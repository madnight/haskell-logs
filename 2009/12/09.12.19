00:00:34 <kmc> you can also satisfy the requirement by releasing source, and you're not required to license the source in an free-software way
00:00:40 <copumpkin> yeah
00:02:35 <copumpkin> ooh, /me reads about a view of monads he hadn't come across before
00:04:00 <c_wraith> hmm
00:04:09 <c_wraith> but that wasn't actually a problem for gmp on linux, anyway
00:04:14 <c_wraith> since gmp was dynamically linked
00:04:22 <c_wraith> it was a problem for other haskell packages, of course
00:05:44 <kmc> copumpkin, a monad is an enchilada?
00:05:53 <copumpkin> an algebraic theory, actually, but close
00:05:53 <kmc> or perhaps a taquito?
00:06:00 <Zao> Doesn't 6.12.1 have integer-simple if you want to?
00:06:03 <c_wraith> I thought they were chimichangas
00:06:08 <copumpkin> Zao: yep
00:07:17 <roostaj> anyone else listening to the mars volta and looking for "REU" sites? :P
00:07:47 <kmc> Zao, yeah, that's how we got on this topic
00:09:16 <mtnviewmark> kmc - I believe you once said: "a monad is like a train filled with jello, traveling backward in time"
00:09:54 <copumpkin> lol,
00:09:55 <mtnviewmark> or perhaps it was "a monad is like an invisible train, traveling backward in time, made of jello"
00:09:59 <copumpkin> "John Baez: We read above: “One can turn monads into adjunctions and adjunctions into monads, but one doesn't always return where one started.” This suggests that there is something like an adjunction between monads and adjunctions! What’s the precise story?"
00:10:08 <c_wraith> Why must everyone make this simple?  Monads should be taught as hard, in order to scare people away.
00:10:21 <copumpkin> "As evidence, note that the Kleisli category gives the initial object among adjunctions that give rise to a specified monad, while the Eilenberg-Moore category gives the terminal one."
00:10:51 <kmc> @quote inverses
00:10:51 <lambdabot> PhilipWadler says: To see that "in" and "out" are inverses, stare at the following diagram
00:11:03 <copumpkin> I think this stuff is pretty awesome
00:11:12 <copumpkin> the more I learn the cooler it is
00:23:10 <mmorrow> copumpkin: so wait, it's saying that this category has {obj:=Category,(->):=Adjunction}, right?
00:23:18 * mmorrow double checks himself
00:24:10 <mmorrow> and  "This suggests that there is something like an adjunction between monads and adjunctions!"
00:24:13 <mmorrow> is saying
00:25:03 <mmorrow> (the category of monads) and (the category of adjunctions) are two of the objects in this {obj:=Category,(->):=Adjunction}
00:26:01 <copumpkin> not sure I understand your notation
00:26:09 <mmorrow> and there is a (->) in this category between them, which is an adjunction because that's what the morphisms are
00:26:27 <mmorrow> copumpkin: so in the second quote
00:26:28 <copumpkin> oh I see
00:26:37 <copumpkin> it's a record notation sort of, and (->) is a name
00:27:05 <mmorrow> i was trying to pinpoint what category the Kleisli and Eilenberg-Moore categories were initial and terminal objects of
00:27:53 <mmorrow> then seeing if this category actually the category the first quote references at the ens
00:27:56 <Cale> They're initial and terminal objects of a category of adjunctions which give rise to a specific monad.
00:27:58 <mmorrow> *end
00:28:08 <Cale> It's not actually the categories themselves which are the objects
00:28:11 <Cale> It's the adjunctions
00:28:14 <mmorrow> yeah, ok
00:28:18 <copumpkin> so the morphisms are morphisms of adjunctions
00:28:20 <mmorrow> that's what i was unclear about
00:28:22 <copumpkin> do those have a name?
00:29:05 <mmorrow> copumpkin: (->) !
00:29:08 <copumpkin> :P
00:29:12 <mmorrow> :)
00:29:12 <copumpkin> http://en.wikipedia.org/wiki/Monad_%28category_theory%29#Monads_and_adjunctions has a bit more
00:30:28 <Cale> Morphisms between adjunctions are something which I haven't spent a lot of time looking at, but it seems interesting.
00:30:59 <mmorrow> yeah
00:31:14 <copumpkin> I was just poking around ncatlab and found that baez quote which seemed particularly weird :)
00:31:27 <copumpkin> also, he's apparently joan baez' cousin!
00:31:51 <mmorrow> :o
00:31:56 <dcoutts> napping: there's a cabal-install 0.8 pre-release available, it has a bootstrap script, or you can build it using your existing ghc 6.10
00:32:11 <Cale> I only know a John Baez.
00:32:34 <Cale> oh, hmm
00:32:42 <Cale> folk singer
00:33:12 <mmorrow> hippies!
00:33:15 <copumpkin> lol
00:33:18 <mmorrow> heh
00:33:46 <Adamant> s/hippies/professional complainers :P
00:34:14 <Adamant> there's a newspaper clipping of Joan Baez protesting something silly back in high school
00:35:11 <napping> dcoutts: I was building it under a new installation of 6.12, and several dependencies the bootstrap script didn't cover were missing
00:35:31 <Cale> It's interesting how categorical notions are so general that they end up capturing themselves in funny sort-of-recursive fashions.
00:35:40 <dcoutts> napping: yeah, I just updated the bootstrap script yesterday
00:37:22 <Cale> A small category is a monad in the 2-category of spans of sets.
00:37:28 <copumpkin> :o
00:38:04 <kmc> @quote hippies
00:38:04 <lambdabot> No quotes match. I've seen penguins that can type better than that.
00:38:22 <kmc> @remember Cale A small category is a monad in the 2-category of spans of sets.
00:38:22 <lambdabot> Done.
00:38:23 <copumpkin> someone should create a domain-specific graph of CT knowledge (in such a way that a computer can reason about it)
00:38:52 * Cale suddenly really hopes that he didn't mess that up given that it's 3:38 am :)
00:39:01 <Cale> I'm pretty sure that's right anyway
00:39:41 <copumpkin> if you did, someone on the internet will have been wrong
00:39:49 <Cale> heh
00:40:44 <dmwit> So, how long does it take for Hackage to build documentation?
00:43:46 * hackagebot upload: sgf 0.1 - SGF (Smart Game Format) parser (DanielWagner)
00:44:00 <copumpkin> :o
00:44:15 <copumpkin> dmwit: I think it happens once or twice a day, but nobody knows the times (or they aren't fixed)
00:44:24 <dmwit> Seems I'm going to have to mirror the docs on dmwit.com for a bit.
00:52:25 <copumpkin> dmwit: omg <4 constraint on base!
00:52:36 * dmwit shrugs
00:52:43 <dmwit> It was just a guess, did it break things on you?
00:52:54 <copumpkin> nope, just noticed it on the hackage page
00:53:38 <dmwit> Hackage wouldn't let me upload without an upper-bound on base. =P
00:54:07 <dmwit> NOW, with way fewer double-negatives! "Hackage required an upper-bound on base."
00:57:48 <copumpkin> preflex: seen FunctorSalad
00:57:48 <preflex>  FunctorSalad was last seen on #haskell-blah 13 days, 6 hours, 28 minutes and 2 seconds ago, saying: and too lazy to get it tested...
00:57:52 <copumpkin> where'd he disappear to?
00:58:28 <roostaj> seen god
00:58:32 <Zao> Maybe he's secretly HaskellLove? :)
00:58:34 <roostaj> preflex: seen god
00:58:35 <preflex>  god was last seen on ##c++ 76 days, 9 hours, 53 minutes and 9 seconds ago, saying: I don't really know either actually
00:58:44 <roostaj> lmfao
00:58:47 <copumpkin> damn, there went my faith
00:58:53 <roostaj> screencap
01:27:06 <Phyx-> i'm getting an error "Could not find module `Network.BufferType'" even though i have network installed. odd...
01:28:59 <dmwit> Phyx-: Is the package hidden, e.g. by your .cabal file?
01:29:31 <dmwit> Also, Network.BufferType doesn't seem to be a module in the network package.
01:29:39 <Phyx-> dmwit: no it's not.
01:29:48 <Phyx-> dmwit: odd, this code was working a few days ago
01:29:54 <Phyx-> then i updated a few packages
01:29:56 <Phyx-> and poof
01:30:33 <dmwit> Well, you should maybe figure out why it thinks Network.BufferType is a module name first.
01:30:51 <dmwit> Because hackage claims that there has been no Network.BufferType module ever in the network package...
01:31:09 <Phyx-> hmm
01:32:34 <Phyx-> dmwit: but there is a Network.Browser in HTTP right?
01:32:37 <Phyx-> it can't find that either
01:33:29 <dmwit> It sounds to me like either a local vs. global package thing or a ghc-version mismatch.
01:33:33 <dmwit> How are you compiling?
01:33:46 <Phyx-> dmwit: ah, BufferType is in HTTP, and for some reason, that was uninstalled
01:34:11 <dmwit> ok, great =)
01:34:52 <Phyx-> let's see if it runs, last time i got an error, that i want to to use network 2.2.1.4, and i hide 2.2.1.5 but it tries to link that anyway
01:35:35 <Phyx-> my quickcheck is gone too...
01:35:45 * Phyx- wonders what happened to his package config
01:37:27 <Phyx-> great, works now, also links the right version of network :)
01:38:30 <Phyx-> dmwit: thanks, lol, i would have kept looking for it in network otherwise
01:38:45 <dmwit> cheers =)
01:44:41 <Phyx-> that's odd.. when does a call to killThread block?
01:46:58 * roostaj yawns
01:48:13 <Lemmih> Phyx-: It should block until the exception has been raised in the target thread.
01:48:51 <Phyx-> Lemmih: but it seems to be blocking indefinitely
01:49:18 <Lemmih> Phyx-: That can happen if the thread is blocking exceptions or is making a blocking foreign call.
01:49:47 <Phyx-> Lemmih: ah ok
01:49:54 <Phyx-> thanks :)
01:57:47 <Phyx-> @cabal info hs-plugin
01:57:48 <lambdabot>   bzzt.
01:57:55 <Phyx-> @cabal info hs-plugins
01:57:55 <lambdabot>   bzzt.
01:57:59 <Phyx-> hmm
01:58:10 <Phyx-> @package info hs-plugins
01:58:11 <lambdabot> http://hackage.haskell.org/package/info hs-plugins
01:58:15 <Phyx-> lol!
01:59:14 <Phyx-> oh, it's just called plugins now
01:59:26 <Phyx-> now/always
02:18:43 <Raevel> hmm, i'm a little hesitant to this warning for discarding return values in do... what *do* you guys think?
02:19:07 <dmwit> I think it's a Pretty Good Idea.
02:19:26 <Twey> What warning is that?
02:19:28 <Raevel> my parsec code would turn very ugly
02:19:43 <Twey> You mean you have to keep every return value?
02:19:52 <Raevel> Twey: do a; b should be do _ <- a; b if a returns non-()
02:19:56 <dmwit> Twey: No, of course not.
02:20:00 <Twey> x.o
02:20:03 <Twey> Why on Earth?
02:20:12 <Raevel> ocaml does that too, iirc
02:20:28 <dmwit> It keeps you honest.
02:20:42 <Raevel> and hurts my eyes :-(
02:20:43 <dmwit> More realistically, it would become "do a_; b".
02:20:43 <Twey> It's really pointless.  And not in a good way.
02:20:53 <Twey> Egh.
02:21:14 <Twey> It's just silly.  This is what we have >> for in the first place.
02:21:15 <Raevel> dmwit: it does not warn if var is suffixed with _?
02:21:32 <dmwit> Raevel: Not if you write "a_ = a >> return ()". ;-)
02:21:33 <Twey> Raevel: The point is that everyone would have to develop non-returning _ variants of every single action.
02:21:51 <Raevel> oh, duh
02:21:55 <Twey> Which someone somewhere seems to think is a good idea
02:22:04 * Twey eyes people suspiciously.
02:22:20 <Raevel> uh, i forgot the name, what's it called when types are added to varnames?
02:22:24 <dmwit> You know, I think it's reasonable to want that kind of warning in some code.
02:22:26 <Twey> Hungarian notation?
02:22:37 <Twey> dmwit: For example?
02:22:42 <Raevel> that's it
02:22:46 <Raevel> poor hungarians
02:22:49 <Twey> Hehe
02:23:01 <dmwit> I dunno.
02:23:09 <dmwit> I'm just saying it's not *crazy*.
02:23:20 <Twey> dmwit: Well, I can't think of any, and you can't think of any… :þ
02:23:37 <dmwit> Even if it seems annoying for some one-offs, it does give a good indication of Code Smells in production code, I would say.
02:24:02 <Twey> Why?  We often run things and discard their return values.
02:24:28 <dmwit> Should we, though?
02:24:36 <dmwit> Presumably they're returning those things for a reason.
02:24:39 <Twey> putStr "Press any key to continue… " >> hFlush >> hGetChar
02:24:51 <Twey> They're returning them because they might be useful
02:24:59 <dmwit> I dare you to find production code that includes that. ^_^
02:25:02 <Twey> That doesn't mean that they're *always* useful or relevant
02:25:04 <dmwit> more like:
02:25:14 <Twey> Er, s/hGetChar/getChar/
02:25:26 <dmwit> putStr "Abort, retry, fail?" >> hFlush >> hGetChar >>= abortRetryOrFail
02:25:36 <Twey> Different use-cases
02:25:38 <Raevel> Twey has funky utf chars
02:26:12 <dmwit> It's been a long time since I used a program that waited for a key and didn't care which one you pressed.
02:26:13 <Twey> ‘Press any key to continue…’ is used when you just want to show the user something and not have it scroll immediately off the screen
02:26:22 <dmwit> long time = more than 5 years
02:26:38 <dmwit> Nah, a pager is used when you want to show the user something without it scrolling off the screen.
02:27:00 <dmwit> Or better yet, nothing at all, let the user hit the scroll lock when they want to see something.
02:27:19 <dmwit> (or pipe it to a pager if that's they're thing)
02:27:29 <dmwit> augh
02:27:30 <dmwit> their
02:27:40 <dmwit> The internet is corrupting my grammar. =(
02:28:33 <Raevel> i spent a lot of my exam today trying to distinguish "zeros" and "zeroes" and finally decided that zeroes is a verb
02:31:47 <Twey> Raevel: They're both ‘zeroes’
02:31:57 <Raevel> really? :-(
02:32:48 <Raevel> wiktionary says zeros is valid at least!
02:33:23 <Twey> I've never seen ‘zeros’ as a plural, though it doesn't look too terribly wrong
02:34:54 <Raevel> okay, staying on topic: i wish scion would be updated to support 6.12
02:35:01 <Raevel> tried to get it compiling but failed
02:37:49 <Raevel> if only i had scion so i could debug easier
02:39:10 <sohum> :t fix
02:39:11 <lambdabot> forall a. (a -> a) -> a
02:39:18 <sohum> fix (*1)
02:39:31 <sohum> > fix (*1)
02:39:35 <lambdabot>   mueval-core: Time limit exceeded
02:39:39 <sohum> > fix (0*)
02:39:43 <lambdabot>   mueval-core: Time limit exceeded
02:51:03 <dsdeiz> hi! am i understanding it correctly? when i do [1,2,3,4] : b.. b would contain the list? :-/
02:51:22 <Raevel> yes
02:51:40 <Raevel> @type [1,2,3,4]:[]
02:51:42 <lambdabot> forall t. (Num t) => [[t]]
02:51:47 <c_wraith> Uh.  that only works if you have a list of lists
02:51:56 <Raevel> @type [1,2,3,4]++[]
02:51:57 <lambdabot> forall t. (Num t) => [t]
02:52:05 <Twey> Of Num instances ☺
02:54:39 <Raevel> Twey: did you use to hang out in ##javascript?
02:54:53 <Twey> I did
02:55:53 <Raevel> cool! well, in some sense at least
02:57:45 <Twey> Raevel: Why's that?  I think I saw you there a while, too ☺
03:01:36 <Raevel> yep yep i hung out there for a couple of years i think, until i realized it actually made me dumber :-P
03:02:35 <Twey> Haha
03:03:40 <Twey> I stayed until that chappie from EFNet joined and started proclaiming in a most churlish manner that standards are to be broken when one feels like it :þ
03:04:49 <Raevel> who was that? probably someone who also hung out in the qnet channel, those guys were plain evil
03:04:51 <c_wraith> Well.  GHC 6.12.1 newly violates the haskell 98 standard.  Because it felt like it. :)
03:05:09 <Raevel> c_wraith: how?
03:06:00 <c_wraith> "Lazy I/O now throws an exception if an error is encountered, in a divergence from the Haskell 98 spec which requires that errors are discarded (see Section 21.2.2 of the Haskell 98 report). The exception thrown is the usual IO exception that would be thrown if the failing IO operation was performed in the IO monad, and can be caught by System.IO.Error.catch  or Control.Exception.catch. "
03:07:48 <vegai> whoa, that's a very good thing
03:08:07 <c_wraith> yes, it is.  I didn't say breaking the spec was wrong, in this case. :)
03:08:19 <vegai> I've been bitten by that more than once in production code
03:08:34 <vegai> mostly because of my own fault, though, but still...
03:11:33 <Lemmih> ?slab llvm
03:11:34 <lambdabot> I won't; I want to go get some cookies instead.
03:12:05 <c_wraith> ?slack ware
03:12:05 * lambdabot clobbers ware with an untyped language
03:13:06 <sohum> hm. after working out all the scaffolding around my current project, including the fileformat parsers and the main interacter and commandline...
03:13:16 <sohum> I /just/ realised I have /no/ idea how to do the actual meat
03:13:21 * sohum sigh
03:13:38 <Raevel> haha i joined ##javascript for the lulz and some poor guy is trying to figure out why his regex returns "different results" for "the same input"
03:13:52 <Twey> G'duh?
03:14:29 <c_wraith> javascript regexes are scary.  It disturbs me that all javascript regexes using /whatever/ syntax are a shared global.
03:14:50 <Raevel> hmm, shared global?
03:15:06 <sohum> I thought only perl did that monstrosity?
03:15:42 <c_wraith> yeah.  if you do something like "var a = /foo/; var b = /bar/;", both a and b are the same regex, which is currently /bar/
03:16:25 <Raevel> 12:10 <randomgit> (i mean, maybe its some weird parser glitch, but no)
03:16:54 <Raevel> c_wraith: really? that sounds too bad to be true
03:17:38 <c_wraith> it's that bad.  and true.  Fortunately, once you know about it, you can work around it using the explicit constructor.
03:18:03 <Raevel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14417#a14417
03:18:23 <Asztal> var a = /foo/; var b = /bar/; alert(a("foobar")); alert(b("foobar"));
03:18:31 <Asztal> ^ that gives me "foo" then "bar"
03:19:05 <c_wraith> bah.  I know I've run into sharing issues before.
03:19:43 <Asztal> JavaScript's scoping could be to blame
03:19:57 <c_wraith> maybe they were just with that one horrendous call...  What's the one that store state in the regex object?
03:20:04 <Raevel> i have used regex literals for ages and never ran into any problems :-)
03:20:42 <sohum> hah, I never knew regex literals were functions
03:21:12 <Raevel> oh, me neither actually
03:21:14 <Raevel> awesome
03:21:37 <Raevel> that's a funny thing about js, i've pretty much read the entire ecma spec but still missed stuff
03:22:14 <Raevel> hmm
03:22:15 <Raevel> >>> /a/ instanceof Function
03:22:15 <Raevel> false
03:27:29 <Jonno_FTW> I am doing this: http://projecteuler.net/index.php?section=problems&id=268
03:27:40 <Jonno_FTW> how long do you think it will take to calculate it using this:
03:28:02 <Jonno_FTW> answer = length [n|n<-[1..(10^16)-1], (length $ factors n) >= 4]
03:28:40 <Jonno_FTW> factors =filter (`elem` primesTo100) . map product . sequence . map (\(x,y) -> map (x^) [0..y]) . primePowerFactors
03:30:12 <Cale> 10^16 is pretty big
03:30:18 <Jonno_FTW> yeah
03:30:20 <MoALTz> if you have to ask then you don't get it
03:30:23 <Jonno_FTW> so a long time?
03:30:28 <Cale> yes
03:30:37 <Jonno_FTW> the factors are pretty fast
03:30:45 <Jonno_FTW> prime factorisation
03:31:12 <Raevel> oh now i remember why javascript was fun, schooling the newbies
03:31:15 <Cale> Let's suppose that factors and length combined spend an average of a nanosecond
03:31:24 <Cale> Then it will take 115 days.
03:31:27 <Jonno_FTW> wow
03:31:39 <Jonno_FTW> what if i cut down the search field?
03:31:42 <MoALTz> you could optimize so that they quit if they don't have 4 unique factors after getting to 100... but it won't do you any good - the number of terms involves is too much (iirc)
03:32:14 <Cale> Generate and test won't work, you really must count them some other way
03:33:12 <MoALTz> i wasted a day trying to attack that problem... kept missing the "colliding terms" (basically you can say how many terms involving certain factors there will be... but other factors will involve the same terms at some point and thus give an overcount)
03:34:02 <Twey> sohum: They're not — the function-calling syntax for regexes is a Mozilla extension
03:34:42 <Jonno_FTW> what do you mean by colliding terms?
03:34:55 <Cale> Well, principle of inclusion/exclusion.
03:35:07 <Jonno_FTW> hmm?
03:35:08 <MoALTz> it's like asking "how many terms 2*3*7 will there be in 10^16?" - you can get the answer easily, but if you then ask "how many terms are there in 5*7*11?" then the answer will involve some of the answers that were in the 2*3*7 answer... which you have to exclude (and i couldn't figure out a simple and small way to do this)
03:35:25 <Twey> Subtraction?
03:35:34 <Jonno_FTW> nub?
03:35:49 <Cale> Subtract the count of those which have both
03:35:51 <Jonno_FTW> or is the list to big?
03:36:21 <sohum> Twey: aah. dammit, and that's a pretty good idea, too
03:36:25 <Cale> (because those are the ones you double-counted)
03:37:21 <MoALTz> Cale: then you get ones from 13*17*19 for example. i couldn't see an easy way around this (i probably missed something)
03:38:27 <MoALTz> i'm rather rubbish at stats
03:38:34 <Cale> This isn't stats :)
03:38:43 <Cale> It's combinatorics mixed with number theory
03:41:06 <Cale> Suppose we have a bunch of finite sets A_1, A_2, ..., A_n
03:41:19 <Cale> and we want to know the number of elements in their union
03:42:25 <Jafet> Try Bernstein "Enumerating and counting smooth integers"
03:43:42 <Cale> Then it's (the sum over 1 <= i <= n of |A_i|) - (the sum over 1 <= i < j <= n of |A_i intersect A_j|) + (the sum over 1 <= i < j < k <= n of |A_i intersect A_j intersect A_k|) - ... + (-1)^(n-1) |A_1 intersect ... intersect A_n|
03:44:35 <Jonno_FTW> that book
03:44:37 <Jonno_FTW> http://cr.yp.to/papers/epsi.pdf
03:44:42 <Cale> So if we can count the sets, and all the various intersections of the sets, it gives us a way to count the union.
03:47:46 <Cale> hmm
03:49:33 <Cale> Unfortunately, I think that's probably even worse, since the number of subsets is quite large
03:51:02 <Cale> Oh, of course
03:51:04 <Cale> duh
03:52:34 <Cale> Counting all the numbers which are not divisible by four distinct primes seems a good deal simpler. :)
03:53:09 <MoALTz> Cale: thought of that, and it's not small either (although a lot smaller :)
03:56:28 <Cale> Ah, but you can sort of just search along the boundary
03:56:48 <Cale> hmm
03:57:29 <MoALTz> you cannot. if you search along with every possbility of 4 primes under 100 then you still end up with 3+ million pieces AND collisions (this is about as far as i got... haven't worked on it since)
03:57:49 <MoALTz> this does seem closer to the solution though
03:59:58 <Cale> I mean that you only have to find the combinations which are close to 10^16
04:01:24 <MoALTz> hmm
04:02:21 <Cale> For each k from 0 to 3, pick k distinct primes, and then you sort of search through the space of exponents, looking for the largest exponents which will still fit under 10^16.
04:03:06 <Cale> Of course, that's still a bit of searching, but if you do it in an orderly fashion, you don't have to go looking through all triples, say.
04:09:33 <Baughn_> @remember edwardkmett Most monad tutorials are written by people who barely understand monads, if at all, but unfortunately nothing can stop someone from writing a monad tutorial. We've tried, there was blood everywhere.
04:09:33 <lambdabot> I will remember.
04:09:57 <Jonno_FTW_> monads are like burritos really
04:10:17 <Baughn_> No, monads are like applicative functors that are also incestous
04:10:25 <Twey> Like lots of burritos chained together at the ends
04:10:35 <Jonno_FTW_> om nom nom nom
04:11:08 <Jonno_FTW_> foldr (nom) 0 burritos
04:11:47 <Jonno_FTW_> wait, actually
04:11:51 <Jonno_FTW_> foldr (nom) om burritos
04:12:03 <Baughn_> Excessive parantheses
04:12:17 <Jonno_FTW_> excessive eating a list of burritos
04:12:20 <Baughn_> Also, it's a collapsive function
04:12:29 <Baughn_> foldl nom om burritos
04:12:34 <Jonno_FTW_> i end up with one huge burrito
04:12:43 <Baughn_> Yes, which can't be divided
04:12:55 <Jonno_FTW_> so, one huge mouthful
04:13:04 <Baughn_> So when using foldr, you first build a huge stack of burritos, and then finally make a single big one from them
04:13:08 <Baughn_> And the stack might topple
04:13:16 <Baughn_> foldl is better, it'll just add them one by one
04:13:22 <Cale> Ohh... so full... I think I'm going to unfoldr.
04:13:28 <Jonno_FTW_> plateoverflow
04:13:32 <b_jonas> lol
04:14:06 * Baughn_ wonders if it says horrible things about him that he found this conversation funny
04:16:08 <Twey> Hehehe
04:16:36 <Phyx-> wow my Regexp skills suck
04:16:41 <Jonno_FTW_> so it's better to explain folds in terms of burritos rather than monads?
04:17:40 <Raynes> I want a burrito.
04:17:46 <Raynes> Jonno_FTW_: Share!
04:18:12 <Jonno_FTW_> i already foldl the burritos i had
04:18:28 <Jonno_FTW_> unfoldr burritos
04:18:29 <Phyx-> unfold them!
04:23:38 <Jonno_FTW_> enumFromTo kitchen burritos
04:24:52 <Baughn> Jonno_FTW_: Type error. Inferred type: Burrito. Expected type: BurritoMaker.
04:25:20 <Jonno_FTW_> it appears by making an error i got my hand chopped off
04:25:45 <Baughn> That's what you get for using usafeMakeBurrito.
04:26:10 <Jonno_FTW_> oh the naive optimisations it claims to provide
04:28:07 <Cale> unsafeMakeBurritoInTheMicrowaveAndForgetIt'sSuperHotInsideAndBurnYourMouth
04:28:46 <stroan> and they say Haskell is bloated..
04:29:51 <gio123> Cale: hi
04:30:13 <Jonno_FTW_> welcome to Haskell's kitchen
04:34:12 <Jonno_FTW_> should this decyph in this return the correct decyphering given the correct key? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14421#a14421
04:36:09 <Phyx-> hm. what's up with all the 404 errors on online docs on hackage
04:44:25 <Jonno_FTW_> OR
04:45:16 <Jonno_FTW_> furthermore, how can I get a list of all permutations of 3 lowercase chars?
04:46:06 <Twey> > sequence "abc"
04:46:07 <lambdabot>   Couldn't match expected type `m a'
04:46:07 <lambdabot>         against inferred type `GHC.Types...
04:46:21 <Twey> D'oh
04:46:46 <Twey> > sequence $ replicate 3 "abc"
04:46:47 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
04:47:09 <Jonno_FTW_> hmm, but i need all 26 lower case characters
04:47:17 <Jonno_FTW_> but is that too much
04:47:28 <Twey> No, of course not
04:47:34 <Twey> > sequence $ replicate 3 ['a' .. 'z']
04:47:35 <lambdabot>   ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","a...
04:47:40 <Jonno_FTW_> thanks
04:48:00 <Twey> They're not generated until you need them, anyway :þ
04:48:07 <Jonno_FTW_> awesome
04:48:39 <stroan> sequence was not a function I knew about
04:48:48 <stroan> excellent :)
04:48:49 <Jonno_FTW_> is it safe to assume that the word "the" will appear in the decyphered text?
04:49:05 <Zao> Some do.
04:49:23 <Jonno_FTW_> text = head  [(n,k)|k<- sequence $ replicate 3 ['a'..'z'] ,n <- decyph k, "the" `elem` n]
04:49:40 <Zao> My approach filters out texts that contains "non-english" characters.
04:49:41 * Cyneox re
04:49:52 <Zao> But my set of "non-english" doesn't match the set used for the text.
04:50:14 <Zao> Personally I think this problem is horribly underspecified and vague.
04:50:37 <Jonno_FTW_> me too
04:51:25 <Zao> My best match matches 1172/1201 characters at best.
04:51:35 <Jonno_FTW_> hmm
04:51:36 <Zao> I suppose I could just go with the one that matches the most or so.
04:51:39 <Jonno_FTW_> perhaps a comma is contained
04:51:49 <Twey> stroan: It's a generic monadic function — permutations is just its effect in the list monad
04:52:03 <Zao> Jonno_FTW_: Better include ;:"' and other silly glyphs too.
04:52:09 <Jonno_FTW_> yep
04:52:11 <Twey> stroan: It ‘executes’ a series of monadic actions in order, returning a list of their results wrapped in the monad
04:52:43 <Jonno_FTW_> my decyph returns the decyphered text as a list of characters
04:53:05 <Twey> i.e. a string ;)
04:53:09 <Jonno_FTW_> yep
04:53:12 <Jonno_FTW_> except
04:53:18 <Jonno_FTW_> my solution thing doesn't work
04:53:25 <stroan> Twey: cheers
04:57:42 <Jonno_FTW_> how come this won't return n as the full decyphered string?
04:57:45 <Jonno_FTW_> decyph keys= map chr $ map (\(x,y)-> bitwiseXOR x (ord y) ) $ zip numbers $ cycle keys
04:57:46 <Jonno_FTW_> brute = [(n,k)|k<- (sequence $ replicate 3 ['a'..'z']) ,n <- decyph k, "the" `elem` n]
05:14:16 <vy> I'm compiling a .hs file via "ghc --make FixStyle", but ghc doesn't produce any executables (except FixStyle.o) despite there exists a "main :: IO ()" function. What should I be missing?
05:15:09 <Igloo> -main-is FixStyle if that's the name of your module
05:15:19 <Igloo> Or just call the module Main
05:16:00 <vy> Hrm... Yeah, I have a different module name. Let me fix that.
05:17:29 <Jonno_FTW_> no help for poor little me?
05:17:58 <Jonno_FTW_> to the stackoverflow mobile!
05:25:21 <Zao> Jonno_FTW_: That shouldn't even typecheck, I'd say.
05:25:42 <Jonno_FTW_> yep
05:25:47 <Jonno_FTW_> but why?
05:27:11 <Phyx-> hmmm. I wonder when GHC will become sentient....
05:27:36 <Jonno_FTW_> oh, all you need to use is: unsafeSKYNET
05:27:52 <Zao> Jonno_FTW_: Doesn't k in decyph k refer to each element of the k list?
05:28:14 <Phyx-> Jonno_FTW_: i can't, John forbade it
05:28:27 <Zao> Similarly, n in "the" `elem` n refers to each element of n, doesn't it?
05:28:34 <Jonno_FTW_> ok
05:28:36 <Twey> No
05:28:43 <Zao> Also, String `elem` String doesn't work anyway.
05:28:55 <Jonno_FTW_> then what do i use?
05:29:03 <Twey> Perhaps you want isInfixOf
05:29:13 <Jonno_FTW_> hmmm
05:29:34 <Zao> > [ t | x <- [0..3], x `rem` 2 == 0]
05:29:35 <lambdabot>   [t,t]
05:29:43 <Zao> > [ x | x <- [0..3], x `rem` 2 == 0]
05:29:45 <lambdabot>   [0,2]
05:29:47 <Jonno_FTW_> :t isInfix of
05:29:49 <lambdabot> parse error on input `of'
05:29:59 <Jonno_FTW_> :t isInfixOf
05:30:00 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
05:30:05 <Zao> Note how the x in the predicate is a single element, not the whole list.
05:30:53 <Jonno_FTW_> uh huh
05:53:08 <PepeSilvia> ja :p
05:56:09 <increpare> anyone else finding hoogle links to be broken today?
05:56:22 <jlouis> increpare: they've been broken for some days now
05:56:35 <increpare> jlouis: ah okay.
05:56:42 <jlouis> increpare: because the 'lastest' part in the url points to nowhere
05:56:52 <jlouis> substitute 'latest' for '6.10.4' and it works
05:56:54 <increpare> aah right
05:56:59 <increpare> updating for 6.12?
05:57:05 <jlouis> Guess so
05:58:21 <increpare> cheers
06:08:03 <burp> is rec somehow a reserved keyword in ghc 6.12?
06:08:13 <burp> HJScript doesn't build.. "parse error on input `rec'"
06:08:29 <Igloo> burp: Yes, with -XDoRec or -fglasgow-exts
06:08:44 <burp> oh ok
06:09:09 <vy> A Haskell driver for MongoDB would be awesome!
06:11:25 <Raevel> how about a wiki page on how to compile broken packages in 6.12?
06:11:46 <burp> better: contact authors to upload fixed versions ;)
06:12:14 <jlouis> or ask the author what there is to be done to fix it
06:12:23 <Jonno_FTW_> is it a good idea to upgrade to 6.12?
06:12:40 <Raevel> well, in the scion case there is a fix in a fork repo on github, but it broke compatibility with 6.10 so it's not in the main repo yet
06:12:45 <burp> I love the fast dynamic linking
06:13:05 <Raevel> Jonno_FTW_: i would wait until most packages are fixed to play nice with it
06:13:10 <leafw> hi
06:13:12 <Jonno_FTW_> ok
06:13:16 <Phyx-> is there a way to force kill a thread? i hate that killThread blocks
06:13:21 <Jonno_FTW_> also, where can I find a changelog?
06:14:18 <increpare> Things always end up feeling messy when I do stuff with random-valued.  Going to use monadrandom this time, though: here's hoping it'll be ace : )
06:14:19 <cnwdup> Jonno_FTW_, http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/release-6-12-1.html
06:14:23 <leafw> I am trying to run the arc challenge gist: http://gist.github.com/260052  , but it fails with "Failed to load interface for `Control.Applicative.Error':". Which library I am missing? apt-file search for Control/Applicative/Error.hi yielded none.
06:14:26 <Jonno_FTW_> thanks
06:14:39 <cnwdup> Jonno_FTW_, I think the changes are amazing.
06:18:13 <byorgey> Jonno_FTW_: if I were you, I would wait at least until a version of cabal-install is released that works with ghc 6.12
06:18:23 <Jonno_FTW_> okie dokie
06:18:27 <byorgey> (which should be pretty soon)
06:18:32 <Jonno_FTW_> i am running GHC on windows
06:18:53 <byorgey> but even so there are still lots of libraries that need tobe upgraded to work with 6.12
06:19:16 <byorgey> actually, I think my advice would be to wait until the new version of the Haskell Platform is released
06:19:17 <increpare> I upgraded recently on osx, in the hope that superclass equalities would be in, but alas not juuust yet. Thankfully haven't encountered any trouble with libraries yet (but sticking pretty close to the core language for now anyway, so)
06:19:42 <byorgey> unless you want to try out some of the new features in 6.12 (and there are some pretty cool ones =)
06:19:53 <increpare> byorgey: any particular ones you'd single out?
06:21:35 <byorgey> increpare: my favorites are Functor, Foldable, and Traversable can now be derived automatically, and tuple sections
06:21:52 <byorgey> there are also apparently lots of parallel improvements if you use that sort of thing
06:21:54 <increpare> derivefunctor, you mean?
06:22:01 <byorgey> yep
06:22:05 <b0fh_ua> Hi there! Can somebody please tell me what am I doing in a wrong way: http://pastebin.com/d6852daec
06:22:09 <byorgey> I/O is now fully Unicode aware...
06:22:12 <increpare> byorgey: yeah, my eyes caught that as well : )
06:22:18 <b0fh_ua> looks like I missed some type inferance?
06:22:22 <gwern> Phyx-: if you want to kill a thread that may be tight looping, there's no way to do so with just one process
06:22:40 <gwern> Phyx-: I discovered this the hardway with mueval; I had to set it up with 2 processes, one to kill the other
06:22:42 <increpare> byorgey: I had some runins with awkward unicode support w/ haskell before, so no doubt it's a good thing.
06:23:03 <byorgey> b0fh_ua: I think you want  (x:xs), not [x:xs]
06:23:16 <byorgey> [x:xs] matches a list containing a single list whose first element is x and rest is xs
06:23:19 <increpare> yeah actually I was just doing something yesterday where derivefunctor would have been pleasant
06:23:51 <b0fh_ua> byorgey: true, thanks
06:23:59 <increpare> byorgey: I think we should introduce an antibracket notation ][:[a] -> a
06:24:14 <increpare> would help out so many beginners : P
06:24:35 <byorgey> increpare: hehe
06:27:15 <syntaxglitch> Are there any guides/references/etc. out there on how to design data definitions in Haskell?
06:27:42 <Phyx-> gwern: :( Thanks, I'll give that a try
06:27:46 <syntaxglitch> I'm trying to do something that seems simple with a bit of enforcing correctness with types, but I'm up to about 6 GHC extensions enabled and a pile of confusing class definitions and there has to be a better way :(
06:27:56 <gwern> Phyx-: if you want to see an example mueval's code should be clear
06:28:13 <increpare> syntaxglitch: let us seeee
06:28:22 <Phyx-> gwern: cool, i'll go take a look at it
06:29:06 <gwern> Phyx-: at least, if anything isn't, tell me and I'll clean it up
06:29:39 <syntaxglitch> increpare, what I'm trying to do is some variation on putting "units" on numbers (like "inches" vs. "meters") and using the type system to make sure I do conversions where needed
06:29:53 <increpare> that should be ok with newtypes and newtypederiving?
06:29:53 <syntaxglitch> I'd paste the code but I don't have it on hand right now and I need to leave in a few minutes
06:30:09 <increpare> i guess until you start multiplying...
06:31:02 <syntaxglitch> Yeah, multiplication should take one dimensionless ratio and one number with a unit
06:31:14 <syntaxglitch> Whereas addition needs two numbers with the same unit type
06:32:10 <syntaxglitch> And ideally I'd like to enforce that with types, not just a data enumeration for unit types that gets compared at runtime
06:32:17 <increpare> Your quantities aren't all scalar then?
06:33:03 <increpare> if they're all scalar, you might be able to get by with GADTs ok? (people use them for expression trees, and this should be much the same sort of thing I guess)
06:33:28 <increpare> hmm
06:33:37 <syntaxglitch> No, going to need nonscalar values eventually, though probably not much beyond pairs of values
06:34:36 <syntaxglitch> But I'll want to have functions that do math on the 2-tuples that also typecheck for correctness
06:34:54 <increpare> Have you tried w/ GADTs yet?
06:35:24 <syntaxglitch> I've looked at GADTs but I don't think I'm seeing the use for them you have in mind...
06:35:30 * syntaxglitch is still kinda new to Haskell
06:36:16 <b0fh_ua> Guys, if I have a list like this: [(Ord, Int)], how can I get find the tuple where snd value is maximum among the list?
06:36:43 <mauke> Ord is not a type
06:36:58 <mauke> :t maximumBy (comparing snd)
06:36:59 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
06:37:25 <increpare> :)
06:41:25 * increpare re:units - for scalars, at least, maybe one sort of type-signature that seems like it might be useful would be something like
06:41:25 * increpare add :: (Quantity a u) => a -> a -> a
06:42:01 <increpare> mult :: (Quantity a u, Quantity a' u', Quantity a'' u'', u'' ~ Mult u u') => a -> a' -> a''
06:42:21 <increpare> where Mult is some datatype constructor for units...
06:42:28 <Twey> increpare: The numeric prelude has some unit stuff
06:42:30 <b0fh_ua> mauke: (wItem, maxValue) = maximumBy ( compare . snd ) sequence
06:42:36 <syntaxglitch> hm
06:42:42 <syntaxglitch> argh, need to go in a moment here
06:42:44 <increpare> [ you can't use ~ freely just yet though...soon however ]
06:42:49 <b0fh_ua> this doesn't work because it can't match types
06:42:54 <increpare> not yet, but soon!
06:43:03 <increpare> you can do it within a class, I think
06:43:04 <b0fh_ua> Occurs check: cannot construct the infinite type: b = (a, b)
06:43:10 <mauke> b0fh_ua: so why didn't you use my code?
06:43:28 <b0fh_ua> mauke: I am trying to understand things :)
06:43:51 <Twey> http://hackage.haskell.org/package/numeric-prelude
06:44:12 <mauke> @unpl compare . snd
06:44:12 <lambdabot> (\ c -> compare (snd c))
06:44:24 <syntaxglitch> increpare, thanks for your help
06:44:33 <increpare> actually, algebra.units seems handy
06:44:35 <increpare> maybe that'll do you
06:44:36 <mauke> well, that's the same as (\x y -> compare (snd x) y)
06:44:45 <increpare> I haven't used it though.
06:44:58 * syntaxglitch is kinda scared by the numeric prelude
06:45:05 <syntaxglitch> It's way more math-y than I am
06:45:09 <b0fh_ua> mauke: I'm list
06:45:14 <b0fh_ua> *lost
06:45:48 <increpare> syntaxglitch: don't be scared by what you want : P
06:46:23 <syntaxglitch> I tried to use the numeric prelude once for writing some code to extract zeroes from polynomials of high (10-20) degree
06:46:46 <increpare> syntaxglitch: How'd it work out?
06:47:12 <syntaxglitch> Other than not providing exact solutions, it worked
06:47:39 <syntaxglitch> My quick and dirty solution ended up being picking random points in the complex plain, doing N-R iteration to find an arbitrary root
06:47:48 <increpare> k
06:47:54 <syntaxglitch> Then doing polynomial long division with the zero I found
06:48:12 <syntaxglitch> And throwing away any remainder on the assumption that, since I found an approximate zero, there shouldn't be any remainder ideally
06:48:32 <syntaxglitch> Then recurse on the new polynomial of degree n-1
06:49:11 <increpare> ah right: i can see how errors might build up in such a situation
06:49:35 <syntaxglitch> Yeah
06:49:36 <b0fh_ua> mauke: (wItem, maxValue) = maximumBy (\x y -> max ( snd y ) ( snd x ) ) sequence
06:49:39 <syntaxglitch> But it worked well enough
06:49:49 <increpare> getting a tiiny problem declaring an instance of Random... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14424#a14424 ... think the problem should be obvious enough to those who can spot it?
06:49:54 <syntaxglitch> Then I did that on all polynomials of degree 13 with coefficients in [-1, 1]
06:50:03 <syntaxglitch> which is a lot of polynomials
06:50:10 <increpare> heheheheh
06:50:11 <syntaxglitch> And then plotted the roots I found on the complex plane
06:50:14 <increpare> it is a lot of polynomials!
06:50:18 <increpare> get a nice picture?
06:50:37 <syntaxglitch> It had some visible structure, which is nice
06:51:02 <Philonous> Isn't that just 16k polynomials?
06:51:45 <syntaxglitch> Philonous, yeah, still took a little while to find all the roots
06:52:05 <syntaxglitch> In the sense of "okay, run the program, get up to go do something else"
06:52:17 <Philonous> I see
06:52:50 <increpare> oops found my bug... : P
06:54:13 <syntaxglitch> increpare, dunno if this worked or not: http://tinypic.com/view.php?pic=2wf46iu&s=6
06:54:33 <Philonous> I wonder how well NR converges on polynomials of degree >10
06:54:57 <increpare> looks like a bear standing behind a glass coffee-table with his mouth wide open
06:55:01 <syntaxglitch> Philonous, it worked well enough most of the time for me, as that image shows
06:55:58 <increpare> what's with the two empty squares on the y axis?
06:56:05 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14425 <- Will this forall do what I want it to do?
06:56:17 <syntaxglitch> increpare, there are no roots very close to i and -i
06:56:56 <increpare> in a perfect square though? : P
06:56:59 <syntaxglitch> Actually there should be gaps around a lot of roots of unity, but most aren't visible in my plot
06:57:11 <syntaxglitch> The squareness is probably an artifact of my code :)
06:57:11 <increpare> aah right
06:57:16 <Jonno_FTW_> how can i test if any of a list a words are part of another list using isInfix of?
06:57:23 <increpare> that explains some of the other ones
06:58:00 <Jonno_FTW_> eg. any ["abc","xyz"] `isInfixOf` ['a'...'z']?
06:58:13 <increpare> the any shouldn't be necessary
06:58:14 <syntaxglitch> increpare, here's a similar render someone else did--polynomials of degree <= 24, coefficients [-1, 1]: http://math.ucr.edu/home/baez/roots/polynomialrootssmall.png
06:58:15 <increpare> but yeah
06:58:28 <increpare> might want to put them all to the same case first?
06:58:39 <Jonno_FTW_> > ["abc","xyz"] `isInfixOf` ['a'...'z']?
06:58:40 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:58:50 <Jonno_FTW_> > ["abc","xyz"] `isInfixOf` ['a'...'z']
06:58:52 <lambdabot>   Not in scope: `...'
06:58:58 <Jonno_FTW_> > ["abc","xyz"] `isInfixOf` ['a'..'z']
06:58:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:58:59 <lambdabot>         against inferred ty...
06:59:07 <Jonno_FTW_> yeah
06:59:14 <Jonno_FTW_> > any ["abc","xyz"] `isInfixOf` ['a'..'z']
06:59:16 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
06:59:16 <lambdabot>         against inferred ...
06:59:16 <increpare> ah: cooloh
06:59:18 <trofi_> > "hell" `isInfixOf` "hello"
06:59:19 <lambdabot>   True
06:59:20 <increpare> oh not 'a' but "a"
06:59:38 <Jonno_FTW_> but I want to test more than just one word
06:59:38 <increpare> erm
07:00:20 <trofi_> :t any
07:00:22 <increpare> does the order count?
07:00:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:00:25 <luite> is it possible to make a non-stackoverflowing sum without using seq, that works in ghci?
07:00:31 <increpare> aah ok
07:00:46 <trofi_> > any (`isInfixOf` "hello") ["foo", "bar", "hell"]
07:00:48 <lambdabot>   True
07:00:50 <Jonno_FTW_> sum' = foldl' (+) 0
07:00:55 <Botje> luite: foldl', but that's cheating :]
07:00:56 <luite> Jonno_FTW_: that's cheating
07:01:22 <trofi_> -XBangPatterns
07:01:25 <Jonno_FTW_> i was never disqualified for using it before
07:01:27 <luite> that too :p
07:01:43 <trofi_> > let !a = undefined in 1
07:01:44 <lambdabot>   * Exception: Prelude.undefined
07:01:57 <Twey> Jonno_FTW_: ‘sum = foldl' (+) 0’ to start with
07:02:27 <luite> not really, the Prelude implementation doesn't use foldl'
07:02:38 <Jonno_FTW_> sum' xs= foldl' + 0 xs
07:02:39 <trofi_> it's a known bug
07:02:43 <Jafet> @src sum
07:02:44 <lambdabot> sum = foldl (+) 0
07:02:47 <Jonno_FTW_> it's not a bug, it's a feature
07:02:54 <luite> the lambdabot source is just a fake source though
07:03:01 <Jafet> > sum [1..1000000]
07:03:03 <lambdabot>   * Exception: stack overflow
07:03:08 <trofi_> feature!
07:03:10 <Jonno_FTW_> foldl is a crime against folds
07:03:34 <Jonno_FTW_> let sum' xs= foldl' + 0 xs in sum' [1..1000000]
07:03:36 <luite> http://haskell.org/ghc/docs/6.10.4/html/libraries/base/src/Data-List.html#sum
07:03:41 <Jonno_FTW_> > let sum' xs= foldl' + 0 xs in sum' [1..1000000]
07:03:42 <lambdabot>   No instances for (GHC.Num.Num ((a -> b -> a) -> a -> [b] -> a),
07:03:42 <lambdabot>            ...
07:03:50 <luite> I think the one using sum' l 0 is used
07:03:56 <eldragon> is not GHC commiting suicide? hehehe
07:04:04 <trofi_> + -> (+)
07:04:09 <luite> but that one also stack ovrflows
07:04:13 <Jonno_FTW_> > let sum' xs= foldl' (+) 0 xs in sum' [1..1000000]
07:04:14 <lambdabot>   500000500000
07:04:20 <Jonno_FTW_> OH SNAP
07:04:22 <Jonno_FTW_> it worked
07:05:04 <Jonno_FTW_> same goes for product
07:05:14 <luite> yes, but that wasn't my question :p
07:05:26 <trofi_> pure luck
07:05:41 <Jonno_FTW_> set a very large stack size
07:06:04 <Jafet> Start a child ghci process with an appropriate stack size
07:07:49 <luite> hmm, nah that's not what I meant either. I was just wondering if it's possible to evaluate a huge sum lazily, without strictness annotations or seq. if the sum was somehow more balanced, the required stack size would be much smaller
07:08:19 <trofi_> @src foldr
07:08:19 <lambdabot> foldr f z []     = z
07:08:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:10:05 <Jonno_FTW_> do it the smart way
07:10:13 <Jonno_FTW_> and use arithmetic sequnces
07:10:26 <luite> :(
07:11:33 <luite> it's not that I want to calculate huge triangular numbers and refuse to compile my code or something :p
07:12:44 <Jonno_FTW_> > let sum' first last = (last*(first + last)) `div` 2 in sum' 1 1000000
07:12:46 <lambdabot>   500000500000
07:12:46 <Saizan> well, if your expression gets more treeish you'd use O(log n) stack i guess
07:12:54 <Jonno_FTW_> smarts win out
07:13:00 <luite> but if the result of sum [a,b,c,d] would be ((a+b)+(c+d)), the required stack space would be smaller than for (a+(b+(c+d)))
07:13:19 <trofi_> is it smaller?
07:13:27 <trofi_> it is wider
07:14:02 <Saizan> it's smaller because you don't have to expand (c+d) into stack while you compute (a+b)
07:15:13 <Berengal> Stacks don't have width...
07:15:17 <Saizan> though i'm not sure with strictness analysis if (c+d) would go on the heap or the stack
07:15:25 <Berengal> Unless you count parallellism
07:15:28 <Saizan> Berengal: each frame can be of different size though, i imagine
07:15:51 <Berengal> Saizan: True, but I count that towards the height of the stack
07:16:17 <Saizan> true
07:18:35 <Saizan> anyhow, i imagine that storing the fact that the second argument is (c+d) should use less stack than entering two (+) applications, does it make sense?
07:21:09 <Saizan> though i still wouldn't use such a schema for sum, since for strict number types you have foldl' and for lazy ones foldr, here we'd have some middle ground that's suboptimal in both cases
07:22:20 <luite> it's purely theoretical, in reality the strictness analyzer would probably catch this, and otherwise you'd add some strictness annotations
07:22:27 <burp> @hoogle haFD
07:22:28 <lambdabot> No results found
07:24:37 <Absolute0> Is bitSize (0::Word64)  The proper way to use Data.Bits?
07:25:12 <Saizan> in ghc i think of the stack as the distance from the top of the expression to the first redex
07:25:21 <BrianB04> Okay, I offically love Haskell.
07:25:29 <burp> no more haFD in GHC.IOBase?
07:25:34 <Saizan> > bitSize (undefined :: Word64)
07:25:35 <lambdabot>   64
07:25:48 <Absolute0> it works
07:25:52 <Absolute0> i am just curious
07:25:58 <Absolute0> if i am not doing anything extra
07:26:10 <Saizan> well, only the type matters
07:26:16 <Absolute0> right..
07:26:25 <Absolute0> Data.Word has no constructors
07:26:40 <Absolute0> I guess Data.Word just defines type synonyms for ints
07:26:42 <Absolute0> right?
07:26:52 <Absolute0> @src Word64
07:26:52 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:26:53 <Saizan> no
07:27:20 <Absolute0> where can I see the source?
07:27:22 <Saizan> well, some of those are probably the same as Int at low level
07:27:46 <Saizan> it's linked from the haddock
07:27:47 <Absolute0> why penguins? :)
07:27:55 <Absolute0> grandmas would be funnier
07:28:03 <Absolute0> lambdabot runs on linux?
07:28:08 <Saizan> yes
07:28:22 <BrianB04> Absolute0: No, penguins are amusing there, since they have no fingers, and could only smash keys with flippers.
07:29:18 <Saizan> Absolute0: however the point is that bitSize never looks at its argument, so you can use whatever value you like, as long as it's of the type you care about
07:29:30 <Saizan> so undefined :: ThatType always work
07:29:36 <Absolute0> thats not true for (.&.)
07:29:58 <jlouis> (.&.) works for everything in Bits, no?
07:29:59 <Saizan> yeah, .&. is a different beast
07:29:59 <Absolute0> i gave bitSize as an example of using Data.Bits, perhaps I should've mad that more clear.
07:30:14 <Absolute0> class Num a => Bits a where
07:30:23 <Absolute0> Thats how Data.Bits defines all its functions
07:30:30 <Absolute0> hmm
07:30:30 <Saizan> oh, the question is "how do i make a value of type Word64?" ?
07:30:46 <Saizan> or some other type Data.Word ?
07:30:50 <Jafet> > 1::Word64
07:30:50 <Absolute0> no, "How do I use Data.Bits functions properly?"
07:30:51 <lambdabot>   1
07:30:52 <luite> to answer my own question, I have made a sum that doesn't overflow in ghci
07:31:18 <Saizan> Absolute0: i don't know what do you mean by properly, though
07:31:43 <Saizan> you don't like that you need type annotations in some places?
07:31:45 <Absolute0> anyways whats the best way to return a list of all the bits that are on in a Data.Word64?
07:32:07 <jlouis> What is the type of the returned list?
07:32:09 <Absolute0> ie: the indeces of the bits that are on.
07:32:20 <Absolute0> jlouis: [Int]
07:32:37 <jlouis> so we are looking for a Word64 -> [Int] I guess
07:32:38 <Absolute0> ie "1111" -> [0,1,2,3]
07:32:51 <Absolute0> ie "1110" -> [1,2,3]
07:33:05 <Absolute0> I am trying to implement a bitboard in haskell
07:33:11 <Saizan> \word -> [ i | i <- [0..63], testBit word i ]
07:33:12 <jlouis> you mean 15 -> [0,1,2,3] right?
07:33:17 <jlouis> and 14 -> ...
07:33:22 <Absolute0> jlouis: right.
07:33:39 <Saizan> > let word = 15 :: Word64 in [ i | i <- [0..63], testBit word i ]
07:33:40 <lambdabot>   [0,1,2,3]
07:34:09 <luite> > sum [1..1000000]
07:34:10 <lambdabot>   * Exception: stack overflow
07:34:12 <luite> > let reduce [x] = x; reduce xs = reduce (rsum xs); rsum (x:y:xs) = (x+y) : rsum xs; rsum [x] = [x]; rsum [] = []; sum' xs = reduce (0:xs) in sum' [1..1000000]
07:34:15 <lambdabot>   500000500000
07:34:17 <Absolute0> Saizan: isn't that O(n)?
07:34:20 <luite> yay \o/
07:34:25 <Saizan> for a bitboard maybe an UArray Int Bool is best, they are bit packed
07:34:28 <Absolute0> Everyonw can do that.
07:34:34 <luite> > let reduce [x] = x; reduce xs = reduce (rsum xs); rsum (x:y:xs) = (x+y) : rsum xs; rsum [x] = [x]; rsum [] = []; sum' xs = reduce (0:xs) in sum' [a,b,c,d,e,f,g,h,i]
07:34:36 <lambdabot>   0 + a + (b + c) + (d + e + (f + g)) + (h + i)
07:34:49 <jlouis> Absolute0: no, it is bounded by 63
07:34:58 <Twey> > findIndices (== 1) . map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) $ 15
07:35:00 <lambdabot>   [0,1,2,3]
07:35:08 <Zao> Jonno_FTW_: Solved it yet?
07:35:19 <Jonno_FTW_> nearly
07:35:27 <Jonno_FTW_> i'm going to filter out the following
07:35:31 <Absolute0> jlouis: if the input is 16 than you're doing 59 extra comparisons
07:35:32 <Twey> > findIndices (== 1) . map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) $ 14
07:35:34 <lambdabot>   [1,2,3]
07:35:39 <Absolute0> i mean 15
07:35:41 <Twey> Oh, needs to be reversed
07:35:50 <Jonno_FTW_> > map chr ([0..31]++[33..45])
07:35:52 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
07:35:53 <Twey> > findIndices (== 1) . reverse . map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) $ 14
07:35:54 <lambdabot>   [0,1,2]
07:35:57 <Absolute0> can't you do some clever mods and logs?
07:36:01 <Twey> There we go
07:36:03 <Twey> Absolute0: See above
07:36:04 <Jonno_FTW_> all those
07:36:22 <Absolute0> Twey: still not good
07:36:22 <Absolute0> :)
07:36:23 <Twey> > findIndices (== 1) . reverse . map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) $ 5
07:36:25 <lambdabot>   [0,2]
07:36:26 <Twey> Why's that?
07:36:31 <Absolute0> if you have 1000000000000000000000000000000001
07:36:41 <Jonno_FTW_> Zao, my decypher is a bit slow though
07:36:42 <Twey> > findIndices (== 1) . reverse . map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) $ 1000000000000000000000000000000001
07:36:43 <Absolute0> the intermediate 0's are checked unecessarily
07:36:43 <lambdabot>   [0,1,5,7,10,11,13,14,15,19,20,23,27,30,34,35,37,38,41,44,45,48,49,50,54,55,...
07:36:53 <Twey> *headscratch*
07:36:57 <Absolute0> and thats wrong output
07:36:58 <Absolute0> :)
07:37:04 <Twey> Just a bit, yeah
07:37:21 <Absolute0> I think i can do something with mod and logs
07:37:34 <Absolute0> the way you would do it on paper..
07:37:57 <jlouis> I would consider the poor mans solution of testing 4 bits at a time and handwriting the 16 cases
07:38:21 <jlouis> but I am not convinced it is faster
07:39:34 <jlouis> UArray Int Bool is probably the right way to go anyway
07:39:50 <Absolute0> > logBase 2 9
07:39:51 <lambdabot>   3.1699250014423126
07:39:59 <Absolute0> > logBase 2 10
07:40:00 <lambdabot>   3.3219280948873626
07:40:06 <Absolute0> hmm
07:40:13 <Absolute0> what to do with that remainder?
07:40:14 <Absolute0> :)
07:40:59 <Zao> Jonno_FTW_: The bruteforce or the per-attemt xor?
07:41:19 <Jonno_FTW_> the xor
07:41:22 <Absolute0> isn't the use of arrays in haskell bad practice?
07:41:27 <Jonno_FTW_> it will brute force
07:41:37 <Jonno_FTW_> removing bad characters
07:41:39 <Axman6> Absolute0: not if you use them sensibly
07:42:12 <Philonous> Absolute0: Why would it be? The right data type for the right job
07:42:24 <Absolute0> @where UArray
07:42:24 <lambdabot> I know nothing about uarray.
07:42:42 <Absolute0> @where UArray Int Bool
07:42:42 <lambdabot> I know nothing about uarray.
07:42:43 <Twey> > logBase 2 pi
07:42:45 <lambdabot>   1.651496129472319
07:42:46 <leafw> when attpting to installing haskell-platform in ubuntu 9.10, I get: GError: The GLUT-2.1.1.2/Setup script does not exist or cannot be run
07:42:54 <leafw> suggestions welcome ... is a package missing?
07:43:26 <Jonno_FTW_> apt-get install GHC6 should do it
07:43:40 <leafw> I followed instructions from: http://davidsiegel.org/haskell-platform-in-karmic-koala/ which were linked to from http://hackage.haskell.org/platform/
07:43:44 <Jonno_FTW_> :!uname -a
07:43:48 <Saizan> Absolute0: http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.3.0.0/Data-Array-Unboxed.html
07:43:57 <Jonno_FTW_> :! uname -a
07:44:12 <leafw> Jonno_FTW_: GHC6, you mean ghc6 ? And that core haskell package is of course already installed
07:44:18 <Jonno_FTW_> ok
07:44:25 <Jonno_FTW_> i forget
07:45:20 <Absolute0> Saizan: Which modules operate on UArray Int Bool?
07:45:37 <Saizan> Absolute0: click on the IArray link in there
07:46:14 <Saizan> Absolute0: there's also STUArray or IOUArray if you need mutable ones
07:46:36 <Zao> Jonno_FTW_: Mine is just an  zip (cycle key) ciphertext
07:46:47 <vy> cabal-install maintainers in the house?
07:47:00 <Jonno_FTW_> ok, to  check if there is bad characters in the decyphered string I use:   (any (`isInfixOf` n) ['\NUL','\SOH','\STX',....]) == False
07:47:18 <Jonno_FTW_> but it wants to do something with \NUL
07:47:25 <Jonno_FTW_> and won't compile
07:47:37 <Absolute0> how does mutable things work in haskell? The same name can be modified?
07:47:49 <Zao> Isn't that interpreted as \N U L?
07:48:06 <Jonno_FTW_> > ord '\NUL'
07:48:07 <Zao> Hrm no, should be right.
07:48:07 <lambdabot>   0
07:48:10 <Zao> I worked with ords.
07:48:23 <Jonno_FTW_> mine screwed up with ords on those
07:48:28 <Zao> @type isInfixOf
07:48:29 <Jonno_FTW_> as in
07:48:31 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
07:48:42 <Absolute0> is sizeof(UArray Int Bool) == sizeof(Word64) ?
07:49:05 <Jonno_FTW_> (any (`isInfixOf` n) $ map chr [0..31]) == False
07:49:29 <Zao> Jonno_FTW_: What you're testing for there is whether the list '\NUL' (which isn't a list) exists infix in n.
07:49:32 <Saizan> Absolute0: they work in a monad
07:49:56 <Jonno_FTW_> then what do i do?
07:49:56 <Zao> Jonno_FTW_: You probably want elem.
07:50:34 <Jonno_FTW_> any (`isInfixOf` n) ["The","the","and"] works fine though
07:50:50 <Saizan> Absolute0: and Bool unboxed arrays are packed, so an array of size 64 of Bools will use 64 bits plus some for the bounds
07:52:44 <Saizan> (but Word64 doesn't just uses 64 bits either, unless it gets unboxed by the strictness analyzer)
07:53:16 <Jonno_FTW_> any (`isInfixOf` "TheWinter") ["The","the","and"] works fine though
07:53:46 <Zao> Jonno_FTW_: Those are strings.
07:53:58 <Zao> Things in single quotes are Chars.
07:54:53 <Jonno_FTW> > any (`isInfixOf` "TheWinter") ["The","the","and"]
07:54:55 <lambdabot>   True
07:54:58 <Zao> Jonno_FTW_: Those are strings.
07:54:59 <Zao> Things in single quotes are Chars.
07:55:05 <Zao> @type 'x'
07:55:06 <lambdabot> Char
07:55:06 <Jonno_FTW> but
07:55:10 <Absolute0> Whats a good tutorial for using arrays in haskell?
07:55:15 <Zao> @type elem
07:55:15 <Jonno_FTW> > chr 0
07:55:16 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:55:16 <lambdabot>   '\NUL'
07:55:26 <Zao> > 'x' `elem` "omg"
07:55:27 <lambdabot>   False
07:55:30 <Jonno_FTW> should it not treat \NUL as a single char?
07:55:35 <Zao> Jonno_FTW_: It does.
07:55:45 <Jonno_FTW> then why doesn't is like my list?
07:56:03 <Zao> @type any (`isInfixOf` "omg")
07:56:04 <lambdabot> [[Char]] -> Bool
07:56:14 <Zao> Because it expects a list of String.
07:56:20 <Zao> @type any (`elem` "omg")
07:56:21 <lambdabot> [Char] -> Bool
07:56:29 <Jonno_FTW> > any (`isInfixOf` "The\NULWinter") '\NUL'
07:56:30 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
07:56:30 <lambdabot>         against inferred ...
07:56:35 <Jonno_FTW> > any (`isInfixOf` "The\NULWinter") ['\NUL']
07:56:36 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:56:36 <lambdabot>         against inferred ty...
07:57:05 <Zao> > '\NUL' `elem` "omg\NULwtf"
07:57:06 <lambdabot>   True
07:57:43 <Zao> isInfixOf's purpose in life is to check whether a sequence is part of another sequence.
07:57:55 <Jonno_FTW> but i want the whole list of map chr [0..31] to be compared with
07:58:06 <Zao> isInfixOf "fbb" "wtfbbq"
07:58:08 <Zao> > isInfixOf "fbb" "wtfbbq"
07:58:09 <lambdabot>   True
07:59:23 <Saizan> Absolute0: this one is not bad http://www.haskell.org/haskellwiki/Modern_array_libraries
07:59:29 <Zao> > map (`elem` "lol") ['i'..'l']
07:59:31 <lambdabot>   [False,False,False,True]
07:59:34 <Zao> > any (`elem` "lol") ['i'..'l']
07:59:35 <lambdabot>   True
08:00:42 <Jonno_FTW> > any (`elem` "derp\NUL") [chr 0]
08:00:43 <lambdabot>   True
08:02:51 * increpare is finally getting some love form the random monad
08:04:25 <Jonno_FTW> brute = head [(n,k)|k<- (sequence $ replicate 3 ['a'..'z']) ,let n = decyph k, any (`isInfixOf` n) ["hello","The","the","and"], (any (`elem` n) (map chr ([0..31]++[33..43])) ) == False]
08:04:51 <tibbe_> What on earth does: Expected kind `??', but `Handler' has kind `* -> *' mean?
08:04:59 <tibbe_> I know what kind * is, ?? is new
08:05:33 <Zao> Jonno_FTW: Does your replicate do what you think?
08:05:45 <mauke> @kind (->)
08:05:46 <lambdabot> ?? -> ? -> *
08:06:05 <copumpkin> tibbe: ?? is a superkind of * and ?
08:06:10 <Jonno_FTW> yes
08:06:12 <Zao> > replicate 3 "asdf"
08:06:14 <lambdabot>   ["asdf","asdf","asdf"]
08:06:23 <copumpkin> oh wait
08:06:28 <copumpkin> ? is a superkind of ?? and *
08:06:36 <copumpkin> oh no, I fail again
08:06:37 <Zao> I don't quite see how that would generate all possible three letter keys :)
08:06:40 <copumpkin> here, http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
08:06:50 <copumpkin> the naming for kinds is terrible, in my opinion :P
08:07:02 <Jonno_FTW> >take 30 $ sequence $ replicate 3 ['a'..
08:07:07 <Jonno_FTW> >take 30 $ sequence $ replicate 3 ['a'..'z']
08:07:10 <Jonno_FTW> > take 30 $ sequence $ replicate 3 ['a'..'z']
08:07:11 <lambdabot>   ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","a...
08:07:13 <copumpkin> tibbe_: ^
08:07:18 <Jonno_FTW> yes it does what i want
08:07:21 <Zao> Oh, sequence.
08:07:23 <Jonno_FTW> produce all possible keys
08:07:24 <copumpkin> Jonno_FTW: replicateM
08:07:28 <Zao> Missed that, sneaky misuse of the list monad :)
08:07:35 <copumpkin> > take 30 . replicateM 3 $ ['a'..'z']
08:07:36 <lambdabot>   ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","a...
08:07:43 <BONUS> its not misuse, it's beautiful use :)
08:08:02 <Zao> Personally I use [[a,b,c] | a <- az, b <- az, c <- az]
08:08:12 <copumpkin> that doesn't scale nicely
08:08:18 <BONUS> scale?
08:08:18 <copumpkin> what if I asked you for all lists of length 10?
08:08:25 <BONUS> ah you mean like that
08:08:33 <copumpkin> syntactically, I mean :)
08:08:41 <Zao> copumpkin: Just needs some TH :)
08:08:45 <copumpkin> lol
08:08:49 <tibbe_> copumpkin: I have no idea why this type lacks type parameters: type Hander = Socket -> Message -> IO ()
08:08:52 <shambler> > length $ replicateM 3 $ ['a'..'z']
08:08:54 <lambdabot>   17576
08:08:59 <shambler> :C
08:09:02 <tibbe_> copumpkin: where Message doesn't have any type parameters
08:09:02 <Zao> copumpkin: The problem domain is fixed and the genericity is not needed.
08:09:07 <mauke> > 26^3
08:09:09 <lambdabot>   17576
08:09:11 <BONUS> why should that type have parameters?
08:09:20 <Zao> Also, I'm pissed that I didn't come up with the fancy solution :)
08:09:28 <copumpkin> tibbe_: it's expecting Message to take a parameter?
08:09:53 <tibbe_> copumpkin: perhaps. This is Message: data Message = Chunk !S.ByteString
08:09:53 <tibbe_>              | Eof (Maybe SomeException)
08:10:00 <copumpkin> hm, guess not
08:10:03 <tibbe_> copumpkin: hmm, perhaps I'm wrapping SomeException wrong
08:10:08 <copumpkin> tibbe_: can you paste the error and the code that generates it?
08:10:15 <tibbe_> copumpkin: sec
08:10:19 <copumpkin> thanks :)
08:10:39 <Jonno_FTW> damn my thing is rather slow at decrypting
08:11:05 <Twey> That's a handy thing you've got there
08:11:23 <tibbe_> copumpkin: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=14427#a14427
08:11:43 <Jonno_FTW> it does a single decryption in 0.31 seconds
08:11:51 <copumpkin> tibbe_: that is odd
08:12:12 <tibbe_> copumpkin: GHC 6.10.4
08:12:52 <copumpkin> oh
08:12:54 <copumpkin> Hander
08:12:56 <copumpkin> vs Handler
08:13:03 <copumpkin> Handler is provided by Exception
08:13:20 <copumpkin> import Control.Exception hiding (Handler)
08:13:25 <copumpkin> type Handler = ...
08:13:33 <Jonno_FTW> ok now i suspect something is wrong with my decryption
08:13:54 <tibbe_> copumpkin: gah
08:14:00 <Jonno_FTW> after testing all keys on the encrpted string it found none
08:14:03 * tibbe_ swears about unqualified imports
08:14:06 <Jonno_FTW> that would be a solution
08:14:10 <copumpkin> :)
08:14:27 <Absolute0> :)
08:16:18 * Jonno_FTW grumbles about having to use Data.Bits
08:17:04 <Zao> Jonno_FTW: A single function.
08:17:44 <Jonno_FTW> this is what happens when you try and redo the wheel children
08:17:48 <Jonno_FTW> never try anything new
08:17:56 <Jonno_FTW> compilers will still hate you
08:18:40 <Jonno_FTW> in the end; there can only be one Function
08:28:15 <vy> How can I parse a string into an Int?
08:28:36 <copumpkin> > read "123" :: Int
08:28:37 <lambdabot>   123
08:28:45 <burp> "is unusable due to missing or recursive dependencies" .. hm what's this with 6.12?
08:28:58 <vy> copumpkin: Thanks!
08:29:12 <burp> I get these for some packages, though installed + fulfilled dependencies
08:29:36 <copumpkin> burp: sounds like a new cabal. What package are you installing?
08:29:58 <burp> for example oeis
08:31:02 <burp> package oeis-0.2.2-f8c6db0d197237dc0b15879795378f7d is unusable due to missing or recursive dependencies:
08:31:02 <burp>   HTTP-4000.0.4-c5ffb6cbad45b5b946818e0eedf3be81 network-2.2.1.5-074ee1ef4d3afb3476c8742ff08324d8
08:31:51 <burp> maybe I should start with a fresh .cabal
08:32:18 <burp> it grew to an amazing 1.4G anyway
08:32:31 <copumpkin> wow
08:34:35 <aavogt> burp: profiling libs enabled, right?
08:34:49 <burp> no
08:34:56 <burp> but shared
08:35:00 <HaskellLove> Anyone has used Jape?
08:36:21 <Heffalump> HaskellLove: as in Just another proof editor?
08:36:25 <Berengal> Does haskell run any sort of finalization on exit?
08:36:37 <burp> I'm gonna start over with a fresh ~/.cabal
08:36:54 <HaskellLove> Heffalump yep
08:36:56 <Heffalump> HaskellLove: yes
08:37:14 <gwyndyllydd> anyone knows the status of the snow leopard 64 bit port?
08:38:28 <gwyndyllydd> i installed 6.10 from the dmg (32-bit) and tried cabal installing yi, but it failed on template haskell - that's after the options needed for ghc to work on snow leopard.
08:38:30 <copumpkin> gwyndyllydd: it works fine on SL... do you actually need your generated binaries to be 64-bit?
08:39:03 * Axman6 would very much like them to be
08:39:10 <copumpkin> me too
08:40:02 <HaskellLove> Heffalump as I read TAPL and papers related I saw that type systems are first formalized in a premise and conclusion way. I am not new to logic but I far from expert either. I asked a question this morning, once you have the rules like that for the type system is your job done, I mean, you have bnf and you put it in ANTLR for example and whoala. Anyways, I think Jape is good place to start...
08:40:04 <HaskellLove> ...playing around, it might get me closer to understand how type systems work... if you have other sugestions recommend something, a book, video, paper, or whatever.
08:40:13 <Baughn> (Nothing :: Maybe ()) <- Lovely.
08:40:17 <gwyndyllydd> copumpkin: no, i am just learning haskell, to be fair, but i couldnt cabal install yi. thats my main issue at the moment. maybe 6.12 could help, but its hosted on www.haskell.org instead of hackage.haskell.org, and for some odd reason i can't access the www server. i downloaded 6.10 through Tor (!!!!).
08:40:27 <copumpkin> oh
08:40:29 <copumpkin> weird
08:40:42 <Baughn> gwyndyllydd: Oh, you're the reddit fellow?
08:40:54 <Axman6> gwyndyllydd: can you install anything? 6.10 needs modification to work properly on SL
08:41:09 <gwyndyllydd> Baughn: reddit fellow?
08:41:26 <Baughn> gwyndyllydd: Yes. Reddit fellow.
08:41:28 <Jonno_FTW> REDDITOR
08:41:49 <gwyndyllydd> Axman6: i used some options mentioned by simon marlow on a ticket at the ghc trac, and it compiled everything needed for yi EXCEPT template haskell, which failed.
08:42:02 <copumpkin> template haskell comes with ghc
08:42:05 <gwyndyllydd> i know what a redditor is, but i dont see the connection here!
08:42:20 <Axman6> gwyndyllydd: so you patched the ghc, ghci, and has2hs scripts?
08:42:25 * Baughn notes that Yi failed miserably to install on ghc 6.12
08:42:37 <Axman6> Baughn: there's a patch
08:42:50 <Axman6> but, it needs to be vty only
08:42:56 <Baughn> Axman6: I should be eating my own dog-food anyhow.
08:43:16 * Axman6 doesn't make dog food
08:43:30 <copumpkin> omnom
08:43:30 <Axman6> anyway, it's almost 4AM, i need to sleep
08:43:36 <Axman6> night all
08:43:57 <copumpkin> g'night!
08:44:02 <gwyndyllydd> Axman6: i added some options to the ghc script in my /usr/bin. do i need a patch?
08:44:09 <Jonno_FTW> it's 3AM
08:44:13 <Saizan> HaskellLove: TAPL usually first gives you the declarative rules, which are simpler but don't describe an algorithm, and then refines them into a syntax-directed form, that can be easily translated into a traversal on the structure of the term
08:44:14 <Jonno_FTW> where you atr?
08:45:13 <Axman6> gwyndyllydd: you need to add them elsewhere too, including the hsc2hs script
08:45:18 <gwyndyllydd> copumpkin: my error happens when configuring template-haskell-2.4.0.0 with "Could not find module 'Data.Data'"
08:45:46 <gwyndyllydd> Axman6: same options passed to ghc or should i man something?
08:46:07 <Jonno_FTW> if it's 4AM does that put you in australia?
08:46:20 <Jonno_FTW> or New Zealand?
08:46:25 <Axman6> no, they are different. i couldn't tell you what they aare though, because i've installed 6.12. i shall check if they're in there though
08:46:38 <gwyndyllydd> it's 14.45 here, and it's HOT.
08:46:40 <Axman6> Jonno_FTW: australia, yes
08:46:49 <Jonno_FTW> hazah another australian
08:47:12 <HaskellLove> Saizan can I come pm I dont understand a paragraph from the Jape manual you might help please?
08:47:22 <gwyndyllydd> ill try installing 6.12... apparently it comes with the modifications already doesnt it?
08:47:31 <Axman6> gwyndyllydd: you need: --cflag=-m32 --lflag=-m32
08:47:47 <Axman6> yeah, it does. but make sure you install the darcs cabal install first
08:48:17 <Baughn> gwyndyllydd: Be warned, quite a few packages haven't been updated to work with 6.12 yet, or only work in the darcs version - including cabal/cabal-install
08:48:31 <Axman6> (and to get cazbal-install installed using the bootstrap.sh, you need to change CABAL_VER to 1.8.0.2)
08:48:51 * gwyndyllydd head hurts
08:49:11 <Baughn> gwyndyllydd: Well, you had bad timing. We're in the middle of our yearly upgrade chaos. :P
08:49:34 <Saizan> HaskellLove: i don't know about the Jape manual
08:49:41 <Baughn> gwyndyllydd: (Don't worry, steps have been taken to make sure it's less of a problem next time)
08:50:03 <gwyndyllydd> this is one tight coupling between cabal-install and ghc
08:50:08 <Baughn> ..last time was a doozy. And the time before /that/, almost /everything/ broke.
08:50:26 <Axman6> gwyndyllydd: it's not all that difficult to get it all working. just darcs get http://darcs.haskell.org/cabal-install/, then modify the bootstrap.sh file to change the cabal version from 1.8.0 to 1.8.0.2, and run it
08:50:34 <Saizan> 6.10 was easier, i think
08:50:53 <Baughn> Saizan: With the base-3/base-4 mess?
08:51:08 <Baughn> No, 6.12 is the easiest yet.
08:51:19 <gwyndyllydd> Baughn: oh, im not worried. i have been following the haskell community for the past 2 years. i just never took the time to dive into the language. im doing a gentle introduction to functional programming through scheme and erlang before the gargantuan haskell type system overwhelms me.
08:51:21 <Baughn> Sure it breaks cabal-install. Last time we didn't /have/ cabal-install. ;)
08:51:35 <gwyndyllydd> Axman6: seems easy enough. will try!
08:51:41 <EvanR_> @src take
08:51:42 <lambdabot> take n _      | n <= 0 =  []
08:51:42 <lambdabot> take _ []              =  []
08:51:42 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
08:51:47 <EvanR_> :t take
08:51:48 <lambdabot> forall a. Int -> [a] -> [a]
08:51:56 <EvanR_> why is take restricted to Int
08:52:02 <Axman6> gwyndyllydd: yep. once you've got cabal-install installed, you can go ahead and install ghc-6.12.1
08:52:08 <Baughn> EvanR_: Data.List.genericTake
08:52:11 <mauke> EvanR_: because it's fast
08:52:25 <gwyndyllydd> thanks Axman6 and Baughn, it's been very helpful. I'll try it right now.
08:52:31 <EvanR_> but shouldnt the Int version just be automatically generated by the compiler
08:52:55 <Baughn> It often is, but that isn't always possible.
08:53:16 <Baughn> EvanR_: Anyhow.. take being restricted to int is only occasionally a problem on 32-bit machines, and never on 64-bit ones. It's fine like this.
08:53:32 <EvanR_> i know it just seems dirty
08:53:38 <Saizan> Baughn: ? by the time 6.10 was released we had a working cabal-install
08:53:38 <copumpkin> it is
08:53:48 <copumpkin> EvanR_: not many people like it, but change is hard
08:53:56 <Baughn> Saizan: Hm. I may be thinking of 6.8 again..
08:54:20 <Baughn> Saizan: Well, at least it broke a lot more back then. The interface hashing in 6.12 is a godsend.
08:54:37 <Saizan> Baughn: yeah, that's nice
08:57:39 <b_jonas> I don't think it's because it's fast
08:58:02 <b_jonas> I think it's becaues it would cause too much defaulting if it wasn't restricted
08:58:33 <EvanR_> well as it is i have to convert all my Integers to Int to use take
08:58:44 <b_jonas> EvanR_: there's genericTake or whatever it's calloed
08:58:50 <b_jonas> @hoogle genericTake
08:58:51 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
08:58:51 <EvanR_> ah
08:58:58 <mauke> <Baughn> EvanR_: Data.List.genericTake
08:59:01 <b_jonas> only that's not in the prelude
08:59:04 <b_jonas> you have to import it
08:59:12 <EvanR_> yes i heard you
08:59:23 <EvanR_> i just want it by default >_<
08:59:36 <Baughn> You can always make your own prelude
08:59:42 <EvanR_> great idea
09:00:18 <HaskellLove> "Because a function call may not terminate, this program defines a partial function." Does that mean that every function that outputs an infinite list is a partial function?
09:00:23 * Baughn might do that too. He's getting really tired of importing Control.Monad/Applicative
09:01:13 <Baughn> HaskellLove: No, in a lazy language, a function call only fails to terminate if a particular term in its output fails to terminate when forced
09:01:44 <Baughn> HaskellLove: So (repeat 2) terminates, but let x = x in [1,x] doesn't
09:03:35 <HaskellLove> let x = x in [1,x] i tried really does not terminate, but hmm, what happens actually? You define a list with element x which defines itself only in terms of itself so... it keeps trying to bite its tail and never terminate?
09:04:08 <jlouis> in [1,x], we need x to produce the result
09:04:31 <jlouis> so we go to evaluate what x is and hit the infinite loop, yes
09:04:49 <Baughn> However, haskell won't actually do infinite work there; it blocks instead
09:04:53 <Baughn> Well. GHC does.
09:04:57 <HaskellLove> Baughn so the second is partial function right? because not all terms in it are defined...
09:05:03 <Baughn> With -threaded it'll even conveniently detect this.
09:05:12 <Berengal> Or -O2
09:05:13 <Baughn> HaskellLove: Yes
09:05:17 <Berengal> (Or -O1, possibly)
09:05:32 <Baughn> HaskellLove: Wait, partial? No. It's just nonterminating.
09:05:40 <Baughn> HaskellLove: Nor is it even a function. :P
09:05:44 <mjb> Why is it that GHC jumps two minor version for each yearly release? 6.10 -> 6.12?
09:05:45 <Berengal> It's just undefined
09:05:49 <Berengal> Or bottom
09:06:04 <Berengal> mjb: The odd versions are the development versions
09:06:12 <HaskellLove> Baughn well I asked about partial functions and you told me that, but yes it is partial I see now :)
09:06:15 <Baughn> HaskellLove: A function is partial if, for some of its possible input values, (some of) its output is bottom
09:06:38 <Berengal> You could say it's a partial value...
09:06:41 <Baughn> I suppose you /could/ call this a partial function, it just seems odd since it,well, isn't a function
09:06:44 <Baughn> Mm. That.
09:07:15 <medfly> only partially so?
09:07:16 <HaskellLove> well not all input is defined so we can call it partial
09:07:27 <Berengal> HaskellLove: It has no input
09:07:31 * medfly hasn't read the entire discussion ;)
09:08:53 <HaskellLove> Berengal let x = x in [1,x] I think we might agree the input here is x in [1, x] and the output is x
09:09:19 <Berengal> HaskellLove: No, there's no input. It's just a definition
09:09:19 <drostin77> Hello, is there a simple "include" function for Haskell (C: #include, ruby: "require" or "load", python: "import" etc.)
09:09:37 <EvanR_> import
09:09:39 <Zao> import imports modules.
09:09:53 <Jonno_FTW> import Module
09:10:00 <Jonno_FTW> impot Data.Awesome
09:10:03 <Zao> With some effort, #include works too.
09:10:03 <Jonno_FTW> etc.
09:10:26 <drostin77> er import another file in the same directory? I have tried import "test2", import "test2.hs", import test2 and import test2.hs
09:10:30 <drostin77> clearly I am doing something wrong heheh
09:10:39 <Zao> drostin77: Module names start with a capital.
09:10:44 <Zao> module Omg where
09:10:55 <EvanR_> does the file have to have the same name
09:10:58 <Zao> Should live in Omg.hs
09:11:10 <drostin77> ah, even if the file is not capitalized! tricky! thanks!
09:11:18 <HaskellLove> Berengal x = 5 is a definition and it has input 5, the function is "assignment" so, you give it a value 5, and you get output such that x will equal 5, or will point to 5...
09:11:32 <Zao> drostin77: The filename relaxation is probably due to case-insensitive platforms.
09:11:34 <EvanR_> x = 5 is a constant
09:11:36 <EvanR_> theres no input
09:11:47 <drostin77> Zao: Nah on ext4, case sensitive... oh wait i see what u mean
09:11:49 <EvanR_> and = isnt a function
09:11:54 <drostin77> thanks :)
09:12:20 <HaskellLove> ok we are talking here from different perpspectives i will just go back to reading now...
09:12:37 <Zao> drostin77: Say I write a program on a FAT32 box, and then copy it to some inferior OS, having to manually fixup filenames would be silly.
09:12:43 <Zao> :)
09:13:11 <EvanR_> so the capitalization doesnt matter
09:13:13 <drostin77> Zao: Agreed, also agree on the backhanded "some inferior OS"
09:13:52 <drostin77> Thanks, definitely just saved me ~1 hour of non-educational googling!
09:14:36 <SamB_XP_> Zao: by "some inferior OS", I assume you mean non-LFN versions of DOS ?
09:14:59 <SamB_XP_> also, FAT32 isn't the point afaik
09:15:01 <Baughn> I don't think GHC runs on DOS..
09:15:03 <SamB_XP_> VFAT does LFN too
09:15:17 <drostin77> ^^ oops, started something. I'm off to play with haskell:)
09:15:22 <SamB_XP_> Baughn: but do you KNOW that ?
09:15:48 <Baughn> SamB_XP_: Yes.
09:15:57 <Baughn> I feel reasonably confident.
09:15:59 <Zao> When cross compiling a GHC, how many stages is it supposed to succeed with?
09:16:08 <Zao> I can't for the life of me get it to produce a non-segfaulting stage2.
09:16:43 <Baughn> Zao: Isn't stage1 sufficient to straight-compile it the rest of the way on the target?
09:17:24 <Zao> Baughn: Quite possibly. I tried the Follow The Guide Blindly approach first.
09:19:14 <EvanR_> so Monad ReadP is a parser generator?
09:19:36 <gwern> :i Either
09:20:14 <gwern> > let f x = if x==0 then Left x else Right x in Left (f 0)
09:20:15 <lambdabot>   Left (Left 0)
09:20:26 <gwern> @hoogle Either a -> a
09:20:27 <lambdabot> Did you mean: Either a a -> a /count=20
09:20:27 <lambdabot> Prelude id :: a -> a
09:20:27 <lambdabot> Data.Function id :: a -> a
09:20:38 <HaskellLove> "The undecidability of the halting problem is an important fact to keep in mind in designing programming language implementations and optimizations. It implies that many useful operations on programs cannot be implemented, even in principle." The above said, can you tell me some examples?
09:20:42 <gwern> > let f x = if x==0 then Left x else Right x in id (f 0)
09:20:44 <lambdabot>   Left 0
09:20:59 <gwern> > let f x = if x==0 then Left x else Right x in Either (f 0)
09:21:00 <lambdabot>   Not in scope: data constructor `Either'
09:21:06 <EvanR_> HaskellLove: isInfinite :: [a] -> Bool
09:21:16 <mauke> @djinn Either a a -> a
09:21:16 <lambdabot> f a =
09:21:16 <lambdabot>     case a of
09:21:16 <lambdabot>     Left b -> b
09:21:16 <lambdabot>     Right c -> c
09:21:40 <gwern> hm. given Either ConnError String, how would I get String without breaking out a case expression?
09:22:00 <mauke> what if there is no string?
09:22:14 <gwern> \(Right a) -> foo, I guess
09:22:24 <gwern> mauke: are you implying I am being less than principled?
09:22:50 <mauke> :t flip either id $ const ""
09:22:51 <lambdabot> forall a. Either a [Char] -> [Char]
09:23:46 <Saizan> "either (const "") id" was too simple?:)
09:23:54 <mauke> contains parens
09:32:57 <gwern> can't believe I still haven't figured out these alexa forms
09:33:00 <gwern> gott ver dammt!
09:39:31 <gwern> oh my god
09:39:37 <gwern> tell me that didn't just work
09:40:00 <gwern> I had to add a '&submit=' to the end?
09:41:48 <gwern> what is the appropriate expression of blinding rage for having wasted 4 or 5 hours on such a stupid issue?
09:43:45 <Twey> gwern: ‘GWOUARRRRGHHGLARBLAGH!’
09:43:58 <Twey> (it's an ancient Klingon love poem)
09:45:02 * gwern notes that down for future use
09:45:59 <drostin77> "File name does not match module name" (saw: Main, expected: Test)... what is this telling me?
09:46:26 <Twey> drostin77: That you have a module Test in a file called Main.hs
09:46:34 <Twey> Or possibly vice versa
09:46:46 <Twey> And therefore nothing will be able to find your module, so it refuses to compile it
09:47:01 <drostin77> Twey: the file is named Test.hs, the code is "text x = x*2"... just trying to get file includes to work :P
09:47:15 <mauke> drostin77: there are no file includes
09:47:45 <drostin77> mauke: that explains all my troubles:)
09:54:56 <Saizan> in absence of a module header the module name defaults to Main
09:55:08 <gwern> @tell benmachine I *finally* solved alexa! you will marvel & despair at what the missing piece turned out to be: http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=5391#a5400
09:55:08 <lambdabot> Consider it noted.
09:57:58 <dmwit> Okay, what library should I use to write a DGS bot?  All I should need is the ability to grab URLs and store cookies.
09:58:27 <chrisdone> what's DGS?
09:58:40 <dmwit> http://www.dragongoserver.net/
09:58:47 <tania> hello
09:58:49 <gwern> @hoogle a -> a -> (a -> ()) -> ()
09:58:49 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:58:49 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
09:58:49 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
09:58:53 <dmwit> tania: Howdy!
09:59:11 <gwern> hm. maybe I should just use an arrow
09:59:13 <tania> i am trying to import Data.Functor but always run into "Could not find module `Data.Functor':", someone having a hint?
09:59:26 <gwern> @hoogle (a,a) -> (a -> b) -> b
09:59:26 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
09:59:32 <HaskellLove> what's up with the Lisp haters spitting on Haskell? I just asked Lisp related question, and just seeing the name HaskellLove they jumped on me ... ?
09:59:32 <gwern> @hoogle (a,a) -> (a -> b) -> (b,b)
09:59:33 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:59:33 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
09:59:33 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
09:59:51 <dmwit> tania: What makes you think that module exists?
09:59:54 <gwern> HaskellLove: envy. they know we're doing better than any lisp except maybe clojure
10:00:00 <gwern> @hoogle Functor
10:00:01 <lambdabot> Prelude class Functor f
10:00:01 <lambdabot> Control.Monad class Functor f
10:00:01 <lambdabot> Control.Monad.Instances class Functor f
10:00:03 <Twey> There's one in 6.12
10:00:07 <Twey> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Functor.html
10:00:13 <Twey> base-4, anyway
10:00:25 <dmwit> aha
10:00:26 <tania> dmwit: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Functor.html
10:00:36 <dmwit> tania: Welp, what does "ghc-pkg list base" say?
10:00:49 <Twey> tania: That documentation is most likely for a different version of base than you have installed
10:00:52 <dmwit> tania: If base is version 3 or earlier, you should just import Control.Monad instead.
10:00:56 <tania> /var/lib/ghc-6.10.4/./package.conf: base-3.0.3.1, base-4.1.0.0
10:01:35 <dmwit> tania: ghc is almost certainly defaulting to base-3 there.
10:01:44 <tania> dmwit: ok thank you very much
10:03:40 <OscarZ> how does one implement threading in imperative programming, where work is done in parallel stages in which at some points threads must wait for other threads to get a certain point to be able to continue
10:03:52 <OscarZ> or do you get this kind of functionality for free ?
10:04:11 <OscarZ> is it left for the haskell runtime ?
10:04:24 <EvanR_> there are MVars
10:04:34 <monochrom> Some API is provided for waiting.
10:04:36 <dmwit> The lightest way is to use `par` to do pure computations in parallel.
10:04:58 <monochrom> Take an OS course.
10:05:06 <dmwit> Though I may be confused about exactly what you're asking.
10:05:33 <EvanR_> i implement threading in imperative programming with pthreads ;)
10:06:42 <OscarZ> In imperative programming, if you know that certain things can be done in parallel, you might launch multiple threads for it and let OS take care of how the work is divided .. but at some points, threads need to wait for others to keep up to a certain point to continue
10:07:11 <EvanR_> and youd use synchronization primitives
10:07:12 <monochrom> Like I said. Some API is provided for waiting.
10:07:51 <monochrom> But I guess you weren't asking. You were stating.
10:07:53 <EvanR_> but why dont you use functional programming instead ;)
10:08:14 <monochrom> Perhaps you are writing an essay aloud.
10:08:16 <OscarZ> monochrom: Ok. I was just trying to clarify my question
10:09:52 <OscarZ> monochrom: Eh.. what do you mean I was stating ?
10:11:24 <OscarZ> I'm just trying to learn functional programming and was thinking of some situations of which I don't know how to implement or even think in functional terms ..
10:12:59 <vy> Are there any shortcuts for (head . take)?
10:13:14 <gwern> @wn perplexion
10:13:16 <lambdabot> No match for "perplexion".
10:13:23 <vy> E.g. `NTH' in Common Lisp.
10:13:37 <gwern> @hoogle [a] -> Int -> a
10:13:38 <lambdabot> Prelude (!!) :: [a] -> Int -> a
10:13:38 <lambdabot> Data.List (!!) :: [a] -> Int -> a
10:13:38 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
10:13:38 <OscarZ> As imperative programming can be mapped on a time-line ... this line gets executed after that one .. etc.. and it is intuitive to mark the spots when to wait for the other threads
10:13:43 <gwern> vy: ^
10:13:44 <monochrom> > [3,1,4] !! 3
10:13:45 <lambdabot>   * Exception: Prelude.(!!): index too large
10:13:48 <monochrom> > [3,1,4] !! 2
10:13:49 <lambdabot>   4
10:14:21 <vy> Thanks!
10:15:20 <EvanR_> OscarZ: in do notation, if you read an MVar, it will block until something writes it. thats imperative like synchronization.
10:16:07 <OscarZ> EvanR_: Ok.. thank you. So this is something to do with Monads?
10:16:21 <EvanR_> not really
10:17:16 <OscarZ> Is it just an ordinary function but it only gets it's value when the "sync lock" is opened ?
10:17:41 <dmwit> More or less, yes.
10:17:43 <EvanR_> MVars are part of the concurrency support, you only used them with forkIO
10:17:54 <OscarZ> How is it actually accomplished in the program .. that you can "open" a specific lock
10:18:52 <EvanR_> its hidden in the semantics of reading and writing MVars
10:18:52 <dmwit> OscarZ: MVar's either contain a value or they don't.  When they contain a value, trying to put a value in blocks until it's empty.  When they are empty, trying to take out a value blocks until it's full.
10:19:04 <monochrom> You say "readMVar blah blah". That thread is blocked until some other thread says "writeMVar blah blah". It can also transfer data.
10:19:21 <OscarZ> Multithreading and related problems can be pretty difficult I guess.. do you think these problems are easier to keep in control in the functional domain ?
10:19:48 * dmwit mumbles something about STM
10:19:57 * dmwit mumbles something about DPH
10:20:44 <OscarZ> Ok.. thanks guys
10:36:26 <copumpkin> OscarZ: yeah
10:36:53 <BenceF> hey all
10:37:11 <copumpkin> OscarZ: the main difficulty with threads is dealing with shared state across them. Eliminate state and you don't have the problem anymore ;) of course it isn't that simple, but many times it can be
10:37:54 <BenceF> is there a way to make to make a binary lib file which i can access from a c++ program?
10:38:18 <BenceF> i have ghc
10:38:33 <BenceF> if that matters
10:38:43 <Zao> BenceF: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
10:39:14 <OscarZ>  copumpkin: I think I understand that.. and many times it can be done so.. and I guess that's when being "pure functional" is really good :)
10:39:34 <copumpkin> OscarZ: even when you can't eliminate shared state, we have nice solutions
10:39:48 <copumpkin> STM allows you to (mostly) forget that other people are messing with your state
10:40:15 <copumpkin> and even our regular concurrency primitives are fairly decent
10:40:22 <OscarZ> what is STM ?
10:40:31 <copumpkin> software transactional memory
10:41:05 <copumpkin> allows you to view a consistent state of your mutable variables, and if someone else writes behind your back, you just run your transaction again
10:41:08 <copumpkin> a bit like a database
10:41:39 <copumpkin> your changes don't appear to other people until you finish your transaction
10:41:48 <Lemmih> BenceF: It's possible but fairly complicated.
10:42:13 <tommd> It isn't that hard.
10:42:19 <OscarZ> copumpkin: Ok.. well explained
10:42:25 <tommd> Just prone to headaches if you use it in conjunction with the Kernel.
10:42:27 <BenceF> Zao: thats kinda messy which saddens me, but  thanks for showing. i appreciate
10:42:51 <copumpkin> BenceF: what's messy?
10:42:59 <Zao> With some glue, you can even make a DLL with it.
10:43:10 <BenceF> Lemmih: yeah i see:D
10:43:24 <copumpkin> BenceF: it seems fairly simple. You define your function, and then tell them that you want to export it and that's it. How much cleaner could it get?
10:43:26 <Zao> I used Haskell from VC++ via a GCC DLL once.
10:43:34 <Zao> Was too cumbersome to be productive.
10:45:00 <BenceF> copumpkin: well i want to compile my c code with gcc and do the linking there
10:45:11 <BenceF> and does it work with c++?
10:45:46 <copumpkin> BenceF: you can compile it with gcc if you really want to. ghc just takes care of some linker parameters for you
10:45:59 <BenceF> if it does im mostly fine with it
10:46:00 <copumpkin> BenceF: you probably need an extern "C" before your declaration in the header
10:46:19 <BenceF> ok i get it
10:46:20 <BenceF> i hope
10:46:27 <BenceF> gonna mess around
10:46:30 <BenceF> :D
10:46:39 <BenceF> thanks for the help
10:47:01 <increpare> HScolour doesn't seem to create anchors for class methods yet: is there a way to get haddock to not make links to them?
10:47:13 <copumpkin> np :)
10:48:11 <increpare> ooh wait the internet tells me to use line-based anchors
10:50:15 <increpare> hurrah it works now
10:50:44 <BenceF> ahhh but after i wrap them up and make a c binary this way , i can turn that into a lib file dont i?
10:51:04 <BenceF> or is that slow and ugly?
10:51:05 <Zao> BenceF: You link it into a library instead of an EXE.
10:51:12 <vy> [OT] IIRC, there should be a website sth similar to "review my code". Does anybody remember its name/address?
10:51:17 <Zao> The "use GHC" bit is mostly about spitting out the right linker command line.
10:52:06 <BenceF> ok. from then on i can surely use it in c++
10:52:11 <BenceF> thats fine with me
10:52:57 <BenceF> still easier than metaprogramming in c++
10:53:37 <meanburrito920_> when using ghci through emacs, how can I enable tab expansion as it is enabled when using ghci from the terminal?
10:53:43 <BenceF> haskell is my newfound sweetheart
10:53:54 <HaskellLove> "Lisp computation is based on functions and recursive calls instead of on assignment and iterative loops." Hmm, this is same in Haskell...
10:54:15 <copumpkin> HaskellLove: yeah, functional languages
10:54:32 <copumpkin> lambda calculus!
10:54:36 <BenceF> yeah theyre both functional languages
10:55:05 <HaskellLove> how does Haskell simulate Lisp's ability to treat programs as data? can it?
10:55:12 <BenceF> but haskell appeals to me more, cause it looks like my math notes from class :D
10:55:28 <copumpkin> HaskellLove: there's template haskell, but otherwise not very well
10:55:40 <BenceF> maybe through io
10:56:04 <Zao> BenceF: Note that you most probably need to use gcc.
10:56:15 <Zao> As you'll have a rough time linking it to MSVC++ code.
10:56:22 <BenceF> but if you want generative programs lisp is youre friends
10:56:37 <BenceF> i use gcc
10:56:44 <BenceF> but thanks
10:57:13 <Absolute0> What is wrong with my record definition: http://pastie.org/750021 ?
10:57:14 <copumpkin> a lot of macros can be replaced by laziness anyway
10:57:15 <HaskellLove> BenceF well first half of 1010 is Haskell only for me, the other half i will have to choose Prolog or Lisp/Scheme
10:57:36 <c_wraith> 1010?  Are you travelling back in time?
10:57:37 <SamB_XP> Zao: hmm ?
10:57:50 <copumpkin> HaskellLove follows the PS3/XBox trophy model
10:57:52 <copumpkin> with languages
10:58:19 <c_wraith> Wait, haskell has achievements?  Maybe I can get my gamerscore up.
10:58:34 <vy> Can anybody help me to tidy this piece of mess up: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14430 Any recommendations/tips/suggestions are welcome.
10:58:37 <Zao> SamB_XP: Last I looked at it, ld and link.exe have rather different opinions on how static libraries are supposed to look.
10:58:50 <copumpkin> zygohistomoprhic prepromorphisms are one achievement,yep
10:58:58 <Zao> Might've changed though.
10:58:59 <increpare> Absolute0: what does it say is wrong with your record definition?
10:59:04 <HaskellLove> hahaha sorry 2010 :D
10:59:06 <increpare> Absolute0: something with the deriving?
10:59:08 <vy> I want to parse ps output in a more functional way. (As can be seen, it's quite hardcoded into the code.)
10:59:12 <SamB_XP> Zao: ah, yeah, you'd probably have to use ld.exe to do the linking ;-)
10:59:14 <Zao> I'd be happy if I could FFI export directly into a VC++ app.
10:59:18 <Absolute0> Board.hs:6:19: parse error on input `{'
10:59:23 <increpare> Absolute0: oh it should be data instead of type for board
10:59:28 <Absolute0> :)
10:59:30 <Absolute0> thanks
10:59:35 <increpare> Absolute0: it works?
10:59:54 <Absolute0> yes
11:00:00 <BenceF> btw in which language did they write haskell?
11:00:02 <increpare> Absolute0: glad I could be of help.
11:00:06 <increpare> BenceF: c/haskell
11:00:07 <ski> (HaskellLove ; i suggest choosing both Prolog and Scheme)
11:00:26 <HaskellLove> ski 6 months is enough for one language only i think
11:00:49 <HaskellLove> by learning language i think, implenting with it, not just reading books so... i do so now with haskell
11:00:53 <BenceF> increpare: must have been difficult
11:01:09 <ski> you're making a Haskell implementation ?
11:01:51 <BenceF> me? sure not
11:02:03 <BenceF> i was only curious
11:02:12 <ski> (sorry, i should have attributed that question to HaskellLove)
11:02:42 <HaskellLove> ski nah man, i meant implementing stuff in haskell, like solving the eulers now with it :)
11:03:02 <HaskellLove> what you said is the ultimate way to learn a language, but i am not there yet
11:04:12 <increpare> BenceF: oh, it should be said that there're a number of different haskell compilers, I don't think all of them have been written in c/haskell. There's a compiler called Jaskell that compiles haskell (or some variant of haskell; I haven't used it personally) to run on the JVM, and that's written in java.
11:05:00 * ski wonders whether `c/haskell' is the intersection of `c' and `haskell'
11:05:02 <tommd> YHC, before it went belly-up, could compile Haskell to javascript.
11:05:04 <BenceF> writing an interpreter or a compiler must be one of the hardest things
11:05:16 <tommd> ski: That language would be amazingly small
11:05:35 <ville> BenceF: not really.
11:05:40 <monochrom> No one uses "/" for intersection.
11:05:41 <HaskellLove> BenceF exactly, especially if it is only you
11:05:41 <increpare> tommd: this was pre V8 era?
11:06:07 <ski> maybe the union would be more reasonable, here
11:06:15 <BenceF> god i love v8 :D
11:06:18 <tommd> increpare: I don't understand the question.  What is the 'pre V8 era' and what are you asking was before that?
11:06:30 <monochrom> "C/C++" suggests union.
11:06:35 <increpare> tommd:  I mean before google open-sourced its super-fast javascript interpreter
11:06:35 <BenceF> the javascript compiler
11:07:00 <ski> or unholy amalgamated sum
11:07:11 <BenceF> well it was some dutch guys i think
11:07:16 <tommd> increpare: Oh, I don't know when that was, but YHC had some Haskell to javascript success a couple years ago and it was about a year later that all the devs really stopped working on yhc.
11:07:20 <BenceF> v8 was an outside job
11:07:38 <tommd> I think ndm was the last one and he stopped once he graduated / got a job.
11:07:39 <increpare> BenceF: outside job in what sense?
11:07:57 <BenceF> increpare: not google did it
11:08:00 <increpare> tommd: ah okay.  It would be quite an interesting prospect now that js has picked up so much speed.
11:08:27 <increpare> BenceF: internet says it was google who developed it?
11:09:08 <BenceF> yeah im writing some growth simulation in js now. works fast. but it saddens me that some functions are not implemented in a lot of browsers
11:09:57 <HaskellLove> I am gathering images to set on my blog in the Valley of my Heroes :D, so far I got Backus, Turing and John McCArthy, any recommendations? I will get also Frege, Russel, Godel, definetly some painting if there is for Liebniz, give me some ideas, computer science heroes?
11:10:13 <jlouis> Euler :)
11:10:17 <monochrom> Aristotle and Plato.
11:10:26 <neun_> Zuse
11:10:50 <jlouis> And an image of monochrom. Monochrom is awesome you know. If not for his math, then for his humour
11:10:51 <raceRider> how do I zip two lists from [(Int,Int,Int),Integer] and [Float] to [(Int,Int,Int),Integer,Float]
11:11:17 <ski> (s/Liebniz/Leibniz/)
11:11:18 <BenceF> oh it was google.
11:11:22 <BenceF> but in denmark
11:11:25 <BenceF> it seems
11:11:26 <BenceF> :D
11:11:36 <increpare> you mean [ ( (int,int,int),integer) ] -> [float] -> [ ((int,int,int),integer,float) ]  ?
11:11:47 <HaskellLove> monochrom have read everything from them, yeah will put them too :) thanks
11:11:47 <BenceF> http://www.google.com/googlebooks/chrome/small_12.html
11:11:49 <increpare> (excuse my capitalization...)
11:11:49 <raceRider> yes
11:11:54 <BenceF> i was 3/4 wrong
11:12:10 <ski> HaskellLove : Church,Curry
11:12:24 <HaskellLove> ski oops almost forgot Church
11:12:29 <increpare> well if you do a normal zip, you'll get   [  ((  (int,int,int), integer), float) ]
11:13:25 <increpare> so then you write a function to rearrange ( ( (Int,Int,Int), Integer), Float) -> ( (Int, Int, Int), Integer, Float)  (let's say you call it f), and then do (map f) . zip
11:13:40 <ski> @type zipWith
11:13:41 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:13:49 <raceRider> rearrange?
11:14:16 <increpare> oh right, yeah, zipWith will do it : )
11:14:49 * increpare 's bracket-fingers are getting tired
11:15:18 <increpare> rearrange ( (x,y,z),n) f = ( (x,y,z),n,f)
11:15:21 <ski> > zipWith (\(triple,n) x -> (triple,n,x)) [((0,0,0),945),((1,2,3),496)] [pi,exp 1]
11:15:23 <lambdabot>   [((0,0,0),945,3.141592653589793),((1,2,3),496,2.718281828459045)]
11:15:25 <iliosci0> george boole?
11:16:03 <increpare> @ski or that : )
11:16:04 <lambdabot> Maybe you meant: ask src wiki
11:16:18 <ski> s/@ski/ski :/
11:16:28 <HaskellLove> iliosci0 absolutely :)
11:16:29 <increpare> :P
11:16:31 <neun_> @djinn ((a,b),c) -> (c,b,a)
11:16:31 <lambdabot> f ((a, b), c) = (c, b, a)
11:22:21 <BenceF> whats the recommended transition method to 2010?
11:22:27 <BenceF> is there one?
11:22:43 <BenceF> does it concern a newbie like me?
11:22:51 <byorgey> BenceF: wait 12 days or so, consume alcoholic beverage
11:22:55 <BenceF> not just in haskell but generally
11:22:56 <BenceF> :D
11:22:57 <pikhq> If you've been writing code for GHC, it probably won't affect you.
11:23:15 <pikhq> Oh, in general? Wait 12 days, consume alcoholic beverage of your choice.
11:23:24 <byorgey> kissing optional
11:23:39 <BenceF> ok. im less worried now
11:24:26 <BenceF> so i wont have to throw out what i learned so far
11:24:34 <BenceF> which is not much btw
11:25:25 * ski will have to unlearn that it's currently year 2009
11:25:50 <BenceF> man im trying to do that since 2004
11:25:52 <BenceF> :D
11:26:21 <Saizan> current_year is so imperative
11:26:25 <pikhq> BenceF: Haskell 2010 does very little beyond standardising some very uncontroversial GHC extensions.
11:26:44 <pikhq> (... Actually, are they GHC extensions if they're already supported by every single Haskell implementation? :P)
11:26:50 <BenceF> pikhq: then it wont affect me at all
11:27:20 <pikhq> BenceF: Yeah.
11:27:49 <BenceF> seems the ill have to worry about c++0x from now on
11:28:32 <increpare> BenceF: why would you worry about 0x?
11:29:45 <BenceF> is it gonna make metaprogramming easier
11:29:49 <BenceF> hope yes
11:29:55 <increpare> BenceF: that's something that makes you worry?  : P
11:30:05 <BenceF> yes
11:30:21 <BenceF> i like to worry. means there are important stuff
11:30:25 <BenceF> ...somewhere
11:30:26 <gnut> hi all
11:30:34 <BenceF> heyyy gnut
11:34:17 <gnut> heyyyyyy BenceF
11:34:26 <HaskellLove> ahhh there's the family http://haskelllove.wordpress.com/
11:35:40 <BenceF> Liebniz's wig rules
11:36:07 <increpare> If I find myself having signatures like this am I doing something wrong? -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14431#a14431
11:36:44 <ben0x539> How big is the installed haskell platform on linux?
11:38:04 <raceRider> increpare: thanks much, from earlier help
11:38:18 <ddarius> pikhq: They weren't all supported by any implementation, but they were all minor.
11:38:45 <increpare> raceRider: things worked out ok?
11:38:56 <pikhq> ddarius: Yeah, "minor syntax change", "remove n + k patterns"... Not a big deal, really.
11:39:19 <|Jedai|> increpare: there's no Graph g constraint, intentional ?
11:39:35 <|Jedai|> increpare: by the way, couldn't youc
11:39:55 <|Jedai|> just put "(Graph g) => g -> g"
11:40:13 <increpare> |Jedai|: it's a method of a graph class g
11:40:31 <increpare> Yeah I could, but then the types of the various parts wouldn't have to match up
11:40:54 <|Jedai|> increpare:  well they sure would since I put g twice
11:41:10 <increpare> oh I misread the second one as a g prime prime : )
11:41:31 <|Jedai|> increpare: in other words if every parts match, are you sure you want to be able to have two separate instance of Graph ?
11:42:09 <increpare> well the idea is that one graph has lots of probabilities attached to each node
11:42:13 <increpare> and the second one has them stripped out
11:42:42 <increpare> (g isn't just a graph...I'd paste more code but it might result in code overload...)
11:43:31 <increpare> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14432#a14432
11:44:29 <|Jedai|> increpare: maybe you could create some shortcut classes like "class (Label g ~ Label g') => MostlySimilar g g' where"
11:44:50 <increpare> |Jedai|: oooh
11:44:52 <|Jedai|> well, more complicated in your case, but you see my drift
11:45:03 <increpare> ooh yes, yes I do.
11:45:12 <|Jedai|> I'm not absolutely sure it would work though, you'll have to test
11:45:22 <increpare> Yep.  Nice idea, though : )
11:47:16 <kmc> HaskellLove, did you read four books on programming languages and logic / type theory in two days?
11:47:40 <HaskellLove> kmc nah man that is work in progress...
11:48:10 <increpare> |Jedai|: aww no the 'superclass equality not implemented yet' bug rears its head.  I think I can wait 'til the next version to do a workaround.
11:48:22 <HaskellLove> only this one is finished functional programming for the real world
11:49:05 <increpare> (not a bug, I guess, and it should be in the next version so if I wait it won't be a workaround...blech/tired)
11:51:29 <trofi> gwern: did you notice mueval does not cleanup /tmp/ after himself?
11:51:37 <gwern> trofi: no
11:51:43 <gwern> doesn't it overwrite the old file?
11:51:51 <trofi> it uses random names
11:52:29 <gwern> probably calling mktemp
11:52:40 <gwern> trofi: is that a problem? I thought OSs were supposed to clean up /tmp
11:52:47 <Craig`> hey
11:53:03 <trofi> i reboot once a month :]
11:53:05 <HaskellLove> kmc I will finish tapl in eight hours by the way
11:53:20 <trofi> not really a problem, but would be better to use /tmp/mueval-$USER/ than
11:53:39 <trofi> as i usually poke in /tmp
11:54:03 <nolrai_P> If I just want something like IORefs is there a monad that does that, like ST or something?
11:54:23 <kmc> IORefs are used in the IO monad
11:54:38 <kmc> ST is a monad which basically provides only STRefs
11:55:01 <kmc> and as a consequence can be called from pure code providing you meet certain requirements (that are checked by the compiler)
11:55:34 <kmc> (ST also provides other things morally equivalent to STRefs, like mutable arrays)
11:56:11 <JoeT> hello?
11:56:18 <kmc> hi
11:56:24 <Zao> It's a Joe Transformer!
11:56:31 <JoeT> yeah. that's me.
11:56:46 <JoeT> what's the command to do a whois
11:56:55 <opqdonut> /whois
11:56:57 <JoeT> oh. forget that question
11:57:00 <opqdonut> less surprisingly
11:57:06 <JoeT> didnt work
11:57:13 <JoeT> i'm on freenode.net
11:57:19 <JoeT> does my ip show up?
11:57:23 <gwern> trofi: eh. seems like another 3 or 4 lines of code for no benefit
11:57:36 <JoeT> ok. i am brand new to haskell.
11:57:44 <EvanR_> JoeT: effectively. its your hostname
11:57:47 <JoeT> and i have a few questions for someone?
11:57:48 <opqdonut> "JoeT !i=joet@ALEXANDER.HCII.CS.CMU.EDU has joined #haskell"
11:57:51 <kmc> ask away
11:57:52 <opqdonut> just ask
11:57:53 <JoeT> thy
11:58:03 <JoeT> hey thanks
11:58:09 <opqdonut> (those allcaps kerberos names are so cute)
11:58:13 <Lemmih> JoeT: Who are the questions for?
11:58:15 <JoeT> well i did category theory bootcamp last weekend online
11:58:22 <JoeT> for our research
11:58:24 <trofi> gwern: can i fool it with TEMP envvar or something?
11:58:36 <gwern> trofi:
11:58:42 <JoeT> i know very basic category theory
11:58:46 <nolrai_P> kmc: thanks!
11:58:47 <JoeT> understand functor
11:58:53 <JoeT> not quite there with monad yet
11:59:01 <gwern> trofi: no, it uses /tmp hardwired
11:59:09 <JoeT> i want to do some modeling that is consistent with categories, functors, monads
11:59:14 <JoeT> anyone listening?
11:59:17 <gwern> trofi: wouldn't be too hard to make it do 'getEnv $TEMP' or whatever
11:59:22 <increpare> JoeT: I'm listening
11:59:27 <kmc> JoeT, in my experience, knowing CT is neither necessary nor sufficient to use the CT-like aspects of Haskell effectively
11:59:47 <kmc> but maybe if your application for programming in Haskell is very CT-centric it will matter
11:59:52 <|Jedai|> JoeT: we're listening but since you didn't ask your question yet, we're waiting for the punchline :)
11:59:54 <trofi> gwern: ok, i'll patch it locally
11:59:55 <increpare> kmc: as someone with a CT background, I can second this : P
12:00:02 <kmc> JoeT, did you look at the category-extras package on Hackage?
12:01:30 <JoeToth> hi. i'm back. i'm using irc inside browser
12:01:38 <kmc> JoeT, did you look at the category-extras package on Hackage?
12:01:51 <JoeToth> where is hackage?
12:01:58 <kmc> @where hackage
12:01:58 <lambdabot> http://hackage.haskell.org/package/
12:03:28 <JoeToth> this browser tool bites
12:03:37 <kmc> get a real IRC client then
12:03:48 <JoeToth> lol
12:03:50 <JoeToth> yeah
12:04:02 <JoeToth> ok. listen. i am brand new to this language.
12:04:08 * kmc listens
12:04:22 <JoeToth> my programming days are over. however, i am programming in java at the present time.
12:04:49 <JoeToth> but. independently of haskell, i was studying category theory as best i could
12:04:57 <JoeToth> i'm a researcher at cmu here in pittsburgh
12:05:07 <increpare> JoeToth: Ah cool : )  What's your area of research?
12:05:14 <JoeToth> cognitive science
12:05:40 <chrisdone> I like the ease with with one can talk to Haskell from C and vise versa
12:05:45 <gwern> and you don't need to do any programming for that?
12:05:49 <JoeToth> really?
12:05:51 <increpare> JoeToth: coolio
12:06:34 <increpare> chrisdone: I don't know - there does seem to be a certain amount of overhead/pain involved : P
12:06:42 <JoeToth> i wanted to apply category theory to a particular domain. mapping vectors in space, if you will
12:06:53 <increpare> JoeToth: so you want a category of vector spaces?
12:07:05 <JoeToth> actually categories
12:07:16 <JoeToth> so here is an example
12:07:20 <increpare> JoeToth: shoot : )
12:07:45 <JoeToth> in one theory, it is posited that the mind manipulates symbols (e.g., "a")
12:08:05 <increpare> k
12:08:07 <JoeToth> in quite another theory, it is posited that a region of brain tissue holds these kinds of memories
12:08:32 <JoeToth> i am creating vectors of features that describe either theory
12:08:34 <increpare> memories of manipulations?
12:08:44 <JoeToth> well. more like RAM. LOL
12:09:08 <BenceF> welll thanks for all the advises. bye all
12:09:09 <JoeToth> so in the former theory, let's just say there is a memory for a symbol "a"
12:09:20 <BenceF> good transition to 2010! ;)
12:09:25 <JoeToth> in the latter theory, "a" is stored among neural connections
12:09:35 <JoeToth> these theories compete in cognitive science
12:09:40 <JoeToth> but they share features
12:09:47 <increpare> So the latter seems quite structural in nature?
12:10:08 <JoeToth> both have structure in common
12:10:24 <JoeToth> they have things in common
12:10:37 <increpare> I mean, to the extent that an atomic element of the first theory exists in the second as a network of connections?
12:10:44 <JoeToth> but in general, i want to describe either approach as a vector of features
12:10:48 <JoeToth> yes inc
12:11:05 <increpare> So, in the first one, what might the features be?
12:11:13 <gwern> (hm. CMU - my sister graduated from there not too long ago)
12:11:27 <JoeToth> (what dept gwern)
12:11:36 <JoeToth> in the former, there are no features.
12:11:44 <JoeToth> it is simply the symbol "a"
12:11:45 <gwern> JoeToth: she was CS; robotics
12:11:54 <JoeToth> i'm cs too
12:11:58 <JoeToth> probably same building
12:12:00 <JoeToth> anyhow
12:12:16 <JoeToth> the former. no features. just symbols. it is "mind"
12:12:28 <JoeToth> the latter. many features. no symbols. it is "brain"
12:12:29 <increpare> so no vectors on this side of things?
12:12:33 * gwern thinks back to that recent paper on childhood mental development using category theory. pretty interesting
12:12:37 <increpare> (on the former)
12:12:39 <increpare> gwern: linky?
12:12:47 <gwern> increpare: it was on -cafe a week or 2 ago
12:12:53 <JoeToth> i saw that gwern since so little is written on it
12:13:02 <JoeToth> ok. please bear with me.
12:13:11 <JoeToth> i really apprecaite this
12:13:16 <increpare> JoeToth: I'm in no rush : )
12:13:25 <HaskellLove> I just realized that bnf specification is denotational semantics and code generation is operational semantics. Is my AHA moment on track?
12:13:35 <JoeToth> if i consider the unit of analysis for both approaches
12:13:51 <lament> aha moment on crack
12:14:09 <JoeToth> you guys are true language freaks. i always envied that.
12:14:14 <JoeToth> i am not wired for math.
12:14:18 <increpare> gwern: ah yes I think I heard this paper mentioned elsewhere
12:14:23 <JoeToth> but category theory is how i've thought most of my life.
12:14:37 <HaskellLove> lament what do you mean?
12:15:03 <JoeToth> my colleague and i want to map the former to the latter
12:15:23 <JoeToth> this being one of hundreds of such mappings
12:15:27 <increpare> so features to symbols
12:15:27 <ski> HaskellLove : BNF does not specify semantics
12:15:31 <JoeToth> in the realm of cognitive science
12:15:32 <JoeToth> ok?
12:15:35 <increpare> and back
12:15:36 <JoeToth> with me so far?
12:15:38 <increpare> sure
12:15:40 <increpare> i think
12:15:58 <monochrom> I am not wired for this kind of talk.
12:16:08 <JoeToth> really mono?
12:16:10 <medfly> you are broken
12:16:15 <gwern> monochrom: think ampthetamines
12:16:16 <JoeToth> but i thought you guys think like this
12:16:17 * medfly opens up monochrom 
12:16:25 <gwern> monochrom: it worked for erdos!
12:16:30 * chrisdone hugs monochrom
12:16:31 <medfly> hehe
12:16:38 <JoeToth> well i cant get caught up in ad hominum
12:16:53 <increpare> JoeToth: sounds risque!
12:17:03 <medfly> saying you're better than others is pretty insulting
12:17:05 <JoeToth> i had been struggling in Word to draw the dang diagrams with no benefit
12:17:14 <Absolute0> Can I define class instances on type synonyms?
12:17:17 <increpare> JoeToth: commutative diagrams?
12:17:19 <kmc> no
12:17:20 <JoeToth> but then i saw haskell. which does functors, and monads?
12:17:26 <medfly> yes JoeToth
12:17:27 <JoeToth> perhaps inc?
12:17:30 <increpare> Absolute0: you should be able to : )
12:17:40 <kmc> Absolute0, the synonym is just another name for an existing type
12:17:43 <JoeToth> ok. i have a source for that so please bear with me
12:17:47 <JoeToth> as i pull up the site
12:17:49 <kmc> it can't have an instance distinct from that type
12:17:52 <increpare> JoeToth: haskell can do things with functors and monads yep
12:17:54 <medfly> JoeToth: I think Cale has a blog on mathematics and Haskell that maybe you'll find interesting, because people here seem to like it
12:18:18 <Absolute0> (All instance types must be of the form (T t1 ... tn)
12:18:23 <Apocalisp> JoeToth: What are you trying to integrate exactly?
12:18:24 <JoeToth> and cmu has prof awodey who wrote THE text on category theory
12:18:30 <JoeToth> i'm meeting with him after the break
12:18:35 <JoeToth> apo - great question
12:18:40 <kmc> JoeToth, whether Haskell "does functors and monads" is a question of perspective
12:18:44 <JoeToth> i am trying to map seemingly disparate theories
12:18:51 <JoeToth> but these theories have much in common
12:18:57 <kmc> to be precise, we say that Haskell *is* a category
12:19:00 <JoeToth> so long as you apply the proper units of analysis
12:19:02 <kmc> the objects of the category are Haskell types
12:19:05 <JoeToth> oh ok
12:19:10 <kmc> the morphisms in this category are Haskell functions
12:19:10 <HaskellLove> ski I understood it like this: 1. BNF is like denotational semantics because it says what stands for what. For example an expression can be a number or an expression followed bu number. 2. Now it is time to operational semantics to add meaning to that, and this happens in the code generation phase in the compiler, where those representations are translated to real machine code that DOES SOMETHING.
12:19:13 <increpare> JoeToth: relatively recent book: I'll have to check it out
12:19:17 <JoeToth> haskell is like the root object, but instead it is a category
12:19:27 <kmc> an instance of the Haskell typeclass Functor is an endofunctor in this category Hask
12:19:32 <medfly> it's a bloody language!
12:20:03 <JoeToth> medfly. i'd like you to know that i've written in more languages than i care to repeat.
12:20:04 <increpare> kmc: but it's also possible to model categories internally within haskell as well
12:20:06 <EvanR_> ill hask your endofunctor
12:20:08 <increpare> (is Haskell a topos?)
12:20:10 <kmc> an instance of the Haskell typeclass Monad is such an endofunctor, along with the natural transformations a -> m a, and m (m a) -> m a
12:20:17 <JoeToth> all the way back to a GE drum computer circa 1974
12:20:39 <increpare> kmc: hopefully Monads will get a much needed upgrade whenever class families appear (don't know if they're on the immediate roadmap)
12:20:43 <b_jonas> wha
12:20:58 <ski> HaskellLove : no, BNF specifies syntax, i.e. what are the well-formed phrases of the language. denotational semantics specify a mapping from that into some domain. operational semantics specify how to "execute"
12:20:59 <JoeToth> is there a haskell GUI
12:21:02 <vy> I'd like to write a lifter function for small predicates like "flagsP f v = (\s -> (flagsOf s) `f` v)" or "uidP f v = (\s -> (uidOf s) `f` v)". Could anybody help me to write one?
12:21:03 <medfly> JoeToth: so?
12:21:03 <b0fh_ua> Hi there! Can somebody please help me with finding out what is wrong with types in the code snippet: http://pastebin.com/d1bfa0cee ?
12:21:08 <kmc> JoeToth, GUI for what?
12:21:15 <JoeToth> for the haskell language
12:21:17 <HaskellLove> ski ok, got it, tnx
12:21:21 <JoeToth> not an api
12:21:22 <kmc> yeah.  with the category-extras classes you can talk about morphisms that aren't constructed with (->)
12:21:29 <increpare> JoeToth: not really.  There's no particularly pleasant visual interface for haskell programming.  It's a text-based programming language.
12:21:31 <kmc> what does "a GUI for a language" mean
12:21:34 <kmc> do you mean an IDE?
12:21:36 <JoeToth> yeah i noticed
12:21:41 <JoeToth> but in emacs it might work
12:21:48 <JoeToth> yeah IDE
12:21:48 <Absolute0> kmc, increpare: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14433#a14433
12:21:58 <JoeToth> e.g., i'm programming in java net beans right now. what a pain.
12:22:05 <kmc> Absolute0, (Char, Int) is already ordered
12:22:08 <JoeToth> so i'm a psychologist and a programmer
12:22:14 <kmc> by the instance (Ord a, Ord b) => Ord (a,b)
12:22:18 <pikhq> JoeToth: Get you a text editor.
12:22:19 <Absolute0> kmc: no way to override?
12:22:20 <medfly> of course, you're also a mathematician and a rocket scientist
12:22:22 <kmc> Absolute0, no
12:22:25 <Absolute0> :(
12:22:25 <JoeToth> yeah. i'll find emacs.
12:22:26 <kmc> because i'ts just a synonym
12:22:29 <pikhq> Those are what you edit text with, after all.
12:22:33 <kmc> you can tell GHC to allow overlapping instances
12:22:37 <kmc> but the effect may not be what you want
12:22:40 <increpare> Absolute0: use a newtype instead of type, I guess
12:22:41 <EvanR_> medfly: yeah. im thinking the same thing
12:22:43 <kmc> you really ought to define a new datatype
12:22:46 <kmc> instead of a synonym
12:22:48 <increpare> Absolute0: that flag sounds pretty dangerous
12:22:50 <JoeToth> i want to populate a space with categories that relate many many theories
12:22:56 <ski> increpare : what upgrade would monads need ?
12:23:04 <JoeToth> is there something like a retriee or query function
12:23:11 <kmc> any time you define a synonym for a tuple, you should seriously consider a new type instead
12:23:14 <JoeToth> *retrieve
12:23:15 <Absolute0> kmc: then the new type won't have that nice tuple syntax :(
12:23:16 <increpare> ski: to be able to restrict their domain?  (the glaring current impossibility of a set monad, say)
12:23:17 <kmc> tuples are meant for localized throwaway stuff
12:23:21 <tommd> JoeToth: It isn't ready for prime time yet,but leksah is a Haskell IDE written in Haskell.
12:23:23 <kmc> Absolute0, I think the tuple syntax is crap personally
12:23:24 <Saizan> n
12:23:34 <kmc> it's more noise than a regular product type
12:23:36 <tommd> I used it for about a day and a half till I went insane
12:23:38 <Saizan> b0fh_ua: the function you pass to maximumBy has to return an Ordering
12:23:39 <JoeToth> where can i find it tommd
12:23:42 <Saizan> ?type maximumBy
12:23:42 <tommd> hackage
12:23:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
12:23:47 <tommd> @hackage leksah
12:23:47 <lambdabot> http://hackage.haskell.org/package/leksah
12:23:51 <JoeToth> i get it. spelled backwards
12:23:52 <Saizan> b0fh_ua: so use compare rather than max
12:24:02 <tommd> Ok, going now.  Later
12:24:04 * tommd leaves
12:24:06 <increpare> JoeToth: Okay, so back to your categories : )
12:24:21 <increpare> JoeToth: you have two, one with symbols, and one with features
12:24:49 <medfly> :)
12:24:57 <kmc> Absolute0, the 2-tuple type (,) is used by a ton of unrelated things.  it's not appropriate to redefine its *one and only* notion of comparison just because you're using it for one particular purpose
12:24:59 <b0fh_ua> Saizan: nice, thanks
12:25:02 <vy> b0fh_ua: "max ( snd y ) ( snd x )" returns the max one, not an ordering. Instead use `compare'.
12:25:13 <b0fh_ua> vy: thanks
12:25:21 <JoeToth> yes inc. ty.
12:25:24 <kmc> this is why we have the ability to introduce new types
12:25:25 <Absolute0> kmc: true.
12:25:34 <kmc> and why it's easy, rather than a horrid pain in the ass as in C++ or Java
12:25:37 <JoeToth> yes. if you know cog sci, that is symbolic vs. connectionist
12:25:43 <Absolute0> I guess I could just define my own compare
12:25:54 <JoeToth> can i PM in here?
12:25:57 <Absolute0> and use it with list *By functions
12:25:58 <kmc> even when two things look the same in the machine, we often want to keep them separate conceptually, and have the typechecker enforce this
12:26:03 <increpare> JoeToth: there's a /whisper command
12:26:10 <medfly> ??
12:26:12 <kmc> Absolute0, you can do that too
12:26:13 <JoeToth> he. leksah is Windows based?
12:26:18 <increpare> JoeToth: so /whisper UNCLEBILL hello sends a message to just them.  I think.
12:26:18 <JoeToth> oh ok inc i forgot
12:26:23 <Saizan> b0fh_ua: btw, \x y -> compare (snd y) (snd x) == flip (comparing snd) == flip (compare `on` snd) , importing Data.Ordering or Data.Function respectively
12:26:46 <kmc> Data.Ord
12:26:59 <mauke> increpare: commands are not "in here". they are in your IRC client.
12:27:05 <xerox> ?type compare
12:27:07 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
12:27:12 <ski> increpare : itym s/whisper/msg/ ?
12:27:17 <xerox> data Ordering = ... ?
12:27:21 <kmc> @src Ordering
12:27:22 <lambdabot> data Ordering = LT | EQ | GT
12:27:28 <JoeToth> i'm downloading leksah
12:27:30 <kmc> > compare 2 3
12:27:31 <lambdabot>   LT
12:27:50 <JoeToth> you know what is so cool about category theory?
12:27:57 <kmc> > let x = "hello world" in zipWith compare x $ tail x
12:27:58 <lambdabot>   [GT,LT,EQ,LT,GT,LT,GT,LT,GT,GT]
12:28:21 <increpare> JoeToth: What do you think is cool about category theory?
12:28:30 <xerox> if there's invert LT = GT; invert GT = LT; invert EQ = EQ, you can do (invert .) . (compare `on` snd) instead of flip too Saizan :D
12:28:31 <kmc> @src comparing
12:28:32 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:28:40 <ski> JoeToth : Topos theory ?
12:28:47 * increpare always had a fondness for coends...
12:29:01 <EvanR_> coeds? ;)
12:29:03 <JoeToth> with a little work, i'm grasping this shit
12:29:10 <increpare> EvanR_: oh dear....
12:29:20 <JoeToth> ok. leksah is running.
12:29:29 <JoeToth> are there sample programs anywhere?
12:29:56 <increpare> sure: lots
12:30:07 <JoeToth> where do i look. ones that are REAL simple.
12:30:15 <kmc> JoeToth, samples to learn haskell in general?
12:30:27 <increpare> JoeToth: I guess this webpage might be useful -> http://www.haskell.org/tutorial/
12:30:31 <kmc> you may like Real World Haskell
12:30:31 <JoeToth> yes kmc
12:30:33 <kmc> @where RWH
12:30:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:30:38 <JoeToth> that tutorial sucked
12:30:47 <medfly> @where lyah
12:30:47 <lambdabot> http://www.learnyouahaskell.com/
12:30:53 <b0fh_ua> Saizan: okay, but I'm trying to keep things simple :)
12:30:55 <JoeToth> ok. thanks.
12:31:02 <increpare> JoeToth: What didn't you like about it?
12:31:15 <JoeToth> oh shit. i hope you didnt write it.
12:31:16 <b0fh_ua> btw some strange error occurs: http://pastebin.com/d1c787c03
12:31:18 <increpare> kmc: rwh is a bit advanced innit?
12:31:22 * increpare did not write it.
12:31:26 <JoeToth> good
12:31:29 <JoeToth> it wasnt bad
12:31:32 <Stinger> I did :(
12:31:39 <JoeToth> oh no. i'm sorry stinger.
12:31:39 <kmc> inclement, *shrug* it's made for people who are good programmers in other languages
12:31:42 <b0fh_ua> looks like it doesn't like the line : getSequenceStats [] = []
12:31:44 <JoeToth> i didn't mean it that way
12:31:44 <Stinger> heh nah
12:31:47 <Stinger> not really
12:31:53 * ski . o O ( `data Prod (a :: Graph) (b :: Graph) = Pair a b where Pair a0 b0 ~~> Pair a1 b1  <=>  a0 ~~> a1 /\ b0 ~~> b1' )
12:31:53 <JoeToth> i AM a good programmer
12:31:57 <kmc> BONUS did actually write LYAH though
12:32:01 <JoeToth> i am just tired of learning like the 11th
12:32:04 <JoeToth> you know?
12:32:10 <kmc> that's why i recommend RWH
12:32:16 <JoeToth> what is rwh
12:32:20 <kmc> @where rwh
12:32:20 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:32:22 <kmc> real world haskell
12:32:23 <JoeToth> ohi see it
12:32:27 <increpare> JoeToth: "the 11th"?
12:32:36 <JoeToth> 11th language that i know
12:32:38 <Stinger> I found haskell school of expression pretty good to learn from
12:32:46 <JoeToth> lemme look
12:33:06 <Stinger> not online though
12:33:11 <JoeToth> oh ok
12:33:17 <JoeToth> well. i'll stumble along...
12:33:19 <increpare> JoeToth: ah right.  Learning languages shouldn't be a chore; it's a privilege : )
12:33:28 <JoeToth> ok inc. i agree.
12:33:40 <JoeToth> you know what is SO cool about what my colleague and i are doing?
12:34:01 <JoeToth> if we can figure out how to populate haskell the way i think we can...
12:34:18 <JoeToth> we will be able to spot where a given approach in cognitive science is
12:34:28 <JoeToth> and also be able to spot where it is or is not going
12:34:33 <JoeToth> and/or where it should go
12:34:54 <increpare> modelling of psychological theories is always a shaky affair
12:35:06 <b0fh_ua> got it
12:35:09 <JoeToth> after i read that category theory unified mathematics. once i was able to think of theories or methods as objects in categories...
12:35:10 <increpare> (I say this as someone with strong feelings of endearment towards lacan)
12:35:16 <JoeToth> i know inc
12:35:23 <increpare> but it sounds very interesting
12:35:33 <JoeToth> i tried whisper inc. didnt work.
12:35:40 <increpare> JoeToth: I tried messaging you, but there seemed to be some trouble with them getting through
12:35:41 <JoeToth> well. we are forcing the issue.
12:35:47 <increpare> JoeToth: you have msn?
12:35:50 <JoeToth> hang on a sec. brb.
12:35:55 <JoeToth> yes inc i do.
12:36:12 <Stinger> what are some other mainstreamish lazy/non-strict languages?
12:36:15 <JoeToth> i'm back. i have msn
12:36:32 <JoeToth> you have an msn handle inc
12:36:45 <ski> Stinger : Clean
12:36:48 <JoeToth> my msn handle is toth.joseph@gmail.com
12:37:29 <ddarius> Excel.
12:37:52 <BMeph> Visual Basic! >;)
12:38:21 <HaskellLove> "Although most programming is done in imperative languages, it is certainly possible that, at some future time, pure or mostly pure FP languages will become more popular. " Even if functional programming becomes more popular, in the end, it will always be imperative, I mean, you will always tell the computer, do this, ok, now do that, now do that. Functional programming will stay as a layer...
12:38:22 <increpare> JoeToth: hey sure I'll add you in a minute...gotta order pizza first
12:38:23 <HaskellLove> ...above imperative I think so people might as well stop comparing both paradigms and use what is needed for the task at hand. Give me some opinions. If there are papers that claim functional will replace imperative completely give me links, but i doubt that...
12:38:29 * increpare is analytic@gmail.com
12:39:26 <kmc> HaskellLove, I agree that some tasks are inherently imperative
12:39:36 <kmc> that's why Haskell has strong first-class support for imperative programming
12:41:18 <HaskellLove> "first-class support for imperative programming" kmc? I am still new to Haskell, so I am not ashamed to say I dont understand that :)
12:41:39 <kmc> HaskellLove, some (not all!) monads can be thought of as models of imperative programming
12:41:44 <kmc> IO is the prototypical example
12:42:05 <copumpkin> btw, http://www.reddit.com/r/haskell/comments/ag6bv/should_i_give_haskell_another_try/c0hg3f2
12:42:12 <copumpkin> (self call)
12:42:13 <kmc> we can build IO values in functions, pass them around, and store them in data structures
12:42:40 <kmc> this is incredibly powerful -- it allows you to define your own control flow structures as ordinary functions
12:42:45 <OscarZ> copumpkin: is this your blog?
12:42:51 <monochrom> @quote JS
12:42:51 <lambdabot> I says: couldn't get through the day as it is without the Prozac and Jack Daniels I keep on the shelf, behind my Tops-20 JSYS manuals.
12:42:52 <copumpkin> OscarZ: yeah, I own reddit
12:43:06 <monochrom> @quote JS.array
12:43:07 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
12:43:08 <copumpkin> OscarZ: (just kidding :))
12:43:12 * ski thinks of all (computational) monads as models of "imperative" programming
12:43:14 <kmc> and it enables things like STM, where we define a mapping between two different sorts of imperative programming, gaining a useful property in the transfer (in this case, atomicity)
12:43:14 <copumpkin> OscarZ: it's just a comment on a social news site
12:43:40 <HaskellLove> kmc so that is the real power I guess people were talking about telling me you will need months to get to haskell's REAL power
12:43:44 <Twey> Heh, yes… Haskell treats imperative programming with more respect than a lot of ‘imperative’ programming languages
12:43:58 <kmc> Twey, yes... and i wish the community did too
12:44:02 <kmc> because some problems really are imperative
12:44:12 <kmc> HaskellLove, i don't think this is the core of the "real power" of haskell
12:44:16 <kmc> but it is a major feature
12:44:19 <EvanR_> 'haskell is currently the best imperative language' ;)
12:44:33 <monochrom> I respect imperative programming. Actually I don't make a big distinction.
12:44:45 <b0fh_ua> that error makes me crazy... Can somebody please take a look at this code snippet please? http://pastebin.com/d33073f5b
12:44:47 <copumpkin> people often talk about haskell's monads allowing you to overload the semicolon (as in c)
12:44:55 <ski> @quote Olin_Shivers
12:44:56 <lambdabot> Olin_Shivers says: Who should I thank? My so-called ``colleagues,'' who laugh at me behind my back, all the while becoming famous on my work? My worthless graduate students, whose computer skills
12:44:56 <lambdabot> appear to be limited to downloading bitmaps off of netnews?
12:45:15 <HaskellLove> monochrom I guess for you it is all lambda calculus :) uh, i will get there one day too, i hope :)
12:45:18 <copumpkin> b0fh_ua: you've got an extra tuple
12:45:32 <monochrom> No, it is not all lambda calculus.
12:45:47 <b0fh_ua> copumpkin: not sure I do understand you
12:45:52 <copumpkin> b0fh_ua: you might want something like map fst remainder in the last line, instead of just remainder
12:46:04 <copumpkin> b0fh_ua: your remainder has a type of [(a, Int)]
12:46:34 <kmc> HaskellLove, the way I think of it lately is:  Functional programming is about describing values, in terms of expressions that can be evaluated.  We can describe values of various types: numbers, lists, syntax trees, etc.  One of these many types we can describe is "imperative action step".
12:46:37 <copumpkin> b0fh_ua: when encountering problems like this, add type annotations to your parts until you figure it out. It makes the error a lot clearer, a lot of the time
12:46:37 <b0fh_ua> hm
12:46:50 <b0fh_ua> you're right
12:47:10 <HaskellLove> kmc I will add that to my blog notes, thanks
12:47:15 <kmc> One of the revolutionary ideas in Haskell is to separate the concepts of "evaluating an expression"
12:47:21 <kmc> from the concept of "perform an imperative action"
12:47:35 <b0fh_ua> copumpkin: with type annotations did you mean simply put comments?
12:48:09 <copumpkin> b0fh_ua: nope, write remainder : [(a, Int)] ; remainder = ... for example
12:48:24 <monochrom> Use ::
12:48:25 <copumpkin> unfortunately that won't relaly work
12:48:32 <copumpkin> yeah, damn agda polluting my mind
12:48:50 <monochrom> This one can't be helped.
12:48:57 <OscarZ> kmc: what is the difference ? to evaluate an expression the computer has to perform an imperative action
12:49:08 <b0fh_ua> now I see that my way of solving that problem is correct
12:49:11 <copumpkin> b0fh_ua: adding type signatures as I described there won't work without an extension
12:49:13 <kmc> OscarZ, you're talking about how one might implement Hsakell
12:49:21 <kmc> OscarZ, I am talking about the semantics of the language
12:49:33 <OscarZ> kmc: ok
12:49:36 <napping> talking about purity?
12:49:44 <Twey> (also, not necessarily true — current architectures are imperative, but see the Reduceron)
12:49:47 <kmc> "evaluation" in Haskell is not imperative and it is not fruitful to describe it as such, unless you're interested in implementation
12:49:48 <monochrom> This one doesn't need help either. Clearly, remainder's type comes from getSequence's type, and it conflicts with findMaxSequence's type.
12:49:59 <kmc> and evaluation in Haskell does not have side effects, either
12:50:02 <napping> Yeah, the relationship between imperative implementation and pure semantics is interesting
12:50:08 <Twey> Apart from making the computer warm ;)
12:50:08 <kmc> that is true even for evaluating a value of type IO ()
12:50:12 <kmc> > putStrLn "Hello, world!"
12:50:13 <lambdabot>   <IO ()>
12:50:19 <b_jonas> but haskell also has the non evaluation part, which is imperative
12:50:20 <kmc> ^^^^^ lambdabot evaluates the IO action but does not execute it
12:50:24 <b_jonas> the part that runs IO
12:50:35 <kmc> yeah
12:50:48 <napping> The point is purity promises various rules about how you can manipulate code, and what things you don't have to worry about being broken by your changes
12:50:56 <kmc> beginners are often told that a type like "a -> IO b" represents an "impure function".  this is a lie, although it may be one of those lies which is conducive to learning
12:51:08 <kmc> the truth about that type is quite a bit more profound
12:51:36 <OscarZ> kmc: When people implement a method or a function they usually first think what they want to accomplish and then write in imperative language how to do it ... I've understood that in Haskell you have to learn how to express the "what you want" part and that's it
12:51:51 <kmc> OscarZ, to varying degrees, yes
12:51:57 <kmc> but sometimes "what you want" really is "do some things"
12:52:00 <napping> and the compiler very cleverly arranges the imperative stuff going on under the hood in such a way that the compiled version of semantically equivalent expressions actually respect those promises, even though there is imperative stuff used in the implementation
12:52:16 <OscarZ> kmc: Ok.
12:52:28 <napping> kmc: well, there is the whole Kleisli category thing
12:52:34 <kmc> OscarZ, when "what you want" is an Integer, you describe an Integer.  when "what you want" is some filesystem manipulations, you describe an IO ()
12:52:49 <tensorpudding> @type \x -> (return . (const 5)) x
12:52:50 <lambdabot> forall a (m :: * -> *) b. (Monad m, Num a) => b -> m a
12:53:44 <OscarZ> kmc: But usually filesystem manipulations have to be in some order... eg.. write lines in some specific order
12:54:21 <b0fh_ua> If I have a list like this [(1,2),(5,7),(6,4),(8,9)]. I want to find the first item with minimal second item of tuple, then drop items from the list and find next minimal from the remainded and so on. The first item of each of those tuples must be returned, so the resulting list will be [1,6,8]
12:54:34 <napping> OscarZ: it's not even so much about what you want vs how to do it. Haskell code still has a bit of how you do it, it's just that the "how" is in terms of constructing new values from old values
12:54:36 <kmc> OscarZ, right.  the functions that manipulate values of type "IO ()" have to consider the order of sub-actions
12:54:46 <kmc> this is no more remarkable than saying that functions that manipulate lists have to consider the order of list elements
12:54:49 <b0fh_ua> I don't see any way to do this for now, since there's no loops in haskell - then I have to pass things to a function
12:54:55 <b0fh_ua> and call it recursively
12:55:13 <napping> b0fh_ua: have you considered Data.Map ?
12:55:17 <kmc> the order in which stuff appears in your datatype has nothing to do with the order of *evaluation*, except in a very low-level operational implementation sense
12:55:33 <kmc> and in Haskell, the order in which IO is performed is defined in terms of the former, and not the latter
12:55:41 <EvanR_> b0fh_ua: what you want to do is fairly straight forward in a functional style
12:56:02 <OscarZ> Ok
12:56:12 <kmc> that is, the IO action (a >> b) means "do a, then b"... regardless of when a, b, (>>), and the overall application are evaluated (or indeed, whether they are at all!)
12:56:19 <napping> b0fh_ua: you could do it in several passes, but that's O(n^2)
12:56:23 <kmc> just like [3,4] means "three followed by 4"
12:56:25 <b0fh_ua> EvanR_: with the code listed at http://pastebin.com/d33073f5b I have to pass the "remainder" to the finaMaxSequence as well
12:56:29 <OscarZ> napping: I think I get you are saying
12:56:33 <b0fh_ua> or create some another function
12:56:42 <EvanR_> b0fh_ua: if you dont want to make a recursive function, you can use foldr
12:56:49 <Twey> b0fh_ua: I don't understand your specification of your desired function.
12:56:56 <napping> something like Map.fromList [(value,key) | (key,value) <- list], then you can use toList
12:57:00 <Stinger> (map snd) . sortBy (compare `on` snd)
12:57:07 <Stinger> map fst even
12:57:22 <Twey> The first set of brackets are unnecessary, Stinger
12:57:23 <EvanR_> whoa :o
12:57:38 <Twey> But that can't be right — that will yield four values, but the result b0fh_ua provided had only three
12:57:52 <kmc> :t \f -> map fst . sortBy (comparing snd) . (id &&& f)
12:57:53 <Stinger> yeah I'm not sure what his criteria exactly are
12:57:53 <lambdabot>     Couldn't match expected type `[(a, b)]'
12:57:53 <lambdabot>            against inferred type `(b1, c')'
12:57:53 <lambdabot>       Expected type: b1 -> [(a, b)]
12:57:55 <HaskellLove> Anyone knows a Algol/ML related channel?
12:58:00 <Twey> And yeah, ‘comparing snd’
12:58:02 <b0fh_ua> Twey: it's just solving of the task to "drop the minimal items from a sequence, so the rest of items will make the ordered sequence"
12:58:03 <kmc> Algol/ML
12:58:04 <napping> Alogl/ML?
12:58:07 <kmc> Fortran/Forth/F#
12:58:11 <EvanR_> algol/ml?
12:58:15 <clarkb> danger lies in ML
12:58:16 <monochrom> J/Java/Javascript
12:58:20 <Twey> b0fh_ua: Minimal compared to what?
12:58:20 <medfly> lol
12:58:21 <kmc> Clean/C++/Clojure
12:58:33 <kmc> Agda/APL/ANTLR
12:58:33 <Twey> Drop the least item from the list?
12:58:35 <medfly> I think he meant "OR"
12:58:37 <EvanR_> algol and ml dont even start with the same letter
12:58:38 <b0fh_ua> Twey: minimal *amount* of items
12:58:52 <monochrom> We all know it means "or"
12:58:52 <copumpkin> lol kmc
12:58:59 <Twey> Oh, hum
12:59:05 <aavogt> then why one channel then?
12:59:06 <kmc> hmm Agda and APL do have some things in common
12:59:16 <copumpkin> really?
12:59:19 <b0fh_ua> I just try to calculate the amount of items greater than the current one to the right of the current one
12:59:23 <kmc> syntactically ;)
12:59:25 <copumpkin> lol
12:59:43 <Twey> Well, that's not going to give you the optimal solution
12:59:43 <ski> @type \f -> map snd . sortBy (comparing fst) . map (graph f)  -- ?
12:59:45 <lambdabot> forall a b. (Ord a) => (a -> b) -> [a] -> [b]
12:59:56 <napping> there's unicode source and infix operators in Agda, and the APL operators unicode page
12:59:56 <b0fh_ua> and in the next pass find the item with maximum number neighbors to the left of it
13:00:26 <copumpkin> ooh the magic graph
13:00:28 <copumpkin> :t graph
13:00:30 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
13:00:30 <b0fh_ua> then find another item with maximum amount of neighbors in the remainder
13:00:32 <b0fh_ua> and so on
13:00:33 <kmc> HaskellLove, there's a channel for ocaml and i think one for SML/NJ
13:00:37 <napping> b0fh_ua: I think you should start following your description more directly
13:00:43 <EvanR_> b0fh_ua: whats the point of the first element then
13:01:00 <copumpkin> > graph (+1) 1
13:01:01 <ski> kmc : s/SML\/NJ/SML/
13:01:01 <lambdabot>   (1,2)
13:01:12 <kmc> ski, ah, does SML/NJ describe an implementation only?
13:01:16 <kmc> i guess so
13:01:16 <ski> yes
13:01:18 <kmc> that being what "standard" means
13:01:22 <Stinger> so right to left drop elements with the snd that's greater than the one directly right
13:01:24 <kmc> sorry, i'm not a ML expert
13:01:26 <copumpkin> noo joisy
13:01:31 <kmc> HaskellLove, as for ALGOL, I think it's been dead for roughly 30 years
13:01:32 <napping> b0fh_ua: mimum (map snd values) will find the current minimum
13:01:48 <b0fh_ua> EvanR_: initially I have the list. With getSequenceStats I create list of tuples, where the first item is the item itself, and the second one is the number of greater items
13:02:01 <napping> b0fh_ua: head [k | (k,val) <- values, val == min_i_found] to extract the first matching one
13:02:10 <tensorpudding> @src graph
13:02:10 <lambdabot> Source not found. It can only be attributed to human error.
13:02:18 <kmc> :t \f -> map fst . sortBy (comparing snd) . map (id &&& f)
13:02:19 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [a]
13:02:22 <napping> [p | p@(_,val) <- values, val > min_i_found] to remove those items, and repeat
13:02:23 <kmc> ^^^^^ i've often wanted this
13:02:24 <ski> <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph = (arr id &&&)
13:02:30 <HaskellLove> In the book it says Algol family let to development of ML so will try to find some papers on Algol could not find books, and will get in sml channel thanks kmc
13:02:30 <ski> <ski> @let cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph = (||| arr id)
13:02:35 <copumpkin> ARR
13:02:41 <kmc> ah yes
13:02:49 <napping> HaskellLove: I recall seeing some articles recently about the higher order stuff in algol
13:02:53 <kmc> @yarr
13:02:53 <lambdabot> Well Ahoy! thar.
13:03:07 <tensorpudding> > cograph (* 2)
13:03:08 <lambdabot>   Left (-2)->
13:03:08 <lambdabot>    -4
13:03:08 <lambdabot>  Left (-1)->
13:03:08 <lambdabot>    -2
13:03:08 <lambdabot>  Left 0->
13:03:11 <lambdabot> [4 @more lines]
13:03:19 <napping> HaskellLove: Ah, I think it was someone comparing this new google Go to a mystery language, which turned out to be Algol 60
13:03:20 <kmc> "2009 October: Unicode - The "⏨" (Decimal Exponent Symbol) for floating point notation was added to Unicode 5.2 for backward compatibility with historic Buran (spacecraft) ALGOL software."
13:03:25 <copumpkin> :t cograph (*2)
13:03:26 <lambdabot> forall a. (Num a) => Either a a -> a
13:03:31 <stoop> > graph (* 2)
13:03:32 <lambdabot>   {-3->(-3,-6);-2->(-2,-4);-1->(-1,-2);0->(0,0);1->(1,2);2->(2,4);3->(3,6)}
13:03:36 <copumpkin> > cograph (*2) (Left 5)
13:03:38 <lambdabot>   10
13:03:42 <copumpkin> > cograph (*2) (Right 5)
13:03:42 <ski> > cograph (^2) `map` [Left 1,Right 2,Left 3,Right 4]
13:03:43 <lambdabot>   5
13:03:44 <lambdabot>   [1,2,9,4]
13:04:01 <kmc> wp says that \ is in ASCII because of algol's /\ and \/
13:05:04 <kmc> napping, haha
13:05:07 <kmc> do you have a link?
13:05:22 <kmc> it's funny how every PL concept is re-invented over and over
13:06:17 <napping> kmc: I googled that for you ... http://www.cowlark.com/2009-11-15-go/
13:06:23 <Berengal> kmc: "1936 - Alonzo Church also invents every language that will ever be but does it better. His lambda calculus is ignored because it is insufficiently C-like. This criticism occurs in spite of the fact that C has not yet been invented."
13:06:31 <kmc> yes :)
13:06:32 <kmc> napping, thanks
13:06:45 <napping> seems like Algol has some super weird terminology and some oddities, but is basically pretty reasonable
13:07:06 <Stinger> heh Berengal : where's that from?
13:07:16 <Berengal> Stinger: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
13:07:31 <stoop> > cograph (* 2)
13:07:33 <lambdabot>   Left (-2)->
13:07:33 <lambdabot>    -4
13:07:33 <lambdabot>  Left (-1)->
13:07:33 <lambdabot>    -2
13:07:33 <lambdabot>  Left 0->
13:07:35 <lambdabot> [4 @more lines]
13:07:41 <tensorpudding> it's okay for a language made in the 60's to be quirky
13:07:47 <BMeph> napping Algol 68, actually. It was on a Lua mailing list, of all places. :)
13:08:02 <Berengal> tensorpudding: It's not okay if it's still used (mostly unmodified)
13:08:04 <kmc> my favorite one: "1972 - Dennis Ritchie invents a powerful gun that shoots both forward and backward simultaneously. Not satisfied with the number of deaths and permanent maimings from that invention he invents C and Unix."
13:08:04 <napping> yes, they had to invent words for things we know call types, and so on. I think they called them modes?
13:08:21 <tensorpudding> well, you fix the quirks as best you can
13:08:49 <BMeph> napping (In regards to the Google Go thing.)
13:09:27 <napping> that reminds me, does anyone know of relatively high level languages that let you specify data layout?
13:10:20 <Heffalump> napping: I think the PSU guys did some stuff in that area. Nothing really usable though.
13:10:30 <napping> hmm, tagless gc and dictionary passing.
13:11:06 <napping> That whole GC-by-type-inference thing worked out for ML might be a bit more practical if you don't erase type applications
13:11:17 <alexyk> I'm trying to see if tokyocabinet-haskell works.  It has tests/, but cabal test does nothing.  There's a TestUtil.hs in the root dir.  http://github.com/tom-lpsd/tokyocabinet-haskell/ How can I run some tests on it?
13:11:47 <napping> in particular, I'm thinking you could make arrays of overheadless objects if the type info was separately passed in
13:15:27 <kmc> napping, that's a fantastic article, thanks for sending me the link :)
13:16:11 <Stinger> haha the haskell one on that history of programming languages page is hilarious
13:18:03 <napping> Does anyone know the usual object header overhead for garbage collection?
13:18:11 <napping> two pointers? one pointer?
13:19:41 <gwern> @hoogle cmd
13:19:42 <lambdabot> Network.Socket data ShutdownCmd
13:19:48 <gwern> @hoogle command
13:19:48 <lambdabot> No results found
13:19:50 <gwern> bah
13:19:53 <ben0x539> Stinger: I liked the "165 - Kemeny and Kurtz go to 1964." part
13:19:58 <ben0x539> err, 1965
13:20:09 <kmc> napping, in Haskell?
13:20:09 <gwern> what was that really easy function which called the given process and returned its string result?
13:20:20 <gwern> I want to use mktemp in a very concise way
13:20:33 <ben0x539> close to readProcess, I believe
13:20:35 <napping> kmc: more in genneral. IIRC the parallel runtime has one info pointer and an extra word for parallel stuff
13:20:42 <Stinger> that whole article is pretty hilarious
13:21:00 <ben0x539> When did Hoogle become useless again :<
13:21:11 <Zao> gwern: HSH's run :: String -> IO String?
13:21:22 <gwern> Zao: no, I don't want to use anything extra
13:21:28 <ben0x539> Extra to what?
13:21:29 <gwern> I know it's in base or what is effectively base
13:21:39 <gwern> ben0x539: well, right now this plugin is calling a SHA package..
13:21:43 <gwern> which is overkill
13:21:57 <ben0x539> Will http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#v%3AreadProcess do?
13:22:34 <napping> I'm specifically wondering about compacting collectors that need only a constant ammount of storage beyond what they recycle from objects
13:22:41 <napping> so pointer reversal and so on
13:23:31 * gwern guesses readProcess will just have to do
13:23:32 <HaskellLove> If I am to research as many languages as possible where do I cut the line? For example why should I waste time with details of Pacal and Algol if those things are encapsulated in Haskell or Lisp or whatever? Why should I waste time on 50 array programming languages if i can study one that incorporates all concepts from those 50? Need advice on this, badly, actually I am on my knees for help...
13:23:33 <HaskellLove> ...on this :)
13:23:47 <gwern> there are 50 array languages?
13:25:28 <napping> haskell to algol is a bit of a stretch
13:25:39 <Cale> HaskellLove: Picking up a new language is simple once you know at least a couple things similar to it.
13:25:49 <tensorpudding> you don't have to do every language
13:26:01 <tensorpudding> only the ones that you find interesting
13:26:26 <kmc> HaskellLove, you want to become an expert in the design of programming languages?
13:26:29 <napping> I'm not sure why you are trying to research lots of languages, but trying to pick things more different from the things you've already done should help
13:26:44 <HaskellLove> kmc yep, I am compiler engineer wannabe
13:27:04 <kmc> well you can write a compiler without understanding any of the theory or design considerations of programming languages
13:27:08 <kmc> just look at Go
13:27:12 <monochrom> He wants to know more languages than anyone cares to enumerate.
13:27:12 <napping> Like, if you've learned APL don't bother with J if you don't know any logic languages at all - assuming you want to learn everything
13:27:17 <kmc> monochrom, haha
13:27:21 <ben0x539> kmc: Ahaha
13:27:24 <HaskellLove> napping 2010 is year for research only and 2011 i start implementation of my language, multi-paradigm general solver  :)
13:27:38 <monochrom> Famouse last words.
13:27:41 <napping> It's hard enough to do one paradigm well
13:28:04 <napping> and probably more useful to concentrate on features and compilers in an area
13:28:13 <gwern> hm. mktemp seems to insist on creating a file
13:28:24 <napping> like if you want to make a good fortran compiler, learning about prolog won't be too useful
13:28:27 <Berengal> HaskellLove: The only way to be "safe" is to try to learn every language. If you find a language easy to learn, not providing any new insight, you can stop.
13:28:44 <napping> also, ask around once you have an area in mind.
13:29:01 <napping> like, "I'm thinking of learning X, Y, and Z  - which has more interesting features?"
13:29:01 <gwern> ah, wait, it's just very unclear a man page
13:29:03 <gwern> -t does it
13:29:07 <Berengal> Listen to what other people say about the language. If they say it's really good for one thing, don't stop trying to learn it until you've discovered why they're saying that
13:29:39 <gwern> aaannnd I have no idea who to complain to; 'this man page appeared in openbsd 2.1'
13:29:44 <gwern> gosh
13:29:48 <ben0x539> Berengal: Additionally, if they say it is really bad for about everything, do not stop learning php until you can make a convincing argument when anyone asks you about it
13:29:54 <kmc> hahaha
13:30:13 <HaskellLove> napping exactly, I am searching for those SETS that integrate ALL OTHERS. Like, functional: Haskell and Lisp/Scheme, imperative: C, oop : C++ and Java, Logic: Prolog, array oriented A++ and so on
13:30:28 <Berengal> ben0x539: That takes about 5 minutes anyway. You're not in any real danger on that part ;)
13:30:54 <ben0x539> HaskellLove: I think you should start with a thorough examination of all the paradigms present in C++ and how they interact
13:31:00 <Berengal> HaskellLove: Don't forget that language design is much more than just paradigms and featuresets.
13:31:03 <HaskellLove> Berengal yes, it takes time to really get to the core of a language... that is why i need to limit myself and choose only few to study in one year
13:31:55 <vy> Is there any function like `apply' in Scheme/CL?
13:32:05 <kmc> for Haskell?
13:32:06 <Berengal> HaskellLove: For some concrete examples; if you don't know Lisp, learn it. Since you already know Haskell, you can stop after macros.
13:32:12 <vy> kmc: Yup.
13:32:13 <kmc> vy, no, what would its type be?
13:32:15 <Berengal> vy: ($)
13:32:22 <HaskellLove> ben0x539 exactly, I mean, if you are into films you also will study bad films too right ? :)
13:32:36 <kmc> Berengal, apply takes a list of args (of different types) and applies them
13:32:45 <kmc> @src ($)
13:32:45 <lambdabot> f $ x = f x
13:32:57 <ben0x539> HaskellLove: C++ does a lot of things and it is relatively important to understand why they are bad
13:33:03 <HaskellLove> vy in Scheme, or it was in Lisp, hmm, I think there is "eval"? if that is what you asked
13:33:20 <Berengal> kmc: no, it takes a tuple and applies the function to that... well, provided you're wearing the haskell goggles
13:33:24 <HaskellLove> vy or you meant in haskell, sorry for misunderstanding typing fast :)
13:33:27 <napping> vy: isn't it called apply?
13:33:30 <kmc> HaskellLove, to be a PL expert you should definitely know: C, Scheme, Haskell, Java or C#, Python, Prolog, and one or more assembly languages
13:33:35 <kmc> that's sort of a basic spanning set
13:33:46 <Berengal> Agreed with kmc
13:33:47 <kmc> i recommend learning C++, as ben0x539 said, to see how they failed
13:33:47 <vy> kmc: I have a list of strings that I want to pass to a ADT ctor. Isn't such a thing possible?
13:33:48 <gwern> java or C#? so he gets no real OO langs?
13:33:50 <Berengal> But add agda
13:33:53 <medfly> kmc: you just wrote out what you know, no?
13:34:00 <tensorpudding> add smalltalk and ruby
13:34:02 <kmc> medfly, i don't know C# or Prolog :/
13:34:12 <kmc> and i don't know Java that well
13:34:14 <gwern> kmc: I've heard mercury these days is a better prolog
13:34:26 <medfly> the more I learn other languages the more I miss Haskell
13:34:32 <HaskellLove> kmc yep I got HLA from the assemblers family, and played around with masm a bit
13:34:33 <Berengal> Prolog + Agda = me knowing how to program in the haskell type system
13:34:36 <napping> I think prolog is more interesting
13:34:45 <kmc> it's especially important to learn C++, in order to absorb the lesson that throwing every feature into your language is not a good idea
13:34:49 <napping> it's got cut and assert and weird stuff like that
13:35:05 <kmc> because they will interact in ways that are impossible to understand
13:35:16 <napping> assuming the goal is languages that have interesting stuff, rather than clean languages that are nice to use
13:35:32 <medfly> brainfuck
13:35:45 <napping> but fortran is certainly worth a look, or at least fortran compilers
13:35:47 <kmc> likewise you can learn Perl
13:36:08 <kmc> which has a similar feature set to Python, but implements each feature as irreducible magic instead of a standard library on top of a core feature-set
13:36:12 <Berengal> I've heard Oz has lots of paradigms...
13:36:25 <HaskellLove> napping the goal is study as much languages as possible and design your language from start, such that in future you can support those and not screw up in design stage and later realize, oh s**t my foundation is all wrong.
13:36:29 <tensorpudding> maybe erlang
13:36:32 <arcatan> Forth or some other stack-based/concatenative language would be nice addition, too
13:36:38 <tensorpudding> yeah, forth
13:36:53 <kmc> or Postscript ;)
13:36:55 <HaskellLove> Berengal Oz definetly is on the list...
13:36:56 <napping> especially to learn the sorts of optimizations possible on Fortran, and why they break down in e.g. C
13:37:04 <kmc> aliasing?
13:37:06 <tensorpudding> hmm, occam-pi
13:37:31 <kmc> HaskellLove, you should also work through all of SICP
13:37:38 <chrisdone> Lisp is like Shang Tsung from Mortal Kombat
13:37:39 <kmc> and play around with your own extensions / modifications to Scheme
13:37:49 <kmc> and then do at least one Scheme implementation not in Scheme, i recommend Haskell
13:37:57 <chrisdone> powerful as it is but it can transform into other languages and use their powers
13:38:05 <tensorpudding> there are tutorials for making schemes
13:38:11 <napping> bonous points for recursive macros
13:38:13 <medfly> making schemes
13:38:15 <kmc> like Kirby
13:38:42 <tensorpudding> the book Essentials of Programming Language is a good book that involves making a scheme interpreter
13:38:43 <ski> (napping : .. and meta-circular macros ?)
13:38:45 <napping> like, (defmacro (foo ...) ... (foo ...) ...) working
13:38:48 <HaskellLove> yeah i start scheme in haskell tomorow
13:38:56 <HaskellLove> there is good tutorial
13:38:57 <medfly> tomorrow?
13:39:07 <medfly> oh, I read that wrong.
13:39:15 <autre> hi all; i've got a problem installing llvm with cabal; system is mac os x 10.6; anyone's got any ideas?
13:39:37 <HaskellLove> medfly yep, if you wanna do it we can go together and cooperate on the way if you want to
13:39:41 <tensorpudding> actually, the intepreter you make there isn't a real scheme
13:39:44 <napping> one thing to watch out for is making designs that unecessarily interfere with efficient implementation
13:39:55 <medfly> aww, that's so sweet.
13:41:59 <autre> the configure started by cabal dies with
13:42:01 <autre> checking for LLVMModuleCreateWithName in -lLLVMCore... no
13:42:03 <autre> configure: error: could not find LLVM C bindings"
13:42:45 <autre> any ideas?
13:44:25 <kmc> install the llvm c library
13:44:42 <autre> i've installed it (throught homewbrew)
13:44:50 <autre> version 2.6
13:44:52 <napping> then search for options to point configure at it
13:44:58 <kmc> in some nonstandard prefix?
13:45:14 <autre> that's the command i used
13:45:15 <autre> cabal install llvm --configure-option --with-llvm-prefix=/usr/local/Cellar/llvm/2.6
13:45:18 <napping> or make sure it's installed in a standard place that configure is already checking, yess
13:45:36 <napping> was that the first test?
13:46:02 <autre> checking for llvm-config... /usr/local/Cellar/llvm/2.6/bin/llvm-config
13:46:15 <autre> checking llvm-c/Core.h usability... yes
13:46:16 <autre> checking llvm-c/Core.h presence... yes
13:46:18 <autre> checking for llvm-c/Core.h... yes
13:46:18 <napping> that is, maybe despite that option it's not finding llvm, or maybe your version of llvm is missing some functions it expectes
13:46:19 <autre> checking for LLVMModuleCreateWithName in -lLLVMCore... no
13:46:21 <autre> configure: error: could not find LLVM C bindings
13:46:44 <napping> Ok, sounds like not the llvm version it expects. I don't know what it does want
13:47:13 <autre> yeah, maybe; i'm compiling the version downloaded from the llvm; i'll give it a try with that
13:47:14 <autre> thanks
13:47:30 <napping> I'd check the docs for the haskell package and see if it says what it wants
13:47:44 <gwern> oh dear. I just made a pure variable used in a bunch of code an impure variable. time for a world of pain :(
13:47:58 <autre> the package info want llvm-2.6
13:48:01 <napping> gwern: what's the change?
13:48:14 <gwern> napping: nothing important; I can alway use unsafePerformIO
13:48:16 <Berengal> gwern: Repent! Repent!
13:48:22 <EvanR_> hehe
13:48:28 * gwern blinks. how did Berengal type that that fast
13:48:38 * Berengal is like a tiger
13:48:39 <napping> autre: you're sure you've compiled the LLVM libs?
13:48:51 <autre> yes
13:48:55 <jmcarthur> Berengal has it as a keyboard shortcut.
13:48:55 <napping> but tigerer!
13:48:59 <EvanR_> i use unsafePerformIO for all my IO actions, not a big deal. i know what im doing
13:49:09 <EvanR_> of course thats only when im using C
13:49:17 <napping> it's the extra er in B(er)engal
13:50:40 <Berengal> EvanR_: It's not unsafePerformIO, it's just that C implicitly #defines ε return
13:51:03 <EvanR_> :o
13:51:29 <Berengal> (and #defines return contEscapeReturn)
13:52:01 <Berengal> Well, inside the compiler innards. It's not like programmers would ever understand continuations...
13:53:25 <EvanR_> is it ok to use myThreadId
13:53:51 <napping> what would be wrong with myThreadId?
13:53:56 <EvanR_> ghc only
13:54:00 <EvanR_> but i guess thats half of haskell
13:54:50 <knobo> What do the "| m -> e" part in "class Monad m => MonadError e m | m -> e where...." mean?
13:54:54 * hackagebot upload: UMM 0.1.5 - A small command-line accounting tool (UweHollerbach)
13:54:59 <kmc> there's no standard for threads in Haskell, is there?
13:55:06 <kmc> knobo, it means that for any type m, there can be only one type e
13:55:11 <kmc> it's called a "functional dependency"
13:55:17 <napping> EvanR_: why do you need thread ids?
13:55:30 <napping> EvanR_: being able to use them for anything is also GHC-only
13:55:45 <EvanR_> i am using them as keys in a Data.Map to identify players
13:55:48 <napping> hugs has ThreadId = ()
13:56:09 <napping> and what do you do after you identify them?
13:56:32 <EvanR_> either interpret their command as them, or send them a message
13:56:40 <napping> be careful about hanging onto threadIds
13:56:51 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14439#a14439 <-- suggestions about how to move uniqueName into the case/let expression? I don't like having both 'outfile' and 'outfile''
13:57:13 <EvanR_> napping: planning on removing them from the map on disconnect...
13:57:21 <EvanR_> and killing the thread
13:57:29 <napping> if you're not using throwTo then you need to store some kind of communication channel anyway
13:57:52 <knobo> kmc: where can I read about it?
13:58:19 <BMeph> @where GHC
13:58:20 <lambdabot> http://haskell.org/ghc
13:58:51 <kmc> http://haskell.org/haskellwiki/Functional_dependencies
13:59:18 <napping> sounds like you could probably pick unique ids and pass them in when you fork the threads
13:59:33 <EvanR_> i was going to do that
13:59:34 <napping> is it running over the network?
13:59:35 <knobo> That's an extension to ghc.
13:59:47 <BMeph> knobo: Specifically, http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
13:59:55 <napping> because turning ThreadIds into some kind of number you could pass to the client isn't so nice
14:00:02 <EvanR_> picking unique ids would involve either random numbers (which werent already taken) or forever incrementing something. but i didnt like either of those
14:00:12 <knobo> "There should be more documentation, but there isn't (yet). Yell if you need it. "
14:00:15 <EvanR_> napping: its for internal use
14:00:25 <knobo> as it says in the documentation.
14:00:35 <napping> oh, then how about Unique?
14:00:41 <kmc> knobo, there's a lot more sections after that though
14:00:47 <EvanR_> napping: let me check
14:01:18 <knobo> the wiki looks better
14:01:24 <ski> gwern : i suppose you could turn the `let'-binding into a `<-' ..
14:01:25 <EvanR_> napping: another thing is i realized i needed the thread ids so i could kill the thread... but maybe i dont
14:01:30 <knobo> kmc: yes it is :)
14:01:41 <knobo> or there are.
14:02:03 <EvanR_> napping: if i disconnect someone, the reader thread should catch an exception.. or something
14:02:31 <gwern> ski: perhaps, but the type errors are a bit much for me
14:02:34 <napping> EvanR_: well, if you want to use killThread that's already not supported by hugs
14:02:46 <napping> cause again, ThreadId = ()
14:02:54 <EvanR_> my original question probably should have been 'is it ok to be ghc only'
14:02:56 <ski> gwern : would you like me to try a rewrite ?
14:02:59 <gwern> ski: sure
14:03:32 <napping> Yeah, that's fine - but it still might not be a good idea to hang onto a threadId
14:04:30 <ski> gwern : i suppose you don't want to unfold `uniqueName', right ?
14:04:36 <gwern> ski: probably not
14:04:36 <napping> the docs claim the thread can't be GC'd while the ThreadId exists
14:04:46 <gwern> ski: it's long enough that I think inlining it would beu nclear
14:05:01 <napping> Unique is really just a builtin counter thingy, I think
14:05:49 <EvanR_> napping: the problem with incrementing my own value is a guy could connect and disconnect over and over just to make my number go up...
14:05:53 * EvanR_ hates that
14:06:07 <napping> if it's internal you don't have to care
14:06:16 <EvanR_> even with 64bit numbers (or bignum) i just dont like it
14:06:35 <napping> It's Data.Unique, instance Eq and Ord
14:06:42 <EvanR_> yeah
14:06:47 <napping> and the promise no two uniques will be different
14:06:53 <napping> rather, the same
14:07:09 <napping> (and secretly, it wraps an Integer)
14:07:11 <EvanR_> i like this
14:07:18 <EvanR_> dont like that ;)
14:07:22 <EvanR_> anyway
14:07:30 <napping> umm, it's never going to overflow 64 bits
14:07:39 <EvanR_> i still dont like it
14:08:39 <napping> well, I guess you might consider stable names
14:08:45 <napping> dunno if they are recycles, though
14:09:12 <napping> besides, how do you think threadId's implement ord?
14:09:24 <EvanR_> come to think of it, threadId probably wont be 'recycled' either, so its not a good use for it either
14:09:51 * EvanR_ starts making a recycling unique type ;)
14:09:55 <gwern> wonder if lisp macros do anything we can't do with TH, quasiquotations, and lazy evaluation
14:10:07 <ski> @instances Data.Traversable.Traversable
14:10:08 <napping> well, stable names are offsets in the stable name table
14:10:08 <lambdabot> Maybe, []
14:10:13 <ski> @instances-importing Data.Traversable Traversable
14:10:14 <lambdabot> Maybe, []
14:10:29 <ski> @instances-importing Data.Tuple Data.Traversable.Traversable
14:10:30 <lambdabot> Maybe, []
14:10:38 <napping> so you could do something like that, with finalizer and weak references and a free list and stuff
14:10:53 <ski> gwern : hygiene
14:11:14 <napping> but maybe you should consider your ping time, and how long it would take to overflow the counter
14:11:16 <EvanR_> and that sounds overengineered :(
14:12:10 <EvanR_> napping: my rng wont overflow in like a googol^1000 rolls, im engineering this thing for the long haul ;)
14:12:12 <napping> it's not like the GC promises to preserve pointer order, so you have to build a free list to track unused things yourself
14:12:23 <napping> nah, rng will collide more easily
14:12:28 <napping> birthday paradox and all
14:12:45 <EvanR_> sorry, i wasnt talking about using rng for unique ids
14:12:58 <ski> gwern : i can't find `instance Traversable ((,) w)' in `Data.Traversable' or elsewhere. it would be simpler, using that
14:12:58 <EvanR_> just that other stuff in here is built for long term ;)
14:13:18 <gwern> ski: I will live, I suppose
14:13:21 <EvanR_> i like saying 'it will never ___' ;)
14:13:21 <napping> MT only gives you a period like 2^19937
14:14:09 <napping> if you want that you need a distributed system supporting hot upgrades
14:14:11 <EvanR_> im using this instead...http://en.wikipedia.org/wiki/Multiply-with-carry
14:15:00 <napping> which means something like Erlang, or coding us up some nice infrastructure
14:15:08 <EvanR_> the one at the bottom with b = 2^32 a = 109111
14:15:32 <EvanR_> yeah i dont want to be that ambitious
14:15:35 <EvanR_> probably
14:15:54 <napping> well, the RNG will give out long before an Integer counter
14:15:58 <ski> hrm
14:16:10 <EvanR_> itll loop, but at least i wont be wasting memory ;)
14:16:26 <EvanR_> and no one will notice because it will be the year 50 bajillion
14:16:42 <napping> it's a logarithmic amount of memory with time
14:16:49 <EvanR_> ah yeah
14:17:00 <napping> well, in increments
14:17:11 <ski> @type uncurry (fmap . (,))
14:17:13 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
14:17:43 <ski> gwern : i can use `strength = uncurry (fmap . (,))', i suppose ..
14:17:52 <gwern> soemtimes you have to admit defeat
14:17:53 <EvanR_> napping: so if i use Unique, id like to eliminate ThreadId. if i hClose a handle that a thread is waiting on , will it fail and allow me to end the read from inside?
14:18:10 <gwern> 'I'd be interested to hear if anyone has solved the problem of embedding a series of pages inside of another (in the sense of Seaside) in a pure functional way. In other words, here's my challenge: write http://www.seaside.st/about/examples/multicounter using the same monadic style.'
14:18:12 <EvanR_> end the thread
14:18:15 <gwern> monad transformer?
14:18:25 <gwern> http://news.ycombinator.com/item?id=1004938
14:19:01 <napping> EvanR_: I think it should, but you should test - windows is a bit weird about socket IO it seems
14:19:29 <EvanR_> i have to say, despite haskells mostly platform indepedentness, i hope no one ever runs this on windows
14:19:32 <EvanR_> its a server
14:20:18 <napping> hmm, it seems GHC doesn't have weak arrays
14:21:43 * gwern has spent so much time on gitit lately it's not even funny
14:21:46 <Heffalump> do you have an application for them?
14:22:05 <napping> Heffalump: well, just EvanR's thing. Basically to make something like a custom StableName
14:22:31 <largos> could someone take a look at some warnings I'm running into while building hsmagick?  It looks like there's some dependency on base 3.???, but I'm pretty sure I have base 4 installed...
14:22:37 <largos> here's the output from the cabal build: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14440#a14440
14:22:51 <napping> where table slots get linked into a free list if the handle becomes unreferenced
14:22:58 <gwern> man who imports Prelude?
14:23:03 <napping> I was thinking one pointer to the finalizer in the table would be cheaper than one in each item
14:23:09 <gwern> largos: quick fix, edit hsmagick.cabal to remove -Werror from ghc-options:
14:23:27 <ski> (gwern : i'm not sure whether Formlets might be appropriate for that ..)
14:23:31 <gwern> largos: slow fix, complain to author that they should knock off the 'import Prelude' stuff
14:23:32 <largos> gwern: yeah, I thought about that.  I'd like to do it the "right" way though
14:23:39 <gwern> me, I'd do both
14:23:55 <largos> gwern: I commented out the only 'import Prelude' and that didn't change anything
14:23:56 <napping> gwern: just plain import Prelude?
14:24:09 <gwern> napping: well, I haven't looked at it, but I assume that's what the module says
14:24:16 <napping> import Prelude() is useful to drop in your own versions
14:24:41 <largos> only one file has an import Prelude, and it looks like this: import Prelude hiding (maximum, minimum)
14:24:44 <napping> but yeah, I think the warning is only if you have a plain unqualified import
14:24:58 <napping> or at least it should be
14:25:05 <c_wraith> see, import Prelude hiding ... is relative common
14:27:13 <largos> I don't understand why the build system thinks there is a dependency on base 3.x
14:27:25 <mauke> because there is
14:28:01 <largos> mauke: is it implicit somehow? I don't see anything that fixes the base dependency to a specific version
14:28:14 <largos> (cabal unpack hsmagick will get the source I'm looking at, fwiw.)
14:28:22 <mauke> what's the dependency list?
14:28:45 <largos> build-depends:       base, directory, filepath, pretty, process
14:29:07 <mauke> hmm
14:29:30 <mauke> unrecognised command: unpack (try --help)
14:29:53 <largos> are you running a 0.6.x cabal install?
14:30:00 <largos> unpack my be new...
14:30:06 <mauke> yes
14:30:15 <largos> ok, it's probably new to 0.7.x
14:30:35 <largos> pasting the cabal file
14:30:40 <largos> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14441#a14441
14:32:12 <mauke> hmm, I don't see where base-3 is coming from
14:32:22 <mauke> unless one of the dependencies was built against base-3
14:33:00 <largos> mauke: ah... that could be
14:33:33 <gwern> '1987 - Larry Wall falls asleep and hits Larry Wall's forehead on the keyboard. Upon waking Larry Wall decides that the string of characters on Larry Wall's monitor isn't random but an example program in a programming language that God wants His prophet, Larry Wall, to design. Perl is born.'
14:33:37 <largos> mauke: I just installed ghc 6.12 yesterday, so if base 4 is new to that, then I probably have local stuff in my ~/.cabal that was build with base 3.x
14:33:48 <largos> is it possible to rebulid everything I've installed with cabal?
14:35:21 <dcoutts> mauke, largos: what's the base 3 / 4 problem?
14:36:06 <ski> gwern : this makes me want `case' on declarations, as well as "floating out bindings in actions"
14:36:24 <HaskellLove> anyone here has written a type checking algorithm? It would be cool to see some code...
14:36:55 <largos> dcoutts: I'm trying to install hsmagick, and it's throwing a warning about base 3 being used
14:37:05 <largos> dcoutts: and I can't figure out why it's using base 3 instead of 4
14:37:10 <dcoutts> largos: that's not something to worry about too much
14:37:20 <dcoutts> largos: unless you're the package author
14:37:24 <mauke> dcoutts: but -Werror makes the build fail
14:37:25 <largos> dcoutts: well, it's escalating to an error
14:37:32 <jlouis> HaskellLove: do you ask for type checking or type reconstruction?
14:37:40 <largos> dcoutts: and I'm trying to learn my way around haskell & build systems, so I'd like to find the "right" fix
14:37:56 <ski> (gwern : so i have two ways to do it, and neither is very pretty. i think i'll leave it at that, now)
14:38:06 <dcoutts> largos: so the .cabal file needs fixing
14:38:20 <dcoutts> largos: currently it doesn't say what version of base it wants, so cabal picks base 3
14:38:27 <largos> ah...
14:38:43 <largos> dcoutts: why does it default to the lower version?
14:38:57 <dcoutts> largos: if it said something like, build-depends: base >=3 && < 5, then cabal would be able to see that the package claims to be able to work with both, and it'd pick the higher one
14:39:30 <dcoutts> largos: but saying, build-depends: base >=3 really just says that you know it works with v3, but have no idea about later versions.
14:39:59 <largos> dcoutts: ok... this one dosen't specify any versions at all (just "base")
14:39:59 <dcoutts> largos: we used that heuristic to stop everything breaking on the transition from base 3 to 4
14:40:06 <dcoutts> largos: indeed
14:40:43 <dcoutts> largos: and so cabal made the right choice, it does build with base 3
14:41:28 <HaskellLove> jlouis type checking contains type reconstruction, as far as I know... so either you have would be awesome to see :) I supose type checking algorithm is too much for one person to write, so i guess you have type reconstruction?
14:42:00 <dcoutts> largos: where does it say -Werror, I can't see that
14:42:10 <largos> dcoutts: the -Werror is in a file header
14:42:14 <jlouis> HaskellLove: type checking does not always contain reconstruction/inference
14:42:28 <largos> (or two...)
14:42:35 <dcoutts> largos: ah, sneaks past the -Werror check that hackage does
14:42:58 <dcoutts> largos: hackage bans -Werror in .cabal files for exactly this reason. Well I suggest you go remove the -Werror flags.
14:43:00 <largos> huh, does hackage not allow -Werror?
14:43:02 <jlouis> By the way, haskell now has a bittorrent client able to seed, if conjure never went there
14:43:05 <largos> ah....
14:43:11 <HaskellLove> jlouis yep i know
14:43:14 <dcoutts> largos: because it breaks everything when the compiler adds a new warning
14:43:21 <largos> yup...
14:43:47 <largos> ok, I'm playing with adding version bounds to the base dependency, fixing a couple other warnings, and I'll pull out the -Werrors, and pass on a patch to the author if it all works out
14:45:00 <napping> using --contraint='base >= 4' option is handy if you don't want to fix it
14:45:22 <largos> dcoutts: thanks for the help!
14:45:52 <mauke> 'cabal upgrade' says: cabal: dependencies conflict: ghc-6.10.2 requires hpc ==0.5.0.3 however
14:45:57 <mauke> hpc-0.5.0.3 was excluded because hpc-0.5.0.4 was selected instead
14:46:10 <mauke> what does that mean?
14:46:29 <mauke> any why is there no comma before "however", but a "\n" after it?
14:47:19 <dcoutts> mauke: it had the choice of hpc-0.5.0.4 and hpc-0.5.0.3, it picked the later one. Then it found it needed the ghc-6.10.2 package and that one needs the older hpc. Then it bails out.
14:47:29 <largos> mauke: shouldn't it have a semicolon before and a comma after? :)
14:47:34 <mauke> yeah, or that
14:47:35 <dcoutts> mauke: if it were smarter it might have picked hpc-0.5.0.3 in the first place
14:47:58 <dcoutts> mauke: I'm happy to accept patches to improve the grammar or wording in error messages.
14:48:32 <dcoutts> mauke: the reason there's a \n is because that list of why each alternative was not picked can get rather long
14:48:38 <mauke> starting from the ghc-6.10.2 constraints seems like a good idea, because cabal can't just update my ghc
14:48:56 <dcoutts> mauke: indeed, it needs an extra bottom-up pass in the solver.
14:49:01 <copumpkin> zomg I haz 6.12
14:49:11 <dcoutts> I think I know how to do it, it's a matter of hacking time
14:49:55 <mauke> why does --constraint='hpc ==0.5.0.3' not fix it?
14:51:09 <dcoutts> mauke: I'm not sure
14:51:24 <dcoutts> mauke: you're just running "cabal upgrade" on its own?
14:51:27 <mauke> yes
14:56:00 <_y_> this is not actually a Haskell question, but I figured that some Haskell programmer probably knows the answer, which I couldn't find online -- in the context of programming language theory, what is "alpha-varying"?
14:56:09 <dcoutts> mauke: sorry that makes no sense to me, cabal upgrade does not run the solver at all
14:56:18 <byorgey> _y_: it just means renaming bound variables
14:56:21 <dcoutts> mauke: what version of cabal is that?
14:56:31 <byorgey> _y_: for example, we can alpha-vary  \y -> y + 2   to get  \x -> x + 2
14:56:35 <byorgey> which is really the same thing
14:56:37 <mauke> dcoutts: 0.6.0, using 1.6.0.1
14:56:47 <dcoutts> mauke: ohh, ancient
14:56:49 <byorgey> we say those two expressions are equivalent "up to alpha equivalence"
14:57:03 <mauke> running 'cabal upgrade cabal-install' now
14:57:15 <_y_> ok, so just renaming variables in a non-sloppy way that doesn't cause the expression to become incorrect
14:57:16 <copumpkin> _y_: are you an agda mixfix operator?
14:57:27 <dcoutts> mauke: we've mostly disabled the upgrade command in newer versions
14:57:31 <_y_> copumpkin:  I have no idea what you just said, probably not
14:57:34 <byorgey> _y_: right =)
14:57:39 <mauke> dcoutts: then how do I upgrade?
14:57:42 <dcoutts> mauke: install is the sensible thing to do
14:57:44 <_y_> thanks byorgey :-)
14:58:04 <mauke> dcoutts: will that install dependencies?
14:58:16 <dcoutts> mauke: upgrade is the same as install except that it also tries to upgrade all dependencies, and that runs into trouble when it tries to upgrade code packages.
14:58:20 <napping> dcoutts: I think something like a SAT solver is a reliable way to go
14:58:25 <dcoutts> code/core
14:59:07 <dcoutts> napping: we've thought about this quite a bit. You need a solver that can cope with soft constraints. SAT solvers are generally not good at that. You also need excellent error messages.
14:59:54 <gwern> (dammit. gitit's RSS is totally fucked up)
15:00:02 <dcoutts> napping: so I'd be happy to be proven wrong, but my intuition is that we want a solver based on more general constraint solving, not on SAT.
15:02:03 <gwern> @hoogle [m a] -> [a]
15:02:04 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
15:02:04 <lambdabot> Data.Graph flattenSCCs :: [SCC a] -> [a]
15:02:04 <lambdabot> Data.Graph.Inductive.Basic postorderF :: [Tree a] -> [a]
15:02:23 <HaskellLove> "C++ templates and ML polymorphic functions are implemented differently. The reason for the difference is not related to the difference between explicitly polymorphic syntax and implicitly polymorphic syntax. The need for different implementation techniques arises from the difference between data representation in C and data representation in ML." Said the above, is not having implicit...
15:02:25 <HaskellLove> ...parametric polymorphism in C++, a negative thing for the language? Or, we cay say that it must have explicit PP since it operates on much lower level then ML?
15:02:31 <mauke> doesn't cabal know which packages are core?
15:02:49 <dcoutts> mauke: nope
15:02:56 <mauke> that sucks
15:03:01 <dcoutts> how would it know?
15:03:12 <dcoutts> and what would it do with that
15:03:23 <dcoutts> and what if your notion of a core package is not the same as mine
15:03:46 <dcoutts> the upgrade feature needs completely rethinking
15:03:54 <mauke> core package := requires compiler upgrade
15:03:56 <largos> dcoutts: what *is* a core package? (anything that comes with the ghc distribution?)
15:04:29 <mauke> cabal: dependencies conflict: ghc-6.10.2 requires directory ==1.0.0.3 however
15:04:29 <mauke> directory-1.0.0.3 was excluded because ghc-6.10.2 requires directory ==1.0.1.0
15:04:47 <dcoutts> mauke: don't use upgrade! :-)
15:04:49 <gwern> given 'Foo = Bar String | Quux String', should I epxect 'changesToPagenames (_ x:xs) = x : changesToPagenames xs' to work?
15:04:53 <mauke> dcoutts: I didn't
15:05:20 <dcoutts> mauke: ohh, you've got things in a twist, see this FAQ: ...
15:05:22 <c_wraith> dcoutts: any plans for a cabal target to launch ghci in the build env of something in the cabal file?
15:05:44 <dcoutts> c_wraith: only if someone writes the code. There's a ticket on it if you're interested.
15:06:10 <dcoutts> mauke: http://haskell.org/cabal/FAQ.html#dependencies-conflict
15:06:13 <napping> dcoutts: well, it's possible to encode relative contraints into SAT if you really must, or maybe a minsat style solver can incorporate them more directly
15:06:27 <c_wraith> dcoutts: might be interesting, though there's one obvious technical challenge (multiple targets in the cabal file)
15:06:36 <dcoutts> napping: you mean constraints like "foo >= 3"
15:06:44 <napping> for each version of a package you make a "using v" variable, a "using >= v" variable, and a "using <= v" variable
15:06:52 <c_wraith> rather, that's a UI challenge, not a technical challenge
15:07:02 <dcoutts> napping: right, but we also need soft constraints, like "prefer later versions of this package"
15:07:04 <napping> dcoutts: yes, are there other sorts of contraints you need?
15:07:12 <b0fh_ua> Hi again. In the following code "getNextItem (x,_) xs = maximumBy (\l r -> compare (snd l) (snd r) ) $ filter ( \(f,_) -> f > x ) xs" if filter return an empty list, exception will be thrown. What is the correct way to implement such expression?
15:07:18 <mauke> dcoutts: why doesn't cabal tell me what A, B and C are?
15:07:57 <napping> oh, that sort of soft constraint. Hmm, that's a different sort of problem, isn't it
15:08:08 <dcoutts> mauke: because someone would have to write the code to do that, there are other higher priorities, like making it not happen in the first place.
15:08:23 <mauke> oh hey, all my packages are broken
15:08:40 <mauke> probably because they depend on rts, which says:   include-dirs: PAPI_INCLUDE_DIR doesn't exist or isn't a directory
15:08:54 <dcoutts> mauke: that was a bug in ghc-6.10.2
15:09:19 <mauke> the FAQ doesn't apply to me. I have no user packages.
15:09:30 <dcoutts> mauke: the same can happen with global ones
15:09:48 <mauke> then the FAQ is wrong
15:10:07 <dcoutts> mauke: no it's just the common case
15:10:35 <mauke> is there any way to find out what exactly is wrong with my packages and how I can fix it?
15:10:40 <dcoutts> or maybe, yes, but it's the common case
15:11:40 <dcoutts> mauke: if it's all in the global package db it may not be easily recoverable since the original package registration may be lost.
15:12:02 <dcoutts> mauke: since you'll have recompiled some core package, overwriting the registration for the original.
15:12:26 <mauke> what's a core package?
15:12:34 <dcoutts> ones that come with ghc
15:12:38 <napping> dcoutts: I've looked into this a bit, and it seems you should be able to deduce a lot of constraints without making any choices
15:12:55 <dcoutts> mauke: you can use ghc-pkg field foo depends
15:13:17 <mauke> huh?
15:13:28 <dcoutts> napping: yes, my plan is to add a bottom up pass too. The idea is to eliminate impossible choices early.
15:13:33 <napping> If you're soft consstraints are lexically ordered it doesn't require much from the solver - when you need to make a free choice just pick the most preferred version of the most important unresolved package
15:13:44 <dcoutts> mauke: to see what the dependencies of a particular package are
15:13:52 <mauke> I'm trying to find a list of packages that come with ghc
15:13:57 <napping> I don't think one bottom up pass will do it, but it's easy enough to describe a fixpoint
15:14:30 <dcoutts> napping: right, that requires the SAT solver give you pack a partial solution and let you carry one having applied extra constraints
15:14:53 <_y_> copumpkin:  I looked it up and I can now say that no, I am not an Agda mixfix operator
15:14:54 <napping> but that's exactly how modern SAT solvers work - they propagate strict interpretations, and then make a random backtrackable choice when that runs out
15:15:02 <copumpkin> _y_: :(
15:15:07 <copumpkin> 5 y 6
15:15:09 <dcoutts> napping: right, not a single pass, but you switch between bottom up and top down until the point where you must make a guess.
15:15:40 <napping> well, if you want to think of it like that I guess. Oh, I gues we shouldn't have cyclic dependencies
15:16:11 <napping> still if p depends on foo, and you decide foo-v is not usable after all then you can also need to go back up and prune some versions of p
15:16:26 <napping> I'm thinking more like CHR, or a worklist of things that need to propagate
15:16:50 <napping> but whatever's easiest to code I gues
15:17:07 <napping> How would you trade off different packages?
15:17:17 <dcoutts> napping: so yes I expect it's possible with a SAT solver, but it needs a lot from the API, you need it to be restartable and you need to be able to minimise the unsolvable bits, and then map that back to the problem domain, to generate an error message.
15:18:32 * hackagebot upload: happstack-util 0.4.1 - Web framework (JeremyShaw)
15:18:34 * hackagebot upload: sendfile 0.6.1 - A portable sendfile library (JeremyShaw)
15:18:36 * hackagebot upload: happstack-data 0.4.1 - Happstack data manipulation libraries (JeremyShaw)
15:18:47 <napping> the variable ordering needs to be customizable, I don't think you need full restarts
15:18:55 <dcoutts> napping: also, I don't think we actually need to do full backtracking. My intuition is that if we take full advantage of the information available at each stage, use global heuristics and some local bounded backtracking then we can get away with it.
15:19:15 <b0fh_ua> Is it possible to return something like "null" from function if there's really no way to calculate the value?
15:19:26 <b0fh_ua> is Maybe right thing to use in such case?
15:19:27 <napping> depends how nice your packages are. If you allow disjunctive constraints I'm pretty sure it's NP complete
15:19:30 <kmc> b0fh_ua, yes
15:19:38 * hackagebot upload: happstack-ixset 0.4.1 - Efficient relational queries on Haskell sets. (JeremyShaw)
15:19:41 <kmc> or the simple hack is to quit the whole program, with "error"
15:19:43 <Berengal> b0fh_ua: It's possible to not return (i.e. crash, or loop infinitely), but you probably don't want that...
15:19:56 <dcoutts> napping: it's certainly NP complete in general, but we only need to handle package dbs that occur in practise.
15:20:08 <dcoutts> napping: the current solver is clearly incomplete, it works in P time.
15:20:19 <kmc> putting "null" into every type is a big disaster
15:20:25 <kmc> that's why we have the explicit Maybe type constructor
15:20:36 <napping> well, guess I'll have to dust off some code and run it against the Hackage database
15:20:42 <kmc> most of the time, you know something isn't null... you want your language to take that as a default
15:21:02 <dcoutts> napping: my biggest concern with the SAT approach is the error messages.
15:21:12 <Berengal> kmc: Not the least because if it's a default, less things will be null
15:21:18 <napping> oh, what to do when it's unsatisfiable
15:21:32 <napping> well, I think that's hard in general
15:21:59 <_y_> why?  can't the SAT solver return an unsat core which indicates why it's not satisfiable?
15:22:05 <napping> what do you want to report if 10 packages are invovled in the inconsistency
15:22:26 <dcoutts> napping: indeed which is a slight advantage to using a less powerful solver, if it has fewer possibilities to consider, and it does them in some more predictable order.
15:22:27 <napping> yeah, finding an unsat core is standard (maybe not unique?), but it can be big
15:22:48 <dcoutts> and then how do you map it back to the original problem domain
15:22:59 <dcoutts> and then construct a comprehensible error message from that
15:23:02 <dcoutts> very hard
15:23:14 <napping> Oh, well the only vars you need map nicely to package versions
15:23:28 <dcoutts> and conditional flags
15:24:43 <napping> so an unsat core will consists of things like need "foo<=2" and "foo>=3" and some other packages
15:24:44 <dcoutts> napping: but people also want to know, "well what alternatives did you try and why didn't they work"
15:25:08 <napping> that's what an unsat core is - enough things you tried and rules between them to force inconsistency
15:25:09 <dcoutts> and then you need to know why you were trying to pick foo <= 2
15:25:12 <chrisdone> @echo                , ap ((text.).(++)) show "> ap ((text.).(++)) show "
15:25:13 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "chrisdone!n=user@unaffiliated/chrisdone", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo                ,
15:25:13 <lambdabot> ap ((text.).(++)) show \"> ap ((text.).(++)) show \""]} rest:", ap ((text.).(++)) show \"> ap ((text.).(++)) show \""
15:25:16 <dcoutts> what package needed that, etc
15:25:24 <napping> but a full list might be messy
15:25:40 <chrisdone> @echo                 , ap ((text.).(++)) show "> ap ((text.).(++)) show "
15:25:41 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "chrisdone!n=user@unaffiliated/chrisdone", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo                 ,
15:25:41 <lambdabot>  ap ((text.).(++)) show \"> ap ((text.).(++)) show \""]} rest:", ap ((text.).(++)) show \"> ap ((text.).(++)) show \""
15:25:45 <chrisdone> daw
15:26:11 <dcoutts> napping: so something to look at is SuSE linux. It uses a SAT solver for its package manager. It's binary packages of course, slightly different from source packages.
15:26:43 <napping> oh, that's interesting
15:27:36 <napping> yeah, the raw info might be something like the fact that the package you asked for wanted bytestrings-2 and syb-3 and each of the ten bytestrings-2 packages need foo <= 3 and each of the ten syb-3 packages need foo >= 4
15:28:03 <napping> but extracting a summary like that from an enumeration of 20some packages might be hard
15:28:06 <b0fh_ua> is there any safe version of maximumBy function, which will return an empty list if called with empty list?
15:28:27 <chrisdone> @src maximumBy
15:28:28 <lambdabot> Source not found. You speak an infinite deal of nothing
15:28:28 <mauke> b0fh_ua: impossible
15:28:54 <copumpkin> b0fh_ua: it could return Nothing or Just a
15:29:01 * copumpkin whistles
15:29:23 * mauke rebuilds xmonad
15:29:38 <b0fh_ua> nicew
15:29:47 <copumpkin> @let nonEmpty _ [] = Nothing; nonEmpty f xs = Just (f xs)
15:29:48 <lambdabot>  Defined.
15:30:02 <copumpkin> > nonEmpty (maximumBy (comparing snd)) []
15:30:04 <lambdabot>   Nothing
15:30:14 <copumpkin> > nonEmpty (maximumBy (comparing snd)) [(1,2),(4,100)]
15:30:16 <lambdabot>   Just (4,100)
15:31:31 * chrisdone is sad because the v4l2 demo from the documentation doesn't work =(
15:31:54 <b0fh_ua> so looks like I have to use Maybe
15:32:16 <EvanR_> maybe is awesome!
15:32:25 <b0fh_ua> since my function can return an item or nothing if list is empty after filtering
15:32:32 <b0fh_ua> EvanR_: may be ;)
15:33:24 <b0fh_ua> if I define function which returns Maybe (Int, Int) - how do I get it's Just value?
15:33:28 <Berengal> b0fh_ua: If you're already using lists, there's a listToMaybe function defined already
15:33:36 * hackagebot upload: happstack-state 0.4.1 - Event-based distributed state. (JeremyShaw)
15:33:37 <Berengal> b0fh_ua: Pattern match on it
15:33:38 * hackagebot upload: happstack-server 0.4.1 - Web related tools and services. (JeremyShaw)
15:33:40 * hackagebot upload: happstack 0.4.1 - The haskell application server stack + code generation (JeremyShaw)
15:33:41 <Berengal> Or use maybe/fromMaybe
15:33:43 <Berengal> @type maybe
15:33:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:33:46 <Berengal> @type fromMaybe
15:33:47 <lambdabot> forall a. a -> Maybe a -> a
15:35:04 <HaskellLove> Haskell has only implicit parametric polymorphism. It does not allow explicit? ML has both I think...
15:35:36 <b_jonas> what does that mean?
15:35:47 <chrisdone> b_jonas: heh, I thought the same sentence in my head
15:36:19 <Saizan> that you can't instantiate type variables explicitly, maybe?
15:36:40 <Berengal> You can't have implicit parameters... well, you can, but not really...
15:36:48 <byorgey> but you can implicitly instantiate type variables explicitly, by giving a type annotation to function arguments =)
15:36:58 <Saizan> like, you can say "fromMaybe @ Int" and having it be of type "Int -> Maybe Int -> Int"
15:37:03 <b_jonas> oh, that think
15:37:14 <HaskellLove> b_jonas well in ML it is implicit like in Haskell, and in C++ you do it explicitly with templates
15:37:38 <b_jonas> explicit module instanciation instead of the instance types derived from the type
15:37:42 <b_jonas> I see
15:37:44 <Berengal> HaskellLove: You still write explicit type parameters in Haskell. What's implicit is the type signatures themselves
15:37:51 <Spockz> I wrote an article on how to determine folds on datatypes and such. Does anyone care to comment? http://www.reddit.com/r/haskell/comments/agigh/haskell_datatypes_and_folds/
15:37:59 <b_jonas> HaskellLove: actually C++ has both, it can derive template arguments automatically in many cases
15:39:10 <increpare> @djinn a -> a
15:39:11 <lambdabot> f a = a
15:39:17 <chrisdone> copumpkin: I think you've defined `list'
15:39:18 <increpare> @djinn ((a -> Bool) -> [a] -> [a]) -> ((a ->m Bool) -> [a] -> [a])
15:39:19 <lambdabot> Error: Undefined type []
15:39:26 <copumpkin> hm?
15:39:35 <copumpkin> oh
15:39:41 <increpare> ((a -> Bool) -> b -> b) -> ((a ->m Bool) -> b -> b)
15:39:51 <chrisdone> list :: b -> ([a] -> b) -> [a] -> b
15:40:04 <increpare> @djinn ((a -> Bool) -> b -> b) -> ((a ->m Bool) -> b -> b)
15:40:04 <lambdabot> f a _ b = a (\ _ -> False) b
15:40:16 <byorgey> increpare: I don't think very interesting functions of that type can exist
15:40:26 <increpare> byorgey: exactly, that's why I'm using djinn : )
15:40:31 <byorgey> increpare: perhaps you mean   ((a -> Bool) -> b -> b) -> ((a -> m Bool) -> b -> m b) ?
15:40:47 <byorgey> I'm not even sure you can do that, I'd have to think about it
15:40:57 <b_jonas> HaskellLove: as for your actual question, I'm not completely sure so others will surely tell you more, but I think that "type families" extension might provide the explicit stuff you want
15:41:09 <increpare> hmm yeah you're probably rightish
15:41:13 * increpare gets pen and paper out
15:41:32 <chrisdone> copumpkin: om nom nom http://hackage.haskell.org/packages/archive/higherorder/0.0/doc/html/src/Data-List-Higher.html#list
15:41:35 <b_jonas> HaskellLove: of course, you can just fool normal haskell instances too with a dummy parameter for which you pass (undef :: SomeType) as argument
15:41:54 <HaskellLove> got it... thanks guys
15:42:57 <chrisdone> bool :: (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b
15:43:05 <stepcut> I upload a package to hackage, and the hackage website shows the right version, but I did cabal update, cabal list <package> and the version is still the old version. Is there a delay?
15:43:18 <increpare> @djinn  ((a -> Bool) -> b -> b) -> ((a -> m Bool) -> b -> m b)
15:43:18 <lambdabot> -- f cannot be realized.
15:43:23 <byorgey> Spockz: I haven't read it too carefully yet (just skimmed it) but my initial impression is that your examples are good but the last section could use some improvement and a bit more explanation
15:43:26 <b_jonas> anyway, night
15:43:36 <increpare> aww
15:43:42 <byorgey> Spockz: it sort of looks like you ran out of steam.  "If it doesn't make sense... think about it more" is a cop-out way to end =)
15:44:05 <dcoutts> stepcut: did the uploads finish successfully?
15:44:09 <increpare> guess that answers my question so : P
15:44:14 <byorgey> Spockz: it looks beautiful, though, I like the formatting
15:44:31 <dcoutts> stepcut: we've been getting a lot of timeouts where the package gets uploaded but something doesn't get regenerated immediately.
15:44:53 <stepcut> dcoutts: hard to say.. i did get time outs on some of the uploads -- but those are actually there. The one that didn't time out is the one that is only half-there
15:45:13 <stepcut> dcoutts: I'm am not sure the other ones actually timed out -- they were taking a long time, and then my browser crashed
15:45:54 <Spockz> byorgey: Indeed the last part is a bit shallow. I tried to encourage the reader to think on the problem, and trying to ensure him that failure to understand doesn't imply stupidity or something
15:46:16 <Berengal> Spockz: "Notice that our list only has one constructor, namely (:) and our fold over lists only asks for one function. Now we have two constructors and consequently we ask for two functions." -- This is wrong. Lists have two constructors, same as trees, and you're asking for one function and a base value. Perhaps you were thinking about the arity of the function instead?
15:46:22 <stepcut> dcoutts: if I wait long enough, should it fix itself?
15:46:26 <dcoutts> stepcut: looks to me like all of them except happstack itself are in the index now
15:46:36 <stepcut> dcoutts: yeah
15:46:43 <dcoutts> stepcut: yes, then next time someone uploads something it'll be regenerated again
15:46:58 * stepcut ponders if he needs to upload anything
15:47:19 <Spockz> Berengal: indeed, that's not entirely what I meant to say...
15:47:43 <dcoutts> stepcut: I think the thing to do is just to relax :-) consider the process as async
15:48:16 <stepcut> dcoutts: but I want to be done with this release now!
15:48:20 <stepcut> so I can go on vacation :p
15:49:09 <dcoutts> stepcut: it's done already, go :-)
15:49:15 <stepcut> :)
15:50:13 <stepcut> it's not done until I confirm that, cabal install happstack, actually does the right thing. And then I have to send the annoucement (which is already written).
15:50:33 <stepcut> I am going to ignore the fact that 2 out of 3 the buildbot builds failed :)
15:51:29 <b0fh_ua> btw where the "comparing" function is defined? I don't seem to have it in Data.List
15:51:37 <dcoutts> stepcut: I'm afraid I don't have sufficient permissions to manually re-generate the index
15:51:37 <mauke> @index comparing
15:51:37 <lambdabot> bzzt
15:51:46 <mauke> @hoogle comparing
15:51:47 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:52:40 <b0fh_ua> nice, thanks
15:52:50 <napping> increpare: did you mean for m to be a monad? djinnn doesn't know that
15:53:01 <increpare> napping: I did.  I wasn't aware of that.
15:53:04 <Spockz> Berengal: fixed it
15:53:16 * stepcut found something else to upload :)
15:53:23 <increpare> napping: I more or less have the function now anyway.
15:53:31 <napping> @djinn (forall a . a -> m a) -> b -> m b
15:53:31 <lambdabot> Cannot parse command
15:54:35 <napping> well, it's impossible in general anysy
15:54:50 <napping> you can't get a -> Bool from a -> m Bool
15:55:17 <b0fh_ua> http://pastebin.com/d1e7ee7a - can somebody please criticise the code?
15:55:29 <napping> e.g. const randomIO :: a -> IO Bool
15:56:02 <aavogt> b0fh_ua: you can use pattern matching instead of fromJust
15:56:08 <increpare> napping: I was trying to modify filter to work when i have a function f:  a -> m Bool
15:56:14 <byorgey> more to the point, you can't even get  m (a -> Bool) from  a -> m Bool
15:56:20 <byorgey> although you can go the other way
15:56:35 <b0fh_ua> aavogt: could you please explain?
15:56:38 <napping> like Control.Monad.filterM?
15:56:51 <increpare> hah
15:56:53 <increpare> hahahah
15:56:53 <byorgey> @type filterM
15:56:55 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:56:55 <increpare> maybe
15:57:02 * increpare sighs
15:57:05 <increpare> thanks
15:57:08 <aavogt> > (\(Just x) -> x) (Just 1) -- b0fh_ua
15:57:09 <lambdabot>   1
15:57:21 <byorgey> > filterM (const [False, True]) [1..3]
15:57:23 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
15:57:30 <BMeph> Whoa, that was trippy; I couldn't tell which channel was which for a bit there... )
15:57:33 <aavogt> > case Just 1 of Just x -> x
15:57:34 <lambdabot>   1
15:57:42 <byorgey> every element gets both filtered and not filtered =)
15:57:56 <increpare> heheheh
15:58:10 <Berengal> <3 list-monad
15:58:40 <Spockz> does someone have a snippet of haskell code that contains nearly all features of Haskell, syntax / control structure wise?
15:58:47 * hackagebot upload: happstack-facebook 0.16 - A package for building Facebook applications using Happstack (JeremyShaw)
15:59:43 <aavogt> Spockz: that will be more than a snippet
15:59:51 <b0fh_ua> guys, is there any online syntax colorer for Haskell code?
15:59:57 <pikhq> Spockz: Haskell 2010, 1998, or GHC Haskell?
16:00:03 <aavogt> if you want to write acceptable code, you don't have to know all the language features
16:00:20 <stepcut> b0fh_ua: for what purpose? hpaste.org ?
16:00:22 <aavogt> there is quite a bit of redundancy
16:00:25 <pikhq> If it's standard, it will be slightly large, but not exceptionally.
16:00:32 <Spockz> it's for my highlighter :P
16:00:38 <pikhq> If it's GHC Haskell, expect a book. GHC does a lot.
16:00:51 <b0fh_ua> stepcut: to embed some code un HTML
16:00:56 <b0fh_ua> *in
16:01:11 <stepcut> b0fh_ua: perhaps you want the offline hscolour program?
16:01:27 <Berengal> Or the hscolour library...
16:01:37 <mauke> b0fh_ua: vim can do that
16:01:39 <EvanR_> offline programs can be used online!
16:01:54 <b0fh_ua> hm
16:01:59 <EvanR_> `rm -rf /`
16:01:59 <largos> is the cabal file format documented anywhere?
16:02:23 <b0fh_ua> vim can create HTML from hs automatically?
16:02:29 <clarkb> yes
16:02:41 <clarkb> :TOhtml I think
16:02:43 <mauke> vim can create HTML from anything
16:03:07 <clarkb> it creates a new buffer that you must save
16:03:30 <b0fh_ua> nice
16:04:13 <BMeph> largos: Have you tried...reading the manual? Rumor has it that it's actually helpful! ;p
16:04:24 <clarkb> rtfm? why would we do that?
16:04:37 <largos> BMeph: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/stability.html#id420502 that one?
16:04:43 <BMeph> largos: I'd suggest: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/stability.html#id420502
16:04:48 * dixie loves cabal & cabal-install
16:05:24 <largos> BMeph: there isn't much info there
16:06:03 <largos> at least, not about the file format.
16:06:37 <largos> ah... it's just not under the File Format section.  my bad
16:06:45 * BMeph reads...and is strongly tempted NOT to recommend the UG in the future.
16:07:09 <stepcut> what's that channel for discussing everything except Haskell?
16:07:23 <BMeph> largos: Naugh, I should have found a better section - the Introduction seems a better start for it.
16:07:27 <mauke> #haskell-blah
16:07:30 <lunabot>  luna: A section must be enclosed in parentheses
16:07:53 <largos> BMeph: yeah, there are quite a few examples, and some syntax.  I'll dig in deeper
16:08:38 * byorgey <3 -XTupleSections
16:08:43 <BMeph> stepcut: Watch out, though; contrary to mauke's suggestion, #haskell-blah sometimes wanders "off-off-topic" and discusses Haskell there. It's confusing, sometimes... ;)
16:09:18 <ezyang> Hey, does anyone know how to make cabal update stop complaining about a new cabal-install even though I installed the new one?
16:09:34 <stepcut> BMeph: well, they are talking about perl right now so I would be safe, except that Pugs came up..
16:10:07 <BMeph> stepcut: See, it's like pink rhinos, they just can't help themselves! ;)
16:11:25 <HaskellLove> What does it mean "straightforward"? in "the kernel is not formally specified, it is essentially a slightly sugared variant of the lambda calculus with a straightforward denotational semantics."
16:11:35 <Tobsan> :t concatMap
16:11:36 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
16:12:50 <Cale> HaskellLove: It means the one which is obvious to anyone who knows a reasonable amount about such things.
16:13:07 <Cale> (rather than something complicated and not obvious)
16:14:02 <HaskellLove> Cale, retorics eh? :)
16:15:08 <dmwit> http://www.reddit.com/r/programming/comments/aggr9/beating_the_arc_challenge_in_haskell/c0hg1tm
16:15:12 <dmwit> What an awesome smiley.
16:15:48 <skorpan> ≖‿≖
16:16:28 <dmwit> bwahaha
16:16:46 <dmwit> That is the perfect level of smug.
16:17:24 <skorpan> what the hell is the arc challenge?
16:17:29 <dmwit> meh
16:17:32 <skorpan> and why are people still paying attention to paul graham?
16:17:37 <dmwit> Write a web-app with as few tokens as possible.
16:17:46 <QtPlaty[HireMe]> I'm not sure.
16:17:49 <dmwit> And I don't think they are. =)
16:17:53 <ezyang> Oh! I know why: I haven't set my bin properly
16:18:15 <Cale> ⤽_⤽
16:18:19 <ben0x539> ಠ_ಠ
16:18:20 <copumpkin> oh wow
16:18:26 <mauke> ツ
16:18:32 * QtPlaty[HireMe] thinks that he shot himself in the foot with arc
16:18:35 <copumpkin> シ
16:18:46 <copumpkin> QtPlaty[HireMe]: that sounds painful, did you get it treated?
16:18:51 <skorpan> stop it with the unicode, you're hanging emacs
16:18:54 <Cale> （＾＿＾）ノツ
16:18:57 <copumpkin> lol
16:19:03 <copumpkin> skorpan: get a better client
16:19:11 <byorgey> skorpan: what version of emacs are you using, 18?
16:19:13 <skorpan> tell me what a better client is
16:19:15 <skorpan> byorgey: 23.1
16:19:16 <mauke> skorpan: http://www.vim.org/scripts/script.php?script_id=931
16:19:19 <copumpkin> skorpan: I use netcat
16:19:29 <sohum> @src fix
16:19:29 <lambdabot> fix f = let x = f x in x
16:19:36 <byorgey> I use unicode in emacs all the time...
16:19:42 <Cale> XChat is not bad for unicode.
16:19:46 <mauke> the real answer is irssi, of course
16:19:48 <copumpkin> netcat works best
16:20:07 <skorpan> byorgey: some of the unicode was fast, i just think someone used some obscure unicode
16:20:07 <QtPlaty[HireMe]> copumpkin: Not me, mr graham
16:20:38 <byorgey> skorpan: oh, it had to stop and load extra fonts or something?  weird
16:20:38 <clarkb> I wondered how long it would take for irssi to be mentioned
16:20:48 <skorpan> byorgey: probably, it does that occasionally
16:21:06 <skorpan> irssi is shitty imo... pretty bad.
16:21:18 * syntaxglitch thought the discussion on news.yc about that was fairly interesting
16:21:26 <Badger> copumpkin: NOTICE AUTH :*** Got ident response
16:21:26 <Badger> ERROR :Closing Link: 127.0.0.1 (Connection Timed Out)
16:21:27 <syntaxglitch> Even if the "arc challenge" does seem... kinda silly
16:21:27 <sohum> skorpan: why do you say that?
16:21:28 <mauke> skorpan: hey, at least its config language has LEXICAL SCOPING
16:21:28 <Badger> :(
16:21:33 <dmwit> I have trouble imagining what could be better or worse about a particular IRC client.
16:21:40 <skorpan> mauke: uh yeah, congrats on that accomplishment.
16:22:18 <mauke> (lexical scoping is pretty important if your system is event/callback based IMHO)
16:22:18 <syntaxglitch> mauke, pff, if it's not turing complete who cares
16:22:46 <syntaxglitch> or by "config file" are we talking "hack the program by writing scripts"
16:22:47 <sohum> syntaxglitch: I look forward to seeing your irc client with config language written in assembler, then :P
16:22:50 <mauke> wait, I don't think I really meant "config language"
16:23:31 <clarkb> I tried weechat but getting ssl to work was not straightforward
16:23:50 <Cale> ಠ_⧂… <-- not amused about the price of this month's shipment of monocle polish.
16:24:17 <ezyang> oy, I don't have that glyph
16:24:25 <skorpan> neither do i
16:24:46 <Absolute0> logBase is defined for Float and Double why then does (logBase 3) work? 3 is (Num t) => t
16:24:56 <Cale> U+29C2 CIRCLE WITH SMALL CIRCLE TO THE RIGHT
16:25:15 <c_wraith> Absolute0: Float and Double are both instances of Num
16:25:18 <Cale> I'm not sure which font on my system has it
16:25:20 <Spockz> byorgey: http://alessandrovermeulen.me/syntaxhighlighter-evolved-extra/ << that's what I used for my post.
16:25:24 <c_wraith> @instances Num
16:25:25 <lambdabot> Double, Float, Int, Integer
16:25:42 <Absolute0> I can't get the signature right for my function: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14442#a14442
16:25:54 <sohum> :t 3 `asTypeIn` \x -> logBase x
16:25:55 <lambdabot> forall t. (Floating t) => t
16:26:00 <byorgey> Spockz: cool.
16:26:22 <skorpan> Absolute0: bitsOn :: (), then let ghc tell you what type it has
16:26:25 <pikhq> :t asTypeIn
16:26:27 <lambdabot> forall a b. a -> (a -> b) -> a
16:26:30 <Absolute0> skorpan: its breaking
16:26:39 <Absolute0> without a signature
16:26:44 <byorgey> Absolute0: I think you want  truncate (logBase 2 (fromIntegral n))
16:26:48 <mauke> Absolute0: what's the error message?
16:26:58 <pikhq> ... o_O
16:26:59 <byorgey> @type logBase
16:27:01 <lambdabot> forall a. (Floating a) => a -> a -> a
16:27:02 <Cale> ꙫ U+A66B CYRILLIC SMALL LETTER BINOCULAR O  Notes: used in the dual of words based on the root for 'eye'
16:27:07 <Cale> ... wtf?
16:27:17 <mauke> haha
16:27:22 <BMeph> "Graham also feels that efficiency problems should be solved by giving the programmer a good profiler." <- impressive for 1) being good advice; 2) attributed to Paul Graham; and 3) quoted off of Wikipedia - wow! ;)
16:27:47 <Absolute0> mauke: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14442#a14443
16:27:58 <byorgey> Absolute0: you can only call logBase on floating-point values, so if you have  logBase n  then n must have a floating-point type like Double
16:28:08 <sohum> fix f == limit as n -> infinity of f_n where f_0 = _|_ and f_k = f_(k-1) _|_, right?
16:28:10 <mauke> Absolute0: that's a type error. adding a type signature won't help; the code is wrong
16:28:16 <Absolute0> HMM
16:28:18 <Absolute0> :)
16:28:22 <byorgey> Absolute0: but you also have  n - logn  which means n must be the same type as logn, which must be an integral type
16:28:28 <Absolute0> :t fromIntegral
16:28:29 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:28:30 * syntaxglitch really needs to spend more time writing Haskell and less time leaving comments about Haskell on news.yc :(
16:28:58 <dmwit> sohum: One correction, f_k = f f_(k-1)
16:30:52 <sohum> dmwit: aaah. arright, lemme try it again
16:33:19 <sohum> dmwit: hm, that still doesn't help me understand http://yi-editor.blogspot.com/2008/12/prototypes-encoding-oo-style.html . I seem to end on Proto { a = _|_, b = _|_, c = _|_ } which is probably not what they want...
16:35:57 <dmwit> sohum: It's impossible to make any progress without knowing the definitions of "fa", "fb", and "fc", as far as I can tell.
16:36:30 <sohum> dmwit: aren't all haskell functions monotonic?
16:36:46 <sohum> dmwit: wrong word... such that f _|_ = _|_ ?
16:36:50 <dmwit> no
16:36:57 <dmwit> > True || undefined
16:36:58 <lambdabot>   True
16:37:04 <dmwit> (The word you're looking for is "strict".)
16:37:35 <mauke> I think I'm looking for another word
16:37:53 <tensorpudding> > undefined || True
16:37:53 <lambdabot>   * Exception: Prelude.undefined
16:37:57 <dmwit> Being non-strict is one part of being lazy. =)
16:38:07 <sohum> dmwit: ah, right, of course
16:38:12 <Cale> (@>=<) :: (Indexable a b, Data a, Ord a, Typeable k) => IxSet a -> (k, k) -> IxSet a  -- best infix operator symbol ever
16:38:22 <tensorpudding> haskell functions aren't monophonic, they're in stereo
16:38:44 <Philonous> sohum: They are monotonic. But that means that a < b ==> f a < f b with _|_ < x
16:38:45 <dmwit> These are not the words you're looking for.
16:38:47 <EvanCarroll> kind of like avatar.
16:39:06 <mauke> what do you call 'f _ = undefined'?
16:39:16 <sohum> Philonous: yea, I realised that. it's just not necessary for f _|_ = _|_, as long as f _ > _|_
16:39:35 <dmwit> >=
16:40:07 <Philonous> sohum: exactly. You can write non-monotonic functions with the help of unsafePerformIO, though. Yet another reason why unsafePerformEvil is just that.
16:40:46 <sohum> hahah
16:46:01 * hackagebot upload: HJScript 0.4.5 - HJScript is a Haskell EDSL for writing JavaScript programs. (NiklasBroberg)
16:46:56 <mauke> > let a = show (b, c); b = show (a, c); c = show (a, b); in a
16:46:57 <lambdabot>   "(\"(\\\"(\\\\\\\"(\\\\\\\\\\\\\\\"(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(\\\\\\...
16:47:37 <Gracenotes> oh show, you're so polymorphic!
16:47:56 <mauke> I'm pretty sure this is a monomorphic show
16:48:03 <medfly> :t show
16:48:04 <lambdabot> forall a. (Show a) => a -> String
16:48:06 <mreh> Cale: what encoding are you using?
16:48:10 <Gracenotes> hm. you may be right. a being a String
16:48:32 <Gracenotes> well. (String, String)
16:48:58 <dmwit> > let f :: (String, String) -> String; f = show in let a = f (b, c); b = f (a, c); c = f (a, b) in a
16:48:59 <lambdabot>   "(\"(\\\"(\\\\\\\"(\\\\\\\\\\\\\\\"(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(\\\\\\...
16:49:55 <Gracenotes> anyway, to paraphrase the popular saying, ain't no such thing as a free type variable
16:50:15 <mreh> that's a country and western song isnt it?
16:50:25 <ezyang> "be green, use only free-range type variables" ?
16:50:41 <c_wraith> there are free type variables.  In instance declarations.
16:51:40 <Gracenotes> c_wraith: like the original saying, there is a subtext that's it's not *actually* free
16:52:02 * hackagebot upload: cabal-install 0.8.0 - The command-line interface for Cabal and Hackage. (DuncanCoutts)
16:52:07 <Gracenotes> even if it says it is. So if there's an 'a' in some type, when you reach it from main, that a has been long since filled in
16:52:30 * Botje dots his äs
16:52:39 <mreh> I can use Gnome apps in xmonad?
16:53:06 <ezyang> Correct.
16:53:16 <Gracenotes> call me modest, but I single-dot. ȧ
16:53:37 <mreh> is there an interactive tutorial for xmonad?
16:53:49 <Gracenotes> anyway, hanukkah presents, brb
16:54:06 <ezyang> mreh: Maybe bluetile?
16:55:09 <mreh> ezyang: thx
16:56:09 <Cale> mreh: UTF-8
16:56:38 <mreh> rly? I thought I was using that, I need to sort out x-chat
17:07:15 * hackagebot upload: hack-handler-happstack 2009.12.20 - Hack Happstack server handler (JinjingWang)
17:12:17 * hackagebot upload: hack-contrib 2009.12.20 - Hack contrib (JinjingWang)
17:12:39 <HaskellLove> anyone here has used Jape? I will need help as I go through the manual... we can go pm...
17:14:24 <copumpkin> why do you want jape?
17:18:25 <HaskellLove> copumpkin I read a book on formal logic so...
17:18:36 <copumpkin> agda ftw :D
17:18:47 <copumpkin> or try coq
17:18:53 <copumpkin> you might get more people around here who know how to use it
17:19:43 <napping> coq has the tactics system, which really helps with proofy thing
17:20:09 <copumpkin> get your proofy thang
17:20:14 <copumpkin> agda is pretty though :)
17:22:09 <napping> the syntax extension stuff in Coq is pretty nice too
17:22:11 <HaskellLove> nah i need to start simple with something like this, i am new to these stuff... I mean I have read on classical vs predicate logic, propositional, high-order logics, temporal, situational and what not logics... but have never worked with a prover
17:23:14 <napping> oh, and the limited subtying stuff looks interesting too. I wonder what kind of type inference you could promise for it in a H-M style language
17:23:54 <napping> that's the thing where you can basically say "inject Var into Exp by applying VarExp", and write variables where expressions are wanted
17:27:04 <HaskellLove> napping i am a compiler wannabe so building type systems is all about formal logic so... i gotta start with that, will go Jape and then try Coq/Agda probably
17:28:17 <copumpkin> the narwhal is back!
17:28:29 <copumpkin> HaskellLove: Agda is pretty similar to haskell, but I'm not sure that helps much :P
17:29:04 <HaskellLove> copumpkin what are preeliminaries to get working in Agda?
17:29:29 <copumpkin> HaskellLove: install agda, download the standard library, set up the agda emacs mode and then you have it :P
17:30:05 <HaskellLove> hahaha I meant, what reading u need to have done? Having done Logic reading would suffice I guess...
17:30:21 <copumpkin> there's a nice tutorial paper on it
17:30:34 <copumpkin> might help even if you don't actually use agda
17:30:45 <copumpkin> http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
17:31:40 <kmc> HaskellLove, you should definitely learn Coq
17:31:49 <copumpkin> yeah, coq is awesome
17:32:20 <HaskellLove> ah yeah tried that paper a day ago and left it, seemed unrelated to my current interests so i continued with TAPL... ok guys, i will read this and finish Jape and hopefully tomorow start playing with Coq and Agda
17:32:59 <copumpkin> and then the day after you'll learn all of mathematics, right?
17:33:10 <copumpkin> and then on the fourth day, you can solve P=?NP
17:34:27 <HaskellLove> it is easy man it is just a program, if you have read on logic you will learn it in couple of hours, just an interface...
17:34:39 <kmc> i don't even see the code anymore
17:34:44 <HaskellLove> as they say, just a tool
17:34:52 <copumpkin> yeah, P=?NP is just a question
17:35:07 <HaskellLove> did not say that :)
17:35:07 <copumpkin> take a glance or two, answer it, what's the big deal
17:35:16 <chrisdone> coq isn't just a tool
17:35:25 <HaskellLove> i said about Jape not about Coq
17:35:33 <ezyang> "it's a way of life"
17:35:37 * copumpkin refrains from a "your mom last night" joke
17:36:21 <kmc> Coq is a useful tool but sometimes it gets pretty hard
17:36:30 <copumpkin> coq is always hard
17:36:41 <Berengal> ...
17:36:53 <HaskellLove> i don't doubt coq is hard
17:37:39 <Berengal> When I started out with agda, the only thing missing was the dependent types, basically. When I got that, and had internalized types as propositions a bit more than I already had, the basics became pretty simple.
17:38:07 <Berengal> Everything else about the language was familiar from haskell
17:38:31 <copumpkin> the codata distinction?
17:38:35 <Berengal> Of course, I don't understand more than a tenth of the standard library, but that's entirely different
17:39:07 <Berengal> I haven't used codata in agda yet, but I am familiar with it from other contexts
17:39:31 <copumpkin> codata in other contexts, data in ntexts?
17:39:44 <copumpkin> ncatlab <=> concatlab?
17:39:47 <Berengal> No, ntexts in data
17:40:50 <Berengal> Anyway, I expect there are a few holes in my knowledge of it, but I don't think I'll have a really hard time understanding it if I set out to do so.
17:43:22 <HaskellLove> copumpkin what are your everyday uses for Coq? I mean, I want to learn this because I am interested in type systems as a compiler engineer wannabe
17:43:52 <copumpkin> HaskellLove: I don't have any, and have barely played with coq at all. I use agda for fun and my own edification
17:44:16 <mreh> upgrading GHC version is equivalent to upgrading the base packages isn't it?
17:44:20 <HaskellLove> copumpkin ok Agda, then for fun and... what specific things... ?
17:44:23 <Berengal> HaskellLove: I'd say the dependent types are really enlightening
17:45:14 <copumpkin> HaskellLove: attempting to prove things :) they're like puzzles that I can set for myself and have the machine check my answers! and I can take stuff I know in math and try to prove it
17:45:28 <copumpkin> HaskellLove: it's also just enlightening, as Berengal said
17:45:33 <copumpkin> but it's mostly a fun challenge
17:46:08 <HaskellLove> cool :)
17:46:11 <Berengal> HaskellLove: Take, say, a function of type [a] -> [a] -> [a]. There can be many functions with that type, and they can pretty much do anything, as long as they return a list... which is easy, since they got two as input.
17:46:28 <HaskellLove> ok...
17:46:55 <copumpkin> HaskellLove: how many functions a -> a -> a are there? :P
17:46:57 <copumpkin> (total functions)
17:47:09 <Berengal> HaskellLove: However, with dependent types, you can make a more specific type that can statically ensure some invariants, such as the result list's length being the sum of the input lists' lengths
17:48:09 <HaskellLove> copumpkin two I guess? the one takes two arguments a and a and produces a, and another lambda function which executes that? haha i don't know, just guessing :) how many?
17:48:36 <HaskellLove> copumpkin oh, actually there are 3
17:48:55 <Berengal> HaskellLove: Also, say you implement a function... simple addition, for the sake of argument. How do prove it is correct? In most languages you can only write tests, proving that 1 + 2 is indeed 3. In dependently typed languages you can write "tests" that cover all inputs, proving that a + b is b + a, among other things
17:48:56 <kmc> where did the verb "execute" come in?
17:48:59 <HaskellLove> ah shit i am confused :) i got your point
17:49:03 <kmc> you don't "execute" things in the lambda calculus
17:49:33 <tensorpudding> lambda calculus is all about functions
17:50:12 <HaskellLove> kmc I could have said it is in scope of...
17:50:28 <copumpkin> HaskellLove: it's two functions, can you write them?
17:51:43 <HaskellLove> let me try
17:52:53 <HaskellLove> it is coming don't write before me :)
17:53:13 <Absolute0> Is this 1 for loops or 2? (foldl' (+) (map (+1) [1..9]))
17:53:22 <Absolute0> since haskell is lazy I would think its only one.
17:53:33 <Berengal> Absolute0: It's two traversals over a list, but they're interleaved
17:53:47 <kmc> Associat0r, GHC will typically fuse together things like that
17:53:56 <kmc> at least it will fuse foldr and map
17:54:01 <kmc> because they traverse in the "same direction"
17:54:04 <Absolute0> to me it translates that into 2 parallel loops, is that correct thinking?
17:54:42 <Absolute0> take 2 pass it to fold
17:54:45 <Absolute0> take 3 pas it to fold
17:54:47 <Berengal> If you ignore the minor overhead a loop has, what's the difference between two loops doing one thing each, and one loop doing both things?
17:54:47 <Absolute0> right?
17:55:07 <kmc> you can of course translate it yourself into a single tail-recursive function (a "loop")
17:55:32 <Absolute0> Berengal: well if the list is 1000000000000000000 long then it makes a big difference
17:55:44 <HaskellLove>  [a] -> [b] -> [c] = \ [b] . \ [a] -> [c] ... copumpkin i give up i can't
17:55:52 <HaskellLove> am i even close
17:55:58 <kmc> ?
17:56:00 <copumpkin> HaskellLove: I asked about a -> a -> a :)
17:56:02 <kmc> that syntax makes no sense
17:56:13 <HaskellLove> yes but lets say a b and c are all type a
17:56:30 <HaskellLove> it was just for notational purposes
17:56:46 <kmc> why don't you write two haskell functions, each with type:  a -> a -> a
17:56:57 <kmc> lambdabot will tell you if they have the proper types
17:57:16 <copumpkin> it's actually impossible to write a function a -> a -> a without unnecessarily restricting the type
17:57:28 <Associat0r> kmc: I am not Absolute0
17:57:31 <copumpkin> well, that's another concern
17:57:32 <kmc> whoops!
17:57:33 <kmc> sorry
17:57:35 * kmc kicks xchat
17:57:54 <kmc> (always blame the client)
17:58:04 <Berengal> copumpkin: No it's not
17:58:19 <copumpkin> Berengal: you'd need an asTypeOf or an explicit type annotation
17:58:28 <Berengal> @type \a b -> head [a, b]
17:58:29 <lambdabot> forall a. a -> a -> a
17:58:39 <copumpkin> yeah, something like that :)
17:58:40 <kmc> spoiler alert!
17:59:07 <medfly> aww...
17:59:09 <Berengal> I don't think that function counts as one of the two copumpkin asked for... Well, it's semantically the same as one of them
17:59:34 <copumpkin> :)
17:59:48 <kmc> yeah, i assume extensional equality
17:59:58 <kmc> there are of course an infinite number of ways to *write* those two functions
18:00:22 <copumpkin> HaskellLove: f x y = x and f x y = y
18:00:27 <Berengal> K and K(SKS)
18:00:33 <copumpkin> HaskellLove: those are the only two terminating functions possible with that type
18:00:42 <copumpkin> @djinn a -> a -> a
18:00:43 <lambdabot> f _ a = a
18:00:59 <kmc> :t curry fst
18:01:01 <lambdabot> forall a b. a -> b -> a
18:01:01 <kmc> :t curry snd
18:01:02 <lambdabot> forall a b. a -> b -> b
18:01:09 <Berengal> @type (const, const id)
18:01:10 <lambdabot> forall a b a1 b1. (a -> b -> a, b1 -> a1 -> a1)
18:01:22 <tensorpudding> @djinn a -> b
18:01:22 <lambdabot> -- f cannot be realized.
18:01:37 <HaskellLove> copumpkin hmm, i thought you are asking me under the hood what is going on lambda calculus kinda question :D
18:02:02 <kmc> "under the hood"?
18:02:14 <copumpkin> HaskellLove: it's a profound fact
18:02:18 <tensorpudding> lambda calculus has a hood?
18:02:30 <Berengal> Lambda calculus has a V8 under the hood
18:02:39 <medfly> vorrooom vorroom
18:02:39 <tensorpudding> does it have spinners?
18:02:48 <Berengal> 450hp!
18:03:13 <Berengal> Ahhh, us programmers and our puns...
18:03:26 <Cale> Really? Does this mean I can evaluate Javascript really quickly with lambda calculus?
18:03:28 <Cale> ;)
18:03:34 <tensorpudding> lol
18:03:36 <tensorpudding> good one
18:04:51 <HaskellLove> haskellove on the way to become a type master yeiiii...
18:06:29 <HaskellLove> and later a compiler engineering master, and after that... umm, no, that's enough for one lifetime...
18:07:36 <tensorpudding> the life is short and the craft so long to learn
18:07:44 <HaskellLove> yep
18:14:40 <HaskellLove> haha this is cool from the manual: "The way that rules match formulae is so nearly mechanical that I could have set Jape up to choose the relevant rule when you merely double-click on a formula. Because I want you to learn about Natural Deduction and
18:14:41 <HaskellLove> not just the use of the mouse, I’ve been grandad-ish and set it up so that you have to choose the rules for
18:14:43 <HaskellLove> yourself."
18:28:58 <luite> what can cause this? ghc.exe: dist\build\Happstack\Data\Default.o: unknown symbol `_sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_constrZMacbsZN_closure'
18:29:30 <luite> (trying to install happstack-data with ghc 6.12.1 on windows, using cabal-install 0.8.0)
18:29:51 <copumpkin> preflex: zdec _sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_constrZMacbsZN_closure
18:29:51 <preflex>  _syb-with-class-0.6.1_Data.Generics.SYB.WithClass.Instances_constr[acbs]_closure
18:30:12 <luite> I already reinstalled syb-with-class
18:38:20 <Cale> luite: Most linking errors are caused by failing to use --make or -package
18:38:48 <luite> hmm, I installed everything so far using cabal-install
18:39:07 <Cale> Oh, well, the packages ought to define their own dependencies
18:39:25 <luite> (except for the packages required to build cabal.exe, but I reinstalled them afterwards)
18:41:08 <luite> the .cabal file lists     if impl(ghc >= 6.12.1)  Build-Depends:    syb-with-class >= 0.6.1
18:41:16 <Runar> Totally off topic... do you know of good free software for time tracking/billing?
18:47:17 <roconnor> Runar: hledger
18:47:23 <roconnor> Runar: still on topic
18:48:20 <roconnor> @hackage hledger
18:48:21 <lambdabot> http://hackage.haskell.org/package/hledger
19:10:05 <syntaxglitch> out of morbid curiosity, is there any way to write a function to extract values from a "data" structure in pointless style?
19:10:40 <syntaxglitch> Maybe I'm being obtuse but I'm not even sure how you'd extract the values without pattern matching on arguments
19:10:43 <kmc> not intrinsically
19:10:49 <kmc> yes, if your datatype provides "deconstructors"
19:10:55 <kmc> :t maybe
19:10:56 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:11:30 <syntaxglitch> kmc, in other words "yes, if you use a pre-existing function that does it already"
19:11:33 <kmc> yup
19:11:44 <syntaxglitch> ok, thanks
19:12:03 <syntaxglitch> I probably shouldn't keep writing so many pointless functions anyway
19:12:05 <kmc> but these functions are commonly provided for standard datatypes
19:12:23 <aavogt> how about definining the data with functions to extract the value?
19:12:30 <aavogt> (as in using record syntax)
19:13:01 <syntaxglitch> kmc, I was wondering mostly in the context of datatypes I was defining myself
19:14:07 <syntaxglitch> aavogt, that's just a way to have the language autogenerate the extracting functions
19:14:37 <syntaxglitch> I wasn't looking for "what's the easy way to extract data", I was wondering about "is this even possible" :)
19:14:49 <aavogt> yes, but those are defined without naming any arguments
19:16:11 <luite> @where paste
19:16:11 <lambdabot> http://hpaste.org/new
19:16:29 <luite> hm, I meant the other paste
19:17:39 <luite> oh found it
19:18:56 <luite> is it possible to make sum4 [1..1000000] use less memory? http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=5404#a5404 (without 'cheating' by forcing intermediate results)
19:20:45 <xerox> ?src foldl'
19:20:45 <lambdabot> foldl' f a []     = a
19:20:45 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:20:52 <luite> yeah that's cheating :p
19:21:03 <luite> (sum3 cheats by pattern matching on the second result)
19:22:17 <luite> I mean second argument
19:30:21 <kmc> @oeis 14,18,23,28,34,42
19:30:22 <lambdabot>  Local stops on New York City Broadway line subway.
19:30:22 <lambdabot>  [14,18,23,28,34,42,50,59,66,72,79,86,96,103,110,116,125,137,145,157,168,181,...
19:31:55 <gwern> @hoogle processors
19:31:56 <lambdabot> No results found
19:31:58 <gwern> @hoogle processor
19:31:59 <lambdabot> No results found
19:32:14 <xerox> that'd better be a finite sequence :)
19:32:18 <gwern> hm. wasn't there a module with a function yielding 'how many processors does my computer have?'
19:32:24 <kmc> @hoogle numCapabilities
19:32:25 <lambdabot> No results found
19:32:27 <xerox> ?hoogle CPU
19:32:27 <lambdabot> module System.CPUTime
19:32:27 <lambdabot> System.CPUTime cpuTimePrecision :: Integer
19:32:27 <lambdabot> System.CPUTime getCPUTime :: IO Integer
19:32:31 <xerox> ?hoogle+
19:32:36 <xerox> dunno.
19:33:00 <kmc> xerox, depends, do you think the MTA is capable of opening one more station before the heat death of the universe?
19:33:57 <xerox> so tragic..
19:34:32 <pastah_rhymez> NARWHALS!! YEEEEAH!
19:34:38 * pastah_rhymez just reloaded reddit
19:35:01 <gwern> @quote narwhal
19:35:01 <lambdabot> No quotes match. stty: unknown mode: doofus
19:35:02 <dmwit> Is that like the sequel or something?
19:35:15 <dmwit> Reddit: RELOADED, now with 100% more EXPLOSIONS and BACON
19:35:22 <dmwit> ?zippy
19:35:22 <lambdabot> Unknown command, try @list
19:35:51 <dmwit> ?yow!
19:35:52 <lambdabot> Couldn't find fortune file
19:36:03 <dmwit> ?vixen how come no love tonight?
19:36:04 <lambdabot> i didn't think so
19:36:49 <pastah_rhymez> why did people pick the stupid lambda/bind-logo?
19:37:01 <pastah_rhymez> seems rather silly when we could have had narwhals
19:37:18 <kmc> they got a bargain deal on merchandise with the old amtrak logo on it
19:37:33 <kmc> aren't narwhals a tired internet cliche?
19:37:45 <kmc> do we want Haskell to join the same category?
19:37:46 <EvanR> i like itmore than the old one
19:38:03 <EvanR> with the floating operators around the lambda
19:38:06 <EvanR> was lame
19:38:11 <stroan> yeah
19:38:14 <kmc> the old one was very "grad student designed this in 10 minutes in GIMP"
19:38:21 <stroan> the old logo was way too busy
19:40:16 <gwern> pastah_rhymez: narhwals aren't recognizable enough
19:40:22 <pastah_rhymez> awww
19:40:30 <gwern> there is no elegant minimalistic ink painting of narhwals
19:41:22 <pastah_rhymez> gwern: that's because they're too majestic to be able to summarize in such small doodles
19:42:04 <kmc> if we want internet cliche why don't we go full-on and make the haskell logo be a comic where stick-figure ninjas make math jokes and eat bacon
19:42:06 <mokus> pastah_rhymez: aka, not suitable for a logo? ;)
19:42:15 <pastah_rhymez> mokus: NONSENSE
19:42:35 <pastah_rhymez> kmc: it has to be chunky bacon
19:42:41 <mokus> hmm, lambda-bacon
19:42:43 <pastah_rhymez> otherwise i'm not supporting it
19:45:15 <gwern> in a bacon, the meat and fat go in segregated streaks
19:45:20 <gwern> the separation makes it delicious
19:45:34 <gwern> just like separating pure and impure code makes it delicious
19:45:41 <mokus> i thought it was the salt and the burnt crunchy bits?
19:47:51 <aavogt> so if we so dislike people thinking monads are really important in Haskell, why is the logo the bind operator?
19:48:10 <kmc> aavogt, monads *are* important
19:48:16 <kmc> they're just not as important as people think
19:48:42 <dibblego> and they are important, regardless of Haskell
19:48:44 <kmc> moreover, the use of monads for IO is distinctive, and something we should be proud of
19:48:58 <EvanR> haskells main feature is monads, doesnt mean you need to learn them first
19:49:05 <kmc> because it's what makes Haskell a good imperative language in addition to a great functional language
19:49:07 <dibblego> ugh no
19:49:13 <pastah_rhymez> http://mislav.uniqpath.com/poignant-guide/images/the.foxes-4c.png
19:49:13 <EvanR> and laziness
19:49:14 <kmc> EvanR, it's definitely not the "main feature"
19:49:20 <EvanR> and...
19:49:20 <pastah_rhymez> the BEST kind of bacon ^^
19:49:28 <EvanR> pattern matching
19:49:34 <kmc> it's barely a feature -- besides "do" sugar, Monad is an ordinary typeclass defined in the libraries
19:49:53 <aavogt> sugar is important
19:50:08 <kmc> indeed.  though programming with monads without the sugar is not too bad
19:50:12 <dmwit> IO is special.
19:50:45 <aavogt> it's bad in that you have one less level of control to separate expressions
19:50:57 <kmc> EvanR, I (and Wikipedia) would say the distinguishing features are: purity, non-strict semantics, strong static typing with inference, type classes, monads, good implementations, community
19:51:05 <Axman6> EvanR: i'd put purity first
19:51:09 <aavogt> when you write:    pattern <- fun a $ b x y
19:51:22 <aavogt> that needs parentheses when you desugar it
19:51:27 <EvanR> hmmmm
19:51:44 <aavogt> (fun a $ b x y) >>= \pattern ->
19:51:44 <EvanR> purity is a feature because it makes code easier to understand?
19:52:01 <aavogt> or worse if the pattern could possibly fail
19:52:01 <kmc> i don't mean "feature" as assigning value
19:52:04 <kmc> but yes, very much so
19:52:09 <dibblego> purity is a feature because non-strict semantics is a feature
19:52:19 <kmc> i meant "feature" as "characteristic"
19:52:27 <EvanR> non strict is a nice feature
19:52:28 <dmwit> > fun "dmwit test" :: Expr
19:52:29 <lambdabot>   dmwit test
19:52:33 <dmwit> hum
19:52:45 <kmc> for example, templates and virtual inheritance are C++ features
19:53:02 <xerox> dmwit: fun is to give labels to functions
19:53:16 <dmwit> I know.
19:53:21 <dmwit> I was testing irssi's highlighting.
19:53:32 <dmwit> But you tested it better, thanks. =)
19:53:46 <xerox> you're welcome (:
19:53:53 <EvanR> i guess i was thinking more along the lines of features and so called misfeatures
19:54:00 <aavogt> there's no fun in haskell though
19:54:10 <EvanR> > print fun
19:54:11 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:54:11 <lambdabot>    `GHC.Show.Show a'
19:54:11 <lambdabot>      a...
19:54:38 <aavogt> then again, you get to assign fun to whatever you want!
19:54:57 <aavogt> therefore haskell is nicer than ocaml
19:55:16 <kmc> other features of Haskell such as algebraic data, pattern matching, curried-by-default functions, and functional programming itself are quite old and not unique to Haskell
19:56:33 <napping> syntaxglitch: in semantics destructors come before pattern matching
19:57:02 <EvanR> i am trying to compile and link a file that imports Network or Data.Map
19:57:19 <EvanR> but just ghc Main.hs gives undefined refs
19:57:21 <syntaxglitch> napping, I'm not sure what you mean
19:57:39 <aavogt> EvanR: use --make flag?
19:57:56 <EvanR> it worked
19:57:59 <EvanR> how magic
19:58:29 <kmc> i think enforced purity, non-strict semantics, and pervasive use of monads are valid things to take or leave out of a language design.
19:58:45 <kmc> but i think pattern matching and first-class functions are essential for basically any general-purpose language
19:58:58 <aavogt> unsafePerformIO kind of breaks enforced purity
19:59:15 <syntaxglitch> also, as far as putting >>= in the logo... better that than do notation, right :P
19:59:17 <kmc> and so they are not characteristic of Haskell, but rather their lack is characteristic of some deep flaws in particular mainstream languages
19:59:29 <kmc> "1970 - Guy Steele and Gerald Sussman create Scheme. Their work leads to a series of "Lambda the Ultimate" papers culminating in "Lambda the Ultimate Kitchen Utensil." This paper becomes the basis for a long running, but ultimately unsuccessful run of late night infomercials. Lambdas are relegated to relative obscurity until Java makes them popular by not having them."
19:59:40 <syntaxglitch> aavogt, don't say that function's name
19:59:51 <kmc> aavogt, sure, and unsafeCast breaks type safety
20:00:06 <kmc> (as does unsafePerformIO, actually)
20:00:12 <kmc> though for somewhat specific reasons, i understand
20:00:16 <EvanR> and theres an FFI
20:00:20 <EvanR> which could break everything
20:00:21 <aavogt> @hoogle coerce
20:00:21 <lambdabot> module Unsafe.Coerce
20:00:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:00:36 <dmwit> The FFI doesn't break anything, the unsafePerformIO does.
20:00:48 <kmc> you can FFI-call a function and lie about the presence of side effects
20:00:55 <kmc> and your FFI function can do type-unsafe things
20:01:00 * syntaxglitch thinks module Please.Break.My.Program.Coerce would be better
20:01:08 <dmwit> I was under the impression that you had to use uPIO to do that.
20:01:37 <kmc> i asked this before but i don't think we arrived at a real good answer: if you use unsafePerformIO only at monomorphic types, can you perform an unsafe coercion?
20:01:48 <kmc> there's a way to do it by creating a polymorphic IORef
20:03:30 <wh5a> > map (+1) [1..10]
20:03:32 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
20:03:42 <wh5a> > pl \x y -> x y
20:03:43 <lambdabot>   <no location info>: parse error on input `\'
20:03:51 <kmc> @pl \x y -> x y
20:03:51 <lambdabot> id
20:05:07 <wh5a> @pl \xs ys -> compare (sum xs) (sum ys)
20:05:08 <lambdabot> (. sum) . compare . sum
20:05:24 <kmc> :t compare `on` sum
20:05:25 <xerox> ?type comparing
20:05:26 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
20:05:26 <lambdabot> forall a. (Ord a, Num a) => [a] -> [a] -> Ordering
20:05:28 <kmc> :t comparing sum
20:05:29 <lambdabot> forall a. (Num a, Ord a) => [a] -> [a] -> Ordering
20:05:44 <xerox> one of the little wonders of the libraries :)
20:07:22 <wh5a> :)
20:16:16 <hoyret> @pl \f a -> f a a
20:16:16 <lambdabot> join
20:34:20 <manjunaths> I have a function defined like this: let d2 x = 2 * x
20:34:20 <karlw> Are there any good tutorials for introducing Haskell to, say, math graduate students with no programming experience?
20:34:51 <manjunaths> ghci says that the type of d2 is d2 :: (Num t) => t -> t
20:35:11 <manjunaths> what does this => mean ?
20:35:20 <Axman6> manjunaths: it's a class constraint
20:35:38 <Axman6> it means that anything that implements the Num class can be put into the function
20:35:40 <jmcarthur> manjunaths: d2 has type t -> t, where t must be an instance of Num
20:35:41 <copumpkin> manjunaths: its type is t -> t for any t that is a Num
20:35:46 <Axman6> :t (*)
20:35:47 <lambdabot> forall a. (Num a) => a -> a -> a
20:36:03 <karlw> manjunaths: Look up type classes.
20:36:08 <Axman6> @instances Num
20:36:09 <lambdabot> Double, Float, Int, Integer
20:36:16 <Axman6> + more
20:36:20 <manjunaths> karlw, ok.
20:36:43 <manjunaths> so t can take up all the types that belong to the class Num ?
20:36:59 <manjunaths> but the type of d2 itself is t -> t
20:37:11 <Axman6> any type that has imp0lemented the Num class
20:37:23 <Axman6> no,the type of D2 is Num t => t -> t
20:37:34 <Axman6> the type constraint is quite important
20:37:42 <manjunaths> I am trying to understand the map function
20:37:50 <manjunaths> how it is implemented using foldr
20:37:52 <Axman6> > let d2 x = 2 * x in d2 "string"
20:37:53 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
20:37:53 <lambdabot>    arising from a use of `d2...
20:38:04 <syntaxglitch> It makes me sad that GHC allows unicode syntax in place of ->, forall, and so on, but doesn't allow using an actual lambda in place of \ :(
20:38:13 <manjunaths> I read the paper, on the universality of the fold operator
20:38:38 <Axman6> manjunaths: you know how to make the identity function usiong foldr?
20:38:43 <ezyang> I wonder how CPS manages to save the underlying monadic state
20:38:45 <manjunaths> what I don't understand is ((:) . d2) (if I pass d2 as f to map) takes only one argument ?
20:38:48 <Axman6> so, foldr f x xs = xs
20:39:17 * Axman6 is off for a ride
20:39:30 <xerox> ?time Axman6
20:39:33 <lambdabot> Local time for Axman6 is Sun Dec 20 15:39:06 2009
20:39:40 <copumpkin> ezyang: you mean the Cont monad?
20:39:49 <kmc> syntaxglitch, because lambda is a lower case letter
20:39:53 <ezyang> copumpkin: Yeah
20:39:54 <manjunaths> rather where can I find information of how d2 which takes one argument and (:) which takes 2 is married by the (.) operator ?
20:40:12 <Axman6> all functions take only one argument
20:40:25 <manjunaths> Ah...
20:40:30 <Axman6> so, (:) :: a -> ([a] -> [a])
20:40:38 <syntaxglitch> kmc, I figured as much
20:40:39 * manjunaths bangs his head on the keyboard
20:40:45 <manjunaths> Axman6, thanks :-)
20:41:04 <karlw> manjunaths: Try writing filter with foldr, then write map.
20:41:15 <manjunaths> karlw, ok
20:41:21 <manjunaths> thanks for the top
20:41:23 <copumpkin> ezyang: it's not really explicitly saving anything
20:41:25 <manjunaths> s/top/tip
20:41:42 <copumpkin> ezyang: this means that if you have a bunch of IORefs or something, their state isn't going to get saved
20:41:42 <karlw> It's not hard to understand.
20:41:54 <copumpkin> (for callCC or something)
20:41:59 <ezyang> copumpkin: Oh, right.
20:42:00 <syntaxglitch> would have to special case lambda as not being the first letter of an identifier unlike every other "letter" glyph in unicode
20:42:05 <ezyang> I guess, "pure monads"
20:42:11 <syntaxglitch> but still... :(
20:42:30 <ezyang> Oh wait...
20:42:39 <kmc> ezyang, ContT State is different from StateT Cont
20:42:40 <kmc> in this respect
20:42:56 <ezyang> Yeah, I'm kind of confused now
20:43:06 <kmc> @unmtl ContT r (State s) a
20:43:07 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
20:43:12 <kmc> @unmtl StateT s (ContT r) a
20:43:13 <lambdabot> err: `ContT r (a, s)' is not applied to enough arguments.
20:43:18 <copumpkin> ezyang: do you understand the basic Cont monad?
20:43:27 <ezyang> I thought I did.
20:43:27 <kmc> @unmtl StateT s (Cont r) a
20:43:28 <lambdabot> s -> (a -> s -> r) -> r
20:44:27 <ezyang> Wait, I thought we could commute State and Cont?
20:44:36 <copumpkin> seems like
20:44:38 <copumpkin> mapCont :: (r -> r) -> Cont r a -> Cont r a
20:44:38 <copumpkin> mapCont f m = Cont $ f . runCont m
20:44:44 <copumpkin> the type sig could be more general on that
20:45:18 <copumpkin> guess not
20:45:20 <copumpkin> yeah
20:45:36 <ezyang> Ok, I'm pretty sure fix callCC save underlying monadic state.
20:45:42 <ezyang> *doesn't save
20:45:55 <kmc> "fix callCC" :O
20:48:29 <ezyang> hmm, maybe I don't actually want that
20:48:32 <ezyang> :t fix callCC
20:48:34 <lambdabot>     Occurs check: cannot construct the infinite type:
20:48:34 <lambdabot>       m = (->) (a -> m b)
20:48:34 <lambdabot>     Probable cause: `callCC' is applied to too many arguments
20:48:41 <ezyang> lol
20:48:49 <ezyang> I mean
20:48:52 <ezyang> :t callCC (\c -> return (fix c))
20:48:52 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => m (m b)
20:49:36 <HaskellLove> I went through the Jape book and I don't like it, you push a button and whoala proof unfolds, I want to do it manually and I want to know WHY I do what I do... time to do Agda or Coq. Can you guys recommend me specific cool books/papers whatever and why should I go with Agda rather then Coq or the other way around?
20:50:37 <copumpkin> HaskellLove: if you want to get anywhere in either of those languages, you might have to spend a little more than an hour or two on each of them
20:51:07 <HaskellLove> I know, I saw what Jape is about and i dont like it... wanna do try Coq or Agda
20:51:29 <kmc> you left #coq :/
20:51:47 <HaskellLove> km well I asked there and got no answer :)
20:52:04 <HaskellLove> maybe they were sleeping
20:52:06 <kmc> there are only 20 people there
20:52:21 <napping> kmc: unsafePerformIO wouldn't be fixed by requiring monomorphic types - data Bad = Bad (forall a . IORef a)
20:52:39 <kmc> napping, good point
20:52:47 <kmc> what about H98 + monomorphic uPIO?
20:53:27 <napping> oh, that's not so hard either
20:53:41 <copumpkin> HaskellLove: you're venturing into way more esoteric territory than haskell. You'll have to get used to obtuse documentation intended for people with a rather sophisticated math background, and comparatively empty, idle IRC channels :)
20:54:05 <napping> just return a bad (A -> (), () -> B)
20:54:18 <napping> hmm, maybe it's not quite that easy
20:54:49 <HaskellLove> copumpkin I can handle that, what do you use? :) If I have you as a mentor I would be glad to learn whatever you do, Agda or Coq, I will be a patient student
20:55:17 <aavogt> do you know haskell yet though?
20:55:30 <napping> syntaxglitch: recursion operators are simple things. simple algebraic data types have initiality and stuff which corresponds to the catamorphism
20:55:46 <kmc> HaskellLove, you should definitely learn Haskell well first, especially for Agda.  Agda is much like a radical extension of Haskell
20:55:52 <copumpkin> HaskellLove: I would love to mentor you in The Way of The Coq. Can you handle it though? It can be _really_ hard sometimes, almost painfully so.
20:55:56 <kmc> and the only Agda implementation is a Haskell library
20:56:23 <copumpkin> but yeah, start with a solid grasp of haskell first :)
20:56:25 <kmc> HaskellLove, but you have to change your nick again, to CoqLove
20:56:35 * copumpkin giggles
20:56:44 <EvanR> nice
20:56:58 <syntaxglitch> napping, I'm really not following you :(
20:57:22 <kmc> @quote ask.coq
20:57:23 <lambdabot> monochrom says: Ask Coq. Don't rely on head.
20:58:55 <napping> syntaxglitch: do you know what an induction principle is? or a catamorphism?
20:59:24 <syntaxglitch> not a clue :(
20:59:34 <HaskellLove> aavogt I solved 20 eulers in haskell, i think it is enough i guess, to start at least. I have read logic stuff too so... I might be ready to start slow with a professor like copumpkin beside me :) So yeah copumpkin I can handle it, we will go real slow so no worries I won't like bother you a lot...
20:59:46 <kmc> HaskellLove, you have not scratched the surface of Haskell
21:00:06 <HaskellLove> kmc you have a point there yes, copumpkin you agree, it is too early?
21:00:08 <napping> if you just consider semantics, you probably want your set of values to include a function like (a->x) -> (b->x) -> Either a b -> x
21:00:35 <hoyret> @pl \ u v -> foldr (+) 0 $ liftA2 (*) u v
21:00:36 <lambdabot> (foldr (+) 0 .) . liftA2 (*)
21:00:41 <napping> and x -> (a -> x -> x) -> [a] -> x, and so on
21:01:07 <kmc> HaskellLove, many people who use Coq don't know Haskell. but most of them are probably in the position to pick it up in a few days
21:01:18 <kmc> and by "pick it up" i don't mean "solve 20 eulers"
21:01:19 <napping> and many more resons to expect that such things exist, than that you should be able to write functions in any particular pattern matching style
21:02:03 <kmc> HaskellLove, try to learn more Haskell to the point where you can define and use custom monads
21:02:08 <kmc> not because monads in particular are so important
21:02:15 <kmc> but because it will exercise a good variety of language features
21:02:26 <kmc> datatype definitions, typeclasses, higher-order programming, etc.
21:02:43 <HaskellLove> kmc, copumpkin if you think it is too early then give me concrete steps. here is where i am now, I solve eulers, and I read TAPL now...
21:02:44 <kmc> also write a Scheme interpreter in Haskell
21:03:00 <kmc> you may be to the point where Euler isn't helping so much
21:03:01 <napping> as in, if you write down a recursive type definitition, what it means for type a T to be "the" solution to a definition that X = F<X> is basically that the appropriate sort of recursion combinator exists
21:03:02 <HaskellLove> kmc ok fair enough...
21:03:11 <kmc> they really only exercise a subset of haskell
21:03:15 <kmc> numeric and list processing mostly
21:03:23 <kmc> you aren't defining algebraic data and transformations on it
21:03:26 <copumpkin> HaskellLove: definitely too early. I've been doing Haskell solidly for a year and still feel there's more to haskell than what I've come across. You're not going to get far without getting very frustrated in agda or coq without being very comfortable in a functional language
21:03:26 <Jafet> They exercise the subset of Haskell that you can do in just about any other language
21:03:26 <xerox> eheh, list processing. lisp.
21:03:47 <HaskellLove> kmc for those kind of things i was recomended to solve sudoku by pasta_rhymez
21:04:06 <aavogt> well a sudoku solver isn't that much code
21:04:20 <aavogt> but it is an interesting start
21:04:20 <napping> otoh, it's not like you particularly need to learn Haskell to start playing with dependent types
21:04:37 <HaskellLove> copumpkin ok we got a deal I am gonna keep pushing borders when time comes you guys will see me advancing here ... so...
21:04:45 <copumpkin> :)
21:05:06 <kmc> HaskellLove, if you are interested in logic, you could do things like: write datatypes to describe structures in first-order logic, and an evaluator
21:05:14 <copumpkin> ooh that sounds fun
21:05:21 <kmc> i did that as an exercise early on
21:05:22 <kmc> it was good
21:05:25 <kmc> and you can work the exercises from TAPL in haskell
21:05:28 <kmc> in the book they use ML i think
21:05:29 <syntaxglitch> napping, that all sounds really interesting but it's midnight and I can still barely follow what you're saying :( Sorry.
21:05:38 <copumpkin> yeah
21:05:50 <napping> and learning what you can do with dependent types demonstrates one of the few ways that haskell could be improved on it's own terms
21:06:08 <HaskellLove> kmc, copumpkin I leave you in peace now, thank you... I will get some sleep now good night ;)
21:06:12 <napping> at least if you think of Haskell as a typeful and semantically grounded language
21:06:21 <kmc> HaskellLove, if you can write a good type checker for System F and a Hindley-Milner type inference algorithm
21:06:29 <kmc> then you might want to attack the coq
21:06:32 <karlw> How may one corrupt young minds without Emacs or Vim?
21:06:46 <napping> not to say there are few ways to improve on Haskell, just that demonstrations are rare
21:06:56 <QtPlaty[HireMe]> Is coq free?
21:07:08 <napping> coq.inria.fr
21:07:08 <kmc> napping, it's not that Haskell is a prerequisite for dependently-typed programming
21:07:29 <kmc> it's that you need to be familiar with functional programming and a general sort of very formal approach to programming
21:07:43 <kmc> and "learn Haskell" is some practical constructive advice for getting to that point
21:08:12 <aavogt> kmc: but is it a prerequesite in the sense that imperative programming and knowing machine language are prerequisites for learning haskell?
21:08:16 <napping> I'd suggest TAPL and Coq'Art to learn about type systems and stuff. Good books are a lot more info-dense than blogs and stuff
21:08:26 <kmc> aavogt, those demonstrably aren't though
21:08:32 <kmc> it that it actually seems *easier* if you skip them
21:08:32 <aavogt> oh, you did sort of give examples that are more related
21:08:46 <kmc> if some hardcore OCaml hacker or PhD logician came in, i definitely wouldn't say they should learn Haskell before trying Coq or Agda
21:09:07 <aavogt> maybe agda for the syntax
21:09:19 <kmc> syntax is trivial ;)
21:09:26 <aavogt> true
21:09:28 <kmc> but also, you might as well learn Haskell too because it's fucking cool ;)
21:09:38 <EvanR> syntax isnt trivial in c++ :)
21:09:52 <kmc> it's not entirely trivial in Haskell either
21:09:58 <kmc> but it should not be the major obstacle in any language
21:10:04 <kmc> it's not, even in C++, because they added so many obstacles elsewhere
21:10:16 <karlw> C++ isn't a *real* language
21:10:29 * johnnowak points at J
21:10:34 <robinhoode> Is there any way to "lift" a function of type a -> (a, a) to a monad type m a -> (m a, m a) with something like liftM?
21:10:46 <kmc> HaskellLove is extremely ambitious and wants to learn by skipping many steps ahead.  I'm just describing what I think some of the intermediate steps are.
21:11:16 <karlw> It's assembly code mixed with this ``class of objects'' nonsense.
21:11:25 <xerox> robinhoode: you'd have to split the m (a,a) "by hand"
21:11:28 <kmc> robinhoode, i don't think you can do "m (a,a) -> (m a, m a)" in a general monad
21:11:40 <kmc> like IO... how do you "split up" the side effects?
21:12:00 <aavogt> the other way makes sense
21:12:03 <kmc> if i have a recipe for IO, i can't chop it up into two recipes and then choose not to evaluate one, or to put them in different order
21:12:06 <kmc> :t liftM2 (,)
21:12:08 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
21:12:34 <napping> kmc: sure you can - \act -> (fmap fst act, fmap snd act)
21:12:48 <copumpkin> there's also a zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
21:13:00 <napping> probably wrong semantics, but you get something
21:13:01 <xerox> robinhoode: if you have a -> (a,a) defined as really being (a -> a, a -> a), there's a possibility
21:13:17 <xerox> (but that is not all a -> (a,a))
21:13:25 <kmc> :t \act -> (fmap fst act, fmap snd act)
21:13:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> (f a, f b)
21:13:46 <kmc> napping, true.  but if you sequence those results together, you've duplicated whatever "effects" the monad models
21:13:54 <napping> well, sure
21:14:00 <kmc> for some reason i thought this was not desired
21:14:03 <napping> but you started with a pure function
21:14:15 <robinhoode> I'm just passing around tuples because I'm maintaining multiple versions of variables.. I'm converting some very imperative code into Haskell
21:14:20 <napping> you'd duplicated the effects in the m a passed to the lifted function
21:14:41 <kmc> robinhoode, sometimes it can be more convenient to define your own type (perhaps a record) than to use tuples
21:14:48 <kmc> tuples are sort of intended for small localized cases
21:15:06 <napping> robinhoode: if so, you might be better off making m a -> m (a,a)
21:15:07 <kmc> plus, you can define your own convenience functions for working with your records in a monadic context
21:15:08 <napping> which is easy
21:15:23 <kmc> :t liftM $ join (,)
21:15:26 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (a1, a1)
21:16:14 <robinhoode> I'll try that out. Thanks guys
21:16:18 <kmc> :)
21:17:18 <napping> I'm not sure why you are mixing monads and tuples like that, if you are turning imperative code into explicit state passing
21:18:22 <robinhoode> Error handling, mostly..
21:18:41 <napping> why do you want to take an m a as an argument?
21:20:04 <napping> usually you'd write functions that take values that are already pure - already checked for error, and have your maybe or somnething only appear as a possible result
21:20:14 <napping> and then join it all up with do blocks or >>=
21:21:34 <robinhoode> Hmm....
21:22:28 <robinhoode> Well, this might make me seem like newb, cuz I'm not sure what the standard practices are, but I'm trying to avoid giving the compiler too much type information to make it easier to maintain and read..
21:23:04 <napping> neither should end up requiring explicit type information, if you are just using Maybe or Either or something like that
21:23:56 <napping> oh, and of course if you are using that sort of monad that it would be easy enough to write something in Maybe a -> (Maybe a, Maybe a) if you wanted to
21:24:33 <napping> but passing around Maybe a everywhere is like passing around nullable pointers everywhere
21:25:16 <napping> It's usually probably better check once and then pass around the successful result, rather than get deep into another operation before you bother to check if the last worked
21:25:25 <kmc> robinhoode, you're doing error handling + state
21:25:39 <kmc> do you maybe want ErrorT State or StateT Error monad stacks?
21:25:44 <napping> oh, stat wouldn't split nicely
21:25:48 <kmc> then both aspects wi/ll  be threaded through for you
21:25:57 <napping> I thought the exercise was translating out state?
21:32:53 <kmc> @remember Twan What can we do with such a well-plated boiler?
21:32:54 <lambdabot> It is forever etched in my memory.
21:44:44 <napping> Say I've got a list l. Is there any clever linear size summary that helps compute minimum (take n (drop m l))?
21:44:50 <roostaj> i must say that I am impressed by the ghc compiler
21:44:55 <roostaj> but i have a question
21:45:07 <kmc> napping, for specific n and m?
21:45:16 <napping> to be able to quickly recompute it
21:45:21 <kmc> oh
21:45:38 <roostaj> is "ghc --make" equivalent to "ghc -c -O" then "ghc -o"
21:45:49 <kmc> roostaj, i don't think --make implies optimization (-O)
21:45:54 <kmc> and make will chase dependencies
21:46:04 <kmc> it will build any modules you import that have changed since last build
21:46:06 <napping> make and -O are separate options
21:46:10 <kmc> and it will find and link the right packages too
21:46:24 <roostaj> kmc: so "ghc --make -O" will work
21:46:25 <napping> you can use the normal options with make, and they will be used for every module it has to compile, or for the link
21:46:27 <kmc> you should pretty much always use --make unless you have to integrate with an existing Makefile or similar, or you have specific needs
21:46:29 <kmc> roostaj, yes
21:46:34 <kmc> i use -O2
21:46:42 <roostaj> reason?
21:46:48 <napping> or ghc --make -O2 -threaded
21:46:58 <sproingie> argh.  has anyone ever successfully used SDL with OpenGL in haskell?
21:47:02 <kmc> roostaj, -O2 optimizes harder than -O
21:47:09 <roostaj> kmc: very cool
21:47:11 <kmc> -O2 is the top for ghc
21:47:16 <sproingie> i have a couple examples that give me blank screens or crash instantly
21:47:19 <napping> slower though. Actually, I guess I have been using just --make recently
21:47:28 <kmc> sproingie, i've use OpenGL but not SDL
21:47:36 <kmc> SDL has disappointed me in most any language
21:47:46 <sproingie> SDL has image conversions for textures
21:47:46 <napping> guess I would have had to rewrite anyway - the slowness was in HXT
21:47:51 <roostaj> kmc: my understanding is ghc takes .hs => .hc => .asm right?
21:47:55 <sproingie> i can't find *anything* to deal with texture loading
21:47:58 <roostaj> where .hc is just C code?
21:48:01 <kmc> roostaj, it does not always compile via C
21:48:17 <roostaj> kmc: does it choose instances to do so? or is it only when invoked?
21:48:27 <kmc> it also produces .hi "interface" files which are needed for imports
21:48:40 <kmc> roostaj, i believe it's controlled solely by -fvia-C and some per-platform default
21:48:40 <kmc> not sure
21:48:49 <kmc> also, it usually mangles the assembly output of the C compiler in a platform-dependent way
21:49:21 <roostaj> kmc: it would likely leave the hc files there if it compiled to them, which i have never seen
21:49:31 <kmc> roostaj, i think it does not leave the files in either case
21:49:33 <kmc> unless you ask it to
21:49:44 <napping> roostaj: no, it only leaves them if you ask it to - and it no longer uses C at all by default
21:49:49 <kmc> there are also many internal languages, for which it can dump out representations if asked
21:49:56 <roostaj> kmc: oh i see cool
21:50:03 <kmc> napping, on some architectures -fvia-C is the only option though
21:50:07 <roostaj> napping: thanks :)
21:50:18 <roostaj> i'm on windows btw
21:50:20 <kmc> some people were doing Haskell iPhone dev with an unregistered via-C ghc
21:50:21 <napping> hmm, guess a summary would have to be an array or something, lest consulting it take O(n) time
21:50:37 <napping> x86 is covered by the native codegen
21:51:20 <sproingie> oh hay maybe i can snag frag's texture code
21:51:27 <sproingie> god knows i can't find any other examples
21:52:20 <sproingie> using the devil bindings would be nice but i can't figure how to use it.  does it just parse the extension of the filename?
21:52:30 <roostaj> napping: so it goes straight to assembly or what is the default intermediate language?
21:52:54 <napping> well, it goes through the intermediate language all the time.
21:53:09 <napping> Core is the one where rewrite rules and stuff happen
21:53:39 <kmc> roostaj, there are lots of intermediate languages inside the compiler
21:53:50 <kmc> in terms of interfacing to external tools, it will output assembly to gas (i believe)
21:54:10 <kmc> internally there is Core, STG, and C--
21:54:32 <monochrom> dons knows Core/STG/C-- :)
21:54:34 <roostaj> kmc: what is Core?
21:54:42 <kmc> roostaj, desugared Haskell basically
21:54:51 <roostaj> kmc: :)
21:54:56 <kmc> the essence of Haskell, boiled down to a few core constructs
21:55:11 <sproingie> Core is strange
21:55:18 <kmc> STG is the Spineless Tagless G-Machine, though modified heavily since the original paper
21:55:40 <sproingie> STG is itself a graph rewriting engine, no?
21:55:41 <monochrom> IIRC Core is "system Fc", a kind of lambda calculus with very rich types.
21:55:44 <kmc> it is basically an abstract machine to which you can compile lazy functional code effectively, yet which also maps onto commodity hardware nicely
21:55:57 <kmc> sproingie, the STG language has a graph-rewriting denotational semantics
21:56:16 <kmc> or perhaps i should say a non-strict reduce-to-WHNF denotational semantics
21:56:29 <kmc> and it has an operational semantics with a heap which undergoes graph rewriting
21:56:47 <sproingie> that sounds a lot harder to wrap my head around than stack or register machines
21:56:54 <kmc> yeah it's fairly mind-bending
21:56:59 <kmc> the original paper is quite good, if dated
21:57:06 <kmc> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
21:57:30 <roostaj> kmc: so a revised answer would be Haskell => Core => STG => C-- => Assembly
21:57:38 <kmc> sure
21:57:40 <roostaj> lol
21:57:40 <roostaj> :D
21:57:59 <kmc> there are optimizations as Core->Core, STG->STG, and C--->C--
21:58:12 <kmc> i should disclaim that i'm not actually a GHC hacker and have picked this up secondhand
21:58:22 <dons> i had to study core back in 2002 many hours a day. :)
21:58:32 <dons> scaary
21:59:01 <kmc> C-- is an imperative language with unchecked machine-level types and basically the capabilities of a platform-independent assembler
21:59:09 <bnijk_> wtf
21:59:15 <bnijk_> C--?
21:59:27 <kmc> there is a C-- runtime which interfaces to the frontend language's runtime and provides the hooks necessary for things like garbage collection
21:59:28 <johnnowak> http://cminusminus.org/
21:59:33 <kmc> i don't know if that's used by the GHC Haskell runtime
21:59:39 <bnijk_> there's something for everything i guess
21:59:54 <roostaj> kmc: so basically you don't want to convert Haskell to C because it isnt going to be very efficient or pretty so you go to something that you can still use gcc as a backend for (C--) which is lower level?
22:00:01 <dons> a variant is used as an intermediate layer of ghc
22:00:06 <kmc> gcc does not have C-- support
22:00:16 <roostaj> kmc: ah, my mistake
22:00:16 <dons> C-- is translated to C by GHC.
22:00:23 <bnijk_> dons: ?
22:00:26 <dons> but also to asm directly. parts of the runtime are written in C--
22:00:27 <bnijk_> how can GHC do that
22:00:29 <kmc> and yes the main problem with compiling via C is efficiency
22:00:33 <dons> the magic of compilers.
22:00:40 <bnijk_> oh yes
22:00:43 <bnijk_> automagic
22:00:44 <kmc> bnijk_, well, the capabilities of C-- are mostly a subset of the capabilities of C
22:00:46 <monochrom> by hard work.
22:00:50 <kmc> with a few notable exceptions like tail calls
22:01:07 <bnijk_> kmc: yes, but a subset of the capabilities of GHC?
22:01:13 <napping> hmm, say I've got a Map k a, a Map k b on a subset of keys, (a -> b -> (a,c)), and want the obvious new (Map k a,Map k c)
22:01:13 <bnijk_> that's what's strange
22:01:18 <johnnowak> is C-- as dead as it looks to be?
22:01:37 <kmc> bnijk_, so you're saying the general idea of compiling Haskell to C or assembly is strange
22:01:38 <kmc> which it is
22:01:42 <bnijk_> no, kmc
22:01:44 <kmc> but this has nothing to do with the C-- to C phase
22:01:44 <bnijk_> it makes perfect sense
22:01:51 <Cale> bnijk_: Well, it's Turing complete too, so obviously there's a way to translate code from one language to the other.
22:01:58 <bnijk_> GHC is turing complete? ok
22:02:01 <sproingie> is c-- not the same c-- language that was proposed as a c-like language for compiler backends?
22:02:02 <kmc> bnijk_, ?
22:02:04 <bnijk_> well that settles it
22:02:04 <kmc> Haskell is turing complete
22:02:08 * ezyang has begun writing his TMR article! 
22:02:15 <bnijk_> kmc: well, "the implementation of haskell in GHC"
22:02:15 <kmc> GHC is a compiler for Haskell
22:02:21 <bnijk_> "compiled by GHC"
22:02:23 <napping> I'd like to avoid duplicating the computation
22:02:23 <Cale> bnijk_: But you really want a machine to do that, because a little bit of Haskell code can turn into a lot of C code.
22:02:26 <dmwit> ezyang: Great!  There's only one step after that... =)
22:02:27 <kmc> bnijk_, a compiler backend is difficult to write correctly, yet mostly a solved problem.  hence the usefulness of systems like C-- and LLVM
22:02:30 <sproingie> bnijk_: that has nothing to do with turing completeness
22:02:39 <sproingie> bnijk_: do you know what turing complete means?
22:02:41 <ezyang> dmwit: "Finishing the article"? :-)
22:02:45 <bnijk_> i know what turing complete means...
22:02:46 <dmwit> ezyang: bingo! =D
22:02:49 <kmc> and to the extent it's not a solved problem, you still want a common language for plugging e.g. your optimizations into someone else's codegen
22:02:51 <Cale> bnijk_: A compiler is a program for translating programs written in one language into another language.
22:02:55 <bnijk_> oh god
22:02:56 <roostaj> Cale: a certain 4 line haskell code turned into 2400 lines of assembly i tried earlier
22:02:56 <bnijk_> here we go
22:03:07 <roostaj> Cale: I thought that was neat
22:03:21 <bnijk_> yes Cale the thing is, i thought GHC was specific to haskell
22:03:28 <sproingie> not hard to generate that much asm with c++
22:03:33 <Cale> bnijk_: GHC *is* specific to Haskell.
22:03:34 <sproingie> ghc is a haskell compiler
22:03:37 <bnijk_> ok
22:03:42 <bnijk_> then how can you compile C-- to C with GHC
22:03:49 <kmc> bnijk_, that is one of the components inside GHC
22:03:53 <Cale> bnijk_: C-- is one of GHC's intermediate languages
22:03:56 <bnijk_> ohh
22:03:57 <bnijk_> ok
22:04:00 <bnijk_> say no more
22:04:00 <sproingie> i thought c-- went straight to asm
22:04:03 <luite> sproingie: I guess with c++ you could even generate 2400 lines of error messages with 4 lines of code
22:04:04 <kmc> GHC compiles Haskell to Core to STG to C-- to (C or asm)
22:04:05 <sproingie> or is this a different c--?
22:04:11 <kmc> luite, hahaha
22:04:17 <kmc> how true that is
22:04:19 <napping> ah, I can do intersectionWith, then disentangle
22:04:31 <napping> and update the first map
22:04:33 <bnijk_> it's amazing all those transitions don't seem to slow down the programs ;)
22:04:40 <bnijk_> what a year we live in
22:04:49 <kmc> bnijk_, the transformations are done at compile time
22:04:50 <tensorpudding> compiling is really slow
22:04:53 <sproingie> i remember reading about a c-- language that was more or less a subset of C with some extra bare-metal stuff like naked call conventions
22:04:53 <tensorpudding> haven't you noticed?
22:04:54 <kmc> or do you mean the speed of running ghc
22:04:57 <bnijk_> compiling is slow
22:04:58 <sproingie> is this the same c--?
22:05:01 <bnijk_> i mean the speed of the resulting code
22:05:02 <kmc> sproingie, think so
22:05:02 <copumpkin> cmm
22:05:18 <kmc> bnijk_, more intermediate languages can imply better codegen, not worse
22:05:29 <kmc> because some optimizations can only be expressed at high level, and some only at low level
22:05:42 <roostaj> bnijk_: the leap from interpretted haskell to compiled with ghc in terms of performance is pretty impressive from the little I've used it
22:05:42 <bnijk_> can't all optimizations be expressed at low level...
22:05:47 <bnijk_> just painstakingly
22:05:47 <tensorpudding> some compilers are really slow
22:05:49 <kmc> bnijk_, not effectively
22:06:06 <Cale> bnijk_: Moreover, processors have become so complicated that computers tend to do a better job at many sorts of optimisations than humans can.
22:06:11 <sproingie> technically anything can be expressed at low level, but not in a tractable fashion
22:06:21 <tensorpudding> but that is usually because they are trying to do a ton of optimizations
22:06:21 <monochrom> If you know types, you can optimize more.
22:06:34 <sproingie> in the end it's about symbolic manipulation, and if you can't recognize symbols, you can't work with them
22:06:37 <kmc> it's probably undecidable to look at assembly output from GHC and do loop fusion
22:06:44 <kmc> so in that sense it's not even painstakingly possible
22:06:56 <bnijk_> hey dons you still there
22:07:02 <kmc> err let's say stream fusion
22:07:10 <sproingie> there is that too, intent gets lost
22:07:27 <sproingie> like, oh, the entire type system
22:07:52 <roostaj> bnijk_: I would think it to be true that there are certain optimizations a human would take if converting directly to assembly that these intermediate languages would miss but the trade-off between work-maintainence time and slight optimizations is in favor of the intermediate languages
22:08:01 <bnijk_> yep
22:08:03 <bnijk_> i understand
22:08:05 <sproingie> part of what a type system does is prove certain behaviors never happen
22:08:11 <sproingie> you can make optimizations from that
22:08:11 <roostaj> bnijk_: :)
22:08:11 <kmc> you can always write your inner loop in assembly
22:08:15 <kmc> in basically any language
22:08:18 <sproingie> but you can't glean the types from assembly
22:08:20 <kmc> including Haskell
22:08:47 <tensorpudding> compilers are big
22:08:54 <roostaj> tensorpudding: si
22:09:53 <bnijk_> the sad thing about programming is that you can never fully understand it
22:10:00 <copumpkin> speak for yourself
22:10:05 <copumpkin> I understand everything
22:10:07 <tensorpudding> that's true with anything that is big
22:10:11 <bnijk_> you can understand the emergent functionality
22:10:12 <kmc> if you tried to compile directly from Haskell to C with no intermediate languages, you would probably end up with a halfassed unmaintainable version of Core and STG buried deep within your compiler, and it would be much harder to write optimizations
22:10:13 <bnijk_> perfectly
22:10:17 <monochrom> the sad thing about life is that you can never fully understand it
22:10:19 <bnijk_> but you'll never know every algorithm
22:10:26 <bnijk_> monochrom: that too ;)
22:10:32 <kmc> there's not really any kind of tradeoff between "more intermediates" and "faster codegen"
22:11:18 <kmc> even for compiling C to assembly, GCC uses at least two IRs
22:11:21 <kmc> i think 3
22:11:31 <bnijk_> from within the heavens come these beautiful songs, these beautiful flowers; our longing spoils them
22:11:35 <bnijk_> our expression makes them lose their fragrance
22:11:45 * bnijk_ plays a harp
22:12:20 <kmc> bnijk_, i think you can understand every piece of the stack, conceptually, if not in detail
22:12:24 <kmc> and also that most people don't
22:12:35 <tensorpudding> GCC is slow
22:12:39 <bnijk_> does anybody want this strawberry cream tart...i can't eat any more
22:12:50 <kmc> give it to lambdabot
22:12:56 <ezyang> /botsnack
22:13:02 <tensorpudding> @botsnack
22:13:02 <lunabot>  :o
22:13:02 <lambdabot> :)
22:13:03 <monochrom> upload it to wikipedia
22:13:29 <bnijk_> > feedLambdabot
22:13:30 <lambdabot>   Not in scope: `feedLambdabot'
22:13:38 <roostaj> kmc: someday i'll dig into ghc myself and see how it works
22:13:40 <bnijk_> > feedLambabot
22:13:41 * ezyang wonders if using Turing machines for my backtracking search example is a good idea. 
22:13:42 <lambdabot>   "feed me, feed me PEOPLE"
22:13:53 <ezyang> wat
22:13:53 <kmc> roostaj, i'd like to do that as well
22:14:05 <luite> sorry to ask again, but has anyone seen this error when installing happstack-data with ghc 6.12.1, using cabal-install 0.8.0: ghc.exe: dist\build\Happstack\Data\Default.o: unknown symbol `_sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_constrZMacbsZN_closure'
22:14:10 * roostaj gets out the to-do list
22:14:55 <kmc> > integerToBreakfast 4
22:14:57 <lambdabot>   "Bacon, eggs, toast, tomato and mushroom. You deserve it"
22:15:11 <bnijk_> :t integerToBreakfast
22:15:12 <lambdabot> Int -> [Char]
22:15:20 <bnijk_> > integerToBreakfast 3
22:15:21 <lambdabot>   "Cup of tea and a biscuit, gotta dash"
22:15:23 <tensorpudding> that's not a breakfast
22:15:23 <ezyang> > integerToBreakfast 9000
22:15:23 <lambdabot>   "* Exception: Prelude.(!!): index too large
22:15:29 <bnijk_> hahaha
22:15:31 <sproingie> i think gcc uses less intermediates these days
22:15:36 <kmc> luite, not me.  looks like it's failing to find part of the syb-with-class package
22:15:52 <bnijk_> ezyang: it fits
22:16:02 <luite> kmc: yes that's what I thought too, but it is installed, I even reinstalled it
22:16:05 <sproingie> it's like C -> SSA GIMPLE -> RTL -> asm i think?
22:16:06 <tensorpudding> > integerToBreakfast 7
22:16:07 <lambdabot>   "Orange juice and muffins"
22:16:17 <bnijk_> who wrote that function
22:16:17 <tensorpudding> > integerToBreakfast 8
22:16:18 <lambdabot>   "Apples, pears, mango and kiwi"
22:16:50 <kmc> bnijk_, it's from a @quote, don't know the author
22:17:02 * DigitalKiwi mumbles about annoying bots pinging him
22:17:12 <monochrom> @type toEnum
22:17:14 <lambdabot> forall a. (Enum a) => Int -> a
22:17:14 <ezyang> haha
22:17:24 <dmwit> You know what my favorite fruit is?  kiwi kiwi kiwi!
22:17:26 <tensorpudding> > toEnum
22:17:27 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
22:17:32 <monochrom> Is it just me or is "toEnum 7 :: Breakfast" far more concise?
22:17:46 <tensorpudding> > toEnum 2
22:17:47 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
22:18:16 <dmwit> > toEnum 0
22:18:17 <lambdabot>   ()
22:18:27 <luite> kmc: completely removing syb-with-class and then installing it again doesn't help either
22:18:34 <monochrom> > [0..] :: [()]
22:18:34 <dmwit> > toEnum :: Int -> Char
22:18:39 <kmc> :/
22:18:41 <lambdabot>   No instance for (GHC.Num.Num ())
22:18:43 <lambdabot>   * Exception: Prelude.chr: bad argument
22:18:45 <lambdabot>    arising from the literal `0' at <intera...
22:18:51 <monochrom> Oh!
22:18:57 <monochrom> > [()..]
22:18:58 <lambdabot>   [()]
22:19:00 <dmwit> > toEnum . abs :: Int -> Char
22:19:01 <lambdabot>   {-3->'\ETX';-2->'\STX';-1->'\SOH';0->'\NUL';1->'\SOH';2->'\STX';3->'\ETX'}
22:19:23 <luite> is it possible that something caused an inconsistency between the .hi and .o files?
22:19:49 <kmc> > integerToBreakfast 9000
22:19:50 <lambdabot>   "Bacon, eggs, toast, tomato and mushroom. You deserve it"
22:20:05 <luite> you make me hungry :p
22:20:20 <luite> almost time for breakfast here (7:19 am)
22:20:37 <kmc> @quote kiwi
22:20:38 <lambdabot> integerToBreakfast says: = (["Cornflakes", "Strawberry jam toast", "Grapefruit", "Cup of tea and a biscuit, gotta dash", "Bacon, eggs, toast, tomato and mushroom. You deserve it", "Waffles", "
22:20:38 <lambdabot> Porridge of some description", "Orange juice and muffins", "Apples, pears, mango and kiwi", "A selection of cold meats with crisp bread", "Headache pills and water", "Leftover pizza", "Leftover
22:20:38 <lambdabot> vindaloo curry"] !!)
22:21:39 <monochrom> Nice.
22:22:05 <ezyang> +1 vindaloo curry
22:22:18 <kmc> vindaloo++
22:22:39 <Runar> Not many people know that Haskell's middle name was Vindaloo.
22:22:54 <copumpkin> the karma syntax is awfully imperative
22:22:57 <ezyang> I thought it was Brooks... oh, lol
22:23:09 <monochrom> Haskell Vindaloo Curry?
22:25:16 <monochrom> Rose Mary Lamb
22:25:38 <sproingie> mmm
22:27:01 <sproingie> i got a chuckle that when the haskell folks asked Virginia Curry, Haskell Curry's widow, she said something like "Haskell never did like the name Haskell"
22:35:37 <jmillikin> Anybody having problems logging into patch-tag?
22:35:40 <napping> is there something like Map.insersectionWith, but where the combining function returns a Maybe?
22:37:08 <kmc> napping, compose it with mapMaybe id
22:37:11 <kmc> :t M.mapMaybe id
22:37:12 <lambdabot> forall b k. (Ord k) => M.Map k (Maybe b) -> M.Map k b
22:37:30 <napping> thanks
22:37:48 <kmc> :t \f a b -> M.mapMaybe id $ M.intersectionWith f a b
22:37:50 <lambdabot> forall b k a b1. (Ord k) => (a -> b1 -> Maybe b) -> M.Map k a -> M.Map k b1 -> M.Map k b
22:44:49 <napping> funny, the most annoying code so far has been for intersecting range representations
22:45:26 <BMeph> Is there a data structure like a list, but where the fundamental constructor is more like append than cons? -- If that makes sense...
22:45:36 <napping> a tree?
22:45:41 <copumpkin> BMeph: a DList?
22:46:12 <BMeph> napping: Yeah, thet's kkind of where I'm leaning; looking to recreate "the Hierarchy" in Haskell.
22:46:54 <monochrom> Sequence
22:47:06 <napping> is there no standard monoid wrapper for min and max?
22:47:13 <copumpkin> napping: it's a semigroup
22:47:26 <dmwit> napping: What's zero?
22:47:28 <copumpkin> unless you have a Bounded constraint :)
22:47:42 <BMeph> copumpkin: Hmm, that's a good point. A DList is kind of like the equivalent of defining sets by characteristic function...maybe. :)
22:47:49 <monochrom> or extended numbers
22:47:49 <napping> well, actually I do want to add appropriate infinities
22:48:12 <copumpkin> instance Monoid (Max (Maybe a)) where
22:48:13 <dmwit> There may be min/max monoids for Ord a => Maybe a.
22:48:15 <napping> I'm thinking of replacing an Any | GE v | LT v | Range v v with a pair of wrapped things
22:49:48 <luite> has anyone here been able to install happstack-data with ghc 6.12.1? I get the same 'unknown symbol' error on both windows and linux
22:51:50 * BMeph has been slogging through Squiggol papers, and is interested in the "Boom type hierarchy" business
22:52:02 <ezyang> BMeph: Squiggol?
22:53:28 <johnnowak> ezyang: bird-meertens formalism probably yields better search results
22:53:35 <BMeph> ezyang: http://en.wikipedia.org/wiki/Bird-Meertens_Formalism (AKA "Squiggol")
22:54:24 <bnijk_> even some of you haskell coders seem to trust google
22:54:26 <bnijk_> tsk, tsk
22:54:32 <bnijk_> goodnight
22:55:12 <Gracenotes> tweet tweet
22:55:30 <ezyang> nighty night
22:57:10 <napping> wait, Num requires Show now?
22:57:25 <copumpkin> always has :(
22:57:28 * copumpkin shudders
22:57:30 <johnnowak> napping: unfortunately
22:57:31 <BMeph> Basically I like the concept where leaf-valued binary trees, append-defined (finite) lists, bags and sets form a hierarchy, similar to the hierarchy of numbers.
22:57:33 <napping> :(
22:57:38 <sproingie> god bless frag.  still can't understand the FRP parts but it has a nice simple texture loader that even supports mipmaps
23:00:53 <BMeph> I.e., lists "are" trees that obey associativity, bags "are" lists with commutativity, and sets are bags with idempotence. A Similar relation could, with enough squinting, be seen with octonions, quarternions, complex, and (non-negative) reals.
23:06:22 <fynn> Hey, anyone knows Gitit?  http://gitit.net/
23:06:35 <kmc> BMeph, that's pretty cool.  never saw it that way before.
23:06:46 <fynn> (It's a Haskell wiki based on Git)
23:06:54 <kmc> i've heard of it
23:07:45 <fynn> kmc: any general idea how they do the Git interfacing?
23:07:45 <humble_hoser> you'd think if it was written in haskell they'd use darcs :P
23:07:56 <kmc> but git is so, so sexy
23:07:58 <fynn> humble_hoser: they support that too (and mercurail as well)
23:08:00 <copumpkin> there is a darcs modification of it too
23:08:01 <kmc> fynn, no, i'd just read the code
23:08:03 <kmc> if i had to find out
23:08:09 <fynn> yeah, I'll probably do that
23:08:15 <kmc> even ghc was going to switch to git
23:08:23 <fynn> didn't it already
23:08:29 <kmc> but it took long enough that darcs got better in the meantime
23:08:33 <kmc> or something like that
23:08:48 <ezyang> fynn: When I last checked, they didn't really have a good abstraction layer above Git.
23:09:07 <ezyang> Writing good functional plumbing for a traditionally imperative program is kind of hard :-)
23:09:20 <fynn> ezyang: interesting. dealing with race conditions for multiple users changes at runtime can lead to non-trivial race conditions.
23:09:36 <fynn> Git in general is problematic for this; it doesn't really expose an API.
23:09:44 <BMeph> I'd imagine that they're saving the darcs-default web-accessible site to use the darcsIDE.net URL... ;)
23:10:38 <fynn> ezyang: if they didn't write a really good layer, Gitit is probably not production-grade stable.
23:10:39 <kmc> the underlying model of Git is quite functional
23:11:02 <fynn> kmc: what makes a DAG "functional"?
23:11:05 * BMeph just realized that that would put a whole new spin on the "Come to the darkside; we have cookies!" meme...
23:11:06 <jmcarthur> the exposed model is as well, really
23:11:29 <ezyang> I mean, objects are immutable
23:11:31 <jmcarthur> fynn: it's purely functional in the sense that it isn't actually mutable besides where HEAD points
23:11:32 <kmc> the main datastructure in Git is a database of immutable objects
23:11:33 <ezyang> Which is pretty nice.
23:11:45 <kmc> content-addressible
23:11:59 <fynn> jmcarthur: the connecting graphs are certainly mutable.
23:12:11 <jmcarthur> fynn: not so :)
23:12:16 <kmc> if you have the name of an object, you know it will always and forever be the same
23:12:21 <kmc> because the name is a hash of the contents
23:12:27 <kmc> on top of this, there is a set of mutable named pointers
23:12:37 <kmc> which are quite literally files in .git whose contents are hashes
23:12:40 <fynn> jmcarthur: how not?  every commit adds an edge.
23:12:53 <fynn> merges too, of course.
23:12:55 <kmc> fynn, every commit adds an object to the database.  it does not change any existing object
23:12:56 <ezyang> Well
23:13:02 <jmcarthur> fynn: a git object is every commit necessary to reach that point. you don't actually change anything when you make more objects
23:13:11 <ezyang> That's where the /directed/ in DAG comes into play :-)
23:13:11 <fynn> kmc: if you don't define the DAG itself as an object.
23:13:24 <kmc> fynn, well, they don't.  and that's what i meant by the "underlying model"
23:13:46 <kmc> you can always invent a mutable view on something
23:14:00 <jmcarthur> fynn: git does the same thing with its DAG that haskell does with its own
23:14:20 <fynn> jmcarthur: you can actually modify those objects afaik. you can merge and split commits with rebasing.
23:14:24 <kmc> jmcarthur, sort of.  haskell implementations do in-place update of thunks to values.  there's no analogue in git
23:14:31 <jmcarthur> fynn: you create *new* objects that way
23:14:36 <kmc> fynn, those create new commit objects
23:14:40 <jmcarthur> fynn: note that they end up with different hashes
23:14:46 <kmc> you can look in gitk or whatever and see the old commits, now unreachable
23:14:48 <fynn> well, correct.
23:14:52 <kmc> (they can be later garbage-collected)
23:15:05 <fynn> I'm still not sure what makes this particularly "functional" :)
23:15:18 <jmcarthur> fynn: nothing changes
23:15:23 <ezyang> Functional datastructures are all about immutablity
23:15:32 <napping> fynn: um, like the way graph reduction is functional?
23:15:37 <jmcarthur> as long as the reflog hold a reference you can always undo
23:15:39 <kmc> fynn, what makes it like pure functional programming is this property: A name stands for a value, not a mutable location
23:15:40 <fynn> see, that's my problem with FP
23:15:54 <fynn> sometimes it's damn useful to be able to mutate objects.
23:16:00 <fynn> necessary, even.
23:16:06 <kmc> fynn, that's why Haskell has many libraries for doing so
23:16:16 <jmcarthur> fynn: git seems to do so well at that that you were tricked into believing it was *real* mutation
23:16:20 <fynn> kmc: so those libraries are not "functional"?
23:16:20 <kmc> now, when would this be necessary in the context of git?
23:16:24 <kmc> fynn, they are in a sense
23:16:39 <kmc> i used a term in a vague "feels like" sense and you are trying to make it much sharper
23:16:40 <fynn> not in Git's context; it's well designed.
23:16:50 <jmcarthur> fynn: define "well designed"
23:16:52 <napping> it is much more often useful to know that things will not be mutated out from under you
23:16:55 <jmcarthur> i think haskell is well designed
23:17:01 <fynn> jmcarthur: I think so to.
23:17:31 <napping> and you can use a bit of explicit state otherwise
23:17:35 <kmc> fynn, if you want to be precise: No Haskell function mutates anything by being evaluated.  Some Haskell functions return "instructions" for how something could later be mutated
23:17:51 <fynn> would anyone like to comment on http://news.ycombinator.com/item?id=1004885 ?
23:18:06 <jmcarthur> i don't really understand why people seem to have a problem immutability
23:18:29 <dibblego> jmcarthur, it's a very difficult mindset to break (the marriage to mutability)
23:18:40 <kmc> fynn, anyway, usually i prefer to use "functional" to mean "has first-class functions", not "has only pure functions"
23:18:49 <fynn> basic claim there is that while Haskell and similar purely-functional languages are theoretically better for parallelism, the reality is that MPI dominates the field, and Haskell et al are unlikely to catch up.
23:18:49 <jmcarthur> *problem with
23:18:50 <kmc> because otherwise we exclude most languages commonly described as functional
23:19:39 <napping> HPC?
23:19:45 <napping> Fortran dominates the field
23:19:46 <fynn> napping: yup, mainly.
23:19:50 <kmc> fynn, for the bleeding edge of compute-heavy HPC, sure, i agree totally
23:20:22 <kmc> if you're willing to spend a gazillion dollars on a supercomputer, you're willing to put in many developer-hours in order to get an extra few percent of speed
23:20:35 <jmcarthur> fynn: i would classify the comment you linked to as... narrow minded
23:20:45 <fynn> the conclusion is that even in the long term, C/++ and Fortran are going to be a better choice, since they just have the best and most well-maintained and developed MPI libraries, while FPs are not getting the necessary attention to catch up.
23:20:47 <napping> In other words, it's true as far as it goes, but almost irrelevant to any programming any of us are likely to do
23:20:51 <fynn> jmcarthur: interesting!  how so?
23:21:08 <napping> says nothing about SMP programming on commodity multicore systems for example
23:21:24 <kmc> fynn, you will always see special purpose languages at the extremes
23:21:33 <kmc> for example, is Fortran still dominant in any other domain?
23:21:33 <dibblego> fynn, you are conflating "most practical" with "most popular"
23:21:58 <kmc> Haskell is poised to occupy a large niche, the one napping describes.  that is not the "C/Fortran/MPI" niche
23:22:01 <jmcarthur> fynn: it assumes that MPI etc. will always have more treatment than the (almost entirely agreeably?) far simpler functional ways of doing things
23:22:13 <kmc> this comment basically admits as much at the end
23:23:08 <jmcarthur> this is like arguing that manual garbage collection is always the best, in my opinion
23:23:15 <napping> that is, yes, you are probably not going to program Blue Waters in Haskell.
23:23:19 <fynn> kmc: so basically you're saying Haskell is relevant for multi-core (SMP) desktop tasks, while the MPI platforms may still be better for the upper echelons of multi-processor and multi-machine platforms.
23:23:27 <kmc> yes
23:23:37 <kmc> and down the line, i'd expect Haskell to compete on more "commodity" distributed-memory systems too
23:23:39 <kmc> not just SMP
23:23:48 <kmc> that's still years away, whereas good SMP performance is available today
23:24:08 <kmc> but again, if you are paying for the bleeding edge hardware, you will pay for the programmer time to do things the hard way
23:24:13 <fynn> how would that happen down the line?
23:24:14 <jmcarthur> i'd even expect an *eventual* bit of traction in supercomputing, assuming no better successor comes along
23:24:25 <kmc> fynn, by someone writing a distributed-memory Haskell implementation?
23:24:26 <napping> I think stuff like Fortress is probably more likely
23:24:35 <jmcarthur> but that's a bad assumption i think, on the kind of timeline this would require
23:24:38 <kmc> it's been done iirc, but not actively worked on
23:25:00 <jmcarthur> kmc: i think distributed haskell has been picking back up lately
23:25:08 <kmc> fynn, and "multi-core (SMP)" does not equal "desktop"
23:25:29 <fynn> kmc, jmcarthur: I guess we're sort of on the border. we're definitely not going to purchase an army of super computers, but we have some HPC tasks and would likely get a few powerful multi-processor servers to tackle them.
23:25:29 <kmc> you are missing a huge category between "desktop" and "world's fastest computer"
23:25:42 <fynn> kmc: yes, see above :)
23:25:45 <kmc> yeah
23:25:47 <napping> fynn: the modern story on parallism and functional programming is that it will make it easier to get programs right that use a few cores
23:26:16 <napping> like, more than one, and some cost in performance is acceptable. In the same way people claim e.g. Java is worth some performance overhead
23:26:24 <kmc> fynn, i'd argue that much of corporate IT spending on hardware goes into the niche you describe
23:26:46 <napping> You really mean numerical HPC stuff?
23:26:49 <kmc> beefy server machines (today, 8- or 16-core), but not "HPC" in the sense of NUMA, expensive interconnects, etc.
23:26:49 <BMeph> npping: Are you thinking about IXM, or is that just a happy association in my own mind? :)
23:27:08 <copumpkin> say I have an a -> IO [a] function, what's a nice way to compose them like kleisli composition for [], but taking the IO into account?
23:27:12 <fynn> napping: sure, I understand that: it's easier to parallelize in a language that _doesn't let you_ commit the sins that prevent parallelization, namely: sharing state.
23:27:21 <kmc> and loosely-coupled tasks that don't require true distributed memory
23:27:33 <jmcarthur> copumpkin: you mean like a -> (IO :. []) a ?
23:27:45 <fynn> kmc: how is that not included in the first? :)
23:27:45 <kmc> fynn, it's also easier to do concurrent programming with STM.  which Haskell has a nice implementation of, though it's far from the only such language
23:27:52 <copumpkin> jmcarthur: if :. is functor composition, yep
23:27:53 <kmc> first what?
23:28:00 <fynn> first assertion.
23:28:36 <Axman6> fynn: what are wondering about? little late to the party
23:28:37 * kmc has made a lot of assertions today
23:28:38 <fynn> basically, the fact that those tasks are uncoupled is because they don't share mutable state.
23:28:38 <napping> no, what's IXM?
23:28:52 <kmc> fynn, sorry, my "and" was coupled to my "beefy ..." comment
23:28:59 <fynn> ah, k.
23:29:09 <jmcarthur> copumpkin: i don't have an answer, but i would be looking at IO :. []. if you could define a monad out of that then you have a kleisli arrow for it :)
23:29:14 <kmc> it does indeed relate to what you described, lack of shared mutable state
23:29:27 <fynn> kmc: and sure, most of those servers are still SMP platforms.
23:30:08 <fynn> Axman6: talking about this comment: http://news.ycombinator.com/item?id=1004885
23:30:10 <napping> hmm, I think a distributed memory MPI environment is actually a bit less imperative
23:30:19 <jmcarthur> i'm not sure if it's possible to define a monad for that, actually
23:30:26 <kmc> basically, i'm saying that many important problems are most cost-effectively solved by scaling parallelism exactly to the number of cores in a good commodity server, and no further
23:30:27 <napping> I mean sure, messages are being sent around, but it's not like you are communicating by mutating shared memory
23:30:30 <jmcarthur> copumpkin: dangit, now you gave me a challenge
23:30:43 <kmc> parallelism in one process i mean
23:30:51 <BMeph> napping: IXM = "Illuminato X Machina" a self-proclaimed "open-source" hardware project looking into unconventional computer models.
23:30:55 <yrlnry> I keep writing "return op a  b" instead of "return (op a b)".  Very annoying, and unfortunately it typechecks okay.
23:31:04 <QtPlaty[HireMe]> Sets have elements, tpes have ???
23:31:13 <yrlnry> QtPlaty[HireMe]:  elements.
23:31:15 <kmc> QtPlaty[HireMe], "types"?
23:31:21 <kmc> elements.
23:31:22 <jmcarthur> values?
23:31:27 <kmc> or "members" or "values"
23:31:45 <copumpkin> jmcarthur: fmap concat . mapM f <=< f seems decent
23:31:46 <kmc> but strictly speaking "value" often denotes an expression in normal form, whereas any expression has a type
23:31:47 <BMeph> They're "rejecting both the Harvard and the Princeton (AKA Von Neumann) models of processors."
23:31:47 <QtPlaty[HireMe]> Thanks guys
23:33:42 <copumpkin> jmcarthur: but I
23:33:46 <copumpkin> 'm open to better suggestions :)
23:34:04 <jmcarthur> copumpkin: it seems to me that IO [a] would have the same problems as the "bad" ListT, no?
23:34:15 <copumpkin> what's bad about ListT?
23:34:17 <napping> good numerical performance is mostly about vectorization
23:34:30 <napping> maybe a bit of re-using space to save on cache load
23:34:56 <jmcarthur> copumpkin: well, i don't know about IO, but i know that generally there isn't a monad for m [a]
23:34:59 <napping> If anything, more data parallel than imperative
23:35:48 <copumpkin> jmcarthur: just thinking about a filesystem tree traversal case
23:35:56 <copumpkin> jmcarthur: you'll likely have a FilePath -> IO [FilePath]
23:36:03 <copumpkin> and you'd ideally like to traverse that naturally
23:36:12 <copumpkin> recursively
23:36:15 <napping> If you don't mind some backtracking can't you do that formally?
23:36:38 <napping> oh, getting out final results, hmm
23:36:59 <napping> data BTIO a = Result a | Work (IO [BTIO a])
23:37:31 <BMeph> napping: Check it out: http://www.liquidware.com/shop/show/IXM/Illuminato+X+Machina
23:38:23 <kmc> i don't understand the point of that
23:38:31 <kmc> each node has an absurdly powerful processor
23:38:42 <ezyang> Heap is not a functional datastructure, is it?
23:38:49 <kmc> it would make more sense if they had stupid but IO-rich controllers
23:39:19 <kmc> i don't know how much a 72 MHz ARM costs but it has to be a lot more than an ATTiny2313 and some shift registers
23:39:36 <napping> ezyang: depends what you mean by Heap. You can certainly give state passing semantics that use a pure functional data structure to represent the heap
23:39:58 <napping> kmc: with that size of block you need an "absurdly powerful" processor to get reasonable performance density
23:40:25 <kmc> napping, depends on the task.  depends what you want to use those IO pins for
23:40:38 <ezyang> napping: I'm building an example of simple backtracking search, and there's a simple meta-heuristic I can use if I'm searching a tree with the heap property
23:40:54 <ezyang> I'm just wondering if pure FPers will wrinkle their nose at something like this as impractical
23:40:59 <napping> I mean to get at all similar performance per volume or whatever to your standard beige box
23:41:05 <kmc> napping, is that what they're going for?
23:41:14 <kmc> if so, they will never achive it
23:41:20 <kmc> die integration >> board integration
23:41:27 <kmc> it seems like they're going for the Arduino crowd
23:41:43 <napping> sounds like they might have grander ambitions
23:41:49 <kmc> and most Arduino projects are absurdly underutilizing a single ATMega328
23:41:51 <napping> not that I'd heard about it before now
23:42:10 <kmc> like you read a single I/O pin at 100 Hz so you can send the world a twitter message when your cat takes a shit
23:43:27 * copumpkin enjoys writing n-ary typesafe functions in haskell
23:43:31 <copumpkin> or in agda actuall
23:44:52 <BMeph> kmc: Seems like the same crowd that builds Coke-can retrievers out of HD motors... ;)
23:45:03 <kmc> dunno that project
23:45:29 <kmc> the twittering cat shitter is my distillation of 1/3 of the projects on hackaday
23:45:48 <napping> hey, you need some CPU to run the twitter client
23:46:56 <kmc> napping, usually the networking is handled either by a computer or by a network interface board that's even more powerful than the ATMega
23:47:05 <napping> that's no fun
23:47:23 <kmc> anyway i do not think it's a terrible waste to use a $4 microcontroller in place of a $2 one for a production run of one.
23:48:02 <ezyang> hpaste is still broken
23:48:34 <ezyang> Would people mind nitpicking this code sample: http://pastebin.com/m57de3cb1 ?
23:48:42 <napping> manycore ARM would be an interesting target platform
23:49:36 <kmc> ezyang, why does search' return a list?
23:49:36 <napping> like this: http://www.eecs.berkeley.edu/~lmeyerov/projects/pbrowser/
23:50:10 <ezyang> kmc: Hmm, I guess the example I crafted doesn't need a list as output. Darn.
23:52:24 <ezyang> I guess... if I make it return paths to the results, I can force the need for a list.
23:52:29 <ezyang> I wonder if there's a better example.
23:53:27 <yrlnry> Is there a syntax for writing a rational number?
23:53:46 <kmc> > 2 % 3
23:53:47 <lambdabot>   2 % 3
23:53:55 <kmc> yrlnry, (%) is a function that builds rationals
23:54:02 <kmc> unfortunately, not an actual constructor -- you can't pattern-match on it
23:54:06 <kmc> > 4 % 8
23:54:07 <lambdabot>   1 % 2
23:54:16 <yrlnry> That's what I thought, but my ghci is saying "not in scope".
23:54:26 <yrlnry> Is it provided by some nonprelude library?
23:54:29 <kmc> import Data.Ratio
23:54:32 <yrlnry> Thanks.
23:54:41 <kmc> @hoogle (%)
23:54:41 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
23:56:55 <yrlnry> I'm pleased because I just finished the first monad class that I ever thought up on my own.
23:57:10 <yrlnry> Discrete probability distributions form a monad.
23:57:34 <yrlnry> return x is the monad value that says that event x occurs with probability 1.
23:58:08 <yrlnry> Come to think of it ,continuous distributions would form a monad too, but my representation doesn't support that.
23:58:26 <kmc> there's a quantum mechanics arrow on Hackage :D
23:59:29 <yrlnry> neat.  I wonder if it is in any way related.
23:59:47 <yrlnry> google search for "probability distribution" monad turns up a paper of Norman Ramsey from 2002.
