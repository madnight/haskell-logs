01:17:14 <HaskellLove> is it possible somehow to use a unary function with the fold functions family?
01:17:31 <HaskellLove> from my limited knowledge it seems you can do it only with binary
01:17:54 <ivanm> exactly
01:17:55 <copumpkin> binary or more :)
01:17:56 <ivanm> @type fold
01:17:57 <lambdabot> Not in scope: `fold'
01:17:57 <Cale> HaskellLove: Well... the type says that the function you pass must have at least two
01:18:02 <Cale> :t foldr
01:18:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:18:05 <copumpkin> HaskellLove: what would you fold with it?
01:18:14 <ivanm> copumpkin: a ternary function is a binary function that takes a binary function ;-)
01:18:24 <Cale> But there are cases where you might ignore one parameter
01:18:26 <copumpkin> HaskellLove: or rather, how would you express the fact that a fold has an accumulator and needs access to the elements?
01:18:28 <ivanm> sounds like you want iterate...
01:18:36 <Cale> > foldr (const (+1)) 0 [1..10]
01:18:37 <lambdabot>   10
01:19:03 <Cale> ivanm: err...
01:19:23 <ivanm> for which comment? ;-)
01:19:38 <Cale> <ivanm> copumpkin: a ternary function is a binary function that takes a binary function ;-)
01:19:47 <HaskellLove> exactly, cant do it... gota have a binary or more as you said
01:19:50 * copumpkin shrugged it off as being a down-under thing
01:19:50 <ivanm> isn't a -> b -> d -> e == a -> (b -> d) -> e ? ;-)
01:19:55 <ivanm> oh, wait, no...
01:19:56 <Cale> no
01:19:58 * ivanm facepalms
01:20:01 <ivanm> copumpkin: heh
01:20:04 <copumpkin> weird aussies
01:20:25 <ivanm> Cale: whilst your here... with the type family stuff for classes, is there any way of specifying a map-like function with them?
01:20:57 <Cale> For type-level lists?
01:21:20 <ivanm> no
01:22:11 <ivanm> so if in class Foo a where you have a type Bar a, is there any way to define a mapping function (i.e. change the type of Bar)?
01:22:31 <ivanm> trying to work out how to add the ability to apply a map to the node/arc labels for graphs
01:23:04 <copumpkin> so class Foo a where type Bar a :: *, what are you trying to map to and from?
01:23:08 <Cale> barMap :: (a -> b) -> Bar a -> Bar b?
01:23:16 <Cale> I don't understand
01:24:30 <ivanm> OK, in the graph class stuff, we defined a class VertexLabelled with "type VLabel g"; how can we let the user change the type of (VLabel g) (e.g. map show to all the vertex labels)?
01:26:17 <copumpkin> it might be hard, especially with type families as opposed to data families
01:26:23 <Ytinasni> so you want to map a `Graph label_type_a` to a `Graph label_type_b` ?
01:26:28 <Ytinasni> that sounds like fmap.
01:27:47 <ivanm> yes
01:28:03 <ivanm> but I'm going to be having a double layer one (node and arc labels)
01:28:07 <ivanm> copumpkin: :(
01:28:27 <copumpkin> ivanm: I'm not sure type families are the best choice here, at least not in that form. If you want to map say vertex labels of Int to String (with show), it's going to know that Int ~ VLabel SomeType, but it's not going to be able to map backwards from String to VLabel (?) because two different VLabel parameters could map to String
01:28:38 <ivanm> yeah :(
01:29:00 <ivanm> (well, I did this stuff with type families when working on it with Cale, since he seems obsessed with them :p )
01:29:08 <copumpkin> sign my "Closed type families and classes now!" petition though
01:29:42 <copumpkin> maybe I should rephrase it as traditional closed families! do not destroy the sanctity of injectivity!
01:29:48 <ivanm> what do you mean by "closed type families" ?
01:29:56 <copumpkin> bijectivity, I guess
01:33:47 <drhodes> what's it called when this happens (f (g (h x))) --> (f (h (g x)))
01:33:56 <copumpkin> ivanm: well the problem with a lot of those reverse mappings with type families is that you might know that VLabel ZomgType ~ String, and that no other VLabel parameters generate String. But someone else might come along later and write type instance VLabel Bool = String and mess things up. If you could tell the compiler to prevent anyone outside a certain scope from defining new instances, then the compiler could just search the instances for the reve
01:33:57 <copumpkin> mapping
01:34:14 <copumpkin> drhodes: nothing in particular?
01:34:15 <ivanm> nope, that's not a problem for me
01:34:26 <ivanm> (it was for another case though)
01:34:39 <ivanm> looks a bit like a flip...
01:34:51 <ivanm> but the ability to do that and still have equality is commutivity
01:36:02 <Jafet> @pl (\f g h x -> f (h (g x)))
01:36:02 <lambdabot> (. flip (.)) . (.) . (.)
01:37:16 <copumpkin> omg it's HaskellLove!
01:37:39 <HaskellLove> copumpkin hell yeah :D
01:39:35 <medfly> hi
01:42:49 * ivanm thinks it might be easier to scrap the double type-family based classes and just have an overall on for those of kind * -> * -> *
01:44:43 <copumpkin> ivanm: what was your goal with the type families?
01:45:11 <ivanm> copumpkin: to indicate the label types
01:45:30 <copumpkin> did you want a different underlying representation for each label type?
01:45:36 <ivanm> this way, I could also allow graphs that have node labels but not edge labels
01:45:46 <ivanm> copumpkin: that was the original goal, yes
01:45:51 <ivanm> but IMHO mapping is more important
01:49:25 <copumpkin> hm, yeah
01:51:34 <atcq> are alex/happy really not popular in the haskell world or would they just not show up in dependency lists on hackage? I haven't been able to find a single package that depends on either alex or happy
01:51:58 <copumpkin> atcq: they're apps
01:52:17 <copumpkin> dependency lists typically show dependencies that are libraries
01:52:58 <atcq> copumpkin: so alex/happy wouldn't be listed in hackage's dependency lists even though it's used in the program?
01:53:15 <copumpkin> well, what are you using for dependencies?
01:53:22 <copumpkin> @hackage language-c
01:53:23 <lambdabot> http://hackage.haskell.org/package/language-c
01:53:42 <kmc> atcq, a lot of people prefer parser combinator libraries to parser generators
01:53:49 <copumpkin>     Build-Tools:    happy, alex
01:54:30 <copumpkin> @hackage haskell-src-exts
01:54:30 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
01:54:56 <copumpkin>   Build-Tools:          happy >= 1.17
01:55:31 <atcq> ah, thanks copumpkin
01:56:01 <atcq> kmc: right, I just have a yacc grammer I want to port to happy
02:05:18 <paolino> has Data.Array.Diff died from 6.12.1 ?
02:05:32 <ivanm> yes
02:05:41 <ivanm> seperate library now IIRC
02:16:10 <zong_sharo> data SomeShow = forall s . Show s => SomeShow s
02:16:18 <zong_sharo> execWriter $ tell [SomeShow "", SomeShow ()] -- good
02:16:28 <zong_sharo> execWriter $ tell [SomeShow ""] >> [SomeShow ()] -- type error
02:16:29 <zong_sharo> why?
02:18:44 <zong_sharo> execWriter $ (tell [SomeShow ""] >>) (tell [SomeShow ()]) -- good too
02:19:13 <ski>   execWriter $ tell [SomeShow ""] >> tell [SomeShow ()]  -- ok, as well, i think
02:20:11 <zong_sharo> lol
02:20:35 <mustafa> Hi, I have a function next :: a -> IO a and want to build the list containing the results of its repeated applications
02:21:20 <ski> how many times ?
02:21:28 <mustafa> the infinite list
02:21:39 <zong_sharo> io is eager
02:21:49 <ski> then you get a non-terminating `IO'-action
02:21:50 <zong_sharo> this is will blow all your memory
02:22:05 <zong_sharo> unless it's event loop or something
02:22:06 <ski> you could (a) start a thread that populates an output list
02:22:12 <mustafa> is there no way around it? maybe, a type IO [IO a] or something
02:22:12 <ski> (b) use `unsafeInterLeaveIO'
02:22:33 <ski> (possibly (a) will use (b))
02:23:48 <mustafa> ok, thanks
02:23:51 <mustafa> this makes sense
02:25:36 <ski> (i suppose another variant is to propagate how many elements you actually want, so you can run it that many times .. but that may not apply or be cumbersome ..)
02:31:17 <augur> so haskelliers
02:31:25 <augur> professionals, at least
02:31:56 <augur> explain to me in what way the type-class dependent definitions of methods are not actually type-relativizied multiple definitions of functions
02:34:43 * ski stares blankly
02:34:45 <Jafet> Bingo! I win.
02:34:51 <augur> wat
02:35:00 * ski looks confused
02:35:07 <ski> augur : by "type-class dependent definitions of methods" do you mean "values depending on type-class constraints" ?
02:35:26 <augur> i mean things like >>= defined relative to a particular monad, say
02:35:32 <augur> or fmap defined relative to a particular functor
02:35:33 <augur> etc
02:35:46 <ski> also including, say, `mapM' ?
02:36:25 <augur> how are these different than, for instance, just doing normal function definition, where you just have differently typed versions of the function?
02:37:54 <augur> e.g. could you just do some random definition of a function twice, but with different type sigs, and if not, is it only because its not associated with a type class, or does being part of a type class introduce something genuinely different into the nature of the defined method in such a fashion that it doesnt warrant saying that you have multiple functions associated with the same name?
02:39:39 <ski> you can't define a function under the same name twice (unless they're in different modules, in which case they don't really have the same (qualified) name)
02:40:12 <augur> so what precisely is going on in type classes where you _do_ have what appear to be different definitions
02:40:22 <ski> type classes allow overloading
02:40:25 <Jafet> Perhaps you want the word "polymorphism"
02:40:48 <augur> jafet, thanks for the insight. i know this.
02:41:00 <augur> my question is what the nature of the overloading is
02:41:09 <augur> if not multiple definitions of a function under the same name
02:41:15 <augur> relativized to type
02:41:32 <Ytinasni> augur: is your question about how it's implemented, or about type-thoery, or what?
02:42:04 <copumpkin> augur, I think the difference is that typeclass methods are all refinements of some general type with something (behavior-wise) in common
02:42:21 <augur> Ytinasni: haskell-theory.
02:42:28 <augur> yes, you ahve type classes, right
02:42:46 <copumpkin> f :: Int -> Bool -> Float and f :: () -> Float are not refinements of a very interesting type
02:42:50 <augur> but either these methods are different functions bound to the same name
02:42:59 <augur> and theyre distinguished by the types
02:43:03 <augur> or theyre something else
02:44:34 <ski> `(>>=)' is a single function, that is overloaded on the actual type being an instance of `Monad'
02:45:36 <augur> and in what sense is that meaningfully different from saying there are multiple type-relativized functions aassociated with the name '>>='?
02:46:07 <copumpkin> type-relativized?
02:46:09 <Jafet> The difference is that one is correct and the other is meaningless
02:46:33 <augur> copumpkin: yes, "overloaded on the actual type being"
02:46:41 <augur> jafet: well which one is meaningless! :P
02:46:51 <augur> because i know precisely what i mean by mine
02:47:01 <augur> and its pretty fucking obviously meaningful.
02:47:33 <copumpkin> augur: you're clearly having trouble getting your meaning across to us
02:47:34 <b_jonas> the point is that as these functions like (>>=) actually have a single type (with a class restriction in it), you can use it to define another function that has the same class binding so it's decided only later what type that function is called for
02:47:49 <augur> i understand that they have a single type
02:48:08 <augur> but when you call >>= on a list, different stuff happens than when you call it on an IO
02:48:32 <Jafet> The same polymorphic function does something different to lists and to IOs.
02:48:33 <copumpkin> augur: that satisfies the same laws and follows a type pattern
02:48:42 <augur> are type classes just big old fancy sugar for a gigantic pattern matching thing
02:48:46 <b_jonas> yes, but note that the type of the function decides exactly how it can be polymorphic
02:49:12 <augur> where the definition of >>= is really with constructors hidden in there
02:49:14 <copumpkin> augur: in the end you can reduce anything to anything else, but I don't think the comparison you're drawing (or appear to be drawing) is particularly fruitful
02:49:37 <augur> or is there some magic internals stuff
02:49:40 <augur> that is
02:49:51 <copumpkin> it just passes an additional value for each typeclass constraint
02:49:56 <copumpkin> at runtime
02:50:09 <Jafet> Are you still asking about "haskell-theory", or are we on ghc now
02:50:12 <augur> if i wanted to define >>= for something, could i do it without a typeclass definition and so forth
02:50:24 <augur> or do i have to use typeclasses
02:50:38 <copumpkin> augur: you could approximate it in other ways, but you'd have to be more explicit
02:50:47 <augur> ok let me rephrase
02:50:56 <augur> could i do the following (or something approximating it):
02:51:21 <copumpkin> augur: typeclasses are method dictionaries + automatic compile-time instance lookup + sugar saving you from passing the dictionaries around explicitly
02:51:38 <augur> (>>=) :: Foo a -> (a -> Bar b) -> Bar b
02:51:39 <copumpkin> another implementation could implement it by actually specializing each function
02:51:49 <augur> (>>=) = \x -> ...
02:51:52 <augur> and have that work
02:52:10 <b_jonas> copumpkin: it sounds so simple when you say it like that, but actually the specializing everything wouldn't work
02:52:12 <ski> augur : actually, the usual implementation doesn't pattern-match on the type at all, instead the proper method is selected from a dictionary that is invisibly passed
02:52:47 <augur> well i dont care about the implementation :P
02:52:52 <augur> im talking about Haskell specs
02:52:53 <b_jonas> augur: only if you have them in different scope from the other (>>=) in which case it's completely determined in compile time by syntax which reference to (>>=) refers to which
02:52:56 <augur> what makes type classes different.
02:53:00 <b_jonas> augur: they just accidentally have the same name
02:53:01 <ski> augur : no, that could not work (with the current type signature of `(>>=)')
02:53:03 <augur> are they just sugar, or are they not.
02:53:04 <ski> @type (>>=)
02:53:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:53:10 <adu> method dictionaries?
02:53:12 <Ytinasni> augur: i think you mean "Foo a -> (a -> Foo b) -> Foo b"
02:53:20 <augur> isnt that what i typed
02:53:25 <augur> oh no sorry
02:53:27 <augur> right yes
02:53:44 <b_jonas> augur: typeclasses are made different in that you can have a function that's also parametric (so it accepts any Monad) and uses >>= which can then refer to the >>= method of any monad
02:54:05 <augur> uh
02:54:14 <b_jonas> copumpkin: in fact I think I don't even understand the dictionary passing implementation, but I'm also not sure I want to
02:54:17 <augur> the function is parametric in what way
02:54:27 <b_jonas> like
02:54:41 <adu> b_jonas: I think they mean instead of defining it in a typeclass, defining it in a data declaration
02:54:41 <ski> @src sequence
02:54:42 <lambdabot> sequence []     = return []
02:54:42 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:54:42 <lambdabot> --OR
02:54:42 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:54:48 <ski> @type sequence
02:54:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:54:52 <Jafet> You could say the function implicitly takes the type of the argument as a "parameter"
02:54:58 <b_jonas> yesh, what ski says
02:55:07 <augur> adu its not even about defining it in a data declaration, its just
02:55:19 <augur> can i define a version of >>= outside of a typeclass like i can define any other function i want
02:55:26 <b_jonas> thoguh it's ugly because it's using the do notation there
02:55:30 <ski> `sequence' calls `(>>=)' (which the `do' sugar expands to), but it's not decided yet what implementation for `(>>=)' will be used
02:55:42 <adu> augur: but then you'd have to import qualified
02:55:47 <augur> what
02:55:57 <adu> like MyMod.>>=
02:55:58 <Jafet> > let a >>= b = a+b in 1>>=2
02:55:59 <lambdabot>   3
02:56:06 <augur> ski: whether or not the version of >>= is decided already is irrelevant.
02:56:33 <augur> adu: what do you mean "like MyMod.>>="?
02:56:36 <ski> augur : you can define a new function called `(>>=)' in a local scope (or if you hide the import of the standard `(>>=)') .. but it won't be the "same" function then
02:57:08 <ski> augur : i mentioned the part about deciding, because overloading in many other languages doesn't work like that
02:57:13 <augur> ok, so then >>= when defined in a type class really IS a distinct thing from the >>= defined in some OTHER type class
02:57:24 <adu> augur: in order to use two monads in the same source, and they both had methods named exactly (>>=) with different types, the only way would be to import qualified each file
02:57:32 <b_jonas> augur: no
02:57:36 <augur> no?
02:57:37 <b_jonas> that's the point
02:57:41 <augur> either it is or it isnt
02:57:41 <Jafet> Type classes don't (need to) define functions
02:57:52 <b_jonas> oh wait
02:57:58 <augur> adu, i dont care about monads, im just talking about functions
02:58:03 <b_jonas> maybe yes
02:58:09 <augur> >>= is just a convenient example since its so very necessary to haskell
02:58:14 <augur> and its three characters.
02:58:14 <b_jonas> maybe I misunderstood your question
02:58:20 <augur> i mean, fuck guys cmon
02:58:20 <b_jonas> + is one character
02:58:24 <augur> its not a complex example
02:58:28 <augur> question, rather
02:58:30 <Jafet> augur, you really need to be more concrete
02:58:34 <Jafet> Try giving code.
02:58:38 <augur> aint no more concrete than this, jafet
02:58:49 <augur> how many lambdas are there.
02:59:02 <augur> one, or as many as there are type classes with that method defined
02:59:09 <Jafet> I give up for now. O happy day.
02:59:15 <b_jonas> what lambdas?
02:59:18 <augur> :|
02:59:21 <augur> right.
02:59:24 <augur> what lambdas.
02:59:28 <ski> type class methods are unrelated to lambdas
02:59:36 <augur> uh?
02:59:38 <ski> you can make a type class like
02:59:47 <adu> augur: if you define (>>=) somewhere else, then in order to use it anywhere that imports the standard Prelude, you will have to "import qualified" the file in which your (>>=) function is defined.
02:59:49 <ski>   class Countable a
02:59:50 <ski>     where
02:59:57 <ski>     inhabitants :: [a]
03:00:02 <ski> see, no function in there
03:00:15 <augur> er
03:00:29 <b_jonas> the complication is that methods have to be package-global, you can't have a method (or instance etc) in local scope
03:00:32 <ski> `inhabitants' is a method of the class `Countable', but it is not a function
03:00:39 <augur> ok let me rephrase it skit
03:00:40 <augur> ski
03:00:46 <augur> when you have methods that are FUNCTIONS
03:00:56 <augur> as opposed to what the rest of the universe calls instance properties
03:01:04 <augur> how many lambdas are there
03:01:23 <ski> i'm really don't know what you're asking about
03:01:26 <Jafet> Well, the overloading principle is also unrelated to functions. You can overload inhabitants happily the same way for each instance.
03:01:28 <augur> SKI
03:01:28 <ski> s/i'm/i/
03:01:32 <augur> >>= IS A FUNCTION RIGHT?
03:01:36 <ski> yes
03:01:38 <Jafet> s`k`i``
03:01:39 <adu> augur: you sound confused
03:01:45 <Ytinasni> augur: the rest of the world wouldn't call that an instance property.
03:01:49 <ski> it can be defined with lambda, and it can be defined without lambda
03:02:00 <augur> well ok maybe its a function of 0 arguments to the rest of the world
03:02:05 <augur> it would obviously depend, Ytinasni
03:02:15 <Jafet> augur, you can rephrase as many fucking times as you want, if you insist on using language people don't understand no one will want to talk to you
03:02:17 <ski> maybe when you say "lambda" you actually mean "function value" ?
03:02:18 <augur> ski, im not talking about whether you define it using \x -> ...
03:02:19 <tredontho> Ytinasni: he's talking about the universe, though
03:02:29 <augur> afaik f x = ... is just sugar for f = \x -> ... anyway
03:02:33 <augur> so all functions are lambdas
03:02:36 <augur> so answer the question
03:02:43 <ski> augur : ok, sorry then. i call the `\' a "lambda"
03:02:58 <ski> so, since
03:03:02 <ski> @type (>>=)
03:03:03 <adu> value = function of 0 variables = lambda with no arguments = bla bla bla
03:03:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:03:15 <augur> jesus christ
03:03:17 <ski> has only two "main" `->' symbols
03:03:27 <ski> there is only two "lambda"s involved
03:03:29 <ski> satsified ?
03:03:48 <ski> (note that this have nothing to do with actual implementation, as you requested)
03:03:52 <augur> ski, what
03:04:03 <adu> augur: yes, functions are lambdas, basically
03:04:24 <augur> ok let me try to rephrase again
03:04:29 <Jafet> Lambda is a greek letter.
03:04:29 <b_jonas> augur: nah, they're not
03:04:33 <adu> augur: one possible difference is that functions can have names (at least in my world), but lambdas do not
03:04:34 <augur> >>= may be m a -> (a -> m b) -> m b
03:04:37 <b_jonas> they can be lambdas with some values locally bound
03:04:44 <augur> but its not two lambdas
03:04:46 <augur> its one
03:04:47 <b_jonas> or even builtin or external functions
03:05:01 <tredontho> currying?
03:05:05 <augur> its return value is a lambda, but its return value is not >>=
03:05:08 <augur> its the return value of >>=
03:05:22 <ski> instance Monad Maybe where (>>=) = \m -> \f -> case m of Nothing -> Nothing; Just a -> f a
03:05:24 <adu> augur: when mapped to a language without curring it is one lambda, but in Haskell, it is two lambdas
03:05:29 <augur> adu
03:05:29 <augur> no
03:05:33 <augur> its not two lambdas
03:05:38 <augur> its one lambda, which returns a lambda
03:05:49 <adu> augur: oh, tricky, yes
03:06:02 <augur> hence why if you did ([1] >>=) == (>>=) you'd get false
03:06:10 <augur> because, obviously, its not its return value
03:06:16 <ski> augur : "its one lambda, which returns a lambda" <- that's two "lambda"s, yes
03:06:19 <augur> thats where the second lambda comes in
03:06:21 <Jafet> No, you'd get a type error.
03:06:26 <Ytinasni> augur: they have different types. they're obviously distinct.
03:06:27 <augur> well that too :P
03:06:43 <augur> Ytinasni: I KNOW
03:06:45 <augur> i know that theyre distinct
03:06:56 <augur> but apparently i have to explain this to ski
03:07:05 <ski> (note : you can't compare values with different types with `(==)')
03:07:07 <adu> ski: are you confused?
03:07:13 <b_jonas> whether they're different lambdas (that is whether they have a different head) only makes sense to ask once you've determined the exact type
03:07:19 <augur> listen
03:07:23 <augur> forget we're talking about bind ok
03:07:24 <augur> +
03:07:28 <augur> no fuck that
03:07:29 <ski> adu : i'm confused about what augur is actually wanting to know, yes
03:07:31 <augur> + is just as bad
03:07:33 <augur> negate
03:07:37 <ski> ok
03:07:40 <augur> negate is unambiguously a -> b
03:07:52 <Jafet> Not a -> a?
03:07:53 <augur> and a and b are both values not functions
03:07:59 <adu> augur: I think its a -> a
03:08:00 <augur> well maybe! i never said a != b
03:08:01 <kmc> functions are values
03:08:01 <augur> :P
03:08:06 <augur> kmc hush :|
03:08:16 <Ytinasni> augur: no. it's a->a, always.
03:08:16 <kmc> and "lambda" is just the name for a particular literal syntax for writing functions
03:08:26 <ski> @type negate
03:08:28 <lambdabot> forall a. (Num a) => a -> a
03:08:40 <augur> oh for fucks sake stop being autistic
03:08:43 <augur> jesus christ
03:08:49 * Jafet passes the "lambda is a greek letter" hat to kmc
03:08:49 <augur> moving on to the actual fucking question
03:08:52 <adu> no swearing
03:08:53 <kmc> something here is being very contentiously argued about
03:08:54 <tredontho> autistic == pedantic?
03:09:15 <kmc> i thought the reason we use programming languages is to be precise about what we mean
03:09:23 <augur> tredontho: autistic = incapable of understanding what people intended when they type something thats slightly different
03:09:28 <kmc> okay so pedantry aside, what is the issue here
03:09:32 <Jafet> The real reason is so we can have flame wars
03:09:38 <adu> YEY
03:09:47 <augur> how many functions are involved when negate is defined relative to multiple type classes
03:09:49 <kmc> 'cause i read the scrollback and there seems to be a lot of uncorrelated noise
03:09:53 <adu> augur: so ask your question already
03:10:13 <Jafet> Uh, negate is only defined as a method of Num.
03:10:15 <kmc> @hoogle negate
03:10:16 <lambdabot> Prelude negate :: Num a => a -> a
03:10:16 <tredontho> like, negate for Double, negate for Int vs. negate for all Num?
03:10:18 <augur> one function, with a bunch of pattern matching giggery inside its single anonymous function definition
03:10:23 <ski> augur : depends on what you mean. `negate' is a single (overloaded) function. yet it has (possibly) several implementations
03:10:23 <augur> JAFET FOR FUCKS SAKE I SAID IF
03:10:25 <kmc> augur, no
03:10:29 <Jafet> You didn't say if, moron.
03:10:34 <kmc> wait everyone stop yelling and shut the fuck up
03:10:35 <augur> ok i said when
03:10:50 <Jafet> And use capslock, it's faster
03:11:00 <kmc> augur, are you asking about how typeclasses are implemented in GHC?
03:11:03 <ski> there is no pattern-matching going on to resolve overloading
03:11:05 <augur> no, kmc
03:11:05 <kmc> or something more conceptual?
03:11:28 <kmc> augur, what ski just said is important and as a bonus does not contain the word "fuck"
03:11:35 <kmc> overloading is not resolved by pattern matching
03:11:40 <kmc> because that would be a pattern match on a type, not a value
03:11:57 <adu> augur: what was your question?
03:11:58 <augur> ok thats fine
03:11:59 <mulletro1> has anyone tried to use the FFI in hs-plugins?
03:12:12 <augur> no pattern matching on types, yes, whatever
03:12:15 <kmc> augur, if you're not talking about the implementation of typeclasses, then you're taking them as a language feature.  in that case, think of a distinct negateInt, negateDouble, negateFloat
03:12:19 <kmc> each one handles only one type
03:12:23 <b_jonas> kmc: no, worse ,it would be pattern matching on a hidden parameter
03:12:30 <kmc> and it magically chooses the right one, even when the type is not known until runtime
03:12:37 <mulletro1> I just get a parse error, even when passing -XForeignFunctionInterface
03:12:38 <augur> yes
03:12:39 <kmc> the "magically" part is the implementation detail we're ignoring
03:12:47 <augur> so then there are as many actual functions as there are type classes
03:12:54 <kmc> sure
03:13:03 <kmc> same for non-function members of the classes
03:13:04 <copumpkin> as many as there are methods in typeclasses and instances
03:13:05 <augur> so that the function name has multiple values
03:13:05 <ski> there are that many implementations of `negate', yes
03:13:12 <b_jonas> I don't understand the implementation
03:13:15 <kmc> augur, sort of
03:13:16 <adu> augur: yes, Int defines negate = negateInt, Double defines negate = negateDouble, etc...
03:13:17 <augur> each of which is relative to the types of the arguments in question
03:13:21 <copumpkin> a typeclass can even be empty!
03:13:22 <ski> `negate' has a single, overloaded, value
03:13:36 <ski> (it can be passed around at run-time)
03:13:38 <b_jonas> copumpkin: empty as in no types or no methods?
03:13:40 <augur> ski, are you kidding me?
03:13:44 <copumpkin> b_jonas: no methods
03:13:54 <ski> augur : no
03:13:57 <adu> its not overloaded, it can totally handle it :)
03:13:59 <augur> are you going to repeat back to me the very word that im asking about as an explanation of the word?
03:14:02 <kmc> augur, i think you are asking questions that are not answerable without choosing an implementation of typeclasses
03:14:07 <kmc> augur, why the hostility?
03:14:13 <Jafet> <augur> ski, are you kidding me?  ->  brilliant, why I keep logs
03:14:20 <b_jonas> copumpkin: is that ever useful?
03:14:21 <copumpkin> augur: calm down. You're only going to make someone call the ops on you.
03:14:35 <kmc> augur, i'm happy to explain how GHC implements typeclasses.  it's not very complicated
03:14:37 <copumpkin> b_jonas: I like the idea, but I'm in a minority
03:14:42 <augur> i dont care about GHC
03:14:42 <Ytinasni> kmc: because noones helping him, and he can't admit he's asking an unanswerable question.
03:14:49 <augur> i care about the SPEC.
03:14:55 <copumpkin> then fucking read it
03:15:06 <copumpkin> @where report
03:15:06 <lambdabot> http://www.haskell.org/onlinereport/
03:15:11 <augur> well i wouldve if i knew you lot would be denser than lead
03:15:18 <ski> > let use_it :: (forall a. Num a => a -> a) -> (Integer,Double); use_it f = (f 42,f pi) in use_it negate  -- passing around the single `negate' value at run-time
03:15:19 <b_jonas> copumpkin: is that related to those compile-time computaton stuff that does magic with fundeps?
03:15:19 <lambdabot>   (-42,-3.141592653589793)
03:15:22 <augur> its a pretty damn simple question, ive rephrased it a million different ways
03:15:23 <kmc> augur, if you care what's in the spec, then you should not object to: <ski> `negate' has a single, overloaded, value
03:15:23 <ray> b_jonas: of course it's useful
03:15:24 <ski> augur : i was not kidding you
03:15:28 <kmc> because as far as the spec says, that is the final word
03:15:32 <adu> augur: i'm not dense, i'm nice
03:15:37 <augur> and i think the answer according to kmc and adu is that yes
03:15:37 <b_jonas> augur: just look at how some class and instance definitions work
03:15:41 <augur> there are multiple actual functions
03:15:43 <b_jonas> augur: seriously
03:15:45 <copumpkin> augur: clearly we're just being dense to piss you off. Surely it's impossible that you just can't get your meaning across.
03:15:53 <augur> and which is used depends on the runtime-discovered types of the arguments.
03:15:55 <kmc> you have to understand that the spec can postulate the existence of things and you pretty much have to accept it
03:15:57 <ski> (Ytinasni : i'm trying to help him/her)
03:15:58 <Ytinasni> augur: there could be. depends on the compiler.
03:15:59 <ray> b_jonas: there are conceptual distinctions that can't be expressed as methods
03:16:02 <kmc> rather than coming to irc and claiming people are shitting you
03:16:14 <augur> Ytinasni: ok well then tell me what its like INDEPENDENT of the compiler
03:16:21 <ray> i mean how do you distinguish between a group and abelian group class
03:16:35 <voker57> How can i make all instances of some typeclass instances of my own typeclass? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15054 doesn't work
03:16:40 <augur> Ytinasni: or let me rephrase it in what must surely be the only other way of asking that question
03:16:40 <kmc> augur, indeed there are multiple copies of typeclass members that *aren't* functions
03:16:42 <kmc> consider:
03:16:44 <kmc> > maxBound :: Int
03:16:46 <lambdabot>   9223372036854775807
03:16:46 <kmc> > maxBound :: Char
03:16:47 <lambdabot>   '\1114111'
03:16:51 <augur> Ytinasni: if some compilers do it that way, what do OTHER compilers do.
03:16:56 <augur> or what COULD other compilers do
03:16:56 <adu> augur: compile-time
03:17:01 <copumpkin> augur: hey here's an idea. If we're being dense and pissing you off, now that you know that we are dense, why don't you just stop talking and read the report? if you have any more questions after reading it (it really isn't that long) then you'll know the terminology we understand and you'll be able to ask more comprehensible questions.
03:17:03 <b_jonas> ray: is that like the "concepts" thing they planned for c++ but didn't get in for lack of time? or something better?
03:17:06 <dibblego> voker57, put (Integral a) => on the class definition
03:17:11 <augur> copumpkin: im a masochist.
03:17:14 <ray> i don't know, c++ is a clusterfuck
03:17:22 <augur> adu: and what besides runtime and compile time.
03:17:27 <copumpkin> augur: it's bordering on troll, so I really urge you to try that
03:17:27 <ray> all i know is that typeclasses with no methods can be useful
03:17:36 <b_jonas> okay, maybe they can be useful
03:17:47 <adu> augur: actually, now that I think about it, it really does depend on the compiler
03:18:02 <kmc> usually even very confused people will not in good faith display this combination of a) hostility, b) persistence, c) inability to communicate
03:18:07 <voker57> dibblego: and if I need more than one typeclass? (or do not want to modify class definition in sources?)
03:18:16 <augur> adu: ok fine, list for me some wide range of options that are hypothetically available, and abstract away the commonalities as well.
03:18:35 <dibblego> voker57, you can do things like wrap a value with newtype
03:18:49 <augur> kmc: i want an answer, which is the only reason im this persistent. :P
03:18:50 <dibblego> voker57, but really, those type-class constraints go on functions and other type-classes
03:18:53 <adu> augur: I read the report for 10 years before I had the terminology to ask really good questions in #haskell :)
03:18:59 <ray> b_jonas: and then when you're writing tests, you only test commutativity for abelian groups
03:19:06 <augur> also, my ability to communicate is fine. people just keep contradicting themselves.
03:19:28 <ray> but since that's over values it can't be a method
03:19:32 <b_jonas> ray: how could you write a test without choosing particular types?
03:19:35 <adu> yes they do
03:19:35 <adu> no they don't
03:19:46 <augur> adu, please, answer the question
03:20:07 <augur> in what ways can compilers differ on this made besides compiletime and runtime, and in what ways are they all similar
03:20:24 <kmc> @faq Can Haskell implement the type-class dependent definitions of methods as actually type-relativizied multiple definitions of functions?
03:20:24 <ski> augur : other compilers could detect statically (i.e. at compile-time) whenever any value of type `forall a. Num a => a -> a' (possibly being an unknown argument to a function), is being used with `a' as type `Integer', and generate code to pass the `Num Integer' dictionary to the run-time value at that point, to get the actual `Integer -> Integer' operations
03:20:24 <lambdabot> The answer is: Yes! Haskell can do that.
03:20:52 <augur> and, again, can i define negate outside of a typeclass definition, in such a way as to actually have it be part of a type class (ie is class F N where ... really just SUGAR or is it substantive?)
03:20:53 <ray> b_jonas: like a quickcheck or whatever property a * b === b * a
03:21:02 <copumpkin> gah, what a fucking waste of time this is
03:21:08 * copumpkin goes out
03:21:13 <augur> by copumpkin
03:21:17 <kmc> augur, you cannot add stuff to a typeclass outside its "class ... where" declaration
03:21:18 <ray> with the type Abelian a => a
03:21:28 <ray> or whatever the implementation details are
03:21:45 <mle> augur: why not just try to do it and see?
03:21:45 <kmc> you can make stuff that works with that typeclass, but its implementation will be the same for all types in terms of that class (parametrically polymorphic)
03:21:52 <augur> ok, so then there really is some substantive non-sugar nature to typeclasses
03:21:53 <ray> or what people refer to as the monad and functor laws
03:21:55 <adu> augur: well, which methods are chosen by the compiler depend only on the type that is an argument to the typeclass, not anything else, and the typeclass argument should be known at compile-time, so its kinda silly to wait until runtime, but it isn't forbidden by the haskellreport
03:22:05 <augur> i asked this already and you all fraking drooled
03:22:09 <osfameron> @ops
03:22:10 <lambdabot> Maybe you meant: docs oeis pl
03:22:11 <b_jonas> ray: the quickcheck won't chose you a random Abelian type, the best it can do is default; and it also can't do one thing if a type is abelian and another if it's not abelian, for that would be against the type system
03:22:11 <kmc> augur, if you want to consider *one particular* implementation of typeclasses, the dictionary-passing implementation, then the "class ... where" is declaring a datatype for typeclass dictionaries
03:22:37 <kmc> e.g.:  data EqDict a = EqDict { eq :: a -> a -> Bool; neq :: a -> a -> Bool }
03:22:48 <ski> augur : you can't define the `Num' method `negate' outside of an `instance' declaration. you can define another function called `negate', that will be unrelated to the former
03:22:49 <kmc> then each "instance" builds a value of this type and squirrels it away in a global place
03:23:01 <b_jonas> adu: no, it is not always known in compile time. in most cases it is, but not always. not even in h89.
03:23:07 <mle> augur: you don't seem familiar with the type system.  Have you read the report?
03:23:34 <augur> ive read enough to know what questions i want to ask, and to know that theyre not answered in the places ive read from.
03:23:38 <b_jonas> adu: they call it parametric polymorphism or something like that
03:23:43 <adu> b_jonas: ok, I guess I don't have a great imagination for wierd cases
03:23:59 * osfameron hugs irssi's /ignore
03:24:12 <kmc> augur, yes, typeclasses are substantive.  they can be thought of as a mechanism for choosing values of implicit function parameters in a type-directed way
03:24:13 <mle> augur: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729 also describes early implementation details in a way that makes the sugarless (Core) form easier to grasp
03:24:15 <b_jonas> adu: yep, they are hard to imagine, but there's some good article for it. it's called something like parametric polymorphism or something.
03:24:17 <augur> i mean, cmon, either the spec says that class ... where is sugar or not. i dont see why ive gotten two different answers on this
03:24:27 <Ytinasni> augur: in terms of the standard, no, it's not just sugar. In terms of how ghc does it, yes, it's sugar.
03:24:28 <kmc> augur, it's not sugar.  who said it was?
03:24:33 <b_jonas> let me look it up
03:24:43 <kmc> yes Ytinasni has it
03:24:48 <augur> well someone keeps mentioning a dictionary thing
03:25:01 <augur> which presumably means that i should be able to pass this dictionary explicitly in code
03:25:04 <Ytinasni> augur: ghc desugars into a dictionary.
03:25:09 <kmc> augur, but you can't in standard haskell
03:25:12 <ski> adu : you sometimes have to wait until run-time (polymorphic recursion, constrained existentials, higher-rank)
03:25:21 <augur> well, a dictionary in haskell-visible terms
03:25:23 <Jafet> Ytinasni, the dictionary is part of the implementation.
03:25:26 <augur> or just some under-the-hood dictionary
03:25:32 <adu> found it: http://www.haskell.org/haskellwiki/Something_like_parametric_polymorphism_or_something
03:25:34 <augur> because i dont care about under-the-hood crap that i cant see
03:25:45 <augur> because thats not sugar
03:25:48 <kmc> augur, the dictionary is only one implementation of typeclasses.  but it's also a very instructive implementation to consider, in terms of understanding what typeclasses can and cannot do
03:25:58 <augur> kmc
03:26:03 <kmc> augur
03:26:06 <augur> in those versions where it is implemented in terms of dictionaries
03:26:17 <augur> can i, in my haskell code, refer to this dictionary.
03:26:26 <kmc> augur, i do not know of a way to do this in GHC
03:26:31 <Ytinasni> augur: no.
03:26:34 <augur> so then its not sugar for the dictionary
03:26:34 <kmc> there is (obviously) no standard Haskell way to do it
03:27:03 <kmc> augur, people were clearly using the word "sugar" a bit differently than you understand.  what was that about autistic people?
03:27:05 <ski> you could pass around dictionaries yourself (given the extension that data constructors can be polymorphic), instead of using type classes .. type classes buy you consistency/coherence, as well as convenience, though
03:27:13 <kmc> they don't understand minor variations in word meaning?
03:27:23 <augur> kmc, apparently theyre using it differently than the whole of the rest of the programming community
03:27:33 <kmc> ah yes well now let's be precise
03:27:36 <kmc> unlike before
03:27:55 <augur> because everyone out there in the real programming world understands sugar to mean something thats equivalent to some other statement or expression of the language
03:28:01 <kmc> when it was just pedantry
03:28:21 <augur> like how (presumably!) do notation is sugar for >>=
03:28:41 <augur> obviously class ... where is not the same kind of sugar as do .. <- ..
03:28:48 <b_jonas> adu: the finger tree article gives a complicated application for it, but there was a simpler introductory article
03:28:52 <kmc> it's a less local transformation
03:28:56 <Ytinasni> augur: not "presumably". the standard says quite precisely how do is sugar for >>=.
03:29:09 <augur> Ytinasni: no i know how precise the spec is on that matter
03:29:18 <kmc> anyway i'm sick of this, have fun
03:29:33 <augur> which is the point, right, i mean, sugar means something quite simple. its notational variation on some other phenomena in the language.
03:29:43 <b_jonas> adu: found it: http://www.eecs.usma.edu/webs/people/okasaki/icfp99.ps
03:29:44 <augur> but typeclasses-as-dictionaries is clearly NOT that sort of thing
03:29:55 <augur> so god only knows why people would tell me about dictionaries when i ask if its sugar
03:30:07 <augur> i can only conclude its because they dont know the jargon
03:30:24 <adu> oo Adventures in Types, i like adventures.
03:30:32 <Ytinasni> augur: "sugar" is ghc jargon.
03:30:41 <Ytinasni> so "don't know the jargon" is an odd statement.
03:30:44 <augur> oh god
03:30:52 <tredontho> god can't help you either
03:31:02 <tredontho> :/
03:31:09 <augur> does GHC really have some magic use of the word sugar that is different than in other programming languageS?
03:31:11 <augur> REALLY?
03:31:45 <Ytinasni> augur: no. it has the same meaning as in other programming languages.
03:31:56 <augur> then type classes are not sugar for dictionaries.
03:32:01 <adu> yes it means glucode
03:32:08 <adu> uh i mean glucose
03:32:16 <Ytinasni> it means that you can acheive exactly the same result except syntactically different.
03:32:17 <ski> `class Num a where negate :: a -> a' can be simulated with `data NumDict a = MkNumDict {negate :: a -> a}'
03:32:20 <augur> and everyone who said they were was wrong and therefore responsible for any confusion that resulted.
03:32:23 <ski> then `silly :: Num a => a -> (a,a); silly a = (a,negate a)' is simulated with `silly :: NumDict a -> a -> (a,a); silly dict a = (a,negate dict a)'
03:32:31 <kmc> @quote sugar
03:32:31 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
03:32:32 <lambdabot> true functional programming), and you've got haskell
03:32:33 <augur> Ytinasni: i know! this is the point! i asked this question like 20 times before
03:32:34 <kmc> @quote sugar
03:32:35 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
03:32:35 <lambdabot> true functional programming), and you've got haskell
03:32:40 <augur> and people kept telling me crap about dictionaries
03:32:51 <augur> only to later say "oh but thats in the compiler not the language"
03:32:58 <medfly> I don't know the jargon, when I ask questions here I try to make them short and spend a while trying to make sense of the answer. :|
03:33:06 <Ytinasni> you could replace every `class` with something else, every `instance` with something else, and have the same program.
03:33:14 <augur> wut
03:33:29 <ski> and `instance Num Integer where negate = negateInteger' is simulated by `dictNum_Integer :: NumDict Integer; dictNum_Integer = MkDict {negate = negateInteger}'
03:33:30 <Ytinasni> for various values of "something else", you might have "dictionaries", which you could then name in code.
03:33:51 <b_jonas> ski, Ytinasni: that wouldn't actually work, would it? not without some kind of unsafeCoerce.
03:33:51 <augur> yes but im not asking how it could be done in theory if we were designing some different version of haskell than Haskell 98
03:34:11 <augur> im asking what the language-itself does
03:34:12 <ski> and finally `foo :: (Integer,Integer); foo = silly 42' is simulated with `foo :: (Integer,Integer); foo = silly dictNum_Integer 42'
03:34:20 <augur> so obviously i COULDNT just do "something else"
03:34:30 <Ytinasni> b_jonas: the same up to turing completeness.
03:34:34 <Jafet> The Haskell report does not define any sort of desugaring transformation for type classes.
03:34:39 <augur> not unless you're saying haskell is so awesome and cool that i can start typing ruby and itll let me do it!
03:34:46 <ski> afaiu, "sugar" needn't be "what the language-itself does", only what *could* be done
03:34:49 <Jafet> It does for do-notation and pattern guards.
03:35:02 <ski> b_jonas : sure it works
03:35:04 <Ytinasni> augur: the language provides these things it calls "type classes", which do what the spec says. no more, no less.
03:35:04 <HaskellLove> I am solving euler 19 and on wikipedia it says "The month has 29 days in leap years, when the year number is divisible by four (except for years that are divisible by 100 and not by 400)" Notice the except on years divisible by 100 and not by 400 thing...  i am confused, why are these calendars like this? 800 is divisible with 100 and with 400 so why does february in it have 29 days?...
03:35:05 <HaskellLove> ...http://www.calendarhome.com/cgi-bin/tycyear.pl?year=700&change=1&suppresshol= http://www.calendarhome.com/cgi-bin/tycyear.pl?year=800&change=1&suppresshol=
03:35:40 <dibblego> HaskellLove, calendars are like that due to the relationship of the time it takes for the planet to spin and the time it takes for the planet to orbit the sun
03:35:46 <Jafet> Ask the EP admins if they'll let you work with the lunar calendar instead
03:35:49 <ski> b_jonas : you'll need polymorphic data constructors for encoding classes with polymorphic methods, though (like `Monad', e.g.)
03:35:51 <augur> Ytinasni: and in the spec there are no other ways of doing what type classes do, in such a way that doing it one way is indistinguishable from the other
03:35:52 <augur> ie
03:35:58 <adu> HaskellLove: you lost me
03:36:00 <tredontho> HaskellLove: 800 is a leap year
03:36:23 <tredontho> HaskellLove: 800 `mod` 400 = 0
03:36:26 <augur> you could use instance ... where to define one instance of a type class defined using class ... where
03:36:28 <tredontho> 700 is not
03:36:36 <tredontho> 700 is divisible by 100, but not by 400
03:36:42 <tredontho> most people aren't aware of that
03:36:46 <augur> and you could also use instance ... where to define an instance of a type class defined using the alternative, NON-class...where method
03:36:48 <b_jonas> augur has a point here, it's not sugar in that you can't just replace instances with something else in some part of the program
03:36:51 <tredontho> they only know that if it's divisible by 4, it's a leap year
03:36:54 <Jafet> Yes, sadly, most people don't know the calendar they use
03:36:56 <b_jonas> it's rather a model of implementation or something
03:37:00 <augur> maybe thats what i should be asking, b_jonas
03:37:02 <Jafet> Let's not care about those people
03:37:03 <adu> http://www.google.com/search?q=year+in+days
03:37:29 <augur> can i define type classes with something other than class ... where such that instance ... where is still able to instantiate that type class
03:37:39 <Ytinasni> augur: turing completeness. there *IS* a way to compute any computable value.
03:37:41 <Ytinasni> augur: no.
03:37:45 <augur> ok then
03:37:56 <Ytinasni> not portably between compilers, anyway.
03:37:59 <Jafet> augur, how many different answers do you want to that question?
03:38:12 <augur> Jafet: just the one, but i only just got it. :P
03:38:15 <Ytinasni> there could be a (hypothetical) compiler that names it's internal objects such that you could use them.
03:38:26 <Jafet> You were given it ten minutes ago, then you pissed off the people who told you
03:38:31 <Jafet> I think you need to go outside.
03:38:41 <augur> ok but the spec doesnt mention this and therefore that would be non-standard
03:38:44 <Jafet> Ytinasni, irrelevant
03:38:44 <augur> yes? yes. good.
03:39:09 <augur> therefore the answer is NO, because such a hypothetical compiler could not exist while still being Haskell 98
03:39:16 <HaskellLove> exactly, so then this calender is mistaken? http://www.calendarhome.com/cgi-bin/tycyear.pl?year=700&change=1&suppresshol=
03:39:17 <Ytinasni> BS.
03:39:29 <Ytinasni> it would accept any comforming haskell program.
03:39:40 <Jafet> It could. Using the hypothetical features would result in a nonconformant program.
03:39:42 <Ytinasni> and some non-conforming ones, but that doesn't matter.
03:39:45 <augur> that doesnt mean it implements that language
03:39:51 <augur> it implements a superset language
03:39:51 <augur> which is not the same thing
03:39:58 <augur> but now were getting into less interesting territory
03:40:01 <Jafet> No compiler implements exactly the language.
03:40:06 <Jafet> For any language.
03:40:08 <augur> well ok granted :P
03:40:08 <Jafet> Except perl 5.
03:40:11 <augur> haha
03:40:22 <HaskellLove> dibblego yeah i know dude
03:40:39 <HaskellLove> dibblego anyways, so the calendar is mistaken, see my above post
03:40:40 <augur> thats probably because any minor deviation from perl 5's spec would necessarily render any and all programs inoperable :P
03:40:41 <adu> HaskellLove: yes
03:40:43 <Ytinasni> augur: by that token, there is no haskell compiler, anywhere. In fact, there is no standard-conformaing compiler for ANY language that i know of.
03:40:57 <Jafet> HaskellLove, the Gregorian calendar was introduced in the Middle Ages.
03:40:58 <tredontho> HaskellLove: yeah, that's wrong.  sort of like the date system in old versions of excell had 1900 incorrectly as a leap year
03:40:59 <augur> ok im done. my question seems to have been answered now.
03:41:08 <tredontho> excel*
03:41:22 <augur> thank you Ytinasni for eventually answering it, and thank you everyone else who at least tried despite failing.
03:41:22 <Jafet> Therefore, the calendar seems correct, as it follows the Julian calendar.
03:41:32 <HaskellLove> ok thanks guys, i thought my functions were wrong and now it turns out the calender is, great :D
03:41:47 <augur> and thank you everyone else here for putting up with the last half our or two.
03:41:48 <augur> :P
03:41:52 <ski> yw
03:42:18 <augur> except you. >O
03:42:34 <ski> as you prefer it
03:42:38 <augur> :P
03:43:17 <Jafet> Well, that calendar looks wrong anyhow
03:43:22 <Jafet> http://www.calendarhome.com/cgi-bin/tycyear.pl?year=1582&change=1&suppresshol=
03:43:31 <Jafet> At least in Rome.
03:43:50 <HaskellLove> so any year divisible with 4 is a leap one
03:44:08 <augur> unless its divisible by 100.
03:44:36 <Jafet> And you claim to communicate clearly.
03:44:44 <augur> what. :|
03:44:53 <HaskellLove> augur ouch... I see... and the 400 thing? on wiki it says "divisible with 100 but not with 400"
03:44:54 <Ytinasni> unless it's divisible by 100 and not 400. (2000 was a leap-year).
03:45:04 <augur> oh was it that?
03:45:21 <HaskellLove> guys you confuse me slap slap
03:45:25 <augur> :D
03:45:27 <b_jonas> HaskellLove: may I recommendhttp://www.tondering.dk/claus/calendar.html
03:45:48 <augur> ok
03:45:51 <augur> the definition for a leap year
03:45:52 <augur> from wiki
03:45:53 <augur> is
03:45:57 <Jonno_FTW> haskell love, beware leap years can also be divisible by 400
03:46:03 <augur> a year is a leap year if
03:46:04 <Jonno_FTW> if on a century
03:46:06 <b_jonas> http://www.tondering.dk/claus/cal/node3.html#SECTION00321000000000000000 in particular
03:46:11 <augur> its divisible by 4
03:46:12 <tredontho> HaskellLove: is it divisible by 4? ---- Yes? ---- is it divisible by 100?  --- if no, then it's a leap year, if yes ----- is it divisible by 400?  --- if yes, it's a leap year, otherwise no
03:46:17 <augur> unless its divisible by 100 in which case it is
03:46:23 <Jonno_FTW> also, there is a very simple maths answer to that question
03:46:25 <augur> isnt*
03:46:34 <augur> unles unless its divisible by 400.
03:46:35 <adu> HaskellLove: timeanddate.com is wrong too
03:46:51 <Jonno_FTW> isLeap n | (n `mod` 100 /= 0) =  (rem n 4) == 0
03:46:53 <Jonno_FTW> 		 | otherwise = (rem n 400) == 0
03:47:01 <augur> leap n = (n % 4 == 0) && (n % 400 == 0 || n % 100 /= 0)
03:47:40 <augur> or what Jonno_FTW said
03:47:40 <Jonno_FTW> isLeap2 n |(n `mod` 4 == 0 && n `mod` 100 /= 0) || (n `mod` 400 == 0) = True
03:47:41 <Jonno_FTW>           | otherwise = False
03:47:44 <tredontho> @type (%)
03:47:45 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
03:47:46 <HaskellLove> is Hoogle down for me only or what? Jonno_FTW what does rem?
03:47:55 <Jonno_FTW> i did this the really long way
03:48:01 <tredontho> > 6 % 4
03:48:02 <lambdabot>   3 % 2
03:48:07 <Jonno_FTW> rem is the remainder from division
03:48:08 <Ytinasni> HaskellLove: the remainder, when doing division.
03:48:13 <augur> oh that
03:48:14 <Jonno_FTW> > rem 5 2
03:48:15 <lambdabot>   1
03:48:17 <augur> damn yo haskell :|
03:48:27 <augur> always so alluringly intuitive then BAM
03:48:30 <Jonno_FTW> 5 divide 2 is 2 remainder 1
03:48:47 <tredontho> > 5 `rem` (-2)
03:48:47 <lambdabot>   1
03:48:49 <Jonno_FTW> hoogle is broken at the moment
03:48:54 <tredontho> 5 `mod` (-2)
03:49:29 * ski hands tredontho a `> '
03:49:32 <Jonno_FTW> you can fix it by changing /latest/ to /6.10-latest/ in the address
03:49:48 <augur> http://en.wikipedia.org/wiki/File:Gregoriancalendarleap_solstice.svg
03:50:26 <tredontho> thanks ski
03:50:34 <tredontho> > 5 `mod` (-2)
03:50:34 <lambdabot>   -1
03:50:49 <tredontho> I was looking for one, couldn't find it anywhere :/
03:51:18 <HaskellLove> Jonno_FTW what do you mean latest? this is the adress http://haskell.org/hoogle/
03:51:29 <Jonno_FTW> oh right
03:51:33 <Jonno_FTW> when you search something
03:51:46 <Jonno_FTW> http://haskell.org/ghc/docs/6.10-latest/html/libraries/base/Prelude.html
03:51:58 <Jonno_FTW> works, while http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html does not work
03:52:26 * hackagebot upload: network 2.2.1.7 - Networking-related facilities (JohanTibell)
03:52:37 <Jonno_FTW> that's only for standard libraries, packages in hackage should still work
03:56:29 <augur> anyone know anything about proofs in formal logic?
03:56:39 <adu> that's wierd, it almost seems that timeanddate.com is only showing 1800 and 1900 correctly, almost as if it had special rules for those years
03:57:00 <adu> augur: yes, i do
03:57:06 <augur> oh god
03:57:07 <augur> D:
03:57:08 <augur> not adu D:
03:57:14 <ski> would you prefer me ?
03:57:30 <augur> either of you: is there a standard convention for the shape of proofs?
03:57:31 <b_jonas> adu: no, it's just using the Gregorian calendar before that for historical accuracy
03:57:32 <adu> augur: well good luck getting help from me with that attitude
03:57:37 <b_jonas> shape?
03:57:49 <b_jonas> rectangular because then it's easier to pack more than on to an article.
03:57:51 <augur> like, what it looks like
03:57:53 <Jafet> Huh? The Gregorian calendar is used now
03:58:00 <b_jonas> the other one then
03:58:03 <b_jonas> the Julian
03:58:14 <ski> augur : there are several common presentation styles. natural deduction, sequent calculus, hilbert-style
03:58:16 <Jafet> That was introduced in 1582, though
03:58:30 <b_jonas> depends on where
03:58:41 <augur> i did derivations in my semantics class in a fashion that simply involved rewriting things in the normal fashion
03:58:45 <ski> augur : and there's several visual variants on how to write those, as well
03:58:51 <augur> and my professor responded with "are you a programming?"
03:58:54 <adu> augur: like this:
03:59:00 <adu> PROOF: bla bla bla bla
03:59:00 <ski> augur : you can also write proof-terms a la type theory
03:59:03 <adu>   bla bla bla bla
03:59:20 <augur> because apparently it was very much like a typical functional programming derivation
03:59:27 <augur> a big pyramid of text
03:59:48 <augur> hm. what are these things you refer to, ski
04:00:01 <ski> formal proof presentation styles
04:00:40 <augur> thanks :P
04:00:47 <ski> see e.g. <http://en.wikipedia.org/wiki/Natural_deduction>
04:00:51 <augur> i mean what makes them what they are
04:02:02 <ski> a single logic (out of many) can often be presented in several of these styles
04:02:34 <augur> i see i see, so "natural deduction" is sort of upside-down tree like, in some sense
04:03:02 <ski> the appearance of proofs in the logic changes with the presentation style, but what formulae are theorems doesn't change
04:03:20 <ski> (usually there are ways to translate proofs between the different presentations, as well)
04:03:26 <augur> right, i just mean the presentation style
04:03:55 <ski> yes, though the key point of "natural deduction" is mainly that it is tree-like, and that it has local assumptions
04:03:55 <augur> because the only presentation style i know is rewriting the entirety of the thing to be proven with one change per line, until you can reduce it to True
04:04:11 <augur> which apparently is a very programmer-y style of doing proofs
04:04:21 <ski> you can write it visually as a tree, or sequentially (possibly with indentation)
04:05:06 <augur> ski, do you know of a site that summarizes these presentation styles?
04:05:27 <augur> "fitch style"
04:05:38 <adu> augur: like wikipedia?
04:05:46 <augur> this is the one that i see a bunch of people using too i think
04:06:00 <HaskellLove> diy year = (4*30) + (7*31) + feb where feb | (year `mod` 4 == 0) || (year `mod`400 == 0) = 29 | (year `mod` 100 == 0) && (year `mod` 400 /= 0) = 28 | otherwise = 28
04:06:01 <HaskellLove> Why does that give me 366 days for year 1900?
04:06:35 <tredontho> the first guard passes
04:06:39 <augur> adu hm. i suppose so!
04:06:43 <tredontho> 1900 `mod` 4 == 0
04:07:02 <augur> but wiki doesnt list these anywhere it seems :(
04:08:28 <HaskellLove> oops ... thanks
04:08:36 <ski> fitch style is similar to natural deduction, with some difference
04:08:45 <ski> (i can't remember what the difference was, atm)
04:09:24 <ski> augur : sorry, no, i know of no such summary
04:09:41 <augur> hm.
04:10:09 <augur> i just dont know how to do proofs in these other styles, but i gather its typical of logic and semantics to do proofs these ways
04:11:19 <ski> (i would expect that if someone expects you to use a particular style, they would provide some material explaining how to do proofs in that style ..)
04:11:32 <augur> oh its not so much about expectations
04:11:38 <augur> i mean, my profs dont care, right
04:11:49 <ski> i don't know
04:11:57 <augur> but if im going to be doing semantics, like i am, i figure i'd at least be able to talk the talk
04:12:28 <augur> ESPECIALLY if im hell bent on inventing different forms of logic to try and solve these problems of natural language :P
04:12:29 <Ytinasni> augur: for a class, you generally want to imitate the teacher(s).
04:12:40 <ski> possibly you can learn much of it by osmosis, reading papers, watching other people present something, and talking to them
04:12:43 <augur> yeah, well he never actually did proofs, see.. :P
04:13:02 <Ytinasni> ah. :D
04:13:04 <ski> not even simple ones ?
04:13:09 <augur> ski, wish i wish. i cant FIND papers with proofs! :(
04:13:13 <augur> no, not even simple ones
04:13:16 <augur> well
04:13:24 <ski> (like proving `|- A /\ B -> B /\ A', e.g.)
04:13:27 <augur> except where simple is demonstrating some mino factor
04:13:36 <augur> oh no that was never even remotely an issue
04:14:01 <augur> besides, you cant prove "|- A & B -> B & A"!
04:14:05 <pozic> augur: every paper on a new algorithm contains a proof.
04:14:10 <augur> since |- is an assertion of axiom!
04:14:10 <augur> :P
04:14:26 <pozic> augur: no, it is not.
04:14:32 <augur> it is in all the books ive read
04:14:53 <ski> `|- A /\ B -> B /\ A' means that `A /\ B -> B /\ A' is a theorem (i.e., is provable) in the current deduction system
04:15:01 <ski> naturally all the axioms are provable
04:15:09 <augur> |- G. is a statement about a proof saying "it is possible to proof, given nothing at all, that G"
04:15:20 <mulletro1> maybe he means |= instead of |-
04:15:25 <ski> so possibly they just used that notation when presenting the logic, to note that a formula was an axiom ?
04:15:34 <augur> no |= is validity of an argument
04:15:38 <ski> *nod*
04:15:43 <augur> |- is provability
04:15:47 <ski> yes
04:15:56 <augur> maybe its the authors ive read
04:16:26 <augur> but they use "|- G." strictly to mean that G is an axiom, by way of being provable without any requirements.
04:16:40 <augur> nothing is to the left of |-, therefore you dont need anything to infer G
04:17:16 <ski> how does that fit with "|- G. is a statement about a proof saying \"it is possible to proof, given nothing at all, that G\"" ?
04:17:34 <augur> its a rephrasing is how :P
04:17:41 <augur> a proof with no steps is an axiom
04:17:56 <ski> (i don't see how you can claim first `|- G' means `G' is provable, and later claim `|- G' is only used for stating `G' as an axiom)
04:18:12 <ski> yes, but usually, there are more theorems than axioms
04:18:12 <Ytinasni> ski: every axiom is provable.
04:18:18 <Ytinasni> that's why they're asioms.
04:18:25 <ski> Ytinasni : i know (i said that above :)
04:18:28 <augur> sure, but a proof that has no steps is an axiom.
04:18:36 <augur> because axioms are just true.
04:18:38 <ski> yes
04:18:50 <augur> well, a proof that has a conclusion but no premises is something where the conclusion is just true
04:18:56 <augur> its axiomatic
04:19:05 <ski> (to be pedantic, i'd say it is a proof that the formula in the axiom is a theorem)
04:19:19 <ski> no
04:19:23 <tredontho> ski: but being pedantic == being autistic, remember?
04:19:26 <augur> well ok we can waffle with that if you want
04:19:32 <augur> but theres no substantial difference there.
04:19:34 <ski> tredontho : and ?
04:19:55 <augur> tredontho: no, being pedantic and not realizing you're being pedantic is being autistic.
04:20:13 <augur> being pedantic, realizing it, and not caring is being a jerk
04:20:17 <tredontho> haha
04:20:30 <tredontho> i never knew how these things were defined before
04:20:31 <ski> augur : in standard terminology, "axiom" are those formulae that are known/decided to be provable at first hand. there can be formulae that are provable without premises that still aren't axioms
04:20:40 <augur> "yes i know what you mean but im going to correct you on your spelling rather than respond to your statement"
04:20:55 <augur> ski: er, can there really?
04:20:59 <ski> yes
04:21:02 <augur> such as?
04:21:04 <Ytinasni> ski: example?
04:21:23 <augur> tredontho: im just making shit up, but i think thats pretty much what you get when you think about it, right
04:21:23 <ski> it depends on which logic (and presentation) you use
04:21:29 <tredontho> ski: now, i'm probably not at your level, but aren't axioms just things which are assumed to be true, not necessarily provable?  isn't that the point of them being axioms?
04:21:32 <pozic> There are no absolute truths in the end.
04:21:37 <tredontho> augur: no, i agree
04:21:54 <pozic> At some point, someone says that induction is a valid principle.
04:22:01 <ski> tredontho : they being "assumed to be true" is what makes them provable, yes
04:22:06 <pozic> That is an axiom that in no way can be proved.
04:22:07 <augur> i mean, people who are pedantic and dont realize it clearly have some problem dealing with social interaction and inferring intentions of communication, which is typical of autistic cognition
04:22:13 <pozic> That's what makes it an axiom.
04:22:27 <augur> and people who are pedantic and DO realize it but persist anyway are well, pretty dickfaced, lets be serious
04:22:29 <tredontho> take for example, euclidean geometry and the 5th axiom
04:22:31 <pozic> Induction can be proved by hand-waving of course.
04:22:45 <Ytinasni> augur: using big words doesn't make them true.
04:22:59 <ski> augur,Ytinasni : but for example, in standard natural deduction presentation of classical logic, `A /\ B -> B /\ A' is provable without premises, but is not an axiom
04:23:11 <tredontho> well, induction is based on natural numbers and the least element axiom, right?
04:23:15 <ski> (it is often an axiom in hilbert-style presentations, though)
04:23:19 <augur> oh ski i think i see what you mean
04:23:41 <augur> assume 'A & B -> B & A' is true
04:24:02 <augur> therefore 'A & B -> A'
04:24:10 <augur> therefore 'A & B -> B'
04:24:25 <augur> therefore 'A & B -> A & B'
04:24:27 <ski> hm, why are you assuming what is to be proved ?
04:24:28 <augur> or something
04:24:43 <Ytinasni> uh....ok. i seem to remember proving that properly for my assignments, though :D
04:24:45 <augur> ok maybe you should assume the opposite :P
04:24:56 <ski> well, you could .. but there's no need
04:25:14 <augur> but i think you can prove it must be true by assuming its true, using it, and then proving that the implications could not be false
04:25:15 <augur> or something
04:25:17 <augur> anyway
04:25:20 <augur> yeah i think i see what you mean
04:25:25 <ski>   assume `A /\ B'
04:25:32 <augur> so maybe they were indeed using it to mean just "It's provable
04:25:38 <ski>     therfore `A', by /\-Elim-0
04:25:43 <ski>     therfore `B', by /\-Elim-0
04:25:45 <augur> erg
04:25:52 <ski>     therfore `B /\ A', by /\-Intro
04:26:00 <augur> but ski, thats not |- A&B -> B&A
04:26:07 <ski>   therefore `A /\ B -> B /\ A' by ->-Intro
04:26:15 <pozic> augur: Coq disagrees.
04:26:21 <ski> so `|- A /\ B -> B /\ A'
04:26:35 <augur> thats A&B |- B&A |- A&B -> B&A
04:26:40 <ski> the conclusion here comes at the end
04:26:46 <ski> augur : no
04:26:53 <augur> i mean, you dont have nothing prior to A&B -> B&A in that proof, right
04:27:01 <augur> you have steps
04:27:05 <augur> which means its not |- ...
04:27:08 <augur> its ... |- ...
04:27:12 <ski> yes, so `A /\ B -> B /\ A' is not an axiom
04:27:28 <ski> but still, there's no assumptions on the proof of `A /\ B -> B /\ A'
04:27:30 <augur> right, but then its erroneous, i think, to use |-
04:27:35 <ski> no
04:27:36 <augur> er, |- ...
04:27:42 <ski> this is how natural deduction works
04:27:55 <ski> you "discharge" assumptions when you use the `->-Intro' rule
04:28:04 <ski> first i assumed `A /\ B'
04:28:13 <augur> mmm... ok.
04:28:15 <ski> then i deduced something, under that assumption
04:28:38 <ski> finally, got `A /\ B -> something', discharching the assumption
04:28:49 <ski> so `A /\ B -> something' doesn't have that assumption
04:29:23 <pozic> Isn't |= in some sense a bit imprecise? Since, AFAIK, even proof steps in |= do take place in some kind of formal system?
04:29:37 <ski> `|=' is for semantics, not for proofs
04:30:04 <ski> pozic : did you mean to use `|=' (semantic entailment) or `|-' (syntactic entailment) ?
04:30:10 <pozic> It is just that |-_MYSYSTEM is a less powerful system.
04:30:13 <augur> well
04:30:17 <pozic> ski: semantic entailment
04:30:24 <augur> im not sure |= is for "semantics"
04:30:28 <augur> whatever thats supposed to mean
04:30:37 <augur> its just about arguments not proofs
04:30:37 <pozic> augur: it defines truth.
04:30:41 <ski> it's a bit imprecise, yes
04:30:59 <ski> (since even proofs can be considered a kind of semantics)
04:31:14 <augur> which is to say that its about the overall structure of the argument, not how you get from the stuff before |= to the stuff after it
04:31:28 <ski> ("it" being ?)
04:31:35 <augur> |=
04:31:58 <ski> `|-' and `|=' are typically defined totally different, for a specific logic
04:32:11 <ski> (there can be several of the former as well as of the latter, too)
04:32:45 <pozic> For propositional logic, you have T & T |= T for example and all that.
04:32:49 <ski> pozic : so, yes, both `|-' and `|=' is relative to some ambient system one is using at the moment
04:33:45 <pozic> Then you can write a program which uses a certain proof system (rules) which determines whether or not a particular formula is true.
04:33:52 <ski> .. but, maybe if we're going to discuss more logic, we should move to ##logic ? (unless it is haskell-related logic, i.e.)
04:33:58 <Twey> I'm reading through Oleg's Iteratee slides (http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk-notes.pdf), and I'm a bit confused about page 49
04:34:29 <augur> hm, ski, it seems i was misremembering precisely how the authors i was thinking of were using |-
04:34:32 <pozic> If you have that |- <=> |=, you have soundness and completeness of the particular system.
04:34:34 <augur> and |= too probably
04:34:38 <ski> pozic : yes
04:34:42 <ski> augur : ok
04:34:46 <Twey> After parsing '\r', it returns a Nothing if there's nothing after it, which is the indicator for EOF or error before terminator reached
04:35:02 <Twey> But '\r' *is* a terminator
04:35:13 <augur> im going to get some sleep
04:35:16 <augur> night guys
04:35:22 <Twey> 'night, augur
04:35:22 <ski> night
04:35:34 <tredontho> night augur
04:37:15 <Ytinasni> Twey: uh, page 49? the pages are numbered 1-37.
04:37:57 <Twey> 49 in the PDF
04:38:03 <Twey> It's numbered 19 on the actual slide
04:38:12 <Twey> (but so are the following four pages)
04:39:12 <Ytinasni> oh, lol.
04:40:04 <Ytinasni> it doesn't return nothing if it sees '\r'.
04:40:38 <Twey> See the check_next case
04:41:02 <Twey> It peeks forward to the next character (after the '\r', which has been parsed by the sbreak at this point)
04:41:10 <Twey> Er
04:41:16 <Twey> The first check_next case, that is
04:41:58 <Twey> And if there is no next character (case c of  Nothing ->) it returns Left line
04:42:04 <Twey> Er, yes, not Nothing, sorry
04:42:24 <Twey> But it returns the error value if an EOF is seen after a valid terminator
04:43:55 <Ytinasni> odd. i'm assuming it's a bug.
04:45:15 <Twey> Hm, 'kay
04:45:39 <Ytinasni> a hard-to-repro bug, unless you're on a mac, too :D
04:45:59 <Twey> Hehe
04:46:42 <Beelsebob> Ytinasni: why a mac?
04:46:48 <Beelsebob> it's windows that uses \r characters
04:47:03 <Ytinasni> Beelsebob: windows uses \r\n.
04:47:05 <Beelsebob> right
04:47:08 <Twey> Old Macs use bare \r
04:47:09 <Beelsebob> but Mac OS uses \n
04:47:12 <Twey> (pre-OS X)
04:47:13 <Ytinasni> mac uses (used?) \r.
04:47:18 <Axman6> used
04:47:21 <Beelsebob> Ytinasni: it's not used \r since 1999
04:47:23 <Twey> Used, yes
04:47:34 <Ytinasni> i haven't used a mac in AGES.
04:47:48 <Beelsebob> the really odd thing here is that windows is the one that does it right!
04:48:04 <Beelsebob> you do need to both reset the carriage, *and* feed the paper through
04:48:23 <Axman6> pfft
04:48:27 <Axman6> there is no paper
04:48:39 <Ytinasni> Beelsebob: i'm going to disagree. on my system, there is neither paper nor a carriage.
04:48:43 <Ytinasni> :P
04:48:50 <zygoloid> i assume Beelsebob was kidding ;-)
04:48:54 <Beelsebob> hehe
04:49:05 <Beelsebob> semi
04:49:47 <zygoloid> \n is newline not linefeed
04:52:16 * zygoloid wonders what unicode says about this
04:52:23 <ivanm> Axman6: there aren't any spoons either
04:52:30 * ski . o O ( C64 also uses `\r' :)
04:52:31 <Axman6> i believe it is line feed. the \r\n combo is often referred to as CRLF, carriage return, linefeed
04:55:13 <zygoloid> let's be clear: \r and \n are C character escapes representing 'carriage return' and 'newline'. CR and LF are ASCII characters representing 'carriage return' and 'linefeed'
04:55:47 <ski> > "\CR\LF"
04:55:48 <lambdabot>   "\r\n"
04:56:13 * zygoloid looks at name of channel. ah yeah, haskell, good point.
04:58:00 <Twey> Unicode says LINE FEED (LF)
05:06:08 <Jonno_FTW> can someone help? I did this for the first facebook puzzle
05:06:09 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15058#a15058
05:06:31 <Jonno_FTW> but i don't know how to make the last line work so that it returns the answer
05:08:15 <ski> change
05:08:17 <ski>   print $ answer $ (read a :: Integer)
05:08:18 <ski> into
05:08:24 <ski>   print =<< answer (read a :: Integer)
05:08:39 <Twey> I think you need an argument to readFile, too
05:08:45 <ski> (and possibly change `printf' into `print' as well ?)
05:08:53 <ski> that, too :)
05:09:14 <Jonno_FTW> it needs to be printf in answer and =<< gave a type error
05:09:14 <Twey> Yeah, printf seems unnecessary here
05:09:33 <Twey> Jonno_FTW: 1) Why?  2) You did it wrong
05:09:40 <ski> @type printf
05:09:40 <Twey> Oh
05:09:41 <lambdabot> forall r. (PrintfType r) => String -> r
05:09:41 <Twey> No
05:09:44 <Twey> Yeah.
05:09:49 <Jonno_FTW> what?
05:09:54 <Twey> You're using printf monadically
05:10:02 <Twey> So it takes its monadic form
05:10:05 <Twey> Which is IO
05:10:10 <ski> hm, actually, the `print =<<' is probably not needed/wanted
05:10:12 <Twey> And then you're attempting to print the IO
05:10:15 <Twey> Right
05:10:20 <Jonno_FTW> yep
05:10:20 <ski> (but should still be valid, i think)
05:10:21 <Twey> You need to either remove the printf, or remove the print
05:10:35 <Jonno_FTW> then how do i get it to display the result?
05:10:38 <Twey> (I'd recommend getting rid of the printf, to keep your impure code separate)
05:10:47 <Twey> With the print or printf that you don't get rid of
05:11:13 <Twey> Right now, you're attempting to print a print operation
05:11:35 <Jonno_FTW> ok
05:12:04 <ski> style-wise, i'd replace `[]' with `""'
05:12:58 <ski> also, mathematically,
05:12:59 <ski>   n `rem` 5 == 0 && n `rem` 3 == 0
05:13:03 <ski> should be the same as
05:13:08 <ski>   n `rem` 15 == 0
05:13:44 <ski> (or s/15/(5 * 3)/, if you prefer having the original numbers)
05:14:37 <Jonno_FTW> http://www.facebook.com/careers/puzzles.php#/careers/puzzles.php?puzzle_id=7
05:14:44 <Jonno_FTW> is what i am trying to do
05:17:14 <Guest123135> wich editor is the best to use for haskell? (I'm using notepad++ and it annoys me with errors, because of the tabs)
05:17:30 <Jonno_FTW> you can have it add spaces when you use tav
05:17:32 <Jonno_FTW> *tab
05:17:46 <Guest123135> How?
05:18:06 <Jonno_FTW> go, Settings -> Language Menu/ Tab Settings -> Replace by space
05:18:17 <Guest123135> tnx, i'll give it a try
05:18:24 <pozic> Guest123135: the people who do the most with Haskell use vim and/or Emacs (23).
05:18:49 <Guest123135> tnx pozic i will try those later this day
05:19:10 <Twey> Jonno_FTW: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15058#a15060
05:19:12 <pozic> Guest123135: Emacs takes time to learn, but then you can use it for lots of things.
05:19:15 <Twey> Jonno_FTW: I prefer emacs.
05:19:21 <pozic> Guest123135: you don't learn emacs in a day.
05:19:29 <b_jonas> editors suck
05:19:32 <Jonno_FTW> brace for emacs vs. vim war
05:19:38 <pozic> Guest123135: you can use it in a day, but you would not appreciate it.
05:19:42 <Jonno_FTW> voice to text perhaps?
05:19:51 <Botje-BMS-> Jonno_FTW: editor :: Either Emacs Vim
05:19:54 <Guest123135> why not?
05:19:58 <Botje-BMS-> no reason to fight :]
05:20:04 <pozic> Editors solve a simplistic problem.
05:20:07 <Jonno_FTW> it happened before
05:20:25 <Twey> Botje-BMS-: You mean editor :: Either Vim Emacs
05:20:27 <Twey> Of course ;)
05:20:35 <Botje-BMS-> same difference :p
05:20:43 <Twey> editor = Left $ error "Argh!  Wrong choice!"
05:20:51 <Jonno_FTW> it's happening
05:20:56 <Botje-BMS-> :]
05:21:07 <ski> (Twey : sure, `Vim' is the exceptional situation, for the `Either Vim' monad ;)
05:21:31 <Guest123135> so witch one is better vim or emacs?:P
05:21:35 <ski> yes
05:21:57 * Twey laughs.
05:22:10 <quuuux> @pl \ a -> fmap (\ w -> flip f w . a) g
05:22:11 <lambdabot> flip fmap g . flip ((.) . flip f)
05:22:57 <Twey> Guest123135: Let me put it this way many people profess to love vim, but I don't know very many at all who've gone back to it after trying out emacs.  :
05:23:06 <Jonno_FTW> i still don't have a solution to my problem
05:23:28 <Twey> Jonno_FTW: You have several
05:23:29 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15058#a15060
05:23:39 <Jonno_FTW> wow thanks guys
05:23:56 <pozic> Twey: I use vim when I have too many Windows open in a desktop session and Emacs is not running ;)
05:24:01 <pozic> windows*
05:24:08 <Twey> Haha, Freudian capitalisation!
05:24:37 <b_jonas> nah, it's data Editor = Vim | Emacs;
05:26:40 <tredontho> no love for yi?
05:26:49 <Twey> http://pbraun.nethence.com/fun/normal/n0010_en_vi-vs-emacs.png
05:26:51 <Twey> *grin*
05:27:39 <pozic> tredontho: Yi is fast enough. Now, all we need is compelling features.
05:28:24 <Jonno_FTW> none of them work
05:28:42 <tredontho> I haven't used it in a while
05:29:35 <quuuux> @unpl flip ((.) . flip f)
05:29:35 <lambdabot> (\ b c g -> f (b g) c)
05:31:20 <ski> @type liftM (enumFromTo 1) . readFile  -- Twey
05:31:21 <lambdabot>     No instance for (Enum String)
05:31:21 <lambdabot>       arising from a use of `enumFromTo' at <interactive>:1:7-18
05:31:21 <lambdabot>     Possible fix: add an instance declaration for (Enum String)
05:31:36 <Jonno_FTW> :t mapM_
05:31:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
05:31:48 <Twey> Yeah, I know, I know :
05:31:58 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15058#a15061
05:33:33 <Jonno_FTW> wow, it actually works
05:33:55 <Jonno_FTW> what's wrong with printf?
05:34:01 <Jonno_FTW> @src printf
05:34:01 <lambdabot> Source not found. Just try something else.
05:34:11 <Jonno_FTW> @src Text.Printf
05:34:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:34:24 <Twey> Jonno_FTW: What's wrong with printf is that you're not using it
05:34:39 <Twey> printf is for run-time interpolation of values into a template string
05:34:56 <Twey> If you're just printing a string, you want putStr, because you don't need to do anything like that
05:34:59 <quuuux> @pl \ f -> flip ((.) . flip f)
05:34:59 <lambdabot> flip . ((.) .) . flip
05:35:23 <Jonno_FTW> ok
05:36:48 <quuuux> hey, that sort of looks like it could be a real combinator: the peeping tom. flip . ((.) (.)) . flip
05:37:55 * hackagebot upload: haskell-src-exts 1.5.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
05:38:03 <b_jonas> nah, ((.) (.)) is not the same as ((.) .)
05:38:16 <b_jonas> or is it?
05:38:18 <b_jonas> maybe it is
05:38:25 <ski> yes
05:38:30 <Ytinasni> it totally is.
05:39:12 <HaskellLove> getting proper divisors for a number, to do it brute force or there is a cleaner way? all proper divisors not just primes...
05:39:19 <portnov> :t ((.) (.))
05:39:20 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
05:40:10 <portnov> :t ((.) .)
05:40:12 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
05:41:05 <b_jonas> HaskellLove: for that you have to find the prime decomposition first and then compute the divisors from that
05:41:20 <HaskellLove> proper_divisors n = [x | x<-[1..n], n `mod` x == 0] this one is ok i think
05:41:28 <portnov> :t flip . ((.) .) . flip
05:41:30 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> a1 -> b) -> f a -> a1 -> f b
05:42:15 <Jonno_FTW> and waht does catMaybes do?
05:42:35 <portnov> :t catMaybes
05:42:36 <lambdabot> forall a. [Maybe a] -> [a]
05:42:37 <Botje-BMS-> picks out the Just values from a list of Maybe's
05:42:44 <b_jonas> > catMaybes [Just 4, Nothing, Nothing, Just 32, Just 5, Nothing]
05:42:45 <lambdabot>   [4,32,5]
05:42:48 <b_jonas> it's quite useful
05:43:26 <b_jonas> at least I think it is
05:46:06 <Jonno_FTW> i still don't get what =<< and similar operators fo
05:46:07 <Jonno_FTW> *do
05:46:24 <Axman6> time for you to go and define them i think. one sec
05:46:46 <Jonno_FTW> a definition isn't very useful to me
05:46:51 <Jonno_FTW> wait
05:46:51 <MoALTz_> > join (*) 3
05:46:53 <lambdabot>   9
05:47:20 <tredontho> @type join
05:47:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:47:38 <MoALTz_> investigating the join magic, since i do not understand it enough
05:47:39 <Beelsebob> Jonno_FTW: do you understand what <$> does?
05:47:46 <Axman6> Jonno_FTW: http://blog.tmorris.net/20-intermediate-haskell-exercises/
05:47:49 <Jonno_FTW> a literal $
05:47:51 <Jonno_FTW> ?
05:47:54 <Axman6> no
05:47:56 <tredontho> @src join (*)
05:47:56 <lambdabot> Source not found. stty: unknown mode: doofus
05:47:57 <Axman6> <$>
05:47:57 <Beelsebob> Jonno_FTW: no, the operation <$>
05:48:00 <Jonno_FTW> no
05:48:02 <tredontho> @type join (*)
05:48:03 <lambdabot> forall a. (Num a) => a -> a
05:48:12 <Beelsebob> Jonno_FTW: if I write the same thing as fmap, do you understand what it does?
05:48:22 <Jonno_FTW> no
05:48:32 <Axman6> > fmap show [1..10]
05:48:33 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10"]
05:48:43 <Axman6> > fmap show (Just 3)
05:48:44 <lambdabot>   Just "3"
05:48:46 <Jonno_FTW> how is it different from map?
05:48:53 <Axman6> > fmap show (Right False)
05:48:54 <Beelsebob> it's not  when working on lists
05:48:54 <lambdabot>   Right "False"
05:49:06 <Beelsebob> map works only on lists, fmap works on *any* structure that you can consider to be a container
05:49:09 <Axman6> fmap is just map, but more general
05:49:13 <Beelsebob> specifically any Functor
05:49:14 <b_jonas> oh, another improvised monad tutorial
05:49:21 <Jonno_FTW> ok
05:49:25 <b_jonas> we should collect all these from the logs and publish a book
05:49:26 <Beelsebob> so...
05:49:32 <Axman6> b_jonas: that one was actually the most helpful one for me
05:49:33 <Beelsebob> > fmap (+1) [1,2,3]
05:49:34 <lambdabot>   [2,3,4]
05:49:37 <Beelsebob> > fmap (+1) (Just 1)
05:49:38 <lambdabot>   Just 2
05:49:43 <b_jonas> Axman6: which one?
05:49:44 <Beelsebob> > fmap (+1) (Right 1)
05:49:45 <lambdabot>   Right 2
05:49:46 <quuuux> b_jonas: I was thinking more like writing an interactive fiction game, but your idea sounds good as well
05:49:47 <Axman6> http://blog.tmorris.net/20-intermediate-haskell-exercises/
05:49:51 <Beelsebob> > fmap (+1) (1,1)
05:49:52 <lambdabot>   (1,2)
05:49:59 <Beelsebob> Jonno_FTW: that seem reasonably clear?
05:50:21 <xle> Hey all.. I'm trying to implement a handshake (over TCP) and I need to construct a set of bytes manually and pack it into a String to send over an established socket... I'm not sure how to go about building the string though.. Should I just do something like [(chr 0x01), (chr 0x03), ...]?
05:50:29 <Jonno_FTW> yep
05:50:50 <Beelsebob> Jonno_FTW: okay, so the next level up... we've looked at applying functions to arguments, where the argument is hidden in a container
05:50:53 <Axman6> xle: use Data.Binary from the binary package, orn the cereal package
05:50:53 <Jonno_FTW> how come fmap (+1) (1,1) returned (1,2)?
05:51:15 <Beelsebob> Jonno_FTW: because that's how fmap is defined on pairs  fmap applies the function to the second argument
05:51:19 * ski annotated "facebook1" with "same, but different" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15058#a15062>
05:51:20 <xle> Axman6: Thanks, let me take a look
05:51:21 <Beelsebob> second element rather
05:51:23 <Axman6> for the same reason fmap on a Right x does something, but it does nothing on a Left y
05:51:25 <b_jonas> haskell is a good language, we just have to write some more good libraries
05:51:40 <MoALTz_> > ((,) 1) 1
05:51:41 <lambdabot>   (1,1)
05:51:46 <osfameron> *lots* more good libraries :-)
05:51:50 <ski> Jonno_FTW : ^ see that paste for something which does the same as Twey's last paste, but is written using `do', instead
05:51:53 <osfameron> can you write a FFI to Perl? ;-)
05:51:54 <Axman6> xle: don't use strings for binary work ;)
05:52:01 * osfameron ducks
05:52:09 <Beelsebob> Jonno_FTW: so... what now, if as well as the argument being in a container, the function is too...
05:52:22 <Beelsebob> then we get to use the <*> operator to do application
05:52:24 <Beelsebob> so...
05:52:24 <xerox> the type of fmap would work for (,) x)
05:52:26 <b_jonas> osfameron: yeah, perl has some good libraries
05:52:29 <xerox> it must be the laws
05:52:38 <Beelsebob> > (Just (+1)) <*> (Just 1)
05:52:39 <lambdabot>   Just 2
05:52:54 <sinelaw> Greetings, mortals
05:52:55 <Beelsebob> > (Right (+1)) <*> (Right 1)
05:52:55 <osfameron> b_jonas: well, in recompense it has some truly awful ones.  I guess there aren't many of those on hackage yet :-)
05:52:56 <lambdabot>   No instance for (Control.Applicative.Applicative
05:52:56 <lambdabot>                     (Data....
05:53:05 <Beelsebob> oops, no instance for Either
05:53:08 <xle> Axman6: :) So I would implement the handshake protocol parameters as an abstract data type and then define the Binary instance to prepare for encoding?
05:53:15 <Beelsebob> > [(+1)] <*> [1,2,3]
05:53:15 <b_jonas> osfameron: sure
05:53:17 <Jonno_FTW> ok
05:53:18 <lambdabot>   [2,3,4]
05:53:21 <b_jonas> osfameron: you have to select among them
05:53:22 <Beelsebob> > [(+1),(*2)] <*> [1,2,3]
05:53:24 <b_jonas> wisely
05:53:26 <Axman6> xle: i can think of worse ways to do it :)
05:53:28 <lambdabot>   [2,3,4,2,4,6]
05:53:31 <b_jonas> and it still has some good libraries missing
05:53:33 <Beelsebob> Jonno_FTW: that one make sense too?
05:53:41 <ski> > fmap ($ 2) (/) 10
05:53:42 <lambdabot>   5.0
05:53:44 <b_jonas> by the way, I think I understand ZipList now
05:53:47 <osfameron> b_jonas: perl or haskell?  I guess both?
05:53:51 <b_jonas> both
05:53:54 <osfameron> yeah
05:54:02 <Jonno_FTW> yep
05:54:02 <osfameron> perl is still missing a really good version of the prelude...
05:54:12 <Beelsebob> Jonno_FTW: okay, so that one btw was called Applicative
05:54:12 <b_jonas> osfameron: nah, you have ruby for that
05:54:44 <Beelsebob> Jonno_FTW: as an asside, if we have an applicative, we can define a functor... fmap f a = (return f) <*> a
05:54:50 <Beelsebob> i.e. put the function into a container
05:54:52 <Beelsebob> then apply it
05:55:15 <b_jonas> but why doesn't ZipList have a Show instance?
05:55:27 <Beelsebob> Jonno_FTW: so then... the next step is... what if instead of having a function in a container, we have a function that *returns* an item in a container
05:55:28 <osfameron> b_jonas: we have Moose and Autobox to get most of the benefits I've seen of Ruby... does Ruby have things like groupBy, proper zip, lazy list semantics etc. (these are the things I've been recently missing in Perl tbh)
05:55:40 <mjk> i writed a haskell code, in GHCi it is ok, but when i use ghci --make demo.hs to generate a .exe file, it show the "Use `+RTS -Ksize -RTS' to increase it.", why?
05:56:02 <Jonno_FTW> ok
05:56:06 <Beelsebob> and that's what (>>=) is for doing  it takes the values in containers, and pushes them into another function
05:56:14 <b_jonas> osfameron: not real lazy lists of course, but there's something like it
05:56:18 <xle> Axman6: Do you know any examples of a network handshake implemented in Data.Binary that I can take a look at? Would be helpful to see it done once..
05:56:25 <Beelsebob> > (Just 1) >>= (return . (+1))
05:56:26 <lambdabot>   Just 2
05:56:43 <Beelsebob> it's common though to write application with the argument on the right hand side, so I prefer to use =<<
05:56:49 <b_jonas> so if you only use ZipList as a Funcor, it's the same as a normal list, right?
05:56:51 <Beelsebob> > (return . (+1)) =<< (Just 1)
05:56:52 <lambdabot>   Just 2
05:56:59 <b_jonas> it only gets different as an Applicative
05:57:04 <Beelsebob> > (return . (+1)) =<< [1,2,3]
05:57:05 <lambdabot>   [2,3,4]
05:57:14 <Beelsebob> > (return . (+1)) =<< (Right 1)
05:57:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:57:15 <lambdabot>    `Control.Monad.Error.Cla...
05:57:17 <quuuux> @pl \ a -> fmap (f a) g
05:57:17 <lambdabot> flip fmap g . f
05:57:26 <Beelsebob> bugger, either is always a problem
05:57:30 <Beelsebob> Jonno_FTW: that one make sense?
05:57:49 <Jonno_FTW> what is Right?
05:57:57 <Beelsebob> Right is one of the constructors for Either
05:58:06 <Beelsebob> data Either a b = Left a | Right b
05:58:20 <Jonno_FTW> and that is for arguments?
05:58:30 <Beelsebob> it's one possible "container" type
05:58:33 <b_jonas> osfameron: also, ruby has threading done the right way
05:58:36 <Beelsebob> an Either a b "contains" values of type b
05:58:55 <Beelsebob> so in being a container, we get to use <$>, <*> and =<< on it
05:59:00 <Axman6> ruby has threading? :O'
05:59:34 <Beelsebob> Jonno_FTW: so, =<< doesn't seem very useful, until you consider that we have several types of "container" that don't litterally wrap up values, but instead, can simply be thought of that way
05:59:48 <Beelsebob> so for example I/O can be thought of as "containing" values given to us from the real world
05:59:54 <osfameron> b_jonas: interesting.  Perl's tended to optimize for unix-forking, or cooperative multitasking instead.  I thought recent Perl's "did threads right" though, but I have to admit I've not looked into it
05:59:57 <Beelsebob> we call functions, and get back "contained" values
06:00:05 <Beelsebob> we can then join the functions together with =<<
06:00:46 <xerox> no actually fmap id = id and fmap (p.q)=(fmap p).(fmap q) would also work with (,x), I wonder why it is (x,) then.
06:00:47 <b_jonas> osfameron: recent perls have Coro, which is sort of done right, but it doesn't have the right libraries for it yet
06:01:04 <b_jonas> and threads without libraries supporting it is no good
06:01:10 <b_jonas> but at least it's actively worked on so there's hope
06:01:14 <Axman6> xle: the type doesn't work
06:01:17 <Beelsebob> xerox: right, theonly reason it's defined theother way round is that trying to write instance Functor (,a) doesn't work
06:01:22 <Axman6> uh, xerox, not xle
06:02:01 <Beelsebob> the type (,a) isn't valid
06:02:30 <b_jonas> could someone answer the actual question I've hidden among lots of nonsense?
06:02:38 <Jonno_FTW> ok
06:02:49 <b_jonas> is GetList the same as a normal list if you only use it as a Functor, not as an Applicative?
06:02:51 <Beelsebob> Jonno_FTW: does =<< make any more sense now?
06:03:03 <xerox> Beelsebob uhm. Is it because the type of the second element is yet to be fixed?
06:03:03 <Beelsebob> b_jonas: yes
06:03:11 <osfameron> b_jonas: Coro can't clone continuations, due to internals of Perl5 being WEIRD, so you can't, for example, implement monads in terms of it (it doesn't do the List monad)
06:03:19 <Jonno_FTW> sort of
06:03:22 <b_jonas> Beelsebob: thanks
06:03:31 <Beelsebob> b_jonas: it's even the same if you use applicative with only one function contained in the left-hand argument
06:03:35 <b_jonas> osfameron: oh, I don't care about that
06:03:46 <b_jonas> osfameron: I only need concurrency, not list monads
06:03:46 <osfameron> b_jonas: but I think Any::Event or similar + recent threads is alleged to be quite convenient.
06:04:05 <b_jonas> osfameron: it is, but the library could still be better, especially the file io part
06:04:10 <osfameron> b_jonas: POE or Any::Event (by the Coro author) are the classic solutions
06:04:12 <b_jonas> osfameron: and ruby has better libraries for it
06:04:15 <b_jonas> osfameron: POE sucks
06:05:16 <Beelsebob> Jonno_FTW: another aside btw, monads are actually defined in terms of "join" not >>=, which may be more or less easy to understand for you
06:05:37 <Beelsebob> join's job is to take a value that's wrapped in two layers of containers, and re-wrap it in only one layer
06:05:48 <Beelsebob> > join [[1,2],[3,4]]
06:05:49 <lambdabot>   [1,2,3,4]
06:05:52 <osfameron> b_jonas: POE's syntax sucks, yeah.  I think it's a powerful set of libraries, and you can wrap it with MooseX::POE (~name~) and Any::Event
06:05:56 <Beelsebob> > join (Just (Just 1))
06:05:57 <lambdabot>   Just 1
06:06:13 <osfameron> b_jonas: what are the equivalent Ruby libs I should look at to compare?
06:06:17 <Beelsebob> you can then define =<< using join and fmap
06:06:22 <b_jonas> osfameron: ruby has threads in the core
06:06:29 <b_jonas> osfameron: it doesn't have direct interface to the event thing
06:06:32 <Beelsebob> f =<< a = join (fmap f a)
06:06:34 <Twey> Woah
06:06:38 <b_jonas> osfameron: so you can only write programs thread-style like in concurrect haskell
06:06:39 <Twey> HPaste crash!
06:06:43 <Twey> 500 Internal Server Error
06:06:44 <Twey> 58030 5: Unable to close due to unfinalised statements
06:06:44 <b_jonas> osfameron: not even style like with anyevent
06:06:57 <b_jonas> osfameron: wait, I think we should take this to -blah
06:06:58 <Jonno_FTW> ok
06:07:03 <Beelsebob> Jonno_FTW: which reveals a bit what =<< is doing  first we grab all the values out of the functions inside the container
06:07:04 <b_jonas> sorry
06:07:10 <Beelsebob> and then we collapse the extra level of container in there
06:07:21 <osfameron> oops, yeah, sorry
06:08:09 <Jonno_FTW> hmm
06:08:13 <Jonno_FTW> eg?
06:08:23 <Beelsebob> lets do it in two stages...
06:08:52 <Beelsebob> suppose we want to figure out (return . (+1)) =<< [1,2,3]
06:09:05 <Beelsebob> we fmap (return . (+1)) over the list, and we get [[2],[3],[4]]
06:09:08 <xerox> Beelsebob if one puts the pair inside a newtype, GHC does not complain about which of the two components of the tuple one uses in the functor instance.
06:09:22 <Beelsebob> so we've done the function application stage now
06:09:28 <Beelsebob> but we've ended up with two layers of lists
06:09:34 <Beelsebob> so we join the two layers
06:09:38 <Beelsebob> and get down to [2,3,4]
06:10:12 <Beelsebob> xerox: really? neat
06:10:14 <Jonno_FTW> ok cool
06:12:30 <Beelsebob> Jonno_FTW: as a final aside, if we have a Monad, then we have an Applicative... we can define <*> with >>= ... f <*> a = f >>= \uf -> a >>= \ua -> return (uf ua)
06:12:37 <Beelsebob> but... that wasn't very pretty
06:12:45 <Beelsebob> we had to define lots of lambda expressions
06:12:57 <Beelsebob> so we invent a special syntax to deal with that
06:13:52 <Beelsebob> where f >>= \uf -> someExpression can be written as:
06:13:54 <Beelsebob> do uf <- f
06:13:56 <Beelsebob>    someExpression
06:14:17 <Beelsebob> so we can rewrite that... do {uf <- f; ua <- a; return (uf ua)}
06:14:41 <PeakerWork> @type liftM2 ($)
06:14:42 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
06:14:58 <tredontho> if i have a [[Int]] and I want all possible products, taking one element from each list, what's the best way to do that?
06:29:15 --- mode: irc.freenode.net set +o ChanServ
06:29:15 <Jonno_FTW> so now you have a word which has a score according to the sum of it's places in the alphabet
06:29:42 <HaskellLove> thanks a lot, knowing about ord now it is easy
06:29:53 <HaskellLove> i thought i will use elemIndex and it will go so slow
06:29:56 <Jonno_FTW> you know zip as well?
06:30:30 <HaskellLove> yeah know the zip family
06:30:31 <Jonno_FTW> post your solution once you get it
06:30:48 <Jonno_FTW> mine ran in 0.0156 seconds
06:30:53 <Jonno_FTW> compiled
06:32:23 <Jonno_FTW> also, you can back the other way using chr
06:32:36 <Jonno_FTW> > ord 'C'
06:32:37 <lambdabot>   67
06:32:43 <Jonno_FTW> > chr 67
06:32:44 <lambdabot>   'C'
06:32:55 <Jonno_FTW> that is useful later
06:33:05 <HaskellLove> Jonno_FTW sure... anyways i have a problem, the list of names is so big my text editor fails and I cant edit the file, haha, will have to somehow compile that file separate and then import it
06:33:10 <HaskellLove> just for the list
06:33:34 <copumpkin> > ((-) `on` ord) 'z' 'a'
06:33:35 <lambdabot>   25
06:33:41 <{newbie}> I just opened the textfile with emacs and it handled the text just fine
06:33:45 <Jonno_FTW> if you are feeling risky, you can use readFile, to import a text file
06:34:36 <Jonno_FTW> > let place c = ord c - 66 in place 'C'
06:34:38 <lambdabot>   1
06:34:48 <Jonno_FTW> > let place c = ord c - 64 in place 'C'
06:34:49 <lambdabot>   3
06:34:52 <Jonno_FTW> > let place c = ord c - 64 in place 'D'
06:34:53 <lambdabot>   4
06:34:59 <Jonno_FTW> > let place c = ord c - 64 in place 'E'
06:35:00 <lambdabot>   5
06:35:14 <Jonno_FTW> i suggest using that place to be concise
06:36:49 <HaskellLove> {newbie} u work on euler too?
06:37:04 <{newbie}> no just read the problem and solved it
06:37:18 <Jonno_FTW> what?
06:37:23 <Jonno_FTW> which question?
06:38:14 <HaskellLove> {newbie} wow, how long in haskell, you are fast?
06:38:26 <{newbie}> HaskellLove: i did it in python
06:38:29 <{newbie}> :( sry
06:38:57 <HaskellLove> what is your user on eulerproject?
06:39:57 <Jonno_FTW> i solved one of the higher up questions by hand the other day
06:40:10 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=79
06:40:19 <Jonno_FTW> it was faster by hand than to think up some code
06:41:17 <copumpkin> I remember doing that in code
06:41:37 <copumpkin> it was fairly straightforward once you get the basic idea
06:42:34 <Jonno_FTW> doing by hand i didn't even need to look at all the entries
06:43:32 <MoALTz_> i did that one by hand too
06:43:51 <Jonno_FTW> how would code work?
06:44:11 <Jonno_FTW> i would make a list containing all digits seen so far
06:44:40 <Jonno_FTW> and then place them according to relative positions according to the attempts
06:45:22 <copumpkin> it seems like it'd be easiest in a logic language actually
06:45:24 <Axman6> Beelsebob3: wireless issues?
06:45:34 <copumpkin> something like prolog
06:45:53 <copumpkin> or haskell types :D
06:47:24 <Botje-BMS-> Jonno_FTW: make a graph, do a topological sort.
06:47:39 <Botje-BMS-> but yes, doing it by hand is easier
06:48:04 <Jonno_FTW> how about, I design a program which does it by hand
06:48:41 <Jonno_FTW> what if the passkey was 15 characters and had thousands of possibly not correct attempts?
06:49:09 <copumpkin> you have a bunch of relations between digits
06:49:26 <Jonno_FTW> i'd beat the guy with a sack of coins instead, doing it by hand
06:49:54 <Botje-BMS-> :)
06:50:03 <Jonno_FTW> or, i could make a robot to beat the guy with a sack of coins
06:56:47 <b_jonas> Jonno_FTW: can you really imagine a bank like that?
06:57:00 <b_jonas> they don't even allow you to set the pin code of your bank card to longer than four digits
06:57:55 <Jonno_FTW> :O
06:58:09 <Jonno_FTW> that's totally not safe if someone was to look over your shoulder
06:58:59 <copumpkin> my parents' banks give them little dongle thingies that generate a code for them given a challenge from the bank
06:59:15 <Jonno_FTW> hardware encrpytion sounds pretty good
06:59:54 <Axman6> copumpkin: yeah they do that here
07:00:28 <fft> Who can tell me what sense may has filter made in continuation passing style ?  i.e. what may be continuation function about ?
07:00:36 <Jonno_FTW> i have a reasonably safe password, and do ebanking through ssl
07:00:43 <Twey> Doesn't that defeat the point?  Someone can just steal it.
07:00:47 <copumpkin> fft: I didn't really understand that
07:00:53 <copumpkin> Twey: it's coupled with a secret for you too
07:00:56 <Twey> Ah, okay
07:01:07 <CalJohn> Twey: it's two factor authentication
07:01:13 <Twey>  hopefully the secret is longer than four digits?
07:01:24 <copumpkin> Twey: only two digits!
07:01:24 <copumpkin> :P
07:01:29 <Twey> >.<
07:01:36 <Twey> D'oh
07:01:56 <Jonno_FTW> 2 digits!
07:02:09 <Twey> Maybe the device self-destructs or something
07:02:12 <fft> copumpkin: Do you know what is continuation passing style ?
07:02:23 <Jonno_FTW> what happens when you get a wrong attempt?
07:02:53 <b_jonas> he has "co" in his name, so he's got to know
07:05:07 <copumpkin> fft: yes
07:07:32 <fft> copumpkin: So I have an exercise - write function filter for lists using  continuation passing style. And there'is no answer for this exercise. I made it but the continuation function is terrible so maybe more elegant solution exists
07:08:04 <copumpkin> :t filter
07:08:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:08:18 <copumpkin> (a -> Bool) -> [a] -> ([a] -> r) -> r ?
07:08:24 <fft> copumpkin: * I don't like my continuation function and have no ide of what clear sense it should have
07:08:42 <fft> copumpkin: *have no idea
07:09:05 <mauke> (a -> (Bool -> r) -> r) -> [a] -> ([a] -> r) -> r ?
07:09:46 <HaskellLove> ghc-6.8.2: panic! (the 'impossible' happened)  (GHC version 6.8.2 for i386-unknown-linux):	linkBCO: >= 64k insns in BCO
07:09:47 <HaskellLove> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug ---------------------- This is what happens when i load a file which only has a list with the names from euler 22
07:10:07 <Jonno_FTW> i suggest upgrade
07:10:10 <Jonno_FTW> your ghc
07:10:20 <copumpkin> don't put lots of static data in a .hs file
07:10:41 <HaskellLove> copumpkin static data?
07:11:09 <copumpkin> put code in your .hs files :P
07:11:15 <copumpkin> keep data in separate files
07:11:26 <copumpkin> (and you know what I mean)
07:11:34 <Jonno_FTW> in that case figure out the correct usage or readFile
07:12:18 <HaskellLove> copumpkin so I should separate this 1000 names list file in several maybe?  Jonno_FTW update? in synaptic that is the newest...
07:12:42 <Jonno_FTW> 6.12 is the newest
07:13:15 <copumpkin> HaskellLove: just use the original file and read it into your program
07:13:44 <HaskellLove> copumpkin yeah that is what i do... ok.. let me upgrade and try
07:13:52 <copumpkin> no
07:13:57 <fft> copumpkin: What did you mean ?
07:14:21 <copumpkin> fft: where do you want the continuations? my answer is continuation-based, I guess, but it's not particularly interesting
07:16:03 <Jonno_FTW> is it a good idea to update to 6.12 now?
07:18:32 <HaskellLove> Jonno_FTW I am downloading it so I will find out soon, if my system goes wackoo or martians land on my desktop
07:19:59 <beutdeuce>  which one is faster? filter' f coll = [ x | x <- coll if x % 2 == 0 then x] or filter' f coll = foldr (\x xs -> if f x then x : xs else xs) [] coll
07:20:19 <fft> copumpkin: where... I don't know. My function which decides what to do further takes 2 arguments - list element and Bool based on filter's predicate to decide wheter connect element to list.  This is rather weird.  P.S. If you wrote somethiing other than function type retype it please. Because I had a disconnect.
07:20:40 <copumpkin> no, that's all I wrote
07:20:44 <copumpkin> mauke wrote another version
07:21:23 <copumpkin> I'm not sure if you want to write filter itself using continuations or just want to have its external behavior be CPS-ish
07:21:55 <dh_> Happy holiday guys.  I have a question when reading http://www.cs.hmc.edu/courses/2006/spring/cs182-3/  , it's about lambda and fix point combinator,  it defines append = x r.x.y.
07:21:56 <dh_> lcase x of (y, h.t.h : (r t y)) , which I cannot understand. any help?
07:21:57 <b_jonas> does the first one even compiler?
07:22:04 <mauke> beutdeuce: which one compiles?
07:22:05 <b_jonas> @undo filter' f coll = [ x | x <- coll if x % 2 == 0 then x]
07:22:05 <lambdabot>  Parse error at "=" (column 16)
07:22:32 <beutdeuce> filter' f coll = [ x | x <- coll, x `div` 2 == 0]
07:22:50 <copumpkin> @@ @pl @undo [ x | x <- coll if x % 2 == 0 then x]
07:22:50 <lambdabot>  Parse error at "if" (column 17)
07:22:56 <beutdeuce> filter' f coll = [ x | x <- coll, x `mod` 2 == 0] rather
07:23:01 <b_jonas> I see
07:23:04 <Axman6> beutdeuce: there's no such thing as if then in haskell
07:23:17 <mauke> @undo [ x | x <- coll, x `mod` 2 == 0]
07:23:18 <lambdabot> concatMap (\ x -> if x `mod` 2 == 0 then [x] else []) coll
07:23:27 <mauke> @src map
07:23:28 <lambdabot> map _ []     = []
07:23:28 <lambdabot> map f (x:xs) = f x : map f xs
07:23:49 <mauke> beutdeuce: looks like it's the same internally
07:23:52 <Axman6> only if then else. and list comprehensions can only have either list expressions, or boolean expressions in them
07:24:09 <copumpkin> if p then True else False
07:24:10 <fft> copumpkin: http://pastie.org/757792
07:24:15 <copumpkin> yay, it's boolean now :P
07:24:44 <copumpkin> @pl (\y g -> g y (p y))
07:24:45 <lambdabot> ap (flip . flip id) p
07:25:15 <mauke> cfilter' looks wrong
07:25:18 <copumpkin> @pl (\g p y -> g y (p y))
07:25:18 <Axman6> argh
07:25:23 <lambdabot> ap
07:25:53 <copumpkin> fft: the lambda you're passing cfilter is essentially ap
07:25:59 <copumpkin> or S
07:26:01 <b_jonas> also odd is in the prelude
07:26:38 <Saizan> dh_: so that in haskell would be "append = fix $ \r x y -> case x of [] -> y; (h:t) -> h : r t y" ?
07:27:29 <dh_> Saizan: I guess,
07:27:45 <b_jonas> isn't that just identity that way?
07:27:52 <b_jonas> oh, I see
07:27:55 <b_jonas> it's not
07:27:57 <b_jonas> sorry
07:30:28 <Saizan> dh_: if you think that r = append there it should make sense
07:30:35 <fft> copumpkin: it works
07:30:58 <dh_> Saizan: yes , that part I can figure out . but why \h.\t ?
07:31:46 <Saizan> dh_: that's because lcase implements "pattern matching" by passing the fields of the constructor to the corresponding handler
07:32:21 <Saizan> ?type let lcase [] (z,_) = z; lcase (x:xs) (_,f) = f x xs in lcase
07:32:22 <lambdabot> forall t t1. [t] -> (t1, t -> [t] -> t1) -> t1
07:32:38 <dh_> Saizan: this Icase is something new to me .
07:33:01 <dh_> Saizan: how did u find out the Icase thing ?
07:33:48 <Saizan> dh_: it looked like "lcase" (with an el) above, however i'm just guessing, since it makes sense like this
07:34:15 <MoALTz_> > [x (y []) | x <- id:[(1:),(2:),(3:)], y <- id:[(1:),(2:),(3:)]]  -- very ugly code
07:34:16 <lambdabot>   [[],[1],[2],[3],[1],[1,1],[1,2],[1,3],[2],[2,1],[2,2],[2,3],[3],[3,1],[3,2]...
07:34:34 <Saizan> it's similar to maybe or either in haskell, except for the tupling and 'of' syntax
07:34:38 <Saizan> ?src maybe
07:34:38 <lambdabot> maybe n _ Nothing  = n
07:34:38 <lambdabot> maybe _ f (Just x) = f x
07:34:42 <Saizan> ?src either
07:34:42 <lambdabot> either f _ (Left x)     =  f x
07:34:42 <lambdabot> either _ g (Right y)    =  g y
07:34:49 <dh_> Saizan : ok, thanks. It's coming from a lecture notes, many details are ignored. I believe your guess are correct ,
07:36:14 <Saizan_> dh_: i'd imagine lcase was defined somewhere else in the slides or during the lectures
07:36:59 <dh_> Saizan_: It doesn't matter any more, because I believe your guess is correct :)
07:38:13 <dh_> Is it possible to use map and reduce to replace fix point combinator ?
07:38:34 <dh_> for example , fact n = reduce (*) [1.. ]
07:38:54 <copumpkin> no
07:39:05 <dh_> copumpkin : to me ?
07:39:09 <copumpkin> unless you're talking about specific cases
07:39:23 <b_jonas> agreed
07:39:28 <pardus> is hpaste.org down?
07:39:37 <dh_> copumpkin: I'm talking about in general. any counter example?
07:39:42 <b_jonas> unless maybe you allow infinite lists
07:39:59 <b_jonas> if you only take finite lists, then map and reduce won't make you turing complete
07:40:10 <b_jonas> if you have an infinite list then they do, but not easily
07:40:27 <dh_> b_jonas: where I can find more information on that ?
07:40:57 <dh_> I guess to prove turning completeness, I need to represent recursive function first, right ?
07:41:26 <Saizan_> fix is exactly how you add general recursion to a strongly normalizing lambda calculus
07:42:03 <Twey> :t fmap (undefined :: a -> b -> c) (undefined :: Functor f => f a) <*> (undefined :: Functor f => f b)
07:42:04 <lambdabot> forall c (f :: * -> *). (Applicative f) => f c
07:42:11 <mauke> dh_: how do you write [1 ..] without fix?
07:42:21 <b_jonas> about the firrst one not being turing complete? the second one is because you can emulate classical turing machines (with tapes you know) with cellular automata, which you can represend with an infinite loop (which is reduce over an infinite list
07:42:23 <Saizan_> but you can add recursive types and folds over them without adding fix, this is explained in "recursive types for free" for example
07:42:56 <Saizan_> mauke: unfoldr!
07:42:57 <Twey> @hoogle Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:42:57 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:42:57 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:42:57 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:43:03 <Twey> Ah
07:44:00 <dh_> mauke:  let nats = 0 : (map (+1) nats)
07:44:11 <dh_> I didn't use fix
07:44:12 <mauke> dh_: that uses fix internally
07:44:12 <copumpkin> dh_: that's implicitly using fix
07:44:14 <Saizan_> there's also an article in The Monad Reader which at the end implements fix with foldr over an infinite list, "getting a fix from the right foldr" iirc
07:44:18 <mauke> it's a recursive binding
07:44:40 <mauke> of course, if your language has recursion built in, you don't need fix in a library
07:44:42 <copumpkin> let nats = 0 : (map (+1) nats) ===> fix (\nats -> 0 : (map (+1) nats))
07:45:30 <b_jonas> yep, you can even do that more directly
07:45:40 <dh_> I see , thanks !
07:45:52 <b_jonas> with only recursive data types, no let-recursive definitions
07:49:49 <dh_> the reason that I prefer map , reduce over  Y combinator is : it's seemed more nature for me.   for example. length a = reduce  + ( map (\x -> 1 ) a )
07:50:12 <dh_> :t reduce
07:50:13 <lambdabot> Expr -> Expr
07:50:24 <dh_> :src reduce
07:50:31 <Saizan_> it's called foldl1' in haskell
07:50:41 <Saizan_> or foldr1
07:50:52 <dh_> @src foldr1
07:50:52 <lambdabot> foldr1 _ [x]    = x
07:50:52 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
07:50:52 <lambdabot> foldr1 _ []     = undefined
07:50:54 <Saizan_> depends how you actually want to work
07:51:05 <Saizan_> "it"
07:51:51 <copumpkin> dh_: yeah, nobody actually likes using fix
07:52:07 <dh_> and also, if the operator to be reduced is associative , we get O(log n) instead of O (n) in fixed
07:52:11 <copumpkin> dh_: it's like writing explicit recursion. We avoid it if we can, and tend to use other recursion patterns when we can see specific ones that fit
07:52:38 <dh_> copumpkin : thanks. we are other recursion patterns?
07:53:16 <Saizan_> you can implement reduce with fix, of course
07:53:28 <copumpkin> map/fold/scan/mapAccum mostly, or *morphisms if you like looking at it from a more abstract viewpoint
07:54:37 <dh_> Saizan_: yes , I have the definition of reduce by fix here. fix is so powerful !
07:55:08 <b_jonas> don't forget find
07:55:09 <dh_> copumpkin: what's that morphisims are you talking about?
07:55:18 <dh_> :t find
07:55:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:55:42 <copumpkin> dh_: http://comonad.com/reader/2009/recursion-schemes/
07:55:44 <b_jonas> I think the four basic recursion patterns are the five -ect methods of smalltalk: collect (map), detect (find), inject (fold), select (filer)
07:55:56 <b_jonas> they all take a function
07:56:01 <copumpkin> dh_: look up bananas/lenses/barbed wire for the original paper on that stuff
07:56:02 <b_jonas> there's also reverse and concat which don't
07:56:48 <copumpkin> not sure I'd consider find and filter recursion schemes
07:56:52 <Saizan_> i wouldn't call find, reverse and concat "recursion patterns" but it's not a formal term so hey :)
07:57:10 <copumpkin> :)
07:57:42 <dh_> copumpkin: I'm still not mathematically mature enough to understand category , but I'm on the way . thanks.
07:58:05 <b_jonas> they need these four because of strictness
08:00:28 <b_jonas> I mean, in a lazy language you can just use listToMaybe filter f l instead of find f l
08:00:33 <b_jonas> but you can't do that in a strict languge
08:06:52 <Axman6> hmm, looks like i'm heading for srs biznes next semester, the high performance scientific computing course will be my first C++ course :o
08:07:30 <copumpkin> ugh :P
08:07:49 <dansa> sends shivers down my spine
08:08:06 <Axman6> i'm sure it won't be so bad
08:08:10 <koeien37> well, for high performance scientific computing, Haskell wouldn't be the first language that comes to my mind
08:08:12 <Jafet> You can write C++ in a relatively clean style
08:08:21 <Jafet> Compared to, er, some other common languages
08:08:22 <Axman6> koeien37: it's one of my first
08:08:28 <koeien37> lots of algorithms are described in an imperative style
08:08:42 <koeien37> I'd use C before Haskell, I guess
08:08:43 <pozic> koeien37: the parallel array sublanguages of Haskell are suitable however.
08:08:46 <copumpkin> koeien37: only because those describing them know no better
08:08:55 <koeien37> copumpkin: agreed. But it's a fact of life
08:09:16 <copumpkin> koeien37: takes some extra effort to think about functionalizing them but I think it's worth it
08:09:32 <Jafet> (Did I hear someone dissin' dem meister Don?)
08:10:05 <koeien37> But if you can use something like hmatrix, that would be even better than using C directly
08:10:27 <Axman6> yup
08:10:29 <jlouis> it is all about getting the right abstraction
08:10:37 <b_jonas> or you can mix stuff
08:10:44 <jlouis> so you don't end up killing yourself with a banana
08:12:00 <Jafet> Well, we have Okasaki, Hinze and Patterson
08:12:02 <Jafet> All will work out
08:19:43 <i_am_neuron> What is the usual subject domain modeling approach in Haskell? I'm developing an application that works extensively with the network and need to model some of the primitives I'm going to send/receive. After defining some typeclasses for them I found myself passing an instance of it to every function of typeclass (like this: 'class Foo a where foo :: a -> IO ()', etc), i.e. I'm clearly trying...
08:19:44 <i_am_neuron> ...to model OOP's 'this'/'self' reference. What are your advices to avoid that?
08:20:38 <osfameron> i_am_neuron: currying?
08:21:24 <i_am_neuron> osfameron: errrm, maybe elaborate more? I'm not sure how currying helps against this
08:22:03 <osfameron> well, instead of:  fun self arg1 arg2, you can do: let fun = fun self;  fun arg1 arg2
08:22:22 <osfameron> I think that isn't what you meant though perhaps...
08:22:28 <aavogt> i_am_neuron: if all your members have that form, you could use   data X = X { a,b,c :: IO () }
08:23:10 <i_am_neuron> osfameron: Yeah, not really that. I want to avoid having self in the first place as this does not seem too idiomatic to me
08:23:27 <i_am_neuron> osfameron: this is not Python, after all
08:24:06 <xle> Hey all, I keep getting the following error on my linux box when trying to compile: Binary: Int64 truncated to fit in 32 bit Int
08:24:06 <xle> ghc: panic! (the 'impossible' happened)
08:24:21 <xle> the same code compiles on my os x box though
08:24:27 <i_am_neuron> With this self I'm trying to carry around some variable's state, i.e. modeling OOP again
08:24:27 <Saizan_> i_am_neuron: using lots of typeclasses is often a sign you're doing it wrong :) especially if you're a beginner coming from OOP, though we'd need more context to tell
08:24:29 <xle> Anyone had this problem before?
08:25:04 <osfameron> the impossible is always happening to me yeah ;-)
08:25:11 <xle> osfameron: haha :)
08:25:18 <xle> oh and it also says: "Prelude.chr: bad argument"
08:25:37 <quuuux> is there a way to make GHCi unify two types, and show what's been unified with what, without actually trying too hard to realise it? I'm playing around with functional dependencies, and the 'Ambiguous type variables' errors are grating on my nerves
08:25:37 <b_jonas> using lots of anything can be a bad sign
08:25:41 <Saizan_> xle: did you copy some .hi files over from one box to the other?
08:26:03 <xle> Saizan_: I thought of the same thing, but deleted all the hi files..
08:26:14 <xle> Saizan_: Ow, scratch that! I left some in a subdir
08:26:18 <xle> Saizan_: Thanks :)
08:26:20 <koeien37> heh
08:26:27 <b_jonas> quuuux: '_ = asTypeOf (undefined :: type1) (undefined :: type2)' can unify two types and show the error, but not what's unified with what
08:26:35 <koeien37> that was quick, Saizan_ :)
08:26:41 <xle> He's good :)
08:26:46 <b_jonas> quuuux: add a let if it's in the ghci prompt
08:27:05 <b_jonas> quuuux: :t can show the unified type
08:27:35 <Saizan_> well, i've overheard enough about the internals to make educated guesses :)
08:28:07 <i_am_neuron> Saizan_: Yeah, I expected that I;m doing something wrong. Basically what I'm developing is a Twisted-like framework for network protocols. I got several typeclasses here: Reactor a where listen :: (Factory b) => a -> PortNumber -> b -> a; then Factory a where buildProtocol :: (Protocol b) => a -> b; and then Protocol a where connectionMade :: a -> IO a; dataReceived :: a -> String -> IO a,...
08:28:07 <i_am_neuron> ...etc Looks more like OOP to me :)
08:28:50 <jlouis> i_am_neuron: why do you want twisted for Haskell?
08:29:05 <i_am_neuron> jlouis: excercise
08:29:13 <mreh> join #lilypond
08:29:19 <mreh> ups
08:29:26 <Saizan_> i_am_neuron: mmh, i'd move them to be just functions or records of functions
08:29:45 <Okito> HELLO!
08:29:53 <copumpkin> HELLO TO YOU!
08:30:08 <Okito> HOW ARE YOU GUYS?
08:30:24 <i_am_neuron> Saizan_: you mean move this away form typeclass, just to be exposed from some module, right?
08:30:26 <Saizan_> i_am_neuron: e.g. newtype Reactor = R (forall b. Factory b => a -> PortNumber -> Reactor), and then i'd transform Factory too
08:30:32 <Saizan_> i_am_neuron: oh, ops
08:30:37 <Okito> What is this chat about?
08:30:48 <mauke> Okito: Haskell
08:30:49 <Saizan_> i_am_neuron: i meant "newtype Reactor = R (forall b. Factory b => PortNumber -> Reactor)"
08:30:57 <mreh> Okito: Golf
08:31:05 <b_jonas> eek
08:31:12 <b_jonas> mreh: you're not serious, are you?
08:31:22 <Okito> No. I guess
08:31:23 <mreh> b_jonas: I am always serious
08:32:16 <Saizan_> i_am_neuron: well, the types should be exposed from some module, and then you get to take functions with these types as parameters
08:32:25 <Lemmih> b_jonas: Never heard of code golf?
08:32:52 <Okito> No.
08:33:16 <Okito> mauke: Coud you tell me about Haskell? i don't know it.
08:33:31 <Saizan_> i_am_neuron: the advantage is that you can create a Reactor record at runtime, hiding the "state" in the closure, while an instance has to be made at compile time so you've to take the state as parameter
08:33:33 <b_jonas> Lemmih: sure I have, but it doesn't seem like this discussion's about it
08:33:35 <mreh> Okito, you made it this far, how much do you know?
08:33:38 <Okito> I don't know what is it :S
08:33:51 <mreh> Okito: it's a programming language
08:33:53 <mauke> Okito: how did you find this channel?
08:34:02 <Okito> i choose a chat without knowing what it was about
08:34:06 <Okito> chose*
08:34:07 <mreh> :)
08:34:11 <Saizan_> i_am_neuron: well, there's actualyl some hackery to make instances at runtime too, but that's maybe for later :)
08:34:37 <Saizan_> i_am_neuron: this might help http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
08:34:55 <Okito> I chose it randomly
08:35:00 <i_am_neuron> Saizan_: I probably start sound too noob. In your last example constructor R takes function as argument, and use it to do all the machinery, right?
08:35:08 <Okito> mreh: I Chose it randomly
08:35:09 <b_jonas> code golf id when you throw unintelligable strings at each other like -lp sub k{my$t;$t=~y/IVXLC/XLCDM/,$t.=("",I,II,III,IV,V,VI,VII,VIII,IX)[$_]for/./g;$$t=$_;$t}y/iul-z/-$+ /;k for s''$'..4e3;$_=k$_=eval
08:35:18 <i_am_neuron> Saizan_: thanks for the link!
08:35:42 <mreh> is b_jonas feeling ok?
08:35:56 <Okito> ?
08:35:59 <mreh> I was once given the task of writing a roman numeral decoder
08:36:02 <xerox> b_jonas I wrote a series of classes that let you only write well-formed roman numerals!
08:36:06 <mreh> that reminds me of that
08:36:08 <mauke> b_jonas: that's pretty readable, actually
08:36:12 <Saizan_> i_am_neuron: well, the contructor just packs the function, which is the one doing everything, i had to use a newtype because Reactor appears recursively in the result of the function
08:36:15 <mauke> I've seen worse Haskell golf code
08:36:22 <Okito> well goodbye ^^
08:36:23 <b_jonas> mauke: yep, I know, I'm not a good golfer
08:37:05 <b_jonas> mauke: the winning entry is less readable
08:37:19 <b_jonas> mauke: this is that famous fonalty golf challenge in case you know it
08:37:30 <dh_> @src foldl
08:37:30 <lambdabot> foldl f z []     = z
08:37:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:37:42 <b_jonas> if you don't, that's a pity, for they've taken it down from their homepage and so the submissions can't be found anywhere on the net now
08:37:57 <mreh> is golf actually relevant to haskell then?
08:38:18 <mreh> am I missing something?
08:38:21 <dh_> @help
08:38:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:38:28 <dh_> @list
08:38:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:38:37 <HaskellLove> how do you make difference on lists in haskell?
08:38:53 <mreh> HaskellLove: clarify please
08:38:58 <Jonno_FTW> intersectBy
08:39:09 <mreh> set difference?
08:39:12 <koeien37> (\\) ?
08:39:19 <koeien37> > [1,2,3,1] \\ [2,1]
08:39:20 <lambdabot>   [3,1]
08:39:36 <HaskellLove> haha i cant beleive it :D coool
08:39:42 <b_jonas> mreh: dunno, you mentioned golf first, didn't you?
08:39:49 <dh_> :t (\\)
08:39:50 <mreh> HaskellLove, use nub if you want to make it a set
08:39:50 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
08:39:57 <i_am_neuron> Saizan_: thanks, I think I got it now
08:40:02 <koeien37> use Data.Set if you want to make it a set...
08:40:03 <dh_> @src \\
08:40:03 <lambdabot> (\\) = foldl (flip delete)
08:40:20 <osfameron> uh?
08:40:22 <dh_> @src flip
08:40:22 <lambdabot> flip f x y = f y x
08:40:28 <dh_> @src delete
08:40:28 <lambdabot> delete = deleteBy (==)
08:40:31 <mreh> b_jonas: I was exploring new territory of #haskell
08:40:43 <mreh> I didn't realise golf was anything other than a game with sticks
08:40:56 <koeien37> dh_: instead of looking at definitions, first look at the types
08:40:56 <dh_> I'll use lambdabot locally .
08:40:56 <i_am_neuron> jlouis: BTW, do you think Twisted for Haskell is not worth the effort?
08:41:05 <b_jonas> now I'm really not getting you
08:41:12 <xerox> dh_ either that or /query lambdabot
08:41:20 <b_jonas> oh, I see
08:41:24 <dh_> koeien37: I prefer @src then @type.
08:41:37 <mreh> s/of/in/
08:41:43 <koeien37> whatever you want :) IME looking at the types first is illuminating
08:42:27 <dh_> xerox: thanks for the /query lambdabot !!
08:43:19 <dh_> I'm kind of hate types because of C++, but now I find that I'm wrong. type is good, just C++ destroied everything.
08:43:35 <koeien37> you mean static typing?
08:43:44 <skorpan> untyped ftw
08:43:49 <skorpan> mirc scripting <3
08:43:53 <mreh> boo
08:43:55 <koeien37> assembler <3
08:44:03 <dh_> static typing is not that bad in haskell, but in C++, .... template, I hate it.
08:44:03 <mreh> machine code <3
08:44:12 <skorpan> M-x butterfly RET <3
08:44:15 <mreh> i am so much more hard-core than everyone
08:44:26 <mreh> punch-cards <3
08:45:14 <b_jonas> I always like the languages I'm not coding in currently
08:45:21 <b_jonas> after coding in any language I'll grow to hate it
08:45:39 <koeien37> there are the languages that everybody complains about, and the languages that nobody uses
08:45:42 <mreh> not Haskell surely?
08:45:58 <dh_> I still falling in love with python, and begin to love haskell.
08:46:03 <HaskellLove> hmm anyone has the answer for euler 23 so i compare to mine and see how much wrong i am? mine is 297633056
08:46:16 <koeien37> can you link to it?
08:46:55 <copumpkin> HaskellLove: way too big
08:47:01 <copumpkin> http://projecteuler.net/index.php?section=problems&id=23
08:47:03 <Jonno_FTW> it should be in the order 10^7
08:47:10 <HaskellLove> ok
08:47:37 <Jonno_FTW> *10^6
08:48:47 <increpare> Hey guys; just trying to convert some IO code to ST code - but having a few small troubles passing the state around.  Put together a small toy case to try convert, if someone could advise?  -> http://pastebin.com/m31259eed
08:51:12 <copumpkin> increpare: you can't pattern match on a MyData if your input is an ST
08:51:45 <increpare> copumpkin: oh, right!
08:53:17 <copumpkin> :)
08:54:53 <increpare> copumpkin: oh.  it compiles now.  All of the extra state annotations are a bit blech, but I think I can live with them.
08:55:10 <copumpkin> :)
08:56:38 <mreh> hpaste is down
08:56:52 <mreh> is anyone aware of a good alternative?
08:57:08 <increpare> mreh: pastebin does haskell highlighting - it's ok
08:57:12 <Twey> I usually use paste.lisp.org
08:57:25 <Twey> pastebin.com is slow, popup-filled, and mangles Unicode
08:57:34 <Twey> pastebin.ca works
08:57:38 <holmak> I like paste2, myself
08:57:41 <copumpkin> or moonpatio.com
08:57:49 <Twey> Ooh
08:57:55 <Twey> I thought that moonpatio.com was hpaste.org
08:58:07 <copumpkin> same owner, different server :)
08:58:10 <increpare> Twey: ah, well moonpatio is the perfect fallback then : )
08:58:14 <mreh> oh
08:58:36 <Twey> Indeed
08:58:37 <mreh> i was going to paste some lilypond source anyway
08:58:44 <mauke> see also http://mauke.ath.cx/stuff/perl/pastebin
08:58:55 <Twey> It's in Perl ;)
08:58:59 <b_jonas> they both suck, but if you enter the pastebin.com or pastebin.ca url to #buubot, the bot copies the paste to its own saner pastebin
08:58:59 <increpare> mreh: oooh what've you been doing with lilypond?
08:59:12 <mreh> increpare: just playing, http://pastebin.com/d3ead7b91
08:59:15 <mreh> this is so buggy
08:59:34 <Twey> b_jonas: Is that erxz.com?  You could also just enter it there in the first place :
08:59:41 <mreh> I get colons after the dotted notes! and the automatically split note's second half has no stem
08:59:46 <b_jonas> Twey: sure, but this helps if someone else pastes to those pastebins
08:59:49 <mreh> increpare: compile it and see what you get
08:59:50 <Twey> True
08:59:54 <b_jonas> and you want to read them
09:00:10 <mreh> increpare: the ultimate goal is a haskore-lilypond library
09:00:27 <increpare> mreh: I'm pretty sure I can see what I'll get ... three high Cs
09:00:28 <dh_> >foldr (:) [3,4] [1,2]
09:00:32 <mreh> i'm keeping it simple and transcribing single mono-phonic lines
09:00:52 <increpare> mreh: ah, cool - with haskore backend?
09:01:26 <mreh> increpare: pay close attention to the formatting, the dotted "half note" followed by a half-note should get split, but it does something weired
09:01:34 <mreh> icrepare: yeah, haskore backend
09:01:39 <dh_> does anybody knows why foldr is not working in above example ? it's working in ghci
09:01:57 <mreh> > foldr (:) [3,4] [1,2]
09:01:58 <lambdabot>   [1,2,3,4]
09:01:58 * increpare isn't a particularly big fan of haskore - always ends up rolling my own things because it never seems to quite fit what I need
09:02:09 <dh_> > foldr (:) [3,4] [1,2]
09:02:10 <lambdabot>   [1,2,3,4]
09:02:22 <dh_> >foldr (:) [3,4] [1,2]
09:02:26 <dh_> oh, space ...
09:02:30 <increpare> mreh: I don't have lilypond installed right now - I'll take your word that it's not quite working
09:02:36 <mreh> increpare: it's pretty heavyweight, but I just spend the weekend getting used to it, what kind of things did you want to do?
09:02:38 <tzzt> > foldl (:) [3,4] [1,2]
09:02:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:03:16 <kuribas> mreh: Do you know pmw, it has easier syntax than lilypond.
09:03:22 <kuribas> ?
09:03:23 <increpare> mreh: some counterpoint and harmony generation-related stuff
09:03:47 <mreh> kuribas: no
09:04:06 <mreh> kuribas: got link?
09:04:33 <chrisdone> i can has link?
09:04:38 <kuribas> http://www.quercite.com/pmw.html
09:05:27 <kuribas> The output isn't as nice, but I find lilypond too unstable for serious use.
09:05:48 <kuribas> And it can handle complicated scores as well.
09:05:55 <_oggy> hi, can anybody tell me what does "!" do in a datatype definition?
09:06:14 <holmak> strict evaluation
09:06:28 <holmak> that member of the type won't be thunked
09:06:30 <copumpkin> it means that when you use the constructor it puts an implicit seq in there
09:06:32 <mreh> kuribas: the examples appear to be printed with white ink, that or it's a postscript format my viewer doesn't know
09:06:36 <_oggy> thanks!
09:07:16 <kuribas> mreh: I can see them without problems (using gv).
09:08:43 <ketil> is it possible to make  a program loop by adding a few par's?
09:08:56 <copumpkin> nope
09:09:02 <copumpkin> shouldn't be, I hope
09:11:29 <ketil> Wow!  I've done the impossible!
09:11:48 <ketil> "The impossible happened." as GHC likes to say.
09:12:20 <ketil> I suspect the explanation is more mundane....but this just worked with -N2, and got stuck for hours halfway through with N4.
09:12:23 <ketil> Weird.
09:13:43 <ketil> The Joys of Parallel Programming, Joy #82: Good news is that at least my program is consuming more CPU than before....bad news is, that it doesn't finish doing it.
09:14:05 <HaskellLove> is there a function to remove duplicates from a list? I looked at all commands and found none, is there other way?
09:14:10 <copumpkin> nub
09:14:10 <koeien37> nub
09:14:12 <mreh> HaskellLove nub
09:14:19 <mreh> I told you this already :)
09:14:19 <copumpkin> anyone else?
09:14:26 <benmachine> nub
09:14:33 <copumpkin> map head . group . sort
09:14:44 <koeien37> unstable
09:14:44 <mreh> i started typing it, I might have well have finished
09:14:57 <HaskellLove> wow this compumpkin guy is a real ninja, that was cool thanks
09:15:00 <benmachine> > nub []
09:15:01 <lambdabot>   []
09:15:07 <copumpkin> lol
09:15:09 <koeien37> > nub [3,2,1]
09:15:10 <lambdabot>   [3,2,1]
09:15:11 <benmachine> > map head . group . sort $ []
09:15:12 <lambdabot>   []
09:15:20 <koeien37> > let nub' = map head . group . sort in nub [3,2,1]
09:15:20 <lambdabot>   [3,2,1]
09:15:21 <benmachine> oh I suppose that makes sense
09:15:28 * mreh .o0(Nobody loves me)
09:15:28 <koeien37> > let nub' = map head . group . sort in nub' [3,2,1]
09:15:29 <lambdabot>   [1,2,3]
09:15:39 <benmachine> @vixen do you love mreh
09:15:39 <lambdabot> love is a powerful word...
09:15:44 <copumpkin> it doesn't preserve order
09:15:54 <benmachine> true
09:16:08 <copumpkin> :t S.toAscList . M.fromList
09:16:09 <lambdabot>     Couldn't match expected type `S.Set a'
09:16:09 <lambdabot>            against inferred type `M.Map k a1'
09:16:09 <lambdabot>       Expected type: [(k, a1)] -> S.Set a
09:16:18 <copumpkin> :t S.toAscList . S.fromList
09:16:19 <lambdabot> forall a. (Ord a) => [a] -> [a]
09:16:30 <copumpkin> there, simplest way ever
09:16:34 <copumpkin> :P
09:16:52 <koeien37> but nub only needs Eq
09:22:44 <increpare> having trouble extracting a variable from an ST monad -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5601#a5601
09:24:02 <edwardk> i just stumbled upon http://software.legiasoft.com/quickcheck/ quickcheck for c++
09:24:22 <edwardk> alas, they are gplv3.
09:24:31 <Twey> increpare: Um, I think you should read up on monads
09:25:01 <copumpkin> increpare: forall
09:25:31 <Twey> Oh wait  I missed the runST.  Heh.
09:25:37 <Twey> Repeatedly >.<
09:25:58 <ski> increpare : try replacing `runST $ do ...' with `runST (do ...)' ?
09:26:17 <copumpkin> increpare: getInc :: (forall s. ST s (MyData s)) -> Int
09:26:19 <increpare> ski: that gives a parse error
09:26:19 <Twey> Ych
09:27:01 * increpare turns on the rank n types extension
09:27:12 <copumpkin> tada!
09:27:23 <benmachine> also, x <- m; return x translates into m >>= \x -> return x which is m >>= return which is m
09:27:46 <benmachine> would it work if you just didn't give getInc a typesig?
09:28:04 <increpare> copumpkin: hah. indeed.  this explicit statifying is more than I had anticipated : P
09:28:12 <increpare> copumpkin: thanks
09:28:12 <copumpkin> benmachine: nope
09:28:23 <gwern> edwardk: oh neat, I didn't know there was a c++ qc
09:28:28 <gwern> time to add it to the wp list
09:28:32 <copumpkin> benmachine: nope to the implicit type, that is :) the other point is definitely true
09:28:46 <benmachine> k
09:29:33 <gwern> so that makes... 12 languages with QC clones?
09:29:53 <edwardk> gwern: yeah. i haven't got enough of kata yet to bootstrap a quickcheck ;)
09:30:02 <increpare> benmachine: your shortening point acknowledged
09:35:29 <increpare> copumpkin: I'm guessing there's utility to just defining type MyBlahState = forall s . ST s (MyBlah s) ; unless maybe there's a nicer way still to do it?
09:41:26 <sjanssen> increpare: I think you might have trouble using MyBlahState
09:41:57 <increpare> sjanssen: why?
09:42:05 <ski> increpare : i'm not sure why `MyBlahState' would be better than using `Int' directly (or a `type' or `newtype' thereof) ?
09:42:47 <increpare> well in the actual code I'm doing there's a type that has a combination of STRefs and normal pieces of member data
09:43:00 <increpare> ski: not just a single int
09:43:29 <ski> hm, ok
09:43:53 <increpare> ski: I'm not sold on it being better, but if it keeps the foralls out of my hair for a short while I'll be content
09:44:19 <ski> ok. it might be useful, depending on what you're intending to do with it
09:49:50 <increpare> ski: I'll let you know how things turn out...
09:50:43 <b_jonas> you could just do everything in IO, that keeps the foralls out
09:53:39 <Jonno_FTW> @src odd
09:53:40 <lambdabot> odd = not . even
09:53:47 <Jonno_FTW> @src evem
09:53:47 <lambdabot> Source not found. You untyped fool!
09:53:49 <Jonno_FTW> @src even
09:53:50 <lambdabot> even n = n `rem` 2 == 0
09:53:53 <increpare> Jonno_FTW: :)
09:54:09 <Jonno_FTW> i was hoping for even n = not . odd
09:55:00 * increpare wasn't aware of the distinction haskell made between div and quot before
09:55:24 <Jonno_FTW> @src div
09:55:24 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:55:39 <Jonno_FTW> @src quot
09:55:40 <lambdabot> Source not found. Take a stress pill and think things over.
09:55:47 <xerox> > let { odds = map succ evens; evens = 0 : map succ odds } in transpose [evens,odds]
09:55:48 <lambdabot>   [[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,...
09:56:05 <increpare> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5603#a5603 <- something being less polymorphic than expected?
09:59:28 <increpare> is this because MyData contains STRefs?
09:59:39 <dh_> given any binary operator, is there a way to find out it's identical elements if exist ? for example, 0 for + , 1 for * , Id for compose.
10:00:11 <increpare> dh_: not in general.  You have anything in particular you're thinking about?
10:00:26 <dh_> no . just wondering.
10:00:43 <dh_> if we have , then we can simplify foldl and foldr.
10:01:20 <copumpkin> increpare: you let the universally quantified state escape!
10:01:26 * copumpkin chases it down
10:01:29 <increpare> copumpkin: :' (
10:01:44 <ski> (increpare : btw, you know you can annotate an existing paste with new related code, right ?)
10:01:47 <copumpkin> initData :: ST s (MyData s)
10:01:51 <tibbe> @seen bos
10:01:51 <lambdabot> Unknown command, try @list
10:02:09 <increpare> ski: (yep)
10:02:38 <increpare> copumpkin: guess I can try deal with the problem so hmmmmm
10:03:21 <copumpkin> increpare: it's fine, as long as you don't return the MyData s from it
10:03:47 <ski> increpare : you can't run `initData' with `runST' (directly) .. you can run it with `getInc', though
10:04:17 <copumpkin> increpare: basically, if that s appears anywhere outside, you have a problem
10:04:21 <copumpkin> :t runST
10:04:22 <lambdabot> forall a. (forall s. ST s a) -> a
10:04:38 <increpare> copumpkin: yip.  I ran intro the trouble because had one state variable nested inside another, and was trying to access the inside variable without going through the state monad in the middle
10:04:50 <copumpkin> runST on ST s (MyData s) gives you a MyData s, and that s is omg universal
10:05:03 <copumpkin> I wouldn't call ST state monad
10:05:06 <HaskellLove> hpaste does not work where do you guys past otherwise?
10:05:09 <ski> increpare : you were trying to use `runST' with argument of type `forall s. ST s (MyData s)' and result of type `MyData s' .. but `s' is not allowed to occur in the result type of `runST' (that's what the `forall s. ' in the argument type does)
10:05:10 <copumpkin> state thread if you must refer to it in english :)
10:05:12 <increpare> copumpkin: right, that's going to cause confusion >_<
10:05:29 <increpare> ski: gotcha
10:05:42 <copumpkin> HaskellLove: moonpatio.com
10:05:44 <ski> so in the type of `runST', i.e. `(forall s. ST s a) -> a', the actual type you use instead of `a' may not refer to `s'
10:05:45 <Zao> HaskellLove: http://moonpatio.com:8080 ?
10:06:25 <ski> you must first remove all `STRef s ..' parts from the result before you can use `runST' on it
10:06:46 <tibbe> sigh, which bot understands @seen ?
10:06:54 <increpare> ski: yippers - just fixing it now.  Cheers :]
10:06:54 <ski> preflex: seen tibbe
10:06:55 <preflex>  tibbe was last seen on #haskell 8 seconds ago, saying: sigh, which bot understands @seen ?
10:07:08 <tibbe> preflex: @seen bos
10:07:08 <preflex>  bos was last seen on #haskell 1 day, 11 hours, 54 minutes and 33 seconds ago, saying: the tendency on hackage is to go for numerous small packages, so fair enough
10:07:19 <tibbe> ski: I wish the bot's name contained "bot"
10:07:32 * ski has no idea who runs it
10:08:18 <copumpkin> mauke runs preflex
10:08:34 <ski> (for completeness, you can avoid removing `STRef s ..'s if you hide the `s' in an existential .. but that renders it useless)
10:09:06 * ski ponders whether one can do evil things with `Typable' or `Dynamic', here ..
10:09:34 <ski> .. i assume not, since the `s' isn't a concrete type
10:09:36 <dh_> see dh_
10:09:42 <dh_> seen dh_
10:09:44 * ski sees dh_
10:09:50 * copumpkin does too
10:09:58 <dh_> prefix: seen dh_
10:10:22 <ski> preflex: are you called "prefix" ?
10:10:31 <dh_> preflex: @seen dh_
10:10:31 <preflex>  dh_ was last seen on #haskell 33 seconds ago, saying: prefix: seen dh_
10:11:48 <tibbe> are there any papers that implements a priority queue in haskell?
10:11:50 <dh_> :t fix
10:11:51 <lambdabot> forall a. (a -> a) -> a
10:12:25 <increpare> is there a source-code formatter for haskell (like the various c++ beautifiers)
10:13:51 <dh_> what is the W combinator in haskell ?  w f x = f x x ?
10:14:14 <dh_> I mean , is it defined some where ?
10:14:14 <c_wraith> join in the (->) monad.
10:14:23 <c_wraith> > join (+) 15
10:14:24 <lambdabot>   30
10:14:25 <dh_> thanks.
10:15:07 <dh_> @src fix
10:15:07 <lambdabot> fix f = let x = f x in x
10:15:19 * ski would prefer `where', there
10:15:31 <dh_> @where fix
10:15:31 <lambdabot> I know nothing about fix.
10:15:37 <copumpkin> lol
10:15:47 <dh_> ....
10:15:49 <c_wraith> @hoogle fix
10:15:50 <lambdabot> Data.Function fix :: (a -> a) -> a
10:15:50 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
10:15:50 <lambdabot> module Control.Monad.Fix
10:15:53 <ski> (or `x@(fix f) = f x', were it allowed)
10:15:56 <dh_> thanks.
10:16:20 <ski> (.. or `fix f = x@(f x)', i suppose)
10:17:24 <copumpkin> fix f = f (fix f) => fix f = fix (\fix f -> f (fix f))
10:18:11 <dh_> how can I get the source for Data.Function fix and Control.Monad.Fix fix ?
10:18:13 <ski> @type \f -> fix $ \fix f -> f (fix f)
10:18:14 <lambdabot> forall t t1. t -> (t1 -> t1) -> t1
10:18:35 <ski> @type \f -> fix $ \fix -> f (fix f)
10:18:36 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t -> t1
10:18:36 <lambdabot>     Probable cause: `f' is applied to too many arguments
10:18:36 <lambdabot>     In the expression: f (fix f)
10:19:03 <ski> @type fix $ \fix f -> f (fix f)
10:19:05 <lambdabot> forall t. (t -> t) -> t
10:20:33 <ski> @source Control.Monad.Fix
10:20:34 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad/Fix.hs
10:20:44 <ski> @source Data.Function
10:20:44 <lambdabot> Data.Function not available
10:20:58 <dh_> @source Data.Function.fix
10:20:58 <lambdabot> Data.Function.fix not available
10:21:23 <dh_> what's the difference between Data.Function fix and Monad.Fix fix ?
10:21:24 <ski> <http://darcs.haskell.org/packages/base/Data/Function.hs> appears to actually contain `fix'
10:21:36 <benmachine> dh_: two locations for the same thing
10:21:43 <benmachine> I think
10:21:46 <ski> the source above for `Control.Monad.fix' just reexports the `Data.Function.fix' one
10:22:24 <dh_> ok. that smells bad.
10:23:24 <c_wraith> Well, it also introduces the MonadFix typeclass
10:23:41 <c_wraith> So it's not like that's all the module does.
10:23:43 <ski> why does it smell bad ?
10:25:37 <Heffalump> is it well known that cabal install 0.8.0 doesn't work in GHC 6.8.2 ?
10:27:01 <dh_> ski: 2 fix definition of the same thing. I mean, MonadFix should not export it.
10:27:52 <sshc> how does guard work with the list monad if it returns () on success?
10:28:04 <copumpkin> it destroys the effects!
10:28:07 <copumpkin> zomg
10:28:07 <Heffalump> sshc: the point is that on failure it, well, fails :-)
10:28:31 <sshc> wouldn't that get rid of the value just like mzero?
10:28:41 <Heffalump> exactly
10:28:45 <Saizan_> ?src guard
10:28:45 <lambdabot> guard True  =  return ()
10:28:45 <lambdabot> guard False =  mzero
10:28:46 <xerox> nope, it will pass () as argumentt to the next action
10:29:13 <Heffalump> oh, you mean succeeding. No, because it produces a single element list.
10:29:17 <dcoutts_> Heffalump: it's not well known. I would have expected it to work. What goes wrong?
10:29:18 <Heffalump> whereas mzero is an empty list.
10:29:23 <c_wraith> what is mzero for IO? >_>
10:29:25 <xerox> (which will ignore it if you do { guard p; amb } because that desugars to guard p >> amb
10:29:35 <Heffalump> ganesh@rocky:~$ cabal install cabal-install-0.8.0
10:29:35 <Heffalump> Resolving dependencies...
10:29:35 <Heffalump> cabal: cannot configure time-1.1.4. It requires base ==4.*
10:29:44 <Heffalump> (and then lots more explanation I could hpaste if you want)
10:30:01 <Heffalump> c_wraith: it's failure
10:30:08 <ski> dh_ : well, `Control.Monad.Fix' defines `mfix'. i think it makes some sense that if you want `mfix', you might also want `fix'
10:30:38 <c_wraith> dh_: it's not like the names will collide if you import both
10:30:39 <dcoutts_> Heffalump: oh ok, that's just the solver not being clever, use --constraint='time<1.1.4'
10:31:21 <dh_> it's about human brain's capability, I like the principle of : there is only one way of doing it.
10:31:34 <dh_> python vs perl.
10:31:41 <dh_> to reduce learning curve.
10:31:57 <benmachine> I think python vs. perl is like, reading code vs. writing it
10:32:13 <ski> `x + x' vs. `2 * x' : which should be prohibited ?
10:32:18 <Heffalump> dcoutts_: looking more promising, ta
10:32:26 <sshc> > do{ x <- [1..10]; y <- [1..10]; guard (x == y); return (x, y) }
10:32:28 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
10:32:35 <sshc> how does that work?
10:32:51 <xerox> @undo do{ x <- [1..10]; y <- [1..10]; guard (x == y); return (x, y) }
10:32:51 <lambdabot> [1 .. 10] >>= \ x -> [1 .. 10] >>= \ y -> guard (x == y) >> return (x, y)
10:33:10 <ski> > [(x,y) | x <- [1..10] , y <- [1..10] , x == y]
10:33:11 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
10:33:13 <Heffalump> dcoutts_: is there a FAQ I/you can add this to? 6.8.2 is the default in Debian so I think it's worth flagging up
10:33:18 <dcoutts_> Heffalump: the problem is the solver is making too many guesses that turn out badly. An incremental improvement would be to prune packages that cannot possibly be installed.
10:33:38 <Heffalump> it's interesting that even with that constraint I had to explicitly ask for cabal-install-0.8.0, btw.
10:33:38 <dcoutts_> Heffalump: 0.8.0 is not yet the default version you get when you cabal install cabal-install
10:33:45 <Heffalump> oh, that's why I had to explicitly ask :-)
10:33:53 <Heffalump> is that just caution?
10:33:55 <sshc> why does that work when guard returns () on success?
10:33:56 <dcoutts_> yes
10:34:19 <xerox> sshc because return (x,y) ignores the value produced by the action guard(x==y)
10:34:20 <Heffalump> I think it's still generally useful info, because I want to work with 6.12 so I needed 0.8.0
10:34:39 <Heffalump> <gone to dinner>
10:34:44 <benmachine> > return () :: [a]
10:34:45 <dcoutts_> Heffalump: right, and you were building it using 6.8.x
10:34:46 <lambdabot>   Couldn't match expected type `a' against inferred type `()'
10:34:46 <lambdabot>    `a' is a rig...
10:34:49 <benmachine> > return () :: [()]
10:34:50 <lambdabot>   [()]
10:34:58 <benmachine> > mzero :: [()]
10:34:59 <ski> `guard (x == y) >> return (x, y)' is same as `guard (x == y) >>= \_ -> return (x, y)'
10:34:59 <lambdabot>   []
10:35:23 <ski> @src (>>)
10:35:23 <lambdabot> m >> k      = m >>= \_ -> k
10:35:30 <dh_> > fix ( 2 * )
10:35:33 <lambdabot>   mueval-core: Time limit exceeded
10:35:42 <benmachine> sshc: basically, [] >>= f always evaluates to [], while [()] >>= f evaluates to f ()
10:35:49 <c_wraith> > fix $ const "hello, world"
10:35:49 <dh_> why fix ( 2 * ) stack overflow ? it should give 0
10:35:50 <lambdabot>   "hello, world"
10:36:03 <c_wraith> dh_: it never finishes evaluating
10:36:24 <dh_> so this fix defintion is wrong.
10:36:35 <dh_> because 2 * 0 = 0
10:36:35 <c_wraith> Not really
10:36:43 <copumpkin> dh_: it's not a smart fix
10:36:46 <c_wraith> it's not a solver that *finds* fixed points
10:36:49 <copumpkin> dh_: it's LEAST fixed point
10:36:51 <dh_> is there a smart fix ?
10:37:01 <copumpkin> you could probably write one for some expressions
10:37:16 <copumpkin> dh_: there's another fixed point of 0, sometimes
10:37:24 <c_wraith> > fix ("Hello! " ++)
10:37:24 <copumpkin> > 2 * (1 / 0)
10:37:25 <lambdabot>   "Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hello! Hell...
10:37:25 <lambdabot>   Infinity
10:37:26 <dh_> of 0 ?
10:37:36 <copumpkin> > 2 * (0 / 0)
10:37:37 <lambdabot>   NaN
10:37:48 <dh_> oh,  1/0 , right.
10:38:22 <ski> `_|_' is the least fixed-point of `(2 *)', in the definedness partial order
10:38:30 <dh_> if we can find a smart fix, then we can find the identity element of any binary operator.
10:38:32 <HaskellLove> anyone can criticize this code in any way regarding euler 23 please? http://paste.pocoo.org/show/159969/ I get result 383652124 which is too big, as some people here warned me but i have no idea what to do more...
10:38:55 <dh_> because identity of any binary operator op is :  fix ( join op )
10:38:56 <xerox> regarding guard, what is a good pattern that extends do { ...; guard p; return A } to "guard p" return A, "guard q" return B, and possibly more clauses?
10:39:13 <xerox> (concatenating them obviously doesn't work)
10:39:35 <copumpkin> HaskellLove: your final result is finalResult = sum $ [1..28123] \\ result
10:39:43 <copumpkin> HaskellLove: why bother writing any of the other code?
10:39:48 <copumpkin> > sum [1..28123]
10:39:50 <lambdabot>   395465626
10:40:02 <c_wraith> > fix ("" ++)
10:40:03 <copumpkin> oh
10:40:06 <lambdabot>   mueval-core: Time limit exceeded
10:40:07 <copumpkin> you subtracted result :)
10:40:25 <sshc> > mzero
10:40:26 <lambdabot>   No instance for (GHC.Show.Show (m a))
10:40:26 <lambdabot>    arising from a use of `M2176928401...
10:40:29 <ski> dh_ : well, if the domain is compact, and has decidable equality, it should work, i think
10:40:33 <sshc> > mzero :: (IO)
10:40:34 <lambdabot>   `GHC.IOBase.IO' is not applied to enough type arguments
10:40:34 <lambdabot>  Expected kind `?',...
10:40:43 <sshc> > mzero :: (IO Int)
10:40:44 <lambdabot>   <IO Int>
10:40:48 <xerox> heh
10:40:53 * ski wonders whether `has decidable equality' is the same as `is descrete'
10:40:55 <dh_> ski: what do u mean by a domain is compact ?
10:41:39 <xerox> dh_ the open sets are preimages of computable functions
10:41:47 <ski> dh_ : that the universal quantifier `forall_A :: (A -> S) -> S' is definable (where `data S = Observed')
10:42:21 <HaskellLove> copumpkin huh?
10:42:30 <ski> e.g. `forall_Bool p = p True && p False'
10:42:37 <copumpkin> HaskellLove: sorry, was confused
10:43:27 <ski> xerox : `mplus' ?
10:43:32 <xerox> ski data S = Observed is not meant as an Haskell definition right?
10:43:38 <ski> yes it is
10:43:52 <xerox> ski what is the type of (&&) ?
10:44:05 <ski>   (&&) :: S -> S -> S
10:44:14 <ski>   Observed && Observed = Observed
10:44:15 <ski> here
10:44:19 <xerox> :)
10:44:58 <HaskellLove> copumpkin confusion is not allowed and tolerated :D
10:44:59 <ski> one can also consider a `(||)' that might spawn two threads, and terminate with `Observed' as soon as one of the argument terminates with `Observed'
10:45:10 <dmhouse> What properties does this "universal quantifier" need to satisfy?
10:45:29 <dmhouse> E.g. forall_Reals r = r 0 certainly has the type (Reals -> S) -> S
10:46:01 <ski> dmhouse : that for each total `p :: A -> S', `forall_A p' terminates with `Observed' iff for every total `x :: A', `p x' terminates with `Observed'
10:46:24 <xerox> ski wonderful, mplus.
10:47:13 <dmhouse> ski: got it
10:47:41 <dmhouse> (x :: A being total just means x /= _|_, presumably.)
10:47:56 <dmhouse> (As opposed to a function being total.)
10:49:15 <ski> dmhouse : see Seemingly impossible functional programs <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>, A Haskell monad for infinite search in finite time <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>, topology in Haskell by Martin Escard <http://www.haskell.org/pipermail/haskell/2004-June/014134.html>
10:51:08 <ski> dmhouse : also see Abstract Stone Duality <http://www.paultaylor.eu/ASD/>
10:53:10 <Nomad010> cool story Taejo
10:53:36 <Taejo> embedded in it, bro
10:53:43 <Nomad010> lol
10:54:16 <Nomad010> "we put the funk in funktion"
10:54:51 <Nomad010> you also put the haskell in you has haskelled my brain
10:55:57 <osaunders> I've heard it said that programming in a functional language can improve one's imperative code? How is this true?
10:56:27 <Taejo> osaunders: maybe by making it more functional? :)
10:56:50 <monochrom> Because pure imperative programming is inconvenient.
10:57:08 <osaunders> OK, take management of state and side-effects for example.
10:57:23 <monochrom> No, take x = a+b*c for example.
10:57:56 <osaunders> In OO "tell don't ask" is considered good practice but functional programming is interrogative by nature, almost the opposite.
10:58:15 <osaunders> You don't form side-effecting operations together into larger side-effecting operations.
10:58:27 <monochrom> The a+b*c part is really functional programming. x=a+b*c is mixed functional and imperative. Pure imperative would be like high-level assembly, three-address instructions: tmp1 = b*c; x=a+tmp1. Would you like to do pure or mixed?
10:59:10 <ski> impure
10:59:48 <osaunders> There's a logical contradiction between tell don't ask (statey) being good imperative practice and functional (stateless) being good practice.
11:00:16 <ski> perhaps they are good practice in different situations ?
11:00:24 <osaunders> Forget by previous questions. The one I really want answered is how both of those are true. Or maybe they aren't.
11:00:35 <osaunders> ski: OK, which?
11:00:43 <osaunders> s/by/my/
11:01:20 <ski> i'm not sure. but maybe "tell, don't ask" is good for some simulations ?
11:02:52 <osaunders> ski: I've followed a guide of doing it wherever I can. There are places where it isn't possible. I do it the rest of the time. That works well for me.
11:03:17 <monochrom> I don't understand how "tell, don't ask" works, unless it means something other than "tell, don't ask". If everybody tells, who is the asker? Without an asker, how does a program even begin execution?
11:03:32 <BMeph> I think that is Haskell had more active development of comonads, we'd see more similarities. But then, maybe I'm just saying that to see more comonads... ;)
11:03:46 <osaunders> monochrom: It's not a universal thing. You do it wherever you can.
11:04:06 <monochrom> OK, so some parts of the program are askers.
11:04:17 <osaunders> Yes, as you point out, they have to be.
11:04:34 <ski> BMeph : well, more comonads would be a good idea in any case :)
11:04:55 <monochrom> Now, I don't understand how functional programming is "interrogative by nature".
11:05:23 <osaunders> "Tell, don't ask" summarizes the value of encapsulating logic and striving towards the identification of policy over mechanics.
11:05:30 <monochrom> Suppose I write "f x = g (g x)". Sure, f asks g. But f is written there in order to be asked too.
11:05:55 <monochrom> So, f tells, and f asks too.
11:06:37 <monochrom> f is written to tell. As an implementation detail, I decide to make the code ask g. But f's purpose is to tell.
11:06:53 <sshc> Hi, I don't understand "getAny" in the example in "http://www.haskell.org/all_about_monads/html/statemonad.html".  Since it's type signature is "getAny :: (Random a) => State StdGen a
11:07:06 * BMeph thinks that monochrom is subtily missing which meaning of "tell" and "ask" is meant in those adages...
11:07:15 <sshc> Hi, I don't understand "getAny" in the example in "http://www.haskell.org/all_about_monads/html/statemonad.html".  Since it's type signature is "getAny :: (Random a) => State StdGen a", won't it always return only one value?
11:07:18 <monochrom> And it is the same in OO too. I write an object to tell. But that object has to ask someone else in order to accomplish its job.
11:07:24 <osaunders> Ask refers to using the return value of a function in a logical decision.
11:07:33 <osaunders> (As is my understanding).
11:07:39 <ski> i think an important distinction might be that `f' here will tell anyone who asks, but will ask a specified agent (`g')
11:07:53 <osaunders> Tell performs an operation without logic or with logic hidden.
11:08:27 <osaunders> The f and g functions in your example could be telling or asking because the names don't describe anything about what they do.
11:08:51 <monochrom> So it depends on names?
11:08:58 <osaunders> It depends on what they do.
11:09:04 <ski> sshc : yes, it will always return (or actually is) the same action. that aaction, when run, may monadically yield different values
11:09:11 <BMeph> I always imagined that "tell don't ask" was about top-down control, as opposed to bottom-up coordination. I could be - and often am - wrong, though. :)
11:09:25 <osaunders> None of this answers your question about why FP is interrogative. I'm struggling to come up with an answer for that.
11:09:47 <monochrom> Then perhaps FP is not interrogative.
11:10:07 <ski> maybe LP is interrogative, then ?
11:10:26 <osaunders> monochrom: I'm thinking.
11:11:22 <osaunders> OK.
11:11:37 <osaunders> Ultimately programs are written for their effects.
11:12:05 <osaunders> In FP effects are minimized and constrained to one or a handful of areas.
11:12:39 <osaunders> The rest of the program just passes values around and makes decisions based on those values.
11:13:11 <Saizan_> after googling, "tell, don't ask" seems to be about smart data that is responsible for its own state
11:13:28 <unenough> state? bah
11:13:41 <deh_> http://www.pragprog.com/articles/tell-dont-ask
11:13:52 <osaunders> Imperative programs, especially those that "tell, don't ask" as much as possible, do nothing to minimize effects instead performing effects wherever possible and passing around less.
11:14:08 <monochrom> See, these "tell" "ask" "policy" are so MBA-type. "OO is about tell" "our company is about synergy" "our company is about our customers" (wrong, your company is about profit, read on) "revenue centre is about income" "cost centre is about spending" "our company is about expanding revenue centres and reducing cost centres" "tech support is a cost centre" "so cut tech support" (so now your company is about screwing over your cu
11:14:08 <monochrom> stomers) "and everything is an object".
11:14:11 <osaunders> TdA is good because it minimizes the amount of passing about work that happends.
11:14:17 <monochrom> @quote monochrom synergy
11:14:18 <lambdabot> monochrom says: "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
11:14:50 <unenough> and "middle-tier solutions"
11:14:53 <unenough> I hate solutions
11:15:03 <kmc> i think FP is about "compute what to do, don't spell it out"
11:15:09 <copumpkin_> we are solution architects
11:15:10 <kmc> "what to do" could be a function or an imperative action
11:15:34 <HaskellLove> I just can't understand for one hour why this gives me the wrong answer for euler 23 http://paste.pocoo.org/show/159977/
11:15:44 <osaunders> kmc: FP isn't about imperative actions so much.
11:16:00 <kmc> osaunders, depends on your definition of FP obviously
11:16:04 <copumpkin> HaskellLove: I'd wager something is wrong with your algorithm, but it's just a guess ;)
11:16:25 <kmc> in Haskell we use functions to manipulate a wide variety of data types.  some of those types represent actions to perform
11:16:30 <Saizan_> osaunders: well if your only effect is updating some variables you can just create an updated copy of yourself
11:16:32 <mreh> why can't a make a compound class implement an arbitary class?
11:16:35 <HaskellLove> copumpkin well yeah but i am banging my head, tested them all separately seems all fine but ...
11:16:49 <Saizan_> osaunders: and you can package data together with the code that manages it in this settings too
11:17:22 <unenough> FP is about immutability, about values
11:17:35 <monochrom> Anyway, in the part of your program where you collect answers and then you decide what next based on them, that's functional programming.
11:17:37 <osaunders> unenough: Yeah, I agree with that.
11:17:53 <unenough> functions are values, and so is everything else
11:17:54 <osaunders> Saizan_: Yes, good point. Those operations could be considered telling.
11:17:59 <Saizan_> i'd say that algebraic programming is more about values, but you can do coalgebraic programming in FP too
11:18:02 <osaunders> Uh, wait maybe not.
11:18:41 <copumpkin> HaskellLove: I'm guessing your sum_each_other function isn't doing what you want it to
11:18:49 <ski> mreh : i'm not sure what you're asking about ..
11:18:50 <Saizan_> osaunders: seen this? http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
11:19:26 <mreh> instance MyClass [String] where ...
11:19:35 <copumpkin> HaskellLove: seems like you want more of a [x + y | x <- nums, y <- nums]
11:19:45 <copumpkin> HaskellLove: if that's the approach you want to take (but it'll take ages)
11:20:31 <osaunders> Saizan_: Oh nice. Let me read this.
11:20:41 <mreh> ski ^
11:22:20 <ski> mreh : well, there might already be an `instance ..s.. => MyClass [a]' ..
11:22:45 <HaskellLove> copumpkin sum_each_other does exactly what i want it too. abundants also i checked it, gives me list of abundant numbers. so when i do sum_each_other abundants, i get sums from abundant numbers and then i say takeWhile <28123... crazy, i must be drunk i tested all and still don't get it where i mistake
11:22:46 <ski> though, iirc, there is some language flag you can flip, in case there aren't
11:23:04 <HaskellLove> anyone has solved euler 23, is the solution 10^7 or more?
11:23:06 <copumpkin> HaskellLove: well then maybe what you want isn't right
11:23:10 <copumpkin> HaskellLove: it's less
11:23:32 <HaskellLove> copumpkin on second thought i will go make myself lots of lemonades too :D
11:23:38 <copumpkin> :)
11:25:00 <copumpkin> _
11:27:37 <carlocci> is there some commented code archive where I can see how problems are solved with haskell?
11:28:08 <kmc> hackage.haskell.org
11:28:55 <carlocci> oh, thank you
11:34:29 <increpare> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5606 <- another "less polymorphic" error, but I'm not sure what's escaping where...
11:34:58 <HaskellLove> i am offering 1 000 000 euros for the one that will find the problem here http://paste.pocoo.org/show/159977/
11:36:20 <b_jonas> HaskellLove: zimbabwean euros?
11:36:26 <Nomad010> french euros
11:36:38 <HaskellLove> printed ones
11:36:48 <Nomad010> lol
11:37:05 <Saizan_> increpare: you should use something like "IORef (forall s. ST s (MyData s))" as input, i'd think
11:37:19 <b_jonas> I still don't understand all this foldr and writer and laziness stuff
11:37:20 <copumpkin_> increpare: omg what are you doing??
11:37:28 <copumpkin_> increpare: you need impredicative polymorphism
11:37:30 * copumpkin_ shudders
11:37:36 <augur> adhey guy
11:37:38 <augur> s
11:37:39 <augur> ..
11:37:40 <increpare> Saizan_: moving the forall inside yeah...asks for impredicateive polymorphism : (
11:37:41 <augur> hey**
11:37:42 <augur> :|
11:37:44 <augur> let me start over
11:37:46 <augur> hey guys
11:37:53 <copumpkin_> ohai
11:37:54 <increpare> copumpkin_: I'm trying to separate out my IO code into ST and IO parts
11:38:09 <augur> copumpking youve gotsomething on your chin there
11:38:14 <Saizan_> increpare: also, are you sure you want ST s (MyData s) rather than (MyData s) ?
11:38:21 <b_jonas> @src foldr
11:38:22 <lambdabot> foldr f z []     = z
11:38:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:38:23 <copumpkin_> increpare: the ST stuff should be restricted to bite-sized functions. The state doesn't escape, on purpose
11:39:24 <increpare> Saizan_: yeah : the MyData type can get pretty big, and I wouldn't want it all changing every frame - that's why i was trying to cut off the frequently mutating part of it in a separate state
11:40:04 <increpare> copumpkin_: what are the disadvantages to using impredicative types?
11:40:16 <copumpkin_> increpare: they'll be gone in GHC 6.14?
11:40:25 <increpare> copumpkin_: oh.  right.  : (
11:40:30 <copumpkin_> increpare: also, you run into russell's paradox :P
11:40:46 <Saizan_> increpare: MyData is a STRef there, it seems weird to pass around an action that produces a STRef rather than just the STRef, but if you know what you're doing ok :)
11:40:48 <increpare> copumpkin_: So maybe a redesign is in order so.  Hmmm.
11:41:22 <copumpkin_> increpare: keep in mind that keeping this fully functional might still work
11:41:31 <b_jonas> okay, so foldr is lazy
11:41:39 <b_jonas> so then writer must work in some similar way
11:41:48 * b_jonas tries to write some simple code
11:41:50 <copumpkin_> increpare: if only a few things change in your state type every iteration, the unchanging stuff will be kept (if it's boxed)
11:42:19 <increpare> copumpkin: so maybe I should just ditch ST so?
11:42:26 * increpare would quite happily ditch ST ...
11:42:48 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=24 how to make permutations lists in haskell?
11:42:56 <copumpkin_> increpare: well, maybe you shouldn't, but it's hard to say. I typically think of ST when I need an algorithm that works best with mutation but is referentially transparent
11:43:05 <copumpkin_> the STRefs never see the light of days
11:43:12 <copumpkin_> -s
11:43:13 <Saizan_> > permutations [1..10]
11:43:14 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,1,3,4,5,6,7,8,9,10],[3,2,1,4,5,6,7,8,9,10],[2,3,...
11:43:16 <copumpkin_> , permutations [1..10]
11:43:18 <lunabot>  [[1,2,3,4,5,6,7,8,9,10],[2,1,3,4,5,6,7,8,9,10],[3,2,1,4,5,6,7,8,9,10],[2,...
11:43:23 <copumpkin_> @botsnack
11:43:23 <lunabot>  :o
11:43:23 <lambdabot> :)
11:43:41 <copumpkin_> HaskellLove: ^
11:44:22 <increpare> Screw it.  I'm just going to ditch the ST stuff right now, and I'll introduce it where needed when performance calls for it.
11:44:26 <HaskellLove> i was about to check hoogle but i could not beleive there is such function, oh man i love haskell more and more, i will change my name now to HaskellDoubleLove
11:44:41 <copumpkin_> lol
11:44:44 <Nomad010> lol
11:44:47 <copumpkin_> how about DoubleCoqLove?
11:45:01 <HaskellDoubleLov> not ready for coq, patience
11:45:16 <monochrom> How about finding your self-identity?
11:45:19 <b_jonas> okay, concrete questoin
11:45:35 <copumpkin_> monochrom: what chrom did you settle on when you realized you only had one?
11:45:44 <monochrom> Black.
11:45:47 <copumpkin> or is it so monochrom that all chroms are that single chrom
11:45:50 * increpare can't find any information about impredicative types being deprecated
11:46:09 <b_jonas> this works, because of laziness:
11:46:10 <b_jonas> > take 30 (foldr (\x s -> x : x : s) [] (cycle "hello, world "))
11:46:11 <lambdabot>   "hheelllloo,,  wwoorrlldd  hhee"
11:46:12 <copumpkin> increpare: ghc mailing list
11:46:41 <b_jonas> this doesn't work obviously:
11:46:46 <b_jonas> > foldr (\x s -> succ s) (0 :: Int) (cycle "hello, world ")
11:46:47 <lambdabot>   * Exception: stack overflow
11:47:03 <increpare> copumpkin: ah found it.
11:47:04 <copumpkin> > succ "abc"
11:47:05 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
11:47:05 <lambdabot>    arising from a use of `...
11:47:48 <b_jonas> > foldr (\x s -> succ s) (0 :: Int) "hello, world " -- shoudl work for finite lists
11:47:49 <lambdabot>   13
11:47:56 <monochrom> > foldr f a [b,c]
11:47:57 <lambdabot>   f b (f c a)
11:48:25 <b_jonas> now if I do this to compute both of them,
11:48:28 <b_jonas> > take 10 (snd (foldr (\x (s, s') -> (succ s, x : x : s')) (0 :: Int, []) (cycle "hello, world ")))
11:48:29 <lambdabot>   "* Exception: stack overflow
11:48:38 <b_jonas> why doesn't that work, and how do I make it work?
11:49:20 <b_jonas> I mean,
11:49:28 <b_jonas> > snd ((\x (s, s') -> (succ s, x : x : s')) 'a' (undefined :: Int, []))
11:49:30 <lambdabot>   "aa"
11:49:38 <copumpkin> > foldr (const . (+1)) 0 [1..10]
11:49:38 <b_jonas> that function is lazy in the second part of the tuple
11:49:39 <lambdabot>   2
11:49:42 <b_jonas> so what's wrong?
11:49:49 <copumpkin> > foldr (const (+1)) 0 [1..10]
11:49:50 <lambdabot>   10
11:49:52 <monochrom> > take 10 (snd (foldr (\x ~(s, s') -> (succ s, x : x : s')) (0 :: Int, []) (cycle "hello, world ")))
11:49:53 <lambdabot>   "hheelllloo"
11:49:53 <HaskellDoubleLov> permutations [1..10] gives me  Not in scope: `permutations', and i have imported Data.List
11:49:57 <monochrom> \o/
11:50:05 <copumpkin> HaskellDoubleLov: you need to have GHC 6.10 or above
11:50:21 <b_jonas> uh
11:50:24 <monochrom> Does anyone else realize that \o/ is very difficult to type? :)
11:50:25 <b_jonas> how could that help?
11:50:47 <c_wraith> is it? /o\.  huh.  Wow, it is.
11:51:12 <b_jonas> could some of you explain?
11:51:12 <tensorpudding> it's kinda unfortunate that \ exists
11:51:15 <b_jonas> that's just strange
11:51:16 <monochrom> foldr works best with non-strict functions. \x (s,s') demands to see the tuple constructor "here and now", too strict.
11:51:45 <b_jonas> monochrom: sure, but isn't whatever is passed lazy in the tuple constructor?
11:51:49 <BMeph> \o/
11:51:53 <b_jonas> wait
11:52:00 <b_jonas> > snd ((\x (s, s') -> (succ s, x : x : s')) 'a' undefined
11:52:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:52:05 <BMeph> `\o/`
11:52:07 <monochrom> Indeed foldr (\x s -> succ s) (0 :: Int) 's problem is also that succ is too strict for Int.
11:52:29 <b_jonas> > snd ((\x (s, s') -> (succ s, x : x : s')) 'a' (undefined :: (Int, String)))
11:52:30 <lambdabot>   "* Exception: Prelude.undefined
11:52:32 <b_jonas> I see
11:52:34 <b_jonas> makes sense
11:52:35 <b_jonas> thanks
11:53:02 <monochrom> Pattern matching is strict unless told otherwise. For \ and case anyway.
11:54:35 <b_jonas> that must be how the writer monad works then
11:54:41 <b_jonas> I'll try implementing something like that then
11:54:45 <unenough> monochrom, recursively strict?
11:55:07 <c_wraith> > (\a b -> a) "foo" (undefined :: Int)
11:55:07 <lambdabot>   "foo"
11:55:22 <c_wraith> \ is only strict in its first argument.
11:55:26 <neun> #git
11:55:27 <lunabot>  luna: Not in scope: `git'
11:55:41 <neun> sorry
11:55:43 <unenough> > (\a b -> b) (undefined :: Int) "foo"
11:55:44 <lambdabot>   "foo"
11:55:52 <unenough> c_wraith, or it's second
11:55:55 <unenough> :)
11:55:58 <copumpkin> c_wraith: not sure I'd way that
11:56:03 <copumpkin> *say
11:56:05 <monochrom> Haha. I was inaccurate. I leave you to fix it.
11:56:17 <c_wraith> ok, fine.  It's only strict in the pattern matching as required by the body. :)
11:56:26 <unenough> = lazy ?
11:56:43 <monochrom> A pattern is exactly as strict as the explicit constructors it contains.
11:56:56 * b_jonas tries to write some code
11:57:31 <c_wraith> > (\ (x:xs) -> "foo") undefined
11:57:32 <lambdabot>   "* Exception: Prelude.undefined
11:58:05 <copumpkin> > (\ ~(x:xs) -> "foo") undefined
11:58:07 <lambdabot>   "foo"
11:58:09 <monochrom> > (\ (x:xs) -> "foo") (undefined : undefined)
11:58:10 <lambdabot>   "foo"
11:58:55 <c_wraith> So unless it's an irrefutable match, pattern-matching in lambdas does check the constructor
11:59:16 <monochrom> Now have some fun with this exception:
11:59:24 <monochrom> > let x:xs = undefined in "foo"
11:59:25 <lambdabot>   "foo"
11:59:38 <copumpkin> let has different rules :)
11:59:47 <copumpkin> > let !(x:xs) = undefined in "bar"
11:59:49 <lambdabot>   "* Exception: Prelude.undefined
12:02:45 <kmc> so let bindings are irrefutable by default
12:03:04 <monochrom> This is why "let 1=0 in True" works.
12:03:14 <kmc> but this is not true for the arguments in a function binding
12:03:24 <kmc> > let f (x:xs) = "bleh" in f undefined
12:03:24 <lambdabot>   "* Exception: Prelude.undefined
12:04:16 <kmc> i don't think i've ever had a use for an irrefutable pattern... what are some typical use cases?
12:04:18 <copumpkin> function bindings are basically case statements
12:04:23 <kmc> > let (x:xs) = [] in 3
12:04:24 <lambdabot>   3
12:04:29 <c_wraith> > let f ~(x:xs) = "bleh" in f undefined
12:04:29 <lambdabot>   "bleh"
12:04:36 <kmc> > (\(x:xs) -> 3) []
12:04:37 <lambdabot>   * Exception: <interactive>:1:138-149: Non-exhaustive patterns in lambda
12:04:40 <kmc> > (\~(x:xs) -> 3) []
12:04:41 <lambdabot>   <no location info>: parse error on input `->'
12:04:47 <kmc> > (\ ~(x:xs) -> 3) []
12:04:48 <lambdabot>   3
12:04:58 <copumpkin> > let xs = [Just 5, Nothing, Just 7] in [x | Just x <- xs] -- kmc
12:04:59 <lambdabot>   [5,7]
12:05:06 <monochrom> If you want to tie-the-knot with a tuple, you'd better add ~
12:05:28 <monochrom> And in fact b_jonas's example is one such example.
12:05:37 <kmc> copumpkin, i mean a use case for ~
12:05:40 <copumpkin> oh
12:06:06 <kmc> copumpkin, does the list version work because of how "fail" is implemented for lists?
12:06:07 <copumpkin> usually knot-tying and careful recursive stuff where you don't want to be too strict
12:06:09 * copumpkin tries to think of a real example
12:06:20 <copumpkin> kmc: yeah
12:06:53 <c_wraith> there are some irrefutable matches in uu-parsinglib
12:07:06 <kmc> > fail "foo" :: [a]
12:07:06 <lambdabot>   []
12:07:11 <monochrom> After some deliberation, it was decided that swap should be defined as: swap ~(x,y) = (y,x)
12:07:14 <kmc> > fail "foo" :: IO ()
12:07:29 <kmc> ?
12:07:30 <kmc> @bot
12:07:30 <lunabot>  :o
12:07:33 <benmachine> that's slightly less efficient than swap (x, y) = (y, x) isn't it?
12:07:34 <burp> crashed :D
12:07:38 <kmc> oh dear
12:07:38 <lambdabot>   <IO ()>
12:07:39 <lambdabot> :)
12:07:51 <kmc> heh i would have thought the second one is bottom
12:07:56 <burp> > fail "foo" :: IO () -- does that take so long?
12:07:57 <lambdabot>   <IO ()>
12:08:14 <kmc> oh.  IO is a newtype isn't it
12:08:23 <c_wraith> yes.
12:08:27 <benmachine> is it?
12:08:34 <monochrom> swap ~(x,y) = (y,x) is more efficient if someone uses it as part of knot-tying.
12:08:36 <benmachine> it is
12:08:47 <kmc> does the spec say whether IO is lifted?
12:09:04 <copumpkin> kmc: it sort of has to be
12:09:08 <bd_> kmc: GHC's implementation of IO is a newtype, but I don't think the spec says anything about how IO is to be implemented
12:09:16 <bd_> @src IO
12:09:17 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
12:09:18 <copumpkin> kmc: I don't think the spec says anything about liftedness does it?
12:09:54 <kmc> perhaps the spec provides no way to reduce to whnf without matching a constructor
12:09:58 <kmc> and there's no standard constructor for IO
12:10:02 <kmc> so the issue is moot?
12:10:41 <bd_> > (fail "foo" :: IO ()) `seq` ()
12:10:42 <lambdabot>   ()
12:10:45 <bd_> interesting
12:10:47 <kmc> it's confusing how "case" always reduces the scrutinee to whnf in some intermediate languages but not in Haskell itself
12:10:53 <bd_> > (error "foo" :: IO ()) `seq` ()
12:10:54 <lambdabot>   * Exception: foo
12:10:55 <kmc> > (undefined :: IO ()) `seq` ()
12:10:56 <lambdabot>   * Exception: Prelude.undefined
12:10:59 <kmc> > (return undefined :: IO ()) `seq` ()
12:11:00 <lambdabot>   ()
12:11:06 <kmc> > return undefined :: IO ()
12:11:07 <lambdabot>   <IO ()>
12:11:16 <benmachine> > undefined :: IO ()
12:11:17 <lambdabot>   <IO ()>
12:11:49 <increpare> monochrom: I ripped out all of the STs, and no real performance hit (though my game-state is still pretty tiny right now)  : )
12:11:54 <increpare> monochrom: also the code got a lot nicer
12:11:58 <kmc> ah so the issue here is that the Show instance for IO a does not touch its argument at all
12:12:08 <copumpkin> yep
12:12:12 <monochrom> Interesting.
12:12:16 <copumpkin> it couldn't do anyhing with it
12:12:45 <benmachine> it could, it just doesn't want to
12:12:48 <pikhq> The only way to do anything with it is the evil "unsafePerformIO :: IO a -> a".
12:12:53 <monochrom> show x = unsafeRollBack (unsafePerformIO x)
12:12:58 <copumpkin> benmachine: what could it do?
12:13:04 <benmachine> umm
12:13:11 * benmachine pokes mueval to find out
12:13:15 <benmachine> unsafeCoerce it?
12:13:27 <copumpkin> benmachine: um :P to what?
12:13:33 <benmachine> ...Int
12:13:37 <benmachine> why not
12:13:40 <copumpkin> sounds exciting
12:13:51 <monochrom> To State# RealWorld -> (# State# RealWorld, a #)
12:14:00 <copumpkin> lol
12:14:16 <kmc> hmm what does a value of type (State# a) represent?
12:14:21 <kmc> is the a a phantom type?
12:14:29 <kmc> is the entire thing a token with no runtime rep?
12:14:50 <benmachine> State# and RealWorld are both from GHC.Prim
12:15:11 <kmc> i think RealWorld is elsewhere and is just "data RealWorld"
12:15:18 <benmachine> :i says GHC.Prim.RealWorld is an empty type
12:15:35 <copumpkin> kmc: it's not defined that way, really
12:15:45 <copumpkin> it's actually primitive
12:15:52 <benmachine> data GHC.Prim.State# a 	-- Defined in GHC.Prim
12:16:18 <kmc> so also an empty type
12:16:20 <kmc> copumpkin, why?
12:17:12 <copumpkin> kmc: not really sure why data RealWorld wouldn't work, except for the fact that it's probably needed before they're willing to go loading modules from outside
12:17:35 <copumpkin> and maybe because empty data declarations aren't allowed by the standard
12:17:41 <monochrom> State# RealWorld -> (# State# RealWorld, a #)  is just to make the compiler happy. It is the X->(#X,a#) skeleton that makes the compiler happy, it doesn't matter what X is.
12:18:44 <benmachine> > undefined :% undefined
12:18:45 <lambdabot>   Not in scope: data constructor `:%'
12:18:51 <benmachine> oh hmm
12:19:01 <nha_> are there any good ways to make a new type thats bounded to a range like -1.0 to 1.0
12:19:11 <mauke> nha_: no
12:19:16 <kmc> > undefined % undefined
12:19:17 <lambdabot>   * Exception: Prelude.undefined
12:19:30 <copumpkin> kmc: that's the Show
12:19:39 <kmc> yeah?
12:19:49 <copumpkin> actually maybe not
12:19:55 <kmc> well yeah makes sense
12:20:00 <solidsnack> kmc: Thanks for pointing me to `haskell-src-exts` -- it turned out to be exactly what I wanted.
12:20:04 <kmc> cool :)
12:20:10 <benmachine> I'm looking at the implementation of rnf for Ratio a
12:20:21 <copumpkin> kmc: it probably tries to reduce the fraction before saving it, so it might not be the Show
12:20:37 <benmachine> wondering if rnf is any different to seq, since Ratio seems to be declared with strict components
12:20:50 <solidsnack> For some reason, I thought it was just a pre-processor -- I didn't realize at all that it was a complete, source preserving parser.
12:21:13 <kmc> > approxRational pi (1/1000)
12:21:14 <lambdabot>   201 % 64
12:21:27 <kmc> > 201.0 / 64
12:21:28 <lambdabot>   3.140625
12:21:33 <kmc> > approxRational pi (1/250000)
12:21:34 <lambdabot>   355 % 113
12:21:40 <benmachine> > Just undefined `seq` ()
12:21:41 <lambdabot>   ()
12:21:42 <kmc> > 355.0/113
12:21:43 <lambdabot>   3.1415929203539825
12:23:44 <benmachine> all tuples of size greater than 2 are annoying, discuss
12:23:50 <kmc> yup
12:23:56 <kmc> define your own type
12:24:13 <jtra> interesting, this page allows to run code in many languages including haskell http://ideone.com/ sample: http://ideone.com/fH3HnVpD
12:24:25 * benmachine wonders if a language that had no native support for tuples would be paritcularly more difficult to use
12:24:43 <increpare> Trying to compile something using ghc with the -prof flag, but when I try to do it I'm getting that it can't find Control.Monad.Random   ( it compiles fine normally)
12:24:58 <kmc> tuples are useful for intermediate values in list processing and the like.  they should have short lifetime
12:25:23 <copumpkin> increpare: you need profiling versions of that library
12:25:34 <Twey> J-Mad_: Like CodePad, then?
12:25:55 <benmachine> I bet that the vast majority of those cases are 2-tuples though
12:25:56 <Twey> kmc: *nod*
12:25:58 <increpare> copumpkin: I have to rebuild it with some additional options?
12:26:08 <copumpkin> increpare: yeah, but it's a real pain
12:26:09 <Twey> They are handy when you really want to return multiple values, too
12:26:21 <Twey> Like in Network
12:26:21 <benmachine> you can't really do much with 3-tuples other than pattern match them
12:26:23 <HaskellDoubleLov> anyone knows how to write a permutations function? not using the already made one...
12:26:25 <Twey> Yeah
12:26:32 <monochrom> BASIC is an example of no tuples.
12:26:35 <kmc> :k (# 3, 4 #)
12:26:36 <lambdabot> Only unit numeric type pattern is valid
12:26:36 <lambdabot> Only unit numeric type pattern is valid
12:26:38 <Twey> Pattern-matching should really be all you do with big tuples
12:26:45 <kmc> err durr
12:26:49 <kmc> :k (# Int, Int #)
12:26:50 <lambdabot> (#)
12:26:50 <Twey> kmc: One message, two errors?
12:26:54 <c_wraith> HaskellDoubleLov: I've written about 5 different haskell implementations of permutations.  It's really pretty straight-forward.
12:26:56 <increpare> copumpkin: could you give me a pointer as to where to start going about it?
12:27:01 <kmc> :k (# Int#, Char# #)
12:27:02 <lambdabot> Not in scope: type constructor or class `Int#'
12:27:02 <lambdabot> Not in scope: type constructor or class `Char#'
12:27:07 <kmc> :k (# (), (), () #)
12:27:08 <lambdabot> (#)
12:27:10 <HaskellDoubleLov> c_wraith wooow, tell me please
12:27:15 <benmachine> if you're going to pattern-match can't you just make a specialised datatype anyway
12:27:17 <copumpkin> HaskellDoubleLov: oh come on. Just install a later version of GHC. You're on a version that's two years old, you can do better than that. Fuck your OS's packaging system
12:27:54 * benmachine tries to work out where that came from
12:27:55 <monochrom> I wonder which OS still features a two-year-old GHC. I mean even Ubuntu has caught up to 6.10
12:28:05 <copumpkin> I dunno
12:28:08 <copumpkin> he's on 6.8 somehow
12:28:10 <HaskellDoubleLov> copumpkin man i will upgrade when i get debian, i want to learn more on ubuntu for a month and then will get debian forever
12:28:39 * benmachine is still waiting for Arch to adopt 6.12 and wondering if he shouldn't just install it himself
12:28:49 <doserj> Debian stable is still on 6.8
12:28:53 <monochrom> http://packages.ubuntu.com/karmic/ghc6
12:29:55 <kmc> benmachine, you want to use it even though Platform isn't ready?
12:30:06 <benmachine> kmc: yes I am anarchic like that
12:30:29 <kmc> fight the power
12:30:33 <benmachine> heh
12:30:36 <kmc> don't let those ghc fat cats tell you what to do
12:30:48 <monochrom> get hugs
12:30:59 <benmachine> it's not anti-authority it is just anti-system-stability
12:31:21 <benmachine> if my computer works for too long I get complacent
12:32:06 <HaskellTripleLov> c_wraith please share some permutations implementations
12:32:27 <kmc> HaskellTripleLov, permutations of [] are?
12:32:32 <kmc> HaskellTripleLov, permutations of (x:xs) are?
12:32:57 <HaskellTripleLov> ok let me try dont write
12:33:14 <monochrom> http://arcanux.org/lambdacats_3.html#entry9 is one of the ghc fat cats XD
12:33:18 <b_jonas> IT WORKS NOW!
12:33:26 <PepeSilvia> hi, is there are a standard filter function that takes lists of predicates instead of a single one? eg. [(a->Bool)] -> [a] -> [a]
12:33:38 <kmc> PepeSilvia, one per element?
12:33:43 <mauke> PepeSilvia: and what would it do?
12:33:47 <kmc> how do you plan to use the list of predicates?
12:33:52 <b_jonas> look: http://erxz.com/pb/22356
12:33:58 <b_jonas> I didn't get it right at first, but now it works
12:34:00 <PepeSilvia> filters the lists on all the predicates
12:34:05 <b_jonas> it emulates the writer monad
12:34:13 <kmc> :t sequence . and
12:34:14 <lambdabot>     Couldn't match expected type `[m a]' against inferred type `Bool'
12:34:14 <lambdabot>       Expected type: [Bool] -> [m a]
12:34:14 <lambdabot>       Inferred type: [Bool] -> Bool
12:34:17 <mauke> :t all
12:34:18 <HaskellTripleLov> kmc i give up, how?
12:34:18 <Zao> all.
12:34:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:34:21 <monochrom> PepeSilvia: Specify what you want in first-order logic.
12:34:22 <PepeSilvia> eg filter* [(>3), (<5)] [1..10]  == [4]
12:34:30 <b_jonas> and is sufficently lazy that it can return the beginning of a list even if I run an infinite sequence of tells
12:34:32 <kmc> HaskellTripleLov, cool you give up after 30 sec
12:34:36 <b_jonas> that's cool
12:34:39 <increpare> copumpkin: ah found the "-p" switch : )
12:34:45 <kmc> nm can't get drawn into this again
12:34:46 <kmc> bbl
12:34:48 <HaskellTripleLov> kmc  well  i know my limits
12:34:50 <Zao> > all [True, False]
12:34:51 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:34:51 <lambdabot>         against inferred ...
12:35:01 <kmc> :t sequence . all
12:35:02 <mauke> :t \fs -> filter (\x -> all ($ x) fs)
12:35:02 <lambdabot>     Couldn't match expected type `[m a]'
12:35:02 <lambdabot>            against inferred type `[a1] -> Bool'
12:35:02 <lambdabot>     Probable cause: `all' is applied to too few arguments
12:35:03 <lambdabot> forall a. [a -> Bool] -> [a] -> [a]
12:35:05 <Zao> Erm... doh.
12:35:09 <Zao> Mixed it up with and :)
12:35:10 <mauke> @pl \fs -> filter (\x -> all ($ x) fs)
12:35:11 <lambdabot> filter . flip (all . flip id)
12:35:47 <mauke> :t \fs -> filter (and . sequence fs)
12:35:49 <lambdabot> forall a. [a -> Bool] -> [a] -> [a]
12:35:55 <mauke> @pl \fs -> filter (and . sequence fs)
12:35:56 <lambdabot> filter . (and .) . sequence
12:36:01 <PepeSilvia> I currently have this:
12:36:02 <PepeSilvia> selectOn [] es = es
12:36:03 <PepeSilvia> selectOn (a:as) es = selectOn as (filter a es)
12:36:11 * b_jonas dances around singing "I understand Writer"
12:36:24 <monochrom> It is best to combine your multitude of predicates into just one.
12:36:56 <Zao> b_jonas: Enjoy until your understanding breaks.
12:37:03 <PepeSilvia> monochrom: that sounds reasonable
12:37:09 * increpare wishes he had built with -p the first time round...quite the chase around!
12:37:35 <monochrom> I think b_jonas's understanding is complete and will not break. I mean he even gets the strictness and non-strictness right.
12:38:25 <monochrom> The next challenge may be Control.Monad.State.Strict and Control.Monad.State.Lazy. It is fun.
12:39:15 <monochrom> Begin with http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5481
12:39:39 <b_jonas> monochrom: is the key that one of them is not a real monad?
12:40:03 <monochrom> I don't know.
12:40:13 <JohnnyL> > take 10 primes
12:40:14 <lambdabot>   Not in scope: `primes'
12:40:26 <JohnnyL> 3,5,7
12:40:29 <JohnnyL> > 3,5,7
12:40:30 <lambdabot>   <no location info>: parse error on input `,'
12:40:32 <kmc> > case undefined `seq` () of () -> "bleh"
12:40:33 <lambdabot>   "* Exception: Prelude.undefined
12:40:35 <JohnnyL> > [3,5,7]
12:40:35 <kmc> > case undefined `seq` () of _ -> "bleh"
12:40:36 <lambdabot>   [3,5,7]
12:40:36 <lambdabot>   "bleh"
12:40:49 <monochrom> Probably not key because even if one of them breaks a law, you still have to find out why.
12:40:56 <kmc> > case undefined `seq` () of x -> "bleh"
12:40:57 <increpare> YAY IT'S BUILDING THE PROFILING VERSION
12:40:57 <lambdabot>   "bleh"
12:41:03 <kmc> > case undefined `seq` () of x -> show x
12:41:04 <lambdabot>   "* Exception: Prelude.undefined
12:42:19 <Veinor> kmc: that's pretty neat :D
12:42:41 <Veinor> > case undefined of x -> x `seq` 1
12:42:42 <lambdabot>   * Exception: Prelude.undefined
12:42:52 <Veinor> > case undefined of x ->  1
12:42:53 <lambdabot>   1
12:43:08 <b_jonas> monochrom: okay, maybe it's not the key, but does the strict one break monad laws?
12:43:16 <monochrom> I don't know.
12:43:20 <Veinor> barring cases like undefined, seq = flip const in terms of output, correct?
12:43:28 <Veinor> > 2 `seq` 3
12:43:29 <lambdabot>   3
12:43:33 <kmc> yeah
12:43:34 <Veinor> > let x = flip const in 2 `x` 3
12:43:35 <lambdabot>   3
12:43:46 <Veinor> > 2 `flip const` 3
12:43:47 <lambdabot>   <no location info>: parse error on input `const'
12:43:48 <Veinor> aw :(
12:43:59 <c_wraith> Veinor: the entire point of seq is that undefined *is* different, though
12:44:15 <Veinor> c_wraith: I thought it was also for speed purposes?
12:44:18 <kmc> evaluating (a `seq` b) to whnf evaluates a to whnf, then b to whnf, and returns b
12:44:42 <monochrom> No, it leaves b as is.
12:44:46 <kmc> oh?
12:44:59 <kmc> but surely if you reduce something to whnf the result better come back whnf
12:45:02 <monochrom> Some outer context is evaluating b if you see b evaluated.
12:45:10 <Veinor> > case undefined `seq` undefined of x -> 1
12:45:11 <lambdabot>   1
12:45:11 <b_jonas> monochrom: same thing
12:45:25 <kmc> Veinor, "case" does not force anything if all patterns are variables or wildcards
12:45:28 <kmc> > (undefined :: ()) `seq` 1
12:45:29 <lambdabot>   * Exception: Prelude.undefined
12:45:30 <Veinor> ah, yeah
12:45:30 <kmc> > (undefined :: IO ()) `seq` 1
12:45:31 <lambdabot>   * Exception: Prelude.undefined
12:45:33 <b_jonas> monochrom: you only get the effect of evaluating a to whnf when you evaluate the output of seq itself, doesn't it?
12:45:37 <b_jonas> so it shouldn't differ
12:45:51 <c_wraith> Veinor: it can help with speed or memory use, but that's a consequence of fact that it forces something to whnf...  which is the same as determining whether it's bottom or not (ie, undefined)
12:46:01 <Veinor> c_wraith: true.
12:46:25 <c_wraith> errr.  I meant eg, not ie.  oops.  >_>
12:46:27 <Saizan_> however seq doesn't give any guarantee to the ordering of evaluations
12:46:36 <Saizan_> s/to/on/
12:46:37 <HaskellTripleLov> fib 0 = 0;fib 1 = 1;fib n = fib (n-1) + fib (n-2) is there more effecient way to do fib?
12:46:51 <b_jonas> HaskellTripleLov: sure there is, isn't that exponential?
12:46:56 <mauke> HaskellTripleLov: is there a less efficient way?
12:46:57 <HaskellTripleLov> c_wraith share some permutations implementation bro
12:47:04 <b_jonas> like mauke says
12:47:08 <HaskellTripleLov> b_jonas yeh it is exp
12:47:43 <merehap> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
12:48:07 <monochrom> http://www.vex.net/~trebla/haskell/calculator/Calculator.hs  has two efficient algorithms for fib.  And don't use the Ackermann function!
12:48:49 <monochrom> The second algorithm completely destroys the false mantra "fib by recursion is slow".
12:49:03 <c_wraith> fib by dumb recursion is slow.
12:49:28 <xerox> (there was a guy who used to write very efficient numerical functions in Haskell, i forget his name, wms or something...)
12:49:44 <Saizan_> (i think you mean wli)
12:49:47 <copumpkin> :(
12:50:06 <monochrom> People even dare to say such falsehood as "the [sic] recursive algorithm for fib". Dude, there are a couple more.
12:50:49 <stoop> copumpkin ya scur me
12:50:49 <xerox> right, wli. I wonder if his code is up somewhere.
12:50:52 <mauke> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1
12:50:53 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
12:51:21 <copumpkin> stoop: y?
12:51:27 <Veinor> mauke: :O
12:51:30 * hackagebot upload: LibZip 0.0.2 - Partial bindings to libzip to read zip archives. (SergeyAstanin)
12:51:55 <Veinor> b_jonas: it turns out that computing fib naively is O(phi^n)
12:51:57 <Saizan_> xerox: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
12:51:59 <stoop> copumpkin, sorry, I just felt like saying that to someone. :-/
12:52:03 <Veinor> and f_n is also O(phi^n)
12:52:06 <copumpkin> stoop: orly?
12:52:06 <Veinor> :D
12:52:13 <mreh> can I re-export a whole module?
12:52:20 <copumpkin> Veinor: zomg phi
12:52:25 <koeien37> mreh: yes, put module X in your export list
12:52:53 <xerox> Saizan_ cool :)
12:52:59 <mreh> koeien37, cool
12:53:30 <Veinor> I wonder what other sequences there are such that calculating s_n is O(s_n)
12:54:12 <c_wraith> > let perms [] = [[]] ; perms ls = do { x <- ls ; rest <- perms $ delete x ls ; return $ x : rest } in perms [1..3] -- the worst implementation I know of
12:54:13 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
12:54:39 <b_jonas> I think we have some permutations generator code in the channel logs somewhere
12:54:43 <b_jonas> multiple variants too
12:54:53 <monochrom> Veinor: try ackermann :)
12:54:53 <kmc> three different ones
12:55:01 <Veinor> haha
12:55:13 <copumpkin> Veinor: I'd imagine any calculation in unary :o
12:55:21 <Veinor> well, I guess O(s_n) and o(s_n)
12:55:22 <kmc> busy beaver sequence
12:55:24 <Veinor> at least from the definition
12:55:31 <Veinor> busy beaver doesn't count, it's not computable :P
12:55:36 <kmc> yeah
12:56:06 <Veinor> so I guess Theta(s_n) :P
12:56:51 <Veinor> wait, I was thinking of Omega when I said o... bleh
12:56:55 <monochrom> 
12:57:55 <b_jonas> somehow google can't search well in those logs
12:58:03 <b_jonas> I'll have to try to download them and search that way
12:58:32 <increpare> trying to make a heap profile, but the graph produced seems to just be for the first second ...
12:59:21 <Veinor> thank you monochrom :D
13:00:21 <HaskellTripleLov> fiblist :: [Integer]; fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist); Can someone explain this function, i see first time such miracle that takes nothing and just IS a Int list...
13:00:32 <copumpkin> increpare: maybe you didn't let the program finish normally?
13:00:48 <copumpkin> HaskellTripleLov: it's not a function, just a value
13:00:51 <c_wraith> HaskellTripleLov: It's not a function.  it's just a recursive data definition
13:01:11 <ColonelJ> > 0 : 1 : zipWith (+) fiblist (tail fiblist)
13:01:13 <lambdabot>   Not in scope: `fiblist'Not in scope: `fiblist'
13:01:18 <increpare> copumpkin: possibly - though I'm pretty sure I'm exiting by calling "exitWith ExitSuccess"
13:01:26 <ColonelJ> @let fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist)
13:01:27 <lambdabot>  Defined.
13:01:30 <ColonelJ> > fiblist
13:01:32 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:01:42 <copumpkin> increpare: hmm, you shouldn't even need to call exitWith :O
13:02:01 <copumpkin> increpare: maybe the profiling stuff doesn't interact nicely with posix exit() calls
13:02:11 <increpare> copumpkin: I'll try ripping it out, see what happens
13:04:05 <increpare> copumpkin: hmm there's no other way to exit using GLUT I can see - it wraps around the main loop with its own, so I only get to play with IO()-valued callbacks.
13:04:20 <increpare> copumpkin guess I can try a test case, see what happens
13:04:39 <HaskellTripleLov> can you recommend me something so i see this recursive data structure miracle in action? profiling tools or whatever? anyways, does someone use Visual Haskell?
13:04:41 <copumpkin> increpare: oh, that's lame. Might want to ask in #ghc about how they interact, and whether the profiling file output is buffered
13:05:01 <increpare> copumpkin: will do. thanks : ]
13:05:42 <BMeph> HaskellTripleLov: CaleWiki. :)
13:05:42 <copumpkin> HaskellTripleLov: start with let x = 1 : x in x. Figure out what's going on, and when you do, try let y = 0 : map (+1) y in y. Once you understand that, then try the fibs expression
13:08:33 <ColonelJ> > let x = 1 : x in x
13:08:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:09:03 <companion_cube> > let x = 1 :x in length x
13:09:09 <lambdabot>   mueval: ExitFailure 1
13:09:13 <companion_cube> :)
13:09:34 <copumpkin> > let x = 1 : x in genericLength x > (3 :: Natural)
13:09:36 <lambdabot>   True
13:09:55 <koeien37> in general that is a bad idea
13:09:59 <koeien37> now it is useful
13:10:26 <mercury^> What is useful now?
13:10:35 <koeien37> using Natural
13:10:37 <koeien37> for length
13:10:40 <mercury^> They are always a bad idea.
13:10:47 <b_jonas> > let x = 1 : map succ x in length x
13:10:51 <lambdabot>   mueval-core: Time limit exceeded
13:11:09 <b_jonas> so length is actually so smart it detects infinite lists and gives that exception or what?
13:11:17 <b_jonas> how does that even work?
13:11:23 <copumpkin> give that codata some love
13:11:27 <copumpkin> b_jonas: nothing that smart :)
13:11:42 <copumpkin> b_jonas: lambdabot just has a time limit and cuts you off
13:11:43 <ColonelJ> b_jonas: it tries to count how many elements there are, and then the time limit for doing that is exceeded since it never ends
13:11:53 <b_jonas> yeah, but the ExitFailure above is what?
13:11:56 <mercury^> It constructs (1 + (1 + (1 + ... with lazy addition.
13:12:18 <b_jonas> > let x = 1 : x in length x
13:12:24 <lambdabot>   mueval: ExitFailure 1
13:12:27 <koeien37> out of time
13:12:32 <mercury^> And since adding something positive cannot decrease a number, after evaluating a few of those lazy additions, it knows that it will be larger than 3.
13:12:42 <b_jonas> but what's the difference in the two errors?
13:12:45 <osfameron> is there a function that takes Ord a => [(a,a)] -> (a,a) => [(a,a)], where the tuples represent (start,end) and an overlapping (start,end) being added might cause the existing ones to truncate, split, or be clobbered entirely ?
13:12:56 <copumpkin> b_jonas: just lambdabot not being very clean
13:13:14 <copumpkin> osfameron: not built-in :)
13:13:14 <osfameron> I know how to write one with a number of span's, but it seems moderately fiddly, and I'm wondering if there's prior art ?
13:13:21 <b_jonas> oh
13:13:41 <Saizan_> b_jonas: there's a fork and a thread, both trying to kill the actual worker thread if it takes too long, depending on which one kicks in you get different errors
13:13:43 <osfameron> copumpkin: fair enough - it's always worth asking, in case my problem is an example of something more general that exists in one of the libs somewhere :-)
13:13:57 <b_jonas> Saizan_: oh
13:14:03 <b_jonas> Saizan_: I see
13:14:03 <ColonelJ> :t foldl'
13:14:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:14:22 <b_jonas> Saizan_: jevalbot is something like that too, it too gives more cryptic messages
13:14:22 <copumpkin> > (1, 2) `mappend` (3,4)
13:14:25 <lambdabot>   Ambiguous type variable `t' in the constraints:
13:14:25 <lambdabot>    `GHC.Num.Num t' arising ...
13:14:40 <b_jonas> Saizan_: most of them are of the form "|abort 4" and then you have to search the code for which one number 4 is
13:14:51 <b_jonas> so I'm at home
13:14:51 <copumpkin> osfameron: seems like you have a semigroup at least, even though there's no default instance for it ;)
13:15:00 <osfameron> copumpkin: "semigroup" ?
13:15:06 <jlouis> monoid
13:15:06 <ColonelJ> let x = 1 : foldl' (+) 0 x in x
13:15:10 <ColonelJ> > let x = 1 : foldl' (+) 0 x in x
13:15:11 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
13:15:18 <sshc> if something is of type State a b, then is it really a function?
13:15:21 <copumpkin> osfameron: math nerd talk for an associative operation
13:15:24 <koeien37> a semigroup is a set with an associative operator
13:15:26 <copumpkin> sshc: sort of
13:15:35 <copumpkin> jlouis: what's the identity element?
13:15:38 <sshc> one that takes an initial value of type a, and returns (b, a)?
13:15:42 <ColonelJ> > let x = [1] : foldl' (+) 0 x in x
13:15:44 <Saizan_> sshc: yeah
13:15:44 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
13:15:54 <koeien37> sshc: under the hood, yes
13:15:56 <sshc> ok, so it is a function.
13:16:04 <sshc> I'm glad I'm finally beginning to understand the State monad
13:16:05 <koeien37> @src State
13:16:05 <lambdabot> Source not found. There are some things that I just don't know.
13:16:06 <Saizan_> sshc: the only difference is that it's wrapped in the "State" constructor
13:16:20 <osfameron> copumpkin: is it associative?  doesn't that imply that things would be symmetric?  whereas depending on the order you add these things, different elements might get clobbered
13:16:21 <koeien37> newtype State s a = State (s -> (a, s))
13:16:23 <jlouis> copumpkin: urgh
13:16:29 <jlouis> copumpkin: nevermind, I was wrong
13:16:31 <koeien37> osfameron: that is commutativity
13:16:32 <b_jonas> sshc: yes, it has to be wrapped because functions have a different monad instance
13:16:35 <ColonelJ> > let x = 1 : foldl' (+) 0 x in x
13:16:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
13:16:46 <b_jonas> it's useful too because sometimes you want to call the State constructor directly
13:16:50 <sshc> so the "s" can be a "data GameState" or even something as primitive as  Int?
13:16:54 <osfameron> koeien37: gah.  yes.  I am weak in teh maths, and strong in booze and christmas food :-(
13:16:58 <koeien37> sshc: anything you'd like
13:16:58 <sshc> copumpkin: why "sort of"
13:16:58 <ColonelJ> > 1 : 2 : 3 : []
13:17:00 <lambdabot>   [1,2,3]
13:17:08 <copumpkin> osfameron: I was just talking about the union of ranges actually
13:17:17 <sshc> copumpkin: becaues it is a function wrapped in the State Monad?
13:17:20 <copumpkin> sshc: it's only a function if you look inside, but you typically don't
13:17:32 <koeien37> :t runState
13:17:33 <lambdabot> forall s a. State s a -> s -> (a, s)
13:17:34 <copumpkin> sshc: I wouldn't talk about wrapping it in The State Monad
13:17:42 <koeien37> ^ you can look inside
13:17:45 <copumpkin> sshc: State is a type and it happens to be a monad
13:17:52 <ColonelJ> > let x = 1 : map (\y -> foldl' (+) 0 y) x
13:17:53 <lambdabot>   not an expression: `let x = 1 : map (\y -> foldl' (+) 0 y) x'
13:17:58 <ColonelJ> > let x = 1 : map (\y -> foldl' (+) 0 y) x in x
13:17:58 <koeien37> well, "State s" is a monad
13:17:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:18:08 <copumpkin> yeah :)
13:18:17 <b_jonas> pity you can't do that easily with StateT
13:18:24 <koeien37> :t runStateT
13:18:25 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
13:18:32 <sshc> so if I had a State that took an Int (s is Int), and returned the new state as the successor (s + i), and for the value / result, the String of that (show . succ $ s), how would I use that?
13:18:48 <ColonelJ> > let y = 0 : map (+1) y in y
13:18:50 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:19:06 <copumpkin> :t modify succ
13:19:07 <lambdabot> forall s (m :: * -> *). (Enum s, MonadState s m) => m ()
13:19:15 <koeien37> do { modify succ; x <- get; return (show x) }
13:19:22 <BMeph> osfareom: Sorry for zoning out. Sounds like what you were asking for five minutes ago, is a DIET. ;)
13:19:25 <sshc> @src modify
13:19:25 <lambdabot> Source not found. My pet ferret can type better than you!
13:19:37 <ColonelJ> @src haskell
13:19:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:19:41 <koeien37> :t do { modify succ; x <- get; return (show x) } -- Let's see if lambdabot knows it, and I'm correct
13:19:42 <b_jonas> @hoogle (s -> (a, s)) -> StateT s m a
13:19:42 <lambdabot> forall (m :: * -> *) s. (Show s, MonadState s m, Enum s) => m String
13:19:42 <lambdabot> No results found
13:19:43 <copumpkin> sshc: a get followed by a put of the function applied to the result of the get :)
13:19:44 <osfameron> BMeph: DIET ?
13:19:50 <osfameron> oh yes
13:19:55 <osfameron> for the stupidity and fullness thing
13:19:55 <b_jonas> koeien37: I'd rather want something like this
13:19:56 <osfameron> thanks
13:19:58 <osfameron> ;-P
13:20:04 <HaskellTripleLov> fiblist = 0 : 1 : zipWith (+) fiblist (tail fiblist), copumpkin so first we begin with 0 and 1 so the name fiblist stands for [0,1] right? and tail stands for [1] ... so what happens in the next step?
13:20:13 <koeien37> b_jonas: then take the identity monad as your m
13:20:15 <b_jonas> a function that lets me apply a function to the state without modifying the other side effects
13:20:26 <copumpkin> HaskellTripleLov: did you look at the first two I suggested?
13:20:34 <sshc> is State the only instance of MonadState?
13:20:37 <b_jonas> koeien37: no, I mean in a StateT where there are other side effects
13:20:44 <b_jonas> sshc: no, transformers are too
13:20:45 <copumpkin> sshc: nope
13:20:49 <HaskellTripleLov> yes i get them but this one i cant figure out what is the next step copumpkin
13:20:57 <copumpkin> there's also a weird RWS thing
13:21:10 <b_jonas> sshc: StateT, plus any monad that's already in MonadState lifted with any other standard monad transformer
13:21:11 <sshc> I want to learn how to actually use State monads before I learn transformers
13:21:25 <copumpkin> HaskellTripleLov: so it starts with [0, 1 (not the unclosed parenthesis)
13:21:26 <koeien37> sshc: did you understand this?
13:21:27 <copumpkin> note
13:21:28 <b_jonas> sshc: well then State and RWS are the only ones
13:21:32 <koeien37> :t do { modify succ; x <- get; return (show x) }
13:21:33 <lambdabot> forall (m :: * -> *) s. (Show s, MonadState s m, Enum s) => m String
13:21:38 <copumpkin> HaskellTripleLov: then if you ask for another element, it applies the zipWith
13:21:47 <b_jonas> sshc: try to reimplement State by the way, that helps a lot in understanding it
13:21:51 <BMeph> osfameron: See http://web.engr.oregonstate.edu/~erwig/papers/Diet_JFP98.pdf
13:21:51 <b_jonas> sshc: the code is simple enough
13:22:17 <b_jonas> sshc: you could do it without caring about the MonadState class, just making your State a Monad with the get and put being non-method functions
13:22:50 <b_jonas> meanwhile I'm still downloading the channel logs and searching for the permutation generation code
13:22:58 <HaskellTripleLov> copumpkin so what is fiblist and what is the tail in the next step?
13:23:01 <sshc> I think a complete example of code using a GameState would help me understand how to use them a lot
13:23:09 <sshc> koeien37: did I understand what?
13:23:16 <koeien37> sshc: this line:
13:23:18 <koeien37> :t do { modify succ; x <- get; return (show x) }
13:23:19 <lambdabot> forall (m :: * -> *) s. (Show s, MonadState s m, Enum s) => m String
13:23:20 <sshc> koeien37: I'm sorry if I skipped something you said earlier
13:23:22 <b_jonas> sshc: what's a GameState?
13:23:47 <b_jonas> sshc: sure, using the state monad can help too
13:23:55 <sshc> b_jonas: by that I mean I'd like to see how global state ([Players], done :: Bool, etc.) is used in games
13:24:04 <b_jonas> sshc: okay
13:24:06 <copumpkin> HaskellTripleLov: zipWith (+) ([0, 1 ?) (tail [0, 1 ?) ==> zipWith (+) ([0, 1 ?) ([1, ?) ==> [0 + 1, ?
13:24:15 <copumpkin> HaskellTripleLov: where ? means you haven't evaluated it yet
13:24:15 <sshc> koeien37: I don't understand that code
13:24:22 <sshc> koeien37: what is "modify?
13:24:36 <koeien37> " modify f " applies f to the state
13:24:43 <b_jonas> and stores it back, right?
13:24:50 <b_jonas> if it only applies f to the state, it's gets
13:24:51 <sshc> koeien37: to the state?  Which state?
13:25:12 <koeien37> the state of type s in "State s a"
13:25:15 <b_jonas> sshc: the state threaded throuhg the state monad. it's a state monad function.
13:25:19 <b_jonas> @type modify
13:25:20 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
13:25:48 <sshc> koeien37: so inside of a do block or a definition of a State monad, there's always a State being threaded through?
13:25:51 <HaskellTripleLov> copumpkin so frickin ununderstendable, it seems only a professor in college can teach me this
13:25:59 <copumpkin> lol
13:26:01 <osfameron> BMeph: oh!  you were serious after all.  That does look interesting (though I don't understand it yet..
13:26:06 <koeien37> sshc: data State s a = State (s -> (a, s))
13:26:21 <mauke> sshc: yes
13:26:32 <koeien37> a value of type "State s a" is a computation that. when performed, eventually will return a value of type "a", while maintaining a state of type "s"
13:26:34 <mauke> sshc: State gives you a single implicit mutable variable
13:27:22 <sshc> while I do know that it *is*, I don't understand how >> is useful in state monads, because the result of the previous action is just ignored?
13:27:39 <koeien37> the value on the left could have modified the state
13:27:48 <copumpkin> HaskellTripleLov: so do you understand how it proceeds?
13:27:50 <osfameron> BMeph: yes... that's almost exactly what I want, except that each node would have additional metadata beyond just the position ranges.  The functions etc. that they define look very useful, thanks!
13:27:53 <b_jonas> sshc: the result is, but the side effect of setting the state isn't
13:28:15 <sshc> @src >> State
13:28:15 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:28:17 <b_jonas> sshc: in fact put x doesn't return a meaningful result, so you usually >> it
13:28:27 <b_jonas> sshc: put x sets the state to x
13:28:28 <koeien37> yeah, it returns ().
13:28:36 <osfameron> ah, except that I *could* have touching ranges, (just not overlapping ones)
13:28:41 <mauke> > runState (modify succ >> modify (* 2) >> modify succ) 5
13:28:41 <koeien37> so you can use >>= (\_ -> ...
13:28:42 <sshc> how does >> change the state of whatever is being htreaded though it?
13:28:42 <lambdabot>   ((),13)
13:28:44 <BMeph> osfameron: Thank Erwig. I just remembered that I'd read about it. ;)
13:29:00 <osfameron> ;-)
13:29:01 <sshc> but then, wouldn't it be impossible to access whatever is being threaded through inside of the monad itself?
13:29:07 <koeien37> sshc: it is an action that, when performed, first runs the value on the left, and then the one on the right
13:29:53 <BMeph> osfameron: Did you want to have overlapping ranges? I looks like balancing as such uses integral intervals as an invariant. :)
13:30:00 <tibbe> bos: hey!
13:30:05 <HaskellTripleLov> copumpkin no man not even close, i will have to find some visual tool to learn this stuff
13:30:09 <BMeph> *It looks like, I meant. :)
13:30:25 <sshc> koeien37: I would look at the source of State's definition of >>, but Hoogle isn't working
13:30:29 <tibbe> bos: are we automatically subscribed to the mailing list?
13:30:30 <koeien37> so what "modify succ >> modify (*2)" does, when performed, is the following. First it runs "modify succ", this increases the value of the state by 1. Then it runs modify (*2), this multiplies the value of the state by 2. The result of this is ()
13:30:59 <b_jonas> > {- sshc: -} runState (put 'n' >> return 4) 'o'
13:31:13 <lambdabot>   (4,'n')
13:31:36 <osfameron> BMeph: overlapping no.  This is for runs of cells on a crossword grid.  The typical checked grids would even cope with the invariant of "don't touch", but some grids (European, Azed, etc.) allow consecutive runs separated just by a thick bar, instead of a blank
13:31:40 <b_jonas> sshc: the result of the put 'n' action is ignored, but the side effect of setting the state to 'n' isn't, so the state changed from 'o' to 'n'
13:31:58 <HaskellTripleLov> does 1/8 = 0.125 means that 125 is a repeating pattern? if not, can i set for more precision?
13:32:10 <bos> tibbe: yep
13:32:11 <koeien37> a "repeating pattern"?
13:32:12 <MoALTz> @let mymixer = ((join .) . zipWith ((. return) . (:)))
13:32:14 <lambdabot>  Defined.
13:32:17 <tibbe> bos: great
13:32:23 <mercury^> HaskellTripleLov: 1/8 is exactly 0.125
13:32:25 <sshc> b_jonas: ok, I understand that now, but how exactly does put 'n' cause a side effect?
13:32:35 <MoALTz> > mymixer "abc" "1234"
13:32:36 <lambdabot>   "a1b2c3"
13:32:36 <tibbe> bos: printed a bunch of papers and code on priority queues to read while I'm in Prague
13:32:38 <sshc> :t (put 'n' >> put 't' >> return 4)
13:32:39 <lambdabot> forall (m :: * -> *) t. (MonadState Char m, Num t) => m t
13:32:44 <bos> tibbe: nice
13:32:49 <sshc> :t (put 'n' >> put 't' >> return 4) 'o'
13:32:50 <lambdabot>     No instance for (MonadState Char ((->) Char))
13:32:50 <lambdabot>       arising from a use of `put' at <interactive>:1:1-7
13:32:50 <lambdabot>     Possible fix:
13:33:01 <koeien37> you forgot the runState
13:33:19 <koeien37> runState (put 'n' >> get >>= (\x -> if x == 'n' then 37 else 42) ) 'o'
13:33:26 <koeien37> > runState (put 'n' >> get >>= (\x -> if x == 'n' then 37 else 42) ) 'o'
13:33:27 <lambdabot>   No instance for (GHC.Num.Num
13:33:27 <lambdabot>                     (Control.Monad.State.Lazy....
13:33:28 <sshc> :t ((put 'n' >> put 't' >> return 4) 'o')
13:33:29 <lambdabot>     No instance for (MonadState Char ((->) Char))
13:33:29 <lambdabot>       arising from a use of `put' at <interactive>:1:2-8
13:33:29 <lambdabot>     Possible fix:
13:33:35 <koeien37> > runState (put 'n' >> get >>= (\x -> return $ if x == 'n' then 37 else 42) ) 'o'
13:33:36 <mauke> sshc: put x = \s -> ((), x)
13:33:36 <lambdabot>   (37,'n')
13:33:40 <sshc> koeien37: I want to know the type of whatever is being passed to runstate
13:34:04 <koeien37> first the computation in the state monad, then the initial state
13:34:14 <sshc> mauke: how does the State monad define >>?
13:34:23 <MoALTz> > mymixer [5,11..] [7,13..]
13:34:24 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
13:34:33 <tibbe> bos: what are you working on at the moment
13:34:41 <mauke> sshc: a >> b = a >>= \_ -> b
13:34:41 <bos> tibbe: i think the wakeup code
13:34:48 <tibbe> bos: ok
13:34:54 <tibbe> bos: sounds good
13:34:57 <sshc> :t (put 'n' >> put 't' >> return 4)
13:34:58 <lambdabot> forall (m :: * -> *) t. (MonadState Char m, Num t) => m t
13:35:16 <sshc> mauke: ok, but how does the State monad define >>=?
13:35:21 <koeien37> m >> k = \s -> let (s', _) = runState m s in k s'
13:35:31 <bos> tibbe: might write a poll backend later too
13:35:35 <tibbe> bos: I have a vague memory reading about some caveats with edge triggered event notification which made it really hard to use in practice, I don't think libev(emt) uses it
13:35:36 <koeien37> (modulo the newtype wrappers)
13:35:42 <tibbe> bos: great
13:35:44 <mauke> m >>= f = \s -> let (s', x) = m s in f x s'
13:35:47 <nha_> whats another good functional language to learn besides haskell and erlang
13:35:48 <mauke> only with more wrapping
13:35:50 <bos> tibbe: yes, i think it is really hard to use
13:35:51 <tibbe> bos: we should have a select and poll backend as fallback
13:35:57 <koeien37> nha_: Scheme. Lisp. Scala.
13:36:03 <bos> tibbe: yeah, just a matter of coding
13:36:07 <koeien37> nha_: OCaml.
13:36:08 <sshc> nha_: erlang is functional?
13:36:15 <sshc> I thought it allowed imperative programming
13:36:16 <koeien37> F#
13:36:17 <mauke> m >>= f = State (\s -> let (s', x) = runState m s in runState (f x) s')
13:36:30 <tibbe> bos: yup. I think edge triggering might require you to do several reads until you get EWOULDBLOCK
13:36:38 <nha_> what does ocaml bring to the table that haskell doesnt have?
13:36:42 <koeien37> ssc: this is a little bit hard to understand, i'd first leave out the newtype wrappers
13:37:26 <HaskellTripleLov> what is the recurring cycle of this number 3.225806451612903e-2, euler 26 seems to heavy :( ahaaaa
13:37:40 <koeien37> "recurring cycle"?
13:37:52 <byorgey> sshc: "functional" is not the opposite of "imperative"
13:38:23 <tibbe> bos: so should we make the current Backend class more general, to basically abstract the whole interface the different backends share in general, or less general than now, only supporting one-shot event registration
13:38:51 <increpare> A: What does ocaml bring to the table that haskell doesnt have?
13:38:52 <increpare> B: jdh...
13:38:57 <HaskellTripleLov> koeien37 well yeah like 1/7= 0.(142857) that in brackets is "recurring cycle"
13:39:02 <koeien37> true
13:39:08 <tibbe> bos: I have a patch that removes the current loop function in favor of a pollForEvents function, I don't know if I should apply it
13:39:09 <increpare> (in joke, ignore...)
13:39:30 <koeien37> HaskellTripleLov: there is a nice trick: 14285 /  99999 = 0.1428514285...
13:39:44 <sshc> why is unsafePerformIO unsafe?
13:39:56 <bos> tibbe: what's the difference?
13:39:58 <tibbe> bos: The question is who we want to own the extra state (callbacks, timeout priority queue). I think the "library" code should own it as it might need to know all the registered file descriptors to be able to recover from a fork
13:40:00 <koala_man> HaskellTripleLov: (0)
13:40:02 <koeien37> sshc: you can crash a Haskell program with it.
13:40:12 <sshc> koeien37: you can?  how?
13:40:13 <Zao> sshc: You don't know when it's evaluated, and it can be used to poke holes in the type system.
13:40:13 <koeien37> sshc: it removes the "IO" tag from a value.
13:40:14 <tibbe> bos: pollForEvents doesn't loop but instead calls the callbacks
13:40:23 <mauke> sshc: because it lets you execute IO actions in the middle of expression evaluation
13:40:25 <koeien37> sshc: it is type unsafe, like Zao pointed out
13:40:26 <b_jonas> mauke: except it's uglier like that because of the newtype wrapper
13:40:29 <increpare> sshc: because it can be used to get around referential transparency (so if I had a function f that used it, f 1 wouldn't always necessarily return the same value)
13:40:29 <b_jonas> but yeah
13:40:33 <HaskellTripleLov> koeien37 i can;t see tje point of the trick?koala_man what?
13:40:50 <tibbe> bos: it's basically just saying that the loop should be run in GHC.Conc instead of GHC.EventManager (assuming we put the code there)
13:40:51 <koeien37> HaskellTripleLov: 14285 / 99999 = recurring 14285
13:41:00 <koala_man> HaskellTripleLov: 3.225806451612903e-2 = 0.03225806451612903 = 0.0322580645161290300000000...
13:41:01 <tibbe> bos: it doesn't really matter
13:41:01 <Cale> sshc: Many many reasons, one of which is that you can completely destroy type safety (along with IORefs), and the fact that the actions you apply unsafePerformIO will run zero or more times in a random order depending on how the evaluation goes, which is altered by optimisations
13:41:16 <tibbe> bos: Having a run-once type function makes things easier to test.
13:41:32 <koeien37> 1 / 9 = 0.111111....; 123/99 = 0.123123123...
13:41:32 <sshc> why would anybody ever actually want to *use* unsafePerformIO?
13:41:39 <sshc> then why does it exist?
13:41:46 <koeien37> sshc: the raison d'etre is the FFI
13:41:47 <nha_> ffi
13:41:53 <koeien37> foreign function interface
13:42:06 <increpare> sshc: for debugging it's useful (spitting out strings to the terminal from any place you want in code)
13:42:13 <tibbe> bos: does that make sense (the explanation that is)
13:42:19 <ben0x539> bytestrings
13:42:22 <sshc> oh, I can see it be used for debugging
13:42:26 <bos> tibbe: yeah
13:42:28 <Cale> sshc: For places where you know that the IO is really referentially transparent and so you don't care how often it runs. To extend the evaluation mechanism without having to recompile GHC.
13:42:37 <koeien37> sshc: they are used to emulate global variables too, but you need to be a wizard before you can do that :)
13:42:40 <bos> tibbe: i think that having a pollForEvents function would be good, in that case
13:42:50 <tibbe> bos: it's not an important decision when the code goes in base
13:43:06 <bos> right
13:43:14 <sshc> but unsafePerformIO seems horrible to use in any real code, so are there any situations in which you absolutely need to use it?
13:43:16 <tibbe> bos: lets try for that though, the only thing that could make that tricky if it would need to have state passed from the last call to it
13:43:18 <Gracenotes> there's no special FFI monad.. it is all IO.
13:43:22 <b_jonas> sshc: for the ffi it's used because to pass data to C functions you might need to build (or read) real arrays and pointers and stuff in haskell,
13:43:26 <koeien37> sshc: "need". Never
13:43:29 <Cale> Easy rule of thumb: Unless your first name is Simon, don't use unsafePerformIO. ;)
13:43:30 <Gracenotes> so a general solution is needed. perhaps too general.
13:43:42 <HaskellTripleLov> koeien37 oh my goooooooood, the number of 9s is the number of digits in a pattern, what a frickin trick
13:43:53 <b_jonas> which is not a pure action, but if you don't get those side effects to leak from a function then the whole thing (build input, call c function, interpret output) can be pure.
13:43:59 <Gracenotes> unless there's some way to declare functions as interfaces to FFI functionality, with automatic top-level unsafePerformIOs on them
13:44:00 <koeien37> sshc: but if you need to do some things with C functions, and you cannot prove to the compiler that it's referentially transparent and without side effects
13:44:07 <Gracenotes> anyway, ramble ramble ramble
13:44:18 <koeien37> HaskellTripleLov: right. Can you prove why it's true?
13:44:24 <sshc> koeien37: so it's never a good idea to use it for purposes besides debugging?
13:44:51 <Gracenotes> and, controversially, top-level IO'd constants
13:44:54 <b_jonas> sshc: besides debugging and calling foreign functions, yes, it has few good applicatoins.
13:45:01 <koeien37> sshc: debugging (although Debug.Trace is a better idea i guess -- they might use unsafePerformIO) and if you use the FFI. Other than that, you have to know what you're doing
13:45:10 <HaskellTripleLov> koeien37 have no idea :(
13:45:12 <Cale> ByteString uses it to add a new datatype
13:45:16 <Gracenotes> which have problems of their own
13:45:18 <koeien37> sshc: I never mention the existence to people learning about IO, for example
13:45:25 <HaskellTripleLov> koeien37 that is why i want to learn coq in near future
13:45:36 <koeien37> HaskellTripleLov: you shouldn't have to learn coq to prove this :)
13:45:42 <Gracenotes> http://www.haskell.org/haskellwiki/Top_level_mutable_state <-- some people claim this is a good use
13:46:18 <Cale> I claim that's exactly one of the things we're trying to prevent ;)
13:46:27 <koeien37> Cale: yeah, agreed
13:46:48 <Gracenotes> :O
13:47:21 <koeien37> Cale: but the ByteString authors obviously knew what they were doing :)
13:47:54 <Gracenotes> such top-level state can be desirable. things can just get inevitably stringy without mutability, though... not like that's always bad.
13:48:08 <koeien37> Gracenotes: it severely reduces composability
13:48:20 <Gracenotes> sometimes that's the goal
13:48:21 <b_jonas> yeah, ByteString is just a big optimization afterall
13:48:38 <BMeph> How does augustss insert compiled LLVM in his programs w/o it? Or does he...? ;)
13:48:59 <sshc> if I had a function that just returned the string version of it (foo x = show x or just foo = show), how would I use unsafePerformIO to print out what is being returned before actually returning?
13:49:22 <koeien37> foo x = unsafePerformIO (print x) `seq` show x
13:49:35 <mauke> sshc: you'd use Debug.trace :-)
13:49:41 <koeien37> but right, Debug.Trace
13:49:58 <koeien37> only in absence of this you'd use my suggestion
13:50:09 <kmc> sshc, the idea of unsafePerformIO is that, by using it, you personally take over a large responsibility that is normally handled by the compiler and low-level libraries
13:50:16 <b_jonas> ah, found the permutation code
13:50:34 <koeien37> if you're learning the language it's not a good idea to use it imo
13:50:45 <kmc> for production code (as opposed to debugging / dirty hacks) it's sometimes necessary but you should think long and hard about each usage
13:50:50 <koeien37> I don't recall using it except for debug.trace when i didn't know it existed
13:50:54 <kmc> generally it's best left to core libraries
13:50:56 <HaskellNinja> Instance Monad Katana where
13:50:58 <kmc> such as ByteString
13:51:12 <kmc> > cycle "stab "
13:51:13 <lambdabot>   "stab stab stab stab stab stab stab stab stab stab stab stab stab stab stab...
13:51:14 <b_jonas> it's in http://tunes.org/~nef/logs/haskell/08.10.13
13:52:18 <b_jonas> who asked for generating all permutations?
13:53:36 <HaskellNinja> HaskellTripleLov:
13:59:34 <byorgey> > permutations [1..5]
13:59:35 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
13:59:37 <b_jonas> Saizan_ mentioned them apparently
13:59:42 <b_jonas> @info permutations
13:59:43 <lambdabot> permutations
13:59:49 <b_jonas> @where permutations
13:59:50 <lambdabot> I know nothing about permutations.
13:59:53 <b_jonas> which module is it in?
13:59:54 <CalJohn> @src permutations
13:59:54 <lambdabot> Source not found. Take a stress pill and think things over.
14:00:00 <mauke> there is no @info
14:00:01 <byorgey> b_jonas: Data.List
14:00:20 <byorgey> but only in base-4.0 and onwards IIRC
14:00:23 <Nomad010> lambdabot: do you know fuun dna?
14:00:24 <b_jonas> was it already there back at that discussion, or is it new in ghc 6.12?
14:00:26 <byorgey> or maybe 5.1, I forget
14:00:27 <b_jonas> I see
14:00:32 <byorgey> b_jonas: it was new in 6.10
14:00:34 <koeien37> 5.1?
14:00:42 <byorgey> er, 4.1, typo, sorry =)
14:00:42 <b_jonas> 6.10? when did that come out?
14:00:58 <b_jonas> before or after 2008-10-13?
14:01:01 <byorgey> b_jonas: 16 July
14:01:08 <byorgey> 16 July 2009, so after
14:01:21 <byorgey> and no, I don't have that memorized =)
14:01:31 <byorgey> oh wait, that was 6.10.4
14:01:50 <b_jonas> 6.10.1 was released on 2008-11-04 according to http://haskell.org/ghc/download_ghc_6_10_1.html
14:01:51 <byorgey> 6.10.1 was November 2008, so still after 10-13
14:01:59 <b_jonas> so it was after
14:02:12 <b_jonas> then if it's indeed 6.10.1 introducing that function, we weren't that stupid
14:02:27 <b_jonas> but that means I'll have to read the docs to see what other useful new functions there are
14:03:38 <byorgey> there's also partitions
14:03:42 <byorgey> > partitions [1..5]
14:03:43 <lambdabot>   Not in scope: `partitions'
14:03:50 <byorgey> or... maybe I imagined that one =)
14:03:55 <copumpkin> I thought only subsequences and permutations were new
14:03:58 <b_jonas> there's "subsequences"
14:04:03 <byorgey> oh, subsequences, that's it
14:04:12 <byorgey> hmm, partitions would have been much more useful =)
14:04:56 <b_jonas> is stripPrefix new?
14:05:09 <byorgey> sounds new
14:05:13 <byorgey> @type stripPrefix
14:05:14 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
14:05:20 <byorgey> nice, didn't know about that one =)
14:05:31 <byorgey> > stripPrefix "ha" "hahaha!"
14:05:32 <lambdabot>   Just "haha!"
14:05:40 * b_jonas too, but that doesn't mean it's new
14:05:45 <byorgey> > stripPrefix "ha" "boo"
14:05:46 <lambdabot>   Nothing
14:06:23 <b_jonas> > stripPrefix "ha" "hello"
14:06:25 <lambdabot>   Nothing
14:06:45 <byorgey> > let maybeStrip pre s = fromMaybe s (stripPrefix pre s) in maybeStrip "ha" "hello"
14:06:46 <lambdabot>   "hello"
14:07:10 <chrisdone> anyone had luck using webcams from haskell?
14:07:47 <chrisdone> gonna start a video4linux library but if someone's already started one...
14:09:56 <byorgey> chrisdone: try asking on haskell-cafe, if there is someone there's only a small chance they happen to be on IRC right now.
14:10:34 <chrisdone> byorgey: aye, I'll do that
14:10:41 <osaunders> If a function isn't higher-order it is normal-order?
14:10:50 <b_jonas> osaunders: it's first order I think
14:11:48 <osaunders> Thnx
14:12:00 <b_jonas> or maybe zeroth order or something
14:12:16 <BMeph> stripPrefix is no later than 6.8.3
14:13:14 <BMeph> That is, it was introduced no later than...
14:13:44 <ben0x539> Is "MergingStAndIo" an actual proposal?
14:15:17 <increpare> copumpkin: ah I think I found my heap profiling solution - it counts the number of seconds the process is active for - mine was only ever using about 2% CPU, so obv it wasn't ever getting above 1 second : P
14:15:53 <copumpkin> ah :)
14:16:35 <b_jonas> good night
14:18:14 <mreh> so I've re-exported some modules, but I don't really understand what that does
14:18:34 <mreh> is it just re-exporting the names that I imported, or the whole module, or just the name of the module
14:21:49 <xerox> ?index mplus
14:21:49 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:22:42 <AmunRa> Hello! Tips and tricks with C++ interop? (note on existing code base: lots of OO, lots of templates and lots of managed pointers (no raw ones))
14:22:56 <Twey> AmunRa: Don't do it
14:23:08 <AmunRa> erhm..
14:23:08 <pikhq> AmunRa: The answer is "no".
14:23:27 <AmunRa> So I shouldn't use Haskell?
14:23:27 <pikhq> The long answer is "If you absolutely must, define a C API".
14:23:46 <Twey> AmunRa: No, you shouldn't use C++ :
14:23:51 <pikhq> C++ does not interoperate with any langauge.
14:23:55 <Twey> Aye.
14:23:59 <ben0x539> Least of all with C++
14:24:04 <chrisdone> teehee
14:24:05 <pikhq> Except by exposing C functions.
14:24:12 <Twey> *nod*
14:24:15 <pikhq> ben0x539: Yeah, it can only sometimes even manage *that*.
14:24:58 <AmunRa> C++ interops well with a number of things.. we have hundreds of thousands of lines of C++ invested in a highly performant code base which we are not going to throw away
14:25:34 <AmunRa> Haskell would be a good complement for many of its weaknesses.. mainly around productivity and correctness..
14:25:38 <pikhq> It is impossible to expose a single C++ function to any other language without wrapping it in C.
14:25:53 <AmunRa> pikhq: see python, see lua
14:26:04 <pikhq> Python doesn't do it.
14:26:11 <AmunRa> boost::python
14:26:13 <Dashkal> Erm?  I thought the Java bindings were direct C++ -> Java.
14:26:27 <pikhq> Dashkal: That's the GNU Java bindings.
14:26:40 <Dashkal> No, I mean JNI.  The jni tool will generate c++ headers
14:27:15 <pikhq> And those work because gcj compiles Java with a C++ ABI...
14:27:40 <pikhq> And that only works at all with a subset of C++.
14:28:26 <pikhq> AmunRa: Okay, so it's not impossible, it's just very very very very hard.
14:28:35 <Saizan_> AmunRa: afaiu it's quite easy to export Haskell code as C-callable functions, so you should be able to call those from C++ too?
14:29:54 <pikhq> For the most part, the way to interact with C++, though, is to go through C.
14:30:16 <ray> this also applies to combining c++ with c++
14:30:26 <AmunRa> ray: ??
14:31:07 <pikhq> C++ can only generally interoperate with C++ code that was compiled by the same compiler.
14:31:44 <kalven> can haskell code compiled with, say, ghc interoperate with haskell compiled with nhc?
14:31:55 <AmunRa> that's hardly ever a problem: gcc or icc on Linux are binary compatible and on Windows it's always VC++
14:32:00 <Heffalump> kalven: no
14:32:09 <kalven> no well defined abi?
14:32:15 <Heffalump> nope.
14:32:20 <kalven> I see
14:32:22 <Heffalump> not even from one version of ghc to the next
14:32:28 <pikhq> AmunRa: Not really. There's 2 or 3 different GCC ABIs.
14:32:41 <pikhq> And on Windows, there's the 2 or 3 GCC ABIs *and* VC++.
14:33:01 <AmunRa> sure, but you can just recompile the code base.. in a firm this is not really a problem we face :-)
14:33:36 <pikhq> Only because you've never tried writing a C++ library...
14:34:04 <pikhq> (which is only really feasible if you limit yourself to a specific compiler, or are open-source)
14:34:49 <ray> haskell binaries are a giant pain
14:35:01 <kalven> pikhq: or publish versions compiled for different toolsets.
14:35:20 <pikhq> kalven: Freaking hard, but feasible.
14:35:35 <sshc> in getAny, which is of type ":: (Random a) => State StdGen a" the first thing done is binding get to g by "g <- get", so shouldn't g now refer to the tube (v, s) where v is the value of the threaded state in the monad and s is the perhaps modified state?
14:35:44 <sshc> but g isn't used as a tuple
14:35:55 <sshc> this is all in http://www.haskell.org/all_about_monads/html/statemonad.html
14:35:56 <pikhq> Particularly with GCC's tendency to break at least small portions of the ABI every minor release...
14:36:04 <AmunRa> all of our code is compiled automatically on multiple platforms.. some low-level code contains #ifdef's to get around portability issues.. but this is very rare (e.g. memory allocators, memory mapped files, thread pools.. et cetera)
14:36:26 <benmachine> sshc: get has type State s s
14:36:28 <sshc> AmunRa: Haskell has a preprocessor?
14:36:30 <benmachine> you get a single value
14:36:36 <benmachine> unless the state is a tuple
14:36:39 <pikhq> AmunRa: If you want it to be called from Haskell: extern "C" functions.
14:36:45 <benmachine> the tupliness of it is hidden in the State bit
14:36:50 <AmunRa> sshc: no, i'm responding to pikhq's statement about C++ code
14:37:03 <pikhq> AmunRa: If you want code to be called from C++, foreign export "C".
14:37:15 <pikhq> And now you know how to do any interaction with C++: via C.
14:37:44 <sshc> benmachine: so after "g <- get", g will then refer to the current state being threaded through the monad?
14:37:50 <AmunRa> seems like I'll have to think if there's a way to abstract the interop then
14:38:08 <AmunRa> thanks for the pointers
14:38:37 <benmachine> sshc: g refers to the state at that point
14:39:02 <benmachine> so, do { put 3; g <- get; put 4; } has g as 3
14:39:09 <benmachine> even at the end
14:41:48 <sshc> benmachine: isn't a state a function?  In the example "random g" is used, but random doesn't take a function or a state.
14:42:01 <sshc> benmachine: and get is defined as: get   = State $ \s -> (s,s)
14:42:17 <sshc> benmachine: how would that cause get to refer to the current state?
14:42:53 <Saizan_> sshc: the one the function takes as argument is the current state
14:43:29 <benmachine> a state computation is a function that takes a state and returns a new state and a value
14:43:32 <sshc> Saizan_: which "one" are you referring to in "the one the funciton takes"?
14:43:49 <increpare> hmm...heap profile -> http://ded.indiefaqs.com/~locus/heapprofile.png   ; the heap usage seems to just continually increase whenever I'm moving, and instantly snap down as soon as I stop.
14:43:51 <benmachine> 'get' is a state computation where the value is equal to the input state
14:44:04 <benmachine> (and so is the new state)
14:44:40 <sshc> benmachine: so get returns a state computation, right?
14:44:48 <benmachine> get *is* a state computation
14:44:57 <Drunkenmonkey> A barrellroll
14:45:41 <sshc> benmachine: oh, so then it returns a value and a state.  (Right?)
14:45:46 <benmachine> yes
14:46:14 <Saizan_> sshc: get = State $ \s -> (s,s) <- there's only one argument here, 's'
14:46:16 <sshc> benmachine: but if it returns a value and a state, then shouldn't "g" refer to the value and state since it is bound by "g <- get"
14:46:19 <sshc> benmachine: ?
14:46:35 <benmachine> no, because that's not how do-notation works
14:46:39 <sshc> why doesn't it point to a tuple?
14:46:44 <Saizan_> sshc: State's >>= hides the state part, and let you see only the value
14:46:55 <Saizan_> directly.
14:47:17 <byorgey> the whole point of the State monad is that you DON'T have to deal with (value, state) tuples everywhere.
14:47:19 <Saizan_> do g <- get; .. = get >>= \g -> ..
14:47:30 <benmachine> g <- get means "assign the name 'g' to the result of 'get'"
14:47:49 <benmachine> the state returned by get goes into the next thing in the do-block
14:47:52 <Drunkenmonkey> I thought about trolling here, but I'm afraid you people would just not get it so I give up before starting
14:47:59 <Drunkenmonkey> Dumbasses
14:48:19 <sshc> Saizan_: directly?
14:48:22 <skorpan> Drunkenmonkey: okay
14:48:23 <benmachine> oh, by result I mean value
14:48:35 <BMeph> 'get' is to functions as 'call/cc' is to continuations? ;)
14:49:05 <Drunkenmonkey> skorpan: see you made a mistake there
14:49:14 <Drunkenmonkey> skorpan: any response is feeding the troll
14:49:22 <skorpan> i *want* to see some trolling to be honest
14:49:24 <Saizan_> sshc: with get you can look at the current state, because get returns it in the value part too
14:49:34 <byorgey> sshc: I think Saizan_ meant you can only see the value directly; the state you can see only indirectly (with 'get')
14:50:09 <benmachine> byorgey: or with runState/execState but that's sort of cheating
14:50:12 <Saizan_> yeah :)
14:50:28 <byorgey> benmachine: sure =)
14:50:28 <Drunkenmonkey> nothing is cheating
14:50:56 <ColonelJ> haskell is cheating
14:51:07 <Twey> It really is
14:51:13 <Drunkenmonkey> writing haskell is like having sex with a condom on
14:51:20 <sshc> benmachine: just to make sure I understand this correctly, a state computation is something of type State a b / a function than takes an initial state and returns a value and another state, perhaps modified?
14:51:36 <benmachine> sshc: yeah
14:51:40 <Drunkenmonkey> there's still a mess somewhere
14:51:41 <skorpan> Drunkenmonkey: safe?
14:51:58 <Drunkenmonkey> skorpan: it's safe, but it's still messy
14:52:15 <skorpan> so unsafe + messy vs. safe + messy
14:52:20 <sshc> benmachine: so when something is bound is a tuple, it takes the first part of the tuple and binds it to something (in this case g)?
14:52:27 <sshc> benmachine: I don't think that's true
14:52:30 <Drunkenmonkey> skorpan: no without one you get rid of the mess
14:52:38 <sshc> benmachine: so what exactly does Haskell bind to g?
14:52:52 <benmachine> sshc: the semantics of 'g <- get' depend on the implementation of >>= for State
14:53:03 <skorpan> Drunkenmonkey: without a condom you get into all sorts of shit you weren't expecting
14:53:21 <monochrom> http://xkcd.com/386/
14:53:21 <Drunkenmonkey> skorpan: it's an amazing analogy
14:53:24 <skorpan> Drunkenmonkey: indeed
14:53:54 * Heffalump thinks skorpan and Drunkenmonkey are in league
14:53:55 <ColonelJ> Drunkenmonkey: your analogy sucks, most people in here haven't had sex, with or without
14:54:10 <Drunkenmonkey> myth
14:54:23 <sshc> benmachine: how does "g <- something" work for the State monad?
14:54:28 <Drunkenmonkey> not everyone here a butt ugly
14:54:45 <Saizan_> sshc: get >>= \g -> .. = State (\s -> let (v,s') = runState get s in runState ((\g -> ..) v) s')
14:54:53 <osaunders> Is there a way for showing how types are resolved systematically?
14:54:53 <skorpan> the same analogy applies to pair programming.  if you do it once, you want to leave the other half right after.
14:54:55 <ColonelJ> Drunkenmonkey: as much as I want to stop trolling on that line, your statements infer that you are ugly
14:55:10 <Drunkenmonkey> ColonelJ: Could not be more wrong
14:55:24 <Drunkenmonkey> I am just a horrible person
14:55:32 <dibblego> can we take it to #haskell-blah please?
14:56:00 <Saizan_> sshc: = State (\s -> let (v,s') = (\s -> (s,s)) s in runState ((\g -> ..) v) s') = State (\s -> let (v,s') = (s,s) in runState ((\g -> ..) v) s') = State (\s -> runState ((\g -> ..) s) s)
14:56:22 <benmachine> sshc: for all monads, foo <- bar turns into bar >>= \foo ->
14:56:29 <benmachine> :t (>>=)
14:56:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:56:36 <sshc> Saizan_: allow me to take a few moments to attempt to understand that.
14:56:42 <benmachine> the key is the 'a' parameter in the second argument
14:57:16 <benmachine> >>= passes a value to that function
14:57:38 <benmachine> which it 'gets out of' the first argument
14:57:51 <benmachine> in g <- get you are basically just calling that value g
14:58:01 <benmachine> oh I think I am even confusing myself now
14:58:03 <Drunkenmonkey> so this is where a monad is perpetually explained, interesting
14:58:05 * benmachine goes and does maths instead
14:58:27 <sshc> benmachine: I'm calling which value "g"?
14:58:47 <ColonelJ> Drunkenmonkey: when was it explained last?
14:58:50 <Saizan_> sshc: the value >>= passes to its second argument
14:58:55 <Saizan_> ?type (>>=)
14:58:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:59:01 <osaunders> I had a serious question.
14:59:33 <ColonelJ> Types are resolved using type inference
14:59:35 <benmachine> osaunders: I missed it and then I went back and read it and now I don't understand what it means but I probably wouldn't be able to answer it anyway
14:59:45 <benmachine> I wish you luck in finding an answer
14:59:46 <Saizan_> sshc: do you have the implementation of (>>=) for the State monad handy? it's essentially my first line above.
15:00:04 <ColonelJ> @src State
15:00:05 <osaunders> OK.
15:00:05 <lambdabot> Source not found. My mind is going. I can feel it.
15:00:13 <Saizan_> osaunders: can you ask again?
15:00:16 <Drunkenmonkey> ColonelJ: probably yesterday
15:00:22 <osaunders> Is there a way for showing how types are resolved systematically?
15:00:30 <ColonelJ> Drunkenmonkey: that long?
15:00:37 <sshc> Saizan_: (State x) >>= f = State $ \s -> let (v,s') = x s in runState (f v) s'
15:01:11 <Saizan_> sshc: yeah, right, i've used runState instead of pattern matching on the first argument, but they are the same
15:01:12 <osaunders> For instance how (.) :: (b -> c) -> (a -> b) -> a -> c is filled out with values.
15:01:37 <sshc> Saizan_: what do you mean "the value >>="?
15:01:37 <Saizan_> values?
15:02:23 <Saizan_> sshc: ">>=" was the subject of "passes" in that sentence
15:02:27 <benmachine> heh
15:02:30 <ColonelJ> here's somewhere to explain monads
15:02:30 <ColonelJ> http://www.haskell.org/haskellwiki/Introduction
15:02:40 <benmachine> read it as, the value that >>= passes to its second argument
15:02:50 <sshc> Saizan_: oh I see :)
15:03:12 <ColonelJ> Everyone should get their heads together for an excellent FAQs answer on that page
15:03:16 <sshc> so, g will be the value that >>= passes to its second argument.  ok.
15:03:51 <benmachine> ColonelJ: there are about a million ways of explaining monads and none of them really work
15:03:56 <benmachine> you just have to use them until they make sense
15:04:00 <Saizan_> osaunders: there isn't a systematic way to show how the type checker infers types, unfortunately
15:04:26 <benmachine> osaunders: sometimes you can get interesting results by doing things like
15:04:31 <osaunders> I still don't really understand what happens when you say ((!! 1) . reverse) I'd like a step-by-step resolution of how (!! 1) and (reverse)'s types are combined into a single function.
15:04:42 <benmachine> @type (.) (undefined :: Int)
15:04:44 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Int'
15:04:44 <lambdabot>     In the first argument of `(.)', namely `(undefined :: Int)'
15:04:44 <lambdabot>     In the expression: (.) (undefined :: Int)
15:04:47 <ColonelJ> > !! 1
15:04:49 <benmachine> whoops
15:04:49 <lambdabot>   <no location info>: parse error on input `!!'
15:04:51 <benmachine> @type (.) (undefined :: Int -> Char)
15:04:53 <lambdabot> forall (f :: * -> *). (Functor f) => f Int -> f Char
15:05:04 <benmachine> oh yeah, caleskell
15:05:17 <Saizan_> for monads there are a few articles or papers that i'd recommend, for State in particular i'd play symbolically witht he implementation
15:05:28 <osaunders> caleskell?
15:05:58 <Drunkenmonkey> even dons is here
15:06:08 <Drunkenmonkey> who would have thought it
15:06:56 <sshc> Saizan_: which articles would you recommend?
15:07:20 <sshc> Saizan_: I'm particularly confused at this point.  Not sure how "g <- get" works
15:07:24 <benmachine> osaunders: lambdabot has a few modifications to the prelude because Cale likes them, they have been nicknamed caleskell
15:07:32 <benmachine> (.) = fmap is one
15:07:40 <benmachine> another is
15:07:42 <benmachine> @type (++)
15:07:44 <lambdabot> forall m. (Monoid m) => m -> m -> m
15:07:51 <Saizan_> osaunders: (.) :: (b -> c) -> (a -> b) -> (a -> c), (!! 1) :: [x] -> x, reverse :: [y] -> [y], the application of (.) to both those gives you the constraints: (b -> c) = [x] -> x, (a -> b) = [y] -> [y], so by decomposition, those are reduced to b = [x] = [y], c = x, a = [y], and then from [x] = [y] you get x = y
15:07:54 <benmachine> a generalisation of the normal type
15:08:16 <Saizan_> sshc: have you followed my reduction steps above? that's how g <- get works.
15:09:20 <Saizan_> sshc: i'd recommend this one in particular if you want to dispel the magic aspect http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:09:23 <ColonelJ> :t \x -> x
15:09:25 <lambdabot> forall t. t -> t
15:09:27 <osaunders> Saizan_: Ahh I think that's exactly what I wanted. Let me write these out so they line up and I can see it all working.
15:09:51 <sshc> :t do{put 3; g <- get; put 4}
15:09:52 <lambdabot> forall (m :: * -> *) s. (Num s, MonadState s m) => m ()
15:10:36 <Saizan> sshc: i just reconnected, got my link?
15:11:55 <sshc> Saizan: 23:08:56 < Saizan_> sshc: i'd recommend this one in particular if you want to dispel the magic aspect  http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:12:01 <sshc> if that's the one, then yes.
15:12:06 <Saizan> sshc: yeah, that
15:12:59 <Saizan> osaunders: did my explanation above made any sense?
15:13:38 <osaunders> I'm playing with it now.
15:14:19 <osaunders> I'm trying to lay it out like you solve an equation.
15:14:53 <PepeSilvia> is there a library like python
15:14:58 <PepeSilvia> 's os.path for haskell?
15:15:29 <Saizan> there's System.FilePath to manipulate paths
15:15:52 <Saizan> to actually work on the filesystem you need System.IO and System.Directory
15:16:09 <PepeSilvia> Saizan: thanks!
15:16:37 <Saizan> osaunders: it's more like a system of equations
15:17:33 <Saizan> well, it's precisely one :)
15:17:56 <increpare> Hmm, the impredicate types thing can be got around (at least in my case) by pulling out the offending nested forall into a newtype.
15:18:18 <increpare> (impredicative)
15:18:36 <Saizan> yeah
15:18:37 <osaunders> Saizan: Hm.
15:20:08 <Saizan> initially you've this two equations (b -> c) = [x] -> x, (a -> b) = [y] -> [y], do you get how i collected these? i could add more steps
15:23:43 <Saizan> one of the axioms of the type system is that when you've an expression (f x) then f :: a -> b, x :: a, and (f x) :: b, for some a and b
15:25:08 <osaunders> I'm almost done, I think.
15:25:17 <osaunders> This is pretty hard and I think I might have got it wrong.
15:25:25 <osaunders> I'll let you see in a minute.
15:26:16 <Saizan> so, when it sees (((.) (!!1)) reverse), it knows ((.) (!!1)) :: a -> b, reverse :: a and the whole :: b, then it recurses down, so (.) :: c -> d, (!!1) :: c, ((.) (!!1)) :: d, but it also was :: a -> b, so d = a -> b, then so far we know (.) :: c -> a -> b, etc..
15:26:31 <Saizan> k :)
15:28:09 <Saizan> (it's something best done by a prolog interpreter or equivalent, anyway)
15:28:36 <osaunders> God I don't know what this is achieving any more.
15:28:44 <osaunders> ((b   -> c) = ([x] -> x)) -> (( a  ->  b ) = ([y] -> [y])) ->  a  -> c
15:28:44 <osaunders> (([x] -> c) = ([x] -> x)) -> (( a  -> [x]) = ([y] -> [y])) ->  a  -> c
15:28:44 <osaunders> (([x] -> x) = ([x] -> x)) -> (( a  -> [x]) = ([y] -> [y])) ->  a  -> x
15:28:45 <osaunders> (([x] -> x) = ([x] -> x)) -> (([y] -> [x]) = ([y] -> [y])) -> [y] -> x
15:28:45 <osaunders> ([x] -> x)                -> ([y] -> [y])                  -> [y] -> x
15:29:30 <osaunders> I just never seem to understand how these types graft on to one another so I thought this might help.
15:29:58 <Saizan> you forgot to propagate the fact that x = y
15:30:06 <Saizan> from the second equation
15:30:21 <osaunders> How do we know that x = y?
15:30:35 <Saizan> (([y] -> [x]) = ([y] -> [y])) <- by this
15:31:15 <osaunders> Oh yeah.
15:31:17 <osaunders> OK.
15:32:06 <osaunders> But isn't [y] different from y?
15:32:23 <osaunders> I'm so confused.
15:32:42 <Saizan> those are different
15:33:15 <copumpkin> [y] is either [] y or y : []
15:33:25 <Saizan> well for f -> g = h -> i to hold, both f = h and g = i have to hold
15:33:40 <Saizan> and for [y] = [x] to hold, y = x must hold
15:33:57 <Saizan> these are called decomposition rules
15:34:07 <Saizan> they basically say that type constructors are injective
15:35:04 <Saizan> you can imagine like we're applying an inverse of [] to both sides of the equation, just like you do to reduce x + 1 = y + 1 to x = y
15:35:35 <osaunders> Hm.
15:35:40 <osaunders> OK.
15:36:11 <Saizan> so from [y] -> [x] = [y] -> [y] we get [y] = [y] and [x] = [y], the first equation doesn't say anything interesting, the second one can be decomposed further into x = y
15:36:14 <BleSS> is there any library to manage logging messages? rather that write them to stdout
15:36:24 <Saizan> by stripping [] away from both sides
15:36:45 <Saizan> BleSS: there's HsLogger on hackage, iirc the name
15:36:51 <sshc> Saizan: thank you for showing me that article.  I've got to "bind f' :: (Float,String) -> (Float,String)" but I'm not really sure what this is.
15:37:22 <Saizan> sshc: that's (>>= f) for the Writer monad
15:37:34 <osaunders> Saizan: OK, that makes sense.
15:37:59 <sshc> Saizan: I want to understand what the article is trying to explain to me.  I don't want to read further until I understand what bind is.
15:38:18 <sshc> Saizan: (not sure what (>>= f) is for the Writer monad)
15:38:47 <Saizan> sshc: ah, well, that article is trying to show you how monads come naturally as a way to abstract some boilerplate from the code
15:38:55 <ColonelJ> @src Writer
15:38:55 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:39:02 <Saizan> sshc: for each different kind of "boilerplate" you get a different monad
15:39:20 <sshc> Saizan: ok, but I want to know what "bind" is doing
15:39:25 <sshc> Saizan: what the purpose of it is
15:39:27 <Saizan> sshc: that in particular is a monad which keeps a log as a String, and concatenates the logs from the various actions
15:39:48 <Gracenotes> bind is partly why people say monads are so nicely composable
15:39:51 <BleSS> is possible to call/run a shell command?
15:39:55 <sshc> Saizan: but what does the "bind" function do in the first part?
15:40:02 <sshc> Saizan: in the first section of the article?
15:40:15 <Saizan> sshc: you can look at the solution
15:40:22 <Saizan> sshc: bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs)
15:40:29 <aavogt> sshc: which article?
15:40:49 <Saizan> sshc: the purpouse is to compose two functions which produce logs along their result
15:40:52 <ColonelJ> open shell, type command, hit return
15:41:07 <Saizan> BleSS: seen System.Process ?
15:41:13 <Saizan> aavogt: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:41:23 <ColonelJ> and what?
15:41:25 <sshc> aavogt: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:41:28 <Dashkal> join #kde
15:42:12 <aavogt> yeah, that's a good one
15:42:26 <sshc> this part is confusing too "bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))"
15:42:30 <BleSS> Saizan: I'm a newbie and I wanted to know if haskell has some tools usefull to doing scripting (to rewriting a library from python)
15:42:43 <sshc> why is the author showing me the type signatures?
15:42:46 <sshc> of bind?
15:43:00 <aavogt> @type (>>=)
15:43:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:43:06 <aavogt> @type (=<<)
15:43:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:43:21 <copumpkin> sshc: the point is that he's showing you how to get there
15:43:34 <osaunders> Saizan: http://codepad.org/tclIXjLC
15:43:38 <sshc> copumpkin: how to get where?
15:43:49 <copumpkin> sshc: the kind of thought process that might lead you to the idea if you'd never heard of the word monad
15:44:00 <sshc> copumpkin: what does "bind" in the article do?
15:44:05 <aavogt> going from specifics to the general things common between all those monads?
15:44:10 <copumpkin> sshc: read the article :P
15:44:21 <Saizan> osaunders: going back?
15:44:44 <osaunders> Shows that I can return to original (b -> c) -> (a -> b) -> a -> c
15:45:42 <Saizan> ah, yeah, with the equivalences produced so far the two types are equal
15:46:09 <yitz> BleSS: hslogger is something like Python
15:46:16 <yitz> 's logging module
15:46:32 <BleSS> yitz: yes, I saw about it, cool! :)
15:46:33 <osaunders> Although what  I really want as the final step is: [a] -> a because :t ((!! 1) . reverse) gives [a] -> a
15:46:59 * yitz needs a keyboard with apostrophe *not* right next to Enter
15:47:01 <osaunders> I suppose [a] -> a = x -> y but [a] -> a is more meaningful.
15:47:10 <Saizan> osaunders: well, you're finished here => ( [x] -> x              ) -> (                [x] -> [x] ) -> [x] -> x
15:47:29 <yitz> BleSS: there's also hsyslog, lower level interface to syslog
15:47:32 <Saizan> osaunders: the result type is [x] -> x, which is equivalent to [a] -> a just by renaming
15:47:38 * companion_cube gives an azerty keyboard to yitz 
15:47:57 <yitz> BleSS: and yes, as Saizan says, you definitely want to make friends with System.Process.
15:48:23 <BleSS> yitz: I was finishing my python library to replace bash scripts on linux boot, but it looks that haskell is amazing
15:48:26 <BleSS> thanks
15:48:41 <osaunders> Maybe I should read about how type inference works.
15:48:56 <xerox> http://mumble.net/~campbell/images/HM-t-shirt.png
15:49:04 <companion_cube> isn't it unification algorithm ?
15:49:07 <Saizan> osaunders: (  b  -> c              ) -> (                a   ->  b ) ->  a   -> c was the type of (.), not (.) (!!1) reverse
15:49:12 <companion_cube> for type inference
15:49:21 <yitz> companion_cube: Thqnks!
15:49:32 <Saizan> companion_cube: a little more as the png suggests :)
15:50:09 <osaunders> Saizan: Ah yes. So ( [x] -> x ) -> ( [x] -> [x] ) -> [x] -> x wasn't really complete, was it?
15:50:36 <osaunders> Are there steps in between ( [x] -> x ) -> ( [x] -> [x] ) -> [x] -> x and [x] -> x?
15:51:01 <Saizan> osaunders: it is complete, but it's not the type of the whole expression, only part of it, the type of the result was (a -> c) from the start, so [x] -> x
15:51:31 <companion_cube> Saizan: what does this represent exactly ?
15:52:07 <osaunders> Technically the result is just c, though.
15:52:25 <Saizan> companion_cube: those are the inference rules for the hindley milner type system, which is the base of the haskell one
15:52:32 <HugoDaniel> hi
15:52:38 <osaunders> Oh no, it's not, wait. I'm stupid.
15:52:47 <lpsmith> @let powerfoldr f b as = b : fold as where { fold [] = [] ; fold (a:as) = f a b : concatMap (\b' -> [b', f a b']) (fold as) }
15:52:47 <Saizan> osaunders: well, the result, or better value of ((!!1) . reverse) is a function
15:52:48 <lambdabot>  Defined.
15:53:13 <osaunders> Yes.
15:53:15 <dmhouse> If I wanted to upgrade from GHC 6.10.1 to the latest GHC, I can't just install this newfangled Haskell platform wotsis, can I?
15:53:30 <Saizan> osaunders: we started with (.) :: (b -> c) -> (a -> b) -> a -> c, so if you apply it to two arguments you're left with (a -> c)
15:53:32 <dmhouse> I'm told " The Haskell Platform version 2009.2.0.2 requires ghc-6.10.4"
15:53:42 <osaunders> Saizan: Right.
15:53:46 <lpsmith> > powerfoldr (+) 0 (iterate (*2) 1)
15:53:47 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:54:17 <companion_cube> Saizan: wow, only 4 rules for the whole typesystem ?
15:54:35 <xerox> the lambda calculus is pretty :)
15:54:40 <osaunders> Saizan: Thanks for all the help so far.
15:55:28 <Saizan> companion_cube: yeah, that's roughly Haskell's type system without typeclasses and GHC extensions
15:55:42 <Saizan> osaunders: np
15:56:17 <companion_cube> do typeclasses heavily complicate the rules ?
15:57:06 <osaunders> companion_cube: I'm pretty sure they don't.
15:57:19 <companion_cube> \o/
15:57:21 <osaunders> Types with different typeclass constraints are considered inequal.
15:57:36 <Saizan> well the contraints just cumulate
15:58:21 <Saizan> and you've to make sure you give a concrete type for all the type variables that won't be able to be instantiated anymore
15:58:32 <Saizan> i guess a good read is "typing haskell in haskell"
15:58:52 <osaunders> @google typing haskell in haskell
15:58:55 <lambdabot> http://citeseer.ist.psu.edu/424440.html
16:00:40 <Saizan> http://web.archive.org/web/20060516235636/www.cse.ogi.edu/~mpj/thih/ <- here's the code
16:01:00 <Nomad010> powerfoldr (+) 0 (iterate (*3) 1)
16:01:17 <Nomad010> powerfoldr (+) 0 (iterate (*2) 1)
16:01:33 <lpsmith> nomad010:   add a > at the beginning of your line
16:01:48 <dh_> good evening guys. I still have question on fix point combinator. How comes the fix cannot find the fixed point of (* 2) ? Is there a determinate way to find fixed point of a lambda expression?
16:02:01 <Nomad010> yeah i just saw that
16:02:02 <Nomad010> thanks
16:02:04 <Nomad010> lol
16:02:40 <sshc> alright, I wrote bind: "bind f (v, otherv) = let (v', otherv') = f (v) in  (v', otherv ++ otherv')  :: (Float -> (Float, String)) -> (Float, String) -> (Float, String)".
16:02:43 <xerox> dh_ this explains it quite well <http://en.wikibooks.org/wiki/Haskell/Denotational_semantics> I think dmouse or kowel wrote it.
16:02:46 <xerox> *kowey
16:03:08 <dh_> xerox: Thanks, I'll read it.
16:03:11 <sshc> aha, I did this correctly (for once)! :)
16:03:18 <xerox> *dmhouse
16:03:35 <Saizan> sshc: nice :)
16:03:53 <dmhouse> xerox: believe that one was apfelmus's doing, actually
16:04:15 <xerox> dmhouse I thought it were you two that wrote the entire thing, ok :)
16:04:56 <dmhouse> xerox: it was mostly, but apfelmus popped in here and there
16:05:23 <hiptobecubic> appelmoes?
16:05:40 <xerox> very good work, I used it to attract a couple of mathematics course-friends of mine to Haskell
16:06:02 <sshc> (2.5, "test") `bind` \_ -> (3.0, "test2")
16:06:12 <osaunders> I'm starting to think it would be really great to compile a huge mass of Haskell exercises. Starting from stupidly simple and building up.
16:06:45 <sshc> <interactive>:1:0:  Couldn't match expected type `Float -> (Float, String)'  against inferred type `(t, [Char])' In the first argument of `bind', namely `(2.5, "test")'
16:06:46 <osaunders> Things like "write the graph reduction for these", "what is the type for these?"
16:07:01 <companion_cube> did you people ever found some things hard -- or even impossible -- to implement in haskell ?
16:07:34 <sshc> companion_cube: A round cube
16:07:45 <companion_cube> :)
16:07:55 <osaunders> You can't implement a reference in Haskell.
16:08:07 <xerox> ?docs Data.IORef
16:08:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
16:08:10 <sshc> osaunders: IORef
16:08:25 <sshc> osaunders: you can kind of emulate one too
16:08:32 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-IORef.html  actually
16:08:34 <osaunders> Oh OK. :-)
16:08:34 <companion_cube> well, i thought of something like a huge mutable graph, how do you implement it and stay pure ?
16:08:35 <Saizan> with an IntMap
16:09:11 <companion_cube> (i'm surely very wrong, i'm a noob)
16:09:12 <sshc> (2.5, "test") `bind` \_ -> (3.0, "test2")
16:09:16 <sshc> ^ why isn't that working?
16:09:30 <companion_cube> >  (2.5, "test") `bind` \_ -> (3.0, "test2")
16:09:31 <lambdabot>   Not in scope: `bind'
16:10:04 <Saizan> companion_cube: well if you really want it to be mutable you can at best encapsulate it into the ST monad, which can be run from pure code, though there are also libs to work with pure immutable graphs reasonably efficiently
16:10:14 <xerox> > (2.5,"test") >>= const (3.0,"test2")
16:10:15 <lambdabot>   No instance for (GHC.Base.Monad ((,) t))
16:10:15 <lambdabot>    arising from a use of `GHC.Base...
16:10:30 <xerox> sshc try import Control.Monad.Instances
16:11:01 <Saizan> sshc: what error are you getting?
16:11:07 <sshc> <interactive>:1:0:  Couldn't match expected type `Float -> (Float, String)'  against inferred type `(t, [Char])' In the first argument of `bind', namely `(2.5, "test")'
16:11:28 <sshc> I think it needs (2.5, "test), the first argument of bind, to be a function
16:11:30 <Saizan> sshc: oh, bind takes the function first.
16:12:08 <Saizan> sshc: bind (\_ -> (3.0, "test2")) (2.5, "test1") <- this will work
16:12:17 <xerox> oops.
16:12:33 <companion_cube> Saizan: yes, for immutable graphs, but what about graphs (or some other structure with lots of cycles of pointers) you want to be able to modify ?
16:12:38 <sshc> Saizan: indeed it did
16:13:12 <companion_cube> i have the feeling that changing pointers in a non tree-like structure is hard
16:13:45 <Saizan> companion_cube: well, you can "modify" immutable graphs by constructing a new one from the old one, hopefully sharing as much of the structure as you can
16:14:06 <companion_cube> Saizan: this looks ugly for large graphs :)
16:14:08 <Saizan> companion_cube: but it's indeed easier with trees
16:14:32 <sshc> companion_cube: in C, it'd be more difficult; for example, if you swap two nodes or sort the graph, the pointers would still point to same location in memory, but would refer to different nodes
16:14:43 <dh_> I think my question about fix point is : can we define a function, that calculate any lambda function's fixed point if exists ?
16:14:44 <companion_cube> i suppose in this case you just have to replace nodes between the mutated one and the root ?
16:14:50 <sshc> companion_cube: unless I don't understand what you're asking
16:15:00 <dh_> for example, 0 is fixed point of 2*, but fix (2 * ) just loop forever.
16:15:10 <Saizan> companion_cube: yeah, i guess it can be, in that case we can use references like IORef or STRef, the first ones live in IO, so you're trapped there, STRefs live in the ST monad, and you can run an ST computation from pure code
16:15:31 <sshc> @src fixed
16:15:31 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:15:36 <sshc> what is fixed?
16:15:36 <Saizan> companion_cube: the run function for ST ensures that no side-effect escapes to the outside
16:15:43 <companion_cube> sshc: uh, in C i think you just replace all pointers
16:15:47 <dh_> fixed point combinator.
16:15:55 <dh_> @src fix
16:15:55 <lambdabot> fix f = let x = f x in x
16:16:47 <sshc> > fix error
16:16:48 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
16:16:50 <companion_cube> Saizan: yes, but the point is : can you have a large mutable graph that you can change without replacing half of nodes :)
16:16:51 <dmhouse> While we're in Wikibook plugging mode: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
16:16:54 <Saizan> dh_: fix calculates the _least_ fixed point, in the definedness order, and yes, we can, the least fixed point of f is (f (f (f ...)))
16:16:54 <sshc> that worked well
16:17:03 <yitz> > fix show
16:17:04 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:17:25 <Saizan> companion_cube: with references it's no different than C pointers, you just get better types :)
16:17:38 <chrisdone> @hoogle c_open
16:17:39 <lambdabot> No results found
16:17:41 <dh_> I guess I don't understand the _least_ here.
16:18:19 <companion_cube> Saizan: you mean that in IO monad you can code like in C ?
16:18:26 <dh_> but is it possible to find all fixed point?
16:18:28 <yitz> dh_: see the wikibooks article ref. by xerox above
16:18:43 <dmhouse> yitz: oi, that was me. And I actually wrote that one :)
16:19:02 <yitz> dmhouse: it's a good article
16:19:05 <Saizan> dh_: have you read the "Bottom and Partial Functions" paragraph? that should explain in which order it is the least
16:19:32 <Saizan> dh_: and i don't think there's a general way to calculate all the fixed points
16:19:38 <Saizan> companion_cube: yes
16:20:00 <dh_> saizan: that's the question I want to ask :)
16:20:04 <companion_cube> Saizan: ok, thanks :)
16:20:22 <Saizan> companion_cube: well, not with the same syntax, and more safely in general, but you have access to the same power if you want
16:22:09 <sshc> @let bind f (v, otherv) = let (v', otherv') = f (v) in  (v', otherv ++ otherv')  :: (Float -> (Float, String)) -> (Float, String) -> (Float, String)
16:22:09 <lambdabot>  <local>:5:51:
16:22:09 <lambdabot>      Couldn't match expected type `(Float -> (Float, String))
16:22:09 <lambdabot> ...
16:22:29 <sshc> why isn't it working with lambdabot?
16:22:35 <companion_cube> i can't figure how evil it is to code almost only in IO Monad :)
16:23:07 <Saizan> @let bind :: (Float -> (Float, String)) -> (Float,String) -> (Float, String); bind f (v, otherv) = let (v', otherv') = f (v) in  (v', otherv ++ otherv')
16:23:09 <lambdabot>  Defined.
16:23:18 <Saizan> sshc: the type signature was in the wrong place
16:23:52 <yitz> dh_: think of the function g f = if f halts then f else id. it will be hard to find all the fixed points of g.
16:24:30 <Saizan> companion_cube: very evil, it's already quite nice, but you miss a lot of the reasoning simplicity that purity gives you
16:24:58 <companion_cube> it doesn't surprise me
16:25:18 <sshc> @let f :: Float -> (Float, String); f x = (2 * x, "doubled ")
16:25:19 <dh_> yitz: if f halts is undecidable
16:25:19 <lambdabot>  Defined.
16:25:37 <sshc> @let g :: Float -> (Float, String); g x = (x * x, "squared ")
16:25:38 <lambdabot>  Defined.
16:25:57 <sshc> @let h :: Float -> (Float, String); h x = (x + 1.0, "incremented ")
16:25:58 <lambdabot>  Defined.
16:26:17 <sshc> > f `bind` g $ 3.0
16:26:18 <lambdabot>   Ambiguous occurrence `f'
16:26:18 <lambdabot>  It could refer to either `L.f', defined at <local...
16:26:31 <yitz> dh_: right. so we can't decide whether f is a fixed point of g. (though i guess we could enumerate all of them)
16:26:38 <benmachine> > L.f `bind` g $ 3.0
16:26:39 <lambdabot>   Ambiguous occurrence `g'
16:26:39 <lambdabot>  It could refer to either `L.g', defined at <local...
16:26:45 <benmachine> > L.f `bind` L.g $ 3.0
16:26:46 <lambdabot>   Couldn't match expected type `(GHC.Types.Float, GHC.Base.String)'
16:26:46 <lambdabot>         a...
16:26:50 * benmachine grumbles
16:26:53 <Saizan> > bind L.f . L.g $ 3.0
16:26:55 <lambdabot>   (18.0,"squared doubled ")
16:26:56 <chrisdone> @hoogle withCString
16:26:57 <lambdabot> Foreign.C.String withCString :: String -> (CString -> IO a) -> IO a
16:26:57 <lambdabot> Foreign.C.String withCStringLen :: String -> (CStringLen -> IO a) -> IO a
16:27:06 <Saizan> sshc: ^^^
16:27:19 <sshc> Saizan: why doesn't f `bind` g $ 3.0 work?
16:27:29 <sshc> Saizan: or L.f and L.g with lambdabot
16:28:09 <benmachine> :t L.g
16:28:09 <Saizan> sshc: because bind doesn't directly compose the two functions, it's just supposed to transform one so that it can be composed
16:28:10 <lambdabot> Float -> (Float, String)
16:28:13 <benmachine> :t bind
16:28:14 <lambdabot> (Float -> (Float, String)) -> (Float, String) -> (Float, String)
16:28:42 <sshc> Saizan: oh, I see
16:29:17 <sshc> why isn't the type (Float -> (Float, String)) -> ((Float, String) -> (Float, String))?
16:29:26 <benmachine> those types are equivalent
16:29:34 <Saizan> -> is right associative
16:29:40 <Saizan> so they are the same type
16:29:42 <benmachine> a -> b -> c == a -> (b -> c)
16:29:44 <Philonous> dh_: The cpo in question here is _|_ < x for all x =\ _|_ and no other elements compare.
16:29:45 <sshc> I see
16:30:07 <BleSS> is there support to manage regular expressions?
16:30:25 <dh_> Philonous: ??? what's cpo?
16:30:36 <yitz> BleSS: yes, but you're usually better off using other nicer parsers instead.
16:30:37 <Saizan> which is related to the fact that an n-ary function in haskell can be seen as a 1-ary function that returns an (n-1)-ary one
16:31:05 <BMeph> BleSS: Did you mean: support to _mangle_ regular expressions? -- ;p
16:31:05 <BleSS> yitz: ok, I'll have in mind
16:31:25 <Philonous> dh_: A complete partial order. What I meant to say is that "least fixed points" refers to the <-relation where _|_ is smaller than everything else, NOT the one defined in ord
16:31:31 <yitz> BleSS: several different flavors of regexps are supported - posix, perl-style, etc.
16:32:30 <dh_> Philonous: thanks. my question is : can I find all fixed point of a lambda function?  the least fixed points is not what I want.
16:32:52 <dmhouse> Sounds like a pretty hard problem in general
16:33:14 <BleSS> I'm impressed with haskell, dynamic compilation, parallel computing, great performace, saves memory, ...
16:33:18 <dmhouse> I wouldn't be surprised if it turned out to be equivalent to the halting problem, e.g.
16:33:29 <Philonous> dh_ No you can't, except for very few functions.
16:33:36 <BleSS> I hope any tutorial to people that comes from imperative languages
16:33:39 <yitz> dmhouse: what i wrote above doesn't prove that?
16:33:42 <dh_> Philonous: why I can't ?
16:33:51 <dmhouse> yitz: it may well do, I've joined this party late
16:33:55 <chrisdone> :hoogle catchAny
16:33:57 <chrisdone> @hoogle catchAny
16:33:57 <lambdabot> No results found
16:33:59 <sshc> @let unit :: Float -> (Float, String); unit x = (x, "")
16:34:00 <lambdabot>  Defined.
16:34:02 <pikhq> Regular expressions in Haskell are kinda not used all that often; a proper parser is just easier.
16:34:08 <sshc> let's see how close I was
16:34:17 <jlouis> BleSS: it also saves headaches
16:34:22 <yitz> dmhouse: think of the function g f = if f halts then f else id. it will be hard to find all the fixed points of g.
16:34:31 <sshc> yes, exactly the same besides the space after the comma! :)
16:34:46 <yitz> dmhouse: we can't decide whether f is a fixed point of g. (though i guess we could enumerate all of them)
16:34:56 <dh_> yitz: if f halts is not a lambda
16:35:08 <chrisdone> @hoogle catch
16:35:09 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
16:35:09 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
16:35:09 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
16:35:11 <dmhouse> yitz: that doesn't look like a computable function in the first place
16:35:12 <Philonous> dh_: You would solve the halting problem, which is impossible.
16:35:25 <yitz> dmhouse: that's what i was trying to prove
16:35:58 <dh_> Philonous: how did u reduce the question to halting problem?
16:37:20 <p_l> dh_: "if halts"?
16:37:40 <dh_> "if halts" is not I wrote, ask yitz
16:37:41 <dmhouse> yitz: well, what would be the least fixed point of that function? Even that should be hard to define
16:37:52 <yitz> yes, i see.
16:37:58 <kmc> "dynamic compilation"?
16:40:23 <BleSS> kmc: I mean it lets dynamic compilation of libraries, I remind ago some years that it built static liraries on linux
16:40:43 <sshc> @let lift :: (Float -> Float) -> Float -> (Float, String); lift  f = unit . f
16:40:44 <lambdabot>  Defined.
16:40:47 <BleSS> s/liraries/libraries
16:41:14 <chrisdone> how does one define, create and access C structures from Haskell's FFI? do we create interface functions to do it all?
16:41:40 <kmc> oh yes
16:41:48 <Philonous> dh_: To see if x is a fixed point of f you have to decide whether f halts for input x.
16:42:43 <Saizan> chrisdone: or use the Storable typeclass, but you need to calculate the offsets, c2hs helps with its {#get field #} expressions
16:44:18 <yitz> BleSS: i just started using skype (against my better judgement, but a client requires it) i was amused to find that when you type s/foo/bar/ in a chat, it actually makes that change to the text of your last previous post.
16:44:47 <povman> hi everyone!
16:45:02 <dh_> Philonous: can't agree with u.
16:45:08 <povman> I love this function: f &&&& g = \a -> f a && g a
16:45:18 <povman> is it defined anywhere good?
16:45:23 <kmc> :t liftM2 (&&)
16:45:24 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
16:45:26 <shachaf> yitz: On both sides?
16:45:26 <dh_> Philoous: in your logic, any function is a halting problem
16:45:29 <dibblego> litA2 (&&)
16:45:33 <dibblego> liftA2 (&&)
16:45:43 <yitz> shachaf: yes. big brother, edit history.
16:46:05 <chrisdone> Saizan: sounds.. fun >_<
16:46:19 <shachaf> yitz: Huh. Indeed.
16:46:28 <yitz> shachaf: there's also an Edit button that gives you gui interface for dummies, of course.
16:46:43 * shachaf has been using Etherpad for communication recently.
16:46:43 <sshc> Saizan: I've come to the third exercise, which is: "Show that lift f * lift g = lift (f.g)".  What exactly is it asking me to do?
16:47:00 <merijn> I'm reading up on monads and the article says lists are a monad too. Am I correct in thinking that "a -> [a]" is then the same (or similar to) "a -> List a" (assuming "List" would be the list monad)?
16:47:08 <kmc> yes
16:47:12 <dibblego> merijn, yes
16:47:18 <kmc> you can write "[a]" prefix as "[] a"
16:47:18 <sshc> Saizan: * has, previously in this arcticle, referred to bind, but it can't in this cas; nor can it refer to the literal (*) function
16:47:37 <merijn> kmc, dibblego: Nice, thanks.
16:47:39 <kmc> > do { x <- [1,2]; y <- [3,4]; return x+y } :: ([] Int)
16:47:40 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
16:47:40 <lambdabot>    arising from the literal `...
16:47:49 <kmc> > do { x <- [1,2]; y <- [3,4]; return x+y } :: [Int]
16:47:50 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
16:47:51 <lambdabot>    arising from the literal `...
16:48:00 <kmc> hmm what'd i do wrong
16:48:05 <shachaf> merijn: "data [a] = [] | a : [a]", as in "data List a = Nil | Cons a (List a)".
16:48:16 <Saizan> sshc: let me look at the article
16:48:36 <kmc> > do { x <- [1,2]; y <- [3,4]; return x+y }
16:48:37 <lambdabot>   No instance for (GHC.Num.Num [b])
16:48:37 <lambdabot>    arising from the literal `3' at <inter...
16:48:39 <yitz> povman: it is now, in the logs for this channel. :)
16:48:41 <povman> dibblego: kmc: Thanks... brain explode...
16:49:01 <Philonous> dh_: Well, any function might diverge
16:49:03 <povman> yitz: haha. Ultimate Haskell reference, right.
16:49:20 <dibblego> povman, take a look at the ((->) t) monad or applicative instance
16:50:03 <dh_> Philnous: Is it possible a function diverge but have fixed point?
16:50:09 <aavogt> > do { x <- [1,2]; y <- [3,4]; return $ x+y } -- kmc
16:50:10 <lambdabot>   [4,5,5,6]
16:50:17 <Saizan> sshc: (*) isn't bind, the definition is "f * g = bind f . g"
16:50:18 <kmc> oh durr, thanks aavogt
16:50:25 <yitz> povman: (&&&&) = on (&&) . flip id
16:50:35 <sshc> Saizan: do I need to define (*)?
16:50:49 <sshc> Saizan: or just understand that "f * g = bind f . g"?
16:50:56 <sshc> Saizan: where is that found in the article?
16:50:56 <Saizan> sshc: just that
16:51:04 <sshc> Saizan: just..which one?
16:51:12 <Berengal> dh_: yes
16:51:19 <Saizan> sshc: just understand
16:51:26 <sshc> ok
16:51:29 <Saizan> sshc: defined here: "Given a pair of debuggable functions, f' and g', we can now compose them together to make a new debuggable function bind f' . g'. Write this composition as f'*g'."
16:51:30 <sshc> Saizan: where is it?
16:51:34 <yitz> @type on (&&) . flip id
16:51:35 <lambdabot> forall a. a -> (a -> Bool) -> (a -> Bool) -> Bool
16:51:48 <povman> how the heck do you flip id
16:51:55 <Berengal> @type flip id
16:51:56 <lambdabot> forall a b. a -> (a -> b) -> b
16:52:01 <dh_> Berengal: thanks. I need to understand diverge.
16:52:04 <Berengal> Reverse application :)
16:52:07 <povman> :t flip
16:52:08 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:52:08 <yitz> oh, the a is at the wrong end. hmm.
16:52:26 <Berengal> dh_: A diverging computation is a computation returning _|_. It's obvious that _|_ is a fixed point in that case :)
16:52:36 <povman> yitz: My favorite is liftA2 (&&)
16:52:44 <Saizan> sshc: so the exercise it's asking you to show that "bind (lift f) . lift g = lift (f . g)"
16:53:09 <yitz> @type liftA2 (&&)
16:53:10 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
16:53:50 <sshc> :t bind (lift f) . lift g
16:53:51 <lambdabot>     Ambiguous occurrence `lift'
16:53:51 <lambdabot>     It could refer to either `L.lift', defined at <local>:10:54
16:53:51 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
16:53:58 <sshc> :t bind (L.lift f) . L.lift g
16:53:59 <lambdabot>     Ambiguous occurrence `f'
16:53:59 <lambdabot>     It could refer to either `L.f', defined at <local>:6:31
16:53:59 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:75:0-32
16:54:05 <Berengal> @type \x -> ((&&) <$> f <*> g) x
16:54:07 <lambdabot>     Ambiguous occurrence `f'
16:54:07 <lambdabot>     It could refer to either `L.f', defined at <local>:6:31
16:54:07 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:75:0-32
16:54:20 <sshc> :t L.bind (L.lift L.f) . L.lift L.g
16:54:21 <lambdabot>     Couldn't match expected type `Float'
16:54:21 <lambdabot>            against inferred type `(Float, String)'
16:54:21 <lambdabot>     In the first argument of `L.lift', namely `L.f'
16:54:24 <kmc> @type \x -> ((&&) <$> ?f <*> ?g) x
16:54:25 <Berengal> @type \f g x -> ((&&) <$> f <*> g) x
16:54:25 <lambdabot> forall t. (?f::t -> Bool, Applicative ((->) t), ?g::t -> Bool) => t -> Bool
16:54:26 <lambdabot> forall t. (Applicative ((->) t)) => (t -> Bool) -> (t -> Bool) -> t -> Bool
16:54:42 <Saizan> sshc: f and g here are pure functions, not those that produce a log
16:54:52 <Saizan> sshc: so of type Float -> Float
16:54:54 <sshc> oh
16:55:06 <yitz> @pl \a -> (&&) on ($ a)
16:55:07 <lambdabot> (on &&) . flip id
16:55:22 <sshc> Saizan: but should'n lift take care of that?
16:55:36 <sshc> Saizan: "bind (lift f) . lift g"
16:55:43 <kmc> @pl \a -> (&&) `on` ($ a)
16:55:43 <lambdabot> ((&&) `on`) . flip id
16:55:44 <sshc> Saizan: that doesn't because it's an error?
16:55:52 <kmc> :t flip id
16:55:53 <Saizan> sshc: lift :: (Float -> Float) -> Float -> (Float, String)
16:55:54 <lambdabot> forall a b. a -> (a -> b) -> b
16:56:05 <kmc> :t flip ($)
16:56:06 <lambdabot> forall a b. a -> (a -> b) -> b
16:56:11 <yitz> @pl \a -> (&&) `on` ($ a)
16:56:11 <lambdabot> ((&&) `on`) . flip id
16:56:17 <sshc> :t L.bind (L.lift L.f) . L.lift L.g
16:56:17 <lambdabot>     Couldn't match expected type `Float'
16:56:18 <lambdabot>            against inferred type `(Float, String)'
16:56:18 <lambdabot>     In the first argument of `L.lift', namely `L.f'
16:56:18 <Saizan> sshc: so you've to pass a (Float -> Float) to lift
16:56:30 <Saizan> sshc: but L.f :: Float -> (Float, String)
16:56:32 <kmc> i like how the correct type is inferred for "flip id" despite id not clearly being a two-argument function
16:56:56 <sshc> :t L.bind (L.lift id) . L.lift id
16:56:57 <lambdabot> Float -> (Float, String)
16:57:07 <sshc> ok that works
16:57:14 <Berengal> kmc: It's easy, by unifying it with flip's type
16:57:30 <Saizan> > L.bind (L.lift (+1)) . L.lift (*2) $ 3
16:57:32 <lambdabot>   (7.0,"")
16:57:33 <Berengal> kmc: It's much harder for humans to grok :)
16:58:01 <sshc> > L.lift $ (+1) . (*2)
16:58:02 <lambdabot>   -0.375->
16:58:02 <lambdabot>    (0.25,"")
16:58:02 <lambdabot>  -0.75->
16:58:02 <lambdabot>    (-0.5,"")
16:58:02 <lambdabot>  -1.5->
16:58:04 <lambdabot> [3 @more lines]
16:58:10 <sshc> > L.lift $ (+1) . (*2) $ 3
16:58:11 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Float -> GHC.Types.Float))
16:58:11 <lambdabot>    arisi...
16:58:27 <Saizan> > L.lift ((+1) . (*2)) $ 3
16:58:29 <lambdabot>   (7.0,"")
16:59:03 <Saizan> sshc: yours was parsed as L.lift (((+1) . (*2)) 3)
16:59:13 <sshc> Saizan: oh.
16:59:51 <MHD> hi guys
16:59:57 <Saizan> Berengal: i've seen at least two (toy) typecheckers fail to infer flip id type, because of misplaced generalization :P
17:00:12 <Saizan> MHD: hi
17:00:19 <tensorpudding> @type L.lift
17:00:20 <lambdabot> (Float -> Float) -> Float -> (Float, String)
17:00:23 <tensorpudding> huh
17:00:39 <Berengal> Saizan: That might suggest it's a good test case
17:00:59 <MHD> I have a "cannot construct infinite type" problem and it's 2am
17:01:12 <tensorpudding> is there a way to prove that your typechecker is correct?
17:01:19 <Saizan> we're in the same time zone!
17:01:23 <Berengal> tensorpudding: Formal logic
17:01:41 <MHD> Saizan: Where are you?
17:01:43 <tensorpudding> yes, so it should be
17:01:50 <Saizan> MHD: italy
17:01:52 <kmc> MHD, can you hpaste your code?
17:02:00 <MHD> Saizan: I'm in denmark
17:02:06 <MHD> kmc: yes
17:02:07 <tensorpudding> probably could use agda too
17:02:08 <gwern> @hpaste
17:02:09 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:02:18 <MHD> data Tree a = Stub | Fork (Tree a) a (Tree a)
17:02:22 <Saizan> tensorpudding: there's an FP lunch on that
17:02:32 <MHD> leaf :: a -> Tree a
17:02:37 <MHD> leaf x = Fork Stub x Stub
17:02:41 <xpika> how many Data.Uniques can i instantiate before i run out?
17:02:42 <Berengal> tensorpudding: Agda is formal logic, isn't it?
17:02:46 <MHD> insert :: (Ord a) => a -> Tree a -> Tree a
17:02:47 <tensorpudding> yes
17:02:50 <MHD> insert x Stub = leaf x
17:02:57 <jlouis> MHD: pastebin it
17:02:58 <Saizan> MHD: don't paste the whole code in channel
17:03:04 <MHD> oh
17:03:04 <jlouis> MHD: together with the type error
17:03:05 <tensorpudding> well, i wasn't sure what logic it implemented exactly
17:03:05 <MHD> dorry
17:03:08 <MHD> sorry*
17:03:09 <xpika> apparently : There is no limit on the number of
17:03:09 <xpika> -- times 'newUnique' may be called.
17:03:16 <MHD> my brain doesn't work well
17:03:17 <jlouis> MHD: much easier to follow that way
17:03:34 <jlouis> MHD: aw comon, it is just 2 AM and I've just posted to my blog :)
17:03:36 <BMeph> xpika: All of them. ;)
17:03:55 <Saizan> xpika: tried looking at the implementation?
17:04:26 <MHD> http://pastebin.com/ded0f1eb
17:04:37 <SubStack> @pl fst . until ((== 0) . snd) (\(m,n) -> (n, m - n * (m `div` n)))
17:04:37 <lambdabot> fst . until ((0 ==) . snd) (uncurry (ap (,) . liftM2 (.) (-) (ap (*) . div)))
17:04:46 <MHD> that's my code
17:06:36 <Saizan> MHD: the error is not there, it's in the recursive calls to insert
17:06:41 <BMeph> SubStack: What, no "m `mod` n"? Are you allowed div, but forbidden mod? :)
17:06:51 <Saizan> MHD: you flipped the arguments order
17:06:56 <SubStack> oh heh
17:07:23 <SubStack> I was just going off of the mathematical definition and not thinking too much about it
17:07:32 <SubStack> this one had floor in it
17:07:52 <MHD> Saizan: Um... what do you mean?
17:08:13 <jlouis> MHD: you call insert with the tree as the first argument, not the second
17:08:24 <jlouis> but you defined it the other way around
17:08:45 <Saizan> MHD: i.e. this should work http://pastebin.com/m62beaf53
17:10:27 <SubStack> > curry (fst . until ((== 0) . snd) (snd &&& uncurry mod)) 30 20
17:10:27 <lambdabot>   10
17:11:11 <MHD> Saizan: Oh... *dope slap*
17:11:42 <Saizan> hehe :)
17:16:50 <MHD> hmm... when inserting multiple items into a BST, should I balance it with every item inserted?
17:21:10 <sshc> is there ever going to be the standard module Data.BinaryTree?
17:21:53 <dh_> anybody knows how to use lambdabot inside ghci ?
17:22:02 <HugoDaniel> hi
17:22:18 <HugoDaniel> anyone wants to share some thoughts on hard real time applications in haskell ?
17:23:01 <kmc> yes, don't do it
17:23:14 <kmc> however you can use Haskell to describe hard-real-time applications
17:23:18 <dh_> why not real time app?
17:23:20 <kmc> which are compiled to a suitable language
17:23:29 <kmc> see the package "atom" on Hackage
17:23:38 <xerox> dh_ http://chrisdone.blogspot.com/2009/12/ghci-on-acid.html
17:23:40 <kmc> it is hard to do hard-real-time with garbage collection
17:23:46 <kmc> at least i don't know of a way
17:24:21 <HugoDaniel> can i signal the gc to wake up only when the code reaches certain parts ?
17:24:32 <kmc> good question; i don't know
17:24:36 <dh_> xerox : thanks!
17:24:48 <xerox> you're welcome :)
17:25:06 <Saizan> there's performGC, i don't know if there's a blockGC too :)
17:25:16 <kmc> @hoogle performGC
17:25:17 <lambdabot> System.Mem performGC :: IO ()
17:25:18 <dh_> we did java games on mobile phone before, gc is not a big issure.
17:25:24 <HugoDaniel> oh, performGC seems fine :)
17:25:35 <kmc> dh_, your java phone games are hard-real-time?
17:25:55 <kmc> hard-real-time means that if you miss a single deadline, your app is a total failure and you probably get sued
17:26:13 <dh_> kmc: jave phone game runs on 30 fps , depends on how do u define as hard-real-time.
17:26:17 <kmc> hard-real-time is like, if this function does not return in 50 us, the plane will crash into a mountain
17:26:20 <dh_> for me , 30 fps is hard enough :)
17:26:23 <kmc> dh_, "u" is not an english word
17:26:30 <kmc> "hard" has nothing to do with the level of latency required
17:26:32 <HugoDaniel> :)
17:26:42 <kmc> "hard" means that close is not good enough
17:26:49 * MHD is away: autoaway [l(on) p(on)]
17:26:59 <kmc> soft-real-time is something like video decoding.  you can miss a frame occasionally and the user is not much unhappire
17:27:13 <SubStack> sounds hard
17:27:16 <MHD> Why is Haskell big in India?
17:27:24 <medfly> it's big in India?
17:27:25 <kmc> lotta goddamn people in India
17:27:28 <MHD> It's so easy to curry.
17:27:29 <dh_> HogoDaniel: what's your definition of hard-real-time?
17:27:33 <kmc> har har
17:27:33 <medfly> hahaha
17:27:39 <MHD> *badum-rish*
17:27:45 <MHD> this
17:27:52 <MHD> tish*
17:28:02 <MHD> I can't even spell how a cymbal sounds
17:28:08 <MHD> >.<
17:28:12 <kmc> rimshot
17:28:18 <kmc> is the name of the sound
17:28:24 <kmc> @quote rimshot
17:28:24 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
17:28:27 <kmc> @quote rim
17:28:27 <lambdabot> int-e says: I propose that all of f, g, h and i be made illegal. (referring to http://hackage.haskell.org/trac/haskell-prime/wiki/StricterLabelledFieldSyntax as it existed on 2009-10-05)
17:28:30 <Trinithis> @faq Can Haskell spell how a cymbal sounds?
17:28:31 <lambdabot> The answer is: Yes! Haskell can do that.
17:29:16 <MHD> it's not called a rimshot by drummers, I'm fairly certain
17:29:20 <kmc> what evs
17:30:02 <kmc> anyway hard real time programming is really, really hard
17:30:12 <kmc> and usually requires specialized languages or operating systems
17:30:23 <kmc> and greatly constrained code, e.g. total absence of dynamic memory allocation, etc.
17:31:19 <kmc> i write semi-mushy-real-time code for a living
17:31:46 <Berengal> kmc: Where is semi-mushy on the scale?
17:31:51 <kmc> in that there is no absolute drop-dead deadline, but each additional microsecond costs nontrivial money
17:31:58 <kmc> :)
17:32:10 <Berengal> Trading?
17:32:13 <kmc> yeah
17:32:50 <kmc> wish i could use Haskell
17:32:59 <kmc> it's feasible for many other styles of automated trading
17:33:14 <SubStack> nice -20 it
17:33:16 <kmc> from company to company the definition of "high frequency" will vary by 5 or 6 orders of magnitude
17:33:21 <Berengal> Didn't cjs write a trading system in haskell?
17:33:42 <kmc> i saw one presentation about one
17:33:45 <kmc> looked really cool
17:33:49 <Berengal> Think he said something about a 50s latency
17:33:58 <kmc> that's pretty good
17:34:11 <kmc> well, depends what you can do in those 50 us
17:34:15 <Berengal> Could've been ms, I'm not well versed in the trading system latencies
17:34:27 <kmc> what's 4 orders of magnitude between friends ;)
17:35:08 <kmc> err 3
17:35:16 <kmc> what's one order of magnitude difference between friends ;)
17:35:44 <Berengal> There was talk of garbage collection taking about 10 of those units, so I guess it must've been s
17:36:19 <kmc> yeah
17:36:52 <Berengal> Still, that's pretty close to the planck time of networks
17:38:45 <kmc> how do you mean?
17:39:09 <kmc> measurement granularity?
17:39:13 <Berengal> Yeah
17:39:24 <kmc> you can make cycle-accurate timing measurements on modern processors
17:40:02 <Berengal> That doesn't matter much when the ping round-trip time is so much greater
17:40:21 <kmc> that's not true
17:40:56 <Berengal> Depends on the application, of course
17:41:11 <kmc> for trading i mean
17:42:17 <Berengal> If you say so
17:42:23 <dibblego> dcoutts, ping
17:42:43 <kmc> it is physically impossible to get a signal from New York to Chicago in less than 3.82 milliseconds
17:42:59 <kmc> but if you can do it in 3.83 ms and your competitors take 3.84 ms, you stand to make a shitload of money
17:43:29 <kmc> it's about getting there first, beating everyone else
17:43:39 <kmc> you may beat them by a tiny fraction of the overall ping time
17:43:41 <dibblego> @tell dcoutts There is a package on hackage, written by someone else, which is very minimal, but defines a data structure that I need (and I expect others might) -- can I somehow contribute to it?
17:43:41 <lambdabot> Consider it noted.
17:44:56 <kmc> similarly, maybe your links are the same speed but you take 10 us less to decide to send the packet in the first place
17:45:26 <Berengal> kmc: What do you program these systems in?
17:45:32 <kmc> C++
17:45:42 <sshc> kmc: how do you like C++?
17:45:46 <kmc> i hate it
17:46:21 <sshc> kmc: did you learn C++ before or after you were introduced to Haskell?
17:46:33 <Saizan> do server near wall street cost more? :)
17:46:48 <kmc> Saizan, the actual trading occurs in giant anonymous datacenters in New Jersey
17:46:50 <zygoloid> Saizan: yes, from what i've heard :)
17:46:50 <SubStack> I thought the datacenters were in New Jersey
17:46:57 <SubStack> heh, yep
17:47:04 <kmc> wall street is where you put the primates in suits
17:47:11 <Saizan> i see
17:47:27 <kmc> most of the stock in the US is traded "physically" in Carteret, NJ or Weehawken, NJ
17:47:53 <SubStack> lots of stories about quants in the news lately
17:48:02 <kmc> anyway in practice people use fiber optic communications, which only travels 2/3 of the speed of light (in vacuum), plus routing delays
17:49:10 <MHD> the null device on windows is called NUL right?
17:49:10 <kmc> sshc, i first used C++ much before using Haskell, and knew it at the level of "C with classes".  i learned C++ for real after learning Haskell
17:49:16 <xerox> is it converting money in different currencies or actual trade of goods?
17:49:28 <kmc> xerox, which?
17:49:39 <drdr> jello ers
17:49:43 <kmc> i was talking about stock trading just now
17:49:46 <xerox> this ultra-fast-trading business
17:49:58 <kmc> but you can do the same stuff with bonds, currency exchange, commodity futures, etc.
17:50:02 <drdr> ohh market paradimes with haskell
17:50:05 <drdr> soo nice
17:50:15 <kmc> the fast NY-Chi link would be good for trading stocks vs. the CME's stock-index futures
17:50:37 <kmc> a fast Carteret - Weehawken link would be useful for pure stock arbitrage between exchanges
17:51:11 <kmc> Saizan, yes, it does cost significantly more to have servers in the same room as the exchange's
17:51:21 <kmc> there's also a limited supply of rack space
17:51:29 <MHD> You know what I dislike about haskell?
17:51:41 <kmc> to the point where big banks will buy the space and use it for irrelevant crap just so other people can't have it
17:51:47 <MHD> The camel back naming convention
17:52:20 <Saizan> kmc: ouch
17:52:35 <MHD> kmc: That's Blasphemy!
17:53:17 <kmc> it's how the game is played
17:53:29 <Saizan> kmc: well, i've some moral objections about making money like this in any case, but that's another story :)
17:53:48 <kmc> i'm all for this kind of cutthroat competition, as long as every player has opted into the game
17:53:54 <kmc> which is why government bailouts of wall street are bullshit
17:53:55 <MHD> kmc: (you're supposed to say "THIS IS BUSINESS!")
17:54:03 <benmachine> MHD: there was a huge haskell-cafe thread about that recently
17:54:07 <benmachine> it's pretty dull :P
17:54:11 <bd_> Really, the exchanges should set up a, say, one second granularity. You get all of the new orders at the start of the window, have 500ms or so to round-trip and think about it, then everyone gets executed at once at the end of the window
17:54:25 <SubStack> there should be hGetWord{8,16,32,64}
17:54:27 <kmc> bd_, they have services like that too (though once an hour or so)
17:54:28 <MHD> benmachine: I'm not on haskell-caf...
17:54:29 <kmc> not every 500 ms
17:54:41 <benmachine> MHD: yeah, but you can read the archives somewhere or other
17:54:42 <SubStack> unpacking binary streams is hard
17:54:44 <bd_> kmc: I mean, force everyone to stick to this granularity, so it doesn't matter what your ping to the exchange is :)
17:55:04 <benmachine> that does sound like it would result in more optimal trading
17:55:19 <kmc> it's in the exchange's best interest to have people compete for speed
17:55:31 <Saizan> SubStack: the Get monad or similar have things like that
17:55:32 <bd_> because they pay for faster links? :/
17:55:38 <bd_> this is where regulation should come in
17:55:43 <kmc> and they trade against each other
17:55:52 <kmc> again, i don't see the problem with allowing rich people to gamble with each other
17:55:59 <bd_> require exchanges to halt trading for X ms after every X ms of open trading, etc.
17:56:01 <kmc> the problem is when ordinary people get dragged in
17:56:11 <kmc> which is what bailouts do
17:56:27 <roostaj> @src putStrLn
17:56:27 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
17:56:35 <roostaj> @src putStr
17:56:36 <lambdabot> putStr s  = hPutStr stdout s
17:56:42 <roostaj> @src hPutStr
17:56:42 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:56:46 <SubStack> Saizan: neat, checking it out now
17:57:05 <kmc> as for joe retiree's pension fund, high-frequency trading helps him.  what doesn't help is when his bank makes a (low-frequency, human-mediated) bet on sketchy derivatives products
17:57:57 <kmc> the markets that are the least problematic are the ones with tons of participants and realtime globally visible information
17:58:11 <roostaj> @src stdout
17:58:11 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:58:22 <roostaj> :t hPutStr
17:58:23 <lambdabot> Not in scope: `hPutStr'
17:59:01 <roostaj> @src ($)
17:59:02 <lambdabot> f $ x = f x
18:00:57 <MHD> how do I get ghc to only output .hi?
18:02:32 <xerox> it may be -C ?
18:04:18 <drdr> anyone know a good project that i can tackle so i can learn haskell a bit better?
18:05:03 <kmc> write a scheme interpreter
18:05:09 <kmc> there's a wikibook about that
18:05:14 <holmak> that's what i did, was fantastic
18:05:32 <holmak> fantastic learning tool, not a fantastic interpreter
18:05:32 <drdr> whats scheme?
18:05:44 <holmak> language in the Lisp family
18:05:52 <holmak> easy to parse, pretty easy to interpret
18:06:02 <drdr> what about basic?
18:06:12 <holmak> scheme is simpler
18:06:31 <roostaj> i'm just learning IO... it is true that main always is an I/O action?
18:06:38 <holmak> roostaj: yes
18:06:38 <drdr> yep
18:06:43 <holmak> main :: IO ()
18:06:44 <roostaj> holmak: drdr: thanks
18:07:00 <drdr> so this means i needs to learn lisp now?
18:07:00 <roostaj> holmak: does it have to be IO () or can it be IO a
18:07:01 <merehap> roostaj: your program couldn't do anything other than make heat if it weren't :)
18:07:03 <holmak> overzealous help for trivial questions huzzah
18:07:18 <roostaj> merehap: good point
18:07:21 <xerox> drdr just a simple syntax to parse for lambda calculus :)
18:07:25 <holmak> always IO (), main doesn't return to anything
18:07:34 <holmak> what would get the return value?
18:07:37 * drdr facepalms
18:07:50 <Philonous> merehap: Probably not even that, as nothing gets forced. It would just quit immediately
18:07:51 <roostaj> holmak: ok cool thanks
18:07:59 <holmak> Don't worry drdr, lisp interpreters are easy!
18:08:11 <merehap> Philonous: ah, true
18:08:21 <drdr> ill just do a modified basic one
18:08:24 <holmak> roostaj: if you *do* want to exit with a specfic value (like C's main), look into the exitWith function
18:08:30 <drdr> BLISP :)
18:08:49 <holmak> drdr: A good place to start is just evaluating math
18:09:03 <holmak> like (+ (*3 4) 2) ==> 14
18:09:03 <drdr> or Beginners Modified Lisp That Holds No Real Lisp Inhearitance aka BMLTHNRLI
18:09:17 <roostaj> holmak: I was just making sure I was correct in my thinking. Does exitWith cause the program to jump out? (as opposed to return which doesn't)
18:09:33 <holmak> i think exitWith actually terminates the program, yes
18:09:38 <roostaj> holmak: ok cool, thanks
18:09:39 <holmak> @hoogle exitWith
18:09:40 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
18:09:52 <holmak> but check Hoogle
18:12:07 <Berengal> exitWith kills the current thread
18:12:14 <Berengal> (And prints the exit value if it's not ExitSuccess)
18:12:31 <Berengal> ((Unless it's the main thread, in which case it exits the program entirely, with the exit code specified))
18:12:55 <Berengal> Also, main can have any IO type, but the actual value returned is thrown away and disregarded
18:14:37 <aavogt> holmak: ghc accepts (main :: IO a)
18:14:47 <aavogt> same with hugs
18:15:07 <holmak> oh weird
18:15:11 <holmak> news to me!
18:15:19 <drdr> why cant hugs handle the let command
18:15:23 <MHD> what is actually in a .hi file?
18:15:42 <sshc> what is a .hi file
18:15:48 <sshc> ?
18:15:54 * increpare has finally gotten the hang of using the prefix (.) function : D
18:16:00 <Berengal> Interface for a compiled file
18:16:18 <roostaj> holmak: yeah i just ended a main with getLine and main was "main :: IO String"
18:16:30 <Berengal> It just tells which functions are in an object file, the types and so on, and some inlineable functions
18:16:33 <holmak> My mistake! sorry about that
18:16:36 <roostaj> ending with "x <- getLine" is of course illegal though
18:16:41 <holmak> Does it behave any differently?
18:17:09 <roostaj> holmak: well it gets input for halting :)
18:17:35 <roostaj> before*
18:18:30 <MHD> That's weird
18:19:37 <roostaj> am i correctin thinking that " <- " is a lexical operator and not an actual operator?
18:19:44 <roostaj> correct in *
18:19:50 <benmachine> it's reserved I think
18:20:04 <aavogt> holmak: well, if you have   main = return "hai", runghc ends up printing it
18:20:08 <kanak> [Newbie question] Hi. I'm trying to write a function that first asks the user for an integer n. It then reads in n integers and returns the sum. I've figured out how to do "read n" part (using getLine and read), but I'm not sure how i can make my program ask for an arbitrary number of integers. Any hints? thanks.
18:20:28 <holmak> aavogt: Interesting
18:20:45 <roostaj> benmachine: so does it only exist in the compiler's parser?
18:21:08 <roostaj> benmachine: actually the wording of that is kind of bizzarre
18:21:08 <medfly> wow, that doesn't sound a lot like a newbie question in Haskell.
18:21:14 <holmak> kanak: try replicateM
18:21:15 <ziman> kanak, you might want to take a look at the function called replicateM
18:21:19 <aavogt> kanak: you can separate your readOneInteger into a separate (IO Integer) function?
18:21:20 <holmak> @hoogle replicateM
18:21:20 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
18:21:20 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
18:21:36 <McManiaC> what does a "class Foo a where type Bar a" mean?
18:21:38 <aavogt> and then pass it to that function everybody else named
18:21:51 <aavogt> McManiaC: type families or something
18:22:16 <aavogt> @google indexed type families
18:22:19 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Indexed_types
18:22:19 <lambdabot> Title: GHC/Type families - HaskellWiki
18:22:20 <xerox> roostaj the do syntax is a text transformation: do { let BINDINGS; ... } => let BINDINGS in do ...   do { x <- amb; ... }=> amb >>= \x -> do ...   do { amb; ... } => amb >> do ...   do { amb } => amb
18:22:37 <MHD> nice
18:22:40 <kanak> aavogt: Thanks. I do have it in a distinct function. I was trying to do a (take n (replicate readOneInt)) but failing. I'll look into replicateM. Thank you so much.
18:23:27 <holmak> kanak: the ...M part is important, you were probably ending up with a list of IO actions
18:23:43 <holmak> kanak: I think your approach could have worked in combination with sequence
18:23:46 <aavogt> @src sequence
18:23:47 <lambdabot> sequence []     = return []
18:23:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:23:47 <lambdabot> --OR
18:23:47 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
18:23:48 <MHD> hmm... Any ideas how to devise a sensible byte code set for something akin to Lua?
18:24:16 <roostaj> xerox: ah ok, I'm not familiar with >>= yet. so words like "do" and "<-" are just sugar?
18:24:29 <MHD> roostaj: Yeah
18:24:33 <xerox> roostaj yes, and that is the complete transformation of syntax.
18:24:57 <MHD> roostaj: Once you get to it, you'll learn that Haskell is one of the sweetest languages of all
18:25:06 <roostaj> MHD: xerox: thanks you, that confirms some of my suspicions
18:25:18 <roostaj> MHD: oh really :). I do have a sweet tooth
18:25:23 <ziman> :t sequence .: replicate
18:25:23 <MHD> Haskell programmers have hight diabetes risk
18:25:24 <lambdabot> Not in scope: `.:'
18:25:59 <roostaj> MHD: I hope the beauty is that it boils down to a few simple constructs (at least that is my intuition)
18:26:39 <kanak> holmak: thanks. sequence (take n (repeat readOneInt)) seems to do the trick :)
18:26:54 <xerox> ?type replicateM
18:26:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:27:15 <xerox> (equivalent)
18:27:59 <c_wraith> @src State (>>)
18:27:59 <lambdabot> Source not found. It can only be attributed to human error.
18:28:08 <holmak> kanak: "replicateM n readOneInt" is easier, though
18:29:07 <holmak> IIRC, most somethingM functions are just "sequence . something"
18:29:22 <BMeph> 'Struth. :)
18:30:32 <osaunders_> What does Z represent in denotational semantics? Any type?
18:31:34 <aavogt> and most of them are for looser definitions of sequence
18:31:38 <aavogt> like liftM2
18:33:52 <kanak> holmak: Thank you for clarifying. How do i work with the IO [Int]s? As in how do I map/fold over them?
18:35:14 <stoop> :t mapM
18:35:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:35:16 <stoop> :t mapM_
18:35:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
18:35:30 <kanak> :t foldM
18:35:31 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
18:35:34 <c_wraith> eh.  best to bind it, and use it with pure functions.
18:36:38 <MHD> lol, the Jargon file can crack me up sometimes
18:37:00 <SubStack> I need to do incremental parsing of a binary network stream with reading and writing of Word8, Word16, and Word32-sized chunks
18:37:16 <SubStack> is there a way to mix the Get and Put monads?
18:38:00 <kanak> c_wraith: Thank you :). I finally got it to work.
18:38:00 <MHD> hairy: adj.    1. Annoyingly complicated. "DWIM is incredibly hairy"     2. Incomprehensible. "DWIM is incredibly hairy"
18:38:46 <kanak> thank you guys so much for your help. you guys are really nice :)
18:40:17 <SubStack> maybe I'll just split those up inside of an IO
18:43:49 <merijn> Hmm, another monad question: Since "a -> IO [Int]" is a valid type signature and lists are a monad to, does that many that constructions of type "(Monad m, Monad n, Monad o) => a -> m n o b" are valid type signature too?
18:44:02 <kmc> merijn, yes
18:44:30 <aavogt> @kind Monad
18:44:31 <lambdabot> Class `Monad' used as a type
18:44:35 <aavogt> @kind Maybe
18:44:36 <lambdabot> * -> *
18:44:43 <kmc> > [] :: [Maybe [Either (Maybe (Either Int Char)) [[String]]]]
18:44:44 <lambdabot>   []
18:44:46 <merijn> This whole monad thing is far easier then it's cracked up to be... :p
18:44:46 <aavogt> you need some parentheses in the type
18:44:46 <benmachine> @kind (Monad m) => m
18:44:48 <lambdabot>     `m' is not applied to enough type arguments
18:44:48 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
18:44:51 <kmc> merijn, indeed
18:44:53 <benmachine> eeer
18:45:00 <aavogt> so  m (n (o b))
18:45:26 <kmc> @check \x -> x == ([] :: [Maybe [Either (Maybe (Either Int Char)) [[String]]]])
18:45:27 <lambdabot>   "Falsifiable, after 0 tests:\n[Just []]\n"
18:45:37 <merijn> aavogt: Right, makes sense.
18:45:40 <kmc> is there a way to ask lambdabot to use quickcheck to generate terms directly?
18:46:20 <aavogt> > id :: Endo [Maybe [Either (Maybe (Either Int Char)) [[String]]]]
18:46:21 <lambdabot>   Couldn't match expected type `Data.Monoid.Endo
18:46:21 <lambdabot>                             ...
18:46:33 <merijn> aavogt: Else I'd be classifying the n monad as a value of the m monad, right?
18:46:37 <aavogt> > Endo id :: Endo [Maybe [Either (Maybe (Either Int Char)) [[String]]]]
18:46:38 <lambdabot>   No instance for (GHC.Show.Show
18:46:38 <lambdabot>                     (Data.Monoid.Endo
18:46:38 <lambdabot>       ...
18:47:00 <aavogt> > id :: [Maybe [Either (Maybe (Either Int Char)) [[String]]]] ->  [Maybe [Either (Maybe (Either Int Char)) [[String]]]]
18:47:01 <lambdabot>   []->
18:47:01 <lambdabot>    []
18:47:01 <lambdabot>  [Nothing]->
18:47:01 <lambdabot>    [Nothing]
18:47:01 <lambdabot>  [Nothing,Nothing]->
18:47:03 <lambdabot>    [Nothing,Nothi...
18:47:11 <kmc> nothing!
18:47:13 <kmc> absolutely nothing!
18:47:30 <aavogt> yeah the smallcheck instance apparently goes breadth first or something
18:48:42 <aavogt> merijn: well otherwise the kind of   m :: * -> * -> * -> *   doesn't match what you need for m to be an instance of Monad
18:49:31 <aavogt> kmc: also you could use Debug.Trace with quickcheck?
18:49:46 <aavogt> oh, but that doesn't work in lb
18:50:03 <aavogt> > Debug.Trace.trace "hai" ()
18:50:04 <lambdabot>   Not in scope: `Debug.Trace.trace'
18:50:10 <roostaj> @src forM
18:50:10 <lambdabot> forM = flip mapM
18:50:15 <roostaj> @src mapM
18:50:16 <lambdabot> mapM f as = sequence (map f as)
18:50:22 <roostaj> :t forM
18:50:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
18:50:55 <aavogt> I suspect that unrestricted use of trace probably bypasses what lb currently does to prevent flooding the channel
18:51:47 <roostaj> :t mapM
18:51:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:51:51 <roostaj> :t map
18:51:52 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:51:57 <aavogt> merijn: a good example to see is Either:
18:52:01 <aavogt> :k Either
18:52:02 <lambdabot> * -> * -> *
18:52:08 <aavogt> :k Either String
18:52:09 <lambdabot> * -> *
18:52:12 <roostaj> > mapputStrLn ["one","two","three","four"]
18:52:13 <lambdabot>   Not in scope: `mapputStrLn'
18:52:13 <aavogt> :k Either String String
18:52:14 <lambdabot> *
18:52:15 <roostaj> > map putStrLn ["one","two","three","four"]
18:52:16 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>]
18:52:26 <roostaj> > mapM putStrLn ["one","two","three","four"]
18:52:27 <lambdabot>   <IO [()]>
18:52:31 <dibblego> mapM_
18:52:38 <roostaj> > mapM_ putStrLn ["one","two","three","four"]
18:52:39 <lambdabot>   <IO ()>
18:53:34 <roostaj> > map print ["one","two","three","four"]
18:53:35 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>]
18:53:42 <roostaj> > mapM print ["one","two","three","four"]
18:53:43 <lambdabot>   <IO [()]>
18:55:07 <merijn> aavogt: That doesn't make any sense to me yet. I only just finished reading the first part of "All about monads", I haven't really tried playing with them yet or read enough examples to get it.
18:55:21 <ksf> suppose I have the map of sets to stuff [{A,B}->{a,b},{B,C}->{c},{C}->{d}}, and I do know the alphabet the keysets are made of ({A,B,C}). Now, given any subset of the alphabet, what's the fastest way to get the keys?
18:55:25 <ksf> some hashing, I presume.
19:11:19 <stoop> > we (<3) lambdabot
19:11:20 <lambdabot>   True
19:11:31 <Badger> heh
19:14:30 <aavogt> @type we
19:14:31 <lambdabot> forall a. a -> a
19:14:37 <aavogt> > lambdabot
19:14:38 <lambdabot>   1
19:15:02 <c_wraith> > we
19:15:04 <lambdabot>   {()->()}
19:15:59 <aavogt> @free we
19:16:00 <lambdabot> f . we = we . f
19:16:14 <CopropHAGE> Tired of those feral negroid beasts and their monkeyshines?  Are you uncomfortable with those Nazi-like groups?  We have the forum for you!  Chimpout Forum!   At Chimpout we are not White Supremacists!  We welcome anybody who isn't a nigger and who hates niggers!  Thats right!  At Chimpout we welcome the diversity of the human species by welcoming Asians, Jews, non-negroid Hispanics, Arabs, Semites, Whites, Native Americans, Indians, etc.  Basicall
19:16:17 <CopropHAGE> y we accept all races except for those fecal-colored Negros!   Join us today in the epic battle of human vs. NIGGER!   http://www.chimpout.com/forum
19:16:21 <kmc> great this again
19:16:40 <kmc> appropriate username though
19:16:42 <ksf> @where ops
19:16:42 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
19:16:55 --- mode: ChanServ set +o dibblego
19:17:12 --- mode: dibblego set -o dibblego
19:18:38 <Badger> huh
19:18:53 <Badger> apparently haskellers are closet racists
19:18:55 <roostaj> :t IOMode
19:18:56 <lambdabot> Not in scope: data constructor `IOMode'
19:19:01 <roostaj> :info IOMode
19:19:24 <kmc> apparently people who join #haskell to spam it and immediately get k-lined are closet racists
19:19:31 <kmc> except without the "closet" part
19:19:44 * ksf wishes he knew about a site that lists gazillions of data structures, as googling for "set lookup" isn't actually returning any sensible results.
19:19:57 <MHD> I just read something interesting
19:19:57 <inimino> I'm sure they're closeted in real life
19:20:16 <MHD> I read the Jargon File entry on Commonwealth Hackish
19:20:42 <MHD> It's about pronounciation of computerterms in different languages
19:21:59 <MHD> How do you pronounce "char"? As /keir/, a prefix of "character" or as it is spelled, /char/?
19:22:31 <kmc> inimino, there are many social circles where that would be openly said and agreed with
19:22:45 <kmc> and many places where it would not be uncommon to meet people who belong to these social circles
19:24:36 <MHD> I pronounce "char" as /char/, because of my lisp experience i think /kier/ is too close to car
19:24:56 <c_wraith> amusingly, I pronounce it car. :)
19:28:00 <inimino> kmc: sadly all too true I am sure
19:28:25 <MHD> How do you read a hexadecimal value as an integer?
19:28:46 <conal> :t readHex
19:28:47 <lambdabot> forall a. (Num a) => String -> [(a, String)]
19:29:04 <MHD> @conal, thx
19:29:04 <lambdabot> Unknown command, try @list
19:29:17 <MHD> wtf.
19:29:36 <c_wraith> lambdabot thinks lines that start with @ are directed to her
19:29:47 <MHD> yea
19:30:00 <inimino> IRC is not twitter
19:31:06 <MHD> inimino: I know, but since @ means 'at' it is convenient to use @name as "at name's statement"
19:36:37 <Cale> MHD: The convention around here is to use the person's name followed by a colon or comma :)
19:36:54 <kmc> Cale! An exclamation point is fine too.
19:37:05 <Cale> haha
19:37:28 <ksf> The One And Only True Way is to use a comma.
19:37:54 <Berengal> I use whatever the client gives me on tab..
19:38:22 <ksf> which is a comma, if your client is worth its salt.
19:38:37 <ksf> ...at the beginning of the line. a space in the middle.
19:39:08 <Berengal> ,ksf like this?
19:39:09 <lunabot>  luna: Not in scope: `ksf'
19:39:22 <ksf> nope. that'd be confusing luna.
19:39:35 <MHD> How does the pattern ('\\':x:xs) induce a parse error?
19:39:40 <ksf> now we need a bot that takes : as command prefix
19:39:59 <Berengal> > let ('\\':x:xs) = undefined in ()
19:40:00 <lambdabot>   ()
19:40:07 <Berengal> MHD: It doesn't
19:40:39 <kmc> > '\\'
19:40:40 <lambdabot>   '\\'
19:40:46 <kmc> > '\u1337'
19:40:47 <lambdabot>   <no location info>:
19:40:47 <lambdabot>      lexical error in string/character literal at chara...
19:40:56 <tensorpudding> > let foo ('\\':x:xs) = True; foo _ = False in foo ['\\']
19:40:57 <lambdabot>   False
19:41:05 <ksf> > '\x1337'
19:41:06 <lambdabot>   '\4919'
19:41:15 <ksf> > '\1337'
19:41:16 <lambdabot>   '\1337'
19:41:17 <tensorpudding> > let foo ('\\':x:xs) = True; foo _ = False in foo ['\\','.',',']
19:41:18 <lambdabot>   True
19:41:44 <MHD> @hoogle readHex
19:41:44 <lambdabot> Numeric readHex :: Num a => ReadS a
19:41:44 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
19:44:15 <Berengal> http://www.reddit.com/r/haskell/comments/aj1fe/haskell_reddit_please_continue_to_submit_stories/
19:44:20 <Berengal> Was just about to comment on that :P
19:52:30 <roostaj> @src withFile
19:52:31 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
20:00:05 <MHD> wtf... ('\\':"") = Parse error in pattern
20:00:13 <deech> Hi all, what is the best way for Haskell to call C++ functions?
20:00:21 <kmc> deech, via C
20:00:26 <MHD> foreign?
20:00:40 <kmc> C++ is uniquely hard to call from any other language
20:00:53 <kmc> including C++ code compiled with a different C++ compiler on the same system
20:00:59 <MHD> kmc: True dat
20:01:22 <kmc> wrap your C++ functions into a C API using extern "C", etc.
20:01:43 <kmc> then use the Haskell C FFI
20:01:58 <kmc> alternately, it is sometimes easier to have two processes communicate than to have foreign calls within one process
20:02:08 <MHD> WTF IS WRONG WITH MY PATTERNS
20:02:27 <kmc> > case "\" of ('\\':"") -> ()
20:02:28 <lambdabot>   <no location info>:
20:02:28 <lambdabot>      lexical error in string/character literal at end o...
20:02:29 <MHD> I swear to god,
20:02:34 <ville> if C++ only had an ABI specification.
20:02:36 <MHD> they are only valid on tuesdays
20:02:37 <kmc> MHD, \' is an escaped quote
20:02:50 <kmc> except... damn
20:02:51 <MHD> '\\' != "\\" ?
20:02:52 <kmc> > '\\'
20:02:53 <lambdabot>   '\\'
20:02:56 <absentia> hiya ville
20:03:01 <kmc> MHD, well those two have different types
20:03:04 <kmc> > '\\' : ""
20:03:05 <lambdabot>   "\\"
20:03:08 <ville> absentia: hello?
20:03:16 <Gracenotes> "\\" == ['\\']
20:03:17 <kmc> > ('\\' : "")
20:03:19 <lambdabot>   "\\"
20:03:23 <kmc> > \('\\' : "") -> ()
20:03:24 <lambdabot>   * Exception: <interactive>:1:133-150: Non-exhaustive patterns in lambda
20:03:31 <kmc> > ( \('\\' : "") -> () ) "\\"
20:03:32 <lambdabot>   ()
20:03:41 <kmc> > ( \('\\':"") -> () ) "\\"
20:03:42 <lambdabot>   ()
20:03:43 <MHD> grumble
20:03:55 <kmc> > case "\\" of ('\\':"") -> ()
20:03:55 <lambdabot>   ()
20:03:59 <MHD> I feel like I'm programming perl!
20:04:03 <Gracenotes> lambdabot not be helping
20:04:04 <kmc> didn't i just have that??
20:04:16 <kmc> oh nm i was stupid then
20:04:24 <Gracenotes> lambdabot not always be helping
20:04:29 <Berengal> Oh no, perl wishes it had the operator-fu haskell has
20:04:49 <Gracenotes> anyway, escape sequences. anything  between 'these' tends to have a single character, is all. a String being a [Char], list of them
20:05:13 <Gracenotes> unless that is well-known here
20:05:16 <MHD> Gracenotes: I'm familiar with the concept of list-strings
20:05:36 <Berengal> Also, fun trivia, "\?" is a string-escape only. It's the empty string
20:05:42 <Berengal> > "\?"
20:05:42 <MHD> I just can't figgure out for the tlife of me how ('\\':"") can be a bad pattern
20:05:43 <lambdabot>   <no location info>:
20:05:43 <lambdabot>      lexical error in string/character literal at end o...
20:05:57 <Gracenotes> MHD: probably the things around it
20:05:57 <kmc> > case "\\" of ('\\':"") -> ()
20:05:58 <lambdabot>   ()
20:06:02 <kmc> MHD, it works in lambdabot
20:06:09 <kmc> and in my ghci
20:06:12 <MHD> kmc: I know
20:06:17 <Gracenotes> what's the context?
20:06:19 <MHD> kmc: It's mystifying
20:06:26 <MHD> stringParse ('\\' : "") = Nothing
20:06:39 <kmc> > let stringParse ('\\' : "") = Nothing in stringParse "\\"
20:06:40 <lambdabot>   Nothing
20:06:49 <MHD> lol
20:06:55 <Gracenotes> er.. try pasting the whole function
20:07:01 <MHD> GHC moves in mysterious patterns
20:07:10 <Gracenotes> hpaste.org is nice
20:07:14 <Berengal> @paste
20:07:15 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:07:54 <deech> Sorry I got kicked off. I was asking about using Haskell to call C++ functions. Is C++ a difficult foreign interface in general or just with Haskell? I only ask because there seem to be SWIG interface for most every other languages I can think of.
20:08:31 <pikhq> deech: C++ in general is nigh-impossible to FFI.
20:08:54 <MHD> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15094#a15094
20:09:29 <MHD> pikhq: Lua is an exception
20:10:00 <Berengal> deech: C++ is difficult to interface with, even in C++
20:10:32 <Berengal> MHD: You need parenthesis around your patterns
20:10:47 <MHD> Berengal: Tried it
20:11:43 <MHD> Berengal: No, wait... That might ahve done it
20:11:48 <pikhq> MHD: So, it supports FFI'ing to a subset of C++?
20:12:11 <Berengal> MHD: Putting parens around it works for me. Of course, you've still got type errors...
20:12:33 <deech> I see. 'MHD' brought up Lua, should I that to wrap the functions I need? I think that Haskell has  a Lua bridge.
20:12:49 <pikhq> deech: No.
20:12:52 <MHD> deech: No, it was just a side note
20:13:22 <pikhq> export "C" retval_t someFunction(with args); // From C++
20:13:25 <MHD> pikhq: From what I've seen of Lua FFI'ing with C++ it almost supports raw function pointers
20:13:41 <pikhq> And then use the Haskell FFI to C.
20:14:01 <pikhq> MHD: ... What kind?
20:14:02 <pikhq> There's several in C++.
20:14:18 <deech> pikhq: Gottit. Thanks!
20:14:39 <MHD> pikhq: Function pointers that either takes va_args or a number of Lua_obj*
20:15:03 <pikhq> MHD: So, are those extern function pointers, static function pointers, pointers to a method, or pointers to a virtual method?
20:15:08 <kmc> pikhq, didn't know the C++ "export" keyword could be used that way
20:15:17 <MHD> pikhq: No idea
20:15:27 <Zao> You mean extern "C".
20:15:30 <pikhq> kmc: Erm. s/export/extern/...
20:15:31 <MHD> pikhq: Probably not method
20:15:34 <kmc> i've always seen:   extern "C" { void myStupidFunction(char x) { ... } };
20:15:49 <kmc> C++ does actually have an "export" keyword but it's for some stupid template bullshit that iirc has never been implemented
20:15:55 <Zao> export is for separate compilation of class and function templates, and not implemented in any compiler but Comeau.
20:16:08 <Zao> Took them a whole major release cycle to get it in.
20:16:15 <pikhq> extern "C" void foo(bar); // That's perfectly valid.
20:16:31 <pikhq> export, though? Yeah, that's template stuff, and soon to be excised from the language.
20:16:46 <kmc> pikhq, indeed.  if the corresponding definition is not marked extern "C", does it have a linker error?
20:17:36 <Zao> I guess it might affect calling convention?
20:17:39 <Zao> And mangling.
20:18:02 <pikhq> kmc: No, only the declaration needs to have it.
20:19:22 <MHD> Parse: verb. To pass on an arse
20:19:46 * Cale feels like adding a picture of Curly Howard to the Curry-Howard correspondence page on Wikipedia.
20:20:42 <sshc> is it possible to create a random function?
20:21:31 <pikhq> Like an RNG?
20:21:54 <MHD> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15063 <- someone posted this with the sole intent of making you lose
20:22:18 <kmc> i lost
20:22:52 <sshc> > let a = mkStdGen 42 in fst . (random a :: ((a -> a), StdGen)) $ 3
20:22:53 <lambdabot>   Couldn't match expected type `a -> (a1, b)'
20:22:53 <lambdabot>         against inferred type `...
20:23:23 <Axman6> i think the Arbitrary class in quickcheck has an instance defined for a -> b
20:23:34 <pikhq> :t random
20:23:35 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
20:23:50 <pikhq> :t mkStdGen
20:23:51 <sshc> what does "forall g a." mean?
20:23:51 <lambdabot> Int -> StdGen
20:23:54 <sshc> ghci doesn't report that part
20:24:03 <Axman6> sshc: you can ignore it
20:24:15 <Axman6> it's implied in ghci's output
20:24:29 <Cale> Sometimes ghci will report it, if you have extensions turned on
20:24:34 <sshc> what does it mean?
20:24:59 <Cale> It's just being explicit about what the type variables mean: that the type is valid for all types g and a.
20:25:01 <Axman6> it means that for all types a or g, the function will work
20:25:08 <Axman6> :t map
20:25:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:25:27 <sshc> in which cases is that not true?
20:25:33 <Axman6> for a's and bs', if you give map a function to turn a's into b's, then map will turn a list of a's into a list of b's
20:25:46 <Axman6> none that i know of
20:25:52 <Cale> sshc: Well, sometimes you have a type variable which is already in scope, and you'd like to refer to it instead
20:26:02 <sshc> can I put "forall a b." in Haskell code?
20:26:03 <pikhq> sshc: None. It says forall, doesn't it?
20:26:12 <Cale> sshc: With extensions turned on, yes.
20:26:17 <Cale> It's a GHC extension
20:26:20 <MHD> I gotta go to bed now, its half pase 5 in the morning...
20:26:30 <MHD> See y'all
20:27:07 <Cale> map :: forall a b. (a -> b) -> [a] -> [b]; map [] = []; map f (x:xs) = y : map f ys where y :: b; y = f x; ys :: [b]; ys = map f xs
20:27:10 <sshc> pikhq: I'm asking which cases you couldn't use forall a b.?
20:27:14 <Cale> (this is a silly example)
20:27:36 <Cale> But see how the type signature of y doesn't mean that y can have just any type, it must be the type b from the type of map?
20:28:43 <Cale> You can do that sort of thing with ScopedTypeVariables
20:28:44 <sshc> pikhq: in other words, when would use something besides" forall"?
20:29:01 <Cale> sshc: Also, sometimes you want to move the forall
20:29:05 <Cale> :t runST
20:29:07 <lambdabot> forall a. (forall s. ST s a) -> a
20:29:24 <Cale> This gives you a way to insist that a parameter to a function is polymorphic, for instance
20:30:13 <Cale> > let f :: (forall x. [x] -> Integer) -> (Integer, Integer); f g = (g [1,2,3], g "Hello") in f length
20:30:15 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
20:30:15 <lambdabot>         agains...
20:30:29 <Cale> oh, d'oh
20:30:36 <Cale> > let f :: (forall x. [x] -> Int) -> (Int, Int); f g = (g [1,2,3], g "Hello") in f length
20:30:38 <lambdabot>   (3,5)
20:31:05 <Cale> > let f g = (g [1,2,3], g "Hello") in f length
20:31:07 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
20:31:07 <lambdabot>    arising from the literal `1...
20:31:15 <Berengal> The genious in the runST type is that 's' isn't in scope when 'a' is introduces, so it can't appear in 'a' (e.g. as a Maybe s). Since the ST actions all contain an 's', this ensures no references escape, which would break referential transparancy if they did.
20:31:24 <Cale> ^^ normally, type variables are not allowed to be instantiated by polymorphic types
20:31:34 <Cale> But you can insist on it using this syntax
20:34:39 <sshc> Saizan_: I'm trying to do Exercise 7, and bind here has a type signature of "bind :: (a  StdGen  (b,StdGen))  (StdGen  (a,StdGen))  (StdGen  (b,StdGen))".  What is passed for each argument, or the first one in particular?
20:36:31 <pikhq> sshc: Clearly, it's a function (a -> StdGen -> (b,StdGen)) that's passed first, followed by a function (StdGen -> (a,StdGen)).
20:38:34 <sshc> pikhq: this is part of the "You could have invented monads" article.  Why is "a ->" there?  Shouldn't bind be composing two random functions?
20:39:07 <pikhq> ... It is...
20:39:18 <pikhq> (a -> StdGen -> (b,StdGen)) is a single function.
20:39:55 <Cale> sshc: Well, not quite. Bind's job is to apply a randomised function to a randomised value.
20:40:28 <Cale> You can think of (StdGen -> (a, StdGen)) as being a sort of randomised version of the type a
20:40:41 <sshc> Cale: specifically, what exactly is a randomised function?
20:40:54 <Berengal> type Random a = StdGen -> (a, StdGen)
20:41:28 <Berengal> bind :: (a -> Random b) -> Random a -> Random b
20:42:15 <Berengal> Where you can read "Random a" as "some random value of type a"
20:42:19 <Cale> sshc: A good example would be   die :: Random Integer;  die = randomR (1,6)
20:42:19 <Berengal> Does that make sense?
20:42:45 <Cale> So it takes a generator, and produces a new generator along with a random integer from 1 to 6.
20:43:34 <sshc> Berengal: could I pass die as the first argument?
20:43:47 <Cale> die would be the second argument
20:43:48 <sshc> :t randomR (1,6)
20:43:49 <lambdabot> forall t g. (Num t, Random t, RandomGen g) => g -> (t, g)
20:43:51 <Berengal> sshc: die is a value, not a function
20:44:00 <Berengal> In this context at least
20:44:00 <Cale> die is only secretly a function
20:44:05 <Berengal> Yes
20:44:07 <Berengal> That
20:44:20 <sshc> what could I pass for the first argument?
20:44:39 <Cale> sshc: How about the function which given a number, rolls another die and adds the two values?
20:44:42 <Berengal> A function that for example takes a die value and returns a random value based on that
20:44:50 <Cale> (producing the result of the addition, and the final generator)
20:45:42 <Berengal> addToDie n = fmap (+n) die
20:45:42 <Cale> (\x g -> let (y,g') = die g in (x+y,g'))
20:45:57 <Cale> same thing
20:45:58 <Berengal> Then 'bind addToDie die :: random Integer'
20:46:17 <Berengal> *Random
20:47:07 <Cale> This is a somewhat awkward explanation. I think we need the rest of the monad operations to make it a little more coherent.
20:47:25 <Berengal> At least return would be useful
20:47:41 <Cale> The end result is that you can write things like   do x <- die; y <- die; return (x+y)  to mean the randomised value which is the result of rolling two dice
20:48:07 <Cale> Or, what is the same thing,  liftM2 (+) die die
20:48:20 <Berengal> bind (\x -> bind (\y -> return (x + y)) die) die
20:49:49 <Cale> sshc: But I guess one answer is that a randomised function is the same as a normal function which produces a randomised value.
20:50:14 <Cale> (which is secretly a function that takes a StdGen)
20:50:24 <Cale> (and produces a StdGen as part of its result)
20:51:01 <sshc> Cale: why isn't the firstr argument's type (StdGen -> a -> (b, StdGen))?
20:51:14 <sshc> Cale: I think that would make it more intuitive
20:51:19 <Berengal> sshc: It is, but flipped around a bit
20:51:49 <sshc> Berengal: do I benifit at all if I use (a -> StdGen -> (b, StdGen)) instead?
20:51:53 <Berengal> sshc: Also, we're trying to hide the StdGens being passed around, which is much easier if we put them last.
20:52:14 <Berengal> sshc: you can't use my type synonym 'Random' from above, for example.
20:52:16 <Cale> sshc: Really, we're going to hide this StdGen machinery behind an abstract type constructor
20:52:41 <Cale> newtype Random a = R {runRandom :: StdGen -> (a,StdGen)}
20:53:01 <Cale> So then the type of this bind becomes
20:53:10 <Cale> bind :: (a -> Random b) -> Random a -> Random b
20:53:32 <sshc> I understand that part now, but shouldn't the type of the second argmunent of bind be the same as the first since bind is composing to randomised functions?
20:53:45 <Cale> But it's not, really
20:53:50 <sshc> the second is the same as the first, only without the "a ->"
20:53:54 <sshc> but it should?
20:53:59 <Cale> It's applying a randomised function to a randomised value
20:54:09 <sshc> oh
20:54:47 <Cale> (I forget how that particular tutorial is trying to explain things, so it's possible that's confusing...)
20:55:11 <Cale> In a sense, it is composing some elaborate functions, but I don't think that's the best way to see it
20:55:14 <HaskellTripleLov> Anyone has any idea how to solve euler 26? All i know for now that might be usefull is that if you divide any number by 9s you get recuring cycle of digits in decimal are, such that the number of digits is the number of 9s you used. any advice to get me started?
20:55:48 <sshc> Cale: this is the one that's made the most sence to me
20:56:25 <Cale> HaskellTripleLov: Implement the division algorithm yourself, in such a way that you keep track of the remainders so that you can see when you've gotten into a cycle.
20:56:46 <HaskellTripleLov> and once I divide a number how can I get only its decimal part? for example 232.64? can i pattern match somehow like _.64?
20:56:58 <Cale> HaskellTripleLov: The division algorithm being the one you learned to carry out in grade 6 or whatever :)
20:57:14 <Cale> You shouldn't use floating point values for this.
20:57:30 <Berengal> HaskellTripleLov: Look at the RealFrac class (:info RealFrac). It has some nice functions for dealing with fractions
20:57:47 <canti> hello. can i write something like `` case x of "a" || "A" -> "it's a" '' ? I mean the "a" _or_ "A" part, I have no haskell experience, but need a quick answer now, thanks.
20:57:50 <Berengal> Also, there's a much easier way of solving this...
20:58:15 <Saizan_> sshc: it's not bind that composes the functions, it's (*) which does
20:58:20 <Cale> canti: There's no way to take the OR of two patterns
20:58:22 <Berengal> canti: You can with view-patterns and a helper case-insensitive function, but not natively, no)
20:58:29 <Saizan_> sshc: with "f * g = bind f . g"
20:58:38 <Veinor> it's a lot easier if you know number theory
20:58:40 <Cale> canti: But you can toLower the value beforehand
20:58:56 <canti> ok...
20:59:02 <meanburrito920_> is it generally common practice to put commas before or after newlines?
20:59:05 <manjunaths> hello
20:59:16 <sshc> Saizan_: so what exactly does bind do?
20:59:16 <Berengal> meanburrito920_: As in e.g. lists?
20:59:25 <Cale> canti: or use a guard like    case x of x | x `elem` "aA" -> ...
20:59:29 <meanburrito920_> Berengal: or module declarations, etc
20:59:52 <Berengal> sshc: it collapses the randomizing wave-function of the random value, and applies the randomized function to the regular value
20:59:56 <Veinor> meanburrito920_: I personally like before, but I think it's stylistic
20:59:59 <HaskellTripleLov> Cale can't I just divide the number, get the decimals and go over them? I mean, why implement a divide algorithm?
21:00:00 <Cale> meanburrito920_: either way
21:00:09 <sshc> Cale: so bind in exercise & is a function that, when given an initial seed (last argument it takes), applies it to the random value ,and passes it to the function (first argument)?
21:00:11 <Saizan_> sshc: bind prepares one of these functions so that it can be easily composed with the other
21:00:21 <Berengal> meanburrito920_: I like to put them before, and the brackets or whatever on a separate line
21:00:29 <sshc> Saizan_: that maskes sence.
21:00:32 <Cale> HaskellTripleLov: Floating point division doesn't really properly work in decimal and has all sorts of problems with it.
21:00:32 <Berengal> meanburrito920_: But either way is common
21:00:57 <Cale> HaskellTripleLov: Also, it gives you no sense of the remainders as each step proceeds
21:00:58 <canti> Cale: i think i'll just write the case twice, each for one of "a" and "A", it's just an example btw...
21:01:07 <Cale> HaskellTripleLov: So you can't tell if there's a cycle or not
21:01:43 <Cale> HaskellTripleLov: Consider what happens when you get a repeating pattern like  393939393912393939393912...
21:02:00 <HaskellTripleLov> ouch
21:02:05 <Cale> HaskellTripleLov: and of course, maybe that's not even the real cycle
21:02:08 <Saizan_> sshc: you can also see bind as a fancy version of function application
21:02:11 <Cale> Maybe the real cycle is longer still
21:02:31 <Cale> You can't tell from the digits, you need the remainders along the way
21:02:57 <HaskellTripleLov> Cale I see...
21:03:17 <Saizan_> sshc: ($) :: (a -> b) -> a -> b, while bind :: (a -> M b) -> M a -> M b, aside from M which is the extra stuff that we carry around in each case, those are pretty similar
21:03:33 <Veinor> that's not bind, that's flip bind :P
21:03:45 <Cale> canti: You could also use let/where to define the common thing
21:03:53 <Saizan_> Veinor: it's bind as defined in sigfpe's article :)
21:04:00 <Veinor> :P
21:04:06 <Berengal> bind /= >>=, apparantly
21:04:14 * Veinor shrugs
21:04:15 <Cale> bind = (=<<)
21:04:34 <Cale> (in this context anyway)
21:04:45 <sshc> why is bind defined as =<< instead of >>= in his article?
21:05:07 <Cale> I'm not sure. Maybe he liked the better agreement with function application.
21:05:44 <Cale> It keeps the information "flowing in the same direction" when used with function composition too
21:05:50 <sshc> the random exercises are a lot more complex, but he gets into a lot less detail there than before.
21:06:27 <Cale> putStrLn . reverse =<< getContents
21:06:43 <HaskellTripleLov> wow I cant beleive Haskell does not have a divide for reals where you can choose precision...  I mean, it is known for language where math folks do their stuff...
21:07:04 <Cale> HaskellTripleLov: There are infinite precision computable real libraries
21:07:08 <Berengal> > pi :: CReal
21:07:09 <lambdabot>   3.1415926535897932384626433832795028841972
21:07:12 <Cale> HaskellTripleLov: But they're irrelevant to this problem
21:07:22 <Veinor> wow, who expanded the Haskell article on Wikipedia
21:07:28 <Cale> Because again, you can't tell what the remainder is.
21:07:39 <troutwine> Has anyone managed to get mmm-mode setup so that literate, latex-style haskell has both haskell and latex syntax highlighting?
21:08:16 <sshc> > {-why isn't putStrNl working?-} putStrNl $ show 3
21:08:17 <lambdabot>   <IO ()>
21:08:32 <Cale> Ln
21:08:42 <Cale> (short for Line)
21:08:47 <sshc> I like Nl better
21:08:50 <sshc> short for newline
21:09:02 <sshc> I defined it by @let putStrNl = putStrLn
21:09:18 <sshc> > let putStrNl = putStrLn in putStrLn $ show 42
21:09:19 <lambdabot>   <IO ()>
21:09:27 <Veinor> :t show
21:09:28 <lambdabot> forall a. (Show a) => a -> String
21:09:44 <Veinor> > putStrLn "42"
21:09:45 <lambdabot>   <IO ()>
21:09:54 <Veinor> lambdabot is showing the return value of putStrLn
21:09:58 <Veinor> not the output
21:10:10 <sshc> oh
21:10:13 <Veinor> Prelude> putStrLn $ show 42
21:10:13 <Veinor> 42
21:10:13 <Veinor> Prelude>
21:10:27 <Veinor> and putStrLn returns an IO ()
21:10:40 <Cale> lambdabot will evaluate expressions containing IO actions, but won't execute the resulting actions
21:10:51 <troutwine> The advice given here http://tinyurl.com/ydwklor isn't really workable.
21:10:55 <kmc> this is actually really good for demonstrating the difference between evaluation and execution :)
21:10:58 <Cale> ghci normally does both in a "smart" way, which can be confusing at first
21:11:15 <kmc> troutwine, yeah, i never got that working :/
21:11:40 <Axman6> :t from
21:11:41 <lambdabot> Not in scope: `from'
21:11:43 <Axman6> :t fromEnum
21:11:44 <lambdabot> forall a. (Enum a) => a -> Int
21:11:59 <Axman6> > fromEnum Nothing
21:12:00 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe a))
21:12:00 <lambdabot>    arising from a use ...
21:12:07 <Axman6> huh
21:12:07 <troutwine> kmc: Hmm... bother. I suppose mmm-mode _is_ fantastically archaic.
21:12:13 <meanburrito920_> why is it that when I attempt to compile some code with any -O flag, i get a message stating "compilation IS NOT required" ?
21:12:27 <sshc> Cale: why not?
21:12:36 <Berengal> meanburrito920_: Did you compile it already once before?
21:12:38 <kmc> meanburrito920_, because you have an up-to-date .o file laying around?
21:12:40 <Cale> sshc: Why doesn't it execute IO?
21:12:40 <kmc> try to touch the .hs file
21:12:42 <Axman6> meanburrito920_: no changes have been made that need recompilation?
21:12:47 <sshc> Cale: yes
21:12:53 <kmc> sshc, lambdabot doesn't execute IO for security
21:12:53 <Cale> sshc: That opens up all sorts of potential security issues.
21:12:54 <meanburrito920_> ah ok
21:13:02 <kmc> and because it's not very well-defined
21:13:06 <kmc> e.g. if you getChar, where does the char come from?
21:13:08 <Veinor> it's the same reason most other repl bots don't let you call system :D
21:13:17 <Cale> sshc: evaluation of Haskell expressions is safe (or at least reasonably so, once you sandbox the resource usage)
21:13:22 <sshc> I see
21:13:27 <Saizan_> meanburrito920_: unfortunately ghc doesn't see that since you've given it a different optimization level it should recopile even if the .hi files look up to date
21:13:29 <Cale> sshc: Execution of IO actions could do anything at all.
21:13:43 <Veinor> launchNuclearMissiles :: IO ()
21:13:45 <meanburrito920_> Saizan_: should that be a bug?
21:13:53 <kmc> there are various backdoors into the IO system, but it's fairly easy to exclude them on a per-module basis
21:14:08 <Saizan_> meanburrito920_: not sure about that
21:14:26 <Veinor> yeah, that's a good question
21:14:28 <meanburrito920_> well it seems like the expected behavior would be for recompilation
21:15:06 <Berengal> meanburrito920_: You could file it as a bug. Worst case it's deemed a feature and closed. Search the bug archives first
21:15:08 <sshc> Cale: aren't the only things IO actions could do are whatever is defined in System.IO?
21:15:27 <kmc> sshc, there are lots of things you can do in the IO monad, with the right module
21:15:33 <kmc> you can break the type system using Foreign
21:15:40 <Veinor> ghci comes with a lot of modules loaded for convenience
21:15:51 <Veinor> better safe then sorry
21:15:55 <Berengal> It's better to bring IO into other monads in restricted cases
21:15:58 <Cale> Well, we wouldn't import Foreign either, but messing with the filesystem is enough to create trouble.
21:16:07 <Axman6> sshc: no, not if you're using the FFI
21:16:31 <Berengal> For example, mmorrow brought the newStdGen :: IO StdGen function into the Rand monad
21:16:32 <sshc> ok
21:16:42 <Cale> You could read and write files in my home directory on linode if you could execute IO, which I'd rather you not be able to do.
21:17:14 <Cale> (not that there's anything all that sensitive there, but still)
21:17:25 <Berengal> You could sandbox the entire bot environment as well, but that's bothersome and wasteful when you've got such a nice typesystem doing the work already
21:17:36 <kmc> there are also non-IO functions that are similarly unsafe
21:17:38 <kmc> e.g. unsafeCoerce
21:17:52 <Berengal> > unsafeCoerce "Hello" :: In
21:17:54 <lambdabot>   Not in scope: type constructor or class `In'Not in scope: `unsafeCoerce'
21:18:01 <kmc> and all of ghc's primitive IO ops, which are not in the IO monad
21:18:07 <Axman6> , unsafeCoerce "hello" :: Int
21:18:08 <lunabot>  luna: Not in scope: `unsafeCoerce'
21:18:11 <Axman6> :(
21:18:18 <kmc> once you allow unsafeCoerce you can no longer rely on the type system to tell you /anything/
21:18:46 <Berengal> You _can_ just unsafeCoerce your way into mordor
21:19:09 <Berengal> Although it's probably a segfault to do so...
21:19:32 <Veinor> unsafeCoerce "quux" :: Integer made ghci hang hard
21:19:48 <Axman6> ha
21:20:07 <Axman6> yeah, Integer is somewhat ... well interesting in its implementation
21:20:08 <Cale> Pretty unsurprising.
21:20:22 <Cale> I also wouldn't be surprised to see a segfault.
21:20:31 <Veinor> C-c didn't do anything, had to kill it
21:20:32 * kmc is suspicious any time someone says something is "probably" a segfault
21:20:47 <Veinor> yeah, I segfaulted when I just did unsafeCoerce "string"
21:21:03 <Veinor> or, whatever this is:
21:21:03 <Veinor> <interactive>: internal error: stg_ap_v_ret
21:21:07 <Cale> Well, generally anything involving unsafeCoerce between genuinely different types will cause that.
21:21:10 <Berengal> kmc: Would you feel better if it was a guaranteed segfault?
21:21:33 <kmc> yes
21:21:35 <Veinor> apparently newtype -> wrapped type is safe
21:21:36 <Cale> You'll either get a segfault, or in some rarish cases, reinterpretation gibberish
21:21:49 <kmc> i am just afraid of mediocre C programmers who shrug off errors as "probably a segfault"
21:21:50 <Cale> This is why it's called unsafe :)
21:21:57 <kmc> not so applicable here
21:22:06 <Cale> You're supposed to prove that the types really are equal
21:22:20 <sshc> Cale: have you ever been able to have reinterpretation gibberish?
21:22:26 <kmc> Cale, in my limited experimentation, it was actually rather difficult to get a segfault
21:22:43 <sshc> Cale: for fun, I would like an example
21:22:47 <kmc> much of the time a cast between two algebraic types will simply map the constructors in order
21:22:52 <Berengal> And with unsafePerformIO you're supposed to prove it's really referentially transparent, but people tend not to be too rigorous
21:22:54 <kmc> e.g. (unsafeCoerce ()) == False
21:23:00 <Cale> ghci> unsafeCoerce# False :: Maybe Integer
21:23:00 <Cale> Nothing
21:23:20 <Cale> ghci> unsafeCoerce# True :: Maybe ()
21:23:20 <Cale> Just ()
21:23:28 <Axman6> http://hackage.haskell.org/packages/archive/cereal/0.2/doc/html/src/Data-Serialize-Put.html#putListOf i really like the implementation of this function
21:23:37 <Veinor> I think unsafePerformIO is safer than coerce :P
21:23:40 <Berengal> Does () even exist at runtime?
21:23:46 <Cale> Veinor: Not really.
21:23:49 <Berengal> Well, I guess it has to because of _|_
21:23:51 <Veinor> well, safer in usage
21:24:00 <Cale> Veinor: You can write unsafeCoerce with unsafePerformIO and IORefs :)
21:24:07 <Veinor> I really like the type Putter
21:24:33 <Axman6> i just like the whole cereal library :)
21:24:57 <Veinor> cereal?
21:25:29 <Axman6> @hoogle cereal
21:25:30 <lambdabot> No results found
21:25:49 <Axman6> @hackage cereal
21:25:49 <lambdabot> http://hackage.haskell.org/package/cereal
21:25:50 <Axman6> even
21:26:01 <Veinor> ah, serialization
21:26:07 <Cale> ghci> let unsafeCoerce x = unsafePerformIO (do writeIORef r x; readIORef r) where r :: IORef a; r = unsafePerformIO (newIORef undefined)
21:26:07 <Cale> ghci> :t unsafeCoerce
21:26:07 <Cale> unsafeCoerce :: a -> a1
21:26:20 <sshc> Cale: I wonder if anybody's ever been able to unsafeCoerce something to a function
21:26:26 <Cale> sshc: yes
21:26:34 <Cale> sshc: dons did it for the IOHCC.
21:26:40 <sshc> Cale: really?
21:26:47 <sshc> Cale: how did he do it?
21:26:57 <sshc> Cale: or from which value did he coerce?
21:26:57 <Axman6> magic
21:27:10 <Berengal> Machine code in bytestring?
21:27:18 <Cale> Yeah
21:27:25 <Cale> iirc.
21:27:29 <sshc> Cale: what did he do?
21:27:30 <Axman6> o.O
21:27:35 <sshc> Cale: I want to try it out in ghci :)
21:27:55 <Veinor> Cale: oh, ew
21:27:56 <Berengal> Shouldn't be too hard, provided you know machine code and haskell's calling conventions and stuff... which does make it pretty hard for the regular layman
21:28:06 <Cale> I'll see if I can find it. It's probably bitrotted, as I wouldn't expect it to work with anything but the one version of GHC it was meant for.
21:28:37 <froystig> haskell.org/ghc/reportabug is down?
21:28:56 <froystig> back up!
21:28:57 <froystig> false alarm
21:29:06 <sshc> froystig: try reporting a bug
21:29:20 <Cale> lol, I was looking for his program, and look what I found: http://www.midnightministries.org.uk/don_stewart.htm
21:29:23 <froystig> i will try seeing if it's already filed first
21:30:13 <Veinor> Cale: haha
21:30:20 <Cale> http://www.cse.unsw.edu.au/~dons/crawl/crawl.hs
21:30:27 <Axman6> Cale: ha
21:30:41 <froystig> sshc: i guess #ghc is a better place to be doing this anyhow
21:31:15 <edwardk> cale: that seems positively reddit worthy ;)
21:31:45 * Axman6 secconds that
21:32:26 <Cale> It doesn't appear to even compile anymore
21:34:55 <Cale> Though I was wrong, it's not actually a representation of a function, just a String
21:35:27 <Cale> But with a little more work, perhaps you could.
21:35:57 <Veinor> from another channel:
21:35:57 <Veinor> 00:32:02 <@Volte> cout -w static const char add_inst[] = "\x55\x48\x89\xe5\x89\x7d\xfc\x89\x75\xf8\x8b\x55\xf8\x8b\x45\xfc\x01\xd0\xc9\xc3"; int main() {int (*add)(int, int) = (int (*)(int, int))add_inst;printf("%d", add(20,4));}
21:36:01 <Veinor> 00:32:03 <+coutbot> 24
21:36:33 <Cale> heh
21:36:54 <Cale> Though, it's easy enough to do that sort of thing.
21:36:56 <sshc> I would like to see something coerced into a function
21:37:02 <sshc> it would be quite interesting
21:37:59 <Axman6> sounds extremely unhaskellish to me
21:38:04 <Cale> sshc: I would do it, but it would require me to actually learn the current physical layout of functions in GHC. You could presumably use a debugger or something and grab the machine code for a compiled function
21:38:53 <sshc> "unsafeCoerce ([3]++) :: [Word8]" is returning an empty list
21:39:04 <Cale> Yeah
21:39:30 <Cale> In memory, [Word8] is not generally a contiguous block of memory
21:39:48 <Cale> It's a lazy linked list
21:41:27 <pikhq> IOHCC?
21:41:30 <sshc> Cale: how do I make it strictly evaluated?
21:41:32 * pikhq must look
21:42:02 <Berengal> sshc: print is strict. ghci uses print to print values
21:42:25 <Berengal> Well, print is _usually_ strict
21:42:33 <Berengal> > print (undefined :: ())
21:42:35 <lambdabot>   <IO ()>
21:42:37 <Axman6> prints lists lazily...
21:42:39 <Berengal> > show (undefined :: ())
21:42:41 <lambdabot>   "* Exception: Prelude.undefined
21:42:50 <Berengal> Wow
21:42:51 <Axman6> > show [undefined]
21:42:52 <lambdabot>   "[* Exception: Prelude.undefined
21:43:03 <Axman6> > show [1,2,3,undefined]
21:43:04 <lambdabot>   "[1,2,3,* Exception: Prelude.undefined
21:44:17 <sshc> Cale: is it possible to coerce a function into any non-function value that can be corced back into the same function?
21:44:45 <Cale> sshc: Possibly.
21:45:19 <ezyang> evening folks
21:45:21 <HaskellTripleLov> So you guys use mutable lists or try to escape that?
21:45:39 <dibblego> someone hasn't been paying attention
21:45:40 <Axman6> there are no mutable lists in haskell
21:45:49 <pikhq> There is no mutability.
21:46:07 <HaskellTripleLov> nah I meant mutable arrays
21:46:18 <Axman6> depends on the situation
21:46:27 <Axman6> they're fine in the ST monad
21:46:32 <sshc> Cale: on the subject of bind for exercise 7, what's the point of the second argument, which has a type of StdGen?
21:46:45 <kmc> there are mutable lists
21:46:47 <sshc> Cale: if you're passing a random value, why do you need two StdGen's instead of one?
21:46:48 <kmc> and there definitely is mutability
21:46:54 <HaskellTripleLov> for example I write a division algorithm and i need an array to throw results from calculations in it
21:46:55 <kmc> it's a total myth that haskell can't work with mutable data
21:46:59 <kmc> it's just not the default way to do things
21:47:15 <ezyang> "and you have to put it away when you're done"
21:47:28 <pikhq> kmc: No, there's just stuff that looks remarkably similar.
21:47:31 <pikhq> Oh, and IO.
21:47:40 <kmc> IO, ST, STM, etc.
21:47:40 <sshc> kmc: is IO the only way to work with mutable data?
21:47:43 <c_wraith> It's also best to encapsulate the mutability, preferably with as little leakage as possible.  Like using ST for mutable array algorithms, instead of IO.
21:47:48 <kmc> sshc, there are several other monads for it
21:47:50 <Axman6> kmc: no
21:47:52 <kmc> with various things
21:47:54 <Axman6> uhm, sshc even
21:47:59 <pikhq> ST and STM only look remarkably similar to mutability.
21:48:00 <kmc> e.g. STM for multithreaded concurrent transactional memory
21:48:03 <Cale> sshc: You generate a random value with one StdGen, and that StdGen is used up, but thankfully, it gives you another to use next time.
21:48:04 <pikhq> :P
21:48:04 <Berengal> sshc: ST allows mutable data in a referentially transparent way.
21:48:07 <kmc> pikhq, what do you mean?
21:48:09 <Axman6> pikhq: ST is mutyability
21:48:14 <Berengal> sshc: Well, transparent outside of the ST action
21:48:14 <kmc> *variables* are never mutable
21:48:15 <Axman6> -y
21:48:16 <kmc> but other things are
21:48:22 <Cale> sshc: If you repeatedly use the same StdGen, obviously you get the same value every time
21:48:24 <kmc> like reference cells named by IORef values
21:48:28 <HaskellTripleLov> mutability wars, everyone run for their lives...
21:48:28 <pikhq> kmc: No, no, no. You'
21:48:32 <kmc> no no no
21:48:37 <kmc> know know know
21:48:38 <pikhq> re just transforming from a state to a state. :P
21:48:49 <kmc> pikhq, in what sense?
21:48:49 <pikhq> No changing of previous state whatsoever.
21:48:52 <kmc> operational implementation sense?
21:48:58 <kmc> because that's not true of the way GHC implements ST or IO
21:49:00 <sshc> Cale: so the purpose of having the second is to avoid using the same StdGen twice?
21:49:06 <kmc> you are actually writing to the same bits in memory
21:49:18 <Axman6> pikhq: the ST monad actually uses mutable variables
21:49:27 <kmc> it /is/ how GHC (or any Haskell system) implements the State monad (which is after all defined in ordinary Haskell)
21:49:30 <pikhq> Axman6: Oh, it actually does?
21:49:34 <kmc> State and ST are very, very different
21:49:41 <kmc> in both interface and implementation
21:49:41 <Cale> sshc: I'm a little unclear on what you mean by "the second", but yes.
21:49:54 * pikhq was confused, apparently.
21:50:46 <kmc> anyway, it's a harmful myth that Haskell has no way to deal with side effects
21:50:54 <kmc> we have better support for imperative programming than most languages
21:51:30 <Axman6> yep\
21:51:34 <kmc> because imperative actions are rightfully recognized as their own datatype, rather than being merely one part of a hodge-podge concept of "function"
21:51:43 <kmc> and we have powerful operations for working with that datatype
21:51:54 <Berengal> And also, they're first class values
21:52:11 <Berengal> Which isn't true in every imperative language even
21:52:19 <kmc> yeah, though it's true of all the good ones
21:52:56 <Berengal> But not all the popular ones (looking at you Java)
21:52:58 <sshc> kmc: if you had a choice, would you rather use java or C++?
21:53:25 <kmc> it's a total joke to say your language is based on executing sequences of steps, yet you don't even support "sequence of steps" as a datatype
21:53:38 <kmc> sshc, that depends on what i'm writing, obviously
21:54:07 <sshc> kmc: then when would you use java and when would you use C++?
21:54:29 <kmc> C++ is intellectually challenging.  writing good C++ code is like writing good brainfuck code -- you adopt a set of annoying arbitrary restrictions, and see what you can do with them
21:54:42 <kmc> and there are enough traps to keep you busy forever
21:55:01 <kmc> sshc, first of all, if i have to work with specific other people, that's a pretty big deciding factor
21:55:14 <kmc> if you say i'll be working with 100 average programmers, Java definitely
21:55:33 <kmc> because the amount of damage 100 average programmers can do with C++ is unimaginable
21:55:48 <sshc> if you're working alone...?
21:55:59 <pikhq> Nuke both langauges.
21:56:15 <kmc> still depends what i'm writing, why i'm writing it, and what the requirements are
21:56:42 <kmc> if it's a pure project for fun, but i have to use one of the two, I'd probably pick Java -- I don't know it as well, I'd learn more, and I'm past the point where learning C++ is fun and to the point where I know enough to hate it
21:56:58 <kmc> basically C++ is fun to learn but not to use, for the intellectual puzzle reason i gave
21:57:14 * ezyang wants to learn C++ template metaprogramming! 
21:57:22 <kmc> you learn how to do these really complicated designs, and you can feel good about being smart enough to figure them out
21:57:27 <pikhq> ezyang: Do you know Haskell?
21:57:27 <Berengal> kmc: One of the problems with Java is that it's C++, but without the fun traps you speak of. It's an absolute bore from a to z
21:57:29 <kmc> then you see that each design would be 10 lines in any decent language
21:57:34 <kmc> Berengal, yeah :/
21:57:36 <pikhq> If so, then C++ template metaprogramming is trivial.
21:57:42 <kmc> ha, i doubt it
21:57:48 <kmc> Haskell is a good functional language
21:57:53 <kmc> C++ templates are a terrible functional language
21:57:53 <pikhq> You have none of the Prelude, IO is not a type, and it's very verbose.
21:58:02 <ezyang> pikhq: I hope so!
21:58:20 <kmc> it's an absolute embarrassment to C++ that they have no better way to metaprogram it than templates
21:58:22 <pikhq> It's very *annoying* to mess with, but rather trivial.
21:58:36 <pikhq> kmc: The preprocessor is often better.
21:58:42 <kmc> and they defend templates as being a feature, when they're really the absolute most broken you could make them and still be remotely usable
21:58:45 <ezyang> I don't really have a good excuse to cozy up to C++, besides doing USACO practice problems...
21:58:47 <pikhq> And that only barely counts as metaprogramming.
21:58:48 <HaskellTripleLov> kmc yeah i hate templates, too, explicit parametric polymorphism, damn even the name is ugly
21:58:59 <troutwine> Sometimes I wonder, when looking at C++ template metacode, if Stroustrup secretly hates all that is good and wonderful.
21:59:21 <Axman6> i'm going to be learning C++ next semester for my high performance computing course
21:59:28 <kmc> "Within C++, there is a much smaller and cleaner language struggling to get out"
21:59:36 * povman uses c++ every day for work
21:59:50 <Axman6> kmc: C?
21:59:50 <pikhq> kmc: Resembles C in many ways, that smaller language.
21:59:52 <stoop> pikhq, templates are pretty much glorified preprocessing. :-P
21:59:56 <stoop> pikhq, (in C++)
22:00:01 <ezyang> (I also think I got rejected from an internship because I didn't have any C++ experience ^^)
22:00:01 <HaskellTripleLov> ezyang is USACO like Euler project or what?
22:00:05 <pikhq> stoop: No.
22:00:11 <ezyang> HaskellTripleLov: Not really.
22:00:15 <pikhq> stoop: Templates are TC. The preprocessor is not.
22:00:41 <toast-opt> stoop - yeah, only if you consider lazy evaluation also 'glorified preprocessing'
22:00:47 <stoop> pikhq, "glorified". :-)
22:01:11 <toast-opt> pikhq - um, i think the C preprocessor is also turing complete.  but not in a good way
22:01:15 <kmc> templates lure you into thinking they're glorified preprocessing
22:01:25 <kmc> but actually name resolution and a whole bunch of other stuff is different inside a template
22:02:09 <kmc> if A<T> inherits from B<T>, B<T> implements foo(), and A<T> calls foo()... it will go look for some random fucking foo() in the global namespace before it goes to B<T>::foo()
22:02:12 <toast-opt> like how templates capture their environment
22:02:39 <kmc> also the whole typename bullshit
22:02:46 <stoop> toast-opt, The C preprocessor is not turing complete.
22:02:47 <pikhq> toast-opt: Only if you assume repeated evaluation of the preprocessor until there is no change in the output.
22:02:50 <kmc> and calling a member fn template of a class template
22:03:08 <kmc> x = Foo<T>:: template bar<T>(3);
22:03:10 <toast-opt> stoop - not even when you include (sic) multiple includes?
22:03:55 <pikhq> toast-opt: *Only* when the preprocessor is evaluated until there is no change in output.
22:04:11 <stoop> toast-opt, not without preprocessing several times (non-standard behavior).
22:04:51 <kmc> Berengal, re C++ vs Java, if i'm "using Java" I can at least write tools in Haskell to automate my work
22:05:11 <kmc> the awfulness of C++ syntax together with the deranged idealism of the GNU hippies pretty much excludes writing any tool to process C++
22:05:25 <kmc> unless you have several coder-years to devote to the effort
22:05:39 <pikhq> kmc: Even without the GNU stuff, it's nearly impossible. C++ syntax is the worst I've seen in a language.
22:05:45 <pikhq> And I know autotools.
22:05:49 <kmc> haha
22:06:10 <kmc> the GNU reference is to the fact that g++ is intentionally built so as to be difficult to integrate into other tools
22:06:18 <stoop> How so, kmc?
22:06:18 <kmc> basically, the equivalent of the GHC API is forbidden by policy
22:06:48 <stoop> kmc, can you give me an example of a compiler that is easier to "integrate"? Integrate in what ways?
22:06:57 <Axman6> which makes the recent news that Clang can compile itself and LLVM even more interesting
22:07:00 <troutwine> For what it's worth, clang inches closer and closer to full c++ support.
22:07:02 <kmc> stoop, like you can use GHC's parser, typechecker, or code gen as a library
22:07:14 <Axman6> though, the compiled code is broken and i don't think works
22:07:17 <kmc> they don't want people to glue bits of GCC onto proprietary code.  if it supported nice serialized forms of intermediate languages, people could use it in proprietary systems without running afoul of the GPL
22:07:21 <stoop> kmc, I am referring to C compilers.
22:07:23 <troutwine> Just links.
22:07:29 <pikhq> kmc: Ah, right. Yeah, I don't think anyone even *understands* GCC...
22:07:29 <kmc> stoop, well...
22:07:37 <kmc> a C compiler could provide its routines as a library too
22:07:38 <stoop> pikhq, why? :-P
22:07:41 <kmc> a good one would
22:08:02 <stoop> gcc developer channel has around 77 active users, a lot of them really knowledgeable.
22:08:03 <Axman6> stoop: The OpenCL stuff Apple are duing basically uses an embedded C compiler to compile a very C like language for your GPU
22:08:33 <Axman6> going*
22:09:15 <stoop> Axman6, sure.
22:09:33 <kmc> anyway if the gcc C++ parser were a nice self-contained library it would make everyone's life easier
22:09:38 <kmc> but it's not and never will be
22:09:43 <stoop> kmc, fair enough.
22:09:44 <kmc> by decree
22:09:56 <stoop> I should probably start learning about LLVM.
22:10:01 <kmc> indeed, me too
22:10:02 <pikhq> Clang, however, does that.
22:10:03 <stoop> It'll probably be an industry standard soon enough.
22:10:11 <kmc> meanwhile gcc-xml doesn't even parse function bodies
22:10:42 <kmc> it makes me sad that smart people are spending their time implementing C++
22:10:51 <kmc> we really ought to write the language off and start over
22:10:55 <kmc> maybe use D or something
22:11:12 <stoop> We should use our imaginations.
22:11:25 <pikhq> stoop: I anticipate Clang being the standard C compiler in a couple of years...
22:11:25 <stoop> and create an empire of vaporware.
22:11:39 <stoop> pikhq, likewise.
22:12:01 <stoop> pikhq, I know FreeBSD has a good effort (with good progress) in supporting Clang. Do you know of such an effort for Linux?
22:12:11 <troutwine> Clang supports all the GNU extensions, yes?
22:12:16 <stoop> Solaris needs to drop SunCC, IMHO.
22:12:18 <pikhq> Clang supports most of them.
22:13:03 <pikhq> It only doesn't build Linux itself because it doesn't support a very very bizarre feature that makes GCC output code for running in 16-bit mode.
22:13:18 <pikhq> (... That uses 32-bit everything)
22:13:20 <ezyang> oh, is that for the bootstrapping code?
22:13:35 <pikhq> Yeah, that's for the x86 kernel entry point.
22:13:52 <stoop> I see.
22:14:26 <ezyang> "real men write their 16-bit code in asm yo"
22:14:29 <stoop> pikhq, which file exactly?
22:14:46 <stoop> ezyang, yeah, I was thinking something along the lines of this. :-P
22:15:06 <pikhq> Don't recall.
22:15:06 <stoop> FreeBSD bootstrap is mostly in assembly (leading to pmode).
22:15:16 <stoop> Ignoring btx, which is in forth.
22:15:56 <pikhq> The Linux kernel uses a whole stream of GNU extensions, making it kinda hard to build with non-GCC compilers.
22:16:34 <pikhq> There's also the occasional bit of hand-assembled machine code stuck in a global char[], making it kinda hard to understand WTF is going on. :P
22:16:46 <stoop> Yeah, it is fucking intense.
22:17:03 <stoop> That is, usage of GNU extensions.
22:17:11 <Trinithis> Just write a Haskell program to deciper it
22:17:13 <stoop> pikhq, that isn't an issue, since that would either be firmware or PIC.
22:17:57 <stoop> http://fxr.watson.org/fxr/source//include/linux/compiler.h?v=linux-2.6
22:19:03 <stoop> http://fxr.watson.org/fxr/source/include/linux/compiler-gcc3.h?v=linux-2.6 :-/
22:19:09 <stoop> I wonder why they don't just use unused attribute.
22:20:20 <ezyang> "submit a patch and maybe Linux will tell you"
22:20:26 <ezyang> *Linux
22:20:32 <ezyang> uh, fail
22:20:33 <troutwine> Linus?
22:20:35 <ezyang> *Linus
22:20:48 <stoop> haha
22:21:58 <roostaj> I have to say i'm thrown off by the indendation of if then statements
22:23:16 <Axman6> then and else need to be indented as much as or more than the if, not too hard
22:23:43 <kmc> roostaj, in Haskell?
22:23:53 <kmc> roostaj, it helps to understand what the layout rule actually is
22:23:57 <roostaj> kmc: yeah, to my eyes it just looks funny
22:24:23 <kmc> inside layout, if a line is to the left of the one above it, it's prepended with }
22:24:26 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15110 -- btw, I justed pasted a little mini-tutorial on how to transform imperative code into functional code.
22:24:33 <kmc> if it's lined up with the line above, it's prepended with ;
22:24:47 <kmc> if it's indented further, it continues the previous line and gets no special punctuation
22:24:57 <kmc> so if your "if then else" all line up, it's "if foo; then bar; else baz"
22:25:11 <kmc> which is going to be valid in H2010 but not in H98 nor GHC
22:25:23 <roostaj> kmc: ah i see
22:25:29 <kmc> (and by "line above" i actually mean the first token starting the layout block)
22:26:08 <kmc> if you are ever very confused by layout you can use explicit punctuation
22:27:10 <roostaj> kmc: I didn't realise that. Thanks
22:28:24 <stoop> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15063
22:28:52 <stoop> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15026 -- That one is cool
22:29:35 <stoop> At least for a newbie like me.
22:39:34 <HaskellTripleLov> what is wrong with this guys: let a = [x | (\x -> x == sum $ map (^5) $ map digitToInt $ show x) [1..1000000]]
22:40:22 <Axman6> you want x <- not \x -> i think. the whole thing is quite a mess though
22:41:28 <HaskellTripleLov> oops
22:41:28 <ezyang> this code is kind of ew: maybe (return ()) (\x -> prompt (Echo x) >> cat) line
22:41:45 <ezyang> I'm not sure if moving the lambdabot out is a good idea.
22:41:49 <ezyang> *lambda
22:42:29 <HaskellTripleLov> Axman6 wait, it is lambda function man, you use -> not <-
22:42:45 <Axman6> ok, well, you're not getting x from anywhere
22:43:09 <HaskellTripleLov> well i give it [1..1000000]
22:44:41 <jfischof> newb question
22:44:49 <jfischof> how do you fix: The last statement in a 'do' construct must be an expression
22:45:05 <Axman6> usually by using return
22:45:12 <Axman6> but, show us the code and we can explain more
22:45:52 <jfischof> cool, do you know the haskell pastebin url? I'm tracking it down
22:46:04 <Axman6> @where hpaste
22:46:05 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
22:46:38 <jfischof> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15118#a15118
22:47:13 <kmc> jfischof, your "do" cannot end with something like "x <- e"
22:47:25 <Axman6> lambdabot: the problem is the let is inproperly indented
22:47:25 <kmc> because that desugars to "e >>= \x ->"
22:47:37 <Axman6> uh, jfischof even
22:47:44 <HaskellTripleLov> nonone knows what is wrong with my code above?
22:47:54 <kmc> jfischof, don't use tabs
22:48:11 <Axman6> jfischof: this is more likely to work, but like kmc says, do not use tabs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15118#a15119
22:48:16 <jfischof> let is not indented
22:48:24 <Axman6> it needs to be
22:48:33 <jfischof> yeah, thanks. I'll change my whitespace settings
22:48:45 <Axman6> the compiler thinks the last line of the do construct is pPos <- new (180::Int, 270::Int, 2.0 :: GLdouble), not mainLoop
23:13:07 <meanburrito920_> does haskell memoize functions that take no inputs?
23:13:20 <ivanm> no
23:13:25 <ivanm> because there's no such thing
23:13:57 <kmc> also "yes", for the same reason
23:13:59 <ivanm> if it has no inputs, it isn't a function
23:13:59 <ivanm> it's a _value_
23:13:59 <kmc> ;)
23:14:17 <ivanm> kmc: heh
23:14:23 <meanburrito920_> ah. but it does cache computed values?
23:14:36 <meanburrito920_> I would think it does
23:14:45 <kmc> meanburrito920_, if you say "let x = e in y", x will only be computed once during the whole evaluation of y
23:14:47 <ivanm> do you mean top level variables?
23:15:00 <kmc> if that entire "let" expression appears inside a function, it may get recomputed for each call to that outer function
23:15:01 <kmc> it may not
23:15:06 <ivanm> if you have x = 2 as a top level definition, then it is only computed once
23:15:11 <ivanm> make that "at most once"
23:15:16 <kmc> the compiler is free to lift lets up beyond a lambda that binds a variable not used in the let
23:15:19 <ivanm> kmc: I think in general it will
23:15:32 <kmc> since evaluation never has a side effect
23:15:41 <meanburrito920_> i mean if i say 'let foo = zip [12..24] [1..12]
23:15:49 <ivanm> inside a function?
23:15:55 <ivanm> it _might_ cache that value
23:15:56 <meanburrito920_> anywhere
23:16:06 <meanburrito920_> becuase the value is constant no matter where it is
23:16:16 <pikhq> It is perfectly valid for it to cache that value.
23:16:21 <pikhq> However, it might not.
23:16:26 <kmc> > let foo = zip [12..24] [1..12] in (head foo, length foo) -- foo is computed only once
23:16:27 <lambdabot>   ((12,1),12)
23:16:29 <ivanm> meanburrito920_: well, you can't have a let in a top level definition ;-)
23:16:56 <ivanm> I think that's probably unwise in general; it could be extremely expensive in terms of memory, and if you only use it once why bother recalculating it?
23:17:00 <meanburrito920_> ivanm: right, but ghci
23:17:09 <ivanm> of course, wiser heads than one have probably considered this
23:17:13 <ivanm> meanburrito920_: hmmm?
23:17:13 <kmc> > let f x = { let foo = zip [12..24] [1..12] in (length foo, head foo) } in (f 'x', f 'y') -- foo is computed maybe twice, not four times
23:17:14 <lambdabot>   <no location info>: parse error on input `{'
23:17:28 <ivanm> if you define it in ghci, then it doesn't get recalculated
23:17:37 <ivanm> kmc: right
23:17:55 <ivanm> but if you have (length $ zip ... , head $ zip ... ) then it will definitely get computed 4 times
23:17:57 <kmc> it may also be computed once, if the optimizer floats that let out of the "f = \x -> ..."
23:18:17 <kmc> ivanm, well the compiler is free to do CSE as well
23:18:19 <ivanm> probably the best way to tell is to use Debug.Trace and see how many times the trace message gets printed
23:18:26 <ivanm> kmc: IIRC, ghc doesn't do CSE
23:18:29 <ivanm> @google ghc cse
23:18:30 <lambdabot> No Result Found.
23:18:39 <kmc> really??
23:18:46 <ivanm> really
23:18:48 <kmc> hmm
23:18:53 <kmc> i'm surprised, but i'm no ghc hacker
23:18:54 <ivanm> due to laziness, etc. making it difficult to do in general
23:19:01 <kmc> hmm
23:21:16 <meanburrito920_> i dont see how the laziness would effect the ability to do cse all that much. cse could be done more easily from the parser level, where the similar code would be evident.
23:21:34 <ivanm> *sigh* I'll say this again
23:21:54 <ivanm> let's say you have a top level let in a function definition that is _expensive_ in terms of space
23:22:21 <ivanm> if you had that value cached to avoid recalculation, but only ever called that function once in your program... wouldn't that be inefficient?
23:23:10 <meanburrito920_> is it any less efficient than having to recalculate a large value over and over again? I guess it comes down to whether or not you value memory or speed more
23:23:21 <ivanm> right
23:23:28 <ivanm> but in the latter case, there's ways around it
23:23:36 <meanburrito920_> such as?
23:23:39 <ivanm> (of explicitly caching the values using a closure or something)
23:24:01 <kmc> the optimizer won't decide tradeoffs like that for you
23:24:12 <kmc> because it's easy to make a let binding yourself
23:24:16 <meanburrito920_> right
23:24:18 <ivanm> right
23:24:33 <kmc> that said i can imagine doing cse in simple cases
23:24:40 <kmc> *shrug*
23:24:54 <ivanm> IIRC, I did something like this for an assignment; I'm trying to dig it up now
23:25:24 <Axman6> ivanm: reckon you'll be down here when dons is?
23:25:37 <ivanm> when is he going to be in canberra?
23:25:40 <ivanm> (but I doubt it)
23:26:30 <ivanm> nope, can't find where I did explicit caching
23:26:40 <ivanm> but IIRC, you use another function to create a closure...
23:32:18 <ivanm> Axman6: but anyway, I'm not going to be moving down till about Feb 10
23:38:46 <kmc> in Haskell each let-bound variable (function or not) is a closure
23:39:23 <kmc> in fact in the original STG-machine paper, everything that's not a primitive value is a closure of sorts
23:39:34 <kmc> thunks, functions, constructors
23:42:21 * ivanm is under the impression that Axman6 is now ignoring him... >_>
23:42:34 <Cale> s/in Haskell/in GHC/
23:43:39 <Cale> There's nothing which says that anything in Haskell needs to be implemented with closures.
23:44:24 <Cale> I actually really like the straightforward graph reduction and substitution model. :)
23:46:41 <Jafet> Is there any implementation of a language using direct graph reduction, though?
23:48:22 <Gracenotes> direct?
23:48:49 <Gracenotes> you do need code to prod the reduction along
23:49:15 <Gracenotes> code-as-in-data, as in let statements, pattern matching... things..
23:52:55 <Cale> Jafet: HOPS
23:55:20 <Jafet> Interesting. Looks like a PLT for Haskell
23:56:41 <kmc> Cale, you're right.  though i think you can meaningfully identify certain nodes in a graph reduction system as "closures"
23:56:57 <kmc> the idea of closure (verb) over free variables is part of the language semantics
23:57:05 <kmc> well okay noun whatever
23:57:12 <kmc> grr
23:57:15 * kmc spins his wheels
23:59:59 <Cale> Jafet: You might send an email to Dr. Kahl bugging him to put the source online. I think he probably needs some encouragement that there's interest in it or something. :)
