00:00:03 <poe> really? f : W->V to f° : W*->V* doesn't work for infinite dimensional spaces?
00:00:22 <mercury^> Yes it does, but then it is not the transpose.
00:00:30 <mercury^> And it's not the transpose for complex spaces either.
00:03:00 <mercury^> Also, V*->W*, but you meant that I think.
00:15:41 <poe> who needs oo-dimensional spaces anyway ;)
00:16:48 <Rayne> how do i convert IO String -> String? my current problem: `lines (readFile "foo.txt")`
00:17:58 <poe> you don't
00:18:23 <poe> do { contents <- readFile "foo.txt"; let xs = lines contents; ... }
00:18:46 <poe> do { lines <- liftM lines (readFile "foo.txt"); ... }
00:19:25 <poe> maybe xs <- liftM lines ..  :)
00:20:06 <Saizan> Rayne: IO String is not a String, it's a program that when run will produce a String
00:20:30 <Saizan> so you can't extract a String from it, but you can push a function needing a String inside that program
00:20:42 <Saizan> like poe showed
00:22:07 <Saizan> http://www.haskell.org/haskellwiki/Introduction_to_IO <- for more
00:28:04 <Phyx-> hmm.. did syb 0.1.0.2 remove the "StringRep" dataTypeRep?
00:31:54 <Rayne> thanks for your help :)
00:32:03 <Baughn> http://haskell.org/haskellwiki/GHC/AdvancedOverlap <-- So I'm just guessing (I've yet to figure them out, really), but would type families simplify this any?
00:32:04 <Phyx-> ah, it became CharRep it seems
00:33:29 <Saizan> Baughn: yes, TypeCast is just ~
00:34:43 <Baughn> Saizan: I was wondering about that. The page never defines a TypeCast class anywhere.
00:34:53 <Saizan> Baughn: it does, at the end
00:35:22 <Baughn> Oh, I see there"s already a note about type families /on/ the page..
00:35:35 * Baughn gets on with writing a monad transformer library
00:36:30 <Saizan> and you're going to use AdvancedOverlap in it?
00:37:08 <Baughn> Kind of. I need to solve the exact problem that page solves.
00:37:14 <dreixel> Phyx-: http://hackage.haskell.org/trac/ghc/ticket/2875
00:37:43 <Baughn> Saizan: Things would be ever so much simpler if instance declarations respected contexts
00:38:38 <Saizan> Baughn: depends on how much you value separate compilation, i guess
00:39:16 <Baughn> ..well, /point/
00:39:47 <ColaMan> Hello, I am a real newbie to Haskell. Looking for a link to download Data.Char, Data.Maybe and Test.QuickCheck please?
00:40:33 <byorgey> ColaMan: you should have Data.Char and Data.Maybe already... what Haskell compiler do you have, and how did you install it?
00:41:09 <Kim^Walkman> ColaMan: You sure you don't have them already? Have you tried importing them?
00:41:27 <Baughn> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13558 <-- I'm still trying to figure out how to make this work
00:41:39 <ColaMan> GHCi, I just downloaded it from the site, only seem to have the prelude...
00:41:49 <Twey> You should probably have Test.QuickCheck, too…
00:41:54 <Baughn> Saizan: Pay no attention to what's below the ===.. and don't bother trying to help right now, I'm going away. ^^;
00:42:20 <ColaMan> You are right! Please forgive my stupidity
00:42:21 <ColaMan> Thanks!
00:42:58 <Saizan> Wrappend, nice
00:44:06 <Saizan> ops, s/nd/d/
00:44:28 <Baughn> I've figured out how to /mostly/ do it, but only by requiring a bunch of trivial instances
00:45:31 <sshc> when would (>>) be useful outside of the IO monad?
00:45:33 <Saizan> it seems like you might just use an instance of inBase for Unwrap, from monadLib
00:46:11 <Baughn> sshc: When you use any other monad
00:46:21 <byorgey> sshc: any time you have a monad with "effects" and you want to do something just for the effect, and not to compute a value.
00:46:25 <Saizan> mh BaseM has a fundep, maybe that will get in the way
00:46:29 <byorgey> sshc: for example, if you want to change the state in the state monad
00:46:35 <byorgey> sshc: you might say   put 3 >> return 7
00:46:46 <byorgey> which would change the state to 3 and then return the value 7.
00:47:03 <Twey> :t put
00:47:04 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
00:47:32 <Twey> >> is much nicer to write than >>=\()-> :þ
00:51:14 <byorgey> although  >>=\_-> is nicer to write than  >>=\()->:þ
00:51:36 <byorgey> I've never even seen the :þ operator before
00:53:12 <sshc> Baughn: any other monad?  How would that be useful for the Maybe monad?
00:54:06 <sshc> byorgey: how does a monady have effects?
00:54:21 <sshc> byorgey: are there any standard monads that do?
00:54:21 <byorgey> sshc: it isn't particularly useful for the Maybe monad
00:54:38 <byorgey> sshc: they don't REALLY have effects, that's why I put it in quotes =)
00:54:50 <byorgey> sshc: but you can think of some monads as modelling "effectful" computations
00:54:59 <sshc> how do they do that?
00:55:08 <Philonous> Baughn: Thanks for the paper, that's exactly what I've been looking for for ages!
00:55:18 <sshc> if the result of anything before >> is ignored, how can it have any effects?
00:55:28 <byorgey> sshc: for example, the State monad models computations which can also have "side effects" (read from/write to) on a state
00:55:49 <byorgey> sshc: the *result* of something before >> is ignored, but its *effects* are not ignored.
00:56:08 <Twey> sshc: (>>) can produce a new value in itself, it just doesn't take a function to do stuff on top of that.
00:56:13 <Twey> :t (>>)
00:56:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
00:56:26 <Philonous> Baughn: That thing makes structural recursion on the type level feasible !
00:56:36 <sshc> byorgey: how is the state monad defined?
00:56:43 <sshc> I don't understand how that could be done
00:56:51 <byorgey> @src State
00:56:51 <lambdabot> Source not found. :(
00:57:02 <Saizan> for the Maybe monad it's useful in combination with guard
00:57:08 <Saizan> or some other check
00:57:16 <byorgey> oh, true
00:57:23 <byorgey> @unmtl State s a
00:57:23 <lambdabot> s -> (a, s)
00:57:58 <sshc> how would I define a simple effectful monad?
00:57:59 <byorgey> sshc: the type  State s a  is basically a function that takes the old state and produces a value and a new state
00:58:25 <byorgey> sshc: I would suggest that you start by implementing a Monad instance for Maybe
00:58:41 <byorgey> the "effect" of a computation in the Maybe monad is that the computation may fail
00:59:15 <byorgey> sshc: then you can work your way through the list monad (nondeterministic computations), and the State monad
00:59:48 <byorgey> sshc: I suggest reading http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
01:00:07 <sshc> > (return Nothing) >> (return $ Just 3)
01:00:08 <lambdabot>   No instance for (GHC.Show.Show (m (Data.Maybe.Maybe t)))
01:00:08 <lambdabot>    arising from a ...
01:00:29 <sshc> > fromJust $ (return Nothing) >> (return $ Just 3)
01:00:30 <lambdabot>   Just 3
01:00:50 <byorgey> > Nothing >> Just 3
01:00:51 <lambdabot>   Nothing
01:01:01 <byorgey> > Just 4 >> Just 3
01:01:02 <lambdabot>   Just 3
01:01:19 <byorgey> see, the value '4' is ignored, but the possibility of failure is not ignored
01:01:25 <sshc> how does that work without return?
01:01:36 <byorgey> sshc: for the Maybe monad,  return = Just
01:02:06 <centrinia> :t return Nothing
01:02:07 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a)
01:02:19 <sshc> so that was Just Nothing
01:02:22 <sshc> > Just Nothing
01:02:23 <lambdabot>   Just Nothing
01:02:31 <centrinia> :t Just Nothing
01:02:32 <lambdabot> forall a. Maybe (Maybe a)
01:02:33 <byorgey> sshc: right, you had two levels of Maybe
01:03:10 <sshc> how does the Maybe monad not ignore the possibility of failure?
01:03:41 <sshc> I can't find the implementation in Data.Maybe on Hoogle
01:03:48 <centrinia> @src Maybe
01:03:48 <lambdabot> data Maybe a = Nothing | Just a
01:03:52 <centrinia> There. :p
01:04:04 <byorgey> sshc: if Nothing ever shows up in a Maybe computation --- whether it comes before >> or not --- the entire computation will fail.
01:04:09 <centrinia> Anyway, Nothing >>= \x -> f x = Nothing
01:04:39 <sshc> where can I see how the Maybe monad is defined?
01:04:52 <FunctorSalad> grep the ghc source? ;)
01:04:54 <byorgey> @src Maybe return
01:04:54 <lambdabot> return              = Just
01:04:58 <byorgey> @src Maybe (>>=)
01:04:58 <lambdabot> (Just x) >>= k      = k x
01:04:58 <lambdabot> Nothing  >>= _      = Nothing
01:05:03 <byorgey> there =)
01:05:06 <FunctorSalad> ah yes, some things lambdabot does have
01:06:24 <sshc>     (Just _) >>  k      = k
01:06:24 <sshc>     Nothing  >>  _      = Nothing
01:06:35 <sshc> that makes sense
01:07:22 <byorgey> sshc: yep, exactly
01:08:26 <sciolizer> instance Functor [(Id,a)] where f `fmap` env = map (\(i, t2) -> (i, f t2)) env
01:08:31 <sciolizer> gives Kind mis-match
01:08:33 <FunctorSalad> btw I didn't mean to sound snarky... I was interpreting the question more as "what is a general method for looking up definitions of base items"
01:08:34 <sshc> I think the implementation allowed for any monad is more flexible than I thought it were
01:08:36 <FunctorSalad> :)
01:09:04 <sciolizer> I can fix it with a newtype
01:09:04 <sciolizer> But is there another way?
01:09:31 <Saizan> sciolizer: no
01:12:33 <Saizan> you can use (fmap.fmap) though
01:12:33 <sciolizer> Saizan: k. Thanks
01:18:51 <Phyx-> hi, quick question, in 6.12 what has {-# INCLUDE "" #-} been replaced by?
01:19:08 <Phyx-> it's saying Warning: -#include is deprecated: No longer has any effect
01:24:53 <Phyx-> guess no one knows
01:24:54 <dcolish> does a graphics library currently exist that allows me to render a data stream rather than static data?
01:25:55 <chrisdone> have we got a lengthsEq :: [a] -> [a] -> Bool function in a package anywhere? kind of defining it myself a lot
01:26:03 <chrisdone> @hoogle [a] -> [a] -> Bool
01:26:04 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
01:26:05 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
01:26:05 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
01:26:16 <mauke> ((==) `on` length)
01:26:22 <napsy> Hi. Any ideas why my code doesn't compile. I'm trying to write a function that will convert my data to a string http://haskell.pastebin.com/m76cc89b2
01:26:42 <chrisdone> mauke: sorry, one that will work if one is an infinite list
01:26:54 <chrisdone> i.e. one that can save time
01:27:37 <eivuokko> So you know one is finite, but don't know which?
01:27:46 <eivuokko> Curious.
01:28:07 <chrisdone> well it's kind of irrelevant, it's more "they're different lengths, no point computing the length of the longer one"
01:28:42 <Twey> Yeah… we need a better abstraction capable of combining those
01:28:56 <eivuokko> Hm.
01:29:06 <mauke> zipEx :: [a] -> [b] -> ([(a, b)], [a], [b])
01:29:16 <eivuokko> (I have no answer, just find it curious situation)
01:29:45 <ertai_> having a lengthCoNat :: [a] -> CoNat function and then comparing the length will do it
01:29:55 <ertai_> ((==) `on` lengthCoNat)
01:30:30 <chrisdone> ertai_: clever
01:30:36 <mauke> > ((==) `on` (genericLength :: [a] -> Natural)) [0 ..] [1 .. 10]
01:30:37 <lambdabot>   False
01:30:46 <chrisdone> (+) for natural is lazy?
01:30:47 <mauke> > ((==) `on` (genericLength :: [a] -> Natural)) [0 .. 9] [1 .. 10]
01:30:48 <lambdabot>   True
01:30:57 <chrisdone> and (==)
01:31:28 <napsy> Can someone please help me.
01:32:00 <reltuk> napsy looking now
01:32:12 <napsy> ok thanks
01:32:32 <mauke> napsy: because main can't be a String
01:32:45 <mauke> also because ("Joe" "Harmful" 2) is not a Person
01:33:08 <reltuk> main = print (Person "Joe" "Harmful" 2)
01:33:26 <mauke> no instance for Show Person, required by print
01:33:35 <reltuk> hah, nope, putStrLn (personToString ...)
01:33:59 <FunctorSalad> . o O ( -XOverloadedStrings )
01:34:08 <chrisdone> well Naturals are now officially awesome according
01:34:14 <reltuk> mauke yes, just when I went to write that for some reason I reverted to thinking we'd have a show instance :-p
01:34:27 <osaunders> napsy: What's the error?
01:34:38 <napsy> just a sec
01:34:41 <chrisdone> class IsString a where
01:34:42 <chrisdone>     fromString :: String -> a
01:35:03 <mauke> type error in ("Joe" "Harmful" 2), inferred type [Char] doesn't match expected type [Char] -> a -> b
01:35:29 <reltuk> how can I get profiler output that isn't CAF in every category?
01:35:59 <chrisdone> FunctorSalad: I guess IsString is a pretty neat way to do limited meta programming
01:36:45 <FunctorSalad> chrisdone: s/neat/crazy/ ;)
01:36:51 <chrisdone> FunctorSalad: or at least a nice way of describing values quickly
01:37:36 <FunctorSalad> chrisdone: one disadvantage is that validity is only checked at compile time, though
01:37:43 <FunctorSalad> *run time
01:38:27 <chrisdone> FunctorSalad: yeah, but there are strings like printf or regexen etc that are runtime checked anyhoo
01:39:01 <canoz> hey, im starting out with haskell and im wondering if someone could recommend a text editor.
01:39:07 <canoz> except notepad ofcourse
01:39:12 <chrisdone> instance IsString Regex where fromString = toRegex (or w/e)
01:39:30 <mauke> I use vim
01:39:40 <SamB_XP> canoz: I'd suggest vim or emacs
01:39:48 <chrisdone> canoz: vim, emacs, visual studio
01:39:57 <SamB_XP> except I'm not sure I'd recommend Emacs on Windows
01:40:17 <chrisdone> I use emacs on windows jerst fine
01:40:29 <canoz> hmm alright, thanks. ill take a look at them
01:40:32 <FunctorSalad> chrisdone: but I think it's still better to get a compile-time printf error :)
01:40:35 <FunctorSalad> (printf-th does it)
01:40:41 <OscarZ> I'm trying to think of the benefits of "pure functional" programming vs the OO paradigm..
01:40:43 <SamB_XP> chrisdone: what variant ?
01:40:50 <FunctorSalad> say the faulty format string is in a rarely executed program part..
01:40:51 <Phyx-> canoz: notepad++
01:40:52 <chrisdone> SamB_XP: ntemacs or emacs-w32
01:41:00 <SamB_XP> OscarZ: well, the paradigm is a great deal more well defined ;-P
01:42:11 <SamB_XP> FunctorSalad: even GCC does that, and maybe MSVC also?
01:42:18 <OscarZ> back then OO was great when coming from the C world, eg. when methods were attached to objects and objects only saw what was relevant to them
01:42:29 <FunctorSalad> SamB_XP: with printf? didn't know..
01:42:29 <chrisdone> SamB_XP: I use this at work http://www.ourcomments.org/Emacs/EmacsW32.html
01:42:43 <SamB_XP> of course, GCC has a hardcoded notion of what the format string means ...
01:42:55 <SamB_XP> FunctorSalad: well, warnings anyway
01:43:09 <FunctorSalad> you mean it detects printf and its argument syntactically right?
01:43:15 <FunctorSalad> in general it's impossible, obviously
01:43:22 <SamB_XP> FunctorSalad: obviously, yes
01:43:24 <FunctorSalad> (to check the format str statically)
01:44:32 <SamB_XP> but you can manage it for at least the fixed-format-string direct calls, of course
01:47:20 <dbrock> OscarZ: side-effect-free modules are useful for managing complexity whatever the paradigm or language you're using
01:48:44 <SamB_XP> FunctorSalad: you can extend the checks to your own printf-based functions, as well: http://unixwiz.net/techtips/gnu-c-attributes.html
01:49:07 <chrisdone> could you define printf in terms of CPS and combinators?
01:49:14 <FunctorSalad> SamB_XP: neat
01:49:22 <chrisdone> so that it would type check and be short
01:49:34 <SamB_XP> chrisdone: what the heck ?
01:49:51 <SamB_XP> C doesn't support any of that ;-P
01:49:58 <chrisdone> in haskell
01:50:12 * chrisdone zoom
01:50:30 <SamB_XP> Haskell doesn't have dependant types, so you can't do type-safe printf without TH
01:50:57 <FunctorSalad> maybe he means having functions for each of "%s" "%i" and so on
01:51:12 <FunctorSalad> but that would be considerably longer
01:51:12 <chrisdone> yeah I do
01:51:23 <chrisdone> P.s P.i
01:51:25 <chrisdone> if P is a module
01:51:25 * SamB_XP tries to remember whether GCC optimizes based on the "noreturn" attribute
01:51:38 <osaunders_> Can you define types that constrain lists to certain sizes?
01:51:39 <mauke> chrisdone: then what's the point in using this "printf"?
01:52:22 <FunctorSalad> osaunders_: uh yeah, but it's getting into type system abuse territory
01:52:32 <OscarZ> dbrock: but in OO you can shield the state "you need" in local variables or such and the user of the library never has to worry about side-effects..
01:52:35 <FunctorSalad> (you use type-level integers)
01:52:57 <FunctorSalad> osaunders: there are some lib on hackage
01:53:00 <FunctorSalad> *libs
01:53:04 <osaunders> FunctorSalad: OK, I don't think I want to do anything esoteric here.
01:53:20 <OscarZ> im not sure i understand how monads can get you out of the side effects from eg. IO operations
01:53:20 <mauke> OscarZ: then why do so many list classes have an append method?
01:53:30 <mauke> also, monads can't
01:54:00 <SamB_XP> OscarZ: they don't get you out of them
01:54:24 <SamB_XP> they only remove the "side"
01:54:29 <SamB_XP> making them simply "effects"
01:55:51 <OscarZ> mauke: true about append.. it feels to me as OO programmer perfectly natural to alter the state this way... if it was List newList = oldList.Append(item); it would be better ?
01:56:20 <mauke> yes, because then I don't have to worry about who else is still holding on to oldList
01:56:20 <OscarZ> SamB_XP: can you elaborate that
01:56:34 <SamB_XP> in fact, you don't even need monads to get rid of the "side" from side effect
01:56:36 <FunctorSalad> SamB_XP: good formulation
01:56:47 <FunctorSalad> ("remove the \"side\"")
01:57:20 <SamB_XP> you *could* just have an IO-performing program be a function from a lazy list of answers to a lazy list of questions
01:57:43 <c_wraith> SamB_XP: that's very nearly what haskell's initial IO model was
01:57:46 <SamB_XP> where the RTS reads the list of questions and passes in the answers after it reads each question ;-P
01:57:52 <SamB_XP> c_wraith: I know ;-)
01:58:06 <mauke> or you could have an IO performing program by constructing values that represent actions
01:58:25 <mauke> with callbacks into pure code to control flow
01:58:45 <OscarZ> when talking about interfaces in java.. i guess java doesnt contradict haskell that much, haskell has the type definitions too
01:58:47 <SamB_XP> yes, we call that last technique "warm fuzzy things"
01:58:53 <mauke> I don't
01:58:57 <mauke> there's nothing inherently monadic about it
01:59:02 * SamB_XP is kidding
01:59:19 <SamB_XP> well, sort of
01:59:41 <OscarZ> but the implementation... seems that in haskell that get compressed somehow in the definition.. by means of recursions and other wizardry
01:59:45 <SamB_XP> I mean, sure, that doesn't have to be talking about Monadic IO, but it *could* be
02:00:11 <OscarZ> and i dont understand how to alter my thinking for that
02:00:20 <SamB_XP> OscarZ: I think IO was originally implemented as a library over the list of requests/list of responses
02:02:33 <bauchus> hi! a question about Text.XHtml. Example for ghci: showHtml $ hotlink "?a&b=1" (toHtml "test" )
02:02:39 <SamB_XP> OscarZ: just realize this: value produced by getChar is not returned by getChar, the only way to do anything with it is by binding it into another function ...
02:03:03 <bauchus> the result is something with <a href=\"?a&amp;b=1\">test</a></html>
02:03:27 <c_wraith> bauchus: showHtml rendes it as a full html document
02:03:29 <bauchus> this works in firefox, but the google-bot seems to have problems with it
02:03:31 <c_wraith> *renders
02:03:51 <chrisdone> bauchus: showHtmlFragment will show the fragment
02:03:54 <bauchus> the problem is &amp; in the url
02:04:12 <OscarZ> SamB_XP: i think you're on the right track.. i always think of the *result* and what to do with it..
02:04:14 <mauke> bauchus: no, that's in fact correct
02:04:14 <c_wraith> technically, that's correct
02:04:24 <bauchus> hm
02:04:48 <SamB_XP> bauchus: pretty sure the issue is that a URL is more than a query string ;-P
02:05:41 <c_wraith> I guess that URL should start with a '/'. at least then it would be a valid relative url
02:05:50 <bauchus> no it's not. my logfile shows a lot og http 500 errors because of google-bots queries
02:06:49 <bauchus> maybe the google-bot is too stupid
02:06:50 <SamB_XP> bauchus: so ?
02:06:59 <SamB_XP> bauchus: google bot just crawls your pages
02:07:17 <OscarZ> SamB_XP: but what if you require multiple results before the next function ?
02:07:32 <OscarZ> ok you can return an array
02:07:42 <bauchus> yes, but it asks for a url like "/?a&amp;b=1" and my program cannot read the cgi variable b
02:08:19 <SamB_XP> CGI?
02:09:04 <bauchus> yes CGI
02:09:08 <SamB_XP> oh, your program is providing the URL / ?
02:09:22 <SamB_XP> er. well, http://host.name/ ?
02:09:35 <bauchus> not, it starts directly with "?"
02:09:38 <OscarZ> does "/?a=&amp;b=1" work ?
02:09:58 <bauchus> no
02:11:01 <Kim^Walkman> That's an odd query string…
02:11:07 <reltuk> ok, I've got a program that simulates a card game
02:11:18 <reltuk> and there are different types of cards
02:11:37 <SamB_XP> bauchus: I mean, when you type that url in your browser, your program runs ?
02:11:52 <reltuk> the card types themselves have functions as parts of their data
02:12:11 <reltuk> so in order to make everything printable, I pass around a disjoint type of CardNames
02:12:11 <SamB_XP> (or is otherwise instructed to handle the request?)
02:12:33 <reltuk> and everywhere I need data about the actual card I'm working on, I call getCardByName
02:12:40 <joe_____> just trying to understand, how is writing a haskell program different from stringing together some shell utilities but for types and monads?
02:12:53 <bauchus> here is an real example: http://www.communitystory.de/?mode=loc&advid=38&init=1
02:12:55 <SamB_XP> joe_____: well, not so different really
02:12:56 <bauchus> this works
02:13:01 <reltuk> the cards all inserted into a map and getCardByName looks them up in
02:13:13 <SamB_XP> except we have better support for multi-parameter functions, i guess
02:13:28 <SamB_XP> but types are a really nice thing!
02:13:32 <bauchus> but with http://www.communitystory.de/?mode=loc&amp;advid=38&init=1
02:13:34 <SamB_XP> oh, and typeclasses are cool too
02:13:37 <bauchus> it doesnt work
02:13:52 <SamB_XP> bauchus: of course not
02:13:56 <reltuk> but the program spends a significant part of its time looking these things up...are there any alternatives other than make everything work with Cards instead of CardNames?
02:14:19 <SamB_XP> bauchus: are you saying that if you click on the link in the HTML, it takes you to the latter URL ?
02:14:22 <bauchus> an google-bot asks for such urls. why? because it sees it in my pages.
02:14:32 <bauchus> clicking works fine
02:14:40 <SamB_XP> also, are you sure this is the REAL google bot ?
02:14:43 <SamB_XP> check the IP addresses
02:14:58 <SamB_XP> it could some bad robot impersonating goooglebot ...
02:15:35 <joe_____> SamB_XP: thanks. I am not trying to put haskell down. I like it but am trying to improve my understanding. Hasn't someone thought about types and typeclasses at a shell level?
02:15:38 <c_wraith> that's a good point.  I've seen very badly written bots that claim to be googlebot
02:15:42 <SamB_XP> hmm, I think you can look up IP addresses on some tool on ARIN's website to see whose they are?
02:15:55 <bauchus> ip 66.249.71.5 looks good:
02:15:57 <c_wraith> google actually publishes the IPs they spider from
02:17:11 <mauke> I've just found out that TH printf is less nice than expected
02:17:35 <kmc> how so?
02:18:02 <mauke> it has to turn into a fixed type thing based on the format string alone
02:18:41 <SamB_XP> mauke: it wouldn't HAVE to be fixed-type
02:18:51 <SamB_XP> it could use typeclasses for the various format types
02:18:56 <mauke> haskell has no way to write a type of Integer|Double or Char|Int
02:18:56 <SamB_XP> right ?
02:19:04 <mauke> hmm
02:19:09 <Twey> Either?
02:19:09 <SamB_XP> well, that's what typeclasses are for, of course
02:19:30 <ClaudiusMaximus> share my GADT and type family pain..   http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5270#a5270  is there any way to achieve that goal?
02:19:32 <mauke> ... with tons of instances and potentially confusing error messages
02:19:37 <SamB_XP> I mean surely you can do at least as well as Python's % operator that way...
02:19:38 <mauke> but yes, that's not worse than what I have now
02:19:42 <mxyz> has anyone installed c2hs on windows?
02:20:03 <SamB_XP> well, okay, *almost* as well
02:20:15 <SamB_XP> you can't do what they do for %s, really
02:20:43 <mauke> what does python do with %s?
02:20:48 <mxyz> c2hs seemed to install fine but when i try to install a package that needs it i get "cabal: The program c2hs is required but it could not be found"
02:21:11 <kmc> call str() on the arg
02:21:11 <kmc> yeah, it could turn %d into a rank-2 arg of type (forall n. (Num n) => n)
02:21:31 <kmc> %s could be (forall x. (Show x) => x)
02:21:37 <mauke> kmc: that breaks String
02:22:13 <mauke> kmc: and how do you display a random Num in decimal?
02:22:24 <joe_____> is there a way to run a haskell program from ghc as a "sh -xvce" ?
02:22:40 <mauke> what's an xvce?
02:22:51 <joe_____> with basicall more debugging
02:22:56 <joe_____> v: verbose
02:23:24 <joe_____> every functions' inputs and outputs/error?
02:23:49 <Berengal> joe_____: ghc -e '<program here>'
02:24:06 <Berengal> -v adds verbosity
02:25:37 <OscarZ> joe_____: I too have strong intuition that understanding Haskell would really make me understand the semantics of programming languages better.. I have a feeling that with imperative languages I am canoeing with bare hands in my humble boat in the seas of semantics.. im trying to think of the typical situations in imperative programming that i find particularly difficult to map to functional domain..
02:26:18 <kmc> haskell is an imperative language
02:26:25 <mxyz> canoeing with bare hands? is someone trying to make the newsletter? :)
02:26:59 <c_wraith> haskell's certainly not an OO language :)
02:27:14 <kmc> yeah
02:27:21 <joe_____> Berengal, just read about -e and will try it out.
02:27:33 <kmc> haskell has features specifically for imperative programming, and none specifically for OO
02:27:43 <kmc> but you can do OO programming in Haskell if you try hard, just as you can do it in C
02:27:59 <OscarZ> kmc: what do you mean by haskell is an imperative language?
02:28:03 <c_wraith> It'd be clumsy....  much like C
02:28:18 <shambler> more clumsy imo
02:28:45 <OscarZ> mxyz: forgive me.. ive had some red wine ;)
02:29:59 <c_wraith> at least haskell has currying, which would be similar to binding objects to their type polymorphically
02:31:01 <chrisdone> well I just learned about GADTs
02:31:02 <chrisdone> nice
02:32:59 * hackagebot upload: readline-statevar 1.0.1.0 - Readline with variables (setX/getY) wrapped in state vars (KrzysztofSkrzetnicki)
02:34:33 <OscarZ> How are things like the typical event model in GUI applications done in Haskell?
02:34:49 <jmcarthur> OscarZ: usually the same way as in C, callbacks and such
02:34:59 <jmcarthur> OscarZ: that's because most of our GUI stuff is bindings to C libraries
02:35:02 <mxyz> do i have to add c2hs to the system path or anything?
02:35:12 <OscarZ> usually you have a some sort of "work queue" that processes things sequentially triggered by events from the user interface
02:35:15 <jmcarthur> OscarZ: there are several more declarative GUI libraries, but i would not call them full featured
02:35:32 <muri_one> Is it possible to do an import of specific functions in ghci?
02:35:47 <CalJohn> @hoogle m (a -> b) ->  m [b]
02:35:48 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
02:35:48 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
02:35:48 <lambdabot> Data.Data gmapQ :: Data a => (d -> u) -> a -> [u]
02:35:49 <muri_one> :m +Module.Name(func) doesn't seem to work
02:36:11 <c_wraith> muri_one: no, ghci doesn't allow that
02:36:22 <OscarZ> hmm ok..
02:36:32 * CalJohn wishes there was a repeatM
02:36:42 <jmcarthur> :t k >>= liftM
02:36:44 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
02:36:44 <lambdabot>     In the first argument of `(>>=)', namely `k'
02:36:44 <lambdabot>     In the expression: k >>= liftM
02:36:53 <CalJohn> @djinn m (a -> b) ->  m [b]
02:36:53 <lambdabot> Error: Undefined type []
02:36:56 <muri_one> Is there a better shell than ghci :)
02:37:19 <kmc> OscarZ, i mean that it has features for imperative programming
02:37:19 <jmcarthur> oh duh
02:37:29 <kmc> better features than most languages, because imperative actions are first-class
02:37:40 <c_wraith> muri_one: you can get the same effect by using :load on a file with the imports you want
02:37:49 <kmc> it's also of course a functional language
02:37:55 <muri_one> c_wraith: ah, cool thanks
02:37:56 <kmc> the opposite of "functional" is not "imperative"
02:38:01 <kmc> the opposite of "functional" is "dysfunctional"
02:38:13 <jmcarthur> CalJohn: what exactly is that type supposed to mean?
02:39:21 <CalJohn> @t repeat
02:39:22 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
02:39:29 <CalJohn> @type repeat
02:39:31 <OscarZ> what if eg. we have a main window which has some "global" fields (call one global state X).. you can launch multiple "sub" windows from there using that use that global state X and while these windows are closed they use the global state X to do their thing... global state X can be changed from any of these subwindows
02:39:31 <lambdabot> forall a. a -> [a]
02:39:37 <mxyz> now im getting: "c2hs.exe: does not exist "
02:39:46 <CalJohn> oh, my mistake
02:39:51 <mxyz> how can it not exist if i just added it to the path. grr!
02:39:53 <OscarZ> lets assume it would make sense to make the user interface like this
02:40:01 <CalJohn> @hoogle m a -> m [a]
02:40:02 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
02:40:02 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
02:40:02 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
02:40:21 <jmcarthur> :t pure . repeat
02:40:22 <lambdabot> forall (f :: * -> *) a. (Applicative f) => a -> f [a]
02:40:25 <OscarZ> is it somehow possible "simulate" this sort of state?
02:40:34 <jmcarthur> :t liftM repeat
02:40:35 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1]
02:40:43 <jmcarthur> OscarZ: what state?
02:40:50 <aavogt> :t sequenceA . repeat
02:40:51 <lambdabot> Not in scope: `sequenceA'
02:41:01 <aavogt> :t Data.Traversable.sequenceA . repeat
02:41:02 <lambdabot> forall (f :: * -> *) a. (Applicative f) => f a -> f [a]
02:41:24 <OscarZ> jmcarthur: the global state X i mentioned in my rant
02:41:28 <jmcarthur> OscarZ: you mean you want the side effect to be performed infinitely?
02:41:56 <aavogt> @src many
02:41:56 <lambdabot> Source not found. It can only be attributed to human error.
02:41:56 <OscarZ> jmcarthur: im not sure what you mean
02:42:01 <jmcarthur> OscarZ: i must not have been here for your rant
02:42:41 <jmcarthur> OscarZ: if you generate an infinite list of values with side effects and you want those side effects then you are wanting infinite side effects
02:43:31 <jmcarthur> (depending on the monad it might not actually become ⊥ though)
02:44:41 <OscarZ> jmcarthur: i tried to describe a GUI scenario where we have launched multiple windows (i assume these are function evaluations).. and these windows have a "submit" button and what happens depends on some "global" state that can change based on user interactions _after_ the sub windows are created
02:45:13 <kmc> OscarZ, are you talking about some particular GUI framework or in general?
02:45:25 <OscarZ> kmc: in general in Haskell
02:45:30 <jmcarthur> OscarZ: your scenario already assumes global state, so i think it only natural that you would find difficulty with this
02:45:40 <kmc> OscarZ, in general you don't have to "simulate" state, an IORef is a real mutable variable
02:45:48 <kmc> and there are many other flavors of such things
02:46:23 <jmcarthur> OscarZ: it sounds like you are looking for some flavor of FRP though :)
02:46:36 <kmc> and what do you mean that launching a window is a function evaluation?
02:47:01 <c_wraith> @hoogle interleave
02:47:01 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
02:47:01 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
02:47:01 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
02:47:02 <OscarZ> i dont really know how it is done in haskell..
02:47:14 <OscarZ> jmcarthur: what is FRP ?
02:47:24 <jmcarthur> OscarZ: like i said, most of our common GUI libraries are just imperative C bindings
02:47:34 <jmcarthur> OscarZ: FRP = functional reactive programming
02:47:36 <kmc> OscarZ, in Haskell, evaluating a function application never has a side effect
02:48:25 <pikhq> In Haskell, there is no state. There are no side effects.
02:48:29 <pikhq> There is only lambda.
02:48:29 <SamB_XP> OscarZ: unless you chose libraries written by an absolute lunatic that break the rules
02:49:20 <kmc> "side effect recipes" and "functions" are two orthogonal datatypes.  a function can of course return a side-effect recipe, which makes it a little bit like a side-effectful function.  but really it's always two separate rules: pure evaluation of functions, followed by execution of the resulting side effect
02:50:30 <aavogt> but where do the side effects named in the recipe come from?
02:50:37 <aavogt> if everything is otherwise pure?
02:50:50 <jmcarthur> nowhere
02:50:52 <c_wraith> FFI, clearly.
02:50:53 <jmcarthur> they are just named
02:50:56 <c_wraith> :)
02:50:59 <kmc> they're built by gluing together smaller side effects
02:51:03 <monochrom> they come from sufficiently advanced technology
02:51:15 <SamB_XP> where do the shell primitives come from ?
02:51:18 <kmc> and there are some built-in ones
02:51:23 <kmc> :t getChar
02:51:25 <lambdabot> IO Char
02:51:26 <reltuk> there is a thread in the runtime that executes them?
02:51:29 <aavogt> exactly, you're just hiding the ugliness of FFI  / unsafeperformio
02:51:36 <kmc> reltuk, not a separate thread
02:51:48 <jmcarthur> @src getChar
02:51:48 <lambdabot> getChar = hGetChar stdin
02:51:54 <jmcarthur> not primitive ;)
02:52:12 <kmc> reltuk, that's an implementation question
02:52:16 <reltuk> kmc: I thought I read a bug where the io thread got killed after a fork or something and then the process was essentially useless...
02:52:29 <jmcarthur> @src hGetChar
02:52:29 <reltuk> kmc: ah yes, implementation =/
02:52:29 <lambdabot> Source not found. That's something I cannot allow to happen.
02:52:40 <kmc> ghc doesn't even use multiple threads by default
02:52:47 <osaunders> Is there a shorthand for exporting everything in a module?
02:52:50 <jmcarthur> well, there is actually some primitive wrapping going on in there
02:53:18 <kmc> reltuk, in my understanding with ghc the semantic separation of evaluation and side effects disappears in the compiled code
02:53:22 <c_wraith> reltuk:  well, "threads" created by forkIO won't prevent program termination if the main "thread" quits.  (the threads in question are green threads, not OS threads)
02:53:28 <kmc> and what you get looks very much like imperative code
02:54:22 <reltuk> maybe I misunderstand...http://hackage.haskell.org/trac/ghc/ticket/1185
02:54:25 <OscarZ> i dont understand how it works.. i understand that you can have callbacks like in C... but if these callbacks map to haskell functions and one of the parameters to the haskell callback function is supposed to be the "global state"
02:54:38 <reltuk> I agree that without -threaded there is only one thread though :-)
02:54:39 <OscarZ> it would be "breaking the rules" right ?
02:54:42 <jmcarthur> OscarZ: these would be IO functions
02:54:44 <aavogt> kmc: which point of compilation? asm, C, core?
02:54:45 <kmc> OscarZ, the callbacks map to haskell *side-effect recipes*
02:54:47 <kmc> not to functions
02:55:00 <jmcarthur> yeah, i should say IO actions
02:55:09 <kmc> or sometimes they map to functions which yield IO actions
02:55:16 <jmcarthur> or most precisely, functions which result in IO actions
02:55:19 <jmcarthur> yes that
02:55:42 <kmc> if you don't have any arguments they will just be actions -- there's no such thing as a zero-argument function in haskell (or in maths)
02:56:12 <OscarZ> kmc: ok.. so i should look into side-effect recipes ?
02:56:19 <jmcarthur> that was a metaphor
02:56:20 <kmc> OscarZ, do you know Haskell already?
02:56:25 <jmcarthur> *analogy?
02:56:29 <kmc> an alternate name
02:56:34 <OscarZ> kmc: no.. just the very basics
02:56:38 <kmc> OscarZ, the thing to read about would be the IO monad
02:56:41 <jmcarthur> OscarZ: just keep learning
02:56:45 <kmc> but the IO monad is not a good place to start learning monads in general
02:56:46 <OscarZ> im just trying to understand how things are done in the functional domain
02:56:46 <jmcarthur> you'll figure it out
02:56:56 <jmcarthur> ignore IO for now
02:57:02 <kmc> OscarZ, Haskell is abnormal among functional languages
02:57:12 <jmcarthur> kmc: it shouldn't be though
02:57:17 <kmc> in Scheme or ML or F# you would just write a function with side effects
02:57:31 <|Jedai|> just learn enough IO that you can print your results (or just use GHCi) for now
02:58:29 <OscarZ> ok.. so you think i should go and try to make simple programs using the IO ?
02:58:31 <reltuk> if you actually start writing programs then you will eventually come to a place where you can figure it out when you have a problem
02:58:34 <kmc> OscarZ, no
02:58:38 <kmc> you should make simple functions first
02:58:40 <kmc> and test them in GHCi
02:58:47 <OscarZ> reltuk: you are probably right
02:58:49 <|Jedai|> OscarZ: Haskell is a purely functional language, those are very rare in that they don't allow side-effect at all in normal code rather than just discouraging them like most other functional languages
02:58:49 <jmcarthur> OscarZ: i think you should just follow a haskell tutorial
02:59:20 <jmcarthur> @where lyah
02:59:20 <lambdabot> http://www.learnyouahaskell.com/
02:59:22 <jmcarthur> @where rwh
02:59:23 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:59:30 <jmcarthur> in that order
02:59:51 <kmc> OscarZ, once you understand how to write Haskell functions, and declare your own types with "data", and work with typeclasses using "class" and "instance".... THEN you should read about the typeclass named "Monad".  and learn to use some simple monads like Maybe and the list.  and *THEN* learn IO.
03:00:01 <kmc> :)
03:00:20 <c_wraith> reltuk: interesting.  Looks like the RTS does indeed use some sort of green thread to manage IO
03:00:22 <kmc> aavogt, i think GHC implements evaluation order for its IO-monad "primitives" in terms of carefully pattern-matching (to force) on values containing a State# RealWorld
03:00:57 <OscarZ> in imperative programming ive normally tried some things on my own... failed... did things differently, maybe had some insights... read about design patterns... realized how elegantly they capture some sub-problems.. started using them.. etc..
03:01:09 <OscarZ> here i find it hard to get started
03:01:14 <jmcarthur> OscarZ: haskell requires a somewhat disciplined approach, is all
03:01:16 <c_wraith> preflex: seen igloo
03:01:17 <preflex>  igloo was last seen on #ghc 2 hours, 30 minutes and 8 seconds ago, saying: pejo: Unlikely
03:01:22 <gwern> @quote emit
03:01:23 <lambdabot> gwern says: wonder what a co-human would be like. would it consume feces and emit steak? you could put a human and a co-human in a circle then
03:01:30 <jmcarthur> OscarZ: just follow the path set before you and it's mostly gravy :)
03:01:30 <|Jedai|> kmc: Right, IO is just an ST without the higher order polymorphism, they use the same primitives
03:01:31 <gwern> @quote emit.a
03:01:32 <lambdabot> No quotes match. I am sorry.
03:01:36 <gwern> argh
03:01:42 <gwern> @quote emission
03:01:43 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
03:01:45 <aavogt> heh
03:01:52 <jmcarthur> i like that one
03:02:09 <gwern> it's very true, and a good example for OscarZ
03:02:10 <jmcarthur> should have qualified that it's a one-line fold expression though
03:02:26 <gwern> jmcarthur: well, of course. anything else would be bad style
03:02:57 <jmcarthur> i will often even write out a many-line implementation of a function, then stare at it and meditate until in a final "aha" moment i rewrite the thing as a composition of two or three simple functions
03:02:59 <blazzy> Text.Regex has the handy subRegex function. Is there equivalent functionality in Text.Regex.TDFA?
03:03:12 <|Jedai|> OscarZ: try to do Euler problems maybe, many beginners in Haskell have found that it is quite nice to try its hand
03:03:28 <kmc> OscarZ, "design patterns" are something to be avoided.  they're usually a symptom that the language has failed to abstract something sufficiently, and is making you do it
03:03:37 <jmcarthur> project euler is a great way to learn list comprehensions
03:03:37 <OscarZ> you guys probably come from C/OO background too.. maybe you can give me some tips what helped you the most to get rid of the imperative thinking?
03:03:48 <kmc> take 250 mcg LSD
03:03:54 <reltuk> OscarZ: actually writing programs...
03:03:59 <kmc> ideally your code should have no patterns that aren't in the problem you're solving
03:04:02 <OscarZ> kmc: interesting..
03:04:09 <jd10> kmc: =)
03:04:20 <jmcarthur> OscarZ: just learn the language, *then* worry about solving problems with it
03:04:23 <kmc> in Haskell we have patterns as well, but i think more people see them as flaws and not something to celebrate and make a career out of writing books about
03:04:31 <|Jedai|> Don't listen to kmc... and try to write some code to resolve small practical problems
03:04:43 <kmc> remember that half of the standard OO design patterns are actually just canonical workarounds for flaws with C++
03:04:44 <jmcarthur> OscarZ: we can speak more clearly about design issues once there is an understanding of terminology and semantics
03:04:49 <kmc> they're not even present in other OO languages
03:04:59 <monochrom> design patterns in other languages become libraries or typeclasses in haskell.
03:05:05 <|Jedai|> OscarZ: After a good tutorial (lyah is nice or so I've heard)
03:05:10 <kmc> monochrom, or just functions
03:05:25 <shambler> LSD is illegal ;(
03:05:29 <gwern> OscarZ: the thing I found helpful was solving small problems purely, driving them from ghci, and only once all the algorithmic guts were done, did I start tearing hair out to get IO working etc
03:05:38 <monochrom> The command pattern is trivial.
03:05:54 <kmc> shambler, yeah... the general idea is to ban the safe drugs so people take unsafe ones
03:06:13 <shambler> like alcohol?
03:06:15 <|Jedai|> OscarZ: Yeah, listen to gwern... :)
03:06:23 <kmc> yeah
03:06:39 <OscarZ> you guys are right.. i have just been lazy and arrogant to think that i'd just "get it" without any real work just because i think im "pretty fluent" in some OO languages
03:06:53 <|Jedai|> kmc: I don't think LSD is exactly "safe" anyway...
03:07:17 <kmc> |Jedai|, relative to the designer hallucinogens created to replace it
03:07:36 <kmc> and yes it's safe on a physical level -- this is well documented
03:07:38 <kmc> anyway o/t
03:07:39 <nagnatron> It's probably safe if you don't have anything to kill yourself with, like a balcony for example.
03:07:45 <kmc> OscarZ, Haskell is very different from almost any other language people use
03:08:00 <trofi> ocaml?
03:08:02 <gwern> true of any mind-altering drug - not having things around to kill yourself with helps
03:08:03 <kmc> yeah
03:08:06 <monochrom> Haskell's Monad typeclass is a design pattern that the design pattern community is unaware of and is recently making inroads to C#.
03:08:07 <kmc> very different from ocaml
03:08:25 * trofi scratches his head
03:08:28 <|Jedai|> OscarZ: getting used to functional programming after a life of imperative languages is quite hard, but definitely worth it (all those that have done the effort agree, even those that returns to their imperative roots afterward)
03:08:35 <gwern> I always had the impression that haskell and sml were fairly similar, but sml was older, and ocaml is a bastardization of sml
03:08:44 <OscarZ> maybe the problem is that ive been thinking my learning of programming languages as a kind of pyramid... thinking that Haskell is the next step.. but actually i need to step down and build again
03:08:46 <monochrom> Meanwhile, the Haskell community has moved on to even better design patterns such as the Applicative typeclass.
03:08:46 <trofi> same here
03:08:56 <kmc> haskell has non-strict semantics, typeclasses, etc
03:08:59 <kmc> vastly different syntax
03:09:03 <kmc> no first-class modules
03:09:11 <kmc> syntax for monads
03:09:12 <kmc> purity
03:09:20 <gwern> monochrom: maybe you have, I haven't!
03:09:31 <monochrom> In fact, I haven't either. :)
03:09:41 <kmc> |Jedai|, OscarZ, also remember that most good languages have functional features.  you can use your FP skills in Python or C# or especially Javascript
03:09:43 <Kim^Walkman> OscarZ: There's more than one pyramid, I prefer the haskell one
03:09:47 <kmc> (Javascript is the world's most popular functional language)
03:09:47 <|Jedai|> OscarZ: Right, it's just not the same pyramid, some foundations in common, that's all (and I can't help but think that Haskell's pyramid is quite higher than most other too)
03:09:48 <elly> 9/names
03:09:57 <elly> fail :(
03:10:26 <Kim^Walkman> OscarZ: Then again, that depends on the domain, but I picked up haskell this august and I love it. With this hammer everything *does* look like a nail.
03:10:37 <kmc> in fact i think any good high-level language should support first-class functions with lexical closure
03:10:48 <kmc> C gets a free pass because it's a low-level systems language and doesn't pretend to be anything else
03:10:59 <gwern> kmc: no, no, excel is!
03:11:09 <kmc> gwern, yeah, SPJ said that ;P
03:11:10 <gwern> don't you memorize everything the Simons write?
03:11:13 <OscarZ> its weird that i just have this feeling that i need to learn this without understanding it
03:11:19 <|Jedai|> kmc: some people still thinks it's not though...
03:11:24 <OscarZ> maybe this irc channel contributes too :)
03:11:35 <trofi> > 1+1
03:11:36 <lambdabot>   2
03:11:48 <monochrom> OscarZ: You learned numbers without understanding numbers. You can do it again.
03:11:49 <kmc> Go claims to be a low-level systems language and it has lexical closures
03:12:15 <|Jedai|> kmc: Right, but I'm not sure Go really is a low-level system language...
03:12:27 <OscarZ> monochrom: one of my problems is that im quite weak with numbers really..
03:12:29 <kmc> yeah their claim is dubious
03:12:37 <monochrom> Darn.
03:12:50 <|Jedai|> kmc: though I must say I don't see any reason a low-level system language couldn't have closures
03:12:53 <monochrom> OK, second try. You learned Chess without understanding Chess.
03:13:08 <|Jedai|> kmc: (apart from the GC I suppose...)
03:13:16 <kmc> OscarZ, you understand what numbers *are*.  doing arithmetic with them is a detail, best left to computers
03:13:19 <gwern> |Jedai|: probably imposes too much discipline on pointers and stacks and heaps as well as the gc issue
03:13:24 <kmc> |Jedai|, i agree, though they do become more cumbersome without gc
03:13:37 <kmc> you can still do it
03:13:44 <pikhq> I'd like to note that Apple C has closures.
03:13:47 <kmc> C++1x will have manually managed lexical closures
03:13:57 <|Jedai|> pikhq: Objective C ?
03:14:05 <kmc> no, Apple's extensions to c
03:14:09 <kmc> (but to objc and C++ as well)
03:14:25 <pikhq> Apple Objective C and Apple C++ and Apple Objective C++ all have it, as well...
03:14:28 <SamB_XP> I bet they copped the idea from that one ObjC compiler ...
03:14:31 <kmc> pikhq, no, it has blocks.  because everyone knows lambdas are useless egghead academic wankery, but blocks are enterprise-ready and industrial strength
03:14:32 <|Jedai|> kmc: Right, I remember thay call them "blocks", no ?
03:14:39 <gwern> if regions had worked out, a low=level region-using language would've been cool
03:14:50 <pikhq> kmc: Hahahah.
03:14:57 <SamB_XP> kmc: I think it's because they couldn't find the lambda key, actually
03:15:04 <OscarZ> kmc: i think i dont. I am able to formulate equations based on some problem and physical laws etc.. but i have very weak intuitive feeling of even the most basic number theoretical facts
03:15:07 <kmc> lambda is a lower case letter
03:15:22 <|Jedai|> SamB_XP: and the block letter is so much easier to find ?
03:15:23 <SamB_XP> kmc: there's also an uppercase one
03:15:35 <benmachine> Λ
03:15:36 <pikhq> Well, calling them blocks instead of lambda at least gets people to not assume garbage collection on them...
03:15:39 <SamB_XP> |Jedai|: they know that block isn't a letter, silly
03:15:51 <SamB_XP> also, there's the fact that ObjC is based on Smalltalk ...
03:16:19 <SamB_XP> and I expect they only support them in plain C/C++ because there's no reason not to
03:16:44 <kmc> also you do not need lambda to have lexical closure
03:17:01 <OscarZ> how are for example integers defined in Haskell... is it wrong to think that each number is own kind of beast, having their own data constructor... like data Integer = One | Two | ...
03:17:03 <pikhq> kmc: Yeah, lambda's merely the most common way of doing that.
03:17:09 <|Jedai|> OscarZ: Well axiomatic arithmetic is not essential to your understanding of Haskell so that shouldn't be too much of a problem
03:17:11 <OscarZ> i understand in practice it isnt so
03:17:15 <kmc> OscarZ, that's a reasonable conceptual model
03:17:22 <|Jedai|> OscarZ: that's a good model
03:17:27 <SamB_XP> OscarZ: I think the Haskell Report may even suggest thinking that way
03:17:29 <kmc> OscarZ, you can define your own natural numbers easily:  data Nat = Zero | Succ Nat
03:17:34 <trofi> @let three = 8
03:17:35 <lambdabot>  Defined.
03:17:43 <kmc> it's a good exercise to do that, then define the typeclass instances for Eq, Ord, Num, Integral, ...
03:17:49 <|Jedai|> OscarZ: in fact it's pretty much how they behave themselves (almost)
03:17:52 <kmc> > let 2 + 2 = 5 in 2 + 2
03:17:54 <lambdabot>   5
03:18:15 <osaunders> Is there a version of map that supplies a count int. So like map fn list [0..length list]?
03:18:23 <OscarZ> kmc: wow.. thats exactly the sort of thing im looking for
03:18:24 <|Jedai|> osaunders: use zipWith
03:18:35 <kmc> :t zipWith f [0..] [x,y,z]
03:18:37 <lambdabot> forall c. (SimpleReflect.FromExpr c) => [c]
03:18:38 <kmc> > zipWith f [0..] [x,y,z]
03:18:40 <lambdabot>   Ambiguous type variable `c' in the constraints:
03:18:40 <lambdabot>    `SimpleReflect.FromExpr ...
03:18:50 <OscarZ> why dont they teach that stuff in elementary school instead of apples and oranges ?
03:19:06 <kmc> well what if you work in a grocery store
03:19:13 <OscarZ> :D
03:19:18 <|Jedai|> > zipWith f [0..] [x,y,z::Expr] :: [Expr]
03:19:19 <OscarZ> touche
03:19:20 <lambdabot>   [f 0 x,f 1 y,f 2 z]
03:19:30 <SamB_XP> OscarZ: I guess they ran out of legos to teach it with ?
03:19:34 <osaunders> OK well I need to map over a 2d list.
03:19:49 <osaunders> So [0..] won't do.
03:19:53 <SamB_XP> they could use the flat-topped kind for zero, and one of the stud-topped kind for succ ;-P
03:20:06 <OscarZ> also.. ive been trying to learn category theory ;)
03:20:10 <|Jedai|> osaunders: I'm not sure I understand what you mean ?
03:20:20 <SamB_XP> (or maybe they're afraid the kids will eat the legos at that age ?)
03:20:47 <osaunders> |Jedai|: Let me think about this for a while.
03:21:07 <OscarZ> ran into a website about haskell and category theory
03:21:33 <OscarZ> and it seemed interesting.. working on a very meta- level of things...
03:21:33 <gwern> I wonder why oleg likes ocaml so much
03:21:57 <kmc> first-class modules?
03:22:01 <|Jedai|> gwern: I think he likes the functors, they are quite elegant
03:22:26 <monochrom> I like its types.
03:22:49 <monochrom> best static type for oo so far
03:22:51 <OscarZ> you guys have any good tips on what kind of exercises one should start learning Haskell and the functional thinking? any good websites or something ?
03:23:12 <kmc> OscarZ, read the tutorials
03:23:15 <kmc> do project euler problems
03:23:15 <|Jedai|> @where lyah
03:23:16 <lambdabot> http://www.learnyouahaskell.com/
03:23:22 <|Jedai|> @where euler
03:23:23 <lambdabot> http://projecteuler.net
03:23:42 <kmc> i learned from http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
03:23:52 <kmc> some good exercises there
03:24:00 <kmc> and links
03:24:05 <|Jedai|> OscarZ: when you have questions, just ask them here, #haskell is a really nice channel
03:24:18 <gwern> |Jedai|: but I don't think I see him use functors too often
03:24:22 <OscarZ> thanks guys
03:24:22 <gwern> he's all about continuations
03:24:23 <kmc> @botsnack
03:24:23 <lambdabot> :)
03:24:24 <lunabot>  :o
03:24:53 <monochrom> Then it is because it is much easier to add continuations to ocaml. He just did it.
03:25:49 <OscarZ> |Jedai|: yes ive noticed.. some really intelligent and also helpful people here... and for some reason the usual arrogant type is absent here :)
03:26:09 <OscarZ> compared to the regular programming irc channel
03:26:20 <akappa> OscarZ, because there are few engineers here :D
03:26:25 <gwndyllydd> Can anyone confirm that the haskell.org main site is down?
03:26:41 <mxyz> its up for me
03:26:46 <akappa> (I'm joking)
03:26:53 <OscarZ> akappa: you think? are most of the people mathematicians here? :)
03:26:54 <gwndyllydd> I can access hackage, but not the wiki or www.haskell.org
03:26:56 <gwern> monochrom: it's hard to have continuations in haskell?
03:27:02 <monochrom> All the arrogant types go to #math instead and say "programming is BS" there.
03:27:05 <gwndyllydd> mxyz: weird!
03:27:08 <shachaf> gwndyllydd: http://www.downforeveryoneorjustme.com/haskell.org
03:27:13 <osaunders> gwndyllydd: Up for me.
03:27:14 <shachaf> gwndyllydd: It seems fine to me.
03:27:24 <akappa> monochrom, ahah :D
03:27:34 <akappa> gwndyllydd, up'n'running
03:27:41 <akappa> gwndyllydd, check your DNS
03:27:59 <gwndyllydd> shachaf: nice one. i didn't knew such service existed.
03:28:17 <reltuk> gwern: is it hard to have continuations?
03:28:25 <gwndyllydd> akappa: i
03:28:27 <gwern> I didn't think it was
03:28:29 <|Jedai|> OscarZ: I don't think so, but there probably is a stronger proportion of academics (and not of the asshole variety curiously)
03:28:30 <gwndyllydd> 'll try
03:28:43 <gwndyllydd> thanks everyone
03:28:50 <gwndyllydd> i'll be back later.
03:29:20 <mxyz> anyone know how to configure c2hs on windows?
03:29:37 <akappa> OscarZ, not only that, but here the people loves the theoretic-centered talk, which is a definitively selling point :)
03:29:40 <Saizan> well, for "first-class" continuations you need compiler/interpreter support, but they are also impure
03:30:30 <Saizan> we've a few monads for [un]delimited continuations though
03:30:30 <|Jedai|> OscarZ: There are some engineers too, but the fact that they tried Haskell at all already demonstrate an open mind, so that weed out a lot of the disagreeable ones ;)
03:30:31 <mxyz> saizan: or you can just right in cps right?
03:30:46 <mxyz> right -> write
03:31:14 <OscarZ> akappa: yes.. ive always been more interested in the more philophical kind of things instead of eg. practical mathematics such as calculus etc..
03:31:15 <Saizan> mxyz: yeah, and abstract that in the Cont monad, though for delimited continuations it's a bit more complicated
03:31:22 <monochrom> Somehow ocaml exposes enough of its low-level execution that oleg could just add continuation as a library of stack-manipulating code, not needing to mod ocaml source.
03:31:48 <monochrom> To add continuations to ghc, one would have to mod ghc source.
03:31:57 <reltuk> cml had a call/cc mechanism, but ocaml doesn't, right?
03:32:04 <|Jedai|> monochrom: That's quite a feat anyway (but on the other hand it was oleg so... par for the course I guess)
03:32:22 <OscarZ> i guess its the "What" sense of functional programming compared to the engineerish "How" thinking...
03:32:25 <reltuk> s/cml/sml/
03:32:35 <|Jedai|> reltuk: not without Oleg library
03:33:12 <roconnor> oh god
03:33:19 <roconnor> what would it mean to add continuations to ghc?
03:33:27 <monochrom> hehehe
03:33:31 <pikhq> Pain, agony, and sorrow.
03:33:41 <|Jedai|> roconnor: Well Haskell would not be pure anymore
03:33:49 <monochrom> Power, glory, and blessing.
03:33:58 <Saizan> unless you restrict them to IO!
03:34:04 <Saizan> (maybe?)
03:34:15 <roconnor> adding continuations to IO would be mostly sane.
03:34:16 <|Jedai|> Saizan: You could as well use ContT IO then
03:34:39 <roconnor> |Jedai|: It might be different
03:34:54 <roconnor> like the difference between ContT State and StateT Cont
03:35:09 <scalaLove> can you guys recommemd me top 5 books in functional programming in general?
03:35:15 <monochrom> ContT IO is quite adequate, I have found.
03:35:16 <mmorrow> , let callcc f = snag (let o = f toss in o `seq` toss o) id in callcc (\k -> foldl' (\a b -> if b==0 then k (0::Int) else a*b) 1 ([1..10]++[0]++[1..])) :: Int
03:35:21 <lunabot>  0
03:35:30 <roconnor> scalaLove: Type Theory and Functional Programming
03:35:33 <roconnor> @where TTFP
03:35:34 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
03:35:42 <mmorrow> but even cooler, since you could also do the things not simulate-able with exceptions..
03:35:43 <|Jedai|> scalaLove: Okasaki thesis
03:35:51 <|Jedai|> @where okasaki
03:35:52 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
03:35:53 <mxyz> scalalove: i like maclennan's "functional programming practice and theory"
03:36:46 <monochrom> ContT IO is usually adequate because: IO has enough rope to hang you (with IORef and whatnot), and ContT makes sures the rope comes back to haunt you!
03:37:18 <mmorrow> pfft, use callcc and hang the rope with your neck!
03:37:39 <Saizan> #ty snag
03:37:39 <monochrom> Storing a continuation in an IORef is great fun.
03:37:41 <lunabot>  forall o a . Typeable o => a -> (o -> a) -> a
03:37:58 <mmorrow> Saizan: snag/grab are throwDyn/catchDyn
03:38:14 <mmorrow> modulo unIO
03:38:28 <mxyz> oscarz: im just happy to get away from the java community. they think closures are the constructs of satan
03:38:50 <Saizan> mmorrowskell is way scarier than caleskell
03:38:58 <mmorrow> heh
03:39:11 <Philonous> Hah, this is the first time that I read "fortunately the type system is not very smart"
03:39:21 <monochrom> mmorrowskell is the construct of satan
03:39:30 <scalaLove> more books please on functional, i solve problems on euler project and want to do them functional
03:39:47 <roconnor> scalaLove: how many do you have so far?
03:40:17 <mxyz> scalaLove: finish one and then ask again
03:40:22 <mxyz> :)
03:40:48 <scalaLove> i want to get at least 5 for the next week so far i got 3 recomendations
03:40:57 <chrisdone> :t snatch
03:40:59 <lambdabot> Not in scope: `snatch'
03:41:07 <scalaLove> and i will watch this http://webcast.berkeley.edu/course_details.php?seriesid=1906978201
03:41:16 <scalaLove> and this http://groups.inf.ed.ac.uk/vision/VIDEO/2009/inf1fp.htm
03:41:22 <mxyz> if you are not familiar with FP osaki's book will be useless to you
03:42:04 <kmc> mxyz, the irony is that OO is liberating mostly because it brought a crude approximation of first-class functions to people who had never seen them before
03:43:14 <mmorrow> monochrom: come to the dark side!
03:43:23 <mxyz> kmc: i used to be a regular at forums.sun.com but the attitude has become pretty negative towards people who challenge their worldview
03:43:28 <monochrom> You have to be very fluent with lazy evaluation to understand Okasaki from chapter 6 onwards.
03:43:33 <toast-opt> kmc, Heh, opinion much?
03:43:38 <kmc> :)
03:43:42 <kmc> i stole that one from paul graham
03:43:50 <OscarZ> mxyz: hehe.. so you have moved from Java to Haskell ?
03:44:02 <toast-opt> but I do miss autocomplwte
03:44:10 <mxyz> with man things in between, lol
03:44:14 <knobo> a data type (woim) that should be a an item + list the data type. Could that be "data Woim = Woim a [Woim a]"
03:44:15 <mxyz> many
03:44:29 <mxyz> that has to be the funniest typo ever
03:44:42 <toast-opt> kmc, to needs autocomplete for vs,eclipse, etc
03:44:46 <knobo> or maybe data Woim = (Woim a) ([Woim a])
03:44:57 <OscarZ> i guess it was the man in the man in the middle attack ;)
03:44:59 <Saizan> knobo: the former
03:45:05 <toast-opt> fp needs
03:45:15 <kmc> knobo, that's a kind of tree
03:45:22 <knobo> kmc: yes
03:45:26 <knobo> but I get     parse error in data/newtype declaration
03:45:27 <nagnatron> I program mainly in Java and people I interact with that are Java programmers sometimes act like it's the only thing that exists.
03:45:29 <kmc> and your parens break it in the second one
03:45:30 <Saizan> knobo: Woim on the right hand side doesn't need to be the name of the type
03:45:57 <Saizan> knobo: it's just a name you will use for the constructor
03:45:58 <Saizan> ?src Tree
03:45:58 <lambdabot> Source not found. Sorry.
03:45:58 <pikhq> data Woim = SomethingHere a [Woim]
03:46:07 <mxyz> nagnatron: in a conversation about closures and named parameters the java forums said "the only people who need them are script kiddies"
03:46:10 <Saizan> pikhq: missing 'a'
03:46:11 <monochrom> data Woim a = Woim a [Woim a]
03:46:12 <scalaLove> any book recomendations for a guy tranfering from imperative and oop to functional?
03:46:31 <pikhq> Saizan: Grawr.
03:46:38 <Saizan> ?google haskellwiki haskell books
03:46:40 <lambdabot> http://www.haskell.org/haskellwiki/Books
03:46:40 <lambdabot> Title: Books - HaskellWiki
03:46:40 <shepheb> my roommate is a devoted Java programmer. it's comfortable for him, I suppose. if I put on my psychoanalysis hat, I think he fears trying some other language because he might not be good at it.
03:46:47 <Saizan> scalaLove: there ^^^
03:46:49 <OscarZ> mxyz: I guess you were using design patterns, all the latest frameworks, ORM, Spring etc.. what was the thing that brought you to the other side? ;)
03:46:55 <toast-opt> scalalove, LYAH. is good
03:47:04 <mxyz> oscarz: oh god no!
03:47:04 <monochrom> > "data Woim = Woim a [Woim a]" == "data Woim a = Woim a [Woim a]"
03:47:05 <lambdabot>   False
03:47:13 <scalaLove> LYAH?
03:47:16 <mxyz> thatnkfully i write engineering apps so i never had to do any of that crap
03:47:27 <toast-opt> read lots of code too
03:47:35 <OscarZ> mxyz: ok.. why do you think they are crap ?
03:47:38 <nagnatron> mxyz: Heh. I was called an idiot and told to learn "some new frameworks" when a friend saw me reading planet haskell.
03:47:49 <scalaLove> toast-opt, LYAH means?
03:47:58 <Saizan> ?where LYAH
03:47:58 <lambdabot> http://www.learnyouahaskell.com/
03:48:06 <toast-opt> @Google learn you a haskell
03:48:07 <lambdabot> Maybe you meant: google hoogle
03:48:13 <mxyz> oscarz: i was referring more to the gigantic enterprise java beans and family
03:48:19 <toast-opt> gay
03:48:22 <knobo> data Woim a = Woim a [Woim a]  gives me:     parse error on input `]'
03:48:25 <toast-opt> oops
03:48:28 <toast-opt> gah
03:48:42 <monochrom> I cannot reproduce your problem.
03:48:44 <knobo> sorry, no maybe that's from somewere else..
03:48:47 <toast-opt> sry phone autocomplete
03:49:07 <SamB_XP> mxyz: I'm not sure if Java Beans is inherantly evil ...
03:49:10 <knobo> it was..
03:49:12 <toast-opt> I'm on an android phn
03:49:34 <mxyz> it is in a language without properties. reflection cant fix everything :)
03:49:36 <monochrom> (how many fingers do you use to type on a phone?)
03:49:38 <SamB_XP> toast-opt: can you alter the dictionary ?
03:49:38 <knobo> I'm making a parser for a datastructure a friend has "invented".
03:49:42 <OscarZ> mxyz: I feel that these frameworks like Spring with dependency injection are moving move in the direction of functional languages
03:49:59 <toast-opt> samb I must look in to that
03:50:06 <mxyz> exactly. they are very inelegant when used with java syntax
03:50:32 <Saizan> bashing java should go to #haskell-blah though
03:50:52 <nagnatron> whoever did the design for Learn You A Haskell is a genuis.
03:50:52 <ben> Or ##java
03:50:53 <mxyz> noted. i didnt mean to java. it pays my bills.
03:50:57 <Saizan> or maybe we should start an #haskell-bashing-other-langs
03:51:13 <OscarZ> mxyz: what features of the java language are the most inconvenient for this ?
03:51:15 <toast-opt> ugh, Java. give me vb over Java any day
03:51:22 <OscarZ> Saizan: its not my intention to bash java
03:51:37 <SamB_XP> how about we talk about how it's a shame that Borland sold their development tools ?
03:51:41 <Saizan> OscarZ: i wasn't defending java, it was just to limit the OT
03:51:45 <mxyz> no no. i really didnt want to bash it. oscarz was talking about how friendly the community was and i was just trying to say that i was driven to haskell cause the java community was so negative.
03:51:51 <OscarZ> Saizan: Java is my main programming language atm.. im trying to reflect things against my background
03:51:56 <toast-opt> Erik meijer has been injecting some haskell into vb
03:52:01 <Saizan> ok, i retire the bashing
03:52:12 <Saizan> talking about java should go to #haskell-blah
03:52:20 <OscarZ> sure
03:53:03 <OscarZ> mxyz you mind joining
03:53:04 <monochrom> Do you know why people claim that when they google for "irc channel for java" or "python" or "ruby" or "php" or "vb" they are brought to #haskell? :)
03:53:12 <mxyz> nah, i dont really want to talk about java
03:53:50 <SamB_XP> monochrom: maybe they found a page listing popular IRC channels, and ours was nearer the top of the list ?
03:54:14 <toast-opt> nagnatron.  that would be 'bonus' who lurks here. give thanks to them
03:54:17 <OscarZ> mxyz: i only wanted to talk about things _compared_ to java but thats ok
03:54:33 <Saizan> or maybe we actually have programming in the topic while others don't!
03:54:36 <toast-opt> lyah is for awesome
03:54:39 <|Jedai|> monochrom: there _are_ sometimes quite surprising visitors on this channel
03:55:21 <mxyz> plus im still trying to get c2hs and portaudio working
03:55:36 <toast-opt> maybe they get confused thinking haskell is a Java framework
03:55:40 <monochrom> My theory: we talk about other languages so much, google looks at our channel log and thinks this channel is about them, e.g., we probably mention the word "vb" much more than the vb channel does!
03:55:46 <mxyz> toast-opt: nice
03:55:56 <nagnatron> toast-opt: Will do, i love it.
03:56:09 <toast-opt> monchrom, behind true
03:56:18 <aavogt> monochrom: you're not helping ;)
03:56:31 <|Jedai|> monochrom: probably #vb has 5 persons in it (myself and the ChanServ included)
03:57:21 <|Jedai|> and there's 32 persons in #vb.net
03:57:30 <SamB_XP> I was just about to ask about #vb.net
03:57:49 <toast-opt> monochrom, maybe its cause converts.  say like "oh, generic polymorphism is much cooler than language X I use at work"
03:58:19 <SamB_XP> monochrom: hehehehe
03:58:27 <|Jedai|> Maybe there are better channels and/or networks for MS languages ? Or maybe IRC isn't really popular amongst them
03:58:35 <SamB_XP> we do talk about a lot of other languages here an awful lot
03:58:46 <SamB_XP> so, lets go back to talking about Delphi, shall we?
03:58:59 <ben> SamB_XP apparently pressed Retry
03:59:04 <monochrom> I want to talk about formal methods.
03:59:05 <opqdonut> pascal, go!
03:59:11 <toast-opt> heh Delphi
03:59:30 <|Jedai|> SamB_XP: I thought we were supposed to speak of Perl 6 ?
03:59:31 <opqdonut> monochrom: how about Kan extensions?
03:59:32 <Philonous> I bet the only reason there are so many people in #haskell is because they want to pimp their channel stats with a cool academic language.
03:59:47 <gwern> yui-e-go, I choose you!
03:59:50 <monochrom> I haven't learn Kan extension but it should be quite fun.
04:00:03 <opqdonut> me neither.. :)
04:00:03 <gwern> with the power of frameworks, capability security, and hype combined, we are invinvible!
04:00:06 <|Jedai|> Philonous: I didn't even know there were "channel stats"...
04:00:08 <toast-opt> philonous, that's why I here
04:00:11 <SamB_XP> I don't even know what Kan is, why should I care about extensions for it ?
04:00:34 <opqdonut> SamB_XP: it's category theory, relates to monads. Kan is a name
04:00:46 <OscarZ> how many on this channel has read Gdel, Escher, Bach: Eternal Golden Braid ?
04:00:47 <monochrom> SamB_XP is joking.
04:01:15 <monochrom> A pun on a previous conversation about framework and framework extension.
04:01:16 <toast-opt> Oscarz, some
04:01:24 <opqdonut> ah, i fell for it
04:01:43 <gwern> OscarZ: a majority, I'd wager
04:01:55 <toast-opt> I thought it was "Kahn!!!!"
04:02:02 <SamB_XP> OscarZ: maybe you should ask instead, "who hasn't?"
04:02:22 <SamB_XP> I had to look at just now to make sure that was really the subtitle ;-)
04:03:04 <monochrom> I have read 1/10 of GEB and skipped 9/10 of it. I can do and write about fixed points better.
04:03:06 <SamB_XP> a better question might be: who has read the first edition ?
04:04:08 <Saizan> i tried to read GEB but it was too diluted and i'm not as good as skipping :)
04:04:10 <OscarZ> SamB_XP: have you :)
04:04:13 <Saizan> *at
04:04:15 <SamB_XP> no
04:04:44 <monochrom> I was not good at skipping either. But after GEB I became great at skipping.
04:04:55 <SamB_XP> I somehow managed to read a lot of it, I think, even if it was kinda diluted ...
04:05:11 * gwern read that as 'I can do fixed points better' o.0
04:05:22 <|Jedai|> I saw the cover, thought it could be interesting, thought it looked pretty long and promptly forgot to make time for it
04:05:25 <SamB_XP> gwern: so ?
04:05:31 <OscarZ> monochrom: what do you mean?
04:05:34 <gwern> SamB_XP: I have a dirty mind, is all
04:06:07 <SamB_XP> I don't really get how dropping the "and write about" makes it dirtier
04:06:09 <toast-opt> es
04:06:14 <toast-opt> ew
04:06:29 <OscarZ> i think Hofstadter was trying to understand consciousness..
04:06:30 <monochrom> Perhaps there is a dirty meaning of "fixed points".
04:06:41 <mauke> there is a dirty meaning of "do"
04:06:55 <SamB_XP> yes, I gather that there is a dirty meaning of "do"
04:06:59 <toast-opt> fixed point = "self application"
04:07:07 <monochrom> See? :)
04:07:30 * SamB_XP didn't know monochrom was that flexible
04:07:32 <|Jedai|> and since I don't how you can "do fixed points" in a non-dirty way, it has to be the dirty meaning of do even it doesn't make any more sense
04:07:47 <toast-opt> @src fix
04:07:47 <lambdabot> fix f = let x = f x in x
04:07:53 <|Jedai|> toast-opt: oh clever !
04:07:56 <OscarZ> and the book was ment to give the building blocks for this understanding..
04:08:11 <SamB_XP> OscarZ: something like that
04:08:23 <sproingie> so i have a conway's life CA sim at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13636 and i'm trying to figure out how to make the pause function a little more elegant
04:08:45 <SamB_XP> like "how the heck do these folds of flesh up here actually let us think and feel?"
04:08:49 <toast-opt> Jedai, thx
04:08:54 <sproingie> right now i'm using a MVar as a semaphore but i kind of hate it, plus i haven't figured out how to keep from passing it around.  maybe Reader?
04:09:09 <OscarZ> it's still the most influential book i've read
04:09:25 <toast-opt> samb coldly?
04:09:26 <OscarZ> even though im bad in mathematics
04:09:43 <toast-opt> foldl?
04:10:27 <SamB_XP> OscarZ: so, are you far enough in math to have realized that it's *not* actually about numbers ?
04:10:33 <sproingie> anyone want to look at my life sim and see if they can suggest a more elegant mechanism?
04:10:52 <dbrock> OscarZ: I recommend _I Am a Strange Loop_
04:10:54 <Saizan> sproingie: ReaderT can help, but you'd have to use liftIO for the IO actions
04:11:14 <SamB_XP> dbrock: ooh, sounds intreresting
04:11:19 <gwern> dbrock: you do?
04:11:22 <sproingie> Saizan: i can probably live with that
04:11:22 <SamB_XP> how can it be obtained ?
04:11:41 <dbrock> gwern: yep
04:11:44 <gwern> you're the first person I've met who says it isn't reheated rubbish
04:11:51 <gwern> and even daniel dennet doesn't like it
04:11:54 <gwern> generous as he is
04:12:00 <OscarZ> SamB_XP: but I'm confused.. i *really* dont understand arithmetics or numbers... i mean.. i know how to perform these operations.. i know how to relate addition to some physical operations such as addition of lenghts etc..
04:12:10 <roconnor> Saizan: presumably sproingie most concerned about the XXX HACK ALERT AROOGA AROOGA DIVE DIVE part of his code
04:12:13 <Baughn> sproingie: There's a QSem type for counting semaphores, not to mention all of STM
04:12:31 <Saizan> roconnor: yeah, but the other one was faster to address :)
04:12:39 <opqdonut> OscarZ: go get a degree and you'll be as confused
04:12:46 <opqdonut> but learn some cool stuff in the process
04:12:53 <OscarZ> SamB_XP: but still.. many of these physical theories based on _numbers_ reveal so many facts that i cant ignore them
04:12:53 <sproingie> roconnor: the design in general is kinda hacked, though test-and-set is definitely my biggest concern
04:13:07 <dbrock> gwern: there aren't many new ideas in it compared to GEB, but if you like GEB and it was a while since you read it, then Strange Loop will be a pleasant revisit of those ideas
04:13:20 <gwern> I didn't enjoy it very much
04:13:24 <gwern> it was terribly argued
04:13:27 <opqdonut> i read GEB way too late
04:13:31 <|Jedai|> OscarZ: It's not so much about numbers, maths isn't about numbers, it's about structure, reasoning and abstraction
04:13:38 <OscarZ> SamB_XP: and I feel that I lack some basic sort of understanding of these elements... that are called numbers
04:13:45 <sproingie> QSem uses unit MVars under the covers anyway.  i don't see a way to do an atomic toggle with those either.
04:13:48 <opqdonut> i liked the dialogues, but had already seen diagonalization and gdel's theorems on courses
04:13:48 <dbrock> many people complain about the dead wife aspect
04:13:57 <gwern> typically to find arguments as terrible as in i am a strange loop, I have to go to _National Review_
04:13:58 <Baughn> sproingie: Well, STM then
04:14:12 <gwern> dbrock: the dead wife thing wasn't too bad in le ton de beau marto
04:14:24 <gwern> but hofstadter had *nothing* for strange loop
04:14:25 <OscarZ> dbrock: I've read I am Strange Loop
04:14:29 <sproingie> Baughn: store the MVar in a TVar?
04:14:35 <gwern> yo dawg...
04:14:54 <OscarZ> dbrock: I think its just a popularisation of the themes in GEB...
04:15:09 <Baughn> sproingie: Why use an MVar at all?
04:15:23 <sproingie> Baughn: i need something to block
04:15:24 <OscarZ> which is all good... i share his intuition of the strange loop
04:15:29 <Baughn> sproingie: STM operations block just fine
04:15:38 <dbrock> it didn't bother me at all; in fact, I thought it was fascinating to hear Hofstadter try to reconcile his sort of magical thinking about his wife with his desire to be objective
04:16:01 <dbrock> I found it led to quite a few beautiful ideas
04:16:14 <OscarZ> dbrock: oh yeah... i felt bad for him
04:16:30 <gwern> eh. I felt more for randy pausch
04:16:31 * hackagebot upload: AES 0.2.0 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
04:16:33 * hackagebot upload: SHA2 0.0.1 - Fast, incremental SHA hashing for bytestrings (SveinOveAas)
04:16:37 <gwern> at least pausch didn't wear out his welcome
04:16:41 <dbrock> gwern: yeah, no, in le ton beau de marot, that wasn't at all bad
04:16:45 <OscarZ> dbrock: but still, there is truth in what he says...
04:16:46 <sproingie> Baughn: didn't know that.  i only ever think of them as atomic.  i'm not sure how to use them to block
04:17:01 <mxyz> i never got the whole pausch thing
04:17:03 <dbrock> OscarZ: sure
04:17:06 <sproingie> er "them" being STM
04:17:20 <Baughn> sproingie: It's pretty fundamental. Any time you call retry in an STM block (or anything you call does), the entire atomically block restarts, right?
04:17:27 <sproingie> i should probably convert it to FRP and just use a stream of "render" events
04:17:29 <Fredderf> @pl snd (bounds sieve)
04:17:29 <lambdabot> snd (bounds sieve)
04:17:33 <sproingie> pause would just turn off the spigot
04:17:36 <gwern> hofstadter's ideas on the strnage loop are hopeless. I'd rather go read some Thomas Metzinger. he's difficult as shit to read, but at least there's something there and he hasn't been cooped up in his own little analogies world mourning his dead wife
04:17:39 <Baughn> sproingie: But it doesn't actually /do/ anything until one of the TVars (or similar) you've read so far gets a new value
04:17:46 <sproingie> 'course i'd probably have to do *that* with blocking
04:18:01 <DrSyzygy> Hmmmmmm.
04:18:06 <Baughn> sproingie: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13638#a13638 <-- Like this
04:18:14 <OscarZ> gwern: What is this Metzinger about?
04:18:22 <DrSyzygy> I can't do >> instance (T a) => S a where { ... }
04:18:23 <DrSyzygy> can I?
04:18:32 <toast-opt> is there stm in haskell?
04:18:37 <mauke> DrSyzygy: not in H98
04:18:38 <ddarius> DrSyzygy: Not without ugly extensions.
04:18:42 <sproingie> ah leaky bucket again
04:18:48 <DrSyzygy> How do I do it if I'm willing to use ghc and extensions?
04:18:56 <Baughn> sproingie: always calls retry if the condition is false
04:18:58 <mauke> you need at least undecidable instances
04:19:01 <|Jedai|> toast-opt: Of course, STM in Haskell is one of the earliest implementation of STM
04:19:03 <mauke> and possible overlappding instances
04:19:03 <gwern> OscarZ: in a few words? concsciousness is self-modeling; the mind operates as a collection of models which get tied together into a model of the whole self, when a whole self is needed
04:19:11 <sproingie> Baughn: that will spin though, right?
04:19:17 <Baughn> sproingie: No.
04:19:26 <Baughn> sproingie: That's the point. retry /blocks/.
04:19:29 <Gracenotes> gwern: really nasty day out, eh
04:19:39 <gwern> Gracenotes: actually, I was thinking of going for a walk
04:19:52 <gwern> I like these days
04:19:53 <sproingie> ahhhhh..  i definitely need to really learn STM
04:19:55 <knobo> I have a list of tokens that I shall build in to a tree. Normaly I would pop one item of a stack and decide what to do with it, but I guess it its not the right in haskell...
04:20:01 <sproingie> i played with it in clojure for a bit and that was it
04:20:05 <Gracenotes> gwern: I went for a walk, to the SAC. Was not too pleasant, but perhaps that's because I was wearing shorts
04:20:10 <|Jedai|> toast-opt: It's pretty suited to it too, since you can ensure that no unrollback-able action are performed by creating a STM Monad that only contains the possible actions
04:20:13 <dbrock> by the way, this talk by David Rock is really enjoyable: http://www.youtube.com/watch?v=XeJSXfXep4M
04:20:14 <gwern> that would not help, no
04:20:18 <Baughn> sproingie: GHC's STM is significantly more capable than anything I've seen in another language
04:20:18 <OscarZ> gwern: I dont think Hofstadter in "Im am a strange loop" brought any false substance in the play because of the tragedy, just forced him to make specific kind of perceptions of the world... the rules he believed in didnt change because of it, he "stayed in the system"
04:20:29 <gwern> dbrock: hm. david rock, dbrock...
04:20:31 <toast-opt> yeah iheve no intuition about stm
04:20:32 <gwern> spam!
04:20:33 <roconnor> sproingie: retry block until something that it read from memory upto that point changes.
04:20:41 <Gracenotes> gwern: the rain is sort of slanty, so if you have some means to avoid it going in your face, e.g. umbrella, it could be pretty enjoyable
04:20:42 <dbrock> gwern: I wish! :D
04:20:57 <roconnor> > atomicially retry -- will block the thread forever.
04:20:58 <lambdabot>   Not in scope: `atomicially'Not in scope: `retry'
04:21:03 <gwern> Gracenotes: my nice waxed aussie hat and coat do me fine
04:22:27 <Gracenotes> if you says so.
04:22:27 <DrSyzygy> Is there some alternative way of making a typeclass that gets expressed whenever certain other classes are present, but doesn't have to possess the other classes to work?
04:22:27 <sproingie> my gf is always wanting me to get pictures of my cat.  black cat.  black leather furniture.
04:22:27 * sproingie grumbles
04:22:27 <Gracenotes> the temperature does seem pretty reasonable, besides these periodic bone-chilling breezes
04:22:27 <Baughn> DrSyzygy: Sadly.. no. Not so much. Not without jumping through starfish-shaped hoops.
04:22:27 <DrSyzygy> What I want to do is to encode the (possibly finite) partial orders as a typeclass. And I figure that if a type has both Enum and Ord, it'll be my kind of partial order; but I don't want all partial orders to be complete orders.
04:22:27 <DrSyzygy> Baughn: :-(
04:22:27 <dbrock> I don't think it's too unfair to describe I Am a Strange Loop as one long rationalization of his denial of his wife's death
04:22:30 <dbrock> but that's almost what's fascinating about it to me
04:22:46 <|Jedai|> knobo: why not, except the pop() part, that seems quite natural
04:22:51 <OscarZ> i wonder what Cale has to say of Hofstadters loops...
04:22:54 <sproingie> think i'll leave the lens cap on and call it a closeup
04:22:59 <gwern> dbrock: I'm neither sadistic nor masochistic, so it was merely painful to me
04:23:23 <gwern> I do not like to see my idols wade out into the mud and wait for it to harden between their toes
04:24:09 <knobo> |Jedai|: loop's and stacks does not work the same way as in other languages...
04:24:22 <knobo> |Jedai|: as far i understand.
04:25:03 <dbrock> gwern: you don't like to think of your idols as humans with faults and emotions and struggles?
04:25:07 <ddarius> Blech.  Who would idolize Hofstadter?
04:25:13 <|Jedai|> knobo: like "parse (Num n:ts) [] = parse ts [Num n]; parse (Add: ts) (n:ns) = Add n (parse ts ns)" or something like that
04:25:32 <opqdonut> knobo: you probably want to fold over the list
04:25:39 <gwern> dbrock: the evil men do lives after them; the good is oft interred with their bones
04:25:56 <|Jedai|> knobo: in other words, do a recursion (maybe you could write it as a fold but if you don't have much experience try to do it directly)
04:26:14 <gwern> I came not to bury Hofstadter's work, but to praise it...
04:26:20 * SamB_XP notes that his God walks on the *top* of the water rather than bothering with the mud
04:26:25 <knobo> opqdonut: if could end this with a fold, I would have learned alot today :)
04:26:25 <Philonous> Why does the type system think the "pred" in the instance header and the instance declaration are different in "instance (IsFunction a pred, Foo' pred a) => Foo a where foo = foo' (undefined :: pred)"  ?
04:28:26 <SamB_XP> Philonous: because you aren't using the "scoped type variables" extension ?
04:28:26 <ddarius> Philonous: Because undefined :: pred means undefined :: forall pred. pred
04:28:26 <Philonous> SamB_XP: That's it, thanks a bomb!
04:28:40 <sproingie> my god lives under the water.  sleeping.
04:29:05 <SamB_XP> mine evidently prefers to sleep in the bottom of a boat during a storm ;-)
04:29:39 <OscarZ> what do you think about category theory?
04:29:45 <OscarZ> and it's usefulness?
04:29:51 <|Jedai|> sproingie: Eternally we hope
04:29:53 <DrSyzygy> OscarZ: I taught a class on that topic this quarter.
04:30:07 <|Jedai|> OscarZ: It's perfectly useless and yet awesome !
04:30:13 <ddarius> DrSyzygy: On the usefulness of category theory?
04:30:36 <DrSyzygy> IMO, category theory is a fascinating and surprisingly powerful mathematical theory, and has more applications than I had expected outside the parts of algebra I'm used to working in.
04:30:37 <|Jedai|> OscarZ: You don't need to understand it at all to program in Haskell though
04:30:42 <OscarZ> |Jedai|: heh.. sounds exactly the kind of thing i'd like to learn about
04:30:47 <DrSyzygy> ddarius: I taught "Category theory and functional programming" this quarter.
04:30:51 <SamB_XP> the usefulness of category theory is evidently that it helps you to move proofs between branches of mathematics
04:31:15 <OscarZ> interesting
04:31:25 <scalaLove> haskell on ubuntu? i installed ghc but how do i call haskell now?
04:31:33 <DrSyzygy> scalaLove: ghc or ghci
04:31:39 <sproingie> ghc, ghci, runhaskell
04:31:40 <DrSyzygy> scalaLove: ghc for the compiler, ghci for the interpreter.
04:31:43 <toast-opt> Dr, that sounds fun
04:31:44 <SamB_XP> and, I suppose, intuitions as well as proofs ;-)
04:31:46 <|Jedai|> scalaLove: ghci is a REPL for Haskell
04:31:49 <DrSyzygy> scalaLove: If that doesn't work, try rehash to update your shell.
04:31:52 <idnar> my god pouts on the cover of the magazine
04:32:01 <DrSyzygy> toast-opt: It was. Notes are up on the haskell wiki.
04:32:19 <OscarZ> i asked about it from a friend and he thought its best to think first about groups, rings, etc.. other algebraic structures
04:32:29 <DrSyzygy> http://haskell.org/haskellwiki/User:Michiexile/MATH198
04:32:36 <ddarius> DrSyzygy: Yeah, I still haven't gotten around to looking through them.
04:32:38 <scalaLove> rehash?
04:32:51 <|Jedai|> scalaLove: I would suggest using emacs with haskell-mode, if you feel like it
04:33:13 <DrSyzygy> OscarZ: Depends on how you want to go at it. It certainly helps having an intuition for how algebraists and geometers do mathematics, since that's what CT abstracts from.
04:33:13 <scalaLove> i hate emacs actualy i have netbeans and eclipse
04:33:22 <sproingie> eclipsefp perhaps
04:33:22 <ddarius> OscarZ: If you have no mathematical background, most introductions to category theory will be very difficult and indeed much of category theory will seem pointless.
04:33:27 <DrSyzygy> OscarZ: But you can use logic and type theory as a source of inspiration for it too.
04:33:39 <scalaLove> |Jedai| what REPL means?
04:33:49 <sproingie> scalaLove: Read-Eval-Print Loop
04:33:50 <|Jedai|> scalaLove: eclipsefp should help, apparently it has progressed some recently
04:33:56 <DrSyzygy> OscarZ: The entire language and most of the constructions are analogies for stuff in algebra, topology and geometry though - so you'll be much better off if you know some stuff.
04:34:04 <mxyz> scalalove: i started using Leksah this week and it works well
04:34:13 <sproingie> scalaLove: aka an interactive interpreter.  like scala.exe
04:34:36 <sproingie> i couldn't make leksah do much other than, well, edit text.  got gedit for that.
04:35:00 <|Jedai|> scalaLove: or python, or ocaml, or... most modern languages now propose a REPL, pretty useful to test things quickly and experiment a little bit
04:35:01 <mxyz> the module hierachy and the function lookups didnt work for you either?
04:35:04 <sproingie> navigating and browsing modules was completely borked
04:35:11 <scalaLove> Leksah it takes time to learn it? mxyz, i mean it takes time to learn emacs for example, incredibly stupid and complicated text editor
04:35:44 <OscarZ> ddarius: I have no mathematical background.. and yes I noticed that :)
04:35:50 <sproingie> emacs is old, that's all.  created before we had CUA conventions and whatnot
04:35:58 <mxyz> leksah didnt take any time to learn. you just start a project like in eclipse and it will give you errors as you type and provide module and function info
04:36:15 <|Jedai|> scalaLove: I don't think emacs is stupid, complicated though... Leksah isn't too complicated to use, certainly incomparable to emacs
04:36:28 <sproingie> emacs + flymake = love
04:36:29 <OscarZ> DrSyzygy: what kind of deductions or "new information" can be achieved by using category theory ?
04:36:33 <scalaLove> oh i see  Leksah is windows, i am ubuntu
04:36:41 <sproingie> leksah is cross platform
04:36:51 <|Jedai|> scalaLove: leksah works on Linux
04:36:57 <sproingie> in fact it feels very much like a port on windows
04:37:08 <mxyz> its built with gtk so it should work on linux right?
04:37:16 <sproingie> should hope so
04:37:17 <DrSyzygy> OscarZ: One of the instances I'm most fond of at the moment is a sensible framework for fuzzy set theory, where geometric constructions indicate how to make sets that are fuzzy on both membership and on equality.
04:37:37 <DrSyzygy> OscarZ: And where soundness and completeness of the resulting set theory and logic follow from the abstract theorems.
04:37:40 <scalaLove> on web site it says windows and mac no linux
04:37:50 <sproingie> it says windows, mac, and *source*
04:38:00 <mxyz> sproingie: yea the gui on windows is kludgy but i cant complain
04:38:06 * jao was unable to install leksah using cabal on linux
04:38:28 <sproingie> but it's probably not the most fun thing to compile
04:38:34 <sproingie> leksah is still pretty raw imho
04:38:44 <sproingie> eclipsefp is probably a bit further along
04:38:46 <mxyz> from their site: " It is currently been tested on Windows and Linux but it should work on the Mac."
04:39:10 <mxyz> does eclipsefp provide the module and function info though? as a beginner thats the most valuable for me
04:39:23 <mxyz> so i dont have to switch between the ide and hoogle or the docs
04:39:45 <OscarZ> DrSyzygy: sounds convincing :) shame i lack the mathematical sophistication to follow that
04:39:46 <sproingie> dunno, i use emacs, which doesn't do that much about it.  i just have hoogle on a hotkey
04:39:52 <|Jedai|> jao: The main problem is Gtk2Hs, since that's not on Hackage, but on Ubuntu, they can be installed with apt-get
04:39:55 <sproingie> i don't even use etags
04:40:05 <OscarZ> DrSyzygy: http://en.wikibooks.org/wiki/Haskell/Category_theory
04:40:08 <OscarZ> you seen that ?
04:40:30 <DrSyzygy> Yeah.
04:40:42 <DrSyzygy> It's an okay intro, but too curt for the stuff I tried to do.
04:40:59 <OscarZ> ok..
04:41:12 <sproingie> why isn't gtk2hs in hackage anyway?
04:41:23 <jao> |Jedai|: cabal complains about regex-base before that, i think
04:41:39 <mxyz> sproingie: good question. it doesnt even install on windows for me.
04:42:02 <mxyz> that same question is being discussed on haskell-cafe right now
04:42:33 <sproingie> it's bound to be a little tricky on windows, but it should be simple for any *nix
04:42:38 <phr> @src length
04:42:38 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:42:43 <phr> @src genericLength
04:42:43 <lambdabot> genericLength []    = 0
04:42:43 <lambdabot> genericLength (_:l) = 1 + genericLength l
04:42:54 <|Jedai|> sproingie: needs some stuff that isn't in cabal yet for its compilation, so it has to use a configure/make setup (or at least it does and it's tricky to port to cabal)
04:43:24 <jao> |Jedai|: it seems that leksah 0.6.1 wants regex-base 0.72.0.2, but cabal finds i've got 0.93.1 and bails out
04:43:29 <sproingie> i've seen cabal fire off configure scripts before
04:43:33 <sproingie> not make tho
04:44:00 <reltuk> I'm trying to optimize a program I wrote, and in order to do it without changing a bunch of code I created a type class that lets me replace a relatively slow piece of data that I'm passing around and accessing everywhere into a fast piece of data
04:44:04 <mxyz> jao: you on windows? i have the newest HP and leksah installed without a hitch.
04:44:15 <jao> mxyz: nope, i'm on linux
04:44:19 <|Jedai|> jao: depending on leksah version, there was some dependancy problems, but it should work with the latest version
04:44:21 <reltuk> but all of my type signatures that I manually wrote are over specified now
04:44:32 <gwern> reltuk: so remove them all?
04:44:39 <reltuk> should I just delete them until I'm done with the refactoring, or should I go through and change them all?
04:44:57 <gwern> delete and restore for debugging issues, I suppose
04:44:59 <jao> |Jedai|: you mean using the source repo instead of the one hackage?
04:45:34 <OscarZ> I think my lack of understanding of mathematics stems from a few fatal misundertandings that have been further amplified by the use of OO paradigm.. I think of Integers that they are some kind of "bag" of same kind of things... but in reality they have unique qualities
04:45:51 <reltuk> gwern : and I could use something like haddock to see where the program itself was overspecified, huh?
04:45:59 <gwern> ?
04:46:04 <Saizan> jao: you could add --constraint="regex-base < 0.90"
04:46:07 <OscarZ> thats why in eg. Java integers are "promoted" to primitives...
04:46:08 <ddarius> OscarZ: I would imagine your "lack of understanding of mathematics" stems from a lack of experience and background.
04:46:09 <Philonous> Fundeps are strange. Why doesn't the type system choose the more specific instance when I write "IsFunction a HFalse" (functional dependencies conflict), but when I use "instance (TypeCast pred HFalse) => IsFunction a pred" it works.
04:46:29 <reltuk> gwern: like, it didn't infer to the type class
04:46:47 <OscarZ> ddarius: I mean that there are people who naturally have feel for these things... are talented in math
04:46:49 <gwern> haddock can't do anything as far as inferring types that ghc can't
04:46:53 <gwern> since haddock goes through ghc
04:47:09 <reltuk> gwern : yeah, but it would print them all somewhere I could see them...
04:47:17 <gwern> oh that
04:47:19 <reltuk> gwern : or does ghc have a mode where it would do that if given a module?
04:47:20 <gwern> you using -Wall?
04:47:22 <|Jedai|> OscarZ: I don't think anybody has a "natural" feel for axiomatic descriptions of numbers
04:47:47 <ddarius> OscarZ: Other people's talents don't affect you.
04:47:47 <reltuk> gwern yeah, but I'll be turning that off if I remove all the type signatures :-)
04:47:49 <OscarZ> |Jedai|: not even the likes of Gdel ?
04:47:58 <jao> Saizan: thanks, will try
04:48:13 <mxyz> oscarz: you see numbers as bags? well in lambda calc they are nested functions, lol. is that kinda like a bag?
04:48:14 <gwern> reltuk: -Wall is a grabbag of options; I suppose you could track down the specific one that prints ifnerred type sigs
04:48:24 <gwern> IIRC, printing inferred type sigs was actually my suggestion
04:48:37 <gwern> (probably my first ghc bug report)
04:48:49 <|Jedai|> OscarZ: No, what Goedel has done isn't that incredible, if he didn't do it, it's quite likely that someone would have found this proof later on
04:48:56 <DrSyzygy> Jedai: You mean Peano? They're obvious.
04:49:03 <scalaLove> how to run a file from terminal? i have a file of 30 lines instalation for haskel and its IDE
04:49:19 <DrSyzygy> It's really about defining the integers as the fundamental well-ordered total order.
04:50:14 <|Jedai|> OscarZ: Not to say that Goedel wasn't a genius, just that what he did had nothing to do with a "natural" feel for numbers (especially for numbers, as I've already told you, numbers aren't that important to mathematicians, abstraction skill is much more fundamental)
04:51:09 <fracture> anyone know of a url somewhere explaining how to set up the haskell SDL bindings on a windows machine?
04:51:27 <OscarZ> I thought his genius was realizing the mismatch between mechanization and interpretation..
04:52:13 <eldragon> OscarZ, mechanization is related to machine, interpretation is related to human.
04:52:51 <|Jedai|> DrSyzygy: you're speaking about naturals (ok, relatives are just a symetrisation of that but...) anyway, while the fundamental idea behind Peano description is quite natural, I wouldn't say that the axiomatic decomposition of it is quite that "natural" and the reconstruction of the whole arithmetic on them isn't something one can have a "feel" for, IMHO
04:53:36 <patch-tag> what's the function that performs some io, and gives up after x seconds if the action isn't complete? I know there's a function for this but the name escapes me
04:53:54 <knobo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13640#a13640
04:53:54 <DrSyzygy> So is it the characterization of integers as differences of naturals you have an issue with?
04:53:57 <|Jedai|> @hoogle timeout
04:53:58 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
04:53:58 <lambdabot> module System.Timeout
04:53:58 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
04:54:03 <knobo> Anyone sees what I mean?
04:54:10 <|Jedai|> patch-tag: timeout, no ?
04:54:11 <OscarZ> DrSyzygy: yes
04:54:18 <patch-tag> Jedai: sounds right, thanks
04:54:52 <DrSyzygy> That one's obvious. If we want to talk about artificially created negatives, whose main role are to make a + x = 0 solvable, just make equivalence classes of things with equal difference.
04:54:53 <Fredderf> @pl \i -> sieve!i
04:54:54 <lambdabot> (sieve !)
04:55:00 <DrSyzygy> You can even pick canonical representatives.
04:55:11 <DrSyzygy> So that you get data  Integer =
04:55:24 <DrSyzygy> So that you get data Integer = Pos x | Neg x
04:56:04 <DrSyzygy> With + lifting cleanly to Pos and Neg, and with Pos x + Neg y defined through size comparison of x, y and then doing the 'obvious' thing.
04:56:08 <knobo> I should have had something like  [Woim "a" [Woim "b" [Woim "c"], Woim "d" [], Woim "f" []]]]
04:56:23 <DrSyzygy> Of course, for Pos and Neg, I'd write the ordered tuplkes (x,0) and (0,x) instead.
04:56:39 <DrSyzygy> and define stuff with the same formulae that'd work for the equivalence class approach.
04:56:45 <DrSyzygy> Still doesn't feel unnatural to me.
04:57:34 <DrSyzygy> Then again I feel even Dedekind cuts to be relatively obvious and easy. :-D
04:57:51 <Fredderf> constArray from to value = array (from, to) [(i, value) | i <- [from..to]]
04:57:51 <Fredderf> Is there such a function in the standard library?
04:58:34 <ddarius> I believe one of the array making functions takes a single value that it duplicates for all entries.
04:58:49 <Kim^Walkman> Fredderf: replicate together with zip?
04:58:50 <DrSyzygy> I wonder whether one can do some sort of approach to computable reals, and their topology, by viewing a dedekind cut as a function Rational -> Bool.
04:59:15 <knobo> time to learn continuations, I think...
05:00:02 <Fredderf> constArray from to value = listArray (from, to) (repeat value)
05:00:02 <Fredderf> ah, that's better :)
05:00:04 <augur> hm!
05:01:48 <EnglishGent> DrSyzygy - arent you going to need some way of eliminating some of those functions? for example f x = True -- not a Dedekind cut
05:02:01 <EnglishGent> (serious question)
05:02:41 <ddarius> f : {r : Rational} -> {forall r'. f r /\ not (f r') => r' < r}
05:02:43 <knobo> I have to sleep on it.. This was so much easier in lisp :/
05:03:11 <ddarius> EnglishGent: Yes, not all Rational -> Bool functions will be Dedekind cuts (with the obvious approach)
05:03:41 <|Jedai|> knobo: just write an auxiliary function that return (Woin [a], [Woin [a]]
05:03:47 <Fredderf> Anyone want to comment on my Haskell program to find the 10001st prime number? :) http://haskell.pastebin.com/m54f759ca
05:04:10 <augur> sd xs = let mu = avg xs in sqrt ((sum (\x -> square x-m) xs) / length xs)
05:04:11 <augur> :o
05:04:23 <knobo> ok. I'll try
05:04:33 <|Jedai|> knobo: or use zippers
05:04:43 <knobo> |Jedai|: did you see my paste?
05:04:58 <|Jedai|> knobo: Yes
05:05:20 <|Jedai|> knobo: I'll try to do something :)
05:05:42 <fracture> man... cabal seems to fail miserably on windows :(
05:05:51 <knobo> |Jedai|: thaks :)
05:06:40 <Saizan> fracture: it tends to work, but for C bindings you need mingw/msys
05:06:50 <DrSyzygy> EnglishGent: It is for the extended reals. :-)
05:07:03 <DrSyzygy> But yeah, we need order-respecting maps of the two total orders Rational and Bool.
05:07:27 <fracture> Saizan: is there any documentation about this anywhere?  (I have the haskell platform)
05:08:40 <fracture> hrm.  seems like the problem is that a lot of these packages use autoconf...
05:08:53 <knobo> |Jedai|: or I'll sleep on it. I love these intens zen moment's when I get it :)
05:09:30 <Saizan> yeah, you need at least an sh.exe to run the configure scripts
05:09:43 <Saizan> and also the C side of the libraries to link against
05:11:31 <fracture> is it possible to run haskell entirely inside of cygwin?
05:12:15 <fracture> meaning, have ghc produce binaries linking cygwin1.dll, etc
05:12:29 <Saizan> i don't think that's supported anymore
05:13:26 <Saizan> you'd have to build a cygwin ghc, and that probably isn't straightforward
05:13:28 <fracture> bummer.
05:14:16 <Fredderf> let n = 1000 in floor (sqrt n)
05:14:19 <Fredderf> > let n = 1000 in floor (sqrt n)
05:14:20 <lambdabot>   31
05:15:55 <fracture> Saizan: some stuff on mailing lists is suggesting people can't get it to work with cygwin, actually, and use msys/mingw instead
05:16:22 <fracture> meaning at all---even just using cygwin for running sh
05:16:25 <Fredderf> @hoohle Int -> Double
05:16:26 <lambdabot> Prelude toEnum :: Enum a => Int -> a
05:16:26 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
05:16:26 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
05:16:43 <mauke> Fredderf: fromIntegral
05:17:00 <Saizan> fracture: yeah, i'd suggest to use msys to run sh too
05:17:28 <Fredderf> ah, thanks
05:18:01 <Saizan> i just added the bin directory of msys to my %Path% when i was on windows
05:18:25 <Saizan> using cmq.exe as shell
05:18:57 <SamB_XP> command & quit ?
05:20:33 <eldragon> what's the shortest name that should be legally admitted as own of an entity, person or company? and could this name coincide with the name of an existent thing but with upper/lower cases?
05:21:01 <fracture> it seems like it'd be nice if the haskell platform jsut did this stuff internally
05:21:13 <fracture> this page I found is saying if you do a non-minimal installation of minGW it won't work
05:21:17 <fracture> (Hah.)
05:22:29 <Saizan> fracture: a version of the installer that includes all of this would make sense, yeah, maybe propose it on the trac :)
05:22:53 <SamB_XP> eldragon: hmm, well, for a company I think you need a legal name that doesn't have exactly the same letters as another but in a different case, yes
05:23:14 <SamB_XP> I won't say "case insensitive", precisely, because some letters don't exactly exist in both cases ...
05:24:47 <Twey> In terms of ‘should’, I would say anything that hasn't previously been taken by another
05:26:17 <Twey> Differences in writing where the difference is significant (e.g. different hanzi used to write the name) but probably not where the difference is purely stylistic (case, font, equivalent characters [a/alpha, hiragana/katakana, &c.])
05:28:09 <SamB_XP> but for trademarks, it's permitted for multiple companies to trademark the same name in different arenas
05:28:15 <DrSyzygy> Twey: Do you really consider a and alpha equivalent? Across how many scripts?
05:28:24 <fracture> bleh; this isn't quite working either :(
05:28:35 <DrSyzygy> Or rather ... do you count the equivalence across the entire scripts?
05:28:44 <DrSyzygy> And in that case, what's the latin equivalent to psi?
05:28:45 * fracture gives up. :)
05:29:10 <Twey> DrSyzygy: The criteria are that a) it's visually indistinguishable (could be misconstrued as a variation of the taken character) and b) it's pronounced the same
05:30:51 <Twey> Either disqualifies (although note that the owner of the identifier may select an arbitrary audio representation)
05:31:22 <Twey> I probably shouldn't have lumped hiragana/katakana in with that, since that's more equivalent to case (a visually distinct style with no audio or semantic difference)
05:39:41 <ddarius> DrSyzygy: Isn't this only true for simple graphs: "For any edge f, there is a unique path from s(f) to t(f) of length 1: (f)"
05:40:33 <opqdonut> why s and t?
05:40:38 <opqdonut> source and to?-)
05:40:43 <ddarius> target
05:40:48 <opqdonut> ah
05:41:03 <opqdonut> i'd've thought source/destination
05:42:49 <benmachine> i'd've's an interesting word
05:43:10 <ddarius> It's a contraction of three words, not a word itself.
05:43:24 <benmachine> i'd've's an interesting contraction of three words
05:44:03 <|Jedai|> @msg knobo This solution seems to work : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13640#a13643
05:44:03 <lambdabot> Not enough privileges
05:44:03 <mauke> ‘i'd've’'s an interesting contraction of three words
05:44:55 <|Jedai|> i'd've's's is an interesting contraction of four words
05:45:29 <Niccus> 's is is redundant
05:46:09 <opqdonut> i'd've is usually spelled i'dve i guess
05:46:20 <Niccus> I'd've been cotton-eye joe
05:46:57 <opqdonut> you, you'd've been married a long time ago
05:46:57 <opqdonut> if it weren't for cotton-eye joe
05:46:57 <ddarius> #haskell conversations are not Noetherian
05:46:59 <lunabot>  luna: Not in scope: `haskell'
05:47:09 <ddarius> I'm pretty sure it is usually spelled "I'd've"
05:47:26 <opqdonut> just struck me as odd when I wrote it
05:50:17 <eu-prleu-peupeu> helloow
05:51:56 <Niccus> hullo
05:52:26 <pastah_rhymez> eu-prleu-peupeu: zup, dawg?
05:54:06 <eu-prleu-peupeu> :D
05:54:16 <eu-prleu-peupeu> pastah_rhymez, i love you bro
05:54:46 <elben> hi
05:55:40 <ddarius> DrSyzygy: Your definition of subcategory seems "obnoxious" not (just) because you can reduce to just arrows, but that the statement D is a category implies most of the conditions you state.
05:56:54 <zygoloid> 22
05:57:04 <ClaudiusMaximus> what can i do when ghc: out of memory (requested 1048576 bytes)
05:59:00 <pastah_rhymez> ClaudiusMaximus: write better code? :p
05:59:31 <pastah_rhymez> ClaudiusMaximus: profile
06:00:26 <ClaudiusMaximus> pastah_rhymez: my code is fine, it's compiling it that isn't :(
06:03:21 <ClaudiusMaximus> aha! ghc +RTS -M2G -RTS seems to be running for more time, maybe it will succeed...
06:03:30 <opqdonut> heh
06:04:01 <monochrom> Your program must be huge.
06:04:15 <opqdonut> or his data
06:04:26 <ClaudiusMaximus> it's the types...
06:04:32 <monochrom> Is type-checking and type-inference of haskell98 pspace-complete?
06:04:43 <opqdonut> ah, it was ghc
06:07:20 <eu-prleu-peupeu> hey
06:07:27 <dons> Haskell (monthly) Web News. First edition. http://haskellwebnews.wordpress.com/2009/12/05/whats-new-in-haskell-december-2009/   Thoughts ? (comment here: http://www.reddit.com/r/haskell/comments/abi5f/whats_new_in_haskell_december_2009/
06:07:34 <eu-prleu-peupeu> what is teh fastest and bestest way to map an Int to an Int ?
06:07:45 <eu-prleu-peupeu> like an IntMap of Ints
06:07:55 <eu-prleu-peupeu> is there a better thing than this ?
06:08:04 <dons> how many ints?
06:08:07 <aavogt> > id 1 :: Int
06:08:07 <lambdabot>   1
06:08:25 <eu-prleu-peupeu> about 3 or 4 keys, and about 1000 entries per key
06:08:29 <dons> tries are the best way. unless you plan on using say, 100M ints, then IntMap is best.
06:08:35 <ClaudiusMaximus> Heap exhausted;
06:08:35 <ClaudiusMaximus> Current maximum heap size is 1999998976 bytes (1907 MB);
06:08:38 <ClaudiusMaximus> :'(
06:08:41 <dons> if it is more like 10M to 1B ints, try the judy pakcage.
06:08:44 <eu-prleu-peupeu> oh, ill have to read up on tries
06:08:51 <eu-prleu-peupeu> thanks dons
06:08:52 <dons> just use IntMap.
06:08:56 <eu-prleu-peupeu> okey
06:09:00 <chrisdone> anyone else try to use a verb for side-effectual functions and declarative descriptions for everything else?
06:09:13 <chrisdone> or am I trying too hard
06:09:25 <EvanR> eu-prleu-peupeu: array?
06:09:34 <eu-prleu-peupeu> i dont use arrays in haskell :P
06:09:55 <eu-prleu-peupeu> they ruin readability if things get nasty :/
06:10:00 <EvanR> morally speaking?
06:10:06 <eu-prleu-peupeu> eheh yes :D
06:10:19 <EvanR> should be the fastest no?
06:10:30 <eu-prleu-peupeu> i dont know :/
06:10:43 <eu-prleu-peupeu> ive heard bout this "uvector" stuff recently, it seems pretty fast
06:10:45 <opqdonut> for read only acces yeah I guess
06:10:48 <EvanR> input set would have to be consecutive
06:11:10 <dons> hence you need a trie-like structure, such as IntMap or Judy.
06:11:19 <opqdonut> heh, Judy
06:11:37 <reltuk> if I'm shuffling relatively small lists, can anyone give me an intuition as to whether it's going to be faster to convert to STArray and do an imperative shuffle than to use oleg's random-shuffle?
06:11:51 <reltuk> relatively small == < 60 elements
06:11:54 <reltuk> but I'm doing it a not...
06:11:57 <dons> are they a bottleneck?
06:12:09 <reltuk> dons about 30% of the programs runtime
06:12:09 <SamB_XP> reltuk: how about you time it both ways ?
06:12:15 <dons> ok. then yeah, prob worth it.
06:12:17 <eu-prleu-peupeu> one of my mission in life is to evangelize haskell to mamals of the human species that are of the female sex
06:12:22 <|Jedai|> eu-prleu-peupeu: I like arrays in Haskell, they're great for dynamic programming
06:12:25 <eu-prleu-peupeu> the other is to avoid arrays
06:12:31 <SamB_XP> eu-prleu-peupeu: why human ?
06:12:44 <reltuk> SamB_XP yeah, I will if I write the imperative shuffle :-
06:12:49 <eu-prleu-peupeu> SamB_XP: i tried with my cat, it didn't work very well
06:13:03 <SamB_XP> reltuk: ah, right, you don't have that yet ;-)
06:13:07 <SamB_XP> didn't think of that
06:13:44 <EvanR> any tips on writing a mud in haskell, do i need advanced monad magic
06:14:01 <|Jedai|> reltuk: the imperative shuffle should be dead simple anyway (Fisher-Yates is easy)
06:14:01 <opqdonut> basic stuff will probably be enough
06:14:10 <c_wraith> Technically, the only monad you *need* is IO
06:14:17 <Niccus> you can write an irc bot without any particularly magical things so it shouldn't be too tricky
06:14:18 <eu-prleu-peupeu> EvanR StateT
06:14:24 <opqdonut> have a simple IO core that does networking etc, everything else pure
06:14:29 <elben> So I'm trying to comprehend monads. Importing Monad.Control.State, say I run "runState get 3". But get :: State s s. So when is "3" applied?
06:14:37 <EvanR> opqdonut: well theres the world state...
06:14:53 <reltuk> |Jedai|: yeah, I'm working on various other changes for the time being...and I'm not too familiar with STArray, so it'll take a while for me to get it right probably
06:14:54 <opqdonut> EvanR: which you can keep in an IORef
06:14:54 <c_wraith> @src State
06:14:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:14:57 <opqdonut> or MVar
06:15:17 <EvanR> StateT IORef MVar ... *gets the books*
06:15:30 <aavogt> @unmtl State String Int
06:15:30 <lambdabot> String -> (Int, String)
06:15:33 <|Jedai|> elben: 3 is never applied since it's a number, not a function ;)
06:15:34 <c_wraith> elben:  the state monad encapsulates a function.  calling runState unwraps the function, which is then applied to 3
06:16:53 <elben> i think it would be helpful if i can read the get implementation. is there a way of doing this online?
06:16:59 <|Jedai|> @unmtl State state returnValue
06:17:00 <lambdabot> state -> (returnValue, state)
06:17:16 <c_wraith> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html
06:17:20 <|Jedai|> elben: get == State (\s -> (s,s))
06:17:39 <dons> EvanR: no, should be straight forward
06:17:39 <dons> start with maybe the irc bot tutorial
06:17:51 <robin> www.ugotit.ca
06:17:53 <eu-prleu-peupeu> what about mapping String keys to Ints ?
06:18:23 <dons> Map or Judy.
06:18:24 <EvanR> dons: okay
06:18:26 <elben> c_wraith, |jedai|: thanks! that's what i needed
06:18:26 <eu-prleu-peupeu> ill just use Map :P
06:18:41 <DrSyzygy> ddarius: True.
06:20:55 <eu-prleu-peupeu> thanks dons
06:21:01 <eu-prleu-peupeu> judy seems "faster"
06:21:51 <eu-prleu-peupeu> i dont like adding extra dependencies in haskell projects
06:22:07 <eu-prleu-peupeu> keeping things to the minimum seems the way to go
06:22:27 <|Jedai|> eu-prleu-peupeu: it is ! if it's adapted to your usage and you want something fast, Judy is the way to go
06:22:29 <eu-prleu-peupeu> or when ghc 6.12 comes out, ill be stranded
06:29:32 <dons> eu-prleu-peupeu: it will be faster for large data sets.
06:29:38 <dons> and you said you only had a small data set.
06:30:52 <eu-prleu-peupeu> yes, its no big deal
06:31:07 <eu-prleu-peupeu> im reading on julia arrays
06:31:09 <eu-prleu-peupeu> this is great stuff
06:31:12 <eu-prleu-peupeu> l33t
06:31:56 <dct25> Hello all
06:32:28 <dct25> I'm very new to Haskell and I'm having trouble understanding its performance characteristics
06:32:43 <dons> in what sense?
06:32:45 <dct25> Take, for example, project Euler's problem 14
06:33:04 <dct25> the naive solution in C works in 4.5 secs on my machine here
06:33:07 <dons> ok.
06:33:26 <dct25> see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13644 for my code
06:33:29 <EvanR> who benchmarks naive solutions
06:33:38 <dct25> the haskell code there takes about 3 minutes
06:33:40 <dons> ah, collatz
06:33:46 <dons> dct25: firstly, what compiler are you using?
06:34:00 <dct25> ghc 6.8.2
06:34:15 <dons> ok. good. and using ghc -O2 to compile?
06:34:24 <dct25> ah, no. I will try that, hang on.
06:34:39 * hackagebot upload: explore 0.0.6.0 - Experimental Plot data Reconstructor (CetinSert)
06:34:41 <dons> then perhaps look at some samples, http://www.haskell.org/haskellwiki/Euler_problems/11_to_20#Problem_14
06:34:48 <dons> also, then look at using the same data structures as you use in C.
06:35:02 <dons> if you use the same structure and algorithms, you'll get the same performance, essentially.
06:35:17 <dons> if you use something with very different characteristics, say, lazy linked lists, you can get quite different results
06:35:34 <dons> but ghc -O2 should be your default :)
06:35:39 <eu-prleu-peupeu> why is there always a penalty associated with lazyness ?
06:35:50 <eu-prleu-peupeu> i find it a very usefull feat.
06:36:13 <dct25> I don't think it's a data structures problem - the C version is just loops and (as far as I can tell) the Haskell version is all tail recursive
06:36:26 <dct25> Ok -O2 took it down to 42 secs
06:36:33 <dons> its written in a slightly weird style.
06:36:37 <dons> let me try refactoring your code.
06:36:46 <opqdonut> dct25: O2 makes arithmetic unboxed, usually
06:36:49 <opqdonut> which is a big gain
06:36:51 <dct25> please do :)
06:37:04 <dons> you just want a translation from the C?
06:37:13 <dct25> that's what I was aiming for
06:37:38 <dct25> but then when that was painfully slow I tried the cached version (also on hpaste)
06:37:38 <dons> have a look at the examples on the link above, btw. you might try benchmarking them.
06:37:55 <zygoloid> tail recursion isn't always what you want for best performance
06:38:17 <eu-prleu-peupeu> why zygoloid ?
06:38:29 <eu-prleu-peupeu> i thought tail recursion was the way to go...
06:38:40 <koeien37> in strict functional languages, that's true
06:38:41 <zygoloid> because it often means building a big thunk then evaluating it
06:40:20 <koeien37> @src foldl
06:40:20 <lambdabot> foldl f z []     = z
06:40:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:40:32 <pa_> zygoloid: is there a difference in amortized characteristics?
06:40:32 <koeien37> > foldl (+) 0 [1..500000]
06:40:33 <lambdabot>   * Exception: stack overflow
06:41:20 <EvanR> is the documentation for Network out of date, or is ipv6 not supported
06:44:30 <yowgi> > foldl' (+) 0 [1..500000]
06:44:32 <lambdabot>   125000250000
06:45:25 <scalaLove> why does this code give me error : type Side = Double
06:46:44 <Lemmih> scalaLove: It doesn't.
06:46:47 <scalaLove> lambdabot: type Side = Double
06:47:00 <eu-prleu-peupeu> i love haskell
06:47:08 <eu-prleu-peupeu> and i love you all
06:47:35 <scalaLove> Lemmih: hmm... i am executing it in terminal in ubuntu and i get : parse error on input `type'
06:47:41 <|Jedai|> scalaLove: You can't define new data types or even type synonyms in GHCi if that's what you're trying to do ?
06:47:49 <Lemmih> scalaLove: lambdabot/ghci is for expressions only. What you pasted is a declaration.
06:48:20 <scalaLove> no errors in terminal in ghci not here
06:48:57 <dons> dct25: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13649#a13649
06:49:04 <dons> dct25: direct translation from C. "same" performance.
06:49:08 <dons> (i.e. 0.6s)
06:49:18 <jmcarthur> scalaLove: that will not work in ghci
06:49:22 <scalaLove> i write ghci in terminal and all fine it starts and executes expressions and all that , but why does that command show eror: parse error on input `type'
06:49:36 <scalaLove> why jmcarthur
06:49:37 <jmcarthur> scalaLove: you have to put that into a file and then compile it or load it into ghci
06:49:43 <dons> you can't enter anything but expressions at the repl.
06:49:48 <jmcarthur> scalaLove: because it's not an expression
06:49:57 <ben> scalaLove: ghci evaluates expressions, you cannot put declarations
06:49:57 <|Jedai|> scalaLove: the normal flow of an Haskell development for me is to put most declaration in modules and load them in GHCi from time to time to check it typechecks and your functions seems to behave (you would add a test framework around to gain more insurance of that of course)
06:49:58 <Lemmih> scalaLove: Because 'type Side = Double' is a declaration. Ghci only understands expressions.
06:50:12 <dons> dct25: let me know what you think.
06:50:20 <kmc> ghci evaluates IO-monad "do" statements
06:50:27 <dct25> dons: Thanks. I will look hard at it
06:50:29 <dct25> :)
06:50:43 <scalaLove> i am so confused
06:51:04 <scalaLove> why is this so, some limitation on it because it is purely functional?
06:51:22 <dons> no, other haskell interpreters have historically provided types and other defns at the repl.
06:51:27 <dct25> The three examples on haskell.org run about the same speed as my code (~50sec for the uncached one and ~7 sec for the cached one)
06:51:30 <eu-prleu-peupeu> i usually find myself having an "id :: Int" in all my data types, and then relating to then through IntMaps
06:51:33 <eu-prleu-peupeu> is this a common practice ?
06:51:34 <dons> there is some tension though between the sequential nature of the repl
06:51:42 <dons> and the fact haskell doesn't have a define evalluation order.
06:51:42 <dct25> Bye for now
06:51:47 <eu-prleu-peupeu> ...i feel that im "reinventing" C pointers :/
06:51:54 <dons> dct25: well maybe i'll put my 0.6s one up
06:52:10 <jmcarthur> eu-prleu-peupeu: that doesn't even type check...
06:52:19 <Esmil> dons: What does the ! before arguments mean?
06:52:22 <jmcarthur> eu-prleu-peupeu: oh wait, i see what you mean
06:52:31 <eu-prleu-peupeu> :)
06:52:33 <kmc> eu-prleu-peupeu, depends what you're doing
06:52:36 <jmcarthur> eu-prleu-peupeu: it's not entirely uncommon. whether it's a good idea just depends
06:52:39 <kmc> maybe you should use references of some kind instead
06:52:41 <kmc> maybe not
06:53:05 <dons> Esmil: its a bang pattern. makes that value strict, so ensures we get a tail recursive loop from ghc, as well as changing the representation of the values to be raw machine ints
06:53:20 <|Jedai|> eu-prleu-peupeu: Well it's a common practice in the DB world anyway ;)
06:53:21 <eu-prleu-peupeu> well
06:53:29 <Esmil> dons: Ahh, cool. An "I know better" hack :)
06:53:41 <EvanR> eu-prleu-peupeu: you are writing a db? sounds like youre on the right track ;)
06:54:04 <ddarius> "In the spirit of teaching an almost 20 year-old dog new tricks, Jacqueline Addesa, a student from Virgina Tech, presented her argument for using the open source Haskell, a language usually reserved for big commercial applications, in an HPC setting."
06:54:04 * EvanR hates databases
06:54:05 <eu-prleu-peupeu> something like "data Stuff = Stuff { id :: Int, ...", i mean i could use Map Stuff Whatever ...
06:54:17 <dons> Esmil: yeah, normally you don't think about telling the compiler the evaluation order, or the data representation, but you can.
06:54:34 <eu-prleu-peupeu> but wouldn't it be "recreating" the data types again and again ? :/
06:54:36 <dons> ddarius: the blogger got a weird impression of the original article, imo.
06:54:38 <SamB_XP> ddarius: normally reserved for WHAT now ?
06:55:05 <dons> ddarius: compare with jacqueline's abstract, http://scyourway.supercomputing.org/conference/view/spost112_1
06:55:16 <kmc> someone hpasted this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5270#a5270
06:55:17 <ddarius> dons: I read that too.
06:55:21 <phr> @hoogle ReadMode
06:55:21 <lambdabot> System.IO ReadMode :: IOMode
06:55:21 <kmc> are those Types.* modules from some package?
06:56:24 <kmc> i don't think of web services as the premier commercial application of haskell
06:56:29 <|Jedai|> ddarius: where did you read this exactly ?
06:56:40 <kmc> hardware design, embedded systems metaprogramming, and financial analytics come to mind
06:56:47 <ddarius> |Jedai|: http://www.genomeweb.com/blog/more-bio-hpc-highlights-sc09
06:56:54 <dons> dsls have been where most of the money is.
06:57:25 <eu-prleu-peupeu> kmc: i feel haskell could be used in anything, since its so fgreat!
06:57:42 <dons> have you released any haskell code on hackage yet, eu-prleu-peupeu ?
06:57:55 <eu-prleu-peupeu> no
06:58:03 <dons> that's a pity. you've been here for a long time.
06:58:08 <kmc> it's a question of which projects you need to mention to convince people it's not just a toy
06:58:10 <eu-prleu-peupeu> i only do haskell at work though
06:58:20 <eu-prleu-peupeu> well, most of the time ive been trolling :)
06:58:43 <kmc> people here often say "darcs and xmonad" but i don't find that persuasive
06:58:51 <dons> bluespec, cryptol, paradise, atom.
06:58:56 <kmc> yes
06:59:06 <dons> how many millions do the big commercial places have to make from this before they count? :)
06:59:22 <kmc> what's paradise?
06:59:22 <Nafai> Any fun Haskell-ish stuff going on in the Bay Area the next two weeks??
06:59:23 <dons> darcs and xmonad are nice open source apps. name some desktop ruby?...
06:59:27 <dons> credit suisse's dsl.
06:59:31 <|Jedai|> ddarius: Yay, I love when bloggers don't feel like checking the facts and just infer what those language they don't know are like
06:59:44 <EvanR> until steve balmer understands haskell it wont be taken seriously *runs*
06:59:46 <dons> gitit and pandoc are also good open source.
06:59:55 <dons> MS funds a lot of haskell.
07:00:44 <SamB_XP> eu-prleu-peupeu: so, you could release some trolling-related libraries!@
07:00:55 <kmc> darcs and xmonad are excellent programs, but fairly niche.  you couldn't use them to convince your boss that haskell is worth taking seriously.  whereas the dsls dons mentioned are used for pretty serious stuff in industry
07:01:01 <kmc> @protontorpedo
07:01:02 <lambdabot> why haskell over say smalltalk
07:01:08 <eu-prleu-peupeu> kmc, at work i do quite some webservices, credit cards generation, proprietary databases abstraction...
07:01:17 <mxyz> dons: do they? it'd be nice if they funded some cross platform libraries too :)
07:01:18 <kmc> all in Haskell?
07:01:21 <eu-prleu-peupeu> sure its small things, but i like working them out in haskell
07:01:43 <eu-prleu-peupeu> all of these stuff are in haskell
07:01:50 <dons> mxyz: they've been funding ghc development for a decade. and more recently, data parallel haskell, threadscope, ...
07:01:53 <kmc> hmm credit card generation
07:01:55 <eu-prleu-peupeu> i replaced quite some java code they had there :/
07:02:10 <dons> kmc: right, so cite industrial use cases, not open source ones.
07:02:19 * jmcarthur is writing a proposal for a haskell project where he works
07:02:35 <kmc> dons, atom is open source isn't it?
07:02:35 <mxyz> dons: i know a lot of haskell programmers (like spj) work at ms research but i didn't realize ms funded that stuff
07:02:37 <kmc> and also industrial
07:02:40 <dons> right.
07:02:50 <eu-prleu-peupeu> credit card generation is easy... just reading data from odbc mangling it and dumping it in a defined way for the machines to read it
07:02:53 <dons> its the industrial use though that hits home.
07:02:56 <dons> eu-prleu-peupeu: off topic.
07:03:02 <Fredderf> @pl floor . sqrt . fromIntegral
07:03:03 <lambdabot> floor . sqrt . fromIntegral
07:03:04 <eu-prleu-peupeu> sorry :D
07:03:23 <kmc> eu-prleu-peupeu, it's quite nice to generate new credit cards especially if they have a high credit limit and are in someone else's name ;)
07:03:44 <jlouis> The question wether a given programming language is useful for "real world programming" is like the question "Are green birds blue?" :)
07:03:59 <kmc> jlouis, how?
07:04:15 <jlouis> both are wierd
07:04:41 <eu-prleu-peupeu> kmc, i dont do that... that is the bank part, generating a credit card is bank independent
07:04:49 <|Jedai|> jlouis: Why, I don't think Brainfuck is suited to "real world programming" for instance ^^
07:05:20 <eu-prleu-peupeu> hmm, who wants to write a brainf*ck parser in haskell ? :)
07:05:22 <eu-prleu-peupeu> are there ?
07:05:26 <jmcarthur> there are tons
07:05:29 <eu-prleu-peupeu> oh
07:05:36 <jmcarthur> we even have it in lambdabot
07:05:46 <|Jedai|> eu-prleu-peupeu: You can bet there already are lots
07:05:52 <kmc> bf is almost trivial to parse
07:06:00 <jmcarthur> almost?
07:06:09 <jlouis> |Jedai|: That is true, my statement should be modulo the turing tarpit
07:06:17 <eu-prleu-peupeu> lets write an haskell parser in haskell ? :D
07:06:24 <kmc> been done
07:06:27 <jmcarthur> done
07:06:29 <Niccus> be creative write a befunge parser
07:06:34 <jmcarthur> ooh
07:06:40 <jlouis> I wrote a brainfuck interpreter twice in Coq and proved them equivalent
07:06:40 <kmc> be creative, create your own language ;P
07:06:41 <eu-prleu-peupeu> lets write an OCaml parser in Haskell ?
07:06:43 <ben> Challenge yourself, write a perl parser.
07:06:47 <kmc> jlouis, haha
07:07:01 <jmcarthur> ben: win
07:07:02 <jlouis> kmc: part of my bachelor thesis from a couple of years ago
07:07:28 <|Jedai|> jlouis: I still thinks it's a valid question, there are lots and lots of languages around, most are pretty flawed
07:07:44 <scalaLove> in a book i read it says haskell is faster then more programs two to ten times, anyone can share experience comparing haskell vs other?
07:07:51 <kmc> what
07:08:02 <|Jedai|> ben: it's impossible, well, without rewriting the Perl interpreter with it
07:08:06 <dons> scalaLove: that question doesn't make sense. can you rephrase?
07:08:29 <dons> @protontorpedo
07:08:30 <lambdabot> why haskell over smalltalk? I thought smalltalked rocked
07:08:48 <jlouis> |Jedai|: true. But people come pretty well along writing software in them.
07:08:49 <scalaLove> dons: it says characteristic of haskell is CONCISE PROGRAMS, programs written in it are faster 2 to 10 times then programs writen in other language
07:09:09 <jlouis> 2 to 10 times smaller perhaps?
07:09:09 <eu-prleu-peupeu> it depends on the programmer
07:09:13 <ben> Haskell programs are shorter, so writing them is faster
07:09:19 --- mode: ChanServ set +o dons
07:09:22 <eu-prleu-peupeu> and if you use foldl instead of concatMap :P
07:09:33 <dons> scalaLove: you remind me a lot of gschuett
07:09:39 <Fredderf> @src on
07:09:40 <lambdabot> (*) `on` f = \x y -> f x * f y
07:09:55 <Rayne> i asked the question some hours ago, but forgot to backup the log: how do i "convert" IO String to String? (=> lines (readFile x))
07:09:56 <scalaLove> i am wrong yeah it says SHORTER not FASTER
07:10:04 <|Jedai|> scalaLove: Haskell is compiled and good Haskell is pretty fast, most of the time it's not C level but it's league beyond the dynamic interpreted languages (Perl/Python/PHP/Ruby...)
07:10:33 <|Jedai|> Rayne: You can't convert IO String to String
07:10:46 <sjanssen> Rayne: rather than convert, you lift the rest of your program into IO
07:10:50 <eu-prleu-peupeu> i wish someone could do a Python VM implementation in haskell :(
07:10:59 <sjanssen> Rayne: in your example, youd "fmap lines (readFile x)"
07:11:05 <jmcarthur> someone *could*
07:11:23 <|Jedai|> Rayne: What you can do is lift a function into IO to handle the String you'll get when the IO action is executed
07:11:26 <sjanssen> Rayne: or "do f <- readFile x; return (lines f)"
07:12:04 <eu-prleu-peupeu> CPython is very slow
07:12:18 <eu-prleu-peupeu> oh well, back to maps
07:12:33 <|Jedai|> eu-prleu-peupeu: Unladen Swallow is trying to do something about that though
07:13:00 <scalaLove> The Haskell type system is also more powerful than most current languages, by allowing functions to be “polymorphic” and “overloaded”. THIS IS FROM A BOOK... hmm I wonder dont other languages offer polymorphism and overloading too? how can it say more powerfull when...? am i missing something?
07:13:26 <koeien37> scalaLove: what book are you reading?
07:13:43 <scalaLove> programming in haskell
07:13:46 <jlouis> scalaLove: polymorphism in CS is an ambigous word. It means different things to different people.
07:14:05 <chrisdone> in what form is overloading available in haskell?
07:14:09 <scalaLove>                                         The Haskell type system is also
07:14:12 <scalaLove> more powerful than most current languages, by allowing functions to be
07:14:13 <scalaLove> “polymorphic” and “overloaded”.
07:14:16 <|Jedai|> scalaLove: polymorphism in Haskell is parametric prolymorphism, not that well supported by most mainstream programming language until recently (Generics in Java are a poor tentative at it on the Java side)
07:14:18 <gwern> I wonder if anyone has ever tried used genetic algorithms to evolve better glyphs for the alphabet
07:14:24 <sjanssen> chrisdone: type classes and also parametric polymorphism
07:14:25 <|Jedai|> chrisdone: typeclass, no ?
07:14:27 <MHD> What would #haskell do if we had the source code of an AI on our hands?
07:14:41 <aavogt> @arr
07:14:41 <lambdabot> Swab the deck!
07:14:41 <gwern> MHD: golf it and put it on hackage
07:14:44 <Botje> @vixen are you an AI?
07:14:45 <chrisdone> sjanssen: isn't that just polymorphism? why call it two things?
07:14:46 <lambdabot> i truely am
07:14:56 <Botje> MHD: looks like we've already done this :)
07:15:05 <|Jedai|> gwern: Well, that's what happened for the 6000 years of history, no ?
07:15:15 <MHD> Has lambdabot ever passed the Turing test?
07:15:25 <gwern> |Jedai|: hah! any sane optimization process wouldn't have given us m and n, or v and w
07:15:29 <gwern> or p and d
07:15:32 <sjanssen> chrisdone: both type classes and parametric polymorphism are different from the way you get polymorphism in eg. Java
07:15:42 <scalaLove> noone can say why haskell, as so said in the book, has more powerfull type system then rest of langs?
07:15:52 <kmc> |Jedai|, "Haskell is compiled" is a nonsense statement
07:15:52 <EvanR> i once heard the overloading of c++ methods base on argument type called 'parametric polymorphism' is this wrong or just jargon collision
07:15:59 <kmc> Haskell can be compiled
07:16:18 <|Jedai|> gwern: probably the optimisation function is somehow lacking, at least we still have a pretty good variety
07:16:23 <ray> pedantry is what is nonsensical
07:16:33 <sjanssen> EvanR: I'd bet on jargon collision, but the speaker might have been misusing the term, hard to say
07:16:39 <Botje> @vixen did you get your Turing license yet?
07:16:40 <lambdabot> isn't it obvious?
07:16:48 <Botje> :)
07:16:51 <Botje> @botsnack
07:16:52 <lambdabot> :)
07:16:52 <lunabot>  :o
07:16:53 <|Jedai|> kmc: Ok... GHC, the main Haskell implementation is a compiler and does a pretty good job
07:16:58 <kmc> yeah
07:17:06 <jmcarthur> scalaLove: we could give you a shopping list of features, but it wouldn't mean anything to anybody not willing to learn what they mean
07:17:15 <jmcarthur> i'm not trying to imply anything by that
07:17:22 <kmc> pedantry whatever, it's important to be precise about these things
07:17:22 <Rayne> if i define "contents <- readFile x;" and then call contents <- fmap lines (contents); it throws an error. why i am not able to do this?
07:17:32 <jmcarthur> it just the reason i don't really try to explain the benefits too concretely
07:17:33 <Rayne> different typ in contents?
07:17:41 <koeien37> Rayne: contents is of type String
07:17:41 <kmc> Rayne, you can't redefine the same name
07:17:45 <ben> yes you can
07:17:47 <ben> Rayne: contents is not IO anymore
07:17:55 <Rayne> ic
07:17:57 <koeien37> Rayne: not of type IO String
07:18:03 <ben> You do not <- it, use let contents2 = lines contents
07:18:08 <scalaLove> jmcarthur: i think the statement is overrated, more powerfull type system then others... i cant see that
07:18:09 <|Jedai|> scalaLove: we can say that Haskell has higher-order polymorphism, existentials, GADT, typeclass, type families, ....
07:18:16 <Rayne> redefining is not possible in haskell?
07:18:27 <koeien37> Rayne: shadowing.
07:18:30 <kmc> hmm actually it should work, by shadowing
07:18:32 <Twey> IORefs allow it, too
07:18:58 <koeien37> let x = x + 1 would just loop though (when x is evaluated.)
07:18:58 <kmc> that's not really a redefinition
07:18:58 <jmcarthur> scalaLove: like i just said, we could throw a load of jargon into the air, but that's not a proper explanation
07:19:06 <|Jedai|> scalaLove: but I don't think that means anything to you yet... so just don't dismiss it out of hand before you know what the book is speaking about
07:19:15 <kmc> koeien37, right, that's a recursive definition
07:19:16 <koeien37> kmc: no, but if one wanted to say x := x + 1
07:19:17 <scalaLove> jmcarthur: throw some dont worry i am not noob
07:19:25 <koeien37> kmc: one might attempt this
07:19:27 <jmcarthur> scalaLove: but haskell is the only general purpose programming language i have ever used that so consistently yields working programs once i am finally able to compile them successfully
07:19:29 <koeien37> kmc: and get confused.
07:19:54 <Rayne> thanks for that information
07:19:57 <mxyz> why havent languages like python, perl, java, haskell pulled together to form a solid set of cross platform libraries (with different bindings)?
07:20:09 <chrisdone> jmcarthur: we need a name for that effect. I propose ``jojojingo!!''
07:20:12 <jmcarthur> mxyz: because they would just be C libraries?
07:20:23 <|Jedai|> scalaLove: did you understand any of the term I used ?
07:21:01 <scalaLove> Jedai all of them, but lot of languages have that
07:21:04 <EvanR> ...existentials?
07:21:20 <mxyz> jmcarthur: yea, but its frustrating that i have java and python installed and am using Leksah which uses Gtk and yet I still can't gtk2hs to install
07:21:26 <jmcarthur> scalaLove: what languages have type families? GADTs?
07:21:29 <|Jedai|> scalaLove: really ? GADT ? Higher-order polymorphism ? Type families ?
07:21:42 <chrisdone> one day I will muster the courage to record myself writing a contained haskell module to demonstrate this effect
07:21:46 <scalaLove> how about scala for start
07:21:49 <Fredderf> @pl \n -> length (primes n)
07:21:49 <lambdabot> length . primes
07:21:51 <eu-prleu-peupeu> http://www.haskell.com/
07:21:52 <jmcarthur> scala is a joke
07:21:55 <Fredderf> @pl \n -> length (primes !! n)
07:21:55 <lambdabot> length . (primes !!)
07:22:01 <jmcarthur> and doesn't have those features that i know of
07:22:03 <koeien37> Rayne: try to read this http://haskell.org/haskellwiki/Introduction_to_IO written by Cale
07:22:09 <|Jedai|> scalaLove: AFAIK it has none of those features
07:22:14 <dibblego> yes it does
07:22:18 <dibblego> it has higher-order polymorphism
07:22:25 <dibblego> but not GADTs or type families
07:22:26 <|Jedai|> scalaLove: it has others though
07:22:26 <jmcarthur> GADTs? type families?
07:22:28 <jmcarthur> ah
07:22:50 <dibblego> fwiw scalaLove doesn't know Scala very well
07:22:56 <|Jedai|> dibblego: oh, it has higher order polymorphism, interesting, how does it use them ?
07:23:03 <jmcarthur> type families are really changing the way i think about a lot of my code. i wish they were more heavily adopted
07:23:12 <|Jedai|> s/them/it/
07:23:32 <dibblego> |Jedai|, how do you mean? it's there as a language feature, I use it
07:23:47 <jmcarthur> actually, i wish type families was a fully completed extension in ghc...
07:23:53 <monochrom> I still haven't learned type families. If someone suddenly types in a whole tutorial into this channel I'll try to read it. <duck>
07:23:57 <jmcarthur> and constraint families will be nice to see some day
07:23:59 <Twey> Heh.
07:24:11 <|Jedai|> dibblego: Right, I was just curious at how it manifests in an hybrid OO/functional language
07:24:16 <monochrom> Oh, not yet fully done? That sucks.
07:24:18 <jmcarthur> monochrom: type families are to types what type classes are to functions, essentially
07:24:24 <eivuokko> Is there more than paper about constraint families?
07:24:31 <jmcarthur> monochrom: only a very rarely used corner case is not finished
07:24:39 <jmcarthur> at least that i have run into
07:24:40 <dibblego> |Jedai|, see the Scalaz project for heavy use
07:24:41 <sjanssen> monochrom: the haskellwiki page is pretty good, I'm sure you'd have a good grasp of them after reading that
07:24:45 <monochrom> Oh that's OK then. It no longer sucks. :)
07:24:57 <jmcarthur> something about equivalence constraints on type class instances or something
07:25:11 <dibblego> |Jedai|, Scala also has implicits (~= type-classes)
07:25:36 <scalaLove> yes it has implicits, both parameters and functions
07:25:52 <|Jedai|> dibblego: Yeah, I read something about typeclass in Scala recently (wasn't it by you ?)
07:25:58 <dibblego> |Jedai|, prolly :)
07:27:27 <|Jedai|> I don't remember but can you do Read with your approach ?
07:27:34 <mxyz> jokingly, i wonder if odersky was so bored why didnt he port haskell to the jvm?
07:27:43 <Twey> Type families sound interesting, but I don't understand them.  ;)
07:27:53 <jmcarthur> i can't wait to have constraint families
07:27:58 <jmcarthur> that will round it out
07:28:00 <scalaLove> so i should learn haskell before scala or the other way around? so far i know c,c++,python,prolog,scheme,java... Have experience with oop and imperative but very litle with functional languages
07:28:02 <dibblego> mxyz, Odersky has objections to Haskell (which I think are horribly ill-informed)
07:28:03 <Rayne> koeien, thanks for that link
07:28:25 <|Jedai|> Twey: They're quite straighforward actually, "just" functions on types
07:28:26 <mxyz> dibblego: so what, he decided to write a language more verbose than java and miss the point completely?
07:28:32 <ddarius> There would be a significant impedance mismatch between Haskell and Java.
07:28:47 <dibblego> mxyz, in my seemingly singly held opinion, yes
07:28:55 <sjanssen> scalaLove: in my opinion, Haskell is more of a functional language than Scala.  Scala is a bit more of a hybrid between several styles
07:28:56 <Fredderf> :t fromFractional
07:28:57 <lambdabot> Not in scope: `fromFractional'
07:29:02 <scalaLove> Martin is proffessor at EPFL, if you think bad of him and scala think again
07:29:15 <ddarius> Incidentally, Scala probably didn't exist at all when Programming in Haskell was written, similarly for C# or Java Generics.
07:29:41 <mxyz> i think odersky is pretty cool and i watch his videos on parleys, but i cant say i think scala is beautiful
07:29:45 <dibblego> ddarius, it was
07:29:48 <monochrom> I hate questions like "should I learn X first or Y first". You come to ask in #X and you already know the answer. Moreover, the only correct impartial answer is "concurrently".
07:30:15 <ddarius> Ah, Programming in Haskell is pretty new, nevermind then.
07:30:20 <ray> you should learn philosophy first, and derive everything else from it
07:30:28 <|Jedai|> scalaLove: I don't see how him being a professor at EPFL should prevent us from objecting to its realization ? Not that I "think bad of him" by the way, I'm just not very interested in Scala
07:30:38 <dibblego> ddarius, Java Generics were influenced by Pizza (Odersky), which was the predecessor to Scala
07:30:57 <ddarius> dibblego: I know that and I don't see what that has to do with what I said.
07:31:08 <mxyz> did pizza have reified generics?
07:31:14 <Fredderf> How can I convert from Fractional Int to Double?
07:31:20 <Twey> scalaLove: I think you should learn Scala first.
07:31:26 <scalaLove> ray that was good, i read a lot of philosophy but stoped, i got enough
07:31:27 <dibblego> ddarius, I may have misplaced the parentheses in your statement
07:31:27 * Twey dons his flame-proof armour.
07:31:31 <koeien37> Fredderf: you mean, Ratio Int?
07:31:50 <Twey> I feel that Scala would provide a nice introduction to a lot of concepts to make the (un-)learning curve for Haskell a little less steep.
07:31:59 <Fredderf>     No instance for (Fractional Int)
07:31:59 <Fredderf>       arising from a use of `/' at <interactive>:1:11-31
07:32:02 <koeien37> > let f :: Rational -> Double; f x = numerator x / denominator x in f (3%2)
07:32:03 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
07:32:03 <lambdabot>         against inferred ty...
07:32:05 <scalaLove> Twey thanks
07:32:10 <Twey> (while being similar enough to the Java you already know to not have such a steep learning curve itself)
07:32:19 <koeien37> > let f :: Rational -> Double; f x = fromIntegral (numerator x) / fromIntegral (denominator x) in f (3%2)
07:32:20 <lambdabot>   1.5
07:32:26 <koeien37> ^ may be easier.
07:32:31 <dibblego> I have experience teaching both Haskell and Scala first to people who have been exposed to poor habits and I am of the firm opinion that you are better off not learning anything than learning Scala
07:32:38 <koeien37> there may be an easie rmethod
07:32:47 <|Jedai|> Twey: I'm less than convinced, since Scala is pretty much a melting-pot and I always found that it was easier learning a new paradigm in a language that won't allow you to fall on your old habits
07:32:51 <ddarius> Haskell's type system is not comparable to most languages.
07:33:04 <Twey> |Jedai|: I suppose that's a point
07:33:13 <ddarius> dibblego: Ouch
07:33:13 <gnut> haddock: internal Haddock or GHC error: Cabal-Version:: openBinaryFile: does not exist (No such file or directory)
07:33:17 <koeien37> |Jedai|: yeah. first convert to the dark side
07:33:21 <gnut> what could be causing this error when compiling ghc?
07:33:33 <scalaLove> dibblego what do you mean
07:33:33 <Twey> dibblego: Oh, you're back!  I haven't seen you around much lately.  Hi ☺
07:33:42 <dibblego> g'day Twey :)
07:33:42 <|Jedai|> koeien37: then you'll never think of returning to the grey ?
07:34:01 <EvanR> so... filter or list comprehension... which is better
07:34:05 <koeien37> |Jedai|: :) and even if you do, you'll be better equipped
07:34:12 <dibblego> first-time Scala users simply go right ahead and make the same mistakes using the same bad habits they have always been doing
07:34:27 <mxyz> dibblego: so you think dijkstra'd be saying "whereas the teaching of Scala should be rated as a criminal offence: it mutilates the mind beyond recovery.", lol?
07:34:40 <Twey> EvanR: Depends what you want to do.
07:34:43 <|Jedai|> EvanR: neither, list comprehension are a very convenient syntax sugar in certain case though
07:34:50 <eivuokko> EvanR, for readibility, the one that is easier for you.  For learning, the one that looks wierd to you.
07:34:54 <dibblego> mxyz, I'd replace it with Java, then use the inability to appropriately use Scala as evidence :)
07:34:55 <scalaLove> dibblego so i should not learn scala nor haskell? then what?
07:35:00 <EvanR> eivuokko: hah
07:35:02 <Twey> EvanR: LCs are basically a combination of map + filter
07:35:13 <Twey> (and ‘sequence’ in cases)
07:35:19 <EvanR> so performance is the same, map/filter or LC
07:35:20 <|Jedai|> scalaLove: I don't think anybody here said that you shouldn't learn Haskell
07:35:22 <dibblego> scalaLove, I think it is inappropriate to "learn a language" -- languages are not topics to be learned
07:35:25 <Twey> If you have just one transformation, or one filter, map/filter is generally better
07:35:29 <Twey> Yes, performance is not an issue
07:35:58 <kmc> scalaLove, learn Haskell
07:36:12 <reltuk> are type variables from a methods signature available for type signatures inside the method?
07:36:15 <kmc> this is the haskell channel, what do you think we'd say
07:36:18 <scalaLove> dibblego, what does that mean
07:36:19 <kmc> reltuk, with an extension
07:36:26 <koeien37> reltuk: yes, if you have ScopedTypeVariables
07:36:31 <reltuk> brilliant!
07:36:35 <kmc> and if you explicitly quantify them with "forall"
07:36:42 <ddarius> EvanR: List comprehensions just desugar into maps and filters.
07:36:51 <EvanR> cool
07:37:01 <|Jedai|> ddarius: and concats (or rather concatMaps)
07:37:11 <reltuk> brilliant!
07:37:55 <Twey> ddarius: How does [ (x, y) | x <- xs, y <- ys, x == y ] desugar?
07:37:55 <EvanR> okay im going to implement a infinite list of the output of a lag1024 complementary multiply with carry generator...
07:37:56 <ddarius> |Jedai|: Well, it mostly desugars into concatMaps but GHC likely optimizes them into the identical code that maps and filters would produce (for the cases that correspond to maps and filters)
07:37:57 <reltuk> it's kind of sad that I don't know much haskell and my program uses all these extensions...
07:38:07 <mauke> @undo [ (x, y) | x <- xs, y <- ys, x == y ]
07:38:07 <lambdabot> concatMap (\ x -> concatMap (\ y -> if x == y then [(x, y)] else []) ys) xs
07:38:27 <Twey> reltuk: Hehe.  Don't worry, they'll mostly be standardised and made the default soon ;)
07:38:49 <Twey> (it's the peril of attempting to maintain default compatibility with a twelve-year-old standard)
07:39:22 <|Jedai|> scalaLove: I think languages are to be explored and used, learning a language just to have seen it is not as mind expanding as trying to use it for real. It's particularly true for a pure functional language like Haskell, so different from everything else
07:40:15 <Twey> Yeah, Haskell is a language where you can understand the language perfectly yet not understand programs written in it at all
07:40:23 <scalaLove> I am learning lot of languages, and i am aware best way to do it is implement a problem so i solve problems from euler project in scala now soon in haskell
07:40:25 <|Jedai|> scalaLove: and to be clear I'm not speaking about the type system here (since you seem unconvinced) but rather the purity of the functional paradigm and the lazy evaluation
07:40:50 <ddarius> Twey: That's true for every language.
07:40:55 <Twey> (i.e. the amount of stuff built into the language is small in comparison to the amount of weird and wacky stuff possible with it)
07:41:11 <Twey> ddarius: I'd say considerably less so for something like Java
07:41:12 <ben> s/possible/required/
07:41:16 <kmc> that's a good thing
07:41:20 <|Jedai|> reltuk: ScopedTypeVariable has done the final cut, it will be in Haskell' (or rather the 2010 release of Haskell')
07:41:21 <Twey> Yes, it certainly is
07:41:59 <Twey> ddarius: In Java, a lot more of the language's functionality is built into the core language definition, rather than built up on top of it
07:42:37 <ddarius> Twey: And in brainfuck, much less is built into it and the programs are much harder to understand.
07:43:16 <Rayne> addLines (x:xl) i = [(i :: String) : x] ++ xl <- how do i convert `i` to string? (i know that this function is stupid like hell, but i have no idea how to improve it)
07:43:25 <kmc> (show i)
07:43:45 <Rayne> ah, thanks
07:43:53 <EvanR> so lets say i want to create a list which begins with r numbers, and each element after that depends on the element r before it in the list. ive seen the fib sequence done sort of like this except r = 1, what if it isnt 1
07:43:54 <|Jedai|> ddarius: I think Brainfuck isn't really a good exemple of balance between built-in and extensibility...
07:44:05 <kmc> Rayne, (e :: t) is not a cast or a conversion
07:44:06 <ddarius> Rayne: foo :: T has no operational behavior
07:44:17 <kmc> it's just an annotation that e has type t
07:44:17 <Rayne> oh, i see :/
07:44:22 <kmc> which the compiler probably knows anyway
07:44:35 <kmc> or which could be false ;P
07:44:43 <aavogt> type annotations can speed up compilation?
07:44:50 <eivuokko> Never.
07:44:51 <koeien37> in which case you get a type error
07:44:53 <aavogt> they do for happy grammars in some cases
07:45:10 <eivuokko> They do?
07:45:20 <aavogt> I read it in the happy manual
07:45:20 <eivuokko> ahf, right.
07:45:23 <aavogt> ;)
07:45:30 <eivuokko> Damn this autocompletion.
07:45:45 <ddarius> aavogt: I don't think the difference one way or the other (and I'm pretty sure it can be both) is noticable except perhaps in generated code instances and some pathological cases.
07:46:55 <|Jedai|> EvanR: Well, that really depends, you could as well be asking for iterate, for scanl or for fix from what you've told us. More details ?
07:46:56 <eivuokko> Yeah, well, they don't speed up typechecking, anyway.
07:47:03 <|Jedai|> > take 10 $ iterate (*2) 1
07:47:04 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
07:47:26 <EvanR> fib = 1:1:[a+b|(a,b)<-zip fib (tail fib)] right? what if instead of needed x[-1] and x[-2] i needed x[-r] which in my case is 1024
07:47:48 <|Jedai|> EvanR: r fixed ?
07:47:50 <EvanR> yes
07:48:02 <ddarius> EvanR: Then just pad with 1024 starting elements.
07:48:11 <EvanR> oh duh
07:48:28 <eivuokko> Well, I guess even that is wrong, hmm, as annotations can cause less instance chasing.
07:48:52 <|Jedai|> > let stuff = [1..10] ++ zipWith (+) (drop 3 stuff) (drop 4 stuff) in take 20 stuff
07:48:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,9,11,13,15,17,19,19,20,24,28]
07:49:21 <EvanR> next question, as i evaluate the list, it will grow and grow, but what if i only care about the last 1024 and would rather this 'forget' the stuff before
07:49:26 <|Jedai|> EvanR: was it something like that ?
07:49:41 <Rayne> a snippet from my code: contents <- fmap lines (readFile x); return (addLines contents 0); works, but how could i write it in more lines like "fmap lines variable" and "return variable"?
07:49:51 <Twey> 23:42:46 < ddarius> Twey: And in brainfuck, much less is built into it and the programs are much harder to understand.
07:49:53 <Twey> ddarius: Yes
07:49:55 <Rayne> is this possible? i think in some cases it is not possible to write it so short?
07:50:23 <koeien37> Rayne: fmap (addLines contents 0 . lines) (readFile x) or so
07:50:30 <Twey> (though that's for a different reason: there isn't more stuff built on top of the language, everyone just uses the few features that are built in)
07:50:34 <koeien37> ehm, no. this is wrong.
07:50:37 <ddarius> EvanR: If the whole list isn't accessible, only what reachable will be kept.
07:50:40 <|Jedai|> EvanR: the "last" 1024 ? the list is infinite, you can't have the lasts elements ! Or do you mean that you only needs 1024 consecutive elements at the same time ?
07:50:55 <EvanR> wow, and yes
07:51:01 <EvanR> that is nifty
07:51:06 <koeien37> @pl fmap lines (readFile x) >>= (\contents -> return (addLines contents 0))
07:51:06 <lambdabot> flip addLines 0 `fmap` fmap lines (readFile x)
07:51:20 <koeien37> Rayne: ^
07:51:42 <koeien37> fmap (flip addLines 0 . lines) (readFile x)
07:51:50 <ddarius> koeien37: I think you went the wrong way.
07:52:11 <EvanR> Jedai: if the sequence is a random number generator, i suppose i take them one at a time. i only care about 1 at a time, but internally it needs 1024 previous elements to generate the next one.
07:52:22 <|Jedai|> EvanR: don't forget to make sure that the head of the list isn't available any longer, if not, Haskell will have to keep it whole in memory
07:52:36 <EvanR> that makes sense, good to know
07:53:19 <koeien37> also the reason that avg xs = sum xs / length xs  takes O(n) space
07:54:23 <EvanR> Jedai: if the head is typed literally into the definition of the list, does that count as available?
07:55:54 <Rayne> yeah, haskell has great potential to confuse me :)
07:55:57 <Rayne> thanks for the help!
07:56:33 <|Jedai|> EvanR: like in my definition ? no, if you do the evaluation by hand you'll see why. Of course if you put my definition on the top-level stuff will always be available to everyone and so will never be GC, you have to put it in a more local scope
07:56:55 <EvanR> ill try to write it out in full and paste it
07:58:40 <scalaLove> why do computer scientists study logistics?
07:58:54 <ben> If they did not, they would go crazy
07:58:55 <|Jedai|> EvanR: the point is that "drop 4 stuff" won't keep stuff around, it'll not point before the first 4 elements of the list, and then zipWith will "forget" pairs of elements too
07:59:02 <phr> @src ReadMode
07:59:02 <lambdabot> Source not found. Where did you learn to type?
07:59:07 <phr> :t ReadMode
07:59:08 <lambdabot> Not in scope: data constructor `ReadMode'
07:59:35 <|Jedai|> phr: it's just a contructor of an algebric data type
07:59:36 <benmachine> @type System.IO.ReadMode
07:59:37 <lambdabot> GHC.IOBase.IOMode
07:59:38 <phr> i want to open a file in read mode, but "import System.IO (openFile, IOMode)" or "import System.IO (openFile, ReadMode)" doesn't export the ReadMode constructor.
07:59:38 <eivuokko> scalaLove, Logic or logistics?
07:59:49 <scalaLove> logistics
08:00:05 <benmachine> phr: import System.IO (openFile, IOMode (ReadMode))
08:00:17 <benmachine> or, IOMode (..) to get all constructors
08:00:22 <Lemmih> phr: (IOMode(ReadMode))
08:00:22 <phr> oh, thanks!
08:00:22 <aavogt> the tsp is a logistics problem, no?
08:00:22 <|Jedai|> phr: IOMode(ReadMode)
08:00:22 <|Jedai|> phr: or IOMode
08:00:32 <eivuokko> They don't always study that.  But it's a field with plenty of opportunities for computerised solutions.
08:00:34 <phr> IOMode by itself doesn't do it
08:00:43 <phr> but IOMode(ReadMode) worked
08:00:55 <|Jedai|> phr: right, that just imports the type
08:01:01 <benmachine> IOMode(..) should work too and get you WriteMode or whatever else
08:01:31 <Rayne> how do i make this function to work as `lineNumbers :: String -> String -> IO String ()`? http://pastie.org/private/vbtlsm8wvoejv8ond87ulw
08:01:33 <phr> benmachine, yeah, i'm trying the style of just importing the minimal set of necessary symbols
08:01:57 <benmachine> phr: good!
08:02:14 <benmachine> I try to
08:02:19 <koeien37> Rayne: do you get an error message?
08:02:24 <benmachine> but sometimes it gets too long
08:02:46 <Twey> That's when I use qualified imports ;)
08:03:41 <Rayne> koeien, yes, added the error: http://pastie.org/private/vbtlsm8wvoejv8ond87ulw
08:04:21 <dibblego> Rayne, your error seems to correlate to a commented line
08:04:43 <Rayne> dibblego, updated the source, sorry
08:04:54 <phr> i wish i could put more than one module in a file.  i want to protect the constructor of a certain datatype so the type can enforce an invariant
08:04:54 <koeien37> but "IO String ()" is not a valid type
08:04:55 <dibblego> Rayne, but you cannot apply IO to two type variables -- it takes only one
08:04:59 <koeien37> IO is of kind * -> *
08:05:12 <koeien37> this means you must apply it to precisely one type (or type variable) to get a type.
08:05:12 <phr> but don't want to make a separate file for 5 lines of code
08:05:21 <|Jedai|> Rayne: numberLines from to = readFile from >>= writeFile to . concat . zipWith (\i l -> show i ++ " : " ++ l) . lines
08:05:31 <koeien37> so IO String is an I/O action that eventually returns a String
08:05:36 <koeien37> but what would "IO String ()" be ?
08:05:43 <FunctorSalad> kind error
08:06:02 <koeien37> yes, i know :)
08:06:02 <Twey> Hehe
08:06:08 <Rayne> i have no idea about this definition but i have to use it
08:06:11 <|Jedai|> Ooops : numberLines from to = readFile from >>= writeFile to . concat . zipWith (\i l -> show i ++ " : " ++ l) [1..] . lines
08:06:15 <FunctorSalad> sorry didn't read the context :)
08:06:18 <Rayne> i would just use function -> String -> String
08:06:20 <koeien37> Rayne: which definition?
08:06:26 <Twey> Rayne: You can't
08:06:28 <Twey> Rayne: It's broken
08:06:32 <Twey> It won't compile
08:06:38 <Rayne> lineNumbers :: String -> String -> IO String ()
08:06:49 <koeien37> that is impossible
08:06:54 <koeien37> that is not a valid type
08:07:07 <EvanR> Jedai: comments, tips, help, http://pastebin.com/m70a88bd8
08:07:10 <|Jedai|> Rayne: You want "String -> String -> IO ()"
08:07:19 <Rayne> my tutor wants me to want it
08:07:27 <Twey> Unless your teacher has reïmplemented the IO monad for pædagogical purposes ;)
08:07:29 <koeien37> Rayne: then your tutor is wrong :) it is impossible :)
08:07:41 <koeien37> or you misunderstood him/her
08:07:49 <Rayne> gosh, when do i get a paper from my tutors which are not full with wrong information? 
08:07:54 <adu> reïmplemented?
08:08:10 <adu> why the Ůŋıçøðë?
08:08:23 <mauke> precision
08:08:33 <Twey> A Hyphen Is Fine Too.
08:08:43 <|Jedai|> EvanR: Well, gen and rand are top level declaration so... not a good idea
08:08:48 <mauke> Spin̈al Tap
08:09:12 <EvanR> Jedai: yeah
08:09:14 <Twey> I just think the diaeresis is sadly neglected in English these days, so I adopted it.
08:09:25 <koeien37> hehe
08:09:26 <reltuk> @seen dons
08:09:26 <lambdabot> Unknown command, try @list
08:09:31 <|Jedai|> EvanR: but the logic seems sound (at first sight) and if you put those in the where of a function, it should work correctly
08:09:45 <koeien37> in Dutch it is compulsory in cases like this, since "ei" is a diphthong
08:09:47 <EvanR> okay
08:09:50 <Rayne> thanks for your help guys
08:09:50 <Twey> koeien37: Right
08:10:13 <Twey> You're welcome, Rayne
08:10:44 <Twey> I never feel quite right hyphenating something that isn't a whole word by itself
08:11:03 <Twey> (and of course there are cases where the hyphen isn't valid, like ‘naïve’)
08:11:05 <adu> like pre-fix
08:11:31 <Twey> Well, that's not ambiguous, so nobody cares :þ
08:11:56 <|Jedai|> EvanR: something like "seed x = drop 1024 rand where pre = ... ; gen = ... ; rand = ..."
08:11:59 <gwern> I mean really, the alphabet glyphs are bad. they're not even rotationally unique, much less one-stroke writable or mirror-edge unique
08:12:04 <gwern> very unsatisfactory
08:12:20 <koeien37> they are just annoying to type in imo
08:12:41 <Twey> 's true
08:12:42 <adu> Twey: it is ambiguous, it could mean a druggie's pre-fix jitters
08:12:51 <|Jedai|> EvanR: preferably doing something with x (a random generator that always returns the same sequence is less useful)
08:13:04 <Cale> We should choose an alphabet which consists entirely of rotations of a single symbol ;)
08:13:10 <EvanR> this is good stuff
08:13:11 <Twey> Haha
08:13:16 <EvanR> *types* *listens*
08:13:18 * koeien37 suggests o
08:13:41 <ddarius> gwern: Why would they need to be rotationally unique?
08:13:46 <mjb> Is there a function built into one of the standard libraries to slice a list?
08:13:54 <gwern> ddarius: so you can read them upside down without getting tremendously confused
08:14:17 <|Jedai|> mjb: slice how ? regularly ? in two ?
08:14:21 <gwern> as it is, there are letters that upside down look like rightside up letter, and it gives me a headache
08:14:21 <koeien37> mjb: drop n . take (m+n)
08:14:29 <Twey> adu: It's not *morphologically* ambiguous.  ‘Pre-fix’ and ‘prefix’ are two separate words, and the latter never takes a hyphen.
08:14:30 <aavogt> that's limiting your number of unique letters rightsideup
08:14:41 <Twey> aavogt: Not severely
08:14:41 <ddarius> gwern: I can read upside down writing without getting tremendously confused, but it's not exactly a usual use-case of glyphs.
08:14:50 <adu> how about rotations of 義?
08:15:03 <koeien37> i prefer rotations of 十
08:15:08 <gwern> aavogt: we only need a few letters, y'know. this ain't chinese
08:15:09 <mjb> Thanks, was wondering if there would be something like Int->Int->[a]->[a] without writing drop.take.
08:15:20 <ddarius> koeien37: I prefer rotations of O.
08:15:31 <Twey> What was that script formed entirely regularly from only a couple of base symbols?
08:15:37 <aavogt> > length $ nub "we only need a few letters, y'know. this ain't chinese"
08:15:37 <adu> ddarius: oOo
08:15:38 <lambdabot>   20
08:15:40 <gwern> Twey: the koren hangul?
08:15:41 <|Jedai|> mjb: Nope, drop . take is good enough :)
08:15:43 <gwern> *korean
08:15:47 <Twey> No no
08:15:51 <monochrom> rotations of ⊙
08:15:55 <Twey> It's named with four numbers
08:15:58 <adu> Korean is so cool!
08:16:03 <Twey> I think it was 36-something
08:16:16 <aavogt> gwern: that's getting close to using all of them ;)
08:16:38 <gwern> Twey: this a real natural language?
08:16:44 <Twey> No, it's a conscript
08:16:49 <reltuk> handywrite uses big and small loops and whether the stroke comes out at the top or bottom and whether it curves up or down to encode english phonology
08:16:50 <gwern> oh. bleh
08:16:59 <koeien37> 義 is this the logo of yi?
08:17:07 <ddarius> "entirely regularly" never applies to a natural language
08:17:14 <adu> koeien: yes
08:17:27 <koeien37> adu: i thought so. didn't encounter it elsewhere yet :)
08:18:04 <adu> yi <- iλ ->
08:18:14 <reltuk> my program did not get faster but the hot spot is gone :-p
08:18:14 <gwern> koeien37: no, yi's logo is different
08:18:25 <mxyz> the perfect alphabet already exists. its braille. 2^6
08:18:27 <monochrom> iλ is imaginary lambda.
08:18:33 <Twey> adu: !λ
08:18:38 <adu> monochrom: no its upsidedown yi
08:18:41 <gwern> mxyz: how's the rotational and other symmetries?
08:19:15 <koeien37> gwern: ahw, but it's based on this
08:19:20 <adu> you know latin is roughly rotationally symmatric
08:19:28 <eu-prleu-peupeu1> :)
08:19:30 <koeien37> gwern: afaics. right?
08:19:32 * monochrom is so lazy, he writes "lambda" by typing "lam", <tab>, getting "lambdabot", then deleting "bot"
08:19:32 <adu> like U, N
08:19:36 <adu> and M, W
08:19:43 <mxyz> gwern: it comes in every color if you want black
08:19:44 * gwern shrugs at koeien37 
08:19:45 <EvanR> Jedai: something like this? http://pastebin.com/m26d0a8e
08:19:50 <adu> GD
08:20:04 <ray> monochrom: i just type 'l'...
08:20:04 <EvanR> oops, r=1024
08:20:10 <gwern> monochrom: isn't that more keystrokes though?
08:20:20 <monochrom> It is less error-prone.
08:20:27 <gwern> lam, 3, tab, 4, back-back-back, 7
08:20:46 <monochrom> You can bet on me typing "lamba" or "lamda" 50% of the time.
08:21:06 <ray> i'll just join this channel as lambadabot
08:21:14 <adu> lolol
08:21:21 <ray> you'll be forced to improve your spellin
08:21:24 <ray> g
08:21:25 <EvanR> Jedai: can i somehow make the two a*x+c expressions a z somehow... like internal where or something
08:21:48 <monochrom> And as you know from software, making mistakes costs more keystrokes then correct-by-construction.
08:22:04 <adu> monochrom: a z? where? how?
08:22:38 <monochrom> Even though correct-by-construction is more keystrokes than writing buggy code.
08:22:48 <Botje> EvanR: take a look at the divMod function
08:22:59 <gwern> everybody do the lambada!
08:23:08 <EvanR> Botje: even better.
08:23:10 <monochrom> I didn't do a z.
08:23:25 <MoALTz> hmm? buggy code requires you to do more keystrokes in order to fix it
08:23:49 <monochrom> Precisely. They were trying to tell me "fewer keystrokes if you don't fix it!"
08:24:02 <adu> oh that was EvanR
08:24:11 <adu> i need more lines
08:24:21 <monochrom> And of course they are right.
08:24:53 <EvanR> divMod (a*x+c) b... but not they are in the wrong order
08:25:03 <EvanR> now
08:26:45 <scalaLove> what does this mean: Int -> Boolean -> IO() ... it is a function that takes a Boolean from a function that takes Int? Can be said like that?
08:26:56 <koeien37> mp
08:26:58 <koeien37> no
08:27:05 <koeien37> it means Int -> (Boolean -> IO ())
08:27:08 <Botje> it's a function that takes an Int and returns a function that takes a Boolean and returns an IO ()
08:27:44 <Botje> EvanR: you could mirror the tuple manually
08:27:59 <Twey> (or, for short, a function from Int to Boolean to IO Unit)
08:29:00 <EvanR> Botje: what do you mean
08:35:28 <scalaLove> i have done compositing and it is cool to think of the tuple above as two nodes
08:35:51 <scalaLove> first one takes input Int and returns boolean and the second node takes input boolean and returns IO()
08:35:56 <scalaLove> correct?
08:37:01 <Cale> tuple?
08:37:34 <Cale> A function of type Int -> (Bool -> IO ()) is a single function which takes as a parameter an Int, and produces as its result a function of type Bool -> IO ()
08:37:36 <scalaLove> what i said equals to this Int -> Boolean -> IO (), sorry i thought all of it is in tuple
08:37:49 <scalaLove> Cale yes
08:38:09 <scalaLove> let me draw u it is cool graphically :) will send u image now
08:38:36 <Cale> It's not the same as (Int -> Bool, Bool -> IO ())
08:40:41 <aavogt> @type uncurry (.) $ (undefined :: (Int -> Bool, Bool -> IO ()))
08:40:42 <lambdabot>     Couldn't match expected type `Int' against inferred type `IO ()'
08:40:42 <lambdabot>       Expected type: (Int -> Bool, Bool -> Int)
08:40:42 <lambdabot>       Inferred type: (Int -> Bool, Bool -> IO ())
08:41:04 <aavogt> @type uncurry (flip (.)) $ (undefined :: (Int -> Bool, Bool -> IO ()))
08:41:06 <lambdabot> Int -> IO ()
08:42:59 <scalaLove> damn Gimp is stupid... anyways ... Two nodes... One takes input Int and outputs Bool, another node connected to this one takes that Bool and outputs IO()
08:43:34 <shachaf> scalaLove: Nothing "outputs" Bool in Int -> Bool -> IO ().
08:43:45 <Twey> A Bool -> IO () is not a Bool.
08:43:51 <aavogt> @type uncurry $ (undefined :: Int -> Boolean -> IO ())
08:43:52 <lambdabot>     Not in scope: type constructor or class `Boolean'
08:43:53 <Twey> It's a (->).
08:43:54 <scalaLove> read carefully
08:43:57 <aavogt> @type uncurry $ (undefined :: Int -> Bool -> IO ())
08:43:58 <lambdabot> (Int, Bool) -> IO ()
08:44:40 <Twey> The function takes an Int, and returns a function Bool -> IO ()
08:45:02 <aavogt> you would think that ghc would know that Boolean cannot be a class in that context
08:45:04 <scalaLove> we talk of the same thing in different words, got you
08:45:19 <Cale> scalaLove: No, I think you've got something a little off.
08:45:29 <shachaf> scalaLove: No, (Int -> Bool, Bool -> IO ()) is really a different thing.
08:45:45 <Cale> scalaLove: There's no sense in which a function Int -> Bool -> IO () is the composite of a function Int -> Bool and a function Bool -> IO ()
08:45:58 <scalaLove> basically the value goes from Int to Bool to IO()
08:46:12 <Cale> scalaLove: It goes Int to (Bool to IO ())
08:46:31 <scalaLove> Cale dude i did not say that, i said it is good to imagine it how it works with nodes from compositing software
08:46:37 <Cale> Which is not the same thing as going (Int to Bool) to IO ()
08:47:05 <Cale> You can imagine a function Int -> Bool -> IO () as a function of two parameters, one Int and one Bool, which produces a single IO () resuly.
08:47:07 <Cale> result*
08:47:10 <benmachine> the Int and the Bool need not be related
08:47:26 <benmachine> in any way
08:47:26 <roconnor> @type guard :: (Int -> Bool) -> IO ()
08:47:28 <lambdabot>     Couldn't match expected type `Int -> Bool'
08:47:28 <lambdabot>            against inferred type `Bool'
08:47:28 <lambdabot>     In the expression: guard :: (Int -> Bool) -> IO ()
08:47:48 <roconnor> ah oops
08:50:20 <ddarius> :t (guard .) :: (Int -> Bool) -> IO ()
08:50:22 <lambdabot>     Couldn't match expected type `()' against inferred type `m ()'
08:50:22 <lambdabot>     In the first argument of `(.)', namely `guard'
08:50:22 <lambdabot>     In the expression: (guard .) :: (Int -> Bool) -> IO ()
08:50:59 <scalaLove> it is like grammar productions
08:51:37 <Cale> scalaLove: It's important to understand that -> associates to the right
08:51:48 <scalaLove> cool
08:51:58 <Cale> scalaLove: (A -> B) -> C and A -> (B -> C) are not the same thing, and A -> B -> C always means the second of them.
08:52:11 <DevHC> how is it best explained?
08:52:30 <scalaLove> yeah got it
08:52:33 <DevHC> add x y = x + y         is a function of type Int -> Int -> Int
08:52:43 <Cale> scalaLove: This corresponds to function application associating to the left, so that  f x y  =  (f x) y
08:53:06 <DevHC> (add 4) in itself is a function differing in the previous one in that the first parameter is fixed
08:53:12 <Cale> all functions in Haskell really have exactly one parameter
08:53:17 <koeien37> DevHC: slightly more general
08:53:21 <scalaLove> got it got it, i knew it before, i just said it is cool to think about it like nodes
08:53:50 <koeien37> :t let add x y = x + y in add
08:53:52 <lambdabot> forall a. (Num a) => a -> a -> a
08:53:55 <Cale> and those who appear to take more parameters are just producing other functions to eat the rest
08:53:59 <Cale> Oh, I just noticed that I'm lagged by a lot.
08:54:14 <Cale> (so sorry if this is getting jumbled up with other people's explanations which haven't reached me yet ;)
08:58:01 <scalaLove> what does it mean Haskell has good integration with new languages? Can you give me examples?
08:58:38 <dons> you can call to and from other languages with very little code.
08:58:53 <dons> import foreign ccall sin :: Double -> Double -- bam! calling C.
08:59:59 <Cale> With *new* languages?
09:00:02 <Cale> hmm
09:00:06 <FunctorSalad> *same thought* :)
09:00:56 <scalaLove> ?
09:01:24 <EvanR> how about integration with older languages like cobol... and intercal
09:01:46 <FunctorSalad> I presumed the "new languages" to stand in contrast to C
09:02:12 <FunctorSalad> can't find the msg scalaLove is replying to though
09:02:26 <dons> i just discard parts of scalaLove's sentences until they make sense.
09:02:31 <scalaLove> well i dont understand the above
09:02:37 <Cale> I suppose it depends on which new languages you're talking about. There is a fair amount of work in integrating Haskell with .NET for instance, but it will of course never be as integrated with .NET as F#
09:02:53 <dons> scalaLove: what are you asking?
09:03:10 <dons> btw, you're famous in two channels now for not making sense.
09:04:21 <Cale> I seem to recall a Haskell to Ruby bridge?
09:04:22 <scalaLove> i read a book and it says it can be easily integrated with other languages... i see the word "new" "confused" you
09:04:35 <scalaLove> Ruby? nice... else?
09:04:35 <koeien37> dons: your @ is still on
09:04:39 <koeien37> trying to scare us?
09:04:43 --- mode: ChanServ set -o dons
09:04:51 <Cale> scalaLove: Anything which interfaces well with C will work.
09:04:55 <mauke> o/` I read a book and I liked it o/`
09:04:59 <dons> scalaLove: haskell can be easily integrated with code from other languages, yes.
09:05:05 <scalaLove> Cale : cool
09:05:05 <dons> it requires very little work.
09:05:40 <Cale> scalaLove: Though, for instance, it can be quite a bit of work interfacing to C++ code, for instance, for the same reason that it's hard to get from C++ to anything else.
09:05:48 <scalaLove> dons: can u give me some specific examples please? not too deep explanations just so i get sense of what it can do
09:06:00 <Cale> er, delete that spurious extra "for instance" ;)
09:06:08 <scalaLove> :)
09:06:30 <ddarius> Cale: Which one is the extra one?
09:06:32 <Cale> scalaLove: There are bindings to GTK 2 and Qt
09:06:44 <Cale> ddarius: Use the axiom of choice
09:06:57 <FunctorSalad> ok, got one
09:07:10 <Cale> scalaLove: and OpenGL, and many other libraries
09:07:25 <scalaLove> Qt and OpenGl - awesome
09:07:47 <Cale> Though, I haven't used the Qt bindings myself.
09:07:57 <Cale> and I don't know how well supported they are
09:07:59 <dons> the pygments binding to Python is another.
09:08:07 <FunctorSalad> IIRC there was an update recently (to qthaskell)
09:08:11 <dons> scalaLove: does that answer your question?
09:08:21 <scalaLove> yes it is enough
09:08:23 <FunctorSalad> Latest qtHaskell release: v1.1.3 (October 2009)
09:08:32 <EvanR> ive been writing this function, getting help from the channel, and now im testing it in ghci. http://pastebin.com/m345854f0 if i type take 5 (rand 0), i get a division by zero error :(
09:08:52 <EvanR> isnt the default numeric type for this Integer?
09:09:17 <koeien37> EvanR: right. but maybe something else makes it infer to be Int
09:09:21 <koeien37> try to find the type in ghci
09:10:06 <koeien37> EvanR: ah yes. r is an int, therefore gen is of type [(Int,Int)]
09:10:06 <koeien37> s/int/Int
09:10:06 <mauke> EvanR: where is s used?
09:10:06 <EvanR> okay
09:10:17 <koeien37> r must be Int because the argument to drop is
09:10:19 <EvanR> nowhere, but it should be used in genpre
09:10:41 <EvanR> r isnt used in arithmetic with the other letters though
09:10:56 <koeien37> that is true. but it forces the type of gen
09:11:09 <koeien37> to be [(Int,Int)]
09:11:09 <kmc> "it's hard to get from C++ to anything else."  <-- including C++
09:11:21 <EvanR> hrm
09:12:11 <nnyby> hi.. i am thinking about writing a mario paint clone written in haskell. i would like to create my own buttons and widgets for a uniform look across OSes. do you know of any haskell programs that do this?
09:12:33 <gwern> mario paint?
09:12:36 <kmc> nnyby, you can draw with cairo, it's the drawing layer below gtk
09:12:50 <EvanR> koeien37: do you recommend forcing everything to use Integer
09:13:00 <koeien37> EvanR: yes.
09:13:04 <nnyby> kmc: alright... is that similar to using HGL or the SDL bindings?
09:13:09 <kmc> i don't know
09:13:10 <EvanR> okay
09:13:14 <koeien37> and then do (fromIntegral r) on the drop
09:13:19 <nnyby> well i will look into it. thanks kmc
09:13:24 <kmc> i think cairo supports real drawing primitives unlike SDL
09:13:46 <EvanR> koeien37: my c version of this uses 32bit unsigned... sad to see it have to have to expand
09:13:52 <EvanR> i guess its the price for simplicity
09:13:53 <koeien37> ahw
09:14:02 <mauke> Word32?
09:14:02 <koeien37> then Word32 should work and be a little bit more efficient.
09:14:11 <nnyby> oh that is nice. i have tried a similar idea in SDL with C, but i got overwhelmed.
09:14:14 <koeien37> but Integer is preferable imo, for more guarantees of correctness
09:14:17 <EvanR> Word32, that sounds good
09:14:23 <EvanR> hrm
09:14:28 <kmc> C is a pretty terrible language for writing applications software
09:14:51 <koeien37> but Word32 should also be okay, if you can prove that your numbers won't go beyond 2^32-1
09:14:53 <Twey> s/applications//
09:14:56 <koeien37> (and below zero)
09:14:58 <kmc> hey now
09:15:22 <EvanR> koeien37: which they wont except for the expression a*x+c
09:16:12 * EvanR looks at a*x+c again... is that going to be sometimes more than 2^64? :S
09:17:09 <ddarius> Cairo is vector based, SDL is pixel based
09:17:19 <scalaLove> is there a chanell on functional programming as a paradigm only, not language specific?
09:17:40 <CalJohn> scalaLove: pretty much this is it
09:17:44 <gwern> what would such a thing look like, I wonder
09:17:48 <EvanR> it is not unheard of to use cairo or some other vector graphics lib with sdl, you rasterize your graphics into sprite sheets. see the game mole invasion
09:18:17 <FunctorSalad> cairo/gtk2hs doesn't build with ghc 6.12 last time I checked though :(
09:18:43 <FunctorSalad> I think some makefile item involving ghc-pkg/sed fails
09:19:00 <FunctorSalad> evil
09:19:02 <FunctorSalad> ;)
09:19:06 <scalaLove> I solved 4 Euler problems in Scala in imperative style. People there criticized me i should try to use vals instead of vars. I am having a transition from imperative to functional style, any guidelines you can accent and point me to?
09:19:48 <monochrom> turn vars into parameters of functions. turn loops into recursion.
09:20:25 <aavogt> I tried to write scala as I would haskell and failed
09:20:42 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/5d794a3194702607  has an example.
09:20:44 <dibblego> In the transition from imperative to functional, there is a very necessary step. It should be Imperative -> Nothing -> Functional
09:21:05 <dibblego> aavogt, we tried and succeeded
09:21:14 <aavogt> part of the thing is that scala's type inference doesn't go backwards
09:21:29 <dibblego> aavogt, yeah that's a PITA
09:21:51 <koeien37> backwards?
09:22:07 <dibblego> the inferencing is not as powerful as in Haskell
09:22:26 <aavogt> @type let x = 1 in (x, (x::Int))
09:22:27 <lambdabot> forall t. (Num t) => (t, Int)
09:22:46 <aavogt> huh, lambdabot has NoMonomorphismRestriction?
09:22:48 <scalaLove> monochrom: thank you i will remember that, any other useful advices... thank you again
09:22:57 <koeien37> aavogt: lambdabot has even more :)
09:23:05 <koeien37> > (+1) . Just 37
09:23:06 <lambdabot>   Just 38
09:23:40 <DevHC> > let { w = 10.0**308.252 ; sq x = x*x } in (sq (sqrt w)) - w
09:23:41 <lambdabot>   1.99584030953472e292
09:23:52 <DevHC> > let { w = 10.0**308.255 ; sq x = x*x } in (sq (sqrt w)) - w
09:23:54 <lambdabot>   NaN
09:25:34 <aavogt> koeien37: there are times when I ask what the inferred type of a function is. In scala, you basically have to annotate the type of the function first, since it cannot be infered from the type of the outputs alone
09:25:52 <aavogt> or that's what I had to do at least
09:26:42 <scalaLove> what do haskell people have against scalla? give me like top 5 so i can measure them in way while i learn them
09:26:46 <aavogt> I suppose the benefit is that you get to use OO things more easily... but I don't know that stuff well
09:27:07 <Optimality> does anybody have strong opinions on a graphics library to use for a game?  I'm looking at the SDL bindings...
09:29:16 <Twey> For a game, it probably is SDL
09:29:26 <Twey> Since SDL includes a bunch of other stuff, too
09:29:35 <benmachine> I've used SDL and found it pretty simple
09:29:42 <benmachine> it seems to segfault every time you quit though >_>
09:31:59 <Optimality> okie doke - hsSDL or SDL-0.5.9 ?
09:32:28 <dons> sdl is good. there's lots of nice examples.
09:33:55 <stroan> Optimality: a 2D game?
09:34:06 <Optimality> stroan: yep - roguelike, in fact
09:34:33 <Optimality> although the ability to do 3D eventually wouldn't be a downside :)
09:34:47 <stroan> there's not much that compares to SDL in that area really
09:35:13 <stroan> especially with the size of the user base
09:35:43 <stroan> and SDL does facilitate OpenGL functionallity. No idea about the haskell SDL bindings though
09:37:08 <Optimality> stroan: that's kinda what I figure - thanks
09:37:23 <benmachine> I've used SDL 0.5.9 before
09:37:36 <benmachine> it segfaults on exit but otherwise seems to behave
09:38:03 <Optimality> I've used SDL before on an NES emulator, I just wasn't sure if there was something preferred for the Haskell world
09:39:02 <EvanR> hrm sdl never segfaults for me, though thats the c lib
09:39:09 <benmachine> btw, I think hsSDL and SDL-0.5.9 are the same thing
09:39:20 <benmachine> EvanR: yeah I mean the haskell binding
09:40:17 <stroan> benmachine: really? I will look into that tomorrow, and try and submit a patch to whomever it may concern
09:40:55 <stroan> I do believe game making should be strongly catered for, as it's a major path into programming
09:41:17 <benmachine> stroan: err, it didn't do it when I just tried
09:41:26 <benmachine> maybe it was fixed in between 0.5.5 and 0.5.9
09:41:35 <stroan> cool
09:41:47 <benmachine> or maybe it's something to do with quitting without using SDL.quit
09:41:48 <benmachine> or something
09:41:57 <eldragon> there's a good idea for Niagara falls: drill some tunnels for them and you will get electric energy.
09:42:07 <stroan> SDL.quit has never thrown an exception for me in a C environment
09:42:13 <stroan> no matter how misused
09:42:17 <aavogt> eldragon: that's already done
09:42:54 <aavogt> and this is probably the wrong channel for that
09:43:16 <eldragon> put many electric generators along these tunnels
09:43:31 <monochrom> I think he also means to drill some tunnels in this channel and get electricity.
09:44:05 <aavogt> channel tunnel?
09:44:43 <eldragon> aavogt, channel and tunnel are the same thing, not?
09:44:47 <aavogt> by the way, you only need one turbine at the bottom... or at the top if you could afford to have a vacuum
09:44:51 <EvanR> i need help... i realized i was doing the algorithm wrong, and heres the 'pseudo code' for what its supposed to do but is clearly incorrect haskell. ideas? http://pastebin.com/m76ee9afc i cant seem to pass a value that way
09:44:58 <stroan> I've had ths conversation a goofd few times, but I can't decide what language I'd teach to a complete newcomer to programming. I think the haskell errors require too much implicit knoledge
09:45:04 <aavogt> eldragon: there is a channel tunnel
09:45:20 <aavogt> perhaps you should complain to them for having named it such
09:45:47 <ddarius> stroan: I would probably not use Haskell but not because of the errors.  I would probably use Scheme currently.
09:46:06 <stroan> ddarius: Scheme was my initial idea
09:46:33 <stroan> but it has relatively few bindins to useful libraries compared to CL
09:46:42 <ddarius> stroan: Use PLT Scheme.
09:46:58 <stroan> PLt doesn't have SDL bindings does it?
09:47:06 <ddarius> Anyway, bindings aren't a big deal for a first language.
09:47:11 <ddarius> stroan: Probably.
09:47:23 <ddarius> (Probably it does, I mean.)
09:47:30 <stroan> ddarius: I find being able to get graphical results being a big deal for first languages
09:47:34 <stroan> qbasic
09:47:37 <stroan> as an example
09:47:47 <stroan> and the other language on early systems
09:47:48 <ddarius> stroan: And SDL isn't the only or easiest way to do that.
09:47:59 <stroan> ddarius: definitely nt
09:48:02 <stroan> not*
09:48:04 <stroan> I agree
09:48:10 <ddarius> stroan: In PLT Scheme you can have images as values.
09:48:24 <stroan> yes, the slideshow language is quite awesome
09:48:33 <monochrom> if you follow hudak's book, you get graphics in chapter 2, and by chapter 22 you get midi music too.
09:48:46 <stroan> monochrom: link?
09:48:50 <roconnor> where are haskell mugs on cafepress?
09:49:23 <monochrom> http://www.haskell.org/soe/
09:49:38 <ddarius> @google site:cafepress.com haskell mugs
09:49:42 <lambdabot> No Result Found.
09:50:52 <Niccus> wrong haskell but http://www.zazzle.co.uk/haskell_mug-168433898444006804
09:51:14 <stroan> ddarius: with regards to scheme, would you teach it as an imperative language, and introduce the functional aspects, or how would you teach it?
09:51:31 <stroan> I'm teaching a beginning programming course via pygame atm
09:51:43 <stroan> and would much appreciate input for next year
09:51:44 <monochrom> I would teach scheme as a call/cc language. XD
09:52:39 <ddarius> stroan: I would start with the functional aspects but eventually teach imperative and pseudo-OO stuff.  I'd probably follow HtDP for complete beginners (with some presentational modifications.)
09:53:22 <ddarius> One of the main reasons I'd recommend Scheme as a first language is the availability of tools and books targetted at complete beginners.
09:54:07 <stroan> one of my biggest complaints with my CS course is being taught OO, before being shown what the problem OO solves is. So you're given a hammer before you're shown what a nail is. Which I think makes python and lisp and haskell better for beginners
09:54:25 <stroan> to a degree
09:54:34 <ddarius> Another reason I prefer it to Haskell in that context is I think beginners should start with a language that emphasizes (pure) functional programming but can also allow (later on) dealing with (unconstrained) stateful programming.
09:54:44 <rfn> Newb question: How to onvert a NominalDiffTime to a DiffTime?  Follow up... what's the difference between the two types?
09:54:49 <stroan> learn program structure, ADTs, and THEN oo
09:55:07 <stroan> but yes dr. scheme is a great program
09:55:48 * hackagebot upload: explore 0.0.6.1 - Experimental Plot data Reconstructor (CetinSert)
09:56:05 <stroan> ddarius: one of the people I used to work with had an anecdote of teaching his wife programming
09:56:15 <stroan> she was an accountant and used to excell
09:56:24 <stroan> she quickly took to fure functional programming
09:56:34 <stroan> but it really confused her once state was introduced
09:56:41 <stroan> and side effects
09:57:08 <stroan> which is pretty much the opposite to the way most CS people come into programming
09:57:51 <scalaLove> how do you pro guys manage to know so many languages? You still keep the references and check up on them for the language u use right?
09:57:56 <stroan> I thought it was an interesting story, since it shows that teaching pure functional programming first is not nessecarilly "harder"
09:58:13 <roconnor> scalaLove: they are all the same.
09:58:30 <Cale> scalaLove: It's a bit like asking how do you learn to use so many programs? :)
09:58:45 <ddarius> stroan: Pure functional programming is distinctly easier than side-effectful programming.
09:58:52 <benmachine> how do you learn so many words?
09:59:09 <joed> benmachine: u abbrv em
09:59:14 <mauke> scalaLove: mostly, no
09:59:17 <stroan> ddarius: 1.5 years ago I would have diagreed with you
09:59:24 <stroan> and most of the people in my course would still do so
09:59:38 <scalaLove> i agree with stroan
09:59:45 <tessier> ditto
09:59:52 <ddarius> stroan: Learning something that you don't already know is distinctly harder than learning something that you already know.
09:59:53 <tessier> Purely functional is NOT how human beings naturally think
09:59:55 <mauke> scalaLove: I have like three complete programming languages in my head
10:00:08 <tessier> Even starting from scratch with a completely newbie programmer procedural is going to be easier.
10:00:11 <stroan> tessier: not saying that
10:00:12 <tessier> In the beginning anyway.
10:00:20 <stroan> it's just that once you've started learning imperratively
10:00:21 <mauke> tessier: I don't believe you
10:00:25 <stroan> it's harded to move to functionakl
10:00:30 <scalaLove> mauke I dont have even one, i keep using reference you cant know it all even for one language
10:00:37 * roconnor doesn't believe tessier either
10:00:37 <tessier> mauke: We all know how to follow directions. Evaluating functions is much different.
10:00:40 <gwern> most people only know 1 language, with 3 or 4 different syntaxes and standard libararies
10:00:44 <benmachine> first fo all, I don't buy the idea that there is a natural way of thinking about a technology only invented half a century ago :P
10:00:46 <mauke> tessier: no
10:00:54 <ddarius> tessier: Programming in general is not how human beings naturally think.
10:01:10 <ddarius> tessier: People have a -very- hard time following directions.
10:01:15 <tessier> ddarius: Procedural programming is much like following a cookie recipe.
10:01:20 <ddarius> Let alone giving complete directions.
10:01:22 <benmachine> secondly, I think that even if people naturally think imperatively, functional programming teaches them why thinking unnaturally is easier
10:01:25 <tessier> You've even got state. Dough already in the bowl? That's state.
10:01:28 <mauke> tessier: no, recipes are declarative or functional
10:01:40 <ddarius> tessier: Procedural programming is like -writing- a cookie recipe.
10:01:54 <tessier> mauke: All of my recipies have step 1 step 2 step 3 and I follow them in order. That sounds pretty procedural to me.
10:01:59 <stroan> I'd love to take two classes, teach one haskell, and teach one C# say (a relatively nice imperative language)
10:02:06 <benmachine> tessier: sometimes I don't follow them in order!
10:02:11 <stroan> and see who has a better concept of computation
10:02:12 <benmachine> sometimes I get the butter out before the eggs
10:02:16 <scalaLove> procedural is natural that is why it is easy, functional i think is the next step, seeing the hiden truth and patterns in procedure
10:02:17 <stroan> and problem solving at the end
10:02:22 <benmachine> butter and eggs are referentially transparent so it's fine
10:02:23 <tessier> I'm a pilot. We have procedures we follow. That's much the same also. We even call them procedures.
10:02:55 <mauke> tessier: I think that's declarative
10:02:55 <mauke> like a makefile
10:02:55 <tessier> Give me a purely functional checklist and I'm gonna get a bunch of people killed.
10:02:56 <Niccus> egg throws exception: double yolk
10:02:59 <tessier> Even s/purely// because there have to be side effects somewhere or the gear don't come down
10:03:00 <Cale> scalaLove: I see it the other way around. Functional programming is a natural way of thinking, and you have to think harder to work out a way to turn things into procedures.
10:03:34 <benmachine> I think that naturality is overrated, whoever holds it
10:03:42 <benmachine> and functional programming is easier for other reasons
10:03:49 <roconnor> and recursion is confusing functional or imperitive.
10:03:53 <benmachine> gives you less to think about, quite often
10:03:59 <ddarius> tessier: Just because some things are procedural doesn't mean we think that way.  I would be much more inclined to think (even when baking cookies) that the thought process is much more a constraint satisfaction problem.
10:04:02 <stroan> Cale: would you not say that the manner in which you would describe a process is imperrative, and not declarative. "Go there, and do that 5 times, and then return"?
10:04:10 <scalaLove> I would say functional is more specific then imperative, maybe too philosophical but...
10:04:14 <FunctorSalad> benmachine: the technical meaning? of naturality
10:04:29 <tessier> ddarius: Can we devise a test for this?
10:04:38 <benmachine> FunctorSalad: part of the reason it's overrated is because it doesn't really have one :P
10:04:45 <Cale> scalaLove: When you want to tell someone to wash the dishes, do you number them all and tell the person to let i be equal to 0, and say that for each i they should wash the ith dish? Or do you just tell them to wash all the dishes?
10:04:53 <tessier> I gave my dad directions to my office the other day. I'm pretty sure that was imperative also.
10:04:55 <ddarius> tessier: Not until we define "thinking"
10:04:55 <Cale> Which is closer to map wash dishes?
10:05:20 <tessier> Cale: Most people pick up the first dish on top of the stack.
10:05:33 <tessier> Cale: We don't describe it that way but we do it that way.
10:05:42 <Cale> tessier: As does map, but we don't care about that detail when describing it.
10:05:52 <mauke> I've seen newbies write code like 'print(a, b); a = 1; b = 2 * a;'
10:05:55 <Draconx> Cale, I'd say washing dishes is closer to map wash (sort dishes)
10:05:57 <tessier> Most of the things we don't naturally know how to do but need instructions for we are given imperative instructions for.
10:06:07 <scalaLove> this conversation seems to make no sense to me :( i will just return to my book
10:06:12 <joed> Cale: to add to your subject, most recipes are functional in a professional context, they describe flavor, assumed knowledge of say mother sauces, reductions and cooking techniques (In a professional context)
10:06:21 <toast-opt> tessier, but maybe they pick up the first dish only because it's the easiest solution to a constraint?
10:06:27 <tessier> joed: Very few of us are professionals.
10:06:27 <stroan> Cale: my I PM you about a catergory/haskell issue?
10:06:46 <tessier> toast-opt: Or because it's on top.
10:06:48 <toast-opt> really, it only appears procedural because an ambiguitiy was resolved in a particular order
10:06:56 <FunctorSalad> benmachine: huh?
10:07:06 <joed> tessier: That is fair :)
10:07:11 <toast-opt> tessier, so?  i don't take it from the top because it's the top.  i take from the top because it's easier
10:07:14 <stroan> heheh
10:07:23 <benmachine> FunctorSalad: possibly I misunderstood you?
10:07:28 <tessier> toast-opt: The problem with this example is that everyone knows how to do dishes. They watch their parents or learn it. Imagine teaching someone how to wash dishes.
10:07:44 <FunctorSalad> benmachine: I was just wondering whether you were talking about category theory naturality, or FP being natural to learn
10:07:52 <ddarius> tessier: You probably wouldn't say, "take the top dish", you'd say "take a dish"
10:07:54 <Cale> Also, any argument that imperative programming is more natural because the CPU takes instructions in an imperative language should be taken together with the fact that the CPU itself is operating based on physical principles that are described using declarative differential equations :)
10:07:57 <luite> Cale: but in haskell you don't tell someone to wash all dishes, just that each dish needs to be washed before it is used again
10:07:58 <benmachine> FunctorSalad: oh, I don't know any CT
10:08:01 <toast-opt> tessier, let me ask you this.  if you experience a polarity reversal, gravity reverses, and you're stuck to the ceiling along with the dishes... would you then take from the bottom?  i would.
10:08:08 <tessier> toast-opt: I bet you turn on the water first. Then maybe grab the soap. Then maybe was it, then rinse it, then dry it. The rest you let the person work out themselves.
10:08:10 <toast-opt> of course, polarity reversals don't phase me
10:08:22 <tessier> toast-opt: The bottom is then the top. The enemy's gate is down.
10:08:35 <FunctorSalad> "naturality" for humans splits into "how easy is this without any training" and "how well does it fit the human mind, if trained" I guess
10:08:38 <Cale> luite: that is true, though the nice thing is that you can see it either way, because it doesn't matter when things are done
10:08:40 <toast-opt> tessier, yes, but if it were procedural, an automatic faucet would kill the whole endevour.  but it doesn't.  human's don't think procedurally
10:08:56 <tessier> toast-opt: An automatic faucet would simply change the procedure.
10:09:02 <Cale> Humans think in terms of something quite close to higher order functions.
10:09:02 <scalaLove> I think I can conclude and end this conversation, here it is: I have no idea how to fix a computer and or even work in desktop and what not... my brother comes and does not tell me move this file to C:... i am like whaaat? he then tries this and he says: double click on my computer, open c, right click and paste... he tells me PROCEDURES ONE BY ONE... A month later I know how to do it and he...
10:09:04 <scalaLove> ...just tells me copy this file to D...
10:09:07 <tessier> toast-opt: Humans learn now things procedurally.
10:09:11 <toast-opt> tessier, and where does that new proceedure come from?
10:09:16 <benmachine> tessier: you teach people to wash dishes by teaching people how to wash a dish, and then teaching people how to do something lots of times
10:09:34 <tessier> benmachine: Iteration.
10:09:43 <benmachine> or map
10:09:48 <FunctorSalad> I agree that the concept of "action" is natural, but haskell just makes action explicit
10:09:50 <toast-opt> hah
10:09:54 <eldragon> functional programming can't target code to says what has to do each electron, hehehe.
10:09:58 <toast-opt> map water dishes
10:10:12 <toast-opt> > map water dishes
10:10:13 <lambdabot>   Not in scope: `water'Not in scope: `dishes'
10:10:21 <toast-opt> darn, now i have to do it
10:10:44 <tessier> You gotta wrap the side-effect of the dishes becoming clean in a monad
10:10:54 <benmachine> nah
10:10:59 <Cale> Actually the example of washing dishes comes from when I taught a friend of mine about Haskell. He came up with it in order to explain why he hadn't enjoyed programming in procedural languages in the past and had found them unnatural.
10:11:03 <benmachine> (wash dish) --> a washed dish
10:11:05 <toast-opt> tessier, no, water is a function that maps dirty dishes to clean ones
10:11:18 <tessier> "Mom, I did wash the dishes, I swear! But I did it in a purely functional way!"
10:11:25 <toast-opt> water :: Dish -> Clean Dish
10:11:41 * benmachine washes the dishes lazily
10:11:44 <toast-opt> actually, it's polymorphic, but i'm not so good with type classes yet
10:11:57 <Cale> There are lots of nonsense details which you have to explain to an imperative programming language in general because you don't have the same linguistic abstractions we take for granted in English.
10:12:01 <benmachine> water :: (Dry d, Wet w) => d -> w
10:12:10 <tessier> When I was a kid and had to clean my room the closet was the monad for storing all of my junk in
10:12:15 <tessier> Under the bed was another popular monad
10:12:36 <toast-opt> benmachine, that type singature is wrong... what about (water (Wet dish))
10:12:53 <benmachine> toast-opt: hmmm
10:13:09 <benmachine> maybe that's covered by morewater
10:13:12 <Cale> Higher order functions (something that I think puts us firmly in the land of functional programming) give us back some of the linguistic abstractions that we take for granted in communicating with each other.
10:13:15 <benmachine> no that is silly
10:13:22 <luite> benmachine: I use a dishwasher, which is some evaluation strategy for evaluating a whole bunch of washes in parallel efficiently (and does require some additional strictness) :p
10:14:07 <toast-opt> how do you model a function that maps from A and B to A only?
10:14:39 <Twey> toast-opt: const?  :þ
10:14:39 <toast-opt> :t const
10:14:39 <lambdabot> forall a b. a -> b -> a
10:14:39 <Twey> Oh, wait, A *and* B
10:14:39 <Cale> "Wash all the dishes"  "Tape these sheets of paper together end-to-end"  "Pick out all the blue M&M's for me"
10:14:44 <Twey> What do you mean by that?  Like an Either?
10:14:51 <Twey> Or a tuple?
10:14:52 <Cale> are all things which are in some way "higher order", and annoying to express in an imperative language because there's no word for them, you have to re-express them every time
10:14:59 <toast-opt> Twey, like an either
10:15:21 <Twey> :t lefts
10:15:22 <lambdabot> forall a b. [Either a b] -> [a]
10:15:23 <Twey> :t rights
10:15:24 <lambdabot> forall a b. [Either a b] -> [b]
10:15:28 <toast-opt> given a Dish, it produced a Wet (Dish), but given a Wet (Dish), it is identity
10:15:31 <Twey> :t partitionEithers
10:15:32 <lambdabot> forall a b. [Either a b] -> ([a], [b])
10:15:37 <tessier> There has got to be a way to test this theory.
10:15:43 <tessier> If there isn't, it isn't science and is pointless to talk about.
10:15:55 <ddarius> tessier: There is, we just don't know how currently.
10:16:12 <toast-opt> i think he means until it's testable, it's not a theory
10:16:19 <toast-opt> it doesn't predict anything
10:16:22 <ddarius> (Actually, we probably do have some inklings and tests for how currently, we just can't accurately interpret the results.)
10:16:22 <tessier> Is the natural way people explain things the natural way people learn things?
10:16:24 <tessier> toast-opt: Right
10:16:44 <tessier> Maybe we could ask people who know nothing about computers to teach someone how to do something that computers normally do
10:16:48 <tessier> And observe how they explain it.
10:17:09 <toast-opt> like saying that the sun is powered by unicorns
10:17:09 <toast-opt> it is
10:17:14 <toast-opt> but that doesn't change anything
10:17:52 <toast-opt> tessier, experiment bias.  computers as presently incarnated have an imperative-programming bias that surfaces up to the UI
10:18:04 <gwern> @quote
10:18:05 <lambdabot> Jerub says: shapr: we have a new manager. she complained of a bad heart when I told her we didn't have revision control.
10:18:17 <tessier> toast-opt: I'm not suggesting we have people explain it with a real computer.
10:18:17 <Twey> o.x
10:18:23 <tessier> Computers would have to not be involved anywhere in the experiment.
10:18:27 <ddarius> tessier: How would you tell someone to write a story/
10:18:28 <ddarius> ?
10:18:39 <tessier> ddarius: Funny you should ask...
10:18:43 <toast-opt> tessier, then what's a 'real computer'?
10:18:55 <toast-opt> i mean, an unreal one
10:18:59 <toast-opt> i guess an imaginary one
10:19:06 <tessier> I mean no computer or technology involved at all
10:19:13 <toast-opt> ... like an iMac?
10:19:28 <tessier> Not a real computer = windows box
10:19:32 <ddarius> toast-opt: He means have a human (who knows nothing about computers) tell another human how to, say, sort a list of objects.
10:19:33 <toast-opt> :P
10:19:42 <eldragon> is playstation2 a computer?
10:19:58 <eldragon> it's bigger and powerful than any i386
10:20:00 <toast-opt> ddarius, ah, but that's not entirely fair
10:20:11 <toast-opt> they will give a proceedure as an _example_ of how
10:20:22 <toast-opt> or, rather, what
10:20:34 <DevHC> i have a question about how haskell generates code
10:20:41 <joed> Or they'll say insert inbetween something implying a lot of knowledge about sorting
10:20:43 <ddarius> I doubt they'd give a "procedure" at all in some sense.  It would be rather incomplete (as an example is).
10:20:44 <toast-opt> say someone taught me to sort cards by spliting into buckets -- low numbers here, then high here,.. etc
10:20:49 <mauke> did you mean: ghc
10:20:53 <DevHC> let me first describe a scenario in a C code
10:20:57 <eldragon> DevHC, haskell team doesn't care the quality
10:21:05 <DevHC> :o
10:21:08 <toast-opt> then one day i get a set of cards that are very discontinuous... 1 2 3 100 999999, etc
10:21:12 <mauke> what do you mean by "haskell team"?
10:21:12 <toast-opt> i'll addapt
10:21:14 <tessier> First google hit on "how to write a story" has a list of numbered points. It then has a link which says a story has a beginning, a middle, and an end.
10:21:16 <DevHC> vsnprintf(message, sizeof(message), "%s %s %s.", decolor(target->name), action->str, decolor(action_source(action, actor)));
10:21:23 <toast-opt> the major thing i got from the lesson is a definition of sorted
10:21:28 <ddarius> tessier: Yes, but could you write a story from that list?
10:21:47 <tessier> ddarius: That isn't what you ask. Every analogy is going to break down eventually.
10:21:50 <tessier> asked
10:22:15 <DevHC> so this function in C is used in an admin system where some higher level users can kick other users from a server, and these messages are logged
10:22:18 <benmachine> DevHC: that's not a vsnprintf
10:22:22 <ddarius> tessier: You also didn't answer the question I did ask which is: How would -you- tell someone to write a story?
10:22:27 <benmachine> sorry I should not nitpick
10:22:36 <Cale> stroan: oh, sorry, yes, sure you can ask me a CT question :)
10:23:00 <DevHC> example messages include: "Arbitry was kicked by Arboreus.", "Idler12345 was kicked automatically.", or "Ab00z3r was banned via the console."
10:26:42 <DevHC> first %s gets replaced by a string (username).. uhm, usernames can have shiny color escape codes embedded, like [c=1], which prints nicely in a game, they are removed for the logs; second %s by another basic string, third one is: if the "user" doing the action (kicking a player from a server) is an real, identified player, the action_source() function returns "by <insert name here>", otherwise "via the console" if the kick command was
10:26:42 <DevHC>  typed at the server machine
10:27:23 <DevHC> now, the thing about this code is what data juggling/moving is actually done when executing this code
10:27:36 <ddarius> Indeed, toast-opt does have his finger on the right thing where, when being taught how to sort a list, the key knowledge gained would be the definition of sorted.  Similarly, if I were trying to describe how to write a story, the knowledge I would try to provide is a definition of story and concepts such as plot and characterization.  I could give an imperative list of things to do, but each of the steps would be complex st
10:27:36 <ddarius> eps that are highly non-deterministic and not very amenable to step-by-step descriptions.
10:27:40 <scalaLove> what this means: sum[] = 0
10:27:59 <tessier> Sorting a list is different from efficiently sorting a list.
10:28:02 <benmachine> if you sum no numbers, you get 0
10:28:20 <tessier> Most humans would come up with their own procedure for doing the sorting themselves and it would probably be relatively inefficient.
10:28:21 <benmachine> ddarius: complex st?
10:28:41 <eu-prleu-peupeu1> sleep now
10:28:43 <ddarius> tessier: I agree with the former but not necessarily with the latter.
10:28:47 <DevHC> decolor() uses a few static buffers and return pointers to them. they take the argument string, and strcpy-everything-except-"[c=*]"-substrings to a buffer
10:28:52 <ddarius> tessier: See, for example, gapped insertion sort.
10:28:53 <tessier> This is the problem some people have with things like Haskell: Hard to predict exactly what it is going to do to work out the solution.
10:29:00 <tessier> How much time/space various constructs will take etc.
10:29:25 <tessier> I have been reading about prolog a bit recently...was wondering if the thing would ever explode with an n^2 type time or memory usage.
10:29:29 <ddarius> tessier: You can always pretend Haskell is an eager language and get an upper bound.
10:29:41 <DevHC> after decolor() copies almost a whole string, it is recopied into the snprintf targeted buffer
10:29:46 <scalaLove> why does sum [] = 0 produce error?
10:30:24 <EvanR> you are redefining sum?
10:30:52 <mauke> scalaLove: where and what error?
10:31:08 <eldragon> my way is very simple, back 60 years, and start to program using pure lambda calculus of Church. Haskell doesn't exist. Lisp doesn't exist.
10:31:15 <scalaLove> <interactive>:1:7: parse error on input `='
10:31:25 <mauke> scalaLove: yeah, you can't do that in ghci
10:31:26 <scalaLove> i execute only that
10:31:28 <mauke> put it in a file
10:31:30 <DevHC> even worse, the action_source() function writes to another static array a "by <name>" or "via the console" (or "automatically") string, which, via the decolor() function gets recopied, and finally copied to the printf buffer
10:31:33 <scalaLove> ok
10:31:42 <mauke> scalaLove: but "sum" already exists
10:32:08 <scalaLove> isnt + what does that? sum exists?
10:32:09 <dons> scalaLove: work from a file, and load it in ghci to experiment.
10:32:20 <mauke> scalaLove: what?
10:32:35 <scalaLove> u say sum exists
10:32:49 <scalaLove> as builtin?
10:32:57 <mauke> no, as a function in the standard library
10:33:00 <mauke> like +
10:33:02 <Axman6> it's in the prelude
10:33:19 <scalaLove> but never the mind it exists so i cant have a func with the same name, ok thanks
10:33:46 <Cale> scalaLove: Well, you can, but you'll have to not import it from the Prelude if you want to do that, which is mildly inconvenient.
10:34:06 <Cale> (or else always refer to it qualified with the module name, which is more inconvenient)
10:34:16 <mauke> just using a different name is easier
10:35:20 <scalaLove> why can i not import from Prelude? Does not prelude automatically load at start no matter i like it or not?
10:35:28 <mmorrow> , let (+) = (*) in 3 + 3
10:35:29 <DevHC> now with the lazyness of haskell i'd expect that it would be possible to generate an inlined function which writes to he output message string exactly once, and consists of a bunch special-purpose of loops which copy the exact needed chars, namely skipping [***], jumping to the appropriate "copy the 'by ...' string' or "copy 'via the console'" loop, etc.
10:35:30 <lunabot>  9
10:35:57 <ddarius> , let (+) = (*) in 2 + 2
10:35:59 <lunabot>  4
10:36:09 <scalaLove> let(-) = (+) in 2+2
10:36:18 <dons> scalaLove: you can import the prelude. your question isn't clear enough to answer.
10:36:22 <eldragon> the idea of Artificial Intelligence doing the programming job that you need is a failure nowadays.
10:36:30 <scalaLove> lunabot: let(-) = (+) in 2+2
10:36:30 <tessier> hmm...looking up "how to" type instructions for doing all sorts of computer related things on the net results in a lot of enumerated lists and "First, then" type descriptions.
10:37:25 <Niccus> , let (+) = (-) in 2+2
10:37:25 <tessier> er...non computer related things I meant
10:37:26 <lunabot>  0
10:37:31 <scalaLove> what extension to save the file and how to run it from terminal after that?
10:37:53 <mauke> DevHC: we don't write to strings
10:38:00 <DevHC> ?
10:38:33 <ddarius> tessier: 1) Telling someone how to do things suggests an (linguistic) imperatives, 2) the steps are likely not amenable to imperative descriptions in many cases (depending on the sorts of tasks), 3) how you might tell someone to do something is rather different than how you (or they would) think about it.
10:38:34 <DevHC> i'm asking that if for example the haskell-equivalent code would be:
10:38:35 <Niccus> save as .hs, run with runghc <file>
10:39:01 <DevHC> message = (decolor (name target)) ++ action ++ (if (name target) == "" then (if (type action) == IdleDrop" then "automatically" else "via the console") else "by " ++ (decolor (name target)))
10:39:08 <tessier> ddarius: Right but we are talking about how to tell the computer to do something.
10:39:23 <tessier> ddarius: How the programmer or the computer thinks about doing it once it already has been told isn't really the issue.
10:39:41 <tessier> At least not as long as we cannot translate the programmers intuitive thoughts straight into the computer.
10:40:27 <DevHC> or something like that, then would it be possible / is it plausible / is it how it already works / <insert_more_questios_here> to generate imperative instructions which creates the resulting message string the way i descibed?
10:41:05 <scalaLove> Niccus: I get error:  Not in scope: `runghc'
10:41:34 <mauke> scalaLove: he means from the terminal, not from ghci
10:41:48 <Niccus> within ghci you want to use :l
10:42:08 <mmorrow> DevHC: anything that's not impossible can be done, the questions to ask are (1) is it really possible, (2) if so, what is an efficient algorithm to derive this, and (3) is it implemented efficiently, and if not can it be
10:42:10 <DevHC> now this is the case for a single-core setup, MAYBE it would be plausible to actually allow one core to decolor one name, another code to decolor another name, and finally to quickly concatenate the resulting outputs ,but for small strings like this, i don't think so...
10:42:59 <DevHC> sure it's possible, how does, for example, ghc perform on this case?
10:44:40 <mmorrow> can you state your case in one simple sentence?
10:44:43 <ddarius> tessier: Have someone with no programming experience try to write a program in an imperative language.  They will certainly have some step-by-step aspects, but they will also certainly have some declarative aspects, such as "find the smallest number" or "pick a number not already used"
10:45:30 <tessier> ddarius: But that sort of declaration is not rigorous enough for a computer to do anything with. That is more "do what I mean" type programming which doesn't work in practice.
10:45:39 <ddarius> tessier: Exactly!
10:46:01 <tessier> Exactly what?
10:46:11 <DevHC> what imperative instructions does the following code generate? is it nearly-efficient or can it be done much better?
10:46:12 <DevHC> message = (decolor (name target)) ++ action ++ (if (name target) == "" then (if (type action) == IdleDrop" then "automatically" else "via the console") else "by " ++ (decolor (name target)))
10:46:15 <ddarius> tessier: Your statement is exactly correct.
10:46:29 <tessier> Of course it is. I said it! ;)
10:46:42 <ddarius> tessier: But declarative programming does come a lot closer to such things, and indeed you could actually state things like "pick a number not already used" in a logic language.
10:46:45 <mauke> DevHC: something funky because strings are linked lists of characters
10:47:06 <EvanR> gah. i am trying to translate this generator into nice haskell code. x[i] = f(x[i-r]+c[i-1]) c[i] = g(x[i-r]+c[i-1]), so i need r past x values and the last c value. i cant pass c forward in a list comprehension, i dont think :\
10:47:15 <EvanR> i tried writing a regular recursive function, no dice
10:47:23 <ddarius> tessier: Part of my point though, is we rarely care about or specify a specific algorithm when giving instructions to people (and ideally to computers as well.)
10:47:25 <tessier> ddarius: That isn't very helpful to our original question of what is the easiest way to teach people to program.
10:47:27 <mmorrow> DevHC: so you're appending a couple lists and making a larger list
10:47:40 <tessier> ddarius: Ideally, yes. But in practice we are far from that ideal.
10:47:51 <tessier> ddarius: Ideally we can say "Tea, earl grey, hot" and get what we want.
10:48:13 <ddarius> tessier: But in many ways declarative languages are closer to that ideal than imperative languages.
10:48:43 <DaveS> you have a food replicator, and the most advanced medicine in the galaxy...
10:48:47 <DaveS> and you order tea?!
10:49:13 <tessier> ddarius: The question is which is easier to teach someone who knows nothing about computers to program with. Not what is the ideal program representation.
10:49:16 <tessier> DaveS: hehe
10:49:28 <mauke> computer: end program
10:49:36 <DevHC> really they are linked lists in practice? :o
10:49:47 <Niccus> they are linked lists in practice
10:49:58 <DevHC> sux
10:50:29 <mmorrow> tessier: foo (T (T a b) c) = T a (T b c)   vs.   foo(T *t){T *tmp; tmp = t->l->l; t->l->l = t->l->r; t->l->r = t->r; t->r = t->l; t->l = tmp;}  ?
10:50:31 <ddarius> tessier: It depends on your goal.  Do you want them to be able to do -something- with computers or do you want them to (more) easily do whatever they want to do with computers?
10:50:32 * tessier ponders going out and getting night current in the BE-76 tonight. The weather is a bit sketchy for VFR. Hmm...
10:50:58 <tessier> ddarius: Good question. Most employers seem to want the former.
10:51:16 <tessier> My boss at my computer job the other day was saying he standardized on PHP because PHP coders are easy to find.
10:51:28 <monochrom> Tea is pretty sophisticated.
10:52:01 * mauke standardizes on anal intercourse because it works on both genders
10:52:14 <tessier> mauke: haha
10:52:22 <monochrom> Tea is a formidable challenge to the most advanced food and medicine replicator in the galaxy.
10:52:49 <Niccus> in fact most of the time you get something almost exactly, but not quite, unlike tea
10:52:55 <medfly> I agree with that tessier
10:53:02 * medfly prepares to be attacked
10:53:21 <dolio> You agree that PHP coders are easier to find?
10:53:31 <medfly> that it's a good reason to choose PHP
10:54:52 <luite> finding good php coders though....
10:54:56 <DevHC> ok, what if i use unboxed types [i've yet to know how they work exactly, but meh..]? what happens then?
10:55:05 <dolio> You might have to weigh that against how many good coders are willing to write mostly PHP.
10:55:09 <medfly> the solution is just to ask for programmers that know Haskell and ask them to program in PHP
10:55:14 <medfly> then they'd be good PHP coders.
10:55:17 <medfly> or something like that
10:55:18 <dolio> But then, it depends what you want them to do.
10:55:43 <ddarius> medfly: But they wouldn't want to program in PHP.
10:55:47 <medfly> :(
10:55:53 * medfly actually programs in PHP
10:56:08 <medfly> need to find more suckers like me
10:56:15 <scalaLove> AFTER THIS runghc "/home/me/Desktop/a.hs" I GET THIS: <interactive>:1:123: Not in scope: `Main.main'
10:56:33 <medfly> IS THERE A MAIN FUNCTION
10:56:45 <scalaLove> no
10:56:54 <mmorrow> :O
10:57:26 <Niccus> don't yell dudes :(
10:57:47 <scalaLove> big letters is not yelling, anyways sory :)
11:00:23 <DevHC> mmorrow, mauke
11:00:45 <scalaLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13656#a13656 how should i enclose it with main? ignore the paste errors
11:01:18 <dolio> Wow, fancy unicode.
11:01:37 <Niccus> for testing individual functions you're probably best off loading it in ghci
11:01:57 <Lemmih> scalaLove: How about using ghci?
11:02:57 <DevHC> scalaLove: smaller being defined to <= instead of < makes the sort non-stable :)
11:03:42 <scalaLove> Lemmih, i use ghci man
11:04:04 <scalaLove> DevHC leave the algorithm tell me how to enclose in main
11:04:04 <Lemmih> scalaLove: No, you don't.
11:04:51 <scalaLove> actually yes i dont sorry, i execute from terminal... when i execute from ghci i get errors that is why people told me here put it in file and use terminal
11:05:12 <DevHC> put "main = print $ qsort [2,8,0,0,1,3,3,7]" in ur program
11:05:25 <Lemmih> scalaLove: Put it in a file and then load that file in ghci.
11:05:46 <scalaLove> how
11:05:49 <mauke> <Niccus> within ghci you want to use :l
11:06:03 <scalaLove> chesus...
11:06:04 <DevHC> 1. run ghci
11:06:10 <mauke> 20 minutes ago
11:06:11 <DevHC> 2. input: :l myfile.hs
11:06:28 <DevHC> (that's an `ell`)
11:08:21 <ddarius> What's an e11?
11:08:33 <Niccus> an L
11:08:34 <DevHC> :D
11:08:43 <DevHC> btw
11:09:08 <DevHC> if i have a main function defines in my .hs file, why can't i use functions defined in that file when i load it up with ghci?
11:09:35 <ddarius> You should be able to if the file isn't already compiled.
11:09:43 <ddarius> If I remember correctly.
11:10:11 <DevHC> how is "already compiled" relevant?
11:10:28 <Niccus> not at all I'd imagine
11:10:33 <DevHC> :l myfile.hs loads up a file, interpreted
11:10:33 <ddarius> GHCi will load compiled code if available.  When it loads compiled code you can't access private functions.
11:11:55 <DevHC> how do i disable loading of compiled code?
11:12:07 <ddarius> Delete the .o/.hi files.
11:12:10 <DevHC> >.<
11:12:15 <DevHC> any easier way?
11:12:17 <mauke> :l *foo
11:12:25 <conal_> DevHC: touch the .hs files
11:12:27 <Lemmih> DevHC: Touch the source file.
11:12:34 <mauke> USE STAR POWER
11:12:42 * conal_ hi-fives Lemmih 
11:13:05 <ddarius> mauke: That's new.
11:13:09 <ddarius> (very new)
11:13:59 <DevHC> at least it would be plausible that if i type ":l myfile.hs" instead of ":l myfile", it would load the interpreted version...
11:14:17 <ddarius> (Maybe not that new.)
11:14:25 <DevHC> ?
11:15:24 <ddarius> If you have GHC 6.10.4 or later the * thing should work. (Possibly for earlier GHC 6.10 versions too.)
11:16:24 <mauke> I use 6.10.2
11:16:27 <DevHC> o
11:16:31 <DevHC> it does work
11:16:55 <ddarius> Yeah, I think the change listing is only between minor versions (i.e. 6.8 v. 6.10)
11:17:38 <ddarius> So 6.10.1 or later should behave that way
11:18:59 * ddarius looks at the GHC 0.29 User Manual
11:22:53 * ddarius wonders where some of these modules went.
11:35:03 <Optimality> anybody manage to get SDL working?
11:35:21 <kmc> while we're yelling about main i feel obliged to point out that it's not a function
11:36:09 <Optimality> I'm getting an "Undefined symbols: "_SDL_main" blah" error
11:36:21 <Lemmih> Optimality: Using osx?
11:36:26 <Optimality> Lemmih: indeed
11:36:39 <Optimality> Lemmih: the documentation suggests some workaround, but I can't get it to work
11:36:55 <Lemmih> Optimality: SDL is a nightmare on osx. See the MACOSX readme.
11:37:36 <Optimality> Lemmih: yep, read it - they point to an example, which I can follow, but they mention it has a corresponding cabal build, which I don't see
11:43:17 <Lemmih> Optimality: You basically have to write a C program that calls your Haskell main.
11:43:33 <Optimality> Lemmih: ugh
11:43:36 <Twey> Seriously?
11:43:37 <Twey> Why?
11:43:40 * Optimality considers dual-booting to linux
11:44:43 <Lemmih> SDL uses CPP macros to redefine 'main' to '_SDL_main'. They then have their own 'main' call '_SDL_main' after some initialization is done.
11:44:55 <kmc> ugh
11:45:03 <Optimality> == kmc
11:45:18 <kmc> @quote ugh
11:45:19 <lambdabot> olsner says: a mind won't be enough, you need a comind to go with it
11:46:09 <Lemmih> Someone on the SDL team needs a kick in the nuts.
11:46:17 <Twey> But why is this only a problem on OS X?
11:46:35 <Twey> (but yeah, ugh)
11:47:05 <Lemmih> On Linux they do the initialization in the SDL_Init function.
11:47:18 <Twey> Oh.
11:47:25 <mxyz> good news everybody!
11:47:28 <Twey> … why wasn't that good enough for OSX?
11:47:58 <Twey> Doesn't the OSX way also preclude initialising a subset of the available subsystems?
11:48:11 <mxyz> woops, its "good news everyone" isnt it. i always get that wrong
11:48:28 <mxyz> can someone help me with a simple cabal question?
11:48:35 <dons> please, just ask!
11:48:52 <Lemmih> mxyz: Can't, watching cartoons.
11:49:04 <Axman6> mxyz: perhaps you could try our #hackage channel. that's what it was started for :)
11:49:12 <mxyz> a godsend at haskell-cafe got my portaudio build to work
11:49:36 <mxyz> the problem is i did "runghc build portaudio" from some weird folder
11:49:48 <mxyz> so though it built I cant import it
11:50:10 <mxyz> can i just copy the portaudio.0.0.1 folder into the .../haskell platform/..../ folder?
11:50:33 <Lemmih> mxyz: Did you install it?
11:51:19 <mxyz> lemmih: i did "cabal unpack ..." and then " runghc setup configure" and  then " runghc setup build"
11:51:29 <Optimality> Lemmih: do you happen to recall where the full example is? All I have is the Test.hs
11:51:47 <Lemmih> mxyz: Do a 'cabal install'.
11:52:38 <mxyz> from the same folder i did the configure and build (the root "portaudio-0.0.1")
11:52:54 <mxyz> should i copy that folder into the haskell platform folder before i install?
11:53:02 <Lemmih> Optimality: Nope, sorry, the OSX stuff wasn't written by me.
11:53:41 <Lemmih> mxyz: No need to copy anything. Just enter the directory and run 'cabal install'.
11:53:46 <Optimality> Lemmih: okie doke - thanks anyways :)
11:55:10 <mxyz> lemmih: thank you. "import Sound.PortAudio" works now
11:55:39 <mxyz> however, the file are in some random temp folder, wouldnt it have better to move them into the HP folder to be organized?
11:56:24 <Lemmih> mxyz: You can delete the source package if you like.
11:57:32 <mxyz> no its not the source folder im talking about. im talking about the files from "cabal unpack portaudio". all the .o and .a files. the *actual* module files
11:59:54 <Lemmih> mxyz: Right, you can delete that entire directory if you like. The compiled library has been moved to a different location.
12:01:32 <mxyz> are you sure, lol? if i do a search in "C:\Program Files\Haskell Platform\2009.2.0.2" for port audio i find nothing. if i delete the folder with the "portaudio.hs" how will it be imported?
12:03:43 <Lemmih> mxyz: There's one way to find out.
12:09:31 * hackagebot upload: explore 0.0.6.2 - Experimental Plot data Reconstructor (CetinSert)
12:12:23 <mxyz> lemmih: thanks again for your help by the way
12:12:42 <Lemmih> No problem.
12:17:43 <scalaLove> runghc WC < quux.txt means?
12:18:11 <Twey> cat quux.txt | runghc WC
12:19:21 <dancor> < quux.txt runghc WC
12:19:47 <dancor> bash syntax is a font of joy
12:20:05 <Apocalisp> yeah, like comic sans
12:20:23 <dancor> well, it's comic
12:20:50 <Twey> Haha
12:20:50 <dancor> exactly
12:21:28 <scalaLove> i dont get it
12:22:04 <dancor> scalaLove: "runghc WC < quux.txt" and "cat quux.txt | runghc WC" and "< quux.txt runghc WC" all do basically the same thing in bash
12:22:05 <Lemmih> scalaLove: It runs the WC program with the contents of quux.txt as input.
12:22:36 <scalaLove> WC is?
12:22:52 <MoALTz> word count?
12:23:01 <joed> Where you go pee?
12:23:05 <Lemmih> scalaLove: Same as WC.hs.
12:23:09 <dancor> it would refer to a WC.hs file in the current directory
12:24:43 <scalaLove> so basically it translates quux.txt to WC.hs?
12:25:31 <Niccus> it feeds quux.txt as input to WC
12:25:51 <Niccus> contents of quux that is
12:25:54 <Lemmih> scalaLove: Not at all. It runs the program in WC.hs with the contents of quux.txt as input.
12:26:25 <scalaLove> i see
12:26:33 <scalaLove> thanks guys, going back to my book :)
12:32:50 <pastah_rhymez> exactly HOW does the case-of indentation work?
12:33:05 <ddarius> of starts a block of layout
12:33:07 <pastah_rhymez> i get an error for this
12:33:09 <pastah_rhymez>         let p' = case (g !!! p) of
12:33:11 <pastah_rhymez>             LON n -> LOF n
12:33:22 <aavogt> that's because the let starts a block too
12:33:25 <ddarius> You are closing lets block
12:33:36 <ddarius> (or continuing it rather)
12:33:40 <pastah_rhymez> whut?
12:34:10 <pastah_rhymez> why am i closing lets block with LON?
12:34:21 <aavogt> because you are indenting the same level as p'
12:34:26 <pastah_rhymez> it's indented one level beyond let
12:34:33 <pastah_rhymez> oh fuck me
12:34:40 <lament> ok
12:35:00 <pastah_rhymez> why can't we get a new keyword for "let" that's just two letters long?
12:35:17 <pastah_rhymez> that would've been swell for all of us four-spacers out here
12:36:09 <pastah_rhymez> are there any plans to change this?
12:36:10 <mxyz> wait just a second
12:36:20 <mxyz> you do 4 space tabs
12:36:26 <pastah_rhymez> yes
12:36:27 <mxyz> thats sickening ;)
12:36:35 <pastah_rhymez> mxyz: no you are
12:36:56 <mxyz> 3 space indents. you gotta keep it odd.
12:36:57 <Peaker> \x09 should simply not be used anywhere
12:37:04 <aavogt> let including the space is 4 characters
12:37:15 <aavogt> I see no issues with that one
12:37:28 <aavogt> > length "where "
12:37:29 <lambdabot>   6
12:37:29 <ddarius> pastah_rhymez: I'd recommend indenting past the enclosing construct in most cases, except for 'do'.
12:37:42 <aavogt> that one is unpleasant
12:37:54 <jmcarthur> pastah_rhymez: the real trick with haskell is to do away with past notions of consistent "spacing" and embrace consistent "blocking"
12:38:01 <pastah_rhymez> ddarius: that's how you reach 100 characters in line width
12:38:06 <Peaker> I indent 2 spaces after "where"
12:38:22 <ddarius> pastah_rhymez: I don't usually.
12:38:31 * pastah_rhymez rolls like it's 72
12:38:36 <jmcarthur> i don't usually have a problem keeping in 80 cols
12:38:51 * mmorrow likes <= 78
12:38:56 <aavogt> depends on variable names
12:39:07 * ddarius doesn't particularly care about column width limits.
12:39:08 <pastah_rhymez> i don't know why it's 72, but when we turn in labs for school, 72 is what we have to keep it to
12:39:10 * monochrom uses 79.99999993841
12:39:35 <c_wraith> what character is that wide?
12:39:42 <mmorrow> the snowman
12:39:43 <pastah_rhymez> actuall, i know that the optimal characters/line for best readability is 68
12:39:52 <monochrom> It is 72 because the TA reserves the left side 8 spaces for comments
12:40:18 <mmorrow> pastah_rhymez: yeah, i hate going much above 70
12:40:28 <pastah_rhymez> monochrom: is THAT how it's supposed to be done... no one told me when i was correcting the kidzs code
12:41:04 <ddarius> Why were the "kidzs" being taught to write incorrect code?
12:41:34 <monochrom> because you don't want every kidzs to get 100% marks.
12:42:04 <pastah_rhymez> no, i was correcting their code
12:42:06 <pastah_rhymez> as a TA
12:42:11 <sproingie> my perl and python code i keep within 100 cols
12:42:12 <ddarius> monochrom: We should teach all CS students in Coq and require proofs of correctness.
12:42:16 <monochrom> you want gaussian distribution. so you teach them to do random, then exploit central limit theorem to get gaussian.
12:42:18 <pastah_rhymez> but noone told me i should use thos 8 chars to write my comments
12:42:20 <sproingie> haskell i have little trouble keeping below 80
12:42:29 <sproingie> the traditional terse variable names help
12:42:49 <ddarius> monochrom: They'll get either 100% or 0% on assignments which will produce a binomial distribution.
12:43:08 <monochrom> Oh yes I dream of that too. doesn't proofcheck -> 0 marks. proofchecks -> marks inversely proportional to length
12:43:23 <jmcarthur> 65-70 is generally accepted as the most readable line width... for prose. i don't know how much that applies to code
12:43:56 <monochrom> The problem with binomial is that one semester is not enough time to give enough assignments to add binomials to gaussian.
12:43:56 <jmcarthur> and that's also for proportional type, not for monospace type
12:43:56 <sproingie> it applies pretty well
12:44:07 <Peaker> its nice to be able to have multiple code columns on a wide screen, so narrow columns are always nice/more efficient
12:44:12 <sproingie> i think it depends on what's in the code
12:44:34 <aavogt> @faq can you write Haskell in proportional fonts?
12:44:35 <lambdabot> The answer is: Yes! Haskell can do that.
12:44:46 <jmcarthur> actually, the general rule is 65-70 em widths
12:44:57 <jmcarthur> so i guess for monospace that would be 65-70 characters
12:45:30 <pastah_rhymez> i hate error handling
12:45:36 * pastah_rhymez is coding without rubber
12:45:51 <Axman6> dude, you've always got to use a rubber!
12:45:53 <roconnor> @src >=>
12:45:53 <lambdabot> Source not found.
12:45:57 <roconnor> @src (>=>)
12:45:57 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:46:01 <monochrom> And in line with my personal philosophy, a proof 1000 lines hacked together over 2 sleepless weeks is worth much less than a 10-line proof discovered in a day. OK I have no control over how many days, but I can still penalize lines, and let the free market figure out what to do with days, e.g., if they spend too many days, it hurts their other courses.
12:46:16 <pastah_rhymez> Axman6: that makes it feel like eating candy with the paper still around it
12:46:25 <Axman6> heh
12:46:33 <pastah_rhymez> Axman6: i know where it's been, it's safe
12:46:34 <gwern> Axman6: when all you have is a condom, every problem looks like something you can have sex with
12:46:47 <Axman6> XD
12:46:50 <monochrom> hahahahaha
12:46:53 <ddarius> monochrom: Which is why you don't have to bother (yourself) penalizing long proofs.
12:47:13 * gwern plagiarizes self from #wikipedia 3 or 4 years ago. but it's a great condom line
12:47:19 <monochrom> I doubt that in practice.
12:48:04 <monochrom> OK, I want to penalize both days and lines. I can directly penalize lines, and it indirectly penalizes days too. I like that.
12:49:50 <monochrom> The typical programming student is accustomed to working 2 sleepless weeks for a question. They take it for granted. They get away with it too, getting 100% just because with that much time you're bound to be comprehensive. I want an excuse to turn it around.
12:50:33 <mxyz> i always thought it was Rootabaga from reading the sandburg stories
12:50:35 <c_wraith> man, when I was grading, I tended to grade down for answers that weren't succinct.
12:51:07 <c_wraith> (Also, I had a fun time when I found someone had plagiarized *me* for an assignment)
12:51:22 <aavogt> how does that work?
12:51:31 <ddarius> c_wraith: Just wrote "tl;dr" and took 10 points off.
12:51:32 <lament> c_wraith: haha
12:51:48 <lament> c_wraith: harry potter had something about that
12:51:56 <lament> that makes you snape
12:52:58 <c_wraith> In this particular case, someone stole my assignment (poor unix security on my part.  world-readable isn't good for homework) the term I did it, and turned it in.  The next term I was grading for that course, and came across very suspicious code.
12:53:30 <ivanm> c_wraith: so you were accused of plagiarism and then they let you tutor it? :p
12:54:11 <c_wraith> ivanm: nah, the instructor knew I was the original author.  I was one of the few competent people in that class, and I wrote code with rather unusual idioms. :)
12:54:19 <ivanm> heh
12:54:21 <ddarius> "Wow, this code is a pile of crap.  ... wait!  This is my code!"
12:54:45 <ivanm> c_wraith: I had for one course where I discussed an assignment with someone online
12:55:01 <mrd> german comments?
12:55:02 <c_wraith> I think the guy who originally stole my code got expelled after his friend turned in the same code the next terrm.
12:55:07 <ddarius> c_wraith: Did you write purely functional C?
12:55:11 <ivanm> we then got told that there was a 0.3% similarity between our submissions, and we had to explain why or else we'd fail due to plagiarism
12:55:20 <c_wraith> .3%?  really?  wow.
12:55:31 <jaredj> that's above the legal limit
12:55:41 <jaredj> er
12:55:41 <c_wraith> which is...  .08%?  ;)
12:55:48 <ivanm> I gave them my MSN chat logs full of me calling him an idiot for how he wanted to do stuff, and they let us off
12:56:02 <ivanm> (basically, he got some ideas of _how_ to do stuff from me, but not any actual code)
12:56:20 <ivanm> c_wraith: our legal limit here is 0.05%...
12:56:36 <c_wraith> man, they really are cracking down on drinking and coding, aren't they? :P
12:56:50 <ivanm> heh
12:56:54 <medfly> in short, #haskell concludes that lazy students that only work an hour before they have to turn in the homework shoudl get higher grades
12:57:09 <medfly> I value work ethic (because I don't have any)
12:57:21 <ddarius> medfly: If they provide a machine checkable proof of correctness, hell yes!
12:57:38 <c_wraith> medfly:  actually, I value results that show understanding.  A braindump of all they half-know about the topic doesn't show that.
12:58:46 <ivanm> heh, I've tutored classes were students would come to my tutorial to learn stuff, but didn't want me to mark it for some reason... >_>
12:59:01 <medfly> were they afraid of you?
12:59:05 <ivanm> nope
12:59:20 <c_wraith> are you sure you didn't eat one at the start of the course just to put them in line?
12:59:26 <medfly> my sister said that she was in some linear algebra course and someone yawned loudly and the professor just left the class because he was insulted by it.
12:59:37 <ivanm> this was Matlab for a first year maths class; only myself and one other tutor actually had any "real" programming experience (I did IT, he did SE)
12:59:41 <ivanm> he had the same problem...
12:59:56 <medfly> wait what did you study?
13:00:11 <ivanm> I did BSc/BInfTech
13:00:14 <MoALTz> if i took notes then i wouldn't want the lecturer marking it
13:00:16 <ivanm> medfly: I was told of a class where the lecturer wrote on the top of the board "I get paid regardless" when the class wouldn't shut up
13:00:29 <medfly> I'm going to end up like that soon, woo
13:00:50 <medfly> haha
13:01:30 <jaredj> "it all pays the same," says one salaried coworker of mine, when they bury us under more forms
13:01:41 <c_wraith> heh.  mandatory attendance policies are so awful.  If the student isn't interested in being in the classroom, why punish every student who does want to be there?
13:02:01 <ivanm> c_wraith: we didn't have mandatory attendance, except for lab pracs
13:02:34 <medfly> yeah, I agree.
13:03:03 <c_wraith> my comment was more about the classroom that wouldn't quiet down.  that sounds like the result of a mandatory attendance policy
13:04:11 <mxyz> yea wtf. my job has a mandatory attendance policy when i can do all my work in my pajamas.
13:04:21 <monochrom> voluntary attendence may still be noisy. you know how students like to discuss among themselves instead of raising hands asking you when they miss something.
13:04:54 <ddarius> People like to talk, period.
13:05:28 <jaredj> that sentence seems ironic
13:05:40 <monochrom> I had classmates specifically asking me everything they miss during class. I specifically waved them silent because clearly otherwise it would be my turn missing something.
13:06:03 <medfly> by the way guys, since we're being off-topic
13:06:11 <ivanm> ddarius: exactly
13:06:23 <medfly> knowing what you know now, would you study CS?
13:06:24 <toast-opt> ivanm, there is such thing as off-topic here?
13:06:30 <jaredj> :D
13:06:42 <jmcarthur> medfly: yes, but at a different school
13:06:44 <ddarius> medfly: To learn or to get a degree?
13:06:47 <ivanm> toast-opt: vaguely, but why ask me?
13:06:48 <ivanm> ;-)
13:06:48 <medfly> get a degree.
13:06:54 <monochrom> I would still study CS.
13:06:55 <jmcarthur> to learn, is what i meant ;)
13:07:05 <ddarius> medfly: Sure it would be easy as pie and that's the only option.
13:07:05 <ivanm> toast-opt: the best bits are when we're talking about non-haskell stuff and #haskell-blah is talking about haskell
13:07:08 <mrd> medfly: i didn't study cs. so yes?
13:07:14 <jaredj> i would still study CS.
13:07:17 <medfly> mrd, what did you study?
13:07:24 <MoALTz> this should move to #haskell-blah
13:07:31 <medfly> I have this dilemma of whether I want to study CS.
13:07:37 <mxyz> many CS programs are just awful
13:07:38 <sproingie> i feel so silly.  solving the potential deadlock in my pause code was so simple
13:07:40 <medfly> to get a degree, that is. I can study CS on my free time, too.
13:07:47 <mrd> philo
13:08:01 <monochrom> someone plagized me. 100% similarity. <duck>
13:08:06 <sproingie> i just use tryPutMVar/tryTakeMVar, so any threads in a race lose gracefully instead of deadlocking
13:08:22 <ddarius> monochrom: Not 100%.
13:08:22 <jaredj> medfly: one of my classes was developing software in a group. that experience was invaluable and i couldn't have gotten it on my own
13:08:32 <monochrom> Oh oops! I see now. :)
13:08:46 <medfly> jaredj, really? not even if you worked as a programmer... developing software in a group?
13:08:49 <mrd> sproingie: so you spin?
13:08:50 <MoALTz> #haskell-blah
13:08:51 <lunabot>  luna: A section must be enclosed in parentheses
13:09:20 <toast-opt> medfly - dilemma of study CS or not; or dilemma of where to study CS: in university program or independent study
13:09:20 <jaredj> medfly: it's part of why i avoid developing software in groups >:)
13:09:32 <medfly> ahahaha
13:09:43 <sproingie> mrd: nope.  it just loses.  it's just a manual pause feature, worst thing that happens is if you bounce on the pause key, it drops the second one
13:09:47 <MoALTz> continue this in #haskell-blah guys(and girls)
13:09:55 <sproingie> was never likely to deadlock, i just didn't like the possibility
13:09:58 <medfly> I'm there!
13:10:05 <monochrom> I love haskell, and so can you.
13:10:11 <jaredj> join #haskell-blah
13:10:14 <jaredj> doh!
13:10:54 <sproingie> i'll probably move to TMVars for gamestate anyway, once i have a more complex game going
13:11:06 <sproingie> and then the deadlock goes away
13:14:39 <medfly> hi thermoplyae !
13:15:02 <thermoplyae> oh hey
13:15:10 <thermoplyae> how've you been
13:18:18 <thermoplyae> yeah i'm ok too.  this place is pretty quiet, i'll try back later
13:25:00 <sohum> is there a pddl library available in hackage?
13:26:33 <mxyz> if a module needs a .dll file how should it be linked? i tried to use a module in ghci and im getting an error that the .dll cant be found.
13:33:53 <houeland> Is there an easy way to compile my program on os x without getting gmp statically linked?
13:37:45 <fracture> wow... so... on windows, building hackage packages manually is infinitely easier than trying to get cabal to install them
13:38:15 <fracture> (at least for SDL and SDL-ttf...)
13:38:57 <scalaLove> how can haskell have type inference when it is strongly typed which means you always must explicitly say what type u use?
13:39:10 <lament> scalaLove: because that's not what strongly typed means.
13:39:22 <fracture> scala: "strongly typed" sorta means different things to different people anyway
13:40:07 <lament> scalaLove: strongly typed means each variable always refers to objects of one specific type
13:40:13 <mxyz> fracture: you got SDL working? i heard its particularly hard on windows
13:40:34 <fracture> mxyz: if you just try to build it from the hackage package it's actually relatively straightforward
13:40:52 <fracture> I bet most people try to get cabal to work, and after fucking with that for a while give up (I have tried multiple times in the past with that method and result)
13:41:13 <fracture> SDL_ttf was worse though:  I had to add some #undef main lines to some hsc files
13:41:14 <mxyz> good to hear. im going to be attempting it this week. im also putting up a tutorial with binaries for the portaudio library i finally got working
13:41:38 <lament> scalaLove: including arguments and return types of functions
13:41:48 <fracture> ah, well I'll probably be around here, so feel free to /msg me if you hit problems :)
13:41:54 <scalaLove> so type inference is part of a strong type system? but type inference is limited and inferes only in 100 % sure cases? something like that i guess, so it is still deterministic...
13:42:15 <kmc> scalaLove, not all strong type systems have inference
13:42:19 <lament> scalaLove: it is deterministic, if a type cannot be inferred your program will not compiler
13:42:22 <lament> -r
13:42:22 <kmc> in fact "strong" can apply to dynamic types too
13:42:35 <mxyz> actually im having 1 dumb problem. i finally got the module working and imported in GHCI but when i make a function call i get a "pa19" dll not found error. was i supposed to pass the path to ghci?
13:42:37 <fracture> where are you guys getting this definition of "strong"?
13:42:39 <scalaLove> oh lament that explains everything, thanks
13:42:41 <kmc> but strong and static type systems benefit greatly from inference, otherwise you have to write every type over and over
13:42:47 <kmc> see: C++, Java
13:42:49 <fracture> doesn't that prevent any language with runtime polymorphism from being called "strongly typed"?
13:43:00 <lament> oh yeah, i guess my definition is for 'static', not 'strong', sorry
13:43:20 <sproingie> "strong" typing is a pretty subjective term
13:43:26 <kmc> fracture, a type system is strong if it prevents horribly undefined behavior of the sort that C pointer casts allow
13:43:37 <fracture> kmc: wow, what a nice rigorous definition, thank you
13:43:42 <fracture> I'll file that away and remember it forever
13:43:43 <kmc> that's an imprecise definition though because "undefined behavior" is slippery to define
13:43:43 <lament> strong just means that only arguments and return values of functions are static, while other variables don't have to be
13:43:43 <mxyz> but thats what makes C so nice
13:43:46 <kmc> fracture, thanks for the sarcasm
13:43:49 <fracture> sure :)
13:43:52 <scalaLove> kmc yeah nice definition
13:44:04 <sproingie> actually that's kind of the definition of what a type system is about
13:44:11 <sproingie> the absence of certain behaviors
13:44:21 <mxyz> fracture: any idea about that dll problem?
13:44:26 <lament> strong = arguments and return values of functions are statically typed
13:44:31 <fracture> mxyz: sorry missed it; one sec
13:44:36 <lament> or possibly just arguments, and not even return values
13:44:53 <fracture> mxyz: what module is this?
13:44:55 <lament> or possibly just built-in functions and not all functions
13:44:59 <mxyz> Sound.PortAudio
13:45:04 <fracture> ah.. hm
13:45:19 <mxyz> it requires the portaudio dll not sure how to link it
13:45:24 <fracture> does that happen compiling in ghc also?
13:45:35 <mxyz> havent tried. one sec
13:45:40 <fracture> like if you put the stuff in a .hs, and try ghc -package <whateverportaudiois> foo.hs
13:45:47 <scalaLove> While strong, static typing makes Haskell safe, type inference makes it concise. The result is potent: we end up with a language that's both safer than popular statically typed languages, and often more expressive than dynamically typed languages.
13:46:02 <scalaLove> from a book, nice to remember that...
13:46:16 <fracture> anyway: if it does, I saw something in the WIN32 readme for the SDL package that said for ghci they had to put an extra copy of SDL.dll named SDL.dll.dll in an accessible directory (hahaha)
13:46:24 <fracture> for some reason GHCI appends an extra .dll to it
13:46:26 <fracture> so you could try that
13:46:28 <Axman6> scalaLove: that doesn't explain what strong typing is though
13:46:34 <fracture> brb one sec
13:47:28 <scalaLove> it does, it says static typing does not allow mistakes, and type inference breaks the limits of static typing while staying in the CORRECT TYPES zone... simple
13:47:48 <scalaLove> i see dynamic as bunch of undeterministic crazy stuff goin on at runtime
13:47:55 <lament> type inference doesn't break any limits
13:48:05 <lament> it simply means you don't have to explicitly write the types of things
13:48:18 <sohum> why isn't cabal updating parsec to 3.0 for me?
13:48:44 <lament> haskell without type inference would still be a pretty decent language, just more verbose
13:49:03 <lament> people already write signatures for functions, as a custom, even though they usually don't have to
13:49:21 <scalaLove> lament, what u just said is braking limits... me not obliged to specify each type and let the compiler infer is limit broken for me, why bother and write types where they are obvios
13:49:34 <ivanm> heya Axman6
13:49:40 <Axman6> o/
13:49:44 <lament> sure, it's just not a very interesting limit to break :)
13:49:44 <ivanm> scalaLove: sounds like RWH
13:49:51 <NNshag> static typing without minimal inference is usually called explicit typing...
13:49:59 <lament> it saves you time, but the time saved is linear with the size of your program
13:50:14 <scalaLove> RWH?
13:50:33 <lament> even ARC saves you time linearly with program size, simply because all the names are short
13:51:08 <ivanm> @where rwh
13:51:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:51:10 <ivanm> scalaLove: ^^
13:51:11 <mxyz> what's the include flag for ghc?
13:51:13 <ClaudiusMaximus> lament: i thought there are examples of types that are exponential with program size..
13:51:20 <fracture> mxyz: you want -package <something> I think
13:51:27 <lament> ClaudiusMaximus: heh
13:51:47 <scalaLove> ivanm yes i read that book now :)
13:52:23 <ClaudiusMaximus> mxyz: usually you want ghc --make
13:52:48 <mxyz> fracture: yea, when i try to compile "import Sound.PortAudio; main = do getHostApiCount" i get a bunch of "undefined reference to" errors probably because of the missing dll
13:53:14 <fracture> mxyz: thge dll is only used at runtime, so it is from a missing .lib
13:53:21 <fracture> are you passing a -package <something> line?
13:53:46 <mxyz> no. ok so how do i link the .lib then?
13:54:16 <fracture> what is the name of the hackage package for port audio?
13:54:34 <fracture> ah portaudio
13:54:36 <fracture> (just looked it up)
13:54:37 <fracture> ok so try
13:54:43 <fracture> ghc -package portaudio yerfile.hs
13:54:48 <fracture> and see if it helps?
13:55:12 <mxyz> C:\A\programming\haskell\test>ghc -package portaudio test.hs
13:55:12 <mxyz> compilation IS NOT required
13:55:20 <mxyz> that was the output
13:55:22 <fracture> :)
13:55:25 <fracture> it just linked it then
13:55:31 <mxyz> nice
13:55:35 <fracture> ok so now when you run it you'll have trouble with the dll (heh)
13:55:43 <sohum> :t (<?>)
13:55:45 <lambdabot> Not in scope: `<?>'
13:55:56 <fracture> easiest thing for futzing around is just put a copy of the .dll in the same directory as the exe you made
13:55:59 <fracture> and it should hopefully work
13:55:59 <mxyz> so just drop the dll in the same folder with the .exe?
13:56:01 <fracture> ya
13:56:10 <mxyz> yea thats fine. awesome. thanks!
13:56:15 <fracture> np
13:56:22 <sohum> @hoogle <?>
13:56:23 <lambdabot> Text.Parsec.Prim (<?>) :: Monad m => ParsecT s u m a -> String -> ParsecT s u m a
13:56:23 <lambdabot> Text.ParserCombinators.Parsec.Prim (<?>) :: Monad m => ParsecT s u m a -> String -> ParsecT s u m a
13:57:40 <Veinor> > let f x = (1:) x; x = f x in x
13:57:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:58:14 <Axman6> Veinor: (1:) x? why not 1:x?
13:58:22 <Veinor> I was just using that for a friend.
13:58:33 <Veinor> er, god my english sucks sometimes :<
13:58:40 <Peaker> @src fix
13:58:40 <lambdabot> fix f = let x = f x in x
13:58:46 <Veinor> yeah, I know about fix
13:58:51 <mxyz> fracture: woo, dropped in the .dll and it did work. is there a way to get this to work in ghci?
13:58:52 <Veinor> I'm just showing him how x = f x can be useful :D
14:01:32 <mxyz> fracture: nevermind. you were right i did have to rename it with .dll.dll ! :)
14:01:50 <mxyz> they should really fix that!
14:03:17 <toast-opt> > let f x = (:) x $ f x in f []
14:03:18 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
14:04:04 <ivanm> > fix ((:) [])
14:04:05 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
14:04:15 <ivanm> > fix (:[])
14:04:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:04:24 <ivanm> > fix ([]:)
14:04:25 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
14:04:28 <ivanm> fix-point monkey!
14:07:57 <Veinor> repeat is tail-recursive, yeah?
14:08:14 <shachaf> I doubt it.
14:08:15 <shachaf> @src repeat
14:08:16 <lambdabot> repeat x = xs where xs = x : xs
14:08:29 <ivanm> so no
14:08:40 <ivanm> since it doesn't call repeat...
14:09:54 <c_wraith> Veinor: tail recursion doesn't show up in haskell that often
14:10:04 <ivanm> laziness > tail recursion
14:12:36 <sohum> :k Parsec
14:12:38 <lambdabot> Not in scope: type constructor or class `Parsec'
14:12:49 <sohum> @hoogle Parsec
14:12:49 <lambdabot> module Text.Parsec
14:12:50 <lambdabot> module Text.ParserCombinators.Parsec
14:12:50 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
14:13:10 <sohum> so Parsec should be * -> * -> *, yea?
14:13:27 <c_wraith> @kind Parsec
14:13:29 <lambdabot> Not in scope: type constructor or class `Parsec'
14:13:33 <c_wraith> @kind ParsecT
14:13:35 <lambdabot>     Not in scope: type constructor or class `ParsecT'
14:14:15 <roconnor> are there applicative arrows?
14:15:02 <Peaker> roconnor: what do you mean?
14:15:28 <roconnor> is c -> a b   and arrow for applicative functor a?
14:15:34 <roconnor> an arrow
14:15:41 <dolio> a (c -> b) is
14:15:42 <sohum> I ask because :k Parsec in ghci gets me * -> * -> * -> *
14:16:08 <sohum> oooh, wait
14:16:13 <dolio> arr = pure; f >>> g = (.) <$> f <*> g
14:17:05 <kmc> Parsec API has changed a lot recently iirc
14:17:30 <dolio> Verifying the arrow laws is left as an exercise for the reader, because I haven't bothered.
14:18:40 <sohum> kmc: hm. I have both parsec-2.1 and parsec-3.0 installed. how are import statements going to behave?
14:19:18 <Axman6> badly >_>
14:19:22 <c_wraith> sohum: depends on what you tell ghc to do
14:19:59 <sohum> c_wraith: ? is there some sort of pragma I can stick in my file?
14:20:30 <c_wraith> sohum: technically, I guess.  It's better to use cabal to manage this sort of thing
14:20:54 <sohum> c_wraith: hrm. fair enough. lemme poke at haskell wiki then...
14:26:00 <c_wraith> cabal is a good build system.  It's worth using once you have more than one source file.
14:26:15 <Veinor> does undefined have any type as defined in usual type theory? it's obviously not _|_ or ()...
14:26:30 <c_wraith> technically, undefined is _|_
14:26:47 <Veinor> but I thought _|_ had no values.
14:26:49 <sohum> does cabal stand for anything?
14:26:57 <p_l> sohum: I doubt it
14:27:01 <sohum> completely automated building and linking? :P
14:27:02 <c_wraith> sohum: not that I'm aware of.  but I just use it. :)
14:27:26 <sohum> Veinor: undefined isn't a value, though
14:27:39 <sohum> Veinor: it's precisely the lack of a value
14:27:55 <Lemmih> p_l: Common Architecture for Building Applications and Libraries.
14:28:10 <sohum> oh, of /course/
14:28:26 <c_wraith> Veinor: a return type of _|_ means "no returned value".  undefined is one way of achieving that goal
14:28:58 <c_wraith> Veinor: another is to just never return
14:29:18 <scalaLove> If i want to transit from imperative to functional i should go with haskell instead scala because it is purely functional, i mean scala allows vars and that is imperative. agree?
14:29:41 <sproingie> not necessarily, it depends how you use them
14:30:06 <Peaker> scalaLove: #haskell would probably recommend Haskell for FP :-)
14:30:20 <Peaker> scalaLove: and I'd venture that #scala would recommend Scala :)
14:30:32 <scalaLove> haskell is not a religion, you are programmers so be objective
14:30:35 <sproingie> i wonder what #clojure would recommend?
14:30:47 <scalaLove> be serious please
14:30:51 <toast-opt> heh, but what would #C++ recommend?
14:31:03 <sproingie> we like haskell
14:31:15 <sproingie> it's hard to get more FP than haskell
14:31:19 <c_wraith> toast-opt: #C++ would recommend template metaprogramming. :)
14:31:26 <scalaLove> it is not about like, i am asking as guy that wants to transit to functional
14:31:28 <toast-opt> c_wraith , doh.
14:32:19 <pikhq> scalaLove: Haskell is not a religion. Haskell is nirvana.
14:32:26 <sproingie> well haskell will certainly make you think functional, all the time
14:32:38 <sproingie> no escape hatches like you get with scala or clojure
14:32:41 <scalaLove> sproingie that was my point yes
14:33:10 <c_wraith> sproingie: there are escape hatches...  They're just ugly.  Use IORef for everything!
14:33:12 <sproingie> clojure has quite a few less escape hatches, though one leads to a doozy (java)
14:33:22 <sproingie> c_wraith: those are still pure
14:33:33 <sproingie> now unsafePerformIO on the other hand...
14:33:36 <toast-opt> template <class F> struct fix { struct type { template<class A> struct apply : F::template apply<F>::type {}; }; };
14:33:38 <toast-opt> i think
14:33:42 <toast-opt> .. isn't that pretty
14:37:43 <toast-opt> sproingie, is clojure pure?  i thought side effects were permitted
14:39:09 <mxyz> clojure is pure
14:39:33 <toast-opt> i guess it might as well be, with STM and all it would have to model side effects
14:39:38 <toast-opt> are they part of types then?
14:39:44 * shortcircuit wants to know how a functional language would implement something like this: http://rosettacode.org/wiki/Rate_Counter
14:40:28 <sproingie> clojure can have side effects.  if you put IO in STM, it may execute multiple times
14:40:33 <toast-opt> shortcircuit - monads for instance.  you pass the state through each function
14:40:49 <toast-opt> and you represent that passing-thru abstractly
14:41:28 <shortcircuit> Mm.
14:41:34 <sproingie> the intended operation of clojure is pure, it just doesn't go to heroic lengths to enforce it
14:42:18 <toast-opt> sproingie - ok, so the style of clojure is to write pure functions, but aren't enforced
14:42:37 <shortcircuit> toast-opt: Are monads allowed in pure-functional programming?
14:42:52 <c_wraith> shortcircuit: there's nothing impure about monads.
14:43:12 * shortcircuit doesn't understand much about functional programming. :-|
14:43:18 <toast-opt> shortcircuit, a monad is a set of functions...
14:44:03 <toast-opt> basically, the result of any monadic code is a result of type (a -> m a)
14:44:07 <sproingie> toast-opt: it's "enforced" insofar as it gives you functional data structures in its stdlib, but you can always reach for impure ones elsewhere.
14:44:14 <kmc> pure does not mean "no side effects".  pure means "functions do not have side effects"
14:44:25 <kmc> we have our own datatype for side effects, which is orthogonal to the datatype of functions
14:44:35 <toast-opt> or instance, the IO a monad is of type ( RealWorld -> (a, RealWorld) )
14:44:46 <toast-opt> a pure function over the whole world ;)
14:44:51 <sproingie> ST RealWorld# anyway
14:45:09 <c_wraith> sproingie: I think it's State#, not ST.  But that detail isn't too important. :)
14:45:10 <kmc> "orthogonal" in the sense that they are totally distinct types, but they cooperate in the expected way -- a function can return a side effect, or a side effect can execute resulting in a function
14:45:34 <shortcircuit> If I'm going to understand this, I need to learn the type description syntax.  Have any good resources for a guy who hasn't yet ventured outside of imperative languages?
14:45:38 <mxyz> to uninstall a cabal package do i use "ghc-pkg unregister"?
14:45:54 <toast-opt> the part i really like is you can have real pure functions that take monadic functions as input/output...
14:46:13 <toast-opt> and monadic functions can work over values of non-monadic, ie really pure, functions too
14:46:14 <sproingie> mxyz: yes
14:46:20 <mxyz> thanks
14:46:37 <sohum> @src asTypeOf
14:46:38 <lambdabot> asTypeOf = const
14:46:42 <sohum> :t const
14:46:43 <lambdabot> forall a b. a -> b -> a
14:46:45 <sohum> :t asTypeOf
14:46:46 <lambdabot> forall a. a -> a -> a
14:46:53 <sohum> @let text = asTypeOf
14:46:55 <lambdabot>  Defined.
14:46:59 <sohum> uh, woops
14:47:05 <sohum> that was meant to be test
14:47:26 <sohum> @undef text
14:47:47 <sohum> @let test = asTypeOf
14:47:49 <lambdabot>  Defined.
14:47:49 <sohum> :t test
14:47:51 <lambdabot> forall a. a -> a -> a
14:47:54 <sohum> hmm.
14:48:03 <sohum> the problem doesn;t come up there...
14:49:01 <mxyz> why exactly does Haskell install things in "C:\Program Files\Haskell Platform" AND "C:\Program Files\Haskell"?
14:49:15 <sohum> @undefine text
14:49:16 <sohum> @undefine test
14:49:35 <sproingie> beats me, i always install the platform in C:\hp
14:49:37 <c_wraith> mxyz: Haskell platform is a collection of libraries.  haskell is the compilation system
14:50:00 <c_wraith> mxyz: well, GHC is the compilation system.  I'm assuming that's what's in \Haskell
14:50:13 <mxyz> nope
14:50:28 <c_wraith> Oh.  well, that's interesting.
14:50:30 <mxyz> GHC is in "C:\Program Files\Haskell Platform\2009.2.0.2\ghc-6.10.4"
14:50:36 <mxyz> along with all the libraries
14:51:19 <mxyz> but when I installed c2hs it created "C:\Program Files\Haskell" and then later when I installed unpacked a library myself (instead of with cabal install) it put it in /haskell/ instead of with the other libraries in /hp/
15:04:41 <patch-tag> is there a preludy function that does something like applyNTimes?
15:04:45 <patch-tag> could be defined as...
15:04:48 <patch-tag> applyNTimes n f x = foldl' (\z _ -> f z) x $ nWhatevers n
15:04:58 <sohum> Baughn: awww. why is the funName :: ...<Enter><Tab><Tab> inserts "funName = " behaviour gone?
15:05:03 <patch-tag> nWhatevers n = take n . repeat $ error "this is just a placeholder, you shouldn't be using it"
15:05:06 <Peaker> patch-tag: iterate then !!
15:05:23 <Peaker> > iterate (*2) 1 !! 5
15:05:24 <lambdabot>   32
15:05:33 <patch-tag> can iterate be defined in terms of something more primitive, like fix or fold{l/r} ?
15:05:59 <toast-opt> unfold
15:06:07 <patch-tag> ahhh...
15:06:28 <Peaker> @src iterate
15:06:28 <lambdabot> iterate f x =  x : iterate f (f x)
15:06:36 <toast-opt> @src  unfold
15:06:36 <lambdabot> Source not found. :(
15:06:43 <toast-opt> @src unfoldl
15:06:43 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:06:51 <toast-opt> heh, nice :)
15:06:53 <Peaker> @. pl src iterate
15:06:54 <lambdabot> (line 1, column 1):
15:06:54 <lambdabot> unexpected end of input
15:06:54 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:06:58 <c_wraith> @src unfoldr
15:07:00 <lambdabot> unfoldr f b  = case f b of
15:07:00 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
15:07:00 <lambdabot>    Nothing        -> []
15:07:00 <Peaker> @pl iterate f x =  x : iterate f (f x)
15:07:00 <lambdabot> iterate = fix ((ap (:) .) . ((.) =<<))
15:07:32 <patch-tag> I guess fibs then can be defined in terms of unfold... as I have defined it in terms of iterate
15:07:51 <Peaker> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
15:07:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
15:07:53 <patch-tag> fib n = head . applyNTimes n nextfibs $ [1,1]
15:08:03 <patch-tag> nextfibs fibs@(x:y:_) = x+y : fibs
15:08:15 <patch-tag> seems easier to me than the usual zipWth :)
15:08:18 <c_wraith> > fix $ (0:) . scanl (+) 0
15:08:20 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:08:23 <c_wraith> err
15:08:24 <c_wraith> oops
15:08:27 <c_wraith> > fix $ (0:) . scanl (+) 1
15:08:29 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:08:31 <c_wraith> there
15:08:45 <toast-opt> ooo, i like that
15:08:56 <c_wraith> scanl rather feels like it was designed for just that trick.
15:08:58 <toast-opt> @src scanl
15:08:59 <lambdabot> scanl f q ls = q : case ls of
15:08:59 <lambdabot>     []   -> []
15:08:59 <lambdabot>     x:xs -> scanl f (f q x) xs
15:09:31 <toast-opt> oh, i see, it produces a list of fold results
15:09:42 <c_wraith> yep
15:09:47 <c_wraith> there's also scanr
15:09:52 <c_wraith> but that's...  bizarre
15:10:03 <Veinor> > scanr (*) 1 [1, 2, 3, 4]
15:10:05 <lambdabot>   [24,24,12,4,1]
15:10:18 <Veinor> > scanl (*) 1 [1, 2, 3, 4]
15:10:20 <lambdabot>   [1,1,2,6,24]
15:10:23 <toast-opt> @src scanr
15:10:23 <lambdabot> scanr _ q0 []     =  [q0]
15:10:23 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
15:10:23 <lambdabot>     where qs@(q:_) = scanr f q0 xs
15:10:43 <c_wraith> > scanr (:) [] [1..7]
15:10:44 <lambdabot>   [[1,2,3,4,5,6,7],[2,3,4,5,6,7],[3,4,5,6,7],[4,5,6,7],[5,6,7],[6,7],[7],[]]
15:11:11 <ClaudiusMaximus> @hoogle guard
15:11:12 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
15:11:12 <lambdabot> Language.Haskell.TH data Guard
15:11:12 <lambdabot> Language.Haskell.TH.Syntax data Guard
15:11:40 <c_wraith> basically, scanr loses the basic purpose of using foldr, which is preserving laziness
15:12:01 <toast-opt> oh, true
15:12:17 <toast-opt> how is foldr lazy though?
15:12:26 <toast-opt> it has to do everything if it does anything
15:12:36 <c_wraith> double-check that.
15:12:45 <toast-opt> oh, nm
15:12:49 <toast-opt> heh
15:12:58 <toast-opt> i forgot list operations
15:12:59 <mxyz> yea scalaLove was getting kinda creepy, noris
15:13:04 <toast-opt> and other constructions
15:13:49 <toast-opt> so unfoldr can never be lazy?
15:13:55 <c_wraith> unfoldr is always lazy
15:14:00 <mxyz> noris > doc_2
15:14:04 <toast-opt> sorry, scanr
15:14:12 <doc_2> haha
15:14:19 <c_wraith> well, scanr probably is lazy, if you only examine the head of the result
15:14:28 <toast-opt> i'll have to look at that... laziness is the trickiest part of haskell i think :)
15:14:31 <sohum> ok, so I have created a cabal file saying that my project depends on parsec >= 3.0, and stuck the source files in the appropriate places. Does ghci pick this up automatically?
15:14:47 <c_wraith> but if you care about the full list, it has to do all the work to fully generate the head element.
15:16:00 <mxyz> oh man. you're bumming me out
15:16:33 <scalaLove> :) stop it
15:16:37 <scalaLove> are u admin
15:17:33 <toast-opt> c_wraith but, what if i'm scanr-ing with \x y -> y : x
15:17:52 <toast-opt> or, hmm, i think i got that backwards
15:18:06 <c_wraith> yeah, I don't think that works, type-wise. :)
15:18:23 <toast-opt> \x y -> y ++ [x]
15:18:36 <ivanm> scalaLove: why are you asking about admins? do you _want_ to be kicked for some reason? :s
15:18:44 <toast-opt> all those appends will be lazy
15:19:04 <c_wraith> toast-opt: but if you fully examine the first result of scanr, it will do all the work.
15:19:41 <toast-opt> c_wraith, of course.  but same of the one result of folds, right?
15:20:29 <c_wraith> toast-opt: I guess my point is this:  scanl is lazy, foldr is lazy.  foldl can't be lazy, scanr can't be lazy.
15:20:39 <scalaLove> ivanm nah it was a joke...nevermind
15:20:56 <toast-opt> c_wraith, i think i get you now.  thx for explaining
15:27:13 <pastah_rhymez> <3 <3 <3 when <3 <3 <3
15:27:31 <pastah_rhymez> this looks soooooo pretty
15:39:09 <pastah_rhymez> @pl \idm state -> fst (runState (unIDM idm state))
15:39:10 <lambdabot> ((fst . runState) .) . unIDM
15:39:51 <patch-tag> earlier we saw iterate defined with fix, can it also be defined with a fold/unfold/whatever (some recursion scheme other than fix?)
15:40:03 <pastah_rhymez> @pl \idm state -> fst (runIDM idm state)
15:40:04 <lambdabot> (fst .) . runIDM
15:40:59 <ddarius> > let iterate f x = unfoldr (Just . (id&&&id) . f) x in iterate succ 1
15:41:01 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
15:41:15 <ddarius> > let iterate f x = unfoldr (Just . (f&&&id)) x in iterate succ 1
15:41:17 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
15:41:31 <ddarius> > let iterate f x = unfoldr (Just . (id&&&f)) x in iterate succ 1
15:41:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:41:45 <Veinor> @src iterate
15:41:45 <lambdabot> iterate f x =  x : iterate f (f x)
15:41:56 <ddarius> @. pl src iterate
15:41:56 <lambdabot> (line 1, column 1):
15:41:56 <lambdabot> unexpected end of input
15:41:56 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:42:09 <Veinor> @@ @pl @src iterate
15:42:10 <lambdabot>  (line 1, column 1):
15:42:10 <lambdabot> unexpected end of input
15:42:10 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:42:14 <Veinor> :/
15:42:28 <ddarius> The @src command is special for some reason and can't be used in those types of commands.
15:42:34 <ddarius> (commands like @. and @@
15:42:35 <ddarius> )
15:42:55 <ddarius> (And by "special," I probably mean buggy."
15:43:41 <kmc> what are the major use cases for GADTs?
15:43:53 <kmc> are they all categorized as DSLs?
15:44:22 <ddarius> kmc: No
15:50:18 <pastah_rhymez> @src forM_
15:50:18 <lambdabot> forM_ = flip mapM_
15:50:22 <pastah_rhymez> thought so :)
15:51:06 <pastah_rhymez> kmc: i know we used it in a lab at school
15:51:15 <pastah_rhymez> we made an implementation of turtle graphics
15:52:26 <pastah_rhymez> GADTs made it extremely easy to instance monad for what we had (since you can hade Lol a, but still have Bind :: Lol a -> (a -> Lol b) -> Lol b)
15:52:49 <pastah_rhymez> and you magically get your 'b', something which isn't as easy without GADTs
15:55:03 <pastah_rhymez> kmc: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lab1.html
15:55:21 <kmc> pastah_rhymez, you went to Chalmers?
15:55:23 <kmc> or just used their labs?
15:55:28 <pastah_rhymez> i go there
15:55:32 <kmc> undergrad or grad?
15:55:46 <pastah_rhymez> doing my bachelor project this spring
15:55:50 <kmc> cool
15:56:05 <pastah_rhymez> i've applied for "writing a haskell interpreter in JS"
15:56:08 <kmc> i get the impression it's like haskelltopia up there
15:56:39 <pastah_rhymez> well, we do our fair share of hasklin' here
15:57:07 <pastah_rhymez> it's the first programming course you get to study when you start at the CS program
15:58:33 <tessier> Haskell interpreter in js? Ouch.
15:58:43 <tessier> Wouldn't it be more interesting to do a js interpreter in Haskell?
15:58:46 <pastah_rhymez> tessier: YHC already has a JS backend
15:58:55 <pastah_rhymez> hmm... maybe it can be written in haskell...
15:58:58 <pastah_rhymez> HMMMM....
15:59:21 <pastah_rhymez> tessier: that'd be way too easy
16:00:09 <scalaLove> The main difference between C and Haskell is that the fields in the Haskell type are anonymous and positional. What does this mean? Anonymous and positional?
16:00:33 <pastah_rhymez> scalaLove: have you looked at haskell records?
16:00:58 <pastah_rhymez> (i'm guessing that that is what the text is refering to)
16:01:39 <p_l> scalaLove: anonymous&positional = referenced by position, not name?
16:01:46 <pastah_rhymez> @where rwh
16:01:46 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:02:08 <pastah_rhymez> scalaLove: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.record
16:02:54 <pastah_rhymez> though with records the datatype fields get names, but that's only syntactic sugar
16:03:09 <Veinor> yeah, records are just a convenient way to define functions
16:03:21 <scalaLove> text compares C structs and Haskell's Data you know...
16:04:04 <pastah_rhymez> scalaLove: as i thought
16:04:05 <Veinor> they are similar
16:05:27 <scalaLove> so anything more i should know about this positional thing? confuses me... why not refer to a field by a name?
16:05:32 <pastah_rhymez> scalaLove: when you use records in haskell, it's like working with javas public class variables (but a bit trickier, because of immutable data)
16:05:48 <c_wraith> scalaLove: It's hard to curry by name.  it's easy to curry by position
16:05:50 <pastah_rhymez> scalaLove: read what i linked to ^^^
16:06:34 <scalaLove> pastah I am reading that book now man, i am a litle before what u pointed me to
16:06:49 <c_wraith> scalaLove: currying by anything other than position is *really* hard in a language with as strong of a type system as haskell
16:06:49 <pastah_rhymez> oh, ok
16:07:00 <pastah_rhymez> but what they introduce there ARE names
16:07:15 <pastah_rhymez> scalaLove: i'll whip you up a small example
16:11:42 <Veinor> is there a limit to how many fields a Data can have?
16:12:02 <scalaLove> thanks, i learn haskell yesterday and now all night, it is encouraging u guys helping me...
16:12:08 <scalaLove> limit? not that i know of
16:12:16 <pastah_rhymez> scalaLove: 1 more minute...
16:13:39 <Axman6> @hoogle Either
16:13:39 <lambdabot> module Data.Either
16:13:39 <lambdabot> Prelude data Either a b
16:13:39 <lambdabot> Data.Either data Either a b
16:13:46 <Axman6> @hoogle Either a b -> c
16:13:46 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
16:13:46 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
16:13:46 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
16:15:18 <pastah_rhymez> @hpaste
16:15:18 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:15:54 <pastah_rhymez> scalaLove: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5275#a5275
16:16:09 <pastah_rhymez> i haven't tested that, but i'm assuminig it works :)
16:20:12 <scalaLove> first of all thank you :), second... i understand what the firs segment of code does, it gets triple of 0s and sets the first to 1... in very general way explained... where is positional thing happening?
16:20:19 <Axman6> would someone mind taking a look at the edits i've made to http://en.wikipedia.org/wiki/Haskell_(programming_language)#Algebraic_data_types ?(all that was there before was a list of things needing to be put there
16:20:35 <pastah_rhymez> scalaLove: positioning thing IS always there
16:20:58 <pastah_rhymez> with positions it means that the data held by RGB0 is held in three positions
16:21:14 <scalaLove> so fields are manipulated, and they are refered as their position not their name/?
16:22:20 <c_wraith> scalaLove: record syntax just creates accessors for each field, so you don't have to do it yourself.  Otherwise, they're the same as non-record syntax.  everything is stored by position
16:22:26 <pastah_rhymez> well, as i said, records are just syntactic sugar
16:23:05 <kmc> records are sugar laced with strychnine
16:24:00 <pastah_rhymez> scalaLove: reload that paste page
16:25:47 <pastah_rhymez> scalaLove: 'red'/'green'/'blue' are all functions of type 'RGB1 -> Float'; what they do different from each other is that they 'select' different fields in the datatype
16:26:13 <scalaLove> wait, you lose me on the first part
16:26:16 <scalaLove> fillRed :: RGB1 -> RGB1
16:26:19 <scalaLove> fillRed c = c { red = 1 }
16:26:26 <pastah_rhymez> yes?
16:26:27 <scalaLove> fillRed c means?
16:26:44 <pastah_rhymez> read my how-to-read-guide for 'fillGB'
16:27:07 <scalaLove> ok
16:27:20 <pastah_rhymez> you get it?
16:27:33 <Axman6> guess not
16:27:42 <pastah_rhymez> awww
16:31:09 <Saizan> Axman6: the description above the Pattern Matching snippet doesn't seem to match the content
16:31:28 <Saizan> Axman6: it talks about 3 functions, but there are 6 of them
16:32:54 <scalaLove> sorry internet problem, was diconected
16:33:03 <scalaLove> thank you i understand now :)
16:34:01 <pastah_rhymez> scalaLove: though you do not always want to use records
16:34:11 <pastah_rhymez> when you make a simle type; like Ordering
16:34:19 <pastah_rhymez> ":i Ordering" <-- in ghci
16:34:33 <pastah_rhymez> well, mostly because that doesn't hold any values, but still
16:34:33 <Saizan> @src Ordering
16:34:33 <lambdabot> data Ordering = LT | EQ | GT
16:34:56 <pastah_rhymez> if it's simple enough then you probably don't need to use records
16:35:25 <c_wraith> records are also a very poor idea when you have multiple constructors
16:35:46 <c_wraith> it's easy to accidently write code that fails with a pattern match eror if you use record syntax with multiple constructors
16:35:53 <pastah_rhymez> i saw this the other day; "data Transaction = Withdrawal Double | Insertion Double"
16:37:14 <Axman6> Saizan: thanks for that :)
16:37:37 <pastah_rhymez> c_wraith: though i have found it quite useful at times, to be able to get rid of nasty pairs which messed stuff up; "data ChessPiece = ... Rook { pos :: (Int,Int) ..." instead of "type CheissPiece = (PieceType, (Int,Int))"
16:38:04 <pastah_rhymez> and then giving ALL the pieces a field "pos :: (Int,Int)"
16:38:30 <c_wraith> pastah_rhymez:  Sure, but if they don't all have the same structure, that won't work.
16:38:40 <pastah_rhymez> true
16:38:57 <pastah_rhymez> scalaLove: ^^ is this way over your head or do you understand what we're talking about?
16:38:59 <scalaLove> i set a goal to solve euler problem #5 today in haskell
16:39:17 <scalaLove> i understood enough i think :) thank you so much
16:40:02 <scalaLove> i solved first 4 in scala, will try #5 in haskell today
16:40:23 <c_wraith> project euler is really good for teaching how to do dynamic programming in haskell. :)
16:40:33 <shambler> dynamic?
16:40:42 <shambler> what's that?
16:40:42 <pastah_rhymez> c_wraith: i suck at that (dynamic programming)
16:40:53 <pastah_rhymez> shambler: a clever recursion thing
16:41:06 <shambler> ohh
16:41:09 <shambler> i remember now
16:41:12 <c_wraith> basically, it's reversing recursion, with memoization.  Build a table of results from the bottom up
16:41:33 <pastah_rhymez> http://www.haskell.org/haskellwiki/Dynamic_programming_example
16:41:33 <c_wraith> It turns out to be really clean in haskell, once you see a good example of it.
16:41:42 <c_wraith> yeah, that example. :)
16:41:42 <shambler> thanks
16:42:40 <c_wraith> (though due to the language being lazy, it's hard to claim there's a real difference between dynamic programming and straightforward memoization)
16:43:22 * pastah_rhymez did a fugly lookup table array hack a week ago
16:43:27 <copumpkin> if you want dynamic programming, use a histomorphism, or if that fails, a dynamorphism!!
16:43:40 <pastah_rhymez> 90%+ of my arrays were uninitialized
16:44:00 <copumpkin> I wonder if a dynamic programming version of an algorithm can be derived automatically if one exists
16:44:04 <copumpkin> probably not
16:44:31 <pastah_rhymez> copumpkin: i see a PhD thesis project here
16:44:36 <copumpkin> :)
16:44:54 <copumpkin> the sad thing is that if one were found in terms of *morphisms, the rest of the world wouldn't notice
16:45:02 <copumpkin> and would write it off as arcane mathturbation
16:46:03 <pastah_rhymez> http://xkcd.org/664/ <-- mouseover
16:46:55 <scalaLove> people recommend me to study type and category theory but i think it is irelevant to a programer, agree?
16:47:17 <pastah_rhymez> scalaLove: yeah, you can be a happy hacker without that
16:47:29 <copumpkin> scalaLove: it's not irrelevant, but it's not necessary either
16:47:40 <scalaLove> agree
16:47:59 <Berengal> type theory is fun
16:47:59 <copumpkin> scalaLove: you might gain "deeper understanding" if you follow their recommendation
16:48:04 <pastah_rhymez> scalaLove: though you should learn monads when you've been toying with haskell for a while, in order make stateful programs and whatnot
16:48:30 <scalaLove> yeah of course the basic stuff i assume we all know, i am talking about going deeper into it
16:48:46 <ddarius> Learning monads in Haskell is -not- learning category theory.
16:49:15 <copumpkin> learning enough CT to understand what a monad is in pure CT would be a decent starting point for someone wanting to go a little deeper
16:49:26 <copumpkin> I'd guess
16:49:53 <pastah_rhymez> copumpkin: nowai i'm doing that :p
16:51:19 <copumpkin> :O
16:51:31 <copumpkin> pastah_rhymez: it's not that deep
16:51:43 <ddarius> Learning enough to understand the definition of monad would take about five minutes.
16:51:53 <copumpkin> :)
16:52:16 <copumpkin> ddarius: assuming one didn't go into it with the fear of arcane terminology and assumptions about massive complexity
16:52:30 <Axman6> Saizan: how's this: http://en.wikipedia.org/wiki/Haskell_(programming_language)#Pattern_Matching i've added some examples too
16:52:31 <pastah_rhymez> i have "Basic Category Theory for Computer Scientists" and even though i've given it two gos i've never gotten past page 10
16:52:59 <copumpkin> pastah_rhymez: CT has a bunch of different books and different people seem to understand it better from different sources
16:53:00 <pastah_rhymez> though last time i tried was ~2 years ago, before i was a monad h4xx0r
16:53:09 <copumpkin> pastah_rhymez: when in doubt, try another book, maybe?
16:53:49 <ddarius> I think I looked at "Basic Category Theory for Computer Scientists" and was not particularly impressed.
16:56:05 <augur> azman6: empty is better
16:57:01 <augur> empty :: [a] -> Bool
16:57:01 <augur> empty [] = True
16:57:02 <augur> empty _ = False
16:57:21 <pastah_rhymez> @src null
16:57:21 <lambdabot> null []     = True
16:57:21 <lambdabot> null (_:_)  = False
16:57:29 <augur> well!
16:57:30 <copumpkin> @quote Axman6 getSex :: Person -> Sex
16:57:31 <lambdabot> No quotes match. There are some things that I just don't know.
16:57:32 <toast-opt> ddarius, any you were impressed by?
16:57:38 <copumpkin> @remember Axman6 getSex :: Person -> Sex
16:57:39 <lambdabot> Okay.
16:57:56 <Axman6> augur: yeah, i'll change that
16:58:04 <ddarius> toast-opt: Awodey's book seemed pretty good.
16:58:27 <pastah_rhymez> @faq can haskell get me laid?
16:58:28 <lambdabot> The answer is: Yes! Haskell can do that.
16:58:36 <augur> Azman6: but theres just one person. masturbation?! D:
16:59:02 <toast-opt> ddarius, ouch, $125 on amazon
16:59:09 <copumpkin> toast-opt: lucky for you...
16:59:19 <copumpkin> toast-opt: there's a super secret PDF floating around
16:59:22 <Axman6> fuck i hate wikipedias editing dialogue!
16:59:27 <toast-opt> heh, :P
16:59:28 <copumpkin> only the select few in this channel know about it ;)
17:00:11 <toast-opt> dunno, i think i'll finish 'types and programming languages' and see where i go from there
17:00:12 <ivanm> @where awodey
17:00:13 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
17:00:20 <ivanm> copumpkin: including lambdabot...
17:00:22 * kmc <3 tapl
17:00:32 <pastah_rhymez> why isn't there a 'whenM' and 'unlessM' in Control.Monad?, seing how these are highly useful because 'when'/'unless' are always called from a monadic context
17:00:36 <Axman6> http://en.wikipedia.org/wiki/Haskell_(programming_language)#Pattern_Matching better?
17:00:42 <copumpkin> kmc: I've kind of lost interest in the main volume
17:00:48 <copumpkin> ATTaPL is more interesting now
17:00:52 <Saizan> Axman6: uhm, i don't like the empty lines between clauses of the same function :)
17:00:55 <kmc> i need to read that
17:01:09 <copumpkin> pastah_rhymez: because you haven't submitted a wonderfully reasoned proposal to libraries@ yet :)
17:01:17 <Axman6> Saizan: there shouldn't be any now. blame wikipedias pathetic editing dialogue
17:01:39 <Saizan> Axman6: ok, it looks nice now
17:01:43 <Saizan> :)
17:02:01 <copumpkin> is talking about typeclasses as relations (with automatic lookup) a common way of describing them?
17:02:06 <ivanm> copumpkin: with the initial AT standing for?
17:02:16 <copumpkin> ivanm: advanced topics iirc
17:02:21 <ivanm> ahhh
17:02:21 <pastah_rhymez> copumpkin: well, this is tedious: do { fe <- doesFileExist fp; when fe $ do }
17:02:29 <copumpkin> and I'm too lazy to get up and look at my shelf
17:02:35 <ivanm> heh
17:02:54 <pastah_rhymez> Axman6: didn't you get 'empty' a bit backwards?
17:02:58 <ivanm> pastah_rhymez: doesFileExist >== flip when blah ?
17:03:04 <ddarius> copumpkin: I think of type classes as sets.  Product sets in the multiparameter case which you could view as relations.
17:03:05 <toast-opt> kmc, let me make sure tapl doesn't consume me first
17:03:07 <Axman6> pastah_rhymez: possibly
17:03:09 <kmc> copumpkin, it's how i think about them
17:03:14 <kmc> typeclasses as relations
17:03:21 <pastah_rhymez> ivanm, copumpkin: whenM (doesFileExist fp) $ do lol
17:03:22 <copumpkin> ddarius: I guess relations are just sets too
17:03:27 <kmc> sets of tuples
17:03:31 <ivanm> pastah_rhymez: I find that uglier
17:03:40 <Axman6> > map not [True, False, True, True]
17:03:41 <lambdabot>   [False,True,False,False]
17:03:43 <pastah_rhymez> ivanm: howcome?
17:03:45 <copumpkin> well, regular (non-MPTC) ones are "unary relations"
17:03:53 <pastah_rhymez> @type liftM
17:03:54 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:03:57 <Saizan> Axman6: maybe better something like "We can use some of the above functions, together with map, like this:" otherwise it sounds like you can't use them without map
17:04:01 <pastah_rhymez> @type liftM when
17:04:02 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 Bool -> m1 (m () -> m ())
17:04:12 <ivanm> pastah_rhymez: you _need_ parentheses then!
17:04:24 <Axman6> Saizan: yeah, the actual text i've written isn't great. i'll change that too
17:04:50 <pastah_rhymez> ivanm: true...
17:04:50 <ivanm> Axman6: oh, our argument with Cale about map = fmap, etc.? in RWH dons et. al. say it's _good_ that it's all simpler!
17:05:06 <ddarius> I would prefer map = fmap
17:05:15 <pastah_rhymez> ivanm: ok, but then 'doWhen = flip when' should be introduced
17:05:16 <toast-opt> hmm, AT are fun topics
17:05:27 <copumpkin> toast-opt: indeed!
17:05:29 <Axman6> ivanm: huh?
17:05:36 <toast-opt> heh, proof carrying code.  that one seems to be so hilariously contentious!
17:05:41 <Axman6> Saizan: 'Using the above functions, along with the map function, we can apply them to each element of a list, to see their results:'?
17:05:56 <medfly> > fmap not [True,False,True,True]
17:05:58 <lambdabot>   [False,True,False,False]
17:06:23 <medfly> I am with Cale. it does exactly the same thing and more.
17:06:26 <ivanm> Axman6: bottom of page 443 of RWH; they say it's good that map is only on lists
17:06:32 <copumpkin> toast-opt: it's a lot of fun
17:06:35 <Axman6> i think fmap should be renamed to map
17:06:38 <copumpkin> me too
17:06:46 <ddarius> medfly: map = fmap was how it was originally in Gofer and, I believe, how it was in Haskell 1.4.
17:06:47 * toast-opt went to a presentation on the topic, and the Q&A at the end had 5 people very heatedly debating. the rest bored stiff, and i couldn't even explain it to coworkers in a way they could care about
17:06:57 <Axman6> the f always confused me somehow
17:06:59 <copumpkin> I don't think having beginner-friendly type signatures should be a goal :P
17:06:59 <pastah_rhymez> ivanm: and besides, i don't really like 'flip'. whenever i see it it i always think to myself "how the fuck are they trying to brainfuck me this time?"
17:07:06 <Axman6> ivanm: my problem was with (.) = fmap
17:07:07 <ivanm> ddarius: IIRC, they removed functors from 98 originally to make it simpler
17:07:11 <ivanm> Axman6: right
17:07:38 <medfly> well, Cale is a mathematician.
17:07:53 <ivanm> medfly: as am I...
17:07:54 <copumpkin> I still don't really get why (.) should be fmap
17:08:00 <medfly> he would think that functors are easier to understand.
17:08:01 <ivanm> (well, next year I'll be a computer scientist...)
17:08:06 <Axman6> copumpkin:  me either
17:08:09 <copumpkin> ivanm: damn, downgrade
17:08:09 <medfly> ivanm, when will you be a doctor?
17:08:19 <pastah_rhymez> copumpkin: Monad (->)?
17:08:23 <ivanm> medfly: end of 2012
17:08:33 <ivanm> copumpkin: well, I'll be doing combinatorics stuff, just through CS
17:08:33 <dolio> We'll all be dead by then.
17:08:38 <Axman6> i think it works well, but i do not think it should be in lambdabot
17:08:40 <ivanm> dolio: we'll see...
17:08:45 <copumpkin> pastah_rhymez: yeah, sure, but does that mean we should make all specialized versions the general versions?
17:08:45 <dolio> :)
17:08:57 <dolio> Sun spots!
17:09:06 <copumpkin> palin will be president
17:09:15 <toast-opt> ah
17:09:17 <pastah_rhymez> copumpkin: THAT would be awesome
17:09:19 <medfly> hahahaha
17:09:20 <toast-opt> you scared me
17:09:24 <copumpkin> and will declare nukular war with atheists and socialists within the US
17:09:26 <copumpkin> and bomb us all
17:09:30 <medfly> copumpkin, that explains that 2012 end of the world thing!
17:09:39 <pastah_rhymez> everytime i wake up i'd be like "god DAMN i don't live in that fuckhole"
17:09:47 <toast-opt> didn't nasa already comment on the 2012 thing?
17:09:50 <Niccus> would be a shame to wait all the way to november-ish though
17:09:53 <copumpkin> toast-opt: yeah :P
17:09:59 <medfly> toast-opt, 2012 thing as in palin is president
17:10:01 <pastah_rhymez> *it's nice that i(
17:10:02 <dolio> Do they need to comment?
17:10:05 <Niccus> if there's gonna be an apocalypse on a given year do it early why not
17:10:08 <copumpkin> dolio: sadly
17:10:11 <Niccus> january, february, maybe even march
17:10:30 <copumpkin> trust me on that nukular war thing, I saw it in my crystal ball
17:10:53 <medfly> though to be honest I think there's a more likely cause for concern
17:10:54 <copumpkin> the only case in history when a country accidentally murdered all its citizens by nuclear bombing itself
17:11:15 <toast-opt> oh... earlier, the discussion on human thought, if it was procedural or constraint-solving
17:11:16 <scalaLove> just to share i found this if there is a newbie haskell read this :http://academic.udayton.edu/SaverioPerugini/courses/cps343/lecture_notes/Haskell.html
17:11:17 <medfly> I don't think that can even happen
17:11:45 <toast-opt> ... intuition isn't proceedural.  it's more an obscure constrain violation, that you then have to work out to find the high-level cause for
17:11:49 <dolio> So, anyone have a favorite higher-rank type that they think will trip up my GHC-like checker?
17:12:59 <copumpkin> hmm
17:13:03 <copumpkin> I could make up something random
17:13:15 <copumpkin> :t undefined :: forall a. (forall b. a -> (forall c. b -> c)) -> a
17:13:16 <lambdabot> forall a. (forall b. a -> forall c. b -> c) -> a
17:13:26 <ivanm> copumpkin: did you see the comic about that?
17:13:33 <copumpkin> ivanm: nope?
17:13:33 <ivanm> (palin being president)
17:13:33 <Axman6> copumpkin: you know about the haskell type system right?
17:13:50 <copumpkin> Axman6: for some values of "know"
17:14:03 <Axman6> well, perhaps you could help fill in http://en.wikipedia.org/wiki/Haskell_(programming_language)#Type_system :)
17:14:06 <ivanm> copumpkin: she's actually an android, and in the future the resistance sends back obama to become president instead, thus saving billions of lives (which is why he got the nobel peace prize)
17:14:14 <copumpkin> lol
17:14:32 <dolio> :t (a : *) -> ((b : *) -> a -> (c : *) -> b -> c) -> a ==> *p
17:14:33 <lambdabot> parse error on input `*'
17:14:34 * ddarius wishes billions of lives weren't saved...
17:14:47 <copumpkin> Axman6: that's why I was asking about typeclasses as relations, wanted to see if that was a conventional way of describing them
17:14:48 * Axman6 suggests that everyone spends 5 minutes making the wikipedia article better by adding to it where JaffaCake has left stubs
17:14:49 <Veinor> RON PAUL 2012
17:14:55 <copumpkin> Veinor: ahem
17:15:00 <scalaLove> I still dont understand this: functional languages have higher order functions which means a function can take a function as argument and output a function... could not a similar thing be done in java?
17:15:00 <dolio> And the prenex checker says that's invalid because it's higher-rank (which it is).
17:15:03 <copumpkin> Veinor: get back to angry politweeting
17:15:09 <Axman6> copumpkin: i wouldn't explain them like that personally
17:15:23 <copumpkin> Axman6: how would you?
17:15:24 <ddarius> scalaLove: Java doesn't even have functions...
17:15:24 <Niccus> fuck that ralph nader 2016 who's with me
17:15:28 <Axman6> scalaLove: how do you pass functions in java?
17:15:29 <Veinor> I am ANGRY about POLITICS
17:15:35 <augur> can you simulate an untyped LC by making every function of type a -> b?
17:15:37 <Axman6> copumpkin: well, i
17:15:54 <pastah_rhymez> scalaLove: try this in ghci: 'map (+10) [0..10]'
17:15:55 <copumpkin> dolio: invalid?
17:15:58 <scalaLove> well a function in haskell that sums is equal to a procedure in java that sums
17:16:11 <ddarius> augur: There are no interesting functions of type a -> b so that wouldn't really help.
17:16:20 <Axman6> i'd just say that a typeclass defines an interface of functions that people can use on all types that implement that function
17:16:21 <augur> ddarius: there are in LC! :P
17:16:22 <Veinor> > map (+10) [0..10]
17:16:23 <Niccus> ScalaLove: your link redirects to a wikipedia page on HTTP...?
17:16:23 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20]
17:16:27 <Niccus> or is my computer going crazy
17:16:28 <augur> you just define everything in terms of lambdas!
17:16:31 <dolio> copumpkin: The prenex checker has rules that are supposed to enforce all quantification to be rank-1.
17:16:34 <Axman6> scalaLove: not really. also, how would you pass that to another function?
17:16:36 <ddarius> augur: Those don't have type a -> b
17:16:37 <pastah_rhymez> scalaLove: if there is a way to replicate that behaviour (for ANY function instead of (+10)) then you can say that it has higher order functions
17:16:38 <copumpkin> Axman6: how would you incorporate MPTC into that definition?
17:16:45 <copumpkin> dolio: aha
17:16:49 <dolio> copumpkin: Like Hindley-Milner.
17:16:54 <copumpkin> dolio: do you plan to release that checker by the way?
17:16:55 <ddarius> augur: If they did have types, they'd be similar to U where U = U -> U
17:16:57 <dolio> Only it's a pure type system.
17:17:01 <Veinor> I refuse to use any language without first-class functions. :D
17:17:02 <dolio> It is released.
17:17:11 <copumpkin> oh?
17:17:11 <Axman6> copumpkin: not knowing what MPTC is, i wouldn't :)
17:17:13 <dolio> Well, not on hackage, but you can get it from darcs.
17:17:20 <copumpkin> Axman6: multiparameter typeclasses?
17:17:42 <Axman6> well, i'd put that in its own section
17:17:48 <copumpkin> dolio: oh, http://code.haskell.org/~dolio/pts/ ?
17:17:58 <Axman6> now i'm starting to see how you might use relations though
17:17:59 <augur> hm wait
17:17:59 <dolio> copumpkin: Yes. It has lots of different rule sets.
17:18:04 <copumpkin> I see, cool
17:18:05 <augur> can you even have a type a -> b?
17:18:14 <copumpkin> augur: well, you can't implement it
17:18:17 <Axman6> @hoogle a -> b
17:18:18 <copumpkin> you can write the type down if you want
17:18:18 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:18:18 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:18:18 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:18:26 <augur> hm
17:18:50 <dolio> Most edges of the lambda cube (both predicative and impredicative), an infinite tower, and now a mono/polytype distinguishing system.
17:18:53 <augur> oh now heres a question see
17:19:01 <augur> ia a -> b == a -> c -> d?
17:19:11 <dolio> Er, corners of the lambda cube. Edges aren't type systems.
17:19:13 <Peaker> augur: yeah
17:19:24 * copumpkin downloads to check it out
17:19:27 <augur> hm!
17:19:31 <Peaker> augur: only value is _|_
17:19:31 <augur> so if thats so
17:19:34 <pastah_rhymez> @scr ($!)
17:19:34 <scalaLove> any function can be replicated in imperative language as procedure. Next... A procedure A1 can take as argument the previous procedure A1.ARG, lets call it sum, and provide arguments. The proc A1 will have switch and case structure, based on the argument it will select procedure, if argument is sum, it will select procedure A1.ARG and execute it with arguments provided in A1. So any oop can...
17:19:34 <lambdabot> Maybe you meant: arr rc src
17:19:35 <scalaLove> ...have higher order functions???
17:19:39 <Veinor> undefined has type a -> b :D
17:19:40 <augur> peaker: or other functions a -> b!
17:19:43 <pastah_rhymez> @src ($!)
17:19:44 <lambdabot> f $! x = x `seq` f x
17:19:53 <augur> T x y = x :: a -> b -> a
17:20:09 <copumpkin> omg, using parsec 3!
17:20:13 <copumpkin> I didn't think anyone did that
17:20:15 <augur> F x y = y :: a -> b -> b
17:20:21 <augur> IF = T
17:20:24 <ddarius> copumpkin: Quite a few people use parsec 3
17:20:35 <copumpkin> cool :)
17:20:36 <pastah_rhymez> scalaLove: in c you have higher order functions through pointers to methods
17:20:37 <ivanm> copumpkin: it's one of the packages that splits hackage
17:20:38 <augur> wait is it t
17:20:53 <ddarius> scalaLove: Smalltalk has higher order functions and the Strategy pattern is one way to mimic higher order functions in any OO language.
17:20:59 <pastah_rhymez> scalaLove: but since java is pointer-free you can't do cool hacks like that
17:21:03 <copumpkin> does parsec 3 have that strict monad bug?
17:21:07 <dolio> There are people who don't use parsec 3 for new stuff these days?
17:21:12 <ddarius> copumpkin: It did.  It doesn't now.
17:21:15 <copumpkin> ah
17:21:16 <scalaLove> yes u can read carefully the above
17:21:35 <augur> btw persony person
17:21:36 <ivanm> dolio: those who still use parsec-2
17:21:38 <augur> can i say
17:21:39 <Twey> pastah_rhymez: I don't think that's anything to do with pointers.
17:21:41 <augur> lambda cube is the shit
17:21:42 <ivanm> IIRC, p-2 comes with the platform, not 3
17:21:46 <sohum> is there a way to automatically get the "can duplicate accessor function names via typeclasses" behaviour?
17:21:54 * copumpkin wants a lambda hypercube
17:22:00 <Twey> You can do first-class functions with references, too, like Python does.
17:22:05 <pastah_rhymez> Twey: well, how would you pass a function as an argument in c otherwise?
17:22:05 <toast-opt> hypercube?
17:22:05 <copumpkin> fourth dimension is subtyping! :P
17:22:17 <ddarius> copumpkin: A PTS allows arbitrarily many "axes"
17:22:18 <augur> copumpkin: i wonder whats not even possible on the lambda cube
17:22:20 <Twey> pastah_rhymez: In C the only way is through function pointers, of course
17:23:00 <Twey> But Java's lack of pointers is not a cause of its lack of first-class functions
17:23:21 <ddarius> Twey: You could defunctionalize.
17:23:35 <Twey> (and function pointers in C are rather special as compared to normal pointers, too)
17:23:39 <scalaLove> A1(sum, 1,2) will return 1 + 2 THIS WAY: A1 has switch/case , if sum then it will output a procedure given 1 and 2 as arguments : 1+2
17:24:02 <dolio> copumpkin: The mono/polytype system has *m, []m, *p and []p, for instance.
17:24:24 <kmc> a function pointer isn't much of a first-class function
17:24:32 <Twey> ddarius: I'd never heard of that before.  That's interesting.
17:24:39 <kmc> because you don't have lexical closure
17:24:48 * copumpkin really needs to read up more on pure type systems. I only know the obvious. Reading up on your links to augustsson's post and the overview
17:24:53 <|Jedai|> scalaLove: Your explanation is frankly not understandable, but from what I can guess, you didn't account for the "can take any function of the right type in parameter", your scheme is limited to functions chosen beforehand
17:24:57 <dolio> So you have rules for quite a few combinations of those, which makes significantly more than a cube. (*m,*m,*m) being the trivial one.
17:24:58 <ddarius> Twey: It's not really useful because it is a whole program transformation.
17:25:02 <Twey> kmc: Or any other way to create them on the fly, I suppose
17:25:11 <scalaLove> Jedai yes, it is
17:25:17 <kmc> without closure, the only things you can point to are a fixed set of functions known at compile time
17:25:20 <scalaLove> previosly chosen procedures
17:25:22 <Twey> ddarius: Interesting in a theoretical sort of way, though.
17:25:24 <kmc> which isn't much of a "datatype"
17:25:49 <Twey> It basically describes a compilation from a functional language to one of those other languages the plebs keep going on about.  :þ
17:25:49 <ddarius> Twey: It has applications, quite a few, theoretically and practically.  It's just not useful for this particular scenario.
17:25:54 <EnglishGent> morning all :)
17:25:58 <Twey> Aye.
17:26:09 <Twey> Mornin', EnglishGent
17:26:10 <kmc> the usual solution in C libraries with callbacks is to let the user specify a void* as a free variable
17:26:14 <ddarius> kmc: Given function pointers it's easy enough to explicitly implement closures.  Tedious, but easy.
17:26:15 <kmc> needless to say, that's a hack
17:26:23 <Twey> kmc: Urgh, yes.
17:26:26 <dolio> A type system like Agda's would technically be an infinite dimensional cube, although taking arbitrary other vertices than the one determined by a systematic rule would be weird.
17:26:29 <scalaLove> Jedai, isnt the function previosly chosen also in func languages?
17:26:34 <|Jedai|> scalaLove: So that's not higher-order function, if you discard the "can take any function" aspect it tremendously reduce the interest of this kind of function
17:26:38 <EnglishGent> hi Twey :)
17:26:44 <kmc> scalaLove, structurally
17:26:46 <Twey> My last foray into C ended with me discovering this lovely fact about pthreads.  ;)
17:26:52 <kmc> but not in terms of its free variables
17:27:00 <kmc> and hence in terms of its behavior: output given inputs
17:27:04 <|Jedai|> scalaLove: No, map or others can take any function you feed them without having to rewrite map to take this function into account
17:27:25 <copumpkin> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html seems to be using a rather awkward representation for lambda calculus (the untyped one)
17:27:29 <scalaLove> Jedai can be done in oop too
17:27:37 <scalaLove> let me try explain
17:27:37 <sohum> specifically, I suppose, is http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html implemented?
17:27:52 <kmc> yup, it turns out oop and fp are very complimentary ideas
17:27:53 <dolio> Like, "all Agda types are allowed, except the ones for the rule (Set38, Set95, Set95)".
17:27:53 <|Jedai|> scalaLove: Right, you can with an anonymous class and yadayada
17:28:08 <kmc> though the zealots in both camps will deny it
17:28:31 <scalaLove> i mean when you think about it in C you can do it all
17:28:41 <kmc> in python, every instance method is a partially applied lexical closure
17:29:02 <kmc> and every function is an object
17:29:03 <|Jedai|> scalaLove: The point is, to reproduce this very simple code you have to use extremely heavy syntax and inadapted abstractions, and it's not even as general (In Java)
17:29:06 <Peaker> kmc: partially applied to what?
17:29:15 <kmc> the "self" parameter
17:29:34 <Peaker> kmc: in Python,  blah.method   is what partially applies
17:29:46 <kmc> yeah
17:29:52 <Peaker> kmc: (The method exists unapplied, independently)
17:30:04 <kmc> the attributes of an object include partial applications of its class's function attributes
17:30:29 <|Jedai|> scalaLove: We already said that C has better support for passing functions in parameter than Java (which is a little... weird when you think about it), but it doesn't have lexical closures, which once more make it less convenient than it should be
17:30:31 <scalaLove> so difference between imperative and func style would not be higher order functions... maybe it is speed we talk about, in func higher order funs work well with the rest?
17:30:57 <kmc> the difference in style is very fundamentally how you express yourself
17:31:19 <toast-opt> jedai, but java models functions as classes... and it has anonymous classes
17:31:19 <copumpkin> scalaLove: I'd say the difference is the fundamental underlying model
17:31:24 <Peaker> I see "Functional programming" as simply "denotational programming"
17:31:26 <kmc> "here are things to do in order" versus "here are some definitions"
17:31:32 <copumpkin> scalaLove: an expression-based one vs. a sequential one
17:31:53 <scalaLove> so when you think about it, higher order functions are not characteristic of func languages only correct?
17:31:54 <|Jedai|> scalaLove: higher-order function are functional style, the fact that you can mimic functional programming in mostly imperative language is well known and appreciated by those that are forced to program in those languages while appreciating the functional paradigm more
17:32:02 <Axman6> scalaLove: correct
17:32:22 <ddarius> Almost every modern language, mainstream or otherwise, and most old languages have higher order functions.
17:32:26 <kmc> scalaLove, the use of higher order functions (a FP feature) does not imply canonical FP style
17:32:35 <scalaLove> I understand now thank you :)
17:32:38 <kmc> just as the use of the "class" keyword in C++ does not imply OO style
17:32:50 <Axman6> scalaLove: generally in functional languages, you say what needs to be done, but not how to do it. so, you don't specify the order things are done in
17:33:21 <kmc> we only specify a list of how to do things, when it's one and the same as what needs to be done
17:33:23 <|Jedai|> scalaLove: the functional vs imperative language is mostly a question of emphasis, except in pure functional language like Haskell or Clean
17:33:24 <kmc> like doing IO
17:33:25 <ddarius> Functional languages are still quite a bit less declarative than logic languages.
17:33:43 <copumpkin> yep
17:33:45 <pastah_rhymez> ddarius: are there any other logical languages than prolog?
17:33:53 <copumpkin> haskell!
17:33:54 <kmc> haskell typeclasses :D
17:33:56 <ddarius> pastah_rhymez: There are bunches.
17:34:00 <copumpkin> pastah_rhymez: curry!
17:34:04 <pastah_rhymez> drop em'!
17:34:04 <|Jedai|> pastah_rhymez: curry !
17:34:10 <dolio> Mercury, Oz, Lambda Prolog.
17:34:15 <kmc> there are logic monads in Haskell
17:34:18 <EnglishGent> pastah_rhymez - Mercury
17:34:20 <copumpkin> Oz is everything!
17:34:31 <kmc> there's a logic language implemented in Scheme in SICP, and one in Lisp in _On Lisp_
17:34:33 <EnglishGent> DataLog
17:34:36 <dolio> Lolli.
17:34:38 <kmc> SQL
17:34:40 <ddarius> Goedel
17:34:44 * kmc ducks
17:34:49 * copumpkin mallards
17:34:53 <EnglishGent> lol
17:34:58 <kmc> duck duck type
17:35:09 <pastah_rhymez> copumpkin: complete with tinman and everything?
17:35:17 <copumpkin> pastah_rhymez: yep
17:35:28 <copumpkin> my programming language course used a lot of Oz
17:35:37 <copumpkin> it was interesting but not very pretty
17:35:47 <ddarius> Oz is multiparadigm; Mercury, Curry, and Escher are functional logic languages; LambdaProlog, Lolli, and Goedel are logic languages.
17:36:07 <Berengal> What's Coq and Agda then?
17:36:14 <ddarius> copumpkin: The syntax is kind of nasty, but the language is relatively well put together.
17:36:19 <kmc> dependently typed languages / proof systems
17:36:24 <|Jedai|> Berengal: dependently typed functional languages ?
17:36:25 <ddarius> Berengal: Functional languages. (Dependently typed ones)
17:36:32 <copumpkin> ddarius: yeah, that's more or less how I felt about them
17:36:36 <Berengal> With heavy emphasis on the logic part
17:36:39 <Jafet> "Research languages"
17:36:46 <kmc> they're not logic programming in the sense of backtracking search over relation sets
17:36:52 <|Jedai|> *Berengal: well not really
17:36:54 <Berengal> That's true
17:36:55 <copumpkin> Berengal: logic in a different sense from prolog, then
17:36:57 <kmc> though i imagine there's some of that anyway
17:37:07 <dolio> Twelf is a logic language if you use it for computation, too.
17:37:08 <kmc> narrowing and what-not
17:37:49 <|Jedai|> Berengal: it's just that the Curry-Howard isomorphism map Coq and Agda to more interesting logics (in the mathematical sense) than lesser languages
17:38:31 <Berengal> |Jedai|: There is some unification going on though, but only between values and types, not values and variables
17:38:48 <copumpkin> okay, this PTS stuff makes me want to write my own PTS in agda now
17:38:51 <Berengal> And it's a compile-time thing
17:39:00 <EnglishGent> PTS?
17:39:03 <copumpkin> pure type system
17:39:06 <EnglishGent> ah
17:39:17 <copumpkin> with de-bruijn indices rather than the Sym stuff augustss is using
17:39:34 <EnglishGent> have to confess I dont know what your talking about :|
17:39:40 <copumpkin> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
17:39:42 <|Jedai|> Berengal: Well if you want to go there, it's well known that Haskell's type system with functional dependancies is very close to a logic programming language like Prolog
17:39:53 <EnglishGent> ty :)
17:39:59 <copumpkin> :)
17:40:18 <|Jedai|> Berengal: I still wouldn't call Haskell a logic programming language :)
17:40:23 <sohum> @let type = id
17:40:23 <lambdabot>   Parse error: Equals
17:40:27 <sohum> yea..
17:40:46 <toast-opt> copumpkin - thx, that looks like a useful tutorial
17:40:53 <sohum> that's more than a bit annoying when you actually want to deal with a typed language in haskell
17:40:55 <copumpkin> |Jedai|: I'd call it two languages, a functional strongly typed language and a (mostly) untyped logic language
17:41:17 <toast-opt> a coworker was telling me some anecdotes on dependent typing... sounded like an interesting beast
17:41:20 <netinho2lol> hey guys
17:41:22 <Axman6> hey sohum
17:41:22 <copumpkin> toast-opt: it is!
17:41:27 <sohum> hey Axman6
17:41:30 <EnglishGent> hello netinho2lol
17:41:38 <netinho2lol> I'm having issues with transpose
17:41:38 <Axman6> sohum: have you played with Go at all?
17:41:39 <ddarius> copumpkin: It's typed.  There's just not much to type.
17:41:40 <Berengal> dependent types are awesome and scary at the same time
17:41:45 <netinho2lol> :(
17:41:47 <sohum> Axman6: I haven't, not yet
17:41:49 <copumpkin> ddarius: yeah, but most
17:41:50 <Peaker> toast-opt: in DT, a function's result *type* can depend on its argument's *value*... crazy stuff
17:41:57 <copumpkin> "values" are of the same "type"
17:42:01 <Axman6> righto
17:42:02 <copumpkin> and by value I mean type and by type I mean kind
17:42:05 <toast-opt> peaker - sweet!
17:42:11 <copumpkin> it's also got subtyping!
17:42:15 <|Jedai|> copumpkin: Right, though with type families and new kinds we're trying to get closer to a (mostly) typed functional language at the type level
17:42:22 <Berengal> And types are first-class values... ish
17:42:27 <kmc> (\b -> if b then 3 else "foo")  ::  (\(b :: Bool) -> if b then Int else String)
17:42:29 <toast-opt> peaker - and i imagine a functions argument types can also depend on its return values?
17:42:35 <ddarius> copumpkin: Except you can't say instance Num Double# so that isn't relevant.
17:42:40 <Peaker> toast-opt: and usually, DT languages allow writing code without general recursion -- that is proven to halt or be "productive" when dealing with infinite inputs
17:42:42 <EnglishGent> "Happy Christmas all " ++ cycle "ho "
17:42:57 <copumpkin> ddarius: yeah
17:42:59 <Peaker> toast-opt: No -- the data flow is in one direction there, I think
17:43:06 <kmc> the restriction on termination is there because people want to use dependent types to do logic
17:43:20 <toast-opt> darn.  i was liking haskell's type inference being able to reason about types in both directions
17:43:21 <kmc> and nonterminating terms are logically unsound
17:43:23 <sohum> so what do you guys use when you'd otherwise have a function type :: Variable -> Type
17:43:28 <sohum> ?
17:43:33 <copumpkin> kmc: also because you can put nonterminating computations into types and the typechecker won't terminate
17:43:37 * copumpkin has been bitten by that in agda before
17:43:37 * toast-opt thinks like 'read' :)
17:43:41 <ddarius> kmc: They are sound, they just make the system inconsistent.
17:43:42 <toast-opt> :t read
17:43:43 <lambdabot> forall a. (Read a) => String -> a
17:43:46 <kmc> copumpkin, sure but that's your own damn fault ;)
17:43:48 <netinho2lol> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#transpose
17:43:49 <Peaker> toast-opt: Anyway, in DT languages, type comparison is no longer a syntactic comparison, but rather -- it has to fully evaluate both terms to compare them.. Also, you can encode logical propositions as types, and any value (without general recursion) you make of those types is proof that those propositions are true
17:43:56 <copumpkin> kmc: :)
17:43:57 <Berengal> Cayenne allows general recursion, does it not?
17:44:05 <kmc> agda allows disabling the termination checker
17:44:07 <copumpkin> agda does too
17:44:14 <dolio> Pretty printing de Bruijn terms is a pain.
17:44:16 <Berengal> True
17:44:16 <EnglishGent> yes it does - but there's not gurantee type checking will terminate (Cayenne)
17:44:22 <netinho2lol> ghc in strict mode doesn't like transpose
17:44:24 <knobo> if I repeatedly use a type like [(Integer,[a])], can I some abbreviate it some how?
17:44:32 <copumpkin> dolio: yeah, but it seems more elegant than passing strings representing variables around
17:44:39 <kmc> knobo, yes, "type Foo a = [(Integer,[a])]"
17:44:46 <|Jedai|> netinho2lol: ??
17:44:57 <knobo> kmc: thanks
17:45:00 <netinho2lol> the list comprehensions don't match for []
17:45:12 <|Jedai|> knobo: Did you manage to solve your problem ?
17:45:13 <dolio> I think PHOAS might be nicer than locally nameless, actually.
17:45:30 <|Jedai|> knobo: your tree problem that is
17:45:40 <knobo> |Jedai|: I found out how to do it, but it's not finished. I have the ide in my head
17:45:59 <|Jedai|> knobo: I sent you a solution, did you get it ?
17:46:00 <copumpkin> dolio: is that more easily pretty-printable?
17:46:02 <netinho2lol> Warning: Pattern match(es) are non-exhaustive in a pattern binding in a list comprehension: Patterns not matched: []
17:46:12 <knobo> |Jedai|: nope.
17:46:19 <knobo> Is it in hpaste?
17:46:57 <dolio> copumpkin: The same, I think. But you don't need to write the index-munging functions.
17:47:05 <knobo> yes it is :)
17:47:06 <copumpkin> ah, yeah
17:47:16 * copumpkin has so much to read! so little time!
17:47:45 <Saizan> netinho2lol: well, the warnings is wrong in this case, the fact that the pattern is not exhaustive is the point there
17:47:47 <knobo> |Jedai|: it's different from mine.
17:47:57 <knobo> |Jedai|: what does the $ sign mean?
17:47:59 <ddarius> copumpkin: Just read all of CiteSeer.  Once you finish that, you probably won't have to read much more as far as CS is concerned.
17:48:09 <netinho2lol> Saizan: so it's a bug?
17:48:22 <copumpkin> ddarius: but there's so much more outside of CS! and I want to know all of math too
17:48:26 <copumpkin> :(
17:48:29 <|Jedai|> netinho2lol: that's just a warning, and it's not really important here, in fact in list comprehension it's usual to use non exhaustive patterns to filter some elements
17:48:37 <dolio> copumpkin: And I figured out how to normalize PHOAS terms without converting to some de Bruijn (or similar) representation before thanksgiving, which was my major objection at the time.
17:48:47 <|Jedai|> knobo: ($) is function application
17:49:00 <copumpkin> dolio: oh, is that in your agda repo?
17:49:09 <dolio> I think...
17:49:10 <|Jedai|> knobo: but it's precedence is the lowest possible, so it allows you to shed some parens
17:49:15 <ddarius> copumpkin: If you get a chance, I recommend looking at the book "Bionanotechnology" by David Goodsell.
17:49:22 <netinho2lol> |Jedai|: it isn't a warning when I'm using -werror P
17:49:28 <netinho2lol> :P
17:49:36 <nlogax> @src ($)
17:49:37 <lambdabot> f $ x = f x
17:49:39 <dolio> copumpkin: http://code.haskell.org/~dolio/agda-share/html/PHOASNorm.html
17:49:39 <|Jedai|> knobo: (f . g . h) (n + m) == f . g . h $ n + m
17:49:41 <ddarius> copumpkin: Also, if you are interested in physics, read David Hestenes' site and the sites linked from it.
17:49:50 <toast-opt> @src (.)
17:49:51 <lambdabot> (f . g) x = f (g x)
17:50:02 <copumpkin> ddarius: damn, the reading list just gets longer! but that's a good thing! thanks
17:50:06 <toast-opt> @src (>>=)
17:50:06 <lambdabot> Source not found. Are you on drugs?
17:50:18 <|Jedai|> knobo: could I see you solution ? I'm interested :)
17:50:40 <ddarius> copumpkin: Also for physics (and math for that matter) read E. T. Jaynes' works.
17:50:47 <netinho2lol> the dot is like the composition dot in maths
17:50:48 <copumpkin> with a name like David Goodsell he should be a salesman
17:51:09 <|Jedai|> toast-opt: (>>=) is a method
17:51:16 <|Jedai|> @src Maybe (>>=)
17:51:16 <lambdabot> (Just x) >>= k      = k x
17:51:17 <lambdabot> Nothing  >>= _      = Nothing
17:51:27 <kmc> @src IO (>>=)
17:51:28 <lambdabot> m >>= k     = bindIO m k
17:51:33 <kmc> ;P
17:51:41 <knobo> |Jedai|: when I'm done. The idea is to use three arguments to the buildTree function, and accumulate the subtrees and trees in the second and third argument.
17:52:12 <knobo> |Jedai|: but I like your solution more. But I'll implement mine also. Because I'm doing this to learn.
17:52:20 <copumpkin> ddarius: thanks
17:52:39 <|Jedai|> knobo: Ok, good luck then ^^
17:52:46 <therp> OT: in case anyone from this beloved channel wants some Google Wave invites, /msg therp <your email>
17:52:56 <ddarius> copumpkin: If you do have any books on your reading list about physics, I'd very highly recommend you read Hestenes and Jaynes first.
17:53:13 <Veinor> @src bindIO
17:53:13 <lambdabot> bindIO (IO m) k = IO ( \ s ->
17:53:13 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
17:53:18 <Veinor> deep magic :O
17:53:28 * EnglishGent wonders if therp has a sleigh with reindeer parked on the roof :)
17:53:53 <copumpkin> ddarius: I'm a quarter of the way through the road to reality that you recommended a while ago (for math purposes) but that's the only phsyics book I have right now
17:54:50 <copumpkin> dolio: why Term' ?
17:54:52 <Axman6> @index unIO
17:54:52 <lambdabot> bzzt
17:54:57 <Axman6> >_>
17:55:03 <ddarius> copumpkin: Yeah, I thought I did recommend that to you.  It's a decent read, just don't get too sold on complex numbers or Penrose's philosophizing about QM.
17:55:08 <copumpkin> dolio: oh, I'm stupid
17:55:08 <|Jedai|> Veinor: well it's just a state monad with a #RealWorld# token as state and some primitive to really execute the action
17:55:09 <copumpkin> ignore me
17:55:15 <therp> EnglishGent: well, it's only invites :) I think my girlfriend won't consider that a valid xmas present :)
17:55:27 <dolio> copumpkin: The primary term representation in PHOAS is the universal quantification over Term'.
17:55:28 <fracture> or his platonic philosophy of mathematics
17:55:36 <ddarius> fracture: Yeah...
17:55:56 <fracture> he's also slightly delusional in that book about what he can explain to what level
17:55:59 <fracture> like it cracked me up
17:56:03 <copumpkin> ddarius: yeah, I've been enjoying it so far, but I'll try to stay critical :P
17:56:08 <fracture> he'll be explaining some crap about exterior derivatives
17:56:22 <fracture> and ahve a footnote reminding you what exponentiation notation means
17:56:37 <ddarius> If you are me, you'll violently disagree with Penrose on many aspects, but it is impressive work for a popular book.  None provide as much technical background.
17:56:48 <knobo> |Jedai|: Your solution does not produce exactly what I want. But I can probably modify it so it does.
17:56:58 * fracture agrees with ddarius.... violently.
17:57:03 <copumpkin> fracture: :)
17:57:44 <copumpkin> lol, http://snapplr.com/3h7n
17:57:49 <|Jedai|> knobo: You want a top level function that produce forests ?
17:58:16 <knobo> |Jedai|:  [(0,"a"),(0,"b"),(0,"c"),(0,"d")] should produce [Woim "a" [], Woim "b" [],Woim "c" [], Woim "d"]
17:58:46 <knobo> |Jedai|:  [(0,"a"),(1,"b"),(1,"c"),(1,"d")] should produce [Woim "a" [Woim "b" [],Woim "c" [], Woim "d"]]
17:59:07 <dolio> copumpkin: That normalization function clearly doesn't obey a Scheme-like notion of proper tail recursion.
17:59:10 <|Jedai|> knobo: Right, so you really want forests from your top level function, I thought that was just an artifact of the way you constructed your first function
17:59:12 <copumpkin> yeah
17:59:41 <tibbe> does the UNPACK pragma work on polymorphic components? i.e. data S a = S {-# UNPACK #-} !a
17:59:48 <dolio> tibbe: No.
18:00:06 <tibbe> dolio: people use it in code :/
18:00:10 <copumpkin> tibbe: it'd be nice if it did with a SPECIALIZE prgram
18:00:12 <knobo> |Jedai|: yes. the first function I created was just terribly wrong.
18:00:13 <copumpkin> pragma
18:00:21 <tibbe> copumpkin: yes
18:02:11 <|Jedai|> knobo: You can do that from my solution just by changing the main body of the function
18:02:36 <|Jedai|> knobo: do I say how or do you want to try finding it yourself ?
18:02:48 <copumpkin> dolio: what's the | in your pts syntax?
18:03:30 <dolio> Do I use it somewhere?
18:03:38 <dolio> I don't think pts uses it anywhere.
18:03:48 <copumpkin> it's in upts
18:03:56 <copumpkin> :let U = { i : Level, A : Type[i] | A }
18:04:02 <dolio> In upts it's part of the syntax of dependent sums.
18:04:15 <knobo> |Jedai|: If you want to. Still not 100% clear how everything in your function works.
18:04:33 <dolio> { x : A | T} is Sigma (x : A) T
18:05:06 <dolio> That's how it looks in Coq, although I don't think it lets you do the comma thing.
18:05:07 <copumpkin> aha
18:05:36 <dolio> Technically the | version is for T : Prop, but I like that better than &.
18:05:53 <|Jedai|> knobo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13640#a13668
18:06:54 <sohum> I thought Either a was a monad?
18:07:36 <c_wraith> EIther has the wrong kind to be a monad
18:07:38 <copumpkin> it is, but in the worst possible way
18:07:43 <copumpkin> and in the wrong place
18:07:45 <|Jedai|> sohum: No, "Either String" is a monad
18:07:52 <c_wraith> Either Error is a monad.
18:08:06 <|Jedai|> c_wraith: Right :)
18:08:21 <sohum> hm
18:08:34 <sohum> @hoogle Error
18:08:34 <lambdabot> module Control.Monad.Error
18:08:34 <lambdabot> module Foreign.C.Error
18:08:34 <lambdabot> module Foreign.Marshal.Error
18:08:46 <sohum> @where Error
18:08:47 <lambdabot> I know nothing about error.
18:08:58 <c_wraith> it's the Control.Monad.Error one
18:09:25 <knobo> |Jedai|: since b is a sub-tree of a it should be [Woim "a" [Woim "b" [Woim "c" []], Woim "d" [], Woim "f" []]]
18:11:12 <|Jedai|> knobo : let list = [(0,"a"),(1,"b"),(2,"c"),(1,"d"),(1,"f"),(0,"oops")] in buildTree' list ===> [Woim "a" [Woim "b" [Woim "c" []],Woim "d" [],Woim "f" []],Woim "oops" []]
18:11:34 <|Jedai|> knobo: That's what it does here, that seems to be the behaviour you want ?
18:12:04 <knobo> |Jedai|: yes it is.
18:12:12 <knobo> Time for a break :)
18:12:48 <knobo> |Jedai|: thank you for your help. It's fun :)
18:12:50 <copumpkin> damn it's late
18:12:51 <|Jedai|> knobo: my first line was unecessary by the way, you don't need to handle [] specially in the new function
18:12:57 <c_wraith> sohum: it's important to consider the of a type when you're looking at what it can be an instance of.
18:13:14 <c_wraith> :kind Either
18:13:18 <c_wraith> err.
18:13:21 <c_wraith> @kind Either
18:13:23 <lambdabot> * -> * -> *
18:13:26 <c_wraith> @kind Monad
18:13:28 <lambdabot> Class `Monad' used as a type
18:13:35 <c_wraith> heh.  Fine...
18:13:44 <c_wraith> @kind Maybe
18:13:45 <lambdabot> * -> *
18:13:47 <sohum> c_wraith: yea, which is why I asked if (Either a) was a monad
18:15:30 <c_wraith> You know, there's no reason it couldn't be.  Except for the instance in Control.Monad.Error messing things up.
18:17:16 <c_wraith> it would work out to be the exact same thing as the Exceptional monad from the explicit-exception package
18:22:17 <endojelly> don't know if that's the right channel to ask, but since people here are generally very knowledgable: which languages do actually have real pass-by-reference, besides C++ (with &),
18:22:40 <endojelly> C and Java don't, it's pass-by-value all the way down (even if some of those values happen to be references or pointers)
18:23:16 <endojelly> python doesn't, either, and with Haskell it doesn't even really make sense (or it does, and it's by-value)
18:23:40 <endojelly> actually, no, with Haskell it really doesn't matter, does it?
18:23:50 <p_l> endojelly: define difference between passing a reference and passing a pointer?
18:24:55 <endojelly> p_l, passing a reference just aliases the variable you specified. semantically at least it is not copied or anything. doing anything to it is exactly like doing it to the original variable, for example assignment
18:25:06 <endojelly> it's just a new name
18:26:29 <endojelly> while by-value creates a new variable, which affects at least assignment. this is also what happens in Java or python
18:27:14 <|Jedai|> endojelly: well as you said with Haskell there's no way to see the difference (without using unsafe and arcane guts of your compiler) but I would say it pass by-value (though most of the time it pass pointers anyway, except in the unboxed case where normally the value is one word at most)
18:27:16 <p_l> endojelly: physically you need to store a copy of the reference unless you can do necessary calculations beforehand
18:27:17 <endojelly> p_l, oh, sorry, you were asking about the difference between a reference and a *pointer*?
18:27:35 <endojelly> p_l, C++ illustrates it with &-arguments
18:27:55 <endojelly> p_l, void foo(int &i) { i = 5; }
18:28:18 <endojelly> |Jedai|, yap, that's how I imagined it... it doesn't really matter how the compiler handles it
18:28:35 <endojelly> but really, which language (besides C++, as I said) really does pass-by-reference?
18:28:39 <p_l> endojelly: I don't see big difference between passing a pointer and playing with C++'s references.
18:28:43 <ehamberg> void foo (int *i) { *i = 5; }
18:28:51 <endojelly> p_l, it's just syntax
18:28:56 <c_wraith> endojelly:  some versions of php, using some syntax.  it's horrible.
18:29:02 <mmorrow> endojelly: it's basically just distinction of whether in f(a), the value of a is copied and a ptr to the copy is passed, or whether a ptr to the original is passed (from the pov of the lowest common denominator)
18:29:20 <endojelly> mmorrow, yes, I know
18:29:30 <p_l> endojelly: it's basically a manner of syntax, not changing anything... and frankly speaking, it doesn't mean anything
18:29:55 <endojelly> p_l, with pointers, you still have a pointer which is passed as a value. you can change that pointer without changing what it points to. that's by value.
18:29:57 <c_wraith> (other versions of php use that same syntax to mean something entirely else)
18:30:05 <endojelly> but my question is really just which language has pass-by-reference 8)
18:30:09 <|Jedai|> wasn't there some subtlety with const and passage by reference ?
18:30:10 <mmorrow> endojelly: so i don't understand your question then, C++ passes by value
18:30:13 <endojelly> c_wraith, oh boy?
18:30:28 <endojelly> mmorrow, it passes by reference with &
18:30:38 <endojelly> and the compiler can use that for aliasing
18:30:43 <dolio> How do you know it doesn't pass a reference by value? :)
18:31:02 <dolio> And all the syntax for using a reference looks the same as for a value.
18:31:03 <endojelly> dolio, it can, if it manages to keep the semantics 8) (which it could)
18:31:07 <p_l> If you pass by value in C, you use stack/registers with relatively fixed positions. With pointers, you pass reference to a memory location (unless you pass a static variable and the compiler/linker can link the address directly)
18:31:11 <|Jedai|> p_l: beside I guess that semantically the passage by reference is clearer on the fact that the value is what will be manipulated (or not), not the pointer itself
18:31:21 <endojelly> but it could also do something different: for example, if a global variable is passed, it could really and truly alias it
18:31:23 <p_l> with reference, you pass the pointer and call it a new name ;-)
18:31:27 <mmorrow> endojelly: fortran is pass-by-reference
18:31:36 <endojelly> by creating a version of the function which accesses the global variable directly
18:31:49 <mmorrow> endojelly: or "pass-by-value-result" (you get the choice per arg)
18:31:55 <endojelly> mmorrow, ah, ok
18:32:14 <mmorrow> endojelly: C and C++ achieve pass-by-reference by a technicality (ptrs)
18:32:41 <endojelly> p_l, see what I just wrote (aber truly aliasing it)
18:32:58 <dolio> I don't really see the difference between Java's passing references by value and C++'s genuine pass by reference.
18:33:02 <p_l> endojelly: iirc, the pass-by-reference as you explain it, works only for variables that have static positions or where you dynamically compile the code or do partial application (where the topic becomes moot)
18:33:24 <endojelly> mmorrow, but with int &i true by-reference semantics are introduces which could be implemented differently by the compiler rather than pretending it's a pointer which is always automatically dereferenced
18:33:25 <p_l> but I'm not a compiler hacker, so...
18:33:37 <endojelly> p_l, yes, I know
18:33:45 <endojelly> my question really just was:
18:33:47 <endojelly> which languages do 8)
18:33:50 <mmorrow> endojelly: yeah, you have a point about C++'s & giving additional alias info
18:34:29 <mmorrow> endojelly: so i suppose it's passing-a-ptr+syntactic-sugar+alias-info-annotation
18:34:38 <endojelly> mmorrow, something like that, yes
18:34:43 <endojelly> it's really not that much of a deal
18:34:51 <mmorrow> endojelly: what's not?
18:34:54 <endojelly> the only reason I ask is because those two terms are well-known
18:35:12 <endojelly> yet almost all languages that come into my mind are completely or mostly by-value
18:35:40 <dolio> I don't think most people would categorize Java as pass-by-value as you do (except for primitives).
18:35:51 <dolio> Hence by-reference being a common term.
18:35:58 <endojelly> mmorrow, the difference between by-value and by-reference. it's often like you said it: passing a reference, syntactic changes and aliasing stuff
18:36:19 <mmorrow> endojelly: any language that allows you to mutate things would be handing you an exploding chainsaw if it was pass-by-ref by default
18:37:05 <endojelly> dolio, a quick google search leads to a lot of sites that want to clarify that java is *not* by reference, but passes references by value
18:37:17 <mmorrow> well, at best, it'd just be an inconvenience having to copy your local int every time you call some function that might ++ it
18:37:27 <endojelly> mmorrow, oh yes. it's like basic on the C64
18:37:31 <mmorrow> :o
18:37:32 <|Jedai|> mmorrow: like Java right ?
18:37:36 <endojelly> where you don't even have procedures
18:37:41 <endojelly> and are forced to use variable names instead
18:37:46 <endojelly> that, basically, is by-reference 8)
18:37:56 <mmorrow> |Jedai|: :o Java passes ints by reference?
18:38:00 <dolio> Are those sites teaching Java to C++ people or something?
18:38:10 <p_l> endojelly: well, I guess that in certain cases, a SSC for Lisp would do aliasing like that... I'm not sure how to ensure apriopriate case for CL without SSC
18:38:10 <|Jedai|> mmorrow: ok, not int
18:38:26 <mmorrow> |Jedai|: phew
18:38:28 <dolio> I suppose there is a difference.
18:38:29 <endojelly> dolio, http://www.javaworld.com/javaworld/javaqa/2000-05/03-qa-0526-pass.html
18:38:35 <p_l> endojelly: and as for Haskell, you've got partial application etc.
18:39:16 <endojelly> p_l, can I say that since you can't modify values in Haskell, no matter what, it doesn't matter anyway?
18:39:24 <dolio> If I do 'void foo(obj & i) { i = new Foo; }, and 'void bar() { obj i = whatever; foo(i) }, does i get changed?
18:39:33 <dolio> I guess that's different than Java.
18:39:47 <endojelly> dolio, yes! that's the point. C++ has real pass-by-reference semantics
18:40:00 <|Jedai|> mmorrow: but I do believe it pass Integer by reference
18:40:09 <mmorrow> ohh. right, i forgot that the by-ref annotation is in the *param list* in C++
18:40:10 <endojelly> dolio, it's also different than passing pointers by value, which C already had, which is basically what Java does for all objects.
18:40:34 * mmorrow hasn't coded in C++ in a long time
18:40:57 <chrisdone> c++'s references just mean function parameters are initialised as the actual variables and not pointers, so you don't have to bother with dereferencing
18:41:06 <endojelly> mmorrow, you can also use it for local variables which must immediately be initialized to the variable you'd like to alias: int &i = j;
18:41:14 <p_l> dolio: ... how is it different, in actual implementation, from syntax sugar for pointers?
18:41:22 <mmorrow> endojelly: ahh
18:41:30 <dolio> p_l: It isn't.
18:41:32 <endojelly> the reference can't ever be changed, of course. it's real aliasing, just a new name, and especially in the local variable case the compiler hopefully handles it as such
18:41:38 <|Jedai|> endojelly: Well yes, but for Java it's implicit and you can't really touch the pointer so I would argue that Jave is at least semantically mostly pass-by-reference
18:41:42 <endojelly> instead of creating a perpetually dereferenced pointer 8)
18:42:04 <p_l> dolio: ... then I don't see wtf is the argument about, I could claim that any SSC for any higher level language might do it
18:42:26 <p_l> (SSC = Sufficiently Smart Compiler, the mythical beast that slaughtered Itanium by simply not being therer)
18:42:29 <p_l> *there
18:42:36 <endojelly> |Jedai|, so than that's a problem of terminology.
18:42:54 <endojelly> |Jedai|, I really don't know if there is a 100%-clear fully accepted definition.
18:42:55 <mmorrow> endojelly: ok, so & in C++ really does add additional semantics beyond syntactic-sugar+aliasing-info
18:43:07 <endojelly> mmorrow, yes
18:43:31 <Berengal> All this reference and pointer stuff is confusing me. How does anyone program in such languages?
18:43:44 <chrisdone> Berengal: with much confusion, typically
18:43:48 <endojelly> mmorrow, also you could implement it by just treating it as syntactic sugar for creating a pointer and perpetually dereferencing it, but that "would be bad".
18:44:07 <p_l> endojelly: you could say that CL's "special" variables are passed by reference... except the actual mechanics are different (because you still have to dereference, unless you play interesting things with stacks etc.)
18:44:29 <chrisdone> I never understood CL's "identity"
18:44:29 <|Jedai|> Berengal: it's hard... I can't believe that there are C++ programmers that think Haskell is too hard for them... :(
18:44:51 <endojelly> p_l, interesting, what are "special" variables? I don't know much about lisp, except what I know from writing my .emacs.el in elisp, which I heard is a particularly nasty dialect of lisp 8)
18:45:17 <Berengal> |Jedai|: Indeed. Haskell is a much simpler language than C++... Even Java or Python are more complex
18:45:22 <Peaker> |Jedai|: C++ can be learned incrementally from a basis of knowledge in C.  Haskell requires a sharper turn
18:45:46 <endojelly> |Jedai|, I'm not sure that those have fully grasped C++, there are probably a lot of caveats in their language for them
18:45:50 <chrisdone> any new paradigm requires a sharp turn
18:45:57 <Berengal> The hard parts of Haskell aren't in the language, but what people do with it.
18:46:16 <p_l> endojelly: in Common Lisp, you have lexical scope and dynamic scope. When you pass arguments to a function, they are passed as lexical variables, to be thrown away (unless you return their values) - their names have no real meaning outside compilation phase
18:46:24 <Peaker> Monads for I/O are always a tough point
18:46:28 <mjrosenb> why on earth is data-aviary in hackage?
18:46:33 <|Jedai|> endojelly: I'm not sure there's a lot of people that really have fully grasped C++... The language is just too big and irregular for that
18:46:47 <endojelly> p_l, you have both? that's interesting
18:46:54 <endojelly> |Jedai|, I agree
18:46:57 <p_l> endojelly: dynamic scope variables, "specials", are always dereferenced with regards to current environment
18:47:13 <endojelly> |Jedai|, and apparently there aren't even any compilers that have a full grasp of the language 8)
18:47:18 <Peaker> |Jedai|: I remember thinking that when I was doing C++.  Now that its a distant memory, its hard for me to remember/re-realize where the bigness was :)
18:47:23 <chrisdone> scheme supports dynamic scope variables, too
18:47:39 <Baughn> |Jedai|: I recently had the occasion to learn how copy constructors work. My program, which had until then worked fine, promptly broke once I realized it should never have worked.
18:47:47 <Baughn> And why does that happen, anyway? It seems impossible.
18:47:57 <Peaker> Baughn: Its called a Heisenbug
18:47:57 <endojelly> Peaker, |Jedai|, there's a C++ "FQA" which illustrates some of the more impossible problems with C++ if you're bored.
18:48:01 <Baughn> Peaker: I know.
18:48:02 <mmorrow> endojelly: although, struct a{int a;}; struct a x = {42}; struct a &y = x; y.a = 43; x.a == ? (43?)
18:48:19 <p_l> endojelly: so you can have (defun foo () (print *x*)) (let ((x 1)) (foo)) (let ((x 2)) (foo)) and it will return apriopriately, 1 2. With lexical variable, foo would return what was the value of x at the moment of compilation (unless it was defined as argument)
18:48:27 <mmorrow> endojelly: so maybe it really is just syntactic sugar and aliasing info
18:48:27 <endojelly> Baughn, that's what you call a schroedinbug
18:48:36 <Berengal> Peaker: Technically it's a Schrödingbug. It's either a bug or not until you look.
18:49:01 <Baughn> endojelly: But seriously, why did it happen? I didn't even recompile, I was just inspecting the source.
18:49:04 * Baughn grumbles.
18:49:04 <EnglishGent> mjb - guessing from the name - bird combinators? (to mock a mockingbird)
18:49:10 <mmorrow> endojelly: i.e., just doing s/y/x/ everywhere would be essentially the same thing?
18:49:17 <chrisdone> Baughn: a wizard did it
18:49:21 <Peaker> In Haskell, dynamic scoping isn't really very useful -- explicit reader monad is nicer
18:49:25 <toast-opt> berengal - no, it's definitely a bug right?  just that you might not observe it in that state
18:49:28 <p_l> Baughn: a Witch did it
18:49:37 <Baughn> p_l: Haruhi did it
18:49:42 <endojelly> mmorrow, yes, true aliasing! gets slightly more interesting with function parameters, though.
18:49:56 <endojelly> mmorrow, but not much.
18:50:02 <p_l> Baughn: argh, foiled! But you shall meet us in the golden land
18:50:06 <mmorrow> endojelly: yeah
18:50:15 <endojelly> mmorrow, I guess it's handy when passing instances
18:50:27 <mmorrow> endojelly: ah, hmm
18:50:28 <endojelly> const &Foo is an idiom you often see
18:50:58 <endojelly> when you don't want to modify it anyway, but you don't want to copy it and you don't need the pointer
18:51:09 <endojelly> plus it's a safeguard
18:51:10 <Berengal> toast-opt: heisenbugs are bugs, but you can't observe what it does and what causes it at the same time. scrödingbugs are pieces of code that don't behave like a bug until you look at the source to discover it never should've worked.
18:51:24 <toast-opt> ah, fair
18:51:37 <endojelly> Berengal, exactly
18:51:52 <endojelly> I encounter far more Heisenbugs than Schrödingbugs
18:52:08 <endojelly> Heisenbugs are those that stop being bugs in the debugger
18:52:18 <endojelly> or, very common, when doing strace on linux
18:52:45 * p_l recalls his last try of running strace on SBCL....
18:52:51 <endojelly> sometimes because it's a race condition and your debugging tool slightly changes the timing
18:52:58 <Berengal> I encounter erroneous requirements most of all...
18:52:59 <endojelly> p_l, SBCL?
18:53:13 <therp> endojelly: common lisp environment
18:53:18 <chrisdone> endojelly: CL's eqiuv. to GHC
18:53:22 <endojelly> ah, thanks
18:53:33 <p_l> endojelly: Steel Bank Common Lisp, one of the best open-source CL implementations out there.... I have been trying to find an error that was later found to be a systemwide thing
18:53:38 <endojelly> p_l, wouldn't imagine seeing a lot besides lots of IO on files
18:53:56 * p_l still doesn't know how the hell his X11 apps can find the socket when it doesn't exist
18:54:02 <endojelly> p_l, oh, nice... could you fix it?
18:54:39 <p_l> endojelly: no, I lost the file containing X11 socket (srsly), and strace showed that it doesn't like SBCL and vice-versa :>
18:55:09 <endojelly> p_l, why did it need the X socket in the first place? %)
18:55:17 <sohum> > let f [a,b] = a in f [1,2]
18:55:18 <p_l> since I filtered everything except network calls, I haven't seen much except for SIGSEGV messages and memory corruption warnings
18:55:19 <lambdabot>   1
18:55:24 <sohum> > let f [a:b] = a in f [1,2]
18:55:25 <lambdabot>   No instance for (GHC.Num.Num [t])
18:55:25 <lambdabot>    arising from the literal `1' at <inter...
18:55:30 <endojelly> brb
18:55:30 <sohum> riiiight
18:55:31 <Baughn> p_l: You should strace a ghc program sometime. It's.. interesting.
18:55:33 <p_l> endojelly: to connect to X server
18:56:10 <p_l> Baughn: Right... Maybe when I'll get a need for something lovecraftian, judging from your usage of "interesting"
18:56:13 <sohum> > let f [a,b,c]:ds = ds in f [1,2,3,4]
18:56:15 <lambdabot>   <no location info>: Parse error in pattern
18:56:26 <sohum> > let f (a:b:c:ds) = ds in f [1,2,3,4]
18:56:27 <lambdabot>   [4]
18:56:43 <Baughn> > let f ([a,b,c]:ds) = ds in f [1..4]
18:56:44 <lambdabot>   No instance for (GHC.Enum.Enum [t])
18:56:44 <lambdabot>    arising from the arithmetic sequence...
18:56:51 <Baughn> ..oh. Right.
18:57:08 <p_l> I strongly suspect my SBCL fiasco might be related to the fact that internal ABI was quite different from "normal"
18:57:14 <Baughn> ..it would be nice if pattern matches accepted string syntax
18:58:27 <dolio> > let f "gorgonzola" = "blue" ; f _ = "green" in f "cheddar"
18:58:28 <lambdabot>   "green"
18:58:52 <Berengal> Baughn: You can sort-of hack it with view patterns...
18:59:39 <Baughn> Berengal: ((== "foo") -> True), right?
18:59:47 <Berengal> Baughn: Also, it does work...
18:59:55 <Baughn> It does?
18:59:57 <Berengal> String syntax that is
19:00:05 <Berengal> Just tested
19:00:05 <Baughn> I'm quite certain I wrote a program a while back that suffered for lack of it
19:00:27 <Baughn> Oh, wait..
19:00:31 <Berengal> > let f "foo" = "bar" in f "foo"
19:00:32 <lambdabot>   "bar"
19:00:40 <Baughn> Berengal: I wanted to type '"foo" ++ rest' as a pattern
19:00:47 <Berengal> Oh, like that
19:01:01 <Berengal> Yeah, stripPrefix + view patterns = <3
19:01:33 <Baughn> Now we just need to wait for 6.12 to officially be released, so others can use my programs. :P
19:01:42 <Baughn> They produce entirely too many warnings on 6.10
19:01:49 <Berengal> I've used that as a cheap parsing tool for a few things
19:02:02 <Baughn> instance Read
19:04:57 <sohum> @hoogle [Either a b] -> [b]
19:04:58 <lambdabot> Data.Either rights :: [Either a b] -> [b]
19:04:58 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
19:04:58 <lambdabot> Data.Graph.Inductive.Graph nodes :: Graph gr => gr a b -> [Node]
19:05:37 <sohum> @hoogle [m b] -> [b]
19:05:38 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
19:05:38 <lambdabot> Data.Graph flattenSCCs :: [SCC a] -> [a]
19:05:38 <lambdabot> Data.Graph.Inductive.Basic postorderF :: [Tree a] -> [a]
19:07:19 <sohum> :t map
19:07:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:07:36 <sohum> @hoogle (a -> m b) -> [a] -> [b]
19:07:37 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
19:07:37 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
19:07:37 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
19:09:02 <sohum> @hoogle (a -> m b) -> [a] -> m [b]
19:09:03 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:09:03 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:09:03 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
19:09:17 <sohum> ah, right
19:09:42 <toast-opt> curious question: what determines if 'deriving' or 'implements' should be used?
19:10:11 <toast-opt> sorry, 'deriving' vs 'instance'
19:10:30 <sohum> @pl x >>= \x -> return x
19:10:31 <lambdabot> x
19:10:35 <sohum> wait, not that
19:10:48 <Veinor> toast-opt: I think 'deriving' means 'guess what I want'
19:11:16 <Veinor> for example if I have a type T Int and I just use deriving (Show)
19:11:20 <eivuokko> toast-opt, sometimes deriving produces results you don't want (as they generall use lexicographical ordering of ctors.)  Sometimes it's not possible to automatically derive instances.  And only certain standard instances can be automatically derived.
19:11:25 <Veinor> it will show a T as, say, T 485
19:11:37 <toast-opt> veinor, is it only for some built-in type classes?
19:11:41 <Veinor> yeah.
19:11:51 <Veinor> I don't think you can deriving Num, for example
19:11:57 <toast-opt> ok, so i can't generally write my own Show?
19:12:05 <Veinor> you can write your own show if you want, using instance
19:12:24 <toast-opt> i mean, can i write a MyShow typeclass that other things could 'deriving'?
19:12:30 <Veinor> ahhhhh
19:12:34 <Veinor> I'm not sure about that actually
19:12:50 <toast-opt> if it's only for certain 'blessed' classes, that makes sense
19:12:58 <eivuokko> toast-opt, Nope, but you could try using preprocessor to do that for you, there's couple.
19:13:03 <Berengal> You can't, but you can use TH to fake it
19:13:09 <toast-opt> TH?
19:13:13 <Berengal> template-haskell
19:13:17 <toast-opt> ah
19:13:47 <Veinor> if I say data Foo a = Bar a | Baz a, can I deriving (Ord)?
19:13:55 <toast-opt> that makes sense.  'instance' is plent good for everything i need.  just wanted to make sure i was understanding right around deriving
19:14:22 <eivuokko> Veinor, for (Ord a) => Ord (Foo a), yes.
19:14:38 <eivuokko> Or rather, that's what it produces.
19:14:41 <Veinor> how will it compare Bar 8 and Baz 6 then?
19:14:51 <Berengal> toast-opt: Also nice to know is the "instance deriving" declaration, which gives you the default instance for a datatype outside of its declaration
19:14:55 <toast-opt> oh, can i have conflicting 'instance' definitions?  like, can i 'instance Num Int' myself with an alternate definition for use in some scope?
19:15:15 <eivuokko> Veinor, it first compares ctors in lexicographical order (the order you wrote them down in yoru source) then parameters left to right.
19:15:17 <toast-opt> i know i can wrap it with a type, but just thought i'd ask
19:15:27 <eivuokko> Veinor, this is specific in haskell 98 report.
19:15:51 <Berengal> toast-opt: You definitely can't use them. It might be legal for two definitions to exist at the same time as long as none of them are used.
19:15:57 <eivuokko> toast-opt, Not really, instances are for most practical purposes global.  (although how they are seen, they are not)
19:16:11 <toast-opt> ok
19:16:13 <toast-opt> thx
19:16:24 <Veinor> ah, so Bar x < Baz y for all x, y
19:16:33 <eivuokko> Yes.
19:16:40 <toast-opt> i saw a slide deck explaining type classes as working as hidden parameters; seems like that might support multiple instances
19:16:57 <Berengal> toast-opt: If they weren't hidden, that'd be true
19:17:28 <toast-opt> berengal, well, thinking something like different scopes.  like function names.  Data.Seq has some things conflicting with Data.List, for instance
19:17:30 <Berengal> Agda does something similar with explicit record passing
19:18:44 <Berengal> toast-opt: That's just giving things different names. The names in Data.List don't conflict with those in Data.Seq because they live in different modules. You can get some ambiguity when using their short forms, but that can always be resolved
19:19:27 <sohum> :t mapM
19:19:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:19:34 <sohum> :t (<$>) map
19:19:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f ([a] -> [b])
19:19:42 <endojelly> what does "non-negative type" mean?
19:19:45 <toast-opt> Berengal - but conceivably, in a different language, i could say through different imports which mapping of Int to Num that i wanted to have visible when i say '+'
19:20:08 <sohum> liftM /= <$>, then. hrm.
19:20:13 <Berengal> toast-opt: you could get that with parameterized modules, yes.
19:20:30 <toast-opt> ah, it already has a name?
19:20:34 <toast-opt> thx
19:21:14 <Berengal> toast-opt: You lose the ability for the compiler to automatically thread instances around at compile/runtime though
19:22:00 <eivuokko> And possible the overlapping-checks, which are nice feature as well.
19:22:02 <toast-opt> yeah, i'll have to think about that more.  not sure i understand enough about typeclasses yet to understand how that threading works.
19:22:06 <toast-opt> thx for the help :)
19:22:28 <toast-opt> it's now 3 am's too many >_<
19:25:06 <scalaLove> in what way does haskell inherited rule-based programming from PROLOG?
19:26:12 <scalaLove> "the language pH is a parallel dialect of Haskell" - can you give me top 3 why should i go into pH?
19:26:22 <Berengal> I guess pattern matching sort of fits that description...
19:27:34 <scalaLove> i see
19:27:34 <|Jedai|> scalaLove: pH is integrated into GHC now, I think it's what became Control.Parallel.Strategies
19:28:27 <scalaLove> can we say then that haskell is a purelu functional language with logic premises?
19:28:41 <eivuokko> scalaLove, normally you wouldn't call haskell logic/rule programming at core, as in haskell you provide the structure for the execution, as well as the constraints.  In logic/rule programming you usually trust that to the implementor of language/runtime.
19:28:49 <|Jedai|> scalaLove: Not really, it's a purely functional language
19:28:55 <scalaLove> |Jedai| you would recommend me going into pH for some particular reason?
19:29:16 <|Jedai|> scalaLove: You can easily use a backtracking monad to do basic logic programming elegantly though
19:29:18 <sohum> :t const . const
19:29:19 <lambdabot> forall b a b1. a -> b -> b1 -> a
19:29:31 <sohum> @hoogle a -> b -> b
19:29:32 <lambdabot> Prelude seq :: a -> b -> b
19:29:32 <lambdabot> Control.Parallel par :: a -> b -> b
19:29:32 <lambdabot> Control.Parallel pseq :: a -> b -> b
19:29:44 <sohum> @hoogle a -> b -> c -> c
19:29:45 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
19:29:45 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
19:29:45 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
19:29:54 <sohum> poo
19:30:24 <|Jedai|> scalaLove: It's a pretty lighweight and cheap way to add parallelism to an existing pure code (of course it won't magically make a sequential algorithm parallel but functional style already encourage parallelisable algorithms)
19:30:52 <scalaLove> so why does it say it encorporates imperative syntax, what does that mean?
19:31:27 <scalaLove> a useful general-purpose programming language, it incorporates
19:31:29 <scalaLove>     * functional features from LISP,
19:31:31 <scalaLove>     * rule-based programming from PROLOG,
19:31:32 <scalaLove>     * imperative syntax, and
19:31:34 <scalaLove>     * data abstraction from Smalltalk
19:31:42 <YuleAthas> It probably means do-notation.
19:31:51 <eivuokko> scalaLove, mainly the do-notation (which is just syntactic sugar), possibly referring to standardised IO-monad as well.
19:31:53 <YuleAthas> That can look a lot like traditional imperative languages.
19:31:56 <eivuokko> scalaLove, Where is that from?
19:32:06 <scalaLove> http://academic.udayton.edu/SaverioPerugini/courses/cps343/lecture_notes/Haskell.html
19:32:10 <YuleAthas> But... "data abstraction from Smalltalk"?  That's a stretch.
19:32:20 <YuleAthas> Also, Prolog?  What the...
19:32:21 <|Jedai|> scalaLove: where did you read that, I wouldn't call that very accurate
19:32:27 <eivuokko> scalaLove, Looks like a bit overeager PR :-P
19:32:27 <YuleAthas> Right, that's rubbish.
19:32:45 <scalaLove> the above link is bullshit? :(
19:32:59 <|Jedai|> eivuokko: Not even really convincing to me... A mix of all of that would be a strange beast indeed
19:33:20 <YuleAthas> scalaLove: that part is quite similar to bovine manure, yes.
19:33:21 <sohum> @hoogle liftM
19:33:22 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
19:33:22 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:33:22 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
19:33:32 <|Jedai|> scalaLove: Maybe the Haskell course itself is good (I don't know) but the description is quite strange...
19:33:52 <sohum> what's the other thing that's equivalent to liftM ?
19:33:53 <eivuokko> I think the author means the things that can be done at library level in haskell.
19:33:59 <scalaLove> it is ridicilious to even mention imperative, i still cant get it imperative syntax wtf
19:34:03 <YuleAthas> scalaLove: it also mentions String as a "primitive type" (what does that mean?), which is certainly wrong.
19:34:07 <eivuokko> Which, of course, is a lot.
19:34:10 <YuleAthas> A Haskell String is just a list of characters.
19:34:25 <scalaLove> ok i will stop reading this shit
19:34:35 <sohum> @hoogle (a1 -> r) -> m a1 -> m r
19:34:36 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
19:34:37 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
19:34:37 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
19:34:46 <sohum> <$>? really?
19:34:58 <ray> :t fmap
19:34:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:35:05 <ray> same function
19:35:11 <|Jedai|> scalaLove: the rest of the page seems more sensed
19:35:12 <sohum> hmm.
19:35:17 <ray> just infix
19:35:44 <ray> some radical fringe elements will tell you that it should be called (.)
19:35:46 <sohum> :t liftM map
19:35:48 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m ([a] -> [b])
19:36:00 <|Jedai|> scalaLove: do-notation can looks like imperative syntax when used with the IO monad
19:36:16 <sohum> :t mapM
19:36:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:36:24 <YuleAthas> |Jedai|: what about stuff like "Haskell prints the arguments to a function which takes >1 argument as a tuple"?
19:36:24 <sohum> ...wait
19:36:34 <sohum> why is mapM != liftM map ?
19:36:48 <sohum> @src mapM
19:36:49 <lambdabot> mapM f as = sequence (map f as)
19:37:04 <sohum> :t liftM2 map
19:37:06 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m [a] -> m [b]
19:37:29 <scalaLove> this div 7 2 = 7 `div` 2  gives me error
19:37:40 <|Jedai|> YuleAthas: didn't see that... but anyway that looks a lot more like notes for the teacher than for the students
19:37:58 <sohum> :t sequence
19:37:58 <Botje> scalaLove: that looks like you're defining an infinite loop.
19:37:58 <Berengal> > 7 `div` 2
19:37:59 <lambdabot>   3
19:37:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:38:05 <|Jedai|> scalaLove: this is not a declaration, it's saying that both syntax are equivalent
19:38:16 <|Jedai|> > div 7 2
19:38:17 <lambdabot>   3
19:38:21 <c_wraith> sohum: mapM is used for mapping a function that returns a monad to a list of arguments, and then putting the result list into that monad.
19:38:48 <sohum> c_wraith: right. I thought the functionM's were == liftM function.
19:39:51 <sohum> c_wraith: is there such an f such that functionM == f function ?
19:40:31 <|Jedai|> sohum: No, if there was most of the *M variant would probably never have made their way in the standard library
19:40:31 <scalaLove> i am suposed to learn like at least 100 languages in 2010, you guys have books to recomend me for in general ways to learn languages?
19:40:32 <c_wraith> sohum: not that I'm aware of.  Most of them do something the equivalent of sequence
19:41:16 <sohum> |Jedai|: I refer you to ++ vs. mappend ;)
19:41:22 <Berengal> scalaLove: Just learn as many paradigms as possible. Learning a new language is a matter of syntax after that.
19:41:23 <sohum> c_wraith, |Jedai|: thanks
19:42:00 <scalaLove> Berengal: yeah i have read books on all paradimgs and used Scheme and Prolog, what u said is most important thing yes
19:42:02 <|Jedai|> sohum: that's one of the objection to monads by the way, the fact that you have to rewrite a function to make it monadic (liftM f just apply f in the monad, it doesn't make it monadic
19:42:07 <scalaLove> it is the topmost view
19:42:24 <sohum> |Jedai|: do arrows solve this?
19:42:34 <Berengal> sohum: arrows have arr
19:42:36 <Berengal> @type arr
19:42:37 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
19:42:47 <eivuokko> scalaLove, What is your actual goal?
19:43:01 <sohum> @pl \f g as -> sequence (f g as)
19:43:02 <lambdabot> ((sequence .) .)
19:43:27 <sohum> @hoogle sequence
19:43:28 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:43:28 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
19:43:28 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
19:43:30 <scalaLove> other i would say: lists-immutable, arrays-mutable or immutable, tuples-mutable or immutable allow heterogeneous
19:43:35 <sohum> :t arr map
19:43:37 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a -> b) ([a] -> [b])
19:43:59 <|Jedai|> sohum: I don't think so, they have different goals, sometimes Arrows are more suited than Monads, but Arrows won't replace Monads for most current usages
19:44:05 <scalaLove> u know lot of general rules overlap like the above
19:44:53 <scalaLove> well the goal is, i want to start implementation of my own language/compiler in 2011 and 2010 will be researching lot of languages and see what i want, i want it multiparadigmed
19:45:15 <|Jedai|> scalaLove: You tried Oz then, didn't you ?
19:45:42 <c_wraith> scalaLove:  there's a lot more than that, though.  Compare the object models in several common object-oriented languages.  Javascript is prototype-oriented.  ruby is...  horrible-oriented.
19:46:07 <scalaLove> nope, probably soon, currently I am on Scala and Haskell
19:46:14 <wm_eddie> Or awesome-oriented depending on what floats your boat.
19:46:29 <Jafet> What do you think of sigfpe's "algebraic" monad replacement?
19:46:31 <eivuokko> scalaLove, I take you mean general purpose language.  Year is not a long time at all for getting to know paradigms, nevermind the details that affect language design.
19:46:41 <scalaLove> the more languages i use the more general patterns i see, and it gets easier to learn
19:46:58 <c_wraith> bad software engineering seems to be the rule in ruby, and I think that's mostly the result of the object model encouraging "oh, I'll just hack it in from somewhere else" design.
19:47:02 <scalaLove> it is enough for me, i am not new to this
19:47:12 <Jafet> (^ |Jedai|, perhaps)
19:47:25 <Botje> c_wraith: c'thulhu on rails? :)
19:47:36 <fergusnoble> hey, quick question, I have a list of type IO [Double] and I want to take the first n elements from it but im not having much luck using take, return and bind in various ways, whats the proper way to do that?
19:47:39 <c_wraith> Botje: that matches my experience
19:47:50 <Berengal> fergusnoble: fmap (take n)
19:48:23 <|Jedai|> Jafet: it looks worthy of more digging :)
19:48:24 <wm_eddie> heh, bad software engineering? What software engineering, we all know Railsists were all English majors.
19:49:10 <Jafet> Software isn't engineered. It is grown.
19:49:16 <fergusnoble> Berengal: that doesnt seem to terminate
19:49:26 <Jafet> That's why all big software look like horrible mutations.
19:49:34 <fergusnoble> (its an infinite list)
19:49:34 <Berengal> fergusnoble: Probably because your IO doesn't terminate
19:49:46 <|Jedai|> fergusnoble: be careful though, if you obtained you IO [Double] from an [IO Double] be aware that taking n after you transformed it won't allow you to only perfom the n firsts compuations
19:50:16 <Twey> The only difference is whether it grows in neat little separate bundles, like toadstools, or huge fat blobs, like coral
19:50:22 <fergusnoble> |Jedai|: oh, ok thats what I'm doing
19:50:38 <Veinor> I would use liftM instead of fmap to be honest :P
19:50:47 <|Jedai|> fergusnoble: It would be better to show us what you are doing, if you can take n from the [IO Double] list instead
19:50:58 <Berengal> Veinor: I'm liable to use <$>...
19:51:07 <Veinor> true, true
19:51:14 <|Jedai|> fergusnoble: if you know n at this stage that is
19:51:28 <fergusnoble> one sec, ill paste up the code
19:52:55 <chrisdone> lambdabot has grown like akira
19:53:09 <Jafet> "I... am... lambdabot"
19:53:16 <Veinor> LUNABOOOOOOOOOOOOOOOOOOOOOOOOOOT
19:53:25 <Veinor> *explodes*
19:53:28 <fergusnoble> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13671#a13671
19:53:56 <wm_eddie> By definition, all software is more macine than man, and therefore twisted and evil.
19:54:03 <chrisdone> explosion of a thousand thunks all being evaluated at once
19:54:08 <scalaLove> pattern matching acts as the inverse of construction, it's sometimes referred to as deconstruction, Can someone explain me what that means in a noobish way so i get it please? :(
19:54:27 <Jafet> wm_eddie, pretty sure you have that the wrong way round.
19:54:33 <sohum> @src mapM
19:54:34 <lambdabot> mapM f as = sequence (map f as)
19:55:02 <sohum> @pl \m f as = sequence (m f as)
19:55:03 <lambdabot> (line 1, column 9):
19:55:03 <lambdabot> unexpected "="
19:55:03 <lambdabot> expecting pattern or "->"
19:55:04 <chrisdone> scalaLove: (1,1) is the construction of a tuple. foo (a,b) = .. is the deconstruction. see how the deconstruction is written the same as the construction?
19:55:06 <opqdonut> '/wg jimki
19:55:09 <opqdonut> woops
19:55:10 <sohum> @pl \m f as -> sequence (m f as)
19:55:11 <lambdabot> ((sequence .) .)
19:55:22 <chrisdone> > let [a,b,c] = [1,2,3] in (a,b,c)
19:55:24 <lambdabot>   (1,2,3)
19:55:49 <|Jedai|> out <- sequence . take n . map (addnoise sigma rng) $ l
19:55:57 <chrisdone> > let (Just a) = (Just 42) in a
19:56:31 <lambdabot>   42
19:56:31 <|Jedai|> and pass n as a parameter of noiseify
19:56:32 <|Jedai|> or maybe maybe, just in this case you could use unsafeInterleaveIO
19:56:41 <chrisdone> scalaLove: get it?
19:56:42 <sohum> @hlint
19:56:43 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:56:49 <sohum> nope, no hlint
19:57:05 <|Jedai|> fergusnoble: I'm going to lunch so ask around for more help :)
19:57:10 <scalaLove> chrisdone: oh i get it now thank you... for example this is construction: "S" ++ "S" and this is deconstruction [String] ? corect?
19:57:10 <fergusnoble> |Jedai|: ok, it would be nice to not have to do the take inside noiseify
19:57:26 <fergusnoble> ok, thanks
19:57:47 <sohum> any way to remove brackets from/simplify "((f .) . g) (h . k) i" ?
19:58:05 <ray> :t (.)
19:58:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:58:14 <ray> yess, correctskell still available
19:58:22 <scalaLove> chrisdone am i on track? ^
19:58:26 <Peaker> sohum: I like SEC notation for this kind of stuff -- essentially treating (.) as a unary operator
19:58:56 * sohum looks this up..
19:59:00 <Peaker> @where SEC
19:59:01 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
19:59:07 <ray> @let result = (.)
19:59:09 <lambdabot>  Defined.
19:59:11 <ray> basically
19:59:14 <Peaker> @let argument = flip (.)
19:59:16 <lambdabot>  Defined.
19:59:32 <Peaker> @type \f g -> ((f .) . g)
19:59:33 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
19:59:41 <sohum> so what, (result f . g) (h . k) i ?
19:59:43 <Peaker> oof
19:59:50 <Peaker> @type \f g -> ((f Prelude..) Prelude.. g)
19:59:52 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
19:59:57 <Peaker> @undef
20:00:02 <Peaker> @let argument = flip (Prelude..)
20:00:04 <lambdabot>  <local>:1:16: Not in scope: `Prelude..'
20:00:13 <Peaker> @let result = (P..)
20:00:14 <lambdabot>  <local>:1:9: Not in scope: `P..'
20:00:27 <Peaker> @let argument = flip (.)
20:00:28 <lambdabot>  Defined.
20:00:28 <chrisdone> scalaLove: (++) isn't a constructor, just an ordinary function
20:00:29 <Peaker> @type argument
20:00:30 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
20:00:36 <Peaker> damnit cale.. :)
20:00:49 <Peaker> @undef
20:00:55 <sohum> you can use asTypeIn
20:00:57 <chrisdone> scalaLove: a constructor is specifically defined by the 'data SomeType = MyConstructor ..'
20:01:05 <sohum> :t argument
20:01:07 <lambdabot> Not in scope: `argument'
20:01:14 <Peaker> @let (f `myCompose` g) x = f (g x)
20:01:15 <lambdabot>  Defined.
20:01:19 <sohum> @let argument = flip (.)
20:01:21 <lambdabot>  Defined.
20:01:31 <Peaker> @undef
20:01:33 <Peaker> @let argument = flip myCompose
20:01:35 <lambdabot>  <local>:1:16: Not in scope: `myCompose'
20:01:38 <sohum> :t argument `asTypeIn` \arg -> arg id id
20:01:40 <lambdabot> Not in scope: `argument'
20:01:41 <Peaker> @let (f `myCompose` g) x = f (g x)
20:01:42 <lambdabot>  Defined.
20:01:47 <Peaker> @let argument = flip myCompose
20:01:48 <scalaLove> chrisdone: I would say then construction is creating a specific, and deconstruction is getting its most fundemental pattern so it can match it with others, correct?
20:01:49 <lambdabot>  Defined.
20:01:51 <Peaker> @let result = myCompose
20:01:52 <lambdabot>  Defined.
20:01:55 <sohum> @let arg = flip (.)
20:01:55 <Peaker> sorry about the spam
20:01:56 <lambdabot>  Defined.
20:01:59 <sohum> :t arg `asTypeIn` \arg -> arg id id
20:02:01 <lambdabot> forall a. (a -> a) -> (a -> a) -> a -> a
20:02:03 <chrisdone> scalaLove: sure
20:02:07 <scalaLove> because it is easier to match the general, chrisdone
20:02:20 <sohum> ok, so id's not the best
20:02:45 <sohum> @let fn :: a -> b -> c; fn = undefined
20:02:46 <lambdabot>  Defined.
20:02:51 <sohum> :t arg `asTypeIn` \arg -> arg fn fn
20:02:52 <lambdabot> forall a b c b1 c1. (a -> b -> c) -> ((b -> c) -> b1 -> c1) -> a -> b1 -> c1
20:03:03 <sohum> oh, woops
20:03:08 <sohum> @let fn :: a -> b; fn = undefined
20:03:09 <lambdabot>  <local>:6:0:
20:03:09 <lambdabot>      Duplicate type signature:
20:03:09 <lambdabot>        <local>:6:0-11: fn :: a -...
20:03:13 <sohum> @undef fn
20:03:16 <sohum> @let fn :: a -> b; fn = undefined
20:03:17 <lambdabot>  Defined.
20:03:21 <sohum> :t arg `asTypeIn` \arg -> arg fn fn
20:03:22 <lambdabot> Not in scope: `arg'
20:03:26 <Peaker> sohum: anyway   (f.).g   is like:  (result . result) f g
20:03:57 <Peaker> sohum: the idea is:  (result . result)  "lifts" a function its given to apply at the result of a result of something
20:04:26 <sohum> :t ((.) . (.)) `asTypeIn` \a -> a fn fn
20:04:28 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
20:04:50 <Peaker> sohum: the idea generalizes well:
20:04:51 <Peaker> @type  (result . first . map . argument) (*2)
20:04:52 <lambdabot> Not in scope: `result'
20:04:52 <lambdabot> Not in scope: `argument'
20:05:15 <Veinor> I need to understand how (f . ) . g works sometime
20:05:18 <chrisdone> @unpl (f .) . g
20:05:19 <lambdabot> (\ d i -> f (g d i))
20:05:19 <Peaker> @type  (result . first . map . argument) (*2)
20:05:21 <lambdabot> forall t d t1 t2. (Num t1) => (t -> ([t1 -> t2], d)) -> t -> ([t1 -> t2], d)
20:05:23 <ray> incidentally all these functions are fmap
20:05:35 <Veinor> yes I unpld it I just don't know why it does that
20:05:41 <ray> it's just "fmap fmap fmap fmap fmap" is harder to understand
20:06:17 <chrisdone> :t (.) id
20:06:18 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
20:06:21 <chrisdone> :t (.) ((.) id)
20:06:22 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (f a) -> f1 (f a)
20:06:39 <chrisdone> tch, lambdabot!!
20:06:39 <Peaker> Veinor: ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
20:07:03 <Veinor> ahh, using currying
20:07:04 <Peaker> Veinor: I just used the definition of (.):   (f . g) x = f (g x)
20:07:22 * sohum braaain
20:07:30 <Peaker> sohum: what? :)
20:07:54 <sohum> heh
20:08:41 <Veinor> :t (.) id
20:08:42 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
20:08:44 <Veinor> what?
20:08:50 <sohum> so (result . result) f g h lifts f to apply to the result of (g h) ?
20:08:51 <Veinor> Prelude> :t (.) id
20:08:51 <Veinor> (.) id :: (a -> b) -> a -> b
20:09:23 <Peaker> > let res =   (first . map . argument) (*2) ([(+10), (+20), (+30)], 4)    in map ($1000) (fst res)
20:09:25 <lambdabot>   [2010,2020,2030]
20:10:00 <Peaker> sohum: notice: I apply (*2) at the first of the tuple, inside each element, in the argument.  That's how easy it is to access the 1000 there :)
20:11:08 <sohum> Peaker: you're deliberately trying to fry my brain now :P
20:11:12 <Peaker> first applies a function (a -> a') at (a, b) to get (a', b)  argument applies a function (a' -> a)    at the 'a'  in:  (a -> b)  so you get  (a' -> b)  instead
20:11:57 <Peaker> sohum: the idea is that:   argument f  -- applies f at the argument.   map (argument f)    applies the argument-applier on each of a list.   first (map (argument f)) applies that to the first of a tuple
20:12:37 <Peaker> sohum: but its nicer to see this as a "path" on the type:   ([a -> b], c)   -- the path to "a"  is   first . map . argument
20:13:19 <sohum> that's pretty pretty
20:13:49 <Peaker> first and second access   a and b   in (a, b)   argument and result  access  a and b  in (a -> b)    to access a,b,c in (a -> b -> c)   we use  argument, result . argument, result . result   respectively (as that's actually (a -> (b -> c)) )
20:14:34 <Peaker> now, you can do some serious brain frying (until it clicks, and then it feels simple :-)  by defining:
20:14:54 <Peaker> @let infixr 2 ~> ; (arg ~> res) f = res . f . arg
20:14:56 <lambdabot>  Defined.
20:15:15 <Peaker> And now, you can apply   f, g, h   to (a -> b -> c)  with :   f ~> g ~> h
20:15:49 <Peaker> @type (length ~> length ~> show)
20:15:50 <lambdabot> forall a a1 a2. (Show a2) => (Int -> Int -> a2) -> [a] -> [a1] -> String
20:16:08 <Peaker> oops, something's wrong :)
20:16:43 <chrisdone> is that conal's thingie? I can't remember the name it was given
20:16:58 * sohum aaagh
20:17:16 <Peaker> conal started the SEC thing, then another guy invented the (~>) thing
20:17:24 <Peaker> I forget his name
20:17:29 <chrisdone> ``SEC''?
20:18:54 <Peaker> @where SEC
20:18:55 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
20:19:19 <Peaker> oh wait, nothing was wrong, I was just confused by the type of the unapplied (~>) :)
20:19:28 <scalaLove> what does this mean, confusing :( data Maybe a = Just a
20:19:28 <Peaker> @type (length ~> length ~> show) compare
20:19:30 <lambdabot> forall a a1. [a] -> [a1] -> String
20:19:47 <Peaker> > (length ~> length ~> show) compare [1,2,3] [4,5,6]
20:19:49 <lambdabot>   "EQ"
20:20:02 <Peaker> scalaLove: the whole line is:  data Maybe a = Nothing | Just a
20:20:17 <scalaLove> yep what it means?
20:20:39 <sohum> :t (length ~> length ~> show) `asAppliedTo` compare
20:20:40 <lambdabot> forall a a1. (Int -> Int -> Ordering) -> [a] -> [a1] -> String
20:20:40 <Peaker> scalaLove: It means:   Define a new data type called "Maybe" that has one type parameter called "a".  Define 2 new data constructors that are values of this type, called "Nothing" and "Just".  The Just constructor contains one field of type "a" in it
20:21:17 <Peaker> sohum: it applies length, length, and show   to the [a], [a1], and Ordering
20:21:26 <scalaLove> wow so that a can be anything like string,boolean,int?
20:21:34 <Peaker> scalaLove: "a" can be, yeah
20:22:02 <Peaker> scalaLove: Note that a single line here defined 3 new names!  "Maybe" (type name), "Just" and "Nothing" (value names)
20:22:13 <scalaLove> ok i understand the a after the constructors but why after Maybe
20:22:41 <Peaker> scalaLove: Maybe is a type, so it has a kind   Maybe :: * -> *    (Takes one type "a", returns one type "Maybe a").    Nothing :: Maybe a    and   Just :: a -> Maybe a
20:22:47 <scalaLove> i mean parametrize Maybe? it is just a name
20:22:49 <sohum> Peaker: I was kinda figuring it out but then you went and said "it applies length, length, and show   to the [a], [a1], and Ordering" and I'm confuzzled
20:23:01 <Peaker> scalaLove: oops, Maybe is a type *constructor*, not a type
20:23:05 <ray> the type is parameterized
20:23:13 <Peaker> scalaLove: "Maybe" is a family of types, not a single type
20:23:29 <Peaker> scalaLove: (Maybe Int, Maybe String) are distinct types
20:23:30 <ray> you use it to make types like Maybe Int
20:23:52 <Peaker> scalaLove: we apply "Maybe" to types with the same syntax we apply functions to values
20:24:07 <chrisdone> :t fst
20:24:09 <lambdabot> forall a b. (a, b) -> a
20:24:16 <scalaLove> uuuu that cool sentence "family types"... let me read some on wiki for that, it is time now
20:24:24 <chrisdone> scalaLove: do you think (,) is a type constructor?
20:24:42 <scalaLove> no
20:24:43 <Peaker> sohum: well,   (length ~> (length ~> show))  applies length to the outermost argument (the first list).  Then it applies length  to (result . argument) which is the inner argument (the second list).  Then it applies show to (result . result) (the Ordering)
20:24:59 <Peaker> scalaLove: don't confuse it with the relatively new feature of "type families" in GHC :)
20:25:05 <chrisdone> scalaLove: do you think (->) is a type constructor?
20:25:36 <Twey> It's a type constructor constructor!
20:25:50 <ray> (->) is the only one that's magic at all
20:25:57 <Peaker> scalaLove: Basically, a type has a bunch of values.  Say you want to make another type, that has the same amount of values, plus one value that you want to use to signal failure.. with me so far?
20:26:04 <chrisdone> ray: how is (->) magical?
20:26:09 <Phyx-> quick question, i have a .cabal file with both a executable and library in it. but when the library is registered ghc-pkg shows it's depends field much larger than what i specified. (it included the things i specified for only the tool)
20:26:24 <ray> chrisdone: show me your data declaration for (->)
20:26:36 <Peaker> ray: in the same sense that IO is magic
20:26:45 <ray> yeah
20:26:51 <Peaker> data a -> b = HaskellASTGoesHere
20:27:03 <scalaLove> I will read some on type families guys wont waste your time but you gave me a good intro thank you so much
20:27:03 <ray> data a -> b = magic
20:27:17 <ray> data IO a = magic
20:27:18 <Peaker> scalaLove: don't read on "type families", you'll be confused, its something else :)
20:27:25 <Peaker> scalaLove: Read on "type constructors"
20:27:46 <Veinor> @src unsafePerformIO
20:27:46 <Veinor> :/
20:27:46 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
20:27:57 <chrisdone> =)
20:27:58 <pastah_rhymez> what?
20:28:01 <ray> real world, unboxed
20:28:01 <pastah_rhymez> he can do that?
20:28:06 <scalaLove> i know what type constructor is but i dont get that a after maybe :(
20:28:12 <pastah_rhymez> @type realWorld
20:28:13 <lambdabot> Not in scope: `realWorld'
20:28:27 <jlouis> haha
20:28:34 <Berengal> scalaLove: That's the parameter to the type constructor
20:29:02 <scalaLove> why parametrize on two places when it is enough in after each of the constructors?
20:29:33 <Berengal> scalaLove: Try reading it as a function from types to types
20:29:45 <Peaker> scalaLove: do you understand   f x = x * 2   ?
20:29:54 <scalaLove> yes
20:29:55 <Peaker> scalaLove: Why does the "x" appear in 2 places, and not just 1?
20:30:42 <Peaker> scalaLove: one place it is declared as an argument input to "f", another it is used in the body of "f".  Same with Maybe.  data Maybe a = Nothing | Just a  -- once its declared as an argument to Maybe. Another it is used in the body of Maybe. It could be used in the body of Maybe multiple times
20:30:54 <scalaLove> because function depends on change of x, that is why f x?
20:31:06 <Peaker> data Tree a = Tip | Branch (Tree a) a (Tree a)
20:31:09 <scalaLove> yeah
20:31:29 <ray> that's a binary tree of values of a certain type
20:31:38 <Peaker> A "Tree" gets an "a" type parameter, and is either a Tip, or a Branch that has 2 (Tree a)s inside it, and a value of type "a" too
20:32:03 <Peaker> ray: Think of "Tree" as a type-level function here, as Berengal said
20:32:05 <Peaker> oops
20:32:09 <Peaker> scalaLove: ^^
20:33:35 <Berengal> Indeed, type-level functions have types too
20:33:39 <Berengal> @kind Maybe
20:33:39 <lambdabot> * -> *
20:34:02 <Berengal> Regular types have kind *, type constructors have some other kind. Only regular types have values.
20:34:09 <Veinor> @kind fmap
20:34:10 <lambdabot> Not in scope: type variable `fmap'
20:34:17 <Veinor> whoops
20:34:21 <Veinor> @kind Int
20:34:21 <Berengal> @kind Mu
20:34:22 <lambdabot> *
20:34:23 <lambdabot> (* -> *) -> *
20:34:27 <Twey> Mu?
20:34:30 <Peaker> scalaLove: If you define  f x = x * 2   its type might be:   f :: Int -> Int    so if you define  Maybe a = ... then its kind is  * -> *     because "x" was "Int"  and "a" is a * (simple type)
20:34:33 <Twey> What's that?  O.O
20:34:34 <scalaLove> oh my god now i get it :) it is so easy and stupid what was i thinking? :) thank you guys
20:34:37 <Berengal> Twey: fix for types
20:34:43 <Twey> Arrgh!
20:34:48 <Peaker> @src Mu
20:34:49 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
20:35:02 <Twey> Terrifying.
20:35:17 <Veinor> @src Omega
20:35:17 <lambdabot> Source not found. You speak an infinite deal of nothing
20:35:19 <Peaker> > Mu []
20:35:21 <lambdabot>   Not in scope: data constructor `Mu'
20:35:26 <Peaker> > In []
20:35:27 <lambdabot>   No instance for (GHC.Show.Show (L.Mu []))
20:35:28 <lambdabot>    arising from a use of `M500723...
20:35:37 <chrisdone> :t In 'a'
20:35:37 <sohum> :t In []
20:35:37 <Peaker> ah, so one can create an infinite list type
20:35:38 <lambdabot>     Couldn't match expected type `f (Mu f)'
20:35:38 <lambdabot>            against inferred type `Char'
20:35:38 <lambdabot>     In the first argument of `In', namely 'a'
20:35:39 <lambdabot> Mu []
20:35:39 <Berengal> Twey: It's sort of neat. If you fix Maybe, you get a list that can't hold values. If you fix [], you get a tree that can't hold values...
20:35:58 <Berengal> Mu Maybe is also isomorphic to unary naturals
20:36:08 <eivuokko> For some definition of neat ;)
20:36:18 <Twey> Berengal: Which is useful how?  :þ
20:36:22 <chrisdone> :t In id
20:36:23 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (Mu f)
20:36:24 <lambdabot>     Probable cause: `id' is applied to too few arguments
20:36:24 <lambdabot>     In the first argument of `In', namely `id'
20:36:34 <Berengal> Twey: idk... I just think it's neat.
20:36:48 <Peaker> Twey: I'd guess its useful in the same way the TypeCompose lib is useful
20:36:50 <eivuokko> Berengal, mind-bendingly fun? :)
20:37:09 <Peaker> Twey: If you define your type as a composition of "PL" type operators, rather than directly -- you can get a bunch of instances and functions for free
20:37:13 <Twey> So Mu [] = [[[[[[[[[[[[ … ]]]]]]]]]]]], ad infinitum?
20:37:17 <Berengal> eivuokko: The first time I got it my mind was indeed bent
20:37:34 <Berengal> Twey: Right. The type anyway
20:37:47 <mmorrow> , fix (Mu . Just)
20:37:50 <lunabot>  Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu ...
20:37:58 <Twey> Still terrifying.  ;)
20:38:20 <Berengal> Twey: Values of Mu [] include all lists of any length containing a Mu []
20:38:24 <Peaker> mmorrow: where does the Mu value name come from?  Isn't the data constructor called In ?
20:38:31 <Berengal> @type In [[]]
20:38:31 <lambdabot>     Couldn't match expected type `Mu []' against inferred type `[a]'
20:38:32 <lambdabot>     In the expression: []
20:38:32 <lambdabot>     In the first argument of `In', namely `[[]]'
20:38:34 <mmorrow> Peaker: it's called Mu in lunabot
20:38:37 <mmorrow> , src ''Mu
20:38:38 <Peaker> mmorrow: ah
20:38:41 <lunabot>  newtype Mu f = Mu (f (Mu f))
20:38:47 <Twey> Berengal: *nod* Infinity + x = Infinity
20:38:48 <Peaker> it sounds like a cow
20:38:51 * mmorrow never liked In
20:38:51 <eivuokko> Twey, it's just one form of expressing certain kind of infinity.  Step out and think in operations, not in values.  :-)
20:39:00 <mmorrow> Peaker: mooooo
20:39:00 <Peaker> Twey: for example,  if you define a type:   data MyType a = M (SomeType1 (SomeType2 a))    you can instead define:  type MyType = SomeType1 :. SomeType2   from TypeCompose -- and then you get Applicative instances and others for free
20:39:10 <Twey> Mµ
20:39:21 <Peaker> mmorrow: "In" steals an unrelated word unjustifiably, yeah
20:39:41 <mmorrow> , muT [0..3]
20:39:44 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
20:39:47 <Twey> Peaker: I… see
20:40:05 <chrisdone> Peaker: that's clever
20:40:18 <Peaker> Twey: so, to express composition of types you have :.  to express recursion of types (for things like List or Tree) you have Mu.  To express type sums you have Either and products you have (,).  So you don't need "data" anymore :)
20:40:33 <jlouis> mmorrow: lunabot is?
20:40:39 <jlouis> compared to lambdabot
20:40:41 <sohum> @pl (\x -> f (g x))
20:40:42 <lambdabot> f . g
20:40:44 <Peaker> chrisdone: Yeah, TypeCompose is cool :)
20:40:46 <sohum> right, duh
20:40:48 <Twey> Peaker: What about custom typeclass instances?  :þ
20:41:01 <chrisdone> you guys stop being bloody interesting
20:41:06 <chrisdone> I just left my bacon to go cold
20:41:07 <Peaker> Twey: If you need non-standard ones maybe your semantics aren't as simple as they could be :)
20:41:09 * chrisdone noms anyway
20:41:16 <Twey> Heh
20:41:57 <Peaker> @where TCM
20:41:58 <lambdabot> I know nothing about tcm.
20:42:24 <mmorrow> , $(foldT [|()|] (\a b->[|($a,$b)|]) (muT (fmap lift [0..7::Int])) id)
20:42:27 <lunabot>  (((0,1),(2,3)),((4,5),(6,7)))
20:42:36 <mmorrow> jlouis: an evalbot
20:42:39 <Peaker> @where+ TCM http://conal.net/papers/type-class-morphisms/
20:42:40 <lambdabot> Done.
20:43:31 <mmorrow> jlouis: that can do template-haskell and has some misc other libs in scope than lambdabot
20:43:31 <jlouis> mmorrow: mm, ok
20:43:42 <jlouis> thanks
20:44:12 <chrisdone> :t (~>)
20:44:13 <lambdabot> forall t3 t2 t t1. (t3 -> t2) -> (t -> t1) -> (t2 -> t) -> t3 -> t1
20:44:42 <mmorrow> jlouis: here's the repo, but it may be finicky on account of the ghc-api volatility (wrt interface), but this should build ok on 6.10.* http://moonpatio.com/repos/lunabot/
20:44:45 <chrisdone> :t (~>) id
20:44:46 <lambdabot> forall t3 t t1. (t -> t1) -> (t3 -> t) -> t3 -> t1
20:45:17 <scalaLove> arent local variables imperative style too? I mean, u still save data to disk, imagine u have to save 100 locals, just registers wont do it, you will have to save on disk...
20:45:23 <mmorrow> jlouis: ugh i forgot, there's a bug in 6.10.x, x > 1 related to something irrelevant to the bot, but it bites nonetheless
20:45:38 <mmorrow> jlouis: i should work around that... (it's like a two line fix)
20:46:00 <Peaker> scalaLove: mutating local variables is considered imperative -- not sure what the "disk" is relevant for here
20:46:09 <mmorrow> jlouis: oh, i almost forgot
20:46:19 <Peaker> scalaLove: the implementation of FP languages is often done using imperative tools
20:46:20 <mmorrow> notably is has eval
20:46:37 <mmorrow> , (fromJust.fromDynamic.fromJust.fromDynamic) (eval "eval \"42\"") :: Integer
20:46:41 <lunabot>  42
20:46:59 <Peaker> mmorrow: what about namespacing?
20:47:09 <Peaker> mmorrow: what names does it have access to?
20:47:22 <mmorrow> Peaker: you mean for eval, or wrt the bot in general?
20:47:29 <Peaker> for eval
20:47:50 <chrisdone> :t ((~>) show cycle (++"!"))
20:47:51 <lambdabot> forall t3. (Show t3) => t3 -> [Char]
20:47:56 <chrisdone> > ((~>) show cycle (++"!")) 7
20:47:57 <lambdabot>   "7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!7!...
20:48:07 <mmorrow> Peaker: eval can see whatever the bot can see (which includes eval itself). the actual bot program iis literally also using the same exact eval function for Strings coming in over the network
20:48:22 <mmorrow> which is my favorite part :)
20:48:29 <Peaker> ah, cool
20:48:46 <Berengal> Self-recursive :)
20:48:48 <mmorrow> so every time you `eval' in the bot, you're already in an eval..
20:48:51 <scalaLove> Peaker: disk does not matter? why did i think that if something is writen to disk it is imperative?
20:49:36 <Peaker> scalaLove: The "engine" that implements functional programming does a lot of side effects -- but that doesn't matter, its just an implementation.  The functional program is pure - and exists besides any specific implementations
20:49:52 <mmorrow> chrisdone: wait, wut
20:50:03 <mmorrow> @type (->)
20:50:04 <lambdabot> parse error on input `->'
20:50:05 <mmorrow> @type ((->))
20:50:07 <lambdabot> parse error on input `->'
20:50:10 <Peaker> scalaLove: If the implementation isn't buggy - you can ignore it when you reason about your functional program - and then side effects are out of the question
20:50:14 <chrisdone> :t (~>)
20:50:15 <lambdabot> forall t3 t2 t t1. (t3 -> t2) -> (t -> t1) -> (t2 -> t) -> t3 -> t1
20:50:17 <mmorrow> @type ((->) "432")
20:50:18 <lambdabot> parse error on input `->'
20:50:22 <mmorrow> :t ((->) "432")
20:50:23 <lambdabot> parse error on input `->'
20:50:28 <mmorrow> unicode?
20:50:31 <chrisdone> it's `~' not '-', haha
20:50:34 <mmorrow> , "~>"
20:50:35 <mmorrow> heh
20:50:36 <lunabot>  "~>"
20:50:37 <chrisdone> tilde
20:50:41 <mmorrow> oh
20:50:43 <mmorrow> hah
20:50:44 <chrisdone> hahaha
20:50:47 <Peaker> mmorrow: what library implements eval?
20:50:54 <|Jedai|> scalaLove: What's important is semantic, Haskell could be implemented with a stack on disk and it wouldn't change anything to its semantic from the point of view of the coder (except speed of course)
20:50:58 <mmorrow> Courier 10 Pitch loses this battle
20:51:00 <|Jedai|> Peaker: hint, no ?
20:51:02 <sohum> @src map
20:51:03 <lambdabot> map _ []     = []
20:51:03 <lambdabot> map f (x:xs) = f x : map f xs
20:51:09 <chrisdone> mmorrow: needs more Deja Vu Sans Mono :D
20:51:12 <mmorrow> Peaker: it's directly using the ghc-api, with minor hackery
20:51:13 <Peaker> |Jedai|: maybe, I'm not sure
20:51:29 <scalaLove> Peaker: I see, so conclusion: functional programming uses local variables, but changing them is done not by directly asigning a value but by mapping to a function/value? am i wrong somehow :(
20:51:32 <mmorrow> Peaker: http://moonpatio.com/repos/lunabot/Luna/Bot/Eval.hs
20:51:45 <Berengal> scalaLove: Local variables aren't changed
20:51:50 <Berengal> They're immutable
20:51:51 <Peaker> sohum: map f = foldr ((:) . f) []  -- read as:  replace every (:) with (:) . f and each [] with []
20:51:51 <|Jedai|> scalaLove: there are no variables in Haskell, only bindings
20:51:55 <mmorrow> and
20:51:57 <mmorrow> http://moonpatio.com/repos/lunabot/Luna/Bot/Eval/GHC.hs
20:52:08 <|Jedai|> scalaLove: as they say : "In Haskell variables don't"
20:52:15 <mmorrow> chrisdone: http://moonpatio.com/images/Courier10Pitch.gif
20:52:18 <mmorrow> ftw!
20:52:20 <chrisdone> mmorrow: I like how your server doesn't force me to download the .hs file
20:52:34 <mmorrow> chrisdone: hah, that's my favorite part of it!
20:52:35 <mmorrow> :)
20:52:36 <scalaLove> yes it has vals only no vars ... but ... ok nevermind i was confused
20:52:43 <Peaker> scalaLove: *Current implementations* of functional programming use mutable variables (local and non-local).    The implementation can be ignored - your programs exist beyond the capacity to execute them.  Executing your program is just one out of many interesting ways to view that program
20:52:45 <mmorrow> chrisdone: oh, i thought you said /don't/..
20:52:46 <sohum> Peaker: I know. I'm just reimplenting a custom variant
20:52:55 <benmachine> |Jedai|: could probably do with a comma after Haskell
20:52:55 <chrisdone> mmorrow: :D
20:53:02 <mmorrow> chrisdone: yeah, it's so annoying when it's not text/plain
20:53:03 <benmachine> otherwise it's just ee
20:53:10 <Peaker> sohum: custom variant of map?
20:53:11 <|Jedai|> benmachine: right, forgot it
20:53:20 <sohum> Peaker: map3 - map 3 at a time
20:53:40 <sohum> Peaker: I imagine you could do something similar with slice, come to think of it
20:53:43 <sohum> :t slice
20:53:43 <Peaker> sohum: isn't that zipWith or recursive zipWith?
20:53:44 <lambdabot> Not in scope: `slice'
20:54:02 <Peaker> sohum: what's the type you want rather than (a -> b) -> [a] -> [b] ?
20:54:12 <chrisdone> :t length ~> length
20:54:13 <lambdabot> forall a a1. (Int -> [a1]) -> [a] -> Int
20:54:22 <|Jedai|> sohum: 3 consecutive elements at a time or 3 lists ?
20:54:23 <chrisdone> :t length ~> length ~> length
20:54:24 <lambdabot> forall a a1 a2. (Int -> Int -> [a2]) -> [a] -> [a1] -> Int
20:54:40 <sohum> Peaker: no. map3 f (a:b:c:ds) = (f a b c):map3 f ds
20:54:50 <chrisdone> I like that
20:54:57 <Peaker> scalaLove: Functional programs are mathematical constructs and don't have any variables or side effects at all.   Normalizing (which means evaluating, or executing) these functional program *might* (as in current implementations) involve side effects, but that's besides the programs themselvesa
20:55:16 <Peaker> sohum: oh, map on chunks
20:55:24 <sohum> chunks! that's the word
20:55:25 <|Jedai|> sohum: something with a "splitEvery" would probably be more elegant :)
20:55:36 <sohum> @hoogle split
20:55:38 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
20:55:38 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
20:55:38 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
20:55:43 <sohum> @hoogle splitEvery
20:55:43 <lambdabot> No results found
20:55:50 <sohum> :t split
20:55:51 <benmachine> what do you do with the last two elements?
20:55:52 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
20:55:58 <benmachine> :t splitAt
20:55:59 <lambdabot> forall a. Int -> [a] -> ([a], [a])
20:56:06 <Peaker> @let chunks n = map (take n) . takeWhile (not . null) . iterate (drop n)
20:56:07 <lambdabot>  Defined.
20:56:08 <sohum> benmachine: only meant to be used on lists with a multiple of three
20:56:09 <Peaker> @type chunks
20:56:11 <lambdabot> forall a. Int -> [a] -> [[a]]
20:56:18 <Peaker> > chunks 3 "Hello world!"
20:56:31 <|Jedai|> sohum: I know that there's a split package on Hackage that have all sorts of split including a chunks one
20:56:31 <lambdabot>   ["Hel","lo ","wor","ld!"]
20:56:53 <Peaker> > (map . map) succ . chunks 3 $ "Hello world!"
20:56:55 <lambdabot>   ["Ifm","mp!","xps","me\""]
20:57:04 <Peaker> > map head . chunks 3 $ "Hello world!"
20:57:06 <lambdabot>   "Hlwl"
20:57:06 <burp> > 9 % (8*6)
20:57:07 <lambdabot>   3 % 16
20:57:15 <sohum> cool
20:57:50 <mmorrow> Peaker: well, actually the evaluator is made a separate binary than the actual bot program for isolation, so rlimits doesn't nuke the bot when they expire for the evaluator, and such
20:58:09 <mmorrow> Peaker: but it's using eval nonetheless
20:58:26 <mmorrow> , fix id
20:58:41 <lunabot>  luna: out of memory (requested 2097152 bytes)
20:58:44 <Peaker> mmorrow: that's cool - though sandboxing in-process would be nice to allow for Haskell as a dynamic "scripting" language in Haskell programs
20:58:57 <mmorrow> Peaker: yeah totally it would
20:59:01 <scalaLove> where and (let and in) have same use for locals right?
20:59:24 <Axman6> scalaLove: almost
20:59:29 <Peaker> scalaLove: they bind names to values -- sometimes they're called "variables" but they don't really "vary" they're immutable
20:59:42 <Peaker> scalaLove: the name bindings' scope is local, if that's what you ask
20:59:48 <scalaLove> not 100%?
21:00:00 <Axman6> there are places you can use let without being able to use where (like in a do block) but, let/in and where can be used interchangably
21:00:20 <|Jedai|> scalaLove: not exactly, "where" is a syntaxic construct that attach to a declaration (eventually with several guards) whereas "let ... in ..." is an expression
21:00:22 <Peaker> you can always use where but it may be a PITA :)
21:00:47 <mmorrow> Peaker: one plus of a separate evaluator binary though is that you can update it without going offline, which i didn't have in mind initially, but has been hugely handy
21:01:48 <mmorrow> Peaker: but right, in-process eval that's sandboxable would be awesome
21:03:30 <|Jedai|> scalaLove: they're overlapping in some cases but they both have use case where you can't use the other
21:04:06 <scalaLove> ok nice explanation will have it in head, i am sure i will recognize which one is apropriate when time comes
21:04:14 <chrisdone> > ((Just . head) ~> length ~> id) (,) "foo" "bar"
21:04:15 <lambdabot>   (Just 'f',3)
21:04:32 <chrisdone>  @_@
21:04:35 <Axman6> :t (~>)
21:04:36 <lambdabot> forall t3 t2 t t1. (t3 -> t2) -> (t -> t1) -> (t2 -> t) -> t3 -> t1
21:04:49 <chrisdone> Peaker: I'm trying to find a use for this function
21:04:57 <Peaker> chrisdone: Good luck! :)
21:05:00 <chrisdone> it would be cool if I didn't need `id'
21:06:04 <chrisdone> > let tuplize a b = ((Just (head a)),length b) in tuplize "foo" "bar" -- this vs.
21:06:04 <chrisdone> > let tuplize = ((Just . head) ~> length ~> id) (,) in tuplize "foo" "bar"
21:06:06 <lambdabot>   (Just 'f',3)
21:06:06 <lambdabot>   (Just 'f',3)
21:06:11 <Peaker> @let infixr 2 ~~> ; f ~~> g = f ~> g ~> id
21:06:12 <lambdabot>  Defined.
21:06:23 <Peaker> > ((Just . head) ~~> length) (,) "foo" "bar"
21:06:24 <lambdabot>   (Just 'f',3)
21:06:44 <Peaker> that won't compose though :)
21:06:48 <chrisdone> yeah
21:07:37 <Kim^Walkman> > ((Just . head) ~~> length) (,) "foo" "ba"
21:07:39 <lambdabot>   (Just 'f',2)
21:08:09 <Veinor> :t (~~>)
21:08:11 <lambdabot> forall t t1 t2 t3 t4. (t -> t1) -> (t2 -> t3) -> (t1 -> t3 -> t4) -> t -> t2 -> t4
21:08:24 <Veinor> haha
21:08:28 <Veinor> @src (~~>)
21:08:29 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:08:39 <Peaker> chrisdone: I think something might be possible with ugly type class hackery
21:08:42 <chrisdone> Veinor: Peaker defined it just above
21:08:48 <Axman6> someone needs to fix the type names chooser >_<
21:09:08 <Peaker> Axman6: canonizing to a,b,c would be nice, yeah
21:09:17 <Axman6> indeed
21:09:43 <chrisdone> what's that '?'-style way of annotating expressions so that they appear in the type result in lambdabot?
21:09:55 <chrisdone> :t a?x
21:09:57 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `Expr'
21:09:57 <lambdabot>     In the expression: a ?x
21:09:57 <chrisdone> :t a?
21:09:58 <lambdabot> parse error (possibly incorrect indentation)
21:10:15 <|Jedai|> > ((Just . head) ~~> ?f) (,) "foo" "ba"
21:10:16 <lambdabot>   Unbound implicit parameter (?f::[GHC.Types.Char] -> t3)
21:10:16 <lambdabot>    arising from a u...
21:10:20 <|Jedai|> :t ((Just . head) ~~> ?f) (,) "foo" "ba"
21:10:21 <lambdabot> forall t3. (?f::[Char] -> t3) => (Maybe Char, t3)
21:10:26 <chrisdone> ah there we go
21:10:28 <|Jedai|> chrisdone: that ?
21:10:32 <chrisdone> yeah, that's useful
21:11:17 <|Jedai|> chrisdone: Yeah, quite nice, the only use I've ever done of implicit parameters ;)
21:11:29 <Peaker> I wonder if the dynamic scoping implementors realized the main usefulness is getting type of sub-expressions :)
21:11:36 <chrisdone> :t let ?foo ~~> ?bar = ?foo ~> ?bar ~> id in ?foo
21:11:38 <lambdabot> Parse error in pattern
21:11:47 <chrisdone> :t let foo ~~> bar = ?foo ~> ?bar ~> id in foo
21:11:48 <lambdabot> Not in scope: `foo'
21:11:54 <chrisdone> ~_~
21:12:11 <|Jedai|> :t ?foo ~> ?bar ~> id
21:12:12 <lambdabot> forall t3 t2 t31 t21 t. (?bar::t31 -> t21, ?foo::t3 -> t2) => (t2 -> t21 -> t) -> t3 -> t31 -> t
21:12:14 <Peaker> :t let foo ~~> bar = ?foo ~> ?bar ~> id in (~~>)
21:12:14 <chrisdone> :t let foo ~~> bar = ?foo ~> ?bar ~> id in (~~>)
21:12:16 <lambdabot> forall t t1 t2 t21 t22 t3 t31. (?foo::t3 -> t2, ?bar::t31 -> t21) => t -> t1 -> (t2 -> t21 -> t22) -> t3 -> t31 -> t22
21:12:16 <lambdabot> forall t t1 t2 t21 t22 t3 t31. (?foo::t3 -> t2, ?bar::t31 -> t21) => t -> t1 -> (t2 -> t21 -> t22) -> t3 -> t31 -> t22
21:12:18 <chrisdone> hehe
21:12:25 <Axman6> >____<
21:12:39 <chrisdone> what a mess
21:12:59 <chrisdone> :t (+1) ~~> (+2)
21:13:01 <lambdabot> forall t t2 t4. (Num t, Num t2) => (t -> t2 -> t4) -> t -> t2 -> t4
21:13:03 <|Jedai|> This name chooser urgently needs a refit !!
21:13:14 <chrisdone> :t ((+1) ~~> (+2)) ~~>
21:13:16 <lambdabot> parse error (possibly incorrect indentation)
21:13:16 <chrisdone> :t (((+1) ~~> (+2)) ~~>)
21:13:18 <lambdabot> forall t t2 t4 t21 t3 t41. (Num t, Num t2) => (t21 -> t3) -> ((t -> t2 -> t4) -> t3 -> t41) -> (t -> t2 -> t4) -> t21 -> t41
21:14:15 <chrisdone> doesn't compose
21:14:32 <|Jedai|> , [$ty|?foo ~> ?bar ~> id|]
21:14:36 <lunabot>  luna: Exception when trying to run compile-time code:
21:14:38 <chrisdone> :t (+1) ~> (+2)
21:14:40 <lambdabot> forall t3 t. (Num t3, Num t) => (t3 -> t) -> t3 -> t
21:14:48 <chrisdone> :t ((+1) ~> (+2) ~~>)
21:14:49 <lambdabot>     The operator `~~>' [infixr 2] of a section
21:14:49 <lambdabot>         must have lower precedence than that of the operand,
21:14:49 <lambdabot>           namely `~>' [infixr 2]
21:14:56 <chrisdone> :t (((+1) ~> (+2)) ~~>)
21:14:57 <lambdabot> forall t3 t t2 t31 t4. (Num t3, Num t) => (t2 -> t31) -> ((t3 -> t) -> t31 -> t4) -> (t3 -> t) -> t2 -> t4
21:15:21 <chrisdone> n/m
21:21:28 <scalaLove> wish me luck i think i am ready to tackle euler #5 with Haskell :D
21:22:49 <Axman6> go for it!
21:23:19 <Peaker> @hoogle Eq a => a -> [a] -> Int
21:23:20 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
21:23:20 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
21:23:20 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
21:24:10 <chrisdone> :t if'
21:24:11 <lambdabot> Not in scope: `if''
21:24:25 <chrisdone> have we got a library with if' in it?
21:25:47 <chrisdone> @instances Monad
21:25:48 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:25:57 <chrisdone> @instances Monoid
21:25:58 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:26:15 <Axman6> @src (,) Monoid
21:26:15 <lambdabot> Source not found. Sorry.
21:26:28 <Axman6> don't worry about it lambdabot, it's not your fault
21:26:46 <Axman6> @src Monoid
21:26:46 <lambdabot> class Monoid a where
21:26:46 <lambdabot>     mempty  :: a
21:26:46 <lambdabot>     mappend :: a -> a -> a
21:26:46 <lambdabot>     mconcat :: [a] -> a
21:27:11 <sohum> hm. How would you use Parsec with a Tree-like input type?
21:27:23 <chrisdone> recursively
21:27:29 <Axman6> @djinn (r -> a) -> (r -> a) -> (r -> a)
21:27:30 <lambdabot> f _ a b = a b
21:27:49 <Axman6> sohum: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
21:28:12 <chrisdone> tree :: Parser Tree
21:28:12 <chrisdone> tree = try branch <|> leaf where branch = atomicthing; leaf = Leaf <$> atomicthing <*> atomicthing
21:28:14 <chrisdone>  <_ <
21:28:58 <Axman6> chrisdone: what datatype is that parsing? i'd have thought a leaf would only have one element
21:28:59 <|Jedai|> chrisdone: your branch and leaves have curious definitions
21:29:17 <sohum> chrisdone: that's parsing /to/ a tree
21:29:40 <Axman6> sohum: what else would you want?
21:29:41 <chrisdone> parsing a tree to a tree..
21:30:00 <|Jedai|> sohum: You would have to make the input type an instance of Stream
21:30:31 <sohum> |Jedai|: either that, or do the recursive thing
21:30:39 <|Jedai|> sohum: I'm curious as to how you would do that ? Choose a traversal order and do it like that ?
21:30:41 <sohum> |Jedai|: a preorder traversal, or something?
21:31:04 <chrisdone> oh right, parsing an actual tree not a string, my bad
21:31:20 <Axman6> chrisdone: that's what i assumed too
21:31:50 <|Jedai|> sohum: I'm not sure that Parsec is the right tool by the way, one of the generic library may be more appropriate
21:31:56 <sohum> basically, I'm parsing a PDDL file, but want to split the String->Sexp and the Sexp->PDDL bits
21:32:44 <sohum> I already have the Sexp->PDDL code, actually. With pattern matching... it looks ok. (it'd look better if I didn't need constructors for Sexp grumble grumble)
21:33:16 <Axman6> sohum: what's the Sexp type look like? (just curious)
21:33:39 <sohum> Axman6: data Sexp = List [Sexp] | Lit String
21:33:48 <Axman6> heh, ok
21:34:06 <Peaker> @hoogle lexer
21:34:07 <lambdabot> Language.Haskell.Lexer lexer :: (Token -> P a) -> P a
21:34:07 <lambdabot> module Language.Haskell.Lexer
21:34:08 <sohum> and then I added a | Sym String because if I have to use constructors I may as well do some early differentiation
21:34:54 <Peaker> Why the parse monad stuff?  Why not a simple [Token] ?
21:35:10 <Peaker> How do I go from String -> [Token]  (Haskell lexing)  easily?
21:35:28 <Axman6> :t lex
21:35:28 <lambdabot> String -> [(String, String)]
21:35:42 <chrisdone> :t readP
21:35:42 <Peaker> ah, thanks
21:35:43 <Axman6> > lex "let f x = x in f 1"
21:35:43 <lambdabot> Not in scope: `readP'
21:35:44 <lambdabot>   [("let"," f x = x in f 1")]
21:35:45 <Peaker> @index lex
21:35:46 <lambdabot> Text.Read, Prelude, Text.Read.Lex
21:35:46 <chrisdone> :t readPrec
21:35:48 <lambdabot> Not in scope: `readPrec'
21:38:45 <|Jedai|> scalaLove: this problem can be solved in 19 characters
21:39:23 <|Jedai|> scalaLove: probably less but we can say that the canonical solution would takes approximately 20 characters
21:42:13 <sohum> hrm, there's a sexpr library in hackage
21:43:25 <sohum> that would have been useful /before/ I wrote my bloody own
21:44:03 <Peaker> > lex ""
21:44:05 <lambdabot>   [("","")]
21:44:14 <Peaker> when does lex return a list that's not exactly one element?
21:45:00 <Phyx-> when it fails? :P
21:45:26 <Phyx-> "If there is no legal lexeme at the beginning of the input string, lex fails (i.e. returns []). "
21:45:34 <Axman6> > lex "\n"
21:45:35 <lambdabot>   [("","")]
21:46:01 <sohum> when there's more than one lex-result, I'd assume
21:46:14 <sohum> > lex "a . b"
21:46:23 <|Jedai|> > lex "184 hello"
21:46:25 <lambdabot>   [("a"," . b")]
21:46:35 <lambdabot>   [("184"," hello")]
21:46:35 <sohum> > lex "$ a"
21:46:39 <Axman6> > lex " let f x"
21:46:46 <lambdabot>   [("$"," a")]
21:46:50 <lambdabot>   [("let"," f x")]
21:46:56 <Phyx-> sohum: i don't think there ever is, lex onl parses till the first one. i beleive the list type is because it can be used with things like alternative to make a naive backtracking parser
21:46:58 <sohum> but I'm having trouble thinking of when that could happen
21:47:38 <Axman6> @hoogle Char -> Bool
21:47:58 <lambdabot> Network.URI isAllowedInURI :: Char -> Bool
21:48:00 <Axman6> hmm, wonfer why lambdabot is being so slow
21:48:02 <lambdabot> Data.Char isAlpha :: Char -> Bool
21:48:04 <Phyx-> who killed the bot?
21:48:07 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
21:48:26 <Axman6> > filter isAlphaNum ['a'..]
21:48:48 <lambdabot>   "abcdefghijklmnopqrstuvwxyz\170\178\179\181\185\186\188\189\190\192\193\194...
21:49:01 <Axman6> > filter (not . isAlphaNum) ['a'..]
21:49:02 <lambdabot>   "{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\141\142\143\1...
21:49:38 <sohum> on second thought, I don't like the sexp library. It can't be pattern-matched
21:49:49 <sohum> I'll stick with mine
21:51:22 <Peaker> Ladies and gentlemen, let me present:
21:51:23 <Peaker> @type (concat ~> length ~> id)
21:51:25 <lambdabot> forall a a1 t. ([a] -> Int -> t) -> [[a]] -> [a1] -> t
21:51:27 <Peaker> > typeCanonize "forall a a1 t. ([a] -> Int -> t) -> [[a]] -> [a1] -> t"
21:51:29 <lambdabot>   "forall a b c. ([a] -> Int -> c) -> [[a]] -> [b] -> c"
21:51:32 <Peaker> hehe
21:51:43 <scalaLove> |Jedai| man i wanna first solve it at all, in Haskell, will worry later of space and speed :D
21:51:45 <Peaker> @type (length ~~> concat)
21:51:47 <lambdabot> forall a a1 t4. (Int -> [a1] -> t4) -> [a] -> [[a1]] -> t4
21:51:49 <sohum> whaaaat
21:51:54 <Peaker> > typeCanonize "forall a a1 t4. (Int -> [a1] -> t4) -> [a] -> [[a1]] -> t4"
21:51:55 <lambdabot>   "forall a b c. (Int -> [b] -> c) -> [a] -> [[b]] -> c"
21:52:10 <Peaker> lame string manipulations, though :)
21:52:40 <Berengal> Neat
21:52:57 <|Jedai|> scalaLove: just to give you an idea of the shortest (probably fastest too) program ;)
21:52:59 <Peaker> I ended up "tokenizing" with groupBy
21:53:40 <Berengal> |Jedai|: You could probably push it down to 18 or 17 characters
21:53:51 <Peaker> typeCanonize is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13677#a13677
21:54:13 <|Jedai|> Peaker: Thanks :) It should help
21:54:54 <|Jedai|> Berengal: right, but it's just to have an idea of the size (using only the prelude, you can do 18 characters with a fast program)
21:54:57 <Peaker> :-)
21:55:56 <Berengal> I was a bit surprised to learn lcm was in the prelude when I first found it...
21:56:55 <Twey> But no gcm?
21:57:00 <Berengal> That too
21:57:08 <Berengal> No, gcd
21:57:13 <Twey> Ah, that's it
21:57:23 <Berengal> gcm doesn't make sense, really...
21:57:48 <Twey> Yeah
21:58:24 <|Jedai|> Berengal: Right, but gcd and lcm come in handy sometimes, and they're so very simple...
21:58:48 <|Jedai|> Though maybe GHC did improve the report definitions ?
21:59:14 <Berengal> |Jedai|: I don't think I've used them for anything, but that may be because I just didn't think of them...
21:59:32 <Peaker> > map (gcd && lcm) [1..10]
21:59:34 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
21:59:34 <lambdabot>         against inferred type ...
21:59:38 <Twey> @src gcd
21:59:39 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
21:59:39 <lambdabot> gcd x y = gcd' (abs x) (abs y)
21:59:39 <lambdabot>    where gcd' a 0  =  a
21:59:39 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
21:59:39 <Peaker> > map (gcd &&& lcm) [1..10]
21:59:41 <lambdabot>   [({-3->1;-2->1;-1->1;0->1;1->1;2->1;3->1},{-3->3;-2->2;-1->1;0->0;1->1;2->2...
21:59:41 <Twey> @src lcm
21:59:41 <lambdabot> lcm _ 0     =  0
21:59:42 <lambdabot> lcm 0 _     =  0
21:59:45 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
22:00:01 <Peaker> @type (gcd, lcm)
22:00:02 <lambdabot> forall a a1. (Integral a, Integral a1) => (a -> a -> a, a1 -> a1 -> a1)
22:00:29 <Peaker> > liftA2 (gcd &&& lcm) [1..10] [15,20]
22:00:31 <lambdabot>   Couldn't match expected type `b -> c'
22:00:31 <lambdabot>         against inferred type `(a -> ...
22:00:54 <Peaker> > liftA2 gcd [1..10] [15,20]
22:00:56 <lambdabot>   [1,1,1,2,3,1,1,4,5,5,3,2,1,1,1,4,3,1,5,10]
22:00:59 <Peaker> > liftA2 lcm [1..10] [15,20]
22:01:01 <lambdabot>   [15,20,30,20,15,60,60,20,15,20,30,60,105,140,120,40,45,180,30,20]
22:02:46 <Peaker> @let (&&&&) = (&&&) `on` uncurry
22:02:47 <lambdabot>  Defined.
22:02:59 <Peaker> > map (gcd &&&& lcm) $ liftA2 (,) [5..10] [5,.10]
22:03:00 <lambdabot>   A section must be enclosed in parentheses thus: (. 10)
22:03:14 <Peaker> > map (gcd &&&& lcm) $ liftA2 (,) [5..10] [5..10]
22:03:33 <Berengal> :/
22:03:33 <lambdabot>   [(5,5),(1,30),(1,35),(1,40),(1,45),(5,10),(1,30),(6,6),(1,42),(2,24),(3,18)...
22:04:21 <Berengal> > [(gcd x  y, lcm x y) | x <- [1..10], y <- [15,20]]
22:04:22 <lambdabot>   [(1,15),(1,20),(1,30),(2,20),(3,15),(1,60),(1,60),(4,20),(5,15),(5,20),(3,3...
22:04:52 <Peaker> not as good a golf :)
22:05:00 <Peaker> well, assuming &&&& exists :)
22:05:46 <sohum> Parsec is annoying me
22:06:09 <mercury^> @pl \f g a -> (f a, g a)
22:06:09 <lambdabot> liftM2 (,)
22:06:53 <sohum> the parse fn is :: String -> Either ParseError Sexp. the pddler is Sexp -> Either PDDLError PDDL. I'd /love/ to be able to chain those together with >>=, but Parsec insists on keeping ParseError abstract.
22:07:33 <mercury^> > liftM2 (lcm, gcd) <$> [5..10] <*> [15,20]
22:07:33 <lambdabot>   Couldn't match expected type `a1 -> a2 -> r'
22:07:33 <lambdabot>         against inferred type ...
22:08:10 <mercury^> > liftM2 (,) lcm gcd <$> [5..10] <*> [15,20]
22:08:11 <lambdabot>   Couldn't match expected type `a -> b'
22:08:11 <lambdabot>         against inferred type `(a1, a...
22:08:19 <mercury^> :(
22:08:27 <|Jedai|> [lcm, gcd] <*> [5..10] <*> [15,20]
22:08:31 <|Jedai|> > [lcm, gcd] <*> [5..10] <*> [15,20]
22:08:32 <lambdabot>   [15,20,30,60,105,140,120,40,45,180,30,20,5,5,3,2,1,1,1,4,3,1,5,10]
22:09:47 <mercury^> @pl \(f,g) a -> (f a, ga)
22:09:48 <lambdabot> flip flip ga . ((,) .) . fst
22:09:50 <b0fh_ua> Hi there! Can somebody please help me with that source code: http://pastebin.com/d7e15f018. I an trying to implement merge sort in Haskell, I created routine which merges lists using a function (zipOrder), and for some reason my mergesort just hangs
22:09:54 <mercury^> @pl \(f,g) a -> (f a, g a)
22:09:54 <lambdabot> uncurry (liftM2 (,))
22:10:10 <b0fh_ua> how can I debug or trace the sattes of list during execution of a function?
22:10:41 <b0fh_ua> *states of list
22:10:57 <mercury^> I don't see why the last example I tried does not work.
22:11:02 <Twey> b0fh_ua: Debug.Trace
22:12:48 <|Jedai|> @pl \(f,g) a b -> (f a  b, g a b)
22:12:49 <lambdabot> uncurry (liftM2 (liftM2 (,)))
22:12:58 <|Jedai|> @pl \f g  a b -> (f a  b, g a b)
22:12:59 <lambdabot> liftM2 (liftM2 (,))
22:13:19 <sohum> that, and of course ParseError in Parsec isn't an instance of Error
22:13:19 <|Jedai|> > liftM2 (liftM2 (,)) lcm gcd <$> [5..10] <*> [15,20]
22:13:21 <lambdabot>   [(15,5),(20,5),(30,3),(60,2),(105,1),(140,1),(120,1),(40,4),(45,3),(180,1),...
22:13:27 <mercury^> Ah, of course.
22:13:32 <scalaLove> I am going bottom-up for the euler #5 in Haskell, this is my first task in Haskell by the way. This is pseudo-code since i am not comortable yet, will resolve it later with the reference beside me, anyways... the questions and code for my first function is here
22:13:35 <scalaLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13678#a13678
22:14:00 <|Jedai|> mercury^: ^^
22:14:32 <scalaLove> how to translate that into valid haskell code? ^^
22:15:07 <|Jedai|> scalaLove : see function all() and mod()
22:15:15 <|Jedai|> @type all
22:15:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:15:26 <|Jedai|> @type mod
22:15:27 <lambdabot> forall a. (Integral a) => a -> a -> a
22:15:49 <b0fh_ua> how can I tell that Haskell should consider the list xs as list of integers?
22:16:10 <|Jedai|> scalaLove: also [1..20] will give you the list of integer from 1 to 20 (this syntax works for all instance of Enum)
22:17:17 <|Jedai|> b0fh_ua: You could give a signature to your function, but why integers ? The only thing that should matter to you is that you can compare them (the type of elements must be an instance of Ord)
22:19:55 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:19:56 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:19:57 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:19:57 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:19:58 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:20:00 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOGhttp://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOGhttp://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:20:01 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:20:01 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:20:03 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:20:08 <|Jedai|> b0fh_ua: anyway, the problem of your function is quite obvious if you just try to evaluate it on a small list
22:20:52 <billym13> hi
22:20:53 <|Jedai|> b0fh_ua: it is purely an algorithmic problem, you didn't identify the base case of your recursion correctly
22:21:38 <billym13> hi there
22:21:38 <billym13> hi jedai
22:21:59 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG             http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:21:59 <billym13> http://lamia-xxx.blogspot.com/ THE BEST MUSIC BLOG
22:22:38 --- mode: irc.freenode.net set +v lunabot
22:23:02 <|Jedai|> b0fh_ua: anyway, the problem of your function is quite obvious if you just try to evaluate it on a small list
22:23:05 <|Jedai|> b0fh_ua: it is purely an algorithmic problem, you didn't identify the base case of your recursion correctly
22:23:30 <scalaLove> Axman6 problem will solve soon? :(
22:23:43 <Axman6> yes, i think it's over now
22:24:31 <b0fh_ua> |Jedai|: well, I know that the problem is with my code - not with the haskell :)
22:24:42 <b0fh_ua> I just trying to find out what's wrong there
22:24:58 <|Jedai|> b0fh_ua: think about what happens when mergesort try to sort a singleton....
22:25:31 <b0fh_ua> |Jedai|: looks like I missed the case when there is only one item in list
22:25:57 <|Jedai|> scalaLove: So, did you manage to code your function in Haskell ?
22:26:19 <scalaLove> i try :( now searching in book to make it all work
22:26:21 <b0fh_ua> |Jedai|: something like 'mergesort x:[] = [x]'
22:26:34 <b0fh_ua> this gives me the error in pattern match :(
22:26:49 <|Jedai|> b0fh_ua: Right, you can write [x] as a pattern or (x:[])
22:27:05 <|Jedai|> b0fh_ua: it lacked parens
22:27:27 <b0fh_ua> |Jedai|: thanks
22:27:32 <b0fh_ua> now it works as expected :)
22:27:43 <b0fh_ua> I simply forgot one corner-case
22:28:16 <|Jedai|> b0fh_ua: note that this is not the best way to do a mergesort in Haskell (or rather on a linked list) but you probably already know that :)
22:29:41 <|Jedai|> scalaLove: So as I said, it's just a question of assembling all() mod() and [1..20] correctly, the types can help to do that
22:30:25 <sohum> @let test :: Either a b -> Either c b; test k@(Right x) = k
22:30:26 <lambdabot>  <local>:10:53:
22:30:26 <lambdabot>      Couldn't match expected type `c' against inferred type `...
22:30:30 <sohum> heheheh
22:30:31 <lambdabot> sohum: You have 1 new message. '/msg lambdabot @messages' to read it.
22:30:32 <sohum> oh, haskel
22:32:11 <|Jedai|> sohum: well it's quite normal that it won't let you do that, since you declared that your function would take any Either a b and transform it into a Either c b...
22:32:12 <scalaLove> |Jedai| : everything correct here? if(((mod n x) == 0) where x = [1..20]) 1
22:32:44 <|Jedai|> scalaLove: where is not a looping construct (there are no loops in Haskell)
22:32:46 <scalaLove> n is parameter of function by the way from previous line isDivisible(n, start, end)
22:33:08 <scalaLove> actually in the brackets there is suposed to be [start..end] not [1..20]
22:33:24 <sohum> |Jedai|: that's not the important part. I've specifically pattern matched against the (Right k) bit, which is the same in both cases.
22:34:29 <|Jedai|> scalaLove: ok, this time I'll give you the solution : isDivisible n start end = all (\x -> n `mod` x == 0) [start..end]
22:35:12 <|Jedai|> sohum: right, but Haskell has no way to check that :)
22:35:42 <|Jedai|> sohum: just use "Right . fromRight" or something like that
22:35:49 <sohum> |Jedai|: yep, I know :) it just amuses me is all
22:36:22 <scalaLove> |Jedai| what is the "\" in "\x"
22:36:32 <|Jedai|> sohum: you could use unsafeCoerce in this case, it would be perfectly safe there (apart from the normal problems of partial functions)
22:36:43 <Axman6> scalaLove: a lambda
22:37:13 <scalaLove> so it is same as saying let x in ?
22:37:16 <|Jedai|> scalaLove: (\x -> expression) is an anonymous function and (\ is the closest you can get from a lambda on a standard keyboard
22:37:20 <Axman6> no
22:37:26 <b0fh_ua> |Jedai|: Can you please take a look at http://pastebin.com/d5798477 and please tell me - is it possible to make the code to look better? Also - I don't really know how to implement merge sort in haskell in the better way :)
22:37:38 <Axman6> > (\x -> x + 1) 4
22:37:39 <lambdabot>   5
22:37:42 <Axman6> > (\x -> x + x) 4
22:37:43 <lambdabot>   8
22:37:48 <Axman6> > (\x -> x ^ x) 4
22:37:49 <lambdabot>   256
22:38:06 <Botje> zipOrder is commonly called "merge" :)
22:38:07 <sohum> :t unsafeCoerce
22:38:09 <lambdabot> Not in scope: `unsafeCoerce'
22:38:19 <sohum> |Jedai|: it sounds scary :(
22:38:20 <Axman6> a -> b
22:38:27 <Axman6> @hoogle a -> b
22:38:27 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:38:27 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:38:27 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
22:39:00 <Botje> b0fh_ua: you can drop line 2 because line 3 already handles it
22:39:02 <|Jedai|> b0fh_ua: too much cases in zipOrder (== "merge")
22:39:11 <scalaLove> Axman6: (\x -> x + 1) 4 basically means: f(x) = x+1, and then replace x with 4, correct?
22:39:31 <Axman6> scalaLove:  yes. it's an annonymous function, a function with a name
22:39:47 <Axman6> scalaLove: you can write f x = x + 1 as f = \x -> x + 1
22:39:53 <Botje> b0fh_ua: you don't need the == True for zipOrder
22:39:58 <chrisdone> wooooo procrastinaaaation
22:40:01 <Axman6> giving a name to an annonymous function
22:40:26 <b0fh_ua> really
22:40:29 <chrisdone> (==True) is only ever useful as a function
22:40:49 <Botje> b0fh_ua: and in the otherwise case, you can do x:y:zipOrder f xs ys
22:40:54 <chrisdone> it makes me rage when I read "if x == True then"
22:41:19 <|Jedai|> b0fh_ua: also, splitting the list in two like you do is innefficient (and you must calculate the length every time too, it's an O(n) operation) it's better to directly split the lists in singleton and so several pass on that to merge adjacent sublist until you get only one sublist
22:41:28 <Axman6> chrisdone: my favourite when we were learning haskell was: f x = if x == True then True else False
22:42:16 <Botje> hey, that's \x -> x `seq` x !
22:42:46 <Axman6> i wonder if ghc would optimise that completely
22:43:02 <|Jedai|> b0fh_ua: by the way, your merge function should either takes a comparison function (that returns an Ordering) or just have two guards in your fourth clause since you do the same for two of your guards
22:43:14 <b0fh_ua> |Jedai|: so you suggest to split entire list in list of lists
22:43:30 <chrisdone> Axman6: what the hell :D
22:43:51 <b0fh_ua> I thought in implementing mergesort as it is done in imperative way when middle of a list is passed to the recursively called function
22:43:56 <|Jedai|> Botje: Yes but only for Bools :)
22:43:58 <chrisdone> Botje: yeah (\x -> x `seq` x) :: Bool -> Bool
22:44:00 <Axman6> chrisdone: if you need more procrasternation fuel, help out be adding to http://en.wikipedia.org/wiki/Haskell_(programming_language) :)
22:44:12 <scalaLove> |Jedai| but does does not return a value like 1 or 0? :( isDivisible n start end = all (\x -> n `mod` x == 0) [start..end]
22:44:28 <scalaLove> or maybe if calculation goes well it returns 1 and 0 otherwise?
22:44:28 <chrisdone> Axman6: is it in need of additions?
22:44:35 <Axman6> very much so
22:44:44 <Axman6> scalaLove: no!
22:44:55 <|Jedai|> scalaLove: it returns a boolean, Haskell does not think 1 and 0 are booleans
22:44:55 <Botje> scalaLove: it returns true or false ..
22:45:03 <Axman6> we use True and False for boolean values
22:45:27 <scalaLove> yeah same thing, all it matters is it returns, not let me figure out WHY it returns :)
22:45:44 <Axman6> well, it does matter ;)
22:45:48 <|Jedai|> scalaLove: "all predicate list" evaluates to True only if "predicate" evaluates to True when applied to all elements of the list
22:46:04 <|Jedai|> @src all
22:46:05 <lambdabot> all p =  and . map p
22:46:12 <|Jedai|> @src and
22:46:13 <lambdabot> and   =  foldr (&&) True
22:46:21 <scalaLove> |Jedai| wow how cool is that, i will quit imperative soon :D
22:46:48 <Axman6> this is haskell, we use the right types for the right situations. no int return codes where they make no sense
22:46:50 <chrisdone> pattern matching kind of avoids the need for that hackish polymorphic `if' that you get in perl, python, javascript, ..
22:47:55 <|Jedai|> scalaLove: and in case you were wondering it does "early return" if there is one element for which the predicate evaluates to False. It doesn't use any special syntax for that, lazy evaluation just makes it happen naturally.
22:48:51 <chrisdone> |Jedai|: did you know that in Visual Basic `and' and `or' do not short-circuit? =)
22:49:00 <|Jedai|> chrisdone: Yes :(
22:49:03 <acieroid> I'm reading « The Haskell School Of Expression » and I'm using ghc on GNU/Linux, what graphics library can I use to run the examples ? (I tried hgl but it seems to use the old exceptions system)
22:49:05 <Axman6> :O
22:49:08 <Botje> no, but andalso and orelse, do :P
22:49:16 <chrisdone> |Jedai|: I found out after much confusion and rage
22:50:11 <scalaLove> |Jedai| lazy evaluation calculated a value only when needed, so once it sees a number not divisible it will stop? :(
22:50:12 <|Jedai|> chrisdone: that's usually the case for programmer accustomed to sane language that try their hand at VB
22:50:28 <chrisdone> not only am I contending with a codebase full of global variables all over the place, I discover its `and' syntax has a perverse semantics
22:50:35 <|Jedai|> scalaLove: I don't see why that makes you sad
22:50:36 <scalaLove> acieroid i was reading the same book today got 100 pages from there it is cool book :)
22:51:02 <scalaLove> |Jedai| I am so happy that i will cry how wonderfull it is :D
22:51:12 <scalaLove> it is happy tears as they say :D
22:51:23 <medfly> guys, ever since I was brutally forced to use less sane languages, I've been missing Haskell
22:51:26 <chrisdone> funny, I was just reading about crying and how people cry when they're happy
22:51:33 <|Jedai|> scalaLove: but your explication is a little bit short, in fact it is because of the way (&&) and foldr() are defined that you get this "early return" behavior
22:51:37 <chrisdone> medfly: what are you forced to use?
22:51:38 <|Jedai|> @src (&&)
22:51:39 <lambdabot> True  && x = x
22:51:39 <lambdabot> False && _ = False
22:51:42 <medfly> chrisdone, PHP.
22:52:09 <chrisdone> medfly: haha. I didn't see that coming. I was thinking more like C# or java, but that takes the biscuit
22:52:21 <|Jedai|> scalaLove: as you can see (&&) only needs the value of its second argument if its first is True
22:52:25 <chrisdone> while you're at it, why don't you use cobol?
22:52:25 <|Jedai|> @src foldr
22:52:26 <lambdabot> foldr f z []     = z
22:52:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:52:30 <medfly> to be honest I don't mind so much, but there are some parts of it that are ridiculous.
22:52:43 <chrisdone> hey, thousands of people use cobol, what's your problem!?!‽
22:53:01 <|Jedai|> scalaLove: and foldr() only needs to execute on the tail of the list if the passed function needs the value of its second argument
22:53:03 <scalaLove> |Jedai| yes i need that behaviour, once a number is found that is not divisible, i will get another one from an outer loop and test that one, a divisible will not have early exit so this behaviour is perfect
22:53:12 <Axman6> next you'll be dissing Ada chrisdone
22:53:21 * Axman6 advises against this
22:53:28 <chrisdone> I don't know anything about Ada
22:53:30 <knobo>     Occurs check: cannot construct the infinite type: a = [a]\    When generalising the type(s) for `myfun'
22:53:40 <knobo> There is not much to go on :(
22:53:49 <medfly> what are you doing knobo
22:53:55 <Axman6> knobo: means you've done something wrong :)
22:54:09 <scalaLove> |Jedai| i dont see why i would use fold, wait, i am tryin something will be back in min
22:54:10 <knobo> hmmm... let me see if there is something wrong.
22:54:16 <knobo> ;)
22:54:18 <chrisdone> probably got something like 2 : 1
22:54:26 <chrisdone> > 2 : 1
22:54:28 <lambdabot>   No instance for (GHC.Num.Num [t])
22:54:28 <lambdabot>    arising from the literal `1' at <inter...
22:54:33 <chrisdone> nah
22:54:35 <|Jedai|> scalaLove: foldr() is used by all()
22:54:38 <|Jedai|> @src all
22:54:39 <lambdabot> all p =  and . map p
22:54:40 <Axman6> > [1] : [3]
22:54:41 <lambdabot>   No instance for (GHC.Num.Num [t])
22:54:41 <lambdabot>    arising from the literal `3' at <inter...
22:54:41 <|Jedai|> @src and
22:54:41 <lambdabot> and   =  foldr (&&) True
22:54:51 <chrisdone> > f x = x : x
22:54:53 <lambdabot>   <no location info>: parse error on input `='
22:55:03 <chrisdone> :t f x = x : x in f
22:55:05 <lambdabot> parse error on input `='
22:55:07 <Axman6> :t let f x = x : x  in f
22:55:08 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
22:55:08 <lambdabot>       Expected type: [a]
22:55:08 <lambdabot>       Inferred type: a
22:55:09 <scalaLove> |Jedai| i need know that yet , i guess
22:55:11 <chrisdone> there we go
22:55:11 <medfly> hurrah!
22:55:15 <medfly> Axman6 wins the competition!
22:55:16 <chrisdone> that's probably the error
22:56:04 <chrisdone> unification: phail
22:56:06 * medfly bets on knobo mistyping xs a x
22:56:07 <|Jedai|> scalaLove: and that's why you have early return. Basically, for most of the Haskell function in the standard library, they'll try to be as lazy as possible, working on infinite lists is a side benefits
22:56:13 <knobo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13683#a13683
22:57:21 <scalaLove> |Jedai| oh i see what you saying now, the second argument is a list, so if  the first is false, the second wont be checked
22:57:47 <|Jedai|> Nlist a = [(Integer,[a])] should probably be Nlist a = [(Integer,a)]
22:57:55 <Axman6> knobo: buildTree n [] = ([],[]) -- is that first thing anb Nlist a like the type says it should be?
22:58:05 <Axman6> oh, yes, it is, heh
22:58:54 <knobo> type Nlist a = [(Integer,[a])]
22:58:54 <scalaLove> i save this in file and execute from terminal why it gives me error?
22:58:56 <scalaLove> main = do
22:58:58 <scalaLove> 	isDivisible n start end = all (\x -> n `mod` x == 0) [start..end]
22:59:00 <|Jedai|> scalaLove: whatever, don't worry about it for now, you should get it when you try to define infinite list and function on them yourself, later on
22:59:13 <knobo> aha..
22:59:24 <|Jedai|> scalaLove: you just put a definition in a do-block
22:59:28 <knobo> nope..
22:59:35 <knobo> I don't get it.
23:00:06 <|Jedai|> scalaLove: and there's nothing else in the block, what did you want your program to do ?
23:00:07 <knobo> Jedai: maybe. It is a string
23:00:21 <|Jedai|> knobo: You don't need to know that in your program
23:00:28 <knobo> atleast it compiled.
23:00:33 <|Jedai|> knobo: or rather in this particular function
23:00:35 <scalaLove> to "load" the function in memory so i can play with it in ghci
23:00:38 <knobo> :)
23:01:07 <knobo> thanks :)
23:01:08 <|Jedai|> scalaLove: just put the declaration on the top-level, and don't create a main() yet if you don't have anything to put in it
23:01:46 <scalaLove> yes but i get this error like that Not in scope: `Main.main'
23:02:10 <|Jedai|> scalaLove: Put "main = undefined" then
23:02:33 <uochem> for what it's worth, I've been doing the haskell thing for a month or so. brute force euler5 took me >30mins to write and "beautify" (SLOW). the 18 char nice and fast version took all of 2 minutes.
23:02:56 <scalaLove> uochem woooow, i am on euler #5 now too
23:02:57 <chrisdone> `undefined' is one of the great Haskell tools
23:03:27 <scalaLove> got the algorithm, i am now searching answers for the syntax
23:03:30 <Saizan> uochem: did you use a reasonable algorithm?
23:03:35 <|Jedai|> scalaLove: Ok, you don't need to put a main() normally, what do your script looks like ?
23:03:57 <scalaLove> just this line : isDivisible n start end = all (\x -> n `mod` x == 0) [start..end]
23:04:15 <scalaLove> i tried as u told me with main=undefined but still same error
23:04:26 <chrisdone> @pl (\x -> n `mod` x == 0)
23:04:27 <lambdabot> (0 ==) . (n `mod`)
23:04:29 <scalaLove> actually  wait
23:04:38 <scalaLove> this time is ok, let me test it
23:04:56 <chrisdone> does GHC inline '.'?
23:05:05 <uochem> well i did a dumb check everything brute force first. then the not-brain-dead version
23:05:21 <|Jedai|> chrisdone: probably
23:05:23 <scalaLove> |Jedai| command not found :(
23:05:34 <|Jedai|> scalaLove: what command ?
23:05:37 <scalaLove> after isDivisible 40 1 20
23:06:00 <|Jedai|> scalaLove: ghci won't tell you that, you're still in your shell...
23:06:45 <scalaLove> i am so sorry, i gota getmyself soon some editor :( sorry again
23:07:25 <scalaLove> ah shit, Not in scope: `isDivisible'
23:07:33 <|Jedai|> Ok, just put "isDivisible n start end = all (\x -> n `mod` x == 0) [start..end]" in a Euler5.hs file, then "ghci Euler5.hs" on your command line (in the right directory) and you're in business
23:08:03 <scalaLove> let me try it cant wait wohooo
23:08:19 <|Jedai|> scalaLove: or you start ghci, then load your script with ":load yadayada/Euler5.hs"
23:08:30 <syzygy> is there a function to turn an element into a singleton tuple, like 42 becomes (42)?
23:08:34 <|Jedai|> scalaLove: Are you using an IDE ?
23:08:46 <scalaLove> nah, ubuntu terminal :(
23:09:25 <|Jedai|> syzygy: No, since there is no "singleton tuple", you can tell than any type is a singleton tuple if that suit you or you can use the type "data Box a= Box a"
23:10:12 <|Jedai|> scalaLove: ok, so does it works if you do exactly as I've told ? (Are you familiar with linux shell ?)
23:10:26 <scalaLove> yes it does now :) i am happies guy
23:10:26 <syzygy> Jedai: There is not singleton tuple?
23:10:46 <|Jedai|> syzygy: No, why would there be, what would be the use ?
23:10:55 <scalaLove> function returns false, anyone knows solution number for euler #5 so i can try if it will return true?
23:11:20 <|Jedai|> scalaLove: just try the solution they give for 1 to 10
23:11:51 <scalaLove> ok
23:12:17 <Axman6> they usually give you some example working inputs you can test your code with
23:12:27 <mercury^> scalaLove: that problem is easy enough to do by hand in less than a minute. Why use haskell?
23:12:31 <scalaLove> oh my gooooooood it works : isDivisible 6 1 3 returned true :) :) :D
23:12:37 <|Jedai|> mercury^: To learn Haskell ?
23:13:23 <syzygy> in this code http://pastebin.com/m5b3997b3 (from Yi) is the 'driver' function declared on line 42?
23:13:25 <scalaLove> i learn new language by implementation not by reading
23:14:08 <mercury^> > foldl1 lcm [1..20]
23:14:10 <scalaLove> mercury i know what solution you mean, but that is a formula i like it more like this so i can think it not just enter the formula
23:14:10 <lambdabot>   232792560
23:14:33 <medfly> scalaLove, RIGHT ON BROTHER!
23:14:43 * medfly high fives scalaLove 
23:14:47 <ray> cool, i found my project one-liner one-liners
23:16:18 <syzygy> help?
23:16:28 <medfly> with?
23:16:33 <medfly> oh
23:16:58 <Axman6> syzygy: its type is
23:17:21 <mercury^> syzygy: why do you want a tuple with a single entry?
23:17:49 <ray> @hackage onetuple
23:17:49 <lambdabot> http://hackage.haskell.org/package/onetuple
23:17:56 <knobo> |Jedai|: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13640#a13684
23:18:06 <ray> @hackage OneTuple
23:18:07 <lambdabot> http://hackage.haskell.org/package/OneTuple
23:18:07 <knobo> |Jedai|: it works :)
23:18:08 <ray> even
23:18:28 <syzygy> in line 42, HConf driver yi restart = getHConf defaultHConfParams Yi.Config.Default.defaultConfig initState, why is it legal to have the name of another function (driver) as a function parameter?
23:18:28 <Phyx-> > fixpoint
23:18:29 <lambdabot>   Not in scope: `fixpoint'
23:18:30 <Axman6> do any other compilers support STM?
23:18:33 <filcab42> Hi all
23:18:42 <Phyx-> @type Data.Function.fixpoint
23:18:44 <lambdabot> Not in scope: `Data.Function.fixpoint'
23:18:51 <mercury^> It's called fix.
23:19:13 <knobo> but it's not pretty..
23:19:24 <Phyx-> mercury^: ah right
23:19:31 <Phyx-> @type fix
23:19:33 <lambdabot> forall a. (a -> a) -> a
23:19:38 <Phyx-> yup, that's it
23:19:52 <Axman6> syzygy: that's a really rather ugly way to do things imo :(
23:20:26 <syzygy> axman6: what does line 42 declare? a constructor, a function, or multiple functions?
23:21:03 <Axman6> the type of driver, which is then defined in the HCons line below.
23:21:41 <syzygy> but isn't the type of driver declared on line 39?
23:22:10 <Axman6> so, something like: a :: Int, Just a = lookup 3 (zip [0..] [1,4,2,6,3,7]) would set a  to 6
23:22:39 <Axman6> syzygy: uh, yeah
23:22:46 <Axman6> didn;t have the code iopen anymore :)
23:23:07 <syzygy> i thought Just a = ... would be a constructor for Just, with a as a parameter?
23:23:25 <filcab42> syzygy: It can also be a type constructor
23:24:09 <Axman6> you know how you can say f xs = ... where (ys, zs) = splitAt 4 xs, to give names to the elements of the tuple? well this is doing the same thing, but on a glabal level
23:25:15 <syzygy> in that case, what's the syntax used to declare a new type constructor for Just?
23:25:26 <Axman6> what?
23:28:02 <knobo> Jedai: did you see the result?
23:29:10 <uochem> re euler5, the brute force method was for learning, does it look ok? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13685#a13685
23:29:10 <Axman6> @hoogle IORef
23:29:10 <lambdabot> module Data.IORef
23:29:10 <lambdabot> Data.IORef data IORef a
23:29:10 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
23:31:20 <knobo> I have made my second haskell program :)
23:32:12 <|Jedai|> knobo: Yep, I have seen it (just now)
23:32:37 <medfly> grats knobo !!!!
23:32:50 <|Jedai|> knobo: I thought about doing something like that first in fact, but that seemed complicated to write and reread... ;)
23:33:21 <knobo> |Jedai|: Yes, it's actualy complicated :(
23:33:24 <|Jedai|> knobo: It shows that you have a background in Scheme/Lisp anyway : way too much parenthesis !!
23:33:46 <knobo> |Jedai|: Yes, I'm a lisper.
23:34:03 <knobo> I'll try to remove some of them.
23:34:18 <|Jedai|> knobo: I think with a little bit of cleaning it could be clearer (for instance avoiding to use list two times in the same clause, one shadowing the other
23:35:10 <|Jedai|> knobo: Well played anyway, it's quite the cool code ^^
23:35:33 <yitz> uochem: looks good to me - does it give you the right answer?
23:36:19 <knobo> |Jedai|: I thought about changing the name of the list list, but only after I pasted it. probably more things that could be cleaned up.
23:39:24 <scalaLove> |Jedai| I am really confused. I have this function isDivisible n start end = all (\x -> n `mod` x == 0) [start..end] that returns true if a number is divisible with all numbers from start to end. The euler problem is to FIND the smallest number divisible with all numbers from 1 to 20. So far, I can test for only one number, but how to test for these numbers [20..100000] which one of those...
23:39:26 <scalaLove> ...isDivisible with all numbers from [1..20] and when it finds it and returns true how to stop calculation and just print the found number? :(
23:39:59 <|Jedai|> scalaLove: You can use find for instance
23:40:03 <|Jedai|> @type find
23:40:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
23:40:49 <Axman6> scalaLove: find (\n -> isDivisible n 1 20) [20..]
23:40:52 <uochem> yitz: yes =)
23:41:36 <|Jedai|> scalaLove: it will probably be quite slow though... This is brute force after all !
23:41:52 <scalaLove> i know :) the point is problem solving
23:42:01 <scalaLove> pure masochism
23:43:01 <uochem> scalaLove, |Jedai|: Just ran my brute force one. didn't time it, but took about 2 minutes to run
23:44:06 <scalaLove> uochem u on 5 too ? awesome? i am going one by one now i will have the first 5 solved, 4 in scala, now one in Haskell with help from these lovely people i would one day hopefully get to buy them at least a bear :)
23:44:33 <aavogt> > product [1..20]
23:44:34 <lambdabot>   2432902008176640000
23:44:36 <|Jedai|> uochem: Right, that's quite slow :) Of course in some languages this solution would be even slower but still...
23:45:31 <aavogt> why search so many numbers, when you know that your answer is a factor of that number?
23:45:40 <uochem> scalaLove, |Jedai|: i have a headstart on haskell -- but i'm not at the point where i can just get stuff done yet, haha. lotsa fun though
23:45:52 <yitz> scalaLove: use your test function to filter an infinite list of numbers, resulting in an infinite list. then just take the head of it.
23:46:14 <yitz> scalaLove: you don't have to worry about stopping the calculation, because it never started. haskell is lazy.
23:46:43 <scalaLove> yitz i dont understand that so i will keep to what i know so far
23:46:56 <mornfall> scalaLove: Wouldn't it be faster to do that on paper? : - )
23:47:27 <yitz> scalaLove: that's haskell. and it's not hard to understand, really. just remember that haskell is *not* scala. clear your mind of all that.
23:47:31 <scalaLove> mornfall: thats not the point, i learn haskell so ... transiting to functional so...
23:47:48 <scalaLove> yitz yeah it is pure it takes time to adapt i guess
23:48:10 <yitz> scalaLove: beginners who first learn haskell don't have this problem. :)
23:48:10 <Axman6> scalaLove: how are you learning haskell by the way?
23:48:30 <scalaLove> reading books
23:48:45 <scalaLove> but this is second day in haskell so i mix it with scala :(
23:48:56 <scalaLove> and use reference a lot
23:50:08 <scalaLove> what is this error? Not in scope: `find'
23:50:10 <scalaLove> Failed, modules loaded: none.
23:50:53 <yitz> @index find
23:50:54 <lambdabot> Data.List
23:51:03 <scalaLove> import it , ok
23:51:45 <scalaLove> works yeii thanks
23:51:56 <scalaLove> @index mod
23:51:56 <lambdabot> Prelude
23:51:57 <yitz> \o/
23:51:57 <|Jedai|> knobo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13640#a13687
23:52:15 <|Jedai|> knobo: What I would do to clean it
23:52:39 <knobo> |Jedai|: Nice :)
23:53:15 <knobo> |Jedai|: When things looks complicated, there is always something wrong in the code...
23:53:46 <knobo> |Jedai|: I tested it on a big file, and it did not do it correct...
23:54:11 <|Jedai|> knobo: right, the EQ case seems a bit suspect to me
23:54:37 <knobo> |Jedai|: exactly
23:54:50 <scalaLove> hmm... find (\n -> isDivisibleOne n start end) [20..] does n here go from 20 to infinity? Does the number thay you say \x and for x it means to go from 20.. ?
23:55:45 <yowgi> scalaLove, yes
23:55:58 <aavogt> flip your parameter order to put n last
23:56:11 <yowgi> find will return as soon as it finds one or reaches the end of the list
23:56:12 <aavogt> then you can write   find (isDivisibleOne start end) [20..]
23:56:17 <yitz> scalaLove: \x -> ...stuff is a function that maps x to stuff. find takes that function, and applies it to each element of the list.
23:56:28 <Axman6> would someone mand taking a look at the ST and STM monad sections i've added to http://en.wikipedia.org/wiki/Haskell_(programming_language)#Monads_and_input.2Foutput ? i'm sure they can be improved upon, but i think it's a fairly decent start
23:56:48 <yitz> until it finds one that returns True.
23:57:39 <scalaLove> yitz does not that "all" do? i thought find should get the number when calculation stops? or it will jus get true when a divisible number is found? so how to get that number that once it is found?
23:57:57 <aavogt> scalaLove: the same algorithm works in a reasonable time when you've written it before?
23:57:59 <yitz> @src find
23:57:59 <lambdabot> find p          = listToMaybe . filter p
23:58:20 <yitz> scalaLove: listToMaybe is a way of taking the first element of a list
23:58:26 <yitz> @src listToMaybe
23:58:26 <lambdabot> listToMaybe []        =  Nothing
23:58:27 <lambdabot> listToMaybe (a:_)     =  Just a
23:58:29 <scalaLove> aavogt-first time on euler project first time euler #5 but not first time problem solving
23:59:23 <aavogt> I have doubts that your code will finish in a reasonable amount of time... but maybe I'm wrong
