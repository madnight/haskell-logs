00:00:03 <copumpkin> shh
00:00:06 <phr> jonno, yeah
00:00:07 <Jonno_FTW> mine took 0.2seconds
00:00:13 <Jedai> phr: just test the order of d and n in factors'
00:00:15 <Jonno_FTW> and a lot less code
00:00:41 <Jonno_FTW> answer = head [a|a<-(zip trians $ map numDivisors trians), snd a > 500]
00:00:45 <phr> hmm
00:00:50 <Jonno_FTW> that's how i did it
00:00:55 <Jonno_FTW> it has 576 factors
00:00:58 <copumpkin> Jonno_FTW: only a lot less code because you didn't write the facotrization code :P
00:01:05 <Jonno_FTW> ssh
00:01:07 <Jonno_FTW> shh
00:01:10 <copumpkin> and faster because you used sophisticated factorization code :P
00:01:18 <Jonno_FTW> those are the handiest modules ever
00:01:26 <Jonno_FTW> i could write my own factorisation
00:01:36 <Jonno_FTW> but it would be so naive as to take forever
00:01:42 <phr> i'm trying to understand what jedai is saying about factors'
00:01:43 * copumpkin slurps some ramen
00:01:52 <copumpkin> does that make me an undergrad again?
00:02:02 <phr> jonno, most of those euler problems sort of revolve around factoring...
00:02:12 <Jonno_FTW> yeah....
00:02:20 <Jonno_FTW> not all of them
00:02:26 <Jonno_FTW> some of them are about text
00:02:53 <phr> how do i get rid of candidates, i.e. when do i get to stop trial division if n happens to be prime?  though, for triangle numbers i guess that never happens
00:03:37 <Jonno_FTW> guards?
00:04:01 <phr> oh, i see
00:04:02 <phr> yeah
00:04:07 <Cale> phr: If n has no nontrivial factors whose square is less than or equal to n, then n is prime.
00:04:36 <copumpkin> less than
00:04:40 <copumpkin> oh I guess or equal
00:05:33 <Cale> If p is prime, then n = p^2 isn't prime, but has a nontrivial factor p whose square is equal to n :)
00:05:40 <copumpkin> :P yep
00:06:15 <phr> wow, that sped it up by 6x
00:06:17 <phr> that's crazy
00:06:42 <phr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14145#a14146
00:06:43 <copumpkin> 6x just for that one, too
00:06:46 <copumpkin> it's not linear
00:07:12 <phr> that is too much speedup, it's still basically the same algor
00:07:35 <phr> oh i understand
00:07:40 <phr> yeah i was going right up to sqrt n
00:07:50 <phr> instead of sqrt of what was left after chopping found factors
00:08:01 <phr> so this really is a speedup
00:08:02 <phr> thanks jedai
00:11:47 <phr> well, cool, i have family visiting and this is the first time i've been able to write any code at all since they got here
00:18:27 <dancor> .oO(has anyone said "i wish i'd coded more" on their deathbed)
00:19:15 <vegai> dancor++
00:19:51 <phr> heh
00:20:35 <copumpkin> dancor: do you know someone whose last name is bharambe?
00:20:35 * BMeph plans to...provided he's able to say anything "on his deathbed"...
00:20:59 <dancor> not yet
00:22:43 <copumpkin> he's back!
00:22:47 <dancor> @vixen Give us your best deathrattle.
00:22:48 <lambdabot> hahaha.
00:22:59 <HaskellLove> i am back?
00:23:07 <copumpkin> yep
00:23:31 <HaskellLove> u guys talked about me? i went to bed a litle :)
00:23:49 <copumpkin> that was very little!
00:23:58 <copumpkin> we didn't talk about you, I just noticed you'd left and then that you came back
00:24:06 <c_wraith> ping times consistently above 5 seconds.  I wish I understood how that's possible.
00:24:41 <HaskellLove> anyways... will this work here: takeWhile 10 (sum bla bla) http://projecteuler.net/index.php?section=problems&id=13 ? why do i feel there is a catch 22 here?
00:24:55 <Heffalump> c_wraith: an intermediate router with a very big backlog?
00:25:19 <HaskellLove> wow we got networks guys here :) it is my most hated subject at cs
00:25:20 <Jonno_FTW> Haskell love
00:25:41 <Jonno_FTW> if you are going to do it naively, use take 10 $ show $ sum numbers
00:25:53 <Jonno_FTW> but there is a much better way
00:26:04 <copumpkin> HaskellLove: that one's utterly trivial in haskell
00:26:09 <Jonno_FTW> yep
00:26:14 <HaskellLove> Jonno_FTW>	i knew it :D but cant see that other way
00:26:15 <Jonno_FTW> also trivial maths
00:26:21 <Jonno_FTW> well
00:26:28 <Jonno_FTW> do you mind me telling?
00:26:38 <HaskellLove> i would love to actually
00:26:55 <Jonno_FTW> you only need the first 10 digits right
00:27:05 <HaskellLove> of the sum... yes
00:27:07 <Jonno_FTW> so you only the sums of the first 10 digits of each number
00:27:15 <Jonno_FTW> 11 digits to be safe
00:27:16 <copumpkin> first 11
00:27:21 <phr> i think 12?
00:27:25 <copumpkin> 50
00:27:27 <Jonno_FTW> no
00:27:32 <Jonno_FTW> 13 to be safe
00:27:37 <Jonno_FTW> so you can cut the numbers down
00:27:50 <Jonno_FTW> to their first 13 digits
00:27:51 <Jonno_FTW> so
00:28:09 <HaskellLove> why do i think that is not a solution... hmm
00:28:25 <copumpkin> you have to look at all the digits
00:28:25 <Jonno_FTW> it is  a fast way to get the solution
00:28:26 <koala_man> it's probably quicker to just sum them all
00:28:33 <copumpkin> and yes
00:29:34 <koala_man> since you know there are 100 numbers, you don't have to look at all the digits
00:29:38 <HaskellLove> sum is not that hard on the processor should be done quickly
00:30:43 <HaskellLove> i just cant get this thing properly indented chesus :D
00:31:05 <vegai> what kind of a silly joke of a language doesn't support solving that problem by brute force ...
00:31:19 <HaskellLove> vegai: exactly
00:31:34 <copumpkin> take 10 . show . sum
00:31:36 <HaskellLove> but there must be some stupid catch 22 they would not put it there like that
00:32:00 <Jonno_FTW> Computation time: 0.015600100 sec
00:32:10 <Jonno_FTW> the optimisation is rather irrelevant
00:32:26 <HaskellLove> daaah it is sum for god sake, it is like nothing for the procesor
00:32:43 <Jonno_FTW> i know
00:32:50 <phr> lots of those probs are slightly challenging if your language doesn't have bignums
00:32:54 <HaskellLove> if only i could indent the damn thing:) ...aaaa
00:33:18 <HaskellLove> phr: aha that is the catch 22 so happy us we are haskellers
00:33:32 <Jonno_FTW> just replace all the linebreaks with a comma
00:33:38 <Jonno_FTW> and put [] around it all
00:34:14 <Jonno_FTW> with the optimisation Computation time: 0.000000000 sec
00:34:19 <Jonno_FTW> HOW THE HELL?
00:34:42 <copumpkin> 14 is pretty simple too
00:35:01 <copumpkin> but nicest with an array
00:35:39 <Jonno_FTW> i used guards
00:35:43 <copumpkin> @let iter n | even n = n `div` 2 | otherwise = 3 * n + 1
00:35:46 <lambdabot>  Defined.
00:35:51 <copumpkin> iter 13
00:35:54 <copumpkin> > iter 13
00:35:55 <lambdabot>   40
00:36:58 <Jonno_FTW> 	chain n | n == 1 = [1] | rem n 2 == 0 = n : chain (n `div` 2) | otherwise    = n : chain (3 * n + 1)
00:37:10 <HaskellLove> damn this thing keeps showing indentation errors... i am gonna rape myself..
00:37:22 <Jonno_FTW> are you doing 12 still?
00:39:58 <HaskellLove> Jonno_FTW 12 killed my head i got frustrated i wont work on it today... i wanna solve 13 and make myself happy, but i cant do even that indentation errors aaaaa
00:41:48 <HaskellLove> Jonno_FTW can u send me your file with tha integer to try it? maybe on rapidshare or something?
00:42:10 <copumpkin> @hpaste
00:42:10 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
00:42:38 <copumpkin> > iterate iter 13
00:42:39 <lambdabot>   [13,40,20,10,5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4...
00:42:50 <endojelly> :t iter
00:42:51 <lambdabot> forall a. (Integral a) => a -> a
00:42:57 <endojelly> :t iterate
00:42:58 <lambdabot> forall a. (a -> a) -> a -> [a]
00:43:55 <Jonno_FTW> pastebin
00:44:50 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14148#a14148
00:45:29 <pastah_rhymez> HaskellLove: what is that?
00:45:48 <HaskellLove> problems... with indentation...
00:45:51 <Jonno_FTW> HaskellLove: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14149#a14149
00:46:42 <HaskellLove> oh, so u put the comma in begining of line
00:46:54 <HaskellLove> ah shit this does not work too... aaaaaaaa
00:47:18 <c_wraith> does foldr fuse with map?
00:47:49 <HaskellLove> c_wraith what do you mean? they are separate ways to traverse a list
00:48:42 <BMeph> SHort answer: Yes. Long answer: of course! ;)
00:49:00 <c_wraith> oh, good.  Then I won't uglify things by fusing manually. :)
00:53:06 * copumpkin looks forward to supercompilation
00:53:10 <HaskellLove> Jonno_FTW can you tell me the answer to euler 13, i have editor problems... indentation errors i try to fix it like half an hour
00:53:17 <copumpkin> so we won't need to rely on knowledge of what rewrite rules exist
00:53:54 <c_wraith> wait.  doesn't fusing foldr with map require being able to invert the map function?
00:53:56 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14149#a14149 is what i used
00:54:07 <Jonno_FTW> don't indent at all
00:54:38 <HaskellLove> nah i mean give me the number, the result so i enter it on euler site... yeah no indentations, and still i get errors
00:55:10 <c_wraith> foldr f z $ map g ls = foldr (f . g) (g' z) ls
00:55:30 <c_wraith> where g' is the inverse of g.   If I did that transformation properly
00:55:34 <Jonno_FTW> 5537376230
00:55:36 <copumpkin> cata-fusion!
00:56:08 <copumpkin> not sure you need the inverse
00:56:29 <HaskellLove> Jonno_FTW thanks bud...
00:56:35 <Jonno_FTW> any time
00:56:49 <copumpkin> > foldr (*) 2 . map (+1) [1,3..19]
00:56:51 <lambdabot>   No instance for (GHC.Enum.Enum [a])
00:56:51 <lambdabot>    arising from the arithmetic sequence...
00:56:54 <copumpkin> > foldr (*) 2 . map (+1) $ [1,3..19]
00:56:55 <lambdabot>   7431782400
00:57:26 <copumpkin> > foldr ((*) . (+1)) 2 $ [1,3..19]
00:57:27 <lambdabot>   7431782400
00:57:57 <c_wraith> hmm.  why am I doing that wrong, then.  >_>
00:58:48 <o-_-o> anyway to format string in haskell like in python ?
00:59:01 <copumpkin> > printf "%d %s" 5 "123" :: String
00:59:02 <lambdabot>   "5 123"
00:59:19 <o-_-o> ok..thanks
00:59:31 <o-_-o> but I don't want to do IO I want to return the string
00:59:40 <copumpkin> that's what I did
00:59:47 <c_wraith> if lambdabot did it, it's not doing IO
00:59:55 <o-_-o> oh...ok
01:00:01 <copumpkin> it's a bad name
01:00:06 <copumpkin> and it annoys me that it also exists in IO
01:00:12 <copumpkin> but hey
01:00:14 <c_wraith> should have been sprintf, clearly. :)
01:00:30 <copumpkin> just call it format
01:00:36 <copumpkin> and get rid of the IO () instance
01:00:48 <c_wraith> how would C programmers find it, then? >_>
01:01:16 <copumpkin> I'm also of the opinion that we should get rid of if
01:03:03 <vegai> yes, Haskell has too many things
01:03:07 <vegai> are they adding more in 2010?
01:03:42 <copumpkin> there are some things I want added
01:03:46 <copumpkin> and some I want removed :P
01:03:53 <copumpkin> 2010 has very few changes
01:04:52 <Twey> copumpkin: Hear, hear
01:05:05 <Twey> Replace if with ?? ;)
01:05:20 <Baughn> > (let id :: (forall id. id -> id) -> id -> id; id id = id id in id) id 5
01:05:21 <lambdabot>   5
01:05:22 <Twey> printf isn't a very good function in general…
01:05:58 <Twey> It's not nearly as powerful as Python's ‘format’
01:06:05 <Twey> Doesn't allow dictionaries, &c.…
01:06:49 <BMeph> The joke isn't funny anymore; get rid of 'return' please.
01:07:29 <Cale> BMeph: huh?
01:07:31 <Cale> :t return
01:07:32 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
01:07:41 * Baughn pokes pure
01:07:48 <copumpkin> point!
01:07:59 <Cale> I'm fine with return
01:07:59 <copumpkin> but pure is better than return at least
01:08:13 <o-_-o> so return doesn't ummm... return ?
01:08:14 <Cale> Well, perhaps move it up the hierarchy
01:08:20 <copumpkin> o-_-o: it does in one sense
01:08:21 * BMeph assures Cale that copumpkin knows what I mean... :)
01:08:32 <Cale> o-_-o: return x is the computation which does nothing except returns x
01:08:43 <Baughn> What it isn't is a command
01:08:55 <BMeph> ...except when it is. :\
01:08:56 <copumpkin> o-_-o: return _does not_ stop your function and return to your caller
01:09:03 <vegai> (-->-) == return
01:09:04 <o-_-o> copumpkin, !
01:09:15 <vegai> (that's an injection needle)
01:09:32 <o-_-o> I hope I never get to use return
01:09:32 <copumpkin> o-_-o: so you could conceivably return in the middle of your function, and it would do very little
01:09:33 <Cale> o-_-o: return v is just like any other computation you might stick into the middle of some computation -- it does nothing and produces the result v
01:09:48 <Cale> o-_-o: You typically use it at the end of a do-block or chain of actions.
01:09:54 <Baughn> o-_-o: Return is, in fact, used a /lot/
01:09:56 <o-_-o> a =  f x
01:09:58 <Gracenotes> Haskell is made of expression juice. Expressions combine.. they don't run straight through a program like a procedure
01:10:11 <copumpkin> mmm expression juice
01:10:11 <o-_-o> and f contains a return in the middle and a gets some value ?
01:10:18 <Cale> o-_-o: because the result of the action described by a do-block is the result of the last action in the block.
01:10:28 <Gracenotes> monads are a clever way of combining expressions with effects (and even those without)
01:10:30 <Baughn> Gracenotes: You see.. haskell programs are made of a series of tubes. And these tubes, each of these tubes is a function.
01:10:39 <Cale> o-_-o: Any occurrence of return in the middle of a do-block can and should be removed.
01:10:45 <o-_-o> Baughn, lol
01:10:50 <copumpkin> we should make an augmented IO+Cont monad with implicit callCC
01:10:52 <Cale> (the monad laws guarantee it)
01:11:00 <copumpkin> for ultimate friendliness to people from other languages
01:11:04 <BMeph> Baughn: ..."filled with tiny chocolate robots!" ;p
01:11:18 <Baughn> BMeph: *Lazy* chocolate robots
01:11:24 <o-_-o> Cale, ok, but you know, RWH one of the first programs has return in it and any attempt to modify it produces weird results
01:11:28 <Cale> o-_-o: You can always replace  v <- return w  in the middle of a do-block with  let v = w
01:11:36 <Cale> o-_-o: hm?
01:11:49 <o-_-o> Cale, for a beginner it is strange
01:12:02 <Cale> o-_-o: which program?
01:12:44 <o-_-o> I've forgotten, but that program was the reason I installed an IRC client and connected to this channel :-p
01:12:50 <Jonno_FTW> how can i test if all elements of a list are the same efficiently?
01:13:08 <Cale> o-_-o: Do you remember which chapter you were in?
01:13:16 <o-_-o> Cale, let me take a look
01:13:35 <Gracenotes> (null . tail . group) is one way
01:14:00 <copumpkin> that will be painful on empty lists
01:14:11 <Cale> > group []
01:14:11 <Gracenotes> hmm. group [] does not yield [[]] as I had thought
01:14:12 <lambdabot>   []
01:14:22 <Cale> null . drop 1 . group  then
01:14:26 <Gracenotes> you can replace tail with drop 1 then
01:14:53 <o-_-o> myDrop
01:14:55 <copumpkin> :t and . ap (==) tail
01:14:56 <Jonno_FTW> or how can i test if they are all unique?
01:14:56 <lambdabot>     Couldn't match expected type `[Bool]' against inferred type `Bool'
01:14:56 <lambdabot>       Expected type: a -> a -> [Bool]
01:14:56 <lambdabot>       Inferred type: a -> a -> Bool
01:15:05 <Cale> Jonno_FTW: another way is  and $ zipWith (==) xs (tail xs)
01:15:13 <o-_-o> Cale, myDrop in chapter 2
01:15:22 <Jonno_FTW> i would have done
01:15:23 <Gracenotes> that takes more time, but nub is a way to do it
01:15:28 <o-_-o> clarkb, http://book.realworldhaskell.org/read/types-and-functions.html
01:15:29 <o-_-o> er
01:15:33 <o-_-o> Cale, http://book.realworldhaskell.org/read/types-and-functions.html
01:15:36 <Jonno_FTW> length nub xs == length xs
01:15:49 <Cale> o-_-o: er...
01:15:52 * BMeph shudders
01:15:54 <clarkb> tab complete ftw
01:16:02 <o-_-o> clarkb, sorry :p
01:16:07 <clarkb> np
01:16:09 <Cale> o-_-o: The only occurrence of return there is in a piece of python code.
01:16:15 <o-_-o> Cale, grep for return
01:16:41 <o-_-o> Cale, /me goes looking
01:16:45 <Cale> okay :)
01:16:53 <Gracenotes> Jonno_FTW: you can even do nub xs == xs, which has the benefit of stopping early if a mis-match is found. might be a bit expensive for complicated structures
01:17:07 <Gracenotes> what's nub's running time? order of n^2?
01:17:07 <Twey> « Haskell doesn't have a return keyword, as a function is a single expression, not a sequence of statements. The value of the expression is the result of the function. (Haskell does have a function called return, but we won't discuss it for a while; it has a different meaning than in imperative languages.) »
01:17:15 <Cale> well, all of these stop early if a mis-match is found
01:17:20 <Cale> It's actually hard not to.
01:17:38 <Cale> Gracenotes: in general it's O(n^2), but in this case it'll be O(n)
01:17:53 <copumpkin> only if the lists is composed of identical elements
01:18:18 <Cale> oh, er...
01:18:30 <Gracenotes> one could rewrite nub to short-circuit in that manner
01:18:31 <Cale> nub xs = take 1 xs
01:18:37 <Cale> ==
01:18:42 <o-_-o> Cale, ok I can't find it, maybe I picked up the program from some tutorial on the internet
01:18:43 <copumpkin> that's nice
01:18:46 <Cale> I didn't read carefully
01:19:04 <copumpkin> > nub []
01:19:05 <lambdabot>   []
01:19:06 <Gracenotes> I think the requirement now is that all are unique
01:19:07 <Cale> o-_-o: Yeah, so I suppose it's confusing if you haven't been introduced to return in Haskell.
01:19:16 <copumpkin> :t liftA2 (==) nub (take 1)
01:19:17 <lambdabot> forall a. (Eq a) => [a] -> Bool
01:19:19 <copumpkin> tada!
01:19:20 <copumpkin> :P
01:19:28 <Gracenotes> @src nubBy
01:19:29 <lambdabot> nubBy eq []             =  []
01:19:29 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:19:44 <o-_-o> Cale, yeah then I was told not to use if then else and return in haskell until I got a bit further along
01:19:52 <Cale> oh, I see.
01:20:01 <Cale> Perhaps you had a return where one didn't belong.
01:20:12 <BMeph> Don't use if-then-else; instead, use bool! ;)
01:20:18 <o-_-o> Cale, yeah...probably
01:20:56 <Gracenotes> hm. I think the overhead of tracking the uniques might be greater than that of just nubbing the whole thing, in common cases
01:21:25 <Cale> Gracenotes: eh?
01:21:38 <copumpkin> Cale's latest nub-based one is the best!
01:22:07 <Gracenotes> may I bring your attention to "[04:14:21] <Jonno_FTW> or how can i test if they are all unique?"
01:22:14 <copumpkin> oh
01:22:18 <copumpkin> missed that
01:22:26 <Cale> ah, okay
01:22:33 <copumpkin> a nub is the best you can do if you don't have Ord
01:22:57 <Jonno_FTW> nub
01:23:01 <o-_-o> how do I put guards in a code of this forms {...;...;..}
01:23:11 <Cale> o-_-o: hm?
01:23:11 <o-_-o> s/forms/form
01:23:13 <Gracenotes> here, an Eq-by-pointer-reference might actually work if you want efficiency.
01:23:29 <Cale> o-_-o: that looks like a syntax error?
01:23:37 <Gracenotes> in GHC, that is. besides being extremely unsafe.
01:23:52 <o-_-o> http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=5311#a5311
01:23:52 <copumpkin> Gracenotes: if you use a stableName it'd be fine, but that's only if your == comparison is expensive
01:23:58 <o-_-o> can I feed this to lambdabot ?
01:24:05 <copumpkin> omnom
01:24:31 <Cale> o-_-o: oh, you just remove the newlines. No semicolons required.
01:24:38 <copumpkin> o-_-o: in general, I'd try to separate presentation from logic
01:25:13 <o-_-o> copumpkin, let me see if I understood what you said...
01:25:29 <copumpkin> > map (head &&& length) . group $ [1,1,11,1,2,2,4,15,1,1,1,4,4]
01:25:30 <lambdabot>   [(1,2),(11,1),(1,1),(2,2),(4,1),(15,1),(1,3),(4,2)]
01:26:10 <copumpkin> o-_-o: you're mixing string generation in with the basic RLE idea
01:27:35 <o-_-o> http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=5311#a5312
01:27:42 <o-_-o> how does this look ? :-)
01:28:13 <o-_-o> copumpkin, ah...ok now I understand
01:28:24 <copumpkin> it's better, although I'd just make two functions
01:28:31 <copumpkin> one that generates a "skeleton" of RLE
01:28:47 <copumpkin> and the other that takes that skeleton and puts it in the format you want
01:29:00 <o-_-o> copumpkin, ok
01:29:14 <o-_-o> I don't think I am that haskelly yet
01:29:16 <copumpkin> > [(1,2),(11,1),(1,1),(2,2),(4,1),(15,1),(1,3),(4,2) >>= uncurry replicate
01:29:16 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:29:24 <copumpkin> > [(1,2),(11,1),(1,1),(2,2),(4,1),(15,1),(1,3),(4,2)] >>= uncurry replicate
01:29:25 <lambdabot>   [2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,2,2,...
01:29:29 <copumpkin> whoops
01:29:36 <copumpkin> :)
01:29:40 <tofulivin> :t transpose
01:29:41 <lambdabot> forall a. [[a]] -> [[a]]
01:29:53 <copumpkin> > map (length &&& head) . group $ [1,1,11,1,2,2,4,15,1,1,1,4,4]
01:29:54 <lambdabot>   [(2,1),(1,11),(1,1),(2,2),(1,4),(1,15),(3,1),(2,4)]
01:30:14 <copumpkin> > uncurry replicate =<< [(2,1),(1,11),(1,1),(2,2),(1,4),(1,15),(3,1),(2,4)]
01:30:14 <lambdabot>   [1,1,11,1,2,2,4,15,1,1,1,4,4]
01:30:23 <copumpkin> not quite as lossy now :)
01:30:31 <o-_-o> heh
01:30:56 <o-_-o> copumpkin, wow...that is some amazing code
01:31:21 <tofulivin> > (i, j, k) <- i = 3, j = 6, k =5
01:31:22 <lambdabot>   <no location info>: parse error on input `='
01:31:27 <tofulivin> oop
01:31:31 <o-_-o> copumpkin, although I have not clue what this is  uncurry replicate =<<
01:31:32 <copumpkin> o-_-o: it's still instructive to write it your way, at first. But most haskellers will try to avoid using explicit recursion after a while
01:32:47 <o-_-o> copumpkin, I will note that, somehow I think when I start to look at a problem, everything looks like it needs list comprehension or recursion, it's like I have a hammer and everything starts looking like a nail.
01:33:02 <shambler> copumpkin, why?
01:33:26 <copumpkin> shambler: it's generally more concise, and recognizing the specific kind of recursion we're using can make optimizations more obvious
01:33:29 <tofulivin> backdrop 10 [1..100]
01:33:34 <Cale> o-_-o: In this case, list comprehension is not bad
01:33:45 <tofulivin> > backdrop 10 [1..100]
01:33:46 <lambdabot>   Not in scope: `backdrop'
01:33:48 <copumpkin> shambler: using map and fold next to each other, for example, GHC can spot those and fuse them together, to save map from spitting out an intermediate list
01:33:53 <o-_-o> shambler, one of the reasons I can think of, is that I have rewritten many library functions, without knowing they exist
01:34:07 <copumpkin> shambler: if you did those two yourself, independently, GHC wouldn't know (although it's getting to the point where it could figure it out)
01:34:14 <o-_-o> Cale, ok
01:34:23 <Cale> > [x | (n,x) <- [(2,1),(1,11),(1,1),(2,2),(1,4),(1,15),(3,1),(2,4)], () <- replicate n ()]
01:34:24 <lambdabot>   [1,1,11,1,2,2,4,15,1,1,1,4,4]
01:34:35 <copumpkin> shambler: but as o-_-o said, it's mostly because we abstract common patterns out all the time in haskell, and most explicit recursion fits patterns
01:34:56 <tofulivin> @ let backdrop n xs =  n 'times' init $ xs
01:35:00 <kmc> indeed.  any "design pattern" is a function or macro waiting to be written
01:35:17 <tofulivin> @let backdrop n xs =  n 'times' init $ xs
01:35:17 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=14 - 1. Get lists of lists such that they contain all chains for numbers from 0 to 1 000 000. Then map length to each, and then with maximize get the biggest one, and from that one pull the first element, the starter of the chain. Ok... but... i do not know how to produce ONE list for ONE number like that. any guidelines guys?
01:35:17 <lambdabot>   Improper character constant or misplaced '
01:35:28 <shambler> oh
01:35:39 <copumpkin> HaskellLove:
01:35:41 <tofulivin> 2+2
01:35:43 <copumpkin> > iterate (+1) 1
01:35:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:35:48 <tofulivin> >2
01:35:51 <copumpkin> HaskellLove: that should be enough to get you started
01:35:54 <tofulivin> >2+2
01:36:00 <copumpkin> tofulivin: needs a space
01:36:01 <shambler> I see, so it's possible for many if not most situations keep those recursions in low-level abstractions like folds and map?
01:36:08 <copumpkin> shambler: yep
01:36:11 <tofulivin> > 2+2
01:36:12 <lambdabot>   4
01:36:21 <copumpkin> shambler: someone compared explicit recursion in functional programming to goto in imperative languages
01:36:36 <kmc> i think that's extreme
01:36:40 <copumpkin> yeah :)
01:36:46 <Jonno_FTW> it's fantastic to see on the PE forums that you have written something faster than someone else
01:36:52 <Saizan> well, we have high standards
01:36:53 <kmc> i quite often run into a recursive function which is not clearly a map or a fold
01:37:05 <copumpkin> kmc: that's when you need the zygohistomorphic prepromorphism
01:37:06 <copumpkin> duh
01:37:09 <kmc> duh
01:37:27 <kmc> often you can find some kind of domain-specific recursion pattern and define it yourself
01:37:47 <o-_-o> zygohistomorphic prepromorphism...really ?
01:38:04 <copumpkin> well some of what edwardk was doing in category-extras was defining composable recursion patterns
01:38:12 <Jafet> A good time to ski.
01:38:13 <copumpkin> unfortunately it's so opaque nobody realizes that :P
01:38:19 <kmc> yeah, i haven't internalized any of that
01:38:19 <o-_-o> what in the universe, copumpkin is not making stuff up
01:38:28 <copumpkin> o-_-o: lol, unfortunately not
01:38:31 <o-_-o> there really is a zygohistomorphic prepromorphism
01:38:34 <kmc> but yeah, if you see structural patterns in the code, you are probably missing some abstraction
01:38:38 <o-_-o> I can't even pronounce it
01:38:39 <tofulivin> fmap (+1) (1,2)
01:38:47 <copumpkin> o-_-o: it's a bit of an inside joke here, but such a thing could exist
01:39:01 <tofulivin> > fmap (+1) (1,2)
01:39:02 <lambdabot>   (1,3)
01:39:18 <kmc> in Java and C++, these abstractions are programmed by writing them down in English on bits of dead tree, and distributing them to expensive macro expansion units that are made of meat.
01:39:25 <copumpkin> lol
01:39:31 <kmc> i think it's a bit inefficient
01:39:36 <copumpkin> published in books with tterns written at the end of their title?
01:40:05 <Jafet> Distributed militarily by gangs of four
01:40:05 <copumpkin> I liked conal's presentation where he remarked about the MVC separation pattern
01:40:42 <SoleSoul> Hi. After the recommendation here about LYAH and RWH I just passed the middle of lyah and I wonder: can you say what percent of Haskell is covered in lyah? After I finish it, would I know enough to code something real in Haskell?
01:41:01 <kmc> SoleSoul, you should know enough to be able to read documentation and ask intelligent questions here
01:41:04 <Jonno_FTW> if you get toward the end, there are actual things to do
01:41:06 <kmc> and that's the most difficult part
01:41:09 <tofulivin> > let f a = b a  where b (a@(z:y)) = a ++ y ++ [z] in f [1,2,3]
01:41:10 <lambdabot>   [1,2,3,2,3,1]
01:41:13 <copumpkin> SoleSoul: you will, but percentagewise you're still very low :) Haskell is a very deep language and you can keep digging forever
01:41:13 <fynn> hey, any comment about the type system of Haskell vs F# and Scala?
01:41:28 <kmc> you won't know every library on hackage or every GHC extension, but you'll have the tools to learn about them
01:41:38 <copumpkin> fynn: any particular aspects of them?
01:42:10 <kmc> fynn, Haskell has (somewhat unusually) no subtyping, while Scala has an OO-like subtyping system
01:42:11 <fynn> copumpkin: just an overview;  from my brief glance, it seemed as if they're inferior, but it's hard to pinpoint how and I need to discuss them in a meeting.
01:42:26 <SoleSoul> So can I skip RWH and move right away to library specific documentations after lyah?
01:42:36 <copumpkin> F# has very restricted subtyping I think, as polymorphic variants
01:42:41 <kmc> SoleSoul, it depends what you're doing.  RWH covers a lot more stuff
01:42:48 <kmc> does LYAH even have a monads chapter yet?
01:42:56 <Jafet> fynn, which Haskell type system?
01:42:56 <kmc> in particular, when you define a parametrized datatype in Scala, you can optionally specify covariant or contravariant subtyping with respect to the type parameter(s)
01:43:06 <copumpkin> fynn: neither of them are particularly strict about effects, and scala even lets you ask for the type of a polymorphic value
01:43:27 <SoleSoul> no, it doesn't have a monads chapter yet
01:43:42 <Jonno_FTW> coming soon!
01:43:45 <kmc> SoleSoul, monads are pretty essential for certain types of programs
01:43:54 <kmc> not just for IO; they're a general way to structure computation
01:44:00 <SoleSoul> Jonno, you write it?
01:44:00 <kmc> copumpkin, Data.Typeable? ;)
01:44:14 <Saizan> copumpkin: no parametricity for the scala guys?
01:44:15 <copumpkin> kmc: we need to add a constraint to our stuff though :)
01:44:15 <SoleSoul> kmc: thank you for your help!
01:44:16 <Jonno_FTW> heck no
01:44:18 <fynn> copumpkin: why is Scala's type inference so limited right now?  is it a core design issue, or were the compiler authors just lazy?
01:44:21 <copumpkin> Saizan: not as far as I know
01:44:35 <copumpkin> fynn: inference + subtyping = not cool
01:44:39 <Jonno_FTW> http://learnyouahaskell.com/chapters, it says down the bottom that monads are coming soon
01:44:44 <fynn> kmc: (that sounds like an advantage ;)
01:44:49 <kmc> BONUS writes LYAH
01:44:51 <copumpkin> Saizan: but I haven't actually done anything in scala so I don't really know :)
01:44:57 <copumpkin> sounds like kmc knows more about it
01:45:06 <kmc> subtyping is a theoretical pain in the ass
01:45:10 <SoleSoul> kmc: yeah, I just checked the buttom of lyah page
01:45:14 <kmc> i think it's amazing and inspirational how far Haskell has got without it
01:45:16 <fynn> copumpkin: ah, so F#'s inference is better since it restricts subtyping
01:45:36 <copumpkin> kmc: it's true that scala has no parametricity, right?
01:45:42 <kmc> parametricity of what?
01:45:42 <fynn> it's really hard to decide between all those languages :(
01:45:50 <kmc> fynn, you should learn Haskell
01:45:52 <kmc> ;)
01:45:56 <kmc> you are asking in #haskell
01:45:57 <copumpkin> kmc: you get typecase, so there's more than one a -> a function?
01:46:05 <Saizan> in F# you can't abstract over higher order types, iirc
01:46:09 <Jafet> Agda!
01:46:11 <fynn> kmc: I think I already like Haskell best, but it's nice to have non-purity for when I need it
01:46:12 <Jafet> Whoops
01:46:13 <copumpkin> ftw
01:46:14 <kmc> copumpkin, sounds likely
01:46:18 <SoleSoul> I really like Haskell so far, but it's very wide and take quite some time to learn..
01:46:19 <copumpkin> blegh
01:46:22 <kmc> fynn, when do you need it?
01:46:35 <Jafet> When he's doing gonadic IO
01:46:40 <kmc> "it's nice to be able to lie about what my program does when I need to"
01:46:41 <copumpkin> fynn: we do have restricted forms of non-purity in haskell too
01:46:50 <kmc> we have *generalized, first-class* non-purity
01:46:53 <copumpkin> only white lies
01:46:57 <copumpkin> in haskell :)
01:47:12 <Jafet> @quote randomRIO
01:47:12 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
01:47:19 <copumpkin> lol
01:47:21 <Saizan> runST copumpkin
01:47:43 <kmc> i've yet to see a convincing argument that monads are an inferior way to do IO, once you've got past the admittedly steep learning curve
01:47:56 <Jafet> Inferior to what, though
01:48:00 <kmc> perhaps the burden of refactoring non-monadic code to monadic
01:48:13 <cathper> Can I increase the stack size when running ghci?
01:48:13 <SoleSoul> who manages this channel? there is a mistake in a link on the top of the page: http://reddit.com/r/haskell"  <-- the " is part of the address by mistake.
01:48:14 <copumpkin> Saizan: Error, Quantified type variable `copumpkin' escapes
01:48:17 <kmc> inferior to allowing function evaluation to have side effects
01:48:17 <fynn> kmc: a mutable mapping ("hash-table") type for instance
01:48:32 <fynn> lots of problems are very easy to solve by passing a mapper around.
01:48:32 <Jafet> cathper, tell your system to provide a larger stack?
01:48:36 <copumpkin> SoleSoul: that's a bug in your client
01:48:41 <kmc> fynn, you'd manipulate such an object within a monad such as IO or ST or STM or State etc.
01:48:48 <kmc> there are plenty of flavors of mutable data in Haskell
01:49:00 <copumpkin> I like mint chocolate chip
01:49:09 <cathper> Jafet: Uhm, I guess the limit is the default 8M from ghc?
01:49:14 <SoleSoul> copumpkin: ok, it's webchat.freenode.net
01:49:24 <fynn> kmc: but not builtin mapper a-la Python's dict, I guess?
01:49:30 <kmc> fynn, "built-in"?
01:49:41 <fynn> i.e. included in Prelude
01:49:49 <Saizan> Data.Map ftw
01:49:49 <kmc> Prelude bah
01:49:54 <kmc> there are loads of standard modules
01:49:58 <kmc> like Data.Map
01:50:01 <Jafet> Lawl at python's builtin module
01:50:07 <Jonno_FTW> Data.List FTW
01:50:07 <Jafet> It makes no sense whatsoever
01:50:10 <fynn> Prelude does include a lot of other types
01:50:27 <fynn> anyways, cool, IDK.
01:50:55 <kmc> Data.Map defines an immutable associative container -- when you "modify" it it returns a new structure (which, as an aside about implementation, should share most of the memory with the other)
01:50:55 <fynn> it's still really hard to pinpoint the diffs between F#, Scala and Haskell
01:50:57 <HaskellLove> \x -> if 5>0 then True else False why is this wrong?
01:51:07 <kmc> HaskellLove, what
01:51:16 <copumpkin> fynn: of those, haskell is the most strict about the types
01:51:21 <Jonno_FTW> use guards HaskellLove
01:51:22 <fynn> has anyone here actually used Scala or F#?
01:51:26 <Jonno_FTW> have you read up on them?
01:51:41 <fynn> copumpkin: can you give an example?
01:51:42 <copumpkin> fynn: I've played with ocaml a bit, and F# is MS OCaml++# 2010
01:51:49 <medfly> fynn, HaskellLove loves Scala
01:51:53 <kmc> fynn, if you want true mutable map, you can put your Data.Map into an IORef, STRef, etc.
01:51:54 <medfly> so he says
01:52:00 <Jonno_FTW> f x | x >0 = True | otherwise =
01:52:02 <Jonno_FTW> False
01:52:09 <copumpkin> um
01:52:12 <copumpkin> f x = x > 0
01:52:16 <kmc> or you can use something with a less general interface but more speed, like an IOUArray or a Judy tree
01:52:17 <fynn> copumpkin: what do you think about it, then?
01:52:31 <kmc> fynn, if you don't know Haskell, it's the best of the three to learn for expanding your mind
01:52:43 <copumpkin> fynn: it's nice, but felt dirty compared to haskell (which I'd seen before trying ocaml, so I was biased)
01:52:51 <kmc> then learn the others as some kind of "middle ground"
01:53:03 <kmc> and decide what's really practical
01:53:19 <thoughtpolice> fynn: w.r.t purity, I think it really, massively pays off in the end, even if lots of people do 'want to have side effects from time to time' - the reason I like it is because it helps document what effects your code has.
01:53:22 <kmc> i think Haskell is practical, once you understand it well -- for example, once you understand how nice the support is for impure, side-effecting computations
01:53:25 <HaskellLove> fynn i have used Scala for three days and replaced it with haskell for life, or at least for 3 years
01:53:30 <fynn> kmc: I actually started learning it already. the appeal of F# and Scala is being a part of much larger echo-systems
01:53:41 <kmc> [sic]
01:53:51 <copumpkin> fynn: the community in haskell is massively helpful
01:53:55 <fynn> heh, s/echo/eco/
01:53:56 <thoughtpolice> come to think of it, the other day a coworker and I were arguing about checked exceptions, and that's why I like them in e.g. java too
01:54:02 <thoughtpolice> because it documents an effect your code has
01:54:03 <fynn> copumpkin: yeah, this channel is awesome btw
01:54:03 <copumpkin> fynn: getting jobs for it might be a lot harder :)
01:54:06 <thoughtpolice> which is good
01:54:10 <Jafet> fynn, if you have this nagging doubt about Haskell's ability to express "real-world computations", the "awkward squad" tutorial may clear it for you
01:54:17 <kmc> or RWH
01:54:18 <tofulivin> haskell can get you a ferrari
01:54:29 <kmc> fynn, are you learning a language for intellectual benefit or for getting stuff done?
01:54:38 <Jafet> Hm, is RWH beerfree?
01:54:38 <fynn> kmc: both.
01:54:41 <kmc> in the former case, never mind the library ecosystems -- that's an implementation detail
01:54:42 <Jonno_FTW> @faq can haskell get me a ferrari?
01:54:42 <lambdabot> The answer is: Yes! Haskell can do that.
01:54:45 <copumpkin> Jafet: yeah
01:54:51 <fynn> kmc: I don't like learning things that I can't use at all.
01:54:57 <Saizan> it's released with a CC license
01:55:02 <kmc> you can use Haskell for big, real-world things
01:55:10 <Jonno_FTW> Haskell is good for project euler things
01:55:15 <copumpkin> fynn: I definitely use haskell for real-worldish things, although my real world might differ from many
01:55:21 <kmc> fynn, http://www.haskell.org/haskellwiki/Haskell_in_industry
01:55:48 <Jafet> I don't think Haskell is prime for "big", although I've seen loads of "real-world" things
01:55:51 <Jafet> Like a ptrace jailer
01:55:51 <HaskellLove> fynn well if u wanna be good, u prepare yourself learning lot of things you wont use at all in future
01:55:59 <kmc> HaskellLove, don't say "u"
01:56:05 <kmc> it makes you sound like a 14-year-old
01:56:21 <HaskellLove> kmc ok man i got u
01:56:23 <edwardk> of course there are zygohistomorphic prepromorphisms. ;) copumpkin wasn't making stuff up.. i was ;)
01:56:24 <kmc> ;P
01:56:24 <thoughtpolice> fynn: practically, a language's infrastructure (e.g. libraries & tools) is critical to its usage. haskell happens to be getting pretty good at it, although there's a lot of things left to go
01:56:33 <copumpkin> HaskellLove: or if you like u a lot, u have 2 b consistent n rite urself instead of yourself
01:56:51 <HaskellLove> copumpkin :D :D
01:56:51 <kmc> i will squash u like the bug u r
01:56:53 <tofulivin> lol haskell is 2 fun
01:57:03 <kmc> PRESS 3333 IF U LIKE HASKEL
01:57:17 <shambler> :<
01:57:24 <HaskellLove> tofulivin fun? haha no fun here man, just work day and night on the dam euler haha
01:57:24 <fynn> thoughtpolice: *nod*. I guess I'll have to learn at least one of the languages above to understand the difference.
01:57:53 <kmc> fynn, i think Scala will be more interesting
01:57:57 <kmc> F# comes off as "Haskell lite"
01:58:15 <tofulivin> What do you think about Erlang?
01:58:26 <copumpkin> HaskellLove: it's also strange to see programmers write that way because the main reason writing like that emerged was for people who had impaired typing. Either on cellphones where it took extra effort to write multiple characters, or for people who were really bad at typing on computers and had to hunt for individual keys. We typically expect programmers to be able to touchtype and type pretty fast (and if you can't, I suggest yo
01:58:26 <copumpkin> everything you're doing and pick up a touch typing tutorial and force yourself to learn before doing anything else!)
01:58:26 <fynn> kmc: as much as I hate the underlying VM, F# looks pretty elegant.
01:58:37 <kmc> as does Ocaml, though they have some major features (OO, parametrized modules, extensible concrete syntax) that Haskell doesn't
01:58:42 <thoughtpolice> fynn: note that haskell is a *lot* more viable than it was, I dunno, say ghc 6.4/6.6 era? not only in GHC stability/capability but in library infrastructure - binary is the ubiquitous serialization library for haskell, and it came out in 2007
01:58:44 <fynn> and your description of it as "Haskell lite" does it justice, and is actually a compliment.
01:58:46 <phr> ndm had a somewhat unflattering blog post about f#
01:58:54 <copumpkin> fynn: if you want a really fun language, try agda :)
01:59:00 <phr> http://neilmitchell.blogspot.com/2008/12/f-from-haskell-perspective.html
01:59:01 <copumpkin> edwardk: I see you're sleeping as always
01:59:10 <copumpkin> :P
01:59:19 <thoughtpolice> I started learning a bit before then. it's come a long way in terms of packages/library support
02:00:01 <HaskellLove> Show some love to HaskellLove yeaaaah
02:00:11 <copumpkin> we do love you!
02:00:26 <thoughtpolice> better tool support would be awesome; I would seriously love if there's something out there like eclipse's Alt-Shift-R for renaming any value and applying the change consistently across an entire project
02:00:28 <HaskellLove> I love you #haskellers more
02:00:30 <thoughtpolice> (can leksah do this?)
02:00:44 <fynn> kmc: did you look at Scala seriously?  it's a kitchen-sink of language features.
02:00:48 <kmc> i did
02:01:03 <fynn> kmc: well, what did you think?
02:01:10 <thoughtpolice> tool-based refactoring could be quite nice I think
02:01:14 <edwardk> copumpkin: i might say the same to you. seeing as you're in my timezone ;)
02:01:15 <kmc> i haven't written much code in Scala.  i have read a lot about its features
02:01:28 <kmc> i think the differences between Scala and Haskell will turn out to be more interesting than the difference between F# and Haskell
02:01:45 <copumpkin> edwardk: hrrmpf! I tried to be diligent and get off IRC but then I needed to come on and didn't have the self-discipline to turn it back off! and as a result am still not done with work
02:01:49 <HaskellLove> why cant i have "if" in lambda expression?
02:01:50 <fynn> my impression was that Scala has more features, while F# is more elegantly designed.
02:02:07 <kmc> HaskellLove, you can.  what makes you think you can't
02:02:17 <kmc> did you try a minimal case of an "if" within a lambda expression?
02:02:24 <kmc> > \x -> if x then "foo" else "bar"
02:02:25 <lambdabot>   {True->"foo";False->"bar"}
02:02:29 <HaskellLove> well i try man: \x if 5>0 then True else False
02:02:34 <kmc> \x -> if ...
02:02:41 <kmc> > \x -> if 5 >0 then True else False
02:02:42 <lambdabot>   {()->True}
02:02:48 <fynn> kind of like the difference between Perl and Ruby, where the former adds features by piling up special cases, whereas the later just provides a powerful metaphor that supports multiple features in a single swoop.
02:02:49 <copumpkin> lol
02:02:54 <kmc> HaskellLove, also, "if ... then True else False" is profoundly useless
02:02:58 <copumpkin> > (5>)
02:02:59 <lambdabot>   {-3->True;-2->True;-1->True;0->True;1->True;2->True;3->True}
02:03:07 <kmc> > (0>)
02:03:08 <lambdabot>   {-3->True;-2->True;-1->True;0->False;1->False;2->False;3->False}
02:03:13 <HaskellLove> yeah man i use the -> too, just missed it here, get errors like that too
02:03:19 <copumpkin> I guess that's const True
02:03:23 <kmc> :)
02:03:29 <kmc> all numbers are less than five
02:03:33 <kmc> SmallCheck confirms it
02:03:41 <copumpkin> who needs agda
02:03:43 <kmc> @check (<5)
02:03:44 <lambdabot>   "Falsifiable, after 14 tests:\n5\n"
02:03:48 <copumpkin> damn!
02:03:50 <fynn> copumpkin: agda is a proof checker...?
02:03:56 <kmc> @check (/= 5) ==> (<5)
02:03:56 <lambdabot>   The section `GHC.Classes./= 5' takes one argument,
02:03:57 <lambdabot>  but its type `GHC.Bool....
02:04:01 <copumpkin> fynn: yeah, and programming language superficially similar to haskell
02:04:03 <HaskellLove> No instance for (Show (t -> Bool))      arising from a use of `print' at <interactive>:1:0-33 kmc
02:04:04 <fynn> is it like coq in Haskell or something?
02:04:13 <copumpkin> fynn: quite similar, but has some new ideas
02:04:29 <kmc> fynn, it's not based on "proof scripts" but rather explicitly building proofs as terms in GADT-style dependent types
02:04:38 <kmc> it also has ultra sexy unicode syntax
02:04:46 <copumpkin> and mixfix!!!
02:04:56 <fynn> interesting. btw, what's the status of Haskell being implemented on JVM or CLR?
02:05:02 <thoughtpolice> mixfix + unicode = win, that was maybe my favorite part of agda :P
02:05:03 <copumpkin> fynn: no active projects
02:05:12 <kmc> HaskellLove, you're trying to print a function.  as the error message tells you, quite explicitly
02:05:13 <thoughtpolice> fynn: difficult
02:05:14 <fynn> if I want to use the language, but need the libraries of either platform
02:05:20 <thoughtpolice> but not infeasible
02:05:23 <kmc> we can do it here because lambdabot has some tricks
02:05:28 <copumpkin> fynn: with JVM 1.7 it might be easier
02:05:46 <thoughtpolice> fynn: to  be honest however, trying to implement haskell on the CLR was the reason don syme invented F#
02:05:48 <fynn> thoughtpolice, copumpkin: interesting, I'd thought it a straightforward target to port Haskell to either platform. is it the lack of tail-calls?
02:05:54 <copumpkin> yeah
02:06:07 <HaskellLove> oh i see so you must have parameters in lambdas like :  (\x -> if x >0 then True else False)3
02:06:15 <kmc> i think implementing on CLR or JVM is not as useful or easy as providing FFI to those systems
02:06:19 <kmc> there was a CLR FFI
02:06:24 <fynn> thoughtpolice: you mean, F# is the most Haskell you can get on the CLR as a common implementation?
02:06:25 <kmc> don't know if the project is usable or active
02:06:27 <copumpkin> HaskellLove: you don't have to, but your other one wasn't a very interesting function
02:06:44 <fynn> kmc: if I'm FFing, might as well just FFI to C/++ :)
02:06:45 <HaskellLove> i know copumpkin i was just playing with lambdas and ifs
02:06:46 <kmc> HaskellLove, why on earth would you write "if x > 0 then True else False"
02:06:52 <kmc> HaskellLove, that is the same as "x > 0"
02:07:00 <copumpkin> kmc: I doubt it, as I remember seeing a GHC commit message getting rid of the traces of it in the RTS
02:07:04 <kmc> :/
02:07:11 <copumpkin> I believe
02:07:13 <shambler> I thought F# is more OCaml than Haskell
02:07:17 <copumpkin> shambler: it is
02:07:26 <thoughtpolice> fynn: don syme originally tried to get haskell on the CLR and ended up just designing F#. the primary problem he said was simply that .NET is a side-effectful, object-oriented library, and this meant mapping it to haskell which is pure and lazy was not easy and the result was not satisfactory if you wanted to use all of the .NET libs, etc
02:07:53 <fynn> thoughtpolice: *nod*, makes sense.
02:08:14 <fynn> I can see getting a toy-implementation working, but then what's the point of using .NET if you can't use the libraries.
02:09:13 <thoughtpolice> for implementation specific things: lack of tail calls is one thing, but the CLR has that. I don't know if the CLR's typing mechanism can handle higher kinded types (SPJs words,) without a possible performance impact, and on that note the JVM is completely type erased w.r.t. generics, and currently haskell wants some type info around for e.g. typeclass dispatch
02:09:26 <phr> @hoogle maxBy
02:09:27 <lambdabot> No results found
02:10:17 <fynn> thoughtpolice: very interesting, thanks for the input. another reason I was interested in F# is that it seems the language is taking off.
02:10:21 <thoughtpolice> I suppose the typeclass dispatch thing can be overcome if you have whole-program compilation; you can specialize type class method calls to eliminate the need to keep type information around for typeclass methods
02:10:31 <copumpkin> mmm
02:10:36 <copumpkin> whole-program compilation
02:10:37 <kmc> you can package a type-class dictionary with a type-erased value
02:10:39 <kmc> that's an existential
02:11:08 <kmc> GHC Haskell does not use runtime type information on values to resolve typeclasses; it uses a compile-time conversion to explicit dictionary passing
02:11:40 <kmc> copumpkin, what if our editors and compilers were coroutines :O
02:11:55 <kmc> whole-program incremental compilation
02:11:57 <thoughtpolice> kmc: ah, neat
02:12:20 <copumpkin> sounds interesting
02:12:26 <kmc> when you build a value of typeclass-constrained existential type, it will store the dictionary into the datastructure
02:12:57 * thoughtpolice thinks it would be really neat if GHC could do whole-program-compiler like things
02:13:13 <copumpkin> thoughtpolice: if pejo's work comes through we'll have some of that I think
02:13:13 <thoughtpolice> all the stuff you could hook into that would be neat :)
02:13:26 <copumpkin> I'm assuming it's hard to do supercompilation without some whole-programness
02:13:46 <HaskellLove> chain n = iterate f n               f n | n==1 = 1 | even n = (n/2) | odd n (3*n+1)         Why these lines show me indentation error when i have no indentations, i spaced them here by the way...
02:13:48 <HaskellLove> 	
02:14:03 <copumpkin> HaskellLove: you left out an =
02:14:24 <copumpkin> if you're tired you should probably go to sleep :P
02:14:30 <thoughtpolice> copumpkin: I saw an interesting patch fly by HEAD sometime, hold on
02:14:45 <HaskellLove> copumpkin I am now man just 5 more mins i gota solve 14
02:14:51 <copumpkin> :)
02:15:00 <kmc> put down the haskell crack pipe
02:15:05 <copumpkin> I know the feeling
02:15:10 <kmc> ;)
02:15:10 <copumpkin> especially with agda, damn
02:15:17 <copumpkin> it's a ****ing videogame
02:15:29 <shambler> haha
02:15:36 <HaskellLove> it is more like masacre torture haha
02:15:51 <kmc> yeah, with agda it's always just one more side quest
02:16:06 <fynn> how are people using agda?
02:16:16 <thoughtpolice> copumpkin: http://www.haskell.org/pipermail/cvs-ghc/2009-November/051339.html
02:16:20 <copumpkin> fynn: I pick random things to prove and fail at proving them
02:16:22 <fynn> it doesn't seem like it has many non-academic uses?
02:16:23 <thoughtpolice> " The -fexpose-all-unfoldings flag arranges to put unfoldings for *everything*
02:16:23 <thoughtpolice>   in the interface file.  Of course,  this makes the file a lot bigger, but
02:16:23 <thoughtpolice>   it also makes it complete, and that's great for supercompilation; or indeed
02:16:24 <thoughtpolice>   any whole-program work."
02:16:36 <copumpkin> thoughtpolice: oh nice
02:16:45 <fynn> copumpkin: heh, so you literally use it as a game.
02:17:00 <copumpkin> fynn: it could, but it's still quite young and is evolving a lot
02:17:06 <copumpkin> fynn: but yeah, for me it's a very educational puzzle
02:17:13 <kmc> fynn, in theory it would be great for writing extremely high-assurance software.  in practice it's nowhere near that stage yet
02:17:23 <copumpkin> fynn: I also teach myself math with it, since I don't have much of a math background
02:17:33 <thoughtpolice> copumpkin: so, I think after this semester is over I will actually have time to work on OSX GHC if you want to keep going at it :)
02:17:40 <kmc> you can think of it as like Haskell, but allowing you to specify and prove *any* property of your code using the type system
02:17:41 <copumpkin> thoughtpolice: yay!
02:17:43 <thoughtpolice> (work + school = no free time)
02:18:01 <thoughtpolice> (work + considerably less school = much more free time)
02:18:40 <thoughtpolice> copumpkin: lol, my coworker was interested in having a 64bit windows GHC. i told him we could hack on our individual ports together, but he declined :(
02:18:46 <copumpkin> aw
02:18:57 <copumpkin> windows is lame, they can stick to 32 bits
02:19:11 <thoughtpolice> d00d i haz windows 7 on this laptop
02:19:21 <thoughtpolice> although i'm currently running debian + xmonad :p
02:19:24 <HaskellLove> f n | n==1 = Nothing | even n = Just (n `div`2) | odd n = Just (3*n+1) ------ what do you see wrong here guys?
02:19:34 <thoughtpolice> and i haz 64-bits
02:19:50 <kmc> > let  f n | n==1 = Nothing | even n = Just (n `div`2) | odd n = Just (3*n+1) in f
02:19:50 <lambdabot>   -3->
02:19:51 <lambdabot>    Just (-8)
02:19:51 <lambdabot>  -2->
02:19:51 <lambdabot>    Just (-1)
02:19:51 <lambdabot>  -1->
02:19:53 <lambdabot> [4 @more lines]
02:20:06 <kmc> > let  f n | n==1 = Nothing | even n = Just (n `div`2) | odd n = Just (3*n+1) in iterate f 5
02:20:07 <lambdabot>   Occurs check: cannot construct the infinite type:
02:20:07 <lambdabot>    a = Data.Maybe.Maybe a
02:20:28 <fynn> copumpkin: are you following any book/tutorial/text while doing that?
02:20:29 <kmc> :t iterateM
02:20:30 <lambdabot> Not in scope: `iterateM'
02:20:45 <copumpkin> fynn: not really, although people in #agda are very helpful :)
02:21:00 <fynn> heh cool :)
02:21:27 <copumpkin> iterateM would be interesting
02:21:32 <copumpkin> :t mfix
02:21:33 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
02:21:45 <nvoorhies> are there advantages to agda over coq beyond not getting funny looks when talking about it in public?
02:22:11 <copumpkin> nvoorhies: much more familiar syntax and construction, universe polymorphism, feels a lot more like a programming language
02:22:19 <copumpkin> nvoorhies: don't think there's much else
02:22:54 <nvoorhies> familiar from a haskell background, I take it, whereas coq's more ML-like?
02:23:03 <copumpkin> yeah
02:23:08 <nvoorhies> makes sense
02:23:36 <HaskellLove> Expected type: a -> a      Inferred type: a -> Maybe a    In the first argument of `iterate', namely `f', any way to keep my f function output Maybe and still use it as argument to iterate?
02:23:59 <nvoorhies> tricking drunk grad students into saying "I love Coq!" is great fun though
02:27:06 <copumpkin> :)
02:27:47 <kmc> are there stats about Hackage somewhere?  number of users, packages, uploads/day?
02:28:08 <kmc> by "users" i meant uploaders
02:28:40 <copumpkin> dons generates them periodically and posts them on his blog
02:28:44 <copumpkin> but I haven't seen any recently
02:29:54 <Saizan> nvoorhies: dependent pattern matching!
02:30:07 <HaskellLove> chain n = iterate f n             f n | n==1 = 1 | even n =  (n `div`2) | odd n = (3*n+1)        This gives me what i want but when it gets to 1 it just keeps making 1s to infinity, how to stop it? I tried Maybe but does not work with iterate
02:30:22 <nvoorhies> Saizan: ah, that sounds like it'd make life easier
02:30:23 <kmc> http://hackage.haskell.org/packages/archive/log could be useful
02:30:23 <copumpkin> HaskellLove: you can use unfold with Maybe
02:30:32 <copumpkin> HaskellLove: or you can use takeWhile with iterate
02:30:47 <HaskellLove> no way to stop it?
02:30:49 <copumpkin> coq doesn't have that?
02:31:01 <copumpkin> HaskellLove: not from within the function :) iterate always generates an infinite list!
02:31:05 <copumpkin> it's part of the fun!
02:31:13 <HaskellLove> haha i see :D
02:31:25 <kmc> 465 uploaders, 6379 uploads, 1736 packages
02:31:26 <HaskellLove> ok takeWhile will do fine then
02:32:18 <Jonno_FTW> takeWhile (/= 1)
02:32:26 <Jonno_FTW> then append 1 to every list
02:32:33 <Jonno_FTW> or add one to the length of each list
02:32:59 <tombee> http://paste.ideaslabs.com/show/lkIRMt7Ej2
02:33:06 <tombee> is there a better way I can do this to calculate prime factors?
02:33:11 <copumpkin> or just takeWhile (>1)
02:33:17 <tombee> its taking a LONG time for the largeNum ;)
02:33:27 <tombee> not even sure if it's still working
02:35:29 <HaskellLove> I have a value called listOfChains, how DeathMetal is that? :D
02:35:47 <HaskellLove> listOfSkulls
02:36:26 <HaskellLove> tombee> I had a mental breakdown this morning with primes, so... just to warn ya, dont be scared now...
02:36:41 <tombee> HaskellLove: did you do problem 3 in haskell?
02:36:54 <HaskellLove> yes i am on 14 now
02:37:13 <tombee> did your solution look anything like mine? :p
02:37:32 <HaskellLove> but i did that one in scala, and the fourth one... from 5 to 14 i do haskell and will continue so
02:37:54 <tombee> hm
02:41:19 <tombee> Ah, solved it
02:41:31 <tombee> I just took the first 1000 primes
02:41:34 <tombee> and used that
02:42:04 <HaskellLove> i was a noob like you a week ago, now i am like intermediate noob hahaha
02:42:27 <Jonno_FTW> you are progressing well young one
02:42:47 <Jonno_FTW> s/one/grasshopper/
02:43:11 <HaskellLove> Jonno_FTW thank you my brother jedai, may the Force be with us
02:44:45 <copumpkin> lol
02:44:45 <HaskellLove> lengthsOfChains = [x | n<-[1..1000000], x = map length (chain n)] ---- you guys notice something wierd here? only this line shows error rest of file is ok
02:45:17 <copumpkin> if you gave us an error
02:45:20 <copumpkin> we might be able to explain it
02:45:25 <copumpkin> let
02:45:33 <copumpkin> let x = map
02:45:58 <HaskellLove> i tried let, either way that is not logical i mean, x is kinda declared in the part before "|"
02:46:27 <Twey> x <- map length $ chain n
02:46:33 <HaskellLove> parse error on input `='
02:46:39 <HaskellLove> Twey tried that one too
02:46:52 <copumpkin> oh
02:46:56 <copumpkin> it's just length
02:46:57 <copumpkin> not map length
02:47:13 <copumpkin> but really
02:47:14 <Twey> I assumed chain return an [[a]]
02:47:26 <Twey> Since he's extracting from it and all…
02:47:26 <copumpkin> [length (chain n) | n <- [1..1000000]]
02:47:38 <copumpkin> maybe it is
02:47:42 <copumpkin> I haven't seen it
02:47:47 <Twey> returns**
02:47:51 <Twey> > [length $ chain n | n <- [1 .. 100]]
02:47:52 <lambdabot>   Not in scope: `chain'
02:48:04 <Twey> Really, people… why does everybody hate whitespace today?
02:48:17 <copumpkin> :t [length $ ?chain n | n <- [1 .. 100]]
02:48:17 <lambdabot> forall t a. (Num t, Enum t, ?chain::t -> [a]) => [Int]
02:48:25 <Twey> Nobody wants to read [length$chain(n)|n<-[1..100]]
02:48:46 * copumpkin often puts extra spaces around the outside of list comps
02:48:57 <Twey> [ like | this ]?
02:49:01 <Twey> I do that sometimes.
02:49:01 <copumpkin> yep
02:49:05 <Twey> Yeah.
02:49:06 <copumpkin> also, tabs instead of spaces
02:49:10 <copumpkin> cause we love the whitespace
02:49:12 <Twey> Arrrgh
02:49:20 <copumpkin> [\tlike\t|\tthis\t]
02:49:21 <copumpkin> :P
02:49:25 <Twey> Arrrrrrgh
02:49:53 * Twey hates tabs on principle, now — they screw with the whole principle of monospace fonts
02:50:16 <copumpkin> yep
02:50:50 <O__> Hi!
02:50:54 <Twey> o/
02:51:01 <O__> fresh beginner here :)
02:51:41 <mjrosenb> is there a parallelized version of map floating around in hackage anywhere?
02:52:26 <yitz> hi O__
02:52:45 <copumpkin> mjrosenb: it's in the standard distribution
02:52:56 <mjrosenb> copumpkin: what is it called?
02:52:57 <copumpkin> import Control.Parallel.Strategies
02:52:58 <copumpkin> parMap
02:53:04 <mjrosenb> sweet.
02:53:11 <O__> trying to implement sth, which involves the State Monad I guess
02:53:21 <copumpkin> sth?
02:53:31 <Twey> copumpkin: ‘Something’
02:53:33 <copumpkin> oh
02:53:42 <O__> the goal is to have a function, call it next, which will give me the next integer everytime I call it
02:53:50 <copumpkin> O__: you can't write that
02:53:51 <Twey> O__: You're doing it wrong, or else in way over your head, if you really are a beginner :þ
02:53:51 <O__> looks like a simple state monad job
02:53:53 <copumpkin> because it isn't a function
02:54:01 <Twey> O__: You're Doing It Wrong©.
02:54:11 <O__> OK.
02:54:13 <Twey> Yes, you can State it.
02:54:22 <Twey> But you probably shouldn't.
02:54:29 <O__> I am a beginner but I know I cannot do it *without* using monads
02:54:38 <copumpkin> oh, well
02:54:44 <copumpkin> you can fake it using State
02:54:50 <copumpkin> but it's not really "returning"
02:54:55 <Twey> Aye
02:55:02 <O__> I want to have multiple functions, using a same sequence of its
02:55:14 <O__> every time they call "next" they ought to get a new int
02:55:14 <yitz> O__: don't think of your program *doing* something. think of what the input is, and what you want the output to be.
02:55:16 <O__> thats all
02:55:37 <yitz> O__: why do you want that?
02:55:50 <O__> hmm yitz, quite a nice way of thinking
02:56:09 <copumpkin> here's how you would write it. int next() { static int x = 0; return x++; }
02:56:21 <O__> :)
02:57:05 <O__> what if I have a State Int somewhere
02:57:08 <copumpkin> :t modify
02:57:09 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
02:57:14 <copumpkin> :t modify succ
02:57:15 <lambdabot> forall s (m :: * -> *). (Enum s, MonadState s m) => m ()
02:57:19 <O__> I guess then I can define next :: State Int
02:57:29 <copumpkin> :t modify succ >> get
02:57:30 <lambdabot> forall (m :: * -> *) b. (MonadState b m, Enum b) => m b
02:57:41 <O__> getting there :)
02:57:48 <copumpkin> :t modify succ >> get :: State Int
02:57:48 <yitz> O__: yes you can. but again, why would you want to do this?
02:57:48 <lambdabot>     `State Int' is not applied to enough type arguments
02:57:48 <lambdabot>     Expected kind `?', but `State Int' has kind `* -> *'
02:57:48 <lambdabot>     In an expression type signature:
02:58:07 <Twey> > evalState (get >>= liftM2 (>>) put return . succ) 3
02:58:09 <lambdabot>   4
02:58:24 <HaskellLove> lengthsOfChains has 1000000 elements, Ints. when I do: maximumElement = maximum lengthsOfChains I get stack overflow. Solution? I know the answer lies in unfoldr but i cant see the solution... ???
02:58:38 <Twey> > let next = get >>= liftM2 (>>) put return . succ in evalState (next >>= next) 3
02:58:39 <lambdabot>   Couldn't match expected type `a
02:58:39 <lambdabot>                                -> Control.M...
02:58:42 <Twey> Oops
02:58:45 <Twey> > let next = get >>= liftM2 (>>) put return . succ in evalState (next >> next) 3
02:58:46 <lambdabot>   5
02:58:49 <Jafet> @src maximum
02:58:49 <lambdabot> maximum [] = undefined
02:58:49 <lambdabot> maximum xs = foldl1 max xs
02:58:49 <copumpkin> > evalState (modify succ >> get) 3
02:58:50 <lambdabot>   4
02:58:51 <Twey> > let next = get >>= liftM2 (>>) put return . succ in evalState (next >> next >> next) 3
02:58:52 <lambdabot>   6
02:58:59 <O__> wow
02:59:11 <O__> that looks cool twey
02:59:12 <mux> HaskellLove: if you compile with -O, maximum should be optimized to do a strict left fold and you shouldn't have a stock overflow
02:59:20 <O__> I'll try to understand why that works :)
02:59:22 <copumpkin> @let next = modify succ >> get
02:59:23 <lambdabot>  Defined.
02:59:35 <copumpkin> > evalState (next >> next >> next) 3
02:59:35 <lambdabot>   Ambiguous occurrence `next'
02:59:35 <lambdabot>  It could refer to either `L.next', defined at ...
02:59:38 <copumpkin> lol
02:59:42 <Twey> Ah, yeah, copumpkin's is nice
02:59:43 <Twey> r
02:59:44 <copumpkin> @undef
02:59:47 <Twey> I forgot about ‘modify’
02:59:48 <Jafet> NEXT!
03:00:08 <copumpkin> > let next = modify succ >> get in evalState (next >> next >> next) 3
03:00:08 <yitz> HaskellLove: if you want it to work in ghci, or in without -O, use maximum' = foldl1' max
03:00:09 <lambdabot>   6
03:00:37 <yitz> HaskellLove: foldl1' is like foldl1, but stricter.
03:00:37 <copumpkin> > let next = modify succ >> get in evalState (do { x <- get; y <- next; z <- get; return (x + y + z) }) 3
03:00:38 <lambdabot>   11
03:00:53 <copumpkin> O__: you have to decide it you want ++x or x++ :P
03:00:55 <Twey> > let next = modify succ >> get in evalState (foldr1 (>>) $ replicate 4 next) 5
03:00:56 <lambdabot>   9
03:01:11 <O__> thanks I get my answer
03:01:14 <O__> for now :)
03:01:28 <O__> i'll come back if i cant figure out how it works
03:01:31 <O__> cheers!
03:01:34 <copumpkin> O__: note that unlike typical examples of "functions with closures"
03:01:50 <copumpkin> next is not a function and does not contain its own state of the counter
03:02:04 <yitz> O__: you could also just pass around an extra parameter that tells what up to what number you have used so far
03:02:32 <yitz> O__: which is exactly what State is a fancy name for
03:02:33 <O__> yitz: I am doing that right now
03:02:33 <mercury^> :t modify
03:02:34 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
03:02:37 <HaskellLove> mux what is -O?
03:02:58 <mercury^> Wouldn't it be better if modify also returned the new state?
03:03:06 <yitz> HaskellLove: a command line parameter for ghc
03:03:27 <HaskellLove> how to use that i hear of it first time
03:03:29 <yitz> HaskellLove: enables more opitmization
03:03:47 <yitz> ghc --make -O2 YourProgram.hs
03:03:49 <O__> isn't -O2 the recommended level of optimization
03:03:51 <Jafet> man ghc
03:04:06 <yitz> usually we use -O2 - even more optimization
03:04:13 <yitz> ues
03:04:15 <yitz> yes
03:04:21 <mux> O__: actually, cabal warns when you use -O2 telling you to only enable it if you're sure it's necessary
03:04:31 <mux> I don't think there is a recommended level of optimization
03:04:39 <dcoutts> there is, it's -O
03:04:53 <dcoutts> that's also the default for cabal builds
03:04:59 <yitz> dcoutts: why not -O2 (last heard everyone usually used that)
03:05:11 <Jonno_FTW> i use -O2
03:05:14 <copumpkin> mmorrow: you're up late!
03:05:18 <Jonno_FTW> and i feel great
03:05:19 <dcoutts> yitz: no, only dons and co use -O2 :-)
03:05:26 <yitz> heh
03:05:32 <SamB_XP> dcoutts: how come ?
03:05:39 <mmorrow> copumpkin: !!
03:05:40 <yitz> why not? besides that it compile a bit more slowly
03:05:54 <dcoutts> yitz: that it can be slower and more code
03:05:55 <Jonno_FTW> i agree
03:06:04 <yitz> usually insignificant for all but the really largest projects
03:06:08 <dcoutts> the Simons put obviously beneficial optimisations into -O
03:06:24 <dcoutts> -O2 is for more extreme and experimental ones that may or may not pay off
03:06:29 <yitz> dcoutts: is that changed in recent ghc?
03:06:38 <dcoutts> no, that's the way it's always been
03:07:22 <yitz> dcoutts: as of 6.8, for example, it was really worthwhile to use -O2 usually.
03:07:37 <dcoutts> yitz: it obviously depends on what you're compiling
03:07:46 <dcoutts> yitz: for code like uvector etc etc, some of the specific optimisations in -O2 are pretty important
03:08:00 <yitz> ok
03:08:08 <dcoutts> for building say the network or HTTP lib it buys you essentially nothing
03:08:26 <dcoutts> except code bloat in code paths that are not performance sensitive
03:08:36 <dcoutts> yitz: if you can measure the improvement then go for it
03:08:37 <yitz> i always understood -O2 gives you the best chance for fusion
03:09:04 <dcoutts> yitz: that's probably true, and if you're relying on fusion then you may well need it
03:09:13 <dcoutts> again, it's easy enough to measure it
03:10:33 <yitz> dcoutts: for everyday use, where you probably won't want to bother measuring and tweaking, what's the danger of just using -O2?
03:11:01 <HaskellLove> yitz so what if it is stricter? strictness will not allow stack overflow?
03:11:14 <HaskellLove> i presume the answer is yes?
03:11:23 <dcoutts> yitz: that you get bigger slower code, and have to wait longer to get it
03:11:38 <yitz> to put it another way - why is the stuff in -O2 that's proven useful in every day work not gone into -O yet?
03:12:03 <dcoutts> yitz: right, if you think there are ones that always pay off then they should be moved into -O
03:12:06 <O__> what about -O3 :)
03:12:06 <yitz> dcoutts: that's even easier to measure :)
03:12:15 * copumpkin always does -O666
03:12:16 <dcoutts> O__: there is no -O3
03:12:20 <copumpkin> it's like selling your soul to the devil
03:12:20 <SamB_XP> why not put the often-harmful stuff in -O3 ?
03:12:35 <O__> there is -O3
03:12:38 <dcoutts> nope
03:12:42 <dcoutts> it's equal to -O2
03:12:43 <HaskellLove> copumpkin is a ninja, do not do that...
03:12:43 <SamB_XP> I mean, since -O3 now does -O2 ...
03:12:50 <O__> someone lied to me :)
03:12:59 <copumpkin> O__: it works, it just doesn't do anything different
03:13:02 <SamB_XP> (in the past, -O3 was more like -O0 ;-P)
03:13:12 <O__> ok, i get it
03:13:14 <HaskellLove> yitz u did not answe me man, does strictness stop stack overflows?
03:13:34 <Axman6> it can help HaskellLove
03:13:35 <yitz> HaskellLove: yes, it can do that sometimes. it will in your case.
03:13:46 <HaskellLove> oki doki let me try
03:13:49 <dcoutts> yitz: there could be some, doing the analysis of what should be in -O vs -O2 requires time from GHC HQ, I'm sure they'd appreciate the help in doing that performance survey
03:14:36 <O__> so after the O discussion
03:14:45 <O__> are you ready for state monad again :)
03:14:53 <yitz> dcoutts: yeah. hmm. not so trivial how to do such a survey.
03:15:04 <HaskellLove> yitz so how to do this with folds: maximumElement = maximum lengthsOfChains ?
03:16:00 <mercury^> HaskellLove: maximum = foldl1' max
03:16:04 <O__> can someone direct me to a *simple* example of state monad
03:16:06 <mercury^> Or something like that.
03:16:13 <mercury^> @code maximum
03:16:13 <lambdabot> Maybe you meant: more todo vote
03:16:19 <O__> in which it only removes the need to pass an explicit state aroun
03:16:22 <O__> around*
03:16:28 <mjrosenb> wtf
03:16:35 * mjrosenb calls hax
03:16:40 <copumpkin> omgwtfhax?
03:16:50 <mjrosenb> i attempted to refactor my code so it could be parallized
03:16:54 <yitz> HaskellLove: write maximum' = foldl1' max, then write maximumElement = maximum' lengthsOfChains
03:17:06 <mjrosenb> since it was basically a map over ~1,000,000 elements
03:17:25 <mjrosenb> and changing map to parMap did not help
03:17:35 <copumpkin> mjrosenb: did you compile with threaded runtime?
03:17:42 <copumpkin> and run with more than one capability?
03:17:45 <mjrosenb> it used to take ~2 minutes, now it takes 10 seconds
03:17:47 <copumpkin> also, did you choose a suitable strategy?
03:17:48 <mjrosenb> copumpkin: yes and yes
03:17:48 <copumpkin> oh
03:17:52 <mjrosenb> and yes
03:17:56 <copumpkin> lol
03:18:00 <copumpkin> omgwtfbbq
03:18:18 <dcoutts> noooo! hnop fails with ghc-6.12
03:18:20 <HaskellLove> i cant override the original maximum function right, i have to do a new one like maximum'... i know it is so, but to ask just to make sure
03:18:20 <dcoutts> doh!
03:18:21 <copumpkin> mjrosenb: I think the gremlin eating all your CPU cycles left
03:18:27 <mjrosenb> as long as rwhnf is reasonable
03:18:33 <yitz> HaskellLove: right
03:18:34 <O__> R: can someone direct me to a *simple* example of state monad please. in which it only removes the need to pass an explicit state around
03:18:46 <mercury^> HaskellLove: you can, but excluding maximum from the Prelude import.
03:18:46 <dcoutts> @slap the hnop authors
03:18:47 * lambdabot locks up the hnop authors in a Monad
03:18:51 <copumpkin> mjrosenb: depends on what kind of work you actually want to do in parallel
03:18:58 <mercury^> by*
03:19:07 <copumpkin> @hackage hnop
03:19:07 <lambdabot> http://hackage.haskell.org/package/hnop
03:19:08 <benmachine> import Prelude hiding (maximum)
03:19:13 <copumpkin> whoa
03:19:14 <copumpkin> what's that?
03:19:18 <copumpkin> hackage nop?
03:19:29 <shambler> but wait, there is -O3 in gcc!
03:19:38 <shambler> http://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/Optimize-Options.html#Optimize-Options
03:20:02 <mjrosenb> copumpkin: it computes a value of type Foo, declared as newtype Foo = Foo(Double,Double)
03:20:15 <mercury^> -COPTS="-O3" or something to use that.
03:20:24 <yitz> copumpkin: it was the very first cabalized package
03:20:31 <mjrosenb> i'd like it to compute as many of those in parallel as possible
03:20:37 <yitz> copumpkin: it installs, but it does nothing
03:20:40 <benmachine> -optc-something
03:20:41 <benmachine> I think
03:20:45 <mercury^> Yeah.
03:20:47 <benmachine> but then you have to via-C
03:21:00 <mercury^> I'm not good at remembering cl options.
03:21:00 <benmachine> -fsomething-else
03:21:45 <HaskellLove> maximumElement = maximum' lengthsOfChains ------------------------------- maximumElement has the biggest number from that list now, but i need to get the index of that number how to do that?
03:21:55 <O__> Once more, sorry to bother but: can someone direct me to a *simple* example of state monad. in which it only removes the need to pass an explicit state around
03:22:32 <yitz> HaskellLove: you need both the value and the index, or just the index?
03:22:43 <copumpkin> HaskellLove: maximumBy (comparing snd) (zip [0..] lengthsOfChains)
03:22:57 <copumpkin> import Data.Ord if you don't have it
03:23:48 <O__> ooww noone likes me!
03:24:00 <yitz> HaskellLove: to get both: maximum' $ zip lengthsOfChains [0..]
03:24:17 <O__> i asked the same question 3 times, at least you could have said gtfo :)
03:24:18 <copumpkin> yitz: smart
03:24:25 <benmachine> O__: that's kind of what the state monad always does?
03:24:31 <Axman6> O__: have some patience...
03:24:31 <mercury^> yitz: how does that work?
03:24:59 <copumpkin> mercury^: the Ord for pairs compares fst first
03:25:03 <copumpkin> and if they're equal, compares snd
03:25:03 <HaskellLove> yitz well i need to get the biggest elelement from the list, get its index and then with that index target the list before and get a list element
03:25:05 <yitz> O__: we love to help because Haskell is fun, but this isn't a customer service department
03:25:09 <O__> Axman6: ok. this is quite a satisfying answer, really.
03:25:18 <O__> yitz: i like yours too.
03:25:32 <O__> i dont mean that you need to give an answer very quickly
03:25:43 <O__> but at least a response :)
03:25:56 <O__> i appreciate you help, certainly.
03:26:21 <mercury^> What is a response worth if it is not an answer?
03:26:33 <benmachine> O__: I grepped my haskell directory for State and got http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14155#a14155
03:26:45 <benmachine> that is an excerpt from a program for dealing with permutations
03:26:48 <O__> mercury: for me to feel better i guess :)
03:26:52 <vegai> mercury^: I suppose that depends entirely on how much you paid for it :)
03:26:59 <O__> motivation to wait
03:27:06 <O__> anyways
03:27:10 <benmachine> (by permutations I mean bijections from a set onto itself)
03:28:27 <copumpkin> O__: http://blog.patch-tag.com/2009/12/07/transliterating-python-to-haskell-fibonacci-in-the-state-monad/
03:28:49 <copumpkin> O__: not that I think it's a particularly good way to start learning haskell if you're very new
03:29:13 <O__> hmm
03:29:16 <O__> you may be right
03:29:32 <mercury^> copumpkin: is that your blog?
03:29:36 <O__> but i am old enough to try woth these guys now.
03:29:37 <copumpkin> nope
03:29:46 <copumpkin> just saw it on reddit a few days ago :)
03:29:50 * copumpkin has no blog
03:29:51 <O__> i've been hassling with hasskle for some time now
03:30:29 <Axman6> O__: i've personally never found a good use for the state monad, nor really been able to grok it
03:30:33 <O__> what a creative typo!
03:30:36 <O__> hasskle!
03:30:38 <HaskellLove> yitz you cant call maximum on list of tupples
03:30:48 <Axman6> sure you can
03:30:58 <Axman6> @instances Ord
03:30:59 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
03:31:13 <Axman6> > compare (1,"hello") (1,"hell")
03:31:14 <lambdabot>   GT
03:31:19 <HaskellLove> Couldn't match expected type `Int'           against inferred type `(Integer, Int)'
03:31:24 <osfameron> ah, good old clunky haskell n-tuples ;-)
03:31:33 <Axman6> > maximum (zip [1,2,3,2,1] [1..]
03:31:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:31:35 <Axman6> > maximum (zip [1,2,3,2,1] [1..])
03:31:36 <lambdabot>   (3,3)
03:31:53 <osfameron> (I mean, I know I don't *want* >5-tuples, but it still just seems inelegant that they have to be defined for each like that)
03:32:10 <Axman6> :\
03:32:15 <tavelram_> Doesnt feel right: There is more mathematical functions from A to B, than program functions/methods from A to B.
03:32:19 <O__> thanks for the links about state monad!
03:32:32 <mercury^> tavelram_: what's wrong about that?
03:32:34 <no-name> can anybody give an example of monad logic?
03:32:35 <O__> they'll keep me busy for some time
03:32:49 <no-name> (without getting to jargony)
03:32:50 <mercury^> (It's only true for infinite A and B also)
03:33:08 <O__> and bye!
03:33:15 <Axman6> tavelram_: ?
03:33:15 <tavelram_> mercury^, does it only concern side-affect free "functions"?
03:33:22 <QtPlaty[HireMe]> tavelram_: Well most of thouse functions from A to B will be uncomputable.
03:33:36 <QtPlaty[HireMe]> Like the halting problem
03:34:04 <tavelram_> so its possible to determine the halting problem as a mathematical function?
03:34:13 <mercury^> tavelram_: effectful functions from A to B are not "functions".
03:34:30 <QtPlaty[HireMe]> tavelram_: Yes.
03:34:59 <tavelram_> mercury^, ok, so just side-effect free then. But you should still include exceptions and non-terminating functions?
03:35:35 <mercury^> tavelram_: A non-terminating function from A to B is not a function from A to B either
03:35:36 <tavelram_> QtPlaty[HireMe], oh, ok.
03:35:39 <QtPlaty[HireMe]> Its a function from Z -> {0,1} where the numbers are gobelizations of programs.
03:35:48 <tavelram_> mercury^, ahh, true :).
03:35:53 <yitz> tavelram_: in conventional mathematics, yes, but some mathematicians use a different formulation of mathematics that does not allow functions that no one could ever observe.
03:35:59 <mjrosenb> QtPlaty[HireMe]: gobelizations?
03:36:22 <yitz> goedel
03:36:40 <yitz> goebel was someone else
03:36:42 * QtPlaty[HireMe] blushes "Sorry goedel"
03:36:45 <tavelram_> QtPlaty[HireMe], oh
03:36:53 <yitz> goebels that is
03:36:56 <Twey> Hahaha
03:36:59 <Twey> Someone else indeed
03:37:26 <mercury^> You really mean Goebbels I believe.
03:37:31 <tavelram_> yitz, ok, I assume this course usese conventional mathematics.
03:37:45 <yitz> tavelram_: good assumption :)
03:38:09 <Twey> Haha
03:38:09 <tavelram_> :)
03:38:48 <Twey> I can see it on a first-grade mathematics exam… ‘1 + 1 = ?’ ‘1 (we are using Boolean algebra here, right?)’
03:38:54 <HaskellLove> copumpkin: indexedList_Maximum = maximumBy (comparing snd) (zip [0..] lengthsOfChains) -------- this gives me stack overflow, any way to fix it?
03:39:18 <yitz> mercury^: I do, but I don't think QtPlaty[HireMe] did though
03:39:30 <yitz> QtPlaty[HireMe]: btw i like your nick
03:39:44 <QtPlaty[HireMe]> yitz: Thankyou
03:39:54 <mercury^> http://www.okcupid.com/profile/QtPlaty/questions?Sex=1 -- that is you?
03:40:29 <tavelram_> Ok, why isnt all functions N -> {0,1} enumerable? There only seems to be twice as many as N, and since N is infininte, there is twice infinite, which is just infinite, so it seems to just be hilberts hotel? The function f(n,b) = n*2+b should be able to enumerate them? But is it wrong to say |2*N| = infinite = |N|?
03:40:31 <QtPlaty[HireMe]> mercury^: Yes...
03:41:02 <mercury^> tavelram_: 2^N is not 2*N.
03:41:24 <yitz> > let (+) _ _ = 7 in 1 + 1
03:41:25 <lambdabot>   7
03:41:49 <mercury^> QtPlaty[HireMe]: okcupid any good? I just read the developer blog so far, which was quite amusing.
03:41:51 <tavelram_> mercury^, huh?
03:42:39 <QtPlaty[HireMe]> mercury^: I was interested in the algrythum myself.  Seemed to find good matchs.
03:42:40 <yitz> tavelram_: list all of those functions in an enumeration. go down the diagonal and flip each bit - you get a function that you missed in your enumeration
03:43:32 <yitz> tavelram_: it's called a "diagonalization argument".
03:43:48 <tavelram_> yeah I know about that one, but how does I miss it?
03:44:12 <tavelram_> do
03:44:31 <HaskellLove> indexedList_Maximum = maximumBy (comparing snd) (zip [0..] lengthsOfChains) -------- this gives me stack overflow, any way to fix it?
03:44:39 <copumpkin> by the way, the reals are countable, haven't you heard?
03:44:53 <copumpkin> diagonalization is bullshit
03:45:10 <copumpkin> (http://knol.google.com/k/are-real-numbers-uncountable)
03:45:18 <copumpkin> ;)
03:45:19 <yitz> oh noes, copumpkin is a constructionalist
03:45:26 <tavelram_> hehe
03:45:32 <mercury^> tavelram_: let e : N -> N -> 2 be an enumeration of N^2. Then f n = case e n n of 1 -> 0; 0 -> 1 is a function N -> 2 which cannot be e m for any m.
03:46:04 <mercury^> enumeration of 2^N*
03:46:13 <mercury^> :(
03:46:41 <edwardk> a coconstructionalist actually
03:46:55 <yitz> HaskellLove: use maximumBy'. and yes, you'll have to write that yourself again, using foldl1' in place of foldl1 as before.
03:47:01 <yitz> @src maximumBy
03:47:02 <lambdabot> Source not found. My brain just exploded
03:47:22 <HaskellLove> @type maximumBy
03:47:22 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:47:34 <edwardk> copumpkin: that knol is funny
03:47:46 <copumpkin> edwardk: you should write some crackpot ones too
03:48:11 <copumpkin> :)
03:48:29 <edwardk> what amazes me is it has so many high votes
03:48:44 <copumpkin> yeah, and that's after we ridiculed it on /r/math
03:49:00 <edwardk> "A reader recently claimed that 1/3 is not in my list because my algorithm for locating the number in my tree would not work. This is nonsense and the reader is of course confused." -- with no rebuttal ;)
03:49:15 <copumpkin> yeah, he's a dumbass
03:49:22 <tavelram_> mercury^, so you have to enumerate using the target n as well?
03:49:33 <mercury^> tavelram_: huh?
03:49:40 <copumpkin> he's basically talking about counting all reals with finite decimal representations
03:49:45 <copumpkin> which of course are countable
03:49:47 <osfameron> that was via good math, bad math ?
03:49:55 <edwardk> "Software Developer, Author" classic, "expertise in one area does not supply expertise in others" problem
03:50:28 <HaskellLove> anyone knows how to rewrite maximumBy with folds?
03:50:43 <mercury^> He's probably not that much of an expert in anything if he cannot understand simple arguments.
03:50:57 <tavelram_> mercury^, oh, sorry, but why isnt f : N -> Bool enumerable? Since it only needs 2*n, ie only increases by a finite number...
03:51:16 <mercury^> tavelram_: I just have you the prove.
03:51:19 <mercury^> gave*
03:51:20 <mercury^> wtf
03:51:32 <tavelram_> mercury^, yeah, but wasnt it for N -> N?
03:51:36 <mercury^> No.
03:51:43 <copumpkin> :t foldl1' (max `on` snd)
03:51:44 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a, b)
03:51:44 <lambdabot>       Expected type: (a, b)
03:51:44 <lambdabot>       Inferred type: b
03:51:58 <mercury^> the proof* also.
03:52:08 <mercury^> I seem to be exceptionally dumb today.
03:52:25 <copumpkin> :t foldl1' (\(x, y) z -> max x y)
03:52:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t)
03:52:26 <lambdabot>       Expected type: (t, t)
03:52:26 <lambdabot>       Inferred type: t
03:52:32 <copumpkin> oh
03:53:13 <HaskellLove> copumpkin can you me the function you send me with: maximumBy and zip stuff? this ubuntu thing logs out on me from time to time i will kill it :D
03:53:20 <copumpkin> :t foldl1' max
03:53:21 <lambdabot> forall a. (Ord a) => [a] -> a
03:53:26 <copumpkin> let's just leave it at that
03:53:29 <copumpkin> and zip it the other way
03:53:56 <Cale> tavelram_: Hey, are you still confused about why the functions N -> 2 aren't countable?
03:54:24 <tavelram_> mercury^, ok, Im way to stressed out to get that though :p
03:54:26 <tavelram_> Cale, yeah.
03:54:36 <tavelram_> Cale, at least a bit :p
03:55:02 <Cale> tavelram_: Okay, so let's suppose you give me any enumeration of those functions, that is, you give me a function N -> (N -> 2)
03:55:07 <tavelram_> Cale, is it just that you cant treat infinite like that in this case? That |2*N| isnt <= |N| and thus not enumerable?
03:55:17 <Cale> I'm going to find a function N -> 2 which isn't in your list.
03:55:28 <mercury^> tavelram_: again, it's 2^N, not 2*N.
03:55:35 <Cale> It's not 2*N
03:56:07 <Cale> and |2*N| <= |N|, but |2^N| is not
03:56:53 <Cale> But in order to see this, we need to see that it's really impossible to get a bijection N -> (N -> 2)
03:57:02 <tavelram_> mercury^, yeah sorry, dont get why its 2^N :p
03:57:13 <mercury^> tavelram_: per definition.
03:57:14 <tavelram_> Cale, but whats the first N of that enumeration? the "target" N?
03:57:44 <Cale> tavelram_: Well, that's just a notation for the set of functions N -> 2. It makes sense because if you have two finite sets A and B, then the number of functions A -> B is |B|^|A|
03:57:51 <tavelram_> so {1,2,3,4} -> Bool is 4^2?
03:57:53 <mercury^> Cale: surjection suffices, and is much easier to show.
03:57:59 <mercury^> (well, is the easy part)
03:58:06 <Cale> tavelram_: 2^4
03:58:35 <tavelram_> oh yeah, sorry, I think I get it.
03:58:52 <Cale> mercury^: right, if there's no surjection, then there's certainly no bijection :)
03:59:53 <Cale> tavelram_: So consider any function N -> (N -> 2)  (or N -> 2^N in the other notation)
03:59:56 <Twey> Haha
04:00:16 * Twey loves switching to this channel and seeing sentences that look perfectly grammatical and yet… :þ
04:00:39 <mercury^> Hrm?
04:01:20 <indios> ciao
04:01:27 <indios> !list
04:01:27 <Optimo> I syndicate the following:
04:01:27 <Cale> tavelram_: Of course, helps to have names for these things, let's take f: N -> (N -> 2)
04:01:27 <Optimo> iPodTVNova_Movies iPodTVNova_Television
04:01:35 --- mode: ChanServ set +o Cale
04:01:38 <tavelram_> Cale, mercury^, ok I got it now, thanks :)
04:01:48 --- kick: Optimo was kicked by Cale (Cale)
04:02:04 <Cale> tavelram_: Oh, so you probably already know the rest of the argument?
04:02:20 <copumpkin> tavelram_: you see why it's exponent btw?
04:02:37 * quicksilver lols at the knol in scrolback
04:02:42 <copumpkin> :)
04:02:43 <tavelram_> Cale, not sure about that in this case, but I should have it in my lecture notes :p
04:02:56 <quicksilver> I remember once I foolishly starting reading a math usenet newsgroup
04:03:05 <quicksilver> it was entirely full of cranky infinity-deniers
04:03:16 <quicksilver> and someone with a weird proof about clifford algebras
04:03:23 <tavelram_> copumpkin, yeah, I was thinking of *ONE* function N -> B, and just enumerating the possibilities that each N could result in either 0 or 1.
04:03:27 <Twey> Hahahaha
04:03:33 <Cale> tavelram_: We form a function g: N -> 2 so that g(k) = 1 - f(k)(k), that is, if the kth entry of the kth sequence is 0, g(k) will be 1, and if the kth entry of the kth sequence is 1, then g(k) will be 0
04:03:35 <copumpkin> tavelram_: :)
04:03:56 --- mode: Cale set -o Cale
04:04:29 * hackagebot upload: chalmers-lava2000 1.1.0 - Hardware description library (EmilAxelsson)
04:04:29 <Cale> tavelram_: That means that g will be different from the kth sequence for each k, because it differs in at least the kth position
04:05:08 <Cale> (It differs from the first sequence in at least the first position, the second sequence in at least the second position, and so on.)
04:05:16 <copumpkin> that syndicator spammer dude is weird
04:05:20 <copumpkin> it happened in here before
04:05:25 <copumpkin> a random dude joins and types !list
04:05:28 <Cale> tavelram_: Make sense?
04:05:35 <copumpkin> and quits, and then Optimo tells us what he's syndicating
04:06:34 <Cale> tavelram_: So no matter how you might try to list the functions N -> 2 with indices in N, you'll end up missing at least one.
04:06:43 <Cale> tavelram_: So it's impossible to list them all.
04:06:51 <tavelram_> Cale, yeah I think so.
04:07:04 <tavelram_> yeah
04:07:51 <mercury^> tavelram_: now think about why listing decidable and semidecidable subsets of N is fine.
04:08:54 <mercury^> (But also why the set of decidable subsets is not semidecidable, while the set of semidecidable subsets is)
04:09:25 <tavelram_> mercury^, sorry, but Ive got an exam in 49 minutes and alot more to cover :p
04:09:31 <mercury^> Oh.
04:09:38 <mercury^> You shouldn't learn stuff on IRC I think.
04:09:41 <HaskellLove> startingNumber = chains !! maximumElementIndex -------------- maximumElementIndex returns Maybe Int, i want to convert it to Int, I tried to put fromMaybe in front but did not work... just this more and i will finish euler 14 and go to sleep heeelp mee :(
04:09:44 <mercury^> Takes too much time.
04:10:28 <Axman6> :t fromMaybe
04:10:29 <lambdabot> forall a. a -> Maybe a -> a
04:11:19 <HaskellLove> did not work with Maybe like this : startingNumber = chains !! fromMaybe (maximumElementIndex )
04:11:30 <tavelram_> mercury^, indeed :p
04:11:40 <Axman6> which is because you're using fromMaybe wrong
04:11:49 <Axman6> > fromMaybe 3 (Just 4)
04:11:50 <lambdabot>   4
04:11:56 <Axman6> > fromMaybe 3 Nothing
04:11:57 <lambdabot>   3
04:13:28 <HaskellLove> so mine should look like?
04:16:06 <HaskellLove> startingNumber = chains !! fromMaybe (maximumElementIndex ) ???
04:17:14 <Axman6> fromMaybe 0 maximumElementIndex
04:17:31 <HaskellLove> what is that 0?
04:18:29 <HaskellLove> oh default value, got it
04:18:54 <Axman6> @src fromMaybe
04:18:54 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
04:19:54 <Axman6> @djinn a -> Maybe a -> a
04:19:54 <lambdabot> f a b =
04:19:54 <lambdabot>     case b of
04:19:54 <lambdabot>     Nothing -> a
04:19:54 <lambdabot>     Just c -> c
04:20:02 <HaskellLove> oh my goood it is computing i hope it gives the right result so i can finish euler 14 and go to sleep happy man
04:27:20 <HaskellLove> if this code can be optimized let me know guys, so far it is ninja slow
04:28:01 <mercury^> HaskellLove: how are you doing it atm?
04:28:12 <mercury^> That problem seems like it is best solved with memotrie.
04:28:35 <HaskellLove> ah what?
04:28:55 <HaskellLove> atm, memotrie? speak english man :D
04:29:07 <mercury^> You want to memorise the chain length for any number you have encountered so far (as any part of a chain).
04:29:18 <mercury^> @hackage memotrie
04:29:18 <lambdabot> http://hackage.haskell.org/package/memotrie
04:29:24 <copumpkin> you can also do it fairly easily with arrays
04:29:27 <copumpkin> lazy arrays
04:29:27 <mercury^> blagh
04:29:44 <copumpkin> lol
04:29:49 <mercury^> copumpkin: those need to have the length known in advance, don't they?
04:29:55 <copumpkin> yeah, so not ideal
04:30:10 <copumpkin> but super duper fast
04:30:27 <copumpkin> and mind-bending if you're not used to seeing array construction depend on itself
04:30:41 <mercury^> Without analysing the problem further, we have to assume them very sparse and huge.
04:30:50 <mercury^> So not good imo.
04:30:52 <copumpkin> it's collatz
04:31:05 <copumpkin> and he has a constrained domain
04:31:24 <mercury^> Yes, but any starting value can become very large later in the chain.
04:31:41 <HaskellLove> so what would be good fix, arrays or memotrie ?
04:31:44 <copumpkin> it will only grow once
04:31:54 <copumpkin> use memotrie
04:32:09 <HaskellLove> arrays are not good here because?
04:32:20 <copumpkin> they're fine, I've seen a blazing solution using them
04:32:30 <copumpkin> but memotrie is more general
04:32:39 <mercury^> I still believe that you cannot know a priori that arrays will work.
04:32:57 <HaskellLove> oh i might rewrite this tomorow then with arrays, dont know why i did not do it from start like that, i got used to lists i guess
04:33:20 <HaskellLove> wow this is still computing, it is huge
04:33:33 <copumpkin> > iterate iter 27
04:33:34 <lambdabot>   Not in scope: `iter'
04:33:41 <mercury^> Because you are doing it totally wrong atm.
04:34:25 <HaskellLove> totally wrong, like what?
04:41:49 <basvandijk> Hello, I'm looking for a package which I know is on hackage but I forgot it's name. I think its from Luke Palmer and it provides the following type: newtype Box a b = Box { unBox :: b }. Does anybody know which package this is?
04:42:58 <Axman6> have you tried using hayoo? it searches hackage
04:43:09 <copumpkin> basvandijk: there's an isomorphic type called Tagged in the tagged package on hackage, but it's by edwardk
04:43:27 <basvandijk> Axman6: yes I tried hayoo and hoogle with no luck
04:43:41 <basvandijk> copumpkin: nice, I will check it out
04:43:52 <copumpkin> @hackage tagged
04:43:52 <lambdabot> http://hackage.haskell.org/package/tagged
04:44:06 <ray> type suitcase for carrying types around
04:44:39 <basvandijk> copumpkin: Thanks 'tagged' is what I was looking for.
04:44:45 <copumpkin> :) np
04:45:01 <edwardk> glad people are finding that useful ;)
04:45:45 <copumpkin> damn, you're still up
04:46:14 <edwardk> yeah, actually just going to head into work now
04:46:16 <Axman6> hmm, is there a name for numbers with exactly 3 factors?
04:46:20 <Cale> Has it been shown that for all k, there exists a problem such that the best algorithm solving that problem is worst case O(n^k)?
04:46:32 <mreh> what monad abstracts function application?
04:46:39 <copumpkin> mreh: reader?
04:46:42 <copumpkin> (a ->) ?
04:46:44 <Cale> The function monad
04:47:04 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
04:47:05 <lambdabot>   ("hello","olleh","HELLO")
04:47:27 <mreh> i've got a value that I want to pass between functions that take a value of this type and compose them all together
04:47:31 <Axman6> :o
04:47:49 <mreh> i thought Monads would be a neat way of doing it
04:47:52 <Axman6> Cale: hmm, i think that's by far the best example of the function monad i've seen
04:47:57 <basvandijk> edwardk: do you follow the PVP on the tagged version number
04:48:32 <basvandijk> because then I will depend on tagged == 0.0.*
04:49:02 <mreh> :t (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z))
04:49:05 <lambdabot> [Char] -> ([Char], [Char], [Char])
04:49:26 <mreh> -> is a monad?
04:49:28 <edwardk> basvandijk: i've been trying to follow the pvp overall, so most likely, yes ;)
04:49:29 <mreh> cool
04:49:36 <copumpkin> :t liftA3 id reverse (map toUpper)
04:49:37 <lambdabot>     Couldn't match expected type `b -> c -> d'
04:49:37 <lambdabot>            against inferred type `[a]'
04:49:37 <lambdabot>     Probable cause: `reverse' is applied to too many arguments
04:49:46 <copumpkin> :t liftA3 (,,) id reverse (map toUpper)
04:49:47 <lambdabot> [Char] -> ([Char], [Char], [Char])
04:49:54 <Cale> (That is, that there is an algorithm solving that problem which takes O(n^k) time, but for all j < k, no algorithm which runs in worst case O(n^j) time can solve the problem.
04:49:57 <Cale> )
04:50:37 <copumpkin> Cale: I imagine you could construct some trivial "find something out about a k-dimensional array" problem for each size
04:51:01 <Cale> Hmm, I suppose you have to be careful about how you measure the input.
04:51:26 <copumpkin> you'd have a k-dimensional hypercube array of side n, I guess
04:51:27 <Cale> but that seems like the right way to go
04:51:34 <copumpkin> that's your input, and "find the max value" in it or something
04:51:41 <copumpkin> doesn't seem particularly interesting though
04:51:47 <Cale> Yeah, but if n is the number of bits in the input...
04:52:08 <tavelram_> Im off to exam, thanks for the help Cale, mercury^, copumpkin, etc.
04:52:16 <copumpkin> good luck
04:52:31 <copumpkin> Cale: why would bits change it?
04:52:37 <copumpkin> oh
04:52:45 <Cale> You see why, yeah?
04:52:49 <copumpkin> I see, you want n space and n^k runtime
04:52:58 <copumpkin> n input space, that is
04:53:01 <Cale> yeah
04:53:08 <copumpkin> hm
04:53:20 <mreh> do { a <- procEvs evs; b <- moveShip a; c <- tick b; return c } -- this seems unecessary
04:53:51 <Cale> mreh: Make use of >>=
04:54:08 <Cale> procEvs evs >>= moveShip >>= tick
04:54:09 <copumpkin> or even >=>
04:54:17 * Beelsebob would use <=< there
04:54:20 <copumpkin> yeah :)
04:54:35 <Cale> or, yes, Kleisli composition, if you're interested in the function of evs
04:54:50 <mreh> this is the "Function" monad?
04:54:52 <Cale> tick <=< moveShip <=< procEvs
04:54:56 <Cale> No, it's any monad.
04:55:14 <Cale> mreh: The do-notation desugars into uses of >>= anyway
04:55:45 <Cale> @undo do { a <- procEvs evs; b <- moveShip a; c <- tick b; return c }
04:55:45 <lambdabot> procEvs evs >>= \ a -> moveShip a >>= \ b -> tick b >>= \ c -> return c
04:55:56 <mreh> @pl procEvs evs >>= \ a -> moveShip a >>= \ b -> tick b >>= \ c -> return c
04:55:57 <lambdabot> tick =<< moveShip =<< procEvs evs
04:56:05 <copumpkin> Cale: seems like the only way to construct such algorithms would be using ideal cryptographic hash functions
04:56:24 <copumpkin> well, functions that can't be reversed
04:56:42 <mreh> so I suppose =<< is right associative
04:56:43 <Axman6> :t (>>= (+))
04:56:44 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
04:57:06 <Cale> infixr 1 =<<
04:57:14 <Cale> is what :info (=<<)  reports
04:57:27 <Cale> The r is for right associative :)
04:57:45 <mreh> yo
04:58:01 <copumpkin> Cale: most other things that would take the complexity up to a power of n have a bad naive runtime but usually have easy ways out
04:58:14 <Cale> copumpkin: yeah
04:59:10 <Cale> copumpkin: I thought it would be amusing if there was a possibility that everything in P is actually solvable in O(n^k) time for some constant k, but it seems very unlikely to be true :)
04:59:22 <copumpkin> so something like find a hash collision over the n-symbol alphabet of length k or something
04:59:39 <copumpkin> or prove that one doesn't exist
04:59:59 <copumpkin> but you'd be throwing away the actual bits of the input, which is lame
05:00:24 <copumpkin> oh
05:00:31 <copumpkin> that is there's a maximum k for all problems in P?
05:01:19 <Cale> copumpkin: Well, I suppose that's not *quite* the negation of this statement
05:01:47 <copumpkin> hm
05:02:13 <Cale> copumpkin: There might be some k which are missed, but there are problems with arbitrarily large k
05:03:15 <copumpkin> I guess big theta
05:04:00 <copumpkin> bah, I should shower and go to campus :)
05:04:14 <Cale> Another thing I was thinking a bit about is, supposing that P = NP, what is the smallest possible exponent for solving an NP complete problem where we could reasonably expect to see any benefit?
05:04:17 <Cale> er
05:04:24 <Cale> s/any/no/
05:05:04 <Cale> I suppose there's a lot of possibilities depending on the constant factors involved when it comes to practicality
05:05:30 <Cale> (and how much of the space of problems gets the worst case behaviour)
05:06:03 <Cale> But P = NP could be true and have no practical consequences at all, if things were bad enough :)
05:06:42 <Cale> (In fact, I almost think it's likely to be the case)
05:06:51 <quicksilver> e.g. P = NP but the polynomial computation requires a computer 10^20 times the size of the universe.
05:07:10 <quicksilver> gonna need another universe...
05:07:51 <Cale> The best polynomial time complexity for solving an NP-complete problem is something like O(n^BB(G)) or something, where BB is the busy beaver function, and G is Graham's numbers
05:07:53 <Cale> -s
05:08:43 <Cale> There are a lot of natural numbers, and almost all of them are very large. :)
05:09:40 <Berengal> Good thing we invented induction...
05:09:42 <quicksilver> true indeed
05:10:10 <Jonno_FTW> speaking of induction
05:10:16 <pozic> Cale: ?
05:10:43 <Jonno_FTW> had a maths exam once including a mathemetical proof by induction
05:10:51 <Jonno_FTW> it worked for the first 4 examples
05:10:57 <pozic> Cale: where do you get that polynomial time complexity?
05:11:08 <Jonno_FTW> and that was all you needed for the marks, but it failed on the 5 example
05:11:14 <mercury^> He was making a joke.
05:13:00 <JohnDoe365> Hi!
05:13:10 <Axman6> 'lo
05:13:28 <JohnDoe365> There has been some discussion lately bout error handling / exception handling
05:13:37 <JohnDoe365> is there a definitve guide somewhere?
05:13:50 <JohnDoe365> or in which direction it's going
05:14:45 <Axman6> write code that doesn't produce them >_>
05:16:02 <copumpkin> require a proof that exceptional conditions are not present
05:16:04 <copumpkin> as a parameter
05:23:00 <Axman6> > 1/909090909090909091 :: CReal
05:23:01 <lambdabot>   0.00000000000000000109999999999999999989
05:23:11 <zygoloid> Cale: are there necessarily problems in P which require n^k steps for arbitrarily large k?
05:23:29 <zygoloid> that sounds pretty close to a proof that P != NP...
05:24:38 <pozic> zygoloid: he was making a joke.
05:24:40 <mreh> @undo do { x <- id; y <- reverse; z <- map toUpper; return (x,y,z) }
05:24:41 <lambdabot> id >>= \ x -> reverse >>= \ y -> map toUpper >>= \ z -> return (x, y, z)
05:25:00 <mreh> @pl id >>= \ x -> reverse >>= \ y -> map toUpper >>= \ z -> return (x, y, z)
05:25:00 <zygoloid> pozic: right, but i was wondering if there was some truth to it :)
05:25:00 <lambdabot> (reverse >>=) . (((map toUpper >>=) . (return .)) .) . (,,) =<< id
05:25:09 <mreh> eurgh
05:32:42 <mreh> > (do { y <- reverse ; z <- map toUpper y; return z }) "hello"
05:32:44 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:32:44 <lambdabot>         against inferred ty...
05:33:17 <mreh> I don't think I fully understand
05:33:22 <Jedai> zygoloid: I don't really how this would bring a proof of P != NP
05:34:06 <mreh> > \x -> (do { y <- reverse ; z <- map toUpper y; return z }) "hello"
05:34:06 <Jedai> mreh: do notation don't usually results in a function
05:34:07 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:34:07 <lambdabot>         against inferred ty...
05:34:13 <mreh> > \x -> (do { y <- reverse x; z <- map toUpper y; return z }) "hello"
05:34:15 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[b]'
05:34:24 <mreh> (> \x -> (do { y <- reverse x; z <- map toUpper y; return z })) "hello"
05:34:30 <mreh> > (\x -> (do { y <- reverse x; z <- map toUpper y; return z })) "hello"
05:34:31 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:34:31 <lambdabot>         against inferred ty...
05:34:45 <Jedai> mreh: stop, calm
05:34:58 <mreh> I am calm
05:35:05 <Axman6> clam down!
05:35:17 <mreh> are you starting?
05:35:21 <Jedai> do { y <- reverse "hello"; let { z = toUpper y}; return z }
05:35:30 <Jedai> > do { y <- reverse "hello"; let { z = toUpper y}; return z }
05:35:31 <lambdabot>   "OLLEH"
05:35:54 <mreh> how do I parameterise it?
05:36:28 <Jedai> > (\str -> do { y <- reverse str; let { z = toUpper y}; return z }) "hello"
05:36:29 <lambdabot>   "OLLEH"
05:36:47 <mreh> @pl  (\str -> do { y <- reverse str; let { z = toUpper y}; return z }) "hello"
05:36:47 <lambdabot> (line 1, column 13):
05:36:47 <lambdabot> unexpected "{"
05:36:47 <lambdabot> expecting variable, "(", operator or ")"
05:37:12 <mreh> why did you have to use the let?
05:37:23 <Jedai> mreh: do-notation is syntaxic sugar, @pl don't understand it
05:37:42 <mreh> @undo  (\str -> do { y <- reverse str; let { z = toUpper y}; return z }) "hello"
05:37:42 <lambdabot> (\ str -> reverse str >>= \ y -> let { z = toUpper y} in return z) "hello"
05:37:46 <Jedai> mreh: y was a Char, it wasn't a list and so not an action in the list monad
05:38:12 <mreh> oh i see
05:38:16 <mreh> you could have used map
05:38:22 <Jedai> mreh: no
05:38:25 <bsod666> anyone here know prolog?
05:38:34 <bsod666> prolog channel seems to be empty
05:38:38 <Jedai> mreh: map takes a list in parameter, y was a Char, not a list
05:39:15 <Jedai> mreh: by the way, you function is just "map toUpper . reverse", you really don't need to use the list monad
05:39:36 <mreh> Jedai: I'm looking for neat ways to compose functions
05:40:17 <mreh> but i suppose if you want to compose a function with do, they must all be of the form (a -> m b)
05:40:20 <Wooga> why here: http://paste2.org/p/561401 if uncomment first line, an error rising ?
05:40:50 <quicksilver> Wooga: what error?
05:40:52 <Jedai> mreh: do has usually not much to do with composition
05:41:16 <Axman6> Wooga: what's te type of lastbutOne?
05:41:20 <Axman6> B*
05:41:35 <Jedai> mreh: you can compose monadic functions with >=> but that has not much to do with do-notation
05:41:36 <Wooga> [a] -> a i suppose
05:41:39 <quicksilver> ah yess.
05:41:43 <quicksilver> the return type is wrong. duh
05:41:51 <Jedai> @hoogle (>=>)
05:41:51 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:42:00 <Wooga> should i declare type of it clearly?
05:42:06 <Jedai> @hoogle (<=<)
05:42:06 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
05:42:16 <Axman6> that won't help. lastButOne [] = []  is just wrong
05:42:46 <Wooga> quicksilver: http://paste2.org/p/561403
05:43:22 <Axman6> well, technically it's not. but it will need to have the type [[a]] -> [a]
05:46:20 <Wooga> Axman6: sorry, may you show complete working example
05:46:22 <Wooga> ?
05:46:49 <Axman6> well, the function can't work in general for the [] case, because there is no last but one element in an empty list
05:46:55 <Axman6> > tail [1..3]
05:46:56 <lambdabot>   [2,3]
05:47:00 <Axman6> > tail []
05:47:01 <lambdabot>   * Exception: Prelude.tail: empty list
05:47:14 <Axman6> the only sensible thing to do would be to throw an error
05:47:33 <Axman6> (technically, you should do the same for the (x:[]) case too)
05:47:50 <Wooga> thanks
05:48:09 <Wooga> i just tried to make something working without errors
05:48:27 <Axman6> well, you can't in general
05:48:28 <Wooga> but well, defined error already not my error
05:48:52 <Axman6> this is why we have the Maybe type, for functions which might fail
05:49:05 <Jedai> > let lastButOne [x,_] = x; lastButOne (x:xs@(y:_)) = lastButOne xs; lastButOne _ = error "not enough elements" in lastButOne [1..10]
05:49:06 <lambdabot>   9
05:49:16 <Jedai> > let lastButOne [x,_] = x; lastButOne (x:xs@(y:_)) = lastButOne xs; lastButOne _ = error "not enough elements" in lastButOne [1]
05:49:17 <lambdabot>   * Exception: not enough elements
05:50:08 <Axman6> > let lastButOne = (!! 2) . reverse in lastButOne [1..10]
05:50:10 <lambdabot>   8
05:50:16 <Axman6> > let lastButOne = (!! 1) . reverse in lastButOne [1..10]
05:50:17 <lambdabot>   9
05:50:21 <Axman6> > let lastButOne = (!! 1) . reverse in lastButOne []
05:50:23 <lambdabot>   * Exception: Prelude.(!!): index too large
05:50:51 <EvilTerran> > map (last . init) ["abracadabra", "f", ""]
05:50:52 <lambdabot>   "r* Exception: Prelude.last: empty list
05:50:52 <Twey> > let lastButOne = last . init in lastButOne [1 .. 10]
05:50:53 <lambdabot>   9
05:50:54 <Wooga> is using reverse better idea for solving it?
05:51:06 <Wooga> isn't there more iterations coming?
05:51:18 <Twey> 13:46:50 < Axman6> the only sensible thing to do would be to throw an error
05:51:21 <Twey> Or use Maybe.
05:51:46 <Axman6> Twey: i did suggest that, but the task is to write something of the form [a] -> a
05:51:49 <Twey> (there are Maybe-using versions of all these functions in the ‘safe’ package)
05:51:55 <Twey> Ah, homework is it?
05:52:02 <Axman6> RWH i'd guess
05:52:07 <Twey> 'kay
05:52:09 <Jedai> Wooga: except if the exercice explicitly ask you to use recursion (explicit recursion), you should always prefer simple composition of functions
05:52:42 <Wooga> thanks
05:52:44 <Twey> Yeah… explicit recursion is usually a sign of something you could be doing better (like a map or fold)
05:53:08 * Heffalump thinks explicit recursion is best unless your code is a simple map or fold
05:53:10 <Axman6> anyone else think it'd be nice to have a standard list type which cannot be empty? ie FilledList a = Cons a (FilledList a) | Nil a
05:53:12 <Twey> Using the provided functions results in shorter code, and also takes care of a lot of performance issues for you
05:53:27 <Twey> Heffalump: You think that until you hit a stack overflow ;)
05:53:36 <Jedai> Wooga: in this case, neither the "last . init" nor the "(!! 1) . reverse" is likely to be widely slower or faster than the explicit recursion so prefer the simplest one
05:53:49 <Twey> ‘Argh, strictness… here?  No… here?  Maybe an accumulator argument…’
05:54:04 <ddarius> Twey: There's no reason at all that you should have stack overflows in explicitly recursive functions.
05:54:07 * Heffalump does know what foldr, foldl and foldl' do, honest :-)
05:55:06 <ddarius> I would say that trying to smash everything into a foldr is certainly not the thing to do, but that most functions do nicely fit into some pre-existing, defined recursion scheme or non recursive pattern.
05:55:41 <Heffalump> even when something is a fold, I don't necessarily write it that way, because I find the direct recursion clearer
05:55:44 <Axman6> :t const . const
05:55:45 <ddarius> However, there are definitely functions that are best implemented explicitly recursive given the current standard library functions such as pairUp.
05:55:45 <lambdabot> forall b a b1. a -> b -> b1 -> a
05:55:53 <Axman6> :t const  const
05:55:54 <lambdabot> forall a b b1. b1 -> a -> b -> a
05:57:41 <aavogt> @type flip
05:57:42 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:57:44 <aavogt> @type fmap
05:57:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:58:14 <Axman6> >_________<
05:58:42 <Twey> :t pairUp
05:58:44 <lambdabot> Not in scope: `pairUp'
05:58:49 <aavogt> @type zip
05:58:50 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
05:58:54 <Twey> What's that?
05:59:17 <aavogt> I think you want zip when you mean pairUp
05:59:26 <aavogt> I've never seen that function
05:59:29 <ddarius> pairUp [] = []; pairUp [_] = []; pairUp (x:y:xs) = (x,y):pairUp xs
05:59:30 <aavogt> @hoogle pairUp
05:59:30 <lambdabot> No results found
05:59:40 <Twey> Oh
05:59:46 <Twey> Data.List.Split.chunk
05:59:55 <ddarius> Produces lists.
06:00:01 <Twey> Aye.
06:00:09 <Twey> Same concept, though.
06:00:15 <ddarius> And map (\[x,y] -> (x,y) . chunk 2 is hideous.
06:00:27 <ddarius> Especially because it doesn't parse.
06:00:31 <Twey> Haha.
06:00:49 <ddarius> (nor is it correct except for even length lists)
06:01:13 <Twey> Indeed, but it's also more flexible.
06:01:43 <ddarius> chunk is certainly a handy function, but I've wanted pairUp or a variation on it often enough.
06:01:51 <aavogt> @hackage tuple
06:01:51 <lambdabot> http://hackage.haskell.org/package/tuple
06:02:33 <aavogt> would there be a way to write pairUp such that the size of the tuple depends on an argument?
06:02:40 <quicksilver> aavogt: no.
06:02:49 <quicksilver> well, yes there is but you don't want to.
06:04:11 <aavogt> quicksilver: so to write it as a type class method where the 'numbers' all have different types?
06:04:31 <aavogt> and then the appropriate functional dependencies to make the size of the tuple unique
06:05:48 <aavogt> why do you say that I don't want to do such?
06:05:52 <aavogt> what can happen?
06:06:13 <ddarius> It'll be more work than it's worth to write and use.
06:06:58 <aavogt> oh, since we have functions like   zip4,   instead of  (zipN N4) or something like that
06:07:39 <Twey> http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Sequence.html
06:07:48 <Twey> I really hope these were TH'd
06:08:08 <aavogt> and you don't seem to gain any flexibility since you can't manipulate all those numbers any more easily than you can zip3 and the other numbered functions
06:08:14 <ddarius> Twey: They should be generated but not with TH.
06:08:24 <Twey> Why not with TH?
06:08:38 <ddarius> Twey: Why have a dependency on TH for such a simple library?
06:09:00 <Twey> What could possibly be better for generating Haskell code?
06:09:41 <aavogt> the TH could have been run before the library was uploaded to hackage
06:10:01 <aavogt> that's an option, but I'm not sure what happened with that package
06:10:02 <ddarius> Twey: For that, I'd probably seriously just use editor macros.
06:10:22 <Twey> Yay editor macros.
06:11:33 <osaunders> Why is return called return?
06:11:39 <osaunders> Seems like a confusing name.
06:11:47 <osaunders> :t return
06:11:48 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:12:50 <aavogt> osaunders: it makes do notation look like more popular languages? Especially if you use braces and semicolons
06:13:14 <osaunders> Yeah, I think that's bad.
06:13:20 <osaunders> Misleading.
06:13:34 <EvanR> it seems its usually used at the end of a do block to return the right type
06:13:48 <EvanR> you have a a and you need m a
06:23:23 <chellomere> hello, is there any easy and portable way of outputting a unicode string in a terminal?
06:23:45 <Axman6> look at the Text package
06:23:46 <Axman6> Data.Text
06:25:29 <Wooga> comments on RWH really awesome idea
06:26:35 <koeien37> from what i've heard, unicode support should be better in ghc 6.12
06:26:44 <koeien37> but i am completely unaware of any problems, really
06:26:49 <chellomere> ok
06:26:52 <koeien37> (warning: that does not imply that they don't exist.)
06:26:55 <chellomere> Axman6, that package appears to be third-party?
06:27:04 <koeien37> yes, it's on hackage
06:27:04 <Axman6> yes
06:28:21 <Axman6> it's a very fast package, similar to bytestrings, that sully supports UTF-8
06:28:21 <koeien37> hmm
06:28:21 <koeien37> putStrLn "我住在荷兰" on my ghci prompt gives an incorrect result
06:28:31 <chellomere> yes, from what I've understood, haskell correctly stores unicode text in Strings, but doesn't output them correctly to a terminal, it just truncates the characters to the lower or upper byte
06:28:37 <koeien37> yeah
06:28:45 <chellomere> lower, probably
06:29:15 <koeien37> i don't know whether this is a problem in haskell or in GHC really
06:29:30 <koeien37> anyway, should be corrected in GHC 6.12
06:29:38 <koeien37> which will be released Real Soon Now according to simon m.
06:29:54 <xerox> ?index text
06:29:54 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.Html, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
06:30:14 <xerox> > text "我住在荷兰"
06:30:15 <lambdabot>   我住在荷兰
06:30:42 <therp> what would be the type for g in http://pastebin.com/m56abdec0 ?
06:30:48 <chellomere> > "我住在荷兰"
06:30:49 <lambdabot>   "\25105\20303\22312\33655\20848"
06:31:23 <koeien37> yeah that seems correct
06:31:33 <koeien37> just the I/O functions that mess up
06:31:49 <xerox> therp: what if you lift it to the top level and ask ghc?
06:31:53 <zygoloid> chellomere: another way of looking at it is that GHC (in 6.10 and before) always (by default?) encodes/decodes as latin1 in its IO layer
06:31:58 <koeien37> > ord '国'
06:31:59 <lambdabot>   22269
06:32:59 <koeien37> ë is also mangled by my ghci
06:33:05 <therp> xerox: then I get g :: (a -> t) -> Mu a -> t
06:33:05 <chellomere> zygoloid, hmm. the characters I want are present in latin1 too, I could perhaps feed it that too
06:33:15 <therp> xerox: (making f the first parameter)
06:33:25 <chellomere> > ''
06:33:26 <lambdabot>   '\65533'
06:33:48 <koeien37> > 'ë'
06:33:49 <lambdabot>   '\235'
06:34:03 <therp> xerox: f :: (a -> a) the type of g should be Mu a -> a but that fails here
06:34:05 <xerox> therp so a = (b->b) and t =b 
06:34:25 <Axman6> oh, is 6.12.1 out?
06:34:28 <Axman6> yes, it is :O
06:34:29 <copumpkin> yep!
06:34:34 <koeien37> zomg zomg zomg
06:34:35 <zygoloid> therp: g (Roll g) alone implies that g :: Mu a -> a
06:34:38 <Axman6> how'd i miss that?
06:34:46 <therp> xerox: the problem is that "a" is considered free in the type expression, although what is require here that a is equivalent to the a from the type of fix
06:34:52 <koeien37> it's on the mailing list
06:34:58 <chellomere> the bot expects utf-8 as input? or why would a latin-1  be \65533?
06:35:03 <Axman6> i don't read the mailing list
06:35:24 <zygoloid> therp: you can't actually annotate the type of g without a language extension. you need ScopedTypeVariables, and you need to add a 'forall a.' to the type of fix.
06:35:27 <koeien37> maybe nice addition to /topic ?
06:35:30 <therp> zygoloid: that fails with http://pastebin.com/m6475a0b5
06:35:40 <xerox> therp: I mean, fix :: (a -> a) -> a and g :: (b -> c) -> Mu b -> c,  then g fix makes b = (a -> a) and c = a
06:35:45 <therp> zygoloid: thanks that's what I suspected that this isn't possible in h98
06:35:55 <koeien37> dynamic linking, unicode, nice!
06:37:09 <therp> xerox: hm, sorry I don't get that. "g fix"?
06:37:33 <xerox> therp: nevermind me
06:38:35 <therp> zygoloid: with ScopedTypeVars it works nicely (and forall a in the typesig of fix)
06:45:05 <mreh> :t (%)
06:45:06 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
06:45:14 <mreh> -3 % 5
06:45:19 <mreh> > -3 % 5
06:45:20 <lambdabot>   (-3) % 5
06:45:28 <mreh> wut?
06:45:35 <koeien37> why does this surprise you?
06:46:02 <mreh> in modular arithmetic -3 = 2 (mod 5)
06:46:13 <koeien37> this is not about modular arithmetic
06:46:20 <koeien37> but about fractions
06:46:26 <mreh> :t mod
06:46:27 <lambdabot> forall a. (Integral a) => a -> a -> a
06:46:34 <mreh> maybe that's what I need?
06:46:36 <koeien37> > mod (-3) 5
06:46:37 <copumpkin> lol
06:46:37 <lambdabot>   2
06:46:38 <koeien37> yes.
06:47:03 <koeien37> as long as your b is positive, a `mod` b is going to be nonnegative within [0..b-1]
06:47:14 <koeien37> i don't know what happens if b is negative, i never use that case
06:47:30 <mreh> i was looking for an elegant way of making my asteroids space ship wrap round
06:47:39 <quicksilver> mreh: % is not the % from C.
06:47:40 <EvanR-work> > mod 5 (-3)
06:47:41 <lambdabot>   -1
06:47:44 <mreh> modular arithmetic seemed the best
06:47:44 <quicksilver> C's % is mod.
06:48:00 <quicksilver> haskell's % is the Rational type
06:48:16 <koeien37> quicksilver: well, yeah, almost
06:48:40 <koeien37> i hate C's behavior w.r.t. negative a in a % b
06:49:42 <profmakx> > mod (-3) 5
06:49:43 <lambdabot>   2
06:49:52 <mreh> why isn't mod infix?
06:49:53 <mreh> strange
06:49:54 <profmakx> is this well defined behaviour?
06:50:03 <mreh> (-3) `mod` 5
06:50:06 <koeien37> mreh: mod is just a normal Haskell function
06:50:07 <profmakx> > (-3) `mod` 5
06:50:08 <lambdabot>   2
06:50:14 <profmakx> you can make it infix if you like
06:50:27 <zygoloid> > let (%) = mod in 5 % 3
06:50:28 <lambdabot>   2
06:50:41 <tofulivin> > let (%) = mod in 5 % 3
06:50:42 <lambdabot>   2
06:50:45 <profmakx> so does "mod" always return the non-negative remainder?
06:50:47 <mreh> @google modulo arithmetic
06:50:48 <edwardk_> is this john earle guy on haskell-cafe a troll or does he just like to have the community do his reading for him?
06:50:49 <lambdabot> http://en.wikipedia.org/wiki/Modular_arithmetic
06:50:49 <lambdabot> Title: Modular arithmetic - Wikipedia, the free encyclopedia
06:50:57 <EvanR-work> > (+7) `map` [0..5]
06:50:58 <lambdabot>   [7,8,9,10,11,12]
06:51:06 <copumpkin> edwardk: he's a crank
06:51:09 <zygoloid> edwardk_: troll, i think
06:51:19 <copumpkin> edwardk: he sent some really crackpotty emails earlier
06:51:19 <koeien37> troll imo
06:51:28 <koeien37> troll/crank, w/e
06:51:32 <tofulivin> >  let evan = 5 in evan + evan
06:51:34 <lambdabot>   10
06:51:35 <copumpkin> I don't think he's trying to piss people off, I think he's just crazy
06:51:39 <copumpkin>  / arrogant
06:51:40 <koeien37> i ignore those threads
06:51:49 <copumpkin> it's sad he got such a huge response
06:51:52 <koeien37> yeah
06:51:55 <edwardk_> copumpkin: yeah
06:52:19 <Heffalump> he did calm down a lot after a lot of people were rude
06:52:38 <mreh> Eugene, by purity do you mean effect free? There is a subtle difference. The lack of effects makes a language functional, but this does not imply that the language is pure.
06:52:49 <mreh> is that true?
06:53:05 <vy> In http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html why does the first ":load Parse" command compiles PNM.hs as well? What's the binding between two modules?
06:53:07 <koeien37> i would say no
06:53:07 <HugoDaniel> referential transparency
06:53:24 <koeien37> depends on what you consider an "effect"
06:53:24 <mreh> he's your typical pseudo intellectual
06:53:34 <copumpkin> we had shelby moore earlier
06:53:38 <koeien37> Haskell is not side effect free
06:53:41 <koeien37> > [1..]
06:53:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:53:42 <copumpkin> who's going to be the next one?
06:53:46 <edwardk_> > -2 `mod` 3
06:53:47 <lambdabot>   -2
06:53:49 <koeien37> i just heated my processor!
06:53:57 <copumpkin> koeien: then nothing is free of side effects
06:53:57 <koeien37> > (-2) `mod` 3 -- careful edwardk_
06:53:58 <lambdabot>   1
06:53:59 <edwardk_> > -2 `rem` 3
06:54:00 <lambdabot>   -2
06:54:06 <copumpkin> lol
06:54:06 <tofulivin> let koeien = 12 in [koeien..]
06:54:06 <xerox> mreh: functional language means functions are first class citizens, purity means no side effects, they to not imply or exclude one another
06:54:14 <edwardk_> hahaha
06:54:14 <tofulivin> >vlet koeien = 12 in [koeien..]
06:54:16 <koeien37> copumpkin: yeah. :)
06:54:22 <tofulivin> > let koeien = 12 in [koeien..]
06:54:23 <lambdabot>   [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36...
06:54:25 <medfly> :]
06:54:26 <dolio> ddarius++
06:54:26 <copumpkin> for me functional means expression/LC-based
06:54:27 <mreh> xerox: ah, ok
06:54:34 <edwardk_> koeien37++
06:54:38 <koeien37> one could have a pure imperative language.
06:55:10 <copumpkin> lots of karma here
06:55:16 <copumpkin> edwardk++
06:55:25 <Philonous1> koeien37: Haskell is side-effect free in the sense that side effects can't be observed in the language. The runtime system on the other hand may very well observe them.
06:55:39 <xerox> imperative/declarative is another dimension as well
06:55:43 <edwardk_> koeien37: sure, but its kinda annoying, because of the extra logarithmic factor you get stuck with on a bunch of algorithms
06:56:21 <tofulivin> > fromIntegral (length "edwardk has 12 ferraris") + 12
06:56:23 <lambdabot>   35
06:56:36 <koeien37> i don't know of a pure imperative language though
06:56:36 <edwardk_> and the fact that there are no pun intended, strictly fewer optimizations you can perform ;)
06:56:42 <edwardk_> tofulivin: not any more ;)
06:56:47 <mreh> TIMECUBE!
06:58:17 <quicksilver> surely haskell is side-effect free in the sense that evaluating expressions doesn't have side effects.
06:58:23 <quicksilver> is that not the point?
06:58:47 <mreh> where does IO fit into that though?
06:58:51 <koeien37> there are some things i find annoying in Haskell though :(
06:58:55 <mreh> such a programming language is useless
06:59:17 <koeien37> i sometimes want to say, import FiniteField where prime = 37
06:59:18 <mreh> oh, runtime system
06:59:37 <dolio> As Jon Harrop has showed, extra log factors are totally unacceptable. :)
06:59:58 <mreh> sometimes I find it hard to understand anything that is written on this channel
06:59:59 <edwardk_> mreh: io is clearly just a free monad, where some external agent is reading the outermost constructor, acting on the world, and then calling the continuation with the result.
07:00:01 <tofulivin> maxBound :: Char
07:00:08 <tofulivin> > maxBound :: Char
07:00:09 <lambdabot>   '\1114111'
07:00:27 <mreh> didn't understand that
07:00:44 <tofulivin> > reverse "mreh"
07:00:45 <lambdabot>   "herm"
07:00:59 <tofulivin> > reverse "mreh" ++ "it"
07:00:59 <mreh> but I think I understand the difference between referential transparency and the opposite
07:01:00 <lambdabot>   "hermit"
07:01:10 <koeien37> the opposite?
07:01:11 <mreh> oh noes! I've been discovered!
07:01:33 <Berengal> Haskell makes a difference between evaluation and execution. Evaluation is side-effect-free, execution isn't
07:01:34 <mreh> yeah, C functions are not referentially transparent
07:01:34 <zygoloid> koeien37: Disciple is kinda a pure imperative language
07:01:44 <zygoloid> koeien37: but it really depends what you mean by 'imperative'
07:02:05 <koeien37> zygoloid: never heard of it
07:02:07 <heoa> 8
07:02:09 <heoa> 5
07:02:15 <Berengal> This is made apparent in that you can seq getLine as much as you want, but nothing happens
07:02:16 <heoa> sorry
07:02:25 <mreh> Berengal: what's the difference between execution and evaluation of Haskell? To me they are the same
07:02:41 <koeien37> execution as in "performing I/O actions"
07:02:51 <koeien37> is different from evaluating said actions
07:02:52 <dolio> If Disciple is imperative, I don't really see how Haskell isn't.
07:02:53 <mreh> oh, k
07:02:56 <Berengal> mreh: When you evaluate an expression you reduce it to normal form. You can't execute expressions, only IO values
07:03:25 <zygoloid> mreh: evaluation of 'if fib 5 == 42 then putLine "42!" else putLine "not 42!"' results in a value of type IO (); execution of it prints a string.
07:03:38 <Berengal> mreh: Evaluating "3 + 5" you get "8". Evaluating "getLine" you get "A program that fetches a line from stdin"
07:04:11 <mreh> right
07:04:20 <Berengal> Just evaluating an IO value doesn't execute it, and values that aren't of type IO can't be executed, since they don't contain instructions
07:04:26 <koeien37> > "3 + 5" -- couldn't resist
07:04:27 <lambdabot>   "3 + 5"
07:04:48 <mreh> read "3 + 5"
07:04:50 <mreh> > read "3 + 5"
07:04:51 <lambdabot>   * Exception: Prelude.read: no parse
07:04:59 <Berengal> > getLine
07:05:00 <lambdabot>   <IO [Char]>
07:05:08 <Berengal> > repeat getLine
07:05:09 <lambdabot>   [<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<I...
07:05:13 <koeien37> hmm
07:05:15 <mreh> so lambdabot only evaluaties
07:05:16 <Berengal> lambdabot only does evaluation
07:05:19 <zygoloid> dolio: yeah, i think it's a pretty subtle distinction.
07:05:22 <mreh> :D
07:05:31 <koeien37> :t (read "3+5") -- i thought this would be ambiguous
07:05:33 <lambdabot> forall a. (Read a) => a
07:05:39 <koeien37> to what does it default?
07:05:42 <Berengal> koeien37: Defaults to ()
07:05:50 <zygoloid> > read "3+5"
07:05:51 <lambdabot>   * Exception: Prelude.read: no parse
07:05:51 <Berengal> > read "()"
07:05:52 <lambdabot>   ()
07:06:00 <koeien37> oh of course
07:06:14 <koeien37> what else? :)
07:07:19 <Berengal> Also, [1..] doesn't heat up your machine. Haskell's lazy ;)
07:07:33 <fizruk1> > [1..]
07:07:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:08:05 <edwardk> mreh: got disconnected, but to clarify what i was talking about, perhaps it is easiest to just point you to a reference. see wouter's 'data types a la carte' paper
07:08:25 <quicksilver> hmm. two edwardks. Is that safe?
07:08:30 <mreh> uhoh
07:08:40 <edwardk> we're pure.
07:08:42 <mreh> I coundt three
07:08:43 <copumpkin> :O
07:08:52 <mreh> oh, i'm mistaken
07:08:54 <copumpkin> mreh: is seing 1.5ble
07:09:19 <mreh> 7.5 edwarks!
07:09:25 <mreh> i must be seeing 1.5ble
07:10:56 <mreh> I thought you wrote 2.5ble, then wrote 1.5ble
07:11:08 <mreh> myself
07:11:41 <mreh> i'm wasting time on this channel
07:11:45 <koeien37> me too
07:12:04 <edwardk> i think we all are, by construction ;)
07:12:29 <fizruk1> can someone help me to parse "int i;"?
07:13:03 <copumpkin> fizruk1: not sure what you mean
07:13:24 <mreh> i just deleted my facebook for the same reason
07:13:32 <copumpkin> mreh: intense!
07:13:32 <Berengal> string "int" <* space *> char 'i' <* char ';'
07:13:32 <leimy> Wow, I'm seriously looking forward to GHC 6.13's Dtrace capabilities
07:13:35 <mreh> I think I might disconnect the internet
07:13:38 <leimy> that's just amazingly cool
07:13:49 <mreh> i have a week to log back in
07:13:50 <copumpkin> leimy: yeah, pity dtrace isn't available on most platforms :(
07:13:54 <stoop> heh
07:14:06 <mreh> then it's byebye rubbish photos and 300 people I don't even know
07:14:06 <koeien37> mreh: why?
07:14:09 <fizruk1> the problem is that i have lexems: "int" "i" ";" and when parsing "i" i don't know whether it is user type or variable name
07:14:11 <stoop> Why can't we use something like oprofile at present, copumpkin?
07:14:21 <stoop> I also wonder why the dtrace probes don't work for Solaris.
07:14:37 <copumpkin> stoop: they don't?
07:14:37 <fasta> fizruk1, in C you know it is a variable name, no?
07:14:40 <mreh> facebook is completely pointless, my life has not improved anyway shape or form by using it
07:14:45 <stoop> After my exams are over I'm going to spend some time to improve GHC support for Solaris, at least in the form of high quality packages.
07:14:54 <mreh> i just waste time on facebook, that's the point of facebook
07:14:58 <stoop> copumpkin, according to the WiKi entry, only Mac OS X is supported.
07:14:59 <leimy> copumpkin: true, but for us Mac guys, that's just amazing :-)
07:15:04 <fizruk1> fasta: no, it can be struct name, for example
07:15:05 <koeien37> mreh: i don't have facebook :) i waste time iin other ways
07:15:08 <leimy> I don't know if Dtrace is on FreeBSD
07:15:08 <copumpkin> yeah :) it's fine for me
07:15:21 <fasta> fizruk1, int struct i? I doubt that.
07:15:30 <stoop> leimy, it is, but user-space support is very rudimentary. No one has spent time working with probes there (and there are some other issues).
07:15:38 <stoop> leimy, kernel-space support is pretty decent on the other hand.
07:15:40 <fasta> fizruk1, you can have struct bar foo, though.
07:15:44 <fizruk1> fasta: stuct i {int x}; int i a;
07:15:52 <leimy> stoop: interesting.
07:15:56 <stoop> copumpkin, fine for you?
07:15:57 <fizruk1> fasta: sorry...
07:16:03 <copumpkin> stoop: I'm a mactard
07:16:03 <stoop> copumpkin, as in you are using them on Solaris?
07:16:04 <leimy> since I'm unemployed now maybe I can secure funding to make that work better -)
07:16:06 <fasta> fizruk1, so, just handle the different cases.
07:16:07 <stoop> copumpkin, oh.
07:16:13 <leimy> company fired everyone on friday :-)
07:16:24 <leimy> just in time for xmas
07:16:26 <stoop> copumpkin, out of curiosity, were you ever a Ruby programmer?
07:16:31 <copumpkin> stoop: I was!
07:16:40 <stoop> copumpkin, typical Mac nerd.
07:16:41 <copumpkin> oh, and I had a goatee and a 2.0 website with rounded corners
07:16:45 <stoop> haha
07:16:46 <stoop> !
07:16:48 <stoop> <3
07:16:49 <Heffalump> leimy: :-(
07:16:50 <copumpkin> with a starburst beta
07:16:54 <copumpkin> but I changed my evil ways
07:16:57 <copumpkin> and am now reformed
07:16:58 <stoop> and a twitter?
07:17:02 <copumpkin> stoop: I still have that
07:17:09 <copumpkin> :(
07:17:11 <stoop> Oh.
07:17:25 <leimy> Heffalump: yeah I was bummed at first too.  :-)
07:17:40 <leimy> now I'm just sort of enjoying a few moments of freedom.  And I've got a contract I'm working to get me through the holidays
07:17:44 <fasta> fizruk1, why are you writing a C parser btw? There exist a few already.
07:17:49 <leimy> but come February I'll need to get something more stable.
07:18:06 <leimy> also i've been interviewing at Amazon for their AWS department... I'm very hopeful that turns into something.
07:18:13 <koeien37> any unemployment grants in your country?
07:18:30 <leimy> yeah they have that, but since I've been working on this contract I'm self-employed so I don't think I qualify
07:18:40 <leimy> and i've never been good about taking hand outs if I can help myself.
07:18:48 <koeien37> of course.
07:18:49 <copumpkin> stoop: you should get twitter ;)
07:18:55 <leimy> I know many people who have no choice and have to.
07:19:02 <leimy> so I feel very fortunate actually.
07:19:03 <copumpkin> stoop: don't you already have a goatee? you just need a starburst and rounded corner
07:19:09 <stoop> copumpkin, I would rather not.
07:19:19 <stoop> copumpkin, well, I did at one point.
07:19:24 <Berengal> copumpkin: What's so wonderful about twitter?
07:19:25 <stoop> copumpkin, but it was an Arab goatee not a Mac goatee.
07:19:52 <stoop> copumpkin, haha, I might add a shiny "Web 2.0" sticker to my website, that would be hilarious.
07:19:54 <fizruk1> fasta: i should  try to get into real parsers, i think
07:20:03 <copumpkin> Berengal: bite-sized information from people I'm interested in, different from blogs from them in that they write a lot more spontaneous things, interesting links, random thoughts on them
07:20:17 <copumpkin> Berengal: not for everyone, but gives me a good way to keep track of things in the background
07:20:30 <copumpkin> stoop: damn, you need to work on your 2.0-ness
07:20:32 <tofulivin> reverse "stoop"
07:20:37 <tofulivin> > reverse "stoop"
07:20:38 <lambdabot>   "poots"
07:20:49 <copumpkin> @check ap (==) reverse
07:20:49 <lambdabot>   "OK, passed 500 tests."
07:20:51 <copumpkin> zomg!
07:21:11 <tofulivin> @check ap (==) map
07:21:12 <xerox> must be list of ()
07:21:14 <Berengal> To me the term "microblogging" doesn't make much sense. What's the point of having a website if you can't use 3000 words or more to describe something?
07:21:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
07:21:19 <tofulivin> > @check ap (==) map
07:21:20 <lambdabot>   <no location info>: parse error on input `@'
07:21:20 <copumpkin> Berengal: and I do tend to avoid the tweeters who write "taking a dump. wow, that was a great dump. biggest dump I've taken in 8 days."
07:21:23 <Berengal> For everything else, there's IRC
07:21:43 <jd10> > 1+1
07:21:44 <lambdabot>   2
07:21:56 <tofulivin> :t reverse
07:21:57 <lambdabot> forall a. [a] -> [a]
07:21:57 <copumpkin> Berengal: because sometimes you have ideas you just want to put out there without putting much effort into them. It reduces the barrier to entry, without the pressure to have a well-developed blog post on them
07:22:00 <mreh> is there a mod for Rational types?
07:22:05 <stoop> I rarely find substantial tweets, copumpkin. :-)
07:22:13 <copumpkin> stoop: you should check out the people I follow
07:22:17 <edwardk> leimy: me too, too bad linux doesn't have dtrace. systemtap seems to be a poor replacement - at least since its userspace isn't really ready
07:22:21 <stoop> copumpkin, example?
07:22:36 <Berengal> copumpkin: I'm fond of my internal censorship. Make me look not as dumb as I would otherwise.
07:22:42 <copumpkin> http://twitter.com/copumpkin/following
07:23:14 <copumpkin> sure, not all of the tweets are profound
07:23:28 <copumpkin> but if I find that someone's tweets tend to not interest me I just stop following them
07:23:32 <stoop> systemtap seems interesting.
07:24:27 <edwardk> stoop: but it also has a bit of that "different for different's sake" feel to it.
07:24:33 <stoop> edwardk, oprofile is alright (but also not a replacement).
07:24:37 <tofulivin> sum [x | x <- [1..1000], x 'mod' 3 == 0 || x 'mod' 5 == 0]
07:24:38 <stoop> edwardk, yes, I looked at some example scripts.
07:24:46 <tofulivin> > sum [x | x <- [1..1000], x 'mod' 3 == 0 || x 'mod' 5 == 0]
07:24:47 <lambdabot>   <no location info>:
07:24:48 <lambdabot>      lexical error in string/character literal at chara...
07:25:01 <edwardk> i looked at the example scripts and some made me wince. they work around the lack of structs by just using lots of arrays.
07:25:35 <koeien37> tofulivin: replace ' by `
07:25:43 <koeien37> ' is for character literals
07:26:19 <stoop> edwardk, hrm?
07:26:22 <tofulivin> > sum [x | x <- [1..1000], x `mod` 3 == 0 || x `mod` 5 == 0]
07:26:23 <lambdabot>   234168
07:26:27 <stoop> edwardk, it looks like they support some kind of structure.
07:26:37 <edwardk> stoop: maybe it was just that script
07:26:44 <stoop> edwardk, http://sourceware.org/systemtap/examples/general/badname.stp
07:26:55 <stoop> edwardk, you can't define a structure, but you can access them in dtrace.
07:27:05 <stoop> edwardk, so you end up using arrays to cache this data.
07:28:01 <tofulivin> > sum (map digitToInt (show (2^2000)))
07:28:02 <lambdabot>   2704
07:28:15 <copumpkin> > foldl1 lcm [1..10]
07:28:16 <lambdabot>   2520
07:29:33 <edwardk> stoop: what i was referring to was their penchant for:   delete fileread[pid(), $fd]   delete filewrite[pid(), $fd]   delete filehandles[pid(), $fd] ... as an idiom
07:30:06 <stoop> edwardk, note, I was incorrect.
07:30:16 <stoop> edwardk, it turns out it is perfectly valid, http://wikis.sun.com/display/DTrace/Structs+and+Unions
07:30:19 <blueonyx> > lcm 0 []
07:30:20 <lambdabot>   No instance for (GHC.Real.Integral [a])
07:30:20 <lambdabot>    arising from a use of `GHC.Real....
07:30:21 <tofulivin> !seen Cale
07:30:32 * stoop hasn't used dtrace in a while
07:30:46 <leimy> I don't really understand why Linus doesn't sometimes go with the flow of work that's already done and good in other platforms
07:30:47 <stoop> edwardk, I just recently switched to Solaris in order to use dtrace for my current project. :-P
07:30:49 <blueonyx> > lcm [] 0
07:30:50 <lambdabot>   No instance for (GHC.Real.Integral [a])
07:30:50 <lambdabot>    arising from a use of `GHC.Real....
07:30:53 <leimy> I mean, kqueues are really nice
07:30:54 <stoop> edwardk, I see.
07:30:57 <copumpkin> stoop: zomg
07:30:58 <tofulivin> > lcm [1..20]
07:30:59 <leimy> but epoll doesn't quite get you to kqueue
07:31:00 <lambdabot>   No instance for (GHC.Real.Integral [t])
07:31:00 <lambdabot>    arising from a use of `GHC.Real....
07:31:03 <blueonyx> @type lcm
07:31:04 <lambdabot> forall a. (Integral a) => a -> a -> a
07:31:06 <edwardk> i never really had a call to. haven't touched solaris in several years
07:31:11 <koeien37> > foldl1 lcm [1..20]
07:31:11 <tibbe> is there any released version of Cabal that works with GHC 6.12.1 or do I have to go with HEAD?
07:31:12 <lambdabot>   232792560
07:31:19 <blueonyx> > lcm 1 2
07:31:20 <lambdabot>   2
07:31:21 <Philonous> Someone should change the topic to mention that ghc 6.12 is released
07:31:23 <leimy> People suggested kqueue to Linus and he said "check out this epoll idea..." instead
07:31:23 <stoop> edwardk, some very nice improvement areas, recently, for the workstation experience.
07:31:27 <blueonyx> > lcm 2 3
07:31:28 <lambdabot>   6
07:31:29 <leimy> I'm not sure if it's just ego, or what.
07:31:29 <edwardk> so iirc it was just coming out when i stopped using it
07:31:40 <stoop> leimy, epoll is nice.
07:31:41 <blueonyx> > lcm 6 4
07:31:42 <lambdabot>   12
07:31:45 <leimy> stoop: yes it's nice
07:31:51 <leimy> stoop: but kqueues get you a lot more functionality
07:31:55 <stoop> leimy, kqueue is great, but I think it is over-generalized.
07:32:03 <leimy> it's a very general interface :-)
07:32:06 <leimy> yes
07:32:15 <tofulivin> preflex: xseen Cale
07:32:15 <preflex>  Cale was last seen on freenode/#haskell 2 hours, 23 minutes and 31 seconds ago, saying: There are a lot of natural numbers, and almost all of them are very large. :)
07:32:16 <leimy> However, Unix is built on generalizations :-)
07:32:20 <leimy> look at file descriptors
07:32:22 <leimy> and files
07:32:27 <edwardk> stoop: i saw the ghc dtrace announcement and so i decided to go see what would be involved doing something similar for my project, but being on linux, i'm out of luck ;)
07:32:39 <Baughn> So.. I can delete ghc-5.4 now, right?
07:32:55 <stoop> edwardk, maybe you should give it a shot?
07:32:59 <leimy> In fact, I bet you could eventually design a system that had no file descriptors in the normal sense, and just provided kqueue handles :-)
07:33:13 <leimy> and still build a unix like thing out of it.
07:33:15 * Baughn found that in ~/backups/home/svein/backups/ ...
07:33:16 <stoop> leimy, not very useful.
07:33:29 <edwardk> stoop: the problem is systemtap doesn't seem to have a userspace component, and its existence seems to have stalled any work on a viable dtrace port
07:33:48 <Berengal> Baughn: Wow, backus of the backups?
07:33:50 <edwardk> stoop: er thats not entirely true. the cddl vs. gpl seems to have caused the latter.
07:33:57 <stoop> edwardk, yes.
07:33:59 <Baughn> Berengal: Yeah..
07:34:01 <leimy> I'd much rather have a kqueue interface than 9 interfaces for 9 things :-)
07:34:01 <Jonno_FTW> how can i test if a triangle contains the origin?
07:34:12 <Baughn> Berengal: A backup of a backup of a long-dead laptop
07:34:14 <stoop> edwardk, user-space probes are the bitch to justify.
07:34:15 <koeien37> Jonno_FTW: depends on your representation of a triangle
07:34:16 <edwardk> and there is a stub for userspace stuff in systemtap that works under some arcane configuration
07:34:28 <stoop> edwardk, because Linux is so fragmented (different projects for different components).
07:34:30 <Jonno_FTW> 3 sets of 2 points
07:34:43 <koeien37> you mean, 3 points in the plane?
07:34:47 <Jonno_FTW> [x1,y1,x2,y2,x3,y3]
07:34:50 <Jonno_FTW> yep
07:34:59 <Jonno_FTW> in the cartesian plane
07:35:27 <romand> http://codepad.org/ZGAhGtOf
07:35:43 <tofulivin> preflex: xseen Paczesiowa
07:35:43 <preflex>  Paczesiowa was last seen on freenode/#haskell 13 hours, 40 minutes and 33 seconds ago, saying: > find even [1,3,5,6]
07:35:44 <stoop> leimy, I prefer kqueue as well, but epoll isn't that bad.
07:35:45 <romand> how should this be done right?
07:35:54 <leimy> stoop: no epoll is not bad
07:36:00 <leimy> stoop: I didn't want to claim it was
07:36:01 <tofulivin> > find even [1, 3, 5, 6]
07:36:02 <lambdabot>   Just 6
07:36:21 <leimy> stoop: I will say that someone is making a kqueue wrapper around epoll so linux can have libdispatch
07:36:48 <Baughn> "You can omit the "$" in a top-level TH splice" <- Ooh
07:36:57 <Jonno_FTW> i found one method using baryocentric points but i didn't get it
07:37:02 <tofulivin> > let leimy = 6 in find even [1, 3, 5, leimy]
07:37:03 <lambdabot>   Just 6
07:37:31 <leimy> :-)
07:37:37 <Berengal> romand: You need to take a parameter of type a, otherwise you have no way of selecting which instance should be used
07:37:44 <edwardk> Baughn: yeah. that one made me very happy =)
07:37:50 <stoop> leimy, libdispatch is such a simple idea, I am surprised no one has provided some general facility for this to begin with.
07:38:11 <Baughn> edwardk: Although, it doesn't mention if I can also omit the parantheses
07:38:15 <leimy> Yeah. it's just work queues, each assigned to a thread
07:38:19 <leimy> and they can run in parallel
07:38:23 <stoop> leimy, I usually write a similar facility (of course, no blocks) for every highly concurrent application I work on.
07:38:27 <stoop> leimy, yes.
07:38:30 <leimy> work on the queue is serialized, reducing the need to write locking code.
07:38:38 <stoop> leimy, with some nice performance advantages (though there is additional room for optimization).
07:38:43 <romand> Berengal: the idea is to use biection between my type and character sequence
07:38:43 <leimy> Of course every concurrent system I've written almost always followed that pattern.
07:38:53 <Baughn> edwardk: And.. I'm not really /sure/, but TH calls still need to use valid haskell syntax, right?
07:39:03 <leimy> the nice thing about those libdispatch queues is that they give me primitives up front.
07:39:06 <edwardk> yeah, its still haskell
07:39:08 <romand> Berengal: and make instances of Show and Read on base of this biection
07:39:18 <Baughn> edwardk: So, no writing a "myData" syntax
07:39:28 <leimy> I wrote several versions of a concurrent prime sieve with libdispatch
07:39:29 <edwardk> Baughn: you can define stuff like
07:39:32 <romand> instead of writing those instances for each such type
07:39:32 <Berengal> romand: Yes, but you have no way of deciding the type of 'a' when you use 'charseq', unless the class parameter 'a' is found somewhere in the signature for 'charseq'
07:39:35 <tofulivin> preflex: xseen HaskellLove
07:39:36 <preflex>  HaskellLove was last seen on freenode/#haskell 3 hours, 5 minutes and 10 seconds ago, saying: totally wrong, like what?
07:39:38 <leimy> if you do it with function pointers instead of blocks, it really flies!
07:39:39 <edwardk> (deriveWhatever 'Foo)
07:39:56 <leimy> doesn't have to const copy closures all over the place
07:40:16 <Baughn> edwardk: Yeah, but I was thinking of making a data-accessors variant where you don't need the _-prefixed version of the names at all
07:40:22 <Baughn> Which isn't doable
07:40:22 <romand> so, such 'type trait' is not possible in haskell?
07:40:26 <stoop> leimy, http://wiki.freebsd.org/200909DevSummit?action=AttachFile&do=get&target=20090918-devsummit-gcd-public.pdf is pretty decent if you're interested.
07:40:26 <leimy> I sent that code to a couple buddies of mine at apple who were working on that stuff.  It was quite fast.
07:40:32 <stoop> leimy, from the person who ported it to FreeBSD.
07:40:47 <leimy> stoop: Robert Watson and I email each other from time to time :-)
07:40:52 <Berengal> romand: The problem is that when you're using 'charseq', which instance should be chosen?
07:41:01 <stoop> leimy, oh.
07:41:05 <xerox> Jonno_FTW: nice problem
07:41:20 <leimy> he's an impressive fellow
07:41:21 <Jonno_FTW> yep
07:41:24 <stoop> Your name sounds familiar, in fact.
07:41:32 <leimy> stoop: oh?
07:41:38 <xerox> Jonno_FTW: I've got an idea, let me grab a piece of paper
07:41:39 <romand> Berengal: ok, I got it, typeclasses are not suitable here
07:41:50 <stoop> leimy, were you involved with OpenDarwin or similar? Or used to idle in the channel?
07:41:51 <romand> any ideas on what is suitable?
07:42:00 <Jonno_FTW> a few obvious things are that if all points have equal sign, it doesn't contain the origin
07:42:14 <leimy> stoop: yeah I used to work on OpenDarwin
07:42:20 <leimy> I still idle there :-)
07:42:29 <Berengal> romand: You can make it work with typeclasses by turning it into a function taking a dummy-value.
07:42:31 <stoop> Ok, I have a slight recollection of you. :-)
07:42:39 <leimy> cool!
07:42:49 <Jonno_FTW> it's from this
07:42:51 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=102
07:42:57 <leimy> as long as I don't owe you money...
07:43:16 <romand> Berengal: sounds like hack... also, what dummy value should I use in Read instance?
07:43:28 <romand> in readsPrec
07:43:55 <stoop> leimy, so, function pointers are faster than blocks?
07:44:13 <Berengal> romand: You can just use undefined, as long as you give it a type signature.
07:44:26 <stoop> leimy, I heard from some very unreliable source that blocks are faster than function pointers (and he had a pretty decent argument regarding context switch overhead).
07:44:36 <romand> oh... hm... thanks!
07:44:39 <stoop> leimy, I forget the details now.
07:44:46 <leimy> stoop: They're not faster :-)
07:44:50 <xerox> Jonno_FTW: pick two vertices, say A and B, and consider the vector BA. for each point P consider PA x BA. The sign of the cross product is the same as the one of CA x BA for all points P that lie in the same half-plane of C (bounded by the line through A and B), it is the opposite sign for all the points that line in the other half-plane.
07:44:51 <leimy> I have proof :-)
07:44:52 <stoop> leimy, could you share the source-code of your sieves thing?
07:44:55 <leimy> yep
07:44:57 <leimy> hang on
07:45:06 <stoop> leimy, thanks.
07:45:10 <jlouis> Jonno_FTW: that one isn't too hard if you look at barycentric coordinates
07:45:27 <leimy> also, my friend Kevin at apple, and Jordan Hubbard both could explain why blocks are not always faster
07:45:35 <leimy> they've been working libdispatch for a while.
07:45:52 <stoop> Sure, of course.
07:45:56 <stoop> Everything is a trade-off.
07:46:04 <Jonno_FTW> hmm
07:46:06 <xerox> Jonno_FTW: (0,0) lies together with C wrt the line through A and B, lies with A wrt the line through B and C, and lies with B wrt the line through C and A, then it's inside the triangle.
07:46:23 <leimy> stoop: http://paste.lisp.org/display/86549
07:46:30 <leimy> there's 7 versions there :-)
07:46:49 <Jonno_FTW> hmmm
07:46:53 <Baughn> stoop: Since I seem to be completely lost - can you give me a reference for what is meant by "blocks" in this conversation? :)
07:47:07 <leimy> I started by trying to use pipes between queues as an event source.  Almost CSP-style
07:47:11 <stoop> leimy, thanks. I'll play with them soon.
07:47:12 <leimy> but that doesn't scale well :-)
07:47:52 <stoop> Baughn, similar to closures.
07:48:11 <stoop> Baughn, f = ^(void){poop();}
07:48:19 <stoop> Baughn, ;
07:49:09 <stoop> Baughn, they are provided as an extension to C and can be leveraged by libdispatch for dispatching work.
07:49:24 <Baughn> ..interesting
07:49:33 <stoop> Baughn, dispatch_async(queue, ^{dothis();});
07:49:40 <stoop> Baughn, haha, my first thoughts. :-)
07:49:53 <Baughn> (But I don't see why it would be faster than function pointers. Or slower.)
07:50:26 <pikhq> Baughn: They're just a bit less annoying to work with than function pointers.
07:50:36 <edwardk> Baughn: because of the lack of gc they have to jump through some hoops to get it all to work out nicely
07:50:38 <stoop> Baughn, I can't think of a reason now, either.
07:51:22 <stoop> Baughn, if you're interested, http://importantshock.wordpress.com/ is the person who gave me some reasons for it (I wasn't completely sold and I shortly forget the inane argument I was provided).
07:51:22 <Baughn> edwardk: Well, I figured it'd just copy any referenced values by value
07:52:09 <stoop> Baughn, (I can only think of reasons for it to be slower)
07:52:47 <edwardk> stoop: not the best person to have argue your case, the first article is a complete misunderstanding about jquery being a monad ;)
07:53:00 <stoop> edwardk, yes, yes. :-)
07:53:15 <stoop> edwardk, well, it was his case.
07:53:46 <stoop> edwardk, overzealous. :-)
07:53:59 <stoop> Anyways, I have to study now. Interesting discussions today :)
07:54:06 <stoop> Bye, thanks for sharing leimy
08:05:54 <Jonno_FTW> i still don't get this barycentric coordinates stuff
08:06:20 <Jonno_FTW> does each triangle have on unique point which is barycentric?
08:07:14 <Saizan> b1the barycenter is unique, yes
08:07:33 <Jonno_FTW> ko
08:08:17 <Jonno_FTW> then how can i find the barycenter given the vertices of a triangle?
08:09:18 <Saizan> http://en.wikipedia.org/wiki/Centroid <-
08:10:18 <Jonno_FTW> thanks
08:10:36 <Saizan> it seems you just take the means of each coordinate
08:10:47 <Jonno_FTW> yep
08:10:52 <EvanR-work> brain <- read http://en.wikipedia.org/wiki/Centroid >>= return brain
08:11:27 <xerox> Jonno_FTW: does incident to a side or a vertex count as inside?
08:11:47 <Jonno_FTW> i don't know, the question doesn't state explicitly
08:11:59 <pikhq> EvanR-work: ... == read http://en.wikipedia.org/wiki/Centroid
08:12:14 <pikhq> :P
08:12:26 <b_jonas> ghc version what?
08:12:38 <b_jonas> it's 6.12.1 already?
08:13:02 <b_jonas> is it because 6.12.0 was a devel release or have I just not been paying attention?
08:13:10 <EvanR-work> this morning i went into the kitchen to make cereal, but i deleriously wanted to do (milkCereal, milk') <- pour cereal milk
08:13:24 <xerox> Jonno_FTW: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14168#a14168
08:13:42 <xerox> Jonno_FTW: this counts points on the sides or vertices as inside
08:14:34 <pikhq> b_jonas: Yes.
08:15:43 <edwardk> evanR: apply a monad law ;)
08:15:50 <edwardk> er pikhq beat me to it
08:16:27 <zygoloid> EvanR-work: sounds like you want to be using the StateT Milk monad transformer...
08:16:43 <b_jonas> thanks
08:16:52 <EvanR-work> lol
08:16:53 <b_jonas> I should have anticipated that reply
08:17:44 <zygoloid> EvanR-work: do milkCereal <- StateT $ pour cereal
08:18:20 <edwardk> @seen gwern
08:18:24 <Jonno_FTW> i got
08:18:26 <Jonno_FTW> barycentre [x1,y1,x2,y2,x3,y3] = ((x1+x2+x3)`div`3),((y1+y2+y3)`div`3)
08:18:29 <zygoloid> preflex: seen gwern
08:18:29 <preflex>  gwern was last seen on #haskell 15 hours, 3 minutes and 8 seconds ago, saying: @flush
08:18:36 <lambdabot> Unknown command, try @list
08:18:49 * hackagebot upload: explicit-iomodes 0.1 - File handles with explicit IOModes (BasVanDijk)
08:21:59 <Jonno_FTW> what do i do next?
08:22:30 <EvanR-work> zygoloid: well then the milkCereal is carrying around the state of the milk, but in my case they were very much separated after i put the milk' up
08:27:17 <fasta> What is the point of writing a paper of 4 pages when the dissertation describes the same thing in 30 pages? I don't think anyone can do anything useful with just the 4 pages.
08:28:24 <EvanR-work> executive summary
08:29:00 <EvanR-work> each sentence must be a gross simplified generalization ;)
08:29:50 <yaxu> put the dissertation in an 'on-line appendix'
08:29:57 <yaxu> and make the paper the introduction
08:30:24 <fasta> Each sentence is written as if it is completely obvious (yeah, right!), and there are references to sub-routines that are not defined (this one is very funny). I am just glad I found the non-decapitated version.
08:30:26 <Jonno_FTW> xerox i can't follow what you did
08:31:16 <xerox> Jonno_FTW: do you know the cross product in R^3 ?
08:31:28 <Jonno_FTW> i know cross product
08:32:03 <xerox> in particular let's consider only vectors with fixed third coordinate
08:32:10 <xerox> i.e. an embedding of R^2
08:33:20 <xerox> then I applied the algorithm described in my previous comment
08:34:03 <Jonno_FTW> what is R^n notation?
08:34:22 <xerox> Jonno_FTW: R is the real line, R^2 the plane, R^3 the space
08:34:49 <Jonno_FTW> ok
08:35:50 <Jonno_FTW> i'll solve this tomorrow
08:36:00 <Jonno_FTW> sleep now
08:36:10 <xerox> the triangle {A,B,C} is represented by vectors in the plane OA = (a1,a2,0), OB = (b1,b2,0) OC = (c1,c2,0)
08:36:33 <aavogt> you could also do polar coordinates
08:36:42 <zygoloid> EvanR-work: the milkCereal isn't carrying the state of the milk; the state of the milk is implicitly carried by the monad.
08:36:43 <Jonno_FTW> hmmm
08:36:49 <xerox> to check wether O is on the same side as C with respect to the line through A and B
08:36:54 <aavogt> and then check that you don't have any angles >180
08:37:09 <aavogt> but doing the cross product stuff is probably quicker than trigonometry
08:37:25 <xerox> it suffices to check the third component of two cross product
08:37:34 <EvanR-work> zygoloid: i think i get it. i havent successfully used a non IO monad yet much less monad transformer
08:38:00 <xerox> OAxBA is a vector, call its third component z
08:38:13 <xerox> CAxBA is also a vector, call its third component z'
08:38:39 <xerox> if the sign of z and z' are the same, then O and C lie on the same half-plane with respect to the line through A and B
08:38:56 <Jonno_FTW> half plane?
08:39:07 <xerox> if you have a line in a plane, it divides said plane in two half-planes
08:39:29 <Jonno_FTW> i was pretty bad at geometry this year
08:39:51 <xerox> the triangle {A,B,C} corresponds to the intersection of said half-planes (in which the third point lie, for each selection of two vertices)
08:40:50 <Jonno_FTW> i'll sleep now
08:41:07 <xerox> good night
08:46:14 <xerox> anybody knows why CTRL-y doesn't paste inside GHCi, but puts it in the background?
08:47:41 <b_jonas> xerox: stty settings
08:51:32 <Vulpyne> Man, ghci still tries to free already free stuff on FreeBSD even with 6.12.1. :(
08:52:00 <Igloo> Vulpyne: Is there a bug filed about that?
08:52:46 <Vulpyne> Igloo: I'm not sure... ghci seems to work, just it crashes on exit.
08:52:51 <gwern> did we steal '->' from category theory?
08:53:01 <Vulpyne> I don't really know where exactly the issue is occuring, but it's been around for quite a while.
08:53:18 <EvanR-work> we stole -> from hunters and gatherers
08:55:07 <aavogt> gatherers need ->  ?
08:56:13 <xerox> b_jonas: it does work in emacs though.
09:01:09 <xerox> b_jonas: I don't think stty is per-program?
09:05:18 <zygoloid> xerox: man tcsetattr :)
09:10:20 <xerox> eek :)
09:12:01 <EvanR-work> -> is obviously an arrow. but after looking at the html comment or even {- in haskell, its like... backwardsing my brain. --> points left!
09:17:09 <zygoloid> EvanR-work: actually, HTML 4 and below are SGML-based, and SGML comment mode is entered and left by "--". you can only use SGML comments inside markup tags delimited by <! and >; "-->" isn't a single lexeme. :)
09:18:16 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14173#a14173 My euler 14 solution, tell me please how to optimize it because it can't be calculated I get this error: out of memory (requested 2097152 bytes)
09:18:19 <EvanR-work> you learn something new every day
09:19:14 <zygoloid> of course, a lot of browsers and a lot of pages get this wrong, so what happens in quirks mode is anyone's guess ;-)
09:20:49 <saml> is haskell fault tolerent ?
09:21:16 <p_l> ... can a *language* be fault tolerant?
09:21:22 <ddarius> Yes.
09:21:58 <zygoloid> HaskellLove: your program will build and store the complete chain for each integer up to 1000000. that's a lot of stuff. you can do better than that.
09:22:22 <saml> i'm gonna make a fault tolerant cloud in haskell
09:23:02 <ddarius> p_l: See http://lambda-the-ultimate.org/node/2108
09:23:36 <zygoloid> HaskellLove: suppose you start from 12345. that 'reduces' to 3*12346. so its chain is 12345:(chain for 3*12346). if you make sure you only build the chain for each number once, you should be able to avoid running out of memory.
09:23:39 <b_jonas> xerox: emacs changes stty settings, because it also wants to use control-c and control-z and control-backslash for different things than the normal signal sending meaning
09:24:07 <xerox> b_jonas: makes sense, and zygoloid's suggestion is how it does it. I see. Thanks.
09:24:41 <p_l> ddarius: that doesn't make the whole system fault-tolerant, of course
09:24:54 <xerox> I wonder what the command to paste killed strings is, though.
09:24:55 <zygoloid> HaskellLove: also, using (!!) and elemIndex won't be very fast. you'd be better off using something like maximumBy fst . map (length &&& id)
09:26:17 <HaskellLove> zygoloid, rewrite it with arrays? Why is maximumBy better then !! and elemIndex when we talk about lists?
09:26:30 <ddarius> p_l: "[11:20] <p_l> ... can a *language* be fault tolerant?" is the first thing I saw when I logged on, so that's all I'm responding to.
09:26:46 <p_l> ddarius: right :)
09:28:05 <Baughn> How do I tell cabal to actually build shared-library-using executables? -_-
09:28:24 <Baughn> I have this nifty directory full of .so's, which nothing links to
09:28:59 <HaskellLove> having read stuff on compilers, they say it is easy to write fault tollerant language, but the art is creating a non tollerant one.
09:30:49 <zygoloid> HaskellLove: two reasons why maximumBy is better. 1: because (!!) requires an additional pass over the list, and 2: because (!!) requires the whole list to be retained until the index is computed (this is ultimately why you're having memory issues)
09:31:05 <Veinor> I'm writing something about whytypes are great.
09:31:36 <Veinor> any ideas?
09:31:50 <HaskellLove> zygoloid actually i will leave maximumBy, i will do this with arrays, agree?
09:32:24 <mathijs> Hi all, I'm trying to compile some code that was written for older GHC versions. I did get it to compile but I'm left with 2 deprecation warnings I don't know how to fix. https://gist.github.com/8248d46680d35b712c2c (warnings at the bottom)
09:33:02 <zygoloid> HaskellLove: the trouble with using arrays is you'll need to deal with the case where your chain leaves the array (for instance, starting with 999999, the next value you look at will be 3000000, which won't be an element of a 1000000 element array)
09:33:17 <zygoloid> HaskellLove: that said, i think i did it with an array and it worked pretty well :)
09:34:11 <HaskellLove> zygoloid, I dont understand. What do you mean by: starting with 999999, the next value you look at will be 3000000
09:34:35 <zygoloid> HaskellLove: well, 999999 is odd, so you next go to 3*(999999+1)
09:34:46 <mathijs> ah sorry I found it.... just needed to put base > 3 in cabal file
09:36:27 <HaskellLove> zygoloid and you cant have infinite arrays so, ouch ouch, right? :)
09:38:38 <zygoloid> HaskellLove: yeah, it's a bit annoying. the 'nice' thing would be to use an infinite int map (i'm sure there's one on hackage somewhere...)
09:39:25 <HaskellLove> hmm... seems i have hit the limits of my haskell powers, i will stop euler now and continue reading books
09:40:38 <jmcarthur_work> an infinite int map? what would that even be?
09:41:09 <Baughn> A function :: Int -> a
09:41:19 <aavogt> there are a finite number of ints
09:41:28 <Baughn> ..Integer -> a?
09:41:48 <jmcarthur_work> i just mean what advantage would it have over IntMap or Map?
09:41:53 <Baughn> aavogt: And, technically, nothing in the haskell'98 report forbids using an Int type with an infinite number of bits.
09:42:03 <jmcarthur_work> i just don't know where the "infinite" comes into play
09:42:20 <Baughn> jmcarthur_work: When people say "infinite map", they usually mean "map where the spine is created lazily"
09:42:29 <zygoloid> jmcarthur_work: i mean, a structure appropriate for pure memoization of Integer -> a
09:42:48 <jmcarthur_work> zygoloid, ah!
09:43:08 <jmcarthur_work> i think a trie would be alright for that
09:43:25 <zygoloid> jmcarthur_work: sure. an infinite trie on the bits of the number would work.
09:44:00 <newsham> jfredett: current HWN is not on front page of sequence.complete.org
09:44:05 <aavogt> Baughn: Int is supposed to be an instance of Bounded though...
09:44:09 <jmcarthur_work> i would go with something a bit more coarse grained, i think
09:44:30 <jmcarthur_work> it would be more complex i guess
09:44:57 <ksf> mmmh gentoo packages for 6.12?
09:44:57 <zygoloid> jmcarthur_work: it depends a lot on how sparsely you expect it to be used i think
09:45:08 <jmcarthur_work> zygoloid, yeah i was just about to say something to that effect
09:45:34 <jmcarthur_work> bit by bit might be the only way to do it efficiently for some cases
09:45:38 <aavogt> though I guess that could be satisfied by adding additional Inf values
09:50:00 <Vulpyne> Hmm, what is this mkUsageInfo thing ghc 6.12 prints out?
09:52:13 <HaskellLove>  No doubt by-value and by-reference parameter-passing mechanisms for arguments to procedures, as found in Pascal [74], look like ‘generic programming’ to an assembly-language programmer with no such tools at their disposal. From a book called Datatype generic programming... just to share this it is kinda cool when you think about it...
09:58:58 <b_jonas> oh cool, ghc 6.12.1 supports dynamic linking of the haskell libraries to programs compiled with it!
09:59:04 <b_jonas> on linux
10:00:34 <jmcarthur_work> i'm curious about whether there is a significant performance penalty for dynamic linking
10:01:02 <Vulpyne> I think it's pretty small.
10:01:05 <osaunders_> What happens if I neglect to close a file with hClose? (I missed any replies if there were any).
10:01:11 <Vulpyne> Most C programs are linked dynamically these days.
10:01:15 <jmcarthur_work> my understanding is that cross-module inlining is a significant part of GHC's optimizations
10:01:28 <Vulpyne> osaunders: It's probably closed when the handle is garbage collected.
10:01:37 <Vulpyne> But you don't necessarily know when that'll be.
10:01:39 <EvanR-work> osaunders_: theres also withFile and readFile
10:01:48 <jmcarthur_work> Vulpyne, C doesn't rely on inlining as much as GHC Haskell does
10:01:52 <EvanR-work> which you dont use hClose on
10:02:25 <osaunders_> Vulpyne: Probably?
10:02:39 <Vulpyne> osaunders: Almost certainly.
10:02:51 <Vulpyne> I didn't write or look at the actual code for that, so I'm not 100% sure.
10:02:54 <Vulpyne> jmcarthur: I see.
10:03:16 <EvanR-work> something tells me if i wasnt going to use hClose i shouldnt use openFile
10:03:34 <Vulpyne> Yeah, most likely.
10:03:50 <zygoloid> Vulpyne: i've seen several percent performance degradations from -fPIC on C++ code.
10:04:07 <b_jonas> zygoloid: on x86 or amd64 cpus?
10:04:12 <b_jonas> or some other
10:04:15 <zygoloid> b_jonas: x86_64
10:04:52 <b_jonas> I mean, in any case, it's a tradeoff. I'm willing to pay a small performance penalty for some code if that means I don't have to have umpteen copies of all libraries in memory.
10:05:47 <jmcarthur_work> i'd be all for dynamic linking if GHC had JIT
10:06:10 <jmcarthur_work> i shouldn't speak too soon since i haven't tried the new dynamic linking yet, though
10:06:27 <cwraith> how long 'til cabal works with 6.12 ?
10:06:51 <Guest61381> it does now
10:06:57 <Guest61381> bah
10:07:06 <Baughn> jmcarthur_work: GHC's dynamic linking still does cross-module inlining
10:07:20 <jmcarthur_work> Baughn, and rewrite rules?
10:07:26 * copumpkin yawns
10:07:29 <Baughn> jmcarthur_work: Nothing should change, in particular.
10:07:35 <jmcarthur_work> Baughn, nice!
10:07:46 <jmcarthur_work> i suspect launch times suffer slightly
10:07:57 <Baughn> jmcarthur_work: Well, this does mean you need the /exact same/ library version you linked it against in order to run it
10:08:03 <jmcarthur_work> oh
10:08:10 <Baughn> Compatibility is something for 6.14.. or .16...
10:08:13 <jmcarthur_work> kind of defeats some of the purpose
10:08:18 <Baughn> Mm.
10:08:23 <jmcarthur_work> at least it's in the plans
10:08:28 <zygoloid> Baughn: am i right in thinking there are plans to take hashes of the 'interface'?
10:08:40 <Baughn> zygoloid: The interface is /already/ hashed, actually
10:08:49 <Baughn> That's in the release announcement. ;)
10:09:23 <Baughn> zygoloid: Problem is, right now that hash will change from you changing what you thought were internal details
10:09:35 <Baughn> And API versioning.. yeah, it's a hard problem
10:10:46 <zygoloid> Baughn: right, i guess we need some tool to tell us where to put the NOINLINE pragmas ;-)
10:11:17 <Baughn> zygoloid: Yeah, but you don't want to kill performance either..
10:11:22 <Baughn> NOINLINE is a bit of a nuke
10:12:11 <zygoloid> right; it's got to be the library designer's decision which function bodies they want to be 'exposed' and locked down
10:13:30 <Baughn> Well, ideally it should be possible to expose them and /still/ allow cross-version use
10:13:42 <Baughn> Might take a bit of work.
10:17:51 <luite> where can I get a network package that works with 6.12.1? I tried the latest one from hackage and darcs, but both fail with "Not in scope: `writeRawBufferPtr'" (I need it to build cabal-install)
10:18:03 <cwraith> Excuse my off-topic celebration for one moment please.  Woo!  Going to the rose bowl!  ok, I'm done with off-topic.
10:18:24 * copumpkin pulls out his whoopin stick
10:18:26 * copumpkin whoops cwraith for being off-topic
10:18:31 <Baughn> luite: It.. comes with one?
10:18:52 <Baughn> Hm. No, it doesn't.
10:19:02 <Baughn> cabal pulled in the hackage one at some point, which works fine
10:19:05 <pikhq> Baughn: So, in effect all the dynamic linking of GHC 6.12 nets is shared memory?
10:19:06 <luite> Baughn: it doesn't seem to, on both linux and windows
10:19:10 <Raevel> ghc 6.12.1 <3<3<3
10:19:27 <Baughn> luite: Yeah, I see. Um. It works for me?
10:19:44 <Baughn> pikhq: And reduced disk-space worse, and drastically lower linking time.
10:19:50 <luite> how did you get a working cabal-install?
10:19:52 <Baughn> *disk-space worse
10:19:52 <pikhq> Baughn: Well, yes.
10:20:02 <copumpkin> linking time uses up a big chunk of build time right no
10:20:02 <copumpkin> w
10:20:06 <pikhq> So, the most *important* features of dynamic linking, in essence.
10:20:09 <Baughn> luite: Grabbed the darcs version, which also needs the darcs version of cabal
10:20:31 <luite> did you use the bootstrap.sh file?
10:20:42 <Baughn> No
10:20:46 <PeakerWork> copumpkin: and "ld" with lots of static libraries takes *so much memory*
10:20:50 <PeakerWork> copumpkin: it literally kills my laptop
10:20:51 <luite> oh perhaps it is outdated
10:21:01 <Baughn> copumpkin: It's a pity cabal-install doesn't actually use dynamic linking for executables, 'Shared: true' or not
10:21:14 <PeakerWork> Baughn: reduced link time, or deferred link time?
10:21:24 <Baughn> PeakerWork: Reduced.
10:21:36 <luite> hmm, it does depend on network
10:21:40 <Baughn> PeakerWork: Most of the link time is due to split-objs, which can be ignored now.
10:22:02 <PeakerWork> Baughn: split-objs?
10:22:41 <Baughn> PeakerWork: A trick GHC uses to reduce executable size - it splits every .hs file into as many .o files as possible, one symbol per file, so GNU ld will deign to include only the necessary ones
10:23:05 <Baughn> PeakerWork: You don't want to know how slow that was before the recent performance improvements to ld
10:23:27 <Baughn> (IIRC, it actually managed O(n^2) search time before. Now it's just O(n).)
10:24:51 <PeakerWork> Baughn: wow -- why do that?
10:25:09 <Baughn> PeakerWork: It drastically cut down on executable size.
10:25:32 <Baughn> But with shared libraries, all that is obsolete now
10:25:35 <PeakerWork> Baughn: Why not do symbol pruning separately before ld?
10:26:10 <Baughn> PeakerWork: Because then we'd need to create a program that reads and modifies ELF files, which is notoriously error and breakage-prone
10:27:08 <PeakerWork> Baughn: cutting down executable size is worth all that pain, btw?
10:27:23 <PeakerWork> Baughn: btw: Where are all these obj files? I see just one .hi, and one .o
10:27:57 <Baughn> PeakerWork: find ~/.cabal/lib -name \*.a
10:28:13 <Saizan> aren't the objects splitted only for the core libraries?
10:29:03 <mreh> doing a random backtracking search, Im going to need monad transformers for that aren't I
10:29:09 <PeakerWork> Baughn: with ghc --make this doesn't seem to happen to each of the .hs files though
10:29:13 <mreh> I can't see any other way
10:29:26 <PeakerWork> mreh: "need" is a strong word :)
10:29:34 <PeakerWork> mreh: one option is a LogicT/proper ListT
10:29:47 <PeakerWork> mreh: if your search needs to do something in any monad other than the List
10:30:20 <Baughn> PeakerWork: That's true. Split-objs is done in the GHC compilation process by default, but not by ghc --make or in cabal.
10:30:26 <Baughn> PeakerWork: You have to turn it on in ~/.cabal/config.
10:30:28 <tofulivin> > let peakerwork = 6 in unfoldr (\x -> if null x then Nothing else Just $ splitAt peakerwork x) [1..]
10:30:29 <lambdabot>   [[1,2,3,4,5,6],[7,8,9,10,11,12],[13,14,15,16,17,18],[19,20,21,22,23,24],[25...
10:30:57 <xerox> how would you do efficiently? option :: StdGen -> [a] -> [a] seems slow
10:31:29 <PeakerWork> tofulivin: I prefer takeWhile (not . null) . iterate (drop n)
10:32:10 * hackagebot upload: ghc-syb 0.1.2.2 - SYB instances for the GHC API (ThomasSchilling)
10:32:30 <lispy> Hmm
10:32:47 <lispy> I just upgraded to ghc-6.12.1
10:32:52 <lispy> and cabal said it's too old
10:32:54 <copumpkin> tofulivin: I like to use guard there
10:33:02 <mreh> PeakerWork: I don't think it's really a backtracking problem in the sense that I need to remember everything i've done until now, I just to throw away an answer if it is wrong and start again from the beginning
10:33:04 <luite> Baughn: which packages did you install manually to be able to compile cabal-install?
10:33:06 <lispy> it gave me a command to run, but I get this error: cabal: There is no available version of cabal-install that satisfies >=0.8
10:33:09 <lispy> Any ideas?
10:33:09 <nominolo> lispy: yep, you need to manually bootstrap it
10:33:26 <lispy> nominolo: is 0.8 unreleased?
10:33:29 <nominolo> lispy: and use cabal's head branch
10:33:38 <nominolo> which is 0.7 and works
10:33:45 <Baughn> luite: In the cabal-install dir, runghc Setup.*hs {configure,build,install}
10:33:50 <nominolo> but you have to manually install mtl, parsec, and network
10:33:56 <nominolo> then run the bootstrap script
10:33:59 <Raevel> and i just upgraded to 6.12.1 and cabals setup configure says it can't pairse ghc-pkg dump, any ideas on that? :-)
10:34:03 <PeakerWork> mreh: why not the simple list monad?
10:34:03 <Baughn> nominolo: So, does cabal-install get support for building dynamic executables soon?
10:34:11 <HaskellLove> Anyone familiar with schematic functional programming? Opinions?
10:34:11 <nominolo> no idea
10:34:11 <Baughn> Raevel: You need to update cabal-install
10:34:18 <copumpkin> HaskellLove: schematic?
10:34:19 <luite> hmm, perhaps I did get the wrong branch or something
10:34:21 <lispy> thanks guys
10:34:37 <mreh> PeakerWork, to me the list monad is for all possible solutions, it's deterministic in it's output, i need something really random
10:34:50 <HaskellLove>    This suggests that diagrams like these should be used to program directly and wehave called this kind of programming ‘schematic functional programming’. So the schematic programming is the process of programming a computer directly through
10:34:52 <HaskellLove> the construction of diagrams. Such diagrams are also referred to as schema, graphics, visuals or pictures.
10:34:56 <opqdonut> mreh: there is a Random monad
10:35:03 <opqdonut> on hackage
10:35:16 <mreh> yeah, I think i
10:35:24 <mreh> 'm making it more complicated than it need be
10:35:32 <opqdonut> doesn't backtrack tho
10:35:55 <cwraith> mreh: is this for a monte carlo sim?
10:36:05 <mreh> cwraith: no :)
10:36:11 * hackagebot upload: Boolean 0.0.1 - Generalized booleans (ConalElliott)
10:36:14 <mreh> Asteroids!
10:38:07 <mreh> Random monad isn't the same as System.Random
10:38:22 <opqdonut> hmm?
10:38:31 <mreh> http://hackage.haskell.org/packages/archive/random/1.0.0.0/doc/html/System-Random.html
10:39:10 <Baughn> Random monad - a TH version of return that picks a random monad for return
10:39:24 <opqdonut> what do you mean (can't open links, ircing on phone)
10:39:28 <b_jonas> Baughn: lol
10:39:47 <Baughn> For better results, compile the program in a loop until it succeeds.
10:39:47 <opqdonut> heh
10:39:50 <mreh> there is no `Random Monad` i am aware of
10:40:01 <Twey> Baughn: Haha
10:40:02 <mreh> Baughn: i think that's what I'm going for
10:40:13 <Baughn> mreh: That's how I usually develop haskell programs.
10:40:28 <Twey> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
10:40:29 <Baughn> I've recently written one that /didn't/ work as soon as it compiled.
10:40:35 <Baughn> This turned out to be due to openssl bugs.
10:40:46 <opqdonut> openssl is a horror
10:40:56 <Baughn> opqdonut: An /undocumented/ horror
10:41:05 <Baughn> That's why I wrote the AES and SHA2 packages. ;)
10:41:16 <opqdonut> heh, good
10:41:51 <b_jonas> but I think there were multiple random monads
10:41:59 <Baughn> Pick one at random?
10:42:27 <mreh> shhh Baughn
10:42:59 <b_jonas> yeah, it's something like that
10:43:09 <PeakerWork> Baughn: virtually all the bugs I encounter in Haskell programs are in FFI'd calls
10:43:34 <Baughn> PeakerWork: Mm. Now, if only Haskell could produce code running as fast as C.
10:43:47 <mreh> System.Random is pretty hard to use, it's hard to compose sequential function calls that use the same generator, it needs State monad
10:44:05 <b_jonas> mreh: that's why there's a random monad. or two.
10:44:08 <Baughn> PeakerWork: ..well, there is good C code and bad C code. OpenSSL is definitely in the "bad" camp.
10:44:31 <mreh> the only MonadRandom I can find is a Monad transformer
10:44:36 <b_jonas> Baughn: even in that case I'd like to be able to use ffi
10:44:50 <b_jonas> I don't believe in rewriting all the good libraries just because they're not written in the language I want to use
10:44:56 <b_jonas> I rather write interfaces
10:45:23 <tofulivin> > unzip [('b','_'),('j','o'),('n','a'),('s','!')]
10:45:24 <lambdabot>   ("bjns","_oa!")
10:46:17 <Baughn> b_jonas: Right, AES and SHA2 are both FFI bindings. Just.. cleverer ones, to saner code.
10:49:09 <PeakerWork> conal: hey, aren't all IfB instances isomorphic to Bool?  the ifB catamorphism seems to prove it..
10:49:46 <conal> hmm
10:50:58 <PeakerWork> conal: also, in your comment, missing contexts: instance EqB  Bool a where { (==*) = (==) ; (/=*) = (/=) }  (Need (Eq a =>)  context there)
10:51:34 <PeakerWork> conal: then, if instance selection was context-sensitive - it would resolve the issue ...
10:52:10 <tofulivin> preflex: xseen Olathe
10:52:11 <preflex>  Olathe was last seen on freenode/#haskell 48 days, 2 hours, 20 minutes and 22 seconds ago, saying: null_ptr: Or mod x y (functions come first, then arguments).
10:52:21 <conal> PeakerWork: thx
10:52:45 <tofulivin> preflex: xseen lambdabot
10:52:48 <preflex>  lambdabot was last seen on freenode/#haskell 7 minutes and 21 seconds ago, saying:   ("bjns","_oa!")
10:52:57 <PeakerWork> oh, I hope I didn't assault him when he wasn't able to chat..
10:55:13 <tofulivin> preflex: xseen Gracenotes
10:55:13 <preflex>  Gracenotes was last seen on freenode/#haskell-blah 56 seconds ago, saying: in those sorts of situations
10:55:44 <Gracenotes> :.:
10:57:12 <Craig`> ohai.
10:58:12 <copumpkin> preflex: xseen preflex
10:58:12 <preflex>  what
10:58:21 <copumpkin> preflex: you heard me
10:58:35 <copumpkin> preflex: xseen mauke
10:58:35 <preflex>  mauke was last seen on freenode/##c 1 minute and 31 seconds ago, saying: linker options go last
10:58:55 <mauke> preflex: xseen jesus
10:58:55 <preflex>  jesus was last seen on mozilla/#firefox 59 days, 16 hours, 52 minutes and 7 seconds ago, saying: So MS tricked the manager into thinking it was installing a global?
11:00:38 <Gracenotes> mauke: would it be possible to only use xseen quotes if 1. current channel = latest channel or 2. in PM
11:00:59 <Gracenotes> because the degree to which the channels in which preflex sits are logged.. varies
11:01:17 <PeakerWork> conal: hey, sorry about throwing all that on you without asking first :)
11:02:00 <conal> PeakerWork: np. i appreciate your noodlings!
11:02:21 <PeakerWork> conal: It seems ifB is not a catamorphism - because the "a" type is restricted.. right?
11:02:28 <mauke> Gracenotes: is it really that much of a problem?
11:02:35 <conal> PeakerWork: yep!
11:02:50 <copumpkin> mauke: that xseen on Gracenotes a few minute ago barely missed something rather embarassng ;)
11:03:04 <copumpkin> PeakerWork: is it really a catamorphism if it's not the fixed point of a functor?
11:03:19 * hackagebot upload: epoll 0.2.2 - epoll bindings (ToralfWittner)
11:03:36 <PeakerWork> copumpkin: I don't know CT :P
11:03:37 <Gracenotes> copumpkin: well, no, I didn't actually say something embarrassing, due to vagueness. unless you means the pumpykins patting.
11:03:46 <copumpkin> Gracenotes: yeah! that
11:03:51 <conal> PeakerWork: i would have given you a counter-example, but i wanted you to find the reasoning bug yourself.  and you did. :)
11:03:59 <PeakerWork> conal: it seems really nice :)   "abs = ifB (< 0) negate id" is very elegant
11:04:23 <Gracenotes> oh. don't recall what that was. it seems.
11:04:36 <conal> PeakerWork: hey, yeah.  lovely example!
11:04:55 <PeakerWork> conal: the tuple instances wouldn't be necessary if Haskell had unlifted type products, too, right?
11:06:41 <PeakerWork> conal: I mean, unlifted products could just use the hypothetical templated instance (instance IfB  Bool a where ifB = ife)
11:07:16 <conal> PeakerWork: hm.  thinking ...
11:08:02 <mreh> Does the IO monad bind like the Identity monad for all intents and purposes
11:08:26 <Gracenotes> mauke: from a security perspective, partitioning channels into logged and not-logged might be best. But, anyway, most conceptions of privacy on the internet are largely illusions, heh
11:08:47 <conal> PeakerWork: i made Boolean for deep DSELs.  there the bool type is syntactic, and i turn one ifB into n ifB's.
11:08:53 <PeakerWork> mreh: what do you mean? "bind like"?
11:09:34 <conal> PeakerWork: eg ifB c (ta,tb) (ea,eb) = (ifB c ta ea, ifB c tb eb)
11:09:34 <monochrom> yay ghc 6.12.1 is out
11:09:56 <mreh> Identity a >>= f  =  f a
11:09:58 <PeakerWork> conal: Without lifted type products, what is the difference between choosing a tuple (x,y) over a tuple (x', y')  and having a tuple of choices (x vs x', y vs y') ?
11:10:00 <conal> PeakerWork: oh.  it's right in the code.
11:10:03 <mreh> that's what the identity monad does right?
11:10:12 * conal hasn't read this code in a while.
11:10:24 <mreh> I made up Identity as a type constructor for the Identity monad
11:10:26 <PeakerWork> mreh: IO binding combines the side effects
11:10:50 <conal> PeakerWork: and i hadn't thought about lifted vs unlifted.  you're giving me too much credit there.
11:11:01 <mreh> yes I know, but I'm talking about evaluation
11:11:07 <mreh> not execution
11:11:34 <jmcarthur_work> conal, some thoughts on funding for open source projects you might be interested in. nothing really new, but a decent summary of the situation: http://clojure.org/funding
11:12:02 <PeakerWork> @check (\p a@(x,y) b@(x',y') -> if p then a else b == (if p then x else x', if p then y else y'))
11:12:03 <lambdabot>   Couldn't match expected type `(t, t1)'
11:12:14 <PeakerWork> @check (\p a@(x,y) b@(x',y') -> (if p then a else b) == (if p then x else x', if p then y else y'))
11:12:15 <lambdabot>   "OK, passed 500 tests."
11:12:32 <conal> jmcarthur_work: will check it out.  thanks a bunch!  i'm still perplexed about supporting sw dev.
11:13:02 <PeakerWork> conal: This ^^ is the equivalence I'm thinking about -- which I think holds completely (and not just disregarding bottoms) in case of unlifted products
11:13:05 <jmcarthur_work> conal, the author decides on a sort of donation system
11:14:51 <conal> PeakerWork: i guess that semantic equivalence is what justifies the treatment of conditional syntactic tuples, where the condition is a boolean expression.
11:15:49 <PeakerWork> conal: oh, I see what I was missing
11:16:01 <conal> jmcarthur_work: i like the sound of that system.
11:16:09 <PeakerWork> conal: Thanks. cool package :)
11:16:20 <conal> PeakerWork: :) !
11:16:49 <PeakerWork> conal: the inability to "instance IfB  Bool a where ifB = ife" seems to really sting though -- I hope someone finds a solution to this recurring issue
11:17:21 <monochrom> Darn ghc 6.12.1 is really getting out of the lib business! Even stm is separate? I guess we have to wait for haskell platform.
11:17:44 <b_jonas> can't you install stm from cabal?
11:17:50 <conal> PeakerWork: yeah.  ouch.  haskell instance selection stings in several ways.
11:17:50 <b_jonas> or from source?
11:18:16 <monochrom> haskell platform is a much cleaner solution.
11:18:31 <copumpkin> no platform for 6.12
11:18:31 <copumpkin> yet
11:18:34 <copumpkin> and for a while
11:19:08 <Igloo> Well, it's due some time in January, but that was assuming an earlier 6.12.1 release, so there may be a knock-on effect
11:19:36 <mreh> who knows how MonadSplit works?
11:19:47 <monochrom> mtl is separate too
11:19:56 <copumpkin> mreh: what's that from?
11:20:20 <mreh> class Monad m => MonadSplit s m | m -> s where -- the type signature from Control.Monad.Random
11:20:31 <mreh> looks a bit garbled
11:20:35 <copumpkin> mreh: probably splittable random generators
11:20:45 <copumpkin> something that isn't very well understood
11:21:02 <jmcarthur_work> probably a state monad with "splittable" state
11:21:35 <mreh> copumpkin: i'l well understood?
11:21:41 <mreh> isn't
11:21:50 <copumpkin> mreh: the idea of a purely splittable random generator
11:22:02 <mreh> oh
11:22:14 <copumpkin> I believe there's one paper on it and that's what we have implemented in the standard library, but someone recently posted an example getting very unrandom behavior from that too
11:22:18 <copumpkin> unless I dreamed that
11:22:25 <copumpkin> (from repeated splitting)
11:22:42 <mreh> the idea of splitting isn't really like a bannan split is it
11:22:48 <mreh> it's like branching
11:22:56 <jmcarthur_work> supposed to be
11:22:59 <bos> splittable PRNGs are on crack.
11:23:00 <mreh> growing a new tree from my branch
11:23:23 <mreh> what is a PRNG?
11:23:27 <mreh> @google PRNG
11:23:28 <lambdabot> http://en.wikipedia.org/wiki/Pseudorandom_number_generator
11:23:29 <lambdabot> Title: Pseudorandom number generator - Wikipedia, the free encyclopedia
11:23:30 <copumpkin> pseudorandom number generator
11:24:26 <gwern> @hoogle (<*)
11:24:27 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
11:24:27 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
11:24:27 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:24:34 <gwern> ?src (<*)
11:24:35 <lambdabot> (<*) = liftA2 const
11:24:39 <gwern> ah. it is const
11:24:56 <gwern> ok, I now feel free to disregard malcom wallace's dislike of 'discard' :)
11:26:30 <EnglishGent> hi - can someone help me with this please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14180#a14180
11:26:46 <EnglishGent> if I try calling it with a file name with a space in it - it doesnt seem to read past the space
11:27:05 <EnglishGent> I'm assuming this is something to do with the behaviour of system ?
11:27:41 <zygoloid> EnglishGent: my 'ew' sense is tingling
11:27:46 <gwern> ?src system
11:27:46 <lambdabot> Source not found. I feel much better now.
11:27:52 <gwern> :t system
11:27:53 <lambdabot> Not in scope: `system'
11:27:55 <gwern> bah
11:27:59 <zygoloid> @hoogle system
11:28:00 <lambdabot> No results found
11:28:00 <mightybyte> EnglishGent: Try changing the last line to system("unrar e -- " ++ (show fullName))
11:28:53 <mightybyte> EnglishGent: i.e. put double quotes around the filename on the command line that you're passing to system.
11:29:04 <EnglishGent> that works! thanks mightybyte
11:29:10 <jmcarthur_work> or don't use the system function
11:29:21 <EnglishGent> I have to confess I'm not entirely sure _why_ it works though
11:29:35 <jmcarthur_work> it's a security flaw waiting to happen if you neglect to sanitize user input, for one
11:30:00 <EnglishGent> jmcarthur - I try to avoid as much as possible, but unless there are haskell libraries for decompressing rar, zip, tar, etc...
11:30:19 <mightybyte> EnglishGent: Shell's usually require you to put quotes around filenames with spaces
11:30:26 <jmcarthur_work> EnglishGent, look in System.Process for alternatives to system
11:30:42 <EnglishGent> well I though I had with the "\"" mightybyte
11:30:46 <zygoloid> EnglishGent: you could try this (untested): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14180#a14181
11:30:49 <EnglishGent> and okay - thanks jmcarthur
11:31:05 <zygoloid> EnglishGent: but really you should use something which takes a list of arguments rather than calling system :)
11:31:16 <mightybyte> EnglishGent: That was only on the putStr line, not on the system line.
11:31:48 <EnglishGent> ty zygoloid
11:32:16 <EnglishGent> and I'd much rather do that! I'd like a function where I can say "here's a compressed file, that might be a compressed archive - uncompress it"
11:32:22 <jmcarthur_work> EnglishGent, runProcess would be a good one
11:32:24 <HaskellLove> the more i read this book on schematic functional programming the more i think there is not so much too it as i thought and just writing text is what programming is...
11:32:36 <mightybyte> EnglishGent: (show str) is equivalent to ("\"" ++ str ++ "\"") when str is a String.
11:32:38 <jmcarthur_work> HaskellLove, :)
11:32:57 <zygoloid> mightybyte: not so!
11:33:12 <zygoloid> > let xs = "foo\"bar" in (xs, show xs)
11:33:13 <lambdabot>   ("foo\"bar","\"foo\\\"bar\"")
11:33:13 <mightybyte> zygoloid: No?
11:33:25 <EnglishGent> ah :)
11:33:54 <mightybyte> > show "hello"
11:33:55 <lambdabot>   "\"hello\""
11:34:10 <mightybyte> > "\"" ++ "hello" ++ "\""
11:34:11 <lambdabot>   "\"hello\""
11:34:23 <zygoloid> mightybyte: no, show on strings escapes embedded \s and "s, and ASCII chars <32 (IIRC)
11:34:31 <HaskellLove> I meam programming is programming, not drawing :D feels good to know this now, i always thought my approach is bad and i miss something and now i see it is ok
11:34:44 <zygoloid> > show "\"\\\23"
11:34:45 <lambdabot>   "\"\\\"\\\\\\ETB\""
11:34:59 <zygoloid> > "\"" ++ "\"\\\23" ++ "\""
11:35:01 <lambdabot>   "\"\"\\\ETB\""
11:35:05 <mauke> > "\127"
11:35:05 <lambdabot>   "\DEL"
11:35:25 <jmcarthur_work> HaskellLove, programming needn't inherently be text, of course. it could also be drawing, diagramming, or writing mathematical formulas
11:35:46 <zygoloid> mauke: ok, my list was not exhaustive ;-)
11:35:48 <EnglishGent> hmm - how can you tell if the process runProcess generates has finished?
11:35:56 <zygoloid> > "øþđæ"
11:35:56 <HaskellLove> jmcarthur_work yeah but my point was it is mainly text, less visual
11:35:58 <lambdabot>   "\248\254\273\230"
11:36:04 <Paczesiowa> jmcarthur_work: don't forget UML!
11:37:14 <mightybyte> zygoloid: Ahh, maybe (show str) == (show $ "\"" ++ str ++ "\"")
11:37:28 <newsham> i'm watching the channel 9 lectures on haskell.  I gotta say Meijer mentions way too many side notes and advanced ideas for every intro idea he mentions
11:37:39 <jmcarthur_work> EnglishGent, getProcessExitCode for nonblocking, waitForProcess for blocking
11:37:40 <zygoloid> mightybyte: which instance of Show are you imagining on the RHS?
11:37:49 <newsham> its somewhat interesting as someone who knows haskell, but I am afraid for my haskell-less friends who try to watch this as a true intro
11:38:01 <mightybyte> zygoloid: The String instance for both.
11:38:27 <zygoloid> mightybyte: that's not right either, i'm afraid :)
11:38:33 <jmcarthur_work> EnglishGent, if all you are going to do is wait until the process finishes and you don't need anything fancy, you could use readProcess
11:38:46 <HaskellLove> newsham yeah he mixes lot of noob stuff with some crazy expert ideas...
11:39:07 <mmorrow> newsham: linkz?
11:39:09 <newsham> also side notes like "yah, this works in linq, when we invented linq we looked at tihs to add it to linq"
11:39:11 <lament> crazy noob expert ideas
11:39:12 <newsham> etc
11:39:15 <newsham> not exactly what a beginner cares about
11:39:20 <mmorrow> hah
11:39:25 <newsham> http://channel9.msdn.com/tags/C9+Lectures/
11:39:28 <mmorrow> thx
11:39:33 <mightybyte> zygoloid: Heh, well probably close enough for the purpose of the example.
11:39:41 <lament> newsham: actually, many beginners probably do...
11:39:45 <zygoloid> mightybyte: it's wrong in 100% of cases ;)
11:40:06 <newsham> lament: i dont think they care at all about what meijer did or didnt do in inventing a language
11:40:11 <HaskellLove> but even the noobest noob can understand everything in those lectures... except the monads ones i am not there yet
11:40:14 <newsham> they *might* care a little that "this idea is in linq"
11:40:25 <mightybyte> zygoloid: Oh, well then the original statement was right.
11:40:41 <lament> newsham: it gives some additional motivation, as in "Haskell is where all these cool ideas come from"
11:41:06 <newsham> lament: this is true, but as an intro to functional programming?  off topic.
11:41:18 <newsham> anyway i argued wy more about this than i cared to :)
11:42:54 <newsham> "you could define 'drop 3 [1,2,3]' as '[1,2,3] |> drop 3' if you just defined 'xs |> f = f xs'"
11:42:57 <newsham> *sigh*
11:43:01 <newsham> please dont do that erik
11:43:20 <Gracenotes> where does |> come from?
11:43:20 <newsham> i think he's being paid to scare people away from haskell ;-)
11:43:31 <philed> Gracenotes: It's the F# pipe operator.
11:43:31 <Paczesiowa> Gracenotes: ocaml/f# ?
11:43:38 <philed> Ocaml doesn't have it.
11:43:47 <EnglishGent> jmcarthur - I'm not trying to do anything fancy, I'm just writing a generic compressed file/archive unpacker
11:43:54 <Gracenotes> ah. it's much more limited, too.
11:43:57 <EnglishGent> I'm doing most of my file processing in pure Haskell
11:43:59 <EnglishGent> :)
11:44:17 <Paczesiowa> philed: doesn't every ocamler (?) define it himself?
11:44:26 <zygoloid> @check let showChar '"' = "\\\""; showChar x = init.tail.show $ x; show' str = "\"" ++ concatMap showChar str ++ "\"" in \xs -> show' xs == show xs
11:44:28 <ray> every ocamel?
11:44:29 <lambdabot>   "Falsifiable, after 443 tests:\n\"\\343339\\625448\\691177\\323105\\55739\\...
11:44:31 <Gracenotes> no monadic computations. eww, is all I have to say
11:44:37 <zygoloid> mightybyte: ^^ i think that's pretty close.
11:44:51 <philed> I don't think so. I don't think Ocaml has operator precedence declarations.
11:44:57 <philed> You'd have to use camlp4.
11:45:03 <philed> or camlp5
11:45:09 <zygoloid> @check let showChar '\'' = "'"; showChar '"' = "\\\""; showChar x = init.tail.show $ x; show' str = "\"" ++ concatMap showChar str ++ "\"" in \xs -> show' xs == show xs
11:45:10 <lambdabot>   "OK, passed 500 tests."
11:45:14 <zygoloid> mightybyte: ^^ and i think that's correct :)
11:45:14 <b_jonas> lol
11:45:27 <eugenn> @pl texto articulo = init (concat (map (++ " ")  articulo))
11:45:28 <lambdabot> texto = init . ((++ " ") =<<)
11:45:35 <jmcarthur_work> EnglishGent, sounds like you just want readProcess then :)
11:45:49 <philed> F#'s |> is right associative and binds weakly. It also has "<|" which is closer to "$".
11:46:01 <jmcarthur_work> should give you something similar to system but with properly escaped arguments
11:46:03 <idnar> @type ($>)
11:46:04 <lambdabot> Not in scope: `$>'
11:46:05 <idnar> @type (<$)
11:46:06 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
11:46:09 <b_jonas> “< ray> every ocamel?” “< lambdabot>   "Falsifiable, after 443 tests” -- sounds like the 433th ocamler it tested didn't define (|>)
11:46:16 <idnar> @src (<$)
11:46:17 <lambdabot> (<$) = (<$>) . const
11:46:19 <idnar> ah yes
11:46:39 <ray> b_jonas: probably quit ocaml too soon
11:46:47 <ray> just an outlier
11:49:33 <mightybyte> zygoloid: Ahh yes, for a moment I was thinking that ("\"" ++ str ++ "\"") automatically expanded str to (show str), but that wouldn't make much sense.
11:51:20 <newsham> right now he's telling me why c# is a great language because of intellisense
11:51:35 <HaskellLove> there is this euler problem: http://projecteuler.net/index.php?section=problems&id=13 and the solution that works is: take 13 or so first digits of each number, and then sum all those 100, and then get the first digits of that and whoala... but i can't understand why it works: imagine this for example : 9999999999999999999999999999999999999999999999999999999999 If only one is added to this...
11:51:37 <HaskellLove> ...it changes profoundly... so how come the solution i told ya here works?
11:51:58 <philed> newsham: And the use of objects as namespaces?
11:53:01 <philed> Don Syme appears to be keen on that combination.
11:53:10 <mightybyte> Anyone know what causes "cabal install" to respond with "cabal: Package xyz can't be built on this system."
11:53:28 <newsham> philed: its an odd point to spend time on in an introduction to programming in haskell
11:54:12 <philed> I'll have to watch it later.
11:54:12 <monochrom> mightybyte: perhaps the package needs c libs.
11:54:20 <Kruppe> I am looking to do some simple precompiling on some C code, basically the addition of some simple pragmas that are replaced with code. Anyone have any suggestions of modules to use? Or should I be looking at something different (ie. not haskell).
11:56:08 <Craig`> can some kind person show me the haskell equivilant of: http://awesomefist.com/craig/crappy_template/template.html ?
11:56:11 <Craig`> pleas
11:56:13 <Craig`> e
11:56:18 <Craig`> s/pleas/\1e/
11:56:35 <Ferdirand> HaskellLove: because you are only adding up 100 numbers
11:56:57 <mightybyte> monochrom: Hmm, I'm not sure, let me check.
11:56:58 <Ferdirand> so even in the wors possible case (all nines) the largest carry you can get is bounded
11:57:47 <HaskellLove> Ferdirand, i dont get it...
11:57:56 <tromp__> no Ferdirand, that's no it
11:58:25 <tromp__> the thing is they dont expect a general solution, just one that works for this set of numbers:(
11:59:14 <tromp__> and for languages with bigints, a general solution is way simpler
11:59:44 <loi> Ferdirands assessment is correct
12:00:08 <monochrom> haskell specifies bigints
12:00:32 <HaskellLove> loi dude, if you have 99999999999999999999 and you add just 1 everything changes, so how can you cut a 50 digit to 10 digit number and do stuff in that euler
12:00:38 <Veinor> then again, it's silly to not use bigints if you're working in a language that has them
12:00:38 <fizruk1> Kruppe: I'm not sure, but maybe you should look at Language.C
12:00:59 <sproingie> Craig`: i'd start with HXT
12:03:03 <Kruppe> fizruk1: Alright ill take a look at it
12:04:10 <chrisdone> @echo       preflex: xseen lambdabot -
12:04:10 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "chrisdone!n=user@unaffiliated/chrisdone", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo       preflex:
12:04:10 <lambdabot> xseen lambdabot -"]} rest:"preflex: xseen lambdabot -"
12:04:16 <chrisdone> cheeky
12:04:31 <TThijs> anyone familiar with HTML stuff in haskell
12:04:33 <TThijs> ?
12:04:49 <chrisdone> @echo                       preflex: xseen lambdabot
12:04:49 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "chrisdone!n=user@unaffiliated/chrisdone", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo
12:04:49 <lambdabot>      preflex: xseen lambdabot"]} rest:"preflex: xseen lambdabot"
12:04:54 <chrisdone> bahh too much
12:05:05 <ziman> I'd like to ask for recommendations -- i need to map strings to values; is there a preferred data structure for that (list-tries, ...?)
12:05:15 <mauke> ziman: Data.Map
12:05:20 <baguasquirrel> @TThijs what do you mean by HTML stuff?  I prefer to keep my backend and frontend separate
12:05:20 <lambdabot> Unknown command, try @list
12:06:02 <TThijs> i have imported Text.HTML
12:06:09 <ziman> mauke, thanks
12:06:31 <TThijs> and now i need to know which names for HTML things to use
12:06:39 <TThijs> like bold gives <B> </B>
12:06:42 <baguasquirrel> @TThijs ahh...  never used it...  isn't that the hstringtemplate stuff?
12:06:43 <lambdabot> Unknown command, try @list
12:07:06 <monochrom> You are triggering lambdabot every time you say a thing.
12:07:35 <TThijs> dunno baguasquirrel
12:07:46 <baguasquirrel> @TThijs dude, google it :)  http://hackage.haskell.org/packages/archive/html/1.0.1.2/doc/html/Text-Html.html
12:07:47 <lambdabot> Unknown command, try @list
12:07:59 <mauke> baguasquirrel: will you please stop it
12:08:00 <inimino> baguasquirrel: IRC is not Twitter
12:08:06 <monochrom> hahahaha
12:08:30 <EvanR-work> where is select in haskell. i see this hSelect thing...
12:08:40 <mauke> EvanR-work: doesn't exist, we use threads
12:08:49 <EvanR-work> i hates threads
12:08:54 <mauke> why?
12:09:01 <EvanR-work> because i spent a long time writing c
12:09:05 <sproingie> thread-per-connection?  now that don't scale
12:09:12 <TThijs> thanks baguasquirrel
12:09:26 <mauke> sproingie: why, are you planning to have more than 200000 connections at a time?
12:09:28 <b_jonas> there's a well-hidden Control.Concurrent.threadWaitRead and threadWaitWrite
12:09:38 <b_jonas> but sometimes a real threadable select would be useful
12:09:48 <EvanR-work> i want a single threaded network program
12:09:48 <b_jonas> or even a more direct interface to the underlying event library
12:09:49 <sw17ch> sproingie: not as badly as you might think
12:09:56 <mauke> EvanR-work: no, you don't
12:09:57 <sproingie> anyway, hSelect not work?
12:10:03 * EvanR-work throws a fit
12:10:05 <EvanR-work> yes i do
12:10:12 <EvanR-work> wheres hSelect
12:10:16 <b_jonas> sometimes the threaded model just makes things complicated
12:10:20 <mauke> EvanR-work: you want threads
12:10:24 <sproingie> sw17ch: depends how it's implemented
12:10:27 <b_jonas> like when you want to change timers
12:10:36 <sproingie> if it's a blocking thread per connection, that's just bad
12:10:43 <EvanR-work> yeah
12:10:47 <sw17ch> sproingie: Haskell's threads are lightweight enough i've condiered making a thread-per-packet in some circumstances
12:11:07 <mauke> threads in ghc are essentially free
12:11:08 <sproingie> if it's a thread getting activated by a real event loop driven by select/epoll/whatever then that's fine
12:11:11 <fizruk1> can someone suggest some tools or libraries to work with AST and do some static analysis?
12:11:17 <Vulpyne> Doesn't GHC's RTS pretty much just use select/poll and IO multiplexing?
12:11:35 <aavogt> fizruk1: which AST?
12:11:38 <mauke> Vulpyne: yes, it's M:N threading
12:11:48 <b_jonas> and this is why I decided against rewriting my cbstream bot in haskell, because I wanted to interface libcurl and that would be ugly with this threading only interface
12:11:52 <sproingie> in which case i stand corrected, that does scale
12:11:53 <fizruk1> aavogt: which you can suggest?
12:12:06 <aavogt> I mean is this for manipulating haskell?
12:12:11 <b_jonas> so it would only work well if I could figure out how the implementation works and interface it directly with C but that seems unlikely
12:12:15 <b_jonas> so I'll just write it in perl
12:12:30 <b_jonas> seriously
12:12:31 <Vulpyne> b_jonas: I've used the Curl library in threading code and it seems to work okay.
12:12:38 <EvanR-work> seems that i have a lot to learn with respect to haskell, threads, and asynch i/o
12:12:46 <fizruk1> aavogt: in best case - for manipulating different languages
12:12:46 <Vulpyne> Although I will agree with you that it doesn't actually say if it will work or not, which is a bit disquieting.
12:12:46 <b_jonas> Vulpyne: sure, if you put it in a separate os thread
12:12:56 <b_jonas> in that case it's trivial
12:12:57 <EvanR-work> gotta sort out the politics/religion from the facts
12:13:01 <sw17ch> does libcurl carry state around?
12:13:08 <Vulpyne> b_jonas: I didn't do anything special.
12:13:10 <sw17ch> or have behind-the-scenes state?
12:13:15 <Vulpyne> b_jonas: Have you looked at the source for the wrapper at all?
12:13:24 <Vulpyne> It seems like it makes a new context every time you do something, so it should be threadsafe.
12:13:54 <aavogt> fizruk1: I'd check out either haskell-src-exts or haskell-src-meta for parsing haskell
12:14:06 <b_jonas> Vulpyne: which wrapper?
12:14:16 <b_jonas> I don't remember, I gave it up months ago
12:14:25 <Vulpyne> b_jonas: curl on Hackage.
12:14:32 <b_jonas> though there's also another reason
12:14:37 <b_jonas> the xml library
12:14:46 <b_jonas> the XML::Twig perl module is just so convenient
12:14:59 <Vulpyne> There are a number of Haskell XML libraries.
12:15:08 <b_jonas> yep, I did look at two of them
12:15:26 <sw17ch> Vulpyne: i don't like most of them...
12:15:39 <Vulpyne> If you don't care about special stuff like validation, tagsoup works pretty well.
12:15:46 <Vulpyne> You can even use tagsoup + parsec.
12:15:57 <Vulpyne> And parse tags as if they were characters. :)
12:16:06 <sw17ch> http://hackage.haskell.org/package/xml
12:16:10 <sw17ch> that's the only xml package i can stand in Haskell
12:16:34 <b_jonas> I don't care about validation
12:16:54 <b_jonas> or other special stuff like that
12:16:57 <Vulpyne> Just tagsoup then, it'll give you a stream of open/close tags.
12:17:14 <Vulpyne> And the stuff in them.
12:20:30 <HaskellLove> do you use the same map function for lists, for arrays too?
12:20:52 <sproingie> no
12:21:29 <sproingie> @type A.amap
12:21:31 <lambdabot> Couldn't find qualified module.
12:21:37 <sproingie> @hoogle amap
12:21:38 <lambdabot> Data.Array.IArray amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
12:21:57 <fizruk1> aavogt: can there be a library that gives some interface to deal with AST for some families of languages?
12:22:26 <HaskellLove> is a amap same as mapArray?
12:22:54 <sproingie> @hoogle mapArray
12:22:54 <lambdabot> Data.Array.MArray mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
12:23:15 <sproingie> difference is IArray and MArray
12:23:35 <fizruk1> aavogt: or there must be totally separate analyzers for different languages (e. g. some rather similar as C# and Java)?
12:23:59 <aavogt> fizruk1: what kind of manipulations to the AST are you expecting in a library?
12:24:07 <sproingie> they really should be the same.  mapArray even yields a new array
12:24:44 <sproingie> oh well.  how fun would it be if it were consistent
12:25:20 <EvanR-work> it would be boring. like lisp ;)
12:25:27 <fizruk1> aavogt: I expect at least some generic respresentation for AST of similar languages
12:26:35 <fizruk1> aavogt: and, probably, some obvious AST transformations (as deleting unreachible code and optimizing arithmetics)
12:27:55 * hackagebot upload: GPipe 1.1.1 - A functional graphics API for programmable GPUs (TobiasBexelius)
12:28:46 <aavogt> fizruk1: hmm, maybe work with the a language as tokenized by here: http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Language.html#t%3AGenLanguageDef
12:30:05 <aavogt> unreachable code doesn't sound possible on a generic AST
12:30:16 <fizruk1> aavogt: yeah, something like that, but another sort of customizing, I think
12:31:25 <HaskellLove> how to get maximum number of array? for lists it is maximum but i see no such funciton for arays
12:32:03 <aavogt> but you could do arithmetic optimizations on the tokens in a reasonably small amount of code with syb (or some other generic programming library)
12:32:20 <fizruk1> aavogt: in most language families we can get an abstract flow control element (sorry for my english). so if we have flow control elements and generic logic expressions we can detect some unreachable code, I think
12:32:38 <fizruk1> aavogt: however, maybe, I'm wrong )
12:33:12 <aavogt> you mean like:   if True then x else y
12:33:17 <aavogt> and then say that y is unused?
12:33:24 <fizruk1> yes
12:33:35 <monochrom> convert array to list then ask for maximum
12:33:48 <fizruk1> or simply functions that are not used in code
12:35:11 <monochrom> "L0: goto L0; print 0" you can find unreachable code there easily.
12:35:12 <aavogt> fizruk1: you've seen hlint?
12:35:27 <fizruk1> aavogt: no, what's that?
12:35:53 <aavogt> monochrom: but you can't really do that without knowing how that language is evaluated
12:36:39 <aavogt> @where hlint
12:36:39 <lambdabot> http://community.haskell.org/~ndm/hlint/
12:37:18 <fizruk1> already there )
12:40:54 <fizruk1> aavogt: seems to be useful ) but it is like most for other languages specialized for one certain language
12:41:14 <fizruk1> aavogt: I really don't know if it is needed to get more general tool
12:44:14 <HaskellLove> why do i get those errors http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14183#a14183
12:44:43 <fizruk1> aavogt: optimizing such things for concrete language can bring to high performance and productivity, but maybe concentration on more general things will lead to solving problems for a variety of problems in similar languages
12:45:52 <Vulpyne> HaskellLove: Try giving some concrete types for your functions?
12:46:22 <HaskellLove> Vulpyne what do you mean?
12:46:36 <fizruk1> aavogt: also, maybe there can come possibility to check multilanguage projects in places, where different platforms interact with each other
12:46:38 <Philonous> Doesn't ghc 6.12 come with extralibs anymore?
12:46:52 <Vulpyne> HaskellLove: Type signatures for your functions.
12:47:29 <Vulpyne> HaskellLove: Right now you have none... It's probably thinking you're working with forall a. Num a => butit probably doesn't know more than that. I haven't used arrays much, but it looks like it can't figure out if you're using a supported data type for your array.
12:50:22 <monochrom> ghc 6.12 comes with fewer libs. stm out. mtl out. couple of others.
12:50:40 <Vulpyne> Once you get cabal-install up, you're golden.
12:50:54 <HaskellLove> i thought haskell type system was hottest thing on earth :(
12:50:59 <b_jonas> Philonous: yep, there's no extralibs
12:51:03 <monochrom> I prefer haskell platform, even if wait.
12:51:13 <Vulpyne> HaskellLove: I may have been wrong.
12:51:15 <rubendv> what is the status of 64-bit ghc on mac os 10.6?
12:51:25 <b_jonas> is there a list of libraries that used ot be in extralibs though so I can just get them from cabal?
12:51:47 <Vulpyne> HaskellLove: Ohh... I think I know. chains returns [[Integer]]. listArray wants [a].
12:52:30 <HaskellLove> Vulpyne correct thanks how did i missed that
12:53:04 <HaskellLove> but hey wait, i need an array of lists
12:54:13 <doserj> HaskellLove: array of lists is ok. but you need to tell the compiler what type of Array you want
12:55:06 <monochrom> I wonder if it is monomorphism restriction behind the scene.
12:55:16 <HaskellLove> doserj can you fix my code and send me paste please?
12:55:28 <HaskellLove> just that line with the array stuff
12:55:40 <doserj> HaskellLove: chainsArray::Array Integer [Integer] should work
12:56:15 <doserj> monochrom: no monomorphism restriction here. just that 'a' is no instance of IArray. but Array is.
12:57:09 <monochrom> I verified my claim. {-# LANGUAGE NoMonomorphismRestriction #-}  Then the type is (Num t, Integral t1, IArray a [t1], Ix t) => a t [t1]
12:57:55 <doserj> ahh, yes.
12:58:43 <doserj> well, at some point, he has to give the type annotation anyways
12:59:12 <monochrom> Alternatively, import Data.Array instead, then chainsArray :: Array Integer [Integer]  "Ma, no tricks!"
12:59:25 <doserj> yep
12:59:50 <monochrom> I mean the type is inferred. Both experiments.
12:59:54 <zagibu> it's me again with more problems of the "Maybe" kind
13:00:13 <zagibu> lookit here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14184#a14184
13:01:15 <zagibu> it's long, I know, so here's a summary...i have a subfunction that returns "Maybe Term", and when I try to use this function in another function that expects a Term, i get a type error
13:01:37 <zagibu> so my question is, do I have to pull the Maybe up in all functions, right to the top level?
13:01:52 <dibblego> zagibu, how do you know your Maybe Term even has a Term? It may have Nothing after all right?
13:01:58 <Vulpyne> zagibu: Well, your actual value is wrapped up in the Maybe.
13:02:00 * doserj is checking why he hasn't NoMonomorphismRestriction in his .ghci. It was there at one time
13:02:15 <zagibu> yeah, right
13:02:36 <dibblego> zagibu, you could use fmap on your Maybe Term to get access to the Term, run your function, then get a Maybe ResultOfThatFunction
13:02:53 <dibblego> > fmap (+1) (Just 7) -- like this
13:02:54 <lambdabot>   Just 8
13:03:03 <aavogt> @type fromMaybe
13:03:04 <lambdabot> forall a. a -> Maybe a -> a
13:03:08 <Vulpyne> > fmap (+1) Nothing
13:03:09 <lambdabot>   Nothing
13:03:19 <zagibu> woah, info overload
13:03:42 <zagibu> a bit more newbie-friendly, if possible?
13:03:49 <dibblego> fromMaybe let's you provide a default value i.e. "get the value out if there is one, but if there isn't, use this given value"
13:04:02 <zagibu> hmmm
13:04:22 <dibblego> fmap allows you to "run this function on the Maybe value, but the result will also be a Maybe"
13:04:24 <HaskellLove> doserj yes it works now :) chainsArray::Array Integer [Integer] how do you read this? confuses me, i would have written it only: chainsArray::Array [Integer]
13:04:57 <aavogt> Array is a type constructor which takes two parameters
13:04:59 <Vulpyne> zagibu: | isJust (existsSubst (Var var) theta) = unify (fromJust (existsSubst (Var var) theta)) x theta
13:05:07 <aavogt> @kind Array
13:05:08 <lambdabot> * -> * -> *
13:05:14 <Vulpyne> zagibu: Something more like that perhaps.
13:05:37 <zagibu> this haskell code will melt my brain soon
13:05:46 <aavogt> HaskellLove: you are allowed to use arrays with other types as indexes
13:05:55 <Vulpyne> zagibu: isJust is the same as your blah /= Nothing.
13:06:07 <kmc> HaskellLove, Array IndexType ElementType
13:06:07 <doserj> HaskellLove: the first parameter is the type with which you index the Array, the second one, what an actual Array element cntains
13:06:20 <aavogt> say you want to have two dimensional indexing:   Array (Int,Int) Int
13:06:21 <Vulpyne> zagibu: If you have "Maybe a" fromJust gives you "a". Or blows up if you pass it a Nothing.
13:06:24 <kmc> HaskellLove, a 2D array of doubles might look like:  Array (Integer, Integer) Double
13:06:35 <HaskellLove> got it
13:06:42 <zagibu> okay, thanks
13:06:49 <jmcarthur_work> so much nicer than nested arrays :)
13:07:05 <kmc> although you might want nested arrays in other cases
13:07:13 <jmcarthur_work> yes
13:07:33 <jmcarthur_work> although that might often mean you mean to use a list somewhere
13:07:40 <jmcarthur_work> *you meant
13:07:46 <jmcarthur_work> not always
13:07:53 <HaskellLove> I banged my head all day with such type errors, now i realize what it means to say: haskell's type system is the greatest but it limits you to work in certain way, now that is not limitation, it just takes time to get used to it.
13:08:17 <jmcarthur_work> the good news is that you do indeed become used to it
13:08:17 <kmc> yes, the point of a strong static type system is to limit you
13:08:19 <HaskellLove> jmcarthur_work yeah but whenever u want indexing do it with array right?
13:08:31 <kmc> the thing it limits you from doing is "writing broken programs"
13:08:31 <jmcarthur_work> HaskellLove, not *always*
13:08:48 <jmcarthur_work> HaskellLove, sometimes you want a map, sometimes a list, sometimes an array, sometimes... something else?
13:08:55 <kmc> Data.Sequence
13:09:03 <jmcarthur_work> yes, a finger tree
13:09:08 <jmcarthur_work> <3 finger trees
13:09:10 <HaskellLove> i see
13:09:40 * kmc ☞ finger trees
13:09:54 <HaskellLove> from now on i will declare everything and explicitly state types
13:09:58 <nlogax> real life finger tree: http://tr.im/HCsY
13:10:09 <kmc> haha
13:10:16 <b_jonas> lol
13:10:33 <Vulpyne> HaskellLove: That's a good idea. :)
13:10:51 <Vulpyne> HaskellLove: One helpful thing about it is it makes it clear when the compiler thinks something different than you do.
13:11:00 <zagibu> fromJust doesn't exist here
13:11:26 <dibblego> import Data.Maybe
13:12:25 <dibblego> zagibu, code that looks like this: | var == x -> True; otherwise = False can be rewritten like this: var == x
13:12:31 <b_jonas> wait, ghc 6.12.1 comes with bytestring in it?
13:12:39 <kmc> boo hiss fromJust
13:12:39 <b_jonas> so that's why they don't have extralibs!
13:12:45 <Vulpyne> zagibu: import Data.Maybe
13:15:39 <Vulpyne> zagibu: I think your (Subst var x):(List theta) part is going to give you trouble.
13:16:02 <Philonous> cabal-install 0.6.4 doesn't like Cabal 1.8, and Cabal 1.6 can't read the output of "ghc-pkg dump". Looks like I'm screwed .
13:16:25 <HaskellLove> any book you guys can recommend that only talks about static type systems in detail?
13:16:41 <aavogt> @where tapl
13:16:41 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
13:16:42 <Heffalump> Types and Programming Languages by Benjamin Peirce is the canonical one
13:16:57 <aavogt> it's not easy though
13:17:26 <Vulpyne> zagibu: MGU looks like Maybe [Substitution] to me.
13:17:29 * kmc <3 tapl
13:18:15 <kmc> HaskellLove, out of curiosity, what other languages do you know?
13:19:14 <lament> Scala
13:19:15 <EvanR-work> well he used to be scala love...
13:19:33 <HaskellLove> c c++ python scheme prolog owl html/xml java ... hmm what else? litle scala i guess and the usual pascal bla bla... but not using these much i have forgoten syntax so i am not that good
13:19:34 <nlogax> love is fleeting
13:19:36 <Vulpyne> But that doesn't mean he knows it, just that he loves it. :)
13:19:58 <EvanR-work> if he did know it, he almost surely wouldnt ;)
13:19:59 <sw17ch> Often times i love languages before i tollerate them.
13:20:13 <sw17ch> Haskell's honeymoon period isn't over yet. :)
13:20:19 <HaskellLove> yeah i l just love haskell but i know shit about it :D
13:20:28 <Vulpyne> The more I use Haskell, the more I love it.
13:20:38 <Philonous> Liskell >3
13:20:45 <Philonous> <3
13:20:51 <Vulpyne> The symbol for balls?
13:20:54 <HaskellLove> me too, we go to bad together every night this week
13:21:12 <Vulpyne> zagibu: I annotated your hpaste. I'm not sure if it will help you.
13:21:13 <Philonous>  /= 3 actually
13:22:21 <zagibu> Vulpyne: thanks a lot...well, your help opened other cans of worms, but I'm fighting
13:22:45 <Vulpyne> zagibu: You might be better off using a Maybe instead of MGU if you want to propogate Failure.
13:23:16 <zagibu> to be honest, I don't have a really tight grip on the code
13:23:46 <zagibu> I wrote it all myself, but on the basis of some pseudo-code and my very limited understanding of haskell
13:24:11 <zagibu> maybe the way I'm doing things is complicated and leading in to a dead end
13:24:11 <mreh> This code works nicely, but how can I make it better?: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14188#a14188
13:24:14 <Vulpyne> zagibu: Well, you have data MGU = Failure | List [Substitution] ... If you used Maybe it would be: data Nothing | Just [Substitution]
13:24:29 <mreh> generating two random numbers is easy, but what if I need 10
13:24:34 <zagibu> ah, but that's a problem, I can't change the data definitions
13:24:34 <Vulpyne> zagibu: And there's nice stuff like the maybe monad.
13:24:42 <Vulpyne> Ah.
13:25:37 <Vulpyne> What is the problem you are having now? The (Subst var x):(List theta) part?
13:25:48 <Taejo> :t foldM
13:25:48 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:25:51 <Cale> mreh: replicateM 10 getRandom
13:26:05 <mreh> :t replicateM
13:26:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:26:11 <zagibu> I'm having trouble adding a subst to an MGU
13:26:23 <Cale> mreh: Why are you using getSplit?
13:26:30 <Vulpyne> zagibu: Did you look at my annotation?
13:26:31 <mreh> Cale: the Rand monad only works like the Identity monad
13:26:35 <zagibu> trouble so big that I'm rewriting major parts of the code
13:26:42 <mreh> you need to call get split to access the random generator
13:26:51 <Cale> mreh: The point of MonadRandom is to avoid explicitly working with the random generator
13:27:08 <monochrom> w00t MGU
13:27:18 <mreh> Cale: i'm a n00b
13:27:36 <Vulpyne> zagibu: Look at that first. :) I've already fixed the problem of adding the substitution to the MGU.
13:27:39 <aavogt> it's more like   Reader Gen  than Identity
13:27:51 <mreh> aavogt: this is true
13:27:54 <Vulpyne> zagibu: You have to pattern match out the [Substitution] part, then you can just treat it like a list.
13:28:06 <aavogt> @type random
13:28:07 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
13:28:16 <zagibu> heh, I just see it, thanks a lot
13:28:20 <Vulpyne> No problem.
13:28:21 <aavogt> or whatever is an instance of RandomGen...
13:28:30 <mreh> isn't that more like State aavogt
13:29:06 <Vulpyne> :t getRandom
13:29:07 <lambdabot> Not in scope: `getRandom'
13:29:16 <aavogt> depends whether or not you return the new PRNG state
13:29:17 * hackagebot upload: hemkay 0.1.0 - A module music mixer and player (GergelyPatai)
13:29:32 <aavogt> maybe it just splits of the state for every single state generation?
13:29:44 <aavogt> in which case it can be Reader
13:30:14 <aavogt> but if it does thread a single RandomGen around (which is probably a more efficient thing to do), then it is more like state
13:31:07 <mreh> Haskell is going to take me years to get :(
13:31:41 <mreh> the temptation is to learn something new rather than code something useful
13:31:55 <Vulpyne> Learn something new *by* coding something useful.
13:34:03 <EvanR-work> @hoogle hSelect
13:34:04 <lambdabot> No results found
13:34:11 <EvanR-work> @hoogle Select
13:34:12 <lambdabot> Text.Html select :: Html -> Html
13:34:12 <lambdabot> Text.XHtml.Frameset select :: Html -> Html
13:34:12 <lambdabot> Text.XHtml.Strict select :: Html -> Html
13:34:56 <EvanR-work> :\
13:36:03 <Vulpyne> Trying to find an interface for select()?
13:36:08 <EvanR-work> yes
13:36:16 <mauke> I can write you one
13:36:18 <mauke> using threads
13:36:22 <EnglishGent> that's how I'm trying to do it (learning something new by coding something useful) :)
13:36:28 <Cale> mreh: Rand is in fact a State monad with a little wrapping.
13:37:07 <EvanR-work> how would you do it with threads
13:37:11 <Cale> EvanR-work: You don't usually need to use select explicitly, just fork some threads which do blocking I/O
13:37:36 <Cale> EvanR-work: It's the GHC runtime system's job to sort it out
13:37:52 <mreh> Cale: I dont see how to wrap a function in Rand, like you would in State
13:38:06 <mauke> like this: http://codepad.org/ZxIs2Y1u
13:38:06 <Vulpyne> EvanR-work: What are you actually to use it for?
13:38:10 <mauke> warning, completely untested
13:38:18 <Cale> If x is any IO action, then forkIO x is an action which when executed, starts a new (Haskell, not OS) thread in which x is to be executed.
13:38:36 <Cale> (and returns the ID of the new thread)
13:38:40 <EvanR-work> a mud server. i want the network module to just return a list of commands that are waiting to be processed along with who sent them
13:38:53 <mreh> if the state of the Rand Monad is a RandomGen
13:39:11 <Cale> EvanR-work: Yeah, for network servers, generally the approach is to fork at least one thread for every client.
13:39:30 <Cale> (they're lightweight, and you don't have to worry about making too many of them generally0
13:39:31 <mreh> sometimes haskell melts my brain
13:39:32 <Vulpyne> Cale: If you need global state, you can just make a TMVar or TChan or something.
13:39:34 <EvanR-work> so how to i 'recombine' all the worker threads into one result...
13:39:35 <knobo> Is it "ok" to say that a monad is a type that implements a certan interface to a java programmer?
13:39:39 <Vulpyne> Er, that should have been to EvanR.
13:39:54 <mauke> knobo: yes
13:39:54 <Cale> knobo: That's true, but not a complete characterisation.
13:39:58 <EvanR-work> Vulpyne: no global state... just an IO thing
13:40:04 <mreh> knobo: yes, and you need to explain the monad laws
13:40:22 <Cale> Well, before that, you need to explain what the interface itself consists of :)
13:40:28 <EvanR-work> ok so threads is probably the way to go
13:40:42 <mreh> he'll flip his lid when he sees return!
13:40:52 <Vulpyne> EvanR: It's the idiomatic way for sure... I mostly write network servers in Haskell and I generally just forkIO each thread.
13:41:04 <Vulpyne> EvanR-work: I don't totally understand what you meant about combining the threads down though.
13:41:05 <dibblego> knobo, yes, except that interface cannot be expressed in Java's type system
13:41:06 <Cale> EvanR-work: MVar and Chan for communication.
13:41:11 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14188#a14188 -- Cale, can you suggest an improvment, making it more generic?
13:41:14 <dibblego> knobo, also, s/type/type constructor
13:41:50 <dibblego> knobo, http://projects.tmorris.net/public/what-does-monad-mean/artifacts/1.0/chunk-html/ar01s04s04.html
13:41:53 <knobo> Is the word monad derivated from "mono" as in single?
13:42:33 <kmc> knobo, believe so
13:42:48 <knobo> aha.. wikipedia says unit
13:42:54 <EvanR-work> Vulpyne: just mean, i have doNetwork :: IO [Command], type thing
13:42:58 <Cale> mreh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14188#a14191
13:43:03 <knobo> next time: wikipedia first, irc second
13:43:08 <EvanR-work> i conceived of it in a 'single threade' manner
13:43:10 <knobo> :)
13:43:10 <lament> i read that as doHomework
13:43:26 <Vulpyne> EvanR: doNetwork does what exactly? Reads commands from a person using the MUD?
13:43:39 <EvanR-work> reads commands from all connected players
13:43:53 <Vulpyne> evanr: You are probably going to restructure it completely.
13:43:58 <EvanR-work> great
13:44:03 <bos> @hoogle isEOFError
13:44:07 <lambdabot> System.IO.Error isEOFError :: IOError -> Bool
13:44:07 <lambdabot> System.IO.Error isEOFErrorType :: IOErrorType -> Bool
13:44:28 <knobo> dibblego: It's a bit difficult for me to read that, cause I don't know java :)
13:44:37 <Vulpyne> evanr: Something more like: mainloop globalstate = forever $ do { newconnection <- acceptnewconnection; forkIO $ handler globalstate newconnection }
13:44:51 <knobo> this http://marijn.haverbeke.nl/monad.html is better for me
13:44:52 <Vulpyne> evanr: And each handler will talk to one client on the MUD.
13:45:04 <dibblego> knobo, I presented that to some people who are familiar with Java (video still in production)
13:45:16 <EvanR-work> ok and the handler eventually needs to talk to the rest of the, non IO, single threaded program
13:45:42 <Vulpyne> evanr: What, you mean like the part that moves monsters around or whatever?
13:45:44 <kmc> i feel like STM is a good fit for a MUD
13:46:18 <EvanR-work> Vulpyne: running scripts, executing timed events, scheduling outgoing IO...
13:46:34 <Vulpyne> evanr: If it was me, I'd also just run that as a separate thread.
13:46:49 <mreh> Cale: nice one
13:46:52 <EvanR-work> it is a separate thread, its the main thread
13:47:05 <EvanR-work> why do i need more threads >_<
13:47:21 <Vulpyne> evanr: It could just make modifications to the global state. Envisionsing that as something like data MudState = MudState { users :: [User]; rooms :: [Room] }
13:47:23 <kmc> EvanR-work, because they're a powerful abstraction for concurrent programming
13:47:30 <kmc> and not nearly such a pain in the ass in Haskell as in other languages
13:47:34 <EvanR-work> but i never wanted to make a concurrent program
13:47:36 <Vulpyne> evanr: Obviously you would use more efficient types and such.
13:47:42 <phr> in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14192#a14192  see the stuff between "chop from here" and "to here" is superfluous
13:47:49 <phr> but if i edit it out, the program slows down by about 30%
13:47:49 <kmc> EvanR-work, a multiplayer game is inherently a concurrent program
13:48:00 <kmc> select() is a crude way of writing a concurrent program
13:48:15 <Vulpyne> It's not really concurrent with select, it just gives the illusion. :)
13:48:16 <kmc> invented long before UNIX systems had real standardized thread libraries
13:48:17 <EvanR-work> its a serializing interface to a single threaded program!
13:49:01 <kmc> it depends on what you do with the result of select(), but if you dispatch to different routines for each data source, you're essentially writing a scheduler for cooperative threads
13:49:20 <EvanR-work> no different sources
13:49:23 <Heffalump> that's essentially what the GHC RTS does
13:49:33 <Vulpyne> evanr: Trying to do it that way is just fighting against the Haskell way. :)
13:49:37 <kmc> threads are easy in Haskell
13:49:39 <EvanR-work> the list of commands simply goes into the event scheduler
13:49:45 <kmc> because imperative and functional programming are nicely complementary
13:50:02 <EvanR-work> you mean concurrent
13:50:09 <kmc> no
13:50:14 <EvanR-work> oh :S
13:50:25 <Vulpyne> evanr: In Haskell's concurrency abstractions, there's stuff like channels and such. If you had the event scheduler run in a thread, it could just consume items from the channel or whatever and modify the state appropriately.
13:50:46 <kmc> i mean that a thread is most easily modeled by a first-class function (or action), and spawning a thread is then a higher-order function
13:50:48 <Vulpyne> evanr: Before your proceed further, you may want to read up on STM.
13:50:55 <Vulpyne> It's pretty simple really, and very powerful.
13:50:57 <kmc> every language's thread API tries to model threads as first-class functions, often poorly
13:51:09 <EvanR-work> STM is a monad transformer?
13:51:14 <kmc> no, just a monad
13:51:17 <EvanR-work> oh
13:51:21 <kmc> like IO, it has to be at the bottom of the stack
13:51:37 <fizruk1> :t when
13:51:38 <kmc> there's a STM chapter in RWH
13:51:38 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:51:44 <Vulpyne> There's a function that converts STM a -> IO a.
13:51:46 <Vulpyne> :t atomically
13:51:47 <lambdabot> Not in scope: `atomically'
13:52:18 <monochrom> It doesn't just convert. It also indicates a single transaction.
13:53:14 <kmc> EvanR-work, with STM you do not need explicit locks -- you can build arbitrarily large atomic operations in the STM monad, and run them in the IO monad with "atomically"
13:53:14 <EvanR-work> i spent so long hating concurrent programming and multithreaded stuff... this is going to take some soul searching...
13:53:27 <Vulpyne> evanr: It's wayyyy different from something like using pthreads.
13:53:34 <EvanR-work> im gathering that
13:53:40 <Vulpyne> pthreads is not fun.
13:53:45 <kmc> EvanR-work, computers have a lot of cores these days...
13:53:58 <EvanR-work> yeah but no program iwanted to write would benefit from them
13:54:02 <kmc> if you can't use them all effectively, you'll become increasingly useless as a programmer
13:54:03 <EvanR-work> so why bother
13:54:14 <CalJohn> EvanR-work: if you want to learn about STM, the papers regarding haskells STM are basically introductions and require no previous knowledge of concurrency
13:54:27 <kmc> *and* multiple threads are a powerful abstraction mechanism, which is worth using even with one core and no performance gain
13:54:30 <Vulpyne> What happens when you want to make your monsters do heavy duty computation? :)
13:54:37 <EvanR-work> the performance gain for multiprogramming correctly a suitable c++ program is just not worth the effort
13:54:58 <kmc> in Haskell we actually try to separate "multithreaded semantics" and "multithreaded implementation of singlethreaded semantics, for performance"
13:54:58 <EvanR-work> Vulpyne: off load them onto another computer and have the ai connect ;)
13:55:23 <Vulpyne> evanr: Seems harder and a lot more difficult to get correct than just forkIO monster :)
13:55:27 <CalJohn> parallelism and concurrency in haskell are relatively trival, lots of people use them
13:55:45 <EvanR-work> Vulpyne: there would be like a million monsters, just doesnt seem feasible
13:55:55 <kmc> EvanR-work, you can fork literally a million threads on GHC's RTS
13:55:59 <kmc> they map to a configurable number of OS threads
13:56:10 <EvanR-work> sounds fancy
13:56:22 <kmc> again, threads as abstraction, not just for performance
13:56:36 <kmc> it can be easier to write a program that runs 1,000,000 threads on 4 cores than one that runs 4 threads on 4 cores
13:56:37 <EvanR-work> im already so far into abstract land why not...
13:56:49 <kmc> EvanR-work, http://book.realworldhaskell.org/read/software-transactional-memory.html
13:57:18 <Vulpyne> evanr: Haskell threads are far more lightweight than OS threads like in pthreads. You don't pay much price to spawn a lot of them.
13:57:38 <EvanR-work> got it
13:57:39 <knobo> I don't know any other editor but emacs, but are there any other editor specialized for Haskell out there?
13:57:50 <Jedai> knobo: leksah
13:57:59 <lament> knobo: vim
13:58:03 <Jedai> knobo: there is a mode for Eclipse too
13:58:03 <Vulpyne> I like emacs. :)
13:58:06 <kmc> knobo, maybe Leksah or Yi.  but i think most people use something more generic
13:58:37 <knobo> The haskell mode I have is a little bit primitiv
13:58:59 <Vulpyne> Do you have the latest haskell-mode?
13:59:19 <knobo> v2_4
13:59:51 <Vulpyne> Latest would appear to be 2.7.0.
13:59:58 <Vulpyne> http://projects.haskell.org/haskellmode-emacs/
14:01:06 <Vulpyne> Hmm, I should upgrade mine!
14:01:21 <leimy> a window manager in 50 lines of C
14:01:22 <leimy> http://incise.org/tinywm.html
14:01:24 <EvanR-work> kmc: Vulpyne: and i just now thought i was done with the hard parts of moving from c to haskell ;) IO, monads, laziness, whizbang type systems...
14:01:31 <EvanR-work> now this
14:01:39 <kmc> the hard part is unlearning everything
14:01:43 <kmc> like "threads are a pain in the ass"
14:01:43 <Vulpyne> evanr: I think the hardest parts are behind you.
14:01:49 <kmc> they are, in dys-functional languages
14:02:00 <kmc> but yeah, if you understand monadic IO, it is not hard to understand STM from there
14:02:49 <mreh> can a (a <- blah) be typed explicitly?
14:03:06 <kmc> > do { x :: Char; x <- "abcde"; return x }
14:03:07 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:03:07 <lambdabot>         against inferred type...
14:03:22 <kmc> > do { x <- "abcde"; x :: Char; return x }
14:03:23 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:03:23 <lambdabot>         against inferred type...
14:03:26 * EnglishGent also likes emacs :D
14:03:30 <kmc> > do { (x :: Char) <- "abcde"; return x }
14:03:37 <lambdabot>   "abcde"
14:03:48 <mreh> kmc: is that list monad?
14:03:50 <kmc> yes
14:03:57 <mreh> i'm learning!
14:04:06 <kmc> type signatures on patterns is a GHC extension, iirc
14:04:30 <kmc> > do { x <- "abcde"; let { y :: Char; y = x }; return x }
14:04:31 <lambdabot>   "abcde"
14:04:40 <kmc> > do { x <- [1,2,3]; let { y :: Double; y = x }; return x }
14:04:41 <lambdabot>   [1.0,2.0,3.0]
14:05:25 <doserj> > do { x <- [1,2,3] :: [Float]; return x }
14:05:26 <lambdabot>   [1.0,2.0,3.0]
14:05:49 <gwern> leimy: the ultimate in portability - just memorize 50 lines,m quite doable, and now anywhere you have cc and X, you have your favorte WM!
14:06:08 <doserj> > do { x <- [1,2,3]; return (x::Double) }
14:06:09 <lambdabot>   [1.0,2.0,3.0]
14:06:38 <leimy> gwern: it's been ported to python and lisp :-)
14:08:09 <Vulpyne> I bet I can compile xmonad in less than 50 lines. :)
14:08:20 <Taejo> gwern: but for that to work you have to make tinywm your favourite WM
14:10:57 <fynn> For OS X Leopard, are people getting GHC from macports or the DMG?
14:11:06 <mreh> does haskell have reflection?
14:12:13 <kmc> mreh, of what kind?
14:12:29 <EvanCarroll> two questions: is there a better way of writing `concat $ replicate 5 [1,2]`; and how do you concat a list of tuples?
14:12:39 <kmc> > take 10 $ cycle [1,2]
14:12:40 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
14:12:41 <zagibu> haha, i have finally resolved all type errors only to get stuck on a semantic error of the worst kind: an endless loop
14:12:42 <mreh> kmc: I just realised type checking such a thing would be impossible
14:12:48 <Heffalump> yes, see Data.Typeable / Data.Dynamic
14:12:52 <kmc> mreh, Data.Typeable provides runtime type reflection
14:12:52 <zagibu> i just love this language
14:12:54 <Heffalump> but you can't enumerate functions
14:13:03 <kmc> Template Haskell provides compile-time introspection and code generation
14:13:07 <EvanCarroll> kmc++
14:13:11 <EvanCarroll> how do you concat a list of tuples?
14:13:11 <EnglishGent> can someone explain this please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14196#a14196
14:13:19 <EnglishGent> it has me very puzzled
14:13:24 <kmc> > concatMap (\(x,y) -> [x,y]) [(1,2), (3,4)]
14:13:25 <lambdabot>   [1,2,3,4]
14:13:28 <mreh> EvanCarroll: are they the same length
14:13:33 <mreh> what about unzip?
14:13:36 <mreh> :t unzip
14:13:37 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
14:14:15 <Vulpyne> EnglishGent: Cause system returns an IO result.
14:14:17 <EvanCarroll> kmc++ again nice!
14:14:23 <kmc> EnglishGent, "Right (system .....)" has type probably "Maybe (IO ())"
14:14:35 <kmc> err not () but whatever system results
14:14:45 <Vulpyne> EnglishGent: You could do something like: Right `fmap` (system blah blah)
14:14:53 <EvanCarroll> ok one last question, is there a library that would permit me to sort a list without any idea of how a monad works?
14:14:57 <kmc> Right <$> (system blah)
14:15:02 <kmc> EvanCarroll, that's in the prelude
14:15:03 <mreh> [(1,2),(3,4)] >> (\(x,y) -> [x,y])
14:15:05 <EnglishGent> but I dont get a type error - it just (in the 2nd case) doesnt actually seem to invoke the system call
14:15:05 <mreh> > [(1,2),(3,4)] >> (\(x,y) -> [x,y])
14:15:06 <lambdabot>   The lambda expression `\ (x, y) -> ...' has one argument,
14:15:06 <lambdabot>  but its type `[b...
14:15:08 <kmc> > sort [1,5,3,7,2]
14:15:09 <lambdabot>   [1,2,3,5,7]
14:15:10 * EnglishGent still confused :|
14:15:30 <mreh> > [(1,2),(3,4)] >>= (\(x,y) -> [x,y])
14:15:31 <lambdabot>   [1,2,3,4]
14:15:33 <kmc> EvanCarroll, why do you think monads are related to sorting a list
14:15:45 <EvanCarroll> erg
14:15:48 <EvanCarroll> i ment to say shuffle
14:15:49 <kmc> EnglishGent, sure -- you're returning an IO recipe, which you never execute
14:15:55 <kmc> that's not a type error
14:15:55 <b_jonas> EnglishGent: the error is not caught because main can be any IO x type and the x is ignored
14:16:01 <Vulpyne> EnglishGent: Because your function is probably of type: unrar :: String -> IO (Either a (IO blah))
14:16:06 <Raynes> > sort [1,10,3,7,4,100]
14:16:07 <lambdabot>   [1,3,4,7,10,100]
14:16:10 <EnglishGent> ah!
14:16:14 <EnglishGent> thanks :)
14:16:18 <kmc> EnglishGent, it's very helpful to put type signatures on top level functions
14:16:21 <b_jonas> oh wait, ignore that, because there's no main there
14:16:24 <kmc> so you do not get surprised in this way
14:16:37 <Vulpyne> EnglishGent: Or use ghci and :t your functions frequently to see what ghc thinks their type is.
14:16:47 <mreh> type signatures everywhere saves lots of head scratching
14:16:58 <Raynes> What mreh said.
14:17:03 <erg0t> there is any function that does (\f x -> f x x) ?
14:17:30 <dibblego> erg0t, join
14:17:36 <erg0t> thanks
14:17:42 <EvanCarroll> @src join
14:17:42 <lambdabot> join x =  x >>= id
14:18:08 <dibblego> > join (+) 2
14:18:08 <lambdabot>   4
14:18:24 <EvanCarroll> so! any prelude function that makes shuffle as easy as calling a function?
14:18:29 <dibblego> > (\f x -> f x x) (+) 2
14:18:29 <fizruk1> how can I get class implementation for a type?
14:18:29 <lambdabot>   4
14:18:31 <kmc> EvanCarroll, shuffle randomnly?
14:18:34 <EvanCarroll> yea
14:18:49 <CalJohn> EvanCarroll: no, but there is a random shuffle on hackage
14:18:51 <kmc> not that i know of.  randomness will require using a monad at some point, but it's really not that hard
14:18:58 <Raynes> I'll also point out a nice little feature in the Emacs Haskell-mode that puts a type signature on a function for you. C-u-C-c-C-t, I believe.
14:19:05 <mreh> ignore him, Monads are hard
14:19:16 <kmc> what's hard about them?
14:19:16 <dibblego> ignore him, not they aren't
14:19:23 <Raynes> Ignore mreh, Monads are easy.
14:19:26 <CalJohn> kmc: olegs doesn't, it takes a list of (random) ints
14:19:37 <kmc> CalJohn, sure, but where do you get that list?
14:19:45 <fizruk1> monads are seemed to be really simple, what about arrows?
14:20:00 <EvanCarroll> i don't think they're hard, I just don't think i know enough to warrent learning a new concept, there are plenty thing I want to do before I play with monads
14:20:07 <kmc> EvanCarroll, that's a good attitude i think
14:20:09 <EvanCarroll> like memoirze DAta.*
14:20:27 <dibblego> fizruk1, the single biggest problem to overcome is understanding higher-kinded polymorphism; after that it is easy -- both arrows and monads require this
14:21:01 <EvanCarroll> what i do is sit in ##php, read their stupid questions (because its like project euler without the need to ever touch wikipedia), and then I write them in the language i'm learning.
14:21:09 <kmc> EvanCarroll, hahaha
14:21:12 <Vulpyne> > foldr (\(x,y) st -> x:y:st) [] [(1,2),(3,4),(5,6)]
14:21:13 <lambdabot>   [1,2,3,4,5,6]
14:21:16 <Raynes> EvanCarroll: Sure, you could memorize Data.*, but you'll probably have to forget the last 10 years of your life in order to have enough room up there to do so.
14:21:36 <kmc> EvanCarroll, be careful, PHP will rot your brain
14:21:49 <EvanCarroll> kmc: oh dude, i had the most amusing convo ever there today
14:22:16 <Vulpyne> > foldr (uncurry ((. (:)) . (.) . (:))) [] [(1,2),(3,4),(5,6)]
14:22:17 <lambdabot>   [1,2,3,4,5,6]
14:22:33 <mreh> calling your album "untitled" is a nightmare of selfreference
14:22:56 <EvanCarroll> Aparently, those php twats that understand about zilch when it comes to security think anonomously hosting text pastes is a problem because some people might up javascript and then use it in phishing attacks.
14:23:04 <nlogax> "untilted" was pretty bad too.. could never find it, until i noticed the spelling
14:23:12 <chowder> any good haskell tutorials that teach by example? I read some of "Learn You A Haskell For Great Good" but its not really what I was looking for.
14:23:19 <EvanCarroll> so the popular trendy and shitty pastbot site, paste2.org, totally lacks the ability to download the raw paste for "security" reasons
14:23:22 <kmc> chowder, Real World Haskell?
14:23:25 <EvanCarroll> pssh, gist.github++
14:23:27 * EnglishGent sets the topic to "what should the topic be? should it be this one?" (an even worse nightmare of self-reference!)
14:23:28 <EnglishGent> :)
14:23:55 <Raynes> chowder: Real World Haskell?
14:23:57 <chowder> kmc: I'll google it
14:24:02 * mreh sets the topic to "Don't read this topic"
14:24:07 <ray> fake world haskell
14:24:14 <kmc> anyone else getting 404s all over these: http://www.haskell.org/ghc/docs/latest/html/libraries/
14:24:24 <EnglishGent> yes - I do too kmc
14:24:26 <EnglishGent> :|
14:24:32 <mreh> haskell school of espressos
14:24:32 * Topic set to "Don't read this topic"
14:24:41 * hackagebot upload: WebBits 2.0 - JavaScript analysis tools (ArjunGuha)
14:24:46 <Raynes> chowder: http://book.realworldhaskell.org/read/
14:24:56 <ray> the kraft of functional macaroni and cheese
14:24:57 <fizruk1> kmc: I do not
14:25:02 <Cale> somehow the version numbers got reintroduced to the links
14:25:08 <kmc> e.g. Data.Set
14:25:09 <Vulpyne> If you read this topic, your closest friend will die in 3 days unless you set the topic in 10 other channels to this!
14:25:14 <Cale> irritating
14:25:26 <ray> data.set is not a 404
14:25:37 <EnglishGent> (Channel c) => setTopic c String -> IO IRC
14:25:38 <kmc> this is a 404 for me: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html
14:25:41 <EnglishGent> (sorry) :)
14:25:51 <mreh> who here gets to use Haskell in their jorb?
14:25:53 <ray> yeah, that is
14:25:58 <ray> but the link from that page has the version number
14:25:58 <Vulpyne> mreh: I do!
14:26:01 <Cale> kmc: The directories moved so that containers has a version number on it again
14:26:06 <mreh> Vulpyne: who do you work for?
14:26:07 <EnglishGent> ooh - Vulpyne, where do you work?
14:26:08 <ray> containers-0.3.0.0
14:26:15 <jmcarthur_work> mreh, i might in the somewhat near future have a cool haskell project at work
14:26:17 <Cale> kmc: This happened for about a week after the last GHC release too
14:26:24 * EnglishGent would love to have work that didnt involve Java, C# or the like
14:26:24 <Vulpyne> EnglishGent: A VOIP company called TelIAX.
14:26:33 <kmc> oh, 6.12.1 released today!
14:26:35 <kmc> :)
14:26:41 <aavogt> mreh: you can fit it in for random scripts sometimes
14:26:42 * kmc hugs GHC team
14:27:05 * Raynes isn't upgrading.
14:27:11 * Cale upgrades
14:27:13 * kmc will upgrade when Platform upgrades
14:27:14 * Vulpyne upgraded first thing this morningc.
14:27:16 <mreh> I wouldn't use haskell for string processing
14:27:22 <kmc> ...but i already broke my cabal somehow :/
14:27:24 <Raynes> I just upgraded to the .4 a few days ago.
14:27:30 <kmc> is there a working cabal-install for 6.12.1?
14:27:35 <jmcarthur_work> mreh, why not?
14:27:41 <Vulpyne> kmc: I had to grab the darcs one.
14:27:48 <mreh> i
14:27:50 <lispy> cale: did I give you sudo on the linode box?
14:27:53 <mreh> i'm afraid of haskell :(
14:27:57 <Cale> lispy: no?
14:27:57 * ray will also upgrade when platform does
14:28:06 <lispy> Cale: I meant to...I should fix that
14:28:07 <Vulpyne> parsec is nice for string parsing.
14:28:08 <mreh> perl is so quick and dirty for string processing
14:28:10 <Cale> lispy: If you have, I've never used it :)
14:28:14 <ray> dirty is right
14:28:17 <mreh> simple stuff
14:28:23 <kmc> Haskell does require you to think a little more up front
14:28:24 <ray> haskell is quick and typesafe
14:28:26 <mreh> maybe if I were parsing complex files
14:28:30 <Jedai> mreh: it's surprisingly good when you're used to it, not exactly the same tools as everywhere else but quite effective (and I say that from the point of view of a good Perl programmer)
14:28:32 <lispy> Cale: okay.  I seem to be MIA here a lot, so I thought it might be useful for you
14:28:42 <jmcarthur_work> mreh, for the quick stuff i just use awk and sed ;)
14:28:43 <kmc> if your program will grow to the point where it's not obviously correct by inspection, you might want to use Haskell
14:28:49 <mreh> Jedai: good perl programmer: isn't that an oxymoron?
14:28:56 <ray> no
14:29:02 <ray> good perl programer === bad programmer
14:29:05 <Vulpyne> I spend way more time thinking in Haskell than writing Haskell code.
14:29:11 <kmc> you can write good code in Perl.  the problem is that no two people do it the same way
14:29:13 <ray> double negation elimination, or something
14:29:18 <kmc> and the other problem is that Perl is just terrible
14:29:20 <EnglishGent> I thought the new Perl compiler was written in Haskell (I'm serious!)
14:29:28 <kmc> EnglishGent, there is a Perl6 implementation in Haskell
14:29:28 <ray> you mean pugs
14:29:35 <lament> kmc: would two people write Haskell code the same way?
14:29:37 <kmc> every language that's heavily based on implicit type conversions turns out to be a trainwreck
14:29:44 <Vulpyne> Don't not not stop not programming in Perl.
14:29:49 <kmc> lament, significantly, yes
14:29:49 <Jedai> mreh: ray : You can write good Perl, it's just extremely lax on everything
14:29:50 <EnglishGent> mind you - I try hard to avoid Perl
14:29:53 <kmc> they would be able to understand each other
14:30:11 <mreh> Perl is like the working mans programming language
14:30:26 <kmc> that sounds bogus to me
14:30:28 <Cale> Pugs has been inactive for a while from what I understand
14:30:31 <ray> i don't actually hate perl or anything, it's just an easy target
14:30:34 <kmc> the working man wants to memorize hundreds of special-case rules?
14:30:35 <Cale> but it was the first implementation of Perl 6.
14:30:36 <mreh> it's pedestrian
14:30:36 <ray> i believe pugs died
14:30:51 <lament> I used to think perl is completely evil but now I see some point to it
14:30:56 <Jedai> That may seem strange or even heretic to you but I actually find Perl and Haskell quite similar in certain ways
14:31:06 <Vulpyne> *gasp* You take that back!
14:31:07 <kmc> the problem with Perl is that everything is irreducible implementation magic.  Python has a similar feel of lightweight scripting, but most stuff is implemented in terms of a few core concepts
14:31:11 <mreh> kmc: it's not hard to get into though, it's quick to learn if you already know java/c
14:31:30 <lament> perl is overcomplicated and baroque, but so are many other things generally considered good
14:31:31 <mreh> kmc: yeah perl does have that aftertaste
14:31:35 <lament> like chess
14:31:42 * Raynes will upgrade when the platform does.
14:31:42 <Cale> mreh: Depends on what you mean by 'learn'
14:32:01 <lament> sometimes, it seems, people are more loyal to things when these things are overcomplicated and baroque
14:32:06 <DerisionSnort> @pl \a b -> foldr (:) b a
14:32:06 <lambdabot> flip (foldr (:))
14:32:25 <mreh> i doubt many real people see the point in haskell though
14:32:27 <lament> (emacs, vim, nethack come to mind)
14:32:35 <Jedai> something about the philosophy of TIMTOWDI, and the crazy peoples maybe
14:32:59 <DerisionSnort> rev = foldl (flip (:)) []
14:32:59 <DerisionSnort> app = flip (foldr (:))
14:32:59 <DerisionSnort> How cool is that, rev and app look very similar :)
14:33:11 <mreh> haskell has no USP, it does everything, but it has no hook
14:33:37 <EnglishGent> haskell is very TIMTOWDI -- http://www.willamette.edu/~fruehr/haskell/evolution.html
14:33:50 <kmc> :t let app = flip (foldr (:)) in app
14:33:51 <lambdabot> forall a. [a] -> [a] -> [a]
14:34:04 <kmc> EnglishGent, that's a wonderful article :)
14:34:16 <DerisionSnort> > flip (foldr (:)) "hello" "world"
14:34:17 <mreh> EnglishGent++
14:34:18 <lambdabot>   "helloworld"
14:34:33 <mreh> I've overdosed on haskell today, must drink tea
14:34:41 <EvanCarroll> I came to haskell from perl, because I'm being sold on haskell as a more expressive language. even though it is fundamentally different.
14:34:49 <Jedai> EnglishGent: Right, it is, except it manage to do it without being baroque and adhoc, it's just its expressivity that allows it (which is why I consider Haskell superior to Perl on this point)
14:35:01 <EnglishGent> :)
14:35:04 <absentia> does 6.12.1 support 64bit on snow leopard?
14:35:05 <kmc> a good language has a small number of highly composable features
14:35:23 <DerisionSnort> @src (++)
14:35:23 <lambdabot> []     ++ ys = ys
14:35:23 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:35:23 <lambdabot> -- OR
14:35:23 <lambdabot> xs ++ ys = foldr (:) ys xs
14:35:26 <Jedai> EvanCarroll: Yep, I had quite the same feeling, mind you I already had some background in OCaml
14:35:29 <EnglishGent> one of my aims (in terms of learning the language) is to be able to understand all of those!
14:35:30 <EvanCarroll> If there was an absolute unbiased ranking of expressiveness without regard to complexity i'd probably learn the language at the top of the list, right now that seems to be haskell.
14:35:36 <Baughn> EnglishGent: Interesting. This time, I actually understand all of the code.
14:35:39 * EnglishGent would appreciate help with some of them! :)
14:35:53 <EnglishGent> congrats Baughn!
14:36:03 * EnglishGent does not yet, but would love to have you explain some of it :)
14:36:26 <Baughn> EnglishGent: It would be more correct to say that I am confident of understanding all of them, should I feel the need to do so. :P
14:36:30 <Baughn> Some need, er, decoding.
14:37:06 <Jedai> Baughn: quite literally for some of them ;)
14:37:08 <mreh> but why not chose perl instead of haskell, it's not the baroqueness of it, it's the reasoning you can do
14:37:18 <fizruk1> can i ask lambdabot to show me implementation of typeclass for certain type?
14:37:24 <kmc> @src Monad Maybe
14:37:24 <lambdabot> Source not found. Sorry.
14:37:25 <mreh> nup
14:37:27 <kmc> @src Maybe Monad
14:37:27 <lambdabot> Source not found. My brain just exploded
14:37:30 <kmc> :(
14:37:35 <fizruk1> :(
14:37:47 <DerisionSnort> @src Maybe
14:37:48 <lambdabot> data Maybe a = Nothing | Just a
14:37:52 <mauke> @src Maybe return
14:37:53 <lambdabot> return              = Just
14:37:56 <mreh>  @src is just a text file somewhere
14:38:02 <kmc> @src Maybe (>>=)
14:38:05 <lambdabot> (Just x) >>= k      = k x
14:38:05 <lambdabot> Nothing  >>= _      = Nothing
14:38:08 <kmc> aha
14:38:09 <Jedai> mreh: I think I already expressed my feeling that Haskell was superior to Perl on almost everything
14:38:11 <kmc> @src Monad
14:38:12 <lambdabot> class  Monad m  where
14:38:12 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:38:12 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:38:12 <lambdabot>     return      :: a -> m a
14:38:12 <lambdabot>     fail        :: String -> m a
14:38:16 <fizruk1> @src (->) r >>=
14:38:17 <lambdabot> Source not found.
14:38:27 <kmc> @src ((->) e) (>>=)
14:38:27 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:38:31 <kmc> @src ((->) a) (>>=)
14:38:31 <lambdabot> Source not found. Wrong!  You cheating scum!
14:38:34 <kmc> @src ((->) r) (>>=)
14:38:34 <lambdabot> Source not found. Sorry.
14:38:39 <pragma_> shut the fuck up
14:38:45 <fizruk1> :)
14:38:48 <kmc> @quote fuck
14:38:48 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
14:38:51 <Baughn> fizruk1: The better way is to look it up on hackage/ghc haddockumentation, and click the "source" link next to the type definition. Hopefully the instance will be nearby.
14:39:02 <Jedai> mreh: Well, except that Hackage is still not really up to the CPAN
14:39:11 <Baughn> .."haddockumentation"...
14:39:23 <DerisionSnort> :t (:)
14:39:24 <lambdabot> forall a. a -> [a] -> [a]
14:40:18 <fizruk1> f >>= g = g . f ?
14:40:29 <mreh> that's amazing kmc!
14:40:36 <mreh> i didn't know that worked
14:40:36 <kmc> ?
14:40:42 <kmc> ah me either
14:40:50 <mreh> did someone type those all out?
14:40:54 <kmc> @src Either (>>=)
14:40:54 <lambdabot> Left  l >>= _ = Left l
14:40:54 <lambdabot> Right r >>= k = k r
14:41:08 <jmcarthur_work> mreh, the quotes?
14:41:09 <dibblego> @src (->) (>>=)
14:41:10 <lambdabot> f >>= k = \ r -> k (f r) r
14:41:15 <mreh> no, the @src listings
14:41:16 <kmc> ah
14:41:34 <kmc> yeah it's confusing that src is inconsistent about kinds
14:41:47 <jmcarthur_work> huh
14:41:52 <mreh> @src Identity (>>=)
14:41:53 <lambdabot> m >>= k  = k (runIdentity m)
14:41:55 <kmc> @src ErrorT lift
14:41:55 <lambdabot> Source not found. I am sorry.
14:42:04 <DerisionSnort> @pl \a -> a
14:42:05 <lambdabot> id
14:42:09 <DerisionSnort> @src id
14:42:09 <lambdabot> id x = x
14:42:54 <mreh> @src Identity
14:42:54 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
14:43:00 <fizruk1> @src
14:43:01 <lambdabot> src <id>. Display the implementation of a standard function
14:43:06 <fizruk1> @pl
14:43:07 <lambdabot> (line 1, column 1):
14:43:07 <lambdabot> unexpected end of input
14:43:07 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:43:36 <mreh> fizruk1, @pl rewrites an expression in "pointfree" style
14:43:48 <mreh> without any lambdas
14:43:48 <fizruk1> any one?
14:44:11 <mreh> any expression apart from "do" expressions
14:44:13 <mreh> @undo
14:44:17 <lambdabot> ()
14:44:22 <kmc> hehe
14:44:30 <kmc> "do nothing, successfully"
14:44:34 <fizruk1> @pl \x y -> x + 2*y
14:44:35 <lambdabot> (. (2 *)) . (+)
14:44:36 <mreh> lambdabot is so inconsistant
14:44:50 <absentia> bah! the paths in the 6.12.1 install docs.. are wrong :-<
14:45:01 <mreh> you can rewrite any expression with (.) and flip
14:45:21 <fizruk1> i think, i got that
14:45:33 <mreh> @pl \x y z -> f z y x
14:45:33 <lambdabot> flip (flip . flip f)
14:45:37 <mauke> mreh: how do I express \f x -> f x x using only (.) and flip?
14:45:47 <mreh> alright, smarty pants
14:46:01 <fizruk1> @pl \x y -> x >>= \z -> y z
14:46:02 <lambdabot> (>>=)
14:46:25 <fizruk1> @ x >>> y
14:46:42 <fizruk1> @pl x >>> \z -> y
14:46:43 <lambdabot> x >>> const y
14:46:57 <mreh> okay okay
14:46:58 <dibblego> fizruk1, >>> is more like flip (.) rather than >>=
14:47:09 <kmc> :t (>>>)
14:47:10 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
14:47:17 <kmc> ah right
14:47:34 <kmc> :t id
14:47:35 <lambdabot> forall a. a -> a
14:48:03 <fizruk1> what is the magic of forall?
14:48:22 <kmc> to what magic do you refer?
14:48:26 <kmc> it's a universal quantifier over types
14:48:32 <mreh> GHC extension
14:48:33 <fizruk1> i know, it allows to create heterogenous data types
14:48:38 <kmc> it cannot be written explicitly in standard Haskell 98
14:49:01 <kmc> fizruk1, that would be existential, not universal quantification.  which (confusingly) uses the same keyword, but in a diferent position
14:49:11 <mreh> @pl \f x -> f x x
14:49:12 <lambdabot> join
14:49:21 <kmc> very simple standard functions like "id" and "map" have foralls in their types
14:49:21 <kmc> :t map
14:49:22 <mreh> how does she do it?
14:49:22 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:50:06 <mreh> i like how @pl is @pl and not @pf
14:50:09 <fizruk1> this forall is just for readability in type specification?
14:50:20 <mreh> its more than that
14:50:27 <kmc> fizruk1, GHC extends the Haskell 98 type system in ways that require explicit "forall"
14:50:30 <kmc> :t runST
14:50:31 <lambdabot> forall a. (forall s. ST s a) -> a
14:50:36 <kmc> ^^^^ that can't be written in haskell 98
14:50:50 <kmc> basically, in H98, every type variable gets an implicit "forall" all the way at the left of the type
14:51:06 <kmc> if you want your forall to be inside a function argument, as with runST, that's called "rank N polymorphism" and is an extension
14:51:16 <mreh> if you omit it GHC just assumes you put it there right?
14:51:23 <EvanCarroll> I keep seeing forall
14:51:27 <EvanCarroll> I still don't know what it does
14:51:33 <EvanCarroll> forall voodoo
14:51:34 <kmc> (specifically, if a rank-N type occurs to the left of (->), the overall type is rank N+1)
14:51:43 <EvanCarroll> it looks like some sort of iterator, but I take it that it isn't so simple
14:51:46 <kmc> EvanCarroll, look at the type of map
14:51:47 <kmc> :t map
14:51:48 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:52:08 <EvanCarroll> so an iterator that takes a variable amount of elements?
14:52:11 <kmc> that means, "no matter what types A and B you choose, you can use the function map as if it had type (A -> B) -> [A] -> [B])
14:52:11 <mreh> it's an existential quantifier, it's in first order logic
14:52:17 <kmc> i don't see what forall has to do with iterators
14:52:25 <EvanCarroll> it just sounds like an iterator
14:52:34 <mauke> not every word that matches /^for/ is "foreach"
14:52:39 <kmc> EvanCarroll, it's "for all types" not "for all elements in this sequence"
14:52:54 <EvanCarroll> fair enoug
14:52:55 <kmc> do you understand the forall in map?
14:53:12 <fizruk1> i think, i understand
14:53:17 <EvanCarroll> ya but why is it needed?
14:53:25 <fizruk1> like in id and every simple function
14:53:29 <kmc> it's not, because type variables get an implied forall
14:53:32 <EvanCarroll> i mean can't map just have a a regular definition of (a->b)->[a]->[b]
14:53:36 <kmc> EvanCarroll, that's equivalent
14:53:49 <EvanCarroll> so what does the `forall a b` do?
14:53:52 <kmc> the types "a -> a" and "forall a. a -> a" are the same (assuming there are no ScopedTypeVariables)
14:54:00 <kmc> EvanCarroll, nothing in this case
14:54:08 <EvanCarroll> so what is the purpose in the cases where it would matter?
14:54:12 <kmc> :t runST
14:54:13 <lambdabot> forall a. (forall s. ST s a) -> a
14:54:14 <EvanCarroll> and why was that chosen there?
14:54:35 <fizruk1> data X = forall a. X a
14:54:45 <kmc> EvanCarroll, compare these two types:  "(forall a. a) -> Int" versus" forall a. (a -> Int)"
14:54:47 <fizruk1> can i write something like that ^^
14:54:53 <mauke> fizruk1: yes
14:54:56 <kmc> fizruk1, yes, that's an existential type
14:54:57 <kmc> EvanCarroll, both are functions
14:55:01 <fizruk1> and than use [X] type?
14:55:10 <fizruk1> and that would be heterogenous list?
14:55:19 <kmc> "forall a. (a -> Int)" accepts any type, and returns an Int
14:55:21 <mauke> yeah, sort of
14:55:52 <kmc> "(forall a. a) -> Int" *requires* that its argument be polymorphic
14:55:53 <fizruk1> what else can be forall used?
14:56:02 <kmc> so pretty much the only thing you could pass there would be "undefined"
14:56:12 <fizruk1> what for?
14:56:25 <jmcarthur_work> my wife got this as a captcha on craigslist today: cresc ⊥
14:56:53 <jmcarthur_work> sorry that was more appropriate for -blah
14:57:14 <kmc> fizruk1, yes, it would be a heterogenous list in some sense
14:57:21 <kmc> you would also be unable to use the elements of the list in any way
14:57:27 <kmc> because you know nothing about their concrete types
14:57:39 <kmc> data X = forall a. (Show a) => X a
14:57:43 <fizruk1> hmm
14:57:48 <kmc> now if you have [X], it's a heterogeneous list, and you can show each element
14:57:59 <kmc> that is, if you pattern match (X x), x has type (Show a) => a
14:58:07 <mauke> which is effectively [String] :-)
14:58:07 <kmc> but you can't do anything else
14:58:43 <fizruk1> magic :: [X] -> String
14:58:43 <fizruk1> magic [] = ""
14:58:43 <fizruk1> magic x:xs = show x ++ " " ++ magic xs
14:59:01 <kmc> magic ((X x) : xs) = ...
14:59:14 <fizruk1> oh, ya...
14:59:34 <fizruk1> (X x) - looks like dead-smiley?
15:01:41 <kmc> hehe
15:01:41 <fizruk1> another question: am i right that newtype is like type, but not a synonym?
15:01:50 <kmc> that makes it very much not like type
15:01:56 <mauke> newtype is like data
15:02:07 <kmc> it's more useful to think of newtype as like data, but restricted to certain cases and more efficient for those cases
15:02:17 <kmc> there is actually one semantic difference though
15:02:54 <fizruk1> what difference?
15:03:13 <kmc> consider: data A = A Int; newtype B = B Int
15:03:28 <kmc> the values (undefined) and (A undefined) can be distinguished
15:03:35 <kmc> but (undefined) and (B undefined) can't
15:03:42 <fizruk1> hmm...
15:03:45 <kmc> if you have "data" with exactly one constructor and exactly one field for that constructor, you can replace it with "newtype"
15:03:54 <Peaker> fizruk1: newtype is like "type" in function, but like "data" in form...
15:04:05 <kmc> it's not like "type" in function
15:04:15 <ray> you can't unify with newtypes
15:04:21 <kmc> "newtype" and "data" are very much closer than either is to "type"
15:04:33 <kmc> the point of using "newtype" over "data" is that you avoid a runtime performance penalty of wrapping/unwrapping the constructor
15:04:46 <Peaker> newtype creates a type that is isomorphic to an existing type, like "type". In this sense it is closer to "type" than to "data"
15:04:47 <ray> type is almost just a macro replacement
15:04:54 <kmc> Peaker, "type" does not create a type
15:04:57 <Peaker> kmc: and the isomorphism which helps reasoning about it
15:05:13 <ray> newtype creates an isomorphic type, type just gives a type an alternate name
15:05:24 <Peaker> kmc: well, a type synonym creates no new type, and the type is isomorphic to itself :)
15:05:34 <CalJohn> kmc: that's a point.  why does ghc not turn single constructor, single field data's into newtypes?
15:05:45 <kmc> CalJohn, because they have different semantics
15:05:53 <ray> see the semantic difference mentioned above
15:05:55 <kmc> newtype will use the same runtime representation as the underlying type, so you get the compile time checking but no runtime overhead
15:06:11 <kmc> but this also means that you can't distinguish undefined and (B undefined)
15:06:17 <kmc> as the B constructor has no runtime representation
15:06:36 <Peaker> If you like unlifted type products -- there's little reason to use "data" over "newtype" when the latter is applicable
15:06:48 <Peaker> I wish newtype was "product" instead
15:06:56 <Peaker> for unlifted products in general
15:06:57 <kmc> newtype doesn't create a product...
15:06:57 <CalJohn> yes, that's true
15:07:02 <kmc> you can only have one field
15:07:26 <kmc> people will write "newtype A = A (Int, Char, Bool)" but i think this is strictly worse than "data A = A Int Char Bool"
15:07:32 <kmc> they have the same amount of wrapping
15:07:50 <fizruk1> so, newtype has exactly one field?
15:07:52 <kmc> and the same amount of compile-time type safety
15:07:58 <kmc> fizruk1, yes, and exactly one constructor
15:08:02 <Asztal> You could do "deriving Ix" on the former though.
15:08:10 <kmc> Asztal, that's a good point
15:08:15 <kmc> hadn't thought of that
15:08:37 <ray> you can even get a free deconstructor with record syntax
15:08:39 <Peaker> kmc: I wish it did create a product
15:08:41 <ray> for your one field
15:08:50 <Peaker> kmc: if someone wants unlifted products, someone really wants unlifted one-constructor types :)
15:08:51 <fizruk1> deconstructor?
15:09:32 <ray> newtype Newtype = Constructor { deConstructor :: Integer }
15:09:34 <ray> or what have you
15:09:40 <fizruk1> so, i should use newtype, when it is not ugly to use one field and i want performance?
15:09:51 <ray> Constructor :: Integer -> Newtype; deConstructor :: Newtype -> Integer
15:09:56 <kmc> Peaker, i don't follow.  if you have a product then you have to introduce a new constructor to hold the multiple fields, and then it's not newtype
15:10:04 <kmc> fizruk1, correct
15:10:14 <fizruk1> cool :)
15:10:22 <kmc> use newtype when two things should have the same runtime representation, but you want a compile-time check against mixing them
15:10:35 <Peaker> kmc: I wish Haskell had a "product" keyword instead of a "newtype" keyword, such that you could have only one constructor in it (like newtype) but more than one field in it -- and all fields would be unlifted, bottom-wise
15:10:48 <ray> also note GeneralizedNewtypeDeriving ghc extension
15:10:51 <kmc> Peaker, would that be like an unboxed tuple?
15:11:04 <Peaker> kmc: not sure what the semantics of unboxed tuples are
15:11:42 <Peaker> kmc: product Product = Product Int String Int -- undefined is indistinguishable from Product undefined undefined undefined -- you can match against Product always, even if everything is undefined
15:11:48 <Peaker> s/match/pattern match
15:11:55 <kmc> Peaker, what about just using "data" with strict fields?
15:12:12 <kmc> or an irrefutable pattern match?
15:12:18 <kmc> > let ~(_, _) = undefined in ()
15:12:19 <lambdabot>   ()
15:12:46 <kmc> > let (_, _) = undefined in ()
15:12:47 <lambdabot>   ()
15:12:51 <kmc> hrm
15:12:57 <kmc> > let Just _ = undefined in ()
15:12:58 <lambdabot>   ()
15:13:07 <Peaker> kmc: data and strict fields have different semantics -- you can't just always successfully match against the constructor..  If you always use lazy pattern matches + strict fields then I think it might be the desirable semantics
15:13:08 <fizruk1> what was that?..
15:13:37 <Peaker> kmc: but if lazy pattern matches were *enforced* on this type, it would help with reasoning about it
15:13:45 <fizruk1> what is strict fields?
15:13:58 <fizruk1> strict = not lazy?
15:14:05 <kmc> yeah
15:14:07 <kmc> more or less
15:14:15 <sjanssen> Peaker: wait, didn't this same thing come up last week?
15:14:34 <fizruk1> i saw "!Int" - what lazyness was undone here
15:14:47 <fizruk1> ?
15:15:13 <Peaker> sjanssen: I bring up my pet peeves a lot :)
15:15:36 <Peaker> fizruk1: whenever the outer constructor's evaluation occurs, it also forces the evaluation of that field, even if it could lazily defer it to when it was needed
15:15:44 <Peaker> fizruk1: outer/container
15:16:11 <fizruk1> so, newtype can not have strict fields?
15:16:15 <Peaker> fizruk1: or if its in the context of a function - then it evaluates that argument before evaluating the function body, whether or not it is needed in the function
15:16:35 <Peaker> fizruk1: A newtype only has 1 field - and it is already not wrapped in a lazy constructor, so there's no point, not sure if it will be rejected or not
15:17:02 <fizruk1> thanks for explaining :)
15:17:04 <Peaker> fizruk1: A newtype constructor is not actually evaluated lazily -- it is wrapped/unwrapped only in compile-time
15:17:49 <ksf> @tell conal my firefox is complaining about your blog's rss feed... there's a space in front of <?xml ...
15:17:49 <lambdabot> Consider it noted.
15:20:31 <fizruk1> @src Monoid Any
15:20:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:21:31 <fizruk1> @src Any mempty
15:21:31 <lambdabot> Source not found.
15:21:51 <fizruk1> @src Data.Monoid.Any
15:21:52 <lambdabot> Source not found. Maybe you made a typo?
15:22:03 <fizruk1> sorry
15:22:52 <medfly> uh, I hear @src is just a few stuff people added there
15:24:23 <ray> AHEM
15:25:03 <trofi> @src (+)
15:25:04 <lambdabot> Source not found.
15:25:32 <ray> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Data-Monoid.html#Any
15:27:27 <fizruk1> what is an approximate time to become not noob with Haskell?
15:27:48 <ray> now would be a good time, but whenever you want
15:27:59 <medfly> it should be measured in work hours imo :)
15:28:25 <fizruk1> medfly: and what is it in work hours?
15:28:39 <aavogt> there's a checklist of things you need to know somewhere
15:28:53 <aavogt> you can probably stop at the type level programming though
15:29:15 <aavogt> that's where I stopped at least
15:29:23 <aavogt> roughly speaking
15:29:54 <fizruk1> what does "type-level programming" mean? i think, i misunderstand...
15:30:56 <aavogt> it means calculating things with the compiler's type inference
15:31:29 <Saizan_> exploiting typeclasses with fundeps or type families, in particular
15:31:52 <aavogt> instead of doing those things with actual values which are intended for that purpose
15:32:38 <fizruk1> i think, i need an example...
15:32:57 <Saizan_> the pratical purpouse is to then use such type-level constucts to express even more in your types, making your code safer
15:34:14 <Saizan_> fizruk1: http://haskell.org/haskellwiki/Type_arithmetic
15:34:45 <Kruppe> are there list like structures in haskell that can hold elements with different type signatures?
15:35:16 <kmc> Kruppe, and do what with them?
15:35:17 <copumpkin> Kruppe: not unboundedly, unless you're willing to forget all about the specific type
15:35:35 <kmc> Kruppe, you'd typically make an algebraic datatype using "data" which has a different constructor for each type you want to store
15:35:43 <kmc> then you can store those uniformly, and pattern-match on the constructors
15:35:48 <dcoutts> Philonous: for ghc-6.12 you need the darcs cabal-install
15:35:50 <Kruppe> ah
15:35:52 <Kruppe> ok
15:36:11 <kmc> Kruppe, you can also use existential types to "forget" part of the type and keep only, e.g., the implementation of a typeclass
15:36:22 <Kruppe> kmc: i was basically trying to get some multiple dispatch kind of thing
15:36:38 <gwern> Kruppe: technically hlist can do what you ask, but typically this request betrays an unidiomatic approach
15:36:40 <kmc> if you want to dispatch each element differently based on its "type", you should probably be dispatching based on a constructor instead
15:36:45 <sjanssen> Kruppe: you might be looking for tuples?  They're fixed length vectors that can hold values of several different types
15:37:07 <Kruppe> kmc: yeah thats pretty much what i wanted functionally
15:37:12 <sjanssen> rather, several values with different types
15:37:36 <Gracenotes> multiple dispatch exists as multi-parameter typeclasses
15:37:51 <Gracenotes> if that's the kind of multiple dispatch you mean
15:38:06 <Kruppe> Gracenotes: can you elaborate or point me towards docs?
15:38:06 <Peaker> fizruk1: I'd guestimate that becoming a non-newbie in Haskell (not expert, of course) took me about 100 hours of work spread across a few months
15:38:11 <Peaker> probably inaccurate
15:40:20 <Gracenotes> Kruppe: like, class Intersect a b where intersect :: a -> b -> Bool.
15:41:25 <Kruppe> Gracenotes: oh ok, yeah thats what I want
15:41:27 <Gracenotes> and then, instance Intersect Spaceship Missile. It dispatches on specific combinations of types
15:42:10 <Gracenotes> except I'm not sure what multiple dispatch has to do with heterogeneous lists. For that, you can use multiple constructors, as was mentioned, or to leave it open-ended, existential types on a typeclass
15:42:50 <Kruppe> Gracenotes: well the thing is I want to map a function on a list and have the function do different things based on the type of thing in the list
15:42:59 <Kruppe> Gracenotes: I know how I would do it in OO
15:43:08 <Saizan_> is multiple dispatch the same as multimethod dispatch?
15:43:13 <fizruk1> Saizan_: i am stuck with that notation for class and instance... but i think, i got the idea of type-level programming )
15:43:39 <Gracenotes> I consider multiple dispatch to mean dispatching on >1 type. single dispatch works on 1 type exactly, but can be open-ended
15:43:41 <Saizan_> Kruppe: it seems like you want existentials, or even just records of functions
15:44:18 <Kruppe> Saizan_: not sure what those terms mean
15:44:51 <Saizan_> Kruppe: http://cale.yi.org/index.php/A_look_at_OO_from_Haskell <- this should clarify them
15:45:03 <Kruppe> Saizan_: thanks, ill read through those
15:45:07 <sjanssen> Kruppe: is the set of types you want to use closed or open?
15:45:33 <Saizan_> Kruppe: though, if you're new to haskell, you might be missing a more idiomatic approach to your problem
15:45:45 <Kruppe> Saizan_: which is why im here! :)
15:45:50 <Saizan_> (or algebraic, i should say?)
15:46:06 <Saizan_> heh, but we need the bigger picture to help you with that :)
15:47:44 <Kruppe> Saizan_: ok, im writing someting to read through a c file and to turn the C file into a simple data structure, right now im thinking a list
15:48:15 <Kruppe> Saizan_: the goal is to basically read pragmas and change the code based on the pragmas
15:48:27 <Botje> Kruppe: have you looked at Language.C, then?
15:48:49 <Kruppe> Botje: I did, and it looks pretty nice, but the documentation is slim and their website is down
15:49:04 <Kruppe> Botje: so im a bit lost
15:49:24 <Botje> oh, boo :(
15:49:32 <Saizan_> it looks like you want to define a custom datatype, an abstract syntax tree if you're familiar with the concept, and parse into that
15:49:38 <Botje> you could at the very least steal their data types :)
15:49:48 <Kruppe> Botje: hehe, maybe
15:50:46 <fizruk1> Saizan_: can you redirect me to read something to understand that example's code?
15:50:47 <Kruppe> Saizan_: I think I've seen them before
15:50:54 <Saizan_> one where the alternatives are not marked by different types, but by different data constructors
15:51:43 <Kruppe> Saizan_: alright, so can i dispatch based on pattern matching the constructers?
15:51:51 <Saizan_> Kruppe: yeah
15:52:12 <Kruppe> Saizan_: Is it detailed in the page you linked earlier?
15:53:10 <Saizan_> Kruppe: the page i linked earlier shows you a case where doing it in this latter way is cumbersome so it uses something more like OO, so somewhat
15:53:39 <Saizan_> fizruk1: what do you find obscure in particular? are you familiar with multiparameter typeclasses and functional dependencies?
15:54:44 <Saizan_> Kruppe: http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html <- this shows it more properly
16:03:31 --- mode: irc.freenode.net set +o ChanServ
16:04:21 <Saizan_> np :)
16:06:59 <monochrom> np=p.
16:07:26 <Gracenotes> lies
16:14:10 <kmc> "How Can Haskell Be Saved"
16:14:11 <kmc> lol
16:14:15 <copumpkin> ugh
16:14:27 <copumpkin> how haskell can be saved: by banning the cranks from our fora
16:15:03 <olsner> cranks imply success and thus imply a need to "save" Haskell?
16:20:28 <svk_> Hey, so I'm reading "Learn you a Haskell for Great Good", and at the end of the types chapter it says something about "(Num b) => length :: [a] -> b"
16:20:51 <svk_> I expected "length :: (Num b) => [a] -> b", is that a typo or some legal syntax that I've missed?
16:21:07 <mauke> typo
16:21:15 <svk_> Ah, okay
16:21:25 * copumpkin pokes BONUS_ 
16:29:16 <copumpkin> preflex: seen FunctorSalad
16:29:16 <preflex>  FunctorSalad was last seen on #haskell-blah 8 days, 21 hours, 59 minutes and 30 seconds ago, saying: and too lazy to get it tested...
16:29:33 <copumpkin> that's not a good last thing to be heard saying
16:29:56 <roostaj> preflex: seen roostaj
16:29:57 <preflex>  roostaj was last seen on #haskell 6 days, 19 hours and 30 seconds ago, saying: eldragon: what you say?
16:30:15 <kmc> preflex: seen roostaj
16:30:15 <preflex>  roostaj was last seen on #haskell 18 seconds ago, saying: preflex: seen roostaj
16:30:19 <roostaj> lol
16:30:20 <kmc> preflex: seen kmc
16:30:21 <preflex>  kmc was last seen on #haskell 6 seconds ago, saying: preflex: seen roostaj
16:30:30 <kmc> preflex: seen preflex
16:30:31 <preflex>  what
16:30:32 <roostaj> :D
16:30:37 <kmc> @quote
16:30:37 <lambdabot> CosmicRay says: <CosmicRay> Is there a way to, say, convert from a Word32 to a Word8 when I know the data in question will fit in a Word8? ; <drlion> CosmicRay: just open the file and Word will ask
16:30:37 <lambdabot> you to convert it
16:30:40 <kmc> @quote preflex
16:30:40 <lambdabot> No quotes match. Sorry.
16:31:16 <mauke> preflex: quote
16:31:17 <preflex>  <uninverted> Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
16:33:06 <kmc> @quote RealWorld#
16:33:06 <lambdabot> Heffalump says: (re the RealWorld# token) The compiler knows that it can implement the token using the  arrow of time
16:34:41 <kmc> > integerToBreakfast 4
16:34:42 <lambdabot>   Not in scope: `integerToBreakfast'
16:34:43 <Paczesiowa> huh, I just wrote a class with a method test, the file typeckecks, but I can't ask ghci about type of test because of type error - IncoherentInstances ftw!
16:36:08 <copumpkin> nice
16:37:28 <Paczesiowa> maybe someone already did this: I need a class with a method test :: a -> (), that will only accept monomorphic arguments
16:37:47 <copumpkin> Paczesiowa: not sure I understand
16:38:07 <copumpkin> it already only accepts monomorphic arguments
16:38:18 <copumpkin> or rather, that's the default behavior?
16:38:21 <kmc> @quote dream
16:38:21 <lambdabot> therp says: good morning. I think I have been dreaming of shift/reset continuations...
16:38:23 <Paczesiowa> copumpkin: test (Just "") :: (), but test Nothing should be type error
16:38:23 * tass wants to know why he can't use a part of a list y[x] as a String
16:38:32 <kmc> y[x] ?
16:38:45 <tass> kmc: y = [String]
16:38:48 <tass> x = Integer
16:38:53 <mauke> y !! x
16:38:58 <kmc> y[x] is not the syntax for the xth element of y
16:39:04 <kmc> the (!!) operator will do that
16:39:07 <mauke> > length[x]
16:39:08 <lambdabot>   1
16:39:09 <kmc> but it takes time proportional to x
16:39:16 <tass> kmc: O'rly? Seems I got it wrong then
16:39:21 <copumpkin> Paczesiowa: hm, well with specific instances you'll get an error that the type is ambiguous
16:40:11 <kmc> tass, if you want to lookup values by index, a list is a poor choice of datastructure
16:40:16 <Paczesiowa> copumpkin: I'll get type error, but it could happen in another module
16:40:22 <kmc> > ['a'..'z'] !! 10
16:40:23 <lambdabot>   'k'
16:40:33 <ray> but that is the 11th letter!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
16:40:36 <tass> kmc: I'm trying to write a command parser.
16:40:45 <Paczesiowa> copumpkin: I'd like immediate error like "no instance for ArgumentShouldBeGrounded a"
16:40:48 <ray> actually i never understood why that was 0-indexed
16:40:58 <kmc> > map (cycle ['a'..'z'] !!) $ fix ((0:) . scanl (+) 1)
16:41:03 <lambdabot>   mueval: ExitFailure 1
16:41:06 <copumpkin> Paczesiowa: ah, not sure that's possible
16:41:10 <tass> And I use words to separate the parts of the command
16:41:19 <tass> Or at least that's the idea
16:41:34 <kmc> > map ((cycle ['a'..'z'] !!) . (`mod` 26)) $ fix ((0:) . scanl (+) 1)
16:41:35 <lambdabot>   "abbcdfinvidloznmzlkvfaffkpzonbopdsvnivdybzazzyxvsnfsxpmbnobpqfvavvqlbmnzml...
16:42:11 <kmc> ray, why lists are 0-indexed?
16:42:13 <Paczesiowa> copumpkin: I think it is (with IncoherentInstances), using typeEq x x, I get the correct behaviour, but I can't abstract this double application
16:42:23 <kmc> they aren't, fundamentally -- (!!) is just another library function
16:42:36 <tass> Hrm...
16:43:08 <ray> if there's a good reason for it to be zero-based i have not heard it
16:43:14 <tass> kmc: Got any creative solution that would be Better than separating arguments with words?
16:43:19 <kmc> tass, i don't follow
16:43:26 <copumpkin> ray: there is a good reason for anything to be 0-based
16:43:32 <kmc> in particular i don't see what separating arguments with words has to do with using (!!)
16:43:34 <Paczesiowa> if y wasn't a list, but a function from a list(singleton) of one index - it would work
16:43:40 <tass> kmc: I'm trying to write a command parser.
16:43:42 <Paczesiowa> just like in CMonad
16:43:43 <tass> I said.
16:43:46 <dolio> It's so that scanl (*) 1 [1..] gives the appropriate factorials.
16:43:49 <ray> copumpkin: there is not!
16:43:55 <copumpkin> ray: there is though
16:43:56 <ray> coddling programmers is the opposite of a good idea
16:44:03 <ben> If lists were 1-indexed, what would (!! 0) do?
16:44:09 <copumpkin> no, mathematically it makes a lot of things uglier
16:44:17 <copumpkin> have you tried working for any significant amount of time in mathematica?
16:44:18 <kmc> tass, sure.  you're writing a command parser
16:44:20 <tass> And I need a way of getting the Nth argument
16:44:21 <Paczesiowa> > [1..] !! (-1)
16:44:22 <lambdabot>   * Exception: Prelude.(!!): negative index
16:44:25 <kmc> what do you mean by "separating arguments with words"
16:44:30 <kmc> okay
16:44:30 <copumpkin> I mean matlab
16:44:36 <copumpkin> half of my code is filled with +-1 to compensate for the ugly 1-based indexing
16:44:37 <kmc> you don't want to consume the arguments in order?
16:44:54 <copumpkin> ray: mod + 1-based indexing is terrible, for example
16:45:09 <ray> maybe
16:45:26 <tass> kmc: I.e. I send the parser a string, and want it to split it up in a array of sorts, so I can make use of the arguments sent in some nifty fashion
16:45:36 <ray> about command persers, the 0th thing is supposed to be the name of the program as it was invoked
16:45:37 <copumpkin> ray: it's basically subtract 1, mod, add 1
16:45:39 <kmc> tass, a list and an array are not very similar
16:45:42 <kmc> but a list may be fine here
16:45:52 <kmc> if there aren't too many elements, (!!) should be fine
16:45:59 <kmc> just be aware that it walks the list from the beginning every time
16:46:16 <kmc> if you want faster random-access indexing, look at Data.Sequence or Data.Map
16:46:25 <copumpkin> Data.IntMap!
16:46:26 <copumpkin> zomg
16:46:30 <kmc> yeah, IntMap
16:46:42 <kmc> better yet, build it in such a way that this is a small detail which can be changed later if necessary
16:47:30 <tass> Well, I kinda have worked out how I want the function to work
16:47:33 <kmc> i suppose each command has its own Haskell function
16:47:58 <kmc> rather than passing a list or a Seq or an IntMap of arguments, you can pass a function which retrieves the nth argument
16:48:05 <tass> Not really, I catch them as cases in guards
16:48:16 <kmc> okay, same idea though
16:48:32 <kmc> you leave the implementation of "get nth argument" abstract from the command code
16:48:48 <tass> Hmm, that's an idea.
16:48:58 <tass> Though, I don't know how I'd like to implement that.
16:49:22 <tass> It feels like words should do that for me
16:50:05 <kmc> words returns a list
16:50:10 <tass> Yeah
16:50:26 <tass> And from a list I ought to be able to get out a single value, no?
16:50:38 <kmc> > let xs = words "foo bar baz bleh"; f = (xs !!) in (f 0 ++ "--" ++ f 2)
16:50:39 <lambdabot>   "foo--baz"
16:51:10 <kmc> > let xs = words "foo bar baz bleh" in ((xs !! 0) ++ "--" ++ (xs !! 2))
16:51:11 <lambdabot>   "foo--baz"
16:51:29 <kmc> tass, i am recommending the former and not the latter so that there's less code to change if you want to move away from a list representation
16:52:14 <tass> Hmm, yeah
16:52:29 <tass> That might make for some lengthy code, but I guess that works
16:53:35 <kmc> tass, the only difference is you say "f = (xs !!)" and use f rather than (xs !!) directly
16:53:39 <kmc> shouldn't make the code much longer
16:54:14 <kmc> @src (!!)
16:54:14 <lambdabot> xs     !! n | n < 0 = undefined
16:54:14 <lambdabot> []     !! _         = undefined
16:54:14 <lambdabot> (x:_)  !! 0         = x
16:54:14 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:54:29 <kmc> note that it's a regular user-defined operator, and that's the (recursive) definition
16:59:05 <HugoDaniel> how can i simplify this: (init . init . init . init . init . init)   ?
16:59:13 <kmc> :t init
16:59:14 <lambdabot> forall a. [a] -> [a]
16:59:24 <kmc> :t drop 6
16:59:25 <lambdabot> forall a. [a] -> [a]
16:59:44 <kmc> err wrong way
16:59:45 <mauke> kmc: that's tail
16:59:46 <HugoDaniel> :P
16:59:55 <HugoDaniel> i dont know the size of the list
17:00:07 <kmc> this will construct a totally new list, whereas drop shares
17:00:28 <kmc> :t foldr (.) id $ replicate 6 init
17:00:29 <HugoDaniel> but using drop will require two reverses
17:00:29 <lambdabot> forall a. [a] -> [a]
17:00:44 <kmc> > let f = foldr (.) id $ replicate 6 init in f "Haskell (pronounced [ˈhæskəl][2][3]) is a standardized, general-purpose purely functional programming language"
17:00:45 <lambdabot>   "Haskell (pronounced [\712h\230sk\601l][2][3]) is a standardized, general-p...
17:00:51 <kmc> > let f = foldr (.) id $ replicate 6 init in f "Haskell (pronounced [ˈhæskəl][2][3]) is a standardized"
17:00:52 <lambdabot>   "Haskell (pronounced [\712h\230sk\601l][2][3]) is a standa"
17:01:04 <kmc> :t foldr (.) id
17:01:05 <lambdabot> forall b. [b -> b] -> b -> b
17:01:11 <lament> > "☃"
17:01:12 <lambdabot>   "\9731"
17:01:48 <bos> @hoogle ioException
17:01:48 <lambdabot> Control.Exception data IOException
17:01:48 <lambdabot> Control.OldException IOException :: IOException -> Exception
17:01:48 <lambdabot> Control.OldException data IOException
17:11:47 <RadioApeShot> I am having some trouble formatting a let statement in a do block
17:11:53 <RadioApeShot> Is there some problem with this construct?
17:12:07 <mauke> no
17:12:21 <RadioApeShot> If I keep the whole let on a single line, it is ok
17:12:31 <RadioApeShot> But I can't figure out how to indent to make it work if I want to start a new line
17:12:43 <Kruppe> RadioApeShot: I don't think you can make multiline lets in a do block
17:12:49 <RadioApeShot> Interesting
17:12:52 <Kruppe> Correct me if im wrong though
17:12:53 <mauke> sure you can
17:12:53 <kmc> you can
17:12:57 <kmc> example coming :)
17:13:19 <Kruppe> RadioApeShot: im a bit of a noob to haskell too :P
17:13:29 <RadioApeShot> What is the status with the S-expression front ends for Haskell?
17:13:34 <RadioApeShot> I love s-expressions
17:13:36 <RadioApeShot> LOVE THEM
17:13:52 <lament> uh... there's one and it's probably bitrotten
17:13:55 <Paczesiowa> if only there was a language full of them, huh?
17:14:05 <kmc> Kruppe, RadioApeShot http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14203#a14203
17:14:26 <RadioApeShot> kmc: thanks, lets take a look
17:14:28 <Kruppe> oh right, just without the in
17:14:47 <kmc> RadioApeShot, if you like s-expressions then perhaps you would like to avoid layout for these cases
17:14:55 <RadioApeShot> Avoid layout?
17:14:59 <copumpkin> grr
17:14:59 <RadioApeShot> By using explicit curly braces?
17:15:01 <napping> google liskell. says it works with 6.10.1
17:15:18 <mreh> how does one include compiler flas in ones source code again?
17:15:44 <Paczesiowa> mreh: {-# OPTIONS_GHC #-}
17:15:49 <RadioApeShot> I am trying to be less persnickity about trivial things
17:15:54 <Paczesiowa> {-# OPTIONS_GHC -Wall #-}
17:15:55 <RadioApeShot> I think it gets in the way of productivity
17:16:06 <RadioApeShot> For now, syntax is a trivial thing, I think
17:16:17 <kmc> RadioApeShot, yeah, explicit curly braces
17:16:24 <kmc> you can mix and match
17:18:43 <RadioApeShot> What if I want to return the value in the body of the let
17:19:07 <kmc> i don't follow
17:19:12 <kmc> you can let-bind something, then return it
17:19:29 <kmc> you can use "return" within the let (it's just an ordinary function, after all) but it probably won't do what you expect
17:19:34 <RadioApeShot> Let me just show you the code
17:20:10 <RadioApeShot> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14204#a14204
17:20:28 <kmc> RadioApeShot, rather than using "let ... in" you can use the do-block let syntax that i showed you
17:20:37 <kmc> where then the "return" would be flush with let"
17:20:47 <RadioApeShot> Ah
17:20:53 <kmc> but it should do the same thing
17:20:54 <RadioApeShot> So the difference is in the absence of the in
17:21:01 <RadioApeShot> Well, this doesn't compile
17:21:05 <RadioApeShot> So I hope it doesn't do the same thing
17:21:07 <kmc> why not?
17:21:09 <kmc> what error?
17:21:22 <RadioApeShot> "    parse error (possibly incorrect indentation)"
17:21:36 <kmc> ok then it is syntax
17:21:39 <kmc> try the other one
17:21:39 <RadioApeShot> Besides the line number, no extra info.
17:22:35 <RadioApeShot> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14204#a14205
17:22:38 <RadioApeShot> New code added
17:22:41 <RadioApeShot> Still gives me a parse error
17:22:57 <RadioApeShot> The same one
17:23:01 <RadioApeShot> Indentation is implicated
17:23:22 <kmc> i do not get a syntax error with the second one
17:23:43 <kmc> it loads fine
17:23:59 <RadioApeShot> Oops
17:24:01 <RadioApeShot> My bad
17:24:08 <RadioApeShot> It loads fine for me too.
17:24:09 <RadioApeShot> Thanks.
17:24:17 <kmc> :)
17:28:03 <RadioApeShot> Programming with a strong type system feels solid and pleasant.
17:28:29 <kmc> yes, it gives you the sense that you and the compiler are in agreement about what your program should do
17:28:35 <RadioApeShot> I always liked writing C, but only ever did so for numerically intensive work.
17:28:39 <RadioApeShot> It sort of feels like that
17:28:39 <Kruppe> the very first program i made in haskell was a GA and it worked first try
17:28:41 <RadioApeShot> But less insane
17:28:46 <kmc> Kruppe, :)
17:28:48 <Kruppe> my jaw dropped
17:29:09 <RadioApeShot> So
17:29:22 <RadioApeShot> If you want to do graphics stuff, does the purely functional idiom break down?
17:29:39 <RadioApeShot> Or are there libraries which are highly Haskell-idiomatic
17:29:41 <kmc> RadioApeShot, it depends how.  Most GUI and graphics libraries are imperative, but Haskell is a great imperative language
17:30:25 <kmc> there is also "functional reactive programming", which is a very pure-functional approach to interactive graphics
17:30:31 <kmc> but is still very bleeding-edge
17:30:47 <RadioApeShot> Like Cells?
17:30:52 <RadioApeShot> Doesn't CL have something like that?
17:30:52 <kmc> don't know about that
17:30:59 <RadioApeShot> Cells-gtk, I think it is called
17:31:17 <napping> It's kind of related
17:31:37 <napping> FRP worries a bit more about nice semantics and defining things in terms of other things and so on
17:31:56 * hackagebot upload: text 0.7 - An efficient packed Unicode text type (BryanOSullivan)
17:31:58 <napping> cells seemed more like observers and rerunning code when stuff changes
17:33:03 <kmc> welcome back everyone :)
17:41:40 --- mode: irc.freenode.net set +o ChanServ
17:45:51 <xerox> > let drop'last m = app . foldr (\x (f,n) -> (\l -> if l > m then (x : f (l-1)) else [],n+1)) (\n -> [],0) in drop'last 5 [1..10] -- HugoDaniel :^)
17:45:52 <lambdabot>   [1,2,3,4,5]
17:46:19 <richard> Is there a shorter way to write (\x -> map f [1..x])?
17:46:28 <xerox> map f . enumFromTo 1
17:46:33 <xerox> not sure is shorter
17:46:43 <richard> Thanks
17:47:13 <xerox> > join (&&&) length ("map f . enumFromTo 1","(\x -> map f [1..x])")
17:47:14 <lambdabot>   <no location info>:
17:47:14 <lambdabot>      lexical error in string/character literal at chara...
17:47:25 <xerox> > join (&&&) length ("map f . enumFromTo 1","(\\x -> map f [1..x])")
17:47:26 <lambdabot>   Couldn't match expected type `[a]'
17:47:26 <lambdabot>         against inferred type `([GHC.Typ...
17:47:34 <dibblego> I think you want (***)
17:47:35 <copumpkin> :O
17:47:36 <xerox> > join (***) length ("map f . enumFromTo 1","(\\x -> map f [1..x])")
17:47:37 <lambdabot>   (20,20)
17:47:40 <copumpkin> zomg
17:47:42 <xerox> aha, same :P
17:49:08 <aavogt> funny thing how $ doesn't actually save any characters as opposed to parentheses
17:49:27 <aavogt> err, relative to parentheses
17:49:47 <xerox> > join (***) length ("join (***) length ()", "(length , length )")
17:49:48 <lambdabot>   (20,18)
17:50:07 <xerox> painful and longer, darn.
17:50:21 <aavogt> my point being that length in characters of an expression isn't the only criterion for choosing which form of the same expression
17:50:38 <xerox> agreed, [1..x] is neat.
17:51:39 <aavogt> you must be disagreeing with me since I like the enumFromTo better ;)
17:51:56 --- mode: irc.freenode.net set +o ChanServ
17:52:27 <Kruppe> I like $ because I find it easier to read
17:52:35 <xerox> aww.
17:54:41 <copumpkin> in alt-stdlib, $ is a generic mapping application function
17:55:24 <ddarius> copumpkin: What are you talking about?
17:55:55 <copumpkin> #alt-stdlib, an underground movement to think about alternative ideas for the standard library, if we had no "this would break" constraints
17:55:56 <lunabot>  luna: parse error on input `|'
17:56:08 <copumpkin> but the current idea is to have a Mapping typeclass
17:56:23 <copumpkin> Map is an instance, IntMap is an instance, (a -> b) is an instance, Array is, and so son
17:56:31 <aavogt> > tail [[a,b],[c,d]]
17:56:32 <lambdabot>   [[c,d]]
17:56:32 <copumpkin> (associated types for domain and codomain)
17:56:35 <ddarius> Great googly moogly.
17:56:45 <aavogt> how would it know how deep to go?
17:56:59 <copumpkin> so you view an Array a as a mapping from Int to a
17:57:05 <ddarius> aavogt: It only goes one layer.
17:57:42 <copumpkin> instance Mapping (a -> b) where type Domain (a -> b) = a; type Codomain (a -> b) = b; f $ x = f x
17:57:44 <copumpkin> and so on
17:57:53 <aavogt> oh, so there's no weird instance for deep application
17:58:03 <copumpkin> no
17:58:17 <aavogt> like   instance Mapping a => Mapping (X a) where ...
18:00:39 <copumpkin> anyway, it's fun to throw ideas for alternative stuff
18:01:07 <copumpkin> we've also been playing with the class families and synonym preprocessor
18:01:25 --- mode: irc.freenode.net set +o ChanServ
18:01:39 <ddarius> copumpkin: In Forsythe, a language designed by John Reynolds, arrays have type  (Int -> a) /\ { length :: Int } where /\ means type intersection.
18:02:03 <copumpkin> http://github.com/dorchard/constraintTermExtensions if anyone hadn't come across it
18:02:08 <copumpkin> ddarius: wow, I imagine you don't get type inference in that
18:02:42 <copumpkin> wouldn't it just be the first parameter intersecting with the length?
18:04:21 <ddarius> { length :: Int } is my made up notation for a record having a length field.
18:06:33 <copumpkin> oh
18:07:53 <ddarius> An array is a function and also a record.
18:07:53 <ddarius> I doubt Reynolds considered inference too much, though I may not be remembering something he said.
18:10:56 <mreh> does GHC handle multiparameter type classes by default?
18:11:07 <ddarius> No.
18:11:21 <mreh> I THINK THERE WAS A NETSPLIT GUYS
18:11:27 <kmc> the default is very nearly H98
18:11:31 <xerox> that /might/ be the case
18:11:41 <kmc> hierarchical modules are enabled by default
18:11:46 <kmc> because that'd be effing annoying
18:11:57 <kmc> probably some other stuff
18:12:07 <ddarius> I don't believe there's anyway to disable hierarchical modules.
18:12:09 <mreh> so is all this enabled in Haskell 2010
18:12:16 <aavogt> -XPatternGuards is accepted
18:12:17 <ddarius> mreh: No.
18:12:28 <kmc> mreh, the Haskell 2010 announcement email lists the extensions that were accepted into the standard
18:12:28 <aavogt> but ghc complains
18:12:31 <ddarius> mreh: Only the extensions listed on the Haskell 2010 page will be enabled.
18:12:36 <kmc> most of them are already available in GHC
18:12:41 <kmc> but it's only a small set of the GHC extensions
18:13:01 <aavogt> even the extensions presen in the other haskell implementations too
18:13:48 <crutex> how do you know when to stop iterating when subdomain decomposing?
18:14:24 --- mode: irc.freenode.net set +o ChanServ
18:14:38 <crutex> how do you know when to stop iterating when subdomain decomposing?
18:15:36 <mreh> data Rand g a     instances      RandomGen g => MonadSplit g (Rand g)
18:15:42 <mreh> this makes no sense to me
18:16:02 <xerox> :info MonadSplit
18:27:02 --- mode: irc.freenode.net set +o ChanServ
18:27:03 <crutex> how can you best choose a preconditioner for solving elliptic differential equation
18:28:17 --- mode: irc.freenode.net set +o ChanServ
18:38:50 --- mode: irc.freenode.net set +o ChanServ
18:44:41 <HaskellLove> hi
18:45:24 <amckinley> hey, can someone suggest some techniques for doing IPC between haskell and python code?
18:52:00 --- mode: irc.freenode.net set +o ChanServ
18:52:18 <HaskellLove> I get stack overflow when i do maximum for a list, solution?
18:52:48 <dibblego> use seq
18:53:10 <HaskellLove> what is that?
18:53:22 <aavogt> @type seq
18:53:23 <lambdabot> forall a t. a -> t -> t
18:53:29 <aavogt> it's magic
18:54:09 <mreh> (it isn't really)
18:54:17 <HaskellLove> you mean seqList?
18:54:30 <aavogt> mreh: you can implement it in haskell?
18:54:41 <mreh> aavogt: :(
18:55:03 <mreh> HaskellLove, use foldl'
18:55:03 <HaskellLove> can you give me example how to use it, i lost myself in docs
18:55:13 <HaskellLove> i did use it and still get overflow
18:55:30 <HaskellLove> maximum' = foldl' max              lengths = map length chains            maximumNumber = maximum' lengths
18:57:21 <mreh> > foldl' max 0 [1..100]
18:57:29 <mreh> @botsmack
19:03:17 --- mode: irc.freenode.net set +o ChanServ
19:03:32 <crutex> how do you know when to stop iterating when solving subdomains of elliptical differential equation?
19:03:39 <lunabot>  :o
19:06:11 <HaskellLove> holy shit this is killing my computer... any better way to get maximum number out of a frickin huge list of 1000 000 numbers?
19:06:26 <IceDane> You guys quoted me in your newsletter! I am so proud right now.
19:06:27 <crutex> 1,000,000 numbers isn't much
19:06:34 <crutex> maybe you should use a more efficient structure
19:06:45 <IceDane> I almost feel I have to do some haskell right now.
19:06:56 <HaskellLove> crutex well why my computer crushes when i do maximum over it? :D
19:07:04 <crutex> o_O
19:07:12 <crutex> i'm not familiar with haskell but sounds like you're doing something else wrong
19:07:19 <crutex> something*
19:07:28 <bnijk_> ary
19:07:33 <bnijk_> haxml is scary
19:08:01 <amckinley> hey, can anyone suggest some techniques for doing IPC between haskell and python code?
19:08:02 <luite_> HaskellLove: 1M is not that much, but if you do large computations, you should probably compile (with optimization, ghc -O2) your code
19:08:33 <monochrom> > foldl1' max [1..1000000]
19:08:34 <lambdabot>   1000000
19:08:43 <luite_> there is a foldl1' ?
19:08:45 <monochrom> Works.
19:08:50 <HaskellLove> i did not compile i run it in interpreter should i compile it with make or whatever it was?
19:08:52 <monochrom> Data.List.foldl1'
19:09:10 <monochrom> Takes split of second in interpreter too.
19:09:23 <luite_> ah, not in Prelude apparently
19:10:14 * monochrom jokingly suggests "convert python to haskell"
19:10:59 <monochrom> > foldl1' max (map (1000 *) [1..1000000])
19:11:00 <lambdabot>   1000000000
19:11:06 <monochrom> instantaneous too
19:11:29 <copumpkin> amckinley: someone wrote a nice bridge for ruby, you could probably adapt it with some effort ;)
19:13:36 <bnijk_> is there a haxml tutorial that isn't insane
19:17:36 <monochrom> I dare say it takes more time to send my message to lambdabot than to have lambdabot evaluate it.
19:17:36 <copumpkin> bnijk_: nope
19:17:36 <amckinley> monochrom: thats not totally crazy :) i wrote a bunch of parsec code in haskell as my first haskell project, and ended up writing a python wrapper around it because i was so frustrated with haskell by that point
19:17:36 <bnijk_> :(
19:23:12 --- mode: irc.freenode.net set +o ChanServ
19:23:18 <HaskellLove> so now i got 3 files, .o .hi and another just called as my filename was, what now i am confused
19:23:18 <bnijk_> what's the best way to do a loop in main, based on a timer
19:23:18 <monochrom> Go to sleep and come back tomorrow and hope the netsplit will stop.
19:23:18 <luite_> HaskellLove: you don't need to edit the .o and .hi files, they are intermediate files generated by the compiler
19:23:18 <bnijk_> when gathering user input
19:23:40 <bnijk_> and have another loop in a function below main..polling for something entered
19:23:53 <bnijk_> er, waiting to retrieve something based on its own timer
19:24:00 <bnijk_> forget the message two before this one
19:24:11 <monochrom> I think everything you need is in Control.Concurrent
19:24:15 <HaskellLove> luite_ so how to execute it now? call that file from ghci?
19:24:27 <luite_> HaskellLove: no just run it from the command prompt
19:24:36 <luite_> it's an executable file
19:24:48 <HaskellLove> so the command is run ghc filename?
19:25:09 <luite_> which operating system or shell do you use?
19:25:54 <HaskellLove> ubuntu
19:26:04 <bnijk_> what's the "wait" function
19:26:04 <monochrom> ./filename
19:26:18 <monochrom> @hoogle wait
19:26:19 <lambdabot> Control.Concurrent.QSem waitQSem :: QSem -> IO ()
19:26:19 <lambdabot> Control.Concurrent.QSemN waitQSemN :: QSemN -> Int -> IO ()
19:26:19 <lambdabot> System.IO hWaitForInput :: Handle -> Int -> IO Bool
19:26:30 <monochrom> There is no function called "wait".
19:26:38 <bnijk_> @hoogle sleep
19:26:39 <lambdabot> No results found
19:26:42 <bnijk_> mmn
19:26:49 <bnijk_> so what do i do
19:26:55 <monochrom> Have you read the list of function names in Control.Concurrent?
19:27:01 <bnijk_> what do you think
19:27:11 <monochrom> I think you haven't, that's what I think.
19:27:18 <bnijk_> you think correctly'
19:27:36 <monochrom> OK fine, threadDelay
19:28:11 <bnijk_> haskell needs better documentation >:O
19:28:21 <monochrom> You haven't even read it.
19:28:22 <gwern> @hoogle Int -> IO ()
19:28:22 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
19:28:22 <lambdabot> System.Console.Editline.Readline setCompletionQueryItems :: Int -> IO ()
19:28:22 <lambdabot> System.Console.Editline.Readline setEnd :: Int -> IO ()
19:28:24 <HaskellLove> luite_ ?
19:28:26 <gwern> nope, docs are fine
19:28:31 <bnijk_> not this particular one, no
19:28:35 <monochrom> Theorem: All documentation is good if you haven't read it.
19:28:44 <gwern> PEBKAC...
19:28:47 <luite_> HaskellLove: oh, monochrom already gave the answer, ./filename  in the shell, in that directory
19:29:36 <gwern> (also, it'd be 'runghc filename', not 'run ghc filename'; like rundmx - one is a band and the other is a warning)
19:30:47 <gwern> hm. gitit segfaults
19:30:49 <gwern> interesting
19:31:13 <gwern> internal ghc error: gitit: internal error: stg_ap_pp_ret
19:31:25 <HaskellLove> so compiling like this should be faster then getting result in intrpreter correct?
19:31:31 <Axman6> bnijk_: didn i seriously just see you complain about documentation, when you hadn't read it?
19:31:48 <xerox> ?docs Control.Concurrent
19:31:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
19:31:49 <bnijk_> no
19:31:54 <bnijk_> you didn't
19:32:00 <Axman6> i swear i did
19:32:01 <bnijk_> i'm not complaining about the Control.Concurrent documentation
19:32:06 <bnijk_> the haskell documentation in general
19:32:08 <bnijk_> there needs to be more
19:32:17 <Axman6> there's plenty, what more do you need?
19:32:20 <gwern> ah, that's trie enough
19:32:24 <bnijk_> it's _complete_, but it's frightening
19:32:24 <monochrom> That is a tautology.
19:32:31 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/ and http://haskell.org is plenty!
19:32:38 <gwern> Axman6: well, we need hackage libs which aren't terrible; and the regular docs need more recipes and examples
19:32:57 <Axman6> gwern: i have also said this in the past too :)
19:33:14 <gwern> Axman6: then why have you strayed? :(
19:33:42 <Axman6> well, i don't think the current docs are bad, but i think there are some big improvements that could be made
19:34:33 <gwern> some hackage libs are really atrocious. we have mediawiki, which seems to be a complete binding except it has no docs so you cannot figure out how to use it
19:34:48 <gwern> feed is almost as bad. took me a great deal of time to figure out a basic usage for gitit
19:34:50 <Axman6> yeah :\
19:35:13 <gwern> oh, even more insulting, mediawiki has full haddocks - which say nothing that the module & function names dont' say
19:35:16 <xerox> I guess we are bound to do some head scratching when using libraries for our own good.
19:35:34 * gwern thinks that no, there's just head scratching
19:35:45 <monochrom> Like what mathematicians say about God's math book, there is God's haskell book.
19:36:10 <bnijk_> we're getting into hubris territory here
19:36:10 <xerox> Maybe it's an appendix of the former.
19:36:15 <Axman6> ther sorts of things i want to see added are: usage statistics (downloads and how many packages depend on it), ratings, comments, which are forwarded to the authors
19:36:16 <copumpkin> dogs like getting their heads scratched
19:36:57 <bnijk_> is there a date type
19:36:59 <xerox> Axman6: the best way is to hack the source
19:37:02 <bnijk_> built-in
19:37:12 <Axman6> i'd like to, but i don't understand the source :)
19:37:22 <monochrom> The best way is to erase the source.
19:38:21 <gwern> Axman6: I think most of those things are in hackage-2 or whatever
19:38:23 <monochrom> Things under Data.Time including Data.Time.* are good.
19:39:22 <monochrom> IIRC there is a way you can use its time type for just dates.
19:39:59 <Axman6> anyone who would like to help out should darcs get http://code.haskell.org/hackage-server/
19:42:07 <monochrom> Oh I guess Data.Time.Calendar.Day is the right type for dates.  Data.Time.Format has functions applicable to Day for reading and writing.
19:42:26 <HaskellLove> what is wrong with hoogle? page not found bla bla...
19:42:59 <monochrom> Day belongs to both typeclasses needed by those functions.
19:48:10 <inbuninbu> question for you guys
19:48:27 <inbuninbu> with arrays: prg<-newArray (0,131072) 0 :: IO (IOArray Word16 Word8)
19:48:42 <inbuninbu> this seems to work
19:48:49 <inbuninbu> > readArray prg 0
19:48:49 <inbuninbu> 0
19:48:49 <Axman6> > maxBound :: Word16
19:48:50 <lambdabot>   Not in scope: `readArray'Not in scope: `prg'
19:48:50 <lambdabot>   65535
19:49:40 <inbuninbu> ack
19:49:42 <inbuninbu> *Main Data.Word> 2^16
19:49:42 <inbuninbu> 65536
19:49:46 * copumpkin moos furiously
19:49:46 <inbuninbu> *smacks self in face*
19:50:49 <inbuninbu> it is weird though. why does readArray X 0 work there, and all others do not?
19:56:05 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14209#a14209 - I am on ubuntu, how to do that? Look at the upper lines, in the lower ones he shows how it is not to be done
19:58:58 <Lemmih> inbuninbu: What?
19:59:18 <roostaj> just getting started question: when I say "where (f:_) = firstname" are the parenthesis required lexically or is (f:_) creating a tuple?
19:59:41 <inbuninbu> Lemmih: well if i create an array like i did, with a size greater than the index type will allow
19:59:52 <kmc> roostaj, no comma => no tuple
19:59:58 <dibblego> roostaj, they are required lexically; you're not creating a tuple
20:00:02 <kmc> > let a:b = [1,2,3] in a
20:00:03 <lambdabot>   1
20:00:06 <inbuninbu> it seems odd that it doesn't complain if i read from index 0
20:00:07 <roostaj> kmc, dibblego: thank you
20:00:14 <byorgey> are they actually required?
20:00:18 <kmc> > let f a:b = [1,2,3] in f 3
20:00:18 <sjanssen> roostaj: actually, the parentheses aren't required in this case
20:00:19 <lambdabot>   <no location info>: Parse error in pattern
20:00:20 <HaskellLove> I use elemIndex over a 1000 000 list, it is incredibly slow. Should I convert the list in array, array has functions that will go faster, finding an index of an element?
20:00:25 <kmc> they are required in most circumstances
20:00:27 <sjanssen> kmc's examples cover it
20:00:37 <kmc> :t elemIndex
20:00:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
20:00:40 <roostaj> sjanssen: ok, cool thanks
20:00:46 <kmc> HaskellLove, you should probably use Data.Map
20:00:56 <kmc> map each element to its "index"
20:01:16 <phr> brute force euler 13 algorithm in haskell: 15 seconds.  brute force algo in C: 1 second.  "sophisticated" algo in haskell: 1.5 minutes.  "sophisticated" in C: 0.08 seconds.
20:01:22 <Lemmih> inbuninbu: '131072 :: Word16' overflows to '0'.
20:01:49 <Lemmih> inbuninbu: You essentially wrote: newArray (0,0) 0
20:01:55 <kmc> phr, what Haskell implementation?
20:01:55 <inbuninbu> Lemmih: ah! that makes sense then
20:01:58 <sjanssen> phr: clearly your sophisticated Haskell implementation is just wrong
20:02:04 <jmcarthur> phr: something is very wrong with that
20:02:18 <luite_> HaskellLove: what are you searching for? 1M comparisons should in general be fairly quick, unless the comparions themselves are slow (for example if you are looking for a specific 10000 element list)
20:02:21 <kmc> phr, are you compiling your code with GHC at -O2?
20:02:28 <kmc> and a recent version of GHC (>= 6.10) ?
20:02:34 <phr> kmc yes, 6.10
20:02:41 <inbuninbu> Lemmih: thanks, that's educational :-)
20:02:41 <jmcarthur> phr: hpaste.org?
20:02:44 <phr> sec
20:02:46 <kmc> you can hpaste your code and we can take a look
20:03:05 --- mode: irc.freenode.net set +o ChanServ
20:03:10 <phr> it's pretty messy
20:03:13 <HaskellLove> luite_ i search for index for given element... so elemIndex elemName list
20:03:18 <kmc> these netsplits are making me thirsty!
20:03:34 <luite_> HaskellLove: what kind of element?
20:03:40 <phr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14210#a14210
20:03:44 <HaskellLove> it is a list of Ints
20:03:57 <kmc> > let m = M.fromList $ zip ["foo", "bar", "bleh"] [0..] in M.lookup "foo" m
20:03:58 <lambdabot>   Just 0
20:04:03 <kmc> > let m = M.fromList $ zip ["foo", "bar", "bleh"] [0..] in M.lookup "bleh" m
20:04:04 <lambdabot>   Just 2
20:04:05 <kmc> > let m = M.fromList $ zip ["foo", "bar", "bleh"] [0..] in M.lookup "notfound" m
20:04:06 <lambdabot>   Nothing
20:04:07 <kmc> HaskellLove, ^^^^
20:04:21 * jmcarthur looks up problem 13
20:04:24 <sjanssen> I think this is easily the 10th time someone has come to #haskell with phr's problem :)
20:04:26 <luite_> HaskellLove: like I said, it's easy to compare integers for equality, but set equality or list equality is much harder (or not computable, for infinite lists)
20:04:43 <luite_> oh sorry didn't read your last line
20:04:44 <phr> sjanssen, euler 13 in general, or memoizing being slow?
20:05:05 <luite_> HaskellLove: it's probably not the searching for the element that is slow then
20:05:09 <sjanssen> phr: Project Euler 13
20:05:40 <phr> the dumb brute solution works ok but i thought i'd try speeding it up with memoization
20:05:42 <HaskellLove> phr that is euler 14 i work on it now too
20:05:45 <sjanssen> phr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14210#a14211
20:05:46 <phr> and probably did a lousy job of that too
20:05:55 <kmc> phr, did you see Data.MemoCombinators?
20:06:01 <phr> kmc haven't seen that
20:06:04 <phr> sjanssen, looking
20:06:04 <kmc> http://hackage.haskell.org/package/data-memocombinators
20:06:21 <sjanssen> wait, don't think that was the right place to add strictness
20:06:41 <phr> sjanssen, yeah, i had also tried that and it didn't help noticably
20:06:59 <MoALTz> euler 14 looks perfect for haskell (i did it in python ages ago).
20:07:35 <sjanssen> phr: you don't keep the memoized IntMap around
20:07:47 <phr> whoops, this is problem 14, not 13
20:07:50 <phr> sjanssen, hmm?
20:07:53 <phr> checking
20:08:05 <jmcarthur> i was about to say... memoization for what?!
20:08:33 <sjanssen> phr: you execute xlength 1000000 times, each time making a new memo table
20:08:35 <phr> line 32 doesn't get the new intmap from runstate, and then put keep it around?
20:08:47 <phr> sec
20:09:13 <sjanssen> phr: oh, I was confused by main/main2
20:09:22 <sjanssen> main2 has the problem I describe
20:09:25 <phr> main2 is the brute force alg
20:09:34 <phr> i should have annotated it
20:09:59 <phr> it takes about 15 sec
20:10:22 * jmcarthur takes a stab at the problem
20:11:07 <phr> some of the intermediate values get too large to fit in a 32-bit signed int, by the way
20:11:20 <phr> the thing didn't crash only b/c i happen to be on a 64-bit box
20:11:27 <HaskellLove> phr, isnt this risky? takeWhile (/= 1) . iterate cnext, i havent played around but, do the functions results go bellow zero?
20:11:39 <phr> haskelllove no they can't go below zero
20:11:44 <sjanssen> phr: oh, the problem is lazy max http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14210#a14212
20:12:21 <phr> foldl1' isn't strict?
20:12:21 <derrida> Is there an easy way to auto-format haskell code (maybe in vim?)
20:12:50 <HaskellLove> phr well why dont you say >1, instead of /1? or you mean they dont go below zero at all, like property of the functions, i havent played with them, i have it test >1
20:13:16 <HaskellLove> phr foldl1' is strict yes i used it to redefine maximum
20:13:19 <phr> sjanssen, that sped it to 3.6 seconds!  thanks!!
20:13:35 <sjanssen> phr: xall doesn't use foldl1' prime
20:13:53 <sjanssen> phr: do you see what the problem was?
20:13:54 <phr> oh, i see, right!
20:13:57 <phr> hmm
20:14:29 <phr> and i have to use -XBangPatterns to use that annotation
20:14:58 <HaskellLove> phr how old r u, you are good like really good...
20:14:58 <sjanssen> phr: I prefer to stick {-# LANGUAGE BangPatterns #-} at the top of the file
20:15:24 <phr> haskelllove, i'm terrible ! :)
20:15:39 <sjanssen> phr: the problem could be solved other ways, but bang patterns are the most convenient
20:15:59 <phr> sjanssen, yeah, i'm used to getting an error message saying to set BangPatterns one way or another, but this particular one just said "parse error in pattern" so it took a minute to figure out what to do
20:16:00 <HaskellLove> phr so how old are you man :D
20:16:23 * phr = fogey :)
20:17:00 <phr> haskellove there is no way you can divide a positive number by 2 and get a negative number
20:17:13 <phr> i mean if they go negative it's from int overflow, which means your prog is busted anyway
20:17:18 * phr wants to ban Int
20:17:30 <kmc> @check \n -> (n > 0) ==> ((n / 2) >= 0)
20:17:31 <lambdabot>   No instance for (Test.QuickCheck.Testable
20:17:31 <lambdabot>                     (Test.QuickCh...
20:17:43 <HaskellLove> phr what do you mean positive number ...  i think you mixed me with someone i did not ask that
20:17:53 <kmc> indeed, using Int is usually premature optimization
20:18:15 <phr> vim?)
20:18:15 <phr> <HaskellLove> phr well why dont you say >1, instead of /1? or you mean they dont go below zero at all, ...
20:18:23 <phr> oops
20:19:59 <HaskellLove> phr ah that one  :)
20:20:42 <kmc> :t (==>)
20:20:44 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
20:20:58 <kmc> @instances Testable
20:20:59 <lambdabot> Couldn't find class `Testable'. Try @instances-importing
20:24:06 <HaskellLove> does importing everything from a library will be slower then loading just the thing needed? for example: import Data.List (foldl1')
20:24:07 <HaskellLove>  against import Data.List
20:24:25 <sjanssen> HaskellLove: no
20:26:47 <kmc> HaskellLove, slower to compile or to run?
20:27:02 <HaskellLove> both...
20:27:18 --- mode: irc.freenode.net set +o ChanServ
20:27:23 <HaskellLove> i mean ... any difference at all?
20:27:43 <kmc> i might be slower to compile.  you probably shouldn't care
20:28:11 <kmc> it won't be slower to run; simply importing a module cannot cause extra code to run as in some languages
20:30:54 <phr> sjanssen, is that implementation (with the IntMap and the two nested State monads) basically sort of reasonable?  it looks way ugly
20:31:14 <phr> State actions, i guess i should have said
20:31:31 <sjanssen> the two actions aren't necessary as far as I can tell
20:31:54 <phr> hmm
20:32:54 <sjanssen> phr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14210#a14216
20:33:52 <phr> hmm!!!!  i didn't realize you could do that
20:34:13 <sjanssen> and then your xall can become a foldM
20:34:29 <phr> yeah, that sounds a lot better
20:35:13 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14217#a14217 kmc can you write there how to continue with Data.Map please? I am new to that and the docs is just huge.
20:35:36 <phr> i'm still trying to figure out what your "a <- clen2 x" exactly does, i mean it looks like the right thing but i'm trying to think through the desugaring just to be sure i understand
20:35:57 <kmc> HaskellLove, http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/containers/Data-Map.html
20:36:04 <kmc> i'll mention some important Data.Map functions to know
20:36:25 <tofulivin> @faq
20:36:25 <lambdabot> The answer is: Yes! Haskell can do that.
20:36:28 <phr> HaskellLove you usually want to import Data.Map as qualified
20:36:38 <phr> since it has a bunch of functions that collide with the prelude
20:36:59 <tofulivin> @faq can haskell ruin lives?
20:36:59 <lambdabot> The answer is: Yes! Haskell can do that.
20:37:02 <HaskellLove> phr thanks... maybe i should get in the habit of importing everything as qualified
20:37:23 <phr> HL sometimes it's enough to just import specific symbols
20:37:30 <kmc> HaskellLove: lookup, empty, insert, delete, adjust, union, difference, intersection, toList, fromList,
20:37:34 <kmc> that should get you started
20:37:35 <tofulivin> @faq can haskell put someone in a mental ward?
20:37:35 <lambdabot> The answer is: Yes! Haskell can do that.
20:37:42 <kmc> there are lots of variations on those which may be used to make things more concise
20:37:52 <kmc> HaskellLove, do you understand what a value of type (Map k v) represents?
20:37:59 <phr> HL, I don't understand what you want to do with data.map in that paste
20:38:12 <tofulivin> @faq can haskell take over a country and install me as ruler?
20:38:13 <lambdabot> The answer is: Yes! Haskell can do that.
20:38:29 <kmc> phr, the idea is to map each value to its index in chains
20:38:33 <kmc> to avoid the linear-time elmeIndex search
20:39:11 <phr> oh, with fromList
20:39:54 <phr> cmap = fromList [(n, chain n) | n <- [1..1000000]
20:40:06 <phr> but that still computes each chain the hard way
20:40:37 <HaskellLove> tofulivin please stop that it is getting annoying
20:40:39 <Nigh8ter> Tired of nigggggers and their monkeyshines?  Give us a try at Chimpout Forum!  http://www.chimpout.com/forum   At Chimpout we welcome all non-niggggroid races!  We are an alliance of humans vs. niiggggggers!
20:40:41 <kmc> HaskellLove, i notice you have no top-level type signatures.  perhaps if you write some it will make your error messages more comprehensible
20:40:44 <kmc> HaskellLove, haha
20:41:00 <kmc> Nigh8ter, sheeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeit
20:41:14 <kmc> @ops
20:41:14 <lambdabot> Maybe you meant: docs oeis pl
20:41:29 --- mode: ChanServ set +o Lemmih
20:41:35 --- mode: Lemmih set +b *!*=Nigh8ter@*.76.241.56.dsl.dyn.telnor.net
20:41:35 --- kick: Nigh8ter was kicked by Lemmih (Lemmih)
20:42:30 <HaskellLove> kmc yeah i will try do that from now on, today morning i banged my head over implicit type errors seems i havent learned my lesson yet.. ok from next euler i want to improve this: use . instead of () and write type signatures for everything
20:42:48 <kmc> HaskellLove, it's good to have goals :)
20:43:55 <HaskellLove> it is good to realize goals too :D
20:44:46 <byorgey> kmc: IIRC you wanted "@where ops"
20:46:22 <kmc> byorgey, thanks
20:47:02 <HaskellLove> so you often use Data.Map for lists operations?
20:47:16 <kmc> HaskellLove, no.  i use Data.Map for an associative container
20:47:37 <kmc> meaning that you want to store pairs (k,v), and quickly find the pair given a key value k
20:47:39 <kmc> or test if there is such a pair
20:47:50 <kmc> @quote netsplit
20:47:50 <HaskellLove> got it
20:47:50 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
20:48:17 <phr> HaskellLove, data.map is like a python dictionary, if you're familiar with those.
20:48:25 <HaskellLove> yep
20:48:26 * phr still trying to figure out how to use foldM
20:48:29 <kmc> or like a C++ STL map<k,v>, without the suck
20:48:34 <phr> lol
20:48:49 <phr> @quote kmc Data.Map is like a C++ STL map<k,v>, without the suck
20:48:50 <lambdabot> No quotes match. It can only be attributed to human error.
20:48:55 <phr> @remember kmc Data.Map is like a C++ STL map<k,v>, without the suck
20:48:55 <lambdabot> Good to know.
20:49:07 <fracture> is Data.Map an rb-tree?
20:49:09 <kmc> HaskellLove, also be aware that in the special case where the key type is Int, there's a more efficient Data.IntMap
20:49:11 <fracture> or something different?
20:49:19 <kmc> "The implementation of Map is based on size balanced binary trees (or trees of bounded balance)"
20:49:22 <clarkb> once upon a time I sued STL map to have a switch statement operate on strings, it was ugly
20:49:24 <fracture> ah
20:50:03 <fracture> so... the exact algorithm is not specifed maybe?
20:50:09 <kmc> afaik the interface only guarantees asymptotic complexity; it would be realizable with a variety of different trees
20:50:14 <kmc> well, they give citations
20:50:16 <kmc> to papers
20:51:17 <cocon> I once heard that mergesort is better in functional languages than... what could this mean?
20:51:23 <cocon> than quicksort
20:51:46 <fracture> maybe if the quicksort can't really be done in-place?  (guessing)
20:52:12 <sjanssen> cocon: probably the best part of quicksort is that it can be done in-place on a mutable array
20:52:13 <HaskellLove> kmc ok so i will use Data.IntMap, both keys and values are Ints
20:52:30 <sjanssen> functional languages typically use immutable lists
20:52:32 <cocon> sjanssen: I'm assuming that we're sorting a list
20:53:20 <cocon> so how do quicksort and mergesort compare on immutable lists?
20:54:28 <Axman6> well i believe the advantage of quicksort is that it runs in constant space, which is difficult in a functional language without using mutability
20:54:36 <phr> HaskellLove if you're on a 32-bit machine, better use IntMap Integer
20:55:53 <HaskellLove> phr, IntMap Integer? my keys and values are small enought to be Int, why Integer?
20:55:56 <xerox> cocon: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Data-List.html#sort
20:56:06 --- mode: irc.freenode.net set +o ChanServ
20:56:38 <phr> HL, the values get to be > 31 bits
20:56:58 <xerox> HaskellLove: keys of an IntMap are Ints
20:57:02 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/containers-0.3.0.0/Data-IntMap.html
20:57:05 <Axman6> HaskellLove: an IntMap is a Map, whose values are Ints
20:57:07 <sjanssen> cocon: merge sort has some really nice properties for functional languages
20:57:08 <Axman6> it's a specialised Map, using only Ints for the keys
20:57:12 <xerox> nope, keys are Ints, values are whatever you want
20:57:35 <sjanssen> cocon: head . sort runs in O(n)
20:57:49 <copumpkin> I love that
20:58:43 <HaskellLove> phr where do i say Integer bla bla, i mean, does not haskell take care of that, when needed to place a number in Integer?
20:58:54 <sjanssen> more generally, (take k . sort) is O(n + k log n)
21:00:18 <copumpkin> sjanssen: is there a page with an analysis of that? I was looking for one to cite when preaching haskell to my twitter followers
21:10:46 --- mode: irc.freenode.net set +o ChanServ
21:10:46 --- mode: irc.freenode.net set +o Lemmih
21:10:46 <kmc> "qualified" and "as Foo" are two separate features.  the former requires (rather than merely allowing) the use of qualified names.  the latter changes the qualified name
21:10:46 <luite_> hmm, this is getting annoying
21:13:21 <bos> preflex: seen dons
21:13:21 <preflex>  dons was last seen on #haskell 23 hours, 46 minutes and 33 seconds ago, saying: http://hackage.haskell.org/package/happstack-state
21:16:48 <jmcarthur> i'm pretty sure i saw dons here more recently than that...
21:17:12 <jmcarthur> maybe preflex was netsplitted
21:18:51 <HaskellLove> kmc, what now i am stuck http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14219#a14219 that first line gives me the error
21:19:59 <kmc> HaskellLove, put a type signature on getIndex
21:20:15 <kmc> HaskellLove, see where it says "Probable fix:"
21:20:26 <HaskellLove> i know but what type, i tried getIndex::Integer
21:20:35 <kmc> HaskellLove, what is the return type of "lookup"?
21:20:53 <HaskellLove> lookup :: Ord k => k -> Map k a -> Maybe a
21:21:12 <kmc> so Integer is not Maybe a
21:21:21 <kmc> what's it supposed to return if there's no such key?
21:21:54 <HaskellLove> so i should set it to Maybe Integer?
21:22:00 <kmc> try it
21:22:20 <phr> HL, do you know how Maybe works?
21:22:27 <HaskellLove> yes
21:22:32 <phr> ok
21:22:57 <HaskellLove> but in cases like this i get confused, still getting used to types like programming
21:26:34 <HaskellLove> kmc wow that was fast :D thanks for Data.Map
21:26:39 <kmc> :)
21:27:14 <sjanssen> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14220#a14220 perhaps this formulation of merge sort will be easier for evangelism?
21:27:56 <sjanssen> I want to draw a binary tree with minimum hassle, which hackage package do I use?
21:27:57 <HaskellLove> so now i have the index of the element i want, should i convert the list to array and then use ! instead of using !! with list?
21:28:16 <copumpkin> sjanssen: that's nice
21:28:19 <kmc> you could also use a map in the other direction
21:28:27 <copumpkin> sjanssen: Data.Tree has a pretty-printer
21:28:35 <ddarius> Look.  A variant of my pairUp function.-
21:28:38 <sjanssen> copumpkin: .png would be best
21:28:45 <copumpkin> sjanssen: oh, it's just text
21:28:46 <HaskellLove> the index is 30, maybe i should just keep it simple and use the list !! :)
21:29:02 <kmc> sure
21:29:08 <sjanssen> IIRC byorgey wrote some library?
21:29:25 <ddarius> diagrams?
21:29:33 <ddarius> @hackage diagrams
21:29:34 <lambdabot> http://hackage.haskell.org/package/diagrams
21:29:53 <sjanssen> yeah, that's it
21:31:37 <luite_> ooh that looks fun, I should have known about this thing earlier
21:32:22 * ddarius isn't sure how Haskell could advertise libraries more without taking out TV ads.
21:32:24 <sjanssen> hmm, not sure if diagrams can do want I want, "Lay out a Tree (from Data.Tree) of Diagrams in a top-down fashion. This layout is experimental; future releases of the Diagrams library are planned which will be able to automatically draw edges between nodes in the tree."
21:32:38 <sjanssen> byorgey: are you around?
21:34:52 <ddarius> sjanssen: You can do what everyone else does and use GraphViz.
21:44:07 --- mode: irc.freenode.net set +o ChanServ
21:44:07 --- mode: irc.freenode.net set +o Lemmih
21:44:18 <roostaj> derrida: :) si
21:44:18 <derrida> does anyone know of a really simple drawing context i could use to make some diagrams without getting into windowing stuff?
21:44:18 <bos> derrida: the cairo bindings aren't too bad
21:44:18 <derrida> bos: i've been meaning to look at them
21:44:18 <derrida> have heard others say it's pretty nice
21:44:31 <derrida> i've been using glut but it's really not what i'm looking for
21:44:36 <kmc> sjanssen, i see now
21:44:50 <kmc> GLUT is just a halfassed windowing library for OpenGL
21:45:47 <derrida> it's not good for making diagrams :)
21:46:04 <derrida> unless they involve particle systems maybe
21:48:20 <derrida> is there something new and sdl-like that is being talked about potentially merged into kernel?
21:49:11 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14221#a14221 kmc please one more last
21:52:08 <mmorrow> derrida: maybe look at byorgey's diagrams package, you can probably find some ideas there
21:52:19 <derrida> cool
21:52:25 <mmorrow> @hackage diagrams
21:52:25 <lambdabot> http://hackage.haskell.org/package/diagrams
21:52:46 <derrida> looks perfect
21:52:53 <derrida> :>
21:53:38 <mmorrow> um, sweet.
21:53:42 <phr> HL i think you have the two args reversed to fromList
21:53:43 * mmorrow downloads it too
21:53:54 <phr> i mean to zip
21:53:57 <phr> that you're giving to fromList
21:54:15 <luite_> any idea when the cabal-install for 6.12 will be released?
21:54:46 <derrida> mmorrow: uh, this thing is freaking awesome!? :>
21:54:52 <phr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14210#a14222  here's my current version with foldM, which looks sort of ugly
21:55:13 <phr> wow, diagrams looks cool
21:56:03 <phr> i remember the old unix "pic"
21:56:24 <derrida> ferrers diagram example is really cool
21:56:24 <HaskellLove> phr, u use diagrams? i read book this morning on schematic functional programming so...
21:56:32 <kmc> @wn u
21:56:34 <lambdabot> *** "u" wn "WordNet (r) 2.0"
21:56:34 <lambdabot> u
21:56:34 <lambdabot>      adj : (chiefly British) of or appropriate to the upper classes
21:56:34 <lambdabot>            especially in language use
21:56:34 <lambdabot>      n 1: a nitrogen-containing base found in RNA (but not in DNA) and
21:56:36 <derrida> o O
21:56:36 <lambdabot> [5 @more lines]
21:56:41 <phr> HL, i'm just looking at diagrams for the first time right now
21:56:58 <phr> dammit i hate SnapShots
21:57:01 <derrida> functional schematic programming meaning what
21:57:11 <derrida> that could be cool or really lame
21:57:12 <derrida> haha
21:58:04 <derrida> i know lisp has been used widely in cad systems because of autodesk though
21:59:31 <HaskellLove> phr cool give me some links to check what u seeing :)
21:59:50 <kmc> @wn u
21:59:51 <lambdabot> *** "u" wn "WordNet (r) 2.0"
21:59:51 <lambdabot> u
21:59:51 <lambdabot>      adj : (chiefly British) of or appropriate to the upper classes
21:59:51 <lambdabot>            especially in language use
21:59:51 <lambdabot>      n 1: a nitrogen-containing base found in RNA (but not in DNA) and
21:59:53 <lambdabot> [5 @more lines]
21:59:55 <phr> http://hackage.haskell.org/package/diagrams
22:00:09 <phr> 	http://code.haskell.org/diagrams
22:00:37 <HaskellLove> derrida, a book on that name talks about using a language Clarity that uses schemes with functional programming, so you dont program basically you draw :D
22:02:14 <HaskellLove> phr oh that, i meant diagrams you meant schemes for functional programs
22:05:07 --- mode: irc.freenode.net set +o ChanServ
22:16:59 <sergdf> hi all, i'm looking for a no-fuss fast balanced tree implementation, and I can't find one in the standard libraries. is this true?
22:17:09 <phr> Data.Map?
22:18:19 <sergdf> phr: that seems to be exactly what i want. thanks
22:18:48 * hackagebot upload: trimpolya 0 - Search for, annotate and trim poly-A tail (KetilMalde)
22:20:09 <bnijk_> functional programming is great huh
22:20:58 <bnijk_> if the internet is a big city, this is some weird kind of mansion
22:21:08 <bnijk_> with holograms everywhere
22:21:18 <bnijk_> and fountains that pour rum
22:23:23 <phr> llol
22:23:40 <hiredman> and there's gin on all the rocks?
22:23:46 <HaskellLove> how to convert Maybe Int to Int? isnt it fromMaybe(variable of type Maybe a)
22:23:52 <toast-opt> hmm, Control-Monad.html is 404?
22:24:13 <vegai> HaskellLove: pattern match (Just x)
22:24:26 <HaskellLove> vegai meaning?
22:24:36 <Lemmih> > (fromMaybe 10 Nothing, fromMaybe 10 (Just 20))
22:24:37 <lambdabot>   (10,20)
22:24:43 <kmc> > case Just 3 of Nothing -> "nothing!"; Just _ -> "Something!"
22:24:44 <lambdabot>   "Something!"
22:24:51 <vegai> HaskellLove: what kmc said
22:25:32 <HaskellLove> i dont get it... so my code is this : startingNumber = ((chains !! (fromMaybe getIndex)) !! 0) + 1
22:25:45 <HaskellLove> getIndex is Maybe Int
22:25:57 <Lemmih> HaskellLove: Look at the type of 'fromMaybe'.
22:26:06 --- mode: Lemmih set -o Lemmih
22:26:39 <HaskellLove> a -> Maybe a -> a which means?
22:26:59 <toast-opt> @src fromMaybe
22:26:59 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
22:27:00 <Lemmih> HaskellLove: It takes two arguments: a default value and a Maybe value.
22:27:23 <kmc> > map (fromMaybe 0 succ) [Nothing, Just 3, Nothing, Just 0]
22:27:23 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t'
22:27:24 <lambdabot>         against inferred ...
22:27:24 <Lemmih> HaskellLove: The default value is used if the Maybe is Nothing.
22:27:29 <kmc> > map (maybe 0 succ) [Nothing, Just 3, Nothing, Just 0]
22:27:30 <lambdabot>   [0,4,0,1]
22:27:33 <kmc> > map (fromMaybe 0) [Nothing, Just 3, Nothing, Just 0]
22:27:34 <lambdabot>   [0,3,0,0]
22:31:34 <HaskellLove> wow i finally think I understood Maybe
22:31:47 <bnijk_> yeah me too
22:31:48 <bnijk_> tonight
22:32:00 <bnijk_> and monads make sense too
22:32:37 <bnijk_> and type constructors
22:32:42 <HaskellLove> well i am far from monads for now... maybe is a monad yes but... i am just doing it superficially
22:32:53 <bnijk_> yes i see
22:33:00 <bnijk_> well don't hesitate
22:35:24 <mmorrow> phr: i've got a fairly speedy collatz if you want to peek http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14210#a14224
22:36:25 <phr> looking
22:36:28 <HaskellLove> does it cost more to convert a list into array and then index with !, or to just index the list... i need to get number with index 800 000 something like that so... :D
22:37:23 <mmorrow> HaskellLove: if you only need to index into the list once, (!!) is much cheaper, since to build an array you need to allocate it and walk the entire list filling the array
22:37:27 <phr> HaskellLove, doing one !! lookup will be faster than conversion
22:37:34 <phr> but, the whole approach is a little bit odd
22:37:43 <phr> i think you should just remember the index that gave you the longest length
22:37:52 <phr> rather than building that table
22:38:16 <phr> mmorrow i'm not sure what your version is doing but it's about 2x as fast as mine, assuming comparable hw
22:38:52 <phr> i like to hope that the compiler is smart enough that the bit twiddling in your f fnuction isn't faster than straightforward arithmetic ???
22:40:56 <mmorrow> phr: phr i think it's how you're using foldM,takeWhile,iterate, since GHC doesn't fuse them together
22:41:47 <phr> i'm trying to figure out how to do another version with STUArray instead of IntMap
22:42:06 <mmorrow> phr: heh, unfortunately there's a chance the bit twiddling might actually contribute some too
22:42:46 <phr> mmorrow, the verison i have now doesn't use takeWhile/iterate, it just uses a memo table
22:42:59 <phr> and recursion
22:43:02 <mmorrow> phr: STUArray may be tough, as you'd have to completely change the algo since you couldn't use the lazy knot-tying-memo-table thing anymore
22:43:26 <phr> i'd write it to look like C code.  you can write C in any language ;)
22:43:44 <mmorrow> oh, right. clength isn't used
22:44:31 <mmorrow> hmm, so i guess that leaves foldM as a possible suspect
22:45:22 <mmorrow> phr: oh wait, so you /aren't/ using the knot-tying algo
22:45:24 <HaskellLove> getIndex = M.lookup maximumLength (M.fromList (zip lengths [0..1000000])) ----------- M is Data.Map....... what does lookup actually do? check values only and return index? i cant see the docs hoogle problems
22:45:31 <mmorrow> phr: that may be the cause
22:45:34 <BMeph> mmorrow: Why not use "testBit 0," instead of "_ .&. 1 == 1"? :)
22:45:36 <phr> knot tying?
22:46:20 <mmorrow> BMeph: heh, i don't think i've ever actually used testBit..
22:46:26 <mmorrow> phr: that may be the cause
22:46:29 <mmorrow> oops
22:46:36 <mmorrow> wrong paste buffer..
22:47:00 <mmorrow> let m2 = M.insert n l' m; (l,m3) = go m2 (f n); l' = l+1 in (l', m3)
22:47:13 <mmorrow> which is line about 52 in my paste
22:47:18 <toast-opt> phr, using lazy evaluation to connect back a reference cycle somewhere, which seems surprising in a pure functional (not imperative) language
22:47:38 <mmorrow> m2 ==depends=on==> {n,l',m}
22:47:50 <toast-opt> let a = 0 : a, for instance.  illegal in an imperative language, as it evaluates 'a' before it is initialized
22:48:07 <mmorrow> {l,m3} ==depend=on==> {m2,n}
22:48:21 <mmorrow> l' ==depends=on=> l
22:48:22 <toast-opt> but legal in a lazy context, because 'a' isn't evaluated until its needed, which will be some time after it is bound
22:48:26 <kmc> *cough* Haskell is pure-functional and imperative
22:48:43 <toast-opt> kmc, yes, and you can't tie the knot in an imperative context, no?
22:48:48 <Lemmih> HaskellLove: http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.3.0.0/Data-Map.html#v%3Alookup
22:48:51 <kmc> you can with mdo :)
22:48:54 <mmorrow> so you insert the value into the map /before/ you've computed it, so you've got it stored when it actually becomes evaluated
22:48:55 <toast-opt> mdo?
22:48:59 <kmc> recursive do notation
22:49:01 <kmc> a ghc extension
22:49:07 <toast-opt> heh, fun
22:49:07 <kmc> you can also do it with "mfix", an ordinary function
22:49:08 <kmc> :t mfix
22:49:10 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
22:49:12 <toast-opt> i'd like to see that
22:49:19 <toast-opt> heh, nice
22:49:31 <phr> i'm going to have to look at this more carefully, right now i have people here chatting in the background so i can't think :)
22:49:34 <toast-opt> and which monads survive that?
22:49:43 <toast-opt> all, or only some?
22:50:11 <kmc> the ones that are in MonadFix
22:50:15 <kmc> @instances MonadFix
22:50:15 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:50:25 <mmorrow> phr: this is a neat view of what "tying the knot" accomplishes http://moonpatio.com/vacuum/gallery/dlist.html
22:50:46 <mmorrow> phr: namely, it lets you create cycles of ptrs in the heap, at the lowest level
22:51:22 <phr> yeah, i'm not sure how much that helps here??
22:53:40 <mmorrow> , let a = listArray (0,4::Int) [1,a!0,42,a!0+a!4,7] in a :: Array Int Int
22:53:41 <lunabot>  array (0,4) [(0,1),(1,1),(2,42),(3,8),(4,7)]
22:54:01 <jbapple> My ghci works just fine, but compiling gives me "undefined reference to" errors when importing Data.Map
22:54:10 <jbapple> any ideas?
22:54:30 <Lemmih> jbapple: Use --make.
22:54:38 <mmorrow> phr: in C, you'd accomplish this by leaving a ptr field in some structure NULL, them writing it later once you've computed the answer
22:54:41 <phr> mmorrow, cute, sort of like an IIR filter :)
22:55:01 <jbapple> Lemmih: MAGIC!! Thank you.
22:55:10 <mmorrow> phr: but since you can't mutate stuff in haskell, you've got to resort to value-recursion with let
22:55:12 * kmc <3 ghc --make
22:55:16 <phr> mmorrow, yeah, i just used intmap.lookup which returns Maybe
22:55:24 <kmc> ah you can mutate plenty of stuff in Haskell
22:55:25 <kmc> ;)
22:55:34 <kmc> also Haskell will mutate you if you're not careful
22:55:52 <mmorrow> phr: i'm not positive exactly what's happening, but you might be re-computing things without the knot-tying
22:56:00 <phr> hmm
22:57:27 <toast-opt> so, curious question...
22:57:40 <toast-opt> in filterM, is the list produced still lazy?
22:57:49 <toast-opt> i would suspect not
22:57:52 <kmc> probably... many monads are lazy
22:58:10 <toast-opt> oh, of course
22:58:16 <toast-opt> it depends on the monad, that's right
22:58:24 <kmc> @src filterM
22:58:24 <lambdabot> Source not found. stty: unknown mode: doofus
22:58:35 <toast-opt> but over IO, it would have to be eager, right?
22:58:36 <toast-opt> all or nothing
22:58:55 <toast-opt> (you could, of course, not connect the result to main... but if you do, it's eager, right?)
22:58:55 <kmc> i'm not sure
22:59:08 <kmc> you can make an IO action that returns a lazy infinite list
22:59:15 <toast-opt> of course
22:59:27 <toast-opt> 'return let a = 0 : a in a'
22:59:40 <toast-opt> :t filterM
22:59:41 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
22:59:52 <bd_> toast-opt: there's unsafeInterleaveIO
22:59:54 <bd_> but that's unsafe :)
23:00:05 <toast-opt> :P modulo unsafe*
23:00:15 <kmc> forcing a list to WHNF does not force each element
23:00:20 <kmc> it only forces the (:) at the top
23:00:30 <kmc> > undefined `seq` ()
23:00:31 <lambdabot>   * Exception: Prelude.undefined
23:00:36 <toast-opt> kmc, ok, so the list is forced, but the elements might not be
23:00:39 <kmc> > (0 : undefined) `seq` ()
23:00:40 <lambdabot>   ()
23:00:44 <bd_> anyway the reason you can't do lazy lists in IO is it introduces side effects from lazy computations
23:00:47 <toast-opt> depending on how filter performs its work...
23:00:51 <kmc> toast-opt, indeed, not even all of the spine is forced
23:01:12 <bd_> do { l <- filterM somethingWithSideEffects; return $! lazyOperation l }
23:01:23 <bd_> do { l <- filterM somethingWithSideEffects [0,1]; return $! lazyOperation l }  even
23:01:29 <phr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14210#a14228  C version, ~50x faster than my haskell version
23:01:35 <bd_> Does somethingWithSideEffects get called with 1, and thus exhibit its side effect there?
23:01:40 <bd_> It depends on lazyOperation
23:01:42 <phr> though, understandable (uses an array instead of intmap, etc)
23:01:45 <bd_> this isn't allowed :)
23:04:04 <toast-opt> > do { res <- filterM (\x -> do {print "*"; return True }) [0,1]; return Nothing }
23:04:05 <lambdabot>   Ambiguous type variable `a' in the constraint:
23:04:05 <lambdabot>    `Data.Typeable.Typeable a...
23:05:26 <toast-opt> > do { res <- filterM (\x -> do {print "*"; return True }) [0,1]; return () }
23:05:28 <bd_> toast-opt: to clarify, that was assuming a lazy filterM
23:05:30 <lambdabot>   <no location info>: lexical error at character '\SI'
23:05:41 <toast-opt> bd_ but how can filterM be lazy?
23:05:45 <bd_> it can't
23:05:46 <toast-opt> (with IO monad)
23:05:49 <bd_> that's what I demonstrated :)
23:06:44 <toast-opt> > do { res <- filterM (\ x -> do {print "*"; return True }) [0,1]; return Nothing }
23:06:45 <lambdabot>   <no location info>: lexical error at character '\SI'
23:06:53 <toast-opt> :P it worked locally
23:06:58 <kmc> > ()
23:06:59 <lambdabot>   ()
23:07:17 <toast-opt> i'm just happy i wrote do code that run locally.  i didn't think i got how <- assignments worked
23:07:24 <toast-opt> bindings, rather
23:07:47 <uorygl> > do { res <- filterM (\ x -> do {print "*"; return True }) [0,1]; return Nothing }
23:07:48 <lambdabot>   Ambiguous type variable `a' in the constraint:
23:07:48 <lambdabot>    `Data.Typeable.Typeable a...
23:08:13 <toast-opt> yeah, both work locally for me
23:08:18 <uorygl> > ord '\SI'
23:08:19 <lambdabot>   15
23:08:20 <kmc> where is Typeable coming from?
23:08:23 * kmc super confused
23:08:25 <toast-opt> dunno
23:08:39 <kmc> :t print
23:08:40 <toast-opt> maybe lambdabot has a different filterM
23:08:40 <lambdabot> forall a. (Show a) => a -> IO ()
23:08:45 <kmc> :t filterM
23:08:46 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
23:08:50 <toast-opt> or print
23:08:58 <kmc> it's not like it can execute IO actions anyway
23:09:02 <kmc> :t do { res <- filterM (\ x -> do {print "*"; return True }) [0,1]; return Nothing }
23:09:03 <lambdabot> forall a. IO (Maybe a)
23:09:13 <kmc> maybe it has some weird way of trying
23:09:14 <kmc> > print "hi"
23:09:14 <toast-opt> that could be it
23:09:17 <lambdabot>   <IO ()>
23:09:24 <kmc> ah, that's a typeOf
23:09:25 <toast-opt> what's the state monad equiv of print?
23:09:27 <kmc> > typeOf $ print "hi"
23:09:28 <lambdabot>   IO ()
23:09:45 <kmc> > unsafePerformIO $ print "hi"
23:09:45 <lambdabot>   Not in scope: `unsafePerformIO'
23:09:47 <uorygl> toast-opt: why is there an \SI in your expression?
23:09:52 <toast-opt> dunno
23:10:01 <kmc> wtf is \SI
23:10:03 <kmc> > '\SI'
23:10:04 <lambdabot>   '\SI'
23:10:07 <toast-opt> i didn't write \si
23:10:25 <kmc> "shift in"
23:14:20 <toast-opt> hmm, endeavors with state monad failed
23:18:23 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14229#a14229 Solved euler 14 yeeeeees....... ah man i am so going to sleep now thank you all guys i love u
23:18:37 <shambler> wait
23:19:01 <shambler> ahve you sleeped?
23:19:16 <shambler> you said "5 more mins" 8 hours ago
23:19:32 <toast-opt> ah, nice one haskellove
23:19:42 <toast-opt> i haven't done that yet, so i can't look at your answer
23:21:40 <toast-opt> ... no dynamic programming?
23:22:43 <HaskellLove> what do you mean no dynamic?
23:22:45 <o-_-o> is there like an abs function, which turns -ve numbers to positive numbers ?
23:23:36 <HaskellLove> abs x | x<0 = x * (-1)
23:24:09 <luite_> toast-opt: you can do it in a few seconds with a trivial algorithm
23:24:37 <luite_> memoization using Data.Map seems to take more time than recalculating all chains
23:25:11 <toast-opt> luite -- eh, i saw 'unsolved whether all chains terminate' and didn't think that it might just be sparce
23:25:14 <toast-opt> sparse
23:28:50 <luite_> toast-opt: what do you mean by sparse?
23:29:06 <toast-opt> luite - that most chains are relatively short
23:29:32 <phr> > abs (-3)
23:29:33 <lambdabot>   3
23:50:56 <toast-opt> what's a good function to use for a quick-and-dirty time measurement
23:51:01 <toast-opt> like C++ 'clock()'
23:52:33 <phr> erm there's some functions like that
23:52:38 <phr> @hoogle clock
23:52:39 <lambdabot> module Data.Time.Clock
23:52:39 <lambdabot> System.Posix.Types type ClockTick = CClock
23:52:39 <lambdabot> System.Time data ClockTime
23:53:43 <toast-opt> ugh, wish hoogle links weren't broken
23:54:54 <Lemmih> ?hackage timeit
23:54:54 <lambdabot> http://hackage.haskell.org/package/timeit
23:57:08 <toast-opt> sweet, thx.
23:57:12 <toast-opt> now i just need to install it
