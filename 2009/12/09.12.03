00:00:58 <osaunders> maltem: I decided to make everything public in my PHP programming and suddenly code was much nicer to work with.
00:01:23 <maltem> heh
00:01:32 <osaunders> Testing especially.
00:16:08 <dolio> @remember JonHarrop Haskell permits all of these optimizations and, yet, its performance sucks beyond belief.
00:16:09 <lambdabot> Nice!
00:20:20 <medfly> Haskell's performance sucks at what?
00:20:50 <dolio> Everything, obviously.
00:21:09 <dolio> It's a complete failure, unlike F#.
00:21:46 <osaunders> Why was GHC implemented in Haskell? Surely that was pretty difficult to do. Why didn't they just why it in C?
00:21:47 <Saizan> dolio: ever thought of going back to traditional comedy shows?:)
00:22:48 <osaunders> *do it in C
00:22:56 <Saizan> well writing compilers is like the one of the things haskell is best at
00:22:56 * osaunders is angry at his brain
00:23:07 <Saizan> they used hbc to bootstrap
00:23:25 <maltem> osaunders, if there's one domain where Haskell is really popular, then it's parsers and compilers
00:23:44 <osaunders> Saizan: Ah
00:23:50 <maltem> The run-time system is C though
00:23:57 <osaunders> So HBC is written in C?
00:24:25 <Saizan> i don't know, actually
00:25:18 <osaunders> LazyMl
00:25:22 <osaunders> *LazyML.
00:25:51 <osaunders> http://www.haskell.org/pipermail/haskell/2001-June/007454.html
00:31:30 <kmc> osaunders, i'd rather write a Haskell compiler in Haskell *and* a Haskell interpreter in C, than write a Haskell compiler in C
00:31:50 <kmc> C is a low-level systems language
00:32:18 <osaunders> Yeah, fair enough.
00:32:31 <medfly> booooo, C...
00:33:15 <kmc> and isn't GHC's runtime in C-- these days?
00:33:38 <osaunders> kmc: maltem said that already.
00:33:41 <medfly> C--?
00:33:48 <osaunders> Oh, wait.
00:33:59 <osaunders> My eyes didn't see the -- part.
00:34:22 <kmc> cminusminus.org
00:34:31 <osaunders> en.wikipedia.org/wiki/C--
00:34:51 <medfly> oh wow.
00:34:59 <medfly> I thought it's an elaborate joke you guys were playing.
00:35:02 <osaunders> Terrible name.
00:35:32 * osaunders just put up that WikiP page a minute ago.
00:35:34 <kmc> osaunders, yes, so are C++ and C#
00:35:42 <medfly> I agree.
00:35:44 <kmc> people talk about C as a portable assembly language, but it's actually missing some essential features like tail calls
00:35:51 <osaunders> Yeah.
00:35:59 <ketil> it's just to make it harder to google.
00:36:02 <medfly> javascript is pretty bad too.
00:36:11 <osaunders> Any name with a symbol in is terrible, for a start.
00:36:16 * ketil will design a language called "
00:36:21 <medfly> hahahaha
00:36:23 <osaunders> lol
00:36:26 <kmc> methinks you can tail-call more easily in javascript
00:36:31 <kmc> by the whole return-a-closure trick
00:36:38 <ketil> Well, the absolutely worst name is 'links'.
00:36:41 <medfly> the nicest thing is to design a language called Porn
00:36:43 <kmc> while (1) { f = f(); }
00:36:50 <osaunders> GCC does tail-call-op with -O3 or something.
00:36:57 <kmc> osaunders, if it feels like it
00:37:02 <medfly> let's see you google THAT
00:37:05 <ketil> Try googling that.  Or any combination: "programming language links", etc.
00:37:16 <kmc> but it's not guaranteed by the language spec
00:37:19 <ketil> Google needs a quoting mechanism. :-)
00:37:20 <kmc> what if you need an indirect tail call, etc.
00:37:51 <kmc> and a major point of compiling via C is portability, which you lose if you depend on some ultra-strength optimization pass that might or might not even fire
00:38:00 <osaunders> I'm going to create a language called Walmart.
00:38:11 <medfly> I still think Porn is a better name.
00:38:20 <osaunders> Yeah, you're right.
00:38:32 <osaunders> A is pretty bad.
00:38:49 <medfly> I mean, imagine that with http://i.imgur.com/ng5aS.png
00:39:29 <osaunders> You could have all kinds of profanity languages constructs in Porn.
00:39:38 <osaunders> Fuck = fork.
00:39:38 <kmc> (_|_)
00:39:58 <osaunders> I'll stop now before this gets out of hand.
00:39:59 <ben> 'fuck' ought to be the term for destructive update
00:40:11 <toast-opt> um, what an odd conversation to enter in the middle of
00:40:32 <toast-opt> ... or for monads
00:40:55 <osaunders> medfly: I can't understand why C++ scores so badly on that chart. It is because C++ programmers are really boring people?
00:41:13 <toast-opt> ooo, which chart?
00:41:25 <toast-opt> and yes, we usually are
00:41:28 <ben> http://i.imgur.com/ng5aS.png
00:41:31 <toast-opt> except for the template metaprogrammers
00:41:56 <toast-opt> oh, that's obvious
00:42:12 <toast-opt> it's because C++ has the same profanity rate as C per line of _useful_ code
00:42:41 <toast-opt> Java, same thing even more so
00:43:10 <toast-opt> heck, with java you can go a whole project without encountering any non-framework code
00:43:35 <pastah_rhymez> toast-opt: what is a "framework"?
00:43:42 <ben> toast-opt: Clearly it is because C++ code is morally equivalent with profanity to begin with, so programmers do not build up the urge to curse~
00:43:55 <toast-opt> ben, i like your answer better
00:52:21 <maltem> FactoryFactory factoryfactory = new FactoryFactory(); // satisfactory?
00:52:34 <pastah_rhymez> hahah
00:52:37 <m0nkfish> o____o
00:52:52 <pastah_rhymez> "satisfactory" XD
00:53:31 <Baughn> What we need are self-reproducing factories
00:53:36 <Saizan> @remember maltem FactoryFactory factoryfactory = new FactoryFactory(); // satisfactory?
00:53:37 <lambdabot> Nice!
00:53:43 <Baughn> Then we can just say "FactoryFactory factory = new Factory();"
00:54:03 <Saizan> "and you can build more of you!"
00:54:03 <bastl> Is there any way to highlight a line at hpaste with the initial upload ?
00:54:33 <pastah_rhymez> why do you need factories? what's wrong with just using a constructor?
00:55:02 <pastah_rhymez> i have the feeling that they're very enterprise-y
00:55:06 <Baughn> pastah_rhymez: Ah, but we have no global functions
00:55:11 <dibblego> new is a side-effect
00:55:26 <Baughn> So no constructors
00:55:38 <pastah_rhymez> Baughn: all my functions outside local scopes are global... :/
00:55:55 <Baughn> pastah_rhymez: In Java? :P
00:56:12 <pastah_rhymez> i thought you were talking about haskell when you said "we"
00:56:27 <Baughn> No, that would've been obviously false
00:56:43 <pastah_rhymez> well, i'm not really awake just yet :)
00:57:16 <dolio> @quote factory
00:57:18 <lambdabot> quicksilver says: or in Java, we'd make it more generic by using a PolynomialDivisionOperatorFactory.
00:57:23 <pastah_rhymez> but i still don't get it, why do i wanna call X x = XFactory.new(); instead of just X x = new X(); ?
00:58:37 <dibblego> because new is a side-effect and it's a way of hiding behind the fact
00:59:04 <ziman> maybe because of singletons?
00:59:12 <Baughn> pastah_rhymez: Point the first, to decouple the actual type being created from what you ask for..
00:59:30 <Baughn> Well, it seems pretty silly from this vantage, but most patterns are, when you get down to it.
00:59:44 <mmorrow> Baughn: data SelfReproducingFactory slavelabor stuff = SRF (slavelabor -> (stuff, SelfReproducingFactory))
01:00:00 <mmorrow> if you simply just keep reusing the slavelabor, you can get infinite stuff!
01:00:12 <pastah_rhymez> hahahaha
01:00:26 <ziman> can't you just repeat stuff? :)
01:00:53 <mmorrow> ziman: but then it's teh same stuff
01:01:14 <ziman> oh, sure!
01:03:08 <Saizan> how does one interpret a file like this? http://pastebin.com/m2b169b8b
01:04:23 <mmorrow> hmm, that could actually be a handy datatype..
01:04:59 <dolio> mmorrow: That's a state machine.
01:05:04 <Saizan> it's supposed to be the output of cpp, i thought i'd get the file contents in there..
01:05:29 <Botje> Saizan: looks like something genereted by cpp, yes :)
01:05:41 <Botje> *generated
01:06:10 <mmorrow> dolio: ah nice. i'm currently deciding whether to do:
01:06:23 <mmorrow> SRF a b = SRF (a -> Maybe (b, SRF a b))
01:06:24 <mmorrow> or
01:06:31 <dolio> I forget whether it's Mealy or Moore.
01:06:32 <mmorrow> SRF a b = SRF (a -> (b, Maybe (SRF a b)))
01:06:41 <mmorrow> dolio: opinion?
01:06:47 <Saizan> Botje: so those # N lines are like includes?
01:07:00 <mmorrow> hmm, i think i like the latter more
01:07:27 <ziman> it's like the function that unfoldr takes
01:08:01 <mmorrow> , src ''SRF
01:08:04 <lunabot>  data SRF a b = SRF (a -> (b, Maybe (SRF a b)))
01:08:11 <Botje> Saizan: they're traces from which file the line came
01:08:35 <Botje> they're so the compiler still knows which line that was in the original source file
01:09:53 <mmorrow> dolio: ooh, speaking of this, there's this one fsm compiler -> C called "ragel", it looks pretty neat (haven't used it)
01:10:03 <mmorrow> cool diagrams in the user manual
01:10:16 <mmorrow> http://www.complang.org/ragel/
01:10:31 <Botje> i think mongrel (ruby web server) uses that
01:10:37 <Saizan> Botje: oh, sorry, i thought there was nothing else in the file so i got confused, there's a lot of whitespace before the code instead
01:10:43 <dolio> We should write a fsm -> Haskell compiler.
01:10:54 <dolio> Then jdh30 can tell us how slow it is.
01:11:01 <dolio> Over 6000x too slow.
01:11:06 <mmorrow> lol
01:11:47 <mmorrow> ohh, i see (looking at mealy on wikipedia).. the state is represented by the function
01:12:26 <dolio> The difference isn't very big.
01:12:39 * mmorrow tries to think of a simple but non-trivial fsm to use SRF for in lunabot
01:12:45 <dolio> It's something like Mealy a b = a -> Moore a b, Moore a b = (b, Mealy a b), or vice versa.
01:12:58 <mmorrow> ahh
01:13:28 <mmorrow> that's pretty cool actually, having them be mutual
01:13:30 <mmorrow> didn't edwardk write a lib with these?
01:13:35 <dolio> I think so.
01:15:33 <mmorrow> hmm, maybe not on hackage
01:16:21 <mmorrow> anyone have any requests for datatype(s) to add to lunabot while i'm at it?
01:16:40 <koeien37> , (+1) . Just 37
01:16:41 <lunabot>  luna: Couldn't match expected type `a -> b'
01:16:44 <Saizan> a pony!
01:17:25 <mmorrow> , src ''Pony
01:17:26 <lunabot>  luna: Not in scope: type constructor or class `Pony'
01:17:29 <mmorrow> , src ''Pony
01:17:30 <lunabot>  luna: Not in scope: type constructor or class `Pony'
01:17:33 <mmorrow> arhg
01:18:06 <mmorrow> , src ''Pony
01:18:08 <lunabot>  newtype Pony = Pony Pony
01:18:11 <mmorrow> , src ''Mealy
01:18:13 <mmorrow> , src ''Moore
01:18:13 <lunabot>  newtype Mealy a b = Mealy (a -> Moore a b)
01:18:16 <lunabot>  newtype Moore a b = Moore ((b, Mealy a b))
01:18:32 <mmorrow> , fix Pony
01:18:33 <lunabot>  luna: No instance for (GHC.Show.Show Luna.ST.Pony)
01:19:07 <Twey> , Pony undefined
01:19:08 <lunabot>  luna: No instance for (GHC.Show.Show Luna.ST.Pony)
01:19:12 <Saizan> is there an unicode Char for Pony?
01:19:14 <Twey> Aw :þ
01:22:44 <mmorrow> , let tick f n = Moore (f n, Mealy (tick (f . f))); tock f = Mealy (tick f); mealy (Mealy m) a = let Moore (b,me) = m a in b : mealy me b in mealy (tock (+1)) 0
01:22:46 <lunabot>  Stack space overflow: current size 8388608 bytes.
01:22:46 <lunabot>  Use `+RTS -Ksize' to increase it.
01:22:52 <mmorrow> :(
01:23:15 <mmorrow> , let tick f n = Moore (f n, Mealy (tick (f . f))); tock f = Mealy (tick f); mealy (Mealy m) a = let Moore (!b,me) = m a in b : mealy me b in mealy (tock (+1)) 0
01:23:17 <lunabot>  Stack space overflow: current size 8388608 bytes.
01:23:17 <lunabot>  Use `+RTS -Ksize' to increase it.
01:23:29 <mmorrow> gah, a loop somewhere?
01:24:19 <mmorrow> , let tick f n = Moore (f n, Mealy (tick (f . f))); tock f = Mealy (tick f); mealy (Mealy m) a = m a in fst (mealy (tock (+1)) 0)
01:24:20 <lunabot>  luna: Couldn't match expected type `(a, b)'
01:24:43 <mmorrow> , let tick f n = Moore (f n, Mealy (tick (f . f))); tock f = Mealy (tick f); mealy (Mealy m) a = let Moore o = m a in o in fst (mealy (tock (+1)) 0)
01:24:44 <lunabot>  1
01:25:06 <mmorrow> so unwieldy without helper functions..
01:26:40 <ski> , src ''Mealy
01:26:43 <lunabot>  newtype Mealy a b = Mealy (a -> Moore a b)
01:26:48 <ski> , src ''Moore
01:26:51 <lunabot>  newtype Moore a b = Moore ((b, Mealy a b))
01:27:04 <ski> (hm, extra brackets ..)
01:27:50 <mmorrow> prettyprint fail
01:28:51 <mmorrow> it's places like this that being able to have infinite types (w/out the fake newtype con) would be handay
01:29:42 <ski> (`SRF' ?)
01:29:57 <ski> .. oh
01:30:05 <mmorrow> let tick f n = (f n, tick (f . f)); tock = tick; mealy = ($) in fst (mealy (tock (+1)) 0)
01:30:11 <mmorrow> vs
01:30:13 <mmorrow> let tick f n = Moore (f n, Mealy (tick (f . f))); tock f = Mealy (tick f); mealy (Mealy m) a = let Moore o = m a in o in fst (mealy (tock (+1)) 0)
01:30:25 <mmorrow> Baughn: data SelfReproducingFactory slavelabor stuff = SRF (slavelabor -> (stuff, SelfReproducingFactory))
01:30:41 <mmorrow> then dolio pointed out that it's a state-machine
01:30:48 <mmorrow> and gave Mealy/Moore
01:31:25 <Baughn> Well, yeah. You can't expect to have a self-reproducing factory without Meals.
01:31:41 <mmorrow> Baughn: good point
01:31:55 <phr> gack.  i have an integer that i want to multiply by the length of some list
01:32:03 <mmorrow> fromIntegral
01:32:12 <Baughn> genericLength
01:32:14 <mmorrow> @type fromIntegral . length
01:32:15 <lambdabot> forall b a. (Num b) => [a] -> b
01:32:17 <mmorrow> or that
01:32:28 <phr> if i say  "let n = fromIntegral . length a" it makes the program run about 3x faster than if i use genericLength
01:32:55 <Baughn> Your program spends all of its time lengthing lists?
01:33:00 <phr> no, hardly any
01:33:11 <phr> or so i would have thought
01:33:21 <phr> i'll hpaste it later, i have someone else here now so can't stay on
01:33:47 <mmorrow> > maxBound :: Int
01:33:48 <lambdabot>   9223372036854775807
01:34:10 <mmorrow> > (8*3{-bytes-}) * (maxBound::Int)
01:34:11 <lambdabot>   -24
01:34:13 <bastl> to anyone that knows about generic programming using regular or multirec: I try to write a generic ToTree function for 'regular'. I think it looks good, only for the Identity functor it doesnt type-check and i cant figure out what's wrong. Can anyone help ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5247#a5248 Thanks!
01:34:29 <mmorrow> > (8*3{-bytes-}) * fromIntegral (maxBound::Int) :: Integer
01:34:30 <lambdabot>   221360928884514619368
01:34:54 <mmorrow> > ((8*3{-bytes-}) * fromIntegral (maxBound::Int) :: Integer) `div` (1000^3) {- gigabytes -}
01:34:55 <lambdabot>   221360928884
01:35:13 <mmorrow> that's a long list to actually need Integer for the length..
01:35:32 <mmorrow> err, wait 1000^4?
01:36:04 <mmorrow> either way, that's like thousands of terabytes of list data..
01:36:35 * mmorrow doesn't see the point of genericLength other than to slow things down
01:38:39 <Baughn> mmorrow: Counting number of objects transferred in a long-running network program?
01:38:42 <mmorrow> (since even though Integer (as-is in ghc) has the S# con, it still has to do two extra compares for every addition)
01:38:53 <Baughn> genericLength is pretty pointless on a 64-bit system, but those still aren't universal
01:38:57 <mmorrow> Baughn: and you have a list of them?
01:39:04 <Baughn> mmorrow: Yes!
01:39:14 <mmorrow> each cons-cell is (3*sizeof(void*))
01:39:32 <mmorrow> , (3*4) * fromIntegral (maxBound::Int)
01:39:34 <lunabot>  25769803764
01:39:54 <mmorrow> , ((3*4) * fromIntegral (maxBound::Int)) `div` (1000*1000*1000) {- GB -}
01:39:55 <lunabot>  25
01:39:59 <mmorrow> :o
01:40:22 <mmorrow> , (maxBound::Int)
01:40:24 <lunabot>  2147483647
01:41:30 <mmorrow> maybe if the list was on-disk and you're streaming it through your length-function i suppose
01:42:02 <ben> genericFileSize = genericLength . readFile :]
01:42:17 <mmorrow> heh
01:42:19 <dreixel> bastl: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5247#a5249
01:42:46 <dreixel> both in regular and in multirec, you need to take the function to apply in the I case as an argument
01:42:55 <Jafet> I've actually done that in C before
01:43:16 <dreixel> because at that stage you have to again apply 'from', and only then apply the generic function
01:43:34 <bastl> hey dreixel :-)
01:43:39 <bastl> why is that so?
01:43:49 <quicksilver> mmorrow: lazy comparison of lazy naturals?
01:44:08 <dreixel> well, because the embedding in these libraries is "shallow"
01:44:08 <bastl> oh, sorry didnt read yr last stmt
01:44:10 <mmorrow> quicksilver: hehe
01:44:20 <quicksilver> mmorrow: (and similar "clever" partial information tricks)
01:44:20 <dreixel> so it's only generic until the recursive points, and then you get the real type again
01:44:33 <dreixel> that's why you get '(PF a) a'
01:44:40 <bastl> i tried toTree $ from $ x but that didnt work either
01:45:00 <mmorrow> quicksilver: oh, good point, i was only considering the Integer case.
01:45:05 <dreixel> this means that in the recursive occurrences you have 'a's again (as opposed to 'PF a (PF a (PF a ...', which would be a deep encoding)
01:45:51 <bastl> so the I is applied to Expr and not to (Fix PFExpr) ?
01:46:11 <quicksilver> mmorrow: also, on a 32-bit system, you can have a [Char] coming from a file which is longer than 2^32 items (albeit not all stored in memory at once)
01:46:24 * mmorrow amends his statement about genericLength only slowing things down, to (genericLength::[a]->Integer) only slowing things down
01:46:37 <dreixel> yes
01:46:52 <mmorrow> quicksilver: right, 25GB list
01:46:52 <dreixel> bastl: yes. you can see that in the definitions of 'from' and 'to'
01:46:54 <mmorrow> quicksilver: (which is reasonable sure)
01:47:33 <ski> `import qualified Generics.Regular.Functions.Show as G; import qualified Generics.Regular.Functions.Read as G', that's allowed ?
01:47:48 <mmorrow> quicksilver: but in that case i'd probably stat() and case on the file-size, and if it's bigger than X, splitAt maxBound, then fmap length ;)
01:48:05 <mmorrow> it'd definitely be worth it time-wise for 25GB of list..
01:48:57 <mmorrow> well, no i take that back. i'd use Int64 and avoid the hackery
01:49:07 <ben> There is another case for genericLength?
01:49:22 <mmorrow> if the Num type is something like a list
01:49:42 <bastl> dreixel: If i wrote them myself. but they are genereated by TH. Or do you mean the type of from and to?
01:49:44 <ben> Oh, nevermind. I thought genericLength was always -> Integer
01:49:48 <mmorrow> > (genericLength [0..] :: Natural) < 3
01:49:49 <lambdabot>   False
01:50:16 <ben> Natural? :S
01:50:49 <mmorrow> not sure where it's from or what it's def is, but i imagine something like  data Natural = Z | S Natural
01:50:50 <bastl> dreixel: is there any more elaborate text on package rewriting ?
01:51:27 <quicksilver> data Natural = Z | I Natural | O Natural ?
01:51:38 <mmorrow> :o
01:51:54 <mmorrow> for from-the-top or from-the-bottom?
01:51:56 <ben> > 1-2 :: Natural
01:51:58 <lambdabot>   * Exception: Natural: (-)
01:52:00 <ben> :I
01:53:09 <Veinor> well what did you expect? :I
01:53:46 <ben> A compile time error :I
01:53:56 <dreixel> bastl: in the definition. Take, for instance, 'from (e1 :++: e2) = R (L (C $ (I e1) :*: (I e2)))
01:53:56 <dreixel> '
01:54:31 <dreixel> bastl: regarding rewriting, here is the paper: http://www.cs.uu.nl/wiki/pub/Alexey/ALightweightApproachToDatatype-GenericRewriting/gr-wgp08-submitted.pdf
01:54:45 <Veinor> also, when is Haskell's builtin length going to return a Num a instead of an Int?
01:54:46 <dreixel> this shallow vs. deep encoding thing is discussed there, I believe.
01:55:34 <Veinor> I had a bug I couldn't track down until I remembered length is silly. why does it do that, anyway>?
01:55:41 <c_wraith> :t genericLength
01:55:43 <lambdabot> forall b i. (Num i) => [b] -> i
01:55:56 <Veinor> yes, but when will length = genericLength? :P
01:56:17 <Saizan> Veinor: when you form a lobby to get that
01:56:26 <Twey> When you adopt #alt-stdlib :þ
01:56:31 <Veinor> what're the reasons to not do so?
01:56:49 <Twey> It's not finished yet
01:56:58 <bastl> yeah, i have the TR from July'08, it's quite terse for starters. the only place I read about deep and shallow from and to is in the multirec paper
01:57:06 <Veinor> I mean, why does length return an Int instead of a Num?
01:57:06 <Twey> Is H' going to do stuff like this?
01:57:10 <Twey> Oh
01:57:18 <Saizan> Veinor: ask mmorrow, for example :)
01:57:37 <Twey> Well, if your list is longer than maxBound :: Int, you might be better off not taking its length
01:58:14 <Saizan> the problem is more that using a length constraints your numbers to be Int rather than defaulting on Integer
01:58:16 <dreixel> bastl: in the paper I linked just yet, section 5., Fixed-point View
01:58:27 <Saizan> so it introduces overflow errors somewhere else
01:58:31 <dreixel> it's benchmarked against the current shallow view, and found to be slower.
01:58:38 <Twey> Unless you immediately fromIntegral it
01:59:01 <Saizan> Twey: right, but it's easy to not think about that
01:59:05 <Twey> Aye
01:59:39 <Saizan> relying on defaulting when you care about the size of your integral type isn't a good code practice, i guess
01:59:55 <Twey> *nod*
02:00:10 <Twey> I think we should have a better way of encoding boundaries in types, too.
02:00:27 <Twey> -1 :: Word should be a type error.
02:00:43 <ivanm> > negate 3 :: Word
02:00:45 <lambdabot>   18446744073709551613
02:00:51 <ivanm> Twey: can't with our current num classes
02:00:55 <Twey> And it shouldn't even have a negate
02:00:57 <ivanm> unless they make negate for Word*
02:00:58 <Twey> ivanm: Yeah
02:01:00 <ivanm> an error
02:01:07 <Twey> Still not a type error
02:01:08 <Saizan> but it's also a nasty bug to spot, since parts of your programs my still be polymorphic and not exhibit the bug in isolation
02:01:18 <Twey> You'd have to move it out into a different class
02:01:20 <Twey> Saizan: Yeah
02:01:30 <Veinor> > (-1) :: Word
02:01:31 <lambdabot>   18446744073709551615
02:02:25 <Veinor> ☃
02:03:41 <pastah_rhymez> haha, snowman :)
02:04:34 <Veinor> unicode: include whatever the hell you want, we have space
02:06:01 <Twey> Yet still no Klingon
02:06:17 <Twey> I'd think Klingon would take precedence over Snowman
02:06:28 <Twey> I mean, at least it's actually text :þ
02:06:31 <johnw> perhaps it is a Klingon snowman
02:06:33 <koeien37> ∰ mathematics!
02:06:35 <bastl> i have a prototype that uses System.POSIX. Whats the best way to port to Win32. Is there any general layer above Posix and win32?
02:06:38 <Veinor> no tengwar either :(
02:07:01 <Twey> Yeah
02:07:03 <Twey> johnw: Haha
02:07:20 <Twey> bastl: Those are very big APIs
02:07:25 <Twey> What specifically are you doing?
02:07:28 <Veinor> http://upload.wikimedia.org/wikipedia/commons/5/5e/Tengwar_sample.svg
02:07:29 <Veinor> Pretty
02:07:37 <bastl> http://www.wazu.jp/gallery/Fonts_Tengwar.html
02:08:33 <Twey> Tengwar is very flowery
02:09:42 <Veinor> ☭
02:09:50 <bastl> Twey: Lego NXT controlling via serial/bluetooth/usb devices
02:10:54 <c_wraith> hammer & sickle is an important codepoint.  for some reason!
02:11:14 <Twey> bastl: Well, there's the ‘serial’ library
02:11:37 <Twey> Oh, it doesn't seem to work on Windows
02:11:51 * ski idly wonders whether there is an "lockpicks & crowbar" codepoint
02:12:28 <Twey> The ‘usb’ package seems to be platform-independent
02:12:35 <Veinor> c_wraith: eagerly awaiting donkey and elephant codepoints
02:12:40 <Twey> Haha
02:12:50 <Jafet> Cue Soviet Russia joke
02:12:53 <Twey> ‘Skull 'n' crossbones’
02:13:09 <Twey> Oh crikey
02:13:10 <Twey> It exists
02:13:19 <Twey> U+2620 SKULL AND CROSSBONES (☠)
02:13:32 <Jafet> You sound surprised
02:13:51 <Twey> I was joking!
02:14:19 <Veinor> I want to register xn--h4h.com now
02:15:18 <koeien37> i have xn--3dsv64dg5bb19b.com
02:15:34 <Veinor> which is?
02:15:37 <Twey> What does that translate to?
02:15:50 <koeien37> 牛在田里.com
02:15:54 <Veinor> I can't find any punycode-undoers
02:15:56 <koeien37> (the cow is in the field)
02:16:05 <Twey> Hahaha
02:16:08 <Twey> Cude
02:16:10 <Veinor> ... ?
02:16:11 <Twey> Cute**
02:16:39 <koeien37> well, koeien = cows (dutch), so it makes a little bit of sense
02:17:42 <Veinor> heh
02:17:50 <Veinor> see, mine would be memorable
02:21:13 <vy> Looking at GHC sources and... Is Simon Peyton Jones using GNU/Linux at Microsoft?
02:21:35 <koeien37> he uses Outlook to send mail, so i wouldn't say that immediately
02:21:41 <koeien37> but what does it matter?
02:22:01 <fasta> vy: I think Simon M. does.
02:22:18 <fasta> vy: but they probably use both, like most people.
02:22:51 <vy> koeien37: It's unix file structure (configure scripts, etc.) is shining.
02:25:07 <Botje> vy: microsoft _research_ :)
02:26:04 <Twey> Veinor: 牛在田里 is memorable :þ
02:26:10 <Veinor> :P
02:26:12 <Twey> You're not supposed to memorise Punycode strings!
02:28:05 <Veinor> it's not memorable if you don't speak chinese!
02:28:16 <Twey> Well, that's easily remedied :þ
02:28:47 * aefjt puts Veinor in a Chinese room
02:29:21 <Veinor> I know a guy has a tinyurl maker that's just [8-ball character].ws
02:31:52 <cx> where do I find good information about Non negative?
02:32:22 <koeien37> i am learning it currently
02:32:52 <koeien37> primarily the written language
02:36:49 <birdiee_> how to use NonNegative it says "NonNegative x" ensures that x >= 0 and that I understand but should it stand before like if my x is a integer or what? no example
02:37:33 <Saizan> birdiee_: where is this NonNegative from?
02:37:42 <birdiee_> i am doing some properties and need the input to never be negative but if I did condition ==> and said that it should not be negative and that it must be smaller then another input I have i get exhausted tests
02:37:51 <birdiee_> Saizan quickCheck I belive
02:37:59 <birdiee_> http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.2/doc/html/Test-QuickCheck-Modifiers.html#t%3ANonNegative
02:38:26 <Saizan> ok, so your x can be of any numeric type you wish
02:38:50 <birdiee_> Saizan or do you have any other tips if I am making a property where I have two inputs one list and one index and the index should not be smaller then 0 and bigger then the length of the list
02:38:57 <birdiee_> Saizan ok I see
02:39:22 <Saizan> you use it like prop_whatever (NonNegative x) .. = real_prop_whatever x ...
02:40:03 <birdiee_> hm now I am not following you
02:40:09 <birdiee_> you mean in the "pattern" ?
02:40:51 <birdiee_> I have to make a newtype right?
02:41:08 <Saizan> NonNegative is the newtype here, it's already defined
02:41:22 <birdiee_> I see
02:41:33 <Saizan> you just have to take parameters of that type for your property and unwrap the newtype constructor
02:42:31 <birdiee_> hm
02:42:35 <birdiee_> so if I have like prop_abc xs (i, y) = my test
02:42:47 <birdiee_> and I want i to use that newtype nonnegative
02:43:02 <Saizan> on which arguments?
02:43:22 <birdiee_> on " i "
02:43:34 <birdiee_> that it should never be smaller then 0
02:43:43 <Saizan> prop_abc xs (NonNegative i, y) = my test
02:43:57 <birdiee_> aha you mean like that
02:44:00 <birdiee_> cool
02:44:54 <birdiee_> is it possible to say that it can't be like greater then length of xs there aswell? because now I use prop_abc xs (i, y) = i < (length xs) ==> my test..
02:45:15 <birdiee_> but I get alot of exhausted tests but that was before nonnegative so maybe it will be okey now
02:47:55 <birdiee_> Saizan Not in scope: data constructor `NonNegative' is there something I must import?
02:47:55 <b0fh_ua> Hi there! I am new to Haskell, I am trying to convert a number into binary form as list of bits (1 or 0). I started to create the function like listed at: http://pastebin.com/d65f9742b. But it doesn't like Num type for testBit.
02:48:01 <b0fh_ua> what do I miss there?
02:48:42 <Saizan> birdiee_: Test.QuickCheck.Modifiers
02:49:11 <birdiee_> hm says it can't find that module
02:49:17 <birdiee_> maybe something I need to download?
02:49:54 <Baughn> b0fh_ua: Seeing the whole source would help. And the error.
02:50:02 <birdiee_> Oh
02:50:03 <Saizan> birdiee_: maybe you're using QuickCheck 1 instead of 2?
02:50:05 <birdiee_> I just have quickcheck 1.2
02:50:09 <b0fh_ua> Baughn: that's the complete source :)
02:50:16 <birdiee_> it came along when I downwloaded ghci
02:50:26 <birdiee_> damnit well have to fix it then
02:50:27 <Baughn> b0fh_ua: Ah yes. testBits is from Data.Bits.
02:50:32 <Baughn> b0fh_ua: ..what's its type, hm?
02:50:36 <Saizan> birdiee_: however, for your case i'd use "forAll (0, length xs - 1) $ \i -> ..."
02:50:49 <pastah_rhymez> b0fh_ua: to begin with;
02:50:50 <b0fh_ua> Baughn: http://pastebin.com/d7f3f680e
02:50:51 <pastah_rhymez> binary a = [ if a `testBit` i then 1 else 0 | i <-[1..16]]
02:50:58 <Saizan> birdiee_: oops,  "forAll (choose (0, length xs - 1)) $ \i -> ..." i meant
02:51:01 <pastah_rhymez> easier to read
02:51:31 <Baughn> b0fh_ua: The code itself is fine, assuming that use of list comprehensions is - I pretty much never actually use them
02:52:02 <b0fh_ua> well, i am just trying to apply things as far as I do learn Haskell )
02:52:05 <Baughn> b0fh_ua: But testBit's type requires its first parameter to be an instance of Bits, which must be reflected in the type signature for binary where you get it
02:52:37 <b0fh_ua> Baughn: class Num a => Bits a where
02:52:37 <Baughn> b0fh_ua: That means that Bits is a subclass of Num
02:52:37 <b0fh_ua> doesn't that mean the Bits subclasses Num?
02:52:38 <Baughn> Yes
02:52:48 <Baughn> So, all instances of Bits are instances of Num
02:52:53 <Baughn> *Not* the other way around
02:52:54 <b0fh_ua> hm, so I can just change Num to bits
02:53:16 <Baughn> Yep. And now you know how to read that error from GHC.
02:53:49 <b0fh_ua> yep, simple from Java - it can't cast parent class to it's child
02:53:52 <birdiee_> Saizan won't I get exhausted test for doing that?
02:54:13 <Baughn> b0fh_ua: Well, it's the same thing. Num is the parent class of Bits.
02:54:17 <Saizan> birdiee_: no
02:54:36 <Baughn> b0fh_ua: (But note, nothing stops you from using more than one parent)
02:55:26 <b0fh_ua> Baughn: http://pastebin.com/d4f92706c
02:55:54 <b0fh_ua> it was compiled just fine, but looks like I have to provide a type to argument?
02:56:01 <birdiee_> Saizan ok cool. so I should use this in the condition before the ==> ? or what do you mena by ...
02:56:16 <b0fh_ua> it doesn't like 'binary 10' for some reason
02:56:20 <Baughn> b0fh_ua: Right, 'fromBits 10' doesn't give enough information to tell /which/ instance of 10 you mean
02:56:43 <Baughn> b0fh_ua: It could be any instance of Bits, and there are quite a few. The type of a literal integer is 'Num a => a', so that's no help.
02:56:54 <Baughn> Try binary (10 :: Int)
02:57:37 <b0fh_ua> Baughn: that worked
02:57:40 <b0fh_ua> thanks!
02:57:55 <Saizan> birdiee_: no, look at the documentation of forAll in the QuickCheck docs, it takes a "Gen a" and a function taking an 'a' to which it will pass a value produced with the passed "Gen a"
02:58:12 <Baughn> @type bool
02:58:13 <lambdabot> Not in scope: `bool'
02:58:31 <Saizan> birdiee_: and "choose (x,y)" is a Gen a that produces a random value between x and y inclusive
02:58:32 <birdiee_> Saizan ok cool will look into that. thanksa again!
02:58:36 <vy> I've been trying to make (foldr (+) 0 sizes) `div` (1024 ** 2) since 10 minutes. Is it that hard to nail the right toDouble/toFloat/toInteger/truncate/round combination?
02:58:46 <Baughn> b0fh_ua: Incidentally, the compiler (or ghci, at least) does do defaulting for Num, which is why you wouldn't have noticed before
02:58:47 <birdiee_> I see nice
02:59:19 <Saizan> vy: 1) switch to foldl', 2) what should be the type of sizes?
02:59:42 <Saizan> ?type (**)
02:59:44 <lambdabot> forall a. (Floating a) => a -> a -> a
02:59:53 <Saizan> and div surely looks wrong :)
03:00:24 <Saizan> > 1024 ** 2
03:00:26 <lambdabot>   1048576.0
03:00:30 <vy> Saizan: 1) Done. 2) Double?
03:00:33 <Saizan> > 1024 ^^ 2
03:00:35 <lambdabot>   1048576.0
03:01:18 <Saizan> ?type let sizes = [1,2,3] :: [Double] in (foldl' (+) 0 sizes) \ (1024 ** 2)
03:01:20 <lambdabot> parse error on input `\'
03:01:25 <Saizan> ?type let sizes = [1,2,3] :: [Double] in (foldl' (+) 0 sizes) / (1024 ** 2)
03:01:27 <lambdabot> Double
03:01:38 <Saizan> vy: is it ok for it to return a Double?
03:01:59 <vy> Saizan: Sure.
03:02:18 <Saizan> then that's it, unless you want rounding etc..
03:02:33 <vy> Hrm... Thanks.
03:02:46 <Saizan> (/) is fractional division, div is the integral one
03:04:48 <zenzike> I'd like to markup my lhs files with # at the beginning of a line, but this gives a syntax error. does anybody know why this isn't allowed?
03:05:20 <ivanm> zenzike: it might think its for the C pre-processor
03:05:31 <ivanm> zenzike: or in the first line, a #! is used to run a script
03:05:35 * hackagebot upload: haskell-src-exts 1.3.3 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
03:06:34 <zenzike> ivanm: is there any way to disable this reading? do you know where I might find documentation?
03:06:57 <ivanm> AFAIK, you can't
03:07:07 <ivanm> dammit, not another HSX update...
03:07:35 <Saizan> if you don't have LANGUAGE CPP it shouldn't interpret those as cpp directives
03:07:47 <Saizan> zenzike: what's the actual error? and how does the source look?
03:07:53 <YuleAthas> CPP is run over the entire literate file, and not just the code blocks?
03:08:07 <ivanm> dunno
03:08:27 <zenzike> Any simple lhs file, with normal code delimited by > , but that contains a # at the beginning of a line, will break.
03:08:30 <ivanm> zenzike: check the first line, I forgot you had to explicitly use CPP
03:08:38 <ivanm> zenzike: a comment line?
03:08:45 <zenzike> yeah, a comment line
03:08:46 <ivanm> zenzike: and are you leaving a blank line around the > ones?
03:08:48 <zenzike> that's why it's so annoying
03:08:52 <zenzike> yup
03:09:09 <zenzike> pick your favourite lhs script, and just stick a # at the beginning of any line
03:09:57 <Saizan> maybe it's getting parsed as a line directive
03:10:43 <ivanm> yup, seems to think it's a CPP
03:10:53 <ivanm> zenzike: maybe try asking in #ghc
03:10:59 <zenzike> http://pastie.org/725283
03:11:08 <zenzike> that simple example breaks
03:11:23 * ivanm just tried it on his own code
03:13:37 * hackagebot upload: XMPP 0.1.2 - XMPP library (OlegIvanov)
03:14:37 * hackagebot upload: matsuri 0.0.4 - ncurses XMPP client (OlegIvanov)
03:18:57 <zenzike> ivanm: it even compile fine in hugs, which makes it wierder
03:19:09 <ivanm> so ghc is probably being too fancy
03:19:40 <zenzike> yeah, that's what i'm assuming. I'll wait for the ghc gurus to come back with an answer :)
03:25:47 <birdiee_> Saizan I still get negative values and i larger then length of xs with forAll (choose (0, length xs - 1)) $ \i -> but now it passes the test so something worked.. but in verboseCheck it shows negative numbers and to large numbers.. but is it like abs is working that the numbers in verboseCheck are changed and therefor I cannot see the "real" result of using forAlll.... ?
03:30:56 <Saizan> birdiee_: you shouldn't have 'i' as one of the arguments to your property if you use forAll
03:32:22 <birdiee_> Saizan hm ok so what we wrote it's like an argument but that isn't in the pattern aswell as not in the type definition for the prop?
03:33:32 <birdiee_> worked
03:33:40 <Saizan> you're getting the i as argument to the lambda expression you pass to forAll
03:33:49 <birdiee_> I see
03:34:06 <birdiee_> it worked
03:34:39 <birdiee_> I will never know what i was with every case though right?
03:34:54 <birdiee_> verbosecheck only write out the arguments, can I explicity write out i?
03:35:39 <Saizan> i'm not sure about that
03:35:59 <birdiee_> ok then I just have to belive that quickCheck is doing the right thing =)
03:36:29 <birdiee_> thank you very much Saizan your help is really appriciated
03:36:53 <Saizan> np :)
03:44:05 --- mode: irc.freenode.net set +o ChanServ
03:46:42 <HugoDaniel> my code is this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5251#a5251  and is VERY slow when i try to generate a single String with the final function shown there...
03:46:46 <HugoDaniel> in going to switch it to a foldl'
03:46:49 <HugoDaniel> any ideas ?
03:49:33 <Saizan> using (++) in a left associative manner is O(n^2)
03:51:05 <Saizan> ?type shows
03:51:05 <lambdabot> forall a. (Show a) => a -> String -> String
03:51:50 <HugoDaniel> oh
03:51:56 <Saizan> i'd just use "concatMap show lstd" actually
03:52:09 <HugoDaniel> let me try it
03:53:08 <mmorrow> how would people order the *bsds in terms of popularity? where bsds = [Free,Net,Open]? (my guess is Free, Open, Net ??)
03:54:16 <HugoDaniel> Saizan! OMG! it just got reduced from 10minutes to 3 seconds!!
03:54:26 <koeien37> mmorrow: yes, i'd think so
03:54:26 <HugoDaniel> im such a horrible coder :P
03:54:26 <mmorrow> popularity := if you had to prioritize them for support in some program (and assume maybe you'll only have time for 1.5 of them), how would you order them?
03:54:34 <mmorrow> koeien: great, thanks :)
03:54:36 <Saizan> heh :)
03:54:48 <koeien37> Free> Open > Net in terms of usage ime
03:55:18 <franksh> mmorrow: http://en.wikipedia.org/wiki/Comparison_of_BSD_operating_systems#Popularity
03:55:21 <HugoDaniel> i really should read up on folds :P
03:55:24 <fasta> mmorrow, it depends on how you count. Sony cameras use NetBSD.
03:56:05 <mmorrow> franksh: ah sweet, thanks
03:56:25 <mmorrow> fasta: hmm, interesting, hadn't considered that angle..
03:56:27 <HugoDaniel> i was thinking like this "i want to reduce a list of something to a single something ... so ill just fold it up"
03:57:00 <SamB_XP> HugoDaniel: that's about the size of it
03:57:01 <HugoDaniel> what a FAIL :)
03:57:05 <Baughn> @. pl undo do a <- foo; bar a; return a
03:57:05 <lambdabot> liftM2 (>>) bar return =<< foo
03:57:16 <SamB_XP> well, usually it's to a single something else
03:57:46 <HugoDaniel> hmm
03:57:57 <SamB_XP> HugoDaniel: how about an example of what you wanted it to do ?
03:58:12 <HugoDaniel> my code is this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5251#a5251  and is VERY slow when i try to generate a single String with the final function shown there...
03:58:14 <SamB_XP> an example something along these lines
03:58:24 <SamB_XP> > sum [x,y,z]
03:58:25 <lambdabot>   0 + x + y + z
03:59:09 <HugoDaniel> but i tried out foldr, foldl, and foldl' ... they both ran in about +-10 mins
03:59:22 <HugoDaniel> and concatMap in 3 seconds
03:59:41 <SamB_XP> HugoDaniel: ah
03:59:59 <Peaker> concatMap show should be about as fast as concat (map show ...)  which should be about as fast as: foldr (++) [] (map show ..)
04:00:25 <Peaker> HugoDaniel: foldr should be ok
04:00:32 <HugoDaniel> but it wasn't
04:00:38 <Peaker> HugoDaniel: show the foldr code/
04:00:56 <Saizan> HugoDaniel: you used foldl, that was the problem
04:01:06 <Saizan> foldr would have been ok
04:01:11 <SamB_XP> Saizan: he says he tried all 3 of the above!
04:01:21 <SamB_XP> nice to see he didn't bother with foldr' ;-)
04:01:24 <SamB_XP> (is there one ?)
04:01:53 <Botje> @src concat
04:01:53 <lambdabot> concat = foldr (++) []
04:02:07 <SamB_XP> hehehe
04:02:18 <HugoDaniel> :D
04:02:18 <Saizan> HugoDaniel: you used foldr (\x y -> show x ++ y) "" ?
04:02:18 <HugoDaniel> i didn't
04:02:23 <HugoDaniel> yes
04:02:34 <HugoDaniel> i will try it again and time it... just to make sure
04:02:53 <SamB_XP> you don't have to actually time it
04:02:58 <Saizan> make sure you enable optimizations etc..
04:03:11 <HugoDaniel> yes
04:03:15 <Botje> 8 MB of strings -> 192 mb of memory
04:03:22 <HugoDaniel> im doing ghc --make -O2 -fvia-C -optc-O3 Main.hs
04:03:23 <Botje> HugoDaniel: have you tried setting your heap size to something bigger?
04:03:26 <SamB_XP> not if it was a 10x difference lasting at least some seconds
04:03:48 <Botje> HugoDaniel: also, run your program with +RTS -sstderr
04:03:54 <SamB_XP> I mean, I'm assuming you're not talking 1 ms vs 10 ms here ;-)
04:03:54 <Botje> so you can see when garbage collects occur
04:04:12 <Saizan> Botje: with concatMap it runs reasonably fast, so i guess those shouldn't matter here
04:04:14 <SamB_XP> Botje: or he could use the beeping flag
04:04:25 <Botje> there's a beeping flag?!
04:04:27 <Botje> brilliant!
04:04:32 <SamB_XP> pretty sure
04:04:35 <Botje> we finally have programs that go PING!
04:04:37 <SamB_XP> check your +RTS --help
04:04:43 <SamB_XP> heheheh
04:05:09 <Saizan> it beeps on every gc, it's wonderful!
04:05:12 <SamB_XP> not if you install the SimCity 2000 sounds and cursors pack ;-P
04:05:20 <Botje>   -B       Sound the bell at the start of each garbage collection
04:05:22 <Botje> indeed
04:05:23 <Botje> cool
04:05:50 <SamB_XP> I honestly like the SimCity 2000 error sound a lot better than MS's ding ...
04:06:29 <SamB_XP> oh, and the screensaver in that pack is pretty amusing
04:06:36 <SamB_XP> it's called "the mad zoner", iirc
04:07:05 * SamB_XP hopes that someone has archived the pack
04:07:32 <SamB_XP> 'cause somehow I doubt EA is cool enough to have kept it around on any of their websites
04:07:44 <SamB_XP> I hate EA :-(
04:08:03 * SamB_XP wants the old maxis back
04:08:57 <Botje> http://ftp.games.skynet.be/pub/ftp.ea.com/maxis/patches/SC2000/
04:09:07 <Botje> there's a sc2kthm.zip there
04:09:49 <SamB_XP> that's probably it then
04:09:55 <SamB_XP> how did you find that so quick ?
04:10:05 <Botje> google for "the mad zoner"
04:10:06 <Botje> it didn'
04:10:10 <Botje> t give many hits though
04:10:28 <SamB_XP> ah
04:10:42 <SamB_XP> I see it in my search results now that you mention it
04:10:51 <SamB_XP> I had already googled for it but forgot to look at the results ;-P
04:11:23 <Botje> let me know if it runs
04:12:33 * SamB_XP prepares to PirateBay it
04:13:00 <Botje> isn't sc2k abandonware by now?
04:13:24 <Botje> http://www.abandonia.com/en/games/82/SimCity+2000.html apparently it is :)
04:13:29 <SamB_XP> Botje: I mean, I'm going to make a torrent and upload it to piratebay
04:13:47 <SamB_XP> I'm not bothering to figure out if it's actually so-called piracy or not
04:13:57 <Botje> well, it isn't
04:14:11 <Kyssan> Purely out of interest.. is there a way to use mutability within a pure function for the sake of efficiency (e.g. a ByteString accumulator to concatenate a large number of strings?)
04:14:14 <Botje> since abandonia hasn't received any ESA threats
04:14:23 <SamB_XP> I'm fairly certain EA won't really care either way, and I don't feel like reading the license to figure it out for no reason ;-)
04:14:46 <SamB_XP> well, I don't think it becomes a great deal more legal just because nobody complains ?
04:14:54 <koala_man> it's illegal, it's just that no one cares
04:15:07 <Botje> EA isn't losing money because they're not selling the game anymore
04:15:14 <cads> morning all! ٩(̾๏̮̮̃̾๏̃̾)۶
04:15:16 <Botje> abandonia makes _real_ sure that's the case.
04:15:24 <SamB_XP> but I dunno about for this Windows theme pack whether the license forbids redistribution by random people or not
04:15:37 <cads> ah crud, unicode does not transmit as compound characters over irc
04:15:39 <koala_man> they're losing money because people play sc2k instead of sims 4
04:15:45 <cads> that was supposed to be a humorous funny face.
04:15:51 <SamB_XP> koala_man: they don't lose money from that
04:15:58 <koala_man> why not?
04:16:14 <SamB_XP> they lose money only if people figure out they're going to do that *before* buying the sims 4
04:16:31 <SamB_XP> and this assumes the people were interested in buying any "the sims" stuff in the first place
04:16:35 <koala_man> not everyone has bought sims 4 already
04:16:42 <Botje> cads: looks fine here
04:16:57 <SamB_XP> I don't really think I want to buy "the sims" ever
04:17:00 <Botje> sim city >>> the sims
04:17:00 <koala_man> they don't want to compete against themselves
04:17:23 <koala_man> totally
04:17:25 <SamB_XP> anyway, I think my family has enough copies of Simcity 2000 by now that it wouldn't be pirating for *me* to download it ;-)
04:17:34 <SamB_XP> enough legal copies, I mean
04:17:52 <zygoloid> SamB_XP: i have a copy i paid for and am not using. i hereby transfer ownership of it to you.
04:18:04 <quicksilver> I rather liked simlife.
04:18:07 <SamB_XP> zygoloid: of the sims ?
04:18:11 <zygoloid> SamB_XP: SimCity 2000
04:18:23 <SamB_XP> zygoloid: I told you we've already got enough of those
04:18:35 <zygoloid> SamB_XP: now you have one more. also get your junk out of my house
04:18:38 <SamB_XP> I just wish I had media for my SimCopter license ;-P
04:18:49 <SamB_XP> zygoloid: I'm not paying to ship something I never asked for to me
04:18:56 <SamB_XP> ;-P
04:18:56 <zygoloid> :D
04:20:10 <koala_man> simcopter ruled
04:20:19 <SamB_XP> it still rules
04:20:31 <SamB_XP> it's just that I could never figure out how to bypass the CD check :-(
04:20:53 <koala_man> well, I would have liked an opengl version that could run at more than 640x480
04:20:55 <SamB_XP> and in the process of attempting to duplicate the CD, the CD shattered
04:21:11 <SamB_XP> I don't think OpenGL supported graphics that bad?
04:21:13 <koala_man> my cd isn't readable anymore
04:21:29 <SamB_XP> mine either, obviously ;-P
04:21:56 * SamB_XP checks isohunt ...
04:22:16 <koala_man> that view distance slider doesn't go far enough either. maybe you can hack the config file
04:22:51 <SamB_XP> I would have thought you'd need to hack the code
04:23:01 <SamB_XP> doesn't the slider have only 2 or 3 positions ?
04:23:19 <koala_man> I seem to remember it as fairly continous
04:23:35 <SamB_XP> huh, maybe
04:23:58 <SamB_XP> but I still think my idea is better ;-)
04:24:20 <cads> can you torture your sims in The Sims?
04:24:26 <koala_man> the jazz channel was awesome, in all its 8khz mono glory
04:24:33 <cads> how good is the cognitive model?
04:24:46 <SamB_XP> cads: you can do things that are usually considered to be torture
04:24:55 <SamB_XP> but I'm fairly certain they don't *actually* suffer
04:24:55 <Baughn> cads: ..not very, but far better than most games
04:25:12 <Baughn> Their intelligence level is quite a bit lower than a housefly, so if you swat those..
04:25:33 <SamB_XP> Baughn: they usually get away from me ...
04:25:34 <cads> can you give them neuroses?
04:25:36 <koala_man> SamB_XP: ah, apparently I have the iso of it. want it?
04:25:36 <SamB_XP> the house flys, I mean
04:25:39 <Baughn> cads: No.
04:25:42 <SamB_XP> koala_man: does it work ?
04:25:45 <cads> what's the point?
04:25:59 <koala_man> SamB_XP: yes, ran ok in wine last I tried
04:26:07 <SamB_XP> koala_man: cool!
04:26:10 <SamB_XP> how big is it ?
04:26:11 <Baughn> cads: If you want good game AI, look at Creatures or Dwarf Fortress.. both of which run on far less of a budget than Sims
04:26:26 <Baughn> There are probably others
04:26:45 <cads> how was spore?
04:26:56 <koala_man> SamB_XP: 624MB on 10mbps, uncompressed
04:27:00 <Baughn> cads: Horrid.
04:27:52 <cads> bleh, I only play chess..
04:28:08 <cads> I am lucky that the ais there are just fine
04:28:26 <Baughn> ..sha-256 is supposed to output /256 bits/, right?
04:28:31 <SamB_XP> koala_man: how do you propose to get it to me ?
04:28:32 <cads> in fact /they/ torture /me/.
04:28:57 <koala_man> SamB_XP: are you on XP?
04:29:05 <Baughn> cads: Try Go. The AIs are much better, while being much worse. :3
04:29:08 <SamB_XP> koala_man: yeah
04:29:12 <koala_man> hmm
04:29:15 <SamB_XP> why ?
04:29:34 <koala_man> I was hoping to just pipe it through netcat since I don't have much in the way of servers installed
04:29:41 <cads> baughn, I think you still have to be a world class player to beat them?
04:29:45 <koala_man> can tack on a http header and see :P
04:30:03 <SamB_XP> koala_man: that sounds awfully non-resumable :-(
04:30:30 <cads> it's funny because you can say that boardgame AIs exhibit a form of formally defined free will :)
04:30:47 <SamB_XP> cads: what makes it "free"?
04:30:59 <SamB_XP> do they use real RNGs nowadays ?
04:31:22 <Baughn> cads: No, just very good
04:31:37 <cads> it has to be able to model likely futures and possible actions, and then make a choice as to what action it wants
04:31:43 <Botje> @pl ok xs ys = and $ zipWith (<) xs ys
04:31:43 <lambdabot> ok = (and .) . zipWith (<)
04:31:46 <Baughn> SamB_XP: Since when does randomness have anything to do with "free will"?
04:31:48 <koala_man> SamB_XP: I can put it on proper http in about ten minutes
04:31:53 <Baughn> SamB_XP: Although.. how do you define free will?
04:31:59 <SamB_XP> Baughn: I don't know yet
04:32:04 <SamB_XP> but I was wondering what he meant by it
04:32:26 <Baughn> SamB_XP: I don't. I don't think it exists, and that the concept itself is relatively incoherent. :P
04:32:46 <Baughn> Well, it's fine as a shortcut for "without outside coercion" though
04:32:51 <SamB_XP> I'm not sure if it exists, and if it does, I think the concept is beyond mere mortals
04:33:09 <Baughn> I also don't think there are concepts beyond mere mortals.
04:33:12 <cads> so probabilistic model of the future to model and judge outcomes of possible actions, and a utility function to choose the actions thus visualized, boom, free will
04:33:21 <Baughn> SamB_XP: http://lesswrong.com/lw/1ht/11_core_rationalist_skills/ <-- Hey, you may find this interesting
04:33:29 <medfly> Baughn, well, you wouldn't know of them, mortal
04:33:35 <SamB_XP> Baughn: well, I have to say it will suck to be you on judgement day ...
04:33:58 <Baughn> SamB_XP: In the event that such an unlikely thing occurs, yes, yes it would
04:34:18 <SamB_XP> what make you think it's so unlikely ?
04:34:22 <medfly> I see myself as a pretty rationalist person, but I can imagine myself not grasping some concept, just because it happened a lot of times.
04:34:31 <SamB_XP> (don't you actually think it's impossible?)
04:34:33 <Baughn> SamB_XP: Same goes for 63999/64000 of everyone else
04:34:36 <cads> http://www-formal.stanford.edu/jmc/freewill2.ps
04:34:57 <SamB_XP> Baughn: where I come from, people claim to think differently for some reason
04:35:20 <Baughn> SamB_XP: What,they don't believe the bible? It says there that only 110,000 or so people get into heaven.
04:35:20 <medfly> SamB_XP, oh yes. they want attention. lots of it.
04:35:43 <Baughn> medfly: Oh, I didn't mean there can't be concepts beyond /particular/ people. I mean, I don't think there's anything beyond our civilization as a whole, should we work long enough at it.
04:35:48 <cads> the guy builds something like a process calculus within which he can define certain classes of free will, or something
04:35:58 <Baughn> medfly: Though it may require building AIs, in some cases. :P
04:36:01 <medfly> Baughn, I can just imagine that it's really possible that everyone is just too bloody stupid.
04:36:11 <SamB_XP> Baughn: have you *seen* our civilization lately ?
04:36:21 <Baughn> SamB_XP: Yes. It's quite impressive, given our origins.
04:36:27 <medfly> SamB_XP++
04:36:34 <osaunders> SamB_XP: What about it?
04:36:40 <SamB_XP> so many idiots!
04:36:44 <Baughn> SamB_XP: And no, I don't think 0 and 1 are valid probabilities, in the sense that no amount of sensory data will ever let me give either probability to an actual possible event
04:37:00 <osaunders> SamB_XP: Oh god yes. I include myself.
04:37:16 <medfly> SamB_XP, what, are you like, religious?
04:37:37 <SamB_XP> Baughn: well, yes, you certainly can't get those empiracally
04:37:40 <SamB_XP> medfly: yeah
04:37:59 <medfly> SamB_XP, it's really reasonable for me to say that you're the one acting weird and seeking attention ;)
04:38:15 <medfly> SamB_XP, what religion?
04:38:20 <SamB_XP> christian
04:38:21 <cads> I dunno, I think some kind of rise to consciousness is waiting in the wings for humanity
04:38:30 <SamB_XP> cads: hehehe
04:38:33 <Baughn> SamB_XP: Empirical evidence is the only form of evidence I accept. It gets a little muddled by my brain's architecture /itself/ being empirical evidence, but thinking you can get true beliefs without evidence is just wrong.
04:38:47 <cads> hehe, I say that with my tongue in my cheek and my fingers crossed
04:38:55 <SamB_XP> Baughn: point
04:38:56 <osaunders> SamB_XP: You're Christian?
04:39:03 <Baughn> SamB_XP: Or to put it another way..
04:39:07 <SamB_XP> osaunders: yeah
04:39:16 <Baughn> SamB_XP: "Realize that it is /information-theoretically impossible/ to reliably get true beliefs unless you actually get reliably pushed around by the evidence"
04:39:34 <Baughn> SamB_XP: Math, not just local circumstances. There are no possible universes in which this is false.
04:39:40 <osaunders> SamB_XP: Do you live in America?
04:39:42 <cads> Baughn, what is a true belief?
04:39:57 <cads> short def, if possible :D
04:39:58 <Baughn> cads: One that reliably predicts sensory input
04:40:10 <SamB_XP> yeah, you can't even know what anything means without these empirical processes in your brain ...
04:40:16 <medfly> YER MIND IS PLAYING TRICKS ON YE!
04:40:33 <SamB_XP> osaunders: yeah
04:40:34 <cads> well the human mind consistently plays tricks
04:40:45 <Baughn> Yep, which you have to correct for
04:40:53 <cads> which is why we find electron orbitals unintuitive, and such
04:40:54 <Baughn> Fortunately we've got just enough functionin machinery to do that
04:41:02 <SamB_XP> a lot of americans claim to be christians but I don't actually believe most of them even know what that means ...
04:41:05 <medfly> I read too much about things like psychosis and memory (distortion) to rely THAT strongly on what I know.
04:41:17 <cads> SamB_XP, which sect?
04:41:24 <medfly> SamB_XP, yes, they don't practise the same christianity as you.
04:41:47 <Baughn> medfly: If you've been noticing that.. have a look at lesswrong.com; the site is /dedicated/ to classifying such biases, and solutions
04:41:54 <cads> I love the new christian death metal, because I feel satan's caress when I listen to it, and I don't even believe in the bastard :)
04:42:01 <medfly> Baughn, what do you mean?
04:42:05 <SamB_XP> cads: me? I'm from presbyterian background, but I haven't bought into that whole calvinism thing yet ...
04:42:07 <Baughn> medfly: Well, read http://lesswrong.com/lw/1ht/11_core_rationalist_skills/ - you'll see
04:43:55 <medfly> Baughn, I'm actually really all for that, it's just that I don't feel it's so great to rely on my memory and thought which I know can be screwed up with me being unable to realise this.
04:44:14 <medfly> at least... rely on it so strongly
04:44:32 <medfly> it might be a bit too unrelated to the subject
04:46:20 <Baughn> medfly: So it would be good to reduce those problems, yes?
04:46:27 <medfly> what
04:46:47 <Saizan> i declare #haskell-blah on you!
04:46:59 * medfly moves.
04:47:19 * Baughn doesn't. Fixing a sha-2 implementation.
04:47:32 <Baughn> Honestly, whose bright idea was it to return the hash as an /ascii string/?
04:48:05 <cads> what is wrong with that?
04:48:29 <Baughn> cads: It takes twice the space of a binary one
04:48:33 <Baughn> ..plus one byte
04:48:45 <medfly> Thu Dec  3 14:56:35 IST 2009
04:48:48 <medfly> it really isn't a problem.
04:48:50 * Baughn is a fan of binary interfaces
04:49:10 <Baughn> medfly: I see your date and raise you "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"
04:49:34 <Baughn> Anyway, I'm stuffing it into a Data.ByteString, so whatever their reasoning, I want binary.
04:49:41 <medfly> I'm just saying that it's okay that it's "double the space", because it's 2009.
04:49:55 <cads> naw, it's important
04:50:15 <Baughn> medfly: And this kind of thought is what gave us XML
04:50:20 <osaunders> Are there linked lists in Haskell, the kinds that you can hold references to list items?
04:50:30 <osaunders> And traverse the links manually,
04:50:30 <medfly> haha
04:50:43 <Peaker> osaunders: Haskell [] lists are linked lists
04:50:45 <medfly> wait, what's so bad about XML?
04:50:53 <osaunders> Peaker: Yeah, that's not what I mean.
04:51:03 <koeien37> i don't understand the XML hate either
04:51:25 <SamB_XP> grr... why do the sysinternals command-line utilities have to pop up *GUI* license-acceptance boxes ?
04:51:39 <ben__> The only good use for xml is xhtml
04:51:39 <Peaker> osaunders: when you "tail" the list, you get a reference to a mid-list item
04:51:39 <osaunders> Actually ignore my question. I'm being silly.
04:51:51 <SamB_XP> ben__: not true!
04:52:02 <koeien37> it's a decent markup language
04:52:20 <ben> I suspect so, but I have not had a lot of need to mark things up.
04:52:21 <SamB_XP> ben__: it has a few advantages over SGML -- for instance, the specs are free
04:52:33 <SamB_XP> also it's a heck of a lot simpler to parse
04:52:37 <osaunders> Peaker: You're not doing a great job of ignoring there.
04:52:42 <ben> Okay, I also have not seen anyone use SGML, outside of html.
04:52:44 <SamB_XP> not so easy to write, sadly
04:52:45 <cads> I don't really understand the novelty XML except that it somehow encodes the data schema as well and this is a good thing for otherwise unstructured data.. is that basically true?
04:53:05 <Baughn> medfly: It's hard to parse XML, very hard to do so /fast/, and it balloons network traffic enormously. That's what's bad about it.
04:53:07 <SamB_XP> DSSSL is neat, really
04:53:08 <Peaker> osaunders: what? I said nothing since you said ignore :)
04:53:15 <Peaker> osaunders: perhaps lag is among us
04:53:19 <Baughn> cads: No, that's not novel either
04:53:20 <SamB_XP> Baughn: but not nearly as hard as for SGML!
04:53:26 <osaunders> Peaker: Sorry, that was rude. You're just trying to be helpful. I appreciate that.
04:53:37 <Baughn> SamB_XP: I'd still rather use Pickle or something
04:53:42 <osaunders> Peaker: Yeah, probably that too.
04:53:51 <SamB_XP> cads: the thing about XML is that you don't need a DTD just to *parse* a document
04:54:07 <ben> Why are we not replacing all uses of XML with json again?
04:54:17 <SamB_XP> you do potentially need the DTD to expand entity references, but ...
04:54:29 <Baughn> ben: ..well, that's still not a binary format, but... admittedly, it is nicer
04:54:45 <SamB_XP> Baughn: so what if it's not binary?
04:54:48 <cads> ben, because JSON reminds us of that horror movie and creeps us out
04:54:50 <SamB_XP> it's easy to parse fast
04:54:58 <ben> Baughn: I do not trust any format I cannot open in notepad and get confused by myself
04:55:46 <SamB_XP> I mean, seriously, just look at the webpage -- that's practically everything you need to know right there, and it would probably fit on 1 or 2 sheets of paper
04:55:46 <osaunders> XML hate -> #haskell-blah
04:56:03 <Baughn> SamB_XP: Non-binary formats are fine for many purposes. Binary ones are useful for others. But we seem to be missing a simple, universal binary format.
04:56:08 <cads> I kind of like the human readability aspect... and shouldn't the code be compressed when it travelling over the network?
04:56:14 <Baughn> I.e. the binary version of JSON
04:56:23 <SamB_XP> Baughn: we could use Banana
04:56:32 <Baughn> cads: A domain-specific encoding does a much better job than gzip
04:56:33 <SamB_XP> I think that basically is the binary version of JSON
04:56:38 <cads> pickle, banana, maybe we'll use hot dog?
04:56:48 <SamB_XP> cads: no, pickle is not suitable
04:56:54 <SamB_XP> it's Python-specific
04:56:56 <Baughn> cads: ..that amounts to "have two encodings for the same format, convert from binary to ascii when shown to the user"
04:57:04 <Baughn> It should be simple. Really.
04:57:17 <SamB_XP> and it requires you to have all the modules that the classes in the data come from, too
04:57:23 <SamB_XP> and it's not exactly safe
04:57:38 <ben> Any actual benchmarks for actual data sizes in a binary encoding compared to gzip'd json/xml?
04:57:52 <cads> SamB_XP, I was cracking a joke :)
04:58:00 <SamB_XP> fine, fine
04:58:16 <SamB_XP> did you here about pb and jelly, also from Twisted?
04:58:51 <cads> I hate to admit how advanced XML has gotten, i'm pretty sure I could use it and do crazy things with it without having to ever write or read it, and that makes it useful
04:59:19 <SamB_XP> cads: you forgot about debugging, I think ;-P
04:59:21 <cads> but, ah... I dunno, I'm so backwards on web tech
04:59:34 <SamB_XP> but yes, it *can* be quite useful
05:00:17 <joe____> i am about to start writing a program that sends commands to a usb device, reads the output back, compares the output with a predefined result and writes out on whether the command is successful or not. Basically, a test suite to an usb device. I do not want to write a dsl to parse my test cases and results and am wondering if there is any module/existing code that I can look for guidance
05:02:08 <koala_man> SamB_XP: http://www.vidarholen.net/~vidar/SimCopter.iso
05:02:40 <cads> I feel like a big thing to worry about is all this unstructured data we've got is going to be uninterpretable in the future, and that documents should spend more data on describing their meaning and not just content
05:03:51 <cads> some computer archeologist of the future is going to really hate us for all our disparate formats
05:04:44 <joe____> i have the usb device interface completed. I just want to know if there is any other option other than having to write the data in a custom format and read the data from a haskell program.
05:05:34 <SamB_XP> koala_man: thanks!
05:08:36 <SamB_XP> joe____: what sort of data is it? have you considered using QuickCheck?
05:08:55 <cads> hey sam, do you believe that physical processes are in the end deterministic?
05:09:09 <SamB_XP> cads: I doubt it
05:09:12 <joe____> the command is basically string data and the result is one integer
05:09:16 <SamB_XP> but who can tell ?
05:09:21 <Baughn> SamB_XP: Even after all the evidence suggesting they are?
05:09:39 <joe____> the file format is:
05:09:42 <cads> Baughn, are we talking hidden variables?
05:09:46 <joe____> command1 --> result1
05:09:47 <SamB_XP> Baughn: oh, they've flipflopped that way again now ?
05:09:54 <Baughn> cads: For quantum mechanics? No, MWI
05:09:54 <joe____> command2 --> result2
05:10:01 <Baughn> SamB_XP: The math has never been nondeterministic
05:10:36 <SamB_XP> okay, I'll just admit that I'm not quite up to that math, honestly ...
05:10:44 <joe____> instead of putting all the 'commands -> results' into a configuration file, I am wondering if there is a better way to do it.
05:10:56 <Baughn> SamB_XP: Well, I can assure you there's no rnd() calls anywhere. ;)
05:11:06 <SamB_XP> Baughn: you've seen the code?
05:11:12 <SamB_XP> then you must be buddies with God!
05:11:13 <Baughn> SamB_XP: I helped write it
05:11:24 <SamB_XP> yet you say you don't believe in him, so you must be teasing
05:11:35 <Baughn> Well, I don't believe he's a /god/
05:11:43 <Baughn> Actually, he's a game programmer.
05:11:45 <cads> good programmer/
05:11:46 <SamB_XP> I had no idea you were that old
05:11:53 <Baughn> Oh, this avatar isn't
05:12:05 <cads> sheesh, this is a rationalist
05:12:16 <Baughn> Rationalists are allowed to have fun too. :P
05:12:26 <cads> hehe, that is illogical :D
05:12:32 <Baughn> Not at all
05:12:37 <SamB_XP> is not
05:12:38 <Baughn> Rationality is about achieving your goals better
05:12:39 <ben> Do vacuum fluctuations work with deterministic physics?
05:12:42 <SamB_XP> it's good for your health
05:12:48 <Baughn> ben: Yes
05:12:53 <Baughn> ben: MWI again.
05:13:21 <Baughn> cads: http://lesswrong.com/lw/59/spocks_dirty_little_secret/ <-- Also, this
05:13:40 <cads> ben, imagine your idea of nondeterminstic physics, and then suppose that all the possible outcomes are being manifest at once, boom, not indeterminstic anymore
05:14:05 <ben> So instead of hidden variables we now have hidden many-worlds?
05:14:09 <SamB_XP> oh, geeze, not the List monad again!
05:14:16 <Baughn> ben: Yeah, but they're not really hidden
05:14:21 <cads> except they are manifest orthogonally to each other and can't be observed from one to the other
05:14:33 <Baughn> That's only true when decoherence happens
05:14:48 <Baughn> If you pay careful attention and set up the experiments right, you can avoid that for a while..
05:15:02 <Baughn> Leading to results such as the double-slit experiment, and many more
05:15:29 <Baughn> Not to mention that quantum computers are built based on splitting the universe, doing all the calculations at once, and then carefully putting it back together so you get the same result in all of the (now identical) "splits"
05:15:34 <cads> would be amazing to realize that as many universes interfering together
05:16:00 <Baughn> Anyway, if you run the math on quantum mechanics, many-worlds is the outcome it actually predicts
05:16:01 <cads> heh, I'm sure thats exactly what we already do
05:16:07 <Baughn> You have to add something extra to get the /other/ interpretations
05:16:29 <SamB_XP> Baughn: you mean, many-worlds is the simplest interpretation of the math?
05:17:10 <Baughn> SamB_XP: Yes
05:17:34 <SamB_XP> sorta like the Free Monad etc.?
05:17:43 <Baughn> SamB_XP: When you evolve the universe's wavefunction according to the basic interpretation, what you get is, well, what MWI predicts. To get something else, you have to add a post-processor
05:17:58 <Baughn> And there's no physical basis for the existence of such a post-processor
05:17:59 <cads> Baughn, are you one of those borgueian platonists that believes all possible mathematical structures exist, and that we are simply part of one of those mathematical structures complex enough to have substructures that are self-aware?
05:18:12 <cads> that's my MWI :)
05:18:16 <Baughn> cads: I consider that to be a reasonably likely option, yes
05:19:00 <Baughn> Add a probability measure based on shannon complexity to the structures, and Occam's razor pops out as a /derivation/. ^_^
05:19:10 <SamB_XP> lol
05:19:13 <cads> you've been reading tegmark
05:19:24 <Baughn> Well, he makes sense. :)
05:19:43 <cads> are you kidding, I love tegmark!
05:19:55 <cads> four levels of multiversery
05:20:06 <cads> almost magical :)
05:20:49 <Baughn> SamB_XP: Oh, that's right..
05:21:19 <Baughn> SamB_XP: MWI is one thing, but in fact, it has been shown (using entanglement experiments) that non-determinism is /not compatible with locality/
05:21:33 <Baughn> So everyone's focusing on the deterministic interpretations, of various sorts
05:21:42 <Baughn> MWI is still the simplest of those, for obvious reasons. :P
05:22:01 <medfly> Baughn, I'm tempted to write a furious comment to lesswrong
05:22:31 <cads> I need to re-read the part about the grand mathematical ensemble to see exactly what kinds of mathematical structures he's talking about as being possible.. I think he's talking about consistent formal theories written in terms of sets of independent axioms
05:23:14 <Baughn> medfly: Go ahead.
05:24:05 <Baughn> cads: If you do, check whether he also allows alternative tautologies
05:24:22 <Baughn> cads: Have you read Godel, Escher, Bach?
05:24:34 <medfly> it's just so old then what's the point
05:24:48 <Baughn> ..well, point
05:24:56 <cads> what I wonder about is 1) how do the structures decide whether they're consistent and therefore real and 2) what about the possibility of some paramathematics which is real but not formalizable
05:25:40 <Baughn> cads: For (1), consider the option that they check at runtime, and just crash if they hit an inconsistency
05:26:23 <Baughn> cads: (The case where they /don't/ crash was covered in Greg Egan's Luminous. Hang on.. http://brage.info/~svein/luminous.pdf)
05:26:37 <cads> baughn: http://xkcd.com/505/
05:27:18 <cads> Baughn, that really doesn't solve the problem of whether the structure the computer is running on is consistent :D
05:27:46 <cads> that's not much stronger than saying "God runs the joint"
05:28:06 <Baughn> Well, yes it is - god's prior probability is rather tiny
05:28:17 <Baughn> Occam's razor, remember. But point taken.
05:28:37 <cads> hmm, I remember the simulationist argument
05:28:55 <Baughn> Oh, and the first option I suggested..
05:28:58 <Baughn> cads: http://xkcd.com/240/ <-- Better strip
05:29:45 <cads> hah, that one hurts me heart
05:29:50 <Baughn> ...I've had that dream. They're always the most realistic ones. :/
05:30:11 <Baughn> cads: Ignore the last three panels, and you see what I'm getting at
05:30:25 <Baughn> In fact, just stick to #2
05:30:36 <cads> right
05:31:03 <cads> man, I need to learn more about formal theories
05:31:26 <Baughn> *Read* godel, escher, bach.
05:32:29 <cads> man I won't read hofstater because he seems like a modern mystic rather than a real scientist
05:32:45 <Baughn> It's still the best introduction to formal systems I've seen
05:32:56 <Baughn> At least borrow the book.
05:37:34 <cads> allright, so we have a set of axioms determining physics. We use these axioms to define the existence of a universe of sets describing possible initial conditions, those initial condition that are consistent with the rules. At the same time we now have an implied universe of every consistent complete space-time in the theory.
05:38:19 <cads> boom, some of those space times correspond to universes where live evolved and we're here in irc talking about this
05:39:05 <Baughn> There have to be universes that are much nicer to intelligence out there. Pity we're living in /this/ one.
05:39:45 <cads> I still think that this skirts the issue of what it is that the formal theories live on
05:40:05 <quicksilver> the brains of dead mathematicians
05:40:20 <cads> nomz nomz!
05:43:36 <cads> anyways, suppose the theory is inconsistent, then for a given spacetime we may be able to produce independent theorems stating that the spacetime both is and is not a member of the possible worlds in the theory
05:44:09 <cads> basically the theory completely melts down and fails to have any true statements
05:45:44 <quicksilver> rather, it has too many true statements ;)
05:45:48 <quicksilver> it thinks everything is true.
05:45:59 <quicksilver> which is not a very practical theory
05:46:08 <quicksilver> or at least, not a very useful notion of truth.
05:46:16 <cads> so such theories would be members of tegmark
05:46:22 <cads> s universe
05:46:24 <cads> bleh
05:46:30 <pastah_rhymez> Could not find module `HereDoc' <-- what's the cabal package for this? can't find any :(
05:47:09 <cads> quicksilver, I think people are trying to work on paralogics, which deal with inconsistent systems :D
05:47:56 <dcoutts> pastah_rhymez: the google search on hackage doesn't turn up anything either
05:48:16 <cads> I think the great ensemble theory would say that these theories inconsistent under classical logic would still be present, but simply define trivially empty structures
05:49:04 <cads> but hey, are we going to create a great ensemble and then when we find some crazy nonlogic too, create a large ensemble?
05:49:15 <joe____> hunit vs quickcheck? does anybody use hunit and am wondering if u have any thoughts?
05:49:16 <cads> larger*
05:50:30 <HugoDaniel> hmm
05:50:33 <HugoDaniel> back
05:50:42 <quicksilver> hunit and quickcheck are solving different problems, mostly
05:50:44 <HugoDaniel> ok, so foldr is darn slow, and concatMap is very fast
05:50:53 <HugoDaniel> i recompiled it with +RTS -B, and no bell sounded
05:50:57 <quicksilver> quickcheck is type-directed randomised testing of properties
05:51:09 <quicksilver> hunit is structuring unit tests
05:51:13 <ivanm> joe____: note that quickcheck can't test IO functions (AFAIK, anyway)...
05:51:20 <quicksilver> you could use, for example hunit unit tests which used quickcheck to do (some of) the work
05:51:45 <joe____> ok, thanks.
05:52:02 <joe____> can I assume that hunit is more a collection of testsuites?
05:52:16 <joe____> can I assume that hunit is more a collection of tests into a testsuite?
05:52:45 <joe____> and quickcheck is where the inputs are arbitrary/unknown?
05:54:15 <poe> joe____ check out the wiki, http://haskell.org/ there must be articles on hunit and qc (and qpc maybe)
05:54:35 <joe____> thanks, will do so.
05:57:18 <cads> Baughn, Jürgen Schmidhuber seems to answer some of my misgivings by limiting things to the universes computable by constructivist math
05:58:03 <cads> http://arxiv.org/abs/quant-ph/0011122
06:00:30 <cads> this kind of mathematical theory of everything for me on a bad day turns into this nasty feeling of super pure nihilism, I think I prefer a form of self referential literary modal realism, where at least you know some author is writing your universe, and you could write his if you wanted to
06:01:03 <quicksilver> actually, I couldn't
06:01:08 <quicksilver> my handwriting is too scruffy
06:01:12 <quicksilver> it would go terribly wrong.
06:01:48 <cads> at least I'm sure you could come up with a better ending than 2012 :P
06:02:22 <cads> typed manuscript also is appropriate for engendering new universes.
06:02:53 <cads> for that matter so should thought be
06:03:00 <cads> umm, and any formal relation at all :P
06:05:46 <cads> Baughn, I actually feel really lucky to be in a universe that is not completely hellish for its conscious members at the current time. I feel lucky to be alive now, rather than during the spanish inquisition, or the plague, or prehistory
06:06:39 <cads> but that's just this universe... think about all the boschian nightmare universes there are out there
06:06:45 <eevar2> cads: hey now, don't forget about the swine flu :p
06:07:05 <HugoDaniel> i like this: http://www.pcper.com/article.php?aid=825
06:07:09 <HugoDaniel> 48core cpu
06:07:17 <HugoDaniel> haskell ftw!
06:07:26 <ben> cads: I assume by that universe you mean the set of first world countries?
06:07:54 <mmorrow> cads: can i have some of what you just smoked?
06:08:11 <cads> surely, bro!
06:08:16 <mmorrow> :)
06:09:53 <cads> ben, heh, mine is a brittle optimism, you just have to remind me of the human trade industry
06:10:49 * cads has decided that any reality that contains himself must be the best of all possible realities
06:11:04 <HugoDaniel> :)
06:11:24 <HugoDaniel> yeah cads
06:11:30 <HugoDaniel> in those times there wasn't even haskell
06:11:40 <medfly> "those times"?
06:11:42 <medfly> like, now?
06:11:42 <cads> y'kno?
06:11:56 <cads> medfly, ancient times
06:11:59 <medfly> there's still human trade going on these days.
06:12:15 <medfly> HOW IS THAT FOR OPTIMISM?
06:12:27 <cads> well, that's what I meant
06:12:50 <HugoDaniel> im planing on buying some asians, teach them haskell, and create a huge haskell code-force
06:13:13 <medfly> HASKELL CODE FORCE!
06:13:22 <medfly> will they have a dance?
06:14:03 <HugoDaniel> :D
06:15:29 <cads> What's that called when a sex slave has their limbs cut off at the elbows and forearms so that they must walk around on all fours like an animal?
06:15:42 <cads> suffice is to say, people do that
06:16:15 <HugoDaniel> thats useless... how can they code like that ?
06:16:40 <cads> with swishes from their pony tail butpluggs :P
06:16:47 <Zao> HugoDaniel: Speech recognition?
06:16:50 <medfly> lol
06:16:57 <Zao> You lads seem to be diverging from the topic, I must say.
06:17:11 <medfly> yeah, they don't feel like moving to #haskell-blah
06:17:36 <cads> bleh, sorry about that
06:18:07 <HugoDaniel> "colon, colon, space, capital i, small n, small t"
06:18:51 <medfly> I think they have eye things, so you move your eyes and then you can click stuff, that makes more sense
06:19:02 <medfly> tracks eye movement
06:20:04 <peternovice> If I define a monad transformer EitherT e m a = EitherT {runEither :: m (Either e a) }, should it not be possible to define its return to be able to return both Left e and Right b, i.e returnET Right f = EitherT  $ return (Right f); returnET Left f = EitherT $ return (Left f)?
06:20:51 --- mode: Lemmih set -o Lemmih
06:23:49 <BONUS> peternovice: the type of return for EitherT is (Error e, Monad m) => a -> EitherT e m a
06:24:05 <BONUS> not Either a e -> EitherT e m a
06:24:20 <BONUS> maybe you're thinking of lift?
06:24:27 <ski> peternovice : maybe you were thinking of `lift :: Monad m => m a -> EitherT e m a' ?
06:24:30 <ski> Kyssan : use `ST s' monad ?
06:24:52 <BONUS> > lift (Left "hah") :: EitherT String Maybe a
06:24:53 <lambdabot>   Not in scope: type constructor or class `EitherT'
06:24:59 <BONUS> > lift (Left "hah") :: ErrorT String Maybe a
06:25:00 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
06:25:00 <lambdabot>         against inferred ...
06:25:03 <BONUS> eh
06:25:16 <BONUS> > lift (Left "hah") :: ErrorT String (Either String) a
06:25:17 <lambdabot>   No instance for (GHC.Show.Show
06:25:17 <lambdabot>                     (Control.Monad.Error.Err...
06:25:22 <BONUS> sorry
06:25:23 <ski> `a' ..
06:25:24 <peternovice> Well I really just want to insert a Left value into the monad
06:26:03 <ski> > runErrorT (lift (Left "hah") :: ErrorT String (Either String) ())
06:26:04 <lambdabot>   Left "hah"
06:26:21 <BONUS> or you can use throwError
06:26:27 <ski> peternovice : so you want `Either e a -> EitherT e m a' ?
06:26:55 <BONUS> > runErrorT (throwError "errorr" :: ErrorT String Maybe a)
06:26:56 <lambdabot>   Just (Left "errorr")
06:27:27 <ski> defaulting ?
06:27:31 <peternovice> ski, Bonus I am not sure if you want me to see the analogy with ErrorT and use it for my EitherT.
06:27:55 <ski> i think so
06:28:17 <ski> (as long as you don't add evil `Error e' constraints !)
06:29:51 <BONUS> you want to make your transformer return on the outside but have a Left on the inside, right?
06:29:58 <fasta> How can I find the arguments the run-time system actually received?
06:30:14 <fasta> So, not the arguments that are passed to the program.
06:30:21 <peternovice> I will try lift (Left sometihg)
06:30:27 <BONUS> like [Left "blah"], Just (Left "blah"), etc.
06:31:11 <ski> peternovice : it would help if you explained better what you wanted ..
06:32:55 <peternovice> ski, sorry I was trying some things out, and trying to comprehend what you ment. Basically I have a EitherT like the one in Control.Monad.Either and I want to insert a Left into the monad m (Either a b) in EitherT.
06:33:19 <ski> what does "insert a Left into the monad m (Either a b) in EitherT" mean ?
06:33:44 <ski> can you give an example of what your function could take as input, and what it should give as output, in that case ?
06:35:03 <ski> (if you have some code where you need this, it might help to paste)
06:39:16 <peternovice> ski, sorry again, I am learning. But the return of EitherT b m a has type returnET :: a -> EitherT b m a and is implemented: returnET x = EitherT $ return (Right x). So I could have someting like returnET':: Either a b -> Either b m a, which does returnEt Left x = EitherT $ return (Left x); returnET Right x = EitherT  $ return (Right x). But basically I just want to have a way to insert a Left like I can insert a Right with the retu
06:41:42 <ski> peternovice : are you sure you didn't mean `Either b a -> Either b m a' ?
06:42:00 <peternovice> ski, you are right
06:42:43 <ski> and i think this sounds like you want `lift (Left foo)' instead of  returnET (Left foo)
06:42:43 <ski> if course you need to define `lift'
06:42:50 <ski>   instance MonadTrans (EitherT e)
06:42:52 <ski>     where
06:43:06 <ski>   --lift :: Monad m => m a -> EitherT e m a
06:43:10 <ski>     lift ... = ...
06:43:35 <ski> (s/if/of/)
06:44:04 <quicksilver> loft?
06:44:07 <quicksilver> ;)
06:44:23 <ski> obviously, yes ;)
06:45:35 <peternovice> But then I use "lift (left foo)" will I not enter the monad m ?
06:45:47 <peternovice> I mean m a?
06:48:34 <peternovice> Perhaps I should change my definition of lift: Now it is lift m = EitherT (liftM Right m)
06:51:56 <adu> peternovice: you will enter the land of Narnia
06:52:06 <ski> peternovice : hm, you're right. sorry, i confused things
06:52:11 <ski> my earlier suggestion
06:52:13 <ski> <ski> peternovice : so you want `Either e a -> EitherT e m a' ?
06:52:18 <ski> appears to be what you want
06:52:55 <ski> (as i ought to have seen, instead of thinking of `lift')
06:53:09 <ski> there is no standard abstraction for that, though
06:53:22 <ski> it could possibly be constructed as
06:53:29 <Hunner> @quote ski
06:53:29 <lambdabot> ski says: please talk to your son or daughter about parametric polymorphism
06:53:36 * ski sighs
06:53:59 <ski> (that's not a quote a mine .. that's from a quote of me quoting Benjamin something, from USENET)
06:55:14 <ski> @forget ski please talk to your son or daughter about parametric polymorphism
06:55:15 <lambdabot> Done.
06:56:08 <quicksilver> ski: you are wrong. It was you, and I have proof[1]. * [1] - http://sequence.complete.org/hwn/20061122
06:56:11 <quicksilver> ski: ;)
06:56:26 <ski> @remember Dave_Benjamin please talk to your son or daughter about parametric polymorphism
06:56:26 <lambdabot> Good to know.
06:56:49 <ski> quicksilver : i remember i've said it before, and i remember i quoted it from that guy
06:57:13 <quicksilver> ski: I was joking. It was an observation about wikitruth.
06:57:33 <quicksilver> ski: but, yes, it was dave benjamin's email sig from early years of the 2000s
06:57:58 <ski> *nod*
06:58:22 * hackagebot upload: uri 0.1 - Library for working with URIs (JaroslavGridin)
06:59:24 * hackagebot upload: vector 0.4.2 - Efficient Arrays (RomanLeshchinskiy)
07:03:21 <KlutTut> I want to define the function takeWhile using a  call to foldr. I have this: takeWhile' c xs = foldr (\x acc -> if f==x then x:acc else acc) [] xs
07:03:33 <KlutTut> but now I can't do takeWhile' odd [1,1,2]
07:03:35 <KlutTut> for example
07:03:40 <KlutTut> how do I fix this, any help?
07:05:29 <mtnviewmark> I'm assuming this is a homework problem?
07:05:39 <Botje> KlutTut: you're not using c in your definition?
07:06:02 <KlutTut> ow mistake, f = x
07:06:04 <KlutTut> stupid
07:06:06 <mtnviewmark> and I'm assuming that f==x was supposed to be f x  and takeWhile' c should have been takeWhile' f
07:06:07 <KlutTut> f =c
07:06:09 <KlutTut> i meant
07:06:14 <KlutTut> let's rewrite it
07:06:15 <KlutTut> one sec
07:06:36 <mtnviewmark> but here is a way to think about it
07:06:42 <KlutTut> takeWhile' c xs = foldr (\x acc -> c==x then x : acc else acc) [] xs
07:06:57 <mtnviewmark> is c a test element or a function?
07:07:10 <KlutTut> test element
07:07:17 <BONUS> :t takeWhile
07:07:18 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:07:24 <mtnviewmark> consder   takeWhile' odd [1, 3, 5, 2, 7, 9, 4, 11, 13]
07:07:43 <KlutTut> hm
07:07:49 <mtnviewmark> what should happen when the foldr "reaches" the 4?   what about the 2?
07:08:00 <benmachine> > odd == 1
07:08:01 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
07:08:01 <lambdabot>    arising from the lite...
07:08:06 <mtnviewmark> (I say "reaches" because while that is how one can think about foldr, that isn't actually how it happens)
07:08:06 <benmachine> :o
07:08:23 <KlutTut> odd == 1 is not possible that'smy problem
07:08:31 <benmachine> true
07:08:32 <mtnviewmark> (but no matter.... for this problem it is okay to think about it that way for now)
07:08:36 <benmachine> what *is* possible?
07:08:46 <KlutTut> if i rewrite the function of the foldr like:      (\x acc -> c x then x:acc else acc)
07:08:47 <mtnviewmark> > odd 1
07:08:47 <lambdabot>   True
07:08:50 <KlutTut> i can do odd and even but
07:09:01 <KlutTut> then I can't do takeWhile' 1 [1,1,2] for example
07:09:05 <mtnviewmark> > let x = 42 in odd x
07:09:06 <lambdabot>   False
07:09:23 <BONUS> takeWhile takes a predicate. just do takeWhile' (==1) [1,1,2]
07:09:25 <benmachine> you can't have a function that accepts "odd" and "1" as arguments
07:09:36 <benmachine> in the same place
07:09:42 <benmachine> because they are different types of things
07:10:06 <benmachine> @type odd
07:10:07 <lambdabot> forall a. (Integral a) => a -> Bool
07:10:08 <benmachine> @type 1
07:10:09 <lambdabot> forall t. (Num t) => t
07:10:19 <mtnviewmark> @type (==1)
07:10:20 <lambdabot> forall a. (Num a) => a -> Bool
07:10:46 <KlutTut> ah ok
07:10:58 <KlutTut> I thought the alrdy existing takeWhile could handle both
07:11:02 <mtnviewmark> I've gotta run, but also, KlutTut - consider [1, 3, 5, 2, 7, 9, 4, 11, 13] and what I asked about it   :-)  good luck
07:11:14 <KlutTut> k tnx
07:11:15 <mtnviewmark> > takeWhile 1 [1, 1, 2]
07:11:15 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
07:11:16 <lambdabot>    arising from the lite...
07:11:20 <mtnviewmark> :-)
07:12:07 <benmachine> KlutTut: it can do both behaviours, but takeWhile 1 is the wrong way to get the latter
07:12:26 <KlutTut> what's the righth way
07:12:47 <benmachine> do you know about partially applied functions?
07:13:20 <KlutTut> guess not
07:13:24 <KlutTut> doens't ring a bell
07:13:33 <benmachine> hmm
07:13:40 <ray> :t takeWhile
07:13:41 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:14:11 <ray> to misleadingly echo kant, 1 is not a predicate
07:14:45 <benmachine> if you have a function of multiple parameters, and you give it some but not all of them, you get a function that takes the remaining ones and produces a result
07:15:05 <KlutTut> ah
07:15:22 <benmachine> == is a function of two parameters, if you apply one parameter to it you get a function of one parameter
07:15:25 <benmachine> so
07:15:29 <benmachine> @type (== 1)
07:15:31 <lambdabot> forall a. (Num a) => a -> Bool
07:15:45 <benmachine> is a function of one parameter that takes a number and gives you True or False
07:15:53 <maurer_> Does anyone know if it's possible to have a cabal package that both contains a library and executables which link against that library?
07:15:57 <benmachine> which is exactly what takeWhile wants
07:16:08 <benmachine> > (== 1) 4
07:16:09 <lambdabot>   False
07:16:11 <benmachine> > (== 1) 1
07:16:12 <lambdabot>   True
07:16:24 <benmachine> > takeWhile (== 1) [1, 1, 2, 3, 5, 8]
07:16:25 <lambdabot>   [1,1]
07:16:30 <benmachine> etc.
07:16:56 <dcoutts> maurer_: that's now supported in Cabal-1.8
07:16:59 <KlutTut> ah ok
07:17:10 <maurer_> dcoutts: Cool, I'll go look through the 1.8 docs then.
07:17:30 <KlutTut> I understand, if you want to take the 1's out of a list you have to define the parameter correctly and not change the defenition of the function
07:17:37 <KlutTut> of takeWhile'
07:17:47 <dcoutts> maurer_: it's a matter of setting the build-depends of the exe to use the name of the lib
07:18:10 <dcoutts> maurer_: the catch is that you need the hs src dirs to be separate, otherwise it'd just pick up the sources locally again
07:18:27 <maurer_> dcoutts: That's fine. Thanks.
07:19:51 <ski>   class (Monad m,MonadTrans t)
07:19:58 <ski>      => MonadTransformable m t
07:20:03 <ski>       | m -> t , t -> m
07:20:07 <ski>     where
07:20:15 <ski>     exalt     :: Monad n => m a -> t n a
07:20:27 <ski>     humiliate :: t Identity a -> m a
07:20:27 <ski>     -- humiliate . exalt = id
07:20:27 <ski>     -- exalt . humiliate = id
07:20:30 <ski>     -- exalt . return = return
07:20:34 <ski>     -- exalt . join = join . exalt . liftM exalt
07:20:37 <ski>     -- humiliate . return = return
07:20:39 <ski>     -- humiliate . join = join . humiliate . liftM humiliate
07:20:58 <ski> any more laws ?
07:21:21 <ski> (i suppose functor laws .. but possibly those follow from parametric polymorphism ?)
07:21:46 <quicksilver> they do, but they're still laws, I think.
07:21:56 <THC4k> how do i check if a possibly infinite list has exactly n elements ?
07:22:26 <poe> THC4k recurse with an accumulator
07:22:34 <quicksilver> (drop n xs == []) && (length (take n xs) == n)
07:22:45 <ski> peternovice : i was thinking with a class like this, you could have an `instance MonadTransformable (Either e) (EitherT e)', where `exalt :: Monad n a => m a -> EitherT e n a' is your  returnET'  operation
07:22:53 <quicksilver> == [] is fugly, btw
07:22:58 <ski> quicksilver : yes, but then you don't have to check them ..
07:22:59 <YuleAthas> What's a quick and dirty way to get the runtime of a function call in GHC?
07:23:03 <quicksilver> (null (drop n xs)) && (length (take n xs) == n)
07:23:03 <YuleAthas> (GHCi)
07:23:06 <quicksilver> that's better
07:23:25 * Baughn goes nuts trying to make a monad class for ST
07:23:26 <quicksilver> YuleAthas: :set +s
07:23:57 <ski> Baughn : ?
07:23:58 <THC4k> ok thanks, i was curious if there was something neater
07:24:02 <poe> > splitAt 10 [1..4]
07:24:03 <lambdabot>   ([1,2,3,4],[])
07:24:10 <Baughn> ski: Along the lines of monads-tf, but for ST
07:24:20 <ski> `monads-tf' ?
07:24:26 <Baughn> ski: ..mind-expanding. And possibly impossible, but not sure yet.
07:24:28 <ski> (hackage ?)
07:24:30 <Baughn> Yes
07:24:39 <ski> @hackage monads-tf
07:24:40 <lambdabot> http://hackage.haskell.org/package/monads-tf
07:25:26 <YuleAthas> quicksilver: thanks.
07:25:44 <peternovice> ski, thanks,, it seems a bit too complicated for me, I am in the process of trying to learn all this monad business. I guess I will have to think some more about it.
07:26:49 <ski> Baughn : "Along the lines of monads-tf" meaning you want to use type families somewhere ?
07:27:11 <Baughn> ski: No, not really, I just want a working ST class.
07:27:31 <ski> peternovice : ok, then just define your own `exaltET :: Monad m => Either e a -> EitherT e m a' operation
07:27:46 <ski> Baughn : where "working ST class" means ?
07:28:18 <fasta> Baughn, MonadST?
07:28:22 <ski> hm .. a lifting of `ST s' into a class for monads having `ST s' somewhere in them ?
07:28:29 <Baughn> ski: Has a liftST function I can creat instances for for types like ReaderT a ST b.. or whatever that looks like
07:28:32 <Baughn> Right
07:28:36 <fasta> Baughn, (that existed two years ago. )
07:28:41 <Baughn> type AES s a = ReaderT AESCtx (WriterT BL.ByteString (ST s)) a <-- Ah. This.
07:28:58 <Baughn> fasta: Really? Where?
07:29:25 <fasta> Baughn, it has nothing to do with tf, though. I didn't follow your whole question.
07:29:44 <Baughn> fasta: It seems like the sort of class that would belong in monads-tf
07:29:48 <fasta> Baughn, http://www.haskell.org/pipermail/libraries/2003-November/001549.html
07:30:22 <Baughn> fasta: Oh, no no. That's easy. liftST is the hard bit.
07:30:40 <ski> what would `liftST' do ?
07:30:58 <Baughn> liftST :: ST s a -> m a
07:31:05 <Baughn> Probably with an extra s on the right side
07:31:34 <fasta> Baughn, wouldn't that work the same as MonadIO?
07:31:42 <ski> "An r -> m fundep breaks right off the bat with STRef and Lazy/Strict.ST.  With an m -> r fundep, as I have it, it's also broken right off the bat via IO and MVar/IORef*." glad to hear
07:32:00 <Baughn> fasta: Not quite. The s is a problem.
07:32:09 <Baughn> fasta: (And I can't use MonadIO; ST is not IO)
07:32:22 <ski> Baughn : so it would be compareable to `liftIO :: MonadIO m => IO a -> m a', then ?
07:32:32 <Baughn> Yes
07:32:44 <fasta> Baughn, you can hide it with RealWorld as value of s.
07:32:58 <fasta> Baughn, that's what MonadST did, IIRC.
07:33:09 <Baughn> fasta: Then I lose type safety
07:33:15 <ski> really ?
07:33:33 <Baughn> I can't /hide/ the s; that would make it possible to return an STRef from the monad
07:33:44 <ski>   class Monad m => MonadST s m | m -> s
07:33:47 <ski>     where
07:33:51 <ski>   liftST :: ST s a -> m a
07:33:52 <ski> ?
07:34:14 <Baughn> ..no RealWorld there
07:34:24 <ski> (also, itym s/possible/imposible/)
07:34:44 <ski>   instance MonadST s (ST s)
07:34:48 <fasta> Baughn, I think it is named RefMonad.
07:34:59 <ski>   instance MonadST s m => MonadST s (ReaderT r m)
07:35:01 <ski>   &c.
07:35:05 <Baughn> fasta: I need liftST (unsafeIOToST foo) to work
07:35:11 <fasta> Baughn,  http://hackage.haskell.org/packages/archive/TypeCompose/0.6.7/doc/html/Data-RefMonad.html
07:35:34 <fasta> Baughn, oh, never mind. This is something else.
07:35:35 <ski> fasta : `MonadRef' is for abstracting references, not lift from a base monad `ST s'
07:36:49 <fasta> ski: I know.
07:37:31 <fasta> Baughn, anyway, I don't see the problem. There has been a library which does this. You should be able to find it on some search engine.
07:37:56 <Baughn> fasta: The problem is that I don't know how to do it myself. ;)
07:38:01 <fasta> Baughn, it looks somewhat like this:  http://paste.lisp.org/display/34374
07:38:36 <fasta> Baughn, you can also collapse all those instance into one with MonadTrans.
07:38:47 <Baughn> That's the general idea
07:39:18 <fasta> Baughn, but that requires extensions. Most of the time GHC says "you need bla to do that", so you can just use that.
07:39:27 * Baughn is aware.
07:40:19 * ski wonders if it would be nice to split `MonadRef' up a bit
07:40:32 <ski> (i suppose that depends on what laws it has .. which i don't know)
07:42:00 <benmachine> Baughn: is that a general philosophical statement
07:42:18 <Baughn> Would you like it to be?
07:42:31 <benmachine> sure
07:42:43 <quicksilver> ski: quite a lot of laws.
07:43:08 <quicksilver> ski: readRef r >> a === a; writeRef r x >> writeRef r y === writeRef r y; ...
07:43:21 <quicksilver> ski: I think these laws are probably well studied in formal analysis of assignment languages
07:44:06 <ski> but not `writeRef r a >> readRef r  =  writeRef r a >> return a', i suppose ?
07:44:19 <ski> (think concurrency)
07:45:51 * zygoloid ponders "data ST' a = ST' (forall s. ST s a)"
07:46:31 <quicksilver> ski: concurrency isn't part of my view of the semantics of MonadRef
07:46:53 <ski> but it's part of `IO' .. so if `instance MonadRef IORef IO' ..
07:46:59 <quicksilver> ski: in the presence of concurrency it's very hard to have any modular static semantics.
07:47:11 <quicksilver> you can have whole-program static semantics, of course
07:47:18 <quicksilver> but it's hard to make them composable / modular
07:47:24 <ski> *nod*
07:47:33 <quicksilver> which is what the whole separation logic / spatial logic is supposed to be about
07:47:37 <ski> (maybe something like `STM' would be better behaved)
07:47:41 <quicksilver> regaining modularity in a concurrent context.
07:47:57 <ski>   instance MonadState s m => MonadRef (FRef s) m
07:48:09 * ski wants the above to work !
07:48:37 <gbacon> should hasDup (reverse -> (x:xs)) = x `elem` xs trigger a "Pattern match(es) are overlapped" warning?
07:48:45 <ski> (also, `instance MonadReader r m => MonadReadRef (FRef r) m' would be good)
07:49:03 <maurer_> I don't suppose this is likely, but does cabal have any sort of lhs2TeX integration yet?
07:49:06 <gbacon> http://hackage.haskell.org/trac/ghc/ticket/2395 is marked fixed, but this seems to be the same issue
07:49:24 <ski> (where `FRef a b' is a functional reference pointing to a value of type `b' inside any value of type `a')
07:50:22 <ski> (obviously `newRef' works with neither of those instances)
07:51:27 <quicksilver> ski: without newRef that isn't MonadRef in any interesting sense though
07:51:34 <quicksilver> ski: without newRef it is "just" MonadState
07:51:39 <ski> hence
07:51:40 <ski> * ski wonders if it would be nice to split `MonadRef' up a bit
07:51:47 <quicksilver> but there's nothing new to see here
07:51:51 <quicksilver> it just is MonadState
07:52:08 <quicksilver> MonadState s and FRef s r gives you MonadState r
07:52:21 <quicksilver> modulo uniqeuness of instances and newtype wrapping and suchlike
07:52:22 <ski> not necessarily
07:52:25 <quicksilver> but morally at least.
07:55:10 <ski> hm
07:56:19 <dcoutts> maurer_: what would you expect it to do?
07:56:53 <dcoutts> maurer_: if you can describe it precisely then file a feature request
07:57:04 <maurer_> dcoutts: Sure, I'll file one.
07:57:56 <ski> quicksilver : i was thinking i had an example of a `newRef' where the type of the value in the reference was constrained .. but apparently my example wasn't like that
07:59:01 <quicksilver> ski: MonadState [s] gives rise to a kind of constrained newRef for s
07:59:05 <quicksilver> ski: is that the kind of thing you mean?
07:59:20 <zygoloid> is the GHC repository available in a browseable format (webcvs style) somewhere?
07:59:39 <ski> i was thinking of something like `newRef :: forall a. Foo a => a -> m (ref a)'
08:05:21 <pastah_rhymez> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13547#a13547 <-- i would love some input on this; it's for a CLI game (Grid type has lots of more stuff, not shown here)
08:07:21 <pastah_rhymez> think of chess as an example, but in the actual lines that makes up the grids are dynamic here
08:07:40 <pastah_rhymez> (hence all the :: a -> String)
08:09:56 <ski> quicksilver : but i guess one point here would be that it would be nice if `get',&c. had type `MonadState s m => FRef s a -> m a',&c. .. but i suppose one can make those derived operations
08:11:48 <ski> quicksilver : but now we see that we have overlap with `readSTRef :: STRef s a -> ST s a',&c. .. thus we ought to split `MonadRef' into several classes, and merge some of them with the (modified) `MonadReader',`MonadState',&c. classes
08:12:52 <ski> quicksilver : do you see the point ?
08:12:54 <quicksilver> ski: I don't think I agree.
08:13:05 <quicksilver> I mean, I see the commonality but I disagree on the layering.
08:13:16 <quicksilver> readRef can't be broken down further.
08:13:36 <ski> no, but `newRef',`readRef',`writeRef' can
08:13:56 <quicksilver> given MonadRef m r, and a variable of type Ref r s, you can 'pretend' you have a MonadState s, or a MonadReader s
08:14:11 <quicksilver> (further, if s happens to be a Monoid, even a MonadWriter s)
08:14:35 <quicksilver> you can manifesting that isomorphism in a variety of ways
08:14:41 <quicksilver> although note that "Ref r s" is a type not a class.
08:14:57 <quicksilver> I can declining my verbs wrong like pitr from userfriendly.
08:15:23 <Raynes> pastah_rhymez: I don't like the way you indented gSize in Grid. ._.
08:15:25 <quicksilver> actually the type is just "r s" not "Ref r s"
08:15:28 <Raynes> pastah_rhymez: I hate when people do that. ._.
08:15:30 <ski> ("declinink" ?)
08:15:46 <zygoloid> quicksilver: i think you mean you can declining your verbs incorrect? ;-)
08:15:54 <pastah_rhymez> Raynes: oh yeah, that was exactly the kind of feedback i was looking for
08:16:02 <quicksilver> one way is to give special purpose runFoo methods
08:16:10 <Raynes> pastah_rhymez: ;)
08:16:24 <Raynes> I'm picky about formatting.
08:16:45 <quicksilver> runStateInRefContext :: MonadRef m r => r s -> (forall m . MonadState n s => n a) -> m a
08:16:53 <pastah_rhymez> Raynes: well, it looks better in gvim for me; the "::"s are aligned
08:17:00 <quicksilver> ski: I think maybe that's roughly something you said a while back :)
08:17:01 <pastah_rhymez> as well as "{" and ","
08:17:19 <ski> quicksilver : i'm not sure of that
08:17:23 <quicksilver> but the 2-rank type is probably clumsy in practice.
08:17:25 <Raynes> pastah_rhymez: And that is why I don't use gvim. :o
08:17:42 <ski> (and the `forall m. ' should probably be `forall n. ')
08:17:47 <Raynes> I've always wanted to say that.
08:17:49 <quicksilver> ski: yes ;)
08:18:23 <quicksilver> pastah_rhymez: lining up the :: looks nice and I don't know Raynes is talking about ;)
08:18:23 <ski> quicksilver : so why don't you want to merge these interfaces ?
08:18:36 <pastah_rhymez> quicksilver: thank you :)
08:18:48 <quicksilver> ski: there is an impedance mismatch isn't there?
08:18:52 <pastah_rhymez> but could i get some feedback on the actual code, plz?
08:18:55 <pastah_rhymez> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13547#a13547
08:18:59 <quicksilver> ski: "r s" is a type of kind :: *, not a class
08:19:03 <ski> (quite possibly i'm missing some mismatches, here ..)
08:19:14 <ski> quicksilver : .. and ?
08:19:16 <quicksilver> ski: I don't see how you can merge it with the classes.
08:19:20 * ski doesn't follow
08:19:27 <pastah_rhymez> think 'visualize brd'; 'brd :: Grid (Maybe ChessPiece)'
08:19:36 <Raynes> quicksilver: What are you talking about? Lining up :: looks great, but the paste makes it look as if he's indented the the whole thing after the , in order to match up the ::.
08:19:53 * ski tries to think this through more coherently
08:19:57 <Raynes> Maybe it just rendered wrong in my browser or something.
08:20:07 <pastah_rhymez> Raynes: yeah, probably
08:20:16 <pastah_rhymez> must be all the suckiness you get from not using vim
08:20:24 <quicksilver> Raynes: left-aligned vs right aligned identifier doesn't bother me much, if that's what you mean
08:20:34 <quicksilver> I'd left-align it myself, but I don't feel strongly
08:21:01 <zygoloid> i'd left-align myself, because there are contexts where you can't right-align in haskell and i like to be consistent
08:21:08 <Raynes> pastah_rhymez: Emacs is perfectly fine.
08:21:10 <zygoloid> also because right-aligning is harder to maintain ;-)
08:21:33 <Raynes> So he did right align?
08:21:50 <pastah_rhymez> GODDAMIT
08:22:04 <pastah_rhymez> stop talking about goddamn alignment, PLEASE
08:22:26 * Raynes rests his case.
08:22:34 <ski> (also, it's hard to right-align at the first non-whitespace at a line)
08:22:47 <zygoloid> pastah_rhymez: what sort of feedback do you want? :)
08:22:56 <pastah_rhymez> if this is a good class or not
08:23:01 <Raynes> Take it down a level.
08:23:05 <Raynes> <3
08:23:52 <zygoloid> pastah_rhymez: well, i'd call the 11th member 'bottomRight' not 'bottolRight' ;-)
08:24:10 <ski> ok, what i think i'm suggesting is replacing
08:24:26 <ski>   instance MonadReader r (Reader r)
08:24:28 <ski> with
08:24:40 <ski>   instance MonadReadRef (FRef r) (Reader r)
08:24:43 <ski> and
08:24:53 <ski>   instance MonadState s (State s)
08:24:54 <ski>   with
08:24:58 <zygoloid> pastah_rhymez: how many different instances for this class will you have?
08:25:09 <ski>   instance MonadWriteRef (FRef s) (State s)
08:25:12 <pastah_rhymez> zygoloid: just one, for now
08:25:14 <ski> also adding to that
08:25:25 <ski>   insyance MonadRef IORef IO
08:25:27 <ski> and
08:25:37 <ski>   instance MonadRef (STRef s) (ST s)
08:25:46 <ski> (s/insyance/instance/)
08:27:04 <zygoloid> pastah_rhymez: i'm not sure i'd use a class at all until i had good reason to think i needed one.
08:27:13 <ski> where `MonadReadRef ref m' contains `readRef :: ref a -> m a', `MonadWriteRef ref m' also contains `writeRef :: ref a -> a -> m ()', `MonadRef ref m' also contains `newRef :: a -> m (ref a)'
08:27:22 <ski> quicksilver : see what i'm suggesting ?
08:27:47 <zygoloid> pastah_rhymez: i'm also not sure that the type of the contained element is the right way to parameterize the visual style
08:27:47 <ski> (`readRef' and `writeRef' could be called `get' and `set', if you prefer)
08:28:18 <pastah_rhymez> zygoloid: do you have any other ideas?
08:28:25 <ski> (and `MonadReadRef ref m' should also contain `localRef :: ref a -> (a -> a) -> m b -> m b')
08:28:58 <pastah_rhymez> maybe i could make a type 'GridVisualizer' which i can pair with a grid when generating my [String]?
08:29:09 <pastah_rhymez> zygoloid: would that be a better interface?
08:29:59 <ski> (and probably also adding shortcuts to `MonadReadRef (FRef a) m => m a' (the old `get'/`ask'), &c.)
08:30:31 <zygoloid> pastah_rhymez: you could start by writing out the visualize function, and leave generalizing it until you know how you want it generalized.
08:30:51 <pastah_rhymez> zygoloid: probably a good idea :)
08:31:27 <pastah_rhymez> though i did that a while back and the function was like 30+ lines and MESSY
08:32:07 <pastah_rhymez> ah well, i'm smarter now :)
08:32:48 <ski> hm .. one "problem" i can see is that we probably don't want `m -> ref' on `MonadRef ref m' (and friends), while the `m -> r'/`m -> s' FD on `MonadReader r m'/`MonadState r m' seems to be relied upon sometimes
08:32:49 <zygoloid> don't be afraid to factor out any pieces of it which you can sensibly give a name to :)
08:32:53 <ezyang> Is there any more recent haskell-cafe dicussion on error handling than this: http://article.gmane.org/gmane.comp.lang.haskell.libraries/6382 ?
08:32:57 * ski wonders whether this would actually be a problem
08:33:46 <seanmcl> is there some obvious reason why (, 5) can't be a section when ( ++ [5]), ( : [5]) etc. can be
08:34:44 <ToRA> seanmcl: in ghc 6.12 it is legal
08:34:49 <ToRA> ghc-6.12.0.20091007 -XTupleSections -e '(,5) 4'
08:34:50 <ToRA> (4,5)
08:35:13 <seanmcl> oh, good.  Thanks!
08:36:06 <pastah_rhymez> ezyang: haha, i want an OutOfCheese error :)
08:36:21 <ezyang> DivideByCucumber?
08:36:22 * pastah_rhymez trys to think of ways to implement this in his project
08:36:28 <ezyang> oh man, we have a Discworld fan
08:36:49 <ski> seanmcl : anyway, `,' is not really an operator .. `TupleSections' was added to make tuple constructors more like operators, though
08:37:19 <seanmcl> ski: but ':' is a constructor isn't it?
08:37:26 <seanmcl> I don't see the difference
08:37:29 <quicksilver> ski: *nod* I do see what you mean, and it's not what I thought you meant.
08:37:42 <quicksilver> ski: where I think it gets fiddly is relating that to Reader/State
08:37:47 <quicksilver> ski: due to the type/class dichotomy
08:37:52 <quicksilver> (or explicit/implicit dictionary)
08:38:02 <derde> > 1+2
08:38:03 <lambdabot>   3
08:38:20 <ski> > Node {rootLabel = 1,subForest = []}  -- the `,' here doesn't construct a tuple !
08:38:21 <lambdabot>   Node {rootLabel = 1, subForest = []}
08:38:24 <derde> > map (+1) [1..5]
08:38:25 <lambdabot>   [2,3,4,5,6]
08:39:02 <quicksilver> > let x,y :: Int; x = 1; y = 1 in x+y
08:39:03 <lambdabot>   2
08:39:12 <quicksilver> ^^ that , doesn't construct a tuple either!
08:39:30 <osaunders_> > (1,2) -- is a tuple
08:39:31 <lambdabot>   (1,2)
08:39:37 <seanmcl> ok, so comma is overloaded in multiple ways
08:39:43 <quicksilver> yes, comma is syntx.
08:39:58 <ski> quicksilver : maybe i was unclear / misstating my idea before. i don't want to replace or change `Reader' or `State' .. only `MonadReader' and `MonadState'
08:40:07 <osaunders_> Comma separate tuple items and list items.
08:40:11 <osaunders_> And a few other things.
08:40:17 <quicksilver> ski: that's what I meant. I was abbreviated.
08:40:26 <CalJohn> "overloaded" is not quite the right word, though
08:40:46 <quicksilver> ski: the split of MonadRef into Monad{Reader/Writer}Ref I follow, though.
08:40:47 <CalJohn> i think the , in lists is syntatically removed fairly early
08:40:59 <CalJohn> and the , in types is in the type constructor name space
08:41:06 <quicksilver> ski: but the link from MonadReaderRef -> MonadReader is, IMO, less straightforward to encode.
08:41:21 <ski> (quicksilver : i'm still not sure what you mean by "type/class dichotomy" here, and what problem that would indicate)
08:41:50 <ski> quicksilver : the idea was to replace `MonadReader' with `MonadReaderRef'
08:42:03 <quicksilver> ski: readRef :: ref a -> m a , "ref a" is a type
08:42:08 <ski> yes
08:42:21 <quicksilver> get :: MonadReader m a => m a
08:42:27 <quicksilver> MonadReader is a class
08:42:32 <quicksilver> the "ref a" has vanished!
08:42:37 <quicksilver> (its implicit, in the class)
08:42:45 <quicksilver> the MonadReader class has an implicit "ref a"
08:42:53 <quicksilver> (similarly with MonadState)
08:43:04 <quicksilver> readRef allows multiple references
08:43:08 <quicksilver> MonadReader by design, only one.
08:43:20 <quicksilver> hence my rank-2 tom-foolery
08:43:50 <ski> so we go from
08:43:56 <ski>   ask :: MonadReader r m => m a
08:44:02 <ski> to
08:44:10 <ski>   \ref -> liftM (readFRef ref) ask :: MonadReader r m => FRef r a -> m a
08:44:14 <ski> to
08:44:16 * Baughn decides to just make an MonadIO instance for the STs
08:44:17 <ski>   readRef :: MonadReadRef (FRef r) m => FRef r a -> m a
08:44:23 <ski> where that last is generalized to
08:44:32 <ski>   readRef :: MonadReadRef ref m => ref a -> m a
08:44:38 <ski> so that another instance of that is
08:44:52 <ski>   readRef :: MonadReadRef (STRef s) (ST s) => STRef s a -> ST s a
08:45:34 <ski> where `FRef a b' is a functional reference to a value of type `b' in any value of type `a'
08:45:39 <ski> e.g. defined as
08:46:05 <quicksilver> I know what FRef is.
08:46:23 <ski> (ok .. wasn't sure if you recalled it)
08:46:31 <quicksilver> It is never far from my mind.
08:46:58 <jmcarthur_work> i haven't been paying attention, but let me see if i understand this correctly...
08:46:58 <quicksilver> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1058
08:47:09 <quicksilver> ski: (my notion of reference and monadic reference)
08:47:16 <jmcarthur_work> you want to take MonadReader and make it use explicit "references"?
08:47:18 <quicksilver> a laughably incomplete API, it was constructed on-demand.
08:47:33 <ski> so the original `ask' now is `readRef idFRef' .. which could be factored into a new name
08:47:41 <jmcarthur_work> and i assume that for the Reader/ReaderT case there is only one valid reference?
08:47:51 <ski> jmcarthur_work : that's the suggestion, yes
08:47:52 <quicksilver> well a canonical one, at least.
08:47:54 <ski> jmcarthur_work : not at all
08:47:58 <jmcarthur_work> which you are given by the run function
08:48:25 <ski> no
08:48:39 <ski> you give the reference to use to the `readRef' function
08:49:05 <jmcarthur_work> right, but where do you get it in the first place?
08:49:20 <ski> jmcarthur_work : `readRef ref = liftM (readFRef ref) ask' would be how to implement `readRef' for `MonadReader r ref' (in terms of `ask')
08:49:30 <ski>   idFRef :: FRef a a
08:49:35 <ski> is one canonical reference
08:49:45 <ski>   fstFRef :: FRef (a,b) a
08:49:49 <ski>   &c.
08:49:52 <ski> give others
08:51:13 <jmcarthur_work> oh, so this is actually kind of similar to data-accessor-mtl?
08:51:37 <jmcarthur_work> besides the explicit references thing
08:51:37 <ski> yes, `FRef'/`Lens' is similar to `Data.Accessor'
08:52:22 <jmcarthur_work> so FRef is an arrow? or at least a category?
08:52:31 <ski> i believe so, yes
08:53:04 <jmcarthur_work> sounds reasonable enough. something like lenses
08:53:27 <ski> jmcarthur_work : my idea here was to use `FRef' (/ ...) to combine and generalize `MonadReader' and `MonadState' with `MonadRef' (which should then be split)
08:54:18 <ski> hm ..
08:54:26 <ski> i suppose one could also allow instances
08:54:46 <ski>   instance MonadReadRef ((->) r) (Reader r)
08:54:49 <ski> so that
08:54:58 <ski>   asks getFoo
08:55:03 <ski> can also be replaced by
08:55:08 <ski>   readRef getFoo
08:56:06 <fasta> GTK really wants to have users: http://www.gtk.org/mailinglists.html => 404
08:57:06 <quicksilver> jmcarthur_work: category but not array
08:57:09 <fasta> The correct URL is http://www.gtk.org/mailing-lists.html, btw, but their FAQ is wrong.
08:57:21 <quicksilver> ski: I wish I had time to pin down what I don't like about data-accessor
08:57:24 <ski> (and we don't need a new (problematic) corresponding thing for `gets getFoo' since `get',`gets' has been merged with `ask',`asks' into `readRef', which is in `MonadReadRef', and thus doesn't require a read-/write-able reference)
08:57:31 <ski> quicksilver : ditto :)
08:57:38 <quicksilver> ski: so many libraries, so many things wrong with all of them.
08:57:48 <ski> (itym s/array/arrow/)
08:58:18 * hackagebot upload: addLicenseInfo 0.1 - Adds license info to the top of a file. (JoeFredette)
08:58:28 * ski hasn't really looked deeply at `data-accessor', but looking at it always leaves me feeling that things are subtly wrong with it
08:58:41 <ski> (and i suppose that's the reason i haven't looked deeply at it ;)
09:00:05 <ski> (.. hm, i suppose with `instance MonadReadRef ((->) r) (Reader r)', we can simplify `ask' from `readRef idFRef' to `readRef id', which is maybe not so bad ..)
09:00:31 <ski> (and finally, i'm not really married to any of the names of the operations, here)
09:02:00 <quicksilver> jmcarthur_work: although read-only refs are of course arrows, because they are isomorphic to functions.
09:02:09 <quicksilver> jmcarthur_work: but the writable part breaks that arrowness
09:03:16 <ski> `IOReadRef' is an arrow ?
09:03:28 <ski> (i know it can be a functor)
09:04:11 <ski> (defined as `data IOReadRef a = forall x. IORR (IORef x) (x -> a)')
09:04:12 <jmcarthur_work> quicksilver, right
09:04:45 <quicksilver> ski: no, just read-only FRefs are
09:04:53 <quicksilver> ski: IOReadRef isn't the right kind to be an arrow.
09:05:00 <ski> oh
09:05:04 <ski> exactly
09:05:16 <ben> i wish i was the right kind to be an arrow
09:05:22 <ski> (and that's why i suggested `instance MonadReadRef ((->) r) (Reader r)' :)
09:05:50 <ski> (ben : so time could fly like you ?)
09:06:07 <quicksilver> I was I was the right kind to be a banana
09:06:33 <ben> ski: I am getting the impression you are implying some sort of relationship between me and fruit flies.
09:09:48 <ski> ben : just a "double proportionality", i swear !
09:10:11 <ski> (where by "double proportionality" i mean `a0 : a1 :: b0 : b1')
09:11:10 <ski> quicksilver : any specific reason not to `newtype MonadLens m s = MonadLens { unMonadLens :: m (s,s -> m ()) }' ?
09:12:52 * ski has been pondering a not-quite-the-same `newtype FRefM m a b = FRM {unFRM :: a -> m (b,b -> m a)}' type ..
09:14:34 <quicksilver> ski: there was, at least, some reason in my head when I did that
09:14:41 <quicksilver> ski: I wonder if I can remember what it was? ;)
09:15:00 <ski> quicksilver : also, shouldn't `lModify' be defined by `lModify l f s = case unLens l s of (v,v_s) -> v_s (f v)' to take advantage of single-traversal ?
09:15:19 <quicksilver> yes, it should
09:15:23 <quicksilver> that's a bug I was aware of ;)
09:16:19 <quicksilver> you're probably right about MonadLens, yes.
09:18:54 <ski> (`(>.>)' and `(<.>)' should also use `unMonadLens' and `unLens' directly ..)
09:19:47 <ski> (and `withLens' and `withLens_' should obviously do that, when `MonadLens' is changed)
09:20:49 <ski> (not to mention that (>.>)' and `(<.>)' are horrible names for those operations, imo :)
09:21:24 <quicksilver> work in progress, the names
09:21:29 <ski> *nod*
09:22:04 <dzhus> Hello Haskellers. Is there `and` function for tuples?
09:22:19 <poe> ?type uncurry (&&)
09:22:20 <lambdabot> (Bool, Bool) -> Bool
09:22:37 <ski> see also
09:22:40 <ski> @type and
09:22:40 <lambdabot> [Bool] -> Bool
09:22:43 <ski> (that's for lists)
09:22:51 <dzhus> yep, thanks
09:23:06 <sw17ch> > (uncurry (&&)) (True,False)
09:23:06 <lambdabot>   False
09:23:42 <ski> > uncurry (&&) (False,undefined)
09:23:43 <lambdabot>   False
09:23:53 <ski> evening shapr
09:26:10 <gwern> > log(10)
09:26:11 <lambdabot>   2.302585092994046
09:26:14 <gwern> > log(1)
09:26:15 <lambdabot>   0.0
09:27:12 <ski> > log `graph` exp 1
09:27:13 <lambdabot>   (2.718281828459045,1.0)
09:27:45 <gwern> @check \x -> x > log(x)
09:27:46 <lambdabot>   "Falsifiable, after 2 tests:\n-0.5\n"
09:27:57 <gwern> @check \x -> x>=0 && x > log(x)
09:27:57 <lambdabot>   "Falsifiable, after 0 tests:\n-0.25\n"
09:28:15 <gwern> @check \x -> if (x>=0) then ( x > log(x)) else True
09:28:18 <lambdabot>   "OK, passed 500 tests."
09:29:05 <gwern> @hoogle log
09:29:05 <lambdabot> Prelude log :: Floating a => a -> a
09:29:05 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
09:29:05 <lambdabot> Network.CGI logCGI :: MonadIO m => String -> m ()
09:29:17 <ski> @check let infixr 0 ==>; a ==> b = not a || b in \x -> x >= 0 ==> x > log x
09:29:17 <lambdabot>   "OK, passed 500 tests."
09:29:18 <gwern> @check \x -> if (x>=0) then ( x > logBase 2 x) else True
09:29:18 <YuleAthas> Is there a general function for doing this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13550#a13550
09:29:19 <lambdabot>   "OK, passed 500 tests."
09:29:24 <ski> @check \x -> x >= 0 ==> x > log x
09:29:25 <lambdabot>   No instance for (Test.QuickCheck.Testable
09:29:25 <lambdabot>                     (Test.QuickCh...
09:29:39 <gwern> > ln e
09:29:40 <lambdabot>   Not in scope: `ln'
09:29:50 <gwern> :t e
09:29:51 <lambdabot> Expr
09:29:55 <ski> > exp 1
09:29:56 <lambdabot>   2.718281828459045
09:29:59 <gwern> what, we have pi but no e?
09:30:13 <ski> > log `graph` exp 1
09:30:14 <lambdabot>   (2.718281828459045,1.0)
09:30:17 <burp> @let e = exp 1
09:30:18 <lambdabot>  Defined.
09:30:24 * ski grins
09:30:29 <gwern> ~.~
09:30:34 <ski> > e
09:30:35 <lambdabot>   Ambiguous occurrence `e'
09:30:35 <lambdabot>  It could refer to either `L.e', defined at <local...
09:30:35 <gwern> > logBase e e
09:30:36 <lambdabot>   Ambiguous occurrence `e'
09:30:36 <lambdabot>  It could refer to either `L.e', defined at <local...
09:30:38 <burp> damn
09:30:46 <gwern> > logBase (exp 1) (exp 1)
09:30:46 <ski> > logBase L.e L.e
09:30:46 <lambdabot>   1.0
09:30:47 <lambdabot>   1.0
09:31:21 <ski> but `logBase (exp 1) = log'
09:31:55 <gwern> @check \x -> if (x>=0) then ( x >= logBase 2 x) else True
09:31:56 <lambdabot>   "OK, passed 500 tests."
09:32:17 <ski> gwern : see my `(==>)' above
09:32:30 <gwern> yeah yeah but easier to modify my scrollback
09:32:42 <ski> (really there should be a better such with QC, but some some reason i don't understand at the moment, that didn't want to work now)
09:33:22 <ski> ("better" in that when `foo' in `foo ==> bar' fails, that doesn't count as a succeeded test, but rather as a bad testcase)
09:33:39 <ski> (er, s/fails/succeeds/)
09:34:42 <periodic> Hrm, apparently I have to read up more on how haskell parallelizes.  It seems to be surprising me.
09:35:23 <dons> periodic: what method are you using?
09:35:37 <ski> (.. argh, i'm thinking backwards .. that should be "fails", not "succeeds" .. when `foo' is `False', that means the testcase was inadmissible, so then we should generate another testcase (and forget about the present one))
09:35:44 <periodic> I'm iterating over a set of strings which are built by adding a character from each set onto the existing list.
09:35:49 <periodic> I was using parMap.
09:36:00 <poe> I wonder if there is a configuration option for the wiki used for haskell.org so that the RSS doesn't contain unformatted HTML
09:36:05 <periodic> I am printing out the strings as I go (wanted to get an idea of progress because this is taking hours)
09:36:19 <dons> ok. and using the parallel runtime? (+RTS -N4 ...)
09:36:26 <periodic> +RTS -N8
09:36:27 <poe> (...or even a URL-request option.)
09:36:42 <periodic> Basically, I was expecting to see it jumping all over the place as it went.
09:36:51 <dons> periodic: it wlil still depend on what work you're doing inside the map, of course.
09:36:57 <dons> and you're using ghc 6.10.4 or 6.12?
09:36:57 <periodic> because it would do the "a..." strings and the "b..." strings in parallel.
09:37:06 <dons> 6.12 is a /lot/ more efficient with parMap style things
09:37:13 <dons> yeah, should be easy to show that.
09:37:14 <periodic> hrm, I'm on 6.10.
09:37:35 <shapr> hej ski
09:37:37 <periodic> I thought it wasn't parallelizing because the the end character is staying the same in my output.
09:38:00 <periodic> but the CPU usage is up around 300%
09:38:13 <ski> @type \m x c -> fix $ \f -> do l <- m; if l == x then return c else liftM2 g (return l) f
09:38:14 <lambdabot> forall (m :: * -> *) b a1. (Monad m, Eq a1, Show a1, Show b, SimpleReflect.FromExpr b) => m a1 -> a1 -> b -> m b
09:38:26 <ski> @type \g m x c -> fix $ \f -> do l <- m; if l == x then return c else liftM2 g (return l) f
09:38:26 <lambdabot> forall (m :: * -> *) b a1. (Monad m, Eq a1) => (a1 -> b -> b) -> m a1 -> a1 -> b -> m b
09:38:31 <periodic> I was expecting it to interleve strings that were much further appart.  That's all.
09:38:43 <periodic> It might be an artifact of th eway it's doing output.
09:38:55 <periodic> I am doing (hFlush stdout) after each print.
09:39:13 <poe> What wiki engine is used for http://haskell.org/ ?
09:39:15 <periodic> The map is actually just computing a hash.  I sort of forgot part of my password to a system... >_<
09:39:17 <phr> @src join
09:39:17 <lambdabot> join x =  x >>= id
09:39:34 <phr> :t join
09:39:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:39:41 <ski> YuleAthas : why pass `return l' and not just `l' to `g' ?
09:39:46 <periodic> And the system has no other users set up with passwords on it currently, and it doesn't have a CD drive.  BUT I could get the shadow file from another system with the same password.
09:40:16 <Millz> http://notalwaysright.com/out-of-state-out-of-mind/3367
09:40:41 <ski> @type \g m x c -> fix $ \f -> do l <- m; if l == x then return c else liftM2 g l f
09:40:42 <lambdabot> forall (m :: * -> *) b a1. (Monad m, Eq (m a1)) => (a1 -> b -> b) -> m (m a1) -> m a1 -> b -> m b
09:41:12 <EvanCarroll> why can't a function typed with a paramertized signature, accept a member type that doesn't happen to be parameterized
09:41:21 <EvanCarroll> let f :: Maybe[Bool] -> Bool; f a = case a of { Just[True] -> False; Just[False] -> True; _ -> True }
09:41:29 <EvanCarroll> like why do I need Just[] there
09:41:52 <ski> @type \g m c -> fix $ \f -> maybe (return c) (\l -> liftM2 g l f) =<< m
09:41:53 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a -> a) -> m (Maybe (m a1)) -> a -> m a
09:42:22 <EvanCarroll> shouldn't that be a language function done under the hood? or, shouldn't it satisfy a Maybe[Bool], by just being a Bool
09:42:43 <grn> How can I define a recursive list? Something like a_1 = const, a_n = f(a_{n-1}) for n > 1.
09:42:58 <ski> EvanCarroll : are you sure you don't want s/Maybe[Bool]/Maybe Bool/,s/Just[True]/Just True/,s/Just[False]/Just False/, there ?
09:43:26 <ski> @type let f :: Maybe Bool -> Bool; f a = case a of { Just True -> False; Just False -> True; _ -> True } in f
09:43:27 <lambdabot> Maybe Bool -> Bool
09:43:36 <EvanCarroll> ski: No I'm not sure.
09:43:37 <benmachine> grn: iterate is good for that
09:43:41 <benmachine> :t iterate
09:43:42 <lambdabot> forall a. (a -> a) -> a -> [a]
09:44:04 <ski> @type let f :: Maybe Bool -> Bool; f = maybe True not in f  -- EvanCarroll : this does the same as the previous one
09:44:06 <lambdabot> Maybe Bool -> Bool
09:44:17 <grn> benmachine, great! thanks
09:44:21 <EvanCarroll> hrm
09:44:23 <EvanCarroll> maybe that's why
09:44:24 <EvanCarroll> hahah
09:44:45 <EvanCarroll> but why do i still need Just
09:45:23 <ski> EvanCarroll : generally, you don't pass parameters to type( constructor)s in haskell by wrapping them in `[',`]' .. you just pass them with same syntax as function application
09:45:42 <ski> @kind Maybe (Maybe Int)
09:45:43 <lambdabot> *
09:45:47 <ski> @kind Either (Maybe Int)
09:45:48 <lambdabot> * -> *
09:45:51 <ski> @kind Either (Maybe Int) Bool
09:45:52 <lambdabot> *
09:46:39 <periodic> Password recovered!  Yay!
09:46:55 <EvanCarroll> Right, but the question is why does Maybe Bool, not just accept an a regular True, why does it require you to wrap it with Just True, which just says the True supports Nothing, even though it is not nothing
09:47:10 <periodic> That parallel haskell was an order of magnitude faster than the non-parallel, and it only took me 15 minutes to figure out from never having parallelized before.  Thanks Haskell!
09:48:06 <grn> Is it possible to match a touple in a lambda expression? Like \(x y) -> x + y?
09:48:32 <ski> EvanCarroll : one reason is to make you explicitly use `case ... of Just x -> {- ok, use `x' -}; Nothing -> {- handle error case -}' so you don't forget to handle the possible `Nothing' case
09:48:56 <poe> grn indeed, just add a ',' between x and y
09:49:01 <ski> (btw, you don't actually need to use `case ... of ...' .. you can use other helper functions like `maybe' that does that for you)
09:49:09 <ski> @src maybe
09:49:09 <lambdabot> maybe n _ Nothing  = n
09:49:09 <lambdabot> maybe _ f (Just x) = f x
09:49:22 <EvanCarroll> i understand why it has to have the nothing case, I just don't understand why the language has to be explicitly told that a conforming literal has to accept Nothing, even though it isn't Nothing
09:49:50 <dzhus> How to constuct a type for a 4-element list of Bool? Like [Truth, False, False, Truth].
09:49:55 <grn> poe, thank you!
09:50:16 <benmachine> dzhus: use a 4-tuple?
09:50:22 <poe> you're welcome! The shape of the constructors of the datatypes must be matched exactly in the pattern matches, that's all.
09:50:27 <ski> EvanCarroll : another reason is that `Maybe' is not a "special" type in haskell .. it gets treated like any other algebraic data type .. so if they don't get a free implicit `Just' conversion, why should `Maybe' get one ?
09:50:29 <benmachine> or data ListOf4 a = L4 a a a a
09:51:13 <dzhus> benmachine: tuple is a solution indeed
09:51:27 <ski> (so that argument boils down to uniformity of the language)
09:53:48 <ddarius> ski: We could implicitly lift to any monad !
09:55:14 <ddarius> dzhus: Except that we use True instead of Truth, your example is exactly a 4 element list of Bool.
09:55:56 <ski> ddarius : yes .. but *should* we ? :)
09:56:07 <ski> i have nothing against lifting from
09:56:12 <ski>   <expr> :: a
09:56:12 <ski> to
09:56:21 <ski>   <expr> :: a  -- with `m'-side-effects
09:56:23 <ski> but to
09:56:28 <ski>   <expr> :: m a
09:56:29 <ski> ?
09:57:13 <ski> (and i suppose `m' here could be in `Applicative', or even `Pointed')
09:57:48 <sw17ch> This John Earle guy on -cafe is a tad bit hard to follow... never quotes, never provides links, has unbearably huge font...
09:58:07 <EvanCarroll> ski: I guess I don't understand why Just should exist, if something typed with Maybe Foo could accept Foo, without having to explicitly accept a `Just Foo`
09:59:07 <EvanCarroll> If maybe is algebraic then I would expect it to accept two value constructors, so why not just accept Nothing and the Type, like it says, why does it have to accept Nothing and `Just Type`
09:59:30 <ben> Because "Just Type" is a different type than "Type"
09:59:34 <ben> stop making it more confusing :(
09:59:35 <EvanCarroll> but why?
09:59:39 <ski> algebraic data types have constructors for each alternative
09:59:45 <ski> @src Maybe
09:59:45 <lambdabot> data Maybe a = Nothing | Just a
09:59:51 <ski> alternatively defined as
09:59:56 <ski>   data Maybe :: * -> *
09:59:56 <ben> EvanCarroll: Because its type is Maybe a
09:59:57 <ski>     where
10:00:11 <ski>     Nothing ::      Maybe a
10:00:17 <ski>   Just    :: a -> Maybe a
10:00:26 <ski> you can't just remove the name `Just' here
10:00:38 <EvanCarroll> right, so Maybe[Bool] is an enumerated type for Nothing or Bool., Bool already accepts True and False because it is an enumerated type for two values, so Maybe[Bool] accepts Nothing | True | False
10:00:44 <EvanCarroll> Where does Just fit in
10:00:48 <CalJohn> What is the correct event listener to use on an ImageMenuItem in gtk2hs?  I am using onSelect but that seems to crash X...
10:01:00 <mux> EvanCarroll: you meant [Maybe Bool]
10:01:09 <EvanCarroll> yea.
10:01:13 <ski> EvanCarroll : haskell doesn't have sub-typing. it seems you want `a' to be a subtype of `Maybe a'
10:01:14 <EvanCarroll> I did
10:01:15 <EvanCarroll> but still
10:01:18 <ben> Why are we talking about lists
10:01:25 <EvanCarroll> we aren't
10:01:25 <mux> it makes no sense for Maybe a to be equal to a
10:01:27 <EvanCarroll> that was a typo
10:01:29 <benmachine> EvanCarroll: do you want True to be both Bool and Maybe Bool?
10:01:35 <EvanCarroll> right, so Maybe[Bool] is an enumerated type for Nothing or Bool., Bool already accepts True and False because it is an enumerated type for two values, so Maybe Bool accepts Nothing | True | False
10:01:40 <jasonmay> freudian
10:01:41 <EvanCarroll> gah
10:01:47 <EvanCarroll> remove the []s from my thing
10:02:04 <quicksilver> EvanCarroll: so you can write code polymorphic in Maybe a, is one answer.
10:02:13 <quicksilver> so that 'True' has a unique type, is one other answer.
10:02:15 <ski> EvanCarroll : and `Maybe Bool' is not an enumerated tyep for `Nothing' or `Bool' .. it is not an enumerated type at all
10:02:16 <gwern> @quote have.your.baby
10:02:17 <lambdabot> No quotes match. Where did you learn to type?
10:02:19 <sw17ch> quicksilver: yes, that
10:02:21 <mux> also, one of the strength of a Maybe type is that it forces people to check for potential errors
10:02:24 <quicksilver> so that Maybe (Maybe Bool) makes sense, is a third answer.
10:02:26 <ben> but Maybe Bool is Nothing | Just Bool, the Maybe type cannot go and add a varying number of constructors :(
10:02:29 <gwern> @remember Apocalisp You can't have your baby and eat it too
10:02:29 <lambdabot> Good to know.
10:02:32 <ski> @instances Enum
10:02:33 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
10:02:34 <mux> if they could use a Maybe a as an a, it would mean introduce runtime failures
10:02:35 <quicksilver> there are a lot of reasons why the type system choices were made
10:02:38 <gwern> @quote whitespace.sauce
10:02:38 <lambdabot> tensorpudding says: so you boil lisp for an hour to sift out the parentheses and impurities, make a whitespace sauce with liberal syntactic sugar, and you have haskell a la mode
10:02:43 <quicksilver> although they are not the only choices you can imagine.
10:02:45 <mux> and haskell's type system wouldn't be strong
10:02:48 <gwern> @quote seamlessly
10:02:49 <lambdabot> ddarius says: I'm not aware of anything (including C++) that can seamlessly talk to C++ code.
10:02:58 <Cale> EvanCarroll: The (fully-defined) values of type Maybe Bool are  Nothing, Just False, and Just True
10:02:58 <gwern> @quote Data.Data.Data
10:02:58 <lambdabot> ksf says: is Data.Data.Data some kind of reference to swedish chefs?
10:03:01 <ski> (yeah, i know one could define `instance Enum a => Enum (Maybe a)' .. but you can't get that by `deriving Enum')
10:03:08 <gwern> @quote like.shit
10:03:09 <lambdabot> IceDane says: [on escaping an imperative mindset]: <kmc> i recommend heavy drinking <IceDane> I've tried that. I just have fun and wake up and feel like shit the day after. but still think in loops.
10:03:20 <gwern> @quote generated.core
10:03:20 <lambdabot> jpet says: Ok, after studying the generated core a bit, I can conclude that generated core is somewhat hard to follow.
10:03:26 <Cale> EvanCarroll: *Not* Nothing, False, and True.  False and True have type Bool, not Maybe Bool.
10:03:34 <gwern> @quote update.complexity
10:03:34 <lambdabot> Adamant says: [on the update complexity of Data.Map] I read that as "Oleg(n)"
10:03:45 <grn> I have 5000 x 5000 pixels and I'd like to assign a number to every pixel. What's the best way to do it? Is there an alternative to a list of lists?
10:03:45 <EvanCarroll> Cale++
10:03:46 <EvanCarroll> that kind of helps I suppose
10:03:47 <gwern> @quote impure.relations
10:03:47 <lambdabot> skorpan says: I did not have impure relations with that language
10:03:49 <quicksilver> gwern: excuse me, that's quite spammy?
10:03:51 <gwern> @flush
10:04:02 <gwern> quicksilver: spam. spam, spam, spam, delicious spam!
10:04:03 <EvanCarroll> so something that is Just True can not also be True, because they are seperate!
10:04:05 <ski> EvanCarroll : i second "<quicksilver> so that Maybe (Maybe Bool) makes sense, is a third answer."
10:04:06 <benmachine> grn: Data.Array
10:04:19 <EvanCarroll> which makes sense I suppose if we replace Just with NOTJust
10:04:23 <grn> benmachine, thanks
10:04:23 <CalJohn> (solved: it is onActivateLeaf)
10:04:27 <mux> EvanCarroll: you cannot define a "Maybe a" type and then say it's the same as an "a" type -- it's not, and haskell's type system doesn't allow you to mistake one type for another for safety reasons
10:04:34 <zygoloid> grn: you probably want a UArray for something that size.
10:04:53 <zygoloid> grn: list would be good if you can arrange to only need a small amount of the image in memory at a time
10:05:09 <grn> zygoloid, thank you, I'll look at it.
10:05:11 <Cale> EvanCarroll: If it helps, you can think of values of type Maybe t as being a bit like lists of length at most 1 (whose entry, if it exists, has type t)
10:05:13 <mux> EvanCarroll: the way things work, if you have a function returning a Maybe a, callers are forced to check for a potential error
10:05:18 <quicksilver> you can of course make auto-promoting trues and falses if you like. typeclasses allow (indeed, are intended for) that kind of overloading.
10:05:24 * ski wants to know where to learn about this `Oleg(...)' complexity notion !
10:05:33 <EvanCarroll> I jsut think the english of Maybe and Just is extremely confusing way more than it needs to be.
10:05:43 <Cale> EvanCarroll: So, just like the length 1 list [True] is not the same as the value True, the value Just True is again not the same.
10:05:54 <mux> I wish Just was called Some
10:05:57 <EvanCarroll> because Just A, is no different than A, and Maybe A, in every case implies that can accept A
10:06:06 <mux> but I'm OK with Just
10:06:06 <ski> mux : and `None' for `Nothing' ?
10:06:07 <benmachine> mux: implication of plural, arguably
10:06:17 <EvanCarroll> benmachine++
10:06:19 <EvanCarroll> I agree.
10:06:24 <mux> does "Some" really imply plurality? it doesn't seem to me
10:06:30 <quicksilver> class Boolish t where { true :: t; false :: t }. instance Boolish Bool where { true = True; false = False }; instance Boolish (Maybe Bool) where { true = Just True; false = Just False; }
10:06:31 <mux> but I'm not a native english speaker...
10:06:37 <shapr> Ooh, me neither!
10:06:39 <benmachine> it doesn't *necessarily* imply plurality
10:06:53 <EvanCarroll> I think NOTJust is more adaquate, because it implies something more and the difference is explicit.
10:06:59 <benmachine> but it's probably more common in standard English to refer to "some beans" than "some bean"
10:07:00 <mux> benmachine: well then it doesn't seem to imply plurality "more" than Just
10:07:06 <mux> just beans :-)
10:07:12 <FunctorSalad> "Some" implies existential quantification to me
10:07:15 <ski> (shapr : surely you can say whether it's correct in alabamish, at least !?)
10:07:26 <quicksilver> (obEnglish: 'some' has a different meaning, as a kind of indefinite relative, like 'some guy', 'some car', etc )
10:07:37 <FunctorSalad> data Some f = forall x. Some (f x)
10:07:38 <FunctorSalad> :)
10:07:40 <mux> quicksilver: I think there's a Boolean type-class on hackage that allows exactly this
10:07:54 <ski> FunctorSalad : aye
10:07:59 <maltem> quicksilver, which is maybe to be considered colloquial style
10:08:09 <mux> FunctorSalad: isn't that because of SomeException? :-)
10:08:11 <quicksilver> maltem: it sounds colloquial but is, as far as I know, strictly correct.
10:08:28 <ski> (s/Boolish/SubObjectClassifier/ ?)
10:08:29 <quicksilver> maltem: a little archaic in formal usage, maybe.
10:08:44 <quicksilver> ski: that's the dual isn't it?
10:08:55 <Apocalisp> EvanCarroll: Another view of Maybe is the maybe function.
10:08:58 <shapr> ski, jo alabamsk aer inte saa olika
10:09:01 <FunctorSalad> mux: hmm, it matches the plain english `some' too if you read a tycon as a predicate
10:09:04 <Apocalisp> @type maybe --EvanCarroll
10:09:04 <FunctorSalad> "Some List"
10:09:05 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:09:11 <FunctorSalad> (if List a was [a])
10:09:12 <quicksilver> class SubObjectClassifier t where { in :: t -> Bool; }
10:09:15 <maurer_> Is there a way to uninstall a library?
10:09:21 <ski> quicksilver : .. i don't think so ?
10:09:28 <maltem> interesting to have a word that is both colloquial and archaic
10:09:30 <quicksilver> ski: ok you're probably right. I'm sleepy.
10:09:38 <quicksilver> maltem: quite common, in english at least.
10:10:12 <Apocalisp> EvanCarroll: Nothing is precisely the value such that: maybe z f Nothing == z
10:10:14 <ski> the subobject classifier should include `true : T >-> Omega' and `not : Omega >-> Omega', which gives you `false : T >-> Omega' by composition ..
10:10:26 <FunctorSalad> I'm pretty sure Bool isn't a subobject classifier for Hask
10:10:34 <ski> and there should be no general `Omega >-> T + T'
10:10:46 <FunctorSalad> (actually Hask doesn't have pullbacks so s.o.c. isn't even welldefined ;))
10:10:49 <grn> Did someone apply Haskell to web programming?
10:10:53 <Apocalisp> EvanCarroll: Just x is precisely a value such that: maybe z f (Just x) == f x
10:10:57 <ski> (when there is such a one (isomorphism), the sub-object classifier is said to be "boolean" :)
10:11:54 <mux> grn: several people did actually; there's the HAppS framework, the hack framework (iirc like ruby's rack thing), several combinator libraries for generating html/xhtml (moe, xhtml..), and also template libraries (HStringTemplate is nice)
10:11:59 * ski boings on chair
10:12:12 <mux> grn: and I'm missing some
10:12:28 <Apocalisp> EvanCarroll: So if you have a function like (maybe 0 (+1)), then if you apply it to Nothing, you will get 0. If you apply it to Just x, you will get x + 1.
10:12:42 <benmachine> ooh, possible alternative to Just: Only
10:12:52 <benmachine> (not sure there are any advantages though)
10:12:57 <FunctorSalad> ski: I always mix up "boolean" and "two-valued" topoi
10:13:06 <ski> FunctorSalad : probably there's something weaker which the sierpinski space in topology is an instance of, which could possibly be used in haskell, as well
10:13:24 <osfameron> benmachine: I think a name like Actually would make more sense ;-)
10:13:40 <benmachine> heh
10:14:58 <FunctorSalad> ski: how's "not : Ω -> Ω" defined again?
10:15:11 <Cale> Nothing and Just make sense to me as words to use. Just in the sense of "only this"
10:15:35 <osaunders> Mmm fixity declarations.
10:16:19 <osfameron> Cale: it doesn't feel like an "only" thing to me (Nothing feels onlier, so to speak)
10:16:30 <osfameron> but there you go... the concept is lovely whatever it's called
10:16:51 <mux> clearly lovely
10:16:55 <osaunders> osfameron: I think Just is kinda of a weird name too but what would you call it otherwise?
10:17:08 <osaunders> I concluded Just was fine.
10:17:32 <quicksilver> well, None and Some is the other famous choice
10:17:39 <osaunders> Is Maybe a monad?
10:17:39 <quicksilver> as used by ocaml (and SML?)
10:17:46 <osfameron> F# use None/Some too iirc
10:17:51 <mux> what about Maybe a = None | One a ?
10:17:59 <ski> FunctorSalad : actually, now that you mention that, i'm not sure whether i confuse `boolean' and `two-valued' as well
10:18:04 <osaunders> quicksilver: What's the name of that type Maybe still?
10:18:12 <mux> I really like Some, but it's true it makes one think of some extistentially quantified value
10:18:18 <ski> quicksilver : `NONE' and `SOME' in SML, iirc
10:18:24 <benmachine> osaunders: Maybe is a monad yes
10:18:26 <FunctorSalad> ski: one of them was that Ω be isomorphic to 1+1 I think ;)
10:18:32 <oteren> if you have a list of Maybe a's, does that make the list of type Maybe?
10:18:37 <mux> but existential quantification isn't even in haskell 2010 ;-)
10:18:37 <osaunders> benmachine: What makes it a monad?
10:18:45 <quicksilver> osaunders: the type in ML is called 'Option', with the constructors being 'None' and 'Some'
10:18:45 * ski wonders what glyph `Ω' is
10:18:57 <ski> (hm, `\Omega', presumably)
10:18:57 <benmachine> :t flip maybe
10:18:58 <lambdabot> forall a a1. (a1 -> a) -> a -> Maybe a1 -> a
10:18:59 <osfameron> "Option" is vaguer than "Maybe"
10:19:00 <quicksilver> osaunders: (modulo capitalisation being different in those languages)
10:19:03 <benmachine> hmm no
10:19:06 <quicksilver> "Option" is terrible.
10:19:09 <mux> oteren: not really
10:19:11 <quicksilver> "Optional" is quite good though.
10:19:12 <CalJohn> @hoogle IO FilePath
10:19:12 <lambdabot> Did you mean: :: IO FilePath /count=20
10:19:12 <lambdabot> No results found
10:19:21 <CalJohn> ?
10:19:23 <quicksilver> I assume it's an ill-advised way to save typing two characters of Optional ;)
10:19:24 <FunctorSalad> ski: doesn't show up in your font? Omega, yes
10:19:26 <jmcarthur_work> Option sounds like it should be like Either
10:19:28 <benmachine> :t maybe Nothing
10:19:29 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
10:19:30 <CalJohn> @hoogle IO (FilePath)
10:19:30 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
10:19:31 <lambdabot> System.Directory getHomeDirectory :: IO FilePath
10:19:31 <lambdabot> System.Directory getTemporaryDirectory :: IO FilePath
10:19:34 <benmachine> aha
10:19:44 <osaunders> Yeah I think Option is pretty bad.
10:19:51 <mux> Maybe is nice
10:19:52 <benmachine> osaunders: return = Just; (>>=) = flip (maybe Nothing)
10:19:53 <ski> (jmcarthur_work : and `Optionally' ?)
10:20:01 <quicksilver> bear in mind that ML type constructors are read postfix
10:20:07 <quicksilver> so its "int option"
10:20:07 <ski> (or `Optional' ?)
10:20:12 <quicksilver> vs "Maybe Int"
10:20:20 <quicksilver> I still prefer optional.
10:20:23 <mux> OrNot a would be fun.
10:20:34 <jmcarthur_work> i never got that about ML. why are type constructors postfix? is there some theoretical reason?
10:20:38 <osfameron> OrNot = Hot | Not
10:20:39 <mux> OrNot a = TooBad | Yay a
10:20:46 <quicksilver> jmcarthur_work: because of the french
10:20:55 <jmcarthur_work> aha
10:21:14 <jmcarthur_work> natural language influence?
10:21:17 <quicksilver> well mcbride has newtyped maybes for 'Might' and 'Must'
10:21:32 <quicksilver> to distinguish the two natural monoids there
10:21:43 <benmachine> First and Last
10:21:45 <ski> FunctorSalad : given you know how to define the complement of a sub-object, i think it can be defined
10:21:47 <jmcarthur_work> data Perhaps a = Yup a | Nope
10:21:52 <osaunders> Is there anything I can type in GHCi to see the fixity of things?
10:22:04 <quicksilver> IIRC he has some clever sounding combinators leading to a punchline I can't remember.
10:22:07 <quicksilver> osaunders: :i
10:22:10 <mux> osaunders: I think :info shows that, doesn't it?
10:22:18 <quicksilver> jmcarthur_work: data ICanHaz a = UCanHaz a | NoThx
10:22:18 <jmcarthur_work> he does a lot of punchlines with his code
10:22:22 <ski> FunctorSalad : and i think complement could be defined as the largest subobject whose intersection with the input is the empty subobject
10:22:30 <osaunders> quicksilver: Thnx.
10:22:34 * ski ponders how to phrase that in a formula
10:22:38 * benmachine feels guilty for finding that funny
10:22:41 <FunctorSalad> ski: I suppose it's the supremum of all subobjects which have empty intersection with S, but that's not first-order
10:22:50 <ski> FunctorSalad : *nod*
10:22:52 <jmcarthur_work> data CanHaz a = AwsumThx a | OhNoes
10:22:57 <quicksilver> also
10:23:01 <FunctorSalad> (hadn't read your message before sending :))
10:23:08 * ski doesn't have the book with this definition here, atm ..
10:23:18 <quicksilver> data No a = OopsIAccidentallyTheWhole
10:23:23 <mux> hahaha
10:23:29 <jmcarthur_work> lovely
10:23:58 <Apocalisp> quicksilver: data CanHaz a = Haz a | ButIEatedIt
10:24:06 <jmcarthur_work> win
10:24:07 <osaunders> lol
10:24:10 <quicksilver> Apocalisp++
10:24:12 <CalJohn> Is there a way to get the directory of the file that is being executed?
10:24:20 <quicksilver> CalJohn: don't think so, no
10:24:34 <jmcarthur_work> @remember Apocalisp data CanHaz a = Haz a | ButIEatedIt
10:24:34 <lambdabot> Done.
10:24:49 <CalJohn> quicksilver: that would be handy at making glade gtk more portable
10:24:53 <CalJohn> :/
10:24:58 <mux> let's add that to the list of things to add for haskell 2011.
10:25:00 <FunctorSalad> ski: hmm or `false' could be the characteristic function of "void : empty -> 1"
10:25:06 <FunctorSalad> ski: (guessing :))
10:25:13 <jmcarthur_work> mux, you mean lolskell
10:25:23 <mux> {-# EXTENSION LolTypes #-}
10:25:28 <Vulpyne> @hoogle getworkingdirectory
10:25:28 <lambdabot> No results found
10:25:33 <grn> I have a list of numbers and I'd like to convert it to count all its elements by converting it to a mapping: number -> count(number)
10:25:41 <Vulpyne> CalJohn: http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Directory.html#v%3AgetWorkingDirectory
10:25:49 <FunctorSalad> class ThingsICANNHas a
10:25:55 <FunctorSalad> instance ....
10:26:20 <CalJohn> Vulpyne: that's not actually the same thing that I am asking for
10:26:30 <ski> FunctorSalad : er .. that's it, i think :)
10:26:31 <Gracenotes> also System.Directory.getCurrentDirectory :: IO FilePath
10:26:38 <mux> data family LolCat a; data instance CeilingCat; data instance SeriousCat...
10:26:40 <CalJohn> Vulpyne: working directory and the location of the file beinge executed are normally not the same
10:26:56 <CalJohn> for example, konqueror sets the wd to ~ at all times
10:26:57 <Vulpyne> CalJohn: Ah, sorry, I didn't read it correctly.
10:27:05 <benmachine> CalJohn: it's technically possible that the file being executed doesn't have a location
10:27:05 <CalJohn> np :)
10:27:12 <CalJohn> yes, that is also true
10:27:15 <Vulpyne> In would be argv[0] in C, there should be a way to at least get that.
10:27:15 <benmachine> e.g. after a chroot, or an unmount
10:27:17 <benmachine> etc. etc.
10:27:26 <Vulpyne> But yeah, as he said, it's not always accurate.
10:27:29 <Gracenotes> CalJohn: you mean /usr/bin? for ghc? :.
10:27:33 <benmachine> there's no way of getting argv[0] unmolested that I know of
10:27:40 <Cale> grn: I don't think I understand what you're after? The length of the list? Its sum? The function which given n, gives the nth element of the list?
10:27:53 <quicksilver> CalJohn: it's a nasty thing to want (in my opinion) but I'm sure there is a library for finding it.
10:27:57 <Vulpyne> @hoogle getProgName
10:27:57 <lambdabot> System.Environment getProgName :: IO String
10:28:01 <Vulpyne> There you go.
10:28:04 <CalJohn> no, i mean if /home/cal/foo.hs is being run by cal from ~, I want to know /home/cal/foo.hs
10:28:09 <mux> Gracenotes: counting the occurence of each number?
10:28:17 <mux> err, that was for grn.
10:28:18 <quicksilver> CalJohn: http://hackage.haskell.org/package/FindBin
10:28:20 <benmachine> getProgName gives you the last component
10:28:21 <CalJohn> quicksilver: it is a nasty thing to want, but if you want to use glade to write programs, you pretty much need to have it
10:28:22 <Cale> grn: Oh, a function which determines how many times a particular element occurs?
10:28:30 <quicksilver> CalJohn: I think it's immoral and base but there you go ;)
10:28:43 <osaunders> benmachine: That's usually not reason enough not to permit this to be done in other languages.
10:28:44 <mux> that would be map length . group
10:28:46 <Cale> grn: If that's the case, then it's just  length (filter (== n) xs)
10:28:53 <ski> Cale : btw, did you have any comment on my `asTypeIn' ?
10:29:05 <mux> maybe adding . sort
10:29:07 <Cale> ski: I added it, it's a good idea.
10:29:33 <FunctorSalad> asTypeIn?
10:29:33 * osaunders writes so poorly when tired.
10:30:03 <ski> > length `asTypeIn` \length -> length "foo"
10:30:04 <lambdabot>   ""->
10:30:05 <lambdabot>    0
10:30:05 <lambdabot>  "a"->
10:30:05 <lambdabot>    1
10:30:05 <lambdabot>  "aa"->
10:30:06 <lambdabot> [7 @more lines]
10:30:16 <grn> Thats right, but I want to count all the elements in a list.
10:30:23 <FunctorSalad> @ty asTypeIn
10:30:24 <lambdabot> forall a b. a -> (a -> b) -> a
10:30:29 <Cale> :t length `asTypeIn` \length -> length "foo"
10:30:30 <lambdabot> [Char] -> Int
10:30:38 * CalJohn has just come up with a better way to solve his problem, at compile time, with gnu make
10:30:41 <ski> sorry, `@type', yes
10:30:43 <ski> @type (+) `asTypeIn` \(+) -> 4 + (4 :: Integer)
10:30:44 <lambdabot> Integer -> Integer -> Integer
10:30:50 <ski> @type (***) `asTypeIn` \(***) -> id *** id
10:30:51 <lambdabot> forall c c'. (c -> c) -> (c' -> c') -> (c, c') -> (c, c')
10:30:58 <ski> @type (***) `asTypeIn` \(***) -> id *** id `asTypeOf` \_ -> (False,'c')
10:30:59 <lambdabot> (Bool -> Bool) -> (Char -> Char) -> (Bool, Char) -> (Bool, Char)
10:31:09 <ski> > typeOf (undefined `asTypeIn` \x -> ord x)
10:31:10 <lambdabot>   Char
10:31:47 <zygoloid> FunctorSalad: instance ICANNHas ResponsibilityForAssigningIPAddresses ?
10:31:54 <ski> @let asAppliedTo :: (a -> b) -> a -> (a -> b); asAppliedTo f a = f `asTypeIn` ($ a)
10:31:55 <lambdabot>  Defined.
10:31:57 <ski> @type (***) `asAppliedTo` (+ (1 :: Integer))
10:31:58 <lambdabot> forall b' c'. (Integer -> Integer) -> (b' -> c') -> (Integer, b') -> (Integer, c')
10:32:04 <ski> @type loop `asAppliedTo` ((+1) *** (*3))
10:32:05 <lambdabot> forall b d. (Num b, Num d) => ((b, d) -> (b, d)) -> b -> b
10:32:18 <ski> (that's probably enough examples)
10:33:10 <FunctorSalad> zygoloid: ^^ forgot about that
10:33:59 <FunctorSalad> (ICANN was just "the new punny thing which has cheezeburgers" to me)
10:34:04 <FunctorSalad> o_o
10:34:53 <zygoloid> FunctorSalad: http://www.templetons.com/images/icannhas.jpg
10:35:20 <FunctorSalad> zygoloid: there's some comic too but I couldn't refind it
10:35:29 <ski> (an alternative name for `asTypeIn' would be `asUsedIn' or maybe `asTypeUsedIn')
10:38:27 * ski apologizes for scaring away the discussions ..
10:39:00 <quicksilver> ski: `asSeenIn` `fromTVs` `youMayRecogniseMeFrom`
10:39:50 <ski> (quicksilver : "TV" `asUsedIn` "Tanglible Value" ?)
10:41:23 <grn> How to convert an integer to a float?
10:41:55 <ski> @type fromIntegral
10:41:56 <lambdabot> forall a b. (Integral a, Num b) => a -> b
10:45:34 <sw17ch> > fromIntegral 65 :: Double
10:45:34 <lambdabot>   65.0
10:45:41 <sw17ch> > fromIntegral 65 :: Rational
10:45:42 <lambdabot>   65 % 1
10:46:55 <ski> > fromIntegral (65 :: Integer) :: Double  -- just in case :)
10:46:56 <lambdabot>   65.0
10:47:48 <copumpkin> wow, haskell attracts crackpots
10:48:17 <grn> > (take 2 [1..]) ++ (take 2 [1..])
10:48:19 <lambdabot>   [1,2,1,2]
10:48:26 <grn> > group((take 2 [1..]) ++ (take 2 [1..]))
10:48:27 <lambdabot>   [[1],[2],[1],[2]]
10:48:40 <grn> could someone explain me why it works like that?
10:48:48 <zygoloid> > id 65 :: Double
10:48:49 <lambdabot>   65.0
10:48:53 <dons> copumpkin: this guy got drawn in by the 2010 announce.
10:49:01 <zygoloid> wow guys i have a new proof that fromIntegral == id!
10:49:32 <copumpkin> dons: a couple of his monologues to haskell-prime seemed reasonable, but his past few emails on -cafe are ridiculous
10:49:46 <copumpkin> damn, we must avoid success harder!
10:49:56 <dons> copumpkin: challenge: spot how many of this check list for trolls he hits: http://haskell.org/haskellwiki/Protect_the_community/Notes#Identify_poisonous_people
10:50:07 <amuck_> grn: How do you expect it to work?
10:50:19 <grn> > group([1,2,1,2])
10:50:20 <lambdabot>   [[1],[2],[1],[2]]
10:50:31 <sw17ch> copumpkin: my favorite part is the unbearably huge font he uses
10:50:36 <copumpkin> yeah, lol
10:50:44 <dons> sw17ch: oh? (i use a terminal)
10:50:50 <dons> so you see his markup?
10:50:52 <copumpkin> his html email is in a huge font
10:50:58 <dons> mwhaha
10:51:06 <sw17ch> dons: yeah, gmail renders it with size 24 or 32 font or something huge
10:51:08 <dons> i should add that to the list.
10:51:11 <dons> uses font size > 16.
10:51:15 <sw17ch> hah
10:51:38 <sw17ch> also, i can't ever figure out his context. he just starts rambling in response to _something_, but I can't tell what.
10:51:41 <copumpkin> http://snapplr.com/edcr
10:51:47 <sw17ch> he doesn't quote, or reference people, or provide links....
10:52:02 <copumpkin> I love the arrogance of "I'll let you figure it out on your own, it'll be more instructive"
10:52:11 <grn> amuck, I get it, I missed the info that it groups adjecent elements, thanks. How can I group non-adjecent elements?
10:52:22 <sw17ch> copumpkin:  :)
10:52:26 <zygoloid> grn: you could sort first
10:52:45 <BONUS> lol, overuses capital letters
10:52:57 <sw17ch> i like how OCaml being French seemed to have some sort of weight to his argument
10:53:00 <dons> easy trolls are easy
10:53:20 <dons> PLEASE TREAT THIS BUSINESS PROPOSITION WITH UTMOST CONFIDENTIALITY.
10:53:27 <ski> @check \x -> id x == fromIntegral x
10:53:28 <lambdabot>   "OK, passed 500 tests."
10:53:29 <ski> zygoloid : ^
10:53:41 <dons> maybe it is a parody
10:53:43 <zygoloid> ski: see, thought so :)
10:53:51 <dons> are there really trolls that aren't self aware?
10:53:53 <ski> (only checked for `Integer', though)
10:53:57 <sw17ch> dons: this one isn't
10:54:06 * sw17ch wanders away to a meeting...
10:54:52 <BONUS> speaking of cafe, i was thinking of posting my concerns regarding local let binding monomorphism and GHCi
10:55:07 <grn> but how can I count elements w/o sorting? My list is quite big.
10:55:22 <copumpkin> fold a Map.insertWith
10:55:24 <BONUS> anyone know if this has already been discussed?
10:55:30 <copumpkin> or fromListWith
10:55:37 <dons> BONUS: btw, ... status of LYAH?
10:56:14 <BONUS> dons, hey! working with editors now
10:56:15 * dons was idly pondering right a LYA-Parallel Haskell, and having BONUS do the illustrations...
10:56:36 <BONUS> and also writing the forward chapters, although they're not ready to be put up on the web
10:56:39 <BONUS> haha
10:56:40 <dons> excellent.
10:56:57 <BONUS> should be out soon!
10:57:01 <ski> (what's this with "unbearably huge font he uses" ? every message is displayed with the font and size *I* choose ! ;)
10:57:06 <dons> one of my 2010 goals is to do a multi-part series on parallel haskell. i could imagine it becoming a LYAH-style thing
10:57:11 <dons> maybe we should do it as a joint project :)
10:57:15 <BONUS> haha, awesome!
10:57:22 <BONUS> i'd gladly provide illustrations and any help
10:57:33 <dons> cool! ok, i will think more about this and contact you
10:57:37 <BONUS> cool
10:58:17 <BONUS> btw, dons, do you know anything about mtl being deprecated or something like that?
10:58:26 <BONUS> heard it here, but i was unable to find more info
10:59:04 <dons> mtl is kinda deprecated in favour of transformers or monadLib.
10:59:04 <dcolish> so phooey seems to be broken because Data.Reactive is now laid out differently. Whats the best approach to updating the package? Just change the functions and hack on it til it works?
10:59:19 <dcolish> s/functions/imports/
10:59:36 <BONUS> ah. i'm gonna start writing the monad transformers chapter of LYAH soon and was wondering
10:59:58 <BONUS> should probably write about mtl, yeah?
11:00:42 <ski> grn : i'm not sure how to count elements (not counting equal occurances more than once) without sorting or worse ..
11:01:30 <ski> (if you only have `Eq', you can compare every element with every other element, which is worse than sorting, but may be the only option you have in some circumstances, i think)
11:01:52 <burp> set + length?
11:02:15 <ski> i'd assume that is comparable to sorting
11:02:33 <burp> well, you don't need to sort in that case
11:02:38 <YuleAthas> Does anyone here have CHP experience?  What's your strategy for having several processes that produce console output?
11:02:39 <burp> I can imagine it's a bit better
11:02:49 <burp> O(n*min(n,W)). Create a set from a list of integers.
11:02:57 <int-e> ski: yep, an adversary can arrange things such that the last of C(n,2) pairs you compare for equality will be the only equal pair in the whole set.
11:02:58 <ski> hm .. maybe somewhat better, yes
11:03:14 <burp> what's W?
11:03:23 * ski doesn't know
11:03:44 <Baughn> Wait, wait, MonadLib too?
11:03:52 <Baughn> There are too many transform libraries! ;_;
11:05:46 <ski> Baughn(,BONUS) : don't forget `monads-tf' :)
11:05:53 <BONUS> aghh!!
11:06:36 * ski idly ponders to create a new monad transformer library ..
11:06:58 <ToRA> also monads-fd
11:07:14 <Baughn> ski: monads-tf is what I usually use
11:07:20 <EvanCarroll> BONUS: did you get my pvmsg?
11:08:49 <BONUS> oh yeah! i did! thanks for the info!
11:08:51 <Baughn> ski: I think we need to pick one and stuff it in the haskell-platform. :/
11:09:07 <BONUS> i'm gathering all the corrections and am going to put them up, just a bit swamped now :)
11:10:09 <ski> Baughn : not until after we've determined which is the best, i hope ..
11:11:11 <ski> (and by "best" i mean that we're reasonably sure it's the best possible, with the current type system, not just the best of the available options submitted so far)
11:16:48 <grn> how to access pixels directly in sdl?
11:16:57 <grn> I'm talking about Haskell bindings of course.
11:17:04 <copumpkin> unsafeGetPixelsNao
11:17:17 <ezyang> What are people's experiences getting monads from different libraries to interoperate?
11:17:30 <ezyang> (as in one library uses mtl, another uses transformers, etc.)
11:17:38 <copumpkin> oh, ew
11:19:11 <Berengal> ezyang: Nifty trick for just such occations: import "mtl" Control.Monad.Whatever; import "transformers" Control.Monad.Whatever
11:19:50 <Vulpyne> I haven't seen that syntax before. Is it equivalent to import qualified Control.Monad.Whatever as Transformers ?
11:19:52 <ezyang> Oh man XPackageImports
11:20:02 <copumpkin> Vulpyne: it allows you to specify the package
11:20:09 <copumpkin> from which to import the module
11:20:10 <Vulpyne> Ah, I see.
11:21:11 <Berengal> When I found out about it, a dark cloud that had been hanging over me for months finally lifted
11:21:57 <ezyang> I'm still really confused by the mtl/transformers/monadLib situation
11:22:08 <ezyang> I think PackageImports makes it possible to interoperate with some care
11:22:20 <ski> /monads-fd/monads-tf
11:22:32 * ezyang is reading the "transformers versus mtl" thread 
11:22:52 <Zao> More than meets the eye?
11:23:57 * Berengal points out that there are no "Applicative Transformers"
11:24:52 <ezyang> huh, none of these alternative monad libraries fix the Monad typeclass issue
11:24:55 <ezyang> sadface.
11:25:13 <ben> Monad typeclass issue? As in, not having 'fail'?
11:25:15 <Berengal> Which Monad type class issue?
11:25:24 <ezyang> hah, "which"
11:25:54 <ezyang> I think my main issue is the Lack of Functor => Applicative => Monad (I don't care too much about pointed)
11:25:57 <copumpkin> unfortunately in haskell you can't retroactively change a class
11:26:08 <copumpkin> and none of the monad libs provide alternate Monad classes
11:26:13 <copumpkin> just transformers on the standard one
11:26:15 <ben> You cannot?
11:26:22 <ezyang> yeah...
11:26:22 <copumpkin> short of changing the code
11:26:26 <Berengal> That's because an alternative Monad class would require an alternative Prelude
11:26:46 <ben> Can you talk 'do' into translating into >>= for another Monad class?
11:26:52 <ski> quicksilver : i think your `(>.>)' operation is probably good, though .. we want to be able to combine `STRef s a' / `STReadRef s a' (/ `MonadLens m a') with `a -> b' / `FRef a b' (/ `Kleisli m a b' ? (/ `FRefM m a b' ??)) into `STReadRef s a' (/ `STReadRefM s a' ??)
11:27:42 <Berengal> ben: Yes, with -XNoImplicitPrelude
11:27:44 <ski> ben : istrs
11:28:34 <Veinor> ezyang: oh hey there
11:28:38 <copumpkin> it doesn't even have to be a Monad clas
11:28:42 <ezyang> Veinor: yo
11:28:49 <Veinor> it's phurst
11:29:02 <ezyang> aha! Hello from LINERVA
11:29:05 <copumpkin> Veinor: you just gave away your identity
11:29:07 <copumpkin> ZOMG
11:29:09 <Veinor> oh no!
11:29:13 <Berengal> "do" is just syntactic sugar, as evidenced by it being desugared before anything else (important) happens during compilation
11:29:20 <EvanCarroll> how would you generate a list of a 100 3 digit long 0 padded string representation of 0..100
11:29:44 * Badger heads off to dartmouth's cs dept.
11:29:45 <ben> map (printf "%03d") [0..100]
11:29:53 <copumpkin> Badger: I don't make a secret of it :P
11:30:00 <ben> :: [String] I guess
11:30:23 <Badger> copumpkin: lies! you pretend to be a vegetable to fool us all!
11:30:26 <copumpkin> lol
11:30:27 <EvanCarroll> so printf is working as sprintf?
11:30:33 <copumpkin> EvanCarroll: yep
11:30:38 <Berengal> > take 100 . tail $ [[x,y,z] | x <- ['0','1'], y <- ['0'..'9'], z <- ['0'..'9']]
11:30:39 <lambdabot>   ["001","002","003","004","005","006","007","008","009","010","011","012","0...
11:30:44 <copumpkin> EvanCarroll: tis magick
11:30:46 <EvanCarroll> that's confusing
11:30:51 <FunctorSalad> Berengal: before typechegging?
11:30:57 <copumpkin> Berengal: wonderful
11:31:03 <Berengal> FunctorSalad: Yup
11:31:03 <Fredderf> @pl (\s -> s == reverse s)
11:31:04 <lambdabot> ap (==) reverse
11:31:09 <ben> EvanCarroll: It just figures out whether you want a String or an IO () by looking at type inference.
11:31:12 <Fredderf> :t app
11:31:12 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
11:31:14 <FunctorSalad> Berengal: ah, thought all desugaring was after it
11:31:19 <FunctorSalad> "do" is special?
11:31:20 <copumpkin> Fredderf: very different
11:31:25 <copumpkin> Fredderf: it said ap, not app :P
11:31:30 <Fredderf> :t ap
11:31:30 <EvanCarroll> ben what do i import to get printf?
11:31:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:31:33 <Berengal> FunctorSalad: This means you don't even need (>>=) and return in the same class... nor fail
11:31:36 <ben> Text.Printf
11:31:38 <ski> @index printf
11:31:38 <lambdabot> Text.Printf
11:31:44 <Veinor> I was thinking
11:32:10 <Fredderf> I don't understand ap at all :)
11:32:14 <copumpkin> ezyang, Veinor: y'all'd better be at the next boston HUG! :P
11:32:18 <Fredderf> guess it requires understanding of Monads
11:32:23 <Veinor> > let digits = ['0'..'9'] in zipWith4 (:) digits digits digits (repeat [[]])
11:32:24 <lambdabot>   Couldn't match expected type `c -> d -> e'
11:32:24 <lambdabot>         against inferred type `[...
11:32:28 <Veinor> bah :(
11:32:34 <EvanCarroll> i think Berengal wins
11:32:36 <EvanCarroll> I like his solution
11:32:39 <copumpkin> Fredderf: somewhat :) although Applicatives work just fine too
11:32:45 <Veinor> there's yeah, but list comprehensions are... eh.
11:32:46 <ski> Fredderf : liftM3 f ma mb mc = return f `ap` ma `ap` mb `ap` mc
11:32:53 <ezyang> I totaly came to the October one, but was too hosed for November
11:32:56 <Veinor> oh yeah, you want liftM3 too
11:33:02 <copumpkin> ezyang: damn! I missed that one
11:33:03 <Berengal> :)
11:33:36 <Fredderf> :t app (==) reverse
11:33:36 <lambdabot>     Couldn't match expected type `a -> a -> Bool'
11:33:37 <lambdabot>            against inferred type `(b -> c, b)'
11:33:37 <lambdabot>     Probable cause: `app' is applied to too many arguments
11:33:40 <copumpkin> not app :P
11:33:43 <Fredderf> :t ap (==) reverse
11:33:44 <lambdabot> forall a. (Eq a) => [a] -> Bool
11:33:44 <Fredderf> LOL
11:34:08 <ezyang> copumpkin: dang!
11:34:17 <ski> Fredderf : that's in `Monad (r ->)', which may be somewhat confusing, if you don't know what's going on
11:34:18 <Berengal> > take 100 . tail . replicateM 3 $ ['0'..'9']
11:34:19 <lambdabot>   ["001","002","003","004","005","006","007","008","009","010","011","012","0...
11:34:28 <copumpkin> Berengal: there, much better
11:34:50 <copumpkin> > map read . take 100 . tail . replicateM 3 $ ['0'..'9'] :: [Int] -- tada!
11:34:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:34:51 <ski> Fredderf : basically `ap (==) reverse  =  \x -> ((==) x) (reverse x)  =  x == reverse x'
11:35:08 <Berengal> > [1..]
11:35:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:35:10 <Berengal> ;)
11:35:12 <copumpkin> nope!
11:35:15 <copumpkin> mine is cooler
11:35:21 <ski> (Fredderf : in the `(r ->)' `Monad' that is .. it can also be used in other monads)
11:35:22 <Berengal> Mine's faster
11:35:28 <copumpkin> yeah but mine is cooler
11:35:31 <copumpkin> and cool > fast
11:35:47 <asdioajsdoiajsd> what would lamdabot do if i let it run an infinite loop?
11:35:54 <ski> try
11:35:56 <ski> > fix id
11:35:57 <Berengal> > last [1..]
11:35:59 <lambdabot>   mueval-core: Time limit exceeded
11:36:01 <lambdabot>   mueval-core: Time limit exceeded
11:36:03 <FunctorSalad> rlimit
11:36:06 <asdioajsdoiajsd> until (== 0) (+1) 1
11:36:16 <copumpkin> needs moar "> "
11:36:23 <ski> > let x = x in x  -- as well ..
11:36:26 <lambdabot>   mueval-core: Time limit exceeded
11:36:34 <copumpkin> > until (== 0) (+1) 1
11:36:38 <lambdabot>   mueval-core: Time limit exceeded
11:36:44 * copumpkin strokes lambdabot 
11:36:47 <asdioajsdoiajsd> xD
11:37:04 <Berengal> > forever $ do Just Nothing
11:37:08 <lambdabot>   mueval-core: Time limit exceeded
11:37:13 <copumpkin> showoff
11:37:21 <ski> > let x = 1+x in x  -- this
11:37:23 <Berengal> > forever $ do Nothing -- However, haskell being lazy...
11:37:24 <lambdabot>   Nothing
11:37:25 <lambdabot>   mueval-core: Time limit exceeded
11:37:30 <ski> > let x = 1+x in x > (3 :: Natural) -- .. and this
11:37:31 <lambdabot>   True
11:37:40 <Veinor> :t forever
11:37:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
11:37:41 <copumpkin> now switch that to x + 1
11:37:51 <copumpkin> > let x = x + 1 in x > (3 :: Natural) -- .. and this
11:37:55 <lambdabot>   mueval-core: Time limit exceeded
11:37:57 <copumpkin> zomg
11:38:01 <copumpkin> need moar unamb
11:38:10 <ski> copumpkin : that's what i did first (not being able to remember which order it does) :)
11:38:19 <Veinor> > forever $ []
11:38:20 <lambdabot>   []
11:38:22 <Veinor> :o
11:38:26 <FunctorSalad> heh
11:38:31 <copumpkin> :)
11:38:42 <Fredderf> let foo = ap (==) reverse in foo "abcba"
11:38:43 <FunctorSalad> @src forever
11:38:44 <lambdabot> Source not found. Take a stress pill and think things over.
11:38:50 <Fredderf> > let foo = ap (==) reverse in foo "abcba"
11:38:51 <lambdabot>   True
11:38:54 <FunctorSalad> FFFFFFFFFFFFFFFFFFUUUUUUUUUUU I don't need to stress pills
11:38:57 <FunctorSalad> ;)
11:39:12 <Berengal> forever m = m >> forever m
11:39:20 <Badger> you could strain the pills, though
11:39:28 <shachaf> @pl forever m = m >> forever m
11:39:28 <lambdabot> forever = fix (ap (>>))
11:39:30 <Badger> you'd probably end up with a homeopathic remedy
11:39:45 <ski>   forever = fix . (>>)
11:39:45 <FunctorSalad> (I guess that was 'rage' pills though)
11:39:54 <Fredderf> that ap thingy doesnt work in ghci
11:39:55 <Fredderf> Prelude> :m Control.Monad
11:39:55 <Fredderf> Prelude Control.Monad> let foo = ap (==) reverse in foo "abcba"
11:39:55 <Fredderf> <interactive>:1:10:
11:39:55 <Fredderf>     No instance for (Monad ((->) [Char]))
11:39:55 <Fredderf>       arising from a use of `ap' at <interactive>:1:10-24
11:39:56 <Fredderf>     Possible fix: add an instance declaration for (Monad ((->) [Char]))
11:39:58 <Fredderf>     In the expression: ap (==) reverse
11:40:00 <Fredderf>     In the definition of `foo': foo = ap (==) reverse
11:40:02 <copumpkin> > concat [repeat 'F', repeat 'U']
11:40:02 <Fredderf>     In the expression: let foo = ap (==) reverse in foo "abcba"
11:40:03 <lambdabot>   "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...
11:40:05 <Fredderf> Prelude Control.Monad>
11:40:06 <Fredderf> whats going on there?
11:40:12 <Berengal> Fredderf: import Control.Monad.Instances
11:40:16 <Veinor> copumpkin: it has omega Fs and then omega Us ;)
11:40:20 <gbacon> should hasDup (reverse -> (x:xs)) = x `elem` xs trigger a "Pattern match(es) are overlapped" warning?
11:40:30 <ski> (Fredderf : or `Control.Monad.Reader', iirc)
11:40:39 <FunctorSalad> forever Nothing === Nothing >> forever Nothing === Nothing
11:40:40 <Berengal> Or Control.Applicative, or Control.Arrow
11:40:47 <asdioajsdoiajsd> :t concat
11:40:48 <lambdabot> forall a. [[a]] -> [a]
11:40:52 <Berengal> It's almost impossible to not bump into Monad (-> r)
11:40:57 <copumpkin> Veinor: thus we must interleave them!
11:41:05 <asdioajsdoiajsd> :t concat.concat.concat
11:41:06 <lambdabot> forall a. [[[[a]]]] -> [a]
11:41:09 <ski> Berengal s/(-> r)/(r ->)/
11:41:12 <asdioajsdoiajsd> i see what they did thar..
11:41:15 <copumpkin> > concat . transpose [repeat 'F', repeat 'U']
11:41:16 <lambdabot>   Couldn't match expected type `[a]'
11:41:16 <lambdabot>         against inferred type `GHC.Types...
11:41:19 <copumpkin> > concat . transpose $ [repeat 'F', repeat 'U']
11:41:20 <lambdabot>   "FUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFU...
11:41:26 <ski> (or at least s/(-> r)/((->) r)/, if you insist ..)
11:41:29 <Berengal> ski: s/->/(->)/ actually
11:42:01 <asdioajsdoiajsd> > concat [[1,2][3,4]]
11:42:02 <lambdabot>   Couldn't match expected type `t -> [a]'
11:42:02 <lambdabot>         against inferred type `[a1]'
11:42:22 <asdioajsdoiajsd> > concat [[1,2],[3,4]]
11:42:23 <lambdabot>   [1,2,3,4]
11:42:28 <Berengal> Wow, that was a surprisingly bad error
11:42:54 <ski> > repeat 'F' /\/ repeat 'U'
11:42:55 <lambdabot>   "FUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFU...
11:43:09 <Veinor> why /\/?
11:43:14 <ski> why not ?
11:43:14 <copumpkin> #ty each
11:43:20 <lunabot>  forall a . [] a -> Omega a
11:43:28 <Fredderf> If I import Control.Monad and Control.Monad.Instances and Control.Monad.Reader, I get the following error:
11:43:29 <Fredderf>     Ambiguous type variable `a' in the constraint:
11:43:29 <Fredderf>       `Eq a' arising from a use of `==' at D:\code\test.hs:5:9-12
11:43:29 <Fredderf>     Possible cause: the monomorphism restriction applied to the following:
11:43:29 <Fredderf>       foo :: [a] -> Bool (bound at D:\code\test.hs:5:0)
11:43:29 <Fredderf>     Probable fix: give these definition(s) an explicit type signature
11:43:30 <Fredderf>                   or use -XNoMonomorphismRestriction
11:43:32 <ray> > let rage n = (take n $ repeat 'F') ++ (take n $ repeat 'U') in map rage [1..]
11:43:32 <Fredderf> Failed, modules loaded: none.
11:43:33 <lambdabot>   ["FU","FFUU","FFFUUU","FFFFUUUU","FFFFFUUUUU","FFFFFFUUUUUU","FFFFFFFUUUUUU...
11:43:36 <ski> i've seen it used for "interleave" somewhere
11:43:39 <copumpkin> Fredderf: @hpaste
11:43:42 <ray> the last element of that list is what you want
11:43:42 <FunctorSalad> anyone else used F and U for adjoint functors in their CT lectures?
11:43:54 <copumpkin> lol
11:43:54 <ski> @hpaste
11:43:54 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:43:58 <FunctorSalad> you end up with FUFUFU when making the monad of the adjunction, seriously we did
11:44:13 <mwc> FunctorSalad: would have been a good lecture
11:44:13 <ray> ふふふ
11:44:19 <ski> FunctorSalad : i've seen it used in books (and probably papers, as well), at least
11:44:23 <Veinor> ray: take n $ repeat 'F' is better knowns as replicate n 'F' :P
11:44:28 <__ent__> hi
11:44:34 <asdioajsdoiajsd> > 10.0 / 6.0
11:44:35 <lambdabot>   1.6666666666666667
11:44:38 <mwc> I need to come up with a good trojan for laplace transforms
11:44:53 <Veinor> what?
11:44:54 <ski> @src replicate
11:44:55 <lambdabot> replicate n x = take n (repeat x)
11:45:00 <copumpkin> mwc: trojan her pleasure?
11:45:06 <__ent__> is here somebody who can help me with linking on windows please?
11:45:10 <Fredderf> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5254#a5254
11:45:48 <dschoepe> Fredderf: {-# LANGUAGE NoMonomorphismRestriction #-} would solve that
11:45:55 <dschoepe> or specifying a type signature
11:46:04 <ski> or eta-expanding
11:46:12 <Veinor> trojan is a horrible name for a condom
11:46:13 <mwc> copumpkin: I mean, an example with an amusing result
11:46:21 <mwc> like FUFUFU in the adjunction
11:46:22 <Veinor> you think it's safe so you let it in, then it opens up and lots of little men invade you :(
11:46:34 <Vulpyne> On the plus side, it has an association with horses.
11:46:50 <mwc> but on the downside, an association with greeks
11:46:53 <mwc> (I kid, I kid)
11:46:54 <Berengal> Horses of wood, no less...
11:47:47 <mwc> Well, I'd say we're completely OT
11:47:49 <__ent__> does anybody here use HDBC-sqlite3 on windows?
11:47:55 <asdioajsdoiajsd> Veinor, are STDs like worms then? You don't know you got infected, but you spread the infection whenever you can?
11:48:08 <korre> so anyone feel like helping me with a typeclass
11:48:17 <Veinor> :O
11:48:27 <Twey> Veinor: Haha, it's true
11:48:33 <Twey> I'd never thought about that before
11:49:06 <Berengal> korre: Tell us your troubles
11:50:29 <asdioajsdoiajsd> :t inverse
11:50:30 <lambdabot> Not in scope: `inverse'
11:51:10 <__ent__> :t 1
11:51:12 <lambdabot> forall t. (Num t) => t
11:51:33 <korre> whell im trying to write this class (Show a, Read a) => Storable a where    load::String->IO a    load path = do       content <- readFile path       let tmp = (read content) :: a        return tmp
11:51:45 <korre> dam that was not readable
11:52:55 <Botje> you don't really need a typeclass for that.
11:53:16 <korre> no butt im experamenting
11:53:34 <saml> you don't really need a experimenting for that
11:54:55 <grn> How to convert an Int to Data.Word8?
11:55:11 <Botje> fromIntegral?
11:55:20 <asdioajsdoiajsd> to the experienced haskellers, do you when writing a program include the types of a class? (as in ... :: a -> B)
11:55:20 <Botje> :t fromIntegral :: Int -> Word8
11:55:21 <lambdabot> Int -> Word8
11:55:42 <ski> asdioajsdoiajsd : do *what* when writing ... ?
11:55:45 <Vulpyne> asdioajsdoiajsd: You mean types of functions?
11:56:05 <asdioajsdoiajsd> uh
11:56:08 <asdioajsdoiajsd> scuse me, yes Vulpyne
11:56:13 <asdioajsdoiajsd> :$
11:56:23 <Vulpyne> When you say "class" people start to think "type class". :) In response to the question, I always do.
11:56:41 <Vulpyne> Except when I want to see what the compiler thinks the type is. :)
11:56:45 * ski often includes type signatures (in comments :/) when making instances of classes, yes
11:57:19 <grn> What actually fromIntegral does? Converts an Integral to any other type, or to other numeric types?
11:57:27 <ski> @type fromIntegral
11:57:28 <lambdabot> forall a b. (Integral a, Num b) => a -> b
11:57:32 <asdioajsdoiajsd> why in comments, ski?
11:57:35 <ski> to other numeric types
11:57:37 <BONUS> @seen dons
11:57:38 <lambdabot> Unknown command, try @list
11:57:48 <BONUS> who's the bot with @seen again?
11:57:51 <BONUS> preflex: seen dons
11:57:51 <preflex>  dons was last seen on #haskell 58 minutes and 48 seconds ago, saying: mtl is kinda deprecated in favour of transformers or monadLib.
11:58:02 <ski> asdioajsdoiajsd : last i tested, type signatures were not allowed in the `where' in an `instance' declaration
11:58:14 <asdioajsdoiajsd> ah
11:58:20 <FunctorSalad> I just Unviersal-Argument inferior-haskell-insert-type everything
11:58:21 <ski> (why, i don't know)
11:58:28 <FunctorSalad> thanks to Baughn that works reliably now :)
11:58:49 <FunctorSalad> sometimes I insert the sigs too early though and end up having to delete them all again
11:58:55 <FunctorSalad> (when design changes)
11:59:52 <Baughn> FunctorSalad: I, um, don't recall doing anything with that
11:59:54 <BONUS> hmm interesting dilemma. what would you guys say is correct: type class or typeclass?
12:00:02 <Baughn> typeclass, but I'm norwegian.
12:00:07 <BONUS> lol
12:00:15 <Botje> typeclass.
12:00:20 <BONUS> H98 puts it as two words, RWH as one
12:00:32 <Twey> The Typeclassopedia has a section on this issue.
12:00:36 <ski> `H98' must be right ! (it *is* the standard)
12:00:37 <asdioajsdoiajsd> :t putChar
12:00:39 <lambdabot> Char -> IO ()
12:00:40 <Twey> It concludes that ‘type class’ is correct.
12:00:46 <FunctorSalad> typelcass; contains more information: makes it clear that it's a technical temr
12:00:54 <asdioajsdoiajsd> > putChar "asdasda"
12:00:55 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:00:55 <lambdabot>         against inferred type...
12:00:57 <Twey> I agree, on stylistic grounds
12:00:57 <FunctorSalad> Baughn: hmm you revived haskell-mode right?
12:00:59 * BONUS checks typeclassopedia
12:01:07 <Botje> asdioajsdoiajsd: did you mean putStrLn ?
12:01:09 <FunctorSalad> Baughn: inserting types used to fail for some large type sigs
12:01:22 <Baughn> Oh. I think someone sent me a patch to deal with that.
12:01:29 <ski> FunctorSalad : which version(s) of GHC allows that ?
12:02:02 <asdioajsdoiajsd> Botje, I dunno, my book says putChar here (or am i speaking to a bot now?:$)
12:02:12 <FunctorSalad> ski: inserting type sigs? haskell-mode for emacs
12:02:15 <asdioajsdoiajsd> putStrLn "adfas"
12:02:16 <Botje> putchar wants a char
12:02:18 <Botje> so 'f'
12:02:24 <Botje> not "foo", which is [Char]
12:02:26 <asdioajsdoiajsd> ah
12:02:30 <asdioajsdoiajsd> ahh.
12:02:31 <asdioajsdoiajsd> ok!
12:02:33 <asdioajsdoiajsd> thanks
12:02:34 <ski> FunctorSalad : yes, but since when is that allowed (directly) inside an `instance' declaration ?
12:02:54 <FunctorSalad> ski: I was thinking of functions
12:02:59 <FunctorSalad> (not instances)
12:03:27 <ski> ah, ok
12:04:01 <ski> (mis"parse" of what you were replying to)
12:05:07 <Fredderf> @pl map toLower
12:05:07 <lambdabot> map toLower
12:05:17 <Fredderf> so no stringToLower exists?
12:05:41 <FunctorSalad> Baughn and everyone else: btw am I the only one who finds \emptyset for () questionable?
12:05:51 <ClaudiusMaximus> > length "map toLower" < length "stringToLower"
12:05:52 <lambdabot>   True
12:06:01 <Fredderf> lol
12:06:25 <ski> (.. "toLowers" ?)
12:06:32 <Baughn> FunctorSalad: It's fine as a type, not so good as a value
12:06:42 <FunctorSalad> Baughn: heh I thought the opposite
12:06:47 <Baughn> Unfortunately haskell-mode can't really differentiate between the two yet
12:07:07 <FunctorSalad> in von-Neumann numerals you have 1 = { \emptyset }, so as a value it's okay
12:07:13 <Fredderf> @pl length "map toLower" < length "stringToLower"
12:07:13 <lambdabot> True
12:07:21 <Baughn> As a type, it contains no information
12:07:21 <ski> FunctorSalad : who's using `\emptyset' for that ?
12:07:27 <Baughn> ski: haskell-mode. ;)
12:07:29 * ski wants to know who to punish !
12:07:37 <Baughn> ..oy
12:07:41 <Fredderf> @pl \x \y -> length x < length y
12:07:41 <lambdabot> (line 1, column 4):
12:07:41 <lambdabot> unexpected "\\"
12:07:41 <lambdabot> expecting operator, pattern or "->"
12:07:47 <Fredderf> @pl \x y -> length x < length y
12:07:47 <lambdabot> (. length) . (<) . length
12:08:00 <ski> (It's *not* fine as the unit type !)
12:08:09 <Veinor> wait, haskell-mode uses unicode characters for things?
12:08:13 <Baughn> ski: So what symbol would you prefer?
12:08:18 <Baughn> Veinor: Sure, if you turn the function on
12:08:38 <Veinor> ah
12:08:42 <ski> Baughn : the `T' symbol which is an up-side-down `_|_' might work ..
12:08:54 <copumpkin> \top !
12:08:56 <Veinor> is that generally considered a bad idea?
12:09:01 <FunctorSalad> () isn't that bad actually
12:09:02 <ski> (or `1' .. but i suppose that's taken :)
12:09:04 <copumpkin> Veinor: not at all
12:09:14 <Baughn> It makes haskell look better. ;)
12:09:20 <Veinor> :P
12:09:23 <Veinor> So how do I enable it?
12:09:28 <Baughn> M-x customize-group haskell
12:09:29 <Twey> ⊥
12:09:36 <Fredderf> :t (<$>)
12:09:37 <ski> but `()' isn't so bad, given that Haskell's already taken the wrong notation `()' and `( .. , .. )' for the types ..
12:09:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:09:41 <Twey> U+22A5
12:09:56 <Twey> ski: You'd prefer *?
12:10:07 <ski> yes
12:10:16 <Twey> What would unit be?
12:10:19 <Veinor> we should use  ☠  for bottom :D
12:10:24 <Twey> Hehe
12:10:25 <Baughn> Maybe I should use U+2605
12:10:32 <Twey> ★
12:10:33 <Twey> Heh
12:10:35 <Twey> Cute
12:10:40 <ski> Twey : `1' or `\top' (or `Unit' if you can't take the two former)
12:10:42 <copumpkin> Twey: Agda has a type called that :P
12:10:50 <Veinor> you and your agda
12:10:58 <Twey> copumpkin: Called what?
12:11:00 <copumpkin> one day you'll understand
12:11:07 * ski knows about a song called "Hnan Agda"
12:11:15 <FunctorSalad> ★ is not bad
12:11:16 <Veinor> also, what's the star type do?
12:11:17 <Twey> ski: Broken encoding!
12:11:27 <copumpkin> can't remember, I'm sure I saw it somewhere
12:11:29 <Twey> Veinor: It represents the product of types (i.e. tuples)
12:11:33 * ski bows, guilty as charged
12:11:46 <FunctorSalad> or () but with some obscure parens
12:11:48 <Twey> Int * Bool = (Int, Bool)
12:11:48 <Baughn> But seriously, what should I use as the symbol for ()?
12:11:49 <ski> (that's "The Hen Agda", in english)
12:11:49 <Veinor> worked fine for me, ski
12:11:52 <FunctorSalad> (just so it looks fancy)
12:12:11 <copumpkin> Baughn: \top
12:12:17 <FunctorSalad> hmm
12:12:21 <copumpkin> ⊤
12:12:21 <Veinor> Twey: should use × for that instead :P
12:12:22 <copumpkin> that is
12:12:29 <Baughn> copumpkin: The value that is a member of no types?
12:12:33 <Twey> Veinor: It was probably ISO-8859-1, then
12:12:33 <Baughn> Um..
12:12:40 <ski> Veinor : "star type" ?
12:12:41 <Apocalisp> ski: wayte a minute...
12:12:53 <ski> Veinor : maybe you mean the kind `*' ?
12:12:53 <Apocalisp> ski: Hönan Agda... Coq...
12:12:54 <Veinor> I mean, Int × Bool
12:12:55 <copumpkin> Baughn: oh, I guess the type should be ⊤ and the value should be um
12:13:03 <copumpkin> data ⊤ : Set where um : ⊤
12:13:03 <Twey> Ah
12:13:04 <Baughn> copumpkin: They have to both be the same.
12:13:09 <copumpkin> Baughn: why?
12:13:15 <ski> (some papers write the kind `*' as a five-pointed star :)
12:13:22 <Baughn> copumpkin: The parser and font-lock mode aren't unified.
12:13:28 <ski> Apocalisp : indeed ..
12:13:28 <Baughn> That's a project for the future.
12:13:40 <Veinor> times new roman has a non-bold 6-pointed * and a bold 5-pointed *
12:14:16 <Baughn> copumpkin: So, with that in mind..?
12:14:24 <copumpkin> not sure :)
12:14:36 <Baughn> I could just remove the symbol entirely, but I don't think the empty set is all wrong
12:14:45 <Apocalisp> ((uncurry (<) . join (***) length) .) . (,) $ "((uncurry (<) . join (***) length) .) . (,)" "(. length) . (<) . length"
12:14:49 <Baughn> It encodes "no information here" pretty well. ;)
12:14:50 <Apocalisp> > ((uncurry (<) . join (***) length) .) . (,) $ "((uncurry (<) . join (***) length) .) . (,)" "(. length) . (<) . length"
12:14:51 <lambdabot>   Couldn't match expected type `t -> [a]'
12:14:51 <lambdabot>         against inferred type `[GHC...
12:14:59 * ski . o O ( `data So : Bool -> Set where Oh : So True' )
12:15:27 <ski> Baughn : no !
12:15:38 <Baughn> ski: Well, give me an alternative!
12:15:42 <ski> Baughn : the empty set would be a reasonable symbol for the type `Void'
12:15:47 <grn> Could you take a look at: http://pastebin.com/d509e271a
12:16:01 <grn> It's my first Haskell programme
12:16:08 <ski> the empty type and the singleton type are *very* different
12:16:14 <Baughn> ski: I could use U+2721
12:16:18 <Veinor> ski: >:|
12:16:19 <Twey> {∅}
12:16:21 <grn> It draws a nice Clifford attractor
12:16:27 <grn> How can it be improved?
12:16:41 <Twey> data {{∅}} = {∅}
12:17:25 * ski frantically searches for a web page with pictures of unicode glyphs
12:17:43 <Baughn> http://www.fileformat.info/info/unicode/block/dingbats/utf8test.htm
12:17:43 <FunctorSalad> kcharselect if you're on linux
12:17:46 <Zao> ski: fileformat.info
12:19:17 <ski> (FunctorSalad : i found that, yes, but it just displays boxes for most glyphs :)
12:19:20 <Fredderf> > on (<) length "map toLower" "stringLower"
12:19:21 <lambdabot>   False
12:19:29 <Fredderf> > on (<) length "map toLower" "stringToLower"
12:19:30 <lambdabot>   True
12:19:33 <Fredderf> ah
12:19:48 <FunctorSalad> ski: DejaVu Sans has most of them
12:19:59 <Fredderf> > (<) `on` length "map toLower" "stringToLower"
12:20:00 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> a -> b'
12:20:00 <lambdabot>         against i...
12:20:41 <Veinor> > (<) `on` (length "map toLower" "stringToLower")
12:20:42 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> a -> b'
12:20:42 <lambdabot>         against i...
12:20:52 <Veinor> oh, whoops
12:21:07 <Fredderf> ((<) `on` length) "hello" "world"
12:21:13 <Fredderf> > ((<) `on` length) "hello" "world"
12:21:14 <lambdabot>   False
12:21:15 <Veinor> yeah, I think that's what you need
12:21:24 <ski> grn : i'd write
12:21:31 <Fredderf> the cool thing is i was able to find "on" with hoogle
12:21:37 <Fredderf> @hoogle (s -> n) -> (n -> n -> Bool) -> (s -> s-> Bool)
12:21:37 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:21:37 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
12:21:37 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
12:21:49 <Baughn> ski: Okay, U+2766 it is.
12:22:02 <ski>   points = (`iterate` (0,0)) $ \(x,y) ->
12:22:06 <ski>     (sin(a * y) + c * cos(a * x)
12:22:07 <ski>     ,sin(b * x) + d * cos(b * y))
12:22:13 <Veinor> I'd useyeah, hoogle is really cool
12:22:16 <Veinor> -I'd use
12:22:21 <Fredderf> LOL
12:22:23 <ski> (and similarly for `pixels')
12:22:23 <Veinor> damn me and my habit of mixing lines
12:22:25 <copumpkin> Veinor: fail
12:22:46 <Baughn> fail--
12:22:47 <FunctorSalad> U+2766 FLORAL HEART ❦
12:22:54 <FunctorSalad> ?
12:22:55 <Badger> @karma fail
12:22:55 <lambdabot> fail has a karma of 0
12:23:17 <Baughn> Oh my. There has to be a story in there.
12:23:21 <ski> (well s/sin/sin / and s/cos/cos /)
12:23:31 <Baughn> fail--
12:23:34 <Baughn> @karma fail
12:23:34 <lambdabot> fail has a karma of -1
12:25:58 <Baughn> ski: Or, since you dislike using empty set, how about U+29B1
12:26:04 <Baughn> Also known as 'not empty set'
12:26:34 <Baughn> Hm. Maybe U+29B2.. empty set plus one
12:27:01 <Veinor> haha
12:28:00 <grn> If i have a list [((Int, Int), Int)] is it possible to do pattern matching? Like [((x, y), count)]:xs?
12:28:26 <FunctorSalad> drop the []
12:28:27 <copumpkin> ((x, y), count): xs
12:29:46 <grn> right, I wrote them by mistake. But I get: Parse error in pattern
12:30:14 <Vulpyne> When in doubt, add more parenthesis!
12:30:29 <Vulpyne> Or put the actual code on hpaste and show us.
12:30:46 <grn> Vulpyne, lol, that did it :-)
12:30:55 <grn> Vulpyne, I put it on pastebin
12:31:02 <ski> grn : also, instead of `paint surface maximum ps = do ... where p = head ps; pt = fst p; count = snd p; x = fst pt; y = snd pt; color = fromIntegral(4 * (255 * count) `quot` maximum); rest = tail ps', use `paint surface maximum (((x,y),count):rest) = do ... where color = fromIntegral(4 * (255 * count) `quot` maximum)'
12:31:09 <Vulpyne> Ah, I didn't see you paste a link to the code.
12:31:29 <grn> ski, thats the part I wanted to replace with pattern matching
12:31:38 <ski> *nod*
12:32:22 * ski got delayed by trying to understand why Baughn wanted to use FLORAL HEART for the unit type ..
12:35:21 <asdioajsdoiajsd> :t :=
12:35:22 <lambdabot> parse error on input `:='
12:35:29 <voker57> is hackage some kind of read-only down? ERROR: dist/package.tar.gz: 400 Error in upload
12:35:30 <asdioajsdoiajsd> :t (:=)
12:35:31 <lambdabot> forall a b. a -> b -> Assoc a b
12:36:31 <copumpkin> @hoogle Assoc
12:36:32 <lambdabot> Control.Parallel.Strategies data Assoc a b
12:36:32 <lambdabot> Text.Parsec.Expr data Assoc
12:36:32 <lambdabot> Text.ParserCombinators.Parsec.Expr data Assoc
12:36:55 <asdioajsdoiajsd> @hoogle attr
12:36:55 <lambdabot> Text.Html class ADDATTRS a
12:36:55 <lambdabot> Text.XHtml.Frameset class ADDATTRS a
12:36:55 <lambdabot> Text.XHtml.Strict class ADDATTRS a
12:37:11 <asdioajsdoiajsd> @hoogle prop
12:37:11 <lambdabot> Prelude properFraction :: (RealFrac a, Integral b) => a -> (b, a)
12:37:11 <lambdabot> Test.QuickCheck data Property
12:37:11 <lambdabot> Test.QuickCheck property :: Testable a => a -> Property
12:38:06 <asdioajsdoiajsd> I'm a little confused, what do Prop and Attr mean?
12:39:14 <ski> presumably abbreviations for `Property' and `Attribute'
12:41:21 <asdioajsdoiajsd> > takeWhile True (repeat True)
12:41:22 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:41:22 <lambdabot>         against inferred ...
12:42:32 <Kim^Walkman> :t takeWhile
12:42:34 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:42:36 <Kim^Walkman> :t True
12:42:37 <lambdabot> Bool
12:44:53 <ski> @type otherwise
12:44:55 <lambdabot> Bool
12:45:00 <ski> > (fst *** fst) (('a',()),('b',False))
12:45:01 <ski> > join (***) fst (('a',()),('b',False))
12:45:01 <lambdabot>   ('a','b')
12:45:02 <lambdabot>   Couldn't match expected type `()'
12:45:02 <lambdabot>         against inferred type `GHC.Bool.B...
12:45:18 <copumpkin> sad
12:45:39 * ski wonders whether `fst :: forall a. (exists b. (a,b)) -> a' would fix that ..
12:45:53 <copumpkin> that would be nice :)
12:46:15 <ski> (or maybe `fst :: forall a. (a,exists b. b)) -> a' ?)
12:46:24 <copumpkin> would those be different?
12:46:24 <ski> (s/))/)/)
12:46:29 <ski> i'm not sure
12:46:36 <ski> maybe they'd be interconvertible
12:46:43 <copumpkin> if you think of exists as a pair
12:46:55 <copumpkin> it seems like you can distribute it around without much pain
12:46:59 <ski> `exists a. [a]' would be different from `[exists a. a]', anyway
12:47:04 <copumpkin> yeah
12:50:47 <halcyon10> @pl (\x -> trace (show x) x)
12:50:47 <lambdabot> trace =<< show
12:50:53 <ski> also, i've been wondering whether `data Either :: * -> * -> * where Left :: forall a. a -> forall b. Either a b; ...' (or `... Left :: forall a. a -> Either a (forall b. b); ...' would fix `instance Monad (Either e) where ...; Right a >>= k = k a; ma >>= _ = ma' (alternatively `...; ma@(Left _) >>= _ = ma; Right a >>= k = k a'
12:51:02 <ski> (but i'm doubting this)
12:53:07 <ski> (potatishandlarn : .. haru nra potter till salu ?)
12:53:37 <dolio> forall a. a -> forall b. Either a b is the same as forall a b. a -> Either a b.
12:54:49 <ski> yes, and i'm not sure `forall a. a -> Either a (forall b. b)' would help either
12:54:52 <ski> (hence the doubt)
12:56:05 <dolio> It seems unlikely to me.
12:56:14 <ski> i just want some way to tell the type system that when matching on `Left ...', the `b' part of `Either a b' is actually irrelevant, so may be replaced by a fresh variable ..
12:56:24 <Heffalump> also, Either a (forall b .b) will become illegal in GHC 6.14
12:56:24 <ski> .. but i'm not sure how to express this
12:56:38 <Heffalump> ski: reconstruct the value
12:56:44 <ski> Heffalump : any reason why ?
12:56:55 <ski> Heffalump : well, that's what i wanted to avoid :)
12:56:58 <dolio> For instance, that type doesn't let you have Left 5 :: Either Int Int.
12:57:02 <Heffalump> ski: because ImpredicativeTypes are being removed until they can figure out how to make them work sanely
12:57:08 <ski> ok
12:57:33 <ski> dolio : yes, i know
12:58:01 <ski> (that above was more meant to express my failure to formalize this, rather that a good way to do so)
12:58:10 <Fredderf> :t or.map
12:58:11 <lambdabot>     Couldn't match expected type `[Bool]'
12:58:11 <lambdabot>            against inferred type `[a] -> [b]'
12:58:11 <lambdabot>     Probable cause: `map' is applied to too few arguments
12:58:44 <Fredderf> :t (\p -> or.map p)
12:58:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:59:07 <copumpkin> :t any
12:59:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:59:13 <copumpkin> :t or . map
12:59:15 <lambdabot>     Couldn't match expected type `[Bool]'
12:59:15 <lambdabot>            against inferred type `[a] -> [b]'
12:59:15 <lambdabot>     Probable cause: `map' is applied to too few arguments
12:59:29 <copumpkin> oh :)
12:59:36 <copumpkin> :t (or .) . map
12:59:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:59:49 <Fredderf> @pl (\p -> or.map p)
12:59:50 <lambdabot> any
12:59:52 <Fredderf> LOL
13:00:11 <ski> (iirc OCaml has something slightly similar with polymorphic (aka lightweight) variants .. if you  match foo of `A -> ... | `B x -> ..x.. | y -> ..y..', then the type system knows that `y' can't be the  `A  or  `B  variant)
13:00:56 <ski> @type Cont . flip any
13:00:57 <lambdabot> forall a. [a] -> Cont Bool a
13:01:12 <ski> Fredderf : ^ :)
13:04:29 <Fredderf> Is there a name for the empty list besides [] like nil or so?
13:04:58 <Botje> [] is just fine
13:05:03 <Botje> you can call it nil if you want
13:05:47 <roconnor> you can also call it mempty
13:05:50 <roconnor> or call it mzero
13:06:05 <Vulpyne> Anything but "late for dinner".
13:06:28 <roconnor> or you can call it (fail "late for dinner")
13:06:50 <roconnor> > (fail "late for dinner") :: String
13:06:50 <lambdabot>   ""
13:07:08 <roconnor> > (fail "late for dinner") :: [()]
13:07:09 <lambdabot>   []
13:07:15 <Vulpyne> Amusing.
13:07:27 <Vulpyne> I should use that in code.
13:07:57 <ddarius> > 1:2:3:4:fail "late for dinner"
13:07:58 <lambdabot>   [1,2,3,4]
13:08:08 <ezyang> what
13:08:30 <ezyang> oh right, list monad
13:08:31 <dolio> Very perspicuous.
13:09:37 <Vulpyne> > 1:2:3:4:error "late for dinner" -- :)
13:09:38 <lambdabot>   [1,2,3,4* Exception: late for dinner
13:14:41 <asdioajsdoiajsd> :t fromInteger (True)
13:14:42 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Bool'
13:14:42 <lambdabot>     In the first argument of `fromInteger', namely `(True)'
13:14:42 <lambdabot>     In the expression: fromInteger (True)
13:15:02 <Vulpyne> Maybe you want fromEnum.
13:15:32 <Vulpyne> BTW, that's more parenthesis than you needed. :)
13:16:06 <Axman6> death to parens!
13:16:14 <asdioajsdoiajsd> There's no problem in using more, right?:p
13:16:43 <Vulpyne> Well, other than the code looking weird, no.
13:16:47 <Baughn> For a type like 'newtype Foo m a = Foo (ReaderT X (WriterT Y m) a)', it would be nice to automatically generate appropriate instances to make Foo a Monad(Reader|Writer) without that touching the internal reader/writer transformers,
13:16:53 <ddarius> > ((((((((((((((((((((((((fromInteger ((((((((((((((((((((((((((((True))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
13:16:54 <lambdabot>   <no location info>: parse error on input `)'
13:16:59 <ekp2> Guys what do you recommend a self taught computer science guy, how to compete with people from college?
13:17:17 <Vulpyne> Compete in what way?
13:17:23 <ezyang> ekp2: Make a portfolio.
13:17:34 <ddarius> Go to college.
13:17:36 <asdioajsdoiajsd> And I tried that only because a question i got here said: how to solve an error when trying "2 + True", a: fromInteger (True), b: define a function (+) with type Integer -> Bool -> Integer, or define a function fromInteger of type Integer -> Bool, d: none of the above
13:17:49 <Axman6> ddarius: damn, beat me to it
13:17:55 <ekp2> compete in sense be on same level with knowledge
13:18:06 <Baughn> Now, I can see how to do that - something like 'newtype Foo m a = Foo (Wrap (ReaderT X (WriterT Y (WrapEnd m)) a)', but before I do so, is there anything like that in a package already?
13:18:08 <ddarius> ekp2: Drink lots of alcohol.
13:18:17 <ezyang> "hackadrunkathon"
13:18:23 <Vulpyne> ekp2: Spend lots of time programming and learning about programming.
13:18:32 <ekp2> very general advices
13:18:32 <c_wraith> ekp2:  investigate several computer science programs, look at the course lists, and learn those same things
13:18:34 <Vulpyne> I work as a programming and I have no formal education whatsoever.
13:18:38 <Vulpyne> Er, programmer.
13:18:47 <ekp2> ok
13:18:56 <Axman6> Vulpyne: does it show
13:18:57 <Heffalump> Vulpyne: beyond high school level, you mean?
13:18:58 <Axman6> ?
13:18:59 <Axman6> :P
13:19:00 <jfoutz> write a compiler.
13:19:06 * ddarius is completely confidant he can "beat" the vast majority of CS undergrads and many graduate students handily.
13:19:25 <Vulpyne> Heffalump: I never really went to school. I was "homeschooled" which mostly involved teaching me to read and leaving me alone after that. :)
13:19:29 * Botje hands ddarius a bigger stick
13:19:38 <Vulpyne> Axman6: Show in what way?
13:19:46 <ziman> Baughn, do you mean RWST?
13:19:49 <Heffalump> Vulpyne: wow
13:20:06 <copumpkin> :t (****)
13:20:07 <lambdabot> forall t t1. t -> t1 -> Doc
13:20:15 <ekp2> write a compiler - i agree with that one
13:20:16 <copumpkin> > go **** yourself -- gain
13:20:17 <lambdabot>   don't be rude
13:20:24 <Vulpyne> Heffalump: Well, it resulted in me doing a couple things pretty well (programming) since I was really interested in that, and knowing very little about stuff that didn't interest me.
13:20:40 <Badger> @hoogle (****)
13:20:41 <lambdabot> No results found
13:22:05 * Axman6 personally quite likes having a fairly well rounded education. specialisation is for university
13:22:13 <Baughn> ziman: Not like that. Hang on, let me write it up..
13:22:23 <ddarius> Specialization is for insects.
13:22:53 <copumpkin> :)
13:22:59 <Axman6> wut?
13:23:03 <Vulpyne> Having a well rounded education would be nice, but seems less attractive if you end up using only a small subset of the knowledge. Not to mention, it's expensive and/or timeconsuming.
13:23:03 <asdioajsdoiajsd> > 1 + 2
13:23:04 <lambdabot>   3
13:23:31 <Vulpyne> These days if you have a reference of some information you want to know, you can find detail on it pretty easily.
13:24:55 <copumpkin> Vulpyne: "use" can be broad
13:25:44 <Baughn> ziman: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13558#a13558 <-- ..yet to fill in the implementation of Wrap/Wrapped, but you get the idea
13:26:05 <Vulpyne> That is true. I assuming you're talking about something slightly related being useful if you were trying to solve some problem in another domain.
13:26:17 <Axman6> @unmtl (ReaderT X (WriterT Y m) a)
13:26:17 <lambdabot> X -> m (a, Y)
13:26:31 <Baughn> ziman: (And,of course, I meant Reader Int, not ReaderT)
13:26:44 <copumpkin> Vulpyne: or just mental "practice"
13:27:34 <ddarius> copumpkin: That's a good point.  Learning is, itself, a skill.
13:27:35 <Raynes> You silly kids and your monad transformers.
13:27:36 <Vulpyne> copumpkin: If it's something interesting enough to use as practice, perhaps would one already have learned about it on one's own. :)
13:28:03 <Axman6> how do you know something's not interesting?
13:28:10 <ddarius> Vulpyne: There's plenty of interesting stuff out there.  Way more than you could learn in a life time.
13:28:12 <copumpkin> mental agility is generally something good
13:28:20 * hackagebot upload: error-message 1.0 - Composable error messages. (GregoryCrosswhite)
13:28:26 <copumpkin> it doesn't need to be school
13:28:44 <copumpkin> but most people tend not to be curious enough to feed/exercise their mind to its full potential on their own
13:29:10 * copumpkin waves his hands some more
13:29:33 * ddarius doesn't see college significantly helping those people.
13:29:35 <Vulpyne> I don't disagree with any of that.
13:30:09 <ddarius> Vulpyne: Learn how to crochet.
13:30:10 <Vulpyne> Just from my perspective, there are many things I would have learned in school (or college if I'd gone) that would have extremely low usage for the time expended.
13:30:12 <copumpkin> yeah, it probably doesn't do much
13:30:30 <ddarius> Vulpyne: Learn the things you want to learn.
13:30:36 <ddarius> and how to crochet.
13:30:40 <Vulpyne> And having a small amount of knowledge about a wide amount of things is more useful [to me], and you can expand on that when needed.
13:30:43 <copumpkin> Vulpyne: I have no use for my knowledge of southeast asian history, but it was fascinating and illuminating :)
13:31:04 <ziman> Baughn, ah, i see, interesting. So do you access AESCtx via something like (liftWrap ask), then? (however, i don't know the answer to your question...)
13:31:04 <ddarius> copumpkin: I doubt you have no use for it.
13:31:04 <jfoutz> is crocheting better than knitting? knitting is actually kinda neat.
13:31:16 <ddarius> jfoutz: I do both.  They each have their benefits.
13:31:18 <Vulpyne> copumpkin: If you'd just heard about it, would you have been motivated to learn more about it on your own?
13:31:25 <copumpkin> ddarius: beyond sounding knowledgeable in social circles?
13:31:27 <Vulpyne> ddarius: Why crocheting? :)
13:31:29 <ddarius> jfoutz: It's a lot easier to do hyperbolic geometry with crochet though.
13:31:36 <ddarius> copumpkin: Yes.
13:31:37 <copumpkin> Vulpyne: only a little, but I wasn't forced to take the course in the first place
13:31:49 <copumpkin> ddarius: fair enough, I can see some examples
13:32:14 <ddarius> Vulpyne: It's easy, relaxing, and actually is interesting from at least a few perspectives.  It's also useful.
13:32:14 <Baughn> ziman: Something like that, I guess. I've yet to figure out exactly how to implement this. :P
13:32:28 * hackagebot upload: error-message 1.0.1 - Composable error messages. (GregoryCrosswhite)
13:32:32 <Baughn> ziman: It borders perilously closely to type programming, an area I've so far left to the experts
13:32:34 <Vulpyne> ddarius: Useful in that you end up with stuff you can wear?
13:32:37 <ezyang> huh, what's that
13:32:43 <ddarius> Vulpyne: Yes.
13:32:56 <copumpkin> ddarius: have you done any of the mathematical knitting/crocheting? klein bottles, projective plane?
13:33:34 <ddarius> copumpkin: I want to make a Klein bottle but haven't gotten around to it.  I've thought about (and implement to some extent) the mathematics of the induced geometry.
13:33:37 <Vulpyne> ddarius: I don't think it would interest me, I'll just buy the hat. :)
13:34:59 <asdioajsdoiajsd> > putStr "a\nb\nc\nd\ne"
13:35:00 <lambdabot>   <IO ()>
13:35:15 <copumpkin> > text "a\nb\nc\nd\ne"
13:35:16 <lambdabot>   a
13:35:16 <Vulpyne> NO IO FOR YOU. COME BACK ONE MONTH!
13:35:16 <lambdabot>  b
13:35:16 <lambdabot>  c
13:35:16 <lambdabot>  d
13:35:16 <lambdabot>  e
13:35:29 <Baughn> > text $ repeat "a\n"
13:35:30 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:35:30 <lambdabot>         against inferred type...
13:35:35 <asdioajsdoiajsd> I ran out of IO?
13:35:39 <Baughn> > text $ concat $ repeat "a\n"
13:35:44 <copumpkin> > text "a\n, 1 + 2"
13:35:48 <lambdabot>   mueval: ExitFailure 1
13:35:55 <lambdabot>   mueval-core: Time limit exceeded
13:36:01 <Vulpyne> lambdabot doesn't let you do IO.
13:36:02 <Baughn> > text $ concat $ replicate 100 "a\n"
13:36:04 <lambdabot>   a
13:36:05 <lambdabot>  a
13:36:05 <lambdabot>  a
13:36:05 <lambdabot>  a
13:36:05 <lambdabot>  a
13:36:06 <lambdabot> [21 @more lines]
13:36:14 <copumpkin> > text "a\n, 1 + 2"
13:36:14 <Baughn> 21? Interesting.
13:36:15 <lambdabot>   a
13:36:15 <lambdabot>  , 1 + 2
13:36:20 <copumpkin> damn
13:36:29 <asdioajsdoiajsd> i think lambdabot should be named labda
13:36:30 <asdioajsdoiajsd> bot
13:36:32 <philed> Does anyone here know much about FRP?
13:36:38 <copumpkin> conal does :)
13:36:47 <Baughn> I do. :)
13:36:51 <philed> Ohhh..
13:36:55 <copumpkin> @slap Baughn
13:36:55 * lambdabot pushes Baughn from his chair
13:36:55 <philed> Is that *the* Conal?
13:36:59 <Baughn> No
13:37:10 <Baughn> conal is conal, and not me, but conal is.
13:37:22 <Baughn> Well, I know a little at least
13:37:24 <philed> So it's not Conal Elliot?
13:37:25 * conal chuckles
13:37:31 <copumpkin> conal is.
13:37:37 <conal> philed: no.  it's Conal Elliott.
13:38:00 * conal is sensitive about the single-"t" spelling
13:38:09 <Baughn> Elliottt?
13:38:13 <mauke> conall?
13:38:15 <aavogt> needs more repeated consonants ;
13:38:22 <Baughn> Elioth
13:38:28 <sproingie> Elbereth
13:38:58 <mauke> gilthoniel
13:39:06 * c_wraith is afraid of sproingie.  while he stands there
13:39:17 <Vulpyne> In Mordor where the shadows lie?
13:39:32 <mauke> probably in nethack
13:39:35 <shachaf> Was conal once called nal?
13:40:03 <copumpkin> shachaf: his arrows were flipped early on
13:40:06 <Badger> one does not simply >>= into mordor
13:40:12 <copumpkin> possibly before birth
13:40:32 <ezyang> @remember Badger one does not simply >>= into mordor
13:40:33 <lambdabot> Done.
13:40:48 <philed> Anyway, I'm working on a port of an implementation of FRP to F# to take advantage of Unity. I'm going for a continuations based approach, but I'm not sure if space leaks are going to get the better of me as I get into it.
13:41:00 <ben> unsafePerformPalantir
13:41:10 <Baughn> ..at least you don't have to sprinkle every few lines with unsafePerformIO
13:41:24 <philed> I've got an integrate function, but I can't do anything as cool as writing exp = integrate 1 exp
13:41:49 <philed> Since I don't have lazy evaluation. Is there a chance I can avoid the problem of space leaks entirely?
13:42:47 <sproingie> seems to me you wouldn't have space leaks unless you added your own laziness back in
13:44:04 <conal> philed: frp in a strict language is tricky.  folks have made various attempts.  i think they've all fudged/broken the semantics.
13:44:33 <copumpkin> http://pchiusano.blogspot.com/2009/05/optional-laziness-doesnt-quite-cut-it.html
13:44:39 <conal> philed: still could be worth another go, though.
13:44:42 <copumpkin> ergo, drop F# :P
13:44:48 <copumpkin> (just kidding, only sort of)
13:44:57 <philed> I'd drop F# if I could. But I want to be able to use Unity.
13:45:03 <asdioajsdoiajsd> :t ()
13:45:06 <lambdabot> ()
13:45:11 <asdioajsdoiajsd> nice.
13:45:21 <philed> I get an entire game engine written for me that way.
13:45:29 <asdioajsdoiajsd> :t (9)
13:45:30 <lambdabot> forall t. (Num t) => t
13:45:31 <copumpkin> :)
13:45:32 <copumpkin> gotta go
13:45:38 <ezyang> bye!
13:45:39 <conal> philed: trouble-free frp in a lazy setting is still problematic as well.
13:45:46 <asdioajsdoiajsd> :t (9,k)
13:45:47 <lambdabot> forall t. (Num t) => (t, Expr)
13:46:04 <philed> conal: Can I get a heads-up on common pitfalls?
13:46:12 <conal> philed: i can see the appeal of having a free game engine.
13:47:11 <asdioajsdoiajsd> :t thd
13:47:13 <lambdabot> Not in scope: `thd'
13:47:15 <Baughn> Can we just agree that FRP is tricky?
13:47:16 <conal> philed: if you keep a denotational focus, you'll probably notice the pitfalls.
13:47:20 <asdioajsdoiajsd> :t snd
13:47:21 <lambdabot> forall a b. (a, b) -> b
13:47:45 <philed> conal: I have an almost entirely denotational focus. The little bits of operational stuff are just there for the hacky bit of interface with the imperative world of unity.
13:47:57 <conal> philed: terrific!
13:48:36 <conal> philed: behaviors defined by self- and mutual recursion will be the trickiest.
13:49:15 <Baughn> ziman: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13558#a13560 <-- Here, how's this?
13:49:24 <conal> philed: well -- maybe trickier is having a functional implementation that's not extraordinarily inefficient.
13:49:43 <Baughn> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13558#a13560 <-- Actually, you're the best type-hacker I know of. Maybe you can help me make this work? Line 19 is.. obviously wrong, but....
13:49:56 <conal> philed: e.g. behaviors & events as infinite thingies.
13:50:25 <philed> conal: I'm very worried there. I don't know enough about the speed I need. I'm using FRP entirely for scripting, but even then, I've got to get all my stuff done 60 frames a second.
13:50:39 <philed> I haven't started looking at memoisation.
13:51:06 <philed> Two secs.
13:53:27 <mm_freak> not to be, that is the unit monad
13:53:43 <conal> philed: also, most FRP implementations are unfriendly to any sort of retained-mode engines.  i tackled that issue in Fran, as described in "From Functional Animation to Sprite-Based Display" http://conal.net/papers/padl99/ .
13:55:08 <chamrrr> hello I can that my post not belong there, but I have question if exist some IRC for matlab discusions
13:55:25 <lament> try #math-software
13:55:32 <Baughn> chamrrr: Did you.. try #matlab?
13:55:54 <ski> Baughn : s/MonadTrans m/MonadTrans t' ??
13:56:18 <chamrrr> thanks very much :)
13:56:19 <Baughn> ski: I'm not sure.
13:56:23 <philed> I'm roughly hoping that if I keep the game simple enough, the interface with the engine won't be too demanding. I'd like to put all the complexity into the scripting, which is why I hope FRP will be of real benefit.
13:56:26 <conal> philed: the file came through.  i'm unable to reply through the priv channel.
13:57:12 <ski> Baughn : i'm not sure i understand `wrap = lift . wrap', though
13:57:19 <philed> Not sure why that is.
13:57:24 <conal> philed: sure.  that paper describes a FRP architecture that rendered at video refresh but frp'd at a lower & less regular rate.
13:57:47 <ski> error-message sounds wonderful
13:57:49 <Baughn> ski: The idea is that the operation is lifted to the next innermore monad transformer, and then retried
13:58:26 <Baughn> ski: Eventually it'll hit Unwrap, where that method is overridden to just do it instead
13:58:43 <Baughn> (Is "innermore" a word?)
13:58:57 <mauke> it is now.
13:59:20 <conal> philed: i'm about to leave now.  will be back online in 45 mins or so.
13:59:48 <philed> Cool. I'll be around. Cheers for helping me out.
13:59:56 <conal> :)
14:00:39 <ski> Baughn : `wrap :: Monad m => m a -> t (m a)' will only add a single transformer (namely `t')
14:01:01 <Baughn> ski: Did I mention I'm going to need several hours of meditation to reach the level where I can /understand/ this code?
14:01:05 <Baughn> Let alone write it
14:01:16 <ski> i believe you possibly want something more list `wrap :: m a -> n a' with some relation between `m' and `n'
14:01:26 <ski> s/list/like/
14:01:28 <periodic> Can anyone point me to a good way in haskell to deal with halting a parallel computation if _any_ of the threads returns an answer?  e.g. I'm doing a tree search and I don't want the system to entirely evaluate the left side to depth 1000 if it finds an answer on the right side at depth 2.
14:02:10 <periodic> Should I store an answer in a common variable or something? Or is there an easy way to parMap it?
14:02:15 <Vulpyne> periodic: Could this be useful - http://www.haskell.org/haskellwiki/Unamb
14:02:42 <periodic> *reads*
14:02:44 <Baughn> periodic: Unamb will do it. But be aware, the titular unamb function itself is probably buggy, and if it isn't, chances are GHC is.
14:02:54 * Baughn is speaking from experience
14:03:18 <periodic> Thanks, Baughn.
14:03:28 <periodic> "Although semantically very simple, unamb has been quite tricky to implement correctly and efficiently."
14:03:37 <periodic> And thanks for the link, Vulpyne.  It sounds like exactly what I want.
14:03:41 <Vulpyne> In normal cases, or funky cases like where one of the operations does IO and spawns threads or such.
14:03:47 <ski> Baughn : if you use `wrap :: Maybe a -> ReaderT r (Wrap (StateT s (Unwrap (WriterT o Maybe)))) a', what do you expect that to amount to ?
14:04:05 <periodic> yeah, I'll try to stick with pure searching of a tree.
14:04:16 <Baughn> ski: I.. what?
14:04:51 <ski> did i manage to completely misunderstand the application you want of this ?
14:05:01 <periodic> Thanks, both of you.  *goes off to code*
14:05:13 <ski> when you say "Lifts operations until the outermost Unwrap", what do you mean, then ?
14:05:24 <Baughn> Exactly what I said
14:05:31 <ski> (and why "outermost" rather than "innermost")
14:05:35 <ski> well, i don't know what it means
14:05:40 * hackagebot upload: bitmap 0.0.1 - A library for handling and manipulating bitmaps. (BalazsKomuves)
14:05:51 <Baughn> ski: Well - typically, monad transformers are arranged as a one-dimensional chain, right?
14:05:58 <ski> yes .. ?
14:05:58 <Baughn> Or a type-levellist..
14:06:30 <ski> so `ReaderT r',`Wrap',`StateT s',`Unwrap',`WriterT o', in the above example
14:06:36 <Baughn> ski: unwrap := tail . dropWhile (/= Unwrap)
14:06:41 <Baughn> So to speak
14:07:34 <ski> (from the beginning or from the end of that "list" ?)
14:07:39 <Baughn> Beginning
14:07:51 <Baughn> ski: I think a simpler example would be better. So, like this: type Foo = ReaderT Int (Wrap (Reader Char ()))
14:08:21 <Baughn> ski: unwrap ask would lift the ask operation until it hits the type wrapped by Wrap, and reads the Char
14:08:39 <Baughn> ski: Replace the Wrap type with Unwrap, and the /wrap/ function would do the exact same
14:08:43 <Baughn> Normally, you'd use them in pairs
14:09:13 <ski> oh .. is this some kind of workaround to that the `MonadReader',`MonadState',&c. classes aren't indexed by names of environment/state (so that you can have more than one of each in a "transformer stack") ?
14:09:20 <Baughn> Yes
14:09:34 <Baughn> It allows you to skip part of the stack, and thus side-steps that
14:10:11 * ski feels uneasy with helping to workaround this kind of bug .. :)
14:10:32 <ski> (and i think it is a bug, even though i don't know how to fix it correctly)
14:10:38 <Baughn> You can make a transformer stack with any number of readers, writers, whatevers in, surround it with Wrap and Unwrap, and the compiler will skip to the monad wrapped inside it unless you explicitly tell it not to, by calling unwrap
14:10:54 <ski> but i think you need a predicate of two arguments
14:11:25 <Baughn> I think this is way above my level, actually. Not much use in trying to explain it here. :P
14:11:44 <ski> and possibly you need different classes for `Wrap' resp. `Unwrap'
14:11:46 <Baughn> I'll keep thinking about it, but it was easier to write out how I think it should work than to actually make haskell understand it
14:12:04 <ski> you said something about them usually coming in pairs
14:12:06 <ski> example ?
14:12:17 <Baughn> newtype AES m a = AES (Wrap (ReaderT AESCtx (WriterT ByteString (Unwrap m)) a))
14:12:33 <Baughn> That's a monad transformer. Supposed to be.
14:12:46 <ski> oh
14:13:17 <ski> so you want `instance MonadReader r m => MonadReader r (AES m)' then, i suppose ?
14:13:31 <Baughn> Yep, preferably derived
14:14:06 <Baughn> Anyway, the outermost Wrap tag is required so the functions working with AES internally can /avoid/ the skipping
14:14:14 <Baughn> I.e. by calling unwrap
14:14:16 <ski> hm, this sounds more complicated that i first thought :)
14:14:31 <ski> (yes, i see)
14:14:55 <ski> (well, i don't see how `unwrap' or `wrap' would work, but i see the idea)
14:15:14 <ski> i wonder whether
14:15:38 <ski>   instance MonadReader r m => MonadReader r (Wrap (UnWrap m))
14:16:08 <ski>   instance (MonadTrans t,MonadReader r (Wrap m)) => MonadReader r (Wrap (t m))
14:16:10 <ski> would work ?
14:16:20 * Baughn surely doesn't know
14:16:39 <Baughn> What we need is someone like conal, to figure it all out. :)
14:16:46 <sm> hey all.. how can I strictly writeFile a new file, so that I can read it right away ?
14:16:56 <ski> (this would suppose that `UnWrap' is not in `MonadTrans', though ..)
14:17:05 <mauke> sm: writeFile is strict
14:17:10 <sm> hmm
14:17:15 <periodic> Baughn and Vulpyne: unamb isn't QUITE what I want, because I don't want it to toss out the side with a solution just because the other side finished first.  I guess i'm looking for some way to parallalize [Maybe a] -> IO a and return the first Just a found.  I'll keep looking around.  This is a good start.
14:18:00 <Cale> periodic: Just do a parMap perhaps, followed by msum?
14:18:05 <Cale> er...
14:18:12 <Vulpyne> periodic: Send results through a TChan maybe?
14:18:14 <periodic> Cale: Problem is it will evaluate all the threads, right?
14:18:21 <Vulpyne> Then you can consume them in the order they arrive.
14:18:32 <periodic> Vulpyne: That's what I'm thinking.  I just hoping for some magic.
14:18:42 <Cale> Or, wait, you want to parallelise the evaluation of a list, or parallelise the execution of an IO action?
14:18:45 <Vulpyne> STM isn't magicy enough for you? :)
14:19:02 <periodic> Cale: parallel tree search returning as soon as any thread finds a goal node.
14:19:15 <Heffalump> is there any way to get from forall x . IO (Foo x) to IO (forall x . Foo x) ?
14:19:36 <periodic> Vulpyne: I'm just not very familiar with STM.  Guess it's a good time to learn.  I hear good things about Haskell STM.
14:19:41 <Heffalump> [I'm actually using a wrapper for forall x . Foo x, so the impredicative instantiation isn't an issue]
14:19:48 <dolio> Heffalump: If you could do that, then you could write unsafeCoerce.
14:20:12 <Heffalump> dolio: really? how?
14:20:17 <Cale> periodic: Well, why not pure parallelism with parMap then? Sure, you might waste some computation on sparks that don't get used, but it's only natural, since you don't know where the first solution will come, and even once you find it, you have to evaluate all the prior elements to determine that.
14:20:18 <dolio> Foo = IORef
14:20:19 <periodic> Cale: with the msum version, the solution could be the last element of the list produced by the parMap, and I'd hate to wait for all the other threads to finish to get an answer.
14:20:25 <Vulpyne> periodic: If you've ever had to use stuff like pthreads in C, it's wayyy easier. :)
14:20:39 <Heffalump> oh yeah, doh.
14:20:40 <Cale> periodic: You have to wait for all the other threads to know that it's the answer.
14:20:44 <Heffalump> thanks.
14:20:45 <massy> :/quit
14:20:51 <massy> exit
14:21:05 <Cale> periodic: At least, with the definition that you want the first solution in the list.
14:21:07 <periodic> Cale: That's just it, i have a function 'goal :: Node -> Bool' which runs in a small amount of time.
14:21:16 <periodic> Cale: so as soon as I visit a goal node, I know it.
14:21:22 <dolio> Heffalump: So, let someone know if you figure out how to do it. :)
14:21:30 <sm> can someone point out why http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13564 is failing then ?
14:21:31 <periodic> and I will take ANY goal node.  I just want to get it one fast.
14:21:47 <Cale> Well, okay. Then you really do want amb.
14:21:59 <Heffalump> dolio: :-)
14:22:13 <Vulpyne> But Baughn said "DOOM". :(
14:22:34 <Cale> DOOM?
14:22:54 <Vulpyne> Well, he said it probably wouldn't work reliably either due to bugs in unamb or GHC.
14:23:04 <Cale> not unamb, amb.
14:23:04 <periodic> Cale: Amb will return when the first one finishes executing.  So there is a chance that one side of the tree (let's just assume binary for now) will finish without finding a solution before the side which does have a solution.  So if I have 'findGoal :: Tree a -> Maybe a' I could get back Nothing when there is a solution.
14:23:07 <Vulpyne> Ahh.
14:23:23 <sm> ooh, writeFile requires the file to exist ?
14:23:28 <periodic> In my case I have a bounded-depth tree on which I'm doing depth-first search.
14:23:37 <Cale> (that is, this really ought to be in IO because it's not deterministic)
14:23:41 <periodic> Amb is much simpler than unamb.
14:23:54 <Vulpyne> sm: I doubt that.
14:23:58 <Botje> sm: it creates a file.
14:24:17 <Cale> periodic: Well, okay, maybe you want to write your own :)
14:24:21 <Botje> sm: _maybe_ laziness is affecting you somehow
14:24:24 <Botje> but that'd be weird.
14:24:40 <Cale> periodic: Basically, you create a thread for each computation you want to do, and you have a single MVar which they all try to write to.
14:25:05 <Cale> periodic: and the first one to write to it will cause the main thread to kill everything and capture the result
14:25:18 <periodic> Cale: right.  Just write to the Mvar when a solution is found and have all the threads bail if they see someone else found it.
14:25:36 <periodic> Oh, I could have the main thread watch the MVar and just return that?  I guess that's true.
14:25:36 <Cale> They'll naturally block if the MVar is already full
14:25:49 <sm> it is my writeFile call that's failing though
14:26:02 <periodic> Ah, and then I can use amb to parallelize instead of parMap.
14:26:03 <Cale> and the main thread pulls on the MVar immediately and blocks waiting for the result, and then right after that, kills off everything
14:26:05 <ski> Cale : or in a `NonDet' with `choose :: NonDet a -> IO a' :)
14:26:08 <ddarius> Cale: Only once they finish.
14:26:23 * Peaker wants to write a generic build system that understands that the dependency lists themselves are computed results and have their own dependencies, and should be cached, etc
14:26:55 <periodic> Sounds like it's time for me to learn about MVars! :D
14:26:56 <mauke> sm: what's in rulesfile?
14:27:03 <periodic> Thanks for the input, Cale.
14:27:22 <Vulpyne> I guess you could poll isEmptyMVar.
14:27:31 <Cale> Vulpyne: eh?
14:27:37 <Cale> Vulpyne: why?
14:27:46 <Cale> This shouldn't require any polling.
14:27:47 <Vulpyne> If you wanted to bale from the side of the searching threads.
14:27:51 <Vulpyne> Bail.
14:27:52 <Cale> Oh
14:28:36 <periodic> I'm seeing as either using parMap and having the search threads pool the MVar, or having main block and just letting it kill off the threads.
14:28:40 <sm> mauke: rulesfile is "test.rules". The file doesn't exist. initialRulesContent is ""
14:28:45 <periodic> pool = poll
14:28:49 <mauke> sm: are you sure it's "test.rules"?
14:28:53 <Cale> periodic: parMap wouldn't be used here
14:29:00 <sm> pretty certain, I just traced it
14:29:01 <Vulpyne> periodic: The latter is probably better.
14:29:08 <Vulpyne> I was just throwing random ideas out. :)
14:29:11 <Cale> periodic: This is entirely in IO. You're creating threads to do the evaluation anyhow.
14:29:23 <Cale> (explicitly, rather than implicitly with parMap)
14:29:27 <mauke> hmm, not linux. sm: does Mac OS have strace?
14:29:43 <periodic> Okay, I think that makes sense.  I only started parallel programming in haskell this morning. Lots to learn. :)
14:30:08 <sm> I've got my writeFile arguments backwards, haven't I
14:30:10 <sm> doh :)
14:30:15 <ddarius> :t writeFile
14:30:16 <lambdabot> FilePath -> String -> IO ()
14:30:37 <sm> mauke: strace is my utility for tracing showable things
14:30:38 <mauke> oh, d'oh
14:30:49 <Cale> periodic: Pure parallelism is good when you have a deterministic result. If you want a nondeterministic result, then at present your best bet is some sort of concurrency.
14:30:50 <sm> thanks for the help, all
14:31:20 <periodic> Cale: Ah, I see.  The nondeterminism has to happen in IO.
14:31:28 <periodic> Makes sense.
14:31:51 <periodic> Gotta go to a meeting now.  I'm sure I'll have more questions over the next day or so.  Thanks agian.
14:31:55 <Cale> periodic: Using par is nice when you can get away with it though, because you know that it's semantically safe for free. Replacing y with par x y never changes the meaning of your program, only its performance.
14:33:53 * hackagebot upload: monadLib 3.6.1 - A collection of monad transformers. (IavorDiatchki)
14:35:10 <dons> crikey
14:38:11 <dolio> @yow!
14:38:11 <lambdabot> Couldn't find fortune file
14:57:44 <Kim^Walkman> How do you upgrade all “non-core” packages with cabal?
14:58:15 <Kim^Walkman> Assuming I don't know which ones are core and not.
15:04:43 <dons> upgrade to latest ones on hackage?
15:05:25 <Kim^Walkman> Yep!
15:05:59 <Kim^Walkman> Using “cabal upgrade” I get a list o packages, but for example I know “network” is a core package, no?
15:06:14 <Kim^Walkman> I don't know which ones are safe to upgrade to the latest hackage version
15:09:29 <jmcarthur_work> i typically will always upgrade executables but will only upgrade libraries as i use them
15:23:31 <fpz> does ghc support extensible records (trex for example)?
15:26:05 <copumpkin> no
15:26:05 <SamB_XP> fpz: no :-(
15:26:27 <fpz> hm, ok
15:26:29 <fpz> thanks
15:32:35 <narens> Could someone explain to me how Memocombinators remember values? I've been staring at the data-memocombinators code in hackage and I don't even understand how Memo Bool works. How can just putting a where clause make it cache the value?
15:33:15 <napping> must be something like memo f = (\->..) where cache = ...
15:33:27 <napping> So the where applies to the application that memoizes your function
15:33:43 <napping> and scopes over all uses of the memoized thing - not that I've ever heard of data-memocombinators
15:34:08 <narens> bool :: Memo Bool
15:34:08 <narens> bool f = cond (f True) (f False)
15:34:08 <narens>     where
15:34:08 <narens>     cond t f True  = t
15:34:11 <narens>     cond t f False = f
15:34:22 <narens> how does that prevent recalucating f True
15:34:43 <napping> because the function returned is cond (f True) (f False)
15:34:59 <narens> doh!
15:35:03 <narens> nvm
15:35:16 <nomeata> Hi. In $( fun [d| ... |] ), do the escaped definitoins pass through the typechecker before being passed to fun?
15:35:24 <nomeata> If so, is there a ways to avoid that?
15:35:30 <narens> napping: thanks
15:35:35 <napping> the terms in the brackets are typechecked, yes
15:36:02 <napping> you might look at using Language.Haskell and parsing a string yourself, but it might be a bit of trouble mapping it back to things in scope
15:36:37 <napping> I don't understand how the identifier stuff works in TH/GHC internals
15:37:14 <nomeata> :-(
15:37:35 <napping> if you do the simple string->ident thing it should just catch whatever's in scope
15:37:44 <narens> napping: so, I should be able to use a Data.Map internally to memoize rightsince it is lazy? So, for example if I wanted to do this for integers.
15:37:59 <napping> dunno how you'd do a really proper job if you wanted to allow qualified names in the text and stuff
15:38:12 <napping> narens: map isn't lazy like that, just in the values
15:38:56 <nomeata> napping: hmm, too bad. My function would actually make it type check, but of course it’s too late at that point
15:39:15 <nomeata> napping: is type-checking necessary to resolve names?
15:39:57 <napping> I'm not quite sure what you mean, but in the Q monad you can look up info for identifiers
15:41:38 <napping> I meant haskell-src-exts
15:42:44 <napping> like $(f (parseDecl "...")) v.s. $(f [d| ... |])
15:43:01 <napping> It's a bit strange [| |] does typechecking when the AST itself isn't particularly typeful
15:49:53 <wio> hi
15:49:59 <wio> can someone help me with polynomials?
15:50:27 * mauke cackles madly
15:50:57 <DevHC> hi
15:51:07 <DevHC> what about code hot swapping in haskell?
15:51:26 <DevHC> is it possible / how far is it from being implemented / is someone trying to implement it ?
15:51:39 <napping> hs-plugins
15:51:44 <napping> you can at least get loading
15:51:53 <dons> it is possible, has been possible for about 5 years. not widely used.
15:52:01 <napping> you have to code some state juggling yourself to really get swapping
15:52:19 <dons> there are several approaches.
15:52:26 <lispy> dons: does the stuff xmonad does with plugins count?
15:52:35 <mauke> xmonad has plugins now?
15:52:43 <lispy> Er, the contrib stuff
15:52:49 <nomeata> napping: thanks for your comments. I posted a description of my problem on haskell-cafe now.
15:52:50 <lispy> I think of those as plugins
15:52:58 <mauke> those are normal modules (static libraries)
15:53:08 <lispy> How does Mod-q work then?
15:53:11 <dons> xmonad serializes state and reforks itself.
15:53:19 <mauke> lispy: it recompiles xmonad and runs it
15:53:20 <lispy> Does it kill the existing process and fork a new one?
15:53:25 <dons> a very aggressive form of hot swapping. it won't preserve network connections etc.
15:53:26 <mauke> lispy: no, it just does an exec
15:53:40 <dons> while say, yi's model does preserve volatile state
15:54:25 <lispy> dons: you have some published paper about what yi does.  Where did those go.  Maybe DevHC wants to read them
15:54:31 <Lemmih> dons: Had a chance to look over my proposed addition to 'binary'?
15:54:40 <lispy> hey Lemmih
15:54:55 <lispy> Lemmih: So you pretty much stopped on LHC these days?
15:55:54 <dons> Lemmih: i've read it once, seems sensible. need to think some more about the consequences.
15:57:58 <wio> hey, any help with polynomials?
15:58:02 <wio> how to implement them?
15:58:29 <h20xt> wio: list of coeefficents?
15:58:40 <wio> probably
15:58:59 <Lemmih> lispy: Kinda. Pretty much the only things left to do are infrastructure tasks. And they are nearly impossible to get correct and are boring as hell to work on.
15:59:07 <h20xt> http://old.nabble.com/Convolution-td20389851.html
15:59:13 <lispy> Lemmih: hehe
15:59:13 <wio> but I would have to print them for example "a^3b^5 + 9xca - 6x^2"
15:59:24 <h20xt> gives a quick way of doing convolution, which is basically polynomial multiplication
15:59:38 <lispy> Lemmih: Were you getting interested in the supercompilation stuff or is that me misremembering?
15:59:45 <h20xt> yeah, just zip the coefficient list with the monomials
15:59:51 <napping> Lemmih: check splices, apply LN2, calibrate magnets?
15:59:54 <DevHC> :(
16:00:14 <ralph_> I have to study math, but I want to write haskell instead.
16:00:26 <ralph_> It's like:  They're the same thing, but not really.
16:00:47 <DevHC> dons: so it's basically not much better than restarting the binary?
16:00:59 <Lemmih> lispy: I did plan to try some GRIN supercompilation but never got around to it.
16:01:33 <napping> DevHC: what are you trying to do? You can do things at finer grain with dynamic loading if you need to
16:01:46 <napping> DevHC: but nothing like "become:" or "monkey-patching"
16:02:23 <dons> DevHC: ?
16:02:30 <napping> although I have failed thus-far trying to figure out enough of the GHC API to make something like a GHC that preserves bindings across :R
16:02:42 <dons> DevHC: the xmonad approach is to serialize all state dynamically and refork. however, that's not the plugins-based approach.
16:02:43 <DevHC> well for example if there's a network server with bugs, is it possible to fix bugs without forcing client disconnection?
16:02:48 <dons> which is to unload and reload new code on the fly.
16:02:52 <dons> yes, of course.
16:03:17 <napping> how *does* it store the environment?
16:03:18 <dons> like i said, there are many ways to achieve this.
16:03:19 <DevHC> so what was that "aggressive" swapping u talked about?
16:03:23 <dons> this paper describes the approach, http://www.cse.unsw.edu.au/~dons/papers/SC05.html
16:03:29 <DevHC> kthx
16:03:31 <dons> using code hotswapping
16:03:47 <dons> napping: xmonad?
16:03:54 <napping> no, ghci
16:04:00 <dons> ah sorry
16:04:06 <Lemmih> lispy: I hope to write a paper about generalized constructor specialization.
16:05:18 <napping> DevHC: it's much easier to make new connections get the new code and open sockets continue to be served by original code
16:06:14 <DevHC> could u explain that a bit more?
16:06:32 <ralph_> Is xmonad a windows manager?  I just installed ubuntu.  How can I find out what my windows manager is?  How easy would it be for me to use xmonad and what kind of committment would it take?
16:06:35 <rasfar> any suggestions for a haskell package (available with darcs) with a lengthy and interesting patch history?  i've looked at xmonad only so far.  moving on to yi now.  i'd hate to overlook something really yummy...
16:06:56 <stroan> rasfar: gnome
16:06:58 <stroan> most likelt
16:07:00 <stroan> likely
16:07:21 <rasfar> gotta be haskell source code.  does gnome use darcs?? wow
16:07:27 <DevHC> the server is a large connection center between all clients, and other clients receive data about some other cliens from the server
16:07:48 <stroan> rasfar: sorry, I meant ralph_
16:07:52 <dons> ralph_: visit xmonad.org
16:08:06 <stroan> typed ra and tab completed and didn't check
16:08:07 <napping> DevHC: if it's something like you have one process listening, and it forks a thread for each connection, it's easy to load code for a new dispatcher and get the old one to hand the socket over
16:08:20 <rasfar> np
16:08:44 <napping> DevHC: It's more complicated to bundle up an intermediate state in the handlers so they can hand it over to new code. And if you've got something like a webserver with mostly short-lived connections that's plenty
16:09:48 <DevHC> ok onto the concrete example
16:10:19 <napping> kinda like Erlang. In Erlang you can reload code, but only module-qualified calls will go the new code, threads busy calling around between local functions don't get switched onto the new code (which may not even have the same private functions)
16:10:44 <DevHC> we have a game server to which about 20-30 client are connected at any point in daytime, and client connections could last from minutes to hours
16:11:46 <BONUS> hey dons, just going over some stuff with ze editor, was wondering, any reason why you used "typeclasses" in RWH as opposed to "type classes"?
16:13:23 <dons> BONUS: we just decided, iirc.
16:14:12 <rasfar> dons, any suggestion for haskell package with rich darcs revision history?
16:14:24 <BONUS> ah, ok
16:14:28 <lispy> Lemmih: cool.  I forward to seeing that
16:14:45 <lispy> rasfar: what do you mean rich ?
16:14:59 <rasfar> or anyone?  i'll ask again later.  seems reasonable to ask rather than browse endlesslly...
16:14:59 <lispy> rasfar: You want something where 'darcs changes' produces a lot of output?
16:15:14 <napping> DevHC: and? what do you want to change?
16:15:34 <rasfar> i think so.  basically, lots of authors and patches with many different dates.
16:15:42 <poe> ?hackage dyre
16:15:43 <lambdabot> http://hackage.haskell.org/package/dyre
16:15:50 <lispy> rasfar: well, darcs itself is on hackage
16:15:55 <poe> this package is interesting for dynamic reload
16:15:59 <lispy> rasfar: Been around since 2003, IIRC
16:16:04 <lispy> rasfar: thousands of patches
16:16:16 <rasfar> that's a good one; thanks lispy
16:16:29 <DevHC> ok this is an imaginary case, but:
16:16:31 <lispy> rasfar: xmonad would be another good one
16:17:16 <rasfar> xmonad is the one i used as proof-of-concept, it's working.
16:19:39 <DevHC> clients connect to the game server, start playing whatsoever... each client receives the network name of all other clients, but not the real one, but rather one taht the server truncated to max.35 chars, for example. ... at some time in life the players ask to have +5 max.chars, and the admin agrees. the code has to be hot-swapped while the server is running.
16:20:09 <dons> rasfar: ghc?
16:20:12 <dons> cabal
16:20:20 <dons> the base package.
16:20:56 <DevHC> next at some other point in life, the server gets annoyed by a bunch of people chosing nicknames with profanity. the decision is to implement an auto prifanity filter, rather than have an admin on watch 24/7
16:22:12 <napping> the second only affects new users, and the first case doesn't make much sense to me
16:22:30 <rasfar> dons: thanks
16:22:57 <lispy> rasfar: something that may make the darcs history even better is that the changes are missing encoding information and some entries have non-US locales.  I forget the exact detail but I think there is some non-utf8 unicode or some such
16:23:05 <DevHC> now this is an imaginary example in that i don't know what would a game server look like of ported to haskell, it's currently a C game engine running a bytecode state machine and call to it are done based on client activity and time, etc.
16:23:16 <DevHC> napping: why?
16:24:27 <DevHC> ok, at some point in life a bug has been discovered and needs fixing and it would be cool to have it fixed without forcing clients to disconnect
16:24:40 <lispy> DevHC: that sounds like the quake3 architecture
16:24:46 <DevHC> it is :P
16:25:02 <napping> I guess I'm saying that's something you have to build in
16:25:02 <lispy> DevHC: frag is a haskell clone, but it doesn't have a bytecode interpreter that I'm aware of
16:25:35 <DevHC> bytecode doesn't matter since the intent is to code the machine in haskell..
16:26:34 <napping> you can't just open an interpreter and start mucking around in a running program, unless you programmed in hooks with which to muck around
16:28:46 <DevHC> provided taht i have the necessary hooks (in my running haskell program, not bytecode state machine), and i don't care about the neligible performance loss versus full optimization
16:28:57 <lispy> DevHC: Yeah.  I've always wondered how Everquest/WoW/Eve et al solve these problems.  I have this mental model that they come up with DSLs for content and then store that in databases and they can purge the server memory and load new stuff dynamically so that for most patches they don't have to reboot
16:29:01 <dons> haskell's hotswapping uses native code, fwiw
16:29:05 <dons> you can also use bytecode
16:29:15 <dons> but that's one of the nice benefits -- compiled code swapping == full speed.
16:29:55 <napping> I mean indirection. It's not like when you call "addUser" it looks up the function from a global symbol table that you can patch
16:30:18 <lispy> DevHC: you might like the research that went into make a hot patchable linux kernel.  I forgot the name of the guy that did that work though...
16:30:30 <DevHC> :o
16:31:07 <napping> so to do in Haskell your code needs to provide the layer of indirection
16:31:09 <Peaker> Linux's kexec allows for a really fast reboot -- can replace the entire kernel
16:31:22 <rasfar> lispy: thanks for the suggestion.  maybe we can discuss it in #darcs over the weekend
16:31:39 <lispy> rasfar: sure.  I'm frequently there.
16:37:48 <lispy> rasfar: I'm curious what you need it for.  Eg., what are you working on?
16:38:44 <visof> how can i convert float to int ?
16:39:01 <ivanm> @hoogle (Floating f) => f -> Int
16:39:01 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
16:39:02 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
16:39:02 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
16:39:05 <ivanm> bah
16:39:10 <ivanm> visof: round, trunc, ceil, etc.
16:39:13 <ivanm> @type round
16:39:13 <Lemmih> visof: truncate, round, floor, ceiling.
16:39:14 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:39:24 <rasfar> lispy: source code evolution visualisation
16:39:34 <napping> DevHC: basically, I'm saying Haskell is not lisp. You've workable primitives at the level of (loadFunction :: (Typeable a) => FilePath -> String -> IO a) for grabbing new code as a higher order value
16:39:37 <lispy> rasfar: on, really cool
16:40:00 <ivanm> rasfar: what are you using for the actual visualisation?
16:40:18 <rasfar> thanks! i'm a bit busy tonight but hopefully I can show you something over the weekend.
16:40:35 <rasfar> the frontend is C/GLUT ... wish it was Haskell...
16:41:20 <napping> DevHC: so if you've written a program in such a way that it already has a few versions of something and you can switch between them at runtime it shouldn't be hard to load up an additional implementation dynamically, but you need to think a bit ahead of time
16:42:37 <DevHC> talk about 'think a bit ahead of time'
16:43:02 <DevHC> if we look at basic scripting languages, for example:
16:43:53 <DevHC> tribes2's c-like scripting, where:
16:43:59 <DevHC> $somerandomvar, $myarray[myindex], etc are global variables
16:44:05 <wio> wtf
16:44:09 <napping> basically, be able to make whatever changes you want just by calling functions that exist in your program
16:44:14 <wio> my instance Show is giving me an error all the time
16:44:19 <wio> it worked 10 minutes ago
16:44:35 <wio> It could refer to either `Teht.show', defined at Teht.hs:11:0 or `Prelude.show', imported from Prelude
16:44:38 <wio> ????
16:44:48 <wio> why would it refer to Prelude.show
16:44:53 <wio> I just don't get it
16:45:10 <DevHC> yes
16:45:47 <DevHC> vars & functions are indentified by names
16:46:18 <DevHC> any function can refer to any of the global vars and (re)define any function
16:46:33 <mauke> wio: that sounds like you defined another show, not an instance of Show
16:46:50 <wio> that's the only thing I have
16:46:57 <napping> so if you've got an upgradePhysics :: PhysicsEngine -> IO () you are golden. If you just have a bunch of code calling PhysicsEngine.foo, well, you can't write ordinary Haskell code to reach in and change the functions of a module by name so simple dynamic loading won't get you that either
16:47:04 <DevHC> of course if one function changes the argumentcount of some function, then there will be script errors at the time of calls to the function :)
16:47:12 <mauke> wio: what is the only thing you have?
16:47:18 <wio> only Show
16:47:31 <wio> instance Show dataType where plaaplaa
16:47:33 <mauke> wio: just 'Show' is a syntax error
16:47:42 <mauke> wio: that's another syntax error
16:47:59 <ivanm> wio: did you import some other module elsewhere?
16:48:05 <ivanm> and Prelude.show is what you want
16:49:41 <DevHC> that was just an example to show how it's possible in some languages
16:50:12 <wio> ivanm: I got it
16:50:16 <wio> about indentation
16:50:18 <DevHC> heck, during runtime, users can even type their own statements in the console
16:50:18 <copumpkin> "Fixpoints of group actions on categories give category of coupled collections of algebras that are coalgebras"
16:50:39 <ray> there's a tongue twister
16:50:43 <copumpkin> :P
16:51:02 <ray> she sells coupled collections of algebras that are coalgebras by the seashore
16:51:03 <mauke> .oO( llections of coalgebras )
16:51:09 <DevHC> (and of course, alter any variable, redefine any function [in 1 line :P], execute other functions)
16:51:28 <napping> DevHC: yeah, you can't do any of those things in Haskell
16:51:41 <DevHC> too bad
16:51:45 <DevHC> so what CAN i do?
16:51:53 <ray> @faq can you do any of those things in haskell?
16:51:54 <lambdabot> The answer is: Yes! Haskell can do that.
16:51:56 <napping> basically, import new values including functions and things
16:52:04 <DevHC> :D
16:52:28 <napping> the pure functional extends to reflection
16:52:50 <DevHC> now how do i USE those new functions if i have to update the code to make taht code call those functions?
16:52:54 <napping> you may be able to look around, but you can't change things like what function is meant by (==) at type Bool
16:53:16 <DevHC> no not so radical changes
16:53:26 <napping> As with any language, you know the program will only do things statically apparent in the source
16:53:42 <DevHC> ?
16:53:52 <napping> It's statically apparent that a lisp program may be savaged from a REPL at runtime
16:54:04 <DevHC> ? :D
16:54:28 <DevHC> i don' know lisp
16:54:29 <dolio> Savaged?
16:54:41 <DevHC> ololl;>
16:54:59 <napping> Think (seq eq #'<)
16:55:12 <napping> (setq eq #'<), rather
16:56:26 <napping> Well, one thing you can do is load up a new copy of just about everything and call into it, and then control flow just continues in the new code
16:57:48 <napping> wow, TagSoup is much faster than HXT's xpath
17:04:41 <gwern> napping: it does much less, if you will
17:04:41 <gwern> less is faster :)
17:18:48 <copumpkin> sure is quiet in here tonight
17:18:52 <aeron> well
17:18:54 <aeron> i'm here now :)
17:19:00 <copumpkin> LET'S MAKE SOME NOISE!
17:19:04 <aeron> haskell sux lolo
17:19:40 <aeron> quick, someone point me to the definitive article on arrows :)
17:22:48 <Niccus> I don't think there's one yet but there are a few with very helpful pictures
17:23:52 <aeron> well, anything you know of that you think may be helpful?
17:24:45 <djahandarie> aeron, >>= that way!
17:25:15 <ClaudiusMaximus> my FAuSt-alike in Haskell seems to work! yay!
17:26:42 <Niccus> aeron:  http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
17:30:27 <osaunders> Greetings my fellow Haskellers.
17:36:21 <Niccus> > let (^-^) =0 ; (+: )=x ;o =[] ;x =3 in (^-^) :3 :x :( +:) :o
17:36:22 <lambdabot>   [0,3,3,3]
17:37:53 <Rotaerk> Niccus, you must be bored :P
17:39:40 <aeron> Niccus: thanks for the link
17:41:17 <aeron> Unrelated, I've got a problem with cabal, trying to install haskell-src-exts on Fedora. It claims I need happy ver. >= 1.17 but I don't have it, but I can successfully install happy 1.18.4, but then I go back and try and install haskell-src-exts again and it only repeats the error. I've had this go on and off but I can't remember what I did before to solve this. Any thoughts?
17:41:33 <aavogt> that's because happy isn't in your path
17:41:48 <aavogt> export PATH=$PATH:~/.cabal/bin
17:41:51 <aavogt> or some such
17:51:54 <copumpkin> People I wish to lure to IRC (more often): pigworker, sigfpe, psykotic, and SPJ
17:52:09 <ivanm> preflex: seen sigfpe
17:52:09 <preflex>  Sorry, I haven't seen sigfpe
17:52:11 <copumpkin> (and 808140)
17:52:15 <ivanm> preflex: seen SPJ
17:52:16 <preflex>  Sorry, I haven't seen SPJ
17:52:16 <copumpkin> preflex: seen dpiponi
17:52:17 <preflex>  Sorry, I haven't seen dpiponi
17:52:21 <ivanm> copumpkin: who's 808140?
17:52:23 <copumpkin> he was here several months ago
17:52:29 <ivanm> preflex: uptime
17:52:31 <copumpkin> ivanm: some random dude on reddit who posts awesome comments
17:52:34 <ivanm> heh
17:52:45 <ivanm> as long as grauen* doens't come here
17:52:48 <copumpkin> lol
17:53:01 <copumpkin> he posted one thing I agreed with once
17:53:02 <Cale> I sometimes think it'd be cool for SPJ to use IRC, but that would probably take time away from putting cool stuff into GHC :)
17:53:11 <mauke> preflex's uptime isn't very useful because it keeps no (permanent) state
17:53:40 <Windcape> hi, if I define following: data User { username :: String }, how do I make a instance of User with a given value for the username ?
17:53:57 <mauke> User{ username = "Windcape" }
17:54:09 <Cale> Windcape: that's a syntax error as you wrote it, btw
17:54:32 <Windcape> yeah, sorry data User = User { username :: String }
17:54:33 <Cale> data User = User { username :: String }  -- would work though
17:54:34 <Cale> yeah
17:55:02 <ivanm> copumpkin: yeah, something non-haskellian the other day was good
17:55:10 <copumpkin> ?
17:55:15 <ivanm> Cale: hasn't he come online on #ghc very rarely
17:55:17 <Cale> You can either write it as mauke showed, or you can use the plain syntax
17:55:20 <aeron> okay, so now cabal is not letting me install Leksah as it says I need regex-base ver 0.72.02, but I've got 0.93.1.. I can even get the older version installed, but the Leksah install doesn't work. Any thoughts?
17:55:25 <Windcape> I'm also wondering, why doesn't it allow Username, ie. with a capital U ?
17:55:28 <ivanm> copumpkin: me speak English goodly! :s
17:55:28 <Cale> User "foo"
17:55:36 <copumpkin> ivanm: :)
17:55:50 <Cale> Windcape: because only data constructors are allowed to have names starting with an uppercase letter
17:55:52 <ivanm> copumpkin: I was trying to say that something he (grauen*) said the other day on a non-haskellian topic was good
17:55:56 <copumpkin> oh ok
17:56:01 <mauke> Cale: and type constructors!
17:56:02 <copumpkin> bonch is the worst
17:56:12 <ivanm> the drinking guy?
17:56:16 <Windcape> Cale oh, thanks.
17:56:19 <aeron> bonch has cut most of that shit out, thankfully
17:56:21 <Cale> Well, yes, though type constructors live in a separate world :)
17:56:21 <copumpkin> yep
17:56:43 <Windcape> btw. I can't for the life of me find a online tutorial that describes how to use data structures, everything is stupid commandline evaulatation one-liners.
17:56:50 <Windcape> any idea where to look?
17:57:00 <aeron> Windcape: data structures in general?
17:57:04 <Cale> Well, have you seen LYAH and RWH?
17:57:13 <Cale> @where lyah
17:57:13 <lambdabot> http://www.learnyouahaskell.com/
17:57:16 <Windcape> aeron well, for instance, how to use the 'data' keyword
17:57:16 <Cale> @where rwh
17:57:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:57:24 <Cale> @where yaht
17:57:24 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
17:57:28 <Cale> @where wikibook
17:57:28 <lambdabot> http://en.wikibooks.org/wiki/Haskell
17:57:56 <poe> http://www.haskell.org/haskellwiki/Blog_articles/Data
17:58:07 <poe> lots of Data articles :)
17:58:32 <Cale> http://haskell.org/onlinereport/decls.html#sect4.2 -- or if you're more hardcore :)
17:58:50 <Windcape> well, that's technically definitions
17:59:08 <Windcape> but for example, they usally don't explain how to say, print a property of a user defined data structure.
17:59:30 <aeron> Windcape: to which link are you referring?
17:59:33 <Windcape> like print myUser[userId] , so I find it annoying having to guess the syntax.
17:59:50 <BONUS> LYAH has some data structures in chapter 8
18:00:02 <Cale> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types
18:00:05 <BONUS> otherwise the wikibook is cool, and also RWH and Purely Functional Data Structures
18:02:09 <Cale> Windcape: There are two options for extracting values from a piece of data that you built. You can pattern match on it, binding the fields that you're interested in to variables, or, if you defined the data type using record syntax (like that User type above), the field names are automatically associated with functions for extracting the given fields.
18:02:31 <Cale> That is, you automatically get a function  username :: User -> String
18:03:28 <Cale> Which can be slightly confusing, since the data declaration says  data User = User { username :: String }, but that type is the type of the field, rather than the automatically-defined extractor function.
18:03:49 <Cale> Windcape: make sense?
18:04:55 <Windcape> trying to make it make sense ;)
18:05:22 <aeron>  "Warning: This package indirectly depends on multiple versions of the same
18:05:22 <aeron> package. This is highly likely to cause a compile failure.
18:05:22 <aeron> package leksah-0.6.1 requires regex-base-0.72.0.2
18:05:22 <aeron> package regex-posix-0.94.1 requires regex-base-0.93.1
18:05:22 <aeron> package regex-compat-0.92 requires regex-base-0.93.1"
18:05:41 <Windcape> I still can't see how to do something like: main = print username myUser
18:05:52 <mauke> Windcape: main = print (username myUser)
18:05:54 <Cale> main = print (username myUser)
18:05:59 <mauke> also, putStrLn
18:06:15 <Cale> Both will work, but print will quote the string
18:06:27 <allbery_b> nggggggggggggggh. suppressing urge to accuse <redacted> of confusing mathematical rigor with religious "Truth™"
18:06:40 <Cale> allbery_b: huh?
18:06:55 <Cale> allbery_b: Some kind of platonist?
18:07:19 <allbery_b> the "Is Haskell A Fanatic" thread.  so far I think he's got that arrow pointing the wrong way
18:07:36 <mauke> Cofanatic?
18:07:43 * copumpkin hides
18:07:44 <Windcape> ah, parenthesis, cheers
18:08:00 <Cale> oh, I haven't been following the mailing lists in a long long time
18:08:04 <copumpkin> Cale: lucky you
18:08:11 <copumpkin> you avoided John D Earle
18:08:18 * Cale has 8070 unread Haskell Cafe threads
18:08:33 <Cale> No, actually I didn't. I still have H' going to my inbox
18:08:49 <Nafai> copumpkin: Heh, was that the "Fanatic" guy?
18:08:54 <Cale> Er, well, I didn't miss his posts to that anyway.
18:08:55 <copumpkin> yeah, among other things
18:08:55 <dolio> I don't really understand what "rigorous" means that it'd apply to OCaml's type system and not Haskell's.
18:09:01 <copumpkin> he also filled up the H' list
18:09:33 <allbery_b> yes, and was invited to move it to cafe instead
18:09:52 <dolio> copumpkin: Did you read the H' mails?
18:10:00 <copumpkin> dolio: only a couple of them
18:10:05 <copumpkin> they didn't seem too ridiculous at first
18:10:06 <dolio> Did they make any sense?
18:10:34 <copumpkin> well, maybe they were
18:10:47 <copumpkin> his first email ended in: "What Simon wrote caused me to reflect on its meaning for a time. I feel that what Simon is saying is that if you value the truth, you will be willing to suffer for it. Apparently, Cynbe is not willing to suffer. As such the Pagan motif is appropriate. "
18:11:06 <copumpkin> "If computer programs are speech as in a form of literature, the preparation of speech under constraints is poetry. "
18:11:42 <copumpkin> http://snapplr.com/ww8d was almost something I could agree with
18:11:47 <Cale> In the context of that mailing list, it's completely unhelpful and useless.
18:11:58 <copumpkin> definitely
18:12:07 <copumpkin> that's why he was "invited" to move elsewhere
18:14:57 <copumpkin> anyway, definitely a crackpot
18:15:20 * allbery_b yields to temptation, none too guardedly
18:15:25 <Cale> It always amazes me how people get like that
18:15:38 <allbery_b> "tenure"
18:15:58 <Cale> Is he tenured somewhere?
18:16:01 <allbery_b> (says a sysadmin for a bunch of EE faculty...)
18:16:05 <copumpkin> I sure hope not
18:16:08 <allbery_b> sure sounds like it
18:16:53 <Cale> Most of the tenured people I've ever met were far more coherent.
18:17:39 <copumpkin> I can't say I've ever noticed anything seriously weird in tenured profs
18:19:04 <dolio> I googled his name, but nothing came up.
18:19:10 <copumpkin> yeah, same
18:19:14 <dolio> There's an oncologist with the same name.
18:20:47 <copumpkin> allbery_b: by invited, I meant that he appeared randomly on the H' list, and Simon Marlow eventually "invited" him to haskell-cafe (i.e., told him to stop spamming nicely)
18:21:23 <copumpkin> sorry for confusion :)
18:21:56 <dolio> Do his essays start at 3, by the way? I don't have 1 and 2.
18:22:26 <copumpkin> 1 wasn't numbered
18:22:53 <copumpkin> http://snapplr.com/q6yb http://snapplr.com/6xvn
18:22:54 <BONUS> sent an email to haskell-cafe re: abandoning local let generalisation and GHCi
18:22:59 <dolio> Oh, he started inside some other thread.
18:24:33 <ivanm> you guys are talking about that annoying character on -cafe that writes everything on one long line ending in _______________________ ?
18:25:40 <BONUS> did the email arrive to -cafe? my mail client is weird with displaying my own emails on mailing lists
18:25:48 <copumpkin> yep
18:25:51 <copumpkin> I just got it :)
18:26:07 <BONUS> cool
18:26:35 <ivanm> BONUS: it's an option to -cafe as well
18:26:45 <ivanm> you can say that you don't want to receive emails you sent
18:26:53 <BONUS> ah. i didnt know that
18:27:22 <ivanm> BONUS: what nationality are you? from your surname, I'm guessing czech or something...
18:27:51 <BONUS> i'm bosnian
18:28:01 <BONUS> but yeah, same thing basically :)
18:28:10 <ivanm> ahhh
18:28:26 <ivanm> as in bosnian-bosnian, serb-bosnian, croat-bosnian or other-bosnian? :p
18:29:17 <BONUS> just bosnian :) i don't see the point of that segregation really
18:29:32 <tensorpudding> human is close enough
18:29:45 <ivanm> heh
18:29:57 <ivanm> BONUS: I wanted to make sure I didn't cause any possible offence ;-)
18:30:18 <ivanm> my dad and I were in Banja Luka a few months ago, and some drunk yobbo got up him for wearing a green shirt... >_>
18:30:19 <copumpkin> ivanm: where are you (or your parents) from? other than down under?
18:30:48 <ivanm> my maternal grandparents were refugees from Ukraine after WWII (captured by the Nazis during the war)
18:30:55 <BONUS> haha. yeah things like that happen sometimes, but you know how it is with programmers, we're usually a bit more sensible about those things
18:30:57 <ivanm> my dad is from Serbia, but he's half ukrainian to start with
18:31:12 <BONUS> if we get offended, it's about programming languages or something like that
18:31:15 <ivanm> BONUS: yeah, we discriminate on _programming_ language, not on how to spell milk or something! :p
18:31:24 <BONUS> exactly haha
18:31:40 <BONUS> death to imperative programming
18:31:57 <tensorpudding> infidels smiting the name of Lambda!
18:31:58 <copumpkin> functional languages > slavic languages
18:32:00 <copumpkin> duh
18:32:02 <BONUS> lol
18:32:06 <ivanm> heh
18:32:07 <copumpkin> apples > oranges, too
18:32:29 <franki^> indeed, down with oranges!
18:32:31 <poe> comparing apples to oranges, oh my
18:32:55 <copumpkin> instance GeneralizedOrd Apple Orange
18:33:12 <ddarius> Who gets offended about programming languages?
18:33:31 <copumpkin> a lot of people seem to take it personally if you "insult" "their" language
18:33:38 <tensorpudding> people get offended when people who don't know how to use a language insult it viciously
18:33:44 <ivanm> ddarius: stupid students who have an irrational hatred of haskell, lisp, FP, etc. without ever using it...
18:33:44 <tensorpudding> c.f. almost every C++ rant
18:33:46 <ivanm> >_>
18:34:05 <Niccus> prolog...
18:34:15 <ddarius> I just get frustrated and tired.
18:34:23 <tensorpudding> people saying haskell is useless because it was made by academics
18:34:34 * ivanm bought a book on prolog, but didn't understand wtf it was talking about... then again, it was only $1...
18:35:03 <ddarius> You got months worth of kindling for a dollar.  Sounds like a good deal.
18:35:09 <BONUS> i think it's mostly people who still think it's about knowing *programming languages* instead of knowing *programming*
18:35:11 <dolio> Anyone who knows anything knows Haskell is useless because it's over 6000x slower than other languages.
18:35:41 <ivanm> ddarius: heh
18:35:45 <ddarius> dolio: Haskell is exactly 6000 times slower than every language.
18:35:46 <ivanm> ddarius: no need for kindling here!
18:36:13 <ivanm> dolio: has to be over; they killed "hello world" in haskell because it was taking over a day...
18:36:14 <SamB_XP> ddarius: including itself ;-P
18:36:20 <Draconx> dolio, well, at least it's not over 9000 times slower.
18:36:26 <dolio> Heh.
18:36:35 <SamB_XP> Draconx: lol
18:36:36 <ddarius> SamB_XP was paying attention.
18:36:40 <tensorpudding> hmm, i must read the uncyclopedia entry on haskell again
18:36:41 <Cale> tensorpudding: To be fair, you don't need to know all that much about C++ in order to have plenty of ammunition ;)
18:37:00 <ivanm> Cale: for starters, the stupid name? :p
18:37:11 * allbery_b doesn't see why it matters in practice; Rails was wildly successful despite Ruby being pretty slow compared to Perl/Python/PHP
18:37:19 <tensorpudding> C++'s name is good
18:37:31 <tensorpudding> it emphasizes the fact that it was an obnoxious extension to C
18:37:40 <ddarius> Cale: The issue is people abusing a language and then complaining that their ineptitude is a facet of the language.
18:37:52 <ivanm> tensorpudding: heh
18:38:07 <tensorpudding> oh man
18:38:18 <tensorpudding> _|_ does look like someone giving you the finger
18:38:36 <Cale> ddarius: Yeah, that's never a great argument
18:38:49 * allbery_b thinks it's not so much obnoxious as obstreperous
18:39:42 * SamB_XP wonders how many people got the DBZ ref above ;-P
18:40:10 <dolio> SamB_XP: I thought it was pretty widely known.
18:40:20 <tensorpudding> my /ignore filters messages based on many criteria, including containing DBZ references
18:40:34 <SamB_XP> dolio: yes, but how man of them would have noticed it ?
18:41:36 <ivanm> SamB_XP: what reference?
18:41:42 <ivanm> then again, I never watched DBZ...
18:42:45 <ddarius> SamB_XP: I knew it was a reference to something.  Something stupid so my mental ignore filters kicked in.
18:43:11 <aeron> someone give me the most eloquent reason why haskell can outperform other languages :P
18:43:20 <ddarius> Because it's faster.
18:43:32 <Draconx> aeron, it can sometimes run an infinite loop in finite time.
18:43:38 <shachaf> @faq Can Haskell outperform other languages?
18:43:38 <lambdabot> The answer is: Yes! Haskell can do that.
18:43:39 <allbery_b> heh
18:44:05 <shachaf> Draconx wins, I think.
18:44:16 <aeron> :[
18:45:58 <Cale> aeron: Because it's just a language and the only thing which really determines performance is the implementation.
18:48:07 <SamB_XP> @faq is Haskell's power level over 9000 ?
18:48:07 <lambdabot> The answer is: Yes! Haskell can do that.
18:48:19 <copumpkin> aeron: purity gives a hypothetical compiler a lot more leeway to rearrange things in crazy ways without having to figure out complex interdependencies of effects
18:48:23 <ivanm> doesn't say if it is or not...
18:50:29 <Draconx> @faq Can Haskell raise its power level over 9000?
18:50:29 <lambdabot> The answer is: Yes! Haskell can do that.
18:50:37 <Cale> Yeah, I suppose the purity side of things comes into play with regard to making it easy to write efficient parallel implementations especially.
18:51:13 <Cale> (and designing APIs for parallelism and concurrency)
18:51:19 <copumpkin> and supercompilation is a lot easier
18:51:35 <copumpkin> still not easy though :)
18:52:33 <Windcape> Cale wouldn't you say it's less about purity , and more about the general aspects of functional programming , ie. immuability everywhere.
18:53:03 <Cale> Windcape: immutability is part of purity
18:53:13 <SamB_XP> Windcape: those are pretty closely related ;-P
18:53:20 <Windcape> in a way I guess. Mostly when I think purity, I think sugar
18:53:34 <Cale> "purity" around these parts is a nickname for referential transparency
18:53:35 <Windcape> like Java wanting to be pure, and not implement closures
18:53:58 <SamB_XP> Windcape: oh, that's called NIH
18:54:22 <Cale> That is, the property that if two functions produce equal results for every possible parameter, then one can be replaced with the other without affecting the result of the program.
18:54:22 <Windcape> ;-)
18:54:36 <Windcape> SamB_XP they did excuse it with purity though.
18:54:59 <Cale> That's a completely different sense of the word.
18:55:07 <SamB_XP> one of the properties of NIH is that people don't say when they're following the pattern ;-P
18:55:35 <Cale> Also, implementing closures isn't useful. What you really want is an implementation of functions.
18:56:04 <dolio> Uh oh, you brought up one of Cale's pet peeves.
18:56:05 <SamB_XP> Cale: well, what he's talking about is more-or-less functions...
18:56:19 <Windcape> well, I'd dare to say that closures makes people work more towards functional programming
18:56:23 <Windcape> at least, it did for me.
18:56:25 <Cale> (closures are an implementation mechanism for functions, sure, but that's a detail that only the compiler writers should care about)
18:56:51 <copumpkin> lol
18:56:52 <SamB_XP> Java, as you may be aware, does not *have* functions yet
18:57:03 <Cale> Java doesn't really have proper support for functions unfortunately, which sucks, yeah.
18:57:05 <SamB_XP> though I get the impression they're coming soon
18:57:56 <MoALTz> SamB_XP: due to fortress?
18:58:05 <Cale> On the other hand, Java's implementation may already use closures.
18:58:14 <SamB_XP> MoALTz: nothing of the kind
18:58:29 <Cale> (I wouldn't know, I haven't looked at it, but closures are also a popular way to implement objects)
18:58:49 <SamB_XP> MoALTz: they were implementing some library and they needed a ridiculous number of boilerplate classes, I think ...
18:59:17 * Cale feels tempted to coin the acronym "CANALF"
18:59:26 <Cale> "Closures are not a language feature"
18:59:32 <copumpkin> I actually guessed that
18:59:35 <copumpkin> yay me
18:59:46 <medfly> yay copumpkin
19:00:39 <dolio> You can get anonymous inner classes to capture (part of) their environment, so there's probably something like closures in there.
19:00:46 <SamB_XP> so something along the lines of a passing in a lambda instead of an object that implements a one-method interface is evidently in the works ...
19:01:07 <SamB_XP> shouldn't involve any JVM changes, right ?
19:02:54 <SamB_XP> dolio: why anonymous inner classes ?
19:03:30 <dolio> I think those are the only kind you can stick inside the body of a method.
19:04:49 <dolio> You could have a named inner class inside an anonymous inner class inside a method, I guess.
19:04:56 <dolio> But that's pretty convoluted.
19:05:28 <ddarius> SamB_XP: Haven't they thought about doing that several times now?
19:05:47 <ddarius> Of course now they have to copy C#.
19:06:08 <dolio> The latest proposal's been on the table for a while now.
19:06:43 <dolio> Getting shouted at because first class functions are too hard.
19:06:51 <SamB_XP> dolio: what I was looking at wasn't a proposal ;-P
19:31:04 <phr> :t (>>=)
19:31:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:35:06 <copumpkin> http://snapplr.com/awy4
19:35:48 <Niccus> what type wizardry is this
19:36:11 <ivanm> copumpkin: why not just pastebin that rather than screenshotting?
19:36:17 <copumpkin> ivanm: too lazy
19:36:37 <ivanm> heh
19:37:20 <ddarius> copumpkin: And if I go arity (BS.pack "foo") ?
19:37:41 <Niccus> what would happen on "arity printf" anyways
19:38:05 <copumpkin> *Main Data.ByteString.Char8> arity (pack "foo")
19:38:06 <copumpkin> 0
19:38:14 <ivanm> Niccus: heh
19:38:30 <Cale> What if functions were an instance of Num?
19:38:30 <copumpkin> http://snapplr.com/94v3
19:38:44 <ivanm> Cale: heh
19:38:50 <copumpkin> any polymorphic function type needs restricting, obviously :)
19:38:51 <ivanm> Cale: not sure if you can add arbitrary functions though...
19:39:11 <ivanm> copumpkin: OK, try arity (printf "foo") ...
19:39:20 <copumpkin> ivanm: the return type is still polymorphic
19:39:42 <ivanm> copumpkin: right, I"m just wondering how ghc manages to work out when it ends then...
19:39:48 <ivanm> copumpkin: where did you get arity from?
19:39:51 <ivanm> @hoogle arity
19:39:51 <lambdabot> No results found
19:39:52 <copumpkin> I just wrote it
19:39:52 <ivanm> :p
19:39:53 <tensorpudding> i tried to implement a Num instance for functions, but it wouldn't let me get by without an instance of Eq
19:39:58 <ivanm> copumpkin: how'd you do it?
19:40:02 <ivanm> tensorpudding: undefined
19:40:19 <tensorpudding> yeah, i defined (==) to be const False
19:40:28 <ivanm> I would guess that it'd only really work for (a -> a) ...
19:40:37 <copumpkin> ivanm: fairly simple, a13574
19:40:41 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13574#a13574
19:40:59 <tensorpudding> it would not be possible to test for equality of functions on types with infinite values
19:41:05 <ivanm> copumpkin: what's a13574 eant to be?
19:41:14 <copumpkin> ivanm: I accidentally only copied the end of the url
19:41:19 <ivanm> copumpkin: nice!
19:41:27 <ivanm> heh
19:41:27 <Niccus> whoa
19:43:01 * ivanm wishes "cabal upgrade" included executable-only packages as well...
19:47:01 <conal> BONUS: thanks for your "spreading out" tweet!  thanks for the giggles.  (http://twitter.com/bonus500/status/6324804419)
19:48:36 <roostaj> @conal ha ha that's great
19:48:36 <lambdabot> Unknown command, try @list
19:48:45 <copumpkin> we need a @conal command
19:48:50 <roostaj> :(
19:48:50 <conal> hah
19:48:59 <conal> :)
19:49:12 <roostaj> @list
19:49:12 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:49:39 <conal> copumpkin: it could just say "think more denotationally.
19:49:45 <conal> "
19:49:53 <Niccus> @_@
19:50:02 <copumpkin> > conal
19:50:03 <lambdabot>   think more denotationally
19:50:06 <copumpkin> in the mean time
19:50:26 <SamB_XP> I can proceed with my studies of conotational semantics!
19:50:40 <copumpkin> connotational?
19:50:41 <conal> SamB_XP: :)
19:50:59 <conal> copumpkin: how did you do that lambdabot trick?
19:51:09 <copumpkin> > text "think more denotationally"
19:51:10 <lambdabot>   think more denotationally
19:51:12 <copumpkin> :)
19:51:18 <SamB_XP> conal: private let
19:51:23 <bd_> :t text
19:51:24 <lambdabot> String -> Doc
19:51:27 <SamB_XP> :t conal
19:51:28 <lambdabot> Doc
19:51:32 <bd_> :i Doc
19:51:33 <conal> oh!  sneaky. :)
19:51:36 <bd_> aw :(
19:51:38 <copumpkin> that's me!
19:52:23 <shachaf> @what's-up Doc
19:52:23 <lambdabot> Unknown command, try @list
19:55:11 <roostaj> has anyone read "The Haskell Road to Logic, Maths and Programming" by Kees Doets and van Jan Eijck?
19:55:23 <dolio> > girard
19:55:24 <lambdabot>   Semantics is overrated.
19:59:49 * hackagebot upload: uri 0.1.1 - Library for working with URIs (JaroslavGridin)
20:16:24 <roostaj> @slap
20:16:24 * lambdabot beats up
20:17:23 <copumpkin> @slap herself
20:17:23 * lambdabot pokes herself in the eye
20:17:34 <copumpkin> @slap herself
20:17:34 * lambdabot slaps herself
20:18:09 <MoALTz> @slap her naught body
20:18:09 * lambdabot decomposes her naught body into several parts using the Banach-Tarski theorem and reassembles them to get two copies of her naught body!
20:18:23 <roostaj> oh ha ha
20:18:25 <roostaj> :D
20:18:27 <tensorpudding> ...
20:18:39 <jmcarthur> o_O
20:18:44 <tensorpudding> did you mean to put naughty as naught, or is that a really slick reference to null sets?
20:18:57 <MoALTz> alas it was a typo
20:19:46 <bnijk> i'm writing my first nontrivial haskell program tonight
20:20:05 <bnijk> a program that returns defitions from a wiktionary xml dump
20:20:06 <ddarius> tensorpudding: It's not possible to test for function equality on types with even finite domains, e.g. () -> ().
20:20:10 <bnijk> to CLI
20:20:17 <bnijk> ok it is trivial
20:20:26 <bnijk> but i'll put some cool stuff in there
20:20:28 <tensorpudding> ddarius: why not?
20:20:29 <Gracenotes> en.wiktionary? how big is that?
20:20:40 <bnijk> like 130 mb
20:21:30 <tensorpudding> you could say two functions f, g : A -> B  are equal if for each value x : A, f x = g x
20:22:02 <dolio> How you decide if id = let f x = f x in f?
20:22:19 <Cale> It's possible to decide equality of total functions on compact domains.
20:22:29 <copumpkin> pff
20:22:32 <ddarius> Cale: Which does not describe Haskell functions.
20:22:43 <tensorpudding> i'm not sure i follow
20:22:54 <copumpkin> tensorpudding: have you seen seemingly impossible functional programs?
20:23:13 <tensorpudding> seemingly impossible in what sense?
20:23:23 <Cale> ddarius: Well, doesn't describe all of them.
20:23:42 <copumpkin> @go seemingly impossible functional programs
20:23:42 <lambdabot> Maybe you meant: google googleit do
20:23:50 <copumpkin> @google seemingly impossible functional programs
20:23:53 <lambdabot> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
20:23:53 <lambdabot> Title: Mathematics and Computation » Seemingly impossible functional programs
20:24:01 <Cale> Usually when we talk about whether or not laws hold, we're a bit lax and only consider defined values though.
20:24:23 <tensorpudding> isn't cantor space infinite
20:24:32 <copumpkin> tensorpudding: hence the seemingly impossible
20:24:35 <Cale> It's infinite but compact
20:24:45 <tensorpudding> hmm
20:24:56 <tensorpudding> but there are finite sets which are not compact?
20:24:59 <toast-opt> But what can you not do with types and curried functions over those types?
20:25:04 <Cale> There are not.
20:25:20 <toast-opt> if you need Eq, then make your type Eq, and make that type curryable
20:25:26 <tensorpudding> so if A is finite, then shouldn't equality of functions A -> B be possible to determine?
20:25:30 <Cale> Er, there are finite topologies which are compact.
20:25:32 <Cale> er
20:25:34 <Cale> not compact
20:25:45 <toast-opt> instead of a -> b, type Foo in Eq and some Foo -> a -> b
20:25:56 <copumpkin> tensorpudding: @hackage enumerable
20:26:06 <tensorpudding> i've seen it
20:26:07 <copumpkin> :P
20:26:49 <Cale> tensorpudding: Basically, what causes problems is the inclusion of _|_ in the considerations
20:27:08 <ddarius> tensorpudding: Haskell functions are not total.
20:27:51 <Cale> Er, hmm...
20:28:22 <tensorpudding> so it's not defined on all values of a given type?
20:28:33 <tensorpudding> well, i suppose if _|_ is included, then that is obvious
20:29:03 <Cale> Well, I suppose we really should be more careful.
20:29:15 <Cale> Finite topological spaces are all compact in the traditional sense.
20:29:26 <ddarius> I would hope.
20:30:01 <Cale> We're really discussing whether there's a continuous equality testing function, I suppose.
20:30:03 <tensorpudding> what is the distinction you're making between "compact in the traditional sense"
20:30:46 <Cale> Either we need a new definition of compactness, or we should be careful about saying what we mean by 'equality testing'
20:30:54 <ddarius> I was trying to figure out how you would have an infinite set of distinct open covers at all for a finite topology.  The only thing I could think of was that "finite topology" meant something different from what I thought.
20:31:24 <Cale> (probably the latter)
20:31:26 <ddarius> Cale: See the synthetic topology work.  It should handle these issues directly.  Adding, e.g. the notion of overt.
20:31:35 <Cale> Yeah.
20:31:58 <Cale> I've skimmed that bit, but need to read it more carefully :)
20:32:31 <tensorpudding> two functions f,g : X -> Y is equal if for all x in X, f(x)=g(x)
20:32:50 <tensorpudding> that's the traditional meaning for two functions being equal
20:32:54 <Cale> tensorpudding: right.
20:33:21 <tensorpudding> trying to apply that to functions over Haskell types does not work, you say
20:34:58 <Cale> Well Haskell functions are all continuous
20:35:19 <tensorpudding> continuous?
20:36:10 <Niccus> what's _|_ again
20:36:11 <Cale> You can put a topology on any datatype, where the open sets are the subsets which it's possible to write a program that terminates if the element is in the set, and doesn't terminate if not.
20:36:21 <Cale> Niccus: nontermination
20:36:31 <tensorpudding> that's a really freaky topology
20:36:43 <Cale> tensorpudding: that is, the semidecidable sets
20:37:01 <augur> anyone have a passing interest in language/linguistics here? :x
20:37:37 <tensorpudding> Cale: where did that come from, by the way
20:37:47 <tensorpudding> I want to learn more about these things but there is no introductory treatment
20:37:49 <copumpkin> augur: lots of us :)
20:38:09 <Cale> There's a nice connection to the view of metric spaces -- imagine the metric topology as being induced by using "programs" which keep decreasing the size of the epsilon-ball around a point, and terminate if the ball ends up entirely in the set
20:38:19 <augur> copumpkin: how about linguistic semantics? wanna have some fun with semantics? :D
20:38:39 <copumpkin> augur: not now, but maybe some other time :P
20:38:44 <augur> aww :(
20:38:47 <Cale> tensorpudding: http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf
20:38:58 * copumpkin does enjoy languages a lot though
20:39:38 <Cale> tensorpudding: So you can sort of think of the open sets as the sets where if you work hard enough to make your tools precise enough, you'll be able to decide that any point which is in the set really is.
20:40:01 <Cale> tensorpudding: (ignoring matters of the real quantum world ;)
20:40:36 <tensorpudding> okay...
20:41:26 <tensorpudding> though this implies that there are subsets which are not decidable in this sense
20:41:40 <tensorpudding> (sets that are not open in this topology"
20:41:54 <Cale> Well, sure. In both the metric topology and in the topology on a datatype
20:42:32 <tensorpudding> well, i can see how a set isn't open in a metric, but it's harder to understand why some subsets of a type are undecidable
20:42:34 <Cale> In the metric topology, consider any set with a point that lies on the boundary -- that is a set such that any epsilon ball around it has some points outside the set.
20:42:39 <Cale> Okay
20:42:46 <Cale> So take the natural numbers for instance.
20:43:00 <Cale> There is a set of natural numbers corresponding to the halting Turing machines.
20:44:15 <tensorpudding> okay
20:44:29 <tensorpudding> how do you know what it is?
20:44:36 <Cale> Well, for any point in this set, it's possible to eventually determine that it really is in the set. Just run the corresponding Turing machine until it stops.
20:44:46 <shazam> @palomer
20:44:46 <lambdabot> I think vim is good for the rubbish bin
20:44:47 <Cale> But how about the complement?
20:45:03 <shazam> oh lord, I actually said that?
20:45:05 <shazam> @palomer
20:45:05 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
20:46:01 <tensorpudding> i guess the problem i'm seeing, is that what if the type has only one element
20:46:36 <tensorpudding> why is there no way to figure out if they functions are equal then
20:46:41 <Cale> tensorpudding: Then sure, every subset is both open and closed
20:46:54 <Cale> tensorpudding: But consider the type with just two values:  () and _|_
20:47:14 <Cale> The open sets are {}, {()}, and {(),_|_}
20:47:28 <tensorpudding> as an aside, is there a good use for ()?
20:47:42 <Cale> Sure
20:47:51 <Cale> :t putStrLn
20:47:52 <lambdabot> String -> IO ()
20:47:54 <tensorpudding> I see () in type signatures, and I assumed that it was the type of the value ()
20:48:00 <Cale> yep
20:48:01 <copumpkin> :t 1
20:48:02 <lambdabot> forall t. (Num t) => t
20:48:06 <copumpkin> :k 1
20:48:07 <lambdabot> *
20:48:09 * copumpkin whistles
20:48:27 <tensorpudding> so returning () just allows you to return something that is any type you want
20:48:36 <copumpkin> it returns ()
20:48:36 <Cale> er...
20:48:42 <copumpkin> () isn't special
20:48:45 <copumpkin> data () = ()
20:48:48 <Cale> () is just an empty tuple
20:49:11 <tensorpudding> hmm
20:49:27 <copumpkin> so you could do x <- putStrLn "ohai"
20:49:28 <Cale> tensorpudding: Because Haskell has general recursion everywhere, every type has this extra value _|_ representing a nonterminating value
20:49:30 <copumpkin> x would contain ()
20:49:50 <tensorpudding> so that nonterminating programs actually typecheck
20:49:52 <Cale> tensorpudding: The only open set to which _|_ ever belongs is the full space
20:50:02 <Cale> right
20:50:19 <tensorpudding> how does that work?
20:50:22 <Cale> We can't check that they're terminating anyway, once we've introduced general recursion
20:50:29 <tensorpudding> i did know that
20:50:48 <Cale> So we have to allow something like _|_ in our mathematical description of what values exist.
20:51:05 <Cale> Well, it's much more important in a language like Haskell with non-strict semantics
20:51:14 <Cale> because we can have lists like  1 : _|_
20:51:21 <Cale> which is not the same list as _|_
20:51:35 <tensorpudding> what happens when you try to actually apply something to _|_
20:51:44 <ddarius> > (fix id) 3
20:51:48 <lambdabot>   mueval-core: Time limit exceeded
20:52:12 <Cale> tensorpudding: If it pattern matches with a nontrivial (refutable) pattern on _|_, then you get _|_
20:52:31 <Cale> tensorpudding: But if it doesn't pattern match, you very well may get a meaningful answer
20:52:40 <Cale> > const 5 undefined
20:52:41 <lambdabot>   5
20:52:47 <tensorpudding> okay
20:52:53 <tensorpudding> :t undefined
20:52:54 <lambdabot> forall a. a
20:52:56 <Cale> > head undefined
20:52:57 <lambdabot>   * Exception: Prelude.undefined
20:53:02 <Cale> > head (1 : undefined)
20:53:03 <lambdabot>   1
20:53:04 <tensorpudding> so undefined is _|_, essentially?
20:53:07 <Cale> yeah
20:53:21 <Cale> Well, we glom errors and nontermination together
20:53:45 <Draconx> @let bottom = bottom
20:53:46 <lambdabot>  Defined.
20:53:49 <tensorpudding> can you get errors of kind that isn't nontermination?
20:54:19 <Draconx> :t bottom
20:54:20 <lambdabot> forall t. t
20:54:54 <Cale> tensorpudding: Well, you can represent your errors as values
20:55:04 <Cale> tensorpudding: If that's what you mean
20:55:05 <ddarius> model
20:55:08 <Cale> > error "hello"
20:55:09 <lambdabot>   * Exception: hello
20:55:21 <Cale> ^^ I mean we consider that to be the same _|_ as an infinite loop
20:56:03 <Cale> Because from the point of view of evaluating expressions, there's no way to catch the error, so it's like an infinite loop which has the nice property of letting you know and killing the program
20:56:27 <copumpkin> :t isBottom
20:56:29 <lambdabot> Not in scope: `isBottom'
20:56:41 <copumpkin> :)
20:56:54 <tensorpudding> i guess my question is pretty silly
20:57:00 <tensorpudding> i'm trying to find a coherent wording for it
20:57:21 <tensorpudding> the function error isn't what i'm talking about
20:57:27 <ddarius> @hoogle isBottom
20:57:27 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
20:57:54 <gwern> what
20:57:55 <Cale> hehe
20:57:58 <Draconx> @let isBottom x = seq x False
20:57:59 <lambdabot>  Defined.
20:58:18 <Draconx> > isBottom 5
20:58:19 <lambdabot>   False
20:58:22 <copumpkin> #ty isBottom
20:58:25 <lunabot>  luna: Exception when trying to run compile-time code:
20:58:29 <Draconx> > isBottom bottom
20:58:33 <lambdabot>   mueval-core: Time limit exceeded
20:59:44 <tensorpudding> eh
21:02:06 * ddarius rechristens Haskell 2010 as Haskell X.
21:02:23 <dolio> That's a better name.
21:02:48 <copumpkin> ooh!
21:02:48 <Veinor> So what's different in Haskelll 2010?
21:02:58 <copumpkin> Veinor: minor syntax changes and pattern guards
21:03:03 <copumpkin> + FFI
21:03:09 <gwern> it's a terrible name. now wolverine will come looking for us
21:03:10 <Veinor> link?
21:03:34 <ddarius> gwern: Wolverine is awesome though.
21:03:38 <kmc> Veinor, it codifies a few extensions that have existed in GHC forever
21:03:53 <Veinor> ahh
21:03:58 <Veinor> also, what's isBottom supposed to do?
21:03:59 <gwern> ddarius: and awesome at killing you
21:04:31 <ddarius> kmc: They don't all exist in GHC.
21:04:33 <kmc> > isBottom undefined
21:04:34 <dolio> We could switch to an all Roman numeral versioning system.
21:04:34 <lambdabot>   * Exception: Prelude.undefined
21:04:38 <kmc> ddarius, which ones are new?
21:04:42 <kmc> or not in GHC anyway
21:04:44 <dolio> Haskell X.VI.IX
21:04:55 <ddarius> gwern: If I'm going to be killed by a superhero, Wolverine is definitely the superhero I'd want to do it.
21:05:03 <Stinger> Haskell MMX
21:05:13 <gwern> ddarius: that's so gay -_-
21:05:16 <Stinger> just to be confusing
21:05:18 <Veinor> ah, found a list of which extensions
21:06:46 <Veinor> oh, awesome, HierarchicalModules is in
21:06:55 <ddarius> kmc: DoIfThenElse, NoNPlusKPatterns, LineCommentSyntax
21:07:37 <dolio> Hierarchical modules!? That's too much!
21:07:43 <copumpkin> so avant-garde
21:08:24 <gwern> hierarchical modules are so dead white euro male
21:08:30 <Veinor> also, PatternGuards
21:08:38 <Veinor> PatternGuards look sexy
21:08:39 <kmc> the trac page for DoAndIfThenElse says it's been implemented in GHC
21:08:45 <copumpkin> gwern: damn, I'm three of those
21:08:51 <Veinor> but which 3?
21:08:58 <copumpkin> who knows!
21:09:01 <Veinor> :O
21:09:04 <copumpkin> don't want to give away my identity!
21:09:07 <copumpkin> oh wait
21:09:22 <dolio> Well, he's obviously dead and male.
21:09:24 * gwern grabs mah shotgun
21:09:43 <copumpkin> imma chargin mah lazer
21:10:49 <ddarius> kmc: Then that was relatively recently and certainly not forever.
21:11:38 * kmc shrugs
21:12:14 <kmc> point is, this isn't like C++1x where nobody will implement it right for decades
21:12:25 <kmc> (since nobody's implemented C++98 right)
21:12:40 <dolio> 1x?
21:12:40 <ddarius> kmc: That's because all this crap is really minor.
21:12:42 <dolio> They've still got like 25 days left to release the standard.
21:13:06 <kmc> or, they can call it C++0A or C++0B etc.
21:14:12 * kmc is holding out for hegemonical modules
21:15:39 <toast-opt> my vote is on C++0C
21:15:47 <toast-opt> because C is my favorite hexadecimal number
21:16:05 <osaunders> Oh awesome my Logic for Dummies is ready to pick up.
21:16:53 * ddarius should write "Categorical Logic for Dummies"
21:17:09 <dolio> Yes, please.
21:17:30 <osaunders> Oh there's something I've been meaning to ask, what is isomorphism?
21:17:55 <ddarius> osaunders: Its a pair of arrows, f : A -> B and g : B -> A such that f . g = id and g . f = id.
21:17:56 <tensorpudding> i'm not strictly opposed to that title, though i'd feel guilty reading a math book that had the _ For Dummy's packaging
21:18:23 <ddarius> tensorpudding: Oh, I'd definitely want it to be in the "For Dummies" track.
21:18:46 <osaunders> ddarius: That's not nearly as interesting as I thought it would be.
21:18:51 <Cale> osaunders: depends on context, but basically it means that two things are identical as far as all the structure we care about.
21:18:51 <dolio> That might at least result in book stores carrying it.
21:19:21 <Cale> ddarius' definition is a general one which works in any category
21:19:41 <Cale> But to get a sense of what it really means, you have to specialise it to particular categories.
21:19:56 <osaunders> Cale: Asymtotically identical?
21:20:18 <BMeph> "Adjunctions for the Rest of Us!" :)
21:20:40 <Cale> osaunders: maybe in the right context...
21:21:40 <kmc> osaunders, for example, two graphs G and H are isomorphic if there's a bijection f from the vertices of G to the vertices of H, such that an edge in G from u to v exists if and only if an edge in H from f(u) to f(v) exists
21:21:48 <Cale> osaunders: Two vector spaces are isomorphic if there is an invertible linear map from one to the other. (Which means that they have the same dimension)
21:22:23 <osaunders> :/
21:22:41 <kmc> that is, G and H are isomorphic if you can match up their vertices 1:1, in such a way that matching vertices have matching edge structure
21:23:22 <kmc> osaunders, this means that they're "the same graph" in some sense
21:23:35 <kmc> if you don't care about what the vertices are called, but only how they connect
21:24:03 <osaunders> Okay.
21:24:24 <kmc> so in a lot of math, you identify some concept of isomorphism like this, and then you mostly talk about objects "up to isomorphism", meaning that you don't care about the difference between G and H if they're isomorphic
21:24:39 <osaunders> What branch of mathematics is this?\
21:24:46 <kmc> osaunders, any
21:24:50 <ddarius> All of them.
21:24:59 <Chris_____> question about pattern matching: why does "sub1 (x+1) = x" have type "Integral a => a -> a" instead of "Num a => a -> a"?
21:25:08 <kmc> :t let sub1 (x+1) = x in sub1
21:25:10 <lambdabot> forall t. (Integral t) => t -> t
21:25:12 <Cale> osaunders: The stuff about graphs is from graph theory of course
21:25:19 <copumpkin> Chris_____: because it's ugly
21:25:20 <kmc> :t let sub1 x = x-1 in sub1
21:25:21 <lambdabot> forall a. (Num a) => a -> a
21:25:26 <Cale> osaunders: Vector spaces are from linear algebra
21:25:36 <dolio> Chris_____: The way n+k is defined goes through Integer.
21:25:41 <Cale> osaunders: ddarius' original general definition was category theoretical.
21:25:49 <kmc> osaunders, "isomorphism" is a sort of meta-concept.  "graph isomorphism" is a concept in graph theory, "group isomorphism" is a concept in group theory, etc.
21:26:18 <ddarius> Category theory capturing this definition in one, simple notion is one of its successes.
21:26:38 <osaunders> Right, OK.
21:26:38 <Cale> osaunders: In any given branch of mathematics you'll have one or more definitions of the word "isomorphism" to say what you mean by two structures being "the same"
21:26:53 <ddarius> homeomorphic, homotopic
21:27:03 <rindolf> Hi all.
21:27:09 <kmc> osaunders, in category theory you have a single definition of "isomorphism" and you can simply say "isomorphism in the category of graphs", etc.
21:27:15 <Cale> osaunders: and it'll usually come out of something more basic called a "homomorphism"
21:27:40 <kmc> the advantage is that "the category of graphs" is a precisely defined formal object, and you get your concept of isomorphism for free
21:27:46 <Cale> osaunders: which is a weaker notion -- typically some kind of structure-preserving function, but it only preserves it in one direction :)
21:27:48 <rindolf> First of all the topic shouldn't be in Haskell syntax - if confuses the hell out of X-Chat's URL recognition.
21:27:50 <osaunders> Why the morphism part of the word, they sounds like something is changing?
21:27:54 <osaunders> *that
21:28:04 <Cale> osaunders: yes
21:28:09 <ddarius> morph means form
21:28:19 <kmc> 'ὁμός (homos) meaning "same" and μορφή (morphe) meaning "shape"'
21:28:21 <ddarius> iso means same
21:28:27 <osaunders> Ah.
21:28:39 <kmc> iso means "more same than homos", apparently
21:28:45 <ddarius> kmc: Apparently.
21:28:51 <kmc> because homomorphisms can "forget" part of the structure
21:29:00 <kmc> but an isomorphism is by definition invertible
21:29:00 <copumpkin> mmm homos
21:29:21 <copumpkin> homos homoi?
21:29:28 <osaunders> heheh
21:29:45 <ddarius> kmc: Well the internet says "iso is equal"
21:29:53 <osaunders> homos appreciate other homos morph.
21:30:34 <kmc> @vixen ὁμός μορφή
21:30:34 <lambdabot> why me? :)
21:30:46 <rindolf> Secondly, can anyone come up with a faster Haskell code for http://github.com/shlomif/Project-Euler-Problem-10-Comparison ? Currently the Haskell code there perform much more poorly than the C code, and even more poorly than the Perl 5 code by a factor of 2 or 3. See http://github.com/shlomif/Project-Euler-Problem-10-Comparison/blob/master/project-euler-prob-10/results/telaviv1.shlomifish.org/bench_reuslts-1.txt
21:31:17 <kmc> @vixen привет
21:31:17 <lambdabot> too many perverts send out sick pictures of themselves. what type of man does that?
21:31:23 <Cale> osaunders: Basically, a homomorphism will be a function from the components of one structure to the components of another so that any "important" way in which elements of the first structure were related will be preserved in the elements they get sent to.
21:31:50 <Cale> osaunders: For example, what we care about in the context of vector spaces is addition and scaling of vectors
21:32:15 <Cale> So we require that a homomorphism of vector spaces (more commonly, a linear transformation), preserve these operations
21:32:55 <Cale> So if V and W are vector spaces, a homomorphism is a function f sending vectors of V to vectors of W such that f(x+y) = f(x)+f(y), and f(ax) = a f(x)
21:32:57 <kmc> rindolf, did you see http://haskell.org/haskellwiki/Prime_numbers
21:33:02 <Cale> for any vectors x, y and any scalar a
21:33:33 <rindolf> kmc: I think I have implemented similar code in my version.
21:33:39 <kmc> rindolf, also, with any kind of benchmark you should clarify what language implementations you're using
21:33:49 <kmc> it's nonsense to talk about the speed of a language or an algorithm
21:34:08 <rindolf> kmc: I'm using ghc, gcc and /usr/bin/perl - all from Mandriva packages.
21:34:20 <kmc> what version of ghc, with what compiler options?
21:35:29 <rindolf> kmc: ghc-6.10.4-1mdv2010.0
21:35:38 <rindolf> kmc: and the flags are in the makefile.
21:36:15 <dolio> If you want to go really fast, you should use a mutable array instead of a list.
21:36:18 <rindolf> Oh wait! I didn't add -O2 to the Haskell.
21:36:22 <kmc> rindolf, indeed
21:37:14 <kmc> rindolf, you can also try it with: -O2 -fvia-c -optc-O2
21:37:27 <toast-opt> if you want it to go really fast, you should not pass the expression into an IO monad
21:38:15 <kmc> rindolf, instead of Integer you could use Int, as your primes all fit within a machine word
21:38:29 <rindolf> kmc: but the sum doesn't.
21:38:35 <kmc> ah true
21:38:39 <rindolf> The sum overflows 2 GB.
21:38:46 <rindolf> I could somehow segment them.
21:39:33 <kmc> also you could compute a running sum rather than constructing a list to sum.  i'm not sure if that'd make a difference, or if ghc will fuse your sum anyway
21:40:30 <me1232> pl \x -> f x x
21:40:43 <kmc> rindolf, your C version doesn't use bignums
21:40:47 <kmc> @pl \x -> f x x
21:40:47 <me1232> @pl
21:40:47 <lambdabot> join f
21:40:47 <lambdabot> (line 1, column 1):
21:40:48 <lambdabot> unexpected end of input
21:40:48 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
21:40:54 <me1232> thank you
21:40:57 <rindolf> kmc: no, but I'm using long long
21:41:00 <rindolf> kmc: it's 64-bit.
21:41:00 <me1232> @pl \x -> f x x
21:41:00 <lambdabot> join f
21:41:20 <rindolf> kmc: I could try it with libgmp too.
21:41:32 <ddarius> :k Int64
21:41:33 <lambdabot> *
21:41:53 <ddarius> @pl \x -> x x
21:41:53 <lambdabot> join id
21:42:06 <copumpkin> doom!
21:42:06 <kmc> rindolf, if you have a 64-bit machine, ghc's Int should be nearly 64 bits anyway
21:42:09 <copumpkin> destruction upon us all
21:42:11 <kmc> and apparently there's an Int64
21:42:24 <rindolf> kmc: I don't have a 64-bit machine.
21:42:35 <rindolf> kmc: let me try with an Int64.
21:43:03 <kmc> i mean i think you could translate the C version into Haskell piece-by-piece and get nearly the same performance
21:43:08 <kmc> with the crazy bit arithmetic and all
21:43:30 <rindolf> kmc: the C version uses assignment.
21:43:36 <copumpkin> yeah, you can do that
21:43:37 <kmc> rindolf, yes
21:43:38 <kmc> we have that...
21:43:44 <kmc> many ways
21:43:51 <copumpkin> IN TEH IO OR ST MONADZ
21:43:54 <kmc> the simplest is to turn a loop into a tail-recursive procedure
21:44:14 <kmc> we also have the crazy bit ops in Data.Bits
21:44:26 <rindolf> kmc: I thought tail recursion was not a good idea in Haskell (as opposed to Scheme and Lisp).
21:44:30 <idnar> copumpkin: MOAN ADZ?!
21:44:33 <kmc> rindolf, ?
21:44:35 <copumpkin> rindolf: why not??
21:44:37 <kmc> where'd you get that idea?
21:44:44 <copumpkin> well, it's not as commonly used
21:44:50 <copumpkin> because we have laziness
21:45:04 <copumpkin> but, it's definitely still possible if you want it
21:45:11 <rindolf> kmc: I'm using the bit ops for bit assignment anyway.
21:45:18 <rindolf> copumpkin: I see.
21:45:47 <rindolf> copumpkin: I was told some time on IRC that it's not working as expected.
21:45:51 <kmc> and because we prefer combinators like fold and map over explicit recursion
21:45:58 <rindolf> But it may have been a misunderstanding on my part.
21:46:08 <copumpkin> rindolf: hm, maybe because of strictness and thunk buildup
21:46:17 <copumpkin> but otherwise, it should definitely behave as you'd expect :)
21:46:22 <kmc> rindolf, it's an essential part of the language that tail recursion work properly
21:46:32 <toast-opt> rindolf - might be because it doesn't need to be a tail call to avoid blowing the stack
21:46:50 <rindolf> kmc: OK, thanks.
21:46:53 <toast-opt> and just because it's a tail call doesn't mean it wont
21:47:05 <Berengal> rindolf: foldl doesn't benefit from TCO, but foldl' does
21:47:05 <rindolf> 10.hs:1:10: Not in scope: type constructor or class `Int64'
21:47:14 <toast-opt> it took me a while to figure out why lazy evaluation causes problems for foldl
21:47:25 <toast-opt> because i'm thinking 'foldl is tail recursive right?'
21:47:33 <idnar> @src foldl
21:47:33 <lambdabot> foldl f z []     = z
21:47:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:47:53 <Twey> Heh.
21:47:57 <Twey> @src foldl'
21:47:57 <lambdabot> foldl' f a []     = a
21:47:57 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:48:05 <kmc> f (f (f (f ... (f z x0) ... x1) x2) x3)
21:48:17 <Twey> foldl', on the other hand, is *not* tail-recursive
21:48:27 <kmc> in other words a big thunk
21:48:35 <Twey> So yeah, TCO doesn't work quite the same in Haskell
21:48:50 <rindolf> Hi Twey
21:48:53 <toast-opt> twey - it isn't?
21:48:54 <Twey> Hey, rindolf ☺
21:48:58 <kmc> foldl' is basically tail recursive
21:49:00 <kmc> because seq is weird
21:49:00 <toast-opt> @src seq
21:49:00 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:49:09 <Twey> kmc: Oh really?
21:49:16 <Twey> toast-opt: seq is magic
21:49:18 <kmc> well seq tail-calls its second arg
21:49:23 <Twey> Aha!
21:49:25 <MoALTz> seq is inbuilt isn't it?
21:49:28 <kmc> which isn't weird at all
21:49:29 <Twey> I never knew.
21:49:29 <kmc> MoALTz, yes
21:49:36 <Twey> Yeah, makes sense.
21:49:39 <toast-opt> oh, duh, i remember seq now
21:49:42 <toast-opt> and $!
21:50:02 <Berengal> kmc: technically, it can call the second arg before the first, in which case it doesn't tail-call it... the compiler is free to choose
21:50:15 <kmc> bummer
21:50:21 <rindolf> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Int.html - one thing that frustrates me about the Haskell documentation is that it is almost completely void of examples and synopses.
21:50:24 <Berengal> This is why we have pseq
21:50:39 * copumpkin attempts to pronounce pseq
21:50:44 <copumpkin> it's quite fun, y'all should try it
21:50:50 <kmc> rindolf, you should get your docs from here: http://www.haskell.org/ghc/docs/latest/html/libraries/
21:50:52 <Twey> Easy
21:50:55 <kmc> though i can't say it's better in this particular case
21:51:04 <toast-opt> does ghc use tagged integers?
21:51:04 <Twey> /psɛk/
21:51:05 <Berengal> copumpkin: I bet a great majority of us did when you said you did
21:51:09 <kmc> toast-opt, don't think so
21:51:18 <copumpkin> Berengal: :D
21:51:20 <kmc> rindolf, in this case... Int64 works just like Int, but it's 64-bit
21:51:20 * copumpkin haz influenz
21:51:27 <kmc> your examples would not be Int64-specific
21:51:29 <toast-opt> kmc, then why the '2^29'ths there?  shouldn't it be 2^31st then?
21:51:33 <rindolf> OK, now with Int64 it is down to 3.33seconds.
21:51:38 <Berengal> copumpkin: It's like when people tell you you can't lick your elbow...
21:51:45 <osaunders> toast-opt: Tagged?
21:51:46 <kmc> toast-opt, where?
21:51:49 <kmc> toast-opt, in the Report?
21:51:53 <toast-opt> yeah, for Int
21:51:57 <kmc> the Report allows for tagged implementations
21:52:04 <toast-opt> oh, ok, gotcha
21:52:10 <kmc> osaunders, sometimes you want to be able to tell a primitive Int from a pointer just by looking at it
21:52:13 <Twey> rindolf: What're you doing?  Playing with performance?
21:52:35 <rindolf> Twey: in a way.
21:52:37 <osaunders> kmc: But no pointers inHaskell?
21:52:39 <kmc> osaunders, so you use some of the bits as a "tag" and mask them out when doing math
21:52:43 <kmc> osaunders, this is at the implementation level
21:52:43 <copumpkin> osaunders: sure there are
21:52:46 <Berengal> rindolf: Did you check out the primes package? I got a 3x speedup using the primes from that
21:52:48 <copumpkin> if you're willing to go digging at the lower levelss
21:52:49 <kmc> not at the language specification
21:53:02 <kmc> e.g. when implementing the garbage collection, this can be useful
21:53:14 <rindolf> Twey: http://github.com/shlomif/Project-Euler-Problem-10-Comparison
21:53:18 <kmc> but ghc doesn't use it; instead, it already knows what's a pointer and what's an int, from context
21:53:22 <rindolf> Berengal: ah.
21:53:36 <toast-opt> yeah, otherwise your stack frames need to some sort of metadata for identifying value types
21:53:45 <kmc> solution: two stacks :D
21:53:46 <toast-opt> either on the frame itself, or using the instruction pointer
21:53:49 <toast-opt> ... or that
21:53:53 <toast-opt> :)
21:54:05 <toast-opt> or 3 on ia64
21:54:11 <toast-opt> (ia64 already has two stacks)
21:54:28 <copumpkin> two BK stackers, hmm
21:54:41 <toast-opt> monadic hamburgers?
21:59:53 <Niccus> burger buns >>= cheese >>= burger
22:00:18 <toast-opt> _ >>= eat
22:00:29 <Niccus> eat does not return a sandwich
22:01:00 <toast-opt> heh
22:01:15 <toast-opt> i can tell you what it returns... eventually
22:01:17 <Cale> It returns the empty sandwich.
22:01:58 <toast-opt> eh, no
22:07:26 <Twey> rindolf: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13579#a13579
22:07:43 <Twey> (sorry, had to)
22:08:06 <rindolf> Twey: what about it?
22:08:34 <Twey> It's the way to formulate your Haskell implementation.
22:08:55 <Twey> Rather than having nested ‘where’s and superfluous brackets all over the place :þ
22:10:38 <Twey> (<<http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13579#a13580>> — sorry, missed a spot)
22:11:35 <Twey> See also how the p is passed around explicitly, making the data flow clearer
22:12:05 <Twey> Oh, and: we use ‘_’ to indicate an unused argument
22:12:16 <Twey> Which lets the compiler optimise it away
22:12:42 <toast-opt> what is the '1@' in '1@(a:as)'?
22:12:49 <copumpkin> it can optimize it away even if you use a name
22:12:53 <copumpkin> but just don't use it
22:13:09 <Niccus> l represents the entire list
22:13:12 <Twey> toast-opt: It's an ‘l’, not a ‘1’
22:13:18 <toast-opt> oops, thx
22:13:24 <Twey> Yeah.  Rather than reconstructing the whole thing.
22:13:44 <manju> what is 'it' ?
22:13:52 <manju> in ghci
22:14:03 <Twey> manju: The last expression evaluated
22:14:19 <Twey> rindolf: What -O setting did you use to get the 135-second result?
22:14:34 <rindolf> Twey: 135 second?
22:14:37 <manju> Twey: I figured that much, by putting it into ghci, what does it expand to ?
22:14:50 <rindolf> Twey: it never took so much.
22:15:20 <Twey> Your results say:
22:15:20 <Twey> haskell_mine: 135 wallclock secs ( 0.00 usr  0.00 sys + 134.71 cusr  0.70 csys = 135.41 CPU) @  0.15/s (n=20)
22:15:28 <Twey> manju: The value of the expression
22:15:34 <rindolf> Twey: for 20 times.
22:15:38 <manju> Twey: ok
22:15:55 <Twey> rindolf: The file says 500
22:15:58 <rindolf> Twey: and I used it without -O I think.
22:16:02 <rindolf> Twey: no.
22:16:06 <rindolf> Twey: (n=20)
22:16:24 <Twey> Err
22:16:25 <rindolf> Twey: I ran a different number for the C version and a different one for the Haskell and Perl ones.
22:16:28 <Twey> That's ridiculously slow
22:17:05 <Twey> Try -O
22:18:29 <Twey> I would expect twice or maybe thrice slower than the C
22:18:37 <Twey> Certainly not 225 times
22:20:11 <Twey> (and yeah, if you translate it directly using unboxed values and IORefs and stuff, it should probably be about the same)
22:27:25 <rindolf> Twey: I tried -O.. - it is down to 3-4 second run-time per-run.
22:27:44 <rindolf> In any case, I lack the energy to work on it more now.
22:27:53 <rindolf> This is all too vexing.
22:28:13 <rindolf> Twey: feel free to fork the repository and write a better version.
22:28:32 <rindolf> Well, I'm also tired - I slept about 4 hours tonight.
23:16:38 <copumpkin> "Greetings, my name is M!"
23:18:24 <drhodes> Mexclamation Point
23:35:30 <Baughn> ziman: Well, the wrap/unwrap system wouldn't work, specifically if one of the transformers used to build the wrapped one itself uses this.
23:35:44 <Baughn> ziman: ..I'm going to need some actual type arithmetic. Oh, this'll be fun.
23:36:33 <ivanm> Baughn: so what's going to happen with hlint support in haskell-mode?
23:37:36 <dblhelix> goodmorning #haskell
23:37:45 <Baughn> ivanm: Removed, probably. I'll see if I can integrate better with the /real/ hlint.el.
23:37:56 <ivanm> *nod*
23:38:07 * ivanm waves idly in dblhelix's general direction
23:38:18 <ivanm> Baughn: did you really not know about hlint.el?
23:38:56 <Baughn> ivanm: I didn't write the hlint stuff in haskell-mode in the first place, and I only checked it for working-ness, not duplication of other projects
23:39:26 <ivanm> ahhh
23:41:26 * Baughn goes back to watching Darker than Black
23:41:39 <ivanm> never heard of it...
23:42:09 <Baughn> ivanm: http://anidb.net/perl-bin/animedb.pl?show=anime&aid=6644 <-- This
23:42:30 <Baughn> It's very good, even if it, um, lives up to its title.
23:42:48 <ivanm> as in full of horror, etc.?
23:42:57 <Baughn> The horror is subtler, but yes.
23:42:58 <Twey> Not horror, exactly
23:43:05 <Twey> It's just very… dark
23:43:17 <Baughn> Well, I thought what happened to Suou was pretty horrifying
23:43:30 <Baughn> ..her, and every other contractor, but Suou is neither fowl nor fish
23:43:44 * ivanm checks out wikipedia
23:43:50 <ivanm> so far its not making much sense...
23:43:52 <Twey> It's probably something to do with her association to Hei
23:44:05 <Twey> ivanm: The plot is rather subtle
23:44:14 <ivanm> ahhh
23:44:23 <Twey> The whole of the first series didn't make sense to me until about halfway through :þ
23:44:29 <Baughn> Twey: My impression was that her abilities are borrowed from Hei (..well, Pai), so I guess..
23:44:37 <Twey> Ah, yeah
23:44:41 <Baughn> OTOH, did you notice her star is /red/?
23:44:45 <Twey> Yeah :þ
23:45:07 <Twey> Er, but anyway, must go
23:45:14 <Baughn> ..episode eight is a doozy
23:45:21 <tombee> hello!
23:46:23 * ivanm waves idly in tombee's general direction
23:47:44 <Baughn> ivanm: The worst part is, flat affect is an actual problem real people can have. Though flat affect combined with a lack of conscience and superpowers is probably a bit unusual..
23:48:01 <ivanm> wuh? what's flat affect?
23:48:10 <Baughn> An inability to feel emotions
23:48:14 <ivanm> ahhhh
23:48:58 <Baughn> People with /real/ flat affect, reasonably, just sit there and eventually die. Those who don't usually have at least some remaining emotions, just.. not those you'd first look for.
23:49:15 <tombee> I know this might be a 'how long is a piece of string' question, but has anyone got any ideas on the level of complexity to implement a chess game in haskell? :)
23:49:17 <cnwdup> @hoogle (a -> b -> a) -> [a] -> [b] -> [a]
23:49:18 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:49:18 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:49:18 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
23:49:34 <Baughn> tombee: Not very hard. Unless you want it to be smart.
23:49:45 <ivanm> tombee: as in just the rules?
23:49:48 <ivanm> or an AI?
23:49:50 <copumpkin> cnwdup: what do you need it to do? a zip?
23:49:55 <tombee> Well I was thinking AI as well.
23:49:56 <Baughn> tombee: Also, how long is (repeat 42)?
23:50:14 <copumpkin> omega
23:50:31 <tombee> Hmmm :P
23:50:31 <Baughn> ..there are only two possible answers, and neither is /that/
23:50:48 <cnwdup> copumpkin, it feels like a fold, but I guess it isn't. I want to apply a function to ever n-th item of a list with n coming from a list of indices.
23:50:57 <cnwdup> s/ever/ervery/
23:51:16 <cnwdup> Ah, damn. every is what I meant. :)
23:51:16 <ivanm> Baughn: the length of a thunk or infinity?
23:51:22 <Baughn> tombee: Haskell lends itself well to implementing primitive chess AIs, I should think. Okay. It'll be easier than /other/ languages; look up the list monad and such.
23:51:25 <tombee> Basically I'm looking for a project, that's challenging but manageable for me.
23:51:26 <ivanm> cnwdup: heh
23:51:37 <Baughn> tombee: It should be fine, just go ahead and try. :)
23:51:43 <tombee> I have no real experience in haskell :)
23:51:46 <Baughn> ivanm: I didn't say.
23:52:03 <tombee> Baughn: you probably hear this a lot in here, but it's for a uni project
23:52:07 <ivanm> Baughn: well, I was checking if that was the two possible answers...
23:52:11 * ivanm resists the urge to suggest evil projects to tombee
23:52:17 <Baughn> tombee: Time-frame?
23:52:27 <Baughn> ivanm: It was
23:52:27 <tombee> very difficult to 'gauge' the difficulty of the project they're looking for though
23:52:37 <tombee> uhm they're usually about 3-4 months
23:53:06 <tombee> but obviously the majority of these projects is research/documentation
23:53:09 <Baughn> That's enough time to learn haskell, implement chess, implement a primitive AI, and get thoroughly stuck on the fancier stuff.
23:53:21 <Baughn> So, yes, I think HsChess will be fine.
23:53:26 <tombee> Well I have a good year and a bit to get a headstart
23:53:32 <Baughn> Just upload it to hackage if it turns out playable, okay? ;)
23:53:39 <tombee> Ofcourse
23:53:51 <tombee> ivanm: what are these evil projects? :)
23:54:41 <koala_man> a primitive AI means minimax?
23:54:45 <tombee> yeah
23:54:48 <tombee> I guess so :p
23:55:01 <Baughn> If you feel more ambitious, try Go
23:55:09 <tombee> It appears I have 2 months for the bulk of the project
23:55:15 <Baughn> ..or don't.
23:55:15 <tombee> this would include research etc.
23:55:32 <tombee> But, I do have a lot of time to get a headstart in learning what I need :)
23:55:52 <Baughn> tombee: Have you used haskell much, before?
23:56:07 <tombee> Not really no, only trivial stuff.
23:56:19 <Baughn> Right. Push this on your list of things to learn, then: Monad transformers.
23:56:25 <tombee> I find it difficult to 'get stuck into' haskell
23:56:34 <tombee> without having a real project to work on
23:56:34 <Baughn> MonadRandom, MonadPrompt, ListT - all things you'll almost certainly have a use for.
23:57:06 <roostaj> have any of you read "The Haskell Road to Logic, Math, and Programming" by chance?
23:59:32 <ivanm> tombee: implement nauty in haskell; develop a generic graph class that everyone accepts, etc. :p
23:59:35 <ivanm> roostaj: I have
23:59:40 <ivanm> well, skimmed through it, anyway
23:59:50 * ivanm thinks he has an electronic copy somewhere...
23:59:50 <Baughn> tombee: Oh, I know! Implement FRP! ^_^
23:59:56 <Baughn> (No. Don't.)
