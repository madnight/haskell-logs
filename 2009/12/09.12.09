00:00:07 <Philonous1> Veinor: No, it is not. if' p a b = if p then a else b. Unfortunately it is not defined in any standard library
00:00:10 <JohnDoe365> kyagrd: substitute cool by 'used today'
00:00:24 <poe> JohnDoe365 yeah there is no shiny looking website with screencasts because we avoid success (:
00:00:30 <sheyll> hi
00:00:35 <poe> (company policy)
00:00:37 <kyagrd> And it's the most coolest (means not running on ghc but actually intracting with some other thing like a browser) thing I can find
00:00:45 <sheyll> How can I add an hour to a UTCTime?
00:00:45 <DerisionSnort> @pl \(x, y) -> x < y
00:00:46 <lambdabot> uncurry (<)
00:01:29 <Veinor> ahh, it's a lambdabot thing then
00:01:31 <poe> ?index UTCTime
00:01:31 <lambdabot> bzzt
00:01:36 <Veinor> that sucks :(
00:01:38 <kyagrd> JohnDoe365: What is patch-tag built on then? Isn't it being used?
00:02:00 <DerisionSnort> @pl \xs -> zip xs (tail xs)
00:02:01 <lambdabot> ap zip tail
00:02:07 <kyagrd> There is at least a working site :)
00:02:16 <DerisionSnort> :t ap
00:02:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:02:49 <poe> sheyll \x -> addUTCTime x (secondsToDiffTime 3600)
00:04:42 <poe> sheyll err not quite
00:04:43 <dcestari> hello everybody
00:05:14 <EnglishGent> hi dcestari :)
00:05:20 <dcestari> I'm having an error with gch 6.8, I'm using the type "SomeException" from Control.Exception but it does not work
00:05:21 <DerisionSnort> @pl all (uncurry (<)) . pairs
00:05:22 <lambdabot> all (uncurry (<)) . pairs
00:05:32 <JohnDoe365> kyagrd: Of course you're right. It's just none of the frameworks provide you with functionality of long lasting connections (comet) or RESTful APIs (storage), functionality supporting cloud computing
00:05:33 <dcestari> I get "Not in scope: type constructor or class `SomeException'"
00:06:08 <Veinor> DerisionSnort: that's already pointless
00:06:12 <dcestari> It works fine on gch 6.10, is this a known issue?
00:06:16 <Veinor> @unpl all (uncurry (<)) . pairs
00:06:16 <lambdabot> (\ c -> all (uncurry (<)) (pairs c))
00:06:28 <Saizan_> dcestari: Control.Exception changed in 6.10
00:06:38 <dcestari> Saizan_: how?
00:06:45 <DerisionSnort> > all (uncurry (<)) . ap zip tail $ [2, 3, 5, 7]
00:06:46 <lambdabot>   True
00:06:50 <DerisionSnort> > all (uncurry (<)) . ap zip tail $ [2, 3, 5, 4]
00:06:51 <lambdabot>   False
00:06:53 <Saizan_> dcestari: introducing SomeException and friends
00:06:54 <DerisionSnort> cool
00:07:03 <JohnDoe365> kyagrd: If Haskell ist not a requsiste but only FP, take a look at http://nitrogenproject.com/
00:07:11 <dcestari> Saizan_: go figure. hehe
00:07:15 <Veinor> > ap zip tail $ [2, 3, 5, 7]
00:07:17 <lambdabot>   [(2,3),(3,5),(5,7)]
00:07:17 <kyagrd> JohnDoe365: Thanks for mentioning that, I'm not an expert on web programming
00:07:26 <Saizan_> dcestari: with ghc 6.8 you can use the extensible-exceptions package, and import Control.Exception.Extensible, it'll work in 6.10 too
00:07:46 <dcestari> Saizan_: let me try that, thanks
00:08:24 <kyagrd> JohnDoe365: Haskell is a requsite, the program consists of introducing Haskell, Erlang, and some other things like markup languages such as markdown and of course someone else is a big fan of pandoc even he is not a haskell programmer
00:08:50 <JohnDoe365> kyagrd: http://nitrogenproject.com/ is in erlang
00:09:06 <kyagrd> JohnDoe365: I'm only in charge of the Haskell section
00:09:27 <fasta> How can anyone be a fan of pandoc?
00:09:28 <JohnDoe365> kyagrd: k ;)
00:09:41 <poe> sheyll addUTCTime 3600 does it :)
00:09:59 <kyagrd> Most relavent thing I could find to make audience most entertaining was happstack, and I'm a user of patch-tag anyway :)
00:10:02 <dcestari> Saizan_: cabal install extensible-exceptions ?
00:10:03 <fasta> Pandoc is buggy. (just like all the other tools in the same category)
00:10:29 <thoughtpolice> fasta: did you submit bug reports?
00:10:29 <kyagrd> fasta: well all other markdown tools are buggy as well and pandog is quite good among them in comparison that was hs claim
00:10:43 <kyagrd> sorry pandoc not pandog
00:11:02 <fasta> thoughtpolice, I think I did once, but since it is/was being developed by a professor I lost interest.
00:11:19 <fasta> thoughtpolice, it just means that it will be abandonware.
00:11:39 <thoughtpolice> no it doesn't. it's open source. i could begin maintaining it if john doesn't seem dedicated.
00:11:42 <sheyll> poe: thanks
00:12:06 <poe> sheyll you're welcome
00:12:36 <HaskellLove> indentation rules are extremely anoying, how do you deal with that?
00:12:44 <copumpkin> it hasn't been abandonware so far
00:12:48 <fasta> HaskellLove, scalaLove, is that you?
00:12:53 <HaskellLove> yea
00:12:56 <fasta> Heh
00:12:58 <dcestari> cabal install extensible-exceptions ??
00:13:05 <jmcarthur_work> HaskellLove, i think of it as block rules, not indentation rules
00:13:11 <jmcarthur_work> that's really closer to what it is
00:13:18 <fasta> HaskellLove, we hit TAB a lot of times.
00:13:24 <jmcarthur_work> and with that mindset, it's a lot nicer than, say, python's syntax
00:13:58 <fasta> Haskell is nicer in a lot of ways.
00:14:11 <HaskellLove> jmcarthur_work what if u copy a 100 line text into a file and then load it in GHCI? it can have 1000 indentation errors where do you start fixing all that mess?
00:14:12 <fasta> Example: writing a file in Haskell: writeFile.
00:14:31 <jmcarthur_work> HaskellLove, ghci doesn't work for that anyway
00:14:32 <thoughtpolice> fasta: regardless I think that's a poor reason to not submit a bug report; it's worth documenting it regardless.
00:14:44 <c_wraith> a hundred-line file can't have more than 100 indentation errors. :)
00:14:48 * thoughtpolice is out of it this morning with his repetetive words
00:15:03 <jmcarthur_work> ghci is meant to be interactive. if you want to load a file, you load the file. don't copy-paste it
00:15:29 <dcestari> Saizan_: can't find that extensible-exceptions package
00:15:34 <HaskellLove> c_wraith indentation works only for start of line space?
00:15:46 <dcestari> Saizan_: is there a way to "catch all" exceptions prior 6.10 ?
00:15:49 <jmcarthur_work> oh i misread what was said
00:16:03 <mux> dcestari: http://hackage.haskell.org/package/extensible-exceptions
00:16:17 <jmcarthur_work> HaskellLove, if you copy-pasted 100 lines of valid haskell code you should get valid haskell code in most cases
00:16:32 <Jonno_FTW> how can i do a continued fraction in haskell?
00:16:34 <dcestari> mux: I meant on the laboratory I'm on
00:16:35 <c_wraith> HaskellLove: yes, the only thing the alignment rules care about is the start of the line
00:16:39 <mux> dcestari: ah
00:16:48 <jmcarthur_work> and if you don't (it was pasted into an existing function, for example) your editor should help you pick up the pieces
00:16:50 <HaskellLove> c_wraith that is nice to know,ok
00:16:51 <dcestari> mux: but thanks
00:16:58 <DerisionSnort> > let n = 100 in [(x, y, z) | x <- [1..n], y <- [x..n], z <- [y..n], x*x + y*y == z*z]
00:17:06 <c_wraith> jmcarthur_work: I'm pretty sure he means "off the web" or the like, where html formatting can really make it ugly
00:17:11 <DerisionSnort> > let n = 10 in [(x, y, z) | x <- [1..n], y <- [x..n], z <- [y..n], x*x + y*y == z*z]
00:17:26 <DerisionSnort> > let n = 10 in n
00:17:35 <DerisionSnort> no response?
00:17:39 <mux> sounds like a very inefficient way to generate pythagorean triplets
00:17:43 <jmcarthur_work> c_wraith, it's a rare situation for me
00:17:45 <Jonno_FTW> yeah
00:17:52 <Jonno_FTW> better off
00:18:04 <c_wraith> jmcarthur_work: I suspect it's more common for raw beginners
00:18:11 --- mode: irc.freenode.net set +v lambdabot
00:18:24 <jmcarthur_work> DerisionSnort, try now
00:18:24 <DerisionSnort> I mean response from the bot
00:18:33 <jmcarthur_work> DerisionSnort, lambdabot was split
00:18:38 <DerisionSnort> > let n = 10 in [(x, y, z) | x <- [1..n], y <- [x..n], z <- [y..n], x*x + y*y == z*z]
00:18:49 <DerisionSnort> hm...
00:18:52 <jmcarthur_work> > 1
00:18:59 <jmcarthur_work> :\
00:19:03 <DerisionSnort> :-(
00:19:10 <jmcarthur_work> @bot
00:19:10 <lunabot>  :o
00:19:17 <DerisionSnort> @pl 1
00:19:17 <jmcarthur_work> go with lunabot :)
00:19:30 <DerisionSnort> how do i "go with lunabot"?
00:19:30 <lambdabot>   [(3,4,5),(6,8,10)]
00:19:30 <lambdabot> :)
00:19:30 <lambdabot>   1
00:19:31 <lambdabot> 1
00:19:40 <DerisionSnort> oh there he is
00:19:41 <jmcarthur_work> oh hi lambdabot!
00:19:44 <DerisionSnort> > 2+3
00:19:45 <lambdabot>   5
00:19:48 <DerisionSnort> yay!
00:19:48 <jmcarthur_work> DerisionSnort, lambdabot is a she
00:20:55 <Jonno_FTW> can it be asked this?
00:21:06 <Veinor> , 2 + 3
00:21:08 <lunabot>  5
00:21:18 <aavogt> @vixen are you a she?
00:21:18 <lambdabot> yes, i am
00:21:25 <Jonno_FTW> > lunabot `elem` men
00:21:27 <lambdabot>   Not in scope: `lunabot'Not in scope: `men'
00:21:32 <c_wraith> @vixen are you a he?
00:21:33 <lambdabot> yes, i am
00:21:43 <c_wraith> @vixen well, which is it?
00:21:44 <Veinor> :o
00:21:44 <copumpkin> nothing wrong with being both
00:21:45 <lambdabot> yeah, it is
00:21:48 <dcestari> what is the difference between: catch (...) (\e -> print (e :: SomeException)) and: catch (...) (\e -> print (e :: Exception)) ??
00:21:53 <DerisionSnort> @pl all true
00:21:54 <lambdabot> all true
00:22:00 <DerisionSnort> @pl all True
00:22:04 <lambdabot> all True
00:22:30 <dcestari> @pl 1
00:22:32 <lambdabot> 1
00:22:43 <Philonous1> @type all
00:22:44 <dcestari> @pl (1:2)
00:22:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:22:45 <lambdabot> 1 : 2
00:22:54 <Philonous1> @type all (==True)
00:22:55 <lambdabot> [Bool] -> Bool
00:22:59 <Veinor> all True = const True :: [a] -> Bool
00:23:00 <Philonous1> @type all True)
00:23:00 <c_wraith> @pl \_ _ _ _ _ _ -> 0
00:23:01 <lambdabot> parse error on input `)'
00:23:02 <lambdabot> const (const (const (const (const (const 0)))))
00:23:03 <Philonous1> @type all True
00:23:04 <lambdabot>     Couldn't match expected type `a -> Bool'
00:23:04 <lambdabot>            against inferred type `Bool'
00:23:04 <lambdabot>     In the first argument of `all', namely `True'
00:23:44 <DerisionSnort> @pl all id
00:23:45 <lambdabot> and
00:23:47 <DerisionSnort> ah!
00:23:49 <aavogt> > if True == True then True else False
00:23:50 <lambdabot>   True
00:23:53 <Veinor> actually, all True is syntactically invalid
00:24:00 <Saizan_> dcestari: in the old Control.Exception catch will catch everything by default
00:24:02 <Veinor> er, type invalid
00:24:03 <Veinor> > all True [1, 2, 3]
00:24:05 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
00:24:05 <lambdabot>         against inferred ...
00:24:06 <EnglishGent> @vixen are you made of a mimetic polyalloy
00:24:07 <lambdabot> i truely am
00:24:12 <EnglishGent> see - that explains it
00:24:19 <EnglishGent> vixen can change gender at will!
00:24:21 <EnglishGent> :)
00:24:52 <DerisionSnort> > \xs -> and $ zipWith (<) xs (tail xs) [2, 3, 5, 7]
00:24:54 <lambdabot>   Couldn't match expected type `[t] -> [GHC.Bool.Bool]'
00:24:54 <lambdabot>         against infer...
00:25:01 <DerisionSnort> > \xs -> and $ zipWith (<) xs (tail xs) $ [2, 3, 5, 7]
00:25:03 <lambdabot>   Couldn't match expected type `a -> b'
00:25:03 <lambdabot>         against inferred type `[GHC.B...
00:25:13 <dcestari> can I conditionally compile something for GCH 6.10 and something else for GHC 6.8?
00:25:36 <aavogt> you can use CPP at least
00:25:37 <DerisionSnort> > let isSorted xs = and $ zipWith (<) xs (tail xs) in isSorted [2, 3, 5, 7]
00:25:38 <lambdabot>   True
00:25:39 <dcestari> like C's #ifdef #endifdef ?
00:25:45 <DerisionSnort> > let isSorted xs = and $ zipWith (<) xs (tail xs) in isSorted [2, 3, 5, -7]
00:26:09 <dcestari> CPP ?
00:26:14 <lambdabot>   False
00:26:29 <jmcarthur_work> dcestari, the C preprocessor
00:26:39 <jmcarthur_work> dcestari, just use the CPP language extension
00:26:41 <DerisionSnort> @pl \xs -> (and $ zipWith (<) xs (tail xs))
00:26:42 <lambdabot> and . ap (zipWith (<)) tail
00:27:00 <aavogt> you can run the same preprocessor over your haskell as happens to C
00:27:54 <dcestari> thanks! aavogt: jmcarthur_work: I'll read on that
00:27:57 <aavogt> cabal (or maybe ghc on it's own) #defines GHC610 or some similar variables you can use to check ghc version
00:28:56 <dcoutts> dcestari: check that what you want to check for really is ghc and not say the version of a library
00:28:58 <copumpkin> :t all (uncurry (<)) . ap zip tail
00:29:00 <lambdabot> forall a. (Ord a) => [a] -> Bool
00:29:54 <aavogt> > all undefined []
00:29:55 <lambdabot>   True
00:29:56 <dcoutts> dcestari: people often make the mistake of doing conditional compilation on the ghc version when they actually meant the version of a lib, like base. The libs and ghc are not tied together so much anymore so it's more important to get right.
00:30:42 <dcestari> dcoutts: base-3 and base-4 are libs, right?
00:30:53 <dcoutts> dcestari: yes
00:30:57 <dcestari> dcoutts: do they contain Control.Exception definitions?
00:31:04 <dcoutts> yes
00:31:08 <HaskellLove> wow I just learned about sections in Haskell they are so cool... but why does this give me error: (/2) x where x=12
00:31:27 <ben> > let x = 12 in (/2) x
00:31:28 <lambdabot>   6.0
00:31:33 <ben> Presumably because you are using where wrong
00:31:34 <aavogt> because where belongs to declarations
00:31:35 <dcestari> dcoutts: so I should do conditional compilation over the base version? is base-4 the one with SomeException and base-3 the other one?
00:31:38 <copumpkin> HaskellLove: tell us the error and we'll tell you why
00:31:39 <DerisionSnort> @unpl ap f g
00:31:40 <lambdabot> (f >>= \ b -> g >>= \ a -> return (b a))
00:31:55 <HaskellLove> parse error on input `where' copumkin
00:31:57 <Saizan_> dcestari: yes
00:31:58 <dcoutts> dcestari: right, use #if MIN_VERSION_base(4,0,0)
00:32:17 <dcestari> that looks better, thanks dcoutts
00:32:22 <dcestari> and Saizan_ of course
00:34:11 <DerisionSnort> I don't get this ap thing
00:34:17 <DerisionSnort> at all
00:34:28 <c_wraith> DerisionSnort: don't worry about it for now
00:34:32 <copumpkin> DerisionSnort: it's not trivial
00:34:47 <jmcarthur_work> DerisionSnort, learn applicative before monad ;)
00:34:56 <DerisionSnort> ok
00:35:01 <jmcarthur_work> ap is the same as (<*>)
00:35:03 <gwern> bloody monad transformers
00:35:40 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13879#a13879
00:36:18 <gwern> I don't know why return is making my 'content' a [[Block]] rather then turing the [Block] into PluginM [Block]
00:36:34 <DerisionSnort> this is what i have written that i do understand. is it related at all?
00:36:36 <jmcarthur_work> gwern, because of the (++)?
00:36:36 <DerisionSnort> myAp f g x = f x (g x)
00:36:46 <Beelsebob> DerisionSnort: ap is easy to think of in terms of an extension of fmap
00:36:49 <Saizan_> gwern: (++) expects lists
00:36:55 <Beelsebob> fmap applies a function to an argument in a container
00:36:57 <gwern> jmcarthur_work: well, how else am I going to combine a [Block] and a [Block]?
00:36:59 <Saizan_> unless you've rebound that to something more general
00:37:02 <DerisionSnort> :t fmap
00:37:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:37:05 <Beelsebob> ap applies a function in a container to an argument in a container
00:37:07 <aavogt> you need to liftM2 (++)
00:37:09 <jmcarthur_work> gwern, liftA2 (++)
00:37:25 <gwern> -_- go not to the elves for advice...
00:37:43 <jmcarthur_work> gwern, of even: (content++) `liftM2` transformBlock xs
00:37:43 <Saizan_> ?src liftM2
00:37:44 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:37:46 <jmcarthur_work> *or even
00:37:49 <DerisionSnort> @pl \f g x -> f x (g x)
00:37:50 <lambdabot> ap
00:37:53 <jmcarthur_work> s/liftM2/liftM/
00:37:55 <DerisionSnort> there we go :)
00:37:55 <Saizan_> gwern: does that look familiar? ^^^
00:38:07 <gwern> Saizan_: no
00:38:10 <Beelsebob> DerisionSnort: that's ap for functions only though
00:38:12 <gwern> should it?
00:38:23 <Saizan_> gwern: you can't read do-notation anymore?
00:38:29 <DerisionSnort> and is there a named function for "ap for functions only"?
00:38:47 <Beelsebob> DerisionSnort: conal calls it "result" IIRC
00:38:48 <gwern> I'm just saying that that particular fragment of do-notation doesn't ring any bells
00:38:55 <Saizan_> Beelsebob: result is fmap
00:39:00 <Beelsebob> oh is it?
00:39:06 <Beelsebob> yeh, that makse sense
00:39:18 <Beelsebob> hmm, no I don't think there is a name for <*> on functions only then
00:39:46 <edwardk> DerisionSnort: isn't it just the s combinator?
00:40:39 <Twey> :t ap
00:40:40 <edwardk> which as i recall was originally named for 'starling' =)
00:40:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:41:23 <edwardk> ah, here it is: http://hackage.haskell.org/packages/archive/data-aviary/0.2.0/doc/html/Data-Aviary-Birds.html#v%3Astarling
00:41:24 <edwardk> =)
00:42:56 <edwardk> Beelsebob: there is in literature, just not in haskell
00:43:05 <Beelsebob> edwardk: right
00:43:58 <jmcarthur_work> Saizan_, result is (.)
00:44:04 <Beelsebob> jmcarthur: right, fmap
00:44:14 <Beelsebob> ((.) is fmap on functions)
00:44:18 <jmcarthur_work> Beelsebob, conal doesn't define it as fmap though. he restricts it to (.)
00:44:37 <Beelsebob> jmcarthur: well yeh, it's fmap but restricted to functions
00:44:48 <edwardk> hence why most 'semantic editor combinator' programs can be reduced to fmapping ;)
00:44:56 <Saizan_> ahahaha
00:44:58 <jmcarthur_work> edwardk, of some sort
00:45:25 <edwardk> jmcarthur_work: sure, but when i doubt: fmap fmap fmap
00:45:27 <gwern> @hoogle unsafePerformIO
00:45:27 <lambdabot> Foreign unsafePerformIO :: IO a -> a
00:45:27 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
00:45:51 <jmcarthur_work> edwardk, argument, first, etc. aren't fmap (unless you use a newtype)
00:45:58 <Beelsebob> edwardk: my favorite function is fmap fmap fmap sequence fmap
00:46:07 <dcestari> dcoutts: MIN_VERSION_<lib> is a cabal definition
00:46:07 <edwardk> @type fmap fmap fmap sequence fmap
00:46:11 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
00:46:14 <Beelsebob> @type mapM
00:46:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:46:16 <edwardk> nice
00:46:19 <copumpkin> cute
00:46:34 <Beelsebob> (mapA ofc, but that's my normal rant)
00:46:38 <dcoutts> dcestari: yes
00:46:44 <copumpkin> @type fix $ ap sequence
00:46:45 <lambdabot> forall a. [[a] -> a] -> [a]
00:46:52 <dcestari> dcoutts: I'm running a simple haskell program
00:47:00 <dcestari> dcoutts: I can't use that
00:47:10 <dcestari> dcoutts: can I?
00:47:26 <HaskellLove> concat xss =  [x | xs ← xss, x ← xs ], this xss thing... I know about this notation (x:xs) but xss? does that mean you can add "s" and have stuff like xssssssssssss
00:47:28 <edwardk> jmcarthur_work: sure, i suppose the main problem that i have with the practice is that by giving it a special name and restricting it you come to see it as something fundamentally different from the underlying concept
00:47:42 <DerisionSnort> @pl \f x -> f (f x)
00:47:43 <lambdabot> join (.)
00:47:47 <quicksilver> HaskellLove: it's just a convention. You can call it "elephant" if you like
00:47:58 <edwardk> jmcarthur_work: and a lot of semantic editor combinator applications are just (result . result)
00:47:59 <quicksilver> concat elephant = [x | xs <- elephant, x <- xs]
00:48:02 <edwardk> which is fmap fmap fmap
00:48:03 <HaskellLove> quicksilver I dont like elephants man
00:48:04 <dcoutts> dcestari: not if you're not using cabal. But if you're trying to make a portable package that works on various systems then using cabal is the way to go. It lets you specify the dependencies.
00:48:14 <jmcarthur_work> edwardk, i think if you are really just using a bunch of fmaps then you should be using some type composition to make it just one fmap, most of the time
00:48:39 <dcestari> dcoutts: is just a simple project, not a package. I'll have to use the ghc version then, right?
00:48:54 <jmcarthur_work> i think fmap fmap fmap is less clear than result . result
00:48:57 <DerisionSnort> :t fmap fmap fmap
00:48:59 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
00:49:09 <jmcarthur_work> could at least use fmap . fmap
00:49:17 <jmcarthur_work> since the middle one must be function composition anyway
00:49:28 <jmcarthur_work> (well, the first one)
00:49:39 <dcoutts> dcestari: cabal is perfect for simple projects
00:50:03 <dcestari> dcoutts: I can't install cabal on the laboratory I have to run the project in
00:50:19 <dcoutts> dcestari: if you've got ghc you've got the Cabal lib too, it comes with it
00:50:23 <dcestari> dcoutts: it runs fine on ghc 6.10 with base-4 but I need to make it work for the laboratory too
00:50:44 <dcestari> dcoutts: how can I use it?
00:51:26 <dcoutts> dcestari: the build sequence for a cabal package is simple: runghc Setup configure; runghc Setup build; runghc Setup install
00:52:08 <dcoutts> dcestari: the install location is configurable of course, like ./configure && make systems. Mostly the same flags.
00:53:01 <HaskellLove> length xs =sum [1 | ← xs ] What does that mean, crazy...
00:53:20 <HaskellLove> length xs =sum [1 | _← xs ] sorry mistake ^
00:53:22 <jmcarthur_work> HaskellLove, map every value in xs to 1, then sum the result
00:53:45 <byorgey> [ 1 | _ <- xs ]  means "for each element of xs (which I don't care about), produce the value 1"
00:53:46 <jmcarthur_work> HaskellLove, alternatively, sum . map (const 1)
00:53:59 <ToRA> dcoutts: I'm currently playing/using D.S.Command in Cabal for a frontend for a program I'm writing, using cabal-install's Main as a reference
00:54:00 <byorgey> > [ 1 | _ <- "abcde" ]
00:54:01 <lambdabot>   [1,1,1,1,1]
00:54:03 <ToRA> dcoutts: it's pretty neat
00:54:15 <ToRA> dcoutts: just wondering where the data type "Flag" comes from
00:54:29 <dcoutts> ToRA: I've been meaning to extract it into a separate package
00:54:40 <jmcarthur_work> > sum $ (1<$) "Hello, World!"
00:54:42 <ToRA> dcoutts: +1 to that idea :)
00:54:42 <lambdabot>   13
00:54:45 <dcoutts> ToRA: it's from D.S.Setup iirc
00:55:05 <ToRA> dcoutts: ah yup, gottit
00:55:08 <ToRA> dcoutts: thanks
00:55:23 <copumpkin> > [ 1 | 'a' <- "abcda" ]
00:55:25 <lambdabot>   [1,1]
00:55:44 <dcoutts> ToRA: btw I don't recommend depending on the Cabal lib for that purpose, would be better to just copy it out
00:55:46 <copumpkin> > [ (i, 1) | 'a' <- "abcda" | i <- [1..] ]
00:55:47 <lambdabot>   [(1,1),(2,1)]
00:55:53 <Twey> @src (<$)
00:55:54 <lambdabot> (<$) = (<$>) . const
00:56:06 <ToRA> dcoutts: this program is going to end up depending on Cabal for some other stuff later anyways
00:56:19 <dcoutts> ToRA: oh ok, what is it ooi?
00:57:12 <ToRA> dcoutts: my black-box ghc-api testing program.  want to make it (eventually) so you can give it a cabal file and it does the right thing(TM)
00:57:46 <HaskellLove> length xs =sum [1 | _← xs ] ----------------------- [x| x+2] here before the | part we give variables not constants like 1, and then we specify some functions to apply to those variables.... so [1 | _ <- xs] is extremely confusing
00:57:48 <dcoutts> ToRA: ok, make sure it checks the build-type, it'll not work in general with build-type: custom
00:57:55 <ToRA> dcoutts: nod
00:57:57 <gwern> whew. at least it compiles now
00:58:38 <ezyang> Halp! I don't understand sigfpe's "Where do monads come form" post
00:58:46 <copumpkin> ezyang: halp!
00:58:58 <ezyang> :-P
00:59:02 <copumpkin> ezyang: it's not exactly an entry-level article
00:59:07 <copumpkin> ezyang: btw, bostonhaskell next week!
00:59:22 <gwern> how is monad formed
00:59:34 <ezyang> copumpkin: ooh, what time?
00:59:39 <copumpkin> you need to do way instain monoid
00:59:39 <ezyang> *from
00:59:46 <gwern> how do program get compaled
00:59:55 <copumpkin> ezyang: hasn't really been decided yet, but you should get on the mailing list to get updates
01:00:08 <copumpkin> http://groups.google.com/group/bostonhaskell?pli=1
01:00:10 * ezyang has finals that week, but could make time... 
01:00:13 <ezyang> gotcha
01:00:16 <jmcarthur_work> monads are like pregnant women
01:00:54 <Saizan_> ezyang: any specific doubt on that article?
01:01:48 <ezyang> Saizan_: sigfpe goes through the trouble of defining an overloaded algebraic notation for flowcharts, except that it doesn't actually get me any intuition
01:01:50 <dcestari> dcoutts: so I'm using cabal, how can I instruct cabal to generate Haskell code from my Happy file?
01:01:55 <Twey> Typeclassopedia!
01:02:02 <ezyang> so I'm getting more confused by the overloading
01:02:11 <ezyang> Twey: What about it?
01:02:20 <dcoutts> dcestari: just list the module in the appropriate section, exposed/other-modules.
01:02:21 * ezyang <3 typeclassopedia 
01:02:26 <gwern> oh wow. my Subst plugin destroys any page it's used in
01:02:31 * gwern wonders what went wrong
01:02:57 <ezyang> maybe I should just start w/ the Haskell.
01:02:57 <copumpkin> need a cong plugin too
01:03:01 <dcoutts> dcestari: all the modules need to be listed anyway
01:03:30 <Saizan_> ezyang: well, that's just to connect it to algebra, but the symbols used for the operations are not that important
01:03:52 <jaspervdj> anyone here going to ZuriHac?
01:04:03 <Saizan_> i.e. don't try to find a connection with addition and multiplication in particular
01:04:38 <dcestari> Could not find module `Control.Exception':
01:04:38 <dcestari>       it is a member of the hidden package `base-3.0.3.1'
01:04:44 <dcestari> ??
01:04:54 <Saizan_> though choice and sequencing are often connected to those
01:04:55 <gwern> causes gitit to hang too
01:05:10 <Saizan_> dcestari: forgot base in build-depends ?
01:05:28 <gwern> ah, I knew the 'Str ref:_' was dodgy
01:07:15 <ezyang> Oh, I see. I get lost when he defines η and μ and then magically declares, "This is a monad!"
01:08:04 <Twey> Monad is as monad does
01:08:18 <ezyang> Twey: Thank you for your zen comment.
01:08:19 <Saizan_> well those two are the natural transformations of the usual definition of Monad in CT
01:08:20 <ezyang> :-)
01:08:25 <Saizan_> ezyang: i.e. return and join
01:08:28 <Twey> Hehe
01:08:43 <ezyang> Saizan_: Oh! I didn't see that
01:09:12 <Saizan_> if you've join and fmap you can define >>=, so with return you've your familiar Monad
01:10:05 <ezyang> Saizan_: Is the functor instance implicit, in this case?
01:10:58 <Saizan_> ezyang: yeah, T is assumed to be a functor there
01:11:03 <ezyang> cool.
01:11:21 <ezyang> Ok, the composition operation f*u is kind of funny too
01:11:50 <Saizan_> f*u would be u >>= f
01:12:17 <ezyang> oh!
01:12:23 <ezyang> curioser and curioser
01:12:52 <Saizan_> "x_n" would be "Var n" in the Expr datatype below
01:12:58 <gwern> surely there is a better way than this:
01:13:00 <gwern> clean ∷  [Inline] →  String
01:13:03 <gwern> clean = str  · filter (λy →  case y of Str x →  True; _ →  False)
01:13:06 <gwern>    where str [] = []
01:13:09 <gwern>          str ((Str s):xs) = s ++ str xs
01:13:30 <gwern> (clean [Str "f", Apostrophe, EnDash, Str "foo", HtmlInline "bar"] ~> "ffoo")
01:14:03 <Saizan_> clean xs = [ s | Str s <- xs ]
01:14:47 <gwern> (embarassingly small as ever)
01:15:21 <gwern> needs a concat tho
01:15:23 <byorgey> surely  concat $ [ s | Str s <- xs ] ?
01:15:25 <byorgey> yeah
01:15:40 <Saizan_> ah, right
01:15:56 <ezyang> Hmm, what's the identity function...
01:16:07 <ezyang> in μ(a)=i*a
01:16:46 <dcestari> Saizan_: hehe, forgot 'd' in Build-Depen**d**s
01:16:48 <gwern> or in my specific case, unwords
01:16:50 <ezyang> Also, if I understand correctly the type of * is T(N) x T(N) = N?
01:16:58 <ezyang> that doesn't actually make sense.
01:17:14 <Saizan_> ezyang: the identity function is just (\x -> x)
01:17:20 <poe> [ x | x@
01:17:54 <ezyang> so, f(n) = n?
01:18:01 <ezyang> as opposed to f(n) = x_n?
01:18:05 <ezyang> I guess that makes sense...
01:18:24 <Saizan_> right
01:18:39 <ezyang> ok. I really want to find out the type of * then
01:18:49 <Saizan_> remember that in this case that n is of type T(N)
01:19:06 <ezyang> right, which is how we get the "join" style functionality
01:19:18 <Saizan_> yup
01:19:32 <Saizan_> that's the definition of join haskell uses too
01:19:53 * ezyang should refresh his knowledge of the join implementations for the simple monads... 
01:20:04 <Saizan_> ?src join
01:20:05 <lambdabot> join x =  x >>= id
01:20:13 <ezyang> ohhh
01:20:15 <ezyang> ha ha ha
01:20:25 <Twey> Is ‘join’ part of Monad?
01:20:29 <Saizan_> no
01:20:36 <ezyang> > join [[1,2],[1,3]]
01:20:37 <lambdabot>   [1,2,1,3]
01:20:41 <dcestari> is there a way to tell cabal to do something like "ghc -make" ?
01:20:41 <Jonno_FTW> how can i return the element of a list which is not the other 2?
01:20:42 <ezyang> whee
01:20:56 <Twey> Couldn't one do (>>=)/join the same way as (==)/(/=)?
01:20:59 <dcoutts> dcestari: that's what it does do
01:21:10 <gwern> blast. bloody Space. ruins my list comp
01:21:13 <dcoutts> dcestari: what is the problem exactly?
01:21:15 <Twey> Jonno_FTW: ‘Not the other two’?
01:21:19 <Jonno_FTW> hyp = maximum [op',oq',pq']
01:21:22 <Jonno_FTW> 			opp = minumum [op',oq',pq']
01:21:23 <Jonno_FTW> 			adj = other   [op',oq',pq']
01:21:29 <dcestari> dcoutts: but it doesn't find my module, but ghc -make Main.hs works ok
01:21:37 <Jonno_FTW> the adj is neither the hyp nor the opp
01:21:39 <Twey> Jonno_FTW: delete?
01:21:41 <Twey> :t delete
01:21:43 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
01:21:53 <Saizan_> Twey: you could give a default def. for join, but not one for >>= without a Functor context
01:21:57 <dcestari> dcoutts: sorry
01:22:06 <Twey> > delete x [x, y, z]
01:22:08 <lambdabot>   [y,z]
01:22:10 <dcoutts> dcestari: have you specified, main-is: Main.hs in the executable section?
01:22:15 <dcestari> dcoutts: is because I need to run "happy parser.y" first
01:22:21 <Twey> > head . delete y . delete x $ [x, y, z]
01:22:23 <lambdabot>   z
01:22:28 <dcestari> dcoutts: can I tell cabal to do that?
01:22:33 <dcoutts> dcestari: cabal will run happy automatically, you just need to list all the modules
01:22:47 <ezyang> Twey: "might as well sort it and then index in"
01:23:02 <Twey> If it sorts
01:23:09 <Twey> The example doesn't
01:23:10 <ezyang> oh, that's true
01:23:13 <Twey> Eq doesn't imply Ord
01:24:35 <dcoutts> dcestari: I'm happy to look over your .cabal file and give you feedback, since this is your first time
01:24:40 <Twey> > listToMaybe foldr ($) [] . map delete [x, y] $ [x, y, z]
01:24:42 <lambdabot>   Couldn't match expected type `[a]'
01:24:42 <lambdabot>         against inferred type `(a1 -> b ...
01:24:42 <Twey> Er
01:24:45 <Twey> > listToMaybe . foldr ($) [] . map delete [x, y] $ [x, y, z]
01:24:47 <lambdabot>   Couldn't match expected type `a -> [[a1] -> [a1]]'
01:24:47 <lambdabot>         against inferred...
01:24:56 <Twey> Oh, duh
01:25:12 <Twey> > (listToMaybe .) . ($) . foldr (.) [] . map delete [x, y] $ [x, y, z]
01:25:14 <lambdabot>   Couldn't match expected type `a1 -> [a]'
01:25:14 <lambdabot>         against inferred type `[b]'
01:25:20 <Twey> *headscratch*
01:25:20 <Jonno_FTW> thanks
01:25:24 <dcestari> dcoutts: happy, hehe. I added "Other-Modules: Parser" and now runs happy
01:25:28 <Twey> Anyway, I think there's a function in Data.List for this
01:25:30 <Saizan_> you need an ap somewhere
01:25:53 <dcestari> dcoutts: thanks, all I need to do know is add happy Build-Dependencies
01:25:54 <Saizan_> > [x, y, z] \\ [x, y]
01:25:56 <lambdabot>   [z]
01:26:11 <ezyang> :t (\\)
01:26:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
01:26:19 <dcoutts> dcestari: really you need to list all the modules, otherwise it doesn't know what to pre-process or to put into the .tar.gz when you runghc Setup sdist
01:26:28 <int-e> > sort [y, x, z]
01:26:29 <lambdabot>   [x,y,z]
01:26:41 <Twey> Ahh
01:26:45 <Twey> I had the arguments backwards
01:26:53 <Twey> Yes
01:26:58 <int-e> > sort . scanl (+) 0 $ [y, x, z]
01:26:59 <lambdabot>   [0,0 + y,0 + y + x,0 + y + x + z]
01:27:01 <dcestari> dcoutts: should I add a Other-Modules for each module ?
01:27:34 <dcoutts> dcestari: no, say "other-modules: Foo, Bar, Baz"
01:27:37 <ezyang> why is the type for fold so weird...
01:27:50 <int-e> @type foldr
01:27:51 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:27:53 <dcoutts> dcestari: btw there are loads of example .cabal files on hackage
01:28:07 <joe____> what is the difference between $ and . ?
01:28:10 <int-e> ezyang: which fold, and what's weird about it?
01:28:12 * ezyang is referring to fold :: (s -> w -> w) -> ((s -> w) -> w) -> (n -> w) -> Expr s n -> w 
01:28:15 <Kim^Walkman> @src ($)
01:28:16 <lambdabot> f $ x = f x
01:28:17 <Kim^Walkman> @src (.)
01:28:18 <lambdabot> (f . g) x = f (g x)
01:28:21 <ezyang> in the sigfpe blogpost
01:28:22 <dcestari> dcoutts: thanks, I'll check them out. Any of them you know uses Happy ?
01:28:37 <ezyang> joe____: One is function composition, one is application
01:28:59 <joe____> thanks ezyang
01:29:05 <dcoutts> dcestari: yes several do, eg language-c :-)
01:29:11 <int-e> joe____: you can write  a . b $ c  as a $ b $ c, because $ is right associative.
01:30:03 <int-e> joe____: i.e. (a . b) $ c === a $ (b $ c) === a (b c)
01:30:54 <copumpkin> joe____: you sure you have enough underscores there?
01:31:12 <joe____> int-e: what about a $ b c
01:31:32 <dmhouse> That's fine too, joe____.
01:31:35 <joe____> copumpkin, i do not have a nickname and this is what the irc system assigns me.
01:31:38 <int-e> joe____: that's *another* way to write the same expression
01:31:44 <copumpkin> aw
01:31:52 <ezyang> hmm... I wonder if this internal "tree" structure is similar to the "stair-casing" pattern you get if you try to write monadic code w/o monads
01:32:02 <gwern> huzzah! it seems to work
01:32:26 <HaskellLove> compose =  foldr (◦) id where is this compositiong operator on keyboard? Isnt the dot operator for compositing?
01:32:59 <gwern> ugly tho :(
01:33:02 <ezyang> @hoogle compose
01:33:18 <joe____> int-e: what is the need for . ?
01:33:29 <lambdabot> No results found
01:33:39 <ezyang> joe____: Higher-order functions.
01:33:42 <int-e> hmm. U+25E6 WHITE BULLET
01:33:59 <ezyang> instead of functions that take values and return values, you make functions that take functions and return functions
01:34:17 <ezyang> and then things go kablooie
01:34:23 <int-e> joe____: you don't strictly need it. But it's convenient to write  f . g  instead of  (\x -> f (g x))  for function composition.
01:34:29 <dcestari> where is Char ? I mean, which library?
01:34:39 <oteren_> isnt a 'higher order function' just that you have a input and [a] outpout?
01:34:41 <int-e> joe____: and with time you'll likely find that this pattern occurs quite often.
01:34:47 <ezyang> dcestari: Data.Char?
01:34:53 <joe____> thanks guys.
01:35:17 <ezyang> oteren_: Not that I know of.
01:35:40 <oteren_> ah, we are both right
01:35:43 <oteren_> according to wikipedia :)
01:35:48 <oteren_> its one or the other
01:35:51 <byorgey> oteren_: no, a 'higher order function' is one that takes a function as an argument.
01:35:55 <int-e> > map (length . group . sort) ["a", "aa", "aba", "abcdeaa"] -- number of unique letters in each string
01:35:56 <lambdabot>   [1,1,2,5]
01:35:56 <oteren_> no wait
01:35:58 <oteren_> you are fully right
01:36:00 <oteren_> i misread :P
01:36:02 <dcestari> ups, is haskell98 ezyang
01:36:51 * ezyang needs to read the Haskell98 spec 
01:37:04 <copumpkin> nuh uh
01:37:06 <int-e> joe____: that last example would read more awkwardly without . - perhaps (\x -> length (group (sort x))) or (\x -> length $ group $ sort x)
01:37:07 <copumpkin> don't read it!
01:37:16 <byorgey> oteren_: in Haskell, functions which *return* functions are not all that special, because of currying
01:37:20 <int-e> copumpkin: why not?
01:37:33 <copumpkin> your eyeballs will turn black
01:37:39 * ezyang gasps in horror 
01:37:41 <dcestari> great! thanks dcoutts
01:37:44 <int-e> copumpkin: mine didn't ;)
01:37:46 <dcestari> dcoutts: cabal rocks
01:37:48 <dcestari> :P
01:37:50 <dcoutts> :-)
01:37:52 <copumpkin> a friend of mine did it! it's dangerous!!
01:38:00 <copumpkin> int-e: maybe you were wearing glasses
01:38:11 * ezyang thinks, "Oh man, I'm wearing glasses too." 
01:38:28 <int-e> copumpkin: but I agree that this is not a good place to start learning haskell. Except perhaps the appendix with the standard prelude - that is quite instructive.
01:38:44 <copumpkin> yeah
01:38:58 <ezyang> I was actually speaking to someone the other day, and he was like, "The Haskell98 report is like a math textbook... I liked it..."
01:39:20 <copumpkin> one of the toughest things to do
01:39:28 <copumpkin> is come up with a decent graph datastructure
01:39:34 <copumpkin> so many design choices!!
01:39:59 <int-e> ezyang: just as long as you know that you can always stop and read a tutorial or a book like real world haskell instead, I see no harm in looking at the report.
01:40:28 <int-e> copumpkin: I hear there are whole books on "efficient graph representations."
01:40:31 <aavogt> maybe if you can understand the grammars given
01:41:46 <ezyang> I consider myself fairly well-versed in the basics of Haskell, which is why I think it's ~about time to read the spec.
01:42:06 <copumpkin> make sure you keep those glasses on
01:42:13 <ezyang> aye aye captain
01:42:57 <joe____> int-e: can I use . in:  map ( \(a,b,c) -> TestCase $ assertEqual a b $ take (length b) c ) testresults
01:43:30 <joe____> type TestResult = (Message,Stack,Result)
01:45:28 <int-e> joe____: not in that case, no - there are no nice functions for taking apart triplets.
01:45:29 <joe____> and testresults is an array of TestResult
01:45:36 <ezyang> What's a type variable?
01:45:42 <int-e> @pl \(a,b,c) -> TestCase $ assertEqual a b $ take (length b) c
01:45:55 <ezyang> oh, it's a, b, c
01:46:06 <int-e> @type 5
01:46:37 <int-e> ezyang: A variable which ranges over types instead of values (as normal variables do)
01:47:42 <joe____> ok, thanks int-e.
01:47:45 <int-e> in id :: a -> a, a is a type variable. It's implicitely universally qualified, i.e. the type is really  id :: forall a . a -> a
01:49:09 <HaskellLove> someone told me i will need monads in three months not sooner... what is this thing when you start needing monads? when u starrt writing interactive programs or what?
01:50:04 <ezyang> I needed monads in the very first program I wrote in Haskell
01:50:08 <int-e> HaskellLove: You can use IO without understanding monads.
01:50:10 <ezyang> (because I used a map >.>)
01:50:13 <Baughn> HaskellLove: You never /need/ monads. Except for IO (which is really easy, and you don't need to understand monads to use), they're only to make programs easier
01:50:18 <Zao> HaskellLove: You use them rather soon, you just don't know it yet :)
01:50:19 <Veinor> strictly speaking, whenever you deal with functions, you deal with monads :P
01:50:24 <Veinor> same for lists
01:50:27 <jmcarthur_work> HaskellLove, when you start writing programs complex enough to benefit from monads
01:50:27 <ezyang> You probably already use them.
01:50:29 <Baughn> HaskellLove: It's more like, in three months you'll be writing functions whose simple implementation uses monads
01:50:37 <Baughn> *simplest
01:50:40 <jmcarthur_work> HaskellLove, when you start writing programs complex enough to benefit *a whole lot* from monads
01:50:44 <Philonous1> HaskellLove: You need a basic understanding of monads when you want to do I/O. I'd suggest investigating monads when you have a good grasp about haskell's santax, types and type classes
01:50:56 <Philonous1> syntax*
01:51:02 <HaskellLove> I see
01:51:03 <Baughn> Not really. He needs a basic grasp of the *IO* monad.
01:51:09 <int-e> HaskellLove: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html seems relevant.
01:51:15 <Baughn> That one's very simple compared to most of the others
01:51:30 <jmcarthur_work> for IO, just mentally substitute Monad m => m with IO
01:51:31 * hackagebot upload: hmatrix-static 0.2 - hmatrix with vector and matrix sizes encoded in types (ReinerPope)
01:52:38 <jmcarthur_work> in fact, you can even use monads without understanding them. for example, if you need the Maybe monad, just use the same monad documentation but mentally substitute Maybe for Monad m => m instead of IO
01:52:56 <jmcarthur_work> you only really need to understand them when you start writing your own
01:53:12 <int-e> Monads are a very abstract concept; they come in many shapes, simple and complex, and you'll encounter the simple ones soon enough. You'll need more examples to understand the concept of monads, their essence, that they all have in common (which really is very little - look at the Monad class).
01:53:14 <jmcarthur_work> and by the time you get there you should realize there isn't all that much to understand anyway
01:53:48 <Baughn> "Monad" is nearly as abstract as "function", and a whole lot less studied in middle school. ;)
01:54:13 <copumpkin> it seems more abstract :)
01:54:21 <copumpkin> a function is fairly straightforward
01:54:37 <int-e> you've gotten used to functions
01:54:46 <int-e> *got
01:55:02 <Berengal> ... I sometimes say "abstraction" when I mean "function" ...
01:55:03 <copumpkin> it's just a simpler concept to define
01:55:48 <copumpkin> I mean, the definition of monad is pretty simple too
01:56:00 <Veinor> it seems like once you write a thing that actually needs monads, you'll finally get them
01:56:00 <Baughn> Monads have more structure than functions, which makes them less abstract..
01:56:15 <Baughn> Otherwise, I'd say they're at about the same level of abstraction
01:56:16 <Philonous1> I always found monads easier to understand when thinking of them as Kleisli-arrows. Because those are just "beefed up" functions.
01:56:17 <jmcarthur_work> Veinor, nothing needs monads
01:56:19 <int-e> right. but the definition doesn't tell you why they'd be useful for programming.
01:56:24 <Veinor> well, you know what I mean
01:56:44 <copumpkin> Baughn: I'd say their abstraction is incomprable unless the set of requirements on one is a subset of the set of a requirements on the other
01:57:36 <jmcarthur_work> copumpkin, kleisli arrows?
01:57:53 <copumpkin> jmcarthur_work: what about them?
01:58:02 <copumpkin> you can construct a category on top of a monad
01:58:23 <jmcarthur_work> well, one could describe functions in terms of the identity monad
01:59:01 <ezyang> Wow, the first part of Haskell98 is pretty mind-numbin
01:59:05 <jmcarthur_work> this is in the haskell sense, i suppose. i don't know if that generalizes to the categorical monads
01:59:31 <jmcarthur_work> i'm sure monads could be described in terms of functions, too, somehow
01:59:37 <copumpkin> jmcarthur_work: I think you can build a kleisli category on top of any monad
01:59:50 <jmcarthur_work> i would say neither is more "abstract"
02:00:03 <copumpkin> jmcarthur_work: yeah :)
02:00:20 <jmcarthur_work> it's like saying the world is fundamentally imperative or fundamentally declarative
02:00:24 <Baughn> @src IO mfix
02:00:32 <jmcarthur_work> it's not really either, in my opinion
02:00:52 <copumpkin> gah, sets frustrate me!
02:01:09 <Jonno_FTW> hmm
02:01:21 <Baughn> jmcarthur_work: The evaluation model of the world? Oh, it's lazy evluation, with main = evaluate (rnf (historyOf particleThatIsAboutToCrossTheHorizon))
02:01:23 <Philonous1> @bot
02:01:23 <lunabot>  :o
02:01:28 <copumpkin> why must they be so hard to represent in a pure manner?
02:01:43 <jmcarthur_work> copumpkin, pure in the haskell sense?
02:01:47 <copumpkin> nope
02:01:58 <copumpkin> pure in the no polluting requirements sense
02:02:00 <copumpkin> no Ord, no Eq
02:02:01 <copumpkin> :P
02:02:17 <jmcarthur_work> ah yeah
02:02:31 <jmcarthur_work> well... Eq makes some sense. sets don't contain duplicates
02:02:39 <copumpkin> yeah
02:02:47 <jmcarthur_work> Ord is just for efficiency
02:02:54 <copumpkin> but people still talk about sets of functions
02:03:04 <copumpkin> mathematicians are so lax
02:03:05 <copumpkin> tsk tsk
02:03:26 <Jonno_FTW> can someone help me?
02:03:31 <jmcarthur_work> well, it's possible to prove functions as equal or not equal in specific cases, just not in general
02:03:40 <Jonno_FTW> doing this problem
02:03:49 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=91
02:03:50 <copumpkin> jmcarthur_work: yeah, sure
02:03:53 <jmcarthur_work> unfortunately, the haskell type system would prefer that you be able to do that in general
02:04:01 <Jonno_FTW> with this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13881#a13881
02:04:10 <jmcarthur_work> a subset of functions as a new data type, however, could be stored in a haskell Set, i'm sure
02:04:19 <Jonno_FTW> it returns an empty list forr the example given and i don't know why
02:04:32 <jmcarthur_work> where the construction of a value of that type satisfies certain constraints and carries certain information suitable for Eq
02:04:39 <copumpkin> jmcarthur_work: I'm tempted by an a -> Bool representation
02:04:45 <copumpkin> but it's not very pretty :P
02:04:53 <jmcarthur_work> for set?
02:04:57 <copumpkin> yeah
02:05:04 <copumpkin> Eq a => a -> Bool
02:05:07 <Baughn> Can't you just use reallyUnsafePointerEquality?
02:05:22 <copumpkin> not necessarily
02:05:23 <jmcarthur_work> Baughn, besides not actually comparing the functions, you mean?
02:05:35 <jmcarthur_work> Baughn, for a multiset that would be fine, i think
02:05:36 <copumpkin> I mean coming up with a nice representation for sets
02:05:38 <copumpkin> not an ugly hack
02:05:52 <cwraith> Jonno_FTW: did you ever solve 266?  (turns out branch & bound is much too slow)
02:05:53 <Philonous1> I think mathematicians don't mean decidable equality when they are talking about equality
02:06:01 <Jonno_FTW> nope
02:06:03 <Baughn> jmcarthur_work: Hm. Well, in certain zen circles, _ == _ = True would do fine
02:06:04 <jmcarthur_work> Baughn, well, besides update, removal, etc. just for insertion it would work
02:06:23 <jmcarthur_work> copumpkin, what is the semantic model for Set?
02:06:39 <copumpkin> jmcarthur_work: beats me
02:06:45 <copumpkin> jmcarthur_work: I want this for agda, fwiw
02:06:48 <Jonno_FTW> i went back to problem 91 and now i'm stuck
02:06:52 <copumpkin> and I want it to be convenient for proofs
02:06:56 <jmcarthur_work> ah
02:07:27 <zygoloid> jmcarthur_work: if it weren't for toList, it could be Set a = a -> Bool
02:07:42 <jmcarthur_work> zygoloid, yeah, the membership function
02:08:13 <jmcarthur_work> which even alone sounds like it would need at least an Eq constraint
02:08:20 <EvanCarroll> is there an easy way to remember what order the function paramters are in for foldr and foldl, and where initial value is processed first/last
02:08:49 <EvanCarroll> foldl is \acc x foldr is \x acc, why is that?
02:08:58 <copumpkin> EvanCarroll: left/right
02:09:27 <jmcarthur_work> :t foldr
02:09:42 <jmcarthur_work> ugh, no lambdabot
02:09:54 <jmcarthur_work> #ty foldr
02:09:58 <lunabot>  forall b a . (a -> b -> b) -> b -> [] a -> b
02:10:06 <cwraith> Jonno_FTW: one thing I'd do, just to simplify the code, is work with distance^2 rather than distance...  everywhere.
02:10:15 <jmcarthur_work> #ty foldl
02:10:17 <lunabot>  forall b a . (a -> b -> a) -> a -> [] b -> a
02:10:21 <Jonno_FTW> hmm
02:10:30 <jmcarthur_work> that looks like the same argument order to me...
02:10:44 <jmcarthur_work> besides the function argument, of course
02:10:59 <Jonno_FTW> cwraith: i did that with isRight
02:11:18 <EvanCarroll> and how do you phrase it, that foldr/foldl changes association of the function? And, then how you do you explain the associativeness if you're explaining an operater?
02:11:20 <Jonno_FTW> or do i fix it up at the top
02:11:33 <cwraith> Jonno_FTW: yeah, I was just looking at op, oq, and pq
02:12:00 <EvanCarroll> oh wait. I see
02:12:27 <Jonno_FTW> do i even need sqrt in that case?
02:12:40 <EvanCarroll> you would phrase it, "The association of the arguments to fold are changed through the suffix, foldr, and foldl, while retaining the initial property of the function or infix operator?"
02:12:52 <cwraith> Jonno_FTW: my point is exactly that.  remove those sqrts, then remove the squares in isRight
02:13:19 <cwraith> Jonno_FTW: in fact, there's a good chance that's why it's not working.  you're checking for exact equality with floating point numbers.
02:13:20 <Jonno_FTW> but then it isn't pythagoras
02:13:55 <cwraith> Jonno_FTW: it is..  You're still comparing distance^2.  You're just never doing a sqrt op, so you're never going to floating-point
02:14:07 <Jonno_FTW> ok
02:15:07 <Jonno_FTW> i thought it would work fine though
02:15:42 <Jonno_FTW> i'll work on this later
02:15:44 <EvanCarroll> how would you split an array [1..100] on every third element, returning a list of lists of three elements?
02:15:45 <Jonno_FTW> i need sleep
02:15:55 <cwraith> Jonno_FTW:  the problem is that floating-point math is inexact.  You're doing == calculations.  there's no guarantee that (sqrt 2) ^ 2 == 2
02:16:07 <EvanCarroll> oh wait
02:16:13 <EvanCarroll> i got an answer to this last night after i left
02:16:15 <EvanCarroll> http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html#v%3Achunk
02:16:40 <EvanCarroll> Saizan_: Thanks!
02:19:35 <cwraith> > (sqrt 2 :: CReal) ^ 2 == 2
02:19:45 <cwraith> oh, right.  lambdabot is dead
02:22:00 <chrisdone> I once heard a ruby programmer mocking lisp's ))))). ironic since there is the same complaint of end end end end
02:22:24 <zygoloid> @hoogle a -> (a -> Bool) -> (a -> a) -> a
02:22:46 <zygoloid> preflex: seen lambdabot
02:22:46 <preflex>  lambdabot was last seen on #haskell 46 minutes and 48 seconds ago, saying:   [1,1,2,5]
02:23:13 <chrisdone> preflex: be james spader
02:23:14 <preflex>  no quotes found for james spader
02:23:16 <medfly> , (sqrt 2 :: CReal) ^2 == 2
02:23:16 <lunabot>  luna: Not in scope: type constructor or class `CReal'
02:25:16 * hackagebot upload: Monocle 0.0.0 - Symbolic computations in strict monoidal categories with LaTeX output. (OsmanBineev)
02:31:54 <luite> @type (<$>).(<$>)
02:32:27 <mbuf> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/chalmers-lava2000 creates a shared library, libHSchalmers-lava2000-1.0.2.a, how do I import the module to test it?
02:32:46 <mbuf> when I use runghc Setup configure, build
02:41:17 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13884#a13884 I need opinions here, when you update send me pm or a link on this channel
02:41:42 <HaskellLove> Specific advices are welcomed not just, ah well use some managment tool bla bla
02:42:14 <copumpkin> heh
02:43:44 <byorgey> mbuf: you need to import one or more packages that it exports.  for example,  'import Lava2000' at the top of your .hs file
02:44:06 <byorgey> mbuf: if that doesn't answer your question, then I'm not sure what you are asking.
02:44:35 <mbuf> byorgey, thanks; and where does this .hs file need to be to recognize the .a file?
02:45:18 <mbuf> byorgey, also in the README file, it says set Lava2000/LavaDir.hs to correct path, does it mean path to chalmers-lava2000-1.0.2?
02:46:33 <byorgey> mbuf: is there a reason you don't want to do  runghc Setup install?
02:46:55 <byorgey> that will install the shared library in a standard place so it can be accessed from any .hs file, anywhere
02:47:08 <byorgey> mbuf: I don't know what path it means
02:47:08 <mbuf> byorgey, I can do that too
02:47:13 <mbuf> byorgey, ok
02:47:23 <mbuf> byorgey, runghc Setup install as root?
02:48:06 <byorgey> mbuf: if you'd rather install it locally, you can do  runghc Setup configure --user --prefix=some/local/path
02:48:11 <byorgey> and then build and install
02:48:14 <mbuf> byorgey, ok
02:48:21 <mbuf> byorgey, thanks for your help
02:48:51 <byorgey> mbuf: sure.
02:51:39 * EnglishGent waves to copumpkin & byorgey :)
02:51:47 <copumpkin> hi :)
02:52:22 <Veinor> whee, time to write my Base-Depends line
02:52:34 <Veinor> er, Build-Depends
02:53:37 <Veinor> Warning: 'license: MIT' is not a recognised license.
02:54:10 <Veinor> bleh
02:54:35 <Veinor> where's a list of what licenses Cabal recognizes, then?
02:55:07 <Veinor> ah, found it
02:56:51 <byorgey> hi EnglishGent =)
02:57:28 <dcoutts> Veinor: MIT is recognised from Cabal-1.8 onwards and it's ok to use now. Cabal-1.6 will warn but that's ok.
02:57:34 <Veinor> ah, okay
02:57:39 <Veinor> I wonder what the difference is, anyway
02:57:40 <dcoutts> hackage upload should allow it already
02:57:49 <dcoutts> Veinor: between what?
02:58:00 <Veinor> between MIT and BSD3.
02:58:31 <Baughn> , \n -> 16 - n `mod` 16
02:58:32 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a))
02:59:26 <Veinor> Wikipedia says they're very similar
02:59:26 <mreh> , @seen mmorrow
02:59:27 <lunabot>  luna: parse error on input `@'
02:59:36 <mreh> , seen mmorrow
02:59:37 <lunabot>  luna: Not in scope: `seen'
02:59:56 <mreh> , help
02:59:58 <lunabot>  type of an expression:      , [$ty| \x -> x |]
02:59:58 <lunabot>  get info for a type/class:  , src ''Monad
02:59:58 <lunabot>  get info for a var/con:     , src 'fix
03:00:14 <Philonous1> Veinor: BSD3 prohibits advertising with the name of the original author. BSD-2 drops this and is thus equivalent to MIT
03:00:25 <Veinor> Philonous1: I thought that clause was BSD4.
03:00:38 <Veinor> ahhh.
03:00:46 <Veinor> my mistake, was thinking of a different one.
03:01:20 <mreh> @seen lament
03:01:34 <Veinor> anyway, yeah. I think I'll go with BSD3, then, seems more in line with what I want.
03:01:42 <Veinor> Not like it matters for my piddly little program anyway :B
03:02:01 <roconnor> @tell cads  http://wiki.nixos.org/wiki/InstallingOnVirtualBox
03:03:18 <mreh> @botsmack
03:03:19 <lunabot>  :o
03:06:01 <mreh> where is lambdabot?
03:06:15 <Badger> obsoleted by lunabot
03:06:20 <copumpkin> DEAD
03:06:24 <monochrom> dating
03:06:45 <mreh> necrophilia
03:07:07 <mreh> how do I ask lunabot if s/he has seen someone?
03:07:17 <dolio> Use preflex for that.
03:07:24 <mreh> who's preflex?
03:07:32 <dolio> preflex: seen copumpkin
03:07:32 <preflex>  copumpkin was last seen on #haskell 1 minute and 11 seconds ago, saying: DEAD
03:07:41 <mreh> preflex: seen morrow
03:07:41 <preflex>  Sorry, I haven't seen morrow
03:07:50 <copumpkin> preflex: seen mmorrow
03:07:50 <mreh> preflex: seen mmorrow
03:07:50 <preflex>  mmorrow was last seen on #haskell 1 day, 17 hours, 27 minutes and 18 seconds ago, saying: mreh: i've gotta disappear, but i'm always in here..
03:07:51 <preflex>  mmorrow was last seen on #haskell 1 day, 17 hours, 27 minutes and 18 seconds ago, saying: mreh: i've gotta disappear, but i'm always in here..
03:08:00 <monochrom> heh
03:08:05 <mreh> lulz
03:08:19 <Twey> Heheh.
03:08:35 <mreh> does lunabot quote?
03:08:51 <ruediger> hi
03:08:51 <dolio> I don't think so.
03:08:58 <dolio> , craps
03:08:59 <lunabot>  luna: No instance for (GHC.Show.Show (o -> (Luna.ST.Die, Luna.ST.Die)))
03:09:13 <byorgey> hi ruediger
03:10:21 <mreh> preflex: seen lament
03:10:21 <preflex>  lament was last seen on #haskell-blah 32 minutes and 2 seconds ago, saying: -------¬_______
03:10:22 <mbuf> haskell package is installed in /usr/local/lib/chalmers-lava2000-1.0.2/ghc-6.10.3, how to uninstall it? sudo runghc Setup unregister?
03:11:08 <byorgey> mbuf: ghc-pkg --global unregister chalmers-lava2000
03:11:09 <mreh> what a peculiar thing to say
03:12:00 <lament> mreh: sup
03:12:36 <mreh> i was wondering if I could include your parser in my automatic score generation library
03:12:50 <dolio> , randM (replicateM 4 crapsM)
03:12:51 <Veinor> every time I run cabal install cabal-install I laugh a little inside
03:12:52 <lunabot>  [(⚃,⚅),(⚂,⚁),(⚁,⚃),(⚃,⚄)]
03:13:08 <mbuf> byorgey, and I just rm -rf the folder?
03:13:15 <HaskellLove> anyone knows where I can get Wadler book Introduction to Functional Programming on torrent or rapidshere link? pm me please
03:13:23 <dpiponi> ezyang: If you have any questions about my post, now's your chance. (I think it was you asking, I just looked in the logs.)
03:13:35 <mreh> lament:  i was wondering if I could include your parser in my automatic score generation library
03:13:43 <dcoutts> Veinor: I'm planning to shorten it to just "cabal install cabal" hopefully that doesn't spoil the joke
03:13:52 <ezyang> dpiponi: Hmm, so I slogged through it a little further
03:14:09 <ezyang> I think I got stuck on the fold
03:14:26 <Veinor> aw :(
03:14:27 <Veinor> Data/Nimber.hs:6:7: file name does not match module name `Nimber'
03:14:28 <ezyang> and the general algebraic language defined in the post is kind of fuzzy
03:14:33 <Veinor> what am I doing wrong here?
03:14:37 <aavogt> Veinor: must be Data.Nimber
03:14:44 <dpiponi> ezyang: One thing I should say is that I don't care about this algebra. It's not very interesting in its own right. The point is that an algebra of some sort exists.
03:14:51 <aavogt> or don't stick the Nimber.hs in the data directory
03:14:53 <Veinor> ah.
03:14:56 <ezyang> dpiponi: Ah.
03:15:07 <ezyang> "what is an Algebra?"
03:15:09 <Veinor> aavogt: I put it in Data/ because I was given to understand I'd need to do that for cabal packaging.
03:15:20 <dpiponi> ezyang: I didn't go into the fold as it's a standard thing though I'm not sure where to point you for more info.
03:15:42 <ezyang> dpiponi: Well, the function type was kind of odd for a fold
03:15:56 <aavogt> Veinor: then I think you need to specify hs-source-dirs:  Data
03:16:07 <aavogt> or you already have?
03:16:09 <Veinor> I fixed it
03:16:10 <dpiponi> An algebra is just a bunch of operators (like '+', '-') that satisfy a bunch of equations like 'a(b+c)=ab+ac' in ordinary arithmetic.
03:16:21 <byorgey> mbuf: sure, if you want
03:16:30 <lament> mreh: sure, go ahead, let's say it's GPL
03:16:39 <sproingie> it's math with symbols
03:16:51 <mbuf> byorgey, thanks
03:17:21 <ezyang> But the "flow control" algebra very clearly doesn't have things like associativity or commutativity
03:17:28 <HaskellLove> anyone knows where I can get Wadler book Introduction to Functional Programming on torrent or rapidshere link? pm me please
03:17:30 <dpiponi> ezyang: "Effects", like state, can be described by an algebra instead of with a monad. You can then derive the monad from the algebra. But there's a case that can be made that it's the algebra that's more fundamental.
03:17:49 <dpiponi> An algebra is a bit like defining writing a spec for an API. You're saying that we have these functions and they interact in this way.
03:18:08 <sproingie> what i'd like to know is what's the difference between an algebra and a calculus
03:19:05 <dolio> "Algebra" has actual formal meanings, and calculus doesn't? :)
03:19:18 <monochrom> I disagree.
03:19:27 <byorgey> AFAICT "calculus" is just academese for "system"
03:19:31 <sproingie> (one's an arabic name, the other is the stuff that builds up on your teeth)
03:19:46 <dpiponi> sproingle: Not convinced there's a difference. People use both words informally to mean some kind of system with rules and equations.
03:20:00 <byorgey> monochrom: you think "calculus" has an actual formal meaning?
03:20:01 <dolio> You do? I don't think I've ever seen "a calculus is defined as an n-tuple ...".
03:20:08 <dpiponi> Although 'algebra' does have some very specific meanings (more than one in fact, very confusing!)
03:20:26 <mreh> lament: thx
03:20:29 <ezyang> Mathematicians are very guilty of name overloading
03:20:32 <monochrom> Oh, you mean the word itself. I was thinking examples of calculi.
03:20:54 <ezyang> dpiponi: Ok, so I guess I see the point of your post a little more clearly, now
03:21:05 <monochrom> But I can give one anyway. A calculus is a bunch of syntactic rules.
03:21:11 <mreh> calculus means pebble in latin
03:21:13 <ezyang> which is that monadic computations (in the State monad) can be represented as data-structures themselves, which are trees
03:21:19 <ezyang> and which correspond to the algebra you defined
03:21:29 <sproingie> Lambda Pebble
03:21:42 <dolio> monochrom: Yeah, that's pretty good.
03:21:45 <monochrom> An algebra promises equational rules. A calculus can has rules not equational.
03:21:50 <Apocalisp> Pebble is an awesome name for a PL
03:21:58 <mreh> recalcitrant, means "like a stone" i.e. annoying
03:22:01 <ezyang> mreh: Huh.
03:22:05 <mreh> there's some phone called a pebble
03:22:05 <ezyang> curious
03:22:09 <lament> mreh: but I reserve the right to curse your project with a powerful, vile ancient curse
03:22:14 <sproingie> so "calculator" refers more or less to an abacus?
03:22:18 <Rotaerk> I can has rules not equational
03:22:21 <ezyang> "Lambda Pebbles: A great way to start the day!"
03:22:33 <mreh> lament: okay
03:22:34 <dolio> Barney!
03:23:12 <dpiponi> ezyang: that thing I call a fold is also called a catamorphism. I'm sure there are dozens of tutorials on them but for some reason they've all gone into hiding on me!
03:23:26 <ezyang> I actually have one on hand
03:23:34 <ezyang> But I haven't actually sat down and done the exercises yet ^_^
03:23:51 <sproingie> is there a morphism name for a zip?
03:23:55 <dolio> There's the original "... Bananas ...", but the notation is pretty hardcore.
03:24:22 <Saizan_> the type of the fold function follows the same pattern as foldr
03:24:23 <dpiponi> I learn about catamorphisms from this, but it wasn't easy: http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
03:24:28 <Saizan_> ?type foldr
03:24:39 <mreh> dolio: lense and bananas
03:24:42 <Saizan_> ?bot
03:24:42 <mreh> lenses
03:24:52 <monochrom> For the record: "system" is patentese for calculus.
03:24:56 <dolio> Yes, and envelopes and barbed wire.
03:24:57 <mreh> washing her hair
03:24:58 <Voker57> @type foldr
03:25:02 <sproingie> frown.  reactive-glut won't compile
03:25:03 <dolio> But I was trying to save myself some typing. :)
03:25:09 * ezyang "This Diagram Commutes!" 
03:26:02 <Saizan_> meh, however you take a function for each constructor and replace the occurrence of the type of the tree with the type of the result of the fold
03:26:57 <Saizan_> (:) :: a -> [a] -> [a] becomes a -> b -> b, [] :: [a] becomes b, in fact you've foldr :: (a -> b -> b) -> b -> [a] -> b
03:27:00 <dolio> I also like A Tutorial on (Co)Algebras and (Co)Induction.
03:27:05 <sproingie> hay where's lambdabot?
03:28:53 <dpiponi> I wonder if "calculus" can be viewed as emphasising doing transformations on algebraic things. Like differential calculus is about an operator that turns expressions into expressions.
03:29:09 <dpiponi> Lambda calculus is about reductions in terms.
03:30:03 <ezyang> "calculus is about calculation"
03:30:57 <sw17ch__> *sigh*
03:31:13 <Twey> Calculation is just reduction of terms anyway.  :þ
03:32:10 <fritschy_> hey there - i am having trouble getting timing information when using ghc's cost centre for profiling - all timing information is 0.0... any idea what's wrong there?
03:33:13 <dolio> dpiponi: I don't know. A lot of calculi seem to involve binders/quantifiers, while algebras tend to be about combining elements of a language with operations.
03:33:26 <dolio> Lambda calculi, predicate calculi, relational calculi.
03:33:34 <dolio> Vs. relational algebra...
03:33:53 <dpiponi> dolio: predicate calculus, that's a good counterexample to what I said.
03:33:54 <dolio> If I recall correctly.
03:34:04 <sproingie> i've heard of relational calculus tho
03:34:20 <dpiponi> I think the truth is this: if the person who invented X called it a calculus and published their result then everyone else calls it a calculus.
03:34:29 <sproingie> i'll buy that
03:35:27 <lament> algebras are about representing the state of some system in terms of a set of simple states and operations on/between them
03:35:32 <dolio> I'm not sure how "calculus" fits into my definition. I guess some notations sort of have the differentiation and integration operators binding a variable of sorts.
03:37:11 <dolio> Of course, the (first order) propositional calculus doesn't have quantifiers. Maybe it should be predicate algebra. :)
03:37:11 <sproingie> i'll go with "it's a cooler name than `system'"
03:37:51 <Veinor> man, I turned on -Wall in my package and now I'm getting a bunch of warnings
03:38:05 <lament> quick, turn it off!
03:38:11 <Veinor> :o
03:38:17 <mauke> alias ghc='ghc 2>/dev/null'
03:38:28 <HaskellLove> I am watching presentation of F# and it says it has functional core and objects. Does Haskell have objects?
03:38:37 <mauke> fix'd
03:38:37 <sproingie> HaskellLove: not in the OOP sense, no
03:38:39 <mauke> HaskellLove: no, not really
03:38:57 <aavogt> what is a "functional object"
03:39:10 <sproingie> F# is a good deal more multiparadigm than haskell
03:39:17 <Veinor> some of them are just shadowing errors
03:39:21 <Veinor> er, warnings
03:39:23 <mauke> aavogt: probably one where methods return a new object instead of mutating
03:39:38 <monochrom> "process calculus" and "process algebra" haha
03:40:21 <monochrom> For the most part, you turn a process algebra into a process calculus by oriented the equational axioms of the algebra.
03:40:22 <Veinor> eh, I think I can disable -Wall
03:40:35 <monochrom> s/oriented/orienting/
03:40:38 <aavogt> maybe -W is enough?
03:40:59 <sproingie> is there a way to disable specific warnings after -Wall?
03:41:01 <Veinor> I yeah, that works
03:41:03 <sproingie> i'd love to disable shadowing warnings
03:41:04 <Veinor> -I
03:41:09 <aavogt> shadowing does lead to subtle bugs sometimes... missing type signatures not so much
03:41:16 <dcoutts> sproingie: yes, -wno-blah-blah
03:41:20 <kmc_> HaskellLove, Haskell's existential types are somewhat like OO objects
03:41:32 <Veinor> okay, I might have something wrong in my .cabal file
03:41:39 <dcoutts> sproingie: all the warning flags are documented in the ghc user guide
03:41:53 <JackSMith> get windows keys for cheap http://bit.ly/5Tgz2X :)
03:41:58 --- mode: ChanServ set +o mauke
03:42:01 <lament> HaskellLove: F# has two type systems - one similar to that of Haskell, and another ("objects") identical to that of C# and Visual Basic
03:42:02 --- mode: ChanServ set +o dcoutts
03:42:09 <dcoutts> bah
03:42:12 <mauke> there should be a ghc --help-all that lists all options
03:42:15 <Veinor> module main:Data.Nimber is not loaded
03:42:18 <Veinor> what does this mean?
03:42:19 <HaskellLove> I changed my name from scalaLove to HaskellLove, should I change to F#LOve? :(
03:42:31 <lament> Yes.
03:42:35 <kmc_> having two type systems sounds ugly
03:42:40 <copumpkin> it is
03:42:43 <lament> it does
03:42:50 <kmc_> it's not hard to make one type system that handles both objects and first-class functions well
03:42:56 <Zao> Associat0r: Do you have anything to say in defence of F#? :)
03:42:57 <lament> kmc_: it is hard
03:42:59 <dcoutts> Veinor: it means the source file is available locally but you've not loaded it.
03:42:59 --- mode: mauke set -o mauke
03:43:00 <kmc_> if everything is an object, then functions are objects
03:43:05 <sproingie> HaskellLove: rather polylingualamorous, aren't we?
03:43:09 --- mode: ChanServ set -o dcoutts
03:43:13 <Veinor> dcoutts: explain what I need to do
03:43:13 <lament> kmc_: the problem is not that you need to combine those functionalities, the problem is that you have to interoperate with the rest of .net
03:43:20 <kmc_> yeah
03:43:22 <monochrom> Why do you even call yourself <language>love
03:43:26 <HaskellLove> sproingie yep
03:43:30 <lament> kmc_: and an HM type system just doesn't do well as .NET objects
03:43:32 <dcoutts> Veinor: :load The.File.You.Want.hs
03:43:44 <sproingie> The/File/You/Want.hs
03:43:46 <kmc_> HaskellLove: http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
03:43:48 <Veinor> I'm trying to install it along with the rest of the libraries, though
03:43:48 <sproingie> :load takes paths
03:43:58 <dcoutts> sproingie: yep thanks
03:43:58 <Veinor> so I can just do :m +My.Module
03:44:10 <sproingie> :load is so you can :reload
03:44:19 <Associat0r> Zao I am eating
03:44:20 <dcoutts> Veinor: no, because the file is there locally, and local ones mask packages.
03:44:33 <Veinor> hm.
03:44:43 <Associat0r> but in short F# is great and everyone on .NET should use it
03:44:47 <Veinor> ahhhh, okay.
03:44:53 <Veinor> yeah, it works from a different directory
03:45:01 <dcoutts> Veinor: if you've built and registered the package then yes you can :m The.Module, but you need to cd somwhere else first so it doesn't find the local sources.
03:45:15 <lament> Associat0r: what advantages does it offer over C#?
03:45:33 <dcoutts> lament: it encourages the functional style
03:45:35 <Veinor> ah, okay. also, is there a cabal remove or something?
03:45:43 <kmc_> pattern matching, lightweight syntax for function literals
03:46:01 * zygoloid reads up. get windows keys for cheap? i already have two free ones on my keyboard which i'm not using...
03:46:01 <dcoutts> Veinor: you mean to unregister packages? ghc-pkg unregister blah
03:46:13 <monochrom> hahaha
03:46:17 <lament> dcoutts: c# sort of does that more and more
03:46:24 <Veinor> zygoloid: lol
03:46:28 <sproingie> C# hardly does that with a minimum of fuss
03:46:29 <dcoutts> lament: it allows it, it doesn't encourage it
03:46:47 <dcoutts> lament: C# is basically java, F# is basically (Oca)ML
03:46:49 <lament> dcoutts: my coworkers already try to replace foreach loops with linq whenever possible :)
03:47:10 <monochrom> yay for linq
03:47:20 <lament> dcoutts: sure, but C# is far more functional than java, and F# has the same basic object model as C#
03:47:47 <sproingie> yes it's all .NET CLR in the end
03:47:53 <jlouis_> mmm, cml looks so much more inviting compared to chp
03:47:57 <dcoutts> lament: I think there's still a much bigger difference between C# and F# than between C# and Java, from a language POV
03:48:02 <sproingie> but i'd still rather use scala than java even if it's just all java bytecode in the end
03:48:31 <dcoutts> lament: F# can quite legitimately be called a functional language, C# really can't
03:48:38 <sproingie> tho scala vs java is one area where you see tooling really win the day
03:48:46 <dolio> F# has active patterns. C# doesn't, does it?
03:49:31 <lament> dcoutts: right, i just suspect that any practical use of F# will involve so much state that it might as well be written in C#
03:50:10 <sproingie> there's more to functional idioms than purity
03:50:20 <dcoutts> lament: depends on whether you're using it to glue together existing .net libs or whether you're making a separate component
03:50:23 <sproingie> it's not like ocaml is pure either
03:50:24 <monochrom> Perhaps F# has much better type signatures than C#
03:50:36 <lament> dcoutts: i guess
03:50:42 <dcoutts> sproingie: no but ocaml has mostly pure libs and encourages purity as the default
03:50:51 <sproingie> and F# could go that way
03:51:14 <sproingie> in doing so, it could probably do optimizations C# would find difficult
03:51:18 <dcoutts> it's more constrained by the imperative APIs of the rest of the platform
03:51:50 <dcoutts> sproingie: only in it's pure subset, which is hard to contain since types don't help you in an impure language
03:51:52 <lament> sproingie: it's not just "purity" in an abstract way, it's the fact that the main data entities you're dealing with are .NET objects, designed in every way for stateful uses
03:53:50 <lament> so trying to be too functional with them is using a hammer as a screwdriver
03:53:59 <lament> or a screwdriver as a hammer
03:54:07 <sproingie> done that a few times
03:54:20 <Associat0r> only pure FP is FP
03:54:24 <lament> oh, man, that table from IKEA
03:54:32 <Associat0r> the rest is just bonus
03:54:36 <lament> you're supposed to attach the legs with double-ended screws
03:54:40 <zygoloid> i love how IKEA have a "destruction area"
03:55:39 <monochrom> But F# has much better type signatures.
03:55:50 <Associat0r> beter type inference
03:55:59 <Associat0r> better
03:56:04 <lament> the picture on the assembly instructions had you screwing in the double ended screws by hand. In reality I could barely do it with pliers without ruining the thread :(
03:56:05 <sproingie> betterer
03:56:17 <monochrom> When I write an imperative program, I may still choose Haskell over C++ just for the type signatures.
03:56:32 <Associat0r> also you don't want to use a pure language for doing most stuff
03:56:55 <lament> you're saying that in #haskell... :)
03:56:59 <sproingie> lament: should only need to start them in the leg, then it should screw in both directions when you screw the leg to the table
03:57:21 <monochrom> OK, when I write an object-oriented program, I may still choose ocaml over C++ just for the type signatures.
03:57:21 <sproingie> lament: hopefully you don't strip the table side in the process.  ah well that's ikea for you.
03:57:42 <Associat0r> did you see what they had to go through to get some decent performance out of the shootout?
03:58:25 <Associat0r> also I don't want to miss proper OO
03:58:30 <sproingie> i'm satisfied with getting java levels of performance
03:59:03 <dpiponi> Anyone running ghc on a netbook. I'm thinking about something really lightweight for hacking on my commute.
03:59:24 <sproingie> i run haskell on a 256M vhost, i suspect a netbook will do just fine
03:59:27 <dpiponi> Not sure how painful it is to use ghc on an Atom with 1-2Gb RAM
03:59:37 <Associat0r> Zao o damn I thought this was #gamedev
03:59:38 <sproingie> it's really painful with less than a gig of ram
03:59:39 <Botje> dpiponi: eee1000 here. compiles are a bit slow, but running is okay
03:59:40 <sw17ch> dpiponi: not a problem at all
03:59:51 <sw17ch> i had an EEE 901 that ran/built (o_O) GHC just fine
03:59:53 <sproingie> compiles are fine, linking goes south real fast
04:00:28 <sproingie> i blame gnu ld myself
04:00:34 <dancor> ghc compiles are not known for expedience
04:00:47 <sproingie> but it's ghc that tickles whatever bug gnu ld has
04:00:51 <zygoloid> dancor: compared to g++ they are! :)
04:01:05 <dancor> there should be a compilation shootout
04:01:10 <zygoloid> hah :)
04:01:15 <sproingie> stalin would lose that one for sure
04:01:38 <Zao> Associat0r: Heh.
04:01:47 <dpiponi> Is everyone using ghc on a netbook using Linux?
04:01:53 <monochrom> just use kruschev instead of stalin
04:02:00 <edwardk> dpiponi: ghc works fine on more or less anything if you don't crank the optimizations
04:02:08 <stoop> dpiponi, I'm on a Thinkpad T61 using Solaris.
04:02:19 <stoop> Hi edwardk.
04:02:30 <Veinor> cabal: dist/src/sdist.26354/nimber-0.1/Data: removeDirectory: unsatisified constraints (Directory not empty)
04:02:34 <Veinor> why do I keep getting this?
04:02:37 * sproingie has a 17" notebook.  can't stand netbooks.
04:02:46 <dcoutts> Veinor: windows? nfs?
04:02:53 <Veinor> afs
04:02:58 <dancor> what's a good/existing css parser
04:03:04 <edwardk> compiling category-extras will suck because I think I have -O2 -feverything-underthesun set because of the rewrite rules and constructive algorithmics combinators, but hey ;)
04:03:08 <edwardk> heya stoop
04:03:13 <wzp> is a 'binary function' a function that takes two arguments ?
04:03:18 <sproingie> wzp: yep
04:03:28 <Veinor> it's not stopping anything from compiling/installing/doing its thing, it's just annoying
04:03:32 <wzp> sproingie: quick answer, thanks
04:03:41 <Veinor> compiling it on /tmp works fine
04:03:44 <dcoutts> Veinor: is afs making hidden files when you delete things like nfs does?
04:04:27 <Veinor> ls -alt says no
04:04:42 <edwardk> i keep trying to find a netbook that has a keyboard big enough to type on, but no surplus. haven't yet been happy with any of them really
04:04:49 <dcoutts> Veinor: they might be transient
04:05:10 <Veinor> possibly. it just pollutes dist/src/sdist.foo is all
04:05:13 <dcoutts> Veinor: I'm not sure how we're supposed to deal with file systems that do that kind of thing
04:05:16 <sproingie> i keep trying to find a netbook i'd like that isn't just $100 less than a notebook with five times the power
04:05:40 <Veinor> an option 'delete-nonempty-directories-anyway'? :D
04:05:58 <Veinor> ... huh. class time. back in an hour :P
04:06:03 <dpiponi> When I'm stuck on a bus, a small keyboard is a big plus, even if it slows me down.
04:06:38 <edwardk> true enough
04:06:40 <sproingie> true i don't take the laptop travelling.  i tend to read blogs and such on my phone.
04:06:56 <edwardk> i'm waiting to see how the next generation of netbooks do for battery life
04:07:04 <lament> I saw some guy on the bus play Nethack
04:07:10 <lament> ...with TILES :(
04:07:16 <sproingie> nethackbook
04:07:30 <edwardk> lament: such a waste of power ;)
04:07:35 <dpiponi> I should read more blogs then! Though if they're literate haskell I always understand better if I can run and tweak the code.
04:07:42 <sproingie> my poison is dwarf fortress.  netbooks just don't have the oomph to play that at a decent framerate
04:07:47 <stoop> mauke, which bot was it that had PoppaVic quotes?
04:07:58 <lament> sproingie: is it still windows only?
04:08:05 <mauke> stoop: preflex, but that was in its other brain
04:08:06 <sproingie> lament: nope there's a mac and windows port now
04:08:13 <lament> oh? hm
04:08:17 <lament> should i try it?
04:08:20 <sproingie> er a mac and linux port
04:08:21 <lament> or should i just buy crack?
04:08:35 <sproingie> i recommend mainlining heroin, you'll kick it easier
04:08:52 <lament> i haven't heard anyone say anything negative about dwarf fortress, ever
04:08:56 <Ferdirand> there's a linux port ?
04:09:10 <Ferdirand> goodbye, productivity
04:09:29 <sproingie> it's tedious to do some things what with all the forbids and marking, and the interface is still something out of Area 51
04:09:38 <sproingie> other than that it's tile-based crack
04:09:58 <sproingie> i'm chomping at the bit for the next version, he really fixed a lot of the problems with the military
04:10:09 <sproingie> like, they no longer spar naked with steel battleaxes
04:10:27 <sproingie> Sgt Urist McStumpy
04:10:38 <lament> er, it's no longer text-based?
04:10:44 <sproingie> it's always been tile based
04:10:51 <sproingie> the default tile set just uses text characters
04:11:03 <lament> what is this a picture of? http://farm3.static.flickr.com/2377/2224777118_891f3f7f2c.jpg
04:11:17 <edwardk> dpiponi: bah, i much prefer the haskell compiler in my head to ghc -- so much less work to get things to compile. runtime performance is rather abysmal though.
04:11:23 <mauke> reminds me of dwarf fortress
04:11:31 <Ferdirand> and as such, doesn't run over ssh :(
04:11:41 <sproingie> lament: that's some DF visualizer
04:11:50 <mauke> oh, duh
04:11:56 <sproingie> would be neat if the game itself looked like that
04:12:02 <lament> oh
04:12:09 <sproingie> but it's a glorified screenshot tool
04:12:47 <sproingie> there's stonesense which might contend to be an actual interface, but it's far from that atm
04:14:08 <lament> that looks like zelda
04:16:36 <HaskellLove> how do u compare Haskell and Java?
04:17:08 <lament> By the number of job positions available
04:17:12 <Niccus> with great difficulty
04:17:29 <holmak> subjectively
04:19:05 <monochrom> I just don't compare.
04:19:05 <edwardk> HaskellLove: by the average intelligence level of the questions on #haskell and #java ;)
04:19:17 <monochrom> I find all this empty talk vain.
04:19:31 <HaskellLove> cool
04:19:33 <lament> Haskell and Java are equivalent
04:19:44 <lament> under the Blub equivalence relation
04:20:12 <edwardk> monochrom: there is nothing wrong with a little well placed vanity ;)
04:20:14 <HaskellLove> that is so cool I compare them, Java is like a sexy girl and python is like a strict army general
04:20:21 <fritschy_> lament: please elaborate :)
04:20:38 <monochrom> But you see this one is not well-placed.
04:21:10 <Niccus> python is strict?
04:21:17 <copumpkin> yeah
04:21:20 <lament> java is sexy?
04:21:22 <jmcarthur_work> i don't see how that metaphor fits at all
04:21:33 <monochrom> I just wish everyone agrees this is a troll and I am right to just ban.
04:21:47 <kmc_> @protontorpedo
04:22:01 <jmcarthur_work> monochrom, if a troll, a very advanced troll
04:22:09 <monochrom> That needs lambdabot but she's out dating today.
04:22:25 <kmc_> s/dating/passed out in a gutter/
04:22:37 <holmak> What kind of bot does a haskell bot date?
04:22:50 <c0n5pir4cy> Dont know
04:22:53 <lament> what is a nice bot like you doing in a gutter like this?
04:22:53 <aeter> lazy
04:22:53 <holmak> Surely, she isn't out with the imperative trash
04:23:04 * copumpkin agrees with monochrom, but isn't sure about what
04:23:09 <c0n5pir4cy> lol
04:23:21 <kmc_> the eval bot in ##c++ is written in Haskell
04:23:33 <edwardk> HaskellLove: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html seems appropriate here ;)
04:23:36 <holmak> haha, that's amazing
04:23:38 <jmcarthur_work> lambdabot dates... c++?!
04:23:45 <edwardk> or the retort: http://lambda-the-ultimate.org/node/3133#comment-45803
04:23:51 * c0n5pir4cy Faints
04:23:56 <kmc_> oh my
04:24:28 * c0n5pir4cy gets back up
04:25:42 <c0n5pir4cy> :)
04:26:13 <c0n5pir4cy> Can anybody explain the Either type for me
04:26:15 <c0n5pir4cy> ?
04:26:29 <kmc_> data Either a b = Left a | Right b
04:26:54 <monochrom> It has two cases. Think of union type but safer.
04:26:56 <roconnor> c0n5pir4cy: disjoint union of two types a and b
04:26:57 <kmc_> if S and T are types, then a value of type (Either S T) is one of two things:
04:27:07 <kmc_> - (Left x) for some x of type S
04:27:11 <kmc_> - (Right x) for some x of type T
04:27:38 <jmcarthur_work> Left (x :: a) :: Either a b ; Right (y :: b) :: Either a b
04:28:08 <roconnor> c0n5pir4cy: try not to think of a lifted coprouct in the category of scott domains.
04:28:15 <monochrom> hahahaha
04:28:21 <jmcarthur_work> you're being mean
04:28:26 <c0n5pir4cy> lol
04:28:27 <roconnor> sorry sorry
04:28:36 <holmak> roconnor++ for highly insightful commentary
04:28:44 <c0n5pir4cy> ¬¬
04:28:56 <c0n5pir4cy> :)
04:29:04 <kmc_> :t Left 'x'
04:29:07 <holmak> c0n5pir4cy: are you familiar with Maybe?
04:29:08 <kmc_> grr right
04:29:14 <c0n5pir4cy> Nope
04:29:21 <kmc_> data Maybe a = Nothing | Just a
04:29:31 <kmc_> a value of type (Maybe T) could be one of two things:
04:29:33 <c0n5pir4cy> Yeah
04:29:38 <holmak> Maybe and Either are similar
04:29:40 <kmc_> Nothing :: Mabye T
04:29:41 <monochrom> Do you know that you can define a data type and what it can look like?
04:29:45 <c0n5pir4cy> Nothing or Just a
04:29:47 <kmc_> (Just x) :: Maybe T, provided x :: T
04:29:57 <c0n5pir4cy> yeah
04:30:13 <c0n5pir4cy> It just confuses me with how it works
04:30:23 <kmc_> which part of how it works is confusing?
04:30:45 <roconnor> c0n5pir4cy: works by having tags at runtime.
04:30:52 <monochrom> If I write "data Funny = Case1 Int | Case2 Bool" do you understand it?
04:31:03 <kmc_> you build values using the data constructors (Left, Right, Nothing, Just).  these act like functions (or just fixed values, in the case of Nothing which has no args)
04:31:13 <kmc_> you take apart values of these types by doing pattern matching
04:31:39 <c0n5pir4cy> so if i Created a Funny Variable of Type Int it would be of type case1
04:31:40 <c0n5pir4cy> ?
04:31:44 <kmc_> @bot
04:31:44 <lunabot>  :o
04:31:48 <kmc_> c0n5pir4cy, no
04:31:54 <kmc_> Case1 is not a type.  Nothing and Just are not types
04:32:14 <kmc_> the stuff on the right hand side of the '=' in a 'data' declaration describes what the *values* look like
04:32:16 <c0n5pir4cy> Just cases
04:32:21 <kmc_> the stuff on the left hand side describes what the *types* look like
04:32:25 <monochrom> It is not "type int". But perhaps what's in your mind is right.
04:32:34 <kmc_> (Case1 3) and (Case2 True) are both values of type Funny
04:32:50 <kmc_> similarly, Nothing and (Just 'x') are both values of type (Maybe Char)
04:33:20 <kmc_> here's an even simpler one:
04:33:21 <c0n5pir4cy> ok
04:33:23 <kmc_> data Bool = False | True
04:33:32 <kmc_> False and True are two values of type Bool
04:33:39 <c0n5pir4cy> That makes more sense to me
04:33:49 <c0n5pir4cy> It can be either True or Falose
04:33:55 <c0n5pir4cy> *False
04:34:22 <kmc_> data Booly = Falsey Int | Truey Char
04:34:31 <monochrom> a Funny value can be either Case1 with a number or Case2 with a boolean
04:34:33 <kmc_> same deal, but now we've attached some data to each "tag"
04:34:40 <kmc_> so whereas False :: Bool,  Falsey :: Int -> Booly
04:34:53 <c0n5pir4cy> ahh
04:34:54 <Gracenotes> that's no boolean, sir ⃝_⃝
04:35:10 <roconnor> data declarations are kinda hard to understand at first. :)
04:35:26 <monochrom> I disagree.
04:35:41 <OscarZ> c0n5pir4cy: im trying to learn this stuff too.. do you know the difference between type constructor and data constructor ?
04:35:44 <c0n5pir4cy> Thing is I've got a tree type defined and i can understandf that
04:35:45 <monochrom> But I guess one needs to see examples of valid values.
04:36:12 <monochrom> So if the type has recursion you understand it? Without recursion you can't?
04:36:18 <c0n5pir4cy> Types just the simple one, that lets you make data out of
04:36:33 <c0n5pir4cy> Existing types?
04:36:36 <monochrom> This is great news. We have witness who says recursion is easier.
04:36:38 <Gracenotes> trees are less ad-hoc just by merit of being more common in compsci
04:36:39 <c0n5pir4cy> Basically
04:37:01 <Gracenotes> as opposed to explicit nullable stuffs
04:37:37 <OscarZ> c0n5pir4cy: i found this helpful: http://www.haskell.org/tutorial/goodies.html
04:38:38 <c0n5pir4cy> Thx OscarZ, I'll be sure to take a look
04:39:02 <OscarZ> The chapter 2.2 User-Defined Types has some examples
04:39:16 <c0n5pir4cy> Thanks everybody
04:40:50 <c0n5pir4cy> Do i have to define Either myself? I get a not in scope error
04:41:47 <aavogt> @src Either
04:41:53 <mauke> ENOBOT
04:41:55 <aavogt> @bot
04:41:55 <lunabot>  :o
04:42:02 <mauke> c0n5pir4cy: what's the exact error message?
04:42:04 <jmcarthur_work> c0n5pir4cy, are you sure you are using Either as a type constructor and not a data constructor?
04:42:09 <aavogt> , [$src| ''Either |]
04:42:10 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
04:42:18 <c0n5pir4cy> My mistake :)
04:42:29 <c0n5pir4cy> Got it working
04:42:32 <jmcarthur_work> the data constructors are Left and Right :)
04:42:46 <aavogt> , [$ty| src |]
04:42:48 <lunabot>  Name -> Doc
04:43:00 <aavogt> , src ''Either
04:43:03 <lunabot>  data Either a b = Left a | Right b
04:43:19 <aavogt> , src 'src
04:43:21 <lunabot>  src :: Name -> Doc
04:43:38 <copumpkin> , src ''src
04:43:39 <lunabot>  luna: Not in scope: type variable `src'
04:43:45 * copumpkin fails
04:44:18 <aavogt> , src ''Doc
04:44:20 <lunabot>  data Doc = Empty
04:44:20 <lunabot>           | NilAbove Doc
04:44:20 <lunabot>           | TextBeside TextDetails !Int Doc
04:44:30 <sacko> hi all, anyone have any idea where i would start in creating an authentication script in haskell? is there another way, rather than passing a user data type to functions that need authentication?
04:44:53 <aavogt> obviously monads are an answer
04:45:41 <aavogt> but that's just hiding the tedium of passing your user data explicitly
04:46:50 <sacko> i'll have to read up on monads a little more then, unless there are other ways you can think of?
04:47:21 <aavogt> @google XImplicitParams
04:47:28 <aavogt> oh, no bot
04:47:43 <aavogt> please don't use implicit params
04:47:49 <sixthgear> Hi #haskell, our friend lambdabot no longer graces our channel. Is she sick today?
04:48:22 <kmc_> OscarZ, do you understand the difference between how "Maybe" and "Just" are used?
04:48:30 <kmc_> Maybe is a type constructor; Just is a data/value constructor
04:48:35 <sacko> ok i shall not, i'll have a look into them though (so I know what to avoid)
04:48:38 <osaunders> @list
04:48:38 <tensorpudding> @botsnack
04:48:38 <lunabot>  :o
04:48:52 <Gracenotes> sixthgear: in the hospital from blunt trauma with a lambda cube
04:49:07 <sixthgear> Gracenotes: :o
04:49:16 <osaunders> Dammit, I only came for lambdabot.
04:49:20 <aavogt> but types and constructors have different namespaces, so if you only have one constructor it is convenient to use the same name
04:50:25 <aavogt> , src ''Maybe
04:50:27 <lunabot>  data Maybe a = Nothing | Just a
04:50:32 <sixthgear> 666 people in this channel. It must be the devil's fault, or the devil bot maybe
04:50:50 <aavogt> Maybe could be defined as   data Maybe a = Nothing | Maybe a
04:50:54 <osaunders> If you believe in that crap.
04:51:06 <kmc_> aavogt, but that's just two things which happen to have the same name
04:51:26 <tensorpudding> , src ''Mu
04:51:28 <lunabot>  newtype Mu f = Mu (f (Mu f))
04:51:38 <Gracenotes> moo.
04:51:42 <OscarZ> kmc_: I think I understand this part.. it was c0n5pir4cy who asked that
04:51:48 <tensorpudding> where did Mu come from
04:51:53 <kmc_> oh i thought you were asking too
04:52:16 <Gracenotes> it's a sort of fix on types. I believe.
04:53:03 <tensorpudding> I saw it on the stages of a haskell programmer page, but I was wondering why it was called Mu
04:53:05 <aavogt> kmc_: what do you mean by happen? I believe somebody in the haskell committee made a conscious decision to have separate namespaces for types and for constructors
04:53:17 * hackagebot upload: AES 0.2.1 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
04:53:29 <Gracenotes> Mu X can have a value if newtype X a = X Y.. I think.
04:53:38 <OscarZ> kmc_: In Maybe a = Nothing | Just a, a can be thought as a "placeholder" for some arbitrary type that occurs on the left side of the = sign ?
04:53:42 <aavogt> such naming means there's less names to keep track of
04:53:56 <aavogt> OscarZ: exactly
04:53:57 <kmc_> OscarZ, for a value of that type
04:54:20 * hackagebot upload: Monocle 0.0.1 - Symbolic computations in strict monoidal categories with LaTeX output. (OsmanBineev)
04:54:33 <kmc_> OscarZ, err, which occurance of "a"?
04:54:43 <kmc_> the left "a" is a binding occurance of the type variable "a"
04:55:04 <Berengal> OscarZ: It might help to look at it like a function, but taking types as arguments and returning a type. Also, you can only use it in type signatures.
04:55:09 <OscarZ> sorry.. i ment right side
04:55:11 <kmc_> it says that Maybe will always be used as (Maybe T), for some type T, and let's call that type T 'a' locally
04:55:24 <kmc_> on the right side we define a field with that type
04:55:30 <kmc_> just as if we'd said Maybe a = Nothing | Just Int
04:55:39 <kmc_> except we use 'a' instead of 'Int' so the user can choose the type
04:55:44 <OscarZ> The "a" in Maybe a says that in right side that type will occur...
04:55:53 <kmc_> no actually
04:55:56 <OscarZ> that is, when the type is actually used in some function
04:56:10 <kmc_> you can take type parameters that are not used
04:56:23 <kmc_> you definitely don't need a field of type "a"
04:56:26 <OscarZ> well, then i didnt understand it i guess ;)
04:56:31 <kmc_> data Foo a = Bar (Maybe a)
04:56:41 <kmc_> the type constructor Bar has no field of type "a"
04:56:45 <kmc_> sorry value constructor
04:56:54 <kmc_> the value constructor Bar has no field of type "a"
04:57:06 <kmc_> data Foo a = Bar Char  -- even stranger, but still legal
04:57:19 <kmc_> (legal in ghc i think, not sure about Haskell 98)
04:57:25 <OscarZ> kmc_: thanks, this is good example
04:57:26 <aavogt> why not?
04:57:45 <Berengal> kmc_: No reason it shouldn't be valid Haskell 98
04:57:55 <OscarZ> hmm..
04:57:55 <Berengal> (Also, no reason we should care anymore ;))
04:58:36 <allbery_b> I thought they were a common idiom in H'98 as type witnesses, for emulating various fancier features
04:58:50 <kmc_> what's not legal in H98 is
04:58:56 <kmc_> data Foo a b -- no right hand side
04:59:22 <kmc_> which is also useful with some other ghc extensions
04:59:24 <copumpkin> you can simulate that though
04:59:28 <aavogt> hmm, thats mostly an aesthetic thing
04:59:36 <kmc_> data Foo a b = NeverUseThis -- with unexported ctor
04:59:48 <copumpkin> or even with one value in it
05:00:03 <copumpkin> newtype Foo a b = Moo (Foo a b)
05:00:45 <aavogt> so many cows ;)
05:00:53 <OscarZ> kmc_: why would you do "data Foo a = Bar Char" or is this just an example that it is actually legal ?
05:01:31 <aavogt> triggers check: cannot construct infinite MOOOO
05:01:32 <copumpkin> it's legal
05:01:45 <copumpkin> aavogt: nuh uh!
05:01:47 <aavogt> but of course it doesn't complain
05:01:54 <copumpkin> BAAAA
05:02:01 <Cale> OscarZ: You might do things like that if you wanted to make use of the type in some other way, but didn't need a value of that type.
05:02:13 <kmc_> an example would be the trivial monad
05:02:18 <kmc_> data Trivial a = Trivial
05:02:37 <kmc_> the Monad typeclass requires that the types in that class have kind * -> *, meaning that they have one type parameter
05:02:50 <jmcarthur_work> a (slightly) more useful example would be tagging a list with its length at the type level
05:03:18 <jmcarthur_work> usually something that is demonstrated with GADTs
05:03:38 <kmc_> OscarZ, basically the use cases boil down to
05:03:48 <kmc_> - you want to encode compile-time information using types, without instantiating values of those types
05:03:50 <Cale> Phantom types like that also often show up in EDSLs, where you might want to use the Haskell type system to typecheck the expression trees for your embedded language, but don't actually need Haskell values of those types.
05:03:59 <kmc_> - someone else expects you to have a type parameter there, e.g. a typeclass like Monad
05:04:07 <jmcarthur_work> data Vector s a where Nil :: Vector Zero a ; Cons :: a -> Vector s a -> Vector (Succ s) a
05:04:23 <Cale> For example, you might have a type like   data Expr a = Expr ExpressionTree
05:04:43 <Cale> and then you might define operations on that type with more restrictive types than actually required given their implementation:
05:05:05 <Cale> (.+.) :: Expr Int -> Expr Int -> Expr Int
05:05:17 <Cale> isZero :: Expr Int -> Expr Bool
05:05:40 <c0n5pir4cy> Managed to confuse myself again
05:05:43 <Cale> if' :: Expr Bool -> Expr a -> Expr a -> Expr a
05:06:13 <c0n5pir4cy> if Either is a Type constructer How can you return something of type Either
05:06:17 <c0n5pir4cy> ?
05:06:30 <Cale> c0n5pir4cy: Use one of the data constructors for that type
05:06:34 <Cale> :t Left
05:06:43 <mauke> #ty Left
05:06:45 <lunabot>  forall b a . a -> Either a b
05:06:46 <aavogt> copumpkin: ah, tricky with the use of newtype, otherwise you could have varying depth nestings of Moo terminated by undefined
05:06:49 <Cale> Oh, lambdabot is troubled?
05:06:58 * Cale fixes
05:07:07 <copumpkin> aavogt: damn right!
05:07:27 <Cale> :t Left
05:07:31 <Cale> :t Right
05:07:33 <lambdabot> forall a b. a -> Either a b
05:07:39 <lambdabot> forall b a. b -> Either a b
05:07:47 <c0n5pir4cy> lol :) I was trying to make something with type Either a b -> Either b a
05:08:00 <aavogt> @type either Right Left
05:08:03 <tensorpudding> @botsnack
05:08:04 <lunabot>  :o
05:08:05 <c0n5pir4cy> so i could use Left to do that?
05:08:09 <lambdabot> forall a a1. Either a a1 -> Either a1 a
05:08:12 <copumpkin> #ty either Right Left
05:08:14 <lunabot>  forall a1 a . Either a a1 -> Either a1 a
05:08:15 <lambdabot> :)
05:08:20 <copumpkin> mine is bettar
05:08:40 <aavogt> @djinn f :: Either a a1 -> Either a1 a
05:08:45 <lambdabot> Cannot parse command
05:08:52 <aavogt> @djinn Either a a1 -> Either a1 a
05:08:59 <lambdabot> f a =
05:09:05 <lambdabot>     case a of
05:09:11 <lambdabot> Plugin `djinn' failed with: thread killed
05:09:16 <aavogt> aww
05:09:17 <mauke> haha
05:09:24 <mauke> good lambdabot, you look kind of slow
05:09:48 <copumpkin> lol
05:09:53 <copumpkin> @djinn Either a a1 -> Either a1 a
05:09:58 * copumpkin chants
05:09:59 <lambdabot> f a =
05:10:00 <Cale> lambdabot will still be joining channels perhaps
05:10:05 <lambdabot>     case a of
05:10:12 <c0n5pir4cy> twist (Left a) (Right b) = either b a?
05:10:17 <lambdabot> Plugin `djinn' failed with: thread killed
05:10:23 <copumpkin> failbot
05:10:23 <aavogt> just wait for it ;)
05:10:34 <copumpkin> oh lambdabot lives on linode now?
05:10:53 <aavogt> c0n5pir4cy: what happens if the first argument to twist is Right?
05:11:33 <c0n5pir4cy> It was meant to take in something of type Either
05:11:38 <copumpkin> c0n5pir4cy: twist (Left a) = Right a; twist (Right a) = Left a
05:12:29 <mauke> > "done joining?"
05:12:30 <lambdabot>   "done joining?"
05:12:40 <aavogt> @djinn Either a a1 -> Either a1 a
05:12:40 <lambdabot> f a =
05:12:41 <lambdabot>     case a of
05:12:41 <lambdabot>     Left b -> Right b
05:12:41 <lambdabot>     Right c -> Left c
05:12:57 <aavogt> @. @elite @djinn Either a a1 -> Either a1 a
05:12:57 <lambdabot> Plugin `compose' failed with: Unknown command: "@elite"
05:13:03 <copumpkin> @@
05:13:03 <aavogt> @. elite djinn Either a a1 -> Either a1 a
05:13:04 <lambdabot> f 4 = CasE A oph 1eF+ B -> RiG|-|T b ri9HT C -> LephT C
05:13:14 <copumpkin> lol
05:13:31 <c0n5pir4cy> @copumkin GHC Doesn't like that
05:13:31 <lambdabot> Unknown command, try @list
05:13:35 <c0n5pir4cy> :(
05:13:45 <luite> is there an algorithm for finding all possible maximum flows in a network? (flows where the residual graph has different remaining edges)?
05:14:09 <luite> oops, was meant for #algorithms
05:14:17 <opqdonut> good question
05:15:52 <c0n5pir4cy> Copumkin: I get an Expected type error, should i Hpaste my code?
05:16:02 <mdaum> How can I use cabal to install a package, but let me hack the cabal file first?
05:16:58 <copumpkin> c0n5pir4cy: sure
05:17:06 <mdaum> Specifically I want to install hsmagick with the pthread dependency removed.
05:18:53 <c0n5pir4cy> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13894#a13894
05:19:13 <Berengal> mdaum: cabal unpack fetches (and unpacks) thepackage, but doesn't install it
05:19:33 <kmc_> c0n5pir4cy, , typo on last character
05:19:35 <kmc_> should be b not a
05:19:49 <mdaum> Berengal, cool.  And what should I do after to install?
05:19:52 <copumpkin> not sure how that gave you a bad expected type though
05:20:17 <kmc_> :t let twist (Left a) = Right a; twist (Right a) = Left a in twist
05:20:21 <lambdabot> forall t a. Either t a -> Either a t
05:20:30 <c0n5pir4cy> Dunno, but it works :)
05:20:37 <jmcarthur_work> :t either Right Left
05:20:38 <c0n5pir4cy> lol, I should lrn2read
05:20:38 <lambdabot> forall a a1. Either a a1 -> Either a1 a
05:20:44 <kmc_> @src either
05:20:45 <lambdabot> either f _ (Left x)     =  f x
05:20:45 <lambdabot> either _ g (Right y)    =  g y
05:20:46 <c0n5pir4cy> Thanks
05:20:47 <Berengal> mdaum: just cabal configure/build/install/clean in the folder it's unpacked in
05:20:55 <Botje> twist = either Right Left
05:20:59 <jmcarthur_work> :t Right ||| Left
05:21:00 <lambdabot> forall b a. Either b a -> Either a b
05:21:33 <kmc_> @check liftM2 (==) id (either Left Right)
05:21:34 <lambdabot>   "OK, passed 500 tests."
05:21:41 <kmc_> @check liftM2 (==) (id :: Char -> Char) (either Left Right)
05:21:42 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:21:56 <kmc_> @check liftM2 (==) (id :: Either Char Int -> Either Char Int) (either Left Right)
05:21:57 <lambdabot>   "OK, passed 500 tests."
05:21:59 <mdaum> Berengal: thx much, works like a charm
05:22:08 <kmc_> lambdabot is speedy now
05:22:21 <kmc_> @. elite nixon
05:22:21 <lambdabot> \/OT3r5 qUICx1Y phORGe7 WHa+ 4 mAN s4Y5.
05:22:25 * monochrom works like a char
05:22:41 <monochrom> Oh hi lambdabot
05:23:17 <copumpkin> @check ap (==) reverse
05:23:18 <lambdabot>   "OK, passed 500 tests."
05:23:45 <opqdonut> @unpl ap (==) reverse
05:23:45 <lambdabot> ((==) >>= \ b -> reverse >>= \ a -> return (b a))
05:23:54 <opqdonut> gah!
05:24:07 <opqdonut> anyway, that's x == reverse x right?
05:24:14 <aavogt> yes
05:24:15 <copumpkin> yep
05:24:21 <aavogt> @type ap (==) reverse
05:24:22 <lambdabot> forall a. (Eq a) => [a] -> Bool
05:24:26 <Berengal> @redo ((==) >>= \ b -> reverse >>= \ a -> return (b a))
05:24:26 <lambdabot> Maybe you meant: do read todo undo
05:24:32 <Berengal> @do ((==) >>= \ b -> reverse >>= \ a -> return (b a))
05:24:32 <lambdabot> (do { b <- (==); a <- reverse; return (b a)})
05:24:39 <aavogt> it wins because the type defaults to [()]
05:24:39 <copumpkin> lol
05:24:45 <copumpkin> aavogt: shh
05:24:47 <opqdonut> ah :D
05:24:53 <monochrom> This is feature interaction.
05:25:26 <Berengal> I'm glad we have defaulting, but I'm also glad we only have defaulting in interpreters (by default)
05:25:34 <aavogt> did I spoil something terribly?
05:25:47 <aavogt> Berengal: seems to be enabled in the compiler
05:25:49 <Berengal> @check \a b -> a == b
05:25:50 <lambdabot>   "OK, passed 500 tests."
05:25:54 <aavogt> but you do get warnings
05:25:56 <idnar> @check ap (==) reverse :: [Integer] -> Bool
05:25:57 <lambdabot>   Couldn't match expected type `[GHC.Integer.Internals.Integer]
05:25:58 <Cale> Berengal: We also have some defaulting by default
05:25:58 <aavogt> if you ask for them
05:26:06 <Cale> Berengal: Specifically numeric defaulting
05:26:07 <idnar> whaaaaaaaat
05:26:20 <Berengal> Cale: We do? Even without the MMR?
05:26:22 <monochrom> defaulting up to default. unique up to unique isomorphism
05:26:37 <idnar> @check (ap (==) reverse) :: [Integer] -> Bool
05:26:38 <lambdabot>   Couldn't match expected type `[GHC.Integer.Internals.Integer]
05:26:43 <Cale> Berengal: Even without the MR. It's separate, though the MR tends to push it along.
05:26:49 <idnar> @check ap (==) reverse :: [String] -> Bool
05:26:50 <lambdabot>   Couldn't match expected type `[GHC.Base.String] -> GHC.Bool.Bool'
05:27:03 <idnar> am I doing something stupid?
05:27:09 <Berengal> I just can't remember a case where I had defaulting when compiling
05:27:12 <aavogt> idnar: @check wants a Bool
05:27:22 <Berengal> Unless it's ninja defaulting
05:27:22 <aavogt> and it can provide any Testable or something
05:27:27 <idnar> aavogt: I'm giving it a Bool
05:27:38 <aavogt> I see none
05:27:45 <idnar> [String] -> Bool
05:28:14 <aavogt> @check \x y -> (ap ((==) :: [Integer] -> [Integer] -> Bool) x (reverse x)
05:28:14 <lambdabot>  Unbalanced parentheses
05:28:24 <aavogt> @check \x y -> ap ((==) :: [Integer] -> [Integer] -> Bool) x (reverse x)
05:28:25 <lambdabot>   Couldn't match expected type `[a]'
05:28:25 <Cale> Berengal: You surely might have used an integer literal whose type was underdetermined
05:28:26 <idnar> it worked with @check ap (==) reverse
05:28:38 <aavogt> @check \x -> ap ((==) :: [Integer] -> [Integer] -> Bool) x (reverse x)
05:28:39 <lambdabot>   Couldn't match expected type `[a]'
05:28:42 <idnar> as far as I can tell, the problem is with my type signature, not @check
05:28:44 <idnar> but I can't see why
05:28:46 <Cale> Berengal: If you write code without many explicit type signatures, it's bound to happen (and even quite likely without it)
05:28:47 <Berengal> Cale: Yes, but I can't remember that being anything but (Num a) => a
05:29:01 <aavogt> @check ap ((==) :: [Integer] -> [Integer] -> Bool) reverse
05:29:02 <lambdabot>   "Falsifiable, after 7 tests:\n[3,-2]\n"
05:29:20 <idnar> okay, that works
05:29:34 <Berengal> And I explicitly remember getting an ambiguous type error where the choice was Int or Integer
05:29:45 <idnar> @type ap (==) reverse :: [Integer] -> Bool
05:29:46 <lambdabot> [Integer] -> Bool
05:30:03 <idnar> meh, whatever
05:30:05 <aavogt> @check succ
05:30:06 <lambdabot>   "Arguments exhausted after 0 tests."
05:30:26 <Berengal> :O
05:30:35 <aavogt> @check (ap (==) reverse :: [Integer] -> Bool)
05:30:36 <lambdabot>   "Falsifiable, after 5 tests:\n[0,0,4,-4]\n"
05:30:56 <idnar> oh
05:31:10 <idnar> silly parens
05:32:06 <aavogt> yeah, I can't come up with a reason why they are needed here
05:32:10 <HaskellLove> http://mschnlnine.vo.llnwd.net/d1/ch9/0/Beckman_OnMonoids_NoFear_ch9.mp3 If someone complicates thing with monads ever again I will eat him alive, haskell noobs go to that link and stop fearing monads
05:32:31 <idnar> monads or monoids?
05:33:37 <monochrom> mp3 complicate things significantly
05:33:41 <copumpkin> HaskellLove: um, that's monoids
05:33:45 <medfly> lol
05:33:56 <HaskellLove> talks about both
05:34:18 <monochrom> mp3 is linear, non-browsable, not-at-my-own-pace, etc.
05:34:25 <idnar> a monad is just a monoid in the category of endofunctors on Hask, right? :P
05:34:35 <copumpkin> idnar: a monoid _object_
05:34:38 <copumpkin> :P
05:34:54 <Rotaerk> monoids are easy... it's hemorrhoids you have to worry about
05:34:58 <idnar> aww, now I just sound like I don't know what I'm talking about
05:36:12 <monochrom> Do you know what's the real problem? Every noob finds his own favourite explanation and then asserts "every noob will get this". That's the real problem and that's why every noob doesn't get it.
05:36:50 <Alpounet> dons, ping
05:36:52 <Apocalisp> Maybe somebody should write a monad tutorial.
05:36:52 <mdaum> Anybody know how to go from a Ptr a -> a ?
05:36:58 <HaskellLove> nah you guys try to mix math into programming just so u can say "hey look how cool i am using all this math explanations" woow
05:37:21 <Berengal> mdaum: peek
05:37:23 <Berengal> @type peek
05:37:24 <kmc_> @hoogle peek
05:37:24 <lambdabot> Not in scope: `peek'
05:37:24 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
05:37:25 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
05:37:25 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
05:37:35 <jmcarthur_work> monochrom, okay, i believe you now
05:37:58 <copumpkin> HaskellLove: I'm getting rather tired of you
05:38:29 <mdaum> Merci all.
05:38:36 <monochrom> Eh? What do you believe?
05:38:37 <kmc_> "you guys try to mix math into programming"
05:38:39 <kmc_> hahahaha
05:38:42 <jmcarthur_work> monochrom, about HaskellLove
05:38:46 <Apocalisp> copumpkin: Don't screw him, he's a ninja.
05:38:48 <monochrom> Heh ok. :)
05:38:55 <copumpkin> monochrom: same
05:39:23 <Ferdirand> and I was about to ask for a more detailed explanation of endofunctors on Hask
05:39:44 <jmcarthur_work> @src Endo
05:39:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:40:05 <HaskellLove> haha fuck yeah i am ninja... anyways... when someone asks u about monads ask him is he a programmer or a mathematician... to a programer u can explain it in 5 minutes, not tell him how complex it is so he goes studies a hole day and at night he says : wait why the fuck do i waste time, i will never use this
05:40:37 <medfly> you're overestimating "programmers" :|
05:40:41 <monochrom> In fact, I do exactly that, programmer-oriented description in 5 minutes.
05:40:42 <Ferdirand> have fun writing boring boilerplate then
05:40:52 <medfly> I prescribe you a visit to ##php or a similar channel
05:40:57 <copumpkin> monochrom: I'd get rid of it
05:40:57 <medfly> it will be gone in 3 days
05:41:02 <monochrom> "it's just overloading these operators..."  So actually it's just one minute.
05:41:19 <jmcarthur_work> we need to stop giving monads their own chapters
05:41:21 <Berengal> HaskellLove: Haven't we told you to just look at the class? That's what monads are, as far as mathematically challenged programmers should care.
05:43:37 <edwardk> monads are two methods and three laws, what's the big deal? ;)
05:43:41 <sproingie> HaskellLove: are you sniffing glue?
05:43:53 <sproingie> seriously, you were writing complete words and thoughts just a few hours ago
05:44:07 <HaskellLove> sproingie from time to time yes
05:44:18 <sproingie> thought so.  come back sober, mkay?
05:44:25 <edwardk> that would explain the waning lucidity
05:44:39 * hackagebot upload: nimber 0.1 - An implementation of (finite) nimbers (PatrickHurst)
05:44:46 <copumpkin> see, getting everyone in a channel to react violently belongs under a bridge
05:45:00 <HaskellLove> ok going back to study bye bye
05:45:15 <edwardk> copumpkin: fair nuff
05:45:26 <copumpkin> Veinor: zomg
05:45:44 <copumpkin> edwardk: monochrom was asking earlier if anyone else thought he was a troll
05:45:58 <Veinor> copumpkin: :o
05:46:11 <Veinor> I found a couple typos in the .cabal, as well as the lack of haddock documentation
05:46:15 <Veinor> right after I uploaded it :(
05:46:31 <monochrom> Is that nimber?
05:46:38 <Veinor> yeah.
05:46:43 <edwardk> hrmm, i wonder if cybernetics offers a potiwid principle for trolls.
05:46:46 <Veinor> (zomg real name)
05:46:54 <monochrom> I guess you can quickly amend and upload an update.
05:47:37 <Veinor> true.
05:48:21 <Apocalisp> HaskellLove was trolling #scala a few days ago
05:48:26 <edwardk> "the purpose of a troll is what is does"
05:48:30 <edwardk> er what it
05:48:35 <Veinor> how do I include haddock information in the package? it's not in the output of cabal sdist
05:49:04 <HaskellLove> the troll is solving euler now by the way
05:49:14 <edwardk> so ultimately, don't ask the troll if they are a troll, but if they have troll like effects, then they are a troll.
05:49:31 <Veinor> hm
05:49:41 <Apocalisp> troll typing
05:49:42 <Veinor> so basically I guess the question is: how do I get haddock onto hackage?
05:49:57 <copumpkin> Veinor: you wait
05:50:05 <copumpkin> if you have haddock on your module, it gets processed once or twice a day
05:50:06 <edwardk> Veinor: haddock installs on hackage a few hours later
05:50:09 <Veinor> ahhh.
05:50:10 <edwardk> it runs in a batch
05:50:10 <Veinor> okay.
05:50:31 <jmcarthur_work> ?hackage nimber
05:50:31 <lambdabot> http://hackage.haskell.org/package/nimber
05:50:34 <edwardk> probably because they try to cross-link modules or out of sheer laziness or something
05:50:42 <Veinor> in that case, the only problem I have is some tab problems in the .cabal as well as an external function that's just a relic of a slow implementation
05:50:47 <Veinor> so nothing much
05:51:03 <copumpkin> phurst = first!
05:51:09 <copumpkin> l33t hax0r style
05:51:47 <Saizan_> edwardk: so you prefer an extensional approach with trolls?
05:51:58 <Apocalisp> @elite Does this plugin still work?
05:51:58 <lambdabot> dOEs 7|-|iz P|ugIN $+iLl wORk?
05:52:01 <Apocalisp> heh
05:52:05 <edwardk> Saizan_: yes =)
05:52:16 <sproingie> @elite . @elite . @nixon
05:52:16 <lambdabot> . @eLi+E . @niXon
05:52:22 <sproingie> doh
05:52:26 <sproingie> @elite . @elite @nixon
05:52:26 <lambdabot> . @E|i+3 @NIXon
05:52:33 <idnar> @. elite nixon
05:52:33 <lambdabot> The PR3zz iz 7|-|E eN3My.
05:52:34 <edwardk> decidability of type-checking isn't a problem. when you can't decide -- its a troll
05:52:43 <edwardk> gotta run
05:52:47 <copumpkin> :)
05:52:55 <sproingie> @. elite elite nixon
05:52:55 <lambdabot> nIx0n
05:53:00 <Apocalisp> If it trolls like a troll, it's a troll.
05:53:02 <sproingie> bah
05:53:03 <Saizan_> the intention is actually harder to decide here, i think
05:53:29 <sproingie> trolls are bottom
05:53:29 <holmak_> @nixon
05:53:29 <lambdabot> Voters quickly forget what a man says.
05:53:35 <Veinor> ... why do you have a @nixon?
05:53:35 <copumpkin> and I do consider trolls extensionally
05:53:45 <holmak> Wow, that is a fantastic feature.
05:53:55 <Apocalisp> @. elite yarr
05:53:55 <lambdabot> /\/\4Y ThE c14P m4ke YE incaPA813 oph (r4(KING j3NnY'z 7e4 (up.
05:54:20 <Veinor> cracking jenny's tea cup?
05:54:40 <copumpkin> HaskellLove: for what it's worth, the composition operator the mp3 discusses is called <=<
05:54:40 <Veinor> http://www.youtube.com/watch?v=7pOoSe2K5DU
05:55:09 <Saizan_> @. elite . elite nixon
05:55:09 <lambdabot> y0U KnO\/\/, I7's0RZ A FUnnY +HIng, EverY OnE 0ph T|-|3 B45+aRdz0RZ 7|-|A7 aR3 0u7 4 1e9ALisiN9 /\/\4RiJuAN4 i5 je\/\/Is|-|. \/\/hA+ +|-|3 C|-|riz7 iS T|-|e /\/\a+7Er \/\/it|-| +|-|3 J3W$, 80B? \/\/
05:55:09 <lambdabot> H4+ I5 7|-|e m4t+3R \/\/ItH 7|-|e/\/\? I Supp05E It Iz0rz 83c4U$E /\/\0$+ oF 7H3M 4RE P5y(hi47rI5+5.
05:55:34 <xerox> /query chanserv
05:55:40 <xerox> oops
05:55:40 <Veinor> bastardzorz
05:56:00 <lament> psychiatrists for marijuana?
05:57:47 <sproingie> psychiatristzorz
05:58:32 <lament> @quote sproingie
05:58:33 <lambdabot> sproingie says: [about auto-memoisation] right, and what haskell needs is more space leaks
05:59:20 <idnar> @quote
05:59:20 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
05:59:36 <idnar> @quote
05:59:36 <lambdabot> dons says: Those who would give up essential type safety, to purchase a little liberty, deserve neither liberty nor type safety.
05:59:48 <idnar> @quote
05:59:48 <lambdabot> weitzman says: Sometimes it's ok to polish diningware with a hammer, as long as it gets the job done
05:59:51 <idnar> @quote life
05:59:52 <lambdabot> roconnor says: life lesson from today: 1 closure is nice, 500 000 closures sucks
05:59:58 <copumpkin> HaskellLove: I do like his approach to explaining it, but I still think knowing the basics helps before you get to the composition he talks about (called kleisli composition). It gives you no impression of lifting functions into the monad, or lifting binary functions, and so on.
06:00:43 <copumpkin> bah
06:01:25 <monochrom> You annoyed him sufficiently. :)
06:01:39 <copumpkin> :/
06:01:51 <copumpkin> he does seem enthusiastic, but damn he's annoying
06:02:20 --- mode: irc.freenode.net set +o ChanServ
06:04:27 <Ferdirand> so, what are arrows in Hask ?
06:04:35 <copumpkin> haskell functions
06:07:41 <Ferdirand> isn't an arrow supposed to be unique between two objects, up to isomorphism ? (sorry, CT noob here)
06:08:12 <tensorpudding> there can be more than one  arrow between two objects
06:08:14 <monochrom> No. sin,cos :: Double -> Double
06:08:57 <monochrom> Even a->[a] has many different arrows.
06:08:57 <tensorpudding> there can also be arrows from an object to itself which are not the identity
06:09:18 <copumpkin> countably many such arrows?
06:09:26 <tensorpudding> for example, in the category Rng, there are infinitely many ring homomorphisms between Z and itself
06:09:41 <monochrom> I don't know. I can give countably many, but I don't know what else is there.
06:09:44 <tensorpudding> corresponding to the maps x |-> x + n
06:09:45 <lament> Ferdirand: the whole point is that there can be many arrows between two objects
06:09:51 <lament> Ferdirand: otherwise, category theory would be graph theory
06:10:08 <tensorpudding> wait is that rigth...
06:10:49 <monochrom> Heh, does not preserve 0, not ring homomorphism
06:11:04 <copumpkin> rng!
06:11:09 <monochrom> But you can always try \x -> x*n
06:13:12 <Ferdirand> ok. I can't recall why I remember something about arrows being unique. That did seem somewhat strange indeed.
06:14:10 <monochrom> id:A->A is unique for each A
06:14:18 <copumpkin> composition is unique
06:14:51 <copumpkin> wait, does that make sense?
06:14:55 <tensorpudding> monochrom: that is what i was thinking of
06:15:11 <tensorpudding> though that's not surjective
06:16:01 <monochrom> composition is unique. though not emphasized because taken for granted.
06:16:05 <tensorpudding> if you consider R though, those define an uncountable number of ring homomorphisms from R to itself
06:16:53 <Ferdirand> ahh, that makes more sense
06:18:54 <c0n5pir4cy> Ok, how can i turn any function from (a -> b) to (a -> Either b c) The either type really confuses me
06:19:31 <paul424> hey how do I get the module Graphics.Win32 if I work under linux "
06:19:58 <copumpkin> :t \f -> Left . f
06:19:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (Either a b)
06:20:38 <copumpkin> fucking (.)
06:20:44 <copumpkin> :t \f x -> Left (f x)
06:20:45 <lambdabot> forall t a b. (t -> a) -> t -> Either a b
06:21:04 <mdaum> Anybody can help me load an image using hsmagick?
06:21:56 <monochrom> @djinn (a->b) -> (a -> Either b c)
06:21:56 <lambdabot> f a b = Left (a b)
06:22:09 <Gracenotes> c0n5pir4cy: remember, (a -> b) -> (a -> Either b c) is equal to (a -> b) -> a -> Either b c. Partial application is neat like that.
06:22:34 <c0n5pir4cy> that makes sense :)
06:22:37 <Gracenotes> partially applying types, that is (regardless of semantics, which are still pretty neat)
06:22:37 <c0n5pir4cy> Thanks
06:23:07 <jmcarthur_work> @. pl djinn (a->b) -> (a -> Either b c)
06:23:08 <lambdabot> f = (Left .)
06:23:23 <blaros31_> Why is there so much kool aid in the world?
06:23:34 <monochrom> Any sufficiently advanced hstechnology is indistinguishable from hsmagick <duck>
06:23:37 <OscarZ> whats the dot . ?
06:23:52 <Gracenotes> c0n5pir4cy: just think about how to get from one type to another. given an a, can you get an Either b c? Well, you can get a b from calling a function, and an Either b c from Lefting it
06:24:01 <monochrom> The dot . is as in "f . g" as in "(f . g) x = f (g x)"
06:24:04 <Gracenotes> for future type implementations
06:24:07 <sproingie> @pointy Left .
06:24:07 <lambdabot> (\ a d -> (Left) (a d))
06:24:32 <copumpkin> blaros31_: I hope you don't mean what I think you mean
06:25:44 <Gracenotes> OH YEAH
06:25:46 <paul424> ehh I need Graphics.Win32 to compile the winghci under linux .. is there anyway to do this ?
06:25:57 <mdaum> How can I build a Word?
06:26:01 <blaros31_> copumpkin: what would I mean?
06:26:08 <copumpkin> blaros31_: I don't know, what did you mean?
06:26:17 <Gracenotes> only you can answer that, sir blaros
06:26:27 <copumpkin> mdaum: just use a number literal, or fromIntegral
06:26:31 <sproingie> paul424: could be that a module for Win32 won't run on Linux?
06:26:32 <copumpkin> :t 5 :: Word
06:26:33 <lambdabot> Word
06:27:15 <mdaum> Ah.  I see.  My real problem is how to build a Word from a CULong
06:27:43 <sproingie> i guess there's cross-compiling, but that's tricky enough with gcc, let alone ghc
06:28:10 <paul424> yeap...
06:28:22 <blaros31_> copumpkin: sorry my question was for #kool-aid must of gotten lost in irssi
06:28:32 <copumpkin> blaros31_: ah okay, that's what I thought ;)
06:28:33 <Gracenotes> mdaum: CULong belongs to plenty of typeclasses. perhaps you can use fromIntegral
06:29:07 <mdaum> Gracenotes: Yes!!
06:29:12 <Dr_Sunglasses> blaros31_: i know what you mean..... i know a few people who could use a more savory drink now and then
06:29:17 <Gracenotes> @type fromIntegral
06:29:18 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:29:40 <Gracenotes> CULong is an Integral, and Word is a Num. Precision loss might be another matter, but this works for the types
06:30:20 <mdaum> Gracenotes: It's an image width/height, so if precision is lost the computer prolly doesn't have enough RAM :)
06:30:44 <Gracenotes> mm. I mean you might lose the top 32 bits
06:30:54 <Gracenotes> unless you use Word64. or your computer implicitly uses it.
06:32:49 <copumpkin> Dr_Sunglasses: you know that the kool aid stuff is actually wrong? the real Jonestown people drank Flavor Aid
06:33:05 <kmc_> the more you know
06:33:12 <mdaum> Sig.  Call went through this time, but stack overflow.
06:33:18 <copumpkin> not that I'm implying you were using the kool aid expression on us ;)
06:33:22 <mdaum> Methinks this library is a toy.
06:33:23 <copumpkin> just sayin'
06:33:41 <copumpkin> whoops, that was for blaros31_
06:33:48 <fracture> @hoogle guard
06:33:49 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
06:33:49 <lambdabot> Language.Haskell.TH data Guard
06:33:49 <lambdabot> Language.Haskell.TH.Syntax data Guard
06:35:05 <HaskellLove> I am solving Euler #7. 1. What is the most effective way to test if n is a prime, except brute-force dividing with first 10 numbers and get result?
06:36:48 <QtPlaty[HireMe]> HaskellLove: There are probolistic prime tests
06:37:03 <m3ga> HaskellLove: to test is N is prime you need to see if it is divisible by and number up to sqrt (N). one short cut is to only test if it is divisible by other primes rather than all numbers.
06:37:08 <fracture> HaskellLove: at #7 something like that's probably the best way to go
06:37:24 <copumpkin> HaskellLove: if you intend to go on, you'll probably need a better approach to primes though
06:37:29 <copumpkin> half the euler problems involve them
06:37:34 <copumpkin> it gets a little old
06:37:57 <fracture> IIRC there's some number theory library that has an isPrime function
06:38:08 <fracture> (and a probabilistic prime tester thing)
06:38:22 <copumpkin> yeah, haskell for maths v1
06:38:30 <copumpkin> oh I don't think that's probabilistic
06:38:36 <copumpkin> but maybe
06:38:37 <m3ga> @hoogle prime
06:38:38 <lambdabot> Data.HashTable prime :: Int32
06:38:38 <lambdabot> Text.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
06:38:38 <lambdabot> Text.ParserCombinators.Parsec.Prim tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m
06:38:38 <lambdabot> a
06:38:41 <ac> anybody have naming conventions for big union types?
06:38:44 <mdaum> Ok.  Take 2: has anybody had experience loading image files in a haskell program, and playing with them?  Specifically, I need to get the image bits into an hmatrix Matrix.
06:38:49 <copumpkin> there's also ONeillPrimes.hs
06:39:02 <fracture> http://hackage.haskell.org/package/Numbers
06:39:06 <fracture> is what I was thinking of, I think
06:39:36 <m3ga> mdaum: this greyscale images or colour? (curiosity only)
06:39:57 <mdaum> Well, I'd be happy to model a color image as 3 matrices.
06:40:02 <kmc_> mdaum, a binary PNM file is image bits prepended with a trivial header
06:40:08 <kmc_> so you can cheat by converting externally
06:40:20 <mdaum> kmc_: it's true....but
06:40:33 <kmc_> then you can also get fast access with a mmapped StorableArray, if you care
06:41:08 <HaskellLove> copumkin you have some book on mind for me to see some patterns for primes or something?
06:41:22 <mdaum> kmc_: hmatrix will be fast, I think.  Just have to get the data in.
06:41:27 <holmak> mdaum: My preference is to use Python+PIL to convert to a trivial format, then load the trivial format into Haskell
06:41:47 <holmak> easy, but has obvious shortcomings
06:42:28 <mdaum> holmak: Sigh.  Time just slipped back 15 years.
06:42:37 <pastah_rhymez> HaskellLove: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html
06:42:40 <paul424> hmm I just installed the ghc, but there;s no cabal install tool as stated here : http://www.haskell.org/cabal/download.html
06:42:59 <holmak> mdaum: What do you mean?
06:43:31 <mdaum> holmak: just that's the style of image handling I used 15 years ago..before it stopped being a problem.
06:44:54 <holmak> Well, it still seems to be a nuisance to load any popular image format. If you find a better way to do it in Haskell, I would greatly benefit.
06:45:24 <mdaum> holmak: hsmagick seems closish
06:46:47 <Saizan_> paul424: ghc comes only with Cabal the library
06:46:56 <Saizan_> paul424: cabal-install has to be installed separately
06:47:04 <Saizan_> paul424: or with the haskell platform
06:48:26 <paul424> ok, I have package manager on slackware already , is there any way of converting the package to the natvie package format ? ( tgz ) ? I don't want to manage them two already ...
06:49:09 <copumpkin> http://projecteuler.net/index.php?section=problems&id=61 is quite cute
06:49:14 <Saizan_> paul424: there are converter for many distros, but i'm not aware of one for slackware
06:49:41 <paul424> Saizan_: ok thanks
06:55:57 <Berengal> One thing I like about a tight, iterative developing style is when you're dusting off an old project and everything works, and provides visible functionality
06:56:18 <Berengal> One thing I like about Haskell is not having to remember which functions diddle which variables
06:57:32 <Berengal> 30 minutes was all it took for me to get up to speed on a project I abandoned 4 months ago
06:57:47 <lament> Haskell: For All The Projects You'll Abandon!
06:58:13 <Berengal> (And Then Get Back To Later)
06:59:05 * hackagebot upload: usb-safe 0.3 - Wrapper around the usb package adding extra type-safety (BasVanDijk)
07:02:16 <inclement> I intend to use haskell for data manipulation of data from some tab separated files (all two column, I think) - basically I want to write some functions to yank out columns, create new columns by manipulating these, and write columns to files (that I can then apply gnuplot to or whatever). Currently I plan to just read the file data into lists of rows and use transpose to get the columns - which are in a list form that I can easily pass around. D
07:02:22 <inclement> oes that sound reaosnable, or am I better off using some specific library?
07:02:45 <inclement> (Sorry if that's a silly question...I'm new to both haskell and general programming, so I'm wary of reinventing the whell)
07:02:48 <inclement> *wheel
07:05:48 <aavogt> inclement: there's a gnuplot package... might be more convenient to use that than worrying about ragged columns when outputing stuff
07:06:42 <inclement> Ah, okay
07:06:47 <inclement> Thanks :)
07:10:39 <c0n5pir4cy> @djinn (a -> Maybe b) -> (b -> Maybe c) -> (c -> Maybe d)
07:10:39 <lambdabot> f _ _ _ = Nothing
07:10:51 <c0n5pir4cy> ..fail
07:10:54 <ddarius> a -> Maybe c
07:11:04 <ddarius> c0n5pir4cy: That's the only solution.
07:11:18 <c0n5pir4cy> ok :)
07:11:38 <ddarius> @djinn (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)
07:11:39 <lambdabot> f a b c =
07:11:39 <lambdabot>     case a c of
07:11:39 <lambdabot>     Nothing -> Nothing
07:11:39 <lambdabot>     Just d -> b d
07:12:02 <c0n5pir4cy> I'm actually trying to compose two functions with maybe in them
07:12:05 <tensorpudding> @djinn a -> a
07:12:06 <lambdabot> f a = a
07:12:12 <ddarius> :t (>=>) :: (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)
07:12:13 <lambdabot> forall a b c. (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
07:13:22 <c0n5pir4cy> Thanks ddarius
07:13:33 <copumpkin> <=< is cuter
07:13:46 <mmorrow> preflex: seen int-e
07:13:46 <preflex>  int-e was last seen on #haskell 5 hours, 17 minutes and 16 seconds ago, saying: right. but the definition doesn't tell you why they'd be useful for programming.
07:13:55 <tensorpudding> can you have _ in combinator names?
07:14:36 <tensorpudding> > let (>_>) = (+) in 1 >_> 2
07:14:37 <lambdabot>   <no location info>: parse error on input `)'
07:15:03 <mmorrow> i'm always amazed at just how much faster Int{Set,Map} are than {Map,Set} (of course, it's only applicable when your key is Int..) http://www.haskell.org/pipermail/haskell-cafe/2009-December/070592.html
07:15:42 <tensorpudding> > let (>-<) = (+) in 1 >-< 2
07:15:43 <lambdabot>   3
07:15:56 * mmorrow usually goes out of his way to conjure Int keys and associate them with whatever than use the whatevers in a Map,Set
07:17:33 <c0n5pir4cy> :r
07:20:56 <paul424> Setup.hs import: unable to open image `Distribution.Simple': Permission denied @ blob.c/OpenBlob/2480. ./Setup.hs: line 2: main: command not found
07:21:17 <paul424> That what I get when runnign the Setup.hs from cabal.install
07:21:33 <c0n5pir4cy> composeMaybe (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)
07:21:58 <c0n5pir4cy> Can anybody tell me why this triggers a parse error on the secong ->
07:21:58 <mmorrow> @type (>=>) :: (a -> Maybe b) -> (b -> Maybe c) -> (a -> Maybe c)
07:21:59 <lambdabot> forall a b c. (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
07:22:39 <mmorrow> c0n5pir4cy: did you put that literally? (i.e. with no "::"?)
07:22:45 <ray> :t Kleisli
07:22:46 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
07:23:04 <c0n5pir4cy> lol, i'm too tired clearly, thanks mmorrow
07:23:10 <mmorrow> c0n5pir4cy: :)
07:23:24 <mmorrow> c0n5pir4cy: (also, (>=>)/(<=<) ftw :)
07:23:40 <skorpan> :t (>=>)
07:23:40 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
07:23:43 <ray> we call those kleisli rocketships
07:23:58 <c0n5pir4cy> lol, i'm too tired clearly, thanks mmorrow?
07:24:03 <ray> blasting you off into a new era
07:24:11 <c0n5pir4cy> sorry, what does that do?
07:24:31 <mmorrow> c0n5pir4cy: since Maybe is a Monad, it's equivalent to your composeMaybe
07:24:42 <skorpan> could someone give me an example of a use case for (>=>), e.g. with the Maybe monad?  something simple
07:24:50 <mmorrow> g <=< f = \x -> g =<< f x
07:24:54 <c0n5pir4cy> wow
07:25:02 <copumpkin> :t \f g -> runKleisli (Kleisli g <<< Kleisli f) :: (b -> Maybe c) -> (a -> Maybe b) -> (a -> Maybe c)
07:25:03 <lambdabot>     Inferred type is less polymorphic than expected
07:25:03 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
07:25:03 <lambdabot>         g :: b1 -> (a -> Maybe b) -> a -> Maybe c
07:25:09 <mmorrow> f >=> g = \x -> f x >>= g
07:25:38 <copumpkin> oh, whoops
07:25:41 <skorpan> mmorrow: i could decipher that from the type, but i have a hard time figuring out a good use case.  i don't think i've ever seen one in real code.
07:25:46 <copumpkin> :t \f g -> runKleisli (Kleisli g <<< Kleisli f)
07:25:47 <lambdabot> forall b (m :: * -> *) b1 a. (Monad m) => (a -> m b) -> (b -> m b1) -> a -> m b1
07:25:58 <joe____> i was using System.USB for my program. I stumbled across System.USB.Safe but could not figure out much about it and am wondering if anyone has any suggestions on reading up on it..
07:26:00 <copumpkin> backwards :)
07:26:03 <quuuux> skorpan: if xs :: [IO a], then foldr (<=<) return xs composes them all together
07:26:05 <mmorrow> skorpan: oh, didn't see your question
07:26:06 <eu-prleu-peupeu> hey haskell ppl
07:26:15 <copumpkin> quuuux: it does?
07:26:35 <copumpkin> skorpan: I've used it
07:26:49 <mmorrow> @type print <=< replicateM n
07:26:50 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
07:26:50 <lambdabot>     In the first argument of `replicateM', namely `n'
07:26:50 <lambdabot>     In the second argument of `(<=<)', namely `replicateM n'
07:26:50 <copumpkin> skorpan: for extra pointless monadic code!
07:26:58 <mmorrow> @type print <=< replicateM 4
07:27:02 <lambdabot> forall a. (Show a) => IO a -> IO ()
07:27:10 <skorpan> copumpkin: it feels a lot like (>>=) but...
07:27:11 <copumpkin> @type readFile <=< readFile
07:27:12 <lambdabot> FilePath -> IO String
07:27:17 <quuuux> copumpkin: that's the one situation I've had so far where it clarified, instead of obfuscating
07:27:20 <copumpkin> skorpan: it is, just less composed
07:27:24 <copumpkin> quuuux: I mean, it doesn't do that
07:27:43 <HaskellLove> 10%x==0 where x<-[3,5,6,7] ---------- what is wrong here?
07:27:48 <copumpkin> skorpan: symlinks in a line
07:27:48 <mmorrow> skorpan: yeah, it's basically (=<<) (or (>>=)) but when your function is taking the arg to "f" as an arg itself, in
07:28:01 <mmorrow> skorpan: foo a = g =<< f a
07:28:03 <copumpkin> HaskellLove: syntax?
07:28:06 <mmorrow> skorpan: foo = g <=< f
07:28:15 <HaskellLove> syntax yeah
07:28:36 <copumpkin> HaskellLove: you can't write that. [10 % x == 0 | x <- [3,4,6,7]]
07:28:42 <copumpkin> or put it in a do block
07:28:42 <mmorrow> skorpan: granted, that isn't that concrete of a use case per se, but that's pretty much the place/case i use that in
07:28:46 <Lycurgus> any access grid users here?
07:29:31 <quuuux> copumpkin: oh, whoops, got my types mixed up. foldr (<=<) return :: [a -> m a] -> (a -> m a)
07:29:55 <c0n5pir4cy> composeMaybe f g = (\f x -> Just (f x))
07:29:56 <copumpkin> :)
07:30:08 <c0n5pir4cy> How can i compost two maybe functions together
07:30:08 <skorpan> mmorrow: why doesn't "foo = g =<< f" work?
07:30:10 <c0n5pir4cy> >
07:30:18 <c0n5pir4cy> ?
07:30:24 <mmorrow> skorpan: since (f :: a -> m b)
07:30:37 <mmorrow> skorpan: rather than (m b)
07:30:47 <mmorrow> (assuming (g :: b -> m c))
07:30:57 <PeakerWork> c0n5pir4cy: >>=
07:31:17 <skorpan> i don't follow.  "foo a = g =<< f a" looks like a pointful version of "foo = g =<< f"
07:31:20 <mmorrow> @type Just <=< Just
07:31:21 <lambdabot> forall b. b -> Maybe b
07:31:45 <skorpan> > Just <=< Nothing
07:31:45 <lambdabot>   Couldn't match expected type `a -> Data.Maybe.Maybe b'
07:31:46 <lambdabot>         against infe...
07:31:50 <skorpan> > (Just <=< Nothing) 3
07:31:51 <lambdabot>   Couldn't match expected type `a -> Data.Maybe.Maybe b'
07:31:51 <lambdabot>         against infe...
07:31:53 <mmorrow> skorpan: right, but the types don't quite work out, the correct point-free version is with s/=<</<=</
07:32:00 <skorpan> > (Nothing <=< Just) 3
07:32:01 <lambdabot>   Couldn't match expected type `b -> m c'
07:32:01 <lambdabot>         against inferred type `Data...
07:32:05 <quuuux> skorpan: g =<< f doesn't typecheck though
07:32:17 <mmorrow> , (Just <=< Just) 42
07:32:18 <lunabot>  Just 42
07:32:29 <skorpan> ohhhhh, i see
07:32:34 <mmorrow> :)
07:32:38 <skorpan> > (Nothing =<< Just) 3
07:32:39 <lambdabot>   Couldn't match expected type `a -> m b'
07:32:39 <lambdabot>         against inferred type `Data...
07:32:42 <skorpan> god damn it :(
07:32:46 <mmorrow> heh
07:32:50 <skorpan> > Nothing =<< Just 3
07:32:51 <lambdabot>   Couldn't match expected type `a -> m b'
07:32:51 <PeakerWork> @pl foo a = g =<< f a
07:32:51 <lambdabot>         against inferred type `Data...
07:32:52 <lambdabot> foo = (g =<<) . f
07:32:57 <skorpan> i'm confused
07:33:01 <mmorrow> @type Nothing {- !!!! -}
07:33:02 <lambdabot> forall a. Maybe a
07:33:08 <mmorrow> not (a -> Maybe b)
07:33:10 <skorpan> :t Nothing =<< Just
07:33:11 <lambdabot>     Couldn't match expected type `a -> m b'
07:33:11 <lambdabot>            against inferred type `Maybe a1'
07:33:11 <lambdabot>     In the first argument of `(=<<)', namely `Nothing'
07:33:21 <PeakerWork> skorpan: =<<   takes a function on the left, and a Maybe on the right
07:33:26 <mmorrow> @type Just =<< Nothing
07:33:27 <lambdabot> forall a. Maybe a
07:33:41 <skorpan> i hate =<<, it always messes me up
07:33:41 <mmorrow> @type Just <=< (\a -> Nothing)
07:33:42 <lambdabot> forall b a. a -> Maybe b
07:33:49 <sproingie> > maybeToList =<< Just 3
07:33:49 <skorpan> why not just stick to >>= like normal people!?
07:33:50 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe b]'
07:33:50 <lambdabot>         against inferre...
07:34:08 <sproingie> oh duh
07:34:10 <PeakerWork> skorpan: because of the data flow
07:34:10 <mmorrow> skorpan: since (<=<) preserves the direction of flow when you've got (.) interspersed in there too
07:34:13 <kmc_> @src (=<<)
07:34:13 <lambdabot> f =<< x = x >>= f
07:34:19 <sproingie> > (+ 2) =<< Just 3
07:34:20 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
07:34:20 <lambdabot>    arising from the lite...
07:34:27 <mmorrow> skorpan: (resp. (=<<))
07:34:29 <sproingie> my brane doesn't work today
07:34:30 <PeakerWork> skorpan: Haskell pipes with (.) are the reverse direction of unix pipes, and its nice to be able to read without changing your direction :)
07:34:32 <quuuux> skorpan: the mnemonic I find useful is that the > and < show which way the data 'flows' through it
07:34:33 <c0n5pir4cy> lol this confuses me :)
07:34:40 <PeakerWork> sproingie: are you insane in the membrane?
07:34:45 <sproingie> don't i wish
07:35:40 <skorpan> insane in the brain!
07:37:27 <c0n5pir4cy> ok, no simpler way to do it? I cant get it to compile :(
07:38:03 <quuuux> @unpl (.) . (=<<)
07:38:03 <lambdabot> (\ f b c -> (b c) >>= f)
07:38:28 <mmorrow> c0n5pir4cy: are you trying to use (>=>) or (<=<)? since you direction of your original composeMaybe was equiv to (>=>) rather than (<=<)
07:38:50 <mmorrow> (or is that even what you're talking about..?)
07:38:56 <tensorpudding> > mod 104 33
07:38:57 <lambdabot>   5
07:39:11 <c0n5pir4cy> i tried both
07:39:12 <c0n5pir4cy> composeMaybe f g =  f >=> g
07:39:20 <c0n5pir4cy> Gives me a not in scope error
07:39:25 <mmorrow> oh
07:39:28 <mmorrow> import Control.Monad
07:39:45 <mmorrow> (you're using ghc(i), right? i'm not sure if hugs has that)
07:40:10 <c0n5pir4cy> Yeah, i'm using GHC
07:40:24 <mmorrow> yeah, you just have to import it
07:40:46 <mmorrow> :m + Control.Monad
07:40:48 <mmorrow> in ghci
07:41:19 <mmorrow> (putting that line in your $HOME/.ghci might be useful too)
07:41:27 <c0n5pir4cy> That works :)
07:41:30 <mmorrow> woo
07:41:43 <c0n5pir4cy> can you explain to me how the Monad works
07:41:52 <mmorrow> @src Maybe return
07:41:52 <lambdabot> return              = Just
07:41:58 <mmorrow> @src Maybe (>>=)
07:41:59 <lambdabot> (Just x) >>= k      = k x
07:41:59 <lambdabot> Nothing  >>= _      = Nothing
07:42:30 <mmorrow> , Nothing >>= (\a -> Just (a*2))
07:42:31 <lunabot>  Nothing
07:42:38 <mmorrow> , return 4 >>= (\a -> Just (a*2))
07:42:39 <lunabot>  Just 8
07:42:49 <c0n5pir4cy> :)
07:43:02 <mmorrow> easy! ;)
07:43:15 <c0n5pir4cy> yeah, Thanks for your help
07:43:23 <mmorrow> np
07:43:31 <c0n5pir4cy> :D
07:46:11 <HaskellLove> How do you say: n `mod` x !=0, i know there is no !
07:46:20 <skorpan> /=
07:46:25 <skorpan> > 3 /= 3
07:46:26 <lambdabot>   False
07:46:55 <HaskellLove> ok
07:48:20 <PeakerWork> > (3 /= 3) /= (1 /= 2)
07:48:21 <lambdabot>   True
07:48:27 <PeakerWork> > 3 /= 3 /= 1 /= 2
07:48:28 <lambdabot>   Precedence parsing error
07:48:28 <lambdabot>      cannot mix `GHC.Classes./=' [infix 4] and `GH...
07:48:37 <skorpan> > foldr (/=) 1 [1..10]
07:48:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:48:38 <lambdabot>    arising from the literal `1'...
07:48:45 <skorpan> > foldr (/=) True [1..10]
07:48:46 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:48:46 <lambdabot>    arising from the literal `1'...
07:48:56 <PeakerWork> Can't compare True and 1
07:48:59 <skorpan> hm... i wanted to come up with something clever for once. :(
07:49:15 <Philonous> foldl1 (/=) [True,True,True,False,True]
07:49:17 <Philonous> > foldl1 (/=) [True,True,True,False,True]
07:49:18 <lambdabot>   False
07:49:31 <quuuux> foldr (&&) $ zipWith (/=) [1..10] [1..10]
07:49:37 <quuuux> > foldr (&&) $ zipWith (/=) [1..10] [1..10]
07:49:38 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
07:49:38 <lambdabot>         against inferred type ...
07:49:52 <PeakerWork> > foldr1 (&&) $ zipWith (/=) [1..10] [1..10]
07:49:53 <lambdabot>   False
07:51:12 <quuuux> @pl \ f a -> f a a
07:51:13 <lambdabot> join
07:51:46 <quuuux> I need to learn how to make better use of the (-> r) monad, these nifty things keep coming up
07:52:22 <aavogt> are you sure you want to?
07:52:23 <ddarius> (r ->) or ((->) r), (-> r) isn't even a Functor
07:52:43 <quuuux> see? I can't even spell it right, I have much to learn :)
07:52:46 <aavogt> oh, you wrote the section wrong
07:52:50 <sproingie> and for now (r ->) is not valid syntax
07:53:07 <ddarius> I think some mild extensions allow it.
07:53:31 <aavogt> @instances-importing ((->) r)
07:53:32 <lambdabot> Couldn't find class `r)'. Try @instances-importing
07:53:43 <aavogt> @instances-importing Monad
07:53:44 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:53:46 <HaskellLove> [n | n<-[11,13..], x<-[3,4,5,7], n `mod` x /= 0] ----------------------- This is wrong... How can I say, give me n only if n mod x /= 0 but for all x`s not calcuate 11/3 and return 11, then 11/4 and return 11... I want to get a list of primes like [11,13,17,23]
07:53:47 <PeakerWork> join and liftM2 are easy, but ap still confuses me somewhat
07:53:54 <uorygl> quuuux: well, it's pretty simple; return is const and (>>=) is... some complicated thing.
07:54:07 <sproingie> LYAH covers ap pretty well
07:54:12 <aavogt> that simple eh?
07:54:31 <PeakerWork> sproingie: I mean, in the function monad instance
07:54:43 <sproingie> ap is like liftMX
07:54:48 <ddarius> (=<<) is S, ap is also S
07:54:51 <sproingie> where X is arbitrary
07:55:01 <PeakerWork> sproingie: its readable when its used that way
07:55:18 <PeakerWork> sproingie: f <$> x <*> y ...   but zip <*> tail is not very readable to me yet :)
07:55:24 <skorpan> S as in the S combinator?
07:55:28 <PeakerWork> @type zip <*> tail
07:55:29 <lambdabot> forall b. [b] -> [(b, b)]
07:55:40 <PeakerWork> ddarius: with a flipping of the first func arg to (=<<)
07:55:52 <ddarius> > (f =<< g) x
07:55:53 <sproingie> > zip <*> tail $ [1..10]
07:55:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:55:54 <lambdabot>    `GHC.Show.Show a'
07:55:54 <lambdabot>      a...
07:55:54 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
07:55:57 <aavogt> I have little intuition whether the head or tail is (fst . head) from that function
07:56:11 <aavogt> > (zip `ap` tail) "yes"
07:56:12 <lambdabot>   [('y','e'),('e','s')]
07:56:21 <ddarius> > (,) =<< succ $ 1
07:56:23 <lambdabot>   (2,1)
07:56:27 <ddarius> > ap (,) succ 1
07:56:28 <lambdabot>   (1,2)
07:56:30 <PeakerWork> I guess you can read: zip <*> tail   as -- apply zip to tail, where everyone's getting the reader's point
07:56:58 <ddarius> So ap is S and =<< is S . flip
07:57:55 <ddarius> So one could say (=<<) is BSC
07:58:18 <PeakerWork> what's that?
07:58:34 <ddarius> B = (.), C = flip
07:59:15 <PeakerWork> can you apply combinators with that syntax?
07:59:32 <PeakerWork> Only in your first academic degree, I suppose
08:00:11 <HaskellLove> let f n = if ((mod n 3 /= 0) && (mod n 4 /= 0) && (mod n 5 /= 0) && (mod n 7 /= 0)) then True ------------ why it gives me: <interactive>:1:93: parse error (possibly incorrect indentation)
08:00:25 <skorpan> HaskellLove: you need an else
08:00:26 <monochrom> where is your else
08:00:42 <skorpan> however that could easily be rewritten without an if
08:00:52 <skorpan> just remove "if" and "then True"
08:01:00 <HaskellLove> shit, u always need else in haskell? so in my case can I put: else _
08:01:12 <skorpan> no, you need to actually return a value
08:01:13 <paul424> hey how to use the  cabal to install packages ?
08:01:17 <copumpkin> HaskellLove: it's not hard to see why
08:01:23 <HaskellLove> got it
08:01:37 <PeakerWork> HaskellLove: what is it supposed to evaluate to if there's no "else" and the "if" doesn't match? :)
08:01:55 <monochrom> You have to give an answer either way.
08:01:55 <skorpan> HaskellLove: if you sometimes want to return a value and sometimes not, you are looking for Maybe, i.e. Nothing or Just <value>
08:02:02 <copumpkin> HaskellLove: in practice, I don't think many people use if anyway
08:02:13 <HaskellLove> how about ignore... but yeah every function must return and if is a function that returns boolean bla bla bla got it
08:02:24 <copumpkin> ignore?
08:02:39 <skorpan> is that "const . return ()"?
08:02:40 <aavogt> if blah then useful expression else error "Imma bad programmer"
08:02:56 <skorpan> hm const (return ()) rather
08:02:58 <skorpan> never mind
08:02:59 <HaskellLove> copumkin: its a joke
08:03:17 <PeakerWork> s/bad/naughty
08:03:54 <aavogt> return $ return ()
08:05:03 <monochrom> I now agree with skorpan. let f n = (mod n 3 /= 0) && (mod n 4 /= 0) && (mod n 5 /= 0) && (mod n 7 /= 0)
08:05:26 <ddarius> monochrom: Only if the else is "else False"
08:05:38 <monochrom> Yes.
08:05:38 <HaskellLove> let f n = if ((mod n 3 /= 0) && (mod n 4 /= 0) && (mod n 5 /= 0) && (mod n 7 /= 0)) then True else False ---------- Why does this return False for "f 25", wierd...
08:05:42 <ddarius> monochrom: However, no matter what is in the else, the thing could be rewritten easily not to use else.
08:05:54 <ddarius> er if-then-else
08:06:12 <monochrom> > mod 25 5 /= 0
08:06:13 <lambdabot>   False
08:06:30 <PeakerWork> let f n = all ((/=0) . (n `mod`)) [3,4,5,7]
08:07:13 <PeakerWork> > map (25 `mod`) [3,4,5,7]
08:07:14 <lambdabot>   [1,1,0,4]
08:07:26 <PeakerWork> HaskellLove: because mod 25 5 == 0
08:08:31 <HaskellLove> well daah and i say it IF it is /= 0 then give me true
08:10:13 <PeakerWork> HaskellLove: but it wasn't /= 0 so it gave you False
08:10:21 <PeakerWork> HaskellLove: not sure if you're asking or realizing :)
08:11:20 <copumpkin> Veinor: your waffleimages links are not clicker-friendly ;)
08:12:21 <HaskellLove> man in my function i say IF N IS NOT DIVISIBLE WITH ANY OF 3 4 5 OR 7 GIVE ME TRUE, OTHERWISE FALSE...25 IS DIVISIBLE WITH 5, SO GIVE ME FALSE...
08:12:47 <copumpkin> that's not what your logical expression says
08:13:00 <copumpkin> you wrote if it's divisible by ALL of 3,4,5,7
08:13:05 <PeakerWork> HaskellLove: s/any/all
08:13:27 <EvanR> are we programming in haskell or cobol
08:13:37 <copumpkin> HaskellLove: also, if p then True else False is just a tad redundant :P
08:13:58 <copumpkin> > let f n = if ((mod n 3 /= 0) && (mod n 4 /= 0) && (mod n 5 /= 0) && (mod n 7 /= 0)) then True else False in f (3 * 4 * 5 * 7)
08:14:01 <lambdabot>   False
08:14:03 <rasfar> EvanR lol
08:14:12 <HaskellLove> PeakerWork: let f n = all ((/=0) . (n `mod`)) [3,4,5,7] Can you explain what this does, the dot confuses me... even though i know what all and the dot operator do as separate out of this context
08:14:32 <PeakerWork> if (if (if p then True else False) then True else False) then True else False
08:14:38 <copumpkin> lol
08:14:38 <ddarius> copumpkin: That is actually the eta rule for booleans.
08:14:41 <fritschy_> copumpkin: i work in a company doing c++ - there are lots of programmers that write exactly that redundant "if (something == true)" like code... it's a shame!
08:14:49 <jmcarthur> @check \c -> (if c then True else False) == c
08:14:49 <lambdabot>   "OK, passed 500 tests."
08:14:53 <copumpkin> ddarius: that's a nice way to look at it
08:15:09 <copumpkin> fritschy_: yeah :/ it's a very common thing
08:15:35 <PeakerWork> HaskellLove: do you know what the (/=0) and (n `mod`) functions do, each?
08:15:36 <fritschy_> btw; i am not yet employed there... only student ;)
08:15:41 <HaskellLove> very redundant, i dont use it i just play with haskell now
08:16:02 <HaskellLove> PeakerWork: yes
08:16:30 <PeakerWork> HaskellLove: so  ((/=0) . (n `mod`))  tells you whether a number does NOT divide n nicely, ok so far?
08:17:11 <PeakerWork> HaskellLove: ((/=0) . (n `mod`)) x  ==  n `mod` x /= 0
08:17:12 <HaskellLove> this is crazy confusing
08:17:27 <EvanR> its stupid awesome!
08:17:30 <PeakerWork> HaskellLove: it just means: "First do (n `mod`) by this number, then compare the result with 0"
08:18:06 <PeakerWork> HaskellLove: so it tells you whether (n `mod`) by this number isn't 0
08:18:13 <copumpkin> @let n `divides` m = m `mod` n == 0
08:18:14 <lambdabot>  Defined.
08:18:25 <copumpkin> > nubBy (flip divides) [2..]
08:18:26 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:19:06 <HaskellLove> PeakerWork: That is the most stupid syntax ever, haskell should be ashamed for allowing such a stupidity... syntax should be intuitive not this shit...
08:19:14 <PeakerWork> HaskellLove: hehe
08:19:21 <copumpkin> wtf is this
08:19:33 <PeakerWork> HaskellLove: you're entitled to having a silly opinion :)
08:19:42 <HaskellLove> :D
08:19:44 <copumpkin> he's also entitled to piss me the fuck off
08:19:46 <copumpkin> but damn
08:19:54 <HaskellLove> copumkin i love u too man
08:19:58 <HaskellLove> anyways...
08:20:17 <ddarius> copumpkin: I would not waste my time with HaskellLove.  In fact, I don't.
08:20:21 <PeakerWork> HaskellLove: I find the syntax really nice...  (/= 0) is very clear.  (n `mod`) is very clear.  So the composition with (.) is very clear.  But it does take time to get used to new notations
08:20:54 <dons> is john earle blogging via haskell-cafe@? he doesn't seem to be asking questions.
08:20:57 <dons> very odd
08:21:05 * EvanR looks at the flip function for the first time
08:21:11 <copumpkin> > all (`divides` 25) [3,4,5,7]
08:21:12 <EvanR> interesting.
08:21:12 <lambdabot>   False
08:21:18 <copumpkin> > any (`divides` 25) [3,4,5,7]
08:21:19 <lambdabot>   True
08:21:24 <copumpkin> can't get much more readable than that
08:21:26 <ddarius> John Earle is another person I wouldn't and don't waste my time with.
08:21:38 <copumpkin> ddarius: yeah, I'll follow your example
08:23:35 <HaskellLove> PeakerWork: I got it man, yeah cool syntax thanks, I love Haskell again
08:24:36 <HaskellLove> it cofused me but then i remembered that the function on the rightmost is first applied so...
08:25:28 <PeakerWork> HaskellLove: don't let your (understandable) frustration from struggling with new things get the better of you :)
08:25:46 <HaskellLove> PeakerWork thanks man :D
08:26:37 <HaskellLove> PeakerWork how long r u in Haskell?
08:26:55 <PeakerWork> HaskellLove: 18 months or so, I think
08:27:00 <HaskellLove> wow
08:27:39 <PeakerWork> Took me about 2 months to fall in love with the language, I think :)
08:28:03 <PeakerWork> Before discovering Haskell, I wondered where all the like-minded people were hiding
08:28:43 <HaskellLove> 2 months? man for me it was the first day first love on first sight :D
08:29:04 <PeakerWork> HaskellLove: not sure how I can love a language I don't really understand yet
08:29:15 <HaskellLove> me niether hahahaha
08:29:53 <HaskellLove> i am kiding, i love it cause it is pure and i beleive we should go more functional and forget a ltile on imperative because it is full with shit
08:30:28 <dibblego> What about Scala? You divorced that?
08:30:33 <mmorrow> HaskellLove: how old are you?
08:31:07 <HaskellLove> I will be back to Scala after Haskell yes, because it combines both imperative and func
08:31:10 <copumpkin> I fell in love with it almost immediately
08:31:18 <copumpkin> it was weird
08:31:19 <HaskellLove> but for next two months just haskell
08:31:38 <EvanR> screw scala
08:31:41 <dibblego> Scala does no such thing, it only markets itself that way
08:31:51 * mmorrow guesses 16
08:31:53 <copumpkin> doesn't scala violate parametricity?
08:32:53 <HaskellLove> violate parametricity? what exactly do u mean
08:33:09 <copumpkin> doesn't it basically have typecase?
08:33:24 <sproingie> you
08:33:27 <dibblego> yes
08:33:27 <sproingie> it's two extra letters
08:33:28 <sproingie> use them
08:33:35 <inclement> Hmm...how do I write a function that tests if something is a String?
08:33:37 <inclement> Or other type
08:33:43 <copumpkin> inclement: with typecase! :P
08:33:55 <copumpkin> or typeclasses, in haskell
08:34:07 <inclement> Actually, tests if something can be read as a string - as opposed to crashing
08:34:10 <HaskellLove> hahaha i am not the only noob here, way the go inclement
08:34:13 <copumpkin> class RUASTRINGKTHX a where icanhazkthx :: a -> Bool
08:34:13 * inclement goes to look up typeclasses
08:34:26 <copumpkin> instance RUASTRINGKTHX String where icanhazkthx _ = True
08:34:26 <lispy> I think you could also do this with GADTs
08:34:38 <copumpkin> instance RUASTRINGKTHX a where icanhazkthx _ = False
08:34:42 <copumpkin> turn on overlapping instances
08:34:57 <copumpkin> inclement: oh, you need spoon!
08:34:58 <copumpkin> :P
08:35:00 <inclement> Ooh! A use for classes!
08:35:02 <sproingie> HaskellLove: we all try to be easy-going and friendly here, but it's really hard when you talk like a tween on myspace
08:35:04 <inclement> Thanks very much :)
08:35:11 <copumpkin> @hackage spoon
08:35:11 <lambdabot> http://hackage.haskell.org/package/spoon
08:35:13 * copumpkin coughs
08:35:14 <inclement> Understanding how classes might be useful to me has been an enduring pain :)
08:35:19 * copumpkin hopes dcoutts didn't notice him
08:35:44 <dcestari> hello all
08:36:00 <dcestari> I'm having an error compiling using Cabal
08:36:08 <EvanR> inclement: isnt anything in the Show class printable?
08:36:40 <dcestari> I do
08:36:46 <HaskellLove> sproingie sorry, anyways i go back to euler now cya...
08:36:54 <dcestari> #if MIN_VERSION_base(4,0,0)
08:36:54 <lunabot>  luna: Not in scope: `if'
08:37:05 <dcestari> but I get an error
08:37:07 * sproingie twitches his eyebrow
08:37:19 <inclement> EvanR: I'm not quite sure what you mean...what I'm actually trying to do is parse a list of floats, but cut out the first value if it is a string
08:37:25 <inclement> (This being the list title)
08:37:28 <dcestari> error: missing binary operator before token "("
08:37:36 <copumpkin> sproingie: r u anoid at me? y r u so strict?
08:37:56 <dcoutts> @slap copumpkin
08:37:56 <lambdabot> I won't; I want to go get some cookies instead.
08:38:05 <dcoutts> lambdabot: bah, you're going soft
08:38:06 <copumpkin> see, she likes spoon too
08:38:25 <dcoutts> @vixen you love pure functions don't you?
08:38:25 <lambdabot> you're fun too
08:38:26 * sproingie grabs a coknife to cocarve copumpkin into a cojackolantern
08:38:36 <copumpkin> inclement: but more seriously, you should use reads
08:38:40 <copumpkin> inclement: not spoon :)
08:39:00 <copumpkin> > read "\"a\"" :: String
08:39:01 <lambdabot>   "a"
08:39:02 * inclement sheathes google
08:39:06 <copumpkin> > read "\"a" :: String
08:39:07 <lambdabot>   "* Exception: Prelude.read: no parse
08:39:20 <copumpkin> > reads "\"a" :: [(String, String)]
08:39:21 <lambdabot>   []
08:39:26 <copumpkin> > reads "\"a\"" :: [(String, String)]
08:39:27 <lambdabot>   [("a","")]
08:40:04 <inclement> Ohoh, so it would return an empty list if there wasn't a string at the beginning? Thus solving the problem?
08:40:08 <copumpkin> yeah
08:40:16 <copumpkin> in fact, a more useful form of it
08:40:23 <mmorrow> , eval "reads \"\\\"a\\\"\" :: [(String, String)]"
08:40:23 <inclement> I see, thanks very muh
08:40:26 <lunabot>  <<[([Char],[Char])]>>
08:40:32 <copumpkin> :t fmap fst . listToMaybe . reads
08:40:33 <lambdabot> forall a. (Read a) => String -> Maybe a
08:40:56 <copumpkin> > (fmap fst . listToMaybe . reads) "4" :: Maybe Int
08:40:57 <lambdabot>   Just 4
08:41:01 <copumpkin> > (fmap fst . listToMaybe . reads) "a4" :: Maybe Int
08:41:02 <lambdabot>   Nothing
08:41:07 <copumpkin> :)
08:41:43 <tensorpudding> it's good to be Nothing
08:43:13 <copumpkin> :t fromJust
08:43:14 <lambdabot> forall a. Maybe a -> a
08:43:18 <copumpkin> :t fromNothing
08:43:19 <lambdabot> forall a. Maybe a -> a
08:44:44 <Philonous> @src fromNothing
08:44:45 <lambdabot> Source not found.
08:44:48 <dcestari> hello, I have this file http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13902
08:45:13 <sproingie> > fromNothing Nothing
08:45:14 <lambdabot>   * Exception: Prelude.undefined
08:45:16 <dcestari> but I think the cpp does ot ge called
08:45:29 <sproingie> > fromNothing (Just 123)
08:45:30 <lambdabot>   * Exception: Prelude.undefined
08:45:36 * copumpkin whistles
08:45:38 <sproingie> that was less than useful
08:46:20 <dcestari> seams like Cabal is no reading my 'extensions'
08:46:35 <copumpkin> dcestari: what are you trying to do again?
08:46:45 <dcestari> hehe
08:48:13 <dcestari> copumpkin: just this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13903
08:48:27 <dcestari> but looks like cabal does not want to
08:49:29 <dcoutts> dcestari: are you specifying the CPP extension?
08:49:48 <dcestari> yes dcoutts , http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13902
08:50:03 <copumpkin> ML~
08:50:06 <copumpkin> in our haskell!!
08:50:12 <copumpkin> blasphemy!!
08:50:15 <dcestari> hehehe
08:50:16 <copumpkin> (says the dude behind spoon)
08:50:26 <dcestari> is an interpreter
08:50:57 <nominolo> preflex: seen edwardk
08:50:58 <preflex>  edwardk was last seen on #haskell 2 hours, 58 minutes and 7 seconds ago, saying: gotta run
08:51:10 <dcoutts> dcestari: looks like it should work then
08:51:37 <dcestari> I get src/Main.hs:14:0:  error: missing binary operator before token "("
08:52:00 <nominolo> dcoutts: the cabal-install boot script doesn't work.  It tries to download Cabal-1.8.0 which I guess doesn't exist yet
08:52:02 <dcestari> and that line is exactly the hightlighted one here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13903
08:53:11 <HaskellLove> how to get n-th member of a list?
08:53:18 <HaskellLove> a[n] does not work
08:53:21 <dcoutts> nominolo: but you should have it installed already, so it should not bother trying to install it
08:53:29 <dcoutts> nominolo: unless you're building with 6.10
08:53:34 <nominolo> not on ghc 6.10.4
08:53:36 <copumpkin> HaskellLove: MORE RIDICULOUS BLAH SYNTAX FUCKING HASKELL ETC. (!!)
08:53:46 <nominolo> well I have to build with 6.10.4
08:53:50 <copumpkin> > [3..6] !! 1
08:53:51 <HaskellLove> copumkin cool ok
08:53:51 <lambdabot>   4
08:54:03 <lament> copumpkin: !!
08:54:16 <nominolo> otherwise it complains about that I should use my debain packages.  which is rediculous for 6.12
08:54:30 <dcoutts> nominolo: what complains?
08:54:36 <dcestari> dcoutts: no clue?
08:54:39 <nominolo> sh bootstrap.sh
08:55:22 <dcoutts> nominolo: I've no idea what you mean, it doesn't know anything about debian packages
08:55:36 <dcoutts> dcestari: you've not shown us what goes wrong
08:56:49 <luite> is there a haskell map implementation that has a function to get the smallest element greater than some value?
08:56:54 <nominolo> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13904#a13904
08:57:00 <dcestari> dcoutts: I run "runghc Setup build" and get "src/Main.hs:14:0:  error: missing binary operator before token "(""
08:57:20 <PeakerWork> luite: minimum . filter (>=someValue) ?
08:57:23 <dcestari> dcoutts: which is exactly the one hightlighted here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13903
08:57:37 <luite> PeakerWork: that is not quite the O(log n) operation I was looking foor :)
08:57:49 <nominolo> dcoutts: isn't the purpose of bootstrap to automatically download network and parsec?
08:57:49 <PeakerWork> luite: oh, you mean Map
08:57:58 <luite> oh sorry, yes
08:58:03 <dcoutts> nominolo: they used to always come with ghc
08:58:18 <PeakerWork> luite: should be possible
08:58:19 <nominolo> huh?  certainly not core-libs
08:58:21 <dcoutts> nominolo: the bootstrap hasn't really been updated for 6.12
08:58:34 <luite> PeakerWork: yes, but Data.Map doesn't seem to have a function for it
08:58:48 * monochrom 's prophecy yesterday comes true
08:58:57 <dcoutts> nominolo: people who picked the minimal ghc build have never needed a bootstrap script
08:59:18 <nominolo> dcoutts: I can't remember ghc ever shipping with network
08:59:25 <nominolo> that was always the problem with cabal-install
08:59:36 <nominolo> at least not the minimal distrib
08:59:37 <monochrom> ghc 6.4 and before shipped with network
08:59:42 <dcoutts> nominolo: it was in the extralibs collection so everyone had it
08:59:50 <nominolo> monochrom: well, I started with 6.6.1
08:59:52 <dcoutts> nominolo: I'll accept patches to update the bootstrap script
09:00:09 <PeakerWork> luite: look at Data.Map.split
09:00:26 <monochrom> Yes, 6.6.1 was when network moved to extralibs
09:01:14 <monochrom> http://groups.google.com/group/comp.lang.haskell/browse_frm/thread/ea4c9bb7aacf404b/62ce57594e91a4f7#62ce57594e91a4f7
09:01:24 <PeakerWork> luite: it behaves funny though
09:01:29 <luite> PeakerWork: oh thanks
09:01:39 <luite> oh why?
09:01:56 <dcoutts> dcestari: what version of ghc is that?
09:02:48 <PeakerWork> > M.split 2 $ M.fromList [(1,1),(2,2),(3,3)]
09:02:49 <lambdabot>   (fromList [(1,1)],fromList [(3,3)])
09:02:53 <PeakerWork> > M.split 3 $ M.fromList [(1,1),(2,2),(3,3)]
09:02:54 <lambdabot>   (fromList [(1,1),(2,2)],fromList [])
09:03:11 <PeakerWork> oh, I think I may have misread
09:03:18 <PeakerWork> luite: splitLookup seems nicer
09:03:43 <PeakerWork> > M.splitLookup 3 $ M.fromList [(1,1),(2,2),(3,3)]
09:03:44 <lambdabot>   (fromList [(1,1),(2,2)],Just 3,fromList [])
09:04:05 <Veinor> copumpkin: yeah, yeah. I post them as I get them :P
09:04:07 <mmorrow> luite: you can use okasaki's "bootstrapped queue" idea to get (amortized) O(1) findMin http://moonpatio.com/repos/boot-pq/IntPQ.hs
09:04:44 <mmorrow> luite: (that one uses IntMap as the "primitive" queue, so inherits some the complexity of IntMap for some operations)
09:05:26 <mmorrow> http://www.brics.dk/RS/96/37/BRICS-RS-96-37.pdf
09:06:44 <dcestari> dcoutts: is MIN_VERSION_base a ghc 6.10 macro?
09:06:57 <dcestari> dcoutts: 6.8
09:07:01 <mmorrow> luite: and the UndecidableInstances are a result of:
09:07:04 <mmorrow> deriving instance (Eq a, Eq (q (BootQ q a))) => Eq (BootQ q a)
09:07:08 <paul424> could someone have gtk2hs build already ?
09:07:14 <mmorrow> the "q(BootQ q a)" constraint
09:07:44 <luite> mmorrow: interesting, but does it support this operation? the findMin I want is a findMinThatIsAtLeast
09:08:35 <mmorrow> luite: hmm, i suppose you could add that operation if the "primitive" queue (here IntMap) supports it
09:09:00 <luite> my keys are also not integers
09:09:03 <mmorrow> but then you do no better than just using IntMap directly
09:09:09 <mmorrow> luite: right, s/IntMap/Map/
09:09:26 <dcoutts> dcestari: ok, that explains it. Those macros are added in Cabal-1.6 which comes with ghc-6.10. You can upgrade to Cabal-1.6 and keep using ghc-6.8, that combo works fine.
09:09:30 <mmorrow> (you'd only take a hit in the constant switching to Map)
09:09:43 <dcoutts> paul424: what do you mean exactly?
09:10:19 <paul424> the gtk bindings for haskell build for slackware ...
09:10:52 <mmorrow> luite: but yeah, that being the operation you want, i'd just use Map.split
09:11:02 <luite> mmorrow: ok, I'll just use Map for now then, thanks for the link though, I saved it to read later :)
09:11:07 <HaskellLove> listA = [2,3,5,7] ++ [n | n<-[11,13..], prime n == True] ------------- How can I say this list to have 10 000 members limit?
09:11:08 <mmorrow> luite: :)
09:11:14 <copumpkin> mmorrow: did you ever test your modified Set/Map?
09:11:20 <dcestari> dcoutts: I can't install anything there. So I'll have to use ghc version then?
09:11:20 <copumpkin> IntSet/Map I mean
09:11:39 <dcoutts> dcestari: you can install haskell packages in your home dir
09:12:27 <dcoutts> dcestari: but if you need it to work on plain installs of 6.8 then yes you need to use another technique
09:12:34 <dschoepe> HaskellLove: take 10000 listA
09:12:45 <dcoutts> dcestari: there's another more hacky method...
09:13:04 <HaskellLove> dschoepe why did not i thought of that? :( i know that command
09:13:06 <mmorrow> copumpkin: i did really briefly actually (just a quicky $ time ...) and there wasn't any difference really that i could see, BUT the problem i realized is that at all the places ghc inlines that function, it inlines the original version, and since i modified the asm it's essentially useless since it won't really be used
09:13:18 <copumpkin> HaskellLove: another == True? :P
09:13:23 <dcestari> dcoutts: I need it to work on plain installs of 6.8, I'll try
09:13:29 <copumpkin> mmorrow: oh
09:13:33 <mmorrow> copumpkin: :(
09:13:43 <HaskellLove> copumking: you mean about the prime?
09:13:55 <copumpkin> HaskellLove: yep
09:14:02 <dschoepe> HaskellLove: Yes, x == True is the same as just `x'
09:14:07 <copumpkin> gotta run, bbl
09:15:12 <dcoutts> dcestari: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13905
09:15:37 <dcoutts> dcestari: the base4 flag will get resolved automagically
09:15:58 <EvanR> yay. i get do notation now...
09:16:06 <dcestari> dcoutts: how?
09:16:12 <HaskellLove> copumpkin dude that tests if n is a prime
09:16:15 <dcoutts> dcestari: another alternative in your specific case is to use the extensible-exceptions package which works with 6.8 and 6.10
09:16:34 <dcoutts> dcestari: the value gets picked by Setup configure, though you can override it
09:16:53 <HaskellLove> dschoepe prime is a function returns true if n is prime
09:16:56 <dcoutts> dcestari: that way you get to use the exact same code, less testing
09:16:58 <dcestari> dcoutts: I looked into that, but then again I can't install it
09:17:14 <dschoepe> HaskellLove: yes, so instead of saying prime n == True, you could just say prime n
09:17:16 <dcoutts> dcestari: you can always install stuff locally, that's the default for cabal-install
09:17:31 <kmc_> > ((True == True) == True) == (True == True)
09:17:31 <lambdabot>   True
09:17:45 <HaskellLove> dschoepe that is like... hmm... cool...
09:17:51 <dschoepe> @check (x == True) == x
09:17:54 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
09:17:59 <dschoepe> @check \x -> (x == True) == x
09:18:00 <lambdabot>   "OK, passed 500 tests."
09:18:01 <kmc_> @check \b -> b == (if b then True else False)
09:18:02 <lambdabot>   "OK, passed 500 tests."
09:18:09 <HaskellLove> HaskellLove but i would rather have it explicit and readable
09:18:19 <nominolo> dschoepe: at least half of our first-year students make this "mistake"
09:18:33 <HaskellLove> nominolo? mistake?
09:18:40 <dcestari> dcoutts: this lab workstations are so weird they don't even have cabal-install
09:18:52 <nominolo> well, I put it in quote for a reason
09:18:53 <dschoepe> HaskellLove: well, more of a style error
09:19:02 <dcoutts> dcestari: you can do this even without cabal-install (which itself can be installed locally)
09:19:02 <EvanR> are we still trying to figure out if a true value == True evaluates to true
09:19:14 <monochrom> hahaha
09:19:22 <HaskellLove> dschoepe I would say do it if it is more readable like that, it is not always about less code
09:19:30 <kmc_> HaskellLove, i don't think it's ever better to say "prime n == True".  but it might be better if "prime" were named "isPrime"
09:19:43 <dcoutts> dcestari: sounds though like it might be wise for us to admit defeat and just use #if _GLASGOW_HASKELL >= 610
09:19:46 <dschoepe> HaskellLove: then most people wouldn't agree that it is more readable
09:19:48 <kmc_> because "isPrime n" is clearly better than "isPrime n == True"
09:19:53 <monochrom> Actually it is x==True evaluating to x.
09:19:53 <kmc_> in scheme they would say (prime? n)
09:20:18 <dcestari> dcoutts: hehe, I just can get every user to setup cabal on their HOME
09:20:30 <dcestari> dcoutts: I like the flag version
09:20:31 <nominolo> kmc_: in other Lisp it'd be (prime-p n)
09:20:34 <EvanR> monochrom: thats what i said ;)
09:20:48 <monochrom> x can be false.
09:20:55 <EvanR> ah
09:21:10 <dcoutts> dcestari: if you can get them to do that then you can use the extensible-exceptions solution
09:21:30 <kmc_> @pl \x -> x == True
09:21:30 <lambdabot> (True ==)
09:21:45 <nominolo> Too bad ScopedTypeVariables didn't make it into H'2010
09:21:45 <dcestari> dcoutts: sorry, that was "I just can't**"
09:22:03 <monochrom> > [ ((x==y)==z) == (x==(y==z)) | x<-[False,True], y<-[False,True], z<-[False,True] }
09:22:04 <dcoutts> dcestari: right, sounds more realistic :-)
09:22:04 <lambdabot>   <no location info>: parse error on input `}'
09:22:08 <monochrom> > [ ((x==y)==z) == (x==(y==z)) | x<-[False,True], y<-[False,True], z<-[False,True] ]
09:22:09 <lambdabot>   [True,True,True,True,True,True,True,True]
09:22:31 <EvanR> monochrom: perfect induction ;)
09:23:09 <monochrom> I don't know what that means. But I'm flattered. :)
09:23:25 <EvanR> you proved a law by evaluating all possible inputs ;)
09:23:55 <nominolo> EvanR: this assumes well-defined definition of ==
09:23:59 <nominolo> which is the case for Bool
09:24:03 <monochrom> Yes. I think it's the most convenient way for this community.
09:24:17 <EvanR> that other method where you rely on an infinite recursion of logic has always been fishy ;)
09:24:21 <dcestari> dcoutts: the flag version works perfectly
09:24:23 <nominolo> monochrom: now prove it for (==) :: Integer -> Integer -> Integer
09:24:49 <blueonyx> > [1,-1..]
09:24:50 <lambdabot>   [1,-1,-3,-5,-7,-9,-11,-13,-15,-17,-19,-21,-23,-25,-27,-29,-31,-33,-35,-37,-...
09:24:53 <nominolo> er, Bool at the ned
09:25:38 <EvanR> even Integer has its limits... right?
09:25:43 <dcestari> dcoutts: thanks a lot, you have been of great help
09:25:57 <dcoutts> dcestari: sorry it was a bit of a trial :-)
09:26:08 <Cale> EvanR: Eventually you run out of memory
09:26:21 <EvanR> never. i have six gigs.
09:26:56 <dcestari> dcoutts: I'd like to use haskell on my usual environment, web. but I don't know if that's realistic
09:27:18 <Cale> EvanR: So the limit is somewhere around 2^(6*2^30)
09:27:24 <dcoutts> dcestari: there are plenty of server-side frameworks
09:27:25 <HaskellLove> strange thing: (!!) listA 10000 gives me the element right away, but last listA calculates long time... how stupid is that?
09:27:26 <EvanR> dcestari: javascript with jquery is like almost as good, it seems
09:27:29 <monochrom> On some strange island you meet someone from a strange race. Each person in this race does this: he always speaks true statements (angel), or he always speaks false statements (demon). The person you meet says, "I am an angel iff I eat cookies". Does he eat cookies?
09:27:40 <Axman6> HaskellLove: not stupid at all
09:27:52 <Axman6> that's called lazy evaluation. enjoy it
09:28:00 <Cale> EvanR: of course, that'll be an overestimate since it assumes we use the entirety of your memory for the one integer
09:28:01 <dcestari> EvanR: I like that about javascript, and other EcmaScript related
09:28:13 <dcestari> dcoutts: anyone you ever used?
09:28:14 <kmc_> HaskellLove, are you sure you're not a troll?
09:28:17 <HaskellLove> Axman6, last traverses the whole list from start?
09:28:23 <dcoutts> dcestari: I've used happstack
09:28:38 <dcestari> dcoutts: I'll check that one out
09:28:41 <monochrom> Let x be "he is an angel", y be "he eats cookie". From his statement (which we are so sure of because we hear it), we know: x==(x==y).  That is (x==x)==y.  That is True==y.  He eats cookies.
09:29:06 <kmc_> @src last
09:29:06 <lambdabot> last [x]    = x
09:29:06 <lambdabot> last (_:xs) = last xs
09:29:06 <lambdabot> last []     = undefined
09:29:09 <monochrom> Or rather, shall I say: From we hearing his statement.
09:29:18 <dcestari> @src tail
09:29:19 <lambdabot> tail (_:xs) = xs
09:29:19 <lambdabot> tail []     = undefined
09:30:17 <nominolo> :t listA
09:30:18 <lambdabot> Not in scope: `listA'
09:30:31 <HaskellLove> so it traverses from start ... ah shiiit... if i was designer i would have made last a syntactic sugar for !!
09:30:44 <nominolo> HaskellLove: huh?
09:30:47 <kmc_> HaskellLove, to get the length of a list, you also must traverse it
09:30:48 <Axman6> HaskellLove: what?
09:30:49 <kmc_> @src length
09:30:49 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:31:05 <HaskellLove> oh i see
09:31:10 <HaskellLove> well i am crazy then
09:31:14 <HaskellLove> and stupid
09:31:17 <kmc_> length [] = 0; length (_:xs) = 1 + length xs
09:31:22 <kmc_> or, write it as a fold for bonus points
09:32:05 <EvanR> can the bot remember source that you type in, like the definition of length
09:32:05 <kmc_> HaskellLove, i don't see how it makes you crazy or stupid
09:32:13 <kmc_> it's just a property of singly linked lists
09:32:38 <kmc_> we can't store length "in the head" because it would break the property that you can break off part of a list and treat it as another list, with zero copying
09:32:49 <kmc_> which is essential for basically every aspect of how lists work in haskell
09:32:59 <dcestari> I have a question, not related to any problem. Just curious
09:33:18 <dcestari> I read on "A Gentle Introduction to Haskell" about the _|_ value
09:33:24 <EvanR> is list length very useful except for maybe statistics
09:33:25 <kmc_> HaskellLove, also, (!!) too traverses the list linearly
09:33:39 <Axman6> @src (!!)
09:33:39 <lambdabot> xs     !! n | n < 0 = undefined
09:33:39 <lambdabot> []     !! _         = undefined
09:33:39 <lambdabot> (x:_)  !! 0         = x
09:33:39 <lambdabot> (_:xs) !! n         = xs !! (n-1)
09:33:53 <dcestari> I though, "hey, Haskell 'gives you the finger' if you messed up!"
09:34:05 <dcestari> but I haven't seen this value ever
09:34:16 <EvanR> haha
09:34:32 <nominolo> dcestari: it's a collection of "shit happens" events
09:34:34 <kmc_> dcestari, it's not parsed or printed
09:34:38 <kmc_> > error "Bleh"
09:34:38 <lambdabot>   * Exception: Bleh
09:34:46 <HaskellLove> kmc_ how come is so fast then?
09:34:47 <nominolo> dcestari: like Error: undefined, or your program going into a loop
09:35:03 <dcestari> but is it an explicit type? nominolo
09:35:11 <kmc_> dcestari, it's not part of the language syntax
09:35:14 <kmc_> and it's not a type
09:35:18 <kmc_> it's a value that's a member of every type
09:35:31 <dcestari> so why the references to _|_
09:35:53 <kmc_> it's supposed to look like ⊥, which is from maths
09:36:06 <nominolo> dcestari: it's pronounced "bottom"
09:36:23 <kmc_> "e evaluates to _|_" is a shorthand way of saying "evaluating e results in a runtime error, or an infinite loop"
09:36:32 <lispy> is it called bottom because it's part of some lattice foramlism?
09:36:38 <kmc_> yes, domain theory
09:37:16 <lispy> and, bottom has type forall a. a, right?
09:37:18 <kmc_> dcestari, there is also a *type* named "bottom" in some languages (and sometimes in Haskell), but it's an unrelated concept
09:37:28 <lispy> Or is it just that it inhabits all types?
09:37:39 <nominolo> dcestari: whenever a function has an "impossible type" it's only value can be _|_ (i.e., an error or non-termination)
09:37:47 <kmc_> lispy, you'd never mention bottom in a typing judgement, only in an evaluation judgement
09:38:04 <monochrom> It is the bottom of the partial order you use for your data type.
09:38:10 <dcestari> but can I do something like?: failEveryTime = _|_ ??
09:38:11 * BMeph pats the nicely-shaped (_|_)... ;)
09:38:13 <kmc_> for proving things like type preservation you probably want it to inhabit every type
09:38:16 <kmc_> dcestari, that's not valid syntax
09:38:22 <lispy> kmc_: so it's not a value?
09:38:27 <kmc_> you would write it as "undefined"
09:38:30 <kmc_> > undefined
09:38:31 <lambdabot>   * Exception: Prelude.undefined
09:38:34 <kmc_> > error "custom message"
09:38:35 <lambdabot>   * Exception: custom message
09:38:40 <kmc_> > let x = x in x
09:38:44 <lambdabot>   mueval-core: Time limit exceeded
09:38:47 <nominolo> dcestari: yes, but you'd write it failEveryTime = undefined -- undefined = error "Prelude.undefined"
09:39:06 <kmc_> ^^^^^^  all three of those expressions "evaluate to bottom"
09:39:08 <EvanR> BMeph: the (.)(.) combinator
09:39:14 <dcestari> ok, so undefined ~ _|_ ?
09:39:19 <nominolo> dcestari: I.e., you cannot write it down in a program.  It's just a shorthand for a collection of undefined things.
09:39:26 <BMeph> Evan: Better yet, the (.)$(.) operator! ;)
09:39:27 <kmc_> it's terminology we use to talk about the language.  it's not part of the language
09:39:39 <EvanR> hah.
09:39:44 <lispy> :t (.)$(.)
09:39:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
09:39:46 <nominolo> dcestari: or a program that goes into an infinite loop
09:39:53 <dcestari> ok ok, I see
09:40:05 <dcestari> @src undefined
09:40:06 <lambdabot> undefined =  error "Prelude.undefined"
09:40:06 <EvanR> @pl (.)$(.)
09:40:07 <lambdabot> ((.) .)
09:40:11 <lispy> :t join . (.)$(.)
09:40:13 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
09:40:13 <lambdabot>     Probable cause: `.' is applied to too few arguments
09:40:13 <lambdabot>     In the second argument of `(.)', namely `(.)'
09:40:22 <dcestari> @src error
09:40:22 <lambdabot> error s = throw (ErrorCall s)
09:40:26 <lispy> :t join . ((.)$(.))
09:40:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (f a -> a -> b) -> f a -> f b
09:40:52 <kmc_> :t throw
09:40:53 <lambdabot> Not in scope: `throw'
09:40:55 <kmc_> @src throw
09:40:55 <lambdabot> throw exception = raise# exception
09:41:06 <dcestari> @src throw
09:41:06 <lambdabot> throw exception = raise# exception
09:41:07 <nominolo> dcestari: actually, exceptions are somewhat icky because they let you distinguish different kinds of _|_
09:41:16 <kmc_> dcestari, at this point you get into guts of GHC's implementation of haskell
09:41:30 <kmc_> it's probably best to treat "error" as a primitive, unless you are doing fairly specific things
09:41:36 <nominolo> dcestari: which is problematic from the point of referential transparency (and hence compiler optimisations and more)
09:41:47 <kmc_> that's why you can only catch in IO, right?
09:41:48 <dcestari> I see
09:42:36 <kmc_> it would be nice if there were monads to represen referentially-opaque actions that didn't also allow disk access, network access, spawning threads, etc.
09:42:39 <dcestari> interesting
09:42:42 <kmc_> i.e. the old "IO is too coarse-grained" problem
09:42:50 <BMeph> kmc_: I see it more as an "if you know it's coming, then it isn't "really" exceptional, is it? ;)
09:42:58 <nominolo> dcestari: basically, if you don't have referential transparency, then the result of a program is dependent on the order in which things are evaluated.  And that's essentially unpredictable in a lazy language
09:43:10 <HaskellLove> Why does this result in infinite loop when I call listA, to be printed... it calculates 10 minutes and still going i dont think it will stop
09:43:13 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13906#a13906
09:43:21 <kmc_> moreover, if you assume the order doesn't matter, your compiler can do awesome optimizations
09:43:30 <kmc_> so we like to make this assumption
09:43:35 <dibblego> can foldM generalise to type constructors besides []?
09:43:43 <nominolo> HaskellLove: take 10001 ([2] ++ [n | n<-[3,5..], isPrime n])
09:43:57 <nominolo> i.e. yours is interpreted as (take 10001 [2]) ++ [n | n<-[3,5..], isPrime n]
09:44:03 <mmorrow> luite: (err, re: the bootQ and O(1) findMin..) findMin is literally (/= amortized) O(1), it's deleteMin that becomes amortized
09:44:17 <BMeph> HaskellLove: It won't stop. Try it with parens around the "... ++ ..." part. :)
09:44:25 <mmorrow> luite: (fyi :)
09:44:28 <nominolo> dibblego: isn't that what Foldable implements?
09:44:35 <dibblego> oh it does?
09:45:02 <nominolo> I thought so.  I might be wrong
09:45:06 <BMeph> HaskellLove: Better yet, just say "[2] ++ take 1000 [...]" instead. :)
09:45:08 <dibblego> ah foldrM
09:45:15 <nominolo> foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
09:45:15 <nominolo> foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
09:45:50 <dibblego> nominolo, cheers
09:45:51 <mmorrow> kmc_: true, but either order matters or it doesn't, so really you want to avoid imposing an ordering that doesn't actually need to exist, rather than force code that needs to be ordered to not have an ordering (which doesn't make sense)
09:46:12 <monochrom> hehe
09:46:26 <nominolo> dibblego: I suspect foldrM to be not very stack-friendly
09:46:49 <dibblego> nominolo, I agree
09:48:03 <luite> mmorrow: ah that does make sense :)
09:58:28 <phr> did haskell-mode somehow change recently so it doesn't auto-indent .lhs the same way as before?
09:58:35 <phr> it used to outdent >
10:00:16 <HaskellLove> after lot of banging in the wall i realized i cant define a isPrime function like this: isPrime n = all ((/=0) . (n `mod`)) [3,4,5,7]
10:00:18 <HaskellLove> I mean I dont test whether a number is divisible with 11,13 and other sexy numbers... damn...
10:00:59 <monochrom> To find the primes, you must first fine the primes.
10:01:06 <monochrom> err
10:01:10 <monochrom> To find the primes, you must first find the primes.
10:01:17 <m3ga> sounds like recursions :-)
10:01:24 <monochrom> To understand recursion, you must first understand recursion.
10:01:42 <monochrom> And yes I am hinting at a solution.
10:01:53 <copumpkin> HaskellLove: did you see what I wrote earlier?
10:01:53 <roconnor> HaskellLove: http://r6.ca/blog/20081116T213644Z.html
10:02:03 <copumpkin> > nubBy (flip divides) [2..]
10:02:04 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:02:57 <kmc_> if you want to make an apple pie from scratch, you must first invent the universe
10:03:36 <m3ga> > numBy (flip divides) 2:[3, 5 ..]
10:03:36 <lambdabot>   Not in scope: `numBy'
10:03:47 <m3ga> > nubBy (flip divides) 2:[3, 5 ..]
10:03:49 <lambdabot>   No instance for (GHC.Enum.Enum [a])
10:03:49 <lambdabot>    arising from the arithmetic sequence...
10:03:55 <monochrom> To invent the universe, you plagiarize the universe.
10:04:00 <m3ga> > nubBy (flip divides) $ 2:[3, 5 ..]
10:04:02 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:04:03 <HaskellLove> copumkin what?
10:05:47 <HaskellLove> i tried to invent something guys? warn me! kick me if needed
10:06:22 <m3ga> HaskellLove: roconnor says look at http://r6.ca/blog/20081116T213644Z.html
10:07:22 <HaskellLove> will someone explain me what this thing does: nubBy (flip divides) [2..]
10:07:22 <copumpkin> HaskellLove: the expression for all primes that I wrote just now
10:07:25 <copumpkin> (and earlier)
10:07:42 <sm> http://programming-musings.org/2009/12/03/enjoying-haskell is very nice
10:08:01 <Alpounet> can we simulate polymorphic variants in haskell ?
10:08:21 <copumpkin> at best with existential types, I'd guess
10:10:14 <Alpounet> copumpkin, is it really the closest we can get ?
10:10:26 <copumpkin> aren't polymorphic variants basically subtyping?
10:10:57 <BMeph> Alpounet: Don't ask how to force the computer to do it; ask what YOU want to do with it. ;)
10:11:27 <Alpounet> BMeph, actually my question was rather theoretic.
10:11:35 <HaskellLove> so u guys recommend me not to fuck around and try to find primes but use a function for it and then just take the 10001 element. would not that be a cheat for the euler problem?
10:11:38 <Alpounet> I handle practical things I need to do quite well for the moment :-)
10:11:42 <copumpkin> HaskellLove: there's a much more efficient way to get an infinite list of primes, but it isn't quite as succinct
10:11:51 <v_> sm: http://programming-musings.org/2006/03/28/a-haskell-bookshelf/ is very nice too
10:12:03 <Alpounet> copumpkin, yeah, well, sort of.
10:12:05 <copumpkin> HaskellLove: whatever you can do in under one minute isn't a cheat :) as long as you wrote it or at least understand it
10:12:17 <Alpounet> copumpkin, see http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc36
10:12:18 <copumpkin> > nubBy (flip divides) [2..] !! 10001
10:12:21 <lambdabot>   mueval-core: Time limit exceeded
10:12:23 <sm> oh, thank you
10:12:24 <copumpkin> > nubBy (flip divides) [2..] !! 1000
10:12:26 <HaskellLove> copumpkin i can live with that
10:12:28 <lambdabot>   mueval-core: Time limit exceeded
10:12:29 <copumpkin> that code is slow :P
10:12:39 <copumpkin> but so short and sweet :)
10:13:00 <HaskellLove> yeah but please explain me what nubBy (flip divides) [2..] !! 1000 does? i dont get this code...
10:13:22 <copumpkin> @src nubBy
10:13:22 <lambdabot> nubBy eq []             =  []
10:13:22 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:13:39 <copumpkin> HaskellLove: it's basically a recursive filter
10:13:59 <copumpkin> > filter (flip divides 2) [2..10]
10:14:00 <lambdabot>   [2]
10:14:10 <copumpkin> > filter (divides 2) [2..10]
10:14:11 <lambdabot>   [2,4,6,8,10]
10:14:18 <copumpkin> > filter (divides 3) [2..10]
10:14:19 <lambdabot>   [3,6,9]
10:14:34 <copumpkin> it's basically filtering all but the first element of those out
10:14:47 <v_> > (filter (divides 3) [2..]) !! 100
10:14:48 <lambdabot>   303
10:15:06 <det> Is anyone familiar with how a mark/compact GC works? Is it necessary to store the length of the block in a header?
10:15:37 <phr> er, it can be done different ways
10:15:40 <phr> like BIBOP
10:15:44 <phr> doesn't require storing the length
10:15:47 <v_> > flip (>) 3 11
10:15:48 <lambdabot>   True
10:16:20 <v_> > nubBy (\x y -> x+y == 10) [1..100]
10:16:21 <lambdabot>   [1,2,3,4,5,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
10:17:15 <v_> > randomlist 10 seed
10:17:16 <lambdabot>   Not in scope: `randomlist'Not in scope: `seed'
10:18:25 <HaskellLove> nubBy (flip divides) [2..] !! 1000 ---- slow down .... i read about nubBy in manual and still dont get it... noobish language please?
10:18:52 <xerox> ?index nubBy
10:18:53 <lambdabot> Data.List
10:18:55 <xerox> ?docs Data.List
10:18:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
10:19:26 <xerox> HaskellLove there you go http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#nubBy
10:19:29 <det> phr, Thanks, I'll take a look at it.
10:19:43 <v_> It doesn't get any clearer than this  http://www.zvon.org/other/haskell/Outputlist/nubBy_f.html
10:19:51 <det> Is storing the length the "usual" way of going about it ?
10:20:07 <HaskellLove> xerox that is not noobish :D
10:20:19 <copumpkin> HaskellLove: nub removes "duplicates" from a list
10:20:24 <v_> #ifdef USE_REPORT_PRELUDE
10:20:24 <HaskellLove> yes
10:20:25 <lunabot>  luna: Not in scope: `ifdef'
10:20:28 <v_> is not :-P
10:20:30 <copumpkin> > nub [1,1,11,2,1,1,4,6,2,4,1]
10:20:31 <lambdabot>   [1,11,2,4,6]
10:20:33 <xerox> HaskellLove: ignore what doesn't fail between USE_REPORT_PRELUDE
10:20:36 <copumpkin> HaskellLove: make sense so far?
10:20:43 <phr> det, hmm, i think i'm not really current with the times
10:20:43 <xerox> fall not fail
10:21:00 <HaskellLove> but nubBy? i know nub
10:21:02 <phr> but yeah, storing the length somehow is the most obvious wya
10:21:03 <phr> way
10:21:11 <copumpkin> HaskellLove: nubBy allows you to specify your own equality comparison
10:21:20 <phr> usually you'll have some special hack for specific common sizes
10:21:22 <copumpkin> I claim two elements are equal if one divides the other
10:21:26 <phr> like in lisp you have a lot of cons ondes
10:21:27 <phr> nodes
10:21:33 <det> phr, I am just thinking about algorithms, and it seems like a copying collection can get by with a 1 word header, but mark/compact would need a 2 word header
10:21:38 <phr> so you'll tend to allocate pages of them
10:21:59 <det> I see
10:22:02 <phr> marking gc's often use just 1 bit
10:22:29 <det> I'd think you would need 1 word for the new pointer
10:22:37 <det> and 1 word for the length
10:22:37 <phr> hmm
10:22:53 <phr> maybe you can update all the pointers on the fly
10:22:57 <det> and could combine the marking bit into 1 of those fields since they would be word aligned
10:23:08 <tensorpudding> (:), head and tail are a bit nicer than cons, car and cdr if you ask me
10:23:45 <det> The common sizes thing could help
10:23:46 <copumpkin> car (short for "Contents of the Address part of Register number"),
10:23:50 <copumpkin> cdr ("Contents of the Decrement part of Register number"),
10:23:53 <HaskellLove> nubBy (flip divides) [2..] .... so this together with flip and divides means?
10:23:59 <det> but I wonder if it is worth complicating allocation
10:24:05 <tensorpudding> copumpkin: yes, very clear from the acronyms
10:24:26 <phr> i'm sort of vague on this, but can't you use a data field of the old object to point to the new object, then forward any references as you find them?  i think that's normal
10:24:37 <copumpkin> HaskellLove: what I said. Removes duplicates from [2..] where I define duplicates as being a pair of numbers where one divides the other
10:24:48 <phr> there's a page full of gc papers maintained by mark jones iirc
10:25:09 <phr> richard jones
10:25:14 <phr> http://www.cs.kent.ac.uk/people/staff/rej/gc.html
10:25:27 <phr> pretty old though
10:25:32 <BMeph> I like the papers by Chuck Jones, they're much funnier. ;p
10:26:24 <HaskellLove> copumpkin that is like Uber Uber complicated for me give me an hour to figure it out
10:27:56 <BMeph> HaskellLove: You know what 'flip' does, right? ;)
10:28:14 <tensorpudding> @src flip
10:28:14 <lambdabot> flip f x y = f y x
10:28:33 <copumpkin> HaskellLove: just ignore how nubBy is defined. Just think of a more general notion of equality. nub [1,1,1,3,1,3,10] will take 1 at the beginning of the list and filter 1 out of [1,1,3,1]. It will then be left with only [3,3,10]. It then takes 3 from the head of the list and filters it out of the remaining list, [3,10]. That means it's left with [10], which it takes 10 from and filters [] of. Then it's left with [1,3,10].
10:29:27 <copumpkin> HaskellLove: nubBy (flip divides) means the same idea, except instead of comparing for equality, it's asking if the number divides another. So it effectively amounts to filter out all multiples of 2, then filter out all multiples of 3, and then all multiples of 5, and so on
10:29:32 <Cale> Of course, the order in which things happen is a little different from that since:
10:29:37 <Cale> > nub [1..]
10:29:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:29:43 <Cale> But that's a detail :)
10:29:52 <copumpkin> yeah :P
10:32:58 <HaskellLove> wow u guys are crazy cool, are you Masters or Phds?
10:33:41 <HaskellLove> which flip do you mean the one from Prelude or from Data.Function
10:33:51 <copumpkin> HaskellLove: they're the same :)
10:34:03 <copumpkin> flip is one of those functions that can only have one definition
10:34:09 <copumpkin> (ignoring bottoms!)
10:34:35 <copumpkin> :t flip
10:34:36 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:34:44 <copumpkin> wtf
10:34:48 <Draconx> caleskell!
10:34:54 <copumpkin> dammit! :P
10:35:09 <copumpkin> @djinn (Functor f) => f (a -> b) -> a -> f b
10:35:09 <lambdabot> Error: Class not found: Functor
10:35:13 <copumpkin> bah :)
10:35:25 <copumpkin> @djinn-a
10:35:31 <copumpkin> @djin
10:35:32 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
10:35:49 <copumpkin> @djinn-add class Functor f where fmap :: (a -> b) -> f a -> f b
10:35:56 <copumpkin> @djinn (Functor f) => f (a -> b) -> a -> f b
10:35:57 <lambdabot> -- f cannot be realized.
10:35:57 <jmcarthur> :t \f x -> fmap ($x) f
10:35:58 <joe____> what is the use of "type synonym" other than making the code readable?
10:35:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
10:36:04 <copumpkin> jmcarthur: boo
10:36:09 <copumpkin> joe____: 'sabout it
10:36:15 <jmcarthur> @pl \f x -> fmap ($x) f
10:36:15 <Draconx> @pl \f x -> fmap ($x) f
10:36:15 <lambdabot> flip (fmap . flip id)
10:36:15 <lambdabot> flip (fmap . flip id)
10:36:18 <jmcarthur> :
10:36:49 <copumpkin> omg Twey infected jmcarthur
10:36:55 <tensorpudding> flip doesn't really help readability
10:37:06 <Draconx> bah, using flip in the definition of caleflip there is bad :(
10:37:13 <copumpkin> yeah
10:37:21 <copumpkin> @src flip
10:37:21 <lambdabot> flip f x y = f y x
10:37:26 <copumpkin> especially when @src lies now
10:37:37 <jmcarthur> @src (.)
10:37:37 <lambdabot> (f . g) x = f (g x)
10:37:41 <jmcarthur> is also a lie
10:37:43 <jmcarthur> :t (.)
10:37:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:37:52 <joe____> if there is a function that has a definition of "functionx :: type_synonym" and "type type_synonym = Int -> Int", can I call functionx as " functionx 0 0"
10:37:54 <jmcarthur> frickin' caleskell
10:38:22 <jmcarthur> joe____: no, just functionx 0
10:38:25 <raceRider> @type zip
10:38:26 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
10:38:36 <raceRider> @type ascii
10:38:37 <lambdabot> Not in scope: `ascii'
10:38:44 <raceRider> @type foldr
10:38:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:39:08 <copumpkin> @let thecake a = is a lie
10:39:09 <lambdabot>  Defined.
10:39:27 <m3ga> > [1 .. 10] !! 2
10:39:27 <roconnor> @let liar = not liar
10:39:28 <lambdabot>   3
10:39:28 <lambdabot>  Defined.
10:39:29 <joe____> jmcarthus, yes as the last Int is return parameter of functionx
10:39:41 <tensorpudding> > liar
10:39:45 <lambdabot>   mueval-core: Time limit exceeded
10:40:06 <tensorpudding> some help that is
10:40:17 <joe____> jmcarthur, thanks
10:44:42 <det> phr, hmm, I think you can get by with a 1 word header using the following scheme
10:45:23 <det> phr, if all heap objects are allocated word-aligned, then you have 6 bits to play with on 64 bit and 5 bits on 32 bit arch
10:45:30 <HaskellLove> ok wait someone explain me flip first with simple example
10:45:47 <copumpkin> > flip (-) 5 3
10:45:48 <lambdabot>   -2
10:45:52 <copumpkin> > (-) 5 3
10:45:53 <lambdabot>   2
10:45:57 <det> phr, so you can use 1 bit for marking, that leaves you 5 bits to encode length in
10:46:12 <ivanm> @type flip
10:46:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:46:18 <copumpkin> HaskellLove: if your function takes two arguments, it gives you a function that takes those arguments in the opposite order
10:46:27 <copumpkin> ivanm: @type has lost its educational qualities :)
10:46:39 <ivanm> bugger, so it has
10:46:41 <ivanm> @slap Cale
10:46:42 * lambdabot will count to five...
10:46:49 <phr> det, in old fashioned systems you would have a block of objects all the same size
10:46:53 <ivanm> :t flip
10:46:54 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:47:00 <ivanm> yup, stuffed that up as well
10:47:05 <phr> so you'd only store the length as part of the block, not all the internal objects
10:47:12 <phr> e.g. you'd have a 4k page
10:47:12 <ivanm> Caleskell--
10:47:21 <phr> where the first few words would be a header
10:47:23 <det> phr, if you use 1 of those bits to indicate the length is too large to encode, then you can encode all objects equal to or lesser than 16 (2 ** 4) words in length using just a 1 word header
10:47:24 <HaskellLove> (flip divides) [2..] so flip here flips what?
10:47:32 <copumpkin> HaskellLove: flips divides
10:47:37 <phr> then to get the length you'd mask off the low address bits to look at the beginning of the page
10:47:38 <copumpkin> > 5 `divides` 10
10:47:39 <lambdabot>   True
10:47:52 <det> phr, and you use another word for objects that are longer than 16 words
10:47:56 <copumpkin> > divides 5 10
10:48:00 <lambdabot>   True
10:48:01 <copumpkin> > divides 10 5
10:48:02 <lambdabot>   False
10:48:03 <det> phr, or longer than 8 words on 32bit
10:48:04 <copumpkin> > flip divides 10 5
10:48:05 <lambdabot>   True
10:48:10 <Draconx> divides 10 0
10:48:13 <Draconx> > divides 10 0
10:48:14 <lambdabot>   True
10:48:16 <phr> det  i guess on a 64 bit system you can use bits like that
10:48:24 <phr> but on 32 bit systems they are more scarce
10:48:27 <det> phr, even on 32bit, I think you have 5 bits to play with
10:48:46 <det> or am I wrong
10:48:50 <phr> det you really want to use no more than 2 words for a cons node
10:48:55 <HaskellLove> (flip divides) [2..] the parenthesis confuse me a lot... is this the same: flip divides [2..]
10:49:01 <ivanm> yes
10:49:07 <phr> just a pair of pointers where you can snag a bit or two
10:49:26 <phr> i guess you can get a couple bits from each pointer
10:49:44 <phr> or if they're all on 8-byte boundaries then 3 bits from each ptr
10:49:53 <phr> so yeah, 1 bit for gc mark, 5 bits for size
10:50:02 <BMeph> HaskellLove: Actually, no.
10:50:13 <phr> but, i dunno if modern systems do stuff like that
10:50:15 <det> Am I correct that if you align all accesses to 32 bits you have 5 bits ?
10:50:18 <phr> jones's book is like 10 years old
10:50:30 <phr> well they are byte addresses
10:50:42 <det> my brain isnt working now
10:50:47 <det> I might be way off
10:51:00 <phr> 32 bits = 4 bytes
10:51:04 <tensorpudding> @type flip divides
10:51:05 <BMeph> HaskellLove: Er, Okay, just by itself it's the same, but the point is, "(flip divides)" is a function that's used by "nubBy". :)
10:51:05 <lambdabot> forall a. (Integral a) => a -> a -> Bool
10:51:13 <phr> so you only get 2 bits per pointer to mess with
10:51:14 <tensorpudding> flip divides is a function
10:51:18 <det> ahh
10:51:23 <det> and 3 bytes on 64 bit ?
10:51:32 <phr> 3 bits, yeah
10:51:39 <tensorpudding> flip takes a function and returns a function with its arguments flipped
10:51:42 <phr> but the thing is, on 64 bits you won't really use 64 bits of address space
10:51:49 <phr> you can simply grab more bits
10:51:58 <phr> but on 32 bit systems the address bits are precious
10:52:12 <HaskellLove> BMeph... slow in noobish language please... what this means : nubBy (flip divides) [2..]
10:52:45 <tensorpudding> @src nubBy
10:52:45 <lambdabot> nubBy eq []             =  []
10:52:46 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:52:57 <BMeph> HaskellLove: Okay, "nubBy" is a function. It takes a function as its first qargument, in this case, "(flip divides)".
10:52:58 <det> I guess with 2 bits, you dont have enough to encode cons nodes
10:53:03 <det> 1 bit for marking
10:53:19 <HaskellLove> BMeph... ok go on
10:53:31 <det> 1 bit for whether it fits in 1 word
10:53:38 <det> which would just be a mutable reference
10:53:41 <det> not a pair
10:54:04 <BMeph> HaskellLove: nubBy takes a second argument, a list of things. Tehn it uses the function it got to decide whether to "pass on" an element of the list, or throw it out.
10:54:38 <phr> i think some systems use 2 or 3 tag bits
10:54:54 <det> although I guess if you made it relative to some other address and limited the size of the heap to 2GB, you could gain another bit
10:54:57 <HaskellLove> BMeph ok...
10:55:18 <phr> 2 bits = 00 => immediate integer, 01 => pair, 10 = immediate short float, 11 = tagged heap object, maybe?
10:55:24 <tensorpudding> > nubBy (==) [1..10]
10:55:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:55:42 <tensorpudding> > nubBy (/=) [1..10]
10:55:43 <lambdabot>   [1]
10:55:52 <det> phr, you need 1 bit for marking
10:55:53 <phr> that lets you do integer addition without any bit operations
10:56:08 <HaskellLove> <tensorpudding>man u confuse me wait BMeph explains me
10:56:09 <phr> well there's no immediate objects in the heap
10:56:14 <det> and this is only for compaction
10:56:15 <phr> so you can re-use those values
10:56:30 <tensorpudding> > nubBy (\x y -> mod x y == 0) [1..10]
10:56:31 <det> it doesnt need to encode types at all
10:56:31 <lambdabot>   [1]
10:56:35 <det> only length
10:56:50 <det> types can easily be encoded on the stack tagless
10:56:51 <tensorpudding> > nubBy (\x y -> mod x y == 0) [3..10]
10:56:52 <lambdabot>   [3,4,5,7]
10:57:02 <tensorpudding> > nubBy (\x y -> mod x y == 0) [2..20]
10:57:03 <lambdabot>   [2,3,5,7,11,13,17,19]
10:57:09 <tensorpudding> oh hey, we got primes
10:57:29 <phr> det if you're trying to write a serious gc i think you've got to read up on the literature, there are many decades of fiendish cleverness to know about
10:57:41 <BMeph> HaskellLove:  The way it (nubBy) decides is, it uses the function on 1) an element in the list and 2) all of the elements that came before it. If the function ever gives back "True" then it discards the element, and goes to the next one.
10:57:53 <phr> and everything i know is way old
10:57:54 <tensorpudding> in that one i just put, nubBy takes the next number in the list, and removes all elements in the list which are multiples of that number
10:58:13 <det> Well, I can easily think about how to do copying collection with just a 1 word header
10:58:16 <det> and tagless stack
10:58:23 <phr> yeah
10:58:23 <tensorpudding> so it should produce primes, though it's a really slow algorithm for finding primes
10:58:39 <det> I guess even 2 header mark/compact uses less memory than 1 header copying
10:58:59 <HaskellLove> nubBy (\x y -> mod x y == 0) [2..20] <tensorpudding talk to me man, noobish explain this i still dont get it what happens
10:59:02 <phr> there are some copying collectors which use very small regions
10:59:03 <phr> immix ?
10:59:16 <det> very small regions ?
10:59:44 <phr> http://cs.anu.edu.au/techreports/2007/TR-CS-07-04.pdf
10:59:58 <phr> http://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf
11:00:03 <tensorpudding> okay, so it first matches [2..20] to (x:xs), and the x is 2. it then does filter on the rest of the list to remove every element in xs which fails the test
11:00:22 <phr> http://www.haskell.org/pipermail/cvs-ghc/2009-February/047626.html
11:00:22 <tensorpudding> err, actually, it removes all the ones that succeed the test
11:00:36 <phr> http://hackage.haskell.org/trac/summer-of-code/ticket/1566
11:00:42 <tensorpudding> in this case, the test is checking to see if they are multiples of x
11:01:12 <tensorpudding> because if y is a multiple of x, then mod x y == 0
11:01:19 <tensorpudding> > mod 5 10
11:01:20 <lambdabot>   5
11:01:26 <tensorpudding> err, other way around
11:01:30 <tensorpudding> > mod 10 5
11:01:31 <lambdabot>   0
11:01:41 <tensorpudding> divides would be simpler
11:01:45 <tensorpudding> @src divides
11:01:45 <lambdabot> Source not found. My mind is going. I can feel it.
11:01:50 <tensorpudding> oh well
11:02:06 <tensorpudding> we could define a function to represent that test we have, instead of using that throwaway lambda
11:02:41 <tensorpudding> so the first application of nubBy returns 2:nubBy eq ys, where ys is xs, but it had filtered all of the
11:02:58 <tensorpudding> elements for which eq x y is false
11:03:23 <tensorpudding> it essentially is doing the sieve of eratosthenes
11:03:41 <det> phr, hmm, it's not obvious how large of a header they use, just by skimming
11:04:13 <phr> i didn't get the sense they were trying to squeeze out every bit like in the old days
11:05:01 <det> Well, 2 word header for cons seems excessive
11:05:15 <det> for larger objects it is better
11:05:17 <phr> yeah
11:05:20 <phr> looking
11:06:32 <det> Seems it isnt quite so simple in this collector
11:06:44 <phr> ah, they don't store the size (at least for small objects), they have separate object lists for different sizes
11:07:03 <det> "Immix is struc-
11:07:03 <det> tured around aligned 128B lines and 32KB blocks, and can reclaim
11:07:03 <det> space at 128B granularity.
11:07:03 <det> "
11:07:11 <phr> yeah
11:07:12 <det> sorry for multi-line paste
11:07:17 <phr> np
11:07:59 <phr> 1 mark byte per line
11:08:29 <det> and a line is only reclaimed when all objects contained in it are garbage ?
11:08:47 <phr> not sure, i haven't read this thing yet
11:09:03 <phr> it looks that way though
11:09:21 <phr> well, it's a copying collector
11:09:27 <det> ahh
11:09:30 <phr> so i guess it can copy multiple objects from an old line to a new one
11:10:01 <phr> i will have to read this thing all the way thru
11:10:16 <phr> but my second-favorite tv show is coming on soon :)
11:11:03 <det> what is that
11:11:09 <phr> countdown
11:11:17 <det> never heard of it :-)
11:11:31 <phr> it's about US politics
11:11:40 <phr> if you're not from here, be happy :)
11:11:48 <Alpounet> phr, what's you first favorite ? :-p
11:11:48 <det> I am
11:11:52 <det> Las Vegas, Nevada
11:11:57 <phr> oh ok :)
11:12:30 <phr> you can download from here http://podcast.msnbc.com/audio/podcast/MSNBC-COUNTDOWN-NETCAST-M4V.xml
11:12:39 <phr> actually 2nd-favorite is sort of bogus, i don't watch it very often
11:12:56 <phr> i don't have a tv at all, i just download the podcast once in a while
11:14:29 <phr> but i have some folks visiting who like to watch it and my download just finished... so bbl :)
11:17:01 <Acedio> Hey all :) Does anyone know how to write binary to a file? I'm currently just using writeFile, but it's outputting unicode...
11:20:04 <joe____> i am trying to create a function that can return a "Ptr" parameter
11:20:20 <joe____> does anyone remember one from the top of their head?
11:20:45 <joe____> i am trying to create Ptr parameter to test a binding function
11:21:10 <Draconx> Acedio, use bytestrings.
11:21:20 <Cale> :t Foreign.Alloc.malloc
11:21:21 <lambdabot> Couldn't find qualified module.
11:21:33 <Cale> :t Foreign.Marshall.Alloc.malloc
11:21:34 <lambdabot> Couldn't find qualified module.
11:21:36 <Cale> :t Foreign.Marshal.Alloc.malloc
11:21:37 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO (GHC.Ptr.Ptr a)
11:21:44 <Cale> There it is :)
11:21:49 <joe____> Thanks Cale
11:21:57 <Cale> Or better yet
11:22:00 <Cale> :t Foreign.Marshal.Alloc.alloca
11:22:01 <lambdabot> forall a b. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
11:22:11 <Acedio> Draconx: Thanks, these look like they'll do the trick!
11:22:18 <Cale> You pass it a function which needs a Ptr, and it handles the allocation/deallocation
11:23:17 <manju> ah..finally xchat
11:23:39 * manju was uncomfortable with konersation
11:26:51 <joe____> sorry if this is a stupid question. I am trying to create a pointer x using " x <- Foreign.Marshal.Alloc.malloc" but gives an error
11:26:59 <joe____> any easy way to do this?
11:27:11 <Axman6> what's the type of malloc?
11:27:14 <Axman6> and what's the error?
11:27:27 <joe____>   Ambiguous type variable `a' in the constraint:
11:27:27 <joe____>       `Foreign.Storable.Storable a'
11:27:27 <joe____>         arising from a use of `Foreign.Marshal.Alloc.malloc'
11:27:27 <joe____>                      at <interactive>:1:5-32
11:27:32 <Cale> joe____: Make sure that you go on to use x appropriately
11:27:44 <Cale> joe____: so that it can infer how much memory that it needs to allocate
11:28:02 <Axman6> joe____: you might need something like "x <- malloc (y :: Int)"...
11:28:04 <Cale> Otherwise, you'll have to give an explicit type signature to resolve the ambiguity
11:28:13 <Cale> er, that wouldn't work
11:28:20 <ivanm> anyone know how to do multiline haskell code in a blog post in wordpress.com ?
11:28:22 <Cale> x <- malloc :: IO (Ptr Int)
11:28:24 <Cale> would though
11:28:40 <joe____> i am trying to create a pointer of " Ptr CUChar"
11:29:04 <joe____> ok, thanks guys. will give it a shot.
11:29:06 <Cale> joe____: Is there a function which specifically takes a Ptr of that type?
11:29:21 <ivanm> using <code> ... </code> doesn't take indentation into account... :@
11:29:23 <Cale> joe____: You don't need to give a type signature if the type of pointer to create can be inferred
11:29:38 <ivanm> preflex: seen dons
11:29:39 <preflex>  dons was last seen on #haskell 3 hours, 8 minutes and 34 seconds ago, saying: very odd
11:30:48 <joe____> Cale, yes.
11:31:38 <monochrom> monomorphism restriction sometimes leads to needing type annotations.  "x = malloc" is an example.
11:35:42 <aavogt> shouldn't the monomorphism restriction actually be called a polymorphism restriction, since that's what it is restricting?
11:36:13 <monochrom> The English Literature people are still arguing over this. :)
11:38:04 <tensorpudding> also known as pedants
11:39:02 <aavogt> I think the naming is more to get people to hate monomorphism
11:39:18 <aavogt> if they see eew, polymorphism restriction
11:39:59 <aavogt> then they are going to say solution: remove polymorphism.... the way we have it doesn't let people blame polymorphism as easily
11:40:35 <amz> "restricting x" vs "restricting to x", I guess
11:40:47 <aavogt> so pedants like pedantry
11:41:04 <tensorpudding> they don't like pedarasty though
11:41:07 <monochrom> pastes like pastry
11:41:15 <ddarius> tensorpudding: They might.
11:41:33 <copumpkin> pedantic pederast pediatricians?
11:41:39 <tensorpudding> only in a way unrelated to being a pedant i hope
11:43:04 <Acedio> Weird, I'm getting an "illegal operation (not a binary handle)" when trying to write to a file using Data.ByteString.Char8.writeFile.
11:43:09 <tensorpudding> every now and then idiots confuse pedophiles with pediatricians and do stupid things
11:43:29 <Acedio> Even when I switch over, trying to write to stdout with hPut, it gives the error.
11:45:16 <paul424> who use the cabal packager ?
11:45:22 <paul424>  I need help
11:48:01 <ivanm> paul424: you mean cabal-the-library or cabal-install ?
11:48:45 <nominolo> Acedio: use hPutStr
11:49:39 <paul424> ivanm: the cabal install .. I just get the dep I don't understand : it ask for glib >=0.10, but on hackage.db there is none which would suit it ....
11:49:50 <ivanm> paul424: you need gtk2hs
11:49:54 <ivanm> it isn't available off hackage
11:49:55 <Acedio> nominolo: No dice :( I think hPutStr is a synonym for hPut.
11:50:17 <aavogt> @hoogle hPut
11:50:17 <lambdabot> Data.ByteString hPut :: Handle -> ByteString -> IO ()
11:50:17 <lambdabot> Data.ByteString.Char8 hPut :: Handle -> ByteString -> IO ()
11:50:17 <lambdabot> Data.ByteString.Lazy hPut :: Handle -> ByteString -> IO ()
11:50:37 <nominolo> Acedio: ok, so I believe stdout by default is opened in text mode, not in binary mode
11:50:50 <nominolo> there's some way to change that, but i don't know that OTTOH
11:50:52 <monochrom> strange, ghc 6.10.4 binary tarball comes with both base-3 and base-4 ?
11:50:58 <ivanm> is it just me, or is planet.haskell dead?
11:51:05 <Acedio> Ahh, I'll give it a look. Thanks nominolo :)
11:51:11 <aavogt> it does that
11:51:15 <ivanm> it says it was last updated 2 days ago...
11:51:23 <ivanm> monochrom: yes
11:51:30 <ivanm> monochrom: it's taken you this long to realise that? >_>
11:51:48 <ivanm> monochrom: 6.12 will also come with 3 and 4, but its base-3 will spit out deprecation notices if used
11:51:51 <monochrom> it took me this long minus 24 hours to decide to install 6.10.4
11:51:55 <ivanm> :o
11:51:57 <ivanm> monochrom: how come?
11:52:11 <monochrom> because there has been no need
11:52:21 <ddarius> If you're happy with your current install, why bother upgrading?
11:52:26 <ivanm> except MOAR AWESOME (dammit, I'm channeling copumpkin again!)?
11:52:29 <nominolo> ivanm: planet.haskell works for me
11:52:30 * ddarius has GHC 6.10.1
11:52:36 <copumpkin> MOAR AWESOME
11:52:38 <ivanm> main difference between 3 and 4 is the extensible exceptions, which is available with a compatability package...
11:52:52 <monochrom> Just for moar awesome, in short.
11:53:05 <paul424> ivanm: I have installed that ...
11:53:14 <ivanm> nominolo: just looks like it hasn't been updated (or is sigfpe's post really the latest haskellian one?)
11:53:30 <paul424> trhought the ubuntu repository than converted it by alien to my tgz slackware format
11:53:38 <ivanm> paul424: then it should be there
11:53:48 <ivanm> monochrom: ghc-pkg list | grep -i glib
11:53:50 <nominolo> ivanm: it marks post as new if the author edits them.  maybe Dan is just updating his post a lot
11:53:58 <ivanm> nominolo: ahhhh
11:54:08 <ivanm> paul424: note that it needs gtk2hs >= 0.10 ...
11:55:04 <monochrom> ghc-pkg list | grep -i glib  is emptyness
11:55:36 <ivanm> monochrom: whoops, that was meant tof paul424
11:55:42 <ivanm> paul424: ghc-pkg list | grep -i glib
11:56:05 <paul424> its from : https://launchpad.net/ubuntu/+source/gtk2hs/0.10.1-3ubuntu2/+build/1320224
11:56:49 <paul424> ivanm: there's none .. only some bindings to it
11:57:02 <ivanm> hmmmm?
11:57:30 <ivanm> you need the libghc6-glib-dev package that's on that page
12:00:48 <paul424> ivanm: strange enough .... hmm
12:04:05 <monochrom> 6.10.4 has utf8 I/O and type families. it is moar awesome. maybe I will use them.
12:04:32 <paul424> ivanm: its installed in /usr/lib/haskell-packages/ghc6/lib/glib-0.10.1
12:04:43 <paul424> ivanm: what is the proper path for those packages ?
12:04:58 <ivanm> monochrom: it has utf8 IO? you sure?
12:05:08 <ivanm> 6.12 will have locale-based IO, otherwise AFAIK you have to use utf8-string
12:05:20 <ivanm> paul424: doesn't matter, as long as ghc-pkg knows where they are
12:05:26 <monochrom> Oh oops, you are right.
12:05:37 <paul424> ivanm: yeah but seems it doesn't
12:05:43 <paul424> what 's its config file ?
12:06:19 <ivanm>  /usr/lib/ghc-<version>/package.conf
12:06:23 <ivanm> but you shouldn't edit that by hand
12:06:34 <ivanm> paul424: I'm guessing that the package is for a different version of ghc than what you have
12:06:40 <paul424> so how to add those libs
12:06:46 <paul424> ivanm: yeah probably
12:06:51 <phr> does Text replace utf8-string more or less?
12:07:17 <ivanm> paul424: *shrug* I don't use ubuntu
12:07:22 <ivanm> phr: don't think so
12:07:35 <ivanm> phr: but I could be wrong
12:07:44 <paul424> no to add them to ghc-pkg database
12:08:11 <ivanm> paul424: it's a PITA to do it manually
12:08:22 <ivanm> you want ghc-pkg register
12:08:28 <ivanm> paul424: ghc-pkg help
12:09:33 <paul424> Expose the specified package. / what does it mean ?
12:09:42 <ivanm> not what you want
12:09:44 <ivanm> you want register
12:11:42 <paul424> yeah I know just wondersing ... anyway the package is the directory or the .a library or what , ivanm ?
12:12:08 <ivanm> Cabal format
12:12:21 <ivanm> as I said, you probably don't want to do it by hand
12:12:39 <ivanm> paul424: go to the ghc users guide and look up its documentation on ghc-pkg
12:13:02 <paul424> oh I found it the register needs the confiig files :)
12:13:37 <ivanm> yup
12:14:01 <ivanm> paul424: a proper install of gtk2hs will do this, but its installer is a tad buggy (because it tries to use ghc-pkg directly rather than using cabal)
12:14:31 <ivanm> paul424: which version of ubuntu are you using (and are you using a system ghc or did you install it by hand)?
12:15:13 <paul424> ORGH i told you ... I use slackware... but lack of package + fail with compilation made me downloading those packages
12:15:23 <paul424> I converted them
12:15:31 <ivanm> did you? don't recall you saying that...
12:15:42 <ivanm> paul424: that's bad
12:15:54 <ivanm> for GHC stuff, you really need to compile it for that specific version of ghc
12:16:31 <paul424> hmm so I will just look for the packages in ubuntu with matching version, does it make sense ?
12:16:33 <ivanm> OK, missed where you said you were using slackware
12:16:37 <ivanm> paul424: no
12:17:03 <ivanm> you'd be better off getting the source tarball and compiling it by hand
12:18:24 <HaskellLove> I am reading book on Ocaml. Someone interested to give me some comments how Ocaml influenced Scala and any other related Scala/Ocaml/Functional programming topics?
12:18:30 <monochrom> this would mean downloading lots of "xyz-dev" packages.
12:19:22 <copumpkin> Ocaml mostly influenced F#
12:19:25 <monochrom> Miranda influenced Haskell.
12:19:28 <copumpkin> in fact, F# is almost a superset of ocaml
12:19:28 <ivanm> yeah
12:19:41 <ivanm> but wikipedia says that ocaml influenced scala...
12:19:45 <tensorpudding> Haskell derived from Miranda, which derived heavily from older functional languages, including ML
12:19:47 <ivanm> and of course wikipedia is _never_ wrong!
12:19:47 <monochrom> That is the only story I can tell you in #haskell legally.
12:20:06 <ivanm> monochrom: because of legal restrictions or because people would hit you? :p
12:20:11 <tensorpudding> but ML was strict, whereas Miranda was lazy
12:20:21 <monochrom> perhaps illegal restrictions too <duck>
12:21:02 <sohum> how do you tie together the version in your cabal file and the version that you output on -v?
12:21:05 <sohum> manually?
12:21:25 <ivanm> sohum: use the paths module
12:21:29 <ivanm> sohum: xmonad does this IIRC
12:22:12 <sohum> ivanm: GHC.Paths?
12:22:15 <tensorpudding> miranda derived from SASL and KRC
12:22:16 <ivanm> nope
12:22:22 <ivanm> Paths_<package name>
12:22:32 <ivanm> sohum: it's in the Cabal documentation
12:22:44 <sohum> ivanm: ah. thanks!
12:22:52 <ivanm> no worries
12:23:20 <HaskellLove> copumpkin well yeah F# is a dialect of OCaml
12:23:29 <ivanm> sohum: note that if you want to load the module that does call Paths_foo in ghci, you have to start ghci with -idist/build/autogen
12:23:35 <ivanm> HaskellLove: not really...
12:24:47 <HaskellLove> ivanm blame wikipedia man
12:25:11 <ivanm> wikipedia says it is? then it _must_ be! ;-)
12:25:22 <ivanm> HaskellLove: well, depends on how you define dialect I suppose
12:25:35 <aavogt> is dutch a dialect of german?
12:25:47 <aavogt> is english a dialect of german?
12:25:53 <aavogt> how far do you want to go?
12:26:03 <HaskellLove> i see your point
12:26:19 <aavogt> note that none of those qualify as dialects
12:26:25 <aavogt> at least in my opinion
12:26:40 <ivanm> O'Haskell, etc. are arguably dialects of Haskell, but IIUC, F# isn't that close in syntax terms
12:27:12 <aavogt> ivanm: that is something different from OOHaskell which is purely a library thing?
12:28:34 <kmc> ML is strict, but Lazy ML is lazy
12:29:23 <tensorpudding> i like lazy
12:29:31 <tensorpudding> lazy reminds me of those lazy rivers
12:29:42 <sohum> ivanm: so wait, .cabal files can run haskell code?
12:30:17 <paul424> ivanm: just what guarantee I have that it won;'t fail ?
12:30:57 <aavogt> sohum: no, but the syntax is sort of similar
12:31:14 <aavogt> also Setup.lhs can do arbitrary haskell stuff
12:32:48 <sohum> aavogt: basically I just want the version specified in .cabal and the version output by -v to match. Paths_foo gets me access to a datafile for the latter, but how would you do that for the former?
12:33:32 <aavogt> sohum: for the package being specified in the cabal fine?
12:33:34 <aavogt> file
12:33:41 <sohum> aavogt: yea/
12:34:02 <aavogt> the one in Paths_foo is generated from the .cabal file version info
12:34:28 <aavogt> if you update the latter, the former will follow suit
12:34:59 <sohum> aavogt: so it defines things other than getPackageFileName?
12:35:15 <paul424> ohh i finally found it ... I use the verison 6.10.4 while the gtk2hs supports only 6.10.1
12:35:18 <paul424> ghosh
12:35:41 <sohum> @hoogle getPackageFileName
12:35:41 <lambdabot> No results found
12:36:19 <sohum> @hoogle Paths_
12:36:19 <lambdabot> No results found
12:36:23 <sohum> @hoogle Paths
12:36:23 <lambdabot> System.FilePath.Posix pathSeparator :: Char
12:36:23 <lambdabot> System.FilePath.Windows pathSeparator :: Char
12:36:23 <lambdabot> System.FilePath.Posix pathSeparators :: [Char]
12:40:26 <sohum> oh, I see
12:40:41 <sohum> for future reference, http://old.nabble.com/get-cabal-info-for-self--td24437017.html
12:42:52 <manju> http://shootout.alioth.debian.org/u64q/benchmark.php?test=knucleotide&lang=all&box=1
12:43:14 <manju> why does haskell have such insane timing in thie benchmark ?
12:46:11 <holmak> wow, the top C++ solution is completely ridiculous
12:46:23 <holmak> uses some kind of template-based hashing?
12:47:00 <monochrom> next time it will be template-based primality testing
12:47:01 <sproingie> template metaprogramming?
12:47:09 <sproingie> they better have included the compile time in the runtime
12:47:26 <manju> I am amazed the compiler can parse that :-)
12:47:42 <holmak> I certainly can't :D
12:47:46 <manju> sproingie, they did
12:47:57 <manju> sproingie, 7.02s to complete and log all make actions
12:48:08 <manju> 7 secs is not bad
12:48:15 <holmak> they didn't include it then, they list the run time as 5 seconds
12:48:45 <sproingie> damn interesting code
12:49:03 <holmak> the shootout definitely has interesting code
12:49:24 <holmak> the things people do to C++ to make it fast melt my eyes
12:50:30 <manju> holmak, I don't know about this benchmark, which is supposed to be just fast, but even in real-life we've optimized the hell out of code
12:50:45 <sproingie> java's performance is pretty impressive there too
12:50:54 <kmc> is agda on shootout yet?
12:51:02 <manju> we wrote some code to do software compositing in real-time, which had to be hand optimized using assembly
12:51:19 <manju> sproingie, but haskell seems to be winning against scala
12:52:43 <sproingie> the cpu utilization for the haskell code is pretty meh
12:53:04 <sproingie> then again ATS did it nice and fast on just one cpu
12:54:20 <manju> is ATS a language ?
12:54:34 <sproingie> apparently.  ugly as sin too.
12:55:02 <paul424> whats the diffrence between this packages http://haskell.org/ghc/dist/6.10.1/ ?
12:55:07 <manju> I can see that
12:55:40 <sohum> hm. hackage doesn't have cabal 1.7.3?
12:55:54 <manju> if Ocaml and C++ had a baby it would look like ATS
12:56:07 <artagnon> Has anyone been to Microsoft Research Cambridge to work on GHC? I'm referring to the ad here: http://hackage.haskell.org/trac/ghc/wiki/Internships
12:56:18 <monkfish> whats wrong with this: data Tree = Leaf a | Branch a [Tree]
12:56:27 <monkfish> i thought to be polymorphic it had to be lowercased?
12:56:47 <sohum> monkfish: a doesn't have a context -- it isn't defined anywhere
12:57:04 <sohum> monkfish: you want data Tree a = Leaf a | Branch a [Tree a]
12:57:32 <sohum> monkfish: "defined", loosely using that word
12:57:32 <sproingie> to be a type variable it has to be lowercase
12:57:38 <monkfish> thanks guys i forgot that detail
12:58:23 <paul424> ivanm: ? one source is 7 MB and second 70 MB ... that does not make sense ..
13:04:21 <sohum> ...what
13:04:51 <sohum> "hs-source-dir is deprecated, please use hs-source-dirs". "Unknown fields: hs-source-dirs".
13:05:58 <sohum> oh, you need to put it under the executable
13:09:44 <sohum> @hoogle exitWith
13:09:44 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
13:16:12 <sohum> is there a way to not warn on an unspecified record field?
13:17:39 <sohum> :t id *** getContents
13:17:40 <lambdabot>     Couldn't match expected type `b' -> c''
13:17:40 <lambdabot>            against inferred type `IO String'
13:17:40 <lambdabot>     In the second argument of `(***)', namely `getContents'
13:17:45 <sohum> :t id &&& getContents
13:17:46 <lambdabot>     Couldn't match expected type `b -> c''
13:17:47 <lambdabot>            against inferred type `IO String'
13:17:47 <lambdabot>     In the second argument of `(&&&)', namely `getContents'
13:17:51 <HaskellLove> what is difference in writing compilers for imperative vs functional languages? and what are the chalenges you face to combine both?
13:18:04 <copumpkin> it's generally a lot harder for functional languages
13:18:14 <copumpkin> because the imperative paradigm is a lot closer to the underlying machine's model
13:18:21 <copumpkin> unless you're on an esoteric machine
13:18:45 <ohday> Is haskell a higher level language than C?
13:19:00 <copumpkin> they're almost opposite ends of the spectrum
13:19:12 <copumpkin> although C is often characterized as lower-level than it is
13:19:59 <sohum> :t getContents
13:20:00 <lambdabot> IO String
13:20:05 <sohum> ...oh.
13:20:19 <copumpkin> sohum: what are you trying to do?
13:22:20 <sohum> copumpkin: I thought getContents was readFile. I'm an idiot.
13:22:25 <sohum> :t id &&& readFile
13:22:26 <lambdabot> FilePath -> (FilePath, IO String)
13:22:42 <copumpkin> :t strength . (id &&& readFile)
13:22:42 <lambdabot> FilePath -> IO (FilePath, String)
13:23:28 <sohum> strength?
13:23:34 <copumpkin> :t strength
13:23:34 <grant__> Can someone tell me why http://haskell.pastebin.com/m26d5c8ed doesn't work? I'm guessing I need a forall or something.
13:23:34 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => (a1, f a) -> f (a1, a)
13:23:43 <copumpkin> > strength (1, [1..5])
13:23:44 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5)]
13:23:51 <sohum> why specifically for the second?
13:24:09 <sohum> @hooglee (f a, b) -> f (a, b)
13:24:09 <lambdabot> Maybe you meant: hoogle hoogle+
13:24:14 <sohum> @hoogle (f a, b) -> f (a, b)
13:24:14 <lambdabot> No results found
13:24:16 <copumpkin> sohum: doesn't have to be, but the second one tends to get more love
13:24:34 <HaskellLove> so if someone wants to combine a func and imperative in one what must he watch out in the first stage of bnf specification?
13:25:08 <copumpkin> > strength1 ([1..5], 1)
13:25:09 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5)]
13:25:14 <copumpkin> whoops, did it backwards :)
13:25:25 <sohum> @hoogle strength
13:25:26 <lambdabot> No results found
13:25:37 <Gracenotes> sohum: if it's a functor, blah (fa, b) = fmap (flip (,) b) fa
13:25:40 <sohum> @where strength
13:25:40 <lambdabot> I know nothing about strength.
13:25:44 <copumpkin> HaskellLove: bnf is just about syntax, and that is mostly arbitrary
13:25:54 <sproingie> @hoogle strength1
13:25:55 <lambdabot> No results found
13:26:13 <copumpkin> sohum: there's also (f a, f b) -> f (a, b) if you have an applicative :)
13:26:15 * sproingie Ô.o
13:26:31 <copumpkin> :t uncurry (liftA2 (,))
13:26:32 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
13:26:41 <copumpkin> :t uncurry (fmap . (,))
13:26:42 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
13:26:45 <Gracenotes> @pl \(fa, b) -> fmap (flip (,) b) fa
13:26:45 <lambdabot> uncurry (flip (fmap . flip (,)))
13:26:48 <sohum> aah/
13:26:57 <sohum> why "strength"?
13:27:05 <Gracenotes> hm. that's a more elegant way of putting it.
13:27:11 <Gracenotes> *cough* *pl*
13:28:46 <Gracenotes> although @pl's purpose is not exactly to produce elegant code. I suppose it evolved, by demand, to have behavior more along those lines
13:29:12 <tensorpudding> i don't like that output from @pl there
13:29:21 <Gracenotes> ...not like I'm going to do an anthropological study on it...
13:29:32 <tensorpudding> more than one flip, plus uncurry, seems a bit pushing it
13:29:55 <Gracenotes> the flips cancel each other out, toofmap . (,)
13:29:58 <Gracenotes> oops.
13:30:07 <Gracenotes> let me try a less forced version
13:30:08 * copumpkin maps his toofs
13:30:36 <Gracenotes> @pl \(fa, b) -> fmap (\a -> (a, b)) fa
13:30:37 <lambdabot> uncurry (flip (fmap . flip (,)))
13:30:42 <Gracenotes> meh.
13:31:06 <Gracenotes> copumpkin: invisibl word boundry ==^.^==
13:31:35 <sohum> @pl \a o -> return o { k = f a }
13:31:36 <sproingie> i am so going to define a ==^.^== operator
13:31:36 <lambdabot> (line 1, column 18):
13:31:36 <lambdabot> unexpected "{"
13:31:36 <lambdabot> expecting variable, "(", operator or end of input
13:31:51 <sohum> grr record update
13:34:55 <sohum> @pl \a o -> return $ f o (g a)
13:34:56 <lambdabot> (return .) . flip f . g
13:34:58 <copumpkin> sohum: not really sure. an Applicative is called a strong lax monoidal functor precisely because it can do what I did with it above, and a strong monad is something that can do what strength does to functors in haskell. I guess a strong functor is an extension of that idea
13:35:18 <sohum> @pl \a o -> return $ f (g a) o
13:35:18 <lambdabot> (return .) . f . g
13:35:21 <grant__> why can't I say this?:    show (if True then "baz" else 2)
13:35:22 <copumpkin> and "all functors in haskell are strong", apparently
13:35:27 <copumpkin> so all monads are too
13:35:39 <copumpkin> not really sure what the logic is behind that naming though :)
13:35:48 <copumpkin> grant__: what would the type of that expression be?
13:35:56 <grant__> String
13:35:59 <copumpkin> grant__: you actually can say that, but it won't do what you hope
13:36:07 <copumpkin> :t if True then "baz" else 2
13:36:08 <lambdabot>     No instance for (Num [Char])
13:36:08 <lambdabot>       arising from the literal `2' at <interactive>:1:24
13:36:08 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
13:36:16 <copumpkin> it's not fundamentally illegal
13:36:26 <jmcarthur> if you define instance Num String
13:36:30 <copumpkin> grant__: the typechecker doesn't care that you have a constant in there
13:36:55 <kmc> grant__, both branches of an "if" must have the same type, always
13:37:09 <jmcarthur> fortunately, 5 has type String
13:37:23 <copumpkin> http://snapplr.com/3pw7 isn't a good sign
13:37:42 <grant__> kmc: I was hoping it would treat each branch as an instance of Show
13:37:57 <copumpkin> when John Baez doesn't know what a categorical construct is good for, you should be scared
13:38:04 <kmc> > if True then show "baz" else show 2
13:38:05 <lambdabot>   "\"baz\""
13:38:12 <copumpkin> but in practice I actually use strength quite a lot in haskell :)
13:38:23 <jmcarthur> grant__: both branches are instances of Show, but if requires they be the exact same concrete type, not just two types that share an instance
13:38:25 <sohum> @where (&&&)
13:38:26 <lambdabot> I know nothing about (&&&).
13:38:28 <jmcarthur> *ir
13:38:30 <jmcarthur> **it
13:38:32 <copumpkin> Control.Arrow
13:38:33 <sohum> @hoogle (&&&)
13:38:33 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
13:38:37 <sohum> danke
13:38:51 <kmc> > show (if True then ("baz" :: forall a. (Show a) => a) else (2 :: forall a. (Show a) => a))
13:38:52 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context (GHC.Show.Show a)
13:38:53 <lambdabot>    aris...
13:39:01 <copumpkin> :t (&&&) `asTypeIn` \(&&&) -> ((+1) &&&)
13:39:02 <kmc> > show (if True then ("baz" :: forall a. (Show a) => a) else (2 :: forall a. (Num a, Show a) => a))
13:39:02 <lambdabot> forall b c'. (Num b) => (b -> b) -> (b -> c') -> b -> (b, c')
13:39:03 <lambdabot>   Couldn't match expected type `a'
13:39:03 <lambdabot>         against inferred type `[GHC.Types....
13:39:07 <sohum> @hoogle fmap
13:39:07 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:39:07 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
13:39:07 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
13:39:25 <jmcarthur> kmc: that will never work. it has no idea what instance of Show to use
13:40:00 <grant__> I see, it has too pick an instance at compile time
13:40:19 <elben> In Control.Monad.State, is runInterp a function? I can't seem to find the implementation in the haskell src
13:40:22 <kmc> jmcarthur, okay.  it  works with an existential datatype because the constructor captures the instance
13:40:24 <kmc> i see
13:40:48 <jmcarthur> data Showable = forall a . Show a => Showable a ; show (if True then Showable "baz" else Showable 5)
13:41:12 <kmc> jmcarthur, you also have to define "instance Show Showable"
13:41:15 <kmc> which is annoying boilerplate
13:41:21 <kmc> is it newtype-derivable?
13:41:29 <jmcarthur> doesn't matter
13:41:32 <kmc> elben, runInterp is not mentioned anywhere in the source to Control.Monad.State.Lazy i have
13:41:34 <jmcarthur> it's not a newtype
13:41:44 <kmc> it couldn't be?
13:41:47 <jmcarthur> no
13:41:55 <jmcarthur> existential quantification must be data
13:42:07 <kmc> because it can have hidden fields?
13:42:24 <jmcarthur> and it makes sense considering that the dictionary must be carried at runtime and newtype must be the same as the wrapped type
13:42:26 <elben> kmc: I meant runState, sorry
13:42:41 <jmcarthur> right
13:42:51 <kmc> elben, it's the name of the field in the State datatype
13:43:01 <kmc> newtype State s a = State { runState :: s -> (a, s) }
13:43:11 <kmc> thus runState :: State s a -> s -> (a, s)
13:43:36 <kmc> State is a record, runState is the accessor for its one and only field
13:43:37 <elben> but isn't that just the signature?
13:43:57 <kmc> elben, when you declare a record like that you get the field accessors for free
13:44:03 <jmcarthur> elben: the record syntax is kind of a shortcut for defining the function
13:44:11 <kmc> the idea is:  data Person = Person { height :: Float, name :: String }
13:44:22 <kmc> automatically defines height :: Person -> Float, and name :: Person -> String
13:44:23 <kmc> as functions
13:44:32 <kmc> in addition to defining the constructor Person :: Float -> String -> Person
13:44:33 <sohum> @pl \(a,b) g a b
13:44:33 <lambdabot> (line 1, column 13):
13:44:33 <lambdabot> unexpected end of input
13:44:33 <lambdabot> expecting pattern or "->"
13:44:36 <kmc> (this is one of my complaints with records... the signature within the record declaration is a lie)
13:44:39 <sohum> @pl \(a,b) -> g a b
13:44:39 <lambdabot> uncurry g
13:44:43 <sohum> duh.
13:45:20 <elben> kmc: i see.. thanks
13:45:59 <kmc> i'd rather they'd just said:  newtype State s a = State (s -> (a, s));  runState :: State s a -> s -> (a, s);  runState (State f) = f
13:46:22 <elben> make it more explicit huh
13:46:40 <elben> i'm new to haskell, and that really confused me
13:47:28 <kmc> it confused me when i was beginning haskell
13:48:27 <sohum> @hoogle (Either a b) -> (a -> c) -> (b -> c) -> c
13:48:27 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
13:48:27 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
13:48:33 <kmc> the sole purpose of records is to give nicer syntax to things which can also be accomplished by other means
13:48:36 <kmc> i think the syntax is not nicer
13:48:44 <kmc> so i think the feature is dubious
13:49:01 <jmcarthur> there are good uses for record syntax... but not many
13:49:24 <jmcarthur> xmonad uses it to good effect for configuration, for example
13:49:35 <fracture> is there an easy way to copy a record changing only one element without record syntax?
13:49:51 <fracture> like let newrec = myrec { mrSomeElement = 12 }
13:49:54 <jmcarthur> and i personally like the, perhaps unintuitive, trick to get free projections via record syntax
13:49:56 <sohum> @pl \a b -> f (g a b)
13:49:57 <lambdabot> (f .) . g
13:50:06 <sohum> @pl \a b -> f (g a b) h i
13:50:06 <lambdabot> flip flip i . flip flip h . (f .) . g
13:50:13 <jmcarthur> fracture: that is the only way i know of
13:50:49 <jmcarthur> fracture: i personally prefer to avoid large flat data structures though, so it's usually not that big a deal for me to write out the updater explicitly
13:51:08 <sohum> @pl \a b -> f g h (i a b)
13:51:09 <lambdabot> (f g h .) . i
13:51:14 <sohum> oh, right
13:52:08 <sproingie> pattern matching on records is pretty handy, but unfortunately none of it is polymorphic
13:53:10 <sproingie> can't share labels, the accessor can't be computed from other fields, etc
13:53:27 <copumpkin> fc-labels might help that
13:53:29 <kmc> perhaps the feature is a success in that it annoys people enough to think harder about it
13:53:33 <kmc> and come up with things like fclabels
13:53:38 <sproingie> it's still nice syntax sugar when you have 20 labels in a record
13:53:40 <copumpkin> can't remember if you can have polymorphic label matching there
13:55:18 <toast-opt> :t f g h . (. i)
13:55:19 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
13:55:19 <lambdabot>     In the second argument of `(.)', namely `i'
13:55:19 <lambdabot>     In the second argument of `(.)', namely `(. i)'
13:55:39 <sproingie> view patterns kind of help there
13:55:42 <ivanm> toast-opt: it doesn't know what f g h and i are
13:55:54 <toast-opt> ivanm, thx, i gathered.
13:56:04 <ivanm> @type \f g h -> f g h . (. i)
13:56:05 <sproingie> tho view patterns are a bit nasty looking to compose ad-hoc
13:56:05 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
13:56:05 <lambdabot>     In the second argument of `(.)', namely `i'
13:56:05 <lambdabot>     In the second argument of `(.)', namely `(. i)'
13:56:14 <ivanm> bah
13:56:21 <ivanm> @type \f g h i -> f g h . (. i)
13:56:22 <lambdabot> forall t t1 b a b1 (f :: * -> *). (Functor f) => (t -> t1 -> f b1 -> b) -> t -> t1 -> f a -> (a -> b1) -> b
13:56:26 <ivanm> @slap Cale
13:56:26 * lambdabot clobbers Cale with an untyped language
13:57:27 <copumpkin> I support (++) = mappend
13:58:25 <dibblego> (.) = fmap?
13:58:46 <copumpkin> yep
13:58:59 <copumpkin> and flip = scary
13:59:01 <copumpkin> :t flip
13:59:02 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:59:20 <copumpkin> > flip (Just (+1)) 5
13:59:21 <lambdabot>   Just 6
14:00:24 <ivanm> dibblego: did you see the pythonic approach to parser combinators on reddit the other day?
14:00:30 <dibblego> no
14:00:35 <ivanm> http://codepad.org/9HGWo3GR
14:00:54 <toast-opt> ivanm, that was a hilarious read, thx for sharing :)
14:01:08 <sproingie> egad
14:01:18 <ivanm> heh
14:01:27 <sproingie> looks like habnabit's code
14:01:38 <sproingie> he has a one-liner python chat server
14:01:45 <sproingie> lots of lambda
14:02:13 <sproingie> no evals except one little part it needs to bootstrap
14:08:21 <sohum> :t (.) ((.) (either error (return . show)))
14:08:22 <lambdabot> forall (m :: * -> *) b (f :: * -> *) (f1 :: * -> *). (Monad m, Show b, Functor f, Functor f1) => f1 (f (Either [Char] b)) -> f1 (f (m String))
14:08:40 <Bobrobyn> Hey guys.  As a C programmer who wants to learn Haskell, would the "Write Yourself a Scheme in 48 Hours" tutorial be a terrible idea...or is it realistic?
14:08:43 <sohum> :t (Prelude..) ((Prelude..) (either error (return Prelude.. show)))
14:08:44 <lambdabot> forall (m :: * -> *) b a a1. (Monad m, Show b) => (a1 -> a -> Either [Char] b) -> a1 -> a -> m String
14:09:33 <tensorpudding> Bobrobyn: it's a bit ambitious for the first thing you do, maybe
14:10:25 <Bobrobyn> lol.  It's a tutorial which is mean to teach you Haskell by getting you to write a Scheme compiler, tutorial.
14:10:31 <Bobrobyn> *mean = meant
14:11:11 <manju> ok I officially have contracted haskell madness
14:11:21 <manju> prime n = [2] ++ [ x | x <- [2..n], odd x, (\x -> [n | n <- [2..(round (sqrt (fromInteger x)))], x `mod` n == 0] == []) x ]
14:11:21 <godfreyhk> does a -> a -> a means (a->a) -> a or a -> (a->a)?
14:11:23 <tensorpudding> well, i was under the impression that it was not as easy of a first experience with haskell
14:11:27 <toast-opt> bobrobyn, wait -- it gets you to write a tutorial on scheme compilers?
14:11:31 <manju> > prime n = [2] ++ [ x | x <- [2..n], odd x, (\x -> [n | n <- [2..(round (sqrt (fromInteger x)))], x `mod` n == 0] == []) x ] in prime 10
14:11:32 <lambdabot>   <no location info>: parse error on input `='
14:11:40 <manju> argh or not
14:11:48 <tensorpudding> if you have no experience with functional programming, haskell will be very different to what you are used to
14:11:49 <manju> hang on, it works shere
14:11:54 <toast-opt> godfreyhk - right associative, so a->(a->a)
14:12:00 <pikhq> Bobrobyn: ... 48 hours is not enough to get over the initial mind-breaking of even purely functional programming...
14:12:04 <Bobrobyn> toast-opt, No, I'm an idiot at explaining things.  It gets you to write an actual Scheme compiler.
14:12:05 <godfreyhk> okay thanks
14:12:08 <manju> > let prime n = [2] ++ [ x | x <- [2..n], odd x, (\x -> [n | n <- [2..(round (sqrt (fromInteger x)))], x `mod` n == 0] == []) x ] in prime 10
14:12:08 <sohum> :t (Prelude..) ((Prelude..) (either error (return Prelude.. show))) (undefined :: (String,String) -> a)
14:12:08 * toast-opt read as 'function taking a and a producing a'
14:12:09 <lambdabot>   [2,3,5,7]
14:12:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => (String, String) -> a -> m String
14:12:16 <manju> haha
14:12:19 <pikhq> Much less the type system or, say, functors, monoids, monads, etc.
14:12:45 <tensorpudding> you'll want to supplement it
14:12:47 <toast-opt> bobrobyn, darn.  i thought it would be funny if it taught you haskell by having you write tutorials about writing things in haskell
14:12:58 <toast-opt> literate tutorials?
14:13:08 <Bobrobyn> Lol
14:13:11 <Bobrobyn> Yeah, that would be funny
14:13:12 <godfreyhk> any example of (a->a)->a then?
14:13:13 <godfreyhk> say
14:13:16 <tensorpudding> real world haskell is considered an okay book for people who have programming experience
14:13:19 <godfreyhk> (Int->Int)->Int
14:13:25 <Bobrobyn> Cool
14:13:34 <tensorpudding> but not necessarily any familiarity with functional paradigms
14:14:00 <tensorpudding> it has some asides written for people who are used to Java/C++
14:14:05 <Bobrobyn> Any suggestions for someone that hasn't done functional programming before, but know Ruby, Python, Java, and C?  (C being my personal favourite, as a weirdo)
14:14:34 <tensorpudding> like i said, RWH
14:14:39 <sproingie> LYAH is good
14:14:42 <tensorpudding> @where rwh
14:14:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:14:47 <pikhq> Bobrobyn: Real World Haskell, and I will note that you will soon come to despise all other languages.
14:14:51 <sproingie> RWH is kind of all over the place
14:14:59 <kmc> Bobrobyn, you can do functional programming in Ruby and Python
14:15:01 <tensorpudding> learn you a haskell is a pretty one
14:15:08 <kmc> you could start by learning the functional features of the languages you already know
14:15:10 <manju> Bobrobyn, I am using Hutton
14:15:11 <sproingie> i had a hard time following a lot of the basic stuff without the knowledge i already had
14:15:13 <kmc> as a sort of prelude to learning Haskell
14:15:22 <manju> Bobrobyn, I come from a C++ and Python background
14:15:22 <toast-opt> :t  \f -> \x -> f (f x)
14:15:23 <lambdabot> forall t. (t -> t) -> t -> t
14:15:26 <toast-opt> oops
14:15:33 <pikhq> kmc: You can do functional programming in C; it's just kinda hard.
14:15:46 <manju> Bobrobyn, and hutton is really very good for someone who doesn't know anything in functional programming
14:15:49 <kmc> pikhq, i agree.  but function pointers alone don't count; that's the hard part
14:15:51 <tensorpudding> C doesn't have first-order functions though
14:15:57 <sproingie> there's that cute blog post about how C is a pure functional language
14:15:58 <toast-opt> :t \f -> f (f 42)
14:15:59 <tensorpudding> err, first class*
14:15:59 <lambdabot> forall t. (Num t) => (t -> t) -> t
14:16:09 <pikhq> sproingie: Said blog post inspired me to learn Haskell.
14:16:15 <sproingie> it's a masterful reductio ad absurdum
14:16:19 <godfreyhk> thanks!
14:16:25 <tensorpudding> you can write it in a vaguely functional style though
14:16:42 <kmc> you have to build your own closures by hand.  same problem with C++'s "functors"
14:16:44 <sproingie> emphasis on vague
14:16:56 <tensorpudding> but most people would think you'd be nuts using recursion all over the place in C
14:17:02 <toast-opt> > let f g = g (g 42) in f (*2)
14:17:03 <lambdabot>   168
14:17:11 <tensorpudding> or avoiding using mutable variables
14:17:28 <toast-opt> i don't think that's useful, but it has type (a -> a) -> a, for Num a
14:18:01 <tensorpudding> you can't program generically in C
14:18:13 <godfreyhk> may i ask how would you comprehend that?
14:18:26 <godfreyhk> like if you have to read it out loud how would you say that
14:18:30 <pikhq> tensorpudding: Recursion isn't all *that* nuts in C; any compiler worth its salt will do tail call recursion right these days...
14:18:34 <Bobrobyn> Cool.  I'm inspired to learn Haskell because someone showed me a tic tac toe program in Haskell and went:  "Isn't that fudged up?"...and I agreed...but desired to understand.  Plus I need to learn functional programming someday anyways.
14:18:39 <toast-opt> tensorpudding, /you can't/it's difficult to/
14:18:57 <toast-opt> void* and void*(*)(void*,void*) can do many things
14:19:09 <tensorpudding> that looks abominable
14:19:11 <tensorpudding> and dangerous
14:19:15 <manju> can I have guards in lambda expressions ?
14:19:17 <pikhq> Also, yeah, you sure can program generically. You just have a *lot* of void pointers and a lot of function pointers going on.
14:19:25 <godfreyhk> ah I think I get it
14:19:53 <godfreyhk> it takes a function that transform a num to a num as argument and returns a num
14:19:54 <kmc> pikhq, that gives you an unsafe dynamic type system.  which could be considered an improvement over an unsafe static type system :)
14:20:02 <godfreyhk> well maybe return is not the word..
14:20:10 <godfreyhk> "gives"
14:20:11 <pikhq> kmc: Quite true.
14:20:13 <toast-opt> tensorpudding, it is, but it is something you can.
14:20:22 <tensorpudding> okay, that is fair
14:20:35 <tensorpudding> there are a lot of things that you can strictly do in C, I suppose
14:20:45 <toast-opt> it's like walking on the third rail.  you can do it.  just not for very long.
14:20:51 <tensorpudding> but which are probably not good ideas
14:21:11 <toast-opt> who ever said anything about good ideas?
14:21:21 <Berengal> There are a lot of things you can do in brainfuck too...
14:21:31 <Berengal> But you probably don't want to
14:21:32 <toast-opt> berengal, exactly!
14:22:03 <Bobrobyn> Lolcode is where it's at.
14:22:18 <Berengal> If you squint alot, gotos are like continuations...
14:22:23 <Berengal> But without the typesafety
14:22:40 <manju> map (\x -> [n | n <- [2..(round (sqrt (fromInteger x)))], x `mod` n == 0] == []) [2..]
14:22:49 <manju> this tells if a number is prime or not
14:22:50 <sproingie> can walk on the third rail all you want, long as you dont touch anything else
14:22:53 <Berengal> And without the first-class-ness
14:23:07 <manju> but I want it to return the number instead of true or false, possible to modify the above ?
14:23:34 * toast-opt saw this in the newsletter, on the topic of lolcode:  data CanHaz a = Haz a | ButIEatedIt
14:23:47 <monochrom> heh
14:23:50 <Lemmih> manju: Try 'filter' instead of 'map'.
14:24:05 <manju> Lemmih, thanks
14:24:28 <manju> wow...nice
14:24:56 <Bobrobyn> @ toast-opt, I lol'd at that :p
14:25:32 <toast-opt> bobrobyn, i vote that lolcode be repurposed as a repository of code in lol style
14:25:54 <toast-opt> really, its a coding convention, not a language
14:25:57 <sproingie> hasklol
14:26:13 <manju> sproingie, hehe
14:26:16 <tensorpudding> lolcaml!
14:27:05 <Bobrobyn> toast-opt, Hah ha.
14:30:09 <sohum> @pl \_ -> f (g . h)
14:30:09 <lambdabot> const (f (g . h))
14:30:41 <sohum> @test f . g . h == f (g . h)
14:30:41 <lambdabot> Maybe you meant: let list tell
14:30:50 <sohum> @check f . g . h == f (g . h)
14:30:51 <lambdabot>   No instance for (GHC.Classes.Eq (a -> c))
14:30:51 <lambdabot>    arising from a use of `GHC.Cla...
14:34:14 <appleboy> when does binding between identifiers and their type happen?
14:34:21 <appleboy> is it compile time?
14:34:28 <ezyang> appleboy: correct.
14:34:55 <appleboy> thanks
14:35:20 * ezyang thinks "Things that are not the same: appleboy; apple kid" 
14:35:48 <appleboy> ?
14:36:11 <ezyang> It's an earthbound reference.
14:38:34 <Gracenotes> I am quite annoyed that this bag of Jolly Ranchers ended up containing only a single blue raspberry candy
14:40:27 <toast-opt> blue raspberry monad
14:40:36 <ddarius> First line of this paper: "Parser combinators [4 lines of cites]"
14:41:22 <sohum> :t fmap . (,)
14:41:23 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
14:41:53 <monochrom> hahaha
14:42:04 <sohum> :t fmap `asTypeIn` \fmap -> fmap (5,[3,2])
14:42:06 <lambdabot>     Couldn't match expected type `a -> b'
14:42:06 <lambdabot>            against inferred type `(t, [t1])'
14:42:06 <lambdabot>     In the first argument of `fmap', namely `(5, [3, 2])'
14:42:19 <ddarius> :t asTypeIn
14:42:20 <lambdabot> forall a b. a -> (a -> b) -> a
14:42:23 <sohum> :t fmap `asTypeIn` \fmap -> fmap 5 [3,2]
14:42:24 <lambdabot> forall a b. (Num (a -> b), Num a) => (a -> b) -> [a] -> [b]
14:43:58 <sohum> :t fmap `asTypeIn` \fmap -> fmap id [3,2]
14:43:58 <lambdabot> forall a. (Num a) => (a -> a) -> [a] -> [a]
14:43:58 <sohum> :t fmap `asTypeIn` \fmap -> fmap id (3,2)
14:43:58 <lambdabot> forall a t. (Num t, Num a) => (a -> a) -> (t, a) -> (t, a)
14:43:58 <sohum> oh, I see
14:45:14 <sohum> :t foldl1
14:45:15 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:45:39 <sohum> @pl \a b -> a ++ '.':b
14:45:39 <lambdabot> (. ('.' :)) . (++)
14:45:49 <sohum> @pl \a b -> b ++ '.':a
14:45:49 <lambdabot> flip (++) . ('.' :)
14:46:03 <sohum> @hoogle intercalate
14:46:03 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
14:46:03 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
14:46:03 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
14:47:12 <sproingie> intercalate makes me think of intercal
14:49:00 <phr> lol
14:50:42 * BMeph made you an esoteric language, but intercalateit
14:50:58 <sohum> @pl \v -> i k  $ m s (b v)
14:50:58 <lambdabot> i k . m s . b
14:51:00 <SmurfOR> After reading about combinators in RWH I was wondering if anyone had some good resources with a more lengthy explanation and some more examples (I kind of get it but writing a combinator for the Iterator later in the chapter has me stuck).
14:52:20 <sohum> :t (->)
14:52:21 <lambdabot> parse error on input `->'
14:52:26 <sohum> :t (-->)
14:52:27 <lambdabot> parse error (possibly incorrect indentation)
14:52:55 <ezyang> SmurfOR: which chapter?
14:53:00 <sohum> -> reserved for sigs and - comments...
14:53:39 <Axman6> sohum: --> is a perfectly legal operator
14:54:14 <c_wraith> defining functions as const is fun.
14:54:21 <SmurfOR> ezrakilty, chapter9.  There's an exercise where you pretty much imitate a combinator you made earlier (which is dead easy).  I think the algebraic data type and how it's used has me a bit confused.
14:54:54 <SmurfOR> I'd just like to see some more simple examples really.
14:55:24 <Axman6> :t let f = const f in f
14:55:24 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
14:55:24 <lambdabot>     Probable cause: `const' is applied to too few arguments
14:55:24 <lambdabot>     In the expression: const f
14:55:41 <ezyang> SmurfOR: May I recommend Parsec to you?
14:56:17 <ezyang> it is "the" combinator library
14:57:00 <SmurfOR> ezyang, Are there any particular introductions to parsec you recommend?
14:57:18 <kmc> afaik there's no really precise definition of "combinator"
14:57:49 <ezyang> "oh hey, RWH has one..."
14:58:17 <ddarius> kmc: There are but not as used here.
15:00:01 <ezyang> I think parsec is one of those things that you really should go off and parse something with
15:00:08 <ezyang> On that note...
15:00:48 <ezyang> I recently converted a bunch of my code to Parsec-style, and in the process introduced some subtle breakage. The new code typechecks, and testing the parsers individually seems to work. How might I go about debugging this?
15:01:12 <ivanm> "parsec-style"?
15:01:18 <ivanm> how were you parsing it beforehand?
15:01:25 <ezyang> Read. :-D
15:01:31 <ivanm> ezyang: I prefer polyparse (not that I've actually used parsec...)
15:01:52 <ivanm> *shudder*
15:02:08 <ivanm> ezyang: that's the problem with monadic parsing IMHO, it's hard to track down the source of the error
15:02:39 <ezyang> yeah...
15:02:57 <ezyang> although I'm kind of hoping there's some technique that someone will show me and I'll be like OH COOL!
15:03:05 * ivanm first thought ezyang was telling him to read what he wrote, and looked back and forth through the chat history before he realised ezyang meant the Read class...
15:03:12 <sohum> Axman6: it is?
15:03:21 <ezyang> ivanm: Sorry 'bout that
15:03:36 <ivanm> heh, no worries
15:05:49 <Berengal> I've thought about implementing a new polyparse monad that keeps a stack trace of sorts...
15:12:39 <sohum> Baughn: haskell-mode isn't including -isrc for ghci :(. It was doing it, and then I changed some stuff in the .cabal file and now it's not anymore.
15:13:07 <sohum> Baughn: I could laboriously revert my changes and find out why, or I could read the source, but it's easiest to poke you :P
15:13:28 <ivanm> Berengal: there is a state-based polyparse monad...
15:13:37 <ivanm> so you could probably bastardise that...
15:13:53 <ivanm> sohum: ummm, hang on, let me check my settings
15:14:02 <ivanm> in custom-set-variables: '(haskell-program-name "ghci -idist/build/autogen")
15:14:59 <sohum> ivanm: how does that interact with one-of haskell files?
15:15:16 <ivanm> if dist/build/autogen doens't exist, it doesn't care
15:15:50 <sohum> ok,  fair enough
15:16:39 <sohum> it's not including -isrc either, though, now, which is weird.
15:16:54 <sohum> does it parse the cabal file to find the source-dirs?
15:25:34 <ivanm> sohum: nope
15:25:50 <ivanm> sohum: did you kill and then restart the ghci?
15:38:30 <ivanm> @. elite yow
15:38:30 <lambdabot> C0ulDn'T fIND phoRtUnE fil3
15:38:35 <ivanm> grrr...
15:38:50 <pastah_rhymez> anyone tried/using leksah?
15:39:06 * ivanm started it once, then went back to emacs
15:39:16 <pastah_rhymez> haha
15:39:21 <JohnDoe365> pastah_rhymez: me
15:39:44 <pastah_rhymez> JohnDoe365: is it nice?
15:39:50 <JohnDoe365> I would recommend it
15:39:55 <pastah_rhymez> cool
15:40:02 <JohnDoe365> compared to the eclipse plugin it's definitely more advanced
15:40:10 <pastah_rhymez> if i have 'case (e :: T) of'
15:40:18 <pastah_rhymez> can it insert all the instances of T then?
15:40:48 <kmc> ?
15:40:53 <kmc> i don't understand your question
15:40:54 <JohnDoe365> uhm ... you got me, I installed it just yesterday
15:41:07 <pastah_rhymez> so if i have case expression
15:41:10 <pastah_rhymez> say
15:41:21 <pastah_rhymez> case (x == y) of
15:41:37 <ivanm> oh, you want leksah to auto-fill the cases for you?
15:41:39 <pastah_rhymez> can i make it insert "True -> undefined; False -> undefined" for me?
15:41:39 <ivanm> I doubt it...
15:41:48 <ivanm> pastah_rhymez: consider a list; there's infinite possible options
15:42:01 <JohnDoe365> pastah_rhymez: It's helping out when dealing with the projects set up, dunno about that context information
15:42:30 <pastah_rhymez> ivanm: not really, you only go one level into your structure...
15:42:56 <sinelaw> ivanm, it would be either Cons or Nil
15:43:07 <sinelaw> no?
15:43:24 <ivanm> case list of [_,2,x] -> x
15:43:47 <pastah_rhymez> well, that i would write manually anyhow
15:43:48 <ivanm> pastah_rhymez: and I don't know how "aware" of your code leksah is to be able to do that...
15:44:11 <pastah_rhymez> but would want it to do "case list of; [] -> undefined; (x:xs) -> undefined"
15:44:34 <pastah_rhymez> ivanm: template haskell and stuff like that can probably solve it :{)
15:44:36 <pastah_rhymez> :)
15:44:58 <ivanm> maybe *shrug*
15:45:06 <ivanm> pastah_rhymez: ping the leksah developer...
15:45:23 * pastah_rhymez is doing darcs get on HEAD
15:47:00 <b6> what are the rules about using unicode characters in identifiers?
15:47:17 <ezyang> *mumble mumble* don't *mumble*
15:47:46 <kmc> b6, the Report defines the lexical structure of identifiers in terms of the Unicode character classes "lower case", "upper case", and "title case"
15:48:30 <b6> kmc: thanks, checking those definitions.
15:49:38 <ian__> length1 xs = [1 | _ <-xs] Am i making a syntax error with this line? ghci is giving me parse errors when I'm trying to take a few exapmles from learn you haskell and mess around with them
15:50:04 <pastah_rhymez> ezyang: it's you?
15:50:18 <ivanm> ezyang: heh
15:50:22 <b6> ian__: i think you need 'sum'.
15:50:38 <ivanm> ian__: looks OK to me; what's your type?
15:51:02 <ian__> a list i belive
15:51:18 <ian__> I havn't gotten to specifying types yet ha
15:55:47 <pastah_rhymez> i get this: It requires glib >=0.10
15:55:59 <pastah_rhymez> but i already have 'libglib2.0-dev' installed
15:56:19 <pastah_rhymez> what am i doing wrong?
15:56:33 <bfh6558> fucking haskell blows my mind the more i read into learnyouhaskell
15:56:45 <b6> pastah_rhymez: what are you trying to install?
15:56:46 <bfh6558> how old is this lanauge
15:56:49 <pastah_rhymez> bfh6558: which chapter are you an?
15:56:58 <pastah_rhymez> bfh6558: work began in 92 or something
15:57:08 <pastah_rhymez> bfh6558: first standard was in 98
15:57:12 <pastah_rhymez> b6: leksah
15:57:31 <bfh6558> just started 3 pastah_rhymez
15:57:50 <bfh6558> so ha not very far at all
15:57:57 <b6> pastah_rhymez: so can you cabal install glib?
15:58:39 <pastah_rhymez> b6: glib is a C library
15:58:44 <pastah_rhymez> isn't it?
15:58:56 <b6> pastah_rhymez: yes, but there's a haskell package that binds to it.
15:59:19 <pastah_rhymez> shouldn't cabals dependency solver fix that?
15:59:54 <b6> pastah_rhymez: yeah. i'm trying to get you to get closer to what the actual error is.
16:00:02 <pastah_rhymez> bfh6558: http://arcanux.org/lambdacats/brain.jpg
16:00:08 <ivanm> pastah_rhymez: gtk2hs
16:01:23 <pastah_rhymez> ivanm: there's like 8 packages on cabal
16:01:33 <pastah_rhymez> *hackage
16:02:10 <bfh6558> hahaha
16:02:24 <pastah_rhymez> cabal: cannot configure gtk2hs-cast-glib-0.10.1.1. It requires glib -any
16:02:26 <pastah_rhymez> There is no available version of glib that satisfies -any
16:02:29 <pastah_rhymez> wtf?
16:03:02 <medfly> I had this thing that I wanted to install with cabal and apparently to install it I needed to get some dependency from my package manager
16:03:03 <bfh6558> pastah_rhymez: Thank you for that picture ha, i had to bookmark that for forwarding to friends
16:03:19 <pastah_rhymez> bfh6558: http://arcanux.org/lambdacats.html
16:03:31 <pastah_rhymez> you won't get many of them now, but it'll come to you :)
16:03:31 <bfh6558> oh yeah i've already been loking :)
16:03:59 <ivanm> pastah_rhymez: gtk2hs isn't on hackage
16:04:58 <pastah_rhymez> ivanm: why not?
16:05:10 <ivanm> it isn't cabalised yet
16:05:17 <ivanm> and hackage only has cabalised packages
16:06:02 <pastah_rhymez> Errors were encountered while processing:
16:06:04 <pastah_rhymez>  ghc6-doc
16:06:05 <pastah_rhymez> WTF?!
16:06:20 <pastah_rhymez> goddamn synaptic
16:06:40 <bfh6558> "i cant haskell today i has the dumb" awesome
16:07:20 <pastah_rhymez> fuck it!
16:07:23 <pastah_rhymez> no leksah for me
16:08:48 <bfh6558> sigh its so late and i do not want to wake up for class, coding djykstras algo in c++ is just not that exciting to me..
16:10:30 <pastah_rhymez> bfh6558: there's a haskell ==> c converter
16:10:45 <pastah_rhymez> though i don't think it works that well
16:10:49 <pastah_rhymez> but there is one :)
16:10:58 <kmc> ghc can compile via C
16:11:38 <kmc> if you turn in ghc's output for a C++ class your teacher will probably slap you
16:12:21 <wcarss> slap them back; haskell style -- I guarantee you won't cause any negative side effects
16:13:04 <kmc> @slap everyone
16:13:05 * lambdabot smashes a lamp on everyone's head
16:13:15 <tensorpudding> :(
16:13:20 <tensorpudding> @botsnack
16:13:20 <lunabot>  :o
16:13:20 <lambdabot> :)
16:13:20 <ezyang> oh noes, my server!
16:13:31 <pastah_rhymez> o_O
16:14:31 <ivanm> kmc--
16:14:35 <kmc> :(
16:14:54 <ivanm> that's for slapping everyone
16:15:28 <pastah_rhymez> ⋂ _⋂
16:15:54 <kmc> hey lambdabot did it
16:16:08 <ivanm> yes, but you know how suggestible she is
16:16:12 <kmc> "just following orders" is no excuse
16:17:50 <mmorrow> hah, never seen this before: "Redirect Loop: Firefox has detected that the server is redirecting the request for this address in a way that will never complete."
16:18:00 <mmorrow> http://infocenter.arm.com/help/topic/
16:18:10 <pastah_rhymez> what's the name of unicode >>=
16:19:00 <ivanm> mmorrow: stole that off ghc, did they? ;-)
16:19:12 <mmorrow> <<loop>>
16:19:29 <ivanm> that's what I was getting at
16:19:39 <kmc> blackholes and revelations
16:20:22 <kmc> what's a simple haskell expression that gets caught as <<loop>>?
16:21:01 <ivanm> > let infinitey = infinitey in infinity
16:21:02 <lambdabot>   * Exception: stack overflow
16:21:04 <ivanm> bah
16:21:59 <bfh6558> last [1..]
16:22:23 <sohum> ivanm: yea, I did. a few times.
16:23:41 <tensorpudding> > let stack = overflow and overflow = stack in stack
16:23:42 <lambdabot>   <no location info>: parse error on input `='
16:23:48 <tensorpudding> err
16:23:54 <tensorpudding> > let stack = overflow, overflow = stack in stack
16:23:55 <lambdabot>   <no location info>: parse error on input `,'
16:24:50 * hackagebot upload: Monocle 0.0.2 - Symbolic computations in strict monoidal categories with LaTeX output. (OsmanBineev)
16:25:26 <kmc> head . dropWhile ((== (1/2)) . realPart) . filter (not . trivialZero) $ zeros riemannZetaFunction
16:25:30 <kmc> let's see infinite loop detection on that
16:25:36 <ivanm> tensorpudding: semicolons, not commas
16:25:46 <Twey> :t lie
16:25:47 <lambdabot> String -> String
16:25:47 <Twey> :t is
16:25:48 <lambdabot> forall a. a
16:25:49 <kmc> > let a = b; b = a in a
16:25:50 <ivanm> ? let stack = overflow; overflow = stack  in stack
16:25:53 <lambdabot>   mueval-core: Time limit exceeded
16:25:56 <ivanm> > lie
16:25:56 <lambdabot>   * Exception: okay, I've had it
16:26:01 <Twey> Haha
16:26:12 <kmc> > is
16:26:13 <lambdabot>   * Exception: quit poking around
16:26:19 <kmc> > fix error
16:26:22 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
16:26:24 <Twey> :-D
16:26:39 <kmc> why is that one quoted?
16:26:57 <Twey> It takes it as a string, presumably
16:28:14 <kmc> > error "foo"
16:28:15 <lambdabot>   * Exception: foo
16:28:19 <kmc> not quoted
16:28:26 <kmc> > error $ fix error
16:28:27 <lambdabot>   * Exception: * Exception: * Exception: * Exception: * Exception: * Exceptio...
16:29:05 <bfh6558> what the heck exactly is an 'infix' function? just a function that makes more sense when thought of as a pipe, like between its arguments?
16:29:24 <kmc> bfh6558, it describes syntax
16:29:48 <Saizan> kmc: show over String is lazy enough to produce " before looking at the value and triggering the exception
16:29:52 <Saizan> ?type fix error
16:29:53 <lambdabot> [Char]
16:30:09 <kmc> Saizan, ah, right
16:30:14 <sohum> :t error
16:30:15 <lambdabot> forall a. [Char] -> a
16:30:27 <kmc> bfh6558, it's a property of what name the function is bound to, not of the function value itself
16:30:44 <Stinger> 1 + 2 infix, (+) 1 2 prefix
16:33:01 <kmc> elem 2 [1..10] prefix,  2 `elem` [1..10] infix
16:46:20 <Twey> > fix ("" ++)
16:46:24 <lambdabot>   mueval-core: Time limit exceeded
16:46:29 <Twey> Hmph… no quote
16:46:43 <sohum> > fix ("a" ++)
16:46:44 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
16:47:02 <Twey> Odd, hmn?
16:47:06 <sohum> yea
16:47:17 <sohum> :t (""++)
16:47:18 <lambdabot> [Char] -> [Char]
16:47:40 <Stinger> what's odd about it?
16:47:47 <tensorpudding> > fix ("ha" ++)
16:47:48 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
16:48:15 <Twey> Stinger: It's lazy enough to print a quote with a non-empty string, but it doesn't print an opening quote for the empty string
16:48:26 <sohum> > ""
16:48:27 <lambdabot>   ""
16:48:40 <tensorpudding> > "^_^"
16:48:40 <Lemmih> Twey: But the String isn't empty.
16:48:41 <lambdabot>   "^_^"
16:48:58 <Lemmih> Twey: ""++x === x
16:49:09 <sohum> > fix (""++) -- < in this, Lemmih
16:49:10 <Lemmih> Twey: So, fix ("" ++) === fix id
16:49:12 <lambdabot>   mueval-core: Time limit exceeded
16:49:18 <Twey> Aha, that would explain it
16:49:36 <sohum> it's type should still be String, though
16:49:53 <Twey> sohum: Yes, but it never reaches anything to print out
16:50:04 <Lemmih> > fix (id :: String -> String)
16:50:08 <lambdabot>   mueval-core: Time limit exceeded
16:50:22 <sohum> Twey: right, but shouldn't that consideration occur /after/ it prints out the opening quote?
16:50:23 <Twey> It doesn't print the empty strings: they're completely ignored
16:50:31 <Twey> Nope
16:50:36 <Twey> (that would require tweaking of fix)
16:50:39 <Lemmih> > fix (id . show :: String -> String)
16:50:40 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:51:41 <Lemmih> No 'show', no quotes.
16:51:46 <kmc> :t interleave
16:51:48 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
16:51:53 <EnglishGent> morning all :)
16:52:11 <kmc> > fix (interleave ['a'..])
16:52:12 <lambdabot>   "aabacbdaecfbgdhaiejckflbmgndohpaqiresjtcukvfwlxbymzg{n|d}o~h\DELp\128a\129...
16:52:13 <Saizan> > undefined :: String
16:52:14 <lambdabot>   "* Exception: Prelude.undefined
16:52:27 <Saizan> > fix id :: String
16:52:31 <lambdabot>   mueval-core: Time limit exceeded
16:52:38 <Saizan> weird.
16:53:10 <Saizan> oh
16:53:21 <kmc> > undefined :: [()]
16:53:22 <Saizan> it's just mueval being too strict
16:53:22 <lambdabot>   * Exception: Prelude.undefined
16:53:28 <Lemmih> > head (show (fix id :: String))
16:53:29 <lambdabot>   '"'
16:53:31 <kmc> > [(), undefined] :: [()]
16:53:32 <lambdabot>   [(),* Exception: Prelude.undefined
16:53:52 <Saizan> if you try "fix id :: String" in ghci you get the "
16:53:56 <Twey> > [undefined]
16:53:58 <lambdabot>   [* Exception: Prelude.undefined
16:54:11 <Twey> Saizan: Huh.
16:54:59 <Saizan> mueval doesn't give a partial result when it timeouts
16:55:16 <Saizan> > ((),fix id)
16:55:20 <lambdabot>   mueval-core: Time limit exceeded
17:16:35 <tombee> I'm unsure of how I group functions together into a sort of 'class'
17:16:39 <tombee> http://github.com/tombee/Perceptron/blob/master/perceptron.hs
17:18:31 <Saizan> you could just declare a type that's a record of functions
17:19:14 <Saizan> assuming you've to pass around these functions together to higher order functions
17:19:34 <Saizan> otherwise the module system is good for grouping
17:41:41 <tombee> Hmm ok Saizan, which would make more sense?
17:42:09 <tombee> I'm not sure this 'perceptron' model really fits, in the way that inputs must be part of the constructor
17:43:42 <tombee> Then again I suppose because the idea is to create pure functions, I have to create a new 'Neuron' for every calculation?
17:44:04 <tombee> So this would make sense in the way that I have to create a new Neuron with a set of inputs for every 'output'
17:44:26 <ziman> i would not include Inputs in Neuron
17:44:56 <ziman> that's something you give to the function; Neuron should contain only the state & params of the neuron
17:44:56 <manju> is it possible to address a list like in C
17:44:59 <manju> like
17:45:04 <manju> a[i][j]
17:45:05 <tombee> Sure ziman, thanks :)
17:45:21 <Twey> manju: Lists are not arrays
17:45:30 <Twey> (arrays can be found in Data.Array)
17:45:38 <manju> ok
17:45:48 <pastah_rhymez> manju: you have this:
17:45:48 <ziman> manju, it is, you can use xs !! 3 -- but doing so is generally considered bad style and usually suggests you're doing somthing wrong
17:45:52 <pastah_rhymez> @type (!!)
17:45:53 <lambdabot> forall a. [a] -> Int -> a
17:46:19 <manju> ok
17:46:33 <manju> I am trying to solve the problem 11 of project euler
17:46:39 <manju> the one with the number grid
17:46:40 <manju> http://projecteuler.net/index.php?section=problems&id=11
17:47:18 <pastah_rhymez> manju: for this you'd probobly like arrays
17:47:43 <manju> pastah_rhymez, yeah, it seems like that
17:47:57 <pastah_rhymez> manju: because of referential transparency, if you change one value in an array you have to copy all the other values of the array
17:48:24 <pastah_rhymez> "hello!" --> "hello?" means that you have to copy all of "hello"
17:48:29 <pastah_rhymez> to where the new array is
17:48:39 <ziman> tombee, and, I'd make the neuron output a Double instead of boolean values; later you'll probably want to combine the neurons into networks, where that would be useful
17:48:48 <manju> pastah_rhymez, ok
17:49:09 <pastah_rhymez> http://hackage.haskell.org/packages/archive/array/0.2.0.0/doc/html/Data-Array-Unboxed.html#v:UArray
17:49:17 <pastah_rhymez> that's probably what you want
17:49:59 <pastah_rhymez> (U == Unboxed == values are in the array; no pointers to the values)
17:50:47 <pastah_rhymez> haha!! (Int,Int) is i IX
17:50:51 <pastah_rhymez> cool
17:51:28 <tombee> ok ziman thanks :)
17:51:39 <tombee> http://github.com/tombee/Perceptron/blob/master/perceptron.hs
17:51:51 <tombee> I've performed the updates now, any more advice would be appreciated ziman :)
17:52:34 <pastah_rhymez> tombee: dude!
17:52:40 <manju> haha I have not clue how to use this :-(
17:52:44 <pastah_rhymez> you're doing "if True then True else False"
17:52:47 <pastah_rhymez> wtf, man?
17:53:17 <pastah_rhymez> manju: just try to make an array of [1..10]
17:53:25 <pastah_rhymez> go from there ;)
17:53:29 <pozic> pastah_rhymez: you need to get those lines from somewhere.
17:53:44 <manju> pastah_rhymez, hmm..
17:54:12 <Alpounet> tombee, hey, writing a neural network library too ? :)
17:54:41 <pastah_rhymez> tombee:
17:54:43 <pastah_rhymez> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13915#a13915
17:56:47 <pastah_rhymez> manju: in ghci: > :m Data.Array.Unboxed
17:56:52 <pastah_rhymez>   > :browse
17:57:08 <copumpkin> :m +
17:57:17 <pastah_rhymez> copumpkin: doesn't matter
17:57:26 <copumpkin> one sets it, the other adds to it
17:57:34 <copumpkin> as far as I know, at least
17:57:47 <copumpkin> maybe I just made that up :)
17:58:05 <copumpkin> nope, I didn't
17:58:12 <manju> pastah_rhymez, can you create a one dimensional array with 1 2 3 ?
17:58:19 <manju> I have no clue how to use the library
17:58:49 <manju> > a = array (1,3)
17:58:50 <lambdabot>   <no location info>: parse error on input `='
17:58:50 <pastah_rhymez> listArray (0,2) [1,2,3]
17:59:04 <pastah_rhymez> first argument is index span
17:59:22 <manju> index span is what ?
17:59:34 <manju> sorry :-(
17:59:34 <pozic> manju: can you read English?
17:59:39 <manju> yes
17:59:41 <pastah_rhymez> well, maybe i wan to adress my array from 100 to 200
17:59:47 <pastah_rhymez> instead of 0 to 11
17:59:51 <pozic> manju: then there is no need to ask these questions here.
17:59:53 <pastah_rhymez> *0 to 100*
17:59:53 <manju> ah
17:59:57 <pozic> manju: read the documentation.
18:00:00 <kmc> manju, the main thing to know is that (xs !! n) takes time O(n)
18:00:12 <kmc> it traverses the list from the beginning
18:00:22 <pozic> manju: put it in your Bookmark Toolbar folder if you have such a thing and have a locally installed version of the documention.
18:00:24 <kmc> manju, did you see Data.Sequence?
18:00:38 <kmc> it's more like a list than like an array, but has much more efficient indexing
18:00:59 <manju> kmc, no, but I will
18:01:09 <pozic> manju: ttp://www.haskell.org/ghc/docs/latest/html/libraries/index.html
18:01:37 <manju> pozic, I did read this, but the documentation is really obtuse
18:01:41 <pozic> manju: if you want to know anything about a particular type go to Index and search for the type. E.g. Array.
18:01:52 <pozic> manju: then you try to read the source code.
18:02:07 <pozic> manju: the array documentation is quite clear for the simpler types.
18:02:32 <pozic> manju: what specifically didn't you understand?
18:02:44 <kmc> arrays are complicated by the fact that we have two typeclasses (IArray and MArray) for working with more than two concrete types of arrays
18:02:55 <kmc> it's convenient though
18:03:36 <copumpkin> there's also the Array typeclass
18:04:02 <copumpkin> oh wait
18:04:05 <copumpkin> it isn't a typeclass
18:04:05 <manju> an array seems like a list of tuples ?
18:04:12 <copumpkin> manju: it can behave like one
18:04:19 <pozic> manju: that is the wrong way to think about it.
18:04:36 <copumpkin> think of it as Int -> a
18:04:37 <kmc> manju, an array maps every "index" in a fixed range of indices to an "element"
18:04:41 <kmc> the element could be a tuple, or not
18:04:42 <pozic> manju: first of all you should say an Array, instead of array.
18:04:54 <pozic> manju: be specific.
18:05:09 <manju> ok Array is type and array is ctor
18:05:13 <kmc> manju, you can *initialize* the array with a list of (index, element) tuples
18:05:23 <kmc> but once created it does not behave much like that list
18:05:30 <manju> kmc, ah...now I get it
18:05:30 <kmc> :t array
18:05:31 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
18:05:43 <manju> let me write some code to test my theory
18:05:53 <copumpkin> listArray is a more common way of doing it
18:05:55 <kmc> manju, you may find this helper useful:
18:05:56 <kmc> :t listArray
18:05:57 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
18:06:02 <pozic> manju: the documentation for Array is in the Haskell 98 language report.
18:06:13 <pozic> manju: which unlike the C standard is a free document.
18:06:20 <kmc> > (listArray (0, 4) "xyzab") ! 3
18:06:21 <lambdabot>   'a'
18:06:39 <manju> pozic, I know, but I don't if this is because I am non-native english speaker, but reading the document is hard
18:06:55 <pozic> manju: http://www.haskell.org/onlinereport/array.html
18:07:01 <kmc> manju, you can index by any type which is a member of Ix, not only ints.  so e.g. a two dimensional array could have index type (Int, Int)
18:07:12 <pozic> manju: from which country are you?
18:07:16 <manju> india
18:07:16 <kmc> > (listArray ((0,0), (1,1)) "xyzabc") ! (1,0)
18:07:17 <lambdabot>   'z'
18:07:37 * copumpkin yawns
18:07:48 <Alpounet> manju, that's a matter of training.
18:07:53 <kmc> you could build an n*m 2D array with listArray ((0,0), (n-1, m-1))
18:08:04 <kmc> @instances Ix
18:08:04 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
18:08:05 <pastah_rhymez> manju: for your giant grid you will want to do 'listArray ((0,0), (19,19))'
18:08:53 <manju> pastah_rhymez, ok
18:09:10 <kmc> @instances-importing Data.Array Ix
18:09:11 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
18:09:14 <tombee> Alpounet: yep :)
18:09:50 <tombee> pastah_rhymez: yeah sorry, I haven't tested this yet, just slung some code together to just get something 'sort of working'
18:10:10 <kmc> > (listArray ('a', 'z') [1..26]) ! 'q'
18:10:11 <lambdabot>   17
18:10:28 <pastah_rhymez> kmc: hehe, nice :)
18:10:29 <kmc> > let myOrd = ((listArray ('a', 'z') [1..26]) !) in myOrd 'q'
18:10:30 <lambdabot>   17
18:10:34 <manju> kmc thanks :-)
18:10:46 <kmc> :)
18:10:56 <kmc> @quote array
18:10:56 <lambdabot> ghc says: DsExpr.dsExpr: Infinite parallel array!
18:11:32 <Alpounet> tombee, I also have a beginning of neural network library : http://github.com/alpmestan/HNN
18:11:49 <Alpounet> + a
18:12:43 <manju> ah...wow
18:12:45 <manju> kmc thanks
18:12:50 <manju> I think I figured it out
18:13:03 <manju> > let b = [08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08]
18:13:04 <lambdabot>   not an expression: `let b = [08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,1...
18:13:11 <manju> let a = listArray (0, 19) b
18:13:30 <manju> let a = listArray (0, 19)  [08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08]
18:13:34 <manju> > let a = listArray (0, 19)  [08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08]
18:13:35 <lambdabot>   not an expression: `let a = listArray (0, 19)  [08,02,22,97,38,15,00,40,00,...
18:13:49 <manju> > let a = Data.Array.listArray (0, 19)  [08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08]
18:13:50 <lambdabot>   not an expression: `let a = Data.Array.listArray (0, 19)  [08,02,22,97,38,1...
18:14:05 * manju goes back silently to ghci
18:15:29 <manju> how do I get my ghci to behave exactly like kmbdabot
18:15:35 <manju> lambdabot
18:15:38 <medfly> @let a = Data.Array.listArray (0, 19)  [08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08]
18:15:38 <lambdabot>  <local>:17:0:
18:15:38 <lambdabot>      Multiple declarations of `L.a'
18:15:38 <lambdabot>      Declared at: <local>:...
18:15:45 <trofi> > [08]
18:15:46 <lambdabot>   [8]
18:15:47 <medfly> @let someother = Data.Array.listArray (0, 19)  [08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08]
18:15:48 <lambdabot>  Defined.
18:16:20 <manju> hmmm...
18:16:36 <manju> so now someother can be used ?
18:16:51 <copumpkin> > someother Data.Array.! 3
18:16:52 <lambdabot>   97
18:16:56 <copumpkin> > someother Data.Array.! 0
18:16:57 <lambdabot>   8
18:17:05 <manju> oh..cool
18:18:36 <kmc> @let somef = (someother !)
18:18:37 <lambdabot>  Defined.
18:18:41 <kmc> > somef 6
18:18:42 <lambdabot>   0
18:18:46 <kmc> > somef 13
18:18:46 <manju> haskell is cool, once you get the hang of it
18:18:47 <lambdabot>   78
18:18:55 <kmc> an array is a lot like a function
18:18:56 <medfly> sure is
18:19:18 <kmc> copumpkin, why the qualified name?
18:19:19 <Jafet> cabal install lambdabot; alias ghci=lambdabot
18:20:17 <kmc> hehe
18:20:36 <quicksilver> IRC.Haskell.Users.copumpkin
18:20:57 <tombee> Thanks Alpounet ill keep that in mind
18:21:18 <manju> g cabal proxy
18:21:25 <manju> argh...wrong windoe
18:22:35 <manju> ah...it works
18:23:24 <manju> so cabal is cpan of haskell ?
18:23:26 <manju> nice
18:25:27 <kmc> the site is hackage.haskell.org
18:25:43 <kmc> the program's package name is cabal-install but the binary is just "cabal"
18:27:01 <manju> ick...cabal is not working
18:27:10 <manju> it says I need to do cabal update
18:27:31 <manju> which says I need to do cabal install cabal-install
18:27:36 <pastah_rhymez> hehe
18:27:44 <int-e> it should work just fine even when it says that. they're just informative messages
18:27:45 <manju> and then I do that and it says cabal update
18:27:47 <manju> gah
18:28:03 <manju> If forgot what I was doing
18:28:11 * manju scrolls back
18:28:27 <manju> ah..right lambdabot
18:29:06 <pastah_rhymez> gosh darnit
18:29:14 <pastah_rhymez> i can't solve euler 11
18:29:24 <ivanm> oh noes...
18:29:32 <pastah_rhymez> ivanm: and my code is bug free!!
18:29:39 <ivanm> because its empty? :p
18:30:05 <Botje> pastah_rhymez: store it all in an array, generate all possible combinations, find the biggest one
18:30:53 <pastah_rhymez> Botje: doing exactly that
18:31:23 <Botje> so what are you stuck on?
18:31:28 <Botje> you can put the code on hpaste if you want
18:31:33 <pastah_rhymez> http://codepad.org/9ueVFV8t
18:31:41 <Botje> although i haven't been awake for very long
18:32:19 <Saizan> manju|tea: how are you calling cabal-install? and do you have ~/.cabal/bin in your $PATH?
18:32:29 <int-e> pastah_rhymez: what about diagonals? and you're missing some horizontal and vertical products, too.
18:32:36 <Cale> pastah_rhymez: So, that's two numbers horizontally or vertically
18:33:03 <Cale> oh, no sorry
18:33:08 <Botje> huh. codepad.org won't even load
18:33:09 <pastah_rhymez> well, i'm going from (0,0) to (16,16)
18:33:13 <Cale> But yeah, missing diagonals
18:33:22 <pastah_rhymez> oh shit
18:33:27 <pastah_rhymez> it says diagonally too
18:33:30 <pastah_rhymez> dang
18:33:40 * pastah_rhymez feels stupid
18:33:44 <Botje> ah, there we go
18:33:46 <int-e> pastah_rhymez: how many horizontal products are there? hint: The answer is not 17*17.
18:34:08 * quicksilver is taken aback by the vocal opposition to studlyCaps on haskell-cafe. I've never considered them offensively ugly.
18:34:41 <adu> int-e: is it 17*16/2?
18:34:50 <Saizan> quicksilver: a commando of lispers?
18:35:04 <Peaker> pastah_rhymez: I'd create a directions list:  dirs = [(1,0),(0,1),(1,1),(-1,1)] ?
18:35:04 <Jafet> is_that_not_the_default_style?
18:35:23 <pastah_rhymez> Peaker: it's cool, i know how to solve it
18:35:40 <Peaker> pastah_rhymez: ok, just suggesting it could be nicer than the duplicate prod* functions
18:35:40 <int-e> adu: nah. the question is basically how many ways there are to place a grid aligned 4x1 rectangle inside a 20x20 rectangle, without changing its orientation.
18:35:56 <quicksilver> Jafet: I'm just surprised people feel so strongly.
18:36:09 <quicksilver> Jafet: i-find-this and_also_this andThisToo almost equally readable
18:36:16 <quicksilver> and I certainly don't lose sleep over any of the three.
18:36:36 <adu> int-e: 16*20?
18:36:39 <quicksilver> although inconsistency within a single codebase is slightly unaesthetic.
18:36:58 <int-e> adu: off by one, but yeah, that has the right shape.
18:37:18 <Peaker> quicksilver: If you want to turn in a paper with a horrible and deep mistake -- and you want it to be unnoticed -- put in a lot of spelling errors :)
18:37:38 <Peaker> quicksilver: in other words -- when the code has unaesthetic stuff in it -- it diverts attention away from the important stuff
18:38:17 <quicksilver> ;)
18:38:22 <quicksilver> Peaker: I'll remember that :)
18:39:39 <Peaker> Its hard for me to find the deep flaws in code that is superficially flawed -- and therefore I think it is of utmost importance to be very strict about style, getting the final dots and commas correctly in the right places..
18:40:47 <Saizan> you need to train your abstraction abilities a little :P
18:41:52 <Fafnr> Does anyone know of a nice, thorough guide to do-notation? I'm studying the syntax of various programming languages, but I'm having a hard time finding anything comprehensive about haskell's do-notation, even after extensive google'ing
18:42:20 <Jafet> do notation tutorials are side dishes to monad tutorials
18:42:25 <Jafet> It's a well-kept secret
18:42:49 <Kim^Walkman> Fafnr: Is it the syntax or what it desugars to?
18:42:54 <Peaker> Saizan: mie abztraction bilits jst fne, bUt wh_n te f0cus s dovrtwd awy fom imprtnt stuph, its hrd to fcs on thm
18:43:26 <Saizan> Peaker: it's harder, but not that much
18:43:29 <Fafnr> Kim^Walkman: The syntax only. I'm looking at non-context free grammars in programming languages, and do-notation came up on my radar :)
18:43:42 <Peaker> Saizan: depends on how bad the superficial stuff is :)
18:43:52 <Fafnr> Jafet: So, you're saying to check out monad tutorials?
18:44:04 <Saizan> Fafnr: well, the grammar and the translations are defined in the haskell98 report
18:44:09 <int-e> Fafnr: http://haskell.org/onlinereport/exps.html#sect3.14 ... but that's only half of the story; the other half is turning layout into braces and semicolons.
18:44:15 <Jafet> Oh, the syntactic translation is trivial.
18:45:02 <Jafet> @undo do { x <- foo; y <- bar x; let z = baz y; return z }
18:45:02 <lambdabot>  Parse error at "}" (column 52)
18:45:05 <Jafet> @undo do { x <- foo; y <- bar x; let z = baz y; return z; }
18:45:05 <lambdabot>  Parse error at ";" (column 51)
18:45:15 <int-e> Fafnr: http://haskell.org/onlinereport/lexemes.html#sect2.7 introduces the layout rules and links to a more formal description.
18:45:25 <int-e> @undo do { x <- foo; y <- bar x; let { z = baz y }; return z; }
18:45:26 <lambdabot> foo >>= \ x -> bar x >>= \ y -> let { z = baz y} in return z
18:45:37 <Jafet> Oh, ok
18:45:38 <Fafnr> int-e: Cheers! that looks a lot like what I was looking for!
18:46:56 <Fafnr> The online report is the "official" report from the Haskell body, right? It's just nice to know your sources :)
18:48:22 <int-e> Fafnr: http://haskell.org/ --> Language definition  has some more information about the report itself.
18:49:10 <Fafnr> int-e: Cheers again!
18:49:22 <Fafnr> This a supremely helpful channel :)
18:49:47 <int-e> :)
18:59:14 <Baughn> http://en.wikipedia.org/wiki/HMAC#Implementation <-- Looks pretty simple. But does anyone know why the 0x5c/0x36 constants?
18:59:31 <opqdonut> magic as always
18:59:33 <opqdonut> see md5
18:59:36 <Baughn> Going by what I know of hash functions, absolutely any non-identical constants should be fine
19:00:00 <opqdonut> well HMAC is intended to be cryptographic too
19:00:13 <Jafet> If you scroll up, it's magic from an RFC
19:00:28 <Jafet> Which I would advise you to read instead of wikipedia
19:00:32 <opqdonut> those constants probably correspond to some two undivisible polynomials over some finite field
19:00:35 <opqdonut> or something like that
19:00:44 <Baughn> Jafet: It doesn't explain it, though. :
19:01:18 <opqdonut> at least that's how the magic constants in CRC arise
19:03:14 <Baughn> The wikipedia code is correct, thankfully
19:03:45 <Baughn> Hm. Well, I'm pretty sure any non-equal, non-zero constants would do, but.. let's not make any changes.
19:03:48 * Baughn cargo-cults ahead.
19:03:53 <Jafet> This is a good time to find out if mathematica can do polynomial factorization over GF2
19:04:16 <opqdonut> Jafet: tell us what you find out :)
19:04:19 <Jafet> HMAC produces a signature, so I'm pretty sure for compatibility you'd have to use the same constants
19:04:25 <int-e> Baughn: they have exactly half of their 8 bits set, and so does 0x5c ^ 0x36. Other than that, they seem arbitrary to me.
19:04:57 <Baughn> int-e: Which is a nice property, but hash functions are supposed to diverge completely even with a single-bit difference
19:05:28 <opqdonut> or rather, especially on those :)
19:05:34 <Jafet> Supposed to, but they don't.
19:05:44 <Baughn> What, even SHA-2?
19:06:01 <opqdonut> i guess the pigeon hole principle says it can't
19:06:15 <Baughn> Sure it can
19:06:39 <Baughn> The pigeon hole principle says the hash function has to be lossy, it says nothing about information leakage
19:07:10 <Baughn> If you have two nonequal hash values, it should be impossible to tell anything about the relation of their source values
19:09:13 <koala_man> except that they're nonequal
19:09:21 <Baughn> ..admittedly.
19:09:35 <Jafet> That didn't hold for MD2, MD4, MD5, SHA-1, crypt...
19:09:48 <Jafet> You're expecting it to hold for SHA-2, which sounds a bit optimistic
19:10:02 <Baughn> I'm expecting it to hold until SHA-3 has been finalized. ^^;
19:10:21 <Baughn> I'm not expecting mathematical guarantees from a field that is this immature
19:13:08 <mullein> csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf also uses 0x5c, 0x36 for ipad and opad, and says "in the HMAC algorithm, values of the ipad and opad depend on the block size of the approved hash function"
19:13:47 <Baughn> So it does. ipad and opad have to be the same size as the block size of the hash function.
19:14:18 <Jafet> Oh, it's length padding?
19:14:53 <Baughn> ipad = Data.ByteString.map (xor 0x5c) key
19:16:21 <Baughn> (Except it's really 0x36 for that one)
19:16:48 <Baughn> Jafet: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13916#a13916 <-- Or just see this. I'm pretty sure it's correct.
19:18:31 <Jafet> If it depends on the length of something, I'll wager it's hardening against length extension
19:18:36 <Jafet> You misspelled "attackers"
19:18:50 <int-e> Baughn: of course your 'ipad' is really 'K xor ipad' from the RFC
19:19:12 <Baughn> int-e: Which is the only projection of ipad that's ever actually used, but yes
19:20:16 <Baughn> Jafet: Ah, thanks. Uploading a 0.1.1 just for /that/ would have been a bit much.
19:25:35 <int-e> Baughn: hmm. it's irritating that you calculate the hash in two different ways - although I think I understand why: the size of text can be large while B.concat [opad,ihash] only duplicates a couple of dozen bytes.
19:26:03 <Baughn> int-e: Exactly
19:26:52 * hackagebot upload: SHA2 0.1.0 - Fast, incremental SHA hashing for bytestrings (SveinOveAas)
19:26:54 * hackagebot upload: polyparse 1.4 - A variety of alternative parser combinator libraries. (MalcolmWallace)
19:28:28 <ivanm> @ask malcolmw what's new in polyparse 1.4?
19:28:28 <lambdabot> Consider it noted.
19:32:58 * hackagebot upload: hmatrix 0.7.1.0 - Linear algebra and numerical computations (AlbertoRuiz)
19:39:00 <v_> What's wrong with this code?  http://pastebin.com/m4155ac03
19:39:27 <fasta> v_, homework?
19:39:32 <v_> Nope
19:39:54 <v_> I think it's formatting
19:40:00 <v_> *the formatting
19:40:23 <fasta> v_, let me guess: an infinite loop?
19:40:33 <ben> v_: You tell us, what is wrong with the output?
19:40:52 <fasta> v_, the problem is obvious.
19:41:30 <fasta> v_, you run a recursive process on a non-decreasing size list.
19:41:32 <v_> Great, and now it's working..
19:41:33 <v_> runhaskell wrong.hs
19:41:33 <v_> [2,3,4,5,6,6]
19:41:37 <v_> Wtf.
19:41:44 <dolio> That isn't an infinite loop.
19:41:53 <ben> fasta: Surely matching on (x:xs) and calling the recursion on just xs is not infinite
19:42:13 <fasta> Oh, missed the parenthesis.
19:42:29 <ben> > let qsort [] = [] ; qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs) in qsort "foobar"
19:42:30 <lambdabot>   "abfoor"
19:43:00 <tsudot> how do i save a list to a file
19:43:05 <tsudot> im trying this
19:43:07 <tsudot> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13917#a13917
19:43:07 <v_> ben: thanks
19:43:17 <v_> One-liners are awesome
19:43:42 <Beelsebob> tsudot: well, that's reading it, certainly
19:43:52 <Beelsebob> tsudot: bear in mind that you could just use show and read instances
19:43:57 <Beelsebob> and use haskell list syntax in your file
19:44:18 <v_> I'm doing a presentation for some colleagues  and I want to keep the exemples as simple as possible
19:44:29 <v_> And quicksort is a classic
19:45:03 <tsudot> Beelsebob, i tried using show before closing the handle, it gives me a match error
19:45:11 <fasta> v_, quicksort is misleading.
19:45:27 <v_> I know
19:45:38 <v_> Most short examples are misleading
19:45:57 <opqdonut> yeah it's not quicksort
19:46:18 <dolio> It's close enough.
19:46:38 <ToRA> dcoutts: wrt Cabal.Command and friends - there isn't any quick support for parsing/handling numeric option arguments?  Can't see anything in there (or in ReadP to even parse ints...)?
19:47:15 <fasta> v_, you should also discuss http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html if you want to present any kind of good picture.
19:47:19 <dolio> It has the same performance problem cases as quicksort.
19:47:28 <dcoutts> ToRA: right
19:47:42 <ToRA> dcoutts: k cool, just checking I wasn't being blind
19:47:44 <v_> And this http://en.literateprograms.org/Quicksort_(Haskell)#Performance
19:48:36 <mreh> Monad m => [m a] -> m a -- why is there no function to do this?
19:49:07 <dolio> @type foldr1 (>>)
19:49:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
19:49:48 <mreh> I need to think about what I'm doing
19:49:54 <ToRA> @type msum
19:49:55 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
19:50:04 <v_> fasta: interesting. So that quicksort isn't really quicksort.
19:50:38 <fasta> v_, that's why I said it was misleading.
19:50:51 <v_> Ok, got it
19:50:54 <mreh> I've got a sequence of functions I want to apply to a state monad, I think I had the wrong type signature
19:51:23 <v_> The examples from literateprograms are much better
19:51:25 <mreh> what's the idiom I am looking for
19:51:44 <ToRA> so you want something like: [State a ()] -> State a ()
19:52:03 <c_wraith> :t sequence_
19:52:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
19:53:06 <mreh> ToRA: State a () == (() -> (a, ()))
19:53:11 <mreh> that's not what I need
19:53:24 <ToRA> no
19:53:34 <ToRA> State a () = a -> (a,())
19:53:38 <ToRA> i used a when I meant s
19:53:41 <mreh> right
19:54:06 <ToRA> i mean you care about what happens to the state, but not what your functions return at the end
19:54:36 <fasta> I think convincing other people to use any other language than the one they are already using is quite difficult, especially when tool support and conversion tools don't exist.
19:54:48 <mreh> ToRA, how can I keep the result of these computations in a list?
19:54:57 <ToRA> @type sequence
19:54:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:55:22 <fasta> It is basically throwing away a current investment with the _expectation_ that things will be better.
19:55:28 <mreh> I keep forgetting that State represents a function
19:56:01 <c_wraith> @src State
19:56:01 <lambdabot> Source not found. Are you on drugs?
19:56:03 <fasta> mreh, what exactly are you doing?
19:56:17 <ToRA> > runState (sequence [(State (splitAt 1)), (State (splitAt 2))]) "hello"
19:56:18 <lambdabot>   (["h","el"],"lo")
19:56:38 <mreh> fasta: creating a random list, but the next element depends on the previous one, similar to a random walk
19:56:52 <fasta> mreh: why not use the MonadRandom?
19:57:13 <mreh> what does it do?
19:57:20 <fasta> mreh, then you can just say next to get your next random number.
19:57:43 <fasta> Oh, no, that is another monad. It is getRandom, I think.
19:57:47 <mreh> It's a little more complicated than you think I imagine
19:58:15 <fasta> mreh, well, then you didn't fully describe the problem.
19:58:21 <bastl> ivanm: can you point to an example for experimenting with graphviz from ghci? i.e. creating a GTK-canvas and drawing on it.
19:58:29 <mreh> or you didn't understand
19:58:39 <ivanm> bastl: ummm.... from an FGL graph or by hand?
19:58:43 <bastl> fgl
19:58:45 <fasta> mreh: unlikely.
19:58:46 <ivanm> (there's no real examples as such...)
19:59:36 <fasta> mreh, MonadRandom only solves the random number part. You combine those with monad transformers, probably StateT in this case.
19:59:51 <ivanm> bastl: OK, quick version: let dg = graphToDot' g [] (const []) (const []); runGraphvizCanvas' Gtk dg
19:59:58 <ivanm> that does a _really_ plain graph
20:01:44 <ivanm> bastl: good enough?
20:01:50 <bastl> im trying ...
20:01:58 <ivanm> heh
20:02:15 <jaspervdj> I want to make a FilePath an instance of something, but that's a [Char], and apparently I can't do that
20:02:41 <jaspervdj> So the obvious solution would be something like newtype MyFilePath = MyFilePath FilePath
20:02:49 <jaspervdj> or is there a more standard solution to this?
20:02:58 <Asztal> Or the FlexibleInstances language extension
20:03:01 <fasta> jaspervdj, there are non-standard ways to do so.
20:03:09 <fasta> jaspervdj, I recommend the newtype.
20:04:20 <jaspervdj> okay, is there already a String wrapper newtype somewhere in the libraries or should I write my own one?
20:06:43 <fasta> jaspervdj, what do you need the type-class for?
20:07:09 <jaspervdj> well, the type class is called Renderable
20:07:32 <jaspervdj> and I want to be able to pass a datatype, but also a filename
20:09:09 <fasta> jaspervdj, just make up a type RenderableFilePath then.
20:10:09 <jaspervdj> fasta: okay, thanks
20:10:53 <fasta> jaspervdj, that said, lots of tools don't use type-classes.
20:11:25 <fasta> You can get much of the same benefits by using modules.
20:11:59 <mreh> how do I make my own State objects then? withState f (return a)
20:13:01 <Cale> mreh: State objects?
20:13:13 <fasta> mreh: use better terminology.
20:13:21 <mreh> my own functions encapsulated in a State monad
20:13:34 <mreh> fasta: get off my case
20:13:47 <Cale> hmm, I think I'd need to be more familiar with what you were doing then.
20:13:58 <Cale> (I just got here :)
20:14:36 <mreh> Cale: generating a random list where the next element depends on the last
20:14:47 <mreh> e.g. a random walk in 1d
20:15:06 <fasta> Cale, he kills you when you say a monad transformer of MonadRandom + StateT.
20:15:28 <Cale> mreh: okay, a finite list?
20:15:30 <mreh> fasta: what's with you personal vendetta against me?
20:15:37 <mreh> Cale: aye
20:16:08 <fasta> mreh: saying "get off my case" without any kind of argument is kind of silly, don't you think?
20:16:12 * hackagebot upload: OpenVG 0.2.1 - OpenVG (shivag-0.2.1) binding (StephenTetley)
20:16:28 <fasta> mreh: and remember that I don't have to answer. Nobody here has to.
20:16:43 <mreh> obviously I need a monad transformer, but i need to encapsulate a function that takes the previous state and gives me a value depending on that one
20:16:52 <mreh> infact, the state could just be the last object
20:17:06 <mreh> fasta: not getting into a flame war
20:18:30 <Alpounet> mreh, then you just need to use >>= within the State monad ... ?
20:19:07 <mreh> Alpounet: I was going to use sequence, because I have to bind a list of things and collect the result
20:19:14 <mreh> but, I
20:19:55 <mreh> 've got nothing to bind to, just a list of values, how do I take a function that takes a state and returns a new state and a value and inject that into the State monad
20:20:17 <mauke> :t State
20:20:18 <lambdabot> forall s a. (s -> (a, s)) -> State s a
20:21:03 <mreh> lol. thanks mauke, that took a long time
20:22:51 <mreh> now I just have to combine it with Random numbers
20:37:18 <SamB_XP_> mmmkay, for some reason IDA is under the impression that any function consisting of "mov eax, 1" and "retn Ch" is _DllMain@12 ...
20:39:07 <SamB_XP_> no, worse, it's gotten the idea that *any* piece of code like that is _DllMain@12
21:06:49 <DerisionSnort> @src Bool
21:06:50 <lambdabot> data Bool = False | True deriving (Eq, Ord)
21:09:06 <Jafet> Hmm, compiling happy produces a nice list of warnings
21:25:55 <ivanm> bastl: so did that work?
21:34:53 <Veinor> When I first started learning Haskell, I thought that lists being restricted to one type was a huge flaw.
21:34:59 <Veinor> Then I realized.... why do you need multi-type lists?
21:35:49 <tombee> If I have a function :: x -> y -> z
21:35:56 <idnar> a list with elements where you truly don't know the type is useless
21:36:01 <tombee> and I have ([x],[y])
21:36:05 <idnar> the thing is that in other languages, there's usually no such thing
21:36:23 <tombee> how could I run function over ([x],[y])?
21:36:25 <Voker57> idnar: they can be of one typeclass
21:36:25 <idnar> there's frequently operations you can perform on any value, like toString() or some such
21:36:51 * Jafet shoves idnar into Tcl
21:36:56 <Veinor> (Show a) => [a] ?
21:36:58 <idnar> or in a language like Python, you can do "duck typing" and just assume they all support a certain interface
21:37:11 <idnar> in Haskell, all of these use cases are still supported, but you have to make them explicit
21:37:26 <mauke> tombee: depends on what you want to do
21:37:37 <Jafet> Or just use HList!
21:37:38 <idnar> so you can have (Show a) => [a] or even some crazy stuff with existentials
21:37:45 <idnar> but if you just have [a], you can't do anything
21:37:59 <Veinor> > [2, "f"] :: (Show a) => [a]
21:38:00 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
21:38:01 <lambdabot>    arising from the literal ...
21:38:06 <Veinor> ;)
21:38:10 <xerox> tombee: uncurry f
21:38:25 <Voker57> you need some extension to enable that
21:38:29 <idnar> uhm
21:38:39 <tombee> ah I'll look at that xerox
21:38:40 <idnar> > [2, "f"] :: [forall a. (Show a) => a]
21:38:41 <lambdabot>   Couldn't match expected type `a'
21:38:41 <lambdabot>         against inferred type `[GHC.Types....
21:39:01 <gwern> 'It handles arbitrary left-recursive grammars, including eps-cycles.
21:39:01 <idnar> anyway, (Show a) => [a] was a bad example
21:39:04 <gwern> It copes with highly ambiguous grammars. It can produce all parses of
21:39:06 <gwern> the input sequence. It parses the input in O(n^4) time with respect to
21:39:09 <gwern> the size of the input.
21:39:14 <gwern> oh, n^4, is that all? shucks darn
21:39:27 <idnar> haha
21:39:27 <Veinor> gwern: ... what?
21:39:48 <gwern> Veinor: I bet that's your reaction to everything oleg writes
21:40:03 <Veinor> perhaps it would be if I knew more about this alleged 'oleg'
21:40:28 <mauke> @where oleg
21:40:28 <lambdabot> http://okmij.org/ftp/
21:40:34 <Veinor> anyway, breakfast time
21:41:14 <ben> Oleg is a mythical hero and the haskell 98 standard was conveyed to us through a song of his heroic deeds
21:41:36 <Jafet> In epic Norse!
21:45:45 <Veinor> also, does Haskell have a top type?
21:46:53 <Jafet> What is a top type?
21:47:31 <Veinor> a type that is a supertype of every type
21:47:37 <Veinor> like Object in java
21:47:44 <Jafet> That would be a completely useless type.
21:47:51 * hackagebot upload: bindings-gpgme 0.1.1 - Low level bindings to gpgme. (MauricioAntunes)
21:50:10 <Jafet> Also, types don't work exactly that way in Haskell
21:51:15 <ben> You can use existential types to build a container that can contain any other type
21:51:31 <ben> but you would need to constrain them to Typeable or something to do anything with it.
22:00:11 <Saizan> there isn't a concept of subtyping in haskell anyhow
22:01:02 <Saizan> but if you have data Object = forall a. Object a, then you can coerce every value to an Object via the Object constructor :)
22:01:18 <tombee> Can I get some help debugging this error:
22:01:18 <tombee> http://pastie.org/737226
22:01:36 <paul424> What is the diffrence bettween those packages : http://haskell.org/ghc/dist/6.10.1/. one has 7 and the other 70 MB ?
22:03:27 <Saizan> i don't see any with 7
22:03:48 <Axman6> mw wither
22:03:51 <Axman6> e*
22:04:58 <paul424> ghc-6.10.1-src.tar.bz2                           04-Nov-2008 08:12  9.1M
22:05:27 <Saizan> so, 9
22:05:44 <sohum> has anyone implemented a polynomial datatype?
22:06:00 <paul424> Saizan: WHY it is so >?
22:06:26 <Saizan> those are just the sources anyhow, ghc-6.10.1-x86_64-unknown-linux.tar.bz2 contains the result of building too
22:07:21 <sohum> I can't imagine it'd be too hard. data Num a => Polynomial a b = Number a | Variable b | Add (Polynomal a b) (Polynomial a b) | Mul (Polynomial a b) (Polynomial a b)
22:07:32 <paul424> Saizan: hmm contain builded binaries right ?
22:07:37 <Saizan> the result of building both ghc-6.10.1-src.tar.bz2 and ghc-6.10.1-src-extralibs.tar.bz2
22:07:41 <Saizan> paul424: right
22:08:12 <Saizan> tombee: that error message looks weird, there are two different expressions in it, are you sure you didn't mangle it while copyin?
22:08:31 <sohum> you make that an Ord instance, and you have a complexity class representation
22:08:41 <tombee> Hang on Saizan, let me just update it I might have copied the wrong error :)
22:09:00 <Saizan> tombee: however, it seems you've the order of arguments backwards in f and in your application of foldl
22:09:20 <sohum> then you can specify complexity classes for typeclass operations, and in a number of cases this is programmatically useful for efficiency
22:09:41 <Saizan> foldl (flip f) inputSet (weights neuron) is more likely to work
22:09:54 <tombee> http://pastie.org/737238
22:10:22 <tombee> I think I'm passing a LIST of inputs where its expecting just Inputs
22:10:26 <tombee> and the same with the Double
22:10:28 <tombee> :(
22:11:25 <Saizan> tombee: foldl takes 3 arguments at least, unless you want to produce a function
22:11:28 <Saizan> ?type foldl
22:11:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:14:01 <Saizan> i don't understand what that function is supposed to do
22:14:28 <ivanm> Saizan: you don't get foldl? :o
22:14:48 <tombee> http://jpmoresmau.blogspot.com/2007/05/perceptron-in-haskell.html
22:14:53 <tombee> the epoch function on that blog
22:15:02 <tombee> I'm trying to apply that
22:15:13 <tombee> but his stuff is designed a little differently
22:15:21 <Saizan> ivanm: tombee's function i meant
22:18:10 <Saizan> tombee: his step function takes inputs weights expected
22:18:32 <tombee> yep, on mine weights is contained in Neuron
22:18:37 <Saizan> ok
22:20:18 <tombee> so I need to take ([Inputs],[Double]), and run learnStep Inputs Double
22:20:40 <Saizan> you want to construct a new Neuron out of the result of learnStep though
22:20:57 <Saizan> otherwise you can't feed it as input to learnStep again
22:21:20 <Saizan> and you want to fold over [(Inputs,Double)]
22:21:24 <tombee> Hmm, does this make sense though?
22:21:31 <Saizan> which is just the zipWith version
22:21:59 <Saizan> *zip
22:22:58 <Saizan> it does make sense that you create an updated Neuron after learning
22:23:13 <tombee> I see, ok.
22:23:18 <Saizan> probably it'd just be the old one with the weights updated
22:24:30 <Saizan> http://pastie.org/737259 <- like this
22:26:44 <tombee> gotcha
22:26:53 <tombee> I still have to zip the inputSet though right?
22:28:07 <tombee> 		adjustedWeights = foldl f neuron inputSet 		f (inputs,expected) = learnStep neuron (zip inputs expected)
22:28:22 <tombee> Gah, that's two lines obviously.
22:28:27 <Saizan> no
22:28:30 <Saizan> not there at least
22:29:09 <Saizan> note that i've changed the type signature of learnEpoch.
22:29:21 <Saizan> to reflect the one of epoch, and because it makes more sense
22:29:25 <tombee> Oops, yes.
22:29:29 <tombee> Sorry
22:30:00 <Saizan> but if you've ([Inputs],[Double]) you can convert it to [(Inputs,Double)] with zip
22:30:20 <Saizan> but that has to happen before you apply foldl to it
22:30:23 <saml> then you can convert to Map too
22:30:58 <Saizan> except that Map doesn't make much sense here.. we're not using lookup or insertion..
22:31:10 <Saizan> and we most likely care about the order
22:32:26 <Saizan> tombee: the point is that you can only fold over a list, not a tuple of lists
22:32:38 <tombee> gotcha yes, I understand where I went wrong there.
22:33:16 <fasta> Does this website with java applet work for anyone? http://www.ics.uci.edu/~eppstein/projects/pairs/Applications/RayDiagram/
22:34:03 <EnglishGent> is there a way to shuffle a list in Haskell? it seems to me that using random numbers must involve state - so there should be no way to write shuffle :: [a] -> [a] , only shuffle :: [a] -> m [a]
22:34:46 <Saizan> you can write shuffle :: StdGen -> [a] -> [a]
22:34:49 <xerox> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
22:35:03 <fasta> EnglishGent, you can write [a] -> [a], but it would destroy everything Haskell stands for ;)
22:35:20 <xerox> there Oleg writes Saizan's
22:35:59 <Saizan> (so m = StdGen -> there, but it looks more innocent)
22:36:19 <saml> why do you want to shuffle a list?
22:37:24 <saml> create a monad that takes a Set and outputs random element when you call next :: YourMonad a
22:37:35 <EnglishGent> saml - not for any practical reason - I'm thinking about the algebra of permutators
22:37:57 <EnglishGent> how it ought to form a group with id as the zero & composition as the group operation
22:38:24 <xerox> Cale has got some articles on ``permutations in Haskell'' on the analogical engine
22:38:33 <EnglishGent> oh? linky? :)
22:38:52 <Veinor> you can definitely write shuffle :: [a] -> [a]
22:39:00 <Veinor> it's just that it will always provide the same output for the same input
22:39:14 <Cale> actually, those are Robin's posts :)
22:39:28 <Cale> http://analogical-engine.com/wordpress/
22:39:31 <EvanR-work> what is the type of main again?
22:39:42 <Veinor> I think it's IO ()
22:39:51 <EvanR-work> so its not a function
22:39:53 <Cale> http://analogical-engine.com/wordpress/?page_id=57 -- there are convenient links from here :)
22:40:00 <Cale> EvanR-work: that's right
22:40:11 <xerox> Cale: you should enable more readable urls =)
22:40:35 <Cale> xerox: Except that at this point, that would be a lot of work.
22:40:50 <EvanR-work> then this IO tutorial is bugging me, which alegorically describes main as main :: RealWorld -> ((), RealWorld)
22:41:15 <xerox> Cale: work.. I wonder how do you find the will to write so much!
22:41:16 <Cale> EvanR-work: Yes, I hate that analogy
22:41:40 <Cale> xerox: Well, writing isn't so annoying as dealing with stupid technical issues.
22:41:42 <HaskellLove> What do you start with when u design a language?... I thought i will research whole 2010 and 2011 start bnf design, but i was told that is wrong it is just "syntax"...
22:41:45 <Veinor> I don't think it works for main, but I like it for IO in general
22:42:12 <Cale> EvanR-work: I suppose if you want to buy into that analogy, you imagine that the Haskell runtime system passes the real world into main for you
22:42:17 <EnglishGent> thanks :)
22:42:34 <EvanR-work> HaskellLove: yeah syntax is not that important... what does the language do, how fantastically will it do it, and why should it exist because there are already a million languages probably that do it
22:42:36 <Cale> EvanR-work: But I think it's a dumb analogy and wish that it would go away.
22:43:07 <Cale> EvanR-work: A better analogy is to imagine that a value of type IO t is effectively a (higher-order) syntax tree for an IO computation.
22:43:09 <quicksilver> Veinor: it's a poor analogy, for it implies that only the IO action can change the RealWorld
22:43:11 <HaskellLove> EvanR-work I should start with semantics first and derive bnf from that?
22:43:28 <quicksilver> Veinor: whereas, in fact, the RealWorld evolves independently o the IO computation and along side it.
22:43:45 <Cale> EvanR-work: and that the Haskell runtime system contains an impure executor which pattern matches on that and carries out the actual actions.
22:44:24 <EvanR-work> so far i have just imagined IO to be a monad with no definition, because its outside the scope of the language (like.. an operating system)
22:44:37 <Cale> EvanR-work: That's not a bad way of thinking.
22:44:39 <zygoloid> EvanR-work: that's a reasonable way to look at it, i think
22:45:03 <Cale> EvanR-work: But you could also imagine that there's a datatype like:
22:45:06 <Cale> data IO a where
22:45:10 <Cale>   ReturnIO :: a -> IO a
22:45:17 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
22:45:23 <Cale>   GetChar :: IO Char
22:45:29 <Cale>   PutChar :: Char -> IO ()
22:45:35 <Cale>   ... other IO primitives ...
22:46:00 <Cale> and when you use those functions, you're just building up a datastructure which the runtime system interprets
22:46:05 <zygoloid> my preference is to imagine 'data IOFunctor a where GetChar :: IO Char; PutChar :: Char -> IO (); ...' with IO being the free monad over that functor
22:46:18 <Cale> yes
22:47:12 <EvanR-work> that would probably make sense to me if i had a handle on data yet
22:47:32 <quicksilver> zygoloid: you presumably need to first imagine it into a free functor by including "where FMap :: (a -> b) -> IO a -> IO b"
22:47:43 <Cale> Yeah, it doesn't help that it's actually a GADT, which is an extension.
22:47:51 <zygoloid> quicksilver: right :) i'm imagining that's behind the ...
22:48:10 <quicksilver> EvanR-work: then take a slightly less formal view and simply thing of an IO action as a series of "instructions"
22:48:26 <zygoloid> alternatively, 'data IOFunctor a = GetChar (Char -> a) | PutChar Char (() -> a) | ...'
22:48:29 <quicksilver> EvanR-work: where an "instruction" is a informal notion of talking to the rest of the computer
22:48:30 <tombee> Saizan: I'm still struggling to foldl over that list, could you give me any pointers? :)
22:48:38 <quicksilver> EvanR-work: (like printing something, or checking the keyboard)
22:48:53 <tombee> Saizan: you said that I need to give foldl 3 params
22:48:56 <quicksilver> EvanR-work: and believe that the haskell runtime has some magic way of "running" these instructions when you attach them to "main".
22:48:56 <Saizan> tombee: my paste doesn't typecheck?
22:49:01 <quicksilver> EvanR-work: (but never runs them unless you do that)
22:49:10 <EvanR-work> so i see in the above that IO would have only a as data, and the rest is functions that operate on datas?
22:49:19 <EvanR-work> i mean IOs
22:49:20 <Saizan> tombee: foldl takes a combining function, an initial value, and the list to fold over
22:49:32 <quicksilver> well "IO a" has the property that if you do run all the instructions you somehow get an 'a' out the end.
22:49:36 <quicksilver> and, yes, that's all you get.
22:49:52 <tombee> Couldn't match Weights against Neuron apparently Saizan
22:49:55 <EvanR-work> and the functions are strung together with >>=
22:50:21 <Saizan> in the above description GetChar etc aren't functions themselves, they are constructors, things from which you build values
22:50:36 <EvanR-work> oh really
22:51:31 <Saizan> tombee: oh, right, if forgot to change the result type of learnEpoch
22:52:01 <tombee> Ah, so I get a new Neuron
22:52:02 <tombee> got you.
22:52:09 <Saizan> right
22:52:09 <quicksilver> EvanR-work: or, in the language I was using they're called "instructions"
22:52:17 <quicksilver> EvanR-work: the point it, they're not functions.
22:52:34 <quicksilver> EvanR-work: they're actions / instructions / procedures / whatever word you want to use which isn't 'function'
22:52:50 <Saizan> i guess it makes more sense if you're familiar with the concept of an Abstract Syntax Tree
22:56:25 <quicksilver> "commands" is another word.
22:56:47 <quicksilver> I mean, the word isn't important, except that if you're trying to understand the difference between these things and functions, it's good not to use the word 'function' ;)
22:57:10 <ivanm> quicksilver: what aren't functions? values of type IO blah ?
22:57:42 <quicksilver> ivanm: yes.
22:58:29 <EvanR-work> quicksilver: wait a minute.
22:58:34 <Cale> Yeah, functions have parameters, and IO actions do not.
22:58:59 <EvanR-work> putStrLn :: IO String -> IO ()
22:59:04 <EvanR-work> looks like a function to me
22:59:12 <Cale> *that* is a function
22:59:17 <aavogt> @type putStrLn
22:59:18 <lambdabot> String -> IO ()
22:59:21 <EvanR-work> oh
22:59:24 <Cale> But putStrLn "hello" is not
22:59:43 <EvanR-work> no, its an IO ()
22:59:47 <Cale> right
23:00:03 <EvanR-work> and getChar is IO Char
23:00:51 <EvanR-work> gah. *dumps yet another tutorial because i dont want to think of things as burritos*
23:01:04 <ivanm> IO actions are just special values that happen to do stuff when (transitively) called from the uber-magic value "main"
23:01:21 <ivanm> EvanR-work: heh
23:01:26 <ray> a monad tutorial is like a sausage factory
23:01:33 <ivanm> someone actually made a burrito tutorial? :o
23:01:34 <ivanm> ray: lol
23:01:43 <ivanm> @remember ray a monad tutorial is like a sausage factory
23:01:43 <lambdabot> Okay.
23:01:57 <gwern> @quote monad.tutorial
23:01:57 <lambdabot> ray says: a monad tutorial is like a sausage factory
23:02:01 <gwern> @flush
23:03:26 <quicksilver> EvanR-work: there is a distinction between understanding monads, and understanding IO
23:03:39 <quicksilver> EvanR-work: my comments were intended to help you understand IO without making any attempt to generalise the abstraction.
23:03:51 <EvanR-work> yes, i was looking at an io tutorial
23:03:54 <quicksilver> if you wish to understand monads in general, I quite like "You could have invented monads"
23:04:07 <quicksilver> and I think Cale wrote a good one but I don't recall the title.
23:04:35 <EvanR-work> im trying to understand program structure as a whole, which seems to begin at main :: IO ()
23:05:12 <int-e> cale wrote http://www.haskell.org/haskellwiki/Monads_as_Containers and http://www.haskell.org/haskellwiki/Monads_as_computation I think.
23:05:24 <EvanR-work> but an action can invoke a function which delves into other realms like sockets or state or ... just regular functions
23:05:38 <EvanR-work> and you eventually return to the IO
23:05:39 <Cale> yes, I wrote those
23:05:47 <gio123> Cale: hi
23:05:51 <Cale> hi
23:05:58 <gio123> Cale: pm :)
23:07:06 <Saizan> btw, there's no automatic way to derive what a normal form should be given an algebra, right?
23:07:24 <int-e> EvanR-work: IO is Haskell's sin box where we put all the nasty things like mutable variables, file access, pressing red buttons and so on.
23:07:54 <tombee> Saizan: all appears to type check now, and added the 'delta'
23:08:09 <tombee> http://github.com/tombee/Perceptron/blob/master/perceptron.hs
23:08:14 <jmcarthur> EvanR-work: you can think of the architecture of haskell programs as a pure "core" with an impure "shell"
23:08:19 <tombee> any advice on style/etc. welcome :)
23:08:40 <jmcarthur> assuming you call IO impure
23:08:50 <EvanR-work> jmcarthur: and this shell consists of functions which return IO, or are we talking about other monads
23:09:00 <aavogt> but you can certainly write your code all in IO
23:09:06 <aavogt> but please don't
23:09:10 <jmcarthur> i really mean the execution of the IO actions to be the impure part
23:09:17 <EvanR-work> ah
23:09:19 <jmcarthur> which is not something you actually do in your code
23:09:44 <Cale> Evaluation of Haskell expressions is pure, execution of IO actions is not.
23:09:48 <EvanR-work> ah... Network returns IO stuff to...
23:09:51 <jmcarthur> the IO actions, of course, can pass through the pure part of your program without tainting them
23:09:57 <ray> IO launches the nuclear missiles
23:09:57 <jmcarthur> just can't be executed there
23:10:04 <Cale> Even evaluation of expressions which produce IO actions is pure.
23:10:15 <Cale> So, it's really two completely separate processes.
23:10:30 <EvanR-work> i heard somewhere that from inside a pure function you cant 'use' IO
23:10:35 <Cale> that are interleaved to make a Haskell program run
23:10:43 <Cale> EvanR-work: well, that's essentially true
23:10:51 <ray> it's the difference between typing a page of orders that says "ORDERS: launch the nuclear missiles" and launching the nuclear missiles
23:10:55 <jmcarthur> you can cheat
23:10:58 <HaskellLove_> EvanR-work cant u do that with >>=?
23:11:04 <aavogt> @hoogle trace
23:11:04 <lambdabot> Debug.Trace trace :: String -> a -> a
23:11:04 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
23:11:04 <lambdabot> module Debug.Trace
23:11:06 <Cale> EvanR-work: You can't write expressions that cause the execution of IO actions (at least without low-level primitives which are dangerous to use)
23:11:15 <jmcarthur> HaskellLove_: >>= eventually has to form a chain up to main :: IO ()
23:11:23 <EvanR-work> i guess the explanation of that is that unless the function returns IO something, it cant really eventually do the action
23:11:31 <EvanR-work> okay
23:11:32 <Cale> EvanR-work: right
23:11:33 <jmcarthur> HaskellLove_: if you can't trace a path back to main that way then it will not be executed, essentially
23:12:10 <Cale> EvanR-work: But every function of type a -> IO b can also be thought of as a pure function which takes a value of type a, and produces some action value without doing any effects.
23:12:22 <EvanR-work> right
23:12:27 <Cale> (it's executing the action, not evaluating the function which has the effects)
23:12:51 <EvanR-work> now what about the issue of other monads, i suppose its ok to use monads for their particular purposes even inside a pure/'non IO' function
23:13:07 <EvanR-work> because IO is special
23:13:08 <jmcarthur> EvanR-work: right. they are not IO :)
23:13:19 <jmcarthur> IO isn't all the special though
23:13:29 <EvanR-work> IO causes your program to run
23:13:31 <EvanR-work> for one thing
23:13:32 <jmcarthur> it just wraps special primitives
23:13:49 <jmcarthur> s/wraps/abstracts/
23:13:59 <EvanR-work> i see what youre saying
23:14:07 <Cale> EvanR-work: The IO values themselves you can think of as being mundane, inert data. It's what the executor does with them which is special.
23:14:11 <jmcarthur> IO doesn't have different semantics from any other monad, is all i mean
23:14:12 <EvanR-work> yes
23:14:24 * EvanR-work graduates a little
23:14:32 <jmcarthur> the primary difference is that IO doesn't have a pure "run" function
23:14:42 <jmcarthur> like runState, runReader, etc.
23:14:52 <int-e> rts :: IO a -> LaunchMissiles (I may have misunderstood the purpose of IO just a little ...)
23:15:01 <ray> data IO a = magic
23:15:48 <EvanR-work> is it possible to extend IO with more data constructors from inside the program... or is that a malformed question
23:16:19 <Cale> EvanR-work: essentially, via the FFI
23:16:35 <jmcarthur> if you pretend IO is a GADT, the FFI extends that GADT
23:16:36 <EvanR-work> launchMissiles :: Country -> IO ()
23:16:41 <Cale> EvanR-work: Well, there are a number of ways you can imagine it working
23:16:41 <EvanR-work> launchMissiles = ...
23:16:54 <Cale> You could also imagine that there's just a sufficiently-general data constructor
23:17:06 <ray> depends, is it launchMissiles or unsafeLaunchMissiles?
23:17:06 <EvanR-work> and use it as a primitive
23:17:49 <EvanR-work> runrawx86assembly :: String -> IO ()
23:17:51 <Cale> EvanR-work: Well, the constructors already in the datatype are sufficiently compositional that you rarely need to extend it, since you can define more complicated things in terms of simple ones
23:18:31 <EvanR-work> okay
23:22:17 <tombee> Saizan: thanks for your help btw (I must go for a while now :))
23:28:31 <bsod666> does anyone here know prolog?
23:29:05 <bsod666> i checked the prlog channel but it appears to be rather stagnant
23:30:21 <saml> yah i know prolog is sql
23:30:41 <bsod666> ?
23:31:37 <bsod666> im trying to find an equivalent of a haskell statement i have
23:32:03 <paul424> who could help me resolve the depend with cabal : hhttp://pastebin.com/d6a71b81
23:32:06 <paul424> http://pastebin.com/d6a71b81
23:32:30 <dcoutts> paul424: you need gtk2hs installed
23:32:43 <paul424> hmm me so dumb
23:32:50 <saml> cabal install leksah
23:32:59 <jix> is there a FRP library that uses Int as Time and has a fixed stepping of 1?
23:33:00 <saml> bsod666, what's haskell statement?
23:33:46 <dcoutts> paul424: yes, then after that, as saml says, you can use the cabal program for the remaining deps since those ones are on hackage
23:34:27 <bsod666> match l n o = length(filter(== n)l)== o
23:36:08 <saml> o == l.countNumberOfIdenticals(n)
23:36:54 <knobo> Is there any benefit of writing "data Foo a = Foo a" over "data Foo = Foo String" if I'm not using anything else but strings?
23:37:37 <knobo> I might consider using ByteString in the future. I just don't know.
23:38:56 <bsod666> saml how would i run that?
23:39:11 <zygoloid> knobo: does the type 'Foo a' make sense for 'a' anything other than String?
23:39:15 <bsod666> o == l.countNumberOfIdenticals(n) .?
23:39:32 <knobo> zygoloid: It could maybe in the future.
23:39:59 <saml> bsod666, sorry. that was Java. i do not know Prolog
23:42:56 <bsod666> lol ok
23:48:30 <bastl> ivanm: sorry, had a number of meetings this afternoon. Your example to draw graphs from ghci didnt work directly. I could tweak it to run with Xlib, but not with Gtk. I also had to download the latest version ...
23:49:42 <ivanm> bastl: check what outputs your dot supports by running "dot -Txxx"
23:49:47 <ivanm> gtk should be there
23:49:51 <ivanm> if not, then gtk won't work ;-)
23:49:57 <ivanm> @time
23:49:57 <lambdabot> Local time for ivanm is Fri Dec 11 01:46:08
23:50:21 <bastl> @time
23:50:43 <bastl> hm
23:51:00 <bastl> yeah thats the output i got for Canvas Gtk.
23:51:11 <bastl> And no, i donzt have gtk among dot's outputs. ...
23:55:58 <wm_eddie_> Thank you who ever wrote Monad (sans metaphors) in haskellwiki
23:56:22 <pastah_rhymez> @where Monad
23:56:23 <lambdabot> I know nothing about monad.
23:56:26 <pastah_rhymez> @where Monads
23:56:26 <lambdabot> http://www.haskell.org/all_about_monads/html/
23:58:13 <wm_eddie_> That is way too long.
23:58:22 <wm_eddie_> hence the problem.
23:59:41 <pastah_rhymez> wm_eddie_: nah, i like that
