00:00:07 <manju> I am stumped by the SC presentation
00:00:22 <Saizan> as opposed to j which is line noise for everyone?:)
00:00:25 <manju> 37 times lesser code than C and also 2.68x faster performance
00:00:31 <manju> Saizan: heh
00:00:42 <manju> yeah, I saw J :-)
00:00:49 <path[l]> whats j?
00:01:00 <GNU\colossus> I'm kind of stuck with my assignment, I tried to sum up the problem here: http://pasted.at/d8f641b6ec.html - is anyone of you able to help?
00:01:30 <Veinor> cnwdup: skipAtLeastOne
00:02:20 <copumpkin> GNU\colossus: start by writing the type
00:02:47 <copumpkin> GNU\colossus: also, asking haskell to derive Eq for you will probably help :)
00:02:52 <c_wraith> Yow.  that's an ugly problem.  Lots of cases, and lots of doing stuff yourself
00:03:08 <c_wraith> copumpkin: I'm pretty sure that problem definition doesn't allow you to ask it to derive Eq
00:03:12 <GNU\colossus> copumpkin: I already implemented Eq for the type
00:03:22 <GNU\colossus> copumpkin: that was part of the assignment
00:03:22 <copumpkin> damn them :P
00:03:25 <copumpkin> lol ok
00:04:07 <manju> GNU\colossus: the answer is in another pastebin
00:04:10 <GNU\colossus> copumpkin: my problem is that I also have to evaluate an expression as LT another expression if it's a subexpression of the latter
00:04:12 <copumpkin> lol
00:04:23 <copumpkin> GNU\colossus: start now by writing out the cases
00:04:44 <copumpkin> GNU\colossus: x `isSubExprOf` (Neg y) = ?
00:04:54 <manju> GNU\colossus: http://pastebin.com/d7fc92358 <- if you look at this it maybe cheating :-)
00:05:37 <copumpkin> that looks wrong
00:05:45 <manju> copumpkin: heh
00:05:47 <copumpkin> oh I see
00:06:22 <copumpkin> it does stuff in a weird and somewhat redundant way, it seems
00:06:38 <manju> I wouldn't know, I was trying to look for the definition Opd
00:06:50 <manju> and it was one of the first hits
00:07:45 <Saizan> i don't get the Second and First suffixes
00:07:50 <Saizan> but otherwise it looks sane
00:07:58 <GNU\colossus> thanks for the tip, I'll try grokking what's going on in partOf{First,Second} for a whileâ€¦
00:08:05 <Saizan> instead of trying to both recurse down and match the structure at once
00:08:37 <manju> what is Opd ?
00:08:45 <copumpkin> operand?
00:08:57 <manju> is that a keyword ?
00:09:19 <Saizan> it's just a constructor name, it's in the Expr declaration above
00:09:33 <idnar> I dunno, a lot of those J solutions look awesome
00:09:36 <idnar> if only I could read them...
00:10:01 <manju> idnar: heh
00:10:18 <GNU\colossus> manju: my personal guess is its short for "Operand" ;)
00:10:37 <manju> GNU\colossus: ok
00:11:34 <Saizan> if we had the zipper for Expr we could use "fold . map (Any . partOfSecond x) . duplicate"
00:13:34 <Saizan> which is actually fold . extend (..)
00:18:28 <copumpkin> it'd be pretty simple to write a CoKleisli w Arrow instance right?
00:19:15 <Saizan> yes
00:22:33 <Saizan> you can also make an Arrow instance for w a -> m a with a distributive law between w and m
00:23:32 <copumpkin> fun
00:35:48 <ClaudiusMaximus> what's the cure for duplicate instance errors?
00:35:57 <copumpkin> don't duplicate instances
00:35:58 <Saizan> newtypes
00:35:58 <ivanm> ClaudiusMaximus: don't?
00:36:32 <copumpkin> two useless answers and one helpful one
00:36:34 <copumpkin> I like it
00:36:43 <ClaudiusMaximus> hmm
00:36:53 <ClaudiusMaximus> maybe some context will help you to help me :)
00:37:00 <copumpkin> usually does
00:37:19 <mxc> what was the other useless answer?
00:37:34 <copumpkin> both me and ivanm telling him not to do it
00:38:04 <mxc> oh, i thought there were two distinct useless answers
00:38:09 <copumpkin> @slap ivanm_and_copumpkin
00:38:09 * lambdabot smashes a lamp on ivanm_and_copumpkin's head
00:38:32 <copumpkin> damn right
00:39:33 <ClaudiusMaximus> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5209#a5209
00:40:03 <copumpkin> how do they differ?
00:40:23 <ClaudiusMaximus> one has a PositiveT in the context, one has a NegativeT in the context
00:40:44 <copumpkin> oh, contexts don't distinguish them
00:40:57 <ClaudiusMaximus> ok, then they don't differ
00:41:29 <copumpkin> OverlappingInstances might make it work
00:41:52 <copumpkin> and maybe IncoherentInstances :)
00:41:53 <ClaudiusMaximus> what magical tricks can i do to get this to work?  reify the types and use case? (i've never used this library or type families before)
00:41:57 <copumpkin> all the yummy ones ;)
00:43:14 <copumpkin> did those help?
00:43:28 <copumpkin> I can never remember when IncoherentInstances really helps
00:43:30 <Saizan> ClaudiusMaximus: do you have a way to decide if you should use one or the other just by looking at the types?
00:44:08 <Saizan> OverlappingInstances won't help here since no instance head is more general than the other, they are equal
00:44:09 <copumpkin> oh yeah, conceivably something could be both Positive and Negative
00:44:59 <copumpkin> ClaudiusMaximus: maybe add a dummy "phantom type" parameter to help distinguish them?
00:45:37 <ClaudiusMaximus> i think i need to read more papers on what type families are :)
00:46:56 <Saizan> i generally use this trick http://okmij.org/ftp/Haskell/isFunction.lhs but it's not always applicable, note that now you can just use ~ instead of TypeCast
00:47:53 <Saizan> http://okmij.org/ftp/Haskell/typecast.html <- this page is quite helpful if you need to guide instance resolution
00:50:26 <ClaudiusMaximus> thanks for the suggestions, but i fear i've waded in too deep again..
00:51:48 <Saizan> when you get where you need oleg's help you're in quite deep waters, yeah :)
00:55:37 <pelotom_> QQ: what's the difference between abstract algebra, universal algebra and category theory?
00:56:56 <pelotom_> or is it all just different flavors of abstract nonsense?
00:57:29 <mjrosenb> pelotom_: i took a class called abstract algebra.  it was basically group theory, ring theory and field theory.
00:57:45 <opqdonut> yeah abstract algebra usually refers to just that
00:57:54 <opqdonut> but in this context it might be something different, beats me
00:58:13 <opqdonut> pelotom_: a universal algebra is a category-theoretic construction, basically
00:59:13 <pelotom_> so all concepts of abstract algebra can be formulated in category theory but not vice versa?
00:59:34 <pelotom_> err, universal algebra
01:00:26 <opqdonut> yeeeaaah
01:00:36 <opqdonut> i mean, that certainly is true, but also a bit nonsensical :)
01:00:50 <pelotom_> why so?
01:01:09 <opqdonut> well, they're different things. universal algebra is specific, category theory is general
01:01:15 <opqdonut> anyway, I can recommend a book
01:01:23 <opqdonut> "Foundations of Programming Languages"
01:01:28 <manju> is it possible to write a library in haskell and call it from C or C++ ?
01:01:37 <pelotom_> cool, thanks :)
01:01:43 <opqdonut> tackles all sorts of stuff relating to algebras, typing and even a bit of CT
01:01:49 <opqdonut> it's very easy to read IMO
01:01:55 <Beelsebob> manju: absuletly
01:01:58 <opqdonut> big book, lots of examples, slow start
01:02:21 <Beelsebob> manju: look up the documentation on the FFI â€“ you need to do a couple of tricks to make sure your library initialises the ghc runtime etc
01:02:23 <Beelsebob> but it'll work fine
01:02:39 <opqdonut> it manages to show why CT matters, which hardly any documents do
01:02:53 <pelotom_> opqdonut: that sounds fantastic
01:02:59 <manju> Beelsebob: ok, are there any real world libraries which do this ?
01:03:08 <opqdonut> also has good stuff on scott domains (all this least-fixed-point stuff etc), which is nice
01:03:14 <opqdonut> and simpler to understand than CT
01:03:47 <pelotom_> opqdonut: this book? http://www.amazon.com/Foundations-Programming-Languages-Computing/dp/0262133210
01:03:50 <Beelsebob> manju: I've done it before in production code, but not any that's been released as FOSS
01:04:05 <manju> Beelsebob: ok
01:04:18 <opqdonut> pelotom_: yes.
01:04:29 <opqdonut> wow, price is a bit steep
01:04:42 <shambler> oh my
01:04:48 <opqdonut> i've had a copy on loan from the uni library for almost a year now :)
01:07:25 <pelotom_> opqdonut: yeah, I'm gonna try to find it at a library. thx for the tip
01:08:12 <aeron> I'm using Control.Monad.Error and I just tried compiling and I get undefined references.. Is there a -package I should add?
01:08:30 <aeron> specific to Control.Monad.Error, that is
01:09:13 <opqdonut> try the --make for ghc?
01:10:10 <aeron> opqdonut: why is that I have to use -package for parsec, but --make applies here? I'm completely new to using more than ghci so bear with me :)
01:10:44 <opqdonut> frankly, i have no idea. experience says that --make sorts out all sorts of linking errors
01:10:53 <aeron> ha! works for me :)
01:11:53 <fasta> Beelsebob, did you find an elegant way to build the library in the end?
01:12:01 <cx> good morning everyone
01:12:23 <Beelsebob> fasta: not really, just throwing make files at it
01:12:35 <Beelsebob> and figuring out the necessary incantations to make ghc works is... hard
01:12:54 <fasta> Beelsebob, yes, I basically parse the ghc -M output ;)
01:16:52 <c_wraith> what's the highest operator precedence?
01:17:29 <c_wraith> (numerically, not what operator has the highest precedence)
01:17:52 <EnglishGent> hi cx
01:17:56 <fasta> c_wraith, 9.
01:18:01 <EnglishGent> morning all :)
01:18:02 <c_wraith> thanks fasta
01:18:09 <fasta> c_wraith, see report.
01:18:29 <o-_-o> some universities and instructors are putting their lectures online, is there any haskell course that is available online ?
01:18:38 <c_wraith> @where report
01:18:38 <lambdabot> http://www.haskell.org/onlinereport/
01:18:46 <EnglishGent> there's the Simon-Peyton Jones videos
01:18:52 <EnglishGent> if that help o-_-o
01:19:12 <EnglishGent> there'a also some good free textbooks on line
01:20:02 <o-_-o> EnglishGent: http://blip.tv/file/324976
01:20:05 <o-_-o> this one ?
01:20:13 * EnglishGent looks
01:20:31 <EnglishGent> yes
01:21:04 <EnglishGent> if you want - I have notes crossreferencing the time-indicies & the slide / part covered
01:21:08 <EnglishGent> your welcome to a copy :)
01:22:11 <EnglishGent> has anyone successfully installed the cabal magic library?
01:22:14 <o-_-o> EnglishGent: thanks
01:22:21 <EnglishGent> yw :)
01:22:59 * EnglishGent stares blearrily at errors & thinks he needs a coffee before attempting to do battle with cabal
01:23:00 <o-_-o> sorry, but I don't understand what you mean by "crossreferencing the time-indicies" ? :-)
01:23:20 <o-_-o> EnglishGent: how can I get the notes from you ?
01:23:40 <EnglishGent> I'll dcc you them
01:23:43 <EnglishGent> hang on
01:25:32 <o-_-o> the sheer amount of information on haskell is staggering
01:25:40 <o-_-o> I am intimidated
01:26:12 <o-_-o> there is so much to learn, and I am stuck in 3rd chapter of real world haskell
01:26:20 <cads> oh you're boned
01:26:39 <o-_-o> heh
01:27:11 <cads> say "goodbye and thanks for all the fish" to your sanity, because soon it'll be replaced by a graph reduction machine, up to an isomorphism that is
01:27:22 <o-_-o> thanks for the encouragement :)
01:27:42 <c_wraith> it's not *that* bad.  sometimes your sanity still sends fish
01:28:05 <cads> I actually speak of a glorious transformation which if you survive you'll soar out of like a phoenix, and speak in tongues of morphisms and functors
01:28:11 <c_wraith> ...  Though I'm up stupidly late working on a "crash course to surviving haskell" for work.
01:28:23 <c_wraith> ...  *for*
01:28:25 <o-_-o> by that time haskell would've paved a highway over my sanity
01:28:37 <c_wraith> Ok, if my grammar has failed that much, it's time to stop coding.
01:29:01 <EnglishGent> o-_-o btw - by cross referencing the time-indices I mean the thing at the bottom of the video showing how many minutes/seconds have played
01:29:15 <o-_-o> c_wraith: can you share that ?
01:29:25 <o-_-o> EnglishGent: ah...now it makes sense
01:29:30 <EnglishGent> so now with the notes you just jump to any section / side - as my notes tell you what time it starts at
01:29:45 <o-_-o> cads: I look forward to it :)
01:29:46 * EnglishGent happy to let anyone who wants a copy have one :)
01:30:33 <c_wraith> o-_-o: It's intended as an interactive demo.  Lots of small snippets of code to load with ghci and demo.  I'm not sure how well it would stand alone
01:31:07 <o-_-o> c_wraith: that is interesting
01:31:28 <c_wraith> also, I'm only just now getting to data declarations.
01:31:30 <c_wraith> There's a ways to go
01:31:52 <o-_-o> ok
01:32:35 <c_wraith> still, if it goes over well, I'll put it online somewhere with a reasonable description of how to play with the various snippets
01:32:45 <c_wraith> ....  once I finish it.
01:32:59 <o-_-o> c_wraith: thanks, I look forward to it
01:36:42 <cads> o-_-o, it's not really that bad.. you do have to read computer theory papers, but the awesome thing about knowing haskell is that computer theory papers are pretty much all written in haskell ;)
01:37:21 <o-_-o> cads: ok, I want to learn functional programming, haskell seemed like a nice place
01:38:02 <cads> indeed
01:38:16 <Saizan> @where LYAH
01:38:16 <lambdabot> http://www.learnyouahaskell.com/
01:38:21 <Saizan> good way to start
01:38:22 <o-_-o> and I heard the community was very friendly :-)
01:38:35 <o-_-o> yeah I started with LYAH
01:38:45 <cizra> o-_-o: Extremely friendly.
01:38:47 <o-_-o> rather am using LYAH
01:38:58 <cizra> o-_-o: They've put up with my dumb questions for AGES.
01:39:48 <o-_-o> cizra: definitely, I am at a stage in haskell where I don't know how to put the parens correctly and they've debugged my code
01:40:06 <Saizan> yeah, come here when you're stuck/confused, when the US is awake it can be crowded but we strive to give an helpful answer to everyone :)
01:40:26 <o-_-o> thankfully I am asleep when the US is awake
01:42:40 <cads> lyah is hilarious but terrible cross contamination from ruby community of bespectacled stoner fuzz-beard wizards
01:43:11 <cads> I died a little reading it
01:43:12 <Saizan> ah, yeah, i got confused by the use of parentheses at the start too, in imperative languages you use them to group arguments to functions, here only to group function applications
01:45:10 <Saizan> it's more consistent with what happens with infix operators
01:45:50 <Saizan> C-like: (a + b) vs. f(a,b);  Haskell-like: (a + b) vs. (f a b)
01:47:18 <cads> @pl \(x, y)-> x^2 + 2 * y
01:47:18 <lambdabot> uncurry ((. (2 *)) . (+) . (^ 2))
01:47:38 <o-_-o> I copy the sentences from this channel and e-mail it to myself
01:47:55 <o-_-o> "<Saizan> ah, yeah, i got confused by the use of parentheses at the start too, in imperative languages you use them to group arguments to functions, here only to group function applications" <- this goes in
01:49:15 <cads> Saizan, I think I could just barely show that formally, the point-free version of that function above is the same as the lambda expression
01:50:12 * hackagebot upload: darcswatch 0.4 - Track application of Darcs patches (JoachimBreitner)
01:50:45 <Saizan> so something like "f(a,g(c,d))" translates to "f a (g c d)"
01:51:24 <Saizan> cads: what do you mean?
01:52:39 <Saizan> though f(a,g(c,d)) can be put anywhere and still be a single expression, while if you write "h f a (g c d)" you're passing 3 arguments to h and you want "h (f a (g c d))" instead
01:54:34 <cads> well, by applying some relations, I think I could write a proof that those are the same by transforming the one statement into the other... which is kind of the neat thing about functional programming languages
01:56:19 <o-_-o> Saizan: that is extremely helpful
01:56:24 <Saizan> ah, yeah :)
01:56:35 <fasta> cads, it seems the proof of that statement would be something like simp; reflexivity in Coq ;)
01:57:29 <opqdonut> :)
01:57:39 <cads> yeah, my proof would be a sketch based on handwaving, till I looked up the relevant transform rules
01:58:40 <fasta> I think proving something in Coq is not an order of magnitude more difficult than proving the same thing on paper.
01:58:41 <Saizan> well, i think you need eta-conversion in the equality
01:59:16 <Saizan> but then you just need to expand the definitions in the pointfree version
01:59:55 <cads> the section of a composition operation is still wierd to me
02:00:22 <cads> actually, this is the first time I've really though about what (. f) means :P
02:01:42 <cads> is it correct form to look to the standard for zenlike understanding of these kinds of things, or are there better sources?
02:01:52 <Saizan> (. f) = \g-> (. f) g = \g -> g . f = \g -> \x -> (g . f) x = \g x -> g (f x)
02:02:47 <Saizan> you mean the haskell98 report with the definitions of the operators?
02:04:01 <cads> hehe, I'll assume the answer is "yes you idiot consult the report", and stop digging my hole :)
02:04:21 <fasta> cads, reading the standard at least once will not hurt.
02:04:57 <fasta> cads, in the end it is the only credible source.
02:05:13 <Saizan> no, i just didn't know what you were referring to with standard :) however conal's post on what he calls "semantic editor combinators" are also on this topic
02:05:21 <Saizan> *posts
02:06:51 <o-_-o> The Implementation of Functional Programming Languages <- How is this book ?
02:07:07 <fasta> o-_-o, better than average.
02:07:33 <fasta> o-_-o, but you don't need it to program in Haskell.
02:07:38 <cads> Saizan, was this his blog, or in here?
02:07:46 <Saizan> cads: the blog
02:07:49 <o-_-o> fasta: ok
02:11:58 <ksf> http://denise.dreamwidth.org/23600.html
02:12:43 <ksf> the strange thing about this is that the haskell community seems to fulfil at least 80% of the requirements, but we fail to derive a profit from it.
02:14:22 <ksf> in fact, there are a thousand new faces coming here, each day, voluntarily, and we're sending them off doing the same exercises that gazillions of them did before, instead of pooling them to do something productive.
02:14:26 <fasta> ksf, the problem is still tool-support.
02:14:43 <ksf> what tools?
02:14:50 <fasta> ksf, good compilers for example.
02:15:09 <ksf> I'd choose ghc over gcc or javac any time of the day.
02:15:38 <fasta> ksf, probably you have more experience with C than me then ;)
02:16:04 <fasta> ksf, I never found a compiler bug in gcc, for example.
02:16:06 <ksf> ...well I guess it mostly bogs down to choosing haskell over c and java.
02:16:29 <ksf> I've found two or three in javac
02:16:34 <cads> Saizan, conal's understanding never ceases to amaze me, I can only imagine the kind of things the thinks about when he think about the semantics of some given code
02:16:46 <fasta> ksf, well, so, maybe all tools suck ;)
02:16:46 <ksf> ...and four or five bugs in jvm implementations of handsets.
02:16:50 <cads> he can get philosophical with that stuff
02:17:30 <ksf> the problem there being that you can't ever hope for your issue to be fixed on time for product release... javac had a queue going into the millions, and the jvms were already installed.
02:17:46 <ksf> "let them get a new firmware" isn't a thing you want to tell your boss.
02:17:57 <Saizan> cads: i personally don't like too much the philosophical detours, but he does have interesting points :)
02:18:25 <fasta> ksf, if everything had a solid upgrade core, there wouldn' t be a problem.
02:19:16 <ksf> yep. so we're can't involve newbies because our tools suck, which suck because we don't have the manpower to fix it, which is because we don't involve newbies?
02:19:33 <cads> if your system is something that might be called to do funky temporal logics and represent the arrow of time and such, the way you understand might well get philosophical :)
02:20:09 <Nafai> ksf: What are the productive things you think the Haskell community could involve newbies in?
02:20:31 <fasta> ksf, yes, it is sort of like that.
02:21:14 <fasta> ksf, still, it is obviously possible to build useful systems with Haskell, today. It just isn't as smooth as it could be.
02:21:28 <ksf> I bet a lot of maintainers have a mental list of small things they'd like to do, but don't get around doing.
02:21:45 <ksf> the key there is to file an issue for each of them.
02:22:16 <Saizan> cads: something that's rarely stressed in its points is that you gain the hindsight of what your problem is also by struggling with the implementation or playing with an half-baked one
02:22:17 <cads> Nafai, there are lots of libraries and stuff, plus the a community of people to help, I'd say work on a project relevant to your professional interests using haskell
02:22:19 <ksf> it's insanely more rewarding to hack on a real-world problem (with community support) than doing some exercise from a book
02:22:24 <fasta> This is probably the real problem: http://www.relfe.com/plus_5_.html
02:22:53 <fasta> ksf, yes, it's also good for your career.
02:23:09 * Nafai nods
02:23:11 <Nafai> indeed
02:23:12 <fasta> ksf, and sense of accomplishment and all that.
02:24:07 <en0th> ksf, that's so true. I'm programming with C for a computer network course.. Nothing more boring.
02:24:08 <Nafai> Heh, I need to figure out my professional interests.  :)  I've been all over the map and I'm unemployed right now. :(
02:25:11 <en0th> ..and useless, in my point of view.
02:25:44 <ksf> ...speaking of which, we need more yi developers. a lot more. or get the existing ones out from under their bush and into #yi.
02:26:25 <fasta> en0th, would any non-GC language be useless?
02:26:43 <Saizan> ksf: are there good resources to get started with yi hacking?
02:27:06 <ksf> ...and while the yi source is nearly as bad as happstack when it comes to idiomatic haskell (there actually is type Endo a = a -> a), it should be quite easy to get a hold of even as a beginner, with some support
02:27:10 <ksf> Saizan, yes, the source.
02:27:42 <toast-opt> fasta, um, bugs are like monetary debt.  is that your point? :)
02:27:45 <Saizan> ksf: is that good?:)
02:28:04 <ksf> there's also a paper about the incremental parser, without which I'd have to read even more source to get an idea of how to do the stuff I want to do.
02:28:15 <ksf> there could surely be better docs.
02:28:22 <ksf> ...developer docs, that is, not even user docs.
02:28:27 <en0th> fasta: the point is that we have to build some sample programs that will be useless once we got the final exam
02:28:39 <fasta> toast-opt, no, the point is that money based on credit stiffles everything. In principle we all have the skill to make a good system, but nothing comes out of it, because everyone is waiting for someone else to do the work.
02:28:41 * ksf wonders whether the haddock builds for the darcs sources
02:28:57 <fasta> toast-opt, especially money created out of nothing.
02:29:14 <toast-opt> fasta, doesn't (fix) create stuff out of nothing?
02:29:28 <Veinor> Any time somebody says that Haskell has too many operators, point them at this
02:29:31 <Veinor> http://glyphic.s3.amazonaws.com/ozone/mark/periodic/Periodic%20Table%20of%20the%20Operators%20A4%20300dpi.jpg
02:29:32 <fasta> toast-opt, (fix)?
02:29:41 <toast-opt> yeah, from Data.Function
02:29:51 <ksf> uh. indeed. it does. cabal haddock generates docs for exactly one module.
02:29:53 <ksf> *sigh*
02:30:01 <fasta> toast-opt, no, it needs a computer.
02:30:05 <toast-opt> :P
02:30:29 <fasta> toast-opt, you should read it again, maybe.
02:30:53 <toast-opt> fasta, reading it now
02:30:55 <fasta> toast-opt, the system is setup in such a way that it is impossible by design to repay debts.
02:31:13 <Veinor> politics? in my #haskell?
02:31:28 <fasta> It is a very smart system from the point of view of the creators.
02:31:41 <fasta> Veinor, it has little to do with politics.
02:31:53 <fasta> Veinor, more with your wallet.
02:32:15 <cx> if I have a list and i want the second last item in the list, like [1,2,3] then i want the 2, do you have any tips for me ? :)
02:32:45 <Saizan> > [1,2,3] !! 1
02:32:46 <fasta> cx, last . tail
02:32:47 <lambdabot>   2
02:32:52 <path[l]> like last.init ?
02:33:06 <Saizan> head . tail
02:33:07 <fasta> cx, er last . init
02:33:22 <cx> oki thanks going to try it out
02:33:25 <toast-opt> fasta, still not sure what context you're quoting this story in
02:33:25 <Saizan> ah, second last
02:33:45 <ksf> Saizan, you can try asking questions in #yi, where you won't be alone...
02:33:54 <fasta> toast-opt, the ultimate reason why we don't have bright and shiny tools.
02:33:58 <ksf> ...asking questions and not getting any reaction, that is.
02:34:10 <Saizan> ksf: heh, i noticed that in the past
02:34:16 <toast-opt> fasta, you mean, platnum plated tools?
02:34:17 <ksf> at least if I don't know the answer, either
02:34:28 <fasta> toast-opt, if you want, yes.
02:34:37 <ksf> (and I'm quite new to the codebase, but grepped my way through say 60% of it now)
02:34:39 <fasta> toast-opt, have you actually read it? Do you understand it?
02:35:30 <toast-opt> i understand the mathematics of it
02:35:36 <toast-opt> that part isn't very difficult
02:36:26 <fasta> toast-opt, indeed it is very simple. Still, I would say that at least 80% of the population doesn't know about this.
02:36:38 <toast-opt> know about what?
02:36:57 <fasta> For example this little fun fact: "Noone knows what they are worth, but it's estimated that their wealth is estimated at $2 trillion - $491,409 trillion US ."
02:37:05 <toast-opt> is this story to be a representative of some real world situation?
02:37:16 <ksf> Saizan, regarding your buffer question... what is that you want to do with them?
02:37:17 <fasta> toast-opt, uhm, this is how our whole money system works.
02:38:16 <toast-opt> hmm., perhaps i'm not knowledgable enough in our money system
02:38:27 <fasta> toast-opt, the "bail-outs" are just part of the system.
02:38:52 <Saizan> ksf: in the past i've wanted to make a CLI irc client scriptable in haskell, but i never found a nice way to build the UI, i though yi could be a good frontend
02:38:55 <blackh> fasta: I'm cursed with an understanding of it
02:39:06 <fasta> blackh, yep, that's really what it is.
02:39:15 <Nafai> Saizan: Sounds like a cool idea
02:39:29 <fasta> blackh, ignorance is a bliss, unless _everyone_ understands it.
02:39:56 <ksf> Saizan, you can start out with a simple text buffer and an attached minibuffer as text and command entry area
02:40:12 <blackh> fasta: Tell me about it. Oh the tragic absurdity of the situation, eh. :)
02:40:18 <ksf> then if you got going, add an irc mode that can display that buffer in a nice way
02:41:10 <ksf> I'd be surprised if yi cares about whether a buffer is actually file-backed or not, so there you've already got infinite scrollback for free.
02:41:30 <fasta> blackh, what I am surprised about is how easy it is to make people ignorant of these things.
02:41:41 <Saizan> ksf: modulo memory use?
02:42:02 <ksf> to see how to navigate inside a buffer and insert text and so on, I'd recommend looking at the implementation of your favourite keymap.
02:42:05 <ksf> well...
02:42:06 <fasta> blackh: you would expect that they explain how the money system actually works in economics classes at high-school for example.
02:42:09 <Veinor> ok, unrelated to anything: why does find put its return value in a Maybe but head throws exceptions?
02:42:12 <ksf> yi's a memory hog atm, anyway.
02:42:35 <ksf> I would say that big file support is an orthogonal issue, though.
02:42:44 <blackh> fasta: When the truth is that absurd, nobody believes it.
02:42:48 <ksf> something like mmapping files or such.
02:43:21 <toast-opt> fasta, i'm still not clear on the point.  given this situation, what's the resolve?
02:43:39 <ksf> if things get done smart enough, i.e. you don't require the line count to be displayed, scrolling to the end of a file should be instant.
02:44:21 <ksf> the point of yi is, after all, to abstract away over all those low-level issues.
02:44:24 <fasta> toast-opt, why would I have to figure out a solution for this mess? I am glad you see there is a problem.
02:44:41 <toast-opt> fasta, well, i already could _see_ there was a problem
02:44:48 <Saizan> Veinor: because the alternative to head that doesn't throw exceptions is just a case statement away
02:44:59 <Saizan> Veinor: look at the safe package however for other versions of it
02:45:01 <toast-opt> one doesn't need to know physics or engineering to understand that a car crash is a bad thing
02:45:10 <Veinor> Saizan: I guess the question is: how do you decide whether to use Maybe or exceptions?
02:45:12 <toast-opt> one sees the scrap and debris, and it's obvious
02:45:13 <fasta> toast-opt, a temporary solution might be some money system which was introduced when they got rid of the banks the first time. They sure didn't like that one.
02:46:15 <fasta> toast-opt, for example something like this: http://en.wikipedia.org/wiki/United_States_Note
02:46:31 <Saizan> Veinor: i'd say always use Maybe (or Either etc..), but you might add a convenience function when the precondition is easily checkable
02:46:38 <ksf> there's some companies that introduced their own secondary money and use it among themselves, in a mostly circular fashion.
02:46:43 <toast-opt> fasta, i was wondering if that was the logical conclusion, but wasn't sure if there was some political 'trick' remaining
02:47:32 <fasta> ksf, ah, like which ones?
02:47:40 <ksf> also, there's some experience with http://en.wikipedia.org/wiki/Freigeld
02:47:58 <fasta> There are some systems which work with "time".
02:48:26 <ksf> I think it was some small and medium sized companies in switzerland and their partners.
02:48:30 <o-_-o> there was book written in 1998 on haskell
02:48:41 <o-_-o> anyone remember the name or link ?
02:49:00 * o-_-o saw it in 1998, but now doesn't remember which
02:49:11 <fasta> ksf, does it still exist?
02:49:17 <ivanm> o-_-o: by bird?
02:49:23 <fasta> ksf, or did the leader die in a mysterious plane crash? ;)
02:49:25 <blackh> o-_-o: The Haskell School of Expression?
02:49:27 <ivanm> or do you mean the actual Haskell 98 report?
02:49:28 <ksf> you know, if one company makes robots, and another one buys these robots to produce screws, and you need screws to build the robots, it doesn't make much sense not to exchange stuff more directly.
02:49:36 <o-_-o> ivanm: I don't remember, but it was online
02:49:36 <toast-opt> battery dead, need to call it a night
02:49:39 <toast-opt> interesting as alway
02:49:43 <o-_-o> ivanm: probably
02:49:55 <ivanm> toast-opt: if its dead, then how are you still here? >_>
02:50:01 <aeron> cya toast-opt :)
02:50:18 <o-_-o> no it started with monda
02:50:21 <o-_-o> moads(
02:50:23 <o-_-o> monads*
02:50:45 <ksf> fasta, I'm trying to find the reference
02:50:50 <toast-opt> let myMoney = fix (\x -> myMoney)
02:50:53 <toast-opt> how about that
02:50:56 <ivanm> o-_-o: maybe look through the book section of the haskell wiki?
02:51:04 <toast-opt> > let myMoney = fix (\x -> myMoney)
02:51:06 <lambdabot>   not an expression: `let myMoney = fix (\x -> myMoney)'
02:51:19 <toast-opt> > let myMoney = fix (\x -> myMoney) in myMoney
02:51:23 <lambdabot>   mueval-core: Time limit exceeded
02:51:45 <Cyneox> hi there! are there any lambda-gurus around? i need a ">" (greater) operator in lambda.. does somebody have any ideas? thx
02:51:45 <toast-opt> hmm, i guess it doesn't come out of thin air that easily
02:52:14 <ivanm> Cyneox: using church numerals?
02:52:22 <ivanm> IIRC, TaPL had something like that...
02:52:37 <Cyneox> ivanm: using [1,2,3...]
02:53:05 <ivanm> Cyneox: what do you want to do?
02:53:13 <ivanm> @type \ x y -> x > y
02:53:14 <lambdabot> forall a. (Ord a) => a -> a -> Bool
02:53:20 <Cyneox> i need a lambda expression
02:53:50 <Cyneox> mayybe its the wrong the channel but i thought i could simply ask for that.. perhaps there is somebody with lambda-skills :D
02:53:58 * ksf can't find it
02:54:05 <ivanm> Cyneox: still not sure wtf you're talking about...
02:54:14 <Saizan> Cyneox: so it's some exercise in pure lambda calculus, and not in haskell?
02:54:21 <Cyneox> Saizan: right
02:54:31 <Saizan> Cyneox: how are the numbers represented?
02:54:36 <Cyneox> wait...
02:54:45 <Cyneox> L sz. z           = 0
02:54:50 <Cyneox> L sz. s(z)        = 1
02:54:55 <Cyneox> L sz. s(s(z))     = 2
02:54:56 <Cyneox> ...
02:55:01 <ivanm> yes, church numerals
02:55:10 <ivanm> so why are you saying [1,2,3...] ?
02:55:22 <ivanm> Cyneox: as I said before, I think tapl has something on this
02:55:27 <Cyneox> ivanm: i didnt knew they're called church numerals..sorry
02:55:42 <ivanm> and then you have church lists, etc.
02:55:47 <Cyneox> ahh
02:55:50 <Cyneox> good to know
02:56:08 <ksf> data Nat = Z | S Nat; two = S (S Z)
02:56:28 <ivanm> Cyneox: look up church encoding on wikipedia
02:56:56 <Cyneox> ok..thanks!
03:01:30 <o-_-o> bird's book is very expensive
03:01:34 <o-_-o> :-(
03:14:18 <cx> Im trying to understand foldr, myLength = foldr (\x n -> n + 1 ) 0  what does the 0 stand for?
03:14:32 <opqdonut> the starting value of the fold
03:14:39 <cx> ah
03:14:57 <cx> thx
03:17:35 <ksf> why does haddock compile my source?
03:18:10 <ksf> It's clear that it should be typechecking it, but ghc-asm taking up 99% of my cpu for minutes on end isn't a thing I like to see.
03:30:50 <ClaudiusMaximus> mm, it appears that the 'tfp' package defines type families "Mod x y" etc, but no type instances for them  - it's a bit useless without them...  or am i missing something?
03:31:13 <Saizan> ksf: TH
03:32:25 <Saizan> ClaudiusMaximus: maybe the instances are in some other module? is haddock just isn't reporting them?
03:34:12 <ClaudiusMaximus> Saizan: i looked hard, but i think i'll try grepping the local sources...
03:34:29 <ClaudiusMaximus> in case haddock's source links are missing something
03:40:56 <ClaudiusMaximus> nope, not there, though I found where they would be if they would have been implemented..
03:41:24 <zygoloid> ClaudiusMaximus: they're in Types.Data.Num.Decimal.Ops
03:41:47 <zygoloid> umm, no, they're not ;-)
03:41:57 <ClaudiusMaximus> zygoloid: yes, but Mod is missing! (at least in the latest version on hackage)
03:42:21 <gemie> i am doing a sudoku solver. and i am at the last step where I am going to use all my functions I have built and use them to solve a sudoku. if I want to recursively solve it by taking a possible position which I get from a function and use that in each resursive case and use that to update the sudoku with it. and keep doing until there is no blank positions left. Can i use foldr with a lambda to do this?
03:42:38 <ClaudiusMaximus> zygoloid: and i'm sure people will want to Div by numbers larger than 2 at some stage...
03:59:26 <cads> gemie, I think your task is co-recursive between a few different functions so it'll probably be less compact than a fold
04:04:58 <zygoloid> anyone know if it's possible to find which address ranges your process has mapped in linux, other than by parsing /proc/self/maps?
04:14:03 <Baughn> dons: What you don't realize is, I spent two days working out the API and internals of the AES binding, and I'm /still/ not satisfied. You could probably do it in an hour. :P
04:16:11 <cx> @concatMap
04:16:11 <lambdabot> Unknown command, try @list
04:16:21 <cx> :(
04:16:35 <ski> @type concatMap
04:16:38 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
04:16:42 <cx> :)
04:16:59 <zygoloid> @@ @type (=<<) :: @type concatMap
04:17:02 <maltem> Is the git repo of ghc on darcs.haskell.org not fed anymore (and git://darcs.haskell.org taken down)?
04:17:02 <lambdabot>  forall a b. (a -> [b]) -> [a] -> [b]
04:17:03 <ski> @src [] (>>=)
04:17:05 <lambdabot> xs >>= f     = concatMap f xs
04:17:21 <cx> Im trying to figure out concatMap
04:17:28 <cx> I know what concat does
04:17:30 <cx> and map
04:17:38 <cx> :D
04:17:41 <zygoloid> @src concatMap
04:17:42 <lambdabot> concatMap f = foldr ((++) . f) []
04:18:03 <zygoloid> concatMap f xs = concat (map f xs)
04:18:32 <cx> aha
04:19:41 <ski> > concatMap (\x -> map ((,) x) $ if x < 0 then [] else if x == 0 then [0] else [- sqrt x,sqrt x]) [-4,2,-1,0,1,-2,4]
04:19:43 <lambdabot>   [(2.0,-1.4142135623730951),(2.0,1.4142135623730951),(0.0,0.0),(1.0,-1.0),(1...
04:20:45 <cx> thank you
04:21:13 <ski> > concatMap (\c -> if c == '_' then "-" else if c == '#' then "" else [c]) "foo_bar#42"
04:21:15 <lambdabot>   "foo-bar42"
04:21:52 <ski> > concatMap (\c -> if c == '_' then "-" else if c == '-' then "--" else [c]) "foo_bar-baz_quux"
04:21:54 <lambdabot>   "foo-bar--baz-quux"
04:24:15 <zygoloid> > concatMap (\c -> ["zero","one","two","three","four","five","six","seven","eight","nine"] !! (ord c - ord '0')) $ show 15294
04:24:17 <lambdabot>   "onefivetwoninefour"
04:31:18 <ksf> > zip `ap` tail [1..]
04:31:20 <lambdabot>   Couldn't match expected type `[a] -> [b]'
04:31:20 <lambdabot>         against inferred type `[t]'
04:31:30 <ksf> > (zip `ap` tail) [1..]
04:31:32 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
04:31:59 * ksf wonders why ghci complains about a missing Monad ((->) [b])) instance.
04:33:29 <fasta> ksf, import Control.Monad.Instances?
04:37:36 <ksf> yep, that's it.
04:41:19 <chellomere> hello
04:42:00 <birdiee_> i am doing a sudoku solver and I am at the end of creating the solution function so I have all the functions that are needed already. I have started to build my function where I check that it's an okay suduko and all that and if it's then I have a helper function where I am going to solve it. there I have 2 guards, the first guard checks if there is any blank positions in the sud. if it is then It returns the sudoku oth
04:42:23 <birdiee_> now I am having trouble doing this recursivly I have tried out some stuff with foldr but I need hints
04:42:27 <birdiee_> how should I think
04:42:33 <ksf> sodoku solvers? in my days, we were doing irc clients.
04:42:42 <birdiee_> haha :)
04:42:44 <chellomere> I was going to ask a question about how fast length on strings it, then I realized a string is just a list, and that it thus should be O(n) to run length on something. right?
04:43:02 <birdiee_> ksf todays youth.. lazy you know =)
04:43:30 <ksf> the trick to folds is to do them manually, step by step.
04:43:59 <birdiee_> ksf another question is. is it a fold I want here?
04:44:15 <ksf> that is, write the code for one iteration, comment it away, write the code for two iterations, comment it away, then for three, and by then you should be able to spot the right abstraction for it.
04:44:53 <ksf> chellomere, right.
04:44:59 <ksf> if you want something faster, there's Seq.
04:45:06 <ksf> ...in Data.Sequence.
04:45:32 <chellomere> no need, I'll just make sure to precompute the lengthes of the words
04:45:38 <ksf> which has O(1) length and O(min (log n, log m)) concat.
04:45:57 <birdiee_> ksf okey gonna try it out thanks for the tip
04:46:47 <chellomere> the algorithm has a quite high time complexity, and operates on text split into words
04:47:31 <chellomere> so initial text splitting/length calculation won't affect performance much
04:48:32 <SamB_XP_> chellomere: hmm, but as long as the words aren't german words ...
04:48:40 <SamB_XP_> ... shouldn't they be pretty short ?
04:49:40 <chellomere> SamB_XP_, yeah they are
04:49:59 <ksf> I know I'm seriously OT now, but firefox has overtaken IE in germany: 45.6% market share vs. 44.4%
04:50:04 <chellomere> quite short, but not all that short, as they are in a germanic language ^^ (swedish)
04:50:17 <SamB_XP_> of course, you've got to be careful with assumptions like that if anyone hostile could be affecting the input ..
04:50:53 <SamB_XP_> chellomere: well, it's just that I heard the other day about one of my teachers showing off german words that spanned a blackboard
04:51:11 <chellomere> haha :) could happen here too, not that extreme tho
04:51:23 <SamB_XP_> I think it might have been a double-width blackboard too ;-)
04:51:38 <ksf> hell you can make them recursive
04:51:44 <maltem> SamB_XP_, one of my favourites is K-Vektorraum-Endomorphismus
04:52:12 <chellomere> in swedish, as in german, you can create basically infinitely long words
04:52:17 <SamB_XP_> maltem: okay, hmm, what does the K bit mean ?
04:52:22 * ski . o O ( "Constantinopolitanischerdudelsackpfeifenmachergesellschaft" )
04:52:34 <maltem> SamB_XP_, the name of the field (KÃ¶rper)
04:52:55 <SamB_XP_> ski: okay, so some dude from constantinople did what now ?
04:52:56 <ksf> ski, that's two words.
04:53:10 <maltem> ski, that's not a grammatical german word. I think we had that discussion already ;)
04:53:18 <ski> take that up with Samuel Clemens :)
04:53:40 <SamB_XP_> ski: er, you mean Mark Twain?
04:53:44 <ski> yes
04:53:46 * chellomere .oO(barnbarnsbarnsbarnsbarnsbarnsbarns...barn)
04:53:59 <ski> barn^n
04:54:01 <chellomere> child's child's child's child's child's ... child
04:54:14 <maltem> A popular (real-world) example is Donaudampfschiffahrtsgesellschaft
04:54:16 * SamB_XP_ thinks of Mark Twain as the real name and Samuel Clemens as the Secret Identity
04:54:20 <ksf> Kapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiffkapitänsmützenknopftransportschiff
04:54:53 <ksf> .o( do I win? )
04:54:56 <SamB_XP_> anyway, what was the constantinople "one" supposed to mean ?
04:54:57 <ski> (did that got cut off or should it end with "transportschiff" ?)
04:55:09 <ksf> well, it's infinite.
04:55:39 <SamB_XP_> ksf: and we're supposed to believe that it got cut off at such a convenient spot on it's own ?
04:55:40 <cx> is there a function for function (1,1,1,2,2,2,3,3,3) results in ((3,1),(3,2),(3,3)) ?
04:55:56 <SamB_XP_> cx: you can't do that with tuples in Haskell
04:56:07 <ksf> but you can end it on either kapitän, mütze, transport, or schiff.
04:56:21 <ski> > histo [1,1,1,2,2,2,3,3,3]
04:56:21 <SamB_XP_> cx: you maybe are thinking [1,1,1,2,2,2,3,3,3] -> [(3,1),(3,2),(3,3)] ?
04:56:24 <lambdabot>   fromList [(1,3),(2,3),(3,3)]
04:56:33 <cx> SamB_XP_ yes!
04:56:38 <SamB_XP_> ski: where did that come from ????
04:56:42 <chellomere> acetylseryltyrosylserylisoleucylthreonylserylprolylserylglutaminylphenylalanylvalylphenylalanylleucylserylserylvalyltryptophylalanylaspartylprolylisoleucylglutamylleucylleucylasparaginylvalylcysteinylthreonylserylserylleucylglycylasparaginylglutaminylphenylalanylglutaminylthreonylglutaminylglutaminylalanylarginylthreonylthreonylglutaminylvalylglutaminylglutaminylphenylalanylserylglutaminylvalyltryptophyllysylprolylphenylalanylproly
04:56:42 <chellomere> lglutaminylserylthreonylvalylarginylphenylalanylprolylglycylaspartylvalyltyrosyllysylvalyltyrosylarginyltyrosylasparaginylalanylvalylleucylaspartylprolylleucylisoleucylthreonylalanylleucylleucylglycylthreonylphenylalanylaspartylthreonylarginylasparaginylarginylisoleucylisoleucylglutamylvalylglutamylasparaginylglutaminylglutaminylserylprolylthreonylthreonylalanylglutamylthreonylleucylaspartylalanylthreonylarginylarginylvalylaspartyl
04:56:43 <chellomere> aspartylalanylthreonylvalylalanylisoleucylarginylserylalanylasparaginylisoleucylasparaginylleucylvalylasparaginylglutamylleucylvalylarginylglycylthreonylglycylleucyltyrosylasparaginylglutaminylasparaginylthreonylphenylalanylglutamylserylmethionylserylglycylleucylvalyltryptophyl-threonylserylalanylprolylalanylserine
04:56:46 <maltem> SamB_XP_, Constantinopolitanisch = constaninopolitan (or what you call it), Dudelsack = bagpipe, Dudelsackpfeifenmacher = maker of bagpipe pipes, Gesellschaft = company. But as I said, the whole word doesn't mean anything
04:56:46 <ski> @index histo
04:56:47 <lambdabot> bzzt
04:56:52 <chellomere> o.O sorry, didn't think it was that long
04:56:52 <SamB_XP_> cx: what do you want from [1,2,2,2,1,1] ?
04:57:28 <SamB_XP_> maltem: oh! gesellschaft = company?
04:57:41 <ski> SamB_XP_ : "A Connecticut Yankee"
04:57:48 <ksf> "dudelsackpfeifenmachergesellschaft" works, though.
04:58:04 <ksf> but city names can't be prefixed like that
04:58:06 <SamB_XP_> interesting, that's also the name of the Bonne's ship in The Misadventures of Tron Bonne (a Megaman Legends spinoff)
04:58:23 <ksf> unlike e.g. "donaudampfschifffahrtsgesellschaft"
04:59:09 <ksf> "gesellschaft" also means "society". the best translation might be "corporation", as in "corpus"
04:59:15 <maltem> There's someone going for the triple-f spelling :)
04:59:26 <SamB_XP_> so, is dudelsack = bagpipe?
04:59:31 * hackagebot upload: AES 0.1.0 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
04:59:32 <SamB_XP_> or just bag ?
04:59:33 <ksf> yep.
05:00:00 <maltem> SamB_XP_, was my list that unclear?
05:00:04 <ksf> maltem, yes, but I'm old enough to know how to spell portemonnaie, and not just because I had frensh in school.
05:00:36 <SamB_XP_> maltem: no, I just missed that part
05:00:37 <endojelly> I am French
05:00:38 <endojelly> and German
05:01:03 <ksf> A very wise man once said "It is wrong to be french"
05:01:14 <endojelly> I remember ,)
05:01:15 <SamB_XP_> ksf: well, it's not like you can help it!
05:01:34 <endojelly> but the US just hates us for our freedom ;)
05:01:39 <SamB_XP_> ksf: anyway, the Bonnes are a pirate family
05:02:01 <SamB_XP_> endojelly: oh ... is *that* why "we" called them Freedom Fries?
05:02:19 <shambler_> @yarrr
05:02:19 <endojelly> SamB_XP_, sounds plausible
05:02:20 <lambdabot> Smartly me lass
05:02:28 <ksf> no it's because you say insane things like "four twenty nineteen" instead of ninety-nine, and are even proud of it.
05:02:29 * SamB_XP_ never got into that, though he did make a Freedom Toast joke the other day for lack of any better joke to make at the time
05:02:45 <endojelly> SamB_XP_, by the way, did that *really* happen?
05:03:12 <SamB_XP_> endojelly: some people actually did call them freedom fries, yes!
05:03:21 <ksf> my baker definitely changed the name of "americans" to "hanseats" after that happened.
05:03:28 <endojelly> I first thought it was just a (pretty lame) joke... but over time the impression came that there really really are people that called them freedom fries
05:03:34 <SamB_XP_> I really have no idea why they did that
05:03:42 <ksf> ...works better, too, there never was any bit of blue to them.
05:04:04 <SamB_XP_> it seemed pretty dumb, especially considering I don't think those things are all that french to start with ?
05:04:06 <endojelly> hmm, they're still called "Amerikaner" in Munich
05:04:06 <dsdeiz> hi! is twitter, haskell twitter client good? :-/
05:04:26 <mux> SamB_XP_: well the guy who introduced potatoes in europe was french :-P
05:04:34 <endojelly> SamB_XP_, I don't know, are "Amerikaner" American?
05:04:41 <ksf> endojelly, were they blue-white instead of red-white, I bet they'd be called bavarians, by now.
05:04:44 <SamB_XP_> endojelly: never heard of them!
05:04:56 <endojelly> ksf, you mean the fries?
05:05:01 <SamB_XP_> I would have assumed the dish was just composed of couch potatoes from the US ;-P
05:05:03 <maltem> SamB_XP_, a couple of European countries claim to have invented French Fries, most prominently, Belgium
05:05:10 <endojelly> because "Amerikaner" here are all white
05:05:22 <endojelly> http://www.dorfbaeckerei-soetebier.de/neu/produkte/broetchen/amerikaner_59.jpg
05:05:29 <endojelly> pretty tasty pastry, too
05:05:41 <endojelly> it's sugar-coated fluffy dough.
05:06:08 <ksf> endojelly, http://de.wikipedia.org/wiki/Hanseat_(Geb%C3%A4ck)
05:06:09 <ksf> those ones
05:06:17 <maltem> They are listed as rolls, url-wise? :)
05:06:29 <endojelly> ksf, ooh. don't know those.
05:06:37 <SamB_XP_> maltem: can't they be pastry rolls ?
05:07:03 <SamB_XP_> like cinnamon rolls?
05:07:10 <endojelly> maltem, they're not too unsimilar. although the dough itself is much too sweet, fluffy and unstable to be really bread.
05:07:11 <fritschy_> endojelly: stop! :)
05:07:22 <ksf> ...then you most likely don't know http://de.wikipedia.org/wiki/Franzbr%C3%B6tchen , either, and I pity you.
05:07:25 <SamB_XP_> well, I can't say that I've seen one before, but that hardly means it didn't originate here
05:07:25 <endojelly> fritschy_, with what? 8)
05:07:36 <SamB_XP_> this place is pretty big ;-P
05:07:38 <fritschy_> diskussing gebaeck! ;)
05:07:45 <fritschy_> d'oh!
05:07:50 <endojelly> heheh
05:07:52 <endojelly> fritschy_, why? :D
05:07:55 <fritschy_> bad day.. today! [tm]
05:08:03 <endojelly> SamB_XP_, no, but it *does* look tasty
05:08:09 <maltem> endojelly, and the shape is too different
05:08:13 <ksf> ...I know another story of the origin, though, which is simply that the baker who invented is was called "Franz"
05:08:17 <SamB_XP_> actually, being this big is one of the things I hate about the US
05:08:27 * fritschy_ is searching something to eat...
05:08:28 <fritschy_> ;)
05:08:34 <SamB_XP_> though I guess technically America isn't just the US
05:08:49 <SamB_XP_> no matter how forgetful we USians can be of this fact
05:09:22 * maltem missed to reply to fritschy's "d'oh!" saying "nuts!"
05:09:22 <SamB_XP_> I mean, there's at least Canada as well ...
05:09:22 <endojelly> must be fun, being a canadian in the US
05:09:47 <maltem> s/missed/missed the opportunity/
05:09:52 <SamB_XP_> endojelly: well, the trouble is that sometimes we think of the *country* as being named America :-(
05:10:13 <endojelly> SamB_XP_, truth be told, when I say "America", I often mean the US, too
05:10:19 <endojelly> and I'm from Europe
05:10:29 <endojelly> I blame TV 8)
05:10:33 <SamB_XP_> I guess it's really more ambiguous than incorrect to call this country America
05:10:48 <endojelly> that sounds about right
05:11:09 <endojelly> after all, the U.S. are a subset of America
05:11:26 <Saizan> no Haskell Land or Haskell Nation yet?
05:11:27 <SamB_XP_> 'cause that can mean the USA, the continent of North America, or both North and South America
05:11:38 <SamB_XP_> Saizan: you must be joking
05:11:40 <endojelly> it's similar to saying someone's "Asian". that's totally correct, yet unspecified.
05:12:11 <SamB_XP_> endojelly: well, at least that's not possibly referring to something more specific than the continent of asia, is it ?
05:12:31 <SamB_XP_> at least, I've never heard of a country called Asia
05:12:33 <ksf> there's no asian continent.
05:12:39 <ksf> the continent is called eurasia.
05:12:49 <SamB_XP_> oh, is that how it works?
05:13:08 <endojelly> SamB_XP_, that's what I mean
05:13:32 <ksf> ...and the border is somewhere in russia. in geographical terms, at the ural, and in sociological terms it's almost impossible to draw.
05:13:36 <SamB_XP_> there's no faultline seperating Russia into European and Asian parts ?
05:13:53 <endojelly> SamB_XP_, calling a japanese person asian or a person from the USA american isn't wrong
05:14:01 <SamB_XP_> endojelly: well, sure
05:14:03 <ksf> http://en.wikipedia.org/wiki/Ural_Mountains
05:14:07 <endojelly> ksf, ah, that always bothered me
05:14:25 <SamB_XP_> but saying that america has this or that legal/political/social problem ...
05:15:11 <endojelly> ksf, it's hard to tell where europe even is when you look at it on a map. are there tectonic plates or something that separates europe from asia?
05:15:20 * SamB_XP_ looks at http://en.wikipedia.org/wiki/List_of_tectonic_plates
05:15:25 <maltem> The "perceived" border to Asia lies somewhere behind the Rhine :P
05:15:30 <ksf> it's mostly historical.
05:15:32 <endojelly> SamB_XP_, yeah, ok, you're right
05:15:55 <ksf> ...and reaches far more east than commonly assumed.
05:16:07 <ksf> like, afghanistan was greek, once.
05:16:14 <ksf> under alexander the great
05:16:17 <SamB_XP_> huh, apparantly europe and asia have one primary plate
05:16:27 <SamB_XP_> also called eurasian, for some reason ;-P
05:16:42 <ksf> russia was never far from european politics
05:16:46 <ski> (Saizan : well, how about a Republic <http://lisperati.com/landoflisp/panel57.html> ?)
05:17:12 <ksf> ...after all, everything east of the ural is "far off", even in russian terms, in which 1000km are just around the corner.
05:17:29 <maltem> Boy how I hate it when pepole can't express themselves properly, especially when they're doing massive exercise sheets
05:17:44 <SamB_XP_> maltem: eh?
05:18:01 <maltem> oh, nvm, I was just moaning around
05:18:20 <SamB_XP_> huh, http://en.wikipedia.org/wiki/Eurasian_Plate needs a better picture ...
05:18:29 <SamB_XP_> maltem: but what about ?
05:18:43 * hackagebot upload: Glob 0.5 - Globbing library (MattiNiemenmaa)
05:18:47 <maltem> SamB_XP_, well, this exercise sheet here
05:19:28 <ksf> much of today's european culture originates in africa and asia, anyway. on the one hand the indo-germanic tribes, on the other hand what's remaining of old-egyptian culture
05:20:19 <SamB_XP_> ksf: egypt seems, socially, to be part of europe ?
05:20:35 <SamB_XP_> or at least have been historically ...
05:21:10 <maltem> SamB_XP_, I don't think Egypt is considered any more European than, say, Vietnam
05:22:11 <ksf> heck _jesus_ was modelled after horus, both sun gods.
05:22:11 <Saizan> well, it was an european colony
05:22:54 <ksf> there's some significant overlap between the bible and the egyptian book of the dead
05:23:28 <maltem> Saizan, as was Vietnam
05:23:45 <ksf> not for long, though.
05:23:51 <Saizan> there has been this christian europe vs. islamic middle-east for quite some time that still had a certain influence on what we consider europe, i think
05:24:05 <ksf> I think vietnam holds the standard for countries kicking the hell out of invaders.
05:26:46 <ksf> without the arabs, there'd never be any wind mills in europe, without which there'd be no significant agriculture.
05:27:32 <ksf> ...but then europe has rivers, and water power is immensly more powerful+reliable than wind, so europe had an edge
05:28:03 <ksf> not that much happened for at least 1500 years except oppression, though.
05:31:00 <mux> Deewiant: ping
05:32:44 <Deewiant> pong
05:33:49 <mux> Deewiant: just read your page abotu the Glob package - I wanted to let you know there's a FileManip package on hackage that provides a System.FilePath.Glob module
05:34:39 <mux> Deewiant: I believe there's another glob pattern matchign function in MissingH
05:34:42 <Asztal> FileManip depends on the unix package. :(
05:36:12 <Deewiant> FileManip's glob looks a bit simplistic, I doubt there'll be problems with that... you probably won't use it in anything that uses Glob
05:36:38 <mux> I'm not saying those are better/worse or whatever, you were just saying that there is no such thing on hackage and there is
05:36:42 <Deewiant> And yes, MissingH has some simple glob support as well
05:36:43 <vy> A naive question: Why doesn't "1 `(,)` 2" or "1 `,` 2" work, while "(,) 1 2" does?
05:37:04 <Deewiant> mux: Nothing like globDir exists anywhere else
05:37:19 <mux> Deewiant: it might be a good idea to rephrase your web page on Glob then
05:39:14 <ski> vy : you can't infix arbitrary expressions. and `,' is not an operator
05:39:33 <ski> > [1,2,3] `zipWith (+)` [30,20,10]
05:39:36 <lambdabot>   <no location info>: parse error on input `('
05:40:02 <benmachine> I seem to remember there being something silly you can do with
05:40:15 <benmachine> data Infix = a :- b
05:40:26 <Botje> let (==>) = (,) in foo ==> bar
05:40:37 <benmachine> and a function a -: (b :- c) = b a c
05:41:25 <Berengal> benmachine: Given the right associations, you don't need parens either, and can just do foo -: bar baz :- quux
05:41:51 <benmachine> yes
05:41:52 <Deewiant> mux: Reworded
05:45:34 <trofi> http://en.wikibooks.org/wiki/Haskell/Graph_reduction#Implementation_of_Graph_reduction <- what is supercombinator?
05:49:25 <cathper> Is there a more elegant way to separate a list into a pair (as,bs) of lists where all a <- as fulfills the predicate and where no b <- bs fulfills the predicate?
05:49:29 <cathper> Two filters, but ...
05:50:27 <zygoloid> > partition odd [1..9]
05:50:28 <lambdabot>   ([1,3,5,7,9],[2,4,6,8])
05:51:45 <Botje> trofi: iirc it's a top level function with no free variables.
05:52:01 * cathper is obviously blind.
05:52:06 <cathper> zygoloid: Thanks :-)
05:53:40 <zygoloid> > let sort [] = []; sort (x:xs) = uncurry (++) . (sort *** (x:) . sort) $ partition (<x) xs in sort "hello"
05:53:42 <lambdabot>   "ehllo"
06:02:21 <halcyon10> hi, how can i install quickcheck 2.1.0.2 with cabal if i currently have version 1.2 installed? i tried --reinstall and --upgrade but that only reinstalled 1.2...
06:02:40 <dcoutts> halcyon10: cabal install 'quickcheck >= 2'
06:02:56 <dcoutts> see also cabal install --help for other variants
06:06:03 <halcyon10> dcoutts: thanks, it worked!
06:13:53 <FliPPeh> Which XML library is recommended? :o
06:14:47 <ksf> whatever suits you best.
06:14:54 <FliPPeh> I have no idea
06:14:59 <ksf> ...when I needed one, I settled for HaXML
06:15:01 <FliPPeh> I want to read an RSS feed
06:15:24 <ksf> ...because it was reasonably uncomplex, and can generate haskell adts out of a dtd
06:15:47 <ksf> ...then you most likely want an atom reader, which just might exist on hackage, or haxml
06:16:23 <ksf> http://hackage.haskell.org/package/feed
06:16:58 <FliPPeh> Thanks :)
06:17:17 <meanburrito920_> is there an easy way to uninstall a build of ghc6.10.3 so that I can upgrade to 10.6.4? or should I just install over the top of my old files?
06:17:30 <meanburrito920_> (I'm installing from the tarballs)
06:17:35 <FliPPeh> Well
06:17:43 <FliPPeh> I installed 6.10.4 over 6.10.3
06:17:49 <ksf> ...you should use your distro's tools to uninstall
06:17:49 <FliPPeh> And had my system cluttered up
06:17:52 <FliPPeh> On windows
06:18:04 <meanburrito920_> ksf: i did a make install
06:18:14 <meanburrito920_> so i cant use my distros uninstall tools
06:18:23 <Axman6> :t forever
06:18:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
06:18:28 <FliPPeh> No packet manager?
06:18:29 <Axman6> > forever []
06:18:30 <lambdabot>   []
06:18:35 <Axman6> > forever [a]
06:18:37 <lambdabot>   * Exception: stack overflow
06:18:37 <ksf> well, you shouldn't do system-wide installs without your package manager...
06:18:41 * hackagebot upload: eprocess 1.1.0 - *Very* basic erlang-like process support for Haskel (FernandoBenavides)
06:18:50 <meanburrito920_> i have a package manager, but it didint have the most up-to-date version of ghc
06:18:56 <meanburrito920_> it was on 6.8
06:18:58 <meanburrito920_> :(
06:19:00 <FliPPeh> :/
06:19:02 <FliPPeh> Debian?
06:19:02 <opqdonut> it's ok really
06:19:15 <opqdonut> as long as you put stuff in usrlocal
06:19:21 <meanburrito920_> yep
06:19:23 <FliPPeh> I like Arch Linux for Haskell
06:19:29 <ksf> ...at least on gentoo, the ghc installation is spit into /usr/lib/ghc-<version>
06:19:31 <meanburrito920_> at least, thats where make install put htem
06:19:33 <meanburrito920_> *them
06:19:37 <shambler_> FliPPeh, why?
06:19:37 <FliPPeh> Because about 80% of hackage is in the arch linux repos :)
06:19:39 <ksf> if that's a standard feature of the tarball, you should be fine.
06:19:46 <opqdonut> if you want to be clean about stuff you can have something like stow
06:19:49 <Axman6> FliPPeh: more i believe
06:19:59 <FliPPeh> Also it always has the most up to date version of GHC
06:19:59 <shambler_> FliPPeh, how 'bout gentoo?
06:20:10 <opqdonut> which is basically a manager for your usrlocal
06:20:10 <ksf> aren't there inofficial debian packages?
06:20:10 <FliPPeh> I have no idea about gentoo
06:20:33 <ksf> and failing everything else, you can always do something like ./configure --prefix=/home/whoever/ghc
06:21:08 <meanburrito920_> ksf: thats what I did for cabal. i forgot to do it for ghc though
06:35:45 * hackagebot upload: hint-server 1.1.0 - A server process that runs hint. (FernandoBenavides)
06:35:54 <saml> > let dogs = out in 1
06:35:56 <lambdabot>   1
06:36:29 <saml> > let x = asidofjoiwasvdhoefoawhefo in 1
06:36:31 <lambdabot>   Not in scope: `asidofjoiwasvdhoefoawhefo'
06:36:43 <Botje> :t out
06:36:44 <lambdabot> forall (f :: * -> *). Mu f -> f (Mu f)
06:36:49 <Botje> O_o
06:36:54 <saml> > out 1
06:36:56 <lambdabot>   No instance for (GHC.Show.Show (f (L.Mu f)))
06:36:56 <lambdabot>    arising from a use of `M548...
06:37:04 <saml> > let dogs = out in out dogs
06:37:05 <lambdabot>   Couldn't match expected type `L.Mu f'
06:37:06 <lambdabot>         against inferred type `L.Mu f...
06:37:36 <saml> > who
06:37:38 <lambdabot>   Not in scope: `who'
06:53:09 <Axman6> hooray, i've just implemented my first parser!
06:53:39 <byorgey> \o/
06:53:47 <byorgey> using what?
06:55:58 <Axman6> byorgey: from scratch
06:56:05 <byorgey> nice
06:56:06 <Hunner>  how would I order something like this like [(1,1),(2,2),(3,3)...(1,6),(2,7),(3,8)...] ? : [ (x,y) | x <- [1..5], y <- [1..7] ]
06:56:27 <Hunner> err, (3,1)
06:56:38 <Axman6> makes understand parsers much easier. i used this video: http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13/
06:57:09 <Axman6> Hunner: i don't get the question
06:57:15 <byorgey> Hunner: I don't understand your question.  You're trying to generate such a list? or sort it in a certain way? or... ?
06:57:23 <Hunner> >  [ (x,y) | x <- [1..5], y <- [1..7] ]
06:57:25 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(2,1),(2,2),(2,3),(2,4),(2,5),(2...
06:58:37 <Hunner> I want each number to increment until the list is full,. as it is, x stays the same until y's range is used
06:59:00 <Axman6> 'the list is full'?
06:59:13 <byorgey> Hunner: so you want [(1,1), (2,2), (3,3), (4,4), (5,5), ???  <--- then what?
06:59:41 <Hunner> then (1,6), since x has been used
06:59:47 * mmorrow doesn't see the pattern in [(1,1),(2,2),(3,3)...(1,6),(2,7),(3,8)...] at all
06:59:49 <Hunner> Axman6: lists are all unique right?
06:59:55 <byorgey> ok, and then (2,7), and then what?
07:00:44 <Axman6> Hunner: in what sense?
07:01:11 <Hunner> Axman6: in the sense that it can't have two (1,1)'s in it
07:01:21 <Axman6> they're not lists ;)
07:01:23 <Hunner> byorgey: (3,1)
07:01:30 <byorgey> > [(1,1), (1,1)]
07:01:31 <lambdabot>   [(1,1),(1,1)]
07:01:40 <Hunner> hmm. shoot
07:01:41 <byorgey> lists can have multiple identical elements
07:01:49 <byorgey> > zip (cycle [1..5]) (cycle [1..7]) -- something like this?
07:01:50 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(1,6),(2,7),(3,1),(4,2),(5,3),(1,4),(2,5),(3...
07:01:58 <ski> > [not,not]
07:01:58 <Axman6> > fix (1:)
07:01:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:02:01 <lambdabot>   [{True->False;False->True},{True->False;False->True}]
07:02:04 <Hunner> ah hah! that's it
07:02:04 <byorgey> figuring out where to end it is the hard part
07:02:12 <byorgey> that list I gave is infinite
07:02:52 <Hunner> hmm. Yeah, I hadn't counted on the lists being bags :)
07:03:02 <Axman6> > let f xs ys = take (length xs * length ys) $ zip (cycle xs) (cycle ys) in f [1..5] [1..7]
07:03:03 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(1,6),(2,7),(3,1),(4,2),(5,3),(1,4),(2,5),(3...
07:03:04 <byorgey> they're not bags, they're lists =)
07:03:21 <Hunner> [07:07]    Axman6 : they're not lists ;)
07:03:28 <Axman6> Hunner: lists are linked lists
07:03:38 <Axman6> (1,2) is not a list, it's a tuple
07:04:08 <Hunner> Sorry, I was talking about the stuff between [] Axman6
07:04:09 <byorgey> Axman6: I don't see what you're getting at.  How are linked lists not lists?
07:04:22 <byorgey> yes, Axman6, something like that ought to work as long as x and y are relatively prime
07:04:25 <Axman6> byorgey: i was saying tuples aren't lists
07:04:35 <byorgey> Axman6: oh, I didn't think Hunner was asking about tuples
07:04:36 <Hunner> byorgey: mathmatically lists can't have duplicate items, I believe
07:04:50 <Axman6> Hunner: you're thinking sets
07:05:02 <Hunner> ah, there you go
07:05:05 <byorgey> Hunner: I don't think that's true.
07:05:05 <Axman6> lists aren't a mathematical construct really
07:05:15 <byorgey> sure they are.
07:05:29 <ski> > let twoLists = ([0..2],[0..3]) in take ((uncurry (*) . (length *** length)) twoLists) ((uncurry zip . (cycle *** cycle)) twoLists)
07:05:32 <lambdabot>   [(0,0),(1,1),(2,2),(0,3),(1,0),(2,1),(0,2),(1,3),(2,0),(0,1),(1,2),(2,3)]
07:05:32 <Axman6> well, they're a lot more obscure than sets i'd say...
07:05:45 <ski> > let twoLists = ([0..2],[0..4]) in take ((uncurry (*) . (length *** length)) twoLists) ((uncurry zip . (cycle *** cycle)) twoLists)
07:05:47 <lambdabot>   [(0,0),(1,1),(2,2),(0,3),(1,4),(2,0),(0,1),(1,2),(2,3),(0,4),(1,0),(2,1),(0...
07:05:52 <byorgey> a list of X's is a function {1,..,n} -> X  for some natural number n
07:05:55 <Hunner> byorgey: they don't have to be both prime. 13 and 20, for example
07:05:58 <ski> > let twoLists = ([0..1],[0..3]) in take ((uncurry (*) . (length *** length)) twoLists) ((uncurry zip . (cycle *** cycle)) twoLists)
07:06:00 <lambdabot>   [(0,0),(1,1),(0,2),(1,3),(0,0),(1,1),(0,2),(1,3)]
07:06:14 <byorgey> Hunner: right, "relatively prime" means they share no common factors
07:06:18 <byorgey> not that they are prime necessarily
07:06:30 <Axman6> 4 and 7 are relatively prime
07:06:36 <Axman6> but 4 isn't prime
07:06:43 * Hunner sees now
07:06:49 <Axman6> since the only common factor between the two is 1
07:06:59 <ski> > let twoLists = ([0..1],[0..3]) in take ((uncurry lcm . (length *** length)) twoLists) ((uncurry zip . (cycle *** cycle)) twoLists)
07:07:02 <lambdabot>   [(0,0),(1,1),(0,2),(1,3)]
07:07:39 <byorgey> heh, lcm, indeed =)
07:07:59 <ski> > liftM2 take (uncurry lcm . (length *** length)) (uncurry zip . (cycle *** cycle)) ([0..1],[0..3])
07:08:01 <lambdabot>   [(0,0),(1,1),(0,2),(1,3)]
07:08:23 <Axman6> ski: this is just getting more and more horrible!
07:08:37 <Axman6> :t liftM2 take
07:08:37 <ski> hehe
07:08:38 <lambdabot> forall a (m :: * -> *). (Monad m) => m Int -> m [a] -> m [a]
07:08:45 <Axman6> :P
07:09:01 <Axman6> > liftM2 take [1..3] [[1..5]]
07:09:02 <lambdabot>   [[1],[1,2],[1,2,3]]
07:09:05 <int-e> ski: now curry the whole thing :)
07:09:09 <Axman6> > liftM2 take [1..30] [[1..5]]
07:09:10 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5...
07:09:18 <ski> @type \mn mas x -> liftM2 take mn mas x
07:09:20 <lambdabot> forall t a. (Monad ((->) t)) => (t -> Int) -> (t -> [a]) -> t -> [a]
07:09:27 <byorgey> > let on2 f g = uncurry f . (g *** g) in liftM2 take (on2 lcm length) (on2 zip cycle) ([0..1],[0..3])
07:09:28 <lambdabot>   [(0,0),(1,1),(0,2),(1,3)]
07:09:30 <Axman6> > liftM2 (take *** drop) [1..30] [[1..5]]
07:09:31 <lambdabot>   Couldn't match expected type `a2 -> r'
07:09:31 <lambdabot>         against inferred type `([a] ...
07:09:35 <Axman6> > liftM2 (take &&& drop) [1..30] [[1..5]]
07:09:37 <lambdabot>   Couldn't match expected type `a2 -> r'
07:09:37 <lambdabot>         against inferred type `([a] ...
07:09:39 <Axman6> bah
07:09:57 <byorgey> @type on
07:09:57 <ski> @type \f g -> uncurry f . (g *** g)
07:09:58 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:10:00 <lambdabot> forall a c (a1 :: * -> * -> *) b. (Arrow a1, Functor (a1 (b, b))) => (a -> a -> c) -> a1 b a -> a1 (b, b) c
07:10:03 <int-e> ski: oh.  join (***) cycle  :)
07:10:40 <ski> int-e : i was thinking on that before, yes :)
07:10:56 <byorgey> Hunner: don't mind us, just having some #haskell-style fun =)
07:12:03 <Hunner> @hoogle (***)
07:12:04 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:12:26 <Hunner> oh, arrows. I've left those alone for now
07:12:26 <ski> @type \f g x -> (***) f g x
07:12:28 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
07:14:27 <ski> > curry (liftM2 take (uncurry (on lcm length)) (uncurry (on zip cycle))) [0..1] [0..3]  -- int-e : satisfied ?
07:14:29 <lambdabot>   [(0,0),(1,1),(0,2),(1,3)]
07:14:42 <Axman6> Hunner: i find they're actually easier to use than you might expect
07:15:33 <Axman6> Hunner: basically, Arrow a => a b c -> a b' c' -> a (b, b') (c, c') means: (a -> b) -> (a' -> b') -> (a,a') -> (b,b').
07:15:44 <Berengal> For some value of ->
07:16:04 <Axman6> so, you can apply two functions to a tuple, one to the first element, and one to the second:
07:16:24 <Axman6> > ((+1) *** show) (3,Nothing)
07:16:25 <lambdabot>   (4,"Nothing")
07:16:49 <int-e> @type liftM2 ?f ?g ?h ?x
07:16:51 <lambdabot> forall a1 a2 r t. (?f::a1 -> a2 -> r, ?g::t -> a1, ?h::t -> a2, ?x::t, Monad ((->) t)) => r
07:17:03 <int-e> @type ap (?f . ?g) ?h ?x
07:17:05 <lambdabot> forall a a1 b t. (?f::a -> a1 -> b, ?g::t -> a, Functor ((->) t), ?h::t -> a1, ?x::t, Monad ((->) t)) => b
07:17:10 <Veinor> http://i.imgur.com/vbVWJ.jpg
07:17:32 <Veinor> what in gods name?
07:18:06 <int-e> @type (.)
07:18:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:18:18 <Hunner> So what's the ?f ?h business then?
07:18:26 <int-e> Cale's bot. Okay, I was wondering about that additional Functor constraint.
07:18:49 <Axman6> Hunner: it lets you get the types of parts of an expression, along with the type of the whole expression
07:18:52 <int-e> Hunner: They're implicit arguments.
07:18:55 <Cale> Hey, that is strange.
07:19:06 <byorgey> Veinor: oh goodness.  Perl just keeps getting more and more ugly and ad-hoc, doesn't it?
07:19:13 <Axman6> :t map ?f [1..2]
07:19:15 <lambdabot> forall a b. (?f::a -> b, Num a, Enum a) => [b]
07:19:24 <Cale> A Functor ((->) t) constraint should disappear because it's satisfied, shouldn't it?
07:19:37 <Veinor> byorgey: and people say Haskell has a lot of confusing operators ;)
07:19:49 <int-e> Cale: apparently neither the monad nor the functor instances are in scope. odd.
07:20:17 <Axman6> Veinor: heh, i thought that was for haskell initially :P
07:20:24 <byorgey> Veinor: but Haskell operators are just defined in *libraries*.  These things are all *built-in* to the syntax of Perl!!
07:20:26 <int-e> @type join (,)
07:20:28 <Cale> int-e: The @type command has been acting strangely, even though it does appear to load L.hs, it behaves as if none of L.hs's imports are there.
07:20:28 <lambdabot> forall a. a -> (a, a)
07:20:30 <Veinor> apparently [\f] x = scanl1 f x
07:20:43 <Veinor> and [f] x = foldl1 f x
07:20:45 <Veinor> or something
07:20:59 <Botje> you guys should be happy
07:21:08 <Botje> the perl6 people are doing all the hard work of coming up with cool syntax
07:21:11 <Botje> which we can just steal :)
07:21:20 <Axman6> >_<
07:21:20 <Veinor> I have no clue what the fuck a 'hyper dwim all' is
07:21:45 <Veinor> also, first language I know of that has both a = and a :=
07:21:55 <Axman6> Botje: no they're not, they're all too busy realising that Haskell is for more awesome, after writing Pugs :)
07:21:55 <int-e> Cale: I don't know what's happening; I agree it's odd. Are overlapping instances allowed, preventing the compiler from simplifying contexts eagerly?
07:21:56 <Veinor> and a ::=, for that matter
07:22:11 <Cale> int-e: hmm...
07:22:16 <maltem> What language with a := does not have a = ?
07:22:17 <Axman6> Veinor: Ada has = and :=. though the former is equality
07:22:34 <Veinor> yeah, I meant in the context of assignment operators
07:22:37 <Axman6> i'd say Pascal does too
07:22:43 <nvoorhies> = := and ==
07:22:45 <Axman6> yeah, that is messed up
07:22:49 <Botje> Veinor: iirc the single "hyper" things map an operand over a list
07:22:54 <Veinor> so.... map?
07:22:57 <Botje> yeah
07:22:57 <Veinor> :V
07:23:02 <Botje> whereas >>op<< is a foldr
07:23:14 <Veinor> that's going to be confusing as hell
07:23:14 <Axman6> >>_<<
07:23:26 <nvoorhies> so they're borrowing even more from apl?
07:23:37 <Botje> most of the ops i see are just existing perl5 ops that are no longer overloaded
07:23:42 <Botje> hmm
07:23:43 <Axman6> i'm so glad i've only ever written one thing in Perl. i'll never do it again
07:23:46 <Botje> [op] is a foldr
07:23:49 <Botje> i wonder what >>op is, then
07:24:04 <Veinor> also apparently if you define infix f and infix \f there's literally no way to get perl to interpret [\f] as 'scan f' as opposed to 'fold \f'
07:24:07 <Botje> i'll find out after i write some more pages
07:25:16 <Veinor> also, I like all the method stuff in the bottom left
07:25:57 * Hunner wonders what would happen if haskell was taught as an introductory CS language for a semester before anything else was introduced
07:26:26 <Botje> Hunner: you'd have people saying "man, these for loops and assignment are hard!"
07:26:26 <Axman6> Hunner: that's what they did here...
07:26:34 <Axman6> they do it a fair bit actually
07:26:51 <Hunner> I couldn't take fb until third-year :/
07:26:55 <Hunner> fp*
07:27:11 <Botje> it's a master's course here, unfortunately
07:27:14 <Botje> right.
07:27:30 * Botje goes back to writing C++ assignments
07:27:56 <Veinor> people who grow up learning OOP find FP hard
07:28:02 <Axman6> haskell was the first thing they taught us here. and this was in the IT degree, not CS. it's also an IT course for engineers
07:28:03 <maltem> omg I have to moan again at these exercise sheets. "How to modify the program if one wants f to be a power series in x-1 instead of x? Apply your modified program to the example above. Why does it fail? What can one do?"
07:28:05 <Veinor> and vice versa
07:28:19 <Veinor> maltem: is it the poor grammar?
07:28:28 <Veinor> "how to x?" always annoys the crap out of me
07:28:35 <birdiee_> what is the opposite of fst?
07:28:39 <maltem> Veinor, no, that's due to me translating it while typing
07:28:40 <Axman6> snd?
07:28:43 <Botje> "one" as a subject annoys me more :)
07:28:43 <Axman6> :t snd
07:28:44 <lambdabot> forall a b. (a, b) -> b
07:28:46 <Veinor> ahh
07:28:49 <birdiee_> cool thanks Axman6
07:28:52 <Ferdirand> I was TA for a C++ programming course aimed at 1st year physics once. Some girl asked for help "i wrote pseudo-code but I cannot translate it to C++". Her pseudo-code was valid haskell. I cried.
07:29:11 <Axman6> birdiee_: i wouldn't call it the opposite personally :)
07:29:12 <maltem> Veinor, it's the way the prof supposes that we're thinking exactly the same as himself, at all times.
07:29:24 <Botje> Ferdirand: wow. that's .. bad
07:29:42 <Veinor> Ferdirand: .... what?
07:29:42 <maltem> I mean, "why does it fail" - how bad can an assignment be?
07:29:43 <Veinor> no way
07:29:56 <Axman6> Ferdirand: ... had she ever used haskell before?
07:30:10 <Ferdirand> Veinor: well, it was the first week, basic stuff, loops, recursion et al
07:30:11 <ksf> @remember Knuth I envy astronomers: People expect them to study stars because stars are beautiful and interesting?
07:30:12 <lambdabot> I will remember.
07:30:14 <Axman6> maltem: that shows understanding...
07:30:19 <absentia> fard: do you still have that pseudo code?
07:30:22 <ksf> http://www.simple-talk.com/opinion/geek-of-the-week/donald-knuth-geek-of-the-week/?utm_source=simpletalk&utm_medium=email&utm_content=newsletter20091130&utm_campaign=Opinion
07:30:35 <maltem> Axman6, ?
07:30:37 <Philonous1> Ferdirand: Well, but that makes it easy! Just let ghc dump the c
07:30:52 <Veinor> yeah, you should definitely post it
07:30:56 <absentia> I kep hearing that (1) haskell is a b!tch to get anyting to compile and (2) people keep writing pseudocode that's valid haskell ....   something smells.
07:31:02 <Axman6> @remember Ferdirand I was TA for a C++ programming course aimed at 1st year physics once. Some girl asked for help "i wrote pseudo-code but I cannot translate it to C++". Her pseudo-code was valid haskell. I cried.
07:31:02 <lambdabot> I will never forget.
07:31:07 <Axman6> @quote Ferdirand
07:31:08 <lambdabot> Ferdirand says: I was TA for a C++ programming course aimed at 1st year physics once. Some girl asked for help "i wrote pseudo-code but I cannot translate it to C++". Her pseudo-code was valid
07:31:08 <lambdabot> haskell. I cried.
07:31:22 <Ferdirand> oh great :p
07:31:51 <Axman6> maltem: if you can explain why something won't work, then it shows you know what you're doing, and not just fumbling your way through it
07:31:54 <Ferdirand> well, tbh it was *almost* valid haskell. (some parenthesis misplaced or so)
07:32:03 <Ferdirand> but the idea was definitely here
07:32:12 <int-e> absentia: I take it that these are not the same people saying it. :)
07:32:13 <absentia> still...  that's closer than ... I've been working on this one line for 60 minutes, I *still* can not get it to work.
07:32:25 <absentia> int-e:  no.  obviously.
07:32:25 <Axman6> Ferdirand: so they'd never used haskell before?
07:32:39 <Ferdirand> nope. most of them had no experience in programming at all.
07:32:54 <Axman6> >_<
07:33:00 <maltem> Axman6, the problem is that the flaky program is not given in the assignment. I have to invent it myself, explain why that's how to do it, then explain why it does not work.
07:33:02 <int-e> absentia: and of course it depends on what you're trying to do. writing ... uh, Fortran programs, to fit the cliche, in Haskell is quite hard.
07:33:02 <Axman6> did you introduce her to haskell?
07:33:15 <ksf> absentia, you should try sending a pizza to oleg. ghc sends all your programs to him for typechecking.
07:33:15 <absentia> I can't imagine haskell is the best choice for people who have never had any experience at programming.. ever.
07:33:19 <Axman6> maltem: yeah, that's less cool
07:33:33 <Cale> absentia: It's worked out rather well in the people I've tutored.
07:33:37 <absentia> ksf: wha?
07:33:49 <int-e> absentia: some people (including myself) seem to think that this is an advantage of Haskell.
07:33:58 <Axman6> absentia: i dunno, lots of people have done algebra. haskell's not that big of a leap
07:34:07 <ksf> yes. we harness the power of oleg every time we compile a file.
07:34:33 <Ferdirand> for these guys, writing (x=x+1) was infinitely more confusing than recursion, it seems
07:34:54 <int-e> > let x = x+1 in x -- how is this not confusing?
07:34:57 <Axman6> absentia: GHC has a somewhat working typechecker, but it always checks with Oleg before returning. that's why compilation isn't that fast
07:34:59 <lambdabot>   mueval-core: Time limit exceeded
07:35:04 <ksf> absentia, if you could imagine it, you'd be able to forget all you previously learned about programming, at which point your code would work.
07:35:30 <absentia> ksf: ya... that's the issue -- damn day job!
07:35:48 <Veinor> int-e: x = x + 1 isn't confusing to me :/
07:35:48 <Reinz> hello
07:35:58 <Axman6> g'day Reinz
07:36:06 <QtPlaty[HireMe]> Veinor: You are an experenced programer thoug.
07:36:10 <maltem> Axman6, I remember something else going like: We substitute foo by bar and experience a miracle: [... result of substution ...] Assignment: Explain the miracle.
07:36:10 <Veinor> because I learned imperative programming so I'm in the mindset of 'do this! do that! now do the other!'
07:36:29 <Axman6> Cale: any chance for a @flush?
07:36:33 <absentia> v: me too.
07:36:33 <absentia> :-<
07:36:40 <Reinz> Can you help me please?
07:36:43 <QtPlaty[HireMe]> Veinor: But think of x = x +1 when you have only ever done algreba
07:36:48 <Philonous1> Axman6: But ghc can enumerate all primes in finite time when you rename your .hs files to .praise-oleg
07:36:50 <absentia> I fear my haskell will end u being one long do block
07:36:56 <Axman6> Reinz: not if we don't know your problem
07:37:04 * ksf started out with pascal, and that uses := for assignment.
07:37:11 <Veinor> Philonous1: and then solve the riemann-zeta hypothesis!
07:37:20 <Philonous1> @faq
07:37:20 <lambdabot> The answer is: Yes! Haskell can do that.
07:37:22 <Axman6> QtPlaty[HireMe]: easy, it's false :P
07:37:25 <ksf> definitely makes sense, although I despice that excuse for a language in all other ways there are.
07:37:36 <Reinz> My friend,  I need your help, please rigister at this link: http://vk.com/reg5432221  This is social network like facebook. You will help me very much, thanks!!!
07:37:42 <absentia> that was because wirth had an issue with 3 = 4 ...  ie:  x = 3;  x = x + 1;  // no, x != x +1
07:37:48 <Axman6> @where ops
07:37:48 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:38:21 <absentia> ooh, make friends fast!
07:39:18 <Veinor> That looks a lot like facebook.
07:39:39 <Axman6> Veinor: i do hope you didn't visit that whole link :(
07:39:39 <Veinor> Like, I'm fairly sure they ripped code straight from facebook.
07:39:46 <Veinor> why not?
07:39:53 <Philonous> absentia: Did you post the offending line of code you mentioned here?
07:40:29 <Veinor> 's not like I'm going to register :P
07:40:31 <Axman6> they are supposed to get money for each person who clicks their link
07:40:47 <Axman6> you just gave money to a spammer basically
07:40:53 <Veinor> nah, it's only for signups
07:40:57 <Axman6> well, that's the story anyway
07:40:58 <Veinor> usually
07:41:02 <absentia> phil:  no... sorry, was something from a while ago (and it wasn't an hour, more like 5-6 minutes.. but felt like forever).  whenever learning a new language, there's always that phase where just getting the grammar to work is an issue...   once I get to where I can write valid lines in a language, then it's possible to get better in the language.
07:41:21 <Veinor> vOv
07:41:49 <absentia> I followed it.... so that I could learn the domain to avoid it in the future.
07:41:49 <Berengal> Nothing wrong with giving money to spammers. If you do it enough, the companies funding them'll go bankrupt
07:41:57 <absentia> no one is going to get rich getting pennies per click... not that way.
07:42:06 <Veinor> but yeah, the UI, the phraseology, everything just remind me of facebook
07:42:21 <Veinor> wanna bet they copied the ToS and then did a search/replace where appropriate?
07:42:33 <Cale> @flush
07:42:55 <Axman6> ta
07:43:05 <absentia> my question is:  just like facebook... why bother? when we have the real facebook?  what could this place possibly offer ?  and, with all that they ask just to get in, seems like it could be harvesting email addresses for spam  (sorry, russian version) ... so I'm not going anywhere near it.
07:43:34 <Veinor> absentia: but they have 50 MILLION PEOPLE :O
07:43:43 <Axman6> heh
07:43:45 <absentia> like the old page:  HAS YOUR CREDIT CARD NUMBER BEEN STOLEN ON THE INTERNET?  PLEASE ENTER IT HERE _________ TO BE CHECKED>  You enter a/the number and it goes "YUP!  IT'S BEEN STOLEN!"   h0h0h0h0.
07:43:56 <Hunner> I wantone of those periodic table of the operators for Haskell :)
07:44:16 <absentia> V: and not a single one of my friends... so, again, useless.
07:44:25 <Axman6> absentia: ha, never seen that before :)
07:44:26 <Hunner> Something I can hank on a wall
07:44:48 <Berengal> Hunner: Haskell has an infinite number of potential operators
07:45:12 <Veinor> Berengal: depends on whether you go with the spec or actual implementations :P
07:45:24 <Veinor> in practice it's bound by the information content of the universe
07:45:26 <Axman6> the spec has limitations?
07:45:38 <camio> It might be interesting to see that table of operators in the haskell platform.
07:45:41 * Berengal should write a library that only has operators and only uses * as an operator symbol
07:45:53 <Berengal> Acme.Prelude, perhaps?
07:45:56 <Axman6> Veinor: not really, we can create them lazily, using constant(ish) space :P
07:46:03 <Hunner> Berengal: yeah, it doesn't have to be very comprehensive. thre are many that are more widely used than others, and maybe it could just be the Prelude or what's in the HP or something
07:46:09 <Veinor> camio: ah, but where do you draw the line between operators and functions?
07:46:30 <Berengal> Is div an operator?
07:46:30 <Berengal> Is `div` ?
07:46:35 <Veinor> is map?
07:46:36 <Axman6> no
07:46:47 <Veinor> because perl 6's map is on that table
07:46:48 <Axman6> it's in the prelude though, so it doesn't matter :P
07:47:04 <absentia> I thought the only working implementation of perl 6 was done in haskell
07:47:08 <Berengal> Sometimes I wish we had more operators...
07:47:11 <absentia> that's... embarassing for perl6.
07:47:22 <Axman6> absentia: i do believe you're right
07:47:25 <Botje> absentia: rakudo is picking up steam, actually
07:47:34 <camio> Veinor: I'm referring to all infix functions. No syntax sugar.
07:47:46 <Berengal> > let (Â¤) = map in (^2) Â¤ [1..10]
07:47:47 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
07:47:56 <Veinor> just in the prelude then? it'd be pretty small I'd imagine
07:48:04 <Berengal> Why do I never see Â¤ as an operator?
07:48:08 <camio> Veinor: No, all in the haskell platform.
07:48:14 <Veinor> ahh
07:48:16 <camio> Veinor: There's lots of stuff there.
07:48:29 <Veinor> so anything in hackage?
07:48:50 <camio> Veinor: The haskell platform includes "blessed" packages from hackage.
07:49:00 <Veinor> oh, that's what you meant. okay.
07:49:14 <Berengal> Sure there're no overlaps?
07:49:17 <Veinor> brb writing a program to generate a program that has definitions for every possible operator ;)
07:49:24 <zygoloid> > (*******) ***** ((******* " ") **** (******) **** ["he" ****** "llo", "wo" ****** "rld"])
07:49:26 <lambdabot>   "hello world "
07:49:39 <Axman6> ...
07:49:39 <camio> Berengal: I know for sure there _are_ overlaps. Like . from Prelude and . from Control.Category.
07:49:49 <Berengal> zygoloid: Now we're talking
07:49:51 <Axman6> zygoloid: is that miranda?
07:50:12 <zygoloid> Axman6: that's Censored Haskell
07:50:26 <Berengal> camio: There's even an overlap in the implementation. Control.Category.(.) is specialized to Prelude.(.) for functions
07:50:28 <Veinor> zygoloid: I hate you
07:50:52 <zygoloid> hooray! i made a new enemy!
07:50:52 <camio> interesting
07:50:57 <Veinor> @src ******
07:50:57 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:51:05 <Berengal> @type (*****)
07:51:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:51:15 <Veinor> @type (******)
07:51:15 <Berengal> @type (*******)
07:51:16 <lambdabot> forall m. (Monoid m) => m -> m -> m
07:51:17 <lambdabot> forall a. a -> a
07:51:21 <Veinor> @src (******)
07:51:21 <lambdabot> Source not found.
07:52:16 <Cale> absentia: It's a bit sad, but pugs has been inactive since mid 2007 apparently.
07:52:48 <pozic> Does anyone understand the Apache2 license here?
07:52:50 <absentia> this haskell is too advanced for me.
07:52:51 <Axman6> Cale: all the devs gave up on perl, and moved to using haskell
07:53:22 <camio> Axman6: Is that a statement or a question?
07:53:35 <Axman6> a probably false statement :)
07:53:37 <absentia> Pugs is a compiler and interpreter for the Perl 6 programming language, started on February 1, 2005 by Audrey Tang. Pugs development has all-but died off with most Perl 6 development work now taking place on Rakudo, however its source repository is still used for storing the official Perl 6 test suite.
07:53:39 * Hunner thisk it's sarcasm
07:53:40 <roconnor> what's the best way of checking if a list has unique elements?
07:53:47 <absentia> ya, I use to use perl... but then I moved to C++.  :-)
07:53:48 <roconnor> I have nub l = l at the moment.
07:53:54 <roconnor> nub l == l
07:54:03 <saml> absentia is a mad C++ skill
07:54:04 <roconnor> my list isn't very long
07:54:09 <Berengal> roconnor: Set.fromList
07:54:11 <Berengal> ?
07:54:17 <Axman6> Hunner: it's somewhat true. Pugs was written in haskell, and a lot of the developers ended up liking haskell a lot
07:54:24 <maurer_> Is it possible to write a function that would work similarly to map or fmap, but would keep going down the chain of nested functors/nested lists until it hit something that wasn't a functor/list?
07:54:24 <roconnor> Berengal: I want a bool check
07:54:58 <saml> maurer_, yes, give me a type for that map
07:55:12 <maurer_> sami: That's part of the problem, I don't know how to express this type
07:55:13 <Berengal> roconnor: Doesn't Set provide some sort of insert function that also returns if it existed or not?
07:55:27 <roconnor> does it?
07:55:32 <Berengal> roconnor: I think that's the way to go if you want something better than nub anyway...
07:55:33 <Axman6> maurer_: i have a feeling it isn't
07:55:35 <poe> roconnor Set.toList Set.fromList might do it?
07:55:40 <Berengal> roconnor: But it requires Ord...
07:55:49 <maurer_> sami: It would be something like (a -> a) -> [(n)a](n) -> [(n)a](n)
07:55:49 <roconnor> poe: what is the check?
07:55:57 <saml> how about Collection -> Maybe Collection
07:55:58 <maurer_> Where [(n) is n brackets
07:55:59 <Axman6> maurer_: since there's no way to say: instance (not Functor a) => Blah a where...
07:55:59 <roconnor> I don't want the list of unique elements
07:56:00 <Berengal> Well, anything faster than nub does require Ord anyway
07:56:05 <roconnor> I want to know if my list has only unique elements
07:56:26 <Berengal> Size comes to mind...
07:56:32 <Berengal> (==) also works for nub...
07:56:33 <Cale> maurer_: I think it's possible using fancy typeclasses, but probably more trouble than it's worth.
07:56:39 <maurer_> OK
07:57:10 <roconnor> but (==) doesn't work for to/from Set
07:57:15 <roconnor> at least I don't see how.
07:57:16 <Berengal> No, it doesn't
07:57:19 <Axman6> it might be possible using overlapping typeclasses
07:57:27 * Berengal looks up the Data.Set API
07:57:38 <saml> is typeclass haskell98?
07:57:59 <Axman6> saml: yes. or else we wouldn't have Num etc :)
07:58:00 <Cale> saml: single parameter typeclasses are
07:58:17 <Axman6> and we'd have to use Double.+, Int.+, Integer.+ all the time
07:58:23 <Cale> saml: with very restrictive conditions on what the instances look like
07:59:17 <maurer_> Cale: Oh, are you suggesting I might be able to do it by making all functors/collections be a member of some typeclass that has this function defined on them recursively, and then I assign an instance to every terminal type I want that actually just performs the function?
08:00:30 <Cale> maurer_: Yeah, something like that
08:00:41 <Cale> maurer_: You're bound to run into ambiguity issues
08:00:54 <Cale> But there's probably a way to deal with them, given enough GHC flags ;)
08:00:57 <Botje> maurer_: if you only want to process the leaves, look into SYB and Uniplate
08:01:09 <maurer_> OK, that's a little awkward, and I think it doesn't actually help me solve the problem I'm actually trying to solve :(
08:01:17 <Botje> (if you don't have control over the data structure, maybe)
08:01:21 <Cale> What are you actually trying to solve?
08:01:22 <maurer_> (the actual goal here is that I'm trying to write an N-D convolution function)
08:01:31 <Cale> N-D?
08:01:38 <Cale> oh, N dimensional
08:01:38 <Berengal> roconnor: Data.Set doesn't have the insert returning a bool, but Data.Map has a function called insertLookupWithKey, which returns Maybe oldKey
08:01:49 <Berengal> roconnor: You could do it with a Data foo ()
08:01:56 <roconnor> hmm
08:01:59 <maurer_> Cale: Yeah. So I was trying to solve the problem I ran into when I went to typesign it.
08:02:14 <maurer_> (before beginning to try to write it)
08:02:23 <Berengal> roconnor: A mapAccum, followed by and . map not
08:02:36 <poe> roconnor what can we assume on the contents of the list, just Eq? or Ints?
08:02:58 <opqdonut> Berengal: not . or plz :)
08:03:00 <poe> Berengal or any :)
08:03:42 <Berengal> all not
08:04:04 <Berengal> @src any
08:04:05 <lambdabot> any p =  or . map p
08:04:08 <Berengal> @src all
08:04:08 <Cale> maurer_: Well, if you want it to work on arbitrarily nested lists, yeah, that's kind of awkward.
08:04:09 <lambdabot> all p =  and . map p
08:04:50 <maurer_> Cale: Yeah, I guess I'll try it with a parameter n. While I don't know how that would be typesigned still, I can at least see how to write it.
08:05:23 <Cale> maurer_: Well, you'd need a *type* level n, if it's going to be receiving nested lists as well
08:05:28 <Cale> maurer_: It's potentially easier to make it work on arrays whose indices support some kind of additional operation.
08:05:54 <maurer_> Cale: Except one of the explicit use cases for this involves convoluting a pyramidal structure, and Arrays will be sad about that.
08:05:59 <Cale> ah
08:06:10 <Cale> Maybe some sort of trees?
08:06:50 <maurer_> Maybe? Maybe I should just write a 3D pyramidal convolution function and a 2D convolution function and leave it at that.
08:07:07 <Cale> That's quite possibly simpler :)
08:07:34 <Cale> I'm actually not sure exactly what the code would look like for a polytypic convolution.
08:08:18 <Cale> You need some way of defining what all the possible translations are.
08:08:33 <fasta> Did anyone manage to install openil/imagedevil on Windows?
08:09:00 <Cale> maurer_: However, if you can do that... perhaps you can make it entirely polymorphic
08:10:17 <Cale> maurer_: Actually, there's something which seems very comonadic about this.
08:11:16 <poe> > any (\(x:xs) -> elem x xs) . init . tails $ ([1..5] ++ 10 : [6..10])
08:11:18 <lambdabot>   True
08:11:53 <Cale> maurer_: Let me think about it a bit :)
08:11:59 <maurer_> Cale: Thanks.
08:12:33 <dmwit> > (\xs -> nub xs == xs) ([1..5] ++ 10 : [6..10]) -- poe
08:12:35 <lambdabot>   False
08:12:41 <dmwit> well
08:12:45 <dmwit> > (\xs -> nub xs /= xs) ([1..5] ++ 10 : [6..10]) -- poe
08:12:46 <poe> dmwit looking for other ways :)
08:12:48 <lambdabot>   True
08:13:01 <dmwit> ok =)
08:13:08 <roconnor> poe: Ints let say
08:13:14 <ski> (Berengal : "`div`" is an operator, yes)
08:13:38 * Axman6 would not say that "div" is though
08:13:39 <ski> (Cale : s/polytypic/polytopic/ ?)
08:13:41 <Berengal> ski: Are all functions operators, by extension?
08:13:49 <ski> Axman6 : agreed
08:13:52 <Cale> ski: Presumably both
08:13:56 <Cale> :)
08:14:11 <Cale> ski: But the type issue was my main concern at the time
08:14:53 <poe> > ((==) <*> (IS.toList . IS.fromList)) [1,2,3,4,5,6,7,8,] -- roconnor
08:14:54 <lambdabot>   <no location info>: parse error on input `]'
08:15:01 <poe> oops :)
08:15:41 <Berengal> poe: That fails, because Set.toList won't preserve the original order
08:15:42 <Axman6> IS?
08:15:47 <Axman6> IntSet?
08:16:08 <poe> Berengal oh too bad. lenght and IS.size is not good though :/
08:16:24 <poe> Maybe nub /is/ the best way.
08:16:27 <dancor> i think it's only out of laziness that ghci doesn't parse to determine that a = b means let a = b
08:16:36 <dancor> does anyone (dis)concur?
08:16:44 <Berengal> poe: length is bad, but can be had for free with a mapAccum...
08:16:48 <dancor> afterall, it determines that a means print a
08:17:07 <poe> Baughn mapAccum[LR] is a good idea!
08:17:11 <Berengal> poe: And don't sets remember their sizes?
08:17:13 <dpratt71> what is the likelyhood that a broken Haddock package would cause problems when installing another package via Cabal (sans documentation)?; I think these issues are unrelated, but I'm not certain
08:17:16 <ski> Prelude> :i elem
08:17:16 <ski> infix 4 `elem`
08:17:16 <ski> elem :: Eq a => a -> [a] -> Bool
08:17:30 <poe> Berengal yes that is IS.size
08:17:37 <ski> (^ an operator with a corresponding fixity declaration)
08:18:25 <roconnor> > 2^17
08:18:26 <Berengal> ski: So anything that's defined with operator symbols or have a fixity declaration is an operator by your definition?
08:18:27 <lambdabot>   131072
08:18:34 <roconnor> that's not so big
08:19:13 <ski> Berengal : no, anything that is constructed by operator characters (and is not reserved), as well as any name surrounded by backticks
08:19:24 <Cale> maurer_: A comonad w is a type of functor with a function  extract :: w a -> a  (which intuitively extracts the value at the 'origin'), and  duplicate :: w a -> w (w a)  which intuitively produces a structure consisting of all the translations of the structure you feed it.
08:19:30 <ski> so e.g. "`not`" is an operator
08:19:52 <poe> > not . or . snd . mapAccumL (\s x -> (S.insert x s, S.member x s)) S.empty $ [1,2,3,4,5,6,6]
08:19:54 <lambdabot>   False
08:20:19 <Axman6> woah... there's some ... well sort of scary code here: http://www.cs.nott.ac.uk/~gmh/calculator.lhs
08:20:40 <maurer_> Cale: I'll have to think that over. It seems to make sense, but I do not immediately see how to write duplicate (though extract kinda makes sense)
08:20:58 <Cale> maurer_: Well, for indexed structures, there's a pretty generic way to do it
08:21:02 <Berengal> poe: Uses two traversals of the set, which made me unhappy that there wasn't a insertElem :: a -> Set a -> (Bool, Set a) functions defined...
08:21:11 <Cale> maurer_: So long as your indices have a monoid operation :)
08:21:32 <Berengal> or insertUnique :: a -> Set a -> Maybe (Set a)
08:21:34 <maurer_> Cale: Thanks. I'll think about it.
08:21:39 <Cale> maurer_: But for a convolution, we'll need a little more than this
08:21:40 <poe> Berengal no Eq a constraint?
08:21:54 <maurer_> OK, I assumed the extract operation was taking a step of the convolution.
08:21:57 <Berengal> poe: Sets require Ord anyway :P
08:22:14 <maurer_> Oh, I see, the extract operation can't technically do that unless we assume possibly untrue things about the structure to be used for the convolution.
08:22:15 <Cale> maurer_: Well, it's close.
08:22:58 <Cale> maurer_: We'll need an operation which we can implement on any functor already which has the same type as duplicate, but which *really* duplicates the structure :)
08:23:57 <Cale> copy :: (Functor w) => w a -> w (w a); copy x = fmap (const x) x
08:24:03 <ski> @type \x -> (x `not`)
08:24:05 <lambdabot> Bool -> Bool
08:24:18 <Cale> maurer_: next, we'll need an operation which "zips" two such structures
08:24:42 <Cale> (and this I don't think we can get from just Functor and Comonad, but I'm willing to be proven wrong ;)
08:24:59 <zygoloid> "(Monoid r) => (->) r" is presumably a comonad: extract = ($ mempty); duplicate f a b = f (a `mappend` b)
08:25:13 <Cale> That is, we'll want  fzip :: w a -> w b -> w (a,b)
08:25:26 <Cale> zygoloid: right
08:25:39 <ski> Cale,maurer_ : may i ask what you're trying to do ?
08:25:42 <poe> what kind of convolution are you talking about?
08:25:57 <maurer_> Yeah, the fzip that is predefined requires an instance of the zip class as well
08:25:57 <Cale> ski: Write as general as possible a convolution operation
08:26:04 <maurer_> ski: We're trying to get an n-dimensional arbitrary shape convolution operation
08:26:45 <Berengal> fzip implies ap, does it not?
08:26:51 <maurer_> poe: The kind where you overlap some sampling mask on the space, do some kind of zipping operation (usually *) then some kind of folding operation (usually +) and do this everywhere that it fits in the space
08:26:54 <Berengal> And vice versa
08:27:08 <ski>   convolute :: Num a => (Nat -> a) -> (Nat -> a) -> (Nat -> a)  -- like this but more general ?
08:27:20 <zygoloid> Cale: i think you 'clearly' can't get fzip because none of your productions can merge two w-structures into one.
08:27:30 <Cale> zygoloid: right
08:27:49 <ski>   convolute f g n = sum [f i * g j | i <- [0..n] , let j = n - i]
08:27:50 <Cale> zygoloid: though strange things happen in Hask. All monads are strong, for example.
08:28:02 <Berengal> fzip = ap (,)
08:28:03 <maurer_> zygoloid, Cale: Though, we can restrict ourselves to things which can merge like that.
08:28:28 <maurer_> zygoloid, Cale: The most basic way to think of this is in terms of lists rather than full fledge functors, and for those concatenation is fine.
08:28:42 <Berengal> Alternatively, ap fs xs = fmap ($) (fzip fs xs)
08:28:47 <Cale> maurer_: concatenation I don't think we'll need
08:28:51 <Cale> maurer_: just zipping
08:29:02 <maurer_> Cale: Yes, but concatenation implements join
08:29:08 <Cale> hm?
08:29:24 <maurer_> Well, in the case of the list functor, which was our sample
08:29:25 <zygoloid> Cale: haskell has ruined category theory for me :) it seems 'obvious' that all monads are strong ;-)
08:30:06 <maurer_> zygloid's reasoning on why we couldn't get it is that we can't do the operations w (w a) -> w a or  (w a) -> (w a) -> (w a) which we can if we apply the appropriate restrictions
08:30:28 <Saizan> Berengal: maybe liftA2 (,), actually, but fzip presumably wants to be left or right inverse of an funzip xs = (fmap fst xs, fmap snd xs) and that's not guaranteed by ap
08:31:03 <Cale> maurer_: anyway, the idea will be to take our structure x and  fzip (copy x) (duplicate x)
08:31:34 <Cale> maurer_: and then fmap some kind of summarisation over that -- probably a pointwise product followed by a sum
08:31:46 <roconnor> > [1,1]\\[1]
08:31:48 <lambdabot>   [1]
08:32:22 <zygoloid> Cale: sounds like you want: fmap (x,) (duplicate x) ?
08:32:23 <Cale> So it'll look like  fmap (sum . fmap (uncurry (*))) (fzip (copy x) (duplicate x)
08:32:42 <Cale> zygoloid: that's another way to put it, yeah
08:32:49 <Cale> er, hmm
08:33:00 <Cale> Perhaps we don't really need the zip operation after all, see? :)
08:33:05 <zygoloid> hehe ;-)
08:33:12 <Cale> Strange things happen in Hask, I'm telling you
08:33:27 <Cale> fmap (sum . fmap (uncurry (*))) (fmap ((,) x) (duplicate x))
08:33:38 <maurer_> zygloid: What is this comma operator you keep using? I'm unfamiliar.
08:33:39 <zygoloid> Cale: looks like the same strength thing we get with monads :)
08:33:39 <Cale> and look at that it works on an arbitrary comonad
08:33:41 <roconnor> @hoogle [a] -> Bool
08:33:42 <lambdabot> Prelude null :: [a] -> Bool
08:33:42 <lambdabot> Data.List null :: [a] -> Bool
08:33:42 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
08:33:46 <roconnor> @hoogle a -> [a] -> Bool
08:33:46 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
08:33:47 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
08:33:47 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
08:34:11 <zygoloid> maurer_: that's a new GHC extension. (x,) == \y -> (x, y)
08:34:38 <Cale> maurer_: so we can get convolution to work on anything for which we can define a comonad instance.
08:34:45 <maurer_> zygoloid: Ah, how new of a version of ghc do you need for that?
08:34:52 <Berengal> zygoloid: Does it work for (,x) too? What about (x,,y)?
08:34:54 <Cale> maurer_: (and for which we can define sum)
08:35:05 <maurer_> Cale: Cool. I _think_ it makes sense, I'm going to give it a shot.
08:35:05 <zygoloid> maurer_: i think it's in 6.12
08:35:19 <zygoloid> Berengal: yep.
08:35:24 <Berengal> Neat
08:36:58 <Saizan> if you google "convolution is comonadic" you get a sigfpe post :)
08:37:19 <zygoloid> @type let duplicate :: Functor f => f a -> f (f a); duplicate = undefined in  fmap (sum . fmap (uncurry (*))) (fmap ((,) x) (duplicate x))
08:37:21 <lambdabot>     Couldn't match expected type `[(a, a)]'
08:37:21 <lambdabot>            against inferred type `(Expr, a1)'
08:37:21 <lambdabot>     In the first argument of `fmap', namely `((,) x)'
08:37:33 <zygoloid> @type let duplicate :: Functor f => f a -> f (f a); duplicate = undefined in  fmap (sum . fmap (uncurry (*))) (fmap ((,) ?x) (duplicate ?x))
08:37:35 <lambdabot>     Couldn't match expected type `[(a, a)]'
08:37:35 <lambdabot>            against inferred type `(a1, a2)'
08:37:35 <lambdabot>     In the first argument of `fmap', namely `((,) ?x)'
08:37:45 <Cale> Saizan: sigfpe and I seem to have very similar interests and thoughts
08:38:08 <Cale> Except for the stuff about robots and special effects :)
08:38:17 <Saizan> heh :)
08:38:36 * Axman6 wishes that Cale would follow sigfpe's lead and not force his ideas on others
08:38:47 <maurer_> I should really get around to reading sigfpe's stuff someday.
08:39:25 <zygoloid> @type let extract :: Functor f => f a -> a; extract = undefined; duplicate :: Functor f => f a -> f (f a); duplicate = undefined in  fmap (sum . uncurry ((*) `on` extract)) (fmap ((,) ?x) (duplicate ?x))
08:39:27 <lambdabot> forall a (f :: * -> *). (Functor f, Num a, Num [a], ?x::f [a]) => f a
08:39:36 <Berengal> Axman6: We need more forcing of ideas. If nobody forces their ideas on others, we won't get bad ideas replaced by good ones. And if for some reason people start forcing bad ideas, we can throw rocks at them. Other hard object too, if you want.
08:40:17 <zygoloid> Cale: looks like you still need the fzip in order to compute the inner product
08:40:22 <jmcarthur_work> i disagree with throwing rocks at what we see as bad ideas
08:40:34 <Axman6> Berengal: there are helpful and unhelpful ways to force ideas on people. getting the spec changed is one good way.
08:40:35 <Berengal> jmcarthur_work: metaphorically speaking
08:40:43 <jmcarthur_work> i disagree with forcing any ideas though
08:40:55 <jmcarthur_work> can't we all just get along?
08:40:59 <camio> Axman6: Good, but not necessarily helpful.
08:40:59 <Cale> zygoloid: fmap (uncurry (*)) will do the product part
08:41:09 <Cale> zygoloid: oh
08:41:20 <Berengal> jmcarthur_work: conflict breeds progress.
08:41:21 <Cale> zygoloid: right we need to extract somewhere
08:41:40 <maurer_> Urgh. Went to install hsce for the comonad class, and cabal-install updated to a borken state :/
08:41:56 <jmcarthur_work> Berengal, if we quell unpopular ideas we have no conflict upon which to progress
08:42:08 <zygoloid> @type let extract :: Functor f => f a -> a; extract = undefined; duplicate :: Functor f => f a -> f (f a); duplicate = undefined in  fmap (uncurry ((*) `on` extract)) (fmap ((,) ?x) (duplicate ?x))
08:42:08 <jmcarthur_work> that is my issue with "throwing rocks"
08:42:10 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a, ?x::f a) => f a
08:42:14 <zygoloid> Cale: ^^ that?
08:42:22 <Berengal> jmcarthur_work: I didn't say unpopular. I said bad :P
08:42:43 <jmcarthur_work> Berengal, what is a bad idea if not one which is unpopular?
08:42:58 <zygoloid> Cale: that's the same as: "fmap (extract x *) x" i think?
08:43:06 <Berengal> jmcarthur_work: But the point is that unpopular ideas are, well, unpopular. If nobody tries to force those unpopular ideas onto others, they'll effective quell themselves
08:43:19 <Cale> zygoloid: you're missing the duplicate
08:43:27 <jmcarthur_work> Berengal, perhaps we use "force" in different ways
08:43:32 <Cale> zygoloid: er, in your reformulation, anyway
08:43:32 <zygoloid> Cale: the duplicate is cancelled by the extract
08:43:42 <Saizan> jmcarthur_work: one that you can show has bad consequences, suspension of judgement is good until you've some facts to make a judgement with
08:43:44 <jmcarthur_work> i have no problem with *promoting* your unpopular ideas
08:43:49 <Cale> oh
08:43:53 <Berengal> jmcarthur_work: This is why I do my best to get more people to use haskell, instead of accepting Java as a supperior language
08:44:23 <Cale> oh, right, we can't just look at the tips
08:44:38 <birdiee_> @src ($)
08:44:38 <lambdabot> f $ x = f x
08:44:58 <jmcarthur_work> Saizan, that is a reasonable definition of "bad idea" i suppose, but it's still going to depend on the unpopularity of the consequences
08:45:25 <byorgey> as we all know, "unpopular" and "bad" are NOT synonymous. =)
08:45:39 <jmcarthur_work> byorgey, :)
08:46:18 <poe> The speed of light being an universal constant was unpopular :^)
08:46:19 <jmcarthur_work> byorgey, to those not in our group, your statement may not hold so true
08:48:14 <byorgey> jmcarthur_work: well, that depends on whether you think there are any external objective standards of good/badness.
08:48:46 <jmcarthur_work> byorgey, i do not, in general. that is basically my point
08:49:08 <byorgey> ok, point taken; I happen to disagree =)
08:49:25 <jmcarthur_work> byorgey, to "throw rocks" at what we perceive as bad ideas is something i perceive as tyranny of the majority
08:50:03 <byorgey> jmcarthur_work: oh, I don't like the idea of "throwing rocks" either (although I don't know what exactly Berengal meant by that originally).
08:50:24 <dancor> you can even abstract polemics!
08:50:42 <jmcarthur_work> byorgey, and i also take issue with that kind of closed-minded attitude, that ones own ideas are inherently better than all others'
08:51:15 <jmcarthur_work> byorgey, i think i have an idea of what he meant... something far less aggressive than it sounds
08:51:26 <byorgey> jmcarthur_work: yes, probably =)
08:52:04 <Saizan> actually the point was accepting ideas from others, unless you can tell they are bad
08:52:06 <byorgey> jmcarthur_work: I agree with you there, but I would make a distinction between believing that one's ideas are superior, and believing that they are superior *just because they are yours*
08:52:36 <dancor> isn't forcing an anti-forcing pacifist idea still forcing an idea
08:52:56 <byorgey> anyway, this should probably go to #haskell-blah =)
08:53:04 <byorgey> and also, I need to go to school!
08:54:03 <jmcarthur_work> Saizan, i believe i have made a reasonable argument that your definition for badness relies on a subjective judgement of consequence
08:54:28 <jmcarthur_work> dancor, i am promoting, not forcing ;)
08:54:31 <mmorrow> <jmcarthur_work> can't we all just get along?
08:54:33 <mmorrow> no
08:54:39 <mmorrow> :)
08:54:48 <Berengal> jmcarthur_work: promoting == forcing, if you squint a bit ;)
08:55:17 <jmcarthur_work> Berengal, that is what i thought you were getting at. i simply disagree with that one
08:56:29 <Berengal> jmcarthur_work: Well, my way of looking at it leaves you with a language having one less distinction, so I guess it's inferior
08:56:43 <jmcarthur_work> haha
08:57:37 <dancor> > "opinions are like " ++ undefined
08:57:37 <lambdabot>   "opinions are like * Exception: Prelude.undefined
08:57:37 <Saizan> jmcarthur_work: it's not a reasonable argument, it's a belief :) i'm with byorgey on the matter of there being an objective standard of good/badness
08:57:57 <mmorrow> they say that history's written by the victors, they're no points for second place, blah blah
08:59:12 <dancor> take it to #haskell-believes-in-objective-utility
09:00:05 <abuiles> Hi there, I have been writing some code which was implemented with functional dependencies, but instead using Type Families, and I'm just getting something wrong and haven
09:00:14 <abuiles> been able to fixed
09:00:16 <jmcarthur_work> Saizan, i suppose my argument is about decisions of direction more than whether an idea fits a preestablished direction. the former determines the criteria for badness
09:00:16 <abuiles> more http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5202#a5202
09:00:17 * mmorrow mispelled #haskell-believes-in-objective-utility, ended up in #java, decides he's really bad at spelling
09:00:32 <jmcarthur_work> dancor, sorry
09:00:33 <abuiles> *haven't
09:01:06 <mmorrow> *speling
09:01:09 <fasta> abuiles, which compiler are you using?
09:01:24 <dancor> haskell is bad for a shell lang bc it keeps everything around forever, compilation is slow, and probably some other things.  what's better, ocaml?
09:01:43 <abuiles> fasta: ghci 6.10.4
09:01:51 <dancor> i'm interested in haskell as a shell lang bc of FP and conciseness
09:01:53 <jmcarthur_work> dancor, who says it keeps everything around forever?
09:01:58 <mmorrow> dancor: they have faster hash tables, and furthermore faster overwriting of variables in general.
09:01:58 <fasta> dancor, I use runhaskell for some scripts.
09:01:59 <dancor> jmcarthur_work: doesn't it?
09:02:20 <fasta> abuiles, that version has broken type-families.
09:02:24 <Saizan> dancor: you mean ghci?
09:02:34 <jmcarthur_work> dancor, in any other shell, if i assign a variable i expect it to remain around until i exit the shell. besides that, i see no other reason a haskell shell would keep anything around unnecessarily
09:02:39 <fasta> abuiles, later versions might also be broken.
09:02:40 <dancor> jmcarthur_work: i mean, in a shell context you might request anything at any point in the future
09:02:49 <dancor> jmcarthur_work: but in non-haskell langs you can clear things
09:02:56 <fasta> abuiles, basically type-families only exist on paper.
09:02:57 <jmcarthur_work> oh, i see
09:03:02 <mmorrow> dancor: i've heard they even have faster O(1) traveling-salesman implementations using hash tables
09:03:27 <dancor> so it's like should i try to add unsetting to haskell or look for something better for shell lang
09:03:39 <abuiles> fasta: ;(.
09:03:46 <Saizan> s/haskell/ghci/g :)
09:03:52 <dancor> or at least that's how i chose to see the false dichotomy :)
09:03:52 <tensorpudding> how would you implement pipes in haskell?
09:04:41 <dancor> tensorpudding: i would look at HSH first..
09:04:48 <jmcarthur_work> dancor, what about let foo = undefined? it doesn't get rid of the identifier, but at least it drops the value
09:05:01 <mmorrow> by forkIO'ing a threads that feeds Handle==>Handle, where those two Handles are connected to the output and input of two processes respectively
09:05:35 <mmorrow> which you create with System.Process (the processes)
09:06:02 <mmorrow> or you could just dup
09:06:59 <abuiles> fasta: so, if I want to use  associated types that implies type families, right ?
09:08:29 <mmorrow> well, you can't dup if you're working at the Handle-level
09:08:35 <dancor> jmcarthur_work: i suppose that should work in ghci
09:08:41 <fasta> abuiles, I am not an expert on type-families, but I would not recommend to use them.
09:09:12 <fasta> abuiles, there were a lot of open issues in 6.10.4 at least. Probably lots of those have been fixed.
09:09:15 <dancor> jmcarthur_work: it's funny, it looks (using pmap) like things aren't deallocated that way tho even like a minute later
09:09:26 <dancor> but anyway it seems like they could be in theory
09:11:40 <abuiles> fasta, thanks.
09:11:58 <dancor> does anyone happen to know if ghci permanently-in-the-process leaks memory if you do like:  let a = [1..1000000]; print (last a); let a = undefined
09:15:10 <Saizan> dancor: even if ghci deallocates that a, it won't return the memory to the OS
09:16:43 <jli> I understand turning profiling on in the RTS affects performance (and I suppose compiling with -prof would at least make executables bigger), but does installing profiling libraries through cabal (with -p) have any negative effects, aside from disk usage and slightly longer "cabal install" times?
09:17:19 <Saizan> jli: no
09:17:24 <zygoloid> dancor: don't know for sure, but it certainly looks like it leaks it.
09:17:38 <jli> Saizan: great, thanks.
09:17:41 <dcoutts> jli: it just makes the profiling versions available, you only get the slowdown if you use the profiling libs.
09:18:08 <zygoloid> dancor: i've tried repeatedly doing: ghci> let a = [1..]  ghci> a!!1000000   and memory usage keeps going up
09:18:15 <Saizan> zygoloid, dancor: http://hackage.haskell.org/trac/ghc/ticket/698
09:18:33 <Saizan> zygoloid: ah, that's another thing again :)
09:18:56 <Saizan> s/another thing again/yet another thing/
09:19:41 <Axman6> jli: you'll notice that if you tell cabal-install to build profiling libs, it'll build both .o and .p_o binary files
09:20:41 <jmcarthur_work> i won't give it back to the OS, but afaik it should GC it if it needs more memory
09:21:03 <jmcarthur_work> zygoloid, oh, interesting
09:21:57 <Saizan> the problem is if it's smart enough (not dumb?) to see the old a can be GC'ed
09:22:30 <Saizan> it's not something to do with haskell being functional
09:23:28 <aavogt> but how is it supposed to know if you have not typed the rest of the code yet?
09:23:47 <aavogt> or is it supposed to reevaluate the expression?
09:23:52 <Saizan> the old a is no more in scope.
09:24:26 <aavogt> oh, shadowing
09:28:18 <MHD> putStrLn "Hello Werld!"
09:29:48 <Twey> error "Evil English Error Encountered"
09:30:12 <MHD> Oh, how bloody awful
09:30:37 <MHD> >putStrLn "Hello, World!"
09:30:52 <ski> > 42
09:30:54 <lambdabot>   42
09:31:15 <MHD> > putStrLn $ "The answer is " ++ show 42
09:31:17 <lambdabot>   <IO ()>
09:31:25 <MHD> lol, wut?
09:31:38 <aavogt> no io with lambdabot
09:31:40 <ski> @help run
09:31:41 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
09:32:28 <ben> > runST (newSTRef 42 >>= readSTRef)
09:32:29 <lambdabot>   42
09:32:31 <ben> :O
09:32:43 <stoop> Uh oh.
09:33:01 <MHD> let g 0 = ""; g n = 'x' : g (n - 1) in g 3
09:33:06 <ben> I think a bunch of ST-to-IO exploits were fixed at some point :3
09:33:13 <MHD> > let g 0 = ""; g n = 'x' : g (n - 1) in g 3
09:33:15 <lambdabot>   "xxx"
09:35:21 <Axman6> > runST (newSTRef 42 >>= \x -> unsafeIOtoST (print 1) >> readSTRef x)
09:35:22 <lambdabot>   Not in scope: `unsafeIOtoST'
09:35:25 <Axman6> :(
09:35:40 <MHD> Hmm... what if Haskell and FORTH had an affair and forgot to use protection?
09:35:46 <zygoloid> > runST . unsafeCoerce $ putStrLn "Hello"
09:35:47 <lambdabot>   Not in scope: `unsafeCoerce'
09:36:00 <Saizan> tsk, be more creative at least!
09:36:29 <MHD> > unsafeHasturHasturHastur
09:36:31 <lambdabot>   Not in scope: `unsafeHasturHasturHastur'
09:36:39 <MHD> samn
09:36:41 <MHD> damn*
09:37:05 <Vulpyne> You can't do IO in lambdabot.
09:37:13 <MHD> I know
09:37:15 <Axman6> MHD: you've been in here a few times in the last few days, and i haven't seen you say anything i wouldn't consider trolling...
09:37:24 <MHD> okay...
09:37:47 <MHD> I actually have a problem with a stack based calculator I am making
09:38:38 <Vulpyne> That's too vague for anyone to help you. :)
09:39:43 <MHD> I have a monad data Try a = Ok a | Err String
09:39:50 <MHD> that most of the script uses
09:40:06 <Vulpyne> That looks like Either.
09:40:22 <MHD> Yeah, yeah, I'm just playing around with monads as of now
09:41:14 <MHD> The main point of my program is to parse a string into a list of (Try Stack -> Try Stack) where type Stack = [Double]
09:41:29 <MHD> and then fold with (.)
09:43:07 <Saizan> not (Stack -> Try Stack) and fold with =<< ?
09:43:36 <MHD> I have concidered doing that, but I like compiling it into a single function
09:43:54 <MHD> Maybe i should just fold with =<< or >>=
09:44:09 <benmachine> or <=<
09:44:10 <Saizan> yeah, that's what i were suggesting
09:44:25 <benmachine> :t (<=<(
09:44:25 <MHD> <=<? Is that Arrows or something?
09:44:26 <benmachine> er
09:44:27 <lambdabot> parse error (possibly incorrect indentation)
09:44:28 <benmachine> :t (<=<)
09:44:30 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
09:44:47 <ski>   (f <=< g) a = f =<< g a
09:45:06 <ski>   (f . g) a = f $ g a
09:45:23 <MHD> okay..?
09:45:27 * benmachine prefers to think of it as f <=< g = \a -> g a >>= f
09:45:42 <ski> so `(<=<)' is monadic composition
09:45:55 <MHD> Okay. That's kinda cool
09:46:15 <ski> (and `(>=>)' is also monadic composition .. but in the other direction)
09:46:39 <MHD> :t (>=>)
09:46:41 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:47:33 <ski>   print <=< mapM processIt =<< computeList  -- e.g.
09:47:57 <MHD> so that would be (f >=> g) a = f a >>= g ?
09:48:04 <ski> yes
09:48:07 <MHD> cool
09:48:35 <ski> (benmachine : any reason you prefer a lambda, there ?)
09:54:29 <Twey> Isn't that just the same as â€˜print =<< mapM processIt =<< computeListâ€™?
09:55:14 <benmachine> ski: I like to use lambdas when something is usually used to make a function
09:55:25 <benmachine> which is an incredibly vague and poorly defined idea
09:55:33 <benmachine> but I like it anyway
09:55:41 <Twey> :t (<=<)
09:55:43 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
09:55:44 <Twey> :t (=<<)
09:55:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:55:59 * Twey scratches his head.
09:56:19 <MHD> :info (=<<)
09:56:34 <MHD> no :info?
09:56:42 <benmachine> no, use ghci
09:56:42 <Twey> @info (=<<)
09:56:43 <lambdabot> (=<<)
09:56:50 <benmachine> I suppose :info is usually too verbose for IRC
09:56:50 <Twey> Not very useful, but there it is ;)
09:56:55 <conal> anyone know how to make GLfloat from a Float?
09:57:04 <Twey> conal: fromRational?
09:57:10 <benmachine> realToFrac?
09:57:55 <conal> i'm updating FieldTrip to work with the latest OpenGL
09:58:06 <MHD> is $ the only operator with 0 precedence?
09:58:15 <conal> great.  i think realToFrac will do it.
09:58:24 <conal> fromRational takes a Rational.
09:58:31 <conal> thanks Twey & benmachine
09:58:56 <benmachine> conal: when I tried to make frag work I found that
09:58:59 <benmachine> usually you can just replace one type with the other
09:59:10 <benmachine> since GLfloat can do pretty much everything Float can
09:59:17 <benmachine> then you avoid overheads
09:59:17 <dancor> this seems relevant: http://www.haskell.org/pipermail/hopengl/2002-April/000156.html
09:59:21 <benmachine> not always possible though
09:59:26 <ski> benmachine : ok. i like to write type signatures like `map :: (a -> b) -> ([a] -> [b])' and still define like `map f (x:xs) = ...'
10:00:06 <ski> (i.e. i think of it abstractly as mapping a function to another function .. but then i go on defining the returned function in terms of what is returned when it is applied)
10:00:31 <MHD> I like to write functions that are supposed to return functions like mkOperator :: String -> Stack -> Try Stack
10:00:35 <benmachine> my way uses fewer parentheses :P
10:00:56 <ski> the extra brackets there was the point
10:01:11 <dancor> MHD: http://www.haskell.org/onlinereport/standard-prelude.html
10:01:20 <dancor> also ($!) and seq
10:01:58 <MHD> dancor: ?
10:02:03 <benmachine> ski: but you need them on the LHS of the definition as well
10:02:10 <benmachine> equation
10:02:10 <ski> MHD : you can defined your own operators with `0' predecence, if you like
10:02:11 <benmachine> thing
10:02:13 <dancor> MHD: those functions have infixr 0
10:02:23 <dancor> if you grep for "infixr 0" on that page
10:02:28 <MHD> dancor; Aah..
10:02:35 <benmachine> Data.Function.on has 0 infix precedence
10:02:36 <dancor> MHD: also, using/demanding/sparking in http://hackage.haskell.org/packages/archive/parallel/1.1.0.1/doc/html/src/Control-Parallel-Strategies.html#using
10:02:38 <benmachine> irritatingly.
10:02:39 <ski> benmachine : you mean `(map f) (x:xs) = ...' ?
10:02:49 <benmachine> ski: no I mean (f <=< g) a
10:03:08 <ski> oh
10:03:24 <benmachine> not that it is actually important!
10:03:26 <ski> (btw, the point i mentioned was the extra brackets in `map :: (a -> b) -> ([a] -> [b])')
10:03:37 <benmachine> yeah I've seen that too
10:03:49 <ski> (in case that wasn't clear)
10:03:51 <benmachine> it is sometimes nice but I don't do it personally
10:03:57 <dancor> `on` is interesting bc it's actually infixl 0
10:04:15 <benmachine> dancor: which means it can't be mixed with $ at all which is why it annoys me
10:04:20 <dancor> heh
10:04:53 <dancor> the fixity system seems like such a practical hack
10:05:05 <dancor> 0 to 9?  really?
10:05:36 <ski> benmachine : .. but i don't find the brackets there irritating
10:05:45 <Vulpyne> If only it was a Double. :)
10:06:00 <MHD> why couldn't the infix system be like... 0 to 100?
10:06:10 <ski> btw, do i remember wrong, or was `(map f) (x:xs) = ...' invalid syntax previously ?
10:06:16 <dancor> there's a trade-off of complexity
10:06:16 <jfoutz> > head $ foldr (\w (a:b:as) -> maybe (read w:a:b:as) (\op -> op a b:as) (lookup w [("+",(+)),("*",(*))])) (repeat 0) $ words "* + 1 2 3"
10:06:18 <lambdabot>   9
10:06:32 <dancor> it's still somewhat reasonable to memorize fixities with only 0..9
10:06:50 <dancor> wish they were listed in hoogle tho
10:06:57 <ski> MHD : why couldn't the infix system have rational precedences ?
10:07:06 <MHD> ski: lol
10:07:28 <dancor> infixrrlir (pi :: CReal)
10:07:37 <ski> (actually, i think i possibly would prefer an abstract (dense) ordering, rather than a concrete one like rationals)
10:08:07 <dancor> {-# LANGUANGE UndecidableFixities #-}
10:08:48 <ski> (for some reason, Prolog has precedences between `0' and `1200')
10:08:53 <benmachine> hah
10:08:58 <MHD> ski: lol
10:09:06 <ski> (and `0' binds tightest !)
10:09:37 <benmachine> how's this for an idea: fixity is directly proportional to length of operator in characters
10:09:47 <benmachine> so . is tight but >>= is loose
10:09:54 <MHD> wat
10:09:56 <ski> @type let (x `foo` y) = () in foo
10:09:58 <benmachine> leaving aside the fact that it is an awful idea
10:09:58 <lambdabot> Parse error in pattern
10:10:00 <ski> bah!
10:10:01 <benmachine> it's a pretty good idea
10:10:12 <dancor> low-complexity
10:10:15 <dancor> nothing-to-memorize
10:10:16 <benmachine> yes
10:10:26 <dancor> alright!  let's fork haskell
10:10:26 <benmachine> those are the benefits
10:10:33 <benmachine> the drawback is that you get $$$$$$$$
10:10:39 <ski> or we could go the OCaml way, and deciding fixity and precedence from the first character of the operator
10:10:41 <MHD>  hahahaha
10:11:06 <benmachine> well, we already decide whether it's a function or constructor from the first character
10:11:24 <Rotaerk_> operators would start to look like censored swearing
10:11:49 <Vulpyne> Perl flashbacks.
10:12:49 <jfoutz> $@_[$&]
10:12:54 <ski> does `ß' count as upper case ?
10:14:03 <jfoutz> > isUpper '?'
10:14:04 <lambdabot>   False
10:14:05 <ski> > (isLower &&& isUpper) 'ß'
10:14:07 <lambdabot>   (False,False)
10:14:22 <jfoutz> hmm. scary.
10:14:28 <dancor> :t toUpperCase
10:14:29 <lambdabot> Not in scope: `toUpperCase'
10:14:39 <jfoutz> :t toUpper
10:14:39 <ski> @type toUpper
10:14:39 <stoop> > isUpper '0'
10:14:40 <lambdabot> Char -> Char
10:14:40 <lambdabot>   False
10:14:41 <MHD> > isUpper 'æ'
10:14:41 <lambdabot> Char -> Char
10:14:41 <dancor> :t Data.Char.Properties.Case.toUpperCase
10:14:42 <lambdabot>   False
10:14:43 <lambdabot> Couldn't find qualified module.
10:14:51 <stoop> How is uppercase defined?
10:14:54 <stoop> @src isUpper
10:14:54 <lambdabot> Source not found. :(
10:15:16 <benmachine> it's defined in a unicodey way
10:15:19 <dancor> it's defined by the unicode standard
10:15:50 <MHD> MHD :: Computer -> Dinner -> Computer
10:15:52 <dancor> please hold while unicode-properties slowly compiles
10:15:58 <MHD> MHD = 30 min
10:16:38 <blueonyx> @src (\\)
10:16:39 <lambdabot> (\\) = foldl (flip delete)
10:17:22 <dancor> ski: it's lower case: http://www.fileformat.info/info/unicode/char/00df/index.htm
10:17:47 <dancor> also, unicode-properties has been stuck at [3 of 17] for minutes
10:17:54 <dancor> must use TH ;)
10:24:09 <zygoloid> > ord 'ï¿½'
10:24:10 <lambdabot>   65533
10:25:08 <zygoloid> looks like U+FFFD to me?
10:27:18 <allbery_b> FFFD is the substitution character, I believe
10:27:30 <allbery_b> can be displayed for any character missing fromt he font
10:31:24 <zygoloid> > (isLower &&& isUpper) 'ÃŸ'
10:31:26 <lambdabot>   (True,False)
10:32:41 <Zao> > (isLower &&& isUpper) 'áºž'
10:32:42 <lambdabot>   (False,True)
10:32:55 <zygoloid> > ord 'áºž'
10:32:56 <lambdabot>   7838
10:33:06 <zygoloid> > toUpper 'ÃŸ'
10:33:08 <lambdabot>   '\223'
10:33:14 <Zao> 'U+1E9E LATIN CAPITAL LETTER SHARP S'
10:33:26 <zygoloid> , text $ map toUpper "ÃŸ"
10:33:27 <lunabot>  
10:33:50 <zygoloid> oh right, lunabot's output encoding isn't utf-8 :(
10:34:18 <ben> There are other encodings?
10:35:01 <copumpkin> Data.Text does toUpper 'ÃŸ' correctly I think
10:35:06 <zygoloid> , text $ map toUpper "'ÃŸ'"
10:35:07 <lunabot>  'ß§
10:35:13 <copumpkin> I vaguely remember bos talking about that
10:35:33 <zygoloid> hmm, maybe it's the input encoding that's wrong
10:35:52 <bos> what what?
10:35:52 * hackagebot upload: pisigma 0.1.0.3 - dependently typed core language (AndresLoeh)
10:35:53 <bos> oh, right. yes.
10:36:05 <zygoloid> , text $ map toUpper $ "'\195\159'"
10:36:06 <lunabot>  'ÃŸ'
10:36:08 <bos> basically, "map toUpper" gives wrong answers with unicode.
10:36:27 <ben> Huh
10:36:29 <copumpkin> yeah, cause there isn't necessarily a one-to-one mapping?
10:36:34 <bos> right
10:36:40 <ben> > map toUpper $ "'\195\159'"
10:36:41 <lambdabot>   "'\195\159'"
10:36:57 <zygoloid> , length "\195\159"
10:36:58 <lunabot>  2
10:37:06 <bos> even Data.Text gives wrong answers for some languages where the locale demands different behaviour than the norm, such as the turkic languages
10:37:12 <bos> i need to fix that.
10:37:44 <bos> however, that falls below the line of "fun things to do after the kids are in bed".
10:38:28 <bos> anyone who does i18n in a serious way for fun needs to be kept clear of sharp utensils and easily opened top-floor windows
10:40:27 <netinho2lol> hey guys
10:40:39 <netinho2lol> do you know how can I reverse a scanl?
10:41:03 <ziman> what do you mean, can you give an example?
10:41:08 <netinho2lol> sure
10:41:09 <zygoloid> netinho2lol: you want to get back to the original list? :)
10:41:23 <netinho2lol> nope :P
10:41:30 <netinho2lol> let me try to decrypt this...
10:42:29 <netinho2lol> I have a list of functions that act over a list of strings
10:42:33 <newsham> is galois making slides, audio or video of its talks available yet?
10:43:12 <netinho2lol> and I'm going to make a list of the accumulating stuff, starting with the original list of strings, and its accumulating values
10:43:37 <netinho2lol> basicly, sounds like a scan
10:43:47 <poe> newsham I thought about that too: I wonder what's the point of the blog posts :^)
10:44:39 <netinho2lol> stuff [f1,f2,f3] z = [z, f1 z, f2 . f1 $ z, f3 . f2 . f1 $ z]
10:44:44 <dubhrosa_> can someone tell me the performance characteristics of !!, the list index operator? is it O(n)?
10:45:01 <poe> yes
10:45:03 <netinho2lol> dubhrosa_: it's O(n), me thinks
10:45:25 <netinho2lol> zygoloid: it's basicly that function, which is a scan, me thinks
10:45:27 <zygoloid> dubhrosa_: xs!!n is O(n)
10:45:27 <roconnor> @type scanl
10:45:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:45:29 <Saizan> it's O(n), and it's optimal
10:46:02 <zygoloid> netinho2lol: ok, what's the problem?
10:46:02 <roconnor> > scanl (flip ($)) z [f,g,h]
10:46:03 <lambdabot>   Ambiguous occurrence `g'
10:46:04 <lambdabot>  It could refer to either `L.g', defined at <local...
10:46:08 <roconnor> @undef
10:46:11 <roconnor> > scanl (flip ($)) z [f,g,h]
10:46:12 <lambdabot>   [z,f z,g (f z),h (g (f z))]
10:46:20 <netinho2lol> FUUK
10:46:22 <netinho2lol> >_<
10:46:27 <netinho2lol> I knew it
10:46:28 <netinho2lol> FU
10:46:34 <dubhrosa_> thanks; so if one needs O(1) array access one should use STUArray?
10:46:38 <netinho2lol> I did the same thing
10:46:44 <netinho2lol> but without the flip!!!
10:46:49 <zygoloid> dubhrosa_: one should use an Array of some form.
10:46:50 <netinho2lol> what is this flip thing?
10:46:59 <roconnor> @src flip
10:46:59 <netinho2lol> :t flip
10:46:59 <lambdabot> flip f x y = f y x
10:47:01 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
10:47:11 <poe> > scanl (flip ($)) 0 [(+1),(+2),(+1),(+2)]
10:47:12 <lambdabot>   [0,1,3,4,6]
10:47:19 <netinho2lol> it flips the arguments
10:47:22 <netinho2lol> of course!
10:47:26 <Saizan> dubhrosa_: Data.Sequence provides fast indexing too
10:47:35 <poe> that is higher order *programming* :)
10:47:45 <netinho2lol> that's why I wanted to reverse the scan
10:47:48 <netinho2lol> >.<
10:47:51 <netinho2lol> gd damn it
10:47:56 <zygoloid> dubhrosa_: yeah, as Saizan points out, logarithmic array access is usually fast enough :)
10:48:09 <dubhrosa_> sorry, I should have specified that I'm building the list in a fold as I go along...
10:48:29 <roconnor> having Expr in lambdabot is really helpful
10:48:47 <poe> who's the author?
10:48:48 <dubhrosa_> e.g.: L.foldl' (\ soln weight -> (L.minimum  (map (\ (cv,cw) -> if cw > weight then maxint else cv+soln!!(cw-1) ) coins)): soln) [0] [1..w]
10:48:55 <roconnor> not sure
10:49:10 <roconnor> there were a couple implementations that came out at around the same time.
10:49:30 <zygoloid> @hackage simple-reflect
10:49:31 <lambdabot> http://hackage.haskell.org/package/simple-reflect
10:49:47 <netinho2lol> logarithmic stuff is always crazy
10:49:48 <zygoloid> ^^ i believe that's what \b uses
10:49:49 <dubhrosa_> so I guess it has to be mutable, which makes me think STUArray is appropriate, but I'm new to this so any suggestions appreciated
10:49:58 <mmorrow> , (text . utf8enc) "ÃŸ"
10:49:59 <lunabot>  ÃŸ
10:50:49 <mmorrow> lunabot doesn't do any encoding to the output, assuming the ircgrammer will do it if desired
10:51:16 <zygoloid> dubhrosa_: if you can build the whole list (or at least the whole list spine) before you need lookups, then you can use an immutable array
10:52:00 <roconnor> > scanl (.) id [f,g,h] z
10:52:01 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
10:52:01 <lambdabot>         against infe...
10:52:07 <roconnor> > scanl (.) id [f,g,h]
10:52:08 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:52:08 <lambdabot>    `Test.SmallCheck.Serial ...
10:52:22 <roconnor> @type scanl
10:52:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:52:26 <zygoloid> mmorrow: it must do /some/ encoding to convert a Char to a sequence of bytes over the wire...
10:52:38 <mmorrow> , utf8enc "ÃŸ"
10:52:39 <lunabot>  "\195\159"
10:52:42 <roconnor> > sequence (scanl (.) id [f,g,h]) z
10:52:43 <mmorrow> , "ÃŸ"
10:52:44 <lunabot>  "\223"
10:52:47 <lambdabot>   [z,f z,f (g z),f (g (h z))]
10:53:02 <mmorrow> zygoloid: it output the raw bytes the expression results in
10:53:07 <mmorrow> *outputs
10:53:08 <roconnor> hmm, goes the wrong way
10:53:17 <roconnor> > sequence (scanl (flip (.)) id [f,g,h]) z
10:53:19 <lambdabot>   [z,f z,g (f z),h (g (f z))]
10:53:27 <zygoloid> mmorrow: what does 'text' consider the 'raw bytes' of '\1234' to be?
10:53:37 <roconnor> bah
10:53:48 <mmorrow> probably a chopped 255?
10:53:50 <zygoloid> mmorrow: it sounds like your encoding is iso-8859-1
10:54:06 <dubhrosa_> zygoloid: how do you build the list spine without actually building the list?
10:54:16 <bos> i wonder if ghc could easily issue better error messages for code that gets function arity wrong.
10:54:20 <mmorrow> zygoloid: it's whatever the Text.PrettyPrint does with chars > 255, since it does nothing to the output
10:54:32 <bos> e.g. supplying 3 arguments to a function of 2.
10:54:42 <mmorrow> , utf8enc "ÃŸ"
10:54:43 <lunabot>  "\195\159"
10:54:44 <poe> roconnor needs an Expr for . :)
10:54:50 <mmorrow> > text "\195\159"
10:54:51 <lambdabot>   Ãƒ
10:54:52 <zygoloid> dubhrosa_: the distinction i was trying to make is, you need to be able to specify what the elements of the list should be, but you don't need to compute those values yet
10:55:10 <roconnor> > flip f
10:55:12 <lambdabot>   Ambiguous type variable `c' in the constraints:
10:55:12 <lambdabot>    `SimpleReflect.FromExpr ...
10:55:25 <roconnor> > f x y
10:55:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:55:26 <lambdabot>    `GHC.Show.Show a'
10:55:26 <lambdabot>      a...
10:55:27 <mmorrow> , (render . text) "ÃŸ"
10:55:28 <lunabot>  "\223"
10:55:31 <Badger> > text "\223"
10:55:33 <lambdabot>   ÃŸ
10:55:34 <roconnor> > f
10:55:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:55:35 <lambdabot>    `SimpleReflect.FromExpr ...
10:55:41 <mmorrow> , "ÃŸ"
10:55:42 <lunabot>  "\223"
10:55:58 <mmorrow> lambdabot implicitly utf8-encodes all raw bytes
10:56:00 <benmachine> > expr f
10:56:02 <lambdabot>   f
10:56:08 <zygoloid> , text "\223"
10:56:09 <lunabot>  
10:56:13 <zygoloid> > text "\223"
10:56:15 <lambdabot>   ÃŸ
10:56:18 <copumpkin> shapr hasn't boinged recently
10:56:23 <zygoloid> lambdabot: 1, lunabot: 0
10:56:55 <mmorrow> :o
10:57:12 <mmorrow> lunabot is teh one mangling bites!
10:57:51 <zygoloid> *shrug* it's not like IRC defines a character encoding anyway
10:58:41 <dubhrosa_> zygoloid: ah, ok, in my case the nth element can depend on any of the previous (n-1 or lower) elements, so I guess I could formulate the entire computation as the construction of the immutable array...is that what you mean?
10:58:43 <dancor> irc <-> unix <-> utf8
10:58:46 <dancor> come on
10:59:07 <dancor> irc is where hackers go to speak when they don't want to be overheard
10:59:20 <elly> haha
10:59:21 <mmorrow> hah
10:59:32 <copumpkin> omgwtfhax
10:59:32 <mmorrow> s/lunabot/lambdabot/ is teh one mangling bites!
10:59:49 <mmorrow> excalamatory fail
11:00:02 <netinho2lol> the new ghc is going to support unicode 8, right?
11:00:22 <mmorrow> gah
11:00:35 <roconnor> netinho2lol: you mean unicode IO?
11:00:41 <netinho2lol> yeah
11:00:48 <netinho2lol> I read that somewhere
11:04:04 <zygoloid> , length "ÃŸ"
11:04:05 <lunabot>  1
11:04:19 <zygoloid> mmorrow: at least lambdabot's "mangling" is symmetric
11:04:48 <roconnor> > f x
11:04:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:04:50 <lambdabot>    `GHC.Show.Show a'
11:04:50 <lambdabot>      a...
11:04:51 <zygoloid> mmorrow: lunabot decodes utf-8 on input, but encodes 8859-1 on output!
11:08:27 <thunderbolt> What strategies do you guys use when you're refactoring haskell code?
11:08:54 <poe> > f x :: Expr
11:08:55 <lambdabot>   f x
11:10:33 <mmorrow> zygoloid: it's ghc that decodes it on input, and your client that encodes it
11:10:36 <Botje> thunderbolt: the delete key :)
11:11:05 <Botje> thunderbolt: look for explicit lambda's, feed them through @pl, use them if they come out prettier.
11:11:27 <Botje> look for explicit recursion, see if it can be refactored using higher order functions
11:11:30 <mmorrow> zygoloid: actually, i can't remember now
11:11:32 * mmorrow checks
11:11:49 <thunderbolt> Botje: Thanks. Those help. Any strategies specific to removing code duplication?
11:12:00 <poe> let dot = fun "." :: Expr -> Expr -> Expr in scanl dot (fun "id") [f,g,h] :: [Expr] -- roconnor :D
11:12:03 <Botje> don't do it in the first place!
11:12:07 <poe> > let dot = fun "." :: Expr -> Expr -> Expr in scanl dot (fun "id") [f,g,h] :: [Expr]
11:12:09 <lambdabot>   [id,. id f,. (. id f) g,. (. (. id f) g) h]
11:12:22 <poe> (not *too* good looking but we're getting there)
11:12:33 <Botje> either abstract the common parts to a function, or implement the different parts in lambdas, extract those and abstract common parts
11:13:21 * thunderbolt nods
11:13:37 <jimmyjazz14> Anyone notice that GHC is really buggy on FreeBSD
11:13:44 <jimmyjazz14> or is that just me
11:14:43 <mmorrow> zygoloid: ok, so the bot program briefly utf8decodes, just to filter control chars, then re-utf8encodes, and the eval program utf8-decodes the input, but leaves it up to the code it runs to handle any output encoding it might want
11:15:19 <brh_> hi,  what does No instance for (MonadRandom []) arising from a use of `arrange'
11:15:24 <brh_> mean?
11:16:31 <Botje> in what code?
11:16:49 <poe> roconnor locally it does the right thing with  let dot = op Infix 1 " . "  and then  scanl dot (fun "id") [f,g,h] :: [Expr]  gives  [id,id . f,(id . f) . g,((id . f) . g) . h]    :)
11:17:18 <brh_> arrange :: (MonadRandom m) => [a] -> m [(a, a)]
11:17:18 <mmorrow> zygoloid: (so the bot assumes the output is already in utf8, but it doesn't do it /for/ you)
11:17:19 <brh_> arrange pl = liftM2 zip (return pl) (grabbleOnce pl $ length pl)
11:23:00 <Berengal> Random musing: Why select when you can forkIO?
11:24:58 <Rotaerk_> select?
11:25:19 <blueonyx> :t select
11:25:21 <lambdabot> Not in scope: `select'
11:27:31 <Berengal> As in non-blocking IO
11:27:55 <mmorrow> int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
11:28:05 <mmorrow> (man select)
11:28:38 <benmachine> Berengal: you don't?
11:28:44 <copumpkin> world's ugliest API
11:28:56 <benmachine> 'tis not
11:29:03 <Berengal> benmachine: Don't what? Select?
11:29:07 <benmachine> it's a little ugly but you are asking it to do quite a lot which it does quite well
11:29:11 <benmachine> Berengal: yes
11:29:15 <mmorrow> wow, the select manpage is pretty useful
11:29:19 <copumpkin> yeah, it's decent at it
11:29:28 <Berengal> benmachine: Nope. Never used it for realz
11:29:33 <copumpkin> but all the bit-based stuff and macros
11:29:38 <copumpkin> is just ugly :P
11:29:57 <benmachine> bit-based stuff?
11:30:13 <copumpkin> the parameters to it are a big bitfield
11:30:21 <benmachine> well you don't need to know that
11:31:01 <copumpkin> the +1 on nfds is also ugly
11:31:11 <copumpkin> (and the maximum number of fds)
11:31:46 <mmorrow> heh, yeah that bothers me
11:32:03 <benmachine> that is what you get for using C.
11:32:10 <copumpkin> I mean, there's no reason they couldn't stick the +1 on their side
11:32:39 <copumpkin> benmachine: APIs can get a lot better than that, even in c
11:32:57 <nando> hey
11:33:17 <copumpkin> hey is for horses
11:33:20 <benmachine> well if they did the +1 you wouldn't be able to listen for activity on no file descriptors?
11:33:21 <mmorrow> it's like if you had to do (!!(i+1)) for i, just because whoever wrote (!!) was on crack at the time
11:33:26 <benmachine> well you would
11:34:03 <nando> i would say "Hello World" but someone migth shoot at me
11:36:28 <nando> i was wondering if someone could (or would) help me
11:36:54 <netinho2lol> sup nando
11:37:09 <nando> i started haskell only 1 month ago so i'm pretty new to this
11:37:20 <netinho2lol> putString "Hello World"
11:37:34 <copumpkin> nando: we won't know until you ask your question :)
11:37:34 <benmachine> putStrLn
11:37:36 <nando> and we haven't gone over the IO class
11:37:48 <nando> i'm getting to it :p
11:38:39 <nando> we're doing a class project and we are supose to build a touring machine
11:38:48 <nando> i've done that and it works
11:38:59 <copumpkin> turing ;)
11:39:02 <nando> the problem is that is suposed to show every step
11:39:05 <copumpkin> unless it's supposed to travel
11:39:12 <nando> turing*
11:39:56 <nando> i can get the comands from the file and manage to put a getLine to ask the user what to duplicate
11:40:15 <nando> the only problem i'm having is duplicating for the second step
11:40:41 <copumpkin> duplicating?
11:41:09 <nando> running the function again with the results from the first step
11:41:17 <nando> inside a "do"
11:41:21 <copumpkin> sounds like a fold
11:41:33 <copumpkin> which conveniently gives you a scan to keep previous results
11:41:47 * copumpkin swoons at higher-order functions
11:41:59 <nando> i do have to print the result of each step
11:42:19 <copumpkin> don't think of it as printing the result
11:42:20 <Berengal> mapM_ print . scanl turing initialState
11:42:23 <copumpkin> think of it as keeping it around
11:42:28 <copumpkin> so you can print it later
11:42:42 <copumpkin> separate your logic from your IO
11:43:09 <nando> i first did the funtions cuz i didn't even knew about IO, now i'm trying to put it together
11:43:31 <nando> but ofcourse it just showed the final state
11:43:35 <copumpkin> did you use a fold?
11:43:38 <Saizan> but you function presumably runs the turing machine until it stops? or just a step at a time?
11:43:46 <nando> like 111 becomes 1110111 in the exemple
11:43:46 <copumpkin> or did you explicitly recurse?
11:44:00 <nando> i did both until the end and step by step
11:44:13 <Saizan> ok, then with the step by step it should be simple
11:44:14 <copumpkin> what's your type for the step-by-step function
11:44:17 <copumpkin> ?
11:45:08 <nando> aux1_passo :: (Int,[Int],Int,[Int]) -> [(Int,Int,Int,Int,Char)] -> (Int,[Int],Int,[Int])
11:45:19 <copumpkin> oh my
11:45:21 <nando> first Int is the state
11:45:38 <copumpkin> luckily it's a -> b -> a
11:45:40 <copumpkin> :t foldl
11:45:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:45:46 <nando> i need to change it to a general type but for now i'm working with Int
11:46:04 <Berengal> At least use a synonym
11:46:21 <Berengal> Or two, as is the case
11:46:43 <Saizan> the list is the tape?
11:46:59 <copumpkin> this sounds like the perfect application for a zipper
11:47:07 <nando> teh tape is [Int],Int,[Int]
11:47:22 <Saizan> [(Int,Int,Int,Int,Char)] <- what's this?
11:47:33 <copumpkin> states?
11:47:39 <copumpkin> seems odd
11:47:41 <Berengal> And what do you know, it _is_ a zipper
11:47:44 <zygoloid> transition table?
11:47:59 <Saizan> ah, it might be the table, right
11:48:00 <nando> [state,leftlist,position, right list]
11:48:24 <Zao> Can one navigate with a zipper in structures that have "tied the knot"?
11:48:24 <zygoloid> nathanic_work: and tehe [(Int,Int,Int,Innt,Char)]?
11:48:26 <nando> i canche the position back and foword form the right and left list
11:48:29 <nando> change
11:48:32 <Zao> Say that you have a cleverly constructed grid or so.
11:48:53 <copumpkin> Berengal: I'll show you a real zipper
11:48:58 <nando> like 111 becomes []1[1,1]
11:49:20 <zygoloid> Zao: if you navigate that way you'll probably get a space leak, and if you update that way it won't affect the other paths to the same element
11:49:36 <nando> than 011 becomes [0]1[1]
11:49:47 <Zao> zygoloid: Time to whip out the intptrs then.
11:49:52 <nando> than [1,0]1[]
11:49:56 <zygoloid> hehe :)
11:50:07 <Saizan> nando: oh, we got that
11:50:08 <Zao> Maybe array if a regular grid.
11:50:19 <nando> i haven't learn arrays :(
11:50:34 <Saizan> nando: but what is the second argument to that function?
11:50:38 <zygoloid> nando: that's a data structure called a list zipper that you're using there
11:51:40 <nando> theh second argument is the comands (inicial state,read,final state, write,direction)
11:51:49 <Zao> nando: My array statement was not aimed at you.
11:51:51 <copumpkin> you want a comonad!
11:52:05 <Berengal> copumpkin: No, he doesn't want a comonad
11:52:12 <copumpkin> yep!
11:52:28 <ystael> @remember Berengal copumpkin: No, he doesn't want a comonad.
11:52:29 <Berengal> Why does everything have to be comonads with you?
11:52:29 <copumpkin> coMONADS are coOL
11:52:29 <lambdabot> It is forever etched in my memory.
11:52:56 <nando> i'm trying to learn the IO on my own but it isn't clickin gin yet
11:53:00 <nando> :/
11:53:17 <nando> clicking*
11:54:48 <osfameron> mmm, gin
11:55:31 <Twey> Haha
11:55:51 <Berengal> nando: Does your function call another function of type (Int, [Int], Int, [Int]) -> (Int, Int, Int, Int, Char) -> (Int, [Int], Int, [Int])?
11:56:27 <Berengal> If not, can you easily refactor out such a function from it?
11:57:19 <Berengal> nando: It may also help if you show us a bit of the code:
11:57:20 <Berengal> @paste
11:57:21 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:57:23 <nando> it calls another to see what comand to apply
11:57:59 <nando> the code is kind of a mess cuz i'm still a noob at it so it long
11:58:08 <nando> but i can send you the file for you to see
11:58:17 <FliPPeh> How do I access pages with basic authentication via Network.HTTP?
11:58:23 <Berengal> Just paste it instead. Much better for all involved
11:58:24 <FliPPeh> Can't find anything
11:59:05 <nando> ok i'll past it in parts
11:59:14 <Berengal> Sure. Start with the function above
11:59:17 <nando> so the step by step funtion is
11:59:32 <Vulpyne> FliPPeh: http://hackage.haskell.org/packages/archive/HTTP/4000.0.8/doc/html/Network-HTTP-Auth.html ?
11:59:40 <nando> aux1_passo :: (Int,[Int],Int,[Int]) -> [(Int,Int,Int,Int,Char)] -> (Int,[Int],Int,[Int])
11:59:42 <FliPPeh> I've been looking at that but..
11:59:47 <nando> aux1_passo (s,x,z,y) l = let (i,r,f,w,m)= localizaestado s z l
11:59:55 <FliPPeh> I have no idea how to use those
11:59:56 <nando>                      in if m == 'A' then (f,x,z,y)
12:00:06 <nando>                                      else if m =='D' then if y==[] then (f,w:x,0,[])
12:00:08 <FliPPeh> I have no idea what "realm" would be
12:00:14 <nando>                                                                    else (f,w:x,head y,tail y)
12:00:19 <FliPPeh> nando
12:00:20 <Berengal> @paste
12:00:21 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:00:21 <FliPPeh> @hpaste
12:00:21 <nando>                                                       else if x==[] then (f,[],0,w:y)
12:00:22 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:00:27 <Berengal> nando: Use the link above
12:00:28 <nando>                                                                     else (f,tail x, head x,w:y)
12:01:49 <Vulpyne> FliPPeh: I'm not sure the realm matters.
12:02:09 <Vulpyne> FliPPeh: But if you do the request without authorization, you should get the realm in the 401 response.
12:02:34 <Vulpyne> FliPPeh:  146     Error: Thread ended with result: Left (EventError "Unknown Content-Type returned: Just \"text/plain\"")
12:02:36 <nando> ok i used the link
12:02:42 <Vulpyne> Oops.
12:02:46 <nando> berengal
12:03:01 <sproingie> argh.  how di i shut up these "Pattern match(es) are overlapped" warnings when I have a wildcard pattern at the end?  I KNOW they're overlapped, that's why it's at the end.
12:03:02 <Vulpyne> FliPPeh: http://en.wikipedia.org/wiki/Basic_access_authentication
12:03:24 <sproingie> this from LambdaHack illustrating it: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5214#a5214
12:03:31 <Vulpyne> Are you using views?
12:03:42 <nando> berengal can i pm you
12:03:50 <sproingie> Vulpyne: nope
12:04:02 <benmachine> sproingie: pattern matches are only overlapped if they are identical
12:04:06 <Berengal> nando: Just a hint: Posting the resulting link in the channel helps us find it easier ;)
12:04:07 <bitstream0101> how can I use Data.FingerTree.traverse' to get the fingertree elements into a flat list? traverse' (:[]) doesn't give me what I want.
12:04:10 <Vulpyne> Hmm, do you have every case already covered in addition to the wildcard one?
12:04:11 <benmachine> so that the last pattern is never matched
12:04:22 <nando> ok ikis
12:04:43 <nando> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5215#a5215
12:04:49 <sproingie> benmachine: so it'll only give me the warning if it proves that it can't ever reach that last one?
12:05:06 <benmachine> that's the idea
12:05:25 <sproingie> oh good.  i can live with that, since i normally have the warning about nonexhaustive patterns on
12:06:26 <nando> Berengaldid you get it?
12:06:44 <Berengal> nando: I'm looking at it now
12:07:41 <nando> i added the text file at the end with the exemple
12:07:43 <nando> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5215#a5216
12:08:35 <nando> don't laught to hard berengal
12:08:59 <Berengal> nando: I'm more worried about crying
12:09:03 <Berengal> nando: naw, just kidding :P
12:09:07 <bitstream0101> said another way, is there a better way / cleaner to gather fingertree elements into a list than a primitive recursive function that repeatedly applies (e.g.) Data.FingerTree.viewl? traverse' looks like it could get me what I want, but I'm not having any luck.
12:09:07 <|Jedai|> bitstream0101: Isn't there an instance of Foldable too, then you can use foldr (:) []
12:09:22 <bitstream0101> |Jedai|: hmm, i didn't look, good idea.
12:09:45 <sproingie> been playing nethack too long, i keep pronouncing (:) as "newt" instead of "cons"
12:09:51 <dankna> haha
12:09:54 <dankna> that's highly amusing
12:09:59 <bitstream0101> sproingie: lol
12:10:25 <roconnor> bitstream0101: careful, a little inefficency bell is ringing in my head
12:10:40 <bitstream0101> roconnor: yeah, mine too ;P
12:11:19 <roconnor> bitstream0101: mostly by |Jedai|'s comments which make me think that you want to forget about lists an head directly to foldMap and its friends.
12:11:42 <bitstream0101> roconnor: this is in the context of ensuring that multiple fingertrees have the same contents; I will probably just end up using the Eq instance but was hoping for a quick-and-dirty way to inspect contents
12:11:51 <|Jedai|> roconnor: Well I don't think it's a question of implementation, rather than converting to a list then doing things with it is probably not very efficient anyway
12:12:31 <|Jedai|> bitstream0101: Why would you _not_ use the Eq instance in this case ?
12:13:11 <bitstream0101> |Jedai|: I will -- I just want to visually inspect particular elements first (although the Show instance probably gives me what I need as well
12:13:27 <jmcarthur> if there is an instance of foldable you should be able to just use toList
12:13:44 <jmcarthur> :t Data.Foldable.toList
12:13:46 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
12:14:24 <bitstream0101> jmcarthur/|Jedai|: Yup, realizing there was a Foldable instance was good enough for me. I was getting frustrated trying to do what I wanted with Data.FingerTree.traverse', that's all.
12:19:47 <netinho2lol> guys, I'm so cold
12:19:57 <netinho2lol> can Haskell heat my room?
12:20:10 <dancor> Yes!  Haskell can imbue that.
12:20:21 <|Jedai|> @faq Can Haskell heat thy room ?
12:20:22 <lambdabot> The answer is: Yes! Haskell can do that.
12:22:23 <nando> i think Berengal died and my haskell code is responsible for that hahahah
12:23:57 <Berengal> nando: It's just a bit too hard for me to read non-english code at this late hour, sorry ...
12:24:17 <nando> lol no i'm sorry it's kinda a mess
12:24:56 <Berengal> nando: What you want to do, however, is make a function with a signature something like MachineState -> Input -> MachineState, because then you can easily transform it into a function MachineState -> [Input] -> MachineState
12:25:12 <Berengal> nando: Which calls the single state transformation function several times
12:25:51 <Berengal> nando: Which again can be changed easily to a function of type MachineState -> [Input] -> [MachineState], which does the same, but stuffs all the old states in a list.
12:26:06 <Berengal> nando: To print all the single steps, you just have to print the list
12:26:28 <nando> oh i make a list an dprint it only at the end
12:26:42 <Berengal> That's the general idea
12:26:57 <jmcarthur> i hate this. i have a type that according to quickcheck fails to satisfy a TCM, but only for certain (function) parameters, and i don't know how to go about discovering what the function it fails on actually is
12:27:04 <nando> i wa sthinking on printing one by one but that makes it simpler
12:27:22 <nando> i think i can do that now
12:27:36 <nando> trial and error \o/
12:27:42 <jmcarthur> :(
12:29:19 <Berengal> jmcarthur: Can you get a hold of the function, then throw a bunch of parameters at it?
12:29:24 <nando> thx Berengal i'm going to approache it that way
12:29:48 <jmcarthur> Berengal: how do i retain the function from quickcheck?
12:30:01 <Berengal> jmcarthur: Dunno... hacking the library somehow, I suspect
12:30:05 <jmcarthur> eek
12:30:34 <jmcarthur> i've been thinking it would be nice to tweak or combine quickcheck/smallcheck a bit for a few features i really wish they had
12:30:41 <Berengal> I'm no quickcheck wizard. I suspect others might have more to say on the topic
12:32:06 <jmcarthur> hmm, looks like i could get the seed for generating the parameters, maybe
12:32:20 <jmcarthur> then maybe i can regenerate them using the Gen monad
12:32:49 <Berengal> That's one way to go about it (yay for psedo-randomness in testing)
12:32:59 <copumpkin> do "casts" to and from Any cost anything?
12:33:23 <jmcarthur> @hoogle Any
12:33:24 <lambdabot> Data.Monoid newtype Any
12:33:24 <lambdabot> Data.Monoid Any :: Bool -> Any
12:33:24 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
12:33:31 <copumpkin> not that Any
12:33:34 <jmcarthur> yeah
12:33:35 <copumpkin> GHC.Any
12:33:45 <jmcarthur> i think casts are supposed to be basically free
12:35:36 <jmcarthur> dang, quickcheck does, but checkers doesn't have a way to give me the seed
12:37:16 <jaspervdj> any standard way too recursively copy a directory?
12:44:42 <netinho2lol> I'm cutting a list via 2 indexes, so I'm using two takes?
12:44:49 <djahandarie> Can Haskell get me laid?
12:44:56 <netinho2lol> djahandarie: probably
12:44:58 <medfly> yes it can
12:45:04 <netinho2lol> :t take
12:45:06 <lambdabot> forall a. Int -> [a] -> [a]
12:45:13 <netinho2lol> looks like it
12:47:37 * hackagebot upload: eprocess 1.1.1 - *Very* basic Erlang-like process support for Haskell (FernandoBenavides)
12:53:02 <netinho2lol> crap
12:53:06 <netinho2lol> it's drop, then take
12:53:21 * sm likes http://hackage.haskell.org/packages/archive/recent.html
12:55:44 <sm> but could anyone explain this bizarre thing Jinjing is up to now ? http://hackage.haskell.org/package/snow-white-2009.12.1
12:55:45 <arjanb> it could better list the uploaded packages for a whole week, now i need to check it almost daily just not miss interesting new packages
12:55:47 <Heffalump> use the rss feed
12:55:49 <sm> true enough
12:56:24 <sm> I take it back, a short list is fine here
12:56:32 <netinho2lol> how do I define a function with lambdabot?
12:56:35 <netinho2lol> let?
12:56:41 * hackagebot upload: hpage 0.4.8 - A scrapbook for Haskell developers (FernandoBenavides)
12:56:42 <mercury^> with an at
12:56:45 <Vulpyne> With @let
12:57:01 <mauke> netinho2lol: what's the point?
12:57:36 <netinho2lol> i don't have access to ghci right now
12:58:54 <netinho2lol> @ let cutlist x y l = take (y-x) . drop x l
12:58:57 <jmcarthur> doh! i'm a dummy. i can just use the parameters for join instead of for (>>=), then i don't have to deal with that pesky function parameter
12:59:02 <netinho2lol> @let cutlist x y l = take (y-x) . drop x l
12:59:04 <lambdabot>  Defined.
12:59:07 <mauke> :t cutlist
12:59:09 <lambdabot> forall a. Int -> Int -> [[a]] -> [[a]]
12:59:37 * mauke grins appropriately
12:59:38 <netinho2lol> [[a]]?
12:59:44 <netinho2lol> @let cutlist x y l = take (y-x) $ drop x l
12:59:46 <lambdabot>  <local>:1:0:
12:59:46 <lambdabot>      Warning: Pattern match(es) are overlapped
12:59:46 <lambdabot>               In...
13:00:53 * sm gives hpage a try
13:14:57 <aeron> hey! i know it's not thanksgiving anymore, but i am thankful for you guys :P
13:15:05 <EvanCarroll> how cute.
13:15:07 <aeron> now I do have a question though
13:15:23 <copumpkin> cupboard love!
13:15:33 <aeron> Existential types.. I know of several cases I've needed them, but are they bad form at all to use?
13:15:48 <aeron> I mean it seems to map pretty seamlessly to interfaces in C#, so doesn't seem problematic
13:16:00 <aeron> but I'm just curious if you shoudl really work to avoid them, etc
13:16:02 <copumpkin> I'd avoid them if possible but there are some cases where they are indeed useful
13:16:26 <copumpkin> I'd avoid mapping code directly from another language to a construct in a new language that can simulate it
13:16:31 <netinho2lol> :t mappend
13:16:33 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:16:36 <netinho2lol> :t ++
13:16:37 <monochrom> I use my mood to decide when to use them.
13:16:38 <lambdabot> parse error on input `++'
13:16:42 <netinho2lol> :t (++)
13:16:44 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:16:49 <copumpkin> netinho2lol: the ++ signature here isn't standard
13:16:56 <copumpkin> it's normally [a] -> [a] -> [a]
13:16:58 <aeron> copumpkin: I guess I meant, the concept is proven and I understand it thoroughly for that context
13:17:01 <aeron> but noted :)
13:17:07 <netinho2lol> copumpkin: hlint is saying to replace my ++ with mappend
13:17:10 <netinho2lol> why?
13:17:18 <copumpkin> aeron: but yeah, it definitely isn't bad, but it can sometimes lead to strange non-idiomatic code :)
13:17:28 <copumpkin> netinho2lol: you don't have to listen to hlint
13:17:36 <copumpkin> netinho2lol: it's just trying to generalize your code a bit more
13:17:36 <aeron> The case I saw them used that influenced me was in the "Write yourself a scheme in 48 hours", regarding equality testing
13:17:40 <copumpkin> but it might be useless in this case
13:17:43 <aeron> Using things that implement show
13:18:23 <netinho2lol> @let supercut a b = drop (pred a) . take b
13:18:25 <lambdabot>  Defined.
13:18:25 <mauke> aeron: it's a bit useless for show because you could just store strings
13:18:28 <netinho2lol> :t supercut
13:18:30 <lambdabot> forall a. Int -> Int -> [a] -> [a]
13:18:54 <netinho2lol> > supercut 2 6 ([1..100]::[Int])
13:18:56 <lambdabot>   [2,3,4,5,6]
13:19:17 <netinho2lol> fu fu fu
13:19:31 <netinho2lol> > supercut 0 0 ([1..100]::[Int])
13:19:32 <lambdabot>   []
13:19:35 <netinho2lol> > supercut 0 1 ([1..100]::[Int])
13:19:37 <lambdabot>   [1]
13:19:40 <aeron> mauke: what do you mean? are you familiar with the example I'm talking about? The cheat way to test for structural equality was to check if they're both the same string representation, but they're stored as other types
13:19:49 <netinho2lol> > supercut 0 2 ([1..100]::[Int])
13:19:51 <lambdabot>   [1,2]
13:19:52 <mauke> oh, that
13:20:04 <mauke> I thought you meant an existential that just wraps Show
13:21:38 <copumpkin> is there such a thing as an initial coalgebra or a final algebra?
13:22:54 <FunctorSalad> copumpkin: I think the final algebra would be the trivial algebra
13:23:01 <FunctorSalad> (one element)
13:23:04 <FunctorSalad> maybe I'm missing sth
13:23:16 <FunctorSalad> (for any functor, that is)
13:23:17 <Baughn> > (+2*3) 4
13:23:18 <lambdabot>   10
13:23:34 <Baughn> > (*2+3) 4
13:23:35 <lambdabot>   The operator `GHC.Num.*' [infixl 7] of a section
13:23:35 <lambdabot>      must have lower prece...
13:32:41 <aavogt> has anybody tried importing ghc functions into hugs via ffi?
13:33:13 <aeron> mauke: would you mind checking out this page: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_2 - the heading "Equal? and Weak Typing: Hetergenous Lists"
13:33:22 <aavogt> foreign export just requires that the ghc-rts (and compiled code) from ghc exist, right?
13:33:31 <aeron> I'm trying to wrap my head around an alternative means to that end
13:34:05 <aavogt> I mean, it is possible, but has it been automated such that the type signatures are preserved (if possible of course)
13:34:53 <aavogt> my idea is to use hugs haskell as the configuration language, while ghc haskell can do the heavy stuff, ex. reasonable xmonad and yi configurability without the ghc dep
13:35:02 <aavogt> (more of a concern with xmonad)
13:35:30 <Twey> But why?  :Ã¾
13:37:23 <sm> well hpage installed beautifully on leopard.. that's quite something
13:37:32 <aavogt> Twey: because hugs is 5M, and ghc is 500M
13:37:43 <aavogt> has it been done before?
13:37:44 <sm> and runs, but clicking interpret gives a bus error
13:38:21 <Twey> aavogt: Oh :Ã¾
13:38:59 <aavogt> yes
13:39:50 <aavogt> and the user configuration doesn't use any extensions not present in hugs afaict, while the implementations need those extensions
13:40:12 <FunctorSalad> hmm
13:40:46 <aavogt> or if the interfaces are not hugs-compatible, I will find out
13:42:42 <aavogt> this is my alternative to 1) fixing hugs, 2) removing the use of extensions in those libraries, 3) telling people to suck up the ghc dependency
13:43:10 <aavogt> I think there were a couple more ideas around to address that difficulty
13:43:36 <FunctorSalad> is hugs maintained anymore?
13:44:14 <copumpkin> hasn't been updated in 3 years afaik
13:44:40 <aavogt> something like that
13:46:31 <dpratt71> what is an .hsc file?
13:48:00 <FunctorSalad> @hackage hsc2hs
13:48:01 <lambdabot> http://hackage.haskell.org/package/hsc2hs
13:48:04 <FunctorSalad> @dpratt71
13:48:05 <lambdabot> Unknown command, try @list
13:48:35 <dpratt71> FunctorSalad: thanks
13:52:23 <copumpkin> if a fold is a catamorphism, what is a scan? it's very closely related
13:52:30 <gwern> aavogt: tell people to suck it up. it's not like every other haskell library doesn't depend on ghc and your dep is unusual
13:52:44 <FunctorSalad> @ty scan
13:52:45 <lambdabot> Not in scope: `scan'
13:52:48 <FunctorSalad> @ty scanl
13:52:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
13:52:51 <FunctorSalad> @ty scanr
13:52:53 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
13:53:44 <FunctorSalad> maybe there's some simple way to cut the 500M down?
13:53:47 <FunctorSalad> sounds like a lot
13:53:57 <copumpkin> dynamic linkage
13:54:00 <FunctorSalad> (now that ghc is getting out of the libraries business :))
14:02:33 <jberryman> would a list in weak head normal form look like:  (? : ?)
14:02:53 <Heffalump> if non-empty, yes
14:03:05 <Heffalump> being in WHNF means it's either that or []
14:03:15 <jberryman> Heffalump: right, thanks.
14:03:27 <jberryman> how does that differ from head normal form?
14:03:37 <Heffalump> of course, the ?s might be evaluated too. There's nothing about WHNF that prevents deeper things being evaluated
14:03:51 <Heffalump> \x -> (\y -> y) 3 is in WHNF but not HNF
14:04:04 <Heffalump> i.e. WHNF never requires evaluation under a lambda
14:04:39 <copumpkin> for data with constructors WHNF = HNF, right?
14:05:08 <Heffalump> copumpkin: for anything of non-function type, I guess.
14:05:26 <Heffalump> so yes
14:05:34 <dancor> WHNF = HNF or any-function-type, right?
14:05:43 <dancor> or is there some constraint on the lambdas
14:05:52 <dancor> to be WHNF
14:05:55 <Heffalump> dancor: there still has to be a lambda at the outside
14:06:07 <Heffalump> (\x y -> x + y) 3 isn't in WHNF
14:06:12 <dancor> ok
14:06:33 <Heffalump> also, I think newtype might provide an exception to my claim about anything of non-function type, given that the constructor has no runtime existence
14:06:55 <Heffalump> and I guess strict data also has some weird effect (that may make the definition a bit meaningless)
14:07:20 <dancor> so (\ x -> (\ y -> x + y)) 3 is not WHNF, but (\ x -> (\ y -> x + y) 3) is WHNF?
14:07:30 <Heffalump> correct
14:07:33 <FunctorSalad> I have some weird performance behaviour here. Changing the "mapM" to "mapM_" here causes roughly a 50x speedup.
14:07:35 <FunctorSalad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13464#a13464
14:07:37 <jberryman> Heffalump: thanks.
14:07:42 <Heffalump> FunctorSalad: that's a well-known effect
14:07:48 <FunctorSalad> (both with the IO monad and the Maybe monad)
14:07:49 <Heffalump> because of stack behaviour
14:08:02 <monochrom> mapM and mapM_ are written differently
14:08:13 <FunctorSalad> Heffalump: hmm I would have expected it to get optimized to the same thing (the contents of the result is never used)
14:08:22 <FunctorSalad> the result is only checked for being null
14:08:24 <Heffalump> that would be nice, but it doesn't
14:08:30 <Heffalump> @src mapM
14:08:30 <lambdabot> mapM f as = sequence (map f as)
14:08:32 <Heffalump> @src mapM_
14:08:32 <lambdabot> mapM_ f as = sequence_ (map f as)
14:08:35 <Heffalump> @src sequence
14:08:35 <lambdabot> sequence []     = return []
14:08:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:08:36 <lambdabot> --OR
14:08:36 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:08:37 <Heffalump> @src sequence_
14:08:37 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:08:46 <aavogt> is that optimization possible?
14:09:48 <Heffalump> I guess inlining and dead-code analysis might find it.
14:09:55 <Heffalump> I certainly wouldn't count on it.
14:10:15 <FunctorSalad> the example I posted is pretty simple :)
14:10:45 <FunctorSalad> lazyness doesn't help us here?
14:11:01 <Heffalump> no, because it still has to build a chain of thunks for the value
14:14:47 <monochrom> You need a monad law to justify the optimization.
14:15:26 <Heffalump> not for a specific monad which you can just inline
14:15:31 <Heffalump> but yes, in general
14:16:14 <monochrom> The optimization also needs to do some analysis over the recursion.
14:17:04 <Heffalump> yes, but that's standard for dead-code analysis in imperative languages
14:17:06 <monochrom> err nevermind.
14:17:49 <FunctorSalad> the monad is specialized to either Maybe or IO, depending on flag
14:17:57 <FunctorSalad> both have the ~50x slowdown
14:19:10 <Heffalump> basically the moral of the story is that you have to use mapM_ by hand.
14:19:41 <watermind> hi guys
14:19:51 <watermind> my haskell mode for xemacs was not working very well
14:19:57 <watermind> so I downloaded the latest one
14:20:10 <watermind> now when I try to load an haskell file I get
14:20:34 <watermind> "invalid read syntax: #"
14:20:38 <watermind> :S
14:20:42 <watermind> anyone been through this?
14:21:13 <sproingie> you can report it as a bug, but you'll probably end up having to fix it and sending a patch
14:21:28 <sproingie> since there's not a lot of xemacs users left
14:22:15 <sproingie> does it say what file/line it's in?
14:22:37 <watermind> sproingie: really? what are you guys using then?
14:22:37 <skorpan`> watermind: i don't think the maintainer of haskell-mode really bothers about xemacs... as sproingie says, xemacs are quite the minority today.
14:22:46 <sproingie> i use gnu emacs
14:22:48 * Heffalump uses xemacs
14:22:51 <sm> turn on debug-on-error and do it again to get a backtrace, try to figure out what it's doing
14:22:53 <skorpan`> Heffalump: minority!
14:22:59 <sproingie> i used to use xemacs exclusively, but gnu emacs pretty much leapfrogged it years ago
14:23:16 <Heffalump> I started using xemacs in 1997 or so and have never switched
14:23:16 <watermind> hmm really
14:23:18 <skorpan`> Baughn: are you online?
14:23:23 <Heffalump> I'm completely clueless on the relative merits though
14:23:34 <sm> watermind: yeah really :)
14:23:34 <Heffalump> or any kind of advanced use
14:23:36 <watermind> I moved to xemacs ages ago mostly because of x-symbol
14:23:47 <skorpan`> x-symbol?
14:23:56 <watermind> I was playing with isabelle
14:24:00 <skorpan`> :|
14:24:01 <sproingie> xemacs has some nicer APIs here and there but it's not as well maintained, and it's a great deal slower on windows
14:24:12 <skorpan`> ,isabelle
14:24:13 * hackagebot upload: statethread 0.1 - The ST monad and STRefs (HenningThielemann)
14:24:13 <lunabot>  luna: Not in scope: `isabelle'
14:24:22 <sproingie> plus some of xemacs's nicer apis like buffer-syntactic-context are just too buggy to use anyway
14:24:27 <skorpan`> oh what the fuck, this is is not #emacs ??
14:24:34 <watermind> yes x-symbol parses grammars and displayes it as symbols
14:24:53 <watermind> so you can have <rightarrow> parsed as an arrow
14:24:57 <watermind> and <beta> as a beta
14:24:58 <watermind> etc
14:25:03 <sproingie> neat
14:25:17 <watermind> so in Isabelle the theorem prover you can see your proofs in nice mathematical notation
14:25:42 <watermind> in fact I was always hoping for someone to do the same for haskell
14:25:53 <sproingie> there is some support for that
14:25:54 <tensorpudding> you mean agda?
14:25:56 <sproingie> it screws up layout tho
14:26:00 <watermind> although I can understand it's messy because of the layout
14:26:06 <watermind> tensorpudding: ? agda
14:26:08 <roconnor> matita
14:26:13 * hackagebot upload: monadLib 3.6 - A collection of monad transformers. (IavorDiatchki)
14:26:23 * watermind googles
14:26:24 <tensorpudding> agda, it's a theorem prover writen in haskell
14:26:30 <sproingie> huh, whatever happened to hasktags?
14:26:38 <tensorpudding> err, proving language
14:26:42 <roconnor> http://matita.cs.unibo.it/images/screenshot-matita-href.png
14:26:43 <tensorpudding> uses dependent types
14:27:21 <watermind> tensorpudding: oh I didn't know it was writen in haskell
14:28:47 <watermind> roconnor: how was the GUI built?
14:28:58 <watermind> roconnor: do you know?
14:29:08 <roconnor> nope
14:29:17 <roconnor> other than it went via mathml
14:29:50 <sproingie> alfa?  it's haskell.
14:29:54 <watermind> it's a smart way to do it
14:30:31 <watermind> ok so I'll give GNU Emacs a try
14:30:36 <watermind> and hope for the best
14:30:42 <sproingie> i suspect there's something newer than alfa tho
14:30:58 <watermind> so many theorem provers
14:31:15 <anfedorov> hey
14:31:20 <roconnor> agda sort of isn't a theorem prover kinda
14:31:22 <watermind> I will want to implement a few things in a couple of months and have no idea which one to choose
14:31:48 <anfedorov> I remember seeing a project for creating haskell code matching a given type signature
14:31:55 <anfedorov> *generating
14:32:00 <anfedorov> does anyone know what I'm thinking of?
14:32:00 <sproingie> that's quickcheck kinda sorta
14:32:02 <Heffalump> @djinn a -> b -> b
14:32:02 <lambdabot> f _ a = a
14:32:06 <gwern> haskell is my favorite theorem prover
14:32:12 <Baughn> skorpan`: Yes
14:32:28 <skorpan`> Baughn: watermind claims that haskell-mode is broken on xemacs... :)
14:33:03 <Baughn> skorpan`: Yes..?
14:33:25 <skorpan`> oh, i see
14:33:38 <gwern> people still use xemacs huh
14:33:44 <watermind> Baughn: just downloaded the latest stable and I get "invalid read syntax: #"
14:33:58 <watermind> I had absolutely no idea people were moving to emacs
14:34:59 <Baughn> watermind: XEmacs is fairly different, and also not on my system.. also not really officially supported
14:35:09 <anfedorov> alrite, how about, if I wanted to generate haskell code to match a certain signature, how would I do it?
14:35:11 <Baughn> watermind: I don't know what it might need instead of #
14:35:37 <Baughn> watermind: (But you're welcome to submit patches!)
14:36:26 <gwern> @djinn (a,b) -> b
14:36:28 <lambdabot> f (_, a) = a
14:36:32 <gwern> anfedorov: ^
14:36:39 <watermind> roconnor: why exactly is it just kind-of-a proof assistent?
14:36:42 <gwern> don't ask too much more of it though...
14:36:48 <watermind> roconnor: I looked at the description but wasn't clear
14:36:59 <watermind> Baughn: I think I'll just move to Emacs :P
14:37:12 <FunctorSalad> "<gwern> haskell is my favorite theorem prover" <-- in which sense?
14:37:35 <monochrom> haskell proves 0+0=0.
14:37:57 <roconnor> watermind: it has no tactic system for automation, and nothing well developed to fill that void.
14:37:59 <anfedorov> ah, quickcheck... yeah, not precisely, I was thinking of literally generating haskell source to do genetic programming
14:38:20 <gwern> FunctorSalad: I was jesting about types, and free theorems
14:38:37 <anfedorov> I might be going crazy imagining things, though :-/
14:38:38 <sproingie> Lambda: The Ultimate Theorem Prover
14:38:41 <watermind> roconnor: ok... but it doesn't have because it's not developed yet or because it's not the point at all?
14:39:18 <watermind> gwern: I get the idea but still you don't prove free theorems with haskell
14:39:36 <watermind> gwern: you prove free theorems satisfied by haskell
14:40:20 <gwern> silly pedantic watermind, jests are for kids!
14:40:23 <anfedorov> Ah, I think I'm thinking this: http://www.vishnu.bbn.com/papers/stgp.pdf
14:40:44 <anfedorov> "Strongly Typed Genetic Programming", by DJ Montana
14:40:57 <gbacon> ?hoogle (a,b) -> (c,d)
14:40:57 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
14:40:58 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
14:40:58 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
14:41:33 <gbacon> ?hoogle (a,a) -> (a,a)
14:41:33 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
14:41:33 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
14:41:33 <lambdabot> Data.Graph.Inductive.Basic grev :: DynGraph gr => gr a b -> gr a b
14:41:41 <gwern> anfedorov: there's also a 'magic' tool but the japanese professor developing it seems to've dropped it
14:41:57 <anfedorov> gwern: is there a link?
14:42:05 * gwern shrugs
14:42:37 <anfedorov> :(
14:43:31 <Baughn> watermind: Oh, I almost forgot. You really want Emacs-23.
14:44:23 <medfly> lol, DJ Montana
14:48:10 <ziman> can i have a typeclass method that does not mention the type at all?
14:48:26 <Saizan> no
14:48:36 <ziman> or is the only option to hack it via const?
14:48:38 <ziman> hm, thanks
14:48:41 <copumpkin> well
14:48:46 <Baughn> ziman: There would be no way to tell which instance you meant
14:48:49 <copumpkin> there's a Tagged type to make it a little less ugly
14:48:55 <ziman> yes, that's what bothers me :)
14:49:01 <copumpkin> http://hackage.haskell.org/package/tagged
14:49:11 <copumpkin> world's simplest package ;)
14:49:14 <copumpkin> but it's a neat idea
14:49:21 <Baughn> ..functor? Applicative?
14:49:28 <Baughn> It /contains no data/! -_-;
14:49:32 <aeron> What's the easiest way of timing some execution with haskell, inside a program?
14:49:40 <copumpkin> Baughn: sure it does
14:49:52 <copumpkin> @hackage timeit
14:49:52 <lambdabot> http://hackage.haskell.org/package/timeit
14:49:59 <aeron> thank you kind sir
14:50:01 <Baughn> copumpkin: ..well, okay, yes it does
14:50:04 <Baughn> Odd type
14:50:19 <copumpkin> its only purpose is to avoid dummy parameters
14:51:00 <monochrom> aeron: http://hackage.haskell.org/package/criterion
14:53:25 * Saizan_ writes an applicative instance for data Const a = Const in front of Baughn 
14:54:22 <copumpkin> lol
14:56:17 <Saizan_> it could be worse, i could have used newtype
14:57:20 <dancor> (type)cast charm
15:07:20 <benmachine> ohh man
15:07:40 <benmachine> stupidest bug in project euler problem ever: forgetting that there is a number between sixteen and eighteen
15:08:00 <tromp__> what is it?
15:08:10 <gwern> well, everyone does it. '15 dollars, 16 dollars, 18 dollars... here you go'
15:08:15 <gwern> don't beat yourself up over it
15:08:31 <ddarius> 6Ï€
15:08:31 <benmachine> :)
15:09:19 <aeron> another question: I just installed haskell platform fresh on Fedora 12, and installed cabal.. and I run cabal update, and it tells me I can update with cabal install cabal-install.. but I do that, and it tells me I should run cabal install cabal-install again
15:09:53 <tommd> aeron: I'm not sure but I'd try:  "cabal update ; cabal install cabal ; cabal install cabal-install"
15:09:57 <dcoutts> aeron: check the location of the version you're running vs the location of the version you're updating
15:10:07 <tommd> or listen to dcoutts, thats a better plan.
15:10:32 <aeron> where would I run it if I wanted to do it system-ide?
15:10:33 <aeron> wide
15:10:50 <dcoutts> aeron: my guess is you've got /usr/bin/cabal but the one you just installed will be in ~/.cabal/bin which you've probably not got on your $PATH
15:10:59 <aeron> alright
15:11:00 <aeron> thanks
15:13:00 <Saizan_> if you want to install it system-wide there's --global --root-cmd=sudo, maybe with --prefix
15:13:11 <aeron> alright
15:13:12 <aeron> thanks
15:14:37 <aeron> that worked perfectly
15:16:26 <eu-prleu-peupeu> hello
15:18:29 <eu-prleu-peupeu> what is the best way to apply a new id to a data type that is something like this: data Obj = Obj { id :: Int, bla, bla, bla } whenever it is created ?
15:18:51 <copumpkin> not sure I understand
15:19:03 <monochrom> unique identifier generation
15:19:08 <eu-prleu-peupeu> createObj :: Obj
15:19:26 <monochrom> I feel that some monad is involved
15:19:26 <watermind> Baughn: I have emacs 23
15:19:33 <eu-prleu-peupeu> unique identified generation is easy
15:19:33 <watermind> Baughn: but I'm having problems with it
15:19:38 <eu-prleu-peupeu> thats not the problem
15:19:45 <watermind> Baughn: says it can't load xfonts
15:19:51 <watermind> :S
15:19:54 <eu-prleu-peupeu> well, im using a state monad
15:19:56 <ddarius> monochrom: Or a comonad...
15:21:01 <eu-prleu-peupeu> where i have something like this: newId = {do lst <- get; put $ tail lst; return $ head lst }, where lst is something like [1..] :P
15:21:29 <eu-prleu-peupeu> but i want to enforce that Objs are only created through the function "createObj"
15:21:45 <eu-prleu-peupeu> so that i can guarantee that i always have a unique id
15:21:51 <mauke> make the constructor private
15:21:56 <eu-prleu-peupeu> how is that ?
15:22:18 <monochrom> do not export certain things
15:22:18 <tromp__> same as what Ratio does?
15:22:48 <eu-prleu-peupeu> is there any convention for the name of a constructor function ?
15:23:01 <monochrom> And yes, after a while, you find that it means you will write and export trivial accessor functions. exactly like oop advice.
15:23:02 <ddarius> eu-prleu-peupeu: No.
15:23:04 <eu-prleu-peupeu> is this a good practice in haskell ? :/
15:23:36 <eu-prleu-peupeu> so ill just make everything private by default :P
15:23:48 <eu-prleu-peupeu> since i want an id in all my data types
15:23:55 <mauke> http://haskell.org/haskellwiki/Smart_constructors
15:24:11 <ddarius> eu-prleu-peupeu: There is nothing special about "constructor" functions.
15:24:27 <monochrom> constructors want to be free!
15:24:53 <tromp__> unique objects is harder than smart coinstructors though
15:25:02 <tromp__> there needs to be some hidden state
15:25:26 <monochrom> yes he completed the state part.
15:25:37 <ddarius> monochrom: We have laws in this here type.
15:26:35 <copumpkin> ddarius is the sheriff of this here type?
15:26:40 <eu-prleu-peupeu> im going to become the best haskell programmer in the world
15:26:42 <eu-prleu-peupeu> ever
15:26:45 <monochrom> (what is "this here type"?)
15:26:45 <authorblues> im sure i dont fully understand what im doing, but i am playing with Network.Curl, and curlGetString returns IO (CurlCode, String), and i just want the string, but i dont know how to extract something from the IO monad (or any monad)
15:26:58 <authorblues> can someone explain it to me in terms ill understand for hacking this code together
15:27:08 <mauke> authorblues: you don't, you slap extra code on it with >>=
15:27:12 <copumpkin> monochrom: an attempt to simulate talk from "the old west", at least on my part
15:27:29 <Botje> authorblues: main = do (code, body) <- curlGetString ...; putStrLn body
15:27:38 <mauke> authorblues: basically, you say stuffWithIO >>= foo
15:27:44 <authorblues> got it, i think
15:27:47 <authorblues> ill give that a shot
15:27:47 <mauke> and then it calls 'foo' with the result of the IO
15:27:49 <copumpkin> eu-prleu-peupeu: glad to hear it
15:28:06 <Botje> for now, stick to main if you need to do IO
15:28:07 <ddarius> mauke: maybe
15:28:21 <Botje> once you're no longer getting type errors you can start making your own functions taht return IO *
15:28:40 <Vulpyne> You could also do stringresult <- fst `fmap` curlGetString etc etc
15:29:35 <eu-prleu-peupeu> copumpkin: yeah :D i just need to read some stuff
15:29:41 <eu-prleu-peupeu> like smart constructors and whatever
15:29:42 <copumpkin> don't we all
15:29:53 * copumpkin definitely has lots of stuff to read
15:30:10 <authorblues> okay, all i need is the string returned from this functions monay, and im not getting it quite right
15:30:18 <authorblues> i cant just "stick to main", since im using this library
15:30:23 <authorblues> monad**
15:30:32 <Botje> authorblues: can you paste the code you have so far?
15:30:39 <Botje> on hpaste.org or somesuch
15:31:00 <eu-prleu-peupeu> what are the biggest projects on hackage ,besides xmonad, darcs and cabal ?
15:31:16 <monochrom> I thought Botje's sample code answered all questions.
15:31:22 <authorblues> getCURLString = do (_, str) <- str >>= Curl.curlGetString "***redacted url***" [CurlPort 8300]
15:31:37 <copumpkin> eu-prleu-peupeu: I could've sworn I've seen you ask that before
15:31:48 <monochrom> You never need to get the string. All you need is pass the string on to another function.
15:32:24 <eu-prleu-peupeu> :D
15:32:25 <Botje> authorblues: getCurlString = do { (_, str) <- Curl.curlGetString "url" [CurlPort 8300] ; return str }
15:32:53 <Botje> authorblues: or getCurlString = Curl.curlGetString "url" [CurlPort 8300] >>= \(_, str) -> return str
15:33:18 <Botje> and then getCurlString will have type IO String
15:33:36 <Botje> which means you can only invoke it from within piece of code in IO
15:34:19 <authorblues> Botje: this monad business is just strange to me, but im trying to follow it
15:34:31 <Botje> basically, once you're in the IO monad, there's no way out.
15:34:42 <Botje> you can only use IO * things from within other IO * things
15:34:48 <Botje> and main is the "uber IO thing"
15:34:53 <gwern> curl? just use Network.HTTP. then you use 'openURL = simpleHTTP . getRequest'
15:35:20 <ben> gwern: Does it open a new connection for every request?
15:35:21 <poe> (or getRequestBody . simpleHTTP . getRequest)
15:35:31 <gwern> ben: probably
15:35:39 <monochrom> Those of us who have applied to grad school probably understand this better. Grad school makes us solicit our profs for letters that praise us. To cut cost, we are required to mail the letters to grad school at our own expense. To protect the profs, we are never to read the letters they write. At this point, a haskell newbie may ask "how can you mail a letter if you aren't allowed to read it?"  Haha of course you know that's
15:35:39 <monochrom> a silly question.
15:35:41 <gwern> ben: just means more delicious parallelism!
15:36:13 <copumpkin> monochrom: :O
15:36:45 * hackagebot upload: sorty 0.1 - Sort lines per file size (KrzysztofSkrzetnicki)
15:36:46 <monochrom> In haskell, it is: get_from_prof >>= \letter -> send letter grad_school
15:37:03 <gwern> monochrom: I always wonder, is mail really that expensive?
15:37:10 <copumpkin> that's an awkward order of parameters for send
15:37:10 <monochrom> Who says you need to access the return value before you can give it away?
15:37:18 <copumpkin> get_from_prof >>= send grad_school
15:37:19 <copumpkin> would be nicer
15:37:22 <ddarius> gwern: Enough of it is.
15:37:37 <gwern> ddarius: but how many letters do profs need to mail?
15:38:04 <copumpkin> 42, every day
15:38:06 <monochrom> I don't argue how much cost it saves. Perhaps it is not even about cost, but just about torturing we students.
15:38:19 <copumpkin> it's part of the hypocritic oath they sign when they become professors
15:39:10 <monochrom> I wonder if I should store my insight under "blog" or "humour". :)
15:39:16 <dolio> monochrom is an expert analogizer.
15:39:35 <gwern> monochrom: you don't have a 'monad_tutorial' tag yet?
15:39:42 <monochrom> Don't you find it ironic? I very hate analogies but I'm very good at analogies.
15:39:48 <monochrom> No.
15:39:59 <dolio> It's like rain on my wedding day.
15:40:02 <monochrom> But I have some arrow tutorials. Does that count?
15:40:16 <copumpkin> monochrom: are they like burrito factories?
15:41:00 <authorblues> im REALLY sorry to be a bother, but other parts of my code are breaking now because im not quite understanding the concept. now, if i want to use an IO String as a String/[Char], does any code that makes use of it have to be wrapped in IO monad stuff? because im not quite getting what i expected
15:41:19 <ben> yes
15:41:21 <monochrom> In short yes.
15:41:36 <Botje> yup
15:41:37 <eu-prleu-peupeu> this stuff of using smart constructors with peano numbers is really teh shizniitt
15:41:40 <authorblues> how do i wrap arbitrary code in IO monad stuff
15:41:59 <ben> authorblues: Also you are not a bother, this might be the single most 'what the hell is going on' part of learning haskell
15:42:03 <eu-prleu-peupeu> it makes me feel like tthe very smartt
15:42:04 <authorblues> just hanging a "do" on stuff is really about what ive gleamed from what little bit ive been doing
15:42:15 <monochrom> In long see http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming
15:42:38 <mauke> authorblues: it can all be done with >>= and return
15:43:05 <authorblues> erm, k... i want to treat a IO String as a String in as little bit of overhaul as possible... can >>= do that?
15:43:11 <thoughtpolice> authorblues: hi! :)
15:43:24 <ben> authorblues: >>= takes an IO string and a function that takes a string
15:43:24 <authorblues> hey thoughtpolice, still giving it the good fight
15:43:29 <mauke> authorblues: depending on how hard you squint, yes
15:43:44 <eu-prleu-peupeu> for every data type, ill have a "makeDataType" function
15:43:53 <eu-prleu-peupeu> and ill live happily ever after
15:43:57 <monochrom> Don't treat IO String as String. Don't read the letter.
15:44:10 <ddarius> There is no letter.
15:44:32 <mauke> I follow the letter to the law
15:44:56 <monochrom> >>= passes on the string to the next destination, and my url has concrete examples.
15:45:29 <authorblues> monochrom: i know, im reading
15:45:40 <monochrom> "I want to do some string processing on it before passing it on" I have that as well.
15:46:00 <authorblues> haha, i will want to do that
15:46:48 <mauke> getLine >>= (\str -> return (map toUpper str))
15:48:46 <authorblues> ugh, this really is more frustrating than my traditional programming
15:48:59 <copumpkin> authorblues: it takes getting used to, definitely
15:49:02 <authorblues> okay, full disclosure
15:49:30 <authorblues> im trying to concatenate this string that im scraping with another string by way of: ("Now playing: " ++ (getThatString >>= \s -> return s)
15:49:46 <authorblues> which, you all know is wrong
15:50:10 <authorblues> its the concatenation process that its telling me that the types dont match up... IO String with [Char]
15:50:11 <mauke> ah, slightly wrong order
15:50:12 <Vulpyne> You'd want to do something more like getThatString >>= \s -> return ("Now playing: " ++ s)
15:50:20 <monochrom> I even have an example of getLine >>= \s -> return ("You entered: " ++ s)
15:50:24 <mauke> >>= only gives you another IO something
15:50:29 <Vulpyne> The type of that expression would be IO String.
15:50:29 <ddarius> liftM ("Now playing: "++) getThatString
15:50:37 <mauke> all your operations on the result have to be inside the function to the right of >>=
15:50:46 <authorblues> okay, please dear lord tell me there is a way to just get rid of this damn monad
15:50:50 <authorblues> i just want to get the String clean
15:50:53 <mauke> there isn't
15:51:03 <authorblues> but whhhhhhhhhhy?
15:51:06 <ddarius> authorblues: There is no String.
15:51:07 <copumpkin> you don't
15:51:07 <copumpkin> once you're infected, you can't escape
15:51:09 <copumpkin> someone should make a GPL monad with no Copointed instance
15:51:11 <authorblues> that makes no sense to me
15:51:12 <monochrom> Yes there is a way to just get rid of this damn monad. Use C.
15:51:20 <mauke> authorblues: but seriously, why do you think you need it?
15:51:26 <ddarius> authorblues: What if the network connection fails?  What String should be returned?
15:51:28 <authorblues> monochrom: not helpful
15:51:43 <monochrom> Right, I am unhelpful.
15:51:47 <copumpkin> monadic licenses
15:51:52 <Botje> authorblues: can't you show your code?
15:51:53 <monochrom> I speak the unhelpful truth.
15:51:56 <authorblues> ddarius, mauke: thats fair, but it just seems so arbitrary
15:52:04 <mauke> authorblues: you can just put all your code inside the ... in 'foo >>= \x -> ...', and x will be IO-free
15:52:13 <Botje> it's easier if we could just tell you how to proceed
15:52:14 <copumpkin> authorblues: it isn't arbitrary at all
15:52:25 <Vulpyne> authorblues: blah <- somethingthatreturnsIOString -- After that, you can pretty much treat blah like a plain String.
15:52:31 <mauke> authorblues: the real reason is that Haskell can't execute actions
15:52:39 <authorblues> Botje: a lot of this is modifying code that isnt mine, so i dont feel like theres anything else worth looking at
15:52:43 <Vulpyne> authorblues: So for example you could then do: putStrLn (blah ++ " other string stuff")
15:52:55 <copumpkin> authorblues: think of it as one of those toxic boxes with gloves built into them, and a one-way door in. You can stick stuff in the box, and manipulate it while it's inside the box, but it can NEVER ESCAPE!!
15:53:12 <Vulpyne> authorblues: You could also call a pure function on it, like: let thingy = take 10 blah
15:53:12 <mauke> copumpkin: ew, no
15:53:28 <copumpkin> lol
15:53:38 <Botje> authorblues: but perhaps an example will get you going. making code monadic is fairly mechanical.
15:53:44 <Vulpyne> authorblues: But the function that is doing IO stuff has to return an IO result, so the impureness can't escape.
15:54:01 <mauke> here's an incomplete sketch of how I think about this: http://mauke.ath.cx/stuff/haskell/how-to-io.html
15:54:11 <copumpkin> omg mauke almost has a monad tutorial
15:54:17 <mauke> no
15:54:24 <mauke> note how "monads" are never mentioned
15:54:32 <mauke> this is an IO tutorial
15:54:35 <monochrom> I feel that all of us in the business of writing tutorials have lived in vain.
15:54:49 <ddarius> That's why I don't write tutorials.
15:54:51 <authorblues> Botje: alright, lemme get it up
15:55:04 <Apocalisp> authorblues: It's not arbitrary. When you have an IO String, you basically have a *program* that will get a string from the operating system.
15:55:30 <fbru02> when recurring over a list how con i know how deep into the recursion , aka the index of the array, am i ?
15:55:32 <ddarius> Apocalisp: Maybe.
15:55:48 <Apocalisp> Yeah, it might actually not :)
15:55:49 <mauke> fbru02: you count
15:55:51 <mauke> manually
15:55:52 <ddarius> fbru02: Do you mean lists or arrays?  You don't.
15:55:57 <Botje> fbru02: either keep a counter or zip the list with [0..]
15:56:33 <fbru02> Botje: ok that's what i saw, most of the time , you use a tuple and a zip ?
15:56:44 <Apocalisp> authorblues: You can't get a String out, but you can put another program in, a program that accepts a String once it's available from IO.
15:57:03 <ddarius> monochrom: There are and have been excellent tutorials on these topics for almost two decades and see how well they are recognized.
15:57:34 <Apocalisp> we need a comonadic OI tutorial :)
15:57:39 <Botje> fbru02: yes
15:58:20 <monochrom> People seem to prefer the tutorials not living on a web page, but be pasted into irc at say 2 seconds per line on demand, "on-demand streaming tutorial".
15:58:29 <fbru02> Botje: thanks
15:58:47 <Botje> .. in magnificent surround sound!
15:59:42 <copumpkin> people like human contact and interaction, even if it's crammed through a restrictive medium like text
15:59:45 <authorblues> Botje: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5222#a5222 please be kind... im trying to modify some code i found. thats USUALLY how i learn, but this is a bit bigger
15:59:59 <rinspy_> I think I'm being retarded here but... Î»x.xx is in Î²-normal form, right?
16:00:05 <gwern> monochrom: personalized tutorials, you mean
16:00:11 <mauke> oh nice, another half broken IRC bot
16:00:18 <gwern> @quote stereo
16:00:19 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
16:00:23 <monochrom> Actually, you can't tell whether it's personalized or not.
16:00:36 <authorblues> mauke: im just prototyping something quickly for radio reddit
16:00:38 <gwern> monochrom: sure you can. google for the messages?
16:00:45 <authorblues> thought id try it in haskell instead of perl for a change
16:01:13 <Botje> authorblues: okay. so you have getCurrentSong, that's :: IO String
16:01:19 <mauke> \r\n is just wrong
16:01:19 <authorblues> right
16:01:21 <Botje> you can turn that into a Net String with io
16:01:28 <Botje> and eval is in the Net monad
16:01:28 <authorblues> ...okay
16:01:32 <mgorbach_adium> Can someone clarify some syntax for me? I have a case statement inside a do block (STM Monad). In one of the branches of the case statement, I need to put more than 1 line of code. How do I do this?
16:01:42 <Botje> so you can use the >>= construction again:
16:01:49 <mauke> mgorbach_adium: start another do block
16:02:03 <Botje> eval "!nowplaying" = getCurrentSong >>= \str -> privmsg ("Now playing: " ++ str)
16:02:07 <gwern> mgorbach_adium: you mean like 'do foo; bar; return ()', something like that?
16:02:17 <Botje> uh
16:02:18 <mauke> Botje: needs more io
16:02:21 <Botje> yeah.
16:02:26 <Botje> eval "!nowplaying" = io getCurrentSong >>= \str -> privmsg ("Now playing: " ++ str)
16:02:54 <Botje> authorblues: can you verify if that compiles?
16:03:03 <authorblues> it does
16:03:10 <Botje> good
16:03:15 <monochrom> I should write a bot to do exactly what I said. streaming tutorials.
16:03:16 <Botje> now i can work backwards from the types :)
16:03:25 <mgorbach_adium> mauke: Indeed that works. Thanks.
16:03:35 <monochrom> Its personalization feature means you can enter "pause", "go back 5 lines".
16:03:47 <Botje> monochrom: don't forget "my brain asploded"
16:03:58 <Botje> authorblues: io getCurrentSong has type Net String
16:04:14 <monochrom> Oh, for mysterious reasons there is no "stop" hahaha
16:04:15 <Botje> authorblues: you want to use that string and pass it as an argument to privmsg
16:04:20 <authorblues> so io :: IO a -> Net a
16:04:21 <authorblues> ?
16:04:24 <Botje> yes
16:04:43 <Botje> the >>= function takes something of type Net a
16:04:48 <Botje> and a function of type (a -> Net b)
16:04:56 * hackagebot upload: sorty 0.1.1 - Sort lines per file size (KrzysztofSkrzetnicki)
16:05:01 <authorblues> now whats the diff between IO monad and Net monad
16:05:06 <Botje> in this case: Net string and String -> Net ()
16:05:14 <mauke> authorblues: Net has some special powers on top of IO
16:05:29 <mauke> wait, that looks really simple
16:05:43 <Botje> authorblues: the author of this bot chose to be lazy
16:05:48 <mauke> authorblues: Net carries the IRC connection around (the socket)
16:05:50 <Botje> authorblues: and instead of passing the handle around everywhere
16:05:56 <Botje> it is passed around invisibly by the reader monad
16:06:19 <authorblues> thats just what i need. someone trying to make my life easier
16:06:26 <Botje> actually, it is.
16:06:29 <authorblues> when i get done with exams, im going to try to roll my own
16:06:39 <Botje> if you didn't use that, you'd have to pass Handle around _everywhere_
16:06:56 <authorblues> Botje: that seems to me like it would clarify the code
16:07:09 <Botje> authorblues: not really
16:07:19 <Botje> since most of the time you'd simply pass it through
16:07:37 <Botje> if you look at the occurrences of asks, that's where the handle is used
16:07:53 <Botje> which is all of two places, if i'm counting correctly
16:08:08 <Botje> yeah
16:08:33 <Botje> if you didn't have ReaderT, eval would need the handle, privmsg would need it, and write would need it
16:08:48 <authorblues> hmmm, this turned out not to be a trivial task
16:08:57 <Botje> it's only hard the first time round :)
16:09:04 <authorblues> hopefully
16:09:12 <Botje> authorblues: stare _REAL_ hard at the type for (>>=)
16:09:22 <authorblues> im loving haskell, but theres a few hurdles ive never experienced in any other language
16:09:42 <authorblues> yeah, it takes an IO a and a function a -> IO b, and gives you an IO b
16:09:43 <Botje> and the type for io getCurrentSong, and the type for \str -> privmsg ("Now Playing" ++ str)
16:09:59 <mauke> don't be afraid of the IO. it can smell your fear.
16:10:03 <mauke> STARE IT DOWN
16:10:08 <Botje> :)
16:10:11 <authorblues> mauke: i wreak of it
16:10:27 <Botje> authorblues: anyway, monads are real easy if you think about them logically
16:10:36 <Botje> for me, staring at the types long enough made it "click"
16:10:48 <mauke> having consulted a dictionary I think you mean reek?
16:10:49 <authorblues> Botje: im not at that level yet
16:10:58 <authorblues> reek is probably what i meant
16:10:59 <monochrom> I calculated with the types long enough.
16:11:01 <Botje> ah. you want to first learn a bit more about the type system then
16:11:10 <Botje> save I/O for later
16:11:15 <authorblues> i get the type system, i just dont get monads
16:11:26 <Botje> well, no one can help you with that
16:11:30 <authorblues> haskell makes sense to me, almost all of it, but monads
16:11:37 <mauke> this isn't monads, it's IO :-)
16:11:42 <authorblues> i mean, ive done functional, a bit, with some LISP/scheme
16:11:46 <Botje> they're real easy.
16:11:55 <Botje> stop thinking of them as hard, because they're not :)
16:12:04 <Botje> and then you'll see the light
16:12:07 <Botje> right! off to bed now :)
16:12:16 <authorblues> Botje: lol, vicious cycle. thanks for all the help
16:14:14 <Cale> hylo'morphism [Gr. {mu}{omicron}{rho}{phi}{ghacu} form], the doctrine that primordial matter is the First Cause of the universe.
16:16:05 <gwern> @wn reek
16:16:07 <lambdabot> *** "reek" wn "WordNet (r) 2.0"
16:16:08 <lambdabot> reek
16:16:08 <lambdabot>      n : a distinctive odor that is offensively unpleasant [syn: {malodor},
16:16:08 <lambdabot>           {malodour}, {stench}, {stink}, {fetor}, {foetor}, {mephitis}]
16:16:08 <lambdabot>      v 1: have an element suggestive (of something); "his speeches
16:16:09 <lambdabot> [6 @more lines]
16:16:24 <dibblego> is there a Parsec-based function for parsing Haskell syntax?
16:24:41 <watermind> oh my
16:24:47 <copumpkin> oh your
16:24:56 <watermind> took me ages to get emacs set up to work with haskell :S
16:25:13 <bastian> apt-get install haskell-mode (=
16:25:14 <pastah_rhymez> watermind: vim?
16:25:18 <watermind> the wonders of working with an ancient distribution :S
16:25:23 <watermind> pastah_rhymez: nah
16:25:31 <watermind> pastah_rhymez: not that desperate
16:25:33 <pastah_rhymez> watermind: ED THE STANDARD TEXT EDITOR?
16:25:54 <pastah_rhymez> apparently you have to write that in caps, dunno why...
16:26:08 <watermind> pastah_rhymez: I rather write it on paper and use OCR :P
16:27:10 <watermind> can we use unicode with ghci?
16:27:18 <watermind> alphas, betas, gammas
16:27:19 <medfly> yes
16:27:22 <medfly> eh..
16:27:24 <osaunders> pastah_rhymez: Oh it's because if you don't it causes a time space discrepancy and everyone dies.
16:27:40 * medfly doesn't know about that part
16:27:47 <watermind> :S
16:27:50 <osaunders> Some say it would have been better if ED THE STANDARD TEXT EDITOR was never created.
16:28:04 <osaunders> I mean, it's pretty risky.
16:28:13 <osaunders> Someone could type it wrong at any moment.
16:28:33 <watermind> so no one is using greek letters in haskell programs
16:28:38 <watermind> they look nice :S
16:29:05 <pastah_rhymez> watermind: --> #agda
16:29:17 <pastah_rhymez> they only use emacs and greek letters
16:29:22 <pastah_rhymez> and logic symbols
16:29:26 <watermind> I like them
16:32:48 <copumpkin> watermind: agda loves unicode
16:33:05 <copumpkin> watermind: but despite superficial similarities, it's quite a different language, and you need to be more careful about many things
16:33:33 <watermind> copumpkin: yes I checked the page, dependent types, proof checking
16:33:37 <watermind> copumpkin: sounds interesting
16:33:42 <copumpkin> it is awesome :)
16:34:10 <watermind> copumpkin: regarding the functional aspect of it, is it also lazy?
16:34:19 <copumpkin> well
16:34:21 <copumpkin> it's total
16:34:26 <copumpkin> it supports codata
16:34:41 <copumpkin> so it's sort of "explicitly lazy"
16:35:04 <watermind> codate?
16:35:07 <watermind> *codata
16:35:45 <copumpkin> well, with regular data you specify constructors
16:36:14 <watermind> so codata, destructors I guess...
16:36:16 <copumpkin> with codata you specify destructors :P
16:36:17 <copumpkin> yeah
16:36:20 <watermind> such as head and tail
16:36:31 <copumpkin> in the sense that they give you an observation of the data
16:37:25 <watermind> so what is the essential difference between those destructures specified in codata and haskell's pattern matching on the constructors?
16:37:54 <copumpkin> superficially data and codata declarations look very similar, you have: (co)data X (parameters) :  (type) where moo : (another type) -> (type); baa : (yet another type) -> (type)
16:38:06 <copumpkin> you still get to pattern match on them
16:39:01 <copumpkin> haskell data is more like codata
16:39:19 <idnar> what are parameters and type in the first bit there?
16:39:35 <copumpkin> data Bool : Set where true : Bool; false : Bool
16:39:45 <poe> type variables  and a  type  in which those are bound I guess
16:39:59 <copumpkin> data Nat : Set where zero : Nat; suc : Nat -> Nat
16:40:21 <watermind> can you give an example of codata too?
16:40:21 <poe> is Set the only primitive type?
16:40:34 <copumpkin> watermind: just replace the data with codata there :)
16:40:41 <copumpkin> poe: it's the type of types
16:40:51 <copumpkin> but yeah, there are no real primitive types
16:41:00 <copumpkin> although recently you get something kinda primitivish
16:41:05 <watermind> copumpkin: oh I thought they would have different uses...
16:41:28 <watermind> so what would be the difference between Bool specified as data/codata
16:41:36 <copumpkin> data Fin : Nat -> Set where zero : {n : Nat} -> Fin (suc n); suc : {n : Nat} -> Fin n -> Fin (suc n)
16:41:49 <copumpkin> watermind: almost nothing, really
16:41:49 <Saizan_> idnar: parameters are those that don't change between constructors
16:41:59 <copumpkin> in fact, in agda we typically don't usually use codata declarations on their own
16:42:22 <copumpkin> we keep it locked away in a handy type called âˆž
16:42:23 <watermind> I was trying to see the connection between this and lazyness
16:42:31 <copumpkin> watermind: âˆž might make it a bit clearer
16:42:33 <poe> what is Fin?
16:42:42 <copumpkin> poe: all naturals smaller than a certain value
16:42:47 <copumpkin> poe: also known as finite sets
16:42:59 <copumpkin> so Fin 3 is inhabited by 0, 1, 2
16:42:59 <roconnor> Fin n is a type with n elements.
16:43:17 <dolio> I'm not sure âˆž is 'handy' and not 'hacky'.
16:43:18 <idnar> can you define something like Haskell's [] type?
16:43:19 <roconnor> Fin 0 = Empty
16:43:23 <lispy> Is there a command (preferably on hackage) which will colorize some haskell code on stdout or in my pager?
16:43:25 <roconnor> Fin (S n) = option (Fin n)
16:43:27 <roconnor> er
16:43:32 <copumpkin> dolio: it is hacky, but it's also kinda neat, I think :P
16:43:32 <roconnor> Fin (S n) = Maybe (Fin n)
16:43:34 <poe> copumpkin the definition misses an n ?
16:43:38 <Saizan_> lispy: hscolour
16:43:42 <copumpkin> poe: ?
16:43:51 * roconnor hears the ghosts of ocaml
16:43:52 <copumpkin> watermind: here it is http://www.cs.nott.ac.uk/~nad/listings/lib/Coinduction.html#452
16:43:58 <lispy> Saizan_: thanks.  I installed that but it's not in my path...maybe bash is being dumb
16:44:09 <mauke> hash -r
16:44:15 <poe> copumpkin oh nevermind, ' .. : Nat -> Set ' here's the n
16:44:41 <Saizan_> lispy: check that you have ~/.cabal/bin in the PATH
16:44:48 <lispy> Oh, HsColour not hscolor
16:44:51 <lispy> hscolour*
16:44:55 <Saizan_> ah, yeah
16:44:57 <copumpkin> watermind: so basically you have a type âˆž that is codata, and you can stick anything into it using the # constructor
16:45:16 <copumpkin> you can think of # as a thunk
16:45:29 <watermind> ye
16:45:31 <watermind> yes
16:45:33 <copumpkin> â™­ on that thunk will pull the value out, and force it
16:46:16 <watermind> I see so that basically gives you a lazy datatype?
16:46:21 <copumpkin> it also adds a certain musical feel to agda ;)
16:46:29 <copumpkin> watermind: more or less
16:47:06 <copumpkin> watermind: it's the only way to get infinite things, because on regular data the typechecker expects things to be finite (or you won't pass the termination checker)
16:47:16 <Saizan_> "The Sound of Codata" a great name for a paper
16:47:35 <copumpkin> the hills are alive with it :)
16:47:54 <lispy> Saizan_: hehe
16:48:16 <poe> Saizan_ why? (:
16:48:16 <copumpkin> dolio: would you prefer the \# and \b to be implicit?
16:48:26 <copumpkin> I remember NAD proposing that somewhere
16:48:33 <lispy> Saizan_: subtitle, "And Other Infinite Musicals."
16:49:29 <copumpkin> here is that Fin type I mentioned if anyone's interested: http://www.cs.nott.ac.uk/~nad/listings/lib/Data.Fin.html#339
16:51:29 <copumpkin> (it's very useful if you have a vector type that has an explicit length, and you don't want to allow people to index outside of it, for example)
16:52:22 <dolio> I'd prefer that if codata really doesn't work, something else that corresponds better to the underlying theory, instead of using codata to make a single type that we use in a certain way to mimic what the underlying idea is.
16:52:35 <copumpkin> yeah, true
16:52:42 <copumpkin> hm
16:52:46 <copumpkin> I wonder what a nicer way to do it is
16:53:01 <copumpkin> Saizan_: you have the paper title, you should come up with the idea! :P
16:53:46 <mreh> can I store a haskell function to be retrieved later?
16:53:55 <copumpkin> on disk? nope
16:54:12 * medfly wonders what that means
16:54:15 <jcapper> Isn't that what a .hs file is?
16:54:23 <mreh> jcapper: no
16:54:33 <poe> If the function is simple enough there is a chance
16:54:35 <mreh> well, I could write a function that writes source code
16:55:02 <mreh> copumpkin: it isn't impossible though?
16:55:17 <copumpkin> mreh: it wouldn't be if we had some sort of bytecode
16:55:25 <medfly> maybe you can write a .hs file and then use it?
16:56:02 <mreh> i have a perceptron, it takes ages to train it and test it, but I have no idea how long it takes to do each
16:56:11 <mreh> is suppose profiling is an idea
16:56:32 <copumpkin> mreh: you could deal with its "closure" explicitly as data
16:56:34 <mreh> but when it comes to implementing this baby, I don't want to have to wait for the damn thing to come-online every time
16:56:36 <copumpkin> and then have a way of saving that
16:57:10 <Associat0r> mauke
16:58:04 <watermind> mreh: a perceptron? so basically you just need to store its configuration...
16:58:12 <watermind> mreh: the weights
16:58:19 <mreh> watermind: yes, i didn't implement it like that
16:58:30 <mreh> watermind, the weights and the training data of course
16:58:38 <mreh> it's a kernel perceptron
16:58:48 <mreh> unless you know a way of compressing it
16:58:52 <mreh> i couldn't thing of one
16:58:59 <mreh> think*
17:00:01 <mreh> with a kernel perceptron the configuration is a function of the training data "dot" the input
17:00:43 <mreh> that's megabytes if you have 4000 training images that are 16x16
17:00:58 <mreh> there must be a better way of representing the configuration that I can't see
17:01:05 <watermind> I see :S
17:01:42 <mreh> anyway, it recognises handwritten digits okay, it's just ******* slow to get started
17:06:58 <Axman6> rarg. just realised that just because GHCi can read something implementing Num, when you write "1+2*3", it still doesn't have a read instance >_<
17:07:11 <maurer_> Is there an easy way to force a thunk?
17:07:27 <Axman6> seq
17:07:30 <copumpkin> pattern match on it, or use seq
17:07:32 <amckinley> hey, could someone help me understand the state monad?
17:07:48 <copumpkin> amckinley: do you understand functors?
17:07:59 <Axman6> @src State
17:07:59 <lambdabot> Source not found.
17:08:03 <Axman6> :O
17:08:13 <Axman6> @unmtl State s a
17:08:13 <lambdabot> s -> (a, s)
17:08:19 <shachaf> amckinley: My advice is always to reimplement State yourself.
17:08:33 <shachaf> amckinley: Figure out how it would be done. Then, afterwards, you can figure out how it fits in as a monad.
17:08:41 <osaunders> I'm guessing Yi is like Vi?
17:08:43 <Axman6> data State s a = State (s -> (a,s))
17:08:57 <copumpkin> amckinley: a good introduction is here: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html , but I encourage you to make sure you understand functors (and ideally applicatives) before you play with monads
17:09:03 <amckinley> copumpkin: definitely not :) i understand the idea of state transformation and immutable reference, but im really having a hard time understanding the way my monadic code interacts with the rest of my program
17:09:28 <Axman6> amckinley: actually, i have a video, which i just realised, i think implements a stateful parser monad. it might be helpful :)
17:09:43 <Axman6> amckinley: http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13/
17:10:14 <amckinley> Axman6: awesome, thanks :)
17:10:39 <Axman6> amckinley: if nothing else, it'll help you understand monad parsers :P
17:10:45 <Axman6> monadic*
17:10:48 <copumpkin> amckinley: sigfpe's blog posts in general are pretty awesome
17:10:58 <copumpkin> one should understand applicative parsers first! ;)
17:11:05 <amckinley> Axman6: that would be great, especially because ive written a bunch of monadic parsers without really understanding them ;)
17:11:44 <monochrom> I have long used real numbers without understanding them.
17:11:51 <Axman6> copumpkin: well, Monad gives you do notation. all monads are applicative right?
17:12:14 <copumpkin> Axman6: yeah, but you should understand what you can get without monads and then understand what more monads give you
17:12:28 <monochrom> Then one day someone told me "did you know for real numbers every bounded non-empty subset has a supremum?" and my brain exploded.
17:12:56 <amckinley> copumpkin: what im trying to do is have my haskell program recieve newline-delimited "commands" on stdin, which should cause the state-update to happen. then eventually there's a "DONE" command which terminates processing
17:13:06 <Axman6> monochrom: ... supremum?
17:13:39 <copumpkin> a greatest value, that isn't necessarily in the set, I think
17:14:05 <osaunders> What can I do about this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13474#a13474
17:14:14 <copumpkin> [0, 1) has a supremum of 1, even though it isn't in the actual set
17:14:31 <copumpkin> unless I'm confused :)
17:14:48 <medfly> uppah-bound
17:15:44 <Saizan_> osaunders: cabal install alex
17:16:34 <osaunders> Saizan_: Worked. What the hell?! Why do I need to do that manually?
17:16:43 <copumpkin> it's an executable
17:16:49 <copumpkin> not a library
17:17:06 <osaunders> Oh wait, another error.
17:17:09 <copumpkin> and so eu-prleu-peupeu disappears for another month
17:17:15 <copumpkin> until he's in the mood for haskell again
17:17:15 <monochrom> haha
17:17:25 <amckinley> @type foldM
17:17:26 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:17:30 <osaunders> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13474#a13475
17:17:40 <copumpkin> at which point he shall return, tell us he'll be the greatest haskLE programmer ever, and ask what the biggest projects in haskell are
17:18:07 <heatsink> Oh yeah, I got that error too.
17:18:12 <monochrom> "write a C compiler and interpreter in haskell"
17:18:22 <heatsink> You can remove the instance declaration in Yi.
17:18:49 <osaunders> heatsink: You removed it manually and then it worked?
17:18:55 <heatsink> Yes
17:19:00 <Axman6> monochrom: i've been wanting someone to do that for a while now
17:19:05 * osaunders isn't very impressed
17:21:56 <Axman6> :t (.) (.)
17:21:57 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
17:22:07 <Saizan_> they've been too optimistic about that instance
17:22:27 <Saizan_> osaunders: you can also use --constraint="data-accessor < 0.2.1"
17:22:36 <heatsink> osaunders, Yi was developed with an earlier version of data-accessor and doesn't have precise enough dependences.  That instance declaration isn't in data-accessor-0.2.0.2, so you can try installing that version.
17:23:28 <Saizan_> actually, it's the data-accessor guys that aren't respecting the PVP
17:23:35 <osaunders> PVP?
17:23:54 <heatsink> Player versus player?
17:23:57 <Saizan_> Package Versioning Policy
17:24:00 * QtPlaty[HireMe] xpands pvp as player vs player
17:24:16 <Saizan_> but yeah, i used to expand pvp like that too :)
17:24:47 * osaunders doesn't like it when packages don't install.
17:25:08 <osaunders> I'm going to try what heatsink said first.
17:25:12 <Saizan_> osaunders: you could mail the maintainers asking them to fix
17:25:50 <osaunders> Saizan_: It would be better if a system was designed such that these things didn't break so easily.
17:26:03 * Cale tries to fix the hacky PHP LaTeX plugin some more so that it doesn't replace things inside <code></code> and <pre></pre>
17:26:09 <osaunders> This problem is rife in all languages.
17:26:20 <Cale> I really really hate regular expressions.
17:26:21 <Saizan_> it's an hard problem
17:26:28 <dolio> Cale: You're getting outpaced on your blog.
17:26:30 <gwern> Cale: why bother?
17:26:34 <Cale> dolio: It's true.
17:26:35 <gwern> just use gitit or something
17:27:38 <osaunders> This is cale's blog http://forum.bible.org/blog/blogs/cale
17:27:46 <osaunders> :-P
17:27:53 <Cale> I wish that regular expressions at least supported something closer to the full range of operations which regular languages are closed under.
17:28:22 <Cale> Regular languages are closed under complement and intersection, but there's no way to express that.
17:28:36 <osaunders> What's that?
17:28:40 <osaunders> That sounds interesting.
17:29:02 <Cale> Of course, perl regular expressions aren't even regular expressions, but let's ignore that for a moment.
17:29:14 <monochrom> This is the same mindset as "propositional logic is just and-or-not".
17:29:28 <mauke> and of course, PCRE isn't perl regexes
17:29:38 <Cale> That's true too
17:29:48 * mauke shakes a fist
17:29:50 <osaunders> OK, lemme guess Regular Expressions come from math?
17:29:56 <monochrom> "you could convert other operations to and-or-not" "you could convert other operations to union-concat-star"
17:30:18 <Cale> osaunders: Yes. The branch of math called computer science.
17:30:22 <byorgey> osaunders: well, from theoretical computer science =)
17:30:32 <byorgey> and what Cale said
17:30:41 <gwern> osaunders: squint right, and everything comes from math
17:31:01 <byorgey> especially everything discussed in this channel. ;)
17:31:01 <copumpkin> you don't even need to stray very far from "regular math" to get regular expressions though
17:31:10 <copumpkin> as in, you don't need to squint very hard ;)
17:31:10 <monochrom> Everything comes from hylomorphism. :)
17:31:16 <copumpkin> omg
17:31:32 <Cale> regular languages are the preimages of subsets of finite monoids under homomorphisms from a free monoid
17:31:46 <osaunders> :-O
17:31:46 <mauke> zomg
17:32:07 <amckinley> thats what *she* said! :D
17:32:07 <monochrom> haha ok!
17:32:31 <poe> a conversation killer (or starter..)
17:32:31 <osaunders> lol
17:32:31 <mauke> I have no idea what you just said, but I can use regexes
17:32:32 <copumpkin> Cale: what was the URL to your blog again?
17:32:32 <Draconx> Alternately, regular languages are the languages described by regular expressions.
17:32:32 <inimino> well that was an interesting thing to see while glancing at #haskell
17:32:32 <Cale> http://analogical-engine.com/wordpress/
17:32:36 <copumpkin> Draconx: and define regular expressions!
17:32:38 <mauke> and by "regex" I mean the things that are actually out there
17:32:39 <stroan> and now to google every noun in that sentence...
17:32:40 <copumpkin> (inductively!)
17:32:49 <Draconx> copumpkin, sure, one sec.
17:33:01 <mauke> I actually know the nouns, but I don't know what "free" means
17:33:14 <byorgey> mauke: "free monoid" = list
17:33:20 <mauke> ...
17:33:24 <poe> typically "no relations between the elements"
17:33:26 <monochrom> (Who is Robin?)
17:33:30 * osaunders adds Cale's blog to Google Reader and tags it under "oneday"
17:33:31 <Cale> yeah the lists on some alphabet under concatenation
17:33:37 <copumpkin> Cale and Robin, sitting in a tree
17:33:37 <copumpkin> or something
17:33:42 <Cale> monochrom: friend of mine
17:33:43 <Draconx> copumpkin, let Î£ be a finite set of symbols not containing (, ), | or *.
17:33:44 <copumpkin> writing a blog entree
17:33:53 <Draconx> an element of Î£ is a regular expression.
17:34:00 <Draconx> the concatenation of two regular expressions is a regular expression.
17:34:13 <Draconx> a regular expression enclosed in parentheses is a regular expression.
17:34:25 <mauke> I can spot the hole
17:34:34 <copumpkin> Draconx: what else?
17:34:35 <Draconx> two regular expressions separated by | is a regular expression.
17:34:42 <Draconx> anything else is not a regular expression.
17:34:44 <monochrom> "to understand regular expression, you must first understand context-free language"
17:34:48 <byorgey> you forgot *
17:34:49 <mauke> Draconx: that doesn't use *
17:34:50 <copumpkin> Draconx: you forgot * and empty languages
17:35:00 <mauke> copumpkin++
17:35:03 <Draconx> whoops, I had that written down, too :/
17:35:09 <monochrom> Oh I have a funnier one. "To understand regular expression, you must first understand recursion"
17:35:18 <inimino> :)
17:36:03 <amckinley> monochrom: "to understand recursion, you must first understand recursion"
17:36:13 <copumpkin> wow, Robin's most recent entry was written in the future ;)
17:36:18 <monochrom> Yes that's where I drew inspiration!
17:36:23 <mauke> preflex: quote LeoNerd
17:36:23 <preflex>  <LeoNerd> Circular definition: (n). Something like this.
17:36:26 <Cale> data Reg a = Zero | One | Symbol a | Plus (Reg a) (Reg a) | Times (Reg a) (Reg a) | Star (Reg a)
17:36:29 <Draconx> monochrom, indeed, the language of regular expressions is not regular.
17:36:32 <medfly> hi!
17:36:37 <copumpkin> Cale: why One?
17:36:49 <copumpkin> oh
17:36:53 <Cale> copumpkin: One is the empty string, Zero is the empty language
17:36:54 <copumpkin> the language containing only the empty string
17:37:05 <copumpkin> yeah
17:37:53 <heatsink> I have a parsec question.  If I get an "unexpected" error message and an "expecting" error message together, should these errors pertain to the same input position?
17:38:19 <copumpkin> still no Rel category
17:38:24 * copumpkin goes hrrmpf
17:38:38 <osaunders> Cale: Regular expresions are a superset of BNF?
17:38:40 <amckinley> heatsink: yes. "expecting" is just a list of all the parsers that failed to be applied
17:38:44 <mreh> how can I break up a list with ordered elements
17:38:45 <copumpkin> you should have subcategories :P
17:38:46 <mauke> more like subset
17:38:56 <Cale> osaunders: no
17:39:06 <mreh> break doesn't give me the option to look at the last character
17:39:18 <mreh> element*
17:39:30 <osaunders> heatsink: Nice one, Yi just built.
17:39:32 <amckinley> mreh: what are you trying to do? partition a list?
17:39:36 <mreh> yah
17:39:45 <heatsink> osaunders, good.
17:39:48 <amckinley> mreh: based on what, some predicate?
17:39:50 <mreh> amckinley: actually, count the elements of a list
17:40:10 <mreh> the number of ocurrances of a digit in a list
17:40:25 <osaunders> Do people hear like Yi?
17:40:26 <Draconx> Okay, I think I prefer the definition: A regular language is a language L for which the Myhill-Nerode equivalence relation R_L has finite index.
17:40:36 <mreh> for all digits in the list
17:40:50 <heatsink> amckinley, I think I found a bug in Parsec then.  Adding tokens after the error-token will change the "expecting" message and/or cause parsing to succeed, but does not change the "unexpected" message.
17:40:52 <osaunders> *here
17:41:42 <amckinley> @type breakList
17:41:43 <lambdabot> Not in scope: `breakList'
17:41:48 <amckinley> @type MissingH.breakList
17:41:49 <mreh> aaha, group
17:41:49 <lambdabot> Couldn't find qualified module.
17:41:52 <amckinley> *sigh*
17:41:55 <amckinley> mreh: http://hackage.haskell.org/packages/archive/MissingH/0.18.6/doc/html/Data-List-Utils.html#v%3AbreakList
17:41:57 <mreh> group [1..10]
17:42:01 <mreh> > group [1..10]
17:42:02 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
17:42:43 <amckinley> heatsink: what do you mean, adding tokens?
17:43:25 <amckinley> mreh: http://www.zvon.org/other/haskell/Outputlist/groupBy_f.html
17:43:31 <amckinley> @type groupBy
17:43:32 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
17:43:34 <amckinley> there we go
17:43:42 <heatsink> amckinley, adding text between the position where the error is reported and the end of the file.
17:43:46 <Axman6> groupby is broken :(
17:44:08 <heatsink> amckinley, I'm using an Alex lexer, so the input to Parsec is a list of tokens.
17:44:24 <Axman6> > groupBy (<=) [1,2,3,2,3,3,2,1]
17:44:25 <lambdabot>   [[1,2,3,2,3,3,2,1]]
17:44:33 <byorgey> mreh: length . filter (==n) ?
17:44:36 <amckinley> Axman6: ouch :(
17:44:39 <Axman6> > groupBy (<=) [1,2,3,2,3,3,2,1,0,1,2,3]
17:44:40 <lambdabot>   [[1,2,3,2,3,3,2,1],[0,1,2,3]]
17:44:47 <mauke> Axman6: how is that broken?
17:45:00 <byorgey> it's not broken, it just has undefined behavior on things that aren't equivalence relations
17:45:02 <watermind> which of the 3 indentation modes do you use?
17:45:03 <mreh> >group . sort $ [1,2,3,2,3,3,2,1]
17:45:05 <Cale> Huh?
17:45:08 <mreh> > group . sort $ [1,2,3,2,3,3,2,1]
17:45:10 <lambdabot>   [[1,1],[2,2,2],[3,3,3]]
17:45:28 <Axman6> because it compares only the first element. i more often want it to compare adjacent elements
17:45:37 <Cale> byorgey: I think the report is maybe underzealous about what it says about the behaviour of groupBy for non-equivalence relations
17:45:39 <mreh> > zip [1..] . map length . group . sort $ [1,2,3,2,3,3,2,1]
17:45:41 <lambdabot>   [(1,2),(2,3),(3,3)]
17:45:45 <Cale> groupBy does a perfectly sensible thing
17:45:51 <byorgey> Cale: true.
17:45:59 <byorgey> but didn't the behavior just change recently?
17:46:03 <byorgey> IIRC
17:46:10 <Axman6> i've enver seen a use for the current groupBy
17:46:35 <Cale> Axman6: Breaking a list of hierarchical document levels into a tree
17:47:01 <Axman6> got a (psudo) example?
17:47:08 <Cale> Like, suppose you have a document with sections like [1,1.1,1.2,1.2.1,1.2.2,1.2.3,1.3,2,2.1,...]
17:47:52 <Axman6> hmm, fair enough
17:47:58 <Cale> you can groupBy the number of parts in the section number and it'll split the list up just right
17:48:03 <Axman6> still, i'd like to have the other groupBy there too :)
17:48:18 <Cale> and then separate up the head and tail of each of those, recursing on the tails
17:49:18 <maurer_> Does anyone know why when I map something, I wouldn't get a divide by zero error, but when I parMap rwhnf it, I do?
17:50:17 <gwern> maurer_: maybe you don't force the later entry which causes the div error when you're using map?
17:50:24 <monochrom> what is rwhnf in detail?
17:50:41 <gwern> monochrom: it's a strategy; reduce to weak head normal form
17:50:45 <maurer_> gwern: No, I printed it before
17:50:49 <Cale> rwhnf x = x `seq` ()
17:50:52 <Cale> iirc
17:51:08 <monochrom> Oh then it's more eager than map
17:51:14 <maurer_> gwern: My previous janky thing before I applied parMap was I was trying forcing it by printing it.
17:51:27 <gwern> maurer_: hm. that's kind of odd. you force the entire list and that didn't div by 0?
17:51:50 <maurer_> gwern: No. Unfortunately, the program as a whole is kinda complex so it's hard to isolate what's causing it.
17:52:35 <copumpkin> Cale: what was that fancy sequence you had with fix interleave or something?
17:53:28 <Saizan_> that was ski, iirc
17:53:37 <copumpkin> oh
17:53:45 <Cale> I had one too
17:54:00 <Cale> which was a different one from ski's :)
17:54:02 <maurer_> gwern: If you're actually interested in looking at it, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5225#a5225
17:54:03 <Cale> (I think)
17:54:04 <copumpkin> :t interleave
17:54:06 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
17:54:09 <copumpkin> :O
17:54:15 <copumpkin> > fix (interleave [0..])
17:54:16 <maurer_> gwern: Unfortunately, it is likely too complex to discern the source trivially.
17:54:17 <Cale> > fix (interleave [0..])
17:54:17 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
17:54:18 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
17:54:20 <Cale> yeah
17:54:21 <copumpkin> aha :)
17:54:34 <amckinley> Axman6: ouch :(
17:54:34 <copumpkin> is that from LogicT?
17:54:38 <Cale> yeah
17:54:41 <amckinley> Axman6: whoops, resend
17:54:45 <Cale> Handy thing. I should remember that it's there.
17:54:52 <Cale> I usually end up defining (/\/) by hand
17:55:08 <poe> ?oeis 0,0,1,0,2,1,3,0,4,2,5
17:55:10 <lambdabot>  a(2n) = n, a(2n+1) = a(n).
17:55:10 <lambdabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8,...
17:55:33 <poe> oh
17:58:49 <gwern> maurer_: yeah, I dunno
17:58:56 <amckinley> Axman6: how can i use the state monad with the IO monad? my code waits on STDIN for a complete "command" to come in, then updates the state based on the command, then goes back to waiting
17:59:07 <gwern> maurer_: I'm a little suspicious of rdeepseq and then parmapping seq, though
17:59:23 <maurer_> That was added afterwards
17:59:38 <amckinley> Axman6: but all the examples ive seen with the state monad bundle up all the state transitions in a single argument to runState
18:00:00 <byorgey> amckinley: use StateT s IO
18:00:06 <byorgey> where s is the type of your state
18:01:18 <Cale> yay, my contributions to that oeis entry were accepted :)
18:01:47 <amckinley> byorgey: does that mean i need to understand how monad state transformers work? :(
18:01:49 <poe> Indeed :)
18:01:50 <byorgey> amckinley: see http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
18:02:09 <Saizan_> maurer_: where is rdeepseq defined?
18:04:05 <byorgey> hmm, is MonadUndo on hackage?
18:05:30 <jbe> What does <<loop>> mean? (run-time output from my haskell program)
18:05:34 <visualbasicgui> Does anybody know why [String] isn't valid as a result type for regular expression matching with (=~)?
18:05:42 <mauke> jbe: you wrote an infinite loop
18:05:46 <byorgey> jbe: it means the runtime detected an infinite loop
18:05:53 <jbe> Wow, the runtime is smart.
18:06:03 <c_wraith> visualbasicgui:  I think it was changed to [(String, String)]
18:06:10 <maurer_> Saizan_: rdeepseq is in Control.Strategies.Parallel
18:06:23 <maurer_> Saizan_: It basically just says "force this"
18:06:26 <visualbasicgui> c_wraith: Hmm, thanks. I was using [[String]] but that's something else entirely.
18:06:38 <visualbasicgui> c_wraith: I'll experiment with [(String, String)]
18:06:49 <byorgey> jbe: mind you, it can't *always* detect infinite loops. (halting problem, yada yada... =)
18:06:49 <c_wraith> visualbasicgui:  I'm not certain of that.  Double-check everything :)
18:07:06 <visualbasicgui> c_wraith: rwh _needs_ to be edited like a master
18:07:14 <byorgey> jbe: it is able to detect it when you have defined something in terms of itself in an unproductively circular way
18:10:32 <jbe> Here I am, happy my code compiles, and the runtime is thumbing its nose at Turing.  Well it would be nice if it said "infinite loop detected" rather than "<<loop>>" because the latter is hard to google for.
18:11:40 <blackh> You'll just have to #haskell for it. :)
18:16:18 <amckinley> Axman6: so i need monad transformers because otherwise its impossible to do IO from inside the state monad
18:18:44 <copumpkin> amckinley: well, you can get all of state using regular IO
18:19:56 <amckinley> copumpkin: then im very confused... i can only call execState with a state monad, not anything that involves io..
18:20:25 <copumpkin> I mean, if you want to do IO from within a state monad, you might as well just convert your State stuff to IO
18:20:31 <Philonous> amckinley: I think it's the other way around. You can have state in IO, but you can generally not have IO anywhere but in IO
18:20:43 <copumpkin> since you can do everything state can do in IO and more
18:20:56 <amckinley> Philonous: thats what i meant to say :)
18:21:16 <byorgey> @remember jbe Here I am, happy my code compiles, and the runtime is thumbing its nose at Turing.
18:21:16 <lambdabot> I will never forget.
18:22:12 <byorgey> amckinley: if you are using StateT s IO  then you need execStateT, not execState
18:22:25 <amckinley> byorgey: right
18:23:49 <amckinley> byorgey: aha! http://www.haskell.org/haskellwiki/Simple_StateT_use
18:24:08 <byorgey> amckinley: ah, good, didn't know about that one =)
18:28:52 <Philonous> Would be great to have versions of the standard library functions already lifted into MonadIO
18:31:09 <mwc> Too bad Haskell'10 didn't do that
18:31:23 <mwc> putStrLn :: MonadIO m => String -> m ()
18:31:26 <mwc> too confusing?
18:35:00 <byorgey> hmm, to use that we'd also need some extra defaulting rules
18:39:40 <Saizan_> main would still be IO, and things that get callbacks too
18:39:50 <idnar> byorgey: why?
18:44:24 <tensorpudding> is yi still alive?
18:44:55 <Lemmih> tensorpudding: I sure hope so. It's the only editor I use.
18:46:03 <tensorpudding> hmm, is it good already?
18:46:45 <Lemmih> tensorpudding: No, but it sucks less than emacs/vim.
18:51:00 <tensorpudding> it appears that yi conflicts with data-accessor
18:51:18 <aavogt> @type LamE
18:51:19 <lambdabot> Not in scope: data constructor `LamE'
18:51:20 <Saizan_> tensorpudding: add --constraint="data-accessor < 0.2.1"
18:51:26 <aavogt> #ty LamE
18:51:30 <lunabot>  [] Pat -> Exp -> Exp
18:51:45 <tensorpudding> where do i add that?
18:51:48 <aavogt> Saizan_: why are there multiple patterns for LamE?
18:52:21 <aavogt> I find that I am writing: LamE [VarP x] (CaseE (VarE x) [ Match ... ]
18:52:36 <aavogt> where x is from  x <- newName "x"
18:53:13 <aavogt> is there a better way? I always have trouble with combining quasi quotes and the actual AST
18:53:36 <Kruppe> I'm trying to write a small haskell program that runs a shell command (suppresses its output), does stuff with the results of the shell command and then prints the results. Right now I'm playing around with HSH for this purpose, but I'm wondering how do I suppress the output of the original shell command?
18:56:36 <poe> Lemmih does it do ghc-api typecheck-on-the-fly things ? :)
18:57:19 <Lemmih> poe: They're working on scion support, I think.
18:59:37 <Philonous> Kruppe: You mean supress it's output to the terminal?
18:59:50 <Philonous> Kruppe: Maybe this helps:  http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html#v%3AreadProcess
19:00:32 <Kruppe> Philonous: I'll check it out, thanks. I think I may be going about it in the wrong way though.
19:01:18 <Philonous> Kruppe: Or you could use createProcess, than you can redirect standard-error as well (you could read it with hGetContents for example)
19:03:49 <Kruppe> Philonous: I'll take a look at that as well.
19:04:16 <poe> Yi has got lots of sources!
19:08:01 <Saizan_> aavogt: you mean why it takes a list of patterns? because that corresponds to \ x y z .. ->
19:08:32 <aavogt> ah, so I don't have to write it as   \x -> \y -> \z in the AST
19:08:39 <Saizan_> right
19:09:28 <aavogt> would you have any suggestions for style with this TH: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13478#a13478
19:10:23 <Saizan_> aavogt: let me try
19:10:49 <aavogt> there's lots of noise to specify what to do when there aren't enough (or too many) elements in the list
19:11:55 <aavogt> as an overview: data Foo a = Foo { x,y,z :: a};  $(mkFromList ''Foo) makes an expression  [a] -> Maybe (Foo a),  that only succeeds on lists of length 3
19:13:22 <aavogt> I was surprised that TH does typechecking, such that  data Foo a = Foo { x, y, z :: a, w :: String } works, and the impossible Foo { x,y::a , w::String, b :: Int } is rejected at compile time
19:13:36 <aavogt> err, that the type safety of TH is as good as it is
19:16:21 <aavogt> hmm, the (show fieldName) is better as (nameBase fieldName)
19:18:46 <Saizan_> aavogt: why are you crafting the variables so accurately? to make the generated code readable?
19:19:38 <aavogt> yeah, so I have some idea what's going on when I look at -ddump-splices
19:20:23 <Saizan_> well, without using some lib i think that's fairly good, but use 'Just and 'Nothing instead of mkName ..
19:21:35 <Saizan_> i was trying to use [| .. |] to write the lambda part but it gives errors about staging
19:21:37 <aavogt> what do you mean by without using some lib?
19:22:08 <Saizan_> aavogt: for example derive has a module that defined quite a lot of utility functions to deal with variables and applications
19:24:02 <aavogt> which one?
19:25:48 <Saizan_> http://hackage.haskell.org/packages/archive/derive/2.0.1/doc/html/Language-Haskell-TH-Helper.html
19:28:02 <aavogt> ah, I was looking only in the Derive. namespace.  Thanks!
19:28:58 <osaunders> Anyone used hscurses? I can't get it to actually output anything.
19:47:14 * hackagebot upload: Omega 0.2.1 - Operations on Presburger arithmetic formulae (ChristopherRodrigues)
20:00:39 <zong_sharo> i need to construct from untyped and unstructured tree (like json) some typed and structured tree
20:00:57 <copumpkin> make a bunch of constructors
20:01:07 <zong_sharo> data structure is big and complex, explicitly recuircive function is tedious and error prone
20:01:18 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13485#a13485 <- more details
20:01:51 <zong_sharo> i need some framework, for matching data in PrimTree
20:04:45 <zong_sharo> copumpkin: any advice?
20:05:02 <copumpkin> you could try working with some of the generic programming interfaces like syb
20:05:08 <copumpkin> but that might take longer to learn
20:05:26 <zong_sharo> how syb can help me?
20:05:51 <copumpkin> not really sure specifically, but it sounds like the kind of thing it's supposed to help with :)
20:06:30 <zong_sharo> why?
20:08:30 <Berengal> Isn't syb and friends more about recursing on heterogenous, structured trees, treating them as if they were unstructured, but tagged with names?
20:10:02 <osaunders> Anyone used hscurses? I can't get it to actually output anything.
20:10:36 <osaunders> Or move the cursor.
20:11:46 <aavogt> osaunders: what did you do?
20:12:17 <osaunders> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13486#a13486
20:12:36 <osaunders> And many other variants.
20:13:50 <jeff_s_> Hi haskellers, you guys helped me write this function a couple days ago. http://pastebin.com/df0465eb I'm using it in some other functions and I'm getting some problems. One thing I found is that calling it with the empty list gives me an error from (!!), but I want the empty list to make the function return Nothing.
20:14:20 <osaunders> I can get characters, it would seem.
20:15:53 <jeff_s_> I'm wondering if anyone knows why the empty list case doesn't seem to be followed?
20:16:19 <jeff_s_> I get the error when calling it in ghci with "newStdGen >>= (\g -> print $ evalState (chooseFrom []) g)"
20:16:23 <SamB_XP> jeff_s_: did you by some chance put the [] case second ?
20:16:40 <jeff_s_> nope, don't think that's the problem
20:17:10 <jeff_s_> I have its type, "chooseFrom []" on the 2nd line, and then "chooseFrom list" on the third line
20:17:55 <Saizan_> are you sure it's from that function? did you test it in isolation?
20:19:10 <osaunders> OMG!
20:19:14 <osaunders> It was endWin.
20:19:52 <osaunders> Awesome it works now xD
20:20:12 <osaunders> endWin closes it all down as if nothing ever happened, it would seem.
20:20:18 <osaunders> Also, you need refresh.
20:22:55 <jeff_s_> saizan_ yup, pretty sure
20:23:51 <jeff_s_> This is what I see: http://pastebin.com/d4ed3554d
20:27:23 <Saizan_> there has to be something funny going on, like you didn't save the file or it's loading some other version or you didn't reload it
20:29:01 <aeron> so if I have this function for recognizing lists,
20:29:02 <aeron> parseList :: Parser LispVal
20:29:03 <aeron> parseList = liftM List $ sepBy parseExpr spaces x
20:29:33 <jeff_s_> I saved the file :\
20:30:07 <jeff_s_> just reloaded ghci from scratch and did it again, no luck
20:30:12 <aeron> using Parsec (taken from Write Yourself a Scheme in 48 hours), and with a type LispVal which can be a string, list, atom, how can I recognize NIL as a list as well?
20:31:26 <aeron> the type signature in particular is what's confusing me
20:32:20 <Saizan_> jeff_s_: then i'd say you've found a bug in ghc
20:32:56 <Saizan_> but i can't believe such a big one is there.. which version of ghc are you using?
20:33:41 <Berengal> jeff_s_: What happens if you pattern match on list? As in, list@(_:_) instead of just list in the parameters
20:34:05 <jeff_s_> 1 sec
20:34:21 <jeff_s_> The Glorious Glasgow Haskell Compilation System, version 6.10.4
20:35:36 <jeff_s_> "*** Exception: experiment.hs:(14,0)-(17,51): Non-exhaustive patterns in function chooseFrom"
20:36:20 <Berengal> jeff_s_: Typo in the first case
20:36:24 <Berengal> choosefrom vs chooseFrom
20:36:42 <Saizan_> aaaah
20:36:46 <osaunders> Can one use loops in a do?
20:37:01 <Saizan_> d'oh, just realized that.
20:37:37 <Berengal> osaunders: What do you mean by loop? As in some built-in for or while?
20:38:13 <osaunders> Berengal: I want to say mvWAddStr stdScr 1 maxX "|" several times with from 1 to maxY
20:38:23 <Berengal> osaunders: replicateM_
20:38:24 <osaunders> *with i from
20:38:27 <Berengal> @type replicateM_
20:38:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
20:38:28 <Saizan_> or mapM
20:38:34 <Saizan_> ?type mapM_
20:38:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:38:54 <osaunders> What does the underscore signify?
20:38:55 <Saizan_> or, you can define your own custom recursive function
20:39:02 <Saizan_> that it discards the results
20:39:04 <Berengal> osaunders: That we don't care about the result, just the effects
20:39:11 <osaunders> OK.
20:39:43 <osaunders> Is that a universal convention or does underscore sometimes mean other things?
20:39:52 <Berengal> while :: (Monad m) => m Bool -> m a -> m a, or while :: (Monad m) => (a -> Bool) -> m a -> m a
20:40:00 <osaunders> Other than (x,_) = meh
20:40:08 <Berengal> I've only seen it mean "don't care"
20:40:21 <Berengal> Makes sense, since it's magical in patterns that way too
20:40:32 <osaunders> Yes.
20:40:34 <osaunders> OK, cool.
20:40:58 <Berengal> Oh, and there's also forM_
20:41:00 <Berengal> @type forM_
20:41:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
20:41:12 <osaunders> So you could have "OMG your mother just died" and the evil son says "_".
20:41:14 <Berengal> Which is the same as mapM_, but with arguments flipped
20:41:43 <Berengal> That sort of looks like it's crying though...
20:42:03 <osaunders> Yeah :-(
20:42:07 <osaunders> Oh well.
20:42:14 <Berengal> More like Â¬_Â¬
20:42:15 <osaunders> I'll try some of these functions, thanks.
20:42:20 <osaunders> Berengal: lol
20:42:28 <aeron> how do I use un-pointfree here?
20:42:36 <aavogt> @unpl (+)
20:42:36 <lambdabot> (+)
20:42:36 <Berengal> @unpl id
20:42:37 <lambdabot> (\ a -> a)
20:42:40 <aeron> thanks
20:43:17 <aeron> @unpl parseList = liftM List $ sepBy parseExpr spaces
20:43:18 <lambdabot> parseList = liftM List (sepBy parseExpr spaces)
20:44:15 <aavogt> I suppose that unpl (+) should technically be  (\x y -> x + y)... but that would probably be ugly, since @unpl seems to apply the same rules everywhere recursively
20:44:15 <Berengal> >_>
20:44:49 <Berengal> @unpl (\ x -> (x+))
20:44:50 <lambdabot> (\ x a -> x + a)
20:45:13 <idnar> @unpl (x+)
20:45:13 <lambdabot> (\ a -> x + a)
20:45:27 <aavogt> aeron: there are no arguments (well, other than token stream and parser state, but those are in the monad, not as arguments)
20:46:08 <aeron> aavogt: so I'm confused about what the type signature means: parseList :: Parser LispVal, where lispval is an alg. data type for string, list, bool, etc
20:46:38 <aavogt> so Parser hides the string being parsed
20:46:50 <Berengal> Yes, the string is implicit
20:47:12 <aavogt> and gives you access to the results of your parsing only temporarily (with do notation, or liftM)
20:47:36 <aeron> alright, so it does take a String parameter implicitly, and returns a LispVal? i know that's not technically correct but
20:47:47 <aavogt> eventually, you have to use some function to turn    Parser LispVal -> (String -> LispVal)
20:47:54 <aeron> alright
20:47:57 <jeff_s_> Berengal: thanks! Can't believe I didn't see that before. BTW why didn't ghci tell me that I had missed a case?
20:48:08 <aavogt> @type parse
20:48:09 <lambdabot> Not in scope: `parse'
20:48:16 <aavogt> @hoogle parse
20:48:16 <lambdabot> Text.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
20:48:16 <lambdabot> Text.ParserCombinators.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
20:48:16 <lambdabot> Network.URI parseAbsoluteURI :: String -> Maybe URI
20:48:19 <Berengal> jeff_s_: Because you didn't pass it -wall?
20:49:29 <aeron> aavogt: basically what I'm trying to do is be able to see "NIL" as either a bool or a list depending on context
20:49:45 <Berengal> aeron: Why not use a special Nil value?
20:50:21 <aavogt> aeron: you make multiple attempts to parse a given input, right?
20:51:15 <aeron> aavogt: yeah - I've got a parseExpression function that trys checking something as a symbol, string, number, quoted form, or a list
20:51:22 <aavogt> if the parseList parser fails, you can then try just to parse Nil as if it was a bool... or Nil can be an empty list too?
20:51:42 <aeron> in common lisp, nil represents both false and the empty list yes
20:51:50 <Berengal> And about a dozen other things...
20:51:57 <aeron> Berengal: like what?
20:52:05 <Berengal> Depends on context
20:52:20 <EvanCarroll> BONUS_: Marco!
20:52:40 <aeron> anyway, maybe I should make a new type for a list which can either be nil or a real list?
20:52:42 <Berengal> For example, it might mean null as in the SQL null in (:foo 1 :bar 2 :baz () :quux 4
20:52:43 <EvanCarroll> i think I found a pretty big typo in LYAH
20:52:44 <Berengal> )
20:52:48 <EvanCarroll> # tellCar :: (Show a) => Car String String a -> String
20:52:49 <lunabot>  luna: parse error on input `::'
20:52:56 <EvanCarroll> We'd have to force this function to take a Car type of (Show a) => Car String String a. You can see that the type signature is more complicated and the only benefit we'd actually get would be that we can use any type that's an instance of the Show typeclass as the type for c.
20:53:10 <Berengal> aeron: I'd split list into Nil and Cons, actually...
20:53:15 <EvanCarroll> shouldn't that read, `... an instance of the Show typeclass as the type for a`
20:53:50 <EvanCarroll> anyone confirm?
20:54:16 <EvanCarroll> maybe he means type c as in the typedef
20:54:31 <savanni> Hey, quick and very basic question:
20:54:31 <EvanCarroll>    1. data Car a b c = Car { company :: a
20:54:31 <EvanCarroll>    2.                      , model :: b
20:54:31 <EvanCarroll>    3.                      , year :: c
20:54:32 <EvanCarroll>    4.                      } deriving (Show)
20:55:04 <savanni> I know this is handled by the standard libraries, but how do I declare "instance Monad (Either String a) where" and have that line type check correctly?
20:55:12 <Berengal> EvanCarroll: I think there's some unfortunate alpha renaming going on there. Could be anything
20:55:28 <EvanCarroll> yea, I agree with the diagnosis
20:55:34 <Berengal> savanni: instance Monad (Either String) where
20:55:39 <aavogt> @kind Either
20:55:40 <lambdabot> * -> * -> *
20:55:44 <Berengal> @kind Monad
20:55:45 <aavogt> @kind Either String
20:55:46 <lambdabot> Class `Monad' used as a type
20:55:46 <lambdabot> * -> *
20:55:49 <aeron> Berengal: how would Cons map to the Haskell list? The current def for a LispVal list is "| List [LispVal]"
20:55:55 <EvanCarroll> he shouldn't not have referred the type as c, because the type in reference to the function signature that the passage was under has it as a
20:56:20 <osaunders> OK so this works. do { replicateM_ 3 (putStrLn "foo") } but I don't understand why I don't need a slash before putStrLn.
20:56:22 <jberryman> savanni: think of (Either String) as the 'm' in 'm a'
20:56:29 <savanni> Berengal: with that I get "All istance types must be of the form (T a1 ... an)", along with a suggestion to use -XFlexibleInstances
20:56:48 <Berengal> aeron: Well, Cons LispVal LispVal and Nil are isomorphic to haskell lists, but unlike haskell lists, lisp lists don't have to be nil-terminated, and are really just untyped pairs
20:57:00 <Berengal> isomorphic when nil-terminated*
20:57:24 <Berengal> aeron: For example, how would you represent "((1 . 2) . 3)"?
20:57:44 <aeron> Berengal: isn't that scheme?
20:57:55 <aeron> nevermind
20:57:57 <Berengal> savanni: add {-# LANGUAGE FlexibleInstances #-} to the top of your file
20:58:00 <aeron> I just haven't done enough with CL
20:58:12 <jeff_s_> berengal: thanks for your help!!
20:58:20 <Berengal> jeff_s_: :)
20:59:05 <savanni> Ah, okay, need flexible instances.  I'll go read up on that.  Thanks.
21:01:15 <BMeph> osaunders: "a slash"? :)
21:01:35 <osaunders> BMeph: (\putStrLn "foo")
21:02:15 <osaunders> Actually I think you can ignore that. It was a silly question.
21:02:21 <osaunders> The answer is Haskell is lazy-eval.
21:02:50 <jeff_s_> It's so strange, because instead of giving the (!!): Index too large error, when I ran my program it simply failed to halt. I think i'll just leave that question unanswered
21:02:54 <Berengal> osaunders: No, the answer is that evaluation /= execution
21:02:56 <jeff_s_> now it works
21:03:27 <jberryman> I'm having trouble understanding the difference between Control.Monad.State and Control.Monad.State.Strict... it seems that the strict version uses 'case' rather than 'let' but not sure what that means.
21:03:56 <osaunders> Berengal: :-s
21:03:57 <osaunders> What's the difference?
21:05:17 <Berengal> osaunders: When I ask you to evaluate "1 + 2", you answer "3". I could also ask you to execute "1 + 2", and you might answer "3", but since 1 + 2 = 3, what would you do if I asked you to execute "3"?
21:05:31 <Berengal> osaunders: Or perhaps that was just confusing...
21:06:09 <aavogt> > case undefined of _ -> 0
21:06:10 <lambdabot>   0
21:06:17 <Berengal> osaunders: Better example. When I ask you to evaluate 'putStrLn "Hello world!"', you reply "A program that prints Hello World.". When I ask you to execute it, you print "Hello world!"
21:06:24 <aavogt> > case undefined of x -> 0
21:06:25 <lambdabot>   0
21:06:47 <osaunders> Berengal: OK, got it.
21:07:10 <osaunders> :-D .... I understand!
21:07:19 <osaunders> Thanks Berengal
21:07:23 <Berengal> :)
21:11:21 <osaunders> Is there a style preference:
21:11:22 <osaunders> (\x -> x + 1)
21:11:25 <osaunders> or
21:11:28 <osaunders> (\ x -> x + 1)
21:11:40 <Berengal> I like \x -> x + 1
21:12:05 <Berengal> (But playing with agda lately has caused me to put whitespace everywhere)
21:15:11 <osaunders> @src sequence
21:15:11 <lambdabot> sequence []     = return []
21:15:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:15:12 <lambdabot> --OR
21:15:12 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:15:20 <idnar> I prefer \x too
21:35:40 <osaunders> This... (+1) 2 ...is called sectioning, right?
21:36:15 <osaunders> > (+1) 2
21:36:17 <lambdabot>   3
21:54:24 <sshc> part of Maybe Monad is "(Just x) >>= f = f x", but what sort of function should be f be?
21:54:56 <c_wraith> sshc:  look at the type of >>=
21:55:09 <c_wraith> @type (>>=)
21:55:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:55:53 <sshc> what's an example of one?
21:56:59 <Cale> sshc: depends on what the initial Maybe a was and how you want to continue
21:57:16 <Cale> sshc: Let's suppose you want to do three lookups in a row in some kind of table
21:57:31 <Cale> sshc: and each of the lookups might fail to find something and produce Nothing
21:57:34 <c_wraith> > Just 5 >>= \x -> Just (x + 5)
21:57:35 <lambdabot>   Just 10
21:57:44 <sshc> > let a x = Just $ x + 3 in return 3 >>= a
21:57:46 <lambdabot>   Just 6
21:57:51 <Cale> sshc: and you want the result of the whole computation, if any of the lookups fail, to be Nothing
21:58:09 <Cale> sshc: Oh, and each lookup depends on the result of the previous one
21:58:23 <Cale> So we have something like, perhaps:
21:58:33 <sshc> Cale: how would the Maybe Monad handle Nothings?
21:58:50 <Cale> sshc: If anything gives Nothing, the whole computation is Nothing
21:58:50 <c_wraith> > Nothing >>= \x -> Just (x + 5)
21:58:51 <lambdabot>   Nothing
21:59:38 <Cale> @let myTable = [(1,2),(2,4),(4,3),(3,7),(5,4)]
21:59:39 <lambdabot>  Defined.
21:59:53 <Cale> > lookup myTable 4
21:59:54 <lambdabot>   Ambiguous type variable `t' in the constraint:
21:59:54 <lambdabot>    `GHC.Num.Num t'
21:59:54 <lambdabot>      aris...
21:59:55 <Cale> er
21:59:57 <Cale> > lookup 4 myTable
21:59:59 <lambdabot>   Just 3
22:00:09 <Cale> > lookup 4 myTable >>= \k -> lookup k myTable
22:00:11 <lambdabot>   Just 7
22:00:29 <Cale> > lookup 4 myTable >>= \k -> lookup k myTable >>= \l -> lookup l myTable
22:00:30 <lambdabot>   Nothing
22:00:59 <Cale> > do k <- lookup 4 myTable; l <- lookup k myTable; lookup l myTable
22:01:00 <lambdabot>   Nothing
22:01:01 <sshc> Cale: could there be any different strategies for the Maybe Monad, or is it the only possible implementation?
22:01:04 <Cale> > do k <- lookup 1 myTable; l <- lookup k myTable; lookup l myTable
22:01:06 <lambdabot>   Just 3
22:01:21 <Niccus> it's the only one that seems to make sense
22:01:25 <Cale> sshc: I'm not sure there's another monad structure you could put on Maybe
22:01:59 <sshc> if there were an alternative strategy for the Maybe Monad, could they coexist?
22:02:18 <Cale> Only by newtyping Maybe
22:02:33 <Cale> (or more likely inventing a whole new type)
22:02:48 <Cale> I don't think there is one though.
22:02:50 <ivanm> yeah, newtyping Maybe is kinda useless
22:02:57 <Cale> Well, apart from the completely stupid one
22:03:10 <Cale> instance Monad Maybe where
22:03:14 <Cale>   return x = Nothing
22:03:19 <Cale>   x >>= f = Nothing
22:03:30 <ivanm> heh
22:03:34 <Cale> That satisfies the monad laws, but it's dumb
22:03:52 <dfrey> I have a list of elements and I want to compare every possible pair of elements to check if they satisfy a condition and then return "Just (e1, e2)" or Nothing depending on whether any pair satisfies the condition,  I know that there must be some sort of abstraction for that type of comparison, but I can't think of it.  Any hints?
22:04:08 <ivanm> Cale: well, you should specify fail _ = Nothing as well
22:04:19 <ivanm> dfrey: you have [a] ?
22:04:25 <sshc> Cale: this is a slightly unrelated question, but can newtype be used with the same syntax as data?
22:04:25 <ivanm> or [(a,a)] ?
22:04:33 <Cale> dfrey: list comprehensions and msum
22:04:40 <dfrey> my input is [a]
22:04:55 <Cale> > msum [Nothing, Nothing, Just 5, Nothing, Just 7]
22:04:57 <lambdabot>   Just 5
22:05:38 <ivanm> have to be careful though
22:05:42 <dfrey> Cale: So it just grabs the first one that isn't Nothing?
22:05:46 <sshc> Cale: well, thanks for your voluntary help.  I'm trying to understand how and why the standard monads work.
22:05:54 <Cale> > msum [guard (x^2 + y^2 == z^2) >> return (x,y,z) | x <- [1..20], y <- [1..20], z <- [1..20]]
22:05:55 <lambdabot>   No instance for (GHC.Show.Show (m (t, t, t)))
22:05:55 <lambdabot>    arising from a use of `M88...
22:05:58 <Cale> er...
22:06:08 <ivanm> heh
22:06:08 <Cale> > msum [guard (x^2 + y^2 == z^2) >> return (x,y,z) | x <- [1..20], y <- [1..20], z <- [1..20]] :: Maybe (Integer, Integer, Integer)
22:06:09 <lambdabot>   Just (3,4,5)
22:06:22 <ivanm> Cale: maybe even a listToMaybe, depending on how you write the comprehension?
22:06:25 <Cale> dfrey: you could also use listToMaybe
22:06:26 <Cale> yeah
22:06:27 <ivanm> Cale: that is, have the guard on the RHS
22:06:36 <Cale> :t listToMayeb
22:06:37 <lambdabot> Not in scope: `listToMayeb'
22:06:38 <Cale> :t listToMaybe
22:06:40 <lambdabot> forall a. [a] -> Maybe a
22:06:44 <Cale> > listToMaybe []
22:06:46 <lambdabot>   Nothing
22:06:50 <Cale> > listToMaybe [2,3]
22:06:51 <lambdabot>   Just 2
22:06:58 <ivanm> @src listToMaybe
22:06:59 <lambdabot> listToMaybe []        =  Nothing
22:06:59 <lambdabot> listToMaybe (a:_)     =  Just a
22:07:14 <ivanm> djinn would be able to work it out, if djinn knew about lists...
22:23:21 <kmc> type inference is a weird thing to do, from a logic perspective
22:23:34 <kmc> given the structure of a proof, what is the most general thing you can prove with that structure?
22:25:08 <Berengal> kmc: That's undecideable, depending on the logic.
22:25:10 <copumpkin> we have the answer! now what was the question? :P
22:26:31 <Berengal> What's funky is type inference in dependently typed languages infering values...
22:27:13 <copumpkin> well, you almost never get type inference in dependently typed languages
22:27:27 <Berengal> You get some
22:27:37 <Berengal> But it's not total
22:27:38 <copumpkin> the trivial stuff
22:28:24 <kmc> Berengal, right.  like unrestricted inference for GADTs for example
22:32:39 <Cale> kmc: It smacks of adjoint functors.
22:32:56 <Cale> (trying to determine the most general thing which a proof proves)
22:34:08 <mornfall> Free model!
22:34:18 <kmc> it is an accurate description of type inference, right?
22:34:25 <copumpkin> free beer
22:34:25 <Cale> yeah
22:35:39 <Cale> In the other direction, you probably have something like the simplest proof of a given statement.
22:36:12 <mornfall> Cale: Which may not be a functor though.
22:36:13 <Cale> (though in Haskell that doesn't give you anything too nice :)
22:36:19 <Cale> yeah
22:36:22 <copumpkin> free beer and forgetful distillation?
22:36:25 <Cale> Well...
22:36:32 * copumpkin stops trying to come up with something witty along those lines
22:36:41 <Cale> I'm sure that there's some kind of appropriate categories we can interpret this in :)
22:36:51 <mornfall> Cale: There always are... : - P
22:37:34 <mornfall> I should probably go to school.
22:37:42 <copumpkin> school is for losers
22:37:44 <copumpkin> stay on IRC
22:37:48 <Cale> heh
22:38:06 <savanni> Strangely, I wasn't interested in IRC until years after school.
22:39:29 <mornfall> copumpkin: Hush, or I'll reverse your arrows again. : - P
22:39:34 <copumpkin> :)
22:40:15 <mornfall> Wow, Bleadof!
22:40:56 <mornfall> (Bah, right, I'm out of there, lest I follow copumpkin's advice...)
22:43:07 <ivanm> @slap copumpkin
22:43:07 * lambdabot slaps copumpkin
22:43:39 <Cale> http://arxiv.org/abs/math.CT/0305049 -- if nothing else, this book has the most amazing diagrams ever :)
22:44:34 <copumpkin> > cut "ivanm"
22:44:36 <lambdabot>   ivanm: imma cut u up so bad u -- u -- u gon wish i no cut u up so bad
22:44:52 <ivanm> Cale: arxiv hosts books now?
22:44:53 <shambler> :)
22:44:54 <shambler> funny
22:45:41 <ivanm> not really...
22:46:15 <copumpkin> @cut ivanm
22:46:16 <lambdabot> Maybe you meant: bug ft let quit run
22:46:19 <copumpkin> http://www.youtube.com/watch?v=FU6OrcyUU0o
22:46:27 <ivanm> looks like my blog post about graphviz got onto proggit... not that anyone bothered to comment on it... >_>
22:46:33 <Cale> I swear that most of higher-dimensional category theory must have been arrived at by some guys sitting around in a room with a blackboard and saying "What if a drew a diagram like *THIS*!?" and drawing some insane scribble up on the blackboard, and then everyone tries to figure out how to turn it into meaningful mathematics.
22:46:47 <ivanm> heh
22:46:54 <ivanm> @remember Cale I swear that most of higher-dimensional category theory must have been arrived at by some guys sitting around in a room with a blackboard and saying "What if a drew a diagram like *THIS*!?" and drawing some insane scribble up on the blackboard, and then everyone tries to figure out how to turn it into meaningful mathematics.
22:46:55 <lambdabot> Okay.
22:46:57 <tensorpudding> did anyone know that sigfpe won an academy award?
22:47:08 <copumpkin> yep
22:47:14 <tensorpudding> i totally didn't know that
22:47:30 <Cale> If you don't believe me, look at the top of page 39
22:47:30 <ivanm> where?
22:47:49 <tensorpudding> pretty neat
22:48:04 <Cale> Where there is a diagram of a morphism in the *appropriately named!* swiss cheese multicategory
22:48:31 <Cale> http://arxiv.org/pdf/math/0305049v1 <-- in this pdf
22:49:15 <copumpkin> http://snapplr.com/p16e
22:49:33 <Cale> yes :)
22:49:39 <copumpkin> mmmenthal
22:49:48 <ivanm> ...
22:49:59 <copumpkin> ivanm is not amused
22:50:02 <copumpkin> (ever)
22:50:17 <copumpkin> Look at me. I can be not amused as well.
22:50:32 <copumpkin> There.
22:50:46 <dibblego> System.Process.readProcess claims to return the concatenation of stdout and stderr, but it is not true -- it returns stdout only
22:51:14 <ivanm> copumpkin: it's more of a "wtf" than an amusement situation IMHO
22:51:24 <ivanm> dibblego: if it fails, then it returns stderr
22:51:37 <copumpkin> ivanm: Oh, I see.
22:51:46 <dibblego> ivanm, my mistake, ta
22:52:37 <ivanm> dibblego: it's amazing what reading the source tells you...
22:52:38 <ivanm> ;-)
22:52:50 <dibblego> ivanm, the comment says it -- I'm just blind :)
22:52:58 <ivanm> heh
22:53:53 <copumpkin> OMG, it's the internet! http://snapplr.com/a869
22:54:00 <Berengal> It's amazing haskell source is readable
22:54:58 <Cale> tensorpudding: I did, from the intro to his talk on diagrams and commutative monads
22:55:10 <copumpkin> http://snapplr.com/5y65
22:55:24 * copumpkin feels like a kid with a picture book
22:55:27 <Niccus> look at me I'm a tree
22:55:36 <shambler> I see some string theory in there >_>
22:55:40 <Niccus> a graph of multiway trees
22:55:40 <ivanm> copumpkin: I thought it _was_ a picture book...
22:55:50 <Cale> shambler: Yeah, this stuff is actually related
22:56:20 <Cale> shambler: and to particle interaction diagrams as well :)
22:56:47 <osaunders> Found an error in LYAH. isUpperAlphanum = (`elem` ['A'..'Z']) should be isUpperAlpha
22:57:23 <Cale> @tell BONUS <osaunders> Found an error in LYAH. isUpperAlphanum = (`elem` ['A'..'Z']) should be isUpperAlpha
22:57:23 <lambdabot> Consider it noted.
22:57:39 <Cale> @flush
22:58:21 <osaunders> Awsome thnx.
22:59:10 * hackagebot upload: chalkboard 1.9.0.15 - Combinators for building and processing 2D images. (AndyGill)
22:59:38 <osaunders> There's no way to use self or this for recursion is there instead of repeating the name?
23:00:00 <Niccus> what do you mean
23:00:32 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
23:00:33 <lambdabot>   3628800
23:01:11 <osaunders> Niccus: Recursive functions repeat their own name in order to recurse.
23:01:22 <osaunders> So if you want to change the name later you have to change it in two places.
23:01:28 <osaunders> Even more with pattern match cases.
23:01:43 <Cale> osaunders: you can use fix like ^^ to define anonymous recursive functions
23:01:58 <Axman6> hmm, this still confuses me: http://stackoverflow.com/questions/1830005/inferred-type-appears-to-detect-an-infinite-loop-but-whats-really-happening
23:02:06 <osaunders> Cale: You still repeated fac
23:02:14 <Cale> osaunders: Indeed
23:02:23 <Berengal> > let fib = fix (\this n -> if n <= 1 then 1 else f (n - 1) + f (n - 2)) in fib 5
23:02:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:02:24 <lambdabot>    `SimpleReflect.FromExpr ...
23:02:31 <Cale> osaunders: But I could have named fac anything I wanted to
23:02:33 <Berengal> > let fib = fix (\this n -> if n <= 1 then 1 else this (n - 1) + this (n - 2)) in fib 5
23:02:34 <lambdabot>   8
23:02:36 <Berengal> There
23:03:02 <osaunders> :t fix
23:03:03 <lambdabot> forall a. (a -> a) -> a
23:03:21 <ksf> the occurs check "detecting infinite loops" is just a misnomer. it detects occurences of the left-hand symbol in the right-hand term.
23:04:11 <toast-opt> @src fix
23:04:11 <lambdabot> fix f = let x = f x in x
23:04:11 <ksf> ...anyway, that portion of the type system isn't turing complete, so the possibility of termination checking shouldn't come surprising.
23:04:30 <toast-opt> fix is a rather simple function :)
23:04:35 <toast-opt> it cheats tho, of course
23:04:44 <Axman6> ksf: was that directed at me?
23:04:52 <Berengal> "As a proof method, general recursion is wholly bogusâ€”its type, âˆ€Pâ‡’(Pâ†’P)â†’P is a blatant lie."
23:05:00 <ksf> Axman6, yes. or more or less, the internet.
23:05:32 <Axman6> heh
23:05:52 <Axman6> ksf: i don't see how it doesn't terminate though...
23:05:53 <toast-opt> berengal, a fellow haskelltonian coworker told me today that the thing called 'dependent typing' fixes this, but isn't turing complete
23:06:09 <ksf> Axman6, me neither.
23:06:21 <ksf> it's like saying a circular list doesn't terminate.
23:06:57 <Berengal> toast-opt: You can have dependent types with general recursion. See epigram. The dependent typing is orthogonal-ish to termination (but the typechecker likes strongly normalizing terms)
23:07:29 <copumpkin> Axman6: same way you can get anything out of a = a
23:07:50 <ksf> the typechecker doesn't care, but customers would most likely rather get shipped a non-terminating program than a non-compiling one.
23:07:56 <copumpkin> :t let f x = f x in f
23:07:58 <lambdabot> forall t t1. t -> t1
23:08:26 <Cale> Axman6: Imagine that the first line was changed to  mergesort [] = [7]
23:08:59 <Axman6> why can't it infer the types frm the second case?
23:09:06 <Cale> (suppose for simplicity that's the Integer 7)
23:09:08 <Berengal> ksf: Unlikely. It's much easier to sue for a non-compiling program than a non-terminating one. Much easier to fix in-house as well...
23:09:19 <Axman6> i mean, merge :: Ord a => [a] -> [a] -> [a]
23:09:28 <dons> ?yow
23:09:29 <lambdabot> Couldn't find fortune file
23:09:30 <copumpkin> Axman6: it did
23:09:31 <toast-opt> ksf, i'd rather order a package and get an empty box than one that, when opened, caused me to appear in the 'cube' movie cubes
23:09:36 <Cale> Axman6: When you merge two lists, you get a list of the same type
23:09:44 <Axman6> yes...
23:09:54 <Cale> Axman6: But there's nothing saying that the output list here has a type which is the same as the input list
23:09:59 <toast-opt> ... would have prefered empty box to box containing 'cube' movie, as well
23:10:07 <Axman6> Cale: why isn't there?
23:10:10 <Cale> Axman6: after all, we've applied mergesort already to both p and q
23:10:28 <Axman6> hmm
23:10:31 <Cale> So if mergesort returns a list of swiss cheeses, there's no problem.
23:10:57 <Cale> There's nothing in the definition which says that we have to be able to add an element of xs or p or q to that list
23:10:59 <copumpkin> Axman6: there's a big ravine between the input and output
23:11:11 <Cale> So what will happen is it will recurse forever.
23:11:27 <Axman6> >_<
23:11:36 <Axman6> the frunction works right?
23:11:55 <copumpkin> nope
23:12:22 <Cale> It only "works" for the empty list
23:12:22 <toast-opt> > let f x = f x in f
23:12:23 <Axman6> how does it not work?
23:12:26 <lambdabot>   mueval-core: Time limit exceeded
23:12:27 <copumpkin> try it
23:12:56 <Cale> Axman6: There's no way that an element of the input ever makes it to the output list
23:13:18 <copumpkin> if the function worked, you could put in [Int] and ask for [Bool] out of it
23:13:21 <Axman6> how come?
23:13:25 <Cale> because mergesort itself is applied to every list which contains a member of the input list
23:13:25 <Berengal> Axman6: Start out assuming mergesort has type a -> b, for generality. Look at the first case to refine that to [a] -> [b]
23:13:47 <Cale> (and there are no members of the original list being split off there)
23:14:00 <toast-opt> would be much more interesting to ask for [Flubber]
23:14:10 <toast-opt> then you could put it in your car, get off oil for good
23:14:43 <copumpkin> merge :: [c] -> [c] -> [c], merge (mergesort (p :: [a]) :: [b]) (mergesort (q :: [a]) :: [b]) :: [b]
23:14:49 <Berengal> Axman6: In the second case, you return merge (mergesort p, mergesort q). Merge has [c] -> [c] -> [c], p and q have type [a], so mergesort p and mergesort q have type [b], (because [a] -> [b] applied to [a] is type [b]). The result of mergesort is therefore [b], which unifies with the assumption that mergesort returs type [b]
23:15:24 <Axman6> i don't care about the types at the moment >_<
23:15:41 <Cale> Axman6: The types are the easiest way to understand what's deeply wrong with it
23:15:41 <copumpkin> Axman6: the type aren't disjoint from the functionality
23:16:11 <Axman6> ah, fixed it
23:16:37 <Axman6> just needs the case for [x]
23:17:09 <copumpkin> do you see why though?
23:17:22 <Cale> Right, which is where you transfer an element of the input to the output, and that's where the types get unified.
23:17:43 <Axman6> well, functionally, sure. and the fact it doesn't terminate explains the type. i was more curious why it didn't terminate :)
23:17:54 <Berengal> Heh
23:18:16 <copumpkin> then it's what Cale just said :)
23:18:34 <copumpkin> but it's neat that if you get an impossible type, you definitely have a bug in your program
23:18:44 <Berengal> Has anyone actually had a real bug caught by this mechanism though?
23:18:58 <Berengal> I can remember it happening once, but only once
23:19:07 <copumpkin> not me :)
23:19:26 <Cale> Well, from a value perspective,  mergesort [x] would have been  merge (mergesort p) (mergesort q) where (p,q) = split [x], which means that p = [x] and q = []
23:19:48 <Cale> and so mergesort p = mergesort [x], which is what we're trying to compute
23:20:23 <copumpkin> now for a related question
23:20:33 <copumpkin> under what conditions is GHC able to detect a loop and spit out <<loop>> ?
23:20:54 <Berengal> copumpkin: When you compile with -O2 (or at least -O1), and you enter a thunk you're already evaluating
23:20:54 <Cale> That's a really good question. It used to be able to do it far more consistently.
23:21:02 <osaunders> When you say :: a -> b does they mean they *have* to be different or just that they can be?
23:21:19 <copumpkin> osaunders: they can be
23:21:29 <osaunders> Great, thnx.
23:21:30 <copumpkin> osaunders: but because they can be, the function is impossible
23:21:49 <osaunders> impossible?
23:21:54 <copumpkin> yep
23:22:04 <Cale> :t const (error "foo")
23:22:06 <lambdabot> forall a b. b -> a
23:22:08 <zong_sharo> i neet to construct typed and structured tree from tree like data PrimTree = Alist [(String, PrimTree)] | List [PrimTree] | Str String | Nil
23:22:19 <copumpkin> osaunders: if I told you to write me a function that given a value of any type, should be able to produce a value of any other type
23:22:22 <copumpkin> osaunders: how would you do it?
23:22:27 <zong_sharo> data structure is big and complex, constructing tree manually is tedious and error prone.
23:22:40 <zong_sharo> maybe i'm i need some tree matching framework, like parsec, but for trees??
23:22:47 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13485#a13485 <- more details
23:22:53 <Cale> zong_sharo: maybe one of the generics libraries?
23:22:57 <zong_sharo> (code samples, etc)
23:22:58 <copumpkin> osaunders: if it's a -> a for example, you can give the caller back what he passed in (and then you're id)
23:22:59 <osaunders> copumpkin: someFn a = 10
23:23:12 <copumpkin> osaunders: nope, you need to be able to return any type (at your caller's discretion)
23:23:18 <Niccus> :t unsafeCoerce
23:23:19 <lambdabot> Not in scope: `unsafeCoerce'
23:23:20 <copumpkin> that would be a -> Int, which is valid
23:23:24 <copumpkin> but isn't a -> b
23:23:26 <zong_sharo> Cale: how?
23:23:58 <copumpkin> or rather (Num b) => a -> b
23:24:04 <copumpkin> which is very different from a -> b
23:24:18 <copumpkin> osaunders: make any sense?
23:24:44 <osaunders> copumpkin: So is :: a -> b a compile error?
23:24:47 <copumpkin> nope
23:25:02 <copumpkin> you can write the type, but the only way to write a function of that type is low-level hackery that breaks the type system
23:25:08 <toast-opt> > f :: a -> b
23:25:10 <lambdabot>   Could not deduce (GHC.Show.Show a, SimpleReflect.FromExpr b)
23:25:10 <lambdabot>    from the co...
23:25:22 <toast-opt> :t (f :: a -> b)
23:25:23 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
23:25:23 <lambdabot>       from the context ()
23:25:23 <lambdabot>       arising from a use of `f' at <interactive>:1:1
23:25:30 <Niccus> @hoogle a -> b
23:25:30 <toast-opt> maybe not, sry
23:25:30 <Cale> zong_sharo: http://community.haskell.org/~ndm/uniplate/
23:25:30 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:25:30 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
23:25:30 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
23:25:33 <copumpkin> osaunders: there really aren't very many functions fully polymorphic in their return value. Think of read
23:25:39 <copumpkin> > read "1" :: Int
23:25:40 <lambdabot>   1
23:25:43 <copumpkin> > read "1" :: Double
23:25:45 <lambdabot>   1.0
23:25:47 <osaunders> @scr read
23:25:48 <lambdabot> Maybe you meant: arr rc src
23:25:51 <copumpkin> (I, the caller, am telling it what type to return)
23:25:52 <osaunders> @src read
23:25:53 <lambdabot> read s = either error id (readEither s)
23:26:06 <osaunders> @t read
23:26:06 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:26:12 <copumpkin> :t read
23:26:13 <osaunders> :t read
23:26:14 <lambdabot> forall a. (Read a) => String -> a
23:26:15 <lambdabot> forall a. (Read a) => String -> a
23:26:22 <Cale> That is the source for the default implementation of read when you write an instance.
23:26:25 <copumpkin> also note that
23:26:29 <copumpkin> > read "1" -- is an error
23:26:31 <lambdabot>   * Exception: Prelude.read: no parse
23:26:33 <Cale> Really, it's implemented separately for every type
23:26:41 <copumpkin> > read "()"
23:26:43 <lambdabot>   ()
23:26:46 <copumpkin> (that's ugly)
23:26:54 <Cale> (extended default rules is on)
23:28:20 <Cale> zong_sharo: http://community.haskell.org/~ndm/downloads/paper-uniform_boilerplate_and_list_processing-30_sep_2007.pdf
23:28:26 * osaunders is thinking
23:28:30 <Cale> (in case you're not already looking at it)
23:29:37 <ivanm> osaunders: thinking? what's that? :p
23:32:23 <osaunders> ivanm: I do think!
23:32:49 <Veinor> imho when you write somehting like x ``f`` y instead of x `f` y
23:32:53 <copumpkin> anyone interested in network protocols here?
23:32:54 <Veinor> the compiler should say that you made a grave mistake
23:33:02 <Veinor> :D
23:33:03 <osaunders> copumpkin: Do you say it's impossible because it is in some profound theoretical way or just because Haskell doesn't provide a way to do it easily?
23:33:12 <copumpkin> osaunders: profound theoretical
23:33:34 <osaunders> Could you have a version of read that would take a.
23:33:44 <copumpkin> osaunders: if it were possible to write, you'd be able to say "if you give me a proof of X, I can use it to prove Y"
23:33:48 <Cale> osaunders: There is a function of type a -> b which doesn't terminate.
23:33:50 <osaunders> read 1 :: Int -- produces: 1
23:33:57 <osaunders> read "1" :: Int -- produces: 1
23:34:06 <copumpkin> "if cows are black, pigs can fly"
23:34:13 <Cale> (or produces an error, which is another kind of nontermination)
23:34:37 <Cale> osaunders: But consider that b might be a type for which there are no values
23:34:55 <Cale> osaunders: and yet our function still has to produce a result for every value of type a
23:35:05 <copumpkin> osaunders: one thing that might make it clearer is that in haskell all free type variables have an implicit forall in front of them. a -> b is actually forall a b. a -> b
23:35:08 <Cale> osaunders: So all that it could possibly do is to not terminate.
23:35:13 <kmc> :t let f x = f x in f
23:35:15 <lambdabot> forall t t1. t -> t1
23:35:20 <copumpkin> kmc: yeah, I wrote that earlier :P
23:35:36 <copumpkin> meaning, you need to write a single function that can take ANY type of input and from nothing but that, product ANY type of output
23:35:43 <copumpkin> *produce
23:35:48 <kmc> also "undefined" is a function of type a -> b
23:35:56 <kmc> :t undefined ()
23:35:58 <lambdabot> forall t. t
23:36:03 <copumpkin> :t undefined :: a -> b
23:36:03 <copumpkin> yep
23:36:05 <lambdabot> forall a b. a -> b
23:36:13 <toast-opt> i thought it was a value of 'a'
23:36:15 <toast-opt> :t undefined
23:36:17 <lambdabot> forall a. a
23:36:19 <copumpkin> it is
23:36:23 <copumpkin> but a can be anything
23:36:24 <copumpkin> including a -> b
23:36:29 <toast-opt> of course, a can = a' -> b
23:36:31 <kmc> "forall a b. a -> b" is a specialization of "forall a. a"
23:36:33 <copumpkin> so by writing undefined :: a -> b I'm restricting from a
23:36:47 <toast-opt> oh, gotcha :)
23:36:49 <ksf> you can always unsafeCoerce and output size_t bytes in hexadecimal.
23:36:49 <copumpkin> :)
23:37:04 <copumpkin> yeah, unsafeCoerce is cheating
23:37:13 <copumpkin> nontermination is more interesting as a source of a -> b
23:37:56 <copumpkin> tensorpudding: omg twitter
23:38:12 <Veinor> 'if you give me a proof of X, I will give you a proof of Y after infinitely much time'?
23:38:36 <Veinor> gives me a mental image of like a deadbeat theorem-prover
23:38:38 <osaunders> OK. Well I appreciate what everyone is saying. I think you guys may be jumping the gun by trying to explain this to me though. I don't know how to declare types yet.
23:38:39 <copumpkin> a.k.a. never
23:38:48 <Veinor> 'where's my proof man, where's my proof?' 'I'm good for it man, I swear!'
23:39:10 <toast-opt> osaunders, i'm with you there
23:39:21 <copumpkin> :)
23:39:31 <Cale> zong_sharo: does that library look like the sort of thing which might help?
23:39:42 <copumpkin> figuring out types for their own sake is probably one of the biggest and best steps you'll make in haskell learning
23:39:43 <osaunders> :: a -> b is impossible. Got it.
23:40:16 * osaunders goes back to LYAH
23:40:26 * copumpkin should set up a blog so he can get started on that long-overdue monad tutorial that I'm expected to write as a new haskeller
23:40:41 <copumpkin> hmm, I guess I changed subject there
23:41:06 <Veinor> heheh
23:41:14 <Veinor> writing a monad tutorial is a rite of passage, huh?
23:41:15 <Cale> copumpkin: Figure out how general 2-categories are important to Haskell programming and write about that.
23:41:31 <copumpkin> hm!
23:41:45 * Axman6 decided not to write a monad tutorial, and his first tutorial specifically avoids mentioning them
23:42:24 <copumpkin> Cale: in regular hask, a morphism between morphisms would be a function from a function to a function?
23:43:01 <Cale> Well, I suppose you could take it that way. The two functions should have the same type to begin with
23:43:31 <Cale> and it would have to agree in a particularly nice way with composition
23:44:11 <copumpkin> so they'd basically be (a -> b) -> (a -> b)
23:44:22 <Cale> So that if * is "vertical" composition of parallel arrows, and . is normal composition, then (a * b) . (c * d) should be the same as (a . c) * (b . d)
23:44:27 <copumpkin> yeah
23:44:50 <Cale> So (*) :: (a -> b) -> (a -> b) -> (a -> b)  (for some a and b)
23:45:00 <Cale> er
23:45:05 <copumpkin> that's a weird type :)
23:45:16 <Cale> well...
23:45:22 <Cale> actually it's weirder than that
23:45:26 <Axman6> osaunders: you around?
23:45:38 <Cale> We need each function (a -> b) to have its own type :)
23:45:48 <copumpkin> :O
23:45:55 <toast-opt> Cale, do you have a reference or description for what this '*' composition operator does?
23:45:55 <Cale> So that we can talk about which morphisms exist between any specific pair of them
23:46:01 <copumpkin> hm
23:46:06 <Cale> toast-opt: It might not exist.
23:46:23 <toast-opt> oh, ok :)
23:46:37 <copumpkin> toast-opt: as written, there are only two things it can do
23:46:43 <Cale> toast-opt: But I can tell you what to look at for general 2-categories
23:46:57 <toast-opt> i can't think of what x -> x -> x can do, where x is a -> b
23:47:03 <copumpkin> toast-opt: or four if you really stretch it
23:47:24 <copumpkin> toast-opt: only three things!
23:47:50 <Cale> Hask isn't really a 2-category in any way which is easy to see in the language
23:47:54 <copumpkin> moo :: x -> x -> x; moo a b = a or moo a b = b or moo a b = undefined
23:48:12 <copumpkin> Cale: damn, there goes my first blog post :(
23:48:16 <Cale> copumpkin: Basically, in a 2-category, the set of arrows between any pair of objects is itself a category
23:48:24 <ski> copumpkin : a morphism between morphisms is a morphism where the domain and codomain themselves are morphisms (*not* types of morphisms)
23:48:25 <copumpkin> oh ok
23:48:31 <Cale> copumpkin: But 2-categories might still be a useful concept
23:48:44 <Cale> copumpkin: The 2-category of categories is a good example
23:49:07 <copumpkin> so in the category of categories, morphisms are functors
23:49:15 <copumpkin> so morphisms between morphisms are NTs?
23:49:21 <Cale> In that category, we have categories which are our objects, and then functors which are our 1-cells, and then natural transformations, which are our 2-cells, yeah
23:49:35 <copumpkin> fair enough :)
23:49:52 <Cale> and in Haskell, we render natural transformations as polymorphic functions
23:50:04 <copumpkin> yeah
23:50:39 <copumpkin> seems simple enough
23:50:55 <Cale> There are some additional conditions usually imposed on how the compositions interact
23:50:56 * copumpkin defines a new concept: unnatural transformations, between natural transformations
23:51:26 <copumpkin> those are the kind that the ninja turtles and splinter underwent
23:52:17 <copumpkin> Cale: for what? 2-cats?
23:52:26 <Cale> yeah
23:53:04 <Cale> Heh, there's a 3-category of 2-categories, apparently. I haven't looked at the details.
23:53:46 <copumpkin> sounds like fun
23:54:08 <copumpkin> the only exposure I've had to n-categories is the cafÃ© ;) and the brief glance at operads a couple of weeks ago
23:54:57 <copumpkin> category theory looks really scary but once you start looking hard at it, it really isn't that complicated
23:54:58 <Cale> If you take a 2-category, and you restrict it to only have one 0-cell (object), then you get the concept of a monoidal category
23:55:00 <copumpkin> just extremely abstract
23:55:20 <Cale> Just like if you take a normal category and restrict it to have only one object, you get a monoid :)
23:55:24 <ski>   (*) :: forall (a :: cat2) (b :: cat2). forall (f :: a >-> b) (g :: a >-> b) (h :: a >-> b). (g >--> h) -> (f >--> g) -> (f >--> h)  -- vertical composition, roughly
23:55:32 <copumpkin> :o
23:55:40 <Cale> ski: yeah, that's better :)
23:55:49 <copumpkin> needs moar agda
23:56:24 <copumpkin> but yeah, I see
23:56:35 <ivanm> copumpkin: needs more correct spelling...
23:56:35 <ivanm> ;-)
23:56:35 <osaunders> Axman6: Hi
23:56:40 <copumpkin> ivanm: MOAR
23:57:08 <osaunders> Axman6: I took a quick look at that course you sent me the link to, btw.
23:57:39 <sohum> is there something equivalent to :t foo in foo bar ?
23:57:55 <copumpkin> sohum: how do you mean?
23:58:00 <sohum> like,
23:58:03 <sohum> :t (***)
23:58:05 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:58:16 <sohum> :t id *** id
23:58:18 <lambdabot> forall b b'. (b, b') -> (b, b')
23:58:20 <ivanm> @type let f = (+) 1 in f
23:58:21 <lambdabot> forall t. (Num t) => t -> t
23:58:35 <sohum> so I'd want :t (***) in id *** id
23:58:56 <Cale> That's a decent idea.
23:58:57 <ivanm> sohum: let
23:58:57 <ski>   (.) :: forall (a :: cat2) (b :: cat2) (c :: cat2). forall (f0 :: a >-> b) (f1 :: b >-> c) (g0 :: a >-> b) (g1 :: b >-> c). (f0 >--> g0) -> (f1 >--> g1) -> (f1 . f0 >--> g1 . g0)  -- horizontal composition
23:59:05 <ivanm> sohum: oh, I see what you mean
23:59:24 <ski> (where `cat2 :: Cat2')
23:59:26 <sohum> because sometimes the most general types aren't the easiest to understand
