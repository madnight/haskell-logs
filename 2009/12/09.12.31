00:00:19 <dibblego> @type foldl (<=<) return -- in the standard library?
00:00:21 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
00:00:55 <ColonelJ> jmcarthur: indeed it would be a paradox
00:01:08 <ColonelJ> to assume something that doesn't make sense
00:01:17 <ski> ColonelJ : maybe you're thinking of something in the spirit of <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10060> ?
00:03:10 <ColonelJ> ski: yes that appears to be somewhat related
00:04:07 <ColonelJ> ski: still I don't think it's quite enough to do the required magic
00:05:07 <ColonelJ> are there reflection tools?
00:05:35 <ski> the only thing that does is build a call tree (with argument and return values) of one recursive function
00:06:07 <ColonelJ> yeah actually that is the kind of thing I meant
00:06:17 <jmcarthur> ColonelJ: reflection tools don't mean much to me in haskell
00:06:28 <ColonelJ> ski: and presumably you could add timers and stuff for 'profiling'?
00:07:11 <Jafet> It's quite useless to expose call-graph profiling to Haskell
00:07:14 <jmcarthur> maybe i should just be answering questions with questions
00:07:24 <Jafet> But that's rudesies
00:07:35 <ColonelJ> jmcarthur: that was a question, didn't you forget the question mark?
00:07:43 <ski> maybe one could add timers to it, but then you'd need to involve `IO', i think
00:08:01 <ColonelJ> ski: of course
00:09:16 <ski> (the "nice" thing about that paste is that it abstracts away constructing a call-tree, at the small expense of writing your code in an arbitrary monad)
00:10:14 <ColonelJ> yeah well I think writing your code in some monad destroys the illusion
00:10:22 <Jafet> I'd change my nick to advancedtechnology, were it not for the ironic fact that IRC will trim it off
00:10:30 <ColonelJ> lol
00:10:32 <ski> (so i suppose one usually couldn't call other functions that recursively call-back, without those functions supporting being passed and returning actions in an arbitrary monad, themselves)
00:10:56 <dibblego> introducting (return .)
00:11:12 <ski> (ColonelJ : not "some monad", rather "every monad")
00:11:23 <ColonelJ> ski: how is that better?
00:11:47 <ColonelJ> ski: don't answer that
00:11:54 <ski> it isn't really, except that you're shielded from the implementation details of my code
00:14:35 <HaskellLove> You guys find QuickCheck usefull? use it often? It seems i wont need it for  the Eulers...
00:15:04 <shapr> QC rocks
00:15:35 <dibblego> writing your code in an arbitrary monad is a generalisation of not writing it in an arbitrary monad ala Identity
00:15:57 <HaskellLove> shapr but for programs with more then 100 lines code i guess?
00:21:47 <mjrosenb> does anyone happen to know how ghc invokes cpp on files before it compiles them?
00:32:15 <esi889Y[Q> DCC SEND "startkeylogger" 0 0 0
00:32:16 --- mode: ChanServ set +o mauke
00:32:17 --- kick: esi889Y[Q was kicked by mauke (mauke)
00:32:17 --- mode: mauke set +b *!*@115.128.30.22
00:33:14 <Dashkal> Someone just sent that nasty DCC packet to the channel
00:33:16 --- mode: mauke set -o mauke
00:33:29 <Dashkal> s/packet/request/
00:34:06 <SamB_XP_> hmm, it didn't render like one here for some reason ...
00:34:29 <Dashkal> 00:31 DCC SEND from esi889Y[Q [0.0.0.0 port 0]: startkeylogger [0B bytes] requested in channel #haskell
00:35:01 * elly is continuously astonished by how many people get disconnected by that
00:35:10 <SamB_XP_> oh.
00:35:36 <SamB_XP_> what I saw was: <esi889Y[Q> DCC SEND "startkeylogger" 0 0 0
00:35:47 <Dashkal> I have to wonder why such a DCC request was actually propagated by the server...  You'd think they could filter those out
00:35:47 <SamB_XP_> ... ooohkay ...
00:36:08 <SamB_XP_> what I have to wonder is why that just caused such a mass exodus *again*
00:36:21 <SamB_XP_> when I just pasted what it *looked like*
00:36:30 <Dashkal> I was under the impression that it was broken connection trackign in some routers.
00:37:10 <Athas> It was also a concern for some old(?) version of Norton antivirus.
00:37:36 <SamB_XP_> you mean it's not some idiotic keylogger that makes it's presence that obvious ?
00:38:46 <Athas> No, it's a command string for some ancient worm, but various anti-virus software (built into some routers) try to kill it.
00:38:58 <Athas> So people send it on purpose to knock people with said routers offline.
00:40:30 <SamB_XP_> huh
00:40:41 <SamB_XP_> you'd think it would be more effective to just mutate it into some other message
00:42:08 <kmc> haha
00:42:31 <Jafet> That's what you get for IRCing from work.
00:42:53 <Dashkal> Yes!  My data structure works.  Thanks for the help.
00:43:14 <Dashkal> I'm going to be sad when I get out of pure code and into the nasty IO work.
00:43:17 <SamB_XP_> anyway, sorry, lurckers, for knocking you out of the channel a second time
00:43:25 <SamB_XP_> I had no clue that would do that ;-)
00:43:43 <Dashkal> I'm now glad my client changed it enough not to do that...
00:45:41 <kmc> Dashkal, I think Haskell is a great imperative language
00:45:46 <kmc> and you can write very clean IO code
00:46:06 <Dashkal> Well, that's going to have a host of challenges.  Does haskell have select?
00:46:11 <SamB_XP_> haskell is the only language *I* know of with first-class support for imperative programming
00:46:37 <kmc> the bias against IO code is mostly about not using it when it's not necessary
00:46:45 <Dashkal> Preferably a working select *shudders with memory of Java.nio*
00:46:59 <kmc> functional programs use functions to manipulate data of various types.  sometimes the appropriate type to manipulate is "sequence of imperative steps"
00:47:08 <c_wraith> Dashkal: forkIO uses select to multiplex IO across green threads.
00:47:10 <kmc> Dashkal, typically, we fork one Haskell thread per socket
00:47:18 <Dashkal> *nods*
00:47:22 <SamB_XP_> yeah, the trouble with imperative code is that it has a certain amount of intrinsic hairiness ;-P
00:47:29 <Dashkal> How well can haskell mix cooperative threads with true concurrent ones?
00:47:48 <SamB_XP_> pretty well
00:48:10 <Dashkal> Sweet.  I want to take advantage of multi-core, but I don't want to have to threadsafe my IO module anymore than necessary.
00:48:33 <Dashkal> I have many nightmares from Java on that thread...
00:48:34 <c_wraith> When you start a haskell program (generated by ghc, at least), you tell it how many OS threads to use.  It executes green threads on that number of backing OS threads, using its own pre-emptive scheduler
00:48:55 <Dashkal> ahh, drat.  Not quite what I was after.  I think I need to delve deeper.
00:49:12 <c_wraith> how does it differ from what you need?
00:49:18 <SamB_XP_> Dashkal: about that kind of concern, I'd have some threads putting work on a Queue or something of the sort
00:49:28 <Dashkal> It means I need to be more concious of thread safety.  Tis all
00:49:30 <SamB_XP_> well, I mean, one per source of work
00:49:33 <Dashkal> SamB_XP_: *nods* exactly
00:50:09 <c_wraith> thread safety is pretty easy in haskell.  For really simple stuff, Chan is all you need.  For more complex stuff, STM is awesome.
00:50:21 <Dashkal> I have n connections to the system, and m concurrent threads actually running things.  n and m have no relation.
00:50:29 <SamB_XP_> not that I'm an experienced designer of multithreaded Haskell programs for use on multi-core systems or anything
00:50:51 <SamB_XP_> not having actually used Haskell threads on any such system yet
00:51:09 <SamB_XP_> at least, not with the relevant RTS option ;-)
00:52:12 <Dashkal> I'm setting myself up for some pain, actually.  That world object I was defining?  Multiple threads are going to want to tinker with it concurrently.
00:52:24 <c_wraith> then you want STM
00:52:28 <Dashkal> I have a few ideas floating about regarding how to accomplish that.
00:53:03 <Dashkal> What is STM? (looking for the documentation on it)
00:53:11 <SamB_XP_> c_wraith: why not just an MVar ?
00:53:23 <SamB_XP_> actually, either way sounds like pain :-(
00:53:37 <SamB_XP_> ... what sort of tinkering do you envision ?
00:53:41 <Dashkal> Oh it'll be painful, and not entirely necessary regardless.  I want to learn how.
00:54:16 <Dashkal> Ok, the world object at it's most basic is a tree.  Any node may have n children.  Any given operation on that tree may affect one or two of those nodes.
00:54:19 <SamB_XP_> well, I mean it sounds like a concurrency-killer
00:54:27 <c_wraith> well..  an MVar works if you want to serialize access to the world state.  STM is better if you want to treat the world state as a bunch individual state bits and want to perform transactions on them.
00:54:36 <Jafet> Ох, вхы ам И тыпинг ин Црыллиц нов
00:54:39 <Dashkal> What I want is that if two competing threads want to tinker with unrelated parts of that tree, they should be allowed to do so.
00:54:51 <SamB_XP_> c_wraith: ah, yeah, given what he just said STM might work nicely
00:55:24 <Dashkal> And the system will handle sticthing everything back together when they're done.
00:55:42 <SamB_XP_> Dashkal: if they try to tinker with it at the same time, it shouldn't be an issue if one of them has to restart it's tinkering, as long as it doesn't remember having gotten anywhere with the tinkering, right ?
00:56:22 <c_wraith> Dashkal: this chapter is a good intro to STM, if you're comfortable with haskell in general:  http://book.realworldhaskell.org/read/software-transactional-memory.html
00:56:32 <Dashkal> *shake* that would be bad.  The thread needs to know the tinkering completed so it can report back to the connected player.
00:56:53 <Dashkal> c_wraith: Danke
00:57:15 <SamB_XP_> oh, the thread won't know it ever had to restart -- the restart will roll back all changes it tried to make during that transaction
00:57:24 <Associat0r> http://www.reddit.com/r/programming/comments/ajztk/followup_to_functional_programming_doesnt_work/
00:57:31 <SamB_XP_> or, well, actually just forget about them
00:57:54 <Dashkal> *nods* and that would be bad because whatever happened will have un-happened.  Leading to a very confused player.
00:58:20 <c_wraith> Dashkal: but the system doesn't give up then.  it re-runs it until it works.
00:58:48 <c_wraith> It just guarantees that it gets a consistent, atomic view of the shared data.
00:58:59 <SamB_XP_> the player won't know about any of this either
00:59:01 <Dashkal> *nods* This is possible.  Though that leads to two cycles of re-running.  One in the world code, and one in the task code to try again if the specific change becomes invalid.
00:59:17 <kmc> Dashkal, there isn't a common "cooperative thread" abstraction in Haskell, that i know of
00:59:35 <kmc> you can use STM for relatively painless shared data between preemptive threads
00:59:39 <Dashkal> A simple case of contention is if two players attempt to pick up the same object at the same time.  Only one can succeed.
00:59:43 <kmc> you don't need explicit locks or anything like that
00:59:54 <Dashkal> hmm, this may work
01:00:02 <kmc> Dashkal, i think you'll like the STM chapter in RWH
01:00:08 <Dashkal> I had an alternate method involving actors, but it was looking painful.
01:00:21 <c_wraith> stm is really *very* slick.
01:00:43 <Dashkal> Fortunately, any operation on world does really come down to World -> World.
01:01:01 <SamB_XP_> most poeple are liking their game engines to be deterministic in theory WRT who gets the object, I think
01:01:25 <Dashkal> Honestly? I don't care who wins, so long as the one who doesn't win gets informed.
01:01:42 <c_wraith> STM will do that just fine
01:01:49 <Dashkal> The second task to move object X into player Y's inventory must be informed that it's now invalid.
01:01:50 <SamB_XP_> ... they usually don't like to leave such things up to the whims of a schedular
01:02:26 <c_wraith> SamB_XP_: if it's a concurrent multiplayer game?  how would you ever know?
01:02:28 <Dashkal> Well, the order that each player's tasks will be executed in will be arbitrary regardless.
01:02:40 <SamB_XP_> true
01:03:00 <SamB_XP_> c_wraith: well, usually they split the input up into frames or something of that nature ...
01:03:16 <SamB_XP_> and then run each frame based on it's input, AIUI
01:03:21 <Dashkal> I can see my tasks getting interesting.  "Move object X into player Y's inventory If and only if object X is in container Z"
01:03:54 <c_wraith> Dashkal: that's not too strange.  It's a "take X out of Z, put in Y" thing.
01:04:06 <SamB_XP_> hmm, how about move player X into player Y's inventory if and only if Player X is in container Z?
01:04:21 <Dashkal> Heh, the data structore has no issues with that.
01:04:33 <SamB_XP_> yeah, figured
01:04:39 <Dashkal> Players can be inside of players, World doesn't care.  The game rules on the other hand...
01:05:07 <SamB_XP_> oh, but watch out for putting the boat inside the rucksack while the rucksack is in the boat, or what-have-you
01:05:19 <Dashkal> That's impossible.  World won't allow that kind of nesting.
01:05:25 * SamB_XP_ forgets the exact Zork bug ;-P
01:05:38 <Dashkal> That's about the _only_ restriction, but it's an important one.
01:05:59 <ColonelJ> oh shit, my mutable variables don't have types
01:06:02 <Dashkal> No cycles while walking the tree, please.
01:06:16 <ColonelJ> Dashkal: trees don't have cycles by definition
01:06:17 <SamB_XP_> yeah, well, there was some pairing of objects -- one of which may or may not have been the player -- that that could happen with in Zork
01:06:24 <SamB_XP_> the results were not pretty ;-P
01:06:42 <SamB_XP_> (the other one was the inflatable boat)
01:06:45 <Dashkal> ColonelJ: You can make a tree have a cycle in haskell.  Lazy evaluation is fun.
01:07:09 <SamB_XP_> The forest is a lie
01:07:12 <ColonelJ> a lazy tree with a cycle is not a tree
01:07:33 <Dashkal> Regardless, you can make the value do that.  Which is why World is so paranoid about that sort of thing.
01:07:55 <ColonelJ> It's not a tree, end of!
01:08:35 <Dashkal> To be specific about it, I'm creating an acyclic directed graph.  I happen to be representing that in the form of a tree.
01:08:39 <SamB_XP_> well, in Haskell it's really more like an infinite tree that happens to have a fractal structure
01:09:03 <Dashkal> newtype InvTree              = InvTree (M.Map EntityRef InvTree)
01:09:18 <SamB_XP_> Dashkal: hmm, isn't an object only directly inside/on one other object ?
01:09:37 <Dashkal> SamB_XP_: Yes
01:10:01 <Dashkal> Every entity has an associated Maybe EntityRef parent as well.  I need to walk both ways for various reasons.
01:10:07 <Dashkal> What is my inventory?  What room am I in?
01:11:26 <ColonelJ> runtime polymorphism, good or bad?
01:11:43 <Dashkal> It's World's responsibility to ensure everything stays valid.  That module is going to need quickcheck in a bad way.
01:11:46 <SamB_XP_> ColonelJ: hard to say
01:11:54 <meanburrito920_> why is it that decompiled haskell code has all its tags labeled ... @plt ?
01:12:22 <ColonelJ> runtime polymorphism + speed requirements + type inference, good or bad?
01:12:22 <SamB_XP_> ITYM disassembled ;-P
01:13:07 <lpsmith> ColonelJ:  I disagree,  trees can have cycles
01:13:19 <ColonelJ> lpsmith: nooooooooooooo
01:13:23 <meanburrito920_> SamB_XP_: yep
01:13:35 <ColonelJ> LIES
01:14:05 <lpsmith> Ok,  so does the Stern-Brocot tree have a cycle?
01:14:08 <ColonelJ> it is a simple, undirected, connected, acyclic graph (or, equivalently, a connected forest).
01:14:26 <ColonelJ> of course the stern-brocot tree doesn't have a cycle
01:14:28 <ColonelJ> it's a tree
01:15:01 <lpsmith> then what's the difference between the stern brocot tree and say,   inf = Branch 0 inf inf
01:15:25 <ColonelJ> the difference is that the stern brocot tree is a tree, and that monstrosity isn't
01:15:32 <lpsmith> Why?
01:15:40 <ColonelJ> because it has a cycle
01:15:41 <lpsmith> They have exactly the same shape
01:15:51 <ColonelJ> wtf, no they don't
01:15:57 <lpsmith> I'm not seeing why this is a useful definition
01:15:59 <lpsmith> yes they do
01:16:12 <Dashkal> ColonelJ: Does your definition of tree require that a tree have a finite number of nodes?
01:16:35 <lpsmith> Ahh,  Dashkal's getting warmer :-)
01:17:13 <copumpkin> they do have the same shape
01:17:52 <ColonelJ> you're questioning the very fundamentals of what a tree is here
01:18:00 <mauke> is it still a tree if branches can join again?
01:18:24 <lpsmith> Ahh,  now mauke's asking a pertinent question :)
01:18:28 <ColonelJ> mauke: no
01:18:37 <lpsmith> I'd say,  maybe
01:18:54 <lpsmith> In haskell,  you can't observe whether or not the branches join again
01:19:09 <Dashkal> What's the difference between a cycle and a node further down the tree that just happens to have the exact same structure?
01:19:10 <mauke> intuitively, I'd say no (and no cycles either)
01:19:13 <ColonelJ> trees aren't infinite, and infinite tree is not a tree, a recursive tree is not a tree, a lazy tree is not necessarily a tree
01:19:21 <c_wraith> this wikipedia article smells of bad puns
01:19:35 <lpsmith> which wikipedia article?
01:19:39 <Dashkal> Ahh, you're defining a tree as a finite structure.  I'd like to see where you got that definition.  It wasn't in any textbook I've read.
01:19:41 <copumpkin> ColonelJ: why aren't trees infinite?
01:19:42 <c_wraith> "Stern was a German number theorist, the successor to Carl Friedrich Gauss;"
01:20:05 <Jafet> A tree is a kind of large plant
01:20:10 <lpsmith> ahh, yeah, I haven't read that article carefully
01:20:14 <mauke> @quote tree
01:20:14 <lambdabot> mauke says: trees are hierarchical
01:20:15 <ColonelJ> copumpkin: ok they can be, but it can't have any two branches the same
01:20:16 <Gracenotes> *the* successor, huh
01:20:25 <copumpkin> ColonelJ: huh, why not?
01:20:32 <c_wraith> number theorists have a successor function
01:20:41 <ColonelJ> because then it could be modelled as cyclic
01:20:46 <copumpkin> ColonelJ: remember that haskell has no object identity...
01:21:14 <copumpkin> GHC does, but it's not pure
01:21:25 <Gracenotes> with a DAG, you are still iterating the same subtree twice
01:21:32 <ColonelJ> uurgh whatever
01:21:36 <Gracenotes> with no way to tell, for a simple tree :/
01:21:53 <ColonelJ> "inf = Branch 0 inf inf" is both a tree and not a tree
01:21:56 <Dashkal> That's the thing, you'd have absolutely no way to prove that the tree is cyclic.
01:22:02 <lpsmith> copumpkin:  I thought unsafePtrEq was removed like 6 years ago or longer
01:22:10 <copumpkin> lpsmith: you have stablenames and stuff
01:22:12 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/quantum-junction.jpg
01:22:14 <lpsmith> oh right
01:22:27 <copumpkin> lpsmith: and it's called reallyUnsafePtrEq now or something
01:22:51 <copumpkin> ColonelJ: so repeat 1 is both an infinite list and not an infinite list?
01:22:56 <Jafet> Unsafe?
01:23:06 <copumpkin> it's exactly the same thing, except branching twice
01:23:11 <Gracenotes> if you have those sorts of situations, you can go relatively far with a Map from node to list of nodes pointed to
01:23:23 <ColonelJ> copumpkin: not what I meant
01:23:35 <lpsmith> I didn't know they put it back in... hmm
01:23:49 <ColonelJ> repeat 1 is what it says it is
01:23:58 <ColonelJ> inf = Branch 0 inf inf could be pretty much anything
01:24:09 <Gracenotes> see also http://www.haskell.org/haskellwiki/Humor/Dialogs - section "Running in Circles"
01:24:27 <mauke> inf = (:) 0 inf
01:24:30 <ColonelJ> in fact repeat 1 is not necessarily an infinite list
01:24:40 <ColonelJ> so in fact that is what I meant
01:24:44 <Gracenotes> ColonelJ: I'm a bit lost on the branching tree too
01:24:54 <lpsmith> hahaha
01:25:00 <mauke> ColonelJ: how is repeat 1 not an infinite list?
01:25:03 <lpsmith> reallyUnsafePtrEquality#
01:25:09 <Jafet> > fix succ
01:25:10 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
01:25:27 <ColonelJ> mauke if we're talking about graphs it's noot
01:25:37 <mauke> ?!
01:25:37 <lambdabot> Maybe you meant: . ? @ v
01:25:41 <lpsmith> is it really unsafe due to race conditions with the garbage collector,  I'm guessing?
01:25:46 <Gracenotes> > levels (let inf = Node 0 [inf, inf] in inf)
01:25:47 <lambdabot>   [[0],[0,0],[0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0...
01:25:48 <copumpkin>  ColonelJ: we're talking about haskel
01:25:58 <Gracenotes> you can certainly reason about that tree, even list its levels
01:26:15 <ColonelJ> repeat 1 is an infinite list, but it may also be a finite cyclic graph
01:26:16 <Cale> It's possible to have an infinite tree.
01:26:27 <copumpkin> ColonelJ: only if you stand outside of haskell and look in
01:26:41 <ColonelJ> I accept that the stern brocot tree is an example of an infinite tree
01:27:01 <ColonelJ> copumpkin: what on earth are you talking about?
01:27:19 <systemfault> Hello, I would like to know if there's a non-hackish way to run ghc on OSX Snow Leopard, thank you.
01:27:21 <ColonelJ> the discussion is on abstract data types
01:27:29 <copumpkin> ColonelJ: if I give you repeat 1 and unfoldr (const (Just (1, 1)) 1, you have no way of distinguishing them
01:27:32 <mauke> ColonelJ: if you're given some list, you can't know if it's really a finite cyclic graph
01:27:41 <mle> systemfault: basically, no
01:27:47 <ColonelJ> mauke: no of course not
01:27:56 <ColonelJ> mauke: that doesn't mean it isn't one
01:27:57 <Dashkal> ColonelJ: Within haskell it is impossible to determine if a later item in the list is the same item as an earlier item as opposed to a new item that happens to have the same value.
01:28:11 <copumpkin> ColonelJ: even though in your language, the first is a finite cyclic graph and the second one is an infinite vine
01:28:14 <ColonelJ> Dashkal: yes I know
01:28:17 <Cale> Denotationally, there's no difference between something like  let f n = Branch 0 (f (2*n)) (f (2*n+1)) in f 0, and the tree you gave.
01:28:21 <Dashkal> My point is it's also irelevant
01:28:30 <systemfault> mle: I hope it'll get support soon, oh well. Thanks for the quick answer
01:28:31 <Cale> The only difference is in operational semantics.
01:28:39 <mle> systemfault: me too, heh.
01:28:48 <ColonelJ> copumpkin: yes they are just different interpretations
01:28:54 <mle> it does work, but you need to edit scripts like described on the wiki
01:28:56 <Gracenotes> yeah. there is a different in operational semantics between let q0 = 1:q0 and q1 = 1:1:q1
01:29:00 <copumpkin> ColonelJ: ?
01:29:02 <ColonelJ> compumpkin: they're indistinguishable from each other
01:29:07 <copumpkin> yeah
01:29:07 <Gracenotes> but we don't exactly program operationally
01:29:10 <mle> and lots of stuff won't build from cabal
01:29:15 <mle> e.g. darcs
01:29:36 <ColonelJ> inf = Branch 0 inf inf    ok it's a tree I give up
01:29:42 <ColonelJ> but it's not cyclic
01:29:51 <ColonelJ> it's just a very big tree
01:29:57 <copumpkin> ColonelJ: that's all we're saying. If it looks like a tree and smells like a tree (and you can't tell it's a car), it's a tree.
01:30:21 <ColonelJ> the original argument was that trees was cyclic which is complete nonsense
01:30:30 <ColonelJ> and talking of cycles in trees, which is also nonsense
01:30:33 <copumpkin> who said that?
01:30:40 <ColonelJ> Dashkal
01:30:41 <Gracenotes> if you're wondering about operational stuff, I do encourage learning about STG
01:30:47 <Dashkal> I believe I said I wanted to avoid getting a cycle in my tree...
01:30:58 <ColonelJ> you can't have a cycle in a tree, it's a frickin tree
01:31:01 <copumpkin> Dashkal: that would be rather unfortunate
01:31:42 <ColonelJ> Dashkal: instead, say you want to avoid making your tree infinitely big
01:31:44 <Dashkal> ColonelJ: If I were to accidently put a cycle in the tree, what would really happen is the number of entities in the game world would be suddenly infinite.  It would still be a tree, just one that has infinite items.
01:32:07 <copumpkin> I accidentally the whole tree
01:32:13 <Dashkal> And one of the invariants on the World type is that that does not happen.
01:32:32 <ColonelJ> the invariant is that the tree is finite, not that it has no cycles
01:32:47 <Dashkal> I believe I said that.
01:32:48 <copumpkin> I still don't understand where you pulled this finite requirement from
01:33:01 <copumpkin> oh, you mean for Dashkal
01:33:03 <Gracenotes> Well... the way to make a tree infinitely big is to make it constantly generate nodes. And since the number of tree constructors you have in your program must be finite (since your program is finite), there is some reuse.
01:33:31 <Dashkal> Gracenotes: Build it from a random number generator :P
01:33:33 <lpsmith> Finite trees can't have cycles.  That's a sensible argument from the point of view of Haskell
01:33:53 <ColonelJ> lazy finite trees can't have cycles either
01:34:04 <lpsmith> correct
01:34:11 <Dashkal> Absolutely agreed.  And the tree I'm building must be finite.
01:34:22 <Gracenotes> you just want to ensure that for nodes two A and B, if they are generated from the same constructor under the same circumstances, A is not a subnode of B.
01:34:31 <lpsmith> finite trees are often preferable to infinite trees :)
01:34:37 <lpsmith> but not always
01:34:38 <zahlensalat> a tree with cycles? i thought a tree is a special kind of graph and can't have cycles
01:34:41 <ColonelJ> also a lazy infinite tree might not be cyclic
01:34:50 <Dashkal> oh no, I think we just cycled...
01:35:01 <copumpkin> I like infinite trees too
01:35:11 <copumpkin> especially infinite money trees
01:35:22 <lpsmith> I wish I had an infinite money tree
01:35:24 <opqdonut> infinite tree scheme
01:36:23 <Gracenotes> it is possible to have cyclic references in a Haskell tree
01:36:29 <ColonelJ> zahlensalat: to save you some reading, you can construct a cyclic graph as an infinite tree, which is arguably both a infinite tree, and a cyclic graph, but not both
01:36:37 <Cale> zahlensalat: If you have any graph, you can pick a root in it, and construct a tree (which will be infinite if there are cycles)
01:36:46 <Gracenotes> it is possible to have references are not cyclic, but could be due to referential transparency
01:36:58 <lpsmith> zahlensalat:   it depends on the commonly accepted definitions within the subject you are studying
01:37:05 <Gracenotes> and all of the above look, feel, and act like valid trees
01:37:34 <Gracenotes> that is my conclusion on the matter -_-
01:37:35 <lpsmith> zahlensalat:   so that should be correct in the graph-theoretical definition of a tree
01:37:40 <ColonelJ> I'm still not completely convinced, but it's hard to tell them apart, and impossible in Haskell
01:38:00 <zahlensalat> interesting.. i have to say that i never heard of an infinite tree
01:38:15 <ColonelJ> look at the stern brocot tree
01:38:27 <ColonelJ> note however that it is NOT cyclic
01:38:31 <Gracenotes> in Haskell, it's a tree that creates new nodes as you descend into them
01:38:32 <copumpkin> it's a locally finite graph
01:38:38 <lpsmith> yeah,  it's my favorite example:   it's old,  established,  and above all else,  *useful*
01:38:49 <lpsmith> And the Haskell community should know more about it!
01:39:03 <c_wraith> STM mzero is retry.  That's a novel interpretation of MonadPlus.  >_>
01:39:16 <Cale> ColonelJ: Using trees with sharing is typically not a great way to represent potentially cyclic finite graphs in Haskell anyhow.
01:39:35 <Gracenotes> ColonelJ: that was the subject of an interesting functional pearl
01:40:06 <Gracenotes> well. at least, one that constructed it.
01:40:10 * lpsmith agrees with Cale
01:40:26 <Cale> ColonelJ: You basically lose all sharing the moment you want to change something, and you can't "copy" things in such a way that they'll share.
01:40:36 <copumpkin> I wrote a graph representation using it, but it was unpleasant
01:40:42 <harrison> how does arrowloop work on functions? it says "loop f a = b where (b, c) = f (a, c)", but i'm not seeing how that can compile with any f.
01:40:44 <ColonelJ> Cale: that's what functions are for
01:40:54 <Cale> ColonelJ: Or yeah, Data.Map
01:41:07 <ColonelJ> functions can do EVERYTHING
01:41:20 <ColonelJ> they can divide by zero
01:41:28 <Cale> Map Vertex (Set Vertex), and variations of it is not bad
01:41:55 <Gracenotes> really, a lot of the Haskell functional pearls are just finding the DAG structures in computations that makes laziness work with them
01:41:56 <copumpkin> Map and functions are pretty close
01:42:01 <lpsmith> ColonelJ:  if you are trying to be absurdist,  a funnier response would be "they can compute the halting problem" or some such thing
01:42:07 <Gracenotes> and work efficiently
01:42:39 <ColonelJ> lpsmith: they can, the only problem is, the function that does that doesn't terminate
01:43:01 <ColonelJ> neither does divide by zero
01:43:06 <lpsmith> point taken,  if you are referring to a set-theoretic function
01:43:12 <ColonelJ> and herein lies the problem
01:43:19 <lpsmith> However,  within the haskell community, that's not really a function :)
01:43:27 <Cale> I consider it a function
01:43:33 <Cale> It's just not a computable function
01:43:55 <ColonelJ> you can't know if something is computable or not until you have computed it
01:44:09 <ColonelJ> this is the halting problem
01:44:22 <Gracenotes> well. you can in some cases.
01:44:23 <Cale> It's possible to show that there's no Turing machine which computes certain functions.
01:44:32 <ColonelJ> Gracenotes: ok yes
01:44:43 <lpsmith> Cale:  I'd say it depends on the context of the conversation;  and I'd say that "function" usually means "computable function" in the present context :)
01:44:44 <dblhelix> ColonelJ: that's not the halting problem...
01:44:45 <Gracenotes> with human intuition and whatnot
01:44:54 <dblhelix> ColonelJ: that's about termination, not computability
01:45:05 <ColonelJ> dblhelix: I know, sorry
01:45:33 <ColonelJ> What I meant was, that if it terminates, it is computable
01:45:52 <copumpkin> on all inputs
01:46:11 <ColonelJ> copumpkin: on whatever inputs you want to say it's computable for
01:46:18 <ColonelJ> the domain as it were
01:46:50 <ColonelJ> and I don't know of anything in haskell that knows about which domains the function works for
01:47:01 <ColonelJ> since it's impossible to say
01:47:05 <copumpkin> it's called the type! :P
01:47:07 <ColonelJ> all the time
01:47:10 <ColonelJ> copumpkin: no
01:47:14 * copumpkin plugs his ears and ignores partial functions
01:47:27 <ColonelJ> division by zero for example, works for everything except zero
01:47:27 <Gracenotes> well, types are sets of values
01:47:40 <copumpkin> ColonelJ: I use agda
01:47:46 <copumpkin> lalalalalala
01:47:49 <opqdonut> :D
01:49:00 <ColonelJ> can agda prove that zero is the only real number that cannot divide the others?
01:49:01 <lpsmith> yay for adga
01:49:18 <copumpkin> ColonelJ: by definition?
01:49:19 <copumpkin> sure
01:49:32 <lpsmith> I really should work on one or more of Agda, Isabelle, Coq, and HOL
01:49:55 <opqdonut> we did an imitation of pierce's tapl+coq course
01:50:04 <opqdonut> 'twas cool
01:50:20 <Gracenotes> that sounds too fun
01:50:21 <copumpkin> agda can definitely ask you to provide a proof that a parameter is not 0 with your call to the divide function
01:50:28 <lpsmith> although in my own horribly limited understanding,   Isabelle sounds the most interesting
01:50:33 <lpsmith> Although...
01:51:02 <lpsmith> It's not as programming-oriented as Coq or Agda :-(
01:51:04 <ColonelJ> copumpkin: good to know
01:51:10 <copumpkin> ColonelJ: unfortunately we have no reals in agda :)
01:51:22 <copumpkin> but we do have fields
01:51:30 <ColonelJ> of gold?
01:51:31 <lpsmith> So do real numbers exist?
01:51:32 <opqdonut> reals would be simple to define, right?
01:51:36 <copumpkin> lpsmith: nope
01:51:39 <copumpkin> opqdonut: nope
01:51:39 <Gracenotes> why not prove things with IEEE floating point? That should be fun!
01:51:43 <opqdonut> computable reals, taht is
01:51:48 <copumpkin> but I'd welcome you to define some
01:52:00 <opqdonut> or hmm, problems with proving halting?
01:52:21 <copumpkin> I'd copy roconnor's fewdigits library if I were to do it
01:52:26 <copumpkin> since he used it to prove stuff about reals in coq
01:52:48 <lpsmith> But what about random processes?  Without reals you can't take the limit of certain random processes... :-)
01:52:51 <opqdonut> i've been planning to do some basic constructive topology in coq
01:52:54 <Dashkal> Lazy evaluation is so much fun when testing partially completed code...
01:52:57 <ColonelJ> 0 is a real number, therefore real numbers exist QED
01:53:05 <copumpkin> omg
01:53:34 <Gracenotes> ColonelJ: exist? are you sure? Show me a real number existing in nature
01:54:04 <ColonelJ> there are real numbers everywhere in nature
01:54:06 * copumpkin comes up with an inductive definition of reals and proves godel wrong again!
01:54:07 <ColonelJ> golden ratio for example
01:54:11 <ColonelJ> pi
01:54:15 <copumpkin> nah, that's rational
01:54:18 <copumpkin> sry, fail
01:54:26 <ColonelJ> rational numbers are real numbers
01:54:33 <lpsmith> lol
01:54:39 <Cale> Neither of those numbers are rational.
01:54:40 <Gracenotes> ColonelJ: where does pi exist in nature?
01:54:46 <ColonelJ> circle
01:54:53 <Gracenotes> Do perfect circles exist in nature?
01:54:55 <Cale> Show me a circle ;)
01:55:01 <copumpkin> ^ that was my point
01:55:11 <c_wraith> there's one right behind you.  But it's hiding.
01:55:20 <lpsmith> The earth is closer to being a perfect sphere than many ball bearings
01:55:21 <Dashkal> Take string.  Tie one end to chunk of charcoal.  Stab other ent into stump.  Drag charcoal around with string taut.  Circle
01:55:21 <ColonelJ> they don't even have to be exactly circular to be of the form of a circle
01:55:28 <ColonelJ> and the form involves pi
01:55:43 <Gracenotes> well, forms don't actually exist (plato be damned)
01:55:48 <c_wraith> dashkal: error at the atomic level
01:55:51 <Cale> But also, the natural numbers similarly don't exist in nature. I've seen 5 apples, but I've never bumped into 5.
01:56:06 <opqdonut> actually, one can't even approximate pi physically properly
01:56:06 <Dashkal> c_wraith: Then don't measure at that level
01:56:10 <opqdonut> as the earth is curved
01:56:11 <opqdonut> :)
01:56:13 <Gracenotes> all this doesn't stop mathematicians from talking about them very specifically :)
01:56:25 <opqdonut> mathematicians can talk about symbols
01:56:30 <opqdonut> symbols exist, on paper
01:56:34 <copumpkin> Cale: you need to go to the top of everest. I found a natural up there once
01:56:34 <Cale> The real numbers are an excellent component for models of physical phenomena
01:56:39 <opqdonut> end of discussion :)
01:56:44 <ColonelJ> god exists
01:56:48 <ColonelJ> just like pi does
01:56:54 <Gracenotes> Cale: yep, key word: "model"
01:56:57 <opqdonut> let's not go here please
01:57:09 <Cale> Models are all we have.
01:57:22 <opqdonut> 5 exists in my head
01:57:35 <ColonelJ> exactly
01:57:38 <opqdonut> as do the circles
01:57:40 <Cale> I would like one objective reality please! Oh, they're sold out again.
01:57:45 <ColonelJ> and therefore they exist
01:57:51 <copumpkin> mmm models
01:58:10 <Dashkal> ColonelJ does not exist. *nods to self*
01:58:12 <Gracenotes> opqdonut: but I'm pretty sure all that exists in your head is neurons firing D:
01:58:20 <ColonelJ> I think therefore I am, I win
01:58:22 <opqdonut> what are these neurons
01:58:34 <copumpkin> ColonelJ: cogito ergo es
01:58:39 <Gracenotes> omg they don't exist either
01:58:40 <opqdonut> I am merely aware of sensory data and the abstractions I have built on top of them
01:58:52 <Cale> OH NO EVERYTHING IS AN ABSTRACTION OF SOMETHING ELSE!!!1
01:59:00 <copumpkin> zomg
01:59:01 <opqdonut> existing is ill defined :)
01:59:07 <opqdonut> anyway, this belongs in ##philosophy
01:59:18 <opqdonut> or ##math, if you wish
01:59:27 <ColonelJ> I don't wish to go to either
01:59:44 <lpsmith> #haskell often delves into ##philosophy and ##math,  if you haven't noticed
01:59:46 <lunabot>  luna: Not in scope: `haskell'
01:59:56 <lpsmith> hahaha
02:00:02 <opqdonut> lpsmith: not this deeply usually
02:00:02 <ColonelJ> I do wish that people insisting pi isn't real, go away to one of those places and not come back
02:00:03 * Gracenotes joins to see the join-flood
02:00:10 <lpsmith> true enough
02:00:19 <opqdonut> or rather, shallowly
02:00:25 <opqdonut> well, you know what I mean
02:00:32 <kmc> opqdonut, you did a version of TaPL+Coq in Agda?
02:00:36 <Cale> ColonelJ: It depends on what you mean by real
02:01:03 <ColonelJ> Cale: real as in it exists, and it is a real number
02:01:09 <Cale> Exists in ZFC?
02:01:24 <Cale> Exists empirically?
02:01:24 <opqdonut> kmc: no, in coq
02:01:24 <lpsmith> What about ZFC + CH?
02:01:34 <opqdonut> kmc: agda would've been pretty horrible :D
02:01:39 <c_wraith> exists as in you've had a conversation with it
02:02:11 <Cale> There's no physical experiment you could do to determine if pi exists or not, because it's not a matter of science.
02:02:12 <ColonelJ> who doesn't talk to pi?
02:02:33 <c_wraith> well, yes, pi exists.  I was thinking of more abstract numbers.  like 3
02:02:34 <opqdonut> hmm, does CH->AC ?
02:02:51 <ColonelJ> 3 can talk to you
02:02:53 <Cale> It's something which exists as a consequence of certain collections of abstract assumptions which are essentially arbitrary, but which we've also found useful for various purposes.
02:03:08 <Cale> opqdonut: They're independent of each other
02:03:25 <opqdonut> ok
02:03:33 <opqdonut> wonder what ZF+CH looks like
02:03:40 <ColonelJ> things don't even have to be true to exist
02:03:54 <gio123> Cale: hi
02:04:07 <kmc> opqdonut, because of the lack of proof scripts?
02:04:10 <Cale> Well, it's perhaps less funny than with AC included.
02:04:23 <opqdonut> kmc: yeah, basically
02:04:29 <gio123> Cale: hi
02:04:39 <ColonelJ> why not just pick some random axioms and see what  you come up with?
02:04:40 <Cale> ZF+CH+AC means that you not only can well order the reals, but you can well order the reals such that the set of predecessors of any real is a countable set.
02:04:42 <copumpkin> lol
02:04:45 <kmc> i'm doing Pierce's Software Foundations in Coq right now.  it's great fun
02:04:48 <copumpkin> Cale: hi
02:05:02 <gio123> copumpkin: bye
02:05:03 <gio123> :)
02:05:07 <opqdonut> and some things like strong normalisation for typed lambda calculus require a lot of automation
02:05:10 <opqdonut> to be readable
02:05:14 <copumpkin> gio123: bye!
02:05:32 * dblhelix is longing for a tactics engine for Agda
02:05:40 <copumpkin> eww, no tactics kthx
02:05:43 <Cale> So it means that the reals are in some sense *just barely* uncountable.
02:05:49 <opqdonut> Cale: it's kinda strange how formalists are much more common among fp people than among mathematicians in general
02:05:52 <opqdonut> in my experience
02:06:15 <copumpkin> Cale: so if I subtract one or two of them, I can count them again? yay! time to go write a blog post about godel being bullshit
02:06:31 <opqdonut> copumpkin: not to forget cantor
02:06:36 <copumpkin> whoops
02:06:39 <copumpkin> that's what I meant, lol
02:06:48 <Cale> opqdonut: I don't know. I think it really depends on which collections of people are in communication. I have the strong sense that platonism is dying quickly.
02:06:51 * copumpkin goes back to sleep before he says any more bullshit
02:07:18 <gio123> Cale: translation?
02:07:23 * opqdonut goes to write a blog post about copumpkin being bullshit
02:07:27 <Cale> gio123: sure
02:07:29 <copumpkin> :)
02:07:31 <gio123> :)
02:07:39 <gio123> pm?
02:08:21 <Cale> gio123: You don't have to ask, just send me messages that are worth replying to, and I'll reply to them if I'm around. :)
02:08:38 <gio123> i pmed u
02:08:41 <gio123> but no respond
02:08:50 <Cale> I saw that, but all you said was 'hi'
02:08:57 <gio123> :)
02:11:33 <ColonelJ> bbl
02:12:05 <copumpkin> well, that was pretty exciting
02:12:42 <Dashkal> All that because I dared mention a cycle in a tree :P
02:13:04 <opqdonut> well, ex falso quodlibet
02:13:08 <copumpkin> OMG TREES DO NOT HAVE CYCLES
02:13:10 <copumpkin> STFU
02:13:31 <dblhelix> :|
02:13:45 <c_wraith> I think the standard definition of a tree implies the ability to identify individual nodes.
02:14:10 <c_wraith> meaning the shape isn't the only characteristic
02:14:16 <Dashkal> In wich case haskell has no trees?
02:14:31 <copumpkin> well, you can add the identity yourself
02:14:44 <copumpkin> but yeah, probably not
02:15:08 <Dashkal> The only reason I call it a tree at all is because that's how I envision it.  I believe it would be more correctly referred to as a DAG
02:15:35 <opqdonut> it's not necessarily acyclic
02:15:46 <Dashkal> Mine is.  It's one of the invariants.
02:15:48 <copumpkin> I think it's quite fine to talk about a tree if your ADT represents one
02:15:57 <opqdonut> yeh
02:16:37 <Dashkal> A cycle in the structure is an invalid state.  None of the functions that operate on it are allowed to cause that state (and the type constructor is not exported).
02:17:00 <Dashkal> Assuming no bugs (heh), it's a DAG.
02:20:39 <c_wraith> Dashkal: an interesting feature of STM is that it lets you specify post-conditions for a transaction
02:29:09 <drippee> wow a lot of people here
02:31:16 <lpsmith> @src either
02:31:16 <lambdabot> either f _ (Left x)     =  f x
02:31:16 <lambdabot> either _ g (Right y)    =  g y
02:33:19 <Dashkal> Is there a monad for working with Eithers?  I'm looking for something that colapses Lefts much like the Maybe Monad colapses Nothings.
02:33:35 <osfameron> Either already is a monad isn't it?
02:34:03 <c_wraith> not in the best way possible
02:34:08 <lpsmith> >   Left 1 >>=  \x -> return (x + 1)
02:34:09 <lambdabot>   Ambiguous type variable `t' in the constraints:
02:34:09 <lambdabot>    `Control.Monad.Error.Cla...
02:34:19 <lpsmith> >   (Left 1) >>=  \x -> return (x + 1)
02:34:19 <Cale> I think the instance is not in the Prelude, and the instance in mtl in Control.Monad.Error is suboptimal
02:34:20 <lambdabot>   Ambiguous type variable `t' in the constraints:
02:34:20 <lambdabot>    `Control.Monad.Error.Cla...
02:34:38 <Cale> But Either is an easy monad anyway.
02:34:42 <Dashkal> hmm, drat.  That would have been a nice clean way to work with those methods...
02:34:52 <Cale> You can write the instance by hand
02:34:57 <Dashkal> *nods* I'm about to
02:34:59 <Dashkal> Just more work :P
02:35:32 <Cale> You could import Control.Monad.Error
02:35:49 <Cale> but in that case, you have to write Error instances for the types you want to use on the left.
02:35:55 <Cale> If it's just String, then it's fine.
02:36:07 <lpsmith> cale:  why is the mtl's definition suboptimal?
02:36:19 <Dashkal> Just a string.  I have some guarded methods and I wanted to be able to work with them in do notation
02:36:35 <Cale> lpsmith: Because it requires those Error instances when it shouldn't have to.
02:36:55 <Cale> lpsmith: Simply to support fail which shouldn't be in the Monad class in the first place.
02:36:55 <lpsmith> ahh
02:37:11 <lpsmith> agreed
02:37:41 <lpsmith> I've never really used Control.Monad.Error,  to be honest
03:04:12 <Dashkal> Hrm, Control.Moand.Error isn't quite what I wanted, but that's fine.  I intend on writing a world manipulation monad later anyway which can handle that.
03:04:43 <Dashkal> Thanks for all the help.  See you in the new year :)
03:05:01 <andrewe> Can someone give an example of Data.Function.fix?
03:05:33 <andrewe> Shouldn't this work? Data.Function.fix (\x -> x*x :: Float)
03:09:38 <Berengal> andrewe: It does work, but it's also _|-
03:09:41 <Berengal> _|_*
03:09:51 <Berengal> > fix (1:)
03:09:55 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:09:55 <b_jonas> merry christmas
03:10:23 <Jafet> :t square
03:10:24 <lambdabot> Not in scope: `square'
03:10:25 <andrewe> _|_ is undefined?
03:10:33 <Berengal> andrewe: Yes
03:10:57 <Berengal> As in infinite loops and partial functions. Things that fail to return
03:10:58 <andrewe> What's the use of fix then?
03:11:41 <Berengal> It's the abstraction of recursion
03:12:26 <Berengal> It finds the least defined fixed point. If that's _|_, then _|_ is what you'll get
03:13:14 <andrewe> If it's _|_ fix will not return?
03:13:31 <Berengal> Correct. At least not semantically
03:13:54 <andrewe> I don't understand what "least defined" means.
03:14:06 <andrewe> "least" in which sense?
03:14:34 <Berengal> In the definedness sense
03:14:49 <b_jonas> undefined is the least defined value, so fix will return undefined whenever that's a fix point of its argument
03:14:55 <Berengal> Values have a definedness. For example, "1" is a defined value
03:15:17 <b_jonas> but for example undefined is not a fixpoint of (1:) so fix (1:) can't return undefined
03:15:22 <Berengal> "undefined", infinite loops and partial functions return undefined values
03:16:05 <Berengal> In strict languages, there's only defined and undefined values. In lazy languages there's a whole hierarchy of them
03:16:23 <Berengal> For example, 1:[] is more defined than 1:_|_ is more defined than _|_
03:17:30 <andrewe> I will think about it.
03:17:37 <Berengal> And fix (1:) is less defined than 1:[], but more defined than 1:_|_. It's an infinite number of 1s with _|_ at the end (on the other side of the infinity)
03:18:41 <Berengal> In a way, it's infinitesmally less defined than fully defined...
03:19:30 <Berengal> andrewe: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
03:20:17 <b_jonas> so is that why undefined is called undefined?
03:20:46 <Berengal> Yes
03:21:19 <kmc> @src fi
03:21:19 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:21:20 <kmc> @src fix
03:21:20 <lambdabot> fix f = let x = f x in x
03:25:20 <andrewe> Berengal: strange, but thanks for the explanation. :-)
03:30:09 <Berengal> :)
03:37:16 <Saizan> fix (1:) is not less defined than 1:[], they are incomparable
03:41:14 <Berengal> Saizan: How so?
03:47:04 <Saizan> Berengal: it'd mean you couldn't write f = tail . tail, because f [1] = _|_ but f (fix (1:)) /= _|_, so it wouldn't be monotonic
03:48:14 <Berengal> Makes sense
03:48:19 <Saizan> but, more constructively, you can order only values that agree on the observable constructors
03:49:48 * Berengal refreshes his denotational semantics
03:51:31 <xpika> how can i convert say the first 1 from the first 7 in [0,1,1,0,7,0] to a 0
03:51:59 <b_jonas> xpika: I don't understand the question
03:52:42 <xpika> [0,1,1,0,7,0] to [0,0,1,0,7,0]
03:54:29 <xpika> based on circular positions
03:54:30 <Berengal> let (x, (_:y)) = span (/=1) [0,1,1,0,7,0] in x ++ 0:y
03:55:17 <Berengal> Oh, like that
03:55:28 <Stinger> oh he adds the crucial detail 5 mins later :P, so you mean [0,1,1,0,7,1] -> [0,1,1,0,7,0]
03:55:38 <xpika> Stinger: yes
03:55:50 <xpika> its for a list of poker players
03:56:19 <xpika> and moving the focus across the board to the first player still holding money
03:56:41 <dibblego> @google zipper list
03:56:42 <lambdabot> http://www.haskell.org/haskellwiki/Zipper
03:56:42 <lambdabot> Title: Zipper - HaskellWiki
03:56:50 <xpika> yes
03:56:54 <dibblego> xpika, you might want to check that out ^^
03:56:56 <xpika> i looked into that
03:57:19 <b_jonas> ah, I see
03:57:24 <b_jonas> circularly after the 7
03:58:14 * hackagebot upload: GPX 0.4.2 - Parse GPX files (TonyMorris)
03:58:46 <xpika> dibblego: using a zipper can send me into an infinite loop if i make a mistake
03:59:04 <dibblego> xpika, so can programming
03:59:09 <xpika> dibblego: something i want to avoid
03:59:27 <dibblego> that's easy; don't make mistakes!
03:59:36 <xpika> dibblego: haha
03:59:53 <dibblego> any Haskell program can go into an infinite loop if you make a mistake
04:00:07 <xpika> dibblego: that would require an infinitely strong type system
04:00:11 <dibblego> that's not a good reason to not use zippers
04:02:10 <xpika> dibblego: maybe the zipper isnt the problem for me
04:02:25 <xpika> dibblego: its that its an incomplete soloution
04:02:30 <xpika> dibblego: for my needs
04:02:45 <xpika> in that im trying to write safe code
04:03:05 <b_jonas> just break the list to the part before and after the 7, then first check if the part after the 7 has a 1, if it does, replace it there and prepend the beginning, otherwise replace it in the first part of the list and append the rest.
04:03:48 <xpika> b_jonas: i like that soloution. less chance of infinite loop
04:04:22 <xpika> is lambdabot on?
04:04:28 <xpika> > "test"
04:04:29 <lambdabot>   "test"
04:05:28 <BONUS> hmm, why does it seem impossible to do: type instance Foo Int = forall r. Either r Int
04:05:50 <BONUS> or to involve any sort of existentially quantification on the RHS of type functions
04:11:44 <Saizan> even with RankNTpes?
04:14:01 <b_jonas> > let { s = [0,1,1,0,7,0]; b x s f d = case span ((/=) x) s of { (s0, sm : s1) -> f s0 sm s1; _ -> d; }; } in b 7 s (\s0 sm s1 -> b 1 s1 (\s10 s1m s11 -> s0 ++ sm : s10 ++ 0 : s11) (b 1 s0 (\s00 s0m s01 -> s00 ++ 0 : s01 ++ sm : s1) (error "not found 1"))) (error "not found 7")
04:14:02 <lambdabot>   [0,0,1,0,7,0]
04:14:12 <b_jonas> -> xpika try that
04:15:49 <Stinger> simple
04:16:10 <b_jonas> yeah, it fits in an irc line without having to remove the spaces
04:16:19 <b_jonas> might be nicer with a cyclic rotate though
04:20:15 <b_jonas> yep, is simple with cyclic shift indeed
04:21:02 <b_jonas> /msg evalj evalj: (i.&7 (i.&1@] (0:`[`])} ])&.|. ]) 0 1 1 0 7 0
04:21:50 <b_jonas> I admit that's ugly though
04:24:03 <b_jonas> still it shows that cyclic shift is simpler
04:24:30 <Gracenotes> J, huh
04:25:13 <xpika> b_jonas: only i don't undersatnd j
04:26:13 <b_jonas> you just cyclically shift the array so the 7 goes to the beginning, then you find the first 1 and replace it with 0, then you undo the cyclical shift
04:26:15 <xpika> b_jonas: can you give me the gist of what its doing?
04:26:33 <xpika> b_jonas: oh ok
04:27:19 <xpika> b_jonas: i think that can result in an infinite loop
04:27:25 <b_jonas> no it can't
04:27:31 <b_jonas> all the operations are finite
04:33:22 <b_jonas> > let { se = [0,1,1,0,7,0]; phi k s = let { (s0, s1) = splitAt (mod k (length s)) s; } in s1 ++ s0; (Just i7) = elemIndex 7 se; sp = phi i7 se; (sp0, _ : sp1) = break (1==) sp; } in phi (negate i7) (sp0 ++ 0 : sp1)
04:33:23 <lambdabot>   [0,0,1,0,7,0]
04:33:36 <b_jonas> -> xpika
04:37:13 <Raevel> xpikachu!
04:41:17 <b_jonas> would be easier if the libraries already had cyclic shift and amend at index functions
04:41:57 <b_jonas> but no, they consider those, uh, "inefficent" or "bad style" on lists -- as if all those eq-based union, intersect, nub etc functions were better
04:42:16 <b_jonas> hypocricy
04:43:13 <Jafet> In their defense, they can probably spell
04:43:47 <b_jonas> which word did I misspell?
04:44:10 <b_jonas> oh, inefficient
04:44:40 <drippee> can i ask a really dumb question
04:44:49 <Jafet> You may get a really dumb answer.
04:45:12 <drippee> are any of you using haskell professionally?
04:45:36 <|fft|> How to write more detailed     m >>= (\x -> f a b)   ?
04:45:49 <xpika> drippee: id love to use haskell at work
04:45:58 <Saizan> b_jonas: hypocrisy, actually
04:46:08 <Jafet> As opposed to using Haskell in an unprofessional manner?
04:46:16 <b_jonas> oh
04:46:17 <koeien37> |fft|: what do you mean, "detailed"?
04:46:28 <drippee> no, just for money i mean
04:46:48 <|fft|> koeien37: I mean more lambdas  if f a b = (f a) b
04:46:56 <Jafet> Does getting grants to do useless "research" count?
04:47:23 <ivanm> Jafet: any useless research in particular?
04:47:29 <Jafet> @curry \x -> f a b
04:47:30 <lambdabot> Unknown command, try @list
04:47:45 <koeien37> |fft|: i still don't understand your question.
04:48:08 <Jafet> ivanm, no idea, ask drippee
04:48:30 <ivanm> I just came in, what's the current flame fest about?
04:48:37 <jlouis> List manipulation is pretty good when n is rather small
04:49:11 <drippee> it counts
04:49:17 <|fft|> koeien37: do m; f a b  = m>>=(\_ -> f a b )  =... =  ?
04:49:35 <|fft|> How to continue this chain
04:49:45 <koeien37> if you don't use x, then m >> f a b is the shortest
04:49:48 <jlouis> |fft|: depends on the definition of >>=
04:50:03 <koeien37> but there is nothing wrong with do { m; f a b }
04:50:09 <jlouis> |fft|: which is grabbed from the appropriate type class
04:50:17 <|fft|> jlouis: >>= from State Monad
04:50:39 <Jafet> drippee, then there are a fair number of "professional" Haskell users in here
04:50:58 <b_jonas> if it has >>=(_ -> f a b)
04:51:02 <b_jonas> then you can say >> f a b instead
04:51:03 <xpika> b_jonas: cyclic shift would be very good. as well as updateAt
04:51:05 <b_jonas> right?
04:51:08 <Jafet> In fact, GHC is the product of useless research
04:51:19 <xpika> b_jonas: how do you get them to add it to the data.List
04:52:40 <|fft|> b_jonas: And ?
04:53:09 <|fft|> If a and b are function how do they get previous state
04:53:15 <|fft|> *are functions
04:54:21 <koeien37> if they are functions that need to be run in the State monad too, they should have that type
04:54:37 <koeien37> State s a for some value of a
04:54:54 <jlouis> |fft|: m >>= (\x -> f (a x) (b x)) is perhaps the minimal (pure) way to pass x to a and b
04:55:27 <|fft|> koeien37: yes they are.
04:55:39 <koeien37> then they can run "get", too
04:56:57 <|fft|> jlouis: so this is the correct interpretation of this do notation   do m; f a b     ?
04:57:09 <b_jonas> you mean m >>= liftM2 f a b ?
04:57:11 <b_jonas> or something
04:57:19 <b_jonas> |fft|: no
04:57:36 <koeien37> do m; f a b is m >> f a b
04:57:39 <Saizan> drippee: there's a page on haskell.org on commercial users, and CUFP too
04:57:54 <b_jonas> "CUFP"?
04:57:56 <|fft|> b_jonas: more presicely   a returns State and b returns State and f is  mplus function
04:57:56 <koeien37> m >>= (\x -> f (a x) (b x)) is do { x <- m; f (a x) (b x) }
04:58:38 <Saizan> ?google CUFP
04:58:39 <lambdabot> http://cufp.galois.com/
04:58:40 <lambdabot> Title: Commercial Users of Functional Programming
04:58:40 <McManiaC> whats the ghc flag to compile with threads again?
04:58:46 <jlouis> -threaded
04:58:55 <jlouis> McManiaC: man ghc :)
04:59:02 <koeien37> this compiles in the threaded RTS
04:59:06 <McManiaC> no man entry =(
04:59:08 <McManiaC> fail package
04:59:18 <drippee> thank you for the link
04:59:53 <jlouis> if you want faster compilation, something else is needed
05:00:46 <koeien37> ghc is slow, but not annoyingly so
05:00:58 <|fft|> koeien37: if    do m; f    I understand how the state passes through. But if  do m; f a b  where a and b are functions dealing with state I can't get where do they get it.
05:01:00 <b_jonas> McManiaC: -threaded is listed under http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/options-phases.html#options-linker
05:01:16 <koeien37> can you write such an f, as an example?
05:02:12 <|fft|> do  m; f  `mlpus` g
05:02:32 <|fft|> mplus is in f role here of course
05:02:40 <koeien37> f a b = do { x <- a; y <- b; return (x, y) } -- example
05:02:54 <koeien37> the f gets passed these actions, and can run them
05:02:55 <jlouis> |fft|: that would work if f has type m a and g has type m a for some monad m and type a
05:03:11 <koeien37> :t forever
05:03:12 <|fft|> jlouis: sure
05:03:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
05:03:27 <jlouis> |fft|: so what is your question then?
05:05:59 <copumpkin> he wants to know how to do a real fast fourier transform
05:06:12 <koeien37> he wants to know the first fundamental theorems for GL_n and O_n ;)
05:06:15 <copumpkin> the regular one gives complex output, so he takes the magnitude with the |_|
05:06:34 <jlouis> copumpkin: I was just about to fire that punch line ffs
05:06:44 <copumpkin> :)
05:06:52 <|fft|> jlouis:  here we have  (m >>=(\_ -> mplus f g) and f g are also based on previous state. But from defenition of (>>=) in State Monad it's clear how the state passes to mplus. And not clear how it passes to it's arguments f and g
05:07:03 <copumpkin> the nice thing is that you can do the real one in half the time
05:07:08 <copumpkin> so never fear
05:07:19 <koeien37> is State a MonadPlus, then?
05:07:34 <Saizan> it is't
05:07:39 <koeien37> right, i thought so
05:07:42 <|fft|> koeien37: no but as an example
05:07:53 <b_jonas> first fundamental what?
05:08:01 <koeien37> let's take another example then. The function "forever"
05:08:07 <koeien37> :t forever
05:08:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
05:08:15 <Saizan> |fft|: these kind of functions are either implemented in terms of >>= or need to look at the internals of the monad
05:08:25 <koeien37> Take as an example:    m >>= (\_ -> forever f)
05:08:32 <koeien37> this "forever" is defined in terms of >> again
05:08:53 <koeien37> so it's m >> f >> forever f   => m >> f >> f >> forever f => m >> f >> f >> f >> forever f, and so on
05:09:03 <McManiaC> how can you wait for a "forkIO" function to finish?
05:09:22 <koeien37> (of course lazily. Note that forever f = f >> forever f
05:09:43 <ivanm> RWS == Read-Write-State monad?
05:09:53 <Saizan> ivanm: yeah
05:10:00 <koeien37> sequence is an example of a function that takes a list of actions, and runs them
05:10:01 <BONUS> McManiaC: modify the IO action so that it puts its result into an MVar
05:10:03 <koeien37> :t sequence
05:10:04 <jlouis> McManiaC: in principle, forkIO finishes instantly and produces a new child
05:10:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:10:07 <Saizan> Reader-Writer-
05:10:08 <koeien37> Could you write this function?
05:10:18 <jlouis> McManiaC: perhaps you want to wait for the child?
05:10:20 <BONUS> and then fork it and wait for the mvar to become full
05:10:37 <ivanm> and RWST is a transformer version?
05:10:41 <koeien37> or use Chans if you want to communicate
05:10:53 <ivanm> hmmm, I would have thought RWS would have actually been defined using transformers in mtl...
05:11:29 <koeien37> @src (<$>)
05:11:29 <lambdabot> f <$> a = fmap f a
05:12:16 <Saizan> ivanm: it's not really clear why RWS is there, presumably the reduced generality gave some perfomance improvements
05:12:31 <koeien37> fmap = ap . pure. This is an applciative law, right?
05:12:40 <|fft|> koeien37: So to get this work  do m; h f g should be defined as  m>>h f g =  let a = m>>=f ; let b = m>>=g in m>> h a b? or what ?
05:12:46 <ben0x539> I doubt applicative laws include ap
05:12:50 <b_jonas> nah, it's just an easier interface
05:12:51 <Saizan> but if youre looking for perforrmance on monads there are more effective transformations, afaiu
05:12:53 <koeien37> well, <*> then
05:13:17 <b_jonas> koeien37: in that case I think yes
05:14:06 <koeien37> |fft|: do { m; h f g } is just m >> h f g
05:14:17 <ivanm> Saizan: not looking for performance; just considering using RWS rather than my hacked together version which is a custom State that has read-only variables as well :s
05:14:22 <koeien37> h could be of type State s () -> State s () -> State s ()
05:14:28 <ivanm> (since I'm going to want to add logging in down the track anyway)
05:14:31 <koeien37> hell, h could be (>>) itself
05:16:23 <Saizan> there isn't a general way to say "these actions should take the current state even when i pass them to some arbitrary function"
05:16:39 <Saizan> you've to look at the implementation of that function to see what happens
05:17:43 <Saizan> most of the time the function will just use the actions as arguments to >>=, just like you'd call callbacks in an imperative language
05:18:03 <ivanm> so, is mtl still the preferred choice, or has some contender started being used a fair amount?
05:19:16 <Saizan> it's still the most common i think
05:22:58 <|fft|> Saizan: So we have   h  f g = (\state -> do whatever we want with state for example state'  = u (state) and then call g(state') ) and so on  ?  The behaviour with the state is completely defined in this way?
05:23:14 <ivanm> Saizan: *nod*
05:23:14 <b_jonas> there's another library, and you can always just hand-roll a single monad you're using or whatever
05:23:29 <b_jonas> monadLib or something
05:27:23 <medfly> monad transformer something
05:28:18 <ivanm> monads-fd as well
05:28:42 <ivanm> b_jonas: I'm currently using a hand-rolled monad; but it's a State monad that I'm treating as a Read-State monad :s
05:30:28 <Stinger> a Reader?
05:30:57 <ivanm> as in I have wrapper functions around it so that you can read some values and modify others
05:31:04 <Saizan> |fft|: if you meant f instead of u, and modulo type errors yes
05:31:29 <Saizan> |fft|: though you rarely work directly with state functions, you generally use combinators
05:32:58 <|fft|> Saizan: I simply meant that do whatever. Anyway now it's clear. thanks.
05:34:57 <Saizan> yup, State actions are nothing fancier than functions, so the only thing that matters is which arguments you give them
05:42:24 <ivanm> OK, I'm having a complete mental blank here; without using GeneralizedNewtypeDeriving, how does one write ask-like functions for a newtype wrapped around a MonadReader instance?
05:42:30 <ivanm> manual unpacking and repacking?
05:49:49 <Saizan> yeah
05:50:10 <ivanm> :(
05:50:11 <Saizan> ask = NewtypeConstr ask
05:51:05 <ivanm> ahhh, "Constr . asks" gets what I want \o/
05:52:48 <ivanm> and I take it GeneralizedNewtypeDeriving fails for MonadState, etc. because its a MPTC?
05:53:16 <Raevel> wow, i gave when an additional arg by accident and the errors were very wierd
05:56:23 <Saizan> ivanm: it generally works
05:57:10 <Saizan> ivanm: you've to list "MonadState Statetype" in the deriving clause
05:57:15 <ivanm> Can't make a derived instance of `MonadState PState' (even with cunning newtype deriving: `MonadState' does not have arity 1)
05:57:20 <ivanm> ahhh, I get you now
05:57:44 <Asztal> Raevel: at least you didn't get http://hackage.haskell.org/trac/ghc/ticket/3621 :)
05:58:41 <Ke> so whatever happened to dynamic linking in ghc?
05:59:20 <Saizan> it should work in ghc 6.12
05:59:52 <Ke> Saizan: so why isn't it written in features with cat sized letters
06:01:17 <Saizan> Ke: do you care so much? :) i could be wrong, anyhow
06:03:21 <Ke> Saizan: -rwxr-xr-x  1 jkarlson jkarlson 1140612 2009-12-31 16:02 a.out
06:03:31 <Ke> for a 6 line program
06:03:37 <Zeiris> I'm trying to build a graph. Is there a realistic way to make it so data Node a = Node a [Node a], ie have each node contain links to its' neighbours? (Rather than keys which can be looked up to find the neighbours.)
06:03:39 <doserj> it's stated in the highlights of the 6.12.1 release notes
06:03:48 <jlouis> Ke: stripped?
06:03:54 <Ke> nope
06:03:59 <jlouis> ...
06:04:13 <Ke> still even unstripped C binaries are much smaller
06:04:31 <Saizan> Ke: i know, it doesn't impress me much, mostly because the size doesn't scale linearly with the amount of code
06:04:41 <jlouis> Ke: C programs need to runtime system
06:05:05 <Ke> that is shared
06:05:58 <Ke> dynamic linking may or may not be the most crucial thing that ever happened to haskell
06:06:18 <Saizan> Zeiris: depends on the operations you need, with that representation you can't tell the difference between a cyclic and an infinite graph for example
06:07:21 <Zeiris> Hum. Well, I intend to search for minimum-cost paths, so you bring up a good point.
06:07:46 <Saizan> Zeiris: you could be sneaky with things like StableName to observe sharing
06:07:58 <edwardk> preflex: xseen RyanT5000
06:07:58 <preflex>  RyanT5000 was last seen on freenode/#haskell 9 hours, 51 minutes and 56 seconds ago, saying: c_wraith: the guy who forces it
06:08:35 <doserj> Ke: did you build all dependent packages also shared?
06:09:31 <Ke> doserj: having no problems, just doing recon
06:09:59 <Saizan> perhaps the best thing about dynamic linking is that ghc will stop splitting object files (afaiu), so much shorter link times
06:10:26 <Ke> I was thinking about feasibily of programming haskell on embedded systems like freerunner
06:11:15 <Ke> could be faster and more stable than python commonly used
06:12:01 <Ke> only small scripts in python are only kilobytes and the space is not too plentiful
06:16:06 <eu-prleu-peupeu> hi
06:19:47 <HaskellLove> I had a function in the interpreter lets call it a. then i had function b that included a. both functions were created in interpreter with let. after i redefined function a, function b was still conected to the old function a. What is going on?
06:20:05 <mauke> lexical scoping
06:21:02 <Athas> Aww, no liftM13.
06:21:12 <mauke> Athas: that's what ap is for
06:21:19 <HaskellLove> mauke vs dynamic scoping which would have updated it right?
06:21:40 <mauke> yes ... sort of
06:21:45 <Jafet> You cannot redefine a function
06:21:53 <Jafet> You can create a new one with the same name
06:22:07 <koeien37> correct. let a = a + 1 will loop, for example, upon evaluating a
06:22:42 <twanvl> > do { let {a = "old a"};  let {b = "b from " ++ a};  let {a = "new a"};  return b } :: [String] -- this is how definitions in ghci work
06:22:43 <lambdabot>   ["b from old a"]
06:23:00 <koeien37> and in GHC too
06:23:17 <HaskellLove> Jafet I thought you can do that in interpreter but not with the compiler
06:23:39 <Jafet> As twanvl said, the interpreter uses an implicit do block
06:24:40 <HaskellLove> Jafet I mean, it is an interpreter after all you have to be able to play with it so i expected the "nothing is changed, each time a new thing is built on top of another" thing to be only for, well, when you compile a text file.
06:24:59 * copumpkin just wrote another massive spiel on reddit
06:25:05 <copumpkin> I should really get a blog
06:25:17 <Jafet> Why should the interpreter use a different language? That would be useless
06:25:23 <koeien37> again the "FP doesn't work" "debate"?
06:25:43 <edwardk> the copumpkin.reader
06:25:48 <copumpkin> :)
06:25:58 <Jafet> A kingdom for a blog!
06:25:59 * copumpkin looks embarrassed
06:26:01 <copumpkin> koeien37: yep
06:26:06 <lpsmith> getting a blog is easy
06:26:23 <HaskellLove> > import Data.Copumpkin.Ninja.GeneralSolver
06:26:24 <lambdabot>   <no location info>: parse error on input `import'
06:26:27 <koeien37> I can more or less see where the argument is coming from
06:26:40 <lpsmith> Although I'm not sure I'm happy with wordpress.com on a few counts.
06:26:45 <koeien37> but the initial article was poor
06:27:36 <copumpkin> lpsmith: yeah, I wouldn't want wordpress
06:27:41 <copumpkin> it makes me uncomfortable
06:27:49 <edwardk> copumpkin: why?
06:28:05 <edwardk> i just run wordpress on my own machine
06:28:21 <copumpkin> maybe it's just me, but some aspects of some software make me feel like the programmer doesn't know what he's doing, despite a possibly attractive front-end
06:28:26 <lpsmith> Their business model is messed up.   Wordpress on your own machine might be ok
06:28:34 <edwardk> i'll concede that ;)
06:28:35 <koeien37> it has had lots of security problems
06:28:36 <copumpkin> I get that feeling from wordpress
06:28:43 <lpsmith> heh,  I get that feeling too
06:28:52 <copumpkin> another such program is papers for mac :)
06:29:09 <copumpkin> I use it because I want to organize my papers, but it feels a little icky somehow (despite being quite pretty)
06:29:21 <edwardk> i think that feeling is fairly common in anything that ends in .php
06:29:27 <copumpkin> yeah :)
06:29:31 <DrTeggy> copumpkin, fully agreed
06:29:41 <DrTeggy> copumpkin, I would love to love Papers more.
06:29:44 <DrTeggy> But I can't.
06:29:47 <copumpkin> yeah :/
06:29:56 <b_jonas> and in good php tradition, lots of wordpress modules have quoting problems
06:30:26 <en0th> Is there a way to "bridge" a data definition through a module? Something like:
06:30:27 <lpsmith> but really,  I don't want to fiddle with blogging software much,  and I'm not sure what's a good option
06:30:27 <en0th> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5661#a5661
06:30:46 <copumpkin> lpsmith: when I feel particularly virtuous, I'm going to give hakyll a go
06:31:03 <Jafet> That's because PHP programmers don't want to admit they're writing half a dozen DSL subprograms by concatenating strings.
06:31:03 <copumpkin> no security issues (beyond a misconfigured server) with static html :)
06:31:10 <koeien37> en0th: sure, why not?
06:31:26 <koeien37> in the export list, include "module Core", or "Foo(..)"
06:31:45 <copumpkin> wow, my reddit comment is even more of a wall of text than I intended it to be. The person I'm responding to probably won't even read it :P
06:31:53 <Jafet> (And they'd turn their noses at Tcl, oh they would.)
06:31:59 <lpsmith> the one thing I think I want is the ability for people to leave comments
06:32:09 <lpsmith> hackyll doesn't provide that
06:32:19 <copumpkin> lpsmith: disqus and intensedebate are comment-specific services
06:32:28 <copumpkin> they also cross sites, so you can maintain your "reputation"
06:33:08 <en0th> koeien37: cool, i'll go for Foo(..), thanks!
06:33:18 <Jafet> I feel that the web is a fad, it'll eventually go away.
06:33:21 <koeien37> Foo is the type, Foo(..) is the type + all its constructors
06:33:42 <koeien37> so if you want to export an abstract data type, you can use Foo, without the constructors
06:34:08 <en0th> that's why it gave me problems, i forgot the (..) part
06:34:52 <koeien37> this is the canonical way to use hiding / abstraction in Haskell
06:35:08 <koeien37> but if you want to export the constructors, you can use Foo(..) or Foo(Con1, Con2, Con3)
06:36:18 <en0th> looks very good.
06:36:22 <DrTeggy> Beware, advertisement ahead:
06:36:27 <DrTeggy> I have a vacant full-time PhD position in my database research group here at U
06:36:27 <DrTeggy> Tübingen, Germany. (http://www-db.informatik.uni-tuebingen.de/). Our research
06:36:28 <DrTeggy> involves the construction of compilers for various kinds of advanced
06:36:28 <DrTeggy> functional query/programming languages. Target platform for these compilers
06:36:28 <DrTeggy> are relational DBMS. Contact me if you've got a M.Sc. in CS and love database
06:36:28 <DrTeggy> technology and/or (functional) programming languages.
06:36:35 <DrTeggy> (Sorry, folks)
06:36:52 <koeien37> you might want to advertise on the mailing lists Haskell and Haskell-cafe
06:37:05 <jlouis> Indeed!
06:37:07 <DrTeggy> koeien37, a very good suggestion.  Thank you!
06:37:35 <koeien37> there might also be a functional programmer list for Germany (I know there is one for the Netherlands)
06:38:36 <DrTeggy> This work really happens on the verge of DB and PL technology.
06:38:50 <DrTeggy> Hard to find folks who love both aspects of it.
06:41:31 <copumpkin> DrTeggy: target all the maintainers of the packages in this category: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database :P
06:42:03 <DrTeggy> I don't want to open a side-business in spamming, hehe
06:42:29 <DrTeggy> But you're all helpful, thank you.
06:42:45 <Jafet> Why does all the real work get done in europe
06:42:52 <Jafet> It baffles.
06:42:58 <koeien37> all "real" work is done in asia
06:43:17 <koeien37> in the west we get to write things down on paper and get paid
06:44:00 <DrTeggy> We were visiting Philip Wadler (U Edinburgh) and talked the project through.  It really has an FP side to it, trust me. :-)
06:44:25 <DrTeggy> It's connect with Wadler's Links effort.
06:44:46 <Jafet> In the west you write code in paper?
06:44:52 <Jafet> Baffling.
06:45:06 <koeien37> heh, i had a programming course with pen & paper
06:45:12 <HaskellLove> I just wrote a sexy permutations function http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15299#a15299
06:45:16 <koeien37> but I must confess, most of the time i use my computer
06:46:35 <koeien37> but when I do mathematics, it's more pencil & paper :)
06:47:32 <doserj> HaskellLove: now use that to implement permutation sort...
06:48:02 <HaskellLove> permutation sort?
06:48:16 <koeien37> "check all permutations for sortedness"
06:48:30 <Jafet> Most efficient sort known to man
06:48:44 <Jafet> (Note: product only tested on nearly-sorted sequences.)
06:49:18 <b_jonas> oh, you mean deterministic bogo sort
06:49:41 <HaskellLove> I don't know what sort you guys talk about, anyways i will use my permute function to finish some eulers now
06:49:47 <koeien37> bogo sort = randomly permute and check if it's sorted, if not, restart?
06:49:55 <koeien37> HaskellLove: it's a joke :)
06:49:56 <DrTeggy> I have to go outside with my little son.  Take care, folks.  All the best for the New Year.
06:50:54 <b_jonas> koeien37: yes, that's randomized bogo sort
06:51:22 <HaskellLove> anyways my permute is kinda of cheat, it generates numbers, for example for a three digit it generates 100..999 and checks all numbers whose digits list is same with the given n
06:51:32 <HaskellLove> i want now to write a recursive one if i can
06:52:13 <koeien37> permuting shouldn't be dependent on the input type
06:54:19 <HaskellLove> koeien37 yeah this one is for numbers only but i could easily replicate it for words too
06:54:23 <Jafet> Well, it'll probably want an instance of Ord
06:54:34 <koeien37> why?
06:54:47 <koeien37> :t permutations
06:54:48 <lambdabot> forall a. [a] -> [[a]]
06:54:58 <Jafet> Oh, nevermind
06:55:19 <HaskellLove> koeien37 mine is Int ->[Int]
06:57:10 <HaskellLove> i need it for now, if i need it for other types can easily adapt it and parametrize, too lazy now i just wanna finish my sweet eulers
06:58:52 <koeien37> what is the goal of doing these Euler projects. To learn, isn't it?
06:59:05 <koeien37> I would try to make one of type [a] -> [[a]]. It's a good exercise
07:00:46 <Botje> HaskellLove: the base case is perms [] = [[]]
07:01:04 <Botje> that's what stumped me for a _LONG_ time
07:01:12 <copumpkin> :)
07:01:20 <koeien37> well, yeah, if you do perms [] = [], you will get nowhere
07:01:23 <HaskellLove> Botje i am not doing it recursively, mine is kinda lame
07:01:38 <koeien37> yours depends on a finite input alphabet
07:02:27 <copumpkin> > permutations [1..]
07:02:28 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:02:35 <copumpkin> > permutations [1..] !! 1000
07:02:36 <lambdabot>   [3,5,2,4,7,6,1,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:02:37 <HaskellLove> koeien37 yes but, we people work with finite input alphabets, so it will work for anything
07:02:51 <koeien37> why would you assume that?
07:03:16 <copumpkin> > find ((== [3,1,4,1]) . take 4) $ permutations [1..]
07:03:20 <lambdabot>   mueval-core: Time limit exceeded
07:03:31 <copumpkin> > find ((== [3,1,4]) . take 4) $ permutations [1..]
07:03:35 <lambdabot>   mueval-core: Time limit exceeded
07:03:44 <copumpkin> > find ((== [3,1,4]) . take 3) $ permutations [1..]
07:03:45 <lambdabot>   Just [3,1,4,2,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
07:04:05 <koeien37> > find ((== [3,1,4,1,5,9]) . take 6) $ permutations [1..]
07:04:09 <lambdabot>   mueval-core: Time limit exceeded
07:04:15 <koeien37> i guessed so
07:04:25 <copumpkin> , find ((== [3,1,4,1]) . take 4) $ permutations [1..]
07:04:33 <lunabot>  Killed.
07:04:49 <koeien37> yeah, two 1's. Not going tow ork
07:04:52 <lpsmith> [3,1,4,1]  will never appear
07:05:01 <copumpkin> lol
07:05:03 * copumpkin feels stupid
07:05:30 <copumpkin> #ty each
07:05:35 <lunabot>  forall a . [] a -> Omega a
07:05:51 <lpsmith> But assuming a finite alphabet isn't that big a deal
07:05:59 <lpsmith> more important is it's very slow
07:06:00 <copumpkin> #ty map (each . repeat) [1..]
07:06:02 <lunabot>  forall a . (Num a, Enum a) => [] (Omega a)
07:06:17 <copumpkin> , sequence $ map (each . repeat) [1..]
07:06:18 <lunabot>  luna: No instance for (GHC.Show.Show (Control.Monad.Omega.Omega [a]))
07:06:24 <lpsmith> To clarify,  HaskellLove's permute is very, very slow
07:06:30 <copumpkin> , runOmega . sequence . map (each . repeat) $ [1..]
07:06:33 <lunabot>  Stack space overflow: current size 8388608 bytes.
07:06:33 <lunabot>  Use `+RTS -Ksize' to increase it.
07:06:37 <copumpkin> boo
07:06:52 <lpsmith> Here's a problem for you,  HaskellLove:
07:06:56 <copumpkin> , runOmega . sequence . map (each . replicate 2) $ [1..]
07:06:58 <lunabot>  Stack space overflow: current size 8388608 bytes.
07:06:58 <lunabot>  Use `+RTS -Ksize' to increase it.
07:07:17 <Botje> Omega is the diagonalization thing, right?
07:07:21 <copumpkin> yeah
07:07:27 <b_jonas> @type runOmega
07:07:28 <lambdabot> Not in scope: `runOmega'
07:07:34 <copumpkin> #ty runOmega
07:07:37 <lunabot>  forall a . Omega a -> [] a
07:07:52 <lpsmith> using recursion, not some combination of built in functions,    write a function that takes an integer representing an index into a list,   an element to be inserted,  and a list,  and inserts that element into the list at that index.
07:08:00 <lpsmith> what's the type of such a function?
07:08:20 <b_jonas> ah, I see: http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html
07:08:42 <HaskellLove> lpsmith i can do my function much faster if i apply it to indices :D and then just convert indices to elements
07:09:16 <lpsmith> trust me on this one
07:09:26 <lpsmith> let's get through the basics first
07:09:51 <HaskellLove> will do that now wait let me do it this one, will be so fast and cool
07:09:51 <lpsmith> insertion is cheaper than sorting
07:11:19 <lpsmith> You want help for that function?  It's easy,  just two or three short lines
07:11:32 <HaskellLove> no it is easy will do it now
07:12:00 <lpsmith> ok,  let me see it when you are done
07:12:49 <HaskellLove> sure
07:14:09 <lpsmith> (incidentally,  your permutation function is the bogo-sort approach to generating permutations.   So if you use that to do a deterministic bogo-sort,  it'd be more of a bogo-bogo-sort.)
07:14:31 <matsuura> uh, 10:11 DCC SEND from esi889Y[Q [0.0.0.0 port 0]: startkeylogger [0B bytes] requested in channel #haskell
07:14:36 <matsuura> what the fuck is this?
07:14:56 <lpsmith> not to mention that you are using sort to produce a sort, which is hilarious
07:15:02 <lpsmith> err, would be
07:15:06 <koeien37> i've seen it too. I'm not too worried
07:15:17 <zygoloid> matsuura: exactly what it looks like. someone trying to trick you into installing a keylogger
07:15:23 <matsuura> install?
07:15:24 <matsuura> lol
07:15:38 <matsuura> do people actually still use dcc? >_>
07:15:42 <koeien37> or it's a command for a botnet
07:15:43 <Stinger> botnet?
07:15:46 <zygoloid> matsuura: or possibly someone trying to initiate some already-installed script for a botnet
07:16:04 <matsuura> people are crazy...
07:16:08 <Ke> matsuura: it's a line that makes some windows firewall applications go crazy
07:16:17 <zygoloid> people wouldn't do it if it  didn't work
07:16:22 <matsuura> oh, they should check version first
07:16:27 <matsuura> would make more sense
07:16:31 <Zeiris> How do I make my Haskell code not look like a gigantic ugly mess?
07:16:50 <matsuura> zygoloid: na, they're just fucking retarded
07:16:58 <koeien37> that depends. Can you paste your code?
07:17:03 <matsuura> most of those guys end up being skiddies or something of the nature anyways
07:17:18 <lpsmith> zeitris:  rewrite it over and over again until it looks good
07:18:16 <Stinger> whenever I have insane code it's usually me trying to be tricky and doing everything pointfree in my head
07:18:28 <matsuura> DCC aborted receiving file startkeylogger from esi889Y[Q
07:18:30 <matsuura> lol
07:18:42 <matsuura> someone should gline him
07:19:58 <Botje> no no no
07:20:00 <Botje> sterilize.
07:20:50 <Zeiris> Heh, lpsmith's suggestion works, though is a bit inefficient. Maybe it's also that I'm used to structuring stuff with discrete functions or objects, and abuse the freedom Haskell provides. (An obvious problem I think I've spotted is lumping everything into one giant function, and bad naming due to repeated re-writes: http://paste.pocoo.org/show/160914/)
07:21:37 <lpsmith> Well, depends,  I rewrote my queue code a few hundred times,  but that's partly because I didn't understand it :-)
07:22:13 <lpsmith> That project directory has at least 20 variants that I kept
07:22:50 <koeien37> Zeiris: can't you do more in SQL directly?
07:23:04 <lpsmith> but it's a short snippet of code,  amenable to that kind of approach
07:24:07 <mreh> > let slidingWin n xs = windows n 0 xs; windows n m = (take m . drop n $ xs) : windows (n+1) m xs in slidingWin 3 [1..]
07:24:08 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
07:24:10 <Zeiris> Hurr. I'm embarassed to say that I understand Haskell better than SQL. I think I need to use more point-free definitions to get rid of ( and ) brackets.
07:24:36 <mreh> > let slidingWin n xs = windows n 0 xs; windows n m xs = (take m . drop n $ xs) : windows (n+1) m xs in slidingWin 3 [1..]
07:24:37 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
07:25:10 <mreh> i was going to ask for a more haskelly way to do that, but when it worked
07:25:19 * hackagebot upload: zip-archive 0.1.1.5 - Library for creating and modifying zip archives. (JohnMacFarlane)
07:25:44 <lpsmith> HaskellLove, so here's the type of the function I want you to write:
07:25:46 <mreh> > let slidingWin n xs = windows n 0 xs; windows n m xs = (take n . drop m $ xs) : windows (n+1) m xs in slidingWin 3 [1..]
07:25:47 <lambdabot>   [[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,3,4,5,6,7...
07:25:58 <lpsmith> insertAt :: Int -> a -> [a] -> [a]
07:26:01 <mreh> > let slidingWin n xs = windows n 0 xs; windows n m xs = (take n . drop m $ xs) : windows n (m+1) xs in slidingWin 3 [1..]
07:26:02 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
07:26:05 <mreh> that's the idea!
07:26:15 <lpsmith> so what's a base case?
07:26:22 <zygoloid> > let slidingWin n xs = map (take n) (tails xs) in slidingWin 3 [1..]
07:26:23 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
07:26:42 <mreh> :t tails
07:26:43 <lambdabot> forall a. [a] -> [[a]]
07:26:49 <lpsmith> Well, one of the base cases is when the Int is equal to zero,   so what should the rest look like?
07:27:02 <mreh> zygoloid: more succinct, nice
07:27:17 <lpsmith> How do you insert something at index zero?
07:27:22 <HaskellLove> lpsmith haha you monster :D cool
07:27:39 <Twey> :t (:)
07:27:40 <lambdabot> forall a. a -> [a] -> [a]
07:27:41 <zygoloid> mreh: should also be asymptotically faster, i think.
07:27:49 <matsuura> Twey: Hey! Did you get my memo?
07:27:53 <HaskellLove> I tried to used repeat for permutations before but you only get limited number like that of course
07:28:01 <Twey> matsuura: Yes
07:28:26 <matsuura> You hadn't responded to me at all.. was curious as to what happened
07:29:17 <lpsmith> @src take
07:29:18 <lambdabot> take n _      | n <= 0 =  []
07:29:18 <lambdabot> take _ []              =  []
07:29:18 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
07:29:37 <mreh> zygoloid: asymptotically? I don't understand
07:29:44 <mreh> explain in terms of big O notation
07:30:06 <Twey> I looked, laughed, and deleted it.  You were let back in before, as I recall, and managed to behave so badly as to get a permanent ban the next time.  I didn't respond because you'd go through your usual troll routine all over again, pretending to have forgotten everything you did.
07:30:16 <b_jonas> :-)
07:30:22 <lpsmith> mreh:  asyptotically faster meaning the it's big O faster
07:30:50 <mreh> lpsmith: wut? like an order of magnitude?
07:30:58 <mreh> big O(what)?
07:31:18 <zygoloid> mreh: suppose you looked at the first element of each produced list, and you looked at the first n lists. your one would take 1 step for the drop 0, 2 steps for the drop 1, 3 steps for the drop 2, and O(n^2) total
07:31:49 <Zeiris> How does something like   (sysName s)++" ("++sec s++")"++" "++link s    end up parsing correctly? Do function applications just have a higher priority than (++)?
07:31:51 <lpsmith> not necessarily, but if somethings asymptotically faster, then it's possible to choose a large enough problem that the asymptotically faster algorithm is 10x faster
07:31:53 <mreh> zygoloid, how else do you think "tails" works?
07:31:56 <Zeiris> (What is the default function application priority?)
07:31:58 <zygoloid> the tails method is O(n), since it just drops one element from the previous list
07:32:08 <mreh> tails can be done with an accumulator though cant it
07:32:11 <mreh> @src tails
07:32:12 <lambdabot> tails []         = [[]]
07:32:12 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
07:32:13 <matsuura> Twey: I don't understand, at all.. It seems you're making that up or something that's fine. Thanks
07:32:23 <b_jonas> Zeiris: yes
07:32:33 <b_jonas> Zeiris: function application has (almost) the highest priority
07:32:41 <Zeiris> Is there a number to it?
07:32:46 <lpsmith> but of course,  the required problem size might be impractically large
07:32:49 <koeien37> except for record syntax
07:32:55 <b_jonas> the only things that has higher priority are package clarifications and the @ sign
07:32:56 <mreh> right
07:33:07 <b_jonas> Zeiris: I don't know if there's a number for it
07:33:41 <matsuura> Twey: unless you can provide me with some logs? I'd be happy if you showed me that it was true and you're lot just trying to keep me banned for some crazy reason.. Have no idea.
07:33:53 <matsuura> Twey: Just want to be able to study
07:34:00 <Zeiris> That's insane... You're right, it's even higher priority than (.)! Something like sec = take 4 . show . sysSec works fine :D
07:34:09 <canvon> Zeiris: http://www.haskell.org/tutorial/functions.html#sect3.2.2
07:34:09 <koeien37> right
07:34:22 <matsuura> Twey: if I don't ask something relevant to the topic, feel free to keep me away
07:34:48 <mreh> preflex: seen mmorrow
07:34:48 <preflex>  mmorrow was last seen on #haskell 1 day, 7 hours and 52 seconds ago, saying: * mmorrow refocuses back on topic
07:35:14 <mreh> good turnout on #haskell for the largest social event of the calendar year
07:35:21 <djahandarie> \o/
07:35:41 <mreh> i've got to go to some party though...
07:35:53 * koeien37 too later today
07:36:02 <Twey> matsuura, I've wasted so many days on this the last time you pulled this routine, and we went through the whole business of showing you the logs, and you insisting you don't remember, or that the eroguro child porn you posted apropos of nothing was just for artistic purposes, and so on and so forth, and then you whining in #freenode, and I'm not doing it again.  Please go away.  We don't want you in there.  Also, this is severely off-topic for #haskell.
07:36:06 <mreh> i might sneak my laptop in
07:36:14 <matsuura> Twey: you spent like 20 minutes
07:36:15 <Twey> End of discussion.
07:36:21 <matsuura> Twey: I just want to study
07:36:44 <mreh> Twey: issue him with his last warning
07:36:56 <Twey> mreh: He's had about three.
07:37:02 <matsuura> Twey: you wont talk to me in pm
07:37:03 <matsuura> at all
07:37:11 <koeien37> @where ops
07:37:12 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
07:37:27 <mreh> matsuura: this is off topic, please take it somewhere else
07:37:30 * matsuura speaks about other things
07:37:50 <gabl> Is it possible to use lazy Bytestrings with Network.HTTP?
07:38:03 <b_jonas> ah, tricky!
07:39:19 <mreh> is there something in Data.List that does that sliding window trick? I want to do list monady things with a random sequence, so I thought making an inifinite sequence and finding the first sequence within it that fit
07:39:36 <Zeiris> Ha, this explains why I've had so much trouble getting (.) to work right! All this time, functions ate up arguments at a higher priority than (.) chained functions :D
07:39:41 <mreh> that probably made little sense
07:39:47 <Botje> mreh: map (take n) . tails
07:40:11 <mreh> :t guard
07:40:13 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:40:20 <zygoloid> Zeiris: functions eat up arguments at a higher priority than anything else :)
07:40:35 <Botje> functions are greedy little bastards.
07:40:59 <mreh> has anyone else noticed that hoogle's links into the prelude are broken?
07:41:00 <djahandarie> We should probably just remove functions from Haskell entirely
07:41:07 <Botje> totally.
07:41:13 <koeien37> dysfunctional programming ftw
07:41:16 <mreh> noo, not my functions
07:41:19 <Botje> i hereby proclaim haskell to be an "al programming language"
07:41:27 * Jafet distributes the skis
07:41:47 <koeien37> what use are "variables" if they don't "vary"?!?!
07:41:53 <mauke> ski is the limit
07:42:02 <Twey> They do vary
07:42:04 <mreh> koeien37, they do
07:42:05 <Botje> no, ski is the bottom :(
07:42:06 <mreh> lol
07:42:16 <Twey> But between function calls, not within the same call
07:42:20 <koeien37> i know
07:42:32 <Twey> Heh
07:42:35 <Jafet> lim inf!
07:42:37 <koeien37> > let fact 0 = 1; fact n = n * fact (n-1) in fact 37
07:42:38 <lambdabot>   13763753091226345046315979581580902400000000
07:42:44 <mreh> ROFL, right, enough chat
07:44:49 <mreh> are the properties of mzero just mathematical, not programmed?
07:45:08 <koeien37> what do you mean?
07:45:18 <ray> they can't be expressed in the type system
07:45:21 <ray> which is probably what you mean
07:45:23 <_JFT_> Hey guys, which version of GHC are you using 6.10.4 (Platform installer etc) or 6.12.1 (or dev head?) Just went to upgrade my 6.10.3 installation and I'm confused as to which to pick...
07:45:29 <ray> you just have to follow them
07:45:29 <mreh> how can I be sure than [] >>= f is always []?
07:45:34 <koeien37> 6.10.4
07:45:46 <koeien37> I'll keep using 6.10.4 until HP is released for 6.12.x
07:45:55 <mauke> 6.10.2
07:45:59 <Ke> HP?
07:46:03 <koeien37> mreh: ehm. You have to prove that, there is no way to prove it inside haskell.
07:46:07 <koeien37> mreh: just like the monads laws
07:46:11 <SamB_XP> @type ([] >>=)
07:46:12 <mauke> the last one with readline support
07:46:12 <lambdabot> forall a b. (a -> [b]) -> [b]
07:46:12 <_JFT_> Ke: Haskell Platform
07:46:18 <koeien37> The Haskell Platform
07:46:27 <SamB_XP> @free (a -> [b]) -> [b]
07:46:28 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
07:46:34 <ray> mreh: all haskell can guarantee you is that which can be expressed in the type
07:46:35 <koeien37> haha
07:46:37 <Ke> I guess the conservative approach is using the newest haskell provided by the distro
07:46:41 <SamB_XP> oh, right ...
07:46:44 <SamB_XP> no lists ...
07:46:47 <copumpkin> wow, the word "boobs" just made it onto haskell-cafe, that's a first for me
07:46:59 <copumpkin> not that I object, but it's unexpected :)
07:47:00 <SamB_XP> copumpkin: why is that a first ?
07:47:10 <djahandarie> 58008
07:47:12 <SamB_XP> isn't that the name of (.).(.)
07:47:12 <djahandarie> hehe
07:47:16 <copumpkin> well, I've never seen that on haskell-cafe :) but admittedly I haven't been around for very long
07:47:17 <mreh> oooh, it's in the implementation of >>=
07:47:19 <ray> fmap fmap fmap
07:47:21 <copumpkin> SamB_XP: no, real boobs
07:47:29 <SamB_XP> oh, referring to actual boobs?
07:47:34 <SamB_XP> that's strange ;-)
07:47:36 <mreh> stop talking about boobs!
07:47:36 <djahandarie> ray, haha
07:47:37 <Twey> Hahaha
07:47:40 <koeien37> ray: LOL
07:47:47 <copumpkin> :)
07:47:49 <Olathe> Haha
07:48:05 <mreh> cycle "fap "
07:48:24 <Ke> Yeeaaahh!
07:48:33 <Twey> Ke: You have an unusually short name
07:48:43 <Twey> I'm impressed
07:48:47 <koeien37> call me overly PC, but I would rather see this kind of thing eliminated from programming communities
07:48:56 <djahandarie> Are single character words reserved? Never seen one before
07:48:59 <djahandarie> nicks*
07:49:08 <ray> drive-by MIAMI STYLE
07:49:09 <mreh> koeien37, hi, my name is boxy!
07:49:12 <ray> YEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH
07:49:13 <k> hai
07:49:15 <SamB_XP> djahandarie: they're presumably all registered ;-)
07:49:18 <djahandarie> k, is that registerable?
07:49:23 <Twey> I don't think they're reserved, it's just that everybody took them within the first few days of FreeNode :þ
07:49:26 <djahandarie> Haha
07:49:27 <koeien37> no, already registered
07:49:32 <djahandarie> Sort of like the internet
07:49:34 <lpsmith> koeien37,    yeah,  I mean, I am no prude,  but it can make people uncomfortable.
07:49:39 <Twey> koeien37: Mm, I can kind of agree.
07:49:49 <djahandarie> Except the internet has all permutations of 4 letters registered already. T_T
07:49:55 <Ke> the thing is, you get slightly more spam, if you have a very short nick
07:50:01 <lpsmith> I mean,  there are almost no women that participate in our community
07:50:05 <djahandarie> And about every word in the English dictionary
07:50:25 <copumpkin> lpsmith: more than elsewhere, maybe
07:50:27 <ray> when i was camping "r", i got messaged regularly by some bot trying to identify to me
07:50:27 <Ke> but nowadays there isn't much spam anyways in irc
07:50:35 <lpsmith> That's common in programming, but it seems things such as PHP, for example,  do have a sizable female contingent
07:51:10 <djahandarie> I wish I could meet a woman who programmed Haskell
07:51:11 <lpsmith> copumpkin:   Maybe,  I don't really have a feel for it.  My impression is that we have fewer females than many.
07:51:14 <djahandarie> That would be... hot
07:51:18 <Ke> isn't php like the ugliest language of them all
07:51:22 <mreh> haskgurl
07:51:24 <djahandarie> > cycle "fap "
07:51:25 <lambdabot>   "fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fap fa...
07:51:35 <Zeiris> HA
07:51:45 <_JFT_> djahandarie: that might be 'dis'functional ;)
07:51:49 <ray> a still more glorious dawn awaits, not a sunrise, but a galaxyrise
07:51:58 <lpsmith> Most of the female programmers I've known really like PHP
07:52:08 <lpsmith> well, I shouldnt' say most
07:52:15 <SamB_XP> djahandarie: hot as in Higher-Order Typed ?
07:52:17 <mreh> i know lots of women who like HTM:
07:52:27 <SamB_XP> HTM: ?
07:52:30 <mreh> HTML
07:52:33 <SamB_XP> is that a new variant of HTML?
07:52:37 <Twey> Heh
07:52:40 <koeien37> the ; and l are next to each other
07:52:43 <djahandarie> HTML5 went down the drain
07:52:52 <mreh> it's HTML for anal people
07:52:53 <djahandarie> So they decided to move to special characters
07:53:01 <SamB_XP> lol
07:53:20 <Twey> koeien37: No they're not!  They're on opposite corners of the keyboard!  :þ
07:53:29 <koeien37> dvorak?
07:53:36 <skorpan> yes, ; and L are right next to each other
07:53:38 <mreh> Twey: qwerty layout
07:53:51 <koeien37> > '1' /=
07:53:52 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:53:55 <koeien37> > '1' /= 'l'
07:53:56 <lambdabot>   True
07:54:11 <Twey> koeien37: Yeah
07:54:17 <djahandarie> Man, I've been meaning to try Dvorak some time
07:54:25 <djahandarie> But I'm not always on my own computer
07:54:32 <mreh> it's a waste of time in my mind
07:54:38 <koeien37> I don't think you will un-learn qwerty
07:54:40 <djahandarie> So I won't be able to do it 100%
07:55:01 <koeien37> I'm not convinced that it's going to give considerable speedups, enough for me to warrant learning it
07:55:07 <djahandarie> My WPM on Qwerty has maxed out at like 120
07:55:22 <djahandarie> I want to go faster... :P
07:55:24 <koeien37> i have about 300 characters per minute
07:55:25 <Twey> It doesn't give me much in the way of speed-ups, but it does stop the aches in my wrists
07:55:30 <Olathe> It doesn't speed me up, but it is more comfortable to type.
07:55:39 <zygoloid> djahandarie: i thought the 'dvorak makes you type faster' thing was a myth invented by Dvorak to keep his Navy funding?
07:55:55 <zygoloid> i think it is supposed to reduce the risk of RSI though
07:56:03 <mreh> qwerty was designed to slow you down, that's where the myth comes from
07:56:14 <mreh> infact it was designed to stop typewriter jams
07:56:19 <Zeiris> What are the hjkl keys on dvorak? :(
07:56:28 <Olathe> dhtn
07:56:30 <mreh> you have to switch hands more often with qwerty
07:56:35 <mreh> unless you type "qwerty"
07:56:36 <koeien37> yeah, I'd need to rebind my vim bindings then :)
07:57:05 <mreh> they never suspected that one
07:57:26 <mreh> so what does guard do? always return monad zero if the condition is not met?
07:57:29 <ray> but switching hands makes you faster
07:57:34 <koeien37> @src guard
07:57:34 <lambdabot> guard True  =  return ()
07:57:35 <lambdabot> guard False =  mzero
07:57:42 <koeien37> mreh: so, Yes!
07:58:14 <ray> ideally you want to switch hands every single character for maximum speed
07:58:23 <mreh> return () >>= [1,2,3]
07:58:26 <mreh> > return () >>= [1,2,3]
07:58:27 <lambdabot>   Couldn't match expected type `() -> m b'
07:58:27 <lambdabot>         against inferred type `[a]'
07:58:46 <koeien37> > return () >> [1,2,3]
07:58:47 <lambdabot>   [1,2,3]
07:58:48 <mreh> um
07:58:54 <koeien37> > mzero >> [1,2,3]
07:58:54 <mreh> that's the on
07:58:55 <lambdabot>   []
07:59:13 <Olathe> > mone
07:59:15 <lambdabot>   Not in scope: `mone'
07:59:36 <koeien37> > do { x <- [1..4]; guard (x > 3); return x }
07:59:36 <lambdabot>   [4]
08:00:16 <copumpkin> > [x | x <- [1..4], x > 3]
08:00:16 <copumpkin> zomg
08:00:18 <lambdabot>   [4]
08:01:27 <ray> zone of omg
08:02:10 <mreh> so list comprehensions are a 1-1 mapping onto list monad functionality
08:02:11 <mtnviewmark> anyone know of a class like Monoid but where the combining function is a -> b -> a  (a is the "accumulating" thing)    (where as Monoid's mappend is a -> a -> a)
08:02:23 <Olathe> @undo [x | x <- [1..4], x > 3]
08:02:23 <lambdabot> concatMap (\ x -> if x > 3 then [x] else []) [1 .. 4]
08:02:27 <Olathe> IT goes to that
08:02:28 <koeien37> that would be a MPTC
08:02:47 <koeien37> @src Foldable
08:02:47 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:03:02 <copumpkin> mtnviewmark: an r-module! minus all the extra properties ;)
08:03:14 <koeien37> yeah it's like scalar multiplication :)
08:03:17 <mreh> Olathe: i'm sure that's identical to the list monad way
08:03:28 <Olathe> @src concatMap
08:03:29 <lambdabot> concatMap f = foldr ((++) . f) []
08:03:34 <Olathe> Yeah, I think so.
08:03:54 <mtnviewmark> "r-module" sounds like something Scooby-Doo would say --- a higher-order abstract Scooby-Doo that is!
08:04:09 <koeien37> class AbelianGroup m => Module r m where scalarMult :: r -> m -> m
08:04:10 <copumpkin> mtnviewmark: it's like a vector space but over a ring instead of a field
08:04:10 <HaskellLove> I still dont get it why sometimes i can use partial functions like map (-1) and sometimes i must use map (\x-> x-1) otherwise i get errors
08:04:25 <copumpkin> HaskellLove: that's the only one
08:04:25 <koeien37> HaskellLove: (-1) is minus 1, not a section.
08:04:33 <Olathe> HaskellLove: The minus operator is messed up a bit.
08:04:38 <koeien37> HaskellLove: very unfortunate. You can use 'subtract'
08:04:45 <Olathe> > ((-)1) 5
08:04:46 <lambdabot>   -4
08:04:52 <HaskellLove> aha thank you
08:05:01 <koeien37> > map (subtract 1) [1,2,3]
08:05:02 <lambdabot>   [0,1,2]
08:05:05 <copumpkin> @let (–) = (-)
08:05:06 <lambdabot>  Defined.
08:05:10 <copumpkin> > map (–1) [1..5]
08:05:11 <lambdabot>   [0,1,2,3,4]
08:05:36 <mtnviewmark> I suppose what I want is something that would be called: Unfoldable!
08:05:47 <koeien37> mtnviewmark: a left module is an abelian group with scalar multiplication of a ring. So it's like a "vector space over a ring" in some sense
08:05:48 <Olathe> copumpkin: Haha
08:05:50 <copumpkin> mtnviewmark: what's the application?
08:06:34 <mtnviewmark> Oh - I'm way yak shaving a problem here, but I want a class of things that can Word8 values applied, eventually yielding a "completed" thing
08:07:04 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
08:07:07 <copumpkin> maybe?
08:07:07 <koeien37> don't you want Foldable?
08:08:04 <mtnviewmark> kind of runs the other way -- unpacking a collection
08:08:13 <mtnviewmark> I want to pack one up
08:08:24 <copumpkin> hmm
08:08:30 <copumpkin> this is just an arbitrary fold over a structure
08:08:47 <koeien37> then it's more like a -> (a,b) isn't it?
08:08:54 <koeien37> or a -> Maybe (a,b)
08:09:01 <mtnviewmark> yes, that is one Builder instance
08:09:13 <copumpkin> that's Unfoldable! :P
08:09:31 <mtnviewmark> Yes - exactly - but where is Unfoldable?!?!?
08:09:41 * hackagebot upload: happstack-dlg 0.1.1 - Cross-request user interactions for Happstack (ChrisSmith)
08:09:49 <copumpkin> mtnviewmark: so you want an anamorphism ;)
08:10:04 <mtnviewmark> yikes, my goofy implementation might turn into a use package? Unfoldable?
08:10:06 <mtnviewmark> hmmmmm.....
08:10:25 <mtnviewmark> okay- let me finish speeding up the uuid package (what I'm ostensibly doing)
08:10:31 <mtnviewmark> then I'll look into generalizing it
08:11:03 * copumpkin coughs: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Ana.html
08:11:03 <copumpkin> ana :: Functor f => Coalgebra f a -> a -> FixF f
08:11:03 <copumpkin> clearly ;)
08:12:00 <copumpkin> :)
08:12:13 <koeien37> coalgebra's
08:12:19 <mtnviewmark> on a tangent (not that I need it now), which is considered a more "safe" extension: FunctionalDependencies or TypeFamilies ?
08:12:25 <koeien37> what is a coalgebra in this context?
08:12:36 <copumpkin> koeien37: a -> f a
08:12:39 <koeien37> i'd use TypeFamilies now, just because they're cool and shiny and new
08:12:49 <SamB_XP> koeien: an algebra class with girls
08:12:51 <koeien37> copumpkin: so a categorical coalgebra
08:12:56 <copumpkin> yep
08:13:00 <copumpkin> f-
08:13:55 <koeien37> I'm more used to "algebra" as a module with multiplication
08:14:05 <copumpkin> yeah, damn overloading of terms :)
08:14:11 <copumpkin> f-algebra and f-coalgebra
08:15:26 <copumpkin> a 李-algebra
08:15:28 * copumpkin chuckles
08:15:52 <koeien37> that's a plum?
08:15:53 <koeien37> why?
08:15:56 <mtnviewmark> that's almost exactly why I wouldn't want to use TypeFamilies -- because they are new, and I worry subject to change and possible discard ---- that said, I think they are clearer than FunctionalDependencies (if a little more verbose of the simple cases)
08:16:10 <copumpkin> koeien37: a li-algebra ;)
08:16:26 <koeien37> heh. I didn't know the pronunciation
08:16:28 <mtnviewmark> actually, I like the idea of a plum-algebra
08:17:06 <copumpkin> :)
08:18:43 <copumpkin> I guess monochrom's last name would work too
08:22:18 <koeien37> mtnviewmark: Fundeps might also be on the way out. no way to tell yet
08:22:33 <koeien37> there was a thread on the haskell-cafe about this topic recently
08:22:50 * koeien37 is totally going to confuse his profs with 李-algebras
08:22:51 <SamB_XP> mtnviewmark: mmm, delicious!
08:23:10 <SamB_XP> koeien37: because they won't be able to figure out how to pronounce it ?
08:23:24 <koeien37> right :)
08:24:31 <copumpkin> :)
08:24:48 <copumpkin> lie algebras are awesome!
08:25:25 <osfameron> knaves and knights?
08:26:10 <HaskellLove> should I use head instead of !!0 ?
08:26:15 <koeien37> definitely
08:26:22 <copumpkin> take 1 is even better
08:26:22 <koeien37> and if you can, pattern matching
08:26:31 <copumpkin> and that's best :)
08:27:33 <HaskellLove> why is take 1 better then head, i just need to get the first element of a finite list
08:27:39 <koeien37> take 1 is total
08:27:43 <Saizan> i don't see much different between head and (!!0)
08:27:45 <osfameron> HaskellLove: [] is a finite list
08:27:59 <koeien37> Saizan: there isn't, it's style. I think head is far more idiomatic
08:28:17 <koeien37> > take 1 [] -- no crash!
08:28:19 <lambdabot>   []
08:28:28 <HaskellLove> well i dont care about style, more about speed, if it is same then i will use head, it is kinda sexier
08:28:38 <koeien37> if anything, head is faster
08:28:41 <copumpkin> HaskellLove: best is pattern matching
08:28:55 <copumpkin> lpsmith: have you tried agda btw?
08:29:12 <HaskellLove> isnt head and !!0 compiled to the same thing below?
08:29:13 <zygoloid> !!1 is much l33ter than head . tail
08:29:22 <lpsmith> not seriously,  not yet
08:29:24 <lpsmith> I should
08:29:30 <zygoloid> srsly!!1
08:29:33 <koeien37> probably. but it's never a bottleneck
08:29:35 <SamB_XP> HaskellLove: head might be more efficient
08:29:39 <copumpkin> lpsmith: srsly!!1
08:29:42 <SamB_XP> but won't be any less efficient
08:29:45 <lpsmith> lol
08:29:46 <SamB_XP> depends on compiler and settings
08:30:04 <lpsmith> Last I played with it, documentation was seriously lacking
08:30:08 <HaskellLove> zygoloid agree
08:30:10 <Olathe> @let head' [] = []; head' (x:_) = x in head' [1..]
08:30:11 <lambdabot>   Parse error: KW_In
08:30:15 <Olathe> Bah
08:30:17 <lpsmith> but I understand it's gotten a lot better
08:30:29 <Olathe> @let head2 [] = []; head2 (x:_) = x in head2 [1..]
08:30:30 <lambdabot>   Parse error: KW_In
08:30:37 <sproingie> !! 1 basically *is* head, but it's a matter of the intent you're expressing
08:30:39 <koeien37> Olathe: @let is for definitions, not expressions
08:30:40 <Olathe> Hmm...
08:30:42 <copumpkin> lpsmith: oh, it's still pretty bad, documentation-wise, but #agda is nice and there's a decent mailing lis
08:30:51 <SamB_XP> sproingie: !!0
08:30:52 <SamB_XP> not !!1
08:30:52 <Olathe> Oh, editing error :) Thanks
08:30:55 <lpsmith> heh
08:30:56 <Olathe> > let head2 [] = []; head2 (x:_) = x in head2 [1..]
08:30:58 <lambdabot>   No instance for (GHC.Enum.Enum [a])
08:30:58 <lambdabot>    arising from the arithmetic sequence...
08:31:09 * sproingie facepalms.  yes., zero-based
08:31:13 <Olathe> > [1..]
08:31:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:31:24 <SamB_XP> sproingie: what's with the "DEL" character ?
08:31:27 <sproingie> i'll do my 20 Hail Dijkstras
08:31:28 <koeien37> > let head2 [] = []; head2 (x:_) = [x] in head2 [1..]
08:31:31 <lambdabot>   [1]
08:31:32 <copumpkin> lpsmith: interesting blog post btw :)
08:31:34 <osfameron> (_:x:_) for !!1
08:31:48 <sproingie> SamB_XP: irssi and ssh lag i guess
08:31:49 <lpsmith> thanks,  I was pretty pleased with it
08:31:52 <koeien37> yeah, (!!) is pretty ugly imo
08:32:08 <osfameron> it's deliberately ugly isn't it?
08:32:08 <SamB_XP> so that was an actual DEL character ?
08:32:11 <zygoloid> > srslys!!1
08:32:12 <lambdabot>   srsly
08:32:15 <lpsmith> Although what I came up with seems so obvious in retrospect that it's almost embarrassing how much time I spent on it this year
08:32:16 <SamB_XP> not the DEL-rendering character ?
08:32:24 <sproingie> SamB_XP: that was me hitting DEL and irssi deciding to send it instead of locally deleting
08:32:28 <Olathe> Oh !
08:32:30 <osfameron> take 2 srslys
08:32:34 <osfameron> > take 2 srslys
08:32:35 <copumpkin> lpsmith: it still isn't obvious to me, if that's any consolation :P
08:32:36 <lambdabot>   [srsly,srsly]
08:32:36 <Olathe> koeien37: Thanks
08:32:47 <copumpkin> lol
08:32:51 <sproingie> SamB_XP: irssi's reinvention of curses is not without bugs
08:32:52 <zygoloid> osfameron: no!
08:33:19 <copumpkin> > take 2 wtfs
08:33:20 <lambdabot>   [wtf,wtf]
08:33:22 <sproingie> its redisplay is awesomely buggy, i sometimes get parts of the wrong channel in another when i switch
08:33:40 <SamB_XP> sproingie: you're sure you didn't get a bad version ?
08:33:56 <osfameron> :t wtfs
08:33:57 <lambdabot> forall a. [Sym a]
08:34:03 <sproingie> > take 2 wtfs >> when morning $ call me
08:34:04 <lambdabot>   Not in scope: `morning'Not in scope: `call'Not in scope: `me'
08:34:08 <mauke> I think that's unicode related
08:34:09 <SamB_XP> > f wtf
08:34:10 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:34:11 <lambdabot>    `SimpleReflect.FromExpr ...
08:34:15 <osfameron> @index Sym
08:34:16 <SamB_XP> awwwww
08:34:16 <lambdabot> bzzt
08:34:27 <sproingie> SamB_XP: it's whatever is current in Sid
08:34:27 <osfameron> that's a lisp-like Symbol ?
08:34:35 <zygoloid> > map lol wtfs
08:34:36 <lambdabot>   Ambiguous type variable `b' in the constraints:
08:34:37 <lambdabot>    `SimpleReflect.FromExpr ...
08:34:37 <lpsmith> copumpkin:  I think the one post before it was really very helpful mental emancipation from continuations
08:34:39 <sproingie> actually i havent had the redisplay bug for a long time
08:34:42 <zygoloid> > map lol wtfs :: [Expr]
08:34:43 <SamB_XP> sproingie: ah, maybe you should try testing instead ;-P
08:34:43 <lambdabot>   [lol wtf,lol wtf,lol wtf,lol wtf,lol wtf,lol wtf,lol wtf,lol wtf,lol wtf,lo...
08:34:57 <lpsmith> And I think monochrom's example may have subconciously helped as well
08:34:58 <Olathe> zomg
08:35:00 <zygoloid> > zipWith lol wtfs srsly :: [Expr]
08:35:01 <lambdabot>   Not in scope: `srsly'
08:35:05 <zygoloid> > zipWith lol wtfs srslys :: [Expr]
08:35:06 <lambdabot>   [lol wtf srsly,lol wtf srsly,lol wtf srsly,lol wtf srsly,lol wtf srsly,lol ...
08:35:11 <Olathe> Haha
08:35:14 <sproingie> lolskell
08:35:29 <osfameron> what's a Sym?  they don't have initial Capital letter, so it's not a constructor ?
08:35:45 <sproingie> capitals are always types or constructors
08:35:54 <sproingie> (or classes)
08:35:54 <koeien37> or typeclasses
08:36:03 <koeien37> or module names
08:36:05 <zygoloid> osfameron: it's more-or-less a String with show = id
08:36:11 <zygoloid> plus lots of exciting instances
08:36:16 <osfameron> but where does it live?
08:36:22 <sproingie> i always thought it odd that constructors used caps
08:36:24 <zygoloid> @hackage simple-reflect
08:36:24 <lambdabot> http://hackage.haskell.org/package/simple-reflect
08:36:28 <sproingie> since they're functions, not part of the type language
08:36:40 <koeien37> they're more than that, you can pattern match on 'em
08:36:56 <sproingie> yah there's that
08:37:03 <mauke> constants are capitalized, variables aren't
08:37:05 <sproingie> they represent the bridge i guess
08:37:08 <copumpkin> > foldr f z [a,b,c]
08:37:09 <lambdabot>   f a (f b (f c z))
08:37:19 <koeien37> f Nothing, f nothing
08:37:20 <sproingie> mauke: ain't everything constant? :)
08:37:24 <koeien37> this would get *very* confusing
08:37:53 <koeien37> and a source of numerous bugs (code compiles if Maybe is not in scope, but might do something different)
08:38:05 <copumpkin> > foldr (fun "the_function) (var "the_base_case") [var "the_first_variable", var "the_second_variable", var "the_third_variable"]
08:38:07 <lambdabot>   <no location info>:
08:38:11 <lambdabot>      lexical error in string/character literal at end o...
08:38:11 <copumpkin> :(
08:38:57 <zygoloid> > foldr (fun "the_function") (var "the_base_case") [var "the_first_variable", var "the_second_variable", var "the_third_variable"]
08:38:58 <mauke> > foldr (fun "the function") (var "the_base_case") [var "the_first_variable", var "the_second_variable", var "copumpkin"]
08:38:59 <lambdabot>   No instance for (SimpleReflect.FromExpr
08:38:59 <lambdabot>                     (Data.Number.Sy...
08:38:59 <lambdabot>   No instance for (SimpleReflect.FromExpr
08:38:59 <lambdabot>                     (Data.Number.Sy...
08:39:03 <mauke> hah
08:39:05 <zygoloid> > foldr (fun "the_function") (var "the_base_case") [var "the_first_variable", var "the_second_variable", var "the_third_variable"] :: Expr
08:39:06 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
08:39:06 <lambdabot>         against inferred ...
08:39:11 <sproingie> > FOLD RIGHT USING FUNCTION (+) WITH BASE CASE 0 WITH LIST [2..20].
08:39:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:39:20 <koeien37> :: COBOL
08:39:22 <copumpkin> #cobol kthx
08:39:23 <lunabot>  luna: Not in scope: `cobol'
08:39:25 <mauke> GOTO 10
08:39:27 <sproingie> oh right i forgot that
08:41:26 * osfameron wonders if single-assignment analysis and escape analysis (~terminology?~) could be used to parse a cobol program and turn it into something with actual functions
08:42:12 <osfameron> (as mostly, cobol programs just read and write bits of global data, for great comic effect)
08:43:14 <sshc> :t zip
08:43:15 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
08:46:50 <sproingie> COBOL monad, eh?
08:52:19 <SamB_XP> sproingie: and I thought the BASIC library was evil ...
08:52:53 <conal> copumpkin: please do start your own blog.  and moderate for quality.  then you're building something of value in a place people who are genuinely curious can find it.
08:53:47 <mtnviewmark> just how awful are orphan instances?
08:56:08 <sproingie> they're not, really.  confusing to find maybe.
08:56:30 <copumpkin> conal: :) I'll make an effort in the next few days to get something set up, before term starts again
08:56:58 <mtnviewmark> do they "leak" into the whole program if just one module imports a module that defines one?
08:57:08 <conal> copumpkin: i'm glad to hear.  i'll read your new blog faithfully.
08:57:09 <mtnviewmark> or is it "confined" to just that importing module
08:57:23 <sproingie> i think the main problem with orphan instances is it makes another instance possible to clash
08:57:38 <sproingie> on the other hand that can be on purpose (the possibility, not the actual clashing)
08:59:01 <mtnviewmark> hmm.. .If two modules each have the same orphan instances for use internally, can the both be safely imported by another module?
08:59:17 <mtnviewmark> or another way to ask that is: Is there a way to safely "seal" an orphan instance to a package?
08:59:18 <copumpkin> conal: thanks!
08:59:24 <copumpkin> mtnviewmark: nope
08:59:37 <sproingie> instances are promiscuous
08:59:54 <sproingie> or maybe better term is slippery, they escape whenever they can
09:00:03 <conal> copumpkin: i hardly ever play the convince-the-skeptic game any more.  it's so much easier for them to remain thick-headed, play bait&switch, conjure more specious arguments, etc, than it is for me to pin them down to clear & rational inquiry.
09:00:30 <Lycurgus> amen
09:00:34 <mtnviewmark> hmmm..... that seems like an "issue"!
09:00:39 <copumpkin> yeah, it's true. I tried dealing with a particularly trollish guy on reddit the other day and he at least refrained from calling me a bunch of swearwords, but definitely got no less thick
09:00:50 <conal> so instead i like to invest my energy where i believe there's genuine curiosity.
09:01:12 <copumpkin> makes sense :)
09:01:22 <sproingie> i just dismiss with "okay, you go ahead and be right if that makes you feel better"
09:01:51 <conal> copumpkin: though sometimes i still indulge in reddit.
09:02:54 <fabjan> My http proxy blocks reddit
09:02:55 <sproingie> haskell.reddit is a nice collection of bookmarks.  rest of reddit i can't stand
09:02:55 <sproingie> especially politics
09:03:03 <fabjan> I like to believe it helps me :)
09:04:35 <Lycurgus> couple questions: 1) is darcs still the premiere haskell app and 2) what happened with perl 6 being haskell based, did that die off like expected?
09:05:33 <sproingie> pugs was an implementation of perl6, it wasn't necessarily intended to be *the* implementation
09:06:02 <sproingie> rakudo is much further along than pugs
09:06:15 <Lycurgus> ruby based?
09:06:23 <sproingie> what makes you say that?
09:06:28 <Lycurgus> rak-
09:06:38 <sproingie> why does that automatically mean ruby?
09:06:45 <sproingie> it's a word
09:06:55 <Lycurgus> not automatically, just suggests it (to me)
09:07:00 <copumpkin> R is written in ruby too ;)
09:07:15 <copumpkin> Lycurgus: it's just a japanese word
09:07:15 <Lycurgus> R <- S
09:07:16 <sproingie> rakudo is mostly written in perl6 itself with a C core
09:07:23 <Lycurgus> ah
09:07:25 <conal> i just finished skimming through that reddit thread (http://www.reddit.com/r/programming/comments/ajztk/followup_to_functional_programming_doesnt_work/).  one thought: the critics are more-or-less correct in saying that we pure do not know how to construct large-scale pure functional programs in many domains.  i'm okay with that reality, and because FP is so compelling to me, i'm working on the problem.
09:07:45 <Twey> Lycurgus: http://en.wikipedia.org/wiki/Pugs#Development_model
09:07:56 <Twey> Looks like Tang ended up with other things on her plate
09:07:56 <Lycurgus> Twey, thx
09:08:18 <conal> i suspect the pure FP community invites criticism by not being more upfront about where we really are in our endeavor.
09:08:40 <copumpkin> yeah
09:08:43 <Twey> Rakudou means ‘the easy road’… I wonder if that's meant to be a crack at Pugs/Haskell :þ
09:10:02 <sproingie> tang is still doing perl6, not sure about pugs
09:10:17 <Lycurgus> ruby's not that bad btw, certainly upon examination I think most here would think it better than perl or php
09:10:26 <sproingie> pugs is interesting, anyone who wants a commit bit gets one.  she set it up as deliberate anarchy
09:10:57 <c_wraith> the problem with ruby is the collection of incredibly bad software engineering practices that have been accepted as the ruby way.
09:11:09 <Twey> Yeah
09:11:19 <sproingie> i would say pugs was actually the easier road
09:11:22 <Twey> Certainly better than PHP, of course… Perl, maybe not
09:11:23 <Raevel> oh, i know i knew this... what package should i use for working with user configuration files?
09:11:34 <Twey> Raevel: Dyre?  HsLua?
09:11:39 <sproingie> rakudo faces a much harder problem of bootstrapping the language
09:12:05 <EvanCarroll> I don't understand the significance of the commit bit crap with pugs.
09:12:15 <sproingie> it isn't, really
09:12:20 <Raevel> Twey: too advanced, i'm thinking more like "ini files" :-)
09:12:20 <Twey> Oh, maybe it was actually ‘rakudo’, ‘paradise’.  D'oh.
09:12:23 <gio123> happy new year
09:12:25 <EvanCarroll> it seems like a shitty attempt to get the same cooperation that git does more successfully and controlably.
09:12:32 <sproingie> version control means you can run it wiki style and revert anything bad
09:12:33 <Twey> Raevel: Lua allows you to write files like that
09:12:43 <Twey> (but also offers more power if the user needs it)
09:12:55 <sproingie> Tang is a little bit pretentious about the whole anarcho-syndicalism thing
09:12:56 <Lycurgus> so there's a yawning divide between more or academics finding it (haskell/pure fp) compelling and most everybody else finding it useless
09:13:13 <conal> also, the OP (FP doesn't work) says that 100% pure FP doesn't work but 85% pure does.  perhaps an accurate description of the current state of Haskell programming, which uses IO semantics for perhaps 15% of a problem solution and pure (denotational) functional about 85%.
09:13:28 <shapr> djahandarie, "cycle fap" is a good way to get banned.
09:13:51 <EvanCarroll> I'd be curious to know what was wrong with having written perl6 in haskell?
09:13:52 <Twey> conal: Well, of course 100% pure FP is good for nothing but heating up the processor :þ
09:13:59 <djahandarie> shapr, sorry sir.
09:13:59 <conal> Lycurgus: that yawing divide may be typical of progress in any field.
09:14:02 <Lycurgus> *more or less academics
09:14:03 <EvanCarroll> I heard a lot of arguments it was slow, was it bad haskell code?
09:14:23 <jmcarthur> conal: my issue is with the dismissive nature of both extreme sides of the debate
09:14:30 <conal> Twey: 100% pure works well for me in ghci.
09:14:34 <sproingie> Twey: you can get information out of heat patterns, so there's your output :)
09:14:41 <Lycurgus> conal, yes but look out for failure to obtain closure.
09:14:42 <conal> jmcarthur: me too.
09:15:00 <Twey> canvon: That's just having GHCi do the impure bit (that the Haskell runtime usually does)
09:15:05 <Twey> sproingie: Haha, point :þ
09:15:13 <sproingie> EvanCarroll: pugs was just a straight interpreter
09:15:14 <sproingie> was/is
09:15:20 <Lycurgus> (especially after 20 or 30 years of effort with a huge ramp up at the end)
09:15:20 <Twey> Really?  WP says it compiles too
09:15:29 <sproingie> it can generate PIR code, yes
09:15:31 <sproingie> which parrot then runs
09:15:33 <sproingie> not pugs
09:15:37 <Twey> *nod*
09:15:41 <Twey> So it's a compiler, too
09:15:41 <conal> the situation could be much worse. at least we FPers are not hunted and burned at the stake.  so we get to keep working on the problems and making progress.
09:15:44 <sproingie> yep
09:15:49 <EvanCarroll> just interpreter? or did it compile to bytecode?
09:15:55 <ColonelJ> I don't understand the point on that page about functional languages being necessarily too inefficient for making games, surely it's all a matter of optimization
09:15:58 <sproingie> i dont think it implements as much of perl6 as rakudo tho
09:15:59 <SamB_XP> conal: true
09:16:13 <sproingie> ColonelJ: it's a matter of radically rethinking the problem too
09:16:16 <conal> good enough for me.
09:16:18 <SamB_XP> considering how many of us are heathens, I suppose that's a good thing ?
09:16:19 <EvanCarroll> there is an fps made in haskell
09:16:49 <SamB_XP> EvanCarroll: but has it been ported to Reactive ?
09:16:52 <sproingie> much as i love the idea of frag, it ain't as zippy as a C++ version
09:17:08 <EvanCarroll> http://www.haskell.org/haskellwiki/Frag
09:17:27 <SamB_XP> perhaps I ought to be asking Conal this ;-)
09:17:48 <sproingie> so it's not impossible, but games like FPS's have an incessant demand to squeeze all performance out of a CPU
09:17:57 <conal> SamB_XP: i doubt it has.
09:17:58 <sproingie> still, a lot of game logic is getting more functional
09:17:59 <ColonelJ> "(Note that these screenshots are of the old level, which was replaced for copyright reasons.) "
09:18:08 * SamB_XP wishes he could get ahold of the Windows 3.1 SDK ...
09:18:15 <EvanCarroll> the new one is better or worse?
09:18:18 <sproingie> ColonelJ: it uses Quake3 assets
09:18:21 <jmcarthur> It irritates me when somebody claims that the best we can do is 85% pure for complex systems, even if in practice *so far* that is what is mostly achieved.
09:18:24 <copumpkin> SamB_XP: you and your reversing archeology
09:18:39 <SamB_XP> copumpkin: well, in this case I want it for their debugger
09:18:50 <SamB_XP> and, well, headers and .libs are also nice
09:18:54 <neosoothsayer> Hello everyone - I am newbie who's interested in learning about Haskell. What is a good introductory book, but which also covers some of the philosophy behind Haskell?
09:18:55 <sproingie> i don't see a functional language running the input and render loop of a game engine in my lifetime
09:19:02 <sproingie> however there's no reason everything else can't go more functional
09:19:02 <conal> jmcarthur: without acknowledging the difference between "can do" and "have done"?
09:19:02 <Twey> There was an interesting article on LtU
09:19:05 <copumpkin> @where lyah
09:19:06 <lambdabot> http://www.learnyouahaskell.com/
09:19:08 <Lycurgus> you mean codeview?
09:19:09 <copumpkin> @where rwh
09:19:09 <SamB_XP> copumpkin: how do YOU want to run simtower on a 64-bit OS ?
09:19:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:19:14 <Twey> http://lambda-the-ultimate.org/node/1277 — here we are
09:19:15 <jmcarthur> conal: indeed
09:19:21 <copumpkin> neosoothsayer: bird's book is also supposed to be good
09:19:26 <sproingie> as it is even the rendering functionality has gone more functional
09:19:27 <conal> sproingie: or maybe there is a reason we can't go further.  we don't know yet.
09:19:29 <sproingie> shaders are basically functional
09:19:41 <SamB_XP> sproingie: indeed
09:19:48 <Twey> It seems to be saying that the main reasons for not using Haskell are 1) no dependent types and 2) the devs are scared of it :þ
09:19:53 <neosoothsayer> copumpkin: bird book?
09:19:58 <SamB_XP> they more-or-less have to be to be, to be efficient
09:19:59 <copumpkin> neosoothsayer: http://www.amazon.com/Introduction-Functional-Programming-using-Haskell/dp/0134843460 for example, but the other two are available on the web which makes it quicker :)
09:19:59 <conal> sproingie: yeah.  graphics is very naturally functional.  it's mostly made up of pure functions.
09:20:06 <Jafet> Games have always been based on imperative programming.
09:20:09 <jmcarthur> conal: although if i recall correctly there were also some qualifiers applied to that statement which weakens it a bit. i don't have the article up right now
09:20:20 <Jafet> You can't build efficient functional programs on top of massive imperative foundations
09:20:21 <SamB_XP> Jafet: well, they've always involved a fair amount of it, yet
09:20:23 <copumpkin> neosoothsayer: having said that, I haven't read any of those, so I don't really know
09:20:24 <neosoothsayer> copumpkin: thanks!
09:20:25 <SamB_XP> s/yet/yes/
09:20:47 <SamB_XP> but there have also always been rather non-imperative things here and there ...
09:21:01 <SamB_XP> at least conceptually
09:21:07 <sproingie> unreal engine has a graphical dataflow language, that's quite functional
09:21:14 * copumpkin is more of a subjunctive person than an imperative one
09:21:26 <sproingie> not sure how many AAA titles actually use kismet
09:21:31 <copumpkin> maybe indicative
09:21:40 <SamB_XP> sproingie: are you talking about their material system ?
09:21:43 <jfoutz> conal: after my 837th read of your push pull frp paper, i was thinking ... another nice optimization, in addition to the constant reactive value, a bifuncotor behavor Time->a, a->Time would be *super* handy for implementing when. of course, it would need to be monotonic or add crazy semantics for a behavior like sin(time)
09:21:46 <conal> maybe we can't straighten out the nay sayers, but we can make a shift to more honest and humble expressions of our own.
09:21:52 <SamB_XP> to borrow a term from POV-Ray
09:22:03 <sproingie> SamB_XP: thinking more of kismet, which is general scripting logic
09:22:12 <SamB_XP> sproingie: hmm, I haven't seen that
09:22:19 <SamB_XP> I've only really seen the UnrealScript
09:22:32 <SamB_XP> what version of the engine has this Kismet thing ?
09:22:40 <sproingie> SamB_XP: http://www.unrealtechnology.com/features.php?ref=kismet
09:22:49 <sproingie> eh that's not a good link
09:22:59 <SamB_XP> i.e. what release of UT would you need to use to play with it ?
09:23:00 <sproingie> it does have a couple screenshots you can click to expand tho
09:23:18 <conal> for instance, championing "pure FP" and then sneaking in imperative computation via IO is begging for criticism.
09:23:19 <SamB_XP> I only have UT 2k3, and I have no hardware on which to run it in any case ...
09:23:36 <sproingie> SamB_XP: you would need UT3
09:24:25 <jmcarthur> conal: THAT is our problem
09:24:44 <conal> i'd rather we said something like "we find pure (semantically transparent) FP compelling.  there are some things we don't yet know how to say, and we're working on them.  meanwhile, we're working with a cleanly stratified functional/imperative model."
09:24:47 <copumpkin> unfortunately, the things we need to interface with are still imperative
09:25:09 <copumpkin> so even if they're referentially transparent, we can't really get around an unsafePerformIO unless we go functional all the way down
09:25:10 <jmcarthur> i don't even know if humility is a prerequisite for recognizing that
09:25:14 <neosoothsayer> copumpkin: what books on Haskell have you read?
09:25:17 <sproingie> the underlying machine model is going to remain imperative for a while
09:25:19 <copumpkin> neosoothsayer: none :P
09:25:19 <ColonelJ> sproingie: the input loop and the render loop can be implemented as lazy lists no?
09:25:24 <conal> jmcarthur: yes.  and the imperative folks sense that we're trying to pull the wool over their eyes.  and they're right even if they're not smart enough to pin us down on the trickery.
09:25:27 <SamB_XP> I remember I was having the darndest time trying to get the AIs to understand the concept of a drawbridge for my final project -- didn't actually try writing any script for that, though ...
09:25:29 <sproingie> ColonelJ: not efficiently
09:25:30 <jmcarthur> copumpkin: so we should make a functional operating system ;)
09:25:32 <copumpkin> neosoothsayer: I just spew a load of bull and try to sound like I know what I'm talking about :)
09:25:49 <ColonelJ> sproingie: and the optimizer should be able to translate to the imperative machine level code
09:26:04 <SamB_XP> I don't think I ever quite managed to get them to understand it :-(
09:26:12 <sproingie> ColonelJ: a "sufficiently smart compiler" could do it theoretically, but we still don't have such a thing
09:26:24 <conal> copumpkin: that interfacing to imperative doesn't bother me a lot.  it happens all the time inside the implementation of pure FP stuff like numbers & lists.  we have a denotational explanation.
09:26:29 <SamB_XP> sproingie: those things are mythical ;-P
09:26:31 <ColonelJ> sproingie: instead you could use some sort of annotation thing to say to create a looping thread
09:26:39 <ColonelJ> without affecting the purity of the code
09:26:56 <sproingie> ColonelJ: haskell does a bang up job, but game engines tend to have unforgiving requirements like no gc in critical sections
09:27:26 <ColonelJ> couldn't you extend haskell to add such a feature?
09:27:33 <sproingie> you can write at the machine level now in ghc, it just looks hideous
09:27:35 <ColonelJ> again without affecting purity
09:27:35 <SamB_XP> extending would not do the trick
09:27:47 <SamB_XP> you would need *restrictions*
09:28:12 <SamB_XP> I mean, technically I guess the ability to describe such restrictions would *be* an extension ...
09:28:27 <sproingie> note that i'm only talking about the AAA game engines that demand all your CPU
09:28:56 <ColonelJ> I think demanding all your CPU is reasonable
09:29:00 <copumpkin> omnom
09:29:10 <SamB_XP> I wish they would only demand all of *my* CPU
09:29:18 <sproingie> i'm not saying it's impossible for functional languages, just that current compilers don't satisfy the demands these engines have
09:29:25 <SamB_XP> but noo, it has to be someone more up-to-date's CPU ...
09:29:32 <ColonelJ> sproingie: indeed, change is required
09:30:09 <sproingie> life is change.  functional's more poised to take advantage of multicore, but the imperative world will always feel free to borrow from functional where it suits them
09:30:27 <ColonelJ> yes certainly
09:30:27 <sproingie> fine by me.  if they can do that for C++ and fix the syntax i'd go back to it ;)
09:30:35 <SamB_XP> and really, the GC behaviour of GHC isn't really acceptable in real-time gaming unless you are using a comparatively quite small proportion of the total system resources ...
09:30:39 <holmak> On the other hand, I doubt any of us are going to try to develop on Unreal or Valve's level. We could easily make an indie-quality game with great performance.
09:30:44 <SamB_XP> er.
09:30:50 <SamB_XP> s/proportion/portion/
09:31:09 <Zeiris> With how heavily software relies on extremely specialized hardware on performance, and how much the development of that hardware has been motivated by imperative C-like languages, can something pure and functional ever compete without a change in the hardware?
09:31:20 <holmak> And by indie, I mostly mean 2D.
09:31:29 <copumpkin> Zeiris: look at GPUs
09:31:38 <sproingie> Zeiris: GPU hardware is largely functional
09:31:41 <SamB_XP> holmak: I wish they still did pro stuff in 2D :-(
09:31:45 <Jafet> You'd be surprised at how unsuitable C is to current architectures
09:31:49 <Zeiris> Wow, that was fast. Nevermind, point taken :D
09:31:50 <copumpkin> Zeiris: programming them is nothing like a typical programming language, and most people have great difficulty getting anything done with them
09:31:51 <sproingie> heck they didn't even get branch instructions til recently
09:32:03 <jfoutz> something mmo ish would be a lot easier, and perhaps more impressive.
09:32:05 <sproingie> even now they can only execute very localized branches
09:32:06 <edwardk> i would argue that gpu hardware is fairly dysfunctional ;)
09:32:12 <jmcarthur> architectures seem to be largely progressing in directions *favorable* to functional languages :)
09:32:18 <copumpkin> edwardk: shh, don't detract from the point! :P
09:32:21 <sproingie> edwardk: they're stream processors, they do the job nicely
09:32:23 <SamB_XP> edwardk: it's a bit of both worlds
09:32:50 <sproingie> MMO could really make use of STM i think
09:32:52 <Jafet> SamB_XP: http://scene.org/file.php?file=/parties/2008/breakpoint08/in64/pimpmyspectrum.zip&fileinfo
09:33:19 <holmak> MMOs are also a terrible idea. Unless your name is Blizzard, its not gonna work :/
09:33:20 <SamB_XP> Jafet: what are the HW requirements of that ?
09:33:31 <rbe> hi
09:33:37 <Jafet> Modern x86 running Windows, probably
09:33:44 <jfoutz> wow isn't that impressive graphicaly, it's the client communication.
09:33:44 <sproingie> there are tons and tons of smaller MMOs.  if your requirement is to take over the industry then yes you better be Blizzard
09:33:48 <SamB_XP> define "modern"
09:33:50 <Zeiris> The MMO market has plenty of room for fish to swim in. There's a bajillion niches WoW does not fill, which are nice and comfortable.
09:33:52 <edwardk> sproingie/samb: yeah, guess i'm just a bit bitter having worked in that world that there are so many rough edges and sharp corners on all of the architectures, and that there still are no good tools for abstracting over the domain
09:33:54 <SamB_XP> and it doesn't need a GPU or anything ?
09:34:08 <jfoutz> i mean... they have great art, but it's not cutting edge rendering.
09:34:13 <Jafet> jmcarthur, rather, functional programmers are finding new ways to do efficient code transformation
09:34:18 <sproingie> personally i think the MMO market is oversaturated but that's hardly relevant to writing a proof of concept
09:34:26 <SamB_XP> edwardk: but you'd have to admit that shader code isn't really very imperative, yes?
09:34:31 <sproingie> edwardk: have you looked at GPipe?
09:34:34 <edwardk> SamB_XP: i agree.
09:34:44 <Jafet> The upcoming parallelism bubble might bring something, though
09:35:03 <edwardk> sproingie: its cute
09:35:15 <SamB_XP> Jafet: oh, is it going to be a bubble then?
09:35:19 <sproingie> there's also OpenCL bindings
09:35:23 <Jafet> If you want to write an MMO "proof of concept", better make it big
09:35:27 <jmcarthur> i think i am one of the few who is skeptical of the parallelism craze
09:35:31 <sproingie> bus latency means it's going to be a batch API for some years to come
09:35:32 <Jafet> Lazily generated worlds sounds nice
09:35:46 <SamB_XP> yeah, okay, some of these core counts do sound rather insane, I'll admit
09:36:03 <Jafet> SamB_XP, they all are marketing bubbles. Some pop, some float away
09:36:05 <SamB_XP> but I think parellelism will be with us to stay, unless we really can't figure out how to use it ...
09:36:16 <SamB_XP> hmm. float away ?
09:36:18 <sproingie> being skeptical of all crazes is healthy.  but multicore is here to stay.
09:36:21 <jmcarthur> SamB_XP: that sums up my opinion as well
09:36:39 <Jafet> Float away, get replaced by something else
09:36:49 <jmcarthur> it's here to stay, but it will *be* a problem, not solve our problems
09:36:54 <SamB_XP> none of them just shrink back down to size ?
09:37:07 <SamB_XP> jmcarthur: I know
09:37:07 <jfoutz> at the very least, multicore will live in datacenters. 1 vm per core.
09:37:09 <Jafet> How will it "be a problem"?
09:37:18 <edwardk> opencl is very much of the same spirit as cuda and ctm, i like where its going, but i would like a better way to generate code for these things than dumping through raw text
09:37:23 <benmachine> jmcarthur: one of our problems is that we need problems that we can solve well, hence it will be both
09:37:41 <SamB_XP> Jafet: the same way that things like schedulars are problems already ;-)
09:37:55 <jmcarthur> Jafet: because it would be simpler to have one 10 GHz core than to have 10 1 GHz cores ;)
09:38:01 <edwardk> that and i'm dubious that any platform other than apple is going to have decent multiple device opencl support
09:38:01 <Jafet> Just remake Haskell semantics in terms of CSP and you're set!
09:38:02 <sproingie> used to be you could send raw bytecode to shaders
09:38:09 <sproingie> heck, used to be you had to
09:38:30 <Jafet> (Try doing that to C.)
09:38:31 <jmcarthur> sproingie: you can't anymore? :(
09:38:34 <sproingie> s/bytecode/machine code/
09:38:41 <edwardk> sproingie: i spent a lot of time playing with hand-generating the shader code ala cudasm
09:38:48 <Beelsebob> edwardk: my guess is that windows will get it through ATi and nVidia both already supporting it
09:38:56 <SamB_XP> edwardk: well, okay, so it would be nice to have a syntax tree API ... that's not much of a *problem*, is it ?
09:39:01 <Beelsebob> and linux will get it through the implementation already being open source
09:39:08 <Jafet> Actually, you can have a 10 GHz core, right now.
09:39:10 <edwardk> Beelsebob: yes, but they both seem to have their own little isolated driver machinery for it
09:39:16 <Jafet> Just don't expect it to be clocked or anything
09:39:31 <Beelsebob> edwardk: right – there's no chance that MS will implement it – but that's the exact same situation for OpenGL
09:39:38 <sproingie> jmcarthur: lowest level API that DX exposes now is an ASM program, i think
09:39:41 <Beelsebob> yet OpenGL works nicely on windows
09:39:43 <Jafet> Oh, and you'll need to buy a fab plant to make it in
09:39:48 <edwardk> SamB_XP: i'm currently trying to jit down to this, so i don't want to go back and forth through some text based representation in performance-centric code ;)
09:39:48 <SamB_XP> or possibly a simple binary format for the syntax trees
09:39:49 <sproingie> jmcarthur: for GL it's worse, it's only ever allowed GLSL source
09:39:57 <SamB_XP> edwardk: ah, point
09:40:06 <sproingie> tho i think GLSL implementations cheat and allow ASM too
09:40:26 <SamB_XP> edwardk: I guess what I mean is that this isn't a technically hard problem ...
09:40:31 <edwardk> SamB_XP: i was willing to hand generate bins in memory using a cudasm approach
09:40:33 <Beelsebob> sproingie: that's not really "worse" given that you hardly change shaders all the time
09:40:34 <SamB_XP> it's more of a cat-herding problem ;-P
09:40:43 <ColonelJ> Parallelism is a solution to the problem of not being able to make processors faster, and it creates the new problems of synchronization etc.
09:40:59 <sproingie> Beelsebob: it means you can't use any other compiler than the one you got in whatever version of the driver you have
09:41:03 <jmcarthur> sproingie: i just think it's dumb that we have functional shader languages translated to imperative shader languages translated to functional ASM
09:41:07 <SamB_XP> ColonelJ: and dividing up the work evenly
09:41:08 <Beelsebob> sproingie: true
09:41:16 <copumpkin> why we're so excited by DPH
09:41:21 <sproingie> jmcarthur: the shader language is only sorta imperative
09:41:22 <Beelsebob> jmcarthur: it is indeed dumb
09:41:22 <_JFT_> Can I ask cabal/ghc-pkg question in this channel?
09:41:24 <copumpkin> now if only we could get a dozen more brilliant people working on it
09:41:31 <sproingie> it looks imperative but you're really restricted in what you can do
09:41:37 <sproingie> think of it like a state monad
09:41:41 <jmcarthur> sproingie: you are right, but it would still be much simpler to skip the intermediate step
09:41:48 <SamB_XP> jmcarthur: ever looked at FiSH?
09:41:57 <SamB_XP> or is that FIsH?
09:41:58 <Jafet> JFT, no. We're busy talking about GPU shaders
09:42:11 <SamB_XP> _JFT_: btw, Jafet is kidding
09:42:20 <Jafet> I'm not!
09:42:23 <_JFT_> lol I guesses that much :P
09:42:33 <jmcarthur> SamB_XP: i have no idea what that is
09:42:34 <SamB_XP> well, he better be ;-P
09:42:35 <edwardk> SamB_XP: i've been doing a lot of playing around with tracing jits, and one of the places i'd really like to exploit that is tracing to generate a superblock and then pushing that out as a gpu program, with the 'side-exit' cases showing up as basically a texture of the instances that failed, to be cleaned up by subsequent passes.
09:43:02 <sproingie> transferring that texture back will take forever
09:43:22 <sproingie> i guess if you're only running subsequent passes you don't need to send it back
09:43:25 <SamB_XP> jmcarthur: it stands for Functional = Imparative S___ H____, I think ...
09:43:45 <sproingie> Super Hawt
09:43:50 <edwardk> SamB_XP: so the performance of the intermediate representation is a pretty big component of my overall latency, its the serial bottleneck on the performance of the rest of the system. Amdahl's law and all that
09:43:55 * Jafet ties the noose
09:44:11 <SamB_XP> edwardk: yes, I see your meaning
09:44:14 <Jafet> edwardk, write shaders to write your shaders
09:44:15 <SamB_XP> it is a problem
09:44:20 <Jafet> (In parallel!)
09:44:27 <_JFT_> here comes then: ghc-pkg list report that "directory-1.0.0.3" is present on the global cache. Yet when I try to install "cabal install reactive --dry-run" it tells me that it will install "directory-1.0.0.3", when running the command it actually reinstall it in my "user cache" how come?
09:44:29 <jmcarthur> SamB_XP: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.5099 ?
09:44:30 <sproingie> http://linux.maruhn.com/sec/fish.html
09:44:30 <ColonelJ> Amdahl's law :(
09:44:44 <edwardk> Jafet: easier said than done in a world where you can't even talk about function pointers ;)
09:45:01 <edwardk> jafet: thats one nice thing about the output of the tracing jit: the result is a single superblock
09:45:06 <SamB_XP> edwardk: but not a very hard one for even conventional programmers to understand and solve, with changes to the right component
09:45:14 <ColonelJ> Amdahl's law even applies to pure functional code
09:45:14 <sproingie> _JFT_: you have cabal set up for user installs
09:45:35 <_JFT_> sproingie: I tried sudoing the command to no avail
09:45:39 <sproingie> _JFT_: oh i see, i dont' know why it reinstalls
09:45:52 <SamB_XP> edwardk: so how DO you JIT shaders, anyway?
09:45:56 <_JFT_> sproingie:  I am on a mac
09:46:12 <_JFT_> sproingie: would pasting my cabal config helps?
09:46:24 <sproingie> you don't JIT shaders any more than you do x86 asm
09:46:36 <sproingie> you can do instruction rewriting on the hardware of course
09:46:37 <SamB_XP> _JFT_: hmm, I think the thing you need to do is not sudo, but pass --global
09:46:46 <SamB_XP> well, I mean, sudo will come in somehow or other, but ...
09:47:13 <_JFT_> SamB_XP: anyway to install "user" just reactive without having to reinstall what is already there globally?
09:47:40 <edwardk> SamB_XP: short answer that i'd been playing with is to take a big mostly data parallel task written in basically naive Haskell style, that just happens to be working on textures instead of data points, and start interpreting on the main CPU using a tracer which logs the code path it takes on the first few data points
09:48:10 <SamB_XP> edwardk: ah
09:48:12 <edwardk> SamB_XP: take that code path and generate a superblock, which marks up a texture when you fall off the basic path with where you failed to take the same path
09:48:20 <edwardk> and run THAT in parallel on the gpu
09:48:24 <neosoothsayer> n00b question: what is the difference between binding with <- and using "let x =" ?
09:48:42 <sproingie> neosoothsayer: <- desugars to using >>=
09:48:44 <_JFT_> SamB_XP: here's my cabal/config http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15303#a15303
09:49:00 <SamB_XP> edwardk: so what do you do with the resulting fail texture ?
09:49:02 <neosoothsayer> sproingie: thanks
09:49:02 <edwardk> then what you have to do is take the textures written by the side-exits, and emulate each of the distinct cases on the main CPU, tracing new lines, and compile a new shader that incorporates each of those code paths
09:49:08 <sproingie> neosoothsayer: <- is used to bind monadic values, let is for "plain" values
09:49:18 <_JFT_> SamB_XP: Global conf is located here: /Library/Frameworks/GHC.framework/Versions/610/usr/lib/ghc-6.10.4/./package.conf
09:49:32 <ColonelJ> vanilla values as it were
09:49:51 <HaskellLove> How to get lists combinations ? For example i have 10 elements in a list, and i want to combine each element with each other in an element of length 3. it is kinda 10 choose 3 thing but i dont need number of combinations i need the actual combinations
09:49:52 <sproingie> @undo do { greeting <- "hello"; putStrLn greeting }
09:49:52 <lambdabot> "hello" >>= \ greeting -> putStrLn greeting
09:50:00 <sproingie> ARG
09:50:00 <SamB_XP> oh, you run the shader code on the CPU on a sampling of the failed points, gotcha...
09:50:05 <sproingie> @undo do { greeting <- readLine; putStrLn greeting }
09:50:06 <lambdabot> readLine >>= \ greeting -> putStrLn greeting
09:50:08 <edwardk> samb: so the result turns into a 'wishbone' like structure of code paths that all return via the original code point, or are marked as intrinsically CPU-bound, because they don't run on the CPU
09:50:18 <edwardk> er
09:50:27 <edwardk> because they don't run on the GPU in sufficiently small space
09:50:34 <SamB_XP> edwardk: so, how do you decide which points to simulate ?
09:50:38 <ColonelJ> HaskellLove: write a function
09:50:52 <copumpkin> replicateM 3
09:51:01 <copumpkin> > replicateM 3 [1..5]
09:51:02 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,1,5],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[1...
09:51:43 <ColonelJ> that's not combinations
09:51:49 <benmachine> > filter ((== 3) . length . nub) . replicateM 3 $ [1 .. 5] -- inefficient version
09:51:49 <edwardk> short answer? at present the model is to CPU emulate a small random sample of the texture (based on the first few entries in a sobel sequence), then out of the remainder a random sample including one of each distinct side-exit that was taken
09:51:51 <lambdabot>   [[1,2,3],[1,2,4],[1,2,5],[1,3,2],[1,3,4],[1,3,5],[1,4,2],[1,4,3],[1,4,5],[1...
09:52:04 <tromp__> > replicateM "ibm"
09:52:05 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:52:05 <lambdabot>         against inferred type ...
09:52:09 <_JFT_> SamB_XP: Thank you --global worked! How to I set that as default in my cabal/config file?
09:52:12 <tromp__> > replicateM 3 "ibm"
09:52:13 <lambdabot>   ["iii","iib","iim","ibi","ibb","ibm","imi","imb","imm","bii","bib","bim","b...
09:52:21 <edwardk> the 'remainder' being the cases that failed when i tried to feed the entire texture to the cpu using the superblock i generated
09:52:29 <SamB_XP> _JFT_: I'm afraid I can't recall :-(
09:52:42 <_JFT_> SamB_XP: ok thank you :)
09:53:18 <benmachine> HaskellLove: I'd do it by saying, the ways of choosing 5 things from 10 things are, choose the first thing, and then 4 things from 9 things, or don't choose the first thing and choose 5 things from 9 things
09:53:29 <edwardk> SamB_XP: it'd need a lot of work to be practical, it was mostly to see if it was even possible ;)
09:54:20 <ColonelJ> benmachine: your last example was permutations not combinations
09:54:33 <ColonelJ> benmachine: I mean the inefficient one
09:54:50 <edwardk> SamB_XP: main problem that i ran into is its very hard to get sufficiently random access for the writes to mark thunks, etc. so i put it down for a while to wait until the intermediate languages catch up enough.
09:55:23 <benmachine> ColonelJ: oh, that sounds plausible yeah
09:55:41 <SamB_XP> edwardk: hmm ?
09:56:18 <edwardk> SamB_XP: basically pointer-based data structures are not good citizens in the gpu world ;)
09:56:43 <copumpkin> fColonelJ: I figured his language wasn't exactly mathematically precise and described what I understood he wanted
09:57:05 <copumpkin> poucet: wow, twitterblast!
09:57:07 <SamB_XP> edwardk: wouldn't you just write a number identifying the not-yet-compiled node to a "fail" texture/channel?
09:57:07 <benmachine> > filter (all . zipWith (<)) . replicateM 3 $ [1 .. 5] -- inefficient version
09:57:08 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:57:09 <lambdabot>         against inferred type ...
09:57:11 <benmachine> aw
09:57:13 <edwardk> SamB_XP: and i had enough to do to get basic cpu stuff working on kata, that i put down all my little gpu toys
09:57:26 <benmachine> > filter (all . (zipWith (<) <*> tail)) . replicateM 3 $ [1 .. 5] -- inefficient version
09:57:27 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:57:28 <lambdabot>         against inferred type ...
09:57:32 <benmachine> fine I give up
09:58:07 <edwardk> SamB_XP: its not the 'not yet compiled' bit that is the issue, its that i need to mark the thunk as evaluated and forward it to its evaluated version, but then you're starting to play with dynamic memory allocation in a shader, etc. so i start using textures as heap space, etc.
09:58:12 <SamB_XP> edwardk: hmm, the problem, though, is how do you rerun the shader only on the not-yet-rendered points ?
09:58:15 <poucet> copumpkin: ?
09:58:22 <edwardk> SamB_XP: that part isn't hard actually
09:58:37 <copumpkin> poucet: lots of twees in a row :)
09:58:38 <SamB_XP> edwardk: oh, you mean ypu're trying to implement lazy evaluation in shaders ?
09:58:40 <edwardk> SamB_XP: you maintain the mask of what failed on what side-exit
09:58:43 <SamB_XP> that's probably crazy ;-P
09:58:43 <poucet> copumpkin: me?
09:58:54 <benmachine> > filter (and . (zipWith (<) <*> tail)) . replicateM 3 $ [1 .. 5]
09:58:56 <copumpkin> poucet: yep? was it not intentional?
09:58:56 <lambdabot>   [[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3...
09:58:59 <poucet> copumpkin: oh!
09:59:04 <poucet> copumpkin: friendfeed from delicious
09:59:06 <edwardk> SamB_XP: yeah, a tracing jit inlines right through the eval body
09:59:11 <benmachine> woo
09:59:12 <copumpkin> poucet: ah :)
09:59:21 <edwardk> SamB_XP: i'd have it a bit easier if this was something closer to an erlang ;)
09:59:22 <SamB_XP> edwardk: oh, can you run a shader only for non-magic-color points on a bitmap then ?
09:59:47 <benmachine> @quote zip`ap`tail
09:59:47 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
09:59:52 <edwardk> SamB_XP: yeah, just branch to 'done' when it doesn't match ;)
10:00:14 <SamB_XP> edwardk: I was under the impression that that would not actually save much/any time
10:00:26 <edwardk> most of the time, not
10:00:36 <SamB_XP> I meant, a way to bypass even *running* the shader for those points
10:00:52 <HaskellLove> what is that <*> thing
10:00:54 <jmcarthur> > nub . map sort . replicateM 3 $ "abc"
10:00:55 <lambdabot>   ["aaa","aab","aac","abb","abc","acc","bbb","bbc","bcc","ccc"]
10:01:04 <jmcarthur> crap
10:01:17 <SamB_XP> jmcarthur: what ?
10:01:18 <edwardk> SamB_XP: well, one way would be to generate a smaller texture that just consisted of those points and indices into the original larger text
10:01:18 <edwardk> er texture
10:01:39 <SamB_XP> edwardk: okay, that doesn't sound very efficient either
10:01:59 <jmcarthur> > nub . map sort . filter ((==3) . length . nub) . replicateM 3 $ "abc"
10:02:00 <lambdabot>   ["abc"]
10:02:02 <SamB_XP> because then you'd have to do a bunch of random accesses to put the pixels where they belong :-(
10:02:09 <jmcarthur> > nub . map sort . filter ((==3) . length . nub) . replicateM 3 $ "abcde"
10:02:10 <lambdabot>   ["abc","abd","abe","acd","ace","ade","bcd","bce","bde","cde"]
10:02:19 <edwardk> SamB_XP: most of this isn't. it was mostly an intellectual exercise to even see if it was possible, i hadn't gotten down to optimizations yet =)
10:02:26 <jmcarthur> sorry for the flooding, i am done now
10:02:43 <HaskellLove> jmcarthur no need to be sorry, thank you so much
10:03:01 <jmcarthur> it is not efficient
10:03:02 <SamB_XP> edwardk: well, it'd be nice to at least not run 100x slower than conventionally-compiled code ;-P
10:03:35 <c_wraith> HaskellLove: <*> is for function application inside contexts that implement applicative.
10:03:35 <edwardk> SamB_XP: yeah. thatw why i was looking for constant factors to kill ;)
10:03:55 <EnglishGent> hi all :)
10:03:56 <HaskellLove> > nub $ replicateM 3 [1..5]
10:03:57 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,1,5],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[1...
10:04:14 <HaskellLove> > map nub $ replicateM 3 [1..5]
10:04:16 <lambdabot>   [[1],[1,2],[1,3],[1,4],[1,5],[1,2],[1,2],[1,2,3],[1,2,4],[1,2,5],[1,3],[1,3...
10:04:27 <SamB_XP> edwardk: well, I'd think that there might well be a way to trigger shaders to run or not based on a mask ...
10:04:31 <c_wraith> > [(+1), (*2), (^3)] <*> [2..4] -- HaskellLove: Lists implement applicative
10:04:32 <lambdabot>   [3,4,5,4,6,8,8,27,64]
10:04:40 <poucet> copumpkin: hadnt used delicious in a while and decided to put my digital photography links on it, but I didn't realize it would be feeding to twitter
10:04:54 <SamB_XP> but certainly going throught text isn't going to be any help
10:05:01 * poucet needs to brighten up his blog next year, it's empty and boring, and put more haskell stuff again
10:05:16 <SamB_XP> however, you could just put that down to bad APIs for the moment and pretend you don't have those costs ;-P
10:05:27 <HaskellLove> c_wraith i have no idea what applicative is so... i just want to keep it simple for now :) no need for that for now... i wanna first get comfortable with basic processing in haskell using map fold zip and what not, to solve eulers
10:05:31 <edwardk> SamB_XP: probably. i'm a bit umm. out of date when it comes to shader stuff. i was a 3d graphics guy before they came along, and only picked them up to keep myself from becoming a dinosaur ;(
10:06:18 <SamB_XP> edwardk: I don't actually follow them or even have a card with pixel shaders, myself ;-P
10:06:32 <SamB_XP> but once in a while I read a page about them, I guess
10:06:36 <edwardk> SamB_XP: hah
10:07:05 <poucet> copumpkin: wow, 3 people already complained =)
10:07:20 <edwardk> poucet: more haskell, yes!
10:07:33 <jmcarthur> HaskellLove: copumpkin and i taught you applicative in our attempts to lead you up to monads
10:08:10 <HaskellLove> > filter (\x -> hasDuplicates x) $ replicateM 3 [1..5] where hasDuplicates l = length l /= length (nub length)
10:08:11 <lambdabot>   <no location info>: parse error on input `where'
10:08:25 <|fft|> do  if p then a else b  what will be the result  ?   either a or b depending on p ? or there can be other cases  ?
10:09:05 <flux> well, if p is undefined, then in some level the value of the whole expression is undefined
10:09:05 <jmcarthur> |fft|: it can be a, b, or _|_
10:09:22 <|fft|> what is _|_ ?
10:09:29 <jmcarthur> |fft|: nontermination
10:09:38 <jmcarthur> |fft|: it would be _|_ if p is _|_
10:09:53 <jmcarthur> |fft|: we pronounce _|_ as "bottom"
10:10:38 <jmcarthur> > if undefined then a else b
10:10:39 <lambdabot>   * Exception: Prelude.undefined
10:10:47 <jmcarthur> if True then a else b
10:10:53 <jmcarthur> > if True then a else b
10:10:54 <lambdabot>   a
10:10:57 <jmcarthur> > if False then a else b
10:10:58 <lambdabot>   b
10:11:02 <djahandarie> If you are wondering where it came from, it is from a mathematical symbol. ;)
10:11:27 <flux> an ascii rendition of one's bottom, obviously.
10:11:50 <|fft|> then something wrong is going on
10:12:07 <djahandarie> ⊥
10:12:35 <idnar> ⊤
10:12:44 <Philonous1> T
10:12:54 <jmcarthur> |fft|: what "wrong" could be going on?
10:13:26 <HaskellLove> wow i see on hoogle this replicateM thing is a monad kinda thing, i am confused why such thing works for combinations
10:13:36 <|fft|> function works incorrectly when I insert if then else structure which is equivalent in my opinion
10:13:38 <jmcarthur> HaskellLove: lists form a monad
10:13:54 <jmcarthur> |fft|: equivalent to what?
10:14:30 <copumpkin> poucet: I wasn't complaining, just notifying you :)
10:14:38 <HaskellLove> jmcarthur i dont know what you talk about sorry :(
10:14:44 <poucet> copumpkin: Thanks =)
10:15:01 <poucet> I'm tempted to reenable it, I don't plan to constantly add links at that rate, and it did get me a new follower (photography)
10:15:08 <edwardk> djahandarie: i have always wondered how the _|_ symbol came to be used. i know for instance the |- turnstile comes from http://en.wikipedia.org/wiki/Begriffsschrift
10:15:51 <burp> HaskellLove: that's because you don't work with real world haskell code// read tutorials, but just try to finish all project euler stuff
10:16:10 <matsuura> xD
10:16:17 <jmcarthur> HaskellLove: for lists, return x = [x] ; m >>= k = concatMap k m
10:16:21 <edwardk> which uses the upside down T style turnstile for negation
10:16:23 <jmcarthur> HaskellLove: so lists form a monad
10:16:35 <HaskellLove> burp well yeah that is my point, why go beyond what i understand i need to master basic processing first, remember i am new to functional programming
10:17:00 <sproingie> edwardk: top is T, _|_ is an upside-down T
10:17:03 <c_wraith> HaskellLove: Project Euler is a very poor way.
10:17:05 <Olathe> Maybe T is theorem and _|_ is antitheorem or something.
10:17:15 <jmcarthur> HaskellLove: why are you learning haskell if you don't want to go beyond what you understand?
10:17:18 <edwardk> sproingie: how boring =)
10:17:29 <HaskellLove> c_wraith well it is a chalenge for me ... i dont know i might be extremely dumb or something
10:17:34 <|fft|> aaargh
10:17:36 <|fft|> brackets
10:17:43 <jmcarthur> HaskellLove: full immersion is the best way to learn, in my opinion, and project euler is only partial immersion
10:17:45 <sproingie> if you put it in parentheses it looks a bit like a bottom:  (_|_)
10:17:47 <|fft|> It's all about brackets
10:17:56 <HaskellLove> jmcarthur it is not just all haskell haskell, with euler i practice general solving abilities
10:18:11 <c_wraith> HaskellLove: project euler is a challenge with regards to math and algorithms, for most people.  regardless of language.  If you really want to learn the language, do something more complete with it.
10:18:14 <jmcarthur> HaskellLove: monads are not haskell-specific
10:18:35 <Kim^Walkman> sproingie: rofl
10:18:37 <edwardk> sproingie: I suppose I can buy the 'umop apisdn' explanation though.
10:18:37 <matsuura> what is?
10:18:57 <|fft|> no it works. rofl
10:19:02 <|fft|> *now
10:19:06 <jmcarthur> matsuura: who are you talking to?
10:19:12 <HaskellLove> jmcarthur monads are haskell specific to my limited knowledge, sml has side effects IO like the Lisp family and F# and C# are their own story and so on and on...
10:19:14 <matsuura> you
10:19:27 <jmcarthur> HaskellLove: no, monads are not a language feature
10:19:39 <copumpkin> HaskellLove: monads are an abstract structure
10:19:39 <sproingie> monads are not haskell specific.  haskell just uses them more explicitly than most
10:19:43 <sproingie> LINQ is a monad
10:19:44 <jmcarthur> HaskellLove: SML, lisp, F#, and C# all can express monads as well
10:19:45 <Twey> And monads are not for IO
10:19:46 <c_wraith> scala has a monad library
10:20:00 <jmcarthur> HaskellLove: and can even benefit from them as an explicit abstraction
10:20:01 <|fft|> If some expression in do block fails than the whole result is fail ?
10:20:02 <HaskellLove> well haskell IO is monadic so...
10:20:08 <mercury^> > fmap succ 1
10:20:09 <jmcarthur> HaskellLove: so what?
10:20:10 <lambdabot>   No instance for (GHC.Num.Num (f a))
10:20:10 <lambdabot>    arising from the literal `1' at <int...
10:20:23 <HaskellLove> jmcarthur ok i got your point
10:20:31 <sproingie> in all fairness if you have to deal explicitly with monads qua monads chances are you're doing it in haskell
10:20:33 <|fft|> or it depends on >>= definition ?
10:20:37 <c_wraith> HaskellLove: STM is monadic, so clearly monads are for handling concurrency safely
10:20:40 <sproingie> but monads are not themselves a haskellism
10:21:02 <copumpkin> maybe is monadic, so clearly monads are for handling failure
10:21:03 <jmcarthur> sproingie: i've used monads in C++ for a serious application
10:21:18 <edwardk> copumpkin: *twitch*
10:21:23 <sproingie> jmcarthur: sure, but most C++ libraries don't use 'em
10:21:25 <shambler> show me the code!
10:21:28 <HaskellLove> jmcarthur monads in c++? ok am i dump or something i dont get it :)
10:21:30 <mercury^> Making the identity an instance of functor does not work, does it?
10:21:36 <jmcarthur> sproingie: true
10:21:38 <sproingie> HaskellLove: again i direct you to LINQ, which is a monad
10:21:44 <idnar> Either is monadic, so clearly monads are for sum types
10:21:53 <sproingie> Either a is a monad
10:21:56 <copumpkin> LINQ is C#, in case you haven't come across it
10:22:01 <idnar> oh, true
10:22:06 <c_wraith> |fft|: fail is actually (for historical reasons that were poorly considered) part of the Monad typeclass.  So what fail does *is* monad-specific, but not related to >>=
10:22:07 <edwardk> sproingie: modulo some law requirements
10:22:14 <stepcut> can this function be implemented?
10:22:14 <copumpkin> edwardk: *cotwitch*
10:22:16 <stepcut> bind :: (Monad m, Monad f) => (f a) -> (a -> m (f b)) -> m (f b)
10:22:17 <jmcarthur> HaskellLove: that's because you refuse to move on to more advanced programming concepts in haskell or otherwise since you are comfortable sticking with project euler problems so far
10:22:18 <idnar> haha
10:22:19 <stepcut>  
10:22:28 <sproingie> fail has to do with monad comprehensions i think
10:22:45 <sproingie> if we ever get monad comprehensions back i suppose we'll be glad to still have fail
10:22:50 <jmcarthur> sproingie: and do notation
10:22:56 <idnar> @type (>>=)
10:22:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:23:01 <copumpkin> stepcut: if f is traversable
10:23:06 <sproingie> jmcarthur: failed pattern match?
10:23:11 <jmcarthur> sproingie: right
10:23:15 <|fft|> c_wraith: I mean inside the do block it depends on >>= what happens   if  do fail s; foo
10:23:18 <neosoothsayer> hehe, everyone is trying to get HaskellLove to agree on something, but he/she just wont give up :)
10:23:23 <Saizan> mercury^: for newtype Identity a = Identity a you can
10:23:27 <stepcut> copumpkin: that is fine
10:23:33 <sproingie> i guess do-notation sort of is monad comprehensions.  bringing them back would just mean sugar over 'do'
10:23:35 <edwardk> fail came about due to the elimination of failure free patterns from haskell '98 and the desire to make it so local code changes wouldn't cause the spurious addition of an extra constraint (MonadZero or MonadPlus) based on just changing a pattern.
10:23:37 <sproingie> yay metasugar
10:23:39 <idnar> doesn't that type unify with (>>=)?
10:23:46 <sproingie> metasugar, 2000% sweeter than normal sugar!
10:23:48 <copumpkin> idnar: the first one is in f
10:23:49 <idnar> @type (>>=) :: (Monad m, Monad f) => (f a) -> (a -> m (f b)) -> m (f b)
10:23:50 <edwardk> unfortunately, we're stuck with it now =(
10:23:51 <lambdabot>     Couldn't match expected type `f' against inferred type `m'
10:23:51 <lambdabot>       `f' is a rigid type variable bound by
10:23:51 <lambdabot>           an expression type signature at <interactive>:1:25
10:23:53 <mercury^> Saizan: right, but you you cannot make "fmap succ 1" work that way.
10:23:58 <idnar> oh, yes, the monad swaps
10:24:02 <HaskellLove> > combinations n l = filter (\x -> not(hasDuplicates x)) (replicateM n l) where hasDuplicates l = length l /= length (nub l) in combinations 3 [1..10]
10:24:03 <lambdabot>   <no location info>: parse error on input `='
10:24:06 <neosoothsayer> :type main
10:24:13 <Saizan> mercury^: no
10:24:17 <neosoothsayer> @type main
10:24:18 <lambdabot> Not in scope: `main'
10:24:26 <mercury^> Saizan: it makes sense too, but it would be interesting to know what exactly we would lose if we made that work.
10:24:27 <burp> > fmap succ [1]
10:24:28 <lambdabot>   [2]
10:24:31 * stepcut is prety sure he figured this out once, but has apparently gotten dumber since then
10:25:22 <sproingie> man i gotta find focus on my game project.  can't get started.
10:25:31 <copumpkin> @type \x f -> Data.Traversable.sequence (join (fmap f x))
10:25:33 <lambdabot> forall a (t :: * -> *) (m :: * -> *) a1. (Data.Traversable.Traversable t, Monad t, Monad m) => t a -> (a -> t (m a1)) -> m (t a1)
10:25:39 <copumpkin> oh whoops, that one is backwards I think
10:25:48 <sproingie> moving an '@' around the screen isn't terribly inspirational
10:25:59 <neosoothsayer> why is gaming such a focus with Haskell? more elegant to program in than C++?
10:26:09 <sproingie> neosoothsayer: i like games
10:26:10 <c_wraith> |fft|: I guess it's true that it requires a monad where >>= forces at least a partial pattern match on its argument.
10:26:12 <HaskellLove> jmcarthur i stand strong on the attitute master walking before running so i will keep the euler and do monads and avanced stuff after i solve it all ... I mean, i am dumb in functional programming, i still have problems with recursion and using fold and what not
10:26:12 <copumpkin> @type \x f -> Data.Traversable.sequence (join (fmap (Data.Traversable.sequence . f) x))
10:26:12 <Jafet> Seeking success
10:26:13 <lambdabot> forall (m :: * -> *) (t :: * -> *) a a1. (Data.Traversable.Traversable m, Monad t, Data.Traversable.Traversable t, Monad m) => t a1 -> (a1 -> m (t a)) -> m (t a)
10:26:13 <Saizan> mercury^: there's a paper about allowing instances like these
10:26:18 <copumpkin> stepcut: ^
10:26:27 <burp> solve all project euler problems.. -.-
10:26:33 <sproingie> neosoothsayer: if it were a focus, i'd have more and better examples to choose from
10:26:45 <mercury^> Saizan: do you have a link? :)
10:26:53 <sproingie> at least i have nice texture loading stuff from frag.  the rest of frag i can't comprehend at all.
10:27:06 <Saizan> mercury^: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.7505
10:27:18 <copumpkin> @type \x f -> Data.Traversable.sequence (Data.Traversable.sequence . f =<< x)
10:27:19 <lambdabot> forall (m :: * -> *) (t :: * -> *) a a1. (Data.Traversable.Traversable m, Monad t, Data.Traversable.Traversable t, Monad m) => t a1 -> (a1 -> m (t a)) -> m (t a)
10:27:29 <mercury^> Saizan: thank you!
10:27:30 <copumpkin> stepcut: I guess both need to be traversable
10:27:38 <copumpkin> stepcut: unless I missed something
10:27:46 <HaskellLove> burp just watch me  :) seriosly i will devote months to it
10:27:51 <burp> HaskellLove: ok :D
10:28:31 <stepcut> copumpkin: thanks
10:28:40 <edwardk> copumpkin: you can probably get by with just a distributive law between them, since that then becomes a special case of the monad construction for m (t a) -- which can be built several ways
10:28:48 <copumpkin> yeah
10:28:54 <HaskellLove> burp i solved 40 so far in one month, and i am one month in haskell so i guess i am ok track
10:29:05 <HaskellLove> and new to func programming so
10:29:14 <copumpkin> edwardk: don't think there's any distributive stuff anywhere but category-extras, right?
10:29:15 <aavogt> did you solve them, or did #haskell solve them for you?
10:29:29 <sproingie> naw he solved most of them
10:29:38 <edwardk> copumpkin: but mark p jones wrote up something back in er.. 93 or so =)
10:29:43 <copumpkin> :)
10:29:54 * copumpkin gnaws on sproingie 
10:29:57 <sproingie> not with the most elegantly idiomatic code, but that just shows it's his own work
10:30:15 <copumpkin> edwardk: have you heard anything about hacbos?
10:30:22 <HaskellLove> aavogt like i care if you think that...
10:30:37 <edwardk> copumpkin: no i haven't. i need to ping ravi but he's been rather distracted
10:30:39 * sproingie is infected with colycanthropy
10:30:55 <copumpkin> sproingie: are you a werecat?
10:31:09 <copumpkin> #furry
10:31:10 <edwardk> sproingie: you spontaneously become less furry?
10:31:10 <lunabot>  luna: Not in scope: `furry'
10:31:18 <sproingie> there we go
10:31:42 * Saizan imagined a flock of haskellers invading bos' house
10:31:59 <copumpkin> Saizan: we should definitely invite bos to hacbos if it happens
10:32:10 <edwardk> Saizan: the bostonhaskell user group has been planning a hackathon in january or february some time
10:32:13 <SamB_XP> Saizan: you mean a *pack* of *rabid* 'skellers?
10:32:21 <sproingie> there a san francisco group?
10:32:37 <sproingie> every time i mention SF someone says "bay area".  as if san jose were next door.
10:32:38 <edwardk> copumpkin: which should probably be added to the 'hac' series list or something once we know when we have the space
10:33:06 <copumpkin> edwardk: yeah :) hasn't been much talk recently
10:33:14 <copumpkin> we need a poll
10:33:40 <MyCatVerbs> I recommend kqueue. Much faster, more features and IMHO the API is even slightly nicer.
10:33:50 * MyCatVerbs grins sheepishly.
10:34:07 * copumpkin facepalsm
10:34:13 <copumpkin> facepsalms?
10:34:13 <copumpkin> :P
10:36:25 <aavogt> [13:21:54]      stepcut | bind :: (Monad m, Monad f) => (f a) -> (a -> m (f b)) -> m (f b)
10:36:29 <jfoutz> blessed is the hacker who does not unsafePerformIO
10:36:33 <aavogt> @type flip Data.Traversable.traverse
10:36:34 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
10:36:57 <aavogt> oh, right there's a join missing there
10:37:30 <HaskellLove> aavogt for your information for all the eulers i had my solutions like this. I solve euler 49 now: -- step 1: get permutations of the prime, step2: filter primes, step3: get combinations 4 (the prime and its permutations primes) step5: filter c-b == b-a....... I asked here for syntax and haskell related stuff, of course i was new to func programming and haskell so...
10:38:01 <aavogt> [13:30:01]  HaskellLove | aavogt like i care if you think that...
10:38:08 <aavogt> so you're trying to convince somebody?
10:38:18 <HaskellLove> aavogt actually i care :)
10:40:37 <copumpkin>  @type \x f -> fmap join (Data.Traversable.traverse f x)
10:40:37 <copumpkin> @type \x f -> fmap join (Data.Traversable.traverse f x)
10:40:37 <lambdabot> forall (m :: * -> *) a a1 (f :: * -> *). (Monad m, Data.Traversable.Traversable m, Applicative f) => m a1 -> (a1 -> f (m a)) -> f (m a)
10:41:06 <copumpkin> that's much better than the one I came up with earlier, thanks aavogt :)
10:41:48 <jmcarthur> HaskellLove: "you have to walk before you can run" is a cop out
10:42:10 <jmcarthur> HaskellLove: it's true to an extent, but you've been at this for plenty long enough to try running
10:42:38 <HaskellLove> jmcarthur i actually dont feel ready to even walk in haskell so i will take it easy :)
10:42:57 * SamB_XP wonders why the heck his mozilla doesn't have its DLL base addresses set up so that they mostly won't need rebasing, but instead has most DLLs with the default base address of 0x10000000 ...
10:43:46 * copumpkin wonders why windows still does that nasty stuff
10:43:55 <SamB_XP> copumpkin: what nasty stuff ?
10:44:04 <jmcarthur> HaskellLove: i suspect the reason is that you are learning algorithms and not haskell
10:44:16 <SamB_XP> copumpkin: doesn't it make things faster and/or save RAM ?
10:44:24 <matsuura> haha
10:44:25 <SamB_XP> (or swapspace, maybe?)
10:44:30 <jmcarthur> or the functional way in general
10:44:41 <sproingie> there's worse ways to learn functional programming.  i suspect after 40 PE problems tho you're ready for something meatier
10:44:43 <joe3> I read that hGetContents of System.IO is a lazy function and that it really helps while working with large files. I am wondering if hGetBuf is a lazy function too.
10:45:41 <sproingie> solving problems given to you is easy, figuring out what the problems are is the tricky part
10:45:58 <SamB_XP> copumpkin: or were you thinking they should all use PIC so that rebasing would be no work at all, except for the export tables?
10:46:12 <copumpkin> yeah, PIC
10:46:25 <joe3> if hGetBuf is not a lazy function, just wondering if there is an equivalent of hGetContents for binary files?.
10:46:37 <copumpkin> @hoogle hGetContents
10:46:37 * SamB_XP wonders if PIC is worth it
10:46:38 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
10:46:38 <lambdabot> System.IO hGetContents :: Handle -> IO String
10:46:38 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
10:46:42 <sproingie> yes, it's hGetContents
10:46:48 <SamB_XP> doesn't PIC have runtime costs?
10:47:06 <copumpkin> SamB_XP: almost nothing as of x86_64 afaik
10:47:15 <SamB_XP> oh, well, guess what
10:47:15 <joe3> thanks copumpkin
10:47:23 <sproingie> don't you lose a register with PIC?
10:47:39 <SamB_XP> I'm not *running* an x86_64 kernel
10:47:39 <copumpkin> and not much on x86 either
10:47:49 <copumpkin> the kernel shouldn't really matter that much
10:47:57 <copumpkin> and mac os does PIC everywhere, so it can't be that bad
10:48:19 <SamB_XP> uh, you can't run x86_64 code without an appropriate kernel ...
10:48:20 <sproingie> OSX isn't exactly the king of zip
10:48:30 <SamB_XP> 7-zip is the king of zip, yes?
10:49:08 <copumpkin> SamB_XP: you can run 64-bit code in userspace running on a 32-bit kernel is what I mean
10:49:18 <SamB_XP> copumpkin: since when ?
10:49:22 * copumpkin invents 8-zip
10:49:29 <copumpkin> SamB_XP: that's what mac os has done for the past three releases
10:49:45 <copumpkin> even snow leopard has a 32-bit kernel by default
10:49:50 <SamB_XP> well, it must be a hybrid kernel
10:49:50 <copumpkin> all userspace apps are 64
10:50:18 <SamB_XP> 'cause clearly they need some code in there that handles the Volume 3 shit
10:50:30 <copumpkin> yeah
10:50:48 <SamB_XP> Volume 3 being the part of the Intel manuals that covers such juicy details
10:50:58 <copumpkin> :)
10:51:14 <copumpkin> I've read a fair amount of their manuals, sadly
10:52:04 <SamB_XP> anyway, what I meant is I'm not running a kernel that *supports* 64-bit code
10:52:18 <copumpkin> FAIL!
10:52:38 <SamB_XP> well, part of the reason for that is that I don't have a CPU that can run it, either
10:53:47 <SamB_XP> the other reasons being that I don't own a copy of XP 64, and that NTVDM/WoW32 isn't available for 64-bit capable NT anyway
10:54:04 <ColonelJ> ah I'll need to have another look at those bloody intel manuals
10:54:11 <copumpkin> world of warcraft?
10:54:20 <sproingie> Windows On Windows
10:54:24 <ColonelJ> I found quite a number of errors in the intel manuals, but I didn't bother to send it to them
10:54:51 <SamB_XP> more precisely, [16-bit] Windows on Win32
10:55:07 <sproingie> dosemu
10:55:14 <copumpkin> ColonelJ: responsible citizen!
10:55:36 <ColonelJ> copumpkin: I was intending to do a complete list of errors after reading the whole thing, which didn't happen
10:55:45 <SamB_XP> copumpkin: well, I don't think I would have been able to find the bug-contact info on their site anyway ...
10:56:13 <SamB_XP> ColonelJ: you should have started a list on your blog and noted them down as you found them
10:56:36 <ColonelJ> SamB_XP: I started a list, but it's not on the web
10:57:41 <ColonelJ> There are actually two completely different instructions with the same mnemonic
10:57:45 <ColonelJ> I found that very odd
10:57:52 <SamB_XP> so, is it true that OS X can run 16-bit programs and 64-bit programs at the same time ?
10:58:11 <ColonelJ> I don't think that's possible, without emulation
10:58:32 <ColonelJ> 64 bit mode can't run 16-bit
10:58:51 <ColonelJ> might work with multiple cores, I have no idea about that
10:58:55 <SamB_XP> ColonelJ: I think I heard they figured something out, something akin to the gymnastics required to switch out of Protected Mode
10:59:12 <copumpkin> SamB_XP: doubt it can do 16-bit
10:59:33 <ColonelJ> SamB_XP: I wouldn't want to use an OS that did that...
10:59:59 <SamB_XP> what, restarting the CPU in mid-session alarms you?
11:00:06 <ColonelJ> indeed
11:00:40 <SamB_XP> how is that different from suspending the system momentarily?
11:00:50 <SamB_XP> I mean, the not-to-disk kind of suspend
11:01:36 <ColonelJ> I don't know, it just sounds like a very stupid idea
11:01:45 <jmcarthur> i don't think it does
11:01:54 <jmcarthur> delicate, perhaps
11:02:08 <SamB_XP> well, to me it just sounds (a) tricky and (b) probably not very good for performance
11:02:29 <ColonelJ> as well as (c) unreliable
11:02:34 <SamB_XP> not a bit!
11:02:36 <jmcarthur> ColonelJ: why unreliable?
11:02:43 <SamB_XP> not if you get past (a), I mean
11:02:48 <jmcarthur> ColonelJ: what undefined behavior do you expect?
11:02:49 <sproingie> it's perfectly reliable.  it's murder on performance, yes
11:03:05 <ColonelJ> I suppose it depends how it's handled
11:03:14 <SamB_XP> you could certainly write an unreliable implementation
11:03:48 <ColonelJ> I don't see what the benefits of such operation are anyway
11:03:57 <ColonelJ> what use are 16 bit programs
11:04:18 <koeien37> legacy
11:04:25 <SamB_XP> at least, the guide I saw to switching back to real mode indicated that there are a lot of things you have to get right before it becomes safe ;-)
11:05:05 <SamB_XP> I admit I don't know *what* 16-bit programs Apple would care to run, but ...
11:07:35 <sinelaw> How do I represent the type of a superset of a set?
11:08:02 <sinelaw> Specifically, a sigma algebra
11:08:46 <sinelaw> type SigmaAlgebra a = Set (Set a)
11:09:23 <copumpkin> there you go!
11:09:30 <copumpkin> does Set have an Ord instance?
11:09:44 <dolio> data SigAlg sig a = Inj a | Roll (sig (SigAlg a))?
11:09:53 <sinelaw> whaaa?
11:10:24 <sinelaw> dolio, what are Inj and Roll?
11:10:32 <copumpkin> dolio:  isn't that free?
11:10:35 <copumpkin> as in free monad?
11:10:48 <dolio> copumpkin: Yes, it is. How amazing.
11:11:07 <copumpkin> it is for me, since I don't know what a sigma algebra is :)
11:11:15 <HaskellLove> how do you guys do a == b == c, it shows errors like that precedence bla bla... will i have to do this: a==b && b==c ?
11:11:23 <monochrom> Yes.
11:11:37 <EvanCarroll> something about the parrot testing suite makes it almost intentionally hard to understand the progress of the project
11:11:42 <c_wraith> HaskellLove:  look at the type of (==)
11:11:43 <EvanCarroll> http://rakudo.org/status
11:11:47 <EvanCarroll> rakudo rather
11:11:52 <zong_sharo> it's likely i need some advice
11:12:05 <zong_sharo> i wrote an command line argument handling library
11:12:31 <zong_sharo> it's safe, extensible, base on af, no unsafePerofrmIO, concise, generates help message
11:12:34 <sinelaw> copumpkin, sigma algebra of s = a set of subsets of s, closed on under complements and unions
11:12:36 <dolio> sinelaw: Maybe I'm confused by your request a bit. You want a free algebra over a signature, or an algebra generated by some signature and a set of particulars?
11:12:49 <zong_sharo> but, i cannot get positional argument parsing
11:13:04 <zong_sharo> for example: ["a", "-b", "c"]
11:13:05 <sinelaw> dolio, see what i just wrote to copumpkin
11:13:22 <zong_sharo> if "-b" is flag, then positional arguments is "a" and "c'
11:13:29 <zong_sharo> ohterwise - just "a'
11:13:39 <zong_sharo> but, my lib is af based
11:13:49 <aavogt> > True == True == True
11:13:50 <dolio> That's a definition of sigma algebra I've never seen before.
11:13:51 <lambdabot>   Precedence parsing error
11:13:51 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
11:14:15 <zong_sharo> so -> (,) <$> positionalArguments <*> blah
11:14:22 <sinelaw> dolio, Hold on to your chair. you're about to see it again.
11:14:25 <sinelaw> http://en.wikipedia.org/wiki/Sigma-algebra
11:14:30 <sinelaw> tada!
11:14:31 <aavogt> > let infixl ==; (==) = (Prelude.==) in True == True == True
11:14:32 <lambdabot>   True
11:14:50 <zong_sharo> positiolnalArguements depends on result of blah, but af inteface forces order of evaluation
11:14:55 <monochrom> sinelaw just editted it in a few seconds. <duck>
11:14:59 <zong_sharo> http://github.com/zong-sharo/argument <- code
11:15:13 <sinelaw> monochrom, http://mathworld.wolfram.com/Sigma-Algebra.html
11:15:22 <monochrom> I'm just kidding!
11:15:29 <sinelaw> dolio, ^^
11:15:34 <dolio> monochrom: How dare you insult my mother!
11:15:59 <sinelaw> your mother?
11:16:45 <dolio> So, these aren't sigma algebras like from algebra?
11:16:55 <dolio> Σ-algebras.
11:17:25 <monochrom> σ-Algebra is not Σ-Algebra. Sorry.
11:17:37 <sinelaw> dogmaT, your MOTHER?
11:17:39 <sproingie> case-sensitive algebra, yay
11:17:42 <sinelaw> oops. dolio!!!
11:17:50 <sinelaw> dogmaT, please, please, please, ignore that.
11:18:02 <monochrom> Someone chose σ to refer to countable union. I don't know why.
11:18:05 <sproingie> is there a Λ calculus?
11:18:08 <dolio> sinelaw: It's an in-joke.
11:18:25 <dolio> Perhaps so in that monochrom doesn't get it.
11:18:42 <sinelaw> anyway
11:18:47 <sinelaw> type SigmaAlgebra a = Set (Set a)
11:18:48 <sinelaw> right?
11:18:49 <copumpkin> the best kind of in-jokes are the kind that only you get
11:18:51 <sinelaw> oops.
11:18:57 <sinelaw> type SigmaAlgebra (Set a) = Set (Set a)
11:19:04 <copumpkin> can't get much more in than that
11:19:07 <sinelaw> copumpkin, grafnook.
11:19:10 <sinelaw> hahaha.
11:19:23 <copumpkin> hahahaha, fail
11:19:28 <sinelaw> doh.
11:19:41 <dolio> Anyhow, algebraists always refer to free algebras over some signature Σ as Σ-algebras, so that's what I thought you were talking about.
11:19:50 <dolio> Clearly that's why F-algebras are a better term.
11:20:11 <sinelaw> dolio, i'm as much an algebraist as you are a _________ .
11:20:20 <sinelaw> (fill in the blank)
11:20:30 <copumpkin> sinelaw: surely the blank must satisfy some laws?
11:20:40 <monochrom> Σ-algebraist
11:20:54 <sinelaw> it must satisfy the law of not satisfying any law.
11:21:00 <sinelaw> you are a bottom! ha.
11:21:04 <sinelaw> j/k.
11:21:06 <monochrom> The blank must be filled by a noun phrase.
11:21:22 <sproingie> ooh mad-libs
11:21:23 <copumpkin> i'm as much an algebraist as you are a person!
11:21:50 <|fft|> finally I got the monad transformer work :)
11:22:04 <copumpkin> |fft|: did you call in optimus prime?
11:22:04 <sinelaw> copumpkin, error: turing test failed.
11:22:11 <Olathe> I'm as much an algebraist as you are a squid.
11:22:22 <|fft|> copumpkin: voltron
11:22:26 <monochrom> OptimusT'
11:22:40 <copumpkin> hah
11:23:04 <sinelaw> copumpkin, unless you ARE an algebraist, in which case the test didn't fail at all
11:23:39 <sproingie> I'm as much an algebraist as you are an algabraist as much as me
11:24:32 <sinelaw> you must really be one, if you came up with that
11:24:35 <twanvl> data SigmaAlgebra a = forall b. SA { set :: b -> Set a, union :: b -> b -> b, complement :: b -> b }
11:24:51 <sproingie> i think that's convergent, but it hurts my brane too much to think about it
11:25:59 <dolio> I doubt you can use Set a from Data.Set, at least.
11:26:19 <Raevel> my rss torrent downloader app works <3
11:26:28 <dolio> Unless you're only dealing with finite sets X.
11:26:55 <sinelaw> twanvl, I didn't get that. does that promise that the set is closed under those operations?
11:26:58 <sinelaw> if yes, how?
11:27:33 <sinelaw> dolio, well how do i represent uncountable sets?
11:27:44 <copumpkin> a -> Bool
11:27:45 <sinelaw> just a type?
11:27:58 <dolio> Uncountable? I don't think you have any uncountable sets.
11:28:11 <dolio> But countably infinite could be a -> Bool, yes.
11:28:12 <monochrom> complement :: b->b says that b is closed under complement.
11:28:15 <wagle> whats the current work in the vein of liang's modular interpreters 10-15 years ago?
11:28:26 <sinelaw> dolio, uncountably infinite?
11:28:41 <monochrom> however, union :: b->b->b is just binary union. we need infinitary union.
11:28:42 <sinelaw> dolio, R?
11:28:43 <dolio> No Haskell type is uncountably infinite, so it doesn't matter.
11:29:30 <twanvl> union :: (b -> Bool) -> b, but that would perhaps be difficult to use
11:29:44 <sinelaw> dolio, isn't there a type for unlimited precision floats?
11:29:56 <dolio> Sure. But there are only countably many of those.
11:30:08 <sproingie> i thought cantor said otherwise
11:30:25 <koeien37> there are only countably many "representable" unlimited precision floats
11:30:27 <sproingie> difference between reals and floats i guess
11:30:40 <koeien37> computable is maybe a better word
11:30:42 <sproingie> there's countable bits of information in the universe anyway
11:31:20 <sinelaw> dolio, excuse me, i learnt math for engineers. is R uncountably infinite?
11:31:28 <koeien37> yes
11:31:29 <sinelaw> dolio, we use 'j' for 'i'.
11:31:32 <SamB_XP> sproingie: actually countable, or just the bits of information in the universe at any given time are what mathemeticians *call* countable?
11:31:34 <monochrom> I take the theorem-prover perspective. I just write down abstract types and axioms. Why worry how a computer can store the set of all sets.
11:31:52 <dolio> R is. But not the computable subset of R, which is all you get in Haskell.
11:31:56 <sinelaw> and the type of unlimited precision floats is not isomorphic to R?
11:32:04 <SamB_XP> I mean, if the universe expands fast enough, you won't be able to count fast enough ;-P
11:32:05 <sinelaw> dolio, oh i see.
11:32:07 <sproingie> heck it's not only countable it's finite
11:32:07 <koeien37> sinelaw: no
11:32:10 <koeien37> 0.999... = 1
11:32:17 <sproingie> finite energy == finite information
11:32:53 <twanvl> monochrom: the computer can store the set of all sets quite easily: "the set of all sets"
11:33:00 <sinelaw> monochrom,  so how would you do the sigma algebra?
11:33:13 <sproingie> once you can accept the idea of the universe expanding into nothing that is something, wearing stripes with plaid comes easy.
11:33:22 <dolio> sinelaw: Any element of R you get in haskell will have a program that computes it. And programs are in correspondence with finite character strings, which is a countable set.
11:33:23 <sproingie> (quote from the Zuma endgame screen)
11:33:28 <wagle> in an analog computer, the finite energy "is a real number" </scare-quotes>
11:33:41 <twanvl> sinelaw: what do you actually want to do with it?
11:34:18 <sinelaw> twanvl, pet it
11:35:00 <twanvl> :)
11:35:01 <wagle> (there was that argument 15 years ago..  dunno what happened/turned-out)
11:35:19 <sinelaw> dolio, what's the capacitance of R?
11:35:24 <sinelaw> :P
11:36:10 <sinelaw> dolio, but yes, that's an important distinction.
11:36:20 <monochrom> sinelaw: I would do it in Isabelle/HOL. has typeclass. has axioms in typeclass.
11:36:31 <sproingie> twanvl: how about the set of all sets that don't contain themselves? ;)
11:36:52 <joe3> i have a binary file and I want to work on the contents of the file on a byte-by-byte basis. I want to use Data.ByteString.Lazy.Char8 for my purposes. But, the definition of "ByteString" contains 8-bit characters only. When it refers to ***characters***, will it do some transformation from byte to char8Z
11:36:57 <joe3> i have a binary file and I want to work on the contents of the file on a byte-by-byte basis. I want to use Data.ByteString.Lazy.Char8 for my purposes. But, the definition of "ByteString" contains 8-bit characters only. When it refers to ***characters***, will it do some transformation from byte to char8?
11:37:14 <wagle> http://en.wikipedia.org/wiki/Super-Turing
11:37:23 <joe3> just want to make sure that it does not.
11:37:31 <sproingie> wagle: does he have a cape?
11:37:44 <joe3> I know that the System.IO does some transformations such as CRLF to LF, etc.
11:38:10 <jmcarthur> joe3: you mean you want unicode characters and not just Char8s?
11:38:12 <sproingie> even superturing machines have the halting problem
11:38:22 <doserj> joe3: then why do you want to use Char8, if you are worried?
11:38:24 <wagle> sure
11:38:47 <stepcut> I seem to be getting a lot of 'unknown symbol' errors while linking with GHC 6.12, on code that works fine under 6.10. Is this a known issue?
11:38:58 <stepcut> sometimes compiling with -O0 helps, but not always
11:39:08 <wagle> but when i asked hava if she'd constructed the halting problem solver for turing machines, she said yes
11:39:09 <dolio> Anyhow, if you want sigma-algebras over a type T, then a single type SigAlg T isn't right, is it? There is potentially more than one sigma-algebra over a particular set, right?
11:39:16 <joe3> jmcarthur: it is a binary file and I want to break the file into a list of binary chars such as [0,1,1,0,...]
11:39:32 <joe3> doserj: I like the lazy functionality as the file can be huge.
11:39:36 <sproingie> sure but you need a super-super-TM to solve the super-halting problem
11:39:44 <sproingie> (super-duper)
11:39:49 <dolio> What you want is U : SigAlg T, and then you have u v : U where T - u : U and u `union` v : U and so on.
11:40:08 <jmcarthur> joe3: oh. you could just... map over each Char8 with a function to convert it to a binary representation then concatenate the result
11:40:12 <wagle> what if the continuum hypothesis is false?
11:40:41 <wagle> (or unprovable?)
11:40:44 <neosoothsayer> who's ravi?
11:40:44 <joe3> jmcarthur: before I break up each byte into a list of binary digits, I want to ensure that the library hGetContents of the char8 library does not transform the contents.
11:40:44 <jmcarthur> joe3: or are you concerned about negative values or something?
11:40:59 <wagle> 8)
11:41:00 <jmcarthur> joe3: oh you mean stuff like newlines?
11:41:04 <joe3> jmpcarthur: yes
11:41:10 <joe3> jmcarthur: yes
11:41:24 <doserj> joe3: what's wrong with Data.ByteString.Lazy?
11:41:38 <joe3> doserj: will check it out.
11:41:48 <joe3> I did not know that there was such a library.
11:41:58 <joe3> I thought there was just Lazy.Char8
11:41:59 <sproingie> there'd be a nice shiny fields medal for anyone who solved the continuum hypothesis i'm sure
11:42:17 <jmcarthur> joe3: the only difference is one exposes Char8 and the other exposes Word8
11:42:30 <doserj> continuum hyptothesis is solved
11:42:40 <sproingie> proven one way or the other?
11:42:52 <wagle> just wondering if a P(Z) machine could solve the R machine halting problem..  8)
11:42:53 <jmcarthur> joe3: the binary package just uses lazy bytestring's readFile action without doing anything too special, so i guess it's safe
11:43:02 <doserj> proven to be independant from the other Acioms in ZFC
11:43:11 <monochrom> That's like a fields medal for proving the reals countable.
11:43:25 <joe3> jmcarthur: what is the difference between word8 vs char8?
11:43:37 <joe3> jmcarthur: sorry if this is a stupid question
11:43:50 <joe3> in asm, I know that word = 16 bits and char = 8 bits
11:44:01 <jmcarthur> > (minBound :: Char8, minBound :: Word8)
11:44:02 <lambdabot>   Not in scope: type constructor or class `Char8'
11:44:05 <Olathe> Word8 is unsigned 8-bit integer.
11:44:06 <joe3> jmcarthur: but am not sure how this translates to haskell
11:44:16 <Olathe> Word16 is unsigned 16-bit integer.
11:44:17 <Olathe> Etc.
11:44:17 <wagle> it all sorta hinges on cantor's definitions
11:44:17 <jmcarthur> > (minBound :: Data.Char.Char8, minBound :: Data.Word.Word8)
11:44:19 <lambdabot>   Not in scope: type constructor or class `Data.Char.Char8'
11:44:22 <jmcarthur> eh whatever
11:44:26 <jmcarthur> i never use it anyway
11:44:38 <mauke> there is no Char8 type
11:44:51 <jmcarthur> that is what i suspected. just uses Char, right?
11:45:06 <doserj> joe3: Data.ByteString.Lazy.Char8 offers some functions to directly work with Chars and Strings
11:45:36 <joe3> doserj: so I am better off sticking to Data.ByteString.Lazy then.
11:45:39 * wagle wonders if there's an ASCII (or ASCII7 and ASCII8, or umm you know)
11:45:39 <joe3> doserj: thanks.
11:45:44 <jmcarthur> Word8 is unsigned Int8
11:45:55 <joe3> jmcarthur: that is what I need.
11:46:34 <ray> :t '光'
11:46:36 <lambdabot>     lexical error in string/character literal at character '?'
11:46:53 <mauke> > ord '光'
11:46:54 <lambdabot>   20809
11:47:09 <monochrom> Data.ByteString.Lazy.Char8 means that it gives you Char but the Char's come from bytes, one byte becomes one Char.
11:48:14 <monochrom> But newline may be orthogonal to this. newline is controlled by handles, "text mode" vs "binary mode".
11:51:21 <joe3> monochrom: so, I am better off with sticking to Data.ByteString.Lazy if I want to work with bytes as such and not bother with their ascii character representation?
11:51:36 <jmcarthur> joe3: i would use that
11:51:40 <monochrom> I believe that is completely not true.
11:51:48 <sinelaw> Is there any point in defining this?
11:51:49 <sinelaw> data SetOf a = SetOfS (Set a) | SetOfF (a -> Bool)
11:52:17 <monochrom> If the handle is already in text mode, you will get newline fudging whether you ask for Char or Word8.
11:52:41 <wagle> isnt "Char" sort of like "Int"?  only worse, because you dont know what encoding even 10-20 years from now?
11:52:44 <sinelaw> forget it. it's silly.
11:53:14 <monochrom> Data.ByteString.Lazy.* is on top of handles.
11:54:15 <jmcarthur> monochrom: the binary package's decodeFile function or whatever it's called just uses L.readFile without specifying a mode
11:54:20 <sinelaw> on second thought: Should there be a Set typeclass?
11:54:23 <sinelaw> (I think there should)
11:54:36 <joe3> monochrom: i am opening the file with openBinaryFile
11:54:37 <twanvl> wagle: no, a Char is (or at least should be) a Unicode code point, it has nothing to do with encoding
11:55:14 <monochrom> Oh good, if you explicitly openBinaryFile then there is no newline fudging.
11:56:00 <monochrom> And if there is no newline fudging then both ByteString.Lazy and ByteString.Lazy.Char8 will not have newline fudging either.
11:56:28 <wagle> twanvl: 10-20 years ago, the encoding du jour was ascii..  now its unicode..  what's next?
11:56:52 <monochrom> Look, ByteString.Lazy.Char8 is just ByteString.Lazy composed with a call to "chr" or "fromEnum" that is all.
11:57:22 <twanvl> wagle: unicode is not an encoding, and besides, it is designed to last a long time
11:57:28 <jmcarthur> wagle: uniascii
11:57:41 <mauke> unicode is extended ascii
11:57:45 <wagle> sure its an encoding..  huh?
11:57:52 <koeien37> UTF-x is an encoding
11:58:10 <mauke> wagle: unicode isn't an encoding
11:58:22 <sproingie> in that the lower 127 unicode codepoints are ascii.  calling it extended ascii is like calling base-10 extended binary
11:58:36 <mauke> s/7/8/
11:58:54 <HaskellLove> since i installed ghc 6.10 in bash in ubuntu i cant use HOME or END, it just types character does not go at start or end of line. And this is in the interpreter, in bash HOME and END work... anyone has this problem too?
11:58:56 <sproingie> mauke: i start counting at 0 :)
11:59:21 <mauke> HaskellLove: whch 6.10?
11:59:46 <koeien37> 6.10.4 should have haskeline
11:59:56 <HaskellLove> GHCi, version 6.10.4
12:00:04 <sproingie> no problems here
12:00:05 <mauke> (that's why I recommend 6.10.2 and a patch)
12:00:08 <monochrom> I cannot reproduce your problem.
12:00:32 <sproingie> i have 6.10 at home on ubuntu 9.10, no problems
12:00:49 <sproingie> but then i mostly run ghci in emacs
12:00:51 <wagle> int is an encoding of integers.
12:01:01 <wagle> in a particular range
12:01:17 <mauke> wagle: what are you talking about?
12:01:24 <sproingie> big-endian and little-endian is an encoding of integers in a particular range
12:01:26 <wagle> what are you talking about?
12:01:27 <sproingie> int is a datatype
12:01:50 <mauke> sproingie: even then you've got issues with negative numbers
12:01:50 <wagle> ones complement, two's complement..
12:02:00 <sproingie> mm that too
12:02:16 <monochrom> People are so naïve.
12:02:17 <wagle> you pointless pedantic down pat
12:03:01 <sproingie> That's just silly.  I mean, has anyone really been far even as decided to use even go want to do look more like?
12:03:15 <Veinor> monochrom: bonus points for the diacritic
12:04:33 <sinelaw> so nobody ever defined a type class for sets?
12:05:01 <monochrom> I haven't seen one.
12:05:11 <wagle> i saw a monad for sets, didnt look to see what they did about Eq
12:07:37 <dolio> collections probably has a class for sets.
12:07:42 <dolio> And Edison.
12:13:56 <Raevel> anyone familiar with parseargs? for argIndex :: a the docs say "Connects the input description to the output argument.". i don't understand what they mean
12:15:20 <sinelaw> interesting idea:
12:15:20 <sinelaw> http://repetae.net/recent/out/classalias.html
12:15:46 <dolio> Yes, everyone likes class aliases.
12:15:56 <dolio> I suggest you implement them for us. :)
12:16:12 <sinelaw> dolio, good idea. I suggest you implement that idea.
12:22:52 <sinelaw> Can someone explain this syntax?
12:22:54 <sinelaw> class Monoid c => Map c k a | c -> k a where
12:23:07 <dolio> Functional dependencies.
12:23:10 <sinelaw> whats the "| c -> k a"?
12:23:18 <dolio> c uniquely determines k and a.
12:23:26 <sinelaw> is that an extension?
12:23:32 <dolio> Yes.
12:24:41 <sinelaw> dolio, I see it's not in haskell 2010
12:25:17 <dolio> There is significant overlap between them and type families, and the latter are preferred by quite a few people.
12:25:42 <sinelaw> dolio, so what does that definition above say about Map?
12:25:54 <dolio> So I wouldn't expect them to appear in any future standard, really.
12:26:20 <dolio> It says that given c, you know what k and a are, and you can only declare a single instance for any given c.
12:26:36 <dolio> c is the type of maps, k is the type of keys, and a is the type of things stored in the maps.
12:26:52 <dolio> So "Map (Data.Map k a) k a" would be a likely instance.
12:27:06 <sinelaw> ah, i see
12:28:43 <sergdf> i'm interested in storing data very compactly in memory, with the ability to look it up quickly. I've found Data.Trie in hackage. Can anyone suggest other avenues I might investigate?
12:29:04 <sinelaw> dolio, but also type families aren't in hask 2010
12:29:15 <wagle> never saw type families before, but i like what i think "Map (Data.Map k a) k a" does/means
12:29:18 <dolio> Yeah, well, they're a little under-baked at present.
12:29:23 <sproingie> lots of things arent' in haskell 2010
12:29:36 <sproingie> heck mptc's aren't even in
12:29:53 <sinelaw> sproingie, i didn't expect them to be, i just misunderstood what dolio said about functional dependencies
12:30:13 <dolio> The type families equivalent is "class Map c where type Key c :: * ; type El c :: * ; ..."
12:30:37 * wagle now wonders about some "type family inference" thing
12:30:55 <HaskellLove> [[[9011,1091,1901,1109],[9011,1091,1901,1109]], [[9012,1091,1901,1109],[1,2,3,4]]] How would you guys retreive the list [1,2,3,4] ... the predicate that it satisfies is hasSequenceProperty, which basically means d-c==c-b==b-a... i have hasSequenceProperty defined but, i have problems filtering and getting the list efectively, i get crazy with filter and map
12:32:29 <twanvl> sergdf: it depends on what kind of data you have
12:32:59 <sinelaw> @hoogle (\f g x s -> if (f x) then (g x s) else s)
12:32:59 <lambdabot> Parse error:
12:33:00 <lambdabot>   --count=20 "(\f g x s -> if (f x) then (g x s) else s)"
12:33:00 <lambdabot>                ^
12:33:07 <twanvl> HaskellLove: "filter hasSequenceProperty" or "find hasSequenceProperty" should work
12:33:10 <neosoothsayer> Does anyone know of a rebuttal to Andrei Alexandrescu's comment on the writing qsort function in haskell? He seems to have a point about the inefficiency... - link: http://www.informit.com/articles/article.aspx?p=1407357&seqNum=3
12:33:35 <HaskellLove> twanvl but the list is nested deep
12:33:36 <sproingie> the canonical quicksort example shows off haskell's expressiveness.  it's *NOT* an efficient algorithm
12:33:54 <sproingie> if you're talking about the haskell version i think you are
12:33:55 <twanvl> HaskellLove: then use concat to flatten it
12:34:25 <sproingie> alexandrescu is absolutely correct
12:34:47 <HaskellLove> twanvl the structure is broken with concat
12:34:55 <neosoothsayer> yeah, I was talking about the canonical example - so thats not how one would write it in the real work in Haskell?
12:35:01 <sproingie> it's definitely not
12:35:06 <monochrom> neosoothsayer: I think we are long past the era of using those lines of code to introduce haskell.
12:35:07 <twanvl> HaskellLove: oh, you want to filter each sublist?
12:35:25 <twanvl> neosoothsayer: quicksorting linked lists is stupid anyway
12:35:30 <sproingie> what's cool about haskell is that you can use the inefficient version as a specification and then prove a more efficient version is equivalent to it
12:35:39 <dolio> Any sort on lists isn't going to do a whole lot better.
12:36:01 <dolio> You're not going to do better in C, even, unless you're ready for hideous complexity.
12:36:02 <ColonelJ> sproingie: why is that a property of haskell? I think you can do that with any language...
12:36:27 <sproingie> ColonelJ: sure but you can generate the tests
12:36:48 <sproingie> theorem prover might even prove them equivalent though that's probably more academic than practical
12:37:11 <ColonelJ> sproingie: I'm sure there are proof systems for many other languages, including C
12:37:28 <sergdf> twanvl: (re: space-efficient data structures) i'm working with strings and int64's
12:37:28 <sproingie> i'm sure they're even hairier than ones for haskell
12:37:53 <ColonelJ> sproingie: well I'm sure they are, but still
12:38:09 <sproingie> you can always write functional programs in C, yes
12:39:05 <twanvl> sergdf: then look at Data.Text, Data.ByteString and uvector, those are all unboxed arrays of raw data
12:39:23 <sproingie> linked lists are elegant looking and friendly to gc but they're rarely efficient
12:39:43 <Heffalump> what makes them friendly to GC? Fewer pointers to traverse?
12:39:55 <neosoothsayer>  Is Andrei mistaken that Haskell should do the same things as C more efficiently or atleast equal in performance? Are they meant for use in different ways that makes the question of qsort performance moot?
12:39:59 <sproingie> you can just lop off whatever chunk of it you want
12:40:44 <sproingie> friendly to quick gc'ing when consuming it, i should say
12:40:54 <j4cbo> i think there's an important distinction between GC'd and non-GC'd languages as performance goes:
12:40:56 <sproingie> other operations may be downright hostile to gc i suppose
12:41:17 <j4cbo> with a GC'd language, you pay the penalty for allocation only when you free the object (when the GC happens)
12:41:30 <ane_> neosoothsayer: I think he's trying to say that haskell shouldn't be demonstrated like this
12:41:30 <j4cbo> with a non-GC'd language, you pay the penalty mostly when you *allocate* it, and not so much when you free it
12:41:40 <j4cbo> so direct comparisons are kinda difficult.
12:41:59 <sproingie> most gc's don't really free objects.  garbage collection is kind of a misnomer, they normally collect everything that isn't garbage
12:42:21 <j4cbo> sproingie: are copying GCs "most" GCs? :P
12:42:39 <j4cbo> (they are in the FP world, yes, but they generally aren't for imperative languages afaik)
12:42:41 <sproingie> generational works the same way
12:42:50 <neosoothsayer> j4cbo & sproingie : thanks for your comments. Insightful!
12:43:29 <j4cbo> in languages like C, an important non-automatable part of optimization is reducing your allocator load
12:43:36 <sproingie> most geniune haskell advocacy doesn't use that quicksort example
12:43:55 <j4cbo> i have absolutely no idea how well optimizing haskell compilers like GHC do that.
12:44:03 <ane_> isn't the factorial example becoming more and more ubiquitous
12:44:18 <j4cbo> but i suspect it's not very good, since there isn't even automatic bytestring rolling afaik
12:44:19 <SamB_XP> sproingie: or at least doesn't seriously try to claim it does the same as the usual quicksort does
12:44:30 <neosoothsayer> Interestingly, the Haskell wiki lists that example for qsort
12:44:35 <sproingie> not calling it quicksort would probably be a good start
12:44:51 <sproingie> it's quicksort-ish
12:45:02 <j4cbo> yeah, http://www.haskell.org/haskellwiki/Introduction/Direct_Translation *seriously* turned me off from haskell
12:45:25 <j4cbo> the message that page gives is "in order to write performant haskell code, you have to make it look like C"
12:45:31 <j4cbo> which isn't really true, but...
12:45:44 <mercury^> That's largely true in my experience.
12:45:54 <j4cbo> see, this is why i use SML :P
12:46:36 <kmc> most parts of most programs don't need to be fast
12:46:43 <mercury^> If you want highest performance, you will probably use something different to both Haskell and SML.
12:46:49 <Heffalump> how much nicer would SML look? I think the biggest problem with Haskell for imperative programming is that it is really verbose at simple stuff like reading variables.
12:46:50 <kmc> i would rather spend my time making the code fast than getting it to work at all
12:46:57 <j4cbo> kmc: that's a bad excuse
12:47:04 <kmc> i don't see why
12:47:11 <sproingie> mlton is supposed to be pretty darn fast, but haskell is getting there
12:47:17 <mercury^> j4cbo: everyone lives by that excuse.
12:47:21 <mercury^> GHC is much better than mlton.
12:47:21 <kmc> fwiw haskell passed ocaml on shootout
12:47:29 <sproingie> clean is damn fast
12:47:34 <kmc> (with ghc)
12:47:37 <mercury^> And the shootout is meaningless.
12:47:42 <j4cbo> ocaml is slower than mlton.
12:47:48 <sproingie> code on shootout is far from idiomatic
12:47:58 <kmc> (is there a name for the inria ocaml compiler?)
12:48:02 <SamB_XP> they won't let us use our usual tricks on shootout anyway
12:48:06 <sproingie> ocamlc
12:48:07 <sinelaw> mercury^, exactly. they should have an 'average' shootout. what the average experienced programmer would do
12:48:30 <SamB_XP> hmm, doesn't the native compiler have a different name ?
12:48:35 <mercury^> sinelaw: it's not even that it's wrong to optimise. The problems however are illposed.
12:48:46 <SamB_XP> ocamlopt, maybe ?
12:48:48 <mercury^> And most solutions are far from that language's optimal solution.
12:48:52 <sproingie> rosetta code is better for idiomatic code samples
12:49:07 <kmc> SamB_XP, yeah
12:49:17 <kmc> i want a name for the implementation in general
12:49:26 <SamB_XP> kmc: ocaml ;-P
12:49:26 <kmc> but "ocamlopt" is all right i suppose
12:49:31 <kmc> SamB_XP, that's the language
12:49:40 <sproingie> ocaml has just one implementation.
12:49:51 <kmc> but there's no reason it has to
12:50:05 <SamB_XP> yeah, but the inmplementation has no name yet because of this
12:50:05 <kmc> even when there is only one implementation, it is worth distinguishing between the language and the implementatiot
12:50:27 <sproingie> perl never sees the need
12:50:30 <j4cbo> i think "ocaml" is defined as the language implemented by ocaml
12:50:34 <kmc> it bugs me that a lot of programmers don't even seem to understand the difference between a language and an implementation
12:50:55 <aavogt> what do programmers care about a language specification?
12:50:57 <sproingie> some languages are defined by the implementation
12:51:02 <SamB_XP> most are ;-P
12:51:08 <SamB_XP> I mean, the ones actually used
12:51:10 <kmc> unfortunately yes
12:51:16 <Heffalump> aavogt: it enables them to separate bug from feature
12:51:25 <j4cbo> when you pass -fstd=gnu89 to GCC, it implements the gnu89 version of the language, which is defined as "the version that gcc implements when passed -fstd=gnu89"
12:51:51 <SamB_XP> I mean, all the various C compilers have scads of extensions and such ...
12:51:53 <sproingie> python has three major implementations, coming up on four.  ruby has several VMs, though only one is official at any one time
12:51:58 <j4cbo> and they say recursion isn't as important in C!
12:52:26 <aavogt> but does GHC win by the number of extensions?
12:52:27 <kmc> haha
12:52:28 <SamB_XP> yeah, okay, so sometimes you try to write code that will work with several implementations, yes
12:52:35 <j4cbo> sproingie: which one do you count as "coming up on"? CPython, IronPython, Jython, PyPy as the new one?
12:52:36 <SamB_XP> well, I guess it helps when you HAVE a spec?
12:52:43 <SamB_XP> I don't think ocaml does...
12:52:44 <sproingie> j4cbo: unladen-swallow
12:52:44 <kmc> Unladen Swallow
12:52:55 <j4cbo> ah
12:52:57 <sproingie> i completely forgot about pypy actually
12:53:00 <sproingie> so there's four coming up on five
12:53:12 <aavogt> Heffalump: arguably specifications can have bugs too....
12:53:17 <j4cbo> well, last i knew pypy wasn't really going anywhere :P
12:53:27 <j4cbo> so i guess that hasn't changed
12:53:32 <SamB_XP> Python doesn't *precisely*, but it has a number of implementations that are not contested by Python.org
12:53:44 <sproingie> j4cbo: yah that's kind of why i forgot about it
12:53:53 <SamB_XP> and it does have a bunch of PEPs...
12:54:00 <SamB_XP> and a reference manual or two
12:54:20 <kmc> this is why the difference matters... CPython is slow, so people think Python code must always be slow
12:54:31 <SamB_XP> and if you can't run the pure-python part of CPython's library, you've probably got issues
12:54:32 <sproingie> cpython is considered the reference, but GVR considers them all "official"
12:54:32 <kmc> CPython is an interpreter, so people think Python is an "interpreted language", a total nonsense term
12:55:06 <SamB_XP> well, I have to admit I wouldn't use a Python implementation that didn't come with a REPL...
12:55:10 <j4cbo> i'm very sad that Psyco seems to be falling into disrepair.
12:55:19 <kmc> SamB_XP, but you can have a compiled REPL
12:55:35 <SamB_XP> fine
12:55:37 <sproingie> j4cbo: was always useless to me on 64-bit machines
12:55:43 <j4cbo> SML/NJ has one.
12:55:50 <j4cbo> sproingie: my point exactly. :P
12:55:53 <kmc> SamB_XP, or a GHCi-like hybrid
12:55:56 <sproingie> way to not catch the netsplit, irssi
12:56:06 <sinelaw> Where can I see which type classes the function type (a->b) is an instance of?
12:56:15 <SamB_XP> but the features that make Python "interpreted" *do* tend to cause headaches for optimizers ;-)
12:56:28 <Heffalump> aavogt: sure, but it's less likely
12:56:30 <kmc> SamB_XP, you mean the dynamic features?
12:56:44 <SamB_XP> yeah
12:56:51 <kmc> it's true, i don't see a full static compiler for Python being successful
12:57:01 <kmc> but a JIT compiler could be
12:57:09 <kmc> and Psyco already is, to some degree
12:57:11 <SamB_XP> can be, yes
12:57:12 <j4cbo> i would love to see a whole-program compiler for Python...
12:57:16 <SamB_XP> it's just not very portable
12:57:16 <j4cbo> Pyton, like MLton :P
12:57:22 <kmc> haha
12:57:22 <SamB_XP> j4cbo: you'd not love it
12:57:26 <sproingie> that'd be a neat trick
12:57:27 <kmc> is MLton whole-program?
12:57:45 <j4cbo> yep
12:57:55 <sproingie> Stalin for python
12:57:59 <sproingie> you could call it Palin
12:58:01 <kmc> even into the library?
12:58:03 <kmc> sproingie, hahahahaha
12:58:06 <j4cbo> kmc: yep
12:58:09 <ane_> heh
12:58:15 <kmc> j4cbo, does it cache results of analyzing the libraries?
12:58:17 <elly> mm, stalin
12:58:25 <j4cbo> kmc: no, and so it takes *forever* to compile anything
12:58:31 <kmc> damn
12:58:55 <SamB_XP> that'd go SO well with Python's crazily dynamic features
12:59:19 <sproingie> ruby's got even more crazy dynamic goofiness in some ways
12:59:42 <SamB_XP> well, I don't really feel like learning Ruby
12:59:58 * increpare chortles at sproingie
12:59:59 <SamB_XP> the fact that it had no in-REPL help was a turn-off for me ;-P
13:00:02 <wagle> maybe not enough of a rewording (but I'm surprised to get no response):  whats the state-of-the-art these days for modular interpreters and/or (probably implementations of) modular denotational semantics?
13:00:08 <sproingie> irb is still awful
13:00:42 <joe3> hello, wondering if you might have some comments on a small program that I wrote: http://pastebin.com/m2a5836e6
13:00:47 <SamB_XP> I was like "huh? no help()? how am I supposed to look at the docstrings?"
13:00:51 <joe3> please feel free to be critical
13:01:04 <joe3> is anyone having problems with hpaste?
13:01:15 <Raevel> yes
13:01:50 <sproingie> joe3: you'll need to do something like print it or it's not going to do anything
13:02:25 <Raevel> joe3: flip div 2 is (`div` 2)
13:02:30 <Heffalump> SamB_XP: you can't get at the docstrings in ghci either, can you?
13:02:45 <sproingie> i would so love haddock integration in ghci
13:02:46 <joe3> sproingie: yes, it is just a sample program that I wanted to check if it fits in haskell thinking.
13:03:07 <SamB_XP> true, but Haskell was different enough from Python that it didn't bother me so much ...
13:03:13 <sproingie> joe3: you've got dminus and dplus using exactly the same code, suggests to me you could factor it out
13:03:21 <joe3> i am just a bit unsure about the duplicate code for opening filehandles, etc..
13:03:37 <sproingie> joe3: and personally i use $ instead of parens but that's purely a matter of style
13:03:38 <SamB_XP> and, you know, :t and :b is a heck of a lot better than what I could find in ruby ;-P
13:03:46 <joe3> sproingie: yes, they are both exactly same except for the filename.
13:03:48 <SamB_XP> excuse me, *:browse*
13:04:09 <SamB_XP> oh, and :i
13:04:17 <sproingie> joe3: factor that out into a function in a 'where' clause.  or even a new top-level function
13:04:37 <joe3> sproingie, will try. thanks.
13:05:07 <Raevel> joe3: you could also do import Data.ByteString.Lazy as BL to shorten the code a bit
13:06:09 <joe3> ok, thanks.
13:07:16 <sproingie> it's pretty easy to add new commands to ghci, i should take a whack at haddock support
13:08:13 <sproingie> be easier for me to bash it up in elisp for haskell-mode tho
13:09:04 <joe3> thanks a lot, I just made the changes recommended: http://pastebin.com/m24bded0b
13:09:14 <joe3> nothing fancy..
13:09:44 <skorpan> joe3: what's with prefixing stuff with Prelude?
13:10:14 <Raevel> i also prefer to not indent do's that much, for instance line 12 could be indented only 2 spaces from the left margin
13:10:15 <joe3> skorpan: sorry that is commented out.
13:10:22 <Cale> hmm, looks like someone has to unclog hpaste's tubes
13:10:41 <joe3> skorpan: i was trying it out in ghci and it was complaining about functions in prelude and data.bytestring
13:10:55 <joe3> skorpan: i used the prefixing to get rid of those errors.
13:11:01 <Cale> joe3: import qualified Data.ByteString.Lazy as BS (unpack,hGetContents)
13:11:33 <joe3> skorpan: when using ghci, do u use ":m + xx" for every module that u use or do u do something else?
13:11:37 <joe3> Cale: Thanks.
13:11:38 <Cale> Though, as you have it written there, it ought not to overlap with the prelude
13:11:46 <skorpan> joe3: i rarely use ghci to be honest
13:11:52 <Raevel> alike so; http://pastebin.com/m791f8e3d
13:11:56 <Cale> skorpan: Whaaaaaaat
13:12:19 <skorpan> Cale: what? :P
13:12:27 * Cale doesn't write Haskell code without both GHCi and an editor window open.
13:13:03 <skorpan> okay, i use ghci, but not like that.  i C-c C-l in emacs :P
13:13:07 <Cale> ah
13:13:11 <joe3> Raevel: what did u do?
13:13:30 <Cale> joe3: another tip, you can combine adjacent lets without having another let keyword, as long as you maintain the indentation level
13:13:50 <joe3> Cale: thanks, I did not know that.
13:14:15 <Raevel> joe3: remove a bunch of whitespace
13:14:28 <Cale> I forget who is in charge of hpaste.org
13:14:44 <Cale> Was it glguy?
13:15:16 <matsuura> not sure
13:15:31 <monochrom> use http://moonpatio.com/fastcgi/hpaste.fcgi/
13:16:44 <joe3> Raevel: thanks.
13:18:27 <joe3> btw, do you think my code will stand (though simple) if both of the files are around 360 Mega bytes each in size
13:19:01 <joe3> i am hoping that by using the lazy library, I do not have to worry about processing issues/system hangs?
13:19:40 <Cale> Well, this program doesn't actually do anything at all so far...
13:20:09 <Cale> The reverse which is in there is a little worrying.
13:20:14 <joe3> i am hoping to load this into ghci with a break and analyse the data
13:20:33 <HaskellLove> wohooooo EULER 49 solved! http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5666#a5666
13:20:35 <Cale> You should probably move those definitions to the top level
13:20:55 <joe3> Cale: i am using the reverse on only one byte at a time. Do u still think that it could be an issue?
13:21:02 <joe3> Cale: ok, will do.
13:21:13 <Cale> joe3: Oh, in that case, it's fine
13:22:41 <Twey> Heh
13:22:57 <Twey> It's the same as doing it on lots of bytes at the same time, but it's okay because it doesn't look as bad!
13:23:06 * Twey suffers from this, too.
13:23:19 <Cale> It's not quite the same
13:23:44 <Cale> It's the same time-wise
13:23:49 <Cale> but not memory wise
13:24:00 <Twey> Ah, true
13:24:13 <sinelaw> How can I express this in haskell? the type of either type A or type B
13:24:19 <Twey> It would be nice if lists were doubly-linked.  We could do constant-space reverse.
13:24:33 <Cale> But no constant time cons
13:24:33 <Twey> sinelaw: Either A B
13:24:43 <Twey> Cale: There is that :-\
13:24:46 <sinelaw> Twey, yah ok
13:25:28 <sinelaw> another question
13:25:50 <skorpan> HaskellLove: dude, numberHasDigits_1487 n = (sort $ map digitToInt $ show n ) == [1,4,7,8], seriously?
13:26:07 <Cale> sinelaw: Sometimes it's a good idea to work out what the choice between types really means and define a new datatype, but if it's nothing too special, Either can be convenient because it has a fair amount of library support already.
13:26:24 <HaskellLove> skorpan what?
13:26:51 <sinelaw> Cale, i want exactly that type (either type a or type b) and nothing more.
13:27:28 <Cale> sinelaw: I suppose that's fine. If one of the two represents an error, make sure that's the first parameter to Either.
13:28:07 <sinelaw> Cale, yes I know that - thanks
13:28:22 <HaskellLove> by the way step4: filter d-c == c-b == b-a is step4: filter c-b == b-a, forgot to delete d... anyways, skorpan numberHasDigits_1487 given a number like 1847 returns true because it contains those digits... what is so not clear here?
13:28:32 <Raevel> oh i changed my mind about parseargs, it's nice
13:28:47 <Cale> There's so much meaningless hpaste spam
13:29:44 <Cale> Looks like some spammer testing a program to submit spam without actually having anything meaningful to advertise.
13:29:46 <skorpan> HaskellLove: it just strikes me as strange to use sorting and (==) to do that
13:30:25 <Cale> skorpan: What strikes me as stranger is that the number to check against is part of the name of the function rather than a parameter
13:30:27 <sproingie> that is so missing the point of the problem
13:30:27 <sinelaw> if my class laws has an axiom that there exists a value of the type class that satisfies some property, does that neccesarily mean i MUST show a general implementation?
13:30:28 <HaskellLove> skorpan well it is creative in my opinion, how else would you check if a number contains some digits?
13:30:31 <skorpan> Cale: that too
13:30:38 <sinelaw> s/has/have
13:31:22 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5667#a5667
13:31:26 <skorpan> HaskellLove: `all' and `elem' sound like a good start
13:31:34 <Cale> ^^ there's the solution I banged out the other day when you mentioned the problem :)
13:31:48 <Cale> (including a permutations function :)
13:32:11 <HaskellLove> Cale I wrote one too wanna see it :) but not recursive
13:32:29 <Cale> sure
13:32:51 <HaskellLove> skorpan it can be parametrized i just did it so for this problem... anyways all and elem will do the same thing so mine is cooler
13:33:06 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
13:33:09 <lambdabot>  Defined.
13:33:32 <HaskellLove> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5668#a5668
13:33:54 <Cale> > let perms xs = evalStateT (mapM (const (StateT select)) xs) xs in perms [1,2,3]
13:33:55 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
13:34:46 <Cale> HaskellLove: Oh, you just search all the numbers for the ones which happen to be permutations?
13:34:49 <HaskellLove> Cale I also did one that does permutations but using indices let me post that one too :)
13:35:09 <HaskellLove> yep and that is slow, so the second one i permute indices and retreive elements :)
13:35:40 <HaskellLove> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5669#a5669
13:35:48 <sproingie> i can't wait for the problems that will take billions of years to brute-force
13:35:52 <Cale> Yeah, that's a rather inefficient way to do it, but it doesn't really matter for this problem, since there are only 9000 numbers you care about
13:36:21 * hackagebot upload: data-clist 0.0.1 - Simple functional ring type. (JohnVanEnk)
13:36:23 * hackagebot upload: data-clist 0.0.2 - Simple functional ring type. (JohnVanEnk)
13:36:31 <sproingie> that was quick
13:36:39 <sshc> that was quick
13:36:50 <monochrom> sproingie: I can't either. It's a billion-year wait. XD
13:36:58 <Cale> Why would a ring type be in clist?
13:37:24 <monochrom> Maybe because clist = cyclic list = ring buffer
13:37:49 <Cale> Ah, right, I just thought that perhaps I was misinterpreting what you meant by ring as you said that :)
13:37:52 <HaskellLove> Cale the second one does it with indices, lot faster :) imagine having numbers to 123456789 i would have to generate them all with my first approach, but with the second i just do it with indices so i use the first function to permute [1..length $ show number] and then just retrieve elements from that :)
13:37:55 <sinelaw> hmm. Haskell types are not sets.
13:37:58 <Cale> s/you/they/
13:38:18 <sinelaw> they don't satisfy extensionality
13:38:24 <Cale> sinelaw: huh?
13:38:30 <dolio> That's okay. Sets are lame.
13:38:36 <sinelaw> wait, they do. sorry.
13:38:52 <Cale> sinelaw: Well, they might not, but I can't think of any examples of that.
13:38:54 <monochrom> Cale: We had a little cross-purpose-talk concerning σ-algebra and Σ-algebra earlier today. It did not help that both parties used the wording "sigma-algebra". :)
13:39:29 <sinelaw> a newtype has the same values as the old type?
13:39:32 <SamB_XP> but not Sigma-algebra?
13:39:55 <uorygl> All you need now is a ς-algebra.
13:40:04 <SamB_XP> cedilla algebra ?
13:40:10 <mauke> no, that's ç
13:40:13 <monochrom> OK, "Sigma-algebra" too, but didn't help much empirically.
13:40:14 <uorygl> No, that's also the Greek letter sigma.
13:40:16 <dolio> Quesadillas?
13:40:26 <Cale> I know the boolean algebra / measure theory sort of sigma algebra, what's the other one?
13:40:41 <dolio> Cale: Free algebra over signature sigma.
13:40:45 <Cale> ah, okay
13:40:49 <monochrom> Σ is a signature. Think universal algebra, F-algebra.
13:40:55 <Cale> right
13:40:56 <fabjan> I just watched the vacuum-cairo videos on youtube and wanted to try it out, but it depends on cairo, gtk and svgcairo and I can't figure out how to install them
13:41:16 * uorygl goes to find out what σ-algebra and Σ-algebra are.
13:41:24 <Cale> fabjan: gtk isn't available on hackage, but you can download it separately
13:41:34 <Cale> gtk2hs
13:41:43 <sproingie> i usually just install gtk2hs through my package manager
13:42:21 <Cale> http://www.haskell.org/gtk2hs/download/
13:42:29 <sproingie> really should be on hackage.  heck ghc should be on hackage
13:42:38 <increpare> heh
13:42:41 <Cale> gtk2hs has a rather complicated build system
13:42:50 * monochrom plans to revive the "destructor" debate. :)
13:42:55 <sproingie> probably not as complicated as ghc's build system :)
13:43:06 <Cale> That is also true
13:43:07 <luite> unfortunately very few haskell programmers seem to care about gui's
13:43:11 <dolio> I suppose it doesn't have to be free. Something could be a non-free Sigma-algebra.
13:43:18 <increpare> luite: that's not exactly true
13:43:41 <increpare> luite: at least I don't think so.  I think it's a chicken/egg thing
13:43:41 <Cale> luite: I sort of care, but nothing exists which is both practical and sufficiently usable ;)
13:43:50 <Nomad010> [CTCP] Received unknown CTCP-TIME request from lambdabot to Channel #haskell.
13:43:51 <Nomad010> nice
13:44:20 <sproingie> @time Nomad010
13:44:21 * increpare observers that there are qt bindings...goes to inspect
13:44:21 <lambdabot> Local time for Nomad010 is Thu Dec 31 23:43:56 2009
13:44:30 <luite> Cale: yes, I guess that's probably a better description of the current situation
13:44:32 <Nomad010> orsm
13:44:42 <sproingie> happy almost-new-year
13:44:43 <luite> the same goes for me
13:44:57 <Nomad010> now i can check my time without looking at the lower right hand corner of the screen :p
13:45:00 <Nomad010> lol
13:45:02 <Nomad010> oh right
13:45:05 <Dashkal> Oh nice.  I didn't realize the entirety of the RWH book was online.  That'll be nice until I can order the dead tree version...
13:45:18 <increpare> qt's callback system should be pretty amenable to haskell
13:45:19 <monochrom> I wager that the two ratios are the same: (haskell programmers providing gui libs)/(haskell programmers) = (programmers providing gui libs)/(programmers)
13:45:19 <Nomad010> new year's day
13:45:27 <Cale> I can't be bothered working out a GUI for something if it requires me to do it the same way as one would do it in an imperative language.
13:45:41 <Cale> Unless of course it's absolutely essential.
13:45:47 <dolio> increpare: The Qt binginds are pretty terrible.
13:45:58 <increpare> dolio: awwww :'(
13:46:15 <dolio> Wow, how did I make that typo?
13:46:24 <Twey> Glade helps
13:46:33 <Cale> Yeah, it does.
13:46:37 <monochrom> So, it is not that haskell people care less about gui --- the ratio is the same --- but that just because we are fewer and therefore ours are more crude.
13:46:46 <increpare> QT creator was one of the most enjoyable things I came across this year ; also the python qt bindings are lovely.
13:47:23 <Cale> monochrom: That, and GUI code just seems painful to write by comparison with most other code.
13:47:28 <increpare> A lot of the UI tools work in haskell has been really experimental
13:47:31 <monochrom> Yeah.
13:47:31 <skorpan> it's ridiculous that they called it PyQt and not QtPy...
13:47:38 <Twey> monochrom: I think it's more that the Haskell people who care about GUI are trying hard to devise a lovely functional paradigm for GUI-coding
13:47:53 <sproingie> skorpan: the current incarnation of Qt bindings has the even dumber name of PySide
13:48:01 <increpare> Cale: really?  Delphi was the first IDE I ever used - it made GUI stuff really really fun.  Also QT is lovely for C++ innit?
13:48:15 <Twey> Insofar as C++ can ever be lovely…
13:48:46 <monochrom> It's also that (haskell programmers giving parser lib)/(haskell programmers) = (programmers giving parser libs)/(programmers) but haskell is such a superior language for parser libs that you only need 5 fingers to make one.
13:48:49 <increpare> Twey: yes, insofar as C++ can be lovely, QT is lovely.
13:49:06 * increpare is a UI coder by profession...
13:49:27 <sinelaw> @hoogle (a->b->b) -> b-> m a -> b
13:49:28 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
13:49:28 <lambdabot> Data.Foldable foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
13:49:28 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
13:49:32 <Cale> I used Delphi as well, but I think by my current standards it doesn't really do the right thing. Mathematica comes closer to providing a sensible way to handle GUI stuff, to the extent that mathematica does anything in a sensible way.
13:49:34 <sproingie> what's nice about Qt in C++ land is it's an entire platform
13:49:38 <Twey> Then you should know that QT is a video codec and player, while Qt is a toolkit.
13:49:42 <Twey> Shame on you!
13:49:47 <Twey> sproingie: Yeah
13:49:47 <Dashkal> I try to avoid UI code.  By profession I did Java/Swing.  I don't think the scars will every heal.
13:49:54 <increpare> Twey: : P
13:50:01 <fabjan> thanks Cale
13:50:01 <increpare> Twey: touche...
13:50:05 <Twey> increpare: It's read ‘cute’.
13:50:12 <sinelaw> Twey, sounds like the sigma-algebra thing again
13:50:14 <monochrom> I actually rather enjoy Swing.
13:50:22 <Twey> Swing isn't so bad
13:50:29 <sproingie> swing's design is all right.  writing actual code for it, dreadful
13:50:30 <increpare> Twey: I KNOW HOW TO SAY IT STOP BEING MEAN.
13:50:32 <Twey> It certainly beats the crap out of MFC
13:50:36 <sproingie> i blame the language tho, not the design
13:50:44 <Cale> I want to be able to declaratively specify how input is tied to output in a way which is composable and not based on callbacks.
13:50:45 <Twey> Yeah
13:50:59 <Twey> increpare: ☺
13:51:03 <Dashkal> Swing isn't terrible, but it taught me some bad habits that I'm still trying to shed.
13:51:12 <sproingie> i really like WPF
13:51:13 <increpare> Cale: I'm not familiar with mathematica's approach; reminds me a bit of conal's approach to GUIs back a while ago
13:51:17 <increpare> Twey: :)
13:51:20 <monochrom> Oh! CHP style may be using for GUI and TV too.
13:51:23 <Dashkal> It'll be much more tolerable if Java 7 lambda support is up to par.
13:51:31 <Cale> It is quite similar to the FRP way of doing things.
13:51:37 * increpare used to have a fondness for swing also...
13:51:42 <sproingie> monochrom: i would love love love to see a gui example for CHP
13:51:47 <Cale> There's a good bit of impurity mixed in, but you can mostly ignore it and things work.
13:51:58 <Twey> Haven't tried WPF
13:52:05 <Twey> Cale: Was that WRT CHP or WPF?
13:52:10 <Twey> Or Swing?
13:52:15 <Heffalump> sproingie: WPF feels like a giant hack to me
13:52:17 <Cale> I'm referring to mathematica's gui stuff.
13:52:21 <Twey> Oh
13:52:21 <monochrom> Well CHP as-is does not have GUI in mind. But you can steal the operators and their laws.
13:52:25 <sproingie> Heffalump: so do all gui libraries to me
13:52:26 <Twey> D, none of the above :þ
13:52:48 <sproingie> WPF lets you attach shaders to individual widgets.  if that sort of thing turns your crank.
13:52:54 <Twey> Yikes.
13:53:04 <increpare> sproingie: mmm : )
13:53:10 <Cale> I think Haskell makes us all very picky about library design, to the extent that most GUI libraries start to seem intolerable :)
13:53:25 <Twey> I suspect so.
13:53:41 <dpratt71> another vote for WPF; like FP, it seems pretty declarative, composable
13:53:43 <sproingie> what i like about WPF is it lets you go truly crazy with composition
13:54:01 <skorpan> i hear curses is in
13:54:11 <Cale> sproingie: So, it's not based on event handlers?
13:54:11 <sproingie> 'course when i tried it the result was glacially slow, but the model was nice anyway
13:54:25 <sproingie> Cale: composition of visual elements.  it's still event-based
13:54:36 <Cale> ah, okay
13:55:07 <p_l> sproingie: yes, but iirc you can define some crazy routing for events...
13:55:39 * increpare thinksit's bad to blame a whole area of programming for being messy just because nobody's figured out a sexy way of doing it in Haskell yet (while at the same time acknowledging that they have legitimate concerns).
13:55:47 <dpratt71> the WPF command-binding stuff obviates a lot of the event-handling code
13:55:51 <increpare> (a way of doing it sexily)
13:56:10 <dpratt71> (perhaps a non-sequitor)
13:56:25 <Cale> The trouble with callbacks is that they're not really functions in any sensible fashion, so they don't compose with each other, and are forced to obscure what it is that they affect by using mutation to change things.
13:56:26 * hackagebot upload: data-clist 0.0.3 - Simple functional ring type. (JohnVanEnk)
13:56:43 <fabjan> I like the cocoa way, no writing or reading scary GUI code.
13:57:05 <increpare> I know one guy who recently migrated to javascript for gui stuff; he's totally in love with it now.
13:57:10 <increpare> (migrated from cocoa)
13:57:16 <sinelaw> @hoogle (\f z x y -> (f z x) && (f z y))
13:57:16 <lambdabot> Parse error:
13:57:17 <lambdabot>   --count=20 "(\f z x y -> (f z x) && (f z y))"
13:57:17 <lambdabot>                ^
13:57:21 <sinelaw> @pl (\f z x y -> (f z x) && (f z y))
13:57:22 <lambdabot> ap =<< ((flip . (((.) . (&&)) .)) .)
13:57:36 <sinelaw> @type (\f z x y -> (f z x) && (f z y))
13:57:38 <lambdabot> forall t t1. (t -> t1 -> Bool) -> t -> t1 -> t1 -> Bool
13:57:47 <sinelaw> @hoogle (t -> t1 -> Bool) -> t -> t1 -> t1 -> Bool
13:57:48 <lambdabot> Data.IntMap insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
13:58:02 <sproingie> yeah i noticed WPF's event model was pretty interesting but i never figured it out
13:58:03 <Cale> > join (liftM2 (&&)) (f z) x y
13:58:04 <lambdabot>   Couldn't match expected type `t1 -> t'
13:58:04 <conal> a funny thing about GUIs is that the popular methods are pretty lousy.  there's often a very simple functional spec, which is inverted in imperative formulations.
13:58:04 <lambdabot>         against inferred type `GHC.B...
13:58:05 <Cale> er
13:58:07 <increpare> Cale: Yeah I can see the problems there.
13:58:14 <Cale> :t \f z x y -> join (liftM2 (&&)) (f z) x y
13:58:15 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `Bool'
13:58:15 <lambdabot>     In the first argument of `liftM2', namely `(&&)'
13:58:15 <lambdabot>     In the first argument of `join', namely `(liftM2 (&&))'
13:58:16 <sproingie> you could probably convert it to continuous functions somehow
13:58:18 <Cale> hmm
13:58:32 <conal> leading to event handlers and/or multi-threaded imperative code.
13:58:35 <Cale> oh, right
13:58:36 <sinelaw> @pl (\f x y -> (f x) && (f y))
13:58:37 <lambdabot> flip =<< (((.) . (&&)) .)
13:58:43 <conal> when functionally, it's so simple.
13:59:35 <sproingie> i'm thinking of breaking out the gui for my app into a client/server thing and not bothering with doing it in haskell
13:59:40 <Cale> :t \f -> (&&) `on` f
13:59:41 <lambdabot> forall a. (a -> Bool) -> a -> a -> Bool
13:59:46 <increpare> conal: while you're here, the one issue I remember having with your google talks talk was that you said thought that interface designs should emerge more or naturally from their functional specification.  I would probably go more for a "separation of underlying behavior and appearance" line myself (like html/css, say).
13:59:52 <doserj> (&&) `on` f z ?
14:00:03 <Cale> need another layer of onning
14:00:03 <sinelaw> conal, my stuff about random variables yesterday was utter nonsense. random variables are simply functions from events to numbers, nothing more.
14:00:25 <sproingie> not sure what to connect to the gui with, it should be reasonably fast.  maybe shm.
14:00:45 <sproingie> pipe would probably be fast enough tho
14:01:00 <Cale> er, oh
14:01:08 <Cale> doserj: seems right :)
14:01:14 <Cale> :t \f z -> (&&) `on` f z
14:01:15 <lambdabot> forall t a. (t -> a -> Bool) -> t -> a -> a -> Bool
14:01:46 <sinelaw> I just wrote an example of a simple gui implemented only (well, almost...) functionally
14:01:57 <sinelaw> that graph editing thing i've been ranting about
14:01:59 <conal> increpare: yeah.  i know the separation idea is popular.  and it has appeal for me also.  and i'm intrigued with the idea of a unifying generalization of the two normally separated notions of programming interface and user interface design.
14:02:01 <Cale> @pl \f z -> on (&&) (f z)
14:02:02 <lambdabot> (on (&&) .)
14:02:06 <Cale> !!
14:02:09 <doserj> oh
14:02:13 <sproingie> conal: i've got a patch for reactive-glut to make it work with current versions of OpenGL.  still can't make Test compile tho
14:02:18 * doserj meditates
14:02:24 <sinelaw> Cale, wow you hit the jackpot
14:02:27 <sinelaw> !
14:02:29 <conal> sproingie: cool :)
14:02:48 <Twey> :t ((&&) `on`)
14:02:49 <lambdabot> forall a. (a -> Bool) -> a -> a -> Bool
14:02:57 <Twey> Oh
14:02:58 <Twey> Heh
14:03:04 <Twey> :t on (&&)
14:03:06 <lambdabot> forall a. (a -> Bool) -> a -> a -> Bool
14:03:20 <sinelaw> :t on
14:03:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:03:37 <increpare> conal: that's really appealing to me as well.  Admittedly a lot of UI libraries/toolkits/whathaveyous try to do it to various extents.  Anyway, I wouldn't approach it as a unification/generalization but rather as more of a radical refactorisation myself : )
14:03:56 <Cale> conal: Did you ever manage to work out what was happening with the integral equations failing?
14:04:35 <conal> Cale: i don't know.  i hear that unamb works much better with ghc 6.12.1, which i don't have.
14:04:45 <Cale> That's interesting :)
14:04:57 <increpare> Cale: indeed
14:05:01 <sproingie> bah, need a decent diff on this box first
14:05:09 <sproingie> freakin windows
14:05:26 <sinelaw> increpare, you can have the 'model-view' idea by having the view be a function of the model
14:05:38 <maltem> Given   data CList r a = Nil | Cons a ((CList r a) -> r) -> r),   is there something like (++) for CList?
14:06:01 * doserj actually finds (((&&) `on`).) easier to understand...
14:06:06 <sinelaw> increpare, well actually that statement was obvious
14:06:31 <increpare> sinelaw: well types are easier to expose than randomo-member variables in any event
14:06:53 <Cale> maltem: There must be :)
14:07:12 <Cale> It's just a little mindbending trying to work out how to write it :)
14:07:27 <Cale> Maybe if we make good use of the Cont r monad
14:07:30 * hackagebot upload: GPX 0.4.3 - Parse GPX files (TonyMorris)
14:08:04 <Cale> data CList r a = Nil | Cons a (Cont r (CList r a))
14:08:21 <maltem> Ah, I'm lucky - Cale is in here ;)
14:09:09 <sinelaw> increpare, indeed
14:09:27 <maltem> Cale, and then see if using callCC reduces the mind-bending? I'll try that
14:11:20 <Cale> append :: CList r a -> CList r a -> CList r a
14:11:20 <Cale> append Nil ys         = ys
14:11:20 <Cale> append (Cons x xs) ys = Cons x (do xs' <- xs
14:11:20 <Cale>                                    return (append xs' ys))
14:11:30 <sinelaw> transform :: model -> Behavior input -> Behavior model
14:11:31 <sinelaw> view :: model -> Behavior Input -> Behavior Output
14:11:39 <sinelaw> increpare, how about it ^^^
14:12:06 <sinelaw> maybe view should start with model -> Behavior Model -> ...
14:12:08 <Cale> maltem: ^^
14:12:16 <maltem> Cale: wow. That looks so... easy
14:12:31 <increpare> sinelaw: but isn't model just model :: Behaviour Input -> Behaviour Output?
14:12:39 <dolio> flip append ys <$> xs
14:12:49 <conal> i guess one reason the imperative model stinks for GUI programming (including imperative haskell libs) is that GUIs are naturally non-sequential, and another is that they're often continuous.  so sequentiality and discreteness are imposed limitations of the implementation tools.
14:12:51 <Cale> maltem: The bind in the Cont monad paints over a lot of insanity.
14:12:55 <sproingie> *reducing* mind-bending by using callCC?
14:13:01 <Cale> No callCC :)
14:13:14 <Cale> Just (Cont r)'s bind
14:13:17 <sinelaw> increpare, yeah, you're right, but we are modifying the model
14:13:22 <maltem> I'll hoogle (>>=) for Cont and try to figure it out  :)
14:13:27 <sproingie> mouse motion may be continuous.  clicks aren't.
14:13:28 <sinelaw> i'm not completely sure you're right
14:13:30 <Cale> in fact, this is less than bind
14:13:31 <Cale> it's fmap
14:13:33 <conal> sinelaw: do you know the TV/Eros approach to functional/composable MVC?
14:13:52 <sinelaw> conal, I saw those but didn't yet have time to properly inspect them
14:13:58 <sinelaw> so i don't remember much
14:13:58 <conal> sinelaw: it's startlingly simple.
14:14:06 <Cale> append (Cons x xs) ys = Cons x (fmap (\xs' -> append xs' ys) xs)
14:14:19 <conal> sinelaw: i didn't realize the close connection with MVC until a reviewer pointed it out.
14:14:22 <increpare> conal: I don't think continuity is that common
14:14:33 <maltem> sproingie, right, the reduction of mind-bending happened exactly by *not* calling callCC
14:14:36 <increpare> actually I'm not sure what you mean by continuity
14:14:57 <conal> increpare: mouse movement and slider movement are two examples of continuity.  time is another.
14:15:18 <sinelaw> conal, I won't be surprised it's simple. btw, trying to define a typeclass with ZFC set semantics. i'm stuck on powerset (another late night exercise to be regretted)
14:15:20 <maltem> Let's see, fmap f m = Cont $ \c -> runCont m (c . f)
14:15:24 <sproingie> i think most guis respond to menu selections and button clicks, not sliders.
14:15:31 <sproingie> er respond most of the time
14:15:35 <increpare> conal: Yeah ok they're legit : )
14:15:48 <Cale> maltem: You could also just wrap and unwrap the conts
14:15:51 <conal> sinelaw: i refactored MVC into model/view, where one kind of view is controller+view
14:16:05 <maltem> Without newtype un/wrapping, that's fmap f m c = m (c . f)
14:16:08 <conal> sinelaw: the latter is a function view.
14:16:20 <sergdf> contemptible newbie question.. how to convert Int64 to big-endian ByteString?
14:17:23 <conal> sinelaw: examples at http://www.haskell.org/haskellwiki/TV and http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/ (video link)
14:17:58 <maltem> so fmap (\xs' -> append xs' ys) xs  ==~  \c -> xs (c . (\xs' -> append xs' ys)), if I'm not mistaken
14:18:04 * maltem will ponder about that
14:18:08 <sinelaw> conal, cool, that video link is how Peaker introduced me to FRP stuff. i didn't actually watch it yet - but I will
14:18:12 <conal> what i like most about this approach is that usability doesn't interfere with composability.
14:18:33 <conal> while in other systems, usability thwarts composability.
14:18:41 <sinelaw> conal, what i didn't comprehend at the time is why do you force us to present things in a specific way to the user
14:18:50 <increpare> conal: how might that sort of system internally describe the adding and removing of components?  (I'm thinking of audio programs here right now, which have interfaces traditionally very close to what you describe there)
14:18:54 <Cale> sergdf: well... there's always Data.Binary.Put, which defines things like that for WordN's, but it's possible there's something more convenient...
14:18:55 <conal> sinelaw: i don't.
14:20:02 <conal> increpare: if you mean editing of the functionality, as opposed to creating the functionality, i don't have an answer that i'm satisfied with.  i make some remarks at the end of the video.
14:20:31 <increpare> increpare: right, I mean the editing of functionality qua functionality.
14:20:45 <increpare> conal: oops: conal: ok.
14:21:10 <conal> what seems to make the editing question tricky is that previous methods depend on syntactic presentation, while TFP is thoroughly semantic.
14:21:19 <conal> (tangible functional programming)
14:21:46 <conal> it'd be easy to compromise the consistent semantic nature of TFP and then pick a standard solution to editing.
14:21:47 <sinelaw> conal, i have this hypothesis that a self-editing editor is a proof of a library's completeness
14:22:07 <sinelaw> conal, it implies editing the functionality
14:22:53 <increpare> conal: couldn't you model such an editor (or several) within TFP?
14:22:54 <conal> i haven't wanted to cop out with a syntactic solution, because my intuition tells me that there's a wonderful semantic solution waiting to be discovered.
14:23:11 <sinelaw> conal, and i don't mean one that re-compiles itself, rather one that actually edit itself, its own value
14:23:14 <conal> increpare: probably.
14:23:32 <jfoutz> i keep playing with step function behaviors to simulate the sudden appearence and disappearance of components
14:23:40 <conal> sinelaw: sure.
14:23:43 <increpare> sinelaw: what existant libraries would qualify for this status?
14:23:59 <sinelaw> increpare, i don't know
14:24:03 <sinelaw> possibly none
14:24:20 <sinelaw> i'm trying to do this in yampa
14:24:31 <sinelaw> (that's where my graph editor is heading)
14:24:34 <increpare> sinelaw: probably some lispy ones :/
14:24:46 <increpare> sinelaw: you can edit the editor from within the editor?
14:25:11 <conal> sinelaw: i finished reading your project description.  the graphy stuff isn't in there, is it?
14:25:12 <sinelaw> increpare, not quite yet :) in fact you can't really do much besides editing FGL graphs
14:25:24 <Cale> conal: I wonder if there would be a way to take a syntactic solution and do some sort of deforestation on it
14:25:27 <sinelaw> conal, nope, it will be in the progress report (due in a few months)
14:25:41 <Cale> (If I understand what you mean)
14:25:44 <increpare> sinelaw: are you going to develop a flowcharty scripting language that the editor can interpret?
14:25:54 <sinelaw> increpare, not at all
14:25:57 <conal> Cale: probably so, though i'm not concerned about efficiency.
14:26:09 <sinelaw> increpare, well i'm not sure what you mean by 'scripting'
14:26:12 <Cale> conal: I mean in order to obtain what is effectively a semantic solution
14:26:48 <increpare> sinelaw: I mean a graph-based scripting language in which you would rewrite the editor's behaviour.
14:26:51 <conal> Cale: maybe so.  it'd have to avoid breaking the semantic abstraction somehow.
14:27:31 <conal> Cale: i designed the DeepArrow combinators to all be semantic, and therefore live/tangible.
14:27:40 * increpare is guessing that's not what sinelaw meant.
14:28:06 <sinelaw> increpare, any language is graph based
14:28:27 <sinelaw> i mean code is generally describable as a graph
14:28:30 <conal> sinelaw: syntactically?
14:28:38 <sinelaw> conal, yes
14:28:43 <conal> sinelaw: k
14:29:06 <increpare> sinelaw: right, but most are represented as strings.
14:29:12 <sinelaw> conal, and also, i have a hunch that Yampa is a graph semantically
14:29:25 <sinelaw> increpare, that's before they are compiled into an AST
14:29:36 <conal> sinelaw: having worked in graphics, i'm wary of APIs that let graphness leak into the (implicit) semantic model.
14:30:00 <sinelaw> conal, actually an incorrect hunch. an SF is a graph, but it has input and outputs. so it isn't.
14:30:01 <increpare> increpare: right.  anyway.  What do you mean when you said you were trying to do what you said you were trying to do with this graph editor anyway?
14:30:08 <increpare> damn: sinelaw:
14:30:13 <sinelaw> heh
14:30:17 <conal> sinelaw: yeah.  i saw in your project outline that you think Yampa is graphy.  it's on my list of things to discuss when you're ready.
14:31:31 <sinelaw> conal, we could discuss it now, but you know what my localtime was last night :) I'l; be going in a few minutes
14:31:54 <sinelaw> increpare, parse error on your last question
14:32:20 <sinelaw> conal, but i'll be glad to next week
14:32:22 <conal> sinelaw: i like to discuss without rush, when there's time to really take things in.
14:32:23 <increpare> sinelaw: What cool stuff are you going to do with the graph editor?
14:32:48 <sinelaw> conal, that's exactly why i'm delaying it :)
14:33:03 <conal> sinelaw: cool :)
14:33:12 <sinelaw> increpare, first stage: just a cool visual graph editor
14:33:21 <increpare> sinelaw: right.
14:33:29 <sinelaw> increpare, auto layout using dot
14:33:38 <sinelaw> allowing users to manually edit visual some attributes
14:33:59 <increpare> sinelaw: layout using dot?
14:34:05 <sinelaw> increpare, i don't remember if i showed this to you: http://www.youtube.com/watch?v=RT87JfTYIvo
14:34:06 <increpare> sinelaw: you mean to label things?
14:34:11 <increpare> sinelaw: you did not
14:34:14 <sinelaw> that's my old python prototype
14:34:54 <sinelaw> increpare, yes label things, change colors, shapes, set pinned positions, etc.. and of course also edit the values associated with nodes/edges
14:35:25 <increpare> sinelaw: there's something about the shape/shading of those ellipses that really disgusts me at some aeshtetic level.  Other than that: it looks fun.
14:35:38 <increpare> sinelaw: Okay.  So - stage after that?
14:35:49 <sinelaw> increpare, heh. don't worry, that program is extinct.
14:36:13 <sinelaw> increpare, make the program be able to represent, and then - edit, it's own graph
14:36:35 <increpare> sinelaw: so the program is going to be interpreted so?
14:36:44 <increpare> or you'll construct the yampa-stuff at run-time?
14:36:49 <sinelaw> increpare, exactly
14:37:03 <sinelaw> i'll transform yampa SF's at runtime
14:37:15 <increpare> sinelaw: sounds fun : )
14:37:18 <sinelaw> dunno how to do it yet, but didn't try either
14:37:44 <sinelaw> increpare, then there is stage 3
14:37:55 <increpare> sinelaw: wasn't that stage three?
14:38:11 <sinelaw> ah, so what were the first two?
14:38:35 <Nomad010> hmm new year
14:38:37 <Nomad010> lol
14:38:47 <sinelaw> increpare, this is what i've come up with so far, btw http://www.ee.bgu.ac.il/~noamle/graphui/design.html
14:38:49 <increpare> " first stage: just a cool visual graph editor" / " make the program be able to represent, and then - edit, it's own graph"
14:39:00 <sinelaw> oh
14:39:07 <sinelaw> yeah, ok, so stage 4 now
14:39:11 <increpare> :P
14:39:14 <sinelaw> ;)
14:39:33 <increpare> so stage four
14:39:39 <sinelaw> Nomad010, welcome to the year of Haskel 2010
14:39:42 <sinelaw> Haskell even
14:39:56 <Nomad010> lol
14:40:03 <increpare> sinelaw: wasn't 2009 the year of Haskell 2010?
14:40:13 <sinelaw> increpare, not unless 2009 = 2010
14:40:22 <Nomad010> increpare: it's like fifa
14:40:26 <Nomad010> fifa 2010
14:40:30 <Nomad010> in 2009
14:40:33 <Nomad010> why
14:40:39 <Nomad010> => fail
14:41:09 <increpare> sinelaw: I don't see the need for the 'infinitesimal delay' node in the design
14:41:13 <sinelaw> increpare, stage 4: join this editor with another one, which edits functional code
14:41:28 <skorpan> Nomad010: i think that's because most countries have their seasons start in 2009 and end in 2010
14:41:31 <sinelaw> increpare, well, it's the semantics of yampa
14:41:39 <Nomad010> skorpan: probably
14:41:55 <increpare> sinelaw: ok.
14:42:00 <ivanm> sinelaw: so the latest version of graphviz is satisfactory for you?
14:42:18 <increpare> sinelaw: so you can attach functional code to the different arrows/whathaveyous?
14:42:18 <sinelaw> increpare, how can you have a signal function that uses its own output as input?
14:42:46 <Olathe> fix
14:42:56 <sinelaw> increpare, exactly. except this editor should be "smart" in that you don't edit text directly, something like LiveC which Peaker & I implemented
14:43:03 <sinelaw> ivanm, very much, thanks!
14:43:16 <sinelaw> i was able to do what i needed (so far)
14:43:17 <ivanm> no worries
14:43:29 <ivanm> heh
14:43:55 <sinelaw> increpare, try cabal install lui
14:43:59 <sproingie> i can't quite figure it out, what's the difference between amb and unamb?
14:44:14 <increpare> sinelaw: I ... am on my xp partition at the moment... no haskell here : (
14:44:17 <sproingie> they both seem to return whichever terminates first
14:44:23 <ivanm> ambiguous vs unambiguous? :p
14:44:39 <sinelaw> increpare, so you can try LiveC
14:44:55 <Twey> Is Eros still going anywhere, conal?
14:45:18 <Twey> There was a big stir when the presentation came out, but since then I haven't really heard anything
14:45:30 <sinelaw> increpare, http://enough.googlecode.com/files/livec-2007-11-4.tar.gz
14:45:50 * increpare downloads
14:46:04 <sinelaw> I hope it works
14:46:05 <conal> Twey: yes, Eros/TFP is still going somewhere, though not outwardly.  it's the project most important to me.  i'm circling back to it.  right now via functional gpu programming.
14:46:10 <sinelaw> increpare, you'll need pygame
14:46:22 <sinelaw> and python obviously
14:46:29 <HaskellLove> why does not that stop before 1 000 000? it gives me 1001604 for result http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5671#a5671
14:46:45 <Twey> conal: Nice.  ☺
14:47:04 <voker57> does Data.List.Length evaluate full list?
14:47:14 <mauke> voker57: yes
14:47:21 <voker57> if so, how to find out if list has n entries without evaluating?
14:47:30 <increpare> sinelaw: >_<  I think we're going to have to pause the conv. here now, because I have all this stuff installed on my OSX partition but I can't restart until I've done some stuff here in xpland : (
14:47:31 <kmc> voker57, it evaluates the spine of the list
14:47:41 <sinelaw> increpare, ok
14:47:43 <voker57> right
14:47:45 <kmc> it does not evaluate every element
14:48:01 <mauke> null . drop (n - 1)
14:48:04 <aavogt> HaskellLove: then you want to use takeWhile (<1000000)?
14:49:23 <aavogt> right now you are asking for the sum of primes up to some number where the total is greater than the largest prime (<1000000)
14:49:58 <conal> Twey: the question of semantic editing is probably my biggest puzzle right now.  and there are technical obstacles like lack of a cross-platform GUI lib.  my inclination is to move away from conventional non-semantic-friendly 2D GUI libs.
14:50:41 <conal> i.e., imperative/IO-based GUI libs. and something more like what antony courtney & i were after with Fruit.
14:50:51 <conal> what i called "genuinely functional GUIs".
14:51:14 <ColonelJ> > 5 ^ 2
14:51:15 <lambdabot>   25
14:51:16 <conal> by which i meant denotationally precise & simple.
14:51:55 <dibblego> @hoogle (Fractional a, Integral i) => a -> (i, a)
14:51:55 <lambdabot> Prelude properFraction :: (RealFrac a, Integral b) => a -> (b, a)
14:51:55 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
14:51:55 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
14:52:05 <voker57> works, thanks. was thinking about something like that
14:52:29 <Twey> conal: I had imagined that semantic editing was effectively solved now.  What's left to do on the problem after your SEC work?
14:53:41 <Twey> Heh, ‘We recommend ghc (5.02.2 or later)’
14:54:08 <tensorpudding> lolol
14:55:03 <conal> Twey: ah yes.  i see the ambiguity about "editing".  SECs (deep arrows) give a semantic basis for editing meaning, UI, types, code, etc (and all combinations, simultaneously).  my puzzle is how to help the user when s/he wants to revisit an earlier choice in the creative process.
14:55:39 <Twey> Ah!  I see.
14:55:40 <conal> Twey: a choice in *construction* rather than meaning/value.
14:55:51 <Twey> (sort of… heh)
14:56:09 <conal> the syntax/semantics divide gives a familiar partial answer.
14:56:20 <sinelaw> conal, Peaker and I were thinking about that question from the point of view of a version control of user actions
14:56:38 <conal> but pure TFP is all semantic.
14:56:55 <conal> sinelaw: nice.
14:57:07 <sinelaw> every value in the program is constructed by applying actions over previous values. so you can have a history - version tree - of actions
14:57:32 <sinelaw> the history both allows to revisit the past / undo, and it also describes the values at every step
14:57:40 <sinelaw> so it IS those values
14:57:59 <conal> sinelaw: yep.  that's the construction-recipe approach.
14:58:20 <conal> sinelaw: i talked with peaker long ago, and there was someone with him.  was it you?
14:58:35 <sproingie> huh, True `pand` undefined throws "*** Exception: BothBottom"
14:58:41 <sproingie> clearly tho only one is bottom
14:58:47 <sinelaw> conal, some very old stuff about that: http://code.google.com/p/enough/wiki/PackageLibrary
14:59:05 <Twey> Eesh
14:59:08 <sinelaw> conal, possibly, and possibly not.
14:59:10 <conal> sinelaw: i describe a similar (i think) idea in the Q&A part of that google tech talk.  i describe it in terms of a movie metaphor.
14:59:15 <Twey> Things that check for bottom give me the creeps
14:59:34 <sproingie> it's obviously only catching exceptions
14:59:47 <sinelaw> conal, most relevant part in that link being "Layer 2: revision control"
15:00:09 <sinelaw> keep in mind this was before we discovered FP
15:00:14 <sinelaw> (and haskell)
15:00:23 <sproingie> sum [1..] `unamb` sum [1..] still hangs forever
15:00:46 <conal> sproingie: those results are about what i'd expect.
15:00:59 <conal> sproingie: have you looked at the def of pand?
15:01:03 <sproingie> get cracking on that halting problem :)
15:01:20 <conal> sproingie: i doubt the "both" referred to there are the args to pand
15:01:52 <conal> Twey: i'm glad bottom-checking gives you the creeps.
15:02:42 <conal> Twey: one has to be careful to stay within semantic monotonicity.
15:03:41 <SamB_XP_> the usage in Lazy Smallcheck seems reasonable enough ...
15:03:48 <SamB_XP_> or do I mean Chasing Bottoms?
15:04:00 <sinelaw> conal, we got stuck when thinking about local vs. global versioning
15:04:49 <conal> sinelaw: i got stuck thinking about replaying later actions after changing one.
15:05:16 <sinelaw> conal, like merge (or rebase) in version control?
15:06:04 <sinelaw> conal, one problem with that being that some later actions may become invalid?
15:06:04 <conal> sinelaw: i don't know.  maybe.  even the types can change, since semantic edits don't preserve type.
15:06:23 <conal> yes.  ill-typed
15:06:26 <sinelaw> yeah, that's a good example
15:06:44 <sinelaw> even if not ill-typed, they can be rendered meaningless
15:06:45 <HaskellLove> why do i get error empty list bla bla... find (\x->isPrime(last x)) (tails $ takeWhile (<30) $ scanl (+) 0 [1..10])
15:07:07 <sinelaw> i mean, they can become useless
15:07:19 <sproingie> > tails $ takewhile (<30) $ [50..60]
15:07:20 <lambdabot>   Not in scope: `takewhile'
15:07:21 <sinelaw> (like mapping on empty lists, etc.)
15:07:24 <sproingie> > tails $ takeWhile (<30) $ [50..60]
15:07:25 <lambdabot>   [[]]
15:07:30 <sproingie> huh
15:07:34 <sinelaw> actually that's not so bad. ill-typed is the problem
15:08:12 <sproingie> ah it's last
15:08:48 <mercury^> Yes.
15:08:51 <dibblego> > (-610) `divMod` 60 -- how do I get (-10,10) ?
15:08:52 <sproingie> you could filter with a comprehension
15:08:53 <lambdabot>   (-11,50)
15:09:30 <mercury^> > (-610) `quotRem` 60
15:09:31 <lambdabot>   (-10,-10)
15:09:37 <sinelaw> @tell increpare I uploaded a liveC demo video, http://enough.googlecode.com/files/livec.ogv
15:09:38 <dibblego> ah cheers
15:09:38 <lambdabot> Consider it noted.
15:10:02 <sinelaw> conal, I supposed you've seen that program
15:10:36 <conal> sinelaw: i don't know.  will download when i'm in civilization next.  thx.
15:11:15 <sinelaw> the idea was to edit the language's AST 'in memory' instead of compiling it from text
15:11:29 <sinelaw> but to display it as it would be expressed as text
15:13:05 <augur> erf
15:13:30 <augur> im having trouble remembering the name of an experimental intermediary language for haskell that some guys were working on
15:16:57 <Lycurgus> intermediary like miranda?
15:17:13 <Lycurgus> or intermediary like llvm?
15:17:15 <sinelaw> augur, it's on GRIN?
15:17:22 <sinelaw> s/on//
15:17:42 <augur> nevermind i found it :)
15:17:43 <augur> http://vimeo.com/6688091
15:17:50 <augur> the types as calling conventions video
15:19:37 <conal> sinelaw: you have construction-recipe + syntax (AST) + semantics (value/visible/executable) ?
15:20:27 <sinelaw> conal, you mean that livec thing?
15:20:54 <mercury^> Where has Saizan gone?
15:20:56 <conal> sinelaw: yeah.  sry.  "you have" == my assumption that you were involved in creating.  were you?
15:21:08 <sinelaw> yes
15:21:58 <sinelaw> we did it in a few days. but it was before we were aware of the (lack of) semantic definitions
15:22:07 <sinelaw> or even of what 'semantic' means
15:22:47 <sergdf> is it generally considered hackish to use {-# SOURCE #-} and .hs-boot files? do people generally write Haskell programs without circular module dependencies?
15:23:12 <Cale> sergdf: Usually we avoid it, yeah.
15:23:17 <sinelaw> but we had a vision of what we were trying to implement, and that vision was the construction-recipe (history/versioning) , the AST (we picked subset of C as an example), and the python code that implemented it
15:23:36 <sergdf> cale: thanks
15:24:16 <Cale> sergdf: It's rather unfortunate though, since the language spec says that it should be supported.
15:25:26 <sinelaw> conal, then, we realized that by all the operations we were implementing on the actions (accumulating changes) and the "model" that they modify, we were really implementing a functional programming language
15:25:42 <sinelaw> so we stopped, and peaker started learning haskell
15:25:50 * Cale is constantly annoyed by nubBy being broken.
15:25:55 <sinelaw> that was 2-3 years ago I think
15:26:00 <sinelaw> 2 probably
15:26:56 <ivanm> Cale: I know how groupBy is broken; how is nubBy broken?
15:27:46 <conal> sinelaw: cool.  familiar evolution of a project.  i saw the same thing happen over & over at Microsoft & Sun, but folks didn't make the leap to replace their 3D or multimedia libs or res-independent image editors or non-linear video editors with a well-designed, semantically precise, typed lambda calculus.
15:27:55 <sinelaw> Cale, is the axiom of choice in ZFC constructible from the first 8 for finite sets?
15:28:10 <conal> sinelaw: that realization led me to Pan and then Eros.
15:28:25 <Cale> ivanm: parameters flipped
15:28:36 <ivanm> @type nubBy
15:28:37 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
15:28:42 <sinelaw> conal, in a way, it's good that we went through the process naively, once
15:28:48 <ivanm> Cale: as in the parameters to the predicate function?
15:28:49 <Cale> The parameters to the (a -> a -> Bool) function are backward
15:28:50 <Cale> yeah
15:28:59 <sinelaw> without knowing about all the stuff that's out there (and the stuff you already did)
15:29:03 <ivanm> what does it currently do? new -> old -> Bool ?
15:29:05 <ivanm> @src nubBy
15:29:05 <lambdabot> nubBy eq []             =  []
15:29:05 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:29:06 <Cale> So the later elements of the list get put into the first parameter of the function
15:29:10 <Cale> which is backward
15:29:15 <Cale> (compared to the spec)
15:29:25 <Cale> That @src is the correct nubBy
15:29:29 <ivanm> Cale: so this is a GHC problem rather than a spec problem?
15:29:31 <ivanm> @slap GHC
15:29:31 <Cale> yes
15:29:31 <lambdabot> stop telling me what to do
15:29:33 <conal> sinelaw: i noticed that end-user media authoring is very like functional programming (though superficially very unlike).  and very unlike imperative programming.
15:29:38 <ivanm> any particular reason they do that? :s
15:29:47 <Cale> There can't be a *good* reason
15:30:05 <Cale> They screwed it up while making it more efficient and only tested it on symmetric relations apparently.
15:30:30 <sinelaw> conal, audio editing has been expressed as data flowing through a function graph, for a very long time
15:30:32 <ivanm> :(
15:30:38 <sinelaw> conal, especially synthesis
15:30:42 <Cale> Of course, the Report foolishly says that's okay
15:30:44 <ivanm> Cale: and they don't fix it because everyone expects it to stay the way it is?
15:30:49 <conal> sinelaw: yep.  in a sadly ad hoc way.
15:30:53 <sinelaw> right
15:31:09 <Heffalump> Cale: what other spec is there?
15:31:13 <Heffalump> (than the report)
15:31:14 <sinelaw> conal, btw I think there's a huge market for a properly designed video editor
15:31:34 <Cale> nubBy *should* be specified such that it produces the subsequence of the input list such that
15:31:36 <sinelaw> conal, for the moderately involved home user and up
15:31:37 <conal> sinelaw: let's do it.
15:31:44 <sinelaw> conal, i'm in
15:31:52 <conal> sinelaw: sweet
15:31:56 <Cale> 1) f x y is False for each x occurring before y in the resulting list
15:32:27 <Cale> 2) The sequence of indices of selected elements is lexicographically minimal
15:32:29 <conal> sinelaw: i have a principle i call "the curse of the special".  treating audio or imagery or 3d or ... as special in the end means treating it badly, and treating all other types even worse.
15:32:34 <sinelaw> conal, my brother and I made a video for my dad's birthday last year using Adobe Premier Pro which is supposed to be good (by Adobe's name in that area), but it was sooooo horrible!! i couldn't believe it
15:32:56 <sinelaw> conal, exactly!
15:33:02 <Heffalump> Cale: why?
15:33:06 <Cale> 3) No additional elements from the input list could be added to the sequence while maintaining these.
15:33:21 <Cale> Heffalump: Because it's a useful and common pattern of sieving
15:33:36 <Cale> Heffalump: Let's say I want a list of peaks of some list
15:33:48 <conal> sinelaw: eep.  it's been a plan in my mind for a while to make an end-user authoring tool for graphics, imagery, video, etc, that's much more powerful & optimizable than the "special" tools.
15:34:20 <sinelaw> conal, intentions converging :)
15:34:24 <conal> sinelaw: for one thing, the artifacts authored would be interactive, parametric, compact, and resolution-independent.
15:34:42 <conal> sinelaw: oh, and gpu-accelerated.
15:34:51 <sinelaw> that last bit is important, by the way
15:34:58 <sinelaw> after my experience...
15:35:01 <conal> or whatever thousand-core-accelerated or whatever.
15:35:20 <conal> strike that first " whatever"
15:35:34 <Cale> Then nubBy (>) is exactly what I want.
15:36:13 <Cale> (Supposing that I want to report progress on finding the maximum element of some list)
15:36:57 <Cale> (Or perhaps (>=))
15:37:20 <Cale> But now nubBy's parameters have been flipped, so all my programs which make use of that need to be fixed.
15:37:36 <Cale> and I have to remember that the function is applied backwards
15:37:52 <Cale> Not to the elements of the list in the order that they occur in the list as you'd expect
15:38:12 <Cale> Heffalump: Does that make sense?
15:38:18 <ivanm> conal: and when will this mystical piece of software first see the light of day? ;-)
15:38:47 <Cale> I don't want to have to write nubBy myself every time I want to do something of that sort.
15:39:08 <conal> ivanm: you'll know soon after i know.  i can never predict these things.
15:39:19 <ivanm> heh
15:41:34 <wagle> (sorry if only the same people are here):  whats the state-of-the-art these days for modular interpreters and/or (probably implementations of) modular denotational semantics?
15:42:56 <Cale> Heffalump: Of course, there's also the nice primes example of sieving by divisibility. That one is not efficient, but there are a lot of things of that sort where this pattern is the most sensible thing you can do.
15:48:44 <Heffalump> Cale: my instinctive feeling is that a function that's a generalisation of one based on an equivalence relation shouldn't be over-specified
15:48:55 <Heffalump> and that you should have some other name for the spec you want
16:00:01 <Cale> Heffalump: This of course still reduces to nub when you supply it with an equivalence relation
16:00:15 <Cale> Heffalump: It's a perfectly sensible function without the equivalence relation though.
16:00:27 <Cale> I don't see why people think that it ought to be underspecified.
16:01:16 <Heffalump> permitting implementation freedom is the usual answer
16:01:18 <Cale> I think nubBy is a perfectly suitable name for what this function does.
16:01:50 <j4cbo> "reduces to nub" :P
16:02:08 <Heffalump> I don't really find your spec intuitive
16:02:17 <Codex_> hmm, I have a question about CT. If you have a bijection, what are the stuff you can do with that information?
16:02:20 <Heffalump> why should we only get f x y = False for x occurring before y?
16:03:21 <pham> I just discovered the order of constructors in a union type effects semantics in ambiguous derivations such as Ord. Is this in the Haskell 98 spec, or should I not be relying on this behavior?
16:03:49 <Heffalump> I think it's in the spec
16:04:03 <Cale> It is in the spec
16:04:21 <pham> Heffalump, Cale: cool, I won't worry about it then. You saved me the effort of digging through the spec ;)
16:04:46 <Cale> The derived order is lexicographic: first testing the order of the constructors, and then for equal constructors comparing fields in the order in which they occur
16:05:04 <pham> turns out the first constructors are less than when deriving Ord, not greater than like I'd expect
16:05:19 <Cale> Well, it's the order that they occur across the page.
16:05:44 <Cale> Normally we write numbers in order like 1,2,3,4,5, not 5,4,3,2,1 ;)
16:05:58 <pham> heh
16:06:00 <mauke> a b c d
16:06:49 <Cale> Heffalump: basically, because that's the natural generalisation to asymmetric relations
16:07:25 <Heffalump> what's natural about it? Why not for x occurring after y?
16:07:29 <Cale> Heffalump: and if you want both when your relation is asymmetric, it's easy to write (\x y -> f x y || f y x)
16:08:30 <Cale> I think the general principle should be that any higher order function should produce an expression graph where the elements of the list stay as close to the order in which they occurred in the list.
16:08:45 <Cale> For example, foldr and foldl follow this principle.
16:09:03 <Cale> mapAccumL does, but mapAccumR doesn't, which is another pet peeve of mine.
16:10:04 <Cale> This means that whenever you're applying a function parameter to multiple elements of the list, that function should receive the elements in the order in which they occurred in the list.
16:10:50 <Cale> Or if it gets an element of the list and something constructed from later (resp. earlier) elements of the list, the single element should come first (resp. second)
16:11:39 <chrisdone> happy new year from england
16:12:20 <Cale> Of course, higher-order functions are imaginable where this policy is hard to apply, but it's usually simple, and would make it easy to remember which way around things go.
16:12:44 <MyCatVerbs> Happy new year from Wales, chris. :)
16:13:15 <mercury^> nubBy does it wrong, doesn't it?
16:13:16 <pham> It's already Jan 1st over there, isn't it?
16:13:43 <Heffalump> only just
16:13:46 <chrisdone> MyCatVerbs: =)
16:13:50 <pham> I feel behind the times... still in 2009
16:13:56 <pham> hey that rhyms
16:13:57 <Cale> mercury^: Now it does.
16:14:05 <Cale> mercury^: The code in the Haskell98 spec does it right.
16:14:08 <mercury^> > nubBy (<) [2..]
16:14:09 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
16:14:11 <mauke> GREETINGS FROM THE FUTURE
16:14:15 * Heffalump spent the day getting further and further away from Wales
16:14:21 <mercury^> Cale: that's why I tripped when I did the primes!
16:14:21 <MyCatVerbs> pham: indeedely-do it is.
16:14:25 <Cale> But GHC doesn't do it the same way
16:14:27 <Cale> mercury^: yes
16:14:32 <Ke> http://upload.wikimedia.org/wikipedia/commons/e/e7/Timezones2008.png
16:14:34 <MyCatVerbs> Sensible lad, Heffalump.
16:14:37 <chrisdone> "hello" is spelled "helo" now!
16:14:53 <Cale> mercury^: I absolutely hate that it's been switched, because I rarely use nubBy with equivalence relations.
16:15:08 <mercury^> What's the reasoning?
16:15:10 <MyCatVerbs> chrisdone: it's been "EHLO" for more than a decade now.
16:15:11 <Ke> seems to be 2010 in whole of eurasia and africa
16:15:18 <Cale> mercury^: It's just a mistake
16:15:47 <Cale> I mean, after nubBy (>=), probably my next most common usage is with things that are also not equivalence relations, like  nubBy ((==) `on` snd)
16:16:09 <Cale> er
16:16:16 <Cale> No, sorry, that one is :)
16:16:24 <MyCatVerbs> Pretty sure that one is, heh. :)
16:16:26 <Cale> yes
16:16:29 <mercury^> :)
16:18:50 <Cale> So, it sees some usage either way, but I think the ordering relation case is really important.
16:19:08 <mercury^> Yes.
16:19:10 <Cale> It's handy as a sort of approximation of maximum or minimum
16:19:21 <Cale> When you want to produce things more lazily.
16:19:44 <Cale> and of course there's the divisibility relation example
16:20:38 <skorpan> maybe i should enter the new year with a working xmobar
16:25:16 * hackagebot upload: xsd 0.3.1 - XML Schema data structures (TonyMorris)
16:26:54 <sergdf> what's the best way to get a lazy bytestring from a string? (I can't find a way within the bytestring library, but i could be missing something)
16:27:48 <mauke> pack
16:28:01 <sergdf> when i do that, i get type errors because Char != Word8
16:28:23 <mauke> import Data.ByteString.Lazy.Char8
16:28:35 <sergdf> aha, thank you
16:28:54 <holmak> @hoogle String -> ByteString
16:28:54 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
16:28:54 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
16:28:54 <lambdabot> Prelude read :: Read a => String -> a
16:29:01 <mercury^> Can one instantiate the (true) identity endofunctor as such in some language (maybe agda or Epigram)?
16:36:20 <Cale> sergdf: That doesn't work if your string may contain higher unicode characters
16:37:10 <sergdf> cale: i suppose i would use Data.ByteString.Lazy.UTF8 for that?
16:37:19 <mercury^> sergdf: if it does work, map w2c over the string.
16:37:54 <Cale> sergdf: For those purposes, there are various libraries such as Data.Text (see the text package on Hackage), as well as UTF8-light
16:38:19 <Cale> Codec.Binary.UTF8.Light in utf8-light has class UTF8 a where encode :: a -> ByteString; decode :: ByteString -> a
16:38:34 <sergdf> ok. i don't need that yet, but i'll keep it in mind
16:38:45 <Cale> With instances for String, ByteString, and a bunch of other list types.
16:39:10 <sergdf> sounds pretty useful
16:40:00 <mercury^> Also: is there any useful replacement prelude yet?
16:41:00 <Cale> mercury^: If you're interested, perhaps join #alt-stdlib, but there hasn't been much discussion lately.
16:41:20 <Cale> There really isn't much done.
16:41:45 <mercury^> The new standard did not remove the implicit prelude, did it?
16:41:52 <Cale> One of the major demotivating factors is that even if you write it, it'll be a pain to use.
16:42:04 <Cale> Because nothing will be compatible with it.
16:43:08 <Cale> I think the right way is really just to push things into base and use version numbers to try to keep things straight, correcting the packages on hackage to work with newer versions as we go.
16:45:01 <mercury^> I fully agree.
16:47:06 <Cale> But the commercial users might be upset with that (?)
16:48:03 <Cale> But hopefully if things are versioned, we can have multiple versions of base get installed by default -- ones corresponding to published standards, and a new one which is in flux.
16:48:20 <Cale> I don't have much political power in this regard though.
16:51:13 <Cale> One thing which I think we definitely should *not* try to do is standardise changes before making them in base.
16:51:59 <mercury^> Apart from missing an opportunity to change late, why is that bad?
16:53:40 <Cale> Well, it means that we have to specify things before we've actually had a chance to try them.
16:54:38 <Cale> If there's a mistake in the standard, we end up stuck with supporting that mistake. If there's a mistake in the unstandardised-as-yet libraries, we just fix it.
16:55:55 <tensorpudding> fixing mistakes before they become standard is what i'd call a good idea
17:01:48 <ColonelJ> happy new year #haskell
17:05:20 <sioraiocht> what is the greek letter commonly used to denote the function of a final coalgebra?
17:05:27 <sioraiocht> (it's alpha for initial algebras)
17:05:52 <kmc> omega? ;)
17:06:09 <dolio> Alpha is used for initial algebras?
17:06:12 <sioraiocht> yeah
17:06:23 <dolio> By whom?
17:06:24 <sioraiocht> in or alpha are common names
17:06:41 <sioraiocht> everyone?
17:06:52 <dolio> Seems like I would have seen that before.
17:06:54 * sioraiocht is not a bibtex file
17:06:55 <sioraiocht> =p
17:07:03 <sioraiocht> I think gamma is common
17:07:15 <sioraiocht> oh well, supervisor will let me know if i'm wrong
17:10:19 <monochrom> Bart Jacobs and Jan Rutten's "A Tutorial on (Co)Algebras and (Co)Induction" uses "c" for generic co-algebra. http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf
17:10:56 <dolio> Oh, so it does.
17:11:07 <Nomad010> comathematicians are devices for turning ffee into cotheorems
17:11:31 <dolio> cotheorems into ffee.
17:11:44 <j4cbo> yeah, i think cotheorems into ffee
17:11:46 <Nomad010> fail
17:11:50 <Nomad010> forgot to swap
17:11:52 <Nomad010> lol
17:11:54 <dolio> LERN 2 CATEGORY!
17:12:01 <Nomad010> nevar
17:12:22 <ray> learn some category theory noob
17:12:33 * Nomad010 hides in shame
17:12:55 <SamB_XP_> so comathematicians are the ... converse ??? ... of mathematicians ?
17:13:36 <dolio> Categorical dual.
17:13:38 <Nomad010> co is like the dual
17:14:14 <Codex_> C^op x C -> Set.
17:14:23 <Nomad010> " A statement that easily leads to the proof of a cotheorem is called a 'rollary' "
17:14:24 <jlouis> Bifunctors!
17:14:31 <ray> co- is always dual, but exactly what duality is varies depending on what you're doing
17:14:33 <jlouis> Happy new year #haskell btw
17:14:48 <Nomad010> it's pi here
17:14:52 <mreh> \0/
17:14:56 <SamB_XP_> I know what co means
17:15:11 <Nomad010> gmote
17:15:14 <mreh> jlouis, are you in france/scandanavia?
17:15:31 <jlouis> mreh: scandinavia
17:15:43 <Nomad010> apparently the fireworks in paris were amazing
17:16:04 <SamB_XP_> I'm assuming that ffee = \not coffee and that cotheorems = \not theorems
17:16:04 <Nomad010> and by that i mean cheerio
17:16:38 <mreh> how can I write a function that takes an infinite list of numbers, and finds the first sublist that adds up exactly to a number
17:17:53 <ray> a comathematician is a contravariant functor from theorems to coffee
17:17:54 <ray> maybe
17:18:36 <mreh> what does that make a physicist?
17:18:53 <ray> trivial
17:19:07 <SamB_XP_> an applied mathemetician ?
17:19:09 <SamB_XP_> no, wait.
17:19:16 <kmc> > inits "abcde" -- mreh sublists like this?
17:19:17 <lambdabot>   ["","a","ab","abc","abcd","abcde"]
17:19:22 <SamB_XP_> that would just be theorems
17:19:25 <SamB_XP_> ;-P
17:19:28 <mreh> kmc more like this
17:19:33 <ray> even applied mathematicians can look down on physicists
17:19:35 <mreh> > tails [1..]
17:19:36 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:19:44 <mreh> > take 5 . tails [1..]
17:19:44 <kmc> oh
17:19:45 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
17:19:59 <mreh> kmc, but the size of the take isn't known
17:20:30 <kmc> mreh, hmm
17:21:07 <kmc> that sounds tricky
17:21:14 <dolio> > sublists [1..5]
17:21:15 <lambdabot>   Not in scope: `sublists'
17:21:36 <mreh> I need a function that takes a list and returns the first n elements that sum to x, or [] otherwise
17:21:47 <kmc> > concatMap inits $ tails "abcde"
17:21:47 <dolio> > subsequences [1..5]
17:21:48 <lambdabot>   ["","a","ab","abc","abcd","abcde","","b","bc","bcd","bcde","","c","cd","cde...
17:21:48 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
17:21:54 <kmc> > concatMap inits $ tails [1..]
17:21:55 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
17:22:13 <kmc> > concat . transpose . map inits $ tails [1..]
17:22:14 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
17:22:54 <dolio> > subsequences [1..]
17:22:55 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
17:23:30 <lpsmith> > take 5 . tails [1..]
17:23:32 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
17:23:37 <lpsmith> umm
17:23:47 <araujo> anyone knows a nice git-based (free) project hosting site?
17:23:49 <lpsmith> wat?    ^^^^
17:23:50 <skorpan> > map (take 5) $ tails [1..]
17:23:51 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
17:23:53 <mreh> @src sunsequences
17:23:54 <lambdabot> Source not found. My pet ferret can type better than you!
17:23:58 <dolio> > take 5 . Just [1..]
17:23:59 <mreh> @src subsequences
17:23:59 <lambdabot>   Just [1,2,3,4,5]
17:24:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:24:01 <skorpan> araujo: github
17:24:10 <araujo> skorpan, free?
17:24:14 <skorpan> araujo: it's free
17:24:18 <ivanm> why are you wanting git?
17:24:22 <araujo> skorpan, ok
17:24:27 <araujo> becausegit rocks
17:24:31 <skorpan> git <3
17:24:43 <holmak> git == 2 ?
17:24:50 <tensorpudding> araujo: is gitorious free enough for you?
17:24:54 <ivanm> holmak: no, git can be any value less than 3
17:24:59 <lpsmith> dolio:  ok,  what am I missing here?   I'm confused
17:25:05 <araujo> tensorpudding, let me check
17:25:29 <dolio> lpsmith: (.) = fmap
17:25:36 <lpsmith> ahh
17:25:49 <tensorpudding> github has free hosting too, as well as commercial options
17:25:55 <Veinor> I use github.
17:26:04 <tensorpudding> gitorious is kinda like the identi.ca to github's twitter
17:26:06 <ivanm> lpsmith: Caleskell
17:26:08 <lpsmith> makes sense now,  thanks dolio
17:26:11 <ivanm> @type (Prelude..)
17:26:12 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:26:13 <lpsmith> kik
17:26:15 <lpsmith> lol
17:26:18 <Veinor> I don't know how it compares to gitorious, but I have no issues with github
17:26:36 <Veinor> tensorpudding: ob: except github is actually useful!
17:26:58 * araujo checks both
17:27:45 <mreh> > drop 8 . subsequence [1..]
17:27:46 <lambdabot>   Not in scope: `subsequence'
17:27:49 <mreh> > drop 8 . subsequences [1..]
17:27:50 <tensorpudding> if you have no real preference, github is vastly more popular it seems
17:27:50 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
17:28:23 <ivanm> tensorpudding: seeing as how I don't use twitter and have no idea what identi.ca is, what's the difference? ;-)
17:28:59 <tensorpudding> identi.ca is smaller community, and the hosting software itself is open-source
17:29:27 <tensorpudding> that was the point of my analogy
17:29:29 <mreh> > subsequences [1..]
17:29:30 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
17:29:31 <ivanm> aha
17:29:42 * ivanm sticks with community.haskell.org
17:29:44 <tensorpudding> is that the server software that gitorious runs is itself hosted on gitorious
17:29:46 <mreh> > drop 8 . subsequences [1..]
17:29:47 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
17:29:51 <mreh> ?!
17:29:51 <lambdabot> Maybe you meant: . ? @ v
17:30:07 <ivanm> @type subsequences
17:30:08 <lambdabot> forall a. [a] -> [[a]]
17:30:17 <tensorpudding> identi.ca uses an open source framework, laconica
17:30:19 <stoop> > subsequences [1..]
17:30:20 <mreh> > drop 8 . subsequences $ [1..]
17:30:20 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
17:30:21 <lambdabot>   [[4],[1,4],[2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4],[5],[1,5],[2,5],[1...
17:30:36 <ivanm> is that something some did a @let for?
17:30:43 <tensorpudding> the difference in popularity between twitter and identi.ca is pretty vast though
17:30:48 <dolio> Nope. It's in Data.List.
17:30:57 <mreh> it's perfect for what I want
17:30:57 <ivanm> don't recall ever seeing that one
17:31:10 <dolio> It's relatively new.
17:31:25 <mreh> well, it's not perfect, it's rather wasteful
17:31:35 <tensorpudding> hmm,a ctually, they seem to have changed the name or somesuch
17:31:42 <tensorpudding> statusnet is the new name
17:31:45 <ivanm> dolio: as in 6.12 new?
17:31:58 <dolio> No. 6.10 perhaps.
17:32:32 <ivanm> *nod*
17:32:34 <ivanm> I see it now
17:32:48 <dolio> I think it got added at the same time as permutations.
17:32:49 <augur> since noones really active in ##logic, anyone know of any good finitist type-subtype calculi and mereological calculi?
17:32:53 <tensorpudding> there is a similar analogy between last.fm and the up-and-coming libre.fm
17:33:50 <ivanm> augur: I read that as "meteorological calculi", and thought you wanted weather-prediction math...
17:33:50 <ivanm> ;-)
17:33:58 <augur> :p
17:34:09 <tensorpudding> cloud combinators!
17:34:19 <holmak> Is Language.Haskell.* related to the GHC parser, or is an independent reimplementation?
17:34:34 <holmak> *it it ...?
17:34:47 <holmak> **is it an independent reimplementation?
17:35:14 <mreh> do people send happy new year to their entire phonebook?
17:35:17 <Veinor> ew, finitism
17:35:25 <ivanm> holmak: completely separate
17:35:34 <ivanm> mreh: I don't send a happy new year to _anyone_
17:35:48 <mreh> ivanm: I don't buy into it, what's the point
17:36:12 <ivanm> mreh: of what? you're the one doing extra work!
17:36:25 <holmak> That seems unfortunate. Is the GHC parser not useful to coding in general? Or too closely coupled?
17:36:40 <augur> ill take it that noone has any such references
17:36:40 <augur> :|
17:36:46 <mreh> > tails [1..] -- is a good place to start, but I need to stop evaluating the tail when the sum of the list is larger than "x"
17:36:47 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:36:58 <ivanm> holmak: the GHC parser is fragile, and assumes you are using GHC
17:37:23 <aavogt> > map (take 10) $ tails [1..] -- mreh
17:37:24 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4...
17:37:24 <holmak> That's too bad. Language.Haskell.* seems pretty solid, though.
17:37:39 <ivanm> whereas haskell-src is stable, and haskell-src-exts seems to be stabilising (four major releases of haskell-src-exts and I only had to change one line of code when using it!)
17:37:57 <ivanm> mreh: see takeWhile
17:38:39 <mreh> ivanm: lovely
17:39:00 <aavogt> @type takeWhile((<=x).snd).(zip`ap`(scanl1 (+)))
17:39:01 <lambdabot> [Expr] -> [(Expr, Expr)]
17:39:13 <aavogt> @type takeWhile((<=100).snd).(zip`ap`(scanl1 (+)))
17:39:14 <lambdabot> forall b. (Num b, Ord b) => [b] -> [(b, b)]
17:42:41 <mreh> > do gen <- newStdGen; return $ randomRs (1,10) gen
17:42:43 <lambdabot>   <IO [Integer]>
17:42:53 <mreh> > do gen <- newStdGen; print $ randomRs (1,10) gen
17:42:54 <lambdabot>   <IO ()>
17:43:17 <mreh> > unsafePerformIO $ do gen <- newStdGen; print $ randomRs (1,10) gen
17:43:18 <lambdabot>   Not in scope: `unsafePerformIO'
17:45:05 <ben0x539> > runST
17:45:07 <lambdabot>   No instances for (Test.SmallCheck.Serial (forall s. GHC.ST.ST s a),
17:45:07 <lambdabot>        ...
17:46:38 <aavogt> @help run
17:46:38 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
17:50:52 <mreh> @run do gen <- newStdGen; print $ take 100 . randomRs (1,10) $ gen
17:50:53 <lambdabot>   <IO ()>
17:51:19 <mreh> does she kill any process that runs more than 3 seconds?
17:51:29 <aavogt> > length [1..]
17:51:31 <mreh> > fix (1:)
17:51:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:51:33 <lambdabot>   mueval-core: Time limit exceeded
17:53:06 <mreh> brane hurts
17:54:51 <augur> mreh, branes of what dimension?!
17:54:51 <augur> D:
17:54:55 <augur> 10 dimensional?!
17:55:00 <augur> DAMN YOU M-THEORY
17:56:14 <augur> btw whats the meta-command to get something's type from lambdabot
17:57:47 <augur> oh @type?
17:57:48 <augur> hm
17:57:53 <ivanm> or :type
17:57:57 <ivanm> :type takeWhile
17:58:03 <augur> yeah. nothin.
17:58:03 <ivanm> :t takeWhile
17:58:03 <augur> :|
17:58:04 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:58:06 <ivanm> OK, just :t
17:58:07 <augur> wat
17:58:09 <ivanm> @type takeWhile
17:58:10 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:58:12 <augur> i did that in a pm and it didnt work! :(
17:58:15 <augur> :t fix
17:58:16 <lambdabot> forall a. (a -> a) -> a
17:58:20 <augur> :source fix
17:58:24 <augur> guess not
17:58:26 <augur> @source fix
17:58:27 <lambdabot> fix not available
17:58:29 <augur> :(
17:58:46 <c_wraith> Well, not everything about flying over new year's is bad.  Took me all of one minute to get through security
17:58:47 <doserj> @src fix
17:58:47 <lambdabot> fix f = let x = f x in x
17:58:52 <augur> aga!
17:59:05 <augur> aha even
17:59:09 <augur> interesting
17:59:14 <augur> who needs fix? XD
17:59:22 <troutwine> c_wraith: Which airport?
17:59:28 <c_wraith> PDX
17:59:31 <augur> > fix (1 +)
17:59:32 <ivanm> > map length . group $ fix ""
17:59:33 <lambdabot>   Couldn't match expected type `a -> a'
17:59:33 <lambdabot>         against inferred type `[GHC.T...
17:59:35 <lambdabot>   mueval-core: Time limit exceeded
17:59:39 <troutwine> I love PDX.
17:59:44 <ivanm> > take 10 . map length . group $ fix ""
17:59:45 <lambdabot>   Couldn't match expected type `a -> a'
17:59:46 <lambdabot>         against inferred type `[GHC.T...
17:59:46 <c_wraith> free wireless!
17:59:49 <ivanm> grrr
17:59:52 <ivanm> @type fix ""
17:59:53 <lambdabot>     Couldn't match expected type `a -> a'
17:59:54 <lambdabot>            against inferred type `[Char]'
17:59:54 <lambdabot>     In the first argument of `fix', namely `""'
17:59:55 <ivanm> oh, right
17:59:58 <aavogt> @free fix
17:59:58 <ivanm> > take 10 . map length . group $ fix show
17:59:59 <lambdabot>   [1,1,1,3,1,7,1,15,1,31]
17:59:59 <lambdabot> f . g = h . f => f (fix g) = fix h
18:00:12 <troutwine> c_wraith: And a Powell's branch!
18:00:14 <skorpan> wtf ivanm?
18:00:28 <ivanm> skorpan: wtf what?
18:00:32 <skorpan> what just happened?
18:00:42 <ivanm> > fix show
18:00:43 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:00:49 <c_wraith> troutwine: I'm on the wrong side of security for that.  In fact, I'm on entirely the wrong side of the airport from my departure gate, just because it's the only place with anything going on.
18:01:02 <skorpan> what The FUCK
18:01:10 <augur> thats so confusing
18:01:10 <augur> :D
18:01:10 <troutwine> Good lord.
18:01:13 <ivanm> skorpan: it knows it starts with a ", so show of it becomes "\"... , then it shows that, so "\\\", etc.
18:01:24 <skorpan> ivanm: that's just bizarre
18:01:26 <ivanm> oh, wait, that last one should be "\"\\\"
18:01:29 <ivanm> skorpan: yup
18:01:43 <aavogt> @oeis 1,1,1,3,1,7,1,15,1,31
18:01:43 <kmc> > fix error
18:01:44 <lambdabot>  Expansion of (1+2x)/((1+x)(1-2x^2)).
18:01:44 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
18:01:44 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:01:45 <troutwine> c_wraith: Ah, shame. Still, good times are to be had almost anywhere in PDX.
18:01:50 <ivanm> I can never remember how, but IIRC, dons managed to use that with scanl to get the fibonacci sequence once a few years back to break up a flame fest on -cafe
18:01:57 <ivanm> kmc: heh
18:02:02 <ivanm> yeah, that's a good one as well
18:02:06 <ivanm> skorpan: the power of laziness!
18:02:14 <monochrom> and recursion
18:02:15 <kmc> > fix ((0:) . scanl (+) 1)
18:02:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:02:31 <ivanm> kmc: ahhh, that's the one
18:02:36 <ivanm> I thought he used fix show though...
18:03:41 <aavogt> > map (\x -> (1+2x)/((1+x)(1-2x^2))) [1..]
18:03:43 <lambdabot>   No instance for (GHC.Enum.Enum (a -> t))
18:03:43 <lambdabot>    arising from the arithmetic seq...
18:03:56 <monochrom> What is 2x? :)
18:04:06 <aavogt> > map (\x -> (1+2*x)/((1+x)*(1-2*x^2))) [1..]
18:04:06 <medfly> 2*x
18:04:07 <lambdabot>   [-1.5,-0.23809523809523808,-0.10294117647058823,-5.806451612903226e-2,-3.74...
18:04:28 <ivanm> monochrom: well, 4x can be considered a condensed form of the name of an aussie beer...
18:04:35 <ivanm> so maybe 2x is half a glass of that beer? :p
18:05:00 <aavogt> > iterate deriv (\x -> (1+2*x)/((1+x)*(1-2*x^2)))
18:05:01 <lambdabot>   Occurs check: cannot construct the infinite type:
18:05:01 <lambdabot>    a = Data.Number.Dif.Di...
18:06:01 <monochrom> Oh, beer.
18:06:32 <ivanm> heh
18:07:59 <aavogt> @type deriv
18:08:00 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
18:08:14 <aavogt> > iterate deriv (deriv (\x -> (1+2*x)/((1+x)*(1-2*x^2))))
18:08:15 <lambdabot>   Occurs check: cannot construct the infinite type:
18:08:15 <lambdabot>    a = Data.Number.Dif.Di...
18:12:25 <chrisdone> what's the word on Liskell?
18:13:30 <chrisdone> if GHC supported an -XSExpressions extension, that would be awesome. then you could write code that anyone with GHC could use, rather than limiting it to Liskell-GHC users
18:23:51 <Veinor> deriv?
18:24:21 <drdr> anyone know how hard the darcs protocal is to re emulate?
18:24:58 <Veinor> oh, the backslashes in show is 1, 3, 7, 15
18:25:21 <Veinor> so f_(n+1) = 2f_n + 1
18:26:40 <Veinor> @unpl \f x y -> f y x
18:26:40 <lambdabot> \ f x y -> f y x
18:26:49 <Veinor> why do I always confuse unpl with pl :S
18:26:52 <Veinor> @pl \f x y -> f y x
18:26:52 <lambdabot> flip
18:27:03 <Veinor> @pl \x -> (x :: Int)
18:27:03 <lambdabot> (:: Int)
18:27:11 <shachaf> Hah, that would be nice.
18:27:14 <Veinor> oh huh, that works
18:27:17 <Veinor> ?
18:27:21 <Veinor> > (:: Float) 2
18:27:22 <lambdabot>   <no location info>: parse error on input `::'
18:27:22 <shachaf> Veinor: No, it's not valid Haskell.
18:27:25 <Veinor> :(
18:27:41 <augur> anyone have PNAS access?
18:27:50 <drdr> whats PNAS?
18:27:53 <shachaf> > (`asTypeOf` (undefined :: Float)) 2
18:27:55 <lambdabot>   2.0
18:28:05 <augur> Proceedings of the National Academy of Sciences
18:28:12 <benmachine> @pl doesn't know about a lot of special haskell syntax
18:28:12 <drdr> ah
18:28:12 <lambdabot> doesn't know about a lot of special haskell syntax
18:28:12 <drdr> nope
18:28:20 <augur> anyone? D:
18:28:26 <drdr> what you need?
18:28:32 <drdr> its probally somewere else
18:28:35 <shachaf> @vixen You forgot to use /me.
18:28:36 <lambdabot> Is that a real poncho or is that a Sears poncho?
18:28:49 <augur> drdr: Campbell's monkeys concatenate vocalizations into context-specific call sequences
18:29:03 <drdr> ok then...
18:29:08 <drdr> cant help you therre
18:29:12 <augur> :p
18:29:35 <drdr> try emailing Campbell and explaining to him what your working on?a
18:30:01 <augur> i know how i can get it by emailing people but it'd be nice to just get into a PNAS archive directly
18:30:50 <drdr> then it looks like your gonna need to suscribe
18:30:54 <augur> :P
18:31:03 <Veinor> 2 `asTypeOf` 2.0
18:31:04 <augur> im sure my uni has a subscription i just cant find it
18:31:06 <Veinor> > 2 `asTypeOf` 2.0
18:31:08 <lambdabot>   2.0
18:31:17 <drdr> talk to the libary people
18:31:18 <Veinor> @src asTypeOf
18:31:18 <lambdabot> asTypeOf = const
18:31:24 <Veinor> ...
18:31:26 <Veinor> what?
18:31:35 <Veinor> 2 `const` 2.0
18:31:38 <Veinor> > 2 `const` 2.0
18:31:39 <benmachine> Veinor: asTypeOf has type a -> a -> a
18:31:39 <ben0x539> The interesting part is the type.
18:31:39 <lambdabot>   2
18:31:44 <benmachine> whereas const has type a -> b -> a
18:31:51 <ben0x539> @type asTypeOf
18:31:53 <lambdabot> forall a. a -> a -> a
18:31:55 <Veinor> ahh.
18:33:29 <drdr> anyone know a editer that lets you send your code to ghc for evaluation in the editer
18:36:10 <tensorpudding> drdr: emacs allows you to run a ghci inside the editor, and you can send code to it easily
18:36:21 <drdr> how?
18:37:11 <tensorpudding> M-x run-haskell to start the ghci process, then if you are in the haskell major mode, C-c C-l loads the current file into ghci
18:37:21 <drdr> ok
18:37:46 <fhobia> :-) ...how do i add a number to a string like "Line: " ++ num ?
18:37:57 <bd_> > "Line: " ++ (show (1+1))
18:37:58 <lambdabot>   "Line: 2"
18:38:01 <tensorpudding> it allows you to do other things, google the haskell-mode docs if you want
18:39:16 <Veinor> :t Show
18:39:17 <lambdabot> Not in scope: data constructor `Show'
18:39:18 <Veinor> er
18:39:20 <Veinor> :t show
18:39:21 <lambdabot> forall a. (Show a) => a -> String
18:39:51 <ben0x539> :t fmap
18:39:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:39:57 <aavogt> @hoogle Integer -> String
18:39:57 <lambdabot> Prelude show :: Show a => a -> String
18:39:58 <lambdabot> Text.Show show :: Show a => a -> String
18:39:58 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
18:40:16 <fhobia> awesome
18:40:24 <mauke> > gshow 42
18:40:25 <lambdabot>   "(42)"
18:40:32 <mauke> wat
18:40:42 <ColonelJ> @hoogle [a] -> [Integer] -> [a]
18:40:43 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
18:40:43 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
18:40:43 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
18:41:07 <ColonelJ> pff
18:41:08 <aavogt> funny how it doesn't just pick const
18:41:41 <ColonelJ> @hoogle listindex
18:41:41 <lambdabot> No results found
18:41:57 <aavogt> there aren't very many thing you can do to a   [a]
18:42:16 <ColonelJ> I think [Integer] -> [a] -> [a] is what I really meant
18:42:23 <ColonelJ> @hoogle [Integer] -> [a] -> [a]
18:42:24 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
18:42:24 <medfly> @hoogle Integer -> [a] -> [a]
18:42:24 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
18:42:24 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
18:42:24 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
18:42:24 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
18:42:26 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
18:42:34 <aavogt> @type \xs -> concatMap (flip replicate xs)
18:42:35 <lambdabot> forall a. a -> [Int] -> [a]
18:42:50 <medfly> what are you trying to do
18:42:55 <aavogt> @type \xs -> concat . concatMap (flip replicate xs)
18:42:56 <lambdabot> forall a. [a] -> [Int] -> [a]
18:43:41 <ColonelJ> :t nth
18:43:42 <lambdabot> Not in scope: `nth'
18:43:42 <Veinor> the hell is gshow?
18:43:54 <ColonelJ> :t element
18:43:55 <lambdabot> Not in scope: `element'
18:43:55 <cwraith> @hoogle gshow
18:43:55 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
18:44:05 <Veinor> element is called elem :P
18:44:11 <cwraith> looks like it's part of SYB
18:44:11 <Veinor> > 2 `elem` [2,3]
18:44:11 <ColonelJ> :t elem
18:44:12 <lambdabot>   True
18:44:12 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
18:44:33 <aavogt> > gshow ()
18:44:34 <ColonelJ> what's nth then?
18:44:34 <lambdabot>   "(())"
18:44:39 <Veinor> nth?
18:44:43 <Veinor> > fix gshow
18:44:44 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:44:47 <Veinor> ...
18:44:54 <aavogt> > [2,3] !! 1
18:44:55 <cwraith> ColonelJ: !!
18:44:55 <lambdabot>   3
18:45:09 <ColonelJ> yeah that thanks
18:45:09 <Veinor> oh, yeah. you want !!
18:45:25 <aavogt> you probably want to avoid that operation as much a possible
18:45:33 <ColonelJ> not sure I can here
18:45:38 <ColonelJ> I'll write the function and you can see if there's a way
18:45:47 <aavogt> @hpaste
18:45:47 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:45:54 <ColonelJ> it's one liner
18:46:08 <aavogt> ok
18:46:08 <cwraith> > gshow ("martians", 34)
18:46:09 <lambdabot>   "((,) \"martians\" (34))"
18:46:31 <Veinor> that's weird.
18:47:22 <c_wraith> Veinor: It's valid haskell code for creating that tuple
18:47:28 <Veinor> yes, I know
18:47:36 <Veinor> (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
18:47:43 <Veinor> 21:45:21 <~xephero> 8 fucking ruled
18:47:50 <Cale> It's because gshow doesn't treat anything as a special case.
18:47:51 <Veinor> ... how did that get in here :I
18:48:24 <Cale> hmm
18:48:29 <Cale> > gshow [1,2,3]
18:48:30 <lambdabot>   "((:) (1) ((:) (2) ((:) (3) ([]))))"
18:48:34 <Cale> right :)
18:49:00 <skorpan> @src gshow
18:49:01 <lambdabot> Source not found. Wrong!  You cheating scum!
18:49:04 <skorpan> :t gsho
18:49:05 <skorpan> :t gshow
18:49:05 <lambdabot> Not in scope: `gsho'
18:49:06 <lambdabot> forall a. (Data a) => a -> String
18:49:17 <mle> > gshow gshow
18:49:18 <skorpan> so it's defined in what, Data.Data?
18:49:18 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:49:18 <lambdabot>    `Data.Data.Data a'
18:49:18 <lambdabot>      a...
18:49:30 <c_wraith> @hoogle gshow
18:49:30 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
18:49:51 <skorpan> Data.Data.Data a - awesome
18:49:56 <Veinor> oh, data data data I don't want to leave the zeta oh no no no no no~ o/`
18:50:03 <c_wraith> I'm pretty sure there's no Data instance for functions.  >_>
18:50:18 <mle> c_wraith: for now, heh.
18:50:18 <skorpan> almost of like python's datetime.datetime
18:51:37 <Veinor> ColonelJ: so what are you trying to do?
18:51:58 <ColonelJ> I've forgotten how to do multiple definitions in a let
18:52:02 <ColonelJ> for pattern matching
18:52:32 <c_wraith> ColonelJ: in a one-liner, separate them with ;
18:52:41 <Cale> ColonelJ: Just line them up vertically, ordinarily.
18:52:44 <ColonelJ> I guessed it already
18:53:51 <ColonelJ> @let listindex [] xs = []; listindex (i:is) xs = (xs !! i) : listindex is xs
18:53:54 <lambdabot>  Defined.
18:54:11 <systemfault> Hello, I just made a small snippet to solve Project Euler #14 but it's slow as hell, anyon could take a look at it and tell me what I'm doing wrong?
18:54:14 <systemfault> http://www.ideone.com/f7Jxx8Ym
18:55:10 <Cale> systemfault: Needs more memoisation.
18:55:13 <c_wraith> That one's easier if you memoize it.
18:55:24 <c_wraith> also, there's a function maximum that does what your whole fold does
18:55:27 <c_wraith> :t maximum
18:55:28 <ColonelJ> systemfault: it's an optimization thing you're missing
18:55:28 <lambdabot> forall a. (Ord a) => [a] -> a
18:55:33 <mauke> oi, another pastebin
18:56:32 <Cale> systemfault: If you make use of the data-memocombinators library, you can make it rather pretty.
18:56:32 <ColonelJ> when I did it in C I just used an array and filled in values with lengths as I came to them
18:57:08 <Cale> You can do the same thing in Haskell, by defining an array which has all the right values straight away. They'll only be computed as needed.
18:57:18 <Cale> But Data.MemoCombinators is even prettier.
18:57:38 <systemfault> I'll google a bit, I'm really a beginner :)
18:57:41 <ColonelJ> yeah memoization is neater for this
18:59:53 <FunctorSalad> random thought... why not a MEMO pragma?
19:00:00 <FunctorSalad> (as a new lang feature)
19:00:36 <FunctorSalad> (functions could be tagged with it)
19:00:53 <SamB_XP_> heh
19:01:01 <Cale> systemfault: I'll write up an example
19:01:02 <SamB_XP_> why do people always come up with this one ?
19:01:10 <systemfault> Cale: :)
19:01:24 <SamB_XP_> ("MEMO pragma")
19:01:39 <ColonelJ> > listindex [8,5,12,12,15] " abcdefghijklmnopqrstuvwxyz"
19:01:40 <c_wraith> FunctorSalad: to some extent, that's a tough thing to do.  It's not always obvious from the type of the argument what the best way to memoize it is.  (that is, what the best data structure to use is)
19:01:40 <lambdabot>   "hello"
19:01:56 <FunctorSalad> SamB_XP_: has it been discussed and decided against, you mean?
19:02:19 <SamB_XP_> it's just that there's a lot more to memoizing than saying "memoize this!"
19:02:25 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=5674#a5674
19:02:27 <FunctorSalad> c_wraith: hmm, right... you could fallback to an Ord-based map, I guess
19:02:52 <Cale> oops, didn't actually use all the things I imported :P
19:03:03 <Cale> Don't need Data.Ord or Data.List
19:03:34 <c_wraith> FunctorSalad: If the arg type is Int, what's the best way to memoize?  If the access pattern is clustered, Array is best.  If it's chaotic, IntMap is best.  etc....  So many decisions to make.
19:03:43 <FunctorSalad> Cale: not familiar with how Data.MemoCombinators does it
19:03:53 <chrisdone> Haskell> let Right [Stmt (StmtPos _ (ExprStmt (AssignE (CondE (AExpr (AOp a b c))))))] = parseProgram "a+a"
19:03:53 <chrisdone> a :: String
19:03:53 <chrisdone> b :: AExpr
19:03:55 <chrisdone> c :: AExpr
19:03:58 <chrisdone> (0.00 secs, 2098080 bytes)
19:04:01 <chrisdone> I love GHCi
19:04:04 <FunctorSalad> (err nvm... you were talking about your imports, not my mention of Ord)
19:04:09 <Cale> FunctorSalad: It's really cool. The source code to Data.MemoCombinators is very enlightening. There's nothing impure at all.
19:04:57 <FunctorSalad> c_wraith: hmm yes
19:05:23 <systemfault> Cale: Seems that I don't have Data.MemoCombinators.
19:05:34 <Cale> systemfault: cabal install data-memocombinators
19:05:41 <systemfault> Ok :)
19:06:09 <Cale> (It's one of those things which almost ought to be in base :)
19:06:23 <FunctorSalad> or maybe I've seen it... was this the scheme of "defunctionalizing" function types?
19:06:44 <FunctorSalad> like (Bool -> a) ~ (a,a) and so on
19:07:05 <ColonelJ> how do I get out of ghci
19:07:19 <FunctorSalad> ColonelJ: Ctrl+D
19:07:25 <ColonelJ> : panic! (the 'impossible' happened)
19:07:25 <ColonelJ>   (GHC version 6.10.4 for i386-unknown-mingw32):
19:07:25 <ColonelJ>         thread blocked indefinitely
19:07:25 <ColonelJ> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
19:07:37 <ColonelJ> That was Ctrl+Z
19:07:38 <Cale> ColonelJ: odd, heh
19:08:05 <SamB_XP_> ColonelJ: might as well do as it says, I guess ...
19:09:29 <systemfault> Cale: Is there a command I have to do after the cabal install? Because i'm getting undefined references..
19:10:08 <ColonelJ> actually maybe it wasn't ctrl+z after all, I think it was ctrl+C
19:10:45 <FunctorSalad> Ctrl+C doesn't quit it for me
19:10:48 <ColonelJ> no
19:10:50 * hackagebot upload: data-inttrie 0.0.1 - A lazy, infinite trie of integers. (LukePalmer)
19:10:51 <FunctorSalad> (but 6.12)
19:10:51 <Cale> systemfault: Oh, use --make to build the program
19:10:59 <ColonelJ> but if you hold the key combination, then type something else, it crashes
19:11:00 <Cale> ghc -O2 --make 14
19:11:04 <FunctorSalad> oh
19:11:33 <systemfault> Cale: Thank you :)
19:12:58 <systemfault> Cale: Still a bit slow but it now takes half the time :)
19:12:59 <Cale> Interestingly, it seems to take a lot longer and a lot more memory if you memoise all results of the function with Memo.integral rather than Memo.arrayRange (1,10^6)
19:13:14 <Cale> Oh, well, it only takes a couple seconds here.
19:13:35 <Cale> Maybe 5 seconds or so :)
19:13:41 <systemfault> Ok:)
19:13:59 <ColonelJ> that's... unimpressive
19:14:06 <ColonelJ> how long does the arrayRange one take
19:14:09 <Cale> Seems about right.
19:14:26 <Cale> ColonelJ: That's what I'm measuring
19:14:28 <medfly> "pfft, only half the time?"
19:14:40 <ColonelJ> it should take about 1 millionth of the time
19:14:44 <Cale> oh
19:14:45 <medfly> "I should learn another language. Haskell isn't worth it"
19:14:45 <ColonelJ> if it actually works
19:14:51 <Cale> Well, yes, it should
19:15:06 <Cale> I haven't measured the unmemoised one
19:15:25 <medfly> Cale: systemfault has
19:15:43 <ColonelJ> my C# one takes less than a second
19:15:51 * hackagebot upload: data-inttrie 0.0.2 - A lazy, infinite trie of integers. (LukePalmer)
19:15:57 <systemfault> ColonelJ: Yeah, that's my problem...
19:15:57 <Cale> ColonelJ: memoised, yeah?
19:16:05 <ColonelJ> on a pentium III, including start up time, using an array
19:16:09 <augur> does anyone have a decent amount of experience with a diverse range of logical systems? to the extent that you might call yourself a logician?
19:16:26 <ColonelJ> augur: probably
19:16:54 <ColonelJ> augur: people were mentioning this sort of stuff yesterday...
19:17:01 <augur> oh?
19:17:26 <ColonelJ> [10:04] <Cale> ZF+CH+AC means that you not only can well order the reals, but you can well order the reals such that the set of predecessors of any real is a countable set.
19:17:40 <ColonelJ> I think that should be ZFC
19:17:41 <Cale> heh, I wouldn't call myself a logician though
19:17:52 * hackagebot upload: data-inttrie 0.0.3 - A lazy, infinite trie of integers. (LukePalmer)
19:17:52 <Cale> ZF+AC = ZFC
19:17:59 <ColonelJ> oh right
19:17:59 <Cale> So I could have said ZFC+CH
19:18:09 <augur> i need someone i can talk to about providing a proper explication of a logic
19:19:01 <tensorpudding> so every real number can have countably many predecessors? how does that work?
19:19:14 <QtPlaty[HireMe]> augur: What is your exact question/thing you wish to disccuss?
19:19:44 <Cale> tensorpudding: Take the first ordinal which has the cardinality of R
19:20:08 <ColonelJ> augur: http://en.wikipedia.org/wiki/First-order_logic
19:20:17 <augur> no no ColonelJ dont be ridiculous
19:20:18 <Cale> tensorpudding: Since it's the first, and ordinal less than it has a strictly smaller cardinality, in particular, because there are no cardinalities in between thanks to CH, it has the cardinality of N
19:20:25 <Cale> s/and/any
19:20:38 <tensorpudding> okay, i get that
19:20:44 <augur> QtPlaty[HireMe]: well, generally speaking, im trying to understand what i _should_ be doing in order to create something that could qualify as a logical system
19:20:55 <tensorpudding> the first uncountable ordinal isn't able to be reached by countably many applications of the ordinal successors though
19:21:02 <ColonelJ> augur: you just need axioms I think
19:21:08 <augur> e.g. what sort of tasks should i ensure it can properly handle, etc. and so forth
19:21:11 <Cale> tensorpudding: this is true
19:21:12 <ColonelJ> augur: axioms and rules
19:21:21 <tensorpudding> that was the point of my cognitive dissonance
19:21:28 <augur> right, but i mean, axioms in what sense, right
19:21:34 <doserj> augur: syntax, semantics, deduction rules
19:21:37 <Cale> tensorpudding: and since there's a bijection between that first uncountable ordinal and R, we can use that bijection to well order the reals
19:21:41 <augur> inference rules, i suppose, but im not sure what kinds of inferences i need to consider
19:21:59 <ColonelJ> the rules and the axioms actually define the logic
19:22:01 <Cale> tensorpudding: at which point each real number is assigned a countable ordinal
19:22:11 <ColonelJ> you can have whatever you want really
19:22:15 <QtPlaty[HireMe]> http://en.wikipedia.org/wiki/List_of_rules_of_inference
19:22:21 <tensorpudding> but the "greatest countable ordinal" cannot reach the smallest uncountable ordinal through the ordinal successor
19:22:27 <QtPlaty[HireMe]> Thouse are the most common
19:22:32 <Cale> There is no greatest countable ordinal
19:22:53 <tensorpudding> hmm
19:23:08 <twanvl> augur: you write statments in some syntax, for example in a type system you would say   "G |- x : t" to mean that expression "x" has type "t" in context G
19:23:10 <Cale> But every ordinal still has a set of predecessors (as normally constructed, they are its elements)
19:23:18 <tensorpudding> okay
19:23:20 <tensorpudding> i guess
19:23:46 <Cale> For instance, the first infinite ordinal has all finite ordinals as its set of predecessors.
19:23:49 <tensorpudding> it's still hard to talk about well-orderings on uncountable sets though
19:24:12 <tensorpudding> since you can't really picture it
19:24:12 <Cale> Well, AC guarantees their existence
19:24:22 <SamB_XP_> the WHAT now ?
19:24:30 <twanvl> augur: then the axioms are things like "() | 1 : Int" holds always, and rules like if "G |- f : a -> b" and "G |- x : a" can both be inferred, then so can "G |- f x : b"
19:24:36 <ColonelJ> augur: probably best way to understand it is to look at some actual logics, most are just based on others with stuff added
19:25:07 <Cale> I don't really feel like an uncountable ordinal is all that mysterious on its own, but somehow it's when you compare the standard ordering on the reals with that ordering, that's when it gets a bit strange :)
19:25:17 <augur> ColonelJ: believe me, ive looked at a bunch of books on non-standard (e.g. non F/S/HOL logics) and they dont really seem to explain much :P
19:25:32 <SamB_XP_> Cale: I'm afraid you may not be licensed to carry that axiom
19:25:43 <SamB_XP_> I'm going to have to see your license and registration?
19:25:44 <ColonelJ> augur: what's wrong with standard ones?
19:26:15 <Cale> I kind of like the global well ordering axiom myself
19:26:24 <Cale> Just give me an order which well orders *everything*
19:26:26 <SamB_XP_> I meant the AC
19:26:28 <Cale> yeah
19:26:37 <Cale> global well ordering obviously implies AC :)
19:26:38 <tensorpudding> how is an ordering that orders everything not a self-defeating object?
19:26:46 <augur> nothing as such, im just using a non-standard logical form and i'd like to demonstrate that it can be used to do certain inferences that you'd want it to be able to do
19:26:47 <augur> or whatever
19:26:48 <Cale> tensorpudding: eh?
19:26:52 <FunctorSalad> augur: "a logic" is a very broad term really... AIUI it isn't formally defined
19:26:55 <Cale> tensorpudding: Well, it orders all sets
19:26:59 <SamB_XP_> yeah, wouldn't it die of heart attack from all that food ?
19:27:01 <FunctorSalad> (it's what logicians study ;))
19:27:07 <tensorpudding> oh, just sets
19:27:22 <Cale> and sets are what the quantifiers are ranging over
19:27:29 <Cale> So, might as well be everything
19:27:45 <tensorpudding> it can't order the set of all orderings can it?
19:28:11 <FunctorSalad> SamB_XP_: food overdose acutely causes heart attacks? :o
19:28:12 <twanvl> there probably is no set of all orderings
19:28:18 <tensorpudding> well, it's probably not a set
19:28:19 <Cale> Well, it's not technically an ordering as normally defined, but an extra relation symbol which restricts to a well-ordering on any set.
19:28:41 <SamB_XP_> FunctorSalad: after long enough ordering everything, yes, It'll get one!
19:28:43 <tensorpudding> maybe there is a class of all orderings on sets
19:28:43 <ColonelJ> http://en.wikipedia.org/wiki/Modal_logic
19:28:48 <Cale> There is
19:29:06 <augur> ColonelJ: i know what modal logic is :P
19:29:14 <Cale> It's not hard to write down a predicate which specifies when something is an ordering, so there's a class of them.
19:29:32 <Cale> (an ordering which is itself a set, and not one of these global things)
19:30:00 <ColonelJ> augur: just making sure you know how to build up systems from axioms
19:30:24 <augur> im reading the formalization to be sure.
19:30:52 <augur> i suppose i need to figure out what my aim is for this thing to be able to do
19:30:53 <augur> hm
19:31:08 <augur> the kinds of inferences i want it to be able to make
19:32:59 * hackagebot upload: yst 0.2.2.1 - Builds a static website from templates and data in YAML or  CSV files. (JohnMacFarlane)
19:34:44 <Olathe> > let 5 = 6 in 5
19:34:46 <lambdabot>   5
19:34:48 <Olathe> Lies
19:34:59 <augur> ah but try adding
19:35:03 <augur> > let 5 = 6 in 5+5
19:35:04 <lambdabot>   10
19:35:06 <augur> :o
19:35:14 <Olathe> See ? Lies !
19:35:14 <augur> AMAAAAAZING
19:35:18 <augur> > let 5 = 6 in 5+1
19:35:18 <lambdabot>   6
19:35:20 <augur> :o
19:35:25 <Olathe> Haha
19:35:28 <augur> lambdabot doesnt like redefining numbers.
19:35:39 <Cale> It's a pattern binding which binds no variables
19:35:58 <Olathe> What if I consider 5 a variable ? ;)
19:36:03 <ColonelJ> 5 = 6 is false right?
19:36:09 <augur> no you're thinking of ==
19:36:11 <augur> = is assignment
19:36:14 <twanvl> > let 1+1=3 in 1+1
19:36:15 <lambdabot>   3
19:36:17 <augur>  /binding
19:36:25 <Cale> The pattern match would fail, if you could actually cause it to occur.
19:36:25 <Saizan> > let x@5 = 6 in x
19:36:27 <lambdabot>   * Exception: <interactive>:1:145-151: Irrefutable pattern failed for patter...
19:36:35 <Cale> right, like that :)
19:36:51 <ben0x539> > case 6 of 5 -> 5 + 5
19:36:52 <lambdabot>   * Exception: <interactive>:1:149-168: Non-exhaustive patterns in case
19:37:09 <Cale> let doesn't trigger any evaluation though
19:37:27 <mle> case is the only evalutation.
19:37:30 <ColonelJ> let (+1) x  = x+x in 5+1
19:37:33 <mle> ...only spelled better.
19:37:35 <ColonelJ> > let (+1) x  = x+x in 5+1
19:37:35 <lambdabot>   <no location info>: Parse error in pattern
19:37:39 <Cale> Except now that we have bang-patterns, they messed things up a bit
19:37:44 <mle> true.
19:37:51 <ColonelJ> > let x+1  = x+x in 5+1
19:37:52 <lambdabot>   * Exception: <interactive>:1:149-158: Non-exhaustive patterns in function +
19:38:00 <mle> useful though.
19:38:01 <Cale> I kind of wish that bang patterns worked how they originally did.
19:38:13 <Cale> Bang patterns at the top level of a pattern binding should be pointless.
19:38:17 <uorygl> Heh. It's evaluating 5+1 as 5+5 and then trying to pattern match on 5+5.
19:38:19 <ben0x539> > case undefined of _ -> "toot"
19:38:21 <lambdabot>   "toot"
19:38:40 <ben0x539> > let f !x = "toot" in f undefined
19:38:41 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:38:41 <lambdabot>    `SimpleReflect.FromExpr ...
19:38:48 <ben0x539> > let f !x = "toot" in f (undefined :: Int)
19:38:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:38:50 <lambdabot>    `GHC.Show.Show a'
19:38:50 <lambdabot>      a...
19:38:53 <ben0x539> aw :<
19:39:20 <ColonelJ> > let x*1 = x+x in 5*1
19:39:22 <lambdabot>   10
19:39:30 <Saizan> you're defining the (!) operator there
19:39:36 <ben0x539> Oh.
19:39:47 <Saizan> BangPatterns are not turned on
19:39:52 <ColonelJ> > let x*1 = x+x in 5*3
19:39:53 <lambdabot>   * Exception: <interactive>:1:149-157: Non-exhaustive patterns in function *
19:40:06 <ColonelJ> interesting...
19:40:24 <uorygl> Indeed, you're completely redefining the * function.
19:40:39 <uorygl> > let x*2 = x+x in 5*2 -- of course, this is the *proper* way to do it. :-P
19:40:40 <lambdabot>   10
19:41:12 <ColonelJ> uorygl: what if you want to use the old definition in your new one?
19:41:43 <ben0x539> > let x*0 = 0 ; x*n = x + x*(n-1) in 5*3
19:41:44 <lambdabot>   15
19:42:23 <Olathe> > let x*0 = 0 ; x*n = x + x*(n-1) in 5*3.5
19:42:25 <lambdabot>   * Exception: stack overflow
19:42:31 <ben0x539> What part of a case expression actually forces evaluation of the casee?
19:42:49 <Saizan> ColonelJ: you can qualify it, e.g. Prelude.*
19:43:02 <twanvl> > let 6*9 = 42; x*y = x Prelude.* y in map (6*) [5..10]
19:43:03 <lambdabot>   [30,36,42,48,42,60]
19:43:08 <ColonelJ> > 5 Prelude.* 6
19:43:09 <lambdabot>   30
19:43:15 <Olathe> zomg
19:43:27 <tensorpudding> > Prelude.(+) 2 1
19:43:29 <lambdabot>   Not in scope: data constructor `Prelude'
19:43:38 <tensorpudding> oh hmm
19:43:44 <Olathe> > (Prelude.+) 2 1
19:43:45 <lambdabot>   3
19:44:00 <tensorpudding> yes, that would be right
19:44:08 <ColonelJ> > let x*1 = x+x, x*y = x Prelude.* y in [5*1,6*2,99*1]
19:44:09 <Saizan> ben0x539: well the case expression by itself doesn't, but when you force its evaluation then the casee gets evaluated as far as it's needed to realize one of the patterns matches
19:44:09 <lambdabot>   <no location info>: parse error on input `,'
19:44:21 <ben0x539> right
19:44:28 <ColonelJ> > let x*1 = x+x, x*y = x Prelude.* y in [5*1, 6*2, 99*1]
19:44:29 <lambdabot>   <no location info>: parse error on input `,'
19:44:40 <Cale> Hmm, interesting
19:44:51 <aavogt> > let x*1 = x+x; x*y = x Prelude.* y in [5*1, 6*2, 99*1]
19:44:52 <medfly> > let x*1 = x+x, x*y = x (Prelude.*) y in [(5*1),(6*2),(99*1)]
19:44:52 <lambdabot>   [10,12,198]
19:44:53 <lambdabot>   <no location info>: parse error on input `,'
19:44:54 <ColonelJ> > let x*1 = x+x, x*y = x Prelude.* y in [(5*1), (6*2), (99*1)]
19:44:55 <lambdabot>   <no location info>: parse error on input `,'
19:45:02 <Cale> That Collatz chain length problem's time behaviour seems really sensitive to the size of the memo table
19:45:12 <ColonelJ> lol
19:45:14 <aavogt> > let x*1 = x+x; x*y = x Prelude.* y in [5*1, 6*2, 99*1] :: Expr
19:45:15 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
19:45:15 <lambdabot>         against inferred ...
19:45:20 <aavogt> > let x*1 = x+x; x*y = x Prelude.* y in [5*1, 6*2, 99*1] :: [Expr]
19:45:21 <lambdabot>   [5 + 5,6 * 2,99 + 99]
19:45:32 <medfly> > let x*1 = x+x, x*y = x (Prelude.*) y in [5*1,6*2,99*1]
19:45:33 <lambdabot>   <no location info>: parse error on input `,'
19:45:36 <twanvl> > let x*y = let z = x Prelude.* y in if z > 10 then var "infinity" else z in  [ x * 2 | x <- [1..10] ]
19:45:37 <lambdabot>   [2,4,6,8,10,infinity,infinity,infinity,infinity,infinity]
19:45:45 <Cale> A table with entries up to 4*10^5 is a good deal faster than one with entries up to 10^6
19:45:57 <Olathe> > let 6*9 = 42; x*y = x Prelude.* y in map (6*) [5..10] :: Expr
19:45:58 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
19:45:58 <lambdabot>         against inferred ...
19:46:04 <Olathe> > let 6*9 = 42; x*y = x Prelude.* y in map (6*) [5..10] :: [Expr]
19:46:05 <lambdabot>   [6 * 5,6 * 6,6 * 7,6 * 8,42,6 * 10]
19:46:32 <aavogt> > 42 / 7
19:46:33 <lambdabot>   6.0
19:46:46 <Berenlap> Cale: Doesn't that seem like a likely point to break cache coherence at?
19:47:26 <Cale> Berenlap: perhaps that's what it's about
19:47:42 <uorygl> > iterate (\x -> if x `mod` 2 == 0 then x `div` 2 else x * 3 + 1) 1209346 :: [Integer]
19:47:43 <lambdabot>   [1209346,604673,1814020,907010,453505,1360516,680258,340129,1020388,510194,...
19:47:45 <Cale> Though, we are talking about a boxed array
19:47:56 <BMeph> Breaks at 2^16, perhaps? :)
19:48:09 <twanvl> the size of the entire array shouldn't matter as long as only a part of it is used
19:48:47 <ColonelJ> > map (1+) [2..5] :: [Expr]
19:48:48 <lambdabot>   [1 + 2,1 + 3,1 + 4,1 + 5]
19:49:13 <Cale> 2^16-1 is almost twice as slow as 4*10^5
19:49:26 <Olathe> > logBase 2 (4*10^5)
19:49:27 <lambdabot>   18.609640474436812
19:49:39 <twanvl> Cale: perhaps most of the time is spend just building thunks
19:49:43 <Cale> Yeah, so that's a bit too small
19:50:21 <Olathe> > 2^19 - 1
19:50:22 <lambdabot>   524287
19:53:00 <ColonelJ> :t base
19:53:02 <lambdabot> Not in scope: `base'
19:57:57 <ColonelJ> > let 0 `base` b = 0, x `base` b = if x `mod` b == 0 then b * ((x `div` b) `base` b else x `mod` b + b * ((x `div` b) `base` b in map (\v -> v `base` b) [212,999,12,66] :: [Expr]
19:57:57 <lambdabot>   <no location info>: parse error on input `,'
19:59:35 <twanvl> ColonelJ: use ; to separate declarations in a let
19:59:45 <ColonelJ> oops, yeah
19:59:51 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then b * ((x `div` b) `base` b else x `mod` b + b * ((x `div` b) `base` b in map (\v -> v `base` b) [212,999,12,66] :: [Expr]
19:59:52 <lambdabot>   <no location info>: parse error on input `else'
20:00:27 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b * ((x `div` b) `base` b) else (x `mod` b + b * ((x `div` b) `base` b) in map (\v -> v `base` b) [212,999,12,66] :: [Expr]
20:00:28 <lambdabot>   <no location info>: parse error on input `else'
20:00:53 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b * ((x `div` b) `base` b)) else (x `mod` b + b * ((x `div` b) `base` b) in map (\v -> v `base` b) [212,999,12,66] :: [Expr]
20:00:54 <lambdabot>   <no location info>: parse error on input `in'
20:01:16 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b * ((x `div` b) `base` b)) else (x `mod` b + b * ((x `div` b) `base` b)) in map (\v -> v `base` b) [212,999,12,66] :: [Expr]
20:01:17 <lambdabot>   [212 `mod` b + b * (212 `div` b `mod` b + b * (212 `div` b `div` b `mod` b ...
20:02:34 <ColonelJ> > let 0 `base` b = 0; x `base` b = if mod x b == 0 then (b * ((x `div` b) `base` b)) else (x `mod` b + b * ((x `div` b) `base` b)) in map (\v -> v `base` b) [212,999,12,66] :: [Expr]
20:02:35 <lambdabot>   [212 `mod` b + b * (212 `div` b `mod` b + b * (212 `div` b `div` b `mod` b ...
20:03:47 <ColonelJ> how do you control what goes in the expression and what doesn't
20:05:29 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b * ((x `div` b) `base` b)) else (mod x b + b * ((x `div` b) `base` b)) in map (\v -> v `base` b) [212,999,12,66] :: [Expr]
20:05:30 <lambdabot>   [212 `mod` b + b * (212 `div` b `mod` b + b * (212 `div` b `div` b `mod` b ...
20:06:27 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then ((b :: Expr) * ((x `div` b) `base` b)) else (x `mod` b + b * ((x `div` b) `base` b)) in map (\v -> v `base` b) [212,999,12,66]
20:06:28 <lambdabot>   [212 `mod` b + b * (212 `div` b `mod` b + b * (212 `div` b `div` b `mod` b ...
20:06:58 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b * ((x `div` b) `base` b)) else (x `mod` b + b * ((x `div` b) `base` b)) in map (\v -> v `base` b) [212,999,12,66]
20:06:59 <lambdabot>   [212 `mod` b + b * (212 `div` b `mod` b + b * (212 `div` b `div` b `mod` b ...
20:07:32 <matsuura> holy fuck
20:09:03 <twanvl> ColonelJ: everything goes into the expression, but you could keep things as Integers first, and then use fromInteger to convert to an Expr
20:09:05 <uorygl> How much faster is testing the Collatz conjecture when you assume it holds for every number below the one you're resting?
20:09:40 <ColonelJ> twanvl: even after I got rid of Expr it still gives an expression
20:11:45 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then 99 - 1 else 100 + 1 in map (\v -> v `base` b) [212,999,12,66]
20:11:47 <lambdabot>   [101,101,101,101]
20:12:11 <twanvl> ColonelJ: you get an Expr because you used 'b' somewhere
20:12:16 <ColonelJ> ah yes
20:12:29 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b * ((x `div` b) `base` b)) else (x `mod` b + b * ((x `div` b) `base` b)) in map (\v -> v `base` 2) [212,999,12,66]
20:12:30 <lambdabot>   [212,999,12,66]
20:13:08 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b :: Expr * ((x `div` b) `base` b)) else (x `mod` b + b * ((x `div` b) `base` b)) in map (\v -> v `base` 2) [212,999,12,66]
20:13:09 <lambdabot>   <no location info>: parse error on input `*'
20:13:17 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then ((b :: Expr) * ((x `div` b) `base` b)) else (x `mod` b + b * ((x `div` b) `base` b)) in map (\v -> v `base` 2) [212,999,12,66]
20:13:18 <lambdabot>   [2 * (2 * (212 `div` 2 `div` 2 `mod` 2 + 2 * (2 * (212 `div` 2 `div` 2 `div...
20:13:55 <medfly> you can query lambdabot too
20:15:03 <ColonelJ> meh I'll figure it out another time
20:16:02 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then ((fromInteger b) * ((x `div` b) `base` b)) else (x `mod` b + b * ((x `div` b) `base` b)) in map (\v -> v `base` 2) [212,999,12,66]
20:16:04 <lambdabot>   [212,999,12,66]
20:16:16 <ColonelJ> :t fromInteger
20:16:17 <lambdabot> forall a. (Num a) => Integer -> a
20:16:44 <ColonelJ> that doesn't seem to convert to an Expr as was claimed
20:16:50 <twanvl> > fromInteger 2 :: Expr
20:16:51 <lambdabot>   2
20:17:04 <twanvl> > fromInteger (2+3) + 4 :: Expr
20:17:05 <lambdabot>   5 + 4
20:17:34 <twanvl> that works because Expr is an instance of Num
20:19:37 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b * ((x `div` b) `base` b)) else (fromInteger (x `mod` b) + (b :: Expr) * fromInteger ((x `div` b) `base` b)) in map (\v -> v `base` 2) [212,999,12,66]
20:19:38 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:19:38 <lambdabot>         against inferred ...
20:20:18 <ColonelJ> thanks lambdabot for that useful feedback
20:20:34 <ColonelJ> ah I see
20:20:43 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b * ((x `div` b) `base` b)) else (fromInteger (x `mod` b) + (b :: Expr) * ((x `div` b) `base` b)) in map (\v -> v `base` 2) [212,999,12,66]
20:20:43 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:20:44 <lambdabot>         against inferred ...
20:21:43 <ColonelJ> > let 0 `base` b = 0; x `base` b = if x `mod` b == 0 then (b * (fromInteger (x `div` b) `base` b :: Expr)) else (fromInteger (x `mod` b) + (b :: Expr) * ((x `div` b) `base` b)) in map (\v -> v `base` 2) [212,999,12,66]
20:21:44 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
20:21:44 <lambdabot>         agains...
20:22:12 <twanvl> ColonelJ: perhaps you should try it locally in ghci, that will give you more feedback
20:22:27 <ColonelJ> probably, how do you load the Expr thing
20:22:34 <ColonelJ> :t Expr
20:22:35 <lambdabot> Not in scope: data constructor `Expr'
20:22:38 <twanvl> cabal install simple-reflect
20:22:42 <twanvl> import Data.SimpleReflect
20:23:40 <twanvl> you could also talk to lambdabot in private, I believe she shows 6 lines instead of 2 in that case
20:23:53 <ColonelJ> cabal: There is no package named simple-reflect
20:24:13 <twanvl> try  cabal update
20:25:00 <ColonelJ> it's telling me to cabal install cabal-install
20:26:42 <twanvl> that probably means you have an old version of cabal
20:26:57 <ColonelJ> at least a few days old
20:27:10 <ColonelJ> at most a week
20:27:40 <BMeph> Man, what loser wrote that package?
20:27:49 <BMeph> ;p
20:27:52 <twanvl> BMeph: which one?
20:28:25 <ColonelJ> > repeat "cabal install "
20:28:27 <lambdabot>   ["cabal install ","cabal install ","cabal install ","cabal install ","cabal...
20:28:37 <ColonelJ> > cycle "cabal install "
20:28:38 <lambdabot>   "cabal install cabal install cabal install cabal install cabal install caba...
20:29:32 <twanvl> anyway, I really should be going to bed
20:29:42 <BMeph> That "simple-reflect" one. :)
20:29:43 <ColonelJ> me too, but I probably won't
20:29:44 <twanvl> good luck, ColonelJ
20:30:02 <SamB_XP_> @localtime twanvl
20:30:03 <lambdabot> Local time for twanvl is Fri Jan 01 05:29:44
20:30:11 <SamB_XP_> hehehehe
20:30:11 <twanvl> ?slap BMeph
20:30:11 * lambdabot will count to five...
20:30:14 <twanvl> ?slap BMeph
20:30:15 * lambdabot hits BMeph with a hammer, so they breaks into a thousand pieces
20:30:15 <ColonelJ> @localtime ColonelJ
20:30:15 <SamB_XP_> yeah, I guess you should ;-P
20:30:16 <lambdabot> Local time for ColonelJ is Fri Jan 01 04:29:55 2010
20:30:31 <ColonelJ> mine has the year I win
20:31:13 <ColonelJ> what do we call this decade?
20:31:40 <medfly> wasted time
20:42:41 * araujo just released his small language
20:42:45 <araujo> http://code.google.com/p/jotstack  !
20:43:37 <medfly> grats
20:45:02 <ivanm> ColonelJ: well, this is still technically the same decade as last year....
20:45:16 <ivanm> same as the new millenium started in 2001, not 2000
20:45:32 <ColonelJ> millenia aren't related to decades much
20:45:56 <ColonelJ> I mean like, the eighties, the nineties, the noughties, the ...?
20:46:02 <ivanm> ColonelJ: sure there are; 10 decades to a century, 10 centuries to a millenium
20:46:09 <medfly> the eleventies
20:46:26 <ivanm> ColonelJ: why bother providing yet another artificial time-based grouping that doesn't mean anything?
20:46:40 <ColonelJ> ivanm: there has to be one
20:46:47 <ivanm> why?
20:48:39 <c9s> is there anyone using ghc on snowleopard ?
20:48:49 <c9s> how do i install ghc from ports ? or ?
20:48:56 <c9s> any ideas ?
20:49:19 <ivanm> probably depends which version you're talking about here (of ghc)
20:49:24 <ColonelJ> ivanm: because the lack of one will mean someone will make one up at some point, and it will catch on
20:49:27 <ivanm> but there has been talk of it on the haskell-cafe mailing list
20:49:37 <ivanm> ColonelJ: still doesn't explain why there _has_ to be one
20:49:44 <ColonelJ> inevitability
20:49:57 <ivanm> it just means there are even more stupid people in the world than I thought, that's all
20:49:59 <ivanm> *shrug*
20:50:00 <ivanm> ;-)
20:50:19 <ColonelJ> generally it's the media's fault
20:51:06 <ivanm> agreed
20:51:08 <ivanm> media--
20:51:16 <ivanm> @karma media
20:51:17 <lambdabot> media has a karma of -1
21:07:04 <drwho> happy new year
21:10:21 <ivanm> drwho: are you really a gallifreyan?
21:11:02 <patc__> If he has a time machine he can have new year every day
21:19:53 <FunctorSalad> media--
21:21:37 <shapr> @karma media
21:21:37 <lambdabot> media has a karma of -2
21:21:43 <shapr> media--
21:21:55 <shapr> The advertising and packaging industry makes me angry.
21:22:02 <FunctorSalad> I feel guilty already for ganging up on media
21:22:06 <shapr> They're not the music industry, since they clearly don't make music.
21:22:17 <FunctorSalad> (but then media do really suck)
21:22:31 <FunctorSalad> :)
21:22:54 <FunctorSalad> I'm more concerned about the constant oversimplification of issues
21:22:55 <Jafet> Neither does the music industry.
21:23:03 <FunctorSalad> (blah, sorry)
21:23:20 <SamB_XP_> Jafet: I think he was talking about the people who refer to themselves thus
21:24:06 <Jafet> @faq Can Haskell make music?
21:24:06 <lambdabot> The answer is: Yes! Haskell can do that.
21:26:33 <ski> (mauke : i'm the limit of what ?)
21:27:59 <Jafet> .oO(That was a half-day-old conversation)
21:28:25 <FunctorSalad> I was already wondering
21:28:26 <FunctorSalad> :)
21:36:32 <shapr> happy new year... almost
21:36:57 <Twey> Where are you that it's not yet 2010?
21:37:02 <SamB_XP_> shapr: you're about a half hour late!
21:37:10 <SamB_XP_> Twey: a bit further west than I ;-P
21:37:17 <Nafai> It's not for an hour and a half!
21:37:24 <shapr> It's still half an hour till new year here.
21:37:24 <Nafai> Hey shapr!
21:37:35 <shapr> y0
21:37:37 <Twey> Ooh.
21:37:44 <skorpan> how exotic
21:38:08 <skorpan> what happened to internet time anyways?  you know that whole @3248 thingie
21:38:26 <SamB_XP_> skorpan: people decided that decimal was dumb?
21:38:42 <Twey> 60 is a pretty nice base
21:38:48 <skorpan> SamB_XP_: i recall having a cell phone back then which supported it
21:38:49 <Twey> Let's use base-60 time
21:39:18 <Twey> … which basically just means changing to 60 hours in a day and dividing a year into 6 chunks with a bit left over
21:39:39 <shapr> I like internet time.
21:40:01 <SamB_XP_> shapr: it makes timezones a pain, though, doesn't it ?
21:40:12 <skorpan> timezones don't exist on the internet
21:40:14 <Twey> It removes timezones
21:40:16 <skorpan> wasn't that the whole point?
21:40:16 <Twey> That's the point
21:40:21 <skorpan> jinx
21:40:31 <SamB_XP_> okay, then, it makes it a lot harder to figure out when midnight is
21:40:32 <Twey> Hehe
21:40:32 <SamB_XP_> whatever
21:44:14 <shapr> SamB_XP_, internet time has only one time zone total.
21:45:13 <medfly> it's always 4am
21:45:41 <medfly> and we're all sitting in boxers with a beer bottle on our table
21:45:43 <medfly> sorry
21:46:09 <skorpan> that's the internet
21:46:16 <skorpan> sitting in your boxers with beer at 4am
21:50:00 <FunctorSalad> and we *like* it :D
22:01:41 <ezyang> Happy New Years #haskell
22:03:00 <shapr> happy new year from Alabama!
22:03:36 <medfly> happy new years from #c++ !
22:03:43 <medfly> (which is where we all hang out, right?)
22:04:23 <Veinor> 03:31:51 [freenode] DCC SEND from esi889Y[Q [0.0.0.0 port 0]: startkeylogger [0B bytes] requested in channel #haskell
22:04:31 <Veinor> I'm surprised that's not blocked.
22:04:41 * ski moves away from medfly on the bench, there
22:04:52 * Twey too, on the opposite side
22:04:55 <Twey> :þ
22:05:03 <Twey> C++ lurgy!
22:13:46 <path[l]> oh thats where I keep getting the startkeylogger from
22:13:47 <path[l]> lol
22:14:09 <Cale> 新年おめでとう
22:16:29 <Twey> Cale: 開けましておめでとう。 ☺
22:16:46 <skorpan> apparently it's okay to speak non-english languages in this channel.
22:16:59 <shapr> sakert?
22:17:25 <Twey> Kaip suprantu.
22:17:35 <Twey> Taip**
22:17:41 <skorpan> сталин мотхерфуцкерс, до ёу спеак ит?
22:18:14 <Twey> Why yes.  Yes I do.
22:18:23 <skorpan> just checking
22:18:29 <Twey> :þ
22:19:40 <Cale> Why the ц?
22:19:59 <skorpan> apparently that's what "uc" becomes
22:20:03 <Twey> Because that's what ‘c’ maps to in the phonetic Cyrillic layout.  ;)
22:20:05 <skorpan> i didn't really bother that much
22:20:12 <skorpan> oh, yeah, 'c'
22:35:29 <Jonno_FTW> gentlemen
22:35:41 <shapr> Yeah?
22:35:47 <Jonno_FTW> wow,
22:35:51 <Jonno_FTW> this place isn't deserted
22:37:00 <Jonno_FTW> *tumbleweed*
22:37:34 <shapr> It's #haskell
22:37:39 <shapr> It's never deserted!
22:37:52 <Jonno_FTW> import Lazy.Tumbleweed
22:38:01 <shapr> In reality, I'm single.
22:38:06 <shapr> Otherwise, I'd be out with some woman.
22:38:27 <Jonno_FTW> makes sense
22:41:40 <shapr> it's oh so quiet...
22:41:43 <shapr> it's oh so still...
22:41:47 <shapr> you're all alone...
22:45:02 <Jonno_FTW> *crickets chirping*
22:45:35 * shapr chirps
22:45:48 <shapr> I'm chirping like a Japanese cricket... because I'm drinking Japanese sake!
22:45:56 <shapr> jiihaa! den är så kul!
22:46:10 <Jonno_FTW> that isn't japanese
22:46:15 <shapr> oh right
22:46:17 <shapr> What was that?
22:46:23 <Jafet> http://www.youtube.com/watch?v=fZ1uk7hdM7o
22:46:29 <Jonno_FTW> seems scandanavian
22:46:35 <shapr> Jonno_FTW: huh, could be
22:46:39 <adu> 謹賀新年
22:46:48 <Jonno_FTW> that's chinese
22:46:56 <shapr> You sure it's not Japanese?
22:47:01 <matsuura> it can be
22:47:02 <Jonno_FTW> it could be
22:47:02 <matsuura> lol
22:47:35 <adu> its japanese
22:47:41 <shapr> Aha!
22:47:51 <matsuura> :p
22:47:56 <Jonno_FTW> sorry, i didn't learn a lot of Kanji
22:47:58 <shapr> does it say something about rice wine?
22:48:02 <matsuura> nope
22:48:05 <shapr> aww
22:48:15 <matsuura> new years
22:48:24 <adu> 日本語ですよ
22:48:26 <Jonno_FTW> happy new years from 17 hours ago
22:48:35 <Jonno_FTW> nihongodesuyo
22:48:36 <matsuura> yeah
22:48:55 <SamB_XP_> happy ne years from my sleep
22:49:07 <Jonno_FTW> and desuyo means what in context of nihongo?
22:49:13 <shapr> bra nytår!
22:49:15 <shapr> or something like that
22:49:39 <adu> Jonno_FTW: its kinda like the Minnesota "dontchya know"
22:49:42 <shapr> gott nytt år!
22:49:44 <matsuura> Jonno_FTW: it's japanese!!
22:49:46 <Jonno_FTW> ok
22:49:51 <Jonno_FTW> right
22:49:55 <shapr> Eh, that was closer.
22:50:24 <matsuura> or, "god fucking damnit, its JAPANESE!!!! :DDDDDDDDDDDDDDDDDDDDDDDDD ^______________________________^" or soething
22:50:25 <Jonno_FTW> nihongo wa wakarimasen
22:50:27 <matsuura> something *
22:50:33 <matsuura> that's okay
22:50:45 <adu> Jonno_FTW: です by itself is the end of a sentence.
22:50:54 <Jonno_FTW> i know that bit
22:51:00 <adu> Jonno_FTW: it literally means "is"
22:51:14 <o-_-o> this suddenly turned into haskell-blah :-), but happy new year!
22:51:14 <matsuura> the equiv of are or a coupla
22:51:14 <shapr> Jag vill tala mer svenska istället :-P
22:51:21 <adu> HNY
22:52:06 <adu> i think i've had a little toomuch rice wine
22:52:23 <Jonno_FTW> i had too much ouzo and then i felt sick
22:52:25 * SamB_XP_ keeps falling mostly asleep at the keyboard
22:52:28 <adu> my friend got a drunk text, and it had way to many letters missin
22:52:38 <matsuura> I don't want to live..
22:52:40 <o-_-o> ಹೊಸ  ವರ್ಷದ ಶುಭಾಶಯಗಳು
22:52:42 <matsuura> but I don't want to die
22:52:47 <o-_-o> wonder if that works
22:52:49 <matsuura> it's really really frustrating
22:52:50 <adu> o-_-o: is that Hindi?
22:52:57 <Twey> … no
22:52:59 <adu> o-_-o: Georgian?
22:53:04 <o-_-o> adu, no kannada
22:53:13 <matsuura> that's hard to read
22:53:15 <adu> oh the kanada with a K
22:53:16 <matsuura> really hard to read
22:53:21 <o-_-o> ಠ_ಠ this language
22:53:34 <matsuura> yeah
22:53:46 <o-_-o> no seriously
22:53:53 <matsuura> I believe you
22:53:58 <matsuura> it's just really hard to read
22:54:00 <adu> I like Burmese
22:54:10 <adu> a.k.a. Myamarese
22:54:31 <o-_-o> matsuura, actually it is phonetic, so once you know the characters it is very easy
22:54:32 <shapr> Jag är så trött...
22:54:37 <o-_-o> matsuura, just like sanskrit
22:54:52 <o-_-o> there is nothing like a spelling mistake
22:55:10 <matsuura> I suppose, but that's just like reading really dense chinese characters, it's still really difficult to read unless you boost the font size
22:55:24 * adu <3 UTF8
22:55:28 <o-_-o> matsuura, that may because of really bad fonts
22:55:37 <adu> but china like GB
22:55:44 <matsuura> ah, perhaps.. I don't have specifics for that langauge set up so... :p
22:55:49 <o-_-o> matsuura, most of the fonts for the language are made by amateurs
22:56:06 <matsuura> :(
22:56:31 <adu> you know what i like even more than utf8?
22:56:36 <adu> EXI
22:57:11 <ivanm> adu: you know what I like even more than utf-8? cheese!
22:57:12 <ivanm> ;-)
22:57:20 <adu> lol
22:57:33 <adu> i like pasta, but close enough :)
22:57:43 <adu> http://straymindcough.blogspot.com/2009/05/haskell-exi-and-utf-8-encodings.html
22:58:00 <o-_-o> नोथन सूर्यमान सम्वथ्सरस्य सुभाशयह This is in sanskrit (how they wished happy new year 3000 years ago :-p)
22:58:10 <o-_-o> oops
22:58:35 <o-_-o> नूतन सूर्यमान सम्वथ्सरस्य सुभाशयह sorry spelling mistake :-)
22:58:36 <matsuura> o-_-o: yeah, that's not even readable here
22:58:46 <matsuura> even knowing the langauge, the charactesrs only have a slight change
22:58:53 <matsuura> need better fonts + size
22:58:53 <adu> i can see it, but only because I use GNU Unifont
22:59:14 <Veinor> I can see it find.
22:59:14 <matsuura> :)
22:59:19 <adu> matsuura: I highly recommend GNU Unifont, it may look really pixelated, but it has every unicode character in the BMP
22:59:20 <Veinor> I can't read it, though. :P
22:59:23 <ivanm> gah! unifont is _ugly_ :s
22:59:44 <matsuura> adu: eh, doesn't matter, I wont learn the language any time soon, so, no worries
22:59:46 <o-_-o> it is easier than haskell to learn :-)
22:59:47 <ivanm> seems to be overly hinted or something :s
22:59:48 <adu> ivanm: that's why it makes a good fallback font :)
22:59:50 <matsuura> is kind of interesting none the less
22:59:57 <ivanm> adu: _because_ it's fugly?
23:00:06 <o-_-o> ivanm, it is overly hinted
23:00:08 <adu> ivanm: no because it has every character
23:00:24 <adu> o-_-o: its a bitmap font, there is no hinting at all
23:00:34 <o-_-o> adu, ah
23:00:45 <o-_-o> I wonder what font I have, it came with fedora
23:00:45 * adu <3 gnu-unifont
23:00:47 * ivanm goes back to DejaVu Sans Mono
23:01:13 <o-_-o> it says happy new year according to solar calendar
23:01:45 <adu> ivanm: DejaVu is fugly
23:02:01 <ivanm> nowhere near as fugly as unifont is
23:02:28 <adu> at least the letters are crisp, as opposed to 4 gray pixels to indicate a line
23:02:41 <Sam__> adu: it only looks pixelated if you don't set the size correctly ;-P
23:03:01 <adu> Sam__: I set the size correctly :)
23:03:48 <adu> SamB_XP: I set the size after calculating what my OS considers a "pt" by using the dimensions of my screen, etc...
23:04:03 <adu> oddly enough, its 14pt in my debian vm, and 16pt in macosx
23:04:18 <SamB_XP> adu: oh, I just tried sizes until the squares fell on my pixels
23:04:30 <adu> i use math :)
23:04:36 <o-_-o> if I go for an interview and they tell me use any language you want, I wonder if it would be ok to use haskell
23:04:40 <SamB_XP> here, it came out to 12
23:05:20 <SamB_XP> adu: well, I didn't know enough about what windows thinks "pt" means, etc., to do it that way ;-)
23:05:27 <o-_-o> the only problem would be that the interviewer not understanding what I write
23:06:16 <Veinor> haha.
23:06:35 <adu> o-_-o: that would be a major problem imho
23:06:45 <Veinor> blah. a lot of the stuff I'm thinking of for programs to write is IOy and not really suited to Haskell
23:07:04 <o-_-o> adu, yeah, I know :-|
23:07:12 <adu> 'IOy' really? that's an adjective now?
23:07:29 <Veinor> hey, you know what I meant :D
23:07:32 <SamB_XP> adu: of course
23:07:35 <o-_-o> adu, for the past 30 or so secs
23:07:39 <adu> wow
23:07:42 <SamB_XP> that's how the language works
23:07:57 <adu> Veinor: that's going to be the next insult I use in ##c
23:08:01 <o-_-o> SamB_XP can take the credit of inventing a new word
23:08:05 <Veinor> haha
23:08:10 <SamB_XP> cannot
23:08:18 <SamB_XP> I claim the word existed already
23:08:28 <o-_-o> IO is not a word
23:08:29 <adu> Question: what's wrong with C? Answer: Its IOy.
23:08:31 <o-_-o> IOy is
23:08:31 <Veinor> but yeah, I want to write a program that notifies me whenever I get a new e-mail
23:08:34 <SamB_XP> but was just waiting for someone to (reconstruct) it from it's roots
23:08:44 <Veinor> IOy: it's missing a u :D
23:08:59 <SamB_XP> er. s/(reconstruct)/[re]construct/
23:09:01 * SamB_XP is tired
23:09:06 <adu> i like it
23:09:36 <Veinor> but I don't know whether I should plunge into working in, say, the IMAP monad or whatever, or just write the silly thing in Python and be done with it
23:09:41 <cp2> i'm in the future.
23:09:54 <Jonno_FTW> pythonesque.....
23:09:57 <SamB_XP> Veinor: there aren't already a multitude of such programs ?
23:09:58 <Jonno_FTW> is a word now you know
23:10:04 <SamB_XP> pythonic is the usual term
23:10:08 <Veinor> SamB_XP: none that use the notification method I want.
23:10:10 <o-_-o> Veinor, what OS, what mail client ?
23:10:16 <SamB_XP> Veinor: what method be that?
23:10:21 <SamB_XP> you want it should send you an email?
23:10:21 <Veinor> zephyr.
23:11:03 <Veinor> linux, gmail web interface :P
23:11:43 <adu> @quote Veinor a lot of the stuff I'm thinking of for programs to write is IOy and not really suited to Haskell.
23:11:44 <lambdabot> No quotes match. Are you on drugs?
23:11:57 <adu> @remember Veinor a lot of the stuff I'm thinking of for programs to write is IOy and not really suited to Haskell.
23:11:58 <lambdabot> I will remember.
23:12:07 <o-_-o> Veinor, why not use the pop3 interface to gmail and setup some client ?
23:12:29 <Veinor> ?
23:12:37 <ivanm> Veinor: there's heaps of gmail notifier apps available...
23:12:37 <SamB_XP> o-_-o: the IMAP one is probably far better-suited ?
23:12:48 <o-_-o> SamB_XP, ...or the IMAP
23:13:01 <SamB_XP> anyway, adapting an existing notifier is probably the best approach
23:13:05 <Veinor> yes but I want one that notifies me even if I'm on one of the school computers
23:13:25 <Veinor> and I don't feel like doing the black magic to get a notifier to autorun
23:13:45 <o-_-o> Veinor, hmmm....setup your home/dorm machine to text you :-)
23:13:58 <o-_-o> and sign up for the LKML
23:13:58 <Veinor> I'm not on a good texting plan :P
23:14:16 <o-_-o> Veinor, you pay for incoming text ?
23:14:27 <Veinor> america, whoo!
23:14:47 * SamB_XP thinks his plan has basically, er...
23:14:48 <Veinor> o-_-o: you have to understand: american telecom companies are horrible
23:14:54 <o-_-o> Veinor, what ?! seriously ?
23:14:58 <SamB_XP> > 0.3 * 0.25
23:15:00 <lambdabot>   7.5e-2
23:15:12 <Veinor> they charge you like 10 cents a text, incoming or outgoing, if it goes over your plan
23:15:16 <SamB_XP> 0.075 cents/message
23:15:29 <o-_-o> Veinor, that is ....
23:15:36 <o-_-o> I am at a loss of words
23:15:37 <Veinor> yueah.
23:15:38 <Veinor> *yeah
23:15:42 <SamB_XP> but I've got basically no monthly rate
23:15:51 <Veinor> well, I dunno if it's ten cents, but it's a nontrivial amount.
23:15:57 <matsuura> no one loves me :(
23:16:03 <Veinor> and that's even if you have an unlimited data plan
23:16:04 <matsuura> no one has said happy new years to me
23:16:10 <matsuura> out of the 376 people I know
23:16:12 <SamB_XP> I mean, if I were to stop using it for an extended period, I'd eventually need to buy a new card to extend my airtime expiry date ...
23:16:14 <matsuura> not 1 has said happy new years
23:16:16 <o-_-o> matsuura, happy new year ! :-)
23:16:22 <Veinor> happy new year :3
23:16:27 <adu> Veinor: back in my day we had to use cans and string
23:16:31 <matsuura> :D
23:16:34 <Veinor> but yeah, I feel like writing something but I don't know what
23:16:43 <SamB_XP> of course, the 0.25/minute figure was estimated by me
23:16:44 <adu> Veinor: write a Yi module
23:16:56 <adu> Veinor: or implement SVG fonts in mozilla
23:17:01 <o-_-o> Veinor, do you pay for incoming calls ?
23:17:14 <SamB_XP> and I could get a card to halve that ...
23:17:18 * o-_-o shudders waiting for the answer
23:17:23 <SamB_XP> but that only works as long as I have *this* card
23:17:27 <Veinor> o-_-o: I don't know the specifics of my plan, I don't use my phone as a phone much
23:17:29 <SamB_XP> o-_-o: you *don't* ?
23:17:36 <Veinor> just as a portable internet machine
23:17:43 <o-_-o> SamB_XP, I didn't even know that was legal
23:18:01 <o-_-o> SamB_XP, I live in India, where the competition is insane
23:18:08 <SamB_XP> huh
23:18:14 <o-_-o> SamB_XP, everyone and their dog has a cell phone
23:18:24 <SamB_XP> what does a dog do with a cell phone ?
23:18:27 <Veinor> the one bonus of paying for incoming texts is that it means there's no text spam
23:18:38 <SamB_XP> true
23:18:38 <Veinor> because it's illegal and has a $500 per message fine
23:18:38 <o-_-o> SamB_XP, because it is cheap :-)
23:18:52 <SamB_XP> I do love that I get no text spams
23:19:19 <SamB_XP> the closest to text spam I get is no-charge promotional texts about offers for cheaper airtime cards ;-)
23:19:31 <o-_-o> SamB_XP, my sister is on a plan where outgoing call to anywhere in the country is like 2.5 cents/sec
23:19:45 <Veinor> I don't even get those, I just get 'hey you're not in the USA, you'll get charged $20/MB data"
23:19:49 <matsuura> wtf
23:19:55 <matsuura> 2.5/sec
23:19:56 <matsuura> hahaha
23:20:03 <matsuura> that's outrageous
23:20:13 <SamB_XP> matsuura: I pay more ;-P
23:20:20 <SamB_XP> > 25/60.0
23:20:21 <lambdabot>   0.4166666666666667
23:20:23 <matsuura> D:!!!
23:20:34 <SamB_XP> no, wait, I pay less
23:20:44 <SamB_XP> I can't keep track of orders of magnitude
23:20:51 <o-_-o> matsuura, sorry .5 cents/sec
23:20:54 <Veinor> darn those powers of ten
23:21:09 <matsuura> skype ftw
23:21:11 <Veinor> and factors of 5
23:21:24 <Veinor> matsuura: true story: AT&T wouldn't allow the skype iphone app to go over 3G
23:21:38 <Veinor> because it would cut into their precious profits
23:21:40 <matsuura> wtf
23:21:42 <o-_-o> matsuura, yeah, skype might be cheaper but we don't have skype here
23:21:52 <matsuura> uh, get it?
23:21:57 <Veinor> I don't remember whether they relented
23:22:03 <o-_-o> matsuura, it is illegal :-)
23:22:13 <ivanm> you can use it over wireless though, can't you?
23:22:22 <o-_-o> skype cannot make calls to any phone numbers at all
23:22:35 <Veinor> yeah, over wireless
23:22:40 <o-_-o> ivanm, only skype on computer to skype on another computer
23:22:50 <ivanm> o-_-o: right
23:22:55 <ivanm> but who actually pays for skype?
23:22:58 <SamB_XP> the 25 cents/minute rate is what I calculated, anyway ...
23:22:58 <o-_-o> no skype to another cell phone
23:22:59 <ivanm> there's cheaper voip options
23:23:01 <matsuura> o-_-o: no way
23:23:09 <o-_-o> matsuura, :-)
23:23:44 <o-_-o> we can pretty much use skype as voice chat only here
23:27:09 <Jonno_FTW> @src sort
23:27:09 <lambdabot> sort = sortBy compare
23:27:43 <Jonno_FTW> @src sortBy
23:27:44 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
23:28:20 <Jonno_FTW> @src insertBy
23:28:20 <lambdabot> insertBy _   x [] = [x]
23:28:20 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
23:28:20 <lambdabot>                                  GT -> y : insertBy cmp x ys'
23:28:20 <lambdabot>                                  _  -> x : ys
23:31:51 <kmc> HAPPY NEW YEAR
23:31:57 * kmc drvnk
23:32:06 <Jonno_FTW> that was 18 hours ago kmc
23:32:13 <kmc> what eva
23:32:23 <DarthShrine> Jonno_FTW: ftw.
23:32:36 <Jonno_FTW> \n/
23:32:40 <kmc> 8====D
23:32:44 <kmc> sorry
23:32:46 * kmc drvnk
23:33:22 * adu is drvnk 2
23:34:12 * Jonno_FTW was drunk
23:35:06 * mreh just woke up from being drunk at 7am
23:35:21 <mreh> i wasn't drunk at 7am
23:35:54 <SamB_XP> I was just thinking of asking about that ;-P
23:36:00 <SamB_XP> in an obnoxious manner
23:36:37 <kmc> drinking is the hangover cure
23:36:44 <mreh> yeah baby
23:38:20 <mreh> how does "guard" work
23:38:33 <mreh> :t guard
23:38:34 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
23:38:36 <copumpkin> > guard False : [a]
23:38:37 <lambdabot>   Couldn't match expected type `m ()'
23:38:37 <lambdabot>         against inferred type `SimpleRe...
23:38:42 <copumpkin> > guard False : [()]
23:38:43 <lambdabot>   Couldn't match expected type `m ()' against inferred type `()'
23:38:47 <copumpkin> > guard False :: [()]
23:38:48 <lambdabot>   []
23:39:02 <copumpkin> > [] >> [1,2,3]
23:39:03 <lambdabot>   []
23:39:09 <copumpkin> > [1,2,3] >> []
23:39:10 <lambdabot>   []
23:39:15 <copumpkin> ^
23:39:20 <Jonno_FTW> @src gaurd
23:39:20 <lambdabot> Source not found. Where did you learn to type?
23:39:28 <Jonno_FTW> @src gaurd
23:39:28 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:39:36 <mreh> i think what I meant to say was, I don't understand list monad properly
23:39:36 <Jonno_FTW> @src guard
23:39:37 <lambdabot> guard True  =  return ()
23:39:37 <lambdabot> guard False =  mzero
23:39:48 <Jonno_FTW> @src mzero
23:39:48 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
23:40:01 <mreh> [] is mzero for []
23:40:07 <mreh> that's rather confusing
23:42:10 <Veinor> Larry: The Thinking Man's Stooge.
23:43:07 <kmc> @src (>>=) []
23:43:07 <lambdabot> Source not found. I am sorry.
23:43:11 <kmc> @src [] (>>=)
23:43:12 <lambdabot> xs >>= f     = concatMap f xs
23:43:20 <kmc> ^^^^^ list monad mothafukkas
23:43:53 <Veinor> @src [] mappend
23:43:53 <lambdabot> Source not found. :(
23:44:01 <kmc> @src mappend []
23:44:01 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:44:05 <kmc> @src (++)
23:44:06 <lambdabot> []     ++ ys = ys
23:44:06 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
23:44:06 <lambdabot> -- OR
23:44:06 <lambdabot> xs ++ ys = foldr (:) ys xs
23:44:49 <mreh> right, I understand list monad now, now I need to "takeWhile the sum of the list is less than x", I think like kinky sex games, some zips are in order
23:45:05 <Veinor>  I think like kinky sex games, some zips are in order
23:45:06 <Veinor> ahahahaha
23:45:23 <Veinor> @quote mreh right, I understand list monad now, now I need to "takeWhile the sum of the list is less than x", I think like kinky sex games, some zips are in order
23:45:23 <lambdabot> No quotes for this person. I am sorry.
23:45:34 <Veinor> @quote remember mreh right, I understand list monad now, now I need to "takeWhile the sum of the list is less than x", I think like kinky sex games, some zips are in order
23:45:34 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
23:45:37 <Veinor> ffff
23:45:38 <mreh> @remember
23:45:38 <lambdabot> Incorrect arguments to quote
23:45:41 <Veinor> I'm not drunk, I swear
23:45:46 <Veinor> @remember mreh right, I understand list monad now, now I need to "takeWhile the sum of the list is less than x", I think like kinky sex games, some zips are in order
23:45:46 <lambdabot> Nice!
23:45:50 <kmc> lrlrrrrrrrrr
23:45:56 <Twey> I'm not swear, I drunk!
23:46:01 <mreh> drunk? who's drunk?!
23:46:07 * kmc .
23:46:45 <mreh> @remember Veinor I'm not drunk, I swear. (NYE 2009)
23:46:46 <lambdabot> Nice!
23:47:14 <kmc> it's not NYE anymore
23:47:17 <kmc> it's NYD
23:47:28 <mreh> not everywhere!!
23:47:39 <kmc> fuk evyrwhere
23:47:50 <Veinor> I haven't even had any alcoholic drinks!
23:48:07 <mreh> ...officer
23:48:19 <Jonno_FTW> get the tazer
23:50:41 <mreh> > zip [1..] (scanl1 (+) [1..])
23:50:43 <lambdabot>   [(1,1),(2,3),(3,6),(4,10),(5,15),(6,21),(7,28),(8,36),(9,45),(10,55),(11,66...
23:52:43 <mreh> > (\xs -> map fst . takeWhile ((<= 10) snd) . zip xs $ (scanl1 (+) xs)) [1..]
23:52:44 <lambdabot>   Couldn't match expected type `(a, b) -> GHC.Bool.Bool'
23:52:44 <lambdabot>         against infe...
23:52:54 <mreh> > (\xs -> map fst . takeWhile ((<= 10) . snd) . zip xs $ (scanl1 (+) xs)) [1..]
23:52:55 <lambdabot>   [1,2,3,4]
23:53:05 <mreh> verbose
23:53:25 <Cale> @let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes
23:53:26 <lambdabot>  <local>:24:0:
23:53:26 <lambdabot>      Multiple declarations of `L.primes'
23:53:26 <lambdabot>      Declared at: <lo...
23:53:34 <Cale> blah :)
23:53:43 <Cale> @undefine
23:53:45 <Cale> @let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes
23:53:46 <lambdabot>  Defined.
23:54:04 <Cale> scanl (+) 0 primes
23:54:06 <Cale> > scanl (+) 0 primes
23:54:07 <lambdabot>   [0,2,5,10,17,28,41,58,77,100,129,160,197,238,281,328,381,440,501,568,639,71...
23:54:24 <mreh> > scanl1 (+) primes
23:54:25 <lambdabot>   [2,5,10,17,28,41,58,77,100,129,160,197,238,281,328,381,440,501,568,639,712,...
23:55:06 <mreh> @pl (\xs -> map fst . takeWhile ((<= 10) . snd) . zip xs $ (scanl1 (+) xs))
23:55:06 <lambdabot> liftM2 ((map fst . takeWhile ((<= 10) . snd)) .) zip (scanl1 (+))
23:55:38 <mreh> gah!
23:56:18 <mreh> @pl xs -> zip xs $ (scanl1 (+) xs))
23:56:19 <lambdabot> (line 1, column 4):
23:56:19 <lambdabot> unexpected ">" or "-"
23:56:19 <lambdabot> expecting variable, "(", operator or end of input
23:56:22 <mreh> @pl xs -> zip xs $ (scanl1 (+) xs)
23:56:22 <lambdabot> (line 1, column 4):
23:56:22 <lambdabot> unexpected ">" or "-"
23:56:22 <lambdabot> expecting variable, "(", operator or end of input
23:56:36 <mreh> @pl (xs -> zip xs $ (scanl1 (+) xs))
23:56:36 <lambdabot> (line 1, column 5):
23:56:36 <lambdabot> unexpected ">"
23:56:36 <lambdabot> expecting variable, "(", operator or ")"
23:56:47 <mreh> @pl (\xs -> zip xs $ (scanl1 (+) xs))
23:56:47 <lambdabot> ap zip (scanl1 (+))
23:56:53 <mreh> :t ap
23:56:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:58:39 <mreh> wut monad is that?
