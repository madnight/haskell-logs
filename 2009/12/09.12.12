00:00:15 <Twey> manju_: It should be included with your distro package, I think
00:00:40 <Twey> Check /usr/share/doc/ghc/libraries/index.html
00:08:10 <HaskellLove> is there a book talking about computer architecture for functional languages?
00:08:27 <Twey> Not as far as I'm aware
00:08:31 <Twey> There are some interesting papers, though
00:11:34 <manju_> If I have a function like blah (x:xs), how do I check that the input list in empty ?
00:12:59 <emile_m> manju_: Your pattern already implies non-empty list.
00:13:01 <eivuokko> blah [] =... ;  blah (x:xs) = ...
00:13:08 <lvh> manju_: create a different pattern
00:13:31 <manju_> ah...ok
00:14:25 <Axman6> HaskellLove: could always look into lisp machines
00:24:25 <HaskellLove> what is this "otherwise" thing with guards isnt it same as "else"?
00:26:46 <Axman6> @src otherwise
00:26:46 <lambdabot> otherwise = True
00:27:02 <Axman6> HaskellLove: ^^^^^
00:27:15 <Jafet> else is a keyword, huh
00:27:17 <Jafet> @src else
00:27:17 <lambdabot> Source not found. I feel much better now.
00:27:21 <Axman6> it just makes code nicer to read than seeing | True = blah
00:28:15 <HaskellLove> always True, oh i see so it is like default case in case switch statements. got it..
00:28:25 <Axman6> surt of
00:28:28 <Axman6> sort*
00:30:01 <Jafet> Hrm
00:30:44 <Jafet> > let otherwise = False in case 1 of otherwise -> 0; 1 -> 1
00:30:45 <lambdabot>   0
00:32:04 <|Jedai|> Jafet: that probably don't work as you thought it would
00:32:16 <MarcWeber> dcolish: If you mark a package as deprecated or superseded will it still show up in the hackage index file?
00:32:29 <MarcWeber> @ dcoutts
00:32:44 <Jafet> No, it probably didn't.
00:33:07 <|Jedai|> Jafet: since here "otherwise" is not in a guard but a pattern, as such it will just create a new otherwise binding shadowing the one you just defined in the let which himself was shadowing the global otherwise = True
00:33:32 <Jafet> Interesting
00:33:35 <|Jedai|> let otherwise = False in case 1 of 1 | otherwise -> 0; 1 -> 1
00:33:40 <|Jedai|> >  let otherwise = False in case 1 of 1 | otherwise -> 0; 1 -> 1
00:33:41 <lambdabot>   1
00:34:32 <|Jedai|> > let otherwise = False in case 1 of otherwise -> otherwise; 1 -> 2
00:34:33 <lambdabot>   1
00:36:53 <HaskellLove> confusing ninja stuff going on... i will cover my eyes for now
00:37:49 <|Jedai|> HaskellLove: so did you manage to do the 11th euler problem in Haskell ?
00:38:54 <HaskellLove> |Jedai|> I paused it i read book on func programming now and will watch some eric mayer lectures again today
00:42:50 <medfly> meijer
00:52:02 <Beelsebob> So, the haskeline package won't build on open solaris because it needs a libiconv (which is part of libc on open solaris)
00:52:13 <Beelsebob> but looking at the cabal file, it explicitly says *not* to link against libiconv
00:52:19 <Beelsebob> what am I missing about how this is built?
00:53:06 <Kim^Walkman> @src otherwise
00:53:06 <lambdabot> otherwise = True
00:53:10 <Kim^Walkman> HaskellLove
00:53:18 <Kim^Walkman> There's your answer :)
00:53:35 <Beelsebob> the Setup.hs file even has a check to see whether to build with -liconv
00:53:40 <Beelsebob> but it apparently never gets run
00:55:53 <Beelsebob> argh more wtf
00:56:03 <Beelsebob> haskeline requires utf8-string 0.3.6
00:56:05 <Beelsebob> which isn't in hackage
00:56:09 <Beelsebob> >.<
00:56:45 <Saizan> it is
00:56:49 <Beelsebob> oh, so it is
00:57:11 <Beelsebob> oh fail, I forgot to cabal update
00:57:12 <Beelsebob> >.<
00:58:06 <Craig`> hey again :)
00:58:38 <Craig`> my internet is going slow, like 15kB/s, so I left it to install ghc etc, but it failed half way through, so I have to restart :/ it's soo much easier to install on windows :/
01:02:10 <mk64ftw> Craig`: as opposed to?
01:02:21 <Craig`> ubuntu imo
01:02:30 <|Jedai|> Craig`: I fail to see how it is any easier to "search for the Haskell platform, download the installer then execute it" than to type "sudo apt-get install ghc6" or equivalently type ghc in an appropriate GUI search box and click on it to install it
01:02:53 <|Jedai|> In fact I would say that the second option is much easier
01:02:53 <bnijk_> is BONUS in here
01:03:03 <Twey> No
01:03:08 <Twey> You'll have to settle for BONUS_
01:03:19 <bnijk_> BONUS i've come to award you the bnijk scholarship for quirky web design with relation to haskell
01:03:19 <Berengal> Twey: I've got both of them in my list...
01:03:20 <Craig`> by easier I meant that windows download is much less in size, and I ran sudo apt-get install ghc
01:03:24 <|Jedai|> Twey: BONUS is here too :)
01:03:28 <Twey> Oh yes
01:03:29 <Twey> Haha
01:03:41 * hackagebot upload: interlude 0.1.2 - Replaces some Prelude functions for enhanced error reporting (KetilMalde)
01:03:45 <bnijk_> you receive a used toothpick in the mail every october, for half a year, starting now
01:04:01 <Twey> *scratches head*
01:04:02 <Craig`> oh yes! it didn't restart
01:04:15 <Twey> Is this meant to be a reward or a punishment?  :þ
01:04:24 <|Jedai|> Craig`: I somehow doubt that... The difference can't be much significant. Any perceived difference on your side may be due to internet connexion problems though
01:04:37 <bnijk_> kind of both
01:05:05 <Craig`> I'll just stop talking, I've kinda made it apparent that I'm a noob
01:05:20 <mk64ftw> Craig`: might want to check your mirrors in /etc/apt/sources.list and see that they are good for your location...
01:05:23 <bnijk_> everybody in this room except for the haskell devs is a noob Craig`
01:06:05 <Twey> But everybody is a Haskell dev :þ
01:06:17 <bnijk_> how do you type that character
01:06:21 <mk64ftw> => everybody is a noob :O
01:07:24 <|Jedai|> Craig`: I don't think it has much to do with being a noob, and more to do with an interrupted download which would make anyone cranky anyway :)
01:07:25 <bnijk_> haskell scares the hell out of me
01:08:49 <|Jedai|> bnijk_: No reason it should, it's just a little bit mind blowing from time to time
01:09:12 <bnijk_> that is it
01:09:28 <mk64ftw> i don't understand why people put haskell on a pedastal like this to be honest
01:09:41 <mk64ftw> every language has its mindblowing features, haskells are just more apparent
01:09:55 <Twey> I don't really agree
01:09:56 <bnijk_> i think haskell's got more of em mk64ftw
01:10:09 <mk64ftw> then i think you don't have enough experience in other languages...
01:10:17 <bnijk_> :t (==)
01:10:18 <mk64ftw> c++ has blown my mind many a time
01:10:21 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:10:33 <bnijk_> c++ is boring
01:10:42 <Twey> About 80% of the current programming languages are basically the same as another language with different syntax
01:10:49 <Craig`> yes, I've got ghci! haskell time :D
01:10:57 <medfly> you mean a different programming languages with the same syntax
01:10:59 <Twey> C++ is indeed mind-blowing, but in a much less positive way :þ
01:11:40 <bnijk_> C++ is like vegan pizza
01:11:49 <bnijk_> if you didn't want the cheese and the gluten...why did you order a pizza
01:12:01 <medfly> gluten?
01:12:11 <bnijk_> ok forget the gluten
01:12:11 <medfly> do vegans have a problem with gluten?
01:12:16 <bnijk_> some vegans do
01:12:16 <mk64ftw> *sigh* ok
01:13:04 <Twey> Personally I'd liken it to a turbaconducken pizza pie deep-friend and marinaded in fat for good measure, and then left out in the sun to ripen for a week or so
01:13:07 <mk64ftw> what in the world is gluten?
01:13:11 <Twey> deep-fried**
01:13:28 <medfly> mk64ftw, that stuff in some flours'
01:13:28 <bnijk_> what is turbaconducken?
01:13:47 <bnijk_> gluten is what happens to the starch when you knead bread dough
01:13:49 <Cale> Presumably similar to turducken, but with bacon
01:13:51 <c_wraith> gluten is the protien formed by mixing flour and water.  it's what makes gives bread its fibrous structure
01:13:57 <medfly> mk64ftw, some people claim it's related to really awkward diseases and they're so much better without it
01:14:01 <Twey> bnijk_: A chicken, inside a duck, inside a turkey, with bacon.
01:14:07 <bnijk_> hot damn Twey
01:14:16 <bnijk_> where does the bacon go
01:14:28 <Twey> On the outside, last I saw, but I imagine you can just stuff it anywhere
01:14:28 <medfly> I guess they make a bacon mat to cover the whole thing
01:14:34 <Twey> Yeah
01:14:38 <medfly> c_wraith, it isn't IN flour?
01:14:47 <bnijk_> > "medfly" > "c_wraith"
01:14:48 <lambdabot>   True
01:15:00 <Twey> It also has the dubious honour of looking like a headcrab
01:15:04 <Twey> http://neatorama.cachefly.net/misscellania/450turbaconducken.jpg
01:15:05 <bnijk_> it is in flour
01:15:11 <bnijk_> but you have to knead it to get more ;)
01:15:13 <Craig`>  > putStrLn "Craig`"
01:15:22 <Twey> Craig`: <IO ()>
01:16:28 <medfly> duuuuude.
01:16:39 <Twey> Truly.
01:17:08 <|Jedai|> Craig`: for obvious reason IO is not available on lambdadot, so they just replaced it by a dummy that just print the type it would have
01:17:13 <bnijk_> > read "c_wraith" :: [Char]
01:17:15 <lambdabot>   "* Exception: Prelude.read: no parse
01:17:29 <Twey> That's misleading, |Jedai|
01:17:31 <bnijk_> oh ho ho
01:17:39 <Twey> IO is available
01:17:47 <bnijk_> > map succ "c_wraith"
01:17:48 <lambdabot>   "d`xsbjui"
01:17:52 <Twey> It just doesn't get executed
01:18:02 <|Jedai|> Twey: Ok, it's not the same IO as in GHC though
01:18:13 <Twey> > read "\"c_wraith\"" :: [Char]
01:18:14 <lambdabot>   "c_wraith"
01:18:21 <Twey> Strings need quotes ☺
01:18:27 <Twey> |Jedai|: It isn't?
01:18:33 <Twey> |Jedai|: How's that?
01:18:42 <bnijk_> > map (succ . succ . pred) "c_wraith"
01:18:43 <lambdabot>   "d`xsbjui"
01:18:45 <Twey> Apart from the added Show instance
01:18:46 * hackagebot upload: filestore 0.3.4 - Interface for versioning file stores. (JohnMacFarlane)
01:18:51 <Cale> Hey, isn't "d`xsbjui" a lojban word? ;)
01:19:04 <Twey> No :þ
01:19:07 <bnijk_> ^ is that john cale
01:19:14 <Cale> Huh?
01:19:16 <Twey> ‘Cale’ is two, though!
01:19:17 <bnijk_> tell him i love his work in the velvet underground
01:19:23 <Cale> My name is Cale Gibbard
01:19:30 <bnijk_> i know who you are
01:19:41 <bnijk_> > maxBound :: Char
01:19:42 <lambdabot>   '\1114111'
01:19:45 <medfly> his first name is Cale, not his last name :3
01:19:57 <|Jedai|> Twey: oh ok, you just put a additional Show instance on the standard IO stuff ? I though that you replaced it by a dummy type altogether (well I guess it isn't necessary).
01:20:08 <Twey> |Jedai|: I didn't do anything to it.  :þ
01:20:18 <Twey> But no, it's the real IO as far as I know.
01:20:28 <bnijk_> > reverse "Cale"
01:20:29 <lambdabot>   "elaC"
01:20:35 <bnijk_> > flip "Cale"
01:20:36 <lambdabot>   Couldn't match expected type `a -> b'
01:20:36 <lambdabot>         against inferred type `GHC.Ty...
01:20:42 <|Jedai|> Twey: There was once a discussion on replacing it by IOSpec, the IO simulation monad
01:20:43 <mauke> ǝןɐɔ
01:20:51 <Cale> |Jedai|: Yeah, it's the real IO type, it just skips the step where it executes the IO action.
01:20:52 <bnijk_> mauke is that an irssi plugin
01:20:56 <mauke> bnijk_: yes
01:21:02 <bnijk_> do you have 'rsay' too
01:21:21 <|Jedai|> Cale: Right, that makes sense, I was just confused ^^
01:21:31 <bnijk_> > fromIntegral (length "Cale") + 12
01:21:32 <lambdabot>   16
01:21:37 <Twey> IOSpec is scary
01:21:38 <mauke> bnijk_: what's that?
01:21:43 <bnijk_> rainbow say
01:21:49 <bnijk_> it turns your text rainbow colored
01:21:56 <Twey> Yeesh
01:21:59 <mauke> 9/li1/ke5/ t=/hi</s?g
01:22:03 <bnijk_> like that
01:22:07 <bnijk_> more colorful though
01:22:13 <|Jedai|> Twey: I kind of like it
01:22:14 <Veinor> like this?
01:22:20 <mauke> Veinor: no, we're +c
01:22:20 <Veinor> or this?
01:22:32 <Veinor> mauke: really? cause I saw your colors just fine
01:22:39 <mauke> yes, I have magic powers
01:22:43 <Veinor> ah :o
01:22:43 <Twey> Those are irssi colours
01:22:45 <mauke> continue in #haskell-blah?
01:22:49 <Twey> They're magic :þ
01:22:50 <Twey> Heh
01:22:57 * Twey goes to get food, instead.
01:23:18 <bnijk_> > isItCale :: (String a) => a -> String; isItCale "Cale" = "It's Cale!"; isItCale x = "It's not Cale!"
01:23:20 <lambdabot>   <no location info>: parse error on input `;'
01:23:25 <medfly> lol
01:23:27 <bnijk_> feh...how do i do line breaks
01:24:12 <medfly> I think you need to use @let
01:24:21 <bnijk_> @let isItCale :: (String a) => a -> String; isItCale "Cale" = "It's Cale!"; isItCale x = "It's not Cale!"
01:24:22 <lambdabot>  <local>:2:12:
01:24:22 <lambdabot>      Type constructor `String' used as a class
01:24:22 <lambdabot>      In the typ...
01:24:29 <bnijk_> @more
01:24:37 <bnijk_> alright, i give up
01:24:49 <paper_cc> bnijk: simply no polymorphic strings in lambdabot
01:25:12 <paper_cc> @let isItCale :: String -> String; isItCale "Cale" = "It's Cale!"; isItCale x = "It's not Cale!"
01:25:13 <lambdabot>  Defined.
01:25:20 <paper_cc> > isItCale "Cale"
01:25:21 <lambdabot>   "It's Cale!"
01:25:22 <bnijk_> > isItCale "Cale?"
01:25:23 <lambdabot>   "It's not Cale!"
01:25:29 <bnijk_> ;)
01:25:34 <bnijk_> > isItCale "Cale!"
01:25:35 <lambdabot>   "It's not Cale!"
01:25:50 <|Jedai|> @let isItCale :: (IsString a) => a -> String; isItCale "Cale" = "It's Cale!"; isItCale x = "It's not Cale!"
01:25:51 <lambdabot>  <local>:3:0:
01:25:51 <lambdabot>      Duplicate type signature:
01:25:51 <lambdabot>        <local>:3:0-38: isItCale ...
01:26:00 <bnijk_> @undefine
01:26:09 <|Jedai|> @let isItCale :: (IsString a) => a -> String; isItCale "Cale" = "It's Cale!"; isItCale x = "It's not Cale!"
01:26:10 <lambdabot>  <local>:1:12: Not in scope: type constructor or class `IsString'
01:26:14 <Beelsebob> I wonder if there's any plan to gain 64 bit ghc support on OS X
01:26:25 <bnijk_> is IsString valid
01:26:44 <bnijk_> i take it not
01:27:01 <|Jedai|> bnijk_: It is, but apparently not in lambdabot
01:27:27 <|Jedai|> bnijk_: it's what allows you to use the new polymorphic string literals extension in GHC
01:27:27 <aavogt> @type fromString
01:27:28 <lambdabot> Not in scope: `fromString'
01:27:40 <paper_cc> bnijk_: IsString is valid, but only with {-# LANGUAGE something #-}, and lambdabot doesn't have that enabled
01:27:45 <|Jedai|> bnijk_: it's in Data.String
01:27:58 <bnijk_> i see
01:28:13 <|Jedai|> paper_cc: Well IsString is valid even without that pragma, it just isn't very useful
01:28:45 <paper_cc> |Jedai|: isItCale won't compile without the pragma, that is
01:28:49 <benmachine> :t (GHC.Exts.IsString s) => s
01:28:50 <lambdabot> parse error on input `=>'
01:28:56 <benmachine> oh
01:28:58 <benmachine> sily me
01:29:02 <benmachine> :t undefined :: (GHC.Exts.IsString s) => s
01:29:04 <lambdabot> forall s. (Data.String.IsString s) => s
01:29:11 <benmachine> same difference.
01:29:45 <|Jedai|> paper_cc: Right, it won't (since the literal are not overloaded and so the patterns won't work for all IsString), which is why IsString isn't much use without the corresponding extension
01:30:28 <|Jedai|> @type GHC.Exts.fromString
01:30:29 <lambdabot> forall a. (Data.String.IsString a) => String -> a
01:30:44 <|Jedai|> @let isItCale :: (GHC.Exts.IsString a) => a -> String; isItCale "Cale" = "It's Cale!"; isItCale x = "It's not Cale!"
01:30:44 <lambdabot>  <local>:1:12:
01:30:44 <lambdabot>      Not in scope: type constructor or class `GHC.Exts.IsString'
01:31:06 <medfly> this should be modified every time to highlight a different person from this channel.
01:32:01 <paper_cc> ... by calling him Cale.
01:32:21 <bnijk_> @let coneArea :: (RealFloat a) => a -> a -> a; cone r h = let bottomArea = pi * r^2; conicArea = pi * sqrt(r^2+h^2) * r in bottomArea + conicArea
01:32:22 <lambdabot>  <local>:1:0:
01:32:22 <lambdabot>      The type signature for `coneArea' lacks an accompanying bi...
01:32:34 <bnijk_> bi what!
01:32:40 <benmachine> binding
01:33:05 <paper_cc> @let coneArea :: (RealFloat a) => a -> a -> a; coneArea r h = let bottomArea = pi * r^2; conicArea = pi * sqrt(r^2+h^2) * r in bottomArea + conicArea
01:33:06 <lambdabot>  Defined.
01:33:34 <Craig`> I'm staying on for quite a lot more time, what would you say would be the best way to learn a bit of hands on haskell? :)
01:33:36 <bnijk_> oh jeez
01:33:50 <bnijk_> > coneArea 1 1
01:33:52 <lambdabot>   7.584475591748159
01:34:19 <newsham> craig: write some small programs
01:34:19 <bnijk_> @let coneVolume r h = 1/3 * pi * r^2 * h
01:34:20 <lambdabot>  Defined.
01:34:26 <bnijk_> > coneVolume 1 1
01:34:27 <lambdabot>   1.0471975511965976
01:35:03 <benmachine> Craig`: implement bits of the standard library
01:35:16 <benmachine> well, I found that useful anyway
01:35:24 <paper_cc> Craig`: really, write something
01:35:50 <Craig`> paper_cc, yeah I know that programming == learning, but I was meaning, should I read bits of real world haskell, then make stuff?
01:35:55 <bnijk_> @let sphereVolume r = 4/3*pi*r^3
01:35:56 <lambdabot>  Defined.
01:36:37 <newsham> craig: that would be reasonable
01:36:40 <|Jedai|> Craig`: depends on your background ?
01:36:59 <Craig`> by that do you mean if I'm experenced with programming?
01:37:09 <|Jedai|> Craig`: Right
01:37:25 <paper_cc> (with this type of programming.)
01:37:34 <Kim^Walkman> Haskell is like starting fresh, coming from an imperative background
01:37:44 <|Jedai|> Craig`: if you are RWH is probably a good idea else LYAH is pretty good
01:37:47 <bnijk_> aren't we all Kim^Walkman
01:37:51 <medfly> ++i WHY DOESN'T THIS WORK
01:38:05 <medfly> bnijk_, no
01:38:05 <newsham> kim: more so than other languages, but still, knowing how to program is an advantage over not knowing how to program
01:38:11 <newsham> its not a complete clean slate
01:38:16 <medfly> bnijk_, some people (such as I) started out with Haskell.
01:38:17 <Kim^Walkman> True that
01:38:24 <bnijk_> @let medfly c = "WHY DOESN'T " ++ [c] ++ " WORK"
01:38:25 <lambdabot>  Defined.
01:38:31 <bnijk_> > medfly MEDFLY
01:38:32 <lambdabot>   Not in scope: data constructor `MEDFLY'
01:38:35 <bnijk_> > medfly "MEDFLY"
01:38:36 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
01:38:36 <lambdabot>         against inferred type...
01:38:37 <medfly> that's a good point
01:38:39 <medfly> why don't I work!
01:38:41 <newsham> > medfly 'X'
01:38:41 <bnijk_> ugh
01:38:42 <lambdabot>   "WHY DOESN'T X WORK"
01:38:50 <bnijk_> @undefine
01:38:57 <medfly> @let medfly c = "WHY DOESN'T " ++ c ++ " WORK"
01:38:58 <bnijk_> @let medfly c = "WHY DOESN'T " ++ c ++ " WORK"
01:38:58 <lambdabot>  Defined.
01:38:58 <newsham> c is a char
01:38:59 <lambdabot>  <local>:1:0:
01:38:59 <lambdabot>      Warning: Pattern match(es) are overlapped
01:38:59 <lambdabot>               In...
01:39:07 <bnijk_> > medfly "MEDFLY"
01:39:08 <lambdabot>   "WHY DOESN'T MEDFLY WORK"
01:39:15 <Craig`> @where LYAH
01:39:16 <lambdabot> http://www.learnyouahaskell.com/
01:40:15 <bnijk_> http://learnyouahaskell.com/bonus.png
01:40:58 <medfly> is that a portrait?
01:41:06 <bnijk_> i hope so
01:41:30 <newsham> day of the tentacle
01:41:59 <bnijk_> dott++
01:42:12 <bnijk_> http://4.bp.blogspot.com/_fkIZl8RAmtw/Sh7q0OdbmkI/AAAAAAAAAJo/OBzMOgpSQug/s400/sculpts_ultros.jpg
01:42:13 <Twey> Craig`: RWH is very sequential.  You'll struggle if you try to read it out of order.
01:42:27 <Twey> It includes practical projects (serious ones).
01:42:42 <Craig`> Twey, I'd read it in order, and then after each chapter try and apply what I'd read
01:42:55 <bnijk_> oh here it is http://www.rpgsquare.de/file/sek/screenshots/19/46/extrem/Ultros%20Lete%20River.jpg
01:43:29 <bnijk_> sorry about that
01:45:20 <Cale> Heh, good ol' Ultros
01:46:59 <mauke> wasn't he the one with the horrible puns?
01:47:34 <newsham> mauke: probably that was me ;-)
01:48:45 <mauke> http://www.encyclopediadramatica.com/Ultros (probably NSFW, but I can't see the ads)
01:50:04 <bnijk_> > sum [x | x <- [1..1000], x `mod` 3 == 0 || x `mod` 5 == 0]
01:50:05 <lambdabot>   234168
01:50:36 <bnijk_> of course there's an ED article for ultros
01:51:41 <benmachine> bnijk_: should be [1 .. 999] iirc
01:51:55 <bnijk_> oo, you're right
01:52:11 <bnijk_> well, 233168
01:58:07 <Craig`> right so you guys have told me that to learn some haskell, i just need to make some "small programs", sorry, but could someone provide me with some basic programs to make? may sound stupid, but it's for my learning purpose (those mathematical ones may be a little too advanced for the total haskell beginner imo)
01:58:34 <bnijk_> Craig`: do what i'm doing
01:58:36 <bnijk_> projecteuler.net
01:58:39 <bnijk_> > sum (map digitToInt (show (2^2000)))
01:58:40 <lambdabot>   2704
01:58:52 <osfameron> ~
01:59:09 <Craig`> even for the first one I havne't learnt enough haskell yet, bnijk_
01:59:19 <bnijk_> so ask for help
01:59:22 <bnijk_> don't be a stranger now
01:59:29 <aeter> there was a 99 problems in haskell... -> http://www.haskell.org/haskellwiki/99_Haskell_exercises
01:59:47 <Cale> Craig`: Also, have you tried tutorials such as learnyouahaskell?
01:59:52 <Cale> @where lyah
01:59:52 <lambdabot> http://www.learnyouahaskell.com/
02:00:08 <Craig`> Cale, I'm looking through it now :)
02:00:15 <newsham> craig: if you want a slower intro, try two dozen short lessons
02:00:29 <newsham> http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
02:00:35 <newsham> it will teach you about progrmaming the pure part of haskell
02:00:58 <newsham> it doesnt assume any prior programming experience
02:01:02 <bnijk_> try these too
02:01:04 <bnijk_> http://www.willamette.edu/~fruehr/454/labs/lab4.html
02:01:14 <bnijk_> can't hurt ;()
02:01:15 <newsham> and its highly exercise based
02:01:43 <cads> !seen roconnor
02:01:59 <cads> :P
02:02:56 <mauke> preflex: xseen roconnor
02:02:56 <preflex>  roconnor was last seen on freenode/#haskell 20 hours, 22 minutes and 21 seconds ago, saying: > pred 0 :: Natural
02:03:27 <mauke> preflex: xseen dpiponi
02:03:27 <preflex>  dpiponi was last seen on freenode/#haskell 2 days, 21 hours, 53 minutes and 23 seconds ago, saying: I should read more blogs then! Though if they're literate haskell I always understand better if I can run and tweak the code.
02:07:05 <bnijk_> > isPrime 20
02:07:06 <lambdabot>   Not in scope: `isPrime'
02:07:10 <bnijk_> damn
02:07:25 <HaskellLove> i guess when you have structures like lists of lists of lists of ... you get the idea... you use map to adress each member? any other cool ways to "index" list elements in func language like sweet haskell?
02:08:08 <bnijk_> HaskellLove: get a room!
02:08:22 <Gilly> > [1,2,3] !! 2
02:08:23 <lambdabot>   3
02:08:28 <newsham> > 20 `elem` takeWhile (<= 20) primes
02:08:30 <lambdabot>   False
02:08:59 <bnijk_> what's a really simple prime number tester
02:09:09 <HaskellLove> sometimes it comes to doing map . map . map crazy stuff... and i like map more then !!, u guys?
02:09:17 <paper_cc> HaskellLove: there's the index operator (!!) :: [a] -> Int -> a, but you probably want to use arrays (Data.Array), because (!!) takes linear time
02:09:21 <paper_cc> :t (!)
02:09:22 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
02:09:39 <paper_cc> for arrays, (!) takes constant time
02:09:47 <Gilly> HaskellLove: map and (!!) are not really comparable
02:10:06 <HaskellLove> Gilly, yes but they can be used to index stuff
02:10:09 <newsham> bnijk: my above example seems pretty simple to me
02:10:22 <inclement> What's an easy way to test if every element of a list is itself the empty list. Specifically, to test if ["","","","",...,""] is a list of empty strings?
02:10:25 <bnijk_> ah, found one
02:10:28 <bnijk_> @let isPrime :: Integral a => a -> Bool
02:10:28 <lambdabot>  <local>:3:0:
02:10:28 <Gilly> HaskellLove: how do you index stuff with map?
02:10:28 <lambdabot>      The type signature for `isPrime' lacks an accompanying bin...
02:10:36 <xerox> inclement: all null
02:10:37 <bnijk_> @let isPrime :: Integral a => a -> Bool; isPrime p = p > 1 && (all (\n -> p `mod` n /= 0 ) $ takeWhile (\n -> n*n <= p) [2..])
02:10:38 <lambdabot>  Defined.
02:10:42 <HaskellLove> Gilly: for example map . map . map is equal to applying !! three times or so
02:10:47 <HaskellLove> u get the idea
02:10:48 <sproingie> in some vague sense a map can replace !! in that you generate values on demand instead of indexing them randomly
02:10:48 <qwr> inclement: all (== "")
02:10:49 <paper_cc> @t all null
02:10:49 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
02:10:54 <paper_cc> HaskellLove: no
02:10:56 <sproingie> which is The Right Idea
02:10:57 <inclement> Ah, all. Thanks very much
02:10:57 <paper_cc> @ty all null
02:10:58 <lambdabot> forall a. [[a]] -> Bool
02:10:59 <Gilly> HaskellLove: i don't think so :)
02:11:04 <bnijk_> > sum (x|x<-[1..1999999],isPrime x)
02:11:05 <lambdabot>   <no location info>: parse error on input `|'
02:11:16 <paper_cc> > sum [x|x<-[1..1999999],isPrime x]
02:11:19 <lambdabot>   mueval-core: Time limit exceeded
02:11:37 <paper_cc> > sum $ takeWhile (<= 1999999) primes
02:11:38 <bnijk_> i'm making a lot of stupid syntax errors today
02:11:41 <lambdabot>   mueval-core: Time limit exceeded
02:11:45 <paper_cc> =(
02:11:53 <paper_cc> > sum $ takeWhile (<= 19999) primes
02:11:57 <lambdabot>   mueval-core: Time limit exceeded
02:12:10 <sproingie> must be a seriously brute force primes
02:12:18 <paper_cc> @src primes
02:12:18 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:12:29 <c_wraith> which is sad when there's
02:12:32 <bnijk_> feh
02:12:32 <newsham>  ?let primes = nubBy (\x y -> x `mod` y == 0) [2..]
02:12:53 <EvanR> how do i make a global variable *hides*
02:12:55 <paper_cc> , sum $ takeWhile (<= 19999) primes
02:12:57 <lunabot>  luna: Not in scope: `primes'
02:13:05 <paper_cc> > sum $ takeWhile (<= 19999) primes
02:13:09 <lambdabot>   mueval-core: Time limit exceeded
02:13:17 <sioraiocht> EvanR: you can use an MVar, but chances are if you are using a global variable, you are doing it wrong
02:13:40 <sioraiocht> EvanR: there are always better ways to do things than that, you can use the State Monad, for example
02:14:02 <HaskellLove> Gilly i do man, check this out for example: a = [[[1,2],[3,4]], [[5,6],[7,8]]] you can say: map . map f is same as: apply function to !! 0 a, and then apply function to !! 0 of (!! 0 of a) ... get it?
02:14:02 <bnijk_> > sum (map digitToInt(show (foldr (*) 1 [1..100])))
02:14:04 <lambdabot>   648
02:14:07 <EvanR> well, i create a generator in a do expression somewhere, then later in the program i want to use the generator, i guess i could pass it around...
02:14:08 <monochrom> You make a global variable *hide* by erasing it from source code. :)
02:14:13 <Craig`> newsham, thanks, I'm liking two dozen :)
02:14:19 <newsham> yw.
02:14:26 <paper_cc> EvanR: you could pass it around in a Reader
02:14:32 <sproingie> Chans are also good for passing stuff arond
02:14:50 <EvanR> i really need to figure out how to use these Reader / State thingies
02:15:11 <sioraiocht> EvanR: using them is really easy
02:15:17 <EvanR> i assume Writer would be useful to get debug info from a function? i notice that runtime errors give precious little info
02:15:19 <sioraiocht> esp if you aren't fussed about knowing HOW they work
02:15:23 <paper_cc> EvanR: see All about monads
02:15:33 <bnijk_> @let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
02:15:34 <lambdabot>  Defined.
02:15:35 <HaskellLove> will someone check my last post here and tell me how cool that is?
02:15:46 <bnijk_> hmm
02:15:59 <sioraiocht> EvanR: depends on the function.
02:16:05 <newsham> evanr: Debug.Trace is useful for adding some more info
02:16:20 <newsham> better is to not make mistakes ;-)
02:16:21 <EvanR> just a line number would be nice
02:16:29 <bnijk_> > first [x|x<-fib [1..],length x == 1000]
02:16:30 <lambdabot>   Couldn't match expected type `a b c' against inferred type `[a1]'
02:16:33 <newsham> there's a debugger in ghci
02:16:40 <newsham> which could help
02:17:35 <bnijk_> this is tricky
02:17:43 <EvanR> the tutorials always seem to show examples that are very simple, like 'suppose you have two functions which use a state', but in real life i have main and its more complex...
02:18:00 <EvanR> IO is floating around...
02:18:02 <HaskellLove> Gilly I got u man haha damn i am good, and u thought they are not similar in a way, I am advancing in Haskell yeiiii
02:18:03 <Craig`> haskell isn't a speed demon though is it?
02:18:07 <bnijk_> > ([x|x<-(map fib [1..1000000]),length x == 1000])
02:18:08 <lambdabot>   No instance for (GHC.Num.Num [a])
02:18:08 <lambdabot>    arising from a use of `L.fib' at <inte...
02:18:16 <bnijk_> > fib 12
02:18:17 <lambdabot>   144
02:18:19 <sproingie> HaskellLove: what's even cooler is fmap.fmap
02:18:19 <mauke> Craig`: haskell has no speed, it's a language
02:18:21 <bnijk_> what's the deal with this?
02:18:23 <newsham> evanr: as much as possible you should strive for small and simple functions in functional programming
02:18:23 <HaskellLove> Craig` haskell is a ninja man
02:18:33 <newsham> you can make lots of functions if you need more complexity
02:18:33 <sproingie> HaskellLove: that'll dive into arbitrary functors, not just lists
02:18:41 <opqdonut> ?quote fmap fmap fmap
02:18:42 <lambdabot> No quotes for this person. My pet ferret can type better than you!
02:18:43 <sproingie> HaskellLove: and it'll work exactly the same on lists
02:18:53 <Craig`> I mean, finding the result of "small paws" takes 0.158s, whereas in ruby it takes 0.006s
02:18:54 <opqdonut> ?quote fmap.fmap.fmap
02:18:54 <lambdabot> No quotes match. You type like i drive.
02:18:56 <EvanR> newsham: i get that, but if two different functions want to use my generator of type IO Int ?
02:19:00 <opqdonut> gah, nevermind
02:19:18 <mauke> Craig`: what exactly are you comparing?
02:19:21 * bnijk_ scowls
02:19:24 <newsham> evanr: pass it as an arg?
02:19:25 <opqdonut> Craig`: what's small paws?
02:19:33 <EvanR> newsham: all the way from main?
02:19:33 <Craig`> just some text
02:19:42 <bnijk_>  ([x|x<-[1..1000000], length x == 1000])
02:19:47 <Craig`> two dozen used it as an example, heh
02:19:48 <c_wraith> EvanR:  I really don't understand why you even want that.  What it's doing can be accomplished by just having a list
02:19:54 <mauke> step 1: did you compile with -O2?
02:19:54 <newsham> evanr: *shrug* you could.  I dont really know your exact situation and I dont want to make a blanket generalization :)
02:19:59 <bnijk_> no, no
02:19:59 <mauke> step 2: what's the algorithm?
02:20:09 <EvanR> c_wraith: yes, the generator just returns the next element of a list
02:20:19 <sproingie> ruby saves a lot of time in text operations by totally ignoring unicode
02:20:30 <newsham> or you could turn the IO Int into a [Int] by generating all values (lazily) and then pass that lazy list around
02:20:36 <newsham> and let the callers chop up that list as they see fit
02:20:53 <Craig`> time ghci -e '"small paws" => 0.158s .. time ruby -e '"small paws"' => 0.006s, but any ways, I'm sure 0.152s won't make my grow old
02:20:53 <mauke> sproingie: ByteString to the rescue
02:21:00 <mauke> haha, wtf
02:21:02 <sproingie> i bet if you used ByteString haskell would be a lot faster
02:21:03 <EvanR> newsham: its an [Int] first, i made the generator an IO wrapper...
02:21:05 <newsham> or you could hide the IO Int in some structure you pass around often, or in a state monad or whatever
02:21:10 <sproingie> haskell's String type is grotesquely slow
02:21:19 <mauke> Craig`: that's the startup overhead of ghci
02:21:27 <mauke> Craig`: that has nothing to do with the performance of Haskell programs
02:21:42 <opqdonut> oh my god what a benchmark :D
02:21:45 <bnijk_> > fib (first [ x | x <- [1..1000000], (length (fib x) == 1000)]) -- why doesn't this work
02:21:46 <lambdabot>   Couldn't match expected type `a b c' against inferred type `[a1]'
02:22:01 <newsham> craig: i thought you're just learning.  why are profiling already? :)
02:22:05 <bnijk_> i don't understand where it's expecting a b c
02:22:08 <EvanR> newsham: situation... a mud server may need to generate a random number in various contexts after handling an event.
02:22:18 <newsham> ?type first
02:22:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
02:22:34 <paper_cc> @type head
02:22:34 <Twey> GHCi is not designed to be used for executing programs
02:22:35 <lambdabot> forall a. [a] -> a
02:22:37 <Twey> It's a debugging tool
02:22:42 <bnijk_> wrong function then
02:22:55 <paper_cc> > fib (head [ x | x <- [1..1000000], (length (fib x) == 1000)]) -- that should work
02:22:56 <lambdabot>   No instance for (GHC.Num.Num [a])
02:22:56 <lambdabot>    arising from a use of `L.fib' at <inte...
02:23:07 <paper_cc> though it doesn't
02:23:10 <EvanR> but yeah i need to figure out how a state monad would help
02:23:16 <Craig`> newsham, I am just learning, I just thought I'd check it out haha :)
02:23:17 <bnijk_> something's wrong with the fib definition i think
02:23:26 <newsham> evanr: there are IO actions for returning "the next random number".  You can call them from any of your IO actions, not just from main.
02:23:35 <newsham> craig: premature optimization :)
02:23:36 <paper_cc> @ty fib
02:23:37 <bnijk_> > fib 20 -- though this works
02:23:37 <lambdabot> forall t t1. (Num t, Num t1) => t -> t1
02:23:38 <lambdabot>   6765
02:23:43 <Twey> [@ twey peordh ] % echo 'main = print "small paws"' > /tmp/foo.hs
02:23:44 <Twey> [@ twey peordh ] % ghc /tmp/foo.hs -o /tmp/foo
02:23:50 <Twey> [@ twey peordh ] % time /tmp/foo
02:23:56 <Twey> /tmp/foo  0.00s user 0.00s system 0% cpu 0.002 total
02:24:06 <sproingie> EvanR: simple answer, you keep global state in some kind of MUDState object, then store that in the State part of a StateT that comprises your overall "MUD Monad"
02:24:17 <EvanR> newsham: so the 'members' of IO like getChar are like 'globals'
02:24:21 <Craig`> any ways, back to learning :)
02:24:23 <Twey> ('course, that's on my system, not yours ☺)
02:24:25 <sproingie> which is a pretty monolithic approach but it works
02:24:27 <paper_cc> bnijk: what do you mean by "length (fib x)"
02:24:28 <paper_cc> ?
02:24:33 <bnijk_> ohhh
02:24:41 <newsham> evanr: the function definitions in libraries are globally defined
02:24:45 <bnijk_> > fib (first [ x | x <- [1..1000000], (length (show (fib x)) == 1000)]) -- why doesn't this work
02:24:47 <lambdabot>   Couldn't match expected type `a b c' against inferred type `[a1]'
02:24:49 <newsham> and the top level functions in your program
02:24:49 <bnijk_> oops
02:24:52 * sproingie is trying to learn FRP which is supposed to break down localized states a little more elegantly
02:24:53 <bnijk_> > fib (head [ x | x <- [1..1000000], (length (show (fib x)) == 1000)]) -- why doesn't this work
02:24:53 <Gilly> HaskellLove: i think you are not making sense.
02:24:57 <lambdabot>   mueval-core: Time limit exceeded
02:25:02 <bnijk_> feh
02:25:03 <newsham> bnijk: you're using "first" incorrectly.  its not what you think it is
02:25:09 <bnijk_> i know i know, it's head
02:25:10 <Craig`> Twey, what os is thaat? mac?
02:25:11 <newsham> > first [1,2,3]
02:25:12 <lambdabot>   Couldn't match expected type `a b c' against inferred type `[a1]'
02:25:16 <newsham> > head [1,2,3]
02:25:17 <lambdabot>   1
02:25:23 <HaskellLove> Gilly read sproingie posts after mine
02:25:23 <Twey> Craig`: GNU…
02:25:38 <Craig`> sorry, I wasn't sure by the %.. :/
02:25:42 <bnijk_> > fib (head [ x | x <- [1..1000000], (length (show (fib x)) == 1000)]) -- now how do we make lambdabot solve this
02:25:45 <Twey> Oh
02:25:46 <lambdabot>   mueval-core: Time limit exceeded
02:25:49 <Twey> I think that's a zsh thing
02:26:05 <newsham> bnijk: when in doubt, break down the complex expression into pieces and see which piece breaks
02:26:07 <sproingie> Gilly: he was diving into lists manually with !!, now he's mapping over them instead.  doubly nested lists, ergo map.map
02:26:14 <HaskellLove> sproingie can u explain me fmap, the manual is not very clear just shows its type
02:26:15 <bnijk_> yeah newsham i understand ;)
02:26:19 <Twey> Or I might have added that myself.  I don't remember what the default zsh prompt looks like.  :þ
02:26:19 <sproingie> Gilly: not so much map replacing !! as evolving a better algorithm
02:26:35 <sproingie> HaskellLove: LYAH explains fmap in wondrous detail
02:26:41 <EvanR> newsham: yeah but i wrote this function makeRng :: Integral a => [a] -> IO a, so so far ive used the generator like do g<-makeRng []; x<-g; print x; x<-g; print x;...  would be nice if i could use g anywhere in IO... after all, i can use makeRng anywhere...
02:26:55 <Gilly> sproingie: he was claiming !! and map are equal
02:27:11 <newsham> evanr: there's already a random number generator "IO a"
02:27:15 <EvanR> i know that
02:27:17 <EvanR> but i like mine more
02:27:18 <newsham> you dont need to make makeRng
02:27:21 <newsham> ok.
02:27:29 <EvanR> it has a longer period
02:27:29 <sproingie> Gilly: well that's confused, but not what he really meant
02:27:33 <HaskellLove> LYAH ??? sproingie....
02:27:42 <sproingie> @where LYAH
02:27:42 <lambdabot> http://www.learnyouahaskell.com/
02:28:01 <Gilly> sproingie: well, he was saying he prefers map over !!, I said they are not comparable and then he started giving examples, claiming they are
02:28:02 <HaskellLove> Gilly i said equal in a context dude, not equal meaning really equal damn it
02:28:25 <newsham> evanr: ok, so you define a RNG by calling makeRng and then assign that to a global name, or pass it in as an argument to other functions, or implicitly pass it in as part of a State monad or something
02:28:30 <Gilly> HaskellLove: you still haven't said how you "index" lists with map :)
02:28:31 <HaskellLove> Gilly for the situations i gave dude, of course map and !! are not same
02:28:50 <Twey> bnijk_: It does work.  It just takes ages, because you're asking it to do lots of work.
02:28:55 <EvanR> newsham: state monad sounds right... i think my main problem is i havent connected the monad concept with the data structure concept..
02:29:16 <benmachine> bnijk_: I once wrote a thing with the Writer monad to track how many times a naive fibonacci algorithm called itself recusively
02:29:23 <Twey> (find the 1ᴇ1000+th Fibonacci number)
02:29:24 <newsham> evanr: if you know the arg to makeRng without any io, I'd just globaly define  myRng = makeRng [...the list...]
02:29:27 <sproingie> EvanR: the monad isn't itself the data structure, it's just a way of sequencing functions that pass the data structure around
02:29:37 <HaskellLove> Gilly well you dont get it do you... in functional languages you have it ALL AT ONCE not like imperative where you have it ONE AT A TIME... so for map because it operates over all elements you can compare it to index and operate... simple
02:29:37 <newsham> then you can just access "myRng" directly in any of your IO actions
02:29:38 <Gilly> HaskellLove: well, if you have just discovered that instead of doing n times (!!) + some magic you can simply map, congratulations to you
02:29:52 <Twey> And lambdabot doesn't like being hung up for hours at a time doing someone's calculation.  :þ
02:29:54 <benmachine> if I am using it correctly then it seems calculating the 20th fibonacci number is taking nearly 1100 function calls
02:29:55 <bnijk_> oic
02:29:56 <EvanR> newsham: the arg would be read from a file or [] if starting over the sequence
02:29:59 <benmachine> er, 11000
02:30:06 <HaskellLove> Gilly haha i knew that son, you did not it took u  all these posts to ask
02:30:09 <benmachine> it doesn't need to take more than 20
02:30:12 <Twey> benmachine: You're not using it correctly :þ
02:30:20 <c_wraith> calculating fib(n) naively uses  fib(n) function calls
02:30:24 <Twey> Yes
02:30:30 <newsham> you could bend the rules a little and use unsafePerformIO to read the data in from a file and still assign its results to a pure global value
02:30:33 <Twey> Wait
02:30:38 <Twey> How naïve is naïve?
02:30:42 <sproingie> newsham: "a little"?
02:30:45 <Gilly> HaskellLove: you're actually quite annoying, dude :) but anyways, i wasn't realizing you are comparing the functional way with the imperative until now.
02:30:46 <bnijk_> how do you produce a binary number
02:30:50 <bnijk_> as a string
02:30:53 <benmachine> Twey: in terms of fib n-1 and fib n-2
02:30:59 <bnijk_> from an int ;)
02:31:00 <Gilly> HaskellLove: if *that's* what you tried to explain (very poorly!), then alright.
02:31:02 <mauke> showIntAtBase
02:31:03 <newsham> sproingie: sure, just a little.. if the contents are all read at initialization time, its mostly pure
02:31:06 <bnijk_> ooo
02:31:09 <bnijk_> > showIntAtBase 585
02:31:10 <lambdabot>   * Exception: Numeric.showIntAtBase: applied to negative number -3
02:31:13 <HaskellLove> Gilly oh thank you Chesus now he finally saw what i meant
02:31:14 <Twey> Sounds like it should be, er, O(log(n)) I think
02:31:19 <bnijk_> o.o
02:31:21 <sproingie> newsham: yah i suppose if you only do it once
02:31:33 <EvanR> newsham: not sure how i like that method, id like to avoid totally writing a c program in haskell ;)
02:31:35 <bnijk_> :t showIntAtBase
02:31:35 <benmachine> Twey: isn't it exp(n)?
02:31:36 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
02:31:53 <c_wraith> Twey: fib n = fib (n - 1) + fib (n - 2).  That's O(fib n) to calculate.
02:32:08 <bnijk_> > showIntAtBase 2 585
02:32:09 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Char))
02:32:09 <lambdabot>    arising ...
02:32:11 * Twey scratches his head.
02:32:12 <newsham> evanr: the thing about using state is that it sounds like you want to mix state and monad which means using monad transformers.. which might be a little advanced at this point.
02:32:15 <bnijk_> no, no
02:32:24 <Gilly> HaskellLove: well, you could have said that map in haskell and certain loops in C (or insert your choice of imperative language) are somehow equivalent
02:32:24 <EvanR> newsham: thats what i was afraid of
02:32:26 <newsham> if you're ocmfortable with that, go for it.  otherwise I'd recommend starting by implicitely passing around the thing
02:32:35 <Twey> > fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 20
02:32:36 <lambdabot>   <no location info>: parse error on input `='
02:32:40 <Gilly> HaskellLove: that would have been much more understandable
02:32:41 <Twey> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 20
02:32:41 <newsham> its not that much work to pass in the generator as one extra argument
02:32:42 <lambdabot>   10946
02:32:45 <Twey> Hm
02:32:50 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14052#a14052
02:32:50 <Twey> That's a lot of function calls
02:32:52 <HaskellLove> Gilly man explain me what fmap please, or maybe it is early for me to learn them i am like 5 days in haskell?
02:32:52 <newsham> if you end up having several extra args like that, just wrapp em all up in a single record
02:32:54 <c_wraith> That definition is O(n)
02:33:04 <bnijk_> > showIntAtBase 2 intToDigit 585
02:33:05 <lambdabot>   ""->
02:33:05 <lambdabot>    "1001001001"
02:33:05 <lambdabot>  "a"->
02:33:05 <lambdabot>    "1001001001a"
02:33:05 <lambdabot>  "aa"->
02:33:07 <lambdabot>    "1001001001aa"
02:33:09 <lambdabot>  "aa...
02:33:13 <bnijk_> wtf
02:33:21 <Gilly> HaskellLove: fmap is just a generalization of map for Functors (think of them as collections with objects you can map over)
02:33:23 <benmachine> oh, my thing thinks that F_0 is 0 and F_1 is 1
02:33:24 <Twey> c_wraith: Yeah, I was just trying to figure out what the twentieth Fibonacci number actually is, before I turn old and grey :þ
02:33:29 <benmachine> it's usually 1 and 2 respectively, right?
02:33:36 <benmachine> erm
02:33:39 <c_wraith> well...  O(n log n) when you start counting the time to add the numbers when they get large
02:33:40 <sproingie> HaskellLove: fmap is like map but it works on arbitrary functors (a list is a functor).  now explaining what a functor is could take a while, and LYAH explains them better than I can
02:33:40 <Twey> benmachine: It starts with 1 and 1
02:33:41 <EvanR> newsham: well i could group all the generators, world state, settings etc in a single data structure and pass that around, but passing it back in updated fashion sounds bad
02:33:43 <HaskellLove> Gilly seems not for me at this time, ok will leave it for later
02:33:43 <Gilly> HaskellLove: For lists fmap = map, for, say, some tree fmap would "map" over all of the leaves and so on.
02:33:45 <benmachine> by which I mean, F_1 = 0
02:33:46 <benmachine> hmm
02:33:50 <bnijk_> > showIntAtBase 2 intToDigit 2
02:33:51 <lambdabot>   ""->
02:33:51 <lambdabot>    "10"
02:33:51 <lambdabot>  "a"->
02:33:51 <lambdabot>    "10a"
02:33:51 <lambdabot>  "aa"->
02:33:53 <lambdabot> [5 @more lines]
02:33:56 <Twey> F_0 = 1, F_1 = 1, I believe
02:33:58 <bnijk_> where are these "a"s coming from
02:34:07 <newsham> evanr: the RNG at least is not something you need to update, right?
02:34:09 <aavogt> > showIntAtBase 2 intToDigit 2 ""
02:34:10 <lambdabot>   "10"
02:34:11 <benmachine> wikipedia says F_0 = 0
02:34:13 <newsham> are there other globals you have that you need to update?
02:34:22 <newsham> you probably want to pass them as IORefs
02:34:23 <Twey> bnijk_: It's providing sample input to show you what the function does
02:34:27 <newsham> if you're passing them to IO actions
02:34:32 <Twey> benmachine: Oh, okay then
02:34:32 <newsham> IORefs are pretty simple to use.
02:34:43 <EvanR> newsham: correct, it 'updates' itself
02:34:44 <benmachine> ...aren't mathematical sequences usually indexed from 1?
02:34:49 <sproingie> IORefs are those mutable variables haskell doesn't have ;)
02:35:02 <bnijk_> @let makeBin x = showIntAtBase 2 intToDigit x ""
02:35:02 <lambdabot>  Defined.
02:35:05 <Twey> benmachine: Depends on the mathematician
02:35:07 <newsham> sproingie: when in imperative code....
02:35:13 <osfameron> IORef is a funny name for a mutable variable
02:35:20 <monochrom> Note how F_0=0 F_1=1 is compatible with F_1=1 F_2=1.
02:35:23 <sproingie> well the ref is pure
02:35:27 <sproingie> the content varies
02:35:30 <mreh> how do I get Double from an Int?
02:35:34 <Twey> Dijkstra wrote an amusing anecdote about a mathematician yelling at students for starting sequences at 0
02:35:46 <mauke> mreh: fromIntegral
02:35:53 <bnijk_> > sum [x|x<-[1..999999], reverse (makeBin x) == makeBin x && reverse (show x) == show x]
02:35:54 <Twey> :t fromIntegral
02:35:55 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:35:57 <lambdabot>   mueval-core: Time limit exceeded
02:36:01 <bnijk_> grrrr
02:36:12 <mreh> mauke: I got distracted by fromInteger
02:36:23 <bnijk_> all that work for no answer
02:36:23 <mauke> @src fromIntegral
02:36:23 <lambdabot> fromIntegral = fromInteger . toInteger
02:36:45 <Twey> bnijk_: Hint: use your local GHC for intensive computations.  ☺
02:36:49 <sproingie> Twey: "In corporate religions as in others, the heretic must be cast out not because of the probability that he is wrong but because of the possibility that he is right"
02:36:52 <sproingie> Twey: that one?
02:36:55 <bnijk_> i realize Twey
02:36:59 <bnijk_> i have it open
02:37:06 <Twey> sproingie: That's the one :þ
02:37:08 <bnijk_> but then i have to look up all these modules
02:37:13 <kmc> if you're not actually doing IO, use STRef over IORef
02:37:18 <mauke> @index showIntAtBase
02:37:18 <lambdabot> Numeric
02:37:20 <Twey> All you need for that one is Prelude and Numeric
02:37:20 <mreh> Twey, spoingie: heard about climategate?
02:37:25 <Twey> No
02:37:26 <mauke> @index intToDigit
02:37:26 <lambdabot> Data.Char
02:37:29 <mreh> EWD was a genius
02:37:35 <sproingie> mreh: i prefer to call it SwiftHack
02:37:38 <bnijk_> climategate++
02:37:42 <Twey> Oh, yeah, and that
02:37:55 <Twey> But you can use ("01" !!) instead of intToDigit
02:38:00 <mreh> sproingie: hacking the data together, or hacking the servers
02:38:11 <sproingie> mreh: think Swiftboat
02:38:13 <EvanR> kmc: what counts as IO
02:38:21 <mreh> (cycle "01" !!)
02:38:23 <kmc> input and output
02:38:24 <bnijk_> can any of you implement "aplay" in two lines of haskell?
02:38:33 <bnijk_> not counting "import" lines
02:38:33 <kmc> or anyway other stuff that's in the IO monad
02:38:37 <newsham> mreh: when a small subset of climatologists were embarrassed by some private language that joked around about supressing evidence?
02:38:40 <EvanR> kmc: generating a random number for some purpose isnt really IO
02:38:45 <sproingie> how about this
02:38:48 <bnijk_> newsham: did you read the emails?
02:38:49 <mauke> main = system "aplay"
02:38:50 <sproingie> let's put ALL our cards on the table
02:38:50 <kmc> yeah, you can put rng into ST as well
02:38:50 <EvanR> nor is using regular arrays
02:38:54 <sproingie> let's see all of Exxon's emails
02:38:57 <newsham> bnijk: i saw some exerpts
02:39:00 <sproingie> oh, not sharing now are we?
02:39:04 <kmc> that's my point.  if it *only* involves mutable state, you can use ST
02:39:05 <bnijk_> newsham: i read probably 20% of them
02:39:07 <bnijk_> i have them all
02:39:09 <kmc> and that has some advantages
02:39:09 <bnijk_> do you want a copy?
02:39:10 <newsham> bnijk: at any rate, its irrelevant what one small group of climatologists said
02:39:12 <sproingie> that's all i gotta say about "climategate"
02:39:12 <Twey> mreh: Well, it's binary, so it'll never need a third digit
02:39:14 <bnijk_> no, it's not
02:39:16 <EvanR> kmc: so what is IORef for?
02:39:23 <bnijk_> their research was the lynchpin of the whole thing
02:39:24 <gwern> @hoogle (a -> Bool) -> a -> [a] -> [a]
02:39:24 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
02:39:24 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
02:39:24 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
02:39:34 <kmc> EvanR, for doing mutable state if you're in the IO monad
02:39:35 <sproingie> bnijk_: take it to #haskell-wank
02:39:40 <bnijk_> w/e
02:39:55 <newsham> bnijk: this is way off topic here.  there is general consensus amoung the scientific community.  this is not controversial.
02:40:03 <bnijk_> ok
02:40:05 <mreh> consensus consmensus
02:40:07 <gwern> oh well. I guess erase = map (λx →  if isAlphaNum x then '_' else x ) works well enough
02:40:07 <bnijk_> you do not get to tell me something is offtopic
02:40:16 <bnijk_> in the same breath that you talk about what you think about it
02:40:19 <sproingie> i do get to tell you you're a goddam tool
02:40:32 <mreh> take it to
02:40:36 <EvanR> kmc: so if i get a network event, use one of several handlers, need a random number, the result is sent back to the sender, is that iO?
02:40:41 <kmc> yes
02:40:42 <mreh> #haskell-no-one-cares
02:40:43 <lunabot>  luna: A section must be enclosed in parentheses
02:40:57 <bnijk_> nobody cares until they're broke mreh...
02:41:07 <sproingie> nobody cares HERE period
02:41:11 <kmc> network access is definitely going to involve IO actions, unless you're using a fancy API that wraps it somehow
02:41:22 <bnijk_> nobody would have brought it up if nobody cared
02:41:28 <EvanR> kmc: so for a server, is the entire program 'in the IO monad' ?
02:41:38 <mauke> so you're saying we should just kick everyone who brings it up
02:41:38 <newsham> bnijk: this channel is for discussion of haskell.
02:41:40 <kmc> what do you mean by "entire program"?
02:41:47 <kmc> every Haskell program is a value "main :: IO ()"
02:41:51 <mreh> lets take it haskell
02:41:53 <bnijk_> are you discussing it right now newsham ...
02:41:53 <mreh> =blah
02:42:07 <medfly> @let climateGate = "it's a conspiracy!"
02:42:08 <lambdabot>  Defined.
02:42:15 <mreh> lol
02:42:20 <medfly> all discussions about off-topic things should be done in this manner . :)
02:42:27 <kmc> that value is an IO action, built out of smaller IO actions using the monad operators
02:42:28 <monochrom> #haskell-blah
02:42:29 <lunabot>  luna: A section must be enclosed in parentheses
02:42:30 <bnijk_> what
02:42:34 <gwern> kmc: if a program does no IO how do you know it exists?
02:42:35 <bnijk_> unqualified slander?
02:42:43 <bnijk_> hand-waving?
02:42:45 <gwern> bnijk_: libel, actually
02:42:45 <benmachine> import qualified Slander
02:42:56 <gwern> bnijk_: since all of that would be written; slander is verbal
02:42:59 <EvanR> kmc: you said that if you arent doing IO, dont use IORef, but it seems starting from IO, you are always doing IO. my scenario has parts that arent really IO, just computing something for later IO
02:43:05 <bnijk_> oh who cares, my point is the same
02:43:09 <monochrom> Final warning. Banning begins in 30 seconds.
02:43:25 <kmc> EvanR, the usual structure for a Haskell program is a crunchy IO shell with a gooey chocolate pure function center
02:43:31 <bnijk_> exhausting
02:43:35 <newsham> gwern: because you just wrote it down with pencil and paper?
02:43:36 <newsham> :)
02:43:46 <gwern> newsham: I always keep a notepad handy
02:44:03 <EvanR> kmc: yeah so is the generating a random number in the crunchy part or the gooey part
02:44:26 <kmc> :t runST
02:44:27 <gwern> EvanR: gooey
02:44:27 <lambdabot> forall a. (forall s. ST s a) -> a
02:44:28 <bnijk_> @let pentagonal n = n*(3*n-1)/2
02:44:29 <lambdabot>  Defined.
02:44:40 <bnijk_> > map pentagonal [1..10]
02:44:41 <lambdabot>   [1.0,5.0,12.0,22.0,35.0,51.0,70.0,92.0,117.0,145.0]
02:44:47 <bnijk_> excellent
02:44:47 <gwern> EvanR: since RNGs use seeds and that means they are pure
02:44:47 <kmc> EvanR, runST is the main thing ST can do that IO can't
02:44:56 <gwern> (but don't ask how you get a unique seed...)
02:45:14 <EvanR> in my case the seed is read from a file on program start
02:45:31 <EvanR> which is just the last state of the generator before ending the program
02:45:47 <kmc> if it is useful for you to have pure (non-action-returning) functions that "run" your RNG-using code internally, you might want ST
02:45:57 <EvanR> ah
02:46:03 <sproingie> the RNG may be crunchy or gooey depending on the RNG you use
02:46:10 <sproingie> storing the RNG state is always in the crunchy part
02:46:19 <sproingie> i like these adjectives
02:46:31 <sproingie> @quote kmc the usual structure for a Haskell program is a crunchy IO shell with a  gooey chocolate pure function center
02:46:32 <lambdabot> No quotes match.
02:46:37 <sproingie> @remember kmc the usual structure for a Haskell program is a crunchy IO shell with a  gooey chocolate pure function center
02:46:38 <lambdabot> It is forever etched in my memory.
02:46:40 <gwern> sproingie: the problem is I like crunchy better than gooie
02:46:47 <gwern> so for me the desirability is inverted
02:46:49 <gwern> @flush
02:46:56 <EvanR> hah
02:47:39 <kmc> EvanR, the State monad is also sufficient to pass RNG state
02:48:11 <EvanR> would i use multiple state monads for each piece of world state, or one state with all the state in it, including the rng
02:48:17 <kmc> the latter
02:48:21 <sm> yeah, drop the "gooey"
02:48:27 <sm> it's just pure chocolate
02:48:47 <EvanR> is that combined with IO or separate
02:48:49 <kmc> IO and ST give you "true" mutable cells with in-place memory update.  State is just monadic sugar for the pure-functional trick of passing and returning your state from/to every function
02:48:56 <EvanR> like leaving IO, entering state, or what
02:49:03 <kmc> it depends if you need to do IO in the same code
02:49:06 <newsham> i would recommend writing it simply first, pass in values directly if they dont change, either return values or pass in mutable iorefs or strefs at first, do lots of stuf fin IO.
02:49:11 <EvanR> kmc: seems like i could avoid that
02:49:13 <EvanR> maybe
02:49:14 <kmc> if so you can use StateT IO s a
02:49:18 <kmc> @unmtl State s a
02:49:18 <lambdabot> s -> (a, s)
02:49:18 <newsham> then step back and ask yourself how much needs to be IO, start rewriting, see how far you can get
02:49:22 <kmc> @unmtl StateT IO s a
02:49:23 <lambdabot> IO -> s (a, IO)
02:49:38 <newsham> then sit back and ask yourself how you'd do the whole thing again knowing what you now know
02:49:40 <benmachine> @unmtl StateT s IO a
02:49:41 <lambdabot> s -> IO (a, s)
02:49:44 <kmc> that's the one
02:50:08 <newsham> would give you a chance to play with several ideas one at a time, without having to tackle all these compelx things all at once
02:50:08 <EvanR> newsham: okay...
02:50:53 <ErhardtMundt> BONUS, hey!
02:51:01 <benmachine> some people have pointed out that using StateT s IO a doesn't really give you anything that ReaderT r IO a with an IORef can't
02:51:04 <sproingie> EvanR: chances are you'll want a big "MUD Monad" which is a stack of monads using transformers
02:51:12 <c_wraith> Bah.  runSTArray doesn't do what I need.  I think I'm going to have to unsafeFreeze.  >_>
02:51:20 <EvanR> sproingie: that would be cool
02:51:37 <kmc> :t runSTArray
02:51:38 <lambdabot> Not in scope: `runSTArray'
02:52:05 <sproingie> there's a few games on hackage that use the stack approach
02:52:09 <sproingie> mage i think is one
02:52:11 <ddarius> benmachine: State s a = forall st. ReaderT (STRef st s) (ST st) a
02:52:27 <sproingie> i can't get mage to work since it uses curses which seems to be really borked these days
02:52:37 <Cale> EvanR: I've found that transforming the IO monad is usually a bit of a waste, since IO really has a lot of stuff available in it already.
02:52:49 <sproingie> ah the problem is it uses its OWN curses binding which doesn't work on ncurses
02:53:05 <newsham> cale: I was thinking that but afraid to say it and be called out for heresey :)
02:53:07 <EvanR> Cale: so youd say in a heavy state dependent program to just use all IO
02:53:33 <Cale> EvanR: Well, not necessarily. I tend to only use IO for, well, I/O.
02:53:41 <BONUS> hey michele! :)
02:53:55 <Cale> Construct a datatype which represents the entire state of your game effectively
02:53:55 <benmachine> if you can easily separate input and output streams then sometimes RWS is fine
02:53:57 <newsham> evanr: the parts of your program that need to be in IO monad..
02:54:05 <Cale> and write pure functions for operating on that datatype
02:54:32 <Cale> Then hook those up to actual input and output in the IO monad
02:54:34 <EvanR> Cale: ah. you mean separate IO from other state stuff
02:54:35 <benmachine> especially given that you can make a Monoid of IO () so you can use it for your writer
02:55:03 <ErhardtMundt> BONUS, I had problems with my hard disk
02:55:19 <ErhardtMundt> BONUS, do you have the latex source yet?
02:55:27 <kmc> benmachine, that's a really clever trick
02:55:30 <kmc> Monoid (IO ())
02:55:35 <BONUS> for the lyah pdf?
02:55:41 * ddarius never uses Writer.
02:55:50 <ddarius> @instance Monoid
02:55:50 <lambdabot> Maybe you meant: instances instances-importing
02:55:51 <Cale> Monad transformers are not really all that fit for programs which one would normally classify as an "application". They work out well for constructing certain types of libraries.
02:55:54 <Craig`> I'm liking [c | c <- "blah blah blah", c /= ' '] :)
02:55:54 <BONUS> i'll look for it!
02:55:58 <ErhardtMundt> BONUS, yeah, the LYAH draft
02:56:00 <kmc> i suppose any monad m forms a monoid with (m ()) because of the Kleisli category
02:56:02 <ddarius> @instances-importing Data.Monoid Monoid
02:56:03 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:56:07 <ErhardtMundt> BONUS, thanks ;)
02:56:08 <Craig`> BONUS, I love LYAH :)
02:56:09 <Cale> And of course, the lines are quite fuzzy there.
02:56:21 <BONUS> Craig` thanks :D
02:56:29 <kmc> > filter (/= ' ') "blah blah blah"
02:56:30 <lambdabot>   "blahblahblah"
02:56:43 <kmc> don't name something if you don't have to :)
02:56:48 <newsham> kmc: monad laws say so, no?
02:57:07 <benmachine> kmc: any applicative, indeed?
02:57:08 <Craig`> kmc, oh cool thanks, it's just this pdf I was reading showed the code I used.. hmm
02:57:11 <Cale> > filter (not . isSpace) "blah  blah\t \n\v"
02:57:12 <lambdabot>   "blahblah"
02:57:12 <benmachine> er, that wasn't a question
02:57:14 <benmachine> kmc: any applicative, indeed.
02:57:22 <benmachine> wait
02:57:24 <kmc> the monad laws say that the kleisli category obeys category laws.  and if you restrict a category to one object, it's a monoid
02:57:32 <kmc> any applicative, really?
02:57:35 <newsham> are you guys trying to confuse craig' ?
02:57:38 <benmachine> I'm not actually sure if the applicative laws enforce associativity
02:57:54 <benmachine> but you can get a binary operation with identity in the same way
02:57:58 <Cale> Huh?
02:58:15 * benmachine tries to look up applicative laws
02:58:25 <Cale> What's this about applicative?
02:58:38 <kmc> Cale, whether (f ()) can be made a Monoid, for Applicative f
02:58:49 <kmc> it can for Monad f, using the Kleisli category
02:58:52 <benmachine> with mappend (*>) and mempty pure ()
02:59:10 <kmc> fair enough
02:59:16 <kmc> :t (*>)
02:59:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
02:59:24 <Cale> Yeah, that'd be a monoid.
02:59:33 <benmachine> how do we know *> is associative?
02:59:54 * benmachine found the applicative laws and now is trying to make them do interesting things
03:02:39 <benmachine> :t const id
03:02:40 <lambdabot> forall a b. b -> a -> a
03:04:06 <Craig`> this haskell programming is actually fun :)
03:04:25 <bnijk_> > xor 21
03:04:26 <lambdabot>   Ambiguous type variable `t' in the constraints:
03:04:26 <lambdabot>    `Data.Bits.Bits t'
03:04:26 <lambdabot>      ...
03:04:33 <bnijk_> oh really
03:06:52 <newsham> > 5 `xor` 21
03:06:53 <lambdabot>   Ambiguous type variable `t' in the constraint:
03:06:53 <lambdabot>    `Data.Bits.Bits t'
03:06:53 <lambdabot>      a...
03:06:56 <newsham> > 5 `xor` 21 :: Int
03:06:57 <lambdabot>   16
03:16:37 <roconnor> > [True,True,False,False] `xor` [True,False,True,False]
03:16:38 <lambdabot>   No instance for (Data.Bits.Bits [GHC.Bool.Bool])
03:16:38 <lambdabot>    arising from a use of `...
03:17:00 <Twey> Hm
03:17:07 <roconnor> > True `xor` False
03:17:08 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
03:17:08 <lambdabot>    arising from a use of `Da...
03:17:12 <roconnor> gah
03:17:12 <Twey> [Bool] sounds like a prime candidate for Bits
03:17:32 <roconnor> H98 says it can only be Bits a =>[a]
03:17:38 <benmachine> dang I am finding it surprisingly hard to prove anything with applicative laws
03:17:42 <Twey> Ah, yeah
03:18:14 <roconnor> benmachine: really?
03:18:29 <benmachine> roconnor: the most likely explanation is that I suck at proof
03:18:35 <roconnor> :)
03:18:54 <roconnor> you could be trying to prove unprovable statements
03:19:13 <benmachine> possibly
03:19:36 <EvanR> is there a one liner for serializing/decoding a value
03:19:56 <benmachine> but it seems like most of the transformations you can do require a pure on the right
03:20:00 <benmachine> ooh wait
03:20:10 <benmachine> you can go both ways round of course
03:20:12 <benmachine> silly me
03:20:26 * benmachine wonders if that actually helps
03:22:03 <newsham> evanr: like "show" ?
03:22:36 <EvanR> ah. so if i have a complex data type, i can show it
03:22:40 <newsham> > read (show 5) :: Int
03:22:41 <lambdabot>   5
03:22:49 <EvanR> if the parts are showable
03:23:08 <newsham> you can automatically derive Show for data types made up of showable components
03:23:24 <kmc> EvanR, you can show your type iff it is an instance of the Show typeclass.  and you can make the compiler generate that instance automatically if the parts are instances of Show
03:23:26 <kmc> using "deriving"
03:23:38 <EvanR> what document describes all this besides the haskell report
03:23:47 <ray> the haskell 98 report?
03:23:47 <kmc> most any Haskell tutorial
03:23:59 <ray> what's wrong with the report
03:24:04 <HayashiRazan> kmc :: IO()
03:24:05 <EvanR> im thinking im just going to read the report
03:24:13 <EvanR> tutorials leave me feeling empty
03:24:23 <kmc> why am i a unit IO action?
03:24:31 <sproingie> i never found the report all that helpul
03:24:34 <sproingie> helpful
03:24:54 <BONUS> the report left a huge gaping chasm in my soul
03:24:56 <kmc> it was helpful to me in understanding layout
03:24:59 <newsham> the "gentle introduction to haskell" is a good reference-like intro :)
03:25:04 <newsham> ie. not gentle ;-)
03:25:23 <sproingie> the gentle introduction covers a lot of weird stuff that doesn't really belong in a tutorial
03:25:24 <EvanR> im looking gentle, but its not too verbose on data
03:25:31 <EvanR> lookginat
03:25:36 <sproingie> i swear the dialog pattern dates from before haskell had monadic IO
03:25:47 <newsham> evanr: this one is simple enough to just answer on the irc.
03:25:50 <toast-opt> so, curious question... the 'State a' monad is something like (state -> (a, state)), right?
03:25:55 <newsham> data Foo = Int | String deriving (Show)
03:26:03 <Paczesiowa> @unmtl State s
03:26:03 <lambdabot> err: `State s' is not applied to enough arguments, giving `/\A. s -> (A, s)'
03:26:06 <newsham> oops, bad syntax :)
03:26:08 <Paczesiowa> @unmtl State s a
03:26:08 <lambdabot> s -> (a, s)
03:26:08 <Cale> toast-opt: State s a ~= s -> (s,a)
03:26:14 <newsham> data Foo = Foo Int String deriving (Show)
03:26:24 <newsham> x = show (Foo 3 "test")
03:26:35 <toast-opt> is the backward-flowing state monad something like BackState s a ~= (s,a) -> s
03:26:37 <EvanR> im feeling like im missing a lot of the data declarations. need to read
03:26:52 <Cale> toast-opt: No, it has the same type
03:27:01 <Paczesiowa> toast-opt: bind works different
03:27:03 <Cale> toast-opt: It just has a different implementation of bind
03:27:06 <toast-opt> oh, gotcha
03:27:27 <Paczesiowa> (s,a) -> s wouldn't work, how would you write return?
03:27:34 <kmc> EvanR, LYAH covers this doesn't it?
03:27:38 <Paczesiowa> without some crazy ContT?
03:27:44 <EvanR> havent seen that one yet
03:27:51 <kmc> @where lyah
03:27:51 <lambdabot> http://www.learnyouahaskell.com/
03:28:12 <newsham> evanr: you mean you havent read the top 20 haskell books and tutorials before asking your question?!@# ;-)
03:28:32 <EvanR> a) that abbr didnt register as something i needed to look at, and b) the expanded title of the tutorial sounded like it was written by a troglodyte ;)
03:28:33 <Cale> (s,a) -> s isn't even a (covariant) functor in a
03:28:36 <Paczesiowa> is there a trick to reify class context in a type?
03:29:01 <ezyang> In Parsec, is there a way to make sure the parser consumed all of the input, and if it didn't, error?
03:29:03 <Cale> Paczesiowa: "reify"?
03:29:08 <Paczesiowa> ezyang: eof
03:29:09 <kmc> ezyang, (>> eof)
03:29:17 <ezyang> cool
03:29:32 <sproingie> the backward state monad is pretty mind-bendy
03:29:39 <Paczesiowa> Cale: "if there is C a in context then .."
03:29:46 <kmc> @pl \a b -> do { x <- a; b; return x }
03:29:46 <lambdabot> (line 1, column 12):
03:29:46 <lambdabot> unexpected "{"
03:29:46 <lambdabot> expecting variable, "(", operator or end of input
03:29:47 <sproingie> ISTR it didn't satisfy one of the monad laws
03:30:07 <kmc> @pl \a b -> a >>= \x -> (b >> return x)
03:30:07 <lambdabot> (. ((. return) . (>>))) . (>>=)
03:30:14 <Cale> Paczesiowa: No, not so far as I'm aware.
03:30:22 <Paczesiowa> come on - one law... nobody's perfect:)
03:30:35 <Cale> Paczesiowa: Maybe if you're talking about template Haskell, but I don't know much about TH.
03:30:38 <ezyang> Is there a cute way to make it return the result of the previous parser?
03:30:53 <Paczesiowa> Cale: that wouldn't be fun:)
03:31:07 <Paczesiowa> ezyang: (<*)
03:31:11 <Paczesiowa> :t (*<)
03:31:12 <lambdabot> Not in scope: `*<'
03:31:17 <Paczesiowa> :t (<*)
03:31:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
03:31:18 <ezyang> :t (<*)
03:31:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
03:31:24 <ezyang> coool
03:31:26 <benmachine> that runs them right-to-left doesn't it?
03:31:36 <benmachine> try const <$> a <*> b
03:31:47 <jeff_s_> Is there a way to get the IO monad "inside" the Gen monad so I can print the "a" that's in "Gen a"?
03:31:51 * benmachine thinks this should have a name as it is handy
03:32:01 <idnar> @src (<*)
03:32:02 <lambdabot> (<*) = liftA2 const
03:32:05 <idnar> bah
03:32:15 <benmachine> @src liftA2
03:32:16 <lambdabot> liftA2 f a b = f <$> a <*> b
03:32:20 <benmachine> oh ok
03:32:24 <idnar> heh
03:32:26 <Paczesiowa> :i Gen
03:32:33 <idnar> yeah, it just throws away the result on the right basically
03:32:41 <benmachine> so it's not like =<<
03:32:46 <benmachine> wrt >>=
03:32:54 <idnar> @type (*>)
03:32:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
03:33:06 <idnar> and that throws it away on the left
03:33:09 <HayashiRazan> :t ezyang
03:33:10 <lambdabot> Not in scope: `ezyang'
03:33:27 <Paczesiowa> he's right there!
03:33:30 <Cale> jeff_s_: It's not an instance of MonadIO, so probably not.
03:33:40 <HayashiRazan> :t Paczesiowa
03:33:41 <lambdabot> Not in scope: data constructor `Paczesiowa'
03:33:48 <Cale> newtype Gen a = MkGen{ unGen :: StdGen -> Int -> a }
03:34:03 <kmc> use ReaderT
03:34:08 <Cale> It's essentially just a function monad with StdGen and Int parameters
03:34:20 <Paczesiowa> you can unsafeCoerce Gen a to that function
03:34:25 <kmc> haha
03:34:27 <jeff_s_> oh ok, hm, so my only option is "generate"
03:34:30 <Cale> huh?
03:34:37 <Cale> Why would you unsafeCoerce?
03:34:54 <Paczesiowa> Cale: isn't it abstract?
03:35:00 <Cale> no
03:35:06 <Paczesiowa> nvm then:)
03:35:14 <EvanR> are data constructors functions
03:35:33 <newsham> mathematically?
03:35:37 <EvanR> haskelly
03:35:42 <eivuokko> nomeata, but they may appear on same places in expressions as functions do.
03:35:44 <Kim^Walkman> :t True
03:35:45 <lambdabot> Bool
03:35:49 <jeff_s_> EvanR I think so. like you can do "map Just [1..3]
03:35:51 <Kim^Walkman> Dur
03:35:55 <eivuokko> I hate this autocomplete thingy..
03:36:02 <BONUS> :t Just
03:36:03 <lambdabot> forall a. a -> Maybe a
03:36:05 <newsham> they behave in the same way as other functions except they can be pattern matched against to deconstruct
03:36:17 <EvanR> ok
03:37:46 <BONUS> hmm, terminology question: do you guys prefer "value constructor" or "data constructor"
03:38:04 <EvanR> ive only heard data constructor
03:38:08 <monochrom> value constructor
03:38:13 <EvanR> :\
03:38:15 <Paczesiowa> value is a bit smly
03:38:23 <Paczesiowa> SML-y
03:38:27 <benmachine> :t flip id id id
03:38:28 <monochrom> "data" is too ambiguous by now.
03:38:28 <lambdabot> forall a. a -> a
03:38:59 <newsham> True is a data constructor and a value ;-)
03:39:22 <monochrom> "data" is too ambiguous because "data MyType = ..." defines a type but is keyworded "data". This word is tainted and cursed.
03:39:46 <EvanR> the right side of = lists data constructors
03:39:53 <sproingie> i just say constructor
03:39:55 <EvanR> functions returning MyType
03:40:01 <EvanR> there are also type constructors
03:40:10 <sproingie> hm true
03:40:13 <EvanR> so i need terminological clarification
03:40:30 <sproingie> value constructor is probably more appropriate now
03:41:30 <newsham> EvanR: sometimes you have parameterized types. like "list of ..." or "Maybe ..."
03:41:38 <monochrom> "newtype HisType = X Bool" do you call X a newtype constructor?
03:41:42 <newsham> that require more types to make a complete type.
03:41:59 <EvanR> i dont like value constructor since any function call constructs a value
03:42:09 <EvanR> but not all are related to data declarations
03:42:27 <newsham> evanr: eh? functions could return a value that was passed in and previously constructed :)
03:42:32 <c_wraith> is there an array -> list function?
03:42:42 <newsham> ie.  id x = x  <- not constructing anything
03:43:02 <benmachine> monochrom: I think if you did it'd be clear what was meant
03:43:03 <monochrom> I wouldn't say "any function call constructs a value".
03:43:06 <BONUS> c_wraith: elems
03:43:10 * ezyang is frustrated because he can't figure out why his parser is wrong 
03:43:16 <c_wraith> :t elems
03:43:17 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
03:43:26 <c_wraith> Hmm.  Is there a general version of that?
03:43:35 <monochrom> "head" seems to be a destructor.
03:43:35 <c_wraith> I'm using STArray
03:43:38 <EvanR> ill just synonymize data constructors and value constructors
03:43:44 <BONUS> c_wraith: there's one in MArray
03:43:51 <c_wraith> thanks, BONUS
03:44:11 <benmachine> :t getElems
03:44:12 <lambdabot> Not in scope: `getElems'
03:44:16 <benmachine> hm
03:44:26 <BONUS> if you want to use elems on an STArray, i think you have to freeze it first to get an Array
03:44:30 <BONUS> and then you use elems on the array
03:44:46 <c_wraith> there is getElems
03:44:51 <BONUS> or do elems . runSTArray
03:44:55 <benmachine> ghci> :t getElems
03:44:55 <benmachine> getElems :: (MArray a e m, Ix i) => a i e -> m [e]
03:44:58 <monochrom> I choose "type ___or" and "value ___or" because a wide community here already talks like "are you finding primes at the value level or the type level?"
03:45:06 <Twey> Heheheh
03:45:39 <BONUS> oh yeah and there's getElems if you want an ST action that yields the elements
03:45:40 <monochrom> So they will also talk like "do you mean constructor at the value level or the type level?"
03:45:46 <EvanR> unfortunate the first tutorial i read called the wrong thing!
03:45:49 <BONUS> monochrom: i like that reasoning
03:46:03 <EvanR> now its etched into my brain
03:49:48 <dh____> good morning guys. How long it might takes to install ghc on a Mac with port ? I'm installing hls2latex with port, but it required to install ghc, which freezed at Building ghc ...
03:50:37 <Saizan_> it can take a while.
03:50:46 <Phyx-> Hi, anyone know how to use QuickCheck 2.0 to generate random values? there used to be a function "generate :: Int -> StdGen -> Gen a -> a" in there, but i can't seem to find it in 2.x
03:51:07 <dh____> saizan: by a while, do u mean 1 hour?
03:51:54 <Paczesiowa> dh____: depends on your machine, it can take even 2h
03:52:19 <dh____> ok, thanks. I guess I'll wait.
03:56:02 <ezyang> Does the natural parser consume trailing whitespace?
03:56:18 <bnijk_> > zipWith (*) [1..10] [2..11]
03:56:20 <lambdabot>   [2,6,12,20,30,42,56,72,90,110]
03:56:35 <bnijk_> oh how interesting
03:56:43 <ezyang> Oh, yes it does. AHA.
03:56:45 <altmattr> 0 until 10 is great, but how to create a list of length x with the same element in each cons cell?
03:56:52 <ezyang> Can I make it not do that?
03:57:02 <xerox> > replicate 10 x :: [Expr]
03:57:03 <lambdabot>   [x,x,x,x,x,x,x,x,x,x]
03:57:06 <altmattr> oops, wrong chanetl
03:57:06 <copumpkin> altmattr: replicate x element
03:57:09 <bnijk_> > zipwith (-) (zipWith (*) [1..10] [2..11]) (zipWith (*) [2..11] [3..12])
03:57:10 <lambdabot>   Not in scope: `zipwith'
03:57:11 <altmattr> heh?
03:57:15 <xerox> :)
03:57:16 <bnijk_> > zipWith (-) (zipWith (*) [1..10] [2..11]) (zipWith (*) [2..11] [3..12])
03:57:17 <lambdabot>   [-4,-6,-8,-10,-12,-14,-16,-18,-20,-22]
03:57:22 <bnijk_> :D
03:57:40 <bnijk_> what are the odds
03:58:00 <Phyx-> .quit
03:58:50 <bnijk_> > replicate 10 "/;:'`':;\.," :: [String]
03:58:51 <lambdabot>   <no location info>:
03:58:53 <lambdabot>      lexical error in string/character literal at chara...
03:59:06 <bnijk_> > replicate 10 ";:'`':;.," :: [String]
03:59:08 <lambdabot>   [";:'`':;.,",";:'`':;.,",";:'`':;.,",";:'`':;.,",";:'`':;.,",";:'`':;.,",";...
03:59:58 <ezyang> Ok, replaced natural with read <$> many digit
04:00:06 <ezyang> I'm... not terribly happy with this solution
04:00:35 <idnar> > cycle "_,.-~^`'`^~-.,"
04:00:37 <lambdabot>   "_,.-~^`'`^~-.,_,.-~^`'`^~-.,_,.-~^`'`^~-.,_,.-~^`'`^~-.,_,.-~^`'`^~-.,_,.-...
04:00:40 <Paczesiowa> ezyang: don't you mean many1?
04:00:46 <kmc> > concat $ filterM (const [False ..]) ".,:;"
04:00:49 <lambdabot>   ";::;,,;,:,:;..;.:.:;.,.,;.,:.,:;"
04:00:59 <ezyang> Paczesiowa: Oh, yes that's what I mean
04:01:01 <bnijk_> not bad idnar
04:01:18 <bnijk_> > replicate 10 "---_oo-O-_---____----oo----" :: [String]
04:01:19 <lambdabot>   ["---_oo-O-_---____----oo----","---_oo-O-_---____----oo----","---_oo-O-_---...
04:01:23 <idnar> I need more unicode to fill in the bottom arc
04:01:31 <idnar> but I don't have a compose key on this computer
04:01:38 <pchiusano> If i have import qualified Data.IntMap as M
04:01:53 <pchiusano> why can I not say type Map a = M a ?
04:01:55 * bnijk_ opens gucharmap
04:01:59 <kmc> M is a module, not a type
04:02:04 <kmc> type Map a = M.IntMap a
04:02:06 <EvanR> idnar: swap , and .
04:02:23 <pchiusano> kmc: ah, I see
04:02:42 <Philonous> Is there a library for dependent types? (Type numerals etc. )
04:02:49 <bnijk_> > replicate 10 "᧖᧘ᦵᦡ𐎲𐏐𐏓𐏔𐎬𐤐𐤂𐤆𐤗𐤟𐤟𐤟𐤙𐤘𐤗" :: [String]
04:02:50 <lambdabot>   ["\6614\6616\6581\6561\66482\66512\66515\66516\66476\67856\67842\67846\6786...
04:02:54 <pchiusano> kmc: thnaks :)
04:02:58 <ddarius> Philonous: That's not dependent types.
04:03:03 <kmc> fake dependent types
04:03:05 <idnar> > cycle "_.,-~^`'`^~-,."
04:03:06 <lambdabot>   "_.,-~^`'`^~-,._.,-~^`'`^~-,._.,-~^`'`^~-,._.,-~^`'`^~-,._.,-~^`'`^~-,._.,-...
04:03:10 <idnar> hmm, depends on your font, I guess
04:03:11 <bnijk_> did i just freeze all their clients :O
04:03:11 <Paczesiowa> Philonous: there is for nat arith library on hackage
04:03:29 <Philonous> ddarius: Yes. I meant simulating dependent types
04:03:32 <bnijk_> ڶ۞
04:03:35 <Philonous> Paczesiowa: Thanks
04:03:46 <Paczesiowa> Philonous: why?
04:03:51 <kmc> > repeat '☭'
04:03:52 <lambdabot>   "\9773\9773\9773\9773\9773\9773\9773\9773\9773\9773\9773\9773\9773\9773\977...
04:03:54 <Paczesiowa> Philonous: why=what do you need?
04:03:56 <bnijk_> > cycle "ﻅﺫﺠﻈﺯﺄﻁﻧﺁﹲﹳﹴﹷﺡ"
04:03:57 <lambdabot>   "\65221\65195\65184\65224\65199\65156\65217\65255\65153\65138\65139\65140\6...
04:03:58 <kmc> > text $ repeat '☭'
04:04:00 <bnijk_> lambdabot can't do it
04:04:03 <lambdabot>   mueval: ExitFailure 1
04:04:05 <kmc> > text $ take 20 '☭'
04:04:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:04:06 <lambdabot>         against inferred ty...
04:04:15 <kmc> > text $ replicate 20 '☭'
04:04:16 <bnijk_> :t text
04:04:18 <lambdabot>   ☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭
04:04:18 <lambdabot> String -> Doc
04:04:26 <bnijk_> wtf is doc
04:04:38 <kmc> Text.PrettyPrint
04:04:42 <kmc> good library
04:04:50 <Paczesiowa> please stop messing with lambdabot and my screen
04:04:52 <kmc> > text $ replicate 80 '☭'
04:04:53 <lambdabot>   ☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭☭...
04:05:14 <Philonous> Paczesiowa: I want to manipulate the arguments of functions, and I want a type-safe way of expressing a certain argument position
04:05:27 <bnijk_> text $ replicate 20 "ﻅﺫﺠﻈﺯﺄﻁﻧﺁﹲﹳﹴﹷﺡ"
04:05:30 <bnijk_> > text $ replicate 20 "ﻅﺫﺠﻈﺯﺄﻁﻧﺁﹲﹳﹴﹷﺡ"
04:05:31 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:05:31 <lambdabot>         against inferred type...
04:05:36 <bnijk_> shhuuuuuuuu
04:05:45 <bnijk_> well whatever
04:05:53 <Paczesiowa> Philonous: go on...
04:05:55 <EvanR> hehe. i see sickle and hammer in my xterm but not ﺯ
04:05:55 <kmc> sheiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiit
04:06:08 <kmc> EvanR, this is what you get for using a communist OS
04:06:16 <EvanR> haha
04:06:28 <bnijk_> urxvt >
04:06:30 <bnijk_> urxvt > *
04:08:14 <bnijk_> > filter (`elem` ['A'..'Z']) "i wondEr Very often As to wheN evanR will reSpond cUrtly, at his nicK, to thiS"
04:08:15 <lambdabot>   "EVANRSUKS"
04:08:27 <kmc> hahaha
04:08:27 <bnijk_> it's hard to make those sentences sound convincing
04:08:37 <Philonous> Paczesiowa: for example I want to write "flipParameters three five" and I want a type error when the function doesn't have enough formal parameters rather than a runtime error
04:10:38 <bnijk_> somebody give me a problem to solve in haskell
04:10:42 <bnijk_> and not this "99 questions" crap
04:10:45 <kmc> world hunger
04:10:54 <Paczesiowa> type level RSA
04:10:55 <bnijk_> ok...ok
04:10:59 <bnijk_> world hunger
04:11:20 <kmc> write a scheme interpreter
04:11:23 <kmc> write a raytracer
04:11:35 <benmachine> write a haskell compiler
04:11:45 <bnijk_> > solve worldHunger
04:11:47 <lambdabot>   "grow more fruits and vegetables"
04:11:51 <bnijk_> damn
04:11:53 <bnijk_> was that all
04:12:07 <kmc> vortex 4 needs:
04:12:07 <mauke>  "eat insects"
04:12:16 <kmc> "kill the poor"
04:12:21 <mauke> bnijk_: solve all of http://spoj.pl
04:12:28 <bnijk_> kmc: ....
04:12:28 <PepeSilvia> spawn more overlords
04:12:33 <bnijk_> dead kennedys?
04:12:42 <Berengal> @type solve
04:12:42 <kmc> hehe
04:12:43 <lambdabot> forall a. (Enum a) => [a] -> [a]
04:12:50 * bnijk_ opens spoj.pl
04:12:52 <Berengal> @type worldHunger
04:12:53 <lambdabot> [Char]
04:12:54 <kmc> > solve
04:12:55 <lambdabot>   * Exception: Prelude.Enum.().pred: bad argument
04:13:06 <Berengal> > worldHunger
04:13:07 <lambdabot>   "hspx!npsf!gsvjut!boe!wfhfubcmft"
04:13:11 <Paczesiowa> Philonous: you want library for values like "three"? because other than that I think all you need is hMinimum
04:13:15 <Berengal> Hah
04:14:38 <Paczesiowa> Philonous: wait, nvm that. it's not that easy
04:14:45 <Philonous> Paczesiowa: What is hMinimum?
04:15:18 <Paczesiowa> Philonous: min lifted to type level
04:16:06 <Paczesiowa> Philonous: are all your types of arguments in function type different?
04:16:30 <Philonous> Paczesiowa: They might be. I don't want to make assumptions there
04:17:04 <sm> is there a way to cabal install just the dependencies for a project, without building the project itself, eg in the project's source directory ? The best I've found is to hit ctrl-c
04:17:29 <sm> s/in/from/
04:17:36 <c_wraith> bah.  I'm clearly not understanding how to use ST.  "Inferred type is less polymorphic than expected     Quantified type variable `s' is mentioned in the environment:"
04:17:54 <BONUS> c_wraith: code?
04:18:02 <c_wraith> one moment
04:18:37 <bnijk_> what's the inverse of 'ord'
04:18:37 <Berengal> sm: cabal fetch
04:18:41 <Berengal> bnijk_: chr
04:18:47 <bnijk_> right, right
04:18:50 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14054#a14054
04:19:11 <Berengal> sm: Though I'm not sure if that installs or just downloads the dependencies
04:19:31 <sm> it just complains about missing base, here
04:20:16 <bnijk_> ok...
04:20:19 <bnijk_> let's finally settle it
04:20:22 <bnijk_> are you guy ready
04:20:28 <bnijk_> i don't care i'm doing it anyway
04:20:30 <bnijk_> > whatIsTheAnswerTo lifeTheUniverseAndEverything
04:20:31 <lambdabot>   "the answer is 42"
04:20:39 <bnijk_> it was earth all along!!!!!
04:20:42 * bnijk_ kills himself
04:21:27 <toast-opt> nice
04:21:32 <BONUS> c_wraith: i think the compiler doesn't know that you're using STArrays
04:21:56 <c_wraith> hmm
04:22:16 <patch-tag> @pl \x -> x
04:22:16 <lambdabot> id
04:22:22 <bnijk_> BONUS: you should write the monads section of LYAH
04:22:32 <BONUS> bnijk_: i'm working on it :)
04:22:40 <patch-tag> @pl \newrq -> ( trace (show . ((,) "unproxify newrq") $ newrq) ) newrq
04:22:40 <lambdabot> trace =<< show . (,) "unproxify newrq"
04:22:42 <bnijk_> you've been working on it for like, two years ;)
04:22:47 <toast-opt> heh
04:23:18 <bnijk_> meanwhile all the noobs are in a haze of monad inapplicability
04:23:20 <BONUS> i think half a year would be more appropriate. had a lot of stuff going on O_O
04:23:32 <bnijk_> cars are crashing into buildings
04:23:34 <patch-tag> thanks lambda :)
04:23:36 <BONUS> hehe
04:23:38 <bnijk_> flowers are blooming and i am flying
04:23:44 <toast-opt> it's very tricky, i imagine.  it's a very 'eureka' type thing, once you've learned it it's hard to remember not knowing
04:24:01 <BONUS> but there are loads of monad tutorials to learn them right now
04:24:18 <bnijk_> not colorful tutorials though
04:24:39 <tensorpudding`> sun is shining, birds are singing
04:24:43 <kolmodin> does anybody use the parser generator frown?
04:24:50 <EvanR> learn you a monads for great justice
04:25:07 <toast-opt> evanr, nice title
04:25:35 <bnijk_> yes, use it BONUS
04:25:42 <bnijk_> or just hide it somewhere
04:25:58 <bnijk_> did you get my messages about the bnijk scholarship
04:26:09 <toast-opt> but 'a <plural>' ?
04:27:03 <EvanR> might as well be totally ungrammatical
04:27:04 <BONUS> c_wraith: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14054#a14055
04:27:35 <BONUS> your problem was that you were using MArray functions, but the compiler doesn't know that just because you're creating arrays in the ST monad that you're using STArrays
04:27:39 <c_wraith> So why couldn't it infer that?  Because ST uses a rank-2 type?
04:27:47 <BONUS> (they could be STUArrays or something completely else)
04:27:56 <BONUS> nah, it doens't have anything to do with that
04:28:21 <patch-tag> what do you usually call the (-> r) monad? universal reader?
04:28:47 <patch-tag> the from whatever monad?
04:28:50 <c_wraith> Hmm.  I would have thought the fact that I was leaving it polymorphic meant it couldn't have been an STUArray.
04:28:54 <ray> (r ->) you mean?
04:29:02 <patch-tag> yes
04:29:07 <c_wraith> Since STUArray requrires knowing the type
04:29:08 <ray> function monad
04:29:15 <ray> very occasionally reader
04:29:21 <BONUS> c_wraith: it's just like show (read "3")
04:29:37 <BONUS> the read here can't be left polymorphic
04:29:49 <Paczesiowa> :t show . read
04:29:50 <lambdabot> String -> String
04:29:57 <c_wraith> BONUS: ah, ok.  I've worked my way through that example in my head.
04:30:00 <Paczesiowa> > show . read $ "3"
04:30:02 <lambdabot>   "* Exception: Prelude.read: no parse
04:30:04 <Paczesiowa> > show . read $ "()"
04:30:05 <lambdabot>   "()"
04:30:09 * bnijk_ 03 - dick suffers is furious with you.mp3 ...
04:30:40 <BONUS> c_wraith: if your function returned something to do with the type of array that you're using
04:30:46 <BONUS> then it could be left polymoprhic
04:31:13 <c_wraith> Yeah, it's hiding the fact that it's using an array completely.  It's just an implementation detail (that allows using the O(n) algorithm)
04:31:16 <BONUS> but your function was just [a] -> g -> ([a], g) so the compiler couldn't just guess with MArray instance to use
04:31:20 <BONUS> yeah
04:31:22 <patch-tag> ray: actually...    instance Monad ((->) r) ...
04:31:41 <BONUS> i like the (,) <$> getElems <*> readSTRef genRef line :)
04:32:03 <patch-tag> which is closer to ( r -> ) in spirit imho. I like "from r" monad
04:32:18 <c_wraith> BONUS: I've been writing a lot of uu-parsinglib code.  I picked up that idiom doing that. :)
04:32:24 <BONUS> when i was doing a ST shuffle implementation i did fr <- unsafeFreeze ar; return (fr, gen)
04:32:29 <ray> (-> r) and ((->) r) are the opposite
04:32:45 <BONUS> yours is more elegant
04:32:47 <ray> stupidskell can't section ->
04:32:54 <ray> dumbskell
04:32:58 <BONUS> yeah the applicative style <$> <*> is awesome
04:33:17 <patch-tag> well syntactically we're both incorrect I believe no?
04:33:28 <BONUS> ray: yeah types can't be sectioned
04:33:29 <patch-tag> anyways don't want to belabor the point
04:34:28 <sproingie> numbskell
04:34:29 <napsy> Does haskell allow to modify (extend) functions in runtime like prolog?
04:34:40 <sproingie> napsy: nope
04:34:47 <byorgey> patch-tag: I usually call it the "reader monad" or "environment monad"
04:34:59 <byorgey> napsy: haskell doesn't allow you to modify *anything* at runtime. =)
04:35:07 <napsy> ok
04:35:09 <byorgey> this is a feature, not a bug
04:35:22 <napsy> so it's probably not the best choice for AI
04:35:33 <xerox> main = putStrLn "you suck!" -- *might* modify your mood at runtime
04:35:40 <sproingie> you can always define a set of combinators and an interpreter
04:35:48 <byorgey> napsy: I think that conclusion is unwarranted.
04:35:56 <sproingie> then you're targeting a flexible runtime API, not so much haskell itself
04:36:03 <byorgey> napsy: you can accomplish the same things with Haskell, you just have to think about them in a different way.
04:36:28 <EvanR> you can construct lists of actions and manipulate them arbitrarily, and run them
04:36:32 <Philonous> How is "instance (HZero :==: HZero) " a malformed instance header?
04:36:50 <napsy> We're learning prolog in school and it has some interesting properties. Just wanted to know if such things as expanding the "knowledge database" was possible
04:36:53 <sproingie> nothing about AI requires runtime modification of code
04:36:53 <byorgey> napsy: for example, with haskell, you could take a function and then construct (at runtime) a NEW function based on the old one.
04:36:59 <Paczesiowa> Philonous: what class is that?
04:37:07 <byorgey> napsy: sure, that is possible, but not by *modifying* a function.
04:37:10 <patch-tag> byorgey: po mans reader
04:37:25 <Philonous> "class a :==: b | a-> b , b-> a" (ghc accepts that)
04:37:26 <sproingie> you have to define what the knowledge database is first
04:37:27 <napsy> hm interesting
04:37:27 <byorgey> patch-tag: I think you mean 'po mans Reader' =)
04:37:31 <Paczesiowa> Philonous: perhaps instance (:==:) HZero HZero a
04:37:59 <Paczesiowa> Philonous: no 'a' at the end
04:38:17 <stulli> Can anybody help me with this error: Could not find module `GHC': it is a member of the hidden package `ghc-6.10.4' ?
04:38:32 <Paczesiowa> stulli: ghci -package ghc
04:38:34 <sproingie> napsy: in haskell you'd define your system as a function transitioning one knowledge base to another
04:38:48 <napsy> hm ok
04:39:04 <stulli> Paczesiowa: Thanks!
04:39:07 <sproingie> each KB would be a "snapshot", completely immutable
04:39:07 <patch-tag> napsy: if you are used to programming in an imperative way, you can use the State monad: http://blog.patch-tag.com/2009/12/07/transliterating-python-to-haskell-fibonacci-in-the-state-monad/ (transliterates stateful fibonacci from python to haskell)
04:39:07 <napsy> is there a project using haskell for AI that I could look at?
04:39:15 <Philonous> Paczesiowa: You are right. It appears ghc doesn't permit infix instance declarations. How boring.
04:39:23 <c_wraith> BONUS: I don't fully understand the change to the last line.  What's going on there?  Is it just ST not implementing Applicative?
04:39:24 <sproingie> napsy: check out hackage
04:39:26 <sproingie> @where hackage
04:39:27 <lambdabot> http://hackage.haskell.org/package/
04:39:35 <napsy> ok thanks I will
04:39:46 <BONUS> c_wraith: yeah it seems ST just isn't an instance of Applicative
04:39:49 <BONUS> kinda lam
04:39:49 <BONUS> e
04:39:59 <sproingie> ST is weird
04:40:13 <BONUS> looks like an oversight
04:40:14 <BONUS> i mean
04:40:25 <c_wraith> The instance is all of two lines. :)
04:40:27 <BONUS> instance Applicative (ST s) where pure = return; (<*>) = ap
04:40:29 <BONUS> there you go
04:41:39 <sproingie> sounds like that applies to every monad
04:41:44 <c_wraith> It does
04:41:48 <sproingie> i guess with ST you need the extra param
04:42:00 <c_wraith> That's true for the monad instance, also
04:42:13 <ddarius> ST isn't a monad, ST s is.
04:42:25 <sproingie> there any plans in Haskell' to fix the "Monad doesn't derive Functor" problem?
04:42:26 <copumpkin> someone should make ST an Arrow
04:42:31 <copumpkin> with a universally quantified domain :P
04:42:59 <benmachine> sproingie: people have come up with proposals but mostly they have been unsatisfactory
04:43:34 <benmachine> sproingie: http://haskell.org/haskellwiki/Superclass_defaults for example
04:43:45 <ddarius> benmachine: There's no need for a "proposal."  All that is necessary is to change class Monad m to class Functor m => Monad m
04:43:53 <ddarius> This is how Haskell 1.4 was.
04:44:32 <benmachine> ddarius: still wouldn't "derive" Functor
04:44:54 <ddarius> benmachine: I'm pretty sure he meant "derive" in the OO sense
04:45:10 <sproingie> how is it haskell lost features like that going from 1.4 to 98?
04:45:18 <benmachine> I'm pretty sure he meant that instance Monad m should automatically make m a functor
04:45:21 <jmcarthur> data constructor
04:45:28 <jmcarthur> dang, i was scrolled up
04:45:31 <jmcarthur> heh
04:45:33 <BONUS> hehe
04:45:40 <benmachine> hi5 jmcarthur
04:45:42 <BONUS> it seems like people are 50/50 over this
04:45:46 <EvanR> ah, so its data constructor after all ;)
04:45:54 <BONUS> i prefer value constructor over data constructor
04:46:11 <bnijk_> what is the difference between a monad and a stamen
04:46:22 <bnijk_> a functor and an aorta
04:46:25 <bnijk_> these questions and more
04:46:34 <bnijk_> for the low, low price of 29.95
04:49:01 <patch-tag> is there any way to do comments in a cabal file?
04:49:49 * Cale would guess that the comment syntax is the same as Haskell's
04:49:49 <sproingie> -- does it
04:49:51 <aavogt> -- starts a comment
04:51:47 <gwern> @quote mordor
04:51:47 <lambdabot> Badger says: one does not simply >>= into mordor
04:51:56 <gwern> @quote CanHaz
04:51:56 <lambdabot> Apocalisp says: data CanHaz a = Haz a | ButIEatedIt
04:52:06 <gwern> @quote your.baby
04:52:06 <lambdabot> Apocalisp says: You can't have your baby and eat it too
04:52:18 <gwern> @quote parametric.polymorphism
04:52:18 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
04:52:27 <gwern> @quote beginners
04:52:27 <lambdabot> mauke says: a hint to beginners: typing 'fix error' in ghci does not have the intended  effect
04:52:30 <gwern> @quote beginners
04:52:30 <lambdabot> mauke says: a hint to beginners: typing 'fix error' in ghci does not have the intended  effect
04:52:37 <gwern> @quote to.beginners
04:52:37 <lambdabot> mauke says: a hint to beginners: typing 'fix error' in ghci does not have the intended  effect
04:52:43 <sproingie> oooookay
04:52:51 <gwern> @quote confusing.to.beginners
04:52:51 <lambdabot> Cale says: Beginners are confusing to beginners. I move that we remove them from the language altogether.
04:52:54 <gwern> finally
04:53:16 <gwern> I sometimes wonder about lb's randomness - getting the mauke quote 3 times?
04:53:31 <mauke> maybe search is deterministic
04:53:31 <c_wraith> If there were only 2 that matched, that's 1/8
04:53:35 <c_wraith> not that rare
04:53:39 <gwern> @quote take.curry
04:53:39 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
04:53:41 <jmcarthur> gwern: can you prove it's not random? ;)
04:53:51 <gwern> jmcarthur: no. can it prove it is random?
04:53:54 <monochrom> heh
04:54:00 <gwern> @quote implementation.detail
04:54:01 <lambdabot> jmillikin says: [the real world is] an implementation detail of IO, pay it no mind
04:54:10 <gwern> @quote idiot.savant
04:54:10 <lambdabot> monochrom,ezyang says: The Principle Of Idiot Savant: any sufficiently misguided opinion is indistinguishable from deep insight
04:54:21 <gwern> ok, something's wrong there...
04:54:37 <gwern> @quote insane.scribble
04:54:37 <lambdabot> Cale says: I swear that most of higher-dimensional category theory must have been arrived at by some guys sitting around in a room with a blackboard and saying "What if a drew a diagram like *THIS*!?
04:54:37 <lambdabot> " and drawing some insane scribble up on the blackboard, and then everyone tries to figure out how to turn it into meaningful mathematics.
04:54:50 <gwern> @quote at.turing
04:54:51 <lambdabot> jbe says: Here I am, happy my code compiles, and the runtime is thumbing its nose at Turing.
04:55:02 <gwern> (what does that even mean?)
04:55:03 <sproingie> there ought to be a rate limiter
04:55:14 <gwern> @quote valid.haskell
04:55:14 <lambdabot> Ferdirand says: I was TA for a C++ programming course aimed at 1st year physics once. Some girl asked for help "i wrote pseudo-code but I cannot translate it to C++". Her pseudo-code was valid
04:55:14 <lambdabot> haskell. I cried.
04:55:19 <c_wraith> gwern:  that one was about the program dumping out <<loop>>
04:55:32 <bnijk_> how do you do regex search and replace in haskell
04:55:39 <gwern> c_wraith: ah. of course, no one said you couldn't write a very general loop detector...
04:55:43 <sproingie> bnijk_: Text.Regex
04:55:46 <bnijk_> i should probably just look this up
04:56:02 <gwern> c_wraith: after all, the halting problem is solvable for turing machines with bounded memory
04:56:08 <sproingie> @where hackage regex
04:56:08 <lambdabot> http://hackage.haskell.org/package/
04:56:10 <gwern> @quote morphasm
04:56:10 <lambdabot> mmorrow says: [regarding excessive use of categorical recursion schemes] a morphasm?
04:56:11 <sproingie> bah
04:56:21 <sproingie> @where rege
04:56:21 <lambdabot> I know nothing about rege.
04:56:22 <bnijk_> does lambdabot have text.regex
04:56:24 <Veinor> gwern: well yeah, but not practicaly :p
04:56:28 <gwern> @quote rollomorphism
04:56:28 <lambdabot> copumpkin says: I'm on a rollomorphism
04:56:48 <gwern> bnijk_: pretty sure mueval doesn't importat regexs
04:56:52 <bnijk_> :m +Text.Regex
04:56:54 <gwern> @quote rumour
04:56:54 <lambdabot> dons says: but rumours are remarkably common when it comes to haskell
04:57:03 <gwern> @quote chapter.10
04:57:04 <lambdabot> monochrom says: If you read a haskell book or an FP book, by chapter 5 it's already doing data structures. It's chapter 10 in imperative books.
04:57:04 <sproingie> , "foo" ~~ "fo+"
04:57:05 <lunabot>  luna: Not in scope: `~~'
04:57:12 <sproingie> , "foo" =~ "fo+"
04:57:13 <gwern> sure, but in chapter 10 we start covering IO!
04:57:13 <lunabot>  luna: Not in scope: `=~'
04:57:20 <sproingie> > "foo" =~ "fo+"
04:57:22 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
04:57:22 <lambdabot>                    ...
04:57:22 <gwern> @flush
04:57:28 <sproingie> ooh lambdabot has it
04:57:45 <sproingie> @type (=~)
04:57:46 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
04:57:51 <benmachine> > "foo" =~ "fo+" :: Bool
04:57:52 <lambdabot>   True
04:57:54 <sproingie> wowzers
04:57:56 <benmachine> > "foo" =~ "fo+" :: Int
04:57:57 <lambdabot>   1
04:58:00 <benmachine> > "foo" =~ "fo+" :: String
04:58:01 <lambdabot>   "foo"
04:58:03 <sproingie> oh i forgot =~ is crazy-overloaded
04:58:05 <benmachine> > "foo" =~ "fo+" :: [String]
04:58:06 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
04:58:06 <lambdabot>                    ...
04:58:10 <benmachine> aw
04:58:29 <benmachine> there's some array versions as well
04:58:32 <ddarius> > "foo" =~ "fo+" :: (String, [String])
04:58:33 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
04:58:33 <lambdabot>                    ...
04:58:38 <bnijk_> o_o
04:58:44 <medfly> CRAZY OVERLOADED
04:58:50 <sproingie> should get a version that works on the new text type
04:59:04 <WET_VIPER_CAQ> is books what good?
04:59:17 <benmachine> books are good
04:59:19 <bnijk_> lol
04:59:19 <medfly> @where lyah
04:59:19 <lambdabot> http://www.learnyouahaskell.com/
04:59:21 <bnijk_> @where LYAH
04:59:21 <lambdabot> http://www.learnyouahaskell.com/
04:59:23 <bnijk_> @where RWH
04:59:23 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:59:47 <WET_VIPER_CAQ> bnij,, why go "lol" as ot say: his engrish is bad, mixed with his question
04:59:50 * sproingie :: Crazy
04:59:53 <WET_VIPER_CAQ> would you rather me say: what is a good haskell book?
04:59:59 <wvc> dont assume im a foreigner
05:00:00 <wvc> lulz
05:00:05 <wvc> bigot!
05:00:09 <bnijk_> it was endearing
05:01:23 <bnijk_> surreal
05:01:44 <gwern> I found the regex libs to be really powerful, and unusable
05:01:48 <medfly> WET-VIPER-DONG, you're probably a foreigner to me
05:01:50 <gwern> they need serious doc work
05:02:12 <WET-VIPER-DONG> "medfly"
05:02:14 <WET-VIPER-DONG> where are you from
05:02:26 <medfly> the middle east :)
05:02:28 <wvc> i see
05:02:40 <wvc> my brain is fried, studying for an isc2 concentration
05:02:42 <wvc> issep bleh
05:02:53 <copumpkin> wow
05:03:23 <wvc> copumpkin, u should get into "l4d-2"
05:03:36 <copumpkin> wvc: haven't finished the first one yet
05:03:52 <wvc> the sequel is in
05:03:53 <wvc> new orleans
05:03:57 <medfly> what's l4d?
05:03:59 <wvc> left 4 dead
05:04:01 <medfly> ah
05:04:04 <wvc> on steam/pc
05:04:07 <copumpkin> anyway, #haskell-blah
05:04:18 <medfly> I thought it might be a set of lectures that I should bookmark :/
05:04:30 <wvc> pumpkin, freenode is notorious for information gatherers to be offended from "off topic" conversation
05:04:44 <sproingie> The Zombie Feynmann Lectures
05:04:48 <copumpkin> wvc: 600 people don't need to know about your viper dong or videogames
05:04:48 <wvc> information gatherers are typically 20-50 yr old males who learn anything about technology from q-basic to radar engineering etc
05:04:50 <bnijk_> oh my
05:04:54 <mauke> wvc: I am offended
05:04:56 <wvc> this whole irc network is information gatherers
05:05:08 <copumpkin> wvc: do you have a haskell question?
05:05:11 <medfly> what do I do if I don't fit this category of people
05:05:24 <Cale> wvc: Talk about Haskell, or get out. :)
05:05:25 <Badger> medfly: explode
05:05:28 <wvc> we stuff our brains with "information" like beavers stuff their cheeks w/ food/wood
05:05:30 * medfly implodes
05:05:39 <bnijk_> lol
05:05:45 <bnijk_> humans have a natural imperative to seek information
05:05:50 <bnijk_> when presented with any problem
05:05:56 <medfly> Cale, earlier I said that all off-topic discussions should be done in the following manner
05:05:57 <bnijk_> pertaining to their own survival
05:06:06 <wvc> how is learning programming pertaining to our survival?
05:06:13 --- mode: ChanServ set +o Cale
05:06:14 <bnijk_> wvc: puts food on the table
05:06:14 <wvc> all we need is clothes, a cave, and grain
05:06:16 <medfly> @let informationGatherer = "Someone who is 20-50 years old"
05:06:17 <lambdabot>  Defined.
05:06:22 <bnijk_> maybe even gets us wives ;)
05:06:22 <Cale> wvc: Do I need to repeat myself?
05:06:26 <copumpkin> wvc: you done rambling?
05:06:31 <medfly> Cale, I think this works.
05:06:40 <bnijk_> > isItCale "cale?"
05:06:41 <lambdabot>   Not in scope: `isItCale'
05:06:42 <wvc> cale, you are more then welcome to kick me, i have 15-20 shell accounts, ill come in under a diff nick and engage in conversation
05:06:47 <bnijk_> pfft
05:06:47 <medfly> haha, someone undefined it :)
05:06:53 <copumpkin> wvc: you'd be pathetic
05:06:56 <wvc> :)
05:07:01 --- mode: ChanServ set +o mauke
05:07:02 --- mode: mauke set +b *!*@user-24-236-92-14.knology.net
05:07:03 <medfly> wvc, Cale is here so much he doesn't mind banning each one
05:07:14 <mauke> surprise!
05:07:18 <medfly> isItCale?
05:07:19 <bnijk_> i wrote a song about wvc
05:07:22 <bnijk_> may he rest in peace
05:07:23 <bnijk_> http://omploader.org/vMno4MQ/trypt.mp3
05:07:34 <Cale> medfly: Too late, mauke had even less patience than I did :)
05:07:40 <medfly> Cale, :)
05:07:43 <medfly> Cale, read pm
05:07:57 <Cale> medfly: I did.
05:08:02 --- mode: mauke set -o mauke
05:08:06 <bnijk_> Cale: you should listen to it... and reflect on how you treated him
05:08:09 <medfly> I thought you'd be really excited about it.
05:08:11 <copumpkin> he said he's coming back!
05:08:13 <johnren> Enter text here...
05:08:17 <copumpkin> there he is
05:08:18 <johnren> ellow there
05:08:23 <medfly> no, I don't think so
05:08:28 <copumpkin> :P
05:08:29 <johnren> who can help  me in  solving  php problem?
05:08:33 <medfly> johnren, me
05:08:34 <johnren> hel pme please
05:08:34 <copumpkin> johnren: ##php
05:08:36 <Cale> johnren: This is #haskell though
05:08:38 <copumpkin> it's him
05:08:39 <johnren> im having a hard time
05:08:45 <johnren> doing my thesis
05:08:50 <bnijk_> lol
05:08:50 <Cale> johnren: Join ##php instead
05:08:51 <medfly> thesis in PHP?
05:08:52 <johnren> any  one there who  has  a good heart
05:08:53 <bnijk_> i'll help you johnren
05:09:02 <johnren> tnx
05:09:04 <Paczesiowa> damn trolls...
05:09:05 <copumpkin> it's awfully coincidental
05:09:05 <johnren> bn
05:09:06 * medfly actually uses PHP a bit
05:09:12 <bnijk_> jo
05:09:14 * copumpkin sighs
05:09:16 <johnren> bnjik
05:09:20 <bnijk_> johnren: !!!!
05:09:34 <BONUS> i didn't know saturday nights on #haskell were like this :)
05:09:35 <johnren> i am having a vard  time in searching with paging
05:09:38 <mauke> bnijk_, johnren: you are noise
05:09:38 <copumpkin> johnren: join ##php
05:09:41 <johnren> *hard
05:09:55 <bnijk_> message me johnren
05:09:59 <copumpkin> johnren: would you join ##furryfandom and ask about cooking?
05:09:59 <medfly> -johnren- VERSION PJIRC 2.2.1
05:10:02 <medfly> that's really the problem
05:10:09 <johnren> because  if i get the value it doesnt get the  space character mah friend
05:10:20 <Cale> johnren: this is offtopic here
05:10:28 <johnren> ok im sorry
05:10:29 <bnijk_> these conversations never go anywhere
05:10:36 <medfly> since when do people in this channel care about conversations being off topic
05:10:48 <mauke> when they annoy me
05:10:50 <copumpkin> medfly: when they're far off-topic we care, if you're talking about math or CS, then it's fine
05:11:05 <johnren> ok
05:11:06 <johnren> im sory
05:11:13 <medfly> johnren, how are you connecting?
05:11:15 <copumpkin> johnren: don't be, just look for help in the right place
05:11:16 <johnren> how can i join in php chat room?
05:11:20 <copumpkin> johnren: type /join ##php
05:11:25 <medfly> johnren, what website are you connecting from?
05:11:25 <johnren> im  so  sorry
05:11:30 <Cale> johnren: In any case, it's for your own sake, try ##php, there are people who care about PHP programming there :)
05:11:30 <medfly> copumpkin, PJIRC sucks
05:11:30 <bnijk_> Cale: are you listening to thote about WET_VIPER_DONG
05:11:39 <johnren> tnx cale
05:11:48 <sproingie> man they are all over the channel today
05:11:51 <bnijk_> the song i wrote about*
05:11:56 <Cale> bnijk_: no, I haven't
05:11:57 <johnren> very sorry beacuse im having a hard time here  and im  desperate
05:12:00 <johnren> c u agen guys
05:12:01 <johnren> tnx
05:12:02 <bnijk_> http://omploader.org/vMno4MQ/trypt.mp3
05:12:05 <copumpkin> johnren: good luck
05:12:11 <bnijk_> it's an elegy
05:12:26 <medfly> it's kind of lame declaring you have x shells and then connecting from PJIRC
05:12:36 <copumpkin> lol
05:13:04 <medfly> johnren, connect using http://java.freenode.net/ to ##php
05:14:22 <Berengal> I want to make an IRC client in pure HTML and server-side code.
05:14:28 <mauke> CGI:IRC?
05:14:30 <medfly> haha
05:14:38 <Berengal> Something like that
05:14:38 <johnren> ##php
05:14:39 <lunabot>  luna: parse error on input `]'
05:14:48 <johnren> ellow
05:14:49 <bnijk_> wow...if i have the transparency in urxvt and the right background image (which happens to be the regex cheatsheet), i have @ in this channel
05:14:52 * bnijk_ goes on a rampage
05:14:54 <medfly> johnren, http://java.freenode.net//index.php?channel=php
05:15:01 <Berengal> Pop up two frames, put an input form in one, and never really close the output of the other, so you can continue writing to it.
05:15:16 <mauke> isn't that exactly what CGI:IRC does?
05:15:42 <johnren> ellow there
05:15:46 <johnren> :D
05:15:54 <johnren> bnijk ellow
05:15:58 <Veinor> bnijk_: haha.
05:16:15 <johnren> :(
05:16:38 <johnren> how  can i join tophp room?
05:16:42 <johnren> how  can i join to php room?
05:16:47 <mauke> johnren: how did you join #haskell?
05:16:54 <bnijk_> johnren: just message me
05:16:56 <Paczesiowa> mauke: how much patience you've got left?
05:16:56 <medfly> johnren, I just gave you a direct link. if that doesn't work, then maybe you are trolling.
05:17:01 <sproingie> johnren: /quit
05:17:02 <johnren> i just cclick  it
05:17:03 <medfly> I am incredibly patient.
05:17:06 <johnren> im a newbie here
05:17:07 <mauke> johnren: click what?
05:17:08 <bnijk_> type "/msg bnijk (the problem you're having)"
05:17:13 <bnijk_> without the quotes
05:17:22 <bnijk_> .....
05:17:39 <medfly> I used PJIRC or something too, once.
05:17:52 * copumpkin still thinks this channel should be +s
05:18:11 <skorpan> emacs switching to bazaar, finally
05:18:31 <copumpkin> no more cathedral?
05:18:54 <sproingie> as if ESR ever named a qualitative difference
05:18:58 <copumpkin> it's ridiculous how much time a clueless IRC user can waste
05:19:04 <copumpkin> and how easy it would be to troll posing as one
05:19:16 <copumpkin> regardless of whether you get kicked, you'll have a dozen people telling you the same thing for 5 minutes
05:19:22 <sproingie> i suspect bazaar refers to the VCS
05:19:32 <Berengal> copumpkin: Remember when the computer was newfangled?
05:19:39 <medfly> copumpkin, come on. we're on IRC. we're begging to have our time wasted by such things
05:20:13 <bnijk_> enforcement of "offtopic" rules is a guaranteed time-waster
05:20:16 <Paczesiowa> can type errors always be pinned to an expression?
05:20:18 <bnijk_> better to just let the conversation go where it will
05:20:21 <copumpkin> on another network that I'm an IRC op on, I have a special /samove command
05:20:34 <medfly> what's a special /samove command
05:20:37 <sproingie> what's that do?
05:20:46 <copumpkin> it parts them from one channel and joins them to another
05:20:48 <copumpkin> saves hours
05:20:53 <medfly> haha
05:21:03 <copumpkin> it's just a combination of sapart and sajoin
05:21:03 <sproingie> interesting.  didn't know you could forcibly /join a client
05:21:21 <mauke> you can do everything if you control the server
05:21:33 <sproingie> i guess it has to work that way otherwise channel redirects wouldn't work
05:21:39 <medfly> it's kind of strange that clients cooperate, I guess they don't work the way I thought they do
05:21:53 <copumpkin> medfly: IRC is a remarkably stateless protocol
05:22:05 <ben> I think clients just have to assume that everything the server tells them is a reaction to something they did at some point in the past :V
05:22:23 <sproingie> the protocol is stateless, clients aren't necessarily.  but that sort of thing happens with redirects anyway
05:22:23 <medfly> very neat
05:22:23 <copumpkin> yeah, because there's no way to associate your actions to the server's responses
05:22:38 <medfly> :)
05:25:00 <Saizan_> Paczesiowa: a bit harder when the problem is that the type signature doesn't match the inferred type, which is why some "infinite type" error messages are so poor
05:25:48 <Paczesiowa> Saizan_: I just got an type error with dummy location and I thought it was weird
05:26:02 <Paczesiowa> Saizan_: and it wasn't occurs check related
05:26:13 <Saizan_> dummy?
05:26:21 <Paczesiowa> 1:0
05:31:28 <Paczesiowa> is Pepe Iborra here?
05:31:41 <copumpkin> don't think so
05:33:18 <Paczesiowa> copumpkin: do you know if he's related to Jose (or even the same person)?
05:33:26 <copumpkin> same person, afaik
05:34:13 <Paczesiowa> copumpkin: thanks
05:35:00 <copumpkin> yeah, http://www.google.com/profiles/pepeiborra links to a linkedin page that says his name is José
05:36:16 <fizruk> hello everyone! does yi irc channel exist?
05:36:24 <copumpkin> don't think so
05:37:03 <fizruk> "the #yi irc channel on freenode has about 20 people" - I found it on Yi blog...
05:37:17 <copumpkin> oh I guess there is one
05:37:19 <copumpkin> just /join #yi
05:37:20 <skorpan> yes, it exists
05:38:15 <fizruk> thanks
05:42:49 <Paczesiowa> how does naming free variables work in type checker? I have e:: (Foo l) => ... and foo e :: (Foo a) => ..., why did l become a?
05:42:55 <sm> hey all.. if anyone can give quick documentation feedback for hledger, I'd appreciate it. Good/bad/missing/ugly, where did you get lost or tune out.  http://hledger.org . Thanks!
05:44:10 <copumpkin> Paczesiowa: it inherits names from things you use it with
05:44:29 <copumpkin> :t (undefined :: Maybe weirdvar)
05:44:30 <lambdabot> forall weirdvar. Maybe weirdvar
05:44:45 <copumpkin> :t (undefined :: Maybe weirdvar) >>= (+1)
05:44:45 <lambdabot> forall b. (Num (Maybe b)) => Maybe b
05:44:51 <copumpkin> :t (+)
05:44:51 <Paczesiowa> copumpkin: but foo doesn't have explicit type sig
05:44:52 <lambdabot> forall a. (Num a) => a -> a -> a
05:44:59 <copumpkin> :t (>>=)
05:45:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:45:18 <xerox> sm: looks like it serves the page contents with the wrong encoding
05:45:44 <sm> xerox: you mean demo.hledger.org ?
05:45:47 <xerox> yes
05:46:00 <sm> yes, thank you
05:46:19 <xerox> http://img709.imageshack.us/img709/9195/schermata20091212a22393.png
05:52:24 <shazam> anyone know the article in which they prove that type inference in the presence of subtyping is undecidable?
06:02:03 <OscarZ> considering a typical computer program, how much of the meaning of the program is "embedded" in the program and how much stays in the mind of programmer?
06:04:38 <mahogny> OscarZ, which unit do you measure in?
06:04:59 <monochrom> Often, much specification is in the programmer.
06:05:34 <monochrom> If the program is buggy, the majority is in the programmer.
06:05:53 <OscarZ> mahogny: good point
06:06:12 <mahogny> the interesting parts of the specification is for sure diluted with all sorts of uninteresting language constructs
06:06:25 <monochrom> "f x = x + 1 what's wrong with this it doesn't work!"  He means the program has a bug. His mind wants to add 2, the program adds 1.
06:06:34 <mahogny> in a way, it is all in there. one interpretation of the meaning of the program
06:06:36 <OscarZ> What I'm after is that, is it possible to have a program that has a meaning in itself
06:06:55 <mahogny> exemplify
06:06:56 <monochrom> Yes.
06:07:04 --- mode: ChanServ set +o mauke
06:07:04 --- mode: mauke set -b *!*@user-24-236-92-14.knology.net
06:07:28 <OscarZ> that it would be feasible to think that an alien race would understand the program and what is the.. err... "meaning" of it...
06:07:39 <OscarZ> or does objective meaning as such exist at all
06:07:59 <monochrom> Nevermind alien. Just take another programmer.
06:08:04 --- mode: mauke set -o mauke
06:08:05 <OscarZ> hehe
06:08:41 <monochrom> Another programmer cannot know for sure the author's intention. But another programmer can be sure what the program ends up doing empirically.
06:08:58 <benmachine> 22:01:57 < OscarZ> or does objective meaning as such exist at all <-- this would be a difficult enough question without the context of programming
06:09:07 <benmachine> is there any meaning to anything?
06:09:27 <mahogny> well, do you agree on the platon philosophy?
06:09:33 <monochrom> "f x = x + 1" what is my intention?
06:09:37 <MarcWeber> dcoutts_: I don' think that the discussion does make very much sense because I'm looking for mainainers who dislike the idea and don't read the mailinglist. Do you think it would be feasable to contact them and create a list? Because this way I feel my idea is going nowhere.
06:09:40 <monochrom> A. I want to add 1.
06:09:56 <monochrom> B. I want to input the only even prime and get the first odd prime.
06:10:13 <olsner> I think you wanted to multiply by 2, just didn't bother implementing it for x != 1
06:10:19 <monochrom> My intention is B. You can't know it. But you can try A, and you are not wrong to.
06:11:10 <OscarZ> if we think about a simple bit... which can be 0 or 1 .. is it clear that its very subjective how one interprets it..
06:11:42 <OscarZ> by what means can complexity bring objectivity into this question ?
06:11:47 <monochrom> "0" "1" are already interpretations.
06:12:13 <OscarZ> you are right.. i ment a set of two different things ..
06:12:15 <Zao> Some interpret electrically low as 1.
06:12:16 <monochrom> You watch a dot on a screen. It is bright, not dark. Is that "0"? Is that "1"?
06:12:24 <Zao> And that's a concrete interpretation too.
06:12:51 <benmachine> I think programs are all communications of a sort, and their meaning is dependent on the writer and reader having the same idea of the language
06:13:10 <monochrom> It will turn out that bright is ⊤ and dark is ⊥, nothing to do with 0,1.
06:13:25 <benmachine> in that sense you can't really say that programs have any meaning in themselves
06:14:17 <monochrom> We are already divided on whether xml is meaningful. :)
06:14:48 <mahogny> XML sucks ass :P
06:14:49 <OscarZ> monochrom: XML? interesting, what is your take on that?
06:15:00 <monochrom> I use xml.
06:15:32 <monochrom> Sometimes I write simple raw xml myself.
06:15:36 <BMeph> That reminds me of another issue: equality on functions.
06:16:00 <mahogny> for an alien, understanding a program is a bit like finding a nail in a haystack, if you consider the universe of all potential logic (ignoring platon). it might not make sense at all until you find the magic interpretation
06:16:04 <medfly> check
06:16:22 <mahogny> or *a* magic interpretation
06:17:21 <OscarZ> mahogny: oh yeah about Platon.. i dont know much math myself.. but the idea of mathematical concepts as "real" in some kind of way seems appealing to me
06:17:54 <OscarZ> im trying to learn basically from stratch after some programming experience..
06:17:55 <Veinor> *Plato?
06:18:06 <mahogny> ah thanks
06:18:24 <OscarZ> Plato yes, sorry
06:18:30 <mahogny> I mainly consider plato for physics. I'm more of an intuitionist for math we've just made up
06:18:32 <Veinor> it's confusing cause of platonic :P
06:19:36 <OscarZ> at some point i thought that i want to learn math and whats it about... after reading GEB
06:20:01 <OscarZ> do you guys have some pointers of what particular parts of mathematics should one concentrate on ?
06:20:12 <OscarZ> to get a firm base on which to build
06:21:14 <mahogny> depends on what you want to use it for. philosophy or application?
06:21:35 <Cale> OscarZ: One of my favourite textbooks to start off with is "Calculus" by Michael Spivak.
06:21:47 <OscarZ> mahogny: very good point... philosophy :)
06:21:51 <Cale> OscarZ: You'll also want to learn some linear algebra, it's a good place to begin.
06:21:52 <mahogny> hm. that textbook was semi-evil IIRC
06:23:08 <OscarZ> Cale: interesting that you recommend things like that
06:23:11 <Cale> As far as philosophy of mathematics is concerned, I'm a formalist. I don't believe that mathematical ideas have any existence independent of us.
06:23:45 <Cale> and I don't believe that there's one true choice of axioms
06:24:01 <Cale> (though there are certainly advantages to agreeing to using the same axioms as each other)
06:24:36 <o234567890123456> whoa whoa what, wrong server
06:24:42 <OscarZ> Cale: but isnt it perfectly feasible that an alien race in this universe would come up with exactly same mathematical laws that we do, the same semantics ?
06:25:26 <Cale> OscarZ: It's possible, sure. That doesn't mean that there aren't other choices that are just as good.
06:25:49 <jmegner> I'm having a trouble getting runhaskell to recognize ctrl+d as signalling EOF
06:26:02 * ben trembles before the might of Cale
06:26:24 <jmegner> runhakell blah.hs <someFile works fine
06:26:39 <OscarZ> Cale: Empirically, isnt't the Platonic position more feasible.. why do you think it is not so ?
06:26:51 <shambler> we need a precendent to conclude, an alien invasion would be nice
06:26:56 <Cale> OscarZ: In what way?
06:27:17 <tensorpudding`> what guarantees do we have that the aliens will be able to communicate with us
06:27:32 <tensorpudding`> or have any inclination to do so
06:28:06 <tensorpudding`> they would probably be so advanced that we could not understand them
06:28:11 <monochrom> Among ourselves we already disagree on Num axioms.
06:28:32 <sm> xerox: fixed that one, at least if utf8 is being used. Thanks
06:28:42 <monochrom> Nevermind Monad vs Applicative
06:28:45 <OscarZ> Cale: What in our knowledge of the universe is there to believe that mathematical concepts and reasoning could be different in some other parts of the universe?
06:29:10 <Cale> OscarZ: Mathematical truths have nothing to do with physical observations.
06:29:41 <shambler> these are constructs of our minds
06:29:53 <Cale> OscarZ: There's no sense in which we can decide that some axioms are good or bad based on experiment.
06:29:54 <xerox> sm: good :)
06:30:02 <Cale> OscarZ: (or rules of inference)
06:31:12 <Cale> OscarZ: Now, surely there is a sense in which existing mathematics reflects the way in which humans think (and have thought), but that's all the more reason that you'd expect alien mathematics to be different.
06:31:55 <OscarZ> Cale: Interesting :)
06:31:57 <jmegner> How can I get runhaskell to recognize ctrl+d as eof?
06:32:24 <Cale> 1 + 1 = 2, not because of any physical observation, but because of the definitions we make regarding numbers.
06:33:25 <ray> yeah, in physical reality, 1 + 1 = 2.999999999999999999
06:33:29 <shambler> note how our world can be described in different ways by math, and there is no way to determine which way is more real than other
06:33:29 <Cale> heh
06:33:43 <Cale> shambler: yes
06:33:51 <Draconx> jmegner, runhaskell handles ctrl+d as expected here.  It might be useful to note that "ctrl+d" doesn't really mean "end of file".
06:34:09 <OscarZ> nteresting thoughts.. I thought
06:34:37 <Cale> Well, when it comes to making predictions about what we will see under various conditions, that's what science does, and that can be tested reasonably well.
06:35:03 <Cale> But that has nothing to do with mathematics except possibly in the use of mathematics to describe the predictions.
06:35:33 <jmegner> Draconx, perhaps I should give you a code snippet and tell me what is wrong with it
06:35:41 <jmegner> Draconx, what does ctrl+d mean then?
06:35:41 <Draconx> jmegner, the only thing ctrl+d does is causes the terminal to send any buffered data.  In the event that there is no buffered data, this causes a read to return zero.
06:36:22 <OscarZ> Ok.. so mathematics should be treated as some kind system (interesting in it's own right) but really not as a "building block" of reality
06:37:22 <Cale> OscarZ: at least, that's how I see it
06:37:29 <jmegner> Draconx, that does not jive with my understanding of ctrl+d on linux terminals
06:37:38 <Draconx> jmegner, try this: cat - - -
06:38:00 <jmegner> Draconx, anyway, how do I tell a haskell program that stdin has ended?
06:38:17 <Draconx> jmegner, experiment with various combinations of entering text, pressing enter, and pressing ctrl+d
06:38:20 <OscarZ> Cale: Why is it then that some parts of the physical reality are so well modeled by concepts of mathematics?
06:38:24 <Cale> OscarZ: If you try to tie mathematics down to reality, or what concepts are useful for describing existing observations, it's way too restrictive.
06:38:29 <McManiaC> ray: hehe
06:38:43 <Cale> OscarZ: Because people have spent a lot of time finding appropriate models.
06:38:53 <Draconx> jmegner, well, a read returning zero should cause functions like getLine to return early.
06:39:12 <idnar> sometimes those concepts are specifically developed for modelling parts of physical reality
06:39:28 <jmegner> draconx, if I press ctrl+d three times, I can exit "cat - - -"
06:39:33 <Draconx> jmegner, right.
06:39:43 <jmegner> Draconx, since I'm sending three eofs
06:39:59 <Draconx> jmegner, this is because if you do not enter any other text, the terminal has no buffered data, and reads return zero.
06:40:00 <idnar> yeah, that's not a great example
06:40:00 <ray> dumbferential lolquations
06:40:10 <idnar> but try "cat -" and then type "foo^D" with no enter
06:40:12 <Draconx> jmcarthur, try typing foo, without pressing enter, and press ctrl+d.
06:40:24 <Draconx> jmegner, how many times do you need to press ctrl+D to exit after doing that?
06:40:34 <Cale> OscarZ: Or, if the question is about why it's possible to construct models which predict the behaviour of things using mathematics as a general framework or language, well, the systems which are well-studied in mathematics are the patterns which humans are good at picking out.
06:41:30 <jmegner> draconx, so how do I gracefully terminate a program that is simply "main = do interact id"?
06:41:41 <jmegner> Draconx, when using stdin
06:41:51 <ray> look at the standard model
06:41:51 <c_wraith> enter, ctrl-d
06:42:02 <BONUS> hmm, how would you guys log a ghci session? like when you quit it, you have everything you've done in a .txt file
06:42:10 <ray> those particles are just mathematical fictions used as a model
06:42:15 <idnar> or ^D^D
06:42:17 <shambler> Cale, wow, that's deep
06:42:19 <erikc> is it just me or is uploading to hackage super slow?
06:42:20 <Draconx> jmegner, pressing ctrl+d when the terminal has no buffered data should do just that.
06:42:25 <shambler> ray, yeah
06:42:28 <erikc> (through the website)
06:42:45 <copumpkin> erikc: it was super slow for me too
06:42:51 <erikc> k
06:43:17 <jmegner> Draconx, I have pressed ctrl+d many times in a row and that does not work
06:43:29 <jmegner> Draconx, many combinations of ctrl+d and enter
06:43:39 <OscarZ> Cale: Interesting..
06:44:10 <jmegner> hmmm....now I'm getting weird ctrl+d behavior when just running cat
06:44:37 <Draconx> jmegner, your terminal might be in an abnormal state.
06:45:16 <jmegner> Draconx, wow, running 'main = do interact id' in runhaskell messes up my terminal
06:46:11 <dibblego> @hoogle findM
06:46:11 <lambdabot> Data.IntMap findMax :: IntMap a -> a
06:46:11 <lambdabot> Data.IntSet findMax :: IntSet -> Int
06:46:11 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
06:46:19 <jmegner> Draconx, 1) start terminal 2) ctrl+d works fine on cat 3) runhaskell blah.hs 4) quit haskell program 5) cat is messed up
06:46:27 <dibblego> @type find
06:46:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
06:47:20 <Cale> OscarZ: Of course, I don't believe in any sort of notion of absolute truth. At the very least, if there were a system which predicted events perfectly, I see no way that we could ever be certain that it did so, and even then, it wouldn't be part of mathematics, but a scientific model, because it makes predictions.
06:47:41 <jmegner> Draconx, I agree, running "main = do interact id" in runhaskell messes up my terminal
06:47:45 <Cale> But I see it as much more likely that no such system exists.
06:47:53 <Draconx> jmegner, sounds like a bug somewhere :)
06:47:54 <Cale> (and that's fine)
06:48:24 <jmegner> Draconx, a bug in runhaskell or somewhere in terminal land?
06:48:32 <Draconx> a system that predicts events perfectly obviously fails if events can depend on predictions.
06:48:36 <McManiaC> Cale: just curious, do you study math or aynthing?
06:48:42 <ray> and that's pine
06:48:50 <Cale> McManiaC: yes
06:49:11 <McManiaC> for how long? ^^
06:50:06 <Cale> McManiaC: Well, I suppose I started my BMath in 2001, and have continued studying mathematics since then. I was interested in mathematics for a couple years before that.
06:50:28 <McManiaC> ok
06:51:07 <Draconx> jmegner, yes :)
06:51:12 <McManiaC> im just interested when people start to argue like this…
06:51:18 <jmegner> Draconx, hmm, using ghc to compile 'main = do interact id' seems to work
06:51:29 <jmegner> Draconx, and does not mess up the terminal
06:51:34 <McManiaC> i study physics myself and i think theres a lot of rational reasons after those mathematical axioms
06:51:41 <jmegner> Draconx, where should I report the bug?
06:51:52 <mercury^> reasons after axioms?
06:51:56 <jlouis> I need to run some SHA1 digest on data of type String, returning the hex representation of the digest, also as a String. Suggestions?
06:52:07 <Draconx> jmegner, fwiw, runhaskell works fine for me with "main = do interact id", with ghc 6.10.4
06:52:16 <McManiaC> and as you stated earlier, maybe some "alian race" would define some other axioms, but I think they'd end up with the same "math"
06:52:21 <jlouis> Of course, converting to Bytestrings is an option :)
06:52:25 <jmegner> hm, I have 6.8.2
06:52:45 <jmegner> Draconx, I guess I can try that version
06:53:02 <Cale> McManiaC: Well, we don't even really have one mathematics.
06:53:22 <Cale> McManiaC: But a lot of incompatible mathematical systems, some of which are better-tended-to than others.
06:54:25 <Cale> This is something which is often abused by philosophers, but are you guys generally aware of Gödel's incompleteness theorems?
06:54:31 <Paczesiowa> jlouis: readProcess "sha1sum" [] myString
06:54:37 <McManiaC> hmm
06:54:38 <mercury^> I think he means the general kinds of compressions that we recognise, which are likely to be similar for other intelligence because compressions into low complexity are easy.
06:54:44 <jlouis> Paczesiowa: cheater :)
06:55:06 <mercury^> Cale: Kolmogorov complexity is much more interesting here I believe.
06:55:43 <Paczesiowa> jlouis: why cheater? are you looking for native sha haskell implementation?
06:56:18 <McManiaC> im not too deep into math, so no, I never heard of gödel or kolmogorov ^^
06:56:47 <jlouis> Paczesiowa: That would be closer to the goal, yes. I'll look at Data.Digest.Pure.SHA
06:57:16 <Paczesiowa> jlouis: oh, I thought that it was too slow or something
06:57:35 <mreh> what is a "standard reader monad"
06:57:45 <jlouis> Paczesiowa: speed is not really of the essence here (yet)
06:57:48 <Cale> McManiaC: Well, any mathematical system which is capable of making general-enough statements about arithmetic, either proves a contradiction (is inconsistent, which is bad because everything becomes both true and false and the system is sort of boring from that perspective), or there are statements P for which neither P, nor its negation is provable.
06:57:48 <BONUS> i'm reading GEB atm :)
06:57:53 <Cale> (it's incomplete)
06:58:09 <Paczesiowa> jlouis: because looking on hackage for package named "SHA" is pretty obvious first step:)
06:58:13 <mreh> BONUS: such a long book for not very much
06:58:21 <Cale> McManiaC: and when you run into a situation of that type, you could always add either P or its negation as a new axiom
06:58:39 <Cale> McManiaC: and this is just statements about natural numbers :)
06:58:39 <jlouis> Paczesiowa: true, but people might have some experience playing with them, hence me asking
06:58:44 <BONUS> mreh: could be denser at some parts but so far i'm liking the approachable feel to it
06:58:51 <mercury^> Any axiomatisable mathematical system.
06:59:01 <mercury^> Using non-probabilistic logic.
06:59:05 <tensorpudding`> is there any reason to read GEB after you already have a solid foundational knowledge in mathematics
06:59:15 <opqdonut> well it is entertaining
06:59:21 <mercury^> What's GEB?
06:59:22 <opqdonut> the dialogues especially
06:59:28 <BONUS> Gödel Escher Bach
06:59:32 <Cale> tensorpudding`: It's still quite entertaining, but maybe a little slow through the mathematics bit.
06:59:37 <BONUS> by Douglas R. Hofstadter
06:59:45 <Cale> tensorpudding`: It talks about a lot of other things though
07:00:11 <kmc> parts of it are pretty bs
07:00:23 <mreh> kmc: yes
07:00:25 <kmc> but it's worth reading at least for the presentation
07:00:32 <monochrom> Premature speculation of inefficiency is the root of all premature optimization.
07:00:41 <mreh> it's like reading dan dennett, pinker, all that crowd, all highly speculative and dull
07:00:50 <BONUS> premature optimization is the root of all awesome
07:01:01 <mercury^> And especially, premature optimization is often correct.
07:01:25 <monochrom> (I wish it's socially acceptable that I just get ahead and @remember myself saving you all the trouble. :) )
07:01:28 <ray> optimizing compilers are the root of all modern systems even being able to run
07:01:32 <monochrom> s/get/go/
07:01:42 <gwern> monochrom: you can privmsg lb
07:02:04 <gwern> mreh: you dislike speculative philosophy of mind? then maybe you'd enjoy thomas metzinger...
07:02:04 <ray> goodel, awescher, bachmazing
07:02:29 <mercury^> I'm so annoyed by the constant "Optimizing early is bad" and "Compilers optimize better than humans do."
07:02:31 <mreh> gwern: I like Kant's antimonies, and the Chinese Room argument, that's all I need to live by
07:02:43 <mreh> rational psychology is impossible
07:02:44 <gwern> you like the chinese room argument?
07:02:48 <gwern> mreh is dead to me. DEAD
07:02:54 <ray> RIP
07:03:08 <McManiaC> lol
07:03:22 <mreh> you're another starry eyed postgrad who things he's going to make AI
07:03:40 * gwern wishes I was even that
07:04:24 <monochrom> And you, another starry eyed human who thinks he's so smarter than other machines, nay, even other organisms.
07:04:47 <mreh> yes
07:04:57 <gwern> imagine, thinking meat!
07:05:13 <ray> thinking meat is impossible
07:05:16 <ray> and a bit disgusting
07:05:25 <mreh> i like meat
07:05:44 <gwern> ray: apparently they communicate by squeezing meat to make squelching sounds
07:05:45 <mreh> monochrom is a vegetarian
07:05:53 <BONUS> reading this chinese room thing, not convinced :[
07:05:57 <ray> typical
07:06:28 <Philonous> Apparently the type checker doesn't want to play with long types. "Context reduction stack overflow". I was just trying to multiply 9 by 0 on the type level :>
07:06:38 <Philonous> 9 by 9*
07:06:59 <ray> tell that baby type checker to stop crying like the little crying baby that it is
07:07:03 <mreh> BONUS: what if the man in the room memorised all the rules in the book
07:07:11 <mreh> does he understand chinese now?
07:07:17 <aavogt> Philonous: {-# OPTIONS_GHC -fcontext-stack=25 #-}
07:07:33 <aavogt> or maybe more...
07:07:53 <BONUS> mreh: i'd say no, but he is a sort of carrier for something that does
07:08:02 <BONUS> just like your neurons don't understand english
07:08:06 <Paczesiowa> iirc there's no point in making it too big, it'll eat your ram instead
07:08:16 <mreh> BONUS: are you your neurons?
07:08:34 <BONUS> i think so, yeah
07:08:36 <Philonous> Does that work in ghci? Because I'm at 1000 and it still complains
07:08:39 <kmc> john searle can suck my balls
07:08:51 <ray> the ball-sucking room argument
07:08:53 <monochrom> ghc memorizes all the rules in the book. I won't dwell on "understanding" without a mathematical definition. But ghc is more competent than me already.
07:08:55 <aavogt> well, those people we assume already know chinese probably don't know all the rules in the book
07:09:00 <mreh> strong AI can suck my balls
07:09:09 <Veinor> mreh: but can it do so as well as a human?
07:09:16 <Philonous> Is all that swearing really necessary?
07:09:22 <ray> most people speak a language, but only a few people are linguists
07:09:36 <mreh> Philonous: balls or Strong AI?
07:09:38 <copumpkin> polyglot?
07:09:57 <kmc> Chinese Room is argument by lack of imagination
07:10:00 <Paczesiowa> Philonous: it fails to typecheck ghci input?
07:10:16 <Paczesiowa> Philonous: if so, try to put that 9*9 as top-level value into .hs file
07:10:25 <mreh> it shows that a machine is not capable of understanding
07:10:34 <kmc> how does it show that?
07:10:56 <kmc> and why can the same argument not be applied to a human?
07:11:00 <kmc> which after all is a type of machine
07:11:00 <BONUS> mreh: i would say that it is wrong since we are, by definition, capable of understanding (well some of us) and we are essentially machines
07:11:04 <Philonous> Paczesiowa: That worked. Thanks!
07:11:13 <b0fh_ua> Hi there! Can somebody please help me to understand this definition of `on` function: on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:11:20 <kmc> b0fh_ua, that's not the definition
07:11:23 <kmc> that just gives the type
07:11:24 <kmc> @src on
07:11:25 <lambdabot> (*) `on` f = \x y -> f x * f y
07:11:26 <mreh> BONUS: are we? that is an apriori that you've supplied
07:11:32 <b0fh_ua> sorry, a type
07:11:42 <Philonous> Now, 9*9*9 really fried it.
07:11:43 <mreh> you can't assume what you set our to prove
07:12:01 <b0fh_ua> what I understood is that it takes 2 functions and 2 parameters?
07:12:08 <Paczesiowa> Philonous: ghci often has different set of extensions than your file loaded
07:12:25 <kmc> b0fh_ua, the functions are parameters
07:12:26 <BONUS> mreh: hmm. what would you say is the difference between man and machine?
07:12:29 <Paczesiowa> Philonous: stack limit? ram? cpu?
07:12:35 <Philonous> Lo and behold, after careful consideration it arrived at an answer.
07:12:40 <kmc> b0fh_ua, it might be more readable as the equivalent type:  (b -> b -> c) -> (a -> b) -> (a -> a -> c)
07:12:52 <mreh> BONUS: men make machines
07:12:58 <copumpkin> machines make men
07:13:06 <Philonous> Maybe I'd rather not query the type of this monster
07:13:07 <b0fh_ua> still some sort of voodoo
07:13:09 <gwern> (chinese room is an intuition pump - *surely* such an odd machine doesn't *really* understand, while we humans do?)
07:13:10 <BONUS> that's the whole difference?
07:13:33 <kmc> a human is a really odd machine
07:13:34 <mreh> gwern: you stole that from denett
07:13:36 <kmc> it's made of meat
07:13:41 <gwern> mreh: I did, yes
07:14:00 <BONUS> b0fh_ua: consider (*) `on` (+1)
07:14:03 <mreh> gwern: dennet is the master of assuming what he sets out to prove
07:14:03 <gwern> (more specificall, I stole the 'intuition pump', though not the description, IIRC)
07:14:14 <kmc> consciousness explained [away]
07:14:19 <kmc> let's go to #haskell-blah with this
07:14:26 * mreh high fives kmc
07:14:28 <gwern> mreh: and what precisely is unfair about the characterization of the chinese room argument as an ppeal to intuition?
07:14:31 <BONUS> (*) `on` (+1) is like (*), only (+1) is first applied to each argument
07:14:54 <mreh> gwern, all the arguments against it are appeals to intuition
07:15:06 <b0fh_ua> BONUS: that's what I understand. The problem is that I don't understand that type definition
07:15:08 <ray> no, that's all the arguments for it
07:15:15 <gwern> it is an appeal to intuition, what non-intuitive arguments can be used against it?
07:15:20 <ohday_> BONUS: Do you have any plans on working on the sections that are incomplete for LYAH soon?
07:15:20 <ohday_> The monad section et al
07:15:42 <BONUS> ohday_: yup. working on them over the holidays and such
07:16:13 <BONUS> i'm also going over the old chapters with an editor an mmorrow to get them ready for print, so the new chapters aren't going as fast as the previous ones, but they'll get there :)
07:16:37 <gwern> oh, is the book thing still happening?
07:17:03 <kmc> BONUS, you're bookifying LYAH?
07:19:15 <BONUS> kmc: yup :)
07:19:20 <kmc> nice
07:19:24 <BONUS> official announcement coming soon, but for now it's unofficial
07:20:44 <ohday_> BONUS: cool
07:20:45 <stoop> http://fp-syd.googlegroups.com/web/haskell-hubris.pdf
07:21:09 <stoop> heard about this from ohday_ :)
07:21:21 <jlouis>  /12
07:23:08 <stoop> nm, it's boring
07:23:40 <copumpkin> stoop: shh, the author is here :P
07:23:54 <copumpkin> well, not right now, but often
07:25:35 <Veinor> stoop: I don't get the jruby vs ghc slide
07:26:03 <stoop> Yeah, nevermind. :-P
07:26:07 <stoop> copumpkin, ah, ok. :-P
07:26:21 <stoop> Well, I just heard "backdoor" and I thought it could be slightly interesting to me. I'm just not interested in Ruby.
07:26:30 <copumpkin> Veinor: it uses the weird exposition that the shootout uses
07:26:34 <copumpkin> stoop: you like the backdoor?
07:27:29 <Veinor> copumpkin: wait, what?
07:27:33 <ohday_> Looks like its wrapped in ruby
07:27:46 <copumpkin> Veinor: http://shootout.alioth.debian.org/
07:28:11 <stoop> copumpkin, only yours.
07:28:17 <copumpkin> aw
07:28:20 <stoop> <3
07:28:41 <Veinor> so, jruby is 319 times slower than haskell at mandelbrot?
07:28:48 <copumpkin> yeah
07:28:54 <copumpkin> well, than ghc
07:29:03 <copumpkin> lest one of the implementation vs. language people jump on you
07:29:14 <Veinor> well, yeah
07:29:38 <Veinor> hm, that's not what the shootout stuff says
07:29:49 <Veinor> oh, my mistake, that's java 6 vs haskell
07:30:09 * ohday_ wonders about the competition between hugs and ghc
07:31:16 <ohday_> if there's any.
07:31:29 <Veinor> haskell is pretty fast :D
07:31:38 <copumpkin> conal: did you see the GADT syntax for families in 6.12.1?
07:31:44 <copumpkin> conal: http://haskell.org/ghc/docs/6.12.1/html/users_guide/release-6-12-1.html
07:32:09 <CalJohn> ohday_: hugs is slow by that metric
07:32:23 <ohday_> ah.
07:32:57 <conal> copumpkin: i hadn't.  will check it out.  thanks!
07:35:07 <copumpkin> has anyone tried installing 6.12.1?
07:35:16 <copumpkin> does cabal-install work with it yet?
07:36:02 <Paczesiowa> copumpkin: is it final release?
07:36:12 <Paczesiowa> copumpkin: it's not listed as stable on ghc's website
07:36:13 <copumpkin> Paczesiowa: supposedly, but no official announcement as far as I can see
07:36:26 <copumpkin> http://haskell.org/ghc/download_ghc_6_12_1.html
07:36:44 <copumpkin> not really sure what's going on
07:40:50 <Philonous> copumpkin: the links to the distributions are 404s
07:41:16 <copumpkin> oh yeah
07:41:24 <copumpkin> I guess the release date is wrong :)
07:49:09 <dibblego> how can I satisfy the GHC warning about `(.) (+) read` which causes Warning: Defaulting the following constraint(s) to type `Integer'?
07:49:31 <gwern> add a type sig?
07:49:40 <dibblego> it's in the body of a function
07:49:49 <dibblego> I could pull it out and add a type sig
07:49:49 <gwern> write it as (\x -> (.) (+) read) :: Int ?
07:50:39 <ben> That looks wrong
07:50:56 <Paczesiowa> dibblego: you can annotate any expression: (.) ((+):: Int -> Int -> Int) read
07:51:19 <aavogt> @type (+) . read
07:51:20 <lambdabot> forall a. (Num a, Read a) => String -> a -> a
07:51:29 <dibblego> that works thanks
07:51:59 <Paczesiowa> I'm suprised you didn't know that:)
07:52:11 <dibblego> I did; I just thought there was a more typical way
07:52:29 <dibblego> i.e. something less clumsy
07:53:02 <HaskellLove> Data Y = 1 | 0  What is wrong with this?
07:53:03 <Paczesiowa> you can apply something to monomorphic function
07:53:03 <aavogt> @type \s x -> (+ (x `asTypeOf` (undefined::Int))) $ read s
07:53:04 <lambdabot> String -> Int -> Int
07:53:21 <aavogt> :t asTypeIn
07:53:22 <lambdabot> forall a b. a -> (a -> b) -> a
07:53:34 <Paczesiowa> HaskellLove: constructors must start with capital letter (or :)
07:54:07 <aavogt> @type asTypeIn (undefined::Int) . ((+) . read)
07:54:08 <lambdabot> String -> Int
07:54:08 <Paczesiowa> HaskellLove: data Y = I | O
07:54:30 <aavogt> @index asTypeIn
07:54:31 <lambdabot> bzzt
07:54:36 <aavogt> @hoogle asTypeIn
07:54:36 <lambdabot> No results found
07:55:13 <Baughn> @ask ivanm http://trac.haskell.org/haskellmode-emacs/ticket/12#comment:3 <-- Comment? Yes, please.
07:55:13 <lambdabot> Consider it noted.
07:55:23 <HaskellLove> Data Y = One a | Zero b Paczesiowa why that does not work?
07:55:38 <Paczesiowa> HaskellLove: what are a and b?
07:55:39 <ben> what is a and b?
07:55:49 <aavogt> > (asTypeIn (undefined::Int) . ((+) . read)) "1" 2
07:55:50 <lambdabot>   Couldn't match expected type `t1 -> t'
07:55:50 <lambdabot>         against inferred type `GHC.T...
07:56:08 <Paczesiowa> HaskellLove: that would be very advanced use (existential type) - I'm sure it's not what you mean
07:56:26 <aavogt> oh, right, asTypeIn is just another variation of const
07:56:31 <Paczesiowa> HaskellLove: do you want Bit type?
07:56:53 <HaskellLove> Paczesiowa>so i have to add where to that? no bit type i just experiment with Data
07:57:15 <Paczesiowa> HaskellLove: data Y a b = One a | Zero b (but that's just Either)
07:57:36 <copumpkin> aavogt: yeah, but it constrains the types more
07:57:38 <HaskellLove> Paczesiowa>	ok
07:57:58 <Paczesiowa> HaskellLove: or data Y = forall a. One a | forall b. Zero b (but that's something entirely different)
08:03:34 <napsy_> Is haskell pronounced with "hashkell" or just "haskell"?
08:03:50 <Zao> Hashell?
08:04:04 <Taejo> napsy_: just haskell
08:04:04 <gnuvince> napsy_: Hass-kell
08:04:17 <mauke> it's pronounced "throatwarbler-mangrove"
08:04:23 <MarcWeber> dcoutts_ told me that depreceating packages on hackage can be done. Is there someone who can tell me how this works exactly?
08:04:58 <napsy_> hm I'm asking because I've heard people saying "hashkell"
08:05:15 <mauke> .oO( sibboleth )
08:05:43 <Philonous> Some people say "linnix" to linux
08:06:19 * Baughn says "has-kyll"
08:06:43 <ente> häskyll?
08:06:51 <napsy_> hm ok
08:06:58 <Baughn> ..probably goes well with hIDE
08:07:05 <ente> häskyll brucks körri
08:07:55 <OscarZ> What is meaning in context of haskell programs ?
08:11:54 <chrisdone> I always thought it was named after the crustaceans; krill
08:12:11 <chrisdone> @faq has krill adapted to the harsh antarctic environment?
08:12:11 <lambdabot> The answer is: Yes! Haskell can do that.
08:12:27 <thieusoai> hi is there a way to make this more compact    case t of  a ->  "string1"  ; b-> "string1"  ; c -> "string1" ;d -> "string2"   ?   basically I want to do something like   case t of  {a,b,c} ->  "string1"
08:12:32 <chrisdone> Yes! Hȧs Krill can do that.
08:12:41 <hopthrisC> somebody willing to help me meta-solve my university assignment?
08:12:58 <hopthrisC> i've been given a bunch of test cases to verify my implementation
08:13:06 <chrisdone> thieusoai: case t of any (==t) ["string1","string2"] -> ..
08:13:15 <hopthrisC> like "for (\n -> n*3) 5 2 == 486"
08:13:16 <chrisdone> with valid syntax
08:13:28 <chrisdone> I can't type anymoe, rsi setting in
08:13:36 <hopthrisC> can i evaluate a string at runtime?
08:13:37 <kpreid> thieusoai: the details of how to accomplish that depend greatly on what the actual case patterns are
08:13:54 <hopthrisC> i don't think i have much more than prelude to work with, though
08:13:56 <thieusoai> chrisdone: ic -- thanks
08:14:00 <kpreid> hopthrisC: then no
08:14:12 <hopthrisC> k. thanks
08:14:21 <hopthrisC> this assignment suuuuuuucks
08:14:27 <kpreid> it is possible, but complicated and plugin-requiring, to eval
08:14:30 <copumpkin> thieusoai: yes, if that's your specific case
08:14:33 <kpreid> why do you need to evaluate strings?
08:14:49 <copumpkin> thieusoai: case t of D -> "string2"; _ -> "string1"
08:14:49 <copumpkin> :P
08:14:55 <kpreid> hopthrisC: if you have such test expressions why not just not quote them and run them?
08:15:19 <hopthrisC> kpreid: i want to turn the test cases into a script that prints the expressions which are false
08:15:30 <hopthrisC> which evaluate to false, i should say
08:15:33 <benmachine> strictly speaking it should be possible to implement a haskell interpreter in the prelude :P
08:15:36 <kpreid> if you want them labeled, then I'd just write a preprocessor -- e.g. takes input lines like "a == b" and writes out ("a == b", \a b -> a == b")
08:15:36 <benmachine> but I don't recommend it
08:15:43 <medfly> how do you know what evaluates to false?
08:15:58 <chrisdone> thieusoai: oh, completely misread what you said. just use ||? case t of a || b -> "string1"?
08:16:01 <kpreid> and then feed that into your haskell compiler
08:16:12 <copumpkin> chrisdone: that works?
08:16:13 <chrisdone> thieusoai: err. case t of a | a || b -> "string1"
08:16:19 <copumpkin> oh
08:16:23 <copumpkin> a guard
08:16:25 <hopthrisC> kpreid: yes, i can do that easily
08:16:27 <copumpkin> then you'd need some ==
08:16:31 <benmachine> guards are the usual way yes
08:16:36 <benmachine> oh I am so vague
08:16:37 <copumpkin> or a `elem` [x,y,z]
08:16:48 <benmachine> ignore what I said, everyone
08:16:52 <kpreid> hopthrisC: I wouldn't recommend trying to do it in a different way, for now
08:16:59 <benmachine> it is not worth the effort to make comprehensible
08:17:52 <hopthrisC> kpreid: i just thought i might as well actually _learn_ some haskell, if i have to waste my time on this stupid course
08:17:52 <chrisdone> benmachine: do you want a platonic man hug?
08:17:52 <benmachine> chrisdone: always.
08:17:52 <chrisdone> /^_^/
08:17:52 <hopthrisC> kpreid: stupid, because the course is stupid, not because haskell is stupid, mind you
08:17:52 <benmachine> \^_^\
08:17:54 <chrisdone> yay
08:18:01 <copumpkin> {-_-}
08:18:14 <hopthrisC> medfly: every testcase is of the form a == b
08:18:15 <kpreid> hopthrisC: it's been a while since I've done any serious haskell, but last I knew the tool for evaling was hs-plugins
08:18:18 <ente> [-_-]
08:18:18 <hopthrisC> medfly: or what do you mean?
08:18:19 <zong_sharo> read the iteratee stuff
08:18:44 <zong_sharo> it's left-fold, so no way to implement with iteratees something like echo server
08:18:47 <zong_sharo> right?
08:18:52 <hopthrisC> kpreid: thanks for the help!
08:18:58 <kpreid> hopthrisC: also, maybe the test frameworks like quickcheck have something for you
08:19:07 <benmachine> kpreid: not mueval?
08:19:21 <zong_sharo> my guess, this is possible with right-fold enumerators
08:19:36 <zong_sharo> does any revelant papers exists?
08:19:45 <kpreid> benmachine: I don't know what that is
08:19:56 <benmachine> mueval is what lambdabot uses for @run
08:20:11 <benmachine> I'm not sure if it is available as a library or just an executable
08:20:23 <kpreid> I thopught lambdabot used hs-plugins
08:20:32 <kpreid> maybe I'm confused about what pieces are called what
08:20:33 <benmachine> > fix id
08:20:36 <lambdabot>   mueval-core: Time limit exceeded
08:20:43 <benmachine> mueval is involved somehow
08:20:50 <benmachine> maybe they're different names for the same thing, I don't know
08:23:20 <benmachine> it might be that we (I say we as if I had anything to do with it ever) switched to mueval in a separate process rather than hs-plugins because it was safer
08:23:51 <HaskellLove>  Non-exhaustive patterns in function last -------------- that is the error I get what does it mean?
08:24:23 <kpreid> HaskellLove: the arguments given did not match the patterns of the function definition
08:24:46 <Berengal> > last []
08:24:47 <lambdabot>   * Exception: Prelude.last: empty list
08:24:52 <HaskellLove> let last (_:xs) = last xs ................   let last [x] = x......... and then i say last [1,2,3,4]
08:25:16 <Berengal> Are those the same lasts?
08:25:23 <Berengal> Or did you redefine it?
08:25:31 <benmachine> HaskellLove: the first pattern matches with higher priority than the second
08:25:32 <kpreid> HaskellLove: you have to define both cases in the same 'let', or you're redefining it
08:25:58 <benmachine> so [x] matches against (_:[]) and results in last []
08:26:02 <HaskellLove> Berengal> same function but for different arguments
08:26:05 <benmachine> instead of matching against [x] and giving you x
08:26:14 <benmachine> last [] doesn't have a pattern defined
08:26:16 <benmachine> hence the error
08:26:26 <Berengal> HaskellLove: Then know that the first case will match anything that isn't an empty list before the second case gets a chance.
08:26:28 <HaskellLove> kpreid, oh I see, let me try
08:28:21 <kpreid> HaskellLove: But it's also true that if you keep them in that order, it will fail as benmachine and Berengal described
08:28:33 <HaskellLove> let last [x] = x; last [_:xs] = last xs; last [] = Nothing ------- hmm i get errors here too
08:28:57 <benmachine> HaskellLove: that's because you've changed (_:xs) into [_:xs] for no good reason :)
08:28:58 <kpreid> you'd have to either put the [x] case first or make the first case (_:xs@(_:_))
08:29:00 <sproingie> HaskellLove: last (_:xs)
08:29:09 <sproingie> i do that all the time myself
08:29:18 <sproingie> thank FSM for flymake
08:29:21 <kpreid> HaskellLove: that will not typecheck anyway unless the list is a list of Maybes
08:29:35 <HaskellLove> oops sorry :) thanks
08:30:28 <HaskellLove> kpreid> u r correct i get errors when i execute... let me try fix it
08:31:22 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14065#a14065
08:31:58 <kpreid> As I said, your current definition requires it be a list of Maybes.
08:32:21 <kpreid> Because in one case it returns an element, and in another it returns Nothing, so the elements of the lists must be Maybes
08:33:13 <sproingie> let last [x] = Just x ...
08:33:27 <sproingie> that's probably what you're looking for
08:34:52 <HaskellLove> sproingie thanks, kpreid yes i sent it cause i did not know how to do it... thanks guys
08:44:39 <HaskellLove> let secondToLast [] = Nothing; secondToLast [x] = Nothing; secondToLast (x:y) = Just x; secondToLast (x:xs) = secondToLast xs;
08:45:05 <kmc> HaskellLove, (x:y) and (x:xs) are the same pattern except for renaming variables
08:45:25 <kmc> variables whose names end in 's' are not in any way special
08:45:35 <HaskellLove> got it let me fix it
08:45:48 <dmead> ello channel
08:46:01 <kmc> hi
08:46:45 <HaskellLove> kmc oh my god it works i wrote my own secondToLast function :D
08:47:10 <kmc> oh em gee
08:59:49 <BMeph> Are functions that do the same thing by different ways the same? :)
09:00:28 <benmachine> BMeph: depends on why you care
09:00:37 <tommd> Depends your pov, doesn't it?  I would say no, but I'm a jerk.
09:00:38 <Elench> Yes, also no
09:00:43 <dibblego> extensionally equivalent
09:01:02 <benmachine> I would say no if you're talking about optimising your program, for example, but perhaps yes if you are talking about proving properties of your code
09:01:19 <HaskellLove> BMeph i think such question can not have a simple answer as yes or no, it all depends what you want in what case
09:02:42 <tommd> benmachine: That sentence has an assumption about the properties that need proven and their relation to what is different between the functions.
09:02:48 <olsner> hmm, this is weird, if I specify up to about 2.5MB of heap with +RTS the program stops immediately with "heap exhausted" - if I specify any more (e.g 3MB) it allocates all available RAM instead of respecting the set limit
09:02:59 <benmachine> tommd: it also has a perhaps :)
09:03:23 <tommd> Perhaps he had functions that both wouldn't return but one would halt the system while the other would run nop's... and the goal is to heat the room.  Then we could kill him.
09:03:55 <benmachine> they don't do the same thing then do they?
09:04:13 <tommd> Certainly not, but far as I'm concerned both are _|_ :-)
09:05:07 <kmc> mathematically, they are the same
09:05:39 <benmachine> hmm
09:05:47 <benmachine> I suppose so
09:05:50 <kmc> we write "f(x) = y" as a shorthand for "(x,y) \in f"
09:06:05 * benmachine takes refuge in his use of perhaps
09:06:12 <kmc> and so the set of all (input,output) pairs is irrelevant of how the function is defined in notation
09:06:18 <mreh> does ghc only do static linking?
09:06:27 <kmc> it can do dynamic now
09:06:30 <tommd> mreh: No, not anymore.
09:06:33 <kmc> or soon?
09:06:45 <tommd> For example, IHG recently got the RTS dynamically linking.
09:06:50 <tommd> Thank goodness.
09:07:05 <mreh> ghc is blocking on "Linking Main..."
09:07:26 <tommd> Which ghc?
09:07:28 <mreh> oh, its done!
09:07:28 <kmc> when people talk about "extensional equivalence" of lambda-terms, what they mean is that the denotations of those terms (the translation from lambda-calc AST into actual math function) are the same function
09:07:31 <mreh> that took ages
09:07:33 <tommd> yay
09:07:51 <Philonous> Why do mathematicians distinguish between a function and it's graph? What's the difference between the two?
09:08:02 <tommd> One exists
09:08:10 <kmc> whereas "intensional equivalence" means structural equality of the lambda calculus syntax i believe
09:08:13 <kmc> possibly up to alpha-renaming
09:08:42 <mreh> 2.7MB for a crappy game of asteroids!
09:08:49 <benmachine> Philonous: if you have a function that takes a set and produces its powerset, it's pretty difficult to graph that
09:08:58 <kmc> Philonous, what do you mean by the graph of a function?
09:10:05 <Philonous> kmc: Typically, the graph g of a function f is defined as the set of all pairs g = (x,y) such that f x = y
09:10:30 <Philonous> g = { (x,y) } *
09:10:36 <kmc> it's just a matter of notation then
09:10:44 <kmc> we want to say f(x) = y rather than (x,y) \in f
09:10:50 <kmc> so we give the two uses of "f" different names
09:12:31 <olsner> mmkay, rebuilt with RTS debugging, running with -DG and -Dg I'm getting loads of printouts about "allocated 2 megablock(s)" - but never anything about running a GC
09:21:15 <HaskellLove> I have a list of tuples. I need to test if some of the tuples contains negative elements, any sugestions what functions to use?
09:21:33 <dibblego> @type any
09:21:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:21:50 <kmc> any, (< 0)
09:22:02 <kmc> HaskellLove, tuples of what length?
09:22:08 <kmc> how many elements in the tuple, i mean
09:22:17 <copumpkin> @free any
09:22:18 <lambdabot> any . (.) f = (.) (any f) . $map
09:22:35 <ray> @free (&&&)
09:22:35 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
09:23:00 <benmachine> uncurry ((||) `on` (< 0))
09:23:01 <HaskellLove> kmc> the tuples are of type (x,y) and the list contains 3 of them
09:23:07 <ziman> @free fmap
09:23:08 <lambdabot> Expected variable or '.'
09:23:18 <ray>  i
09:24:40 <HaskellLove> copumpkin free command in what module, there are several?
09:25:02 <kmc> HaskellLove, did you read the documentation for Data.List?
09:25:07 <kmc> plenty of useful functions there
09:25:09 <copumpkin> probably http://hackage.haskell.org/package/free-theorems
09:25:35 <HaskellLove> kmc>yes i just wanted to hear from you too
09:25:46 <HaskellLove> ok i will do any and map
09:25:58 <benmachine> :t uncurry
09:25:59 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:26:06 <benmachine> if you're using any I don't think you need map
09:26:11 <benmachine> @src any
09:26:14 <lambdabot> any p =  or . map p
09:26:31 <aavogt> @free const
09:26:32 <lambdabot> f . const x = const (f x) . g
09:26:50 <kmc> > any (<0) . concatMap (\(a,b) -> [a,b]) $ [(1,2), (3,4)]
09:26:51 <lambdabot>   False
09:26:58 <kmc> that will work only if the tuple elements are the same type
09:27:37 <mauke> > any (\(x,y) -> x < 0 || y < 0) [(1,2), (3,4)]
09:27:38 <lambdabot>   False
09:27:42 <aavogt> you can unzip and then have a list of the fst and the snds
09:28:31 <HaskellLove> copumkin I did not understand any from the free theorems thing... i will leave it seems complex
09:28:47 <aavogt> > (any (<0) *** any (<0)) $ unzip [(1,2), (3,0)]
09:28:48 <lambdabot>   (False,False)
09:28:54 <aavogt> > (any (<0) *** any (<0)) $ unzip [(1,2), (3,-1)]
09:28:55 <lambdabot>   (False,True)
09:29:26 <aavogt> > (any (<0) *** any (<0)) $ unzip ([(1,2), (3,-1)] :: [(Double,Int)]) -- to make the point
09:29:27 <lambdabot>   (False,True)
09:30:00 <dibblego> > join (***) (any (<0)) $ unzip ([(1,2), (3,-1)] :: [(Double,Int)]) -- to make the point
09:30:01 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
09:30:01 <lambdabot>         against inferred ty...
09:30:15 <dibblego> > (join (***) (any (<0))) $ unzip ([(1,2), (3,-1)] :: [(Double,Int)]) -- to make the point
09:30:16 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
09:30:16 <lambdabot>         against inferred ty...
09:30:19 <dibblego> bleh
09:30:36 <dibblego> that is the point isn't it
09:30:52 <aavogt> I'm not sure anymore
09:31:04 <kmc> :t (, True)
09:31:05 <lambdabot> parse error on input `True'
09:31:27 <dibblego> any (<0) *** any (<0) has a more general type than join (***) (any (<0))
09:31:41 <kmc> ghc 6.12.1 manual says that tuple sections are "Python-style"
09:31:48 <kmc> i'm unaware of a similar feature in Python
09:31:56 <luite> has 12.1 been released now?
09:32:07 <mauke> kmc: (42,)
09:32:26 <kmc> but that's not \x -> (42,x)
09:32:34 <kmc> and it only works for the singleton tuple
09:32:39 <copumpkin> huh?
09:32:41 <mauke> right
09:32:43 <kmc> in Python
09:32:45 <copumpkin> oh
09:32:53 <luite> are tuple sections new in 6.12?
09:32:54 <kmc> it's not a similar feature
09:32:55 <kmc> yes
09:32:58 <copumpkin> (3,2,,,2,1,6,2,,3,5)
09:33:00 <kmc> and it's not out yet
09:33:23 <luite> oh, didn't realize that. I 'discovered' them a few weeks ago, found them handy in some cases
09:34:24 <kmc> cool 6.12 has GADT data instance declarations
09:34:29 <kmc> that should explode some heads
09:34:43 <HaskellLove> aavogt>	I will stick to map and any do it somehow... the *** thing i dont know it yet, it is arrows and monads stuff i am not there yet :)
09:35:00 <kmc> HaskellLove, you're sure you don't want "any"?
09:35:01 <kmc> @src any
09:35:01 <lambdabot> any p =  or . map p
09:35:05 <kmc> @src or
09:35:06 <lambdabot> or    =  foldr (||) False
09:35:17 <ray> :t any
09:35:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:35:27 <HaskellLove> kmc>yes i said will do it now with map or any ...
09:35:31 <ray> i think that is more informative
09:35:43 <ray> > any (>5) [1..4]
09:35:44 <lambdabot>   False
09:35:47 <ray> > any (>5) [1..6]
09:35:48 <lambdabot>   True
09:35:50 <kmc> well i wanted to point out that any is map + something additional
09:36:22 <aavogt> HaskellLove: (f *** g) is just a shortcut for:   (\(x,y) -> (f x,g y)), in that use case there's nothing more to it
09:36:50 <monochrom> ghc 6.12.1 is not released yet.
09:36:54 <Zao> > or [True, False, undefined]
09:36:55 <lambdabot>   True
09:37:17 <monochrom> and yay for using foldr
09:37:25 <kmc> > or ([True, False] : undefined)
09:37:26 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:37:26 <lambdabot>         against inferred type ...
09:37:35 <kmc> > or (True : False : undefined)
09:37:35 <lambdabot>   True
09:37:53 <HaskellLove> aavogt>	hmm translate that in noobish talk way? :( I guess apply f to first member and g to second member and combine that? it works only for tuples with two members only?
09:37:54 <kmc> hmm the fold doesn't force the spine?
09:38:05 <kmc> > map (const ()) undefined
09:38:06 <lambdabot>   * Exception: Prelude.undefined
09:38:10 <TomB> hi, I'm trying to get into haskell and going through some introductory tutorials, etc.... I'm running into dependency hell trying to get my development environment set up.  So I decided to just clean install a new OS and get everything set up right.  What would be the most haskell friendly distro/set of tools?
09:38:19 <kmc> > map (const ()) ('x' : undefined)
09:38:20 <lambdabot>   [()* Exception: Prelude.undefined
09:38:23 <kmc> TomB, get Haskell Platform
09:38:29 <TomB> I did
09:38:29 <benmachine> :t map
09:38:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:38:30 <kmc> from the website, if your distro does not support it
09:38:39 <kmc> Arch Linux is supposed to have good support
09:38:40 <gwern> TomB: many people bypass the distro entirely
09:38:46 <kmc> i use debian with my own HP install
09:38:51 <kmc> also i guess debian supports it now
09:38:59 <kmc> Mac OS X has some problems :/
09:39:10 <Axman6> >_<
09:39:12 <monochrom> I use ubuntu and I don't use ubuntu's ghc etc.
09:39:14 <aavogt> HaskellLove: no, you seem to have understood. While (***) works for things other than tuples, that is of no concern here
09:39:20 <TomB> kmc:  ok.... I'll look into debian I guess because I already have some experience with them
09:39:24 <ben> @type (***)
09:39:25 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:39:28 <kmc> TomB, what were you using before?
09:39:28 * ben explodes
09:39:39 <aavogt> when using pairs it does exactly as I wrote with the lambda
09:39:50 <kmc> (b ~> c) -> (b' ~> c') -> ((b, b') ~> (c, c'))
09:39:50 <Axman6> ben: replace a with (_>)
09:39:52 <monochrom> (pairs and functions)
09:39:55 <Axman6> (->)*
09:40:27 <monochrom> Why do beginners allege to have so much problem with merely overloaded operators like *** ?
09:40:29 <ben> Where does the part come on where it works with things other than tuples?
09:40:50 <TomB> I tried to get it on Windows, then some lesser known distros.  I think I'm going to just virtualize those whole thing and create a 'haskell' machine'
09:40:52 <mauke> it doesn't
09:40:54 <kmc> it's all tuples.  however (~>) might not be (->)
09:40:59 <kmc> but rather any other Arrow
09:41:20 <monochrom> In C++ you never had problems with a[3] being array index whatever, even though even that could be overloaded to be something entirely different.
09:41:24 <ben> What arrows other than functions are there?
09:41:28 <benmachine> ben: sometimes you get something like (a -> m b) -> (c -> m d) -> (a, c) -> m (b, d)
09:41:32 <benmachine> with monad m
09:41:35 <kmc> ben, look at Control.Arrow
09:41:36 * ben has never seen arrows in actions other than to impress beginners
09:41:38 <benmachine> only newtyped up
09:41:53 <ben> Oh, right, was that the Kleisli thing
09:41:58 <kmc> the kleisli category of any Monad is an Arrow
09:41:58 <benmachine> yeah
09:42:10 <kmc> because "Arrow" is Haskell's weird term for "category with products and some other stuff"
09:42:32 <kmc> it's one place where they deviated from standard category theory terminology, and not in a good way
09:42:34 <kmc> imo
09:42:37 <Axman6> kmc: that's a pretty weird name anyway
09:42:40 <dibblego> ben, I use them regularly, particularly in Scala
09:42:41 <HaskellLove> I will just enjoy my ignorance for now and ignore these arrows thing
09:42:46 <copumpkin> Freyd categories aren't they?
09:42:48 <copumpkin> something like that
09:43:19 <kmc> the morphisms of the Kleisli category of a monad M are the functions of type (a -> M b)
09:43:26 <kmc> the composition operator in this category is (>=>)
09:43:28 <kmc> :t (>=>)
09:43:29 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:43:33 <monochrom> @quote monochrom generalization
09:43:33 <lambdabot> No quotes match. Take a stress pill and think things over.
09:43:36 <benmachine> isn't it (<=<)
09:43:40 <monochrom> @quote monochrom premature
09:43:40 <lambdabot> monochrom says: premature generality is the root of OOP
09:43:48 <kmc> yeah i guess so
09:44:03 <kmc> composition being backwards and all
09:44:18 <kmc> and given that definition, you can easily state the monad laws as "the Kleisli category is a category"
09:44:23 <aavogt> @quote premature
09:44:23 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
09:44:33 <gwern> @quote dick
09:44:33 <lambdabot> Axman6 says: what's @flush do? saves stuff to dick?
09:44:42 <gwern> actually, that reminds me
09:44:42 <kmc> @quote explode
09:44:42 <lambdabot> RobertXCringely says: If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing
09:44:42 <lambdabot> everyone inside.
09:44:44 <gwern> @flush
09:44:44 <jaredj> teehee
09:45:06 * gwern added that one btw
09:45:06 <kmc> lol, Robert Cringely
09:45:11 <kmc> @quote ghc
09:45:11 <lambdabot> ghc says: Illegal polymorphic type signature in pattern
09:45:15 <kmc> @ghc
09:45:15 <lambdabot> ghc says: parse error (possibly incorrect indentation)
09:45:16 <kmc> @ghc
09:45:17 <lambdabot> ghc says: does not have the required strict field(s)
09:45:30 <benmachine> @ghc explode
09:45:30 <lambdabot> ghc says: My brain just exploded.
09:45:48 <kmc> @quote impossible
09:45:49 <lambdabot> <autrijus> says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
09:46:53 <monochrom> @ghc infinite
09:46:53 <lambdabot> ghc says: Occurs check: cannot construct the infinite type
09:47:05 <kmc> > let x = [x] in x
09:47:06 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
09:47:08 <ben> < benmachine> ben: sometimes you get something like (a -> m b) -> (c -> m d) -> (a, c) -> m (b, d) <- Not (m b, m d)?
09:47:29 <benmachine> ben: (m b, m d) is easy
09:47:37 <benmachine> m (b, d) is more interesting
09:47:51 <TomB> kmc: one thing I have had some trouble with is Yi... being made for haskell, is it the de facto norm, or do people just tend to use some editor+compiler
09:47:58 <kmc> not many people use Yi
09:48:04 <kmc> to my knowledge
09:48:12 <kmc> use whatever editor you're comfortable with
09:48:12 <ben> @djinn (Monad m) => (a -> m b) -> (c -> m d) -> (a, c) -> m (b, d)
09:48:12 <lambdabot> -- f cannot be realized.
09:48:16 <kmc> try to get a haskell mode for it
09:48:18 <benmachine> what you *actually* get is Kleisli m (a, c) (b, d) but that is a newtype over a similar thing
09:48:30 <benmachine> @djinn (Monad m) => a -> m a
09:48:30 <lambdabot> f = return
09:48:34 <kmc> you can build from the command line with "ghc --make"
09:48:37 <benmachine> hrm
09:48:38 <kmc> quick test with "runhaskell"
09:48:45 <kmc> and above all, interactively poke at your program with ghci
09:48:54 * benmachine is pretty sure he's realised f at some point
09:49:00 <TomB> hm... I got leksah to work, but requiring everything to be in  package got annoying,, so far I've been using ghci
09:49:19 <kmc> ghci is amazing... i don't understand how all these supposed industrial strength enterprise languages get by without a good REPL
09:49:34 <benmachine> :t \f g (x, y) -> (,) `liftM` f x `ap` g y
09:49:35 <lambdabot> forall t t1 a1 a (m :: * -> *). (Monad m) => (t -> m a1) -> (t1 -> m a) -> (t, t1) -> m (a1, a)
09:49:40 <kmc> or why people think that no language could have both a REPL and a compiler
09:50:00 <TomB> and it works for running through tutorials, I just know that for a larger project I would want more IDE-ish tools available as well.
09:50:28 <ben> kmc: Maybe because all the industrial strength enterprise languages require more run-up and code and state and whatnot to get anywhere than you could reasonably type into a REPL
09:50:37 <monochrom> I don't find ghci a good repl, but I agree repl+compiler is underrated and under-known.  ocaml and sml do repl+compiler too.
09:51:05 <kmc> but our Haskell and Common LISP REPLs can load your program with all the boilerplate, then let you poke it interactively
09:51:12 <HaskellLove> map (any (<0)) (indexList !! 0) Why is that wrong? by the way (indexList !! 0) gives a list of three tuples each two elements... o oh got it... any works with lists... ok that means then that i should somehow flatten the list and destroy tuples, how to do that?
09:51:19 <monochrom> sml repl is better because you can define types right there, can't do it in ghci.
09:51:31 <kmc> HaskellLove, you are sending your internal monologue straight to this channel now?
09:51:39 <kmc> yeah, that's regrettable
09:51:41 <monochrom> you can manually enter a whole sig and a whole module into sml repl.
09:51:52 <HaskellLove> kmc with purpose it is so you can see my confusion
09:52:52 <monochrom> What is wrong with map (any (<0)) (indexList !! 0) ?  is it a syntax error or type error?
09:54:09 <HaskellLove> monochrom http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14067#a14067
09:54:44 <kmc> HaskellLove, having read that error message, what does it tell you?
09:55:22 <monochrom> What is indexList like?
09:56:00 <HaskellLove> monochrom o i forgot indexList has tuples that is why... oh shit... i am sorry
09:56:07 <monochrom> The error message says somewhere you treat (4,5) like a single number.
09:56:26 <kmc> > (4,5) < 0
09:56:26 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
09:56:27 <lambdabot>    arising from the literal `0' at <i...
09:57:07 <HaskellLove> monochrom... so how can i flaten a tuple to its elements?
09:57:16 <kmc> HaskellLove, \(x,y) -> [x,y]
09:57:19 <kmc> in the case of a 2-tuple
09:57:24 <kmc> which will only work when they are the same type
09:57:29 <benmachine> HaskellLove: don't
09:57:47 <benmachine> make a function that will operate on the whole tuple and tell you if either element is < 0
09:58:12 <HaskellLove> benmachine ok
09:58:18 <kmc> :t \(x,y) -> [x,y]
09:58:19 <lambdabot> forall t. (t, t) -> [t]
09:58:53 <kmc> can we make lambdabot output using UnicodeSyntax for extra confusion
09:59:00 <ritchief> does somebody here know if ghc 12rc2 works with mac os x 10.6? wihtout doing the patch by hand
09:59:17 <benmachine> kmc: some IRC clients have decidedly iffy unicode support
10:00:08 <monochrom> IMO use more utf-8 more pervasively to encourage people to switch software.
10:00:41 <ray> ｇｏｏｄ　ｉｄｅａ，　ｍｏｎｏｃｈｒｏｍ
10:00:48 <monochrom> chicken-and-egg vicious cycle: everyone else uses ascii, I can get by with ascii software
10:01:23 <dibblego> monochrom, I am doing exactly that with a library I am writing (not Haskell)
10:01:33 <ray> ｆｒｏｍ　ｎｏｗ　ｏｎ　ｉ　ｗｉｌｌ　ｏｎｌｙ　ｕｓｅ　ｆｕｌｌｗｉｄｔｈ　：）
10:01:33 <monochrom> Actually it is more vicious than that because: everyone else uses ascii, I can get by with ascii, and you stick with ascii too because everyone else and I do.
10:02:19 <ray> or maybe i won't go that far, i'll just pepλper in rλandom lambdas
10:03:14 <benmachine> λλλ
10:03:31 <benmachine> I wonder if the greek programming community would be displeased if we made λ special syntax
10:03:31 <ray> kmc: i think the real question here is "how can we make haskell the most confusing language for newbies without impacting the CLIQUE?"
10:03:49 <monochrom> clique? niche?
10:03:52 <ray> i think, regrettably, it's a bad idea
10:04:17 <monochrom> I believe we already know. Use Control.Arrow combinators. :)
10:04:18 <ray> the CLIQUE being those of us who make pronouncements like this one
10:04:29 <monochrom> @type (***)
10:04:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:04:38 <monochrom> That already does more than wonder.
10:04:40 <kmc> haλf λife
10:04:50 <kmc> :t (.)
10:04:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:04:52 <pastah_rhymez> kmc: nice :)
10:05:04 <monochrom> @type (+)
10:05:05 <lambdabot> forall a. (Num a) => a -> a -> a
10:05:11 <kmc> e^x dx dx, e^x dy
10:05:21 <monochrom> That is a whole week of reading tutorials. :)
10:05:58 <HaskellLove> why would you make haskell as confusing as possible for beginners?
10:06:19 <kmc> HaskellLove, because we are evil people
10:06:29 <kmc> and our evil plan is totally serious
10:06:38 <ray> that is how CLIQUEs preserve themselves
10:06:41 <benmachine> flip :: (a -> f b) -> f a -> b
10:06:41 <HaskellLove> kmc you fuckin monsters leave us noobs in peace :D
10:06:56 <benmachine> wait is that wrong
10:06:58 <kmc> MAX-CLIQUE
10:07:00 <benmachine> I think it might be
10:07:12 <benmachine> flip :: f (a -> b) -> a -> f b
10:07:12 <kmc> that seems a bit impossible
10:07:19 <kmc> :t flip
10:07:20 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:07:23 <benmachine> there we go, that associates properly
10:07:32 <ray> caleskell is on, remember?
10:07:39 <benmachine> heh
10:07:47 * benmachine wonders what functor-flip is actually *for*
10:07:50 <monochrom> "I have a cunning plan"...
10:08:10 <benmachine> > flip (Just succ) 0
10:08:11 <lambdabot>   Just 1
10:08:12 <ray> anyway, i don't think easiness for newbies should be a concern in haskell design
10:08:14 <aavogt> :t flip fmap
10:08:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
10:08:17 <kmc> i love it when a plan comes together
10:08:54 <Axman6> ray: i don't think it's something that should be actively removed though
10:08:55 <ray> or if it is a concern, only in helium etc
10:09:04 <kmc> ray, i think a lot of features that get added to languages for the sake of making them "easy to learn" turn out to be horribly counterproductive
10:09:11 <benmachine> ghc --please-be-gentle
10:09:17 <kmc> like C++... let's keep the syntax of C for familiarity, while recklessly changing the semantics of everything
10:09:19 <ray> well, take monad comprehensions
10:09:22 <ray> (please!)
10:09:34 <ray> and by that i mean "take them and put them back, please"
10:09:45 <kmc> because somehow syntax is the hard part of learning a language?
10:09:54 * Axman6 has just successfully implemented an ALU using an HDL! :O
10:09:59 <kmc> cool
10:10:11 <ray> automatic lambda unifier using a haskell description language
10:10:18 <HaskellLove> yeiii I finished my function: hasNegative (x, y) | or [x<0, y<0] = True | otherwise = False
10:10:24 <tommd> Axman6: Was it in Lava or Wired?
10:10:24 <benmachine> > let { monad = 5; comprehensions = map pred "bbshi" } in take monad comprehensions
10:10:25 <lambdabot>   "aargh"
10:10:33 <Axman6> this book is awesome: The Elements of Computer systems (often knows as 'From NAND to Tetris in 12 easy steps')
10:10:49 <Axman6> tommd: nah, one designed for use with this book
10:11:18 <benmachine> ray: there's easiness for newbies and then there's easiness for programmers, though
10:11:22 <tommd> So the book has a custom, non-VHDL/Verilog HDL?
10:11:30 <benmachine> imo do-syntax is the latter
10:11:34 <Axman6> yep
10:11:39 <tommd> odd
10:11:40 <benmachine> among other things
10:11:53 <Axman6> se3ems to work alright though
10:11:56 <Axman6> -3
10:12:48 <ray> i didn't say "remove do notation"
10:13:13 <ray> restricting comprehensions to lists is a little like restricting do notation to IO
10:15:33 <Axman6> tommd: this is my implementation of the ALU (including all my attempts fighting the system to try and see if the output was zero: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14068#a14068
10:16:02 <pastah_rhymez> I would like some comments before getting started: http://codepad.org/py1U6Q0d
10:17:53 <pastah_rhymez> wrong names? something missing? typesignature needs flip?
10:21:16 <Axman6> looks alright to me, from what i can see
10:21:24 <benmachine> Maybe Grid a
10:21:30 <benmachine> should probably be Maybe (Grid a)?
10:21:41 <pastah_rhymez> benmachine: well yeah, but that will cause a type error anyway :p
10:21:46 <pastah_rhymez> or kind
10:22:28 <Axman6> http://dmcc.acm.org/pres/?query=/dmcc///confdata/ICFP2008/2008-09-26_09h56 looks quite interesting, using the Atom package to control hybrid vehicles
10:22:34 <pastah_rhymez> joinRL/joinUD is NOT going to be fun :(
10:22:46 <ritchief> well, the code doesn't work in ghc 12rc2
10:22:56 <ritchief> at least on mac os x 10.6
10:23:30 <Axman6> ray: have you checked if the changes that are needed to force it to be 32 bit are there?
10:24:45 <benmachine> why would you cast the thing to Data.Map rather than to e.g. STArray?
10:24:54 <benmachine> hmm would that even work
10:25:01 <pastah_rhymez> benmachine: cast to ST?
10:25:12 <benmachine> well, any MArray
10:25:20 <pastah_rhymez> because casting to ST will cause getting a monadic return value
10:25:25 <pastah_rhymez> DONOTWANT
10:25:38 <Axman6> not really
10:25:38 <benmachine> :t runSTArray
10:25:39 <lambdabot> Not in scope: `runSTArray'
10:25:47 <pastah_rhymez> i looked in ST
10:25:49 <benmachine> @type Data.Array.ST.runSTArray
10:25:50 <lambdabot> forall i e. (Ix i) => (forall s. ST s (GHC.Arr.STArray s i e)) -> Array i e
10:25:52 <benmachine> pure as you like
10:25:59 <benmachine> sort of
10:26:18 <pastah_rhymez> but can i be able to contain that?
10:26:36 <pastah_rhymez> data Holder a = ListH [[a]]
10:26:38 <pastah_rhymez>               | ArrayH (Array Pointer a)
10:26:40 <pastah_rhymez>               | MapH (Map Pointer a)
10:26:42 <pastah_rhymez> data Grid a = Grid
10:26:44 <pastah_rhymez>         { gHolder :: Holder a
10:26:46 <pastah_rhymez>         ,   gSize :: (Int,Int) } -- (WIDTH, HEIGHT)
10:27:06 <benmachine> good question
10:27:14 <benmachine> I don't know what the API would look like
10:27:14 <pastah_rhymez> that's what i have so far, from working on my prototype
10:27:15 * lispy|web politely mentions hpaste as a good place for showing code snippets
10:27:23 <pastah_rhymez> lispy|web: sorry
10:27:31 <benmachine> but in principle it's not impossible to have fast array updates in a pure environment
10:27:55 <lispy|web> pastah_rhymez: cabal install pastepipe to make it even easier.  It's like cat, but instead of showing on your terminal, it ends up on hpaste :)
10:27:55 <pastah_rhymez> benmachine: but what happends to referential transparency?
10:28:18 <pastah_rhymez> lispy|web: oh, that sounds nice :)
10:28:34 <joe____> haste also helps to paste to hpaste
10:28:40 <joe____> cabal install haste
10:28:43 <lispy|web> joe____: what is haset?
10:28:45 <lispy|web> haste*
10:28:54 <HaskellLove> containsNegative [(x,y)] | isPositive (x,y) = True | otherwise = False --------- what am i doing wrong with this?
10:29:27 <joe____> another module to paste to hpaste
10:29:31 <benmachine> pastah_rhymez: nothing?
10:29:31 <lispy|web> HaskellLove: hmm...what are you wanting to do?
10:29:31 <Axman6> [(x,y) | isPositive (x,y) = True | otherwise = False ]
10:29:44 <Axman6> wait, never mind
10:29:45 <benmachine> because ST is clever and doesn't let its environment escape
10:30:10 <lispy|web> That's a case of Rank-2 types for the win
10:30:10 <benmachine> HaskellLove: that pattern matches a list of one element
10:31:01 <lispy|web> :t all
10:31:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
10:31:03 <HaskellLove> Axman6 List comprehensions always save the day, thanks man
10:31:08 <benmachine> (and you're not using any or all like you should be)
10:31:15 <Axman6> HaskellLove: you don't want what i wrote
10:31:22 <lispy|web> all isPositive, is very likely what you want
10:31:43 <lispy|web> Er
10:31:51 <benmachine> using any/all with properly named functions reads like English
10:31:52 <lispy|web> Hehe, it is modolu a negation
10:31:56 <pastah_rhymez> benmachine: well, i think i can stick to Data.Map for now... i know too little about how to use ST to have it implemented here
10:31:58 <Axman6> HaskellLove: also, what you really do what is: containsPositive [x] = isPositive x (i think)
10:32:14 <HaskellLove> lispy|web that is cool yes thanks
10:32:17 * hackagebot upload: msgpack 0.2.0 - A Haskell binding to MessagePack (HideyukiTanaka)
10:32:29 <benmachine> pastah_rhymez: fair enough, but Data.Map is probably better suited to sparse structures
10:32:50 <benmachine> in some vague way
10:32:53 <pastah_rhymez> benmachine: it still guarantees O(log n) write operations
10:33:03 <lispy|web> HaskellLove: it does seem like either containsNegative has the wrong name or the sample specification is backwards
10:33:04 <pastah_rhymez> that's the fastest it's going to get for me...
10:33:13 <pastah_rhymez> (for now)
10:33:24 <kmc> HaskellLove, it is quite pointless to use guards this way:    f x | p x = True | otherwise = False
10:33:39 <kmc> that's just like:    f x = if p x then True else False
10:33:43 <benmachine> pastah_rhymez: but might be a little pricier memorywise than an array
10:34:03 <pastah_rhymez> but is there some function missing from my interface? perhaps forRow :: (a -> a) -> Pointer -> Grid a -> Grid a
10:34:14 <pastah_rhymez> and same type for 'forColumn'
10:34:21 <HaskellLove> kmc>yeah but guards are cooler
10:34:46 <benmachine> guards are cooler than nested if statements
10:34:52 <benmachine> but using neither is cooler still
10:35:01 <Axman6> HaskellLove: not if you're doing exactly ehat if expressions are for
10:35:06 <Axman6> w*
10:35:10 <benmachine> "if p x then True else False" is exactly the same as "p x"
10:35:19 <dibblego> f = p
10:35:28 <benmachine> exactly.
10:37:25 <Axman6> "Atom can schedule threads at compile time" <- awesome
10:38:04 <kmc> HaskellLove, i didn't mean you should use the if statement.  i mean that the if statement is equally pointless but maybe it's easier to see why
10:38:14 <kmc> (err "if expression")
10:39:06 <HaskellLove> kmc got it, thanks
10:39:36 <akappa> Axman6, wtf
10:42:30 * BMeph prefers: "if px == True then True else False"... ;p
10:42:35 <Axman6> akappa: it's a hard real-time DSL, so i guess it makes sense that you know how long something is going to toake ahead of time
10:42:55 <Axman6> benmachine: man, i saw that so many times when people were learning haskell at my uni
10:42:59 <Axman6> uh, BMeph
10:43:02 <kmc> maybe there is some language out there where booleans are actually not first class, and can only be used in conditionals
10:43:17 * BMeph chortles with wicked glee!
10:43:19 <akappa> Axman6, so "Atom" isn't the processor by intel
10:43:20 <akappa> :P
10:43:24 <Axman6> no
10:43:33 <Axman6> cabal install atom
10:43:35 <akappa> ah okay :)
10:43:35 <Axman6> :P
10:43:35 <kmc> hehe
10:44:02 <EvanR> what is the point of kinds
10:44:08 <kmc> what is the point of types
10:44:20 <EvanR> i.e. why are they covered in tutorials
10:44:21 <kmc> kinds exist to describe the ways in which types and type constructors can be used
10:44:33 <kmc> that's a different question
10:44:41 <copumpkin> types need types too!
10:44:45 <copumpkin> poor types
10:44:56 <Axman6> and kinds need types too@
10:44:58 <Axman6> !*
10:45:05 <copumpkin> Set1
10:45:06 <EvanR> i heard theres no way to use types in the language, but you can display them in ghci for example
10:45:06 <pastah_rhymez> EvanR: e.g., look at Data.Map
10:45:07 <kmc> was reading about Omega
10:45:08 <kmc> fun times
10:45:17 <pastah_rhymez> EvanR: Map key value
10:45:18 <BMeph> sorts? :)
10:45:19 <kmc> EvanR, you mean kinds?
10:45:23 <copumpkin> Set2
10:45:23 <EvanR> yes kinds
10:45:25 <copumpkin> Set3
10:45:32 <pastah_rhymez> EvanR: but if you just write lol :: Int -> Map Int
10:45:40 <pastah_rhymez> then you get a kind error :(
10:45:43 <pastah_rhymez> (i think)
10:45:51 <kmc> EvanR, with some GHC extensions you can write (or sometimes have to write) kinds in your source
10:45:52 <EvanR> a kind error
10:45:58 <kmc> > 3 :: Maybe
10:45:59 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
10:45:59 <lambdabot>  Expected kind `...
10:46:13 <EvanR> ok
10:46:13 <kmc> > () :: ([] () ())
10:46:14 <lambdabot>   Kind error: `[]' is applied to too many type arguments
10:46:22 <kmc> > () :: (Either () () ())
10:46:23 <lambdabot>   Kind error: `Data.Either.Either' is applied to too many type arguments
10:47:14 <pastah_rhymez> EvanR: but you CAN make sillya aliases:
10:47:20 <pastah_rhymez> type IntMap = Map Int
10:47:27 <pastah_rhymez> ==> IntMap a = Map Int a
10:47:46 <Axman6> sillya?
10:47:50 <pastah_rhymez> -a
10:47:58 <Axman6> ah
10:48:05 <pastah_rhymez> Axman6: i'm brushing my teeth here, what do you expect?
10:48:19 <EvanR> > take 5 "sillya"
10:48:19 <lambdabot>   "silly"
10:48:23 <Axman6> stop typing with your nose :P
10:50:36 <BMeph> Isn't that how Brits say "more silly"? ;p
10:51:19 <benmachine> how does everyone else say it?
10:51:40 <EvanR> sillyERRRRRR
10:51:53 <benmachine> well that is sillier than our way
10:52:40 <EvanR> learn real english you... you... you english
10:52:46 <kmc> > () :: Maybe Maybe
10:52:47 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
10:52:47 <lambdabot>  Expected kind `...
10:52:57 <benmachine> @slap EvanR
10:52:57 * lambdabot hits EvanR with a hammer, so they breaks into a thousand pieces
10:53:05 <benmachine> breaks?
10:53:06 <pastah_rhymez> BMeph: i'm from sweden
10:53:06 <benmachine> oh dear.
10:53:17 <kmc> lambdabot has a way of truncating error messages just before the useful part
10:53:24 <benmachine> heh
10:53:52 <benmachine> she should really do it based on lines rather than characters
10:54:02 <benmachine> and possibly fiddle with the whitespace a bit
10:58:11 <bnijk_> what did i miss
11:00:31 <gwern> EvanR: kniggit?
11:01:15 <MoALTz> :t it
11:01:16 <lambdabot> Not in scope: `it'
11:02:39 <kmc> ghci has "it"
11:03:01 <kmc> if you type an expression e that's not an IO action, it builds and executes the action:  do { it <- e; print it }
11:03:09 <kmc> err not that
11:03:19 <kmc> let it = e in print it
11:03:21 <kmc> something like that
11:03:56 <MoALTz> hmm
11:03:59 <MoALTz> @more
11:04:12 <MoALTz> was wondering about the error message being truncated
11:05:53 <kmc> all members of a typeclass are monomorphic, right?
11:07:52 <benmachine> kmc: instance Show a => Show [a]?
11:08:11 <kmc> each individual type is monomorphic
11:08:23 <kmc> what i'm asking about is:  instance C (forall a. a -> a)
11:08:35 <kmc> not forall a. instance C a
11:09:12 <kmc> yes it's rejected even with FlexibleInstances
11:10:26 <kmc> i'm not sure if higher-rank instances (?) are theoretically unreasonable or just more trouble than they're worth
11:11:23 <kmc> they're weird to think about, because typeclass constraints are in a contravariant position
11:18:05 <kmc> hmm types in equality constraints similarly must be monomorphic
11:18:09 <Axman6> woah, this thing is really cool: http://antipastohw.blogspot.com/2009/08/introducing-illuminato-x-machina.html
11:19:07 <bfh6558> what is the tab size in haskell
11:19:10 <kmc> 8 chars
11:19:18 <Axman6> don't use tabs
11:19:19 <Axman6> ever
11:19:21 <kmc> Axman6, that's nuts... each individual board is really powerful too
11:19:26 <bfh6558> no tabs?
11:19:41 <Axman6> kmc: yeah. pretty expensive though. 16 boards are over $800US
11:19:42 <bfh6558> code would loook really ugly then!
11:19:47 <kmc> yeah
11:19:55 <bd_> bfh6558: Use tab stops but have your editor pad them out into spaces.
11:19:56 <Axman6> bfh6558: make your editor use spaces instead of tabs
11:20:06 <HaskellLove> why does this give me type errors? map (read::Int) ["23","34"]
11:20:08 <kmc> it would make more sense if the boards had some cheap micro and cost a few dollars
11:20:10 <bd_> bfh6558: That way when it's opened up later, you see what the compiler sees, guarenteed
11:20:12 <Axman6> any decent editor can do it
11:20:17 <kmc> but the cost of connectors might be prohibitive
11:20:22 <bd_> HaskellLove: 'read' isn't of type Int :)
11:20:23 <benmachine>  don't even use tab stops, imo
11:20:29 * benmachine uses sort of space stops
11:20:32 <Axman6> HaskellLove: map (read :: String -> Int) ..
11:20:33 <bd_> HaskellLove: perhaps you mean: map (read :: String -> Int) ...
11:20:45 <kmc> HaskellLove, what does the error message look like?
11:21:01 <bd_> :t map (read :: Int) [ "23", "34" ]
11:21:02 <lambdabot>     Couldn't match expected type `Int'
11:21:02 <lambdabot>            against inferred type `String -> a'
11:21:02 <lambdabot>     In the first argument of `map', namely `(read :: Int)'
11:21:05 <bd_> it looks like that
11:21:09 <HaskellLove> bd yeah that works thanks :D
11:21:27 <Philonous> Programming with type level natural reads almost like assembly. hAdd a b r = add a and b and store it in r
11:21:29 <bfh6558> yeah good point about the spaces but I feel like that makes it a pain to edit different fieltypes in vim without writig a vim script to check the extention on my file :(
11:21:38 <kmc> HaskellLove, what part of the type error message you got was confusing?
11:21:49 <mauke> bfh6558: not extension, file type
11:22:02 <bfh6558> sorry
11:22:04 <bfh6558> filetype
11:22:06 <mauke> bfh6558: you want either a filetype script, or an autocommand
11:22:37 <HaskellLove> kmc well this works: read "3434" :: Int so ... that is how i implied mine above
11:22:50 <kmc> HaskellLove, that doesn't answer my question
11:23:12 <kmc> HaskellLove, you said that this expression gave you a type error:   map (read::Int) ["23","34"]
11:23:15 <kmc> what was the error message?
11:23:24 <HaskellLove>  Couldn't match expected type `Int'           against inferred type `String -> a'
11:23:47 <bfh6558> mauke: im still very new to vim, I learned emacs for a month, coded some c++/c and then switched. in ur opinion which one of the two would be easier find/make before i head off on a potentially ~3hour googlespree
11:23:49 <kmc> > map (read::Int) ["23","34"]
11:23:50 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:23:50 <lambdabot>         against inferred type ...
11:23:58 <kmc> HaskellLove, "    In the first argument of `map', namely `(read :: Int)'"
11:23:59 <kmc> correct?
11:24:04 <kmc> i mean, did it tell you that?
11:24:14 <HaskellLove> In the first argument of `map', namely `(read :: Int)'    In the expression: map (read :: Int) ["23", "34"]
11:24:35 <BMeph> Has anyone here ever used any OBJ-type languages, and if so, any thoughts? :)
11:24:52 <kmc> HaskellLove, from that error message you can solve this problem yourself
11:25:04 <kmc> in particular, it tells you the problematic expression (read :: Int)
11:25:10 <kmc> and it tells you the type it inferred for "read"
11:25:28 <kmc> and you can also get the type of "read" yourself from ghci
11:25:42 <mauke> bfh6558: :autocmd FileType haskell :setl sw=4 sts=4 et
11:25:56 <mauke> put that in your ~/.vimrc, then complain because the options suck :-)
11:26:24 <bfh6558> mauke: ahaha thank you so much!
11:26:33 <kmc> HaskellLove, I would rather help you learn to read error messages, then explain each error individually
11:26:35 <bfh6558> I appreciate the advice and help
11:26:46 <kmc> than*
11:27:06 <bfh6558> I'm still gonig to have to red the help pages on autocommands now that you've sparked my interest in them
11:28:03 <HaskellLove> kmc i understand you but you seem to think i did not see that... i was like ok if this works : read "3434" :: Int why would not this work : map (read::Int) [bla bla bla]
11:28:20 <kmc> HaskellLove, the error message tells you why not
11:28:48 <kmc> in particular, (read) and (read "3434") are different expressions with different types
11:28:51 <HaskellLove> kmc but why does this work then read "3434" :: Int? ok nevermind got the point
11:28:59 <kmc> :t read
11:29:00 <lambdabot> forall a. (Read a) => String -> a
11:29:01 <kmc> :t read "3434"
11:29:02 <lambdabot> forall a. (Read a) => a
11:29:03 <dibblego> HaskellLove, read "3434" and read are different
11:29:05 <Axman6> kmc: you're trying to tell the compiler that read has a different type to how it was defined
11:29:24 <Axman6> uhm, HaskellLove even
11:30:49 <bd_> HaskellLove: read is a function. You're telling the compiler that it needs to find a way to make up a read which is not a function, but rather a constant Int.
11:31:20 <kmc> Which is impossible, because "String -> a" and "Int" have different "shapes"
11:31:39 <kmc> Meaning, there's no way to fill in types at the type variables to make them the same
11:31:47 <kmc> An Int is never a function, even if you get to choose the return type.
11:32:40 <kmc> That is what GHC means when it says "Cannot match expected type against inferred type"
11:32:49 <sproingie> @type read "123"
11:32:50 <lambdabot> forall a. (Read a) => a
11:33:05 <sproingie> a is universally quantified, it is all things Read
11:33:21 <sproingie> you want it as an Int, you have to tell it to give it to you as an Int
11:34:10 <sproingie> polymorphic values are one of those weird things that you dont see in a lot of other languages
11:34:20 <copumpkin> yo dawg
11:38:49 <gwern> @quote good.news
11:38:50 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
11:39:01 <gwern> @quote while.you
11:39:01 <lambdabot> chrisdone says: yo dawg we heard you like haskell so we installed a lambdabot in your ghci so you can monad while you monad
11:39:21 <gwern> @quote interpret.while
11:39:21 <lambdabot> No quotes match. I am sorry.
11:39:26 <gwern> @quote compile.while
11:39:27 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
11:39:42 <kmc> stupid meme
11:40:03 * gwern likes it in small doses
11:42:11 <Philonous> SPJ was in this channel?
11:42:22 <tommd> Very rarely.
11:42:32 <tommd> usually #ghc
11:42:40 <copumpkin>  @quote doesn't necessarily come from IRC
11:42:48 <copumpkin> sometimes people @remember stuff from other media
11:42:55 <tommd> that too
11:42:55 <Philonous> I see
11:43:02 <bfh6558> when dealing with lambda calculus how would one define a parametric equation? can they even possibly coexsist with the idea of currying?
11:43:05 <tommd> but SPJ used to show up for the ghc weekly IRC meetings.
11:43:18 <copumpkin> is he too good for that now?
11:43:43 <tommd> copumpkin: I have only been to one in the past year and he wasn't at that one.
11:43:56 <tommd> You could attend and find out.
11:44:48 <copumpkin> I idle in #ghc all the time
11:44:58 <copumpkin> I've observed several meetings and have never seen him :)
11:45:04 <tommd> me too, when I'm connected to freenode.
11:45:24 <tommd> ahh, well, I'm not on at the time of the meetings.  He attended the first dozen or so.  Didn't really take to IRC
11:45:47 <tommd> He tried to write full paragraphs and his client wouldn't break it up but it would truncate.  Kind of frustrated him I would assume.
11:46:11 <kmc> did he IRC in Comic Sans MS
11:46:15 <kmc> dude... MS Comic Chat
11:46:16 <copumpkin> lol
11:46:20 <tommd> Also, I didn't see much coming from the weeklies.  Not sure if that changed.
11:46:24 <kmc> that's where that font is from
11:46:25 <MoALTz> that sounds like a terrible irc client
11:46:37 <dibblego> it rocked
11:46:47 <kmc> see also: jerkcity.com (NSFW
11:51:45 <kmc> {
11:51:48 <kmc> })
11:52:46 <HaskellLove> any help here guys? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14073#a14073 I am 5 days in Haskell and I still find it hard and unintuitive these kinda of manipulations...
11:52:59 <copumpkin> get used to it
11:53:02 <copumpkin> it will last a lot longer than 5 days
11:53:03 <TomB> Ok,, the windows installers default to folder names with spaces in them.. makes it really hard to down the line
11:53:27 <kmc> HaskellLove, make your matrix into an Array
11:53:31 <kmc> call it a
11:53:41 <kmc> then map (a !) over the second list
11:53:45 <kmc> :t (!)
11:53:46 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
11:53:49 <TomB> would a simple renaming of Haskell Platform to HaskellPlatform work, or is a uninstall/reinstall needed (i could fix path)
11:54:20 <TomB> or are there other links and references to "Haskell Platform" somewhere?
11:56:32 <BMeph> Or better yet, may an Array with pair indices, and map (a !) over the pairs directly. :)
11:57:01 <kmc> yeah that's what i meant
11:57:24 <kmc> the second thing is a list of lists of pair-indices
11:57:28 <kmc> so you'd use map (map (a!))
11:57:31 <pastah_rhymez> HaskellLove: here's how it's done: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14018
11:59:01 <HaskellLove> pastah_rhymez yeah man i saw your solution you sent me but i did not even look at it, I want to solve it my way that is how you learn :)
11:59:24 <pastah_rhymez> well, anyway, you can just look at the array code
11:59:28 <HaskellLove> ok so lists are bad and slow let me now read the docs for Array and hopefully make this work
11:59:46 <Cale> If you don't care about speed at all, you can just go with  [[xs !! x !! y | (x,y) <- ks] | ks <- kss]
11:59:49 <pastah_rhymez> HaskellLove: you'll need this line: 'arr = listArray ((0,0) , (19,19)) list'
12:00:09 <pastah_rhymez> look in the docks for how 'litsArray' works :)
12:00:17 <HaskellLove> oki doki
12:00:19 <Cale> Since it's only 20x20, that's not going to be all that slow, but making an array isn't hard and will be more efficient
12:00:39 <HaskellLove> Cale will do so now, thanks
12:00:49 <dibblego> pastah_rhymez, why define first/second instead of import Control.Arrow?
12:00:59 <pastah_rhymez> dibblego: KISS
12:00:59 <dibblego> both = join (***)
12:01:05 <dibblego> pastah_rhymez, that's my point
12:01:20 <pastah_rhymez> well, learning by doing?
12:01:29 <copumpkin> there should be a both with a class-polymorphic rank-2 type
12:01:31 <pastah_rhymez> this is actually my first real usage of arrays
12:01:58 <kmc> lists aren't bad
12:02:09 <kmc> like watermellons, lists are bad when you use them for the wrong task
12:02:59 <kmc> in Haskell we often use a list to represent "streaming" data from one computation to another, rather than a structure that sticks around and is repeatedly accessed
12:05:11 <pastah_rhymez> kmc: like this? http://www.youtube.com/watch?v=bokq7t2aIWc
12:07:37 <sproingie> for streaming, lists are great.  for random access, not so much
12:11:51 <kmc> in some sense (and especially with fusion), lists are a control-flow structure for building graphs of coroutines
12:12:38 <sproingie> what's all this fusion business?
12:12:41 <Axman6> shit, so they are :O
12:12:54 <copumpkin> sproingie: convert them to colists!
12:13:06 <Axman6> sproingie: one form of fusion woukld be map f . map g = map (f . g)
12:13:12 <kmc> @google from lists to streams to nothing at all
12:13:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
12:13:13 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
12:13:22 <pastah_rhymez> fusion == rewrite rules?
12:13:26 <Axman6> removes intermediate lists as much as possible
12:13:31 <Axman6> pastah_rhymez: no
12:13:51 <Axman6> more to do with getting rid of the intermediate lists
12:13:55 <kmc> list fusion is implemented with rewrite rules
12:14:10 <pastah_rhymez> oh, so making pointer derefing occur as little as possible
12:14:23 <kmc> indirectly
12:14:29 <kmc> because it opens up strictness and unboxing too
12:14:32 <copumpkin> don't think about it at such a low level
12:14:44 <pastah_rhymez> yeah, well, that's the bottom line, right?
12:14:45 <copumpkin> it just gets rid of intermediate datastructures
12:14:55 <copumpkin> doesn't have to be lists
12:14:58 <kmc> it's an important property of optimizing compilers that some optimizations exist primarily to expose others, and that this can even be mutually recursive
12:15:07 <copumpkin> it's called deforestation in general
12:15:10 <kmc> it took me quite a while to understand that
12:15:59 <pastah_rhymez> copumpkin: well, everytime i have a datastructur 'data D = D X Y Z' i directly thing 'data D = D (*X) (*Y) (*Z)'
12:16:09 <pastah_rhymez> *think*
12:16:13 <Axman6> well, don't
12:16:16 <copumpkin> pastah_rhymez: I wouldn't
12:16:23 <copumpkin> pastah_rhymez: it doesn't have to be like that
12:16:28 <pastah_rhymez> but that's what it compiles to, right?
12:16:32 <copumpkin> not always
12:16:32 <kmc> it's only important for certain types of low-level program analysis
12:16:42 <kmc> pastah_rhymez, we have high-level languages precisely so we don't always have to think about the assembly level
12:16:46 <kmc> and yes it will not always compile to that
12:16:49 <pastah_rhymez> unless i use lots of # and {-# UNBOXED #-} and ! and whatnot
12:16:55 <Axman6> it's a fair enough way to explain it to C people, but not generally a good way to think of it (unless you're needing high performance, where you want to remove as many of the pointers as you can)
12:17:08 <kmc> bbl
12:17:14 <copumpkin> pastah_rhymez: it's not even a pointer at first
12:17:25 <copumpkin> it's a function to compute that
12:17:53 <copumpkin> but I'd still avoid thinking about it on those levels
12:18:23 <HaskellLove> I am interested what kind of visual aid do you math haskell monsters use when programming in haskell or in general? Maybe some UML here and there and some other cool stuff?
12:18:27 <pastah_rhymez> copumpkin: i just think of it as pointers in order to be able to think about when unboxing it would make sense
12:18:34 <copumpkin> pastah_rhymez: fair enough
12:18:38 <Axman6> UML isn't cool
12:18:42 <copumpkin> HaskellLove: never touched UML
12:18:43 <Axman6> this is however cool: http://www.youtube.com/watch?v=VW5PByaR2EQ&feature=player_embedded#
12:18:57 <copumpkin> HaskellLove: visual aids = writing down the types for what I want to write, before I write the implementations
12:18:59 <SamB_XP> HaskellLove: please remove your horrifing UML from the premises immediately!
12:19:03 <HaskellLove> Axman6 why is that
12:19:10 <copumpkin> often x :: b -> s -> a; x = undefined
12:19:17 <pastah_rhymez> Axman6: man, i want one of those!
12:19:25 <Axman6> it's just horrible :\
12:19:53 <copumpkin> that is an awesome clock
12:20:47 <HaskellLove> copumpkin thanks I will note that now, SamB_XP why man uml is usefull, i think, Axman6 horrible? you got something cooler?
12:20:48 <Axman6> and an awesome art installation to go with it: http://www.youtube.com/watch?v=Ir4fbKGt7xQ&NR=1
12:20:54 <sproingie> UML would be a poor poor fit to haskell
12:21:20 <SamB_XP> HaskellLove: it reminds me too much of Java!
12:21:32 <sproingie> dataflow diagrams might be appropriate, i never really did those in any formal sense tho
12:21:40 <Axman6> it has its uses (companies like Boeing use it a hell of a lot), but i dislike it
12:21:47 <pastah_rhymez> is there some vim plugin that can take all of my lone type signatures and just write definitions? ("f :: Type" ==> f = undefined")
12:22:29 * BMeph will, after seeing Axman6's link, never think of a "grandfather clock" again without at least snickering inappropriately.
12:22:38 <Axman6> heh
12:22:46 <BMeph> Axman6++
12:22:59 <Axman6> @karma
12:22:59 <lambdabot> You have a karma of 8
12:23:01 <BMeph> Axman6: You, Sir, are full of WIN!
12:23:02 <Axman6> hoorah
12:23:29 <Axman6> urgh, do not use the british genetlman meme on me. i'm so sick of it on reddit
12:23:31 * SamB_XP hands him some Mac and Other
12:23:38 <HaskellLove> sproingie Mathematica would be better? SamB_XP you mean it reminds you of OOP? Axman6 are you some kind of mind monster that has it in his head and needs no uml to visualise stuff?
12:24:06 <sproingie> mathematica is not a modeling tool
12:24:18 <copumpkin> HaskellLove: about your "learn as many languages as possible" objective, by the way: I'd recommend you settle on Haskell and decide to learn it really well, instead of getting a taste of a bunch of languages. You could skip through perl, ruby, python, and many other similar languages and learn very little beyond new syntax for the same ideas each time. Haskell will give you exposure to optionally imperative programming, functional
12:24:18 <copumpkin> programming, and logic programming in the type system if you take it far enough.
12:24:23 <Axman6> <some somewhat intelligent comment> -> <reply: "You sir are a gentelman and a hero">
12:24:27 <SamB_XP> sproingie: you can use it to draw diagrams though ;-P
12:24:28 <Axman6> so sick of it >_<
12:24:33 <sproingie> some systems lend themselves to visualization.  frp networks for example
12:24:43 <sproingie> other things you just keep in your head
12:24:44 * copumpkin comforts Axman6 
12:24:57 * copumpkin is a comfort veggie
12:25:03 <Axman6> it's so sad how 4chanish reddit has become
12:25:05 <SamB_XP> Axman6: you, sir, are a villain!
12:25:20 <SamB_XP> hmmm, does reddit really have so many pictures of naked girlies ?
12:25:32 <copumpkin> SamB_XP: absolutely, in certain subreddits
12:25:45 <sproingie> i just stick to haskell.reddit.org, aka "dons' bookmarks"
12:25:50 <copumpkin> :)
12:25:57 <SamB_XP> hehehehe
12:26:06 <Axman6> SamB_XP: only if you subscrive to /r/NSFW
12:26:09 <Axman6> -b
12:26:12 <SamB_XP> once in a while someone else submits one, you know!
12:26:13 <Axman6> eljkhgtbegbrtjkjbegtk j
12:26:18 <HaskellLove> copumkin oki doki, thanks man I apreciate your opinion. So, yeah, definetly Haskell is big i will probably with it 6 more months untill i solve all euler
12:26:33 <sproingie> where does all this /b/ /r/ /blah/ stuff come from?
12:26:40 <copumpkin> sproingie: 4chan
12:26:40 <sproingie> i thought 4chan was an irc thing
12:26:44 <copumpkin> nope
12:26:50 <Axman6> HaskellLove: you have very high hopes. some of those problems are _extremely_ difficult
12:26:50 <SamB_XP> 4chan is an image board!
12:26:55 <sproingie> ahhhh
12:27:09 <copumpkin> HaskellLove: some of them are hard and it also gets rather boring after a while
12:27:11 <sproingie> i recall seeing the boards, i thought that derived from some irc thing
12:27:20 <SamB_XP> oh, not a clue!
12:27:21 <copumpkin> I started out wanting to do a bunch of them and got bored
12:27:22 <pastah_rhymez> anyone tried the language Qi? http://en.wikipedia.org/wiki/Qi_(programming_language)
12:27:26 <sproingie> never paid attention to the paths then
12:27:32 <HaskellLove> Axman6 i am a ninja man, i will solve them all in 6 months
12:27:48 <Axman6> i'll give you $10 if you do ;)
12:27:48 <sproingie> i tried out Qi a while back, couldn't really grok the type system
12:27:49 <copumpkin> lol
12:27:55 <BMeph> pastah_rhymez: I've tried Q, but haven't heard of Qi... :)
12:27:56 <MoALTz> some of the earlier projecteuler problems are fun render into a single line haskell solution (list comprehensions are great for this)
12:27:59 <sproingie> but back then i didn't know Monads from Mongols
12:28:04 <copumpkin> HaskellLove: what's your username, I'll keep an eye on you
12:28:50 <pastah_rhymez> seems like Qi is Lisp + haskell ideas - paretheses hell
12:28:54 <SamB_XP> are you talking about PE ?
12:29:01 <SamB_XP> oh, yes
12:29:01 <sproingie> i think sequent types make it pretty different
12:29:13 <SamB_XP> yeah, PE gets really hard after a while
12:29:25 <SamB_XP> and/or boring
12:29:30 <copumpkin> Primitive type operators are list, * (product), --> and array. Here are some examples
12:29:34 <copumpkin> list is a primitive?
12:31:03 <pastah_rhymez> '\' in Qi is '/.'
12:31:06 <pastah_rhymez> is this good?
12:31:13 <HaskellLove> copumkin - WantToSolveIt from Macedonia
12:31:13 <copumpkin> he NEEDED MOAR than #haskell could offer
12:31:15 <pastah_rhymez> is \ reserved in lisp?
12:31:25 <sproingie> gah, it has a slashdot operator
12:31:29 <pastah_rhymez> hehe
12:31:38 <copumpkin> HaskellLove: great :)
12:31:40 <SamB_XP> does it take down the operand ?
12:31:53 <copumpkin> HaskellLove: I'm pumpkin if you're looking for easy problems to solve :P
12:32:08 <pastah_rhymez> (*2) == (/. X (* X 2))
12:32:35 <sproingie> that == kills me
12:32:38 <sproingie> is it lisp or not?
12:32:47 <pastah_rhymez> but it says that partial application is supported
12:32:55 <pastah_rhymez> so maybe you can do withou the X and the /.
12:32:58 <sproingie> owait that's your notation.
12:33:07 <sproingie> i do seem to recall Qi had some weird breaks from lispisms
12:33:12 <pastah_rhymez> sproingie: no, Qis
12:33:24 <sproingie> ok like that.  i suppressed it
12:33:45 <HaskellLove> copumkin you from?
12:33:46 <pastah_rhymez> "Static typing is optional in Qi and is enabled by (tc +) and disabled by (tc -)."
12:33:48 <pastah_rhymez> NICE!
12:34:02 <sproingie> curious
12:34:07 <pastah_rhymez> unsafeCompile
12:34:16 <sproingie> unsafePerformHaskell
12:34:32 <copumpkin> HaskellLove: I'm from all over :)
12:35:05 <pastah_rhymez> sproingie: oooh! it has dependent types
12:35:20 <sproingie> yah its type system looks pretty funktastic
12:35:22 <HaskellLove> copumkin ok, i will have you in mind when i solve them like this big brother standing above me come on bitch solve solve... hahaha :D
12:35:36 <sproingie> i can't entirely understand even Haskell's, so Qi's is way over my head
12:35:37 <copumpkin> :D
12:35:51 <sproingie> (Qi's, pronounced "cheese")
12:35:58 <pastah_rhymez> sproingie: well, just use the parts you understand :)
12:36:01 <pastah_rhymez> like i do :)
12:36:09 <sproingie> that's what i'm doing
12:36:20 <pastah_rhymez> i'm probably never going to use RankNTypes or whatever
12:36:20 <sproingie> learning arrows now
12:36:47 <pastah_rhymez> GADTs and GeneralizedNewtypeDeriving is almost always all i need
12:36:48 <copumpkin> pastah_rhymez: you never know!
12:36:56 <Axman6> hmm, the first comment here is very interesting: http://stackoverflow.com/questions/1894453/development-time-in-various-languages
12:37:19 <dolio> I don't understand why you'd want to turn off type checking.
12:37:24 <pastah_rhymez> Axman6: about the jet engines?
12:37:30 <Axman6> yeah
12:37:34 <SamB_XP> dolio: yeah, doesn't it kinda kill typeclasses dead ?
12:37:35 * Axman6 <3 Ada
12:37:43 <pastah_rhymez> dolio: if you're doing nasty lisp reflection hacks, perhaps?
12:37:47 <pastah_rhymez> (just guessing here)
12:37:52 <dolio> SamB_XP: Well, not just that.
12:38:22 <SamB_XP> well, yeah ... since when is a runtime crash better than a compile-time failure ?
12:38:29 <dolio> What is it going to buy you? Unless you're going to just leave it off. But then you might as well write plain Lisp.
12:38:43 <dibblego> who is turning type checking off?
12:38:56 <pastah_rhymez> dibblego: (-tc) in Qi
12:39:03 <pastah_rhymez> sorry
12:39:06 <pastah_rhymez> (tc -)
12:39:14 <pastah_rhymez> (tc +) to turn it back on again
12:39:16 <dolio> And if you're going to turn it back on, why not get the types write when you first write the code, instead of writing a bunch of code without the type checker, and then fixing all the places it blows up when you're done.
12:39:23 <dolio> Types right, even.
12:39:43 <pastah_rhymez> dolio: i'm guessing it will make sense once you start leanring the language...
12:40:02 <dolio> People ask for it for Haskell, too, though.
12:40:12 <copumpkin> it's laziness!
12:40:19 <pastah_rhymez> dolio: well that's just crazy
12:40:48 <pastah_rhymez> can it even compile without typechecking?
12:40:52 <pastah_rhymez> (haskell)
12:40:59 <pastah_rhymez> i mean is it theoretically possible?
12:41:09 <SamB_XP> no -- the typeclasses need it
12:41:24 <sproingie> {-# LANGUAGE NoTypeChecking #-}
12:41:34 <pastah_rhymez> sproingie: hehe
12:41:39 <sproingie> that'd be a great April 1 announcement for Haskell 2011
12:42:03 <pastah_rhymez> @remember sproingie | {-# LANGUAGE NoTypeChecking #-}
12:42:03 <lambdabot> Done.
12:42:25 <Axman6> @quote LANGUAGE
12:42:26 <lambdabot> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
12:42:34 <Axman6> @quote LANGUAGE
12:42:34 <lambdabot> qwe1234 says: all scripting languages are the same.
12:42:36 <Axman6> @quote LANGUAGE
12:42:37 <lambdabot> qwe1234 says: good developers will write good code in absolutely any language, while bad developers will develop crap no matter the tools they use.
12:42:43 <Axman6> @quote LANGUAGE
12:42:43 <lambdabot> qwe1234 says: all scripting languages are the same.
12:42:55 <sproingie> silly, it's commented out :)
12:43:05 <Axman6> heh
12:43:35 <monochrom> You can use unsafeCoerce to bypass typechecker if you are desperate enough. I don't understand all the complaints about typechecking not being a team player.
12:45:11 <SamB_XP> the problem with C++ is that so much of the rope is completely invisible ...
12:45:45 <pastah_rhymez> monochrom: the only use i've heard of for unsafeCoerce is for IRC clients-bots where you would run (unsafeCoerce getLine) >>= f . unlines, such that f :: [String] -> IO ()
12:45:55 <SamB_XP> ... but you can still hang yourself with that rope just as easily as with C's visible rope
12:45:56 <pastah_rhymez> what other uses is tere for unsafeCoerce?
12:46:03 <SamB_XP> well, rather more easily, really
12:47:09 <monochrom> Well now you hear another use of unsafeCoerce from me. As a "this page still under construction" annotation.
12:48:14 <pastah_rhymez> monochrom: how do you mean?
12:54:37 <copumpkin> pastah_rhymez: why would you use unsafeCoerce there?
12:55:05 <copumpkin> :t getLine >>= ?f . unlines
12:55:06 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
12:55:06 <lambdabot>       Expected type: String
12:55:06 <lambdabot>       Inferred type: [String]
12:55:06 <pastah_rhymez> copumpkin: i don't really know, but apparently it makes everything very easy if you do
12:55:48 <copumpkin> I don't even understand what that would be trying to do
12:56:13 <EvanR> need help with terminology, so a monadic class is one with the monadic operations, return and >>=. but what is 'a monad', an instance of that class? a value with type instance of that class?
12:56:18 <monochrom> :t getLine >>= (?f . unlines)
12:56:19 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
12:56:19 <lambdabot>       Expected type: String
12:56:19 <lambdabot>       Inferred type: [String]
12:57:02 <dibblego> EvanR, the instance of that class, specifically the type variable e.g. "the Maybe Monad"
12:57:19 <monochrom> unlines?
12:58:26 <EvanR> ok
13:00:18 <ddarius> There aren't "monadic classes," there's just the Monad class.
13:01:06 <pastah_rhymez> class Monad m where ...
13:01:11 <pastah_rhymez> instance Monad Maybe
13:01:18 <pastah_rhymez> instance Monad IO -- etc
13:01:46 <copumpkin> those are instances
13:02:20 <pastah_rhymez> EvanR: what are you reading?
13:04:58 <EvanR> pastah_rhymez: all the tutorials... haskell report... currentl a gentle introduction
13:05:48 <pastah_rhymez> EvanR: i found that All About Monads gave me the best insight
13:06:11 <pastah_rhymez> after looking at several before that, All About Monads was the one that really explained it and all the reasons for it
13:07:20 <pastah_rhymez> @hoogle cast
13:07:20 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
13:07:20 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
13:07:20 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
13:08:50 <pastah_rhymez> EvanR: silence from others == agreement
13:09:12 <EvanR> yeah im getting there
13:09:25 <pastah_rhymez> hehe :)
13:09:33 <EvanR> seems like it makes a lot more sense after understanding data types and type classes
13:09:46 <EvanR> then monads are just instances of a class
13:10:11 <pastah_rhymez> well, you have to know those well to understand why you would want monads
13:11:25 <pastah_rhymez> EvanR: have you implemented a typeclass instance for any datatype yet?
13:17:28 <EvanR> pastah_rhymez: no, getting there
13:20:34 <EvanR> i need to know how stuff works before designing programs
13:29:15 <jimmyjazz14> how does printf take a variable number of arguments?
13:29:40 <mauke> by returning a type that can be either a string or another function
13:30:25 <aavogt> > printf "" 1 2 3 4 5 6 7 8 :: String
13:30:26 <lambdabot>   "* Exception: Printf.printf: formatting string ended prematurely
13:31:08 <jimmyjazz14> interesting
13:31:51 <copumpkin> or also an IO
13:31:54 <copumpkin> strangely enough
13:31:58 <copumpkin> not a big fan of that
13:37:41 <mtnviewmark> If I have a typeclass Foo - and several instances of it ... I want to make a type that contain a list of heterogeneous instances...
13:37:45 <mtnviewmark> can I do that with
13:38:27 <mtnviewmark> data (Foo a) => FooList = FooList [a]
13:38:46 <mtnviewmark> or rather - I can't right? because that just means that FooLists can have homogenous lists
13:38:58 <mtnviewmark> for various Foo instances --
13:39:03 <mtnviewmark> do I need to wrap it?
13:39:07 <copumpkin> you'd need to wrap it more
13:39:15 <mtnviewmark> right
13:39:18 <mtnviewmark> so I tried this
13:39:26 <copumpkin> data MultiFoo = forall a. (Foo a) => a
13:39:33 <copumpkin> data MultiFoo = forall a. (Foo a) => MultiFoo a
13:39:34 <mtnviewmark> newtype (Foo a) => WrappedFoo = WF { wf :: a }
13:39:43 <copumpkin> not on the outside
13:39:59 <mtnviewmark> ah.. now can I do that on the FooList directly
13:40:02 <mtnviewmark> or do I need the type
13:40:03 <copumpkin> nobody uses constraints on the outside because they aren't very useful
13:40:11 <copumpkin> you still need the type if you want heterogeneous lists
13:40:35 <copumpkin> then you can do data FooList = FooList [MultiFoo]
13:40:49 <mtnviewmark> data FooList = forall a. (Foo a) =>  FooList [a]
13:40:51 <mtnviewmark> that won't work?
13:40:59 <mtnviewmark> but
13:41:03 <copumpkin> that will work, but it'll give you something else
13:41:08 <mtnviewmark> data FooList = FooList [WrappedFoo]
13:41:09 <mtnviewmark> will?
13:41:21 <copumpkin> the list will be homogeneous of a type that is an instance of Foo
13:41:46 <mtnviewmark> which is no different than putting the constraint on the outside then
13:42:06 <copumpkin> well, it is different in the sense that you could then make a list of FooLists
13:42:11 <copumpkin> or something similarly constraining
13:42:15 <copumpkin> but it's probably not what you want
13:43:13 <mtnviewmark> so, a way to think of the forall in the wrapped case is --- for all a that satisfy (Foo a), we still have a *single* type WrappedFoo
13:43:25 <mtnviewmark> not a family of them one for each Foo instance
13:43:29 <mtnviewmark> right?
13:43:44 <copumpkin> yeah, it's a single type
13:43:51 <aavogt> all you know about the elements of that list is that they have the methods in Foo though
13:44:09 <copumpkin> you could conceivably do [WrappedFoo True, WrappedFoo (), WrappedFoo 5]
13:44:23 <mtnviewmark> right - that's exactly what I want
13:44:46 <mtnviewmark> I wonder - can you do that inside the [] constructor and do it in one step?
13:45:01 <mtnviewmark> data FooList = FooList [ forall a. (Foo a) => a ]
13:45:51 <copumpkin> yes, but it won't do what you want
13:46:04 <mtnviewmark> still only homogenous in the lists?
13:46:20 <copumpkin> well, it's homogeneous in the polymorphic nature of the values
13:46:37 <copumpkin> forget the constraint for a moment
13:46:45 <copumpkin> data FooList = FooList [ forall a. a ]
13:46:50 <copumpkin> could pretty much only contain _|_
13:47:29 <mtnviewmark> if wouldn't be a list of any values at all - but all you can apply to them is id
13:47:33 <aavogt> the constraint is the same as something like:   data FooList b = FooList [ forall a. (a,a -> b) ]
13:48:11 <aavogt> but more convenient
13:48:36 <copumpkin> mtnviewmark: but my basic point is that it's not an existential there, it's universal
13:48:54 <copumpkin> it requires the polymorphism
13:49:07 <copumpkin> it's also being removed from GHC in the near future
13:49:13 <ddarius> :t partition
13:49:14 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:49:23 <aavogt> copumpkin: how so?
13:49:38 <copumpkin> aavogt: ImpredicativeTypes is getting the axe
13:51:14 <copumpkin> mtnviewmark: so one conceivable thing that would work is data NumList = NumList [forall a. Num a => a]
13:51:21 <copumpkin> and then you could do NumList [1,2,3]
13:51:29 <copumpkin> because those number literals are polymorphic
13:51:39 <copumpkin> another one that would work is Read
13:51:58 <copumpkin> any typeclass that polymorphic values work for, really
13:51:59 <mtnviewmark> but then  NumList [ 1::Int, 2::Double ]   --- still fails?
13:52:10 <copumpkin> yeah, you'd need to leave the values polymorphic
13:52:25 <copumpkin> as I said, it's not an existential there
13:52:31 * hackagebot upload: pure-priority-queue 0.14 - A pure priority queue. (BradLarsen)
13:52:35 <mtnviewmark> that's not my aim - I've got several different kinds of "Shape adjustors"
13:52:52 <copumpkin> you probably just want a MultiFoo then
13:52:54 <mtnviewmark> and I need an aggregate shape adjustor -
13:53:06 <copumpkin> I think JHC supports more direct existentials fwiw
13:53:17 <mtnviewmark> I see (thanks to ghci) that you can make MultiFoo be a newtype -- must be a data
13:53:40 <mtnviewmark> I suppose the extra level of type information is required,
13:53:42 <copumpkin> yeah, it needs to carry around a dictionary
13:56:05 <mtnviewmark> well... I did   data WrappedFoo = forall a. (Foo a) => WF { wf :: a }
13:56:28 <copumpkin> an accessor for it might not be very useful
13:56:50 <mtnviewmark> but, then I couldn't do     map (\w -> fooMeth (wf w)) ws
13:56:50 <sjanssen> I'm surprised GHC allows it
13:56:54 <mtnviewmark> and that didn't work
13:57:03 <mauke> continuation based accessors
13:57:29 <copumpkin> yeah, I just tried that
13:57:31 <copumpkin> it gives you an error
13:57:34 <copumpkin>  even asking for its type :)
13:57:57 <copumpkin> mtnviewmark: the only way you can work with such an existential wrapper is with a continuation-ish structure
13:58:05 <sjanssen> "Cannot use record selector `wf' as a function due to escaped type variables"
13:58:18 <mtnviewmark> is there an example of this in the common libraries I can look at?
13:58:23 <copumpkin> letMeIn :: WrappedFoo -> (forall a. Foo a => a -> r) -> r
13:58:43 <copumpkin> letMeIn (WF a) f = f a
13:59:45 <copumpkin> mtnviewmark: hmm, can't think of one
14:01:10 <mtnviewmark> so - If I have a typeclass Foo, and several instances, what is a better idiom for making an aggragte (say, and ordered collection of hetergoenous Foo instances) ?
14:01:21 <copumpkin> is it closed?
14:01:31 <mtnviewmark> as in do I know all the instances upfront?
14:01:32 <copumpkin> or will third parties be able to add more of them later?
14:01:38 <mtnviewmark> the later
14:01:43 <copumpkin> ah
14:01:56 <mtnviewmark> 'cause othewise I could use a data instead of a class
14:02:11 <copumpkin> this is probably your best bet, I guess, unless the instances can be represented as a single function
14:02:29 <mtnviewmark> (Actually - really, I'm exploring this kind of problem and reimplementing it via data type, type class, pure functions, and continuations)
14:03:00 <mtnviewmark> (I've got the other three working, but the heterogenous aggregate of the typeclass version is the bear)
14:03:11 <copumpkin> it's a tough problem
14:03:24 <mtnviewmark> (my plan is to use Criterion to evaluate the speed of these choices )
14:03:34 <copumpkin> ah
14:04:32 <mtnviewmark> I came up on this particular situation in a library I'm writing - and wondered which design direction was right
14:04:44 <bfh6558> a recursive function like maximum would have to iterate over every element in the list correct?
14:04:48 <mtnviewmark> doing all four in a small test problem is proving a good learning experience
14:04:52 <bfh6558> :
14:04:57 <copumpkin> have you come across http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf ?
14:05:08 <copumpkin> but in short, there's not a beautiful solution
14:05:14 <mauke> bfh6558: generally, yes
14:05:42 <mauke> > maximum [True, True .. ]
14:05:44 <mtnviewmark> no, I haven't - thank you copumpkin - as always you are a wealth of help and ideas!
14:05:45 <bfh6558> :( sorry for my relativly uninteresting and newbish questions.  mauke: thanks, btw I got my tabbing correct in vim! thanks for that too
14:05:50 <lambdabot>   mueval: ExitFailure 1
14:06:15 <mtnviewmark> sending you a virtual beverage of your choice
14:06:22 <copumpkin> mtnviewmark: yay, I'll take some eggnog
14:06:46 <bfh6558> with or without nutmeg?
14:06:57 <copumpkin> not sure, I only discovered it recently
14:07:01 <copumpkin> haven't sampled a great variety
14:07:03 <bfh6558> lol :)
14:07:05 * mtnviewmark hads you a glass of eggnog and points out the bottle of rum on the sideboard
14:07:29 <copumpkin> yay, thanks :)
14:07:49 <bfh6558> protip: dont ever commit a whole night of drinking strictly to eggnog, your stomach will not be happy
14:08:06 <copumpkin> lol
14:08:22 <chdevnull> try the nutmeg, it is an improvement
14:09:12 <bfh6558> if haskell makes such heavy use of recursion, is stack memory a common problem?
14:09:18 <bfh6558> or lack there off
14:09:21 <bfh6558> of*
14:09:24 <copumpkin> bfh6558: nope
14:09:33 <bfh6558> shwat? how is this possible
14:09:40 <copumpkin> haskell's recursion is lazy, so we build up heap isntead ;)
14:09:46 <copumpkin> then when evaluating, we consume stack
14:09:52 * MoALTz chuckles
14:09:55 <bfh6558> amazing!
14:10:02 <bfh6558> but i dont quite understand but still amazing!
14:10:18 <syntaxglitch> quick question: I have a program that needs to read some data in from a file and use it throughout the program. Is there a way to keep it "on hand" other than passing it around to everything that needs it?
14:10:37 <ddarius> :t intersect
14:10:38 <copumpkin> syntaxglitch: there's an ugly way to get a global variable, but you should avoid it if you possibly can
14:10:40 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
14:10:53 <Draconx> syntaxglitch, the Reader monad might be of interest to you.
14:10:58 <syntaxglitch> My naive approach of just calling a function that loads the data did what you probably expect, reload the data every time, which is no good
14:12:32 <syntaxglitch> Obviously I could just do the initial read when it initializes stuff then pass the data that's read around, but that'd be a lot of ugly code :(
14:12:44 <bfh6558> copumpkin: in a simple function like maximum [1..50], in what way does being lazy allow this to use the heap, it still recursivly has to check the head vs the maximum of the tail
14:12:54 <copumpkin> the Reader/(r->) monad might be a good solution
14:13:16 <bfh6558> untill the edge of a singleton list
14:13:18 <syntaxglitch> hmm, Reader sounds interesting
14:13:23 <syntaxglitch> That might do what I need
14:13:54 <bfh6558> or is there some kind of black magic going on with this example that i am unaware of
14:14:34 <copumpkin> bfh6558: well, in most examples the function either turns out to be simplifiable to be tail-recursive or doesn't need to produce all its result at once
14:14:41 <copumpkin> @src maximum
14:14:41 <lambdabot> maximum [] = undefined
14:14:41 <lambdabot> maximum xs = foldl1 max xs
14:14:49 <copumpkin> so we're using a left fold
14:14:56 <copumpkin> which is approximately tail recursive
14:16:18 <copumpkin> it's even possible for a function like minimum to return without looking at the entire list, in certain (rare cases), if defined using foldr
14:16:43 <copumpkin> > foldr1 max ([1..50] ++ [0] ++ [1..]) :: Natural
14:16:46 <lambdabot>   * Exception: stack overflow
14:16:48 <copumpkin> boo
14:16:51 <bfh6558> o fold would be the blackmagic, I havn't read that far in learn you haskell :)
14:16:52 <copumpkin> > foldr1 min ([1..50] ++ [0] ++ [1..]) :: Natural
14:16:53 <lambdabot>   0
14:16:59 <copumpkin> that's what I meant :)
14:17:14 <copumpkin> bfh6558: the fold isn't black magic at all, really :) we just dislike writing out our recursion explicitly
14:17:22 <c_wraith> oh, hey.  I've got a question about what an error message means:  "Inferred type is less polymorphic than expected    Quantified type variable `s' escapes" in the code "runST . shuffle' $ length ls - 1".  The error message does not show up in "runST $ shuffle' $ length ls - 1".  What's going on here?
14:17:25 <bfh6558> haha
14:17:43 <copumpkin> c_wraith: you let it escape!!
14:17:52 <copumpkin> what's the type of shuffle?
14:18:16 <c_wraith> copumpkin: Int -> ST something.  >_>
14:18:24 <copumpkin> c_wraith: that something matters
14:18:32 <c_wraith> Like I said, it compiles correctly if the . is a $
14:20:31 <c_wraith> shuffle' :: (RandomGen g) => Int -> ST s ([a], g)
14:21:38 <Cale> Use  runST (...)
14:21:50 <copumpkin> strange that it works with the $
14:21:51 <c_wraith> Cale:  I can make it compile
14:21:59 <c_wraith> the question is *why* does it cause that error?
14:22:13 <mtnviewmark> is there a proposal to allow trailing commas in lists?
14:22:20 <mtnviewmark> boy, I'd sure love that
14:22:23 <copumpkin> mtnviewmark: I think there was, but it was shot down :P
14:22:23 <Cale> There's weird special casing for ($)
14:22:31 <mtnviewmark> really?
14:22:44 <Cale> Hmm... well, almost.
14:22:49 <mtnviewmark> but the put the comma at the start of the expression when putting them one per line is so ugly
14:22:59 <Cale> I seem to recall they added something not-so-general to make runST work with ($)
14:23:10 <copumpkin> mtnviewmark: I guess :)
14:24:01 <c_wraith> So is this because of the funny type signature of runST ?
14:25:50 <Cale> Well, (runST $ ...) shouldn't even work, because ($) isn't *that* polymorphic
14:26:44 <c_wraith> No, really.  What's going on here?  Like, back up a couple steps, and explain to me what the error even means.
14:26:58 <copumpkin> there's a universally quantified variable that escaped
14:27:00 <copumpkin> that is
14:27:08 <Cale> :t runST
14:27:09 <lambdabot> forall a. (forall s. ST s a) -> a
14:27:14 <copumpkin> if you write f :: (forall s. s -> r) -> r
14:27:20 <copumpkin> and that internal forall s. made it into r somehow
14:27:42 <Cale> runST requires a parameter whose type is polymorphic in s, and 'a' cannot contain or depend on s in any way
14:28:19 <Cale> (because the a is bound by the outer forall, where s isn't in scope
14:28:21 <Cale> )
14:30:14 <Cale> :t runST
14:30:15 <c_wraith> Sure...  But how does it decide that when I use (.), the ST action I'm providing depends on s?
14:30:15 <lambdabot> forall a. (forall s. ST s a) -> a
14:30:23 <Cale> :t \x -> runST x
14:30:25 <lambdabot>     Inferred type is less polymorphic than expected
14:30:25 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
14:30:25 <lambdabot>         x :: ST s a (bound at <interactive>:1:1)
14:30:57 <c_wraith> ...  Oh, I think I'm starting to get it
14:30:58 <copumpkin> if GHC could infer higher-rank types that error wouldn't exist would it?
14:31:34 <Cale> That one wouldn't
14:31:42 <Cale> :t (runST $)
14:31:43 <lambdabot> forall a. (forall s. ST s a) -> a
14:31:46 <Cale> ...
14:31:48 <Cale> huh?
14:31:58 <Cale> Okay, that produces an error in my GHC :)
14:32:14 <Cale> They've been fiddling with this though.
14:32:37 <Cale> > runST $ return 5
14:32:40 <lambdabot>   5
14:32:42 <Cale> huh
14:32:51 <copumpkin> > runST . return $ 5
14:32:52 <lambdabot>   Inferred type is less polymorphic than expected
14:32:52 <lambdabot>    Quantified type variable...
14:32:55 <copumpkin> :P
14:32:58 <copumpkin> gotta love it
14:33:26 <Cale> It's because of the screwing about they've been doing trying to make that work because people were complaining that it should.
14:33:38 <copumpkin> damn people
14:33:41 <copumpkin> always wanting stuff
14:34:24 <Cale> But I don't think we really have a real answer for making that typecheck for a sane reason. GHC normally never infers that a type variable should be a polytype.
14:35:12 <Cale> So in some versions of GHC,  runST $ return 5  won't work, but I'm not sure which, or perhaps there are flags which lambdabot is setting that are having an influence on it.
14:35:57 <c_wraith> that particular expression works for me..  but that shouldn't be a surprise, given that it worked in the larger sample code I provided, too
14:36:08 <sinelaw> What's the simplest mathematical definition of a graph?
14:36:16 <Cale> c_wraith: How about (runST $) ?
14:36:18 <c_wraith> sinelaw: a set of pairs
14:36:24 <c_wraith> Cale: that one blows up for me
14:36:50 <Cale> :t (runST $)
14:36:51 <lambdabot> forall a. (forall s. ST s a) -> a
14:36:57 <Cale> ^^ not for LB though :)
14:37:03 <Cale> It's quite odd.
14:37:29 <sinelaw> c_wraith, that disallows 'pseudographs' with more than one edge between nodes
14:37:33 <luite> c_wraith: doesn't work for isolated vertices though
14:37:45 <Cale> sinelaw: Normally it's a set of vertices, and a set of edges or arcs (you have to allow for vertices that aren't connected to anything)
14:38:05 <sinelaw> c_wraith, oh yeah, and also unconnected vertices
14:38:10 <Draconx> sinelaw, a set V and a set E subset of V x V
14:38:25 <sinelaw> Cale, Draconx, that sounds good enough, thanks
14:38:39 <Cale> sinelaw: If you want more than one arc/edge between some pair of nodes, you need to do something more.
14:38:44 <sinelaw> yip
14:38:47 <Draconx> for undirected graphs you can add (a, b) in E implies (b, a) in E.
14:38:55 <luite> or if you want edges between more than 2 nodes
14:38:57 <sinelaw> Cale, what's the usual way to add that?
14:38:58 <Cale> sinelaw: Like perhaps a function V x V -> N which specifies how many arcs there are
14:39:38 <sinelaw> ok, cool. i'm trying to do denotational design of a graph editing GUI
14:39:41 <Cale> V x V -> 2  actually isn't a bad definition on its own :)
14:40:49 <sinelaw> Cale, but I also want the nodes (and also edges) to carry values, so it's V x V -> { set of edge values }
14:41:22 <sinelaw> or even an n-tuple since the set again diasllows multiple identical values
14:41:23 <Cale> sinelaw: Yeah, there are many variations on this sort of graph. Sometimes you want the arcs coming out from each vertex to be ordered too, which is common in the case of graphs used for programs.
14:41:25 <c_wraith> Oh.  Sorry, I was defining a function.  I'm not sure why I got confused there.
14:42:05 <Cale> You could then define a graph to be a function  V -> V*  where V* = union over k >= 0 of V^k
14:42:21 <Cale> (for ordered lists of arcs)
14:42:32 <sinelaw> what's that union over...?
14:42:47 <copumpkin> it's just the kleene star, regex style
14:42:47 <Cale> natural numbers
14:42:52 <BMeph> Perhaps: V x V -> Maybe (...) ? :)
14:43:04 <Cale> sinelaw: Oh, what does the notation mean?
14:43:16 <sinelaw> Cale, yes, what do you mean
14:43:26 <Cale> sinelaw: I mean the union of the sets V^k for each k
14:43:45 <Cale> So, V^0 union V^1 union V^2 union ...
14:43:46 <sinelaw> so you have edges that connect more than two nodes?
14:44:05 <Cale> No, each vertex has an ordered list of outgoing arcs
14:44:24 <Cale> In Haskell, it would just be V -> [V]
14:44:38 <Cale> (though technically my union doesn't include the infinite lists)
14:45:23 <Cale> That's probably one of the more useful sorts of definitions for the sort of graph used for code.
14:46:13 <Cale> (because the order of parameters to a function matters)
14:46:34 <sinelaw> oh. ok, so that's a directed graph with ordered edges, and if it's not just the union (which is a set - rather it's a list) then you also allow more than one edge
14:47:09 <Cale> That union I had was a way of defining finite lists
14:47:25 <Cale> union over k >= 0 of V^k  =  finite lists of elements of V
14:47:29 <sinelaw> Cale, but it's a union of sets, which is also a set
14:47:35 <Cale> yes, a set of lists
14:47:51 <Cale> (well, tuples)
14:47:59 <sinelaw> oh right
14:48:00 <sinelaw> ok
14:48:38 <sinelaw> mathematically is it normal to just say "sequence of V's"?
14:49:23 <Cale> Yeah, but if it's finite you should make that clear, since in a lot of contexts, 'sequence' means 'function from N'
14:50:06 <sinelaw> ok. and also, i still need the edge values, so it's better to have [(X, V)]
14:50:52 <sinelaw> and, i'm going to want to be able to annotate the graph with external data (like how it is to be presented on the screen) so maybe i need unique id's per node and edge?
14:51:46 <Cale> Well, there are lots of ways to break it down
14:51:50 <sinelaw> so that V = X x N   (X is set of node values)
14:54:46 <copumpkin> I wish there were more elegant computer-friendly representations for graphs, really
14:54:56 <copumpkin> the inductive graphs are nice from one perspective, but not from another
14:55:19 <sinelaw> what do you call an "inductive" graph?
14:55:25 <copumpkin> fgl-style
14:55:36 <copumpkin> the agda standard library also implements something like it
14:55:45 <copumpkin> basically a list of node "contexts"
14:56:44 <copumpkin> agda can make stronger guarantees on the contexts, which is nice
14:57:43 <absentia> xn/win shrink 3
14:57:49 <copumpkin> lol
15:03:16 <SmurfOR>  i'm going to be without a connection for a week is there a way for me to be able to download all of hackage and the documentation as one big lump?
15:03:32 <copumpkin> there's a massive tarball somewhere
15:03:41 <mauke> the packages, yes. I don't know about the documentation
15:04:03 <copumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar is the packages
15:04:38 <bfh6558> GAH high order functions make my head asplode
15:04:50 <copumpkin> bfh6558: get used to much head asplosion :)
15:05:22 <mauke> bfh6558: even map?
15:05:28 <bfh6558> sasds and partially applications ooh they bite!
15:05:37 <bfh6558> partial*
15:05:53 <bfh6558> sorry? even map? I don't understand the question
15:06:05 <mauke> map is an example of a higher order function
15:06:12 <copumpkin> map tends to be the easiest higher-order function to grasp
15:06:13 <mauke> I mean, map f [x1, x2, x3, ...] == [f(x1), f(x2), f(x3), ...] seems pretty natural
15:06:24 <bfh6558> I havn't come across it yet, I was just introduced to a few standards like zipwith
15:06:34 <sinelaw> zipwith before map? yuck
15:06:35 <mauke> zipWith is like map2
15:06:59 <bfh6558> actually only zipwith and some stpuid applyTwice function
15:07:10 <mauke> zipWith f [x1, x2, x3, ...] [y1, y2, y3, ...] == [f x1 y1, f x2 y2, f x3 y3, ...]
15:07:16 <shachaf> mauke: map is like zipWith1.
15:07:42 <bfh6558> the number being the order of the function?
15:07:58 <mauke> no, number of arguments
15:08:08 <bfh6558> oh
15:08:10 <bfh6558> :P thanks
15:08:49 <bfh6558> :t map
15:08:50 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:09:06 <bfh6558> oh my forall? hvn't seen that yet
15:09:13 <mauke> you can ignore it
15:09:19 <mauke> it doesn't do anything here anyway
15:09:21 <BMeph> ...and repeat is zipWith0! :D
15:09:44 <mauke> bfh6558: also, forall is a ghc extension, not Haskell98 :-)
15:10:00 <bfh6558> noted
15:10:29 <mauke> .oO( s/^forall [^.]*\.// )
15:12:19 <bfh6558> zipwith (zipwith (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]] just seems crazy
15:12:33 <mauke> it is
15:13:17 <bfh6558> All the example functions i've seen so far involve strings or lists, how is IO in haskell? to actually get data for programs?
15:13:28 <mauke> it's another data structure
15:13:44 <bfh6558> hmm cool :O
15:13:49 <mauke> basically, you construct a description of the I/O you want to do, and return that from your program
15:13:56 <mauke> then the runtime system picks it up and executes stuff
15:14:04 <bfh6558> hvnt really thought of i/o as a structure before, really beyond a simple stream
15:14:14 <bfh6558> ahh
15:14:16 <bfh6558> sweet
15:14:35 <mauke> this structure contains callbacks into pure haskell code, so you can react to input and stuff
15:17:34 <EvanR> back to the issue of recursion and stack/heap. if the code is tail recursive, will the memory performance be better? are fold family like this?
15:18:06 <mauke> tail recursion can lead to stack overflows. beware.
15:18:25 <EvanR> >_<
15:18:42 <EvanR> i thought that was the point of tail recursion, so it could be represented as an iterative process
15:18:50 <bfh6558> ok yeah thats what i was scared of originally! so much recursion use and i'd expect stack overflows out the wahzoo!
15:18:52 <copumpkin> EvanR: you'll have to unlearn most of what you knew about recursion from elsewhere
15:18:52 <EvanR> with no stack
15:18:59 <copumpkin> we do have a stack
15:19:03 <mauke> EvanR: yes, but we have laziness
15:19:15 <copumpkin> the stack just isn't used where you might expect
15:19:27 <mauke> EvanR: so one possibility is that you're efficiently building a huge unevaluated expression
15:19:44 <bfh6558> dang! i just grasped the use of function arguments using the stack in imperative languages
15:20:08 <_Jedai_> EvanR: tail recursion is good generally, but lazyness is more important. The canonic example is "foldl (+) 0 [1..10000]"
15:20:17 <mauke> bfh6558: have you ever gotten a stack overflow in an imperative language?
15:20:34 <bfh6558> only once when I tried to
15:21:02 <pastah_rhymez> bfh6558: recursively calling a function taking 10xlong int?
15:21:05 <mauke> I found it rather hard in C (without using infinite recursion)
15:21:27 <_Jedai_> EvanR: As mauke said, here foldl being tail recursive only means you'll build a huge thunk of (+) and when you try to evaluate this thunk, you'll overflow the stack
15:21:30 <bfh6558> >.< i might have used infinite recursion
15:21:35 <BMeph> mauke: Ackermann? ;)
15:21:45 <mauke> BMeph: ackermann counts as infinite
15:22:13 <BMeph> mauke: How so?
15:22:21 <EvanR> think i need to study the computation model here
15:22:21 <_Jedai_> BMeph: in practice
15:22:21 <copumpkin> you can write it fairly easily with higher-order functions
15:22:21 <mauke> it's HUEG
15:22:26 <copumpkin> oh
15:22:30 <c_wraith> they both terminate when the computer fails :)
15:23:08 <pastah_rhymez> http://web.archive.org/web/20060327112912/http://foldl.com
15:23:12 <bfh6558> EvanR: If you find a good book/resourece let me know! :P I definitely need to take a deeper look into how they do this stuff
15:23:13 <pastah_rhymez> http://foldr.com/
15:23:22 <EvanR> so we start with main... we evaluate it, and this triggers evaluation of the parts of the definition of main...
15:23:24 <_Jedai_> EvanR: there is a good page on this particular example on the HaskellWiki, that may help you grasp what's happening
15:23:33 <copumpkin> @let times n = appEndo . foldMap Endo . replicate n
15:23:33 <lambdabot>  <local>:1:20: Not in scope: `foldMap'
15:23:35 <pastah_rhymez> EvanR, bfh6558 ^^ click my links
15:23:37 <_Jedai_> EvanR: Right
15:23:40 <copumpkin> @let times n = appEndo . Data.Foldable.foldMap Endo . replicate n
15:23:41 <lambdabot>  Defined.
15:23:46 <bfh6558> pastah_rhymez: tyvm
15:23:49 <mauke> :t times
15:23:50 <lambdabot> forall a. Int -> (a -> a) -> a -> a
15:23:52 * EvanR checks links
15:24:29 <mauke> :t (foldl' (.) id .) . replicate
15:24:30 <lambdabot> forall a. Int -> (a -> a) -> a -> a
15:25:15 <copumpkin> @let ackermann 0 = succ; ackermann (n+1) = times . ackermann n
15:25:16 <lambdabot>  <local>:2:38:
15:25:16 <lambdabot>      Couldn't match expected type `Int'
15:25:16 <lambdabot>             against in...
15:25:23 <copumpkin> @let ackermann 0 = succ; ackermann (n+1) = times $ ackermann n
15:25:24 <lambdabot>  <local>:2:46:
15:25:24 <lambdabot>      Couldn't match expected type `Int' against inferred type ...
15:25:26 <copumpkin> boo
15:25:57 <EvanR> _Jedai_: so whats the result of this evaluation, a single value of type IO () or is it a huge collection of thunks, or what
15:26:28 <EvanR> running only occurs after the evaluation is finished or...
15:26:35 * EvanR goes insane
15:26:40 <bfh6558> foldr.com reminds me of some horrible lisp nightmear I had a few weeks back
15:26:49 <_Jedai_> EvanR: a single value of type IO () and running is interleaed with evaluation
15:27:42 <EvanR> hrm
15:28:08 <EvanR> so if an expression can be reduced, it is somehow run?
15:28:09 <lispy|web> ?remember <bfh6558> foldr.com reminds me of some horrible lisp nightmear I had a few weeks back
15:28:10 <lambdabot> Good to know.
15:29:28 <_Jedai_> EvanR: I'm not sure I understand you, "run" is an expression I would only use for IO actions
15:29:58 <lispy|web> EvanR: you can think of programs as directed acyclic graphs of expressions.  The way you "reduce" that graph is your evaluation strategy.  eager reductions follow one rule, and lazy follows a different rule
15:29:58 <MoALTz> i wish haskell98-report.pdf wasn't broken with respect to text selection (and copying)
15:30:17 <lispy|web> MoALTz: What about using the html version?
15:30:32 <EvanR> _Jedai_: yeah so i guess the question only applies to expressions like IO something >>= IO something
15:30:38 <_Jedai_> EvanR: bascally, main is executed, and its component in turn needs some value and thus bring about the evaluation of parts of your program
15:30:54 <MoALTz> lispy|web: i'd prefer to be able to use the pdf version. but yes, that may work instead
15:31:20 <EvanR> lispy|web: and eager is what i read is sicp, where tail recursive is best
15:31:21 <EvanR> ?
15:31:39 <lispy|web> EvanR: right
15:31:55 <pastah_rhymez> M.Map Int (M.Map Int a) must be faster than M.Map (Int,Int) a, right?
15:32:14 <_Jedai_> EvanR: eager is the evaluation model of most other languages (except Clean and R)
15:32:16 <mauke> pastah_rhymez: why?
15:32:56 <mauke> EvanR: eager is when you eval a function argument before you apply the function
15:33:01 <pastah_rhymez> mauke: O(log(log(n))) lookups?
15:33:07 <pastah_rhymez> i'm just guessing here...
15:33:14 <EvanR> lazy must be when you evaluate the function first, leaving the args
15:33:16 <_Jordan__> did the haskell package build script change since like three days ago?
15:33:26 <mauke> pastah_rhymez: I don't see where you get log(log(n)) from
15:33:33 <copumpkin> _Jordan_: _the_ haskell package?
15:33:34 <pastah_rhymez> me neither
15:33:42 <pastah_rhymez> "pastah_rhymez | i'm just guessing here..."
15:33:49 <_Jordan__> bah, s/package/platform/
15:33:55 <EvanR> so whats the strategy for defining functions for lazy evaluation for efficient execution
15:34:17 <_Jedai_> pastah_rhymez: O((log n)²) seems closer to me
15:34:48 <_Jedai_> EvanR: basically, if you can be lazy it's better
15:35:11 <lispy|web> EvanR: well, usually you want things to be lazy.  But sometimes storing the "thunks" (the uncomputed parts) is worse than storing the result.  In those cases, you want to force evluation sooner
15:35:21 <mauke> corecursion
15:35:35 <pastah_rhymez> hmmm
15:35:40 <copumpkin> co channel
15:35:41 <copumpkin> chanel
15:35:43 <_Jedai_> EvanR: for instance a good rule of thumb for functions that takes list in parameter is that you want them to work with infinite lists if at all possible
15:36:17 * BMeph prefers coco chanel... ;p
15:36:20 <bfh6558> oh my god i need a cigerett after reading the last 10 minutes of this room
15:36:34 <bfh6558> :)
15:36:56 <EvanR> heh
15:36:57 <mauke> that's just your brain trying to get out
15:37:00 <lispy|web> EvanR: in sicp you might use an accumulator parameter so you can get tail recursion.  If you did that in haskell, then you probably want to make sure that accumulator is evaluated at each step in the recursion, otherwise you might build up a HUGE thunkt that results in heap exhaustion
15:37:28 <_Jedai_> EvanR: if you can't be really lazy (it's just not possible sometimes to work with infinite list parameter), you probably want to be strict, so you'll use seq or the bang patterns to force a strict evaluation model locally
15:37:52 <lispy|web> EvanR: the good news is, Haskell is lazy and that's what you usually want :)
15:38:09 <EvanR> right
15:38:19 * copumpkin wrote a [a] -> [(Int, b)] -> [(a, Maybe b)] yesterday
15:38:29 <EvanR> lazy seems good
15:38:29 <copumpkin> pretty fancy, eh
15:39:04 <lispy|web> copumpkin: you attached a b to the as at the Int offset?
15:39:05 <_Jedai_> EvanR: the other good news is that GHC will realize when you need to be strict automatically if optimizing (-O2) in a lot of case
15:39:07 <EvanR> every time you get (x:xs) you just leave xs as it is until needed
15:39:09 <copumpkin> lispy|web: yeah
15:39:17 <copumpkin> lispy|web: it assumes the second parameter is sorted
15:39:25 <_Jedai_> EvanR: right, when you can
15:39:44 <lispy|web> _Jedai_: I thought -O2 was only if you can show it helps, and that normally you just use -O
15:40:40 <_Jedai_> lispy|web: no, -O2 helps pretty much all the time now (with "recent" GHC), so when I want an optimized build I always use it
15:40:56 <lispy|web> ah
15:41:15 <_Jedai_> lispy|web: and if I want a fast build I probably just use -O0
15:42:38 <EvanR> ah yeah i just realized how much slower it is than c, even for a small program
15:43:15 <_Jedai_> EvanR: that depends a lot of what you've done in your program
15:43:29 <_Jedai_> EvanR: and if you compiled with optimization
15:43:59 <pastah_rhymez> zipWith (++) ["a","b","c"] ["1","2","3"]
15:44:03 <pastah_rhymez> > zipWith (++) ["a","b","c"] ["1","2","3"]
15:44:04 <lambdabot>   ["a1","b2","c3"]
15:44:49 <lispy|web> > zipWith (++) "abc" "123"
15:44:50 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
15:44:50 <lambdabot>    arising from a use o...
15:44:58 <_Jedai_> EvanR: it is generally possible to get programs close to C speed (within a few factors), but that takes some experience
15:45:01 <lispy|web> oh
15:45:15 <copumpkin> > (runZipList . (liftA2 (++)) `on` ZipList) ["a","b","c"] ["1","2","3"]
15:45:16 <pastah_rhymez> lispy|web: haha, that error is real welcoming to beginners :)
15:45:16 <lambdabot>   Not in scope: `runZipList'
15:45:20 <EvanR> were talking about the build process right
15:45:26 <pastah_rhymez> NO!
15:45:34 <copumpkin> FUCKING NEWTYPE EXTRACTION METHODS
15:45:37 <pastah_rhymez> stop this goddamn braifuck! copumpkin!
15:45:39 * copumpkin coughs
15:45:39 <lispy|web> pastah_rhymez: experts know better than to look at the error message ;)
15:45:52 <pastah_rhymez> i actually WANTED to test that
15:45:53 <_Jedai_> EvanR: No
15:46:03 <EvanR> i meant how long the compiler takes
15:46:06 <pastah_rhymez> not to seem cool in front of the kids
15:46:16 <EvanR> the generated program is pretty fast, so far
15:46:23 * copumpkin 's only goal in life is to steal pastah_rhymez' thunder
15:46:28 <copumpkin> sry, must liv wit it
15:46:40 <_Jedai_> EvanR: but if you're talking about the build process, you're completely right, GHC has to do a lot more work than most C compiler
15:47:00 <pastah_rhymez> EvanR: it's much easier to write slow code in haskell than in C (it's actually hard to get slow C code)
15:47:12 <pastah_rhymez> copumpkin: hey, could you have a glance at my interface now?
15:47:13 <EvanR> does types on all top level stuff speed things up
15:47:21 <pastah_rhymez> you complained about sleeping yesterday?
15:47:27 <copumpkin> pastah_rhymez: but how would I steal your thunder that way??
15:47:47 <pastah_rhymez> copumpkin: you're not as stupid or stubborn as me in order to complete this library
15:47:51 <copumpkin> pastah_rhymez: sure, what was the link again?
15:48:02 <mauke> EvanR: unlikely
15:48:06 <_Jedai_> pastah_rhymez: well except when the C programmer is enticed into using a simple stupid algorithms by C speed and its low-levelness
15:48:08 <lispy|web> EvanR: I think it can speed up type checking.  Not really sure though.  The compiler doesn't trust you to get it right so it double checks your types.
15:48:16 <pastah_rhymez> lispy|web: http://codepad.org/UoJyzp13
15:48:28 <EvanR> ah
15:48:36 <BMeph> pastah_rhymez: I gave you thunder, but copumpkin stoleded it. ;p
15:48:36 <pastah_rhymez> copumpkin: ^^
15:48:53 <_Jedai_> EvanR: Not much except in some very rare case
15:49:18 <pastah_rhymez> copumpkin: PM
15:52:53 <ddarius> :t getZiList
15:52:54 <lambdabot> Not in scope: `getZiList'
15:52:56 <ddarius> :t getZipList
15:52:57 <lambdabot> forall a. ZipList a -> [a]
15:53:21 <EvanR> next question is about data values. in all the examples that 'transform' some data, it takes a value and returns an updated new value. does ghc treat this efficiently?
15:55:51 <mtnviewmark> coolio - I  have that odd little case I was talking about earlier coded four ways: functions, data, type class, and closures --
15:55:59 <mtnviewmark> and Criteron benchmarks for timing it all
15:57:17 <mtnviewmark> in terms of time    functions < data < type classes < closures
15:57:23 <mtnviewmark> (where small is faster)
16:01:38 * ddarius thinks the Revised syntax changed between O'Caml 3.07 and 3.10.
16:02:40 <|Jedai|> EvanR: No, GHC does not
16:03:07 <|Jedai|> EvanR: but you have to remember that doesn't mean all the old value had to be copied
16:04:42 <|Jedai|> EvanR: for example, in a Tree, if you insert a new leave, the new tree then created will share a lot of his data with the old tree, the only thing that really needed to change was the path leading from the root to the new leave
16:05:00 <|Jedai|> s/leave/leaf/
16:08:10 <|Jedai|> EvanR: you'll notice that most of the datastructures you'll see in Haskell have this kind of property (being able to share some of their structure), that's why FP programmers prefer Maps to hash tables for instance
16:08:42 <EvanR> |Jedai|: well i guess the gc would take care of the old values
16:09:00 <|Jedai|> EvanR: right, or the part of the old value that's not shared with the newx
16:10:37 <|Jedai|> EvanR: there's also the case where we apply a big composition of transformations, some libraries will contain the necessary machinery so that no intermediary datastructure has to be created thanks to fusion rules
16:11:44 <|Jedai|> EvanR: which means that you can stay high-level in the expression of your transformation instead of rewriting it yourself as an explicit low level one pass transformation
16:12:19 <twb> How can I determine (programmatically) what ghc6/cabal/xmonad think my architecture is?  It doesn't correspond exactly to uname -m.
16:12:31 <bfh6558> byond xmonad what are some other rather large/well known programs that are coded in haskell
16:12:48 <twb> bfh6558: darcs and camp
16:12:50 <bfh6558> *wave twb
16:12:56 <bfh6558> oh
16:12:57 <bfh6558> thanks!
16:13:18 <twb> bfh6558: gitit, if that counts as "well known"
16:13:33 <bfh6558> branch off of git?
16:26:32 <Lemmih> twb: System.Info?
16:43:26 <Jafet> @hoogle digit
16:43:27 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
16:43:27 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
16:43:27 <lambdabot> Data.Char digitToInt :: Char -> Int
16:43:42 <Jafet> @src digitToInt
16:43:43 <lambdabot> Source not found. It can only be attributed to human error.
16:44:55 <copumpkin> PEBKAC
16:47:43 <bfh6558> oh my god why wouldn't they introduce folds in the chapter about recursion?
16:48:04 <bfh6558> stupid learnYouHaskell
16:48:11 <twb> You think that's bad?  Paul Graham's CL textbook doesn't mention CLOS
16:48:22 <twb> *introductory CL textbook
16:49:38 <dmead> bfh6558, folds are for people who understand recursion
16:49:42 <dmead> not that are just learning it
16:51:20 <dmead> @hoogle the secret of life
16:51:20 <lambdabot> No results found
16:51:23 <dmead> damn
16:51:25 <bfh6558> all you need to do inorder to understand recursion is to look at the mirror a barber holds up so you can see the back of your head, but instead look into the mirror thats allowing you to see the first mirror and so on
16:51:44 <dmead> uhh
16:51:44 <bfh6558> and bang, a freshman CS class learned at the barber shop
16:51:50 <dmead> i think you mean reflection :P
16:51:55 <bfh6558> ^
16:51:56 <bfh6558> yes
16:52:04 <bfh6558> i do, i cant explain very well
16:52:47 <dmead> :P
16:52:59 <dmead> ?type foldl'
16:53:00 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:54:31 <copumpkin> the back of your own head seems decent for fix
16:56:39 <bfh6558> now when talking about folds, they authors mention folds must be done with a binary operation... does that just mean one with 2 arguments or one the machine(cpu) can actually calculate
16:57:10 <copumpkin> 2 arguments
16:57:25 <bfh6558> well nvm just thinking about it i just answ
16:57:33 <bfh6558> sry fatfingered that delete
17:01:42 <Jafet> Hrm
17:01:51 <Jafet> I can't turn an Int into an Integer?
17:02:17 <bfh6558> fromInt?
17:02:23 <bfh6558> or nvm
17:02:24 <bfh6558> sry
17:02:29 <idnar> fromInteger
17:02:33 <bfh6558> yay
17:02:39 <idnar> no, fromIntegral?
17:02:42 <bfh6558> eys
17:02:54 <Jafet> :t fromIntegral
17:02:55 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:03:03 <Jafet> :t fromInt
17:03:03 <lambdabot> Not in scope: `fromInt'
17:03:05 <bfh6558> learn you haskell said that was due to some historical poop
17:03:20 <idnar> > fromIntegral (5 :: Int) :: Integer
17:03:21 <lambdabot>   5
17:03:27 <Jafet> Thankies
17:04:46 <bfh6558> So if you cant foldl [1..] but can foldr [1..], you should not be able to foldr1 [1..] correct?
17:06:06 <copumpkin> incorrect
17:06:12 <bfh6558> :(
17:06:26 <copumpkin> in fact, there's absolutely no difference between foldr1 and foldr on infinite lists
17:06:27 <bfh6558> what the balls does it take for the element next to infinity?
17:06:34 <copumpkin> lol
17:06:36 <copumpkin> there isn't one
17:07:05 <kmc> > scanl (+) 0 [1..]
17:07:06 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
17:07:17 <bfh6558> ok so lazieness happens, so dose that imply a filter/predicate must be somwhere?
17:07:31 <copumpkin> nope
17:07:52 <bfh6558> hmp
17:07:54 <bfh6558> hmpf
17:08:11 <kmc> > fix ((0:) . scanl (+) 1)
17:08:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:08:19 <bfh6558> I think I need to read up on currying once again,
17:08:27 <Jafet> Who woulda thunk that?
17:08:32 * kmc rimshot
17:08:43 <idnar> > foldr1 (:) [1..]
17:08:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:08:59 <kmc> > foldr (:) [] [1..]
17:09:00 <idnar> oh, that won't work
17:09:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:09:14 <idnar> hmm
17:09:17 <bfh6558> building an infinte list?
17:09:18 <kmc> @check \xs -> foldr (:) [] xs == (xs :: [Char])
17:09:19 <lambdabot>   "OK, passed 500 tests."
17:09:38 <idnar> I can't think of a good example for foldr1 now
17:09:49 <kmc> what is desired?
17:09:54 <bfh6558> thats because its brainmelting
17:09:57 <copumpkin> > foldr1 min ([1..50] ++ [0] ++ [1..]) :: Natural
17:09:58 <lambdabot>   0
17:10:02 <idnar> foldr1 on an infinite list
17:10:27 <kmc> ...
17:10:37 <copumpkin> wut
17:11:02 <bfh6558> the min of 1-50, 0 and 1-infinity? did i read that correctly?
17:11:05 <c_wraith> foldr1 (++) $ cycle ["foo", "bar"]
17:11:12 <c_wraith> > foldr1 (++) $ cycle ["foo", "bar"]
17:11:13 <lambdabot>   "foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfo...
17:11:28 <kmc> @src foldr1
17:11:28 <lambdabot> foldr1 _ [x]    = x
17:11:28 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
17:11:28 <lambdabot> foldr1 _ []     = undefined
17:12:09 <bfh6558> @src foldr
17:12:09 <lambdabot> foldr f z []     = z
17:12:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:12:39 <kmc> > foldl1 (++) $ cycle ["foo", "bar"]
17:12:43 <bfh6558> what is the $ in c
17:12:45 <lambdabot>   mueval-core: Time limit exceeded
17:12:45 <lambdabot>  mueval: ExitFailure 1
17:12:47 <bfh6558> c_wraith
17:12:55 <copumpkin> bfh6558: c_wraith is rich
17:12:56 <c_wraith> $ isn't anything in c
17:12:59 <bfh6558> god i cant type, the $ in c_wraith's example
17:13:01 <copumpkin> he drops $ all over the place
17:13:01 <idnar> anyhow, so on an infinite list, you never get to the last element, so it doesn't matter
17:13:09 <bfh6558> haha
17:13:14 <kmc> remember, foldr just replaces each (:) with f and the final [] with z
17:13:20 <c_wraith> oh.  the $ is just "apply the function on the left to the value on the right"
17:13:22 <kmc> that transform works just as well on infinite lists
17:13:27 <idnar> @src ($)
17:13:27 <lambdabot> f $ x = f x
17:13:30 <kmc> it's the left fold that's problematic, because it has to reverse the list structure
17:14:00 <kmc> > foldl (flip (:)) [] "some text to be reversed"
17:14:04 <lambdabot>   "desrever eb ot txet emos"
17:14:24 <kmc> > foldl (flip (:)) [] ("sheeeeee" ++ (repeat 'e') ++ "it")
17:14:29 <lambdabot>   mueval-core: Time limit exceeded
17:14:34 <kmc> > foldr (:) [] ("sheeeeee" ++ (repeat 'e') ++ "it")
17:14:38 <lambdabot>   "sheeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee...
17:14:44 <bfh6558> haskell is so fucking cool, why cant they teach this kid of stuff in college instead of stpuid B-trees that could be looked up on wikipedia in 15minutes
17:15:11 <bfh6558> kind*
17:15:12 <kmc> bfh6558, because then where would the workforce get a supply of Java drones?
17:15:25 <kmc> that said, don't be hating on B-trees
17:15:37 <kmc> you have to know what's out there before you know to look it up on wikipedia
17:15:52 <bfh6558> Oh i dont mind B-trees, i dont like writing a batch program in c++ to just log B-tree queries
17:16:32 <bfh6558> kmc: the beauty of wikipedia is their internal links!
17:16:38 <bfh6558> they tell you whats out there practically
17:17:00 <Jafet> More like what's in there, which is very little
17:17:08 <bfh6558> good point
17:17:12 <kmc> you still need that first flash of recognition where you're working on a problem and think "hey, i could use a B-tree"
17:17:18 <Jafet> There are like, five sentences on finger trees
17:17:27 <bfh6558> BOOK!
17:17:46 <kmc> it's comparatively rare to reach a point in a problem where you say "hey, i should read all the wikipedia data structures articles in alphabetical order to see what's suitable"
17:17:59 <kmc> usually people charge ahead no matter what, so the more things you recognize on the fly, the better
17:18:22 * copumpkin has a whole massive book on spatial datastructures
17:18:26 <copumpkin> have only really skimmed it though
17:18:29 <kmc> wikipedia is also often flat-out wrong
17:18:53 <kmc> or at least, it gives authoritative definitions of terms that are contentious, like "functional programming"
17:18:56 <Jafet> "I bought this huge book on how to use text indices"
17:19:30 <bfh6558> Wikipedia is my source for qeuries into my school's library
17:19:57 <bfh6558> it bascially gives me the keyword / words i should look for in titles in the library
17:20:04 <kmc> yeah
17:20:38 <kmc> that's what a good tertiary source does
17:20:48 <kmc> ideally it should cite some survey papers directly
17:21:14 <copumpkin> quaternary sources ftw
17:21:27 <kmc> that's "my friend said he read this on wikipedia"
17:21:37 <kmc> since about 80% of my conversations have that form, i'm in favor
17:21:53 <bfh6558> hahah
17:24:02 <bfh6558> totaly offtopic, any non gui pdf viewers you guys know of?
17:24:28 <kmc> pdftoppm
17:24:29 <ddarius> Considering what PDF is, that's self contradictory.
17:24:33 <kmc> pdftotext
17:24:40 <ddarius> You could use pdftotext though to, maybe, get the text.
17:24:50 <kmc> lpr
17:25:13 <bfh6558> I was thinking something like pdftohtml
17:25:20 <bfh6558> yay google
17:25:27 <bfh6558> thanks kmc
17:25:31 <bfh6558> and ddarius
17:25:53 * copumpkin is really looking forward to some solid reading time over winter break!
17:26:18 * ddarius is looking forward to some plasma reading time.
17:26:32 <copumpkin> lol
17:27:17 * opqdonut is looking forward intently
17:28:27 * copumpkin eats opqdonut 
17:28:34 <copumpkin> whoops, so much for looking forward
17:28:36 <copumpkin> om nom nom
17:29:11 <pastah_rhymez> > "om " ++ cycle "nom "
17:29:13 <lambdabot>   "om nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom...
17:29:41 <shambler> acrobad reader is cool for reading PDFs
17:29:43 <shambler> :-)
17:29:47 <c_wraith> > cycle "om n"
17:29:48 <lambdabot>   "om nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom...
17:29:53 <shambler> aww non gui ;(
17:29:56 <pastah_rhymez> shambler: acrobad?
17:30:11 <pastah_rhymez> c_wraith: gaddammit
17:30:25 <opqdonut> copumpkin is an arrow from foodstuffs to the scalar field?
17:30:34 <pastah_rhymez> Acrobad - Association de Badminton Gay et Lesbienne
17:30:46 <pastah_rhymez> queer badminton
17:30:51 <shambler> haha
17:30:55 <pastah_rhymez> that's obviously the way to go
17:31:40 <bfh6558> @src head
17:31:41 <lambdabot> head (x:_) = x
17:31:41 <lambdabot> head []    = undefined
17:31:47 <bfh6558> ok good
17:32:03 <copumpkin> head (x:_) = x
17:32:07 <copumpkin> head [] = unsafeCoerce Nothing
17:32:11 <copumpkin> :P
17:33:57 <Beelsebob> copumpkin: ouch
17:34:07 <Beelsebob> I guess that's what most C-type libraries do though
17:34:11 <copumpkin> hey, it's the thought that counts
17:37:57 <kmc> head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
17:38:37 <Beelsebob> haha
17:38:50 <Beelsebob> you've got copumpkin beat, that's for sure
17:38:55 <Beelsebob> at least his had predictable results
17:38:56 * kmc segfaulted ghci testing that
17:39:01 <Beelsebob> haha
17:39:04 <copumpkin> lol
17:39:04 <lispy|web> haha
17:39:16 <kmc> i'm not sure copumpkin's version would  be predictable
17:39:21 <lispy|web> ?remember <kmc> head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
17:39:22 <lambdabot> Nice!
17:39:25 <kmc> it depends on calling conventions and lots of lowlevel crap
17:39:37 <copumpkin> no <>
17:39:43 <Beelsebob> kmc: at least on one system it's referentially transparent
17:39:49 <Beelsebob> I think
17:40:18 <copumpkin> it depends what you do with it
17:40:25 <copumpkin> head [] 5 would be bad
17:40:33 <Beelsebob> it would
17:40:38 <copumpkin> if head [] then 5 else 6
17:40:43 <copumpkin> would probably be fin
17:40:43 <copumpkin> e
17:40:49 <copumpkin> and I'd assume would give you 6
17:40:51 <copumpkin> but who knows!
17:41:00 <kmc> e.g. a closure representing Nothing might be smaller than the closure for the type you cast to, so by accessing that type you read garbage uninitialized memory
17:41:04 <kmc> hence, non-deterministic
17:41:18 <Beelsebob> uhhuh
17:41:29 <kmc> copumpkin, 6 because False and Nothing are both the 0th constructor of their type?
17:41:37 <copumpkin> I'd assume
17:41:45 <kmc> that'd hold on a sort of naive STG machine
17:42:56 <Jafet> > let head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32) in head []
17:42:57 <lambdabot>   Not in scope: `peek'Not in scope: `intPtrToPtr'Not in scope: `unsafePerform...
17:43:04 <Jafet> Doh
17:43:19 <Jafet> I wonder what the type of that would be
17:43:34 <kmc> head :: [a] -> a
17:43:41 <Beelsebob> @type peek
17:43:43 <lambdabot> Not in scope: `peek'
17:43:47 <kmc> :t peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
17:43:49 <Beelsebob> duh >.<
17:43:49 <lambdabot> Not in scope: `peek'
17:43:50 <lambdabot> Not in scope: `intPtrToPtr'
17:43:50 <lambdabot> Not in scope: `unsafePerformIO'
17:43:56 <kmc> it's forall a. a
17:44:14 <kmc> it picks a random addr in the first 4GB of memory and reads a value of type a from there
17:44:25 <Jafet> Wouldn't head [] be a type error, then
17:44:27 <Jafet> :t []
17:44:28 <lambdabot> forall a. [a]
17:44:30 <kmc> nope
17:44:38 <kmc> Jafet, head [] is *not* a type error; that's the problem with head
17:44:47 <kmc> it's a runtime error
17:44:48 <kmc> > head []
17:44:49 <lambdabot>   * Exception: Prelude.head: empty list
17:45:00 <medfly> eh?
17:45:00 <Aviator> does haskell have an interface to crypt(3)?
17:45:00 <kmc> because you can't give the first element of a zero-element list
17:45:03 <Jafet> I mean, if you define head [] as above
17:45:08 <medfly> how can you make it into a type error?
17:45:08 <kmc> why would it be?
17:45:14 <Craig`> hey guys
17:45:23 <medfly> isn't a list with some elements the same type as an empty list?
17:45:25 <medfly> hi Woof!
17:45:43 <Woof> Hoi, medfly
17:45:45 <kmc> medfly, indeed, the empty list is in *every* list type
17:46:04 <Jafet> Oh, so it's polymorphic
17:46:11 <kmc> :t []
17:46:12 <lambdabot> forall a. [a]
17:46:21 <kmc> that's some polymorphism
17:46:22 <Jafet> ...however that works
17:46:46 <kmc> however it works in what sense?
17:47:03 <kmc> > ([] :: [Char], [] :: [Bool])
17:47:04 <lambdabot>   ("",[])
17:47:12 <kmc> > let x = [] in (x :: [Char], x :: [Bool])
17:47:13 <Jafet> I think I'll just crash ghci a bit first
17:47:13 <lambdabot>   ("",[])
17:47:59 <Twey> :t [undefined, undefined]
17:48:00 <lambdabot> forall a. [a]
17:48:17 <Twey> Hm
17:48:23 <kmc> :t let a = undefined, b = undefined, xs = [a,b] in (a, b, xs)
17:48:24 <lambdabot> parse error on input `,'
17:48:36 <Twey> Semicolons ☺
17:48:37 <kmc> :t let a = undefined; b = undefined; xs = [a,b] in (a, b, xs)
17:48:37 <Twey> > length [undefined, undefined]
17:48:38 <lambdabot> forall a a1 a2. (a, a1, [a2])
17:48:38 <lambdabot>   2
17:48:43 <Twey> Interesting
17:48:49 <kmc> shouldn't it unify those?
17:49:00 <kmc> i expected (a, a, [a])
17:49:31 <Twey> I guess not
17:49:33 <kmc> also why does my "let x = []" above not run afoul of MR?
17:49:57 <Twey> I suspect \b has the MMR turned off
17:50:34 <Craig`> meh the page keeps refusing to load for me to install ghci on this pc :/
17:50:34 <kmc> it also works in my vanilla ghci
17:50:41 <Twey> Hum
17:51:01 <Twey> Craig`: GHCi is part of GHC.  Just install ghc via your favourite package manager.
17:51:31 <Jafet> Hrm, head [] :: (Storable a) => IO a
17:51:51 <kmc> oh i probably need another unsafePerformIO
17:52:03 <Twey> x.x
17:52:10 <kmc> and unsafeInventSomeAdditionalTypeclassContext
17:52:31 <medfly> what is [] as [a]?
17:52:32 <Jafet> unsafeInvokeGHC
17:52:35 <kmc> ?
17:52:42 <Twey> Haha
17:52:50 <Twey> medfly: Hum?
17:53:22 <copumpkin> kmc: why would it unify those?
17:53:33 <copumpkin> lets are contorsionists
17:53:37 <kmc> a,b go in the same list; therefore they must have the same type
17:53:56 <copumpkin> that would happen with a lambda
17:54:27 <Craig`> Twey, yeah I'm aware of that, I'm on bloody windows this time though :/
17:55:20 <copumpkin> @type (\a b -> (a, b, [a,b])) undefined undefined
17:55:21 <lambdabot> forall t. (t, t, [t])
17:55:49 <copumpkin> :t let x = 5 in (x :: Int, x :: Double)
17:55:49 <lambdabot> (Int, Double)
17:56:04 <copumpkin> :t \x -> (x :: Int, x :: Double) 5
17:56:05 <lambdabot>     Couldn't match expected type `Double' against inferred type `Int'
17:56:05 <lambdabot>     In the expression: x :: Double
17:56:05 <lambdabot>     In the expression: (x :: Int, x :: Double) 5
17:56:11 <kmc> copumpkin, so it thinks that maybe a and b have different principal types that meet in the type for the list elems?
17:57:27 <copumpkin> :t (\(x :: (forall a. Num a => a)) -> (x :: Int, x :: Double)) 5
17:57:28 <lambdabot> (Int, Double)
17:57:51 <copumpkin> kmc: hm, not sure what you mean
17:58:13 <copumpkin> but that's one of the fundamental differences between let and case (which are what makes up core)
17:59:15 <kmc> :t let a = undefined; b = undefined; xs = [a,b] in (a, b, xs)
17:59:16 <lambdabot> forall a a1 a2. (a, a1, [a2])
17:59:27 <kmc> i mean in what situation will a, a1, and a2 differ?
17:59:41 <copumpkin> polymorphic values
18:00:12 <kmc> :t let a = ('x', undefined); b = (undefined, 'y'); xs = [a,b] in (a, b, xs)
18:00:13 <lambdabot> forall a a1. ((Char, a), (a1, Char), [(Char, Char)])
18:00:20 <kmc> mm i see
18:00:30 <copumpkin> :t let a = read "123"; b = read "45"; xs = [a, b] in (a, b, xs)
18:00:31 <lambdabot> forall a a1 a2. (Read a2, Read a, Read a1) => (a, a1, [a2])
18:00:53 <copumpkin> > let a = read "123"; b = read "45"; xs = [a, b] in (a, b, xs) :: (Int, Double, [Float])
18:00:54 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
18:00:54 <lambdabot>         against inferred ty...
18:01:35 <kmc> copumpkin, (Char, Char) is the meet of forall a. (Char, a) and forall a. (a, Char) in the lattice of polymorphic types
18:01:37 <kmc> i believe
18:01:46 <copumpkin> yeah
18:02:20 <kmc> :t let a = ('x', undefined); b = 'y'; xs = [a,b] in (a, b, xs)
18:02:21 <lambdabot>     Couldn't match expected type `(Char, a)'
18:02:21 <lambdabot>            against inferred type `Char'
18:02:21 <lambdabot>     In the expression: b
18:02:37 <copumpkin> this is weird
18:02:42 <kmc> in that case there is no meet
18:04:07 <copumpkin> Prelude> let a = read "123"; b = read "45"; xs = [a, b] in (a :: Int, b :: Double, xs :: [Float])
18:04:07 <copumpkin> (123,45.0,[123.0,45.0])
18:04:18 <copumpkin> the :t output and the > output seem to disagree in lambdabot
18:04:21 <Saizan> in the "x can instantiate to y" preorder, which is a bit unusual to talk about explicitly but it's surely used
18:05:02 <copumpkin> but kmc's example is cuter anyway
18:05:28 <Saizan> copumpkin: you've NoMR on in ghci, right?
18:05:32 <copumpkin> yeah
18:05:40 <Saizan> lb probably doesn't
18:05:43 <copumpkin> lambdabot's :t output suggests NoMR too
18:05:48 <copumpkin> :t let a = read "123"; b = read "45"; xs = [a, b] in (a, b, xs)
18:05:48 <lambdabot> forall a a1 a2. (Read a2, Read a, Read a1) => (a, a1, [a2])
18:05:59 <copumpkin> > let a = read "123"; b = read "45"; xs = [a, b] in (a, b, xs) :: (Int, Double, [Float])
18:06:00 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
18:06:00 <lambdabot>         against inferred ty...
18:06:01 <copumpkin> that suggests not
18:06:24 <Saizan> yup, they aren't even remotely the same code, so it's unsurprising there are inconsistencies!
18:06:30 <copumpkin> lol
18:06:33 <copumpkin> grr
18:07:29 <Craig`> @where LYAH
18:07:29 <lambdabot> http://www.learnyouahaskell.com/
18:08:59 <sinelaw> what's more popular? 0 included in naturals or not?
18:09:10 <copumpkin> included
18:09:30 <Jafet> Popular among the currently active participants in this channel?
18:09:34 <copumpkin> yep
18:09:43 <copumpkin> without 0 you get almost no interesting algebraic structure
18:10:17 <Jafet> Just have subclasses Positive and NonNegative
18:12:14 <copumpkin> I guess you can get a decent Distributive Lattice with LCM/GCD on naturals without 0
18:37:02 * hackagebot upload: hakyll 0.2 - A simple static site generator library. (JasperVanDerJeugt)
18:42:43 <copumpkin> @hackage hakyll
18:42:43 <lambdabot> http://hackage.haskell.org/package/hakyll
18:43:48 <knobo> Is it possible to redirect stdout to a file?
18:45:39 <knobo> or rather: how can I do it?
18:45:51 <leadnose> from inside the program?
18:46:15 <leadnose> or at startup time?
18:46:37 <bfh6558> oh boy i just found out haskell has a reddit, my life is now complete
18:46:46 <Jonno_FTW> i found that a while ago
18:47:00 <bfh6558> is it worth it to frontpage it?
18:47:12 <CalJohn> yes, bfh6558
18:47:16 <CalJohn> it's medium traffic
18:47:31 <bfh6558> ssweeet
18:49:01 <leadnose> knobo, if you are on unix, "my-program > foo" will redirect the stdout of my-program to foo
18:49:03 <knobo> leadnose: in haskell yes :)
18:49:31 <leadnose> i'm still looking at the other option
18:49:31 <knobo> I thought this was the haskell channel :P
18:49:45 <leadnose> yes this is
18:50:15 <knobo> let stdout = some_handler in ... does not work.
18:51:04 <Twey> No
18:51:09 <knobo> in lisp I can do that.
18:51:11 <copumpkin> use dup2
18:51:11 <Twey> But GHC's Handle type has a magic MVar
18:51:14 <Twey> That you can fiddle with
18:51:19 <Twey> knobo: This is not a good thing :þ
18:51:34 <copumpkin> let ?stdout = ... in
18:51:38 * copumpkin coughs
18:52:10 * Twey threatens copumpkin with a garden weasel.
18:58:01 <bfh6558> @src intersection
18:58:02 <lambdabot> Source not found. My brain just exploded
18:59:19 <Peaker> knobo: Haskell does not restrict what you can do - but it does require you're explicit about it.  If you're passing a new stdout to all functions in a certain call stack - Haskell requires you to do this explicitly.  In many languages, this implies "tediously" - but Haskell has rich abstractions that make this explicit kind of passing-stuff-around very non-tedious
19:00:01 <Peaker> knobo: for example, using an abstraction called a "Reader Monad", you can automate the "stdout" argument passing everywhere -- and have a very small addition to the type signature to express this
19:34:56 <knobo> Peaker: where can I read more about the Reader Monad?
19:38:55 <Tom_> anyone know how to add ghci to jedit?
19:39:10 <Saizan> ?google all about monads
19:39:11 <lambdabot> http://www.haskell.org/all_about_monads/
19:39:11 <lambdabot> Title: All About Monads
19:39:46 <Saizan> knobo: http://www.haskell.org/all_about_monads/html/readermonad.html
20:06:24 <Jonno_FTW> @src intersect
20:06:24 <lambdabot> intersect = intersectBy (==)
20:06:32 <Jonno_FTW> @src intersectBy
20:06:32 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
20:06:39 <Jonno_FTW> @src eq
20:06:41 <lambdabot> Source not found. You speak an infinite deal of nothing
20:07:15 <Jonno_FTW> what is eq?
20:08:33 <profmakx> @type intersectBy
20:08:33 <Twey> Eq is a typeclass, not a value
20:08:34 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
20:08:36 <Twey> @info Eq
20:08:37 <lambdabot> Eq
20:08:39 <dschoepe> Jonno_FTW: a parameter to intersectBy
20:08:41 <Twey> Unhelpful
20:08:46 <Jonno_FTW> no kidding...
20:08:46 <Twey> Oh, I see, sorry
20:08:47 <profmakx> Twey he is talking about the argument
20:08:50 <Twey> Yes
20:09:04 <Twey> I didn't connect the two searches ☺
20:09:17 <Twey> Jonno_FTW: eq can be any function of the appropriate type
20:09:27 <Jonno_FTW> oh, equation?
20:09:46 <Jonno_FTW> why not use f xs ys
20:09:48 <Jonno_FTW> ?
20:10:01 <Jonno_FTW> or is it standard to use eq ?
20:10:03 <Twey> Equality
20:10:10 <Twey> It's an equality check
20:10:12 <Jonno_FTW> ok
20:10:15 <Twey> Therefore, it's been named ‘eq’
20:10:18 <Jonno_FTW> a /= b
20:10:23 <Twey> It could be called ‘f’ if you like
20:10:23 <Jonno_FTW> > a /= b
20:10:25 <lambdabot>   True
20:10:33 <Twey> It doesn't really matter, though ‘eq’ is a bit more informative
20:10:45 <Jonno_FTW> > let a =b in a /= b
20:10:47 <lambdabot>   False
20:18:47 <Beelsebob> anyone want to see how amazingly beautiful Obj-C can be now it has some functional constructs?
20:18:48 <Beelsebob> http://paste.lisp.org/display/92022
20:18:49 <Beelsebob> >.>
20:20:17 <Twey> Oh, simply lovely.
20:20:28 <Beelsebob> hehe
20:20:43 <Beelsebob> considering that's essentially map name . sort . filter isTiled
20:20:45 <Beelsebob> >.<
20:21:20 <Twey> :þ
20:26:20 <Jonno_FTW> > ( 5+6) == (9+3) == 12
20:26:22 <lambdabot>   Precedence parsing error
20:26:22 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
20:26:47 <Jonno_FTW> is it possible to chain to together 3 comparisons?
20:31:33 <Twey> Reminds me of what I was doing in VB.NET yesterday… Dim result As List(Of Foo) = New List(Of Foo)(From y In (From x In xs Order By x Ascending Select x) Where y.IsTiled Select(y.Name))
20:31:39 <Stinger> you can chain together comparisons, as long as after the first one, you are comparing booleans :P
20:31:56 <Stinger> > 1==1==True
20:31:57 <lambdabot>   Precedence parsing error
20:31:57 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
20:31:58 <Jonno_FTW> ok
20:32:03 <Stinger> heh or perhaps not
20:32:08 <Jonno_FTW> i usually just &&
20:32:29 <Jonno_FTW> > 1 == 1 && True == (1+0)
20:32:30 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
20:32:30 <lambdabot>    arising from the literal `1'...
20:32:42 <Jonno_FTW> > (1 == 1) && (True == (1+0))
20:32:44 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
20:32:44 <lambdabot>    arising from the literal `1'...
20:32:53 <Jonno_FTW> > (1 == 1) && (True == (1>0))
20:32:54 <lambdabot>   True
20:32:58 <Jonno_FTW> like tht
20:33:04 <Jafet> > and $ foldr1 (==) [5+6,9+3,12]
20:33:05 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
20:33:05 <lambdabot>         against inferred typ...
20:33:27 <Jafet> Oh, right
20:34:20 <Jonno_FTW> say, why doesn't this work?
20:34:30 <Jonno_FTW> > map (fst^snd) [(1,2),(4,3)]
20:34:31 <lambdabot>   No instance for (GHC.Real.Integral ((a, b) -> b))
20:34:31 <lambdabot>    arising from a use of ...
20:35:07 <Jafet> > let vals = [5+6,9+3,12] in and $ zipWith (==) vals (tail vals)
20:35:08 <lambdabot>   False
20:35:18 <Lemmih> Jonno_FTW: Because (fst ^ snd) doesn't make sense.
20:35:21 <Jafet> How would you expect that to work?
20:35:33 <Jonno_FTW> isn't fst the a in (a,b)
20:35:40 <Jafet> No, fst is a function.
20:35:46 <Jonno_FTW> oh right
20:35:57 <Jafet> @pl \(x,y) -> x^y
20:35:57 <lambdabot> uncurry (^)
20:36:11 <Jonno_FTW> ok
20:36:17 <Jafet> > map (uncurry (^)) [(1,2),(4,3)]
20:36:18 <lambdabot>   [1,64]
20:36:57 <Jafet> Hrm.
20:37:03 <Jafet> > let vals = [5+6,9+3,12,undefined] in and $ zipWith (==) vals (tail vals)
20:37:04 <lambdabot>   False
20:37:12 <Jafet> Yay
20:50:32 <napsy> Is there a tutorial for dealing with multidimensional arrays?
20:52:46 <Baughn> Is one needed?
20:53:07 <napsy> I was looking at some examples and it looks complicated
20:53:13 <HugoDaniel> napsy: just map a tuple :P
20:53:16 <Baughn> > array ((0,0),(2,2)) [((0,0),42)]
20:53:17 <lambdabot>   array ((0,0),(2,2)) [((0,0),42),((0,1),* Exception: (Array.!): undefined ar...
20:54:10 <Baughn> Well, admittedly there is the problem that multi-dimensional arrays are inexplicably slow
20:54:33 <napsy> what if I want to create an array with the given row, column values
20:54:34 <Baughn> (Or are they? Let's see the bug-tracker again..)
20:55:17 <Baughn> > listArray ((0,0),(1,1)) [0,1,2,3,4,5]
20:55:18 <lambdabot>   array ((0,0),(1,1)) [((0,0),0),((0,1),1),((1,0),2),((1,1),3)]
20:55:23 <Baughn> napsy: Like that?
20:55:33 <Jonno_FTW> what is an array in haskell?
20:55:45 <Jonno_FTW> is it similar to a matrix?
20:56:19 <napsy> Baughn: well I want to construct for example a 3x3 matrix and later fill in the values
20:56:31 <Baughn> Jonno_FTW: It's an key-value map, with O(1) read access. Same as any other language.
20:56:52 <Baughn> Jonno_FTW: Boxed arrays additionally allow lazy construction of individual values. Unboxed ones, not so much.
20:57:11 <Baughn> napsy: You want a /mutable/ array?
20:57:13 <Baughn> napsy: ..are you sure?
20:57:43 <napsy> Baughn: I'm trying to create a sinkship game for practice ... I guess the array should be mutable since the state changes
20:58:22 <Twey> Unlikely
20:58:30 <Jonno_FTW> battleships in haskell?
20:58:32 * QtPlaty[HireMe] read sinkship as skinship
20:58:33 <Twey> You're thinking too imperatively
20:58:35 <Baughn> napsy: You could just make a new arary each turn
20:58:46 <Baughn> napsy: Or, better yet, use Data.Map
20:58:51 <napsy> hm how is then the state of the games saved?
20:58:57 <Twey> It's not
20:59:04 <Twey> It's passed around
20:59:40 <Twey> takeTurn :: IArray (Int, Int) ShipPiece -> PlayerInput -> IArray (Int, Int) ShipPiece, hmn?
21:00:14 <napsy> hm
21:01:59 <Philonous> It really takes some overcoming to get used to the way variables (even large ones) are created and discarded willy-nilly rather than mutated. But you will stop worrying and start to love the gc eventually.
21:03:57 <Jonno_FTW> can someone help here?
21:04:04 <Twey> No
21:04:09 <Jonno_FTW> rad n = product' $ map (fst) $ primePowerFactors n abcHit (a,b,c) = (((gcd a b) == (gcd a c)) && ((gcd b c) == 1)) && ((rad (a*b*c)) < c ) hits =length$ takeWhile (<1000) [c|b<-[1..],a<-[1..(b-1)],c<-[a+b],abcHit (a,b,c)]
21:04:10 <Twey> We're all just sat here to discuss athletics
21:04:20 <Jonno_FTW> oh good
21:04:22 <Jonno_FTW> well
21:04:23 <sinelaw> Not I
21:04:30 <Stinger> so, yeah, running
21:04:39 <Jonno_FTW> i'm doing this question right
21:04:41 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=127
21:04:48 <Jonno_FTW> and i only got 30 out of 31 in the example
21:04:57 <Twey> Woah, crap, that's a huge function with crazy formatting
21:05:13 <Jonno_FTW> imagine the original formatting is still there
21:05:20 <sinelaw> or a crazy function with huge formatting
21:05:48 <Jonno_FTW> what's wrong with huge unreadable formatting?
21:05:58 <Jonno_FTW> if i am the only person who will read it?
21:06:41 <Stinger> and yet here it is
21:06:47 <Stinger> in our channel, asking for help :D
21:07:39 <Jonno_FTW> oh snap
21:07:47 <Jonno_FTW> i'll post again
21:07:57 <Jonno_FTW> without huge (TM) formatting
21:08:03 <Stinger> generally people post to paste sites
21:08:03 <Jonno_FTW> rad n = product' $ map (fst) $ primePowerFactors n
21:08:08 <Jonno_FTW> capital idea
21:08:17 <Jonno_FTW> to the hpaste mobile
21:08:23 <Jonno_FTW> but it is only 3 lines
21:10:18 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14088#a14088
21:11:08 <Twey> It's still crazy
21:11:25 <Jonno_FTW> why?
21:11:38 <Jonno_FTW> is it the lack of pointfree anything?
21:12:09 <Stinger> you don't need to do c <- [a+b] btw
21:12:28 <Jonno_FTW> then what do i do?
21:12:35 <Stinger> although you do have that guard
21:12:47 <Jonno_FTW> just use a+b ?
21:12:59 <Stinger> yeah
21:13:03 <Jonno_FTW> but
21:13:08 <Jonno_FTW> clarity?
21:13:21 <Twey> This is why I want whitespace-sensitivity in Haskell >.<
21:13:47 <Jonno_FTW> but that isn't the cause of the problem
21:13:59 <Jonno_FTW> i get 30 solutions where i should get 31
21:14:14 <Stinger> how would ws sensitivity help you here? :P
21:14:46 <Jonno_FTW> ws sensitivity?
21:14:52 <Twey> It would go a long way towards making that readable
21:15:02 <Twey> Also, GHC errors when people use hard-tabs
21:15:20 <Jonno_FTW> is it similar to hlint?
21:15:21 <Twey> (or soft-tabs?  I can never remember which way around those go)
21:15:38 <Twey> (the ones that screw up layout depending on how you look at them)
21:15:45 <Stinger> soft tabs is that automatic spacing thing isnt it
21:15:53 <Stinger> i.e. the new one :P
21:16:22 <Stinger> rather than the old traditional automatic spacing move to x+8 (mod 8)
21:18:31 <Jonno_FTW> but
21:18:55 <Jonno_FTW> what part is not readable?
21:19:31 <Baughn> Twey: Latest darcs version of haskell-mode handles hard-tabs correctly, if that's a problem
21:19:48 <Baughn> ..for "looks horrible, but produces ghc-readable output" values of "correctly"
21:22:52 <Jonno_FTW> ?
21:23:10 <Jonno_FTW> is my search missing something?
21:23:39 <Twey> Yes: whitespace
21:23:58 <Jonno_FTW> is that a likely cause of error here?
21:24:26 <mreh> what monad encapsulates a function application if any?
21:24:30 <Twey> No, it's a likely cause of nobody being able or willing to figure out the error here ;)
21:24:37 <Jonno_FTW> well
21:24:41 <Twey> mreh: Reader (A.K.A. (-> r))
21:24:44 <Jonno_FTW> it's fixed up no
21:24:46 <Jonno_FTW> w
21:24:48 <Twey> Er, (r ->)
21:24:50 <Jonno_FTW> with loads of whitespace
21:25:25 <ErhardtMundt> BONUS, _o/
21:25:26 <mreh> Twey: it mentions "standard reader monad" in the HGL source code, likely to be the same thing?
21:25:51 <ErhardtMundt> hey Twey
21:25:56 <ErhardtMundt> :)
21:26:11 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14088#a14093 — this is how the problem is explained.  Does it give you the result you expect?
21:26:14 <Stinger> There's two reader monads, one is wrapped in a data constructor
21:26:19 <Twey> mreh: Yes
21:26:22 <Twey> ErhardtMundt: Hey ☺
21:26:24 <Stinger> this was confusing me until yesterday
21:29:09 <Jonno_FTW> it does not give the correct result
21:36:33 <mreh> was implementing do syntax such a good idea?
21:37:15 <mreh> it's caused me a lot of confusion :(. all it does is save typing
21:38:07 <mreh> it's a honey trap for C programmers methinks
21:38:14 <Jonno_FTW> hmm
21:38:14 <Jafet> Stop thinking in C then
21:38:20 <Jafet> Jeez
21:38:22 <Jonno_FTW> i don't know C
21:38:38 <Jafet> @quote intPtrtoPtr
21:38:38 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
21:39:07 <mreh> why write C syntax in a language that isn't imperative then?
21:39:23 <Jafet> It isn't C syntax.
21:39:51 <Jafet> And of course, Haskell is the best imperative language.
21:39:52 <mreh> you could have fooled me and the rest of the world who weren't let in on the secret
21:40:25 <Jafet> There is no secret, unless you have trouble reading the Haskell report or a tutorial
21:40:44 <Jafet> In which case you should ask about that instead of complaining
21:41:17 <mreh> It's nice to know some people care
21:42:42 <Jonno_FTW> i found the problem
21:43:18 <Jonno_FTW> the list of c's go [..729,1369,961]
21:44:05 <Jafet> @undo do { know <- that; this <- is; all <- contrived; let { it = become clear; } in your mind; return enlightened; }
21:44:05 <lambdabot> that >>= \ know -> is >>= \ this -> contrived >>= \ all -> let { it = become clear} in your mind >> return enlightened
21:44:59 <mreh> no programmer would set out code like that!
21:45:40 <mreh> do syntax is fine, I think it shouldn't be taught though
21:46:34 <Jafet> Set out code like what?
21:46:56 <mreh> how lambdabot does
21:47:27 <Jafet> Yet you seem to enjoy writing code like that
21:47:57 <Berengal> I write code like that sometimes, but not if it turns into a large chain
21:48:00 <mreh> I like to put the odd newline in between statements though, when my return button is broken
21:48:08 <mreh> you know
21:48:47 <xerox> mreh: there is also is the option of using do { ...; ...; ... }
21:49:04 <Jafet> Well, in the past ten minutes I have not seen a single reason from you why you do not like do syntax. Thus I conclude that you are being a troll. Good day to you.
21:50:04 <mreh> it's the understanding, it's obscured by the syntax
21:50:35 <mreh> I don't actually assign a value to a in a <- foo bar
21:50:48 <xerox> actually it's one of the strengths: we call it programmable semicolon.
21:51:45 <xerox> mreh: no you bind it, and the binding is in scope for the length of the do block
21:52:18 <Jafet> Yes you do.
21:52:25 <xerox> and that is exactly what the syntax transformation says:  do { x <- amb; ... }  ~=  amb >>= \x -> do { ... }
21:52:30 <Jafet> Except in this land we call it binding, not assignment.
21:52:32 <Saizan> mreh: it's just that one should learn the proper semantic rather than "oh this looks like the other languages i know, it'll work the same"
21:53:00 <xerox> (see, >>= is `bind'.)
21:53:11 <mreh> I understand the concepts, I
21:53:30 <mreh> object to the way it's taught, anyway
21:54:35 <xerox> who's teaching you?
21:55:00 <mreh> we are teaching in yesterdays language, I think we need to be more explicit about how the semi colon in haskell is different
21:55:06 <mreh> the internet mostly
21:55:19 <mreh> SOE, RWH
21:55:29 <Jafet> Blame the internet!
21:55:43 <Jonno_FTW> SOE?
21:55:48 <mreh> school of expression
21:55:50 <mreh> paul hudak
21:55:53 <cizra> Will ghc automatically use Ints even when I tell it the function uses Integers, if it seems that the numbers can fit into Ints?
21:55:56 <Saizan> @quote ddarius.*paper
21:55:56 <lambdabot> No quotes match. My pet ferret can type better than you!
21:55:56 <cizra> (optimization)
21:56:36 <mreh> cizra: I don't think it does dynamic optimisation
21:56:59 <mreh> it's all static, so how could I tell if the Integer could fit into an Int at execution time?
21:57:10 <cizra> OK
21:57:21 <Saizan> ?src Integer
21:57:21 <lambdabot> data Integer = S# Int#
21:57:21 <lambdabot>              | J# Int# ByteArray#
21:57:22 <idnar> actually, I think it does
21:57:41 <idnar> yeah, there you are
21:57:46 <mreh> oooh
21:57:50 <mreh> you learn something everyday
21:57:55 <ray> # is a visual representation of a box with stuff coming out of the corners, right?
21:57:57 <lunabot>  luna: parse error on input `of'
21:58:05 <Saizan> but that's not exactly an Int, it still has the overhead of branching on the constructor
21:58:15 <ray> @botsack
21:58:15 <lunabot>  :o
21:58:15 <lambdabot> :)
21:58:53 <Jafet> ghc uses tagged numbers, doesn't it
21:59:18 <Saizan> nah, only tagged pointers
21:59:24 <Saizan> > maxBound :: Int
21:59:25 <lambdabot>   9223372036854775807
21:59:31 <dinx>  hey all, i am trying to install ghc binary but i have run into  the "openFile: does not exist (No such file or directory)" error.  i know downgrading to 6.10.3 works, but just woundering if theres  a fix for this.
22:00:06 <cizra> > maxBound :: Integer
22:00:07 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
22:00:08 <lambdabot>    arising...
22:00:09 * cizra loves abusing pets
22:00:13 <cizra> uh, bots
22:00:15 <cizra> :-D
22:00:39 <mreh> cizra: freudian slip
22:01:03 * cizra loves doing intentional freudian slips. My favourite window manager is xgonad.
22:01:19 <Saizan> dinx: what gives you that error?
22:01:39 <syntaxglitch> cizra, gonad transformers sound awkward though
22:01:45 <dinx> Saizan: trying to install the ghc 6.10.4 binary..
22:02:12 <Saizan> dinx: so from make install? did you ./configure first? maybe you need to run make install with sudo
22:05:23 <HaskellLove> I watch a video lecture from chanel 9 by Brian Beckman on the state monad. He shows his code and some data flow diagrams, cool stuff, i think for complicated projects with functional programming you gotta have uml to model everything...
22:07:35 <mreh> HaskellLove: BRIAN! CHARLES!
22:07:43 <mreh> those two should just get married
22:07:53 <HaskellLove> yeah those
22:07:55 <mreh> nobody is fooled
22:09:37 <HaskellLove> I think i will advance 100 % if i integrate uml into my functional programming workflow
22:10:05 <syntaxglitch> Pf, I plan my Haskell programs with flowcharts.
22:10:39 <HaskellLove> syntaxglitch cool, can i see some examples please? u use uml?
22:11:27 <syntaxglitch> I'd send you some examples but since this is Haskell, I drew the flowcharts only when needed, instead of up front
22:11:33 <syntaxglitch> and it turned out I never needed them
22:11:42 <sinelaw> u?
22:11:43 <syntaxglitch> go lazy evaluation!
22:12:02 <necroforest> is there a "standard" (or just really good) matrix/math library for Haskell?
22:12:07 <necroforest> I'm thinking something like Numpy or SciPy
22:12:28 <HaskellLove> syntaxglitch>	so u use flowcharts or you dont i did not understand?
22:12:38 <mreh> necroforest: hmatrix
22:12:51 * cizra has troubles grokking folds )= I want to apply a function 100,000,000 times on a certain number. How to do it most easily? I have a gut feeling folding over [1..100000000] would be the easiest, but I'm very uncomfortable around them.
22:13:02 <mreh> I use it all the time, machine learning, graphics, it's all good
22:13:40 <mreh> I think there is a static version of it somewhere too, that's really useful for graphics, where you know the size of your matrices and vectors
22:13:54 <ziman> cizra, yes, that's one option; you might have a look at iterate as well
22:13:57 <ziman> :t iterate
22:13:58 <lambdabot> forall a. (a -> a) -> a -> [a]
22:14:04 <dinx> Saizan: http://pastebin.com/m506b33df
22:14:17 <necroforest> mreh,  thanks
22:14:18 <xerox> cizra: I usually do a loop with an auxiliary function and a decreasing number, but that's me :)
22:14:50 <Berengal> The problem with iterate is that it's lazy. Simply indexing into the resulting list is probably going to blow the stack
22:15:17 <ziman> > (iterate (+1) 0) !! 1000000
22:15:18 <lambdabot>   * Exception: stack overflow
22:15:22 <Saizan> dinx: but which command did you run?
22:15:49 <cizra> xerox: (= I just experimented with 2^n. Seems to work from the second try.
22:16:01 <ziman> > (iterate ((+1) . join seq) 0) !! 1000000
22:16:03 <cizra> xerox: foldr (\x y -> 2*y) 1 [1..10]
22:16:03 <lambdabot>   * Exception: stack overflow
22:16:13 <mreh> necroforest: hmatrix-static is a wrapper you have to get separately
22:16:21 <Saizan> > let force [] = []; force (x:xs) = x `seq` x : xs in (force $ iterate (+1) 0) !! 1000000
22:16:23 <lambdabot>   * Exception: stack overflow
22:16:28 <dinx> Saizan: make install
22:16:40 <xerox> cizra: everybody gets caught! =)
22:16:59 <cizra> xerox: What did you mean?
22:17:06 <Saizan> > let force [] = []; force (x:xs) = x `seq` (x : xs) in (force $ iterate (+1) 0) !! 1000000
22:17:07 <lambdabot>   * Exception: stack overflow
22:17:08 <xerox> both last examples hehe
22:17:23 <Saizan> weird.
22:17:27 <Berengal> > foldl1' const . take 1000000 . iterate (+1) $ 0
22:17:28 <lambdabot>   0
22:17:37 <Berengal> > foldl1' (flip const) . take 1000000 . iterate (+1) $ 0
22:17:40 <lambdabot>   999999
22:18:05 <EvilTerran> any category theory types on?
22:18:24 <chrisdone> > fix (\f n -> if n<1000000 then f (2*n) else n) 1
22:18:25 <lambdabot>   1048576
22:18:49 <chrisdone> mmmm. fix
22:19:26 <Saizan> > let force [] = []; force (x:xs) = x `seq` force (x:xs) in (force $ iterate (+1) 0) !! 1000000
22:19:30 <lambdabot>   mueval-core: Time limit exceeded
22:19:32 <cizra> Grr, I get stack overflows.
22:19:43 <EvilTerran> I've been looking at the formalisation of diagrams in a category C as functors F : J -> C for some index category J
22:19:43 <Saizan> forgot to recurse.
22:19:44 <cizra> I have a legitimate need to run a loop 100 million times )=
22:19:55 <xerox> Saizan: right on!
22:20:49 <Berengal> > let iterate' f !x = x:iterate' f (f x) in (iterate' (+1) 0) !! 1000000
22:20:50 <lambdabot>   <no location info>: Parse error in pattern
22:21:00 <Berengal> lambdabot doesn't do bang patterns?
22:21:04 <Saizan> cizra: you've to seq the value at each step
22:21:24 <Saizan> cizra: or use my force if you're going via a list, like with iterate
22:21:30 <chrisdone> cizra: what expression are you getting a stack overflow on?
22:22:03 <Saizan> force = foldr (\x xs -> x `seq` (x : xs)) []
22:22:32 <EvilTerran> and it's got me thinking about these two functors i've come up with (I say that, i bet it's been done before, i just haven't read it if it has)
22:22:33 <cizra> chrisdone: foldr (\x y -> prev y) 99226228 [1..100000000]
22:22:53 * cizra currently investigates how to change the stack size (=
22:22:59 <cizra> heh, always seeking stupid shortcuts
22:23:05 <ray> try foldl'
22:23:25 <EvilTerran> Fst : C x D -> C, by Fst(A,B) = A, Fst(f,g) = f; Snd : C x D -> D, likewise
22:24:36 <xerox> > foldl' (\a x -> a*x) 1 (replicate 1000 2)
22:24:37 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
22:24:49 <EvilTerran> i've wound up with something that seems to be a natural transformation from Fst(F-,G-) to Snd(F-,G-) (i forget the specifics of F and G), and i was wondering if i was missing a nicer way of expressing that
22:25:24 <EvilTerran> (Fst(F-,G-), Snd(F-,G-) : C x D -> E, where F : C -> E, G : D -> E)
22:26:44 <chrisdone> ray: that put my memory usage up to 100% =)
22:26:47 <HaskellLove> why don't you haskellers create UML to HASKELL translator?
22:27:03 <Berengal> We have no use for UML
22:27:11 <EvilTerran> HaskellLove, because i'd rather write my code in haskell than write it in UML and get a machine to translate it
22:27:12 <cizra> Yeah, but you have use for Haskell!
22:27:21 <cizra> So translate all the world's UML to gain a lot of use!
22:27:23 <EvilTerran> HaskellLove, i'd find it easier and probably do a better job
22:27:24 <ray> no use for ML either
22:27:24 <cizra> uh, do I sound trollish?
22:27:45 <EvilTerran> cizra, satirically so, but yeah :)
22:27:58 <cizra> (=
22:28:08 <ray> no UML, no ML, and no L
22:28:16 <profmakx> Haske
22:28:17 <profmakx> ?
22:28:17 <ray> and certainly no
22:28:33 <ray> although haskell is full of empty strings i guess
22:28:49 <Jafet> UML? OMG!
22:28:54 <Berengal> Every polymorphic nil is potentially an empty string
22:28:56 * EvilTerran wonders which particular forgetful functor U is in ML -> UML
22:29:01 <ray> we have full OMG support
22:29:10 <shambler> :-)
22:29:14 <HaskellLove> Why do you guys hate UML u crazy or something? do you know the potential of UML > Haskell?
22:29:40 <shambler> is UML turing complete?
22:29:51 <Jafet> What relevance does UML have to Haskell?
22:29:53 <ray> is turing completeness a useful property?
22:29:54 <Berengal> I'd rather just embed my description language directly in Haskell. Much easier to work with.
22:29:58 <EvilTerran> HaskellLove, they're incomparable, they don't solve the same problem.
22:30:02 <Jafet> Why not HTML to Haskell instead?
22:30:11 <Jafet> Or TeX to Haskell>
22:30:16 <Jafet> TeX is Turing complete!
22:30:22 <syntaxglitch> So is XSLT
22:30:23 <Berengal> Jafet: There's plenty of Haskell to HTML libraries...
22:30:23 <syntaxglitch> chew on THAT one
22:30:34 <EvilTerran> Jafet, syntaxglitch - so are java templates!
22:30:40 <syntaxglitch> C++ template metaprogramming also
22:30:43 <Jafet> java2hs!
22:30:46 <Berengal> Haskell to TeX too, if you consider literate haskell...
22:30:48 <ray> the haskell type system!
22:30:54 <shambler> :X
22:30:55 <shambler> madness
22:31:03 <syntaxglitch> C++ template metaprogramming is even a pure functional language, I think
22:31:11 <syntaxglitch> ray: is it actually?
22:31:15 * EvilTerran suddenly gets back to thinking about simply-kinded type systems
22:31:15 <ray> tarpit #352907!
22:31:27 <syntaxglitch> EvilTerran, just use the simply typed lambda calculus
22:31:28 <ray> why not complicatedly-kinded ones
22:31:31 <EvilTerran> syntaxglitch, it is with the -XUndecidableInstances extension
22:31:51 <Jafet> glitch, but that isn't Turing complete
22:31:56 <ray> turing completeness is only an interesting property when you're inventing CS for the first time
22:32:03 <EvilTerran> syntaxglitch, i mean, a lambda calculus in which the *types* are the simply-typed lambda calculus
22:32:16 <EvilTerran> syntaxglitch, i haven't worked out if it's an entirely coherent concept yet
22:32:22 <Axman6> HaskellLove: it doesn't fit well with haskell. it's far too object oriented
22:32:27 <ray> dependent kinds!
22:32:28 <HaskellLove> u guys dont get it do you... i am not talking of uml as it is now chesus christ... i am talking about similar software where 1. you will have all haskell functions as nodes 2. you can combine those  3. u can create new and specify input/output type number of parameters and so on... what is so fuckin confusing here?
22:32:43 <HaskellLove> Axman6> I am not talking of uml as it is now dude
22:32:48 <Jafet> If you want a UML to Haskell translator so badly, go away and write it
22:32:48 <Twey> Sounds like Djinn
22:32:52 <EvilTerran> HaskellLove, oh right, when you said "UML" you didn't actually mean "UML", you meant "Something i haven't defined that's better than UML". GTFO troll.
22:33:00 <syntaxglitch> Yeah, I was joking about the simply-typed lambda calculus :P
22:33:04 <Axman6> HaskellLove: what are you talking about then... what other UML is there?
22:33:30 <HaskellLove> Axman6> man there is none, i talk about the potential of such software
22:33:35 <BONUS> why would i want to draw haskell functions insteadof just coding them
22:33:37 <ray> just use the untyped lambda calculus
22:33:42 <chrisdone> > let applyntimes n f = fix (\i n' -> if n'<n then i $ f n else f n) 1 in applyntimes (10^8) (*2)
22:33:42 <lambdabot>   200000000
22:33:45 <Axman6> HaskellLove: i know someone who was working on something like that
22:33:46 <Berengal> There has actually been some work on translating haskell code into graphs...
22:33:51 <shambler> oh my god, for the first time I see hate on this channel
22:34:03 <ray> hate? this cannot be permitted
22:34:06 <syntaxglitch> ray: church numerals and all?
22:34:08 <ray> please report for re-edcation
22:34:10 <Jafet> Berengal, such as... all haskell compilers?
22:34:11 <Axman6> Beelsebob: you around?
22:34:19 <HaskellLove> BONUS>	imagine you have a project with 1000 functions, would you rather lurk the fuckin code or have a diagram in front of you?
22:34:29 <ray> type systems are so last century
22:34:39 <shambler> :\
22:34:41 <Berengal> Jafet: For example
22:34:44 <syntaxglitch> HaskellLove, I'd rather look at the code, you can't grep a diagram
22:34:46 <EvilTerran> i'd rather look at the code. it's precise.
22:34:46 <ray> let's duck type everything
22:34:58 * Jafet bites ray
22:34:58 <BONUS> i'd rather have the code neatly split up into sensible modules
22:35:00 <Axman6> hmm, anyone happen to know how to get java to use more heap space? (the java executable that is, not writing code to do it...)
22:35:01 <EvilTerran> syntaxglitch, anyway, as the STLC is strongly-normalising, and i figure that's a good property for a type-system to have, so i've been trying to work out if it makes sense at all
22:35:01 <Berengal> ray: The way Go does?
22:35:03 <Jafet> Wait, I think pythons crush.
22:35:11 <Jafet> Better check.
22:35:16 <EvilTerran> syntaxglitch, er, excuse the bad grammar :P
22:35:19 <ray> now don't get me started on go
22:35:21 <syntaxglitch> EvilTerran, it makes at least superficial sense to me, actually
22:35:22 <HaskellLove> u guys dont get it do you... that kind of software would be a bad ass...
22:35:22 <chrisdone> you can't express a whole system in a page of code
22:35:30 <Berengal> Axman6: Some weird parameters to the jvm
22:35:40 <Jafet> Unfortunately, that software doesn't exist, so we cannot evaluate the quality of its ass.
22:35:41 <Berengal> Axman6: -X256M or something
22:35:47 <cizra> HaskellLove: Want to get rich?
22:35:59 <cizra> HaskellLove: Write an UML to Haskell converter. It'd be badass. You'd get rich selling it.
22:36:12 <Jafet> Expert systems!
22:36:19 <ray> progrummers will never give up their greenscreen displays
22:36:20 <syntaxglitch> ray: I've actually been toying with some ideas for making a language that's essentially static implicit duck typing... probably been before though
22:36:20 <Axman6> HaskellLove: i think it would be interesting, but not 'bad ass'. it might be useful for learning functional programming, but not for programming in general. also, you should look into Apple's Quartz composer, it's very similar to what you're suggesting
22:36:31 <Axman6> Berengal: looks good enough
22:36:32 <ray> though the hardware may change slightly their minds will not
22:36:58 <EvilTerran> syntaxglitch, it occurs to me that System-Fw is more-or-less simply-kinded-types, with the only base kind being *. I guess you'd need kind-polymorphism too to make it simply-kinded-typed-lambda-calculus
22:37:03 <Jafet> Uh, static duck typing is a contradiction in terms
22:37:06 <ray> syntaxglitch: if you had implicit interfaces like go, you'd be pretty far
22:37:08 <syntaxglitch> EvilTerran, I assume your goal is along the lines of making a type system that allows computation of a sort and is as powerful as possible without compiling being subject to the Halting Problem
22:37:16 <Berengal> ray: Very true. In fact, I do all my programming on black screens with green text.
22:37:16 <EvilTerran> syntaxglitch, exactly!
22:37:18 <Twey> Jafet: Not necessarily
22:37:42 <Jafet> Unless you are implementing duck typing using a sufficiently powerful static typing system.
22:37:45 <ray> berengal: it will take the world being consumed in nuclear fire for programmers to advance beyond that :)
22:38:01 <Berengal> ray: You mean black text on white backgrounds?
22:38:16 <syntaxglitch> ray: It might have, I don't recall how Go does it
22:38:18 <EvilTerran> syntaxglitch, i suspect if i pushed it far enough i'd probably end up with the calculus of constructions
22:38:27 <Twey> Jafet: You can have a typechecker run on compilation that checks what properties will be available on a specific object at a specific time and raise type errors accordingly
22:38:30 <Axman6> Berengal: it's -Xmx500m btw
22:38:31 <ray> berengal: let's not go that far
22:38:43 <Berengal> Axman6: As I said CrAzY
22:38:50 <Axman6> yah :\
22:38:54 <EvilTerran> Twey, i recall being able to do that in Scala. it made my skin crawl.
22:39:33 <Twey> Heh
22:39:44 <ray> syntaxglitch: although, it ends up being more typing than haskell..
22:39:45 <Berengal> I actually do all my programming in grey text on dark-grey backgrounds...
22:39:48 <EvilTerran> i guess i'd feel happier about it in a system that wasn't pretending to have a "normal" type system
22:39:49 <ray> typing as in keyboard
22:39:49 <syntaxglitch> Jafet: Basically the system I was toying with demanded semantic equivalence for any two things that shared a name, and used implicit interfaces representing the set of functions you could apply to a value
22:39:55 <Twey> I believe it's possible to write such a type-checker in Lua, actually.  I've been meaning to make one.
22:40:08 <Axman6> whoot! just finished implementing 16K of RAM in this book's HDL language!
22:40:14 <chrisdone> Twey: why?
22:40:23 <syntaxglitch> Jafet, and type resolution would basically propagate constraints using intersections and unions on all the implicit, find-grained "interfaces" required
22:40:29 <Twey> For fun and for security ☺
22:40:33 * EvilTerran does like how tricky you can be with lua
22:40:34 <Axman6> starting with only data flip-flops
22:40:41 <ray> that's something like go
22:41:08 <Jafet> Axman6, copypasta?
22:41:08 <ray> except the interfaces are explicit, just adding objects to them is automatic, or something
22:41:40 <syntaxglitch> ray: Yeah, my (incomplete, sketched-out only) system tried to infer everything
22:42:08 <Berengal> Explicit interfaces aren't neccessarily a bad thing. It helps you think about the meaning of the operations independent of any implementation
22:42:37 <syntaxglitch> I think what got me started was wondering about the maximal subset of a language like Ruby or Python that would allow full static type checks
22:43:29 <Axman6> Jafet: i'd have to paste about 8 files if you want to see all the code. basically, i started by defining a Bit using a DFF and a Mux gate, then built 16 bit Registers from those, then 8 word RAM8's from those, then it's basically copy and paste to build up a 64 word RAM64, 512, 4k and finally 16k
22:44:29 <Axman6> i must say, i *highly* recommend this book to anyone interested in CS: http://www1.idc.ac.il/tecs/
22:44:32 <syntaxglitch> But I got a little carried away with some of the weird type system ideas I had and the thing got kinda ridiculous :( Maybe someday I'll learn Parsec and try and implement it...
22:45:04 <syntaxglitch> Axman6, that DOES sound fun
22:45:16 <Axman6> the course is commonly referred to as 'from Nand to Tetris in 12 steps', because you build a whole (logical) computer from scratch, starting with nothing more than Nand gates
22:45:29 <Axman6> b6 chapter 3, you've made the whole ALU
22:45:32 <Axman6> by*
22:46:07 <syntaxglitch> Axman6, how... uh, "realistic" is it? I mean, it's conceptually pretty simple to build up from logic gates
22:46:15 <Axman6> no, chapter 2 is where you make the ALU, chapter 3 is where you make the RAM. this book moves damn fast :)
22:46:24 <syntaxglitch> For that matter, building up from idealized transistors is easy enough
22:46:30 <Axman6> syntaxglitch: seems pretty realistic to me
22:46:52 <syntaxglitch> It's doing it with non-idealized transistors and restricted to doing it ways that would work if put on an actual chip that could get tricky
22:47:14 <Jafet> Details.
22:47:49 <Jafet> Well, the fun part is when you dump the clock and make it all data=driven
22:47:54 <Axman6> well, it seems to cover a hell of a lot of CS type material: logic, the memory system, machine code, assembly, OS, parsing, and writing software
22:48:17 <shambler> Axman6, nice, thanks for the link
22:48:30 <syntaxglitch> Axman6, I'm more talking about things like signal propagation times, actual voltage effects, and such
22:48:34 <Berengal> Ooo, I saw a video about that once. Seemed pretty interesting
22:48:36 <Axman6> the book is very well written, and quite concise
22:48:54 <Axman6> syntaxglitch: that's not computer science though. that's hardware engineering
22:49:01 <syntaxglitch> If it's idealized to the point where nothing interesting happens between clock pulses and voltages are simple tri-state, that's a bit easier
22:49:16 <Jafet> Many institutes have one single department for electronic engineering and computer science
22:49:32 <syntaxglitch> Axman6, yeah, but where do you think real computers come from? :)
22:49:40 <Axman6> doesn't matter :)
22:49:42 <Jafet> Oh, and don't forget metastability
22:49:58 <syntaxglitch> And in real life, if you're working at the logic gate level you would have to worry about that stuff
22:50:05 <Axman6> you design the hardware, and then implement it
22:50:22 <Axman6> sure... but you're missing the point of the book
22:50:46 <Jafet> Implement the nand gate in Conway's life. Then you can worry about signal propagation times
22:50:54 <syntaxglitch> Axman6, sorry, I was trying to ASK about the point of the book
22:51:11 <Jafet> And if you introduce randomization, you can even worry about thermal fluctuation
22:51:12 <syntaxglitch> Jafet: You've seen the Turing Machine in Life, right?
22:51:13 <Axman6> it's designed to bring most of what's taught separately over a uni CS degree into one or two semesters
22:51:34 <Jafet> I've been more impressed by the von Neumann constructor
22:51:52 <Jafet> (Made out of still lifes)
22:51:52 <xerox> what is the von neumann constructor?
22:52:04 <syntaxglitch> Axman6, what I meant was by "realistic" earlier was something like "are we talking NAND gates in the abstract logical sense or in the bits-of-real-world-silicon sense"
22:52:07 <Axman6> xerox: his parents
22:52:08 <Axman6> >_>
22:52:42 <Axman6> syntaxglitch: yes, in the abstract sense. below that isn't really CS, it's electrical engineering and physics
22:52:53 <syntaxglitch> Axman6, okay, thanks
22:53:12 <Jafet> CS covers everything under the sun within three feet of computers, anyway
22:54:01 <Axman6> basically, the book takes two things as primitive: Nand gates and DFF's. they said they could have just used nand gates, and implemented DFF's using them, but it's not really all that important to what you'd need to know in CS
22:54:06 <syntaxglitch> Everything from single transistors up to C compilers is potentially somewhat of an overlap between CS and EE anyway :P
22:54:42 * Jafet wonders about the probability of total computer system failure from quantum noise
22:54:50 <shambler> :-)
22:54:58 <syntaxglitch> Jafet, might be an issue soon
22:55:11 <shambler> don't forget about cosmic rays
22:55:30 <syntaxglitch> Chips are getting small enough these days that I think electrons are starting to have a nontrivial chance of jumping into other transistors for no particular reason
22:55:36 <Jafet> Surely that's but a TEMPEST in a teapot
22:55:55 <xerox> Jafet: that construction is indeed impressive
22:56:04 <xerox> Never heard of it before, thanks.
22:56:08 <Axman6> are we at the point where single electrons can affect that much yet?
22:56:23 <BONUS> yeah we are imo
22:56:25 <Jafet> A single flipped bit can panic a kernel
22:56:25 <syntaxglitch> That's one of the reasons why the crisis-du-jour is the "end of Moore's Law" for clock speeds and the future being massive parallelism
22:56:30 <Jafet> Software is wonderful like that.
22:57:00 <Axman6> BONUS: well, it's not really an oppinion thing :P
22:57:26 <syntaxglitch> Axman6, I assume it's not that bad yet, CPUs still seem to work as expected
22:57:27 <Jafet> Memory modules now have EEC though, I think
22:57:48 <Axman6> Jafet: only expensive memory
22:58:01 <Jafet> Heh
22:58:17 <syntaxglitch> But my impression is that indeterminate electron location is actually one of the major upcoming barriers to making chips much denser
22:58:30 <Axman6> like that found in the Mac Pros, Xserves and nVidia Fermi architecture
22:58:37 <BONUS> i overuse "imo" haha, but iirc we are, i don't know where i read it though
22:58:49 <Jafet> The diffraction limit is another
22:59:11 <Jafet> And substrate purity
22:59:23 <syntaxglitch> I think the other major problem is something with needing higher-frequency light for the masking, due to the resolution limitations caused by indeterminate photon location
22:59:41 <syntaxglitch> But I don't really recall, it's all way beyond me
22:59:42 <syntaxglitch> :(
22:59:54 <Jafet> It's okay, none of that is computer science!
23:00:18 <syntaxglitch> Yeah, who needs cross-discipline expertise
23:00:22 <syntaxglitch> Specialization ahoy
23:00:24 <Badger> damn those electrons, why can't they just stay still? :(
23:00:36 * Jafet drowns Badger in the Dirac sea.
23:00:41 <syntaxglitch> Badger, the third law of thermodynamics
23:00:44 <syntaxglitch> Is why
23:00:52 * Axman6 is doing an engineering/IT degree, and finds the barrier between the two fairly obvious
23:00:57 <syntaxglitch> Besides, if they did hold still, you'd literally have no idea whatsoever where they were
23:01:27 <Jafet> syntaxglitch, that's how I often feel about my program data
23:01:28 <Axman6> of course they overlap a lot more these days, but i'd say that strictly, EE is below the logic gates, and Cs is above
23:01:54 <Twey> Haha
23:02:22 <Jonno_FTW> ok, my program before gets the solution in 1.1 seconds
23:02:23 <syntaxglitch> Axman6, yeah, it's some of the stuff in between that kinda mixes it up
23:02:40 <Jonno_FTW> how long should it take for it to get the actual answer for up 120000?
23:02:50 <desp> I have a problem with the functions in System.Exit.  They appear to be exiting only from the active thread, and not from the main thread.
23:02:55 <Axman6> Jonno_FTW: what are you talking about?
23:03:07 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14096#a14096
23:03:09 <syntaxglitch> Like I've seen stuff in hardware driver code along the lines of "sleep for a moment here to let the bits settle in the register"
23:03:11 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14088#a14093
23:03:13 <desp> Any ideas?
23:03:37 <Twey> desp: Yes, they do that
23:03:40 <Beelsebob> Axman6: I'm about now
23:03:43 <Twey> desp: throwTo an exception to the main thread
23:03:47 <Axman6> Beelsebob: o/
23:04:00 <syntaxglitch> As an aside, related to EE-that-is-not-CS, anyone played this game? http://www.zachtronicsindustries.com/pivot/entry.php?id=79
23:04:06 <desp> Twey: but in order to do that, I need to carry the main thread id with me, yes?
23:04:07 <Jafet> Is that the abc conjecture?
23:04:08 <Axman6> Beelsebob: what ever happened to that super secret stuff you were working on?
23:04:21 <Beelsebob> Axman6: which super sekrit stuff?
23:04:29 <Beelsebob> iPhone related super sekrit stuff?
23:04:34 <Axman6> nah
23:04:40 <Axman6> FP for kiddies i think
23:04:44 <Twey> desp: Well, there's always an IORef
23:04:47 <desp> Twey: since there's no getMainThreadId function that I can see
23:05:08 <syntaxglitch> Axman6, isn't that Logo?
23:05:21 <Beelsebob> Axman6: oh, company went bankrupt
23:05:24 <Axman6> :(
23:05:26 <Beelsebob> and it wasn't FP for kiddies
23:05:29 <Beelsebob> it was FP for artists
23:05:30 <desp> Twey: which seems to be an odd omission...
23:05:31 <Axman6> Beelsebob: free to talk about it now?
23:05:37 <Beelsebob> I guess so
23:05:42 <Axman6> Beelsebob: same thing :P
23:05:46 <Beelsebob> lol
23:06:07 <Twey> desp: The impression that I get is that System.Exit is meant to exit the whole program, but they didn't really think the design through in terms of threads when writing it
23:06:21 <Axman6> Jonno_FTW: hits = [c | b <- [1 ..], a <- [1 .. b - 1], c <- [a + b], abcHit (a, b, c)] == hits = [c | b <- [1 ..], a <- [1 .. b - 1], abcHit (a, b, a+b)]
23:06:21 <Twey> But you should ask SPJ or someone
23:06:48 * desp goes to the other channel.
23:07:03 <Axman6> Beelsebob: i was just asking because HaskellLove thought that that sort of thing was the most amazing idea ever, and i remembered your work
23:07:04 <Twey> There's a bug report out on the docs
23:07:33 <Jonno_FTW> oh i fixed it up a bit since that version
23:07:38 <Beelsebob> Axman6: I think it has a lot of potential as being the most-amazing thing ever, particularly with some of the nice things we were doing
23:07:44 <Beelsebob> it had the ability to lay out let-expressions a lot more nicely when you did it in two dimensions
23:07:51 <Jonno_FTW> it seems to take a lot of time for anything > 1000
23:08:06 <Beelsebob> and with the syntax that conal (mostly) came up with you could have any different amount of 2D syntax and 1D syntax like we have now
23:08:21 <Beelsebob> (and in fact, dynamically change the amount of each you had)
23:08:22 <Axman6> Beelsebob: don't suppose you have any of the stuff anymore? sounds like it'd be an awesome project
23:08:40 <Beelsebob> Axman6: not really, no
23:08:46 <Axman6> shame
23:08:53 <Axman6> could it produce haskell code?
23:09:43 <Beelsebob> absolutely
23:09:48 <Beelsebob> though we were skipping that step
23:09:56 <Beelsebob> I was directly producing GHC core and firing it at ghc-api
23:10:12 <Beelsebob> our language was actually *much* closer to GHC core than to Haskell
23:10:37 <HaskellLove> Beelsebob you tell them man... tell them how it is done :D
23:10:37 <Axman6> Jonno_FTW: also, you're checking for a+b==c, but if you use the code i had, it's guaranteed
23:10:47 <Jonno_FTW> oh right
23:10:59 <Jonno_FTW> i'll update it with what i have now
23:11:04 <Axman6> Beelsebob: that was exactly what i was thinking would be the best way to do it :)
23:12:12 <HaskellLove> Beelsebob u r the future man go go go
23:12:14 <Jonno_FTW> check it now
23:13:07 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14088#a14097
23:13:10 * Beelsebob wonders who HaskellLove is
23:13:23 <HaskellLove> Beelsebob, he is a ninja
23:13:29 <Jonno_FTW> i made some observations about the numbers produced
23:13:40 <Axman6> good
23:13:57 <Axman6> where'd you ger the 'as' function optimisation from?
23:14:30 <Jonno_FTW> i saw that if b is even then a is usually pretty small
23:14:38 <Jonno_FTW> otherwise brute force it
23:15:09 <Jonno_FTW> [(1,8),(5,27),(1,48),(32,49),(1,63),(1,80),(4,121),(3,125),(81,175),(1,224),(1,2
23:15:11 <Jonno_FTW> 42),(2,243),(7,243),(13,243),(100,243),(1,288),(32,343),(169,343),(5,507),(1,512
23:15:17 <Axman6> hmm, i'd do the 'gcd a b ,gcd a c , gcd b c' check in the producer
23:15:42 <Jonno_FTW> why?
23:15:57 <Axman6> oh, hmm dw
23:16:40 <Axman6> yeah the whole thing cam turn into one (large) list comprehension
23:16:48 <Jonno_FTW> see, it would be quite easy if there is only one solution of a for each b
23:16:53 <Jonno_FTW> but there isn't
23:17:02 <Jonno_FTW> and i think that is where the optimisation is
23:19:37 <Jonno_FTW> any ideas?
23:20:00 <Axman6> Jonno_FTW: also, don't use tabs, ever
23:20:16 <Jonno_FTW> EVER?
23:20:19 <Axman6> how's http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14088#a14098
23:20:20 <Axman6> ever
23:20:49 <Jonno_FTW> why so?
23:21:17 <Jonno_FTW> what do i use to indent for readablility then?
23:21:42 <Axman6> spaces
23:22:02 <Axman6> any decent editor will be able to use a specified number of spaces for tabs
23:22:17 <Jonno_FTW> i use notepad++
23:22:37 <Axman6> i'm pretty damn sure it's got the option
23:22:42 <aavogt> @karma notepad
23:22:43 <lambdabot> notepad has a karma of 40
23:23:01 <Axman6> @karma notepad++
23:23:02 <lambdabot> notepad++ has a karma of 0
23:23:03 <Stinger> haha
23:23:05 <Jonno_FTW> :O
23:23:11 <eivuokko> Jonno, you can make it expand tabs to spaces.
23:23:20 <Jonno_FTW> it is a totally awesome editor
23:23:27 <Jonno_FTW> i use the hello kitty theme
23:23:31 <eivuokko> It is ok, not awesome -.-'
23:23:58 <cizra> Gvim runs on Windwoes. Thy hast no excuse.
23:23:59 <Twey> Hahaha
23:24:08 <cizra> Thou, I meant.
23:24:11 <Jonno_FTW> i tried once
23:24:22 <Twey> More importantly, so doth emacs ;)
23:24:33 <Jonno_FTW> i don't want to learn emacs
23:25:19 * Axman6 didn't really like notepad++. didn't seem to do much more than syntax highlighting
23:25:40 <Jafet> M-x gtfo
23:25:59 <Jonno_FTW> what does gvim offer over np++?
23:26:08 <Zao> Jonno_FTW: Apart from awesomeness?
23:26:29 <Jonno_FTW> yes apart from that
23:26:31 <Jafet> It's vim.
23:26:38 <Jonno_FTW> i know that
23:26:45 <Jafet> So what else do you want to know?
23:26:58 <Jonno_FTW> is it CLI?
23:27:08 <Jafet> Why does that matter?
23:27:17 <Jafet> Oh right, Windows doesn't have a proper terminal or shell.
23:27:24 <Jonno_FTW> correct
23:27:30 <Jafet> So get one, silly.
23:27:47 <Stinger> learn emacs, it is worth your time
23:27:53 <Axman6> Jonno_FTW: Gvim is the gui version
23:27:54 <ziman> gvim is not console on windows
23:27:57 <Axman6> Stinger: pfft
23:27:59 <Philonous> Jonno_FTW: Both vim and emacs have a CLI and a GUI mode
23:28:00 <Stinger> or *spit* gvim
23:28:04 <Axman6> and pfft to the vim lovers too
23:28:06 <Jonno_FTW> ok
23:28:13 <Axman6> i hate both (almost) equally
23:28:28 <Stinger> what do you use, if you say Yi I will hurt you
23:28:29 <eivuokko> Just set your editor to expand tabs, and ignore the editor fanatics.
23:28:45 <Axman6> i don't feel that an editor should realy have a learning curve before you can start using it
23:29:15 <Philonous> Axman6: emacs + CUA mode is rather intuitive. ;)
23:29:16 <Jafet> They all have learning curves. Some are steeper.
23:29:33 <Jafet> The steeper ones let you go higher.
23:29:34 <inclement> Axman: Isn't there a point at which you have to sacrifice some 'needs learning' in order to get some 'extremely poweful'?
23:29:35 <Axman6> (this is why i like TextMate. anyone can use it, and if you feel you want to use more of the features, you can learn them. there's nothing stopping you from getting in there and just using it as a text editor)
23:29:57 <pastah_rhymez> Axman6: vim bindings?
23:30:05 <Axman6> ?
23:30:18 <pastah_rhymez> well, you said like a REAL editor
23:30:28 <pastah_rhymez> do you have ED bindings?
23:30:30 <Jonno_FTW> is it all just a matter of remembering keyboard shortcuts?
23:30:39 <pastah_rhymez> yes
23:30:48 <Axman6> pastah_rhymez: i don't feel that bindings to how other editors is much of a feature
23:31:04 <Philonous> Jonno_FTW: No. Most editors allow you to set the keyboard shortcuts to whatever you prefer anyway.
23:31:16 <Axman6> Jonno_FTW: i personally found vim shortcuts easier to remember than emacs (and _far_ less painful on the hand)
23:31:26 <pastah_rhymez> hmm... i wonder if there's an emacs mode for vim
23:31:46 <Stinger> wouldnt it break the command mode thing
23:31:56 <Jafet> From the vim command line, start a subshell and run emacs.
23:32:00 <Stinger> haha
23:32:05 <Jafet> ...
23:32:21 <pastah_rhymez> http://www.algorithm.com.au/code/vimacs/
23:32:58 <Axman6> right, i should read more of this book, and go to sleep. night all
23:33:12 <eivuokko> Happy adventures.
23:33:14 <pastah_rhymez> Axman6: what book?
23:33:36 <benmachine> some of the things that you can do with vim aren't really possible in an easy-to-use editor
23:33:49 <Jafet> vim is an easy-to-use editor!
23:33:58 <pastah_rhymez> Jafet: WERD
23:33:58 <benmachine> like, having a key combination to join lines
23:33:58 <Jafet> Unless you use colemak.
23:34:10 <benmachine> useful but obscure
23:34:20 <Twey> benmachine: Sure they are.  They're in emacs.  :þ
23:34:25 <Philonous> Jafet: Easy to use is not the same es easy to learn, right?
23:34:26 <benmachine> you can't have quite as much useful unless you also accept obscure
23:34:29 <pastah_rhymez> Jafet: how would that make things easier?
23:34:33 <aavogt> Jafet: there's not that much you need to remap
23:34:36 <Jafet> Philonous, of course not!
23:34:37 <Axman6> http://www1.idc.ac.il/tecs/ fantastic book. watch this to find out what it's about, and why it's so awesome: http://www.youtube.com/watch?v=JtXvUoPx4Qs
23:34:41 <Tupac> :t pastah_rhymez
23:34:42 <lambdabot> Not in scope: `pastah_rhymez'
23:34:42 <Jafet> True, bad example.
23:34:44 <benmachine> Philonous: yeah, -learn makes more sense
23:34:44 <Axman6> @ pastah_rhymez
23:34:45 <Jafet> Dvorak then.
23:34:45 <pastah_rhymez> haha
23:34:49 <Twey> Axman6: Yes, that's also why I recommend emacs to newbies nowadays
23:35:01 <Tupac> :t Twey
23:35:02 <lambdabot> Not in scope: data constructor `Twey'
23:35:02 <pastah_rhymez> pastah_rhymez :: 1337
23:35:03 <Axman6> Twey: why's that?
23:35:28 <Twey> The learning curve is incremental: you don't have to learn everything at once.  It's possible to just use it like Notepad or something with the arrow keys, until the user wishes to learn to use it more efficiently.
23:35:43 <benmachine> you don't have to learn vim all at once
23:35:44 <benmachine> I didn't
23:35:56 <benmachine> you do need to learn more than you need to with most other things
23:35:56 <Axman6> Twey: i don't think you should need a tutorial to start using an editor. emacs fails this test :\
23:36:03 <benmachine> but not all that much
23:36:11 <Axman6> so does vim
23:36:12 <Twey> Axman6: You don't need a tutorial to start using emacs
23:36:17 <Axman6> i did
23:36:18 <Twey> At least in the GUI
23:36:27 <Jafet> http://www.bash.org/?795779
23:36:32 <benmachine> more tutorial = more learning = more better
23:36:32 <pastah_rhymez> in the gui you can click stuff
23:36:35 <HaskellLove> where is this "as" operator on the keyboard? is it @ ???
23:36:35 <Stinger> having a steep learning curve is probably something that makes a good editor :P
23:36:36 <Elench> GUI emacs hurts my eyes and brain though
23:36:37 <Axman6> the gui (even the macified one) is rather confusing indeed
23:36:38 <nagnatron> i love vim's keybindings
23:36:39 <Badger> benmachine: lies
23:36:47 <pastah_rhymez> in vim you only need to know 'i' and 'escape' to get started
23:36:48 <benmachine> Badger: truths
23:36:50 <Twey> All the familiar Notepad operations work.  Navigation with the arrow keys, clicking about with the mouse, closing the window to exit, &c.
23:36:52 <pastah_rhymez> (gvim)
23:36:53 <MarcWeber> nagnatron: Do you know about vim scion ?
23:37:15 <MarcWeber> pastah_rhymez: And :vi in case you entered ex mode :)
23:37:15 <pastah_rhymez> Twey: whan does <C-c> do in emacs?
23:37:16 <darkmotter> hey all, trying to install ghc. i run into the following error on ./conf http://pastebin.com/m13ef1559ig
23:37:19 <nagnatron> MarcWeber: No, what's that?
23:37:23 <Axman6> Stinger: textmate doesn't have a steep learning curve, and it's a great editor. very powerful, and very easy to use
23:37:29 <MarcWeber> nagnatron: It's on the fly checking for vim
23:37:43 <MarcWeber> newtype CheckedException l = CheckedException {checkedException::SomeException} deriving (Typeable)
23:37:47 <pastah_rhymez> Axman6: seen this before; i wish we had this book in our courses we did
23:37:52 <Jafet> Twey, typing to replace a highlighted selection!
23:37:56 <MarcWeber> github.com/nominolo/scion @ nagnatron
23:38:12 <MarcWeber> Axman6: Does textmate support tags?
23:38:15 <Badger> benmachine: does it really save you that much more time than a regular editor?
23:38:22 <benmachine> Badger: you'd be surprised
23:38:22 <Axman6> MarcWeber: what are tags?
23:38:28 <Stinger> I should probably look at textmate one day, but I suspect it's probably not as powerful or extensible as emacs or vim
23:38:31 <Tupac> [ (i, j, k) | i <- [1..3], j <- [1..3], k <- [1..3], i /= j, j /= k, i /= k ]
23:38:34 <Jafet> Hmm, this is spiraling into a subdued editor war
23:38:40 * Jafet goes for food
23:38:50 <pastah_rhymez> isn't there a windows clone of textmate?
23:38:50 <MarcWeber> Axman6: So shut up :-) *kidding* tags let me jump to either a module or a function within a fraction of a second
23:38:56 <pastah_rhymez> 'e', was it?
23:39:01 <benmachine> vim has keys for things that I didn't even realise I wanted to do until I found out there was a key for it
23:39:07 <Axman6> MarcWeber: i asked because i don't know, and they may have a different name
23:39:09 <Twey> pastah_rhymez: Copies, in CUA
23:39:09 <benmachine> like, go to the next instance of this character
23:39:17 <benmachine> go to the character before the next instance of this character
23:39:18 <pastah_rhymez> Twey: in what?
23:39:21 <pastah_rhymez> Twey: gief linky
23:39:23 <nagnatron> MarcWeber: thanks, looks very interesting.
23:39:25 <MarcWeber> Axman6: It's kind of index of your .hs files. I'm googling for it right now
23:39:31 <Jafet> Well, vim has had about 20 years of programmers thinking about the things they want to bind keys to.
23:39:34 <Axman6> MarcWeber: possibly, i've never really looked into it
23:39:34 <Tupac> @
23:39:35 <Badger> benmachine: er... do you actually want to do those things? :P
23:39:36 <benmachine> delete everything up to the matching parenthesis
23:39:37 <Jonno_FTW> is emacs and vim from the days when we didn't have window-tabs?
23:39:38 <Jafet> Similar for emacs.
23:39:48 <Tupac> lambdabot
23:39:57 <Axman6> Tupac: are you right there?
23:40:03 <Twey> pastah_rhymez: Options -> C-x/C-c/C-v Cut and Paste (CUA)
23:40:03 <Jafet> Jonno, you had screen and you learned to love it.
23:40:16 <benmachine> Badger: well, it's nice to be able to navigate quickly, but also it means that you can usually delete exactly the right amount of text in about 4 keystrokes
23:40:17 <HaskellLove> do you guys use the @ operator for arguments naming or you dont find it much useful?
23:40:20 <Tupac> Axman: ??
23:40:29 <Jafet> We use it when we find it useful.
23:40:32 <benmachine> and then paste it in exactly the right place with about four more
23:40:37 <Twey> Jonno_FTW: No, they're from the days when people wanted to be able to easily move text between buffers ;)
23:40:41 <Axman6> Tupac: what are you doing
23:40:42 <Badger> hmm
23:40:52 <Tupac> i want lambdabot to go
23:40:53 <Jonno_FTW> older than nano?
23:40:58 <Axman6> > 1+1
23:40:59 <lambdabot>   2
23:41:13 <eivuokko> Jonno, much.
23:41:13 <Axman6> or, better yet, /msg lambdabot > 1+1
23:41:21 <Tupac> thanks
23:41:36 <Jonno_FTW> > exp (pi * (sqrt (0-1)))
23:41:37 <lambdabot>   NaN
23:41:40 <benmachine> you can install a local lambdabot from hackage, too
23:41:42 <Jonno_FTW> :/
23:41:52 <benmachine> :t exp
23:41:56 <lambdabot> forall a. (Floating a) => a -> a
23:42:10 <Axman6> > > exp (pi * (sqrt (0-1))) :: Complex Double
23:42:11 <lambdabot>   <no location info>: parse error on input `>'
23:42:12 <Badger> benmachine: did that actually work for you
23:42:14 <Axman6> > exp (pi * (sqrt (0-1))) :: Complex Double
23:42:15 <Badger> like, first time :P
23:42:17 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
23:42:21 <benmachine> Badger: uhm, no comment
23:42:24 <Axman6> > exp (pi * (sqrt (0-1))) :: Complex CReal
23:42:24 <Badger> heh
23:42:26 <lambdabot>   (-1.0) :+ 0.0
23:42:28 <Jonno_FTW> floating point error much?
23:42:40 <Axman6> Jonno_FTW: floating point error very little
23:42:48 <benmachine> heh
23:42:56 <Stinger> not an error, just an approximation
23:42:59 <Jonno_FTW> i guess
23:43:02 <burp> 1.22*10^-16 is double machine precision
23:43:05 <Axman6> > 10**-16 -- not very big
23:43:06 <lambdabot>   Not in scope: `**-'
23:43:11 <Axman6> > 10**(-16) -- not very big
23:43:12 <lambdabot>   1.0e-16
23:43:18 <Stinger> haha
23:43:18 <Tupac> > [ (i,j,k) | i <- [1..3], j <- [1..3], k <- [1..3], i /= j, j /= k, i /= k ]
23:43:20 <lambdabot>   [(1,2,3),(1,3,2),(2,1,3),(2,3,1),(3,1,2),(3,2,1)]
23:43:23 <Axman6> > 10**(-16) :: CReal -- not very big
23:43:24 <lambdabot>   0.0000000000000001
23:43:40 <Axman6> anyway! book and sleep! night all
23:43:53 <benmachine> p.s. this made me much better at vim http://www.viemu.com/a-why-vi-vim.html
23:43:55 <Jonno_FTW> hmmm
23:44:03 <pastah_rhymez> Axman6: good night :)
23:44:09 <Jonno_FTW> farewell
23:44:35 <nagnatron> There is also a Vim "cheat sheet" which I printed and have under my laptop to pull out when i need a reminder
23:44:51 <benmachine> yeah
23:45:08 <HaskellLove> Jafet> like most of the time or rarely?
23:46:13 <MarcWeber> Axman6 nagnatron If you're interested I'll prepare a short demontstration. Do you (or anyone else) joind and watch maybe 5min?
23:46:34 <Tupac> ( [i, j, k] | i <- [1..3], j <- [1..3], k <- [1..3], i /= j, j /=k, i /= k )
23:47:10 <Jonno_FTW> what's going on?
23:48:19 <nagnatron> sure
23:48:29 <MarcWeber> nagnatron: Wait some minutes. I'll tell you again
23:48:34 <Tupac> > ([i, j, k] | i <- [1..3], j <- [1..3], k <- [1..3], i /= j, j /= k, i /= k )
23:48:34 <lambdabot>   <no location info>: parse error on input `|'
23:48:35 <Jonno_FTW> the emacs vs. vim battle rages on
23:48:48 <Twey> emacs won long ago
23:48:54 <Twey> The heathens just refuse to admit it ;)
23:50:11 <opqdonut> indeed
23:50:46 <opqdonut> personally i quite like the command set of vi, but emacs is just so much better as a platform
23:50:48 <Badger> Twey: with or without viper? :P
23:51:18 <Twey> Without.  Who wants to turn a perfectly good editor into a clunky vi clone?  Ych.
23:51:18 <Jonno_FTW> here's my fantastic editor
23:51:20 <Jonno_FTW> http://i50.tinypic.com/2dshbpd.jpg
23:51:24 <Tupac> > permutations [1..20]
23:51:25 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[2,1,3,4,5,6,7,8,9,10...
23:51:27 <nagnatron> emacs is painful
23:51:29 <desp> What is the deal with hackage trac?
23:51:35 <Twey> Jonno_FTW: Haha
23:51:42 <Jonno_FTW> it's just so easy to read
23:51:50 <Jonno_FTW> SO EASY
23:51:51 <dmead> noooote paaaaaadddd
23:51:53 <Twey> I use Notepad++ at college — it's the only decent editor installed
23:51:56 <Jonno_FTW> plus plus
23:52:02 <Twey> It's okay, but I miss a lot of the features from emacs
23:52:08 <Jonno_FTW> like?
23:52:38 <Twey> The kill ring, incremental search, emacs' superb language support, auctex
23:52:39 <desp> Jonno_FTW: pink?
23:52:58 <Jonno_FTW> yez
23:53:01 <eugenn> @bt empiezaCon caracter palabra = (head palabra) == caracter
23:53:01 <lambdabot> Maybe you meant: bf ft
23:53:13 <Jonno_FTW> it's the best of the available themes
23:53:13 <eugenn> @ft empiezaCon caracter palabra = (head palabra) == caracter
23:53:14 <lambdabot> Done.
23:53:19 <desp> Jonno_FTW: that's saying a lot.
23:53:19 <Tupac> @hoogle permutations
23:53:19 <lambdabot> Data.List permutations :: [a] -> [[a]]
23:53:29 <Jonno_FTW> it is super fantastic
23:54:00 <nagnatron> Jonno_FTW: you theme is FAB
23:54:08 <Berengal> Shades of gray for me, thanks...
23:54:29 <desp> http://varsztat.com/~desp/praxis/sample-veritas-12.png -- here's my theme and my font.
23:54:32 <eugenn> @pl empiezaCon caracter palabra = (head palabra) == caracter
23:54:32 <lambdabot> empiezaCon = (. head) . (==)
23:54:53 <Jonno_FTW> your theme could use more pink
23:55:02 <Twey> empiezaCon = fmap head . (==)
23:55:54 <Jonno_FTW> also, is that a crazy monospace variant font there?
23:56:00 <aavogt> @type fmap head  . (==)
23:56:01 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Bool'
23:56:01 <lambdabot>       Expected type: a1 -> a1 -> [a]
23:56:01 <lambdabot>       Inferred type: a1 -> a1 -> Bool
23:56:07 <aavogt> @type flip head  . (==)
23:56:08 <lambdabot> forall b a. (Eq a) => a -> [(a -> Bool) -> b] -> b
23:56:10 <desp> Jonno_FTW: look in praxis/ for the font
23:56:14 <aavogt> @type flip fmap head  . (==)
23:56:15 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:56:23 <desp> Jonno_FTW: why crazy, tho? ;)
23:56:32 <Jafet> HaskellLove, that's a stupid question
23:56:41 <Jafet> I use it when I want to use it.
23:56:45 <Jonno_FTW> i haven't seen it before
23:56:58 <desp> Jonno_FTW: probably because I made it.
23:57:33 <Jonno_FTW> oh, well good work there
23:57:36 <HaskellLove> Jafet it is great question man... How often do you use the @ operator for arguments naming and do you rather not use it when u can? simple...
23:57:42 <Twey> :t flip fmap head . (==)
23:57:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:57:54 <Twey> Eh, maybe you should stick with (. head) after all, then :þ
23:58:33 <Tupac> Haskell Love did you learn anything yesterday
23:58:45 <Jafet> HaskellLove, stop trolling
23:58:57 <Jafet> It's not working
23:59:05 <Jafet> ...actually, maybe it is, so I'll stop
23:59:56 <Tupac> > unfoldr (\x -> if null x then Nothing else Just $ splitAt 20 x) [1..]
23:59:56 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[21,22,23,24,25,26,27...
