00:00:08 * copumpkin thinks "Where do monads come from?" would be prettier as "Whence the monads?"
00:01:52 <roconnor> copumpkin: I promise to strangle anyone who extends from Maybe to Either in spoon
00:01:52 <cnwdup> @pl (\a -> a `f` a)
00:01:53 <lambdabot> join f
00:01:58 <copumpkin> roconnor: yay
00:02:06 <idnar> spoon?
00:02:14 <copumpkin> I was afraid I'd feel inadequate if someone else "fixed" it
00:02:28 <copumpkin> but knowing that nobody else will be allowed to makes me feel better
00:02:30 <copumpkin> @hakage spoon
00:02:30 <Jafet> When two consenting adults... wait, that's not it
00:02:31 <lambdabot> http://hackage.haskell.org/package/spoon
00:03:23 <dolio> Why was spoon the obvious choice by the way? You never answered that guy.
00:03:26 <cnwdup> @pl (\a -> a ^ a)
00:03:27 <lambdabot> join (^)
00:03:36 <dolio> Was he right about it being a Tick reference?
00:03:43 <quicksilver> dolio: if someone throws an egg at you, how do you catch it?
00:03:47 <quicksilver> in a spoon, obviously.
00:03:48 <cnwdup> Why do I get a no instance for Monad ((->) a) when using join (^)?
00:03:58 <copumpkin> cnwdup: import control.monad.instances
00:03:58 <quicksilver> cnwdup: because you haven't imported the instance.
00:04:06 <cnwdup> Thanks.
00:04:10 <copumpkin> dolio: not actually sure :) my response was supposed to be humorous
00:04:29 <cnwdup> @pl (reverse . take 10 . reverse)
00:04:29 <lambdabot> reverse . take 10 . reverse
00:04:30 <copumpkin> it was random and catchy
00:04:46 <copumpkin> cnwdup: :O
00:05:03 <cnwdup> Well... I hoped it would come up with a different way to write it. :) The reverse … reverse is ugly.
00:05:06 <Raynes> copumpkin: You should have called it 'seed'.
00:05:21 <copumpkin> @let times = (runEndo . Data.Foldable.foldMap Endo .) . replicate
00:05:22 <lambdabot>  <local>:6:8:
00:05:23 <lambdabot>      The operator `.' [infixr 9] of a section
00:05:23 <lambdabot>          must hav...
00:05:31 <cnwdup> However, drop (length xs - 10) is, too.
00:05:34 <copumpkin> @let times = ((runEndo . Data.Foldable.foldMap Endo) .) . replicate
00:05:35 <lambdabot>  <local>:6:10: Not in scope: `runEndo'
00:05:39 <copumpkin> @let times = ((appEndo . Data.Foldable.foldMap Endo) .) . replicate
00:05:41 <lambdabot>  Defined.
00:05:43 <copumpkin> :t times
00:05:44 <lambdabot> forall a. Int -> (a -> a) -> a -> a
00:05:50 <roconnor> copumpkin: you are allowed to use any commutative monad.
00:06:09 <roconnor> copumpkin: but I can't think of any other than Reader and Maybe and Identity.
00:06:34 <copumpkin> @let backdrop n xs = n `times` init $ xs
00:06:36 <lambdabot>  Defined.
00:06:41 <quicksilver> copumpkin: you should have called it forbiddenspoon, for to accept its use is to descend into the path of sin.
00:06:42 <copumpkin> > backdrop 10 [1..20]
00:06:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:06:50 <copumpkin> cnwdup: :P
00:07:05 <copumpkin> roconnor: sigfpe gave an example or two in that talk
00:07:21 <cnwdup> @src times
00:07:22 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
00:07:24 <Saizan_> that's even worse than reverse . .. . reverse though
00:07:26 <cnwdup> @ty times
00:07:27 <quicksilver> roconnor: Writer is commutative if the monoid is commutative
00:07:27 <lambdabot> forall a. Int -> (a -> a) -> a -> a
00:07:43 <roconnor> quicksilver: oh
00:07:46 <copumpkin> Saizan_: ORLY?
00:07:56 <portnov> > times 3 (*2) 5
00:07:58 <lambdabot>   40
00:08:22 <HaskellLove> it is not necessary to delve into abstract mathematics to get an intuitive understanding of how to use the monadic classes.
00:08:33 <HaskellLove> how cool is that... got it from a book
00:08:40 <copumpkin> HaskellLove: definitely not necessary
00:08:48 <copumpkin> but abstract thinking is necessary to understand the concept
00:08:51 <cnwdup> copumpkin, sweet. But a little too heavy for a one-liner. :)
00:09:02 <cnwdup> @pl (\xs -> drop ( length xs - 10) xs)
00:09:03 <lambdabot> drop =<< subtract 10 . length
00:09:03 <copumpkin> cnwdup: the nice thing is that it's made up of reusable other pieces :D
00:09:31 <cnwdup> I cannot get used to the (->) Monad...
00:09:45 <byorgey> I would flip that around: "if you get an intuitive understanding of how to use monads, you have delved into abstract mathematics without knowing it; congratulations!"
00:09:47 <copumpkin> cnwdup: can you get used to the (a ->) functor?
00:10:09 <cnwdup> copumpkin, I don't think so. But I feel like it would be very helpful to do so.
00:10:34 <copumpkin> cnwdup: (a -> b) -> (f a -> f b), now let f = (c ->)
00:10:42 <HaskellLove> byorgey i like your definition
00:10:44 <byorgey> forall X. it's impossible to get used to the X monad without getting used to the X functor
00:10:59 <copumpkin> plain ol' substitution gives you (a -> b) -> ((c -> a) -> (c -> b)) === (a -> b) -> (c -> a) -> (c -> b)
00:11:03 <copumpkin> cnwdup: look like something?
00:12:16 <cnwdup> copumpkin, I agree with you. But I don't think I really understand it.
00:12:44 <cnwdup> @src (->) return
00:12:45 <lambdabot> return = const
00:12:49 <HaskellLove> anyone interested in helping me with monads in two hours after i finish book and some lectures? in pm?
00:12:56 <cnwdup> @src (->) (>>=)
00:12:56 <lambdabot> f >>= k = \ r -> k (f r) r
00:18:22 <BONUS> HaskellLove: why pm?
00:18:43 <EvanR-work> is it possible to print a function
00:18:45 <BONUS> isn't it better to have potentially 600 people helping you instead of just one
00:18:58 <BONUS> > print (+1)
00:18:59 <quicksilver> EvanR-work: short answer, no.
00:19:00 <lambdabot>   <IO ()>
00:19:05 <BONUS> long answer: nooooooooooo!
00:19:09 <BONUS> > (+1)
00:19:11 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
00:19:23 <EvanR-work> :(
00:19:26 <BONUS> lambdabot has SmallCheck which has limited function printing
00:19:30 <BONUS> but that's more of a novelty imo
00:19:38 <EvanR-work> would be cool to see the result of function composition
00:19:53 <quicksilver> EvanR-work: what answer would you expect for "(+1)", "(\x -> x+1)", "let plusone x = x + 1 in plusone"
00:20:07 <quicksilver> all these things appear to have different source but they are obviously the same function
00:20:24 <int-e> @type length . (():) . flip replicate ()
00:20:25 <lambdabot> Int -> Int
00:20:36 <quicksilver> BONUS: I suppose it's not a novelty - it's to help you understand what a counterexample is, if that counterexample is a function.
00:20:51 <EvanR-work> quicksilver: right
00:21:05 <EvanR-work> quicksilver: you can also have different reprsentations for "Hello World"
00:21:17 <quicksilver> EvanR-work: but there is a canonical representation for "Hello World"
00:21:21 <quicksilver> EvanR-work: data has a normal form.
00:21:25 <EvanR-work> yeah
00:21:29 <quicksilver> functions don't have a normal form.
00:21:31 <EvanR-work> isnt there are lambda calculus normal form
00:21:37 <EvanR-work> for some functions
00:21:43 <quicksilver> yes, there is.
00:21:48 <quicksilver> but haskell is not just lambda calculus.
00:22:02 <EvanR-work> hrm
00:22:27 <EvanR-work> i like (+1) -> (\x -> x+1) ;)
00:22:56 <roconnor> quicksilver: hmm, maybe copumpkin could return the number of exceptions thrown :D
00:23:02 <quicksilver> roconnor :)
00:23:13 <roconnor> probably not.
00:23:34 <roconnor> hmm
00:23:50 <copumpkin> :O
00:24:22 <copumpkin> cnwdup: sorry, was talking to someone
00:24:31 <copumpkin> cnwdup: did that type signature make sense?
00:24:37 <roconnor> is Either Int a a monad?
00:24:44 <roconnor> is Either Int a monad?
00:24:48 <copumpkin> it should be if it isn't
00:24:56 <roconnor> hmm
00:25:06 <roconnor> I don't think this works
00:25:10 <quicksilver> you can make Either Int a monad, yes
00:25:16 <quicksilver> (using "stop on first error semantics")
00:25:28 <quicksilver> there is also a more interesting applicative instance
00:25:33 <cnwdup> copumpkin, it does. But I cannot get used to the concept. At least not enough to use it intuitively.
00:25:35 <portnov> > return 5 :: Either String Int
00:25:35 <quicksilver> which has "add together all errors" semantics.
00:25:36 <lambdabot>   Right 5
00:25:52 <copumpkin> cnwdup: how about this. Do you know Data.Map?
00:25:53 <roconnor> quicksilver: with Left n >> Left m = Left (n + m) ?
00:25:54 <quicksilver> ...but that one will not genearlise to a monad.
00:25:55 <cnwdup> What does f >>= k with f and k being functions?
00:25:56 <cnwdup> copumpkin, I do.
00:25:58 <quicksilver> roconnor: yes.
00:26:03 <copumpkin> cnwdup: do you see its similarity with a function?
00:26:09 <roconnor> quicksilver: really?
00:26:17 <cnwdup> cnwdup, I don't. ^^
00:26:24 <copumpkin> cnwdup: a -> b takes an a and gives you a b for it. Data.Map a b does too, if you use !
00:26:29 <quicksilver> roconnor: indeed not. It is one of the examples in the applicative paper.
00:26:33 <copumpkin> in fact, functions are often called mappings
00:26:37 <jmcarthur_work> quicksilver, what about Left n *> Right x *> Left m ?
00:26:39 <cnwdup> copumpkin, sure.
00:27:06 <copumpkin> cnwdup: so say you had a functor instance for Data.Map a
00:27:08 <quicksilver> jmcarthur_work: That is Left (n+m), IIRC.
00:27:11 <EvanR-work> quicksilver: define function normal form as the function evaluated as much as possible then output as lambda expression. dunno about infinite recursion though...
00:27:24 <jmcarthur_work> oh i see
00:27:29 <jmcarthur_work> i wasn't thinking right
00:27:30 <copumpkin> cnwdup: it would look like (b -> c) -> Map a b -> Map a c, right?
00:27:30 <quicksilver> EvanR-work: that's the problem, yes.
00:27:50 <cnwdup> copumpkin, yes.
00:27:55 <copumpkin> cnwdup: and would work by simply taking all the keys and applying the function to their values
00:28:00 <roconnor> quicksilver: you are saying this is applicative but not a monad?
00:28:41 <cnwdup> copumpkin, I'm following.
00:28:51 <quicksilver> roconnor: yes, I am
00:29:02 <copumpkin> cnwdup: if you view (->) as a kind of Data.Map, fmap is doing the exact same thing to it. For every given key (that is, an input), it applies the function to the associated value (the output)
00:29:10 <roconnor> quicksilver: and it is a commutative applicative functor
00:29:11 <copumpkin> cnwdup: but effectively, with functions, that's just called composition
00:29:25 <quicksilver> roconnor: I'm not sure but I think so.
00:30:00 <roconnor> hmm, the hard bit would be to get enough information from the run time system to construct this value.
00:30:18 <cnwdup> @src (->) fmap
00:30:18 <lambdabot> fmap = (.)
00:30:26 <cnwdup> copumpkin, ok. I understand.
00:30:57 <copumpkin> cnwdup: so for a more concrete example, think of a function h = (+1). You could think of this as a very large Data.Map containing (0, 1), (1, 2), (2, 3), (3, 4) and so on. fmap (+5) on that Data.Map would take it to (0, 6), (1, 7), (2, 8)... fmap (+5) on (+1) does the same thing, and is simply (+5) . (+1)
00:31:05 <roconnor> and an applicative functor doesn't seem like it would be powerful enough.
00:31:14 <copumpkin> I HAVE THE POWA
00:31:57 <roconnor> quick how many errors does (if (errror "0") then (error "1") else (error "2)) have?
00:32:11 <roconnor> other than the missing quote
00:32:15 <copumpkin> none! it's awesome
00:32:20 <cnwdup> copumpkin, Ok. I think I understand the similarity between a Map and a function.
00:32:32 <cnwdup> But there's no monad instance for Map, is there? ;)
00:32:54 <copumpkin> http://snapplr.com/hdaf
00:32:59 <int-e> roconnor: is "errror" one error, or two errors?
00:33:09 <copumpkin> > fmap (+1) . M.fromList $ [(0, 1), (1,2)]
00:33:11 <lambdabot>   fromList [(0,2),(1,3)]
00:33:16 <Veinor> ohohoho
00:33:17 <copumpkin> :)
00:33:28 <copumpkin> Veinor: bostonhaskell next week!
00:33:40 <roconnor> int-e: one ... why would it be two?
00:33:41 <Veinor> When next week? I might be busy with finals and/or coming home for winter break.
00:33:48 <copumpkin> Veinor: not sure actually
00:33:53 <copumpkin> Veinor: you should subscribe to the list
00:34:01 <roconnor> ah but spoon only works on NFData.
00:34:11 <roconnor> and NFData is traversable?
00:34:11 <int-e> roconnor: one typographical error and one "error" after correcting the typo.
00:34:21 <copumpkin> roconnor: I don't think it has such a superclass
00:34:39 <cnwdup> copumpkin, but a function is more than a mapping as each monad can be a functor, but not the other way around.
00:34:46 <Veinor> The next meeting of the Boston Area Haskell User's Group is 6:30pm - 8:30pm on November 24th at MIT.
00:34:49 <Veinor> uh.... >_>
00:34:53 <copumpkin> cnwdup: hm?
00:35:02 <roconnor> copumpkin: it is probably morally traversable.  We can just add another type constraint to spoon :D
00:35:04 <copumpkin> Veinor: yeah, but check Ravi's latest email
00:35:09 <copumpkin> roconnor: hah
00:35:16 <copumpkin> there aren't really that many Traversable instances, sadly
00:35:18 <roconnor> copumpkin: not that I seriously suggest counting the number of errrors
00:35:23 <copumpkin> :)
00:35:32 <cnwdup> copumpkin, I am having trouble with the monad instance of (->). I understand your examples for Functor (->), but that doesn't help with monads, does it?
00:35:43 <Veinor> it doesn't say when the meeting will be
00:35:52 <Veinor> other than 'next week'
00:35:53 <copumpkin> cnwdup: it helps you get closer. Now let's talk about Applicative (->) for a moment
00:35:58 <roconnor> this is an academic excerise I think.
00:36:02 <cnwdup> copumpkin, sure. :)
00:36:05 <Veinor> also, what does spoon do?
00:36:12 <copumpkin> Veinor: that's why I suggested subscribing to the list for when he sends out a specific date
00:36:18 <Veinor> how do I go about doing so?
00:36:20 <copumpkin> Veinor: helps you not fail
00:36:28 <copumpkin> Veinor: google groups!
00:36:47 <roconnor> copumpkin: hmm, traversable is the wrong word
00:36:56 <copumpkin> cnwdup: so Applicative adds pure :: a -> f a and (<*>) :: f (a -> b) -> f a -> f b
00:37:06 <copumpkin> cnwdup: again taking f = (c ->)
00:37:18 <copumpkin> we get pure :: a -> (c -> a) === a -> c -> a
00:37:18 <Veinor> joined :O
00:37:26 <copumpkin> cnwdup: now, what does that look like to you?
00:37:40 <cnwdup> That looks pretty much like const. ;)
00:37:41 <roconnor> copumpkin: maybe NFData is all that is needed.
00:37:48 <copumpkin> cnwdup: indeed!
00:37:53 <copumpkin> it's the only possibility
00:38:00 <copumpkin> now for the more interesting one
00:38:17 <roconnor> copumpkin: actualy with the NFData restriction, perhaps you could use a non-commutative monad such as Either.
00:38:17 * pastah_rhymez is writing a monad tutorial
00:38:19 <copumpkin> (<*>) :: (c -> (a -> b)) -> (c -> a) -> (c -> b)
00:38:21 * pastah_rhymez feels ashamed
00:38:34 <copumpkin> === (c -> a -> b) -> (c -> a) -> c -> b
00:38:39 <copumpkin> cnwdup: that one might be a little tricker
00:38:49 <copumpkin> roconnor: oh yeah?
00:39:06 <copumpkin> cnwdup: but basically think of it as a puzzle :) you have two functions and a value
00:39:14 <copumpkin> your value is of type c, and you need to get a type b
00:39:21 <Hunner> pastah_rhymez: don't forget to take http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ into account
00:39:32 <copumpkin> cnwdup: can you see how to do it
00:39:34 <copumpkin> ?
00:39:34 <cnwdup> So we apply c to the second function and the result and c to the first.
00:39:39 <copumpkin> yep!
00:39:48 <copumpkin> I think your terminology is a little backwards
00:39:51 <copumpkin> but that's the idea :P
00:39:57 <roconnor> copumpkin: you just return the first error in the depth first traversal of the NFData.  This is well defined.
00:40:01 <tombee> http://github.com/tombee/Perceptron/blob/master/perceptron.hs
00:40:11 <tombee> can someone point out why my weightedSum function is failing :p
00:40:13 <tombee> please :)
00:40:16 <copumpkin> roconnor: so I should add a fork :: a -> Either SomeException a?
00:40:39 <Veinor> there needs to be a monad tutorial tutorial
00:40:57 <copumpkin> @djinn (c -> a -> b) -> (c -> a) -> c -> b
00:40:58 <lambdabot> f a b c = a c (b c)
00:41:01 <nyingen> I heard monads are like burritos
00:41:03 <copumpkin> cnwdup: there, lambdabot wrote the code for me
00:41:09 <quicksilver> Veinor: I think there is.
00:41:24 <copumpkin> cnwdup: make sense so far?
00:41:28 <cnwdup> copumpkin, yes.
00:41:38 <copumpkin> now, the only thing that a Monad adds on top of an Applicative is join
00:41:38 <pastah_rhymez> Hunner: well, this is very simple
00:41:51 <copumpkin> cnwdup: or bind, but bind is a more complicated way of looking at the same thing
00:41:57 <copumpkin> :t join
00:41:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:42:02 <pastah_rhymez> Hunner: i'm wrining this as how monads are nice for removing boilerplate
00:42:06 <copumpkin> take m = (c ->)
00:42:14 <copumpkin> you end up with (c -> (c -> a)) -> c -> a
00:42:19 <copumpkin> what is the only thing you can do there?
00:42:33 <cnwdup> Apply c two times to the first argument.
00:42:46 <ksf> can anybody tell me why hsp formats xhtml in such a strange way?
00:42:49 <copumpkin> or pass it two times to the first argument, I'd say :)
00:43:03 <ksf> it does <tag\n><tag\n>
00:43:18 <copumpkin> cnwdup: so there you have it! I've shown that there is only one meaningful way to make (c ->) a monad. Of course, you probably still have no clue what the point of it is
00:43:21 <quicksilver> ksf: because that's the safe place to put newlines in.
00:43:47 <quicksilver> ksf: putting newlines in somewhere helps readability, and puttng it outside tags is not, in fact, safe in general.
00:44:10 <cnwdup> copumpkin, I feel like never seeing when to use it. I always write lambda functions to let lambdabot tell me that I could have used >>= or join for functions.
00:44:13 <ksf> ...but shuldn't be newlines between tags and actual PCDATA be noops?
00:44:23 <copumpkin> cnwdup: it's often called the Reader monad, or you can think of it as the "implicit parameter monad"
00:44:40 <quicksilver> ksf: No, they're part of the PCDATA and thus not necessarily nops.
00:44:45 <copumpkin> cnwdup: say you have \x -> (x^2) + (x^3)
00:45:07 <quicksilver> ksf: in HTML in particular, they're nops at "block-level" but at "inline-level" they're whitespace, equivalent to a single space character.
00:45:08 <copumpkin> here you have two functions, (^2) and (^3) being applied to the same value
00:45:27 <ksf> oh I see
00:45:36 <copumpkin> cnwdup: you can make that x into "The environment" and talk about it implicitly
00:45:49 <quicksilver> ksf: compare "k<b>s</b>f" and "k<b>\ns\n</b>f" ;)
00:45:58 <copumpkin> > (\x -> (x^2) + (x^3)) 5
00:45:59 <lambdabot>   150
00:46:02 <roconnor> copumpkin: I'm still hesitant
00:46:28 <copumpkin> > (do { a <- (^2); b <- (^3); return $ a + b }) 5
00:46:29 <lambdabot>   150
00:46:35 <quicksilver> ksf: of course, when people write HTML by hand they frequently use newlines where they know it doesn't matter, like <divs> and so on. And sometimes they get it wrong and have annoying layout glitches :)
00:46:52 <copumpkin> cnwdup: it does take a bit of getting used to
00:46:55 <roconnor> copumpkin: do people expect (spoon (error "no spoon", 7.0/0.0)) and (spoon (7.0/0.0,error "no spoon")) to be the same?
00:46:59 <ksf> yep most generated html I ever saw didn't have a newline for each and every tag
00:47:31 <copumpkin> roconnor: that does seem like a decent argument against providing any information
00:47:37 <cnwdup> copumpkin, I bet it does. But this was very, very helpful. Thank you. :)
00:47:53 <roconnor> copumpkin: ya, I'm trying to turn it into a more compelling example.
00:48:06 <copumpkin> roconnor: actually it would probably be 7 `div` 0
00:48:15 <roconnor> right
00:48:21 <roconnor> > 7 `div` 0
00:48:22 <lambdabot>   * Exception: divide by zero
00:48:29 <Berengal> > 7 / 0
00:48:30 <lambdabot>   Infinity
00:50:11 <copumpkin> roconnor: as 7.0/0.0 is often infinity
00:50:11 <copumpkin> cnwdup: need to do some quick prep for a meeting I have soon but can try to explain more afterwards if you're still around
00:50:16 <copumpkin> roconnor: I think that example is a perfect response to the question on reddit about providing more information, actually. My response was humorous and probably left him unconvinced, but it's a nice concise example of what could go wrong
00:50:34 <copumpkin> > 7 / 0 :: CReal
00:50:37 <cnwdup> copumpkin, thanks. I'll try to figure out bind myself in the meantime.
00:50:38 <lambdabot>   mueval-core: Time limit exceeded
00:51:10 <copumpkin> yay it's snowing
00:51:26 <cnwdup> copumpkin, well... you've figured it out for me. But I try to comprehend it.
00:52:16 <roconnor> copumpkin: even spoon sufferes from (spoon (error "spoon",fix id)) and (spoon (fix id, error "spoon")) being different
00:52:24 <roconnor> but maybe that isn't so bad.
00:52:37 <Baughn> "Google CEO Says Privacy Worries Are For Wrongdoers
00:52:39 <roconnor> at least they are compatable values.
00:52:49 <copumpkin> hmm, good point
00:53:02 * danderson smells spin
00:53:10 <copumpkin> maybe in an upcoming version I'll outline why Either is bad and explain gotchas in using spoon like that one
00:53:40 <int-e> Baughn: #haskell-blah, I'd say.
00:53:46 <roconnor> copumpkin: but I probably can't exhibit a problem with referential transparency using Either like I thought I could.
00:54:04 <roconnor> not sure
00:54:13 <Baughn> int-e: Accidental middle-click, actually. Perils of touchpads without palm sensors?
00:54:17 <copumpkin> wow, the one downvote spoon had has disappeared :o
00:55:41 <Baughn> roconnor: As for your example.. aren't those both bottom?
00:56:07 <roconnor> not with spoon
00:57:03 * hackagebot upload: msgpack 0.1.0 - A Haskell binding to MessagePack (HideyukiTanaka)
00:57:44 <Baughn> roconnor: Oh, because <<LOOP>> isn't a whitelisted error type?
00:58:07 <roconnor> I made copumpkin not catch loop
00:58:16 <roconnor> I think catching loop is very bad.
00:58:36 * ksf agrees
00:58:37 <Veinor> how do i caught loop?
00:58:53 <ksf> it's just throw NonTermination
00:59:04 <Berengal> thrown for a loop?
00:59:06 <ksf> where NonTermination is a data type with show _ = <<loop>>
00:59:16 <roconnor> Veinor: evaluate (fix id) `catch` <something about loop exception handler goes here>
00:59:19 <ksf> yep. if it's thrown, that is.
00:59:48 <ksf> never mess with the halting problem.
01:00:12 <int-e> ksf: I challenge it all the time, running programs hoping that they will terminate ;)
01:00:21 <Baughn> roconnor: I don't think I see the problem, though. Why is those two expressions spooning differently a problem?
01:00:43 <ksf> although blackholing propably catches all loops that run in constant space and don't use IO or something.
01:01:09 <Baughn> f !x = f (x + 1)
01:01:18 <roconnor> Baughn: this was my concern http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13763
01:01:24 <roconnor> I should try to make it even worse
01:01:26 <int-e> (actually, in my experience, they all terminate; some do it voluntarily while others succumb to my lack of patience and a subsequent term or kill signal. or lack of electric power, if all else fails.)
01:02:03 <ksf> int-e, as an semantic extension of haskell, you're a cyborg.
01:02:26 <Baughn> roconnor: Oh.
01:02:47 <ksf> arguably, also haskell could become bored with a loop and terminate it.
01:05:59 <pastah_rhymez> welcome back :)
01:07:13 <Berengal> @users
01:07:13 <lambdabot> Unknown command, try @list
01:07:17 <jmcarthur_work> freenode!
01:07:39 <pastah_rhymez> bye
01:08:09 * hackagebot upload: bindings-gpgme 0.1 - Low level bindings to gpgme. (MauricioAntunes)
01:14:15 <osaunders_> Berengal: You should write this up in a blog post if you haven't already http://echochamber.me/viewtopic.php?f=11&t=46392&view=next#p1821661
01:15:19 <osaunders_> @tell Berengal You should write this up in a blog post if you haven't already http://echochamber.me/viewtopic.php?f=11&t=46392&view=next#p1821661
01:15:20 <lambdabot> Consider it noted.
01:15:23 <Berengal> osaunders_: I don't have a blog yet. I got stuck implementing the blogging engine
01:15:24 <lambdabot> Berengal: You have 1 new message. '/msg lambdabot @messages' to read it.
01:16:01 <osaunders_> Berengal: Ah, yeah I know that one.
01:16:56 <ksf> what happened to happstack.com?
01:17:12 <ksf> it's been replaced by patchtag...
01:18:49 <EvanCarroll> darcs..
01:31:01 <ksf> is there anything sane to route uri's through your app under happstack? handling posts is another issue...
01:31:13 <ksf> wash seems to be quite dead, indeed.
01:35:25 <Saizan_> ksf: seen Happstack.Server.SimpleHTTP?
01:36:21 <ksf> that doesn't give me wash-like continuation thingies, does it?
01:36:59 <Saizan_> no
01:37:26 <mreh> ive got a function f :: Maybe a, it returns a Just until it has no more values to return, how could I collect all these values up in a list?
01:37:30 <ksf> ...in fact, I don't even really need continuations. I'd just like to have my served uris and hrefs match up
01:37:38 <mreh> some kind of special fold with >>=
01:37:45 <Saizan_> mreh: that's not a function
01:37:51 <Berengal> mreh: unfoldr
01:38:05 <Berengal> @type unfoldr
01:38:07 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:38:11 <mreh> are we still having netsplits?!
01:38:45 * Berengal loves that his client bundles all the splits and joins into one line
01:39:01 <mreh> alright, const f :: a -> Maybe b
01:39:04 <mreh> that's a function
01:39:16 <osaunders_> Berengal: What client?
01:39:23 <Berengal> osaunders_: Quassel
01:39:27 <Saizan_> ksf: mh, sclv was tackling that problem with a library that would work with an user-supplied ADT to represent routes
01:39:31 <osaunders_> @google Quassel
01:39:35 <lambdabot> http://quassel-irc.org/
01:39:36 <lambdabot> Title: Blogs | Quassel IRC
01:39:37 <Berengal> mreh: f is still a value. If it's Just once, it's Just forever
01:39:52 <Saizan_> ksf: the library mainly helping with nesting
01:40:28 <mreh> Berengal: it's a function that returns the events associated with a window in the past 30ms, if there are no events, it will return Nothing
01:40:34 <ksf> urldisp?
01:40:36 <osaunders_> Hm. I'd like to disable leave and join message entirely unless the person was active within a short period.
01:40:52 <Berengal> mreh: Sure it's not an IO (Maybe a)?
01:41:22 <mreh> Berengal: errr, right :D
01:41:44 <mreh> so I can use sequence
01:42:02 <Berengal> mreh: sequence won't stop at Nothing
01:42:18 <Berengal> ... maybe a MaybeT IO a will...
01:43:17 <Vulpyne> If I have Parsec 2 and Parsec 3 both installed, how do I force Parsec 2 to be used? I tried turning on PackageImports and using ``import "parsec-2.1.0.1" Text.ParserCombinators.Parsec'' and it did not seem to work.
01:43:24 <HaskellLove> why is random number generation stateful?
01:43:32 <Baughn> Vulpyne: A constraint in the .cabal file
01:43:48 <Vulpyne> Baughn: I'm trying to just manually use it in ghci or ghc --make blah.
01:43:49 <Berengal> HaskellLove: The state is the seed, which needs to be updated after each new random number
01:44:04 <Baughn> Vulpyne: Maybe -hide-package parsec-3-whatever
01:44:10 <dcoutts__> Vulpyne: ghci -package parsec-2.1.0.1
01:44:17 <Vulpyne> Baughn: It said parsec-2.1.0.1 was hidden, so I added -package parsec-2.1.0.1 to the commandline and now it says parsec-3 is hidden.
01:44:29 <HaskellLove> Berengal got it, thnx
01:44:40 <Vulpyne> Lemme put the stuff in a hpaste.
01:44:43 <Baughn> Vulpyne: Why not just use parsec-3?
01:45:06 <Baughn> Vulpyne: I think the speed problems are fixed now, or soon will be. There was talk of that on -cafe recently.
01:45:29 <Vulpyne> Baughn: Cause that specific application actually uses parsec-tagsoup, which doesn't support parsec3.
01:45:51 <mreh> Berengal: I can always just write it out in full, x : getMaybeWindowEvent -> x : [] if it is Nothing, is the Monad transformer a more elegant solution
01:45:54 <mreh> i'll show you the code
01:46:07 <Baughn> Vulpyne: ghc-pkg hide parsec-3
01:46:15 <Berengal> @unmtl MaybeT IO a
01:46:16 <lambdabot> IO (Maybe a)
01:46:25 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13813#a13813
01:46:26 <Vulpyne> Baughn: But I want to use parsec-3 in something else. :)
01:46:32 <Vulpyne> So I don't want to disable it completely.
01:46:47 <Vulpyne> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=13812 is the hpaste with stuff about my problem.
01:46:48 <Baughn> Vulpyne: cabal doesn't care if it's hidden or not, so you just have to switch back and forth when starting ghci. Make a script or something.
01:47:32 <Vulpyne> That's weird. What's the point of PackageImports then if it doesn't control which package is actually used?
01:48:08 <Baughn> Vulpyne: It does
01:48:32 <Baughn> You can use it if the same module exists in two or more packages with /different names/
01:48:44 <Vulpyne> Ahh.
01:48:49 <Baughn> ..it would be nice to make ghci read .cabal files, though
01:48:50 <Vulpyne> Okay, thanks for the information.
01:49:25 <Vulpyne> I wouldn't mind if there was just any way to tell it what package it should use.
01:50:05 <dcoutts__> Baughn: no, but it would be nice to do it the other way around
01:50:40 <Berengal> mreh: I don't think using a MaybeT will work...
01:50:47 <Baughn> dcoutts__: Just so long as it works
01:51:03 <Saizan_> "cabal show build-flags"
01:52:01 <Berengal> mreh: You could always write a sequenceMaybe function :: (Monad m) => [m (Maybe a)] -> m [a]
01:52:41 <dcoutts__> Saizan_: I was thinking just make cabal invoke ghci/hugs
01:52:59 <dcoutts__> with the right flags
01:53:00 <Berengal> I wouldn't mind the version being part of the package name
01:53:11 <Berengal> At least if it were an optional part
01:54:25 <pastah_rhymez> why does VTY have to suck?
01:54:37 <Berengal> pastah_rhymez: Because it's software?
01:54:50 <dcoutts__> Berengal: what do you mean? you can use -package foo or -package foo-1.0
01:55:07 <pastah_rhymez> Berengal: dude, no, i'm doing the "linux sucks. it's unusable"-thing here
01:55:07 <HaskellLove> IO is the one type that requires the programmer to know what a monad is the other monads are more or less IO
01:55:09 <HaskellLove> optional. It makes abstract return and bind necessary... anyone can comment on this? what is all the fuzz about monads then?
01:55:19 <Berengal> dcoutts__: But does that work in source code as well (with PackageImports)?
01:55:20 <Saizan_> dcoutts__: a simple query seems simpler, more unix style
01:55:46 <mreh> Berengal: it's an IO (Maybe a), not Maybe (IO a). I don't see how sequenceMaybe would help
01:56:00 <pastah_rhymez> HaskellLove: a monad is a way to express a computation
01:56:10 <dcoutts__> Saizan_: that might be useful too, but it's no substitute
01:56:17 <pastah_rhymez> HaskellLove: but what a 'computation' is is highly dependent on context
01:56:18 <Berengal> mreh: Look carefully at the type I wrote. It's still IO (Maybe a)
01:56:22 <HaskellLove> i think u guys exagarate monads
01:56:38 <dcoutts__> Saizan_: also, you want to invoke ghci so that when you :reload it will call out to cabal again to ask it to re-preprocess
01:56:49 <pastah_rhymez> HaskellLove: start reading "All About Monads"
01:56:56 <pastah_rhymez> it's probably the best tutorial
01:57:09 <mreh> HaskellLove: a Monad is a typeclass, anything that implements the typeclass is a monad
01:57:15 <dcoutts__> Berengal: I presume so, you're not really supposed to use package imports normally
01:57:16 <Saizan_> dcoutts__: i thought we could :define something in ghci that calls "cabal show .." and sets the flags
01:57:23 <pastah_rhymez> then you can complain about exagerating :p
01:57:51 <camio> Anyone know what happened to the happstack.com website?
01:58:06 <pastah_rhymez> seriously, is there no one i can troll into helping me with vty?
01:58:21 <burp> camio: you could ask in #happs
01:58:31 <burp> oh, you're already there :D
01:58:40 <Berengal> dcoutts__: Doesn't seem to work for me at least, unless I got the syntax wrong... "mtl-1.1.0.2" fails, "mtl" doesn't
01:58:45 <camio> burp: thanks
01:59:04 <mreh> > let ones = 1:ones in ones
01:59:05 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:59:10 <mreh> w00t
01:59:41 <EvanR-work> why doesnt my interpreter do that :(
01:59:46 <pastah_rhymez> > fix (1:)
01:59:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:59:56 <mreh> ooh
02:00:01 <mreh> :t fix
02:00:02 <lambdabot> forall a. (a -> a) -> a
02:00:02 <pastah_rhymez> @src fix
02:00:02 <lambdabot> fix f = let x = f x in x
02:00:07 <Berengal> > fix error
02:00:08 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
02:00:09 <ksf> http://www.cs.ru.nl/~rinus/iTaskIntro.html
02:00:12 <Saizan_> HaskellLove: we never emphasize the complexity of monads, because they are really simple to use, making new ones effectively takes  more
02:00:14 <pastah_rhymez> mreh: source is more helpful here :)
02:00:28 <pastah_rhymez> Berengal: heheheehe
02:00:29 <ksf> the clean guys surely fail at design, but that stuff is quite cool.
02:01:28 <Saizan_> HaskellLove: however i'm not sure i understand what the sentence you cited is trying to say.
02:01:55 <HaskellLove> lets face it, if u know something u can explain it to a two year old... u guys know the theory but if u really did understand u would have been able o explain to a new guy like me clearly
02:01:55 <copumpkin> I love how job postings on haskell-cafe are dialogues. "No, this requirement is silly, you should relax your criteria"
02:01:59 <portnov> > fix head
02:02:00 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
02:02:01 <HaskellLove> agree? honestly?
02:02:07 <copumpkin> HaskellLove: nope
02:02:08 <portnov> > fix tail
02:02:12 <lambdabot>   mueval-core: Time limit exceeded
02:02:21 <EvanR-work> HaskellLove: whats your problem again?
02:02:24 <EvanR-work> trollin?
02:03:04 <mreh> we don't use the work troll in #haskell
02:03:13 <HaskellLove> EvanR-work I am saying u guys do not really understand them really, otherwise you would be able to explain it to me in analogies and what not...
02:03:15 <mreh> we prefer haskelly-challenged
02:03:17 <Twey> ksf: Haha… code in Comic Sans
02:03:18 <Saizan_> HaskellLove: have you read this? http://www.haskell.org/haskellwiki/Monads_as_computation , it's quite simple, the length is only because it gives you the full rationale
02:03:27 <Twey> I thought/hoped I would never see that
02:03:29 <Saizan_> HaskellLove: analogies don't help.
02:03:31 <copumpkin> HaskellLove: you're basically saying "if you really understood quantum chromodyanmics, you'd be able to explain them to me super easily, despite me knowing very little quantum theory"
02:03:43 <EvanR-work> HaskellLove: people have been giving you tutorials and links etc
02:03:45 <HaskellLove> copumkin - yes
02:03:46 <copumpkin> HaskellLove: what I've been saying is that you can't jump in
02:03:48 <pastah_rhymez> copumpkin: werd
02:03:55 <napping> HaskellLove: you can explain anything to a two year old in about twenty years
02:03:56 <Berengal> HaskellLove: The problem with explaining monads is that they're so simple: There are no analogies that fit
02:04:16 <HaskellLove> ok let me try then i will keep reading again :(
02:04:21 <pastah_rhymez> HaskellLove: http://www.haskell.org/all_about_monads/html/index.html
02:04:31 <nagnatron> copumpkin: To be fair that job post did look like a wish list :)
02:04:34 <pastah_rhymez> read that, THEN complain about insufficient explanations
02:04:35 <aavogt> HaskellLove: read this and then perhaps you will reconsider why analogies usually are bad hre: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
02:04:37 <Berengal> That, in turn, makes explaining them harder, because you've got so few hooks into what the explainee already knows
02:04:44 <copumpkin> HaskellLove: I'm saying you're going about it wrong, though.
02:05:15 <copumpkin> HaskellLove: would you expect to understand string theory with no background in physics? picking up a book on string theory probably won't help you
02:05:21 <Saizan_> HaskellLove: do you understand the basic type system, higher order functions, and typeclasses? those are more or less prerequisites to understand how the various monads are defined/work
02:05:32 <ksf> I dunno how that 94% khaki-blind people see the page, but that red on that teal makes my eyes bleed.
02:06:11 <Twey> ksf: No kidding
02:06:16 <HaskellLove> copumkin people that already know some stuff like to play cool with some words and confuse the beginner, i have had physic professor who could explain me everything with analogies
02:06:31 <HaskellLove> Saizan_ of course i do
02:06:31 <napping> and then get down to equations?
02:07:07 <Saizan_> HaskellLove: then read the link i gave to you, it doesn't try to be cool at all :)
02:07:21 <Saizan_> HaskellLove: it just gives you the straight facts
02:07:23 <Gilly> no wonder - physics is such hand waving anyways (a math guy here :))
02:07:34 <mreh> @pl \a -> Just(1+a)
02:07:34 <lambdabot> Just . (1 +)
02:07:37 <aavogt> perhaps part of the problem is that you're expecting to get it right away?
02:07:52 <ksf> (/me has his personal gripe with a majority labeling me "colour-blind" when they, in fact, can't even imagine how many hues of khaki there are. they just see one)
02:07:57 <mreh> HaskellLove: on my own, it took me three months to understand Monads
02:08:17 <HaskellLove> language u use is source of confusion, u cant see from the viewpoint of beginer, that is my point, u take many things for granted and u cant explain
02:08:53 <mreh> HaskellLove: learning something new always hurts
02:08:53 <napping> oh, things can be explained, but it may take a few layers to get to stuff you also know
02:09:03 <HaskellLove> mreh: not really
02:09:14 <napping> so, read tutorials, write code, ask questions
02:09:19 <HaskellLove> ok
02:09:28 <mreh> don't be afraid to ask stupid questions either
02:09:53 <Saizan_> and look at the code
02:10:00 <Saizan_> code never lies!
02:10:02 <mreh>  @pl \a -> Just(1+a) -- this is the most stupid thing i've written today
02:10:03 <pastah_rhymez> stupid question: why are there no examples in the documentations on hackage?
02:10:32 <pastah_rhymez> mreh: fmap?
02:10:38 <Berengal> pastah_rhymez: Because we haven't nagged the authors enough about it
02:10:41 <aavogt> return . succ
02:10:41 <pastah_rhymez> or maybe not
02:11:05 <pastah_rhymez> Berengal: hmmm... what's the proper nagging channel?
02:11:05 <napping> pastah_rhymez: mostly for the same reason there's a lot of things without any definition at all
02:11:16 <aavogt> pastah_rhymez: the authors believe that the code is somewhat useful given type signatures ;)
02:11:24 <Raevel> :-)
02:11:36 <Berengal> pastah_rhymez: email, I believe. I've tried whining about it here, but it doesn't seem to improve.
02:11:41 <pastah_rhymez> aavogt: when i read the vty docs i get angry, tired and usually fall asleep
02:11:46 <napping> pastah_rhymez: but even documented things do seem to have less examples
02:11:48 <pastah_rhymez> in a slumbering rage
02:12:00 <pastah_rhymez> *slumbersome8
02:12:18 <Veinor> Hey guys
02:12:26 <Veinor> You know what's an anagram for Banach-Tarski?
02:12:36 <sproingie> Tarski-Banach?
02:12:43 <Veinor> Banach-Tarski Banach-Tarski.
02:12:46 <Veinor> ohohohohohohohohoho
02:12:59 <pastah_rhymez> bananach tarski: http://www.tanyakhovanova.com/Jokes/Brownsharpie/2006-12-11-bananach-tarski.jpg
02:13:31 <sproingie> obscurity ahoy
02:13:39 <lament> i'm glad she thought that picture worthy of a (C) declaration
02:13:41 <Berengal> Heh
02:13:49 <pastah_rhymez> hehe
02:13:56 <napping> sproingie: cmon, who hasn't heard of the Banach-Tarski theorem?
02:14:00 <Veinor> It's more of an 'attribution', it's not like you don't get the copyright anyway :P
02:14:17 <pastah_rhymez> napping: even your mom?
02:14:36 <HaskellLove> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ this article is so crap
02:14:42 <napping> hmm, maybe not
02:15:20 <pastah_rhymez> HaskellLove: http://www.haskell.org/all_about_monads/html/index.html <-- read this, everything from beginning to end, and do exercises
02:15:23 <pastah_rhymez> THEN complain
02:15:40 <pastah_rhymez> but please ask while reading if there's any confusion :)
02:15:42 <aavogt> pastah_rhymez: but there are altogether maybe 50 functions adn data declarations in vty
02:15:48 <lament> HaskellLove: I agree. The article is crap. Monads ARE burritos, and there's nothing difficult about that.
02:15:49 <Veinor> HaskellLove: I can see the article's point at the least
02:15:53 <aavogt> it can't be that difficult to piece it together
02:16:21 <pastah_rhymez> aavogt: well, there's no clear example of code structure
02:16:28 <napping> HaskellLove: are you saying you don't think concrete examples are helpful?
02:16:30 <Berengal> Ugh, underscore_variables
02:16:32 <HaskellLove> I know a professor who i bet can explain me monads in 10 mins, but he is abroad... even einstein said that, u really know something? well u can explain it to a 10 year old, it might take a day but u can
02:16:32 <pastah_rhymez> i don't see the general idea, that's all :(
02:17:05 <aavogt> pastah_rhymez: have you looked at any code that uses said library? There's a mirror of hackage with reverse dependencies somewhere....
02:17:06 <stroan> HaskellLove: Monads are really simple. It's how they are used that's clever and possibly unintuitive. Only way to learn is to use tehm imo. So go do exercises
02:17:10 <Veinor> I'd like to meet the man who can explain monads in 10 minutes, heh.
02:17:24 <pastah_rhymez> aavogt: "reverse dependencies"?
02:17:39 <aavogt> as in a listing of all packages that require vty
02:17:40 <HaskellLove> i am working on euler for next 5 or 6 months, too bad monads are not used there, as i was told
02:17:46 <pastah_rhymez> aavogt: i have interactive_terminal_test.hs open here
02:18:09 <Saizan_> HaskellLove: that 10 years old needs to listen to the explanations though
02:18:10 <Berengal> HaskellLove: I've used monads all over the place on PE problems
02:18:13 <aavogt> you can use monads in project euler problems
02:18:30 <pastah_rhymez> aavogt: thought it's one giant wall of text
02:18:36 <Saizan_> HaskellLove: reading the links we gave to you is the most efficient equivalent to that
02:18:39 <stroan> Veinor: it's not hard to explain monads really, a few operations and some rules. That's probably what confuses people the most I'd say, expecting the theory to explain the manner in which it is used
02:18:41 <sm> pastah_rhymez: http://joyful.com/repos/hledger/Commands/UI.hs is a slightly larger example
02:19:01 <HaskellLove> ok then i guess i should stop reading and just enjoy euler and monads will come to me ?
02:19:11 <Saizan_> HaskellLove: we could explain monads to you over irc personally, but we're not always in the disposition to do so.
02:19:11 <Veinor> Yeah, I think I at least sort of get the theory of the monad, just not the practical side.
02:19:16 <pastah_rhymez> sm: DUDE!!!!
02:19:20 <HaskellLove> stroan you are my man
02:19:21 <sproingie> monads are a type class with four operators.  two of them are really interesting, >>= and return.  Their type signature and the monad laws is what they all have in common, and that's about it.
02:19:22 <pastah_rhymez> this seems to be TOTALLY RAD!
02:19:31 <pastah_rhymez> like EXACTLY what i need
02:19:40 <scree> hmm.  In Data.Reflection, given types representing integers n and m, how can I best get a type representing n+m?
02:19:43 <pastah_rhymez> sm: where are your feet? they need kissing
02:20:30 <lament> Monads are like sections of pipe. With radioactive shielding. And the pipe is never wider than an orange.
02:20:32 <HaskellLove> anyone in the mood to explain me monads in pm? I got in the book to the monads chapter and stopped since it is confusing
02:20:40 <sproingie> Monad gives you a common way to glue functions together, since haskell doesn't otherwise have a concept of "flow control" where it just executes the next instruction
02:20:43 <pastah_rhymez> HaskellLove: fine
02:20:50 <ehamberg> could someone help me install X11? (i want to install xmonad 0.9). i get this error when i try to cabal install it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13817
02:20:53 <sm> if you still feel that way in half an hour.. you're very welcome :)
02:20:53 <pastah_rhymez> since you won't stop complaining in hre
02:20:58 <sproingie> so instead of ; we have >>=
02:21:05 * ksf suddenly remembers that time where he tried to convince his basic interpreter to eat "GOTO 120 AND 150" and decided that computers are dumb
02:21:30 <pastah_rhymez> sm: haha, where do you live?
02:21:46 <sproingie> ksf: you wanted it to fork or what?
02:22:01 <ksf> yes.
02:22:20 <ksf> I actually wanted to play the melody again, while displaying another verse.
02:22:23 <Berengal> ksf: It's probably a good thing it didn't work.
02:22:29 <dcoutts__> ehamberg: hmm, ./configure is failing to find headers that should come with the package. What OS/platform?
02:22:49 <ehamberg> Linux. openSuse 11.2.
02:23:09 <ehamberg> should come with what package? :)
02:23:10 <napping> HaskellLove: have you seen the axioms?
02:23:15 <endojelly> "What is the difference between a mutex and a semaphore? Which one would you use to protect access to an increment operation?"
02:23:22 <endojelly> ist it me or is that question.. strange?
02:23:31 <endojelly> first of all: can't I implement a mutex using a semaphore?
02:23:37 <mrd> sure
02:23:42 <endojelly> (among a lot of other things, I love semaphores)
02:23:43 <sproingie> consider the colloquial definition of mutex
02:23:46 <sproingie> i.e. a Lock
02:23:47 <napping> or vice versa
02:24:09 <ehamberg> dcoutts__: i have “ghc-X11-devel” installed, which provide /usr/lib/ghc-6.10.4/X11-1.4.5/include/HsXlib.h
02:24:09 <mrd> a binary semaphore, which can be implemented in terms of a semaphore, of course
02:24:11 <endojelly> and then... "an increment operation"... I don't quite see why it matters that that operation is an "increment operation" and it tells me... nothing
02:24:15 <Berengal> I'd put up a barrier so other threads can't get to the variable while I'm incrementing it.
02:24:17 <endojelly> is it atomic? then it doesn't need a mutex!
02:24:29 <endojelly> is it not? well, just use a mutex implemented with a semaphore 8)
02:24:33 <pastah_rhymez> sm: what version of VTY is this?
02:24:42 <napping> that's for bonus confusion, because a semaphore is mostly a counter, but you usually can't get at the count
02:24:47 <pastah_rhymez> (that your EPIC code is using)
02:24:47 <sm> pastah_rhymez: 4
02:24:47 <dcoutts__> ehamberg: ok, so you've already got an older version installed, do you need the newer one?
02:24:57 <sproingie> napping: and a damn good reason you can't
02:25:03 <ksf> Berengal, but it's the natural thing to do. I understood GOTO, understood that it takes a reference to the thing it should go to, and the manual claimed that it knew "AND"
02:25:12 <ksf> never mind, I had no idea what bools where, back then.
02:25:13 <endojelly> napping, ah. it didn't come to my mind that it was *explicitly* for confusion 8)
02:25:16 <napping> HaskellLove: I trust you've seen the monad laws? That might be the basics you want
02:25:24 <endojelly> so it is not just me, that question is ill-defined at best and confusing at worst?
02:25:26 <ehamberg> dcoutts__: “cabal install xmonad” tries to install X11, so it looks like it…
02:25:30 <endojelly> ill-posed rather than ill-defined
02:25:39 <sproingie> the monad laws aren't really as interesting for practical knowledge as the monad operators
02:25:40 <dcoutts__> ehamberg: HsXlib.h comes wit the X11 package, so it should always be found, it's in the X11 tarball
02:25:57 <endojelly> by the way, while we're at mutex and semaphores
02:26:04 <endojelly> how *is* STM implemented, especially in haskell?
02:26:07 <napping> endojelly: looks more like two or three questions - what's the difference and how to protect a lock
02:26:11 <napping> endojelly: there's a fine paper on that
02:26:19 <ehamberg> dcoutts__: oh. well, that doesn't help me much ;-)
02:26:51 <dcoutts__> ehamberg: right, that's why the error is so confusing
02:27:06 <endojelly> napping, cool, which one?
02:27:33 <ksf> the laws follow out of the do-notation, so to speak.
02:27:44 <ksf> without them, stuff wouldn't properly translate.
02:27:48 <napping> I think the original "Composable memory transactions" includes a section on that.
02:27:59 <ehamberg> dcoutts__: whoa, setting PATH to its default value solved it. i'll have a look at my system.
02:28:13 <endojelly> napping, hmm, I'll take a look, thanks
02:28:25 <dcoutts__> ehamberg: extra gcc?
02:28:32 <ksf> ...but they're a useful thing to have seen, in the same sense that it's useful to know that x + 0 = x and x + y = y + x
02:29:06 <ehamberg> dcoutts__: could very well be. this is a system i haven't used for a long time that i'm upgrading. :)
02:29:10 <ksf> (but you should spare people the proof)
02:29:13 <napping> endojelly: and "Haskell on a shared-memory multiprocessor" describes just about everything else in the parallel runtime, and maybe STM as well
02:29:22 <CalJohn> Can someone remind me of the list monad powerset definition?
02:29:26 <ehamberg> dcoutts__: thanks anyway! :)
02:29:32 <CalJohn> (i can't find it through google)
02:29:36 <dcoutts__> ehamberg: glad it's working :-)
02:29:42 <Saizan_> > filterM (const [False ..]) [1..3]
02:29:43 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
02:29:56 <CalJohn> thanks
02:29:57 <sproingie> whoah
02:30:33 <trofi> looks frightening
02:30:43 <chrisdone> I didn't drop the bomb
02:30:45 <sproingie> [False ..] is a lovely bit of golfing
02:30:52 <Twey> Heh
02:31:17 <sproingie> i still can't wrap my head around how that works
02:31:18 <napping> endojelly: actually the more general runtime paper doesn't seem to mention STM
02:31:32 <chrisdone> http://www.google.com/chrome/intl/en/w00t.html
02:31:36 <chrisdone> google chrome for linux woooo
02:31:51 <napping> sproingie: that's how Enum Bool goes
02:31:52 <Saizan_> ?src filterM
02:31:53 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:32:32 <pastah_rhymez> > filterM (const [True,False]) [1,2,3] -- sproingie
02:32:34 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
02:32:51 <copumpkin> HaskellLove: being able to explain things by analogies to real life things works up to a certain point
02:33:01 * hackagebot upload: GPipe-TextureLoad 1.0.1 - Load GPipe textures from filesystem (TobiasBexelius)
02:33:03 <copumpkin> HaskellLove: analogies work, but you need some grounding in the topic being explained
02:33:07 <Saizan_> filterM p (x:xs) = do b <- p x; if b then (x:) <$> filterM p xs else filterM p xs, with const [False ..] that 'b' is both False and True :)
02:33:40 <copumpkin> HaskellLove: someone could probably come up with an analogy for a lie algebra, but I doubt you'd be able to come up with a "real-world" example of one beyond R^3
02:33:53 <copumpkin> or rotations and stuff
02:35:25 <endojelly> napping, so the shm mp one?
02:36:15 <eturner> Hey guys. I have a small problem if anyone's interested in helping me out.
02:36:56 <stroan> eturner: what's the problem?
02:37:25 <ray> eturner: the solution is to twist left, not right
02:37:35 <eturner> I'm trying to implement a _very_ small readline library but I can't figure out how to take in the arrow key escape sequences.
02:38:33 <eturner> twist left?
02:38:55 <pastah_rhymez> eturner: ok, that's a tricky one
02:39:00 <ray> uaually works for me :(
02:39:16 <sproingie> napping: i get how [False..] goes, i just don't get how that powerset thing works
02:39:19 <ray> you can't even count on escape sequences to be the same
02:39:21 <Twey> Hehe
02:39:26 <pastah_rhymez> eturner: you need to have a massive case-function, that for getChar first tests if it's an escape
02:39:35 <pastah_rhymez> then you need to eat chars as far as you can
02:39:49 <pastah_rhymez> lots of calls to "isReady stdin"
02:40:02 <pastah_rhymez> eturner: easy way would be to steal code from VTY
02:40:07 <sproingie> ohhh i get it now
02:40:10 <pastah_rhymez> http://hackage.haskell.org/package/vty
02:40:19 <Twey> Don't you want to be working with the system termcap?
02:40:25 <pastah_rhymez> eturner: check Graphics.Vty.LLInput
02:40:32 <sproingie> pastah_rhymez: you also have to deal with timing out in order to read a bare escape
02:40:37 <sproingie> it's supremely tricky
02:40:44 <eturner> well, here's my code so far: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13818#a13818
02:40:57 <kmc_> > [False..]
02:40:58 <lambdabot>   <no location info>: parse error on input `]'
02:41:09 <napping> endojelly: the transactions one explains how stm is implemented. The shm explains how the rest of parallel stuff is done, but that doesn't really matter so much for STM
02:41:11 <sproingie> yay ambiguity
02:41:13 <pastah_rhymez> sproingie: isReady stdin worked for me when i did it
02:41:13 <kmc_> > [False ..]
02:41:15 <lambdabot>   [False,True]
02:41:22 <medfly> o.O
02:41:29 <endojelly> napping, the transactions one, then. thanks
02:42:05 <sproingie> i suspect it wants to read False.. as a module path
02:42:06 <kmc_> pastah_rhymez, that's a very nice power set
02:42:08 <kmc_> yeah
02:42:17 <eturner> I've looked through about a dozen hackage packages for relevant code, but I can't seem to find any :(
02:42:31 <napping> endojelly: you might also look for stuff on the STM in clojure, which uses a completely different approach, but I don't know anything that goes into detail
02:42:47 <endojelly> napping, different approach, sounds good
02:42:50 <kmc_> eturner, does haskelline not do it?
02:43:37 <napping> endojelly: GHC is basically - keep a thread-local log, check it before reading the actual vars, and then lock all the vars to verify log consistency/apply changes at the end
02:43:53 <endojelly> napping, just like a database, then
02:43:58 <endojelly> really through a log... nice
02:44:26 <napping> and clojure does a multiversion thing, like postgres
02:44:40 <eturner> well, i essentially just want to take interactive keyboard input, and I figure this is a small enough problem that I could do it and learn something, as i am a big noob :)
02:44:57 <eturner> and I'm _so_ close.
02:45:12 <pastah_rhymez> eturner: well, download the vty source and try to locate where Events are created
02:45:21 <pastah_rhymez> eturner: just load it and :i Event
02:47:20 <osaunders_> Channel Quiz! What does this do? foldr1 (const id)
02:47:30 <kmc_> :t foldr1 (const id)
02:47:32 <lambdabot> forall a. [a] -> a
02:47:33 <eturner> I've already examined vty, shellac, etc. but did not find anything helpful to what i am trying to accomplish. (please forgive my slow typing)
02:47:42 <ksf> iTask takes an interesting brute-force approach to web continuations: Just collect all input, and re-exectude the server-side logic from scratch on every step.
02:47:42 <kmc_> > foldr1 (const id) "abcde"
02:47:44 <lambdabot>   'e'
02:47:54 <osaunders_> kmc: Cheat!
02:48:15 <osaunders_> s/kmc/kmc_/
02:48:53 <filcab42> hi all
02:48:58 <kmc_> hi
02:49:06 <sproingie> ksf: if everything is cached, that's not a terribly bad way to do it
02:49:10 <sm> Why the fuck something as old as a terminal hasn't been beaten down into a simple, universally supported set of operations by now is a mystery. -- http://code.haskell.org/vty/docs/vty_4_development.txt :
02:49:25 <sm> hear hear
02:49:40 <sproingie> terminals suck
02:49:49 <sm> excuse the profanity.. I liked the quote
02:49:54 <filcab42> I know it may be a bit offtopic but... I saw that the Haskell compiler uses the types to prove (non-trivial) theorems about the code... Anyone knows where I can get more information about that?
02:50:12 <copumpkin> filcab42: in what sense?
02:50:14 <filcab42> I'm trying to learn about theorem proving and that seems like a nice place to start...
02:50:16 <ksf> ...well, one wouldn't want to use it to do video uploads. but for most of the cases, which is text data nowhere near 1k, it's perfectly sensible.
02:50:17 <kmc_> filcab42, http://en.wikipedia.org/wiki/Curry-Howard_Isomorphism
02:50:24 <filcab42> Unfortunately, I have no ideia
02:50:39 <filcab42> kmc_: The equivalence between proofs and programs, right?
02:50:43 <kmc_> yeah
02:50:51 <osaunders_> filcab42: That's not off-topic at all.
02:50:52 <sproingie> finally ported LambdaHack to vty4.  i should cut a patch.
02:50:58 <kmc_> a Haskell compiler won't really prove anything for you
02:51:01 <ksf> it trades massive performance problems due to having to keep track of a gazillion sessions with an equal number of continuations each with some re-processing.
02:51:04 <kmc_> your code is the proof
02:51:04 <filcab42> yes, but what kinds of proofs would you derive from a haskell program, for example?
02:51:21 <filcab42> kmc_: But the haskell compiler will, at least, verify it
02:51:27 <kmc_> yes, by typechecking
02:51:41 <kmc_> and it can also determine the most general statement proven by a particular proof
02:51:45 <kmc_> that being type inference
02:51:51 <sproingie> i did a multi-stage form library for CGI a while ago that did that sort of thing
02:52:22 <sproingie> using as many pure functions as i could.  i think i invented the state monad before i'd heard of haskell
02:52:29 <sproingie> (in perl)
02:52:35 <ksf> all input, of course, would be re-evaluated. so logging in might consist of prefixing all urls with an encoded version of the username/password pair
02:52:47 <napping> filcab42: well, Haskell is not an especially strong example of the curry-howard stuff. you have undefined :: a, so writing a function with a given type doesn't prove a whole lot
02:53:02 <filcab42> hmm
02:53:06 <sproingie> wasn't terribly general-purpose tho, i had to edit the library to support different sites, so it was more a coding style than a library
02:53:24 <ksf> the isomorphism only holds for the total subset of haskell.
02:53:35 <copumpkin> filcab42: if you like haskell, and are interested in proofs, you might want to try agda :)
02:53:59 <filcab42> copumpkin: thanks
02:53:59 <ksf> ...as, in fact, turing-completeness doesn't play well with the soundness of any logic system, after all.
02:54:10 <copumpkin> filcab42: it even has an IRC channel, #agda :)
02:54:13 <copumpkin> on this network!
02:54:48 <filcab42> Heh
02:54:57 <copumpkin> filcab42: otherwise you can be more mainstream and use coq or isabelle or something like that
02:55:23 <sproingie> only in #haskell
02:55:32 <sproingie> "mainstream languages like coq and isabelle"
02:55:38 <copumpkin> lol
02:55:48 <napping> filcab42: there's also parametricity, which is perhaps more directly useful for programming anyway
02:55:52 <copumpkin> Veinor: damn, giant antichrist head obama is gone!
02:56:57 <ksf> am I the only one who finds papers that use clean to be less readable than haskell papers, even in the prose sections?
02:56:58 <filcab42> Thanks. BTW, do you know any good book/site/paper/whatever that would be nice to read about theorem proving?
02:57:08 <osaunders_> Can you explain ap without explaining monads?
02:57:16 <ksf> osaunders_, yes.
02:57:20 <ksf> ap = <*>
02:57:30 <copumpkin> osaunders_: yes, with SK calculus
02:57:31 <ksf> :t (<*>)
02:57:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:57:35 <copumpkin> for a particular monad ;)
02:57:37 <napping> The Coq book is good
02:57:51 <osaunders_> copumpkin: SK calculus?
02:58:00 <ksf> [(*2),(+4)] <*> [1,2,3]
02:58:02 <ksf> > [(*2),(+4)] <*> [1,2,3]
02:58:03 <lambdabot>   [2,4,6,5,6,7]
02:58:21 <ksf> > [(*2),(+4)] <*> [1,2,3] :: ZipList
02:58:22 <lambdabot>   `Control.Applicative.ZipList' is not applied to enough type arguments
02:58:23 <lambdabot>  Expe...
02:58:23 <sproingie> LYAH explains <*> and doesn't touch monads
02:58:25 <ksf> > [(*2),(+4)] <*> [1,2,3] :: ZipList Int
02:58:26 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
02:58:26 <lambdabot>                  ...
02:58:40 <ksf> > ([(*2),(+4)] <*> [1,2,3]) :: ZipList Int
02:58:41 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList
02:58:41 <lambdabot>                  ...
02:58:54 <copumpkin> Needs moar data construktorz
02:58:57 <ksf> > ZipList [(*2),(+4)] <*> ZipList [1,2,3] :: ZipList Int
02:58:58 <lambdabot>   No instance for (GHC.Show.Show
02:58:58 <lambdabot>                     (Control.Applicative.Zip...
02:59:02 <ksf> > ZipList [(*2),(+4)] <*> ZipList [1,2,3]
02:59:03 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
02:59:03 <lambdabot>    arising ...
02:59:07 <osaunders_> sproingie: Which chapter?
02:59:09 <ksf> > unZipList $ ZipList [(*2),(+4)] <*> ZipList [1,2,3]
02:59:10 <lambdabot>   Not in scope: `unZipList'
02:59:12 <ksf> grrr
02:59:14 <copumpkin> > runZipList $ ZipList [(*2),(+4)] <*> ZipList [1,2,3]
02:59:15 <lambdabot>   Not in scope: `runZipList'
02:59:17 <sproingie> osaunders_: applicative functors, i'd guess
02:59:18 <copumpkin> meh
02:59:24 <copumpkin> @hoogle ZipList
02:59:24 <lambdabot> Control.Applicative newtype ZipList a
02:59:25 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
02:59:25 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
02:59:31 <ksf> > getZipList $ ZipList [(*2),(+4)] <*> ZipList [1,2,3]
02:59:32 <lambdabot>   [2,6]
02:59:33 <copumpkin> I hate the naming for those newtype extractors
02:59:38 <copumpkin> we really need a newtype typeclass
02:59:47 <ksf> > getZipList $ ZipList [(*2),(+4),(-10)] <*> ZipList [1,2,3]
02:59:48 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
02:59:48 <lambdabot>    arising from a use of syntactic n...
03:00:00 <ksf> > getZipList $ ZipList [(*2),(+4),((-) 10)] <*> ZipList [1,2,3]
03:00:01 <lambdabot>   [2,6,7]
03:01:05 <Gracenotes> it'd be nice if the zip list methods were accessible outside the applicative methods, for plain lists
03:01:05 <lambdabot> Gracenotes: You have 1 new message. '/msg lambdabot @messages' to read it.
03:01:24 <napping> hey, does anyone know of nice code for manipulating imperative programs?
03:01:25 <ksf> Gracenotes, like, zip and ZipWith?
03:01:25 <aavogt> is  (map getZipList . map ZipList) a no-op?
03:01:42 <ksf> yep
03:01:45 <ksf> at least should.
03:01:54 <ksf> well it has to be.
03:01:57 <Gracenotes> ksf: those emulate liftA* up until 7.
03:01:57 <copumpkin> yeah, because map f . map g = map (f . g) and getZipList . ZipList = id, and map id = id
03:02:00 <aavogt> or is it the same as (map id)
03:02:03 <ksf> ...that's just wrapping and unwrapping a newtype.
03:02:07 <Gracenotes> it's not an applicative formulation, though
03:02:40 <Gracenotes> actually, it's not entirely a no-op. it evaluates each element to WHNF
03:02:45 <aavogt> copumpkin: do we really get (map id = id)? I think the map forces the spine of the list
03:02:59 <aavogt> while id doesn't do anything to each element
03:03:04 <Gracenotes> > getZipList $ ZipList undefined
03:03:06 <lambdabot>   * Exception: Prelude.undefined
03:03:25 <shepheb> aavogt: only if you force map to force the spine
03:03:28 <c_wraith> only if something forces the evaluation of the map call.  and I'm not sure how you'd force evaluations of map id
03:03:51 <c_wraith> that is, anything that forces the evaluation of map id also forces evaluation of the spine of the list anyway
03:04:00 <ksf> map id is already forced at compile-time.
03:04:06 <ksf> there's a RULE for such things.
03:05:07 <napping> like transforming a Fortran or C program, doing things like walking through expressions and applying rewrites that require adding a new statement before it, or declaring new temporaries
03:05:13 <Gracenotes> hm. trying to reason about newtype strictness.. hm :/
03:05:35 <napping> seems like the sort of thing where I need the right monad
03:05:38 <ksf> they are strict, always.
03:05:49 <ksf> ...as they're guaranteed not to exist at runtime.
03:06:31 <Gracenotes> right.
03:06:41 <aavogt> shepheb: yes, map id isn't going to cause any evaluation on itself, but when you eventually force the list, I guess the question is whether or not there is any less calculations done if (map id) is replaced by (id)
03:06:54 <copumpkin> fewer
03:06:58 * copumpkin coughs
03:07:00 <napping> aavogt: yes, unless map id was optimized away
03:07:10 <Gracenotes> oh, I see, in length . map (getZipList . ZipList), neither of the inner functions is entered
03:07:36 <aavogt> and depending on how strangely you write id, I guess the RULES for map id won't fire
03:07:40 <Gracenotes> if ZipList was applied, but getZipList was not, it would break for undefined elements. brainfreeze.
03:08:04 <shepheb> aavogt: map id, without any optimization removing it, will cost ops at runtime. it won't change strictness though
03:08:24 <ksf> Gracenotes, undefined and ZipList undefined have the same run-time semantics.
03:08:25 <aavogt> makes sense
03:08:36 <Gracenotes> ksf: yeah. implicit bang
03:08:43 <copumpkin> no
03:08:45 <ksf> ...even if you match on the ZipList constructor, you get bottom.
03:08:51 <copumpkin> no implicit bang
03:08:54 <shepheb> perhaps GHC can do better than RULES map id = id, though, through some other kind of analysis
03:08:54 <copumpkin> I just want bang bang bang
03:08:56 <ksf> as, in fact, there's no constructor to match on.
03:08:56 <Gracenotes> :o
03:09:02 <copumpkin> I don't want relationship
03:09:38 <Gracenotes> that awful sound, bang bang
03:09:43 <napping> shepheb: plain list fusion tries to to things like map f . map g -> map (f . g)
03:09:51 <copumpkin> my baby shot me down
03:10:09 <lament> this is the way the world ends
03:10:25 <Twey> Down down down down down down down…
03:10:27 <Berengal> Not with a bang, but with a newtype?
03:11:35 <Gracenotes> well, I love me some denotational semantics. anyway, class :o
03:17:47 <ksf> what do you people think about the clean guys extending their compiler to eat haskell98?
03:18:05 <elly> "why?"
03:18:30 <ksf> I guess because it's not that hard, and they can annoy the ghc devs.
03:18:46 <ksf> mhhh.
03:19:00 <sw17ch> So, this thingy i wrote reminds me of apply, but almost seems like a more general form... or something... can some one tell me where this functionality is replicated or if it has a name? Some one mentioned natural transformations earlier: http://github.com/sw17ch/rebox/blob/master/src/Data/Rebox.hs
03:19:08 <ksf> Is ghc still considering not being the fastest haskell implementation as a bug?
03:19:22 <Twey> Hehe.
03:19:32 <Twey> Doesn't Yhc/Supero beat it?
03:19:51 <ksf> well, they've got plans on supercompilation.
03:20:17 <aavogt> is the clean compiler as portable as ghc?
03:20:35 <ksf> I wouldn't know, I don't download software that requires registration.
03:20:52 <ksf> and ghc isn't portable, btw.
03:20:59 <ksf> hugs is portable.
03:21:10 <aavogt> there are varying degrees though
03:21:22 <Philonous> Hugs isn't a compiler, though, or is it?
03:21:48 <ksf> hugs is portable as in "compiles out of the box on platforms that didn't exist as the tarball was packed"
03:22:00 <ksf> yep
03:22:05 <ksf> it's pure C, afaik.
03:22:49 <napping> GHC is port-able
03:23:21 <elly> with sufficient thrust, anything is :)
03:23:29 <ksf> napping, well, go ahead, port it.
03:23:56 <napping> to what?
03:24:15 <c_wraith> linux on arm
03:24:33 <c_wraith> ghc apparently doesn't work on arm, because of the lack of FPU
03:25:18 <sw17ch> c_wraith: not all arms lack FPUs
03:25:29 <ksf> napping, http://hackage.haskell.org/trac/ghc/ticket/3472
03:25:37 <c_wraith> I guess that's true.  there are about a billion variants of the architecture at this point
03:25:59 <tommd> Are you talking about ARM or x86?
03:26:11 <sw17ch> c_wraith: for example: iPhone
03:26:15 <sw17ch> or my Samsung Saga
03:28:20 <napping> ok, so it's meant to be port-able
03:31:03 <ksf> x86 lacks an fpu, too.
03:31:09 <ksf> it's the x87 that is an fpu.
03:34:05 <EvanR-work> hi im learning haskell. lets say i have a infinite list of things, how do i use do notation to get just one of them, in such a way that the next time i 'get one' it will be the second element, then third, and so on? or am i thinking about it wrong
03:34:38 <ksf> why do you want to use do-notation?
03:34:47 <inclement> That sounds like you want to change the nature of your list. You can't do that, instead take the first value (or whatever) and th
03:34:57 <ben> State monad?
03:35:05 <EvanR-work> in the imperative part of the program id like to use the list as a generator, get an element 'on demand'
03:35:08 <EvanR-work> the next element
03:35:24 <ksf> yep, state monad.
03:35:30 <EvanR-work> hmmm
03:35:43 <ksf> the random number generator api uses such a model
03:36:12 <EvanR-work> okay
03:36:20 <Philonous> @type foldM
03:36:21 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:36:48 <Baughn> dons: If I were to write new Binary instances for things like List that don't require the whole thing to be forced (i.e. allows lazy encoding), is there any chance it would be accepted?
03:36:54 <ksf> so getNextNumber = do {(x:xs) <- gets; puts xs; return x}
03:37:11 <EvanR-work> :t getNextNumber
03:37:12 <lambdabot> Not in scope: `getNextNumber'
03:37:45 <ksf> ...It'd be a bad idea to save the whole list and an index, as the start of the list would'nt get garbage collected.
03:37:53 <kmc_> EvanR-work, does "mapM" not do what you want?
03:37:54 <EvanR-work> i would like to avoid that
03:37:58 <ksf> it's State [a] a
03:38:28 <EvanR-work> how would you use mapM for this
03:38:39 <Philonous> kmc_: foldM more likely, as you can carry over data
03:39:13 <Philonous> Ah, scratch that
03:39:16 <EvanR-work> ksf: so youre saying that the function above would allow the beginning of the list to be garbage colelcted
03:39:16 <ksf> :t runState
03:39:17 <lambdabot> forall s a. State s a -> s -> (a, s)
03:39:49 <ksf> yep. as the state doesn't keep a reference to the beginning.
03:39:54 <EvanR-work> cool
03:40:02 <EvanR-work> haskell is awesome
03:40:30 <copumpkin> damn righ
03:40:32 <copumpkin> t
03:40:59 <ksf> you could, of course, also want to do things like getPrevNumber = do {(xs, i) <- gets; return xs !! (i-1)}
03:41:12 <EvanR-work> nah ;)
03:41:22 <ben> If you use !! with strictly increasing indices, does the beginning of the list get garbage collected? :)
03:41:41 <EvanR-work> ksf: the dice never repeat ;)
03:41:52 <Philonous> ben: No, as long as you can access the head of the list, nothing ge's garbage collected
03:41:55 <shepheb> ben: if you use !!, should you expect anything good to happen?
03:42:08 <ben> How about -O2 :(
03:42:21 <shepheb> !! is almost certainly not the answer
03:42:40 <copumpkin> it is the answer to a question with two question marks
03:42:41 <ksf> "Multiple exclamation marks", he went on, shaking his head, "are a sure sign of a diseased mind."
03:42:46 <ben> :D
03:43:55 <copumpkin> sw17ch: looks like an Applicative instance
03:44:09 <sw17ch> copumpkin: an instance for what though? :)
03:44:15 <copumpkin> sw17ch: a bunch of Identity-isomorphic Applicative datatypes :P
03:44:29 <copumpkin> where reboxn = liftAn
03:44:36 <EvanR-work> ksf: looks like i need to read up on this state monad... gets.. puts...
03:44:39 <sw17ch> really...
03:44:41 <sw17ch> hmm
03:44:42 <copumpkin> oh wait, not quite
03:44:43 <sw17ch> :t liftA2
03:44:44 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
03:44:55 <copumpkin> yours are homogeneous
03:44:59 <sw17ch> copumpkin: yeah, i thought they were slightly goofy
03:45:15 <ben> > let (??) = (listToMaybe .) . flip drop in ("foo" ?? 5, "foobar" ?? 5)
03:45:16 <lambdabot>   (Nothing,Just 'r')
03:45:25 <copumpkin> well, it's an applicative with lots of composing with a single function
03:45:32 <ksf> EvanR-work, it's really just semantic sugar. you could equally well thread the list thruogh your computation, no magic involved.
03:45:45 <Baughn> @ask dons Actually, shouldn't the Data.Binary instances be in a different package from the class/builder itself?
03:45:45 <lambdabot> Consider it noted.
03:45:54 <EvanR-work> ksf: yes but then would it be gc'd
03:45:57 <shepheb> ben: if "strictly increasing" means "each one", then map. if not, what about filtering first?
03:46:03 <ksf> yes, it would.
03:46:04 <EvanR-work> ah i pass the tail part
03:46:09 <ksf> it makes no differenc.
03:46:12 <ben> hm
03:46:21 <osaunders> In math is there any difference between kth and nth other than name?
03:46:36 <ben> kth is probably later than nth
03:46:50 <ksf> "kayth" is easier to pronounce than "enth"
03:46:56 <EvanR-work> ksf: i am a little confused on memory management, isnt the definition of the list a 'reference' ?
03:46:57 <sw17ch> copumpkin: now, my larger question, is can it be made useful?
03:47:05 <c_wraith> I'm used to k < n
03:47:08 <osfameron> wow, TaPL is dense.. i'm just working through chapter 2 (the remedial maths chapter)
03:47:11 <lament> let the number of tanks be N, no, wait, let it be M.
03:47:24 <ksf> > drop 1000 [1..]
03:47:24 <lambdabot>   [1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015...
03:47:37 <osfameron> nthxbye makes no sense
03:47:37 <c_wraith> But it's all just convention.  they're just unknown values, without further context
03:47:44 <ksf> ...the first 1000 elements are free to be discarded, even if you hold on to the rest.
03:48:05 <ben> > [1..] !! 1000
03:48:06 <lambdabot>   1001
03:48:11 <EvanR-work> so by 'holding on', you mean an active computation is using it
03:48:30 <EvanR-work> :S
03:49:07 <c_wraith> > [1..] !! 1
03:49:08 <lambdabot>   2
03:49:25 <EvanR-work> whats with the !!
03:49:36 <Philonous> @src (!!)
03:49:36 <lambdabot> xs     !! n | n < 0 = undefined
03:49:36 <lambdabot> []     !! _         = undefined
03:49:36 <lambdabot> (x:_)  !! 0         = x
03:49:36 <lambdabot> (_:xs) !! n         = xs !! (n-1)
03:49:48 <EvanR-work> channel rules is that you cant use it!
03:49:53 <c_wraith> > let x + y = [x..] !! y in 5 + 8
03:49:54 <lambdabot>   13
03:50:00 <ksf> you're holding on if there's a reference left, at run-time. if you say "tail primes", after it gets evaluated, it's no longer a reference to "primes", but to some other computation that knows how to compute all primes starting from the second.
03:50:05 <c_wraith> I've just invented really slow addition!
03:50:15 <ksf> like, say,
03:50:32 <c_wraith> ...  partial addition.  y can't be negative
03:50:34 <ksf> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
03:50:35 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
03:50:36 <tensorpudding> c_wraith: looks like peano to me
03:50:48 <Philonous> EvanR-work: (!!) is the list index operator. It's in O(n) time, that's why you shouldn't use it.
03:50:50 <ksf> there's never more than two numbers in memory at the same time, the rest is code.
03:50:57 <EvanR-work> Philonous: right, makes sense
03:50:57 <|Jedai|> c_wraith: It works a lot like the Peano definition of addition
03:51:10 <kmc_> it's fine to use it sometimes...
03:51:16 <tensorpudding> if you need to use something like (!!) maybe you should use arrays instead of lists?
03:51:16 <kmc_> you have to understand that lists are not arrays
03:51:25 <EvanR-work> right
03:51:33 <jmcarthur_work> > [0..] !! 999999999999
03:51:34 <ksf> ...except if you hold on to a reference to the beginning: haskell won't just reevaluate everything, it caches, so to speak.
03:51:38 <lambdabot>   mueval-core: Time limit exceeded
03:51:40 <kmc_> if you want f^n(x) it seems very sensible to do (iterate f x) !! n
03:51:43 <tensorpudding> (!!) is okay if your list is tiny
03:52:07 <|Jedai|> EvanR-work: but it's fine to use it if you know what you're doing (as long as you don't use it like an array, often doing (!!) on arbitrary big numbers
03:52:11 <kmc_> basically if you are used to imperative programming, realize that (!!) is a loop.  if you want a loop (e.g. iterate f this many times) it's fine
03:52:14 <jmcarthur_work> arrays are okay if your array is medium sized
03:52:22 <Twey> What's that?
03:52:22 <Twey> ksf: I find /ɛnθ/ easier than /ˈkeɪ.ɨθ/
03:52:24 <osaunders> Is there a @pl feature in GHCi?
03:52:26 <kmc_> there's also Data.Sequence
03:52:42 <tensorpudding> jmcarthur_work: what is "medium sized"?
03:52:57 <jmcarthur_work> tensorpudding, small enough to fit into memory ;)
03:52:58 <|Jedai|> kmc_: in fact while "(iterate f x) !! n" is short and nice, it's kind of a bad idea if f is strict
03:53:06 <|Jedai|> kmc_: and n big
03:53:23 <ksf> osaunders, cabal install lambdabot
03:53:26 <tensorpudding> jmcarthur_work: that is still kinda small i guess
03:53:38 <Twey> ksf: I find /ɛnθ/ easier than /ˈkeɪ.ɨθ/
03:53:40 <EvanR-work> ksf: but if i define fibs = (that code) then its always in memory?
03:54:00 <osaunders> lambdabot uses brainfuck?!
03:54:09 <ksf> the code, yes.
03:54:16 <EvanR-work> the beginning of the sequence
03:54:18 <Twey> EvanR-work: I know of no such channel rule.  Use of !! is a Code Smell, though — it suggests you're using the wrong structure.
03:54:20 <|Jedai|> EvanR-work: if you define at top-level it won't ever be GC'd since you always have a reference on the head of the list
03:54:20 <ksf> not all the data, of course, it's infinite, after all.
03:54:23 <Veinor> copumpkin: :P
03:54:36 <ksf> |Jedai|, also CAFs get gc'ed.
03:54:38 <EvanR-work> |Jedai|: ah
03:54:58 <EvanR-work> |Jedai|: but what if its a function that returns fibs
03:55:01 <|Jedai|> ksf: I read that somewhere, but I wouldn't rely on that too much
03:55:38 <EvanR-work> or a function they may return fibs
03:55:41 <ksf> ...the question is whether you have one or more references to it. if the one that evaluates first walks it to 100000000, and the second one that uses it to 10, then you've got a space leak of sorts.
03:56:26 <ksf> ...also, if you define fib n = fibs !! n
03:56:55 <ksf> though I agree it's best not to speculate about any of such stuff, and rely on profiling.
03:58:27 <EvanR-work> erm... so in practice i dont want to define at the top level things which dont always need to be in memory. but what about things define 'inside' definitions (where clause) do those count as top level?
03:58:31 <EvanR-work> gah
03:59:03 <ksf> you can use the top level just fine.
03:59:22 <ksf> I'd recommend not to worry.
03:59:33 * osaunders worries
03:59:53 <ksf> osaunders, we even have brainfuck on the type level.
04:00:09 <EvanR-work> in the generator case, i define the infinite list at the top level as rand seed = (sets up the list with seed seed), so later when i set up the state monad, will it eventually not gc?
04:00:12 <osaunders> Huh?
04:00:18 <osaunders> How?
04:00:33 <ksf> UndecidableInstances, I presume.
04:00:45 <osaunders> Actually I don't want to know.
04:00:46 <ksf> and some type families.
04:00:50 <ksf> google for typefuck
04:00:57 <osaunders> No thanks! :-)
04:01:53 <ksf> EvanR-work, in that case, you're safe no matter how CAFs behave, as CAFs are top-level definitions that don't take parameters.
04:02:05 <lament> search text, not images :)
04:02:18 <joe____> function :: x -> y -> z -> [empty list]
04:02:23 <ksf> ...you'd say something like runState (yourComputation) (rand 0xdeadbeef)
04:02:28 <joe____> how can I write the function definition
04:02:36 <ksf> where rand :: Int -> [Int], or similar.
04:02:39 <joe____> when there is no return parameter?
04:02:57 <osaunders> joe____: Empty list == []
04:03:06 <ksf> in that case, of course, you could also just forget about lists and just carry the seed around as state.
04:03:16 <joe____> ok, thanks. and every function has a return parameter?
04:03:23 <osaunders> Yep.
04:03:32 <EvanR-work> ksf: CAFS?
04:03:36 <osaunders> Every function must return a value.
04:03:40 <osaunders> Always.
04:03:56 <ksf> http://www.haskell.org/haskellwiki/Constant_applicative_form
04:04:31 <Philonous> @ŧype let f x = f x in f 3 -- doesn't return anything
04:04:32 <lambdabot> forall t. t
04:05:10 <ben> @help ŧype
04:05:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:05:18 <filcab42> Every function that terminates =)
04:06:01 <ksf> > let f x = f x in f 3
04:06:05 <lambdabot>   mueval-core: Time limit exceeded
04:06:10 <ksf> there, it does.
04:06:16 <ksf> spoon would have caught that.
04:06:28 <EvanR-work> ksf: cool. are all declarations of the form x y z = CAFS?
04:06:38 <Philonous> ksf: exceptions are only observable in IO
04:06:54 <ksf> only things that don't contain free variables are CAFs
04:07:05 <ksf> ...and y and z are free, there.
04:07:16 <EvanR-work> rand seed =
04:07:17 <|Jedai|> EvanR-work: CAFs don't take parameters, so only declarations like "y = .." are CAF
04:07:19 <EvanR-work> seed is free
04:07:25 <ksf> yep
04:07:30 <EvanR-work> so its not a caf
04:07:36 <|Jedai|> EvanR-work: Right, so it's not a CAF so you don't have to worry
04:07:37 <ksf> nope.
04:07:40 <EvanR-work> oh
04:07:42 <EvanR-work> cool
04:08:06 <Philonous> |Jedai|: ((+) 3 ) takes parameters, but it is a CAF, isn't it?
04:08:17 <EvanR-work> and cafs are handled just fine in terms of memory, even if infinite
04:08:58 <|Jedai|> Philonous: ok, so no parameters appears in the binding declaration
04:09:06 <ksf> but, say you'd have splitState = do {(xs) <- gets, return (xs, xs)}, and then continue doing nextNumber on one of the references, but hold on to the other one.
04:09:41 <ksf> ...evaluated thunks would build up, which might not be what you want to do.
04:10:00 <EvanR-work> in that case all in between numbers would appear ?
04:10:10 <ksf> (it might be what you want to do if the computing those elements is really expensive and you've got plenty of ram)
04:10:32 <EvanR-work> the goal would be a one time read, so nextNumber would be the only interface to it
04:10:38 <ksf> yes: they have been constructed, as they were needed, and they can't get garbage collected, as they're still referenced.
04:11:01 <ksf> as I said, don't worry :)
04:11:13 * EvanR-work feels safer, maybe
04:11:34 <EvanR-work> gotta do work now
04:12:36 <McManiaC> hey, I'm trying to figure out how to use Control.Monad.Error (ErrorT)
04:12:50 <ksf> As I said, you can always change your code to not use an infinite list, but use State (Int, Int) Int, the first Int being seed, the other the prng state.
04:12:54 <ben> McManiaC: Which one?
04:12:58 <McManiaC> is there a way to get around those throwError functions etc if I already have a function that returns an Either?
04:13:08 <McManiaC> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
04:14:39 <aavogt> McManiaC: you can pattern match on Right, but that won't preserve any error messages if you get a Left
04:16:37 <aavogt> maybe this already exists in another library, but the function you're looking for is:   value <- either throwError return $ computationReturningEither
04:16:39 <McManiaC> preserve?
04:17:03 <aavogt> say you had a useful error message in the Left (as in you have Either String a)
04:17:21 <aavogt> perhaps you want that value to be thrown as your error
04:17:33 <aavogt> rather than getting a generic error
04:17:35 <McManiaC> jup
04:17:42 <McManiaC> thats why I want to use either
04:18:20 <McManiaC> and value <- either .... looks like what I've been looking for, but I thought this would be already "inside" that error monad
04:19:26 <fritschy_> how does it come i get no timing information in the cost centre profiling info (it's always 0.0)
04:20:13 <EvanR-work> ksf: that might actually be better... possibly smaller, and the state monad handles passing the state for me...
04:20:39 <aavogt> @type throwError
04:20:40 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
04:20:44 <aavogt> type return
04:20:55 <aavogt> @type either throwError return
04:20:56 <lambdabot> forall a (m :: * -> *) a1. (MonadError a m) => Either a a1 -> m a1
04:20:56 <ksf> well, there should'nt be a difference at run-time.
04:21:48 <aavogt> but you might have to wrap the contents of the Left case with a newtype etc.
04:22:26 <McManiaC> http://npaste.de/6a/
04:22:35 <McManiaC> it works but…
04:23:04 <EvanR-work> ksf: the list just seems cooler ;)
04:23:14 <joe____> i am trying to use Test.HUnit and the main is : main = runTestTT $ TestList [ functionx ]
04:23:21 <joe____> functionx :: parameter1 -> DeviceHandle -> Test
04:23:27 <McManiaC> would be cooler if Left = throwError and Right = return…
04:23:32 <joe____> how can I pass the parameters to functionx?
04:24:20 <sunrayser> I have two class definitions: http://pastebin.ca/1707353 how can I ensure that the _result_ of "PrgSemInf t" is an instance of ProgramClass?
04:24:51 <sunrayser> I tried some type equalities but GHC told me to wait for a future release
04:25:48 <joe____> main = do mydevicehandle <- get_deviceHandle; let parameter1 = "x y x";  runTestTT $ TestList [ functionx ]
04:25:55 * paper_cc thinks that (either throwError return) should have had its own name
04:26:24 <paper_cc> joe____: runTestTT $ TestList [ functionx parameter1 mydevicehandle ]
04:26:28 <paper_cc> joe____: ?
04:27:12 <joe____> paper_cc: i am under the impression that the TestList will assume that there are 3 function definitions there instead of
04:27:17 <joe____> one function with 2 parameters?
04:28:32 <joe____> will it take functionx, parameter1 and mydevicehandle as 3 functions?
04:28:38 <paper_cc> joe____: no
04:29:00 <paper_cc> joe____: if you wanted that you'd have to separate them with commas
04:29:20 <napsy> Hello. What does the "Eq a =>" in the function prototype "encode :: Eq a => [a] -> [(Int,a)]" mean?
04:29:46 <ben> It means that you must be able to check two values of type a for equality using ==
04:29:46 <sproingie> anything to the left of => is a constraint
04:29:46 <shachaf> napsy: a is a member of the type class Eq.
04:30:04 <Zao> @src Eq
04:30:05 <lambdabot> class  Eq a  where
04:30:05 <lambdabot>     (==), (/=)   :: a -> a -> Bool
04:30:25 <joe____> paper_cc: runTestTT $ TestList [ functionx parameter1 mydevicehandle , functiony parameter1 mydevicehandle ] would be interpreted as 2 functions?
04:30:29 <napsy> ok thanks
04:30:35 <joe____> just wanted to confirm.
04:30:36 <paper_cc> joe____: yes
04:30:40 <joe____> thanks.
04:31:19 <Zao> napsy: Any type a that has an instance of Eq can be fed into encode.
04:31:50 <napsy> ok
04:31:52 * hackagebot upload: convertible-text 0.0.0 - Typeclasses and instances for converting between types (MichaelSnoyman)
04:36:53 * hackagebot upload: web-encodings 0.2.0 - Encapsulate multiple web encoding in a single package. (MichaelSnoyman)
04:38:24 <ksf> wait.
04:38:36 <ksf> there's actually a working haskell->javascript compiler?
04:38:55 <ksf> why doesn't anybody tell me such things?
04:39:30 <cjay_> you mean yhc?
04:39:37 <ksf> yep.
04:40:11 <chocho> hello all
04:40:15 <cjay> last time I looked the website said that it's still experimental or something
04:40:37 <chocho> can someone help me understand the difference between higher order functions and monads?
04:40:51 <ksf> well, those javascript examples looks useable enough.
04:42:55 * hackagebot upload: hack-handler-cgi 0.2.0 - Hack handler using CGI protocol. (MichaelSnoyman)
04:43:06 <pyNem> chocho, higher order functions cant do everything monads can
04:43:22 <pyNem> chocho, higher order functions are required for implementing monads
04:44:00 <chocho> monads are built on higher order functions, then
04:44:15 <pyNem> not just higher order functions
04:44:30 <pyNem> Okay, tell me why you think monads are higher order functions are similar
04:44:34 <ksf> monads are made out of warm, fuzzy bits
04:44:51 <pyNem> ksf :) and lots of warm apple pie on a rainy afternoon
04:45:24 <chocho> that is to say, higher order functions are one building block of monads
04:46:02 <chocho> I suppose, then, another building block is expression binding?
04:46:47 <ksf> is there a ghc core -> yhc core translator?
04:46:50 <pyNem> chocho, yes
04:47:11 <chocho> I suppose also that the result of a monad is a function?
04:47:21 <pyNem> what is the result of a monad?
04:47:27 <pyNem> what do you mean by* the result of a monad?
04:47:36 <ksf> monads aren't functions, they don't have results.
04:47:46 <pyNem> yep
04:48:11 <pyNem> they are higher order functions in the sense that they combine other functions .. yes
04:48:22 <chocho> sum = reduce add 0
04:48:28 <emile_m> chocho: Monad is just polymorphic datatype (Monad a is like Foo Int or Foo Bool or Foo Whatever) with some functions defined *specially* for any particular monad. High order functon is just an ordinary function which have (at lest) one of it's arguments another function, or return a function.
04:48:30 <ksf> well, there monoids in a category of endofunctors.
04:48:36 <c_wraith> A monadic *value* might be a function.  It might not.  it might be... any type in the language.
04:48:43 <ksf> chocho, read this: http://www.haskell.org/haskellwiki/What_a_Monad_is_not
04:49:02 <pyNem> but the manner in which they combine them is so useful and specialised that they have a name for themselves
04:49:17 <Vulpyne> Are you confusing bind with monads themselves?
04:49:36 * chocho is trying to catch up :)
04:49:47 <ksf> @src sum
04:49:47 <lambdabot> sum = foldl (+) 0
04:50:22 <chocho> I called it a function because it evaluates to something
04:50:25 <ksf> only ever use the term "reduce" if you have to sell something to a suit.
04:50:37 <ksf> "reduce, like in google's mapreduce, you know"
04:50:47 <chocho> bla = a b c
04:50:55 <pyNem> chocho, yeah, monads are functions, and yeah they are higher order functions if you want to look at it that way, but they are not _just_ normal higher order functions
04:50:56 * idnar reduces ksf
04:50:56 * monochrom is depressed by how people have to have everything spelt out in natural language before they do any exercise.
04:50:58 <chocho> a b c evaluates to bla
04:50:58 * hackagebot upload: hack-handler-simpleserver 0.2.0 - A simplistic HTTP server handler for Hack. (MichaelSnoyman)
04:51:10 <sproingie> monads are not functions
04:51:26 <pyNem> sproingie, ?
04:51:32 * ksf maps idnar onto a manifold
04:51:36 <sproingie> the typeclass is a group of functions
04:51:39 <c_wraith> very strictly, emile_m got it right.  a monad is a data type, that might contain anything.  It has some functions associated with it.
04:51:49 <pyNem> sproingie, yeah, okay. agreed
04:51:56 <monochrom> and more irony when natural language is not precise enough for spelling out this.
04:52:00 <Vulpyne> >>= isn't a monad.
04:52:17 <sproingie> being a functor it has some notion of containing.  "context" might be a better term tho.
04:52:20 <monochrom> Or at least how most people abuse natural lanauge is not precise enough.
04:52:42 <idnar> monochrom: I've always been amused by the term "natural language"
04:52:47 <idnar> monochrom: I mean, what's so natural about it?
04:52:56 <sproingie> we all speak it?
04:52:57 <chocho> so an expression involving a monad may not have an = in it?
04:53:09 <idnar> sproingie: we do?
04:53:23 <EvanR-work> is this correct, a monad is a type class of types with >>= and return defined?
04:53:25 <idnar> sproingie: which natural language does everyone speak? :P
04:53:25 <sproingie> barring extreme mental disability or injury, yes
04:53:30 <sproingie> idnar: at least one
04:53:37 <Vulpyne> It evolved "naturally" rather than being constructed like Lojban or Klingon. :)
04:53:59 * hackagebot upload: hack-handler-fastcgi 0.2.0 - Hack handler direct to fastcgi (MichaelSnoyman)
04:54:00 <sproingie> most languages even have the same basic parts of speech
04:54:05 <monochrom> Right, it is not law-of-nature natural.
04:54:05 <sproingie> nouns and verbs
04:54:38 <sproingie> technically everything is "law of nature" natural if you consider mental processes to be an outgrowth of biological ones
04:54:52 <monochrom> so haskell is natural too
04:54:56 <idnar> in which case the distinction is meaningless
04:54:56 <emile_m> Natural languages are fuzzy.
04:54:56 <sproingie> vague category is vague
04:55:01 <chocho> so, in order to understand monads, I assume I must understand the facilities they're built on
04:55:02 <jmcarthur_work> Naturals are natural.
04:55:10 <chocho> (i assert anyways)
04:55:13 <Cale> chocho: It would be a good idea.
04:55:14 <sproingie> chocho: category theory?  not at all.
04:55:20 <jmcarthur_work> type classes, though, yes
04:55:22 <monochrom> monad is natural too
04:55:27 <sproingie> the language constructs, definitely
04:55:34 <Cale> Well, at least the facilities *in Haskell* that they're built on :)
04:55:34 <chocho> well, that is, binding, higher order functions and
04:55:38 <chocho> and what else?
04:55:42 <Cale> typeclasses
04:55:43 <chocho> right
04:55:47 <ksf> category theory is just a set of functors between different areas of maths.
04:55:56 <jmcarthur_work> not sure what you mean by "binding"
04:56:06 <Cale> ksf: and a bunch of natural transformations between them
04:56:11 <idnar> ksf: to understand recursion, you must first understand recursion
04:56:15 <sproingie> abstract nonsense
04:56:22 <chocho> don't all monads have binding?
04:56:26 <jmcarthur_work> useful nonsense
04:56:28 <ksf> well I wasn't mentioning them because I still haven't grokked what a nt actually is.
04:56:32 <sproingie> all monads have >>= and return, yes
04:56:35 <ksf> I'm fine with functors, though.
04:56:41 <sproingie> that's basically it.  >> is defined in terms of >>=
04:56:44 <Vulpyne> http://www.haskell.org/haskellwiki/Monad_Laws
04:56:50 <sproingie> and 'fail' is, well, a wart.
04:57:03 <chocho> so, binding, hof, and type classes
04:57:20 <ksf> but monads aren't a feature of haskell.
04:57:23 <emile_m> btw, can I define an instance of monad using join instead of bind?
04:57:28 <jmcarthur_work> i just mean bind is part of monad, not a prerequisite
04:57:35 <sproingie> 'do' syntax is a feature of haskell
04:57:37 <jmcarthur_work> emile_m, ideally, but you can't
04:57:45 <jmcarthur_work> emile_m, you can write bind in terms of join though
04:57:50 <ksf> emile_m, theoretically, yes, in practice, no, as the typeclasses don't allow it.
04:57:53 <chocho> what types of abstractions are built on top of monads?
04:57:59 <jmcarthur_work> emile_m, m >>= k = join $ fmap k m
04:58:03 <sproingie> chocho: lists for one
04:58:23 <sproingie> lists, continuations, error handling ...
04:58:30 <sproingie> IO of course
04:58:35 <jmcarthur_work> emile_m, so you could say m >>= k = join' $ fmap k m where join' = ...
04:58:35 <sproingie> state
04:58:37 <ksf> erm lists don't use monads, I'd say.
04:58:40 <idnar> alternatively, (>>=) = flip (join . fmap)
04:58:41 <sproingie> lists are monads
04:58:51 * idnar squints to see if he got that right
04:58:56 <ksf> Monad [a] isn't about lists, but computations with arbitrary number of results.
04:59:05 <jmcarthur_work> idnar, i would totally go with that one if i could just define (=<<) instead and not have to use flip
04:59:08 <sproingie> so is [a]
04:59:20 <sproingie> oh i see what you mean
04:59:23 <ksf> sproingie, lists give raise to multiple monads, yes.
04:59:36 <sproingie> well "list" is a convenience term
04:59:42 <jmcarthur_work> lists use monads no more than they use monoids
04:59:54 <chocho> i really want to make a game with haskell
05:00:00 <jmcarthur_work> chocho, me too :)
05:00:00 <sproingie> me too
05:00:05 <jmcarthur_work> heh
05:00:09 <aavogt> chocho: look at all the functions defined in Control.Monad
05:00:22 <jmcarthur_work> i'm working on one, but i am stubbornly working on FRP first
05:00:25 <sproingie> i'm aiming to write Dwarf Fortress in haskell.  that's not ambitious or anything, is it? ;)
05:00:26 <chocho> i work mainly in C++ and I hate hate HATE all the stateful mutation going on
05:00:35 <sproingie> (actually aiming for something a lot simpler to start)
05:00:44 <chocho> i would say that almost all bugs in my programs hide inside the imperative parts
05:01:00 <jmcarthur_work> i'm not aiming for anything simple. i have made games before. i just want to do it *right*, and to me that means FRP
05:01:15 <ksf> incidentally, I once tried out c++ and hated all those <> necessary to get past mutation.
05:01:16 <chocho> i figure if I can program more declaratively, the bugs will fall out automatically :D
05:01:24 <ksf> makes your source look like brainfuck.
05:01:28 <chocho> lol
05:01:29 <ksf> feels the same, too.
05:01:32 <emile_m> chocho: You can use what you've learned here in imperative land (like separating IO and "pure" functions).
05:01:54 <chocho> ya, that's my motivation for learning haskell - to write less shite C++ :)
05:01:58 <monochrom> I wonder how functional programming helps you avoid state bugs. For one, neither avoid off-by-1 errors.
05:02:11 <monochrom> You need formal methods to avoid state bugs.
05:02:15 <chocho> the bugs hide in the mutable state
05:02:20 <chocho> the shared state
05:02:25 <chocho> the implicit state
05:02:32 <ksf> fp sure as hell saves you from off-by-1 errors.
05:02:33 <chocho> the implicit parts in general
05:02:39 <EvanR-work> chocho: better idea, write less c++
05:02:41 <ksf> ...in the sense that usually, they just don't arise.
05:02:49 <monochrom> In functional programming you'll just pass parameters around carelessly and enjoy the same state bugs.
05:02:54 <chocho> I would if i could ;P
05:02:56 <Cale> monochrom: You can help avoid off-by-1 errors by using (and more importantly reusing) higher-order functions.
05:03:05 <GNU\colossus> hi all
05:03:07 <ksf> I noticed that as I, after being shielded from C for three years, did a binary lookup on a haskell array.
05:03:16 <ksf> I had 4 off-by one errors in 3 lines.
05:03:27 <ksf> I just wasn't used to it, anymore.
05:03:30 <emile_m> ksf: Am I right that C++ templates are nearly close to parametric polymorphism?
05:03:31 <idnar> heh
05:03:31 <sproingie> using maps and folds it's virtually impossible to have off-by-one errors
05:03:35 <chocho> all the bugs in my declarative code are easy to find and fix
05:03:39 <sproingie> emile_m: they are parametric polymorphism
05:03:49 <idnar> ksf: apparently fp doesn't help so much, then? ;)
05:04:10 <jmcarthur_work> yeah, i think a lot of the clunkiness in C is the insistence on using arrays for almost every collection simply because it's a language feature and using custom data structures is more of a pain
05:04:11 <chocho> the bugs in the imperative code usually don't reveal themselves until way after they are born
05:04:11 <Cale> emile_m: Pretty close, but C++ has a bad implementation of it.
05:04:15 <ksf> c++ templates are a turing-complete functional language limited to ints and types as parameters.
05:04:20 <chocho> making them hard to find and fix
05:04:21 <idnar> maps and folds let you avoid off-by-one /indexing/ errors
05:04:25 <emile_m> sproingie: By 100% semanthic mean?
05:04:35 <ksf> ...and only slightly worse syntax than say xslt.
05:04:37 <idnar> but off-by-one is really just tied to counting, I think
05:04:44 <chocho> I think of C++ templates as OO macros
05:04:50 <sproingie> i never use bare arrays in C++.  i use maps and folds in STL too, it's just a tremendous pain in the ass
05:04:55 <idnar> you can have an off-by-one error in a plain numeric calculation
05:04:55 <Cale> emile_m: C++ recompiles another copy of each template at each type where it's needed, so polymorphic recursion is impossible.
05:04:55 <chocho> (macros in the proper sense)
05:05:02 <jmcarthur_work> emile_m, templates can even do some things that we can't
05:05:04 <sproingie> mostly maps, there's hardly any way to abstract a proper fold
05:05:16 <idnar> eg. trying to calculate the number of days between two dates
05:05:19 <emile_m> jmcarthur_work: Like? :)
05:05:29 <jmcarthur_work> emile_m, integer parameterized types, for example
05:05:41 <chocho> STL's functional facilities are just so inadequate
05:05:43 <ksf> idnar, after doing the array lookup and noticing that it isn't at all faster than traversing a balanced binary tree, I just went straight ahead and wrote some TH to make code out of those trees.
05:05:51 <ksf> now _that_ was a performance boost.
05:05:58 <holmak> whenever i try to use HOFs in other languages, i miss sections :(
05:06:05 <chocho> hopefully they will improve with the introductions of lambdas in C++
05:06:14 <jmcarthur_work> emile_m, to be fair, we can do it to by reimplementing numerals on the type level, but it's clunky
05:06:14 <ksf> I can't even imagine the amount of pain necessary to do that in c/c++
05:06:21 <chocho> ya, sectioning is nasty even in C#
05:06:25 <jmcarthur_work> emile_m, although i suppose templates are generally clunky anyway
05:06:29 <sproingie> any additions to C++ will undoubtedly add more to the minefield
05:06:37 <chocho> well, not nasty, but not pretty :)
05:06:44 <sproingie> there's just so many gotchas in that language
05:06:46 <Cale> chocho: To be honest, I wish people would stop trying to rescue C++ ;)
05:07:01 <chocho> the problem is all the code we already have in C and C++
05:07:04 <emile_m> jmcarthur_work: But template args must be const at compile time. Isn't it a big limitation?
05:07:27 <chocho> plus, the choice on multiple platforms tends to be restricted to either java or C++
05:07:28 <Cale> Yeah, that is a problem, but adding to that code won't help.
05:07:29 <ksf> ghc with supercompilation and a c++ frontend will be faster than gcc.
05:07:34 <chocho> so screwed either way
05:07:40 <sproingie> java has more than its fair share of gotchas.  dear java: if you're not going to let me compare strings with ==, at least have the decency to warn me when i try it
05:07:48 <Cale> There are lots of languages available for more than one platform.
05:08:00 <chocho> well, there's also tooling
05:08:13 <chocho> because nowadays its all about tooling tooling tooling
05:08:16 * hackagebot upload: bindings-libusb 1.4.2 - Low level bindings to libusb. (BasVanDijk)
05:08:20 <chocho> which I can't argue with
05:08:30 <sproingie> tooling tooling tooling, keep them dogies tooling
05:08:49 <Cale> chocho: By which you mean things like IDE support?
05:09:14 <ben> Java strings overload +, but not ==?
05:09:25 <monochrom> Tooling is important for haskell too. Just that team sizes haven't grown large enough to be desperate for it.
05:09:30 <chocho> IDEs, profilers, on-device-debugging, all this little things that add up
05:09:38 <Cale> I kind of think that IDEs are mostly being used as crutches to prop up poorly designed languages. There are genuinely cool things that IDEs could do, but for the most part, they don't do those things.
05:10:01 <Millz> ben, yes
05:10:02 <Cale> Instead, they make up for the inability to express certain abstractions.
05:10:16 * hackagebot upload: usb 0.3 - Communicate with USB devices (BasVanDijk)
05:10:18 * hackagebot upload: usb-safe 0.1 - Wrapper around the usb package adding extra type-safety (BasVanDijk)
05:10:29 <chocho> isn't == on a java string ambiguous?
05:10:31 <jmcarthur_work> emile_m, the haskell compiler makes everything monomorphic at compile time too
05:10:33 * ksf never worked with strings in his java days, only with stringbuffers
05:10:35 <monochrom> If I have a recursive function and I want to rename it (nevermind callers of it, just change the definition alone), I want a tool to do it, I can't do it reliably myself.
05:10:44 <jmcarthur_work> emile_m, in the absence of rank-n types and such, anyway
05:10:47 <ksf> ...and didn't compare them, either.
05:10:48 <chocho> refactoring is quite an important tool
05:11:11 <Millz> chocho, it always checks pointer address for equaliuty
05:11:12 <Millz> not the value
05:11:18 <monochrom> And then of course there are the advanced refactoring such as "I have monadic code but it's just applicative, I now want applicative code"
05:11:24 <chocho> tools that allow the machine to transform your code based on a semantic understanding of it is quite powerful
05:11:38 <Cale> monochrom: If you have a recursive function which doesn't fit on the screen all at once, something is wrong.
05:11:42 <chocho> right, so overloading it would cause the usage to be ambiguous
05:11:58 <monochrom> It is not the screen.
05:12:01 <emile_m> jmcarthur_work: Those rank-n and impredicative types made me insane :( It's some sort of black magic...
05:12:05 <chocho> you'd want to overload .Equals instead
05:12:09 <chocho> which is ugly, but makes sense
05:12:13 <chocho> (in java)
05:12:16 <jmcarthur_work> emile_m, nah, you just have to get used to it
05:12:20 <monochrom> I have a 10-token recursive function and I still can't rename it reliably, OK?
05:12:30 <tensorpudding> 10 tokens??
05:12:37 <jmcarthur_work> o_O
05:12:47 <chocho> oh, one complaint about the haskell code I've been seeing
05:12:52 <Cale> monochrom: really? You should get into practice :)
05:13:05 <chocho> why are people using one letter variable / parameter names all over their haskell?
05:13:16 <aavogt> because the scope is so samll sometimes
05:13:35 <chocho> even C++ programmers know that names should be expressive / self- documenting
05:13:36 <jmcarthur_work> chocho, because it usually either unambiguous what it means from the type or because it could mean so many different things (due to polymorphism) that a meaningful name is impossible
05:13:47 <tensorpudding> it's a holdover from mathematical notation sometimes
05:14:01 <chocho> jmcarthur, are you sure you're not just thinking hard enough?
05:14:15 <jmcarthur_work> chocho, would should be the same of the elements of [a]?
05:14:17 <chocho> there is likely a name at any level of abstraction
05:14:20 <jmcarthur_work> *the name
05:14:30 <Cale> chocho: It's because many variables in Haskell do not mean anything.
05:14:34 <emile_m> @t map
05:14:35 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:14:41 <emile_m> @type map
05:14:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:14:46 <roconnor> @src map
05:14:47 <lambdabot> map _ []     = []
05:14:47 <Cale> chocho: They are so polymorphic that there's no point in naming them anything complicated.
05:14:47 <lambdabot> map f (x:xs) = f x : map f xs
05:14:56 <emile_m> what is a and b? I don't know :)
05:15:03 <chocho> hmm
05:15:12 <Cale> chocho: and they're short-lived. Names should grow along with their scope.
05:15:16 <tensorpudding> map has f, which immediately implies that it is a function of some kind
05:15:25 <tensorpudding> would it be helpful to call it fun or something?
05:15:29 <chocho> why not call is function instead of f?
05:15:29 <Cale> (and shrink along with their number of uses)
05:15:30 <tensorpudding> or func
05:15:37 <jmcarthur_work> chocho, why call it function?
05:15:40 <Cale> chocho: Because that doesn't add anything.
05:15:46 <Cale> chocho: Except more typing.
05:15:48 <chocho> because function says 'function'
05:15:57 <chocho> it's a matter of explicitness
05:15:58 <jmcarthur_work> chocho, so does f ;)
05:16:04 <chocho> no, f says f
05:16:07 <tensorpudding> and matching the list to (x:xs) is pretty much the de facto way of pattern-matching lists it seems
05:16:10 <jmcarthur_work> chocho, what else could f be but a function?
05:16:13 <roconnor> chocho: that's like calling a loop variable index instead of i
05:16:16 <chocho> frank
05:16:30 <jmcarthur_work> chocho, f x -- f must be a function
05:16:33 <Cale> map theFunctionToApply (theFirstElementOfTheList : theRemainderOfTheList) = theFunctionToApply theFirstElementOfTheList : map theFunctionToApply theRemainderOfTheList
05:16:34 <emile_m> chocho: Usually, f for function, xs for list of x, and so on...
05:16:38 <Cale> ^^ that is not any clearer
05:16:51 <Cale> (unless you are completely unfamiliar with Haskell syntax)
05:16:56 <chocho> Cale, that's just a strawman :)
05:17:05 <jmcarthur_work> map function (element:otherElements) = function element : map function otherElements
05:17:13 <Cale> Well, I'm just stretching things a little further in the same direction
05:17:14 <tensorpudding> map function (first:rest) = function first : (map function rest)
05:17:15 <jmcarthur_work> i think the above is more what you are proposing, and i think it's a bit silly
05:17:30 <jmcarthur_work> none of those are as readable as the short version
05:17:32 <jmcarthur_work> to me
05:17:35 <Kim^Walkman> I believe haskell don't need the explicitly named parameters because of the type system
05:17:36 <Cale> It actually seems clearest to me when the names are short.
05:17:39 <roconnor> I think that shorter names can help with equational reasoning
05:17:40 <tensorpudding> that is a medium between Cale's exaggerated example, and the standard definition
05:17:50 <ksf> chocho, f,g and h are functions, x, y and z are values, a, b, and c are types, and adding an s pluralizes.
05:17:58 <jmcarthur_work> tensorpudding, if there is one i don't think your version is it
05:17:59 <Kim^Walkman> You look at the types to understand what parameters are, you look at the source to find out what they're used in
05:18:06 <roconnor> and equational reasoning is not something that you can readily do in imperitive langauges.
05:18:11 <chocho> i suppose, but it's a problem for newbers
05:18:20 <ksf> like f . g x = f (g x)
05:18:23 <ksf> @src (.)
05:18:23 <tensorpudding> yes, mine is probably not explicit enough
05:18:23 <lambdabot> (f . g) x = f (g x)
05:18:24 <chocho> because you have to build a map in your head before reading code
05:18:30 <ksf> well nearly.
05:18:34 <chocho> there's an implicit mapping
05:18:43 <jmcarthur_work> chocho, what does f "map" to?
05:18:43 <Cale> chocho: There's the problem that for example, x could be *absolutely anything* here.
05:18:45 <emile_m> It's like in math books.
05:18:48 <Philonous> I think speaking names are important when you want to denote a particular thing, like, say, the function that updates the screen. But when you are talking about any function _at all_, calling a function a function doesn't add anything you couldn't already get from the context.
05:18:49 <jmcarthur_work> it's just a function called f
05:18:52 <osaunders> n is number
05:18:53 <chocho> f maps to function :)
05:18:54 <Cale> chocho: and f is any function at all, and xs is any list at all
05:19:04 <jmcarthur_work> chocho, and that is clear from context: f x
05:19:12 <tensorpudding> function is a long word
05:19:13 <Cale> chocho: Well, you know that f is a function because of the type signature
05:19:14 <emile_m> They do'n name functions thisIsTheFunctionThatSquares
05:19:24 <tensorpudding> and the type signature is very suggestive that f is a function
05:19:25 <Cale> chocho: Also, because it's applied to a value
05:19:25 <ben> Maybe they should
05:19:29 <holmak> the f, g, xs conventions are quite uniform, too
05:19:40 <chocho> deriving the truth from an implicit context introduces indirection
05:19:41 <roconnor> @src zipWith
05:19:42 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:19:42 <lambdabot> zipWith _ _      _      = []
05:19:42 <tensorpudding> not to mention that f,g are used as function identifiers in math
05:19:43 <monochrom> Yes, meaningful names are only meaningful when it has a lot of users.
05:19:47 <chocho> and that comes with a price :)
05:19:58 <ksf> I'd use xs and ys there
05:20:06 <chocho> namely, learnability and, I'd argue, readability
05:20:16 <Philonous> Do you call your variables "variable"? What would that add?
05:20:16 <Cale> ah, zipWith is a good example
05:20:21 <jmcarthur_work> chocho, i think long names, at least in haskell, make it hard to see the forest but for the trees
05:20:26 <ksf> x has type a, y b and z c.
05:20:28 <osaunders> ksf: me too
05:20:32 <tensorpudding> using x,y vs. a,b is a personal preference
05:20:34 <chocho> but, I don't think I understand haskell enough to critique
05:20:38 <jmcarthur_work> i can't see the structure of the above verbose definitions of map whatsoever
05:20:53 <ben> What do you do if you need more than three lists? xs, ys, zs,...?
05:21:04 <Cale> zipWith function (firstHead:firstTail) (secondHead:secondTail) = function firstHead secondHead : zipWith function firstTail secondTail
05:21:06 <Kim^Walkman> ås!
05:21:08 <roconnor> jmcarthur_work: I think this is an aspect of equational reasoning.
05:21:10 <monochrom> "map" is a meaningful expressive whatever name.
05:21:12 <jmcarthur_work> but i can tell at a glance what (map f (x:xs) = f x : map f xs) means
05:21:13 <ben> @src zipWith3
05:21:13 <lambdabot> Source not found. My pet ferret can type better than you!
05:21:15 <tensorpudding> ben: you don't use x,y,z if you have more than 3, i suppose
05:21:19 <Cale> ^^ that's already getting hard to read, and I'm not even being ridiculous about the names ;)
05:21:33 <benmachine> as, bs, cs, ds
05:21:35 <chocho> jmcarthur, sure, YOU can - but you have the map built in your head
05:21:37 <benmachine> or, pointfree
05:21:46 <ben> Is a list of functions always fs?
05:21:47 <chocho> alot of people can easily read machine code
05:21:47 <ksf> benmachine, l0, l1, l2, l3, l4
05:21:48 <emile_m> chocho: Often having just finction name and it's signature can tell you more than the whole function defenition in, for ex., Java.
05:21:57 <jmcarthur_work> chocho, i can see from the use and from convention what each identifier means
05:21:59 <tensorpudding> pointfree style is a good way to confuse people a lot of the time
05:22:03 <jmcarthur_work> chocho, and they mean... not much :)
05:22:13 <kosmikus> sproingie: (LambdaHack patch) yes please
05:22:20 <ben> The zips as shown by Hoogle do not even use f for the function :]
05:22:20 <ksf> er s/benmachine/ben
05:22:32 <roconnor> emile_m: it's not unusual for a signature to tell you everything about the function.  :D
05:22:36 <jmcarthur_work> chocho, this is not something i do as explicitly as you make it sound
05:22:42 <chocho> anywho, just wondering what the origins of such short names are
05:22:51 <roconnor> chocho: math
05:22:57 <jmcarthur_work> genericity
05:23:10 <ksf> C programming, also.
05:23:24 <ksf> I've never seen code that goes for( index = 0; ...)
05:23:32 <chocho> math is below the level of the problem's abstraction
05:23:33 <Cale> chocho: The whole point here is that map is doing a structural transformation where the only reasonable longer names would repeat information which is already explicit in the structure of the code
05:23:37 <ksf> the longest variable used in loops is rp.
05:23:41 <jmcarthur_work> chocho, why would you say that?
05:23:44 <osaunders> i,j,k for counters in C.
05:23:58 <jmcarthur_work> chocho, every good abstraction is mathematical in nature
05:24:04 <monochrom> "map" is longer than "ls". Not short name.
05:24:10 <ben> C uses i,j,k for counters to honor Dijkstra, that is not comparable.
05:24:12 <ksf> also bad abstractions are mathematical.
05:24:13 <roconnor> chocho: math is not below the level of the problem's abstraction for the functions that use these short names.
05:24:19 <ksf> usually more complex maths, though.
05:24:23 <medfly> ben, not to honour quaternions?
05:24:36 <chocho> ah, maybe roconnor explains it in a way I understand
05:24:51 <Philonous> Secretly, most haskell programmers just use an editor that obfuscate the code for the intellectual challenge.
05:24:57 <Cale> heh
05:24:59 <monochrom> In "map f xs", map is already the meaningful name. If you pick on "f" "xs", you are barking up the wrong tree.
05:25:06 <chocho> if a function is at the level of a purely mathematical abstraction, the names should match those we find in math
05:25:14 <Cale> f and xs here have a scope of *one line*
05:25:22 <chocho> but, on the other hand
05:25:31 <tensorpudding> the whole map versus fmap thing is kinda meh
05:25:39 <ben> monochrom: If map is already meaningful for you, you are not going to read its source anyway
05:25:45 <Cale> Long variable names are only important when the point of binding moves far away from the point of use
05:26:01 <sproingie> kosmikus: the whole module is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13834
05:26:06 <chocho> where a function goes above that level of abstraction (such as at the level of the business domain), the names should be more descritpive
05:26:09 <jmcarthur_work> Cale, is there a name for that rule of thumb?
05:26:20 <joe____> averageExpected :: Test
05:26:22 <Cale> jmcarthur_work: I don't know. It's just a personal observation on my part.
05:26:22 <sproingie> kosmikus: i tweaked a lot of the code for readability
05:26:26 <monochrom> If you look at other communities, all they do is "map laFunction daList" which is pretended meaningful, not real meaningful. "object" in "object obfuscation pomposity" is not meaningful either.
05:26:28 <BONUS> it mine as well be Cale's Law now
05:26:28 <joe____> averageExpected = TestCase ( assertEqual "should get averaged number from list" (average xs) (average xs))
05:26:40 <joe____> can I change the above function to :
05:26:41 <roconnor> chocho: I think they do.
05:26:49 <ksf> chocho, exactly. and map f xs doesn't become wrong just because you happen to use it in a financial package.
05:26:56 <joe____>  averageExpected = do .. TestCase ( assertEqual "should get averaged number from list" (average xs) (average xs))
05:27:02 <osaunders> Cale: Yeah I've noticed that rule too.
05:27:02 <jmcarthur_work> chocho, you will find that in haskell we often extend the mathy parts to far higher abstractions than on most other languages
05:27:07 <chocho> okay, I understand now
05:27:21 <benmachine> caleslaw?
05:27:33 <Cale> benmachine: ahaha
05:27:38 <chocho> but this being the case, I reserve the right to bitch about meaningless variable names in the latter case
05:27:45 * ksf still wants to have ifM c a p = if p then c else a in the standard libs
05:27:45 <tensorpudding> does it really matter so much what identifiers are used in a function definition? so long as the function name is clear, and it has a type signature
05:29:35 <jmcarthur_work> chocho, there is, of course, always some level where the business logic becomes dominant, but ideally that is just using very generic functions to make a few not so gene
05:32:46 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
05:32:46 --- topic: set by Saizan on [Wed Dec 02 21:02:12 2009]
05:33:05 <reforged> but the x would need to be a different value, right
05:33:12 <tombee> If I have a list of tuples (x,w) and I want to return x_1*w_1 + x_2*w_2 + ... x_n*w_n
05:33:16 <tombee> How would I do this?
05:33:37 <osaunders> tombee: pattern match?
05:33:42 <sproingie> let val = f x ...
05:33:45 <Philonous> reforged: different from what?
05:33:54 <tombee> weightedSum [x] = (fst x) * (snd x)
05:33:54 <tombee> weightedSum (x:xs) = (weightedSum x) + (weightedSum xs)
05:33:59 <tombee> was my attempt osaunders  :s
05:34:06 <reforged> Philonous: if i knew they were integers I could just do x+1, but they could also be Chars or something
05:34:15 <osaunders> tombee: otherwise you can't do it
05:34:32 <emile_m> @type gfoldl
05:34:33 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
05:34:40 <osaunders> You can't explode tuples of 20 length, say, by any means other than pattern matching.
05:35:04 <emile_m> jmcarthur_work: this is it.
05:35:06 <tensorpudding> why would you ever need to make a 20-tuple
05:35:06 <osaunders> It bothers me too.
05:35:11 <Philonous> reforged: Why, no, you can't just arbitrarily change the values. What you are doing is apply f to x, check if this is the same as x, if yes, rejoice, if not, start again, but with x replaced by f x
05:35:23 <osaunders> tensorpudding: Same reason you might want a list of 20 items.
05:35:27 <jmcarthur_work> emile_m, oh is this syb stuff?
05:35:37 <tensorpudding> couldn't you use a record type for that
05:35:38 <tombee> osaunders: can you point me to where I went wrong in my attempt?
05:35:40 <emile_m> jmcarthur_work: Yep.
05:35:48 <chocho> out of curiousity, what does the haskell community think of Erik Meijer's efforts?
05:35:49 <jmcarthur_work> i never actually used it in real code
05:36:05 <jmcarthur_work> chocho, i think most approve. i have not seen them
05:36:12 <osaunders> tombee: Basically you're using tuples where you should be using lists.
05:36:18 <emile_m> Something like "fold anythig you want".
05:36:19 <chocho> i really man-love erik
05:36:25 <Jedai> osaunders: then why not use a list of 20 items ? If you really need an heterogenous list, you can use HList
05:36:31 <tensorpudding> data MyBigList = MyBigList { firstItem::Int; secondItem::Bool, etc. }
05:36:32 <Philonous> reforged: Of course this method isn't guaranteed to actually find the fixed point, it could just keep running ad infinitum, but that's what the descriptions asks you to do
05:36:38 <chocho> like a man loves another man - not in a gay way
05:36:45 <chocho> but in a man way
05:36:54 <tensorpudding> so you're saying that gay men aren't men?
05:36:54 <osaunders> tombee: I think. Post a pastie of your code if you like.
05:36:58 <Jedai> tombee: the type of the first term of your addition is wrong
05:37:14 <chocho> well, a manly man way
05:37:15 <monochrm> You can design a record of 20 fields. With field names, the fields are more manageable.
05:37:22 <tensorpudding> so gay men aren't manly men?
05:37:25 <osaunders> Jedai: What's HList?
05:37:25 <Jedai> weightedSum takes a list and you're giving it a pair
05:37:33 <chocho> i would think
05:37:42 <chocho> i am open to counter opinions tho
05:37:44 <reforged> Philonous: ok, thanks, I don't know why i did not have the idea myself
05:37:47 <tensorpudding> yes, what monochrm said, records with 20 fiels
05:38:02 <Jedai> osaunders: look it up on Hackage
05:38:06 <tombee> Jedai: hmm have I missed [] or something? :s
05:38:14 <tensorpudding> there is nothing different from gay men to other men, except for sexual preference
05:38:16 <Jedai> osaunders: it's an heterogenous list package, with a lot of strange faculty
05:38:19 <tensorpudding> is sexual preference what makes men manly?
05:38:22 <Jedai> tombee: You have
05:38:47 <monochrm> He means brotherly love not romantic love.
05:38:52 <osaunders> Why are we talking about sexuality and manliness?
05:38:55 <Jedai> tombee: though I wouldn't do it like you did, to be honest, I would just use (+), curry, map and sum
05:39:14 <tensorpudding> i figured so
05:39:17 <tombee> I was thinking of mapping, creating a list them summing
05:39:20 <chocho> osaunders, just to see what happens I spose
05:39:21 <tombee> but i thought that would have been a longer way
05:39:23 <tensorpudding> but that's not really "manly love"
05:39:24 <Jedai> weightedSum (x:xs) = (weightedSum [x]) + (weightedSum xs)
05:39:36 <monochrm> People need to speak clearly.
05:39:52 <tensorpudding> philia vs. eros
05:39:52 <Jedai> tombee: using explicit recursion is bad, in Haskell at least, it's bad style
05:39:53 <ksf> it becomes "manly" only if you contrast it with "sissy"
05:40:02 <tombee> Ok, thanks Jedai :)
05:40:06 <monochrm> All the obsession with meaningful names in code but not meaningful words in speech.
05:40:18 <Jedai> tombee: weightedSum = sum . map (uncurry (+))
05:40:37 * ksf doesnt' think explicit recursion is bad style.
05:40:38 <osaunders> Jedai: I'll recurse until I'm more confident with combinators.
05:40:39 <fritschy_> gnah... /me is doing some program to plot lots of lines with gnuplot (by writing a gnuplot script) - well, that same program is slower than an equivalent - not compiled! - python program... still can't figure out what's wrong with it... ;) i think that's what newbies have to go through anyway ;)
05:40:53 <osaunders> s/recurse/recurse sometimes
05:40:57 <tombee> I shall make a note of that, I'm unsure of how that works
05:41:03 <monochrm> Programmer. noun. A person who uses meaningful names in programming languages but not in natural languages.
05:41:05 <tombee> so shall leave it in my code, but commented out :)
05:41:07 <tensorpudding> explicit recursion isn't bad unless it is easily translated into a fold or something
05:41:14 <ksf> ...burying it a couple of lines inside the function is bad, though. always factor it to be as close to the initial = as possible.
05:41:31 <Jedai> tombee: this is the definition I would use, it's much better, it even works on an empty list, a case you forgot in your program
05:41:35 <ksf> multi-line functions are evil, though.
05:41:43 <ksf> wheres or lets are the way to go.
05:41:56 <tensorpudding> summing the elements of a list is clearly expressed using a fold
05:42:15 <ksf> summing the elements of a list is clearly expressed using sum.
05:42:17 <ksf> :t sum
05:42:17 <tombee> Finding haskell really difficult :(
05:42:18 <lambdabot> forall a. (Num a) => [a] -> a
05:42:29 <tensorpudding> @src sum
05:42:29 <lambdabot> sum = foldl (+) 0
05:42:30 <Jedai> tombee: oops I put a (+) instead of a (*)
05:42:33 <Philonous> reforged: Actually it even _does_ always find a fixed point, just somtimes it happens to be _|_
05:42:36 <Jedai> tombee: weightedSum = sum . map (uncurry (*))
05:42:41 <tombee> Hehe I noticed, thanks though :)
05:42:44 <tensorpudding> yes, there is a function for it, and that function is written using a fold
05:42:47 <copumpkin> tombee: most people do
05:42:47 * hackagebot upload: happstack-helpers 0.45 - Convenience functions for Happstack. (ThomasHartman)
05:43:13 <tombee> I've spent most of my last few days at work learning haskell :P
05:43:25 <ksf> I'm always facepalming when I see fac n = foldl (*) [1..n] as an introductory example. it's fac n = product [1..n]
05:43:25 <Jedai> tombee: uncurry (*) takes a pair and multiply its member, map apply it on every pair of your list, then sum makes the sum of the results
05:43:33 <BONUS> i find explicit recursion bad when it can be achieved using combinators, but i think its good to know how recursion works and to think recursively etc.
05:43:40 <medfly> tombee, what do you work at
05:43:43 <v_> Which one is to be avoided? foldr or foldl?
05:43:43 <ksf> :t uncurry (*)
05:43:44 <lambdabot> forall a. (Num a) => (a, a) -> a
05:43:48 <tensorpudding> haskell is kinda like fundamentalist functional programming
05:43:51 <tombee> I probably shouldn't say medfly  ;)
05:43:57 <medfly> tombee, no like field
05:43:58 <monochrm> Oh, foldl (*) [1..n] is even invalid in types
05:43:58 <ksf> v_, it depends.
05:44:12 <tombee> I'm just a software developer
05:44:18 <tensorpudding> you forgot the initial element there monochrm
05:44:19 <emile_m> ksf: I think it is good example on fold nature.
05:44:26 <Jedai> v_: foldl is generally a bad choice, you want foldr or foldl' depending on your needs, but probably not foldl
05:44:28 <tombee> C# and Java
05:44:31 <Philonous> ksf: I see why, \n -> foldl (*) [1..n] doesn't even work ;)
05:44:45 <v_> <<Once you get comfortable with lists (and you will, quickly), favor the foldr function over foldl to avoid "space leaking".>>
05:44:54 <tensorpudding> lazy left folds are not that useful
05:44:57 <monochrm> tensorpudding: I just copied ksf's.
05:44:58 <v_> Jedai: k
05:45:10 <ksf> monochrm, yes, the unit element is missing.
05:45:23 <ksf> another reason to use product and sum instead of folds.
05:45:45 <monochrm> People just make judgements on me without reading the context. Why is reading so hard?
05:45:48 <Jedai> v_: that's not always true, only when the function is lazy in its second argument
05:45:57 <tombee> Jedai: so uncurry (*) will take (a,b) and split it so that we have (a * b)
05:46:30 <monochrm> Please next time when I say just "Yes." pick on me and ask me "monochrom: yes to what?"
05:46:35 <Jedai> tombee: uncurry takes a function with two arguments and transform it so it takes a pair of its arguments instead
05:46:44 <ksf> monochrm, netsplits all over the place, no incentive to scroll up if one can equally well just diss you.
05:47:06 <chocho> lol
05:47:08 <Jedai> tombee: (*) is the prefix (normal function) form of the operator *, which takes two arguments, so... ^^
05:47:14 <monochrm> It was way before netsplit.
05:47:48 <v_> ah, damn
05:47:49 <ksf> well, then there someone has been INSENSITIVE on the internet.
05:47:57 <v_> erver is currently split, channel modes are limited
05:47:58 <tensorpudding> *gasp*
05:48:03 <chocho> I find that the lines of code in C++ projects grow nearly linearly as time passes
05:48:04 <v_> Now there's a first
05:48:04 <ksf> that's even worse than being wrong.
05:48:12 <tombee> gotcha Jedai, that makes sense
05:48:13 <chocho> is this less true in haskell?
05:48:23 <Jedai> tombee: basically, as you said "uncurry (*) (x,y)" == "x * y"
05:48:33 <mkaemmer> ksf: sometimes, people are even CaSeInSenSiTiVe on the internet :(
05:48:39 <ksf> chocho, you tend to add functionality, clean up, and be left with 80% of the lines you had before.
05:48:41 <chocho> it would seem to me that haskell's abstraction facilities would put a cap on source code growth
05:48:46 <tensorpudding> camelCase!
05:49:02 <v_> I guess that people see that languages like Haskell/Erlang are awesome after porting an app from C/C++/Java/etc. to Haskell/Erlang/etc.
05:49:05 <tensorpudding> which has no relation to perl or ocaml
05:49:12 <monochrm> hackage repo grows linearly with time
05:49:44 <Jedai> chocho: it's more chaotic I would say, since Haskell is better at abstraction, it happens pretty often that you stumble unto a way better abstraction that reduce your code instead
05:50:11 <tombee> Haskell makes me sit here and think 'what the hell'...
05:50:16 <Jedai> chocho: still not the majority of case, of course the size of the code tend to grow over time :)
05:50:16 <ksf> terseness grows linearely, functionality grows exponentially, so you get a constant amount of code to do infinite amount of stuff.
05:50:16 <chocho> I find the more i use C++, the more I hate code itself
05:50:18 <tombee> puts the fun back into programming I guess
05:50:26 <reforged> Philonous: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13835#a13837 this is what you meant right?
05:50:26 <v_> Learning Haskell by wtfs/min
05:50:35 <chocho> code has become my enemy
05:50:37 <tensorpudding> haskell has a lot of wtfs
05:50:43 <v_> Puts the funk into functional programming
05:50:49 <Botje> learning haskell by counting broken skulls
05:51:05 <v_> If you're a newbie combing from an Algol-family language Haskell can melt your brain
05:51:12 <ksf> no, it doest'n. c++ has wtfs. haskell has zomfg's.
05:51:28 <v_> C++ is a pitfall-based language haha
05:51:37 <tensorpudding> people hear about functional programming from their other languages, think it's pretty cool, so they try out haskell
05:51:41 <tombee> Jedai: how does it work because there's no parameters for that function?
05:51:49 <chocho> pitfall-oriented programming
05:51:54 <v_> POP
05:51:59 <tensorpudding> like jumping from laudanum to heroin
05:52:05 <ksf> @remember v_ C++ is a pitfall-based language
05:52:06 <lambdabot> Okay.
05:52:13 <ksf> wanna see that in the next hwn
05:52:42 <tensorpudding> if C++ is pitfall-based, where are the swinging vines and alligators?
05:52:53 * monochrm wonders what reforged is taught about fixed points. This exercise could be trivial or impossible depending on how much you are taught.
05:52:54 <Jedai> tombee: (.) is an operator, it's function composition, in other words :
05:52:54 <Jedai> @src (.)
05:52:55 <v_> They're there
05:52:55 <lambdabot> (f . g) x = f (g x)
05:53:04 <Jedai> tombee: ^^
05:53:12 <tombee> Gotcha
05:53:12 <byorgey> tensorpudding: swinging vines = template metaprogramming, perhaps?
05:53:19 <mkaemmer> class alligator { ... }?
05:53:21 <tensorpudding> i think i've seen enough rolling barrels in C++ though
05:53:39 <v_> All those bastardized concepts that give you a mindfuck in C++ are already in Haskell.
05:53:59 <v_> So to speak
05:54:03 <mauke> v_: what, like name resolution?
05:54:06 <reforged> monochrm: we are doing higher order functions right now, never heard about fized points before, precisely we are @ lecture #7
05:54:18 <v_> Like... generic programming
05:54:30 <v_> Meta-programming
05:54:35 <Jedai> tombee: it's common practice in Haskell to construct new functions just by composing functions and using combinators without ever giving a name to the parameters. It's called pointfree style, and while awesome you can easily do it too much and ends up using "pointless" style
05:54:36 <tensorpudding> is generic programming a mindfuck?
05:54:42 <mauke> meta-programming isn't a mindfuck
05:54:44 <v_> It depends
05:54:49 * fracture wishes Haskell had a tad better support for generic programming.
05:54:56 <monochrm> Then it is very hard.
05:55:00 <v_> Used a strong adj there
05:55:13 * ksf wishes ghc would supercompile so he wouldn't have to metaprogram.
05:55:25 <byorgey> Note, there are two different things called "generic programming" in different communities!
05:55:32 <tombee> hum I see, Jedai the reason I ask is the next step is to add another parameter to that sum
05:55:36 <monochrm> Even if I give a solution, it is not obvious why it is valid.
05:55:37 <v_> meh @  std::transform(begin, end, result, func)
05:55:39 <byorgey> what some call "generic programming" Haskell calls "polymorphism"
05:55:44 <tombee> so I have to define the parameters I guess!
05:55:52 <Jedai> fracture: Well there's interesting library though we probably don't know _the answer_ yet
05:55:55 <Jedai> tombee: probably
05:55:56 <byorgey> what Haskellites call "generic programming" is something else
05:56:08 <tensorpudding> what OO calls polymorphism, haskell doesn't really have
05:56:14 <ksf> yep. don't start below syb.
05:56:20 <chocho> i love the idea of metaprogramming, ableit not with C++ templates
05:56:24 <fracture> byorgey: what do haskellites call "generic programming"?
05:56:32 <Jedai> tombee: you don't have to, but you'll get something more readable,  I think
05:56:33 <reforged> monochrm: That is not very helpful ;)
05:56:42 <fracture> Jedai: what are you talkin about?  template haskell or something?
05:56:48 <byorgey> fracture: writing functions which work generically for any data type, based on the "shape" of the type
05:57:05 <chocho> it seems to me that a language ought to expose the constructs a programmers needs to derive his own abstraction facilities.
05:57:15 <fracture> byorgey: oh... that's what C++ people call "generic programming" also (or... part of what they mean by it)
05:57:33 <byorgey> fracture: is it? OK.
05:57:39 <tensorpudding> isn't that what haskell does?
05:57:40 <Jedai> fracture: ok, maybe we're not speaking of the same thing, go see Uniplate for some examples
05:57:43 <ezyang> @remember pumpkin "roconnor would have strangled me if I had given any more information than a Maybe."
05:57:43 <lambdabot> Done.
05:57:44 <monochrm> Well there is no harm to give it. One version (not the most efficient): fix f = f (fix f).  But you need some math to prove it is correct.
05:57:44 <fracture> well, there's also the ability to make new types based on other types
05:57:47 <chocho> it's not enought for a language to provide abstraction facilities.
05:57:56 <byorgey> I was thinking of Java where "generics" just means polymorphism.
05:58:03 <chocho> it has to provide abstraction facility facilities :)
05:58:14 <chocho> as to whether or not haskell provides this -
05:58:17 <tensorpudding> meta++
05:58:20 <fracture> byorgey: C++ templates are worlds more general than java generics
05:58:27 <byorgey> fracture: yes, I'm aware of that =)
05:58:28 <chocho> i don't know enough about haskell to know :)
05:58:57 <chocho> the fact that you can define your own control flow structure with haskell seems evidence that it does
05:59:04 <chocho> at least in part
05:59:09 <Jedai> fracture: Yep, they're a Turing complete functional language ! (I'll let you determine if that's really a good thing)
05:59:09 <chocho> (plz correct me if I'm wrong)
05:59:19 <v_> Guy Steele and Gerald Sussman create Scheme. Their work leads to a series of "Lambda the Ultimate" papers culminating in "Lambda the Ultimate Kitchen Utensil." This paper becomes the basis for a long running, but ultimately unsuccessful run of late night infomercials. Lambdas are relegated to relative obscurity until Java makes them popular by not having them.
05:59:30 <v_> Always cracks me up
05:59:35 <mkaemmer> monochrm: that's certainly one way to define fix... although it defeats the motivation for having it in the first place (if you define it that way, you already have named functions)
05:59:35 <chocho> v_, lol
05:59:43 <v_> Yeah, http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
06:00:10 <v_> Yay @ C++ concepts and Java lambdas or whatever.
06:00:19 <fracture> Jedai: yeah uniplate looks like something else...
06:00:29 <tombee> Jedai: weightedSums = (+) . sum . map (uncurry (*))
06:00:34 <tombee> so how would I make that more readable? :)
06:00:43 <tombee> by adding the parameters
06:00:48 <reforged> monochrm: that gives me "C stack overflow" sometimes
06:01:19 <Jedai> @type (+) . sum . map (uncurry (*))
06:01:21 <lambdabot> forall a. (Num a) => [(a, a)] -> a -> a
06:01:27 <ksf> duh.
06:01:30 <tombee> yep I have the type ;)
06:01:31 <tombee> :)
06:01:32 <fracture> http://www.haskell.org/haskellwiki/Template_Haskell#Examples  <-- more like this sort of thing :)
06:01:48 <monochrm> A more efficient version, saves both memory and time by reuse/sharing: fix f = let x = f x in x
06:01:55 <ksf> there I am, wondering how to generate html server-side, while it should be obvious: in the same way as on the client.
06:01:55 <Jedai> tombee: yeah, put the parameter back in
06:01:58 <ksf> which means, DOM.
06:02:08 <tombee> I'm not sure how though :(
06:02:12 <tombee> I get type errors when I do Jedai
06:02:35 <ksf> in that way, server-side generation can be seen as a fall-back degenerate case of the client doing the displaying.
06:03:22 <Jedai> weightedSums xs y = sum (map (uncurry (*)) xs) + y
06:03:22 <Jedai> tombee: that ^^
06:03:41 <reforged> monochrm: well, thanks for your help, i will ask my instructor what they meant. you were very helpful :)
06:03:49 <tombee> ah, possible to do it with the function compositions still there Jedai ?
06:04:05 <tombee> is (.) preferred? as I feel it seems a bit 'strange'
06:04:10 <monochrm> The instructor should be shot.
06:04:46 <jmcarthur_work> @pl weightedSums xs y = sum (map (uncurry (*)) xs) + y
06:04:47 <lambdabot> weightedSums = (+) . sum . map (uncurry (*))
06:05:02 <tombee> haha
06:05:15 <Jedai> tombee: depends on what you want, (.) has a lot of advantages when you have long pipeline of function (very easy to refactor), but you should strive to be readable
06:05:22 <joe____> i am having trouble with the "run" function definition at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13838#a13838
06:05:30 <jmcarthur_work> i usually prefer (.)
06:05:34 <mkaemmer> is anyone familiar with OpenAL or Hsndfile?
06:05:50 <joe____> the function "run" returns nothing.
06:05:59 <joe____> ghci returns an error
06:06:10 <joe____>     `[]' is not applied to enough type arguments
06:06:29 <Jedai> tombee: it really depends on your taste (though with experience in Haskell your taste will evolve, you may come to prefer the pointfree version of your weightedSum)
06:06:57 <copumpkin> monochrm: did you get optimized for space?
06:07:06 <joe____> run :: [String] -> DeviceHandle -> []
06:07:23 <tombee> just need to motivate myself to keep learning Haskell, it's nice to have a community that is willing to help for a change :)
06:07:30 <monochrm> I think it is a result of flaky connection.
06:07:32 <tombee> don't often get that
06:07:32 <v_> How can I do this in a Haskell one-liner: "Which of the first 100 000 000 hexagonal numbers are divisible by all the numbers in the [2,20] interval?"
06:08:15 <v_> hexag n = [ n*(2*n-1)   | n <- [1..100000000]]
06:08:15 <Nafai> tombee: That's part of the reason I'm still "learning" haskell because of the great community here.  I think I would have given up otherwise since I have not yet mastered it
06:08:32 <Jedai> v_: well you need to generate the hexagonal number (don't remember how but it's easy with a scanl) and then you use find or head . filter
06:08:54 <jmcarthur_work> i have forgotten what it's like in other, lesser channels ;)
06:09:12 <tombee> It's pretty frustrating Nafai, as a lot of the problems I've had it's been totally unclear to where I've been going wrong.  Resulting to trial and error, then when I see the correction I'm miles off :p
06:09:21 <chocho> is it an accurate generalization that programming haskell is merely telling the haskell compiler the explicit equational truth then having it tell you any particular truth thereby implied?
06:09:31 <v_> > product[1..20]
06:09:33 <lambdabot>   2432902008176640000
06:09:35 <chocho> i have so far seen haskell as prolog with equations
06:09:39 <Jedai> v_: divisibility is easy to test, with all()
06:09:39 <v_> Ok... And now some:
06:09:44 <v_> Ah, k
06:09:53 <tombee> I'm hoping that I can get 'good enough' at haskell to complete my final year uni project in it :)
06:10:03 <jmcarthur_work> chocho, that sounds more like logic programming or something
06:10:13 <v_> Well, I'll drop the one-liner part. I just want to make it fast
06:10:22 <chocho> ya, like logic programming but with equations
06:10:45 <Berengal> chocho: Haskell doesn't do any backtracking
06:10:50 <jmcarthur_work> chocho, i would say that is not accurate
06:10:51 <Jedai> chocho: Well Haskell don't have unification (not generally, just patterns) so it's not really accurate
06:10:59 <chocho> ah hm
06:11:05 <Berengal> It's better to think of it as a rewrite system
06:11:07 <Jedai> chocho: though you can backtrack with monads
06:11:20 <Berengal> Where constructors are terminals, and functions are productions
06:11:29 <chocho> by rewrite, you mean expansion?
06:11:33 <Jedai> chocho: if you want to see more of mix of functional and logic style, you should look at curry
06:11:48 <Berengal> chocho: Well, it doesn't have to expand, but sure
06:11:58 <v_> "The Algebra of Programming" is one interesting book
06:12:05 <v_> It's Haskell-ish
06:12:12 <jmcarthur_work> v_, too bad it's out of print and costs an arm and a leg
06:12:23 <v_> Eh, I have it in electronic format
06:12:28 <chocho> i'll put up the arm if you put up the leg
06:12:53 <monochrom> Heh I bought my copy while it lasted. :)
06:12:59 <v_> *Gopher-ish, to be exact
06:13:13 <Jedai> v_: to make it fast, there's probably no substitute to think about the hexagonal numbers structure a little bit, doing 100000000 tests doesn't sound so attractive
06:13:26 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml
06:13:30 <chocho> so if haskell is based on rewriting, then it sounds like macros to me
06:13:34 <v_> Nah, I'll have to optimise that part
06:13:42 <chocho> is this an innaccurate way to think about it?
06:13:49 <jmcarthur_work> i have a $48 hardback copy of the algebra of programming in my amazon shopping cart?!
06:14:12 <monochrom> You have? $48? Go for it! Best price since sliced bread.
06:14:18 <v_> 1 new from $138.99
06:14:19 <jmcarthur_work> yeah seriously
06:14:23 <v_> Man, that's one expensive book
06:14:26 <jmcarthur_work> i don't think it was that price when i added it a long time ago
06:14:28 <v_> IT MUST BE GOOD!
06:14:32 <jmcarthur_work> v_, it used to be higher than that
06:14:35 <v_> And it really is
06:14:52 <v_> Well, it's cheaper to get the pdf and print it
06:15:09 <jmcarthur_work> hardback is nice though...
06:15:24 <jmcarthur_work> and there is obviously resale value if i can find a buyer ;)
06:15:38 <v_> Reading a book like that on ye laptop/PC is tiresome
06:16:02 <Jedai> chocho: maybe not too bad, but typed macros
06:16:04 <monochrom> Unless it comes with a proof IDE.
06:16:12 <jmcarthur_work> huh, $48 is the list price. how did i manage that?
06:16:48 <monochrom> If you read the book on computer, and it has a proof IDE, you can follow the proofs in the book interactively, experiment with your own approach...
06:17:05 <Jedai> chocho: and with sharing
06:17:33 <monochrom> I sometimes treat all programming languages as rewriting.
06:18:04 <v_> If you want rewriting, Maude is the name
06:18:10 <v_> Or ML...
06:18:42 <v_> Term Rewriting and All That is another good title
06:19:00 <Cale> Graph rewriting! :)
06:19:15 <ddarius> All programming languages aren't rewriting?
06:19:24 <monochrom> Haskell doesn't need very general graph rewriting, does it?
06:19:34 <Cale> Not *too* general
06:19:41 <mauke> http://catseye.tc/projects/tamerlane/doc/tamerlane.html
06:19:44 <Berengal> ddarius: It's a bit hard to model cells with just rewriting
06:19:49 <Cale> actually, you can do it with plain term rewriting, I think.
06:20:25 <Berengal> Cale: Even lambdas?
06:20:28 <v_> http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.jpg  btw
06:20:39 <v_> Interesting diagram
06:20:44 <monochrom> Rewriting is the best semantics since sliced bread. Seamless bridging to axiomatic-equational semantics
06:21:16 <ddarius> Berengal: Not really.
06:21:20 <monochrom> All those SOS things are premature optimizations IMO.
06:22:05 <ksf> but, but... oz feels quite procedural!
06:22:06 <Berengal> ddarius: It requires substituting one rewrite rule for another during execution. At least I think it does.
06:22:30 <v_> Heard things about Oz
06:22:46 <ksf> well it's the bread and butter of ctm.
06:22:48 <Cale> Berengal: What problem could there be with lambdas?
06:22:54 <ksf> a hell of a book
06:23:14 <ksf> http://www.info.ucl.ac.be/~pvr/book.html
06:23:15 <v_> What's ctm? Concurrent... ?
06:23:19 <v_> Something, something
06:23:20 <Cale> Berengal: Lambdas are just a simple term rewriting system, aren't they?
06:23:28 <Berengal> Cale: What would the rewrite rule for lambda look like?
06:23:28 <v_> Ah
06:23:36 <mauke> alpha, beta
06:23:38 <Spockz|lap> Is there a way to export all datatypes from a module, together with explicitly named functions? Instead of having to type all the datatypes too?
06:23:38 <v_> CTM is SICP 2
06:23:52 <ddarius> Concepts, Techniques, and Models of Computer Programming
06:24:04 <ksf> yep. but unlike scheme, noone uses oz.
06:24:12 <monochrom> So which is SICP 1?
06:24:16 <v_> And almost noone heard about Oz.
06:24:21 <monochrom> (Using SICP itself as 0)
06:24:28 <joe____> can u have an hunit test on a function with do?
06:24:43 <v_> Well, then ctm is SICP 1
06:25:12 <ksf> it's certainly sicp2 in the sense that it misses to give much or any advice on how to actually design a program or come up with an idea.
06:25:41 <v_> CTM is mentioned here too  http://www.indiangeek.net/wp-content/uploads/Programmer%20competency%20matrix.htm   at the book section
06:25:44 <v_> Heh
06:26:02 <v_> Concurrent (Erlang, Oz) and Logic (Prolog) is Level 3.
06:26:13 <v_> Haskell is level 2
06:26:17 <Cale> Berengal: as mauke said, just alpha and beta reduction.
06:26:21 <monochrom> Eh?! ghc 6.10.4 is still with parsec 2?
06:26:42 <ksf> even better, ghc 6.12 comes without parsec.
06:27:23 <ksf> there's a patch floating around that seems to fix parsec3s performance, though, so I guess migration isn't too far ahead.
06:27:39 <bear531> get windows keys for cheap http://bit.ly/5Tgz2X :)
06:27:50 <monochrom> I guess I don't mind either way.
06:27:57 <ksf> @where ops
06:27:58 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
06:28:00 <ksf> oh darn.
06:28:07 <v_> Too bad I don't use Windows
06:28:19 <Cale> ksf: I'm not sure if that's up to date or not
06:28:28 <monochrom> Actually I'm an op too. Is it a good idea that I am added to that list?
06:28:28 <Cale> ksf: But you can also ask chanserv :)
06:28:42 <ksf> too bad I still have a win2k disc that came with my father's hardware if I'd want to install one.
06:28:53 <monochrom> And there is another one I forgot, made op the same time as mine.
06:29:25 <ksf> Cale, I can't.
06:29:38 <monochrom> @help where
06:29:38 <lambdabot> where <key>. Return element associated with key
06:29:43 <v_> Spamming cheap Windows keys on #haskell. Smart move. That guy knows about Microsoft research
06:29:43 <ksf> and I don't feel like browsing freenode manuals right now.
06:30:22 <Philonous> reforged: That seems right, yes.
06:30:25 <ksf> there's at least where+
06:30:34 <monochrom> @help where+
06:30:34 <lambdabot> where+ <key> <elem>. Define an association
06:31:00 <monochrom> @where+ ops shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
06:31:00 <lambdabot> Okay.
06:31:08 <monochrom> @where ops
06:31:09 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
06:31:24 <monochrom> OK seems to work
06:31:32 <tensorpudding> oh boys, there are ops
06:31:43 <ksf> @flush
06:31:43 <lambdabot> Not enough privileges
06:31:46 <ksf> CAAAALE!
06:31:52 <mauke> @flush
06:31:52 <lambdabot> Not enough privileges
06:31:59 <v_> Eh
06:32:11 <TheHunter> @flush
06:32:53 <v_> > filter (>1)( scanl (/) (product [1..20]) [1000..1000000] )
06:32:55 <lambdabot>   [2.43290200817664e18,2.43290200817664e15,2.43047153664e12,2.425620296047904...
06:33:05 <v_> Meh, that doesn't look right
06:33:14 * ksf wonders why yhc doesnt' compile.
06:33:20 <ksf> it actually looks like bitrot.
06:33:28 <Cale> @flush
06:33:32 <tensorpudding> if it doesn't smell fresh, toss it out
06:34:01 <v_> Fresh curry
06:34:07 <ksf> well I'm interested in the javascript compiler.
06:34:19 <v_> I'm interested in running ghc on my Symbian
06:34:30 <v_> So much for that.
06:34:48 <v_> I heard that ghc runs on the iPhone...
06:35:16 <tensorpudding> iPhone is not Symbian...
06:35:24 <mauke> Cale: TOO LATE
06:35:27 <Berengal> I heard that ghc runs on solaris and SPARC...
06:35:28 <v_> But it's ARM
06:35:37 <v_> ARM is the keyword here
06:36:06 <v_> Too bad Symbian C++ is for masochists
06:36:59 <ksf> @hoogle makeRelativeToCurrentDirectory
06:37:00 <lambdabot> System.Directory makeRelativeToCurrentDirectory :: FilePath -> IO FilePath
06:37:06 <kmc_> C++ is for masochists
06:37:21 <v_> And the Symbian dialect is even worse. Imagine that
06:37:28 <v_> Also, Qt
06:38:52 <Veinor> http://www.youtube.com/watch?v=BQ9YtJC-Kd8
06:39:15 <copumpkin> だめ！
06:40:02 <RayNbow> copumpkin: 何で？
06:40:17 <cnwdup> @karma+ copumpkin
06:40:18 <lambdabot> copumpkin's karma raised to 4.
06:40:29 <mauke> using @karma+ is pointless
06:40:31 <v_> принадлежит всему сообществу
06:40:41 <mauke> lambdabot forgets, and no other bot recognizes it
06:40:52 <c_wraith> Wait, I thought @pl was pointless
06:41:17 <aavogt> @karma C
06:41:17 <lambdabot> C has a karma of 0
06:41:28 <copumpkin> RayNbow: オッフートピックだから
06:41:30 <copumpkin> ;)
06:41:47 <v_> Yeah, karma http://www.youtube.com/watch?v=k83MIqnH5Qc  to burn
06:41:57 <v_> @karma dons
06:41:58 <lambdabot> dons has a karma of 11
06:42:04 <v_> Nice
06:42:14 <c_wraith> 620 after a split?  how big is the channel right now? >_>
06:42:26 <v_> #haskell is huge
06:42:28 <lunabot>  luna: Not in scope: `haskell'
06:42:35 <v_> Heh
06:42:37 <aavogt> same for everybody this side of the split
06:42:47 <c_wraith> err, I meant pre-split
06:42:56 <c_wraith> and it looks like 650ish
06:42:57 <v_> #ml
06:42:58 <lunabot>  luna: Not in scope: `ml'
06:43:01 <c_wraith> that was a smaller split than I'm used to seeing
06:43:09 --- mode: ChanServ set +o mauke
06:43:09 --- mode: mauke set +vvv lambdabot preflex iblechbot
06:43:20 <v_> 00:40 -!- #haskell: Total of 620 nicks, 0 IRC operators, 2 channel operators, 4 voiced, 74 marked away
06:43:24 <v_> irssi is cool
06:43:25 <RayNbow> copumpkin: :p
06:43:48 <v_> I'd love to see an IRC client scriptable with haskell
06:44:00 <v_> Oh wait...
06:44:09 --- mode: mauke set -o mauke
06:44:23 <Spockz|lap> a lot of splits here lately
06:44:24 <v_> This looks good http://www.haskell.org/hircules/
06:44:28 <tommd> ?faq can Haskell IRC?
06:44:29 <lambdabot> The answer is: Yes! Haskell can do that.
06:44:38 <v_> But old
06:44:39 <Veinor> ?can haskell prove that P=NP?
06:44:40 <lambdabot> Maybe you meant: faq map run wn
06:44:44 <benmachine> I wrote a haskell IRC bot
06:44:46 <Veinor> ?faq can haskell prove that P=NP?
06:44:47 <lambdabot> The answer is: Yes! Haskell can do that.
06:44:50 <Veinor> :O
06:44:56 <benmachine> Veinor: it just doesn't want to.
06:45:02 <v_> ?faq can Haskell do my math homework?
06:45:02 <mauke> Veinor: solutions: P = 0, N = 1
06:45:02 <lambdabot> The answer is: Yes! Haskell can do that.
06:45:06 <v_> Haha
06:45:06 <tommd> Veinor: It would have said no, but lambdabot is aware of unsafeCoerce.
06:45:11 <c_wraith> You could add a haskell plugin to xchat, using the hint library on one end, and the FFI on the other end.
06:45:12 <mkaemmer> ?faq can haskell prove that P does not equal NP?
06:45:13 <lambdabot> The answer is: Yes! Haskell can do that.
06:45:21 <v_> ?faq can Haskell make pi?
06:45:22 <lambdabot> The answer is: Yes! Haskell can do that.
06:45:27 <Veinor> ?faq can Haskell solve the halting problem?
06:45:27 <Veinor> mauke: ohohoho
06:45:28 <Veinor> I see what you did there
06:45:30 <lambdabot> The answer is: Yes! Haskell can do that.
06:45:32 <v_> ?faq can Haskell make pie?
06:45:33 <lambdabot> The answer is: Yes! Haskell can do that.
06:45:35 <v_> Darn.
06:45:44 <c_wraith> evil channel!
06:45:47 <tommd> Welcome back all
06:45:48 <v_> Haskell can do A LOT!
06:45:48 <c_wraith> 666 total users
06:45:57 <copumpkin> THE DEVIL
06:45:59 <v_> Yes
06:46:06 <aavogt> @quote oven
06:46:06 <lambdabot> No quotes match. :(
06:46:09 <TheHunter> @msg #haskell lambdabot exploit complete.
06:46:09 <lambdabot> lambdabot exploit complete.
06:46:10 <v_> ?faq Does the Devil use Haskell?
06:46:11 <lambdabot> The answer is: Yes! Haskell can do that.
06:46:21 <v_> k
06:46:32 <v_> 664.
06:46:34 <c_wraith> @msg preflex seen c_wraith
06:46:34 <lambdabot> Not enough privileges
06:46:40 <v_> I want to see 777 users
06:46:41 <c_wraith> heh.  good idea. :)
06:46:42 * v_ waits 
06:47:59 <jmcarthur_work> v_, #haskell continues to grow, so we might see that soon
06:48:23 <v_> 777 is not an unusual number for #haskell. That I know
06:48:51 <v_> It's in the top 10 on freenode
06:48:56 <jmcarthur_work> yes
06:49:02 <copumpkin> we never hit 700
06:49:06 <copumpkin> the biggest was 699
06:49:11 <jmcarthur_work> i think 777 is unusual if we have ever even gotten there
06:49:12 <copumpkin> at least as far as I know
06:49:16 <c_wraith> everyone!  invite your friends!
06:49:33 <tommd> But I don't want those bums spamming #haskell.
06:49:46 <c_wraith> hmm.  you've exposed a very real flaw in my plan
06:49:49 <benmachine> are you calling my friends bums :O
06:49:56 <v_> Lazy
06:50:03 <v_> if they use Haskell
06:50:13 <benmachine> they don't, mostly
06:50:30 * benmachine is alone in his love :(
06:50:31 <v_> "Haskell? What's that? A new breakfast cereal?"
06:50:45 <v_> Haskell - they're gonna taste great!
06:50:57 <mrd> haskell, it's like crack for programmers
06:51:07 <Veinor> Haskell IOs!
06:51:08 <v_> Nono, C++ is crack
06:51:14 <v_> Haskell is LSD
06:51:20 <Alpounet> heh
06:51:22 <v_> Tune in, drop out.
06:51:22 <benmachine> unsafePerformIOs
06:51:23 <Veinor> they're monadically delicious!
06:51:26 <chocho> C++ is drinking listerine
06:51:44 <chocho> and huffing ether
06:51:56 <chocho> then lighting a cigarette
06:51:58 <sproingie> zomg bluetile in xmonad now
06:52:02 <smiler> @faq Can haskell solve the halting problem?
06:52:03 <lambdabot> The answer is: Yes! Haskell can do that.
06:52:05 <smiler> Sweet
06:52:05 <v_> C++ is aurolac
06:52:11 <sproingie> bluetile is just about exactly what i'm looking for in a tiling wm
06:52:12 <Veinor> come on, chocho, all the cool kids are doing it!
06:52:15 * Veinor offers chocho a template
06:52:35 <v_> @faq Can Haskell do a nutritious breakfast?
06:52:35 <lambdabot> The answer is: Yes! Haskell can do that.
06:53:03 <Cale> @faq Can Haskell make me a bacon mat?
06:53:04 <lambdabot> The answer is: Yes! Haskell can do that.
06:53:17 <sproingie> @faq can Haskell create a rock it can't move?
06:53:17 * v_ gets ready for breakfast 
06:53:17 <lambdabot> The answer is: Yes! Haskell can do that.
06:53:34 <Veinor> @faq can Haskell write a pure function with type a -> b?
06:53:34 <lambdabot> The answer is: Yes! Haskell can do that.
06:53:34 <ksf> @faq can Haskell move every rock it creates?
06:53:35 <lambdabot> The answer is: Yes! Haskell can do that.
06:53:35 <medfly> lambdabot's Haskell is like chuck norris
06:53:37 <Veinor> :O
06:53:52 <c_wraith> @faq Can Haskell beat up Chuck Norris?
06:53:52 <lambdabot> The answer is: Yes! Haskell can do that.
06:53:55 <mauke> :t let f x = f x in f
06:53:56 <lambdabot> forall t t1. t -> t1
06:53:56 <tommd> Ok, I'm sorry I used the FAQ... ever.  Is everyone tired of it yet?
06:53:58 * v_ http://www.youtube.com/watch?v=Fm9iVETfxKo
06:54:05 <Veinor> mauke: heh
06:54:06 <v_> tommd: not yet :-)
06:54:15 <sproingie> canHaskellDoThat = const True
06:54:25 <medfly> const?
06:54:26 <Veinor> I think f x = _|_ is cheating though :P
06:54:30 <tommd> @src const
06:54:31 <lambdabot> const x _ = x
06:54:35 <ksf> let unsafeCoerce = const undefined
06:54:49 <Veinor> canHaskellDoThat "make me a sammich" = const True "make me a sammich" = True
06:54:50 <c_wraith> medfly, it's closer to id
06:54:58 * medfly goes to sleep
06:55:00 <lament> @faq I have big ugly red blotches all over my face.
06:55:00 <lambdabot> The answer is: Yes! Haskell can do that.
06:55:11 <medfly> eww!
06:55:22 <Vulpyne> Bow chicka bow wow.
06:55:23 <v_> @faq can Haskell?
06:55:23 <lambdabot> The answer is: Yes! Haskell can do that.
06:55:27 <ksf> lamet, I'd recommend getting off of that c++.
06:55:34 <ksf> your skin will heal quickly, then.
06:55:42 <lament> i heard haskell can do that, though
06:55:48 <v_> Yes it can
06:55:56 <Veinor> we should do like a 'there's an app for that' parody
06:56:01 <Veinor> 'there's a monad for that'
06:56:06 <v_> Hahaa
06:56:09 <sproingie> there's an ap for that
06:56:19 <Veinor> ooh, nice
06:56:29 <lament> there's a nap for that
06:56:41 <v_> there's a cap for that
06:56:46 <Veinor> lament: that's how we got the word 'apron'
06:56:49 <sproingie> bust a cap fo dat
06:56:53 <Axman6> wtf is going on in here >_<
06:56:55 <v_> Fo shizzle
06:56:57 <Veinor> by people thinking 'a napron' was 'an apron'
06:57:01 * benmachine hugs Axman6 
06:57:03 <sproingie> Axman6: we're writing a haskell rap
06:57:09 <Veinor> similarly, 'an uncle' -> the shakespearean 'a nuncle'
06:57:12 <Axman6> oh god
06:57:20 <Veinor> I forget what the linguistic term for this is though :(
06:57:34 <sproingie> transposition?
06:57:42 <v_> Anagram?
06:57:46 <sproingie> spoonerism?
06:57:47 <Veinor> nah, it has to do with people incorrectly locating the boundary
06:57:53 <sproingie> eh not quite a spoonerism
06:58:05 <ksf> the same happened with most propositions, too.
06:58:08 <benmachine> Veinor: [citation needed]
06:58:12 <v_> @faq can Haskell do spoonerism?
06:58:12 <lambdabot> The answer is: Yes! Haskell can do that.
06:58:18 <v_> QED
06:58:26 <ksf> they once were actually suffixes and prefixes to inflect words.
06:58:29 <Veinor> metanalysis!
06:58:45 <Veinor> specifically, juncture loss
06:58:55 <benmachine> allegedly, uncle comes indirectly from avunculus
06:58:57 <benmachine> latin
06:58:57 * v_ remembers he has do work on a Haskell presentation for linguists 
06:58:59 <Veinor> or rebracketing
06:59:03 <v_> *to
06:59:09 <benmachine> http://www.etymonline.com/index.php?term=uncle
06:59:17 <Veinor> # cybern•etics: (from Greek kubernan and -ētēs) has become modern cyber•netics (as in cyberspace).
06:59:18 <lunabot>  luna: parse error on input `in'
06:59:27 <v_> Haskell fo' Linguistics. What a concept
07:00:01 <Veinor> also, helico.pter -> heli.copter
07:00:04 <benmachine> nuncle apparently came from mine uncle -> my nuncle
07:00:19 <Veinor> yeah, which is close enough to what I said :P
07:00:25 <benmachine> heh
07:00:33 <v_> @faq Ph'nglui mglw'nafh Haskell R'lyeh wgah'nagl fhtagn
07:00:33 <lambdabot> The answer is: Yes! Haskell can do that.
07:00:47 * v_ :-D 
07:00:49 <benmachine> internet says you were right about napron though
07:01:04 <benmachine> that is really cool and I am going to tell all my friends and some other people who I sort of like
07:01:05 <c_wraith> I'm glad to know that Haskell plans to raise Cthulhu
07:01:11 <Veinor> :D
07:01:17 <Veinor> I like linguistics, it's cool
07:01:31 <v_> Yes it is
07:01:42 <v_> And there was that LOLITA project at Durham
07:01:47 <v_> Pretty interesting
07:01:51 <copumpkin> @hackage loli
07:01:52 <lambdabot> http://hackage.haskell.org/package/loli
07:01:52 <Veinor> ?
07:02:07 <v_> http://en.wikipedia.org/wiki/LOLITA
07:02:09 <v_> Heh
07:02:32 <v_> Better than the book
07:04:13 <v_> This will help http://www.haskell.org/haskellwiki/Applications_and_libraries/Linguistics
07:04:30 <sohum> @faq can haskell defeat the new world order that will arise in 2013?
07:04:31 <lambdabot> The answer is: Yes! Haskell can do that.
07:04:41 <Veinor> @faq can haskell ron paul 2012
07:04:42 <lambdabot> The answer is: Yes! Haskell can do that.
07:04:57 <copumpkin> Veinor: keep your angry politics to twitter!!
07:04:58 <v_> Mayans and Ron Paul
07:05:02 <Veinor> never!
07:05:08 <v_> What a concept!
07:05:10 <tensorpudding> @faq can haskell reverse entropy?
07:05:10 <lambdabot> The answer is: Yes! Haskell can do that.
07:05:12 <sohum> nup. I said 2013
07:05:21 <v_> 2012++
07:05:28 <Veinor> I refuse to let my societal progressivism be contained to any one medium!
07:05:29 <tensorpudding> off-by-one errors
07:05:39 <sw17ch> @faq can haskell get me a raise?
07:05:39 <lambdabot> The answer is: Yes! Haskell can do that.
07:05:54 <v_> @faq can Haskell do this?
07:05:54 <lambdabot> The answer is: Yes! Haskell can do that.
07:05:56 <tommd> sw17ch: Did you ever get around to playing with Atom?
07:06:12 <sw17ch> tommd: quite a bit, but not recently
07:06:19 <sw17ch> i haven't played with the latest version
07:06:31 <tommd> Your thoughts?  Did you blog about it any?
07:06:37 <DaveS> @faq Where's waldo?
07:06:38 <lambdabot> The answer is: Yes! Haskell can do that.
07:06:44 <v_> This will be a good book too http://homepages.cwi.nl/~jve/cs/
07:07:10 <sw17ch> tommd: not past my first posts --> http://blog.sw17ch.com/wordpress/?p=84
07:07:17 <sw17ch> it's been.. a while
07:07:23 <tommd> sw17ch: Ah, thanks.
07:07:32 <sw17ch> and those entries are outdated now
07:07:36 <sw17ch> check out Lee Pike's blog instead
07:07:47 <Veinor> I need to write things for my blog. I'm out of ideas :/
07:07:54 <sw17ch> i know he contributed substantially on the latest release
07:07:58 <lament> Veinor: me too!
07:08:13 <lament> Veinor: let's start an out-of-ideas blog
07:08:14 * v_ is constantly adding Haskell blogs in Google Reader
07:08:14 <DaveS> Yet another Monads metaphor
07:08:15 <Veinor> I'm thinking of writing my term paper up, but... laaaaazy
07:08:20 <lament> "The quest for ideas"
07:08:25 <copumpkin> Veinor: just don't do it
07:08:26 <DaveS> or YAMM
07:08:33 <Veinor> don't do what?
07:08:36 <v_> @faq can Haskell help me with my blog?
07:08:37 <lambdabot> The answer is: Yes! Haskell can do that.
07:08:39 <c_wraith> I liked the monads-as-monsters metaphor
07:09:36 <v_> it's like tripping monads in the forests with leprachauns and everything
07:10:42 <DaveS> monads are like... abstract datatypes used to represent computations
07:10:42 <Philonous> They eat your values and the only way of getting them out again is letting another monster eat the first one and digesting it?
07:11:07 <copumpkin> Veinor: paper, coursework, whatever
07:11:19 <sw17ch> Philonous: or cutting it open with the unsafePerformIO sabre
07:11:21 <v_> Haskell hides under your bed
07:11:32 <DaveS> Eddie Haskell?
07:11:39 <DaveS> Hate that kid, always hitting my mom
07:11:46 <Philonous> sw17ch: Hax!
07:11:48 <Veinor> no, I mean
07:11:51 <Veinor> adapting the paper for the blog
07:12:04 <Veinor> the paper itself is done and submitted.
07:12:19 <sw17ch> Philonous: cheat codes for Haskell [unsafeCoerce, unsafePerformIO]
07:13:27 <Philonous> sw17ch: Btw. Why do you automatically presume it's IO?
07:13:39 <v_> A natural language generator in Haskell. Yum!
07:13:44 <sw17ch> Philonous: for the sake of the pun :\
07:13:48 <sw17ch> well, joke
07:13:48 <sw17ch> not pun
07:19:17 <sioraiocht> Can anyone point me to a good resource on data types as initial algebras?
07:19:57 <v_> http://www.cs.ut.ee/~varmo/papers/thesis.pdf
07:20:12 <copumpkin> sioraiocht: maybe http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1418 ?
07:20:27 <sioraiocht> thanks v_, copumpkin
07:20:54 <v_> sioraiocht: and this is interesting too, with a bit of Haskell http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
07:20:57 <v_> You're welcome
07:21:02 <Axman6> copumpkin: your spoon package looks quite useful indeed btw
07:21:09 <copumpkin> v_: that looks good! I hadn't seen it
07:21:24 <v_> Yeah, check it out. It's delicious
07:21:30 <copumpkin> Axman6: great! trying to think of a good way to make it extensible now
07:22:04 <DaveS> Oi category theory makes my head hurt
07:22:05 <v_> There is a spoon package?
07:22:14 <copumpkin> @hackage spoon
07:22:14 <lambdabot> http://hackage.haskell.org/package/spoon
07:22:17 <copumpkin> v_: yep
07:22:29 <v_> Interesting
07:22:47 <v_> What are pure computations?
07:23:04 * ddarius would recommend "Calculating Functional Programs"
07:23:22 <v_> ddarius: will do
07:24:39 <copumpkin> I wish authors would publish their .tex source as well as the pd
07:24:39 <copumpkin> f
07:25:14 <RayNbow> copumpkin: are you sure about that? :p
07:25:16 <v_> That reminds me, I have to finish a paper on Boolean circuit complexity... uhm
07:25:28 <copumpkin> RayNbow: sure about what?
07:25:30 <RayNbow> I always manage to put ugly hacks in my .tex documents for example :p
07:25:33 <copumpkin> oh
07:25:47 <v_> .tex obfuscation
07:25:49 <copumpkin> well my main issue is that some people manage to render their PDFs in such a manner that they're really slow and blurry on mac os
07:25:58 <copumpkin> I assume it's encoding the text as outlines rather than text
07:26:08 <copumpkin> and that stops mac os from using hinting and fast text paths
07:26:36 <copumpkin> that tutorial on (co)algebras and (co)induction is one such paper
07:28:58 <Liskni_si> type 3 fonts, usually.
07:29:25 <nagnatron> never heard about that, how would you avoid it ?
07:29:37 <monochrom> I have seen worse. Usually ps2pdf makes really poor pdf's.
07:29:39 <copumpkin> really? I've used type 3 fonts before and haven't had an issue
07:29:40 <copumpkin> but maybe
07:30:27 <Liskni_si> well, i've had all sorts of problems wiewing pdf with type3 in linux, dunno about mac
07:30:44 <copumpkin> apple makes a big deal out of its typography
07:30:47 <copumpkin> and it's usually pretty good
07:30:55 <Liskni_si> and acroread even prints those fonts wrong
07:31:10 <copumpkin> but if the PDF doesn't look like it contains any text, that obviously doesn't get passed through the text pipeline
07:31:41 <Veinor> am I correct in saying that when I write (2 + 3 :: Foo), Foo.+ is used?
07:31:50 <v_> pdf's are quirky, flawed, and an enormous success
07:32:00 <Liskni_si> nagnatron: was that for me?
07:32:01 <monochrom> Correct.
07:32:01 <v_> Just like mp3's
07:32:24 <Veinor> monochrom: because literal numbers are magic like that, yes?
07:32:29 <copumpkin> Veinor: Foo doesn't have a +
07:32:32 <nagnatron> Liskni_si: yes, you and copumpkin
07:32:35 <monochrom> Part of it.
07:32:50 <Veinor> copumpkin: well, you know what I'm trying to say
07:33:06 <copumpkin> the (+) from Foo's Num instance gets used, yep :)
07:33:07 <monochrom> Fool.gold
07:33:14 <sioraiocht> In discussing initial algebras as data types, I usually see people say "For example, list with cons and nil are the initial data type of 1 + A x X, here is the proof"
07:33:26 <Veinor> yay
07:33:35 <copumpkin> sioraiocht: needs more mu!
07:33:39 <copumpkin> oh wait
07:33:54 <RayNbow> copumpkin: how well does this render on your Mac? http://web.cecs.pdx.edu/~sheard/course/AdvancedFP/papers/jacobs97tutorial.ps
07:34:01 <sioraiocht> copumpkin: okay, here's a question, why are initial algebras fixpoints of functors?
07:34:18 <c0w> RayNbow: awfully
07:34:23 <sioraiocht> I never understood how you know by being the least element that voila you were an initial algebra
07:34:32 <ddarius> sioraiocht: See Lambek's lemma.
07:34:36 <c0w> needs more muuuuuuu
07:34:39 <sioraiocht> ddarius: okay
07:34:56 <sioraiocht> also, how does that explain categories with no initial algebras
07:35:21 <Liskni_si> nagnatron: well, a lot of people simply don't have type1 fonts around when they tex the document, and don't care as long as it looks ok on their ps printer
07:35:26 <v_> c0wbell
07:35:26 <ddarius> sioraiocht: The fixpoint construction doesn't even make sense in most categories.
07:35:41 <sioraiocht> ddarius: why is that?
07:35:50 <ddarius> sioraiocht: Why would it?
07:36:04 <sioraiocht> ddarius: I dunno, maybe I don't understand fixpoints of functors, then
07:36:25 <copumpkin> RayNbow: my impression is that PDF has a mechanism for taking arbitrary spaces on a page and allowing you to select it and copy text there. But there doesn't actually need to be text there. So I feel that that pdf uses the mechanism to allow copyable text, and then slaps ugly raster on top of it. http://snapplr.com/7w6t
07:37:07 <nagnatron> Liskni_si: Thanks, makes sense.
07:43:40 <Liskni_si> copumpkin: PDFs of scanned documents may contain a hidden layer of text that's added there by an OCR for copypaste, but that's not the case here I think
07:43:59 <copumpkin> Liskni_si: does that pdf look okay to you? the text looks pixellated to me
07:44:12 <ddarius> sioraiocht: In any omega-cocomplete category, we can construct initial algebras using a fixed point construction, but the notion is more general than that construction.
07:44:17 <v_> scanned PDFs make me flaccid
07:44:24 <sioraiocht> ddarius: ah, okay
07:44:26 <copumpkin> I feel bad for the siki dude on haskell-cafe
07:44:44 <copumpkin> he keeps trying to post a job ad and keeps getting critiques of his posting rather than applications
07:44:57 <ksf> compiling to javascript actually works just fine.
07:45:06 <Liskni_si> copumpkin: it is postscript in fact, and it does not look okay, because there are bitmap type 3 fonts with low resolution (and no character mapping to a known encoding)
07:45:10 <v_> Haskell to js?
07:45:29 <ksf> http://www.haskell.org/haskellwiki/Yhc/Javascript
07:45:41 <copumpkin> Liskni_si: aha. So I wish they'd release the .tex file so I can recompile it :)
07:45:54 <copumpkin> maybe I'll start emailing the authors and asking them for the source
07:45:54 <v_> ksf, interesting
07:45:54 * monochrom is finally upgraded to ghc 6.10.4
07:46:04 <v_> Haskell Web Toolkit
07:46:06 <v_> Woa
07:46:40 <ksf> so the current plan is to generate client-side code with yhc/ycr2js, while doing server-side backup stuff with ghc/happstack, using the same code
07:46:41 <v_> Reminds me of this http://www.slideshare.net/ujihisa/from-javascript-to-haskell  very cool presentation
07:46:47 <ksf> ...that is, server-side DOM scripting.
07:46:55 <v_> Yeah, 1337cakes
07:47:09 <DaveS> v_: http://www.impredicative.com/ur/
07:47:24 <ksf> well, as soon as yhc becomes self-hosting, we'd have a haskell compiler that runs in the browser.
07:47:33 <v_> :-D
07:47:43 <ksf> now that's a gem for hpaste.
07:47:56 <v_> DaveS: also interesting
07:48:04 <v_> But obscure
07:48:10 <ksf> yeah, it's an ml.
07:48:15 <monochrom> lambda-shaped spider
07:48:26 <v_> Ah, it's in the Ml family?
07:48:42 * v_ notes that 
07:49:01 <ksf> it's got some haskell features, but certainly inherited all the syntactic insanity of ml.
07:49:08 <ksf> it's genetic.
07:49:20 <ksf> once an ugly mutant, always an ugly mutant.
07:49:51 <v_> What's wrong with The MLs?
07:50:16 <ksf> well, the _right_ thing is that they're statically typed, and mostly functional.
07:50:18 <copumpkin> mutant languages?
07:50:23 <copumpkin> :P
07:50:32 <DaveS> Ur is pure
07:50:37 <v_> But fast! Ha.
07:51:12 <copumpkin> it's sad when my roommate left the tv on in front of me and I'm too lazy to get up to fetch the remote to turn it off
07:51:27 <DaveS> too lazy to fetch the remote.. that is lazy
07:51:27 <v_> But this "my language is faster than yours" gets old... fast
07:51:27 <copumpkin> the laziness of haskell is flowing in my veins now
07:51:32 <v_> really old, really fast
07:52:08 <v_> The laziness of #haskell is flowing in my veins now. And I have to finish a presentation in... 5 hours
07:52:12 * v_ gets the rope 
07:52:14 <monochrom> my language is lazier than yours
07:52:19 * Badger forces copumpkin to evaluate
07:52:32 <m0nkfish> v_ my language gets older faster
07:52:38 * copumpkin throws a TooLazy exception
07:52:43 <monochrom> copumpkin would just decide to watch tv in order to avoid fetching remote
07:52:45 <v_> C gets old really fast
07:53:01 <m0nkfish> asm gets old extremely fast
07:53:05 <mauke> m0nkfish: http://halfassured.tumblr.com/post/271839003
07:53:05 <v_> copumpkin: in the future your remote will run Haskell
07:53:08 <copumpkin> monochrom: yeah! I don't even watch tv normally. Was just sitting in my living room and he was watching, and then he left
07:53:12 <DaveS> Haskell_Is_Underappreciated exception
07:53:24 <DaveS> Leaving_for_Startup exception
07:53:24 <ksf> v_, http://translate.google.com/?hl=fi
07:53:29 <m0nkfish> consider my mind boggled
07:53:30 <v_> I'm currently aging with the speed of light
07:53:34 <monochrom> This tv show seems quite good afterall. :)
07:53:35 <Badger> Then it'll be too lazy to change the channels.
07:53:35 <v_> Einstein said that
07:53:59 <v_> http://translate.google.com/?hl=fi#ru|en|lol%20wut
07:54:00 <copumpkin> it's a history channel show on guns
07:54:06 <sohum> @pl \n -> map (take n) . takeWhile (not . null) . iterate (drop n)
07:54:06 <lambdabot> ap ((.) . map . take) ((takeWhile (not . null) .) . iterate . drop)
07:54:32 <DaveS> copumpkin: Guns, monsters and nostradamus is half the History Channel line up
07:54:37 <copumpkin> true
07:54:40 <DaveS> might as well be "Cosmos for rednecks"
07:54:41 <Poulter> Hey... how would one filter a list of data types?
07:54:42 <v_> Не оружие убивает людей. Чак Норрис убивает людей.
07:54:44 <DaveS> like on family guy
07:54:51 <ksf> that page is certainly the fastest way to finnish anything.
07:55:03 <Poulter> Data A = B|C
07:55:05 <Badger> Oh lord.
07:55:08 <v_> Finnish is mindfuck.
07:55:13 <copumpkin> @quote id
07:55:14 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
07:55:17 <copumpkin> @quote id
07:55:18 <DaveS> THat's finnish? It looks russian
07:55:18 <lambdabot> dmwit says: (on Haskell) Welcome to the light side of the Force. =)
07:55:22 <Poulter> [A] how do I only get the Bs from the list?
07:55:28 <Badger> Please tell me that didn't actually say Chuck Norris.
07:55:29 <copumpkin> @quote ski
07:55:30 <lambdabot> ski says: > (let id :: (forall id. id -> id) -> id -> id; id id = id id in id) id 5
07:55:36 <v_> Badger: oh snap
07:55:43 <Badger> v_: You monster.
07:55:43 <copumpkin> > (let id :: (forall id. id -> id) -> id -> id; id id = id id in id) id 5
07:55:44 <lambdabot>   5
07:55:56 <v_> Yeah, but I'm a huge fan of
07:56:32 <v_> Первое животное Брюс Шнайер имя, девичью фамилию матери, и все другие его ответы на секретные вопросы случайных 1024 байт блока.
07:56:46 <ksf> Poulter,
07:56:50 <v_> Lol
07:56:52 <ksf> :t filter
07:56:53 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:56:57 <v_> Pretty accurate translation
07:57:13 <DaveS> why does that put spaces between each character?
07:57:17 <Poulter> Yea, I think I've tried that.
07:58:03 <Poulter> filter (\s -> (B _ _ _ ) = s) lis
07:58:07 <v_> @quote lolwut
07:58:07 <lambdabot> No quotes match. Do you think like you type?
07:58:15 <v_> @quote is
07:58:15 <lambdabot> is says: hackage still explodified?
07:58:22 <v_> @quote id
07:58:23 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
07:58:31 <v_> @quote
07:58:32 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
07:58:42 <ksf> filter (\b -> case b of B{} -> True; _ -> False)
07:58:45 <v_> Nice
07:59:05 <ksf> ...I'm advocating lambdas that can pattern match directly, but nobody listenes.
07:59:25 <v_> @faq Can lambdas do that?
07:59:25 <lambdabot> The answer is: Yes! Haskell can do that.
07:59:31 <Poulter> ooo
07:59:39 * ksf recommends isB B{} = True; isB _ = False and then filter isB
08:00:03 <Poulter> B{} ?
08:00:04 <ksf> ...either at top level or in a where or let clause, your choice.
08:00:07 <Poulter> Notation for?
08:00:10 <ksf> that's record syntax.
08:00:16 <Poulter> Sorry?
08:00:25 <ksf> matches the B constructor and saves you from ignoring its fields.
08:00:37 <Poulter> :O Good stuff!
08:00:42 <iesahin> ksf: nice trick :)
08:01:06 <Poulter>  isB B{} = True; isB _ = False
08:01:11 <Poulter> semicolon?
08:01:21 <ksf> make that a newline
08:01:27 <Poulter> kk cool, got that much
08:01:31 <Poulter> Thanks
08:01:35 <ksf> ...layout is hard to get right on one irc line.
08:03:48 <pastah_rhymez> @hoogle exitSuccess
08:03:48 <lambdabot> System.Exit exitSuccess :: IO a
08:03:48 <lambdabot> System.Exit ExitSuccess :: ExitCode
08:09:00 <Poulter> Is it possible to specify fields that B should have?
08:09:26 <Poulter> isB B(_ _ 1 _) = True; isB _ = False
08:09:35 <monochrom> Yes.
08:09:58 <Poulter> Ah I'm being told no underscores.
08:10:05 <Poulter> I've had lot a lot in this project
08:11:35 <Poulter> B is not a tuple hence its not: isB B(_ _ 1 _) = True; isB _ = False: it is isB (B _ _ 1 _) = True; isB _ = False
08:11:38 <Poulter> Thanks
08:14:08 <kmc_> ? a tuple would have commas
08:14:16 <Poulter> Also, yes :) :P
08:14:31 <kmc_> and no constructor name
08:14:43 <Poulter> And that, okay I'm quite fail :(
08:14:51 <Poulter> I'm not working with Tuples anywho
08:17:50 <Vulpyne> It would probably be a lot more readable if you used named fields in a record.
08:20:11 <Vulpyne> Say you did data B = B { spork, spoon, fork, knife :: Int } then isB B { fork = 1 } = True; isB _ = False
08:21:00 <kmc_> records leave a lot to be desired.  but i agree
08:21:16 <Vulpyne> The only thing I don't like about them is the field names are in the global namespace.
08:21:53 <Vulpyne> And if you have multiple fields with the same name in different records, it should just magically know which one I mean. :)
08:22:04 <kmc_> the accessor functions are also useless for updates
08:22:29 <kmc_> so you write a lot of boilerplate like \x r -> r { foo = x }
08:22:46 <kmc_> there are not one, not two, but three packages on hackage that try to fix this properly
08:23:00 <sproingie> what i don't like about record accessors is you can't make them computed
08:23:01 <Vulpyne> Don't you lose nice stuff like pattern matching if you use those though?
08:23:08 <sproingie> doubly so when you use pattern-matching on them
08:23:34 <jmcarthur_work> Vulpyne, no, you can still use pattern matching just as before
08:23:42 <kmc_> yeah, field labels are not first-class.  the basic idea of fclabels, lenses, and data-accessor is to make them first-class
08:23:51 <sproingie> encapsulation is not just for OOP
08:24:09 <Vulpyne> Ah, I've read stuff about some of those, but apparently didn't pay enough attention.
08:24:10 <joe____> can anyone please help me with the below error. I am clueless.
08:24:12 <joe____> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13843#a13844
08:24:14 <jmcarthur_work> Vulpyne, to be fair, it's not really global namespace. just module namespace
08:24:18 <kmc_> Vulpyne, those packages allow you to define (or autogenerate) new "first-class" labels.  the old built-in labels still exist
08:24:33 <aavogt> encapsulation is for pharmaceuticals
08:24:59 <kmc_> joe____, there's a crapload of code there
08:25:21 <joe____> sorry, please ignore the rest of the code.
08:25:32 <joe____> I just put the whole file.
08:25:35 <kmc_> the issue is this "Test" vs "IO b" type mismatch?
08:26:05 <joe____> i can clean it up and put a small file. please give me a minute.
08:26:09 <kmc_> okay
08:26:25 <kmc_> you don't seem to have the definition of "newCtx" which is what's causing the error
08:26:36 <kmc_> i am guessing that newCtx has type "Test"
08:27:33 <c_wraith> If this is HUnit, Test is an alias for IO ()
08:28:53 <joe____> Prelude System.USB> :t newCtx
08:28:54 <joe____> newCtx :: IO Ctx
08:29:02 <Vulpyne> Hmm, that OverloadedStrings thing looks interesting.
08:30:07 <kmc_> Test is not an alias in HUnit
08:30:23 <kmc_> it's a datatype
08:30:39 <kmc_> it has a constructor "TestCase Assertion",
08:30:47 <kmc_> where "type Assertion = IO ()"
08:30:59 <kmc_> joe____, does that clear it up?
08:31:17 <c_wraith> Oh.  I was remembering the wrong type.  oops.
08:31:18 <Alpounet> does anyone know about a library for interrogating webservices in Haskell ?
08:32:15 <joe____> kmc_: please give me a minute. I am trying to understand.
08:34:59 <joe____> sorry, I do not understand.
08:35:11 <joe____> How to equate Test with IO?
08:35:38 <joe____> the last line is the "Testcase ", which returns Test.
08:36:14 <joe____> the rest of the lines in the "do " statement are just some actions that I want to perform before running the testcase.
08:37:16 <DerisionSnort> @pl \n -> [1..n]
08:37:16 <lambdabot> enumFromTo 1
08:37:32 <DerisionSnort> @src enumFromTo
08:37:33 <lambdabot> Source not found. stty: unknown mode: doofus
08:37:34 <Vulpyne> TestCase $ do blah blah blah
08:37:43 * ksf tries to decide whether being hated by all php "programmers" of the world is worth getting his ass down and producing some code
08:38:07 <Vulpyne> It's okay if PHP programmers hate you.
08:38:11 <joe____> should I change the return parameter of tst to "IO ()" from "Test"?
08:38:19 <Cale> ksf: Why are they going to hate you?
08:38:28 <Vulpyne> joe: Try what I said.
08:38:50 <ksf> the idea is to port hsp over to DOM, so that we can write hsp pages that run client-side.
08:39:00 <Vulpyne> Also ensure it evaluates to IO (), possibly by adding a return () at the end of the do block. *DISCLAIMER: I've never even used HUnit.
08:39:18 <joe____> oh, ok..
08:39:21 <ksf> ...oh. and, at the same time, most likely have a static guarantee only to produce valid html on the server-side, too.
08:39:27 <joe____> Vulpyne, I had missed ur comment.
08:39:29 <Cale> Hey, you shouldn't worry about the performance of (++) like that. I doubt it's any slower than printf.
08:39:34 <Alpounet> nobody tackled webservices in Haskell ?
08:39:36 <ksf> ...as I don't think you can generate invalid stuff when you stick to the DOM idl.
08:39:42 <Cale> Especially in the cases where printf would actually be useful
08:39:51 <Zao> I wonder if there's any WSDL -> Haskell tools out there.
08:40:00 <Cale> (++) does what it does as efficiently as any function which does that
08:40:02 <Vulpyne> Before you had: func = do { io action; io action; io action; } , after the change it would be: func = TestCase $ do { io action; io action; io action; return () }
08:40:12 <ksf> Alpounet, there's huuuuuge chunks, but nothing for the faint of heart.
08:40:16 <Zao> Feels like a natural expansion route for happs for serverside.
08:40:19 <Cale> However, lists are fundamentally expensive to concatenate
08:40:31 <Cale> (when the list on the left is long)
08:40:49 <Alpounet> ksf, any pointer that'd be a beginning for me ?
08:40:49 <Vulpyne> I bet lazy ByteStrings are cheap to concatenate.
08:41:00 <Cale> Not really.
08:41:03 <Alpounet> ksf, it'd avoid me to do everything from scratch
08:41:06 <jmcarthur_work> they are unless you are concatenating lots of really short strings
08:41:14 <jmcarthur_work> but for long ones it's a bit nicer
08:41:21 <Vulpyne> I guess it would depend on how many chunks it was in.
08:41:23 <ksf> Alpounet, happstack is basically the way to go
08:41:28 <Cale> Lazy bytestrings are essentially lists of strict bytestring chunks
08:41:37 <Alpounet> ksf, just for querying webservices ?
08:41:38 <jmcarthur_work> fairly big chunks though
08:41:41 <jmcarthur_work> ideally
08:41:43 <Alpounet> I only need to query them
08:41:46 <Vulpyne> I know, I was just being dumb. :)
08:41:54 <jmcarthur_work> unless you have been concatenating lots of little ones
08:42:01 <ksf> oh, no, for deploying webapps to the cloud+beyond.
08:42:18 <Alpounet> oh no no, that's not what I need to do ftm
08:42:22 <ksf> if you want to query, there's basic networking modules that do HTTP, JSON and xml parsers, you name it.
08:42:24 <Alpounet> only for querying right now
08:42:32 <Alpounet> ok
08:42:36 <Cale> asymptotically, it's still on the order of the length of the left string
08:42:45 <Alpounet> nothing that eases the whole thing
08:42:57 <fracture> is there some sort of a union type in haskell?
08:42:58 <Alpounet> I only have to connect the separate parts between them
08:43:01 <Alpounet> ksf, thanks
08:43:05 <jmcarthur_work> yeah
08:43:08 <Vulpyne> DLists maybe?
08:43:11 <ksf> things like tagsoup, that spares you the agony of unsafely regexing your way along invalid html.
08:43:11 <Cale> fracture: There is Either, and you can define others
08:43:13 <kmc_> joe____, a "do" block is going to have monadic type, no matter what
08:43:21 <fracture> ah
08:43:28 <Alpounet> ksf, yeah, I'm already using tagsoup
08:43:36 <Alpounet> it's a pretty good work
08:43:41 <Vulpyne> http://hackage.haskell.org/package/dlist
08:43:42 <Cale> Vulpyne: Yeah, though I would usually not bother with the DList package, and just work with functions
08:43:47 <kmc_> in this case, IO monad; you know from the first statement
08:44:07 <kmc_> joe____, so if you ever say "f :: A -> B;  f x = do ...", and B is not a monadic type, you know it's broken
08:44:20 <Cale> It's really quite simple enough to just work with functions that add elements to the beginning of a list, and concatenate them by composing them.
08:44:22 <joe____> oh, ok.
08:44:31 <jmcarthur_work> what was the problem needing fast concatenation here?
08:44:38 <Cale> There was none
08:44:40 <joe____> i changed it to:
08:44:43 <jmcarthur_work> oh
08:44:49 <joe____>                TestCase $ assertEqual message result $ take length(result) datastack $
08:45:01 <kmc_> what you had initially has type "IO Test".  i.e., an IO action which computes a test case.  not a test case which is itself made of an IO action
08:45:02 <Cale> That's why I complained -- in the code there was a comment that (++) was slow, and a use of printf
08:45:09 <kmc_> does that make sense?
08:45:13 <Cale> when that wouldn't really have helped at all
08:45:18 <jmcarthur_work> with DList (or direct function composition) you also can't really use intermediate results without breaking the efficiency, afaik
08:45:21 <copumpkin> mmorrow: lots of talk about spoon on reddit
08:45:25 <Cale> jmcarthur_work: right
08:45:37 <jmcarthur_work> so it really depends on what you are using it for
08:45:46 <joe____> kmc_: any "function x = do" changes the type to IO() ,right?
08:45:52 <kmc_> no
08:46:00 <kmc_> "do" is more general than that
08:46:04 <Cale> jmcarthur_work: Well, you can *sort of* still use the beginning of the list, but it's awkward.
08:46:12 <kmc_> :t f x = do { return x }
08:46:13 <lambdabot> parse error on input `='
08:46:14 <copumpkin> do doesn't even have to be a Monad
08:46:15 <copumpkin> :P
08:46:19 <kmc_> :t let f x = do { return x } in f
08:46:20 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:46:25 <kmc_> copumpkin, oh?
08:46:42 <c_wraith> > fix (0:)
08:46:43 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:46:55 <copumpkin> kmc_: NoImplicitPrelude just desugars it to >>, >>=, and fail. If you have other versions of those in scope, you can do all sorts of funky stuff
08:46:57 <c_wraith> clearly, you can read the start of the list generated by function composition
08:47:10 <kmc_> that's an extension...
08:47:34 <joe____> how can I get a value from a do block as an argument to a function outside?
08:47:39 <copumpkin> most of us use a handful of extensions in every project
08:47:49 <joe____> device_tests.hs:25:75: Not in scope: `datastack'
08:47:54 <kmc_> joe____, have you learned how to use monads?
08:47:55 <Cale> joe____: Use the function outside inside the do-block
08:47:58 <kmc_> i mean not how to do IO
08:47:59 <joe____>                TestCase $ assertEqual message result $ take length(result) datastack $
08:48:06 <kmc_> because IO is a bad place to learn monads
08:48:19 <Cale> joe____: You're passing way too many parameters to take
08:48:23 <joe____> where                      datastack <- readControl mydevicehandle Vendor ToDevice forthoutput 0 0 8 1000
08:48:29 <tensorpudding> IO is an easy example of a monad though
08:48:31 <joe____> is in the do block after the $
08:48:34 <kmc_> easy how?
08:48:41 <tensorpudding> as in, readily available
08:48:47 <kmc_> IO has all kinds of special properties that other monads don't have
08:48:50 <kmc_> Maybe is readily available
08:48:57 <tensorpudding> Maybe is also kinda trivial
08:49:04 <aavogt> IO behaves like other languages
08:49:06 <Cale> I like the list monad
08:49:13 <joe____> ok, got it. I can move the assertequal into the do block
08:49:14 <Cale> It's trivial enough without being too trivial.
08:49:14 <tensorpudding> i suppose the list monad is the best example
08:49:17 <kmc_> Maybe is easy enough to define yourself
08:49:30 <aavogt> and you need it
08:49:30 <tensorpudding> of a non-trivial, easy and ubiquitous monad
08:49:42 <Cale> But if you want something really trivial, you could always go with  data Trivial a = Trivial
08:49:49 <Cale> instance Monad Trivial where
08:49:52 <Cale>   return x = Trivial
08:49:54 <kmc_> aavogt, IO doesn't behave like other languages
08:49:59 <Cale>   Trivial >>= f = Trivial
08:50:14 <kmc_> the idea that it does is why people ask "how do i turn an IO String into a String"
08:50:14 <copumpkin> > () >> ()
08:50:15 <lambdabot>   Couldn't match expected type `m a' against inferred type `()'
08:50:22 <copumpkin> oh of course
08:50:29 <Cale> kmc_: I'm not sure that's fair to say...
08:50:35 <tensorpudding> it is possible to model IO using applicatives instead of monads isn't it
08:50:42 <Alpounet> ksf, actually, I'd just query an url, get the content, and parse the SOAP string with tagsoup and filter what I want etc
08:50:44 <kmc_> every monad is an applicative
08:50:47 <Alpounet> looks interesting
08:50:48 <Cale> kmc_: Most languages don't have a metalanguage acting on them.
08:50:54 <kmc_> (theoretically if not in type classes)
08:51:02 <aavogt> tensorpudding: you can't choose to do stuff based on user input if you only use applicatives
08:51:13 <tensorpudding> aavogt: okay
08:51:20 <Cale> Apart from that, IO behaves quite a lot like other imperative languages, except more clearly structured.
08:51:20 <aavogt> since with applicatives all the effects must take place
08:51:50 <Cale> mmm... anyway, we're probably way off topic
08:51:58 <tensorpudding> there does seem to be the idea that you shouldn't do a monad when an applicative will work
08:52:02 <Cale> joe____: Have you read my Introduction to IO?
08:52:12 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
08:52:56 <joe____> Cale, I will read it in a minute. Thansk.
08:52:59 <joe____> Thanks.
08:53:37 <Cale> joe____: The general idea is that while you can't use the results of IO actions inside a pure function, you can use pure functions from inside IO actions, passing the results of other IO actions into them.
08:54:01 <kmc_> you can only get so far with the ad-hoc understanding of IO
08:54:19 <Cale> joe____: So if you want to separate your function from IO, you just have it take as parameters all the things that it would need to do IO to obtain.
08:54:39 <joe____> i think i have go back and change the program structure.
08:54:50 <kmc_> and once you move from "how do I do IO?" to "what's a monad anyway?", it's best to set aside IO for a while and learn simpler monads
08:54:58 <Cale> kmc_: You don't ever need to understand monads unless you're writing code that works with more than one monad.
08:55:13 <tensorpudding> you could learn about monads without having to do IO first
08:55:20 <Cale> Otherwise it's an irrelevant detail that IO happens to be a monad.
08:55:52 <monochrom> Just treat ">>=" and "return" as overloaded operators. I have never heard of programming students having problems with "+".
08:55:57 <Cale> Well, nearly. You might like to learn to use the stuff from Control.Monad anyway, but you can just pretend that all the m's are IO's and it works out.
08:56:28 <Cale> Abstractions become distractions if you only care about one example.
08:56:42 <monochrom> But perhaps >>='s extra difficult is that it expects more advanced types of its parameters.
08:56:52 <kmc_> monochrom, yes, it's a higher-order function
08:57:18 <monochrom> But people talk of f+g, v+w (vector addition) anyway. They are just as advanced.
08:57:26 <Cale> Right. I think most of the difficulty of "monads" is really that people are introduced to them before being 100% comfortable with meat & potatoes functional programming.
08:57:41 <sproingie> fer sure
08:57:51 <copumpkin> fo sho
08:57:54 <m0nkfish> what is a potatoes
08:57:55 <sproingie> knowing fmap cold is a help
08:57:55 <Cale> That is, the difficulty for them is not really that monads are a difficult concept, it's that they're not used to working with functions yet.
08:57:58 <jmcarthur_work> monochrom, and of course there's also Num lifted for instances of Applicative
08:58:20 <sproingie> lots of tutorials go "here's fmap now forget about fmap here's all of monads open wide"
08:58:30 <jmcarthur_work> ah, your f+g case is an example of that
08:58:41 <tensorpudding> fmap is easy to understand
08:58:44 <sproingie> it sure is
08:59:04 <kmc_> there's also this problem that "IO a" is an unrealized effect, not a result.  but people are used to languages where every unrealized effect is a function
08:59:09 <Cale> m0nkfish: The potato is a starchy, tuberous crop from the perennial Solanum tuberosum of the Solanaceae family.
08:59:14 <sproingie> IO is also really weird and special
08:59:24 <sproingie> and totally the wrong thing to introduce monads with
08:59:24 <tensorpudding> IO is black boxes
08:59:32 <tensorpudding> that look like a monad
08:59:41 <Cale> sproingie: Yes, but that doesn't mean that one can't learn about IO first.
08:59:43 <tensorpudding> and act like a monad, kinda
08:59:48 <Cale> (before monads)
08:59:58 <sproingie> oh sure, i agree
09:00:00 <Cale> Being an example of a monad is mostly irrelevant.
09:00:05 <kmc_> it's weird at first that side effects and functions are two orthogonal types
09:00:13 <Cale> s/side//
09:00:25 <kmc_> even though it would be natural to anyone who hadn't learned lots of impure languages
09:00:26 <EvanR> this tutorial answers the question 'why should i make the effort to understand monads' with 'flexibility, now your program will be forced to separate imperative from functional code' how is that flexible ;)
09:00:43 <Cale> EvanR: Which tutorial?
09:00:48 <EvanR> all about monads
09:00:51 <kmc_> EvanR, that's a bad answer imo
09:00:55 <sproingie> there is a lot of flexibility in that, but having examples of that flexibility would be helpful
09:01:00 <kmc_> you should learn monads because many useful things are monads
09:01:02 <EvanR> kmc_: paraphrased answe r;)
09:01:06 <sproingie> besides. monads don't force any such thing
09:01:16 <kmc_> like parsers, nondeterministic computations, and software transactional memory
09:01:17 <EvanR> yeah, nevermind
09:01:22 <Cale> EvanR: Yeah, AAM has the nice property of going over the MTL monads and transformers pretty thoroughly, but I'm annoyed with the details.
09:01:34 <kmc_> EvanR, even in a language without enforced purity, monads are useful
09:01:46 <kmc_> for example they've been added to F#, and C# is lurching in that general direction
09:01:47 <sproingie> i have a lot of imperative code floating around, it's all sitting in the IO monad, and i have a lot of pure functions sprinkled in too
09:01:59 <Cale> EvanR: The real reason we care about monads is the reason we care about any programming abstraction. It lets us write code that works in an arbitrary monad.
09:02:01 <monochrom> The flexibility part is right. The final sentence is a wrong explanation. You gain flexibility because you can change the monad type on a whim.
09:02:35 <EvanR> the type system in haskell is the flexible part
09:02:38 <Cale> EvanR: So if we identify libraries which are monadic, we get all these additional functions (the stuff in Control.Monad and a number of other libraries) for free.
09:03:02 <kmc_> just as there are benefits to modeling parsers with a monad, there are benefits to modeling IO with a monad
09:03:05 <Cale> EvanR: So not every parsing library has to implement concatenation of lists of parsers, for example
09:03:09 <aavogt> the mtl specific monad classes are also nice
09:03:12 <kmc_> the latter are not a prerequisite for the former
09:03:27 <jmcarthur_work> Q: Why should I make the effort to learn monads? A: Like any good abstraction, it frees your mind for thinking about more important things than plumbing.
09:03:28 <aavogt> so you can write code for a   (Monad m, MonadState x m, MonadReader y m)
09:03:44 <kmc_> don't forget MonadCont ;)
09:03:49 <Cale> EvanR: The same code (the sequence function), gives us concatenation of parsers, sequencing of lists of IO actions, and Cartesian products of lists.
09:03:52 <kmc_> hmm we really do spend a lot of time talking about monads...
09:03:54 <aavogt> which works for any monad that lets you set state for x and han an environment of y
09:04:05 <kmc_> > sequence [[1,2],[3,4],[5,6]]
09:04:06 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
09:04:08 <jmcarthur_work> kmc_, only because the difficulty is overblown
09:04:09 <Cale> kmc_: It's because people spend a lot of time asking questions about them
09:04:17 <EvanR> just for reference is there anyone in here who is actually trying to decide to learn monads or asking why its important
09:04:18 <aavogt> but this is a general property of typeclasses
09:04:26 <jmcarthur_work> and the necessity
09:04:28 <aavogt> if you write them like that
09:04:34 <Cale> EvanR: I'd assumed you were learning about them.
09:04:45 <EvanR> yeah i am
09:04:56 <monochrom> I am spending time unexplaining monads.
09:05:18 <jmcarthur_work> EvanR, people who believe monads would be their primary stumbling block to learning haskell and would rather not waste the effort to learn haskell if they don't think they can learn monads
09:05:22 <lament> monochrom: can you write a tutorial on that?
09:05:32 <jmcarthur_work> usually just preconceptions *are* the primary stumbling block
09:05:38 <jmcarthur_work> *usually such
09:05:50 <monochrom> I already did. <monochrom> Just treat ">>=" and "return" as overloaded operators. I have never heard of programming students having problems with "+".
09:06:05 <MoALTz> i seriously wonder what someone taught haskell as their first (and only?) language would be like
09:06:22 <jmcarthur_work> like my wife
09:06:26 <Cale> monochrom: + is also an example where people are familiar with abstracting over it though.
09:06:34 <jmcarthur_work> she's not good with it yet, but she thinks imperative languages are pretty weird
09:06:41 <kmc_> monochrom, the problem is not the operators, but understaning what the type they operate over represents
09:07:05 <jmcarthur_work> she hates the idea that she has to worry about whether x is x or y
09:07:11 <monochrom> Or  http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming  for specifically IO, note it does not say "monad".
09:07:12 <EvanR> it seems theres no scarcity of tutorials on this subject
09:07:23 <MoALTz> interesting. what problems did she have with haskell? how cryptic were errors to her?
09:07:23 <EvanR> maybe if they called it something else people wouldnt be so scared ;)
09:07:52 <jmcarthur_work> MoALTz, i think the type system has been her biggest stumbling block, but these are issues she would have had in the absence of the type checker, too, of course
09:07:57 <jmcarthur_work> since the code wouldn't have worked
09:08:25 <jmcarthur_work> she has had no issue with polymorphism though
09:08:35 <jmcarthur_work> just the type checking generally
09:08:42 <Cale> I've usually found that there's a similar difficulty going from Haskell to imperative languages. (Though it's much smaller than going in the other direction.)  Another nice thing about teaching people Haskell first is that their imperative code is usually naturally well-designed.
09:08:55 <sproingie> i believe SPJ suggested Monad be replaced with "Warm Fuzzy Thing"
09:09:08 <c_wraith> Monster is still my favorite.
09:09:09 <jmcarthur_work> she doesn't even seem to have problems with combinators, though, which i would have thought would be problematic for somebody who had just learned what a programming language function is
09:09:14 <sproingie> ooh monster
09:09:27 <sproingie> nom = return
09:09:45 <sproingie> maybe that should be burp = return
09:09:50 <sproingie> nom = (>>=)
09:09:55 <copumpkin> omnom
09:10:07 <Cale> jmcarthur_work: I think we use higher order functions in English all the time :)
09:10:14 <jmcarthur_work> even my mother in law doesn't find simple haskell code that difficult (she is interested, actually)
09:10:18 <Cale> jmcarthur_work: They come really close to how we think, usually.
09:10:35 <monochrom> sproingie: http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
09:10:37 <jmcarthur_work> Cale, you must be right, based on the evidence i'm seeing
09:11:00 <QtPlaty[HireMe]> Cale: do they?
09:11:13 <jmcarthur_work> anyway, time to go make dinner for said wife
09:11:32 <Cale> QtPlaty[HireMe]: Yes. I think imperative programming beats it out of people, but we use similar things in natural language all the time.
09:11:51 <sproingie> monochrom: that's pure win
09:12:07 <monochrom> Yeah :)
09:12:42 <sproingie> to be fair, we use imperative constructs all the time in natural language
09:12:51 <Cale> Imperative languages -- specifically ones which don't have proper support for functions, make it impossible to define anything higher order, so you learn to tell the computer how to iterate over things and so on every time, as if it's some kind of child.
09:13:11 <Cale> You can't say "glue these things together end-to-end"
09:13:30 <sproingie> it's left implicit
09:13:50 <Cale> Or "pick out all the blue M&M's"
09:13:53 <sproingie> usually temporal.  "do this, then do that".  which imperative flow control models nicely
09:14:03 <monochrom> @quote monochrom bbq
09:14:04 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
09:14:11 <monochrom> @quote monochrom sausages
09:14:12 <lambdabot> No quotes match.
09:14:34 <geekles> is there a preferred method for installing haskell on ubuntu 9.10?
09:14:54 <sproingie> aptitude install ghc6
09:14:59 <tensorpudding> depends on if you want the ghc version in ubuntu's package manager, or the latest and greatest
09:15:03 <Cale> geekles: Personally, I would get the generic linux binary from the GHC website and install that.
09:15:06 <monochrom> I installed the http://www.haskell.org/ghc/dist/6.10.4/ghc-6.10.4-i386-unknown-linux-n.tar.bz2 manually
09:15:16 <EvanR> ive been in this channel for a few days, and i noticed that it never stops. its always a heated discussion about haskell and functional programming. a high concentration of sophistication. crazy!
09:15:17 <geekles> well, i'm just starting out, so i'm not sure what i want :)
09:15:17 <Cale> geekles: I don't trust Ubuntu with Haskell-related stuff.
09:15:18 <tensorpudding> you can grab the tarball and compile your own
09:15:34 <Cale> DON'T compile your own GHC.
09:15:40 <pastah_rhymez> my vty makes my terminal 'crash' (unrecoverable state i reached)
09:15:41 <Cale> Use the binary.
09:15:45 <sproingie> my ghc is hand-compiled
09:15:49 <tensorpudding> what's wrong with compiling ghc?
09:15:51 <geekles> i'm just gonna be using the "learn you a haskell" tute
09:15:53 <tensorpudding> besides that it is more involved
09:15:54 <pastah_rhymez> could someone please take a look?
09:15:56 <benmachine> it takes forever for a start :P
09:16:09 <tensorpudding> eh
09:16:14 <sproingie> had to be, needed the dynamic libs to keep the linker from going berzerk
09:16:17 <Cale> The only good reason to compile it yourself is if you're hacking on it. Otherwise it's just a gigantic waste of time.
09:16:19 <pastah_rhymez> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=13852#a13852
09:16:48 <Cale> (and well, maybe if you're on a strange platform and there are bugs you need to work around)
09:16:59 <tensorpudding> if the platform you are on doesn't have a binary
09:17:06 <monochrom> I know the car-mod type wants to compile everything themselves. I mean the gentoo type.
09:17:30 <tensorpudding> they like funrolling
09:17:31 <Cale> tensorpudding: Yeah -- if your platform doesn't have a binary, it sort of implies you're going to be hacking on GHC if you want to run it.
09:17:31 <sproingie> -vomit-frame-pointer
09:17:32 <geekles> yeah, i don't care so much about compiling at this point, was hoping there was a ppa
09:17:51 <tensorpudding> ghc is in ubuntu proper
09:17:55 <tensorpudding> but it might be an old version
09:17:58 <c_wraith> geekles:  http://davidsiegel.org/haskell-platform-in-karmic-koala/
09:18:06 <sproingie> it's pretty well up to date
09:18:07 * EvanR vomits the frame pointer all over sproingie 
09:18:09 <monochrom> Yes there is a ppa.
09:18:11 <tensorpudding> there is haskell platform tooo
09:18:18 <pastah_rhymez> tensorpudding: the version in ubuntu doesn't support CTRL+L
09:18:19 <Cale> geekles: mm... well, in Ubuntu 9.10, there's at least a GHC 6.10.4, but I've heard of people having problems with it.
09:18:24 <pastah_rhymez> for clearing the screen in GHCI
09:18:29 <tensorpudding> pastah_rhymez: what is ctrl+L?
09:18:40 <pastah_rhymez> (so i installed it manually)
09:18:45 <sproingie> Cale: i've had zero problems with it and i've compiled all kinds of junk
09:18:48 <tensorpudding> ooh, so 9.10 does have the latest
09:18:48 <pastah_rhymez> tensorpudding: try it in a terminal :p
09:18:51 <c_wraith> the version in ubuntu has all kinds of problems with haskeline, I admit
09:18:56 <geekles> haskell-platform? is that like a batteries included type of thing?
09:19:03 <sproingie> c_wraith: not that i've seen
09:19:09 <tensorpudding> it would appear to clear the screen
09:19:16 <monochrom> yes
09:19:18 <Cale> haskell-platform is really intended for the package managers of distributions, from what I understand
09:19:25 <pastah_rhymez> geekles: that's not really useful if you're running linux
09:19:31 <pastah_rhymez> but great for OSX or windows
09:19:39 <sproingie> i mostly run ghci inside emacs, so i might not run into all the problems
09:19:43 <pastah_rhymez> at least that's how i understood it
09:19:59 <tensorpudding> haskell platform is nice if you want a decent sized set of maintainer-blessed libraries out of the box
09:20:00 <Cale> sproingie: Yeah, that probably protects you from problems with the line editor.
09:20:14 <kmc_> to clear the screen in ghci i use :!clear
09:20:15 <tensorpudding> i also mostly run ghci in emacs
09:20:18 <ivanm> Cale: is it? I thought it was for people that didn't have package managers (or starting off and not knowing which libraries to use)
09:20:48 <tensorpudding> but most of those libraries are available in ubuntu through apt
09:20:53 <Cale> ivanm: Well, I mean that the Debian/Ubuntu people would pick up the Haskell platform stuff and make .debs out of it.
09:20:56 <tensorpudding> and all of them are available through cabal and cabal-install
09:21:03 <ivanm> Cale: well, at the very least
09:21:08 <ivanm> hopefully they do more than that
09:21:14 <sproingie> the debian folks would probably prefer to unbundle most of the packages
09:21:26 <ivanm> sproingie: maybe a meta package
09:21:27 <Cale> sproingie: Which is really super annoying.
09:21:28 <monochrom> heh
09:21:30 <ivanm> that's what we do in gentoo
09:21:31 <geekles> tensorpudding, you use haskell mode then? it's pretty nice?
09:21:31 <sproingie> license politics alone probably demands it
09:21:33 <ivanm> Cale: why?
09:21:39 <ivanm> geekles: yes, it is
09:21:40 <tensorpudding> geekles: it's nice enough
09:21:45 <c_wraith> I'm pretty sure the debian philosophy is "the more packages you split it into, the better"
09:21:45 <ivanm> sproingie: heh, true
09:21:48 <tensorpudding> you can do neat things with it
09:21:52 <ivanm> c_wraith: heh
09:22:01 <tensorpudding> it integrates with an inferior ghci process well
09:22:08 <ksf> THERE CAN ONLY BE TWO
09:22:12 <tensorpudding> so you can test things without leaving emacs
09:22:15 <Cale> ivanm: Because it means that scripts can't assume that because someone has GHC, they also have the libraries that normally come with GHC. So people end up wondering why the cabal-install bootstrap script isn't working, for example.
09:22:24 <ivanm> tensorpudding: isn't it amazing how fast development of haskell-mode has progressed now that stefan monnier is definitely too busy to maintain it? ;-)
09:22:26 <tensorpudding> there is some nice typechecking bits too
09:22:39 <ivanm> Cale: the bootstrap scripts downloads what it needs...
09:22:40 <ksf> looking at the implementation list of future web standards, internet exploder and opera are going to die
09:22:43 <tensorpudding> ivanm: i haven't been using the mode very long
09:22:50 <ivanm> Cale: in gentoo, AFAIK we've _never_ bundled extralibs with ghc
09:22:53 <Cale> ivanm: Except if that's network, iirc.
09:22:54 <ivanm> tensorpudding: ahhh
09:22:57 <Cale> ivanm: Or mtl
09:23:01 <ivanm> Cale: hmmm...
09:23:04 <tensorpudding> it has so far been enough for me
09:23:04 <Cale> I forget which ones it needs
09:23:12 <tensorpudding> ksf: opera, die?
09:23:22 <ivanm> @where cabal-install
09:23:23 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
09:23:26 <ksf> yep. mozilla and webkit will prevail.
09:23:34 <Cale> But there were some packages that you needed to install aside from GHC on Ubuntu/Debian in order for the script to work.
09:23:44 <sproingie> opera's future does seem doubtful since webkit is displacing its most ubiquitous niche
09:23:56 <ksf> and then there's going to be monica, the warm and fuzzy haskell web platform.
09:23:58 <tensorpudding> opera still has a unique and useful UI
09:23:59 <sproingie> i imagine it'll soldier on for some years yet
09:24:00 <Cale> I think that at least the GHC package ought to depend on all the GHC-bundled library packages.
09:24:15 <ksf> tensorpudding, does it have a modal interface with vi key bindings?
09:24:22 <tensorpudding> no
09:24:24 <ivanm> OK, bootstrap gets: http, zlib
09:24:25 <sproingie> opera's UI is largely moot when it comes to mobile devices
09:24:28 <ksf> so it's not useful.
09:24:48 <tensorpudding> it is possible that you could extend Opera to use such a UI
09:25:00 <ivanm> but assumes network
09:25:00 <ksf> sproingie, but it doesn't have the user base to zombie around like ie6.
09:25:02 <tensorpudding> but the people who want a modal interface with vikeys is small
09:25:06 <Cale> ivanm: Right, and cabal-install needs lots of the GHC-default packages to compile.
09:25:09 <ivanm> Cale: so the bootstrap script isn't that bootstrappy
09:25:12 <Cale> yeah
09:25:17 <ivanm> Cale: GHC-default /= extralibs IMHO
09:25:23 <ksf> ...and ie6 is going to die really soon, I've heard webdevs are dropping support.
09:25:27 <tensorpudding> compared to the number of people who want a fast, stable and usable-by-default browser
09:25:27 <sproingie> ksf: i suspect some company will buy it just to have their own browser IP
09:25:37 <ivanm> ksf: its dead upstream
09:25:44 <ivanm> and many sites have dropped support
09:26:03 <ksf> there's not going to be properitary webbing, anymore.
09:26:04 <monochrom> network ∉ ghc\extralibs
09:26:04 <ivanm> ksf: so it sucks to be working somewhere where you can't install a different browser, and are stuck with XP-default IE6 :s
09:26:13 <sproingie> wow suckage
09:26:14 <ivanm> monochrom: isn't it? hmmm...
09:26:24 <ivanm> monochrom: oh, and show-off ;-)
09:26:25 <ksf> google will push chrome too much for anyone to be able to keep up
09:26:26 <tensorpudding> IE6 is pretty much bronze-age browsing by now
09:26:37 <sproingie> too bad you can't turn chromeframe on by default
09:26:46 <ksf> ...and ms is going to cross out the "I" from Internet Explorer.
09:27:03 <Cale> ivanm: I don't know. I just think that it's silly that the Debian people pick packages apart until they're nearly broken and you have to sort of discover which other packages to install to make them function normally.
09:27:07 <sproingie> didn't they try that ages ago?
09:27:08 <ksf> "Mammon awoke, and lo! it was naught but a follower."
09:27:17 <Zao> ksf: Nternet Explorer?
09:27:20 <Cale> (i.e. as if you'd just downloaded the binaries from upstream)
09:27:24 <ksf> explorer
09:27:25 <ivanm> Cale: in gentoo we do that
09:27:26 <tensorpudding> somewhat of a tangent, they finally released a linux beta for google chrome
09:27:28 <kmc_> "there's not going to be properitary webbing, anymore."
09:27:28 <ivanm> and there's no problem
09:27:34 <kmc_> what about IE >6?
09:27:39 <ksf> that's the prophecy that about:mozilla speaks, and it's true.
09:27:39 <sproingie> they'll probably call it "Live Explorer"
09:28:05 <tensorpudding> my opinion: firefox is an old hat and desperately needs to be refactored
09:28:20 <EvanR> chrome/iron ftw
09:28:26 <sproingie> iron?
09:28:34 <tensorpudding> iron is a repackaging of chromium
09:28:35 <ksf> it's a lot more general than webkit, though.
09:28:35 <EvanR> its in the arch repo
09:28:44 <ksf> ...all that xpi stuff.
09:28:50 <Cale> tensorpudding: Finally? I've had it around for a while now :)
09:29:00 <tensorpudding> with no google privacy stuff, and with an ad-blocker put on
09:29:03 <Cale> I guess it did take them a while.
09:29:06 <DaveS> firefox is old hat compared to what?
09:29:19 <EvanR> chromium
09:29:25 <Cale> tensorpudding: Does the ad-blocker work as well as ABP?
09:29:33 <tensorpudding> Cale: you were probably using the development snapshots
09:29:34 <DaveS> EvanR: The stats disagree
09:29:53 <EvanR> is a type constructor a function?
09:30:01 <copumpkin> EvanR: not always
09:30:03 <Cale> I found an "implementation" of ABP for chrome that appeared to use the same subscription lists, but it didn't seem to block everything that ABP did.
09:30:06 <tensorpudding> @type (:)
09:30:08 <lambdabot> forall a. a -> [a] -> [a]
09:30:21 <sproingie> like the privacy stuff in iron, but i really wish it put google suggest back
09:30:28 <tensorpudding> Chrome still needs work, yes
09:30:33 <sproingie> you're sending your search to google *anyway*
09:30:41 <tensorpudding> but the guts of Chrome are pretty shiny
09:30:42 <Cale> sproingie: indeed
09:30:47 <DaveS> All browsers other than IE and Firefox account for something like 10%
09:30:53 <kmc_> EvanR, a *type* constructor is never a function
09:31:00 <EvanR> ok thats good
09:31:09 <kmc_> a *data* constructor is always a function
09:31:13 <copumpkin> kmc_: depends how you define functions :P
09:31:14 <kmc_> and sometimes they have the same name
09:31:16 <tensorpudding> browsers are probably better for #haskell-blah
09:31:17 <copumpkin> is * -> * a function?
09:31:20 <EvanR> so the return method for a monad is not a type constructor
09:31:21 <Cale> I would definitely use Chrome if I just had equivalents of a few more of the plugins that I have in Firefox.
09:31:41 <sproingie> noscript FTW
09:31:41 <Cale> EvanR: Type constructors live on the other side of the ::
09:31:42 <kmc_> EvanR, nor is it a value constructor, syntactically.  it might however be equal to a value constructor
09:31:43 <tensorpudding> I never used any of Firefox's plugins
09:31:46 <kmc_> as with Maybe
09:31:49 <Cale> I don't use noscript.
09:31:51 <kmc_> in Maybe, return = Just
09:31:56 <sproingie> i use noscript as an annoyance remover
09:31:59 <tensorpudding> except ad-block, which I don't miss
09:32:03 <monochrom> lazy people don't move over to #haskell-blah
09:32:05 <pastah_rhymez> tensorpudding: WHAT!
09:32:13 <kmc_> EvanR: every constructor (value or type) starts with an uppercase letter
09:32:14 <ivanm> sproingie: I use ghostery, adblock plus and RIP as an annoyance remover
09:32:18 <ivanm> oh, and flashblock
09:32:19 <pastah_rhymez> tensorpudding: --> #haskell-blah
09:32:23 <sproingie> seq move-to-haskell-blah
09:32:27 <Cale> And SkipScreen
09:32:42 <EvanR> kmc_: ok makes sense. now i wish 'all about monads' didnt call return :: a -> m a  a type constrcutor ;)
09:32:47 <kmc_> > Maybe 3 -- attempting to use a type constructor as a value constructor
09:32:51 <kmc_> EvanR, where does it say that?
09:33:04 <Cale> oh, and BugMeNot is occasionally handy, though I could live without that one
09:33:09 <lambdabot>   Not in scope: data constructor `Maybe'
09:33:10 <kmc_> @bot
09:33:10 <lunabot>  :o
09:33:11 <lambdabot> :)
09:33:37 <EvanR> kmc_: 'maybe a monad'
09:33:40 <Cale> CustomizeGoogle is one which would also be nice :)
09:33:40 <monochrom> You are now giving me enough excuses to condemn "all about monads". I never liked it, but I didn't find enough good reasons to say it.
09:34:02 <kmc_> i like AAM
09:34:05 <ivanm> Cale: except customizegoogle is almost useless now
09:34:05 <Cale> monochrom: The examples are another reason to condemn it
09:34:09 <ivanm> since filtering doesn't work :(
09:34:16 <ivanm> (any more)
09:34:24 <Cale> ivanm: Filtering?
09:34:30 <kmc_> EvanR, I think you are misreading it
09:34:30 <sproingie> my favorite is the old one that introduces the state monad from first principles and calls the constructor ST
09:34:36 <sproingie> that one confused me for a long time
09:34:36 <kmc_> "We have seen that a monad is a type constructor, a function called return, and a combinator function called bind or >>=."
09:34:41 <kmc_> that's a list of three things
09:34:41 <EvanR> -- return is a type constructor that creates monad instances
09:34:44 <sproingie> when i ran into the real ST that is
09:34:46 <ivanm> customizegoogle used to let you filter out results from certain domains, so I filtered out expertsexchange, etc.
09:34:47 <Cale> Oh, filtering search results? I actually never used that feature of it.
09:34:55 <kmc_> ah, okay
09:34:56 <ivanm> but with the new "wiki" style for google, it doesn't work
09:34:59 <kmc_> that is basically wrong
09:35:04 <Aszstal> ivanm: removing the URL interception is enough reason for me to use it
09:35:08 <ivanm> Cale: there's a bookmarklet for bugmenot as well
09:35:12 <ivanm> Aszstal: true
09:35:14 <kmc_> they're using some nonstandard definition of "type constructor"
09:35:28 <Cale> ivanm: There were some funny differences between the BugMeNot plugin and the actual website.
09:35:30 <sproingie> it's true for trivial monads like Maybe
09:35:34 <EvanR> kmc_: yeah..
09:35:55 <Cale> ivanm: In particular, the plugin often works when the website says that the given site has forbidden the use of BugMeNot
09:36:05 <kmc_> then where would you go for an expert sex change
09:36:23 <tensorpudding> @google expert sex change
09:36:24 <lambdabot> http://en.wikipedia.org/wiki/Experts-Exchange
09:36:24 <lambdabot> Title: Experts-Exchange - Wikipedia, the free encyclopedia
09:36:30 <Cale> lol
09:40:37 <fracture> is there a tool for making Makefile dependency graphs of .hi files for ghc?
09:41:02 <kmc_> ghc -M ?
09:41:46 <fracture> oh
09:41:47 <fracture> neat.
09:41:49 <fracture>   :)
09:42:17 <kmc_> but you should be using ghc --make anyway ;)
09:42:35 <joe____> is there a function to convert: m a -> m ()
09:42:37 <fracture> oh
09:42:38 <fracture> nice :)
09:42:42 <fracture> thanks
09:42:43 <kmc_> :t (>> return ())
09:42:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
09:43:36 <joe____> thanks kmc_
09:44:03 <diego1> :t (>>=)
09:44:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:44:20 <diego1> he.. nice
09:45:22 <diego1> i wonder what else can lambdabot do :-D
09:45:49 <kmc_> @nixon
09:45:49 <lambdabot> Once you get into this great stream of history, you can't get out.
09:46:00 <Woof> @karma diego1
09:46:00 <lambdabot> diego1 has a karma of 0
09:46:10 <Woof> @karma + diego1
09:46:10 <lambdabot> + has a karma of 90
09:46:18 <Woof> @karma diego1 +1
09:46:18 <lambdabot> diego1 has a karma of 0
09:46:20 <kmc_> @djinn (a -> b) -> (c -> d) -> (a,b) -> (c,d)
09:46:20 <lambdabot> -- f cannot be realized.
09:46:28 <Woof> @karma+ diego1
09:46:29 <lambdabot> diego1's karma raised to 1.
09:46:30 <kmc_> @djinn (a -> c) -> (b -> d) -> (a,b) -> (c,d)
09:46:31 <lambdabot> f a b (c, d) = (a c, b d)
09:46:49 <kmc_> @quote kleisli
09:46:49 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
09:48:59 <monochrom> It is really too bad that people don't consult the ISO registry before using names, eh?
09:49:27 <monochrom> Like you first learned about "map" then you became confused at "Map".
09:50:56 <ivanm> there's a registry of names for what to call functions and data structures?
09:51:21 <monochrom> and math terminology, and compsci nomenclature
09:51:46 <monochrom> to ensure that "functor" does not have 3 meanings, for example
09:53:56 <Cale> The council of mathematics gnomes.
09:54:29 <Cale> Who interpret the golden plates passed down from the heavens containing all the definitions and their appropriate distinct names.
09:55:37 <tensorpudding> Who is the Joseph Smith of Haskell?
09:56:09 <stroan> Simon P. Jones?
09:56:22 <BMeph> tensorpudding: Better yet, "Who is the Angel Moroni of Haskell?" ;p
09:56:49 <tensorpudding> Who is the Brigham Young of Haskell?
09:57:05 <Cale> Platonism is so silly :)
09:57:27 <tensorpudding> I actually would rather not associate Haskell with the LDS church
09:57:29 <DerisionSnort> @pl \f -> f . f
09:57:29 <lambdabot> join (.)
09:57:33 <DerisionSnort> :t join
09:57:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:57:42 <DerisionSnort> @src join
09:57:42 <lambdabot> join x =  x >>= id
09:57:49 <ivanm> tensorpudding: agreed
09:57:52 <DerisionSnort> :t >>=
09:57:53 <lambdabot> parse error on input `>>='
09:57:58 <DerisionSnort> :t (>>=)
09:57:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:58:02 <Cale> (almost but not quite as silly as mormonism :)
09:58:29 <tensorpudding> well, the Mormons had polygamy, and the Haskellites had polymorphism
09:58:36 <Cale> ahaha
09:58:41 <EvanR> both are awesome
09:58:42 <ziman> Mormonad m
10:00:07 <DerisionSnort> @pl \f -> f `g` f
10:00:08 <lambdabot> join g
10:00:10 <DerisionSnort> ah
10:04:09 <joe____> i have a fundamental question about haskell's hunit
10:04:18 <joe____> can it test imperative functions?
10:05:02 <joe____> I need to test something on a usbdevice and my actions are : "send command to device", "read input from device" and match the input read with an expected result
10:06:41 <kmc_> by "imperative function" you mean a function that returns an IO action?
10:07:25 <joe____> or instead of having a test for each sequence of actions, should I pull out the input and read commands out?
10:07:25 <joe____> and then just compare the results with Hunit?
10:07:43 <kmc_> i'm pretty sure you can test IO, since TestCase takes an IO ()
10:07:48 <kmc_> but i haven't used HUnit
10:08:08 <joe____> I mean a function that does something and returns a "Test".
10:08:31 <kmc_> functions never "do" anything
10:08:31 <joe____> I think I will do all the IO actions first without the test framework and then compare the results in the test framework.
10:08:38 <kmc_> a function can return a description of how to do something
10:08:41 <joe____> I am getting confused with the types.
10:08:44 <kmc_> joe____, that sounds sensible
10:08:59 <joe____> ok, thanks.
10:18:53 <geekles> so i did a cabal update and was prompted to 'cabal install cabal-install' which i did, but then running another cabal update, it says that cabal-install is still an older version than what is available
10:19:09 <geekles> am i using the wrong PATH?
10:19:31 <SamB_XP_> geekles: I suspect it just didn't give you a good enough suggestion
10:19:46 <SamB_XP_> perhaps you need to specify the version to install more explicitly
10:20:54 <geekles> it says the executable was installed in ~/.cabal/bin but a 'which cabal' shows /usr/local/bin
10:21:33 <geekles> how would i specify a version for install? cabal install cabal-install 0.6.4?
10:21:44 <SamB_XP_> geekles: oh, then I guess you were right in the first place
10:21:46 <geekles> err cabal-install-0.6.4
10:21:57 <c_wraith> geekles: did you use the instructions I linked to?  It will end up in that state, if you did.  sadly.
10:22:16 <geekles> yeah, i did use those linked instructions
10:22:35 <geekles> so i just need to prepend ~/.cabal/bin to my PATH?
10:22:41 <c_wraith> that should work
10:23:05 <ivanm> @tell Baughn in haskell-mode, "-->" and everything afterwards gets highlighted as a comment (when it isn't)...
10:23:05 <lambdabot> Consider it noted.
10:23:07 <geekles> ok, had no idea what cabal was before following those instructions, lol
10:23:57 <c_wraith> cabal is really nice.  When you get to the point where you start using multiple source files, you probably should use it
10:24:26 <ray> when you start uploading your wonderful wondeful stuff to hackage
10:25:12 <geekles> hackage? is that a git hub for the haskell?
10:26:02 <aavogt> no, it's more like CPAN
10:26:22 <geekles> for future reference, fixing the PATH worked, it's now using ~/.cabal/bin
10:27:03 <geekles> aavogt, cool
10:27:15 <geekles> so cabal is pulling from hackage then?
10:27:23 <aavogt> yes
10:27:39 <c_wraith> cabal is both a package manager (using hackage on the backend) and a build system.
10:27:51 <c_wraith> There are definite good points to it being both.
10:28:17 <c_wraith> ...  on the down side, it has no real concept of removing a package that it's installed
10:30:28 <c_wraith> bah...  "The mtl-1.1.0.2/Setup script does not exist or cannot be run" when running make install after configure and make in haskell platform
10:30:44 <c_wraith> there is a file in that director named Setup.hs
10:30:46 <geekles> so is haskell the red pill? i keep hearing mind-bomb references about it... i'm coming from a ruby and lisp background
10:31:53 <ray> haskell is the asprin, acetaminophen, and caffeine general painkiller
10:33:03 <geekles> it looks kinda fun in print
10:33:06 * SamB_XP_ tries to remember what it was that SPJ was saying about aspirins
10:33:12 <c_wraith> wtf.  it looks like...  make should have built Setup
10:33:19 <c_wraith> But for some reason, make skipped mtl
10:39:59 <Poulter> Hey... what's the best way to split a sentence in Haskell?
10:40:15 <QtPlaty[HireMe]> Poulter: Into what?
10:40:15 <c_wraith> into what?
10:40:35 <c_wraith> > words "This may be what you're looking for."
10:40:36 <lambdabot>   ["This","may","be","what","you're","looking","for."]
10:40:53 <Poulter> I'll stop typing
10:40:55 <Poulter> lol
10:40:57 <Poulter> kk
10:41:09 <Poulter> words "Thank you kindly c_wraith"
10:41:19 <Poulter> > words "Thank you kindly c_wraith"
10:41:21 <lambdabot>   ["Thank","you","kindly","c_wraith"]
10:41:29 <Poulter> thanks
10:41:35 <c_wraith> you're welcome
10:43:58 <shachaf> > map text . words $ "Then the bowsprit got mixed with the rudder sometimes"
10:43:59 <lambdabot>   [Then,the,bowsprit,got,mixed,with,the,rudder,sometimes]
10:44:29 <Poulter> Okay, that's cool
10:49:27 <stroan> does one refer to the codomain of a functor?
10:49:34 <stroan> or is there another term for it
10:49:49 <copumpkin> I'd call it that
10:50:01 <copumpkin> since it's just a morphism in another category
10:50:30 <stroan> cheers
10:50:35 <c_wraith> wow, the build scripts for haskell platform are really fragile
10:52:58 <Cale> Er, the codomain of a functor is some category
10:53:29 <Cale> For example, every instance of the Functor class in Haskell represents a functor whose domain and codomain are both Hask.
10:53:51 <yoneda> stroan: when you are viewing the two categories in the category of small  categories, the the functors are morphisms
10:53:51 <lambdabot> yoneda: You have 1 new message. '/msg lambdabot @messages' to read it.
10:54:27 <tensorpudding> does that not work for large categories?
10:54:35 <raceRider> @type map
10:54:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:54:37 <Cale> Nobuo Yoneda is IRCing from beyond the grave!
10:55:13 <yoneda> drop the small doesn't matter
10:57:09 <yoneda> the idea of a functor predates the idea of a category in which functors are morphisms.
10:57:18 <stroan> Cale: the codomain is a subcategory of Hask isn't it?
10:57:30 <copumpkin> yoneda: why is your theorem just a lemma?
10:57:42 <Cale> stroan: If you'd like to consider it that, but Hask itself will always do.
10:57:52 <yoneda> The codomain is Hask its an endofunctor
10:57:57 <tensorpudding> a lot of the interesting functors are between large categories like Grp, Top, Rng
10:58:15 <Cale> stroan: You really want to consider the codomain to be Hask itself, so that you can compose them :)
10:58:34 <stroan> :)
10:58:35 <yoneda> a lemma is a theorem, it's just that its 'helpful' to the Greeks
10:59:00 <Cale> Oh, interesting, apparently Yoneda worked on ALGOL.
10:59:03 <yoneda> yes what cale said, the wikibook is all wet on this
10:59:23 <copumpkin> yoneda: yeah, but it feels less important when called a lemma
10:59:30 <copumpkin> as if it's secondary to something else
10:59:33 <yoneda> we were all working on algol in those dats
10:59:39 <yoneda> days
10:59:43 <SamB_XP> copumpkin: I think a lot of theorems in Coq just get called Lemma?
10:59:54 <ddarius> copumpkin: A lemma is like a subprogram.  A theorem is like a program.
10:59:57 <Cale> I think the Yoneda lemma should be called the completion theorem for categories.
10:59:59 <copumpkin> yeah
11:00:01 <raceRider> @type list
11:00:02 <lambdabot> Not in scope: `list'
11:00:08 <raceRider> @type zip
11:00:09 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
11:00:10 <fracture> I have a problem that I would normally solve with runtime polymorphism (virtual functions, etc)...  what's the haskelly way to approach that?
11:00:16 <ddarius> copumpkin: The Yoneda lemma is called a lemma because it was just a supporting result for some theorem.
11:00:27 <Cale> fracture: What is the actual problem?
11:00:41 <copumpkin> ddarius: and the theorem has since been forgotten but the lemma lived on?
11:00:56 <tensorpudding> a lot of useful results are named lemmas
11:00:56 * copumpkin just wrote heterogeneous vectors in agda, but they feel ugly :(
11:00:57 <Cale> fracture: Possibly records of partially applied functions.
11:01:12 <stroan> copumpkin: how is agda compared to Coq?
11:01:12 <fracture> Cale: I have a main loop in this tetris clone I made, and I'm adding different sorta mode situations (e.g. when it is game over or if I added a title screen, etc)
11:01:16 <tensorpudding> like urysohn's lemma
11:01:24 <copumpkin> stroan: never played with coq much beyond the basic tutorial
11:01:28 <fracture> which need different rendering/update routines and will obviously have different state data
11:01:33 <tensorpudding> or zorn's lemma
11:01:34 <copumpkin> lemmata!
11:01:45 <Cale> fracture: If you can decide what operations you'd like the values to have in common, and want to treat them as the same type (what you'd handle as an up-cast in OO), then you can encode your values as records of the operations partially applied.
11:01:50 <fracture> Cale: I was thinking something like that, but I don';t know how to type the functions so that I don't have to throw *all* possible state data into my main state object
11:02:05 <Cale> fracture: You put the state into the functions themselves.
11:02:11 <fracture> ah hmm
11:02:15 <copumpkin> my heteogeneous vectors are parametrized by vectors of types
11:02:20 <yoneda> we keep calling it a lemma because its useful not for some theorem, but for many, it means like tool or helper you use it again and again
11:02:24 <copumpkin> but they're different vectors :(
11:02:37 <fracture> ah I think I understand
11:02:40 <ddarius> tensorpudding: There are a lot of useful programs that are called subprograms.
11:02:52 <Cale> yoneda: But I think it's actually important enough to be called a theorem if you look at it the right way.
11:02:54 <fracture> assuming I get it, that's really cool...  (now to go try it)
11:02:56 <yoneda> my teacher keeps saying "and now we hit it with yoneda"
11:03:07 <SamB_XP> WHACK
11:03:13 <ddarius> I don't even bother explicitly invoking Yoneda in most cases.
11:03:23 <SamB_XP> you know what they say about hammers ...
11:03:31 <yoneda> yeah, just hit it with yoneda
11:05:30 <yoneda> the categorists exhibit an undercurrent of violence.  I watched the Catster video about the Eckmnn Hilton argument, and Prof. Chu was like "now we hit it with the unit laws"
11:05:45 <ddarius> Cheng?
11:05:55 <yoneda> Eugenia
11:06:06 <ddarius> Yes, Eugenia Cheng
11:06:15 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13856#a13856
11:06:17 <joe____> is there a function that can do (a,b,c) -> (b,c)
11:06:17 <joe____> more like tail and snd, but for a 3 tuple element?
11:06:26 <copumpkin> joe____: not a built-in one
11:06:29 <ddarius> joe____: \(a,b,c) -> (b,c)
11:06:33 <yoneda> getting dim up here in paradise  lost the 'a' on my keyboard,,,
11:06:35 * hackagebot upload: dbus-core 0.7 - Low-level D-Bus protocol implementation (JohnMillikin)
11:06:42 <joe____> copumpkin ,thanks
11:06:52 <joe____> ddarius, that's smart.. will check it out..
11:06:59 <tensorpudding> better would be \(_,b,c) -> (b,c)
11:07:08 <copumpkin> tensorpudding: better :o
11:07:15 <tensorpudding> since you don't need to bind the a since you're not using it
11:07:16 <SamB_XP> yoneda: so, are you named after the lemma or is the lemma named after you ... or are you merely related ?
11:07:49 <copumpkin> 米田
11:07:52 <yoneda> there's  a weak relation, not identity not isomorphism
11:08:05 <copumpkin> an adjunction?
11:08:22 <yoneda> still too strong copumpkin
11:08:27 <copumpkin> ooh
11:08:41 <SamB_XP> the trivial relation ?
11:08:44 <yoneda> i'm liking my irc name i must say
11:08:53 <dcestari> hello
11:09:01 <yoneda> \x y -> True
11:09:15 <copumpkin> that's so binary
11:09:24 <SamB_XP> yoneda: I'll take that as "yes"
11:09:31 * ddarius isn't sure which relation is the "trivial" one.
11:09:38 <SamB_XP> ddarius: that one
11:09:45 <copumpkin> why not \x y -> False?
11:09:50 <ddarius> Indeed.
11:09:50 <yoneda> i wasn't answering just formulating the question
11:09:52 <SamB_XP> that's the empty relation
11:09:54 <copumpkin> is that the empty relation?
11:10:03 <ddarius> Yes, which is arguably "trivial"
11:10:12 <tensorpudding> id is pretty trivial
11:10:19 <dcestari> is there a way to write a "where otherwise = " like? to avoid irrefutable patterns?
11:10:19 <SamB_XP> but, my way you can say that x and y are trivially related
11:10:34 <yoneda> why would you deny it's empty -- or are you denying its a relation>
11:10:47 <tensorpudding> > otherwise
11:10:48 <lambdabot>   True
11:10:57 <tensorpudding> otherwise is just an alias for True
11:11:27 <ksf> hmmm. I don't think a 2.4MiB .yca file is going to result in a web-compatible .js file.
11:11:39 <ksf> anyway, what I'm doing right now is pure insanity.
11:11:43 <yoneda> > otherwise || otherwise
11:11:44 <tensorpudding> it only exists as a prettier way of catching at the end of the guard pattern
11:11:44 <lambdabot>   True
11:11:55 <tensorpudding> > False || otherwise
11:11:56 <lambdabot>   True
11:12:04 <yoneda> ok, our relation is \x y -> otherwise
11:12:13 <SamB_XP> lol
11:12:27 <ddarius> :t \x y -> orElse
11:12:28 <lambdabot> forall t t1 a. t -> t1 -> Maybe a -> Maybe a -> Maybe a
11:12:34 <ksf> I took the html1 dtd, generated a haskell dtd from it, constructed a minimal page and print it with showXML, and am actually attempting to run that on the browser.
11:12:48 <yoneda> > (\x y -> otherwise) "yoneda" "lemma"
11:12:49 <lambdabot>   True
11:13:12 <SamB_XP> ksf: hmm???
11:13:18 <tensorpudding> > (\_ _ -> undefined) "oh" "noes"
11:13:19 <lambdabot>   * Exception: Prelude.undefined
11:13:38 <SamB_XP> ksf: I thought minimal pages were a lot smaller than the figure you just mentioned ...
11:13:54 <yoneda> :t orElse
11:13:56 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
11:14:00 <ksf> well, it seems to compile the whole adt.
11:14:05 <dcestari> forgetit
11:14:10 <dcestari> forget** it
11:14:11 <Cale> whoops, sorry about that :)
11:14:16 <copumpkin> @src orElse
11:14:16 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:14:25 <dcestari> I used a case <expression> of
11:14:29 <dcestari> :t case
11:14:30 <lambdabot> parse error (possibly incorrect indentation)
11:14:32 <ksf> it's not just something that can represent xhtml, it's _exactly_ xhtml.
11:14:47 <Cale> dcestari: case is a keyword
11:15:08 <ksf> and the compiler doesn't seem to get that I'm only constructing a small part of what's possible.
11:15:34 <dcestari> Cale: how can lambdabot point to case's documentation?
11:16:04 <copumpkin> it can't
11:16:08 <Cale> dcestari: It can't. I suppose it could give you a link to the Haskell report.
11:16:10 <Cale> @where report
11:16:11 <lambdabot> http://www.haskell.org/onlinereport/
11:16:22 <dcestari> @where case
11:16:23 <lambdabot> I know nothing about case.
11:16:27 <Cale> It's a basic language feature
11:16:32 <dcestari> hehe, ok
11:16:34 <yoneda> > Nothing `orElse` Just True
11:16:35 <lambdabot>   Just True
11:16:37 <aavogt> @where anything
11:16:37 <lambdabot> I know nothing about anything.
11:16:39 <Cale> (Not a library function)
11:16:51 <dcestari> hehehe, good one aavogt
11:16:59 <copumpkin> @hoogle orElse
11:16:59 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
11:17:08 <ksf> the actual idea is to veryfy against the xhtml dtd statically, at compile time, so that the javascript won't ever trigger any dom-related exceptions in the browser.
11:17:14 <Cale> That's about all that can be known about *anything*.
11:17:57 <Cale> @djinn forall a. a
11:17:57 <lambdabot> -- f cannot be realized.
11:18:33 <yoneda> what can be known about *anything* is what is called a "theorem for free"
11:18:44 <SamB_XP> @free otherwise
11:18:46 <lambdabot> otherwise = otherwise
11:18:57 <SamB_XP> @free undefined
11:18:59 <lambdabot> f undefined = undefined
11:19:04 <Cale> :O
11:19:15 <tensorpudding> what is @free?
11:19:15 <Cale> That free theorem is false!
11:19:19 <SamB_XP> @free unsafePerformIO
11:19:20 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `unsafePerformIO'\n\n"
11:19:33 <SamB_XP> @free f
11:19:35 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
11:19:41 <SamB_XP> @free x
11:19:42 <lambdabot> x = x
11:19:48 <SamB_XP> @free y
11:19:49 <lambdabot> y = y
11:19:50 <SamB_XP> @free z
11:19:52 <lambdabot> z = z
11:19:53 <yoneda> right, excellent
11:19:59 <tensorpudding> @free id
11:19:59 <Cale> @free map
11:20:00 <lambdabot> f . id = id . f
11:20:01 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
11:20:06 <SamB_XP> @free xs
11:20:06 <Cale> @free foldr
11:20:07 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `xs'\n\n"
11:20:08 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
11:20:09 <ksf> SamB_XP, the XHTML adt source is 1.4megs, which gets compiled to 4.2megs worth of yhc core, the final app has a 2.4meg linked core file.
11:20:15 <Cale> SamB_XP: wtf
11:20:22 <SamB_XP> Cale what ?
11:20:26 <yoneda> @free wtf
11:20:27 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `wtf'\n\n"
11:20:34 <SamB_XP> @free conal
11:20:36 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `conal'\n\n"
11:20:38 <blackdog> is there a way of catching arerror in Haskell? undefined, bad index, errors, exceptions, everything?
11:20:39 <SamB_XP> aww
11:20:41 <tensorpudding> @free bird
11:20:41 <Cale> SamB_XP: why are you asking for free theorems of variables?
11:20:42 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `bird'\n\n"
11:20:47 <blackdog> is there a way of catching arbitrary errors in Haskell? undefined, bad index, errors, exceptions, everything?
11:20:54 <SamB_XP> Cale: because they are in scope ?
11:20:59 <ksf> @free unsafeCoerce
11:21:00 <Cale> I guess.
11:21:00 <yoneda> we are asking because it worked
11:21:00 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `unsafeCoerce'\n\n"
11:21:06 <ksf> @free undefined
11:21:07 <yoneda> why did x and y work?
11:21:08 <lambdabot> f undefined = undefined
11:21:14 <aavogt> @hackage spoon
11:21:14 <lambdabot> http://hackage.haskell.org/package/spoon
11:21:15 <SamB_XP> > f x
11:21:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:21:16 <lambdabot>    `GHC.Show.Show a'
11:21:16 <lambdabot>      a...
11:21:19 <tensorpudding> @free fmap
11:21:20 <lambdabot> Expected variable or '.'
11:21:20 <SamB_XP> awww
11:21:24 <Cale> blackdog: You can *try*
11:21:28 <ksf> @free concatMap
11:21:29 <lambdabot> $map g . h = k . f => $map g . concatMap h = concatMap k . $map f
11:21:31 <SamB_XP> Cale: okay, why didn't "f x" work ?
11:21:36 <Cale> blackdog: Using evaluate and catch in the IO monad.
11:21:37 <poe> > f x :: Expr
11:21:39 <lambdabot>   f x
11:22:01 <Cale> blackdog: However, for the most part, errors thrown using 'error' are not meant to be caught.
11:22:11 <nornagon> > foldr1 f x :: Expr
11:22:12 <lambdabot>   Couldn't match expected type `[a]'
11:22:13 <lambdabot>         against inferred type `SimpleRef...
11:22:20 <Cale> blackdog: and catching them reliably is quite tricky
11:22:34 <nornagon> > foldr1 f xs
11:22:36 <lambdabot>   Not in scope: `xs'
11:22:40 <Cale> blackdog: You have to ensure that the evaluation which causes the error happens inside the catch.
11:22:42 <nornagon> > foldr1 f xs :: Expr
11:22:43 <lambdabot>   Not in scope: `xs'
11:22:45 <nornagon> alas.
11:23:01 <Cale> blackdog: and in general, that can be hard if the error is buried inside some data structure
11:23:19 <ddarius>  @free assumes functions are strict
11:23:29 <poe> > foldr1 f [x,y,z]
11:23:30 <lambdabot>   f x (f y z)
11:23:32 <SamB_XP> > map f [1..]
11:23:33 <lambdabot>   Ambiguous type variable `b' in the constraints:
11:23:33 <lambdabot>    `SimpleReflect.FromExpr ...
11:23:47 <SamB_XP> > map f [1..] :: [Expr]
11:23:48 <lambdabot>   [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10,f 11,f 12,f 13,f 14,f 15,f 16,f 1...
11:24:05 <ksf> @free fix
11:24:06 <lambdabot> f . g = h . f => f (fix g) = fix h
11:24:07 <SamB_XP> @type map f [1..]
11:24:09 <lambdabot> forall b. (SimpleReflect.FromExpr b) => [b]
11:24:33 <ddarius> That free theorem pretty much implies fix's implementation or meaning.
11:24:37 * ksf has a brain asplosion
11:24:45 <Cale> ddarius: So it would seem according to the free theorem for undefined
11:24:51 <Cale> @free undefine
11:24:52 <Cale> @free undefined
11:24:52 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `undefine'\n\n"
11:24:53 <lambdabot> f undefined = undefined
11:25:23 <ddarius> @free seq
11:25:24 <lambdabot> g . seq x = seq (f x) . g
11:25:28 <Cale> The free theorem for undefined is that every function is strict ;)
11:25:56 <ddarius> That free theorem is false unless f is strict.
11:26:16 <yoneda> the fix one is amazing
11:26:22 <SamB_XP> > f undefined `seq` ()
11:26:24 <lambdabot>   Ambiguous type variable `a' in the constraint:
11:26:24 <lambdabot>    `SimpleReflect.FromExpr a...
11:26:35 <SamB_XP> > f undefined :: Expr `seq` ()
11:26:36 <lambdabot>   Could not deduce (SimpleReflect.FromExpr
11:26:37 <lambdabot>                      (seq SimpleRe...
11:26:47 <SamB_XP> > (f undefined :: Expr) `seq` ()
11:26:48 <lambdabot>   ()
11:26:56 <SamB_XP> lol
11:27:02 <pikhq> > let f undefined = undefined in f undefined `seq` ()
11:27:03 <lambdabot>   * Exception: Prelude.undefined
11:27:15 <pikhq> > let f undefined = undefined in (f undefined) `seq` ()
11:27:17 <lambdabot>   * Exception: Prelude.undefined
11:27:30 <pikhq> Hooray.
11:27:55 <nornagon> > undefined `seq` ()
11:27:56 <lambdabot>   * Exception: Prelude.undefined
11:27:56 <SamB_XP> pikhq: I don't understand how that does that
11:28:04 <pikhq> SamB_XP: ?
11:28:27 <SamB_XP> pikhq: I would have expected it to use the undefined that was passed to f, not the one from Prelude!
11:28:37 <SamB_XP> oh, wait, now I got it
11:28:40 <SamB_XP> nevermind
11:29:01 <pikhq> _|_ just likes breaking brains, I guess?
11:29:57 <SamB_XP> no, it's just that my brain has some trouble with scoping sometimes
11:30:20 <copumpkin> pikhq: dcoutts  is busy chewing me out on reddit for misusing bottoms :)
11:30:21 <pikhq> Oh, alright.
11:30:26 <pikhq> copumpkin: :)
11:32:18 <ddarius> copumpkin: What did you think was going to happen?
11:32:33 <copumpkin> ddarius: I expected more chewing out all around, actually
11:32:38 <ivanm> copumpkin: yup, because _you fail_! ;-)
11:32:51 <SamB_XP> why fail when you can play simcopter?
11:32:57 <blackdog> Cale: I'm using try already.
11:33:16 <blackdog> Cale: I know it's a bad idea in general, but I'm taking Haskell code as an input, compiling it and using it from Ruby
11:33:16 <copumpkin> woof
11:34:08 <blackdog> so it might do anything at all. I know I can't stop that, but at least for the obvious cases, it'd be nice to be able to catch all runtime errors and pass them back to Ruby as an exception
11:34:45 <blackdog> (I was a bit embarrassed last night - gave a talk on Hubris, and showed a little Sinatra app calling a haskell function implementing fibonacci (what else))
11:34:55 <blackdog> showed fib(100) worked, so that was great
11:35:02 <blackdog> but then they wanted to see fib(fib(100))
11:35:07 <copumpkin> lol
11:35:17 <SamB_XP> they didn't think it would work, did they?
11:35:45 <copumpkin> > fix ((0:) . scanl (+) 1) !! 100
11:35:47 <lambdabot>   354224848179261915075
11:35:56 <blackdog> SamB_XP: I think they wanted to see how gracefully it'd fail
11:36:08 <blackdog> unfortunately, I was using (!!), which takes an int
11:36:19 <copumpkin> ugh
11:36:21 <blackdog> so fib(100) interpreted as an int wraps around
11:36:30 <SamB_XP> hehehe
11:36:31 <blackdog> and it's a negative index into the fib list
11:36:37 <copumpkin> lol
11:36:39 <SamB_XP> hehehehehe
11:36:48 <copumpkin> > 354224848179261915075 :: Int
11:36:49 <lambdabot>   3736710778780434371
11:36:54 <copumpkin> > 354224848179261915075 :: Int32
11:36:56 <lambdabot>   -980107325
11:36:59 <blackdog> the problem is that an error in the haskell can cause the whole process to do horrible, horrible things
11:37:12 <blackdog> is there a better way of isolating it than spinning off a new process?
11:37:39 <blackdog> copumpkin: running on a mac with a 32 bit ghc:)
11:38:09 <SamB_XP> blackdog: I think he figured that out
11:38:21 <SamB_XP> it's just that lambdabot is running on 64-bit for some reason
11:38:36 <pastah_rhymez> blackdog: there's always :: Integer
11:38:41 <pastah_rhymez> though that might get slow
11:39:08 <SamB_XP> but is there generic!! ?
11:39:16 <blackdog> pastah_rhymez: sure, and i fixed the demo up afterwards. but the deeper question is how you can run haskell safely...
11:39:20 <blackdog> SamB_XP: no
11:39:43 <blackdog> list !!! n = head . snd .genericSplitAt n list
11:39:48 <blackdog> or something similar
11:39:58 <blackdog> (it's like !!, but you really mean it)
11:40:30 <pastah_rhymez> blackdog: why would you want to use that?
11:40:34 <copumpkin> why not just list !!! n = head . genericDrop n?
11:40:40 <copumpkin> $ xs
11:40:48 <copumpkin> gah, you know what I mean
11:40:57 <blackdog> copumpkin: because you're smarter than me:)
11:41:15 <blackdog> pastah_rhymez: use what?
11:41:19 <copumpkin> lol
11:41:22 <ddarius> :t genericIndex
11:41:22 <copumpkin> right ;)
11:41:23 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
11:41:32 <copumpkin> ooh even bettar
11:41:48 <Cale> blackdog: Well, you should always prefer to use pattern matching over functions like head/tail/(!!)/fromJust/etc.
11:41:50 <copumpkin> ddarius is smarter than both of us!
11:42:11 <SamB_XP> ddarius: I thought it might be called that
11:42:38 <SamB_XP> I was mostly kidding about "how do you prefix an infix name with a word?"
11:44:05 <blackdog> Cale: this was hooking into an infinite list of all fibonaccis. it's guaranteed to be safe for non-negative indices... i don't think there's a pattern-matching version that works naturally, although i could  be wrong
11:45:02 <SamB_XP> blackdog: running out of RAM is what you call "safe"?
11:45:07 <nornagon> (why use genericDrop rather than just drop?)
11:45:10 <copumpkin> > fix ((0:) . scanl (+) 1)
11:45:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:45:22 <SamB_XP> nornagon: the whole point was to be generic!
11:45:30 <nornagon> :t genericDrop
11:45:31 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
11:45:37 <nornagon> :t drop
11:45:38 <lambdabot> forall a. Int -> [a] -> [a]
11:45:43 <nornagon> Aha.
11:46:05 <yoneda> :t genericSplitAt
11:46:06 <lambdabot> forall i b. (Integral i) => i -> [b] -> ([b], [b])
11:46:40 <blackdog> SamB_XP: of course. we're all running infinite turing machines, aren't we?
11:46:59 <gwern> blackdog: speak for yourself; *my* turing machine merely has unbounded memory
11:46:59 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
11:47:04 <gwern> @messages
11:47:05 <lambdabot> sjanssen said 7h 30m 49s ago: I'm assigning http://xmonad.org/bugs/350 to you, hope you don't mind. All I'm looking for right now is feasibility, not asking you to do all the programming necessary
11:48:56 <SamB_XP> blackdog: well, mine ran out of trees
11:49:18 <blackdog> gwern: never quite got the semantic distinction between infinite and unbounded...
11:50:16 <yoneda> they are cognatem one latin, one anglo-saxon
11:50:29 <yoneda> cognates
11:51:06 <yoneda> greek apeiron un - limited
11:53:13 <EvanCarroll> how come True == 5 == 5 doesn't work, but 5 + 5 + 5 does work?
11:53:20 <EvanCarroll> they are both infix of the same level.
11:53:35 <copumpkin> > 5 == 5 == True
11:53:36 <lambdabot>   Precedence parsing error
11:53:36 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
11:53:42 <copumpkin> == is marked as infix
11:53:49 <copumpkin> which means it can't coexist peacefully
11:53:55 <Cale> EvanCarroll: == is infix 4, and + is infixl 6
11:54:04 <EvanCarroll> that's lame.
11:54:08 <copumpkin> not really
11:54:14 <EvanCarroll> why cant == be infixr ? or infixl?
11:54:22 <Cale> EvanCarroll: Besides, it's silly to use it like that
11:54:25 <copumpkin> because it would be arbitrary
11:54:37 <Cale> (why would you want to write == True in the first place?)
11:54:42 <yoneda> equal would then be unequal
11:55:13 <ivanm> Cale: to see if a boolean value is True or not? :p
11:55:14 <EvanCarroll> Because it would amuse me...
11:55:21 <EvanCarroll> Isn't that what haskell is for ;)
11:55:27 <EvanCarroll> ivanm++
11:55:40 <ivanm> how about (a == b) == (a == c) for xor equality?
11:55:45 <yoneda> == is iff, so wouldn't you want
11:55:47 <yoneda> right
11:56:02 <pikhq> EvanCarroll: Presumably because it's somewhat annoying for ==, and ambiguous for /=...
11:56:05 <ivanm> EvanCarroll: no, haskell isn't to amuse _you_
11:56:12 <ivanm> it's a great big practical joke by SPJ
11:56:20 <gwern> for god's delectation
11:56:31 <pikhq> ... Actually, it's ambiguous for 5 == 5 == True, as well...
11:56:40 <gwern> as the yiddish proverb goes, 'haskellers prove; god laughs'
11:56:42 <pikhq> (only one of the two plausible parsings even typechecks)
11:56:42 <yoneda> its god's joke SPJ is just the seal of the prophets
11:57:39 <gwern> yoneda: well, he does know his unicycling...
11:58:00 <yoneda> i dont want to know....
11:58:17 <natesbrain> hi, I'm a newb and I've got a pure function that operates on two lists and returns a result
11:58:23 <natesbrain> the lists can be infinite
11:58:34 <natesbrain> and if they're pure lists, the functions works just fine
11:58:45 <yoneda> i'm mad at him for the moment, he was seeming kinda surly with sigfpe in the video
11:58:48 <natesbrain> but I'd like to be able to prompt the user for input to generate those lists
11:59:27 <natesbrain> and using fmap or liftM to apply my pure function to them prompts me forever
11:59:44 <natesbrain> I read about unsafeInterleaveIO
11:59:50 <natesbrain> but the unsafe part kind of bugs me
12:00:04 <natesbrain> is there a safe way to do lazy IO?
12:00:16 <natesbrain> or am I worrying about the wrong things?
12:00:33 <natesbrain> (sorry for the incoherent text wall)
12:00:41 <SamB_XP> natesbrain: it's not the kind of thing that can be done safely in general
12:01:31 <pikhq> main = do putStrLn "Please input a list."; x <- getContents; putStrLn . show . function . (read x :: [Type]) -- Kinda like that?
12:02:09 <natesbrain> more like each prompt gets a new element of the list
12:02:21 <yoneda> but there are two lists?
12:02:24 <natesbrain> it's a rock paper scissors, best of 10, win by 2
12:03:00 <natesbrain> so yes, there are two lists
12:03:15 <yoneda> and the new list is of who won
12:03:28 <pikhq> I'd honestly be tempted to stick more of the rock paper scissors logic into the IO monad, myself.
12:03:32 <natesbrain> just a single value, but yes
12:04:01 <pikhq> Though I'd probably regret it soon after. :P
12:04:18 <natesbrain> I toyed with a [IO RockPaperScissors] -> [IO RockPaperScissors] -> Outcome
12:04:37 <SamB_XP> natesbrain: not gonna work ;-P
12:04:40 <natesbrain> and I read up on unsafeInterleaveIO which seems like exactly what I want
12:05:01 <pikhq> Impossible if you're going to do anything meaningful with the lists.
12:05:14 <natesbrain> whups, should ahve been -> IO Outcome
12:05:19 <gwern> natesbrain: you know, what you're trying to do reminds me a lot of the monadprompt package
12:05:21 <natesbrain> right
12:05:22 <pikhq> Makes a huge difference. :)
12:05:26 <natesbrain> :)
12:05:48 <gwern> try looking at the emails about the monadprompt; it seems perfectly designed at a nice rock-paper-scissors type game
12:06:00 <natesbrain> very cool, I will do that
12:06:04 <ddarius> Haskell 1.0 Report published 1 April 1989
12:06:23 <ddarius> or was it '90?
12:06:57 <SamB_XP> ddarius: lol
12:07:11 <SamB_XP> "april fools! it's not really 1.0 yet!"
12:08:06 <heatsink> Are there any cabal packages that export foreign functions?  I want to see how they do it.
12:08:07 <SamB_XP> or "Hahahahahah! they think this language might actually be useful!"
12:09:01 <natesbrain> allright, thanks all for the advice and the reading, this is a great place to get help
12:10:20 <Apocalisp> What's a good unary operator for flip?
12:11:03 <heatsink> flip is a unary operator?
12:11:29 <Zao> s/operator/symbol/
12:11:38 <Apocalisp> Yeah, symbol
12:12:03 <joe____> how can I covert Word8 -> Int?
12:12:06 <Apocalisp> If I were an Agda flip function, what would I look like?
12:12:09 <joe____> any thoughts, please?
12:12:12 <heatsink> joe___: fromIntegral
12:12:15 <monochrom> use fromIntegral to convert
12:12:18 <joe____> ok, thanks
12:12:55 <jmcarthur> ↺
12:13:00 <Apocalisp> ooooh
12:13:07 <heatsink> :)
12:13:35 <jmcarthur> ⇄
12:14:35 <Apocalisp> ⇄ is nice
12:14:42 <jmcarthur> i have no idea how to input either of those in agda-mode though
12:15:02 <jmcarthur> *agda2-mode
12:15:14 <Apocalisp> no worries
12:15:36 <gwern> huh. that's actually a pretty sensible flip operator
12:20:57 <mxyz> is there a function for getting a string containing the bits of an int? like (showBits 123 :: Int64) results in  "1010101......"
12:21:17 <nornagon> no
12:21:53 <monochrom> Something that uses Numeric.showInt and specifying base 2.
12:22:08 <mxyz> great. thank you.
12:22:11 <monochrom> It may be called something other than showInt. Look the doc.
12:22:26 <nornagon> oh.
12:22:36 <roconnor> > showIntAtBase
12:22:37 <lambdabot>   * Exception: Numeric.showIntAtBase: applied to unsupported base -3
12:22:48 <roconnor> @type showIntAtBase
12:22:50 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
12:23:15 <roconnor> > showIntAtBase 2 ("01"!!) 123 ""
12:23:17 <lambdabot>   "1111011"
12:23:30 <poe> > showIntAtBase 2 (chr . (48+)) 12 ""
12:23:31 <mxyz> sweet!
12:23:31 <lambdabot>   "1100"
12:26:55 <gwern> ah, but which endian is that?
12:27:43 <heatsink> little endian
12:28:09 * BMeph hums: "One little, two little three little endians..."
12:28:42 <heatsink> Hmm.  The string starts on the left, so that makes it big endian.
12:29:37 <heatsink> Really, the problem is that text is big-endian and should be little-endian.
12:30:36 <ivanm> greetings, bos
12:30:56 <bos> hi
12:30:56 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
12:32:43 <gwern> 'My suggestion that arrays start with 0.5 was rejected, I felt, without proper consideration.'
12:33:46 <c_wraith> that sounds so familiar.  xkcd?
12:33:54 <Zao> Using Left for failure is discrimintating against left-handed people!
12:34:41 <gwern> c_wraith: no. stan kelly-bootle
12:35:03 <gwern> Zao: you say that like the choice is sinister
12:35:11 <gwern> what, are we going to say that Right is wrong?
12:35:18 <gwern> and Left is right?
12:36:43 <toast-opt> depends... is the text LtR, or RtL?
12:37:09 <toast-opt> i guess that [0-9] is in the LtR character class, though
12:37:31 <gwern> *some* scripts go neither just left nor just right, you insensitive clod!
12:38:44 <toast-opt> qwern, my appologies.  are they infix then?
12:38:51 <toast-opt> gwern, rather
12:39:00 <gwern> they're boustrophedonic
12:39:44 <dcestari> hello all, is there a way to mimic pointers or references in haskell?
12:40:06 <Stinger> MVars
12:40:49 <gwern> @wn boustrophedonic
12:40:51 <lambdabot> *** "boustrophedonic" wn "WordNet (r) 2.0"
12:40:51 <lambdabot> boustrophedonic
12:40:51 <lambdabot>      adj : of or relating to writing alternate lines in opposite
12:40:51 <lambdabot>            directions
12:41:07 <gwern> (for you non-classic scholars watching :)
12:41:21 <toast-opt> i don't think unicode is boustrophedonic-friendly
12:41:49 <gwern> unicode can do anything
12:41:51 <blackdog> copumpkin: how much can you catch with spoon?
12:42:11 <blackdog> it sounds like it might be the answer to my prayers...
12:42:15 <toast-opt> but in "natural-reading-order" are decimal numbers generally big-endian?
12:42:32 <dcestari> I need to define an infinite type
12:42:46 <mxyz> what is the function for getting the bits of a double?
12:42:54 <dcestari> but can't find a way to do so
12:43:08 <heatsink> mxyz: There is one in the MissingH package I think
12:43:28 <mxyz> heatsink: thanks. i tried seraching hoogle for "Double -> String"
12:43:42 <heatsink> mxyz: This would be Double -> Word64
12:44:19 <mxyz> like Java's Double.toLongBits right?
12:44:53 <gwern> don't we have a Bit type?
12:45:15 <heatsink> yeah
12:45:30 <heatsink> gwern: you mean Bool?
12:46:17 <kmc__> dcestari, in what sense?
12:47:00 <dcestari> I need to keep a reference inside a data type, like a "me"
12:47:12 <kmc> what does it refer to?
12:47:22 <dcestari> data Obj = ComplexObject Obj Int String ....
12:47:33 <kmc> yeah that will work
12:47:38 <kmc> it can contain itself
12:47:39 <dcestari> let x = ComplexObject x 1 "text"
12:47:46 <kmc> don't know why you'd want that
12:48:05 <c_wraith> finally got haskell-platform to install.  Only had to modify the build script. >_>
12:48:21 <c_wraith> err..  the build script is what I stole code from.  I modified the install script
12:49:39 <joe____> I am searching for a function that can do " m a -> m () ", can you please help?
12:49:54 <heatsink> mxyz: the data-binary-ieee package
12:49:54 <kmc> :t (>> return ())
12:49:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:49:56 <poe> ?type (>> return ())
12:49:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:50:06 <kmc> joe____, didn't we have this conversation several hours ago?
12:50:11 <tensorpudding> @type getChar >>= putStrLn
12:50:12 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
12:50:12 <lambdabot>       Expected type: Char
12:50:12 <lambdabot>       Inferred type: String
12:50:19 <tensorpudding> err, darn
12:50:59 <joe____> sorry, kmc.
12:51:16 <heatsink> :t sequence_.(:[])
12:51:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:51:49 <joe____> is there a way to do this? I am searching for functions that go from type to type. I tried hoogle, any other suggestions?
12:51:59 <kmc> joe____, the way is to learn how monads work
12:52:03 <jmcarthur> :t (()<$)
12:52:04 <tensorpudding> @type mapM_
12:52:05 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
12:52:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
12:52:50 <kmc> sorry if that sounded harsh, i don't mean it that way
12:53:51 <kmc> just that many of your recent questions would be resolved that way
12:54:15 <kmc> :t \m -> do { m; return () }
12:54:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:55:15 <kmc> :t \m -> sequence_ [m]
12:55:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:55:47 <kmc> :t liftM (const ())
12:55:48 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m ()
12:56:14 <kmc> :t sequence_ . return
12:56:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:59:30 <mjrosenb> hey, anyone know about gtk2hs?
12:59:55 <mxyz> heatsink: yea, i could find it in MissingH. look in Data.Binary?  putDoubleIEEEhost :: Double -> Builder ?
13:00:22 <kmc> joe____, i'm guessing when you ask for "m a -> m ()" you mean in the case where m is a Monad
13:00:28 <kmc> if you know nothing about m then it is impossible
13:01:41 <heatsink> mxyz: That would be it.  You can get a bytestring from a Builder.
13:02:09 <mjrosenb> i have:
13:02:10 <mjrosenb>   tt <- textTagTableNew
13:02:11 <mjrosenb>   sb <- sourceBufferNew (Just tt)
13:02:19 <mjrosenb> ghci says:
13:02:20 <mjrosenb>     Couldn't match expected type `Graphics.UI.Gtk.SourceView.Types.SourceTagTable'
13:02:24 <mjrosenb>            against inferred type `TextTagTable'
13:02:28 <dcestari> make
13:02:45 <dcestari> hehe, sorry
13:03:00 <mxyz> thanks. or did you mean Data.Binary.IEEE754 ?
13:03:05 <mjrosenb> i have no clue where it got *.SourceTagTable from
13:03:40 <mxyz> putFloat64be :: Double -> Put
13:04:09 <mxyz> weird that "double -> word64" isnt in Data.Binary
13:04:22 <joe____> kmc, I have been reading the monad tutorials for the past couple of years. I seem to understand it each time but, in practice, I feel that I am hitting against a wall each time when using them.
13:04:42 <kmc> joe____, do you understand the "do" notation?
13:04:52 <joe____> sorry for the trouble. I feel that the best way is to keep writing programs.
13:04:56 <heatsink> mxyz: I would guess they do more or less the same.
13:05:11 <kmc> joe____, i agree it is the best way.  though perhaps not IO-intensive ones
13:05:39 <kmc> if you have written something of type "m a" using "do", and you want it to be of type "m ()", the solution is to add a final line "return ()" to the "do" block
13:05:49 <kmc> :t do { getChar }
13:05:50 <lambdabot> IO Char
13:05:51 <kmc> :t do { getChar; return () }
13:05:52 <lambdabot> IO ()
13:05:58 <kmc> :t do { return (); getChar }
13:05:59 <lambdabot> IO Char
13:06:09 <kmc> joe____, do you understand why those three do blocks have their respective types?
13:06:11 <joe____> kmc, thanks for being so patient.
13:07:27 <mxyz> heatsink: this ticket: http://hackage.haskell.org/trac/ghc/ticket/1434 contains: "truncate = fromIntegral . double2Int :: Double -> Word64 " if that means anything to you?
13:07:29 <joe____> kmc, "why those three do loops", which three do blocks?
13:08:24 <kmc> the three i just fed to lambdabot
13:08:36 <kmc> i asked for the types of three "do" blocks
13:08:36 <joe____> ok, thanks. I understand them.
13:08:40 <kmc> okay
13:08:54 <kmc> then you understand how to make "m a" into "m ()"
13:08:59 <kmc> and you could write the function that does so
13:09:04 <joe____> yes, thanks.
13:09:07 <kmc> cool
13:09:53 <mxyz> heatsink: i think its double2int from GHC.Float http://www.seas.upenn.edu/~bcpierce/courses/advprog/resources/base/GHC.Float.html#v%3Adouble2Int
13:10:30 <toast-opt> :t (>> return ())
13:10:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
13:11:01 <heatsink> mxyz: It rounds to zero.
13:11:51 <mxyz> heatsink: yea i just saw that in ghci. ill try the put one. thought it seems weird to have to use a builder monad just to do this
13:12:39 <heatsink> mxyz: You can also do it with the FFI.  Of course, the result will depend on your platform's byte order.
13:13:40 <heatsink> :t alloca (\(d :: Double) -> peek (castPtr d :: Ptr Word64))
13:13:41 <lambdabot> Not in scope: `alloca'
13:13:42 <lambdabot> Not in scope: `peek'
13:13:42 <lambdabot> Not in scope: `castPtr'
13:13:53 <toast-opt> seeking advice.  coming from scheme, I'm really missing named let for doing loops.  do i just use normal lets instead?  or prefer foldr's?
13:14:48 <toast-opt> for example,  (define (fact x) (let myloop ((x x) (acc 1)) (if (<= x 0) acc (myloop (- x 1) (* acc x)))))
13:15:18 <heatsink> toast-opt: For simple looping patterns, HOFs are preferred (map, foldr, etc).  For complex ones, recursive lets are preferred.
13:16:15 <toast-opt> heatsink, thx.  but the thing i miss about named lets is being able to put the initial values right next to the variables, instead of variables at the top, initial variables at the bottom
13:16:21 <heatsink> Is ((x x) (acc 1)) defining mutable local variables?
13:17:18 <heatsink> toast-opt: You might prefer 'where' syntax for loops.
13:17:53 <toast-opt> head - in this case, neither x nor acc are being mutated
13:17:53 <toast-opt> it's equivalent to (let (myloop (lambda (x acc) ...)) (myloop x 1))
13:17:53 <toast-opt> oh, duh.  then i can say (myloop x 1 where myloop x acc = ...), right?
13:18:01 <toast-opt> thx!
13:18:05 <heatsink> fact x = myloop x 1 where {myloop 0 acc = x; myloop x acc = myloop (x - 1) (acc * x))}
13:18:09 <kmc> is that something like:  (define (fact n) (letrec ((body (lambda (x acc) (if (<= x 0) acc (body (- x 1) (* acc x)))))) (body n 1)))
13:18:23 <toast-opt> kmc, yes
13:18:31 <mxyz> heatsink: thanks for the help btw.
13:19:25 <toast-opt> i forgot a level of parens, should have been 'equivalent to (let ((myloop (lambda (x acc) ...))) (myloop x 1))'
13:20:24 <heatsink> mxyz: sure.  So yeah, you can allocate some memory, poke it, and peek it to do the conversion, if you don't mind feeling dirty.
13:21:12 <toast-opt> i feel dirty already
13:21:12 <toast-opt> sorry
13:23:32 <Stinger> ok, so is there a lib function for something that does essentially this? (a->b) -> (a->c) -> (b->c->d) -> (a->d); arrows?
13:25:29 <toast-opt> stinger, just fyi, the last parens around 'a->d' are implied.  hoogle says no, but you can probably compose a small set of builtins
13:26:04 <kmc> @djinn (a->b) -> (a->c) -> (b->c->d) -> (a->d)
13:26:05 <lambdabot> f a b c d = c (a d) (b d)
13:26:05 <heatsink> :t \f g h x -> f x `h` g x
13:26:07 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t -> t2) -> (t1 -> t2 -> t3) -> t -> t3
13:26:13 <kmc> @pl f a b c d = c (a d) (b d)
13:26:14 <lambdabot> f = flip . (ap .) . flip (.)
13:26:57 <mjrosenb> aviary likely has it
13:27:19 <mjrosenb> it has so many combinators with the least useful names ever.
13:27:52 <Stinger> heh
13:27:56 <toast-opt> :t flip
13:27:58 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:29:49 <dcestari> is there such thing as variable references in haskell?
13:31:08 <joe____> kmc, just wanted to let u know that I got the program that I was working with complete and it seems to be working.
13:31:20 <Saizan> mutable? there are IORef and STRef
13:31:24 <joe____> Just wanted to pass on my sincere thanks for the help.
13:31:39 <EvanCarroll> how would you take an array of [0..] and split it at every third element to return a list of lists... ?
13:31:49 <Saizan> also MVar and TVar , TMVar if you need thread safety
13:32:17 <toast-opt> ... maybe squeeze 'on' into there
13:32:28 <Saizan> EvanCarroll: array or list?
13:32:46 <Saizan> @hoogle chunk
13:32:47 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
13:32:47 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
13:32:47 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
13:33:00 <dcestari> @src IORef
13:33:01 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
13:33:11 <dcestari> @src STRef
13:33:11 <lambdabot> data STRef s a = STRef (MutVar# s a)
13:33:36 <Cale> (those get into GHC primitive stuff -- you should treat IORef and STRef as primitive types)
13:33:50 <Cale> :t newIORef
13:33:51 <lambdabot> Not in scope: `newIORef'
13:33:56 <Cale> :t Data.IORef.newIORef
13:33:58 <lambdabot> forall a. a -> IO (GHC.IOBase.IORef a)
13:34:00 <Saizan> EvanCarroll: for lists you can use this http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html#v%3Achunk , or write your own loop with splitAt if you don't want to depend on the split package
13:34:01 <kmc> dcestari, if you need destructive update then you should probably use one of the refs
13:34:13 <Cale> dcestari: What are you trying to do?
13:34:14 <kmc> if your references are read-only then you probably don't need any special data type
13:34:32 <kmc> as every haskell value is implicitly by reference
13:35:12 <kmc> <dcestari> data Obj = ComplexObject Obj Int String ....
13:35:13 <kmc> <dcestari> let x = ComplexObject x 1 "text"
13:35:22 <kmc> dcestari, i don't understand why you want to do this, but it will work as-is
13:35:30 <SmurfOR> has anyone here gotten lambdabot to work with ghc 6.12?
13:35:47 <dcestari> kmc: I'll have to check
13:36:15 <dcestari> if I have a list
13:36:20 <dcestari> then pass it to a constructor
13:36:41 <dcestari> then modify it, and it remains the same on the constructed value
13:36:53 <dcestari> so, I think it does not work with references
13:37:05 <ivanm> @remember TomTobin ::facepalm::  I wrote "Foobar" as a placeholder as I was typing [for the author's name], and never replaced it [in my email].
13:37:06 <lambdabot> Okay.
13:38:47 <dcestari> :t $
13:38:49 <lambdabot> parse error on input `$'
13:38:54 <dcestari> :t `$`
13:38:55 <kmc> dcestari, how do you plan to modify a list?
13:38:56 <lambdabot> parse error on input ``'
13:39:01 <toast-opt> :t ($)
13:39:02 <lambdabot> forall a b. (a -> b) -> a -> b
13:39:36 <dcestari> kmc: let x = Constructor xs in replace a b xs
13:39:45 <toast-opt> :t replace
13:39:46 <lambdabot> Not in scope: `replace'
13:39:50 <kmc> where is "replace" from?
13:39:55 <dcestari> custom
13:39:59 <kmc> defined how?
13:40:34 <dcestari> replace :: a -> a -> [a] -> [a]
13:40:40 <kmc> it seems like that returns a new list
13:40:41 <dcestari> replaces occurences of a by b on xs
13:40:49 <kmc> instead of "modifying" one
13:40:49 <Saizan> that won't modify xs anyhow, it'll create a new list
13:41:07 <dcestari> is there a way to Not create a new list?
13:41:09 <kmc> it is not meaningful to speak of modifying a list.  a list is a value, not a location for storing things.  you can't modify [1,2,3] any more than you can modify 3
13:41:23 <kmc> dcestari, if your list is stored in an IORef, you can store a different list into the same IORef
13:41:38 <dcestari> what if it isn't?
13:41:50 <kmc> (or anything similar to an IORef)
13:41:56 <dcestari> I'm on pure functional side right now
13:42:02 <dcestari> not the IO monad
13:42:18 <kmc> you can't modify a list
13:42:26 <kmc> even in the IO monad
13:42:27 <dcestari> what can I modify?
13:42:29 <kmc> nothing
13:42:34 <Saizan> then you should create a new object out of your x and your new xs
13:43:06 <Saizan> let x' = case x of Constructor xs -> Constructor (replace a b xs)
13:43:45 <dcestari> mm
13:44:02 <Saizan> if something like references would be really the most appropriate way, you can implement them using an IntMap, but that's not a so common need
13:44:32 <kmc> probably whatever you want to model by in-place replacement, should be modeled by passing a new, different value to a function, possibly a recursive tail call
13:45:59 <dcestari> I need to keep a reference to an object which has a reference to itself
13:46:03 <kmc> why?
13:46:16 <dcestari> is a "function" so it needs to have a reference to itself for recursion
13:46:31 <kmc> what are you trying to do?
13:46:59 <dcestari> is a interpreter of a DSL
13:47:11 <Saizan> > let fac 0 = 1; fac n = n * fac (n-1) in fac 5
13:47:12 <lambdabot>   120
13:47:12 <dcestari> an**
13:47:18 <kmc> does your DSL have destructive in-place updates?
13:47:39 <dcestari> no, is just the algorithm to evaluate recursive functions
13:47:45 <kmc> okay
13:48:25 <dcestari> I need to bind a fake value to the function name to avoid lookup errors, but after evaluated I need to bind the closure of the newly created function to replace the old fake value
13:48:52 <Saizan> why the fake value?
13:49:06 <Saizan> you can bind the newly created function there directly
13:49:09 <Saizan> because of laziness
13:49:17 <dcestari> let me try it
13:49:56 <Saizan> (this is one of the reasons laziness and purity go well together)
13:51:23 <kmc> let f = RecursiveDSLFunction f x y z in ...
13:52:52 <dcestari> is there an easy way to debug a haskell program? mine gets stock in a loop but I can't see why
13:53:00 <kmc> that's unnecessary anyway, because when you pattern match on (RecursiveDSLFunction f x y z), you might as well also bind a name for that whole thing (call it g), and g will always be the same as f
13:53:35 <kmc> i.e. these two patterns bind the same:  (RecursiveDSLFunction f x y z)  and (f@(RecursiveDSLFunction _ x y z))
13:53:37 <Saizan> kmc: i imagine the recursive reference would be deeper
13:53:41 <kmc> probably
13:53:54 <kmc> you can pass it as far as it needs to go
13:54:13 <kmc> dcestari, load it up in ghci and try individual functions
13:54:25 <kmc> if that fails, use the GHCi debugger or Debug.Trace
13:55:00 <dcestari> thanks
13:55:14 <kmc> but the latter does side effects from a supposedly pure function, so they may not get executed when you expect
13:55:17 <kmc> or at all
13:58:50 <fracture> @hoogle unsafePerformIO
13:58:50 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:58:50 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
14:01:38 <SANDERS> is it just me or is the standard haskell date/time libraries a little of a mess
14:02:20 <fracture> what values do uninitialized fields of a record take?
14:05:31 * hackagebot upload: Binpack 0.4 - Common bin-packing heuristics. (BjoernBrandenburg)
14:05:56 <Saizan> fracture: something like error "not initialized"
14:06:10 <fracture> ah, k
14:11:46 <fracture> so, earlier I was asking what the haskelly way to approach a problem that you'd usually solve with runtime polymorphism (i.e. virtual functions) in OO languages
14:12:08 <fracture> and someone suggested using a partially applied function with state in the function
14:12:46 <fracture> which is a good idea, however for any given type of "thing" here, there's more than one operation I need to be able to do polymorphically, and they all need access to the state and the ability to change it
14:13:02 <fracture> anyone got suggestions?
14:13:24 <dmead> channel!
14:15:04 <joe____> i realise that while programming in haskell, all we need is to code/find " a -> b" transformation function. all the rest of the combinations/folding can be done with out-of-the-box functions.
14:16:24 <Saizan> fracture: a record of functions instead of a single one
14:16:52 <fracture> and each function would take the whole record as an argument and also return it?
14:17:12 <fracture> it might help to specifically what this is:
14:17:18 <kmc> joe____, not sure what you mean
14:17:19 <dcestari> well, turns out it wasn't even the recursive functions!
14:17:39 <fracture> I made a little tetris clone with SDL, and I am trying to refactor it so that I can have a seprate state thing for menus/gameover vs. the game being played
14:17:48 <dcestari> it was the pattern matching algorithm that was failing to match the base cases of my test recursive functions
14:17:52 <Saizan> fracture: it can just close over the record, but if you've some kind of "update" function it has to return it
14:17:53 <fracture> instead of just throwing a bunch of bools into my GameState guy
14:18:04 <fracture> yeah, I need an update and a render for each state
14:18:10 <fracture> err each type of state or whatever
14:18:21 <Saizan> fracture: seen this? http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
14:18:29 <fracture> nope; I'll take a look
14:18:49 <joe____> kmc, do not bother..
14:19:21 <sohum> fracture: do you want State monad + typeclasses? or am I misunderstanding you?
14:19:59 <fracture> sohum: I dunno much about that sort of thing, so no idea if that's what I want
14:20:05 <joe____> was just thinking aloud'ish..
14:20:32 <Saizan> hah, i didn't remember that article actually takes a game as example
14:20:56 <fracture> btw, I would say my current situation is even worse than most non-functional languages...  I know it's something "wrong"
14:21:07 <fracture> but there's fields in the GameState that are logically "const", but there's no way to do that
14:21:22 <kmc> fracture, you can use Reader and State together
14:21:25 <fracture> it's like OO done with everything in one object
14:21:33 <kmc> there's a RWS monad for making convenient combinations of those
14:21:41 <Saizan> you could have a separate GameEnvironment
14:21:53 <sohum> fracture: TypeClasses http://en.wikipedia.org/wiki/Type_class
14:22:11 <Saizan> kmc: what's the advantage of RWS?
14:22:32 <fracture> hrm... I can't use a typeclass directly in a record, can I?
14:22:52 <fracture> like (Foo => a) data Blah = Blah { something :: a }
14:22:54 <fracture> ?
14:23:07 <sohum> yerp, you can.
14:23:13 <fracture> ah, that should do it then :)
14:23:13 <sohum> ... I think
14:23:18 <sohum> gimme a sex
14:23:25 <sohum> *sec
14:23:27 <Saizan> depends what you actually want it to mean
14:23:29 <fracture> ah I see there's an example at that wiki
14:23:51 <fracture> ok
14:23:53 <fracture> so this makes sense
14:24:01 <Saizan> yeah, the SomePointSet
14:24:24 * posixninja teabag's copumpkin 
14:24:28 <fracture> cool... that's exactly what I want I think
14:25:40 <punkindrublic> :0 teabag
14:28:41 <kmc> Saizan, Reader + Writer + State without building a complex monad transformer stack
14:28:55 <fracture> so one other question... would it be a correct characterization of the State monad to say that its only purpose is to simplify the syntax of manually passing state objects around?
14:29:01 <kmc> yes
14:29:06 <fracture> ok
14:29:25 <kmc> @src Monad (State s)
14:29:25 <lambdabot> Source not found. My brain just exploded
14:29:31 <kmc> @src Monad State
14:29:32 <lambdabot> Source not found. That's something I cannot allow to happen.
14:29:42 <kmc> well anyway you can read the source at http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html
14:30:02 <kmc> if you look at the definition of (>>=) for State, you'll see it's exactly that: manually passing state objects around
14:30:14 <fracture> ok
14:30:45 <sohum> hm.
14:30:50 <sohum> Is there an identity monad?
14:30:55 <kmc> yeah
14:31:14 <sohum> such that, say, filterM in ID == filter, and so on?
14:31:23 <kmc> newtype Identity a = Identity a
14:31:25 <kmc> return = Identity
14:31:39 <kmc> (Identity x) >>= f = f x
14:31:54 <sohum> oh, of course
14:32:06 <kmc> there's also a trivial monad :)
14:32:19 <kmc> return = const Trivial; _ >>= _ = Trivial
14:32:24 <sohum> so given that it's an issue to rewrite filter and filterM, map and mapM, etc...
14:32:28 <kmc> it satisfies the monad laws and everything!
14:32:48 <sohum> why not just write the M variants and have the nonM variants be just typerestricted?
14:33:02 * roconnor makes note of another commutative monad
14:33:26 <toast-opt> kmc, heh, i understand monads just enough to get that :)
14:33:54 <toast-opt> let me guess, >> has a default definition derived from >>=?
14:34:00 <sohum> toast-opt: yerp.
14:34:04 <sohum> @src (>>)
14:34:05 <lambdabot> m >> k      = m >>= \_ -> k
14:34:38 <toast-opt> makes sense.  and (\_->k) is another way of writing (const k)
14:34:40 <toast-opt> :t const
14:34:42 <lambdabot> forall a b. a -> b -> a
14:34:43 <sohum> yerp.
14:35:07 <toast-opt> is still getting past C++ notion of const
14:35:25 <sohum> everything is const :P
14:35:37 <toast-opt> except IO stuff
14:35:46 <sohum> heh
14:36:02 <toast-opt> and State stuff
14:36:09 <sohum> nope, State stuff are const
14:36:10 <Saizan_> still const actually
14:36:15 <Saizan_> even IO stuff
14:36:31 <sohum> technically true, I suppose
14:36:31 <sohum> yea
14:36:37 <Saizan_> unless you identify the reference with its content
14:37:27 <Saizan_> ..like C++ does, more or less
14:38:09 <fracture> it's all const, but it's const in a very different way...
14:38:36 <kmc> yeah there are no mutable values in Haskell, period
14:38:46 <fracture> if you do pass an object full of data around as state (where the whole record is replaced every time through a loop), you can end up with members that should "never change", but aren't really const syntactically like you could do in C++
14:38:57 <kmc> because the idea "mutable value" is absolute nonsense... it's a value!  how do you mutate 3 or "hello world"?
14:39:25 <kmc> fracture, you can pass part using Reader and part using State
14:39:26 <fracture> kmc: hrm.  probably it involves a mov instruction or two
14:39:28 <fracture> :P
14:39:46 <kmc> fracture, that doesn't mutate a value.  that changes the contents of memory
14:39:48 <fracture> yeah, but that's pretty unsatisfactory, of course
14:39:58 <kmc> one piece of memory can hold one value at time t and another value at time t+1
14:39:59 <fracture> (at least in some cases)
14:40:07 <kmc> the individual values are immutable
14:40:19 <kmc> this is what is abstracted by an IORef or similar
14:40:55 <fracture> ok sure, why not :)
14:41:03 <kmc> and references of this sort are used quite often in Ocaml as well, even though Ocaml does not enforce purity
14:41:17 <kmc> because they're a conceptually nicer solution than having every "let"-bound variable sometimes change out from under you
14:41:49 <Saizan_> you can mutate let bound variables like that in ocaml?
14:41:54 <kmc> no
14:41:59 <kmc> but you can in other functional languages
14:42:28 <Saizan_> some lisp, i guess
14:42:32 <kmc> scheme
14:42:46 <kmc> javascript
14:43:18 <fracture> I'd find it interesting to see a language where everything is immutable by default, but could be marked mutable (instead of marked "const")
14:44:14 <shepheb> fracture: some Schemers mark variables which are setq!'d by conventional names.
14:44:42 <kmc> the point is, "the number 3" and "a location in memory that is currently holding the number 3" are conceptually different things
14:45:06 <kmc> not just in ML and Haskell, but in any conceptual system of reasoning about how computers work
14:45:38 <kmc> it's to the discredit of many programming languages that they encourage people to confuse these two very different things
14:45:52 <Stinger> heh I was reading something recently about some programming language that let you change the values of numbers
14:46:02 <kmc> > let 2 + 2 = 5 in 2 + 2
14:46:02 <Stinger> 3 := 5
14:46:04 <lambdabot>   5
14:46:39 <fracture> kmc: but I'm not sure that is really something most languages encourage confusion on?
14:47:03 <dmead> not that again
14:47:05 <Stinger> > let 2 = 5 in 2 + 2
14:47:06 <lambdabot>   4
14:47:14 <dmead> it's not changing the value
14:47:20 <dmead> it's overloadign the + operator for a specific value
14:47:22 <fracture> and much of the time, I think there are good reasons to metaphorically identify memory locations, values, even identifiers just to simplify reasoning about the program
14:47:29 <kmc> dmead, indeed, shadowing it for all values
14:47:32 <kmc> > let 2 + 2 = 5 in 1 + 1
14:47:33 <lambdabot>   * Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
14:47:34 <dmead> i complained about it
14:47:38 <dmead> and was shot down
14:47:50 <kmc> fracture, it makes reasoning about programs *much* more complicated
14:48:00 <kmc> because a value never changes
14:48:18 <kmc> but if you encourage people to think of value and state as interchangeable, then they build things with more mutation than is necessary
14:48:26 <fracture> kmc: but even in pure mathematics people do this sort of sloppy reasoning to make things *easier* to reason about
14:48:26 <kmc> the clojure guy had a good talk on this
14:48:39 <fracture> e.g. talking about an operator on a vectors space "moving" vectors, etc
14:48:44 <dmead> the clojure guy things callcc is dumb :/
14:48:49 <dmead> *thinks
14:49:02 <kmc> fracture, that's very different.  the maths people don't write functions that *actually* modify their inputs
14:49:08 <fracture> I think the distinction your making is probably useful in certain contexts, but it's certainly not all the time
14:49:21 <fracture> kmc: correct, however they think of them that way frequently
14:49:22 <Adamant> dmead: he probably thinks that because the JVM makes it hard to do efficently
14:49:27 <kmc> fracture, no they don't
14:49:34 <dmead> Adamant, probably
14:49:37 <fracture> and they often conceptualize the "modification" as a movement in space or through time, etc
14:49:41 <fracture> kmc: oh come on
14:49:51 <fracture> I'm talking about intuitive reasoning about mathematics
14:49:54 <fracture> not the formalism
14:49:57 <kmc> fracture, me too
14:50:01 <fracture> blah
14:50:01 <kmc> "Let a = 2.  Let f(x) = x+1.  Let b = f(a)"
14:50:01 <dmead> referential transparancy eh?
14:50:14 <ski> they think of the "modification" as transforming the value into a new value. the value isn't changed, the transform produces a new (related) value
14:50:14 <kmc> fracture, nobody reading that in a proof would think that now a == 3
14:50:20 <fracture> people even conceptualize a single function as movement sometimes
14:50:24 <kmc> but our programming languages encourage us to write code that *actually* works that way!
14:50:26 <ski> then they go on reasoning about the transforms themselves
14:50:31 <fracture> "f is running up to infinity as you go to the right"
14:50:48 <dmead> referential transparancy !
14:51:31 <kmc> fracture, it is very different to say "f adds 1 to its argument" as shorthand, versus writing a function that *actually* clobbers its argument
14:51:46 <ski> "`f(x)' is approaching `5' as `x' is approaching `3'"
14:52:27 <fracture> my point now is just that different ways of conceptualizing computation may make sense in different contexts
14:52:44 <kmc> certainly
14:52:59 <fracture> and... shorthands are useful :)
14:53:25 <ski> this isn't about `x' taking on a sequence of values, even a continuous one, but a way to conveniently reuse old figures of speech with new (well) precise meanings (in this case something about `epsilon' and `delta')
14:53:54 <kmc> fracture, i am not arguing against using shorthand for describing programs
14:54:01 <fracture> ski: I think it's more about making it easier to think about thinks
14:54:12 <ski> (and mutation is not a shorthand)
14:54:21 <ski> fracture : i agree
14:54:22 <kmc> i am arguing against thinking in such a way that we write programs that are *actually different* in a worse way
14:54:25 <fracture> we have a lot of brain-hardware that is evolved for thinking about movement and time and things like that, not so much for epsilon delta proofs
14:54:45 <kmc> fracture, so use that hardware with a State monad or an operator like (//) that "modifies" by returning a new value
14:55:04 <ski> fracture : we don't really use that with continuity, though
14:55:22 <fracture> ski: which?  time and space concepts?
14:55:40 <manju|afk> can functions names be in a language other than english ?
14:55:58 <ski> of course we use those, but we don't (or shouldn't, at least) use movement for reasoning about continuity
14:56:48 <ski> (what we use is the theorems we have proved about continuity, differentiability, &c.)
14:57:43 <o-_-o> can I overload a string to be a function name ?
14:57:48 <kmc> if f and g both return some variation on their argument, and f also clobbers its caller's copy of that value, but g doesn't... i don't see how you can argue the difference between f and g is merely a matter of "different ways of conceptualizing computation" or "useful shorthand"
14:57:58 <kmc> nor do i see what that has to do with an "intuitive understanding" of maths
14:58:20 <Saizan_> o-_-o: what do you mean by that?
14:58:20 <kmc> even if we intuitively described a maths function in state-update terms, we certainly wouldn't expect it to actually modify previously defined values
14:58:45 <o-_-o> "ϒ" x y  = x + y
14:58:48 <fracture> kmc: the math point was to point out that your claim about "values" does not have a basis in the way people actually think about mathematics
14:58:48 <o-_-o> something like this
14:58:54 <kmc> fracture, yes it does
14:58:57 <fracture> it does, of course, match with how mathematics is formalized
14:59:24 <o-_-o> or even ϒ x y = x + y
14:59:25 <Saizan_> o-_-o: no, you can't use " in identifiers
14:59:37 <o-_-o> Saizan_: awww... :(
14:59:40 <Saizan_> o-_-o: the latter should work
14:59:42 <fracture> and re f and g, that's clearly not something I was claiming
14:59:52 <o-_-o> Saizan_: nah...I tried
15:00:00 <Saizan_> > let ϒ x y = x + y in  ϒ 1 2
15:00:01 <lambdabot>   Not in scope: data constructor `ϒ'Not in scope: data constructor `ϒ'
15:00:15 <ski> `isUpper' ?
15:00:18 <Stinger> yeah if Y is a capital
15:00:29 <Saizan_> > isUpper 'ϒ'
15:00:30 <lambdabot>   True
15:00:33 <o-_-o> it is not Y
15:00:43 <o-_-o> it is some unicode character
15:00:46 <Stinger> yeah I know, but I don't know htf to type that
15:00:46 <fracture> ski: I think the way things work in practice is not how you describe it
15:00:54 <Saizan_> o-_-o: you want a version of  ϒ that's not considered uppercase
15:01:01 <o-_-o> copy pasta :-)
15:01:06 <o-_-o> or use kcharselect
15:01:07 <Stinger> I am lazy
15:01:15 <o-_-o> Saizan_: ah
15:01:16 <Stinger> that would require moving my hand to the mouse
15:01:20 <o-_-o> Saizan_: wow
15:01:25 <kmc> > toLower 'ϒ'
15:01:27 <lambdabot>   '\978'
15:01:33 <kmc> hmm seems bogus
15:02:00 <o-_-o> >let ε x y = x+ y  in ε 1  2
15:02:10 <o-_-o> > let ε x y = x+ y  in ε 1  2
15:02:11 <lambdabot>   3
15:02:14 <o-_-o> wow
15:02:18 <o-_-o> cool
15:02:25 * o-_-o is blown away
15:02:54 <stoop> :-)
15:03:01 <kmc> fracture, i think when people think of values in maths changing over time, they think of it as time being an additional function parameter, not as a mutable update in any sense resembling imperative programming
15:03:03 <stoop> It is convenient, indeed.
15:03:12 <kmc> if you ask them for a representation they will draw either a graph or a table with a "time" axis
15:03:18 <kmc> and you expect to move "back" and "forward" in time at will
15:03:20 <fracture> kmc: in some cases, sure, or if they are being formal
15:03:26 <fracture> kmc: but I assure you it is not always that formal
15:03:41 <fracture> (and there's a reason for that:  it's easier to be sloppy and then check the intuition later using rigor)
15:04:08 <kmc> hmm i can't make my mind work that way
15:04:18 <kmc> to me the time parameter is the natural, intuitive way
15:04:20 <o-_-o> I wonder if I can write a function in my native language
15:04:27 <kmc> and not more "formal"
15:04:31 <kmc> o-_-o, which is that?
15:05:43 <Cale> The lowercase of ϒ would be υ, I believe.
15:05:52 <Cale> > 'υ'
15:05:53 <lambdabot>   '\965'
15:05:56 <Cale> hmm
15:06:06 <kmc> fracture, i honestly don't understand how the "sloppy" maths interpretation you describe is supposed to be anything like assigning through an IORef
15:06:41 <o-_-o> `isUpper` ಊ
15:06:44 <o-_-o> > `isUpper` ಊ
15:06:45 <lambdabot>   <no location info>: parse error on input ``'
15:06:52 <kmc> > isUpper 'ಊ'
15:06:53 <lambdabot>   False
15:06:53 <fracture> kmc: I haven't said anything about IORefs...
15:06:57 <o-_-o> > isUpper ಊ
15:06:59 <lambdabot>   Not in scope: `ಊ'
15:07:05 <o-_-o> > isUpper 'ಊ'
15:07:07 <lambdabot>   False
15:07:10 <Cale> oh, it just lowercased to itself for some reason
15:07:19 <o-_-o> wow
15:07:39 <Cale> (the capital upsilon with hook)
15:07:54 <Cale> > toLower 'Υ'
15:07:56 <lambdabot>   '\965'
15:07:59 <Cale> aha
15:08:08 <Cale> > toLower 'Υ' == 'υ'
15:08:09 <kmc> fracture, i was arguing for separating the concept of value from the concept of storage cell, and arguing that maths works this way
15:08:09 <lambdabot>   True
15:08:11 <fracture> kmc: how do you conceptualize a rotation of R^2?
15:08:30 <kmc> you said that was cumbersome and we should think of them as being the same when we're being "sloppy"
15:08:49 <kmc> so i take it to mean that you think various parts of maths proofs should act like mutable reference cells
15:09:05 <kmc> fracture, a function that takes each point in R^2 to another point in R^2?
15:09:30 <fracture> kmc: are you saying you are incapable of viewing it in a visual sense ("rotating it in your mind")?
15:09:40 <kmc> no, i don't consider visualization and conceptualization to be the same thing
15:09:58 <Cale> fracture: The rotation itself is a function though.
15:10:03 <fracture> anyway all I was rejecting was the notion that we need to be pedantic about the difference between a value and a storage cell at all times when thinking about the behavior of a program
15:10:05 <kmc> i can visualize a rotation graphically.  again, i don't see what that has to do with IORefs
15:10:25 <fracture> for example, at certain levels, it might be better to think only of "moving" memory (another metaphor) instead of assigning values
15:10:33 <Cale> fracture: I think it's *extremely* important to see that difference clearly.
15:10:34 <fracture> Cale: of course
15:10:38 <kmc> fracture, it's not a matter of pedantry.  when we ignore this distinction we write markedly worse programs
15:10:46 <kmc> consider the difficulty of adding multithreading to your typical C++ app
15:10:50 <fracture> kmc: I've never mentioned IORefs...  I don't know who you're arguing against
15:10:52 <kmc> because everyone has used destructive updates everywhere
15:11:13 <fracture> Cale: which difference?
15:11:17 <Saizan_> fracture: you're talking about storage cells, those are IORefs
15:11:18 <Cale> fracture: In fact, I've even gone as far as translating imperative programs into Haskell, turning each line/step into a function, and local mutable variables into function parameters in order to understand what was going on.
15:11:23 <kmc> "rejecting was the notion that we need to be pedantic about the difference between a value and a storage cell"... so every value is a storage cell.... so every value is (for example) an IORef
15:11:37 <Saizan_> or better, IORefs are a kind of storage cells
15:11:53 <Cale> fracture: Once all the mutation had been removed, I could apply equational reasoning to simplify the program and see what it actually did.
15:11:54 <fracture> Saizan_: thanks.  (terminology problem)
15:12:20 <toast-opt> quick q... i can write my own if it doesn't exit, but is there a built in pretty-printer for tree-like data structures?
15:12:26 <Cale> Confusing the idea of a value with the idea of a mutable cell tends to result in the breakdown of all equational laws.
15:12:29 <fracture> Cale: I'm not sure what that has to do with the content of this discussion, though?
15:12:36 <Saizan_> toast-opt: Data.Tree has showTree
15:12:50 <kmc> fracture, sorry, i thought you knew what an IORef was
15:13:00 <Cale> fracture: Well, it seems like you're saying that it's okay to confuse variables with mutable cells?
15:13:13 <kmc> i wanted a concrete model of mutable cells so we'd be clear on what they are
15:13:28 <Cale> fracture: The problem with having variables refer to mutable cells rather than values is that laws no longer hold.
15:13:29 <fracture> Cale: I'm saying it depends on what you're doing
15:13:45 <toast-opt> saizan_, hmm, i already have a tree type, and it's more complicated than that
15:13:46 <kmc> toast-opt, how pretty?
15:14:00 <toast-opt> kmc, eh, JSON-style indenting would be nice
15:14:21 <kmc> i don't know of anything for that.  if you want to roll your own, Text.PrettyPrint.HughesPJ is useful
15:14:27 <Cale> And, well, at least for me, it becomes nearly impossible to understand what's happening in the code. You're forced to read each step in order to figure out how things get transformed. You essentially can't look at anything in isolation anymore.
15:14:32 <toast-opt> dos style 'tree' would be nice though
15:15:17 <toast-opt> i should probably just write my owns, as practice
15:15:21 <Cale> I like being able to figure out what each variable is *once*, rather than on each line of the program.
15:15:32 <fracture> Cale: so... what about at the machine level; it seems like the confusion happens in precisely the opposite way
15:15:33 <idnar> I think you guys are talking past each other
15:15:34 <kmc> Cale, and each *dynamic* line at that
15:15:48 <kmc> fracture, in what situation is it better to pretend values and storage cells are the same?
15:15:48 <o-_-o> > ಕೋಡಿಸು x y = x + y in ಕೋಡಿಸು 2 3
15:15:49 <idnar> I think fracture is talking about /thinking/ about variables and mutable cells, not about /using/ them
15:15:49 <lambdabot>   <no location info>: lexical error at character '\3275'
15:15:53 <kmc> i don't see how that is a simplifying assumption
15:16:01 <fracture> Cale: e.g., I recall trying to explain to a friend doing CS homework a little while back how his literal "values" in the code need to be stored in the program binary somewhere
15:16:09 <o-_-o> awww.. :(
15:16:21 <Saizan_> toast-opt: so you'd want somenthing like Show but properly indented, or prettier?
15:16:32 <fracture> different metaphors seem applicable to programming in machine language easily---namely, think of memory as a linear array and think about "moving" things around and mutating it
15:16:55 <kmc> fracture, right -- the program binary has a number of (read-only) storage cells
15:17:01 <kmc> which contain values (numbers)
15:17:14 <fracture> but how can you contain a number?
15:17:15 <o-_-o> > ಕ x y = x + y in ಕ 2 3
15:17:16 <Cale> fracture: Well, the machine language is implemented by circuits whose behaviour is governed by purely declarative differential equations :)
15:17:16 <lambdabot>   <no location info>: parse error on input `='
15:17:22 <kmc> fracture, it's the definition of a cell
15:17:25 <sohum> o-_-o: you need let
15:17:26 <fracture> you mean they are put in a bijective correspondence with the set of all values, right?
15:17:30 <fracture> let's be *clear* here.
15:17:32 <kmc> at the machine level, the distinction between storage cells and values couldn't be more clear
15:17:33 <fracture> ;)
15:17:34 <sohum> > let ಕೋಡಿಸು x y = x + y in ಕೋಡಿಸು 2 3
15:17:36 <lambdabot>   <no location info>: lexical error at character '\3275'
15:17:36 <o-_-o> > let ಕೋಡಿಸು x y = x + y in ಕೋಡಿಸು 2 3
15:17:37 <lambdabot>   <no location info>: lexical error at character '\3275'
15:17:47 <sohum> I wonder why that doesn't work
15:18:03 <Saizan_> toast-opt: this might be vaguely relevant http://hackage.haskell.org/package/hstidy
15:18:09 <toast-opt> Saizan_, yeah, esp for tree like 'data' definitions
15:18:34 <Cale> At the machine level, values are represented by (vectors of) voltages at a given point in time, while storage cells are represented by actual circuitry.
15:18:37 <kmc> fracture, you are saying that moving and mutating memory is a natural thing to do.  i agree entirely.  my point is that these are operations on storage cells, not on values
15:18:38 <fracture> Cale: sure, but that's back to where kmc and I were a bit ago...  math is often easier to conceptualize nondeclaratively as well
15:18:49 <kmc> i am not saying operations on storage cells are bad or second-class
15:18:53 <Cale> As a mathematician, I can't really agree with that.
15:18:57 <o-_-o> anyone why that doesn't work ?
15:19:11 <toast-opt> Saizan_, sweet.  would be nice as a lib too though
15:19:18 <toast-opt> String -> String
15:19:40 <Cale> I mean, sure, I might think about things changing via some process, but I immediately encode the process as a completely declarative function which doesn't change.
15:19:50 <Saizan_> toast-opt: yeah, you can probably tear it apart, it's a thin wrapper around haskell-src-exts
15:19:57 <fracture> Cale: and that's exactly what I'm talking about.
15:19:58 <kmc> the problem is that C and C++ make it easier to declare a storage cell than to declare a mere shorthand name for an unchanging value
15:20:06 <kmc> so people use storage cells when they don't need them
15:20:10 <Cale> Because unless I do that, there's no way to reason about it.
15:20:22 <Cale> Well, I could adopt some sort of temporal logic, I suppose.
15:20:22 <fracture> well, not with as much certainty
15:20:23 <toast-opt> saizan_, thx for the suggestion.  i might just pipe my Strings to it
15:20:26 <o-_-o> anyone here who works on GHCI ?
15:20:31 <fracture> but truthfully you must admit, you have to reason about it intuitively first, no?
15:20:48 <o-_-o> I wonder if function names can be non-english (non-latin and non-greek)
15:20:55 <idnar> not everyone uses intuitive reasoning
15:21:01 <Cale> Well, I might apply more than one intuition to is.
15:21:02 <Cale> it*
15:21:23 <kmc> "uniLarge 	 -> 	 any uppercase or titlecase Unicode letter "  -- from the Report
15:21:37 <toast-opt> o-_-o, that brings up a terrible question though... how to distinguish type constructors from other identifiers
15:21:39 <kmc> "uniSmall 	 -> 	 any Unicode lowercase letter "
15:21:42 <Saizan_> o-_-o: they can, they just have to be classified as letters by unicode
15:21:42 <fracture> idnar: I doubt that is true.
15:21:47 <kmc> those are terms defined, i believe, by Unicode itself
15:21:59 <Saizan_> o-_-o: and the first letter must be lowercase, still according to unicode
15:22:05 <o-_-o> they are letters in my language
15:22:07 <idnar> I'm on the flip side of that; I work almost exclusively with intuitive reasoning, except when I'm trying to communicate with others
15:22:28 <o-_-o> > isUpper 'ಕ'
15:22:28 <idnar> but my intuition for variables doesn't really have anything to do with value cells
15:22:29 <lambdabot>   False
15:22:32 <idnar> it's purely abstract
15:22:43 <o-_-o> > let ಕ x y = x + y in ಕ 2 3
15:22:44 <lambdabot>   5
15:22:48 <o-_-o> wow
15:22:52 <o-_-o> wtf ?
15:22:57 <o-_-o> what ?
15:22:58 <fracture> mine usually doesn't either---except when it's supposed to and useful to (low level programming)
15:23:12 <Cale> In any case, I always think of a variable as referring to a fixed value rather than to something which changes in mathematics.
15:23:18 <idnar> it's not really an intuition in low level programming, unless you're programming a lisp machine or something
15:23:20 <bfh6558> So im reading learnYouHaskell and for some reason ghci is giving me a parse error when i try to define the function: boomBang xs = [if x < 10 then "BOOM!" else "BANG!" | x <-xs, odd x] Does anyone see any syntax mistakes with this?
15:23:20 <o-_-o> > isUpper 'ಕೋ'
15:23:21 <lambdabot>   <no location info>:
15:23:21 <lambdabot>      lexical error in string/character literal at chara...
15:23:29 <idnar> I mean, you're generally dealing with a real value cell :P
15:23:29 <o-_-o> hmmm...it is a bug
15:23:40 <Saizan_> o-_-o: those look like 2 characters here
15:23:46 <Saizan_> o-_-o: maybe it's an encoding problem
15:23:47 <Cale> bfh6558: Where are you putting that definition?
15:23:53 <o-_-o> Saizan_: not really
15:23:57 <Saizan_> o-_-o: lambdabot expects utf8 input
15:23:59 <bfh6558> strait to gchi, do i need to put it in a scriptfiel?
15:23:59 <fracture> idnar: well, somewhere ;)  but even in C++ some people here seem to forget that the compiler is the one who decides what ends up in value cells and what doesn't
15:24:00 <Cale> bfh6558: You're meant to put definitions into a file, and load that file in ghci
15:24:03 <o-_-o> Saizan_: it reads as koo
15:24:05 <fracture> (within rules)
15:24:09 <bfh6558> Cale: :) thanks
15:24:12 <o-_-o> Saizan_: I think it is utf8
15:24:18 <o-_-o> although I dunno how to verify
15:24:20 <Cale> bfh6558: You can reload the file if you change it by typing :r
15:24:24 <fracture> Cale: even when you think about limits?
15:24:25 <idnar> fracture: oh boy, don't talk to me about C++
15:24:29 <Cale> bfh6558: So it's nice to keep two windows open.
15:24:39 <idnar> fracture: I spent nearly 10 years writing C++ code because I thought it was TEH HARDCOREZ AWESOMEZ
15:24:39 <bfh6558> yeah I'll open a vim next to it
15:24:43 <bfh6558> thank you ca
15:24:52 <idnar> fracture: eventually someone hit me on the head hard enough to reverse the brain damage :P
15:24:57 <fracture> hah
15:25:01 <Saizan_> o-_-o: well, here it looks like two boxes, so i think ghc sees it as two characters and complains that you can't put two characters inside ''
15:25:05 <kmc> C++ will rot your brain
15:25:10 <Cale> fracture: Sure. I think about the sequence of points, and a single point (if it exists) which is the limit of that sequence.
15:25:15 <o-_-o> Saizan_: ah...ok
15:25:16 <Berengal> idnar: C++ IS hardcore. It's neither AWESOMEZ nor TEH though...
15:25:16 <Cale> fracture: Or limits of functions similarly.
15:25:25 <idnar> Berengal: hee hee
15:25:27 <o-_-o> Saizan_: maybe that is true
15:25:36 <Cale> The limit doesn't change :)
15:25:49 <kmc> fracture, the rules are quite restricted... for example even a "const int" has an address and thus must be stored somewhere
15:25:52 <o-_-o> > isUpper 'ಕ್'
15:25:54 <lambdabot>   <no location info>:
15:25:54 <lambdabot>      lexical error in string/character literal at chara...
15:25:57 <o-_-o> yes
15:25:58 <idnar> Berengal: http://www.penny-arcade.com/comic/2008/03/12
15:25:58 <bfh6558> why all the hate for c++ here? lol
15:26:00 <fracture> kmc: that's not true.  :)
15:26:01 <o-_-o> it is 2 characters
15:26:15 <kmc> fracture, i can't do { const int x = 3; const int* const y = &x; } ?
15:26:27 <fracture> C++ has its uses... it's certainly not a pretty language by any stretch, though
15:26:40 <bfh6558> I just taught myself c++ for a data/file structure class and i found it much better than C and much more likable than c#
15:26:43 <fracture> fracture: you can, but the compiler does not have to allocate storage for x if you don't take its address
15:26:50 <Saizan_> o-_-o: however, lambdabot has its own parser, so i'd try those things in an .hs file directly, it's more likely to not have a bug :)
15:26:50 <kmc> bfh6558, how much of C++ do you know?
15:27:00 <kmc> bfh6558, have you read the C++ FAQ and FQA?
15:27:03 <bfh6558> aprox 4months lol
15:27:15 <kmc> most people who just learned C++ actually learned C plus a tiny subset of C++
15:27:26 <toast-opt> lol, the C++ FQA is for awesome.
15:27:27 <kmc> however, it may be advisable to program in such a language rather than using all of C++
15:27:32 <kmc> however, everyone has their own different subset.
15:27:41 <toast-opt> I *like* C++, but still find the FQA a wonderful read
15:27:45 <fracture> about 5% of "C++ programmers" I've met even know what certain basic language features *are*, much less how to use them
15:27:52 <bfh6558> I didnt get much into generics but I'm working on a dykstras algo model atm for the class
15:27:55 <kmc> fracture, which ones?
15:28:05 <fracture> toast-opt: there are a few answers in there that I think are kinda retarded, but it is pretty good overall ;)
15:28:08 <toast-opt> kmc, which programmers, or which features?
15:28:10 <kmc> C++ doesn't have anything called "generics"
15:28:11 <kmc> which features
15:28:28 <bfh6558> kmc: templates sorry
15:28:29 <fracture> kmc: partial template specialization and template specialization, how to write a member function template outside of a class, etc
15:28:33 <fracture> basic syntactical issues
15:28:47 <fracture> people score even lower on how to actually *use* most of that stuff
15:28:53 <Cale> bfh6558: There are a lot of reasons why I'd hate to have to program in C++. The first is that it has no proper support for functions, and I refuse to program without functions. What C++ calls functions, I can't use my program to construct or transform. I can pass around pointers to existing functions which is not the same thing.
15:28:55 <kmc> bfh6558, fracture, templates are their own language.  it's a metalanguage for C++ that's nothing like C++, and is a very ad-hoc painful declarative functional language
15:29:43 <bfh6558> metalanguages are still languages
15:29:46 <fracture> kmc: I implemented a binary tree data structure using Boost.MPL... I'm well aware of that :)
15:29:56 <bfh6558> and if its a part of c++ its more of a dialect id say
15:30:09 <toast-opt> bfh, bad metalanguages are still languages
15:30:10 <fracture> and the compile-time language has immutable data :)
15:30:17 <kmc> bfh6558, it's nothing like C++.  "dialect" implies similarity
15:30:21 <bfh6558> hah
15:30:23 <Cale> bfh6558: I suppose the next thing is that C++ is *really* overcomplicated in ways that are pointless in that they give almost no benefit for the cost. The template system is an incredibly heavyweight thing when all you want is normal parametric polymorphism.
15:30:42 <Cale> The C++ type system sucks, there's no type inference and types are unreadable.
15:30:48 <toast-opt> cale, the one that bugs me is that function templates names are not values :(
15:30:53 <bfh6558> I wish i had known about haskell when i decided to teach myself a new language for myclass this semester
15:30:55 <kmc> Cale, didn't you hear, they have "functors"!  why do it in one line of code when you can use 15?  and why have the compiler decide the in-memory layout of closures or do lambda lifting when you can write it yourself, from scratch, every time
15:31:04 <ddarius> There's a sort of bizarre minor bit of type inference.
15:31:06 <Cale> kmc: exactly
15:31:13 <Cale> ddarius: Well, yes :)
15:31:31 <Cale> ddarius: Just enough to make one wonder why they bothered at all.
15:31:38 <ddarius> Cale: It helps.
15:31:43 <Cale> Okay, yes.
15:31:49 <kmc> fracture, that's an accomplishment much like writing a binary tree datastructure in brainfuck
15:31:52 <Cale> But if you're going to do that much, why not a little more?
15:31:54 <Saizan_> which bit?
15:32:03 <toast-opt> template <class Num> Num add2(Num n) { return n + 2; }  int main(){  vector<int> v = ...; map(v.begin(),v.end(),v.begin(), add2); } -- illegal, because add2 is not a value
15:32:08 <fracture> kmc: yeah.... you should see it (it's horribly disgusting)
15:32:15 <Berengal> I claim that manifest typing is a curse on static safety.
15:32:24 <ddarius> Cale: Because C++'s template system is insane.  The "inference" it does have is a pile of ad-hoc rules.
15:32:32 <toast-opt> \n -> n + 2 -- totally legal :)
15:32:47 <fracture> Cale: I think it is partially the extreme backward-compatability culture, no?
15:33:00 <Cale> fracture: Oh, certainly, there is that.
15:33:03 <bfh6558> Could anyone point me to a well written haskell book? I usually like to have a reference manual that isnt online
15:33:32 <toast-opt> ddarius, i had a case this week where i really wished for this to type inference properly: { auto it;  if ((it = m.find("x")) != m.end()) {...} }
15:33:42 <kmc> fracture, i don't think expecting each "C++ programmer" to know how to do that is reasonable
15:33:44 <Cale> bfh6558: For starting out, there's "Programming in Haskell" by Graham Hutton, which is supposed to be rather good. Also, "Real World Haskell", which is also available freely online.
15:33:58 <fracture> kmc: how to write a member function template outside of a class?  or what?
15:34:05 <ddarius> kmc: They should...
15:34:07 <kmc> i don't consider any part of templates to be a basic language feature
15:34:09 <fracture> kmc: I think it'd be nice if people who say they "know C++" actually do...
15:34:11 <kmc> except possibly using STL
15:34:22 <kmc> fracture, i can say i know Haskell without you assuming i've used Template Haskell
15:34:31 <fracture> I think templates are more basic and more important than classes
15:34:40 <fracture> certainly more important than inheritance
15:34:41 <kmc> and TH actually uses Haskell as the metalanguage
15:34:43 <ddarius> Template Haskell is a compiler-specific extension.
15:35:06 <toast-opt> kmc, not fair, really.  templates are C++'s polymorphism.  it's more like saying you know haskell without understanding Num
15:35:20 <toast-opt> or worse, without understanding a -> a -> a
15:35:37 <kmc> toast-opt, i think partial template specializations go beyond "polymorphism"
15:35:49 * fracture wouldn't say he "knows" haskell.
15:36:01 <kmc> and C++ has several different-but-poorly-interacting mechanisms for polymorphism, like for everything else
15:36:05 <toast-opt> kmc, yes.  it's pattern matching.  like 'fact x = x * fact (x-1); fact 0 = 1'
15:36:52 <toast-opt> template <int x> struct fact { enum { value = x * fact<x-1>::value } }; template <> struct fact<0> { enum { value = 1 }};
15:37:01 <Cale> http://i.imgur.com/NWqCz.jpg -- lol
15:37:19 <fracture> kmc: well, at the least they should know what it *is*, right?
15:37:37 <kmc> fracture, ideally.  but i'd be more worried if they were missing some of the non-template features
15:37:55 <fracture> kmc: most of them miss some of those, too
15:38:06 <kmc> that's where i'd focus my annoyance personally :)
15:38:38 <ddarius> If someone said they "knew (modern) C++" and couldn't use templates beyond using the STL, I'd consider them either incompetent or a liar.
15:38:38 <fracture> but part of the problem is also the language---it's probably too complex for a lot of the types of programming done in it
15:38:45 <toast-opt> fracture, like not knowing that 'new X' should throw?
15:39:00 <toast-opt> er, /should/can/
15:39:00 <fracture> toast-opt: sure, good example
15:39:05 <ddarius> toast-opt: Who doesn't know that?
15:39:12 <fracture> or what the phrase "exception safety" means
15:39:18 <kmc> fracture, yes.  99% of code should be written in a managed language anyway
15:39:22 <fracture> or what private inheritance is for
15:39:30 <fracture> ... list goes on :)
15:39:32 <toast-opt> fracture, yeah.  RAII
15:39:33 <Cale> http://math.ucr.edu/home/baez/week285.html -- this is really cool :)
15:39:43 * kmc goes over to ##c++ to see if they're discussing Haskell
15:40:12 <kmc> Cale, nice
15:41:02 * fracture chuckles (there's motion-related metaphors used on that page).
15:41:55 * ddarius doesn't use motion related metaphors for mutable state as it tends to change discretely.
15:42:38 * fracture would like to make a motion to table the metaphor.
15:42:54 <Berengal> Cale: Nice.
15:43:10 <Berengal> Some of the edges of the circle look like a dragon...
15:44:14 <Cale> I've made similar images with *much* smaller sets of roots, and I can't help but think of how much computation went into these pictures.
15:45:16 <toast-opt> um, is that the dragon fractal?
15:45:23 <toast-opt> hidden in there?
15:45:40 <Cale> (I had something similar to the first image :)
15:46:00 * hackagebot upload: plist 0.0.1 - Generate and parse Mac OX property list format (YurasShumovich)
15:47:27 <toast-opt> the high density image looks like, around 0.5 angle 45 deg, it has the dragon curve embedded in it
15:47:55 <Berengal> toast-opt: That's what I meant
15:48:04 <Berengal> When I said earlier it looked like a dragon
15:48:20 <toast-opt> ah, sorry, missed that
15:49:06 <bfh6558> so quick question is the _ in haskell kind of like a bitdump?
15:49:20 <kmc> bfh6558, it's a pattern that matches anything and does not bind any variables
15:49:23 <Stinger> _ = I dont fkn care
15:49:36 <Cale> http://cale.yi.org/share/AlgInt0.png  http://cale.yi.org/share/AlgInt1.png -- I still have my pictures :)
15:49:44 <kmc> > let _ = error "don't touch" in 4
15:49:44 <cjs> Oh, sweet!
15:49:45 <lambdabot>   4
15:50:00 <cjs> I didn't realize that Haddock generated an index-frames.html as well.
15:50:05 <Cale> (as you can see, I didn't do nearly as much computation to produce them :)
15:50:09 <bfh6558> kmc: are the mechanics of how the compiler actually knows that way out of my league?
15:50:18 <toast-opt> Cale, server not found?
15:50:23 <Cale> er...
15:50:24 <Cale> oh
15:50:38 <Cale> I'll check everything :)
15:51:17 <toast-opt> working now
15:51:50 <kmc> bfh6558, ?
15:51:54 <kmc> knows what?
15:52:25 <kmc> it's just the same as
15:52:36 <kmc> > let areallycrazyvariablenameidon'tuseanywhereelse = error "don't touch" in 4
15:52:37 <lambdabot>   4
15:53:30 <Cale> You might check that cale.yi.org is resolving to 99.247.248.73
15:53:39 <Saizan_> those are quite pretty already
16:04:03 <Cale> Weird how connecting to IRC seems way more sensitive to problems with my internet connection than almost anything else. I can browse the web just fine sometimes and yet attempts to connect to an IRC server will get nowhere.
16:04:50 <Cale> Perhaps it's packet loss, and the IRC client is being too forgiving about reattempts.
16:05:32 <p_l> Cale: I could bet on the fact that "ISP"s nowadays only check if HTTP/HTTPS is working, everything else can go fuck itself
16:07:54 <toast-opt> Cale, it eventually resolved.  my wife and I vote your plot the most asthetically pleasing
16:08:16 <toast-opt> mostly because of the mosaic of interlocking semicircles are most visible
16:08:34 <Saizan_> no dragon though
16:09:16 <toast-opt> tru, no dragon
16:09:43 <toast-opt> ... i need to start looking for interesting ways to graph parser combinators though
16:42:09 <JohnDoe365> Hi
16:42:26 <JohnDoe365> I'm new to haskell
16:42:28 <Cale> hello
16:42:39 <JohnDoe365> but did some erlang
16:42:48 <Cale> Be sure to let us know if you have any questions :)
16:43:09 <JohnDoe365> What library would fir me bist, if I'm lookin for the erlang style of Message passing
16:43:15 <JohnDoe365> I do not care about the syntax
16:43:19 <JohnDoe365> but sematics and functionality
16:43:32 <Cale> ah, hmm
16:43:52 <Twey> Control.Concurrent, or erlang if you need to act as a node
16:44:15 <Cale> Yeah, take a look at Control.Concurrent.Chan specifically
16:44:39 <JohnDoe365> @Twey: Yeah, I dig through the library specs and also found Control.Concurrent the most fitting one
16:44:39 <lambdabot> Unknown command, try @list
16:45:16 <Cale> There are other concurrency abstraction libraries as well, which I'm not as familiar with, but which are quite extensive, like CHP (http://hackage.haskell.org/package/chp)
16:45:31 <kmc> there's a cool blog about CHP
16:45:35 <Cale> yeah
16:45:35 <kmc> looks good but very new
16:47:11 <Cale> JohnDoe365: STM is also a really nice thing to either use directly or build abstractions on top of.
16:49:14 <Cale> JohnDoe365: There are various places you can read about STM, but I'd actually recommend (at least the first part of) this paper: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
16:59:42 <JohnDoe365> Cale: I will investigate in STM, but this is completey new to me
17:00:36 <JohnDoe365> STM is about shared state, while message passing is stateless
17:00:56 <JohnDoe365> with the message passing I'm more familiar from erlang
17:09:37 <Cale> JohnDoe365: Well, "stateless", in that the state is isolated to each thread, but there's still state involved in deciding which messages to send, so the threads themselves act like big stateful variables in a way.
17:20:46 <masklinn> > filter id $ zipWith (==) [1..4] [1..5]
17:20:48 <lambdabot>   [True,True,True,True]
17:21:26 <masklinn> > filter not $ zipWith (==) [1..4] [1..5]
17:21:28 <lambdabot>   []
17:21:34 <masklinn> > filter not $ zipWith (==) [2..4] [1..5]
17:21:35 <lambdabot>   [False,False,False]
17:27:52 <Baughn> ivanm: No, it doesn't. Try the darcs version.
17:27:53 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
17:27:56 <Baughn> @clear
17:27:56 <lambdabot> Messages cleared.
17:32:40 <ivanm> Baughn: bah
17:32:41 <ivanm> ;-)
17:34:40 <napsy> Hello. I'm having troubles with return types. makeCPUHog returns IO String which I later convert to String but it doesn't work. Any ideas? http://haskell.pastebin.com/m120aa971
17:35:20 <quicksilver> napsy: you need to use "c <- " not "let c = "
17:35:42 <quicksilver> (let c = .... just makes it a synonym for makeCPUHog so it will still have type IO String)
17:35:48 <Baughn> napsy: <- is the unwrap-from-IO operator. Which is a total lie, but it'll do for now.
17:36:12 <napping> makeCPUHog returns IO String, which disagrees with the :: String
17:36:44 <napsy> hm yes because I'm still getting errors after switching from = to <-
17:37:10 <napping> so um, drop the bad type signature
17:37:21 <napsy> hm now I'm getting an error in show (a+b)
17:37:37 <napping> ++
17:37:50 <napsy> but a and b are Ints
17:38:09 <napping> oh, that should work then
17:38:10 * Cyneox re
17:38:37 <napping> that's not like anything in the paste
17:38:44 <Baughn> Cyneox: re? re what?
17:38:46 <napsy> http://haskell.pastebin.com/m31482d16
17:38:50 <napsy> this is the current code
17:38:52 <napping> oh, the first line
17:39:05 <Cyneox> Baughn: re(turn)
17:39:06 <napping> again, String and IO String are not the same. you need return
17:39:17 <Cyneox> Baughn: i'M back..whatever...
17:39:22 <Baughn> Cyneox: Don't do that. Just use /away.
17:39:37 <Cyneox> Baughn: i use /ame :D
17:39:41 <napsy> huh with return it works
17:39:49 <napsy> so return makes an IO () ?
17:39:57 <napping> :t return
17:39:58 <Baughn> napsy: return :: Monad m => a -> m a
17:39:59 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:40:05 <napsy> ... wraps the type
17:40:05 <quicksilver> napsy: return puts a simple value into IO, yes
17:40:12 <Baughn> napsy: IO is one instance of Monad, so sure
17:40:12 <quicksilver> (or any other Monad, indeed)
17:40:17 <napsy> oh ok
17:40:19 <Baughn> > return 2 :: Maybe Int
17:40:20 <lambdabot>   Just 2
17:40:24 <Baughn> > return 2 :: [Int]
17:40:24 <quicksilver> so ("foo" :: String) while (return "foo" :: IO String)
17:40:25 <lambdabot>   [2]
17:42:37 <napsy> ok thanks guys
17:47:28 <Baughn> napsy: (For more information: Read the typeclassopedia)
17:47:57 <napsy> ok will do
17:50:35 <Baughn> @where typeclassopedia
17:50:35 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
17:51:59 <stulli> The typeclassopedia is great. There i learned that fmap, liftM and <$> (and map for lists) are all the same.
17:52:24 <napsy> One more question: if I make a call first to putStr then to getLine, why is the putStr output shown only after I finished the input?
17:52:48 <Peaker_> ap = <*>, pure = return, too
17:53:08 <quicksilver> napsy: line buffering
17:53:10 <Peaker_> napsy: probably line-buffering is enabled
17:53:16 <quicksilver> napsy: (nothing to with haskell, it's a unix thing)
17:53:27 <quicksilver> hSetBuffering stdout NoBuffering
17:53:41 <stulli> Peaker: Yes, thats very confusing for a beginner like me
17:55:23 <Peaker> stulli: <$> is just an alias, as for ap,return,liftM -- its because Monad doesn't subclass Applicative (and there are no type-class alias mechanism implemented)
17:56:51 <stulli> But why is <$> defined in Applicative and not already in Functor?
17:57:42 <quicksilver> stulli: because Applicative is much newer
17:57:55 <quicksilver> and the authors of applicative happened to prefer infix notation.
17:58:07 <quicksilver> (which I agree with them about)
17:58:41 <dolio> @src (<$>)
17:58:42 <lambdabot> f <$> a = fmap f a
17:59:04 <Peaker> In math, unary functions are generally prefix, but N-ary functions generally have N args "around" them -- not just infix for 2, but above and below for 4, etc
17:59:22 <stulli> quicksilver: It seems like the type classes could be tidied up a little bit. But i guess that would break quite some code
17:59:33 <quicksilver> stulli: agreed
18:00:57 <Peaker> I think we need a lot more type-classes -- for almost everything that intentionally has the same name in different modules..
18:02:36 <fasta> I get "*** Exception: Codec.Compression.Zlib: incorrect header check for a file which has been compressed with Python zlib when I read it with the Haskell GZip (decompress) module (also kind of a bad error message, I must say).
18:06:10 <pastah_rhymez> anyone here tried out F#?
18:06:17 <pastah_rhymez> anyone here tried out F#?
18:06:40 <quicksilver> fasta: probably a 32/64 bit incompatibility
18:06:41 <pastah_rhymez> i'm curious as to similarities to haskell
18:06:50 <quicksilver> fasta: (at least, that has been known to cause that message or a very similar one)
18:07:28 <fasta> quicksilver, this is on 32 bit Linux.
18:07:54 <quicksilver> ah ok. I retract that guess ;)
18:08:00 <toast-opt> pastah, a little bit.  it's an ocaml dialect
18:08:15 <fasta> quicksilver, and I don't really see why the size of the arch has to do with the file. Especially, something as standard as zlib.
18:08:38 <fasta> quicksilver, thanks for trying though :)
18:09:26 <fasta> I think I am just going to see whether or not the Python zlib version can actually understand the Haskell ByteString.
18:14:44 <malcolmw> any gtk2hs developers able to help me build it on windows?
18:15:17 <pastah_rhymez> toast-opt: is there monads?
18:15:44 <toast-opt> pastah_rhymez, well, you can define monads in just about any functional language.  but no type classes afaik
18:15:59 <toast-opt> so you have to pass the monad functions separately i suspect
18:16:13 <toast-opt> you might be able to use the .Net type system though to do something tricky
18:16:27 <fasta> malcolmw, you can also just dump the error messages here.
18:16:29 <pastah_rhymez> toast-opt: how about defining operators?
18:16:33 <toast-opt> it's also not pure... you can have side effects anywhere
18:16:36 <pastah_rhymez> for making DSLs etc.
18:16:48 <toast-opt> pastah_rhymez, + is for Ints, +. for floats, like ocaml
18:17:31 <pastah_rhymez> ok?
18:17:48 <fasta> malcolmw, and what exactly are you trying to do?
18:17:50 <pastah_rhymez> toast-opt: have you defined your own at any time?
18:18:19 <toast-opt> pastah_rhymez, i don't know all the details, but yes you can define your own operators
18:18:22 <fasta> malcolmw, for a new GUI, you might want to look at wx first, since they have the Windows stuff working already without any hassles.
18:18:27 <dolio> F# lacks the ML module system, as well, which is a pretty significant loss.
18:18:46 <quicksilver> arguably it's the only good think about ML ;)_
18:18:46 <malcolmw> fasta: I already have the GUI written in gtk, just need to make it work on windows
18:19:08 <fasta> And the formal semantics, of course.
18:19:12 <malcolmw> fasta: but the only binary pkgs available are for ghc-6.10.3, and I need 6.10.4
18:19:18 <pastah_rhymez> dolio: what can you do with that? import stuff and get fairy dust for free with it?
18:19:20 <quicksilver> presumably F# has the accursed value restriction
18:19:34 <dolio> Philippa mentioned something about F# not having Hindley-Milner either, but I don't really know what she was referring to.
18:19:37 <fasta> malcolmw, ah, ok. What happens when you try it?
18:20:30 <fasta> malcolmw, the differences between .3 and .4 are pretty small, so I don't see why it shouldn't work with maybe some minor modifications.
18:20:31 <malcolmw> fasta: I've ended up (after some fixes) with the same error as at the end of http://hackage.haskell.org/trac/gtk2hs/ticket/1099 for which there was no workaround given
18:20:33 <toast-opt> dolio, i got far enough in F# to know it does have HM type inference.  but I did not get far enough to see how it interacts with the .Net type system with overloading
18:20:53 <dolio> pastah_rhymez: ML modules essentially have types (called signatures), and you can have multiple modules that implement the same signature (and thus can be used interchangeably), and you can parameterize modules by signatures and create functions (functors) from modules with one signature to modules with another signature, and so on.
18:21:05 <malcolmw> fasta: I'm assuming it is some kind of windows configuration problem, rather than anything inherent in the gtk2hs codebase
18:21:32 <pastah_rhymez> dolio: that seems really weird
18:21:42 <pastah_rhymez> but insanely cool
18:21:55 <dolio> They're very good for programming with abstract types.
18:22:42 <pastah_rhymez> i probably need to play with it a little in order to understand
18:22:43 <dolio> Probably the major deficiency of Haskell with respect to the ML family.
18:22:45 <fasta> malcolmw, if you have the same issue, why not reopen the issue?
18:23:11 <pastah_rhymez> dolio: could this be implemented in for haskells module system?
18:23:30 <fasta> malcolmw, do you know what a chs.pp file is?
18:23:33 <quicksilver> pastah_rhymez: haskell's module system is just namespaces
18:23:38 <quicksilver> pastah_rhymez: it's nothing like the ML one
18:23:40 <malcolmw> fasta: I will do, but was hoping I might find some more immediate help here.  Maybe I should just wait for dcoutts to show up :-)
18:24:24 <toast-opt> quicksilver, this module system, which implementations have it?
18:24:31 <fasta> malcolmw, in the end the developers would probably have to do the same work as you would if you would fix it.
18:24:35 <toast-opt> njsml?  ocaml?
18:24:47 <quicksilver> both
18:24:54 <dolio> Pretty much all MLs have some system like it.
18:24:56 <dolio> Except F#.
18:24:56 <fasta> malcolmw, so, do you know about chs.pp files?
18:24:58 <quicksilver> although there might be some detailed differences I forget
18:25:09 <toast-opt> hmm, i should take a look
18:25:20 <malcolmw> fasta: yeah, the .chs means it needs to be preprocessed with c2hs
18:25:29 * toast-opt disliked ocaml having only one impl, and sml being less popular
18:25:43 <malcolmw> fasta: I'm not sure which pre-processor the .pp part refers to
18:25:43 <dolio> Some take it further. For instance, Alice lets you (un)pickle modules (from)to a file.
18:25:53 <fasta> malcolmw, it is cpp.
18:26:45 <fasta> malcolmw, basically it is a hack to have some things preprocessed before c2hs sees it. Kind of awful, really.
18:26:59 <malcolmw> nice :-)
18:27:12 <fasta> malcolmw, the line numbers are correct, AFAIK.
18:27:25 <quicksilver> could be worse. It could be a perl script which is run to generate c2hs output ;)
18:27:52 <malcolmw> quicksilver: eek, yep, you're right, it could be worse
18:28:00 <fasta> malcolmw, so, it is just a matter of looking at that file, and possibly preprocessing it yourself to see what it generates in the end.
18:28:25 <fasta> malcolmw, the analysis in the bug-report seemed fairly good already. It would just be retracing those steps.
18:28:48 <malcolmw> fasta: so, I've got round the preprocessor macro problems already, and reached the problem at the end of the ticket
18:29:11 <malcolmw> fasta: namely, "failed to load interface for System.Glib.UTFString"
18:30:07 <fasta> malcolmw, Please delete all */*.deps files and try again.
18:30:14 <fasta> malcolmw, did you try that already>
18:30:24 <malcolmw> fasta: yeah, there aren't any .deps files
18:30:53 <fasta> malcolmw, do you mean that you deleted all of them or that you don't see them?
18:31:05 <malcolmw> fasta: there weren't any
18:31:19 <fasta> malcolmw, that seems unlikely, unless they changed the build-system.
18:31:31 <fasta> malcolmw, in Windows .foo files are hidden by default.
18:31:47 <fasta> (not that I think I am telling you anything new here)
18:32:53 <fasta> malcolmw, if you really verified that all the .deps files are gone, I cannot help you further without trying it on my own machine for which I don't have the time.
18:33:08 <fasta> It is a horrible error message too. Someone should file a bug report for that.
18:33:11 <malcolmw> fasta: well, thanks for walking through it with me this far
18:33:32 <fasta> malcolmw, np.
18:37:01 <profmakx> which precision do "Doubles" have in Haskell (or GHC for that matter)
18:39:52 <quicksilver> profmakx: it's not defined, but in GHC on "normal" platforms they are your "normal" C double
18:39:57 <quicksilver> profmakx: ...i.e. 64bit IEEE
18:43:18 <Baughn> quicksilver: Does GHC work on any abnormal platforms?
18:43:42 <quicksilver> Baughn: yes. It works on a lot of obscure platforms that support gcc
18:43:47 <quicksilver> Baughn: mipsel, arm, that kind of thing
18:43:55 <quicksilver> Baughn: I've no idea what 'Double' means on them.
18:44:53 <quicksilver> hppa, s390, armel, m68k
18:44:58 <quicksilver> even alpha
18:45:09 <Baughn> Hm. Not advertised, but.. interesting.
18:45:40 <Baughn> quicksilver: And IIRC, using double on those platforms has gcc insert some inline assembly to emulate them with integer math
18:45:59 <quicksilver> maybe so. So maybe it ends up being IEEE 64 bit anyway.
18:46:00 <Baughn> s/those platforms/platforms without FPUs/
18:46:03 <quicksilver> I just wasn't sure :)
18:46:05 <profmakx> thanks quicksilver
18:46:24 <Baughn> quicksilver: Ah. Well, I wouldn't go /that/ far. :P
18:46:41 <quicksilver> the motorola 68881 is 80bit, for example
18:46:52 <quicksilver> you might expect the m68k compile to be non-IEEE then
18:46:59 <quicksilver> btu maybe it's no worse than the x87
18:47:10 <profmakx> *shudder*
18:47:28 <Baughn> What kind of FP code does ghc generate on x86 now? MMX?
18:47:36 <Baughn> SSE, for doubles?
18:47:38 <quicksilver> x87 on x86-32
18:47:41 <profmakx> as my professor in numerical maths said: Dont. Ever. Trust. Floating Point. Ever.
18:47:42 <quicksilver> MMX on x86-64
18:48:16 <tombee> Hi, just wondering if anyone can help me with a function to extract some data from this:
18:48:16 <tombee> inputSet = [(testData1,1),(testData2,0),(testData3,0),(testData4,0)]
18:48:31 <tombee> I'd like to create the list [testData1, testData2, testData3, testData4]
18:48:46 <profmakx> tombee  map fst youlist
18:48:51 <profmakx> orx.
18:48:58 <profmakx> > map fst [(testData1,1),(testData2,0),(testData3,0),(testData4,0)]
18:48:59 <lambdabot>   Not in scope: `testData1'Not in scope: `testData2'Not in scope: `testData3'...
18:49:14 <tombee> thanks! :)
18:49:18 <profmakx> > map fst [("testData1",1),("testData2",0),("testData3",0),("testData4",0)]
18:49:20 <lambdabot>   ["testData1","testData2","testData3","testData4"]
18:49:24 <profmakx> my brain
18:52:31 <Baughn> > map fst
18:52:31 <lambdabot>   []->
18:52:32 <lambdabot>    []
18:52:32 <lambdabot>  [((),())]->
18:52:32 <lambdabot>    [()]
18:52:32 <lambdabot>  [((),()),((),())]->
18:52:33 <lambdabot>    [(),()]
18:52:36 <lambdabot>  [((),()),(...
18:53:10 <Baughn> profmakx: So, there you go.
18:53:25 <Baughn> > fst . [(a,b),(c,d)]
18:53:26 <lambdabot>   [a,c]
18:53:37 <quicksilver> ooh, caleskell is back?
18:53:44 <Wulf_> Hello
18:53:46 <Baughn> Did it ever go away?
18:53:54 <Baughn> Wulf_: Welcome!
18:54:24 <Wulf_> I tried to run http://www.haskell.org/haskellwiki/Haskell_in_5_steps, 4.1 Write your first parallel Haskell program. ghc complains about not finding Control.Parallel. I'm using debian. What package is missing?
18:54:28 <Peaker> quicksilver: where have you been the past 6 months? :)
18:55:05 <Baughn> Wulf_: Debian does so love breaing up ghc. I can't tell you the name (unless you tell me the alternatives), but it should be libghc6-parallel-dev or something
18:55:38 <emile_m> Baughn: What is it?
18:55:43 <Wulf_> Baughn: thanks, works
18:55:57 <Baughn> emile_m: What is what?
18:56:03 <emile_m> > map fst
18:56:05 <lambdabot>   []->
18:56:05 <lambdabot>    []
18:56:05 <lambdabot>  [((),())]->
18:56:05 <lambdabot>    [()]
18:56:05 <lambdabot>  [((),()),((),())]->
18:56:07 <lambdabot>    [(),()]
18:56:09 <lambdabot>  [((),()),(...
18:56:14 <Peaker> I wouldn't use any of Debian's Haskell related packages -- just install binaries manually for that
18:56:27 <Baughn> emile_m: Oh. Well, \bot has a bunch of really weird instances for show.
18:56:33 <Baughn> > (+1)
18:56:34 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
18:56:45 <Baughn> I think it uses quickcheck for that
18:56:49 <Baughn> (ab)uses
18:56:50 <quicksilver> smallcheck
18:56:56 <quicksilver> I disagreew with Peaker
18:56:59 <quicksilver> debian's haskell packages are great
18:57:02 <Wulf_> how can I make a comment in haskell? :)
18:57:04 <quicksilver> and very fast to install.
18:57:08 <Baughn> > 42 -- comment
18:57:09 <lambdabot>   42
18:57:17 <Wulf_> thanks
18:57:30 <Peaker> quicksilver: do they have cabal-install in Debian?
18:57:36 <Peaker> (or alternatively, packages for all of hackage? :)
18:58:35 <emile_m> In Debian, when installing haskell-platform package, some documentaton is missing.
18:58:53 <profmakx> i like those show instances
19:02:17 <Peaker> we need a DebugShow (like Python's __repr__) that has instances for everything...
19:05:05 <Baughn> Peaker: You could adapt vacuum for that, with overlapping instances
19:05:24 <Baughn> Come to think of it, does vacuum work on 6.12?
19:06:33 * Baughn recompiles mplayer a lot. If only it had been written in haskell..
19:07:20 <Baughn> ...actually, with hardware acceleration for everything under the sun, that should be an option about now. It's mostly not CPU-bound, and the bits that /are/ (ass) are because of bad algorithms
19:07:44 <Baughn> (Heh. Needs an ASS compiler.)
19:07:56 <GNU\colossus> NO SWEARING!
19:07:57 <GNU\colossus> ;)
19:08:11 <Baughn> Optimizing compiler.. for a subtitle format. Anyone else suspect the format is a bit broken?
19:08:23 <GNU\colossus> nah, sounds perfectly fine
19:08:42 <GNU\colossus> I imagine subtitles are one of the most complex subjects, ever
19:09:07 <Baughn> When you want the subtitles to include fluttering golden butterflies, then yes, they are
19:09:12 <p_l> Baughn: The very reason I switched to linux was because of MPlayer's crazy optimizations. For you lucky bastard with your vdpau it might not be cpu-bound... but not everyone is a lucky bastard
19:10:04 <Baughn> p_l: That's fine. Keep the decoding part in libavcodec, but do the higher-level operations - chapters, demuxing, etc. - in haskell
19:10:33 <Baughn> p_l: Also, half of mplayer's "crazy optimizations" are actually *X's* crazy optimizations
19:10:53 <Baughn> X is faster than any other windowing system I know, by a factor of two-three. Crazy, I know.
19:11:03 <p_l> Baughn: I'm not sure about now, but years ago, the most tightly wound code in MPlayer was scheduler
19:12:00 <p_l> ffmpeg got their own crazies for optimizations (I heard something about exhausting possible optimizations on standard before AVX)
19:12:06 <koala_man> Baughn: for which operations?
19:12:18 <Baughn> koala_man: Streaming video
19:12:48 <Baughn> koala_man: XVideo has overhead, but it's far less than Quartz or Directshow
19:14:27 <koala_man> Baughn: neat. where does the overhead go?
19:14:48 <Baughn> koala_man: In the two others? Colorspace conversions in software, and memory copies
19:53:02 <fasta> Is there a way to convert a ByteString to an array of Int32
19:55:30 <dolio> ByteStrings have ForeingPtrs inside (if I remember correctly) so you could get that out of it.
19:55:59 <dolio> Arrays are (Mutable)ByteArr# internally, though, so that's not quite the same.
19:56:49 <dolio> There might be an array library built on ForeignPtr, though (StorableVector, maybe).
19:57:33 <Baughn> fasta: Grab the foreign ptr, cast it to a ForeignPtr Word32, take care of the offset, done
19:57:47 <Baughn> fasta: Or use hackage://storable
19:57:55 <Baughn> Er. storablevector
19:58:07 <Baughn> Casting is, of course, somewhat questionable. ;)
20:04:53 <fbru02> the idea behind generic programming in haskell is sort of producing type-indexed families as Eq, Show ?
20:05:22 <quicksilver> the idea is, for example, to be able to write Eq instances generically
20:05:29 <quicksilver> by induction over the structure of types
20:05:35 <quicksilver> instead of writing it for every type
20:05:52 <fasta> I don't see direct conversions between ByteStrings and storablevector.
20:06:08 <quicksilver> (of course this particular feature is built into haskell as 'deriving Eq' but that feature is not extendable)
20:06:18 <dolio> I don't think the library has them. You'd have to use the Internal modules to access the representation.
20:06:28 <fbru02> so actually it is more useful for people consuming your library than for the library writer??
20:06:33 <dolio> And probably castForeignPtr or something like that.
20:08:24 <Baughn> fasta: Really, you should be complaining to whoever is giving you a bytestring in the first place. What package is that?
20:08:51 <fasta> Baughn, zlib expects one.
20:09:20 <fasta> Baughn, are you saying that storable vectors are to be preferred over bytestrings?
20:09:34 <Baughn> fasta: For anything not actually an array of bytes, yes
20:09:43 <Baughn> fasta: Okay. It makes sense for zlib.
20:10:15 <Baughn> fasta: However, I think the "proper" solution would be a custom Data.Binary instance, to convert between the int array and bytestring
20:10:45 <SamB_XP> yeah, you don't want to use platform-specific byte ordering!
20:10:57 <SamB_XP> or sizing!
20:11:55 <fasta> I think Binary already does it out of the box.
20:12:00 <fasta> Thanks
20:13:02 <SamB_XP> out of whose box ?
20:13:29 <Baughn> Mine
20:13:54 <Baughn> Well, also out of yours.. and fasta's.. it's not in very many boxes
20:14:27 <fasta> It is unboxed, though. Sorry for the bad pun.
20:15:56 <SamB_XP> I was actually thinking Binary's box, or StorableVector's box ?
20:17:42 <fasta> SamB_XP, Binary does that.\
20:22:46 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13866#a13866
20:23:43 <mreh> i can't figure out what's going wrong here, i thought I could fix it with a type declaration
20:24:11 <mreh> (the error refers to the second line)
20:25:07 <byorgey> mreh: well, what type is ms?
20:25:37 <mreh> [m (Maybe a)]
20:25:55 <byorgey> mreh: right, so it can't go on the rhs of  <-
20:26:06 <byorgey> because your do-block is in the m monad, not the list monad
20:27:38 <mreh> i think I was high when I wrote this
20:27:41 <byorgey> the weird error is because it tries to match  [m (Maybe a)] with  m (Maybe a)
20:27:46 <byorgey> heh, perhaps =)
20:28:27 <mreh> I need to bind m to something, but I don't need to bind ms to anything, I can just put that through sequenceMaybes
20:30:35 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13866#a13867 -- working code if anyone is interested
20:31:25 <byorgey> yes, that looks better =)
20:32:16 <byorgey> mreh: hmm, is it different than  fmap sequence . sequence ?
20:32:30 <byorgey> oh, maybe it is lazier...
20:35:15 <Saizan_> yours would return an "m (Maybe [a])"
20:35:41 <byorgey> yeah, sorry, I mean   liftM (fromMaybe [] . sequence) . sequence
20:37:58 <byorgey> oh, ignore me, they are totally different =)
20:38:13 <byorgey> you want the list results *until* the first Nothing
20:38:27 <byorgey> my version throws away the entire list if it finds any Nothings
20:39:13 <Saizan_> what's weird about the code in the paste is that it recurses on ms even if it doesn't use the results
20:39:38 <Saizan_> i'd push the recusion inside the Just branch
20:39:47 <Saizan_> but it also depends on what mreh actually needs
20:41:02 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13866#a13868 <- like this
20:41:13 <byorgey> yeah, I was playing around with that too
20:41:21 <byorgey> but strangly I can't get it to work like I think it should
20:44:31 <Saizan_> well it'd still "perform" all the side effects related to the first run of Just results before letting you look at the list, modulo laziness in the implementation of the monad
20:45:15 <byorgey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13866#a13869
20:45:38 <byorgey> I must be missing something big, why does that code run ALL the print statements each time?
20:45:49 <byorgey> I would expect sequenceMaybes2 to not do the final print
20:47:46 <Saizan_> mh, me too
20:51:23 <byorgey> ah, dammit, I am an idiot
20:51:35 <byorgey> I forgot to change the recursive call in sequenceMaybes2  =P
20:51:51 <byorgey> oh good, now it works as I would expect =)
20:52:10 <Saizan_> direct recursion is evil!
20:52:55 <Saizan_> we should really have a takeWhileM
20:53:01 <byorgey> heh, true
20:53:16 <byorgey> mreh: have you been following this?
20:53:23 <copumpkin> yawn
20:54:13 <byorgey> mreh: your version of sequenceMaybes performs all the side-effects no matter what; see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13866#a13870 for a version that really does stop as soon as it sees Nothing
20:54:18 <byorgey> depending on what you want
21:26:16 <JohnDoe365> Is anybody working with leksah?
21:26:54 <JohnDoe365> Is it normal, that breakpoints are lost after I close and reopen leksah and also not stored in the session?
21:27:37 <mreh> JohnDoe365: For what it is worth, none of the haskell IDEs are up to scratch
21:29:45 <JohnDoe365> mreh: what do you mean by that?
21:30:15 <mreh> they have major components missing
21:30:41 <JohnDoe365> ok
21:30:47 <byorgey> that's no reason not to use them.
21:31:07 <byorgey> JohnDoe365: I'm pretty sure the author of Leksah is still working on it and would love to get feedback/bug reports/feature requests.
21:31:38 <JohnDoe365> The visual debugger in leksha is working, it's just that brekapoints are not saved between sessions
21:31:40 <JohnDoe365> will do that
21:33:04 <byorgey> JohnDoe365: even better, submit a patch ;-)
21:34:08 <Peaker> how does leksah compare to yi?
21:35:17 <JohnDoe365> Peaker: yi is according to the author integrated into leksha
21:35:36 <byorgey> Peaker: they are very different.  yi is a general-purpose editor, while Leksah is a haskell development environment
21:35:48 <JohnDoe365> and it's definitely more 'feature' complete than eclipsefp
21:36:24 <JohnDoe365> The editor of eclipsefp is at least very good, and when you expect git / svn integration you remain in one environemnt
21:36:42 <Peaker> byorgey: oh, cool
21:37:35 * hackagebot upload: ls-usb 0.1.0.2 - List USB devices (RoelVanDijk)
21:41:47 <Jonno_FTW> so
21:42:23 <mreh> soooooooo, who wants to go get a beer
21:42:31 <Jonno_FTW> sounds good
21:42:38 <Axman6> i'm in
21:42:51 <Jonno_FTW> import Drinks.Beer
21:43:32 <quicksilver> the thing about eclipse is not so much that the editor is bad, it's just that it's not as good
21:43:40 <quicksilver> and I don't want to learn another editor just to use an IDE
21:43:46 <quicksilver> in fact that's the problem with all IDEs...
21:43:59 * ivanm mumbles something about alcoholics
21:45:53 <Jonno_FTW> is there a fast way to calculate a factorial
21:45:55 <Jonno_FTW> ?
21:46:11 <Jonno_FTW> i found this, http://www.luschny.de/math/factorial/FastFactorialFunctions.htm
21:46:27 <Jonno_FTW> but they are all written in java and there are no explanations of what they do
21:46:44 <quicksilver> there is no simple, fast, precise way
21:47:00 <quicksilver> that's not java, that's c#
21:47:06 <Jonno_FTW> :O
21:47:14 <Jonno_FTW> aren't they the same thing?
21:47:41 <Jonno_FTW> besides, the question only requires the last 5 digits without the zeroes
21:48:12 <Jonno_FTW> i got this f n = reverse$ take 5 $ show (read $reverse $  show $ fac n :: Integer)
21:48:23 <tombee> Can I specify a 'type' which is restricted to Int 1 or Int 0
21:48:40 <Cale> tombee: Bool?
21:48:54 <quicksilver> Jonno_FTW: the question is expecting you to think more cleverly.
21:49:01 <Cale> tombee: There's no way to express a constraint on what values an Int can be
21:49:03 <quicksilver> Jonno_FTW: the whole idea is not to actualy calculate the factorial.
21:49:07 <mux> tombee: you can in the sense that you can avoid exporting the type constructors and instead export function that use the type constructors (called smart constructors), that would reject any wrong value
21:49:34 <tombee> Ok thanks Cale, mux.
21:49:35 <Jonno_FTW> i can't read C#
21:49:42 <tombee> I will just use Bool instead :)
21:49:43 <mux> now, if it's for restricting Int values it's not very useful
21:49:45 <Cale> Yeah, you can make your own type, or use another one which exists, like Bool, to represent the data
21:49:50 <mux> since you cannot enforce that constraint statically
21:50:05 <quicksilver> Jonno_FTW: I'm not talking about C#
21:50:14 <mux> but you can have a smart constructor call error in the case and ensure that no values of your type are created with inappropriate integer
21:50:15 <quicksilver> Jonno_FTW: I'm tlaking about the question to find the last 5 digits without the zeros.
21:50:25 <quicksilver> Jonno_FTW: that question is expecting you to think of a cleverer way.
21:52:43 <ksf> tombee, it gets even better:
21:52:46 <ksf> > fromEnum True
21:52:47 <lambdabot>   1
21:52:50 <ksf> > fromEnum False
21:52:51 <lambdabot>   0
21:53:29 <Jonno_FTW_> how does that even work?
21:53:46 * quicksilver takes the view that fromEnum specifies an abstract injection into Integer, so although it's fine to rely on it being injective, you shouldn't rely on precisely what form it takes.
21:53:48 <Jonno_FTW_> i get
21:53:58 <ksf> let if' p c a = [a,c] !! fromEnum p in if' True then "foo" else "bar"
21:54:02 <ksf> > let if' p c a = [a,c] !! fromEnum p in if' True then "foo" else "bar"
21:54:03 <lambdabot>   <no location info>: parse error on input `then'
21:54:11 <ksf> ouch
21:54:17 <ksf> > let if' p c a = [a,c] !! fromEnum p in if' True "foo" "bar"
21:54:18 <lambdabot>   "foo"
21:54:52 <ksf> quicksilver, to Int
21:54:59 <ksf> it _should_ be Integer, yes.
21:55:16 <quicksilver> ksf: good point.
21:55:43 <ksf> using 64-bit bitmasks with Enum is russian roulette.
21:56:28 <ksf> > toEnum 2 :: Bool
21:56:29 <lambdabot>   * Exception: Prelude.Enum.Bool.toEnum: bad argument
21:56:44 <ivanm> @slap ksf
21:56:45 * lambdabot loves ksf, so no slapping
21:56:48 <ksf> there's a function to do that properly somewhere in Foreign*, though.
21:56:52 <Stinger__> ok, so when I do join (+), what is going on there
21:57:11 <ksf> :t join (+)
21:57:12 <lambdabot> forall a. (Num a) => a -> a
21:57:38 <Stinger> supposedly it's the reader monad?
21:57:41 <ksf> have a look at the definition of Monad ((->)a)
21:57:47 <ksf> basically, yes.
21:57:53 <Saizan_> join f r = f r r, there
21:58:13 <Stinger> but it doesn't involve the Reader datatype
21:58:22 <Asztal> @src Reader
21:58:22 <ksf> no, but they're isomorphic.
21:58:23 <lambdabot> Source not found. Just try something else.
21:58:26 <Asztal> bleh
21:58:31 <quicksilver> the ((->) a) monad is a direct Reader monad without the extra constructor
21:58:40 <quicksilver> they are the same thing, but one has a newtype in the way
21:58:41 <Stinger> ok so where's that defined?
21:58:46 <quicksilver> Control.Monad.Instances
22:05:26 <Stinger> hmm alright, thanks
22:08:39 <pastah_rhymez> @seen HaskellLove
22:08:39 <lambdabot> Unknown command, try @list
22:08:48 <pastah_rhymez> ehm... ok...
22:08:52 * pastah_rhymez feels insecure
22:10:01 <Jonno_FTW_> hmm
22:10:07 <Jonno_FTW_> so noone could help me?
22:13:11 <quicksilver> Jonno_FTW_: with what?
22:13:23 <quicksilver> pastah_rhymez: try preflex
22:13:23 <Jonno_FTW_> with a fast factorial implementation
22:13:37 <quicksilver> No. They're pretty obscure. Wikipedia gives the basic idea.
22:13:39 <Jonno_FTW_> i found one in c# but it had no explanation
22:13:45 <pastah_rhymez> @preflex HaskellLove
22:13:45 <lambdabot> Unknown command, try @list
22:13:49 <pastah_rhymez> whut?
22:13:50 <quicksilver> I repeat that you don't need that to solve the question you're trying to solve.
22:13:53 <quicksilver> preflex: seen HaskellLove
22:13:53 <preflex>  HaskellLove was last seen on #haskell 19 hours, 52 minutes and 39 seconds ago, saying: anyone in the mood to explain me monads in pm? I got in the book to the monads chapter and stopped since it is confusing
22:14:00 <Jonno_FTW_> :o
22:14:07 <Jonno_FTW_> then how?
22:14:15 <quicksilver> Jonno_FTW_: the correct way to solve that question is not to find a quick way to calculate factorial, but to find a way to get the answer without calculating factorial entirely.
22:14:20 <Jonno_FTW_> do i only need the last few multiplications?
22:14:34 <quicksilver> it's a maths question, not a computing question ;)
22:15:06 <Jonno_FTW_> >(10^12 -1) * (10^12 -2)
22:23:56 <joas> clear
22:25:00 * Jonno_FTW_ crystal clear
22:27:49 <fasta> Why is there no zipWith for arrays?
22:28:30 <aavogt> fasta: you can toList first...
22:28:43 <aavogt> but since indexing is constant time
22:29:06 <fasta> aavogt, yes, but that way I am depending on some magic compiler optimizations.
22:29:06 <opqdonut> fasta: dph has something like that iirc?
22:29:25 <fasta> aavogt, I just want to be to statically see it is not going to such in terms of constant factors.
22:29:31 <fasta> suck*
22:30:27 <fasta> Now, I will have a ByteString which gets converted to an UArray, which gets converted to a list, which is zipped and then will in the end will create a ByteString again, which is to be written to a file.
22:30:44 <fasta> All kinds of conversions that are not needed.
22:30:59 <fasta> If we had a decent sequence protocol...
22:31:26 <fasta> Some say this is the "list". In my experience lists do remain sometimes.
22:31:58 <fasta> It would be much better if the concept of a list just never entered the picture when you don't need it.
22:32:33 <aavogt> a list is a loop
22:33:56 <opqdonut> or an iterator
22:34:02 <tombee> Can anyone give me some help in how I would 'define' a "Neuron" type?
22:34:10 <aavogt> fasta: do you actually need random access?
22:34:34 <fasta> aavogt, not in this case.
22:34:37 <tombee> I want it to contain the following types: Inputs Weights Threshold (those are defined already)
22:35:31 <aavogt> then perhaps you can do your computation on ByteStrings?
22:35:45 <fasta> aavogt, the idea is that I want to use the hardware xor operation.
22:36:09 <fasta> aavogt, which works on 32 bits at once, instead of 4 times an operation on 8 useful bits.
22:37:00 <aavogt> is the xor actually the bottleneck?
22:37:22 <fasta> aavogt, I don't want to write terribly slow code the first time.
22:37:38 <aavogt> maybe it won't be terribly slow?
22:37:56 <saml> slow code is better
22:38:23 <Stinger> war is peace
22:38:26 <aavogt> can UArrays be constructed lazily?
22:38:39 <fasta> aavogt, I also don't care about that.
22:38:50 <fasta> aavogt, since I need the whole result anyway.
22:39:04 <aavogt> you should anyways
22:39:26 <aavogt> because if the array or list can be constructed and consumed lazily, you program will run in constant space
22:39:35 <aavogt> rather than in proportion to your data set size
22:40:04 <aavogt> that will commonly make more of an improvement in running time than what you worry about your 4 ops into 1 op
22:44:48 <fasta> aavogt, laziness also introduces an indirection; what you say is not universally true. There are no universal truths ;)
22:46:24 <ray> lazy omnomnom
22:47:06 <Jonno_FTW_>  wouldn't the lazy way be to just eat what you need until you aren't hungry
22:47:15 <ziman> that's what uvector is for, isn't it?
22:47:32 <aavogt> it would be eating right when you need to use the energy
22:47:49 <aavogt> err, that would cause some lag when exercising
22:48:15 <ray> it would be eating right when you need to crap out what you already pretended to eat
22:48:34 <ray> i.e. do some IO
22:48:47 <Jonno_FTW_> eating recursively?
22:49:14 <Baughn> @hoogle setNonBlockingFD
22:49:15 <lambdabot> No results found
22:49:39 <zygoloid> laziness is eating (and getting some lag) when you need the energy, but then retaining the energy for all future exercises :)
22:50:28 <mreh> rubbish metaphors
22:50:42 <ray> @hoggle nonblocking
22:50:42 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
22:50:43 <lambdabot> Data.ByteString hGetNonBlocking :: Handle -> Int -> IO ByteString
22:50:43 <lambdabot> Data.ByteString.Char8 hGetNonBlocking :: Handle -> Int -> IO ByteString
22:50:51 <ray> metaphors always fail
22:50:57 <ray> the key is to make sure they fail amusingly
22:52:03 <Jonno_FTW_> it's like someon climbing a mountain, and they fall down the other side
22:54:06 <ray> if they fall nonhilariously what was even the point
22:54:23 <Jonno_FTW_> to try to explain something
22:54:54 <Jonno_FTW_> like a fool who thinks that by cheating they have learned something
22:55:06 <aavogt> you can learn how to cheat
22:55:22 <Jonno_FTW_> but that wasn't the original purpose
22:55:56 <aavogt> if that's easier and appears to give the same results
22:56:35 * hackagebot upload: usb-safe 0.2 - Wrapper around the usb package adding extra type-safety (BasVanDijk)
22:57:42 <Jonno_FTW_> this is the real world
22:57:53 <Jonno_FTW_> cheating and not learning will get someone killed
22:58:07 <aavogt> depends what you're doing
22:59:05 <copumpkin> http://snapplr.com/n0k2 :(
22:59:12 <Jonno_FTW_> you're engineering a bridge on your own
22:59:34 <Jonno_FTW_> you cheated and got your degree in mechanical engineering
22:59:52 <Jonno_FTW_> sed bridge fails when a few days into actual use
22:59:59 <Jonno_FTW_> thousands fall to death
23:00:15 <Jonno_FTW_> in crubmling bridge, dodgy engineer implicated
23:00:17 <Jonno_FTW_> etc. etc.
23:00:28 <ray> who is this foolish "ben pierce"
23:00:50 <aavogt> and in any case, I've taken a more flexible position than you (I can say the same thing as you for some cases, but not in say making art), so your specific examples don't really hurt my argument
23:01:23 <aavogt> off to #haskell-blah?
23:01:34 <Jonno_FTW_> nah
23:02:56 <Jonno_FTW_> a cheating artist produces bad art which no one buys, they can't afford food and starve in their inner city appartment
23:03:16 <ray> uh, no, they get grants and professorships
23:03:22 <medfly> arts?
23:03:39 <medfly> artists learn for a degree when they want to make a career out of it?
23:03:40 <medfly> strange
23:04:16 <aavogt> and what qualifies as cheating in some situations is creativity in other situations ;)
23:04:28 <Jonno_FTW_> i suppose
23:04:39 <Jonno_FTW_> some might call it being lazy
23:04:53 <aavogt> @faq can Haskell cheat?
23:04:54 <lambdabot> The answer is: Yes! Haskell can do that.
23:05:17 <aavogt> this is especially a problem when benchmarking
23:05:37 <dcsobral> Is there an easy explanation for why Haskell favors foldr?
23:06:09 <c_wraith> dcsobral: if the resulting data type can be consumed lazily, foldr can be lazy, but foldl can't
23:06:10 <aavogt> supposedly it is also laziness
23:06:14 <Jonno_FTW_> why is there both foldl and foldr ? don't they do the same thing?
23:06:40 <Jonno_FTW_> oic
23:07:42 <dcsobral> Jonno_FTW_: they only do the same thing if the operation is commutative -- and that says nothing of performance.
23:07:54 <Jonno_FTW_> ko
23:08:05 <Jafet> And then there is foldl'
23:08:17 <dcsobral> c_wraith: Ok, I can accept that answer at face value. But do you have an example to illustrate it?
23:08:22 <Saizan_> you almost always want foldl' instead of foldl
23:08:29 <c_wraith> I'm still not sure why foldl exists.  It seems like in every case where it's appropriate, foldl' is better.
23:09:00 <c_wraith> > foldr f [1..7]
23:09:01 <lambdabot>   No instance for (SimpleReflect.FromExpr [t])
23:09:01 <lambdabot>    arising from a use of `Simp...
23:09:17 <c_wraith> > foldr f [a, b, c, d, e]
23:09:18 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
23:09:18 <lambdabot>    arising fr...
23:09:29 <c_wraith> ok, I know I've seen that work in lambdabot.
23:09:32 <aavogt> Saizan_: so which case is foldl better than foldl'
23:09:33 <Saizan_> > foldr f z [1..3]
23:09:34 <lambdabot>   f 1 (f 2 (f 3 z))
23:09:38 <c_wraith> oh, hah
23:09:54 <c_wraith> it would work if I knew the type signature of the folds
23:10:02 <Saizan_> aavogt: for example when what you're folding is a constructor, so seq is only a waste of time
23:10:13 <Saizan_> ?src reverse
23:10:14 <lambdabot> reverse = foldl (flip (:)) []
23:10:25 <aavogt> oh, seq isn't free?
23:10:29 <Philonous1>  foldl is better if f is lazy in the right argument
23:10:53 <Jonno_FTW_> isn't foldl
23:11:12 <Jonno_FTW_> isn't foldl' for when you know for sure all datatypes in a list will be the same?
23:11:25 <Saizan_> seq is not free, it has to check the expression is evaluated
23:11:25 <c_wraith> in haskell?  you always know that
23:11:28 <opqdonut> they're always the same
23:11:42 <c_wraith> > [1, "foo"]
23:11:43 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
23:11:44 <lambdabot>    arising from the literal ...
23:12:00 <Saizan_> Philonous1: for example?
23:12:22 <Jonno_FTW_> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
23:12:28 <Philonous1> Sorry, I meant in the left argument
23:12:42 <Philonous1> > foldl1 (flip const) [1..10]
23:12:44 <lambdabot>   10
23:13:05 <Saizan_> well, that's a case where you should use foldr
23:13:23 <Saizan_> since foldl will still traverse the whole list, for no reason
23:13:26 <jmcarthur> "If more than one rule matches a call, GHC will choose one arbitrarily to apply." -- Does anybody know if "arbitrarily" means "randomly," "unspecified," or "somewhat intelligently"?
23:13:34 <jmcarthur> ^^ rewrite rules
23:13:36 <Philonous1> > foldr1 (flip const) [1..10]
23:13:37 <lambdabot>   10
23:13:47 <Philonous1> Has to traverse the whole list just as well
23:13:54 <Saizan_> heh, right
23:14:51 <Philonous1> maybe flip const is a bad example. foldl is good for functions that are lazy^W nonstrict in the right argument and not associative
23:17:13 <copumpkin> Veinor: teach a class on haskell? :o
23:17:25 <Saizan_> mh, strict in the list as a whole but not in the accumulator
23:18:07 <mux> I think there's nothing more satisfactory than justifying development delays by showing your boss the problem he wants you to solve is NP-complete
23:18:32 <opqdonut> does he really want an exact solution?
23:18:47 <mux> unfortunately no; this wasn't really legitimate :D
23:18:50 <opqdonut> and do the hard instances occur often enough?
23:18:52 <mux> but still fun
23:19:01 <mux> he's all scared now
23:19:02 <opqdonut> indeed. that justification hardly ever is.
23:19:18 <mux> this is an instance o the multiple constrained knapsack problem
23:19:20 <copumpkin> jmcarthur: I'd assume it means in an unspecified manner, which could be any of those but we don't want to commit to any of them so don't rely on it
23:19:29 <mux> but cases are sufficiently "easy" that a naive algorithm should do just fine
23:19:50 <opqdonut> greedy heuristic + shallow search goes pretty far too
23:19:52 <Philonous1> > let revdiv a b = if b == 0 then 0 else b / a in foldl1 revdiv (undefined:[10,9..0])
23:19:54 <lambdabot>   0.0
23:20:00 <Philonous1> > let revdiv a b = if b == 0 then 0 else b / a in foldl1' revdiv (undefined:[10,9..0])
23:20:01 <lambdabot>   * Exception: Prelude.undefined
23:20:02 <opqdonut> or randomised heuristic and a couple of runs
23:20:14 <mux> monte-carlo to the rescue
23:20:21 <opqdonut> indeed
23:20:30 <opqdonut> mcmc
23:21:20 <Veinor> indeed, just basic stuff but still :D
23:21:51 <zygoloid> mux: i work in EDA. NP-complete problems are the easy ones. ;-)
23:22:04 <opqdonut> :D
23:22:59 <mux> zygoloid: electronic design automation?
23:23:21 <mux> I guess it's not the eating disorders association.
23:23:36 <opqdonut> i thought e* data analysis
23:24:08 <mux> exploratory data analysis?
23:24:26 <opqdonut> something like that
23:24:32 <jmcarthur> copumpkin: i'm not sure if that means anything for rewrite rules like associativity or commutativity. rewriting those might open the doors to further rewrite rules sometimes, but it would be silly if they just matched constantly and the other rules never got to fire
23:25:19 <jmcarthur> would be nice if ghc somehow searched for good combinations of rewrite rule applications
23:25:29 <copumpkin> jmcarthur: I think some of them might match constantly. I remember someone saying that GHC makes no effort to even ensure termination of rewrite rules
23:25:39 <copumpkin> that would be awesome
23:25:48 <copumpkin> it seems like a fairly nice self-contained CS problem
23:26:14 <jmcarthur> well, in the absence of benchmarks it would require a heuristic of some sort
23:27:13 <jmcarthur> and nothing as simple as "number of terms in expression" since you want a good balance of rewrite rules and inlining
23:27:52 <copumpkin> yeah
23:27:53 <jmcarthur> maybe rewrite rules could take priorities. that would be simple
23:28:03 <jmcarthur> not as powerful
23:28:05 <flux> jmcarthur, that would be the ultimate nonpredictable rewriter then, no?-)
23:28:07 <jmcarthur> but nicer than what we have
23:28:19 <jmcarthur> flux: indeed
23:28:56 <jmcarthur> flux: it would be that "sufficiently powerful compiler" that everybody wants until they have one and discover that they can't reason about it
23:29:38 <edwardk> jmcarthur: thats ghc in a nutshell, yes ;)
23:29:44 <jmcarthur> although i suppose as long as you can output the rewrite rules that are applied you can still apply some reasoning to it
23:29:49 <jmcarthur> edwardk: heh
23:30:39 <edwardk> actually the most promising approach to rewrite rules that i've seen was the one that popped up on lambda-the-ultimate a while back about forming equivalence classes of programs with them and then choosing from the class of programs rather than applying them as transformations iteratively
23:31:02 <jmcarthur> edwardk: that basically sounds like what i was imagining
23:31:41 <edwardk> looking for the paper. i've been hopeful about employing the techniques from it for kata
23:33:25 <jmcarthur> i would love to have something like that available for alt-stdlib
23:33:48 <edwardk> http://lambda-the-ultimate.org/node/3220
23:34:01 <jmcarthur> if i can just write out a ton of properties as rewrite rules without worry about whether it's always a great idea i think a lot of nice optimizations would fall out that we don't already get
23:34:06 <zygoloid> mux: yeah, electronic design automation. walking the fine line between np-hard and non-computable ;-)
23:34:40 <edwardk> what i like about it is things like strength reduction, etc just drop out
23:34:42 <jmcarthur> edwardk: oh this looks different from what i was thinking, actually. nevermind
23:34:49 <edwardk> without being explicitly written
23:35:39 <jmcarthur> yeah
23:35:52 <mux> zygoloid: sounds... interesting :)
23:35:53 <jmcarthur> this looks like a level beyond what i was looking for
23:36:21 <edwardk> implementation: http://github.com/batterseapower/pegs
23:36:42 <ray> have you renamed that to cool-stdlib yet? :(
23:37:04 <jmcarthur> ray: cool-stdlib?
23:37:04 <edwardk> like i said, this is the most promising approach i've seen. i like the fact that it lets you 'rise above' the rewrite ordering problem and view it from a perspective that has more information available
23:37:36 <opqdonut> hmm, sounds nice
23:37:40 <ray> you'll never get anywhere being modest and calling yourself alternate
23:37:55 <edwardk> 'new-stdlib' ;)
23:37:57 <edwardk> 'stdlib 2'
23:38:16 <quicksilver> 'non-broken-stdlib'
23:38:18 <opqdonut> super-stdlib
23:38:26 <edwardk> stdlib++
23:38:28 <jmcarthur> ray: it's just a name for now. i think a rename will be due, in the future
23:38:31 <Saizan_> turbo-stdlib
23:38:39 <mreh> @pl (\a -> (sgn y) * (k x a) + w a)
23:38:40 <lambdabot> ap ((+) . (sgn y *) . k x) w
23:38:46 <jmcarthur> but not yet. i don't think it matters yet
23:38:49 <edwardk> turbo-haskell
23:39:00 <quicksilver> lightspeed haskell!
23:39:23 <ray> turbo hascal
23:39:48 <edwardk> you could probably buy what remains of Borland pretty cheap if you wanted the name ;)
23:39:55 <jmcarthur> haha
23:40:04 * jmcarthur heads to work
23:40:49 <copumpkin> jmcarthur: work is for wimps!
23:40:50 <copumpkin> don't do it!
23:40:59 <Baughn> "getRndGen :: IO Int -> RND" <-- Does the sin of trying to generate random numbers purely outweigh the sin of using unsafePerformIO instead?
23:41:52 <edwardk> copumpkin: spoken like a true academic. you will go far
23:41:56 <copumpkin> lol
23:41:59 <copumpkin> ahe
23:41:59 <copumpkin> m
23:42:06 <copumpkin> I meant, carry on!
23:43:19 <kyagrd> We're having a workshop on functional languages+etc and quite a few audiences have interest on web and server programming so I'm trying to introduce happstack.
23:43:34 <edwardk> kyagrd: where at?
23:43:46 <kyagrd> edwardk: Seoul, Korea
23:44:12 <kyagrd> It's kind of an unofficial affiliated event of APLAS
23:44:34 <kyagrd> The problem is there don't seem to be a tutorial ... Is HAppS dead project? so introducing happstack is the right thing? Am I right?
23:45:32 <kyagrd> There are documentations for HAppS though
23:46:14 <mreh> are there any workshops coming to london?
23:46:51 <mreh> oh :(
23:48:58 <edwardk> happstack seems to have picked up where happs left off
23:50:14 <Saizan_> i thought happs-tutorial was ported to happstack
23:51:43 <kyagrd> Well, http://tutorial.happstack.com/ this is not working :-(
23:53:07 <kyagrd> It used to be there but it is not right now, there are some fragments remaining in the google cache.
23:53:19 <luite> kyagrd: you can run your own if you install happstack-tutorial
23:53:28 <luite> or maybe happs-tutorial
23:54:08 <HaskellLove> if True then 1 else False -------- I am trying to figure out why this produces error... In the book it says: a conditional expression requires that both possible results have the same type, but why is that so? On second thought, hmmm is my conclussion right? The if branch is just a function with one return type so that is why all else branches have to match the type of the first then...
23:54:08 <HaskellLove> ...subexpression of "if"
23:54:39 <quicksilver> it is so because haskell expressions are expected ot have a single type
23:54:44 <Veinor> HaskellLove: yo ucould think of 'if' as a function, yeah
23:54:50 <quicksilver> consider (if True then 2 else "foo") + 1
23:54:51 <kyagrd> luite: happs and happstack are not compatible though ...
23:54:55 <HaskellLove> exactly
23:55:13 <EnglishGent> @hoogle if
23:55:14 <lambdabot> Text.XHtml.Transitional iframe :: Html -> Html
23:55:14 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
23:55:14 <lambdabot> Test.QuickCheck classify :: Testable a => Bool -> String -> a -> Property
23:55:21 <Veinor> if isn't an actual function though >_>
23:55:27 <copumpkin> quicksilver: that isn't necessarily an error though
23:55:28 <Veinor> @hoogle Bool -> a -> a -> a
23:55:29 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
23:55:29 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
23:55:29 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
23:55:41 <Veinor> @hoogle  a -> a -> Bool -> a
23:55:41 <gwern> Veinor: nothing stopping us except syntax, no?
23:55:42 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
23:55:42 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
23:55:42 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
23:55:46 <EnglishGent> Veinor - why not?
23:55:58 <Veinor> I mean, you can write an 'if' function
23:56:02 * EnglishGent can see no reason for it not to be a function - other that it has special syntax
23:56:13 <Veinor> but Haskell's builtin 'if' isn't a function because of its special syntax :P
23:56:13 <aavogt> less parentheses
23:56:56 <EnglishGent> beh - thats a little ugly - I can see no reason why 'map if foo' shouldnt work
23:57:15 <kyagrd> luite: Oh, happs-tutorial is actually updated as a tutorial for happstack :) I just read the package description on Hackage
23:57:30 <JohnDoe365> kyagrd: None of the 'cool' features of modern web apps are available as a toolset in haskell
23:57:44 <Veinor> f True x y = x; f False x y = y
23:57:58 <JohnDoe365> no rest,  no comet
23:58:17 <sioraiocht> If I'm defining lists as final-coalgebras
23:58:31 <sioraiocht> where out: List(A) -> 1 + A x List(A)
23:58:47 <sioraiocht> I understand that <head,tail> produces A x List(A)
23:58:50 <Philonous1> @pl \p a b -> if p then a else b
23:58:51 <lambdabot> if'
23:58:58 <Veinor> heh.
23:58:58 <sioraiocht> how do I combine the function that produces nil?
23:59:00 <Saizan_> @hackage happs-tutorial
23:59:01 <lambdabot> http://hackage.haskell.org/package/happs-tutorial
23:59:04 <Veinor> @hoogle if'
23:59:05 <lambdabot> No results found
23:59:19 <kyagrd> JohnDoe365: Well I don't know what it means by 'cool' but I think it woundn't hurt to introduce them, most audience is from industry
23:59:24 <Veinor> must be builtin to the language
