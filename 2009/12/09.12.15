00:09:16 <JohnDoe365> Can somebody tell me what software drives http://book.realworldhaskell.org/?
00:10:02 <JohnDoe365> I like it, and think about using for a book our institution is  about to release, will be not programming related though
00:21:48 <dons> JohnDoe365: its some custom software bos wrote.
00:22:28 * bos finally used criterion to benchmark some I/O code tonight.
00:22:33 * hackagebot upload: criterion 0.4.1.0 - Robust, reliable performance measurement and analysis (BryanOSullivan)
00:22:35 * hackagebot upload: uvector 0.1.1.0 - Fast unboxed arrays with a flexible interface (BryanOSullivan)
00:25:09 <dons> did it work?
00:25:13 <luite_> patch to make uvector compile with 6.12?
00:25:23 * dons crosses fingers
00:25:46 <dons> push the patches, bos :)
00:26:13 <dons> btw, is the randomgen in the statistics library going to break out into its own lib?
00:26:41 <bos> i hadn't any plans to do that, but it could.
00:26:58 <bos> i ripped out the I/O code from uvector entirely. it was useless anyway.
00:27:00 <dons> was trying to find it for a segment on randoms at pdxfunc tonight.
00:27:09 <dons> yeah, just an experiment. no one used it.
00:27:50 <luite_> hehe that was also my way to make it compile
00:28:42 <bos> dons: i could factor the random code out, i guess. needs a new name, though.
00:30:14 <grnag> hello
00:35:45 <grnag> > 2*2
00:35:46 <lambdabot>   4
00:37:39 <vegai> dons: what about array?
00:38:14 <o-_-o> grnag, hello
00:39:55 <grnag> o-_-o, hello
00:41:03 <sergdf> > sum [1..100000]
00:41:05 <lambdabot>   5000050000
00:41:10 <sergdf> > sum [1..100000000000000000000]
00:41:16 <lambdabot>   mueval-core: Time limit exceeded
00:41:17 <lambdabot>  mueval: ExitFailure 1
00:41:28 <sergdf> good stuff
00:43:01 <o-_-o> > print "Amuse yourself with lambdabot"
00:43:05 <lambdabot>   <IO ()>
00:43:25 <o-_-o> > printf "Amuse yourself with lambdabot"
00:43:26 <lambdabot>   Ambiguous type variable `r' in the constraints:
00:43:26 <lambdabot>    `Text.Printf.PrintfType ...
00:44:05 <o-_-o> > printf str in str = "Amuse yourself with lambdabot"
00:44:06 <lambdabot>   <no location info>: parse error on input `in'
00:44:27 <o-_-o> I've never gotten the hang of lambdabot
00:45:12 <o-_-o> > let str =  printf "Amuse yourself with lambdabot" in printf str
00:45:13 <lambdabot>   Ambiguous type variable `r' in the constraints:
00:45:13 <lambdabot>    `GHC.Show.Show r'
00:45:13 <lambdabot>      a...
00:45:15 <Baughn> o-_-o: \bot isn't the problem. Your code isn't a valid haskell expression.
00:45:25 <o-_-o> Baughn, I know :-)
00:45:31 <fasta> I just read that CPUs work in an imperative way, which is why we need an imperative programming language.
00:45:41 <o-_-o> > @let str =  printf "Amuse yourself with lambdabot" in printf str
00:45:44 <lambdabot>   <no location info>: parse error on input `@'
00:45:57 <Baughn> fasta: Fun. By the same reasoning, I could advocate death-matches in school exams.
00:46:06 <Baughn> It'll make evolution work better.
00:46:39 <o-_-o> > let str =  "Amuse yourself with lambdabot" in printf str
00:46:40 <lambdabot>   Ambiguous type variable `r' in the constraints:
00:46:40 <lambdabot>    `Text.Printf.PrintfType ...
00:47:20 <o-_-o> @let str =  "Amuse yourself with lambdabot" in printf str
00:47:20 <lambdabot>   Parse error: KW_In
00:48:19 <quicksilver> o-_-o: there is nothing wrong with your syntax, it's just that printf has a weird type.
00:48:30 <quicksilver> > let str = "hi" in printf str :: String
00:48:32 <lambdabot>   "hi"
00:48:48 <o-_-o> ah
00:49:07 <o-_-o> I got lambda bot installed via cabal, how do I run it ?
00:49:07 <quicksilver> "ambiguous type variable" is not a syntax error.
00:49:27 <o-_-o> ok
00:50:00 <fasta> Baughn, here is the funny guy, btw: http://www.cs.ru.nl/~spitters/completeness/Mueller.pdf
00:50:07 <o-_-o> if I try $HOME/.cabal/bin/lambdabot
00:50:18 <o-_-o> none of my commands wor
00:50:22 <o-_-o> I tried 2+2
00:50:29 <o-_-o> I tried > 2*2
00:50:40 <o-_-o> and it still doesn't work
00:50:58 <quicksilver> no idea. I've never installed lambdabot.
00:51:28 <fasta> A few years ago lambdabot was known to be difficult to install.
00:51:39 <fasta> I am not sure whether anything has changed.
00:53:46 <o-_-o> it installed fine and easy using cabal
00:53:58 <o-_-o> but it doesn't want to run anything, for everything it says terminate
00:54:01 <o-_-o> terminated
01:04:33 <bastl> Good Morning! To anyone familiar with packages regular or multirec: Why the fixpoint notion needed? It seems everything would work without it? Is it the theoretical basis to be sure that the types defined directly and via the pattern functor are isomorphic?
01:04:57 <bastl> *Why _is_ the FP notion needed ...
01:07:24 <dreixel> bastl: you mean, as opposed to a kind-* representation?
01:09:33 <ziman> bastl, sometimes you need the functor, not only the generated datatype; usually in those general *-morphisms
01:10:25 <ziman> and since from the functor you can derive (somthing isomorphic to) the data type, but not the other way, they need to take the functor
01:12:46 <bastl> dreixel: in regular Fix is defined but never used. What do you mean by kind-* representation ?
01:13:08 <bastl> ziman: what general *-morphisms?
01:13:40 <ziman> bastl, consider cata :: Functor (f a -> a) -> Fix f -> a
01:13:47 <ziman> bah
01:13:56 <ziman> consider cata :: Functor f => (f a -> a) -> Fix f -> a
01:14:19 <dreixel> indeed you need a functorial representation to define fold, for instance
01:14:44 <dreixel> the Fix is there for convenience as it might be needed in some applications, but the library doesn't use it
01:15:00 <ziman> here you need to express the relation of the functor to its fixed point
01:17:03 <bastl> why?
01:18:56 <ziman> when collapsing the value of the fixpoint-type you collapse it level-by-level, starting from the innermost functor applications
01:20:07 <Saizan> o-_-o: you've to install mueval too
01:21:30 <ziman> i'll show an example: type ListF a e = Cons a e | Nil -- isomorphic to Maybe (a,e)
01:21:56 <ziman> s/type/data/ -- i had Maybe there
01:21:57 <bastl> k
01:22:20 <ziman> now, type List a = FixF (ListF a)
01:22:55 <bastl> k
01:23:08 <ziman> the List-type is a fixpoint of the List-functor
01:23:22 <ziman> if I want to write a length function working on such lists
01:24:22 <ziman> using the cata, it will be: cata phi where { phi Nil = 0; phi Cons _ lengthOfTheInnerList = 1 + lengthOfTheInnerList }
01:25:33 <ziman> now how this works: cata is defined as cata f = f . fmap (cata f) . outF
01:25:50 <bastl> k
01:26:48 <ziman> where outF is merely the "deconstructor" of the FixF (data FixF f = InF { outF :: f (FixF f) })
01:27:22 * bastl must admit that he never understood the Fix-datatype, i.e. the real effect if In and out.
01:27:56 <ziman> In is just a tag for the typesystem; without it, typing would be undecidable, I believe
01:28:20 <ziman> (and we would get infinite types)
01:28:22 <bastl> so it's not really applied to values?
01:28:40 <bastl> only used to infer types?
01:28:54 <bastl> hmm
01:28:58 <blobl> beginner stuff, can someone tell me how can i make this parseLFile function return a tuple with levelMap and outputMap ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14231#a14231
01:29:01 <bastl> ok, go on.
01:29:02 <ziman> FixF can be defined as a newtype, thus it can be completely compiled out, afaik
01:29:32 <o-_-o> how do I access the third element of a tuple ?
01:29:38 <ziman> it's more convenient to define it as a data, to allow more elegant definitions using outF
01:29:42 <o-_-o> (1,2,3,4)
01:29:47 <o-_-o> or the nth element ?
01:30:36 <ziman> o-_-o, there's no general way (what type would such a function have?) except maybe TH; you need to define the functions by hand
01:30:41 <DigitalKiwi> http://www.dreamincode.net/code/snippet3546.htm I haven't seen much haskell code but this is the first I've seen this use of | like this, is it normal and I'm just a nub or what?
01:30:57 <edwardk> is o-_-o only o-_-o because ಠ_ಠ isn't a valid username?
01:31:29 <o-_-o> ziman, ok
01:31:52 <o-_-o> edwardk, my real name lapsed and someone else claimed it
01:32:07 <bastl> ziman: I think im missing some import basics, what are the real foundations of this stuff ?
01:32:07 <o-_-o> edwardk, now this was the nick I used to troll this network long ago
01:32:15 <o-_-o> edwardk, I am left with this
01:32:16 <edwardk> fair nuff
01:33:05 <o-_-o> edwardk, also these are characters from my mother tongue ಠ_ಠ and I tend to speak them out :-)
01:33:14 <o-_-o> edwardk, so they have a strange effect on me
01:33:17 <blobl> anyone can explain how can i get an IO string converted to string?
01:33:51 <opqdonut> blobl: short answer: you can't
01:34:05 <opqdonut> but you can do something with the string, by using for example fmap
01:34:06 <o-_-o> ಠ -> Tha
01:34:21 <ziman> bastl, what exactly do you mean, newtypes/data or functors/fixpoints/catamorphisms?
01:34:25 <pastah_rhymez> blobl: http://arcanux.org/lambdacats/io-monad.jpg
01:34:26 <o-_-o> so ಠ_ಠ -> TaTa for me
01:34:27 <opqdonut> you can also temporarily get the string out by saying x <- m in do-notation
01:34:31 <edwardk> haha
01:34:37 <o-_-o> :-)
01:34:39 <opqdonut> where m :: IO String, s :: String
01:34:41 <bastl> ziman: the latter.
01:34:49 <blobl> cool.. so what do i do with the contents of a file? is not possible to put them as arguments in another function so i do something with it?
01:35:16 <blobl> pastah_rhymez: hehe thats me :D
01:35:44 <opqdonut> blobl: i recommend reading http://learnyouahaskell.com/input-and-output
01:35:47 <bastl> blobl: you probably want to bind the string result of an IO-action to a temporary constant functon ...
01:35:49 <opqdonut> or some other tutorial
01:35:54 <ziman> bastl, I learned it a bit ad-hoc from various snippets of code and tutorials; maybe edwardk could recommend you some reading ;)
01:36:06 <bastl> s <- readFile "myfile.txt"
01:36:40 <pastah_rhymez> blobl: if you have some code that doesn't work, paste it os
01:36:44 <pastah_rhymez> @hpaste
01:36:44 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
01:36:49 <pastah_rhymez> and we can fix it :)
01:36:54 <pastah_rhymez> with nice comments :)
01:38:19 <pastah_rhymez> blobl: also, there i black voodoo magic in System.IO.Unsafe
01:38:35 <blobl> wait :D
01:39:03 <pastah_rhymez> but don't go there... you won't get your soul back if you do
01:39:17 <pastah_rhymez> or maybe you're japanase, and then it doesn't really matter :)
01:39:46 <edwardk> brb
01:42:08 <blobl> heh. so look my function, please
01:42:09 <blobl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14231#a14231
01:42:41 <pastah_rhymez> what's the output of this function?
01:43:05 <blobl> a tuple with the two maps
01:43:14 <blobl> but cannot make it happen :)
01:43:46 <ziman> bastl, the most relevant papers I've read that I can think of now are "Functional programming with bananas, lenses, envelopes and barbed wire" by Meijer, Fokkinga, Paterson and maybe "A Tutorial on (Co)Algebras and (Co)Induction" by Jacobs, Rutten
01:44:02 <pastah_rhymez> blobl: reload your paste
01:44:35 <pastah_rhymez> that function will be
01:44:37 <bastl> ziman: wow, i studied on the latter years ago. what has coalgrebra to do with this ?
01:44:37 <blobl> ok so that returns an IO tuple right ?
01:44:56 <pastah_rhymez> parseFile :: FilePath -> IO (Map,Map)
01:45:34 <pastah_rhymez> http://www.youtube.com/watch?v=UPw-3e_pzqU <-- how it is in the IO monad
01:45:34 <blobl> ya that.. back where the function was called.. to get the first map i just do a fst ?
01:46:03 <ziman> bastl, that paper helped me to understand what a (co)algebra is and the relation between a functor, its fixed point and (co)algebras "operating" on them
01:46:19 <pastah_rhymez> well, once you call parseFile you have to do that from an IO context
01:46:43 <pastah_rhymez> so if i was you i'd have a line, in my IO function calling this
01:46:59 <pastah_rhymez> (lMap,oMap) <- parseFile fp
01:47:21 <pastah_rhymez> yay for pattern matching (removing the use of fst/snd)
01:47:48 <bastl> blobl: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14231#a14233
01:47:49 <ziman> you can plug the (Co)Algebras into *-morphisms from the "bananas-lenses-barbed-wire" paper and you'll get what's in category-extras :)
01:47:58 <blobl> ya get what you mean. im just real new learning this haskell thing. let me test it
01:48:34 <ziman> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Cata.html
01:49:53 <bastl> ziman. I get along with the theoretic things, but when it gets related to haskell-syntax, i loose contect ... catamotphisms are the unique morphisms from the initial object of some F-Algebra to some other Object, right?
01:50:06 <bastl> contect = context
01:50:44 <bastl> rather the initial F-Algebra to some other F-Algebra.
01:51:40 <blobl> pastah_rhymez: thx man. but can i now do whatever i want with the two parts of the tuple? like print one in the screen or something?
01:54:42 <pastah_rhymez> if it's to the left of the "<-" it's of type 'a'
01:54:51 <pastah_rhymez> if it's to the right it's 'IO a'
01:55:09 <pastah_rhymez> so treat it as you would without the IO surrounding it
01:55:29 <blobl> *Main System.IO Data.List> :t lmaplmap :: [((Int, Int), Char)]
01:55:29 <blobl> *Main System.IO Data.List> :t omap
01:55:29 <blobl> omap :: [String]
01:55:29 <blobl> *Main System.IO Data.List> :t lmaplmap :: [((Int, Int), Char)]
01:55:29 <blobl> *Main System.IO Data.List> :t omap
01:55:32 <blobl> omap :: [String]
01:55:35 <blobl> *Main System.IO Data.List> :t lmaplmap :: [((Int, Int), Char)]
01:55:38 <blobl> *Main System.IO Data.List> :t omap
01:55:41 <blobl> omap :: [String]
01:55:44 <blobl> lmap :: [((Int, Int), Char)]
01:55:46 <pastah_rhymez> blobl: take it easy
01:55:48 <blobl> soory :D
01:55:56 <pastah_rhymez> ==> hpaste
01:56:23 <blobl> sorry for that. smething wrong happened was not meant to do it so many times..
01:56:31 <pastah_rhymez> also, in haskell, using the word 'map' is generally a bad thing, since it will cause name conflicts
01:56:48 <pastah_rhymez> #1 you have map :: (a -> b) -> [a] -> [b]
01:56:49 <lunabot>  luna: parse error on input `|]'
01:57:09 <pastah_rhymez> #2 you have Data.Map for all you BST needs
01:57:10 <lunabot>  luna: parse error on input `|]'
01:57:22 <pastah_rhymez> lunabot: quiet you
01:57:37 <pastah_rhymez> @faq can haskell make lunabot be quiet?
01:57:37 <lambdabot> The answer is: Yes! Haskell can do that.
01:58:57 <blobl> thanks
01:59:06 * hackagebot upload: syb-with-class 0.6.1 - Scrap Your Boilerplate With Class (AndreaVezzosi)
02:00:07 * hackagebot upload: explicit-iomodes 0.1.1 - File handles with explicit IOModes (BasVanDijk)
02:05:18 <ziman> bastl, hm, i'd say catamorphisms are functions from a fixpoint of some functor (and anamorphisms are functions to a fixpoint of some functor)
02:07:22 <Saizan> bastl: it is from the initial algebra to another F-Algebra, since the other algebra is made of A and the (F A -> A) function
02:07:54 <Saizan> or maybe not
02:08:44 <Saizan> it is if morphisms between algebras (A,F A -> A) (B,F B -> B) are functions from A to B that respect some laws
02:10:50 <ziman> could you explain how that forms a catamorphism? (on an example, maybe)
02:12:19 <bastl> Saizan: where is the "Fixpoint" in this algebraical view? Is it the initial algebra?
02:12:22 <vy> In GHCi 6.8.2, ":m +Data.Text" cannot locate the package. Am I missing something?
02:13:30 <bastl> ziman I learned these bits from http://www.cs.uq.edu.au/~paul/other-cache/polytyping.pdf
02:14:51 <ziman> bastl, thanks
02:15:03 <DigitalKiwi> http://codepad.org/nGcPBHFz
02:15:12 <DigitalKiwi> wondering if anyone can make that better?
02:15:29 <DigitalKiwi> it's slower than my lua version which is surprising/disappointing :(
02:16:10 <Saizan> bastl: yes
02:19:03 <o-_-o> http://ocaml.janestreet.com/?q=node/64 <- this article I read a some time before I knew anything about haskell and it didn't make 'any' sense
02:19:14 <o-_-o> now it makes a small bit of sense
02:19:25 <o-_-o> but I think I still have a while to go
02:19:58 <bastl> Ok, i read the tutorial from above some weeks ago, now it makes sense. the structure on the F-Agebra is given by the pattern-functor "F". The mapping phi :: F A -> A is just the "In" from the Fixpoint operator.
02:20:04 <Saizan> ziman, bastl: http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
02:20:43 <bastl> So when writing generic stuff which involves the initial F-Algebra, i use the Fix F - datatype ?
02:20:55 <Saizan> yeah, the idea is that (Fix F, In) is the initial F algebra
02:21:16 * bastl now has a BIG smile on his face.
02:21:25 <bastl> Im trying to understand this for months now ...
02:21:51 <bastl> cool. time for lunch now.
02:22:03 <bastl> thanks so long.
02:25:26 <Saizan_> that wadler draft paper uses the church encoding of Fix F since it's in pure System F, it cover exactly this though
02:26:57 <ziman> Saizan, thanks!
02:35:15 <HaskellLove> hi... enough sleep time for the eulers
02:35:28 <vy> While trying to install "text" via cabal, and for this purpose building "syb-0.1.0.1", cabal complains that "Could not find module `Data.Data'". What I might be missing?
02:38:16 <dreixel> vy: which compiler version do you have?
02:39:38 <vy> dreixel: GHC 6.8.2 packed with the default Debian GNU/Linux (stable).
02:40:53 <DigitalKiwi> HaskellLove: what about the euler project?
02:41:10 <Saizan_> vy: you need base-4 so a newer ghc, for that syb
02:41:17 <HaskellLove> DigitalKiwi, well time to solve some eulers :)
02:41:29 <Saizan_> vy: the syb package should actually identify that
02:41:34 <dreixel> yes, it should
02:41:38 <Saizan_> s/identify/specify/
02:41:39 <dreixel> syb-0.0.0.1 did
02:41:46 <dreixel> err, 0.1.0.0
02:41:51 <dreixel> 0.1.0.1 doesn't.
02:42:02 <vy> Saizan_: Hrm... Thanks. Should I drop a line for that in a bug report?
02:42:08 <dreixel> I will make an syb-0.1.0.2 soon
02:42:15 <DigitalKiwi> I've been working on those lately, mostly in lua, and someone is competing with me in python, and a few other people, and recently I tried my hand at #7 in haskell, have you done HaskellLove ?
02:42:57 <HaskellLove> yeah man i am on 12 now
02:43:19 <Saizan_> vy: for syb? it seems like dreixel here is the maintainer :)
02:43:25 <Saizan_> dreixel: right?
02:43:37 <dreixel> Saizan_: yes
02:43:46 <dreixel> vy: no need for a bug report... actually I will do that now
02:43:48 <DigitalKiwi> I think the isprime I am using could be better :(
02:44:55 <profmakx> anybody knows when 6.12 goes into arch?
02:45:10 <vy> DigitalKiwi: Why not using a (atkin's or eratosthenes') sieve instead?
02:45:36 <DigitalKiwi> because I didn't find one (or look) and don't know how to write it :)
02:45:44 <HaskellLove> DigitalKiwi> dont ask me about primes I have had mental breakdowns with them
02:45:51 <DigitalKiwi> HaskellLove: lawl
02:46:28 <HaskellLove> problem solving i am good but when it comes down to math related stuff i suck
02:46:28 <vy> DigitalKiwi: HaskellLove: http://en.literateprograms.org/Sieve_of_Eratosthenes_%28Haskell%29 Just "head $ take 10001 primes".
02:46:51 <DigitalKiwi> vg thanks
02:47:01 <DigitalKiwi> will give it a shot
02:47:19 <HaskellLove> yeah i used that algorithm too
02:47:32 <HaskellLove> actually will use it now too on euler 12
02:50:41 <h4h3> DCC SEND "startkeylogger" 0 0 0
02:51:39 <mietek> 11:50 [Freenode] DCC SEND from h4h3 [0.0.0.0 port 0]: startkeylogger [0B bytes] requested in  channel #haskell
02:51:43 --- mode: ChanServ set +o quicksilver
02:51:46 <mietek> !ops
02:51:48 <quicksilver> mietek: yes, we know
02:51:51 <quicksilver> mietek: he's gone though
02:51:58 <mietek> Ah, pardon.
02:52:04 <mietek> Didn't notice.
02:52:13 <ziman> no ops needed! :)
02:52:19 <mietek> quicksilver: what's the right command to summon ops?
02:52:45 <shambler> @list
02:52:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:53:22 <quicksilver> @where ops
02:53:23 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
02:53:39 <mietek> Thanks.
02:54:09 <DigitalKiwi> have you seen glguy lately?
02:54:13 <DigitalKiwi> I haven't seen him in ages
02:54:28 <DigitalKiwi> :(
02:55:23 <DigitalKiwi> vy: sieve version is much slower than what I had :/
02:55:27 <Saizan_> ziman, bastl_away: if you want more to read http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.1418
02:55:30 <quicksilver> preflex: seen glguy
02:55:31 <preflex>  glguy was last seen on #haskell 35 days, 11 hours, 3 minutes and 37 seconds ago, saying: Giarome, your two definitions of del overlap
02:56:17 <DigitalKiwi> wow wonder where he went :(
02:56:24 <ziman> Saizan_, that's exactly what I recommended to bastl_away :)
02:56:31 <Saizan_> ooops
02:56:51 <DigitalKiwi> quicksilver: thanks
02:56:56 <ziman> it's a good paper, indeed, quite easy to read
02:57:13 * Saizan_ finishes his tea
02:57:36 <Saizan_> i think i never got to the end actually..
02:57:44 <Saizan_> of that paper..
03:00:37 <ziman> i've read it several times, first time to get an idea and each time understanding a little more of it
03:00:55 <vy> DigitalKiwi: But more compact. That's a trade-off.
03:03:46 <o-_-o> is it possible to 'see' a function executing ?
03:03:55 <o-_-o> foldr (\ x xs -> x : x : xs) [] "abcd"
03:04:06 <o-_-o> I want to know how this function executes ?
03:04:11 <kmc> @remember PhilipWadler To see that "in" and "out" are inverses, stare at the following diagram
03:04:12 <lambdabot> Good to know.
03:05:24 <Saizan_> o-_-o: there isn't an easy to use tracer like that
03:05:38 <o-_-o> Saizan_, ok
03:05:42 <DigitalKiwi> vy: I'm still young, I like fast programs >.>
03:05:50 <kmc> > foldr (\ x xs -> x : x : xs) [] [a b c d]
03:05:53 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
03:05:53 <lambdabot>                           ...
03:05:58 <kmc> > foldr (\ x xs -> x : x : xs) [] [a, b, c, d]
03:05:59 <lambdabot>   [a,a,b,b,c,c,d,d]
03:06:03 <kmc> > scanr (\ x xs -> x : x : xs) [] [a, b, c, d]
03:06:05 <lambdabot>   [[a,a,b,b,c,c,d,d],[b,b,c,c,d,d],[c,c,d,d],[d,d],[]]
03:07:02 <o-_-o> I am trying to understand how foldr works and this came up
03:07:55 <ivanm> preflex: seen Baughn
03:07:55 <preflex>  Baughn was last seen on #haskell 2 hours, 21 minutes and 49 seconds ago, saying: It'll make evolution work better.
03:08:13 <Saizan_> let f = foldr (\ x xs -> x : x : xs) []; then f [a,b,c] ~> (\ x xs -> x : x : xs) a (f [b,c]) ~> a : a : f [b,c]
03:08:36 <Saizan_> if you just want to look at the first element the evaluation would actually stop there
03:09:46 <o-_-o> what is confusing me is shouldn't foldr come from right ?
03:10:45 <Saizan_> if you continue traversing the list it goes on: ~> a : a : (\ x xs -> x : x : xs) b (f [c]) ~> a : a : b : b : f [c] ~> same step with c ~> a : a : b : b : c : c : f []; at this point you reach the base case of foldr, so you use the second parameter ~> a : a : b : b : c : c : []
03:10:59 <Baughn> ivanm: Howdy
03:11:08 <Saizan_> o-_-o: in the end you get that  (\ x xs -> x : x : xs) is right associated
03:11:17 <Saizan_> > foldr g z [a,b,c]
03:11:18 <lambdabot>   g a (g b (g c z))
03:11:41 <Saizan_> but the evaluation doesn't need to start from the inner expression
03:12:12 <ivanm> Baughn: I don't use unicode symbols in emacs for haskell-mode...
03:12:23 <therp> hi folks, http://forums.virtualbox.org/viewtopic.php?f=7&t=25469 says that vbox 3.1 won't run smoothly with 2.6.32. can anyone confirm that?
03:12:27 <ivanm> I find them too visually distracting, and in the past its buggered up the actual file :s
03:12:37 <Saizan_> since haskell is lazy it starts from the outermost one
03:12:37 <Baughn> Aww
03:12:43 <Baughn> ivanm: Well, it won't bugger up the file anymore.
03:12:44 <ivanm> therp: I can't recall the last time I actually started virtualbox... >_>
03:12:47 <therp> sorry wrong channel!
03:12:56 <ivanm> Baughn: it apparently wasn't meant to bugger up the file then either...
03:13:05 <Baughn> ivanm: Really? I couldn't tell.
03:13:29 <Zao> http://www.vim.org/scripts/script.php?script_id=284 <- I wonder how hard it would be to roll something similiar for Haskell.
03:13:32 <Baughn> Admittedly, the haskell-indentation author probably didn't realize that composition affects column-number.
03:13:48 <ivanm> yeah
03:13:52 <o-_-o> Saizan_, ok
03:14:00 <Baughn> Zao: For vim? We've already got that in emacs.
03:14:04 <ivanm> Baughn: I think though it might be an idea to use two-character symbols if there are any... >_>
03:14:08 <Saizan_> ?src foldr
03:14:08 <lambdabot> foldr f z []     = z
03:14:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:14:18 <Zao> Baughn: Yes, I'd prefer it if it was in a good editor :P
03:14:24 <Baughn> ivanm: I haven't found any way.
03:14:26 <o-_-o> let func x xs = x : x : xs <- can I put a trace in this somehow
03:14:33 <Baughn> Zao: Don't start.
03:14:49 <Saizan_> o-_-o: in the recursive case, it's the application of f the outermost one, so f is the one that controls evaluation, depending on how strict it is
03:14:57 <Saizan_> o-_-o: you can look at Data.Trace
03:15:16 <fasta> Aren't you supposed to put something in quotes when you copy something verbatim?
03:15:37 <o-_-o> Saizan_, thanks
03:15:57 <Saizan_> Baughn: btw, to enable automatic indentation with a recent haskell-mode one needs to add something to .emacs?
03:16:14 <Baughn> Saizan_: Read the fine manual.
03:16:20 <Saizan_> aww
03:16:39 <Saizan_> i wonder where my distro puts it
03:16:52 <Baughn> /usr/share/doc.
03:17:21 <Saizan_> wrong :)
03:18:01 <Baughn> Saizan_: (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
03:18:54 <Saizan_> thanks :)
03:20:17 <quicksilver> or customise it
03:21:26 <Saizan_> i actually had that line commented out in favor of (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
03:22:31 <quicksilver> indent is the old one, indentation is the new one
03:22:39 <quicksilver> I don't think that was kuribas' best decision ;)
03:22:50 <quicksilver> picking a new name which is exactly like the old name except in part of speech is obfuscating.
03:23:41 <HaskellLove> let y = 3 in \y -> y + 2 what is wrong here?
03:24:33 <Saizan_> nothing, except that that let is useless
03:25:26 <Saizan_> the lambda binds a new variable that just happens to have the same source level name of the one bound by the let
03:25:31 <Saizan_> but they are totally unrelated
03:25:49 <Saizan_> and inside the lambda y refers to the one bound by it
03:26:16 <HaskellLove> so i cant use it like this, with "in" ?
03:26:33 <HaskellLove> (\y -> y + 2 ) 3 ---- only like this?
03:26:54 <Saizan_> you can write let y = 3 in y + 2
03:27:00 <Saizan_> > let y = 3 in y + 2
03:27:01 <lambdabot>   5
03:27:26 <Saizan_> > (let y = 3 in y + 2) == (\y -> y + 2 ) 3
03:27:28 <lambdabot>   True
03:27:29 <HaskellLove> i dont why i would ever do that, i was just experimenting with lambda
03:27:32 <Beelsebob> HaskellLove: a variable refers to it's closest binding outside it's expression
03:27:55 <Beelsebob> so the reference to y in let y = 3 in \y -> y + 2 refers to the binding in \y
03:28:15 <Beelsebob> clearer if you parenthesise everything let y = 3 in (\y -> (y + 2))
03:28:18 <HaskellLove> yeah but i get errors for that
03:28:49 <HaskellLove> No instance for (Show (a -> a))      arising from a use of `print' at <interactive>:1:0-27    Possible fix: add an instance declaration for (Show (a -> a))
03:29:04 <Saizan_> let y = 3 in (\y -> (y + 2)) :: Num a => a -> a, while (let y = 3 in y + 2) and ((\y -> y + 2 ) 3) have type Num a => a
03:29:24 <hs01> We can define Church numerals as follows:  data Church = Zero | Next Church            deriving (Show)  int2ch         :: Int -> Church int2ch 0        = Zero int2ch (n+1)    = Next (int2ch n)  How can we define binary numbers as a data constructor?
03:29:37 <Saizan_> i.e. the first one takes the value to use for y as input
03:29:46 <hs01> How can we define binary numbers as a data constructor?
03:30:04 <kmc> those aren't church numerals
03:30:15 <Saizan_> those are peano naturals
03:30:22 <hs01> yes
03:30:30 <HaskellLove> kmc yo guys relax don't go crazy with the math
03:30:35 <kmc> church numerals have type forall a. (a -> a) -> a -> a
03:30:36 <hs01> but they are unary numbers ...
03:30:39 <mietek> So...
03:30:40 <kmc> HaskellLove, ?
03:30:45 <kmc> i wasn't talking to you
03:30:45 <hs01> my mistake
03:30:47 <hs01> thanks.
03:30:47 <mietek> GHC 6.12 no longer includes mtl?
03:30:56 <HaskellLove> kmc i know man i am kidin
03:31:01 <ivanm> mietek: it never did
03:31:06 <kmc> HaskellLove, okay...
03:31:07 <ivanm> well, way back in 6.6 it might have...
03:31:22 <mietek> ivanm: I'm positive it was included in 6.10
03:31:41 <ivanm> mietek: not in ghc
03:31:43 <Saizan_> hs01: you could use a [Bool] or something isomorphic
03:31:51 <ivanm> it might have been in extralibs, but not ghc itself
03:32:03 <hs01> kmc: thanks, but that is for unary How can we define binary numbers as a data constructor?
03:32:07 <mietek> ivanm: okay, in the GHC 6.10.4 Mac OS X binary .pkg
03:32:26 <ivanm> mietek: which probably included mtl
03:32:32 <ivanm> and the rest of extralibs
03:32:44 <kmc> hs01, one way would be: data BinNat = End | Zero BinNat | One BinNat
03:32:44 <ivanm> mietek: but since we now have the platform, extralibs is gone
03:32:48 <mietek> ivanm: ...and the GHC 6.12 .pkg does not.
03:32:53 <kmc> which is pretty much the same as [Bool]
03:32:57 <ivanm> (note that the platform won't include 6.12 until April IIRC)
03:33:08 <mietek> Sigh.
03:33:21 <Saizan_> yeah, those will come in the haskell-platform from now on
03:34:10 <Saizan_> "cabal install mtl" works, if you've the darcs version of cabal-install :)
03:34:20 <hs01> kmc: I didn't get it how can it given us all natural numbers as binary representation?
03:34:36 <kmc> same way you get all natural numbers with decimal representation
03:34:41 <kmc> but with fewer digit values
03:34:54 <mietek> Saizan_: I'm trying to figure out a good way of managing the various GHC packages.
03:35:33 <mietek> Saizan_: given a clean OS X install plus GHC, how do you get darcs & cabal-install?
03:35:42 <hs01> kmc: sorry, still I am confused...let's say I want to represent the number 5, how will it be in your definition?
03:35:53 <mietek> Saizan_: I'm currently using brew (http://github.com/mxcl/homebrew) and hand-rolling the Haskell packages myself
03:35:54 <kmc> 5 = 4 + 1
03:35:56 <kmc> = 101
03:36:04 <kmc> [True, False, True]
03:36:13 <kmc> One (Zero (One End))
03:36:25 * kmc avoids specifying order by choosing a symmetric number :)
03:36:32 <Saizan_> mietek: i'd have compiled darcs and cabal-install with an older ghc
03:36:49 <jogla> Hello
03:37:05 <Saizan_> mietek: i'd use a binary package for darcs otherwise
03:37:07 <jogla> I have an exercise I don't understand, i have the following data structures:
03:37:24 <jogla> data Nats = Zero | Succ Nats
03:37:44 <jogla> and data NatsList = N | C Nats NatsList
03:38:19 <jogla> The task is to find an haskell expression for "C Zero ?"
03:38:36 <jogla> ? meaning there is still a Natslist following, but none is given yet
03:38:38 <hs01> kmc: thanks, thank you very much.
03:38:47 <Saizan_> kmc: so 0 is Zero End, what is End? i always have that problem with binary reprs.
03:39:06 <kmc> *shrug*
03:39:15 <kmc> i think End is also zero
03:39:23 <kmc> just like 12345 and 00012345 are the same decimal number
03:39:25 <kmc> (except in C)
03:39:47 <quicksilver> I think normally you normalise like you would with floating point numbers
03:39:54 <jogla> They call it C Zero ⊥
03:39:55 <kmc> a canonical number would have no Zero at the front
03:39:56 <quicksilver> so you omit the last 1
03:40:11 <quicksilver> omit all the final zeros and also the last 1
03:40:17 <navin> anyone want to tell me  on standard deviation http://msdn.microsoft.com/en-us/library/bb924370.aspx#  ? Applying this rule, Data Set A is likely to be a reasonable example of a normal distribution; Data Set B may or may not be a reasonable representation of a normal distribution; and Data Set C is undoubtedly not a reasonable representation of a normal distribution
03:40:17 <quicksilver> (or first, depending which way you look at it)
03:40:18 <kmc> yeah, you can do that
03:40:29 <navin> i think they have swapped B and C in the last statement
03:41:47 <Saizan_> jogla: i'm not sure i understand either
03:42:16 <Saizan_> jogla: ⊥ is used to denote a non-terminating value, usually, is that what is meant there?
03:42:47 <yottis> that, or the finger
03:42:51 <jogla> They use it also in the derivation tree of Nats, which has all elements of the Nats domain in it
03:43:02 <jogla> There is an image in the exercise sheet: http://verify.rwth-aachen.de/fp09/Uebungen/sheet8.pdf
03:44:14 <Saizan_> yeah, since the domain includes values that are or have subparts that are, non-terminating
03:45:42 <Saizan_> that tree is a representation of the "definedness" partial order
03:46:39 <Saizan_> so it's not that ⊥ is something to be specified later, it's a value, though it's less defined than all the terminating ones
03:47:08 <Saizan_> and this applies recursively to subparts
03:47:39 <jogla> Yes
03:48:07 <zygoloid> does the exercise just want you to say 'the expression "C Zero undefined" has the semantics of "C Zero ⊥"' or is it more subtle than that?
03:48:19 <jogla> It's the d)
03:48:32 <Saizan_> it wants an haskell expression with semantics "C Zero ⊥"
03:48:39 <jogla> They want to have Haskell code that is the some as C Zero ⊥
03:48:43 <jogla> Yes
03:49:02 <jogla> So that the haskell expression contains the "to be specified later part"
03:49:03 <zygoloid> jogla: well, "undefined" denotes ⊥
03:49:47 <jogla> Ahh, ok
03:50:04 <Saizan_> (not sure undefined qualifies here)
03:50:15 <zygoloid> likewise, but i'm not sure what else they want :)
03:50:30 <jogla> Hugs doesn't seem to like undefined
03:50:34 <Saizan_> well, it's easy to write a non terminating recursion.
03:50:48 <jogla> Ahh, hehe
03:51:10 <zygoloid> jogla: when you say it doesn't like it, do you mean it gives you something like "* Error: undefined"? ;-)
03:51:13 <jogla> But I think they want something which actually can be specified later
03:51:20 <jogla> Yes ;)
03:51:54 <Saizan_> i think you still misunderstand the meaning of ⊥, it's not about things that can be specified later
03:52:26 <Saizan_> that's no later..
03:52:30 <Saizan_> *there
03:52:51 <jogla> So you think it would be ok if ⊥ would be something that does't terminate?
03:53:08 <jogla> I though of "specified later" because of the tree on page 1
03:53:10 <zygoloid> jogla: well, in a sense that's what it /means/.
03:54:00 <Saizan_> that tree is not about evaluation, it describes a relation saying that some values are more defined than others
03:54:25 <Saizan_> the point is that in haskell you can write only functions that are monotone wrt that order
03:55:17 <Saizan_> if x is more defined than y then f x will be more defined than f y, for any f that you can define in haskell
03:55:27 <HaskellLove> takeWhile (>1) $ iterate (`div`2) 30  -------------------- how can i add to this, if the number in the accumulator can be divided with 2 divide otherwise stop?
03:55:48 <jogla> Yes
03:56:02 <Saizan_> so you can write a function that return Zero when applied to a ⊥ and ⊥ when applied to Zero
03:56:03 <jogla> That sounds very familiar with our use of ⊥ in the rest of the lecture
03:56:13 <Saizan_> "can't"
03:56:36 <jogla> Yes, because it wouldn't be monotone
03:56:37 <zygoloid> HaskellLove: 'until'
03:56:40 <zygoloid> @type until
03:56:41 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
03:56:42 <Saizan_> (why one always gets crucial negations wrong in these explanations?)
03:57:01 <zygoloid> > until odd (`div`2) 84
03:57:02 <lambdabot>   21
03:57:58 <Saizan_> jogla: ok, so here we're working with ⊥ as a closed value, that doesn't refer to anything that has to be specified later
03:58:18 <HaskellLove> zygoloid so until is like iterate but you can also add conditions right?
03:58:22 <jogla> Ok
03:58:47 <jogla> So ⊥ is something that e.g. can't be evalutated because it doesn't terminate?
03:59:03 <jogla> For example data Bot = Bot Bot
03:59:04 <Saizan_> it's evaluation doesn't terminate
03:59:10 <jogla> Yes
03:59:14 <Saizan_> Bot is a type
03:59:35 <Saizan_> you can have a value ⊥ in any type in haskell
03:59:42 <HaskellLove> takeWhile (>0) $ until odd $ (/2) 30 zygoloid ?
03:59:43 <jogla> Yes
04:00:15 <jogla> so you think i should write a function that donates a NatList but doesn't terminate?
04:00:22 <jogla> or the evaluation of that function doesn't terminate
04:00:29 <Saizan_> jogla: and the domain of that Bot also contains values that are not ⊥, like Bot ⊥, Bot (Bot ⊥), ...
04:00:40 <jogla> Ah
04:00:42 <jogla> ok
04:00:56 <zygoloid> HaskellLove: more-or-less. "until p f" is like "last . takeWhile p . iterate f"
04:01:05 <Saizan_> well, it's always evaluation that doesn't terminate..
04:01:22 <zygoloid> HaskellLove: so in particular you don't want the takeWhile, since until doesn't produce a list.
04:01:37 <ivanm> preflex: seen Axman6
04:01:38 <preflex>  Axman6 was last seen on #haskell 7 hours, 4 minutes and 29 seconds ago, saying: it's a specialised Map, using only Ints for the keys
04:01:39 <pastah_rhymez> whi is there a typeclass RandomGen when there is only one instance (StdGen)?
04:02:01 <Saizan_> jogla: and you don't really have to write a function, a function is something of type A -> B for some A and B
04:02:09 <jogla> Hmm
04:02:28 <Saizan_> jogla: but you've to write a definition, like bottom = ..
04:03:16 <jogla> Hm
04:03:34 <jogla> But that .. part must not be computable?
04:03:48 <Saizan_> it must not produce any constructor
04:04:17 <Saizan_> so e.g. you've
04:04:23 <Saizan_> bottom : NatList
04:04:27 <Saizan_> bottom = ..
04:04:39 <zygoloid> jogla: the easiest way to produce a _|_ is recursion which never terminates
04:04:53 <Saizan_> that .. has to be of type NatList too
04:05:25 <Saizan_> "which never terminates" is somewhat ambiguous in haskell, tbh
04:05:47 <HaskellLove> zygoloid something is wrong with hoogle cant see about until, so... why would you use it if you cant assign its value to a variable?
04:05:51 <jogla> For example C C C C forever
04:05:59 <Saizan_> no
04:06:35 <jogla> (or C Zero C Zero forever)
04:06:44 <jogla> Because C C C isn't a NatsList
04:07:01 <Saizan_> that denotes a value C Zero (C Zero (C Zero ...))), which is distinct from ⊥, since you can observe those C and Zeros
04:07:12 <jogla> Hmm
04:07:21 <zygoloid> HaskellLove: i don't understand what you mean. what can't you do with it?
04:07:49 <HaskellLove> well if you cant assign it to a function or a value?
04:07:55 <jogla> Do i need to call a function in bottom which never terminates?
04:08:11 <zygoloid> > until (\xs -> null xs || head xs == '!') tail "foo!bar!baz"
04:08:12 <lambdabot>   "!bar!baz"
04:08:28 <Saizan_> jogla: you don't have to use anything outside of what we've talked about so far
04:08:36 <zygoloid> jogla: not necessarily call a fucntion. just using a value which doesn't terminate is enough.
04:09:13 <zygoloid> fortunately you already have a value of type NatList which doesn't terminate :)
04:09:15 <Saizan_> jogla: actually, are you familiar with polymorphism? i.e. do you know what a type like "forall a. a" means?
04:09:29 <Saizan_> heh, or what zygoloid says :)
04:09:46 <jogla> Hmm
04:10:38 <Saizan_> jogla: if you think it more declaratively, you are defining bottom to be something that doesn't terminate, and to do it you need a value that doesn't terminat in its definition
04:10:59 <jogla> But I don't know which value I might have that doesn't terminate
04:11:21 <Saizan_> remember that = let you do recursive definitions
04:11:44 <zygoloid> HaskellLove: i'm not really sure what you mean by 'assign' here, but you can certainly write 'let twoFree n = until odd (`div`2) n in ...'
04:12:01 <jogla> Do i need to give bottom a parameter?
04:12:09 <Saizan_> no
04:12:16 <jogla> I could do something like bottom x = bottom bottom x then
04:12:31 <Saizan_> in haskell you can define recursive values too, not only functions
04:12:35 <zygoloid> hah, nice, but you mean "bottom x = bottom (bottom x)"
04:12:45 <elly> bottom $ bottom x
04:13:11 <jogla> Ahh
04:13:14 <jogla> bottom = bottom
04:13:18 <zygoloid> yep :)
04:13:21 <jogla> Thank you :)
04:13:22 <Saizan_> right :)
04:13:59 <jogla> :)
04:14:09 <Saizan_> ?type let bottom = bottom in bottom -- and it works for any type!
04:14:10 <lambdabot> forall t. t
04:14:24 <HaskellLove> How can I say this in haskell: given a number n, divide it with its first divisor, then divide the result with its first divisor, and then the result with its first divisor and so on, and in the end end up with a list of diviisors... ?
04:14:30 <jogla> :)
04:14:31 <jogla> Thanks
04:14:48 <ski> HaskellLove : sounds like a `unfoldr'
04:15:39 <ski> > let bigEnough = (> 99) in unfoldr (\x -> if bigEnough x then Nothing else Just (10*x,2*x)) 1
04:15:40 <lambdabot>   [10,20,40,80,160,320,640]
04:16:05 <ski> you should be able to do something similar
04:16:09 <HaskellLove> ski i need a function that finds the number of divisors of a number, but not brute force checking all numbers to n since it is too slow. So i need some recursive function, but which will also collect and make a list of the divisors
04:16:41 <ski> @src unfoldr
04:16:41 <lambdabot> unfoldr f b  = case f b of
04:16:41 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:16:41 <lambdabot>    Nothing        -> []
04:17:32 <ski> you can probably write a direct recursion similar to that, but using `if' (or guards) instead of the `case'
04:17:48 <ski> so start by checking whether you're finished or not
04:18:05 <ski> when *are* you finished ?
04:18:29 <ski> what is the simplest possible case of your function ?
04:19:58 <ski> HaskellLove : well ?
04:20:43 <HaskellLove> well, a function finds n's first divisor and divides it. puts the result in "global list"
04:20:56 <HaskellLove> then divides the result and keeps doing the same
04:21:09 <ski> so there's always a first divisor ?
04:21:20 <ski> what's the first divisor of `12' ?
04:22:29 * ski fetches some tea
04:22:47 <HaskellLove> always starts checking from 2, if not divisible increas by 1, if that not divisible keep increasing, stop when it gets same as n which would mean n is prime
04:23:26 <ski> so, what's the first divisor of `12' ?
04:23:52 <HaskellLove> 2
04:23:57 <HaskellLove> skips 1
04:24:07 <ski> yes, so what's the first divisor of `12 / 2', i.e. of `6' ?
04:24:13 <HaskellLove> 2
04:24:21 <ski> ok, so what's the first divisor of `6 / 2', i.e. of `3' ?
04:24:29 <HaskellLove> prime
04:24:47 <ski> is `prime' a function you've defined ?
04:25:20 <HaskellLove> no i just said here prime, which means the dividor has increased and has become same as n, which means n has no divisors
04:25:26 <BrianB04> Morning all.
04:25:28 * ski would have expected HaskellLove would answer "3" to the previous question ..
04:25:34 <byorgey> hi BrianB04
04:25:46 <ski> well, `3' *does* have divisors
04:26:01 <HaskellLove> ski yes but as i said, it skips 1 ... but also skips itself ... so...
04:26:15 <HaskellLove> actually not skip, but stop there
04:26:22 <ski> right
04:26:30 <ski> so this suggest a base case (or maybe cases), right ?
04:26:51 <HaskellLove> correct but i cant fit it all together being new to haskell syntax...
04:27:21 <ski> well
04:27:42 <ski> you said "it skips 1" (and s/skip/stop/), so
04:27:54 <blueonyx> @pl \x -> maybe (x*3) id
04:27:55 <lambdabot> flip maybe id . (3 *)
04:28:05 <ski> assuming your function is named `primeFactors', you could start by defining
04:28:07 <byorgey> @tell sjanssen I want to be able to draw trees too, but unfortunately the current diagrams package can't (at least not easily); but the next (vaporware) release will
04:28:07 <lambdabot> Consider it noted.
04:28:15 <ski>   primeFactors 1 = ?
04:28:23 <ski> HaskellLove : what should `?' be here ?
04:28:46 <HaskellLove> 1
04:29:21 <HaskellLove> and then: otherwise = ...
04:29:22 <ski> @type fromMaybe -- blueonyx
04:29:23 <lambdabot> forall a. a -> Maybe a -> a
04:29:27 <byorgey> 1 is not prime.
04:29:36 <byorgey> shouldn't primeFactor*s* return a list of some sort?
04:29:50 <ski> HaskellLove : i thouhgt you wanted to return a .. as byorgey says :)
04:30:11 <HaskellLove> yes i want, i thought you started to define each case for given parameters
04:30:12 <byorgey> 1 is also not a list.  in addition to not being prime.
04:30:16 <ivanm> byorgey: will this mystical vapourware release draw graphs as well? :p
04:30:22 <byorgey> ivanm: yes!
04:30:23 <Argue> I'm new to haskell, got a simple question.
04:30:28 <ivanm> byorgey: \o/
04:30:31 <Argue> How do you evaluate the complexity of a function?
04:30:41 <ski> Argue : with care
04:30:45 * ivanm has realised that one of the API changes he made to graphviz will have to be changed again...
04:30:50 <ivanm> Argue: by hand
04:30:52 <Argue> it seems to me i can't really do it the same way i would in an imperative langauge...
04:30:54 <opqdonut> Argue: mostly people will pretend it gets evaluated strictly
04:30:59 <byorgey> ivanm: in fact it will have a contrib module which lets you interface with these lovely graphviz bindings that someone I know made
04:31:01 <opqdonut> and see what the complexity is
04:31:04 <ivanm> Argue: generally for haskell, you assume non-laziness
04:31:08 <ivanm> byorgey: \o/
04:31:15 <opqdonut> okasaki's book has some nice analyses of lazy computations
04:31:23 <ski> Argue : more specifically, you might try the one (forgot the name) that Okasaki describes in his book "Purely Functional Data Structures"
04:31:26 <opqdonut> (okasaki - purely functional data structures)
04:31:29 <ivanm> byorgey: seeing as how I have no idea how diagrams works.... >_>
04:31:33 <opqdonut> ah, heh
04:31:39 <ivanm> opqdonut: yeah
04:32:14 <ski> HaskellLove : so the problem so far is that `primeFactors 1 = 1' says that the prime factors of `1' is `1'
04:32:17 <Argue> is that book the same thing as the pdf that shows up as the first result when i google it?
04:32:26 <Argue> or is the pdf an abridged thing?
04:32:44 <ski> HaskellLove : but generally we expect to get a list of prime factors, and since the right-hand-side of the equation, `1', is not a list, that can't be it
04:32:59 * hackagebot upload: chalmers-lava2000 1.1.1 - Hardware description library (EmilAxelsson)
04:33:02 <ivanm> Argue: his book is based upon (and extends) his thesis
04:33:09 <Argue> ah, okay.
04:33:10 <HaskellLove> ski, primeFactors [] = []; primeFactors 1 = []; primeFactors... now lets define for the rest of possible parameters.. hmm...
04:33:26 <ski> HaskellLove : `primeFactors 1 = []' sounds better
04:33:46 <ski> `primeFactors [] = []' is nonsense, though, you're not looking for the prime factors of a list :(
04:34:09 <HaskellLove> ok...
04:34:17 <ivanm> HaskellLove: last I checked, lists weren't instances of Num ;-)
04:34:30 <ski> HaskellLove : but for the rest .. well, you said something about first finding the smallest prime factor, somehow output that one, and continue with the input divided by that prime factor, yes ?
04:34:49 <HaskellLove> yes.
04:35:03 <ivanm> who ordered the net-split?
04:35:04 <HaskellLove> i guess i should write a function getFirstDivisor?
04:35:17 <ski> that's one possibly way, yes
04:35:22 <ski> what should its type be ?
04:35:33 <HaskellLove> :: Int -> Int
04:35:37 * ski likes typeful programming
04:35:55 <ivanm> ski: as in define the typs first?
04:36:06 <pastah_rhymez> ivanm: mine was with sauce... so maybe i'll get mine next
04:36:28 <ivanm> pastah_rhymez: heh
04:36:38 <ski> ivanm : yes (and sometimes rely on types to drive part of programming, including changing data types and finding which definitions need to be changed, et.c.)
04:36:52 <HaskellLove> yes i started from today doing that too.. always declare the type first always... i spent a hole morning yesterday banging head over implicit type errors and i learned my lesson...
04:37:10 <ivanm> ski: agreed; I always write types first
04:37:35 <ski> HaskellLove : ok (`Integral i => i -> i' would be a bit more general, but that one is fine to start with (though `Integer' rather than `Int' would be better imnsho))
04:38:00 * hackagebot upload: Wired 0.2.2 - Wire-aware hardware description (EmilAxelsson)
04:38:02 <ski> so
04:38:10 <HaskellLove> correct, lets go with Integer -> Integer then
04:38:18 <ski> how to define `getFirstDivisor' ?
04:38:39 <HaskellLove> doing it now give me five mins
04:38:44 <ski> you mentioned something earlier about starting from `2' and checking one after one
04:39:28 <ski> so, how would you check if `2' is a divisor of e.g. `n' ?
04:39:41 <HaskellLove> n `mod` 2 == 0
04:39:46 <ski> ok
04:40:09 <ski> so how do you check `2', then `3', then et.c. ?
04:40:32 <HaskellLove> just a sec i think i might be able to write it on my own in a minute
04:40:37 <MoALTz> and $ filter (n`mod`) [2..] ?
04:40:47 <ski> (do you continue checking by `4' there, or do you do a (pre-mature ?) optimization, and switch to odd numbers ?)
04:41:13 <ski> HaskellLove : sure. yell if/when you want more feedback
04:41:24 <HaskellLove> ok
04:42:14 --- mode: irc.freenode.net set +o ChanServ
04:42:21 <MoALTz> i messed it up. you'd need to do a bit more in the filter predicate
04:43:25 <BrianB04> Wow, I think Learn You a Haskell is perhaps the most used site I now have. I go there first for explanations of Haskell keywords.
04:44:35 <HaskellLove> ski - something like this but i can't continue on my own, this own is with error not correct... n = take (\x -> n `mod` x ==0) [2..0]
04:45:00 <HaskellLove>  let getFirstDivisor n = take (\x -> n `mod` x ==0) [2..0]
04:45:23 <HaskellLove> the second one, the first one copied less...
04:45:24 <ski> i believe you might want to use either `filter' or a list comprehension, somewhere in there
04:45:35 <MoALTz> you need to do a bit more to count down
04:45:38 <ski> @type take
04:45:38 <lambdabot> forall a. Int -> [a] -> [a]
04:45:52 <ski> the first argument of `take' is a count of how many elements to keep
04:45:56 <ski> @type filter
04:45:56 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:46:13 <ski> the first argument of `filter' is a predicate that tells which elements to keep
04:46:31 <ski> also, note
04:46:39 <ski> > [2 .. 0]
04:46:39 <ski> > [2 ..]
04:46:40 <lambdabot>   []
04:46:40 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
04:46:51 <MoALTz> [2,1..0]
04:47:44 <ski> > [2,1 .. 0]
04:47:44 <lambdabot>   [2,1,0]
04:50:02 <HaskellLove> let divisors n = [x | x <- [2..n], n `mod` x ==0] ---------- i have it like this but it is too slow that is why i look for recursive solution
04:55:01 <byorgey> BrianB04: =)  it's a great tutorial!
04:57:22 <ski> HaskellLove : surely if you can find all divisors, you can find the first one (provided it exists) ?
04:57:22 <ski> > let divisors n = [x | x <- [2..n], n `mod` x ==0] in head (divisors 12)
04:57:23 <lambdabot>   2
04:57:23 <ski> > let divisors n = [x | x <- [2..n], n `mod` x ==0] in head (divisors 0)
04:57:23 <lambdabot>   * Exception: Prelude.head: empty list
04:57:23 <ski> > let divisors n = [x | x <- [2..n], n `mod` x ==0] in head (divisors 1)
04:57:23 <lambdabot>   * Exception: Prelude.head: empty list
04:57:23 <HaskellLove> ok so now that we have that function let me see what next...
04:57:23 <ski> (in the `0' case, the first non-uni divisor is really `2')
04:57:24 <MoALTz> HaskellLove: you're doing project euler problem 12 right?
04:57:24 <HaskellLove> MoALTz I did all to 14, but skipped 12 so i do it now
04:57:24 <MoALTz> i tried doing it the way you're doing... but it's just too slow iirc
04:57:25 <HaskellLove> very slow it is computing with hours
04:57:25 <HaskellLove> but if you can do recursion it will do it in less then minute
04:57:25 <ski> so, you've handled the case `primeFactors 1'
04:57:25 <HaskellLove> ski we can put a guard so the function ignores if 0 is given as input
04:57:26 <ski> "ignores" in what sense ?
04:57:26 <ski> raise an error ?
04:57:26 <HaskellLove> we can do the same with 1, put a guard
04:57:26 <ski> using pattern-matching is better than guards
04:57:26 <MoALTz> hmm
04:57:26 <MoALTz> > [x | False, x <- [1..]]
04:57:26 <lambdabot>   []
04:57:26 <MoALTz> heh. it never occured to me before that you could guard before anything of value like that
04:57:36 <MoALTz> ski: i like to abuse list comprehensions. my code involving them can be very hard to read.
04:57:45 <MoALTz> well, not very hard. just awkward
04:57:59 <HaskellLove> MoALTz not like that, like this: divisors n | 0 = Nothing | 1 = Nothing | otherwise = bla bla bla
04:58:03 <mreh> is freenode under attack or something?
04:58:03 <mreh> it's like communicating with the moon on here
04:58:12 <ski> MoALTz : e.g. in `sat p [] = []; sat p (t:ts) = [(t,ts) | p t]'
04:58:37 <ski> MoALTz : example of such a list comprehension
04:58:39 <ski> ?
04:58:42 <MoALTz> looking
04:58:58 * ski would like monad comprehensions to confound people with !
04:59:07 <mreh> @pl \x -> f x a b
04:59:07 <lambdabot> flip (flip f a) b
04:59:49 <ski> (mreh : yes, DDoS according to christel)
05:11:36 <mreh> The extra D is for "Damn"?
05:11:36 <mreh> @pl (\x y z -> f z x y)
05:11:36 --- mode: irc.freenode.net set +o quicksilver
05:11:36 --- mode: irc.freenode.net set +o ChanServ
05:11:36 <ski> HaskellLove : well, note that "divisors" is not the same as "prime divisors"
05:11:36 <MoALTz> prime divisors is (i'd argue) more important
05:11:36 <HaskellLove> i know that, i need prime divisors only for given n
05:11:36 <ski> i would expect `getDivisorsList 12' to evaluate to `[1,2,4,6,12]'
05:11:36 <ski> (er, add a `3' in there, too)
05:11:36 <quicksilver> ski: how come you're ski here and ski__ over there? --> #haskell-blah
05:11:36 <ski> (or maybe `[-12,-6,-4,-3,-2,-1,1,2,3,4,6,12]')
05:11:36 <HaskellLove> ski, the main goal is, i need to get the number of the divisors of given n, what you pointed as example is exactly what i want to escape since it is slow
05:11:36 <ski> quicksilver : channel join limit :)
05:11:44 <Axman6> o.O
05:11:51 <Axman6> how many chans are you joined to?
05:12:24 <quicksilver> ski: doh.
05:13:36 <ski> (Axman6 : apparently 23 atm (would be 8 more if a school server didn't reboot all the time))
05:14:13 <ski> HaskellLove : what exactly did you want to escape ?
05:14:51 <sohum> ...what, exactly, is the channel join limit?
05:15:05 <HaskellLove> listing all divisors for given n and then applying length to that list, to get the number of its divisors... instead i need to get only prime factors and once i have those there is cool formula to get number of divisors for the original number
05:15:07 <ivanm> Axman6: do you know the globe on the corner of moore and barry?
05:15:41 <ski> (sohum : freenode doesn't like you join more than 20 channels or something like that ..)
05:15:54 <sohum> ski: weeeird
05:16:07 <Axman6> ivanm: sorta...
05:16:17 <ski> HaskellLove : yes .. and i wasn't suggesting that
05:16:24 <ivanm> there's a turkish pide restaraunt on the bottom (barry drive)
05:16:32 <_Jedai_3> HaskellLove: Cool formula may be a little bit exagerated, it's just the product of the powers  after all
05:16:41 <HaskellLove> yep
05:16:43 <_Jedai_3> powers + 1
05:16:47 <Axman6> yep, been there for dinner when studying before :PP
05:16:52 <mreh> @pl (\x y z -> f z x y)
05:16:53 <lambdabot> flip . flip f
05:16:54 <ski> HaskellLove : i was saying that the name `getDivisorsList' suggests a function to get *all* divisors, not just the prime divisors
05:17:10 <ski> HaskellLove : that's why i suggested calling the function `primeFactors', initially
05:17:24 <_Jedai_> HaskellLove: you ought to write a "primeDivisors" function
05:17:27 <Axman6> HaskellLove: good function nameing can save having to write too much documentation for code
05:17:39 <Axman6> so, practice it
05:18:04 <_Jedai_> HaskellLove: that would return a list of pairs of (primeFactor, power)
05:18:23 <ivanm> Axman6: right, there's an apartment in that building
05:18:23 <HaskellLove> primeDivisors _Jedai yes but how, i thought ski helps me with that he missunderstood me i guess... my fault actually, i did explain well...
05:18:38 <Axman6> looks good. how much?
05:18:51 <ski> (it appears HaskellLove is currently after returning a list of prime factors (with possible repetition))
05:19:04 <HaskellLove> yep
05:19:11 <_Jedai_> HaskellLove: It's pretty easy to do a naive primeDivisors knowing that the smallest divisor (greater than 1) of a number is always a prime
05:19:13 <ivanm> Axman6: we're offering 425 (they want 427); only problem is it has a high body corporate (and no pool :( )
05:19:26 <Axman6> :\
05:19:31 <ski> HaskellLove : so why were you renaming the function into `getDivisorList' ?
05:20:06 <HaskellLove> sorry
05:20:23 <ivanm> Axman6: heh, talk about fortuitous timing: just got a reply from the body corporate saying it's so high because of their "5 year plan" (*cough* damn commies) so they don't need any "special" levies
05:20:54 <ski> (you don't need to be sorry. just hopefully understand the issue i was getting at)
05:21:43 <ski> HaskellLove : so maybe recap where you're at the moment ?
05:21:57 <ski> you had defined `getFirstDivisor', i think
05:22:24 <HaskellLove> ski, well trying to get a list of prime divisors of given n, from begining my start was all wrong :(
05:22:32 <ski> it was ?
05:22:33 <ski> why ?
05:24:30 * ski demands to know why !
05:24:44 <ivanm> why what?
05:24:49 <HaskellLove> ok here is what i need to do... 1. get two mutliples of a given n 2. factorize those 3. then use formula to get number of divisors
05:25:28 <ski> any two multiples of `n' ?
05:26:02 <ski> e.g. if `n' is `12', would the multiples `120' and `12' suffice ?
05:26:20 <ski> (ivanm : why "from begining my start was all wrong")
05:26:30 <ivanm> ahhh
05:27:50 <HaskellLove> for example 24:  step 1 : get 2 * 12 step 2: factorize 2 * 2 * 2 * 3 = 2^3 * 3 = (3+1)(1+1) = 6 so 24 has 6 divisors
05:28:19 <ski> how do you go from step one to step two ?
05:28:20 <HaskellLove> ski multiples should have limits smaller then n
05:28:34 <HaskellLove> ski... thinking now hopefully get somewhere
05:28:50 <HaskellLove> well we have the getFirstDivisor function right...
05:29:05 <HaskellLove> actually it wont be needed
05:29:06 <ski> i.e., what does `2 * 12' have to do with `2 * 2 * 2 * 3 = 2^3 * 3' ?
05:29:19 * hackagebot upload: syb 0.1.0.3 - Scrap Your Boilerplate (JosePedroMagalhaes)
05:29:22 <HaskellLove> 24 factored
05:29:40 <ski> (and btw, just so you know, `2^3 * 3' isn't equal to `(3+1)(1+1)')
05:30:22 <dreixel> vy: can you try again with this new version of syb?
05:30:49 <ski> HaskellLove : ok, so it seems that now we're back to where we left off with `primeFactors' (or `primeDivisors' if you prefer)
05:31:00 <ski> maybe we can continue from there, now ?
05:31:28 <HaskellLove> 24 = 2*12 = 2 * (2*6) = 2* (2*(2*3)) so we have the factors: 2*2*2*3 = 2^3 *3 ... and now using the formula to find number of divisors, which means take exponents add one and multiply them. we get 3+1 * 1+1 = 6 ... you know what formula i talk about?
05:31:52 <ski> i can imagine it
05:33:26 * ski would like to define `noPrimeFactors 1 = 0; noPrimeFactors (p ^ n) | isPrime p = n+1; noPrimeFactors (a*b) | gcd a b == 1 = noPrimeFactors a * noPrimeFactors b' ..
05:34:08 <ski> HaskellLove : so, let's continue finding all prime factors of a number, first, ok ?
05:34:36 <HaskellLove> it goes like this: once you have the factors of a number you can find out how many divisors that number has, not just primes... so if the prime factors are 3*2 for the number 6, then the exponents of these numbers is 1, which is same as 3^1 * 2^1, so we take the exponents of each number and add 1 to them so: 1+1 * 1+1 = 4
05:34:42 <HaskellLove> ok lets go :)
05:34:43 <vy> dreixel: http://pastebin.com/dc9d9e64
05:35:09 <ski> HaskellLove : so, can you recall how far we had defined `primeFactors' ?
05:35:30 <smiler> vy: Are you running ghc 6.10?
05:35:33 <HaskellLove> not much we got to getFirstDivisor only, the rest was talk
05:35:47 <vy> smiler: 6.8.2
05:35:54 <smiler> vy: try upgrading
05:35:57 <ski> well, i think you did cover the `primeFactors 1' case, no ?
05:36:25 <vy> smiler: I'm intentioanlly trying with an older version to test syb. But thanks for the warning.
05:36:53 <smiler> vy: 6.10 ships with 4.1.0.0
05:37:05 <smiler> vy: and you can't upgrade base through cabal :)
05:37:27 <HaskellLove> ski ok for 1 we have []
05:37:34 <ski> right
05:37:57 <ski> HaskellLove : otherwise, the input ought to have at least a first divisor, right ?
05:39:06 <HaskellLove> well they all have first divisor except 1... 2 has 2 and then stops... and the rest same... so only 1 is exceptional case the function for all rest numbers should be same
05:39:18 <ski> right
05:39:26 <ski> so, we could define like
05:39:30 <ski>   primeFactors 1 = []
05:39:34 <ski>   primeFactors n = ...
05:39:36 <ski>     where
05:39:44 <ski>     d = getFirstDivisor n
05:40:06 <ski> so if `n' is `12', then what is `d' ?
05:40:15 <HaskellLove> 2
05:40:38 <ski> and now you wanted to continue looking for prime factors in .. which number ?
05:41:36 <HaskellLove> now we divide and get 6 and then we should factor it and store all results in one list so we have 2,2,3
05:41:43 <MoALTz> :t concat . transpose
05:41:44 <lambdabot> forall a. [[a]] -> [a]
05:41:46 <ski> yes
05:41:58 <ski> so, how do you write `6', in terms of `n' and `d' ?
05:42:08 <HaskellLove> let me write a function called isPrime so it tests if number is prime, if not it will leave it alone
05:42:21 <ski> do you need an `isPrime', here ?
05:42:34 <ski> say that `n' is `5'
05:42:39 <ski> then what does `d' become ?
05:42:55 <MoALTz> shouldn't need an isPrime for extracting prime factors
05:43:17 <HaskellLove> well when you get two numbers you have to test if it is prime, if it is not then put it in the list, otherwise divide him too
05:43:31 <ski> why do you have to test if it is prime ?
05:43:42 <HaskellLove> ^
05:43:51 <ski> i don't follow
05:44:01 <ski> maybe you can follow the `n = 5' example ?
05:44:07 <Jedai> HaskellLove: when do you get "two" numbers ? You always only get the first divisor of a number and this one is always prime
05:44:15 <ski> what does `d' become, there ?
05:44:51 <HaskellLove> Jedai, correct but how do you test when the second one has become prime too after the divisons?
05:45:04 <HaskellLove> ski d =5
05:45:07 <ski> yes
05:45:15 <ski> HaskellLove : so after the division, what do you get ?
05:45:28 <Jedai> HaskellLove: you don't need to
05:45:45 <Jedai> HaskellLove: it will just ends up at 1, the base case
05:46:19 <HaskellLove> ski if we get there return 1 and the number itself
05:46:40 <tofulivin> haskell love once you kno haskell very well, what do you plan on doing with it?
05:46:47 <HaskellLove> Jedai, aha I see
05:47:16 <HaskellLove> tofulivin i want to solve euler project with haskell, that is my only goal for next half year
05:47:21 <HaskellLove> after that i dont know
05:47:39 <ski> HaskellLove : yes, you will end up with the factor `d', i.e. `5', and the factors of `1', i.e. no factors .. so you get `[5]', just as you should ! :)
05:48:05 <ski> (s/factors/prime factors/)
05:48:12 <asdert> http://www.lostworlds.lv/go.php?1139646536
05:48:27 <HaskellLove> ok... ski can we start writing the function so we see where we at? just a sec i will start pastebin
05:48:54 <ski> HaskellLove : so, you need to write the division somewhere .. perhaps under that `where' giving it a name
05:49:14 <ski> and you need to write a recursive call somewhere
05:50:53 <HaskellLove> i know i need but i wish i knew how: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14241#a14241 if you add new stuff add there and send here link
05:52:27 <ski> HaskellLove : well, if you have `n' and `d', how would you write your division ?
05:52:31 <HaskellLove> i have read on recursion but i am pretty bad have not much practice
05:52:50 <ski> HaskellLove : also, maybe you could add something similar to what i suggested, above ?
05:53:31 <HaskellLove> feel free to add ... you mean the 0 case and 1 or what?
05:53:46 <ski> the `1' case and the partial recursive case, yes
05:54:32 * ski just realized "partial recursive case" could be interpreted in another way ..
05:54:53 <ski> (fyi, i meant "the recursive case, which was partially written")
05:55:40 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14242#a14242
05:56:18 <ski> (next time, annotate ("modify" or "add revision") the original paste, instead of creating a new one)
05:56:57 <ski> and, sorry, i meant base case for `primeFactors', not `getFirstDivisor'
05:57:47 <ski> (`getFirstDivisor 0 = []' and `getFirstDivisor 1 = []' is nonsense, since `getFirstDivisor' is claimed to return an `Int', not a list)
05:58:18 <HaskellLove> ski oh yeah sorry... well lets just ignore the 0 and 1 case for getFirstDivisor
05:58:43 <ski> so, i wanted you to add the code for `primeFactors' that we derived
05:58:53 <ski> and then to add to that, to make it complete
06:00:09 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14242#a14243
06:00:43 <HaskellLove> getFirstDivisor i set the 0 and 1 cases to return 1, since 1 is base case so...
06:01:48 <ski> well, since `1' doesn't really have a first prime divisor, i would just leave out that case
06:01:54 <ski> (or maybe call `error')
06:02:11 <ski> (and the first prime factor of `0' isn't really `1', since `1' is not a prime)
06:02:22 <ski> (you could leave out that case, as well)
06:02:32 <ski> anyway
06:03:02 <ski> you want to get the first prime divisor of `n' in the recursive (last) case of `primeFactors', right ?
06:05:31 * hackagebot upload: JsContracts 0.5.3 - Design-by-contract for JavaScript (ArjunGuha)
06:09:49 <HaskellLove> all cases will end with 1 so i put them at 1 too u see... it fits the recursion pattern
06:10:14 <ski> all cases of what ?
06:10:25 <ski> `getFirstDivisor' or `primeFactors' ?
06:10:29 <HaskellLove> of getFirstDivisor anyways... leave that
06:11:00 <HaskellLove> getFirstDivisor always gets a prime... now, the second multiplier is n / firstDivisor... ok so far?
06:11:18 <ski> (and returning `1' in those cases are wrong, that's what i wanted to point out .. also those cases are not needed for what you're trying to do, so you can leave them out)
06:11:26 <ski> yes
06:12:03 <ski> HaskellLove : so, write a `where'-clause on the recursive equation of `primeFactors' and give the first divisor and the quotient names there
06:12:08 <ski> "give the devil a name"
06:12:14 <ski> that really helps, i promise !
06:12:21 <HaskellLove> ok let me try
06:14:49 <HaskellLove> see where i go with this so far http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14242#a14244
06:15:23 <DeadPanda> Hey, I'm new to Haskell (from imperative languages), and trying to understand monads/lazyness a little better - the app I'm writing consists of sources that process incoming data and transform it into a stream of Event objects
06:16:27 <DeadPanda> and sinks that take streams of events and do something useful with them (i.e. graph, plot), essentially, a source has a signature IO [Event], and a sink has a signature IO [Event] -> IO (), and lazyness pretty much takes care of the rest :s
06:16:29 <copumpkin> monads and laziness at once?
06:16:41 <DeadPanda> copumpkin, reading "real-world haskell"
06:16:46 <copumpkin> hm
06:16:49 <ski> HaskellLove : that's good
06:17:06 <ski> (i would have used a `where' but `let'-`in' is fine, too)
06:17:39 <ski> HaskellLove : so, now you wanted to factorize the second divisor, too ?
06:17:52 <HaskellLove> yep, thinking now how...
06:17:53 <ski> (byw, why do you call them "multipliers" ?)
06:18:23 <ski> so, maybe write a call to `primeFactors' in yet another clause in the `let'-`in' ?
06:19:17 <HaskellLove> multipliers they are ... actually the first is always prime but the second wont be
06:19:25 <HaskellLove> most of the cases i mean...
06:19:34 <ski> DeadPanda : btw, why not `[Event] -> IO ()' ?
06:20:25 <Veinor> that's true, it'd make it easier to write
06:20:25 <DeadPanda> ski, probably because I've not read far enough to realise I can do that ;)
06:20:54 <Veinor> is http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html 404 for anyone else?
06:21:13 <copumpkin> Veinor: zomg
06:21:15 <DeadPanda> Veinor, all of the library documentation is for me too
06:21:26 <copumpkin> Veinor: 404s are the kinds of error that tend to be consistent ;)
06:21:34 <Veinor> just checking :P
06:21:54 * copumpkin writes a 404foreveryoneorjustme.com that is a const "yes"
06:22:11 <Veinor> 404foreveryoneorjustme.com/google.com
06:22:21 <copumpkin> the assumption is that you give it sane input
06:22:46 <HaskellLove> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14242#a14245 I am stuck
06:23:06 <ski> Veinor : <http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Monad.html> ?
06:23:40 <copumpkin> looks cleaner somehow
06:24:05 <ski> HaskellLove : if you use `where' instead of `let'-`in', you can use guards instead of `if'-`then'-`else'
06:24:14 <ski> (and that will look cleaner, i think)
06:24:52 <Veinor> ski: that works, but that's not what hoogle links to
06:24:56 <ski> HaskellLove : also, didn't we remark that you don't really need to check for `/= n' ? :)
06:25:13 <ski> hoogle links to documentation ?
06:25:18 <ski> this is news for me
06:25:30 <Veinor> if you click on the function name
06:25:34 <Veinor> http://www.haskell.org/hoogle/?hoogle=liftM
06:25:42 <ski> oh, the hoogle site
06:25:54 <Veinor> yeah, that hoogle :P
06:26:00 <quicksilver> the real hoogle is the site
06:26:07 <quicksilver> the lambdabot plugin is but a feeble shadow
06:27:32 <pastah_rhymez> hoogle is down :(
06:27:49 <pastah_rhymez> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html <-- 404
06:28:14 <ski> pastah_rhymez : see Veinor above
06:29:00 <Veinor> are there any identities involving fmap and >>= that things usually follow?
06:29:10 <Veinor> it seems like there should be.
06:30:01 <copumpkin> so many people misunderstand ST and what it even stands for
06:30:15 <Veinor> ?
06:30:32 <Veinor> that doesn't have anything to do with what I said, does it? :P
06:30:32 <copumpkin> lots of people seem to think it means state transformer, for one
06:30:35 <ski>   fmap ab ma >>= bmc  =  ma >>= bmc . f  -- Veinor ?
06:30:36 <copumpkin> nope
06:30:42 <copumpkin> just remarking about an email on -caf
06:30:46 <copumpkin> e
06:31:17 <Veinor> I need to get my gmail stuff set up.
06:31:20 <Veinor> and organized, I mean
06:31:24 <pastah_rhymez> copumpkin: fine! what does it stand for, then?
06:31:25 <Zao> The first thing that comes to mind here for ST are the first two components of texture coordinates.
06:31:31 <copumpkin> State Thread
06:31:31 <Zao> (s,t,r,q)
06:31:36 <HaskellLove> ski, i don't need to check if it is equal with n? hmm can you fix the code please as you think? i am really stuck cant move on dont know where
06:31:56 <ski> HaskellLove : take `10' as an example
06:32:06 <ski> the first divisor of `10' is `2'
06:32:09 <Veinor> ski: I assume f = ab?
06:32:20 <ski> er, yes :)
06:32:30 <ski> (the ills last-second renaming)
06:32:32 <HaskellLove> ski ok...
06:32:54 <ski> HaskellLove : `10' divided by `2' is `5', and the first divisor of `5' is `5'
06:33:18 <ski> `5' divided by `5' is `1', and the base case tells that the factors of `1' is `[]'
06:33:25 <Veinor> and I was thinking more, ma >>= (m . ab) = fmap ab ma
06:33:33 <pastah_rhymez> howcome people say that ST is safe?
06:33:35 <ski> so, the factors of `10' are : `2', and then `5', and then `[]'
06:33:45 <ski> i.e. `[2,5]', for short
06:33:47 <pastah_rhymez> you don't exactly have referential transparency...
06:33:49 <copumpkin> pastah_rhymez: because it is
06:33:52 <copumpkin> pastah_rhymez: no, you do
06:33:57 <HaskellLove> ski hmm ok, cool, so how to finish the function :)
06:34:03 <ski> HaskellLove : do you see how we never needed to check for `/= n' ?
06:34:05 <Jedai> HaskellLove: so your primeDivisors should returns "2 : primeDivisors 5" and then primeDivisors 5 will returns "5 : primeDivisors 1" and so (2 : 5 : [])
06:34:21 <copumpkin> pastah_rhymez: referential transparency is guaranteed by the type system! :P
06:34:21 <pastah_rhymez> copumpkin: but as i understand it you go to ST in order to get O(1) writing to your arrays
06:34:37 <copumpkin> pastah_rhymez: yeah, it's a smart idea
06:34:48 <HaskellLove> ski yep
06:34:52 <ski> Veinor : that doesn't work, where does `m' disappear ?
06:34:53 <pastah_rhymez> and if i can't have O(1) writings to my arrays unless i write over the old value
06:34:57 <Asztal> or there's DiffArray :)
06:34:59 <copumpkin> pastah_rhymez: what makes mutability referentially opaque?
06:35:03 <pastah_rhymez> Asztal: deprecated
06:35:11 <Asztal> pastah_rhymez: nooooo :(
06:35:15 <Asztal> I liked it
06:35:33 <Veinor> ski: you mean that doesn't typecheck?
06:35:35 <copumpkin> I don't think it's actually deprecated is it? it's just way slower than it should be and nobody wants to fix it
06:35:37 <Veinor> hm
06:35:47 <Veinor> m . ab :: a -> m b
06:35:57 <ski> Veinor : i mean it looks like it probably doesn't hold
06:35:58 <Jedai> pastah_rhymez: Well you got state in your ST monad but if you explicit this state you still got referential transparency in the monad and the important part is that the ST action is externally referentially transparent
06:36:09 <Saizan> pastah_rhymez: the point is that reading from that array is an ST action
06:36:13 <Veinor> ski: ah
06:36:19 <pastah_rhymez> do { x <- mkSTArr [1,2,3]; y <- writeTo x 0 3; return (x==y) } -- True or False?
06:36:57 <ski> pastah_rhymez : that evaluates to `return True'
06:37:09 <copumpkin> pastah_rhymez: why would it be anything different?
06:37:27 <Jedai> pastah_rhymez: writeTo doesn't exist and if it dit it wouldn't return the array
06:37:34 <ski> (assuming s/mkSTArr/newSTArray/ and s/writeTo/writeSTArray/, iirc)
06:37:41 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14242#a14248 Jedai, ski
06:37:43 <copumpkin> Jedai: we get the idea of what his question was, regardless of the bad function names :P
06:37:47 <Veinor> ski: it works for List though
06:37:52 <ski> (well, scratch that, what Jedai said)
06:38:06 <Veinor> >> [1,2,3] >>= (return . (+1)) == fmap (+1) [1,2,3]
06:38:12 <Veinor> > [1,2,3] >>= (return . (+1)) == fmap (+1) [1,2,3]
06:38:13 <lambdabot>   Couldn't match expected type `a -> m a'
06:38:13 <lambdabot>         against inferred type `[a1]'
06:38:18 <Veinor> ... hm
06:38:25 <copumpkin> Veinor: fail
06:38:29 <Saizan> pastah_rhymez: you can't write (==) for ST arrays
06:38:31 <Jedai> pastah_rhymez: but even if it did, x and y aren't really array, they're two "names" pointing to the same array in the state the monad threads
06:38:36 <Veinor> > [1,2,3] >>= (return . (+1))
06:38:37 <lambdabot>   [2,3,4]
06:38:38 <pastah_rhymez> GADDAMN
06:38:41 <Saizan> pastah_rhymez: you can only write somthing that returns ST Bool
06:38:42 <pastah_rhymez> semantics, semantics
06:38:46 <Veinor> > fmap (+1) [1,2,3]
06:38:47 <lambdabot>   [2,3,4]
06:38:48 <ski> > let ma = [0]; m _ = []; ab = (^2) in (ma >>= (m . ab),fmap ab ma)  -- Veinor : refuted ! :)
06:38:49 <mietek> Is it possible and/or a good idea to include in a Cabal library package example programs showing the use of the library, which aren't intended to be installed anywhere during the install phase?
06:38:49 <lambdabot>   ([],[0])
06:38:57 <Saizan> pastah_rhymez: since you can only observe their contents monadically
06:39:02 <Jedai> pastah_rhymez: or rather they're the same name, so they should be equal
06:39:09 <Veinor> ski: well I was thinking _ = return
06:39:12 <Veinor> er, m = return :P
06:39:22 <copumpkin> pastah_rhymez: but anyway, the basic point is that the only referentially opaque thing about mutability is that _external_ changes can cause it
06:39:25 <ski> that's another thing, totally :)
06:39:30 <copumpkin> pastah_rhymez: the universal in the rank-2 type prevents that
06:39:33 <Veinor>  > let ma = [0]; m  = return; ab = (^2) in (ma >>= (m . ab),fmap ab ma)
06:39:40 <Veinor> > let ma = [0]; m  = return; ab = (^2) in (ma >>= (m . ab),fmap ab ma)
06:39:41 <lambdabot>   ([0],[0])
06:39:43 <ski> (that's the definition of `fmap' in terms of `(>>=)' and `return')
06:39:47 <Veinor> ah, okay
06:39:47 <dcoutts_> mietek: yes, either just chuck the sources in or add them to the .cabal file but with buildable: False
06:39:47 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
06:39:58 <Veinor> so that is true
06:39:58 <Saizan> copumpkin: also, that when we write "v <- readSTArray arr i" we don't intend it as an equation
06:40:02 <mietek> dcoutts_: aha, thanks.
06:40:24 <Jedai> HaskellLove: apart from the wrong syntax, it's the right idea
06:40:45 <Veinor> @unpl \ma ab -> ma >>= (return . ab)
06:40:45 <lambdabot> \ ma ab -> ma >>= \ c -> return (ab c)
06:40:47 <HaskellLove> can you please please fix it? if it is litle i dont want to waste you time...
06:40:54 <Veinor> whoops, got unpl and pl confused
06:40:57 <Veinor> @pl \ma ab -> ma >>= (return . ab)
06:40:58 <lambdabot> (. (return .)) . (>>=)
06:41:04 <pastah_rhymez> copumpkin: so how does it work? will runST make a copy of my "pure" array when it starts, do nastiness and then return the overwritten copied array
06:41:06 <pastah_rhymez> ?
06:41:14 <ski> HaskellLove : i suggest first using `where' instead of `let', it will look clearer
06:41:24 <Jedai> ski: he used where
06:41:24 <Veinor> @pl \ab ma -> ma >>= (return . ab)
06:41:24 <lambdabot> fmap
06:41:32 <copumpkin> pastah_rhymez: more or less
06:41:37 <Jedai> ski: he just put "let" on top of it
06:41:37 <Veinor> @pl \ab ma -> ma >>= (f . ab)
06:41:38 <lambdabot> (=<<) . (f .)
06:41:39 <copumpkin> :t runST
06:41:39 <lambdabot> forall a. (forall s. ST s a) -> a
06:41:46 <HaskellLove> ski this is the newest http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14242#a14248
06:41:49 <copumpkin> pastah_rhymez: that forall s. is the secret!
06:42:05 <copumpkin> pastah_rhymez: it prevents you from having an external STRef/STArray that you let in and query
06:42:09 <pastah_rhymez> copumpkin: yeah, i saw tha when i was looking in the documentation the other day
06:42:10 <ski> Jedai : `where <declaration> <expression>' is not valid (either)
06:42:18 <copumpkin> so the only state you can play with and mutate in that expression is stuff you defined inside it
06:42:23 <pastah_rhymez> can't i just return an STRef?
06:42:32 <copumpkin> pastah_rhymez: nope, because the STRef is over s
06:42:33 <pastah_rhymez> as last statement in my ST-function?
06:42:47 <copumpkin> it would complain that "s" escapes
06:42:50 <copumpkin> which is exactly what you want
06:42:56 <pastah_rhymez> hehe
06:42:59 <pastah_rhymez> nifty
06:43:10 <copumpkin> :t runST . return $ 5
06:43:11 <lambdabot>     Inferred type is less polymorphic than expected
06:43:11 <lambdabot>       Quantified type variable `s' escapes
06:43:11 <lambdabot>     In the second argument of `(.)', namely `return'
06:43:13 <copumpkin> like that error
06:43:18 <ski> HaskellLove : that looks much better !
06:43:20 <Veinor> ski: so does that mean that all Monads in a sense are also Functors?
06:43:21 <ski> HaskellLove : now try removing the `let' keywords so that you get rid of the syntax errors
06:43:27 <ski> Veinor : yes
06:43:29 <copumpkin> Veinor: by definition
06:43:31 <ski> all monads are functors
06:43:37 <Jedai> ski: no no, look at it again, he just wrote "<expression> where (let <declaration>)+"
06:43:41 <Veinor> cool
06:43:48 <copumpkin> Veinor: just the haskell standard library definition forgot that, somehow
06:43:59 <Veinor> and I look up a bit in the Prelude docs and I see what I figured out, heh
06:44:02 <copumpkin> Veinor: liftM === fmap unless something is seriously wrong
06:44:03 <Jedai> ski: oh ok, we were not speaking about the same iteration :)
06:44:23 <HaskellLove> Jedai, ski is this the end http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14242#a14250 :)
06:44:24 <ski> (Jedai : that's the last paste annotation, whose existence HaskellLove hadn't made known here, at the time of your comment :)
06:44:34 <pastah_rhymez> copumpkin: "Inferred type is less polymorphic than expected" <-- i've seen this before. nastyness
06:44:42 <copumpkin> it's excellent
06:45:01 <pastah_rhymez> copumpkin: ok, so what CAN you let escape from an STArr?
06:45:07 <copumpkin> pure values
06:45:10 <Jedai> ski: I probably got it because I clicked on its last link after he added it
06:45:15 <copumpkin> anything that doesn't involve the s universal type parameter
06:45:20 <pastah_rhymez> what? return 5 is filthy?
06:45:25 <ski> HaskellLove : and does it work now ?
06:45:34 <copumpkin> pastah_rhymez: return 5 isn't filthy
06:45:38 <copumpkin> > runST (return 5)
06:45:39 <lambdabot>   5
06:45:44 <copumpkin> > runST . return $ 5
06:45:45 <lambdabot>   Inferred type is less polymorphic than expected
06:45:45 <lambdabot>    Quantified type variable...
06:45:46 <HaskellLove> should it :) let me try it i expected crutiqes... let me try
06:45:46 * copumpkin whistles
06:46:00 <pastah_rhymez> gaddamit
06:46:12 * pastah_rhymez has hedd asploshun tiem
06:46:12 <copumpkin> pastah_rhymez: the problem is that (.) is a regular function
06:46:20 <pastah_rhymez> @type runST
06:46:21 <lambdabot> forall a. (forall s. ST s a) -> a
06:46:36 <copumpkin> and ($) is a regular function too
06:46:42 <pastah_rhymez> @type return :: ST
06:46:42 <copumpkin> @type runST . return
06:46:43 <lambdabot>     `ST' is not applied to enough type arguments
06:46:43 <lambdabot>     Expected kind `?', but `ST' has kind `* -> * -> *'
06:46:43 <lambdabot>     In an expression type signature:
06:46:43 <lambdabot>     Couldn't match expected type `forall s. ST s a'
06:46:44 <lambdabot>            against inferred type `m a1'
06:46:45 <lambdabot>       Expected type: a1 -> forall s. ST s a
06:46:50 <ski> @type runST . return
06:46:50 <lambdabot>     Couldn't match expected type `forall s. ST s a'
06:46:51 <lambdabot>            against inferred type `m a1'
06:46:51 <lambdabot>       Expected type: a1 -> forall s. ST s a
06:47:00 <ski> (.. eh)
06:47:38 <pastah_rhymez> copumpkin: i'll have to write an STGrid :)
06:47:53 <copumpkin> that's a terrible error
06:48:27 <copumpkin> pastah_rhymez: yeah :)
06:49:49 <pastah_rhymez> copumpkin: i'd love to sit here and get brainfucked all day but i need to leave :)
06:49:51 <pastah_rhymez> bbl
06:49:56 <copumpkin> pastah_rhymez: ciao :)
06:50:39 <ski> HaskellLove : .. well ?
06:51:03 <copumpkin> @type \x -> runST (return x)
06:51:04 <lambdabot> forall a. a -> a
06:51:19 <ski> @type \x -> return (runST x)
06:51:20 <lambdabot>     Inferred type is less polymorphic than expected
06:51:20 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
06:51:20 <lambdabot>         x :: ST s a (bound at <interactive>:1:1)
06:51:26 <copumpkin> lol
06:52:52 <ski> @type let f :: Monad m => (forall s. ST s a) -> m a; f x = return (runST x) in f  -- bah !
06:52:53 <lambdabot> forall a (m :: * -> *). (Monad m) => (forall s. ST s a) -> m a
07:01:00 <HaskellLove> hello?
07:01:05 <Jedai> HaskellLove: Did you get your answer ?
07:01:09 <mreh> hello?
07:01:14 <Jedai> If not, there is none
07:01:16 <HaskellLove> no freenode went crazy
07:01:26 <mreh> it's been like this for a while
07:01:33 <Zao> Silly script kiddehs.
07:01:33 <HaskellLove> Jedai will i have to write my own function for that?
07:01:34 <mreh> someone said there was a DDoS
07:01:45 <Jedai> HaskellLove: but in the particular case here it is really easy to do
07:02:02 <Jedai> HaskellLove: since all the equal elements are successive
07:02:09 <mreh> "If the United States found itself under a major cyberattack aimed at undermining the nation's critical information infrastructure, the Department of Defense is prepared, based on the authority of the President, to launch an actual bombing of an attack source or a cyber counterattack."
07:02:20 <Jedai> You should use group
07:02:33 <HaskellLove> yep so my parameter will be (x:y:xs) like... ok so i will write it i just wanted to know if there is already such funciton
07:02:35 <Jedai> > group [1,1,1,3,4,4,5]
07:02:35 <lambdabot>   [[1,1,1],[3],[4,4],[5]]
07:03:04 <HaskellLove> Jedai wow :D
07:03:30 <HaskellLove> > map length $ group [1,1,1,3,4,4,5]
07:03:30 <Jedai> HaskellLove: once you have used group to create a list of group of equal values, you can use map, length and head to translate it to a list of pair (element, frequency)
07:03:31 <lambdabot>   [3,1,2,1]
07:03:48 <Jedai> HaskellLove: in your case you only need the lengths though...
07:04:01 <HaskellLove> yep did it above ^
07:04:30 <pigdude> which ghc-related command will interpret its input (STDIN)? I figured runghc, but that is not working
07:04:50 <HaskellLove> runghc "/home/user/Desktop/a"
07:05:05 <HaskellLove> and for compile: ghc --make -O2 "/home/user/Desktop/a.hs"
07:05:09 <pigdude> HaskellLove, that is a command-line argument
07:05:28 <pigdude> HaskellLove, I'm referring to standard input though
07:06:08 <HaskellLove> well you take the result of getLine and do something with it in a function, if u mean that... otherwise sorry for missunderstanding i will leave..
07:06:34 <Jedai> HaskellLove: he means a command that takes the standard input and interpret it as Haskell code
07:07:01 <ski> HaskellLove : did `primeFactors' work ?
07:07:12 <HaskellLove> ok i am gonna stay out of it i have no idea about that sorry pigdude
07:07:20 <HaskellLove> ski yeah man :) i am close to finish euler12
07:07:40 <Jedai> pigdude: runghc --
07:07:44 <HaskellLove> ski thank you so much man you helped me so much thank you thank you
07:07:58 <ski> HaskellLove : as a closing touch to it, i suggest removing `primeFactors 0 = []' (or if you prefer, saying `primeFactors 0 = listOfAllPrimes')
07:08:21 <HaskellLove> ski, nah it is perfect like this :) with the zero case
07:08:29 <pigdude> Jedai, runghc -- < learning.hs prints the usage line
07:08:35 <ski> well, `2' is a prime factor of `0'
07:08:41 <ski> > 0 `mod` 2 == 0
07:08:42 <lambdabot>   True
07:08:54 <fasta> What does <interactive>:1:254: lexical error at character '\EOT' mean?
07:08:58 <Jedai> pigdude: no, you just use the command "runghc --" and it will compile the standard input
07:09:16 <ski> fasta : maybe that you have unmatching quotes or brackets ?
07:09:28 <pigdude> Jedai, I'm providing the contents of that file as standard input
07:09:28 <ski> (or nested comments, maybe)
07:09:36 <Jedai> HaskellLove: Your program won't use the zero case and it is mathematically incorrect to say 0 has no prime divisors so...
07:09:58 <pigdude> Jedai, more ham-handedly, % cat learning.hs | runghc --
07:10:03 <HaskellLove> Jedai i ignore it for simplicity, anyways how should it be done the right way?
07:10:18 <fasta> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14252#a14252
07:10:31 <fasta> ski: it is just taking the length of a large constant list.
07:10:51 <copumpkin> HaskellLove: as ski said, factors 0 = primes
07:10:51 <Jedai> pigdude: works here
07:11:21 <fasta> I think it is some Haskell mode suckage.
07:11:24 <pigdude> Jedai, I'm running the latest on my mac and it worked as expected. runghc does not seem to work with STDIN in the same way in my version. 6.8.2
07:11:28 <Jedai> HaskellLove: but if you're not going to do that, remove the 0 case altogether
07:11:38 <fasta> It works fine in my terminal.
07:11:39 <HaskellLove> copumpkin i dont get it man... what is primes then?
07:11:39 <copumpkin> HaskellLove: if you're allowing multiple instances of each factor in the resulting list, then there's not a good answer
07:11:49 <copumpkin> HaskellLove: a list of all prime numbers
07:12:02 <ski> fasta : i don't know, maybe that long line got truncated, somewhere ?
07:12:16 <Jedai> pigdude: very possible, runghc got no love, it works in 6.10.4 that's all I can tell you
07:12:16 <HaskellLove> copumpkin i am workin on it now
07:12:37 <pigdude> does anybody know of a way to parse standard input with some part of GHC 6.8.2?
07:12:39 <HaskellLove> copumpkin so if 0 give list of all primes? what do you mean? give an infinite list?
07:12:45 <fasta> ski, it was just middle mouse pasting, so that should not happen. I got my answer, but it is annoying that random things break all the time.
07:12:53 <pigdude> Jedai, thanks for your help
07:13:13 <copumpkin> HaskellLove: yeah, but if you allow multiple occurrences of factors, then I don't think there's a good answer. factors 24 = [2,2,2,3], then factors 0 = ?
07:13:27 <ski> (copumpkin : hm, good point)
07:13:44 <copumpkin> primes >>= repeat :P
07:13:49 <copumpkin> :)
07:14:06 <ski>   primeFactorization 0 = [(2,inf),(3,inf),(5,inf),...]  -- i suppose
07:14:23 <copumpkin> yeah, I guess that's one way of doing it, if you're using Natural for the exponent
07:14:31 <ski> aye
07:15:01 <copumpkin> or primeFactorization 0 = error "wtf dude, what r u on?"
07:15:08 <copumpkin> might be more in character
07:15:08 <Igloo> factors (0 :: Int) = replicate 64 2    :-)
07:15:18 <copumpkin> lol
07:15:42 <copumpkin> > (2 :: Int) ^ 64
07:15:42 <mietek> Is it possible to specify "buildable, but not installable" somehow for a Cabal executable?
07:15:42 <lambdabot>   0
07:15:47 <copumpkin> he's right!
07:15:58 <MoALTz> o_O
07:16:03 <dcoutts_> mietek: what would that mean?
07:16:05 <copumpkin> , (2 :: Int) ^ 64 -- same on a 32-bit machine!
07:16:07 <lunabot>  luna: parse error (possibly incorrect indentation)
07:16:15 <copumpkin> o.O
07:16:19 <copumpkin> , (2 :: Int) ^ 64
07:16:20 <lunabot>  0
07:16:25 <MoALTz> > (2 :: Int) ^ 65
07:16:26 <lambdabot>   0
07:16:35 <copumpkin> yeah, ignore that ;)
07:16:39 <MoALTz> oh. it hits 0
07:16:44 <copumpkin> it wraps :)
07:16:51 <MoALTz> and so everything else is zeroed
07:18:15 <mietek> dcoutts_: imagine a Makefile with an additional target that is not included in "all"
07:18:40 <mietek> dcoutts_: that's the way I've been doing things until now
07:19:23 <dcoutts_> mietek: right, the "Simple" cabal build system doesn't currently have the notion of targets like makefiles do, though it's an obvious thing to want to do
07:19:41 <mietek> dcoutts_: perhaps I should just make the executable a separate Cabal package.
07:20:10 <dcoutts_> mietek: what many people have done is used a flag to make the executable conditionally buildable
07:20:25 <dcoutts_> mietek: and that's probably better than ending up with loads of extra packages
07:21:55 <mietek> dcoutts_: you said to use "buildable: False".  Is there a way to overturn that without editing the cabal file?
07:21:58 <jkff> Hey! Any quick recommendations on cool recent articles?
07:22:16 <dcoutts_> mietek: as I said, if you make it conditional
07:22:34 <mietek> dcoutts_: ah, sorry, I just started using Cabal today
07:22:41 <dcoutts_> people mostly use that for test programs, but it would also work with demos
07:23:50 <mietek> Great!
07:24:01 <mietek> I'm having a problem building the test program, though.
07:26:33 <HaskellLove> here are two functions that get number of divisors of given number: there is new and old version... any newbies here might wanna check this out http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14253#a14253
07:27:04 <HaskellLove> did i mention the difference in speed :D
07:28:34 <Jedai> HaskellLove: It is easy to do better than the "new" version but I don't think it is possible to do worse than the "old"
07:28:42 <mietek> dcoutts_: the error happens on build; "<command line>: cannot satisfy -package-id portaudio-0.0
07:28:44 <copumpkin> HaskellLove: it can get faster
07:28:50 <copumpkin> oh Jedai just said that
07:28:59 <copumpkin> HaskellLove: you don't need to start from 2 every time
07:29:03 <Jedai> And I better say it fast since freenode seems to be pretty unstable right now
07:29:18 <copumpkin> I can't believe this is still happening after several days
07:29:25 <dcoutts_> mietek: what version of ghc and cabal?
07:29:55 <mietek> dcoutts_: ghc 6.12.1, with included cabal
07:30:12 <copumpkin> their news page first mentions the splits on december 8
07:30:34 <HaskellLove> copumpkin what change do you propose?
07:30:44 <copumpkin> HaskellLove: as I said, you don't need to start from 2 every time
07:30:49 <mietek> dcoutts_: http://varsztat.com/~desp/portaudio/ is the temporary location, until I get it to build nicely
07:30:54 <Jedai> mietek: 6.12.1 is the new new version of GHC, still fresh from the oven, a lot of packs are bound to be broken for some time yet
07:31:04 <dcoutts_> mietek: we'll need a lot more details, in particular output of ghc-pkg list and cabal configure -v3 and build -v3
07:31:15 <HaskellLove> copumpki yeah but i dont really see other way can you fix the code as you think please?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14253#a14253
07:31:34 <Jedai> mietek: if you want something more stable (though less bleeding edge), you should get the last version of the Haskell Platform with ghc 6.10.4
07:31:35 <mietek> Jedai: well, my package doesn't depend on anything but base
07:31:36 <mietek> Jedai: so this is more like a problem of me misusing cabal
07:32:01 <copumpkin> HaskellLove: I'm not going to do it for you. I gave the information you need :) instead of [2..] in getFirstDivisor, use a smarter starting point
07:32:02 * hackagebot upload: sox 0.1 - Play, write, read, convert audio signals using Sox (HenningThielemann)
07:32:04 * hackagebot upload: alsa 0.3 - Binding to the ALSA Library API. (HenningThielemann)
07:32:38 <Jedai> HaskellLove: you just need to keep track of what was your last starting point
07:32:38 <Jedai> mietek: it might be a problem of Cabal misusing you though
07:33:15 <Jedai> mietek: since this is also a brand new version of Cabal there might be a certain number of packages on hackage that do not build with it yet
07:33:25 <copumpkin> HaskellLove: also, this should only make a difference if the number is prime, but you don't need to go up to n. What's the largest possible factor of a number?
07:33:28 <copumpkin> *prime
07:33:35 <dcoutts_> Jedai: there are, but that's not the problem here I think
07:34:15 <mietek> dcoutts_: all you asked for: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14254
07:34:38 <HaskellLove> copumpkin there is largest factor? i thought they go to inifinity as natural numbers grow
07:34:52 <copumpkin> HaskellLove: say I give you 49
07:34:57 <copumpkin> HaskellLove: what's the largest possible factor?
07:35:08 <copumpkin> HaskellLove: ignoring for a moment that you know what the factor is
07:35:15 <mietek> Jedai: again, this does not involve any third-party packages from hackage
07:35:18 <HaskellLove> 49 squared?
07:35:22 <Jedai> copumpkin: I don't think that's quite right
07:36:05 <copumpkin> Jedai: hm
07:36:11 <Jedai> copumpkin: You mean to say "what's the largest first divisor greater than 1 but different from the number itself", no ?
07:36:17 <dcoutts_> mietek: it may well be that the new cabal feature to let executables depend on libs in the same package isn't working with ghc-6.12
07:36:28 <dcoutts_> mietek: I expect it'd work with 6.10
07:36:42 <copumpkin> Jedai: yeah
07:36:43 <Jedai> ok, my sentence lacks a possible and don't make sense all around either... but still
07:36:44 <dcoutts_> mietek: or don't rely on that feature
07:36:48 <mietek> Okay, let's downgrade.
07:36:55 <mietek> dcoutts_: how can I do that?
07:37:03 <mietek> (not relying)
07:37:25 <kakeman> hi :)
07:37:34 <dcoutts_> mietek: don't use build-depends: portaudio in the executable, just use the source files directly
07:37:35 <knobo`> zygoloid: The content is not so important yet. I'm just trying to understand the type system
07:38:06 <dcoutts_> mietek: you'd need to use hs-source-dirs: . examples
07:38:06 <knobo`> What changes would it take to make the /do/ compile and run?
07:38:20 <zygoloid> knobo`: what do you want it to do? what's the "test" for? what do you expect to happen?
07:38:45 <copumpkin> fucking hell
07:38:56 <zygoloid> knobo`: the failure is arising because you wrote: (State ...) "test", and (State ...) is not a function.
07:38:58 <mietek> dcoutts_: ah, that works great!
07:39:01 * copumpkin goes and does something else
07:39:20 <ski> > 2 `div` 2 :: Natural
07:39:21 <lambdabot>   1
07:39:24 <knobo`> zygoloid: I just don't understand what's going on. I have been reading and reading, and I don't understand it. So I'm doing some testing.
07:39:24 <ski> > 2 `mod` 2 :: Natural
07:39:25 <lambdabot>   0
07:39:27 <ski> > 2 `divMod` 2 :: (Natural,Natural)
07:39:27 <lambdabot>   * Exception: Natural: (-)
07:39:30 <ski> !
07:39:39 <copumpkin> wow
07:39:42 <knobo`> zygoloid: runState (State (\st -> ("yo", st))) "test" works
07:39:42 <mietek> dcoutts_: thanks for your help; hope to get this on hackage soon.
07:39:54 <mietek> I was motivated by today's Haskell MOD player.
07:40:16 <zygoloid> knobo`: that's because 'runState' is a function which takes two arguments.
07:40:33 <ski> do you remember who maintains `Natural' ?
07:40:41 <zygoloid> knobo`: put another way, that's (runState (State ...)) "test", and (runState (State ...)) /is/ a function
07:40:42 <copumpkin> ski: augustss I think
07:40:46 <copumpkin> @hackage numbers
07:40:46 <lambdabot> http://hackage.haskell.org/package/numbers
07:40:48 <mietek> Is Patai Gergely in here, by any chance?
07:41:23 <copumpkin> ski: weird though, it only defines div and Mod
07:41:34 <ski> > State (\st -> ("yo", st)) `runState` "test"
07:41:35 <lambdabot>   ("yo","test")
07:41:35 <copumpkin> and divMod is just defined as both of them
07:41:37 <HaskellLove> are firstTriangleNumberOver500Divs like long names hard on the compiler?
07:41:55 <copumpkin> HaskellLove: strangely enough, they used to be harmful, but not anymore
07:42:09 <copumpkin> HaskellLove: they're hard on your readers though
07:42:14 <HaskellLove> great i ussually right long ones
07:42:38 <copumpkin> @hackage PCLT
07:42:38 <lambdabot> http://hackage.haskell.org/package/PCLT
07:43:00 <copumpkin> http://snapplr.com/71xz
07:43:13 <ski> @hackage PCLSRing
07:43:13 <lambdabot> http://hackage.haskell.org/package/PCLSRing
07:43:33 <copumpkin> HaskellLove: in general, I'd avoid long names unless there's no other way to resolve ambiguity
07:44:18 <copumpkin> oh god, someone made another monad tutorial
07:44:22 <copumpkin> and actually did compare them to burritos
07:44:41 <EvanR-wo1k> lol
07:44:54 <Jedai> copumpkin: I quite liked it though
07:45:05 <Jedai> copumpkin: it was a meta-meta-tutorial
07:45:10 <copumpkin> :)
07:45:22 <EvanR-wo1k> long names are awful
07:45:24 <copumpkin> I quite like it, but it's amusing
07:45:48 <JohnDoe3651> Hi what is the difference between
07:45:50 <JohnDoe3651> myLength :: [a] -> Integer
07:45:50 <JohnDoe3651> myLength xs = len xs 0
07:45:50 <JohnDoe3651>     where len [] l = l
07:45:50 <JohnDoe3651>           len (x:xs) l = l `seq` len xs (l+1)
07:45:50 <JohnDoe3651> main = print $ myLength [1..10000000]
07:45:51 <copumpkin> byorgey must be proud
07:45:52 <JohnDoe3651> and
07:45:54 <EvanR-wo1k> i love haskells (x:xs) and x' <- f x stuff
07:45:56 <copumpkin> JohnDoe3651: don't paste in here
07:46:02 <copumpkin> @hpaste
07:46:02 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:46:07 <JohnDoe3651> ok
07:46:11 <copumpkin> :
07:46:11 <copumpkin> :)
07:46:24 <byorgey> copumpkin: not particularly ;)
07:46:33 <MoALTz> xxs@(x:xs) <- inits myList    is funnier
07:46:46 <byorgey> copumpkin: I know Mark, he's just being funny, I doubt he really intended it as a real monad tutorial =)
07:46:51 <copumpkin> "Finally, a monad must possess a join function that takes a ridiculous burrito of burritos and turns them into a regular burrito. Here the obvious join function is to remove the outer tortilla, then unwrap the inner burritos and transfer their fillings into the outer tortilla, and throw away the inner wrappings."
07:46:53 <copumpkin> I love that
07:47:59 <byorgey> it's actually not a terrible intuition as it goes.  The one problem with it is that it perpetuates the mistaken idea that a value of type 'm a' "contains" a single 'a'
07:48:14 <quicksilver> I think it's a fairly bad intuition.
07:48:19 <byorgey> hehe
07:48:20 <Jedai> byorgey: though as a monad tutorial it's much better than some of those that motivated the "monads are burritos" post in the first place :)
07:48:26 <byorgey> Jedai: true =)
07:48:31 <quicksilver> If you can unwrap the inner burritos and put the filling in the outer one
07:48:46 <quicksilver> then logically you can unwrapp the inner burritos and keep the filling
07:48:52 <byorgey> good point.
07:48:53 <quicksilver> which is exactly what you can't do.
07:48:56 <mietek> Unwrap your inner burrito.
07:49:09 <quicksilver> a good metaphor has to explain why "join" exists but "extract" does not.
07:49:11 <mietek> quicksilver: it's unsafe.  You're going to get messy.
07:49:15 <HaskellLove> ahahahah yeeeeeeeeeeeeees euler 12 solved oh man i am so going to sleep now... ski, Jedai, copumpkin i love u guys :)
07:49:17 <byorgey> well, anyway, I really don't think he actually intended it as a monad tutorial, just a funny observation
07:49:26 <quicksilver> unsafeness is an irrelevant distraction.
07:49:33 <quicksilver> it has nothing to do with the abstraction that monads are.
07:49:45 <quicksilver> byorgey: probably yes :)
07:49:55 <quicksilver> byorgey: don't let something small like the facts of the matter derail a good rant.
07:50:02 <byorgey> right, sorry =)
07:50:04 <Jedai> byorgey: looks like that but it makes me hungry.
07:50:06 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14258#a14258 Euler #12 time : not even a second :)
07:50:37 <EvanR-work> copumpkin: hey can you link me to the burrito tutorial i got lost in the flood
07:50:40 <byorgey> runBurrito :: Eatable a => Burrito a -> IO ()
07:52:20 <EvanR-work> assuming you havent netsplit
07:52:41 <copumpkin> EvanR-work: http://blog.plover.com/prog/burritos.html
07:53:20 <EvanR-work> awesome
07:53:24 <EvanR-work> now i will understand monads
07:54:45 <EvanR-work> 'the unit function for burritos is obviously a tortilla'
07:55:08 * hackagebot upload: storablevector 0.2.5 - Fast, packed, strict storable arrays with a list interface like ByteString (HenningThielemann)
07:56:07 <quicksilver> `/win 32
07:56:10 <quicksilver> :(
07:56:13 --- mode: quicksilver set -o quicksilver
07:57:08 <ziman> that's quite a number :)
07:58:22 <quicksilver> I only have 46 today
07:58:28 <quicksilver> closed some useless query windows.
07:58:56 <idnar> I have 42 at the moment
08:02:58 <HaskellLove_> hey dude why do you steal my name?
08:03:21 <quicksilver> that was you. But probably you're joking.
08:03:43 <HaskellLove> nah there was another guy same name so i loged in as HaskellLove_
08:04:10 <EvanR-work> freenode has a nick registration service
08:04:10 <osfameron> on which note, did it occur to you that coming onto a channel called #haskell and choosing a name that begins Haskell is a bit, um, odd? ;-P
08:04:10 <Jedai> HaskellLove: that was you
08:04:24 <HaskellLove> I was swearing myself ? cool :D
08:04:30 <Jedai> osfameron: no, he was ScalaLove when he first came here
08:04:35 <osfameron> ah
08:04:45 <HaskellLove> osfameron I am ninja man, be calm
08:05:01 <osfameron> ninjas.  calm.  two great tastes that taste great together.
08:05:47 * quicksilver dispatches a team of crack lambda pirates to take out HaskellLove.
08:06:06 <HaskellLove> hahahaha :D
08:06:16 <HaskellLove> thanks quicksilver	they almost got me
08:08:59 <copumpkin> HaskellLove: if you get disconnected, the server won't notice for a while. So when you reconnect, your old you will still appear to be connected
08:11:24 <quicksilver> in this instance, haskellove didn't get disconnected per se
08:11:31 <quicksilver> freenode forcibly moved him.
08:11:37 <copumpkin> oh, I wasn't paying attention
08:11:46 <quicksilver> I think, anyway.
08:11:52 <quicksilver> maybe I misread the global message :)
08:12:43 <copumpkin> ugh
08:14:32 <ski> @hoogle (a -> (b,c)) -> [a] -> ([b],[c])
08:14:33 <lambdabot> No results found
08:14:44 <dpratt711> I'm a bit vexed; Even after spending months learning Haskell, I still come across simple-looking things that I struggle to fully comprehend
08:14:53 <ski> @type (unzip .) . map
08:14:54 <lambdabot> forall a b a1. (a1 -> (a, b)) -> [a1] -> ([a], [b])
08:15:10 <copumpkin> ski: oh, that's nice
08:15:14 <copumpkin> dpratt711: like what?
08:15:15 <ski> @hoogle (a -> m (b,c)) -> [a] -> m ([b],[c])
08:15:15 <lambdabot> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
08:15:17 <dpratt711> this is a good example of what I mean: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5322#a5322
08:15:37 <ski> imo, if we have the latter, we should have the former
08:16:09 <dpratt711> I can poke at it and see what it does, but I find it difficult to reason about
08:16:43 <dpratt711> in fact, I think I have this problem with all non-trivial recursive functions
08:16:52 <copumpkin> :t (runIdentity .) . mapAndUnzipM . (Identity .)
08:16:52 <lambdabot> forall a b c. (a -> (b, c)) -> [a] -> ([b], [c])
08:16:56 <ski> dpratt711 : maybe write it with `do'-notation, instead ?
08:17:11 <dpratt711> in the middle of trying to figure out what a function is doing, I have to figure out what the function is doing
08:17:44 <dpratt711> ski: interesting idea; is there a canonical way to do that?
08:18:04 <tofulivin> preflex: xseen HaskellLove
08:18:04 <preflex>  HaskellLove was last seen on freenode/#haskell 11 minutes and 48 seconds ago, saying: thanks quicksilver	they almost got me
08:18:05 <copumpkin> @@ @redo @undo ([],x:xs) : [(x:ls,rs) | (ls,rs) <- split xs]
08:18:06 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
08:18:15 <copumpkin> hm
08:19:10 <ski>   split :: [a] -> [] ([a],[a])
08:19:14 <ski>   split [    ] = do return ([],[])
08:19:18 <ski>   split (x:xs) = do return ([],x:xs)
08:19:21 <ski>          `mplus` do (ls,rs) <- split xs
08:19:23 <ski>                     return (x:ls,rs)
08:19:29 <ski> is how i'd rewrite it
08:19:41 <dpratt711> ski: thanks; I shall ponder that
08:20:33 <dpratt711> I'm thinking there
08:20:37 <dpratt711> whoops
08:21:11 <dpratt711> I'm thinking there's some mental trick I need to learn to reason about non-trivial recursive functions
08:22:34 <dpratt711> for example, if I could somehow keep the whole definition in my head and imagine how it continuously unfolds
08:23:26 <mreh> :O
08:23:41 <ski> do you know any Prolog ?
08:23:51 <mreh> yes
08:24:13 <ski> dpratt711 : ^
08:24:22 <dpratt711> ski: no
08:24:45 <ski> hm, ok
08:25:11 <ski> well, think of the function as not being able to decide exactly what it wants to return
08:25:28 <ski> if the input is `[    ]', then it knows for sure that it wants to return `([],[])'
08:25:47 <dpratt711> ski: ok, following you so far
08:26:00 <mreh> what's the monad for passing a mutable object between functions?
08:26:02 <ski> is the input is `x:xs', then it knows it could either cut off before this element, so return `([],x:xs)', then
08:26:20 <ski> mreh : maybe you're after `State s' or `ST s' ?
08:26:27 <ski> s/is the/if the/
08:26:47 <dpratt711> ski: ok
08:27:18 * hackagebot upload: array 0.3.0.0 - Mutable and immutable arrays (IanLynagh)
08:27:19 <ski> alternatively, it could recursively split `xs' somewhere into `(ls,rs)', and then add `x' to the front of that, i.e. returning  `(x:ls,rs)'
08:27:26 <ski> that's what the function does
08:27:39 <zygoloid> mreh: if you just want one "mutable" value, then you probably want State s. if you want lots of "mutable" values (and updateable references to them) then you probably want ST.
08:28:05 <dpratt711> ski: ok, I sorta get that :-)
08:28:06 <mreh> I need to generate random numbers too, so I suppose I need StateT
08:28:18 * hackagebot upload: containers 0.3.0.0 - Assorted concrete container types (IanLynagh)
08:28:52 <Cale> mreh: You don't ever *need* StateT
08:28:52 <ski> dpratt711 : now first write `select :: [a] -> [] (a,[])' which nondeterministically selects out one element from a list (and also returns the rest of the elements)
08:29:22 * hackagebot upload: directory 1.0.1.0 - library for directory handling (IanLynagh)
08:29:23 <mreh> Cale: I understand that Monadic things can always be done in a pure way
08:29:28 <ski> dpratt711 : then use that to write `permute :: [a] -> [] [a]' that gives every possible way to permute a list
08:29:29 <zygoloid> ski: kind error!
08:29:43 <ski> @kind forall a. [a] -> [] (a,[])
08:29:44 <lambdabot>     `[]' is not applied to enough type arguments
08:29:44 <lambdabot>     Expected kind `*', but `[]' has kind `* -> *'
08:29:44 <lambdabot>     In the type `(a, [])'
08:29:47 <ski> er, yes
08:29:49 <Cale> mreh: Well, StateT itself is as pure as the underlying monad.
08:29:56 <ski> s/select :: [a] -> [] (a,[])/select :: [a] -> [] (a,[a])/, i meant
08:29:58 <ski> (sorry)
08:30:08 <mreh> I just need some abstraction to make this problem I am solving soluble
08:30:15 <mreh> that's what I see monads as
08:30:18 <Cale> mreh: (It's just a systematic way of using function parameters)
08:30:23 * hackagebot upload: extensible-exceptions 0.1.1.1 - Extensible exceptions (IanLynagh)
08:30:25 <mreh> right
08:31:16 <dpratt711> ski: not sure I know how to parse the signature of "select"...
08:31:25 <Cale> mreh: Okay, so what sort of thing are you doing? A conceptually-simple way of handling random number generation is just to pass around values of type StdGen
08:31:37 <ski> dpratt711 : `[] Foo' is the same as `[Foo]'
08:31:46 <dpratt711> is [] (a, []) the same as [(a,[a])] ?
08:31:56 <quicksilver> ski: sure but what's the unapplied [] inside the right of the tuple doing?
08:31:58 <dpratt711> ski: you're psychic, I see
08:32:01 <mreh> Cale: calling multiple functions that update a single GameState object in a non deterministic manner
08:32:05 <quicksilver> ski: first class types of kind *->* ?
08:32:12 <ski> dpratt711 : the first should be `[] (a, [a])', i made a typo, before
08:32:17 <quicksilver> ;)
08:32:21 <mreh> i.e. multiple functions are non-deterministic
08:32:23 * hackagebot upload: filepath 1.1.0.3 - Library for manipulating FilePath's in a cross platform way. (IanLynagh)
08:32:27 <fizruk> how does loop in ArrowLoop work?
08:32:37 <mreh> so I model the whole process as a non-deterministic one
08:32:44 <copumpkin> fizruk: it's like a doublefix
08:32:50 <copumpkin> fizruk: that passes the second component through unchanged
08:32:53 <Cale> mreh: By non-deterministic, do you mean randomised, or do you mean "generate all possibilities"?
08:32:58 <zygoloid> mreh: i suspect you want something like "State (GameState, StdGen)" or "StateT GameState (State StdGen)"
08:33:01 <jmcarthur> type classes don't do anything and don't work in any particular way
08:33:03 <mreh> Cale: randomised
08:33:03 <dpratt711> ski: you're also psychic in knowing that my example relates to permutations
08:33:08 <ski> quicksilver : it would be nice to be able to type `maybeToList :: [] -> Maybe' ;)
08:33:14 <fasta> How does one install Leksah on Ubuntu (6.10.4)? I already have a compatible gtk2hs installed. I get cabal errors http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14260#a14260
08:33:19 <ski> dpratt711 : hehe
08:33:30 * hackagebot upload: haskell98 1.0.1.1 - Compatibility with Haskell 98 (IanLynagh)
08:33:32 * hackagebot upload: hpc 0.5.0.4 - Code Coverage Library for Haskell (IanLynagh)
08:33:36 <mreh> stochastic
08:33:38 <mreh> that's the word
08:33:39 <Cale> mreh: Okay, then the Rand monad is probably appropriate.
08:34:09 <fizruk> copumpkin: what is, for example, loop id?
08:34:09 <ski> @hoogle StateT s0 (StateT s1 m) a -> StateT (s0,s1) m a
08:34:10 <lambdabot> Did you mean: StateT s0 (StateT s1 m s0) a -> StateT (s0, s1) m a /count=20
08:34:10 <lambdabot> No results found
08:34:11 <mreh> so should I compose that with a Monad transformer to abstract away the game state into a Monad?
08:34:13 <Cale> mreh: Model such a probabilistic function as a map  GameState -> Rand GameState
08:34:26 <dcoutts_> fasta: try regex-posix < 0.80
08:34:31 <Cale> (well, there's probably a StdGen parameter in there)
08:34:37 <jmcarthur> I think when people ask "how monads work" or "how arrows work" they are making assumptions about the nature of those ideas, namely that all implementations work the same.
08:34:52 <mreh> Cale: that's what I've done so far, (RandomGen g) => GState -> Rand g GState
08:35:01 <copumpkin> :t loop `asTypeIn` ($id)
08:35:02 <lambdabot> forall b d. ((b, d) -> (b, d)) -> b -> b
08:35:05 <mreh> but calling several of those functions is difficult
08:35:07 <ski> jmcarthur : the correct answer is obviously the respective laws ! :)
08:35:12 <Cale> mreh: right, that's good
08:35:17 <copumpkin> fizruk: that should be reasonably straightforward in that form
08:35:20 * ski grins
08:35:22 <Cale> mreh: So chaining those together is easy then.
08:35:31 * hackagebot upload: old-locale 1.0.0.2 - locale library (IanLynagh)
08:35:33 <Cale> mreh: Just use the <=< or >=> operator
08:35:39 <Cale> (Kleisli composition)
08:35:42 <mreh> i have to chain them together in the Rand monad
08:35:45 <jmcarthur> ski: i'm hesitant to agree with that, unless you intended it as a joke
08:35:48 <mreh> ooh, what's that
08:35:50 <Cale> :t (<=<)
08:35:51 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
08:35:52 <zygoloid> fizruk: loop id is an easy case, as it happens :) loop id = id
08:35:58 <ski> jmcarthur : both
08:36:00 <Cale> It's like (.), but monadic
08:36:04 <fizruk> copumpkin: i can't understand, what is that loop
08:36:04 <fasta> dcoutts_, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14260#a14261
08:36:05 <eugenn> @pl huboMesMejorDe listaIngresos listaEgresos numero = any (numero <) (zipWith (-) listaIngresos listaEgresos)
08:36:05 <lambdabot> huboMesMejorDe = (flip (any . (<)) .) . zipWith (-)
08:36:07 <zygoloid> fizruk: but that's the (->) Arrow, which is pretty simple :)
08:36:08 <mreh> Cale: excelent
08:36:33 <copumpkin> fizruk: do you understand fix?
08:36:34 <jmcarthur> ski: the laws don't explain how anything works either. they explain the assumptions you are allowed to make, and that's about it
08:36:36 <mreh> Cale: is there no syntactic sugar
08:36:38 * hackagebot upload: old-time 1.0.0.3 - Time library (IanLynagh)
08:36:44 <zygoloid> fizruk: the 'idea' of loop is that you take some structure which has an input value of type 'a' and an output value of type 'a', and connect them together without changing the structure
08:36:44 <Cale> For what?
08:36:49 <fizruk> copumpkin: what is fix?
08:36:52 <mreh> Monad composition
08:36:53 <ski> jmcarthur : yes. the laws explain all you can know, generally
08:37:03 <mreh> i don't suppose it needs it
08:37:13 <copumpkin> fizruk: you should try to understand fix before you try loop. fix :: (a -> a) -> a
08:37:18 <Cale> mreh: Well, <=< is already pretty nice-looking :)
08:37:25 <ski> (and the laws actually explain how you can factor things around in many ways)
08:37:25 <fizruk> zygoloid: where from that output comes for the first time?
08:37:29 <Twey> @src fix
08:37:29 <lambdabot> fix f = let x = f x in x
08:37:30 <jmcarthur> ski: I understand the tendency for newbies to dislike a citing of the laws when they are seeking help in understanding abstract ideas, though.
08:37:37 <mreh> Cale: doesn't it need an interface other than Monad, that wouldn't work with the IO monad
08:37:40 <ski> jmcarthur : agreed
08:37:43 <zygoloid> fizruk: that output comes from the output of the structure.
08:37:48 <Cale> mreh: It works just fine with the IO monad
08:37:52 <jmcarthur> ski: I'm not really sure where the best middle ground is.
08:37:53 <mreh> Cale: cool
08:37:56 <fizruk> fix - is fixed point of a function?
08:38:02 <Twey> Yes
08:38:16 <copumpkin> fizruk: yes, but it can't do magic
08:38:23 <Cale> mreh: (f <=< g) x = do y <- g x; f y
08:38:34 <ski> > (2 :: Natural) < fix succ
08:38:35 <lambdabot>   True
08:38:38 <Saizan> jmcarthur: start from useful consequences of the laws? or maybe motivation on combinator libraries first
08:38:38 * hackagebot upload: pretty 1.0.1.1 - Pretty-printing library (IanLynagh)
08:38:40 * hackagebot upload: process 1.0.1.2 - Process libraries (IanLynagh)
08:38:46 <RadioApeShot> So suppose you are in the IO monad, and you return an anonymous function which closes over some IO dependent value.
08:38:50 <RadioApeShot> Is this allowed?
08:38:51 <fizruk> h... how does it work? as one of fixed point generators from lambda theory?
08:38:52 <Saizan> s/on/of/
08:39:01 <Twey> RadioApeShot: Of course
08:39:03 <ski> RadioApeShot : yes
08:39:08 <quicksilver> copumpkin: yes it can. But only certain spells.
08:39:10 <zygoloid> fizruk: suppose my 'thing' takes a Char c and an Int n, and produces a String and an Int. let's say the produced String is c repeated n times, and the produced Int is fromEnum c.
08:39:12 <copumpkin> RadioApeShot: the anonymous function must be in IO too
08:39:23 <RadioApeShot> So it must also be used only in a do block.
08:39:26 <ski> @src fix
08:39:26 <lambdabot> fix f = let x = f x in x
08:39:27 <Cale> copumpkin: er, not quite
08:39:27 <ski> fizruk : ^
08:39:29 <RadioApeShot> That was what I was wondering about
08:39:31 <Twey> RadioApeShot: What?  No
08:39:40 * hackagebot upload: random 1.0.0.2 - random number library (IanLynagh)
08:39:40 <quicksilver> well arguably the *function* itself doesn't need to be in the IO monad
08:39:46 <copumpkin> well
08:39:46 <quicksilver> it just gets returned in it
08:39:48 <Twey> You can use IO without using a do-block
08:39:49 <copumpkin> it can be an IO action
08:39:52 <dcoutts_> fasta: hmm, odd, sadly I can't debug it right now
08:39:53 <zygoloid> fizruk: then  loop thing  will produce a structure which takes a Char c and produces a String, where the String is c repeated fromEnum c times.
08:39:59 <quicksilver> you can have an IO action of type "IO (Int -> Int)"
08:39:59 <RadioApeShot> Suppose it depends on something you read from a file
08:40:04 <Cale> RadioApeShot: It's possible to have an IO (String -> String), say, which produces a pure function as its result whose behaviour is dependent on IO
08:40:08 <Twey> And you can pass values from inside IO into a pure function that never needs to know they came from IO
08:40:09 <quicksilver> that returns a pure function, which can indeed close over values from IO
08:40:15 <Cale> RadioApeShot: (IO that has already happened)
08:40:15 <RadioApeShot> Like we have a function which opens a file, reads the first line into "line" and then returns a lambda which returns line
08:40:22 <Cale> Sure
08:40:25 <RadioApeShot> What is the type of that function, presuming it takes no arguments
08:40:28 <RadioApeShot> IO String?
08:40:32 <RadioApeShot> Or String
08:40:35 <fasta> dcoutts_, the best thing would be just to delete all references to Leksah from the whole Internet until it works. Most people don't agree with me on that, though.
08:40:36 <Twey> IO String
08:40:40 * hackagebot upload: syb 0.1.0.2 - Scrap Your Boilerplate (IanLynagh)
08:40:40 <Twey> (and therefore it's not a function)
08:40:42 <Cale> do xs <- readFile "foo"; return (\ys -> xs ++ ys)
08:40:44 <Cale> :t do xs <- readFile "foo"; return (\ys -> xs ++ ys)
08:40:45 <lambdabot> IO (String -> String)
08:40:47 <dcoutts_> fasta: heh :-)
08:40:50 <ski> (a function must always have type `... -> ...')
08:40:53 <fizruk> zygoloid: so, first time Int field is ignored?
08:41:11 <RadioApeShot> I see
08:41:16 <copumpkin> fizruk: it might help to look at some examples of how to represent recursion using fix
08:41:18 <Cale> RadioApeShot: It's an IO action which computes a function as its result
08:41:18 <zygoloid> fizruk: what 'first time'?
08:41:30 <Saizan> there aren't lambdas of no parameters in haskell, you just have values instead.
08:41:30 <Twey> :t fmap const getLine
08:41:31 <lambdabot> forall b. IO (b -> String)
08:41:43 <RadioApeShot> I guess where all of this is coming from is, what if you have some data you only load once, and it never chances throughout execution.
08:41:45 <copumpkin> fizruk: are you familiar with the recursive definition of fibonacci people throw around here all the time?
08:41:48 <Cale> RadioApeShot: Of course, you have to execute the IO action first in order to use the function which is its result.
08:41:49 <zygoloid> fizruk: loop doesn't do something multiple times, it connects an output of a block to the block's input.
08:41:51 <RadioApeShot> Just because you load it from a file you are stuck in the IO monad.
08:42:01 <Twey> RadioApeShot: You're *always* stuck in the IO monad.
08:42:01 <RadioApeShot> Is there some way to include data at compile time?
08:42:03 <Cale> RadioApeShot: Nah, you pass the data as a parameter to whatever needs it
08:42:06 <RadioApeShot> Sure
08:42:09 <RadioApeShot> Exactly.
08:42:15 <quicksilver> RadioApeShot: you're stuck in the IO monad but you aren't really.
08:42:20 <Twey> No matter what you do — you'll need to do IO at some point, so your whole program is in IO.
08:42:22 <RadioApeShot> But my instincts in this case is to close over the data
08:42:26 <quicksilver> RadioApeShot: "main" has to be in the IO monad anyway, so that doesn't matter.
08:42:28 <Twey> You can do pure things inside IO, though.
08:42:32 <RadioApeShot> So I have some functions which depend in an incidental way on background data
08:42:33 <quicksilver> RadioApeShot: the rest of your program can be a pure funciton
08:42:38 <fizruk> copumpkin: no, i'm new here
08:42:40 <RadioApeShot> I would declare them in a let block in Scheme
08:42:44 <quicksilver> and you can pass that pure function a value which comes from IO
08:42:50 <quicksilver> or simply close over such a value
08:42:50 <RadioApeShot> Where the data was loaded into variables which I loaded from files
08:42:56 <RadioApeShot> Then the interface is simple
08:42:56 <copumpkin> fizruk: fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- do you understand that?
08:43:22 <Cale> RadioApeShot: Well, you can do that, but the let must occur inside the IO block, and you'll end up passing around the functions rather than the data directly.
08:43:24 <Saizan> RadioApeShot: once you've done the loading you've a simple String or whatever that you can close over etc.. and use in pure code
08:43:31 <fizruk> copumpkin: yes
08:43:42 <Cale> RadioApeShot: One thing you might consider is packaging those functions up into a record which can act a bit like an object.
08:43:51 <copumpkin> fizruk: note how it refers to itself. That's what fix allows you to do, anonymously
08:43:51 <RadioApeShot> Yeah.
08:44:12 <copumpkin> fizruk: that definition above is equivalent to fix (\fibs = 0 : 1 : zipWith (+) fibs (tail fibs))
08:44:21 <copumpkin> > fix (\fibs = 0 : 1 : zipWith (+) fibs (tail fibs))
08:44:22 <lambdabot>   <no location info>: parse error on input `='
08:44:23 <RadioApeShot> I guess it just takes some getting used to, always having to recall who depends on IO
08:44:28 <copumpkin> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
08:44:29 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:44:34 <fizruk> copumpkin: i see :)
08:44:48 <copumpkin> fizruk: so instead of writing the recursion by hand, fix takes care of passing you to yourself
08:45:08 <Saizan> RadioApeShot: the type system tells you that :P
08:45:10 <Cale> RadioApeShot: Well, usually only things which really do I/O will be written in the IO monad. Other things will simply depend on (pure) parameters which come from doing some input at some point.
08:45:10 <copumpkin> fizruk: loop is the same idea, but in any arrow, and allows you to "pass something through"
08:45:24 <zygoloid> copumpkin: i don't think calling that recursion is helpful ;-)
08:45:35 <RadioApeShot> Right.
08:45:41 * hackagebot upload: base 4.2.0.0 - Basic libraries (IanLynagh)
08:45:44 <dpratt711> copumpkin: does this relate to the "Y" combinator I came across recently?
08:45:46 <Saizan> it is recursion though
08:45:48 <copumpkin> dpratt711: yeah
08:45:51 <Cale> zygoloid: What else could it be?
08:46:00 <zygoloid> sure. but value recursion is very different from traditional function recursion
08:46:00 <xerox> ?type loop
08:46:02 <RadioApeShot> But what that means is that anything that is not available at compile time ends up being IO dependent, even if it doesn't actually change through the course of execution.
08:46:02 <Cale> corecursion?
08:46:02 <RadioApeShot> It is just loaded once.
08:46:02 <copumpkin> zygoloid: it factors out recursion
08:46:02 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
08:46:07 <RadioApeShot> Its no big deal, really
08:46:09 <copumpkin> zygoloid: not really
08:46:11 <RadioApeShot> Just interesting.
08:46:32 <Saizan> http://www.vex.net/~trebla/haskell/fix.xhtml <- nice one :)
08:46:35 <Cale> RadioApeShot: hmm... well, it just gets an extra function parameter, rather than being IO dependent
08:46:52 <copumpkin> zygoloid: I can factor out recursion from fibs as easily as I can factor out recursion from nub, using fix
08:46:52 <ski> (dpratt711 : forgot to say, i used `[] Foo' here to high-light that you should think of values of this type as nondeterministically computing values of type `Foo')
08:47:07 <zygoloid> copumpkin: in order to really 'get' that fibonacci example, you need to understand that it's the /same/ data structure on which you're operating
08:47:18 <copumpkin> oh, definitely
08:47:18 <Cale> RadioApeShot: For example, if you had to load a dictionary from disk at some point, functions that need to use that dictionary don't need to be in IO, they just need to take it as a parameter.
08:47:29 <Cale> Dictionary -> ...
08:47:38 <copumpkin> zygoloid: but the function is not fundamentally any different, except it may not be fully applied yet
08:47:45 <dpratt711> copumpkin: ok; I'm no doubt mixing things up, but for some reason I thought that static typing was a problem for implementing that
08:47:48 * hackagebot upload: base 3.0.3.2 - Basic libraries (backwards-compatibility version) (IanLynagh)
08:47:50 * hackagebot upload: Win32 2.2.0.1 - A binding to part of the Win32 library (IanLynagh)
08:48:09 <copumpkin> dpratt711: it is a problem for implementing it in the exact same way you'd do it in LC, but we can do the equivalent
08:48:15 <copumpkin> within the constraints of the type system
08:48:17 <dpratt711> ski: interesting; thanks for the insight
08:48:20 <zygoloid> copumpkin: in function recursion, the fact that a function has a reference to itself isn't really the important part, it's the fact that it recursively invokes itself.
08:48:21 <Saizan> zygoloid: which is the same as understanding that the recursive call uses the same function you're defining, though that's not how it is usually presented, admittedly
08:48:29 <dpratt711> copumpkin: I see; thanks for clarifying
08:48:32 <Jedai> dpratt711: for implementing Y ? Yes, but we're not in the symply typed lambda calculus
08:48:40 <ski> `fix' is a Y combinator
08:48:47 <xerox> Saizan: indeed very nice :)
08:48:58 <Cale> RadioApeShot: At some point up near the top of main, you'll do some actual honest I/O to read the dictionary, and then pass that into the pure computations at which point you can forget that there's any dependence on IO.
08:49:01 <zygoloid> Saizan: no, traditional recursion is about /calling/ yourself, not merely having a reference to yourself. a function in C which takes its own address and stores it somewhere is /not/ recursive
08:49:03 <copumpkin> zygoloid: the only way it can invoke itself is by having a reference to itself. Both cases are using the fact that they have references to themselves, and that's what I'd call recursion
08:49:27 <Saizan> zygoloid: that's one way to explain it
08:49:39 <fizruk> ski: what is Y combinator?
08:49:47 <copumpkin> fizruk: something that does more or less what fix does
08:49:49 * hackagebot upload: template-haskell 2.4.0.0 -  (IanLynagh)
08:49:49 <mreh> can I do monadic things in record syntax, i am too lazy to find out myself
08:49:55 <Saizan> zygoloid: the other is that you're doing what you'd call "value recursion" on a functional value
08:49:59 <fizruk> copumpkin: :)
08:50:00 <copumpkin> mreh: what do you mean?
08:50:02 <Cale> mreh: yes?
08:50:06 <zygoloid> copumpkin: my point was merely: traditional (non-lazy, non-value-) recursion means something specific, and value recursion means something more general. distinguishing them (expaining that this is a generalization) is important
08:50:07 <Jedai> Saizan: I like to think about it like that though, in fact my thought process to get a recursive function is usually to think like I already have defined it and then to write it
08:50:11 <Saizan> zygoloid: which is the more domain theoretical one
08:50:11 <Cale> mreh: I'm not 100% sure what you mean either :)
08:50:32 <copumpkin> zygoloid: I guess :) I'm not sure I see the value in distinguishing them, though
08:50:42 <mreh> Cale, copumpkin: updating a record with do syntax inside the record syntax itself
08:50:45 <zygoloid> Saizan: i would be surprised if the dominant interpretation was that a function which takes its own address is "recursive".
08:50:49 * hackagebot upload: unix 2.4.0.0 - POSIX functionality (IanLynagh)
08:50:59 <Cale> mreh: Only if the record itself needs a value of that type.
08:51:01 <copumpkin> mreh: all you care about is expressions
08:51:06 <Saizan> Jedai: yeah, it's like trusting the inductive hypothesis
08:51:06 <mreh> do p' <- hyperspace
08:51:07 <mreh>                                   return s{ ship = (ship s){ p = p' } }
08:51:23 <mreh> I find this a bit excessive, could I compress it?
08:51:48 <mreh> okay, so no :(. fair enough
08:51:48 <Cale> That's an awful lot of space there :)
08:52:00 <mreh> my editor does funny things with tabs
08:52:10 <Cale> mreh: There shouldn't be any tabs in your file
08:52:11 <fizruk> copumpkin: as i understand, for (->) arrow (loop f) fixes one of inputs, so it is constant for each value of another input, am i right?
08:52:28 <mreh> Cale: actually, I just didn't copy all the whitespace to the left of the "do"
08:52:29 <copumpkin> mreh: if your type is traversable it should be possible
08:52:33 <Cale> ah
08:52:50 <copumpkin> mreh: but I'm not really sure what's going on in that code, so maybe it's irrelevant
08:52:57 * bos loves some haskell hackin'
08:52:57 <Cale> mreh: You could write functions for accessing and updating parts of the structure
08:53:14 <Saizan> zygoloid: oh, i didn't mean to imply that what you said about C was wrong
08:53:43 <Jedai> mreh: I think I see what you're doing and you should probably try to look up "functional references"
08:53:43 <mreh> Cale: i thought that's what the record syntax did for you
08:53:46 <Saizan> zygoloid: just that it's not the only view on recursion
08:53:57 <Cale> mreh: Yeah, but it's not first class.
08:54:18 <Jedai> mreh: record syntax is not really convenient for modifying deeply nested part of your datastructure
08:54:19 <ski> mreh : define `modShip' and write
08:54:21 <ski>   liftM ((modShip `flip` s) . const) hyperspace
08:54:43 * mreh brane asplode
08:54:47 <Cale> ski: flip?
08:54:55 <zygoloid> Saizan: :) I also didn't mean to imply that the (more general) notion of value recursion isn't a legitimate use of the word 'recursion', just that (especially to haskell beginners) we should be clear what we mean
08:55:16 <ski>   modShip :: (Ship -> Ship) -> (Whatever -> Whatever)
08:55:16 <copumpkin> I buy that :)
08:55:24 <ski>   s :: Whatever
08:55:36 <zygoloid> (and especially that the notion of function recursion which might have been learned elsewhere isn't a good way to view value recursion)
08:55:39 <bos> the problem with functional references is that there are too many implementations that all have peculiar warts
08:55:43 <ski>   modShip `flip` s :: (Ship -> Ship) -> Whatever
08:55:57 <ski>   (modShip `flip` s) . const :: Ship -> Whatever
08:55:58 <dpratt711> the recent discussion of monadic IO has brought to mind a question: I recall coming across some doc or tutorial that describes IO actions has having the type "World -> (a, World)", which makes some sense to me; Based on discussions here, I assume this is useful fiction? I also have the impression that at least some of you do not find it to be so "useful". Am I right and why is that?
08:56:17 <Saizan> zygoloid: though value recursion is how we define recursive functions too, so maybe it's a way to explain it :)
08:56:40 <copumpkin> dpratt711: no, it really works that way, but World doesn't contain anything. It's just to convince GHC to create data dependencies. But this is very GHC-specific
08:56:40 <bos> dpratt711: it's actually true in GHC, but the RealWorld part is fakery
08:56:42 <ski> dpratt711 : it is a useful fiction, imo
08:56:54 <Jedai> mreh: functional references would be better suited to your problem (see the "data-accessor" pack on hackage for instance)
08:56:58 <Botje> dpratt711: it only helps if you figured out State before
08:57:08 <mreh> does >=> have a fold variant?
08:57:09 <zygoloid> Saizan: where 'we' is those of us with a background in lambda calculus :) for some people, no definition is necessary, the name is simply in scope in the right place...
08:57:11 <gio123> ski: hi
08:57:21 <mreh> Jedai: cheers for the tip
08:57:27 <mreh> :t foldM
08:57:29 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:58:59 <mreh> @hoogle (Monad m) => (a -> a -> m a) -> [a] -> m a
08:59:03 <Saizan> zygoloid: i meant as a bridge to understand "non-functional value recursion", you could e.g. explain how fix (\fac -> \n -> if n == 0 then 1 else n * fac (n-1)) is defining factiorial as value recursion on a value of type Int -> Int, and then change the type
08:59:13 <Saizan> zygoloid: shifting the focus
08:59:46 <Saizan> which is kind of what the link above does
08:59:57 <zygoloid> there comes a point there where you have to explain that it's a single function, not a function which gets passed a function which gets passed a function which...
09:00:16 <zygoloid> and that's really i think the key part about lazy value recursion
09:00:32 <dpratt711> thanks bos, copumpkin, ski, Botje; one of the best features of Haskell has to be this community, where folks seem to jump at the chance to enlighten the ignorant
09:01:09 <mreh> \o/ hurray for #haskell!
09:01:22 <Saizan> yeah, and that's the same as "the name is simply in scope" you reference the same thing you're defining
09:01:47 * zygoloid nods
09:02:18 <dpratt711> Botje: fiction or otherwise, I found the definition helpful to reason about how the implementation of IO conforms to Haskell's notion of functions
09:02:43 <Botje> oh, sure
09:03:14 <Botje> once you get that monadic "values" represent computations, State is no longer a problem
09:04:07 <mreh> @src foldM
09:05:12 <JohnDoe3651> Can somebody tell me the difference in sematics between the tow fragments  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5321#a5321
09:05:17 <JohnDoe3651> two
09:05:59 <JohnDoe3651> the first solution is almost two times as fast as the second one
09:07:44 <mreh> @src ($!)
09:07:53 <mreh> damnit lambdabot
09:08:10 <c_wraith> $! is the same as $, except it seq's the argument
09:08:16 <c_wraith> so..
09:08:21 <ski>   f $! x = x `seq` f x
09:08:29 <c_wraith> yeah, that
09:08:42 <Jafet> Thunk
09:08:49 <ski> (and it should be left-associative)
09:08:49 <JohnDoe3651> i know
09:09:08 <JohnDoe3651> so i thought the tow fragments should behave the same
09:09:09 <quicksilver> hmm, one seqs l and one seqs l+1
09:09:09 <Botje> JohnDoe3651: you're evaluating l fully
09:09:13 <mreh> @seen lambdabot
09:09:14 <quicksilver> that shouldn't be a big difference I wouldn't thinkg
09:09:19 <Botje> JohnDoe3651: and then you're creating a thunk with l+1
09:09:24 <Botje> which you seq in the next call
09:09:43 <Botje> so the first creates and destroys 10000000 thunks
09:09:56 <Botje> whereas the second just runs in a constant space with a very tight loop.
09:10:14 <mreh> @src foldM
09:10:16 <quicksilver> Botje: he said the first one was faster.
09:10:30 <quicksilver> Botje: (they both run in constant space, anyway, it's just one uses a slightly larger constant)
09:10:46 <mreh> this bonkers
09:10:55 <JohnDoe3651> Botje: The first one, i.e. the fragment with seq runs almost double as fast
09:11:30 <Saizan> JohnDoe3651: compiling both with -O2?
09:12:01 <JohnDoe3651> no, without any switch .. is pathological anyway , but i'm learning and i thought both fragmetns are the same
09:12:14 <Jafet> Use monads!
09:12:15 <JohnDoe3651> while when it comes to runtime performace the're clearly not
09:12:35 <Jafet> They have the same semantics. They just have different runtimes.
09:12:48 <quicksilver> I can't explain why the first one is faster though.
09:13:03 <Botje> oh
09:13:09 <Botje> oops :)
09:13:17 <quicksilver> does GHC do any strictness analysis at all with optimisation off?
09:13:36 <Botje> no idea then
09:13:38 <Botje> << train
09:13:41 <Jafet> Shouldn't it be? Using seq to avoid thunking
09:14:08 <quicksilver> Jafet: the second one seqs all of (l+1) which also avoids thunking I'd think.
09:14:38 <quicksilver> the first one seqs the parameter when the function is called, the second one seqs it just before the recursive call
09:14:48 <quicksilver> doesn't seem like it should be a big difference.
09:14:53 <Jafet> Oh, didn't notice the $!
09:15:04 <Jafet> -fvia-c!!
09:15:25 <copumpkin> zomg
09:17:04 <Saizan> mh, i imagine it might be sligthly easier to spot that len is strict on l in the first case
09:19:23 <mreh> have we got any richtext literate haskell editors?
09:20:37 <dpratt711> OT: do folks here have an IRC client they would swear by? I'm using Pidgin, and there are certain things about it that I find annoying
09:20:48 <JohnDoe365> me too!
09:20:57 <JohnDoe365> loosing connections
09:21:33 <JohnDoe365> Jafet: btw. what do you mean by 'runtime' .. i meant with semantics not the final result but of course all the intermediate evaluations i.e. strict evaluation vs. lazy evaluation
09:21:33 <mreh> JohnDoe365: it's happening to everyone
09:21:38 <Zao> dpratt711: irssi, mostly by habit and convenience.
09:21:41 <dpratt711> JohnDoe365: losing connections recently? I see that happening to a lot of folks here; I suspect a freenode issue
09:21:49 <JohnDoe365> in that sense i meant the same semantics
09:21:51 <JohnDoe365> k
09:22:00 <Zao> dpratt711, JohnDoe365: Freenode is currently suffering from heavy denial of service attacks.
09:22:02 <Vulpyne> dpratt711: I like ScrollZ. It's pretty much like ircII.
09:22:34 <mreh> someone told me it was a DDoS, so i don't think it's just freenode
09:22:51 <mreh> they're after the root name servers
09:22:56 <dpratt711> who the heck would DOS freenode; people have too much free time on their hands
09:23:30 <quicksilver> dpratt711: irssi, obviously
09:23:31 <dpratt711> heh; make that DoS
09:23:37 <Zao> dpratt711: Get banned/klined, have a small botnet at your hands.
09:24:10 <harlekin> q
09:24:15 <Zao> dpratt711: It's why many shell providers explicitly forbid running IRC clients/servers; they're just too targeted by kiddies.
09:24:20 <harlekin> Woops. Sorry.
09:24:38 <Jafet> This is really going to inflate my logs
09:24:50 <defun> hi. I put "gnome-terminal" as my defualt terminal in xmonad.hs. Problem is, after I Mod-q, I still get xterm. xmonad --recompile shows no errors. Help?
09:25:11 <Jafet> It's a divine sign
09:25:12 <Jafet> Use xterm
09:25:20 <dpratt711> thanks for the IRC client advice, guys; I'll give those a look
09:25:26 <hugo> freenode is really bad :(
09:25:42 <EvanCarroll> @src groupBy
09:25:50 <defun> xterm doesn't wrap text, and I can't make the font size smaller.
09:25:59 <defun> any other ways to get "gnome-terminal" to work?
09:26:21 <EvanCarroll> =(
09:26:59 <fizruk> @src zip
09:26:59 <mrsolo> new ghc? woot!
09:27:16 <lambdabot> groupBy _  []       =  []
09:27:16 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:27:16 <lambdabot>     where (ys,zs) = span (eq x) xs
09:27:17 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
09:27:17 <lambdabot> zip _      _      = []
09:27:27 <fizruk> @src unzip
09:27:27 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
09:27:38 <dpratt711> anyone know Cale's home phone #? ;-)
09:27:51 <JohnDoe365> ask the bot
09:27:57 <JohnDoe365> ;)
09:29:24 <fizruk> why unzip has "~" there?
09:29:31 <xerox> to make the pattern matching lazy
09:29:48 <fizruk> why does it need lazy matching?
09:31:06 <xerox> let's see
09:31:31 <EvanCarroll> wow
09:32:02 * EvanCarroll doesn't understand groupBy
09:32:09 <EvanCarroll> I guess I'll just stare at it a bit
09:33:13 <fizruk> > (\(x:xs, _) -> x) $ unzip [(1, undefined), (undefined, undefined)]
09:33:42 <xerox> > join (***) (take 10) . unzip $ zip [1..] [1..]
09:34:07 <sproingie> i totally don't get the syntax \(a,b) ~(as,bs)
09:34:14 <xerox> sigh.
09:34:19 <sproingie> oh it's args
09:34:22 <xerox> , join (***) (take 10) . unzip $ zip [1..] [1..]
09:34:23 <lunabot>  luna: Not in scope: `***'
09:34:35 <xerox> , join (Control.Arrow.(***)) (take 10) . unzip $ zip [1..] [1..]
09:34:36 <lunabot>  luna: Not in scope: data constructor `Control.Arrow'
09:34:44 <xerox> I think the problem is infinite lists, anyway.
09:34:50 <fizruk> , (\(x:xs, _) -> x) $ unzip [(1, undefined), (undefined, undefined)]
09:34:51 <lunabot>  1
09:34:55 <fizruk> WOW!
09:35:44 <xerox> , (\(x:xs, _) -> x) . (foldr (\(a,b) (as,bs) -> (a:as, b:bs)) ([],[])) $ [(1, undefined), (undefined, undefined)]
09:35:45 <lunabot>  1
09:35:49 <xerox> that's not it
09:36:04 <quicksilver> I can't see why it needs it actually.
09:36:06 <fizruk> , (\(x:xs, _) -> x) $ (foldl (\(a, b) (as, bs) -> (a:as, b:bs)) ([], [])) [(1, undefined), (undefined, undefined)]
09:36:07 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = [t]
09:36:17 <doserj> , let unzip = foldr (\(a,b) (as,bs) -> (a:as,b:bs)) ([],[]) in head . fst . unzip $ (1,2):undefined
09:36:18 <lunabot>  luna: Prelude.undefined
09:36:28 <doserj> , head . fst . unzip $ (1,2):undefined
09:36:29 <lunabot>  1
09:37:35 <hugo> what is the opposite of init ?
09:37:44 <xerox> tail
09:38:26 <quicksilver> ah right
09:38:27 <fizruk> last?
09:38:28 <quicksilver> doserj++
09:39:13 <hugo> yes, kast
09:39:14 <hugo> last
09:39:16 <hugo> :)
09:53:47 <Saizan> , foldr (\(a,b) (as,bs) -> (a:as,b:bs)) ([],[]) (repeat (1,1))
09:53:56 <lunabot>  Stack space overflow: current size 8388608 bytes.
09:53:56 <lunabot>  Use `+RTS -Ksize' to increase it.
09:54:46 --- mode: irc.freenode.net set +o ChanServ
09:55:08 <ray> because the functor's on categories of types
09:55:10 <pchiusano> ray: I see, so the objects are types, not instances of those types
09:55:11 <ray> yeah, so constructor and fmap
09:55:14 <pchiusano> ray: thanks
09:56:37 <copumpkin> this is kind of ridiculous
09:56:40 <PepeSilv1a> is there a builtin command for clearing the screen?
09:56:49 <copumpkin> and #freenode has a +l, so there's no way to even ask anyone about an ETA
09:58:22 <Raynes> PepeSilv1a: /quit might work. ;)
09:58:31 <Zao> PepeSilv1a: Client specific. /clear works in some.
09:58:36 <PepeSilv1a> sorry I mean in haskell
09:58:44 <PepeSilv1a> eg. clear or cls
09:59:16 <EvanCarroll> interesting
09:59:25 <EvanCarroll> http://stackoverflow.com/questions/1316365/haskell-surprising-behavior-of-groupby
09:59:28 <lament> PepeSilv1a: there's no such command in any cross-platform environment
09:59:48 <EvanR-wo1k> what about in VT100 ;)
09:59:52 <lament> PepeSilv1a: there's simply no reliable way to do that
10:00:09 <EvanR-wo1k> print clear screen command code
10:00:19 <PepeSilv1a> lament, ok that makes sense actually
10:00:49 <lament> it makes sense but it still kinda sucks :)
10:01:07 <zygoloid> copumpkin: i doubt there /is/ an ETA; they're being DDoS'd :(
10:01:13 <copumpkin> it's a DDOS?
10:01:16 <Twey> We could do with a binding over common console-drawing libraries like conio and ncurses
10:01:26 <Twey> If you really want it, please write it ☺
10:01:28 <copumpkin> they had a notice on their news page saying there was connectivity trouble
10:01:29 <lament> yeah, there's hscurses
10:01:43 <lament> PepeSilv1a: have a look at hscurses
10:01:50 <PepeSilv1a> lament, thanks I will
10:01:51 <lament> it's kinda overkill if you just want to clear the screen
10:02:01 <lament> but it's good if you want to write a roguelike :)
10:02:03 <Twey> copumpkin: « we're still experiencing heavy ddos directed at a variety of locations where we have infrastructure hosted. »
10:02:09 <copumpkin> oh, okay
10:02:13 <PepeSilv1a> lament, yeah that's true, but if it's a good library it could be useful for other stuff
10:02:37 <zygoloid> EvanCarroll: groupBy requires the binary function argument to be an equivalence relation over the values in the provided list. if it's not, the Report does not specify its behaviour.
10:02:57 <PepeSilv1a> see ghci solution btw: http://hackage.haskell.org/trac/ghc/ticket/3062
10:03:23 <callen> @pl \x y -> x y
10:03:29 <lament> PepeSilv1a: eh, sure, you can do that
10:03:39 <callen> wait.
10:03:42 <zygoloid> EvanCarroll: "When the "By" function replaces an Eq context by a binary predicate, the predicate is assumed to define an equivalence"
10:03:42 <PepeSilv1a> bit hacky, but does the job
10:03:52 <lament> bit hacky?? it doesn't even support OS X
10:03:52 <callen> where's the bot?
10:03:58 <copumpkin> died in all the netsplitting
10:04:06 * callen curses
10:04:08 <callen> copumpkin: thanks.
10:05:20 <PepeSilv1a> anyway, I'll look into hscurses. Thanks!
10:05:38 * zygoloid used groupBy (/=) in a code golf entry once :)
10:07:19 <zandax> hello
10:09:25 <zandax> I am not a big Haskell programmer, but I am really interested in functional programming and I therefore I have a question about monads, which I understood well as far as I can tell
10:10:15 <zygoloid> zandax: ask away, we seldom bite ;-)
10:10:54 <Veinor> and when we do, it's not hard
10:10:56 <zandax> yeah thanks, usually I don't ask if I can ask questions, but I wanted to give a little info on my background : )
10:11:27 <zandax> I would like to write a pure random number generator (without IO refs) and somehow combine it with IO commands
10:11:40 <EvanCarroll> # ghci> groupBy (\x y -> (x > 0) == (y > 0)) values
10:11:41 <lunabot>  luna: parse error on input `|]'
10:11:47 <EvanCarroll> what is the x and the y getting set to in that
10:12:10 <EvanCarroll> it seems like it a parition that takes two elements rather than one.
10:12:12 <EvanCarroll> or something goofy
10:12:17 <zandax> to do things like this: "setup the random number generator -> start a recursive loop -> get two random numbers -> print some stuff on the screen -> loop"
10:13:01 <zygoloid> EvanCarroll: x and y will be elements of your list 'values'
10:13:19 <zandax> that would be easy to do in an imperative language, but I can't bend my bind to find a functional solution so far
10:13:38 <EvanCarroll> zygoloid: right, but what a window of two elements that get moved for each iteration?
10:13:44 <zygoloid> zandax: sounds like you want a monad transformer.
10:14:02 <EvanCarroll> # ghci> let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3]
10:14:03 <lunabot>  luna: parse error on input `|]'
10:14:05 <EvanCarroll> # ghci> groupBy (\x y -> (x > 0) == (y > 0)) values
10:14:06 <lunabot>  luna: parse error on input `|]'
10:14:06 <EvanCarroll> I don't understand that.
10:14:09 <EvanCarroll> # [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
10:14:09 <lunabot>  luna: parse error on input `|]'
10:15:03 <zygoloid> zandax: there's the RandT transformer in the MonadRandom package on hackage, see here: http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html
10:15:12 <EvanCarroll> oh wait, is it just creating new groups for each modification of those clauses
10:15:16 <EvanCarroll> maybe that would make sense.
10:15:17 <zygoloid> zandax: or you could roll your own with something like 'StateT StdGen IO'
10:15:38 <EvanCarroll> yep
10:15:40 <EvanCarroll> I got it,
10:15:53 <zandax> zygoloid: I thought about declaring a random numbers monad which is able to lift IO actions, but then I am afraid I would not be able to write the loop with tail recursion
10:17:02 <jmcarthur> zandax: tail recursion is overrated and often the exact opposite of what you want in haskell. i wouldn't worry about tail recursion explicitly
10:17:32 <jmcarthur> zandax: taking advantage of strictness and laziness is our tail recursion
10:17:50 <zygoloid> zandax: you shouldn't have any problems with stack overflow (if that's your concern). your monad should just basically be: data YourMonad a = YM (StdGen -> IO (a, StdGen)), which you can loop with in constant stack in the same way as you can in IO
10:17:57 <zandax> but how do I do an infinite loop which does not crash then? :/
10:18:15 <zandax> hm
10:19:00 <zygoloid> the essence here is that we're completely done with the left-hand side of the >>= when we start considering the right-hand side, so we don't need to remember any information or use up any stack space.
10:20:31 <zandax> okay, I'll give that a try, hopefully it works
10:20:52 <zandax> or I can make it work, better said
10:34:29 --- mode: irc.freenode.net set +o ChanServ
10:34:43 <Cale> zygoloid: The stack consists of case expressions, which case expressions are you talking about? The ones in the definition of >>= ?
10:34:43 <zygoloid> for instance, given "let f 0 = return 1; f n = do { x <- return 1; f (n-1) }", "f 1000000 :: IO Int" will execute to produce 1, whereas "f 1000000 :: [Int]" is likely to evaluate to a stack overflow
10:34:45 <sproingie> > let f 0 = return 1; f n = do { x <- return 1; f (n-1) } in f 1000000 :: [Int]
10:34:46 <sproingie> ENOLAMBDABOT
10:34:46 * zygoloid ponders how the reverse state monad fits into this :)
10:34:46 <EvanR-work> guess the bot was ddosed/netsplitted ;)
10:34:51 <zygoloid> i guess the risk there is building a really deep thunk for the state
10:34:53 <mercury^> zygoloid: why does the list version overflow while IO does not?
10:35:01 <sproingie> good old irc
10:35:01 <jmcarthur> *sigh*
10:35:02 <sproingie> aren't tree topologies great?
10:37:25 * Cale decides to kill the join and part messages in his IRC client.
10:38:39 * EnglishGent dispatches an army of terminators to kill the ddosers instead (control code written in Haskell of course)
10:42:56 * hackagebot upload: synthesizer-core 0.3 - Audio signal processing coded in Haskell: Low level part (HenningThielemann)
10:44:17 <hugo> how do i get rid of "Either" ?
10:44:40 <ray> :t either
10:44:58 <ray> either :: (a -> c) -> (b -> c) -> Either a b -> c
10:46:15 <callen> fml.
10:50:43 <bnijk_> if you get an error like
10:50:46 <bnijk_> "error parsing main"
10:50:51 <bnijk_> what are you supposed to do >:O
10:51:37 <|Jedai|> bnijk_: that seems a little bit... short. Don't you have a little bit more ?
10:51:49 <|Jedai|> An error position for instance
10:51:51 <mercury^> hugo: fanin.
10:52:09 <bnijk_> line 7
10:52:15 <bnijk_> which is "import Network.URI"
10:52:29 <|Jedai|> bnijk_: ok, could you show use the code
10:52:39 <bnijk_> 1 sec
10:52:44 <|Jedai|> essentially before and after this line
10:52:49 <|Jedai|> and don't paste it here
10:52:53 <|Jedai|> @where hpaste
10:52:57 <bnijk_> i know
10:52:59 <bnijk_> i'm already on hpaste...
10:54:11 * bnijk_ fiddles
10:54:18 <bnijk_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14263#a14263
10:54:26 <bnijk_> ox.hs:15:26: The last statement in a 'do' construct must be an expression
10:54:45 <bnijk_> there are probably a bunch of problems with the code...li took the downloadURL straight from RWH
10:54:58 <bnijk_> plus it's not even remotely complete
10:55:04 <|Jedai|> bnijk_: the main function is not properly indented
10:55:14 <bnijk_> oic
10:55:17 <bnijk_> how should i do it
10:55:26 <|Jedai|> the getTicker
10:55:28 <|Jedai|> neither
10:55:42 <|Jedai|> ok, the rules are the following :
10:55:49 * bnijk_ takes out a notepad
10:56:21 <|Jedai|> 1) "do, where, let, case ... of" starts a block
10:56:41 <Veinor> :D
10:56:51 <|Jedai|> 2) the position of the first token after the keywords determine the indentation of the block
10:57:02 * hackagebot upload: synthesizer-dimensional 0.4 - Audio signal processing with static physical dimensions (HenningThielemann)
10:57:14 <bnijk_> can you clarify that
10:57:38 <|Jedai|> so in "do stuff..." stuff is this first token and the block have an indentation equal to the number of character before the "s" of "stuff"
10:57:53 <sinelaw> PeakerWork, ?
10:58:12 <bnijk_> plus 2?
10:58:38 <|Jedai|> but to make clearer the beginning of the block you may go to a new line after the keyword, then you'll just have to count the number of spaces before your first token
10:59:03 <bnijk_> you mean a new line after "do"?
10:59:09 <|Jedai|> bnijk_: generally "do stuff" will be in a function definition so there will be character before it
10:59:21 <|Jedai|> bnijk_: Right, a new line after "do"
10:59:37 <|Jedai|> bnijk_: it's not an obligation, see what you prefer
10:59:43 <hugo> hmm
10:59:45 <bnijk_> i do prefer that
10:59:56 <hugo> hdbc-postgresql requires time-1.1.2 :(
10:59:57 <|Jedai|> bnijk_: absolutely avoid tabulations (the character) by the way
11:00:02 <bnijk_> :(
11:00:03 <hugo> and it kills my ghci
11:00:25 <Veinor> yeah, avoid the tab character
11:00:30 <zygoloid> Veinor: hyphens in identifiers?!
11:00:32 <|Jedai|> bnijk_: you can still use the key to indent your code, as long as your IDE transforms them in whitespaces
11:00:37 <bnijk_> right
11:00:41 <bnijk_> well no more vi then
11:00:44 <Veinor> a discussion on haskell-cafe
11:00:47 <bnijk_> i still get the same error though
11:00:51 <zygoloid> bnijk_: :set et
11:00:57 <|Jedai|> bnijk_: there's plenty of people that use vi for Haskell
11:01:06 * bnijk_ sets et
11:01:11 <mercury^> vi can transform tabs into spaces.
11:01:12 <|Jedai|> bnijk_: anyway, I still didn't say you all rules
11:01:18 <Veinor> @src ($!)
11:01:23 <bnijk_> i'm really looking for general "what's wrong with this code" advice
11:01:26 <Veinor> lambdabot nooooooo
11:01:30 <bnijk_> at the moment i expect it to download the thing at that URL and print it
11:01:32 <hugo> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=5324#a5324
11:01:36 <hugo> how can i fix that ?
11:01:46 <|Jedai|> bnijk_: 3) in a block each line beginning at the indentation level of the block starts a new statement
11:02:19 <|Jedai|> bnijk_: 4) if the line is indented more then it continues the statement before it in the block
11:02:38 <|Jedai|> bnijk_: 5) if the line is indented less then it _ends_ the block
11:02:52 <|Jedai|> bnijk_: and it's not part of the block
11:02:59 <bnijk_> so it's basically like python
11:03:05 <bnijk_> key word "basically"
11:03:10 <|Jedai|> bnijk_: and there you have your error in your first main function
11:03:18 <bnijk_> ok but i already fixed that
11:03:24 <bnijk_> "fixed", and it still gives me that error
11:03:40 <sproingie> it's not much like python
11:03:44 <|Jedai|> bnijk_: "putStrLn $ getTicker tickerUrl" should have been as indented as "args <- getArgs"
11:04:00 <bnijk_> and now it is
11:04:13 <sproingie> python just uses the indent to delimit blocks.  haskell wants things lined up
11:04:53 <bnijk_> this is my first haskell program by the way :D
11:05:09 <bnijk_> it'll be cooler when it works
11:05:59 <|Jedai|> bnijk_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14263#a14267
11:06:33 <|Jedai|> bnijk_: look at this, I can't say if it is correct in any other way but at least it's properly indented
11:06:34 <bnijk_> oic
11:07:55 <bnijk_> ok now i'm back to good old-fashioned type errors
11:08:16 <|Jedai|> bnijk_: Good luck with those :)
11:08:28 <bnijk_> i might be able to sort this one out
11:08:48 <mreh> why is linking so computationally hard?
11:09:09 <bnijk_> ok in the same code...why does downloadURL expect "Maybe A" while it infers "Either String String" from tickerUrl
11:09:11 <|Jedai|> bnijk_: getTicker is clearly not of the correct type
11:09:19 <bnijk_> i could have told you that |Jedai| ;)
11:10:08 <|Jedai|> bnijk_: since you try to putStrLn its result it should be a String, but the return Nothing imply that its result type is probably IO (Maybe ...)
11:10:41 <bnijk_> the return nothing is for HTTP errors
11:10:48 <bnijk_> wait...
11:10:51 <bnijk_> no
11:11:21 <bnijk_> ok so the question is
11:11:29 <|Jedai|> bnijk_: so what do you want to do ? print the webpage if you manage to download it ?
11:11:30 <bnijk_> how do i turn IO (Either String String) into String
11:11:33 <bnijk_> yes
11:11:33 <mreh> is there an alternative to --make that just compiles a version of my program that I can run with dynamic links?
11:11:44 <Twey> bnijk_: You don't
11:12:00 <|Jedai|> bnijk_: then basically your getTicker function should be correct, you don't need to putStrLn it
11:12:18 <bnijk_> oh geez
11:12:21 <bnijk_> i forgot i even putStrLn'ed it in getTicker
11:12:46 <|Jedai|> replace "putStrLn $ getTicker tickerUrl" by just "getTicker tickerUrl"
11:12:48 <Twey> You can turn it into an IO String with: fmap (either id id) value
11:13:05 <bnijk_> ok but then if i do that
11:13:06 <Twey> But you probably don't want to, because then you don't know if it's a success value or an error message
11:13:08 <|Jedai|> bnijk_: and just remove the "return Nothing" line
11:13:08 * hackagebot upload: synthesizer-alsa 0.1 - Control synthesizer effects via ALSA/MIDI (HenningThielemann)
11:13:16 <bnijk_> i still have it putStrLn'ing 'doc'
11:13:19 <bnijk_> which isn't right
11:13:28 <|Jedai|> bnijk_: why ?
11:13:37 <|Jedai|> bnijk_: is it not what you want to do ?
11:13:46 <bnijk_> why am i downloading tickerUrl twice...
11:14:12 <|Jedai|> Ah! you probably also want to remove the second downloadUrl line
11:14:19 <bnijk_> yes
11:14:22 <bnijk_> i did that
11:14:37 <bnijk_> i do want to putStrLn doc, right?
11:15:07 <|Jedai|> bnijk_: well if you want to, you want to, I couldn't tell you what you want to do though, I'm not you ! ;)
11:15:20 <bnijk_> i want to download the file and display it, at the moment
11:15:43 <|Jedai|> bnijk_: right, so do what we just discussed and it should work
11:15:49 <bnijk_> what, the fmap?
11:16:10 <|Jedai|> bnijk_: no, forget what Twey said for the moment
11:16:37 <|Jedai|> bnijk_: it may be interesting later on if you want to do something else with the doc
11:16:47 <bnijk_> (i do)
11:17:59 <bnijk_> ok this is what i have now
11:18:02 <bnijk_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14263#a14268
11:18:18 <|Jedai|> bnijk_: in fact what you want to do right now could be written "main = withSocketDo $ fmap (either id id) (dowloadUrl tickerUrl) >>= putStrLn"
11:18:19 * bnijk_ gets the flamethrower
11:19:04 <|Jedai|> bnijk_: right it should work like that
11:19:06 <b_jonas> @hoogle withSocketDo
11:19:07 <b_jonas> oh, no bot
11:19:19 * bnijk_ compiles
11:19:23 <|Jedai|> b_jonas: it's withSocketsDo anyway
11:19:37 <bnijk_> ok when i do ghc -o catbox catbox.hs
11:19:37 <|Jedai|> bnijk_: I mean with what you just posted
11:19:55 <b_jonas> withSocketsDo :: IO a -> IO a
11:20:06 <b_jonas> I see
11:20:11 <bnijk_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14263#a14269
11:20:13 <bnijk_> ^ i get that
11:20:41 <|Jedai|> bnijk_: use "ghc -o catbox -O2 --make catbox.hs"
11:20:44 <b_jonas> bnijk_: --make
11:20:50 <b_jonas> to include the network library
11:21:05 <b_jonas> and all the other necessary libraries too
11:21:09 <bnijk_> i see i see
11:21:09 <|Jedai|> bnijk_: "--make" will make it so that ghc automatically chase the correct dependencies
11:21:18 <bnijk_> it works!
11:21:23 <b_jonas> cool
11:21:31 <|Jedai|> bnijk_: generally you always want to put it there, it won't hurt anyway
11:22:02 <bnijk_> now this gets complicated
11:22:37 <bnijk_> now we get into HaXml territory...
11:22:58 <bnijk_> and ncurses....
11:25:25 <deech> Hi all, I have a server application written in Haskell. I was wondering about the feasibility of developing the UI portion as a Firefox extension. Has anyone done this before?
11:27:18 <bnijk_> deech: sounds painful
11:27:35 <bnijk_> but certainly possible
11:28:11 <chellomere> meh, hoogle appears to be broken
11:28:14 <deech> bnijk_: Why painful? I am doing this to make deployment easier.
11:28:17 <bnijk_> xpi's work mostly like an API to firefox...the question comes down to the format for the transmission of data
11:28:39 <bnijk_> painful compared to, say, a normal HTML UI
11:30:35 <bnijk_> of course i have no idea what the application is...
11:31:46 <bnijk_> http://www.cse.unsw.edu.au/~pls/PLS/PLS.html <-- are those ecstasy pills with lambdas on them
11:33:59 <callen> so.
11:34:09 <callen> I just got bitten in the arse by side effects in Python.
11:34:24 <callen> an immutable object that references mutable objects that can be destroyed is fun.
11:34:27 <callen> that is all.
11:34:30 <lament> hee
11:34:33 <callen> enjoy your vindication.
11:36:35 <Cale> callen: hehe
11:36:59 <b_jonas> wait, is lambdabot back?
11:37:00 <b_jonas> !bot
11:37:05 <b_jonas> @bot
11:37:05 <lunabot>  :o
11:37:13 <lambdabot> :)
11:37:27 <callen> Cale: Working in Django, request object which contains GET vars amongst other things, is supposed to be immutable. for some god unknown reason it contained list references which were destroyed by a looping pop()
11:37:32 <callen> good times, good times.
11:37:37 <Cale> > head (let f 0 = return 1; f n = return 1 >>= const (f (n-1)) in f 1000000)
11:38:09 <Cale> heh, ultraslow lambdabot :)
11:38:26 <Cale> Probably the joining of channels is taking longer than usual
11:38:44 <b_jonas> welcome back
11:39:07 <lambdabot>   * Exception: stack overflow
11:39:15 <Cale> > head (let f 0 = return 1; f n = return 1 >>= \x -> (f (n-1)) in f 1000000)
11:39:19 <lambdabot>   * Exception: stack overflow
11:39:20 <sproingie> callen: django is a trove of code horrors like that and worse
11:39:29 <bnijk_> django does suck
11:39:35 <Cale> Oh, interesting. Lambdabot is more consistent than ghci here :)
11:39:39 <callen> sproingie: it's not really that django is bad. it's just a quirk of the type system and mutability.
11:39:43 <callen> hasn't been an issue previously.
11:39:44 <callen> I mean
11:39:48 <sproingie> no it's really that django is bad
11:39:51 <Cale> (I get a stack overflow from only one of those in GHCi)
11:39:54 <callen> something that breaks for the first time in half a decade for me...*shrugs*
11:40:12 <callen> Django has its weaknesses, none of them are enough to deter me.
11:40:13 <sproingie> django is full of lots of weird "clever" bits
11:40:18 <nagnatron> Where could I find a nice introduction to lambda calculus?
11:40:18 <lambdabot> nagnatron: You have 1 new message. '/msg lambdabot @messages' to read it.
11:40:27 <callen> sproingie: I muck around in django core enough that its more of a strength than a weakness for me.
11:40:27 <jmelesky> sproingie: so is python itself
11:40:38 <sproingie> jmelesky: good point
11:40:46 <Cale> nagnatron: Wikipedia isn't *so* bad. How much of an introduction do you want?
11:41:27 <jmelesky> sproingie: it pays a price for being so intuitive at the shallow level. when you get deep, you run into weird hackish quirks all over
11:41:44 <sproingie> as an app, it's not so bad.  as an API it's all right as long as you don't dig too deep
11:41:46 <nagnatron> I'm not sure yet :) I'll go with wikipedia. Thanks.
11:42:21 <Cale> nagnatron: Lambda calculus is sort of a funny thing in that the basics of it are rather simple and for programming that's all you really need, but there are lots of theorems you can prove about various lambda calculi, and connections to all sorts of other things from category theory to formal logic.
11:42:47 <b_jonas> nagnatron: there's "http://www.madore.org/~david/programs/unlambda/", there's a Smullyan book that I keep hearing about but have never really seen, and there's "http://books.google.com/books?id=3TI6EYCxTmoC" though it's unlikely to be translated to English
11:42:52 <Cale> You hardly need to know anything about the lambda calculus to just use the notation for programming.
11:43:21 <Cale> But if you want to go a bit further, knowing how to represent any sort of data using lambda terms is nice.
11:43:25 <b_jonas> the last one speaks about lazy and strict evaluation, which is interesting and a bit hard to understand (to me)
11:43:32 <nagnatron> It gets mentioned often and it got me interested.
11:44:00 <Cale> So, you know algebraic datatypes in Haskell?
11:44:01 <nagnatron> b_jonas: Thanks i will check it out.
11:44:58 <nagnatron> Cale: Me? Not yet.
11:44:58 <Cale> Things like  data Nature = Rock | Stream Nature | Tree Nature Nature
11:45:03 <Cale> okay
11:45:21 <EvanR-work> Earth, Wind, Water, Fire, ... and Heart!
11:45:25 <Cale> hehe
11:45:51 <bnijk_> beautiful Cale
11:45:53 <Cale> So, that's a datatype whose members look like things such as  Tree (Stream (Stream Rock)) (Tree Rock Rock)
11:45:54 <b_jonas> Paper, [Scissor]
11:46:29 <bnijk_> Cale: http://everything2.com/title/there+were+no+words+left%253B+we+had+said+them+all
11:46:32 <Cale> nagnatron: Every value of type Nature is either Rock, or Stream x, where x is a Nature, or Tree x y, where x and y are Natures.
11:46:56 <Cale> nagnatron: Obviously, there are more useful datatypes you can imagine :)
11:47:02 <mee_> rock tress and streams of streams of rocks, oh my
11:47:20 <tass> So, let's say I got a string, and I want to, with the use of regex, take part of it and put it in a variable.
11:47:32 <Cale> You can represent natural numbers, lists, various sorts of trees, and all sorts of other things
11:47:50 <Cale> So, there's an easy way to encode any datatype of this sort using only lambdas
11:48:35 <tass> How would I go about it?
11:48:49 <nagnatron> Cale: It's a bit over my head right now, but thanks. It gives me a lot of food for reading:)
11:49:29 <EvanR-work> i suppose floating point numbers are just pairs of natural numbers with associated algorithms
11:49:58 <bnijk_> they're weird in binary EvanR-work
11:50:01 <tass> The string at hand -> ":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message"
11:50:20 <bos> wow. there's a huge regression in threaded concurrent app performance under 6.12.
11:50:25 <Cale> tass: I suppose you could use the Text.Regex library
11:50:29 <tass> And I want to regex say, the channel name "#shub" into one variable,
11:50:41 <tass> Cale: Well, what would the syntax be?
11:50:57 <EvanR-work> bnijk_: right, with the biased exponent and the understood 1 point. but representable 'in lambda' nontheless ;)
11:51:01 <tass> regexchan s =~ "PRIVMSG\s(.*)\s" didn't work
11:51:16 * EvanCarroll has graduated to chapter 8 of LYAH.
11:51:18 <tass> That's what I'd do in perl or PHP but..
11:51:35 <bnijk_> tass: i don't think it knows how to take in the argument
11:52:01 <tass> 's' would be the string
11:52:27 <bnijk_> yes
11:52:32 <bnijk_> you would have to do um
11:52:40 <doserj> > ":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message" =~ "#[a-z]*" :: String
11:52:41 <lambdabot>   "#shub"
11:52:58 <bnijk_> i'm not sure... "PRIVMSG" ++ s ++ "(.*)" ++ s
11:53:00 <bnijk_> ?
11:53:16 <bnijk_> nevermind
11:53:53 <tass> Ah.
11:53:53 <Cale> > ":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message" =~ "PRIVMSG\\s([^ ]*)\\s" :: [[String]]
11:53:53 <lambdabot>   [["PRIVMSG #shub ","#shub"]]
11:54:03 <bnijk_> double \ huh
11:54:22 <Cale> You want an actual \ in the string
11:54:23 <Cale> > "\s"
11:54:32 <lambdabot>   <no location info>:
11:54:32 <lambdabot>      lexical error in string/character literal at end o...
11:54:34 <Cale> > "\\s"
11:54:34 <lambdabot>   "\\s"
11:54:36 <Cale> > length "\\s"
11:54:38 <lambdabot>   2
11:54:43 <tass> Ah, didn't know that
11:56:09 <tass> On another regex note, how would I make a regex case insensitive?
11:56:12 <tass> In perl it's easy peasy
11:56:15 <tass> /regexpattern/i
11:56:20 <callen> how does one make a finite state machine in haskell?
11:56:27 <hugo> anyone here knows john goerzen ?
11:56:30 <hugo> does he hang around here ?
11:56:43 <EvanR-work> callen: you can do it with mutually recursive functions, if im not mistaken...
11:57:35 <Cale> tass: I believe you have to use makeRegexOpts and pass in compIgnoreCase for the compilation options
11:57:40 <Cale> tass: Personally, I just stay away from regular expressions altogether.
11:57:42 <bos> hugo: sometimes, as CosmicRay
11:57:45 <callen> EvanR-work: just curious. thanks. was wondering how you implemented regex in Hs.
11:57:52 <Cale> tass: Anything complicated enough to use regular expressions for is worth using a proper parsing library like parsec for.
11:57:52 <EvanR-work> callen: then simply call the 'initial state' function on the input stream
11:58:04 <callen> huh. neat.
11:58:18 <tass> Cale: Heh, I just kind grew fond of it when fiddling with perl
11:58:42 <Baughn> Cale: D'you think anyone would be particularily annoyed if I made haskell-indentation-mode dependent on a haskell program to work?
11:58:55 <Baughn> ..would seem odd
11:59:06 <Cale> Baughn: I don't know what you're referring to.
11:59:10 <Cale> Baughn: The emacs mode?
11:59:17 <Baughn> Riht
11:59:37 <Baughn> The current parser is a bit.. um. Yeah.
11:59:53 <Cale> Baughn: I haven't used emacs in quite a while, and was never really all that into it. I don't see what the problem with it would be.
12:00:42 <Lycurgus> Maybe user's just not into you
12:00:45 <Baughn> Cale: Me neither, but I bet someone would find a way to complain. Ah well.
12:00:46 <Cale> Baughn: Better than having to write programs in elisp.
12:00:47 * Baughn nods
12:00:50 <Baughn> Come to think of it, SLIME does something similar
12:00:56 <Cale> elisp made the mistake of dynamic scope, and emacs is still paying for it.
12:02:27 <Lycurgus> since we're off topic, may I ask again if anyone uses AccessGrid, or the UCL rat program?
12:04:53 <Lycurgus> (misclick)
12:04:59 <zygoloid> we're off topic? ok! what sort of jam do people like with rice pudding?
12:05:04 <absentia> what's the one sentence summary of what's wrong with dynamic scope?
12:05:21 <zygoloid> absentia: spooky action at a distance
12:05:32 <edwardk> zygoloid: jam with pudding? strange strange man
12:05:32 <absentia> heisenbugs?
12:05:40 <Baughn> absentia: Heisenbugs with jam and cream.
12:05:58 <EvanR-work> there aint no such thing as a free lunch
12:06:07 <absentia> does it even matter if your data is not mutable?
12:06:31 <Cale> absentia: yeah, it breaks the function abstraction -- functions depend not only on their parameters, but can magically do different things depending on the values of certain variables which might be in scope.
12:06:35 <Baughn> absentia: Dynamic scope means not being able to check whether the binding you name is in scope
12:06:53 <Baughn> Because that depends on the caller
12:06:55 <zygoloid> absentia: if you want a one-word answer, i'd say 'noncomposability'
12:07:32 <absentia> ok, that makes sense.
12:07:37 <Baughn> There are certain objects for which dynamic scope makes sense.
12:07:41 <Baughn> Like stdin, or stdout.
12:07:42 <Cale> So how you name the local variables you use can change the behaviour of functions that you call
12:07:54 <Cale> which is obviously stupid
12:08:10 <zygoloid> absentia: dynamic scope means everything's a global, but you can't easily tell /which/ global ;-)
12:08:14 <Baughn> Common Lisp gets it to work by having a convention that all dynamic variables are named *like-this*
12:08:26 <Baughn> ..that, and the module system.
12:08:34 <Baughn> But having it /by default/ is just plainly stupid
12:10:09 <Jedai> callen: you can also build an algebraic data structure
12:10:09 <Jedai> callen: to represent the FSM
12:10:12 <Jedai> the advantage is that you can do manipulation on that to simplify or even modify the FSM
12:10:21 <p_l> Baughn: SLIME does indentation etc. like typical elisp code. There's Semantic which implements a proper parser iirc. And Climacs, which simply has a full-blown parser running
12:10:32 <lament> modify Him?
12:10:46 <Baughn> p_l: I dare say SLIME's indentation is considerably /easier to handle/ than haskell's. :P
12:12:25 <absentia> so, thinking back to SICP.. that *env on each function call is alive and well.
12:12:27 <sinelaw> what's the difference again between data and type?
12:12:33 <p_l> Baughn: sure. That's why I talked about semantic (I don't have anything against Haskell program running in background except for certain issues with bootstrapping it might cause...)
12:12:56 <Baughn> p_l: Issues? Please expand.
12:13:14 <Cale> sinelaw: data introduces a new datatype, type just gives a new name to an existing type
12:13:36 <sinelaw> oh right. and newtype vs. data is lifted/nonlifted bottom?
12:13:40 <p_l> Baughn: I might want to write Haskell code without available working haskell implementation
12:13:43 <p_l> (happens to me)
12:13:51 <Cale> sinelaw: and for completeness' sake, newtype creates a new datatype which is isomorphic to an existing type
12:13:52 <EnglishGent> those are dreadful names btw - why not call them 'newtype' (to introduce a new type) & 'alias' (to provide an alias) ?
12:14:01 <Baughn> p_l: Ah. Well, then you can use one of the /three other/ indentation modes, which are all pure elisp. :P
12:14:21 <sinelaw> Cale, ok, memory cells beginning to work here
12:14:23 * EnglishGent is sure he wasnt the only student who found that confusing
12:14:24 <YuleAthas> I would be really happy if haskell-mode could do prettifying.
12:14:25 <Cale> I think data is an okay name, though 'type' is a bit funny.
12:14:56 <sinelaw> Cale, typedef would have been nice simply because everybody would immediately guess what it does
12:15:10 <sinelaw> Cale, but ugly otherwise
12:15:10 <medfly> but it is SEVEN LETTERS
12:15:13 <Baughn> YuleAthas: That's part of the plan. Basically, make a partial parser, then have reindentation work by sucking it up and spitting it back out, discarding the indentation info.
12:15:40 <sinelaw> medfly, you should know that seven is a holy number
12:15:41 <YuleAthas> Baughn: why a partial parser?  Or do you just say "partial" because some things are never going to be important?
12:16:03 <medfly> sinelaw: hey, your nick's length is seven letters.
12:16:09 <Baughn> YuleAthas: I meant "partial" in the sense that it can parse program fragments and broken code
12:16:16 <YuleAthas> Oh, right.
12:16:16 <sinelaw> medfly, hah, never noticed that before
12:16:21 <Baughn> Or at least make a good try
12:16:26 <YuleAthas> Are you going to write it in Elisp?
12:16:30 <Baughn> No way in hell.
12:16:33 <YuleAthas> Good!
12:16:38 <Baughn> That's been tried three times already.
12:17:29 <Baughn> YuleAthas: Anyway, a haskell editor should be able to assume the existence of a working haskell compiler!
12:18:01 <b_jonas> Baughn: assume only as much that it doesn't freeze/crash emacs and lose your documents if haskell isn't working for some reason.
12:18:29 <YuleAthas> Why would it need to assume the presence of a Haskell *compiler*?
12:18:45 <sinelaw> medfly, six is nature, seven is perfection and supernatural
12:18:54 <medfly> !!
12:19:07 <EvanR-work> hes hitting on you
12:19:09 <medfly> but four is "reasonable length for a common function"
12:19:12 <YuleAthas> Wouldn't it be simpler to write a standalone program that parses Haskell and outputs a prettified version of the input?
12:19:19 <DigitalKiwi> http://codepad.org/5rzYZik4 can anyone help me make this better? I have a version in lua which is only slower by like a hundredth of a second, as much as I like lua and wish that it would be faster than everything else, this just seems wrong >.>
12:19:25 <sinelaw> or shall I say....medflai?
12:19:39 <medfly> YuleAthas: there's something wrong with your Haskell if your code isn't pretty already
12:19:41 <Baughn> YuleAthas: Said "standalone program" is overwhelmingly likely to end up using the GHCi API.
12:19:43 <jmcarthur> YuleAthas: simpler than using an existing tool like a compiler?
12:19:43 <medfly> (what are you talking about?)
12:22:41 <b_jonas> four what?
12:23:07 <medfly> letters
12:23:46 <sinelaw> it's also the number of perceivable dimensions
12:23:53 <sinelaw> (at least in my case)
12:24:09 <Twey> Well… three and a half :þ
12:24:13 <medfly> half?
12:24:15 <bos> is it possible to edit the description of a bug in GHC trac?
12:24:19 <medfly> what's half a dimension? :-p
12:24:30 <Twey> One in which you can only observe movement in one direction
12:24:41 <EvanR-work> fractal self similarity dimensions ;)
12:24:42 <bos> preflex: seen JaffaCake
12:24:43 <preflex>  JaffaCake was last seen on #ghc 1 day, 9 hours, 9 minutes and 28 seconds ago, saying: mmorrow: 404
12:27:04 <sinelaw> preflex, seen Peaker
12:27:04 <preflex>  Peaker was last seen on #haskell 20 hours, 48 minutes and 52 seconds ago, saying: probably inaccurate
12:27:05 <sinelaw> preflex, seen PeakerWork
12:27:05 <preflex>  PeakerWork was last seen on #haskell-blah 1 day, 1 hour, 3 minutes and 46 seconds ago, saying: Veinor: e.g: what ZFS does
12:27:17 <sinelaw> ZFS?!
12:27:29 <sinelaw> oh, not ZFC
12:27:57 <HaskellLove> can somehow give me directions for this problem http://projecteuler.net/index.php?section=problems&id=20
12:29:01 <blueonyx> hey, is there some typeclass for `in some meaning equal`? i have already used Eq because this makes also sense :/
12:30:24 <sinelaw> blueonyx, what?
12:30:53 <b_jonas> blueonyx: you could make a wrapper type and give it an Eq instance, that works well because then you can use Eq-based functions
12:31:08 <blueonyx> i got a list of graphs and some Doubles, the instance of Eq means, the graphs in the list are isomorph and the Doubles are Eq, but sometimes i want to say a some values of this type are equal when the graphs are isomorphic and the Doubles dont matter
12:31:15 <blueonyx> ah yea
12:31:20 <Twey> blueonyx: Most comparing functions allow you to specify a comparison function, though (see ‘on’, ‘comparing’)
12:31:42 <blueonyx> Twey: yea, i know, but this is not my problem :)
12:32:02 <blueonyx> maybe there is some typeclass for === instead of just ==?
12:32:09 <Twey> Whose problem is it, then?
12:32:19 <Twey> Well, you could certainly write one if you liked.
12:32:30 <medfly> ??
12:33:12 <blueonyx> okay thanks
12:33:32 <b_jonas> or you could just use a wrapper type that would wrap graphs and use this other equality
12:33:35 <dogmaT> HaskellLove Have you tried to define factorial? Even simple definition should be fast enough.
12:33:53 <b_jonas> whichever is more practical for you
12:34:07 <HaskellLove> dogmaT oops sorry i meant problem 15 not 20, 20 is easy :)
12:34:36 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=15
12:34:59 <b_jonas> no, it's problem 15 that's easy
12:35:13 <knobo> Does Haskell have something like Lisps format?
12:35:27 <Twey> Not yet
12:35:36 <Twey> Would you like to write it?  ☺
12:35:40 <knobo> :)
12:35:44 <Twey> Well, that said
12:35:48 <EvanR-work> should be that hard ;)
12:35:50 <EvanR-work> shouldnt
12:36:02 <mauke> knobo: well, there's printf
12:36:02 <knobo> I'll learn Haskell first. Then I'll do it.
12:36:11 <b_jonas> haskellers don't like string representation of regexen, why'd they use something like format?
12:36:18 <Twey> We have some pretty-printing libraries.  There is an argument to be made for using functions/data-types to specify formatting algorithms rather than strings.
12:36:20 <mauke> a lot less powerful than format, but we have \n
12:36:25 <Twey> Yeah, indeed
12:36:28 <sinelaw> @hoogle \f g a b -> f (g a b) b
12:36:29 <lambdabot> Parse error:
12:36:29 <lambdabot>   --count=20 "\f g a b -> f (g a b) b"
12:36:29 <lambdabot>              ^
12:36:30 <b_jonas> but then it's certainly possible it write something like it
12:36:36 <sinelaw> @pl \f g a b -> f (g a b) b
12:36:37 <lambdabot> flip flip id . ((flip . (ap .)) .) . (.) . (.)
12:36:48 <tass> The Pixies - Where Is My Mind <3
12:37:22 <sinelaw> @type \f g a b -> f (g a b) b
12:37:24 <lambdabot> forall t t1 t2 t3. (t2 -> t1 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t3
12:37:33 <sinelaw> @hoogle  (t2 -> t1 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t3
12:37:34 <lambdabot> No results found
12:37:38 <sinelaw> @djinn  (t2 -> t1 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t3
12:37:39 <lambdabot> f a b c d = a (b c d) d
12:37:58 * sinelaw gives up
12:38:11 <sinelaw> @type liftA2
12:38:13 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:38:22 <sinelaw> @src liftA2
12:38:22 <lambdabot> liftA2 f a b = f <$> a <*> b
12:38:24 <knobo> What is the most used way of formating functions that uses do? f x = do \n... or f x = \n do ?
12:38:36 <knobo> If you get what I mean.
12:38:55 <Jedai> knobo: not really
12:39:04 <Kim^Walkman> Coding conventions I believe
12:39:17 <Kim^Walkman> Wether or not to start coding on the same line as do, or the line following
12:39:40 <Twey> knobo: The former
12:39:41 <knobo> maybe this one: http://urchin.earth.li/~ian/style/haskell.html
12:39:44 <Jedai> knobo: oh, \n as newline ok. there is no consensus
12:39:53 <mauke> knobo: I always start a new line after do
12:39:54 <Twey> The ‘do’ is always on the same line as the function definition
12:40:17 <Twey> Some people like to start a new line immediately after it, and some like to carry on for one statement on that line and then line up following statements underneath
12:40:55 <HaskellLove> b_jonas can you tell me why is it that easy? by the way i just solved problem 20 it is stupid easy
12:41:11 <knobo> I have to make good habbits from the start :)
12:42:06 <Twey> > product [2 .. 100]
12:42:08 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
12:42:11 <Twey> Done :þ
12:42:40 <b_jonas> HaskellLove: on problem 15? I could give a hint but it might spoil your joy of independently finding the easy solution
12:42:55 <b_jonas> should I private you with it?
12:43:52 <blueonyx> @type (===)
12:43:53 <lambdabot> Not in scope: `==='
12:43:59 <Taejo_> all this talk of burritos is making me hungry! wish $ (taejo =<< burrito)
12:44:11 <b_jonas> heh
12:45:32 <Taejo_> not sure about the extraneous brackets
12:45:46 <Taejo_> wish $ taejo =<< burrito
12:45:53 * Taejo_ =<< burrito
12:45:56 <EvanR-work> better safe than retype ;)
12:46:44 <EvanR-work> :t Taejo_
12:46:46 <lambdabot> Not in scope: data constructor `Taejo_'
12:48:00 <holmak> ha, someone should define all users as filehandles in lambdabot
12:48:23 <holmak> so you can > hPutStrLn holmak "private message!"
12:48:42 <EvanR-work> hClose holmak
12:48:48 <holmak> I have no *bzzzt*
12:49:01 <holmak> I have no idea if that makes sense
12:49:29 <Twey> Hehe
12:49:32 <Kim^Walkman> I thought lambdabot couldn't execute IO actions? :o
12:49:44 <Baughn> Kim^Walkman: It can't, but it could sure redefine hPutStrLn
12:49:50 <EvanR-work> > print "foo"
12:49:51 <lambdabot>   <IO ()>
12:49:56 <tommd> perhaps to @message?
12:49:58 <Kim^Walkman> Heh, true enough
12:49:59 <tommd> or @tell
12:49:59 <b_jonas> it could execute actions in some restricted monad
12:50:04 <b_jonas> that's io-like but doesn't allow all io
12:50:22 <b_jonas> and execute it when the result is in that monad, like the way ghci prompt executes io stuff
12:50:51 <EvanR-work> probably a dumb question, is >>= associative
12:50:53 <sinelaw> can i tell cabal to build using two processes?
12:50:57 <HugoDaniel> is there any wsdl haskell package ?
12:51:10 <dcoutts_> sinelaw: not supported yet
12:51:16 <mauke> EvanR-work: not directly, because the types don't match
12:51:33 <EvanR-work> if the types matched?
12:51:49 <b_jonas> there's a similar law that stands though
12:51:52 <sinelaw> @type (>>=)
12:51:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:52:02 <sinelaw> b_jonas, how can that be associative?
12:52:02 <tommd> @where laws
12:52:03 <lambdabot> I know nothing about laws.
12:52:11 <b_jonas> the types can't ever match I think
12:52:13 <sinelaw> @type (>>)
12:52:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
12:52:18 <EvanR-work> oh right
12:52:19 <sinelaw> that can be associative
12:52:33 <sinelaw> b_jonas, oops i meant EvanR-work
12:52:44 <b_jonas> no, not (>>), there's something for (>>=) but more complicated than simple associativity
12:52:47 <b_jonas> let me look it up
12:52:55 <EvanR-work> i was just thinking of the concept of 'transitively bound' to main
12:52:56 <HugoDaniel> i need wsdl!!
12:52:57 <HugoDaniel> :D
12:53:03 <sinelaw> HugoDaniel, what is that
12:53:05 <knobo> a function f :: [a] -> IO () that should not do anything when f is empth. Is f [] = return () the correct way of doing that?
12:53:14 <mauke> knobo: yes
12:53:15 <EvanR-work> and wondering if IO stuff had to be evaluated in order
12:53:18 <b_jonas> though someone will already know and enter it before me
12:53:24 <sinelaw> dcoutts_, well, is there something else that makes it run faster? :(
12:53:26 <HugoDaniel> http://en.wikipedia.org/wiki/Web_Services_Description_Language
12:53:30 <aavogt> preflex: help
12:53:30 <preflex>  try 'help help' or see 'list' for available commands
12:53:32 <Axman6> heh, did you see that 'the S in SOAP stands for simple' thing on reddit HugoDaniel?
12:53:34 <aavogt> preflex: list
12:53:34 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
12:53:44 <aavogt> preflex: zdec sJl0_info
12:53:44 <preflex>  sJl0_info
12:53:44 <b_jonas> the law is m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h
12:54:02 <dcoutts_> sinelaw: if you're just doing dev builds then use -O0
12:54:12 * EvanR-work begins understanding b_jonas's law
12:54:25 <holmak> preflex: 8ball
12:54:25 <preflex>  what
12:54:28 <sinelaw> dcoutts_, heh, i wasn't really expecting an answer, thanks!
12:54:43 <b_jonas> the law is listed at http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Monad.html#t%3AMonad
12:54:44 <holmak> preflex: 8ball Should I solve my problem by writing a new typeclass?
12:54:44 <preflex>  it is decidedly so
12:54:52 <sinelaw> foddly enough, it just finished building.
12:54:53 <aavogt> I'm having a compile failure due to undefined references. I did recompile my libraries
12:55:05 <aavogt> is there something else that can be done?
12:55:15 <sinelaw> foddly = fondly odd
12:55:20 <sinelaw> or oddly fond
12:55:31 <aavogt> oh, I have to add a new module to the Cabal file?
12:55:53 <b_jonas> aavogt: try compiling with ghc --make, or explicitly include the right libraries
12:55:55 <vulpyne> Axman6: That SOAP thing was pretty funny. I've had to use SOAP and it's pretty horrible.
12:56:07 <dcoutts_> aavogt: yes they must all be listed
12:56:15 <HugoDaniel> Axman6: no
12:56:19 * bos is sad about slower threads in 6.12.1
12:56:25 <HugoDaniel> ive also used soap
12:56:30 * bos is even sadder about deadlocks in 6.12.1
12:56:33 <HugoDaniel> but now i need support for it in haskell, and wsdl too
12:56:41 <aavogt> dcoutts_: yeah, I added a new module imported by another one, but I didn't add it to the cabal file list of exposed modules
12:56:44 <HugoDaniel> "i need" = "i dont want to code a line of java anymore!"
12:56:57 <Axman6> HugoDaniel: http://72.249.21.88/nonintersecting/2006/11/15/the-s-stands-for-simple/
12:57:00 <b_jonas> aavogt: the import statements are like including the header, they won't cause the libraries to be linked in
12:57:27 <thoughtpolice> bos: saw your facebook post, that regression is quite terrible :(
12:57:29 <aavogt> that analogy does not help me ;)
12:57:38 <crutex> when solving elliptic differential equation by domain decomposition, how do you know when to stop iterating?
12:57:44 <bos> thoughtpolice: i'm sure it'll get fixed quickly
12:57:50 <b_jonas> I know I asked this already, but is killing threads with Control.Concurrent.killThread "fast" enough?
12:58:00 <bos> thoughtpolice: that's the marvel of a reproduction recipe
12:58:10 <bos> b_jonas: fast enough?
12:58:10 <aavogt> dcoutts_: could it be possible for cabal to catch such undefined references before I run my executable?
12:58:18 <thoughtpolice> bos: oh yes, JaffaCake is the man. it just sucks that such a bad regression gets caught the day after release, when bugs are much more expensive to fix
12:58:20 <sinelaw> has anyone used wxFruit?
12:58:34 <dcoutts_> aavogt: there's an open ticket on this issue
12:58:37 <aavogt> b_jonas: oddly enough it works for cabal executable targets
12:58:41 <HugoDaniel> ahah
12:58:41 <b_jonas> well, they say that the ghc implementaiton of threads is "lightweight" so creating threads and switching among them is fast
12:58:43 <bos> thoughtpolice: that's true.
12:58:43 <HugoDaniel> great
12:58:49 <b_jonas> but is killing them fast too?
12:58:57 <thoughtpolice> bos: on that note, I still hate how on linux the threaded runtime seems to '
12:59:00 <b_jonas> I know that's not a well-defined problem
12:59:03 <thoughtpolice> slow down' when you use the last core
12:59:09 <aavogt> dcoutts_: great
12:59:22 <bos> thoughtpolice: i've seen reports of that.
12:59:25 <thoughtpolice> but this doesn't appear on solaris, OS X or windows for that matter. :(
12:59:34 <bos> thoughtpolice: i don't know if there's a documented bug for that anywhere.
12:59:40 <thoughtpolice> bos: in all practicality that makes running stuff with -N2 on my dual core laptop worse, not better
12:59:50 <thoughtpolice> which is a bummer.
12:59:55 <EvanR-work> b_jonas: ive been assured to either use threads and love them, and or to not worry about performance
12:59:57 <bos> thoughtpolice: oh, it even affects dual-core systems? suck.
13:00:03 <thoughtpolice> yeah
13:00:03 <mreh> what class enables me to map Integers to classes?
13:00:18 <mreh> type classes that is
13:00:22 <HugoDaniel> im going to create a new package on hackage for a wsdl/soap/uddi
13:00:24 <mauke> mreh: ?
13:00:30 <b_jonas> I love threads, but I hate how ghc doesn't really offer the alternative of using an event model or similar
13:00:30 <HugoDaniel> its going to be called "javatard"
13:00:32 <mreh> I don't even mean types-classes, I mean constructors
13:00:32 <thoughtpolice> for n cores on linux, once you go from making the threaded runtime use n-1 cores to n cores, there's typically a slowdown. even if n = 2 :(
13:00:44 <b_jonas> I don't like to be forced to use something by a language, even if it's something I already like
13:00:55 <mreh> mauke: i wanna do Intable a => Int -> a
13:00:55 <bos> thoughtpolice: i wonder if it could be an RTS bug. i've run lots of parallel code in other languages on linux over the years, and never seen that.
13:01:02 <thoughtpolice> bos: I actually don't think I've seen a bug report for this either, although I know GHC HQ is aware
13:01:03 <Vulpyne> b_jonas: You could write your own event model if you want to.
13:01:04 <b_jonas> threads are helpful in most cases, and I've written threaded programs, but there are some things that I could do easier without threads
13:01:11 <mauke> mreh: how about (Num a) => Integer -> a?
13:01:22 <bos> thoughtpolice: ISTR hearing about it from JaffaCake or chillix or someone
13:02:03 <thoughtpolice> bos: it's possible that the RTS is doing something the linux scheduler does not like, considering that this 'last-core slowdown' scenario does not happen on any other SMP-enabled system (solaris, OS X, etc)
13:02:04 <b_jonas> Vulpyne: yep, but I can't write one easily without using killThread
13:02:09 <b_jonas> and killThread is evil
13:02:14 <b_jonas> I don't like using it even if it's fast
13:02:35 <Vulpyne> b_jonas: Why would you need killthread?
13:02:36 <thoughtpolice> bos: I believe I first heard of it when GHC HQ released the 'runtime support for multicore haskell' paper
13:02:47 <thoughtpolice> which made a note inside about that particular problem on linux
13:02:50 <Vulpyne> b_jonas: Or threads at all. If you really wanted, you could use the FFI for poll/select.
13:02:54 <thoughtpolice> it skewed the benchmarks a bit naturally :/
13:03:03 <b_jonas> Vulpyne: the situation is that I have a timer (want to execute something after some time), but sometimes I want to decrease the time for that timer so it fires earlier
13:03:46 <b_jonas> Vulpyne: nah, that approach gets very ugly unless you reimplement everything
13:04:02 <Vulpyne> b_jonas: I thought you didn't want to use the threaded model at all. I must have misunderstood. :)
13:04:10 <Baughn> In general, asynchronous exceptions are evil. :/
13:04:21 <bos> thoughtpolice: ah
13:04:21 <Baughn> Writing code that works in their presence is frequently hell.
13:04:22 <mreh> mauke: I was hoping there might be a class that automatically converts integers to instances of a type, like Show automatically parses strings
13:04:27 <Vulpyne> b_jonas: So your problem is you forkIO a thread that waits for a while then does something, but when you change the time you'd have to kill that thread and relaunch it with the new time?
13:04:42 <mreh> mauke: deriving (foo), that kind of thing
13:04:53 <mauke> Show doesn't parse strings
13:05:33 <thoughtpolice> bos: oh, i also meant to say, text is looking really, really awesome, especially with the new locale-awareness stuff.
13:05:42 <tass> doserj and/or Cale still around?
13:05:48 <mreh> mauke: read
13:05:53 <mreh> Read
13:05:56 <bos> thoughtpolice: thanks! i've put a lot of work into it.
13:06:04 <b_jonas> Vulpyne: because ghc doesn't (to my knowledge) offer an interface to poll from ffi but allow other threads to execute, so you can't mix that with threading easily
13:06:10 <bos> now all we need is for people to start using it.
13:06:16 <mauke> mreh: Read makes more sense because it can use the source representation
13:06:28 <mauke> mreh: but how would you convert an integer to an arbitrary type?
13:06:29 <b_jonas> Vulpyne: yes, if I decrease the time. if you just increase the time it's easier
13:06:40 <Vulpyne> b_jonas: What granularity is the timer?
13:06:42 <b_jonas> Vulpyne: (that's not my only problem, there's another)
13:06:57 <b_jonas> Vulpyne: dunno
13:07:01 <Vulpyne> b_jonas: Seconds?
13:07:04 <thoughtpolice> bos: we should get some parser combinators slapped on top of text - i would like a high performance text datatype with which I can use a parsec-alike
13:07:08 <tass> Hmm.. I'm getting some parser errors, probably because I'm not entirely sure about the anatomy of a haskell function still.
13:07:20 <bos> thoughtpolice: i think parsec3 already supports it
13:07:24 <b_jonas> Vulpyne: I don't like restricting it because the computer could do milliseconds easily
13:07:27 <mreh> mauke: it could be done, but there's no consistant way
13:07:41 <Vulpyne> b_jonas: If it's not insanely high, you could just put the expire time in a TMVar or something, and then sleep for some interval, wake up and see if it's expired.
13:07:42 <bos> thoughtpolice: but i'm wrong!
13:07:45 <b_jonas> I just want something like Coro+Ev in perl, where I can mix threading and events
13:07:51 <Vulpyne> b_jonas: Then if you wanted to modify the timer, you could just modify the TMVar.
13:08:12 <b0fh_ua> Hi there. Can somebody please explain, what the return type does mean in such type definition "phoneBookToMap :: (Ord k) => [(k, String)] -> Map.Map k String" ?
13:08:21 <bos> ddarius: ping
13:08:23 <tass> So the syntax String =~ "regexpattern" returns the matched part of the string, but how do I set a variable to the matched part of the string?
13:08:24 <mreh> can constructors contain information? like a Java enum?
13:08:26 <b0fh_ua> Map.Map k String - what is it?
13:08:43 <tass> Variable = String =~ "regexpattern"
13:08:44 <tass> ?
13:08:45 <mauke> b0fh_ua: a map from k to string
13:09:01 <tass> Or perhaps..
13:09:08 <tass> Variable = (String =~ "regexpattern")
13:09:10 <tass> ?
13:09:24 <b_jonas> Vulpyne: sure, that would work well in practice, but I'm a mathematician, I don't like such approximate solutions when there are precise ones :-)
13:09:36 <doserj> tass: let var = String =~ regexp in ...
13:09:40 <Vulpyne> b_jonas: Have you looked at http://hackage.haskell.org/package/control-event
13:09:44 <holmak> tass: the type of "variable" determines what =! returns. =! is highly polymorphic on the return type.
13:09:53 <b_jonas> Vulpyne: I mean, the OS won't wake me exactly anyway, nor will the thread be waken when another thread is working, so it hardly matters really
13:10:02 <b_jonas> Vulpyne: no
13:10:35 <b_jonas> Vulpyne: thanks for the link
13:10:35 <Vulpyne> b_jonas: Might do what you want.
13:10:38 <Vulpyne> Sure.
13:10:39 <Jedai> mreh: you mean data constructor ? like "data Maybe a = Nothing | Just a" ?
13:10:57 <b_jonas> except I'm still not sure I want to understand STM, I like normal the threading model
13:11:01 <tass> doserj: 'in' What does that mean in Haskell, I didn't understand the exact concept yet.
13:11:04 <mreh> Jedai: more like constant data, like an Enum in Java
13:11:17 <Vulpyne> b_jonas: STM isn't different from the normal threading model.
13:11:38 <Vulpyne> b_jonas: It's how threads can communicate.
13:11:41 <Jedai> mreh:  what do you mean ? data Stuff = One | Two | Three deriving (Enum) ?
13:12:02 <b_jonas> Vulpyne: in theory I could also allocate one real thread in which I wait for events with ffi, and run stuff in other threads
13:12:12 <b_jonas> Vulpyne: but my problem is
13:12:16 <Vulpyne> b_jonas: If you mean the stuff in Control.Concurrent like TVar, the only very visible difference is you have transactions.
13:12:38 <doserj> tass: "let v = a in b" is Haskell syntax for let-expressions.
13:12:39 <b_jonas> Vulpyne: that the ghci threading system already has to implement an event loop of some kind, and could manage this kind of thing, so why don't they just export the interface for it?
13:12:39 <Jedai> tass: "let <definitions> in <expression>" is an expression
13:12:52 <tass> doserj: As in, what is to follow?
13:13:06 * hackagebot upload: Monocle 0.0.3 - Symbolic computations in strict monoidal categories with LaTeX output. (OsmanBineev)
13:13:06 <Vulpyne> b_jonas: The interface for that Control-Event thing isn't STM-y though. You just add an event with an IO action to execute, and get an EventID back that you can use later to cancel it or whatever.
13:13:22 <Jedai> tass: you can only use the definitions in the expression, so the definitions are local to the expression
13:13:22 <doserj> tass: as in "in the expression b, let v take the value a"
13:13:32 <knobo> There is no such thing as a Monad. There is a type class named Monad. And you can make your type belong to that type clas?
13:13:36 <knobo> right?
13:13:47 <Cale> knobo: huh?
13:13:47 <tass> Right.
13:13:52 <Jedai> knobo: yep, you can make your type an instance of Monad
13:13:52 <Vulpyne> b_jonas: Yeah, it does exactly that - that's why threads are so cheap, because they're mostly just contexes for an IO multiplexing application.
13:13:54 <tass> Wouldn't that make for a syntax like this
13:13:55 <Cale> knobo: There are monads.
13:14:08 <Cale> knobo: A monad M is a type constructor together with some methods.
13:14:14 <Cale> (an instance of the Monad typeclass)
13:14:23 <tass> Or no.. I lost the thread, haha
13:14:30 <Jedai> knobo: though "monad" is the name of a certain mathematic concept that is modelised by the Monad typeclass
13:14:33 * copumpkin just explained monads on reddit!
13:14:33 <copumpkin> zomg
13:14:41 <Cale> knobo: Monads aren't values in Haskell though.
13:14:43 <medfly> zomg!
13:14:48 <b_jonas> Vulpyne: actually it might be better to assume that the ghci event loop is _not_ cheap and efficient, because then the right thing to do (unless I want to hack ghc) is to run an efficent event loop in ffi in one thread.
13:14:49 <copumpkin> I probably did it all wrong though, was a bit out of my comfort zone
13:15:00 <Vulpyne> copumpkin: What type of food did you use as the analogy? Pumpkins?
13:15:22 <copumpkin> Vulpyne: I was actually just clarifying the "monoid in the category of endofunctors" thing that people throw around all the time, and just serves to confuse people more
13:15:30 <Vulpyne> b_jonas: That is pretty much what control-event doe-s.
13:15:30 <b_jonas> Vulpyne: and MJD actually recommended running an event loop in a separate os thread for some programs, though I don't really remember what the particular use case was and why it's so good
13:15:31 <knobo> buritos?
13:15:41 <b_jonas> Vulpyne: yep, it says "two-thread model"
13:15:55 <b_jonas> ARGH
13:15:59 <Cale> I like the monoid in the category of endofunctors description. Actually, I like the string diagram description even better :)
13:16:02 <b_jonas> s/MJD/schmorp/
13:16:08 <b_jonas> I'm just tired
13:16:23 <copumpkin> Cale: me too, but most people try to fit it to an algebraic monoid and get lost in the process
13:16:35 <bos> b_jonas: good advice for perl programmers does not necessarily translate to haskell. in fact, it usually doesn't.
13:16:39 <copumpkin> Cale: at least from what I've seen of people throwing it around on reddit
13:16:39 <b_jonas> Vulpyne: okay, thanks
13:16:51 <Vulpyne> b_jonas: You have to assume a lot of stuff in ghc is efficient anyway, might as well assume that is too. :) There's no reason it wouldn't be, really.
13:17:00 <Cale> copumpkin: Yeah, that's true.
13:17:04 <Vulpyne> b_jonas: You can click on the source links from Hackage and look at the actual source if you want to.
13:17:14 <Cale> copumpkin: You have to be perfectly clear on what a monoid object consists of.
13:17:17 <b_jonas> bos: but if you don't let me first do things the way I know, and later gradually use more haskelly idioms, I'll never learn haskell
13:17:25 <copumpkin> Cale: yeah, that's what I tried to do
13:17:36 <copumpkin> I'd paste my link but reddit just broke
13:17:44 <b_jonas> Vulpyne: yep, I must still assume spawning threads and switching among them is, plus garbage collection
13:17:51 <copumpkin> http://snapplr.com/h7xa
13:18:01 <Cale> b_jonas: That's silly. When you start learning a new language, it's unreasonable to expect that you can do anything the way that you're used to doing it.
13:18:02 <b_jonas> thanks for all the advice
13:18:21 <b_jonas> Cale: have you read Stroustrup?
13:18:29 <knobo> While monads are a mathematical consept, as far as haskell knows, it's just a typeclass.
13:18:47 <Cale> b_jonas: It's like if I was to try to use English idioms in Japanese :)
13:19:00 <copumpkin> knobo: yeah, and the definition of the typeclass serves to further confuse people trying to understand the category theory behind it
13:19:10 <copumpkin> translating idioms is the best thing ever
13:19:12 <copumpkin> I love doing it
13:19:23 <Cale> If you don't feel at sea when learning a new language, then it's probably not worth your time to learn it.
13:19:26 <copumpkin> literal translations of them (are hilarious)
13:19:28 <b_jonas> Cale: nah, I'm not trying to translate idioms, only things I suppose should work in any language, or something
13:19:43 <b_jonas> Cale: I'm not trying to do particularly perlish things
13:19:54 <medfly> b_jonas: it's not so bad to learn to do things the Haskell way from the beginning
13:19:56 <b_jonas> Cale: and I do feel at sea
13:20:05 <Cale> b_jonas: So what are you attempting? :)
13:20:15 <b_jonas> because of all the pure functions and the monad towers
13:20:33 <b_jonas> medfly: some things, yes
13:20:34 <Cale> I try to avoid monad transformer towers as much as possible.
13:20:35 <b_jonas> not all things
13:20:48 <Cale> As a beginner, I think you should pretend that monad transformers don't exist.
13:20:48 <medfly> b_jonas: I was pestered by Cale for writing bad code and now I started working in programming (tho not using Haskell) and I was told I write decent code. that was a _huge_ bonus I didn't notice before ;)
13:20:52 <b_jonas> Cale: not transformer, even just plain monad monad withot a transformer wrapper
13:21:02 <medfly> but I suck in comparison to you, so go ahead
13:21:02 <tass> let s = testVar =~ "#[a-z]*" in testVar = ":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message" putStrLn s
13:21:09 <tass> Am I doing it wrong?
13:21:23 <tass> (There's meant to be a newline before putStrLn s)
13:21:30 <mauke> tass: yes
13:21:33 <Cale> tass: What's with the  testVar = ?
13:21:49 <Cale> tass: Is that supposed to be on the other side of the 'in'?
13:22:02 <tass> Cale: Frankly, I have no clue.
13:22:06 <Cale> tass: The syntax is   let <declarations> in <expression>
13:22:33 <Cale> :t let s = testVar =~ "#[a-z]*"; testVar = ":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message" in putStrLn s
13:22:34 <lambdabot> IO ()
13:22:36 <b_jonas> tass: try let { s = ...; testVar = ...; } in putStrLn s
13:22:42 * b_jonas ducks
13:22:56 <tass> and the 'in <expression>' part is mandatory?
13:23:09 <mauke> tass: well, what would you do without it?
13:23:19 <Cale> tass: Yes, because it's the whole point ;)
13:23:24 <benmachine> the declarations are optional though
13:23:26 <benmachine> > let in 4
13:23:28 <lambdabot>   4
13:23:28 <tass> mauke: I want my variable to be there so I can use it elsewhere?
13:23:31 <mauke> tass: it's like having 'if <expression> then <statement>' and asking whether 'then <statement>' is mandatory
13:23:36 <knobo> OptimusPrime, a monad transformer?
13:23:53 <mauke> tass: if it's here, you can't use it elsewhere
13:23:54 <Cale> tass: It's an expression form, so it absolutely must evaluate to a value.
13:24:15 <Cale> tass: however, there is a statement-form of let which is available inside a do-block
13:24:31 <tass> Hmmm...
13:24:32 <b_jonas> and that too can't stand at the end
13:24:41 <Cale> tass: and it desugars into a let expression when the do-block is unravelled
13:24:48 <tass> So, how would I make it a variable available to the whole program?
13:24:48 <b_jonas> because as the declarations can't have side effects, it does not make sense not to have a value
13:24:52 <mauke> yeah, ths 'in <expression>' part is still there
13:24:57 <Cale> do let <decls>; <stmts>  =  let <decls> in do <stmts>
13:25:08 <mauke> tass: 'var = <expression>' at the toplevel
13:25:13 <Cale> tass: Move the variable to the top level
13:25:20 <tass> Right...
13:25:22 <Cale> tass: Of course, it will be a constant.
13:25:35 <tass> Cale: Well, it's Haskell, so all variables are constants.
13:25:41 <tass> Unless they are IO.
13:25:45 <benmachine> or ST
13:25:54 <benmachine> maybe call them bindings instead of variables
13:25:58 <benmachine> that is more specific
13:26:04 <Cale> Well, sort of, yeah :)
13:26:16 <kmc> an IO action is an immutable value too
13:26:17 <Cale> Variables are constant as long as they remain in scope
13:26:23 <b_jonas> anyway, good night
13:26:28 <Cale> But they can change between those times.
13:26:37 <b_jonas> and thanks for all the advice, even for the ones I don't like
13:26:44 <Cale> For example, x won't always be the same in every call to  f x = x^2,  of course
13:26:44 <tass> My problem here is
13:26:48 <tass> I've got two functions.
13:27:06 <tass> And I'd like variables to be available in both.
13:27:18 <tass> Am I going about it the wrong way?
13:27:21 <ezyang> tass: READER!
13:27:26 * ezyang has no context. 
13:27:35 <Cale> Then I guess it makes sense to move their definitions upward.
13:27:35 <mauke> tass: how constant are the variables?
13:27:45 <benmachine> how variable are the constants
13:27:55 <tass> mauke: They change every time a new line is read from the chat
13:28:04 <mauke> how do they change?
13:28:12 <tass> mauke: A new line is entered in the chat?
13:28:21 <Cale> tass: You could also move the two functions inward, defining them inside the place where they are used.
13:28:25 <benmachine> can you pass them to both functions as parameters?
13:28:27 <mauke> haskell variables aren't magically connected to chat
13:28:27 <tass> And then the program reads it, and replaces the values.
13:28:39 <benmachine> replaces the values?
13:28:43 * benmachine eeks
13:28:48 <tass> mauke: No, but they are magically connected to a getline
13:29:02 <mauke> so your variable is a function parameter
13:29:03 <kmc> you can call a function multiple times with different input
13:29:52 <HaskellLove> b_jonas yes euler 15 give me hint please
13:30:02 <tass> Heck, I'll upload my code to pastebin to de-confuse this
13:30:33 <Cale> tass: Basically, you have a function parameter which gets the string, yeah?
13:31:05 <Cale> tass: You have a couple options. The first one which is rather obvious is to make all the values which depend on that string into functions which take the string as a parameter.
13:31:51 <Cale> tass: The second is to move the definitions of the functions/values which depend on that string into the where-clause (or a let expression) for a function which gets the string as a parameter, so that they can then use it directly.
13:32:22 <tass> Cale: I could make the main = do's where clause reaaaally long, yeah
13:32:22 <Cale> tass: Do either of those make sense in your context?
13:32:41 <Cale> tass: Probably better then to just make things take the value as a parameter
13:32:47 <tass> http://pastebin.com/d212679a
13:32:51 <tass> That's the code, anyhow.
13:33:21 <Cale> tass: You might worry that the number of parameters to functions is getting a bit large, but there are good ways to combat it, and you might actually find that you like it better than using global mutable state :)
13:33:51 <Cale> This is because it makes it easier to test the code with different values of that parameter, and you can see the dependencies more clearly.
13:33:54 <tass> Cale: Yeaaaah... I'm starting to send a hella lot of values to functions already.
13:34:07 <Cale> You can bundle them up into new datatypes
13:34:16 <tass> Hmm, that's true.
13:34:24 <tass> I'm already pondering a Server type
13:35:23 <tass> Cale: What I'm trying to bastardise right now is regexchan and regexnick, respectively.
13:36:50 <tass> And currently, they aren't working as intended ; )
13:37:04 <Cale> tass: What you really want is a parser which extracts all the parts of an IRC line at once and sticks them into a record datastructure.
13:37:57 <tass> Cale: Hmm.. yeah.
13:39:06 <HaskellLove> take 20 . repeat 1 why does not this work, am i applying dot operator the wrong way? I want to do this take 20 $ repeat 1 but with the dot operator for composition
13:39:19 <Cale> take 20 . repeat $ 1
13:39:27 <Cale> Or  (take 20 . repeat) 1
13:39:36 <copumpkin> lolwut
13:39:39 <Cale> Or  take 20 $ repeat 1
13:39:58 <napping> take 20 . repeat 1 is the same as \x -> take 20 (repeate 1 x)
13:40:02 <copumpkin> reddit lost my explanation
13:40:11 <Cale> copumpkin: awesome
13:40:17 <copumpkin> yeah!
13:40:34 <Cale> copumpkin: Don't you love it when you get to write the same long explanation twice?
13:40:57 <copumpkin> Cale: well, it shows up in my comments page, but permalink "broke reddit" and if you look at the main comment thread it's not there
13:41:17 <HaskellLove> napping yeah man but take 20 . repeat 1 does not work...
13:41:29 <Cale> HaskellLove: Because it's ill-typed
13:41:39 <Cale> HaskellLove: repeat 1 is a list
13:41:42 <jmcarthur> HaskellLove: repeat 1 does not take any more arguments
13:41:43 <Cale> HaskellLove: not a function
13:51:53 --- mode: irc.freenode.net set +o ChanServ
13:52:14 <xerox> ghc-pkg list   doesn't have it, hmmm.
13:52:15 <bnijk_> it's the kind of article you want bookmarked...
13:52:15 <Cale> xerox: Could it perhaps be a problem with the 6.12 package?
13:52:15 <HaskellLove> anyone has done euler 15 so we talk in PM and explain me what the solution means which i found on a web? i am not that good combinatorics... so...
13:52:15 <benmachine> bnijk_: my program is pretty poorly modularised, not sur eI want to give you just the whole thing
13:52:15 <tass> Could they please be so kind and stop DDOS'ing already? :<
13:52:15 <benmachine> do you want to know something in particular?
13:52:15 <copumpkin> HaskellLove: many of us have done it, best ask in here :)
13:52:15 <xerox> Cale: do you have 6.12.1 ?
13:52:15 <copumpkin> tass: I wish
13:52:15 <bnijk_> i just need the ncurses bit benmachine
13:52:24 <fizruk> does anybody know good papers about arrow parsers?
13:52:32 <Cale> xerox: Haven't installed it yet
13:52:32 <tass> copumpkin: Makes the chat horribly hard to follow, with all the quit/join messages
13:52:52 <Cale> I just shut off join/quit messages in my IRC client
13:52:57 <tass> Cale: Have you got anything good on custom datatypes?
13:52:59 <xerox> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/index.html
13:53:03 <xerox> no parallel package here
13:53:09 <tass> Cale: Heh, yeah, I like having it for the small channels, though.
13:53:12 <xerox> but there is one here http://www.haskell.org/ghc/docs/6.10.4/html/libraries/index.html
13:53:13 <Cale> Means I don't know if I'm actually talking to anyone who's still there, but at least it helps with the scrolling
13:53:20 <benmachine> bnijk_: mm but it's not easy to extract
13:53:26 <bnijk_> no kidding
13:53:48 <Philonous> Cale: My client shows users that quit in italics
13:54:21 <roconnor> GHC has type erasure?
13:54:31 <Cale> I wish that X-Chat would group the joins/quits and show something like * 56 users joined <Click here to see a list>
13:54:52 * tass is an irssi user.
13:54:52 <HaskellLove> copumpkin awesome :), http://realultimateprogramming.blogspot.com/2009/03/project-euler-problem-15.html Here are things that bother me: 1. "There are 40 steps to any given path" How do you find out how many steps you have in a grid, going from top left corner to bottom right? 2. Are all possible ways done in exactly 40 steps? I mean what if you twirl like a snake game?
13:55:11 <benmachine> bnijk_: well, there's this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14274#a14274
13:55:27 <benmachine> bnijk_: I don't believe it will do much good though, it'd be easier if you asked questions
13:55:50 <bnijk_> all i need to do is initialize the window, have a main display screen, a text-entry box at the bottom, and a floating box at the top
13:56:02 <copumpkin> HaskellLove: the 40 steps thing is fairly trivial and I think you should think about it more if you can't see it :)
13:56:08 <Cale> HaskellLove: What does problem 15 ask for?
13:56:22 <benmachine> PE is offline :o
13:56:26 <copumpkin> HaskellLove: note that solutions to almost all the problems exist online so it's best not to go googling unless you're totally stumped
13:56:27 <benmachine> (temporarily)
13:56:39 <benmachine> if you're totally stumped why would you go googling
13:56:45 <benmachine> just... skip that one
13:57:00 <copumpkin> benmachine: that too
13:57:00 <Philonous> benmachine: You could learn something from the solution
13:57:23 <copumpkin> I imagine not many of the solutions are expressed as progressive hints
13:57:29 <benmachine> mm
13:57:46 <Cale> Number of routes through a 20x20 grid? It's just (40;20)
13:57:49 <HaskellLove> copumpkin this is my first time i look for solution, because i knew it was some combinatorics problem so i did not want to waste too much time with it
13:57:59 <copumpkin> HaskellLove: don't think that way
13:58:04 <copumpkin> HaskellLove: the 40 is absolutely trivial
13:58:13 <HaskellLove> Philonous I agree
13:58:22 * tass dödar Metrals webläsare
13:58:37 <tass> Ignore last message *mutters something about channel confusion*
13:58:44 <Cale> > let fac n = product [1..n]; binomial n k = fac n `div` (fac k * fac (n-k)) in binomial 40 20
13:58:45 <lambdabot>   137846528820
13:58:45 <copumpkin> Cale: it's not even the number of routes, it's the number of steps in any given route
13:58:53 <Cale> copumpkin: oh
13:58:57 <Cale> copumpkin: pff
13:59:00 <copumpkin> :)
13:59:03 <HaskellLove> copumpkin well please explain dont just tell me it is simple :)
13:59:21 <kmc> HaskellLove, he's saying you should think harder ;P
13:59:38 <HaskellLove> by the way i want to learn combinatorics and stuff but slowly, by seing where and how it is used, just reading a book on the topic blows my mind
13:59:39 <Veinor> why, oh why are the haskell doc links broken?
13:59:44 <Cale> HaskellLove: walk along the edges
13:59:57 <Cale> HaskellLove: there are 20 steps down, and then 20 steps left
13:59:58 <Veinor> also, you can do that one problem with a recursive memoized function
14:00:04 <Cale> er, right, or whatever
14:00:12 <Cale> (doesn't really matter what the directions are :)
14:00:39 <copumpkin> HaskellLove: but in general, for a combinatorial problem, take a smaller version of the same problem. 20x20 might be hard to think about, so think about it on a 2x2 or a 3x3
14:00:50 <bnijk_> @hoogle withSocketsDo
14:00:51 <lambdabot> Network withSocketsDo :: IO a -> IO a
14:00:51 <lambdabot> Network.Socket withSocketsDo :: IO a -> IO a
14:00:51 <lambdabot> Network.Socket.Internal withSocketsDo :: IO a -> IO a
14:00:59 <copumpkin> how many steps will it take you to walk from top left to bottom right of a 3x3 grid?
14:01:10 <copumpkin> regardless of what path you take
14:01:10 <napping> Why doesn't pattern matching desugar into something like Maybe?
14:01:36 <HaskellLove> copumpkin it is not intuitive to me to think that ALL paths are 40 steps.. as i said wha if you twirl like a snake... anyways let me count some steps now :)
14:01:37 <Cale> HaskellLove: If you want to choose a path which only walks down and to the right, any such path is described by a string of D's and R's which has 20 D's and 20 R's. You can also think of this as being a string of length 40 of which 20 have been selected to be D's
14:01:53 <kmc> HaskellLove, give the grid integer coordinates and call the target (0,0).  You start at (20,20).  Each step decreases one of the coordinates by exactly 1
14:01:59 <Cale> HaskellLove: You're not allowed to go up or to the right
14:02:11 <Cale> er, damn it ;)
14:02:14 <Cale> to the left
14:02:22 <HaskellLove> Cale well that makes it all easy then :)
14:02:32 <HaskellLove> i thought you can go anyway
14:02:38 <Cale> HaskellLove: Otherwise, there would be infinitely many paths.
14:03:05 <HaskellLove> well this is easy then let me solve it in 5 minutes now :)
14:04:30 <bnijk_> the interesting thing about haskell is that the functional mindset can incorporate natural languages...
14:04:50 <bnijk_> so that with enough libraries and insane combinatrics, you could write english and ghc would compile it...after a few years
14:05:07 <bnijk_> mark my words
14:05:11 <ben> Surely the punctuation would get in the way
14:05:21 <bnijk_> nah
14:06:28 <bnijk_> there have got to be simple network FRP tutorials
14:07:58 <copumpkin> wow, reddit must be in the same datacenter as freenode's major hubs
14:08:04 <copumpkin> because it's slow as **** right now
14:08:16 <ezyang> ==
14:08:18 <tass> Though, why DDOS freenode?
14:08:47 <mercury^> HaskellLove: you can do much better than 5 minutes.
14:09:23 <HaskellLove> mercury^>	being rather stupid it might take me an hour :) i am playing now drawin grids to explore the problem more i just enjoy it
14:09:43 <HaskellLove> drawing trees and what not :)
14:09:45 <copumpkin> it's only your solution that must run in under a minute :) you can take as long as you want on it
14:10:03 <copumpkin> HaskellLove: one idea is to reduce the idea of a path through the grid to a simpler idea
14:10:09 <Cale> tass: There exist people who take some kind of pleasure out of just fucking things up, I guess.
14:10:25 * copumpkin resists the temptation to make a dirty joke
14:10:27 <tass> Cale: Well, sure, I mean, that's fine and all.
14:10:33 <tass> Cale: But, why freenode?
14:10:40 <mercury^> I think there's a rule that every problem must be solvable in under 5 seconds on an old computer?
14:10:41 <HaskellLove> Cale man i just wanna see the tree for myself it will be a binary balanced one i guess
14:10:43 <ezyang> "there also exist people who take some kind of pleasure out of just fucking things down."
14:10:45 <tass> Cale: Surely there must be more interesting places to fuck with.
14:10:59 <ezyang> tass: strange and charmed baby
14:11:07 <mercury^> freenode is an obvious target
14:11:12 <tass> mercury^: Oh?
14:11:14 <mercury^> People have their feelings hurt in discussions here.
14:11:25 <tass> Lol
14:11:28 <copumpkin> HaskellLove: I wouldn't necessarily think of it as a tree, even though it is
14:11:33 <mercury^> It has social interaction and thus emotions run high.
14:11:54 <tass> Surely QuakeNET must be a better target for that purpose? : P
14:12:23 <mercury^> Most quakenet users have a thick skin.
14:12:25 <HaskellLove> i have read lot of AI so i wanna see this tree arghhhhh
14:12:48 <tass> That is sooo not true : P
14:12:53 <mercury^> But also, quakenet is just more robust it seems.
14:12:58 * ezyang thinks AI papers are very interesting 
14:13:01 <ezyang> HaskellLove: which ones?
14:13:16 <tass> qnet folks are mostly pansy CS players who can't take it when things don't go their way ; )
14:13:23 <DigitalKiwi> HaskellLove: I finally got a euler7 I am happy with
14:13:26 <copumpkin> HaskellLove: the trees are great, but won't lead you to a number easily :) but exploring is fun
14:13:27 <HaskellLove> ezyang>	book on ai not papers i am just ai reader
14:14:00 <ezyang> ah ok
14:14:03 <HaskellLove> copumpkin>	yeah man you get GUTS by playing like this, intuition for further similar problems
14:14:26 <mercury^> I had a folder with solutions to most euler problems in Haskell, C and assembler once and then rm *'d once accidentally. :/
14:14:33 <adekoba> i'm making an ID3 (think mp3 tags) parser. I'd appreciate comments on my code: http://github.com/adekoba/htag/blob/master/lib/Sound/HTag/Mpeg/ID3v2.hs . I'm not entirely sure about the structure for Frame's for example.
14:14:34 <HaskellLove> ezyang>	 books, not just one book, i wrote book above :)
14:14:55 <HaskellLove> mercury^>	i would kill myself if that happens to me
14:14:56 <copumpkin> HaskellLove: well, what I'm getting at is reducing a problem to elements that are easy to reason about. This reduces to something fairly simple, but it may not be obvious
14:15:00 <aep> hi folks. i have trouble with cabal: http://codepad.org/mcJSvDDB
14:15:15 <mercury^> HaskellLove: start version control on your solutions before it does.
14:15:49 <HaskellLove> mercury^> should I get Trac or some other software, trac is pain in the ass to be installed
14:15:55 <DigitalKiwi> HaskellLove: why does your tab completion suck >.>
14:15:57 <mercury^> Just use git.
14:16:05 <kmc> git or darcs
14:16:08 <HaskellLove> DigitalKiwi>	what?
14:16:15 * xternal thought that was a user named "mecurial" for a second and laughed
14:16:15 <dcoutts_> aep: tip: don't use sudo cabal install, it doesn't do what you think it does. Just use cabal install, without the sudo.
14:16:17 <adekoba> trac is issue tracking
14:16:19 <DigitalKiwi> HaskellLove> DigitalKiwi>Iwhat?
14:16:29 <DigitalKiwi> see the "I"
14:16:36 <aep> dcoutts_: okay.  yeah no idea what it does really
14:16:44 <HaskellLove> DigitalKiwi>	dude wtf?
14:16:56 <kakeman> is there good site about haskell literature?
14:17:07 <mercury^> laggy connections do that to irssi sometimes
14:17:09 <kakeman> do you know any?
14:17:13 <mercury^> Are you using irssi, HaskellLove?
14:17:21 <phr> kakeman, haskell.org ?
14:17:24 <xternal> haskell.org?
14:17:33 <HaskellLove> mercury^>	dont know what irssi is
14:17:47 <DigitalKiwi> mercury^: maybe he should be using irssi ;D
14:17:49 <kakeman> :D
14:17:56 <DigitalKiwi> mercury^: do you see the I too or is it just me?
14:18:07 <xternal> also, http://book.realworldhaskell.org/ *is* haskell literature ;)
14:18:10 <mercury^> I can see it too.
14:18:20 <aep> "ghc-pkg check" shows a lot of missing files. did you distro screw that up?
14:18:22 <mrsolo> is Text.Regex part of standard library?   ghci fails to find it...
14:19:06 <dcoutts_> aep: looks like the package is slightly wrong, but I think you can workaround it if you upgrade to cabal-install 0.6.4
14:19:12 <tass> mrsolo: Nope, you have to grab the cabal
14:19:20 <ddarius> mrsolo: Less and less is part of the "standard" library where "standard" = distributed with GHC
14:19:29 <aep> dcoutts_: okay. going to
14:19:32 <mrsolo> okay
14:19:50 <dcoutts_> mrsolo: the Haskell Platform is the bigger collection of standard libs + tools.
14:19:52 <_Jedai_> you should probably use the Haskell Platform instead of bare ghc
14:20:18 <_Jedai_> HP contains Text.Regex and others
14:20:22 <mrsolo> ah will use that then thanks
14:20:45 <HaskellLove> copumpkin wooooow the tree is beatifull :) 1. it is symetric 2. tha perfieral paths are unary path not binary :) 3. there is repetition of some trees in the big tree
14:20:48 <aep> dcoutts_: actually i am on 0.6.4
14:21:02 <dcoutts_> aep: hmm, that's odd then
14:21:05 <mrsolo> except haskelll platform is still on 6.10.4
14:21:12 <mrsolo> hmm
14:21:52 <dcoutts_> mrsolo: right, the HP is a tested stable collection of packages, ghc-6.12 was only released yesterday :-)
14:21:55 <aep> isnt there a way to install software with normal packages?
14:22:08 <mercury^> HaskellLove: what tree did you print?
14:22:22 <HaskellLove> mercury^ for 2x2
14:22:32 <copumpkin> HaskellLove: so how many of them are there? :P
14:22:35 <mercury^> "tree for 2x2" does not ring any bells.
14:22:46 <HaskellLove> guys what is the name of git library on ubuntu lot of git stuff
14:22:48 <mrsolo> dcoutts: darn... 6.12 has so many goodies!!! oh well ...
14:22:51 <copumpkin> mercury^: paths through a 2x2 grid
14:22:52 <mrsolo> i wait then
14:23:12 <jmcarthur> HaskellLove: git-core, i think
14:23:32 <jmcarthur> if you mean the package
14:23:34 <ezyang> ==
14:23:36 <HaskellLove> copumpkin - every path is 4 steps and there are 6 paths
14:23:54 <mercury^> Ah, a 4x4 grid.
14:23:59 <copumpkin> a 2x2 grid
14:24:09 <copumpkin> mercury^: from one corner to opposite corner
14:24:21 <copumpkin> HaskellLove: sounds good, now you need to figure out how to generalize it :)
14:24:22 <mercury^> Err, 3x3 grid.
14:24:24 <HaskellLove> what is cool about it, it is symmetric abd the inner trees are the same :)
14:24:28 <HaskellLove> copumpkin yes
14:25:35 <mercury^> HaskellLove: you do not want to operate on paths for that problem, you want to operate on a grid of numbers.
14:25:41 <mercury^> Which you transform.
14:26:06 <copumpkin> I prefer operating on a vector of length 40, myself :P
14:26:12 <copumpkin> makes it very easy to think about
14:26:13 <HaskellLove> mercury^ i have the grid and the tree in front of me, will do one for 3x3 hope i notice some patterns
14:26:22 <mercury^> HaskellLove: ...
14:26:35 <mercury^> You can do in-place updates of the array that represents your grid.
14:27:00 <copumpkin> mercury^: the grid has no numbers in it, fwiw
14:27:05 <copumpkin> it's literally a counting problem
14:27:20 <mercury^> Ah, link?
14:27:24 <mercury^> I must be thinking of another problem.
14:27:26 <copumpkin> project euler is down right no
14:27:26 <copumpkin> w
14:27:29 <roconnor> what are we talking about?
14:27:38 <copumpkin> oh it's back
14:27:38 <copumpkin> http://projecteuler.net/index.php?section=problems&id=15
14:27:50 <phr> If you are seeing this page, you are on the old server. Try clearing your browser cache and restarting your modem/router. Or you can open Command Prompt, and type in: ipconfig /flushdns Then retry. Thanks
14:28:03 <mercury^> So he wants to calculate C(40,20)?
14:28:16 <copumpkin> mercury^: shh :P
14:28:19 <roconnor> oh
14:28:28 <roconnor> mercury^: I was about to say
14:28:29 <roconnor> :)
14:28:47 <roconnor> people who don't want spoilers should talk about this in a different channel :D
14:28:54 <roconnor> it's too tempting
14:29:08 <copumpkin> you can figure it out without knowing about C, anyway
14:29:35 <roconnor> you can figure it out with a $12 calculator from target
14:29:36 <mercury^> Yes, by coming up with the coefficients on your own.
14:30:23 <copumpkin> I'd approach it by thinking of a Vec 40 Bool
14:30:33 <copumpkin> of which 20 must be True and 20 false
14:30:37 <roconnor> copumpkin: you would?
14:30:40 <copumpkin> :P
14:30:47 <copumpkin> if I'd never heard of C
14:30:52 <copumpkin> which seems to be the case here
14:31:10 <roconnor> I'm pretty sure it is best to forget about C and Haskell
14:31:15 <copumpkin> yeah
14:31:19 <roconnor> and pretend you are in a grade 11 math class
14:31:39 <copumpkin> well Vec 40 Bool was just my way of saying 40 choices, of which only 20 really matter
14:31:41 <Philonous> Open your textbook and read the formula?
14:31:51 <roconnor> Philonous: :D
14:31:54 <ezyang> drill drill drill
14:32:02 <copumpkin> reading the formula requires knowing what to look up
14:33:29 <Philonous> copumpkin: Right, but the common approach was opening the textbook and finding a formula with the right amoun of parameters and use this one.
14:33:39 <copumpkin> :)
14:33:59 <roconnor> are calculators 64 bit?
14:34:09 <copumpkin> most of them are floating
14:34:23 <sergdf> is it possible for a function to return a type class instead of an actual type? does this question reveal fundamental ignorance on my part?
14:34:25 <copumpkin> not sure if double or single precision
14:34:25 <mercury^> double precision floats, yep
14:34:30 <roconnor> copumpkin: do they have 53 bit mantissas?
14:34:31 <copumpkin> sergdf: nope
14:34:34 <ezyang> sergdf: sort of
14:34:39 <ezyang> ha
14:34:53 <copumpkin> sergdf: oh wait, did you mean a value of an instance of a typeclass?
14:34:57 <ezyang> I can write a function that returns Foo a => a
14:35:01 <roconnor> > logBase 2 2432902008176640000
14:35:02 <lambdabot>   61.07738392090622
14:35:05 <roconnor> oh
14:35:06 <copumpkin> Integral a => Integer -> a
14:35:07 <copumpkin> like that?
14:35:15 <ivanm> @remember allbery_b What you missed is that the GHC devs are getting out of the libraries business.
14:35:15 <lambdabot> I will never forget.
14:35:42 <roconnor> > floatRadix 0
14:35:43 <lambdabot>   2
14:35:44 <sergdf> copumpkin: i think so, maybe i just have a syntax problem. please stand by
14:35:51 <mreh> why don't local names take precedence over import names?
14:35:55 <roconnor> > floatDigits 0
14:35:55 <lambdabot>   53
14:35:59 <Philonous> sergdf: Functions can be polymorphic in their return type. Look at fromInteger for example
14:36:04 <copumpkin> mreh: we don't like implicit things like that
14:36:21 <roconnor> > logBase 2 2432902008176640000 <= floatDigits 0
14:36:22 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
14:36:22 <lambdabot>    arising from a use of...
14:36:29 <mreh> copumpkin: I hate having to reference everything explicitly
14:36:34 <roconnor> > logBase 2 2432902008176640000 <= fromIntegral (floatDigits 0)
14:36:35 <lambdabot>   False
14:36:37 <roconnor> :(
14:36:39 <roconnor> okay
14:36:53 <copumpkin> mreh: import something hiding the symbols that conflict? and then reimport the conflicting ones qualified
14:36:57 <roconnor> maybe you need a $20 calculator
14:37:08 <copumpkin> :)
14:37:28 <EvanR-work> mreh: there are many ways to import stuff, you can micromanage the namespace however you want
14:37:34 <phr> with the new 6.12 optimizations you can use a $18 calculator
14:37:47 <mreh> can I import a module multiple times?
14:37:49 <roconnor> > logBase 2 670442572800
14:37:50 <lambdabot>   39.28632280618927
14:38:00 <copumpkin> mreh: sure
14:38:07 <roconnor> I guess a $12 one will do afterall
14:38:18 <copumpkin> import Prelude hiding (undefined)
14:38:26 <copumpkin> import qualified Prelude (undefined)
14:38:38 <copumpkin> undefined = error "DAMN YOU!"
14:38:59 <mercury^> $0.12 for a piece of paper will do too
14:39:04 <bnijk_> :t fmap
14:39:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:39:13 <aep> any idea where i can get template-haskell from?  the website only has a broken link
14:39:21 <mreh> I need to use this one symbol all the time, I'd hate having to clutter my code with explicit references to it, however it clashes with a name from an external module
14:39:23 <mercury^> aep: it's integrated into GHC.
14:39:27 <mercury^> (I think)
14:39:35 <aep> cabal doesnt like that one
14:39:41 <sergdf> :r
14:39:46 <mreh> I can't find a way of having a bare reference to a symbol, and a qualified reference to the same symbol
14:40:09 <mreh> "foo.bar" and "bar", in the same code, where bar is define locally
14:40:16 <copumpkin> that's what I just did
14:40:42 <mreh> oh, sorry
14:41:22 <kmc> yes, TH is integrated into GHC
14:41:28 <mreh> i probably dont understand "qualified" properly
14:41:31 <kmc> see ghc manual
14:41:38 <kmc> the standalone implementation is probably super-old
14:42:20 <phr> import qualified seems so vague.  is there a way to import quantified?  :)
14:43:11 <mreh> "import Prelude" is a nasty implicit thing!
14:43:34 <mreh> aww, I just said something really clever
14:44:04 <mercury^> phr: :>
14:44:04 <kmc> mreh, when you import non-"qualified" you can still use the qualified name
14:44:17 <kmc> the default behavior is to allow unqualified names except in case of ambiguity
14:44:27 <kmc> "qualified" changes the module to always require qualification
14:44:32 <mreh> right
14:44:48 <kmc> separately, "import Foo as Bar" renames the qualified name for Foo to Bar.  whether or not qualification is required is still governed by the other rule
14:44:59 <allbery_b> hm?
14:45:58 <kmc> this behavior (conflicting names are errors when used and not before) is a lot nicer than Python's (second unqualified import overwrites the first)
14:46:26 <bnijk_> what other talents besides haskell do you have kmc
14:46:32 <kmc> juggling chainsaws
14:46:40 <bnijk_> good answer
14:46:42 <bnijk_> very quick too
14:46:53 <mreh> isn't that a programming analogy
14:47:41 <copumpkin> guh
14:49:30 <aep> usual steps for a cabal package are configure;build;install ?
14:49:44 <copumpkin> cabal install <packagename>
14:49:45 <copumpkin> for me
14:49:47 * hackagebot upload: haskell-updater 1.0.0.0 - Rebuild Haskell dependencies in Gentoo (IvanMiljenovic)
14:49:50 <copumpkin> but if you want to do it by hand, yeah
14:49:52 <aep> that doesnt work, copumpkin
14:49:59 <copumpkin> no?
14:50:00 <bnijk_> works for me
14:50:09 <copumpkin> you need the latest cabal-install from darcs for 6.12
14:50:14 <crutex2> when solving elliptic differential equation by domain decomposition, how do you know when to stop iterating?
14:50:16 <aep>     Could not find module `Data.Data':
14:50:46 <aep> actually when compiling it manually i get an actual code error. so no much luck there either *sigh*
14:51:21 <dcoutts_> aep: I suggest using an older version of syb-with-class that does not need the newer TH
14:51:48 <aep> there are at least 30 packages that depend on it, if i interpret that correctly
14:51:57 <aep> but will try, thanks
14:52:05 <kmc> syb uses TH?
14:52:11 <HaskellLove> someone tell me how many paths there are for 4x4 grid i think i am close to something
14:52:16 <dcoutts_> kmc: no, syb-with-class does
14:52:29 <kmc> ah
14:52:41 <aep> hm maybe i could try fixing that.  time to learn haskell. heh
14:52:54 <dcoutts_> aep: use cabal install gitit --constraint='syb-with-class<0.6.1' --dry-run
14:52:56 <bnijk_> good luck
14:53:31 <aep> dcoutts_: hey looks like that works
14:53:41 * aep runs
15:06:28 <saml> hey did you write AWS library? EC2
15:06:28 <aep> well that worked. thanks!. now i get this though: http://codepad.org/tlMI4aVh
15:06:28 <aep> ah easy fix. never mind
15:06:29 <Saizan> dcoutts_: now i feel guilty for making life harder for cabal-install
15:06:29 <dcoutts_> aep: are you absolutely sure you're using cabal-install 0.6.4 and not version 0.6.2?
15:06:29 <dcoutts_> aep: I cannot reproduce the problem you reported earlier with template-haskell not building
15:06:29 <dcoutts_> Saizan: ? :-)
15:06:29 --- mode: irc.freenode.net set +o ChanServ
15:06:30 <copumpkin> HaskellLove: there are two steps you need to pick up on here. What choose is and why it works, and why it's appropriate for this problem
15:06:30 <HaskellLove> kmc yeah that one, i am bad at math
15:06:30 <copumpkin> don't be complacent about it!
15:06:30 <copumpkin> :)
15:06:31 <Saizan> dcoutts_: i've uploaded that version of syb-with-class today :)
15:06:31 <HaskellLove> yeah it was that combinations formula let me check it
15:06:35 <copumpkin> HaskellLove: it's fairly simple to derive how choose works from scratch even if you don't remember the formula
15:06:43 <copumpkin> Saizan: syb-with-class needs a monocle
15:06:54 <copumpkin> Saizan: I think you should depend on the monocle package, to give it true class
15:07:16 <Saizan> copumpkin: you are right!
15:07:19 <dcoutts_> Saizan: aye, the problem is that cabal's resolver isn't so smart, in principle it should be able to pick an earlier version of the package and make everything work out.
15:07:28 <Saizan> now, what does the monocle package do?
15:07:49 <dcoutts_> Saizan: I started experminting with a new bottom-up pass in the resolver to eliminate impossible choices
15:07:53 <byorgey> dcoutts_: when you get a chance, any thoughts on http://hackage.haskell.org/packages/archive/oeis/0.2.2/logs/failure/ghc-6.10 ?
15:08:15 <Saizan> dcoutts_: how did it go?
15:08:27 <dcoutts_> byorgey: that's the diamond dep problem
15:08:28 <roostaj> my euler#3 is slooooooooooooooooooooow. better use a better prime algorithm :)
15:08:30 <HaskellLove> copumpkin how man? stop torturing me and help me :) see i am dumb math
15:08:50 <copumpkin> HaskellLove: to derive choose? or see how it's relevant to this problem?
15:08:51 <dcoutts_> Saizan: I think in principle it will work but it needs further changes to the way we handle constraints
15:09:04 <byorgey> dcoutts_: right, that's what I thought, but it builds fine for me using every version of network I've tried.  Any suggestions on how to fix it?
15:09:07 <HaskellLove> to derive choose and how it relates to our problem
15:09:15 <dcoutts_> byorgey: right, it'll work for users too
15:09:23 <bos> preflex: seen tibbe
15:09:24 <preflex>  tibbe was last seen on #haskell 1 day, 7 hours, 38 minutes and 12 seconds ago, saying: is there any released version of Cabal that works with GHC 6.12.1 or do I have to go with HEAD?
15:09:25 <byorgey> ah, ok, just not on the build machine
15:09:28 <byorgey> =(
15:09:36 <bos> oh boy oh boy, i am SO EXCITED.
15:09:42 <dcoutts_> byorgey: it's just the brain-dead builder that hackage uses (it doesn't use the cabal-install resolver)
15:09:53 <byorgey> aha, I see.  that IS brain-dead. =)
15:10:00 <kmc> HaskellLove, formula for choose:
15:10:21 <copumpkin> HaskellLove: say you want to choose 2 balls from a bucket with four balls of different colors (red, green, blue, black) in it. How many choices do you have for your first choice? how many for your second? is that it?
15:10:25 <HaskellLove> copumpkin lets imagine like this:  i have 4 downs and for rights, the question is how to combine those
15:10:35 <dcoutts_> Saizan: we need to be able to separate saying that we will need a package from the constraints we place on a package's version
15:11:03 <dcoutts_> Saizan: since in the upward pass we may eliminate all choices for a package, that doesn't mean we have to fail since we might not need that package
15:11:27 <HaskellLove> copumpkin well for the first choice you have n-1 for the second n-(n-1) and so on right?
15:11:34 <copumpkin> HaskellLove: why n-1?
15:11:42 <dcoutts_> Saizan: where as in the current top-down pass we know all the packages we have constraints on are ones we will eventually need, so once there are no choices available we must fail.
15:11:57 <copumpkin> n-(n-1) = 1
15:12:04 <copumpkin> :)
15:12:11 <Saizan> dcoutts_: i see
15:12:30 <mercury^> HaskellLove: why don't you just read up on binomial coefficients on wikipedia?
15:12:40 <copumpkin> probably a better idea :)
15:12:47 <HaskellLove> mercury^ like i would understand that
15:12:52 <kmc> HaskellLove, i'll give it a shot
15:13:00 <Saizan> dcoutts_: decoupling this might lead to a better handling of the base3/4 situation too, i think
15:13:14 <kmc> You have n buckets.  You want to put a red ball in k of them, and a white ball in the other n-k.
15:13:20 <kmc> That's the problem of choosing k out of n things.
15:13:24 <copumpkin> http://www.mathsisfun.com/combinatorics/combinations-permutations.html
15:13:28 <kmc> We're interested in how many ways there are to do that
15:13:35 <jmcarthur> HaskellLove: the first step toward learning something is to take the first step
15:13:35 <kmc> HaskellLove, with me so far?
15:13:42 <dcoutts_> Saizan: maybe, I think for that we need to loosen things further to allow picking multiple versions of a package where we know they cannot conflict
15:14:18 <HaskellLove> kmc yep
15:14:31 <dcoutts_> Saizan: eg, a package with a lib and an exe where the exe pulls in some additional dep, it's clear the lib cannot re-export types from that package, so it cannot be involved in a diamond dep problem.
15:15:27 <dcoutts_> Saizan: the point is, instead of globally requiring that we pick the same version of a package, we only require it in local domains where there is the risk of re-exported types not matching up
15:15:32 <kmc> HaskellLove, so first we put the n balls into some order
15:15:38 <kmc> there are n! ways to choose an order for n objects
15:15:47 <kmc> HaskellLove, with me so far?
15:17:51 <increpare> I have a question regarding this snippit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14282#a14282 .  When I try to put in the explicit type-declaration for 'shape' I'm getting a 'could not deduce type' message.  This confuses me a little. (Even when I paste in what I get from ':t shape' in ghci, it's not working).
15:18:00 <HaskellLove> is this close to bits and stuff... i mean, you have two bits 1 and 0 and if you have 32 bit adressed it means you can have 2^32 things which was like forgot the number nevermind... kmc
15:18:07 <increpare> (also: hey guys : ) )
15:18:13 <kmc> HaskellLove, no
15:18:29 <HaskellLove> oh that was permutations right?
15:18:32 <kmc> no
15:18:34 <HaskellLove> we need combinations
15:18:37 <kmc> we are talking about ordering n objects, not individually assigning a 1 or 0 to each
15:18:43 <kmc> 2^n and n! are different numbers
15:18:51 <kmc> if you have n objects, there are n! ways to order them
15:19:05 <necroforest> Does anyone here use hfann for neural networks?
15:19:10 <kmc> increpare, you have one of the extensions that enables "forall" syntax turned on?
15:19:21 <kmc> also what does it say it can't deduce?
15:19:35 <increpare> Could not deduce (Graph g v e)
15:19:35 <increpare>       from the context (Graph g v1 e1, Graph g' () ())
15:19:35 <increpare>       arising from a use of `relabel' at G2.hs:7:10-40
15:19:40 <increpare> (oops..>_<)
15:19:50 <kmc> so it's a typeclass issue
15:19:53 <mrsolo> so in haskell lecture series by  erik meijer
15:19:55 <increpare> I have  -fglasgow-exts
15:20:17 <mrsolo> he mentioned that seasoned haskell programmer favors [] instead of Maybe, true?
15:20:29 <kmc> mrsolo, i don't...
15:20:32 <kmc> they do different things
15:20:34 <increpare> mrsolo: does he really say that?
15:20:35 <sinelaw> what's the vanilla 2d-vector type in haskell?
15:20:41 <mrsolo> increpare. ya
15:20:49 <mrsolo> in a context of course
15:20:49 <increpare> mrsolo:  does he say why?
15:20:51 <bd_> mrsolo: That's silly. If you have a reason to 'favor' like that, it's best to just generalize over MonadPlus
15:21:09 <mrsolo> increpare: Maybe is hard to work with in nested structure
15:21:11 <dcoutts_> aep: I can reproduce the problem with TH if using cabal-install-0.6.2, with 0.6.4 it works fine. This is how I'd expect. Please let me know if you still think that it failed when using version 0.6.4.
15:21:14 <kmc> HaskellLove, so there are n! ways to arrange our n balls
15:21:15 <mrsolo> so just do [] for Nothing
15:21:17 <increpare> sinelaw: I usually end up using one of the array classes, with a (Int,Int) index.  There might be a better way, though.
15:21:24 <mrsolo> and [a] for Just a
15:21:36 <Cale> increpare: My guess is that in the real type, there's an additional constraint which can't be expressed in the syntax.
15:21:38 <bd_> mrsolo: There's nothing hard with using Maybe in a nested structure - just deconstruct it using monad do-syntax
15:21:39 <kmc> but any red ball is as good as another; once we've chosen which bins get red balls, we don't care about swapping two red balls
15:21:43 * mrsolo shrugs
15:21:56 <Cale> increpare: (That is, the type printed by :t is not the real type)
15:21:58 <mrsolo> i don't know anything one way or the other, still a newbie here..
15:22:04 <mrsolo> i guess his comment is invalid :-)
15:22:14 <kmc> so each of the n! total orderings is in a set of size k! that we consider equivalent
15:22:18 <aep> dcoutts_: odd. on the other hand i have no idea how to find out which cabal version is actually _running_.  -v --version etc dont work. so all i checked was cabal info cabal-install
15:22:19 <Cale> hmm
15:22:20 <kmc> and likewise for white balls, size (n-k)!
15:22:20 <increpare> Cale: that sounds a bit queer hmm.  I guess there are depenencies in the typeclass
15:22:31 <dcoutts_> aep: cabal --version
15:22:31 <kmc> HaskellLove, so the total number of choices is n! / (k! (n-k)!)
15:22:39 <Cale> increpare: Yeah...
15:22:42 <kmc> and i have to go now, ttyl
15:23:02 <Cale> increpare: er... hmm...
15:23:05 <increpare> maybe if I put an exists in, actually
15:23:11 <increpare> for the g'
15:23:19 <Cale> increpare: No, this doesn't make sense.
15:23:32 <HaskellLove> kmc oh yeah that formula but i still dont get how to derive it and understand it... chesus i am 21 and i am so fuckin non math i gota take some actions
15:23:53 <kmc> HaskellLove, what i just explained is how to derive and understand it
15:23:57 <kmc> i'll let someone else try though
15:24:10 <aep> dcoutts_: says 0.6.2 now.  but it didnt work previously.  i guess thats related
15:24:12 <increpare> Cale: yeah you're right i was bullshitting : S
15:24:20 <increpare> (didn't realize it though)
15:24:24 <HaskellLove> kmc just tell me one more thing, what was the difference betweeen permutation and combinaton of n elements
15:24:31 <kmc> permutation we care about order
15:24:34 <kmc> combination we don't
15:24:40 <dcoutts_> aep: it should always have worked, perhaps just a mis-spelling or something
15:24:48 <aep> hm. might
15:24:48 <Cale> increpare: I mean that it doesn't really make sense what the extra constraint would be...
15:24:58 <dcoutts_> aep: thanks for checking, I'm glad it matches what I expected.
15:25:01 <aep> dcoutts_: anyway, you're right. i propably didnt set PATH properly
15:26:05 <increpare> kmc: except if you're dealing with sets in haskell, most of the algorithms which require the elements to be ordered : P
15:26:11 <increpare> (orderable)
15:26:24 <Cale> increpare: aha!
15:26:26 <sinelaw> FRP.Yampa.Vector2 does the job
15:26:30 <increpare> Cale: oho?!
15:26:38 <Cale> increpare: Would it be the case that g determines v and e as well?
15:26:45 <HaskellLove> kmc and our problem is permutation or combination?
15:26:52 <Cale> increpare: Because adding that constraint helps ghc to typecheck it with the signature.
15:26:55 <HaskellLove> i think permutation
15:27:20 <copumpkin> Cale: this was my attempt at explaining the monoid thing: http://www.reddit.com/r/programming/comments/aewnc/monads_are_like_burritos/c0h95dh anything obviously wrong with that? (beyond being a bad explanation... just want to make sure I actually understand the stuff myself correctly)
15:27:27 <roostaj> question: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14283#a14283 ... when I say euler003 n xs is this an iterative process?
15:27:28 <increpare> Cale: Oh I can do that?  I thought I couldn't add possibly circular dependencies. I'll try it out now.
15:27:50 * increpare hugs Cale
15:27:52 <roostaj> that is a solution to euler#3 if you  don't want the solution btw
15:27:55 <increpare> Cale: thanks : )
15:28:41 <Cale> copumpkin: It might be worth mentioning what the bifunctor is in the specific case, though you sort of do that.
15:28:52 <Cale> copumpkin: By the way, I have a similar explanation in a comment.
15:28:52 <copumpkin> oh, yeah
15:29:17 * copumpkin hunts down Cale's comment
15:29:33 <copumpkin> aha, found it
15:29:44 <sergdf> still having issues returning a member of a type class, could anyone take a look at http://pastebin.com/d9d7f697 and tell me why including the type signature causes it to fail?
15:29:47 <copumpkin> (http://www.reddit.com/r/programming/comments/a7cii/what_a_monad_is_not/c0g7711)
15:31:25 <DigitalKiwi> what is the difference between comment and documentation comment and why are there two documentation comments for until end of line? according to http://merd.sourceforge.net/pixel/language-study/syntax-across-languages-per-language/Haskell.html
15:32:07 <ivanm> DigitalKiwi: the documentation comments go in the haddock html documentation pages
15:32:08 <Cale> <Cale> copumpkin: That thing about associativity is a little funny
15:32:12 <Cale> <Cale> copumpkin: those two are the right ways to look at it, but you need to actually apply the joins :)
15:32:13 <ivanm> but I have no idea for "end of line"
15:32:14 <Cale> <Cale> It's not just saying that the tensor product which turns the category into a monoidal category is associative (though that is required, at least up to coherent isomorphisms), but that mu can be applied to either the left pair or the right pair first.
15:32:22 <doserj> sergdf: the type signature says that makeVar can be *any* instance of MyClass. but the definition says, it is the of type MyInstance.
15:32:24 <Cale> (sorry, not sure which messages got through :)
15:32:29 <copumpkin> Cale: oh, yeah, I see
15:32:34 <copumpkin> Cale: none of those got through :)
15:32:35 <Taejo_> DigitalKiwi: the two types of doc comments comment the previous item and the next item
15:33:04 <Cale> http://www.reddit.com/r/programming/comments/a7cii/what_a_monad_is_not/c0g7711
15:33:19 <Cale> There was my attempt at explaining why it's not bind which is the monoid operation.
15:33:22 <copumpkin> yeah :) found that and linked to it in the time you were gone
15:33:34 <sergdf> doserj: so the fact that the actual type is a member of the type class is not sufficient? can you give me a hint as to what a correct type signature might look like?
15:33:42 <copumpkin> bind seems more related to the kleisli category of a monad than the original definition of it
15:34:05 <doserj> sergdf: makeVar::MyInstance
15:34:05 <Cale> The annoying thing is that freenode can completely disconnect me from the network and my client doesn't even notice except that my ping goes through the roof.
15:34:21 <fracture> if you have [1,0,0,1] and [1,2,3] (as examples), is there an easy way to use the list monad to get a list of [1,x,y,1] where x and y range over [1,2,3] ?
15:34:35 <sergdf> doserj: so if i wanted to have a function that might return different instances of the same class, that would not be possible?
15:35:00 * DigitalKiwi checks what haddock is, thanks
15:35:01 <Cale> > mapM (\x -> if x == 0 then [1,2,3] else [x]) [1,0,0,1]
15:35:03 <lambdabot>   [[1,1,1,1],[1,1,2,1],[1,1,3,1],[1,2,1,1],[1,2,2,1],[1,2,3,1],[1,3,1,1],[1,3...
15:35:03 <fracture> (the real situation is not that small, or I'd use a list comprehension, etc)
15:35:04 <copumpkin> Cale: same here
15:35:13 <doserj> sergdf: only if your class-definition provides such functions.
15:35:14 <fracture> Cale: thanks :)
15:35:24 <Taejo_> DigitalKiwi: do you know python or java?
15:35:32 <DigitalKiwi> nope
15:35:42 <doserj> sergdf: like fromInteger for the class Num
15:36:10 <DigitalKiwi> i know of doxygen though
15:36:31 <Taejo_> while then I guess haddock is like doxygen (which I've never used)
15:36:34 <Taejo_> *well
15:36:50 <Saizan> copumpkin: yeah, the Kleisli triple is (M,=<<,return) iirc, where =<< is usually written ^* (where ^ is intended like in latex)
15:36:58 <copumpkin> ah
15:37:12 <copumpkin> wait
15:37:20 <copumpkin> oh I see
15:37:30 <Saizan> so f : A -> M B means f^* : M A -> M B
15:37:39 <copumpkin> yeah
15:37:42 <sergdf> doserj: so I would define a function, say, fromMyClass, as part of the class MyClass, that would have a polymorphic return type that would be one of the instances?
15:37:51 <Saizan> so you can compose those as arrows of C
15:37:59 <Saizan> where M : C -> C
15:38:00 <DigitalKiwi> hmm, looks interesting, thanks
15:38:37 <copumpkin> Saizan: yeah, I'm used to thinking of it just in terms of <=< and return, but that makes sense
15:38:44 <copumpkin> and they're fairly trivial to switch between
15:38:55 <doserj> sergdf: you would have a class-method like toMyClass:: <something> -> a, yes
15:39:38 <sergdf> doserj: thanks a bunch
15:40:13 <Saizan> with only <=< and return you don't get =<< though
15:40:14 <Cale> err...
15:40:21 <aep> humm.  can ghc cross compile?  i dont think this will ever progress. its trashing out because of too little ram...
15:40:36 <p_l> aep: yes, it can, through C
15:40:49 <aep> can cabal do that?
15:41:11 <dcoutts_> aep: ghc cannot cross-compile yet
15:41:48 <aep> yeah i guess intermedite C is too complex for my needs.
15:41:55 <aep> well thanks anyway.
15:42:21 <doserj> Saizan: you get it with fmap, though, I think
15:42:37 <Saizan> doserj: how?
15:42:54 <doserj> Saizan: join = id >=> id, right?
15:43:05 <Saizan> ?type id >=> id
15:43:06 <dolio> @type \m f -> (f <=< const m) undefined
15:43:07 <lambdabot> forall b (m :: * -> *) c. (Monad m) => m b -> (b -> m c) -> m c
15:43:08 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
15:43:21 <Saizan> ok :)
15:44:00 <dolio> > let bind m f = (f <=< const m) undefined in [1..10] `bind` \x -> [1 .. x]
15:44:01 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,...
15:45:44 <HaskellLove> I think i understood this combinatorics shit, actually remembered it of coruse i studied it high school... so combinations are... being philosophically oriented and well read... i would say if you have to choose 3 books out of 10 of different colors, that means THE FORM is 3 and you have to put these numbers into that FORM in such way that every number meets every other number in that form,...
15:45:46 <HaskellLove> ...but no duplicates of elements combinations happens... kmc, copumpkin, mercury^?
15:45:49 <Cale> aep: What are you trying to do?
15:46:13 <aep> Cale: running the  gitit wiki
15:46:18 <Saizan> (pretty obvious, after the fact)
15:46:49 <dolio> Elements in category theory are functions from terminal objects to the object in question, so yeah. :)
15:47:05 <dolio> Or, morphisms.
15:47:06 <HaskellLove> aep git has wiki too?
15:47:07 <copumpkin> HaskellLove: going back to my example, you have 4 choices for your first pick and 3 choices for your second pick. But picking red then green is the same as picking green then red. How many orderings of 2 elements are there? I just gave it away: 2.
15:47:21 <aep> HaskellLove: :D  its a wiki with git backend
15:47:27 <Cale> aep: I mean, why do you want to cross compile?
15:47:41 <Cale> aep: Is the machine that the wiki is running on a strange architecture?
15:47:42 * copumpkin sticks his tongue out at Saizan 
15:47:43 <HaskellLove> aep shit coool, what is the name of the library so i get it i am ubuntu
15:47:47 <aep> Cale: because the target machine only has 512mb ram ans ghc is trashing
15:47:58 <Saizan> aep: which two systems are we talking about?
15:48:08 <aep> HaskellLove: no idea. http://gitit.net/
15:48:19 --- mode: ChanServ set +b *!n=palomer@*
15:48:19 --- kick: shazam was kicked by ChanServ (Banned: fixed*the*glitch)
15:48:28 <copumpkin> lol
15:48:30 * chrisdone grabs copumpkin's tongue
15:48:36 <ivanm> shazam!~
15:48:36 <aep> Saizan: host 32bit x86, target 64bit
15:48:44 <HaskellLove> aep so u use git as version control system and u can wiki with it?
15:48:53 <copumpkin> is palomer another troll?
15:48:54 <ivanm> HaskellLove: yes, git or darcs
15:49:04 <aep> HaskellLove: yeah looks like it. didnt try, but the concept looks really nice
15:49:14 <sjanssen> copumpkin: not necessarily a troll, but a rather trying person
15:49:20 <copumpkin> sjanssen: ah
15:49:30 <psal> > round 1234.5
15:49:37 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
15:49:40 <sinelaw> @type liftA2
15:49:45 <lambdabot>   1234
15:49:45 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
15:49:45 <sinelaw> > liftA2 round (0.3,0.5)
15:49:50 <lambdabot>   No instance for (GHC.Real.Integral (b -> c))
15:49:50 <lambdabot>    arising from a use of `GHC....
15:49:57 <sjanssen> aep: you want to cross-compile from what to what?
15:50:06 <aep> sjanssen: from 32 to 64
15:50:10 <sinelaw> > liftA2 round (0.3,2.5)
15:50:10 <copumpkin> sinelaw: what are you trying to do?
15:50:13 <lambdabot>   No instance for (GHC.Real.Integral (b -> c))
15:50:13 <lambdabot>    arising from a use of `GHC....
15:50:19 <chrisdone> > uncurry (liftA2 round) (0.2,2.5)
15:50:21 <aep> actually, why am i even doing this, i could just run in 32bit mode
15:50:21 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:50:22 <lambdabot>    `GHC.Real.RealFrac a'
15:50:22 <lambdabot>    ...
15:50:24 <gwern> aep: you may need to rebuild the deps, like build pandoc without highlighting
15:50:35 <gwern> aep: or maybe 6.12 will help you, with its dynamic linking
15:50:42 <aep> nah, i'll go setup a 32bit target.
15:50:46 <gwern> since most of the memory usage is due to linking, and static at that
15:50:46 <sinelaw> @hoogle (a->b) -> (a,a) -> (b,b)
15:50:48 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:50:48 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
15:50:48 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
15:50:53 <chrisdone> wait what
15:50:56 <copumpkin> sinelaw: join (***)
15:51:00 <Saizan> aep: it'll consume less memory in 32bit mode, too
15:51:03 <chrisdone> sinelaw: round doesn't take two args heh
15:51:05 <aep> can i just copy over ~/.cabal and be done with it?
15:51:15 <copumpkin> > join (***) round (0.2, 2.5)
15:51:17 <lambdabot>   (0,2)
15:51:17 <sinelaw> @type join (***)
15:51:18 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:51:21 <sinelaw> ah
15:51:21 <sinelaw> thanks
15:51:29 <Saizan> aep: copy over?
15:51:34 <gwern> aep: you'd need ,ghc too wouldn't you...
15:51:43 <sinelaw> @pl (join (***))
15:51:43 <lambdabot> join (***)
15:51:44 <aep> right
15:51:45 <sinelaw> wow.
15:51:49 <aep> i'll try. thnks
15:51:57 <Saizan> aep: you'd just have to copy the built binary there
15:51:58 <sjanssen> aep: copying .cabal over will only work under very specific circumstances
15:52:13 <Saizan> aep: the haskell libs are linked statically in it
15:52:23 <sjanssen> aep: unless the machines are the same, I wouldn't try it
15:52:23 <aep> Saizan: right.. i keep forgetting haskell does native binaries ...
15:52:26 <mreh> Segmentation Fault?!
15:52:32 <mreh> i thought I'd left those behind
15:52:47 <mreh> ghci quit with a seg fault
15:52:49 <Saizan> mreh: using some C binding?
15:52:52 <sinelaw> @hoogle join
15:52:53 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
15:52:53 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
15:52:53 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
15:53:03 <necroforest> Anyone here familiar with hmatrix?
15:53:12 <necroforest> I'm getting the following exception: *** Exception: nonconformant matrices in liftMatrix2'
15:53:29 <mreh> Saizan, quite likely, I keep getting "Thread blocked indefinitely"
15:53:51 <HaskellLove> copumpkin so for this case, the grid has 20 downs and 20 rights, and i need to combine them in FORM of 40? isnt this permutation problem because ordering matters?
15:54:11 <ivanm> necroforest: they're probably not the same size
15:54:15 <Saizan> mreh: that's when a thread is blocked reading on a MVar and no other thread has a reference to it
15:54:43 <mreh> Saizan: must be a HGL thing, I don't even use threads
15:55:07 <necroforest> oh hmm
15:55:36 <copumpkin> HaskellLove: ordering doesn't matter though. You have 40 steps, but think of it this way instead: you have 20 choices to make, really. The others are implied by your first choices. So all you really need to choose is which 20 of the 40 steps you want to move right in
15:55:41 <Saizan> well, you always use the main thread, but it's likely HGL fault
15:56:09 <shaz> why isn't there an instance Read a => b -> a ?
15:56:21 <copumpkin> shaz: how would that work?
15:56:39 <copumpkin> oh, Read a => Read (b -> a) ?
15:56:40 <HaskellLove> copumpkin... hmmm... so it is like in 1x1 grid, if you choose one step the path is implied right?
15:56:40 <shaz> it would read functions, like \x -> ...
15:56:43 <copumpkin> it would be const?
15:57:20 <shaz> what would be const?
15:57:38 <copumpkin> HaskellLove: well say you have a path of 8 steps, and I tell you that I'm moving right on step 0, 4, 5, and 7. It's pretty obvious from that which steps I'm moving down on
15:57:45 <copumpkin> shaz: how would the instance look?
15:57:57 <shaz> it would probably require some sort of voodoo
15:58:14 <copumpkin> I think the only way to write that function would be to sell your soul to the devil
15:58:16 <HaskellLove> for 2x2 grid you have 4 steps, but you choose 2 rest is implied? if you have 3x3 grid you choose 6 steps rest is implied
15:58:26 <sjanssen> shaz: there you have the reason, voodoo would be required to write that function
15:59:04 <Saizan> wouldn't you just need to write a simple haskell meta-interpreter?
15:59:11 <sjanssen> actually, I think you can have a Read instance for functions
15:59:19 <sjanssen> it's Show that you can't reasonably do
15:59:21 <copumpkin> shaz: how about Show a, Read b, Enumerable a => Read (b -> a) ?
15:59:26 <copumpkin> how would show work?
15:59:28 <copumpkin> I mean read?
15:59:43 <copumpkin> whoops I got the function backwards
15:59:45 <copumpkin> but you get the idea
16:00:16 <shaz> why would a need to be enumerable?
16:00:25 <copumpkin> I meant b
16:00:30 <copumpkin> and Read and Show backwards too
16:00:48 <shaz> why would b need to be enumerable?
16:00:49 <copumpkin> oh I guess I was thinking of the show instance
16:01:16 <copumpkin> so you'd just need Read a, Read b => Read (a -> b) ?
16:01:25 <HaskellLove> the choose function, it does combination?
16:01:31 <copumpkin> HaskellLove: it's not built in
16:01:34 <shaz> yeah, I guess
16:01:34 <Saizan> (not sure if you could actually make it work via Read, you'd need to spot where the variable occurs)
16:01:35 <copumpkin> but yes
16:01:51 <dolio> Show/Read is for generating/reading valid Haskell expressions.
16:02:09 <copumpkin> dolio: so you could write \x -> case x of ... -> ...; ... -> ...
16:02:20 <HaskellLove> ok i will write mine: choose n k = n!/ k! * (n-k)!
16:02:33 <copumpkin> HaskellLove: ! isn't a valid haskell function
16:02:38 <dolio> Yeah, I suppose that'd work.
16:02:39 <copumpkin> you can make it one with an extension
16:02:46 <HaskellLove> i know will do it now
16:03:00 <shaz> so it's doable?
16:03:02 <copumpkin> so Read a, Read b => Read (a -> b); Show a, Show b, Enumerable a => Show (a -> b)
16:03:23 <shaz> I don't even think you need Read a for ->
16:03:26 <dolio> (Read a, Read b) => Read (a -> b) wouldn't be right, though.
16:03:34 <copumpkin> dolio: why not?
16:03:38 <sjanssen> copumpkin: the first isn't quite right
16:03:41 <dolio> If you're going read back in "\x -> case x of ...".
16:03:58 <dolio> copumpkin: Because you need to show the argument, and search for the case it corresponds to.
16:04:09 <copumpkin> dolio: oh, I was going to read them all into a map
16:04:16 <sjanssen> what you need is a new class that reifies the type -- constructors, etc.
16:05:03 <dolio> Hmm, I guess that works.
16:05:04 <copumpkin> dolio: but I see, I'd then need Eq/Ord
16:05:21 <copumpkin> a Show constraint on the domain would be prettier
16:05:33 <copumpkin> but if you can show it, you can probably Eq it
16:05:41 <sjanssen> instance (Reify a, Reify b) => Read (a -> b) -- this plus the source code of a Haskell compiler should be able to read all functions
16:05:47 <copumpkin> lol
16:06:12 <copumpkin> shaz: what were you thinking of?
16:06:13 <sjanssen> copumpkin: won't your solution only be able to read some functions?
16:06:25 <copumpkin> sjanssen: not sure, why?
16:07:08 <sjanssen> copumpkin: say "const . Left".  Read on the type arguments doesn't seem sufficient
16:07:21 <copumpkin> that's polymorphic though
16:07:40 <DigitalKiwi> what does function composition mean?
16:07:45 <kmc> @src (.)
16:07:45 <lambdabot> (f . g) x = f (g x)
16:07:49 <sjanssen> but it won't even work if we give it a monomorphic type like "Int -> Either Int Char"
16:07:52 <kmc> ^^^^ composition of f and g
16:08:19 <copumpkin> sjanssen: why not?
16:09:07 <kmc> > now
16:09:08 <lambdabot>   Not in scope: `now'
16:09:20 <shaz> copumpkin, I was thinking that it would be great to be able to read lambdas :o
16:09:28 <sjanssen> copumpkin: the Read type constraint doesn't give us enough information to know what that Left is
16:09:56 <sjanssen> Read can read "Left x", but knows nothing about "Left"
16:10:05 <copumpkin> > read "Left 5" :: Either Int char
16:10:06 <lambdabot>   Could not deduce (GHC.Read.Read char) from the context ()
16:10:07 <lambdabot>    arising from a...
16:10:15 <copumpkin> > read "Left 5" :: Either Int Char
16:10:16 <lambdabot>   Left 5
16:10:22 <copumpkin> sjanssen: hmm, I still don't get it :(
16:11:36 <kmc> shaz, you can write that Read instance with hint :)
16:12:19 <sjanssen> copumpkin: I don't know how to articulate this better
16:12:23 <copumpkin> sjanssen: so your Int -> Either Int Char function would get Show'd as "(\x -> case x of 0 -> Left 5; 4 -> Right 'a')"
16:12:26 <copumpkin> for example
16:12:45 <sjanssen> copumpkin: and Read would only be able to read functions in this form?
16:12:54 <copumpkin> sjanssen: yeah, that's what I was proposing
16:13:14 <sjanssen> copumpkin: okay, so that will only read a subset of functions
16:13:47 <copumpkin> nothing could read all functions
16:14:03 <sjanssen> copumpkin: yes, something can: a Haskell compiler
16:14:09 <kmc> not uncomputable functions
16:14:28 <kmc> you can write a Read instance for all computable functions using hint
16:14:32 <sjanssen> okay, functions which have Haskell source code
16:14:45 <copumpkin> sjanssen: yeah, but I was trying to stay within haskell :P
16:15:04 <dons> bos: can you push your uvector changes?
16:15:04 <sjanssen> copumpkin: you can write a Haskell compiler in Haskell
16:15:15 <copumpkin> sjanssen: you know what I mean :P
16:16:34 <HaskellLove> copumpkin so the solution for 20x20 grid is: there are 40 steps, two elements LEFT and RIGHT, I wrote a function choose n k, so what now
16:16:58 <copumpkin> HaskellLove: I'm not going to hold your hand through this :)
16:17:30 <jlouis> HaskellLove: projecteuler problems?
16:17:43 <HaskellLove> jlouis> yeah man 15 now
16:18:05 <HaskellLove> having combinatorics mental breakdown...
16:18:14 <ezyang> 2 CHOOSE 3
16:18:41 <kmc> you might want to see a doctor about these frequent maths-induced mental breakdowns
16:20:56 <kmc> @yhjulwwiefzojcbxybbruweejw
16:20:57 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:21:02 <HaskellLove> choose 40 20 this is the solution?
16:21:12 <byorgey> HaskellLove: you have to choose which 20 out of the total 40 steps are going to be LEFT.
16:21:20 <byorgey> the others obviously have to be RIGHT.
16:21:42 <copumpkin> kmc: ???
16:21:46 <kmc> @yhjulwwiefzojcbxybbruweejw
16:21:47 <lambdabot> "\"#$%&'()*+,\""
16:21:48 <kmc> @yhjulwwiefzojcbxybbruweejw
16:21:48 <lambdabot> Just 'J'
16:21:54 <copumpkin> wow
16:21:57 <HaskellLove> kmc is having mental breakdwons
16:22:01 <kmc> don't ask me
16:22:04 <kmc> i just found it
16:22:07 <jlouis> nono :)
16:22:11 <copumpkin> it's generating random values of random types :o
16:22:15 <dolio> @v
16:22:15 <lambdabot> "\""
16:22:25 <kmc> no, it always chooses (Just 'J') for Maybe Char
16:22:26 <kmc> @yhjulwwiefzojcbxybbruweejw
16:22:27 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
16:22:28 <kmc> @yhjulwwiefzojcbxybbruweejw
16:22:29 <copumpkin> oh
16:22:29 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
16:22:41 <copumpkin> looks like the result of some unsafeCoercing or something :)
16:22:47 <byorgey> > fix show
16:22:49 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:22:54 <kmc> > fix error
16:22:55 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
16:22:59 <copumpkin> > fix (interleave [0..])
16:23:00 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
16:23:05 <HaskellLove> byorgey so i should do choose 40 20?
16:23:17 <kmc> > fix (interleave ['a'..'z'])
16:23:18 <lambdabot>   "aabacbdaecfbgdhaiejckflbmgndohpaqiresjtcukvfwlxbymzgndohpaqiresjtcukvfwlxb...
16:23:22 <byorgey> HaskellLove: if that will compute the number of ways to choose 20 out of 40 things, yes
16:23:30 <kmc> HaskellLove, why don't you try it instead of asking us at every single step?
16:23:33 <copumpkin> HaskellLove: you should type the letter c, followed by the letter h, followed by the letter o, followed by the letter o
16:23:41 <dons> jlouis: so is conjure coming back?
16:23:46 <jlouis> dons: mmm
16:23:47 <dons> http://twitter.com/jlouis666/statuses/6712801785 ...
16:23:58 <copumpkin> HaskellLove: followed by the letter s, followed by e, followed by ' ', followed by 40, and finally 20
16:24:19 <byorgey> copumpkin: I'm confused, 40 is not a letter
16:24:20 <HaskellLove> well euler is down so i cant test if that was the solution that is why i asked
16:24:30 <copumpkin> byorgey: I stopped saying letter :P
16:24:31 <jlouis> dons: if the Erlang variant I wrote and the Haskell version is equally sized, we are about 1/3 of the way :)
16:24:40 <kmc> then wait, or find one of the numerous solutions online
16:24:40 <copumpkin> HaskellLove: it's been back up for the past couple of hours...
16:24:46 <dolio> yhjul... are quotes from a while back (before I was here) from lambdabot.
16:24:50 <ezyang> whoa, failed pattern matches in monads call fail
16:25:02 <HaskellLove> If you are seeing this page, you are on the old server. Try clearing your browser cache and restarting your modem/router. Or you can open Command Prompt, and type in: ipconfig /flushdns Then retry.  copumpkin
16:25:05 <copumpkin> ezyang: yep! turn off implicit prelude and you can do all sorts of evil
16:25:11 <byorgey> copumpkin: euler is down for me too.
16:25:19 <dolio> The evaluator used to store expressions in a variable called "v". So if you used "v" in the things you evaluated, you could get weird output.
16:25:32 * ezyang is still trying to figure out interesting applications of the list monad 
16:25:39 <jlouis> dons: code on github btw: http://github.com/jlouis/haskell-torrent
16:25:42 <dolio> After people caused trouble with that, they changed the name to yhjulwwiefzojcbxybbruweejw.
16:25:57 <copumpkin> lol
16:26:00 <kmc> hahaha
16:26:12 <copumpkin> ezyang: I have two favorite ones
16:26:22 <ezyang> copumpkin: ooh, please share
16:26:23 <kmc> > filterM (const [False ..]) "abcd"
16:26:24 <lambdabot>   ["","d","c","cd","b","bd","bc","bcd","a","ad","ac","acd","ab","abd","abc","...
16:26:29 <copumpkin> ezyang: square roots and NFAs
16:26:33 <kmc> > unwords $ filterM (const [False ..]) "abcd"
16:26:34 <lambdabot>   " d c cd b bd bc bcd a ad ac acd ab abd abc abcd"
16:26:40 <byorgey> dolio: ah, thanks for the history lesson, I never knew what yhjulwwiefzojcbxybbruweejw was =)
16:26:42 <copumpkin> ezyang: but really, any nondeterministic computation
16:27:01 <copumpkin> ezyang: so sqrt only tells half the story, right?
16:27:08 <copumpkin> > sqrt 4
16:27:09 <lambdabot>   2.0
16:27:13 <copumpkin> where's -2?
16:27:42 <ezyang> kmc: Huh.
16:27:42 <copumpkin> @let realsqrt x = [sqrt x, negate (sqrt x)]
16:27:44 <lambdabot>  Defined.
16:28:02 <copumpkin> ezyang: don't look at kmc, he's like a siren trying to tempt odysseus
16:28:10 <copumpkin> > realsqrt 4
16:28:11 <lambdabot>   [2.0,-2.0]
16:28:14 <xerox> oh noes, give me back the monodromic function
16:28:22 <zygoloid> > realsqrt 0
16:28:23 <lambdabot>   [0.0,-0.0]
16:28:27 <copumpkin> shh :P
16:28:32 <edwardk1> @let realsqrt x = nub [sqrt x, negate (sqrt x)]
16:28:33 <lambdabot>  <local>:4:0:
16:28:33 <lambdabot>      Warning: Pattern match(es) are overlapped
16:28:33 <lambdabot>               In...
16:28:36 <edwardk1> bah
16:28:41 <copumpkin> lol
16:28:41 <zygoloid> > realsqrt (-1)
16:28:43 <lambdabot>   [NaN,NaN]
16:28:48 <edwardk1> > realsqrt 0
16:28:49 <lambdabot>   [0.0,-0.0]
16:28:56 <edwardk1> thats what you need to fix ;)
16:28:57 <zygoloid> ah well it did say /real/ square root :)
16:28:58 <dolio> > realsqrt (-1) :: Complex Double
16:28:59 <copumpkin> ezyang: so now, we know that 4th root is sqrt of sqrt, so we can write that
16:28:59 <lambdabot>   Couldn't match expected type `Data.Complex.Complex
16:28:59 <lambdabot>                         ...
16:29:02 <xerox> hehe
16:29:08 <kmc> > text . map ((['a'..'z'] !!) . (`mod` 26)) $ fix ((0:) . scanl (+) 1)
16:29:12 <zygoloid> > realsqrt (-1:+0)
16:29:13 <copumpkin> @let real4throot = realsqrt <=< realsqrt
16:29:16 <kmc> > map ((['a'..'z'] !!) . (`mod` 26)) $ fix ((0:) . scanl (+) 1)
16:29:17 <lambdabot>  Terminated
16:29:20 <lambdabot>   mueval: ExitFailure 1
16:29:20 <edwardk1> clearly it should just return [] for the -1 case as well
16:29:21 <ivanm> > realsqrt ((-1) +: 0)
16:29:22 <zygoloid> :o
16:29:23 <lambdabot>   mueval: ExitFailure 1
16:29:25 <lambdabot>   mueval-core: Time limit exceeded
16:29:26 <lambdabot>  Defined.
16:29:28 <copumpkin> @let real4throot = realsqrt <=< realsqrt
16:29:29 <lambdabot>  <local>:6:0:
16:29:29 <lambdabot>      Multiple declarations of `L.real4throot'
16:29:29 <lambdabot>      Declared at:...
16:29:33 <copumpkin> holy fuck
16:29:34 <kmc> > map ((['a'..'z'] !!) . (`mod` 26)) $ fix ((0:) . scanl (+) 1)
16:29:36 <lambdabot>   "abbcdfinvidloznmzlkvfaffkpzonbopdsvnivdybzazzyxvsnfsxpmbnobpqfvavvqlbmnzml...
16:29:39 <ivanm> > sqrt ((-1) +: 0)
16:29:40 <copumpkin> > real4throot 16
16:29:41 <lambdabot>   Not in scope: `+:'
16:29:42 <lambdabot>   [2.0,-2.0,NaN,NaN]
16:29:45 <ivanm> > sqrt ((-1) :+ 0)
16:29:47 <lambdabot>   0.0 :+ 1.0
16:29:52 <copumpkin> > real4throot (16 :: Complex Double)
16:29:52 <xerox> copumpkin: then you'd be feeding negative numbers
16:29:53 <lambdabot>   [2.0 :+ 0.0,(-2.0) :+ (-0.0),(-0.0) :+ 2.0,0.0 :+ (-2.0)]
16:29:57 <ivanm> > realsqrt ((-1) :+ 0)
16:29:58 <lambdabot>   [0.0 :+ 1.0,(-0.0) :+ (-1.0)]
16:30:01 <copumpkin> ezyang: tada
16:30:07 <kmc> > map ((".- " !!) . (`mod` 3)) $ fix ((0:) . scanl (+) 1)
16:30:07 <ivanm> negative 0! \o/
16:30:08 <lambdabot>   ".-- .  -.-- .  -.-- .  -.-- .  -.-- .  -.-- .  -.-- .  -.-- .  -.-- .  -.-...
16:30:10 * ezyang is slightly confused, but thinks it makes sense 
16:30:16 <copumpkin> :P
16:30:23 <copumpkin> ezyang: have you come across NFAs?
16:30:44 <ezyang> I... think I implemented one.
16:30:55 <ezyang> In fact, I was asking for help optimizing it here, and was pointed to logic
16:30:58 <copumpkin> read list as N
16:31:13 <kmc> > -0.0 == 0.0
16:31:15 <lambdabot>   True
16:31:28 <kmc> > 0*(-1.0) == 0.0
16:31:29 <lambdabot>   True
16:31:32 <copumpkin> >>= does exactly what you want for deciding on your successors
16:31:38 <zygoloid> @@ (@undef) (@let realsqrt x | x < 0 = [] | x == 0 = [0] | otherwise = [sqrt x, negate (sqrt x)]) (@let real4throot = realsqrt <=< realsqrt)
16:31:39 <lambdabot> Plugin `compose' failed with: Unknown command: "undef"
16:31:39 <DigitalKiwi> shouldn't that be false?
16:31:42 <kmc> > (1/0.0) == (1/0.0)
16:31:44 <lambdabot>   True
16:31:46 <zygoloid> @@ (@undefine) (@let realsqrt x | x < 0 = [] | x == 0 = [0] | otherwise = [sqrt x, negate (sqrt x)]) (@let real4throot = realsqrt <=< realsqrt)
16:31:48 <lambdabot>  Defined.
16:31:48 <lambdabot>  Defined.
16:31:52 <kmc> > (0.0/0.0) == (0.0/0.0)
16:31:54 <lambdabot>   False
16:31:59 <zygoloid> > real4throot 16
16:32:01 <lambdabot>   [2.0,-2.0]
16:32:02 <kmc> > let x = 0.0 / 0.0 in x == x
16:32:03 <lambdabot>   False
16:32:07 <copumpkin> ezyang: that filterM (const [False, True]) is also neat. It's basically saying for each element, _both_ choose it and don't choose it
16:32:26 <kmc> @@ ?
16:32:26 <lambdabot> Plugin `compose' failed with: Unknown command: ""
16:32:34 <ezyang> copumpkin: Ohh! That makes more sense
16:32:51 <copumpkin> ezyang: and the list monad takes care of making it work beautifully, and gives you all subsets
16:33:04 <copumpkin> the set monad would also be nice, if it existed
16:33:09 <ezyang> It's a little hard to get signal because of all the lambdabot spew
16:33:09 <kmc> > filterM (\x -> if odd x then [True] else [True, False]) [1..4]
16:33:10 <lambdabot>   [[1,2,3,4],[1,2,3],[1,3,4],[1,3]]
16:33:15 <copumpkin> ezyang: yeah :P
16:33:37 <zygoloid> ezyang: try jiggling the aerial around a bit
16:33:38 <kmc> > filterM (\x -> if odd x then [True] else [True, True, False]) [1..4]
16:33:40 <lambdabot>   [[1,2,3,4],[1,2,3,4],[1,2,3],[1,2,3,4],[1,2,3,4],[1,2,3],[1,3,4],[1,3,4],[1...
16:33:44 <adekoba> hello: cabal install base reports: internal error: impossible
16:33:48 <adekoba> how do i fix this?
16:33:57 <kmc> engage infinite improbability drive
16:34:01 <HaskellLove> yo guys give me some book recomendations for math for computer scientists
16:34:14 <dcoutts_> adekoba: you don't. You don't want to install base.
16:34:21 <jlouis> @src filterM
16:34:22 <lambdabot> Source not found. Take a stress pill and think things over.
16:34:34 <adekoba> dcoutts_: oh. it was reported as being outdated by cabal upgrade
16:34:42 <adu> HaskellLove: I <3 Math
16:34:46 <adekoba> dcoutts_: does my linux distro do that for me?
16:34:50 <dcoutts_> adekoba: that may be, but you cannot upgrade it. It's fixed with the ghc version.
16:34:56 <adu> HaskellLove: maybe I can help you :)
16:34:58 <adekoba> dcoutts_: ah ok. thanks.
16:35:41 <HaskellLove> adu yeah tell me some math books i got pissed off forgeting things like these combinatorics shit, which i studied in high school
16:35:44 <copumpkin> HaskellLove: there are people posting links to a math tutorial site all the itme on reddit but I forgot what it's called
16:35:52 * ezyang is afk for a sec 
16:36:02 <copumpkin> HaskellLove: here, http://www.khanacademy.org/
16:36:07 <adu> HaskellLove: for combinatorics, I can only think of one
16:36:09 <copumpkin> HaskellLove: study that and I'll see you next week ;)
16:36:12 <adu> HaskellLove: Comtet
16:36:29 <HaskellLove> adu that is the author? Comtet
16:36:55 <copumpkin> HaskellLove: the site I linked to is a million video lectures about good stuff. Note that I haven't ever watched one of them, but redditors seem to approve
16:37:49 <adu> HaskellLove: http://www.amazon.com/Advanced-Combinatorics-Finite-Infinite-Expansions/dp/9027703809
16:38:23 <copumpkin> not sure he needs advanced combinatorics ;)
16:38:36 <adu> almost every article or book that I've read about comb. references that book
16:38:53 <adu> it is _the_ book
16:39:03 <HaskellLove> copumpkin i knew other sites like that but this one is frickin crazy, mit courseware, stanford, also search computer science video lectures on google will give you some others
16:39:21 <HaskellLove> copumpkin i love you man thank you :D
16:39:21 <copumpkin> HaskellLove: yeah, I've seen itunes U for example, and those others :)
16:39:35 <copumpkin> iTunes U might also be good for you
16:39:35 <adu> HaskellLove: also, a good free one is "Generatingfunctionology"
16:40:45 <adu> copumpkin: everyone secretly needs advanced combinatorics ;)
16:40:49 <copumpkin> lol
16:40:52 <copumpkin> it's true
16:41:03 <xerox> For starters I recommend Bridge to Abstract Mathematics http://www.science.marshall.edu/lawrence/syllabi/bam.pdf
16:41:08 <copumpkin> but people might need basic combinatorics first
16:41:27 <copumpkin> well if y'all are going to recommend all these easy books, I might as well throw in that book Cale loves with the ridiculous diagram
16:41:32 <adu> copumpkin: basic combinatorics = binomial coefficient, everything else is advanced
16:41:33 <copumpkin> oh, and TTT
16:42:02 <HaskellLove> copumpkin iTunes U what is it?
16:42:06 <xerox> binomials have lots of secrets :)
16:42:29 <adu> i know, you could fill a library with binomial coefficients
16:42:29 <copumpkin> HaskellLove: a partnership apple made with a bunch of universities so you can watch many courses online. MIT opencourseware and stuff are included, obviously, but there are many others
16:43:20 <HaskellLove> what software to use for it in ubuntu?
16:43:28 <copumpkin> wine + itunes
16:43:29 <copumpkin> ;)
16:43:44 <adu> xerox: imho, the instant you move from binomials to Stirling numbers, that is when it becomes "advanced"
16:44:19 <HaskellLove> hehe
16:44:27 <Cale> "Generatingfunctionology" is an unfortunate book.
16:44:37 <adu> Cale: why?
16:44:51 <Cale> It somehow manages to completely miss the big picture of the material that it covers.
16:45:08 <dolio> Also they forgot to capitalize the title.
16:45:14 <edwardk1> dolio: haha
16:45:14 <copumpkin> here are a couple more easy books: http://www.math.tamu.edu/~maguiar/a.pdf
16:45:27 <adu> Cale: if by "miss the big picture" you mean "provides an alternate worldview", then I agree
16:45:37 <xerox> copumpkin: what's the title?
16:45:48 <copumpkin> xerox: didn't want to scare people
16:45:57 <xerox> oops.
16:46:43 <Cale> Rather than developing the connection between combinatorial operations on sets, and operations on the ring of formal power series, it sort of spends a whole lot of time mucking about on the algebraic side of things without providing a clear picture of how generating series are connected to the combinatorics.
16:46:54 <copumpkin> here's the other easy book: http://www.case.edu/artsci/math/wells/pub/pdf/ttt.pdf
16:47:03 <copumpkin> you know, just to get you started n stuff
16:47:17 <Cale> There were also a lot of proofs which were way way harder than they had to be because of that.
16:48:12 <ezyang> back
16:48:23 <adu> i like short proofs
16:48:50 <Cale> I seem to recall that it gave a development of the generating series for set partitions which was an absolutely ridiculous page of meaningless algebra rather than simply using composition.
16:49:04 <adu> but i like long proofs too, especially when I understand what is going on, I tend to not understand short proofs
16:49:19 <BrianB04_> I have a question: Could someone explain to me the difference between a value constructor and a type constructor and why you need both?
16:49:32 <copumpkin> xerox: here's a sample from that book: http://snapplr.com/3vjp
16:49:41 * hackagebot upload: X11 1.5.0.0 - A binding to the X11 graphics library (SpencerJanssen)
16:49:58 <copumpkin> duh: http://snapplr.com/6mf5
16:50:00 <adu> oh I have a question
16:50:09 <xerox> copumpkin: that calls for 3d representation :)
16:50:46 <copumpkin> oh, 3d? http://snapplr.com/atkd
16:51:14 <copumpkin> http://snapplr.com/bbma... mmm cheese: http://snapplr.com/6rt6
16:51:37 <adu> I'm working on a binding to the python C API, and I noticed that there is already a language-python package, but it only provides a pure Haskell lexical representation, and I was hoping for bindings to PyDict and PyClass routines... So I was wondering what to call it... should I call the package foreign-python?
16:51:49 <xerox> haha.
16:52:01 <xerox> doorstopper diagrams
16:52:05 <HaskellLove> solving proofs is important you guys think, not just taking the math formula and continue your programming?
16:52:10 <Cale> Set partitions are sets of nonempty sets, and so you get a combinatorial decomposition P --> U \ostar (U - {{}}), where U is the usual set of unordered sets {{},{1},{1,2},...} weighted by size, and since the (exponential) generating series for finite sets is exp(x), you immediately get that the g.s. for set partitions is exp(exp(x)-1)
16:52:20 <copumpkin> HaskellLove: absolutely
16:52:24 <dolio> I need to get around to reading that book.
16:52:34 <copumpkin> dolio: for artistic inspiration?
16:52:35 <adu> HaskellLove: only when it is mission-critical
16:52:36 <jlouis> copumpkin: wonderful diagrams
16:52:59 <dolio> copumpkin: To have more than a very vague idea of what people are talking about when they say "topos".
16:53:10 <copumpkin> dolio: oh, TTT?
16:53:17 <jfoutz> is there a syntax for making a context sensitive instance? i want Eq, but i only want it to work in a particular monadic context.
16:53:19 <copumpkin> dolio: I thought you were talking about this book with the pretty pictures
16:53:20 <copumpkin> :P
16:53:23 <dolio> Isn't that where you were getting the pictures?
16:53:25 <xerox> Cale: nice
16:53:33 <Cale> It's just the composition lemma. But instead, generatingfunctionology completely botches the description of exponential generating series with some confusing decks and hands nonsense, and fails to provide or leaves until later most of the important basic results.
16:53:43 <adu> dolio: I think of Jumbo shrimp in a Wirshtire sauce
16:53:54 <copumpkin> dolio: oh no, this is the ridiculous book Cale posted the other day: Monoidal Functors, species, and Hopf algebras
16:54:03 <dolio> Ah.
16:54:05 <copumpkin> dolio: I have no clue what the first paragraph even means
16:54:11 <dolio> Well, I've been meaning to learn about species, too.
16:54:18 <dolio> But then, who hasn't?
16:54:22 <medfly> <-
16:54:25 <copumpkin> I lie, actually
16:54:30 <copumpkin> the first paragraph is pretty simple
16:54:31 <medfly> should I add that to my list? I don't know what thye are.
16:54:52 <copumpkin> dolio: were you here when people explained that list type derivation in terms of them?
16:55:01 <adu> dolio: are species related to that algebraic datatype differential thing?
16:55:05 <dolio> I don't think so.
16:55:23 <copumpkin> dolio: I remember on reddit you posted the derivation of list from 1/(1-a), and said it was weird because type quotient and difference isn't defined
16:55:32 <copumpkin> but it gave the right answer anyway
16:55:39 <copumpkin> apparently that's all explained beautifully by species, but I haven't a clue how
16:55:45 <Cale> HaskellLove: Knowing how to prove things is helpful to thinking clearly while programming, I think.
16:56:03 <Cale> HaskellLove: After all, writing programs that work and writing proofs is really the same thing.
16:56:04 <dolio> Ah, well, I'll definitely need to get on it, then.
16:56:27 <copumpkin> :)
16:56:34 <medfly> HaskellLove: warning: Cale is a mathematician
16:56:39 * copumpkin off to eat an awesome blossom
16:56:46 <jlouis> Cale: what is U \ostar (U - {{}}), in particular the \ostar. It seems somewhat familiar
16:56:50 <adu> i also like to think of myself as a mathematician
16:57:28 <stroan> medfly: there's only so much Haskell you can do, without eventually finding yourself gleeful at some really obscure mathematical results
16:57:50 <HaskellLove> Cale how is writing boring proofs same as programming?
16:57:53 <Cale> jlouis: It's a type of combinatorial composition on sets of labelled objects
16:58:11 <stroan> HaskellLove: the answer to that question is amazing
16:58:16 <medfly> HaskellLove: I think my comment is necessary to understand Cale's view on programming.
16:58:16 <stroan> but I'll let someone else answer
16:58:20 <Apocalisp> HaskellLove: See the Curry-Howard isomorphism.
16:58:24 <jlouis> Cale: ok, that struck out the familar, thanks :)
16:58:46 <adu> HaskellLove: http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
16:58:47 <HaskellLove> Apocalisp> i have read it on wiki before and never understood why
16:59:13 <u_quark> Curry-Howard is the way to go when a programmer complains about math :)
16:59:15 <dolio> Programmers just write proofs of very boring theorems.
16:59:26 <Apocalisp> HaskellLove: A program is a proof, and the hypothesis that it proves is a type for the program.
16:59:48 <u_quark> dolio: yes, but in a non-boring way most of the times...
16:59:58 <dolio> Yes, of course. :)
17:00:01 <jlouis> This is the point in time where we introduce either Coq og Agda to make the poor soul mentally unstable :)
17:00:10 <dolio> Very elaborate proofs of trivial theorems. :)
17:00:13 <u_quark> lol
17:00:46 <Cale> jlouis: You consider each object of weight n to have its subobjects (whatever you're counting to get the weight) labelled with {1,...,n} in some fashion. To compose two such sets A \ostar B, you take, for each labelled object a in A of weight n, a choice of n objects of B, and they replace the labels in the A object, and have their labels shifted up appropriately so as to be disjoint
17:00:47 <HaskellLove> so where do i start to realize this fact, that programming is proof prooving
17:01:04 <Cale> (so that you get a proper labelled object each time)
17:01:17 <Cale> and this corresponds to taking the composite of exponential generating series
17:01:45 <u_quark> HaskellLove: probably when you start programming in Coq or Agda...
17:02:01 <adu> coq is hard
17:02:05 <HaskellLove> i will now
17:02:13 <jlouis> adu: No :)
17:02:28 <u_quark> Agda is interesting...
17:02:31 <adu> i've tried using coq, and I can't figure out the difference between a strategy and a tactic
17:02:44 <Apocalisp> HaskellLove: Take a simple function type for example, (Int -> String).
17:03:06 <Apocalisp> HaskellLove: Does there exist a function that takes an Int and gives a String?
17:03:14 <jlouis> Cale: there is far too much digging for me to understand that. Subobject? weight? Labelling? I better go read up on those if I need to have a chance understanding that
17:03:18 <Apocalisp> Can integers be turned into strings/
17:03:25 <HaskellLove> i will get books on agda and coq now, you mathematicians pissed me off making me feel inferior and stupid :D
17:03:34 <medfly> @type (show 3)
17:03:35 <lambdabot> String
17:03:51 <jlouis> adu: Twelf is sinisterly evil. Coq is just evil.
17:03:56 <Apocalisp> @type show
17:03:57 <lambdabot> forall a. (Show a) => a -> String
17:04:01 <HaskellLove> Apocalisp well why not?
17:04:09 <qwr> is there non-terminating proofs also? ;)
17:04:10 <Apocalisp> HaskellLove: Prove it.
17:04:20 <Cale> jlouis: ah, okay. It would help to already know what exponential generating series are about
17:04:38 <Cale> jlouis: Are you familiar with ordinary generating series?
17:04:58 <adu> HaskellLove: don't take it personally, that is the secret desire of all mathematicians, don't let them win!
17:05:02 <HaskellLove> Apocalisp how about you got a phone book and your name is number 40, so f 40 will give me Apocalisp... there you go
17:05:02 <HaskellLllama> @djinn (Int -> String)
17:05:03 <lambdabot> Error: Undefined type Int
17:05:05 <jlouis> Cale: formal power series, yes. It is too late here for my brain to rock it. Some other day perhaps
17:05:23 <Apocalisp> HaskellLove: The way you prove that Ints can be turned into Strings is to write program that turns Ints into Strings. The program is the proof!
17:05:24 <HaskellLove> adu  i knew it man :D
17:05:36 <Cale> jlouis: Sure, let me know if you'd like me to explain it at some point
17:05:44 <jlouis> Cale: will do!
17:06:03 <medfly> Apocalisp: it's just a mathematician view of things and it's a common view here because Haskell is popular among mathematicians.
17:06:06 <HaskellLove> Apocalisp wooow, and i thought like... hahaha... i expected to hear some Marsian stuff
17:06:47 <Apocalisp> medfly: I wouldn't know about that. I'm not a mathematician.
17:07:19 <Cale> HaskellLove: The connection actually runs pretty deep though. If you write your proofs in a particular way, it's possible to extract programs from them which actually work :)
17:07:22 <medfly> saying that programming is like proofs makes them feel at home. so much so, that they worked on having a proof that it's similar. :)
17:07:30 <jlouis> adu: I've never encountered the term strategy in Coq. But part of the lure is that you can combine tactics together with a matching language. That gives some pretty clever tactics able to solve many mundane proofs in one go
17:07:45 <HaskellLove> Cale I feel what you talk but i dont understand yet
17:07:49 <jlouis> perhaps you by this mean a strategy?
17:08:03 <bos> dcoutts: ping
17:08:04 <Apocalisp> medfly: Programs and proofs are isomorphic. This is another way of saying that they are exactly the same.
17:08:29 <dcoutts_> bos: pong
17:08:42 <HaskellLove> Apocalisp i would rather save the programer soul and tell him math proof is math proof and program is program
17:08:49 <bos> dcoutts_: do you know what to do when building ghc and ghc-cabal starts getting confused?
17:08:58 <bos> dcoutts_: specificalluy, i'm trying to rebuild base
17:09:06 <Apocalisp> HaskellLove: Then you're just maintaining an illusion. There is no santa claus. Sorry.
17:09:09 <medfly> Cale tells me I should like mathematics because I like programming
17:09:11 <bos> dcoutts_: and ghc-cabal says that HsBase.h isn't there
17:09:12 <Cale> HaskellLove: Okay, so the most basic part of the connection is that if you can prove that B is true given A, then you have a proof that A implies B, which is commonly written A -> B
17:09:20 <medfly> "it's the same!"
17:09:27 <bos> oops
17:09:36 <Freejack> Anyone here working try the Clean compiler?
17:09:43 <Cale> HaskellLove: This corresponds to the fact that if you can construct a value of type B from a value of type A, then you can write a lambda to get a value of type A -> B
17:09:48 <Freejack> errr...working on or trying.
17:09:51 <dcoutts_> bos: I'm not sure how the ghc build system and ghc-cabal interact exactly. I didn't write ghc-cabal, it's just a prog that uses the Cabal library.
17:09:56 <jlouis> medfly: apart from the fact that you can't have infinite loops in the usual sense, but I digress
17:10:03 <bos> dcoutts_: ah
17:10:08 <BrianB04_> medfly: Well, I hate math, and I program pretty darn well. Now, I can't build a compiler, or an AI, or graphics software, but hey.
17:10:17 <jlouis> bed :)
17:10:18 <Apocalisp> jlouis: You can't have infinite loops in valid programs either ;)
17:10:28 <Cale> HaskellLove: Similarly, if you have a proof that A -> B, and a proof that A is true, then you get a proof that B is true. If you have a value of type A -> B, and a value of type A, you can apply the function to the value to get a value of type B
17:10:30 <dcoutts_> bos: what are you doing exactly?
17:10:32 <medfly> Apocalisp: not even one to get user input?
17:10:47 <dcoutts_> bos: building base in the context of a ghc build or trying to build base separately?
17:10:48 <bos> dcoutts_: i'm just trying to run make in the base directory
17:10:57 <bos> dcoutts_: inside a ghc tree
17:11:16 <Cale> HaskellLove: Behind every logical argument, there is a program.
17:11:19 <HaskellLove> Cale well ok, Prolog, Logic, what you talk is not common sence ... and yeah i have studied logic and temporal situation and bla bla other logics which are basically proof systems
17:11:29 * ddarius doesn't think Haskell is popular among mathematicians at all.
17:11:39 <dcoutts_> bos: but presumably there's some reason you're not building from the top level
17:11:41 <medfly> ddarius: I have a limited view of the Haskell community
17:11:45 <Cale> ddarius: I wish Haskell was more popular among mathematicians.
17:11:47 <HaskellLllama> the mathematicians i know do look down on Haskell
17:11:55 <bos> dcoutts_: just to make the build a little faster
17:11:55 <HaskellLove> what you talk is common sence i mean Cale sorry i "put" not above
17:11:59 <ddarius> Cale: It probably would be (but still not very popular) if more knew about it at all.
17:12:01 <Cale> medfly: Mathematics is popular amongst Haskell users :)
17:12:10 <HaskellLove> HaskellLllama why is that
17:12:11 <bos> dcoutts_: but it spontaneously broke after running for a few hours
17:12:13 <HaskellLllama> but perhaps they look down on haskell less than on other languages
17:12:15 <ddarius> Cale: That statement I will agree with.
17:12:16 <dcoutts_> bos: build from the top level but specify the targets you want
17:12:17 <HaskellLllama> HaskellLove: because it's not math
17:12:22 <bos> dcoutts_: ah
17:12:25 <Apocalisp> medfly: To get user input, we just assume that it's available immediately.
17:12:26 <dcoutts_> bos: ghc uses non-recursive make
17:12:28 <bos> dcoutts_: how?
17:12:30 <Cromulent> is anyone else having troubles installing packages using cabal on Mac OS X Snow Leopard using the latest Haskell Platform package? I keep seeing a message saying that the platform does not support x86_64 when I am using it on a Mac Pro
17:12:42 <Cromulent> so it does :)
17:12:43 <HaskellLllama> HaskellLove: and because mathematicians in general consider programming to be worthless
17:12:44 <medfly> Apocalisp: yeah, there are other ways to do it, but that's one which is valid and ok.
17:12:57 <HaskellLove> HaskellLllama> why is that?
17:12:59 <bos> dcoutts_: "make libraries/base" ??
17:13:03 <medfly> (I think)
17:13:08 <ddarius> :t const "" :: Int -> String
17:13:09 <lambdabot> Int -> String
17:13:17 <dcoutts_> bos: it'd need to be an actual file target, like the base .a lib file
17:13:21 <bos> dcoutts_: ah
17:13:22 <HaskellLove> HaskellLllama>they consider them them smarter then programers or something?
17:13:28 <bos> dcoutts_: anyway, it started working again. thanks!
17:13:29 <Apocalisp> medfly: IO String is OK. () -> String is a lie.
17:13:31 <dcoutts_> bos: if there are convenience targets for each lib then I don't know about them
17:13:35 <HaskellLllama> HaskellLove: because otherwise they would be programmers and not mathematicians, i suppose
17:13:38 <medfly> I am not talking about Haskell.
17:13:43 <dcoutts_> bos: the ghc wiki pages might say
17:13:49 <Apocalisp> err... _|_ is a lie
17:14:05 <bos> dcoutts_: i'm retargeting the threaded io manager at poll as well as select.
17:14:15 <bos> ooh, and it's compiling!
17:14:15 <dcoutts_> bos: great
17:14:34 <HaskellLove> give me book recomendations on Agda and Coq
17:14:50 <ddarius> I'm pretty sure there are no books on Agda 2 (at this point)
17:15:03 <ddarius> There is Coq'art for Coq.
17:15:04 <dcoutts_> bos: in principle it should be possible to develop a threaded io manager outside of the context of base, and integrate at the end.
17:15:26 <phr> smerdlykov has an online book about coq
17:15:49 <u_quark> imho mathematics and CS have very match in common beyond C-H isomorphism ... and I am not a mathematician
17:16:02 <phr> http://adam.chlipala.net/cpdt/
17:16:06 <adu> jlouis: oh
17:16:27 <ddarius> u_quark: Perhaps you being a mathematician would change your view.
17:16:47 <medfly> some people claim CS is just maths.
17:16:54 <dcoutts_> bos: of course it has to be in base to have System.IO etc use it, but you could access it via its native API when it's in a separate test package
17:17:21 <Cromulent> medfly: some universities certainly treat it as a maths course
17:17:29 <u_quark> I mean, implementing even the simplest program implies using some algorithms (part of CS - part of mathematics) ... in the same sense that every science that is well-defined is in some sense mathematics
17:17:30 <RadioApeShot> So I have used the Sequence monad in clojure before, but I am looking for a simple example/tutorial on how to use it in Haskell.
17:17:33 <RadioApeShot> Anyone know of such a thing?
17:17:48 <dolio> Mathematics is just CS.
17:17:59 <medfly> it's just a lot worse with CS.
17:18:04 <dcoutts_> dolio: only constructive mathematics
17:18:28 <ddarius> RadioApeShot: I presume Sequence corresponds, more or less, to Haskell's lazy lists?
17:18:36 <Cromulent> cs = maths but maths != cs
17:18:41 <HaskellLllama> u_quark: duh, "well-defined" and "mathematics" are synonymous in your statement
17:18:45 * u_quark putting alcohol in the flame
17:19:10 <medfly> bit too diluted
17:19:19 <HaskellLllama> Cromulent: see, it's statements like that why mathematicians look down on programmers.
17:19:35 <medfly> who cares.
17:19:36 <Cromulent> HaskellLllama: why would that be?
17:19:40 <ddarius> HaskellLllama: Pssh.  When did equality need to be reflexive?
17:19:41 <medfly> mathematicians are often poor.
17:19:45 <tofulivin> Why is Haskell becoming so popular?
17:19:46 <Veinor> Cromulent: replace = with ⊂
17:19:58 <medfly> tofulivin: it's not another imperative language.
17:20:04 <Cromulent> Veinor: no idea where that symbol is on my keyboard :)
17:20:09 <medfly> tofulivin: so it's not like ANY OTHER LANGUAGE in the world.
17:20:16 <u_quark> further more i feel that the way mathematician with when the make a proof is the same way a programmer thinks when writing a program (even in C)
17:20:19 <ddarius> medfly: That counts against it becoming popular...
17:20:19 <Veinor> I got it by looking up 'subset' on Wikipedia :P
17:20:19 <tofulivin> will it be the next big thing in industry?
17:20:27 <ddarius> tofulivin: No.  At least, not directly.
17:20:28 <medfly> and for
17:20:33 <RadioApeShot> ddarius: yes, I think that is right
17:20:53 <RadioApeShot> ddarius: the list monad, is what you would call it
17:21:04 <medfly> if I just wrote some imperative language, why would people learn it?
17:21:06 <ddarius> RadioApeShot: Yes.  That's the most common name in the Haskell community.
17:21:13 <RadioApeShot> ddarius: maybe that is why I can't find it via google
17:21:14 <medfly> but if it were radically different, then there's some reason.
17:21:17 <RadioApeShot> ddarius: let me check
17:21:21 <adu> tofulivin: because you can express 2 structs and 1 union i a single statement: "data Complex = CRect x y | CPolar t r"
17:21:29 <ddarius> medfly: They wouldn't.   They very likely wouldn't learn any language at all that you "just wrote" or even dedicated a lot of time to and wrote.
17:21:44 <HaskellLllama> unless medfly were Google
17:21:48 <medfly> ddarius: that's true, but there's more reason to learn the second option
17:21:50 <medfly> HaskellLllama++
17:21:53 <medfly> hahahah
17:21:59 <medfly> hi Libster !
17:22:01 <HaskellLove> will a math guy translate this to me :Agda is a dependently typed language based on intuitionistic type theory
17:22:01 <medfly> and bearded_oneder !
17:22:04 <Libster> \hi!
17:22:08 <ddarius> HaskellLllama: My point exactly.
17:22:22 <ddarius> HaskellLove: That's not math speak particularly.
17:22:37 <bearded_oneder> medfly! where have you been? :)
17:22:43 <medfly> here. hello!
17:22:55 <Libster> i heard we were trolling
17:23:00 <tofulivin> preflex: xseen Cale
17:23:00 <preflex>  Cale was last seen on freenode/#haskell 10 minutes and 58 seconds ago, saying: medfly: Mathematics is popular amongst Haskell users :)
17:23:02 <Libster> well bring on the trolling i don't see any
17:23:02 <adu> HaskellLove: "dependently typed" means that type definitions can use values, for example the (Vector n t) type takes an Integer and a Type and outputs a Type, this is impossible in Haskell
17:23:19 <Libster> why does #haskell have more users than #math wth
17:23:27 <tensorpudding`> intuitionistic type theory is pretty math
17:23:29 <HaskellLove> adu got it
17:23:39 <ddarius> Libster: Math people on IRC hang out elsewhere.
17:23:42 <adu> Libster: because the ppl in #math tend to piss people off
17:23:43 <HaskellLove> adu and the intuitionistic thing?
17:23:48 <bearded_oneder> preflex: shouldn't that be the invers,  "Haskell is popular amongst Mathematics users"?
17:23:48 <tensorpudding`> or at least, has as much of a reason to be called math as anything else
17:24:03 <medfly> bearded_oneder: preflex is a bot
17:24:04 <bearded_oneder> inverse*
17:24:08 <medfly> bearded_oneder: that's what I said!
17:24:09 <bearded_oneder> ah
17:24:13 <medfly> bearded_oneder: he claimed I was wrong.
17:24:19 <ddarius> tensorpudding`: "intuitionistic" definitely.  "type theory" more formal logic than mathematics in general.  I bet you I could find -plenty- of mathematicians who haven't even heard the term "type theory"
17:24:33 <tensorpudding`> formal logic is separate from mathematics now?
17:24:42 <medfly> I think it's philosophy
17:24:48 <medfly> (too)
17:24:52 <tensorpudding`> it's close enough
17:24:58 <ddarius> tensorpudding`: Some say so.  I don't think so, but it is somewhat specialized beyond first order logic.
17:25:06 <u_quark> speaking of strange types: can anyone tell me why i get a "Could not find module `Data.Generics': it is a member of the hidden package `base-3.0.3.1'" when trying to build type-level ?
17:25:11 <tensorpudding`> wasn't type theory developed by russell and whitehead?
17:25:55 <RadioApeShot> Is there a way to format a do on a single line?  Like if I want to try out something at the ghi prompt?
17:25:58 <ddarius> tensorpudding`: The notion of "type" was arguably introduced by them, not exactly type theory as the term is used today.
17:26:01 <adu> HaskellLove: you can safely replace intuitionistic with algebraic
17:26:05 <ddarius> RadioApeShot: Use semicolons.
17:26:12 <Cromulent> frankly though if mathematicians choose to look down on programmers for using different terms to describe the same thing then it does seem somewhat petty
17:26:22 <ddarius> > (do (1+); id) 3
17:26:22 <medfly> RadioApeShot: it's easier to use a file though.
17:26:23 <lambdabot>   3
17:26:31 <tofulivin> Brouwer was one of the greatest logicians to ever live
17:26:49 <Libster> Computers are the best logicians
17:26:56 * ddarius doesn't know what "algebraic type theory" is.
17:26:58 <medfly> but are they alive?
17:27:01 <Libster> yes
17:27:28 <medfly> okay, us 0 - 1 computers
17:27:29 <tensorpudding`> computers are alive?
17:27:38 <adu> HaskellLove: algebraic datatype systems must have (at the very least) Additive (Sigma) types which kind of represent C unions, and Multiplicative (Pi) types, which kind of represent C structs
17:27:39 <u_quark> Libster: are you a program? do you pass the Turing test ?
17:27:45 <HaskellLove> Dependently Typed Programming in Agda - this is what i read now hopefully will increase my inteligence after it
17:28:22 <stroan> HaskellLove: dependent types and their use, and the implications of a dependently typed system, are a lot of work in the getting I fount
17:28:29 <phr> haskelllove, i liked ouri and sweirstra's "power of pi" paper
17:28:30 <tensorpudding`> i can't imagine agda as something the haskell novice should dive into
17:28:32 <phr> oury
17:28:45 <phr> http://www.cse.chalmers.se/~wouter/Publications/ThePowerOfPi.pdf
17:29:08 <Libster> wait
17:29:15 <adu> o ya, don't to Agda until you appreciate Haskell
17:29:16 <ddarius> Dependent typing is an orthogonal direction, not a continuation, of Haskell.
17:29:18 <Libster> people actually publish academic papers about computer science?
17:29:25 <stroan> I've looked into coq before, but I really want to look into agda
17:29:30 <stroan> coq was just so arcane
17:29:41 <tensorpudding`> it is orthogonal to haskell
17:30:04 <tensorpudding`> i don't see how learning agda is helpful to learning haskell though, or type theory in general
17:30:36 <ddarius> tensorpudding`: I would say it is very helpful for type theory.  It isn't an efficient method for learning Haskell at all, I will agree.
17:30:53 <ddarius> But then, neither is learning, say, Prolog.
17:31:04 <tensorpudding`> i guess that i didn't interpret HaskellLove as wanting to learn type theory so much as haskell
17:31:07 <stroan> tensorpudding`: any resources you'd recommend on type theory?
17:31:24 <tensorpudding`> i'm stuck in TAPL right now
17:31:36 <tofulivin> stroan if you subscribe to Whitehead's metaphysics, you'll learn how to apply type theory to your LIFE
17:31:41 <ddarius> tensorpudding`: My point was more, there's no reason for dependently typed languages are more complicated to learn than Haskell.
17:31:45 <tofulivin> its cool, you'll be a living ghci
17:31:51 <ddarius> s/are/to bo/
17:32:26 <stroan> tofulivin: will go a-googlin'
17:32:36 <tensorpudding`> trying to learn ten different things at once is hard
17:33:12 <dolio> HaskellLove: Intuitionists reject the law of the excluded middle, among other stuff.
17:33:18 <bearded_oneder> Libster: doctorate holders in CS usually consider themselves computer "scientist".
17:33:37 <tensorpudding`> the law of excluded middle is pretty easy to explain
17:33:39 <bearded_oneder> scientist do research and publish papers. ;)
17:33:59 <tensorpudding`> though it's hard to see why someone would want to avoid using it
17:34:20 <dolio> It is hard? Or not hard?
17:34:21 <ddarius> tensorpudding`: Look at the constructive proofs of it via CH (for propositional logic).
17:34:43 <ddarius> tensorpudding`: One reason to avoid using it is when it is not true.
17:35:10 <adu> Random computer scientist: I hypothesize that Microsoft Outlook will deliver my email as usual this morning... *click*, *click*, ... Oh no! blue screen? what is this? My hypothesis must have been wrong!
17:35:13 <tensorpudding`> CH?
17:35:25 <ddarius> tensorpudding`: The Curry-Howard correspondence.
17:35:33 <ddarius> tensorpudding`: newsham had some nice examples.
17:35:40 <tensorpudding`> oh yes
17:36:24 <tensorpudding`> when is it not true?
17:37:04 <ddarius> tensorpudding`: When you are using other logics, e.g. "Does program P halt?"
17:37:05 <bearded_oneder> coming from an OOP setting, this is strange http://en.wikipedia.org/wiki/Haskell_(programming_language)#Overview_and_distinguishing_features
17:37:26 <adu> ddarius: actually I disagree. Learning Prolog is very applicable to Haskell (imho), because Haskell's typeclass system is like a mini-Prolog language within Haskell
17:37:31 <HaskellLove> i will read this on agda and in hour i wanna talk agda vs haskell anyone in the mood ?
17:38:08 <adu> HaskellLove: no, use Haskell
17:38:09 <ddarius> adu: I didn't say it wasn't applicable.  In fact, I distinctly worded it the way I did because learning either Agda or Prolog will very much help you learn Haskell.
17:38:15 <dolio> "Intuitionistic type theory" might refer to Martin-Loef's stuff. I think that's what it's known by.
17:38:38 <tofulivin> so how difficult would it be to turn Haskell into a religion? I was thinking about taking out a loan to buy this building near my house and using that place
17:38:40 <ddarius> Martin-Loef type theory is indeed an intuitionistic type theory.
17:39:01 <tofulivin> preflex: xseen dons
17:39:01 <preflex>  dons was last seen on freenode/#xmonad 4 minutes and 46 seconds ago, saying: cut cryptol build times down rather signifcantly :)
17:39:06 <ddarius> tofulivin: I heard from unreliable resources that you only need 12 "faithful" to establish a religion.
17:39:10 <ddarius> (In America.)
17:39:15 <ddarius> This could be wildly incorrect.
17:39:16 <bearded_oneder> are ST monads similar to C's Structs ?
17:39:22 <tofulivin> :)
17:39:29 <adu> tofulivin: lol the Church of Alonzo Church
17:39:40 <tofulivin> lol
17:39:43 <ddarius> Lambda the Ultimate Salvation
17:40:06 <adu> or just "The Church of Church"
17:40:10 <dolio> Well, I know it's "a" one. I thought a lot of people used "intuitionistic type theory" to refer mostly to his work, though. I certainly could be wrong though.
17:40:12 <tensorpudding`> the church of the holy combinator
17:40:36 <ddarius> dolio: Its not uncommon for "ITT" to be identified with Martin-Loef type theory.
17:40:59 <dolio> You know, kind of like calling differential/integral calculus "(the) calculus".
17:41:13 <adu> bearded_oneder: everything is similar to C structs
17:41:35 <dolio> Or referring to Hughes' stuff as "arrows".
17:41:52 <u_quark> bearded_oneder: I don't think so ST introduces state, putting different thinks together in haskell is using tuples or records
17:41:54 <tensorpudding`> lambda calculus, pi calculus
17:41:56 <ddarius> Hughes stuff isn't arrows.
17:42:01 <ddarius> I somewhat dislike that name.
17:42:09 <ddarius> (I'd probably dislike it more if I cared more.)
17:42:28 <adu> who is t
17:42:46 <mreh> Polygon $ map (\x -> (round $ r * cos x, round $ r * sin x)) angles
17:42:46 <mreh>   where angles = map (((n - 2) * pi / n) *) [1..n]
17:43:09 <mreh> Couldn't match expected type `Double' against inferred type `Int' In the second argument of `map', namely `angles'
17:43:13 <mreh> WUT?
17:43:32 <xerox> ?type round
17:43:33 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:44:15 <mreh> I'm rounding the result r * cos x
17:45:31 <mreh> @pl (\x -> (round $ r * cos x, round $ r * sin x))
17:45:31 <lambdabot> ap ((,) . round . (r *) . cos) (round . (r *) . sin)
17:45:37 <mreh> Gah!
17:46:03 <EvilRanter> join (***) round . (cos &&& sin)
17:46:27 <mreh> hmm
17:46:35 <mreh> anyway, that type error is just baffling to me
17:46:39 <EvilRanter> er, s/round/(round . (r*))/
17:48:02 <dh___> good evening guys.  How can apply an list of function to an argument?
17:48:30 <mreh> map ($) [id, reverse, (map toUpper)] "hello"
17:48:30 <dh___> for example,  how to apply [ (+1), (+2) ] 5
17:48:33 <mreh> > map ($) [id, reverse, (map toUpper)] "hello"
17:48:34 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
17:48:35 <lambdabot>         against inferr...
17:48:38 <xerox> > sequence [(+1),(subtract 1),(*2)] 0
17:48:39 <lambdabot>   [1,-1,0]
17:48:54 <mreh> > map ($ "hello") [id, reverse, (map toUpper)]
17:48:55 <lambdabot>   ["hello","olleh","HELLO"]
17:48:57 <dh___> thanks !!
17:49:06 <ben> > foldr ($) 5 [(+1), (+2)]
17:49:07 <lambdabot>   8
17:49:08 <ben> oh, well
17:49:30 <xerox> mreh: was that a regular n-gon inscribed in a circle?
17:49:42 <mreh> xerox, yess
17:50:01 <mreh> i am approximating a circle, because HGL can't draw empty circles
17:50:04 <DerisionSnort> I just found out about the list monad. Can anyone confirm that foo, bar and baz are completely equivalent in the following listing? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14286
17:50:09 <Philonous> > [id, reverse , ++ "foo"] <*> ["Hello world"]
17:50:10 <lambdabot>   A section must be enclosed in parentheses thus: (++ "foo")
17:50:20 <Philonous> > [id, reverse , (++ "foo")] <*> pure "Hello world"
17:50:20 <mreh> lulz
17:50:22 <lambdabot>   ["Hello world","dlrow olleH","Hello worldfoo"]
17:50:33 <mreh> lambdabot is from the 18th century
17:50:40 <xerox> \n -> Polygon [ (cos t, sin t) | t <- take (n-1) [0, (2*pi)/n, ..]
17:50:54 <mreh> xerox: genius
17:50:54 <xerox> (closed square bracket)
17:51:26 <mreh> are fractional types enumerated?
17:51:29 <mreh> apparently so
17:52:05 <xerox> actually it's take n, not n-1
17:52:10 <mreh> yah
17:52:16 <Philonous> DerisionSnort: Yes, they are equivalent. The second one actually desugars to the first one
17:52:57 <Veinor> mreh: ?
17:53:02 <DerisionSnort> So does that mean that the type [a] is actually, in monadic lingo, something like [] a ? :-)
17:53:05 <Veinor> ah
17:53:18 <mreh> Veinor: :@
17:53:22 <Philonous> DerisionSnort: [a] is syntactic sugar for [] a, yes
17:53:28 <xerox> DerisionSnort: that's right, [] is a type constructor, you feed it a type, it gives back a type
17:53:33 <ddarius> :t undefined :: [] a
17:53:33 <Veinor> > (1, 2) :: [] Int
17:53:34 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
17:53:34 <lambdabot>         against inferred typ...
17:53:34 <lambdabot> forall a. [a]
17:53:40 <Veinor> er
17:53:45 <Veinor> stupid brackets, not being identical!
17:53:47 <Philonous> @type []
17:53:48 <lambdabot> forall a. [a]
17:53:50 <Veinor> > [1, 2] :: [] Int
17:53:51 <lambdabot>   [1,2]
17:54:09 <mreh> xerox, I don't think those angles are correct
17:54:18 <mreh> oh, no they are
17:55:09 <DerisionSnort> How exactly does the function head "get out of the monad"? I thought that was impossible?
17:55:30 <mreh> > [0, (2*pi)/n ..]
17:55:31 <lambdabot>   [0* Exception: not a number
17:55:36 <xerox> mreh \r n -> Polygon [ (r * cos t, r * sin t) | t <- [0, (2*pi)/(fromIntegral n) ..] ]
17:55:37 <ben> DerisionSnort: It is possible for most monads
17:55:44 <ben> DerisionSnort: but not for monads in general
17:55:48 <dh___> Philonous : I like this <*> , thanks
17:55:58 <ezyang> DerisionSnort: Monads are abstraction barriers
17:56:11 <ezyang> and some functions let you break out of them.
17:56:12 <Philonous> DerisionSnort: It would be silly if you couldn't get out of a monad. There is just no uniform way to do it for all monads
17:56:16 <ben> DerisionSnort: A Monad does not have a way to get out of it just by virtue of being a monad, but some of them have their own means
17:56:35 <ben> This is a good thing because a lot more things are monads than you would expect :)
17:56:56 <ezyang> Philonious: ID monad!
17:57:05 <ezyang> IO monad!
17:57:08 <mreh> Monad is just a type class, unlike Java classes you can inherit multiple classes
17:57:10 <Veinor> why is all the documentation stuff broken?
17:57:11 <ddarius> If you define "getting out" as a total function M a -> a, very few monads have ways of "getting out" of them.
17:57:31 <DerisionSnort> well, head is such a function, isn't it?
17:57:33 <Veinor> example: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:head
17:57:33 <mreh> s/inherit/implement
17:57:38 <ddarius> DerisionSnort: It is not total.
17:57:42 <Veinor> > head []
17:57:44 <lambdabot>   * Exception: Prelude.head: empty list
17:57:58 <ddarius> If you don't need totality, then "undefined :: IO a -> a" is a way to get out of the IO monad.
17:58:21 <Philonous> DerisionSnort: Actually list is a monad where there is no nice way to escape it. What when the list is empty? What if there is more than one value? Which one do you choose?
17:58:31 <ben> Surely you can turn every function into a total function by wrapping Maybe around it.
17:58:35 <ddarius> That said, being able to "get out" or not is not, in my opinion, a defining feature of monads.
17:58:35 <DerisionSnort> i think i get it. Thanks everyone!
17:58:51 <Veinor> ben: but then you're just escaping into another monad! oh no!
17:58:55 <ezyang> ddarius: haha
17:59:17 <ben> Veinor: Sure, but then we can say that Maybe is the only monad without a toal function of getting out
17:59:28 <RadioApeShot> So, can someone make sure I am reading this type signature correctly?
17:59:31 <RadioApeShot> continueChain :: [Int] -> (Int -> Int -> Bool) -> (Array Int [Int]) -> [Int]
17:59:59 <RadioApeShot> it is a function which takes a list of ints, a function taking two ints and leading to a bool, and an array with integer index and list of integer elements
18:00:02 <RadioApeShot> It returns a list of ints
18:00:17 <ddarius> ben: Um, please make me a total interpreter for the untyped lambda calculus that returns Maybe in cases of partiality.
18:00:34 <ben> Maybe
18:01:10 <xerox> RadioApeShot: right
18:01:41 <Philonous> dh___: this (<*>) code works even on other structurs. On all applicatives to be precise.
18:02:06 <DerisionSnort> How useful is the Maybe monad in practice? I have seen several videos where lists where used instead of Maybe, where Nothing is mapped to the empty list, and Just x to [x]. Is that common practice?
18:02:15 <u_quark> trying to cabala install type-level I get a "Could not find module `Data.Generics': it is a member of the hidden package `base-3.0.3.1'"... any ideas ?
18:02:26 <RadioApeShot> xerox: thanks
18:02:32 <RadioApeShot> xerox: thats what I thought
18:02:34 <u_quark> cabal*
18:04:27 <ezyang> DerisionSnort: list monad is strictly stronger than the maybe monad
18:04:48 <ezyang> but that doesn't mean you shouldn't use the maybe monad when you need something simple
18:04:49 <Philonous> DerisionSnort: Lists introduce nodeterminism. But there are better Monads for this (LogicT). But if all you need is a way to fail gracefully, Maybe is a better fit (someone trying to understand you code knows exactly what you mean and doesn't need to check whether you return multiple values at some point)
18:04:58 <ezyang> "continuations are strictly stronger than X"
18:05:31 <mreh> (\n r -> [ (round $ r * cos t, round $ r * sin t) | t <- [0, (2*pi)/(fromIntegral n) ..] ]) 3 1
18:05:36 <mreh> > (\n r -> [ (round $ r * cos t, round $ r * sin t) | t <- [0, (2*pi)/(fromIntegral n) ..] ]) 3 1
18:05:37 <lambdabot>   [(1,0),(0,1),(-1,-1),(1,0),(-1,1),(0,-1),(1,0),(-1,1),(0,-1),(1,0),(-1,1),(...
18:05:53 <mreh> :D, it doesn't work
18:06:13 <mreh> > (\n r -> take n [ (round $ r * cos t, round $ r * sin t) | t <- [0, (2*pi)/(fromIntegral n) ..] ]) 3 1
18:06:15 <lambdabot>   [(1,0),(0,1),(-1,-1)]
18:06:24 <mreh> that almost crashed my computer that little mistake
18:06:29 <xerox> mreh: rounding is cruel to very near points like that
18:06:50 <medfly> not typing > at the start?
18:07:05 <xerox> mreh: it makes *some* sense if r is large.
18:07:39 <mreh> xerox, it rounds because I'm working in a discreet co-ordinate space
18:08:07 <mreh> medfly: evaluating a whole infinite list
18:08:58 <mreh> if I'm round anything smaller than 1 then it compresses the whole polygon onto one pixel
18:09:03 <mreh> > (\n r -> take n [ (round $ r * cos t, round $ r * sin t) | t <- [0, (2*pi)/(fromIntegral n) ..] ]) 3 0.5
18:09:04 <lambdabot>   [(0,0),(0,0),(0,0)]
18:09:06 <xerox> mreh: if the radius is small  there aren't many points with integer coordinates there
18:09:10 <medfly> I don't know if that'll crash your computre
18:09:35 <mreh> medfly it used 80% of the memory in 30 seconds
18:09:45 <medfly> still :)
18:09:49 <mreh> it was paging, i have music playing, the whole thing froze
18:09:55 <xerox> if the radius is big, there are more, so those points get snapped to the nearest lattice ones in the direction of the origin
18:10:26 <mreh> > (\n r -> take n [ (round $ r * cos t, round $ r * sin t) | t <- [0, (2*pi)/(fromIntegral n) ..] ]) 100 10
18:10:28 <lambdabot>   [(10,0),(10,1),(10,1),(10,2),(10,2),(10,3),(9,4),(9,4),(9,5),(8,5),(8,6),(8...
18:10:38 <mreh> > (\n r -> take n [ (round $ r * cos t, round $ r * sin t) | t <- [0, (2*pi)/(fromIntegral n) ..] ]) 10 10
18:10:39 <lambdabot>   [(10,0),(8,6),(3,10),(-3,10),(-8,6),(-10,0),(-8,-6),(-3,-10),(3,-10),(8,-6)]
18:10:44 <olognation> Any tips on using haskell with vim?
18:10:49 <medfly> :sy on
18:10:51 <olognation> I'm used to emacs, but I want to learn vim.
18:10:56 <medfly> :set et
18:10:59 <medfly> :(
18:11:00 <mreh> vim is evil
18:11:06 <mreh> vi vi vi
18:11:19 <xerox> mreh: but none of those will look exactly like the real polygon, it approximates a real n-gon in the limit for r->oo
18:11:25 <tass> mreh: Welcome to the dark side, we have cookies!
18:11:32 <tass> ;>
18:11:51 <ezyang> mreh: I like vim!
18:12:08 <tass> I know vim, but I get lost in emacs.
18:12:16 <mreh> xerox, what's the alternative?
18:12:32 <medfly> I actually like graphical editors, but I don't know any decent one
18:12:32 <xerox> mreh: depends exactly what you need
18:12:38 <mreh> I can't do alpha blending on HGL
18:13:12 <tass> medfly: vim (or in your case, gvim)
18:13:21 <medfly> yeah I tried that too...
18:13:38 <medfly> I'm just a spoiled person that apparently didn't get used to the fact he's not using windows ;)
18:13:43 <tass> medfly: All the vim goodness, in a graphical interface.
18:13:45 <medfly> even though that was several years ago (!)
18:13:55 <tass> Meh : P
18:14:14 <medfly> however, I did get used to other parts, luckily :-p
18:14:34 <medfly> I don't know a decent one for windows either
18:15:53 <mreh> do they do races between emacs vim and other contenders?
18:16:08 <mreh> like qwerty vs dvorak!
18:16:14 <medfly> I don't think that you can really compare those things
18:16:18 <medfly> it's just personal preference
18:16:22 <mreh> I know, but it's fun!
18:16:25 <medfly> if you want productivity then you shouldn't be having races
18:16:27 <medfly> :D
18:16:47 <mreh> it's a universal desire of man to know what would kick what's ass
18:16:57 <medfly> my dad would kick your dad's ass
18:16:57 <mreh> i should say "men"
18:17:05 <mreh> nu-uh
18:17:12 <smorg> I don't care to find out which is better. I spent enough time learning vim
18:17:45 <mreh> do you hardcore hackers even have mice?
18:17:54 <mreh> i'd love to ditch the mouse
18:17:56 <medfly> I didn't really learn any vim. I guess it's wyh I prefer it - easier to do things with even if you aren't an expert yet
18:18:04 <medfly> <- not a hardcore hacker
18:18:24 <michaelh> i use sublimetext for an editor
18:18:31 <michaelh> on the topic of editors
18:18:45 <michaelh> on windows
18:18:47 <smorg> I'd love to ditch the mouse but can't quite. I don't like vimperator and still use kwin rather than xmonad quite a lot.
18:19:02 <Raynes> Emacs > _
18:19:18 <medfly> I use a web browser sometimes
18:19:25 <medfly> I know, I should stop
18:19:26 <ezyang> Vimperator!
18:19:28 <p_l> Emacs, Vimperator, XMonad + thinkpad's trackpoint :D
18:19:39 <mreh> medfly: what? text only is where it is at
18:19:43 <mreh> ;)
18:19:47 <stroan> Raynes: emacs is more of an OS in an OS than a text editor
18:19:50 <smorg> gnu screen is quite lacking still. Can't wait til the vertical split feature is in a stable version.
18:19:52 <ezyang> smorg: What's not to like about it?
18:19:57 <tass> stroan: Agreed.
18:20:09 <p_l> smorg: there's a tiling window manager for text console
18:20:28 <tass> Just use xmonad?
18:20:32 <tass> It's good?
18:20:39 <Raynes> stroan: Old.
18:20:44 <medfly> I tried to use xmonad today, I wasn't sure what to do at start
18:20:51 <tass> There's not really anything to not like about it?
18:20:58 <stroan> Raynes: I've only started using emacs
18:21:02 <stroan> and I find it incredibly true
18:21:06 <tass> medfly: Read documentation is usually a safe bet. : )
18:21:08 <Raynes> Sad.
18:21:17 <Raynes> It's incredibly wrong. ;)
18:21:22 <medfly> it seemed long. I used openbox instead.
18:21:36 * medfly tried to use less RAM
18:21:45 <smorg> ezyang: I just need to get used to it. By default it doesn't organize your bookmarks into their folders and theres a few other minor annoyances that make me want to put off really learning it til finals are over :)
18:21:51 <tass> Raynes: Stop lying. Emacs IS an OS, programming language, and an editor, all at the same time. : P
18:21:52 <ezyang> Oh... clever! Using lists of (probability, value) tuples for probabilistic browsing
18:22:02 <ezyang> s/browsing/code/
18:22:09 <ezyang> smorg: Oh. "I don't use bookmarks" :-P
18:22:19 <ezyang> tab completion all the way yo
18:22:27 <tass> Browsing wat?
18:22:29 <Raynes> Indeed, but it never stops being awesome.
18:22:38 <smorg> p_l: whats that? Screen is the only one I know of. I know there is maybe a few others but I don't think they are as mature.
18:22:45 <Raynes> smorg: I know you.
18:22:47 <Raynes> Hi.
18:23:26 <smorg> Raynes: hai2u!
18:24:01 <medfly> I am happy in my nice cozy graphical things
18:24:13 <ezyang> medfly: Infidel!
18:24:32 * ezyang couldn't be bothered to setup xmonad on his desktop... 
18:25:45 <p_l> smorg: I don't remember the name, but I recall seeing it (and I think it started with 'd' but not sure)
18:25:47 * Raynes is using Bluetile.
18:27:17 <medfly> dvtm
18:27:42 <smorg> I use byobu actually - that configuration of screen that comes with ubuntu
18:28:56 <medfly> dvtm <- console tiling wm
18:30:33 <smorg> Raynes: Heh bluetile looks nice. I already have xmonad set up nicely
18:30:37 <medfly> ooh, this lookup found me something else I may want. :)
18:31:34 <Raynes> smorg: It isn't.
18:31:41 <Raynes> Don't be fooled.
18:34:11 <smorg> Didn't know xmonad could resize windows with the mouse
18:34:25 <ddarius> What's a window?
18:34:30 <smorg> tile
18:34:37 <ddarius> What's a tile?
18:34:47 <smorg> square thing which contains words
18:35:09 <ezyang> Is there any built in function that does msum . return?
18:35:18 <ezyang> erm, actually, I don't want that
18:35:24 <ddarius> ezyang: I didn't think so.
18:35:35 <ddarius> smorg: Does it cease to be a tile if it contains no words?
18:35:45 <ezyang> msum . fmap return
18:36:59 <ezyang> hoogle's not turning up anything
18:37:41 <medfly> a tile is that thing on your floor :)
18:37:43 <smorg> ddarius: then its a graphical picture square.
18:38:00 * smorg emerges dvtm
18:38:25 <ddarius> medfly: The carpet?
18:38:58 <medfly> you can have a floor with no tiles, but a tile is related to a floor.
18:39:24 <ddarius> medfly: Does a tile cease to be a tile when it is removed from the floor?
18:39:44 <medfly> no. it is just semantically (?) related to floor
18:39:51 <smorg> floors don't have tiles
18:40:21 <smorg> floor :: (RealFrac a, Integral b) => a -> b
18:40:28 <medfly> haha
18:41:12 <ddarius> tile `on` floor
18:42:02 <tass> Right, now I've created my datatype, now I need to make a parser that transforms a string into that nice new datatype...
18:42:25 <ezyang> List should totally be typeclass and not a type! :-D
18:42:46 <ddarius> class [] a where ...
18:42:58 <ezyang> wait, is it actually?
18:43:29 <copumpkin> moo
18:43:32 <copumpkin> no
18:43:47 <Philonous> ezyang: So what would the [] class look like?
18:44:05 <ezyang> Philonous: I basically just want to be able to overload the [] operator
18:44:48 <copumpkin> I want to be able to overload the space operator
18:44:55 <ezyang> muahahaha
18:44:56 * ray kills copumpkin
18:45:01 <copumpkin> :(
18:45:10 <copumpkin> ray: bostonhaskell?
18:45:19 <ray> new york haskell pls
18:45:34 <copumpkin> fail
18:46:03 <Philonous> copumpkin: You mean like myIntMap 5 begin lookup 5 myIntMap ?
18:46:07 <Philonous> being*
18:46:13 <copumpkin> yeah
18:46:16 <copumpkin> or a total map
18:46:24 <Philonous> I second that
18:47:10 <Philonous> But we could overload ($) for starters
18:47:23 <copumpkin> we're already talking aboutthat in #alt-stdlib :)
18:47:33 <copumpkin> jmcarthur did a nice class with associated types for domain and codomain
18:49:14 <ezyang> Here's a tentative outline for my Logic monad section http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14287#a14287
18:50:02 <tass> This is gonna be such a nightmare to code.
18:50:12 <tass> *flops onto desk*
18:50:55 <smorg> Is that list comprehension working like tuple unpacking in python? Didn't know you could do that so easily
18:50:56 <copumpkin> nuh uh
18:51:00 <BMeph> @type msum . fmap return
18:51:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
18:52:07 <ezyang> "as usual, comments welcome"
18:53:24 <kmc> smorg, you can bind to patterns nested arbitrarily deep
18:54:38 <kmc> > let (Just (x,y), (z:[q]:zs)) = (Just (2, 'x'), ["ab", "c", "def"]) in (x,y,z,q,zs)
18:54:39 <lambdabot>   (2,'x',"ab",'c',["def"])
18:56:32 <smorg> Dang thats powerful. So it works more like in actual set theory rather than just an alternate syntax for writing loops.
18:56:38 * BMeph wants Monoids that are defined by the values, not the types used by them...
18:57:22 <kmc> bearded_oneder, did you get an answer to your ST monad question?
18:57:23 <ezyang> smorg: Yup!
18:57:47 <bearded_oneder> kmc: yes.
18:57:51 <kmc> cool
18:57:54 * copumpkin is the master of all
18:58:54 <ezyang> hmm... that didn't /quite/ do what I wanted it to
18:58:54 <Veinor> I hate how if I cabal install x, and x depends on y, and the latest version of y can't be installed due to incompatible bases, cabal won't just try the next older version :(
18:58:56 <kmc> To me, using Maybe over [] is a prime example of picking the type that says more about your program, for better static checking
18:59:11 <kmc> Sure, you can use [] with the convention that all non-empty lists are singletons, but the compiler won't check that for you
18:59:30 <kmc> You can quite easily make a mistake and introduce nondeterminism where you didn't want it
18:59:38 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14288#a14288
19:00:02 <Veinor> specifically, I ran cabal install hszephyr, and it kvetched that time-1.1.4 requires base-4, without noticing that time-1.1.3 works fine with base-3
19:00:07 <ezyang> maybe I actually want >>-
19:00:11 <brad6> Hi, I would like to learn Computer Programming.Were should I start, Like what Downloads should I get?
19:00:14 <ezyang> oh, yeah, looks like it
19:00:26 <kmc> brad6, you don't know any programming yet?
19:00:42 <BMeph> I hate how if I cabal install x, and x depends on y, and the latest version of y can't be installed due to incompatible bases, cabal won't just try the next older version of x... ;)
19:01:02 <brad6> No, I would really like to learn how though.
19:01:03 <Veinor> ?
19:01:19 <BMeph> Veinor: Just yanking your chain. ;)
19:01:30 <Veinor> haha
19:01:36 <dcoutts> BMeph: I've got an open ticket on it and I think I know how to change the solver to do that. It's a matter of having the hacking time available.
19:01:37 <Veinor> except in this case there is no next older version of x
19:01:56 <kmc> brad6, you're asking in the channel about Haskell, an advanced functional programming language.  It has a reputation for being one of the most difficult languages, but a lot of that difficulty comes from the fact that it's different from other languages.  So it might actually be easier for a new programmer than for someone with lots of experience.
19:02:09 <ezyang> Hmm... still not quite there
19:02:09 <Philonous> ezyang: Are you working with Olegs "backtracking monad with fair operations and pruning" or did you brew something by yourself?
19:02:12 <kmc> If that doesn't scare you off, we're happy to help you learn Haskell
19:02:43 <ezyang> Philonous: I'm using Oleg's
19:02:56 <ezyang> Basically, I'm trying to implement breadth-first search as is taught in an elementary algorithms class
19:02:57 <brad6> Ok,so I should go to a dif. Chatroom?
19:03:06 <kmc> brad6, not if you want to learn Haskell
19:03:10 <mreh> brad6, nah, stick around
19:03:36 <ezyang> Given [1,2,3] and [4,5,6], I've managed to get [(1,4),(3,4),(1,6),(2,4),(1,5),(3,6),(2,6),(3,5),(2,5)] and [(1,4),(2,4),(1,5),(3,4),(1,6),(2,5),(3,5),(2,6),(3,6)]
19:03:39 <emef> Does anyone know a good list of exercises for haskell / functional programming?
19:03:40 <brad6> I just wanting to Learn Basic Programing Skills..
19:03:41 <mreh> I didn't know unix systems when I started haskell, the best way to learn by yourself is to dive straight in
19:03:48 <kmc> brad6, Haskell is my favorite language and I wish I'd learned it at the beginning.  But you might find it a steep learning curve
19:03:56 <Raynes> emef: There is the 99 Haskell problems.
19:04:06 <ezyang> but not [(1,4),(2,4),(3,4),(1,5),(2,5),(3,5),(1,6),(2,6),(2,7)]
19:04:13 <kmc> brad6, you might also check out Python
19:04:14 <ezyang> erm, (3,6) for the last tuple
19:04:15 <kmc> there's a #python channel
19:04:18 <smorg> I didn't know OO when I started Haskell, and it made learning OO REALLY hard. Thats backwards from the stories I mostly hear from others.
19:04:18 <emef> thanks Raynes
19:04:30 <ezyang> brad6: Do you like math?
19:04:43 <Veinor> smorg: what was so hard about learning OO?
19:05:16 <kmc> brad6, to get started with Haskell, download the Haskell Platform for your OS at:  http://hackage.haskell.org/platform/
19:05:17 <smorg> Veinor: Classes. I still find them confusing.
19:05:17 <brad6> No, not rlly my favoit Thing.
19:05:18 <Raynes> smorg: The only reason FP made OO hard for me was the fact that it seems so huge and unnecessarily complex compared to the way Haskell does polymorphism.
19:05:48 <ezyang> Yeah... OO is pretty complicated.
19:05:54 <smorg> classes, attributes, properties, blah... makes my head spin.
19:06:13 <ezyang> OH, I know why this is not working
19:06:14 <kmc> brad6, I don't know any resources for learning Haskell as a first language.  The two most popular tutorials are http://learnyouahaskell.com/ and http://book.realworldhaskell.org/read/
19:06:17 <Raynes> I try to program in OOP languages, but I lose interest fast.
19:06:25 <tass> Heh, ska bli intressant att se hur väl mina regexar funkar
19:06:28 <kmc> Both will assume some level of familiarity with other programming languages, but you might still get by
19:06:41 <ezyang> hmmm, I guess pure depth first search is not really possible
19:06:52 <tass> Wowie, late night madness makes me type stuff in wrong channels
19:07:04 <Raynes> kmc: If he's smart, and really wants to learn, LYAH might be him by.
19:07:08 <kmc> ezyang, Raynes, smorg i enjoyed two articles about OO from Paul Graham's site:  http://www.paulgraham.com/noop.html and http://www.paulgraham.com/reesoo.html
19:07:17 <tass> But on the other hand, will be interesting to see how well my regexes work..
19:07:37 <kmc> "Perhaps part of the confusion... is that the C/C++ folks see OO as a liberation from a world that has nothing resembling a first-class functions, while Lisp folks see OO as a prison since it limits their use of functions/objects"
19:07:41 <smorg> Raynes: Its weird coming from ML or Haskell because I tried learning to write with closures, continuations, lots of lambdas, lots of higher order functions
19:07:56 <ezyang> kmc: Hah! classy articles
19:08:09 <kmc> smorg, there are plenty of language with good support for both functional and object-oriented programming
19:08:22 <Raynes> smorg: Know what would really help you?
19:08:26 <Raynes> smorg: Do some Scala.
19:08:32 <kmc> the part where Java and C++ lack that isn't because they're "imperative" or "object-oriented"
19:08:38 <Raynes> Seriously. Scala is cool.
19:08:42 <kmc> the opposite of "functional" is simply "dysfunctional"
19:08:46 <lazni> @src liftM
19:08:47 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:08:50 <Raynes> I learned what I know about OOP primarily from Scala.
19:09:28 <ezyang> AHA! I wanted an interleaved msum
19:09:50 <kmc> e.g. in Python, every method is a partially applied lexical closure
19:10:01 <tass> Err..
19:10:08 <tass> How do I load modules in GHCI?
19:10:15 <kmc> tass, :module Foo
19:10:18 <Veinor> tass: :m +Module.Name
19:10:20 <Raynes> Python makes me cringe a bit, considering Guido's affinity to functional programming.
19:10:22 <kmc> ":module + Foo" to add it to tthe existing list of modules
19:10:31 <ezyang> "affinity"
19:10:31 <kmc> ":module + *Foo" if you want to see *all* of Foo, not just its exports
19:10:37 <kmc> yeah, Guido and others have said some dumb shit
19:10:45 <kmc> but at the end of the day, Python has real higher-order functions and they're used extensively
19:10:46 <smorg> I don't understand why they are so resistant to functional programming given all the nice features they put into it.
19:10:54 <smorg> They actually got rid of reduce!
19:10:56 <smorg> kind of annoying
19:11:03 * ezyang is so annoyed that id is not of type a -> a 
19:11:04 <kmc> smorg, it's just a library function...
19:11:17 <Veinor> :t id
19:11:19 <lambdabot> forall a. a -> a
19:11:21 <ezyang> Anyway, "You shouldn't write Haskell in Python. It's Not Good."
19:11:36 <kmc> agreed, but the biggest difference between Python and Haskell is not the level of support for FP
19:11:39 <ezyang> I know a bunch of engineers who have to tell themselves this continually
19:11:44 <Veinor> ezyang: ... oh, you meant in python.
19:11:46 <smorg> and python needs tco badly.
19:11:52 <Raynes> kmc: I understand what he is saying, though. Taking out that stuff is equivalent to acting like a 5 year old."
19:11:52 <ezyang> In Python.
19:11:52 <smorg> to make it usable in that way
19:12:01 <Raynes> Minus that last double quote.
19:12:17 * ezyang doesn't trust himself enough to write clever functional code in a dynamically typed language 
19:12:19 <mreh> do I work out the state machine my game should follow, or just implement it all in an adhoc way using boolean variables?
19:12:35 <mreh> one way is lazy, the other may save me alot of hassle
19:12:37 <kmc> iirc reduce and friends are moving to an importable module that's still in the standard distribution
19:13:06 <kmc> ezyang, indeed.  I don't know how the Lisp hackers do it -- not only highly functional but also heavily metaprogrammed code, with no static checking at all
19:13:07 <mreh> also is there a way to decouple the stateful parts of a program from the bits that a functionally dependant on state only?
19:13:17 <mreh> s/a/are/
19:13:20 <kmc> mreh, yes
19:13:23 <Raynes> I'm a Lisp hacker. :>
19:13:26 <smorg> kmc: looks like its in the functools module
19:13:32 <mreh> kmc: tell me please
19:13:34 <ezyang> Raynes: Well, how do you do it? :-)
19:13:39 <kmc> mreh, can you elaborate on what you want to do?
19:13:40 <ezyang> "yay itertools"
19:13:47 <smorg> iirc foldr is technically more powerful than foldl anyway (which is what reduce is)
19:13:52 <ezyang> mreh: I think so.
19:13:54 <kmc> mreh, after all, State monad is just sugar on top of passing your states around functionally
19:13:54 <Raynes> I just do it. It doesn't seem hard to me, or the other Lisp haxorz.
19:14:02 <mreh> kmc: make a game of asteroids without tearing out my hair
19:14:02 <ezyang> mreh: You can still call pure functions from the state monad
19:14:20 <kmc> :t gets
19:14:22 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
19:14:29 <tass> > ":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message" =~ "^:(.+)!" :: String
19:14:31 <lambdabot>   ":tass!"
19:14:35 <tass> Hrm...
19:14:35 <ezyang> mreh: And thus the state doesn't leak over to them.
19:14:43 <ezyang> Raynes: Refactoring?
19:14:44 <tass> Why doesn't that work the way I want it to
19:15:03 * ezyang throws up hands. He doesn't know how to implement breadth-first search in the logic monad 
19:15:06 <Raynes> I don't think I've ever really done large scale refactoring.
19:15:14 <ezyang> "Well there you go."
19:15:26 <tass> I want it to return "tass", not ":tass!"
19:15:27 <kmc> mreh, "gets" will take a pure function that depends on state, and evaluate it, giving you the result in your state monad
19:15:29 <ezyang> It sucks a lot unless you have types or massive amounts of unit tests
19:15:32 <tass> D:
19:15:37 <mreh> ezyang, kmc: you have enlightened me, monads can be used to hide information too!
19:15:44 <ezyang> mreh: Whee!
19:15:49 <kmc> @faq Can monads be used to hide information?
19:15:50 <lambdabot> The answer is: Yes! Haskell can do that.
19:15:56 <ezyang> ==
19:16:03 <kmc> did @faq ever do something else?
19:16:20 <mreh> kmc: lol, i don't know if it was ever meant to either
19:16:23 <ezyang> @faq Can Haskell reduce entropy?
19:16:23 <mreh> possibly
19:16:23 <lambdabot> The answer is: Yes! Haskell can do that.
19:16:31 <ezyang> :-D
19:16:42 <kmc> frequently asked last questions
19:16:48 <mreh> "In this house we obey the second law of thermodynamics"
19:17:18 <BMeph> "Gravity: It's not just a Good Idea, it's THE LAW!" ;p
19:17:40 <BMeph> Although, you can bend it at times... :D
19:17:45 <kmc> or it bends you
19:18:13 <mreh> let me know when the perpetual motion machine arrives
19:18:20 * BMeph had a weird "In Soviet Warp core..." episode
19:18:33 <kmc> let me know when the time machine arrived
19:18:45 <ezyang> man, interleave is binary. This is so annoying...
19:20:01 <mreh> right, i wish there were more hours in the day to hack haskell
19:20:13 <mreh> good night
19:20:21 <kmc> @wikipedia Modafinil
19:20:22 <ezyang> mreh: Gnight!
19:20:23 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=Modafinil
19:20:30 <ezyang> >.>
19:20:37 <kmc> why does it go there?
19:20:43 <kmc> i wanted en.wikipedia.org damnit
19:20:45 <kmc> @quote damnit
19:20:46 <lambdabot> No quotes match. I am sorry.
19:20:57 <mreh> @quote sleep
19:20:57 <kmc> @quote scheme
19:20:57 <lambdabot> yaxu says: I'd rather not go to sleep without a working haskell installation. How would I dream?
19:20:57 <lambdabot> sieni says: scheme adheres to the TIMTOBFTTWTDI principle instead of TIMTOWTDI
19:21:01 * tass explodes in a fiery ball of binary
19:21:14 <mmorrow> ezyang: you mean interleave from LogicT?
19:21:24 <kmc> in this business you're a one or a zero, alive or dead
19:21:37 <mmorrow> , foldr interleave [] (fmap (\n -> [n..]) [0..]) {- ? -}
19:21:43 <lunabot>  [0,1,1,2,2,2,3,3,4,3,5,3,6,4,7,4,8,5,9,4,10,6,11,4,12,7,13,5,14,8,15,5,16...
19:22:00 <tass> I don't like the fact that haskell regex doesn't work like I'm used to : (
19:22:00 <kmc> what
19:22:08 <ezyang> mmorrow: Yeah
19:22:30 <ezyang> mmorrow: It's mostly fair, but not /quite/
19:22:33 <mreh> TIMTOBFTTWTDI?
19:22:51 <ezyang> mreh: That's not even in urbandictionary
19:22:56 <tass> > ":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message" =~ "^:(.+)!" :: String
19:22:58 <lambdabot>   ":tass!"
19:23:00 <kmc> there is more than one ? ? ? ? way to do it
19:23:02 <mmorrow> ezyang: oh. what would be the fair interleaving?
19:23:09 <mreh> it's only occurance is in the haskell logs according to google
19:23:11 <tass> Why does it include ':' and '!' ?
19:23:22 <mmorrow> , foldr interleave [] (fmap (\n -> [n*10..]) [0..])
19:23:23 <lunabot>  [0,10,1,20,2,11,3,30,4,12,5,21,6,13,7,40,8,14,9,22,10,15,11,31,12,16,13,2...
19:23:30 <tass> I want to know ;<
19:23:35 <ezyang> mmorrow: oh wait, that is kind of fair
19:23:44 <mmorrow> i can't really tell..
19:23:46 <smorg> @faq Can Haskell do what haskell cannot do?
19:23:47 <lambdabot> The answer is: Yes! Haskell can do that.
19:23:51 <ezyang> huh. If I have infinite choices from the starting node, I /don't/ want traditional breadth-first search
19:24:27 <mmorrow> ezyang: rather, the diagonal?
19:24:29 <mreh> @quote hire
19:24:30 <lambdabot> SyntaxNinja says: You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean
19:24:30 <lambdabot> I'll keep doing what I'm doing." ;)
19:24:35 <mreh> i love that one
19:24:38 <ezyang> Basically, say I have a graph [1,2,3], and each node there branches to [4,5,6], fair bread-first search is 1,4; 2,4; 3,4; 2,4...
19:24:45 <ezyang> mmorrow: Yeah. The diagonal is fairer.
19:25:02 <ezyang> erm, that last tuple should be 1,5
19:25:13 <mmorrow> ezyang: and can handle the infinite breadth + infinite depth case
19:25:16 <ezyang> @quote burrito
19:25:16 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
19:25:20 <ezyang> Yep
19:26:04 <ezyang> @quote java
19:26:04 <lambdabot> dibblego says: Java programmers prefer referential transparency too, they just call it "design patterns" or something
19:26:22 <kmc> haha
19:26:47 <tass> So noone feel like shedding some light why my regexes don't respect my parenthesises? (Spelling? Ahahaha..)
19:27:00 <kmc> tass, can you hpaste some code?
19:27:07 <ezyang> ==kmc
19:27:23 <kmc> ==NaN
19:27:29 <tass> kmc: I can run one with lambdabot here
19:27:36 <kmc> lambdabot has regex?
19:27:38 <kmc> go ahead
19:27:47 <tass> > ":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message" =~ "^:(.+)!" :: String -- Is meant to extract "tass"
19:27:48 <lambdabot>   ":tass!"
19:27:53 <kmc> oh that thing
19:27:56 <ezyang> ohhh
19:27:56 * smorg wonders if lambdabot works on gentoo yet.
19:27:58 <kmc> i missed that it was regex
19:27:58 * smorg tries
19:28:03 * kmc attempts to grok
19:28:06 <ezyang> "I thought that was just random gobbeldygook"
19:28:08 <tass> Like, why the flying fuck is it doing that?
19:28:08 * ezyang reads 
19:28:23 <ezyang> Oh, well ! is in the pattern
19:28:27 <ezyang> so of course it'll get matched
19:28:36 <ezyang> you'll need a subpattern, or turn it into a lookahead assertion
19:28:42 <ezyang> "subpatterns are easier"
19:28:45 <mreh> @quote LarryWall
19:28:46 <lambdabot> LarryWall says: We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris.
19:28:48 <tass> subpattern?
19:28:53 <mreh> @quote LarryWall
19:28:54 <lambdabot> LarryWall says: <TimToady> learning Haskell itself is easy--I've done it several times already
19:28:57 <BMeph> 'Cause Haskell regex doesn't do that whole pre-match thing...whatever it's called.
19:29:05 <kmc> > "foo :tass! bar" =~ "^:(.+)!" :: String
19:29:06 <lambdabot>   ""
19:29:08 <mreh> is that the real Larry Wall?
19:29:10 <ezyang> Oh, well, I'm a hard core PCRE dude
19:29:15 <kmc> > ":tass! bar" =~ "^:(.+)!" :: String
19:29:17 <lambdabot>   ":tass!"
19:29:29 <kmc> which re module is this?
19:29:36 <kmc> seems it returns the whole match, not the first parenthesized group
19:29:41 <tass> PCRE is what _I_ am using.
19:29:45 <kmc> > "abc" =~ "a(b)c" :: String
19:29:47 <lambdabot>   "abc"
19:30:22 * ezyang should figure out what conjunction and disjunction are 
19:30:28 <kmc> > "abc" =~ "a(b)c" :: [String]
19:30:29 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
19:30:30 <lambdabot>                    ...
19:30:32 <kmc> ezyang, in general?
19:30:35 <smorg> "Object-oriented programming generates a lot of what looks like work."
19:30:37 <ezyang> well, does =~ have an interface for accessing subpatterns
19:30:42 <smorg> ezyang: those are logic terms.
19:30:51 <kmc> conjuction is "and"
19:30:52 <ezyang> kmc: ya. I think a Wikipedia article will tell me what I need to know
19:30:54 <kmc> disjunction is "or"
19:30:55 <tass> Yeah.. because, I thought I was using what is generally considered a subpattern, with my nice parenthesises..
19:31:00 <ezyang> oh. That was easy.
19:31:19 <smorg> disjunction is xor ?
19:31:19 <ezyang> hmm, I guess I need to figure out why >>- is conjunction and interleave is disjunction
19:31:22 <smorg> i thought
19:31:31 <kmc> > getAllMatches $ "abc" =~ "a(b)c"
19:31:33 <lambdabot>   No instance for (GHC.Show.Show (f b))
19:31:33 <lambdabot>    arising from a use of `M2520718398...
19:31:33 <smorg> er no... its just or
19:31:39 <kmc> > getAllMatches $ "abc" =~ "a(b)c" :: [String]
19:31:40 <alexyk> how do you plot from haskell?  is there an R link?
19:31:40 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
19:31:40 <lambdabot>                    ...
19:31:51 <ezyang> oh, that makes sense
19:31:54 <kmc> :t getAllMatches ("abc" =~ "a(b)c")
19:31:55 <lambdabot> forall (f :: * -> *) b. (RegexContext Regex [Char] (AllMatches f b)) => f b
19:32:12 <kmc> this is a friggin crazy api
19:32:18 <ezyang> alexyk: Maybe hackage will have some of what you want?
19:32:35 <ezyang> kmc: "That's what you get for tryin' to use regexes in a statically typed language"
19:32:50 <kmc> :t getAllSubmatches ("abc" =~ "a(b)c") :: [String]
19:32:51 <lambdabot>     No instance for (RegexContext
19:32:52 <lambdabot>                        Regex [Char] (AllSubmatches [] String))
19:32:52 <lambdabot>       arising from a use of `=~' at <interactive>:1:18-33
19:32:56 <kmc> getAllSumbitches
19:33:11 <ezyang> alexyk: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics
19:33:34 <tass> Feckin' confusing. It's so easy in perl and PHP.
19:33:44 <alexyk> indeed, thx
19:33:54 <kmc> could instead have more operators
19:33:59 <kmc> i don't see why they have to overload this one to all hell
19:34:25 <ezyang> I vaguely recall similar shenanigans for Printf?
19:34:27 <kmc> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/ ?
19:34:36 <kmc> printf is variadic though
19:34:46 <kmc> anyway it seems that compiling regexps using TH would be a good approach
19:34:56 <lazni> @src Handle
19:34:56 <tass> TH?
19:34:56 <lambdabot> Source not found. Maybe you made a typo?
19:35:00 <kmc> Template Haskell
19:35:08 <tass> And that is?
19:35:11 <ezyang> ack, I can't do fair disjunctions if I have infinite options...
19:35:27 <lazni> @src printf
19:35:28 <lambdabot> Source not found. You speak an infinite deal of nothing
19:36:32 <kmc> :t getAllSubmatches ("abc" =~ "a(b)c")
19:36:33 <lambdabot> forall (f :: * -> *) b. (RegexContext Regex [Char] (AllSubmatches f b)) => f b
19:37:17 <ezyang> yigh, foldl interleave mzero, doesn't do what I want
19:37:25 <tass> To get my regexes in context with my datatype, this is what I do.
19:37:29 <tass> ILine s = IRCLine (s =~ "^:(.+)!") (s =~ "~(.+@.+)") (s =~ "") (s =~ ".*\\s(.*)\\s:.*") (s =~ "\\s:(.+)$")
19:37:37 <kmc> :t ("abc" =~ "a(b)c") :: MatchText String
19:37:39 <lambdabot>     No instance for (RegexContext Regex [Char] (MatchText String))
19:37:39 <lambdabot>       arising from a use of `=~' at <interactive>:1:1-16
19:37:39 <lambdabot>     Possible fix:
19:37:54 <kmc> :t ("abc" =~ "a(b)c") :: (String, MatchText String, String)
19:37:55 <lambdabot> (String, MatchText String, String)
19:37:57 <kmc> > ("abc" =~ "a(b)c") :: (String, MatchText String, String)
19:37:59 <lambdabot>   ("",array (0,1) [(0,("abc",(0,3))),(1,("b",(1,1)))],"")
19:38:02 <kmc> whaaat
19:38:06 <ezyang> whoa
19:38:10 <ezyang> that... sorta looks correct
19:38:15 <kmc> that can't be the easiest route
19:38:16 <tass> And there's no way in hell I'm gonna type that lotta bull per regex ;_;
19:38:17 <kmc> lesse
19:38:26 <kmc> > ("abc" =~ "a(b)c") :: [String]
19:38:27 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
19:38:28 <lambdabot>                    ...
19:38:28 <ezyang> tass: Use parsec!
19:38:30 <kmc> > ("abc" =~ "a(b)c") :: [[String]]
19:38:31 <lambdabot>   [["abc","b"]]
19:38:33 <kmc> :O
19:38:41 <kmc> > ("abc" =~ "a((b)(c))") :: [[String]]
19:38:42 <ezyang> "you'll still have to type a lot, but it'll be maintainable and readable and composable"
19:38:42 <lambdabot>   [["abc","bc","b","c"]]
19:38:58 <kmc> i think [[String]] might be the simple way to go
19:39:10 <kmc> > ("0a0b" =~ "0(.)") :: [[String]]
19:39:11 <lambdabot>   [["0a","a"],["0b","b"]]
19:39:30 <tass> Well, gee. Hmm... means I'll have to make my get functions to parse lists then.
19:39:40 <tass> Heh, this will be fun.
19:39:40 <kmc> list of matches; each list has full string + submatches
19:39:47 <kmc> full string + sumbitches
19:39:54 <kmc> leon sumbitches
19:40:16 <tass> This will be positively crazy! : D
19:40:31 <tass> So... how would I modify this?
19:40:33 <tass> data IRCLine = IRCLine String String String String
19:40:33 <tass> irc_nick :: IRCLine -> String
19:40:36 <ezyang> "editor combinators duuude"
19:40:39 <tass> irc_nick     (IRCLine nick _ _ _ _) = nick
19:41:20 <tass> I obviously need to do some nice mumbo jumbo to that String.
19:41:42 <kmc> tass, btw, did you see there's already a library for parsing IRC?
19:41:53 <tass> kmc: No, I didn't
19:42:28 <kmc> on hackage
19:42:31 <tass> Though, I guess re-inventing the wheel has it's benefits when it comes to learning.
19:42:36 <kmc> yes
19:42:54 <kmc> don't let me discourage you; in fact i too have learned something by you reinventing the wheel :)
19:43:13 <tass> Profit for all eh? : )
19:43:31 <kmc> One thing I've learned from open-source software is that if you invent enough wheels, one of them will turn out to be round and capable of rolling.
19:43:41 <MoALTz> heheh
19:43:47 <tass> True words ; )
19:44:29 <tass> Sooo.... each regex should look like this then? : P -> (s =~ "^:(.+)!" :: [[String]])
19:44:41 <kmc> hmm, what's P?
19:44:45 <ezyang> @quote kmc One thing I've learned from open-source software is that if you invent enough wheels, one of them will turn out to be          round and capable of rolling.
19:44:46 <lambdabot> No quotes match. My pet ferret can type better than you!
19:44:53 <ezyang> @remember kmc One thing I've learned from open-source software is that if you invent enough wheels, one of them will turn         out to be          round and capable of rolling.
19:44:54 <lambdabot> Nice!
19:45:00 <kmc> aww whitespace
19:45:07 <ezyang> can we unteach lambdabot quotes?
19:45:10 <kmc> @quote rolling
19:45:10 <lambdabot> olsner says: I've always mostly equated coding perl and trolling
19:45:15 <tass> (s =~ "^:(.+)!" :: [[String]])
19:45:16 <tass> rather
19:45:17 <tass> heh
19:45:17 <kmc> @quote capable.of.rolling
19:45:17 <lambdabot> kmc says: One thing I've learned from open-source software is that if you invent enough wheels, one of them will turn         out to be          round and capable of rolling.
19:46:37 <ezyang> i dinnae ken how to unteach lambdabot quotes
19:47:55 <BMeph> @quote capable.of.rolling
19:47:55 <lambdabot> kmc says: One thing I've learned from open-source software is that if you invent enough wheels, one of them will turn out to be round and capable of rolling.
19:48:01 <BMeph> \o/
19:48:24 <ezyang> cool
19:49:44 <kmc> thanks BMeph
19:49:47 <ezyang> Is there a real name for... "triangle" search?
19:50:53 <BMeph> ezyang: What, you don't like the diag? ;)
19:51:02 <BMeph> kmc: You're welcome. :)
19:51:15 <ezyang> BMeph: I don't think it's called diagonal search either?
19:52:03 <ezyang> I wonder if A* would be improved by the Logic monad
19:53:24 <Cale> > [0..] >>- \x -> [0..] >>- \y -> return (x,y)
19:53:25 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0...
19:53:32 <Cale> ezyang: That search?
19:53:37 <ezyang> Oh, hmm, I guess I'm not quite doing legit searches because I'm not returning intermediate nodes
19:53:49 <ezyang> Cale: yeah, that one
19:54:15 <BMeph> ezyang: Look for the Omega Monad. :)
19:54:45 <BMeph> ...or that. :)
19:54:47 <Cale> Is it even a monad?
19:54:55 <ezyang> "I'm doing this for my TMR article about Logic/Prompt/Failure monads" >.>
19:55:08 <ddarius> Cale: Not under observational equality for the laws.
19:55:24 <Cale> That's what I'd expect
19:55:30 <ezyang> BMeph: Ooh, logic totally gets this effect too
19:55:54 <tensorpudding> what is an omega monad?
19:56:01 <ddarius> @hackage Omega
19:56:02 <lambdabot> http://hackage.haskell.org/package/Omega
19:56:02 <ezyang> "A monad for enumerating sets: like the list monad, but impervious to infinite descent. "
19:56:25 <Cale> I also don't understand why it's called Omega.
19:56:33 <tensorpudding> sounds complicated
19:56:37 <Cale> oh, the ordinal
19:59:57 <ezyang> cool, I have an outline for the logic monad
20:01:13 <BMeph> Cale: As opposed to...CL
20:01:18 <BMeph> ?
20:01:35 <kmc> :t (>>-)
20:01:36 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
20:01:47 <kmc> @hoogle (>>-)
20:01:48 <lambdabot> No results found
20:02:07 <ezyang> I don't know why logic's not in Hoogle
20:02:26 <kmc> what's that operator do?
20:02:35 <ray> :t (-<<)
20:02:37 <lambdabot> Not in scope: `-<<'
20:02:58 <ezyang> kmc: It's fair conjunction
20:03:30 <ezyang> it protects you if the second argument non-terminates
20:04:53 <mmorrow> , '(>>-)
20:04:54 <lunabot>  Control.Monad.Logic.Class.>>-
20:05:15 <Cale> BMeph: hm?
20:05:44 <mmorrow> CL = Ceramic Lambdas?
20:06:12 <gwern> mmorrow: now you can microwave your monads and the soup they contain
20:06:20 <mmorrow> gwern: yay!
20:06:31 <Philonous>  Combinatory logic
20:06:52 <mmorrow> Philonous: but that's not microwave-safe!
20:07:17 <ezyang> In defense of burritos, perhaps one of the best metaphors I've gotten was my math professor describing direct sums as sticking sets into a pot.
20:07:19 <dolio> mmorrow: How big is PAGE_SIZE?
20:07:27 <ezyang> "just in case you wanted to know"
20:07:28 <mmorrow> dolio: 4096 bytes on linux
20:07:38 <mmorrow> dolio: definitely reasonable
20:07:52 <dolio> Yeah, that's not bad.
20:08:22 <dolio> Burritos are containers, so obviously they're monads.
20:08:46 * ezyang will definitely put a slide with a burrito in his talk 
20:09:02 <mmorrow> dolio: the most desirable bit about that scheme imo is how every write to a page other than the first one carries zero overhead
20:09:22 <BMeph> Didn't Dominus talk about burritos today? :)
20:10:09 <ezyang> BURRITO http://upload.wikimedia.org/wikipedia/commons/c/cc/Mission_burrito.jpg
20:12:06 <copumpkin> omnom
20:15:18 <dumael> ;_; hungry now.
20:16:40 <tass> kmc: You around still? : )
20:16:47 <kmc> yeah
20:16:56 <kmc> on and off
20:16:57 <tass> (s =~ "^:(.+)!.+@.+\\s" :: [[String]]) !!
20:17:04 <tass> (s =~ "^:(.+)!.+@.+\\s" :: [[String]]) !! 0 1
20:17:05 <tass> *
20:17:08 <kmc> looks like a cartoon character swearing
20:17:31 <tass> Does that look good to you? Haha
20:17:38 <kmc> i think you want !! 0 !! 1
20:17:41 <tass> I'm trying to convert it to a normal string
20:18:00 <tass> Oh, yeah
20:18:04 <kmc> > let f s = (s =~ "^:(.+)!.+@.+\\s" :: [[String]]) !! 0 !! 1 in f ":foo! blah"
20:18:06 <lambdabot>   "* Exception: Prelude.(!!): index too large
20:18:12 <kmc> > let f s = (s =~ "^:(.+)!.+@.+\\s" :: [[String]]) in f ":foo! blah"
20:18:13 <lambdabot>   []
20:18:27 <kmc> maybe you have to make the + in .+ non-greedy
20:18:30 <kmc> > let f s = (s =~ "^:(.+?)!.+@.+\\s" :: [[String]]) in f ":foo! blah"
20:18:32 <lambdabot>   []
20:18:36 <kmc> oh dur
20:18:52 <kmc> > let f s = (s =~ "^:(.+)!.+@.+\\s" :: [[String]]) in f ":foo! blah@blah "
20:18:54 <lambdabot>   [[":foo! blah@blah ","foo"]]
20:19:07 <kmc> > let f s = (s =~ "^:(.+)!.+@.+\\s" :: [[String]]) !! 0 !! 1 in f ":foo! blah@blah "
20:19:09 <lambdabot>   "foo"
20:19:09 <kmc> cool
20:19:22 <tass> Heh
20:19:33 <tass> This makes for some funky-ass one-liner
20:20:10 <blackdog> Axman6: hey, you around?
20:20:16 <mmorrow> kmc: for a second there i thought you were usually parallel lists (w/ the "[:"), which led me to check if lunabot has that extension on, and apparently it does
20:20:19 <mmorrow> , [:42:]
20:20:20 <lunabot>  [:42:]
20:20:24 <kmc> dph?
20:20:30 <mmorrow> i don't think any functions for that are in scope though
20:20:45 <mmorrow> kmc: i think this is different maybe (checking..)
20:21:15 <tass> ILine s = IRCLine ((s =~ "^:(.+)!.+@.+\\s" :: [[String]]) !! 0 !! 1) ((s =~ "~(.+@.+)" :: [[String]]) !! 0 !! 1) ((s =~ "" :: [[String]]) !! 0 !! 1) ((s =~ ".*\\s(.*)\\s:.*" :: [[String]]) !! 0 !! 1) ((s =~ "\\s:(.+)$" :: [[String]]) !! 0 !! 1)
20:21:19 <tass> omfg? : D
20:21:22 <kmc> madness
20:21:27 <copumpkin> oh my, write a damn parser already
20:21:29 <ezyang> MADNESS I SAY!
20:21:30 <kmc> pretty sure you can abstract that though
20:21:39 <tass> copumpkin: That _is_ the parser xD
20:21:41 <mmorrow> , ''([::])
20:21:42 <lunabot>  luna: parse error on input `[:'
20:21:45 <copumpkin> lol
20:21:50 <kmc> tass, any time you see that much repeated text in your code, it's time to write a helper function
20:21:51 <mmorrow> #ty [:42:]
20:21:55 <lunabot>  ()
20:21:57 <mmorrow> :o
20:21:59 <blackdog> tass: regex != parser
20:22:14 <tass> blackdog: Pfff, regex is great for parsing text!
20:22:17 <mmorrow> , [$ty| [: 42 :] |]
20:22:17 <tass> ^^
20:22:20 <lunabot>  ()
20:22:22 <kmc> :t let fg p s = ((s =~ p) :: [[String]]) !! 0 !! 1
20:22:23 <lambdabot> <no location info>:
20:22:23 <lambdabot>     not an expression: `let fg p s = ((s =~ p) :: [[String]]) !! 0 !! 1'
20:22:26 <kmc> :t let fg p s = ((s =~ p) :: [[String]]) !! 0 !! 1 in fg
20:22:28 <lambdabot> forall source source1. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 [[String]]) => source -> source1 -> String
20:22:29 <mmorrow> guess the parses in $ty is barfing
20:22:33 <mmorrow> *parser
20:22:38 <kmc> > let fg p s = ((s =~ p) :: [[String]]) !! 0 !! 1 in fg "foo (.) bar" "foo x bar"
20:22:40 <lambdabot>   "x"
20:22:42 <blackdog> tass: no, regexes are great at lexing text
20:22:45 <kmc> tass, use that ^^^^
20:23:01 <ray> they're not called context-free expressions
20:23:28 <kmc> this is Haskell, we try to avoid "design patterns", not worship them ;)
20:24:17 <tass> Haha, if there was a church for this, I'm pretty sure they would put me on a cross for typing such silly code
20:24:39 <blackdog> you may have your ordering a little confused there - i think the cross comes before the church...
20:24:41 <ezyang> GOOD NIGHT #HASKELL!
20:24:52 <copumpkin> good night
20:24:59 <tass> blackdog: Same difference ; )
20:25:59 <mmorrow> kmc: gah, i dunno what they are. iirc there used to be a "parallel list" group of modules, but they seem to have disappeared from the stdlib
20:25:59 <tass> Wow, now I need to remember how the heck I meant to use this code
20:27:26 <AndyP_> um, is it just me or have the prelude docs disappeared from haskell.org
20:27:55 * hackagebot upload: Cabal 1.8.0.2 - A framework for packaging Haskell software (DuncanCoutts)
20:28:07 <dcoutts> @arr!
20:28:07 <lambdabot> Aye
20:28:17 <tass> Though I'm yet to produce a working regex that fetches the host.
20:28:17 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Prelude.html loads fine to me.
20:28:46 <gwern> @quote two.problem
20:28:46 <lambdabot> No quotes match. Maybe you made a typo?
20:28:51 <copumpkin> @arr
20:28:51 <lambdabot> Yeh scurvy dog...
20:28:56 <gwern> argh
20:29:31 <gwern> @remember jwz Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.
20:29:32 <lambdabot> Done.
20:29:35 <gwern> @flush
20:29:38 <gwern> @quote two.problem
20:29:39 <lambdabot> jwz says: Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.
20:30:18 <AndyP_> monochrom: ok then the "here" link to the prelude docs on http://www.haskell.org/haskellwiki/Prelude needs fixing :) thanks btw
20:30:31 <tass> Ah-hah!
20:30:42 <tass> !~(.+)\\s[A-Z]
20:30:55 <blackdog> i think i've seen that quote attached to regexes, perl, sed and unix...
20:30:56 <tass> I'm getting a hang of this madness!
20:31:37 <dumael> blackdog: threads as well.
20:32:10 * monochrom cannot think of a good way to fix it permanently.
20:32:42 <blackdog> dumael: heh. i think jwz is the mark twain of the computing world. any time someone comes up with a pithy quote it gets attributed to him
20:33:03 <blackdog> we'll probably see "avoid success at all costs" attributed to him soon
20:33:17 <monochrom> Some people, when confronted with a problem, think "I know, I'll write a program." Now they have three problems.
20:33:46 <gwern> 3?
20:34:13 <absentia> xnmonochrom:  I recognize that.
20:34:16 <monochrom> The original problem, program correctness, and oh, which language or toolchain would you like?
20:34:28 <monochrom> And here is a more advanced version:
20:34:29 <absentia> from a cs quotes page...  dykstra?  who said it?
20:34:46 <monochrom> Some people, when confronted with a Project Euler problem, think "I know, I'll write a program." Now they have four problems.
20:35:14 <tass> regexarna är inte helt färdiga, men det kommer bli najs : D
20:35:21 <monochrom> I made it up. I do not know if someone else already said it.
20:35:44 * tass mutters something about no-sleep giddiness and wrong channels
20:36:09 <monochrom> (The original problem, program correctness, which language or toolchain to use, and oh, why is the program taking hours to run?)
20:37:23 <dumael> tass: exactly my problem too, bar having to write a 15 page review if a 3.5 page paper.
20:38:17 * tass grins.
20:38:25 <tass> Finally, my regex-madness is complete.
20:38:39 <absentia> ya? let me find my last one...
20:38:42 <tass> Now, to apply it.
20:39:00 <absentia> ("@_" =~ m@(?:^|\n)\s*\b$pat\b\s+(?:[^\n]*?)\s*([^\n\s]+?)\s*(?:#[^\n]*?)?\s*(?=\n)@ig);
20:39:13 <tass> Nice one ; )
20:39:16 <tass> ILine s = IRCLine ((s =~ "^:(.+)!.+@.+\\s" :: [[String]]) !! 0 !! 1) ((s =~ "!~(.+\\s[A-Z]" :: [[String]]) !! 0 !! 1) ((s =~ "!~.+\\s([A-Z]*)\\s" :: [[String]]) !! 0 !! 1) ((s =~ "!~.+\\s[A-Z]*\\s(.+):.+$" :: [[String]]) !! 0 !! 1) ((s =~ "!~.+\\s[A-Z]*\\s.+:(.+)$" :: [[String]]) !! 0 !! 1)
20:40:53 <tass> Mmm... tasty juicy regex.
20:41:35 <gwern> at some point you need to say screw it we'll do it live with parsers
20:41:57 <tass> gwern: Pfft, regex works ; )
20:43:23 <mmorrow> tass: those are famous last words
20:44:07 <tass> > (":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message" =~ "^:(.+)!~(.+)\\s([A-Z]*)\\s(.+)\\s:(.+)$" :: [[String]])
20:44:09 <lambdabot>   [[":tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message","tass","tass@127.0....
20:44:17 <tass> Meh, output got cut off : (
20:44:35 <tass> Anyway, that creates a long-ass list with all my stuff in it.
20:44:58 <tass> Should be able to use that to make a tiny bit more readable thing.
20:45:32 <MoALTz> i wish @more would work so you could get the rest of the result
20:45:33 <kmc> tass, write a helper function!
20:46:04 <kmc> see all that repeated ":: [[String]]) !! 0 !! 1"
20:46:09 <mmorrow> tass: shouldn't that be "^:([^!])+  ?
20:46:10 <kmc> repeating stuff is the computer's job, not yours
20:46:27 <tass> mmorrow: Dunno, it worked for me ; )
20:46:53 * mmorrow would've thought that (.+) would just match /everything/
20:46:57 <tass> kmc: Well, I'm not, if I make that list thingy
20:47:11 <tass> mmorrow: It does, unless something is at the end of it.
20:47:18 <tass> Ergo, outside the ()
20:48:01 <tass> "^(.+)\\s" matches the first word
20:48:04 <tass> For example
20:48:12 <mmorrow> tass: so it's implicitly making "(.+)a" ==> "([^a])+" ?
20:48:37 <mmorrow> since ".+" := any number of anything
20:48:50 <tass> mmorrow: No, it's one or more of anything.
20:48:51 <adu> no 1-or-more of anything
20:48:59 <mmorrow> tass: right
20:49:05 <mmorrow> that's what i meant
20:49:06 <monochrom> .+ misses the empty string
20:49:09 <tass> () specifies a subpattern
20:49:10 <ToxicFrog> tass: shouldn't ^(.+)\s match everything up to the last whitespace?
20:49:12 <mmorrow> but that's not the relevant part here
20:49:12 <adu> "any number" kinda means 0 or more, since 0 is a number
20:49:25 <tass> ToxicFrog: No, to the first whitespace.
20:49:34 <ToxicFrog> + is usually greedy, in my experience.
20:49:39 <tass> Hmm..
20:50:00 <adu> on a slightly different note, hi mmorrow :)
20:50:00 <mmorrow> yeah, mine too
20:50:01 <ToxicFrog> > = string.match("foo bar baz", "^(.+)%s")
20:50:01 <ToxicFrog> foo bar
20:50:03 <lambdabot>   <no location info>: parse error on input `='
20:50:06 <mmorrow> adu: oh hai!
20:50:07 <tass> Dunno, my regex matches the whole string and splits it into subpatterns, so it works I guess. : )
20:50:20 <tass> "^:(.+)!~(.+)\\s([A-Z]*)\\s(.+)\\s:(.+)$"
20:50:33 <ToxicFrog> Careful, you'll put someone's eye out with that thing.
20:50:59 <ToxicFrog> (that looks like an IRC protocol disassembly regex)
20:51:08 <tass> ToxicFrog: It is.
20:52:41 <adu> > showIntAtBase 12 (" ,abdehilmsy"!!) 370014860487378190594194395 ""
20:52:42 <lambdabot>   "disassembly, dishashembly"
20:52:44 <mmorrow> it looks like pcre regexes aren't greedy by default i guess
20:52:59 <mmorrow> [m@monire ~]$ echo ':tass!~tass@127.0.0.1 PRIVMSG #shub :Sample message' | perl -lne '/^:(.+)!~(.+)\s([A-Z]*)\s(.+)\s:(.+)$/; print "$1 $2"'
20:52:59 <mmorrow> tass tass@127.0.0.1
20:53:23 <tass> Yeah
20:53:31 <ToxicFrog> Aah
20:53:40 <ToxicFrog> Most of my regexing is sed, awk, and lua
20:53:51 <mmorrow> mine too (sed/grep)
20:54:14 <tass> Eller lite snyggare, IRCSplit s = (s =~ "^:(.+)!~(.+)\\s([A-Z]*)\\s(.+)\\s:(.+)$") !! 0
20:54:32 * tass eats a match
20:55:06 <monochrom> Most of my regexing is sad.
20:55:06 <tass> Well, that function should be quite useful.
20:56:48 <adu> most of my regexing is grep
20:56:54 * adu <3 grep
20:57:06 <tass> Most of my regexing is perl/PHP
20:57:14 <tass> Well, PCRE, really.
20:57:45 <adu> i use sed about once every 100 grep usages
20:57:58 <jkingcong> i've been looking into building an automated trading platform in haskell. is anybody doing this?
20:58:03 <adu> i don't know where anything is :P
20:58:15 <jkingcong> (sorry for interrupting) :D
20:58:18 <adu> i use grep instead of Apple Spotlight
21:01:04 <mmorrow> jkingcong: cjk wrote a trading-related prog in haskell, maybe ask him about it when he comes around again
21:01:22 <jkingcong> haha funny you mentioned him
21:01:28 <jkingcong> i actually wrote him an email
21:01:35 <jkingcong> because his name came up in a couple wikis
21:01:38 <jkingcong> mailing lists
21:01:48 <jkingcong> maybe he'll respond :)
21:02:05 <ToxicFrog> adu: I use grep a lot more than sed, but most of my grep usage is fgrep.
21:04:32 <adriyel> @pl \x y -> x y
21:04:33 <lambdabot> id
21:04:38 <adriyel> @unpl id
21:04:39 <lambdabot> (\ a -> a)
21:04:47 <adriyel> @pl \x y -> x + 1
21:04:48 <lambdabot> const . (1 +)
21:04:54 <mmorrow> jkingcong: here's a video of cjk's presentation about it at ICFP this year http://www.vimeo.com/6623087
21:05:04 <tass> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14292
21:05:15 <tass> kmc: Think that works?
21:05:26 <jkingcong> mmorrow: watching now thanks a lot!
21:05:27 <adu> ToxicFrog: most of my usage is "grep -r"
21:05:42 <mmorrow> jkingcong: and here's cjk's company's website http://www.starling-software.com/en/
21:06:21 <mmorrow> jkingcong: and they've got some blogs, i know i've read some stuff about his stuff in one of them before, but don't remember which http://www.starling-software.com/en/blog/
21:06:52 <jkingcong> mmorrow: have you tried any of this stuff yourself?
21:07:09 <mmorrow> jkingcong: and finally, here's the root of that vimeo account, it has a CUFP section too, which you might find interesting http://www.vimeo.com/user2191865/albums
21:07:32 <jkingcong> mmorrow: great
21:07:48 <jkingcong> mmorrow: my first hurdle is interfacing with the market itself
21:08:07 <jkingcong> mmorrow: i doubt any of the major direct access brokers have an API for haskell
21:08:11 <mmorrow> jkingcong: "this stuff" being trading software? not in particular, but i've written various code in haskell for an insurance company as a consultant off-and-on
21:08:27 <Luke> jkingcong: do you have a way to access the market?
21:08:31 <jkingcong> mmorrow: i see
21:08:43 <jkingcong> Luke: haha yes therein lies the issue
21:08:57 <tass> Or to add some more relevant info
21:09:00 <tass> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14292#a14293
21:09:09 <Luke> jkingcong: how do you do it?
21:09:19 <jkingcong> Luke: interactivebrokers for example, has an API for java, C++, vbscript
21:09:20 <mmorrow> jkingcong: i'd imagine you'll need to implement whatever protocol in haskell
21:09:26 <Luke> jkingcong: ah
21:09:44 <jkingcong> mmorrow: yea, i figured as much
21:09:50 <Luke> jkingcong: do you have a financial background?
21:10:01 <jkingcong> mmorrow: of course, there's always hoping somebody did the work there already :)
21:10:05 <mmorrow> heh
21:10:10 <jkingcong> luke: i'm actually a math/physics student
21:10:17 <jkingcong> luke: with a lot of hobbies interests
21:10:29 <Luke> cool
21:10:31 <jkingcong> luke: projecteuler and finance being the big two right now
21:11:23 <whoppix> jkingcong, what exactly is it you're studying?
21:11:24 <Luke> jkingcong: what school?
21:11:36 <jkingcong> applied physics at cornell
21:11:39 <jkingcong> and math
21:11:43 <Luke> when are you done?
21:11:49 <jkingcong> i finish upcoming may
21:11:55 <whoppix> jkingcong, can you actually study both of those simultaneously?
21:12:02 <jkingcong> yep
21:12:07 <Luke> do you have a job?
21:12:08 <jkingcong> i came in with a lot of credit
21:12:14 <jkingcong> not yet
21:12:16 <jkingcong> looking :)
21:12:20 <whoppix> jkingcong, isn't that an awfull lot of work?
21:12:27 <jkingcong> it's tough because i want to go to grad school eventually
21:12:31 <jkingcong> haha
21:12:41 <jkingcong> whoppix: indeed, i work long hours
21:12:54 <whoppix> I'm just studying a single subject - music - right now, and I think it's a fair share of work.
21:13:26 <jkingcong> whoppix: i believe you. i'm learning logic pro in my spare time too. heh
21:13:36 <jkingcong> luke: what do you do?
21:13:48 <whoppix> jkingcong, logic pro?
21:14:01 <jkingcong> whoppix: arranging software for music
21:14:09 * hackagebot upload: atom 0.1.4 - A DSL for embedded hard realtime applications. (TomHawkins)
21:14:42 <ToxicFrog> adu: ditto. But the pattern is usually not a regex, so it's effectively fgrep.
21:15:03 <whoppix> jkingcong, ah, I see. that one seems to be for osx. I've only worked with a few of the common windows softwares so far; cubase, pro tools, FL studio, sonar catwalk and sibelius & propellerheads reason for arranging scores.
21:15:25 <whoppix> I've had a go at garage band once on my gf's macbook, but I didn't figure it out :)
21:15:34 <adu> ToxicFrog: aah, i see
21:15:37 <jkingcong> whoppix: yup all in the same vein. i used reason before logic pro
21:15:52 <jkingcong> whoppix: logic pro is really nice and simple
21:16:36 <Luke> jkingcong: pm
21:16:39 <whoppix> jkingcong, ah. I think at my university we are pretty much nailed on cubase, since my teachers would only take that format, as far as I've heard; but i haven't got any practical assignments so far :/
21:16:59 <whoppix> except for arranging scores on paper
21:19:50 <jkingcong> whoppix: where do you go?
21:20:02 <whoppix> jkingcong, university in oslo
21:20:30 <whoppix> Just started this fall.
21:20:30 <adu> Starling software boo
21:20:43 <jkingcong> adu: haha how so?
21:21:00 <jkingcong> whoppix: awesome, i'm sure it'll be a great experience
21:21:03 <adu> jkingcong: I downloaded QAM, and followed the tutorial, and I got a bunch of errors
21:21:43 <whoppix> jkingcong, well, I'm considering switching to math or physics, or perhaps quantum physics, if we have a course on that.
21:21:57 * adu <3 math
21:24:02 <jkingcong> adu: mm i was going to give that whirl too
21:24:18 <jkingcong> whoppix: ah yes, i took a year of quantum
21:24:44 <whoppix> jkingcong, was it interesting?
21:28:30 <jkingcong> whoppix: definitely. it helps to have some algebra under your belt before you take it
21:29:29 <whoppix> jkingcong, yeah, I'm kinda lacking a lot in that area, and I'm generally missing some math basics, but I think I might have the nessecariy interest and motivation to read up on that on my own.
21:30:43 <whoppix> so right now I'm reading on some of the stuff I unfortunately didn't get in school, like function derivation and integration.
21:31:04 <whoppix> oh boy
21:31:40 <jkingcong> whoppix: yup. knowing the math really will makes physics a lot more doable
21:32:04 <jkingcong> whoppix: a course in analysis wouldn't hurt either
21:33:18 <whoppix> I'll have a look wether I find any course on that scheduled and see if I can sneak in (I do that a lot in math & physics lectures recently :D)
21:33:28 <clarkb> intro to physics taught me all the calculus I needed :)
21:33:49 <clarkb> "This is a differential equation don't worry about the math, but this is how you solve it"
21:34:11 <jkingcong> hehe
21:34:31 <jkingcong> certainly, a good intuition doesn't hurt either
21:34:38 <jkingcong> i need to get going
21:34:40 <xerox> That's like handing fish versus teaching fishing.
21:34:46 <MoALTz> i wonder how many days the botnet used to attack freenode was hired for
21:35:06 <jkingcong> my exam is getting closer :(
21:35:14 <jkingcong> whoppix: cya, good luck
21:35:18 <MoALTz> good lucky
21:35:19 <whoppix> Thanks, you too.
21:35:22 <MoALTz> *luck heh
21:35:30 <jkingcong> moaltz: thanks you too
21:36:00 <whoppix> I'm writing my last examn for this semester right now.
21:36:16 <whoppix> After that I'll have some spare time, thanksfully - maybe I can get some coding done.
21:37:20 <tass> Wowie, what an adventure writing that split function was, and now on to next problem *head desks*
21:56:03 <erikc> anyone know of any companies in the toronto area using functional programming?
22:02:10 <tass> Does haskell have any else if kind of thing?
22:03:10 <whoppix> tass, I mostly tend to making a function with different function clauses for that kind of thing.
22:03:22 <Cale> if <condition> then <expr1> else <expr2>
22:03:29 <Cale> But yes, use guards if you can.
22:04:06 <copumpkin> tass: else if = else + if :P
22:04:17 <copumpkin> if p then x else if q then y else z
22:04:22 <copumpkin> but yeah, don't do it
22:04:25 <tass> Meh, I'll do it the ugly way then :<
22:04:49 <copumpkin> pattern matching and guards are way better
22:04:49 <whoppix> I guess you could use case?
22:05:04 <Cale> case () of
22:05:06 <Cale>  _ | <cond1> -> <result1>
22:05:15 <Cale>    | <cond2> -> <result2>
22:05:20 <copumpkin> case (cond1, cond2) of (True, True) -> ...
22:05:52 <erikc> hey Cale, do you know any waterloo companies using fp?
22:07:45 <tass> I'm too tired to debunk this type mismatch..
22:08:15 <copumpkin> me too
22:09:13 <tass> I'll crash like a boeing 747 with b0rked engines tonight.
22:09:50 <monochrom> and flying just 5 cm above ground
22:10:06 <monochrom> Like what they say about hard disks and heads.
22:10:14 <tass> Heh.
22:11:18 <Cale> erikc: I can't really name many Waterloo companies apart from Maple and RIM
22:11:34 <Cale> erikc: (and some restaurants :)
22:11:54 <copumpkin> omnom
22:11:56 <erikc> haha, k
22:12:01 <copumpkin> Haskell Grill
22:12:33 <ray> fettucinni della cale
22:12:58 <copumpkin> la Cale?
22:13:08 <copumpkin> è femminile
22:17:17 <tass> Naaah, sod it, I give up for now.
22:17:28 <tass> Time for breakfast and wurk wurk
22:20:25 * BMeph wishes there were another way to differentiate something like a type class, except without using types...
22:24:56 <kmc> @quote integerToBreakfast
22:24:57 <lambdabot> integerToBreakfast says: = (["Cornflakes", "Strawberry jam toast", "Grapefruit", "Cup of tea and a biscuit, gotta dash", "Bacon, eggs, toast, tomato and mushroom. You deserve it", "Waffles", "
22:24:57 <lambdabot> Porridge of some description", "Orange juice and muffins", "Apples, pears, mango and kiwi", "A selection of cold meats with crisp bread", "Headache pills and water", "Leftover pizza", "Leftover
22:24:57 <lambdabot> vindaloo curry"] !!)
22:34:21 <mtnviewmark> :t floor
22:34:22 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:34:56 <mtnviewmark> ugh - why? usually when working with reals, when I call floor or ceiling, i still want to work with reals!
22:35:43 <kmc> :t fromIntegral . floor
22:35:44 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
22:36:19 <kmc> mtnviewmark, "why" is the usual type-expressiveness reason; you want the function to express everything it can about its return value in its type
22:37:03 <mtnviewmark> well, in this case, there is practical considerations -
22:37:40 <mtnviewmark> I bet that most code that calls round or truncate expects an integral, whereas most that calls floor or ceiling needs that back as a "same type"
22:38:05 <mtnviewmark> just think it make the code bulkier in these cases
22:39:14 <kmc> it would be nice if Prelude had floor' = fromIntegral . floor
22:39:29 <kmc> in lieu of that you can define it yourself
22:39:32 <MoALTz> thought it did have floor
22:39:40 <kmc> i've quite often used floor and ceil for integral results
22:39:51 <MoALTz> prelude does have floor
22:40:07 <kmc> <kmc> it would be nice if Prelude had floor' = fromIntegral . floor
22:40:14 <kmc> :t floor
22:40:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:40:17 <kmc> :t fromIntegral . floor
22:40:18 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
22:40:27 <MoALTz> ah
22:40:29 <kmc> > (fromIntegral . floor) 3.5 :: Float
22:40:30 <lambdabot>   3.0
22:40:32 <kmc> > floor 3.5 :: Float
22:40:33 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Float)
22:40:33 <lambdabot>    arising from a use o...
22:45:24 <mwc> kmc: perhaps the consider floor and ceiling forms of rounding?
22:47:07 <MoALTz> mwc: isn't so nice. they'd preserve the time if they were just that(?)
22:47:29 <MoALTz> *type
22:47:46 <kmc> :t round
22:47:50 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:48:14 <kmc> :t truncate
22:48:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:49:13 <kmc> > map (liftM (,) round truncate) [-3.5, -0.5, 0, 0.5, 3.5]
22:49:14 <lambdabot>   No instance for (GHC.Real.RealFrac (a -> b))
22:49:14 <lambdabot>    arising from a use of `GHC....
22:51:05 <kmc> :(
22:52:23 <copumpkin> liftM2?
22:52:58 <kmc> whoops
22:53:02 <kmc> > map (liftM2 (,) round truncate) [-3.5, -0.5, 0, 0.5, 3.5]
22:53:03 <lambdabot>   [(-4,-3),(0,0),(0,0),(0,0),(4,3)]
22:53:21 <kmc> > map (liftM2 (,) floor truncate) [-3.5, -0.5, 0, 0.5, 3.5]
22:53:22 <lambdabot>   [(-4,-3),(-1,0),(0,0),(0,0),(3,3)]
23:12:45 <kmc> impredicative polymorphism is deprecated?
23:13:06 <Cale> kmc: At least on a temporary basis.
23:13:47 <Cale> The implementation of it in GHC is considered too complicated to maintain, so they're either replacing the implementation or ditching it altogether by 6.14, apparently.
23:14:55 <kmc> okay.  the workaround is to declare a new datatype which contains the quantification?
23:15:36 <kmc> i have often wanted, e.g.  Data.Map.Map String (forall a. (Num a) => a -> a -> a)
23:15:42 <kmc> how would i express that now?
23:15:59 <Cale> I suppose, yeah.
23:16:09 <Cale> data NumOp where
23:16:34 <Cale>   NumOp :: (forall a. (Num a) => a -> a -> a) -> NumOp
23:16:42 <Cale> Perhaps.
23:16:50 * kmc tries it
23:19:51 <kmc> okay, i can do what i want with {-# LANGUAGE RankNTypes, GADTs #-}
23:19:53 <kmc> thanks
23:20:11 <Cale> Actually, you probably don't need the GADTs either
23:20:36 <kmc> indeed, but it's a generally nicer way to write types
23:20:39 <Cale> yeah
23:24:02 <kmc> so "impredicative" refers to situations where a quantifier appears in a type argument, but not those where it appears merely in a constructor field
23:24:18 <kmc> those would be rank-N, since the quantifier ends up to the left of (->) in the ctor's type
23:24:22 <kmc> is that correct?
23:24:59 <Saizan> impredicative is when you want to instantiate a quantified type variable to a quantified type
23:26:36 <Saizan> what do you mean by type argument?
23:30:08 <kmc> the thing on the right in a System F type application
23:30:11 <kmc> maybe it's not the right term
23:30:37 <kmc> is there a simple explanation for how that relates to the concept of impredicativity in logic?
23:31:00 <Saizan> ah, then yeah, it's that
23:32:41 <Saizan> it relates in the sense that if we allow such instantiations then the range of the quantifications includes the same type you're defining with such quantifications
23:33:36 <kmc> can we use this directly to encode something like Russell's paradox?
23:34:05 <kmc> the encodings i've seen involve a wrapper for the recursive type of naive sets, which is not polymorphic
23:34:19 <kmc> although it does contain type recursion in a negative position
23:35:36 <dolio> Technically GHC lets you instantiate a type argument to a quantified type, as long as that argument doesn't have a datatype applied to it.
23:36:04 <dolio> Which is impredicative, but GHC doesn't care, I guess.
23:36:43 <kmc> > id :: (forall a. a) -> (forall b. b)
23:36:44 <lambdabot>   No instances for (Test.SmallCheck.Serial (forall a. a),
23:36:44 <lambdabot>                    ...
23:36:47 <kmc> :t id :: (forall a. a) -> (forall b. b)
23:36:49 <lambdabot> forall b. (forall a. a) -> b
23:36:49 <kmc> like that?
23:37:30 <dolio> And impredicativity isn't necessarily inconsistent. System F is impredicative, but strongly normalizing.
23:37:38 <dolio> Yes, like that.
23:38:29 <kmc> and i could do the same in System F
23:38:34 <dolio> I don't know enough about GHC's checker to tell you why that works, though.
23:39:37 <kmc> yup, it works with only RankNTypes
23:39:43 <kmc> i assume lambdabot has more extensions turned on
23:39:53 <kmc> :t Just undefined :: Maybe (forall a. a)
23:39:54 <lambdabot> Maybe (forall a. a)
23:40:04 <dolio> Yeah, I think it has -fglasgow-exts.
23:40:18 <kmc> > case (Just undefined :: Maybe (forall a. a)) of Just () -> ()
23:40:19 <lambdabot>   Couldn't match expected type `forall a. a'
23:40:19 <lambdabot>         against inferred type `()'
23:40:23 <kmc> > case Just undefined of Just () -> ()
23:40:24 <lambdabot>   * Exception: Prelude.undefined
23:41:15 <Saizan> > case (Just undefined :: Maybe (forall a. a)) of Just x -> case x of () -> ()
23:41:17 <lambdabot>   * Exception: Prelude.undefined
23:42:00 <kmc> > case undefined of () -> 1; 'x' -> 2
23:42:01 <lambdabot>   Couldn't match expected type `()'
23:42:01 <lambdabot>         against inferred type `GHC.Types....
23:42:13 <kmc> where's my polymorphic case expression ;)
23:43:01 <kmc> > (undefined, undefined (), undefined () ())
23:43:02 <lambdabot>   (* Exception: Prelude.undefined
23:43:11 <kmc> > let f = undefined in (f, f (), f () ())
23:43:13 <lambdabot>   (* Exception: Prelude.undefined
23:43:22 <kmc> > (\f -> (f, f (), f () ())) undefined
23:43:23 <lambdabot>   (* Exception: Prelude.undefined
23:43:53 <kmc> oh whoops
23:43:56 <Saizan> > (\f -> [f, f (), f () ()]) undefined
23:43:57 <lambdabot>   Occurs check: cannot construct the infinite type: t = () -> t
23:44:44 <kmc> :t (\(f :: forall a. a) -> [f, f (), f () ()]) undefined
23:44:45 <lambdabot> forall a. [a]
23:45:02 <emef> i know this is probably an easy question but how would I convert something of type Maybe t to plain t?
23:45:12 <kmc> emef, you need to decide what to do in the case where it's Nothing
23:45:29 <kmc> if the answer is "program crashes and burns", you can use fromJust
23:45:43 <emef> otherwise...?
23:45:47 <kmc> usually, you will want to do something for (Just x) and something for Nothing
23:45:52 <kmc> in which case, you should use a case expression
23:45:59 <emef> ahh
23:46:11 <kmc> > case Just 3 of Just v -> ("it's " ++ show v); Nothing -> "nothing to see here"
23:46:12 <lambdabot>   "it's 3"
23:46:35 <kmc> case expressions are a fundamental way of working with data types
23:46:47 <kmc> in the case of Maybe there are also some helper functions defined in terms of case
23:46:49 <kmc> :t maybe
23:46:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:46:53 <emef> ahh so the Maybe data type is most useful with a case structure?
23:46:56 <kmc> :t fromMaybe
23:46:58 <lambdabot> forall a. a -> Maybe a -> a
23:47:33 <kmc> emef, when you are processing a value of type (Maybe t) and want to "look inside" to see Nothing or (Just x), the fundamental way is to pattern-match
23:47:51 <kmc> this can be accomplished by a case expression, or by defining a function with multiple equations
23:47:53 <kmc> @src maybe
23:47:53 <lambdabot> maybe n _ Nothing  = n
23:47:54 <lambdabot> maybe _ f (Just x) = f x
23:48:01 <kmc> there's an example of the latter approach
23:48:34 <emef> ooh of course
23:48:51 <emef> for some reason I was making it much more complicated than it really is :)
23:49:05 <emef> thank you kmc
23:49:08 <kmc> no problem :)
23:50:05 <kmc> :t maybe Nothing Just
23:50:06 <lambdabot> forall a. Maybe a -> Maybe a
