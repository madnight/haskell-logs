00:00:34 <sohum> @hoogle mappend
00:00:34 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
00:01:23 <sohum> I think one reason that the monomorphism restriction bites us a lot more than it should
00:01:38 <sohum> there's no function synonym operator
00:01:52 <quicksilver> what would a function synonym operator be?
00:01:54 <sohum> = is not a synonym operator, because types can change
00:02:15 * jmcarthur_work doesn't know this terminology
00:02:23 <sohum> like, import Prelude hiding (++); (++) = mappend
00:02:42 <sohum> your intention is clearly to have (++) be a /synonym/ for mappend
00:02:43 <fasta> What are the  '!!'? PS !!(ForeignPtr Word8) !!Int !!Int	
00:02:52 <fasta> I know about !, but not !!.
00:03:11 <sohum> but (++) = mappend means "to use (++), use mappend".
00:03:20 <quicksilver> sohum: I don't understand
00:03:24 <quicksilver> fasta: a haddock bug, IIRC
00:03:37 <sohum> which means that the :t (++) <= :t mappend, when you want :t (++) == :t mappend
00:03:39 <fasta> quicksilver, yep, the source doesn't contain it.
00:03:57 <quicksilver> sohum: assuming you turn the monomorphism restriction off, you do get ++ as a synonym for mappend
00:04:06 <quicksilver> sohum: if you leave it on, you just get a compile-time error.
00:04:47 <sohum> quicksilver: the former behaviour only exists because ghc is generalising
00:05:12 <quicksilver> well, it exists because that is how the haskell type system works.
00:05:14 <jmcarthur_work> generalizing? (++) is not made any more general than its implementation...
00:05:18 <fasta> @hoogle String -> ByteString
00:05:19 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
00:05:19 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
00:05:19 <lambdabot> Prelude read :: Read a => String -> a
00:05:31 <sohum> basically, the user needs some way to signal that "I want these two names to be identical in semantics. implementation /and/ type."
00:05:35 <Baughn> So overlapping type-family instances are bad and forbidden and could lead to unsafeCoerce. But has anyone written an explanation for why? I can make guesses, but in the end they're just guesses.
00:05:46 <quicksilver> sohum: and how is that not what = does?
00:05:48 <jmcarthur_work> sohum, just leave out the type signature then?
00:06:03 <jmcarthur_work> and turn off MR
00:06:20 <sohum> quicksilver: because it doesn't guarantee type
00:06:37 <sohum> jmcarthur_work: well, we're attempting to keep the MR and just have it bite us less often
00:06:40 <dolio> Baughn: It's pretty easy to come up with examples. You need to use more than one module, though.
00:06:41 <jmcarthur_work> :t let (++) = mappend in (++)
00:06:43 <lambdabot> forall a. (Monoid a) => a -> a -> a
00:06:45 <edwardk> Baughn: sure, whenever you're in a context where you can only 'see' that the type is in the larger family but it came from the smaller one, you'll have switched types
00:06:55 <jmcarthur_work> sohum, what do you mean it doesn't guarantee it?
00:07:28 <sohum> :t let (++) :: [a] -> [a] -> [a]; (++) = mappend in (++)
00:07:29 <lambdabot> forall a. [a] -> [a] -> [a]
00:07:50 <jmcarthur_work> sohum, *you* specified the type there. that would not be default behavior
00:07:56 <Baughn> edwardk: I see. Yet another argument for global compilation, then.
00:08:25 <sohum> jmcarthur_work: my point exactly. = has a default behaviour, but the default behaviour can be modified.
00:08:30 <edwardk> baughn: build a module with a type family, and a big wide instance, then build another module with an instance of it that is more specific than the one visible in the other module, the former can't see the more specific instance.
00:08:35 <Baughn> (Yes, there are plenty against it, especially with GHC being in the state it is..)
00:08:37 <jmcarthur_work> sohum, and that's bad?
00:08:46 <dolio> "type family Foo a :: * ; type instance Foo a = a ; foo :: Foo () ; foo = ()" in one module "type instance Foo () = Int ; case foo of 0 -> "commence segfault"" in a second.
00:08:54 <sohum> jmcarthur_work: thus, = doesn't guarantee that the type remains the same
00:09:01 <sohum> jmcarthur_work: no!
00:09:05 <edwardk> Baughn: closing the world solves this, this is one reason why they want 'closed' type families for when you only want a finite number of exceptions
00:09:05 <Baughn> edwardk: Hm. So, what I want are closed type-families.
00:09:33 <jmcarthur_work> sohum, = guarantees that the lhs is no more general than the rhs...
00:09:42 <Baughn> edwardk: Is that slated for 6.14 or something?
00:09:43 <edwardk> Baughn: exactly
00:10:05 <sohum> jmcarthur_work: and I'd like a == or something that guarantees that the lhs is exactly as general as the rhs
00:10:14 <edwardk> Baughn: not sure. it was in the original spec, but i think they have their hands full getting little things like generalized newtype deriving and type families to play nice.
00:10:23 <edwardk> that they can conspire to unsafecoerce is a bit embarassing
00:10:28 <sohum> jmcarthur_work: because often that's what I'm intending, but I have to specify the type manually to avoid the MR
00:10:32 <jmcarthur_work> sohum, how is that better than type signatures?
00:10:34 <fasta> Is there a library which does the same as mystring.decode('hex') in Python?
00:10:46 <edwardk> at least you have to work at it ;)
00:11:05 <dolio> What does that do in python?
00:11:12 <sohum> jmcarthur_work: because it's redundant. (++) :: Monoid a => a -> a -> a; (++) = mappend is harder to understand than (++) == mappend
00:11:35 <jmcarthur_work> i think it's easier to understand because i normally look at the type before the implementation anyway
00:11:38 <Botje> fasta: Numeric.showIntAtBase . ord
00:11:57 <jmcarthur_work> my reasoning is that the implementation is generally just an implementation detail, not a specification
00:12:42 <sohum> the point is that you have to know things about mappend to realise that (++) is being used equivalently to mappend in this program
00:12:50 <sohum> you shouldn't need to
00:12:58 <jmcarthur_work> sohum, that's what a type signature is for
00:13:23 <sohum> jmcarthur_work: ... what? how does a type signature save you from having to know about mappend's type signature?
00:13:24 <jmcarthur_work> or are you talking about things not captured in the type?
00:13:42 <jmcarthur_work> sohum, a type signature for (++) means you don't have to look up the type signature for mappend
00:14:40 <sohum> jmcarthur_work: no, a type signature for (++) could be anything <= mappend's. You have to know mappend's type sig to know that it's being used as an exact synonym.
00:15:21 <jmcarthur_work> sohum, i generally don't care if it's a synonym. this is the point of abstraction
00:16:04 <mux> I don't get why we don't just keep mappend as it is and have (++) = mappend with a type specialized to strings
00:16:27 <sohum> jmcarthur_work: you don't, maybe. the readers of your code do, especially if mappend is a library function (which it is) that they already know about. the compiler (given the MR) definitely cares.
00:16:31 <jmcarthur_work> mux,  what would that change?
00:16:51 <mux> jmcarthur_work: well, nothing, which is the cool point about it
00:17:35 <mux> seriously, the only change would be in t he definition of (++)
00:17:45 <mux> no need to reimplement it
00:18:15 <jmcarthur_work> mux, it's not reimplemented afaik. the string instance for Monoid just says mappend = (++) doesn't it?
00:18:19 <sohum> mux: acutally, you'd swap the locations of the definitions. I believe instance Monoid [] where mappend = (++) is defined as such
00:18:36 <jmcarthur_work> err, list i mean, yes
00:18:43 <mux> jmcarthur_work: I've just looked up the source on hayoo and it seems it is
00:18:59 <gio123> sohum: Abkhazia?
00:19:09 <sohum> gio123: ?
00:19:11 <EnglishGent> has anyone managed to get libmagic working with haskell? it's packaged for cabal - but cabal complains about a missing C library when I try to install it
00:19:23 <sohum> EnglishGent: which c library?
00:20:02 <EnglishGent> missing C library : magic
00:20:07 <osaunders> What does this error mean?
00:20:11 <osaunders> > let addTwo :: (Enum a) => a -> a; addTwo = succ . (+)
00:20:12 <lambdabot>   not an expression: `let addTwo :: (Enum a) => a -> a; addTwo = succ . (+)'
00:20:14 <zygoloid> EnglishGent: do you have that C library installed?
00:20:23 <osaunders> Oh not that error.
00:20:24 <sohum> EnglishGent: libmagic-dev, I'd assume
00:20:30 <EnglishGent> well I think so - as I believe file uses it
00:20:36 <osaunders> This error: Occurs check: cannot construct the infinite type: a = a -> a
00:20:38 <EnglishGent> I can apt-get the dev version if that helps
00:20:55 <zygoloid> EnglishGent: yeah, you'll need the dev version in order to build something against it :)
00:21:10 <sohum> EnglishGent: well, it's building something against it, so...
00:21:17 <EnglishGent> ok - trying that :)
00:21:18 <zygoloid> osaunders: that means that type inferrence has decided that the type 'a' and 'a -> a' are the same
00:21:40 <osaunders> zygoloid: I'm not seeing the problem.
00:22:38 <sohum> jmcarthur_work: basically, with an "exact synonym" operator which basically does the equivalent of also copying the type, code using it is easier to read and a large percentage of cases where the MR is annoying are removed.
00:22:51 <zygoloid> osaunders: that's because (approximately): succ :: d -> d; (+) :: e -> e -> e; (.) :: (b -> c) -> (a -> b) -> a -> c. therefore b -> c == d -> d and a -> b == e -> (e -> e). so b = c = d, a = e, b = e -> e.
00:23:36 <EnglishGent> yay! installed without complaints! - thanks all :)
00:23:59 <sohum> EnglishGent: :D
00:24:07 <fasta> Look at http://hackage.haskell.org/packages/archive/hex/0.1.1/doc/html/src/Data-Hex.html and tell me what is wrong.
00:24:14 <jmcarthur_work> sohum, i am coming around
00:24:18 <iesahin> hi
00:24:27 <zygoloid> osaunders: therefore b = c = d = e -> e, a = e, so the result has type a -> c = e -> (e -> e). but you said the type was f -> f. so f = e, and f = e -> e, so f = f -> f
00:24:29 <jmcarthur_work> i'd rather just remove the MR though, i think
00:24:46 <sohum> jmcarthur_work: maybe, but there's technical reasons for keeping it I hear
00:25:06 <nagnatron> How do you turn a number into a list of its digits?
00:25:18 <iesahin> do you know any examples for using something like Map k (TVar a)?
00:25:20 <sohum> jmcarthur_work: if we can make it less annoying and make code more readable to boot, I'm all for that
00:25:29 <iesahin> using STM with Data.Map?
00:25:48 <iesahin> is it possible/feasible?
00:25:48 <sohum> jmcarthur_work: the only real issue, I think, is what would you call it >_>. == is bad because it conflicts with (==).
00:25:51 <jmcarthur_work> sohum, the only reason is so polymorphic values don't get reevaluated where it is unified with different types. if you make it explicitly polymorphic you get the same issue anyway. the MR just makes it illegal to do that implicitly
00:25:55 <zygoloid> osaunders: succ . (+) == \a -> succ ((+) a) == \a -> succ (\b -> a + b). that's almost certainly not what you want; you can't usually apply succ to a function
00:26:04 <Baughn> iesahin: I've done that. I can't show you the code (copyright issues), but it's perfectly workable.
00:26:07 <jmcarthur_work> *polymorphic with constraints
00:26:27 <Baughn> iesahin: However, consider if you can use a TVAr (Map a b) instead
00:26:45 <iesahin> I want to access different elements of Map concurrently
00:26:54 <sohum> jmcarthur_work: right, but there are two possible cases /now/ where you'd say foo = bar. one where you want the full generality of bar, and one where you don't need it
00:26:59 <jmcarthur_work> sohum, that is not as big of a problem as we once thought, which is why we mostly see the MR as an unreasonable restriction now
00:27:16 <jmcarthur_work> sohum, when you don't need it you have to specify the type anyway
00:27:24 <Baughn> iesahin: STM provides for concurrent read access, it's writes that get serialized.. well, you'd know. Just note that updating a Map takes less time than updating a TVar, even for a very large map.
00:27:24 <iesahin> doing TVar (Map k a) doesn't allow this AFAIU
00:27:50 <sohum> jmcarthur_work: no? import Prelude hiding (++); (++) = mappend; k = "foo" ++ "bar"
00:28:11 <quicksilver> Baughn: that's not really true.
00:28:18 <osaunders> zygoloid: Where did I say the type was f -> f?
00:28:18 <iesahin> then it's rather preferable
00:28:27 <sohum> jmcarthur_work: that gives (++) :: [a] -> [a] -> [a]
00:28:28 <jmcarthur_work> sohum, if GHC inferred (++) ∷ [a] → [a] → [a] for the top level definition then its using black magic
00:28:42 <osaunders> zygoloid: Oh wait.
00:28:43 <Baughn> quicksilver: I've got benchmarks showing it to be. Those were for concurrent access on a multi-processor system, though.
00:28:44 <quicksilver> Baughn: if you have two processes which read from the TVar, they must presumably write to anotehr TVar later, otherwise they are not doing anything observable.
00:28:49 <Baughn> OH..
00:28:51 <Baughn> *Oh..
00:28:53 <zygoloid> osaunders: you wrote 'addTwo :: Enum a => a -> a'. i renamed a to f because i'd already used 'a' :)
00:28:56 <sohum> jmcarthur_work: that's precisely the monomorphism restriction, isn't it?
00:28:58 <jmcarthur_work> sohum, what if (++) was defined in a different module from where it was used?
00:29:00 <quicksilver> Baughn: when they write to the other TVar and commit the consistency check is done
00:29:03 <osaunders> zygoloid: Yeah.
00:29:08 <jmcarthur_work> sohum, no
00:29:14 <quicksilver> Baughn: if it is indeed the case that nothing has written to the Map, then it will be fine
00:29:19 <jmcarthur_work> sohum, the MR would just disallow (++) = mappend without a type signature
00:29:21 <Baughn> quicksilver: Well, they could just be returning the value. That's how I use them.. for mixing with IO
00:29:34 <sohum> jmcarthur_work: well, actually sorry, (++) :: [Char] -> [Char] -> [Char]
00:29:36 <quicksilver> Baughn: (so, yes, multiple concurrent readers will coexist if they are all there is)
00:29:44 <quicksilver> Baughn: but if *anything* writes, all the readers re-start
00:29:45 <jmcarthur_work> sohum, that's not how it works
00:29:47 <Baughn> quicksilver: It's hell to write code that has to work with slightly obsolete data, but at least it'll always be /consistent/
00:29:49 <quicksilver> (retry, rather)
00:29:55 <osaunders> zygoloid: I don't understand why that created an "infinite type" though. Or what that even is.
00:29:58 <sohum> jmcarthur_work: check it.
00:30:04 <quicksilver> (sorry, yes, good point, returning is enough to be observable)
00:30:05 <sohum> jmcarthur_work: that's the type it gives.
00:30:24 <zygoloid> jmcarthur_work: it's not black magic, it's just collapsing it to a single type (due to MR) and picking that type based on deductions from the binding group (specifically "foo" ++ "bar")
00:30:57 <iesahin> quicksilver: Baughn: there will be many writes to the map in my case
00:31:13 <zygoloid> osaunders: "infinite type" means basically it's deduced the type 'x' is equivalent to 'f(x)' for some f(x) which is not the same as x.
00:31:16 <Baughn> iesahin: Then, be happy - Map a TVar works just fine.
00:31:47 <jmcarthur_work> !!!
00:32:03 <fasta> @hoogle String -> ByteString
00:32:04 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
00:32:04 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
00:32:04 <lambdabot> Prelude read :: Read a => String -> a
00:32:06 <iesahin> Baughn: thank you
00:32:11 <osaunders> zygoloid: Why isn't that a cannot match error then?
00:32:22 <sohum> jmcarthur_work: and I believe the MR only applies within files. when you import a module, all symbols you import already have a type
00:32:30 <Baughn> iesahin: (Is there a reason you thought it might not?)
00:32:47 <jmcarthur_work> you mean to tell me that if i define (++) in a library module, use it in a function that unifies it with [Char] → [Char] → [Char], but only export (++) it still only has type [Char] → [Char] → [Char]?
00:32:50 <jmcarthur_work> that's disgusting
00:32:51 <iesahin> I'm rather newbie to this stuff :)
00:32:59 <fasta> Is there a way to reload the libraries without restarting ghci?
00:33:10 <zygoloid> osaunders: because it could match, if infinite types were allowed
00:33:12 <Baughn> iesahin: STM cares not from where the blood flows, so long as it flows.
00:33:32 <osaunders> What's an infinite type?
00:33:33 <Baughn> Er. I mean, from where you get the TVar, so long as it's a TVar.
00:33:38 <Baughn> osaunders: a = f a
00:33:43 <iesahin> I checked TArray and Map, and Map seems simpler
00:33:55 <fasta> osaunders, a list is an infinite type.
00:33:58 <Baughn> They have very different performance characteristics
00:34:03 <jmcarthur_work> sohum, ugh. just disable the MR. if this is how it works i now see why people are militant about it instead of just shrugging it off as inconvenient. i would not have expected this behavior
00:34:09 <fasta> osaunders, that, however, is not what you want to know.
00:34:19 <Baughn> iesahin: But yes, in general you can use Map for everything and just switch to another type as an optimization. Map is O(lg n) in every operation.
00:34:26 <fasta> osaunders, you probably got an error related to an infinite type.
00:34:29 <iesahin> Can I use (Int, Int) as a key in MArray implementations?
00:34:33 <quicksilver> jmcarthur_work: yes, one of the consequences of the MR that most people don't encounter
00:34:43 <iesahin> Baughn: I need something like that
00:34:55 <quicksilver> iesahin: yes, you can, but don't use MArray :)
00:34:57 <fasta> osaunders, most likely you simply made a mistake.
00:35:02 <sohum> jmcarthur_work: why is that an issue? if you're exporting a symbol you're going to be careful about its signatures anyway.
00:35:17 <iesahin> I can use TArray or IOArray :)
00:35:18 <osaunders> fasta: Yeah. zygoloid has been explaining.
00:35:25 <jmcarthur_work> sohum, not if you intend for it to be a "function synonym" as you call it
00:35:37 <osaunders> fasta: But I still don't really understand what the error means. I feel like I'm missing something.
00:35:49 <iesahin> I still spell slowly when it comes mixing different monads
00:35:50 <osaunders> I know I got the type declaration wrong
00:35:55 <sohum> jmcarthur_work: which is exactly my point! the two usages of = are being conflated in the presence of the MR.
00:36:04 <jmcarthur_work> sohum, your proposal is a special =, mine is to disable the MR
00:36:14 <sohum> jmcarthur_work: so the two solutions are to either remove the MR, or to separate the uses
00:36:29 <jmcarthur_work> sohum, our misunderstanding way myself not knowing the full consequences of the MR
00:36:29 <iesahin> so map is easier for now
00:36:31 <zygoloid> osaunders: in principle, the type synonym 'type A = A -> A' could be accepted, and your function could have type A -> A (if Num A and Enum A instances were available)
00:36:31 * Baughn wonders if an STMT would be at all possible
00:36:33 <sohum> jmcarthur_work: given that we want to keep the MR, my proposal is the only proposal :)
00:36:36 <jmcarthur_work> s/way/was/
00:36:54 <jmcarthur_work> sohum, that's a given i wish not to accept ;)
00:36:55 <osaunders> An infinite type can never be satisfied? But a list can be because there's an empty list component. Is that right?
00:37:00 <zygoloid> osaunders: however, deduced types of that form almost invariably mean that your code has a bug.
00:37:13 <jmcarthur_work> osaunders, a value is not a type :)
00:37:18 <fasta> osaunders, sometimes you want that x = Bar x, where x is a type variable and Bar is a type constructor.
00:37:30 <zygoloid> osaunders: no, a list is OK because it's not a type synonym. the type [a] is not the same as the "type" a [a]
00:37:36 <jmcarthur_work> osaunders, you can have infinite values, not infinite types
00:37:41 <sohum> jmcarthur_work: which is fair enough, I suppose. but that's upto the community to decide
00:37:51 <fasta> osaunders, by default that is disallowed in Haskell. You can solve that equation and then use the newtype corresponding to it.
00:38:09 <jmcarthur_work> sohum, i think the NoMonomorphismRestriction extension is reasonable enough for now
00:38:36 <fasta> osaunders, some languages have Equi-recursive types, so that you don't have to worry about it.
00:38:45 <osaunders> I basically understood none of any of that.
00:39:12 <sohum> jmcarthur_work: yea, but function synonyms are orthogonal to the MR anyway. they're more useful in the presence of the MR, but I'd argue for them just for readability otherwise anyway
00:39:29 <sohum> jmcarthur_work: I'ma gonna propose this for Haskell' :)
00:39:54 <zygoloid> osaunders: basically, the type checker is saying "it looks like you made a mistake here; this type is so weird that i don't believe it's what you wanted"
00:39:55 <jmcarthur_work> sohum, how about as a language extension first? :)
00:40:07 <jmcarthur_work> more likely to be implemented
00:40:09 <osaunders> fasta: When you say x = Bar x are you declaring a type there?
00:40:18 <fasta> osaunders, no. Not declaring.
00:40:30 <fasta> osaunders, it is a constraint derived by the type-checker.
00:40:33 <sohum> jmcarthur_work: that's a "first"? I thought language extensions were picked from Haskell' suggestions
00:40:46 <Saizan> osaunders: there are two flavours of recursive types, isorecursive and equirecursive, haskell allows only the former, where a type defined recursively is only isomorphic (not equal) to its expansion
00:40:54 <fasta> osaunders, it has deduced that "if your code wants to do something useful, then those types have to be the same".
00:41:07 <osaunders> fasta: So that can never be satisifed. Is x = Bar x you never get x you get infinite Bars?
00:41:08 <jmcarthur_work> sohum, afaik, most Haskell' suggestions have been to make a subset of existing language extensions the default
00:41:22 <fasta> osaunders, it is not true that this can never be satisfied.
00:41:41 <jmcarthur_work> sohum, i think it's not a rule, but it's more handy to evaluate a proposal's consequences if it's already in GHC
00:41:47 <Saizan> that constraint could be satisfied by a type like (Bar (Bar (Bar ...)))
00:41:55 <Saizan> that's why it's called infinite
00:42:00 <fasta> osaunders, it can be satisfied if you have an infinite chain, like Saizan says.
00:42:08 <sohum> jmcarthur_work: there's a lot which aren't like that. especially in cases where, say, the exact name is undecided and such... besides, the proposal wiki is a handy place to point to :P
00:42:14 <jmcarthur_work> sohum, but i am not a part of the haskell' effort. this is speculation based on my observations
00:42:15 <fasta> osaunders, those uses are quite advanced.
00:42:28 <fasta> osaunders, if you have a few years of Haskell experience, ask again :)
00:42:36 <jmcarthur_work> sohum, there is certainly nothing wrong with proposing it
00:42:40 <zygoloid> in the case of a ~ a -> a, it's harder to write down the tye which satisfies it, but there still is one.
00:42:56 <jmcarthur_work> sohum, i just think it's more likely to be taken seriously if it can be played with already
00:43:11 <sohum> jmcarthur_work: mm, fair enough.
00:43:13 <jmcarthur_work> sohum, and having it added as a GHC extension is probably easier, politically
00:43:18 <osaunders> Saizan: What do you mean by "not equal to its expansion" when you defined isorecursive types?
00:43:34 <zygoloid> ((... -> ...) -> (... -> ...)) -> ((... -> ...) -> (... -> ...)) is a start...
00:43:48 <sohum> jmcarthur_work: what would you call it? :=, :=:, or ===?
00:44:29 <osaunders> For that matter, what's an expansion?
00:44:33 <jmcarthur_work> sohum, i have no idea. i know i don't like := because it looks like mutation from an imperative language
00:44:36 <Saizan> osaunders: say we define newtype U = U {unU :: (U -> U)}, U is not equal to U -> U as far as the typechecker sees
00:44:58 <Saizan> osaunders: but you have two functions that convert one to the other and vice-versa
00:45:02 <sohum> jmcarthur_work: yea, but I like the idea of having the colons because we define types with colons
00:45:07 <Saizan> osaunders: so they are isomorphic
00:45:11 <sohum> jmcarthur_work: so :=: ?
00:45:14 <jmcarthur_work> sohum, synonym foo = bar?
00:45:20 <jmcarthur_work> sohum, mirrors type synonyms better
00:45:28 <zygoloid> osaunders: when we write 'type a = b', types a and b are the same. when we write 'data a = Foo b', a and b are isomorphic (with "Foo" and "\Foo x -> x" mapping between the types)
00:45:29 <jmcarthur_work> maybe a different key word
00:45:31 <zygoloid> (technically that's not quite true due to bottoms, but it's a good approximations)n)
00:45:54 <sohum> jmcarthur_work: true, but requires an additional reserved word, which'll break some programs
00:46:21 <jmcarthur_work> sohum, a new = would do the same
00:46:28 <jmcarthur_work> sohum, consider a := b = …
00:46:40 <jmcarthur_work> that's a pattern match right now
00:46:44 <sohum> jmcarthur_work: aah, right
00:47:07 <ziman> > iterate (take 3) "hello world"
00:47:09 <lambdabot>   ["hello world","hel","hel","hel","hel","hel","hel","hel","hel","hel","hel",...
00:47:57 <zygoloid> , let (++) :: $([t| mappend |]); (++) = mappend in Just "foo" ++ Just "bar"
00:47:58 <lunabot>  luna: parse error on input `$('
00:48:04 * qwr . o O ( take 4 )
00:49:34 <sohum> :t let (+++) = mappend; k = Just "foo" +++ Just "bar" in (+++)
00:49:35 <lambdabot> forall a. (Monoid a) => a -> a -> a
00:49:58 <sohum> :t let (+++) = mappend in let k = Just "foo" +++ Just "bar" in (+++)
00:50:00 <lambdabot> forall a. (Monoid a) => a -> a -> a
00:50:15 <sohum> :t let (+++) = mappend in let k = "foo" +++ "bar" in (+++)
00:50:17 <lambdabot> forall a. (Monoid a) => a -> a -> a
00:50:30 <sohum> interesting, lambdabot
00:50:57 <Veinor> mappend? a pending version of mapp?
00:51:10 <Saizan> lambdabot has NoMR on, iirc
00:51:16 <sohum> ah
00:51:29 <sohum> Veinor: monoid-append
00:51:33 <zygoloid> fwiw, so does ghci's :t iirc
00:51:36 <Veinor> yes I know, I was just making a joke
00:51:38 <jmcarthur_work> i horrible name
00:51:41 <jmcarthur_work> *a
00:52:09 <sohum> :t append
00:52:11 <lambdabot> Not in scope: `append'
00:52:18 <sohum> why didn't they just call it append?
00:52:24 <jmcarthur_work> @hoogle append
00:52:25 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
00:52:25 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
00:52:25 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
00:52:44 <jmcarthur_work> i dunno
00:53:06 <Veinor> > mappend "foo" "bar"
00:53:08 <lambdabot>   "foobar"
00:53:20 <Veinor> > mappend (Just 2) (Just 3)
00:53:22 <lambdabot>   Ambiguous type variable `t' in the constraints:
00:53:22 <lambdabot>    `GHC.Num.Num t' arising ...
00:53:27 <Veinor> ...
00:53:37 <Veinor> I forget why exactly lambdabot does that but it's annoying as crap.
00:53:40 <sohum> :t mappend (Just 2) (Just 3)
00:53:42 <lambdabot> forall t. (Num t, Monoid t) => Maybe t
00:53:46 <Veinor> > mappend (Just 2.0) (Just 3.0)
00:53:47 <lambdabot>   Ambiguous type variable `t' in the constraints:
00:53:48 <lambdabot>    `GHC.Real.Fractional t'
00:53:48 <lambdabot> ...
00:53:56 <sohum> numbers aren't monoids
00:54:00 <Veinor> ah yeah
00:54:03 <sohum> usually, I suppose
00:54:05 <jmcarthur_work> they should be
00:54:16 <Veinor> numbers are a monoid with addition :D
00:54:16 <jmcarthur_work> but there are often more then one possible monoid
00:54:24 <sohum> exactly
00:54:38 <jmcarthur_work> sohum, not stopping me for alt-stdlib ;)
00:54:45 <sohum> heh
00:54:57 <sohum> actually, lemme just mention this
00:55:29 <sohum> the fact that it's called the "Prelude" is one of the things that kept me learning haskell
00:55:33 <jmcarthur_work> sohum, constraint Ring a = (Abelian (Additive a), Monoid (Multiplicative a), Distributive a)
00:55:38 <jmcarthur_work> :)
00:56:19 <ray> what would you call it, the nocturne?
00:56:33 <sohum> jmcarthur_work: is that... valid code? constraint...?
00:56:41 <jmcarthur_work> sohum, just need to add constraint synonyms to GHC for that :)
00:56:54 <jmcarthur_work> sohum, also planning to add constraint families
00:57:15 <jmcarthur_work> sohum, which would allow Set to be a Monad, among other things
00:57:59 <sohum> ray: no, as in, it was awesome. the fact that it was called the Prelude kept me learning haskell even when other things would have made me drop it
00:58:39 <ray> good thing it's not the Tocatta then
00:58:52 <sohum> "kept me" vs. "kept me from"
00:59:28 <sohum> jmcarthur_work: your work confuses me. I should sleep!
00:59:35 <jmcarthur_work> haha
00:59:59 <ray> hooray for set the monad
01:01:27 <ray> all of us with alternative preludes should have a summit sometime
01:01:47 <ray> Coollude 2010
01:02:01 <jmcarthur_work> ray, the alt-stdlib effort is intended to be a whole new library, and i want it to be a collaborative effort, not just me
01:02:50 <Veinor> sohum: why did that keep you learning it?
01:02:50 <jmcarthur_work> ray, #alt-stdlib if you want to follow or influence things :) and http://trac.haskell.org/alt-stdlib
01:03:38 <xle> Hey all... Just wondering.. Why is it that everybody keeps applauding Erlang for excellent error-tolerance and recovery? I am trying to understand what Erlang has in that space that Haskell lacks and/or makes more difficult to work with...
01:03:51 <ray> will look at it sometime
01:03:52 <edwardk> ray: heh, i'll bring my old 'Abstract' modules ;)
01:03:59 <jmcarthur_work> xle, erlang's philosophy is to fail fast and let other processes bring it back up
01:04:23 <jmcarthur_work> xle, haskell doesn't generally encourage that
01:04:28 <Berengal> Haskell's philosophy is to not fail?
01:04:33 <ray> yes
01:04:35 <jmcarthur_work> Berengal, heh heh, yes
01:04:43 <ray> failure?! impossible
01:04:47 <fasta> Considering cosmic rays and all, the Erlang way of doing stuff is better.
01:04:50 <edwardk> xle: honestly the main thing the erlang has is that it has a simple execution model that is easy to understand, and a lot of machinery for handling error propagation and mutual thread death when it goes wrong
01:04:53 <ray> Abstract modules! intriguing
01:05:01 <jmcarthur_work> erlang makes the digression that sometimes you overlook things, but you still want a running system
01:05:07 <Veinor> fasta: how often do you get failures from cosmic rays?
01:05:28 <xle> So in Haskell, we plan for possible failures and catch those in pattern matching, or in monadic chains, etc. Whereas Erlang fails all the time, and makes it convenient to come back up
01:05:29 * roconnor got hit by a cosmic ray once.
01:05:32 <fasta> Veinor, probably more than then amount of 9s they need.
01:05:34 <edwardk> ray: well, what usually comes before the Prelude? The Abstract!
01:06:06 <zygoloid> the PrePrelude? or the Pre2lude?
01:06:09 <ray> i was thinking prelude and fugue, and to have a second-tier library called the Fugue
01:06:14 <Veinor> Anteprelude.
01:06:34 <roconnor> Veinor: http://r6.ca/blog/20041110T014300Z.html
01:07:03 <Veinor> oh wow.
01:07:20 <roconnor> Veinor: I was floored, and thought I was going crazy
01:07:37 <edwardk> xle: you pattern match in erlang as well, but they live in a world where functions can be rebound on the fly, and they have nice mechanism for mutual notification on thread death and for bringing up new services that result from the combination of these features and the libraries they offer
01:07:43 <roconnor> Veinor: then the next day's APOD was about the brilliant aurora that happend that night.
01:08:03 <ray> nice picture
01:08:08 <Veinor> heheh.
01:08:16 <roconnor> Veinor: I should say that these were 3 large files, the size of partitions
01:08:21 <xle> edwardk, I see.. So people change definitions of methods on the fly in Erlang?
01:08:28 <Veinor> the size of partitions? that's a pretty wide range :P
01:08:32 <akappa> a professor in my cs dep. says that erlang isn't relevant in industry at all, it is just used as a tool for formalize systems and study them
01:08:35 <akappa> it is true?
01:08:40 <ray> ask ericsson
01:08:50 <akappa> apart ericsson, I mean
01:08:51 <akappa> :P
01:08:56 <roconnor> Veinor: I'd esitmate on the order of 10 GB
01:09:16 <Veinor> ah, okay
01:09:31 <edwardk> akappa: no. erlang is used, not to the extend that c++, etc. are -- and i don't know anyone that formalizes systems in erlang. that would be a more appropriate dig at Haskell than Erlang ;)
01:09:39 <edwardk> er not to the extent
01:09:44 <roconnor> Veinor: er no wait
01:09:48 <roconnor> must have been smaller
01:09:55 <Veinor> hm
01:09:56 <roconnor> Veinor: the size of a CD each.
01:10:11 <roconnor> since I was checking if my CD copies were correct.
01:10:29 <akappa> edwardk, so it isn't useless to learn erlang for a future work prospective, then
01:10:46 <roconnor> Veinor: I even tossed out my CD because I thought the copy was bad.
01:10:57 <edwardk> akappa: the honestl answer is erlang does make it easy to build big applications and just throw hardware at a problem. if your application can feasibly scale out rather than up, then it is a great tool.
01:11:00 <roconnor> Veinor: then the next CD I made was exactly the same.
01:11:14 <Veinor> I woudl've gone crazy too.
01:11:20 <roconnor> Veinor: then I reran the md5sum on the original and go the same as both my CDs
01:11:28 <roconnor> (and different from the original md5sum run).
01:11:38 <akappa> edwardk, thanks :)
01:11:40 <edwardk> akappa: if you're running a straight-line computation slamming into Amdahl's law, then it's the wrong language.
01:11:59 <xle> Would anyone here recommend a library/app/package to examine in Haskell to understand how a full workflow is typically implemented in Haskell? I am quite familiar with a number of common Haskell concepts by now, but am trying to get some actionable experience on how to structure large problems, including possible errors, failure, etc.
01:12:00 <roconnor> Veinor: I even had the two different sums both visible in the same terminal.
01:12:19 <roconnor> and I swear I didn't touch the files in between
01:12:42 <akappa> edwardk, it is bad for sequential programming?
01:12:42 <scalaLove> why do both Data and Type exist? Data creates a new type and Type is used for synonim types, could not they have just one word for both actions? :(
01:12:47 <roconnor> not like I go around modifying data to be backed up to CD a lot.
01:12:52 <akappa> edwardk, or it is just overkill?
01:13:43 <c_wraith> scalaLove:  you'd need different syntax to distinguish between the two anyway, since data requires a constructor, while type does not.  So you might as well just make them different keywords
01:13:54 <edwardk> akappa: no mutation in a strict language (modulo special cases with some storage stuff, etc) means that you have the typical functional programming problem of potentially an extra logarithmic factor in your algorithms
01:14:27 <Saizan> scalaLove: how would you differentiate data Foo = Bool and type Foo = Bool if that was the case?
01:14:34 <akappa> edwardk, thanks :)
01:14:48 <zygoloid> Saizan: use the same namespace for types and data constructors?
01:15:11 <Saizan> zygoloid: so that the first is invalid?
01:15:27 <scalaLove> Saizan: that is my point, why have Type at all? why not just Foo = Bool
01:16:18 <Saizan> scalaLove: that looks like a value level pattern match
01:16:23 <edwardk> scalaLove: data includes the tag, remember it provides a series of alternatives not just a binding for a tuple
01:16:26 <zygoloid> scalaLove: Saizan's point is that both 'data Foo = Bool' and 'type Foo = Bool' are legal and mean different things
01:17:01 <Saizan> scalaLove: e.g. "Just _ = Nothing" is another legal but different thing, that would clash with that syntax
01:18:05 <doserj> True = False is legal haskell...
01:18:18 <aavogt> > True = False
01:18:19 <lambdabot>   <no location info>: parse error on input `='
01:18:22 <dolio> There's nothing wrong with Foo = Bool except it requires you to have functions at the type level (with the usual syntax).
01:18:26 <aavogt> > let True = False in True
01:18:27 <lambdabot>   True
01:18:42 <aavogt> what?
01:18:46 <Veinor> > let True = False in True == False
01:18:47 <lambdabot>   False
01:18:49 <paper_cc> > let True = False in if True then "foo" else "bar"
01:18:50 <lambdabot>   "foo"
01:18:54 <Veinor> :V
01:18:58 <dolio> Or, similar definition forms.
01:19:00 <Veinor> > let 2 + 2 = 5 in 2 + 2
01:19:01 <lambdabot>   5
01:19:07 <aavogt> oh, it's a pattern match
01:19:16 <Veinor> 12:15:52 < []J> my programing teacher in college told me about how recursion brought him closer to god because it explained the holy trinity :downs:
01:19:16 <aavogt> > let x@True = False in x
01:19:17 <lambdabot>   * Exception: <interactive>:1:137-150: Irrefutable pattern failed for patter...
01:19:26 <doserj> a pattern match that doesn't bind any variables
01:19:37 <zygoloid> > let !True = False in 42
01:19:38 <lambdabot>   * Exception: <interactive>:1:145-157: Non-exhaustive patterns in pattern bi...
01:20:09 <paper_cc> well, True is a data constructor. Can it be rebound in a 'let'?
01:20:13 <aavogt> that's sort of expected, but useless which is why it's surpriting
01:20:19 <aavogt> surprising even
01:20:26 <quicksilver> paper_cc: you're not rebinding the constructor
01:20:30 <scalaLove> Veinor hahahahaha have heard that before too :D
01:20:33 <quicksilver> paper_cc: just (vacuously) matching on it as a pattern.
01:21:21 <paper_cc> quicksilver: and it doesn't fail as it is a lazy pattern match?
01:21:25 <zygoloid> paper_cc: right
01:21:50 <zygoloid> > do True <- return False; return "Hello" :: Maybe String
01:21:51 <lambdabot>   Nothing
01:22:16 <aavogt> > [ x | (True,x) <- map (odd &&& id) [1..10] ] -- slightly useful if we didn't have filter?
01:22:17 <lambdabot>   [1,3,5,7,9]
01:22:33 <paper_cc> > let Just "foo" = Nothing in "blah"
01:22:34 <lambdabot>   "blah"
01:27:51 <mm_freak> > let 1 + 1 = 3 in 1 + 2
01:27:52 <lambdabot>   * Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
01:28:02 <mm_freak> haskell sucks, because it can't even figure out that one
01:28:24 <mm_freak> (i'm just joking, of course)
01:29:01 <Vulpyne> I hear strong AI is coming in Haskell Prime. :)
01:29:05 <gwern> was the pragma DEPRECATED or DEPRECATION?
01:29:21 <Vulpyne> DEPRECATED.
01:29:35 <mm_freak> Vulpyne: yes, i've seen some people move from lisp/scheme to haskell
01:29:44 <KitB_> Can lambdabot tell you the definition of a function you have defined yourself?
01:29:59 <mm_freak> @let f x = x + 1
01:30:00 <lambdabot>  Defined.
01:30:00 <mm_freak> @src f
01:30:01 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:30:03 <mm_freak> no
01:30:09 <KitB_> @let p xs = concat [[y,x]|(i,(x,y)) <- (zip [1..] $ zip xs $ tail xs), odd i]
01:30:11 <lambdabot>  Defined.
01:30:17 <KitB_> And is there a nicer way of doing that? :P
01:30:35 <mm_freak> > p [1,2,3]
01:30:37 <lambdabot>   Ambiguous occurrence `p'
01:30:37 <lambdabot>  It could refer to either `L.p', defined at <local...
01:30:42 <ddarius> :t zip3
01:30:43 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
01:31:16 <mm_freak> > L.p [1,2,3]
01:31:18 <lambdabot>   [2,1]
01:31:23 <KitB> That improves things :D
01:31:24 <mm_freak> > L.p [1..10]
01:31:25 <lambdabot>   [2,1,4,3,6,5,8,7,10,9]
01:32:44 <KitB> @let p xs = concat [[y,x]|(i,x,y) <- (zip3 [1..]  xs (tail xs)), odd i]
01:32:46 <lambdabot>  <local>:21:0:
01:32:46 <lambdabot>      Warning: Pattern match(es) are overlapped
01:32:46 <lambdabot>               I...
01:32:53 <KitB> @undefine L.p
01:32:56 <KitB> @let p xs = concat [[y,x]|(i,x,y) <- (zip3 [1..]  xs (tail xs)), odd i]
01:32:57 <lambdabot>  Defined.
01:33:06 <KitB> > L.p [1..4]
01:33:07 <lambdabot>   [2,1,4,3]
01:33:11 <KitB> Awesome.
01:33:31 * KitB got out of his funky programming exam not long ago
01:34:50 <aavogt> > let p xs = concat [[y,x]|(True,x,y) <- zip3 (cycle [True,False]) xs $ tail xs ] in p [1..4]
01:34:52 <lambdabot>   [2,1,4,3]
01:35:48 <kmc> > let p xs = concat [[y,x] | (x,y) <- zip xs $ tail xs | cycle [True, False]] in p [1..4]
01:35:50 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
01:35:50 <lambdabot>         against inferred type ...
01:38:19 * ddarius would probably use the direct recursive solution.
01:38:51 <kmc> > let p = concat . map (reverse . take 2) . takeWhile (not.null) . iterate (drop 2) in p [1..4]
01:38:52 <lambdabot>   [2,1,4,3]
01:39:41 <KitB> There were two questions for that task
01:39:46 <KitB> One was to do it recursively
01:39:55 <KitB> The other was with comprehension
01:40:49 <KitB> Silly question IMO
01:40:54 <KitB> Recursion was far easier
01:41:05 <KitB> Especially as we were allowed to assume even length inputs
01:42:00 <ddarius> Well, if you were able to assume even length inputs, then a foldr would be nice.
01:42:27 <dons> The Haskell Web News, y'all, http://www.reddit.com/r/programming/comments/ac1o4/whats_new_in_haskell_december_2009_edition/
01:42:52 <ray> haskell monthly news
01:43:10 <KitB> ddarius: We weren't allowed higher order functions
01:43:22 <ddarius> 'the fuck ?!
01:43:38 <ddarius> dons: So do we have all time scales covered?
01:43:54 <ray> i don't think there's a haskell hourly news
01:44:05 <ddarius> ray: Planet Haskell
01:44:26 <dons> i think we may have it all covered now.
01:44:41 <ray> minutely?
01:44:44 <ray> secondly is #haskell
01:45:16 * gwern is tired from the GRE today. is there any very easy and interesting to read in the haskell web news?
01:45:20 <eu-prleu-peupeu> if i have something like this: [(a,b)] how do i change it to something like this: [ (a, [b]) ], i mean joining out the b's whenever a==a
01:45:20 <mxc> minutely is #haskell-in-depth
01:45:22 <eu-prleu-peupeu> ?
01:45:54 <jmcarthur_work> like a multimap?
01:46:02 <eu-prleu-peupeu> multimap ? :)
01:46:04 <eu-prleu-peupeu> let me check it out
01:46:40 <jmcarthur_work> :t Data.Map.fromList . (fmap.map) (:[])
01:46:42 <lambdabot>     Couldn't match expected type `(k, a)' against inferred type `[b]'
01:46:42 <lambdabot>     In the second argument of `(.)', namely `map'
01:46:42 <lambdabot>     In the second argument of `(.)', namely `(fmap . map) (: [])'
01:47:17 <jmcarthur_work> :t Data.Map.fromList . (map.second) (:[])
01:47:18 <lambdabot> forall k b. (Ord k) => [(k, b)] -> M.Map k [b]
01:47:28 <jmcarthur_work> :t toList . Data.Map.fromList . (map.second) (:[])
01:47:29 <lambdabot> Not in scope: `toList'
01:47:36 <jmcarthur_work> :t Data.Map.toList . Data.Map.fromList . (map.second) (:[])
01:47:37 <lambdabot> forall k b. (Ord k) => [(k, b)] -> [(k, [b])]
01:48:31 <eu-prleu-peupeu> thats a bit unreadable :P
01:48:33 <eu-prleu-peupeu> but ok
01:48:33 <eu-prleu-peupeu> thanks
01:48:45 <jmcarthur_work> it's wrong
01:48:55 <|Jedai|> > M.fromListWith (++) . map (second (:[])) $ [(1,2),(1,3),(2,5)]
01:48:57 <lambdabot>   fromList [(1,[3,2]),(2,[5])]
01:49:03 <jmcarthur_work> that's better
01:49:14 <jmcarthur_work> :t Data.Map.toList . Data.Map.fromListWith (++) . (map.second) (:[])
01:49:15 <lambdabot> forall k b. (Ord k) => [(k, b)] -> [(k, [b])]
01:49:36 <mxc> :t Data.Map.fromListWith
01:49:37 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
01:49:53 <jmcarthur_work> > Data.Map.toList . Data.Map.fromListWith (++) . (map.second) (:[]) $ zip [1, 1, 5, 3, 5, 5, 5] [0..]
01:49:55 <lambdabot>   Not in scope: `Data.Map.toList'Not in scope: `Data.Map.fromListWith'
01:50:13 <|Jedai|> > M.toList . M.fromListWith (++) . map (second (:[])) $ [(1,2),(1,3),(2,5)]
01:50:15 <lambdabot>   [(1,[3,2]),(2,[5])]
01:50:31 <jmcarthur_work> > M.toList . M.fromListWith (++) . (map.second) (:[]) $ zip [1, 1, 5, 3, 5, 5, 5] [0..]
01:50:32 <lambdabot>   [(1,[1,0]),(3,[3]),(5,[6,5,4,2])]
01:50:36 <jmcarthur_work> yay
01:51:38 <jmcarthur_work> > M.toList . (M.fromListWith . flip) (++) . (map.second) (:[]) $ zip [1, 1, 5, 3, 5, 5, 5] [0..]
01:51:40 <lambdabot>   [(1,[0,1]),(3,[3]),(5,[2,4,5,6])]
01:51:43 <jmcarthur_work> win
01:52:22 <scalaLove> I am reading on Haskell recursion simulating loops from the imperative style... I wonder, why not loops in Haskell? Instead of changing a var you can replace the next loop val based on the previous loop's value... I feel something is wrong, cant see it, will u tell me what please
01:52:45 <jmcarthur_work> scalaLove, you just described recursion
01:52:51 <Baughn> scalaLove: forM, mapM... look in Control.Monad
01:52:51 <|Jedai|> jmcarthur_work: Bad !! With this change, you've got a O(m²) algorithm (m being the maximum number of values associated to the same key)
01:53:17 <smiler> @src forM
01:53:18 <lambdabot> forM = flip mapM
01:53:18 <jmcarthur_work> |Jedai|, yeah, but i made an implicit assumption to ignore efficiency :P
01:53:22 <Baughn> scalaLove: Then there's map, iterate, folds, etc. etc. etc.
01:53:24 <smiler> @src mapM
01:53:25 <lambdabot> mapM f as = sequence (map f as)
01:53:34 <|Jedai|> scalaLove: There's no "loop" in Haskell because we just use higher-order function instead
01:53:37 <eu-prleu-peupeu> hmm
01:53:39 <eu-prleu-peupeu> nice stuff
01:53:40 <Baughn> scalaLove: It is generally reasonable to assume that if you have explicit recursion in hakell, you're doing something wrong
01:53:46 <eu-prleu-peupeu> ill just paste my code so you guys can check it out
01:54:04 * EvanR-work listens to Baughn 
01:54:28 <bd_> Baughn: Unless you're writing a combinator to traverse over a recursive data structure when SYB does too much allocation
01:54:30 <Baughn> scalaLove: However, you still need to know how they work, so as an exercise..
01:54:30 <jmcarthur_work> |Jedai|, actually, in what order does fromListWith apply the arguments?
01:54:45 <Baughn> bd_: Lies-to-newbies are allowed, right?
01:54:49 <bd_> Baughn: Oh, certainly.
01:55:03 <jmcarthur_work> |Jedai|, if by default it's existing ++ new, my version is the less expensive
01:55:09 <bd_> exceptions to every rule, etc
01:55:10 <|Jedai|> jmcarthur_work: look at our example, it's "f new old"
01:55:15 <lament> @faq Can Haskell let me write complicated programs without ever using explicit recursion??
01:55:16 <lambdabot> The answer is: Yes! Haskell can do that.
01:55:24 <jmcarthur_work> ah i wasn't paying much attention
01:55:27 <jmcarthur_work> nevermind
01:56:15 <aavogt> lament: actually using that plugin seriously ;)
01:56:33 <ddarius> bd_: Use Uniplate.
01:56:38 <scalaLove> I like |Jedai| explanation ... because we use higher-level functions instead.. tnx guys
01:56:51 <bd_> ddarius: hmm, haven't heard of that
01:56:52 <jmcarthur_work> :)
01:56:52 <|Jedai|> jmcarthur_work: it would be less expensive to do a "map (second reverse)" at the end ;D
01:56:58 <c_wraith> I had to use explicit recursion last night because I was using a recursion structure that I'm not aware of a combinator for.
01:57:01 <jmcarthur_work> |Jedai|, yes
01:57:18 <Baughn> c_wraith: Oh, I'm sure there is one. Maybe the zygohistopreprozomorphic operator?
01:57:45 <EvanR-work> how serious are you when you say avoid explicit recursion
01:57:54 <|Jedai|> jmcarthur_work: or maybe, just maybe we could just write an auxiliary function "makeMultimap"...
01:58:08 <|Jedai|> EvanR-work: very
01:58:17 <c_wraith> EvanR-work: many problems don't need explicit recursion.  If you don't need it, you should avoid it.
01:58:18 <lament> c_wraith: you were using an illegal, unauthorized recursion structure
01:58:31 <Baughn> EvanR-work: I haven't used explicit recursion in a very, very long time
01:58:33 <c_wraith> lament:  it didn't even solve the problem in a timely manner.
01:58:38 <|Jedai|> EvanR-work: seriously, if you use explicit recursion there's plenty of thing you can get wrong
01:58:56 <bd_> ddarius: in my case I found that transforming a tree produced too much garbage because, even if it didn't change a node or any of its children, it still reconstructed it because it _might_ have changed some of the children. I don't think uniplate would help there. :/
01:59:05 <bd_> it's been a few years since I did it though :)
01:59:10 <Baughn> EvanR-work: You also need to be aware of useful monads like Reader/Writer and the transformer variants
01:59:10 <jmcarthur_work> |Jedai|, or just use a proper MultiMap :)
01:59:29 <EvanR-work> my problem was that i was constructing a list that depends on previous parts of the list, but a list comprehension was not allowing me to pass the needed parts (the last 1024th x and the 1st last carry) so i wrote a explicitly recursive function to generate it...
01:59:30 <jmcarthur_work> EvanR-work, very serious
01:59:53 <c_wraith> Baughn:  what combinator would I use to avoid explicit recursion with this structure?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13737
02:00:09 <|Jedai|> EvanR-work: whereas if you use higher-order combinators, you benefits from a more tested by time construction, beside you often make more explicit to the reader what your function do
02:00:15 <jmcarthur_work> EvanR-work, list comprehensions are less powerful than straight up combinators
02:00:41 <EvanR-work> so there is some combinator which would do what i was doing. and it would somehow be more understandable?
02:01:18 <EvanR-work> the sequence is x[i] = f(x[i-r],c[i-1]), c[i] = g(x[i-r],c[i-1])
02:01:19 <|Jedai|> EvanR-work: very probably (it's not _always_ true but enough that you can use it as a rule)
02:01:51 <PeakerWork> @src Dynamic
02:01:52 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
02:02:03 <c_wraith> EvanR-work: what's r?
02:02:06 <EvanR-work> a constant
02:02:12 <jmcarthur_work> c?
02:02:20 <PeakerWork> > cast 5 :: Show a => a
02:02:22 <lambdabot>   Couldn't match expected type `a'
02:02:22 <lambdabot>         against inferred type `Data.Maybe....
02:02:28 <PeakerWork> > cast 5 :: Show a => Maybe a
02:02:30 <lambdabot>   Could not deduce (Data.Typeable.Typeable a)
02:02:30 <lambdabot>    from the context (GHC.Show.S...
02:02:39 <PeakerWork> > cast 5 :: (Show a, Typeable a) => Maybe a
02:02:40 <lambdabot>   Nothing
02:02:58 <EvanR-work> jmcarthur_work: c is just some number from the last iteration, the sequence we care about is x
02:03:02 <|Jedai|> EvanR-work: let x = beginning ++ zipWith f x (drop r c); c = beginning' ++ zipWith g x (drop r c)
02:03:07 <PeakerWork> How do lambdabot/lunabot eval stuff to call show on it, if this cast fails?
02:03:14 <|Jedai|> EvanR-work: or something quite like that
02:03:23 * EvanR-work studies this
02:03:25 <PeakerWork> Assuming the result of eval is actually an existential Typeable
02:04:29 <EvanR-work> |Jedai|: would this be as efficient as gen c state = x : gen next_c next_state ?
02:04:46 <Baughn> c_wraith: Brain melting. What is the purpose of that?
02:05:25 <c_wraith> Baughn: It's a branch & bound search for combinations of numbers whose product doesn't exceed a constant.
02:05:25 <|Jedai|> EvanR-work: probably
02:06:02 <EvanR-work> looks like lots of ++, isnt : more efficient
02:06:04 <Baughn> c_wraith: Well, I feel relatively certain that if there was a solution, you'd already be using it.
02:06:23 <c_wraith> Baughn: it doesn't help that I inlined DList-style higher order lists into it. >_>
02:06:49 <Baughn> c_wraith: I wondered about rewriting it to use Writer
02:06:56 <|Jedai|> EvanR-work: what "lots", there's only two. anyway how come you don't have (++) in your function if you start with r x ?
02:07:28 <EvanR-work> |Jedai|: well the whole list would be start ++ gen 0 start
02:07:50 <jmcarthur_work> EvanR-work, could you hpaste your code and we can try to combinatorize it?
02:08:26 <|Jedai|> EvanR-work: so there is one (++) instead of two... I don't think that's really determinant
02:08:27 <scalaLove> oh my good i love haskell, i will change my name soon to haskellLove --------- let fac n = product[1..n] how cool is this
02:08:33 <EvanR-work> |Jedai|: oh i get it
02:08:41 <eu-prleu-peupeu> what tech power the haskellwiki ?
02:08:50 <jmcarthur_work> scalaLove, surely you can do that with scala too?
02:08:59 <eu-prleu-peupeu> it is definetly alien tech, i am sure
02:09:01 <EvanR-work> jmcarthur_work: dont have it with me, i could paste it in 6 hours, or i could hurry right now and try to remember it ... ;)
02:09:09 <jmcarthur_work> ah, don't worry about it
02:09:43 <scalaLove> jmcarthur_work i dunno, but it is a library thing anyways, does not matter...
02:09:55 <scalaLove> oh well i can be HaskellScalaLove
02:12:39 <EvanR-work> jmcarthur_work: http://pastebin.com/m447bffe8
02:14:14 <saml> > let math = pi*pi in math/pi
02:14:16 <lambdabot>   3.141592653589793
02:14:52 * jmcarthur_work tries to make sense of EvanR-work's code
02:15:33 <EvanR-work> hope theres no typos..
02:17:21 <scalaLove> why is pattern matching avaliable only with constructors?
02:17:45 <scalaLove> the rule that you can only pattern match with constructors
02:17:53 <BONUS> what else could it be available with?
02:18:08 <BONUS> f (x + y) = ...
02:18:32 <doserj> constructors are the only functions the compiler knows to be injective
02:19:09 <BONUS> only if something is made with a constructor does the compiler know how to break it apart
02:19:26 <scalaLove> injective?
02:19:47 <doserj> one-to-one
02:19:48 <scalaLove> BONUS - wow nice explanation thanks man, will have that as note here
02:20:30 <knobo> |Jedai|: I found something interesting in "yet another haskell tutorial", in the state monad example. Almost the same function that you helped me with. simplified with a state monad :)
02:20:43 * KitB detaches
02:20:53 <jmcarthur_work> EvanR-work, that's a complicated case. i will tackle it later. i have to work for now
02:21:12 <EvanR-work> ok
02:21:17 <EvanR-work> me too :)
02:21:22 <scalaLove> so basically you can look at constructors as grammar productions stuff... constructors can be seen as non-leaf nodes, they can always be expanded
02:22:39 <c_wraith> constructors can be leaf nodes.  data Bool = False | True
02:25:03 <scalaLove> well if they can be leaf nodes, why does ++ differ from ":", which it says the ++ is not a constructor. That is leaf node, and constructors can be leaf nodes as u said, so why not pattern match ++ ?
02:25:31 <scalaLove> it says, i meant about the book it says...
02:26:52 <c_wraith> (++) isn't a constructor.  it's just a function
02:27:07 <knobo> |Jedai|: ops.. the doc is called "Yet another Haskell introduction"
02:27:12 <scalaLove> that is what i say it is not
02:27:12 <c_wraith> the [a] type has two constructors - (:) and []
02:27:18 <jmcarthur_work> scalaLove, when you apply (++), what you get is not a value constructed from (++) but is something else made with (:) and []
02:27:21 <CalJohn> @type (:)
02:27:22 <lambdabot> forall a. a -> [a] -> [a]
02:27:26 <CalJohn> @type (++)
02:27:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
02:27:59 <c_wraith> Lists are a bit funny, because they get special syntax no other type does.  [] wouldn't be a valid constructor for any other type.
02:30:20 <lament> every time i see a list, i'm convulsing with laughter.
02:30:21 <scalaLove> jmcarthur_work: can i understand this like umm this: when pattern matching is done to something it is curried and expanded and curried and blah... so if (++) is syntactic sugar over ":" so, pattern matching can be done only with lists and ":" but not ++ ? am i even close to the answer?
02:30:44 <c_wraith> scalaLove:  That seems horribly convoluted.
02:30:50 <lament> (++) is no sugar, it's just a function
02:30:56 <aavogt> () gets special treatement too
02:30:56 <jmcarthur_work> scalaLove, (++) is not syntactic sugar
02:30:56 <lament> @src (++)
02:30:57 <lambdabot> []     ++ ys = ys
02:30:57 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
02:30:57 <lambdabot> -- OR
02:30:57 <lambdabot> xs ++ ys = foldr (:) ys xs
02:31:21 <lament> whoa, what does OR mean?
02:31:26 <Berengal> Or
02:31:43 <jmcarthur_work> lament, it means one of those is the actual implementation and one of them is what it probably should be instead :P
02:31:50 <c_wraith> scalaLove:  Just think of it as if there was a data declaration:  data [] a = a : ([] a) | []
02:31:53 <lament> is this another Caleskell thing?
02:31:56 <benmachine> lament: it's a comment
02:31:59 <benmachine> note --
02:32:08 <c_wraith> lament: it just means there are alternate implementations
02:32:31 <lament> one in the prelude, one in?..
02:32:49 <aavogt> @type (Prelude.++)
02:32:50 <lambdabot> forall a. [a] -> [a] -> [a]
02:33:01 <benmachine> scalaLove: if you matched "hello" against the pattern (a ++ b), what would a and b be?
02:33:01 <c_wraith> lament: they're equivalent.  It's just two ways of writing the function.  @src doesn't pull from actual source, necessarily
02:33:04 <scalaLove> crazy explanations in the air, guys when you talk to a noob talk noobish otherwise he will bang his head in the wall as each message comes :D
02:33:24 <Berengal> scalaLove: Values have several forms they can be in, but only one normal form. For example, 1 + 2 is a value, so is 2 + 1 and 3, but only 3 is in normal form. You can only pattern-match on values in normal form
02:33:25 <jmcarthur_work> scalaLove, the noobish answer is you can't pattern match on functions
02:33:35 <aavogt> scalaLove: all you have to do is ask for more explanation ;)
02:33:40 <jmcarthur_work> scalaLove, if you want deeper explanation you will not get a noobish answer ;)
02:33:42 <scalaLove> benmachine: well, "hel" ++ "oo"
02:33:55 <benmachine> scalaLove: why not "he" ++ "llo"?
02:33:58 <jmcarthur_work> scalaLove, or "h" ++ "ello"
02:34:08 <benmachine> there isn't just one answer
02:34:12 <c_wraith> heck.  how about "" ++ "hello"
02:34:17 <benmachine> so it doesn't really make sense
02:34:45 <jmcarthur_work> > map (uncurry splitAt) $ zip [0..] "hello"
02:34:46 <lambdabot>   Couldn't match expected type `[a]'
02:34:46 <lambdabot>         against inferred type `GHC.Types...
02:34:56 <jmcarthur_work> :t splitAt
02:34:57 <lambdabot> forall a. Int -> [a] -> ([a], [a])
02:35:05 <c_wraith> you need a repeat in there
02:35:09 <jmcarthur_work> oh duh
02:35:12 <jmcarthur_work> > map (uncurry splitAt) $ zip [0..] $ repeat "hello"
02:35:14 <lambdabot>   [("","hello"),("h","ello"),("he","llo"),("hel","lo"),("hell","o"),("hello",...
02:35:21 <aavogt> > let f (splitPrefix "hel" -> x) | Just "oo" <- x = True; f _ = False in (f "heloo",f "something else")
02:35:22 <lambdabot>   Illegal view pattern:  (splitPrefix "hel" -> x)
02:35:22 <lambdabot>  Use -XViewPatterns to enab...
02:35:28 <aavogt> , let f (splitPrefix "hel" -> x) | Just "oo" <- x = True; f _ = False in (f "heloo",f "something else")
02:35:29 <lunabot>  luna: Not in scope: `splitPrefix'
02:35:36 <scalaLove> Berengal: normal form, yes similar to what I said before, you expand and curry and what not untill you get all to atomic parts and then u can match, it is like normalizing functions so you can compare them i guess...
02:36:00 <aavogt> Cale: need moar extensions in lambdabot!
02:36:28 <Berengal> scalaLove: Yes, but you can't write patterns that aren't already in normal form.
02:37:17 <scalaLove> aha there, the answer is close i feel it
02:37:18 <Berengal> scalaLove: Because you can't normalize something like 'a ++ [1,2,3]' because you don't know what 'a' is yet.
02:37:24 <jmcarthur_work> scalaLove, you can't really normalize (a ++ b) any more, and we already showed that matching that against a string would be ambiguous
02:37:29 <scalaLove> I will keep this as note :you can't write patterns that aren't already in normal form.
02:37:46 <aavogt> if you knew what a was, then it would be a perfectly fine pattern match
02:37:50 <jmcarthur_work> for that reason, we disallow nonnormalized patterns
02:38:04 <jmcarthur_work> aavogt, in reality, or just in theory?
02:38:05 <aavogt> which is why we have splitPrefix and view patterns ;)
02:38:15 <jmcarthur_work> yes, that :)
02:38:18 <aavogt> jmcarthur_work: in reality
02:38:33 <jmcarthur_work> > let "foo" ++ b = "foobar" in b
02:38:34 <lambdabot>   b
02:38:42 <jmcarthur_work> heh
02:38:51 <Berengal> aavogt: stripPrefix, not split
02:39:03 <Berengal> > stripPrefix "he" "hello"
02:39:04 <lambdabot>   Just "llo"
02:39:25 <aavogt> , let f (stripPrefix "hel" -> x) | Just "oo" <- x = True; f _ = False in (f "heloo",f "something else")
02:39:26 <lunabot>  (True,False)
02:39:37 <aavogt> Berengal: thanks!
02:40:50 <eu-prleu-peupeu> how do i change [M (a, b)] to [M (a, [b]) ] ?
02:41:05 <aavogt> what's M?
02:41:08 <eu-prleu-peupeu> a monad
02:41:09 <eu-prleu-peupeu> :P
02:41:26 <c_wraith> how precisely do you expect to get more b values?
02:41:26 <sproingie> homework?
02:41:38 <aavogt> I think you'll have to settle for  m [(a,[b])]
02:41:53 <eu-prleu-peupeu> whenever a's are equal, ill add the b's
02:41:56 <aavogt> there's not much you can do for grouping the a's without sequencing your monad events
02:42:05 <eu-prleu-peupeu> oh :(
02:42:09 <eu-prleu-peupeu> but i dont want that
02:42:13 <eu-prleu-peupeu> i want the monad to be inside
02:42:22 <eu-prleu-peupeu> so it can easily be composed by ++
02:42:24 <sproingie> if you have a type constructor for M you can do any transformation you want.  whether it's actually meaningful is another matter
02:42:35 <eu-prleu-peupeu> sequence the monad must come in later
02:42:37 <eu-prleu-peupeu> not at this time
02:42:44 <aavogt> @free sequence
02:42:45 <lambdabot> Expected variable or '.'
02:42:50 <aavogt> @ft sequence
02:42:51 <lambdabot> Done.
02:43:19 <aavogt> eu-prleu-peupeu: I'm pretty sure that monad laws let you do this:   sequence a >> sequence b === sequence (a++b)
02:45:09 <aavogt> eu-prleu-peupeu: consider that in general, you can't compare the results of two monadic computations without settling one some kind of order for their effects to happen
02:45:13 <Berengal> eu-prleu-peupeu: You can't look at the as to determine they're equal without running the monad
02:45:40 <aavogt> yeah, Berengal said it bette
02:45:41 <eu-prleu-peupeu> so, if i have f :: M [a], and g :: M[a], how do i add them without some fugly thing like fmap (++) ?
02:45:42 <aavogt> better
02:45:48 <scalaLove> as programming knowledge grows you need to document your stuff, you guys can recommend me some personal GUI equiped wiki software for personal use, not web? I mean imagine having while and link to other page, you click to while and then in the new page u click python and it takes you to a while code example for python. how cool is that you can build yourself a ALL-LANGUAGES-YOU-KNOW one...
02:45:50 <scalaLove> ...reference, only one.
02:45:59 <Berengal> eu-prleu-peupeu: You can't. You have to fmap
02:46:12 <Berengal> And, indeed, join, or bind
02:46:13 <aavogt> liftM2 (++)
02:46:34 <aavogt> fmap (++) f `ap` g
02:47:08 <aavogt> using applicative syntax (I didn't use) isn't fugly imho
02:47:18 <Berengal> (++) <$> f <*> g
02:47:31 <eu-prleu-peupeu> hmmf
02:47:31 <aavogt> scalaLove: supposedly emacs' org mode is pretty good
02:47:51 <|Jedai|> There was some crazy combinators for infix operator and applicative somewhere
02:48:35 <|Jedai|> aavogt: He want's a wiki to keep track of its progress and thoughts, not an IDE
02:48:43 <|Jedai|> *want
02:48:48 <|Jedai|> *wants
02:49:16 <aavogt> I dunno how much sense it makes to keep those separate...
02:49:27 <aavogt> there are some wikis written in haskell however
02:50:10 <Twey> org-mode isn't an IDE…
02:50:25 <Twey> It's a general-purpose note-taking and personal organisation system
02:50:29 <|Jedai|> aavogt: org is awesome though, but I guess he wants something he can access from the web (and IIRC scalaLove is allergic to emacs)
02:50:58 <|Jedai|> Twey: Yeah, I know (I read haskell-mode the first time though)
02:51:16 <eu-prleu-peupeu> what if i have f, g, h, i ... z :: M [a] ?
02:51:24 <eu-prleu-peupeu> how easy is it to ++ them ?
02:51:33 <eu-prleu-peupeu> (and readable)
02:51:44 <knobo> |Jedai|: did you see my message to you above?
02:51:45 <Twey> concat [f, g, h, i ... z]
02:51:54 <eu-prleu-peupeu> Twey: M is a monad :P
02:51:56 <|Jedai|> knobo: No
02:52:04 <Twey> mconcat [f, g, h, i ... z]
02:52:04 <Twey> :þ
02:52:14 <scalaLove> |Jedai| can you give me link to org? I seach org on google but crazy stuff come out...
02:52:27 <knobo> |Jedai|: Almost the same function that you helped me with in "yet another haskell introduction". simplified with a state monad :)
02:52:28 <Twey> Or, fmap concat . sequence
02:52:41 <|Jedai|> scalaLove: that's org-mode in emacs, I thought you didn't like emacs ?
02:52:43 <eu-prleu-peupeu> okey
02:52:47 <eu-prleu-peupeu> mconcat seems what i need
02:52:48 <eu-prleu-peupeu> :)
02:52:48 <Twey> :: [M [a]] -> M [a]
02:52:51 <knobo> I don't understand Monads yet, but I intend to learn :)
02:52:55 <Twey> Right-ho
02:53:07 <|Jedai|> @type mconcat
02:53:08 <lambdabot> forall a. (Monoid a) => [a] -> a
02:53:09 <scalaLove> oh that, yeah, I hate emacs
02:53:14 <eu-prleu-peupeu> i dont like fmaping functions
02:53:18 <eu-prleu-peupeu> its very ugly
02:53:19 <Twey> Some people hate water
02:53:24 <Twey> eu-prleu-peupeu: Not at all
02:53:25 <sproingie> i wish BONUS would get around to monads.  he did a bang-up job on applicatives already.
02:53:30 <|Jedai|> eu-prleu-peupeu: I don't think so...
02:53:34 <BONUS> on it! :D
02:53:43 <eu-prleu-peupeu> :D
02:53:44 <sproingie> yay :)
02:53:51 <jmcarthur_work> eu-prleu-peupeu, <$> is your friend
02:53:51 <BONUS> busy as heck, but i didn't forget, working on them!
02:53:59 <Twey> eu-prleu-peupeu: It's a lot better than ‘(>>= return . concat) . sequence’ :þ
02:54:00 <eu-prleu-peupeu> yes <$> is better
02:54:09 <eu-prleu-peupeu> indeed
02:54:12 <Zao> Soo... I've got a SGI O2 R10k with NetBSD/sgimips on it. Why isn't there any binary GHC for it? :)
02:54:14 <jmcarthur_work> i wish fmap was just called map, though
02:54:17 <eu-prleu-peupeu> its just the name "fmap"
02:54:19 <eu-prleu-peupeu> it sucks
02:54:21 <sproingie> fap
02:54:26 <Twey> Call it something else
02:54:29 <Twey> Cale likes to call it .
02:54:29 <|Jedai|> knobo: Not surprising, it looked pretty stat-ish with it's two pair bindings
02:54:37 <Twey> (. concat) . sequence
02:54:38 * jmcarthur_work has applied the change in alt-stdlib
02:54:48 <Twey> jmcarthur_work: To map or to (.)?
02:54:51 <jmcarthur_work> map
02:54:52 <osaunders> Is it possible to create an addThree x y z = x + y + z using composition and sectioning only?
02:54:53 <PeakerWork> > (*3) . [1,2,3]
02:54:53 <Twey> Oho
02:54:54 <lambdabot>   [3,6,9]
02:54:58 <sproingie> stuff like <$> is handy but it's noisy
02:55:00 <|Jedai|> knobo: interesting though :)
02:55:01 <Twey> osaunders: Yes
02:55:08 <PeakerWork> I guess that makes sense if you see [1,2,3] as the *computation* that yields 1,2,3
02:55:11 <Twey> @pl \x y z -> x + y + z
02:55:11 <lambdabot> ((+) .) . (+)
02:55:12 <sproingie> to say nothing of the operators some people define themselves
02:55:19 <Twey> addThree = ((+) .) . (+)
02:55:33 <osaunders> Oh wow.
02:55:34 <jmcarthur_work> addThree = result (+) . (+)
02:55:39 <jmcarthur_work> where result = (.)
02:55:39 <eu-prleu-peupeu> talking about fugly :P
02:55:52 <Twey> eu-prleu-peupeu: That's not too bad, really
02:55:55 <|Jedai|> eu-prleu-peupeu: liftM concat . mapM sequence
02:55:57 <sproingie> i do love how haskell ends up looking like an emoticon
02:56:01 <Twey> conal's ‘result’ is probably nicer
02:56:12 <Twey> But I don't know that I'd bother using it here
02:56:14 <PeakerWork> addThree = (result . result) (+) (+)  -- apply (+) in the result of the result of (+)
02:56:22 <knobo> |Jedai|: well, there is a lot to learn :)
02:56:24 <jmcarthur_work> i was about to say that :P
02:56:50 <eu-prleu-peupeu> ok, back to code...
02:56:55 <|Jedai|> osaunders: You mean "Arg" no ?
02:57:12 <osaunders> Arg?
02:57:19 <|Jedai|> osaunders: That's ugly
02:57:20 <PeakerWork> I think using  result (+) . f  is not really a SEC -- (result . result) (+) f   is more SEC-ish, because the path on the type of (+) is result dot result
02:57:22 <osaunders> Instead of wow?
02:57:26 <|Jedai|> knobo: Always :)
02:57:46 <knobo> |Jedai|: did you get my url?
02:57:48 <osaunders> osaunders: Well I'm not after beauty here.
02:58:03 <jmcarthur_work> PeakerWork, i think you are right
02:58:21 * Twey always feels that he should be able to use $ in things like (result . result) (+)
02:58:25 <|Jedai|> knobo: I did
02:58:29 <jmcarthur_work> i personally don't think the point free version is all that bad, esp. with result
02:58:30 * Twey gets dreadfully disappointed when he discovers otherwise
02:59:06 <zygoloid> PeakerWork: i think applying result to a binary function is not very SEC-ish
02:59:24 <jmcarthur_work> result2 = result . result
02:59:31 <jmcarthur_work> result2 (+) (+)
02:59:32 <zygoloid> PeakerWork: since semantically, producing a functor containing a function isn't really how you'd think of what you're doing
02:59:35 <|Jedai|> osaunders: The conclusion is that can almost always find a point free version, but it's very easy to veer into the pointless...
03:00:12 <PeakerWork> zygoloid: You mean (result . result) f g      -- you mean its not SECish that f is a binary function?
03:00:47 <zygoloid> PeakerWork: i mean, if g is a function and f is a binary function, you're using a very specific property of the function functor
03:00:52 <jmcarthur_work> i do admit that it's kind of odd where f is not unary
03:01:00 <PeakerWork> zygoloid: I'm not using functors here at all
03:01:10 <jmcarthur_work> yeah result = (.), not fmap
03:01:18 <PeakerWork> jmcarthur_work, zygoloid: I usually manage to make the mental jump of thinking about all functions as unary functions too
03:01:18 <|Jedai|> knobo: Nice of you to give me credit :), but really you're welcome
03:01:34 <PeakerWork> (sometimes its difficult)
03:01:42 <jmcarthur_work> PeakerWork, me too, but it's sometimes.... okay you stole my words
03:01:43 <zygoloid> PeakerWork: the point of SEC is semantic clarity. i don't think this gives that.
03:02:19 <zygoloid> PeakerWork: and fwiw i always use fmap rather than result or second -- i don't really find result or second helpful when i've already got a type signature on the line above
03:02:23 <PeakerWork> zygoloid: clarity is in the eye of the beholder :)
03:03:01 <zygoloid> PeakerWork: oh, absolutely. this is obviously a matter of taste, but to me it tastes funny :-)
03:03:13 <PeakerWork> zygoloid: Well, it may be helpful to see which instance is chosen -- when that is known... Though it could be nice if the code editor showed that :)
03:03:41 <PeakerWork> I'd like to always use fmap, but then have the editor put a "second" somewhere around the "fmap" when the type is known to be a tuple
03:04:05 <zygoloid> PeakerWork: i find it nicer to see (fmap.fmap.fmap.fmap) and think "four levels down" when looking at the type, rather than seeing (fmap.second.result.fmap) and having to remember stuff while looking at the type
03:04:43 <PeakerWork> zygoloid: but "down" isn't the only direction
03:04:56 <PeakerWork> zygoloid: what about (first . arg . result . map . nth 5) f ..
03:05:03 <zygoloid> PeakerWork: no, but it's the only direction i've come up against so far (!)
03:05:23 <jmcarthur_work> i find it weird to think about "levels down" when the type constructors are made up of some combination of infix and prefix, personally. if they are all prefix it's fine
03:05:30 <portnov> :t (fmap.fmap.fmap.fmap)
03:05:32 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
03:05:47 <jmcarthur_work> and in my opinion, if i find myself using long strings of fmaps i probably should make a newtype wrapper and give it a functor instance
03:05:58 <PeakerWork> zygoloid: SECs I've played with were not always "fmap", I think
03:06:11 <PeakerWork> jmcarthur_work: or use TypeCompose's :. ?
03:06:17 <jmcarthur_work> i typically use SECs when a simple functor instance won't work
03:06:21 <jmcarthur_work> PeakerWork, exactly
03:06:26 <zygoloid> PeakerWork: your (first . arg . result . map . nth 5) example kinda horrifies me. i'd write that out pointfully!
03:06:59 <PeakerWork> zygoloid: really? That would be awful in point-ful notation
03:07:33 <PeakerWork> zygoloid: I find it more readable as a "path on the type" -- oh, you apply the function on that "a"? Cool
03:08:22 <zygoloid> given: \(a,b) -> (\x -> a (map (nth 5) . x), b)   i can almost immediately see what's going on.
03:08:32 <jmcarthur_work> eek
03:08:46 <jmcarthur_work> i'm just the opposite
03:08:47 <zygoloid> given the SEC form i have to work it out, which takes me longer
03:08:50 <PeakerWork> zygoloid: Opposite for me
03:09:14 <PeakerWork> zygoloid: also, I'd really love to see Haskell evolve to the point where there's no \ notation at all :)
03:09:36 <jmcarthur_work> with the pointful version i have to keep switching from the lhs to the rhs as i piece together what's happening. with the point free version i can just read left to right
03:10:19 <jmcarthur_work> well, with the SEC version i mean
03:10:27 <jmcarthur_work> @pl \(a,b) -> (\x -> a (map (nth 5) . x), b)
03:10:27 <lambdabot> first (. (map (nth 5) .))
03:10:33 <PeakerWork> zygoloid: I have to reverse-engineer your intent (of not touching the "b" there) from your code -- I find it less declarative, as it is more about the how and less about the what
03:10:37 <jmcarthur_work> that doesn't read so well to me
03:10:56 <PeakerWork> yeah, conal describes his SEC insight as "realizing (.) is useful as a unary function"
03:11:03 <PeakerWork> described*
03:11:20 <zygoloid> PeakerWork: my brain matches up the shapes, and i can see what's happening quickly that way
03:12:04 <PeakerWork> zygoloid: I agree the example is contrived.. Worst stuff I had were things like:  (map . map . map . first) or such -- and in these cases giving aliases to some SEC paths corresponding to your types can really help
03:12:26 <zygoloid> map . map . map? really? ;-)
03:13:08 <chrisdone> oh my
03:13:09 <zygoloid> i like fmap^n being 'just a generalization of fmap'
03:13:22 <chrisdone> I *do* like this haskell logo variation! http://haskellwebnews.wordpress.com/2009/12/05/whats-new-in-haskell-december-2009/
03:13:28 <chrisdone> mmmm
03:13:57 <chrisdone> retains the original purple and greens that became so familiar
03:13:57 <chrisdone> also shiny
03:17:25 <PeakerWork> zygoloid: why not?  Its one of the things I love most about ghci vs Python :)
03:17:39 <PeakerWork> given some list of list of words -- I can easily apply a function to each letter
03:17:54 <PeakerWork> (map . map . map) succ words
03:18:50 <mxyz> if im trying to build something and i see "make: *** [all] Error 2 + exit 1" is that bad, lol?
03:21:30 <osaunders> What does this mean? (+1) . (+) :: (Num (a -> a), Num a) => a -> a -> a
03:21:49 <osaunders> The class constraints confuse me.
03:21:55 <PeakerWork> osaunders: That's probably wrong
03:22:10 <osaunders> I know (+1)  . (+) is wrong but I still want to understand what the type inference means.
03:22:13 <PeakerWork> osaunders: You probably didn't want to call (+1) on the direct result of (+), which has type   Num a => a -> a   (e.g: Int -> Int)
03:22:17 <PeakerWork> osaunders: ah
03:22:25 <Saizan> osaunders: it means that you'd need a Num instance for functions to use that expression
03:22:59 <osaunders> Saizan: Ah, OK.
03:23:05 <PeakerWork> osaunders: It means that (+1) needs to apply to the   Num a => a -> a    function,  since (+1) :: Num b => b -> b    unifying (a->a) and b  yields:   (Num a, Num (a -> a)) => a -> a -> a
03:24:29 <osaunders> How can a be (a->a) and (Num a) at the same time?
03:25:55 <benmachine>  if you declare a Num instance for (a -> b)
03:26:00 <benmachine> which you can't do sensibly
03:27:46 <doserj> osaunders: it is not that a needs to be (a->a). a needs to be an instance of Num, and (a->a) needs to be an instance of Num.
03:27:59 <scalaLove> What is this "Just" thing in Haskell?
03:28:35 <doserj> @src Maybe
03:28:36 <lambdabot> data Maybe a = Nothing | Just a
03:28:50 <Twey> benmachine: Nonsense
03:29:07 <Twey> Church numerals are (a -> a) and also Num
03:29:07 <osaunders> doserj: Right. I think I understand that now.
03:29:07 <doserj> it is a data constructor for the Maybe a data-type
03:29:31 <zygoloid> benmachine: i'm aware of three Num (a -> a) instances which make sense.
03:29:38 <qwr> scalaLove: whether something is just or not...
03:29:47 <doserj> Twey: how do you define negate for church numerals?
03:29:55 <zygoloid> doserj: same way you define it for Nat
03:30:03 <zygoloid> > negate 1 :: Nat
03:30:04 <lambdabot>   Not in scope: type constructor or class `Nat'
03:30:05 <fracture> I have a list like [1,0,0,0,1,0,1], and I want to turn it into a list where if there is a 1 in the nth position, I get n * someValue in my final list, and otherwise nothing.... any hints?
03:30:07 <zygoloid> > negate 1 :: Natural
03:30:08 <lambdabot>   * Exception: Natural: (-)
03:30:23 <Twey> doserj: You don't
03:30:26 <Twey> Yeah :þ
03:30:34 <scalaLove> qwr: just or not?
03:30:37 <fracture> that part giving me trouble is finding out which n (map can't do this I guess)
03:30:59 <Twey> fracture: Zip it first
03:31:00 <ray> making degenerate Num instances is especially fun, because of the way numeric literals are in Haskell
03:31:02 <osaunders> scalaLove: Search for the first occurance of "maybe" in http://learnyouahaskell.com/modules
03:31:07 <zygoloid> > let someValue = 3 in zipWith (\n v -> someValue * n * v) [1..] [1,0,0,0,1,0,1] -- fracture
03:31:09 <lambdabot>   [3,0,0,0,15,0,21]
03:31:11 <fracture> Twey: good idea
03:31:18 <fracture> ah
03:31:25 <fracture> thanks
03:31:33 * fracture never thinks of "zip"... that thing is useful.
03:32:00 <sw17ch> > let x = [1..10] in zipWith3 (,,) x x x
03:32:01 <lambdabot>   [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(6,6,6),(7,7,7),(8,8,8),(9,9,9),(1...
03:32:09 <Twey> There's another way, of course
03:32:40 <mreh> i'm really stuck on a problem, I need to do backtracking with haskell and I need to remember the point i've reached so far
03:32:48 <mreh> it's a little like finding the solution to a maze
03:32:57 <zygoloid> > (3*) `fmap` zipWith (*) [1..] [1,0,0,0,1,0,1]
03:32:58 <lambdabot>   [3,0,0,0,15,0,21]
03:33:18 <Veinor> mreh: pass it around as an argument to the function? or encode it as state in a monad?
03:33:21 <mreh> I don't want to have to compute every possible path through the maze
03:33:23 * zygoloid would like to write `zipWith (*)` ;-(
03:33:23 <Twey> mreh: ZIPPERS!
03:33:42 <Apocalisp> yeppers
03:34:02 <Veinor> @pl \x -> (x,x,x)
03:34:03 <lambdabot> join (join (,,))
03:34:08 <mreh> Veinor, I don't know how to encode state in a monad
03:34:08 <Twey> zygoloid: Well, you can zipWith3 (\x y z -> [x, y, z]) and then use product
03:34:46 <mreh> how do you exploit the properties of a monad to do that?
03:34:46 <zygoloid> @pl \(a,b,c) -> a * b * c
03:34:47 <lambdabot> (line 1, column 6):
03:34:47 <lambdabot> unexpected ","
03:34:47 <lambdabot> expecting letter or digit, operator or ")"
03:34:47 <lambdabot> ambiguous use of a non associative operator
03:34:48 <jmcarthur_work> mreh, wrap it in StateT?
03:34:54 <zygoloid> haha :)
03:35:03 <Veinor> ... what? why doesn't that work?
03:35:09 <mreh> jmcarthur_work, isn't that the same as ST?
03:35:14 <jmcarthur_work> mreh, no
03:35:21 <mreh> StateTransformer
03:35:29 <jmcarthur_work> mreh, ST provides STRefs, StateT gives you a single state
03:35:30 <zygoloid>  @pl doesn't know how to unwrap (,,) i guess
03:35:53 <jmcarthur_work> mreh, also, ST is not a transformer
03:36:01 <shachaf> zygoloid: That's because you can't do it without pattern-matching.
03:36:12 <Apocalisp> How would you feel about changing the type of fmap to be: fmap :: (CanBuildFrom r b t) => (a -> b) -> t
03:36:19 <jmcarthur_work> shachaf, sure you can. you just have to define a combinator
03:36:33 <shachaf> jmcarthur_work: And how will you define the operator?
03:36:34 <_Jedai_> jmcarthur_work: with pattern matching....
03:36:48 <shachaf> jmcarthur_work: There's no operator in the standard library, anyway.
03:36:49 <zygoloid> shachaf: right :) it could at least make up a selector, though... tuple3_0?
03:37:00 <Veinor> tuple 3.0!
03:37:05 <jmcarthur_work> _Jedai_, of course, but then you can use it without pattern matching
03:37:20 <shachaf> zygoloid: Sure, but you really shouldn't be doing that with tuples beyond a certain size.
03:37:35 <zygoloid> shachaf: true. but 3-tuples aren't really that certain size yet imo
03:38:10 <zygoloid> @type zip7
03:38:12 <lambdabot> forall a b c d e f g. [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
03:38:19 <zygoloid> *shudder*
03:38:45 <Cale> Apocalisp: That no longer expresses the structure that fmap has.
03:39:12 <Cale> Apocalisp: though it's true that it would admit more interesting functors from Hask
03:39:21 <Twey> zygoloid: Thank goodness for ZipLists :þ
03:39:42 <Twey> Is zip7 the longest one they defined?
03:39:46 <Twey> :t zip8
03:39:47 <lambdabot> Not in scope: `zip8'
03:39:49 <Twey> Ah
03:39:53 <jmcarthur_work> :t zipWith7
03:39:54 <lambdabot> forall a b c d e f g h. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
03:39:59 <zygoloid> @src zip7
03:40:00 <jmcarthur_work> o_O
03:40:00 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:40:08 <Veinor> @src zipWith7
03:40:09 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:40:12 <Cale> To be fair, you're never going to even need zip7
03:40:12 <Veinor> :/
03:40:13 <zygoloid> presumably zip7 = zipWith7 (,,,,,,)
03:40:25 <zygoloid> rather than the other way around
03:40:25 <Twey> Heheh
03:40:27 <Veinor> :t (,,,,,,,,,)
03:40:28 <lambdabot> forall a b c d e f g h i j. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a, b, c, d, e, f, g, h, i, j)
03:40:34 <Veinor> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
03:40:35 <Apocalisp> Cale: So it's no longer clear that fmap is specifically a structure-preserving map.
03:40:35 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
03:40:35 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q
03:40:35 <lambdabot> -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49
03:40:35 <lambdabot> -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 ->
03:40:37 <grn> How can I check whether a list contains duplicates?
03:40:38 <lambdabot> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> t91 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31,
03:40:39 <jmcarthur_work> AH
03:40:41 <lambdabot> t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70, t71,
03:40:45 <Veinor> ... D:
03:40:45 <lambdabot>  t72, t73, t74, t75, t76, t77, t78, t79, t80, t81, t82, t83, t84, t85, t86, t87, t88, t89, t90, t91)
03:40:45 <Twey> ARGH!
03:40:47 <Twey> Don't do that!
03:40:49 <Apocalisp> Ooookay
03:40:52 <jmcarthur_work> @stopit
03:40:52 <lambdabot> Unknown command, try @list
03:40:56 <Twey> Hahaha
03:40:56 <jmcarthur_work> :P
03:40:59 <Twey> @botsmack
03:40:59 <lunabot>  :o
03:40:59 <lambdabot> :)
03:41:00 <Veinor> it's done, I saw the close paren
03:41:13 <zygoloid> -- @@ @type @eval text $ "(" ++ replicate 300 ',' ++ ")"
03:41:16 <sw17ch> > nub [1,1,2,3,4,4,5,6,7]
03:41:17 <lambdabot>   [1,2,3,4,5,6,7]
03:41:27 <Veinor> zygoloid: oh god, you know not what you do!
03:41:33 <shachaf> @slap zygoloid
03:41:33 <Twey> zygoloid: Aïe!
03:41:34 * lambdabot loves zygoloid, so no slapping
03:41:42 <mreh> what's the complexity of nub? i calculated n!
03:41:42 <Cale> Apocalisp: Yeah, at least that it sends arrows to arrows in a way which accords with how objects are sent to objects
03:41:48 <Twey> I sincerely hope that doesn't actually work, at least in a public channel :þ
03:42:06 <Veinor> @@ @type @eval text $ "(" ++ replicate 2 ',' ++ ")"
03:42:07 <lambdabot>  <no location info>: not an expression: `'
03:42:12 <Veinor> there's your answer
03:42:14 <Apocalisp> Cale: This is how it appears in Scala 2.8. It makes me so sad.
03:42:48 <zygoloid> Twey: it works. but you have to change @eval to @run first ;-)
03:43:02 <mreh> has State monad been deprecated?
03:43:09 <Twey> mreh: ‽ No!
03:43:21 <mreh> what's StateT then?
03:43:35 <zygoloid> it's the transformer version
03:43:35 <Twey> A transformer for the State monad.
03:43:46 <Twey> Transformers let you combine monads.
03:43:57 <Cale> mreh: It's a monad transformer which takes one monad and builds State-monad-like structure over it.
03:44:10 <grn> how to check whether a list contains duplicates?
03:44:15 <Twey> (ideally we'd have every monad just be a transformer instead, except for Identity at the bottom of the stack, but I hear this has performance issues)
03:44:16 <EnglishGent> hi all :)
03:44:17 <Cale> Transformers don't *really* let you combine monads. They let you transform one monad into another.
03:44:30 <Twey> grn: sort . nub list == sort list
03:44:32 <Twey> Er
03:44:38 <Twey> sort (nub list) == sort list
03:44:59 <Veinor> Transformers are also robots in disguise.
03:44:59 <shachaf> Twey: Why is sorting necessary?
03:45:01 <zygoloid> StateT s is a type-level function from monads to monads
03:45:10 <grn> Twey, is sorting necessary?
03:45:17 <Twey> grn: Yes
03:45:19 <Twey> Wait
03:45:27 <Twey> > nub [3, 5, 3]
03:45:29 <lambdabot>   [3,5]
03:45:30 <Twey> No
03:45:34 <Twey> Apparently not ☺
03:45:59 <mreh> Twey, have you memorised all the special character codes?
03:46:03 <sw17ch> @src nub
03:46:03 <lambdabot> nub = nubBy (==)
03:46:06 <zygoloid> > map head . group . sort $ [3,5,3]
03:46:08 <lambdabot>   [3,5]
03:46:08 <sw17ch> @src nubBy
03:46:09 <lambdabot> nubBy eq []             =  []
03:46:09 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
03:46:12 <Twey> mreh: Eh?  No
03:46:19 <jmcarthur_work> mreh, autoreplace is nice :)
03:46:22 <Twey> Ewww
03:46:33 * Twey hates anything that modifies what he types
03:46:48 <jmcarthur_work> Twey, i only rig it up to do it to backslashed things
03:46:51 * Twey doesn't even like it when LaTeX mangles '
03:47:01 <jmcarthur_work> \lambda = λ
03:47:20 <shachaf> jmcarthur_work: ctrl-shift-3bb = λ
03:47:25 <Twey> Heh, seven chars?
03:47:36 <Twey> Compose / \ = λ
03:47:46 <Veinor> I wish Haskell supported λx -> x :P
03:47:50 <shachaf> Twey: I just set up my Compose key a few days ago.
03:47:53 <davidL> speaking of which, is there a LaTeX package that will treat λ as macros and expand them to \lambda?
03:47:56 <Twey> Veinor: I think it does
03:47:56 <copumpkin> Veinor: me too
03:48:00 <copumpkin> Twey: nope
03:48:01 <Twey> Oh, wait
03:48:04 <Twey> Yeah, letter.
03:48:06 <Twey> haskell-mode does.
03:48:08 <jmcarthur_work> shachaf, not for me
03:48:18 <shachaf> Twey: I should add some more characters -- there are a few I've been missing.
03:48:23 <shachaf> jmcarthur_work: In urxvt, anyway.
03:48:24 <Veinor> Compose keys are configurable, yeah
03:48:36 <Twey> shachaf: clsn has a Whopping Big File he's been working on
03:48:45 <Twey> I doubt he'd mind a PM
03:48:49 * shachaf needs more modifier keys!
03:48:53 <Twey> Yeah :-\
03:49:03 <Twey> Veinor: Unless you use SCIM.  ☹
03:49:20 <jmcarthur_work> shachaf, not in my urxvt :\
03:49:23 <Twey> SCIM is evil, and hijacks your Compose key, replacing it with its own non-configurable handler.
03:49:31 <Veinor> Ew.
03:49:34 <Twey> Yeah.
03:49:36 <shachaf> jmcarthur_work: No? You have to hold ctrl and shift down while typing 3bb.
03:49:37 <Botje> me cuddles his escape key
03:49:39 <Twey> I don't know quite why.
03:49:43 <jmcarthur_work> shachaf, that's what i did
03:49:52 <shachaf> jmcarthur_work: Huh. Does the little yellow thing pop up?
03:50:17 <Twey> In GTK+ apps, you can type C-S-u 3 b b RET
03:50:18 <jmcarthur_work> shachaf, yes, but the character it gives me isn't lambda
03:50:30 <shachaf> jmcarthur_work: Oh. What do you get?
03:50:41 <zygoloid> > let ı = undefined in [ı,ı,ı]
03:50:42 <lambdabot>   [* Exception: Prelude.undefined
03:50:50 <jmcarthur_work> shachaf, gosh, it was just my font being dumb
03:51:16 <zygoloid> ĸ
03:51:19 <jmcarthur_work> shachaf, i mostly use sakura so i can use the clipboard that most of my other apps use, so my urxvt isn't very customized
03:52:36 * Twey uses Terminal.
03:52:40 <jmcarthur_work> i may have to type out \lambda, but at least it's not gibberish :P
03:53:41 <grn> How to rotate a list?
03:53:48 <Botje> turn it sideways
03:53:52 <copumpkin> grn: inefficiently
03:54:13 * Botje will become a mac user soonish.
03:54:24 <jmcarthur_work> Botje, coming from what?
03:54:39 <Botje> six years of gentoo and 3 years of ubuntu
03:54:49 <jmcarthur_work> you keep downgrading!
03:54:52 <jmcarthur_work> :P
03:54:58 <Botje> yeah
03:55:08 * copumpkin screams at jmcarthur_work 
03:55:09 <Botje> i don't get much choice in the hardware i get from uni
03:55:16 <Botje> I hope it's tolerable enough
03:55:29 <Botje> i'll probably get a decent rat instead of a murky mouse
03:55:37 * jmcarthur_work throws explicatives in copumpkin's general direction
03:56:05 * copumpkin engages in less-than-gentlemanly behavior in jmcarthur_work, possibly involving fists
03:56:15 <copumpkin> oh whoops, broken sentence
03:56:16 <Veinor> but you can use your mouse like a trackpad! :O
03:56:30 <Veinor> mm, copumpkin/jmcarthur slashfic.
03:57:26 * jmcarthur_work protects himself with static types
03:57:57 <Botje> Veinor: i need a mouse with at least five buttons
04:00:32 <Veinor> what about a mouse with... 18 BUTTONS?
04:00:52 <Veinor> http://www.warmouse.com/branding/images/wm-bb2.png
04:01:10 <byorgey> WHAT
04:01:23 * EnglishGent 's mouse has 6 buttons + a wheel + another button that toggles the first 6 between 2 distinct sets...
04:01:27 <EnglishGent> will that do? :)
04:01:47 <ray> only if the wheel also toggles
04:02:02 <Botje> Veinor: oh, and my mouse wheel also clicks sideways
04:02:02 <mm_freak> @pl \[x,y] -> [y,x]
04:02:02 <lambdabot> (line 1, column 2):
04:02:03 <lambdabot> unexpected "["
04:02:03 <lambdabot> expecting pattern
04:02:05 <Botje> so i have 7 buttons
04:02:11 <mm_freak> @pl \([x,y]) -> [y,x]
04:02:12 <lambdabot> (line 1, column 3):
04:02:12 <lambdabot> unexpected "["
04:02:12 <lambdabot> expecting pattern
04:02:18 <Botje> and a settable sensitivity
04:02:20 <EnglishGent> I think the wheel remains a wheel :|
04:02:23 <mm_freak> @pl \(x:y:[]) -> [y,x]
04:02:23 <lambdabot> (line 1, column 7):
04:02:23 <lambdabot> unexpected "["
04:02:23 <lambdabot> expecting "()", natural, identifier, "_" or "("
04:02:42 <mm_freak> @pl \(x:y:_) -> [y,x]
04:02:43 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . flip (:) . return . head) tail
04:02:53 <mm_freak> @pl \(x:y:zs) -> [y,x]
04:02:54 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . flip (:) . return . head) tail
04:03:04 <mm_freak> @pl \(x:y:zs) -> [y,x]:zs
04:03:05 <lambdabot> ap ((`ap` tail) . (. head) . ((:) .) . flip (:) . return . head) tail
04:03:13 <mm_freak> @pl \(x:y:zs) -> y:x:zs
04:03:14 <lambdabot> ap ((`ap` tail) . (. head) . flip ((.) . (:)) . (:) . head) tail
04:03:31 <lispy> mm_freak: lambdabot also responds to /msg :)
04:04:09 <mm_freak> oh, thanks
04:04:11 <mm_freak> and sorry =)
04:04:38 <copumpkin> mm_freak: you're here!
04:04:49 <lispy> mm_freak: not a big deal.  It was pretty quiet.
04:04:51 <mmorrow> preflex: seen int-e
04:04:52 <preflex>  int-e was last seen on #haskell 6 hours, 27 minutes and 36 seconds ago, saying: > fmap last $ getSequenceByID "A000045"
04:05:03 <mm_freak> copumpkin: i'm always here
04:05:11 <copumpkin> mm_freak: but not idling!
04:05:40 <mm_freak> well, it's not that i've had many haskell questions recently =)
04:07:23 <mmorrow> <mreh> i'm really stuck on a problem, I need to do backtracking with haskell and I need to remember the point i've reached so far
04:07:51 <mmorrow> mreh: so something like walking all paths through a graph exactly once?
04:08:03 <mmorrow> (or something?)
04:08:46 <mmorrow> mreh: i recently realized that doing this is super easy, but it took me a long time to realize how to do it
04:09:01 <akappa> mreh, what about let the function return such "point"?
04:09:20 <mmorrow> mreh: (well, figuring out what "all paths" should mean is what took a long time to realize)
04:10:11 <mmorrow> mreh: something like this? http://moonpatio.com/images/CFG_0-800_600.png
04:10:39 <mmorrow> mreh: (which the function `paths' in this paste computed http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5207)
04:11:06 <mreh> yeah, just like that
04:11:11 <mreh> a maze is a graph i suppose
04:11:58 <copumpkin> haskell needs a trophy system
04:12:01 <copumpkin> like a videogame
04:12:58 <zygoloid> achievement unlocked: The Man With Three Monads (usage of three monads in a single expression)
04:13:08 <Ferdirand> and rank names
04:13:21 <trofi> and package list on hackage
04:14:10 <mmorrow> mreh: here's that paths function with using only stdlib functions and with the type syns i was using expanded http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5283#a5283
04:14:28 <zygoloid> mmorrow: looks like that's all cycles with internal loops removed?
04:14:37 <zygoloid> in any case, pretty :)
04:15:08 <mmorrow> zygoloid: it's all paths from a given start node that end in either (1) a node with no successors, or (2) a node that's already seen
04:15:33 <zygoloid> mmorrow: i think that's equivalent to all paths from a given start node with no internal cycles
04:15:52 <mmorrow> zygoloid: i'm not sure how you mean "no internal cycles"
04:16:32 <mmorrow> zygoloid: yeah, i really like how that graphviz image came out
04:16:56 <mm_freak> KitB: if you still need that…
04:17:09 <mm_freak> @let pairsFlip xs = do x:y:_ <- takeWhile (not.null) . iterate (drop 2) $ xs; [y,x]
04:17:11 <zygoloid> mmorrow: there's no loop from a node to itself which you can remove without changing the "end" of the path
04:17:11 <lambdabot>  Defined.
04:17:13 * mmorrow parses that sentence
04:17:18 <mm_freak> > pairsFlip [1..10]
04:17:19 <lambdabot>   [2,1,4,3,6,5,8,7,10,9]
04:17:31 <EnglishGent> presumably Oleg would be at the top of the high score table :)
04:17:47 <mmorrow> zygoloid: ah ok, yes i think that's equivalent
04:17:47 <zygoloid> EnglishGent: the scores would presumably be fractions of an Oleg
04:18:19 <EnglishGent> congratulations zygoloid - you've just defined a unit of knowledge! The Oleg!
04:18:28 <Baughn> "hsc2hs: Graphics/X11/Xlib/Extras.hsc: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)" <-- Anyone know what this is about? (6.12-rc2)
04:18:31 <fracture> so I have this loop :: MyState -> IO () function that makes new MyStates and calls itself; and there's certain members of MyState that logically I want to be "const" in a C++ sense...  this seems like a design flaw on my part?
04:18:40 <fracture> is there any way to make sure some members will never be changed somehow?
04:18:46 <Botje> fracture: stuff them in a readerT
04:18:54 <trofi> Baughn: yup. non-UTF8 char there
04:18:59 <byorgey> EnglishGent: this unit has existed for many years already =)
04:19:18 <byorgey> type-hackery is routinely measured in milliolegs
04:19:32 <Baughn> trofi: And hsc2hs has no option to handle latin-1 files. Okay. recode should fix it.
04:19:37 <fracture> so let's say it is some special Int... then my function becomes loop :: readerT Int MyState -> IO ()  ?
04:19:47 <fracture> err ReaderT
04:19:55 <Botje> uh
04:20:03 <Botje> MyState -> ReaderT Int IO ()
04:20:13 * hackagebot upload: AGI 1.3 - A library for writing AGI scripts for Asterisk (JeremyShaw)
04:20:31 <Botje> fracture: of course you might want to use a StateT as well
04:20:41 <fracture> Botje: what's using a StateT buy me?
04:20:49 <fracture> (in this case)
04:20:50 <Baughn> trofi: Actually, doesn't the haskell'98 standard specify that source files must be utf-8?
04:21:01 <zygoloid> ReaderT is really just a fancy way of writing "MyState -> Int -> IO ()"
04:21:02 <Botje> your type becomes ReaderT Int (StateT MyState IO ()))
04:21:09 <byorgey> fracture: if some members of MyState should be const, I'd suggest pulling them out into a separate data type called MyEnv or something like that
04:21:17 <trofi> Baughn: it does, but it's a comment :]
04:21:21 <Botje> but yeah, start with a ReaderT, i guess :)
04:21:26 <EnglishGent> if I want to do GUI stuff in Haskell - what do I need to look at? (so far everything I've done has been command line based)
04:21:31 <EnglishGent> in terms of libraries & so on
04:21:40 <EnglishGent> :)
04:21:45 <trofi> Baughn: moreover, i've sent "path" to dons some days ago and no response :[
04:21:51 <trofi> s/path/patch/
04:21:53 <byorgey> EnglishGent: gtk2hs is fairly standard
04:22:02 <byorgey> EnglishGent: there's also wx
04:22:02 <EnglishGent> ty :)
04:22:12 <copumpkin> Veinor: if you only watch two japanese music videos today, make the other one this one: http://www.youtube.com/watch?v=haHLKyjTMV0
04:22:19 <Baughn> trofi: It's silly to use anything but ascii/utf-8, though. Better would be for hackage to reject non-utf-8 parseable files.
04:22:26 <Baughn> trofi: Write a patch for that! ;)
04:22:29 <byorgey> EnglishGent: unfortunately, gtk2hs is not cabalised =(
04:22:35 <byorgey> so you have to install it manually
04:22:44 <trofi> Baughn: absolutely agree
04:22:53 <mreh> mmorrow: this thing uses monoids :(
04:22:54 <EnglishGent> :|
04:23:32 <mreh> someone once told me a clock is a monoid, and I didn;t understand what he was talking about
04:23:33 <Veinor> Mine's better, copumpkin :|
04:23:43 <mreh> the whole analogy thing with haskell doesn't work
04:23:52 <EnglishGent> speaking of videos - some very clever software: http://www.youtube.com/watch?v=vEOmzjImsVc&feature=youtube_gdat
04:24:03 <zygoloid> mreh: probably in the sense that modulo addition forms a group
04:24:07 <copumpkin> Veinor: have you watched all of mine yet? it's pretty awesome (the dude is american)
04:24:31 <mmorrow> mreh: what thing?
04:24:50 <mreh> your graph traversal algorithm
04:24:59 <mreh> the recursive backtracking thiny
04:25:02 <zygoloid> copumpkin: it's 4 minutes long and you pasted it 3 minutes ago so i'm guessing not ;-)
04:25:03 <mmorrow> mreh: oh, mempty is just the empty IntSet
04:25:18 <copumpkin> zygoloid: he might have already seen it!
04:25:19 <fracture> hm... so by using ReaderT does that mean I need a bunch of liftIO thingies on every IO usage now?
04:25:21 <mmorrow> mreh: slash i'm not sure i follow what you mean
04:25:46 <byorgey> mreh: are you saying you don't understand monoids? or you don't understand mmorrow's use of monoids?
04:25:58 <Baughn> fracture: Yep! ^_^
04:26:02 <mmorrow> mreh: ok yeah, looking at paths, you could just replace mempty with IS.empty, does that help?
04:26:25 <fracture> doh....  maybe I'll just put it in my state structure and promise not to change it :)
04:26:30 <trofi> @let ioioio = liftIO
04:26:31 <lambdabot>  Defined.
04:26:59 <idnar> eieio?
04:27:16 <mreh> mmorrow: if I knew what IS was
04:27:18 <sw17ch> powerpc is agreat architecture :)
04:27:27 <zygoloid> mreh: IntSet
04:27:34 <mreh> can't find it on hackage, it's indestinguishable from is
04:27:37 <mmorrow> mreh:  import Data.IntSet(IntSet); import qualified IntSet as IS
04:27:43 <mreh> oh
04:27:47 <mmorrow> likewise for IntMap
04:27:48 <mmorrow> and IM
04:28:16 <fracture> ... ok adding the liftIO's wasn't that bad </complaints>
04:28:26 <mmorrow> (and you could s/Int{Set,Map}/{Set,Map}/ too if you liked
04:28:28 <mmorrow> )
04:29:13 <mmorrow> paths takes a graph and a root node, and returns a list of paths, where path := [node]
04:30:04 <mmorrow> so the algo it's using could be adapted to work with any value of "graph" and "node", as long as you have a way of
04:30:42 <mmorrow> (1) graph -> node -> set of nodes, (2) some "set" datastructure
04:31:11 <mmorrow> (and the Set datastructure being used for both the successors to a node, and to keep a "seen" set)
04:33:27 <fracture> ya know, I don't think this Reader really prevents me from "modifying" the value anyway...
04:33:42 <fracture> I could just re-runReader it
04:34:14 <zygoloid> fracture: you could wrap your transformer stack into a newtype and only expose a run function which ran all the layers of it
04:34:26 <zygoloid> you know, if you don't trust yourself not to use runReader ;-)
04:34:50 <fracture> yeah, well, I guess I trust myself not to use runReader as much as I trust myself not to change values that shouldn't change
04:35:03 <fracture> I was just sorta wishing it was easy to mark something "const" somehow like that
04:35:19 <fracture> but I guess ironically since *everything* is const, we sorta lose that type of compiler checking?
04:36:29 <zygoloid> fracture: if this is all happening within a function, you could define your 'constants' in a where clause for that function
04:37:36 <fracture> zygoloid: interesting...  that might actually work perfectly here (depending on when those where clauses run)
04:38:12 <fracture> will the where clauses be re-evaluated when the function calls itself?
04:38:29 <fracture> seems like they would, no?
04:39:17 <stepcut> is there a CPP macro that cabal sets when it is building my package? so I can do something like, #ifdef __CABAL__ ... #endif ?
04:40:19 <nominolo> hmpf, LLVM neither works on Snow Leopard nor on Ubuntu 9.10 ...
04:40:51 <stepcut> how about cmm ?
04:42:04 <nominolo> stepcut: you can add cpp-options: -D__CABAL__ in your .cabal file
04:42:33 <stepcut> nominolo: yeah.. just wanted to know if there is a canonical way already.. thanks!
04:42:50 <nominolo> I don't think Cabal defines anything
04:43:00 <stepcut> I don't want to import Paths_<module> unless I am actually using Cabal to build
04:43:01 <nominolo> what's your use case?
04:43:06 <nominolo> ah, right
04:43:40 <stepcut> when I am in the source directory and I want, runhaskell Main.hs to work (and use some paths that are local to the source), but which cabal it should use Paths and find out where the data-files really live
04:44:57 <copumpkin> #ty attempt
04:45:01 <lunabot>  forall a . a -> Maybe a
04:45:07 <copumpkin> #src attempt
04:45:08 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
04:45:52 <copumpkin> , attempt (head [])
04:45:53 <lunabot>  Nothing
04:46:02 <zygoloid> fracture: you could decompose your function into a recursive part and an outer wrapper (this is called the worker-wrapper idiom)
04:46:47 <fracture> zygoloid: that might make sense; I'll check it out
04:49:24 <mmorrow> , attempt (fix error)
04:49:26 <lunabot>  Nothing
04:50:47 <copumpkin> mmorrow: what was the definition for that function again? do you mind if I cabal it up and throw it on hackage?
04:51:09 <copumpkin> I guess attempt is a better name than try, as it doesn't conflict
04:51:52 <mmorrow> copumpkin: go for it
04:52:25 <mmorrow> copumpkin: actually i think there might be a package called `attempt' or similar on hackage (i'm not sure it's related though)
04:52:35 * mmorrow looks up that def
04:53:07 <mmorrow> attempt a = unsafePerformIO (catchAll (Just <$> (return $! a)) (return . const Nothing))
04:53:17 <mmorrow> catchAll :: IO a -> (SomeException -> IO a) -> IO a; catchAll = catch
04:53:54 * mmorrow tries to think of decent synonyms for "try"..
04:53:57 <copumpkin> mmorrow: attempt on hackage seems much more complicated
04:54:00 <EnglishGent> attempt
04:54:07 <copumpkin> :P
04:54:31 <mmorrow> yeah, looking at the haddocks now..
04:54:52 <mmorrow> it doesn't appear to do the same thing though
04:54:57 <copumpkin> yeah
04:55:11 <copumpkin> cabal install thereisnotry
04:55:13 <mmorrow> (actually, i'm not really sure *what* it does do exactly)
04:55:27 <mmorrow> copumpkin: spoon!
04:55:40 <copumpkin> that works :P
04:55:41 <jmcarthur_work> we need donot blocks
04:55:44 <copumpkin> Control.Spoon
04:55:45 <mmorrow> doesn't lambdabot have a theasaurus?
04:55:49 <mmorrow> copumpkin: hah
04:55:52 <copumpkin> spoon :: a -> Maybe a
04:56:05 <mmorrow> sounds good to me
04:56:09 <jmcarthur_work> sounds kinky
04:56:23 <copumpkin> mmorrow: do you want to put it up or shall I?
04:56:34 <jmcarthur_work> if one interprets "spoon" as a verb
04:56:48 <copumpkin> jmcarthur_work: that's half the fun
04:56:59 <mmorrow> copumpkin: go for it, it was your idea to begin with
04:57:01 <stepcut>  jmcarthur_work: http://hackage.haskell.org/package/acme-dont ?
04:57:08 <copumpkin> but you implemented it! :P
04:57:13 <copumpkin> but I'll do it, :D
04:57:30 <mmorrow> copumpkin: it took me many moons to come up with that brain-busting one-line def too..
04:57:59 * jmcarthur_work is scared by the existence of a such a function
04:58:03 <mmorrow> this reminds me of that `paths' function
04:58:18 <mmorrow> it took me a few months to figure out what "all paths" should mean
04:58:19 <Saizan> copumpkin, mmorrow: isn't there a library to catch bottoms already?
04:58:26 <mmorrow> and once i did, the code to do it was trivial
04:58:27 <copumpkin> Saizan: is there?
04:58:29 <jmcarthur_work> attempt ⊥ = Nothing ... wtf
04:58:38 <mmorrow> Saizan: i'm not sure
04:58:44 <copumpkin> Saizan: I know there's an isBottom in quickcheck
04:58:47 <copumpkin> but that's the only one I've encountered
04:58:58 <Saizan> http://hackage.haskell.org/package/ChasingBottoms
04:58:59 <copumpkin> the main purpose is for Data.Binary and other libraries that use error where none belongs
04:59:07 <jmcarthur_work> @hoogle isBottom
04:59:07 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
04:59:09 <copumpkin> that's too complicated
04:59:11 <mmorrow> copumpkin: i think a package with this single function and no additional noise is worthwhile myself
04:59:23 <copumpkin> yeah, just install spoon and use spoon :: a -> Maybe a
04:59:24 <copumpkin> :P
04:59:29 <mmorrow> haha
05:00:01 <jmcarthur_work> well, you won't catch me spooning in any of my software any time soon
05:00:42 <mmorrow> that's because spoon will catch it for you!
05:00:52 <mmorrow> ;)
05:01:18 <copumpkin> jmcarthur_work: what will you do if you need to read possibly malformed binary data?
05:01:20 <copumpkin> spoon it!
05:01:21 <jmcarthur_work> catching bottoms is for male cheerleaders
05:02:13 <mmorrow> jmcarthur_work: imo there are two kinds of worthwhile packages on hackage. the first kind being ones whose code you might use in a project, and the second kind being ones whose *ideas* you might use in a project.
05:02:20 <jmcarthur_work> copumpkin, or patch the binary package
05:02:20 <Saizan> i'd avoid catching asynchronous exceptions in a spoon though
05:02:41 <mmorrow> and the second kind are necessarily short and sweet, just enough code to illustrate the idea fully, annd no more
05:02:41 <jmcarthur_work> mmorrow, i am not arguing against putting the package up
05:02:43 <copumpkin> jmcarthur_work: there are other packages that throw errors rather than do things in Maybe
05:03:14 <mmorrow> jmcarthur_work: i'm saying that just because you won't use that "spoon" function verbatim in a project, you may use that idea.
05:03:29 <jmcarthur_work> i would use spoon if i had to. i would just do it kicking and screaming :P
05:10:39 <godfreyhk> can someone explain what does (f .) . g means?
05:11:13 <godfreyhk> and, how to show that it is equivalent to f . g?
05:11:19 <sw17ch> :t (f .) . g
05:11:21 <PeakerWork> godfreyhk: its not equivalent to f . g
05:11:21 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, SimpleReflect.FromExpr (f1 (f a)), Functor f1) => f1 (f b)
05:11:28 <sw17ch> D:
05:11:31 <copumpkin> if g takes two arguments
05:11:34 <copumpkin> and f takes one
05:11:45 <copumpkin> it applies g to both arguments and then applies f to the result
05:11:46 <Saizan> godfreyhk: (f .) . g = \x -> (f .) (g x) = \x -> f . g x = \x -> \y -> f (g x y)
05:12:07 <PeakerWork> alternatively: ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
05:12:29 <copumpkin> oh, I forgot that the tar on mac os makes bad packages for hackage
05:12:38 <copumpkin> does anyone have special flags they pass to it?
05:12:59 <Saizan> use cabal sdist
05:13:08 <copumpkin> oh
05:13:24 <copumpkin> perfect, thanks
05:14:34 <copumpkin> I should probably put some haddock on it first
05:14:47 <copumpkin> meh, that'll be version 0.2
05:16:08 <dbpatterson> I'm writing a program to parse a BIG file (I've been demos of size 1G and 10G, but the final file is more in the realm of 2TB), using lazy bytestrings, and I was wondering if there are any resources of how to code so that the garbage collector will get clean up properly (I don't need more than a couple of megabytes accessible at any time, but right now my operating system is killing it because it runs out of memory)
05:16:12 <Cale> Does anyone with a wordpress blog have any suggestions for what to do about syntax highlighting Haskell code?
05:16:18 <jmcarthur_work> @unpl (f .) . g
05:16:19 <lambdabot> (\ d i -> f (g d i))
05:16:31 * hackagebot upload: spoon 0.1 - Catch errors thrown from pure computations. (DanielPeebles)
05:16:45 <dibblego> Cale, yes, I use a plugin whose name I forget then you use <pre lang="Haskell"
05:16:50 <godfreyhk> thanks guys. I'll try to think through this again
05:16:55 <dbpatterson> Cale: there is a javscript syntax highlighter I think
05:17:11 <stroan> Cale: http://heisencoder.net/2009/01/adding-syntax-highlighting-to-blogger.html
05:17:11 <xternal> wp-syntax, I think it is
05:17:15 <xternal> I have one, checking it now
05:17:21 <stroan> that works very nicely, and will work for wp
05:17:27 <copumpkin> anyone wanna try spoon?
05:19:12 <copumpkin> @hackage spoon
05:19:13 <lambdabot> http://hackage.haskell.org/package/spoon
05:19:59 <xternal> cale: http://wordpress.org/extend/plugins/wp-syntax/
05:20:03 <roconnor> @quote maiden
05:20:04 <lambdabot> No quotes match.
05:20:12 <burp> no haddock yet :|
05:20:20 <copumpkin> burp: one function, called spoon
05:20:35 <copumpkin> burp: pretty simple interface :)
05:20:43 <roconnor> @quote spoon
05:20:43 <lambdabot> simonpj says: If you put a spoonful of sewage into a vat of wine, what do you have? A vat of sewage.
05:20:45 <copumpkin> spoon (head []) ==> Nothing
05:20:51 <copumpkin> spoon (head [1]) ==> Just 1
05:20:52 <burp> oh, nice
05:21:00 <burp> sounds useful
05:21:21 <roconnor> copumpkin: that sounds illegal
05:21:30 <burp> control.exception doesn't have such a thing?
05:21:38 <copumpkin> roconnor: it's to compensate for questionable design decisions in libraries
05:21:43 <copumpkin> burp: nothing that simple
05:21:43 <lament> why would you keep vine in vats anyway
05:21:53 <Cale> xternal: thanks, I'm going to try it
05:22:04 <Cale> (and thanks to others as well :)
05:22:17 <xternal> I checked the parser btw, it does support haskell
05:22:33 <roconnor> copumpkin: by adding non-monotinic functions?
05:22:43 <roconnor> how does fix interact with spoon?
05:22:45 <copumpkin> roconnor: pretty much
05:23:04 <godfreyhk> hmm. so..  I have this:   all' = (and .) . map
05:23:30 <godfreyhk> if I want to do all' p, does that mean (and .) . (map p) ?
05:23:41 <copumpkin> roconnor: otherwise, if you want to use Data.Binary.decode on data you have no control over, your program will just quit if you have malformed input
05:24:20 <roconnor> @hoggle decode
05:24:21 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
05:24:21 <lambdabot> Network.CGI.Protocol decodeInput :: [(String, String)] -> ByteString -> ([(String, Input)], ByteString)
05:24:21 <lambdabot> Network.CGI formDecode :: String -> [(String, String)]
05:24:21 <scalaLove> u guys use the list comprehension form?
05:24:34 <roconnor> @type Data.Binary.decode
05:24:35 <lambdabot> forall a. (Data.Binary.Binary a) => BSLC.ByteString -> a
05:25:30 <ray> how... questionable
05:25:30 <PeakerWork> scalaLove: I try to prefer map/filter/etc but sometimes use it
05:26:01 <copumpkin> roconnor: you can say that it's an error to call head on an empty list and that you should check null first, but it can be a lot cleaner to try and deal with it in Maybe
05:26:11 <roconnor> copumpkin: I'm pretty sure that fixing Data Binary is the correct course of action here.
05:26:18 <scalaLove> PeakerWork, thanks, i find them better too
05:26:28 <roconnor> copumpkin: rather than adding horrible horrible functions.
05:26:37 <copumpkin> roconnor: yes, and in an ideal world no library would call error except in absolutely essential situations
05:26:39 <PeakerWork> scalaLove: Not everything a list comp does is easy with map/filter though.. if I need a lambda, I'll switch to list comp
05:26:53 <copumpkin> roconnor: but you can't fix all libraries and if you need stuff now, you work around it
05:26:57 <roconnor> it's not like the source for Data.Binary isn't available.
05:26:59 <ray> copumpkin writes the functions that haskell deserves
05:27:04 <roconnor> copumpkin: no no
05:27:05 <jmcarthur_work> :t listToMaybe
05:27:06 <lambdabot> forall a. [a] -> Maybe a
05:27:07 <PeakerWork> copumpkin: I'm all for the supposed "awkwardness" of putting everything (including division) in a Maybe
05:27:16 <copumpkin> PeakerWork: me too
05:27:20 <jmcarthur_work> me three
05:27:25 <roconnor> copumpkin: working around things just makes things worse
05:27:47 <copumpkin> roconnor: well, things aren't getting any better for Data.Binary
05:27:54 <copumpkin> and I'm sure there are other packages out there that do this
05:28:03 <copumpkin> if you want to pester the authors to fix it, go ahead :P
05:28:12 <roconnor> don't pester the authors
05:28:12 <copumpkin> in the mean time, spoon seems decent
05:28:20 <roconnor> just patch Data.Binary
05:28:22 <PeakerWork> fromJust could be an inexhaustive function, but head/etc I'd want to return a Maybe
05:28:25 <roconnor> and upload to hackage.
05:28:27 <roconnor> problem solved
05:28:36 <copumpkin> roconnor: I don't feel like it
05:28:56 <copumpkin> it's a complicated package and it'd mean an API change
05:29:00 <copumpkin> which would break stuff
05:29:05 <copumpkin> or a redundant function
05:29:05 <ray> peakerwork: that's just what copumpkin did, but backwards!
05:29:27 <copumpkin> #ty attempt . fromJust
05:29:28 <roconnor> copumpkin: what do you mean by redudent function?
05:29:29 <lunabot>  forall a . Maybe a -> Maybe a
05:29:32 <mreh> newtype Foo3 = Foo3 Int -- can I use a value of type Foo3 in the place of any Int?
05:29:41 <copumpkin> roconnor: either make a decodeMaybe :: ByteString -> Maybe a
05:29:47 <copumpkin> and leave decode :: ByteString -> a in place
05:29:50 <copumpkin> to not break the API
05:30:01 <roconnor> copumpkin: make a decodeMaybe
05:30:05 <copumpkin> roconnor: you do it :P
05:30:10 <copumpkin> you're the one who has a problem with my approach
05:30:27 <jmcarthur_work> decodeMaybe = attempt . decode
05:30:30 <jmcarthur_work> done!
05:30:42 <roconnor> jmcarthur_work: attempt isn't a pure function.
05:30:52 <roconnor> and wil probalby break everything
05:31:02 <jmcarthur_work> #ty attempt
05:31:04 <copumpkin> the basic point is that even though Binary is open source, not all libraries will always be, and you don't always have the time to go figure out the code and what will break by "fixin" it
05:31:05 <lunabot>  forall a . a -> Maybe a
05:31:13 <copumpkin> yet sometimes you just need to Get Shit Done :P
05:31:19 <copumpkin> Spoon is for those situations
05:31:28 <jmcarthur_work> roconnor, i was joking about how to modify binary
05:31:45 <copumpkin> if you have something which uses error like Nothing, it's not breaking referential transparency to put it in Maybe
05:31:47 <roconnor> copumpkin: by Get Shit Done you mean make things worse for yourself later.
05:31:51 <copumpkin> roconnor: not at all
05:31:56 <copumpkin> head uses error like Nothing
05:32:17 <jmcarthur_work> head is different because you can choose not to use it
05:32:22 <copumpkin> yeah
05:32:25 <jmcarthur_work> (not that i'm happy with the way head is)
05:32:31 <copumpkin> decode uses error like Nothing
05:32:37 <PeakerWork> @src guard
05:32:37 <lambdabot> guard True  =  return ()
05:32:37 <lambdabot> guard False =  mzero
05:32:41 <PeakerWork> scalaLove: ^^
05:33:12 <scalaLove> cool
05:33:19 <PeakerWork> scalaLove: mzero of lists is []
05:33:19 <ray> just put unsafeCoerce before everything and let god sort 'em out
05:33:31 <copumpkin> ray: come on, it's nothing like that :P
05:33:43 <PeakerWork> scalaLove: and in the list monad, if you bind to [] anywhere, the whole result is []
05:33:52 <ray> unsafeCoerce it :: VeryMuchLikeThat
05:34:11 <copumpkin> "Takes an error-throwing expression and puts it back in the Maybe it belongs in."
05:34:38 <roconnor> copumpkin: does it only catch uses of (error "foo") ?
05:34:52 <copumpkin> roconnor: nope
05:34:56 <roconnor> :(
05:34:58 <copumpkin> it'll catch an exception
05:35:03 <mmorrow> roconnor: it depends on the catch function you use
05:35:08 <copumpkin> what particular situations are you worried about?
05:35:09 <roconnor> copumpkin: so it will catch the loop exception?
05:35:17 <mmorrow> you can catch whatever subset of exceptions you want
05:36:14 <mmorrow> copumpkin: yeah, it may be useful to parameterize it by the catch function
05:36:16 <copumpkin> if a pure function is throwing exceptions then you can stick it in a Maybe
05:36:30 <mmorrow> how the frig do you spell "parameterize", xchat gives me a red underline for that..
05:36:34 <cnwdup> @pl (\a b -> a `mod` b == 0)
05:36:35 <lambdabot> flip flip 0 . ((==) .) . mod
05:36:37 <copumpkin> the point of this was to be simple though
05:36:41 <copumpkin> there's a more complicated package out there already
05:37:10 <mmorrow> ah, looks like that's just not in xchats word list..
05:37:13 <PhilRod> mmorrow: it probably wants "parametrize"
05:37:22 <PhilRod> but I've seen both spellings used
05:37:28 <mmorrow> Philippa: aha, you're right
05:37:42 <copumpkin> damn common prefixes
05:37:53 <copumpkin> everyone on IRC should strive to use nicks with unique prefixes
05:37:59 <mmorrow> heh
05:38:15 <roconnor> selfdelimiting IRC nicks?
05:38:22 <roconnor> or is that different
05:38:49 <copumpkin> IRC coding
05:39:55 <copumpkin> roconnor: so are there situations where this breaks referential transparency, since a pure function can only throw errors in a referentially transparent manner in the first place?
05:40:14 <mreh> so how could I combine the state and list monads?
05:40:21 <mreh> using StateT?
05:40:39 <Berengal> Or ListT
05:40:44 <mreh> hmmm
05:41:01 <mreh> this is confusing stuff
05:41:22 <_Jedai_> mreh: depends on what you want to do
05:41:25 <Berengal> @unmtl ListT State s a
05:41:26 <lambdabot> [s] -> (a, [s])
05:41:34 <Berengal> @unmtl StateT s ListT a
05:41:35 <lambdabot> err: `ListT (a, s)' is not applied to enough arguments.
05:41:48 <mmorrow> @unmtl StateT s [] a
05:41:49 <lambdabot> s -> [(a, s)]
05:41:50 <Berengal> @unmtl StateT s [a]
05:41:50 <aavogt> mtl doesn't have listT
05:41:50 <lambdabot> err: `StateT s [a]' is not applied to enough arguments, giving `/\A. s -> [a] (A, s)'
05:42:03 <Berengal> Right...
05:42:07 <roconnor> copumpkin: do you think (error "spoon") and (fix id) are the same?
05:42:14 <aavogt> @unmtl StateT s [] a
05:42:14 <lambdabot> s -> [(a, s)]
05:42:30 <copumpkin> roconnor: not really
05:42:43 <Nafai> bos: Snow in SF?  Where?
05:43:01 <bos> Nafai: here in the financial district, at least
05:43:01 <aavogt> I think that's because list makes more sense as the base monad
05:43:04 <copumpkin> roconnor: I think our notion of function can be a little narrow sometimes
05:43:18 <mmorrow> roconnor: depends on your catch function, since it's what makes that decision
05:43:47 <aavogt> at least I want state per-nondeterministic choice, rather than one state common to all of them
05:43:48 <copumpkin> we could just catch ErrorCall and PatternMatchFail
05:43:50 * Berengal tries to figure out how [s] -> (a, [s]) makes sense...
05:44:48 <mmorrow> @unmtl ListT (State s) a
05:44:48 <Berengal> Given a list of states, it produces a value and a list of states...
05:44:49 <lambdabot> s -> ([a], s)
05:44:57 <Berengal> Oh, right...
05:44:58 <mmorrow> @unmtl StateT s [] a
05:44:59 <lambdabot> s -> [(a, s)]
05:45:03 <aavogt> @unmtl ListT (Reader r) a
05:45:03 <fracture> there's no integer-mod-N arithmetic type in haskell, is there?
05:45:03 <lambdabot> r -> [a]
05:45:13 <roconnor> mmorrow: catch only happens in IO.
05:45:14 <fracture> (for arbitrary N, not 2^32, etc)
05:45:30 <mmorrow> roconnor: or in spoon
05:45:46 <Berengal> fracture: Take a look at hackage. I think I remember seeing a library there, but I can't say for sure.
05:45:58 <aavogt> hmm, but Reader and List commute as monads
05:46:11 <PeakerWork> Reader commutes with everything, doesn't it?
05:46:11 <mmorrow> @unmtl ReaderT r [] a
05:46:12 <lambdabot> r -> [a]
05:46:21 <fracture> Berengal: if it's not part of the normal distro I probably am not going to use it anyway
05:46:37 <Berengal> fracture: Don't think there is.
05:46:40 <fracture> k
05:46:46 <mmorrow> @unmtl ContT o (Reader s) a
05:46:47 <lambdabot> (a -> s -> o) -> s -> o
05:46:56 <mmorrow> @unmtl StateT s (Cont o) a
05:46:57 <lambdabot> s -> (a -> s -> o) -> o
05:47:09 <mmorrow> @unmtl ReaderT s (Cont o) a
05:47:10 <lambdabot> s -> (a -> o) -> o
05:47:20 <Nafai> bos: Any fun Haskell/FP things going on in SF in the next 2 weeks?  I'm here visiting and it would be fun to hang out with Haskell'ers
05:47:52 <bos> Nafai: nothing that i know of
05:47:59 <mmorrow> the nontrivial equivalence between "ContT o (Reader s) a" and "StateT s (Cont o) a" is interesting
05:48:16 <copumpkin> it is
05:48:27 <mmorrow> local becomes modify when you never leave local!
05:49:09 <PeakerWork> ;)
05:49:13 <Ferdirand> this sounds really interesting, although i can't wrap my mind around it
05:49:13 <aavogt> oh, and with the ContT, you can jump out of the local?
05:49:15 <scalaLove> The left associative fold is tail-recursive, that is, it recurses immediately, calling itself. For this reason the compiler will optimise it to a simple loop, and it will then be much more efficient than foldr. ------------------- I supose you guys use this?
05:49:16 <PeakerWork> The mind bends never cease :)
05:50:09 <jmcarthur_work> Cont is weird
05:51:11 <roconnor> scalaLove: not at all
05:51:36 <fracture> hm..  I have an object and a function, and an integer N, and I want to apply the function N times (to its own return value on the object), and if N = 0 I just want id
05:51:42 <fracture> anyone have an idea how to do that?
05:51:58 <aavogt> @type iterate
05:51:59 <lambdabot> forall a. (a -> a) -> a -> [a]
05:52:04 <roconnor> scalaLove: we almost always use foldr because the recursive call is usually delayed by laziness until the first item in the list is garbage collected.
05:52:11 <roconnor> scalaLove: thus working in constant memory.
05:52:18 <dibblego> @type \n -> take n . iterate
05:52:20 <lambdabot>     Couldn't match expected type `[a]'
05:52:20 <fracture> aavogt: looked at that (with take) already, but it doesn't really apply for the case N = 0, eh?
05:52:20 <lambdabot>            against inferred type `a1 -> [a1]'
05:52:20 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
05:52:35 <Cale> Does anyone have a nice haskell.php for Geshi so I don't have to update this ugly one by hand? :)
05:53:00 <aavogt> fracture: the index of the resulting list contains the element with your function applied that many times
05:53:15 <aavogt> > iterate (*2) 1 !! 10
05:53:16 <lambdabot>   1024
05:53:31 <fracture> ah I see, thanks
05:54:56 <felix^^> hi all :) is there a way to use pattern guards in a case statement?
05:55:07 <aavogt> felix^^: it works as you would expect
05:55:43 <aavogt> except you might be trained to put = after the guard, when you need to put -> as case statements need
05:55:49 <scalaLove> roconnor: foldl does not work with laziness so I know... but why i do not understand... for me foldr is logcial to work with laziness, for example : [1(2(3(4(5))))], you see in iterator numbers go left to right, starting from left, so how can right fold work with laziness when you dont even know the right side in example like this... ???
05:56:10 <Botje> scalaLove: foldr can be lazy in what it returns
05:56:17 <Botje> scalaLove: a trivial example of this is foldr (:) []
05:56:20 <felix^^> aavogt: that was it -- thanks a lot!
05:56:28 <Botje> scalaLove: if you only use the first element, foldr doesn't have to walk the rest of the list.
05:56:34 <jmcarthur_work> > foldr (:) [] [a,b,c,d,e]
05:56:35 <lambdabot>   [a,b,c,d,e]
05:56:45 <jmcarthur_work> > foldr (:) [] [1..]
05:56:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:56:55 <aavogt> felix^^: that style doesn't seem to be common, but I find it pretty useful
05:57:14 <mmorrow> , foldr f z [0..4]
05:57:16 <lunabot>  f 0 (f 1 (f 2 (f 3 (f 4 z))))
05:57:20 <mmorrow> , foldl f z [0..4]
05:57:22 <lunabot>  f (f (f (f (f z 0) 1) 2) 3) 4
05:57:40 <scalaLove> Botje: can u try noobish explanation for a noob like me please?
05:58:05 <Botje> scalaLove: actually, that was pretty much it :)
05:58:14 <mmorrow> f       0        (f 1 (f 2 (f 3 (f 4 z))))
05:58:19 <mmorrow> vs
05:58:22 <jmcarthur_work> @src foldr
05:58:23 <lambdabot> foldr f z []     = z
05:58:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:58:37 <mmorrow> f (f (f (f (    f z 0         ) 1) 2) 3) 4
05:58:39 <scalaLove> it is counterintuitive to me foldl not to work with infinite lists, and foldr to work...
05:59:13 <scalaLove> when u go from 1 for example to infinity you go left to right, so foldl seems intuitive
05:59:16 <jmcarthur_work> scalaLove, if you look at each application of the function it looks like this: x `f` blahblahblah
05:59:35 <jmcarthur_work> scalaLove, let's say f is (:)
05:59:46 <mmorrow> scalaLove: remember that haskell is lazy
05:59:53 <jmcarthur_work> scalaLove, so we would have x:blah
06:00:00 <jmcarthur_work> scalaLove, if you take the head of that list, you get x
06:00:02 <scalaLove> mmorrow i know it is lazy
06:00:12 <jmcarthur_work> scalaLove, and blah is not evaluated, no matter how large it is, even infinite
06:00:15 <mmorrow> foldr gives the function (1) the first item in the list, (2) a frozen application of foldr to the rest of the list
06:00:17 <PeakerWork> scalaLove: foldr (*) 1 [1,2,3,4] = 1 * (2 * (3 * (4 * 1)))   ;   foldl (*) 1 [1,2,3,4] = (((1 * 1) * 2) * 3) * 4)  -- notice the outer-most * requires the result of foldl on the whole rest of the list, and the last element of the list! so for the first * we encounter (the outer-most) we need to go through the full list
06:00:43 <Ferdirand> @src foldl
06:00:43 <lambdabot> foldl f z []     = z
06:00:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:01:00 <mmorrow> scalaLove: right of course, but knowing and fully appreciating the implications are different
06:01:04 <roconnor> why does runhaskell Setup.hs configure require gcc?
06:01:07 <Ferdirand> you cannot escape foldl other than trough the [] clause
06:01:20 <scalaLove> jmcarthur_work, exactly, isnt that foldl? i mean left, it ignores tail and tail is right
06:01:55 <mmorrow> scalaLove: so with foldl, you can't get any answer until you've traversed the entire list
06:02:24 <mmorrow> scalaLove: with foldr, you get handed the first item of the list, and a frozen application of foldr to the rest of it
06:03:14 <mmorrow> if you discard this frozen application of foldr to the rest of the list, the computation is over
06:03:16 <PeakerWork> scalaLove: the "left" means "left-assocative" -- see which side the () stick to in the above example
06:04:17 <Berengal> scalaLove: If you squint a bit, lists are already folded right. Take for example the list 'x : (y : (z : []))'. For a function (>) and a base value 0, foldr (>) 0 of that lists becomes 'x > (y > (z > 0))'
06:04:37 <jmcarthur_work> scalaLove, the associativity isn't evaluation order. it's just "grouping." if you group the tail off to the side as one big chunk it might mean you don't have to evaluate it
06:04:52 <Berengal> With the function (:) and the base value [], you get back the same list
06:05:10 <roconnor> dcoutts: why does runHaskell Setup configure require gcc?
06:05:22 <scalaLove> oh oh oh got it got it guys, thank you
06:05:38 <Berengal> Now, if you flip the (>) function and reverse the list, then take the left fold, you get '((0 < z) < x) < y'
06:06:26 <mmorrow> roconnor: maybe the package you're configuring has -fvia-C in the ghc-options
06:06:37 <mmorrow> roconnor: or has cbits
06:06:41 <roconnor> nope
06:06:54 <roconnor> mmorrow:  http://hackage.haskell.org/packages/archive/spoon/0.1/spoon.cabal
06:06:58 <mmorrow> haha
06:08:04 <Botje> (((pacman < pellet) < pellet) < ghost
06:08:06 <mmorrow> roconnor: how are you determining that it needs gcc? you don't have gcc and it dies with an error message saying this?
06:08:26 <scalaLove> Any time you want to traverse a list and build up a result from its members you want a fold. ---------- if noobs like me are here this would be cool to note, i put it in notes now.
06:08:36 <roconnor> mmorrow: yes
06:08:50 <roconnor> $ runhaskell Setup.hs configure
06:08:51 <roconnor> Configuring spoon-0.1...
06:08:53 <roconnor> Setup.hs: The program gcc is required but it could not be found
06:08:54 <roconnor> Setup.hs: The program gcc is required but it could not be found
06:08:56 <roconnor> Setup.hs: The program gcc is required but it could not be found
06:08:58 <mmorrow> :o
06:09:14 <mmorrow> roconnor: what if you compile Setup.hs first?
06:09:27 <PeakerWork> scalaLove: a "fold" basically recurses on a list for you - you can write your own recursion if you want
06:09:40 <roconnor> mmorrow: You'll have to wait a moment.  I'll need to remove gcc first.
06:09:48 <roconnor> (now that I've installed it)
06:09:58 <mmorrow> roconnor: (also, how can you not have gcc?!)
06:10:02 <mmorrow> hah
06:10:20 <mmorrow> roconnor: don't remove it!
06:10:22 <roconnor> mmorrow: I'm running nixos, so gcc isn't in my personal profile.
06:10:33 <mmorrow> i'm sure it'll prove useful at some point..
06:10:55 <roconnor> mmorrow: I have it on my system, just not in my path
06:11:06 <roconnor> mmorrow: so random programs I download won't run gcc. ...
06:11:09 <mmorrow> roconnor: maybe cabal just always checks for gcc on unix
06:11:24 <roconnor> that's retarded
06:11:43 <mmorrow> roconnor: you could always if you wanted make a shell script called "gcc" that does nothing
06:12:10 <roconnor> how about a shell script called gcc that wipes my hard drive when it is called.
06:12:17 <roconnor> about as safe as gcc :)
06:12:22 <mmorrow> (or that returns the output of "gcc -version" or whatever is needed)
06:12:22 <roconnor> haskell too :(
06:13:02 <mmorrow> roconnor: the point of the fake-gcc "gcc" script is to satisfy your paranoia, not to enable it :)
06:13:54 <mmorrow> roconnor: what if a program calls "rm"!?!
06:14:21 <mmorrow> better make a fake rm script too.. ;)
06:14:28 <roconnor> anyhow, adding a fake gcc is as bad as using spoon to fix problems.
06:14:38 <mmorrow> roconnor: cry me a river! :)
06:14:47 * mmorrow chuckles
06:15:00 <roconnor> @type maybe
06:15:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:15:07 <roconnor> @type fromMaybe
06:15:08 <lambdabot> forall a. a -> Maybe a -> a
06:15:13 <mrd> random question: has anyone a copy of Damas' PhD thesis?
06:16:12 <shambler> @where TAPL
06:16:12 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:16:16 <shambler> @where ATAPL
06:16:18 <lambdabot> I know nothing about atapl.
06:16:37 <shambler> @where ATTPL
06:16:38 <lambdabot> I know nothing about attpl.
06:16:44 <mrd> I know that covers much the same material, but I want to review something in the original
06:24:03 <roconnor> copumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13763#a13763
06:24:19 <roconnor> copumpkin: various outputs of your spoon function depending on optimization levels
06:24:19 <sohum> Veinor: it's just an awesome name. means just as much as "stdlib" while being a far better name
06:24:50 <roconnor> copumpkin: and all three printed lines ought to be idendical by basic reasoning.
06:25:22 <Veinor> sohum: wow, that was the most delayed response
06:26:21 <sohum> Veinor: I did say I was going to sleep
06:26:54 <Veinor> true.
06:27:53 <roconnor> copumpkin: actually, if you do runhaskell foo.hs it will run forever until you hit Ctrl-c then print 0, 0, (a.out: 0)
06:28:10 <roconnor> copumpkin: since ctrl-c is an exception that spoon catches
06:30:07 <roconnor> copumpkin: anyhow, the point is, yes, it breaks referential transparency.
06:30:34 <copumpkin> roconnor: what if I switch to just ErrorCall and the pattern match one?
06:30:44 <c_wraith> I want to parallelize a recursive pure function that calls itself twice.  Is this a horrible idea?
06:30:51 <Veinor> I've done worse. I've been scrolled up in irssi to 24 hours beforehand and replied to someone saying my name.
06:30:56 <Veinor> re: sohum
06:31:34 <roconnor> copumpkin: that could be better
06:31:45 <roconnor> copumpkin: can you paste the source?
06:31:53 <roconnor> I'll edit my Spoon.hs
06:31:56 <copumpkin> spoon a = unsafePerformIO (catchAll (Just `fmap` (return $! a)) (return . const Nothing))
06:32:00 <c_wraith> (this is, of course, because it's horribly long-running, and I'd like to take advantage of the 4 cores I have available)
06:32:16 * copumpkin shudders
06:32:18 <roconnor> copumpkin: I mean the source with catchAll suitably replaced.
06:32:25 <copumpkin> oh
06:32:48 <roconnor> copumpkin: I could actually believe that would be safe ... for some very loose definition of safe.
06:33:06 <sohum> Veinor: hehhe
06:33:07 <copumpkin> so just PatternMatchFail and ErrorCall ?
06:33:11 <roconnor> sure
06:33:45 <copumpkin> roconnor: just a sec then :)
06:34:50 <copumpkin> is there a nice way to specify that you want to catch a combination of things? or must I just nest the catches?
06:35:25 <roconnor> copumpkin: just do ErrorCall for testing purposes
06:35:30 <copumpkin> ok
06:35:55 <roconnor> copumpkin: actually I don't think spoon does what you think it does.
06:36:02 <roconnor> copumpkin: you need a deep seq
06:36:16 <copumpkin> I wasn't expecting it to be deep
06:36:30 <copumpkin> but should it be?
06:36:38 <roconnor> ByteString.decode is lazy isn't it?
06:36:50 <copumpkin> hm, I didn't think so
06:36:52 <copumpkin> but maybe
06:36:56 <roconnor> so it could return a bunch of stuff lazily
06:37:00 <roconnor> and then find an error
06:37:08 <roconnor> and by then it is too late to turn your stuff into nothing.
06:37:14 <copumpkin> yeah, hmm
06:37:21 <roconnor> well, if decode isn't lazy
06:37:26 <roconnor> then there is no problem
06:37:32 <roconnor> I don't see why it wouln't be lazy though.
06:37:44 <c_wraith> let {x1 = f sub1 ; x2 = f sub2} in x1 `par` x2 `seq` g x1 x2
06:37:47 <copumpkin> it claims "Decode a value from a lazy ByteString, reconstructing the original structure."
06:37:54 <c_wraith> is that the correct basic pattern?
06:37:58 <copumpkin> so I guess if they put it on a lazy bytestring, the decode is probably lazy too
06:38:19 <roconnor> copumpkin: try take 5 (encode (decode [1..]))
06:38:27 <paul424> er is therer any gui for linux ?
06:38:33 <roconnor> copumpkin: er, you know what I mean
06:38:36 <roconnor> decode . encode
06:38:42 <ddarius> c_wraith: Use pseq.
06:38:47 <mmorrow> roconnor is right, you'd need to ensure that enough of the result is forced to trigger any error calls that might occur, which in the general case could only be ensured with rnf'ing it
06:38:55 <ddarius> c_wraith: But otherwise, yes.
06:39:00 <c_wraith> ddarius: ok, I'll take a look at it
06:39:06 <mmorrow> spoon :: NFData a => a -> Maybe a
06:39:13 <ddarius> c_wraith: It's just like seq just with different guarantees.
06:39:23 <copumpkin> roconnor: massive memory gobblage
06:39:24 <ddarius> (or rather, stronger guarantees)
06:39:26 <blackh> paul424: http://haskell.org/gtk2hs/
06:39:31 <c_wraith> ddarius: intended for use in parallel computations, specifically?
06:39:32 <roconnor> copumpkin: really?
06:39:34 <copumpkin> roconnor: and no output
06:39:37 <roconnor> wow
06:39:43 <roconnor> that sucks
06:39:43 <ddarius> c_wraith: Sort of.
06:39:53 <mmorrow> copumpkin: the Data.Binary case i think is unfixable without changing how it fundamentally works
06:39:54 <ddarius> @hoogle pseq
06:39:55 <lambdabot> Control.Parallel pseq :: a -> b -> b
06:40:03 <c_wraith> ddarius: is there a tutorial for this somewhere?
06:40:07 <c_wraith> or even a blog post?
06:40:08 <roconnor> copumpkin: still i think rnf is in order here.
06:40:22 <copumpkin> hm, ok
06:40:31 <copumpkin> it does make sense
06:40:38 <ddarius> c_wraith: A few.  The section in RWH.  There's a video of a talk that covers this stuff.  Some blog posts.
06:40:56 <c_wraith> Ah, ok.  thanks.  I'll check out RWH first.
06:40:58 <roconnor> copumpkin: is there an easy way to replace CatchAll with CatchError for quick testing?
06:41:12 <copumpkin> roconnor: yeah, just replace SomeException with ErrorCall
06:41:19 <mmorrow> copumpkin: currently it just catches any exception triggered by forcing it one level
06:41:36 <copumpkin> mmorrow: yep
06:41:41 <copumpkin> so why not force it all the way?
06:41:58 <mmorrow> roconnor: you can inspect the exception in the catch handler function, and optionally rethrow it
06:42:35 <mmorrow> copumpkin: right, i think you'd need to if the intended effect of spoon is to turn any *eventual* error that might occur into Nothing
06:42:43 <copumpkin> mmorrow: yep
06:42:47 <roconnor> copumpkin: okay, with just ErrorCall, I am getting a.out: <<loop>> in all cases.
06:43:00 <copumpkin> roconnor: that's correct, right?
06:43:05 <roconnor> and runhaskell foo.hs runs forever
06:43:10 <mmorrow> otoh if the intended effect is to just give nothing if forcing the top-level results in an error, then seq
06:43:13 <roconnor> and terminates as you expect with ctrl-c
06:43:36 <mmorrow> roconnor: that's because bytecode doesn't ever catch <<loop>>
06:43:38 <roconnor> copumpkin: I hesiate to use the word correct for any of this.  but yes it is corr*ct
06:43:46 <copumpkin> teaspoon :: a -> Maybe a, spoon :: (NFData a) => a -> Maybe a
06:44:03 <copumpkin> :)
06:44:25 <mmorrow> roconnor: and runhaskell runs ghci with System.Process, write the file to a /tmp/something (iirc) and feeds it to ghci
06:44:35 <mmorrow> copumpkin: haha
06:44:52 <roconnor> it's a bit hard to think of when teaspoon is useful
06:44:54 <roconnor> but whatever.
06:45:00 <copumpkin> yeah, I can't really think of a case
06:45:01 <aavogt> @quote two
06:45:01 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
06:45:06 <copumpkin> but it's a cute name if nothing else
06:45:28 <mmorrow> teaspoon catches (head [])
06:45:39 <copumpkin> true
06:45:48 <copumpkin> if you have more defaulting on, spoon will catch it too :P
06:46:00 <roconnor> copumpkin: with catchError and pattern match failure the only things you catch, it will be harder for me to poke holes in what you are doing.
06:46:01 <mmorrow> but yeah, the rnf version is where this would actually become non-trivially useful
06:46:50 <roconnor> copumpkin: what other exceptions can be thrown from pure code?
06:47:06 <mmorrow> @type Control.Exception.throw
06:47:07 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
06:47:11 <mmorrow> any
06:47:18 <copumpkin> ArithException and ArrayException seem like candidates
06:47:31 <zygoloid> ladle :: IO a -> Maybe a? *ducks*
06:47:32 <copumpkin> http://snapplr.com/fg78
06:47:36 <roconnor> ArithExpetion is especially intersting
06:48:23 <copumpkin> I should catch those too, right?
06:48:29 <roconnor> sure
06:48:31 <copumpkin> and probably provide an either interface to find out what's wrong
06:48:41 <roconnor> nooooo
06:48:44 <copumpkin> :P
06:48:44 <copumpkin>  ok
06:48:48 <mmorrow> haha
06:48:54 <zygoloid> either interface would be impure
06:48:57 <roconnor> copumpkin: you are killing me here :D
06:49:09 <zygoloid> (due to inexact exceptions)
06:49:11 <copumpkin> I'm trying to be as delicate as possible :D
06:49:22 <roconnor> copumpkin: I'll let you have your commutative monad, but going to Either is too much :D
06:49:31 <copumpkin> lol
06:49:59 <copumpkin> is it okay to rely on deepseq instead of Control.Parallel.Strategies now?
06:50:13 <roconnor> I don't know the differences between the two
06:50:14 <copumpkin> rnf should've never been in parallel in the first place
06:50:35 <roconnor> is rnf the only one with the class constraint?
06:50:44 <roconnor> what is the signature for deepseq?
06:51:10 <copumpkin> deepseq :: NFData a => a -> b -> b
06:51:12 <Vulpyne> fork :: IO a -> MVar (Maybe a) ; fork a = do { mv <- newEmptyMVar ; forkIO $ ladle a >>= putMVar mv } -- ;)
06:51:14 <copumpkin> just like seq
06:51:22 <copumpkin> but more profound ;)
06:51:55 <roconnor> deepseq doesn't look so bad to me.
06:52:47 <zygoloid> spork :: a -> a -> a -- evaluate both at once, return the first one which was'nt _|_
06:53:21 <roconnor> zygoloid: conal calls that unamb ... sort of
06:53:36 <scalaLove> can someone give me example of scan so i understand the difference between map and fold vs scan
06:53:40 <zygoloid> roconnor: unamb is something else (in particular, nondeterministic)
06:53:41 <Vulpyne> Waiting for the full-table-set on Hackage.
06:53:47 <copumpkin> scalaLove: a scan is like a fold that keeps intermediate steps
06:53:58 <roconnor> zygoloid: how is yours not nondeterministic?
06:54:04 <copumpkin> > (foldr (+) 0 [1..10], scanr (+) 0 [1..10])
06:54:06 <lambdabot>   (55,[55,54,52,49,45,40,34,27,19,10,0])
06:54:11 <scalaLove> yes i know i read that but to see in example i want, so i really get it...
06:54:15 <zygoloid> roconnor: if it can't tell if the first argument is _|_ or not, the result is _|_
06:54:28 <copumpkin> so last . scanr f z == foldr f z
06:54:32 <sohum> :t _|_
06:54:33 <lambdabot> parse error on input `|'
06:54:36 <copumpkin> @free scanr
06:54:38 <lambdabot> (forall x. g . h x = k (f x) . g) => $map g . scanr h y = scanr k (g y) . $map f
06:54:38 <sohum> :t (_|_)
06:54:40 <lambdabot> parse error on input `|'
06:54:42 <roconnor> zygoloid: that's not how I read your spec.
06:54:53 <sohum> it's not valid haskell :(
06:54:54 <zygoloid> roconnor: first as in leftmost
06:55:09 <copumpkin> is there a common idiom for catching multiple exceptions at once? nesting them is getting tedious
06:55:11 <roconnor> zygoloid: I read first as in first to finish evaluating.
06:55:20 <zygoloid> roconnor: well that's not what i meant ;p
06:55:35 <zygoloid> though i can understand the confusion i've caused ;-)
06:56:31 <zygoloid> > let f _|_ <- undefined = "got bottom!" in f (error "Foo!")
06:56:32 <lambdabot>   "got bottom!"
06:57:06 * copumpkin had difficulty even parsing that at first
06:57:11 <zygoloid> see, you can pattern match on _|_, but you have to tell GHC what the symbol means :)
06:57:22 <mmorrow> copumpkin: you can case on the exception in the handler and optionally rethrow
06:57:35 <mmorrow> copumpkin: the unamb package does this
06:57:45 <copumpkin> mmorrow: but the exceptions have different types? seems like it should be a GADT of some sort
06:58:06 <zygoloid> copumpkin: it's an existential iirc
06:58:19 <copumpkin> zygoloid: oh, for SomeException you mean
06:58:24 * zygoloid nods
06:58:53 <mmorrow> copumpkin: ah, looking at the code it has some helper function or something, check out `putCatch' http://hackage.haskell.org/packages/archive/unamb/0.2.2/doc/html/src/Data-Unamb.html
06:59:06 * hackagebot upload: failable-list 0.2 - A list-like type for lazy streams, which might terminate with an error. (JohnMillikin)
06:59:07 <copumpkin> I see
06:59:30 <copumpkin> I see
06:59:31 <mmorrow> haha, good timing for that package..
06:59:55 <paul424> blackh: no man, actually I wanted IDE for haskell under linux
07:00:09 <mmorrow> :o there's a DontBother exception?
07:00:22 <mmorrow> oh n/m, that's define in unamb
07:00:36 <paul424> hmm I thought about emacs but it's poorly supported
07:01:05 <copumpkin> :P
07:01:17 <copumpkin> BothBottom
07:01:35 <blackh> paul424: Oh! :)
07:01:39 <zygoloid> BothCheeks would have been a better name
07:02:29 <sohum> paul424: ...what on earth do you mean poorly supported?
07:02:54 <cnwdup> @hoogle (a -> b -> a) -> [a] -> [a]
07:02:55 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
07:02:55 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
07:02:55 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
07:02:58 <kynky> thoufgt haskell-mode for emacs was pretty good , there is eclipsefp for ide stuff in eclipse , also leksah might be a consideration
07:03:04 <paul424> no normal person can install it.
07:03:07 <cnwdup> @hoogle (a -> b -> a) -> [b] -> [a]
07:03:09 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
07:03:09 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
07:03:09 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
07:03:20 <elly> er... but you are writing Haskell
07:03:32 <elly> if you can't install emacs, I'm not sure you should be?
07:03:43 <PeakerWork> how does leksah compare to yi?
07:03:51 <Vulpyne> cd /usr/ports/editors/emacs && make install? :)
07:04:05 <mauke> emerge emacs
07:04:06 <sohum> paul424: emacs is pretty trivial to install, and haskell-mode requires a bit more work if you want the latest but it's still pretty trivial
07:04:08 <elly> apt-get install emacs || emerge emacs || yum install emacs || ...
07:04:36 <roconnor> nix-env -i emacs
07:04:45 <paul424> elly: yes, but I meant configuring the mode.
07:04:49 <elly> nix-env? haven't heard that one
07:04:59 <Vulpyne> nix is the functional distro, isn't it?
07:05:09 <sohum> paul424: haven't really needed to. plus, M-x customize-group is awesome.
07:05:27 <scalaLove> why does not this work:  all (_==4) [1..20] and this works  all (==4) [1..20] ??? Isnt the _ replacement for anything? without it is very counterintuitive
07:05:44 <Botje> scalaLove: no, _ *matches* anything
07:05:51 <mauke> scalaLove: your intuition is broken
07:05:57 <bd_> scalaLove: _ is only used for pattern matching. (  _ == 4) isn't a pattern match, it's an expression
07:05:57 <inclement> scalaLove: _ replaces anything in pattern matching. You aren't matching a pattern, you're applying a function
07:06:02 <Botje> haskell does not have the cut macros lisp has
07:06:32 <PeakerWork> scalaLove: _ is a valid match-all-and-ignore *pattern*.  (==4) is not a pattern, and neither is (_==4).   _ is not a "place-holder" for arguments. You could use: (\x -> x==4)
07:06:37 <roconnor> mmorrow: compiling Setup.hs first doesn't help.  I still have gcc could not be found errors.
07:06:40 <scalaLove> of course it is pattern match, it matches the empty space with numbers from 1 to 20 right?
07:06:56 <inclement> No, that isn't pattern matching
07:07:01 <scalaLove> it has to pattern match them, imagine i gave strings in the list and not ints from 1 to 20
07:07:02 <inclement> It's just a different potential use of the word 'matching'
07:07:14 <mauke> scalaLove: why does it have to?
07:07:20 <Vulpyne> scalaLove: You'd get a type error if you gave that a list of strings.
07:07:21 <PeakerWork> scalaLove: Pattern matching is what you have on the LHS of = or between \ and -> (not of ==)
07:08:05 <scalaLove> Vulpyne: u see? to get a type error something first has to be pattern matched and checked
07:08:16 <mauke> scalaLove: no
07:08:17 <Vulpyne> scalaLove: (==4) is a section. In the simplest explanation, if you apply a function that expects a certain number of arguments to less arguments, you get back a function that accepts the remaining arguments.
07:08:27 <PeakerWork> scalaLove:  f (pattern) = ... ; f = \(pattern) -> ... ; do { (pattern) <- ... } ; case <expr> of (pattern) -> ...   anything else is not a pattern (unless I forgot some)
07:08:48 <Vulpyne> scalaLove: So you could do: let addFour = (+4) in addFour 2 -- Result is 6
07:10:14 <copumpkin> hmm, I'm confusing myself here
07:10:16 <PeakerWork> Or let addFor = (+) 4 in addFour 2 -- same thing
07:10:16 <scalaLove> wow confusing... ok nevermind i will keep reading and note this for later... thank you guys at least i get intro into what am i dealing with here
07:12:46 <Vulpyne> scalaLove: Get used to Haskell rearranging your thinking. :)
07:13:22 <scalaLove> Vulpyne I dont worry about that, I am just happy I got into haskell at age 21 and not at 30 :D
07:13:38 <mmorrow> roconnor: yeah, must be cabal
07:14:06 <Vulpyne> Hey now, I'm 30!
07:14:19 <roconnor> Vulpyne: sorry
07:14:29 <roconnor> :P
07:14:34 <Vulpyne> :)
07:14:52 <roconnor> copumpkin: what is confusing?
07:15:00 <roconnor> oh, exception handeling
07:15:02 <roconnor> :)
07:15:17 <copumpkin> roconnor: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13767#a13767 seems like it should work
07:15:31 <copumpkin> however, Prelude Control.Spoon> spoon (head [] :: [Int])
07:15:31 <copumpkin> Just *** Exception: Prelude.head: empty list
07:15:43 <copumpkin> I haven't dealt with exceptions much though
07:15:48 <copumpkin> most of my code is 100% pure :P
07:15:52 <scalaLove> Vulpyne haha :D I meant I am happy i got into it now, and not later, it is changing me as programmer fundemantaly
07:16:13 <copumpkin> scalaLove: I wish I had done it earlier :(
07:16:17 <Vulpyne> scalaLove: Don't worry about it, just giving you a hard time. :)
07:16:18 <aavogt> I believe that most people are over 30
07:16:25 <aavogt> if that's any consolation
07:16:26 <chrisdone> in the world?
07:16:30 <aavogt> yes
07:16:34 <copumpkin> that is so deep
07:17:03 <aavogt> chrisdone: you have some actual statistics to disagree? ;)
07:17:14 <Vulpyne> I wish I'd started too. I've been messing with it for 5-6 years, only been able to use it seriously at work for the last year though.
07:17:18 <mmorrow> copumpkin: maybe to debug, print out the exception in the handler
07:17:29 <mmorrow> regardless of whether you rethrow it or not
07:17:31 <copumpkin> http://en.wikipedia.org/wiki/Population_pyramid
07:17:44 <copumpkin> mmorrow: hmm, okay :) does the basic idea seem reasonable though?
07:17:46 <roconnor> copumpkin: shouldn't (depseq a) be pulled out above the Just ?
07:18:07 <copumpkin> oh, maybe
07:18:36 <copumpkin> yay
07:18:39 <copumpkin> roconnor saves the day
07:18:50 <mmorrow> heh
07:18:52 * roconnor shouldn't be enabling copumpkin
07:18:55 <copumpkin> lol
07:19:00 <copumpkin> my evil ways are being encouraged
07:19:32 <roconnor> mmorrow: is throwIO x the right way of passing on the exception?
07:19:38 * copumpkin is young, innocent, and impressionable! he is being pressed into evil
07:19:57 <chrisdone> anyone else suffer from severe envy of the demoscene video programmers?
07:20:06 <roconnor> chrisdone: nope
07:20:30 <mmorrow> roconnor: hmm, i'd assume that throwIO is basically equivalent to (return . throw)
07:20:41 <mmorrow> (if not exactly so)
07:21:00 <copumpkin> throwIO e = IO (raiseIO# (toException e))
07:21:13 <mmorrow> oh right, and there's a raise# too
07:21:53 <roconnor> I don't know enough about exceptions to know if the rethrowing code is correct or not.
07:22:01 <mmorrow> (raise# could actually be used to create something really interesting, since it lets you throw *anything*, and if you mess up with what type it is in the catch# you segfault)
07:22:03 <chrisdone> aavogt: parently as of 2000 the median age is 26.8
07:22:06 <roconnor> nor do I know enough about unsafePerformIO
07:22:35 <mmorrow> so essentially if you had a mechanism like Typeable, you could implement you own throwDyn/catchDyn
07:22:40 <mmorrow> (via raise#)
07:24:07 <mmorrow> (but of course if your Typeable-like mechanism gives you nothing above Typeable, there'd be no point..)
07:24:23 <roconnor> mmorrow: is there an nfEvaluation IO function?
07:24:35 <roconnor> mmorrow: that would be more approriate than deepseq here.
07:24:47 <aavogt> chrisdone: I guess I'll just have to redefine which population we're discussing then
07:25:01 <copumpkin> roconnor, mmorrow: how's it look? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13767#a13770
07:25:28 <mmorrow> roconnor: well, there's no "magic" deepseq function provided as a primitive, but you could use unpackClosure# along with a seen set to emulate this (which is what vacuum does (but it also retains the graph))
07:25:41 <blobl> can someone help me break a string by another string into a list of strings?
07:25:44 <aavogt> but that's pretty close
07:26:09 <roconnor> copumpkin: I don't understand why teaspon doesn't give you the same sort of error you were complaining about before.
07:26:17 <mmorrow> copumpkin: looks good to me
07:26:26 <PeakerWork> blobl: See Data.List.Split
07:26:50 <mmorrow> roconnor: it does, it just gives you the option of not needing NFFFData, at the cost of only being able to see one level deep
07:26:51 <roconnor> copumpkin: oh, now i understand why
07:27:14 <mmorrow> well yeah, and it also only catches those exceptions
07:27:20 <roconnor> @src ($!)
07:27:21 <lambdabot> f $! x = x `seq` f x
07:27:49 <blobl> PeakerWork: i cant seem to find split.. only splitAt that whats you mean?
07:28:05 <PeakerWork> blobl: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
07:28:07 <ddarius> Deepseq would be a very expensive primitive
07:28:46 <copumpkin> so should I push a new version?
07:29:01 <copumpkin> maybe I'll put haddock on this one
07:29:15 <copumpkin> just to outline the differences between spoon and teaspoon, even though the type sigs should make it obvious
07:29:28 <mmorrow> ddarius: yeah it would, assuming you handle possible cycles
07:29:35 <aavogt> you explain the naming of such functions?
07:30:00 <mmorrow> ddarius: if you only supported heap graphs without cycles it could be O(1) memory
07:30:56 <copumpkin> aavogt: hey, don't ask for too much
07:31:26 <aavogt> just keep that in mind :P
07:31:56 <blobl> PeakerWork: cheers :D
07:34:03 <mmorrow> ddarius: hmm, although actually wouldn't it always be the case that if you deepseq a heap graph that /has/ cycles, deepseq should never finish (wrt semantic meaning of deepseq)?
07:34:26 <mmorrow> if that's so, then deepseq would be easy (and cheap)
07:35:14 <mmorrow> in other words, is it always the case that a cycle in the graph at the rts-level of the heap corresponds to infinite data at the haskell level?
07:36:39 <mmorrow> well, even so, you'd try to evaluate every shared subgraph as many times as it's shared, but still that's better than needing O(n) memory for a seen set
07:37:24 <mmorrow> i guess that's debatable actually
07:38:28 <scalaLove> let a n = n + 2 that gave me this in ghci: Interrupted. and then i executed the same code and it was fine, what is going on?
07:39:10 <mmorrow> did you do that immediately after ^C'ing some computation?
07:39:13 <mmorrow> sometimes that happens
07:39:30 <scalaLove> yes
07:40:27 <dcestari> hello everybody, I need to return the _|_ value, but how?
07:40:36 <lament> er.
07:40:44 <elly> Er.
07:40:44 <dcestari> test :: String -> a
07:40:52 <copumpkin> dcestari: error
07:40:55 <copumpkin> :P
07:40:55 <copumpkin> :t error
07:40:56 <lambdabot> forall a. [Char] -> a
07:40:57 <lament> :t undefined
07:40:57 <lambdabot> forall a. a
07:41:03 <dcestari> test _ = _|_
07:41:11 <copumpkin> dcestari: test _ = undefined
07:41:15 <copumpkin> test x = test x
07:41:17 <copumpkin> whatever you want
07:41:19 <mmorrow> dcestari: if you mean not in a way that kills your prog, then use Maybe
07:41:32 <mmorrow> otherwise undefined or error
07:41:36 <lament> Just undefined
07:41:40 <dcestari> I want to mimic the exit function from an imperative programming language
07:41:52 <lament> that's not what _|_ does
07:41:52 <dcestari> but I don't want errors going into stderr
07:41:57 <mmorrow> dcestari: but do you want *your* program to exit too?
07:42:01 <dcestari> yes
07:42:04 <mmorrow> ah, ok
07:42:06 <copumpkin> has anyone run any tests on the standard sort function to make sure head (sort xs) uses O(n) time?
07:42:14 <mmorrow> @type System.Exit.exit
07:42:16 <lambdabot> Not in scope: `System.Exit.exit'
07:42:24 <copumpkin> or that it behaves like a selection function in general
07:42:26 <mmorrow> @type System.Exit.exitWith
07:42:27 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
07:42:34 <mmorrow> @type System.Exit.exitSuccess
07:42:35 <lambdabot> forall a. IO a
07:42:37 <mmorrow> @type System.Exit.exitFailure
07:42:39 <lambdabot> forall a. IO a
07:43:14 <dcestari> mmorrow: I want to implement a custom 'error' function that does not write the given string to stderr
07:43:22 <dcestari> mmorrow: just putStrLn to stdout
07:43:25 <mmorrow> copumpkin: that'd be interesting to figure out what constant factor that adds above minimum
07:43:36 <mauke> :t throw
07:43:37 <mmorrow> dcestari: ah, so maybe then
07:43:37 <lambdabot> Not in scope: `throw'
07:43:49 <lament> oh god, i remember using a microsoft command-line utility that did that
07:43:49 <HardDrive> how sexy is my ride?
07:43:50 <HardDrive> http://www.youtube.com/watch?v=uEO2eRw4y5Y
07:43:53 <mmorrow> exit msg = do putStrLn msg >> exitSuccess
07:43:57 <lament> (wrote errors to stdout instead of stderr)
07:44:02 <copumpkin> mmorrow: I was hoping to evangelize some more on my twitter by telling people that they get selection for free if they write a sufficiently lazy sort, but
07:44:02 --- mode: ChanServ set +o mauke
07:44:05 <copumpkin> I'm not sure of it myself
07:44:06 <lament> so i had to parse its output and search for the word "error" in it
07:44:30 <lament> (of course, the utility didn't use exit codes either)
07:44:36 <HardDrive> How long does it take to learn C?
07:44:41 <copumpkin> HardDrive: ask ##c
07:44:45 --- mode: mauke set +b *!*@c-66-31-116-172.hsd1.ma.comcast.net
07:44:48 <dcestari> lambdabot: I know it sounds weird, but is for an educational project only
07:44:58 <mauke> wow, he's found freenode/#haskell
07:45:01 <dcestari> that was to lament
07:45:03 <dcestari> sorry
07:45:07 <copumpkin> mauke: who is he?
07:45:09 <mauke> he's some weird kind of troll from efnet/#c
07:45:26 <dcestari> mmorrow: I'll try that
07:45:45 --- mode: mauke set -o mauke
07:45:49 <mauke> basically, he joins and repeatedly asks "how long does it take to learn C" until he gets banned
07:46:25 <Veinor> does Haskell support line continuations?
07:46:40 <cnwdup> @pl (\a b -> a \\ [b])
07:46:41 <lambdabot> (line 1, column 12):
07:46:41 <lambdabot> unexpected "\\"
07:46:41 <lambdabot> expecting variable, "(", operator or ")"
07:46:48 <copumpkin> Veinor: ?
07:46:48 <scalaLove> let a n = n + 1
07:46:50 <scalaLove> find (mod 46) (iterate (a 3) 1)
07:46:55 <scalaLove> how to make the mod work?
07:47:08 <ACSpike[Home]> yay, I finished "Programming in Haskell" last night. What's next?
07:47:19 <copumpkin> ACSpike[Home]: go deeper
07:47:22 <copumpkin> ACSpike[Home]: and deeper
07:47:27 <copumpkin> it's bottomless :P
07:47:30 <copumpkin> except for _|_
07:47:32 <roconnor> > 10 `mod` 3
07:47:34 <lambdabot>   1
07:47:35 <ACSpike[Home]> :-)
07:47:51 <Veinor> like, if I have a long line, that I want to insert a newline into
07:47:51 <scalaLove> it is infix so...
07:47:51 <skorpan> how long does it take to learn C?
07:48:08 <Veinor> oh god, the infection's spread to skorpan D:
07:48:22 <mikste> Veinor, Yes, you end your first line with a '\' character and start your next line with a '\' character.
07:48:31 <aavogt> Veinor: in actual code, or in string litterals?
07:49:04 <Vulpyne> skorpan: C is quite easy if you know any other imperative language. The only difficult things are how low level it is (managing your own memory, etc) and pointers.
07:49:14 <Veinor> in actual code.
07:49:24 <skorpan> so how long?
07:49:31 <Veinor> Vulpyne: yeah, but the low-level and the pointers are hard :P
07:49:34 <aavogt> you don't need to do anything other than just adding the newlines
07:49:36 <mmorrow> copumpkin: things don't look good, but this may be because a reverse-sorted list is the worst-case for merge-sort? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5287#a5287
07:49:46 <tensorpudding> C is a small language, but it has a lot of dark corners
07:49:48 <aavogt> but you still have to follow layout
07:50:02 <Vulpyne> Veinor: I don't think it's that hard, just tedious. :)
07:50:14 <lament> the same people who think monads are easy think pointers are hard?
07:50:16 <Veinor> ah, so I can write
07:50:16 <Veinor> foo = (
07:50:16 <Veinor> a, b)
07:50:16 <Veinor> ?
07:50:16 <scalaLove> let a n = n+1; find (mod _ 46) (iterate (a 3) 1), guys why this does not work?
07:50:16 <mmorrow> dcestari: ooh, nice, interested to see your results
07:50:19 <roconnor> > mod 10 3
07:50:20 <lambdabot>   1
07:50:30 <copumpkin> mmorrow: damn
07:50:31 <roconnor> > (`mod` 3) 10
07:50:32 <aavogt> Veinor: you have to indent the a more
07:50:33 <lambdabot>   1
07:50:39 <Veinor> got it.
07:50:47 <mmorrow> copumpkin: (i had to ^C that because i was about to start swapping)
07:50:53 <Vulpyne> scalaLove: You're trying to pattern match outside of the pattern part again?
07:51:01 <aavogt> or use explicit semicolons and braces, but that gets pretty ugly
07:51:07 <copumpkin> mmorrow: I wonder if the old quicksort would work. Most selection algorithms I've seen are much more similar to quicksort than mergesort
07:51:10 <mmorrow> copumpkin: this may just be on account of the sorting algo though
07:51:11 <O_4> Hey guys, can I get a bit of advice re: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13772#a13772 ?
07:51:15 <tensorpudding> @type find
07:51:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:51:25 <mmorrow> copumpkin: ah, interesting
07:51:37 <scalaLove> Vulpyne, yes but mod is infix so mod 46 is kinda wierd...
07:51:42 <cnwdup> @pl (\a b -> facts b ++ foldl (flip delete) a (facts b))
07:51:42 <lambdabot> liftM2 (++) facts . (. facts) . foldl (flip delete)
07:51:43 <O_4> I'm trying to avoid evaluating 'rest' before returning what I have already.
07:51:48 <tensorpudding> @type mod _ 46
07:51:50 <lambdabot> Pattern syntax in expression context: _
07:52:01 <Vulpyne> scalaLove: mod is just a normal function. It's not an operator.
07:52:09 <mmorrow> copumpkin: well, another thing is that sort would necessarily need to read the entire list into memory in the worst case
07:52:17 <mmorrow> copumpkin: and minimum is O(1) space
07:52:21 <copumpkin> yeah :/
07:52:23 <copumpkin> hmm
07:52:23 <Vulpyne> scalaLove: But you can force any function to work like that by surrounding with backticks, ie: 10 `mod` 20
07:52:31 <copumpkin> mmorrow: but we're comparing against select in general
07:52:34 <copumpkin> so sort xs !! 5
07:52:36 <mmorrow> copumpkin: so maybe the benchmark really should force minimum to retain the whole list too
07:52:38 <aavogt> operators are only infix in haskell if you use backticks or if they contain symbols
07:52:43 <O_4> I thought about having getJSONPhotos return a list of IO actions and then folding (++) over it but that didn't seem to work.
07:53:00 <Vulpyne> scalaLove: You could instead do (\x -> mod x 46) or (\x -> x `mod` 46) or (`mod` 46)
07:53:02 <mmorrow> copumpkin: hmm, ok so maybe rnf the list first
07:53:08 * mmorrow tries that
07:53:23 --- mode: ChanServ set +o mauke
07:53:24 --- mode: mauke set +d *FAT*16*
07:53:37 <Veinor> +d?
07:53:42 <scalaLove> let a n = n+1; find (`mod` 46) (iterate (a 3) 1) Vulpyne ???
07:53:58 <Vulpyne> scalaLove: Is find the function from Data.List?
07:54:03 <Vulpyne> :t Data.List.find
07:54:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:54:05 <scalaLove> yes
07:54:12 <aavogt> scalaLove: a == succ
07:54:12 <Vulpyne> scalaLove: As you can see, it takes an Bool.
07:54:13 <tensorpudding> > let a n = n+1; find (`mod` 46) (iterate (a 3) 1)
07:54:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:54:15 <Vulpyne> :t mod
07:54:16 <lambdabot> forall a. (Integral a) => a -> a -> a
07:54:23 <tensorpudding> > let a n = n+1 in find (`mod` 46) (iterate (a 3) 1)
07:54:24 --- mode: mauke set -o mauke
07:54:24 <lambdabot>   No instance for (GHC.Num.Num (GHC.Bool.Bool -> GHC.Bool.Bool))
07:54:24 <lambdabot>    arising f...
07:54:31 <Veinor> also, I have a stylistic question: if I have a class, Foo, that's defined on non-negative integers, how can I make sure Foo (-5) doesn't work?
07:54:31 <aavogt> you're using iterate strangely
07:54:37 <Vulpyne> scalaLove: But mod returns an Integral.
07:55:02 <Veinor> should I just silently apply abs?
07:55:04 <Vulpyne> scalaLove: So you need to do something more like: (\x -> (x `mod` 46) == 0) or whatever.
07:55:05 <aavogt> > find ((==0) . (`mod` 46)) $ iterate succ 3
07:55:06 <lambdabot>   Just 46
07:55:12 <tensorpudding> actually, wait, (`mod` 46) returns a number, but find needs to have a function that returns a bool
07:55:36 <scalaLove> let a n = n+1; find (if(`mod` 46)) (iterate (a 3) 1) Vulpyne ???
07:55:43 <aavogt> > find ((==0) . (`mod` 46)) $ iterate (+3) 1
07:55:44 <lambdabot>   Just 46
07:55:50 <mauke> scalaLove: iterate (a 3) doesn't make sense
07:55:52 <mmorrow> copumpkin: oh gah, i was using Integer there too..
07:55:56 <mauke> scalaLove: a 3 is 4. iterate 4 is invalid.
07:56:23 <aavogt> if needs a Bool... it doesn't do any coersions
07:56:33 <aavogt> if also needs to be followed by then and else
07:56:41 <tensorpudding> > let a n = n+1 in iterate (a 3) 1
07:56:43 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
07:56:43 <lambdabot>    arising from a use of `a' at <int...
07:56:49 <aavogt> since it is an expression, not a statement
07:57:23 <tensorpudding> > take 10 $ iterate (+3) 1
07:57:25 <lambdabot>   [1,4,7,10,13,16,19,22,25,28]
07:57:26 <dcestari> :t error
07:57:28 <lambdabot> forall a. [Char] -> a
07:57:31 <blobl> PeakerWork: jesus :D
07:57:44 <PeakerWork> blobl: ?
07:57:57 <tensorpudding> it's a lot more clear to use a list comprehension in this
07:58:06 <dcestari> how come "error" does not return IO a ?
07:58:38 <dcestari> :t undefined
07:58:39 <blobl> that thing is amazing
07:58:39 <lambdabot> forall a. a
07:58:45 <aavogt> dcestari: because you're allowed to call error in pure code too
07:59:24 <dcestari> aavogt: I need to write a custom "error" like function to handle errors differently, but that blows me away
07:59:30 <aavogt> so error returns type 'a', which can unify with everything
07:59:33 <mauke> @src error
07:59:33 <lambdabot> error s = throw (ErrorCall s)
07:59:54 <scalaLove> mauke>	why? isnt what iterate does: first argument a function, second how many times to repeat it?
08:00:01 <mauke> scalaLove: yes
08:00:07 <mauke> scalaLove: no
08:00:13 <aavogt> heh
08:00:19 <mauke> scalaLove: the first argument is a function, but the second argument is the function argument, not a count
08:00:21 <aavogt> @quote mauke
08:00:21 <lambdabot> mauke says: trees are hierarchical
08:00:36 <mauke> scalaLove: so why aren't you giving it a function?
08:00:38 <aavogt> @quote mauke.*.right
08:00:38 <lambdabot> copumpkin says: <copumpkin> mauke is right by definition  <mauke> I am wrong  <copumpkin> fuck
08:01:15 <aavogt> dcestari: what is your custom function supposed to do?
08:01:26 <aavogt> error doesn't handle any errors at all
08:01:58 <dcestari> aavogt: I mean, I need a function that does the exact same thing as error but writes the output to stdout instead of stderr
08:02:04 <mauke> dcestari: why?
08:02:17 <mmorrow> copumpkin: woo, actually it looks like it is still O(n)
08:02:20 <dcestari> mauke: academic reasons, nothing special
08:02:27 <mmorrow> copumpkin: (graphing my numbers, one sec)
08:02:41 <copumpkin> roconnor: I've uploaded the new version :) it even has haddock now!
08:02:44 <dcestari> mauke: some scripts depend on the haskell program writing just to stdout
08:02:45 <Vulpyne> dcestari: Must it have a pure type?
08:02:54 <mauke> dcestari: so why don't you redirect stderr to stdout?
08:02:58 <copumpkin> roconnor: no Either version!
08:03:06 <dcestari> Vulpyne: I guess, I need to use it inside pure functional code
08:03:17 <dcestari> mauke: can't modify the calling program :S
08:03:25 <copumpkin> mmorrow: great!
08:03:29 * hackagebot upload: spoon 0.2 - Catch errors thrown from pure computations. (DanielPeebles)
08:03:31 * copumpkin really wants to say that
08:03:35 <mauke> dcestari: doesn't matter if you can modify the called program
08:03:54 <dcestari> mauke: can I redirect output within haskell?
08:04:04 <mauke> I don't know, but that also doesn't matter
08:04:12 <Vulpyne> @src error
08:04:13 <mauke> replace the called program by a shell script
08:04:13 <lambdabot> error s = throw (ErrorCall s)
08:04:39 <scalaLove> whats wrong with this: iterate print 2
08:04:40 <scalaLove>  
08:05:00 <mauke> scalaLove: print doesn't have a type that fits a -> a
08:05:01 <copumpkin> anyone want to test spoon? :)
08:05:02 <zygoloid> scalaLove: iterate wants a function which produces a value of the same type as the value it consumes
08:05:11 <Vulpyne> scalaLove: Have you looked at the type of iterate?
08:05:12 <ray> :t print
08:05:13 <lambdabot> forall a. (Show a) => a -> IO ()
08:05:45 <scalaLove> Vulpyne yeah and tried something but confused me
08:05:45 <fracture> @hoogle Data.Map.map
08:05:47 <lambdabot> Data.Map map :: (a -> b) -> Map k a -> Map k b
08:05:47 <lambdabot> module Data.Map
08:05:47 <lambdabot> Data.Map data Map k a
08:05:56 <fracture> what's an easy way to find out what package a library is in?
08:06:04 <ray> scalalove:
08:06:05 <ray> :t forever
08:06:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
08:06:10 <dcestari> :t throw
08:06:11 <lambdabot> Not in scope: `throw'
08:06:12 <zygoloid> @index map
08:06:13 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
08:06:18 <dcestari> @src error
08:06:19 <lambdabot> error s = throw (ErrorCall s)
08:06:23 <dcestari> @index throw
08:06:24 <lambdabot> Control.Exception
08:06:25 <PeakerWork> > fmap (+1) (Data.Map.fromList [("hello",1), ("world",2)])
08:06:26 <lambdabot>   Not in scope: `Data.Map.fromList'
08:06:27 <mmorrow> copumpkin: yup, head . sort is O(n) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5287#a5288
08:06:32 <Vulpyne> scalaLove: What "iterate f x" does is call "f x" and then feed that result back into f repeatedly, producing a list item each time it iterates.
08:06:35 <PeakerWork> > fmap (+1) (Map.fromList [("hello",1), ("world",2)])
08:06:37 <lambdabot>   Not in scope: `Map.fromList'
08:06:43 <zygoloid> > iterate f x :: [Expr]
08:06:44 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
08:06:49 <zygoloid> scalaLove: ^^ like so
08:06:49 <benmachine> > M.fromList []
08:06:51 <lambdabot>   fromList []
08:06:54 <PeakerWork> > fmap (+1) (M.fromList [("hello",1), ("world",2)])
08:06:56 <lambdabot>   fromList [("hello",2),("world",3)]
08:07:03 <mreh> what's the way to repeatedly apply bind?
08:07:09 <PeakerWork> mreh: sequence?
08:07:14 <mreh> :t sequence
08:07:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:07:19 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13773#a13773 YAY!
08:07:25 <O_4> Does anyone have any suggestions how I can avoid evaluating 'rest' before returning in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13772#a13772 ?
08:07:40 <mreh> :t replicateM
08:07:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:07:46 <copumpkin> mmorrow: does it maintain the same behavior for (!!5) . sort ?
08:07:52 <copumpkin> or an arbitrary selection?
08:07:55 <Veinor> is there a 'darcs setpref test' equivalent for git?
08:08:20 <mmorrow> copumpkin: i was too lazy to write a minimumN function :)
08:08:28 <dcestari> :t evaluate
08:08:30 <lambdabot> Not in scope: `evaluate'
08:08:32 <copumpkin> mmorrow: I'd expect it will behave as expected, anyway
08:08:37 <copumpkin> mmorrow: yay, I can evangelize on twitter some more now
08:08:38 <dcestari> :t Control.Exception.evaluate
08:08:38 <copumpkin> thanks!
08:08:39 <lambdabot> forall a. a -> IO a
08:08:44 <mmorrow> copumpkin: :)
08:08:57 <dcestari> is there any function like IO a -> a ?
08:09:08 <mauke> dcestari: unofficially, yes
08:09:09 <Vulpyne> :t unsafePerformIO
08:09:10 <lambdabot> Not in scope: `unsafePerformIO'
08:09:17 <mmorrow> copumpkin: was going to make a pretty graph in R, but i can't find my boilerplate R code to do that and i can never remember how
08:09:20 <zygoloid> dcestari: not in the mathematical sense of 'function', no.
08:09:24 * fracture figured it out, nm.
08:09:29 <dcestari> zygoloid: you are right
08:09:30 <ray> there certainly is no such function, and it's called unsafePerformIO
08:09:41 <scalaLove> Vulpyne so it will create an infinite list and u need to stop it somehow correct?
08:09:42 <zygoloid> ray++
08:10:00 <dmwit> copumpkin: Yes, with the built-in sort, (!! k) . sort is O(nk).
08:10:03 <dmwit> err
08:10:07 <dmwit> n log k
08:10:08 <Vulpyne> scalaLove: Well, because Haskell is lazy, an infinite list will only be produced if you consume it infinitely.
08:10:17 <mmorrow> copumpkin: looks like the constant in O(n) is roughly 5 too
08:10:18 <copumpkin> neat :)
08:10:20 <zygoloid> dmwit: isn't it O(n + k log k) ?
08:10:30 <Vulpyne> scalaLove: For example [1..] is an infinite list. But "take 2 [1..]" is only [1,2]
08:10:40 <dmwit> zygoloid: Is it?  It might be that.  But that doesn't really sound right to me.
08:11:03 <copumpkin> well I doubt my twitter followers will be splitting hairs
08:11:06 <dmwit> n log k sounds a lot more right
08:11:18 <zygoloid> dmwit: partition about kth element is O(n). sort first k elements is O(k log k)
08:11:23 <Vulpyne> scalaLove: It works that way for everything in Haskell, it's only evaluated when it is needed (although there are ways to force strictness.)
08:11:29 <copumpkin> zygoloid: it's a mergesort
08:11:33 <dmwit> zygoloid: built-in sort is mergesort
08:11:41 <copumpkin> there's a commented-out quicksort
08:11:55 <dmwit> zygoloid: Also, it can't possibly know how many elements you want before it starts the sort, so that argument is nosh.
08:12:11 <mmorrow> copumpkin: too bad that that largest number for sort barely finished without making me swap, so testing this for larger n might not be feasible
08:12:20 <dmwit> (i.e. you can't partition around the kth element)
08:12:20 <copumpkin> mmorrow: ah :/
08:12:23 <zygoloid> dmwit: i was providing an intuitive explanation for why it's plausible
08:12:41 <copumpkin> roconnor: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13773#a13773 :)
08:12:57 <PeakerWork> copumpkin: I don't think ((!!k) . sort)  is O(N) worst-case (like the best algorithms are), maybe average case though
08:13:06 * dmwit nods
08:13:30 <dcestari> sorry for all the trouble
08:13:35 <PeakerWork> zygoloid: not k log n ?
08:13:38 <zygoloid> PeakerWork: i think it typically will sort the first k elements. forcing the spine will usually force the acutal values
08:13:45 <dcestari> All I did was catching all exceptions in the main monad function
08:13:48 <zygoloid> PeakerWork: it's clearly at least O(n)
08:13:50 <dmwit> PeakerWork: I'm pretty sure mergesort does give you O(n) worst-case.
08:14:06 <PeakerWork> dmwit: you mean  (!!n) . mergesort ?
08:14:07 <dmwit> PeakerWork: (assuming a particular k that never ever varies)
08:14:16 <PeakerWork> dmwit: oh, I see
08:14:18 <dcestari> main = catch ( ... all my work ...) ( \e -> putStrLn (show (e :: SomException)))
08:14:19 <scalaLove> Vulpyne oh I see how it works: iterate (*2) 3, it starts with 3*2, and then continues (6*2)*2)...
08:14:51 <mmorrow> PeakerWork, dmwit: here are the numbers i got for k=1 on my machine http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5287#a5288
08:14:51 <PeakerWork> dmwit: it should be the same complexity as getting the minimum of the list via a sort that way, then, intuitively
08:14:55 <zygoloid> i'm having a hard time finding anything which gives a proof of a time bound for any hasklell implementation of take n . sort
08:14:59 <Vulpyne> scalaLove: Yeah, it just repeatedly calls the function on its own result, using the initial value as a seed.
08:15:08 <mauke> > iterate (*2) 3 :: [Expr]
08:15:09 <lambdabot>   [3,3 * 2,3 * 2 * 2,3 * 2 * 2 * 2,3 * 2 * 2 * 2 * 2,3 * 2 * 2 * 2 * 2 * 2,3 ...
08:15:17 <mmorrow> so k=1 is linear at least
08:15:28 <dmwit> mmorrow: Yep, looks linear.
08:15:34 <mmorrow> (with a constant of around 5)
08:15:35 <PeakerWork> mmorrow: you seem to be hitting some quirky jump in the higher input there, cache lines?
08:15:45 <mmorrow> PeakerWork: hmm, maybe
08:15:57 <zygoloid> mmorrow: try k=100 too, that should clarify whether it's k log k + n, or n log k.
08:16:01 <mmorrow> testing that for any larger number with sort though will be tough
08:16:05 <dmwit> PeakerWork: No, I think it's just the very small test case that's the outlier.
08:16:10 <zygoloid> hmm
08:16:12 <mmorrow> that largest sort test barely finished without swapping
08:16:16 <zygoloid> no, forget that :)
08:16:47 <dmwit> > ap (zipWith (/)) tail [0.006, 0.027, 0.182, 1.613, 15.206]
08:16:48 <lambdabot>   [0.22222222222222224,0.14835164835164835,0.11283323000619963,0.106076548730...
08:17:09 <dmwit> > map round . (*100) . ap (zipWith (/)) tail $ [0.006, 0.027, 0.182, 1.613, 15.206]
08:17:10 <lambdabot>   No instance for (GHC.Num.Num [a])
08:17:11 <lambdabot>    arising from the literal `100' at <int...
08:17:20 <dmwit> > map (round . (*100)) . ap (zipWith (/)) tail $ [0.006, 0.027, 0.182, 1.613, 15.206]
08:17:21 <lambdabot>   [22,15,11,11]
08:18:01 <scalaLove> take 10 $ iterate (*2) 1: I understand everything here but the $, I read in docs about it, says: you can ommit braces... does that mean i can also do this: take 10 (iterate (*2) 1)
08:18:14 <dmwit> copumpkin: Have you seen ChasingBottoms?
08:18:21 <dmwit> (just saw your "spoon" paste)
08:18:32 <PeakerWork> scalaLove: yep!
08:18:51 <Veinor> hm, okay. apparently git's pre-commit hook doesn't output anything if your script exits 1, just silently fails
08:19:48 <_Jedai_4> scalaLove: ($) is just function application but with the weakest priority possible (whereas normal function application with a whitespace binds tighter than almost everything else)
08:20:00 <mreh> :t replicate
08:20:01 <lambdabot> forall a. Int -> a -> [a]
08:20:11 <mreh> :t sequence
08:20:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:20:27 <Veinor> Jedai: what binds tighter than whitespace application?
08:20:29 <Vulpyne> scalaLove: Yes, it does. $ is pretty much like an opening parenthesis that you don't have to close.
08:20:36 <Jedai> Veinor: record syntax
08:20:54 <scalaLove> Vulpyne best explanation, will remember that, thank you
08:21:01 <mreh> sequence isn't the generic way of sequencing an arbitary number of calculations is it?
08:21:04 <kmc_> erm except often it's not that
08:21:08 <Vulpyne> scalaLove: Some people like it, some people hate it. I love it personally.
08:21:13 <Veinor> $ is also useful in:
08:21:13 <kmc_> (to Vulpyne)
08:21:18 <dmwit> mreh: Sure it is.
08:21:23 <dmwit> Why wouldn't it be?
08:21:26 <kmc_> mreh, if by "calculation" you mean "monad action"
08:21:29 <scalaLove> Vulpyne I sure hate braces so :) i love $
08:21:33 <Veinor> > zipWith ($) [id, (+1), (-1)] (repeat 1)
08:21:34 <lambdabot>   No instance for (GHC.Num.Num (b -> b))
08:21:34 <lambdabot>    arising from a use of syntactic n...
08:21:35 <kmc_> otherwise computations have no defined order in haskell
08:21:41 <lament> i love dollars
08:21:43 <Jedai> scalaLove: you can also often use it as a closing parenthesis you don't have to open.... ;)
08:21:48 <kmc_> :t sequence
08:21:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:21:52 <copumpkin> dmwit: yep
08:22:17 <scalaLove> Jedai wooow :D thats cool, i know why people say once u get into huskell aint no turning back
08:22:27 <copumpkin> dmwit: it looked overcomplicated and more than I'd expect someone wanting to deal simply with Data.Binary's annoying decode would want
08:22:28 <Jedai> Veinor: map ($ 1) [functions]
08:22:32 <kmc_> heh, ($) is a trivial feature
08:22:36 <Vulpyne> kmc: I think simplifying things to the most common use can be helpful when dealing with people new to Haskell.
08:22:44 <tensorpudding> ($) is so useful though
08:22:52 <copumpkin> kmc_: not in jmcarthur's new alt-stdlib version of it though
08:22:57 <mreh> simplifying never helps
08:23:07 <kmc_> Vulpyne, chemistry professors do this... it always annoyed me
08:23:22 <kmc_> "sorry, everything you learned last week was a lie"
08:23:25 <Veinor> Jedai: yeah, that's what I was thinking of >_>
08:23:26 <kmc_> repeat 3 or 4 times in one course
08:23:27 <ivanm> kmc_: well, I found chemistry in general annoying... ;-)
08:23:38 <Vulpyne> mreh: If every time you try to do something, that requires learning a bunch more stuff, and each of those things you learned about require learning a bunch more stuff, and and everything you learned about there requires learning a bunch more stuff... It's hard to get traction.
08:23:43 <ivanm> (though they do that in physics as well... there's no such thing as an electron orbital!)
08:23:57 <dmwit> Jedai, Veinor: zequence [functions] 1
08:23:57 <kmc_> i mean this is about all you need to know:
08:23:57 <kmc_> @src ($)
08:23:58 <Vulpyne> mreh: Personally, I learn by actually writing programs, and that can't happen unless you get to the point of actually writing something.
08:23:59 <lambdabot> f $ x = f x
08:24:05 <dmwit> > sequence [id, (+1), subtract 1] 1
08:24:07 <lambdabot>   [1,2,0]
08:24:31 <mreh> Vulpyne, humans always communicate it yesterdays language, but that doesn't mean your shouldn't just come out and say exactly what something is
08:24:41 <mreh> s/it/in
08:24:53 <tensorpudding> ivanm: it is useful to have electron orbitals
08:24:55 * copumpkin has a pet peeve: people putting papers up in (g)zip files
08:25:00 <lament> at least the chemists admit their lies
08:25:01 <Jedai> dmwit: I didn't know this one, it's cool but I think I'll still use the map version, it seems clearer to me :)
08:25:18 <Veinor> copumpkin: oh, ew
08:25:28 <tensorpudding> it's just a construct we use to model things
08:25:30 <Vulpyne> mreh: How would you have answered his question?
08:25:31 <mreh> e.g. electrons are not footballs
08:25:33 <tensorpudding> like holes
08:25:33 <copumpkin> .ps.gz in particular seems very common
08:25:51 <tensorpudding> it can be useful to think of electrons as waves, or particles, depending on the problem
08:25:51 <kmc_> copumpkin, yes, especially considering http supports transparent gz
08:26:08 <mreh> yeah, neither of which are footballs
08:26:12 <lament> wait, orbitals don't exist??
08:26:29 <EvanR> gawd... check ##physics for crying out loud
08:26:34 <kmc_> heh
08:26:43 <lament> does the earth's orbit not exist either? :(
08:26:58 <EvanR> if you invoke childishly naive quantum gravity
08:27:11 <mmorrow> copumpkin: yea, ps.gz is so annoying
08:27:13 <tensorpudding> there isn't a coherent theory of quantum gravity yet
08:27:18 <dcestari> thank you all!
08:27:27 <dcestari> good night
08:27:28 <tensorpudding> this isn't even remotely haskell anyway
08:27:52 <EvanR> i cant wait until they come out with quantum haskell
08:28:00 <mreh> dmwit: what monad were you using then?
08:28:17 <Vulpyne> EvanR: There's already a quantum package. :)
08:28:26 <Vulpyne> Quantum monad, I think.
08:28:29 <copumpkin> quantum arrows
08:28:30 <EvanR> haha
08:28:34 <Jedai> electrons orbitals correspond to certain level of energy, though that's a simplification too that still means that they are quantified so they're not a "complete" lie
08:28:48 <tensorpudding> what the hell would quantum haskell even mean
08:28:52 <mreh> :t (>>=)
08:28:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:28:57 <kmc_> "The arrow is defined over any instance of MonadRandom, so if you want to get especially crazy, you can experiment with what quantum computation is like when observables include invoking continuations"
08:28:58 <EvanR> uses quantum functions
08:28:59 <copumpkin> @hackage quantum-arrow
08:29:00 <lambdabot> http://hackage.haskell.org/package/quantum-arrow
08:29:01 <PeakerWork> tensorpudding: the list monad in O(1)? :-)
08:29:02 <mreh> quantum haskell, just use the list monad
08:29:14 <lament> presumably haskell with qubits as a primitive type
08:29:21 <tensorpudding> they're using it in a different sense than what people usually mean by quantum
08:29:24 <lament> which presumably already exists, using simulated qubits
08:29:39 <kmc_> lament, and specially restricted operations on those qbits
08:29:45 <copumpkin> these are quantum arrows
08:30:05 <lament> simulated qubits aren't very exciting
08:30:18 <kmc_> the set of states of a n-qubit system is not the n-way cartesian product of the set of states of a qubit
08:30:21 <scalaLove> sum $ takeWhile (<10000) $ map (^3) [1..] : This works but I try to figure out why------------ takeWhile takes first 10000 numbers, then ^3 is mapped onto numbers on infinity... As it goes to infinity it stops automatically since before this takeWhile went only to 10000?
08:30:24 <kmc_> you need a quantum way to compose them
08:30:26 <copumpkin> it's still an interesting arrow instance
08:30:33 <EvanR> we are required to think in a functional paradigm, and limit the extent of imperative code. in quantum haskell youd have special monads to encapsulate classical computing ;)
08:30:36 <copumpkin> http://hackage.haskell.org/packages/archive/quantum-arrow/0.0.5/doc/html/src/QuantumArrow-Quantum.html#Quantum
08:30:39 <mreh> are functions a monad then?
08:30:44 <kmc_> the set of states of a n-qubit system is, roughly, a complex-valued vector in 2^n dimensions
08:30:53 <kmc_> mreh, (a ->) is a monad for any a
08:31:04 <copumpkin> it's quantum arrows over a monad
08:31:07 <copumpkin> a bit like Kleisli
08:31:14 <kmc_> mreh, which is written ((->) a) because we don't have type operator sections
08:31:15 <mmorrow> <kmc_> the set of states of a n-qubit system is not the n-way cartesian product of the set of states of a qubit
08:31:20 <mmorrow> kmc_: can you explain that?
08:31:40 <kmc_> because of entanglement
08:31:59 <mmorrow> err, first, what is a qubit here?
08:32:00 <copumpkin> someone should write shor's algorithm in quantum-arrow
08:32:06 <mmorrow> an abstract unit? or?
08:32:15 <kmc_> it's a quantum system
08:32:43 <EvanR> a|0> + b|1>
08:32:45 <mmorrow> i know that you can entangle electrons (right?), but what else can you entangle?
08:32:55 <kmc_> its states are unit vectors in C^2
08:32:58 <zygoloid> cats and observers? :)
08:33:06 <lament> mmorrow: anything
08:33:09 <tensorpudding> wavefunctions can be entangled
08:33:09 <lament> mmorrow: it's an engineering problem
08:33:13 <zygoloid> or is this a Copenhagen channel? ;-)
08:33:25 <tensorpudding> but generating them is not easy
08:33:40 <kmc_> a qubit abstracts something like a trapped ion or a photon or a NMR spin state, in the same sense that a bit abstracts a charge in a DRAM capacitor cell or a magnetic orientation on a disk
08:33:50 <tensorpudding> we could talk about climate change
08:34:07 <tensorpudding> that would be in the spirit of Copenhagen
08:34:16 <kmc_> when we say a system has "n qubits" of state we mean that its states are vectors in C^(2^n)
08:34:18 <scalaLove> sum $ takeWhile (<10000) $ map (^3) [1..] : This works but I try to figure out why------------ takeWhile takes first 10000 numbers, then ^3 is mapped onto numbers on infinity... As it goes to infinity it stops automatically since before this takeWhile went only to 10000?
08:34:30 <kmc_> that is, a 2-qubit system is a any superposition of 00, 01, 10, and 11
08:34:33 <MoALTz> shouldn't the offtopic be in #haskell-blah ?
08:34:36 <mmorrow> lament, kmc_: ok, and entanglement identifies two physically separate qubits with each other ("identify" in the math sense)
08:34:37 <kmc_> yeah okay
08:34:40 <aavogt> scalaLove: that's because haskell is non-strict
08:34:46 <mmorrow> lament, kmc_: .. ?
08:34:50 <tensorpudding> isn't a qubit just a state that exists in a space of two distinct states, up and down
08:34:57 <kmc_> going to haskell-blah
08:34:58 <tensorpudding> or you can call them 0 or 1
08:35:06 * mreh likes the general tolerance for off-topic
08:35:10 <EvanR> tensorpudding: nope
08:35:19 <mreh> you get an ass kicking elsewhere for off-topic
08:35:41 <copumpkin> it isn't really off-topic
08:35:48 <mreh> everyone in #C wants to look busy so they don't loose their job to a great ape
08:35:48 <copumpkin> it's just not quite haskell ;)
08:35:49 <dmwit> mmorrow: Not quite.
08:35:57 <dmwit> mmorrow: It just says the two qubits are correlated.
08:36:00 <lament> mmorrow: in probability terms, entaglement is like correlation between variables (variables being values of qubits once you actually observe them)
08:36:23 <lament> mmorrow: so once you observe one qubit, that affects the probabilities for the other, as yet unobserved qubit
08:36:30 <dmwit> mmorrow: At one extreme, this identifies qubits, but it isn't usually so simple. =)
08:37:07 <Vulpyne> scalaLove: Since Haskell isn't strict, the values are just evaluated when they are demanded. So "map (^3) [1..]" is somewhat similar to a stream. As is the other functions you call on it.
08:37:23 <aavogt> scalaLove: the haskell implementation is supposed to evaluate things in such an order that some non-terminating computations may produce actual results
08:37:30 <mreh> i don't think sequence is quite the right function I'm looking for, I need to thread a state through an arbitary number of calculations, how can I do this?
08:37:36 <lament> mmorrow: it's possible to entagle two qubits such that when you observe one, you know that the other one is the same. But it can be arbitrarily more complicated
08:37:58 <mmorrow> interesting
08:37:59 <dmwit> mreh: That's what the State monad is for.
08:37:59 <Vulpyne> arbitrary calculations terminated at what?
08:38:16 * mmorrow just switched from haskell-blah's explanation, catches up
08:38:30 <dmwit> mreh: I'm a little confused about why you keep insisting on an arbitrary number of calculations, though; what would restrict the number of calculations?
08:38:31 <mmorrow> ok, cool
08:38:42 <mmorrow> so entanglement is much more interesting then
08:39:00 <dmwit> IANAP =(
08:39:04 <mreh> dmwit: I need to apply a function on a list whist keeping track of what I just did to the last element
08:39:13 <mreh> map a function to a list
08:39:16 <Vulpyne> mreh: foldl' perhaps?
08:39:38 <mmorrow> so changing the state of one item in an entangled collection of items essentially lets you change the states of all other items in that collection in various ways
08:39:40 <Vulpyne> You can use foldl to simulate state.
08:39:41 <roconnor> copumpkin: I hate this new spoon code much less
08:39:47 <copumpkin> roconnor: yay!
08:39:52 <copumpkin> I'll settle for that for now :)
08:40:00 <copumpkin> roconnor: any more suggestions for decreasing the "ick" factor?
08:40:05 <copumpkin> beyond scrapping it
08:40:12 <mreh> Vulpyne, I think I see how
08:40:18 <dmwit> mreh: foldr, foldM, and mapM could all be relevant, depending on exactly what you're doing.
08:40:48 <dmwit> mreh: map . ap zip tail -- could also be relevant =)
08:40:57 <dmwit> > ap zip tail [2,4..10]
08:40:58 <lambdabot>   [(2,4),(4,6),(6,8),(8,10)]
08:41:09 <roconnor> copumpkin: I can't think of anything other than scrapping it.
08:41:12 <mreh> it's kind of complicated: I want to generate random melodies, but keep them inside a particular range of tones
08:41:37 <copumpkin> roconnor: yay, I'll consider that a local maximum
08:41:53 <mreh> and the melodies move between octaves smoothly, never jumping by more than one octave
08:42:12 <mmorrow> mreh: so generate random Ints in a certain range, then use those Ints to index into an array/list/map which has those tones at indices in that range
08:42:12 <mreh> so I have to be aware of what the last note was
08:42:30 <mmorrow> ah
08:42:36 <mreh> yeah
08:42:39 <mreh> not so simple is it
08:43:04 <dmwit> sure it is
08:43:09 <aavogt> just do dmwit's ap zip tail, and then filter out the ones who jump to much
08:43:12 <copumpkin> roconnor: for what it's worth, decode seems totally unlazy
08:43:15 <dmwit> The map just isn't from Int -> Note, it's from (Note, Int) -> Note.
08:43:19 <lament> generate a list of signed integers corresponding to intervals between notes. Then, if a jump would put a note out of bounds, invert the jump instead
08:43:22 <roconnor> copumpkin: that's dumb
08:43:33 <mmorrow> mreh: i guess you could represent the octave and the note separately, and first generate a random note, then generate a random {down,same,up} value for the octave
08:43:35 <copumpkin> but the rnf one is still good
08:43:56 <mreh> lament: what if I jump from C2 to D3? that's more than an octave
08:44:06 <lament> mreh: oh, that's allowed?
08:44:10 <roconnor> copumpkin: the only reason for decode to not return Maybe is so it can be lazy
08:44:16 <roconnor> copumpkin: and it isn't even lazy!
08:44:20 <lament> mreh: i thought that wasn't allowed
08:44:24 <mreh> it isnt
08:44:28 <dmwit> mreh: You wouldn't, since the interval is only in the range 0-7. ;-)
08:44:28 <lament> mreh: right
08:44:42 <copumpkin> roconnor: yeah :/ or maybe it can be lazy but the list instance isn't or something
08:44:48 --- mode: ChanServ set +o mauke
08:44:49 --- mode: mauke set -b *!*@c-66-31-116-172.hsd1.ma.comcast.net
08:44:53 <dmwit> mreh: In other words, lament is suggesting that you generate interval lists, not note lists.  Then convert.
08:45:20 <dmwit> (or -4 to +4, or whatever your acceptable range of intervals is)
08:45:30 <mreh> mmorrow: the melody is fixed, like the names of notes in the song twinkle twinkle
08:45:34 <mreh> no octave
08:45:43 <mmorrow> mreh: i wrote this for kicks, maybe it could be useful for something you're doing http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4534
08:45:49 --- mode: mauke set -o mauke
08:46:24 <mreh> mmorrow: can that handle key changes?
08:46:30 <copumpkin> someone should write a music library that supports non-equal temperaments
08:46:35 <mreh> is that what the interval for?
08:46:42 <lament> the melody is fixed? i thought you were generating the melody...
08:46:46 <mmorrow> mreh: it could be made to
08:46:54 <roconnor> copumpkin: dons shouldn't be allowed to write haskell code anymore.
08:47:01 <copumpkin> roconnor: lol
08:47:01 <dmwit> mmorrow: I take it you've never done any music theory. =P
08:47:07 <mmorrow> mreh: yeah,   it represents a particular key by the intervals only
08:47:13 <mreh> mmorrow: is that what the degree is for, sorry
08:47:21 <mmorrow> dmwit: heh
08:47:41 <copumpkin> I quite like it
08:47:41 <mmorrow> lemme refresh my memory on that module, one sec
08:47:54 <lament> mmorrow: heh, i wrote most of that for my chord parser
08:48:14 <mmorrow> lament: ooh cool, you have a chord parser?
08:48:44 <lament> yeah, too bad i never wrote anything to connect it too
08:48:46 <lament> -o
08:48:47 <mreh> you have a chord parser?!
08:48:51 <mreh> I would like very much
08:49:04 <tensorpudding> a chord parser?
08:49:06 <mmorrow> mreh: ok, so the degree identifies the i'th note in a scale
08:49:10 <mreh> I could definitely write something to connect to it
08:49:11 <tensorpudding> like chords in music?
08:49:17 <dmwit> jeepers, this is a long module
08:49:27 <DaveS> can somebody explain what a "kind" is
08:49:28 <DaveS> ?
08:49:28 <mmorrow> mreh: and which degree you consider to be the starting degree determines the mode
08:49:35 <dmwit> DaveS: It's the type of a type.
08:49:40 <mreh> mmorrow: it's a shame jazz isn't modal
08:49:46 <DaveS> the type.. of a type..
08:49:53 <mreh> even modal jazz isn't modal
08:49:58 <mmorrow> heh
08:50:02 <lament> *Parser> readChord "Cmaj7#9/B"
08:50:02 <lament> Just (RootedChord B (fromList [0,3,4,7,11]))
08:50:03 <dmwit> DaveS: For example, Int has a different kind than [], because Int is itself a type, but [] isn't a type until it's applied to another type.
08:50:05 <tensorpudding> the fact that jazz isn't modal is what makes it sound good
08:50:14 <lament> some jazz is pretty modal
08:50:19 <lament> and yeah, it doesn't sound very good at all
08:50:22 <dmwit> jazz isn't modal?
08:50:27 <mreh> nope
08:50:27 <mmorrow> lament: ooh sweet, is this on hackage?
08:50:29 <tensorpudding> it is somewhat modal
08:50:35 <lament> mmorrow: no
08:50:39 <dmwit> Are we using the same definition of modal?
08:50:42 <mreh> it's stuck about two centuries back
08:50:56 <mmorrow> lament: is it online anywhere?
08:50:59 <mreh> modal means it has no tonality
08:51:14 <mreh> as such, the feeling is derived from the chord of the moment
08:51:16 <pastah_rhymez> how do i write functions with the ((->) a) monad? is it possible to do with do-notation?
08:51:28 <dmwit> DaveS: StateT has an even more interesting kind; it has to applied to a type constructor and two types before it can become a type.
08:51:32 <dmwit> :k StateT
08:51:33 <lambdabot> * -> (* -> *) -> * -> *
08:51:37 <pastah_rhymez> do i just have functions that all take the same last argument and always leave that out?
08:51:39 <aavogt> pastah_rhymez: same as any monad
08:51:45 <lament> mmorrow: no
08:51:46 <dmwit> DaveS: (*) is the kind of plain old types like Int and String.
08:51:54 <dmwit> DaveS: The rest of the syntax should be familiar, though in a new setting.
08:51:57 <mmorrow> mreh: "<mmorrow> mreh: yeah, it represents a particular key by the intervals only" err, of course i meant s/key/scale/
08:52:02 <pastah_rhymez> aavogt: no, ((->) a) is serious brainfuck, so no
08:52:05 <mmorrow> lament: :(
08:52:14 <roconnor> copumpkin: put l  = put (length l) >> mapM_ put l  -- source for []
08:52:18 * roconnor cries
08:52:18 <aavogt> > let f = do x <- (+1); y <- subtract 2; return (x+y,x) in f 0
08:52:19 <lambdabot>   (-1,1)
08:52:27 <benmachine> I had a good example somewhere
08:52:36 <aavogt> pastah_rhymez: it's just the Reader monad without the newtype
08:52:53 <Veinor> bah, I have to move all my stuff into Data/ for packaging
08:52:58 <benmachine> http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=5289#a5289
08:53:00 <pastah_rhymez> aavogt: yeah, as i said; you leave out the last argument on every line
08:53:02 <copumpkin> roconnor: yeah :/ so I guess it's strict in the spine for put, and probably tries to eat the entire length before returning something for get
08:53:02 <dmwit> Whoops, I was using the wrong definition of modal.  No wonder I was confused.
08:53:09 <benmachine> pastah_rhymez: http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=5289#a5289
08:53:09 <kmc_> pastah_rhymez, yeah.  the translation of "do" is independent of what monad you're using, so it works for any monad
08:53:47 <benmachine> (technically I think I could do that applicatively, but whatever)
08:54:01 <aavogt> pastah_rhymez: yeah, using bind with the (r ->) monad is the same as  'asks' with the same function in the Reader
08:54:08 <kmc_> > sequence [(+1), (*2), ord . ("foobar"!!)] 3
08:54:09 <lambdabot>   [4,6,98]
08:54:41 <roconnor> copumpkin: I guess a lazy list serialization would need an extra bit per element, which might expand to an extra byte per element.
08:55:00 <mreh> mmorrow: did you get it to generate seventh chords?
08:55:15 <mreh> and why aren't you usng the harmonic minor?
08:55:22 <copumpkin> roconnor: it could still just use the length for deserialization and produce the elements lazily, even if it wouldn't do the serialization lazily
08:55:32 <aavogt> > mapM_ subtract [1..10] 0
08:55:33 <lambdabot>   ()
08:55:40 <copumpkin> in case you just receive a truncated file or something, and want what little is still there
08:55:41 <mmorrow> mreh: because harmonic minor is just (II,major) iirc
08:56:05 <mmorrow> mreh: yeah, it gives you seventh chords
08:56:07 <mreh> your V chord isn't a V chord though
08:56:12 <mmorrow> gah!
08:56:29 <mreh> ?!
08:56:29 <lambdabot> Maybe you meant: . ? @ v
08:56:33 <mmorrow> mreh: err wait, where do you mean?
08:56:55 <mreh> if you use the melodic minor, there's no tritone in there that gives you a V7 back to i
08:57:12 <lament> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5291 and http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5290
08:57:13 <mreh> you get a v-7
08:57:13 <dmwit> mmorrow: Typically, you sharp the seventh of a V chord in major mode.
08:57:18 <dmwit> err...
08:57:22 <dmwit> ignore me
08:57:25 <mreh> lul
08:57:38 <roconnor> copumpkin: try head (decode (encode (2::Int, 0::Int, undefined::Int))) :: Int
08:57:43 <mmorrow> lament: awesome!
08:57:49 <dmwit> I did take music theory... but it was half a decade ago. =P
08:58:09 <roconnor> copumpkin: actually that probably won't work
08:58:15 <copumpkin> roconnor: you wanted a tuple?
08:58:26 <copumpkin> I guess so
08:58:29 <mreh> why don't we start collaborating on some music projects?
08:58:32 <copumpkin> if you put type sigs everywhere
08:58:39 <mreh> lament, mmorrow?
08:58:43 <roconnor> I want to test to see if we had a lazy list instance for Binary, if it would be lazy.
08:58:45 <mmorrow> mreh: ahhh, right
08:58:49 <copumpkin> ah
08:58:53 <mmorrow> mreh: (re: harmonic/melodic)
08:59:06 <roconnor> copumpkin: the problem is that bytestring is chuncked
08:59:07 <copumpkin> how many of you play an instrument?
08:59:13 <roconnor> and this chunk is too small
08:59:14 <mmorrow> mreh: ? (awesome! in response to him pasting his chord parser)
08:59:14 <lament> mreh: what kind of music project do you suggest?
08:59:14 <mreh> I play the bass
08:59:17 <copumpkin> ah
08:59:19 <aavogt> all 600
08:59:27 <mreh> jazz and orchestral
08:59:37 <mmorrow> mreh: oh, just saw "..collaborating.."
09:00:01 <mreh> lament, useful libraries for musicians
09:00:02 <lament> you can't play music over the internet, due to latency...
09:00:09 <mmorrow> mreh: i play guitar, but haven't touched it in a long time :(
09:00:10 <mreh> especially the improvising musician
09:00:15 <lament> i'm not really sure what libraries would be useful to a musician
09:00:17 <mreh> www.mattmorrow.com
09:00:21 <mmorrow> i love improvising :(
09:00:23 <copumpkin> lol
09:00:25 <mmorrow> s/:(/:)/
09:00:40 <copumpkin> mreh: http://twitter.com/mmorrow
09:00:40 <mmorrow> haha
09:00:49 <roconnor> copumpkin: I think to test it I'd have to write a new instance for newtype LazyInstance a = LazyInstance [a]
09:00:54 <lament> If you think of music improvisation too mathematically, it'll never sound good
09:00:57 <Veinor> copumpkin: oh god
09:01:01 <mmorrow> i've never been to mattmorrow.com, and i'm not sure i want to ever again :)
09:01:05 <lament> all this theory stuff is really lame
09:01:14 <Veinor> why, what is it?
09:01:14 <copumpkin> mmorrow is praising the lord!
09:01:19 <mmorrow> yay!
09:01:19 <mreh> lament: i don;t want to create music, I want to make teaching improv easier
09:01:21 <Veinor> oh, ew
09:01:43 <ray> help matt morrow is knocking at my computer screen
09:01:58 <copumpkin> mmorrow jumping into a pool: http://www.mattmorrow.com/images/video2.wmv
09:02:09 <copumpkin> damn he's rich
09:02:20 <ray> a pool filled with money?
09:02:50 <mreh> right now, I have to transcribe so much and write long passages down to improvise with, if I could generate those quickly, using a chord parser for example, that could then derive all the guidetones of a progression, that would make it so much easier
09:02:50 <mmorrow> lol, one of the pictures on mattmorrow.com has someone lighting a cigar with a flaming $100 bill
09:03:22 <copumpkin> hot
09:03:24 <mreh> mattmorrow.net
09:03:45 <lament> wait
09:03:54 <lament> you're generating random melodies to teach yourself to improvise??
09:04:05 <mreh> lament: no
09:04:11 <ray> that's a ridiculously programmerish thing to do
09:04:22 <lament> mreh: but you want to?
09:04:26 <mreh> but I'm introducing randomness to force me to learn new material
09:04:30 <lament> o_O
09:04:32 <Veinor> when I'm packaging a package for cabal, how do I tell which Cabal-Version I should use?
09:04:40 <mreh> new inversions of melodies
09:04:49 <copumpkin> Veinor: I just copy someone else's .cabal file
09:04:50 <lament> mreh: please stop right now and go back to transcribing real music
09:04:53 <mreh> new chromaticisms
09:05:24 <Veinor> I could always do it as the max of my requirements' cabal-versions :D
09:05:36 <Veinor> also, how can I auto-generate my Build-Depends line?
09:05:41 <mreh> i am, i'm still transcribing real melodies, then I want to permutate rhythms on those melodies, add differen't trills to them
09:05:46 <mreh> etc.etc.
09:05:52 <lament> mreh: :\
09:05:59 <lament> it's a horrible idea
09:06:29 <mreh> it's not going to sound like music, it's going to sound like an etude, but they exist for a good reason
09:07:19 <blackdog> lament: why is it a horrible idea?
09:07:30 <rasfar> it'll sound like bach of you're unlucky
09:07:51 <mmorrow> lament, mreh: i've wanted to write a prog that'll generate and play random progressions given a particular (scale,key) combo that you could improvise over when you're alone
09:08:00 <lament> blackdog: it's like writing literature using a markov process
09:08:02 <mmorrow> that would be handay
09:08:06 <mreh> lament thinks machines of the future will write music
09:08:20 <mreh> it's not supposed to be art, it's suppose to be a teaching aid
09:08:26 <copumpkin> mreh: chopin's études are wonderful and definitely sound like music too
09:08:29 <lament> mreh: and what are you learning?
09:08:54 <mreh> how to improvise, the method is a man-made method, it's just being automated
09:09:21 <lament> but improvisation has nothing to do with permuting notes, unless you're a computer
09:09:43 <lament> it has to do with inventing melodies, and playing them...
09:09:56 * dmwit looks forward to Take 7, the machine-generated sequel to Take 5.
09:09:58 <mreh> you still need to learn the alphabet before you can write tolstoy
09:10:02 <copumpkin> lol
09:10:03 <lament> I think such a method can only make you *worse* at improvising
09:10:20 * copumpkin hasn't heard much music with a 7 in its time signature
09:10:31 <copumpkin> but then again, I stick to old stuff
09:10:34 <lament> you will concentrate on mechanical aspects instead of the creative aspects...
09:10:34 <DaveS> How exactly are new melodies invented aside from people permuting shit
09:10:35 <mreh> copumpkin: there's a good reason for that
09:10:37 <lament> copumpkin: Pink Floyd, Money
09:10:42 <DaveS> and doing the old "Yeah, that sounds good" routine
09:10:48 <dmwit> I've played a few 7/4 tunes.
09:10:54 <copumpkin> lament: haven't listened to any pink floyd
09:10:57 <copumpkin> dmwit: what do you play?
09:11:09 <dmwit> I play piano first, but those were on the xylophone.
09:11:15 <copumpkin> aha
09:11:20 <lament> copumpkin: oh, what do you mean by old stuff then? Older than Bartok?
09:11:33 * DaveS would like to do a blind test with some of these jazz snobs to see if they can actually tell the difference between a computer and a human peice
09:11:52 <mreh> DaveS: are you refering to me?
09:11:53 <dmwit> DaveS: Do you have some computer jazz?  That seems like an important first step.
09:12:03 <DaveS> Not you specificially
09:12:05 <copumpkin> lament: the latest I go is rachmaninoff
09:12:06 <mreh> there's something called Fuge, but it sounds shit
09:12:07 <lament> DaveS: They might fail the test if the human thing is by someone trained to improvise like mreh
09:12:13 <copumpkin> lament: so roughly the same time as bartok, but not a fan of bartok :P
09:12:15 <mreh> lament hates me
09:12:18 <lament> mreh: yes.
09:12:45 <lament> hm, can't think of any classical pieces in 7
09:13:00 <lament> tchaikovski has a very nice waltz in 5
09:13:11 <c_wraith> it's quite rare to find a classical piece from before 1800 in an odd time signature other than 3
09:13:19 <mreh> I'm not going to have a laptop make music for me!! the melodies it dervies it's lines from will be written by men and women like you and me, and the progressions have to be supplied by someone
09:13:20 <ACSpike[Home]> Emily Howell
09:13:50 <copumpkin> lament: some of the weirdest time signatures I can think of in music I like are in beethoven's 32nd sonata's second movement
09:13:51 <c_wraith> More recent classical music has explored odd time signatures much more.  Mars, Bringer of War is a favorite of mine, and in 5/4
09:14:03 <lament> mreh: Exactly. Imagine mona lisa cut up into little pieces and stiched back together
09:14:05 <mreh> lament, I think you're imagining a brave new world scenario, of computer made music
09:14:10 <copumpkin> lament: oh and one of rachmaninoff's preludes is in 5
09:14:43 <mreh> you're so overreacting
09:14:46 <lament> mreh: no, i imagine you personally concentrating more on the mechanistic aspects of improvisation than on listening
09:14:51 * DaveS notes that most popular music today is written by formula and people enjoy it just fine
09:15:06 <mauke> lament: and how is that a bad thing?
09:15:16 <copumpkin> Op. 32 # 5
09:15:21 <mreh> you need to learn the mechanistic bits too!
09:15:51 <mreh> I can't play beautiful melodies with just my ear as a crutch
09:15:55 <lament> mauke: it's a very programmerish thing that programmer musicians are often guilty of. It leads to sounding like a computer.
09:16:01 <mreh> I need to know where the notes are
09:16:02 <mauke> lament: and how is that a bad thing?
09:16:12 <copumpkin> lament: I like listening to music that sounds like a computer, sometimes
09:16:16 <copumpkin> :P
09:16:22 <lament> mauke: You might have a point, but I doubt it.
09:16:25 <mreh> lament: you're moralising
09:16:29 <mreh> it isn't a moral issue
09:16:54 <lament> mreh: i'm not moralizing, I just think you're doing something detrimental to your development
09:17:04 <roconnor> copumpkin:
09:17:04 <lament> i.e. screwing yourself over
09:17:05 <roconnor> > take 3 (unLazyList (decode (encode (LazyList [1::Int ..])))) :: [Int]
09:17:08 <roconnor> [1,2,3]
09:17:08 <lambdabot>   Not in scope: `unLazyList'Not in scope: `decode'Not in scope: `encode'Not i...
09:17:21 <roconnor> copumpkin: now we know why decode doesn't return Maybe
09:17:28 <roconnor> copumpkin: dons can have his job back
09:17:29 <ACSpike[Home]> http://www.npr.org/templates/story/story.php?storyId=113719483
09:17:35 <copumpkin> roconnor: wait, why not?
09:17:38 <mreh> it isn't in your interests to tell me what to do
09:17:40 <tensorpudding> copumpkin: what does a computer sound like?
09:18:04 <jlouis> tensorpudding: computers play fur elise
09:18:05 <copumpkin> tensorpudding: when thinking of computerish music, I either think of glassworks or infected mushroom
09:18:20 <roconnor> copumpkin:take 3 (unLazyList (spoon (decode (encode (LazyList [1::Int ..]))))) :: [Int]  doesn't terminate
09:18:27 <roconnor> er
09:18:33 <copumpkin> roconnor: does
09:18:34 <mreh> mmorrow: are you still there?
09:18:34 <copumpkin> ?
09:18:46 <roconnor> copumpkin:take 3 (unLazyList (fromJust (spoon (decode (encode (LazyList [1::Int ..])))))) :: [Int]  doesn't terminate
09:18:46 <mmorrow> mreh: yes
09:18:51 <lament> mreh: er, ok, good luck i guess
09:18:57 <sproingie> that's some serious parenthesis there
09:18:59 <copumpkin> roconnor: oh, I see
09:19:02 <sproingie> the $ operator is your friend
09:19:06 <copumpkin> roconnor: teaspoon would work though
09:19:24 <copumpkin> but wouldn't buy you much error-wise
09:19:27 <roconnor> copumpkin: yes, but teaspoon is stupid.
09:19:36 <copumpkin> :(
09:19:37 <mreh> mmorrow: would it be in your interests to share code with me?
09:19:54 <copumpkin> mreh: that sounds like a threat, phrased as a question :)
09:20:05 <tensorpudding> copumpkin: when i think of computer music i think of kraftwerk
09:20:06 <mreh> I know people
09:20:16 <copumpkin> tensorpudding: that's old-school!
09:20:24 <copumpkin> I guess philip glass is probably older
09:20:49 <lament> http://uncyclopedia.wikia.com/wiki/Philip_Glass
09:20:53 <mmorrow> mreh: (although i'm not sure how you mean "in my interests", but) sure, although that Beep module is really the only music-related code i've written really
09:20:56 <roconnor> copumpkin: my encoding of lazyList has an extra byte per item in the list.
09:21:03 <tensorpudding> some guy made a theremin app in Java, that uses IR sensors and wiimotes
09:21:06 <copumpkin> roconnor: I see
09:21:10 <mreh> lament: using technology to learn isn't a bad thing, I don't see what the objection is really
09:21:29 <copumpkin> lol
09:21:30 <roconnor> copumpkin: but it is good that it can be written.
09:21:43 <copumpkin> mreh: "it's not how it's been done for centuries, and is thus bad"
09:21:44 <lament> mreh: What are you learning?
09:21:54 <copumpkin> you must sweat blood!
09:21:56 <lament> mreh: i mean, what do you expect to learn from this?
09:22:01 <copumpkin> learn it the good old-fashioned way!
09:22:09 * ddarius doesn't like the sound of the theremin.
09:22:12 * copumpkin doesn't improvise at all, for what it's worth
09:22:19 <mreh> mmorrow: alright, if it's nothing you're working on right now we dont need to bother
09:22:23 <copumpkin> ddarius: what about weird eerie alien music?
09:22:29 <mmorrow> mreh: :o
09:22:33 * mreh i think lament is a neo-luddite
09:22:44 * ddarius is a neo-neo-Luddite.
09:22:46 <DaveS> copumpkin: Anything eastern...
09:22:51 <lament> mreh: instead of insults, you could answer my question.
09:23:06 <mreh> i am not getting into a flame war
09:23:07 <ddarius> copumpkin: Not something I would want to listen to for even three minutes.
09:23:07 <tensorpudding> the theremin has an odd sound to it
09:23:11 <copumpkin> I have some rachmaninoff played on a theremin by clara rockmore
09:23:14 <copumpkin> it's weird
09:23:15 <tensorpudding> i think i'd get tired of it eventually
09:23:23 <lament> mreh: then why did you say "I don't see what the objection is"?
09:23:26 <mmorrow> mreh: i'm not sure how to take your response "we don't need to bother", but i hope you're not letting lament piss you off :)
09:23:26 <ddarius> It's more monotonous than "odd"
09:23:46 <lament> mreh: Because I don't object to the use of technology at all.
09:23:47 <copumpkin> I'd still like to play with one for a while
09:23:55 <mreh> mmorrow: if  you don't want to work on music projects, you don't have to
09:23:59 <lament> mreh: I have no idea where you're getting that from.
09:24:07 <mmorrow> mreh: anyways, i'd be interested in exchanging ideas and code for sure
09:24:10 <copumpkin> http://www.youtube.com/watch?v=WPZQi2m7i9Y
09:24:18 <ddarius> copumpkin: It'd probably be fun to fiddle with for a few minutes, but it doesn't seem like a fun instrument to play or listen to.
09:24:36 <tensorpudding> needs more armonica
09:24:41 <copumpkin> lol
09:24:55 <mreh> http://www.youtube.com/watch?v=FcZ2NcCEC0o
09:25:23 <copumpkin> it's a prettier piece on solo piano
09:25:28 <mmorrow> mreh: i'm just saying that i'm not currently working on any music-related projects at the moment, not to say i'm not interested in doing so (time permitting/etc)
09:25:42 <ddarius> copumpkin: blech
09:25:54 <copumpkin> ddarius: the solo piano bit, or the theremin version?
09:25:59 <mreh> mmorrow: okay, what's the best way to collab online?
09:26:06 <copumpkin> mreh: ZOMG GOOGLE WAVE
09:26:07 <copumpkin> ;)
09:26:07 <mreh> we can set up something, mibbit?
09:26:31 <mmorrow> mreh: how do you mean collaborate here?
09:26:38 * mmorrow doesn't know what mibbit is :)))
09:26:39 <ddarius> copumpkin: theremin
09:26:43 <mmorrow> sticky keys..
09:26:47 <ddarius> mreh: blech to your link as well
09:26:57 <mreh> :D
09:27:02 <mreh> it's awful isnt it
09:27:12 * copumpkin is recovering from the theremin by listening to the real thing on piano
09:27:12 <mreh> i was just winding lament up
09:27:25 <lament> i really don't understand what's going on here
09:27:34 <mmorrow> lament: the sky is falling!
09:27:44 <lament> mreh: why are you attacking me?
09:27:51 <mreh> lament: awwwww
09:27:57 <mreh> I'm not!
09:28:41 <mreh> mmorrow: a repo for code might be a good idea
09:28:45 <scalaLove> today has been great huskell study day, thank you all, good night :)
09:28:51 <mreh> hackage?
09:28:52 <copumpkin> scalaLove: yay!
09:29:05 <mreh> \o/
09:29:07 <mmorrow> mreh: right, that's more along the lines of what i was thinking
09:29:25 <mreh> schweet
09:29:50 <mmorrow> mreh: do you have in mind a mutually writable repo? if so and if you have a code.haskell.org account we could put one there
09:30:32 <mreh> well, i suppose we need a high level goal for a library
09:30:44 <copumpkin> mreh: save the world?
09:30:45 <mmorrow> true
09:30:46 <ddarius> Just do it all in hpaste pastes.
09:30:58 <mmorrow> yeah, ddarius's idea is good too
09:30:58 <mreh> ddarius: are you high>
09:31:01 <mmorrow> heh
09:31:04 <copumpkin> lol
09:31:15 <SamB_XP> ddarius: and lose it all in the next wipe and/or when they forget the numbers ?
09:31:26 * copumpkin imagines a high ddarius typing on IRC while crocheting
09:31:27 <c_wraith> SamB_XP: hpaste has search!
09:31:40 <ddarius> Google indexes hpaste.
09:31:50 <mreh> we are not using hpaste!
09:32:03 <mmorrow> :)
09:32:03 <c_wraith> But it has revision history!
09:32:04 <mreh> i'll set up a hackage account
09:32:11 <ddarius> copumpkin: If that girl would give me back that hat so I could lengthen it, I would be crocheting (but not high)
09:32:27 <mreh> what do I actually need to do to set up a hackage account?
09:32:30 <mmorrow> lament: what license does your chord parser have?
09:32:33 <copumpkin> ddarius: I guess drugs and armed forces don't mix very nicely?
09:32:49 <mreh> of course it would be really helpful if lament would help us
09:32:57 <mreh> his chord parser looks really good
09:33:03 <DaveS> What is a 'trivial constructor' ?
09:34:00 <ddarius> copumpkin: That's one way to become Civilian Below The Zone.
09:34:33 <mmorrow> ddarius: how long do you have left?
09:35:02 <mmorrow> (or are you re-upping?)
09:37:05 <mreh> it doesn't seem there are any libraries on hackage for music composition
09:37:21 <SamB_XP> @google haskore
09:37:22 <lambdabot> http://www.haskell.org/haskore/
09:37:22 <lambdabot> Title: The Haskore Computer Music System
09:37:38 <SamB_XP> dunno if that's exactly the sort of composition that you meant, but ...
09:37:42 <ddarius> mmorrow: About 8 months.
09:38:17 <mmorrow> ddarius: snap
09:38:38 <mreh> SamB_XP, well it doesn't do chord parsing, and automatic score generation
09:38:47 <mreh> that's the kind of thing I'm interested in
09:39:05 <mmorrow> mreh: i've gotta disappear, but i'm always in here..
09:39:08 <SamB_XP> oh, so some kind of hillypond type thing ?
09:39:18 <SamB_XP> (made up name)
09:39:26 <mreh> mmorrow: alright, i'm setting up an account
09:39:33 <mreh> (requesting)
09:40:04 <mreh> hopefully lament will let us use his parser
09:40:17 <SamB_XP> lamentably, no
09:42:27 <mreh> what was he doing with the music parser anyway>
09:42:32 <mreh> making computer music?
09:43:16 <mreh> Hackage is entirely open source isnt it?
09:43:45 * SamB_XP was kidding with that "lamentably, no" bit, btw
09:44:16 <SamB_XP> mreh: you'll find that the free free software license is rather restrictive
09:44:49 <SamB_XP> in fact, I'm not sure if there IS one
09:44:50 <mreh> SamB_XP, well Richard Stallman isn't involved here is he
09:45:07 <nominolo> preflex: seen edwardk
09:45:07 <preflex>  edwardk was last seen on #haskell 8 hours, 28 minutes and 27 seconds ago, saying: scalaLove: data includes the tag, remember it provides a series of alternatives not just a binding for a tuple
09:45:26 <SamB_XP> mreh: do you know what "the free free software license" means ?
09:45:49 <SamB_XP> it is like "the free monad"
09:45:56 <mreh> no idea
09:46:01 <kmc_> @pl \xs -> zip xs $ tail xs
09:46:02 <ddarius> mreh: Everything on Hackage is (necessarily) open source.
09:46:02 <lambdabot> ap zip tail
09:46:47 <mreh> http://www.youtube.com/watch?v=I25UeVXrEHQ
09:48:27 <sm> evening all.. I'm spending too much time tracking down  "Map.find: element not in the map" runtime error. +RTS -xc doesn't help in this case. Question: what *is* Map.find ? I don't find that function in Data.Map
09:49:41 <kmc_> @check \n -> (== (sqrt n)) . fst . head . dropWhile (uncurry (/=)) . (zip <*> tail) $ iterate (\y -> (y+(n/y))/2) 1
09:49:46 <lambdabot>   mueval-core: Time limit exceeded
09:49:56 <kmc_> sm, what are you using to index maps?
09:50:12 <sm> kmc_: strings I believe
09:50:18 <kmc_> i mean what function
09:50:26 <kmc_> do you have a smallish code snippit you could put on hpaste?
09:52:21 <kmc_> (!) is an alias for find
09:52:25 <sm> alas no, if only I could locate the code snippet
09:52:34 <kmc_> and it's unsafe in the same sense as the prelude's "head"
09:52:38 <sm> ok, I think that helps - thank you
09:53:09 <kmc_> it has a precondition that can't be checked statically, and throws a runtime error if it doesn't hold
09:53:13 <sm> makes sense, I just thought the error would show names from the api
09:53:46 <kmc_> it's usually better to use Map.lookup
09:58:50 <sm> good tip, I will do
10:00:55 <sm> strange that instrumenting all ! in my code with trace doesn't show it thouh
10:01:23 <SamB_XP> sm: try Violin
10:01:39 <copumpkin> sm: is it getting evaluated?
10:01:59 <sm> haskell Violin not googleable alas
10:02:12 <SamB_XP> sm: sorry, was a MIDI joke
10:02:39 <sm> copumpkin: several of my ! sites are evaluated, but in all cases I see both the before trace and the after trace, so I think none of them is the failing one
10:03:01 <SamB_XP> tried -xc yet ?
10:03:40 <sm> yes, but the context seems to be obscured by parsec
10:04:35 <sm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13778
10:07:12 <sm> in fact that paste looks like two different "strack traces" one after the other, I wonder why that is
10:08:24 <SamB_XP> sm: could it be that you get more than one exception thrown ?
10:08:56 <sm> it should stop after one, no ?
10:08:58 <ddarius> > fix error
10:08:59 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
10:09:22 <SamB_XP> sm: not if it got caught after!
10:09:26 <SamB_XP> this is not CL
10:10:18 <copumpkin> > fix (interleave [0..])
10:10:19 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
10:11:13 <copumpkin> > map head . iterate (drop 2) $ fix (interleave [0..])
10:11:14 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
10:11:25 <copumpkin> > map (head . tail) . iterate (drop 2) $ fix (interleave [0..])
10:11:27 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
10:11:42 <copumpkin> that's a cute sequence
10:15:14 <ddarius> > iterate (map (\cs -> show (length cs) ++ head cs) . group) "1"
10:15:16 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:15:16 <lambdabot>         against inferred ty...
10:15:28 <ddarius> > iterate (map (\cs -> show (length cs) ++ take 1 cs) . group) "1"
10:15:29 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:15:29 <lambdabot>         against inferred type...
10:16:07 <copumpkin> lambdabot's error messages are so helpful
10:16:55 <roconnor> copumpkin: actually teaspoon could be useful as a means to give users control over how much sequencing to do.
10:17:18 <ddarius> > iterate (concatMap (\cs -> show (length cs) ++ take 1 cs) . group) "1"
10:17:19 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
10:17:51 <copumpkin> roconnor: in its current form it seems like it would be hard to use to get something unpainful though
10:17:58 <copumpkin> dunno
10:18:09 <copumpkin> show and tell!
10:18:23 <copumpkin> @pl iterate (concatMap (\cs -> show (length cs) ++ take 1 cs) . group) "1"
10:18:24 <lambdabot> iterate ((ap ((++) . show . length) (take 1) =<<) . group) "1"
10:18:31 <copumpkin> ew
10:19:00 <copumpkin> > iterate (liftA2 (++) (show . length) (take 1) <=< group) "1"
10:19:01 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
10:19:36 * copumpkin grins
10:19:55 <Axman6> reminds me of a joke i heard as a kid... 'one one was a race horse, two two was one too. one one won one race, two two won one too"
10:22:49 <copumpkin> > iterate (read . (liftA2 (++) (show . length) (take 1) <=< group) . show) 1
10:22:50 <lambdabot>   [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,132113111231...
10:23:01 <copumpkin> I wonder if the sequence can be defined concisely numerically
10:23:27 <copumpkin> probably not
10:23:29 <ddarius> I'd thought I'd seen such a definition, but it isn't obviously listed in the OEIS entry.
10:28:09 <roconnor> @oesis 1,11,21,1211,111221,312211,13112221,
10:28:10 <lambdabot>  Look and Say sequence: describe the previous term! (method A - initial term ...
10:28:11 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
10:28:28 <copumpkin> that's what I meant :P
10:29:04 * copumpkin looks almost embarrassed as he was when he said data types à la mode for swierstra's functional pearl, instead of à la carte
10:29:48 <roconnor> copumpkin: did you look at the wikipedia article?
10:30:09 <copumpkin> aha, no
10:30:11 <copumpkin> I didn't realize it had one
10:30:57 <copumpkin> that's a pretty epic equation to solve
10:31:05 <copumpkin> it only has three real roots :O
10:37:26 <Cale> It's a bit irritating that they'd write the polynomial that way. There must be a nicer form of it.
10:38:12 <Cale> I refuse to believe that Conway just pulled that one out from the otherways side of his polytope-hat.
10:39:13 <copumpkin> yeah
10:39:35 <copumpkin> I also wonder where the massive equation for all the primes came from
10:39:41 * SamB_XP wants to read spork(2)
10:43:05 <dolio> Is every power of x up to 71 except 70 used?
10:43:39 <dolio> And by used I mean has-a-non-zero-coefficient.
10:44:10 <dolio> Oh, no, 22 is missing, too.
10:44:13 <roconnor> > sqrt (1-4/300^4)
10:44:19 <lambdabot>   0.9999999997530864
10:44:24 <mreh> it's so late
10:44:24 <roconnor> > sqrt (1-4/300^4) :: CReal
10:44:29 <mreh> i'm going to bed, cheers guys
10:44:30 <dolio> And 8.
10:44:38 <lambdabot>   0.9999999997530864197226032616903851979783
10:47:32 <copumpkin> > filter (/= 1) . ap (zipWith subtract) tail . map snd . iterate (\(i, n) -> (succ i, n + gcd i n)) $ (1, 7)
10:47:37 <lambdabot>   mueval-core: Time limit exceeded
10:47:42 <copumpkin> does anyone know why that is?
10:47:52 <copumpkin> > ap (zipWith subtract) tail . map snd . iterate (\(i, n) -> (succ i, n + gcd i n)) $ (1, 7)
10:47:53 <lambdabot>   [1,2,1,1,1,1,7,1,1,1,1,1,13,1,5,1,1,1,1,1,1,1,1,1,1,1,1,1,29,3,1,1,1,1,1,1,...
10:47:56 <copumpkin> that works fine
10:48:01 <copumpkin> and there are non-1 values early on
10:49:30 <SamB_XP> > take 10 $ filter (/= 1) . ap (zipWith subtract) tail . map snd . iterate (\(i, n) -> (succ i, n + gcd i n))
10:49:31 <lambdabot>   Couldn't match expected type `[[(a, b)]]'
10:49:32 <lambdabot>         against inferred type `(t...
10:49:43 <SamB_XP> > take 10 (filter (/= 1) . ap (zipWith subtract) tail . map snd . iterate (\(i, n) -> (succ i, n + gcd i n)))
10:49:45 <lambdabot>   Couldn't match expected type `[[(a, b)]]'
10:49:45 <lambdabot>         against inferred type `(t...
10:49:53 <copumpkin> > take 10 . filter (/= 1) . ap (zipWith subtract) tail . map snd . iterate (\(i, n) -> (succ i, n + gcd i n)) $ (1, 7)
10:49:55 <lambdabot>   [2,7,13,5,29,3,59,3,7,5]
10:49:58 <copumpkin> weird
10:50:24 <copumpkin> lambdabot not being lazy enough?
10:50:30 <SamB_XP> > take 20 . filter (/= 1) . ap (zipWith subtract) tail . map snd . iterate (\(i, n) -> (succ i, n + gcd i n)) $ (1, 7)
10:50:31 <lambdabot>   [2,7,13,5,29,3,59,3,7,5,3,131,3,263,3,17,3,5,3,19]
10:50:35 <SamB_XP> > take 100 . filter (/= 1) . ap (zipWith subtract) tail . map snd . iterate (\(i, n) -> (succ i, n + gcd i n)) $ (1, 7)
10:50:39 <lambdabot>   mueval-core: Time limit exceeded
10:50:45 <SamB_XP> > take 50 . filter (/= 1) . ap (zipWith subtract) tail . map snd . iterate (\(i, n) -> (succ i, n + gcd i n)) $ (1, 7)
10:50:46 <lambdabot>   [2,7,13,5,29,3,59,3,7,5,3,131,3,263,3,17,3,5,3,19,569,3,17,3,13,7,5,3,1181,...
10:50:55 <SamB_XP> copumpkin: I guess so!
10:51:11 <copumpkin> > map head . group . sort . take 50 . filter (/= 1) . ap (zipWith subtract) tail . map snd . iterate (\(i, n) -> (succ i, n + gcd i n)) $ (1, 7)
10:51:12 <lambdabot>   [2,3,5,7,11,13,17,19,29,53,59,131,263,569,1181,2381,4787]
10:52:02 <copumpkin> I really hate it when papers say "It can be shown that" without providing a citation
10:52:18 <SamB_XP> copumpkin: oh, yeah
10:52:44 <SamB_XP> or at least something like "by transitivity"
10:53:14 <copumpkin> well often it's something that's far from obvioius
10:53:34 <copumpkin> I don't expect them to give me a proof or even an outline, but at least let me look it up if I'm interested
10:55:37 <ddarius> "It can be shown that, for all n > 2, x^n + y^n /= z^n for x,y,z in N-{0}"
10:55:57 <ivanm> heh
10:55:59 <copumpkin> hah
10:56:10 <copumpkin> I downloaded wiles' proof of that the other day
10:56:20 <copumpkin> way over my head, but maybe one day I'll be able to get some of it
10:57:05 <ivanm> copumpkin: "some of it" == "abstract"? :p
10:57:18 <copumpkin> let's hope so ;)
10:58:36 <stefstef> records and  enums are both declared with Data, but they are different only in that Enum's constructors have no arguments, correct?
10:59:34 <copumpkin> I've never heard anyone make a distinction like that
10:59:49 <luite> Cale: Conway's constant is the largest eigenvalue of a 92x92 transition matrix, based on recurring sequences or something (unfortunately I cannot find the original paper), so I guess that's where the polynomial showed up
11:00:22 <copumpkin> luite: giant inexplicable polynomials make for better pop-math, anyway
11:00:23 <Draconx> copumpkin, there's a paper in complex analysis (I've forgotten exactly which one) which said something along the lines of "Lemma 1 follows from the embarrasingly simple argument: <ridiculous complex analysis here>."
11:00:25 <fracture> so, if I have something like data Foo { fooB :: Int, fooC :: Int } and an object "a" of type Foo, apparently I can type a { fooB = 12 } to make a new Foo just changing fooB
11:00:34 <copumpkin> Draconx: proof by intimidation!
11:00:37 <fracture> however C-style += and -= type stuff doesn't work---is there any terse way to do that?
11:00:48 <BMeph> bos/augustss: ping
11:01:06 <copumpkin> BMeph: neither of them are in here :P
11:01:13 <roconnor> > sqrt (1-1/(300^4/4)) :: CReal
11:01:15 <lambdabot>   0.9999999997530864197226032616903851979783
11:01:16 <ivanm> preflex: seen bos
11:01:17 <preflex>  bos was last seen on #haskell 5 hours, 13 minutes and 13 seconds ago, saying: Nafai: nothing that i know of
11:01:22 <ivanm> preflex: seen augustss
11:01:22 <preflex>  augustss was last seen on #haskell 99 days, 14 hours, 39 minutes and 50 seconds ago, saying: I was thinking of hac7 :)
11:01:30 <roconnor> > sqrt (1-1/(1+300^4/4)) :: CReal
11:01:31 <copumpkin> dayum
11:01:32 <lambdabot>   0.9999999997530864198445358938809764395458
11:01:46 <BMeph> copumpkin: Thanks. :\
11:01:49 <copumpkin> scalaLove: when will that turn into haskellove?
11:02:04 <scalaLove> soon :)
11:02:13 <copumpkin> BMeph: bos is tweeting away though, if you want to ping him there
11:03:20 <BMeph> compumpkin: Good eye. So, how did you like my qsort, pt. deux? :)
11:04:52 <copumpkin> BMeph: twas excellent!
11:05:10 <Axman6> preflex: seen JaffaCake
11:05:11 <preflex>  JaffaCake was last seen on #ghc 16 hours, 15 minutes and 31 seconds ago, saying: Trac still refusing edits
11:05:40 <luite> bah 4am, cannot sleep and have to attend 7 hours of talks about combinatorial optimization and treewidth tomorrow, this cannot end well...
11:06:13 <copumpkin> luite: use a hammer!
11:06:17 <copumpkin> best way to get to sleep
11:06:29 <ivanm> or a brick wall
11:06:39 <ivanm> luite: s/tomorrow/today/ ?
11:06:45 <luite> ivanm: uhm yes :p
11:22:02 <brooksbp> hello
11:22:11 <SmurfOR> hi
11:22:33 <brooksbp> how does (\a. a+1)(\b. b+2) eval to in the lambda calculus?
11:22:51 <monochrom> (\b.b+2)+1
11:22:53 <brooksbp> i.e. what happens when you have an application where both terms were lambda's
11:23:12 <brooksbp> what's the use of applying functions to functions?
11:23:13 <monochrom> you don't care what's "inside" the second term.
11:23:24 <monochrom> @src map
11:23:25 <lambdabot> map _ []     = []
11:23:25 <lambdabot> map f (x:xs) = f x : map f xs
11:23:33 <monochrom> is the use of applying functions to functions
11:23:51 <monochrom> @src fix
11:23:52 <lambdabot> fix f = let x = f x in x
11:23:55 <monochrom> is another use
11:26:44 <brooksbp> I'm trying to implement an SECD machine... and I don't think I'm handling this case of applying a lambda to another lambda
11:26:50 <Cale> brooksbp: It's possible to formulate the lambda calculus such that there are only variables, applications and lambdas. It's actually possible to define numbers and operations on them, and do all computation inside the untyped lambda calculus.
11:26:58 <HaskellLove> can you guys give me one sentence explanation of classes in haskell? I am imperative guy, so it would help me to hear "how u think of a class in haskell"?
11:27:12 <Cale> HaskellLove: You mean typeclasses?
11:27:22 <ivanm> HaskellLove: they're a way of providing ad-hoc polymorphism
11:27:38 <brooksbp> the machine transforms... and then it runs into the case where it tries to evaluate a + op and tries to add the lambda to an integer
11:28:01 <Cale> I hate that word "ad-hoc" in this context.
11:28:01 <HaskellLove> I mean this type of classes .... class Eq a where bla bla bla
11:28:20 <Cale> The original paper indeed was called "How to make ad-hoc polymorphism less ad-hoc", but that's the whole point -- it's *not* ad-hoc polymorphism anymore :)
11:28:35 <ivanm> oh...
11:28:37 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13780#a13780
11:28:41 <ivanm> you mean I described it wrong in my paper? :s
11:28:44 <brooksbp> Am I missing a case where (\b.b+2)+1 should be recognized as normal and then return... right now my machine continues to evaluate that +... and errs
11:29:01 <Cale> HaskellLove: Right. Think of typeclasses as essentially being predicates on types
11:29:13 <ivanm> brooksbp: well, you need to provide a value for the lambda there...
11:29:24 <ivanm> so my guess it itsn't typed properly (unless you have + defined on functions)
11:29:26 <HaskellLove> Cale: that's fair...
11:29:26 <Cale> HaskellLove: Predicates which when they are true of some type, imply that there's some interface of functionality present
11:29:38 <monochrom> I already implemented SECD. No special treatment to "second guy being lambda" really.
11:30:03 <HaskellLove> Types and classes are not the same thing. A class is a "template" for types. Again this is unlike most OO
11:30:04 <Cale> For example, the constraint (Eq t) means that t must be a type which supports equality comparison
11:30:05 <HaskellLove> languages, where a class is also itself a type.
11:30:16 <HaskellLove> Then why do you call a class, type class?
11:30:39 <Cale> HaskellLove: Well, you can literally think of it as a class, that is, a collection, of types.
11:30:42 <monochrom> (\b.b+2)+1 is really just a case of garbage-in garbage-out. User dares to give you this nonsensical input, you can do whatever you want.
11:30:57 <Cale> HaskellLove: So there's some collection of types Eq which support equality comparison
11:31:11 <Cale> and another collection of types Ord which support ordering comparisons
11:31:11 <brooksbp> monochrom: that's the problem I'm running into... I'm trying to evaluate ((\a.a+2) (\b.b*4)) 5
11:31:22 <ivanm> HaskellLove: class is short for "type class" ;-)
11:31:24 <Cale> and yet another collection of types Num which support numeric operations
11:31:32 <ivanm> monochrom: heh
11:31:45 <brooksbp> monochrom: so you're saying the grammar allows this input, but it's going to evaluate to nothing usable
11:31:48 <ivanm> brooksbp: well, there isn't a sensible evaluation AFAICT...
11:32:00 <Cale> HaskellLove: In OO, the word 'class' is used to refer to a class, or collection, of objects.
11:32:05 <monochrom> I would rather evaluate (\a.a+2) ((\b.b*4) 5)
11:32:09 <brooksbp> ivanm: so I don't have to worry... I guess I've implemented SECD then
11:32:12 <Cale> HaskellLove: That is, it's more or less the same thing as a type.
11:32:19 <HaskellLove> Cale: How about this: A class provides functionality, it can contain like 100 functions... A type can support that class and so, when you make instance of that type you can use the original class functionality,correct?
11:32:21 <Cale> (since objects are values)
11:32:36 <brooksbp> Are there any good 'special cases' of the LC that I can test on my SECD machine
11:32:45 <monochrom> You know, "type system" is invented for a good reason...
11:32:57 <monochrom> (\x. x x) (\x. x x)
11:33:06 <Cale> HaskellLove: To understand the purpose of typeclasses, I think it's good to first understand normal parametric polymorphism, that is, the appearance of type variables in types.
11:33:14 <brooksbp> monochrom: it should just run forever?
11:33:14 <ddarius> I also dislike referring to type class polymorphism as "ad-hoc polymorphism."  In fact, I just dislike the term "ad-hoc polymorphism" altogether.
11:33:23 <HaskellLove> Cale, I do
11:33:31 <monochrom> Yes. But it is also a good "coverage test".
11:33:38 <ddarius> augustss needs to join.
11:33:38 <Cale> HaskellLove: So, you're familiar with how we have   length :: [a] -> Integer,  say?
11:33:54 <Cale> HaskellLove: Or  map :: (a -> b) -> [a] -> [b]
11:34:00 <HaskellLove> yep
11:34:05 <monochrom> Hmm where is my Y-combinator...
11:34:58 <Cale> In these cases, the function works regardless of the types a and b since its implementation does nothing to observe or depend on the values of those types
11:35:09 <Cale> So, how about sorting a list?
11:35:21 <Cale> You might initially think a type like  [a] -> [a] would be fine
11:35:31 <Cale> But then you find out that's not quite enough
11:35:33 <Lemmih> Are the authors of the 'spoon' package here?
11:35:42 <Cale> You also need a way to compare values of type a for ordering
11:35:56 <monochrom> Oh, also test on church numerals.
11:35:59 <Cale> So, we refine that to (Ord a) => [a] -> [a]
11:36:27 <Cale> which says that a can be any type which supports the operations of the Ord class
11:36:35 <HaskellLove> I am confused because Data provides enough functionality, I mean you can do this Data Love a b with a b as parameters, what more can you want? So it confuses me having this one more abstraction above this with Class
11:36:39 <ddarius> Lemmih: Yes.
11:36:41 <Cale> (which are (<), (<=), (>), (>=), and compare)
11:37:00 <Cale> HaskellLove: hm?
11:37:14 <aavogt> HaskellLove: data is closed, class is open
11:37:14 <Cale> HaskellLove: How might you solve the problem of giving a type to the sort function?
11:37:24 <monochrom> (\f. (\x. f (x x)) (\x. f (x x))) is the Y combinator.  (\f. (\x. f (x x)) (\x. f (x x))) (\y. 5) should give you 5 because it is "fix (const 5)"
11:37:30 <Cale> HaskellLove: Of course, you could always pass an extra parameter
11:37:40 <Cale> sort :: (a -> a -> Ordering) -> [a] -> [a]
11:37:50 <HaskellLove> aavogt: can you give me more on that, i think i am close to understand u there
11:38:10 <Cale> HaskellLove: But this is mildly inconvenient in the case of sorting, and *very* inconvenient when it comes to writing arithmetic expressions
11:38:25 <Cale> HaskellLove: Does that make sense?
11:38:47 <HaskellLove> not really :( ok i will leave this as note and keep reading, thank you so far
11:38:49 <Cale> HaskellLove: So even though you could write  data Comparison a = C (a -> a -> Ordering)
11:39:01 <Lemmih> ddarius: Can you tell them that 'return $! a' is dangerous and to use 'evaluate' instead?
11:39:05 <Cale> HaskellLove: Or otherwise, bundle a bunch of functions into a piece of data
11:39:28 <eldragon> SECD is the worst machine of the story
11:39:35 <copumpkin> Lemmih: me?
11:39:56 <ddarius> copumpkin: Use evaluated instead of return $!
11:40:01 <Cale> HaskellLove: The hard part is that you then have to pass those records around by hand, and it can become rather tricky. The nice thing about typeclasses is that the type system ensures that these operations are available where they're needed.
11:40:03 <ddarius> s/evaluated/evaluate
11:40:07 <copumpkin> :)
11:40:13 <eldragon> names that sounds similar to Landin, Lamping, etc. give horrible unexpected notices you.
11:40:59 <copumpkin> @hoogle evaluate
11:41:00 <lambdabot> Control.Exception evaluate :: a -> IO a
11:41:00 <lambdabot> Control.OldException evaluate :: a -> IO a
11:41:00 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
11:41:09 <ddarius> "A Combinatory Account of Internal Structure" or A Combinatory Logic for the Pattern Calculus.
11:41:56 <copumpkin> Lemmih: what's the difference? I'll change it, but just curious. And how does the normal form one get affected?
11:42:14 <Lemmih> ddarius: Tell copumpkin that the compiler is free to hoist the strictness out of the 'catch' if he uses $!.
11:42:19 <copumpkin> lol
11:42:31 <copumpkin> ddarius: can you tell Lemmih that it's fine to speak to me directly?
11:43:12 <HaskellLove> Cale: so far I understand this: with a class you capture functionality. A type can derive from one or many classes, same as multiple inheritance in OOP... it is enough i will keep reading and get back to classes...
11:43:34 <Lemmih> copumpkin: See http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Aevaluate
11:43:39 <copumpkin> Lemmih: so instead of Just `fmap` (return $! a) it'd be Just fmap evaluate a ?
11:43:44 <Cale> HaskellLove: It's best that you not think of Haskell classes as OO classes.
11:44:05 <Cale> HaskellLove: If you absolutely *must* compare them to something in the OO world, compare them to Java interfaces.
11:44:07 <HaskellLove> Cale: I think of them as collections of functions thats all
11:44:18 <HaskellLove> exactly :)
11:44:21 <copumpkin> HaskellLove: what about classes with no methods? :P
11:44:24 * copumpkin whistles
11:44:26 <Cale> HaskellLove: But they're rather more awesome than Java interfaces.
11:44:27 <Lemmih> copumpkin: Right.
11:44:35 <Cale> > read "12" :: Integer
11:44:36 <lambdabot>   12
11:44:39 <Cale> :t read
11:44:41 <lambdabot> forall a. (Read a) => String -> a
11:44:49 <Cale> > read "[1,2,3]" :: [Integer]
11:44:51 <lambdabot>   [1,2,3]
11:45:01 <copumpkin> Lemmih: Just `fmap` evaluate (deepseq a a) ?
11:45:03 <Cale> The parser to use is selected based on the type demanded.
11:45:09 <copumpkin> nah, that can't be right
11:45:18 <Cale> This is something which is tricky to do in most OO settings.
11:45:55 <Draconx> iirc, Ada allows overloading based on return type.
11:46:06 <Cale> Usually in OO settings, the objects, that is, the values themselves, carry around the implementations of the operations.
11:46:24 <Cale> So it becomes impossible to make things polymorphic on the type of the *result*
11:46:37 <Cale> With typeclasses, the implementations of the operations travel separately from the data
11:47:18 <Cale> :t 5
11:47:19 <lambdabot> forall t. (Num t) => t
11:47:33 <Lemmih> copumpkin: It shouldn't matter for 'spoon'.
11:47:34 <Cale> Numeric literals are even polymorphic in this fashion :)
11:47:37 <copumpkin> okay :)
11:47:53 <copumpkin> I'll upload another revision unless you have any other suggestions
11:49:23 <Cale> HaskellLove: Does that make sense?
11:50:19 <HaskellLove> Cale: a litle more yes, i am reading now it will get clear and get back here
11:51:10 <copumpkin> does anyone know the specific time for hackage's haddock buildage?
11:52:01 <copumpkin> alright, a new version of spoon is up
11:54:45 <eldragon> compumpkin, the reversed spoon opened outside the door of the the soda's can that failed its opener.
11:55:15 <ddarius> http://www-staff.it.uts.edu.au/~cbj/Publications/factorisation.pdf
11:55:29 <roconnor> @type throwIO
11:55:30 <lambdabot> Not in scope: `throwIO'
11:55:38 <roconnor> @hoofle throwIO
11:55:39 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
11:55:39 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
11:55:39 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
11:56:29 <roconnor> @hoogle catches
11:56:30 <lambdabot> Control.Exception catches :: IO a -> [Handler a] -> IO a
11:56:49 <roconnor> @hoogle Handler
11:56:50 <lambdabot> Control.Exception data Handler a
11:56:50 <lambdabot> Control.Exception Handler :: (e -> IO a) -> Handler a
11:56:50 <lambdabot> System.Console.Editline.Readline callbackHandlerInstall :: String -> (String -> IO ()) -> IO (IO ())
11:56:57 * hackagebot upload: spoon 0.3 - Catch errors thrown from pure computations. (DanielPeebles)
11:57:15 * copumpkin cackles evilly
11:57:35 <ivanm> @slap copumpkin
11:57:35 * lambdabot smashes a lamp on copumpkin's head
11:57:39 <copumpkin> :9
11:57:48 <ivanm> though I originally read your surname as "Pebbles" ...
11:57:54 <monochrom> I think copumpkin got diplomatic immunity.
11:58:01 <monochrom> s/think/thought/
11:58:40 <copumpkin> ivanm: so do most people :) at my graduation ceremony they asked everyone to write how they wanted their names to be pronounced, and the announcer still got it wrong
11:58:58 <ivanm> heh
11:59:08 <ivanm> monochrom: it's obviously been revoked
11:59:14 <ivanm> due to the hideous cackling sound
11:59:18 <copumpkin> ;(
12:01:03 <roconnor> @hoogle Handler
12:01:04 <lambdabot> Control.Exception data Handler a
12:01:04 <lambdabot> Control.Exception Handler :: (e -> IO a) -> Handler a
12:01:04 <lambdabot> System.Console.Editline.Readline callbackHandlerInstall :: String -> (String -> IO ()) -> IO (IO ())
12:02:12 <roconnor> @hoogle catches
12:02:13 <lambdabot> Control.Exception catches :: IO a -> [Handler a] -> IO a
12:02:31 <copumpkin> I quite like Bas van Dijk's Handle + Mode
12:02:41 <roconnor> does this Handler stuff really work?
12:02:47 <roconnor> it seems kinda impossible.
12:03:15 <copumpkin> roconnor: it's typeable
12:03:24 <roconnor> copumpkin: who says it is typeable?
12:03:50 <copumpkin> roconnor: Handler wants an Exception instance
12:03:52 <Gracenotes> @type Handler
12:03:53 <lambdabot> Not in scope: data constructor `Handler'
12:03:54 <copumpkin> and Exception is a subclass of Typeable
12:03:59 <copumpkin> class (Typeable e, Show e) => Exception e where
12:04:05 <copumpkin> data Handler a = forall e . Exception e => Handler (e -> IO a)
12:04:05 <Gracenotes> hm. not a constructor.
12:04:25 <ddarius> :t Control.Exception.Handler
12:04:26 <Gracenotes> .. an interesting constructor
12:04:27 <lambdabot> forall e a. (GHC.Exception.Exception e) => (e -> IO a) -> Control.Exception.Handler a
12:04:42 <roconnor> ok
12:04:56 <copumpkin> it is a little voodooish though
12:05:56 <copumpkin> the code is fairly straightforward, at least
12:06:21 <Gracenotes> is the type equivalent to (SomeException -> IO a)?
12:06:51 <copumpkin> not really
12:06:53 <HaskellLove> http://www.youtube.com/watch?v=gVLFGQGRsDw&feature=related Wow a Mario in Haskell, making a game, does not that require side-effects, I cant imagine a game made in functional language?
12:06:59 <copumpkin> you deal with a specific exception type
12:07:06 <Gracenotes> hm. it's self contained in its own way.
12:07:30 <copumpkin> Handler $ \(x :: ArithException) -> ...
12:07:40 <copumpkin> you wouldn't be able to pull the ArithException out of SomeException
12:07:52 <copumpkin> except by repeatedly trying fromException on it
12:08:56 <Gracenotes> fun
12:09:20 <Gracenotes> well, by repeatedly, meaning once
12:09:35 <copumpkin> yeah :)
12:09:59 <copumpkin> but if you wanted to emulate catches
12:10:03 <copumpkin> you'd be testing a bunch of different types
12:10:15 <roconnor> copumpkin: did you read http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Control-Exception.html#v%3Aevaluate
12:10:21 <roconnor> it boggles the mind
12:11:17 <copumpkin> yeah
12:11:49 <copumpkin> it's pretty subtle
12:12:07 <ddarius> It makes sense
12:12:31 <ddarius> It's the typical distinction between execution and evaluation.
12:12:33 <roconnor> ddarius: so is spoon broken or not?
12:12:42 <roconnor> I think spoon is fine.
12:12:42 <copumpkin> roconnor: not anymore :)
12:12:54 <roconnor> copumpkin: but you only touched teaspoon
12:12:59 <copumpkin> ddarius: yeah, I had to stare at it for a little before figuring out what was wrong
12:13:06 <copumpkin> roconnor: oh, I thought you meant spoon the package
12:13:21 <roconnor> copumpkin: was teaspoon broken before?
12:13:32 <roconnor> or are you simply making it prettier?
12:13:33 <copumpkin> supposedly in some circumstances it could be
12:13:48 <copumpkin> deepevaluate a = IO $ \s -> case a `deepseq` () of () -> (# s, a #)
12:14:04 <ddarius> copumpkin: It depends on your intended semantics for these functions.
12:14:27 <roconnor> or deepEvaluation a = deepSeq a (return a) >>= return
12:15:09 <copumpkin> ddarius: I'd like teaspoon to return Nothing if any exceptions occur during WHNF evaluation, and spoon to return Nothing if anything happens during NF evaluation. Both of them should act like Just if no errors occur
12:15:43 <roconnor> Note: the first equation implies that (evaluate x) is not the same as (return $! x). A correct definition is
12:15:44 <roconnor>    evaluate x = (return $! x) >>= return
12:15:55 <roconnor> however the monads laws say that  m >>= return is m
12:16:00 * roconnor head 'slode
12:16:05 <roconnor> splode even
12:16:36 * roconnor blames seq
12:17:37 <Lemmih> roconnor: Yeah, the documentation is quite odd. It wasn't always written like that, iirc.
12:17:58 <roconnor> copumpkin: better stick with your version of deepEvaluate
12:18:04 <roconnor> I don't get the documentation
12:18:17 <copumpkin> roconnor: hm? you mean the nasty peer-inside-IO version?
12:18:22 <HaskellLove> anyone can explain me what the right unit rule for monads actually means, it is messy in the book :(
12:18:22 <roconnor> ya
12:18:33 <copumpkin> HaskellLove: you sure you want to be going that far this early?
12:18:46 <copumpkin> :P
12:18:48 <HaskellLove> i am ready yes
12:19:04 <ddarius> In means: m >>= return === m
12:19:15 <roconnor> HaskellLove: the three laws say that (return >=> f) == f and (f >=> return) = f and (f >=> (g >=> h)) = ((f >=> g) >=> h)
12:19:18 <copumpkin> >> Just 5 >>= return
12:19:20 <Lemmih> roconnor: The difference is basically that 'seq' can very easily float around. Like: 'fn x = return $! x' => 'fn !x = return x'.
12:19:23 <copumpkin> > Just 5 >>= return
12:19:24 <lambdabot>   Just 5
12:19:34 <roconnor> HaskellLove: this is the sanest way to look at the laws IMHO
12:20:24 <HaskellLove> is that the noobiest answer possible?
12:20:39 <roconnor> HaskellLove: there are no noobie answers when it comes to monads.
12:20:44 <copumpkin> HaskellLove: monads are pretty abstract entities... you can compare them to burritos but that isn't what a monad "is"
12:20:47 <Lemmih> It's very important that the strictness analyser doesn't believe 'teason' to be strict in its first argument.
12:21:01 <copumpkin> Lemmih: so should I write a deepEvaluate for spoon?
12:21:08 <ddarius> "The monad laws: the Kleisli category -is- a category."
12:21:15 <HaskellLove> i am a beleiver if u understand, really understand something u can explain it to a noob
12:21:15 <roconnor> @quote haiku
12:21:16 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
12:21:18 <monochrom> The unit rules mean that return does nothing funny. It only passes values around.
12:21:19 <roconnor> @quote haiku
12:21:19 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
12:21:21 <roconnor> :/
12:21:39 <roconnor> @quote form.a.monoid
12:21:40 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
12:21:42 <manju> good morning
12:21:46 <copumpkin> "The monad laws: a monad is a monoid object in the category of endofunctors"
12:22:10 <ddarius> copumpkin: I was just outlining the laws, not the whole definition of a monad.
12:22:17 <monochrom> http://www.haskell.org/haskellwiki/Monad_laws  is useful
12:22:42 <Stinger> don't worry about the monad laws, they aren't that important in the beginning :P
12:22:59 <HaskellLove> so far a monad for me is a function that takes two arguments of same type and produce a result of same type
12:23:06 <roconnor> most of the time we don't know what laws mean in haskell.
12:23:09 <copumpkin> HaskellLove: the monad laws basically say do blocks behave intuitively :)
12:23:15 <Lemmih> copumpkin: Probably.
12:23:20 <copumpkin> HaskellLove: not really :/
12:23:38 <monochrom> I concur with copumpkin. It's what I said on that page too.
12:23:57 <copumpkin> HaskellLove: a monad is a function that takes one argument (a type) and produces a result of that same type (a type), such that certain things behave as you might expect
12:24:27 <roconnor> monochrom: that page is really good
12:24:59 <copumpkin> it'd also be fun to outline how applicative would look if it had its own notation à la do
12:25:03 <copumpkin> and what would differ
12:25:09 <HaskellLove> I will watch this and come back in hour http://www.youtube.com/watch?v=9fohXBj2UEI&feature=related
12:25:19 <monochrom> The listed author on haskellwiki is someone else, but it was first my post in haskell-cafe, then I let someone else put it on haskellwiki.
12:25:24 <copumpkin> HaskellLove: that's likely not going to help you much :)
12:25:29 <copumpkin> HaskellLove: although it's a good video :)
12:25:30 <ddarius> copumpkin: Anyway, a monad is a lax functor from the terminal category.
12:25:57 <copumpkin> :)
12:26:00 <copumpkin> clearly relevant: http://snapplr.com/pshb
12:27:27 <monochrom> blowjob girls??!!
12:27:37 <roconnor> @undo \x -> do { y <- m x; n y }
12:27:38 <lambdabot> \ x -> m x >>= \ y -> n y
12:27:50 <roconnor> @pl \ x -> m x >>= \ y -> n y
12:27:51 <lambdabot> (n =<<) . m
12:27:56 <copumpkin> monochrom: it's a silly comedy video :P the girl is in the office now
12:28:57 <kmc> monochrom: in my internet??!!!
12:29:51 <jmcarthur> the catsters ==> blowjob girl?!
12:30:21 <copumpkin> jmcarthur: it's weird!
12:31:08 <copumpkin> HaskellLove: before jumping into monads, I'd strongly recommend starting from functors, and moving up through Applicative
12:31:12 <copumpkin> (possibly through pointed)
12:32:11 <b6> are people aware of template haskell causing some "unknown symbol 'atexit'" error?
12:32:27 <HaskellLove> i am sure it is not as hard as you guys cant explain it :( will be back in hour or two hopefully able to continue the book and understand the monads chapter :D
12:32:45 <copumpkin> HaskellLove: it's a very simple concept, mathematically,  but grounding it in practical examples can be hard
12:33:38 <HaskellLove> lets hope :D study timee
12:33:57 <copumpkin> HaskellLove: but as I said, I'd advise against "jumping in the deep end"
12:34:49 <HaskellLove> copumkin I am studying Scala and paused it to learn Haskell, now i am thinking of pausing Haskell to learn Miranda, what do you think?
12:35:01 <copumpkin> HaskellLove: why Miranda?
12:35:30 <copumpkin> it's basically an early version of haskell
12:35:51 <HaskellLove> it is described as the assembly language of functional languages
12:36:17 <copumpkin> I wouldn't bother. I doubt it'll offer you more than Haskell does
12:36:19 <Chile> seems like that honor would go to typed lambda calc.
12:36:38 <jmcarthur> yeah i wouldn't bother with miranda
12:36:59 <jmcarthur> Chile: or core at least ;)
12:37:31 <HaskellLove> oh yeah it goes to lambda calc. i missed the slide... hmmm... damn... that is what litle sleep does to you, anyways... ok no miranda then
12:37:59 <copumpkin> HaskellLove: and if you haven't picked up LC before, that'll take you about 10 minutes
12:38:14 <HaskellLove> i have actually
12:38:19 <copumpkin> there you go
12:38:39 <copumpkin> HaskellLove: do you understand functors?
12:38:52 <kmc> SK calculus is the microcode of functional languages ;)
12:39:03 <HaskellLove> SK?
12:39:28 <copumpkin> :t ap const const
12:39:30 <lambdabot> forall b. b -> b
12:39:44 <copumpkin> > ap const const 5
12:39:46 <lambdabot>   5
12:40:03 <Gracenotes> kmc: they are more like ternary microcode
12:40:05 <copumpkin> > join (<*>) const 5
12:40:06 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
12:40:07 <Gracenotes> or something weird
12:40:10 <copumpkin> boo :)
12:40:44 <byorgey> HaskellLove: the SK calculus consists of two combinators, S and K, which satisfy the equational laws  Kxy = x  and  Sxyz = xz(yz)
12:40:56 <Gracenotes> or something weird
12:40:58 <byorgey> amazingly, this is enough to encode any computation at all
12:41:32 <copumpkin> HaskellLove: in haskell terms, K = const, and S = ap/<*>
12:41:52 <Apocalisp> SKLove
12:42:08 <byorgey> S = ap/<*> for the ((->) e) monad in particular
12:42:13 <byorgey> not in general
12:42:18 <copumpkin> yeah :)
12:42:40 * copumpkin pressures HaskellLove to learn functors first
12:42:57 <Gracenotes> did I say that twice? meh.
12:43:11 <kmc> i think the analogy to microcode is particularly strong because you wouldn't compile lambda calc to SK (that can increase size exponentially) but rather encode it as data in SK, and write an interpreter for it
12:43:12 <byorgey> or something weird
12:43:24 <kmc> or something weird
12:43:35 <Apocalisp> @remember Gracenotes or something weird
12:43:35 <lambdabot> Done.
12:43:54 <kmc> > text $ map pred "ps!tpnfuijoh!xfjse"
12:43:55 <lambdabot>   or something weird
12:44:32 <HaskellLove> ok I got so confused I will kill myself now and put off my misery
12:44:39 <Gracenotes> oh, I though I'd never get my 15 minutes of fame :o
12:44:48 <copumpkin> HaskellLove: as I said, start small, build up :P
12:45:02 <copumpkin> HaskellLove: almost everyone jumping straight into monads ends up tearing their hair out
12:45:19 <HaskellLove> get away from me you monsters, monads and this and that, leave me alone as happy programmer... hahaha :D
12:45:46 <byorgey> monads monads monads! zygohistomorphic prepromorphism!
12:45:58 <byorgey> ;)
12:46:05 <copumpkin> HaskellLove: I can try to explain to you in another channel if you want (to avoid spamming here)
12:46:06 <kmc> you should, at minimum, understand higher-order functions, type declarations, and typeclasses before you try to understand monads
12:46:22 <kmc> because monads are defined explicitly in terms of those things
12:46:29 <byorgey> and also functors
12:46:37 <HaskellLove> copumpkin i am all yours, want me to come to PM?
12:46:55 <HaskellLove> understand higher-order functions, type declarations, and typeclasses before you try to understand monads : I DO UNDERSTAND THOSE
12:47:01 <copumpkin> sure
12:47:07 <copumpkin> or just #haskell-overflow
12:47:10 <jmcarthur> monads are one of the few things that i never actually had an "aha" moment about. i just gradually picked up things here and there (and by "picked up things" i mean "dropped preconceived notions")
12:47:12 <copumpkin> so other people can chime in if I miss something
12:48:56 <roconnor> jmcarthur: I sort of had a little aha momement when I converted my nested case statements propogating Nonthing into a monadic style.
12:49:10 <roconnor> but it wasn't a total aha
12:49:23 <jmcarthur> roconnor: right. tiny "aha"s everywhere, and that's all
12:55:53 <kmc> HaskellLove, okay, don't need to yell
12:56:07 <HaskellLove> oops sorry caps on :D
12:56:22 <HaskellLove> monads excited me i guess haha
12:58:52 <toast-opt> ... what yelling?
12:59:14 <toast-opt> sorry, wondered if I have a bad connection
13:00:20 <roostaj> what is the most popular operating system for haskell programmers?
13:00:27 <roostaj> arch linux?
13:00:36 <gwern> linux.
13:00:44 <roostaj> which distro
13:01:06 <jmcarthur> i wouldn't want to try narrowing it down
13:01:10 <roostaj> :)
13:01:19 <gwern> like distros matter?
13:01:21 <jmcarthur> i use arch. i don't think it is necessarily a majority here, and actually kind of doubt it
13:01:36 <gwern> they're just some package management and integration work
13:01:42 <gwern> don't mistake the finger for the moon
13:01:51 <toast-opt> ... mac user here.  wished the macports install worked properly
13:01:54 <roostaj> ha ha nice
13:02:02 <ddarius> "Additionally, the type of F does not look very appealing as a logical axiom"
13:02:58 <gwern> ddarius: does this involve another type of U?
13:03:07 <roostaj> gwern: thanks. I was going to switch back over to a nix environment over christmas and was just going to see if there was a popular flavor of linux amongst haskell users
13:03:11 <toast-opt> it's ok.  i have a win7 vm.  the windows installer worked fine
13:04:08 <eldragon> L == NP ? ; (Linear == Non-Polynomial?) It's the bomb!
13:04:21 <kmc> "Non-Polynomial"?
13:04:24 <gwern> roostaj: it's basically the same distribution as among linux users period
13:04:24 <gwern> lots of debian descendants, a number of oddballs like arch, soem redhat
13:04:44 <kmc> roostaj, i use debian, and ignore its haskell packaging in favor of a user install of Haskell Platform
13:05:07 <HaskellLove> ubuntu user here that thinks of going to debian maybe soon
13:05:13 <roostaj> gwern: ubuntu is getting very popular ive noticed. Isn't it built on debian?
13:05:17 <kmc> it's not that different
13:05:27 <kmc> they use the same package managers
13:05:33 <gwern> roostaj: I said descendant, after all
13:05:37 <kmc> but different default repositories
13:05:43 <roostaj> gwern: true :)
13:05:51 <monochrom> I use ubuntu. I don't use ubuntu's ghc. I install in /usr/local myself.
13:06:01 <kmc> roostaj, whatever you pick, just try to get Haskell Platform installed
13:06:11 <roostaj> kmc: ha ha! of course!
13:06:56 <gwern> outster is a funny word
13:07:00 <gwern> @wn ouster
13:07:01 <lambdabot> *** "ouster" wn "WordNet (r) 2.0"
13:07:02 <lambdabot> ouster
13:07:02 <lambdabot>      n 1: a person who ousts or supplants someone else [syn: {ejector}]
13:07:02 <lambdabot>      2: a wrongful dispossession
13:07:02 <lambdabot>      3: the act of ejecting someone or forcing them out [syn: {ousting}]
13:07:17 <gwern> it confused me as a kid for ages. I still don't quite trust it
13:07:25 <roostaj> i may try arch linux--feeling adventurous. I've been wanting to get more familiar with the inner workings of linux for a while and that seems a good way
13:10:01 <eldragon> i wanted NP = L (in Linear time and Linear space), less impossible.
13:11:21 <kmc> eldragon, that's not what those usually name...
13:11:51 <monochrom> You understand what he's talking about?
13:11:55 <kmc> i have no idea
13:12:00 <eldragon> yes monochrom
13:12:06 <aavogt> unsafePerformOuster
13:12:11 <kmc> bizarro world complexity theory
13:12:17 <eldragon> Polynomic can be either linear or non-linear.
13:13:12 <kmc> eldragon, there's something called a linear bounded automaton
13:13:14 <eldragon> or constant.
13:13:31 <kmc> they are less powerful than Turing machines
13:13:38 <kmc> in what they can compute, not in terms of time or space
13:13:43 <copumpkin> they're the best we can do though :)
13:13:49 <kmc> they correspond to the context-sensitive grammars
13:14:55 <aavogt> roostaj: inner workings of haskell are more interesting
13:15:13 <kmc> that depends
13:15:16 <kmc> it's good to know everything
13:15:30 <aavogt> but can you?
13:15:30 <ddarius> kmc: Indeed.
13:15:50 <copumpkin> what's an example of something that an LBA can't do that a TM can? beyond dealing with infinite stuff
13:15:52 <monochrom> I can. Just give me more time. :)
13:16:38 <ddarius> Most people try to know everything by learning more.  That's silly.  Just make less everything.
13:16:46 <roostaj> aavogt: oh, no doubt! I really just want to be more confortable with an operating system, though (it's a side goal)
13:16:48 <copumpkin> :)
13:16:59 <roostaj> comfortable*
13:17:15 * aavogt needs to learn more to understand ddarius
13:17:30 <aavogt> wait, that's opposite of his suggestion
13:17:44 <monochrom> yeah, you should delete him
13:17:44 <kmc> when the asteroids or tsunami or whatever is coming, and we have to escape earth in rocketships, and they have to pick only one person to carry the whole knowledge of computers
13:17:48 <kmc> you should try to be that person
13:18:04 <copumpkin> aavogt: you could just make less ddarius rather than trying to learn more
13:18:17 <kmc> copumpkin, there's probably a pumping lemma for LBAs.  i imagine it's bloody complicated
13:18:32 <MoALTz> kmc: more probably the selector would be a great new war...
13:18:48 <kmc> it is still open whether LBA = deterministic LBA
13:18:49 <MoALTz> grunt or guy in the bunker? your knowledge will decide!
13:18:55 <copumpkin> kmc: yeah, maybe :) but trying to think of a problem that I could even apply that to
13:22:06 <eldragon> i did one question, nobody did answer me.
13:22:37 <kmc> eldragon, none of us have any idea what you are saying, or to whom, or to what end
13:22:57 <eldragon> my question was  NP = L ?
13:23:48 <kmc> where NP is the class of languages decidable by a nondeterministic Turing machine in polynomial time, and L is the class of languages decidable by a deterministic Turing machine in logarithmic space?
13:24:53 <eldragon> L of Linear, not Logarithmic
13:25:07 <kmc> that's not what L means usually
13:25:17 <kmc> you also said something about "non-polynomial"
13:25:20 <monochrom> There was a question? I thought it was an exclamation. Something about a bomb.
13:25:42 <roostaj> monchrom: :D
13:25:55 <roostaj> monochrom: :D
13:27:03 <copumpkin> somebody set up us the bomb!
13:27:48 <jmcarthur> Main screen turn on.
13:28:13 <copumpkin> all your base are belong to us!
13:28:19 <roostaj> what happen?
13:28:25 <roostaj> (out of order)
13:28:31 <jmcarthur> You have no chance to survive make your time.
13:29:30 <roostaj> you are on the way to destruction
13:29:40 <copumpkin> :)
13:29:50 <copumpkin> we get signal! :P
13:29:51 <roostaj> move 'zig'
13:29:54 <roostaj> for great justice!
13:30:05 <luite> hm I thought this had died a long time ago :p
13:30:05 * copumpkin chuckles
13:30:15 <copumpkin> luite: for great justice, it has lived on!
13:30:19 <eldragon> roostaj, it's math, math doesn't create or destroy it, math transforms it.
13:30:47 <roostaj> eldragon: what you say?
13:30:52 <kmc> eldragon, linear space or linear time?
13:30:55 <dolio> L /= NP is pretty obvious, isn't it?
13:31:02 <copumpkin> eldragon: what happen?
13:31:12 <kmc> dolio, if you use the usual definition of L
13:31:20 <eldragon> kmc, if it's linear space between linear time is required, not?
13:31:27 <dolio> Even the "linear time/space" one.
13:31:30 <eldragon> kmc, if it's linear space then linear time is required, not?
13:32:19 <dolio> Comparison sorting is provably n log n best case.
13:32:31 <copumpkin> there's a cute simple proof of that too
13:32:35 <copumpkin> it would even fit in this margin
13:32:47 <kmc> for Turing machines, the space you use is at most the time you use
13:32:49 <eldragon> dolio, sorting can be made in O(n) time.
13:32:56 <kmc> eldragon, not by pairwise comparisons
13:32:58 <copumpkin> eldragon: only with additional information on the elements
13:33:54 <eldragon> add to the trie (with counters) one zillion of ints.
13:34:00 <eldragon> it's O(n)
13:34:31 <dolio> No.
13:34:58 <eldragon> (ints are 32-bit)
13:35:09 <kmc> eldragon, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.2421 see esp. section 4
13:35:23 <dolio> We're not sorting 32-bit ints.
13:35:27 <kmc> eldragon, an O(n) algorithm for sorting does not contradict what dolio said
13:35:28 <eldragon> and one zillion is 100...000 with a million of zero digits.
13:35:46 <eldragon> i wanna log(zillion)
13:35:48 <kmc> eldragon, in "comparison sorting" you can only compare elements pairwise
13:35:54 <dolio> We're sorting things that can only be compared pairwise.
13:36:06 <dolio> And that's the only information you have about them.
13:36:13 <copumpkin> eldragon: you can only do that with additional information, such as a maximum bound on the size
13:38:06 <roconnor> did people talk about expressio substution monad?
13:38:16 <roconnor> I'm told it is some sort of universal monad
13:38:22 <copumpkin> roconnor: I've heard conor talk about it a lot before
13:38:24 <roconnor> maybe a good example of a monad for teaching
13:38:38 <copumpkin> roconnor: yeah, probably, but hard to illustrate with lambdabot :/
13:38:41 <kmc> link?
13:38:59 <monochrom> There is an algorithm for this: input a context-sensitive grammar and a string, output whether the grammar parses the string. There is no algorithm for this: input a turing machine and a string, output whether the turing machine parses the string. So some turing machines cannot be turned into context-sensitive grammars.
13:39:03 <copumpkin> roconnor: we were just doing the functor->pointed->applicative->monad ladder technique :)
13:39:15 <roconnor> kmc: data Expr a = Var a | ...
13:39:37 <roconnor> kmc: Exrp a -- expression with variable names taken from a.
13:39:46 <roconnor> kmc: return = Var
13:40:11 <dolio> The free monad over a functor?
13:40:34 <roconnor> kmc: Var a >>= f = f a
13:40:53 <copumpkin> dolio: as an example?
13:41:01 <roconnor> kmc: Op x y >>= f = Op (x >>= f) (y >>= f)
13:41:59 <roconnor> x >>= f, simulatneously substitute all variables in x with (f a)
13:42:02 <kmc> can you avoid capture too?
13:42:06 <copumpkin> roconnor: variable names taken from a might be a little confusing at first, once you start talking about ap having variable names taken from functions
13:42:58 <kmc> f wants to substitute an expression for *every* occurrence of a variable.  if you have binders what do you do?
13:43:00 <roconnor> ap having variable names taken from functions?
13:43:27 <kmc> :t ap
13:43:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:44:22 <copumpkin> roconnor: I meant the first parameter to ap, sorry
13:44:43 <roconnor> copumpkin: :)
13:45:01 <manju> as a rank newbie it scares me that the only thing haskellers talk about are monads
13:45:18 <ivanm> manju: I beg to differ
13:45:19 <manju> is there nothing else in haskell ?
13:45:25 <ivanm> some people talk about applicative functors!
13:45:34 <Draconx> monads /are/ applicative functors!
13:45:40 <copumpkin> manju: absolutely not, actually. A lot of us are frustrated with how much emphasis is put on monads by newbies to haskell :P
13:45:43 <aavogt> there was some discussion about quantum mechanics today
13:45:43 <monochrom> They also talk about java and scala.
13:45:43 <nornagon> manju: would it scare you if you came to lisp and all they talked about was lists? (alt. macros?)
13:45:45 <ivanm> Draconx: yes, but the reverse isn't true
13:45:54 <ivanm> copumpkin: heh, touche
13:46:09 <ivanm> nornagon: or sexps
13:46:16 <ivanm> then again, what else is there in lisp? :p
13:46:21 <monochrom> clos
13:46:28 <copumpkin> manju: we'll explain them if people ask, but monads are definitely not the central feature of the language, or even a feature of the language at all :) all we have is some handy syntactic sugar for them
13:46:33 <kmc> manju, we talk about a lot of stuff
13:46:41 <copumpkin> granted, monads are pretty cool :)
13:46:50 <aavogt> we talk about talking about monads
13:46:51 <monochrom> monads are so yesterday
13:47:01 <manju> kmc: yes...a lot of monad stuff
13:47:01 <nornagon> the future is cofunctors
13:47:07 <copumpkin> commutative comonads are where it's at
13:47:14 <copumpkin> nornagon: contrafunctors? :P
13:47:20 <nornagon> :P
13:47:32 <manju> you can talk about anything in #haskell as long as it is about monads (kinda like the ford black car reference)
13:47:33 <copumpkin> they do exist, but are awkward to work with in haskell
13:47:55 <nornagon> (secret: i was actually just making stuff up)
13:48:03 <copumpkin> class Contrafunctor f where contramap :: (a -> b) -> f b -> f a
13:48:04 <Cale> copumpkin: cocommutative
13:48:06 <copumpkin> nornagon: I'm not :)
13:48:46 <Cale>  Results 1 - 50 of about 86,900 for cocommutative.
13:49:24 <Cale> Hopf algebras are awesome
13:49:36 <copumpkin> lol
13:50:34 <copumpkin> is there a notion of a free arrow (in the Control.Arrow sense)?
13:50:42 <copumpkin> is it an "algebraic theory"? :P
13:51:14 <Cale> I'm coo coo for cocommutative comonads!
13:51:30 <manju> sorry
13:51:43 <manju> whenever I copy and paste something into the IRC client
13:51:46 <manju> my keyboard dies
13:51:51 <copumpkin> :)
13:51:56 <copumpkin> you shouldn't be pasting into IRC anyway!
13:52:01 <manju> or when I recieve a text message on my cell
13:52:02 <copumpkin> it's telling you
13:52:03 <ivanm> dibblego: http://codepad.org/9HGWo3GR
13:52:13 <manju> heh
13:52:37 <manju> http://blog.sigfpe.com/2009/12/where-do-monads-come-from.html
13:52:46 <manju> I am still trying to understand
13:52:55 <manju> is there a context or something for that article
13:52:58 <ivanm> manju: don't bother
13:53:00 <ivanm> learn haskell
13:53:01 <ivanm> use monads
13:53:06 <ivanm> _then_ try to understand them
13:53:09 <Cale> "deconcatenation coproduct"
13:53:13 <manju> ivanm: ok
13:53:17 <ivanm> RWH does a decent way of working its way up to monads
13:53:19 <monochrom> Yeah, how did you learn Chess.
13:53:27 <ivanm> Axman6: where's that IO tutorial of yours?
13:53:32 <Cale> "We refer to Q(V) as the cofree graded coalgebra cogenerated by V."
13:53:34 <manju> I started playing chess
13:53:36 <Stinger> manju, context = phd in maths
13:53:44 * manju has Axman6 io tutorial book,arked
13:53:57 <luite> hm, I really need a cup of cofree
13:54:12 <Cale> This paper looks like it actually might be really cool
13:54:14 <copumpkin> manju: if you're trying to learn monads, that is not a good place to start
13:54:19 <Cale> http://www.math.tamu.edu/~maguiar/GL.pdf
13:54:20 <manju> http://random.axman6.com/blog/?page_id=70
13:54:23 <luite> cocool?
13:54:29 <copumpkin> luite: ol
13:54:39 <Cale> Lots of interesting trees
13:54:44 <manju> Stinger: :O
13:54:46 <ivanm> manju: overly simplified answer (that's probably wrong): monads were introduced into Haskell for IO, but have since been used in a lot of other places; however, you don't need to (and shouldn't) learn about monads to do IO
13:54:55 <monochrom> "where do monads come from" is not for beginners.
13:54:58 <Cale> "The Hopf algebra of heap-ordered trees"
13:55:21 <copumpkin> manju: sigfpe does have some fairly beginner-friendly articles on monads, but that isn't one of them :)
13:55:22 <luite> ok, I'll dump it on my reader, something to read during the train ride
13:55:39 <manju> copumpkin: ok
13:55:43 <copumpkin> you definitely don't need a PhD in maths
13:55:43 <kmc> what about the "you could have invented monads" page
13:55:49 <monochrom> "you could have invented monads" by the same author is for beginners, or at least outsiders.
13:55:51 <copumpkin> just the ability to reason abstractly
13:56:11 <kmc> manju, do you understand higher-order functions, type declarations, and typeclasses?
13:56:15 <ivanm> manju: whatever you do, _don't_ write your own monad tutorial once you think you understand them ;-)
13:56:17 <ivanm> monads are burritos!
13:56:20 <copumpkin> kmc: I like that one, although I still think a fairly strong grounding in functors through applicatives should be a prerequisite
13:56:50 <eldragon> new relaxed question, NP = Log * Linear ?
13:56:55 <manju> kmc: I understand higher-order functions, I know what typeclasses are but I think I still need to understand a lot and I am still doing type declarations
13:57:05 <manju> ivanm: I wont :-)
13:57:08 <kmc> manju, you need to understand all of those to understand monads
13:57:15 <manju> kmc: ok
13:57:26 <manju> any good types articles ?
13:57:34 <kmc> because each monad is a type declared with "data"; "Monad" itself is a typeclass, and the most important member of that typeclass is a higher-order function
13:57:44 <copumpkin> manju: did I already give you http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/ ?
13:57:47 <manju> kmc: ok
13:57:55 <manju> copumpkin: no
13:58:01 <kmc> manju, also don't try to understand monads by doing IO.  IO is a weird monad
13:58:10 <copumpkin> manju: but by all means, understanding monads is not essential to programming haskell
13:58:11 <kmc> you can  write your own Maybe monad in three lines of code
13:58:14 <manju> you did now
13:58:47 <copumpkin> manju: so don't feel a pressure to "get" them. I'd recommend starting with functors first and getting comfortable with them
13:59:49 <manju> copumpkin: The intermediate haskell exercises, am I supposed to solve them ?
14:00:01 <shachaf> I might recommend ignoring monads completely, and just looking at specific things like lists and parsers and what not.
14:00:16 <copumpkin> manju: if you can solve them, you're probably fairly comfortable with thinking about types
14:00:18 <shachaf> Eventually you'll see the similarities; they happen to have a name.
14:00:20 <Cale> http://www.math.tamu.edu/~maguiar/a.pdf -- oh wow
14:00:42 <copumpkin> manju: they're fairly fundamental exercises, despite the funny names
14:00:53 <manju> copumpkin: ok
14:00:54 <lispy> The iteratee library depends on the class StreamChunk.  StreamChunk does not allow you to make an instance for ByteString.
14:01:16 <Rotaerk__> Cale, hmm... Fock Functors
14:01:18 <Rotaerk__> >_>
14:01:22 <copumpkin> don't be rude
14:01:37 <jmcarthur> fockin functors
14:01:37 <copumpkin> Foque!
14:01:43 <Rotaerk> hehe
14:01:45 <monochrom> Yeah, fock fonctors. Learn munads.
14:01:51 <Cale> :O look at the lovely commutative diagram on page 14
14:02:01 <aavogt> seal functors
14:02:20 <manju> copumpkin: if I don't have a clue what I need to do with the intermediate exercises, should I go read anything ?
14:02:36 <copumpkin> j'aime les phoques
14:02:44 <jmcarthur> holy crap!
14:02:52 <monochrom> I can do the exercises for you.
14:03:01 <manju> monochrom: why ?
14:03:02 <lispy> I wish there was a typeclass lift for newtypes
14:03:07 <copumpkin> lambdabot can do the exercises for you :P
14:03:13 <lispy> GeneralizedNewtypeDeriving doesn't always work
14:03:13 <copumpkin> manju: as an introduction
14:03:23 <copumpkin> manju: can you write a function of type a -> a
14:03:35 <BMeph> SO...do Fock endofunctors,...Fock themselves? ;p
14:03:35 <monochrom> I don't know why.
14:03:41 <copumpkin> holy crap
14:03:53 <manju> > returnInt a = a
14:03:54 <lambdabot>   <no location info>: parse error on input `='
14:03:56 <aavogt> copumpkin: :P
14:04:03 <Rotaerk> manju, hint:  sometimes the type signature pretty much restricts you to only one implementation
14:04:11 <monochrom> two
14:04:20 <copumpkin> monochrom: shhh
14:04:29 <lispy> _|_ doesn't count here :)
14:04:37 <copumpkin> :)
14:04:46 <Cale> Ooh, lattice paths!
14:04:51 <Rotaerk> well I guess a -> a could completely ignore the input and return some literal >_>
14:04:55 * lispy watches Cale's head explode
14:04:56 <monochrom> Of course, it isn't even valid syntax.
14:05:09 <lispy> Rotaerk: and what literal has type a?
14:05:15 <manju> > let giveMeA a = a
14:05:16 <lambdabot>   not an expression: `let giveMeA a = a'
14:05:22 <Rotaerk> oh, true
14:05:31 <manju> > what ?
14:05:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:05:44 <Cale> There are some sublimely complicated commutative diagrams in this :)
14:05:51 <lispy> > let a a = a in a 1
14:05:52 <lambdabot>   1
14:05:58 <copumpkin> lispy: ugh!
14:06:21 <copumpkin> manju: the syntax is let ... in ...
14:06:36 <manju> copumpkin: it works in ghci though ?
14:06:40 * jmcarthur sometimes feels that he is missing out on a lot of beautiful math, but i can't even begin to fathom what value that monstrosity could possibly have
14:06:54 <copumpkin> manju: ghci is an odd beast :)
14:06:55 <Rotaerk> manju, not just any haskell works in ghci... it's more restricted
14:07:08 <jmcarthur> lispy: you just made my head explode
14:07:40 <lispy> jmcarthur: that one is not as magical as it seems
14:07:50 <aavogt> there is no recursion
14:07:53 <lispy> > let a a = a in a
14:07:55 <lambdabot>   {()->()}
14:08:05 <copumpkin> it's just abusing the scoping rules in ways they should never be abused
14:08:12 <lispy> right
14:08:14 <aavogt> @type let id id = id in id
14:08:15 <lambdabot> forall t. t -> t
14:08:40 <aavogt> copumpkin: there's worse stuff with let' and in' as variable names
14:08:55 <lispy> or literals
14:08:59 <lispy> > let 1 = 2 in 1
14:09:00 <lambdabot>   1
14:09:24 <lispy> > let let' = in' in let'
14:09:25 <lambdabot>   Not in scope: `in''
14:09:34 <manju> > let giveMeB a = b where b = a
14:09:36 <lambdabot>   not an expression: `let giveMeB a = b where b = a'
14:09:37 <lispy> > let let' in' = () in let'
14:09:39 <lambdabot>   {()->()}
14:09:44 <manju> grrrrrr...
14:09:57 <lispy> manju: maybe show is broken
14:09:59 <lispy> > fix show
14:10:01 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:10:07 <manju> > let giveMeB a = b where b = a
14:10:08 <lambdabot>   not an expression: `let giveMeB a = b where b = a'
14:10:14 * lispy stops being a butt
14:10:25 <lispy> manju: you can't use that syntax here
14:10:31 <aavogt> > let giveMeB a = b { where b = a } in giveMeB
14:10:32 <lambdabot>   <no location info>: parse error on input `where'
14:10:35 <monochrom> > let in' let' = in' let' in (=)
14:10:36 <lambdabot>   <no location info>: parse error on input `='
14:10:38 <manju> lispy: why ?
14:10:48 <ski> > let giveMeB a = b where b = a in giveMeB
14:10:50 <lambdabot>   {()->()}
14:10:51 <Rotaerk> lambdabot's also restricted
14:10:58 <lispy> manju: lambdabot only does expressions.  And 'where' like that is not part of the expression syntax
14:11:04 <ski> > let giveMeB a = b where {b = a} in giveMeB  -- should you prefer
14:11:05 <lambdabot>   {()->()}
14:11:09 <monochrom> > let (=) a b = a+b in 0
14:11:10 <lambdabot>   <no location info>: parse error on input `='
14:11:18 <manju> lispy: where do I learn about proper expression syntax ?
14:11:33 <lispy> Haskell 98 report, learn you a haskell, etc
14:11:33 <aavogt> @where onlinereport
14:11:34 <lambdabot> I know nothing about onlinereport.
14:11:41 <aavogt> @where report
14:11:41 <lambdabot> http://www.haskell.org/onlinereport/
14:11:50 <lispy> manju: in this case, i'm going to recommend you take a class at Google University.
14:12:33 <lispy> manju: but as ski demonstrated, you can put brackets in the right places to make it work
14:13:01 <copumpkin> > let id :: (forall id. id -> id) -> id -> id; id id = id id in id Prelude.id 5
14:13:02 <lambdabot>   5
14:13:16 * copumpkin coughs
14:13:19 <Rotaerk> ..
14:13:30 <lispy> > fix id
14:13:32 <jmcarthur> lispy: yeah i got that it was just a syntactical thing, but it nonetheless made my head explode
14:13:34 <lambdabot>   mueval-core: Time limit exceeded
14:13:37 <jmcarthur> because it's horrible
14:13:42 <ski> > (let id :: (forall id. id -> id) -> id -> id; id id = id id in id) id 5
14:13:43 <lambdabot>   5
14:13:52 <jmcarthur> oh not this
14:14:10 <manju> guys please :-)
14:14:26 <copumpkin> ski: ooh, prettier
14:14:28 <manju> let's not notch up the gore a bit more
14:14:28 <aavogt> , pprint $ fix (AppE 'id)
14:14:28 <ivanm> @slap ski
14:14:29 <lunabot>  luna: Not in scope: `pprint'
14:14:29 * lambdabot moulds ski into a delicous cookie, and places it in her oven
14:14:31 * ski looks quizzingly at channel
14:14:36 <copumpkin> @remember ski > (let id :: (forall id. id -> id) -> id -> id; id id = id id in id) id 5
14:14:37 <lambdabot> Done.
14:14:43 <lispy> Here is a trickier problem.  Give me a StreamChunk instance for Lazy ByteStrings.
14:14:46 <Rotaerk> hey, mental masturbation is a big part of using haskell, manju, get used to it !
14:14:46 <Rotaerk> :P
14:14:55 <manju> heh :-)
14:14:59 <manju> I see that
14:15:09 <aavogt> , ppdoc $ fix (AppE 'id)
14:15:10 <lunabot>  luna: Not in scope: `ppdoc'
14:15:14 <osaunders> I still don't understand what point-free style? Is it just partial application of function after composition?
14:15:16 <copumpkin> manju: most of us enjoy mental exercise :) it's why we bothered learning this
14:15:26 <ivanm> osaunders: you don't explicitly mention your variables
14:15:32 <aavogt> , pprint $ fix (AppE 'id)
14:15:33 <lunabot>  luna: Not in scope: `pprint'
14:15:44 <aavogt> , [$pprint| fix (AppE 'id) |]
14:15:45 <lunabot>  luna: Not in scope: `pprint'
14:15:46 <copumpkin> manju: you call it masturbation, I call it exercise ;)
14:15:54 <kmc> osaunders, narrowly: no lambdas, no variable patterns
14:15:55 <Woof> lispy: What's Google University? Google Code University? (that's what came up when I googled). Or is there more?
14:15:59 <kmc> so "f = ..." is allowed but not "f x = ..."
14:16:01 <copumpkin> now that could be quoted out of context :)
14:16:04 <kmc> maybe let isn't even allowed
14:16:05 <Rotaerk> lol
14:16:12 <ivanm> osaunders: e.g. square = (^2) <-- not mentioning the value we're actually squaring
14:16:16 <kmc> osaunders, the "points" are named variables
14:16:25 <kmc> @pl square x = x^2
14:16:26 <lambdabot> square = (^ 2)
14:16:40 <kmc> @pl square = \x -> x^2
14:16:41 <lambdabot> square = (^ 2)
14:16:44 <manju> Woof: google university is probably, google for haskell expressions or something
14:16:50 <lispy> Woof: Sorry, just a lame joke meaning, try googling it.
14:17:00 <Woof> Oh okay x.x
14:17:06 <Rotaerk> lispy, there's actually something called Google University :P
14:17:10 <Twey> osaunders: It's the definition of a function in terms of other functions, rather than in terms of its arguments.
14:17:11 <osaunders> kmc: Points are named variables? Since when?
14:17:13 <lispy> Rotaerk: awesome
14:17:14 <manju> I am trying googling and all I get is haskell reguler expression links :-/
14:17:19 <Woof> All the same, I did discover Google Code University because of it. Good : D
14:17:21 <copumpkin> osaunders: from a topological standpoint, apparently
14:17:27 <Woof> Twey! So this is where you're hiding >.>
14:17:43 <Twey> o/ Woof
14:17:51 <copumpkin> Meow.
14:17:53 <Gracenotes> Woof: what :o
14:17:58 <ski> , pp (fix (AppE (VarE 'id)))
14:18:01 <ski> aavogt : ^
14:18:03 <lunabot>  Stack space overflow: current size 8388608 bytes.
14:18:03 <lunabot>  Use `+RTS -Ksize' to increase it.
14:18:12 <Gracenotes> is it much good?
14:18:21 <Woof> Twey. I'd ask you to report back to station but I'll be gone for a few weeks, so you can take that time off too
14:18:22 <copumpkin> there's a Haskell University
14:18:30 <jmcarthur> > (appEndo . Data.Foldable.foldMap Endo $ replicate 1000 id) 5
14:18:31 <Twey> Hehe
14:18:32 <lambdabot>   5
14:18:36 <copumpkin> :O
14:18:38 <copumpkin> station?
14:18:56 <Gracenotes> copumpkin: there is a Haskell party everywhere. at all times.
14:18:59 <aavogt> , pp $ iterate (AppE (VarE 'id)) ('()) !! 10
14:19:00 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
14:19:03 <Woof> Gracenotes: http://code.google.com/edu/algorithms/index.html I don't know, I just came across it. Looks new, in that there isn't too much content
14:19:12 <Rotaerk> too many tools in haskell !
14:19:12 <aavogt> , pp $ iterate (AppE (VarE 'id)) (VarE '()) !! 10
14:19:14 <lunabot>  "id (id (id (id (id (id (id (id (id (id ())))))))))"
14:19:23 <kmc> > fix error
14:19:24 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:19:24 <Gracenotes> Woof: seems to be an aggregation
14:19:31 <Woof> Yes
14:19:37 <ajh> hi everyone.  can i ask a performance question?
14:19:37 <osaunders> So I'm going with: A point-free function declaration is a function declaration that uses no named variables
14:19:39 <aavogt> ski: thanks, lunabot isn't terribly helpful
14:19:41 <c_wraith> :t id . id
14:19:42 <lambdabot> forall a. a -> a
14:19:46 <osaunders> ajh: Don't ask to ask, just ask
14:19:52 <ski> , [$ty| AppE (Var 'id) |]
14:19:55 <lunabot>  luna: Exception when trying to run compile-time code:
14:19:55 <ski> , [$ty| pp |]
14:19:58 <lunabot>  forall a . (Data a, Ppr a) => a -> String
14:20:02 <ski> , [$ty| AppE (VarE 'id) |]
14:20:05 <lunabot>  Exp -> Exp
14:20:13 <Rotaerk> osaunders, f = g instead of f x = g x
14:20:13 <ajh> i'm trying to rewrite some C++ and get comparable performance in haskell
14:20:15 <copumpkin> there's a #ty now
14:20:19 <Rotaerk> as a simple example
14:20:23 <ski> copumpkin : i know
14:20:29 <kmc> #ty id
14:20:32 <Gracenotes> Woof: still, looks like the individual talks are neat. should watch them if I'm bored maybe
14:20:32 <lunabot>  forall a . a -> a
14:20:32 <copumpkin> ajh: that way there be dragons
14:20:34 <ajh> an important part of the process is reading through a binary file
14:20:42 <ajh> essentially a mmapped array of structs
14:20:42 <ski> , [$ty| ty |]
14:20:45 <lunabot>  QuasiQuoter
14:20:57 <Rotaerk> is it possible to factor any and all functions into point free style?
14:20:59 <ajh> in C++ i handle this by mmaping the file and treating as an array of structs
14:21:20 <Twey> Rotaerk: I believe so, yes
14:21:20 <copumpkin> ajh: you can do that in haskell too, but it's ugly :) you probably want Data.Binary
14:21:20 <ski> Rotaerk : assuming you have a few primitives, then yes
14:21:23 <kmc> Rotaerk, yes.  the SK calculus is Turing-complete
14:21:23 <ajh> in haskell i've tried using Data.Binary and Data.StorableVector
14:21:24 <Rotaerk> I remember someone did something in here that used all kinds of flips and $'s to rearrange a function into an unreadable mess that was point free
14:21:25 <Twey> Sometimes they end up horrible, though
14:21:34 <Woof> My thinking as well, Gracenotes
14:21:34 <ajh> but performance isn't that great
14:21:35 <jmcarthur> Rotaerk: as long as there are appropriate folds and projections and such for the data types you are using
14:21:49 <copumpkin> ajh: how much slower than c++?
14:21:53 <kmc> or as long as your types are represented by their church encodings ;)
14:22:01 <copumpkin> ajh: keep in mind that the mem-mapped version is basically constant time
14:22:08 <jmcarthur> kmc: aka a fold ;)
14:22:09 <Rotaerk> you guys use computer science on a level way above my head hehe
14:22:13 <copumpkin> ajh: so anything that actively decodes the file is going to be linear time
14:22:14 <ajh> well, O(N) since i'm actually doing something with it
14:22:22 <aavogt> @pl \a b c d e f g -> g e f d d d a b c
14:22:25 <lambdabot> ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . (flip =<< ((flip . (flip .)) .) . (flip =<< ((flip . (flip .)) .) .
14:22:25 <lambdabot> flip (flip . (flip .) . flip . flip id))))
14:22:33 <jmcarthur> Rotaerk: church encodings are easy to understand, maybe not so easy to come with every time
14:22:50 <jmcarthur> Rotaerk: consider data Nat = Zero | Succ Nat
14:22:56 <osaunders> @pl \x y z -> x + y + z
14:22:56 <lambdabot> ((+) .) . (+)
14:23:05 <osaunders> mm
14:23:09 <ajh> summing an integer column on a ~1M record file, 40bytes/record takes about 1.1s on my machine
14:23:40 <ajh> vs. about 0.03 for C++
14:23:44 <ajh> i'm not doing much processing
14:23:53 <jmcarthur> Rotaerk: the church encoding would be just a series of (a -> a) in place of Succ and (a) in place of Zero, making the whole structure just a function, basically
14:24:04 <copumpkin> ajh: well, still, you're not actually processing the file, just "interpreting" it as mapped memory
14:24:12 <Cale> Church encodings are always straightforward, aren't they?
14:24:12 <copumpkin> the struct is just guiding the compiler for offsets and types
14:24:15 <copumpkin> it's not copying the memory
14:24:30 <Rotaerk> ah
14:24:30 <Cale> You just replace each constructor of your datatype with a parameter to the lambda
14:24:37 <copumpkin> ajh: you can do the same in haskell but it's not as straightforward and we avoid that kind of hack like the plague :)
14:24:40 <ajh> agreed.  but i'm performing calculations based on the contents
14:24:46 <kmc> ajh, you can mmap the file and get it as a StorableArray
14:24:50 <jmcarthur> Cale: yeah, i guess it's always easy
14:24:56 <Gracenotes> Cale: hm... I suppose Church encodings are even straightforward for numbers, if you represent them as a linked list
14:24:58 <kmc> you might want to write a little bit of C to do that, and call it from Haskell by FFI
14:24:59 <Cale> Instead of writing  Succ (Succ Zero), you use (\zero succ -> succ (succ zero))
14:25:12 <Gracenotes> of unit type
14:25:13 <kmc> @hoogle mmap
14:25:14 <lambdabot> No results found
14:25:24 <Gracenotes> @hackage mmap-bytestring
14:25:25 <lambdabot> http://hackage.haskell.org/package/mmap-bytestring
14:25:30 <Gracenotes> other way around then
14:25:37 <Gracenotes> http://hackage.haskell.org/package/bytestring-mmap
14:25:44 <kmc> hmm there's also a "mmap" package
14:25:48 <kmc> very cool
14:26:05 <ski> `Zero' is replaced by `\zero succ -> zero', and `Succ' is replaced by `\n zero succ -> succ (n zero succ)'
14:26:16 <ajh> yes -- i tried with  bytestring-mmap
14:26:18 <ski> @type \a b -> (a * b *)
14:26:20 <lambdabot> forall a. (Num a) => a -> a -> a -> a
14:26:21 <ajh> and with storablevector
14:26:21 <ski> @type \a b -> (* a * b)
14:26:23 <lambdabot>     The operator `*' [infixl 7] of a section
14:26:23 <lambdabot>         must have lower precedence than that of the operand,
14:26:23 <lambdabot>           namely `*' [infixl 7]
14:26:30 <Gracenotes> that doesn't look.. natural
14:26:30 <ajh> neither gives great performance, at least compared to the C++ version
14:28:21 <kmc> ajh, odd, did you profile it?
14:28:53 <ajh> no, sorry.  i'm new to haskell
14:29:25 <ajh> i've never profiled anything
14:29:44 <ajh> kmc: are you proposing I use an IOUArray or are you proposing a StorableArray?
14:30:46 <Cale> I guess the realisation which Church encodings give you is that you can blatantly treat function parameters as a way to build structures in almost arbitrary ways. If the structures you want are built from some finite collection of constructors, you can just write a lambda with each of those constructors as parameters, and put your structure on the right hand side of the ->
14:30:58 <Lemmih> ajh: Is your code online?
14:31:14 <ajh> my code's not online yet.  where should i put it?
14:31:31 <Lemmih> ?paste
14:31:32 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:31:39 <kmc> i think only the StorableArray will definitely work when loaded from contiguous memory external to haskell
14:31:57 <kmc> but if you already tried bytestring-mmap and storable-vector, i don't know that it's worth trying StorableArray
14:32:02 <ajh> oh, it's C copatible, right?
14:33:12 <ajh> lemmih - just a second.  i'm cleaning it up
14:34:20 * Cale wonders why typing in editboxes in firefox seems to have gotten a lot slower. I'm just typing in Gmail, and the display lags behind my typing by several characters which eventually forces me to stop and let it catch up.
14:34:47 <copumpkin> Cale: typing is very CPU-intensive, you need a faster machine :)
14:34:49 <xternal> cale, I get slowdown with ff in gmail too in different areas
14:34:57 <copumpkin> Cale: maybe type top and see if anyone's omnom'ing your cycles?
14:35:04 <xternal> I think this is a current known "feature"
14:35:32 <kfish> i think gmail omnoms
14:35:34 <Cale> It's happening in wordpress too.
14:35:53 <kfish> ah, then ff omnoms
14:35:57 <xternal> hrm, I wonder, disable spellchecking, is that possible?
14:36:12 <Cale> Heh, maybe it's google trying to get everyone to switch to chrome
14:36:13 <xternal> but yeah, annoying whatever it is
14:36:16 <xternal> haha
14:36:33 <xternal> when I switch to a gmail tab in ff, it takes like 1 or 2 seconds to pull up, sometimes
14:36:39 <xternal> annoying.
14:36:52 <rasfar> I've noticed that when the quoted text is getting long, but only on my eeepc.
14:37:52 <ajh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5292
14:38:24 <copumpkin> omg Cale must be writing a new analogical-engine entry!
14:38:29 <copumpkin> if he's talking about wordpress writing!
14:38:33 * copumpkin is such a sleuth
14:39:01 <copumpkin> http://snapplr.com/yz9a :)
14:40:14 <ajh> Lemmih: any thoughts?
14:40:56 <Lemmih> ajh: The unpack+foldl thingy seems suspiscious.
14:41:04 <ajh> Agreed
14:41:43 <Lemmih> ajh: Try SV.foldl'
14:41:45 <copumpkin> isn't there a foldl' on it?
14:42:24 <ajh> Right.  I tried SV.foldl and blew up the stack
14:42:36 <copumpkin> ajh: foldl' ?
14:42:49 <Lemmih> ajh: The tick at the end is important.
14:42:56 <Cale> copumpkin: I wrote one today.
14:42:59 <ajh> Oh
14:43:16 <Lemmih> > foldl (+) 0 [1..1000000]
14:43:18 <lambdabot>   * Exception: stack overflow
14:43:19 <Lemmih> > foldl' (+) 0 [1..1000000]
14:43:20 <lambdabot>   500000500000
14:43:24 <Cale> copumpkin: But I have lots of writing to do. :)
14:43:30 <copumpkin> Cale: yay!
14:43:32 <copumpkin> well, yay for us :P
14:43:32 <ajh> ah hah!
14:43:55 <ajh> hooray for ticks
14:44:00 <copumpkin> ajh: should be quite fast now ?
14:44:07 <copumpkin> ajh: the tick is telling it to be strict in the accumulator
14:44:13 <copumpkin> otherwise it doesn't bother evaluating it
14:44:17 <copumpkin> and builds up a huge pile of nested thunks
14:44:29 <Cale> copumpkin: There are almost too many topics I want to write about to decide what to write about first, so I'm going to start covering things in an approximately random order, and one of the first things will be an index page to stick things into.
14:44:48 <ajh> copumpkin, i'm not sure i follow but i can look at it in more detail
14:45:01 <copumpkin> ajh: basically, laziness is good but sometimes you don't want it :)
14:45:16 <ajh> it's about 1s now
14:45:27 <ajh> which is a speedup, but still ~30x slower than the C++
14:45:32 <ajh> hmm..
14:45:43 <copumpkin> Cale: if you can glean any more information from psykotic's inverting relations over topoi = bayes' theorem, I'd be very eager to hear about that :P but pretty much everything is interesting
14:45:47 <Gracenotes> without the prime, internally it's storing information about what to add with what without actually *adding* it
14:45:48 <Lemmih> ajh: Compiling with -O2?
14:45:53 <ajh> -O3
14:46:03 <copumpkin> -O2 is as fast as it goes :)
14:46:07 <Cale> ajh: Basically, the parts of your program where you're collapsing lots of data into small bits of data should be strict, and everything else should be lazy :)
14:46:20 <Lemmih> ajh: How much time does it spend in GC? You can ask it with '+RTS -s -RTS'.
14:46:22 <copumpkin> ajh: you should probably try profiling now
14:46:36 <ajh> i'm drowning in helpful suggestions!
14:46:38 <Cale> ajh: (that is, by some kind of summarization, rather than by searching)
14:46:50 <Cale> ajh: :)
14:47:15 <ajh> Cale: so i should favor strict folds in general?
14:47:31 <copumpkin> ajh: foldl is almost always a bad idea
14:47:39 <copumpkin> ajh: foldl' and foldr should be your main choices
14:48:37 <jmcarthur> @src foldl'
14:48:37 <lambdabot> foldl' f a []     = a
14:48:37 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:49:06 <ajh> @src foldl
14:49:07 <lambdabot> foldl f z []     = z
14:49:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:50:01 <ajh> i'm completely boggled that the foldl implementation is problematic
14:50:16 <ajh> but let me help Lemmih help me
14:50:42 <ajh> Lemmih: Is this the relevant line from the RTS output?
14:50:50 <ajh>   %GC time       4.2%  (3.4% elapsed)
14:51:00 <copumpkin> yeah, and it doesn't look too bad
14:51:11 <copumpkin> ajh: you could try mmap now
14:51:49 <Lemmih> ajh: Perhaps you should try lazy vectors.
14:52:18 <ajh> my other implementation was with Data.ByteString.Lazy
14:52:37 <ajh> and Data.Binary.Get to get at the fields
14:52:46 <kmc> > foldl f z [a,b,c]
14:52:48 <lambdabot>   f (f (f z a) b) c
14:53:11 <ajh> i'm using records with fields of varying sizes
14:53:19 <kmc> ajh, foldl will build that entire expression in memory before evaluating any of it
14:53:36 <kmc> foldl' will first reduce (f z a) before building something around it
14:53:55 <ajh> kmc: are you suggesting i switch from foldl to foldl' ?
14:54:08 <kmc> that was already suggested
14:54:27 <kmc> foldr does not have this problem because it folds in the same direction as the list structure; elements are "consumed" by the caller of foldr as they are "produced"
14:54:56 <kmc> foldr simply replaces every (:) with f and the [] with z
14:55:09 <ajh> that makes sense
14:55:17 <ajh> StorableVector was still blowing the stack
14:55:29 <kmc> > foldr f z (a:b:c:[])
14:55:30 <lambdabot>   f a (f b (f c z))
14:55:35 <ajh> I suppose that's expected, seeing as I have a 40M record file
14:56:48 <ajh> Lemmih: you're proposing I use Data.StorableVector.Lazy ?
14:56:56 <Lemmih> ajh: Yes.
14:59:40 <Lemmih> ajh: I could give you more advice with some working code.
15:00:14 <ajh> lemmih, the code i put up on moonpatio works
15:00:21 <ajh> but you're missing a relevant datafile
15:00:39 <Lemmih> Oh, my bad.
15:01:36 <manju> who is Tony Morris ?
15:02:08 <shachaf> manju: dibblego
15:02:22 <manju> shachaf: hmmm
15:02:30 <ajh> aah!  Data.StorableVector.Lazy is much slower
15:02:39 <ajh> ~4s to read through a file instead of ~1s
15:04:40 <dibblego> manju, ?
15:05:08 <manju> dibblego: hmm..I saw your post on religion
15:05:21 <dibblego> which?
15:05:22 <manju> dibblego: An Atheistic Appeal
15:05:25 <dibblego> ah ok
15:05:51 <manju> dibblego: maybe this is not the right channel to discuss philosphy
15:06:02 <dibblego> indeed
15:06:19 * SmurfOR is now intrigued
15:06:27 <manju> dibblego: we can go priv, I have a couple of questions
15:06:31 <dibblego> ok
15:06:52 <manju> dibblego: or start a new temp channel that SmurfORcan join :-)
15:06:58 <kmc> haskell-blah
15:07:11 <manju> kmc: ah right
15:07:29 <manju> ok I joined that channel
15:07:51 <manju> dibblego: we can talk in #haskell-blah
15:07:58 <dibblego> ok
15:09:29 <Stinger> hmmm if you put a over general type system on a function will it complain, or only if you try to use it with an unsuitable type
15:09:43 <Stinger> it being ghc I suppose
15:10:03 <Stinger> over general type signature*
15:10:38 <ajh> Lemmih: any thoughts on the code?
15:10:58 <ajh> i was at first thinking there might be some constant overhead to mmapping a file
15:11:16 <ajh> but the program runs essentially instantly on a very small
15:11:20 <kmc> it will complain straight away
15:11:53 <kmc> > let f :: a -> b; f = (+1) in f 3
15:11:54 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
15:11:54 <lambdabot>    arising from the li...
15:12:53 <Lemmih> ajh: The tuples might be a problem.
15:13:23 <Twey> Stinger: There's no such thing as a type that is unsuitable because a signature is too general
15:13:31 <toast-opt> so the type annotation you provide has to match exactly or be strictly more restrictive?
15:13:47 <ajh> Lemmih, is there a better way to deal with the data?  or are composite types just slow in general?
15:13:48 <Twey> :t (+)
15:13:50 <lambdabot> forall a. (Num a) => a -> a -> a
15:13:58 <Twey> :t (3 :: Int) + (4 :: Int)
15:13:59 <lambdabot> Int
15:14:14 <Lemmih> ajh: Try this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5292#a5293
15:14:25 <Twey> If the type is too *restrictive* it will cause an error
15:14:38 <Stinger> yeah toast-op s.w.i.m.
15:14:40 <Twey> With generality, you only have to worry about the DMMR
15:15:11 <Stinger> and kmc preconfirmed that it appears
15:15:19 <ajh> ok.  i'm plugging it in
15:16:34 <kmc> in some cases you can give a valid signature that is *more* general than the inferred type
15:16:37 <Twey> The problem in kmc's example is simply that the provided and inferred types of the function itself do not match
15:17:00 <Twey> (+ 1) is of type Num a => a -> a, not a -> b
15:17:20 <Stinger> a -> b can be a -> a can't it?
15:17:36 <Twey> Yes, but not (Num a, Num b) => a -> b
15:17:48 <kmc> > let f :: a -> a; f = (+1) in f 3
15:17:50 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
15:17:50 <lambdabot>    arising from the li...
15:17:58 <kmc> > let f :: (Num a, Num b) => a -> b; f = (+1) in f 3
15:17:59 <lambdabot>   Couldn't match expected type `b' against inferred type `a'
15:18:00 <lambdabot>    `b' is a rigi...
15:18:13 <ajh> Oh!
15:18:16 <kmc> ^^^^ neither of those is a specialization of (Num a) => a -> a
15:18:22 <ajh> Lemmih: that made a big difference
15:18:43 <Lemmih> ajh: How big?
15:19:01 <ajh> it's down to ~0.165s
15:19:12 <ajh> so a 6 or 7 times performance improvement
15:19:26 <ajh> i think that's close enough to the C performance that i'll stop worrying about it
15:19:41 <ajh> i'm mystified about the pragmas, though
15:20:14 <ajh> i see.  and the fields are unboxed, too
15:21:29 <Lemmih> ajh: This is about as fast as you can go with GHC. The code compiles to a tight loop without any boxing.
15:22:35 <ajh> i think i'll have to read up on boxing and packing.  thanks lemmih
15:30:09 <conal> i have an odd question.  why does this code type-check?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13785
15:32:07 <Stinger> memo doesnt change the type?
15:32:23 <conal> Stinger: right.  it doesn't
15:32:33 <Stinger> memoM = memo
15:32:40 <Stinger> doesn't change the type either
15:35:28 <conal> i'm experimenting with polymorphic memoization (as on my blog), and i expected that memoM def not to type-check.
15:40:25 <blobl> anyone knows how to change colors using hscurses?
15:42:22 <reltuk> anyone know what cabal's default ghc compiler flags are?
15:45:48 <Saizan> reltuk: you can use -v to see the flags passed
15:46:20 <reltuk> Saizan: ahhh, very good
15:46:39 <reltuk> apparently optimizations have no effect on my programs speed =/
15:47:30 <reltuk> -O, -O2, -O2 -fvia-C, -O2 -fvia-C -funbox-strict-fields all perform basically the same
15:47:42 <reltuk> and no flags
15:48:38 <Saizan> reltuk: do you "cabal clean" between them?
15:48:44 <reltuk> Saizan: yeah
15:48:56 <reltuk> Saizan : and configure, because that's how I pass it the flags I guess
15:49:41 <Saizan> reltuk: no, "cabal install" doesn't respect the flag passed to a previous "cabal configure"
15:50:54 <Saizan> reltuk: try with  "cabal clean && cabal install -O2"
15:51:10 <reltuk> Saizan: I'm just building it manually...no install...so cabal clean && cabal configure --user && cabal build
15:51:54 <Saizan> reltuk: ah, ok, so you're running the binary from inside dist?
15:52:09 <Lemmih> reltuk: configure doesn't take build flags.
15:52:26 <reltuk> Lemmih: yeah, I change them in the .cabal file
15:52:47 <Saizan> Lemmih: it takes -On , actually
15:54:06 <Lemmih> Saizan: Right, but not arbitrary build flags like -funbox-strict-fields.
15:54:49 <Lemmih> reltuk: Does your program run in a measurable amount of time?
15:55:56 <reltuk> Lemmih: yeah...I simulate a bunch of card games, so you just simulate tens of thousands if you want to measure it
15:56:13 <Lemmih> reltuk: How much of the runtime is MUT time?
15:56:40 <reltuk> MUT?
15:57:00 <Lemmih> reltuk: +RTS -s -RTS
15:59:32 <reltuk> 100s out of 108s...on the profiled non-threaded app
16:04:41 <reltuk> oh, cabal is always passing -O....that makes more sense
16:08:17 <reltuk> yep, much slower without -O...now I can rest easy :-)
16:14:33 <Cale> http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
16:17:07 <JoshTriplett> Anyone know of a Haskell beanstalkd binding, or a binding to another sensible queuing system?
16:17:17 <ketil> what happened to ctrl-p in ghci? (from 6.8.x to 6.10.4)
16:17:25 <JoshTriplett> (The various obvious Google searches didn't turn anything up.)
16:17:33 <JoshTriplett> ketil: readline went away.
16:17:37 <ketil> oh.
16:17:38 <shachaf> ketil: Well, it doesn't use readline anymore.
16:17:52 * shachaf liked readline more than the Haskell library it uses now.
16:17:56 * JoshTriplett too.
16:18:01 <ketil> 'course.  Can I have it back?  (At least the emacsy bindings)?
16:18:11 <ketil> Haskeline, then?
16:18:15 * JoshTriplett would settle for working home and end.
16:18:28 <shachaf> JoshTriplett: Ctrl-A/Ctrl-E work.
16:18:32 <JoshTriplett> And for lines that wrap rather than moving left and right.
16:18:37 <ivanm> shachaf: 6.10.1 to 6.10.3 _can_ use readline (kolmodin patched it)
16:18:49 <JoshTriplett> shachaf: My fingers don't have those wired in. ;)
16:18:57 * shachaf is running... 6.11.20090501.
16:18:58 <shachaf> Ha.
16:19:07 <shachaf> About time to upgrade, I suppose. But it always gets messed up when I do.
16:19:13 <Saizan> ketil: see the documentation on the trac, you can add your own bindings
16:19:43 <ketil> okay.  Or.. perhaps I should just go with the flow and use C-l in my Emacs buffer more often.
16:19:50 <JoshTriplett> http://trac.haskell.org/haskeline/wiki/CustomKeyBindings looks promising.
16:19:55 <ketil> Saves me hunting for the right xterm all the time :-)
16:20:36 <Saizan> i think you could actually report standard bindings that are missing as bugs
16:21:07 <JoshTriplett> Saizan: Long list.  But yeah, I think I will, now that I know it has a trac.
16:21:27 <ketil> (sorry: C-c C-l)
16:22:46 <ivanm> ketil: and set C-c C-r to inferior-haskell-reload-file !
16:31:39 <JoshTriplett> ketil: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13788#a13788
16:31:55 <JoshTriplett> ketil: That should fix home, end, delete, ctrl-p, and ctrl-n
16:32:05 <JoshTriplett> ketil: Working on some of the others that my fingers don't want to give up.
16:35:31 <JoshTriplett> OK, the new version at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13788#a13790 also handles ctrl-arrows to move by word.
16:36:58 <JoshTriplett> And apparently I can't have yank back with the version of haskeline I have.
16:40:03 <bastl> good morning everyone!
16:40:20 <EnglishGent> hi bastl :)
16:41:38 <bastl> perhaps OT: I setup my thesis (multidocument) with emacs, lhs2tex and latexmk. Does anyone know how to launch the Makefile from emacs !?
16:42:09 <ketil> JoshTriplett, great, thanks!
16:42:32 <JoshTriplett> ketil: Want a CC on the Trac ticket to get those added by default?
16:42:41 <p_l> bastl: M-x compile ?
16:43:24 <bastl> ah :-)
16:43:38 <bastl> \me was/is a vim addict ...
16:43:54 <bastl> emacs feels like methadone ...
16:44:19 * JoshTriplett recommends binding M-x compile to a key.
16:44:28 <JoshTriplett> Lest your fingers wear out from typing it so often.
16:44:44 <JoshTriplett> Somehow, :make doesn't feel so onerous. ;)
16:45:11 <bastl> thanks so long, (before getting too OT ;-) )
16:45:21 * Twey has it on F12
16:45:41 <JoshTriplett> (Tip for using a Cabal project: :set makeprg=./Setup.hs , then :make configure --user , :make build , and so on.  vim recognizes Haskell errors by default and goes to file/line/column.)
16:46:01 <ketil> JoshTriplett, cc counts as a vote, no?  (I don't need mail, but can always contribute some weight if it helps)
16:46:09 <blobl> is there anything like a visual basic timer in haskell?
16:46:24 <JoshTriplett> ketil: Nah, not needed for voting purposes; just if you want to hear when it gets fixed.
16:46:37 <JoshTriplett> blobl: Tell us how a visual basic timer works, and we'll help you find an equivalent. :)
16:47:16 <bastl> JoshTriplett: that tip is useful. Wanna post it to http://vim.wikia.org ?
16:47:27 <blobl> that visual basic thing ticks every n secs.. and executes code.. basically im writting a little snake game so i thought i need something like that
16:47:29 <JoshTriplett> bastl: Sure.
16:47:48 <blobl> got any ideas? im searching in hayoo but im not very good
16:47:52 <JoshTriplett> bastl: also, regarding LaTeX: if you use LaTeX with Emacs, you *really* want AUCTeX mode.
16:48:12 <JoshTriplett> bastl: C-c C-c, the "do what I want next" key.
16:48:25 <bastl> yeah thats the reason i switched from vims latex-suite ...
16:48:51 <JoshTriplett> I think you can convince Emacs to build a multi-file LaTeX project automatically.
16:49:05 <JoshTriplett> bastl: Though getting it to invoke lhs2tex would require more work. :)
16:49:21 <bastl> JoshTriplett: All that worked perfectly until I decided to use lhs2TeX for haskell typesetting ...
16:49:29 <JoshTriplett> Ah.
16:50:48 <JoshTriplett> http://trac.haskell.org/haskeline/ticket/102 , for anyone who cares.
16:50:59 <JoshTriplett> blobl: Haskell has various timer facilities similar to that.  Checking...
16:51:57 <JoshTriplett> blobl: Using a GUI framework, or a text interface like curses?
16:52:05 <blobl> text interface
16:52:12 <blobl> josh must be famous
16:52:22 <blobl> or is it you ? :D
16:52:33 <JoshTriplett> ?
16:53:05 <JoshTriplett> blobl: Oh, the trac ticket?  Yeah, just filed that based on previous discussion in the channel.
16:54:06 <blobl> ya sorry i though you were someone else, most probably
16:54:34 <JoshTriplett> blobl: I might be.  Who did you have in mind? ;)
16:56:12 <blobl> you reversing sometimes? cant recall though it has been ages
16:57:11 <JoshTriplett> Hmmm.  I've done the occasional bit, but not often and not recently.
16:57:32 <JoshTriplett> blobl: As for your question: I don't see any readily available sources of timers, apart from those in GUI frameworks. :(
16:57:51 <blobl> ya that is xmonad right? i saw that one too
16:58:03 <JoshTriplett> I meant things like GTK and wxHaskell.
16:58:14 <JoshTriplett> But yeah, xmonad probably has stuff too.
16:58:33 <JoshTriplett> blobl: You could take the approach of updating in a cycle, and checking how much time has passed.  That sucks, though; you really want to sleep.
16:58:59 <JoshTriplett> You could fake it, with threadDelay, but that doesn't actually check time elapsed since the last frame, so your frames will vary depending on how long you compute.
16:59:38 <JoshTriplett> At best, you could get the time right after you wake up, then right before you go to sleep again you could compute how long you need to sleep.
16:59:49 <JoshTriplett> That still sucks compared to a sensible timer, but it would get the job done.
16:59:54 <JoshTriplett> Does that help?
17:00:01 <dv-> SDL_gfx has some fancy timer stuff I believe
17:00:17 <JoshTriplett> dv-: True, but he wanted something sensible for use in a text-based program.
17:01:17 <dv-> well, you don't need to use graphics to use it
17:01:26 <dv-> http://hackage.haskell.org/packages/archive/SDL-gfx/0.5.2/doc/html/Graphics-UI-SDL-Framerate.html
17:01:27 <JoshTriplett> Granted, but it seems a silly dependency. :)
17:01:42 <dv-> and you can always use sdl + opengl to render the text, kind of like dwarf fortress
17:01:47 <JoshTriplett> Heh.
17:01:50 <JoshTriplett> Point.
17:01:55 <JoshTriplett> Good luck using ncurses with that, though. :)
17:02:38 <JoshTriplett> blobl: I can give you *lots* of options if you don't care about portability, BTW.
17:02:47 <JoshTriplett> blobl: If you don't mind only running on POSIX, for instance.
17:06:27 <blobl> i think i will just go buy some cigarettes :D thanks anyway
17:07:31 <blobl> what about threads though? that seemed like the solution.
17:08:06 <blobl> i will smoke first.
17:18:02 <JoshTriplett> blobl: Snake demo I made a while back as a test program for arrays: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13792#a13792
17:18:22 <JoshTriplett> Fun to see.  Needs ByteString and UTF8String.
17:35:07 <blobl> JoshTriplett: why do you need arrays for? just got back
17:35:59 <JoshTriplett> blobl: That particular program uses arrays to store the text "pixels" before printing them.
17:36:12 <JoshTriplett> blobl: Mostly to test arrays, but also to test a fascinating corner of Unicode. :)
17:36:32 <JoshTriplett> blobl: I highly recommend trying it.  You'll get a kick out of it. :)
17:38:52 <blobl> cant have a list for a history of movements made right?
17:40:43 <blobl> trying arrays or your program?
17:41:41 <JoshTriplett> My snake program.
17:42:20 <JoshTriplett> blobl: I dunno what data structure makes the most sense for a program that lets the snakes wander under keyboard or computer control.  Mine has them move in fixed patterns, so I don't need a history of any kind.
17:44:38 <blobl> wheres that snake program? can i see it please?
17:48:08 <JoshTriplett> On hpaste.
17:48:12 <gio123> is there anybody from portugal?
17:48:16 <JoshTriplett> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13792#a13792
17:49:10 <blobl> cool thanks man
17:54:47 <fasta> Does cabal install zlib work for anyone out of the box on Ubuntu 9.10?
17:55:11 <fasta> When I load it I get that libz.so cannot be found.
17:55:26 <fasta> I have libz.so.1
17:55:27 <Lemmih> fasta: Install libz?
17:55:40 <blackh> fasta: Works for me
17:55:55 <blackh> fasta: Have you got zlib1g-dev ?
17:55:57 <Lemmih> fasta: libz-dev?
17:56:58 <fasta> Lemmih, ok, seems to work now. What exactly is in the dev package? I figured just having the .so would be enough.
17:57:08 <quicksilver> the .so symlink is in the dev package
17:57:17 <quicksilver> the dev package contains those things needed to compile.
17:57:24 <quicksilver> (headers + symlinks)
17:57:39 <fasta> Then what is the .so.1 file?
17:57:50 <quicksilver> the actual library, not the symlink.
17:57:53 <fasta> That is, is the non-dev package useful in some way?
17:58:06 <quicksilver> yes, you can use it run applications which have already been compiled.
17:59:13 <fasta> quicksilver, so somewhere in these applications there are some instructions which tell it to look for the .so.1 file?
17:59:29 <quicksilver> embedded in the binary by the linker, yes
17:59:43 <fasta> I guess that is called the rpath.
17:59:54 <quicksilver> no, the rpath is a way to override the standard searching
18:10:36 <JoshTriplett> fasta: Try running "ldd YourHaskellProgram".
18:10:49 <JoshTriplett> fasta: You should see a list of the libraries it wants, and where the linker found them.
18:12:06 <fasta> JoshTriplett, the minor problem has already been solved. I just wanted to know basically what my last question was out of curiosity. Thanks, anyway.
18:12:35 <JoshTriplett> fasta: Sure.  Understanding the linker can help with understanding various library problems.
18:12:52 <JoshTriplett> fasta: For more information than you probably want to know, check out the output of "objdump -x YourProgram".
18:13:05 <fasta> JoshTriplett, yes, and there is also nm.
18:13:13 * JoshTriplett nods.
18:13:15 <fasta> JoshTriplett, and on Windows Dependency Walker.
18:13:31 <JoshTriplett> Yeah, I vaguely remember using that when I developed on Windows. :)
18:13:41 <fasta> JoshTriplett, and I already tried reading the ld source code once. I cannot recommend doing that.
18:13:55 <fasta> 15KLOC source files :/
18:13:58 <JoshTriplett> fasta: Not unless you have a good psychiatrist on speed dial. :)
18:38:50 * hackagebot upload: parallel 2.2.0.1 - Parallel programming library (SimonMarlow)
18:41:10 <blobl> JoshTriplett: concurrent is supercool
18:41:24 <ivanm> so, is this the "stable" parallel 2 release?
18:41:35 <JoshTriplett> blobl: Indeed, though note that not all of concurrent runs as fast as you might like.
18:41:45 <JoshTriplett> blobl: But it has some cool bits in it.
18:43:15 <manju> twice f x = f (f x) how is the type defined for this ?
18:43:18 <blobl> never had done that. first time. seems like amazing concept. anyway it wont do much just check a list with max length 1840 elems
18:43:31 <manju> twice :: (t -> t) -> t -> t
18:43:52 <manju> ah..nevermind, I think I got it
18:44:21 <manju> twice takes a function which takes a type t and a type t and returns t ?
18:44:43 <mauke> yes
18:44:52 <manju> thanks
18:44:53 <mauke> @djinn (t -> t) -> t -> t
18:44:53 <lambdabot> f a = a
18:44:56 <mauke> hmm
18:45:06 <mauke> ok, that's technically correct
18:46:53 <manju> what ?
18:46:57 <quicksilver> (t -> t) -> (t -> t) ~~ Nat
18:47:23 <manju> how is (t -> t) -> t -> t, f a = a
18:47:30 <manju> shouldn't it be
18:47:47 <manju> er...no idea
18:47:59 <mauke> f x y = x y
18:48:14 <mauke> manju: well, -> in types is right associative
18:48:28 <manju> I have no idea what (t -> t)
18:48:31 <mauke> so '(t -> t) -> t -> t' is actually the same as '(t -> t) -> (t -> t)'
18:48:48 <manju> @djinn (t -> t)
18:48:49 <lambdabot> f a = a
18:48:56 <mauke> which you can read as "a function taking a function and returning a function (of the same type)'
18:49:02 <manju> @djinn (t -> t) -> (t -> t)
18:49:02 <lambdabot> f a = a
18:49:10 <manju> eh ? :-/
18:49:17 <mauke> hmm?
18:49:17 <manju> ah
18:49:27 <manju> ok
18:49:30 <manju> but then
18:49:37 <manju> f a = f no ?
18:49:41 <ivanm> no
18:49:41 <mauke> huh?
18:49:53 <manju> a is a type
18:50:04 <manju> f is the function
18:50:12 <MarcWeber> can you upload the same package version to hackage again containing some fixes?
18:50:19 <ivanm> @type let f a = f no in f
18:50:20 <lambdabot> Not in scope: `no'
18:50:29 <mauke> manju: then 'f a' makes no sense
18:50:37 <ivanm> MarcWeber: no
18:50:39 <manju> sorry no is well no in english
18:50:43 <manju> I meant isn't it
18:50:44 <ivanm> MarcWeber: you have to bump the version
18:50:50 <MarcWeber> ivanm: But isn't this insane?
18:50:51 <ivanm> manju: f a =/= f
18:50:56 <ivanm> since you've applied a value
18:51:02 <MarcWeber> ivanm: Can you remove old versions then?
18:51:03 <ivanm> MarcWeber: well, there's two reasons
18:51:04 <manju> ok
18:51:07 <manju> f a = fa
18:51:10 <manju> f a = f a
18:51:17 <ivanm> 1) it's meant to be an archive of all haskell software, so old versions can't be removed
18:51:45 <ivanm> 2) what happens if you upload a buggy x.y, someone downloads it, then you released a fixed x.y; how can you tell if you have a buggy or fixed one?
18:51:58 <ivanm> manju: right, that's a different story
18:52:03 <ivanm> @type let f a = f a in f
18:52:05 <lambdabot> forall t t1. t -> t1
18:52:07 <mauke> f :: a -> b
18:52:17 <ivanm> manju: ^^ its type is undefined, because it will never end
18:52:26 <mauke> the type is clearly defined
18:52:29 <manju> ivanm: ok
18:52:47 <ivanm> mauke: well, the _result_ type
18:53:01 <mauke> well, all of it
18:53:13 <scree_> the types are all well-defined, just not populated
18:53:18 <MarcWeber> ivanm: I'm asking because of version constraints. There are very often plain wrong. They don't fit current ghc version, they don't contain (or no longer do contain split-syb) and such stuff. However uploading a new package for each of those minor tweaks is insane. Why? Because hackage index grows infinitely. And time required to fidn a solution may raise as well
18:53:59 <manju> ivanm: I think I get it now, f a = a, where a can be a function as well
18:54:21 <ivanm> scree_: semantics ;-)
18:54:33 <mauke> @src id
18:54:33 <lambdabot> id x = x
18:54:38 <MarcWeber> ivanm: Maybe I should use an older ghc release than 6.10.4 to compile some libs..
18:54:38 <mauke> > (id sqrt) 2
18:54:39 <lambdabot>   1.4142135623730951
18:54:40 <ivanm> MarcWeber: yeah, there's different people trying to work out a sane way of fixing that
18:55:14 <ivanm> MarcWeber: the main problem is that the cabal file is inside the tarball; one approach dcoutts is thinking of is to have a separate cabal file on hackage which you can edit to update the versions of the deps
18:55:19 <MarcWeber> ivanm: A sane way would be creating a branch for base < 4, base > 4 etc and fix those bugs on those branches.
18:55:50 <ivanm> MarcWeber: usually, the only problems with base-3 vs base-4 is the new exception stuff; in that case, you can use extensible-exceptions
18:55:59 <MarcWeber> ivanm: Then I still get the old .cabal when downloading the tar ball?
18:56:13 <MarcWeber> ivanm: I can. But I have to do so.
18:56:18 <ivanm> syb makes it more interesting, so you have to do something like base==3.* || (base==4.* && syb)
18:56:47 <ivanm> MarcWeber: yeah, I have no idea how that approach is going to go; I think they're working on having cabal-install using the hackage cabal file rather than the tarball cabal file
18:57:09 <MarcWeber> ivanm: http://github.com/MarcWeber/haskell-nix-overlay Have a look at the folder patches. My current goal is compiling a darcs gui.
18:57:11 * ivanm thinks hackage should maybe go via the gentoo-ebuild route, where the cabal file is not in the tarball but downloaded seperately
18:57:21 <ivanm> MarcWeber: a darcs gui?
18:57:23 <MarcWeber> darcs is still based on base3. That's causing some trouble to me.
18:57:26 * ivanm didn't know there was one
18:57:28 <ivanm> MarcWeber: ahhh
18:58:20 <ivanm> MarcWeber: with gentoo, we don't try to have all packages available, because it's then impossible to check they all work (I've been doing some stuff on-and-off lately in cleaning out old out-of-date libraries that no-one cares about in our overlay)
18:58:33 <ivanm> QtPlaty[HireMe]: how long have y ou been looking for work for?
18:58:51 <MarcWeber> ivanm: http://lists.osuosl.org/pipermail/darcs-users/2009-November/022428.html
18:59:30 <MarcWeber> ivanm: So how about you. How would you proceed? Make packages compile with most recent ghc rather than fixing cosntraints and patching old packages?
18:59:48 <ivanm> MarcWeber: we make them as generic as possible, but specify new ghc if needed to
19:00:01 <QtPlaty[HireMe]> ~/
19:00:02 <QtPlaty[HireMe]> .
19:00:04 <ivanm> MarcWeber: we unfortunately still support ghc 6.2
19:00:04 <QtPlaty[HireMe]> ~
19:00:21 <QtPlaty[HireMe]> 6 months
19:00:31 <QtPlaty[HireMe]> (sorry about that)
19:00:49 <MarcWeber> ivanm: you can't install all packages at the same time by desing, can you?  I mean you should have only one parsec in a dependency chain. If you don't cabal tells you that you may be in trouble (eg when using different cabal versions)..
19:01:27 <ivanm> ahhh
19:01:36 <ivanm> MarcWeber: don't know about that, we allow both parsecs to be installed though
19:01:55 <ivanm> since in gentoo you can "slot" multiple versions of a package (we do it for parsec and haxml)
19:02:05 <MarcWeber> ivanm: It's about having a third library depending on A,B where A and B have been compiled with different parsec libraries
19:02:21 <ivanm> MarcWeber: right, that can be a problem... haven't heard of that occuring though
19:02:45 <MarcWeber> ivanm: I've used gentoo for 2 years 2 years ago. So I tried fixing this by building a environment for each package I want to compile automatically
19:02:54 <ivanm> *nod*
19:02:55 <MarcWeber> one env can have parsec2 antoher can have parsec3
19:03:36 <ivanm> *nod*
19:03:37 <MarcWeber> It's even working pretty well except that nix (or my implementation) is to slow. I can't allow feeding all packages into the solver.
19:04:02 <MarcWeber> So the easiest thing to do is "fix everything" and go upstream only.
19:06:32 <iwikiwi> hi, i have am new to functional languages. And i was wondering how good haskell would be with writing a system of linear equations (which i can generalize so i can play with a wide range of input equations) I will also have to find the values at the minima(differentiate and equate to zero and do some algebra). Is this feasible in haskell? or should i stick to matlab?
19:06:41 <iwikiwi> -have
19:07:27 <manju> iwikiwi: if matlab is working why do you want to use haskell ?
19:08:14 <iwikiwi> manju, I never said it did. I would have to learn matlab to make it work.
19:08:30 <ivanm> heh
19:08:35 <nagnatron> iwikiwi: My experience tells me that what you want to do would be easy in matlab.
19:08:44 <manju> :-)
19:08:59 <ivanm> iwikiwi: you can; for something that specific it might be easier to learn how to do it in matlab or something than in Haskell
19:09:08 <ivanm> there's hmatrix though...
19:09:31 <b0fh_ua> Hi there! Can I use several "where" clauses in an expression?
19:09:34 <manju> but matlab is 'designed' for stuff like this
19:10:06 <MarcWeber> iwikiwi: Unless you want to spend huge amounts of time reimplementing a system use a system which is known to work. Eg Matlab, Octave, Maple, Mupad, maxima etc..
19:10:13 <Saizan_> b0fh_ua: where clauses attach on declarations, and you can nest them
19:10:30 <iwikiwi> ivanm, nagnatron , manju: alright, I will go with matlab.
19:10:58 <iwikiwi> MarcWeber, ah, that makes sense. I will go with matlab.
19:11:03 <Saizan_> doesn't hmatrix already provide the basic functionality? solving linera equations is not really advanced
19:11:07 <Saizan_> *linear
19:11:08 <ivanm> iwikiwi: or, if you prefer a non-proprietary environment, there's octave, pylab, sage, etc.
19:11:21 <ivanm> Saizan_: yeah, it just might be harder for him to work out how to do it
19:11:34 <Saizan_> though an interactive environment might be valuable etc..
19:11:38 <ivanm> since it sounds like iwikiwi is new to Haskell; matlab would be easier to learn just to do that IMHO
19:11:40 <ivanm> Saizan_: exactly
19:12:32 <fasta> iwikiwi, the thing is: if you learn Haskell you will be able to connect to anything. In Matlab you buy some limited environment in which some things are easy (your problem for example).
19:12:36 <manju> Saizan_: matlab has an interactive environment
19:12:41 <iwikiwi> Saizan_, the problem is not outputting a specific numeric result. It is derivating to get a system of linear eqs and then use that string, do some algebra and again substitute in another eq etc.
19:12:47 <ivanm> manju: that's what he meant
19:13:19 <fasta> IIRC, Matlab doesn't even have reference types.
19:13:24 <Saizan_> iwikiwi: ah, symbolic manipulation then?
19:13:27 <iwikiwi> yes
19:13:38 <manju> ivanm: ok :-)
19:13:40 <Saizan_> not sure how good matlab is for that
19:14:00 <ivanm> symbolic toolkit isn't bad
19:14:05 <ivanm> maxima or something would be better though
19:14:08 <nagnatron> The symbolic math toolkit is good. My experience is limited hto.
19:14:17 <ivanm> and if you want an all-in-one environment, there's texmacs... >_>
19:14:30 <ivanm> nagnatron: it's decent for quick stuff; gets very limited very quickly in my experience
19:14:54 <manju> matlab has toolboxes which extend the capabilities
19:15:02 <ivanm> yup
19:15:10 <ivanm> for each one you have to sacrifice another newborn
19:15:12 <manju> but yeah, I've never used matlab for more than matrix stuff
19:15:19 <iwikiwi> hm, so haskell isn't advisable for symbolic manipulation?
19:15:21 <manju> ivanm: haha
19:15:32 <nagnatron> ivanm: Yeah, i read that it is. It was fine for what i used it for but it wasn't very advanced.
19:15:33 <manju> ivanm: or sell an arm and leg
19:15:50 <ivanm> iwikiwi: no library for it yet IIRC
19:15:51 <Saizan_> fasta: yeah, that's weird, my numerical analysis lessons were all about reusing memory by cramming matrices together and then each function call makes a full copy, wtf?
19:16:02 <ivanm> (there was one a while back, but I never saw an actual release...)
19:16:10 <fasta> Saizan_, yep.
19:16:18 <ivanm> manju: I prefer my description
19:16:19 <iwikiwi> ah, i see.
19:16:21 <fasta> Saizan_, and then they say Haskell is slow ;)
19:16:23 * ivanm needs both his arms at least
19:16:31 <Saizan_> iwikiwi: there are some libraries about automatic differentiation
19:16:37 <manju> ivanm: I have a newborn, so I prefer mine
19:16:40 <manju> :-)
19:16:53 <ivanm> heh
19:16:54 <manju> rather not so newborn
19:16:57 * iwikiwi checks for them
19:17:02 <ivanm> manju: I never said it had to be _your_ newborn!
19:17:10 <ivanm> maternity wards, orphanages, etc.
19:17:11 <ivanm> ;-)
19:17:14 <manju> ivanm: haha
19:17:24 <manju> you are evil >:-)
19:17:34 * ivanm would like to point out that he is just joking and does not condone any such illegal or morally dubious activity, blah, blah, blah
19:17:48 * manju knows already
19:18:25 <manju> iwikiwi: someone would've solved all your problems in perl and uploaded into cpan already, but you'll never be able to find it though
19:18:43 <manju> iwikiwi: and it will be write only code
19:19:24 <iwikiwi> manju, the whole of my problem hasnt been automated in the world yet. :p
19:25:52 <kfish> lambdabot, botsnack
19:26:13 * kfish was just talking to cleverbot, and it doesn't like lambdas
19:26:25 <kfish> @botsnack
19:26:25 <lunabot>  :o
19:26:25 <lambdabot> :)
19:26:46 <kfish> nice bots here :)
19:26:49 <MarcWeber> dcolish: Do you mind me readding the split-syb flag at bytestring? It's required by darcs (which depends on base3) and ghc-6.10.4 ?
19:27:33 <Peaker> Where's an instance Monad Either?
19:27:45 <MarcWeber> Peaker: MonadError
19:27:56 --- mode: irc.freenode.net set +o ChanServ
19:28:28 <MarcWeber> http://www.haskell.org/all_about_monads/html/errormonad.html @ Peaker
19:28:35 <Peaker> MarcWeber: thanks
19:31:35 * blobl wanders how this time of this universe goes so fast
19:37:14 <manju|afk> what is the up arrow operator stand for ?
19:37:19 <manju|afk> s/is/does
19:37:28 <ivanm> hmmm?
19:37:30 <manju|afk> [x ↑ 2 | x ← [1 . . 5]]
19:37:37 <manju|afk> [1, 4, 9, 16, 25]
19:37:54 <pastah_rhymez> manju|afk: square?
19:38:16 <Ferdirand> cute
19:38:19 <pastah_rhymez> > all (\x -> x↑2 == x*x) [1..200]
19:38:20 <lambdabot>   Not in scope: `↑'
19:38:21 <manju|afk> ah...yes, damnit, how did I miss it
19:38:26 <pastah_rhymez> > all (\x -> x ↑ 2 == x*x) [1..200]
19:38:27 <lambdabot>   Not in scope: `↑'
19:38:37 <pastah_rhymez> lambdabot: learn utf, dammit
19:38:49 <manju|afk> what it really works ?
19:39:12 <manju|afk> phew
19:39:15 <manju|afk> it doesn't
19:39:19 <pastah_rhymez> manju|afk: maybe it's just some pretty printed stuff you stumbled upon
19:39:22 <ivanm> oh, isn't that x ^ x ^ x or something?
19:39:27 <pastah_rhymez> > all (\x -> x ^ 2 == x*x) [1..200]
19:39:28 <lambdabot>   True
19:39:32 <manju|afk> pastah_rhymez: yes
19:39:49 <pastah_rhymez> manju|afk: what are you reading?
19:39:52 <manju|afk> yes to ivanm too
19:39:56 <manju|afk> pastah_rhymez: hutton
19:40:06 <dolio> There's a notation by Knuth that uses an up arrow.
19:40:06 <pastah_rhymez> manju|afk: awww :(
19:40:14 <manju|afk> pastah_rhymez: what ?
19:40:21 * pastah_rhymez doesn't like that book
19:40:24 <dolio> http://en.wikipedia.org/wiki/Knuth's_up-arrow_notation
19:40:38 <manju|afk> it came with good recommendations
19:40:46 <manju|afk> ok...I got to run, bus leaves in 2 min
19:40:51 <manju|afk> sorry...ttyl
19:40:59 <pastah_rhymez> bye
19:41:50 <pastah_rhymez> anyone here proficient in vty?
19:44:14 <dibblego> @type \p -> foldM (\a b -> liftM (\k -> if k then b:a else a) (p b)) [] -- is this equivalent to filterM?
19:44:15 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m Bool) -> [b] -> m [b]
19:47:58 <dibblego> @check \p x -> let filterM' p = foldM (\a b -> p b >>= \k -> return $ if k then b:a else a) [] in filterM' p x == (filterM p x :: [[Int]])
19:48:01 <lambdabot>   Overlapping instances for GHC.Show.Show
19:48:05 <lambdabot>                              (GHC.T...
19:51:27 <iwikiwi> uh my scrollback fails, who ever it was that told me about automatic differentiation thanks!
19:52:58 <b0fh_ua> Hi there! I need to calculate a sum of even elements and sum of odd elements from a list, how can I do that?
19:53:10 <benmachine> :t partition
19:53:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
19:53:22 <benmachine> partition is most of the answer
19:54:11 <Ferdirand> by 'even' and 'odd', you mean the element themselves ? or the indices of the elements ?
19:54:52 <b0fh_ua> Ferdirand: indices of elements
19:55:06 <mreh> can I interchange record syntax and normal constructor notation?
19:56:08 <b0fh_ua> In general, I am trying to solve the task: take 1-st element, subtract 2-nd element from it, then add 3-rd element, then subtract 4-th element and so on
19:56:52 <Ferdirand> @type sum .  zipWith ($) (cycle [id,negate])
19:56:53 <lambdabot> forall b. (Num b) => [b] -> b
19:56:54 <mreh> b0fh_ua, multiply each number by -1/+1 and then fold them up
19:57:06 <mreh> like Ferdirand said
19:57:16 <Ferdirand> i love zipWith ($)
19:58:10 <b0fh_ua> nice
19:59:37 <quicksilver> or "sum . zipWith (*) (cycle [1,-1])"
19:59:46 <quicksilver> if you prefer
20:03:26 <Peaker> mreh: apparently it can't
20:04:07 <mreh> it's a instance of the halting problem, we shall never know
20:04:24 <b0fh_ua> thanks
20:23:06 --- mode: irc.freenode.net set +v lunabot
20:25:35 <gio123> is there anybody from portugal?
20:26:21 <mreh> they speak portugese in portugal
20:26:39 <gio123> :)
20:26:43 <gio123> are u sure?
20:26:59 <mreh> well, i'm not an expert
20:28:04 <gio123> mreh: are you human or a computer?
20:28:23 <tombee> Anyone here attempted to implement Neural Networks or Bayesian Networks in haskell?
20:28:28 <mreh> gio123, what do you think?
20:28:33 <mreh> lol
20:28:38 <gio123> mreh: human
20:28:51 <mreh> gio123? so why did you need to ask?
20:29:08 <viator_sg> Is there any way to limit the memory usage of haskell program? (I dont want to restart my computer when my tiny program eats all the memory)
20:29:10 <gio123> did i pased turing test?
20:29:51 <mauke> viator_sg: what OS?
20:29:59 <viator_sg> linux
20:30:09 <mreh> tombee: i've done a perceptron
20:30:21 <mreh> aka single layer network
20:30:27 <mauke> viator_sg: setrlimit/ulimit looks appropriate
20:30:27 <tombee> What was it for? :)
20:30:45 <mreh> tombee: recognising handwritten digits
20:30:56 <mreh> U.S. zip codes specifically
20:31:08 <tombee> I see, I'm interested in writing a basic classifier
20:31:15 <tombee> perhaps in haskell
20:31:23 <viator_sg> mauke: thanks, I'm going to search some info :)
20:31:32 <mauke> crap
20:31:35 <mreh> tombee: how many classes? that's not really the hardest part though
20:31:42 <tombee> probably 2
20:31:56 <tombee> spam/ham :)
20:31:56 <mreh> tombee: do you want my source code? it's not great haskell, it was written when I was learning
20:31:59 <mauke> viator_sg: 'help ulimit' in your shell
20:32:08 <tombee> I wouldn't mind taking a look at it :)
20:32:36 <SamB_XP_> mreggen: you'll find most Haskell code is written while learning ;-P
20:32:49 <SamB_XP_> er.
20:32:52 <SamB_XP_> mreh
20:33:12 <SamB_XP_> I gotta get used to using at least 4 letter prefixes :-(
20:33:13 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13798#a13798
20:33:52 <mreh> tombee: there is a 2-class perceptron and it's also generalised to k classes
20:34:03 <blobl> data Movement = (Lft | Rht | Up | Down , (y,x))
20:34:03 <blobl> :t putMVar m "wake up!"
20:34:04 <lambdabot> Not in scope: `putMVar'
20:34:15 <mreh> it's bloody slow on an old machine, and uses about 256MB of memory
20:34:17 <blobl> pf sorry
20:34:18 <mreh> oh bloody hell
20:34:56 <SamB_XP_> well, THAT was a small netsplit
20:35:25 <mreh> tombee: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13798#a13798
20:35:48 <scree_> mreh: what segmentation algorithm?
20:36:19 <mreh> scree_ I didn't mention anything of the sort
20:37:02 <scree> mreh: sorry, you said you were doing US zip codes
20:37:15 <scree> mreh: so I assumed you were reading unsegmented characters
20:37:28 <mreh> scree: oh, no, they have been segmented
20:37:34 <mreh> it was a toy problem
20:37:45 <scree> ok
20:37:55 <scree> (where toy = major research in the 80's :))
20:38:03 <SamB_XP_> well, yeah
20:38:09 <SamB_XP_> you have to start *somewhere*!
20:38:26 <scree> mreh: what accuracy btw?
20:38:29 <mreh> but by the looks of the data set, it was pretty badly segmented, and it has smudges and dashes and all sorts of weired shit
20:38:38 <mreh> 7% error rate
20:38:59 <SamB_XP_> so, who came up with the name "perceptron"?
20:39:01 <mreh> it uses a polynomial kernel to map the data onto a feature space
20:39:20 <SamB_XP_> it sounds like something out of transformers or ...
20:39:22 <mreh> SamB_XP_ Futurama
20:39:27 <mreh> Dr Perceptron
20:39:51 <SamB_XP_> oh -- they let fictional characters do actual research now ?
20:40:05 <tombee> I want to write a spam filter in haskell
20:40:24 <SamB_XP_> tombee: why do you want to do that ?
20:40:32 <tombee> for a project
20:40:33 <SamB_XP_> it doesn't sound particularly interesting to me
20:40:33 <scree> SamB_XP_: I think he was a neurologist
20:40:37 <tombee> for uni
20:40:42 <scree> SamB_XP_: they're allowed strange names
20:40:43 <SamB_XP_> oh
20:41:08 <mreh> tombee: the hardest part is extracting the features of the training set
20:41:29 <mreh> tombee: have you dont machine learning? Because I don't recommend it if you are an undergraduate
20:41:34 <tombee> well the thing with spam is, there's large sets of data available
20:41:48 <tombee> nope I haven't, but I've got a while to work on this mreh
20:41:57 <tombee> a year or so
20:42:07 <tombee> before I even start
20:42:27 <SamB_XP_> I thought making spam filters was fairly well explained on the 'net
20:42:31 <SamB_XP_> isn't it ?
20:43:00 <scree> am ignorant, but if your aim is "read some papers, code some haskell" that should be very doable
20:43:01 <SamB_XP_> I mean, as long as you don't want to use it on *your* inbox
20:43:20 <tombee> I was looking more at a spam filter which works on externals of an email or something
20:43:23 <nlogax> what's a nice way to do "abcdefghijklmno" -> ["abcde", "fghij", "klmno"] ?
20:43:25 <SamB_XP_> hmm, I thought you could even do a lot of your research on web pages
20:43:28 <SamB_XP_> tombee: externals ?
20:43:37 <tombee> doing it without reading the 'body' of the mail
20:43:41 <SamB_XP_> nlogax: you mean, every five chars ?
20:43:43 <Ferdirand> isn't email fundamentally broken by design ?
20:43:59 <SamB_XP_> tombee: that sounds kinda dumb
20:44:00 <nlogax> SamB_XP_: yes, or every n chars :)
20:44:13 <shambler_> SamB_XP_, Frank Rosenblatt came up with it
20:44:13 <SamB_XP_> well, I mean, I guess you *could* do a lot with the from addresses ...
20:44:25 <nlogax> chopIntoPiecesOf 5 xs
20:44:40 <SamB_XP_> nlogax: well, obviously it would be a dumb library function if it only worked for 5 chars
20:44:47 <mreh> tombee: you wouldn't be able to extract enough features from just the email header
20:44:52 <nlogax> SamB_XP_: yes :)
20:44:54 <SamB_XP_> I was just verifying that that was what your example was intended to convey
20:45:11 <mauke> nlogax: Data.List.Split
20:45:24 <SamB_XP_> ah, good, someone with the answer
20:45:31 <SamB_XP_> I always forget it myself ;-)
20:45:56 <nlogax> mauke, SamB_XP_: thanks!
20:46:21 <mreh> tombee: it's not something you can just write yourself too easily, machine learning the best route here, massive body of techniques you can exploit
20:46:35 <mreh> http://videolectures.net/aop07_cesa_bianchi_onl/ <--- good place to start
20:46:37 <nlogax> didn't know there was a whole Split module :)
20:46:51 <SamB_XP_> nlogax: I'm guessing it probably isn't that big ?
20:47:01 <SamB_XP_> it's probably just because Data.List doesn't have the stuff in it
20:48:18 <HaskellLove> it says, having functions with side effects complicates the type system? Why is that so?
20:48:33 <blobl> is it possible to have a datatype that is either left/right/up/down and a tuple?
20:49:10 <blobl> Split module is supercool
20:49:37 <nlogax> SamB_XP_: no, not that big, i think. quite the noob so i'm not sure how big they usually are.
20:49:48 <Peaker_> HaskellLove: it complicates those functions' types - not the type system
20:50:01 <mreh> see you later, I'm going to university
20:50:09 <nlogax> but chunk is exactly what i was looking for
20:50:36 <SamB_XP_> @docs Data.List.Split
20:50:37 <lambdabot> Data.List.Split not available
20:50:39 <SamB_XP_> aww
20:50:56 <blobl> its in hackage
20:51:03 <HaskellLove> Peaker: Can u explain me more, i am studying monads that is why i ask that
20:51:14 <watermind> mauke: how do you know about that module?
20:51:26 <watermind> mauke: it's not in the libs documentation
20:51:37 <mauke> what do you mean by "the libs documentation"?
20:51:59 <watermind> mauke: ghc ->docs-> latest
20:52:11 <watermind> mauke: http://www.haskell.org/ghc/docs/latest/html/libraries/
20:52:14 <Peaker_> HaskellLove: The type system doesn't really have any side-effect-specific feature.. so supporting types that describe "this computation has side effects" may complicate that computation's type (which makes sense, as it complicates the computation itself!) but the type system would be just as complex without those functions
20:52:20 <mauke> watermind: http://hackage.haskell.org/packages/archive/pkg-list.html
20:52:39 <Peaker_> HaskellLove: I prefer "computations with side effects", because "functions" don't have side effects
20:53:45 <watermind> mauke: thanks, I didn't know that
20:54:29 <HaskellLove> Peaker: Can u give me how u see this monads thing I am new to it, please give me intro i am reading lecture notes on them now and stuff...
20:54:30 <osaunders> Where can I find little Haskell currying / composition / type deduction exercises?
20:54:45 <watermind> nlogax: if you want to program your own, I guess the first approach would be to fold a splitAt
20:55:16 <osaunders> @google haskell exercises
20:55:18 <lambdabot> http://www.haskell.org/haskellwiki/99_Haskell_exercises
20:55:18 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
20:55:29 <Peaker_> HaskellLove: you don't need to understand monads to understand how side effects are handled
20:55:59 <scree> > let f n = takeWhile (not . null) . unfoldr (return . splitAt n) in f 5 [1..22]
20:56:00 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22]]
20:56:24 <HaskellLove> Peaker can I come pm so we can talk?
20:56:31 <Peaker_> HaskellLove: why not here?
20:56:52 <blobl> what about exploding a string into list elems using another string as delimeter?
20:57:08 <Peaker_> HaskellLove: Basically, functions (which are pure) let you do pure computations from any input to any output.   But this is not enough for an imperative (side effecting) program. You still want the pure computations, but in between pure computations, you might want to have "effects" occur, right?
20:57:09 <HaskellLove> ok... monads confuse me and u see i dont need to understand them ... give me more info here please talk to me
20:57:26 <HaskellLove> ok i understand that, go on
20:57:48 <nlogax> watermind: thanks for the tip, was just looking at the source of chunk.. or splitEvery, chunk was just a synonym for that :)
20:57:49 * Chinainvent
20:57:54 <Peaker_> HaskellLove: so, Haskell defines a type constructor IO.  (IO a) is a (potentially) side-effecting computation that yields a result "a"
20:58:08 <Peaker_> HaskellLove: values of type (IO a)  *describe*  these side-effecting computations
20:58:23 <HaskellLove> ok...
20:58:31 <scree> we should really have more violent disagreements about the best way to teach monads
20:58:36 <Peaker_> HaskellLove: so now, we want to be able to chain together pure functions and side effecting computations
20:58:54 <SamB_XP_> scree: I think we should try to avoid the subject and just tell people to do something else
20:59:21 <Peaker_> HaskellLove: Lets say we have a side-effecting computation (IO a)  and a pure function f -- and we want "f" to be able to determine the next side-effecting computation to chain
20:59:49 <Peaker_> HaskellLove: so that we build a "chain" which has our (IO a), then f, then some (IO b) that "f" decided to chain after IO a
21:00:28 <HaskellLove> ok...
21:00:53 <Peaker_> HaskellLove: so we have a function called (>>=) that lets us chain our (IO a) with the function f
21:01:04 <HaskellLove> yes bind...
21:01:20 <Peaker_> HaskellLove: (>>=) takes our (IO a)  and our "f" function (which has type  (a -> IO b) because given the result of IO a, it can decide the next side effecting computation to run, which is IO b)
21:01:35 <SamB_XP_> nlogax: wow, that module is bigger than I expected!
21:01:47 <Peaker_> HaskellLove: so (>>=) builds a new computation that sandwiches our (IO a, f, IO b) computations into one big IO b
21:02:22 <HaskellLove> ok...
21:02:33 <SamB_XP_> Peaker_: you shouldn't say "side-effecting", IMO -- just "effectful" or "effecting"
21:03:09 <HaskellLove> things are getting clear please go on... by the way are monads characteristic for Haskell only?
21:03:20 <Peaker_> HaskellLove: (>>=) :: IO a -> (a -> IO b) -> IO b       the second arg's type (a -> IO b) describes both a pure computation to evaluate between IO a and IO b and the effecting computation IO b
21:03:49 <SamB_XP_> the whole point of using the IO monad (programs of type [Response] -> [Request]) is to take the "side-" out of "side-effect"
21:04:21 <SamB_XP_> HaskellLove: they are pretty much Haskell-exclusive
21:04:39 <HaskellLove> so Scala and ML dont have monads?
21:04:55 <Peaker_> HaskellLove: I look at the type (>>=) as:    A. "IO a" -> B. "(a -> ..)" C. "IO b"  and D. IO b     The result D is a "chain" of A,B,C -- A and C are effecting computations, and B is a pure computation - so (>>=) lets us "interlace" effects and pure computations
21:05:10 <SamB_XP_> I can't think of any other, non-toy, language that actually has an IO monad, at least ...
21:05:44 <QtPlaty[HireMe]> Odly enought there is a IO-Monad libarey for perl
21:06:00 <SamB_XP_> QtPlaty[HireMe]: is it any good?
21:06:12 <HaskellLove> Ok I will remember now >>= as a sandwiching operator for functions with and without side effects
21:06:26 <QtPlaty[HireMe]> SamB_XP_: Never used it
21:06:34 <SamB_XP_> certainly it doesn't guarentee that none of that sort of effect happens in non-IO-monadic code ...
21:07:27 <Peaker_> HaskellLove: Do you understand lexical scopes?
21:07:36 <osaunders> @pl \a b c d e -> e d c b a
21:07:36 <lambdabot> flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))
21:08:07 <Veinor> osaunders: more flips than the philippines :D
21:08:29 <osaunders> @pl \a b c d e f g -> g f e d c b a
21:08:30 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
21:08:34 <osaunders> lolz
21:08:43 <Veinor> @pl \a b c -> c b a
21:08:44 <lambdabot> flip (flip . flip id)
21:08:57 <mauke> @. unpl pl \a b c d e -> e d c b a
21:08:57 <lambdabot> (\ b c f i l -> l i f c b)
21:09:22 <osaunders> Does anyone actually understand what (flip (flip . flip id)) means?
21:09:26 <Peaker_> HaskellLove: Do you understand: \x -> \y -> x + y ?
21:09:59 <SamB_XP_> osaunders: I can't really follow flip (flip . flip id), no
21:10:08 <SamB_XP_> @unpl flip id
21:10:09 <lambdabot> (\ b c -> c b)
21:10:22 <SamB_XP_> ah, right, like flip ($)
21:10:33 <osaunders> OK because I've been trying for the last day to understand ((+) .) . (+)
21:10:39 <SamB_XP_> @unpl (flip . flip id)
21:10:40 <lambdabot> (\ j b c -> c j b)
21:10:55 <osaunders> @unpl ((+) .) . (+)
21:10:56 <lambdabot> (\ d g -> (+) (d + g))
21:11:01 <HaskellLove> Peaker I understand lexical scopes yes
21:11:19 <SamB_XP_> @type flip id
21:11:21 <lambdabot> forall a b. a -> (a -> b) -> b
21:11:30 <SamB_XP_> @type (flip . flip id)
21:11:32 <lambdabot> forall a b a1. a1 -> a -> (a1 -> a -> b) -> b
21:11:46 <HaskellLove> But i do not understand that : \x -> \y -> x + y ?
21:11:47 <SamB_XP_> yucky GHC-named types :-(
21:11:53 <Peaker_> HaskellLove: Lexical scopes are used with (>>=) and another function called "return" -- so that the pure computations between the effecting ones can "see" the results from previous effecting computations
21:11:57 * SamB_XP_ wishes there was an option to get it to do hugs-style naming ...
21:12:04 <Peaker_> HaskellLove: what don't you understand about \x -> \y -> x + y?
21:12:28 <Saizan_> SamB_XP_: e.g.?
21:12:39 <Peaker_> @type flip . flip ($)
21:12:41 <lambdabot> forall a b a1. a1 -> a -> (a1 -> a -> b) -> b
21:12:41 <SamB_XP_> Saizan: just use the letters of the alphabet
21:12:45 <Peaker_> @type flip (flip . flip ($))
21:12:46 <lambdabot> forall a b a1. a -> a1 -> (a1 -> a -> b) -> b
21:13:00 <SamB_XP_> instead of trying to use type variable names based on the ones given in the original sigs
21:13:22 * osaunders agrees with SamB_XP_ 
21:13:22 <Peaker_> @type [flip . flip ($), id]
21:13:23 <lambdabot>     Occurs check: cannot construct the infinite type:
21:13:23 <lambdabot>       a = a1 -> (a -> a1 -> b) -> b
21:13:23 <lambdabot>     Probable cause: `id' is applied to too many arguments
21:13:29 <SamB_XP_> I mean, it makes sense sometimes
21:13:40 <HaskellLove> Peaker \y -> x + y - this is anonymous function lambda used to BIND stuff, but the \x before confuses me
21:13:53 <SamB_XP_> but not so much when the type sigs just used arbitrary letters from the beginning of the alphabet
21:13:57 <Peaker_> HaskellLove: \x -> \y -> x + y  == \x -> (\y -> x + y)
21:14:19 <HaskellLove> Peaker ok got it
21:14:25 <Peaker_> HaskellLove: so the "x" in the inner function comes from the outer "lexical scope"
21:14:29 <SamB_XP_> so it'd be nice if there was a way to for lambdabot to request GHC to use the hugs style of naming the type variables
21:14:36 <Peaker_> HaskellLove: say you want to use (>>=) and "getLine" twice, and build a tuple of the two lines
21:14:57 <Peaker_> HaskellLove: what you really want is:  effecting getline computation, effecting getline computation, pure computation that builds a tuple of their 2 results, right?
21:15:31 <SamB_XP_> I mean, it would be even nicer if GHC was able to figure out which variable names in the type sigs are meaningful, and keep just those ;-P
21:15:39 <Peaker_> HaskellLove: (>>=) just lets the pure function see the single result of the left-side effect, right? But we want it to see the results of 2 previous effects
21:15:39 <SamB_XP_> but that's probably not going to happen
21:15:56 <SamB_XP_> for example, sometimes a is meaningful (think (***)) but sometimes it isn't
21:17:32 <Peaker_> HaskellLove: since (IO a) is a "sandwich" of (IO a, pure func, IO b)  you can parenthesize the subsets of your IO/pure/IO/pure/... chain in various different ways, right?  (>>=) is, btw, associative
21:17:55 <HaskellLove> Peaker ok...
21:17:58 <Peaker_> (though its associativity is not as simple/clear as with an (a->a->a) operator)
21:18:23 <Peaker_> HaskellLove: so what you can do is:   getLine >>= (\line1 -> .... rest of computation goes here and line1 is in the lexical scope of the entirety of it ...)
21:18:51 <Peaker_> HaskellLove: Using lexical scoping, the pure computation can actually see not only the "a" it got from IO a, but all the previous IO results its in the lexical scope of
21:19:25 <HaskellLove> ok...
21:19:27 <Peaker_> because IO a  was bound to  (a -> IO b)  and so all the functions in the (IO b) itself are allowed to be in the lexical scope of the (a -> IO b) function and thus all of them "see" the "a"
21:19:57 <Peaker_> HaskellLove: so you can do:   getLine >>= (\line1 -> getLine >>= (\line2 -> return (line1, line2) ) )
21:20:07 <Peaker_> HaskellLove: And this is where "return" comes into play
21:20:12 <osaunders> Do you think I need to understand how to write point-free things?
21:20:23 <Peaker_> osaunders: I think it helps see things more clearly
21:20:49 <osaunders> I understand you can just leave args off the end if they are in the function declaration also.
21:20:58 <osaunders> *off both sides
21:21:24 <osaunders> @pl foo a b = a + b
21:21:24 <lambdabot> foo = (+)
21:21:30 <Peaker_> HaskellLove: did you follow the explanation so far?
21:22:00 <HaskellLove> Peaker will u be here in hour? I took a lot of info I have audio lecture on monads i want to hear and come back ok... by the way yes so far i understood all... ok?
21:22:16 <Peaker_> HaskellLove: not sure if I will, might be
21:22:33 <HaskellLove> ok then I dont want to lose you, go on now please :)
21:23:13 <osaunders> Ahh love.
21:23:16 <Peaker_> HaskellLove: "do" notation does the right-associative binds for us
21:23:23 <Peaker_> HaskellLove: instead of the above:
21:23:28 <Peaker_> getLine >>= (\line1 -> getLine >>= (\line2 -> return (line1, line2) ) )
21:23:31 <Peaker_> you can do:
21:23:46 <Peaker_> do { line1 <- getLine ; line2 <- getLine ; return (line1, line2) }
21:24:53 <Peaker_> HaskellLove: and it desugars to the above.  The "trick" here that allows each statement in the "do" block to see the results of previous binds, is that do { x<-a ; y<-b ; z<-c ; ... } desugars to binds that are nested within each other:  a >>= (\x -> ....rest of do is here, so it all sees x....)
21:25:35 <Peaker_> HaskellLove: Now (>>=) and return satisfy a few laws...
21:26:16 <HaskellLove> wait, how can this (\line2 -> return (line1, line2)) return itself??? I mean line2 returns line2? even thought it does not know what it is ?
21:26:25 <Peaker_> HaskellLove: (action >>= \x -> return x) (which is really just:  action >>= return    -- only feeds the result of an (IO a) to return, which is (a -> IO a)  -- and this is exactly the same as just action.  so action = action >>= return
21:26:45 <Peaker_> HaskellLove: what do you mean by "itself" here?
21:27:08 <Peaker_> HaskellLove: line1 is in the lexical scope because we're inside (\line1 -> ............) and line2 is the argument to the current lambda
21:27:20 <HaskellLove> well \line2 returns line1 and line2
21:27:20 <Peaker_> HaskellLove: the "return" here is not a keyword -- its a normal function called "return"
21:27:40 <Peaker_> HaskellLove: Lets say you have: \line1 -> \line2 -> (line1, line2)
21:28:01 <Peaker_> > let f = \line1 -> \line2 -> (line1, line2) in f "line1" "line2"
21:28:02 <lambdabot>   ("line1","line2")
21:28:08 <Peaker_> HaskellLove: do you understand this code example
21:28:16 <HaskellLove> Peaker you said: The "trick" here that allows each statement in the "do" block to see the results of previous binds -------------------- Can i have a model in my mind for this like a stack?
21:28:27 <Peaker> HaskellLove: not a stack - simply nesting
21:28:55 <Peaker> do { a ; b ; c ; ... }  is more like:  a >>= (... (b >>= (... (c >>= ... ))))
21:29:15 <Peaker> each line in the do opens a new lexical scope -- that the **entire rest of the do block** is put within
21:29:21 <int-e> @undo do { a; x <- b; c x }
21:29:22 <lambdabot> a >> b >>= \ x -> c x
21:29:27 <HaskellLove> Peaker, but nesting is stack concept ? ???
21:29:38 <int-e> ah, no parentheses.
21:29:38 <Peaker> HaskellLove: No, nesting is not related to stack
21:29:42 <HaskellLove> like a process tree
21:30:07 <Peaker> HaskellLove: Nesting is just (parenthesis (within (parens)))
21:30:16 <HaskellLove> the first one contains all, the second one all after it and so on, like russian dolls
21:30:18 <Peaker> HaskellLove: sub-computations within other computations
21:30:23 <Peaker> HaskellLove: yeah
21:30:28 <osaunders> I'm reading Berengal's post in http://echochamber.me/viewtopic.php?f=11&t=46392&view=next why do people like these things?! They scare the hell outta me.
21:30:44 <int-e> a stack is useful (but not required) when traversing nested structures. that's a rather weak connection.
21:30:50 <Peaker> HaskellLove: that's why in a do block:  do { x<-getLine ; ............. everyone can see "x" here ........... }
21:31:30 <Peaker> HaskellLove: because what it desugars to is:  getLine >>= (\x -> ...... of course everyone can see "x" here, we're in a lexical scope that is it!)
21:32:32 <HaskellLove> ok understood...
21:32:33 <Peaker> osaunders: There are many ways to point-free expressions.  With S/K combinators, its pretty point-less.  With good combinators -- its often more readable than the point-ful version
21:33:27 <Peaker> HaskellLove: I feel I didn't explain very well what "return" was or why it was necessary. do you feel you understood that part?
21:34:17 <HaskellLove> yes
21:35:44 <Peaker> HaskellLove: so what's the type of return, and why is it useful?
21:36:05 <Peaker> osaunders: SEC's are a wonderful example of points-free combinators
21:36:09 <Peaker> @where SEC
21:36:10 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
21:36:13 <Peaker> osaunders: I recommend reading that
21:38:57 <HaskellLove> well without return you have nothing
21:39:18 <HaskellLove> u take the result with getLn but u need to return it also
21:39:24 <HaskellLove> print it on screen
21:40:17 <Axman6> that doesn't quite sound right to me
21:40:24 <Peaker> HaskellLove: its not about printing to screen -- we didn't print anything
21:40:29 <Axman6> return is nothing like return in procedural languages
21:40:53 <HaskellLove> return a type then?
21:40:57 <Axman6> no
21:41:03 <Axman6> you can't return types
21:41:07 <Axman6> :t return
21:41:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:41:12 <Peaker> HaskellLove: Without "return" I still have something.. For example, I don't need "return" to write:  do { x <- getLine ; y <- getLine ; print (x, y) }
21:41:13 <HaskellLove> a new function to be executed? so chaining can go on?
21:41:15 <Axman6> > return 1 :: [Int]
21:41:16 <lambdabot>   [1]
21:41:22 <Axman6> > return 1 :: Maybe Int
21:41:23 <lambdabot>   Just 1
21:41:31 <Axman6> > return 1 :: Either String Int
21:41:32 <lambdabot>   Right 1
21:42:06 <Peaker> HaskellLove: I'll explain again
21:42:08 <HaskellLove> Axman6 wait Peaker is explaining me u r confusing me like this
21:42:13 <Peaker> Axman6: I'm trying to avoid Monads and just explain IO for now
21:42:21 <Axman6> ah
21:42:29 <osaunders_> Uh if anyone replied I didn't get their replies
21:42:35 <osaunders_> My last thing was:
21:42:38 <Axman6> have you directed him to my IO tutorial? it avoids monads as much as possible
21:42:38 <Peaker> osaunders: SEC's are a wonderful example of points-free combinators
21:42:38 <osaunders_> OK test me on a really basic one. Ask me to give the types and stuff.
21:42:43 <Peaker> @where SEC
21:42:44 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
21:42:45 <ketil> Regarding haskeline and readline: is it my terminal, or does haskeline deal less gracefully with lines wider than the terminal?
21:42:49 <Peaker> osaunders: I recommend reading that
21:43:06 <osaunders_> Peaker: OK
21:43:10 <Peaker> HaskellLove: so you have getLine :: IO String -- (an effecting computation that yields a String)
21:43:12 <osaunders_> Axman6: Hello.
21:43:21 <Axman6> HaskellLove: if you're trying to understand IO in haskell, this might help you get going: http://random.axman6.com/blog/?page_id=70
21:43:26 <Axman6> o/ osaunders_
21:43:39 <Axman6> brb
21:43:42 <HaskellLove> thank you Axman6
21:43:46 <Peaker> HaskellLove: what if you want to build your own (IO String) values that is a "chain" this effecting computation (getLine) with a pure computation that adds "HAHA" to the beginning of the String getLine yields?
21:44:31 <HaskellLove> i will sandwich them with >>=
21:44:43 <HaskellLove> having lexixal scope in mind
21:44:51 <Peaker> HaskellLove: >>= sandwiches (IO a), pure computation, (IO b) value -- but you just have (IO String), String -> String, right?
21:45:26 <HaskellLove> ok it is confusing now i think we should stop here
21:45:35 <Peaker> HaskellLove: you don't have two effecting computations with a pure function in between. You just want to apply a pure function (String -> String) to the result of an effecting computation (IO String)
21:45:56 <osaunders_> Just so I know what is the definition of a combinator?
21:46:11 <pastah_rhymez> HaskellLove: people sometime assume that you have a masters in math when you're in here, so some things might go over your head
21:46:25 <pastah_rhymez> HaskellLove: just think of IO as glorified C
21:46:31 <BONUS_> osaunders_: usually i think it's defined as a function that uses only the stuff it takes as parameters and function application
21:46:53 <HaskellLove> let me read Axman tutorial and will be back Peaker, yes i have noticed the master think u say, they explained confusingly yesterday
21:48:20 <osaunders_> BONUS: How is that different from any function?
21:48:36 <BONUS> osaunders_: well consider the function
21:48:41 <BONUS> (\a b -> a + b)
21:48:52 <BONUS> the + here comes from outside
21:49:04 <osaunders_> Ah.
21:49:07 <BONUS> it's not a parameter to the function, nor is it function appplication
21:49:07 <osaunders_> OK.
21:49:18 <BONUS> but if we did (\a b f -> a `f` b), then it's a combinator
21:49:26 <osaunders_> Nice.
21:49:31 <quicksilver> "no free names"
21:49:49 <quicksilver> suppose you have no mechanism for free names - suppose your language has no symbol table at all.
21:49:59 <quicksilver> then you have a combinator system.
21:50:01 <Peaker> Only now when explaining this stuff I realized that "do" must desugar to right-associative binds.. or am I wrong?
21:50:14 <quicksilver> Peaker: you are right
21:50:15 <opqdonut> indeed
21:50:23 <opqdonut> to make "scoping" work
21:50:26 * osaunders adds definition of combinator to his Anki deck.
21:50:28 <Peaker> in what cases are left-associative binds more efficient?
21:50:44 <quicksilver> that would depend on the monad definition
21:50:49 <Peaker> yeah, in what monads
21:51:21 <opqdonut> i'd guess right-associative ones are nicer for stuff like Maybe
21:51:24 <Peaker> In exception monads, right-associative is cheaper..
21:51:29 <Peaker> Yeah
21:51:30 <opqdonut> heh, echo :)
21:52:00 <Axman6> osaunders: did you look any deeper into those lectures?
21:53:34 <osaunders> No.
21:53:52 <int-e> > runState (undefined >> put 2 >> return 1) undefined
21:53:53 <lambdabot>   (1,2)
21:54:03 <osaunders> Been reading LYAH and getting confused by ((+).).(+)
21:54:04 <Peaker> I think Saizan_ once said that a Set monad would prefer left-associative to prune duplicates early -- but then after thinking about it - it didn't work out for me (Saizan was always right so far, though :)
21:54:12 <quicksilver> Peaker: right association gives you the option of executing some actions ("on the left") before evaluating everything ("on the right")
21:54:25 <quicksilver> Peaker: that fact is pretty much essential for efficient execution of IO
21:54:28 <int-e> Peaker: how about that?
21:54:29 <BONUS> osaunders: who added ((+).).(+) to LYAH? O_O
21:54:46 <HaskellLove> Peaker I read the tutorial, the in and out of the box explanation is wonderfull, thank you Axman6
21:54:47 <opqdonut> hehe
21:54:52 <BONUS> > ((+).).(+) 3 4 5
21:54:53 <lambdabot>   No instance for (GHC.Show.Show (f1 (f (a -> a))))
21:54:54 <lambdabot>    arising from a use of ...
21:54:56 <Peaker> (.).(.) (+) (+) -- is nicer
21:54:58 <osaunders> BONUS: Oh, it's not in LYAH. I asked what the point-free implementation of addThree was.
21:55:09 <Peaker> > ((.).(.)) (+) (+) 1 2 3
21:55:10 <lambdabot>   6
21:55:20 <osaunders> And about 5 people came back with that.
21:55:31 <mauke> how many of them were lambdabot?
21:55:34 <Axman6> HaskellLove: a lot of people don't like that explanation, because it's not really 'correct'. but i think it is very useful for getting started with IO, which you need to be able to understand it
21:55:35 <BONUS> read conal's semantic editor combinators blog post
21:55:39 <BONUS> where he presents (.) as result
21:55:52 <BONUS> stuff like ((.).(.)) (+) (+) made sense after that to me
21:55:56 <osaunders> Yeah Peaker already recommended that.
21:56:21 <osaunders> BONUS: I like LYAH btw. Well done for all the work that you've put in. It shows.
21:56:25 <wm_eddie_> (.)(.) just looks dirty to me
21:56:32 <osaunders> lol
21:56:56 <shambler> :-)
21:57:02 <mauke> @unpl (.)(.)
21:57:02 <lambdabot> (\ b c e f -> b c (e f))
21:57:10 <osaunders> OK so this is the definition of combinator I'm going with: A combinator is a function with a defintion constructed only out of its arguments without anything else.
21:57:16 <osaunders> Does that sound clear/correct?
21:57:36 <BONUS> osaunders: i think it's more precise to say that it's a function with no free variables
21:57:59 <osaunders> Ack but then I have to define variable.
21:58:05 <HaskellLove> Axman this is programming not math so it is ok :D I think people exagerate with complex explanations, it is like me knowing how electrons and stuff work in the computer, why should i know that, my area is programming so save me from physics and complex monads explanations that i wont ever need right?
21:58:24 <BONUS> yeah but on the other hand saying only out of its arguments without anything else is kind of vague
21:58:33 <Axman6> HaskellLove: you will need monads, but not right now ;)
21:58:48 <Axman6> HaskellLove: and haskell is very mathy, so, get to love it :P
21:58:56 <osaunders> BONUS: OK, A combinator is a function with a definition made only from its arguments, with no free variables.
21:58:57 <BONUS> you can have parentheses inside a combinator but you don't have to take them as an argument
21:59:04 <pastah_rhymez> HaskellLove: what other languages do you know?
21:59:13 <osaunders> Oh yeah that's a good point.
21:59:28 <BONUS> oh and also
21:59:29 <BONUS> other combinators
21:59:37 <osaunders> Oh right yeah.
21:59:40 <osaunders> Damn.
21:59:42 <osaunders> Err.
21:59:49 <aavogt> BONUS: and itself...?
21:59:55 <Peaker> HaskellLove: Programming is math :)
22:00:16 <BONUS> that is kind of implied because if you have a function and combinators inside, you can rewrite those combinators as just function application
22:00:20 <BONUS> but it's good to know
22:00:25 <HaskellLove> c,c++,java,python tried scheme and prolog, i play with scala now, have played with game engines, the usual web shit like html,xml, owl, rdf and other languages i seem not to remember now
22:00:29 <BONUS> itself? hmm
22:00:40 <aavogt> @src fix
22:00:40 <lambdabot> fix f = let x = f x in x
22:00:43 <pastah_rhymez> HaskellLove: then this might be for you: http://www.haskell.org/~pairwise/intro/intro.html
22:00:47 <aavogt> is fix a combinator by your defn?
22:01:19 <BONUS> that's a good question
22:01:34 <HaskellLove> pastah_rhymez thank you so much will read this now
22:01:57 * osaunders 's combinator definition is in tatters.
22:02:40 <aavogt> I guess even if you specified "may only call other combinators", that doesn't exclude writing something like fix, since you could have one fix call the other fix' and the converse
22:02:43 <pastah_rhymez> HaskellLove: i just thought it might be fitting when you said "this is programming not math so it is ok"
22:04:10 <aavogt> but perhaps you could specify that combinators may not introduce any recursion
22:04:29 <Veinor> Q. What do you call a pebble with the letter P written on it?
22:04:33 <BONUS> given that the Y combinator is basically fix and it is, as the name implies, a combinator, fix is a combinator
22:04:35 <Veinor> A. A propositional calculus.
22:04:37 <quicksilver> Veinor: Henry
22:04:39 <BONUS> Y g = g (Y g)
22:05:14 <BONUS> lol
22:05:21 <BONUS> Y = (L L L L L L L L L L L L L L L L L L L L L L L L L L)
22:05:35 <opqdonut> :)
22:05:36 <BONUS> where L = \abcdefghijklmnopqstuvwxyzr -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
22:05:50 <opqdonut> that's a classic yeah
22:06:10 <pastah_rhymez> BONUS: CPS?
22:06:41 <pastah_rhymez> (just noted that r is the last argument and it is what is being applied to the result)
22:08:13 <Axman6> @pl \abcdefghijklmnopqstuvwxyzr -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
22:08:13 <lambdabot> const (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
22:08:29 <Axman6> @pl \ a b c d e f g h i j k l m n o p q s t u v w x y z r -> (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
22:08:32 <lambdabot> (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
22:08:32 <lambdabot> ((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .
22:08:32 <lambdabot> ) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((ap id .) .) .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .)
22:08:32 <lambdabot> . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((ap .) .) .) .)
22:08:34 <lambdabot>  .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .
22:08:36 <Axman6> >_>
22:08:37 <lambdabot> [24 @more lines]
22:08:39 <pastah_rhymez> Axman6: you naughty person
22:08:40 <lambdabot> optimization suspended, use @pl-resume to continue.
22:08:44 <Axman6> hehe
22:09:12 <Veinor> oh god
22:09:21 <pastah_rhymez> Axman6: shame on you... not even ONE titty operator
22:09:40 <pastah_rhymez> @type ((.) . (.))
22:09:41 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:09:49 <Axman6> pastah_rhymez: on my planet, this is the titty operator: (((((((const .) .) .) .) .) .) .)
22:10:15 <pastah_rhymez> EXCELLENT for those function compositions whose rightmost action is zipWith f
22:10:40 <int-e> @type let f . g = \x -> f (g x) in (.) . (.)
22:10:41 <lambdabot> forall t t1 t2 t3. (t1 -> t2) -> (t -> t3 -> t1) -> t -> t3 -> t2
22:10:44 <pastah_rhymez> map lol . filter lulz `tits` zipWith lawlMyBallz
22:11:10 <pastah_rhymez> ^^ that's how i roll :)
22:11:23 <pastah_rhymez> *lawlzMyBallz*
22:11:24 <Axman6> int-e: don't you find the (.) = fmap frustrating?
22:11:32 <HaskellLove> can u guys recommend me books that talk about why math is important to a computer scientists?  So far i am more like, leave the mathematicians do theirs and we programmers ours kinda thing...
22:11:54 <Axman6> HaskellLove: all programming is maths
22:12:02 <osaunders> Logic is maths.
22:12:05 <gwern> @quote orbitz
22:12:06 <lambdabot> copumpkin says: orbitz makes [##C++] especially brutal to make people appreciate #haskell more
22:12:08 <Axman6> and to write efficient programs, you need to know the maths
22:12:11 <gwern> @quote etched
22:12:12 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
22:12:18 <gwern> wow, that's ironic
22:12:29 <camio> HaskellLove: There's a book called "Denotational Semantics" that's pretty revealing.
22:12:34 <gwern> the quote I was looking for was 'command: lambdabot will say 'it is forever etched into my memory' and then forget the quote by tomorrow.'
22:12:36 <HaskellLove> yes ofcourse asymptotic analysis but that is easy math
22:12:49 <gwern> @remember command lambdabot will say 'it is forever etched into my memory' and then forget the quote by tomorrow.
22:12:49 <lambdabot> Done.
22:12:53 <Axman6> HaskellLove: no, not just that
22:12:55 <pastah_rhymez> HaskellLove: think about how a computer works; all it really does are ifs and arithmetic... how much abstraction you do you're still always doing stuff with batches of numbers
22:12:59 <gwern> @quote evening
22:13:00 <lambdabot> mtnviewmark says: [on the State monad] "If I had a sta-ate, I'd compute it in the morning.... I'd compute it in the evening.... All over this la-and!"
22:13:01 <Axman6> there's a hell of a lot more to it than that
22:13:14 <pastah_rhymez> *it's still always*
22:13:15 <gwern> Axman6: numbers? when I was young, we had just bits!
22:13:21 <HaskellLove> pastah_rhymez well ok boolean algebra that is easy too
22:13:30 <gwern> @quote dependent.type
22:13:31 <lambdabot> mmorrow says: in langs with dependent types, you can just map numbers directly to types instead of having to ride a unicycle along a tightrope while battling an unruly gang of monkey with knives
22:13:47 <gwern> @quote poor.*dependent.type
22:13:47 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
22:13:48 <osaunders> HaskellLove: So what that it's easy?
22:13:56 <gwern> @quote fundeps
22:13:56 <lambdabot> joelr says: Fundeps, existential types, & HList take a while to grasp
22:14:04 <gwern> @quote fundeps.without
22:14:05 <lambdabot> Veinor says: just remember: you can't spell fundeps without fun.
22:14:15 <gwern> @quote sticking.things
22:14:15 <lambdabot> Botje says: i think it's too early to be sticking things into other things ..
22:14:23 <gwern> @quote compound.X
22:14:23 <lambdabot> Berengal says: Haskell is made of sugar and spice and everything nice, plus the mysterious compound X
22:14:30 <gwern> @quote Sarah.Palin
22:14:31 <lambdabot> sproingie says: * enables IncoherentInstances and ends up with Sarah Palin in his living room
22:14:38 <gwern> well, only 1 gone
22:14:39 <Axman6> ha
22:14:40 <gwern> not too bad
22:14:42 <gwern> @flush
22:14:46 <pastah_rhymez> HaskellLove: are you working on some haskell project or homework or are you just playing around?
22:14:48 <HaskellLove> ousanders: there is a limit to how deep a computer scientist should go in math and i am trying to figure that out
22:14:52 <Axman6> @quote Axman6
22:14:52 <lambdabot> Axman6 says: getSex :: Person -> Sex
22:14:57 <Axman6> @quote Axman6
22:14:58 <lambdabot> Axman6 says: what's @flush do? saves stuff to dick?
22:15:09 <HaskellLove> learning for myself, i am compiler and OSs engineer wannabe cs student
22:15:14 * Axman6 makes that typo far too often
22:15:37 <osaunders> HaskellLove: Cool.
22:15:38 <pastah_rhymez> so you've written compilers?
22:15:47 <Axman6> HaskellLove: then you're going to have to learn a lot of theory. your compilers will be shit, and very difficult to write if you don't know the theory behind them
22:15:55 <HaskellLove> so far just a stupid calculator language in ANTLR
22:16:08 <HaskellLove> yeah automata theory
22:16:20 <osaunders> HaskellLove: Instead of trying to make that call (how difficult math should be before it's has no use to a computer scientist) just learn the math that seems most useful at the time.
22:16:20 <HaskellLove> but it has limits how deep you need to go into it
22:16:52 <HaskellLove> i do learn as i go, but there is always this doubt in me seeded by other people that there is more to math... anyways...
22:17:13 <Axman6> well, there is
22:17:20 <Axman6> computer science is all maths
22:17:29 <gwern> @quote ax.*crazy
22:17:30 <lambdabot> No quotes match. My mind is going. I can feel it.
22:17:31 <HaskellLove> i want to make my own language, 2010 i will only research and learn lot of languages and 2011 start with mine
22:17:32 <Axman6> it may be a different kind of maths, but it's still maths
22:17:32 <gwern> darn
22:18:04 <Axman6> gwern: what was that one?
22:18:11 <pastah_rhymez> HaskellLove: so what are you working on now? do you have some exerciser or something?
22:18:13 <gwern> Axman6: jes hopin
22:19:03 <HaskellLove> pastah_rhymez i am learning haskell and scala now, and after that other languages, i am going alphabeticaly from the wiki
22:19:14 <Axman6> :\
22:19:16 <HaskellLove> started A+ but paused it
22:19:29 <Axman6> HaskellLove: sounds to me like you're not really learning anything
22:19:55 <Axman6> if you're spending so little time with each language, you're not actually learning it.
22:19:59 <BONUS> well most languages are crap
22:20:09 <Axman6> You haven't learnt a language until you dread in it, regularly.
22:20:09 <BONUS> yeah i'd just stick with fewer languages but learn them more in depth
22:20:17 <Axman6> BONUS: agreed
22:20:18 <pastah_rhymez> HaskellLove: i usually link people who want to learn the language to this: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/lab3.html
22:20:37 <pastah_rhymez> it's a great exercise and you will get a good taste of how working with the language is
22:21:04 <HaskellLove> i devote a language time as needed, but yes lot of languages are ltile and crap so you can pass them by reading a 200 book in a day
22:21:18 <Axman6> :\
22:21:21 <pastah_rhymez> :/
22:21:29 <pastah_rhymez> :|
22:21:29 <HaskellLove> 200 pages
22:21:37 * Axman6 does not have high hopes for HaskellLove becomming a good CS student
22:21:45 * pastah_rhymez neither
22:21:55 <HaskellLove> 200 pages not 200 books :D
22:22:05 <BONUS> aw come on, his heart is in the right place :)
22:22:14 <HaskellLove> 200 is too much for you guys?
22:22:16 <BONUS> and he's motivated
22:22:18 <Axman6> his approach isn't though
22:22:22 <BONUS> yeah
22:22:30 <pastah_rhymez> HaskellLove: to be good you don't have to learn a LOT of languages, but you have to learn a few (which are stuctually different) god
22:22:33 <Axman6> HaskellLove: you don't learn things from books in my experience
22:22:33 <BONUS> HaskellLove: 200 is too much if you won't learn anything new
22:22:33 <pastah_rhymez> *good*
22:22:40 <mauke> *well
22:23:04 <HaskellLove> haha well your approach is wrong then, 200 pages is ok for a day when learning language because lot of concepts u already know and all that content just turns into "reference"
22:23:16 <osaunders> It's not just about consuming knowledge.
22:23:25 <osaunders> It's very important to understand the merits of languages.
22:23:33 <HaskellLove> that is why i solve euler with haskell to learn it
22:23:34 <osaunders> And why they were designed the way they were.
22:23:51 <osaunders> Euler is just math problems.
22:24:01 <HaskellLove> haskell is a big one so i wont do it with a 200 book a day, but u see i measure for what language i can do that
22:24:06 <osaunders> So you'll learn about how good Haskell is for solving math problems.
22:24:07 <pastah_rhymez> HaskellLove: i really recomend trying to complete the lab that i linked to
22:24:50 <Axman6> HaskellLove: i've been using Haskell almost exclusively for two years now. i would not say i've learnt it, because there's just so much to learn. you won't lewarn any language quickly
22:24:56 <osaunders> HaskellLove: if you learn Haskell you can say not only that you know Haskell but that you know an entirely category of PLs namely, purely functional ones.
22:25:27 <osaunders> Learn the best languages from each paradigm.
22:25:54 <osaunders> I'd suggest: Assembly, C, SmallTalk, Haskell, Common Lisp.
22:25:57 <HaskellLove> osaunders exactly, that is how you do it for imperative languages too, lot of stuff are same and you can pass a language in a day if it is small and not as complicated as c++
22:26:17 * Axman6 does not agree with common lisp... but just because he hates brackets
22:26:26 <Peaker> osaunders: what paradigm is CL of?
22:26:32 <osaunders> Homoiconic.
22:26:33 <HaskellLove> I studied assembly and architecture yes, c yes, smalltalk no, haskell now, lisp no but scheme a litle yes
22:26:37 <pastah_rhymez> Axman6: <3 <3 <3 $ <3 <3 <3
22:26:39 <osaunders> I think you should have a homoiconic language in there.
22:26:49 <jkff> osaunders: Why not Java or C# also? OOP with a good type system is a rather serious thing to learn.
22:27:03 <pastah_rhymez> jkff: smalltalk?
22:27:04 <Peaker> osaunders: then I'd s/CL/Scheme
22:27:12 <mauke> jkff: did you just say "java" and "good type system"?
22:27:16 <osaunders> jkff: I suggested SmallTalk. I consider that the best mainstream(ish) OOP language.
22:27:17 <pastah_rhymez> haha
22:27:21 <mrd> java's type system is unsound
22:27:32 <mauke> what type system isn't?
22:27:37 <mrd> SML :)
22:27:43 <mauke> heh
22:27:54 <jkff> mauke: Java's type system is not *that* bad
22:28:01 <jkff> F-bounded polymorphism and stuff :)
22:28:07 <mauke> jkff: yes, it is
22:28:12 <Peaker> isn't Haskell's type system minus some unsafe* functions sound?
22:28:35 <HaskellLove> let me ask u guys this: If i solve all problems from euler project in haskell will that mean i have enough math to be good computer scientist?
22:28:54 <Axman6> HaskellLove: probably not, but possibly
22:29:01 <mauke> jkff: typing of arrays is just broken, and I've yet to see a good equivalent of Either X Y in java
22:29:02 <Axman6> i'm going to say no though
22:29:25 <jkff> mauke: Well, it is broken, but still oop+parametric polymorphism is worth learning
22:29:32 <pastah_rhymez> HaskellLove: maybe a good computer scientist, but not a good haskler
22:29:37 <HaskellLove> Axman6 probably wont solve them all, or if i do does not make me good computer scientist?
22:29:46 <Axman6> no
22:29:54 <osaunders> What's a computer scientist anyway?
22:29:57 <osaunders> I mean, really
22:29:59 <pastah_rhymez> you'll probably not go beyound the IO monad if you just do project euler
22:30:00 <Axman6> makes you a freak at project euler though
22:30:39 <koala_man> osaunders: an android professor
22:30:49 <pastah_rhymez> HaskellLove: please, have a stab at the sudoku solver :)
22:31:01 * benmachine used the list monad in a PE problem once or twice
22:31:15 <pastah_rhymez> it's a great place to start if you wanna get good at hasklin'
22:31:32 <Axman6> HaskellLove: there are whole worlds of programming and computational knowledge that you won't even touch using ptoject euler
22:31:37 <jkff> mauke: I'd say that Java's and C#'s type system are in some senses more powerful than the type system of Haskell'98
22:31:46 <jkff> For example, they both can encode higher-rank and impredicative polymorphism
22:31:54 <osaunders> HaskellLove: There's always more to learn than you will be able to.
22:32:03 <HaskellLove> how much time u think is decent for me to solve euler in haskell if i am full time on it?
22:32:12 <mauke> jkff: I don't care. if I don't get Either X Y, I don't need the rest
22:32:36 <jkff> mauke: Yes, ADTs are a must. I'm, however, discussing not the practical but the theoretical value of a type system :)
22:32:41 <HaskellLove> so far i got 4 in scala and #5 in haskell, will do more tonight
22:32:44 <Axman6> HaskellLove: i highly doubt you will solve all of it, unless you are a programming genius (there's something like 10 people who have solved every problem)
22:32:51 <mauke> I don't even need ADTs
22:33:04 <jkff> Do you need specifically Either? :)
22:33:20 <mauke> well, my standard example is a syntax tree
22:33:34 <mauke> data Expr = Lit Integer | Add Expr Expr | Mul Expr Expr
22:33:34 <pastah_rhymez> what happened when i had a function that was called '_f'?
22:33:44 <pastah_rhymez> was it that warnings got turned off?
22:34:01 <jkff> mauke: Isn't that an ADT?
22:34:03 <mauke> I know how to do this in Haskell and C
22:34:13 <mauke> I don't have a nice solution for Java
22:34:20 <jkff> There really isn't one.
22:34:45 <quicksilver> well, you solve it with subclasses. But it certainly isn't nice.
22:34:54 <quicksilver> leads you down to the path to visitor patterns etc
22:34:54 <mauke> subclasses are too open
22:34:59 <quicksilver> you can leave your sanity at the door
22:35:11 <quicksilver> yes, you ignore the open ness
22:35:12 <Peaker> mauke: yeah, there are no closed type sums in Java/etc. you're supposed to only use open type sums
22:35:13 <pastah_rhymez> how the HECK did java get so big?
22:35:16 <jkff> But I think it would still be unfair to say "java's type system is a piece of shit" just because it doesn't have algebraic datatypes, although it has parametric, F-bounded, higher-rank and impredicative polymorphism
22:35:16 * mrd notes that java generics were designed by wadler
22:35:41 <mrd> no its a piece of shit because it has covariant mutable arrays
22:35:45 <mauke> I don't care about buzzwords, I want nice syntax trees
22:35:46 <quicksilver> just like we ignore the fact that you can't specify two lists are the same length in haskell.
22:35:47 <Peaker> I don't know what those terms mean
22:35:53 <mrd> and no implicit typing
22:36:38 <mrd> and OOP is an ill-defined fad, not a foundation for a PL
22:36:46 <osaunders> Uh oh. Programming language war has broken out.
22:36:51 <mrd> woot
22:36:59 <osaunders> lol
22:37:10 * mauke saddles his perl, rides off
22:37:19 <osaunders> Wooo PHP yeahhh!
22:37:21 <jkff> What do you mean under the OOP that you call an ill-defined fad?
22:37:39 <osaunders> Actually C++ is my favorite language.
22:38:09 <mrd> just about every oop language has a different definitiion of oop
22:38:15 <Peaker> I like "ill-defined fad" :)
22:40:01 <mrd> smalltalkers don't think you can have oop with static types. CLers snort at message passing. Selfish programmers think inheritance is nuts.
22:41:23 <roconnor> inheritance is nuts
22:41:31 * mrd agrees
22:43:10 <Apocalisp> http://www.google.com/codesearch/p?hl=en#COL-LTKK9OQ/trunk/src/main/fj/data/Either.java&q=either%20package:http://functionaljava\.googlecode\.com&sa=N&cd=1&ct=rc
22:44:11 <osaunders> Paul Hudak said "I don't think the perfect object oriented language has yet been designed."
22:44:53 <osaunders> OO is a really vague term, certainly.
22:45:05 <osaunders> That doesn't mean it has no value.
22:45:17 <osaunders> Or that it can't be refined into being valueful.
22:45:42 <Peaker> osaunders: I don't think it will ever be
22:45:47 <mrd> ?quote objectionable
22:45:47 <lambdabot> mrd says: if it has functions, it's functional.  if it has objects, it's objectionable.
22:46:01 <Peaker> ;)
22:52:24 <drostin77> Hello world?
22:52:48 <mrd> putStrLn "Hello world?"
22:53:18 <drostin77> :) cool, first time turning on irc in ~10 years, wasn't sure how to go about it
22:54:04 <eivuokko> You've done the first steps right: get on a friendly channel, and wrote something.  :-)
22:54:10 <mrd> feel any different?
22:54:12 <drostin77> Is this a good place to ask questions about Haskell?
22:54:20 <dschoepe> Yes, hence the name :)
22:54:22 <sioraiocht> drostin77: yes =)
22:54:27 <drostin77> hahah, no not a lot has changed, i like irssi more than whatever it was
22:54:33 <mrd> This is a support channel for people named Haskell
22:55:03 <drostin77> ok, well this is sort of a Haskell question: I cannot get ghci vi-style editing, how do I do that?
22:55:13 <drostin77> I have even tried an 'rlwrap -cr ghci'
22:55:16 <dschoepe> mrd: and if your surname is Curry, you become an operator, right?
22:55:30 <mrd> yes
22:56:34 <mrd> ghci is readline based
22:56:39 <drostin77> (working through real world haskell and about the 200th time i hit escape 0cw and just typed 0cw i decided i need to do something)
22:57:01 <drostin77> ya... my .inputrc is set up for vi... irb (ruby interactive) and python (uh... python interactive) both seem to react
22:57:07 <drostin77> ah...
22:57:13 <drostin77> its probably compiled without readline?
22:58:00 <quicksilver> recent ghcis are , in fact, not readline based
22:58:04 <quicksilver> (which is quite annoying)
22:58:07 <quicksilver> maybe you have one of those
22:58:12 <quicksilver> I think the change was in 6.10.x
22:58:12 <mrd> oh?
22:58:23 <quicksilver> they tried editline for a bit, and then haskeline
22:58:26 * mrd is still on 6.8
22:58:32 <quicksilver> so am I
22:58:35 <quicksilver> partly for this reason ;)
22:58:49 <drostin77> ah
22:58:50 <drostin77> aha
22:58:54 <drostin77> that explains things
22:59:06 <drostin77> i'm 6.10.4 it seems
22:59:24 <Axman6> quicksilver: what problems do you have with haskeline?
22:59:27 <portnov> what about smth like `rlwrap ghci` ?
22:59:32 <quicksilver> Axman6: the fact that it isn't readline.
22:59:38 <Axman6> :\
22:59:41 <Axman6> so?
22:59:42 <quicksilver> Axman6: people who misunderstand readline are doomed to reinvent it, poorly.
22:59:55 <drostin77> portnov: Ya, i said above, but i even tried rlwrap
22:59:57 <quicksilver> readline has config files (which drostin77 is trying to configure) and works across all the apps you have that use it.
22:59:57 <mrd> i typically run ghci in emacs though so i wouldn't notice
23:00:01 <drostin77> and it doesnt work...
23:00:21 <drostin77> yes, well actually i havent touched my realdine config file in quite some time, its just worked...
23:00:35 <quicksilver> mrd: to be honest, so do I. But it's the principle, no? ;)
23:01:02 <drostin77> which is why ghci stumped me so much, but now i see why
23:01:14 <drostin77> is trunk/newer ghci still on haskeline?
23:01:54 * Axman6 dislikes the GPL, and assuming readline is GPL based, thinks this is a good enough reason to replace readline
23:01:57 <mrd> sure
23:02:38 <drostin77> Axman6 you wouldnt happen to know if haskeline can act vi-like?
23:02:43 <p_l> readline is an infamous GPL submarine
23:02:48 <Axman6> not a clue
23:03:08 <mrd> we all live on a GPL submarine
23:03:10 <Axman6> i'm also quite happy with how haskeline works right now though
23:03:10 <drostin77> blast, my muscle memory is really getting the better of me as I learn haskell :P
23:03:20 <mrd> not quite as snappy
23:03:50 <aavogt> haskeline supposedly has a vi mode too
23:04:41 <drostin77> ya, heheh, i see a lot of support tickets about the vi mode, but still searching how to use it
23:04:47 <int-e> quicksilver: I have a half-baken ghci-readline somewhere. I can't find find it right away though. (The half-baken part is a) it isn't cleaned up and b) completions behave somewhat odd)
23:05:16 <drostin77> editMode: Vi might be the trick!
23:06:13 <int-e> although once haskeline handles ^K / ^Y properly (I think I've seen code for that in the darcs version?) I'll probably be happy with it.
23:06:54 <drostin77> Thank you Axman6! ghci uses haskeline was the missing bit of info :)
23:07:25 * benmachine finds telling GHC where to put/find things rather tedious
23:07:25 <drostin77> echo editMode: Vi > ~/.haskeline # was all it took
23:07:29 * hackagebot upload: AVar 0.0.5 - Mutable variables with Exception handling and concurrency support. (AlexMason)
23:07:55 <Axman6> oooh, that's mine :O
23:08:59 <benmachine> if I tell ghc to compile into the current directory (i.e. I don't use -odir or -hidir) then it gives the .o and .hi files names corresponding to the .hs files
23:09:06 <benmachine> which is good
23:09:28 <pozic> How can I verify that hmacSha1 computes the right result? E.g. by using some kind of command line tool which is supposed to return the same?
23:09:55 <pozic> (In Data.Digest.Pure.SHA in the SHA package)
23:10:02 <benmachine> but if I give it -odir and -hidir somewhere else, it uses the module name, and since they are all module Main this results in re-use of the same interface and object file
23:10:15 <benmachine> so ghc produces a lot of the same executable?
23:10:26 <benmachine> pozic: sha1sum?
23:10:35 <benmachine> (at a guess)
23:11:31 <benmachine> no that doesn't sound like what you want
23:11:45 <netinho2lol> sup haskell
23:12:20 <pozic> benmachine: I also need to input a secret key and I don't know the format sha1sum expects.
23:12:20 <benmachine> sup
23:12:41 <netinho2lol> M.hs:98:16-19: Not in scope: 'mix2'
23:12:46 <netinho2lol> what does that mean?
23:12:47 <Jafet> What is, in this case, the "right result"?
23:13:19 <Jafet> netinho2lol, that your code has an error
23:13:28 <benmachine> netinho2lol: that the mix2 function was not in the scope in which it was used?
23:13:41 <netinho2lol> I don't think so
23:13:45 <netinho2lol> it's defined in a where
23:13:53 <benmachine> most common causes: missing import, typo, etc
23:13:59 <benmachine> paste
23:14:02 <netinho2lol> kk
23:14:12 <pozic> Jafet: the right result is whatever other tools return.
23:14:21 <benmachine> my guess is that the where is attached to a different equation, or something
23:15:59 <Jafet> pozic, that's a meaningless thing to tell me
23:16:19 <pozic> Jafet: I didn't mean it to be meaningful.
23:16:56 <Jafet> You're mean.
23:17:06 <pozic> Jafet: the question is clear, no? I just want to check consistency with other tools that are more often used than Haskell.
23:17:44 <Jafet> Why do you want consistency with some unnamed other "tools"?
23:17:59 <netinho2lol> okay
23:18:02 <netinho2lol> I've pasted
23:18:11 <benmachine> because otherwise hashing doesn't make much sense?
23:18:19 <netinho2lol> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13806
23:18:45 <Jafet> That was a meaningless answer-masquerading-as-question
23:19:02 <Jafet> Assuming you're actually looking for these "tools", I would try openssl(1)
23:19:15 <netinho2lol> openssl is huge
23:19:17 <benmachine> netinho2lol: yeah, I think where attaches to a single equation
23:19:26 <Jafet> Which is why I suggested to try it.
23:19:40 <benmachine> so the equation with mix' can't see it
23:20:07 <benmachine> you can either do mixM xs = case xs of ... and put the where on that
23:20:17 <benmachine> or you can put mix' at the top level, I suppose
23:20:42 <benmachine> or you could call it zipWith mix
23:20:46 <benmachine> and then inline it
23:20:50 <Jafet> Or use let.
23:20:59 <benmachine> how would that help?
23:21:03 <netinho2lol> zipwith?
23:21:14 <benmachine> yes
23:21:15 <pozic> Jafet: php -r 'echo hash_hmac("sha1", "message", "key"),"\n";'
23:21:19 <benmachine> @src zipWith
23:21:20 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:21:20 <lambdabot> zipWith _ _      _      = []
23:21:22 <pozic> Jafet: that is what I wanted to hear.
23:21:27 <benmachine> oh
23:21:32 <benmachine> it's not zipWith
23:21:50 <benmachine> close, though
23:21:53 <benmachine> hmm
23:22:34 <netinho2lol> I'm gonna do the case of thingie
23:22:43 <netinho2lol> because I like case-ofs
23:22:44 <netinho2lol> :P
23:22:49 <Jafet> pozic, too bad then, my guessing was way off
23:25:27 <netinho2lol> benmachine: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13806
23:25:31 <netinho2lol> liek this?
23:26:14 <benmachine> netinho2lol: basically yeah
23:26:56 <benmachine> you could do it a bit simpler though
23:27:12 <ksf> hjscript or jmacro?
23:28:29 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13806#a13808 netinho2lol this is an alternative although not necessarily better
23:28:34 <benmachine> depending on your perspective
23:30:02 <netinho2lol> uhm
23:30:06 <netinho2lol> this is actually better
23:30:14 <netinho2lol> empty -> stuff
23:30:22 <netinho2lol> otherwise not empty
23:30:27 <netinho2lol> being one or more elements
23:31:11 <benmachine> p.s. every time I see a function with a [] case and a (x:xs) case I think foldr
23:31:24 <benmachine> might be more complicated here but still
23:32:15 <ksf> there's no hsp-plugin for happstack?
23:32:15 <roconnor> @src tail
23:32:16 <lambdabot> tail (_:xs) = xs
23:32:16 <lambdabot> tail []     = undefined
23:36:47 <ksf> uh. oh. I see. happstack actually depends on hsp.
23:47:40 * hackagebot upload: AVar 0.0.5.1 - Mutable variables with Exception handling and concurrency support. (AlexMason)
23:48:06 <copumpkin> mmorrow: looks like spoon got lots of love on the haskell subreddit :D
23:50:51 <dolio> copumpkin: (x :: T) patterns used to be a separate extension, but it got rolled into ScopedTypeVariables for reasons we laymen aren't (I think) too sure about.
23:51:04 <copumpkin> lol
23:51:17 <dolio> At least, I don't know why.
23:54:26 <quicksilver> dolio: what is an (x :: T) pattern?
23:54:36 <dolio> quicksilver: A type annotated pattern.
23:55:09 <quicksilver> dolio: ah, I understood the word 'pattern' at the wrong level of discourse
23:55:17 <copumpkin> useful mostly for exception handlers
23:55:19 <quicksilver> dolio: in future could you use coloured text to indicate metalevels ;)
23:55:46 <Saizan_> dolio: maybe the haskell-prime wiki has some rationale?
23:55:47 <dolio> I don't think coloured text is allowed in this channel. :)
23:56:03 <quicksilver> I think it's simply that PatternSignatures were very very useful in the context of ScopedTypeVariables
23:56:08 <quicksilver> so the latter switches on the former
23:56:10 <quicksilver> I'm not sure though.
23:56:25 <copumpkin> maybe that's it
23:56:33 <copumpkin> but when I put in a pttern signature, it suggested ScopedTypeVariables
23:56:38 <copumpkin> not PatternSignatures
23:56:43 <quicksilver> dolio: no, a ban which I strongly oppose
23:57:03 <copumpkin> then we'd need to get lambdabot to accept syntax-highlighted code :D
23:57:51 <copumpkin> roconnor: I "cited" you on reddit
