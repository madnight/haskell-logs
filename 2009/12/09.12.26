00:00:07 <sannysanoff> i want to wrap call of these functions in error handler, which returns specific Response upon IOException
00:00:11 <sannysanoff> all happens in IO monad
00:01:13 <sannysanoff> is what I want strange?
00:01:20 <uorygl> Cale: you know, I'm curious--would you say that False False False has a type, given sufficiently fancy types?
00:01:26 <uorygl> sannysanoff: hmm, lemme think.
00:01:52 <uorygl> Well, I don't see why that would require the type of function you describe.
00:02:02 <sannysanoff> uorygl, please enlighten me
00:02:29 <Cale> uorygl: heh, polymorphic bools and sure ;)
00:02:31 <uorygl> Maybe if you told me where the function you describe fits into all this? Or, if not...
00:02:37 <voker57> :t False False False
00:02:38 <lambdabot>     Couldn't match expected type `Bool -> Bool -> t'
00:02:38 <lambdabot>            against inferred type `Bool'
00:02:38 <lambdabot>     In the expression: False False False
00:02:41 <sannysanoff> uorygl, i want this:  ToMessage a => IO a -> IO a
00:03:05 <sannysanoff> and inside, I want to add some catch() or catchSql
00:03:14 <uorygl> sannysanoff: is Response in ToMessage?
00:03:20 <sannysanoff> yes
00:03:55 <sannysanoff> should I return toResponse "error" ?
00:04:03 <sannysanoff> and write Response as a return type?
00:04:39 <uorygl> It does sound like your error handler is simply going to give you either a String or a Response, which is what Either is for.
00:04:55 <sannysanoff> it was supposed to give ToMessage :)
00:05:13 <sannysanoff> uorygl, I understand solution with either, and it is not cute ;)
00:05:53 <uorygl> Well, what does ToMessage look like?
00:06:13 <sannysanoff> I had this code:     val <- liftIO $ fun; return $ toResponse fun,,,,, now i want just val <- liftIO $ handleException $ fun
00:07:34 <uorygl> If it's pretty much the same class as Show, can you just return a Message or whatever?
00:08:18 <uorygl> I guess it all comes down to whether you want Strings and Responses returned by this function to be treated differently or the same.
00:09:11 <uorygl> If they should be treated the same, treat them inside the handleException function; if they should be treated differently, use Either, and it won't really look much worse.
00:10:10 <sannysanoff> uorygl, i understand the approach, thanks.
00:10:20 <sannysanoff> i will return concrete Responses
00:10:28 * uorygl nods.
00:11:27 <sannysanoff> uorygl, with haskell, each time you are in situation: "well, this time I found another way of doing this, but what will happen next time?"
00:11:41 <sannysanoff> :)
00:12:14 <uorygl> :-)
00:13:28 * uorygl ponders in which order a function should pop its arguments from the stack.
00:13:42 <uorygl> I think f x y z should pop x, then y, then z.
00:13:47 <uorygl> That was easy!
00:16:14 <copumpkin> f x y z = ... => f = (\x -> (\y -> (\z -> ...)))
00:17:55 * uorygl decides to actually write a Haskell machine.
00:18:47 <ivanm> aren't you meant to _build_ machines?
00:18:54 <uorygl> Yeah, you are.
00:18:59 <uorygl> But first you have to figure out how they work.
00:18:59 <Cale> uorygl: The stack isn't used for parameter passing though. ;)
00:18:59 <copumpkin> VHDL?
00:19:11 <uorygl> Cale: can it be used for parameter passing?
00:19:26 <Heffalump> the Reduceron is a Haskell machine
00:19:52 <copumpkin> @hoogle reduceron
00:19:53 <lambdabot> No results found
00:19:56 <copumpkin> whoops
00:19:58 <copumpkin> google :)
00:20:24 <eldragon> @google reduceron
00:20:26 <lambdabot> http://www.cs.york.ac.uk/fp/reduceron/
00:20:26 <lambdabot> Title: The Reduceron
00:20:28 <Cale> uorygl: There are lots of ways you could do this, but in the model I've been describing, the stack is used immediately after in a lot of cases, because a lot of functions (all the technically strict ones) will pattern match right away, and that's what the stack is for
00:21:21 <Cale> I guess at a low level, you need a value stack to pass parameters around after all, but perhaps not if you were rewriting term trees.
00:21:27 * uorygl decides to denote thunks with overlines.
00:21:55 <Cale> uorygl: Oh, another way: expressions are graphs
00:22:11 <Cale> (rooted, directed graphs)
00:22:25 * uorygl finds that almost everything is a thunk.
00:22:36 <copumpkin> who woulda thunk
00:22:49 <Cale> "thunk" is the generic name for "implementation of an expression"
00:23:04 <uorygl> Here, thunks seem to be C-style functions. >.>
00:23:14 <Cale> Or pointers to them
00:23:25 <uorygl> Right, pointers to C-style functions.
00:23:26 <Cale> You're reading the STG machine paper?
00:23:31 <uorygl> No, I'm winging it.
00:23:34 <Cale> ah, okay
00:23:51 <Cale> Another way is (pointer,bool) pairs
00:24:05 <Cale> where the pointer points to code when the flag is unset, and data when it is
00:24:21 * uorygl ponders whether premature optimization is the root of all evil.
00:24:46 <tensorpudding> the root of all evil is saying something is the root of all evil
00:24:49 <eldragon> @google STG machine paper
00:24:51 <lambdabot> http://citeseer.ist.psu.edu/200357.html
00:25:08 * uorygl suddenly finds he could really go for a Subway sandwich, even though it's 3:24 in the morning and he has no car.
00:25:10 <Gracenotes> whatever it is, some good engineering is antidotal
00:27:12 <uorygl> Well, these thunks sure don't update themselves.
00:27:25 <copumpkin> the thunkmeister does
00:27:48 <uorygl> My sheet of paper doesn't have a thunkmeister on it.
00:28:03 <copumpkin> you can be the thunkmeister then
00:28:16 <uorygl> I can't put myself into the chip I'm creating.
00:28:34 <copumpkin> guess you're stuck then
00:28:41 <uorygl> It's too small, and it would result in the chip being too expensive.
00:29:22 <uorygl> It would cost over three million dollars.
00:30:32 <uorygl> Hmm. If the average person is worth three million dollars, and the average person's income is seven thousand dollars, then the average person is worth what they could make in about 500 years.
00:31:01 <BMeph> ...and how much would the chip be, without the itty-bitty Subway franchise inside? ;)
00:31:51 * roostaj mumbles something about 5 dollar sandwiches and walks away
00:32:31 <eldragon> what fucking is the life of avg joe.
00:33:07 <eldragon> even non-avg joe
00:33:43 <uorygl> Hmm. I think these thunks don't update themselves because they take parameters.
00:33:47 <uorygl> Which is a really sensible thing to do.
00:34:32 <uorygl> "Bah, most normal users don't call functions with varying parameters."
00:39:42 <uorygl> Hmm, I'm assuming that you can simply call an arbitrary thunk, and I'm also assuming that an expression applied to another expression is a thunk.
00:40:56 <uorygl> I'm missing the thunk representing what f x looks like.
00:41:16 <uorygl> The thunk template, that is.
00:47:39 <uorygl> Now, using the arguments-on-the-stack idea, it seems like the f x thunk should simply push x, call f, and replace itself with whatever f returned.
00:50:23 <uorygl> Unfortunately, f could take a whole bunch of arguments that it oughtn't.
00:50:26 <uorygl> Or could it?
00:54:50 <uorygl> Yeah, I think it could. The f x template thunk is going to keep some stuff on the stack.
00:55:33 <uorygl> So, not passing arguments on the stack sounds like a good idea.
00:56:54 <ivanm> if I have a class Foo, and a function that takes in a Foo value and within it creates another Foo value, is there any way of forcing the second value to be the same Foo instance as the first?
00:57:48 <uorygl> So you have class Foo where f :: Foo a => a -> ...?
00:57:58 <ivanm> no
00:58:41 <uorygl> Oh, f isn't a member of the class, is it.
00:58:47 <ivanm> I have a class Foo a, and  a function bar :: (Foo a) => a -> Int; within bar I create another instance of Foo, but I want to force it to be the same instance
00:58:51 <Gracenotes> f is a function that a type must implement
00:58:53 <ivanm> nope
00:58:55 <uorygl> Yes, you can do that.
00:58:59 <ivanm> Gracenotes: no...
00:59:01 <ivanm> uorygl: how?
00:59:09 <uorygl> One way is the function asTypeOf.
00:59:17 <Gracenotes> at least, in the closest valid syntax to what he has
00:59:28 <ivanm> IIRC, there's a way of using forall ...
00:59:37 <ivanm> Gracenotes: yeah, he was wrong ;-)
00:59:37 <uorygl> bar x = blah (y `asTypeOf` x); y is the other instance of Foo.
00:59:52 <dblhelix> ivanm: wouldn't a function of type f :: Foo a => a -> a just do?
01:00:14 <dblhelix> a function f of type Foo a => a -> a, that is
01:00:42 <dblhelix> this specifies that the result instance is the same as the argument instance
01:01:00 <uorygl> dblhelix: but f doesn't return an a, it returns an Int.
01:01:02 <ivanm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15016#a15016
01:01:29 <dblhelix> uorygl, ivanm: ah, I see
01:02:23 <dblhelix> uorygl: well, indeed, then either you factor out a local auxiliary function with a suitable type signature or you use something like asTypeOf
01:02:29 <dblhelix> @type asTypeOf
01:02:29 <lambdabot> forall a. a -> a -> a
01:02:36 <ivanm> @src asTypeOf
01:02:36 <lambdabot> asTypeOf = const
01:02:39 <ivanm> heh
01:02:53 <dblhelix> asTypeOf just refines the type of const a bit ;-)
01:03:02 <ivanm> I thought asTypeOf was some fancy dynamic typing thing
01:03:13 <uorygl> ivanm: perhaps you could also say bar :: forall a. (Foo a) => a -> Int; bar x = blah (y :: a); I don't know if that would work.
01:03:38 <ivanm> \o/
01:03:42 <dblhelix> uorygl: then you need scoped type variables, which are not in Haskell 98
01:03:48 <uorygl> Let me just take a moment to mention that I'm kind of angry that f (fix f) and fix f can have different types.
01:03:55 <dblhelix> (and also not in Haskell 2010, I think)
01:04:00 * uorygl shakes a fist at whoever created mathematics.
01:04:09 <ivanm> dblhelix: bah, I'm already using MultiParamTypeClasses, FlexibleContexts, FlexibleInstances
01:04:19 <ivanm> uorygl: I believe it was the greeks
01:04:30 <Gracenotes> uorygl: so it was you who traveled back in time and killed Archimedes, eh???
01:04:36 <dblhelix> ivanm: ah, then ScopedTypeVariables won't hurt, I suppose :)
01:05:04 <uorygl> Depends on whether you ask Plato or Hawking.
01:05:07 <uorygl> Gracenotes: not yet!
01:05:09 <ivanm> I don't recall coming across asTypeOf before...
01:05:11 <ivanm> anyway, it works!
01:05:22 <ivanm> thanks uorygl
01:05:31 <Gracenotes> oh dear, not another self-fulfilling ontological prophesy
01:05:43 <dblhelix> uorygl: they can't have different types if we restrict ourselves to rank-1 polymorphic types, can they?
01:06:40 <uorygl> Gracenotes: you know, that going back in time and killing Archimedes thing sounds like a great idea...
01:06:55 <uorygl> dblhelix: I dunno, is String -> a a rank-1 polymorphic type?
01:07:24 <dblhelix> uorygl: it sure is...
01:07:42 <uorygl> Well, error (fix error) :: a while fix error :: String.
01:08:10 <dblhelix> uorygl: ah, but then they still have the same type: String
01:08:36 <dblhelix> uorygl: the former just happens to have more types than the former... but they agree on String
01:08:50 <uorygl> They have different canonical types.
01:09:11 <dblhelix> uorygl: what's the canonical type of error (fix error) then?
01:09:37 <uorygl> @type fix error
01:09:38 <lambdabot> [Char]
01:09:40 <uorygl> @type error (fix error)
01:09:41 <lambdabot> forall a. a
01:09:46 <uorygl> Those.
01:09:54 <dblhelix> uorygl: but forall a. a is not a type
01:10:00 <dblhelix> uorygl: it's a type scheme
01:10:09 <uorygl> Sure it is. It's a thing that comes after ::, so it's a type.
01:10:29 * uorygl ponders whether the plural of "scheme" is "schemeta".
01:10:40 * dblhelix doesn't quite agree
01:11:40 * uorygl ponders whether the plural of "comma" is "commata"!
01:11:45 <copumpkin> clearly
01:12:20 <uorygl> Wait, the word "comma" actually does from the Greek "komma" whose plural is "kommata".
01:12:28 <uorygl> Who expected that?
01:12:55 * uorygl ponders whether the plural of "algebra" is "algebrata".
01:13:10 <copumpkin> al jabr?
01:13:34 <luite> and computa is actually the plural of compu
01:13:42 <dblhelix> and scheme comes from Greek σχήμα, of which the plural reads σχήματα
01:14:00 <uorygl> Hence the word "schemata".
01:14:08 <dblhelix> there you go
01:14:14 <uorygl> Why are "scheme" and "schema" separate words? The word "scheme" even came from the Latin "schema".
01:14:27 <luite> hm, I need to fix utf8 here
01:14:37 <copumpkin> uorygl: there are other pairs like that
01:14:42 <Gracenotes> let's ask the person who started using scheme
01:14:44 <uorygl> Yeah, they're called... what...
01:14:47 <ivanm> uorygl: because nowadays they mean different things
01:14:58 <uorygl> Doublets.
01:15:05 <ivanm> we need to devise a new scheme to take over the programming world!
01:15:13 <Gracenotes> probably an anglicization that wasn't fully implemented, and eventually each fit a niche of separate meanings, ensuring the survival of both
01:15:17 <ivanm> luite: as in your usage of utf8?
01:16:27 <uorygl> Trivia: "host" and "guest" are doublets, even though they're opposites. "Aperture" and "overture" are also doublets, both meaning "opening", but in completely different senses.
01:16:30 <uorygl> Or so Wikipedia rumors.
01:17:28 <luite> ivanm: no the display in this terminal, every time someone uses some fancy characters I only see ?????
01:17:43 <drhodes> dblhelix: agda-mode is nice, thanks for the suggestion.
01:17:56 <dblhelix> drhodes: you're welcome
01:18:15 <copumpkin> drhodes: you doing agda with it?
01:19:09 <drhodes> copumpkin: trying to type out this syntax in Hoare's "communicating sequential processes"
01:20:11 <copumpkin> ah
01:20:22 <luite> could someone say a greek character again :)
01:21:15 <ivanm> luite: OK, so you need a better font
01:21:33 <ivanm> Ͳ
01:21:35 <luite> ivanm: I think it's because I use screen and irssi
01:21:43 <ivanm> bah, I see an empty box for it now!
01:21:47 <ivanm> but when I type it, it's OK...
01:22:17 <luite> I still see a question mark
01:23:26 <uorygl> Ͳ is a square here, even. What is it?
01:23:38 <ivanm> a fancy looking T with curled down edges
01:24:00 <copumpkin> ͳ
01:24:00 <ivanm> weird... whatever the default "Sans" font is can display that character, but DejaVu Sans Mono can't...
01:24:10 <copumpkin> ͱ
01:24:29 <luite> wow sans looks weird in this terminal
01:24:33 <augur> hey guys
01:24:36 <augur> hows it gooooin
01:24:40 <luite> it tries to monospace a proportional font
01:24:56 <augur> i'll monospace you
01:24:57 <augur> ;o
01:25:28 <uorygl> I think my terminal simply doesn't support non-monospace fonts.
01:25:44 <HaskellLove> One of the main arguments in favour of functional programming is that it is easier to prove properties of functional programs than of imperative programs... Hmm why is that so?
01:25:54 <copumpkin> lack of side effects
01:26:26 <uorygl> Lack of side effects and dependencies, "expression" is more likely to be meaningful.
01:27:55 * ivanm wonders why DejaVu Sans can display that character, but the Mono variant can't...
01:32:19 <HaskellLove> anyone has knowledge in Landin-stream I/O systems?
01:32:55 <augur> HaskellLove: functional languages are, essentially, forms of logic
01:33:01 <augur> or more accurately
01:33:07 <augur> theyre forms of logic that we understand _REALLY WELL_
01:33:21 <augur> whereas imperative languages are forms of logic that we dont understand really well
01:33:48 <augur> haskell, etc. are, for all intents and purposes, lambda calculus, which is well understood.
01:34:03 <augur> c, etc. are, for all intents and purposes, hoare logic, which is not so well understood.
01:34:18 <augur> therefore, functional languages are preferable if you care about prooving things about them easily.
01:39:23 <HaskellLove> "A stream is a potentially endless list of values, generated as need arises. Streams were used by Landin in his -calculus semantics of ALGOL 60 to represent the values of loop variables 76] he remarked that streams could have been used to represent I/O in ALGOL 60." Anyone can  talk about this and explain what is going on?
01:40:24 <uorygl> Perhaps I/O would consist of a function taking a stream and returning a stream, and values would simply be output as much as possible.
01:41:14 <copumpkin> haskell used to do something like this for IO I believe
01:41:30 <copumpkin> there was an ADT representing things you could do to interact with the outside world
01:41:42 <copumpkin> and you'd spit them out, and the RTS would consume them and do what you told it to
01:41:48 <copumpkin> something like that, anyway
01:42:19 * uorygl ponders how much a Haskell machine would have to look like a von Neumann machine at all.
01:45:56 <HaskellLove> sounds confusing :(
01:46:07 <uorygl> Well, von Neumann architectures have been used a lot, making them easy to think about, and they *seem* more or less optimal.
01:46:55 <Jafet1> (Optimal for what?)
01:47:04 <uorygl> Optimal for computing. :-P
01:47:20 <Jafet1> What's computing?
01:47:26 <Jafet1> And what's this
01:47:52 <uorygl> Computing is the evaluation of Haskell expressions!
01:48:27 <Jafet> There are superior architectures
01:48:48 <Jafet> For example, graph reduction hardware
01:48:59 <Jafet> I don't really understand them yet, though
01:49:55 <uorygl> Well, how is graph reduction hardware not a von Neumann machine?
01:50:37 <uorygl> You know, when I say "von Neumann machine", I probably mean something totally different. :-P
01:50:57 <augur> you probably do.
01:51:12 <uorygl> Like "machine that executes lots of instructions mostly in sequence".
01:51:17 <Jafet> Well then, this talk is going bottom, then.
01:51:25 <augur> and tho while von Neumann architecture is well understood in terms of programming them
01:51:36 <augur> theyre not well understood in terms of prooving things about them
01:51:40 <augur> and prooving things is important
01:51:41 <Jafet> Harvard machines also execute instructions in sequence.
01:51:49 <Jafet> "proving"
01:52:05 <augur> you know what, im a linguist
01:52:08 <augur> and i say you're wrong.
01:52:17 <Jafet> But I'm a cunning one.
01:52:20 <augur> damnit i wish i had said "your"
01:52:47 <uorygl> Hmm, my little piece of "compiled Haskell" has thirteen instructions. It could be executed as two, then two, then two, then one, then three, then one, then two, for a total of seven steps, as long as the processor is capable of executing three things simultaneously.
01:53:21 <uorygl> How hopscotch.
01:54:35 <Jafet> If you require your architecture to be purely sequential,( whatever that means,) then most consumer computers are not "von Neumann".
01:55:11 <Jafet> However the usual meaning I follow is "executes stored data as program and modifies state"
01:56:34 <uorygl> In that case, the von Neumann architecture is simply anything that isn't a non-von Neumann architecture.
01:57:06 <uorygl> About as much of an architecture as not-wood is a material.
01:59:21 <HaskellLove> continuation I/O, anyone has experience with that?
02:04:49 <copumpkin> HaskellLove: might not be as confusing if you actually understood most of the basis for the material you're reading :P
02:07:42 <HaskellLove> yeah i left it, it was a disertation
02:08:12 <Jafet> Desertation of dissertation
02:08:12 <copumpkin> dissertations tend to be some of the most readable material, because they try to give you an overview of everything leading up to the original work
02:11:44 <HaskellLove> copumpkin well I knew the first type cause i read a book on sml, side-effects IO, but the other three were hole new stuff
02:12:06 <copumpkin> I think you should strive to not only read books, but fully soak in the material
02:12:29 <copumpkin> as it stands, you seem to be sprinting through beautiful art galleries just so you can say you've seen all the art
02:14:04 <HaskellLove> not really :) to prove u i am ok, recommend me a book on functional programming that talks about: continuation I/O, Landin-stream I/O, and other crazy stuff...
02:15:00 <HaskellLove> it seems advanced, my college does not even teach functional programming, so i am self taught... but i supose in colleges  they learn these things, i did not find them so far in text books
02:15:16 <copumpkin> no, I don't know of such books :)
02:17:41 <HaskellLove> the monad system ok, i will learn it with haskell but these others were so new and, but nevermind, i will be busy for months just with haskell so... i was just lurking in, to check out what i might benefit reading, so i dont just do syntax in haskell and really understand stuff
02:18:17 <edwardk> HaskellLove: to be fair you don't need to understand continuation based IO or request/response based IO any more they are dead paradigms
02:18:49 <edwardk> HaskellLove: you can pick them up if they ever seem appropriate to some esoteric purpose of yours, but they are motly of academic interest these days
02:19:50 <HaskellLove> edwardk that is good to know thanks... so today most important ones are the Scheme/ML family vs Haskell right? I mean, side effects IO vs monadic? or there is a third also important?
02:20:13 <HaskellLove> i don't know what to call f#, it is so mixed there...
02:20:19 <edwardk> HaskellLove: those are the two that make the most sense to people. and as to why haskell doesn't use side effect based IO, it just plays havoc with laziness
02:20:21 <copumpkin> f# is ocaml, basically
02:20:45 <edwardk> HaskellLove: f#'s approach is side-effect based. they have 'workflows' but they are just syntactic sugar
02:20:46 <Jafet> The Lisps and MLs are not mathematically functional languages. I don't think it's useful to compare Haskell to them here.
02:20:58 <Jafet> Clean uses uniqueness typing.
02:21:35 <edwardk> Jafet: nothing prevents you from using them in such a fashion, however.
02:21:37 <Jafet> I don't really know of other approaches. I think sigfpe proposed something different
02:21:56 <edwardk> Jafet: his was just a continuation based approach, like the dead ones we mentioned above
02:22:13 <HaskellLove> Jafet we are comparing IO systems for functional languages, so we can compare in that sense...
02:22:15 <copumpkin> HaskellLove: I don't deny that reading all that stuff isn't enormously interesting, but unless you have a fairly strong basis and understanding of a real functional language I find it hard to believe you're absorbing much from the dozen books you've told us you read in the past few weeks
02:22:23 <Jafet> edwardk, well, I mean "functional" as a property of the language.
02:22:23 <copumpkin> *is
02:22:28 <edwardk> Jafet: if you want to be pedantic and collect all of them you can also view IO as a free monad over the set of io actions, which is a variation on the continuation passing style theme
02:22:42 <edwardk> Jafet: well, with unsafePerformIO we can hardly throw stones ;)
02:22:57 <copumpkin> we sort of can, still
02:23:03 <Jafet> There is no unsafePerformIO!
02:23:12 * Jafet waves a watch at edwardk
02:23:12 <copumpkin> even with unsafePerformIO, you can't write code like you can in other languages
02:23:28 <copumpkin> because it's not guaranteed to run at all and very unlikely to run multiple times
02:23:35 <edwardk> copumpkin: bah, with unsafePerformIO and unsafeCoerce you can get pretty close ;)
02:23:53 <edwardk> copumpkin: actually unsafePerformIO locks so it'll only run once
02:24:00 <copumpkin> yeah
02:24:07 <edwardk> copumpkin: unsafeDupablePerformIO can race like that though
02:24:10 <copumpkin> yeah
02:24:43 <copumpkin> but I just mean that if you write a "loop" and put unsafePerformIO (print "ohai!") inside it
02:24:46 <HaskellLove> copumpkin anyways, i read a book on R now for bioinformatics, then i will read this one, just found it seems cool and it says prerequisites basic programming knowledge in some func lang so... here it is: "the-optimal-implementation-of-functional-programming-languages-cambridge-tracts-in-theoretical-bla bla bla"
02:25:00 <copumpkin> you might just get one ohai! out of it
02:25:00 <edwardk> copumpkin: though had a very interesting discussion with jan-willem maessen the other day at bostonhaskell, apparently nehalem made it so that cas based thunking could be as fast as the current scheme without the potential duplication issue
02:25:13 <edwardk> copumpkin: so it might be worth just doing locking 'right' on modern cpus
02:25:16 <copumpkin> ooh
02:25:42 <edwardk> i'm thinking about it for kata, it fixes any ugliness in the semantics
02:25:42 <copumpkin> will it need some magic in our codegen or will it just work?
02:25:53 <xwl> Hi, i tried to build ghc HEAD on leopard 10.6, but failed at cofigure: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15019#a15019
02:26:12 <edwardk> can be made to just work. if i want to keep spitting out c++ i can make the forwarding pointer atomic<>.
02:26:12 <xwl> installed ghc binary is 6.10.4, what is wrong here?
02:26:14 <copumpkin> xwl: you're probably trying to built it 64-bit?
02:26:17 <copumpkin> or implicitly
02:26:20 <xwl> copumpkin: yup
02:26:24 <copumpkin> xwl: #ghc is a better place to ask, though
02:26:35 <copumpkin> xwl: ghc doesn't support 64-bit on osx though, yet
02:26:39 <copumpkin> (sadly)
02:27:02 <copumpkin> it should be fairly straightforward but it isn't
02:27:15 <xwl> bug looks like it tries to build it as 32bit?
02:27:19 <xwl> "Build platform inferred as: i386-apple-darwin"
02:27:25 <xwl> s/bug/but/
02:27:29 <edwardk> "Nehalem also lowers the latency for synchronization primitives such as LOCK, XCHG and CMPXCHG, which are necessary for multi-threaded programming. Intel claims that the latency for LOCK CMPXCHG instructions (which serializes the whole pipeline) is 20% of what it was for the P4 (which was absolutely horrible) and about 60% of the Core 2. While the latency is lower, the behavior is still similar to prior generaitons; 
02:28:22 <edwardk> xwl: actually that is a bug fix for the fact that it links wrong when using the defaults because of the way snow leopard changed out the linker or something like that
02:28:51 <edwardk> xwl: using the 32 bit stuff works, but the 64 bit stuff has a bug ghc-side iirc from the chatter about it
02:29:08 <Jafet> > unsafePerformIO (print "lol")
02:29:10 <lambdabot>   Not in scope: `unsafePerformIO'
02:29:30 <edwardk> jafet: caleskell lacks unsafePerformIO
02:29:43 <Jafet> I wonder why.
02:29:58 <xwl> edwardk: hmm, so why this still fails here?
02:30:20 <xwl> edwardk: the `ghc-pwd' binary should be already installed?
02:30:39 <edwardk> xwl: because they changed the behavior of mac os x with the new version, and no one on the ghc team has gotten around to fixing the 64 bit codegen
03:04:45 <ivanm> preflex: seen sinelaw
03:04:45 <preflex>  sinelaw was last seen on #haskell 22 hours, 48 minutes and 50 seconds ago, saying: i know!
03:10:21 <DigitalKiwi> preflex: seen glguy
03:10:22 <preflex>  glguy was last seen on #haskell 8 days, 16 hours, 30 minutes and 23 seconds ago, saying: Anyone familiar enough with the iteratee library to help me figure out what an EnumeratorN for converting streams of Char to streams of Word8 (using base 64) would look like?
03:10:27 <DigitalKiwi> preflex: seen glguy_
03:10:27 <preflex>  glguy_ was last seen on #haskell 133 days, 13 hours, 24 minutes and 58 seconds ago, saying: ;)
03:11:00 <copumpkin> wow
03:11:05 <copumpkin> he's been gone for a while
03:11:11 <copumpkin> not as long as FunctorSalad though
03:11:48 <koeien37> i've been gone for a while too :) of course I'm not as famous as FunctorSalad
03:11:55 <copumpkin> lol
03:12:04 <koeien37> maybe s/he'll return
03:12:08 <copumpkin> he!
03:12:26 <copumpkin> koeien37: how long were you gone? :o
03:12:41 <koeien37> i had had a break of half a year or so :)
03:12:59 <dolio> preflex: seen ddarius
03:12:59 <preflex>  ddarius was last seen on #haskell 6 days, 14 hours, 35 minutes and 30 seconds ago, saying: Excel.
03:17:10 <mreh> where do haskell record accessor functions go in the name space?
03:17:29 <koeien37> they are just functions?
03:17:38 <mreh> I can't remember how to import them when importing a datatype with a record constructor
03:18:11 <mreh> Foo = Foo { bar :: baz }
03:18:34 <mreh> import FooBarLibrary ( Foo(Foo) )?
03:18:41 <mreh> does that give me bar?
03:18:48 <koeien37> then you import the Foo type and the Foo constructor
03:18:54 <koeien37> I don't think it does, but I could be wrong.
03:19:01 <mreh> experiment time
03:19:06 <koeien37> yeah, for me too :)
03:19:57 <koeien37> apparently I was right
03:22:53 <mreh> that was quick
03:22:59 <mreh> i'm about to run mine
03:25:01 <koeien37> heh. vim > $EDITOR apparently ;)
03:25:25 <mreh> it is the editor of the beast
03:25:42 <mreh> if you import the functions with the datatype, then it works fine
03:25:49 <koeien37> yes
03:25:58 <mreh> import FooBarLib (Foo(Foo,bar))
03:26:09 <mreh> :D
03:26:24 <mreh> i wonder how it does that
03:27:03 <mreh> i would have hated to work on record syntax, as nice as it is, I can't imagine it's implementation is elegant
03:27:18 <koeien37> in your example, you can also use "Foo 37"
03:29:11 <mreh> HenningTheilman's documentation links to datatypes called T in *other libraries* that he wrote
03:29:19 <mreh> the pain of it all!
03:29:45 <HaskellLove> is erlang better suited for some tasks then Haskell? concurency? Can Haskell keep up there?
03:30:21 <ivanm> erlang is probably better for distributed concurrency atm, as well as soft restarts/dynamic replacement of running code
03:31:00 <Saizan_> though there's a lib to make erlang nodes in haskell
03:31:02 <ivanm> basically, erlang is better than haskell for telephone switches...
03:31:04 <ivanm> strange that! ;-)
03:31:25 * hackagebot upload: graphviz 2999.8.0.0 - Graphviz bindings for Haskell. (IvanMiljenovic)
03:33:54 <ivanm> bugger, I just realised there was something else I was quickly going to add to that release...
03:33:58 <ivanm> oh well, it's not that important
03:35:25 <copumpkin> just upload it again
03:36:05 <ivanm> nah, it's nothing featurewise
03:36:19 <ivanm> it's just to use the new eof parser from polyparse 1.4 rather than basically doing similar stuff by hand
03:36:38 <Heffalump> there's rather more to erlang than just telephone switches :-)
03:36:44 <ivanm> besides, it took long enough to upload (and ended up resulting in a "500 Internal Sever Error" :@ )
03:37:01 <ivanm> Heffalump: I just said that it's better than haskell for telephone switches!
03:37:14 <ivanm> erlang's biggest problem IMHO is its syntax
03:37:35 <Saizan_> what's a good resource to learn erlang/know what's good in it?
03:37:49 <ivanm> Armstrong's book is apparently one of the best ones
03:37:53 <ivanm> *better
03:40:41 <Peaker> As I understand it: Erlang is basically a bunch of forkIO'd threads (in a hierarchy, such that when one dies, the child gets a termination message) with each thread having a queue/channel it reads from.  I'm not exactly sure about how messages are sent though (if its supposed to be functional within each such thread)
03:41:32 <knobo> I need som help with Reader Monad http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15020#a15020
03:41:46 <Peaker> oh, and these threads can be auto-migrated across machines/etc
03:42:51 <Peaker> knobo: expand >>= next
03:42:52 <Lemmih> knobo: What's the problem?
03:43:39 <knobo> Basicly I'm playing the human haskell interpreter, and I'm trying to take "(runReader $ (Reader (\e -> 'a') >>= (return . succ))) Nothing" in to the next "expansion". And I have problem with understanding Reader $ \e -> f (r e) e
03:44:14 <Peaker> knobo: "Reader $ \e -> f (r e) e" is simply Reader (\e -> f (r e) e)
03:45:09 <Peaker> knobo: ($) is function application, with very low precedence, such that   blah ... $ bleh ...    where only higher-precedence operators appear in the ... on each side, is equivalent to:   (blah ...) $ (bleh ...)  so ($) is mainly used as a "trick" to avoid parenthesis
03:45:47 <knobo> "(runReader $ (Reader $ \e ->  (return . succ) ((\e -> 'a') e) e )) Nothing" is right.
03:45:54 <Peaker> I'm actually not sure myself why:   blah \x -> x    fails to parse, while   blah $ \x -> x   does parse
03:46:31 <dolio> it's just the rules.
03:47:05 <mreh> can I implement Show for a type myself?
03:47:07 <dolio> I don't think there's a particularly good reason for it. Agda lets you write those, for instance.
03:47:10 <mreh> rather than derive it?
03:47:46 <Peaker> mreh: sure
03:48:19 <Peaker> dolio: so the syntax allowed for function application args is different from that of binary operators, that's weird
03:48:39 <mreh> Peaker: is Show meant just for human readable output, do you have to define other classes if you're wanting to make it into other String formats
03:49:11 <mreh> the context is of converting datatypes into program source code
03:49:17 <Peaker> mreh: I don't think there's a wide concensus about it -- but there is a general tendency to have   read . show = id   and to make the Show'n value look like the Haskell syntax
03:49:18 <mreh> a little like a pretty printer
03:49:30 <Peaker> Its sometimes violated - but indeed IMO when its violated it should actually be a different class
03:50:21 <mreh> Peaker: thx
03:50:34 <dolio> Peaker: The only thing I can think of is that "g if b then t else f" is a little confusing.
03:51:11 <knobo> Now I did something wrong (with this reader monad expansion). What? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15020#a15021
03:51:52 <ivanm> preflex: seen bos
03:51:53 <preflex>  bos was last seen on #haskell 5 hours, 39 minutes and 17 seconds ago, saying: the tendency on hackage is to go for numerous small packages, so fair enough
03:52:54 <Peaker> dolio: well "if" syntax sucks anyway :)
03:53:22 <nainaide> Now talking on #haskell
03:54:07 <knobo>     Couldn't match expected type `t -> a' against inferred type `Reader r a1'  In the expression: (Reader $ \ e -> (succ x))
03:54:07 <knobo>  
03:54:30 <Peaker> knobo: I wouldn't expand the (.)
03:54:44 <knobo> (runReader $ (Reader $ \e ->  (\x -> return (succ x)) ((\e -> 'a') e) e )) Nothing
03:54:47 <knobo> oops
03:54:48 <knobo> sorry
03:54:51 <Peaker> knobo: at least not before applying the calls possible (I forget if that's beta reduction or what)
03:55:54 <mreh> :t replicate
03:55:55 <lambdabot> forall a. Int -> a -> [a]
03:55:56 <knobo> but to expand the return statment, I must do it?
03:55:58 <Peaker> knobo: (runReader $ (Reader $ \e ->  (return . succ) ((\e -> 'a') e) e )) Nothing -- you have name shadowing here - it may be confusing, rename the inner \e.  And beta-reduce
03:56:04 <Lemmih> knobo: Be caseful of the 'r ->' Reader instance.
03:56:08 <mreh> > replicate 3 ' '
03:56:09 <lambdabot>   "   "
03:57:44 <knobo> Lemmih: what do you mean?
03:58:52 <knobo> Peaker: I think the name shadowing thing is ok. (I can handle it)
03:58:53 <Lemmih> knobo: The code on line 11 is wrong.
03:59:23 <knobo> Lemmih: that's what I though. But I'm not able to figure it out.
03:59:26 <mreh> > let foo = 1 in foo : bar where bar = []
03:59:27 <lambdabot>   <no location info>: parse error on input `where'
04:00:49 <koeien37> ... where ... is not an expression
04:00:50 <knobo> Lemmih: but it gives the right result in the repl ( do you call it repl in ghci?)
04:00:55 <Peaker> Lemmih: I don't think line 11 is wrong
04:00:58 <mreh> @faq does Haskell let me have my cake and eat it?
04:00:58 <lambdabot> The answer is: Yes! Haskell can do that.
04:01:32 <Peaker> knobo: if you have: (\e -> 'a') e -- you can already expand that to 'a'
04:02:09 <Lemmih> Peaker: It is.
04:02:51 <Lemmih> knobo: Also, your Monad definition is wrong.
04:02:59 <Lemmih> knobo: Which is the base of your problem.
04:03:13 <Peaker> Lemmih: ah, I did the same expansion based on the monad definition
04:03:16 <knobo> Lemmih: it's from here: http://www.haskell.org/all_about_monads/html/readermonad.html
04:03:38 <Peaker> Lemmih: what's wrong about it?
04:04:24 <Lemmih> Peaker: It should be: Reader r >>= f = Reader $ \e -> runReader (f (r e)) e
04:04:39 <Peaker> oh, right, missing a runReader there
04:04:55 <Peaker> indeed, http://www.haskell.org/all_about_monads/html/readermonad.html seems wrong
04:05:09 <Lemmih> Or even better: r >>= f = Reader $ \e -> runReader (f $ runReader r e) e
04:05:17 <knobo> aha, let me write an email to jeff
04:06:40 <Peaker> Or maybe:  (Reader r) >>= f = Reader $ \e -> let Reader s = f (r e) in s e
04:07:32 <Lemmih> Pattern matching can be annoying when you're manually expanding definitions.
04:15:26 <Peaker> I think if Haskell syntax was a bit more lenient on when you're allowed to use "=" (let .. in .. implicitly scoping as wide as possible) -- that could be less annoying
04:16:05 <Peaker> Maybe something like:  "Reader r >>= f = Reader \e -> Reader s = f (r e) ; s e" with the "let" being implicit there, from the use of "="
04:16:17 <Peaker> though maybe not :)
04:22:20 <zong_sharo> i've got a symbol lookup error _after_ main
04:22:30 <knobo> Still something worng (reader monad) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15020#a15022
04:22:47 <zong_sharo> i suppose, it's happens because my mmap calls clashes with intertal runtime system machinery
04:23:17 <zong_sharo> is there any docs i can read about such things?
04:23:43 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15023#a15023 <- code with mmap
04:35:48 <Peaker> knobo: if you use "runReader" on the rhs of >>=  then you dont need to also pattern match on the lhs
04:36:07 <Peaker> knobo: (\r -> runReader r) == (\Reader r -> r)
04:36:57 <edwardk> peaker: that implicit let syntax makes even me shudder ;)
04:37:28 <Peaker> edwardk: I remember it bothered me a lot that I had to use "let .. in" when I started out with Haskell, but now it doesn't much (esp. since I usually use "where")
04:37:49 <Peaker> knobo: Also, remove the wrong >>= definition :)
04:38:12 <edwardk> peaker: yeah, i do sometimes wish i could just make a lambda-scoped where-clause-like definition
04:38:26 <edwardk> then i could get rid of all my lets ;)
04:40:11 <koeien37> if your anonymous functions are this complicated, it's better to make a named definition imho
04:42:45 <crashedjelly> are there any efforts made for String -> (a -> b)?
04:43:26 <crashedjelly> or ByteArray -> (a -> b)
04:43:36 <crashedjelly> I suspect solutions would be either platform dependent or depend on compilers?
04:43:47 <Baughn> crashedjelly: The GHC API would work fine
04:44:07 <crashedjelly> Baughn: but that means you have to include a whole lot of GHC in a small project :(
04:44:42 <Baughn> crashedjelly: Nah. Use dynamic linking.
04:44:51 <augur> oi!
04:44:53 <augur> haskelliers!
04:45:06 <crashedjelly> Baughn: still needs GHC on the target machine
04:45:09 <augur> how does haskell know (1 + 2) is 3 not a 1-tuple with 3 in it
04:45:10 <edwardk> crashedjelly: wouldn't String -> a be better?
04:45:24 <maltem> crashedjelly, you're asking for a Haskell interpreter, basically, so ...
04:45:25 <Peaker> knobo: I pasted the full expansion there
04:45:40 <edwardk> augur: 1-tuples don't exist ;)
04:45:40 <crashedjelly> edwardk: yeah, but I thought the more specific case would more obviously say what I want 8)
04:45:46 <augur> oh i see
04:45:50 <augur> just 0-tuples and 2+ tuples!
04:46:09 <crashedjelly> maltem: not necessarily. maybe it's machine code
04:46:17 <Peaker> You could say 1-tuples exist, they are just implicit or something :)
04:46:21 <Baughn> crashedjelly: That's a cost I'm willing to pay. GHC isn't that large, when you only need one copy on the machine.
04:46:26 <edwardk> data Augur a = Augur a -- there you have a 1-tuple ;)
04:46:29 <Peaker> philosophically exist :)
04:46:35 <Baughn> Peaker: Nah. Hackage://onetuple. ;)
04:46:36 <augur> D:
04:46:42 <crashedjelly> Baughn: but I don't necessarily need the String/ByteArray to be haskell
04:46:42 <edwardk> peaker: nah, you need an actual box
04:46:45 <crashedjelly> in fact what I need is:
04:46:55 <edwardk> peaker: coz of the extra bottom
04:47:04 <Peaker> oh.. Screw bottoms :)
04:47:05 <Baughn> crashedjelly: Oh, and it's ByteString.
04:47:09 <Peaker> I want unlifted type products
04:47:28 <Peaker> Why would anyone want an extra bottom-able box?
04:48:02 <crashedjelly> a function f : a -> ByteString and a function g : ByteString -> a where g is the inverse of f
04:48:11 <maltem> data Pair a b = Pair {-# UNPACK#-} !a {-# UNPACK #-} !b
04:48:23 <EvilTerran> crashedjelly, sounds like Data.Binary, perhaps?
04:48:35 <Baughn> Data.Cereal
04:48:39 <koeien37> yes, but functions don't have a Binary instance
04:48:39 <crashedjelly> so platform dependently it would be okay to read in machine code
04:48:52 <crashedjelly> EvilTerran: I specifically need it for functions
04:48:59 <Baughn> crashedjelly: Wait, you.. ah.
04:49:05 <EvilTerran> uh... ok, never mind
04:49:16 <Baughn> crashedjelly: There are severe problems with doing that, at all.. what happens if you read it back into a different process?
04:49:17 <maltem> oh, this is about serialization of functions. I didn't realize
04:49:18 <koeien37> this is probably why the JVM is cool :)
04:49:31 <koeien37> this kind of magic
04:49:35 <crashedjelly> maltem: that's why I preferred String -> (a -> b) above %)
04:49:45 <crashedjelly> koeien37: yep, exactly what I thought, too
04:49:55 <edwardk> peaker: i use that extra bottom box to represent improving integers occasionally
04:50:03 <Peaker> Having a portable binary representation of code (functions, types, etc) that allows serializing/deserializing+type-checking at runtime, would be nice
04:50:07 <edwardk> peaker: er improving naturals
04:50:09 <koeien37> java *the language* is awful imo, but the platform is interesting/useful
04:50:11 <crashedjelly> Peaker: exactly!
04:50:31 <koeien37> Peaker: yes :)
04:50:36 <Peaker> edwardk: The Integer is already boxed, why isn't that enough?
04:51:01 <edwardk> Peaker: consider constructs like Free and Cofree, they apply nicely to that box type
04:51:08 <crashedjelly> it arised from thinking about how to model a game whose elements may be so complicated that I'd really prefer to just model it with functions instead of own modelling languages
04:51:22 <crashedjelly> a Haskell DSL instead
04:51:24 <Peaker> edwardk: I don't know those constructs..
04:51:31 <edwardk> data Free f a = Return a | Roll (f (Free f a))
04:51:39 <edwardk> consider that with data Box a = Box a
04:51:43 <koeien37> if your functions are "large", you could just model it with an executable that talks to your process.
04:51:50 <koeien37> the overhead would kill you for small functions though
04:52:06 <Peaker> edwardk: How do you express that with Mu, btw?
04:52:10 <crashedjelly> koeien37: no, not like that, most of the time the functions are very simple, but more complicated stuff may arise.
04:52:14 <edwardk> data Cofree f a = Cofree a (f (Cofree f a))
04:52:27 <Peaker> @src Mu
04:52:27 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
04:52:31 <crashedjelly> it should be really simple and beautiful with a little monad, as long as you don't want to dynamically load other elements
04:52:45 <edwardk> peaker: you can do it, its just a pain in my arse. i tend to view then as alternate ways to tie the fix point than mu. ;)
04:53:08 <koeien37> also, if you have typed functions, you might want to trust a function a -> b, if b is not some IO type
04:53:08 <edwardk> they roll it up slightly differently, Free leaves you placeholder 'a's you can expand out monadically
04:53:11 <Peaker> edwardk: ah, ok, I am just trying to get to the bottom of it, I don't understand how you use it yet :)
04:53:18 <koeien37> modulo unsafePerformIO of course
04:53:24 <crashedjelly> as long as all game elements are part of the original code, no problem. and if I ever really do that project, it'll be probably be like that at first, but it got me thinking
04:53:34 <edwardk> Cofree leaves you extra a's decorating each recursive layer you can redecorate comonadically.
04:53:46 <Jafet> jelly, this sort of stuff is cooked, baked, fried and double-boiled in lisp
04:53:49 <koeien37> yeah. the "haskell way" is to make some DSL then and convert it to a function
04:53:49 <Jafet> Just a note.
04:53:56 <crashedjelly> seems like the only really appealing option is to ditch the function types for the game elements in favor of a small interpreted game modeling language
04:54:03 <koeien37> Jafet: yeah :) the main reason why lisp is cool imo
04:54:10 <crashedjelly> Jafet: I know! first things I thought of: Lisp, JVM %)
04:54:23 <malosh> Hi. I have to parse a file like, say, a list of (NAME = some value), and fill a record type with that. The record has many fields, in fact too many to make it reasonable to reallocate and copy one for each new variable.
04:54:26 <Jafet> Lisp isn't bad. Maybe you could make Lisp your DSL.
04:54:32 <malosh> Any idea (ST monad) ?
04:54:37 <Peaker> edwardk: I understand best from examples -- got any code you can paste?
04:54:40 <Jafet> With an FFI to chicken or whatever
04:54:40 <edwardk> Peaker: compare data Cofree f a = Cofree a (f (Cofree f a)) with data Mu f = Mu (f (Mu f)) -- the only difference is the extra 'a' in each wrapped up layer
04:54:45 <crashedjelly> Jafet: hmm. maybe. it's definitely something to consider.
04:54:47 <fft> Hi. Does anyone use emacs haskell mode for editing ?
04:54:51 <edwardk> Peaker: i have a blog post that used the cofree comonad by a different name
04:54:57 <endojelly> Jafet: but I don't know if that wouldn't be total overkill, too
04:55:01 <Peaker> edwardk: sure
04:55:06 <koeien37> fft: yes, lots of people. (not me, though.)
04:55:08 <endojelly> fft: I do
04:55:13 <Jafet> Lisp is overkill, and that's a good thing.
04:55:19 <edwardk> Peaker: http://comonad.com/reader/2009/incremental-folds/
04:55:29 <edwardk> Peaker the (:>) constructor is Cofree above.
04:55:42 <endojelly> but... well, I guess I will do the following:
04:55:50 <Peaker> Jafet: I dislike the Lisp notion of language extensions via syntactic overloading/processing - I like better semantic overloading (even if it is less powerful)
04:56:08 <edwardk> Peaker: basically the post is about how to use 'Cofree' to compute an incremental fold of a data structure.
04:56:28 <endojelly> I'll first just use my function types to do everything. later on, when (if 8) ) I have a lot of game elements, I can look through them to see how powerful of a language they need and implement it as a game modeling language
04:56:29 <Jafet> I'm just recommending Lisp because Lisp environments are much more suited to jelly's problem
04:56:30 <edwardk> i.e. taking a list and annotating each node with their length, or some other algebra of the list functor
04:56:45 <koeien37> malosh: what do you want to do with the data?
04:57:14 <fft> endojelly: I have a problem : some symbols (like lambda and equal) are displayed correctly, but other ( like not equal and function composition) are displayed as weird squares. Do you know how to solve this ?
04:57:36 <malosh> koeien37 : it is a postscript type 1 font file. I'd like to get bezier curves of the glyphs.
04:57:37 <koeien37> switch to a font that has these glyphs?
04:57:42 <endojelly> fft: maybe you just need to install some more unicode fonts. what platform are you on?
04:57:56 <fft> endojelly: windows
04:58:08 <endojelly> koeien37: it's not as easy as that anymore. nowadays, you don't really have specific fonts but fontsets. the reason is that with unicode, you don't *want* a font which contains all glyphs
04:58:12 <endojelly> instead you have several
04:58:27 <koeien37> ic
04:58:27 <endojelly> fft: then I really don't know how to deal with it, but installing some math unicode fonts might really work
04:58:50 <Jafet> Not that Windows knows a terrible lot about Unicode, especially it's sad attempt at a terminal
04:59:15 <endojelly> koeien37, fft: but usually the system does a pretty good job to find the required fonts for different unicode codepoints. the problems only arise when you want to use other fonts for certain glyphs
04:59:29 <koeien37> the few times I've had to send some unicode to a windows user, it Just Worked (vista or 7)
04:59:40 <fft> endojelly: thank you. I'll try
04:59:40 <koeien37> that consisted of asian characters though
04:59:43 <malosh> endojelly : it is even funnier than that : in opentype for instance you can have in the same file different fontsets sharing overlapping subsets of unicode ;-) Thanks, adobe !
05:00:01 <endojelly> I use agda for my project thesis and... well, let's say many many hours have been wasted to get some of the symbols displayed in a manner that doesn't suck visually %)
05:00:25 <endojelly> malosh: oh wow, I didn't know that, that's even worse yes %)
05:01:03 <nominolo> @pl \f g s -> c (f s) (g s)
05:01:03 <lambdabot> liftM2 c
05:02:41 <koeien37> malosh: I still don't get your problem. The file is too large to fit in memory?
05:02:54 <koeien37> because you have to copy too much data in your data structure?
05:02:57 <nominolo> @seen edwardk
05:02:57 <lambdabot> Unknown command, try @list
05:03:04 <nominolo> preflex: seen edwardk
05:03:05 <edwardk> yo
05:03:05 <preflex>  edwardk was last seen on #haskell 0 seconds ago, saying: yo
05:03:08 <edwardk> =)
05:03:31 <edwardk> whats up?
05:03:37 <nominolo> edwardk: hi there.  You posted a message on @cafe a while ago about Haskell + JIT compilation
05:03:52 <edwardk> nominolo: yeah, based on some of the stuff i've been doing with kata
05:03:56 <nominolo> what exactly did you want to do?
05:04:00 <malosh> koeien37 : no, but modifying a record with rec { field=a } reallocates it all then time and I don't want that. Since I'm already in the ST monad, a good solution would be a runSomething
05:04:25 <koeien37> if you're already in ST, you can change it into an STRef
05:04:32 <edwardk> nominolo: are you familiar with tracemonkey?
05:04:37 <nominolo> edwardk: yup
05:04:51 <malosh> koeien37 : it'd still be allocated and garbage-collected at each mutation
05:05:17 <edwardk> nominolo: i argue this: tracing fixes the intrinsic costs of the spineless tagless g-machine: all those blind jumps
05:05:26 <koeien37> not if you modify the STRef.
05:05:39 <koeien37> i.e. field :: IORef YourType
05:05:50 <koeien37> ehm, STRef
05:06:07 <edwardk> nominolo: to make that make more sense requires a lot of context. hop over to #kata, or i'll flood the channel here ;)
05:06:19 <nominolo> ok.
05:06:19 <koeien37> or haskell-in-depth :)
05:17:46 <Axman6> oh wow, Clang can now build both itself, and LLVM :O
05:18:08 <Jonno_FTW> how can i make this work? map $ read show 123 :: [Int]
05:18:16 <Jonno_FTW> i want [1,2,3] as the result
05:18:27 <Botje> map read $ show 123
05:18:29 <Axman6> though... the clang compiled is broken
05:18:43 <Botje> although that's not quite correct either.
05:18:44 <Jonno_FTW> > map read $ show 123
05:18:45 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:18:45 <lambdabot>         against inferred ty...
05:18:52 <Botje> map (read . (:[])) $ show 123
05:18:58 <Botje> or map (read . return) $ show 123
05:19:02 <copumpkin> read . pure
05:19:10 <Botje> there's also a digitToInt you can use
05:19:19 <Jonno_FTW> @src digitToInt
05:19:19 <lambdabot> Source not found. I am sorry.
05:19:30 <Jonno_FTW> *gasp^
05:19:44 <Jonno_FTW> :t digitToInt
05:19:45 <lambdabot> Char -> Int
05:20:10 <Jonno_FTW> > map (read . pure) $ show 123
05:20:11 <lambdabot>   [* Exception: Prelude.read: no parse
05:20:22 <Jonno_FTW> > map (read . return) $ show 123
05:20:22 <lambdabot>   [* Exception: Prelude.read: no parse
05:21:59 <Jonno_FTW> > map digitToInt $ show 123
05:22:00 <lambdabot>   [1,2,3]
05:23:11 <u_quark> Hello.
05:23:22 <Jonno_FTW> hello
05:24:21 <u_quark> Is anyone affiliated with gitit here ?
05:25:04 <Lycurgus> is git a haskell app?
05:25:09 <Axman6> no
05:25:24 <u_quark> Merry Christmas btw :)
05:25:27 <Axman6> u_quark: i think gwern or someone wrote it. i could be wrong
05:25:28 <Lycurgus> or "gitit" for that matter?
05:25:37 <Axman6> gitit is a haskell app
05:25:41 <u_quark> gitit is a haskell app
05:25:43 <Lycurgus> ah
05:25:45 <Axman6> a git/darcs based wiki
05:26:06 <u_quark> and in the last version hg back-end also
05:26:12 <Lycurgus> superceding tailor?
05:26:39 <u_quark> gwern: ^
05:27:58 <u_quark> @seen gwern
05:27:58 <lambdabot> Unknown command, try @list
05:28:18 <Lycurgus> (doesn't look like tailor is maintained)
05:28:26 <Saizan_> preflex: seen gwern
05:28:26 <preflex>  gwern was last seen on #xmonad 10 hours, 18 minutes and 15 seconds ago, saying: killWindow
05:28:43 <u_quark> tnx
05:28:47 <Saizan_> wasn't tailor a program to convert repos between dvcses?
05:30:43 <Lycurgus> yes, it's on the darcs wiki
05:31:30 <Axman6> that's not what gitit is
05:36:21 <mistermattaway> I can't stop watching Entourage; somebody help me
05:38:32 <Lycurgus> hackage is super slow or the google link for getit is going to fail
05:39:00 <Lycurgus> super slow
05:39:49 <Lycurgus> yes, I see, similar but not the same.
05:41:15 <Lycurgus> *gitit
05:41:16 <Jonno_FTW> what does fromInteger actually do?
05:41:21 <Jonno_FTW> @src fromInteger
05:41:21 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:41:39 <mistermattaway> haha yes!
05:41:40 <koeien> it's a class function. It depends on the type
05:41:50 <EvilTerran> ?type fromInteger
05:41:51 <lambdabot> forall a. (Num a) => Integer -> a
05:42:13 * hackagebot upload: haskell-src-exts 1.4.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
05:42:15 * hackagebot upload: hsx 0.6.0 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code. (NiklasBroberg)
05:42:18 <koeien> every instance of the Num typeclass has a different implementation
05:42:22 <EvilTerran> "class Num a where { ...; fromInteger :: Integer -> a; ... }"
05:42:52 <koeien> for Integer, it's id. For my own matrix type, it's n * identity matrix
05:43:08 <koeien> for a finite field mod p, it's "mod p"
05:43:10 <koeien> etc.
05:45:50 <koeien> but fromInteger is also used for integer literals
05:46:08 <koeien> if you see "1" in a Haskell program, it actually means "fromInteger 1"
05:47:07 <CalJohn> :t (+1) . (2,3,4)
05:47:08 <lambdabot> forall a t t1. (Num a, Num t, Num t1, Functor ((,,) t t1)) => (t, t1, a)
05:47:36 <koeien> Cale has overloaded .
05:47:42 <koeien> on lambdabot
05:48:06 <koeien> :t (.)
05:48:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:49:18 <EvilTerran> (+1) . (2,3,4) wouldn't be well-typed with the standard prelude (.) in scope
05:49:31 <koeien> right. (2,3,4) is not a function
05:49:36 <EvilTerran> ?type (+1) Prelude.. (2,3,4)
05:49:37 <lambdabot>     Couldn't match expected type `a -> b'
05:49:37 <lambdabot>            against inferred type `(t, t1, t2)'
05:49:37 <lambdabot>     In the second argument of `(GHC.Base..)', namely `(2, 3, 4)'
05:50:30 <CalJohn> koeien: yeah, i know
05:54:34 <CalJohn> I'm confused about something else.  I'm trying to use C.M.Instances to use a 4-tuple as a functor, but I can't get it to typecheck
05:54:43 <CalJohn> > (+1) . (2,3,4,5)
05:54:44 <lambdabot>   No instance for (GHC.Base.Functor ((,,,) t t1 t2))
05:54:44 <lambdabot>    arising from a use of...
05:54:55 <CalJohn> > (+1) . (2,3,4)
05:54:56 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t t1))
05:54:56 <lambdabot>    arising from a use of `L....
05:55:09 <CalJohn> huh
05:55:11 <CalJohn> :t (+1) . (2,3,4)
05:55:12 <lambdabot> forall a t t1. (Num a, Num t, Num t1, Functor ((,,) t t1)) => (t, t1, a)
05:55:28 <CalJohn> > (+1) . (2,3)
05:55:29 <lambdabot>   (2,4)
05:55:50 <CalJohn> Am I right in saying that there is no instance for anything greater than 2-tuples?
05:55:51 <koeien> why would (,,) be a functor? its kind is wrong
05:56:10 <CalJohn> mmm, perhaps I am confused
05:56:19 <koeien> (,) a might be a functor. (,,) a b might be, too
05:57:29 <CalJohn> oh hold on, i was wildly confused
05:58:22 <Axman6> i don't see why (,,) has the wrong kind to be a functor
05:59:35 <koeien> (,,) has kind * -> * -> * -> *
06:00:48 <EvilTerran> CalJohn, "(,,) a b" could be a functor, but it'd only be functorial in its last item
06:01:06 <EvilTerran> > fmap Just ((1,2),3) -- it'd work analogously to this
06:01:07 <lambdabot>   ((1,2),Just 3)
06:01:52 <EvilTerran> CalJohn, maybe something like "newtype Triple a = Triple (a,a,a)" would do what you wanted?
06:02:06 <koeien> you could turn that into a functor, yeah
06:03:00 <koeien> > ((+1) *** (+1)) (2,3)
06:03:01 <lambdabot>   (3,4)
06:03:07 <koeien> > join (***) (2,3)
06:03:09 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
06:03:09 <lambdabot>    arising from a use of `Control...
06:03:12 <koeien> > join (***) (+1) (2,3)
06:03:13 <lambdabot>   (3,4)
06:06:40 <knobo> Peaker: thanx
06:18:24 <fft> endojelly: there were incorrect codes in the haskell-font-lock.el
06:19:34 <endojelly> fft: ah ok
06:23:41 <chrisdone> someone from here pasted a start of prolog to hpaste nearly a year ago
06:23:45 <chrisdone> are you here?
06:28:41 <pozic> chrisdone: you mean a prolog interpreter?
06:28:53 <pozic> chrisdone: those are pretty much trivial to implement, no?
06:29:25 <pozic> The trick is implementing something which is fast.
06:30:41 <chrisdone> not something I want to spend time on doing
06:32:09 <pozic> chrisdone: what do you want?
06:32:34 <increpare> pozic: http://darcs.haskell.org/nofib/real/prolog/Examples ?
06:33:03 <increpare> oops ignore that : P
06:33:33 <increpare> there's one on oleg's site (but I doubt it's a regular prolog interpreter)
06:33:44 <Saizan_> chrisdone: there's a prolog interpreter in the demos (or examples?) directory of hugs
06:34:02 <pozic> I really don't see why one would want to use some broken Haskell implementation of Prolog.
06:34:23 <pozic> If you want to embed Prolog, just use some widely used implementation.
06:35:09 <Twey> http://www.dreamincode.net/forums/showtopic21012.htm — he's everywhere!
06:35:19 <increpare> Twey:  heheh
06:35:46 <koeien37> is that who i think it is?
06:35:50 <Twey> Ayup
06:35:51 <chrisdone> pozic: well I don't really want Prolog, just a logic simple language
06:36:14 <Twey> I just joined some random forum I saw an advert for on Facebook, and he's already there doing his usual bit!
06:36:22 <pozic> chrisdone: ah, now, I understand exactly what you mean...
06:36:28 <Twey> Really, it's going a bit too far!
06:36:31 * increpare wonders why there isn't a swap function in prelude [ (a,b)->(b,a) ]
06:36:46 <pozic> increpare: you are number 50.
06:36:53 <koeien37> that seems to be an omission. Although, as usual, easily to define yourself :)
06:36:55 <increpare> pozic: : P
06:37:01 <napsy> Hello. Are there any good resources on socket programming using Haskell?
06:37:22 <Jafet> @pl (\(a,b) -> (b,a))
06:37:23 <lambdabot> uncurry (flip (,))
06:37:35 <Jafet> Expansion.
06:37:44 <koeien37> if you are acquinted with socket programming, Network.Socket isn't hard to use
06:37:45 <increpare> koeien37: yep yep.  It's just sort of funny : )    (already my miscellaneous utility functions/combinators file is the largest in my current project )
06:37:46 <pozic> Twey: heh
06:37:55 <pozic> Twey: is he spamming the whole Internet?
06:37:59 <Twey> He must be!
06:38:05 <koeien37> e-mail, forums
06:38:14 * increpare didn't know that (,) was an operator before
06:38:23 <Twey> increpare: It… kind of isn't
06:38:26 <koeien37> it's a constructor
06:38:31 <Twey> It's a bit magic
06:38:47 <koeien37> you can think of tuples as  data (,) a b = (,) a b
06:39:02 <luite> you can make it more 'operatory' by using {-#LANGUAGE TupleSections #-}
06:39:20 <Jafet> Syntactic magic
06:39:21 <increpare> luite: ooooh....
06:39:37 <Jafet> > (,) 1 2
06:39:38 <lambdabot>   (1,2)
06:39:40 <koeien37> > (3,) 4 -- is it enabled in Lambabot?
06:39:41 <lambdabot>   <no location info>: parse error on input `)'
06:39:46 <luite> with tuplesections, things like  map (,1) [1..10] will work
06:39:49 <pozic> They should implement all these extensions with the syntax of Template Haskell.
06:39:54 <increpare> hmm; that's a happy discovery - thanks : )
06:39:59 <pozic> Then the compiler can implement in any way they want.
06:40:07 <pozic> it in*
06:40:20 <Axman6> Twey: wow, that jdh post... god he's a douche. making it sound like he's just some newb wondering about the language. hasn't he written books about the damn thing?
06:40:30 <pozic> Then people can develop Template Haskell implementations of all these extensions.
06:40:42 <Twey> Axman6: His entire business is based on it
06:40:44 <pozic> So, people only need to implement Haskell 98 to make it work.
06:40:48 <chrisdone> Axman6: yes, John Harrop is a shameless marketeer. who knew?
06:40:58 <pozic> chrisdone: all of us?
06:41:00 <Axman6> he's such a dick about it though
06:41:46 <increpare> not this john harrop i take it ... http://www.johnharrop.co.uk/
06:41:47 <Axman6> F# does look kinda nice though
06:41:49 <pozic> If his libraries are so useful, he should just write a compiler to write bindings to just about every language known to man :)
06:41:55 <Axman6> damnit, it worked >_<
06:42:10 <pozic> F# is an OCaml rip-off.
06:42:23 <pozic> And it is not better.
06:42:29 <pozic> E.g. the module system is absent.
06:42:30 <Axman6> i think it's more haskell like, i could be wrong
06:42:30 <fft> What plugin do you use for compiling haskell programs in emacs ?
06:42:38 <Twey> increpare: Haha
06:42:48 <increpare> pozic: F# is an OCaml rip-off with the support of an excellent (if horribly buggy) IDE
06:42:50 <koeien37> Axman6: in what respect (not really familiar with F#, it just reminded me of ocaml)
06:43:00 <chrisdone> fft: haskell-mode does that
06:43:08 <pozic> increpare: I am not impressed with Visual Studio 2008.
06:43:18 <Axman6> well.... no idea, i thought i'd heard that haskell was a strong influence though
06:43:23 <pozic> increpare: you cannot just give it a file and expect the jump to definition stuff to work.
06:43:41 <increpare> increpare: it's better than 2005 (I hope!  We're upgrading at work next week...they parallellized the linker a bit for 2008, which should speed things up)
06:43:51 <pozic> increpare: they have silly concepts of "projects" and all that before some of the functionality works.
06:44:09 <koeien37> Axman6: i heard they had monads
06:44:30 <increpare> pozic: Right.  But in big businesses you're usually not creating projects on a regular basis.  You have lots of people working on each project.
06:44:32 <Axman6> everything has monads, just people don't know it
06:44:33 <pozic> increpare: the problem with MS tools is that you are dependent on one vendor.
06:44:43 <koeien37> Axman6: I know
06:44:55 <increpare> pozic: There're plenty of third-party add-ons, though, and a plug-in interface, so you're not *totally* dependent
06:44:58 <koeien37> Axman6: but afair they identify them (maybe not as such)
06:45:02 <increpare> pozic: but yeah, it's a bit gross.
06:45:07 <pozic> increpare: big businesses rarely create anything interesting.
06:45:24 <Axman6> i dunno, Sun has done some interesting stuff
06:45:27 <pozic> increpare: a company like BMW does something interesting.
06:45:42 <pozic> increpare: or the Tesla Roadster guys.
06:46:11 <Heffalump> Axman6/Twey: that post is actually dated from 2006
06:46:16 <pozic> There are of course more companies, but 99% of software development is relatively boring.
06:46:20 <increpare> pozic: one thing I found out, to my horrification, that I was completely unable to code in OO languages without autocomplete...I've tried to ween myself off it and back to using api documentation where it's reasonable
06:46:31 <Axman6> ah, could be from before he'd written any books
06:46:33 <fft> chrisdone: I made it load to my ghci, check with hlint. Can I automate compile to smth like  ghc --make filename.hs -o filename   ?
06:46:35 <Axman6> still, he's a dick
06:46:48 <pozic> increpare: in Haskell we can also use much better tools.
06:47:09 <increpare> pozic: You mean that we could if they existed, or they already exist?
06:47:17 <Heffalump> I think SPJ has a good point about the .
06:47:18 <pozic> increpare: in fact, it would be useful to have language support for various things.
06:47:30 <Heffalump> (see his Type Directed Name Resolution proposal)
06:47:34 <Twey> Heffalump: Ah, yes, that's true.
06:47:35 <increpare> Heffalump: what was his point about the . ?
06:47:45 <pozic> increpare: example: sometimes you want to select one value deep from a data structure.
06:47:51 * Twey hits cancel on the sarcastic reply.
06:47:57 <pozic> increpare: suppose there is only one field with a particular type.
06:48:12 <pozic> increpare: (but very deep)
06:48:17 <Heffalump> increpare: that being able to use the type of the receiver to disambiguate between names is very useful
06:48:41 <pozic> increpare: if you could just say (select dataStructure)::MyType, you would save lots of boiler plate code.
06:48:47 <increpare> pozic: well you can do that already with SYB
06:48:53 <increpare> pozic: almost, can't you?
06:49:01 <increpare> pozic: (or uniplate)
06:49:13 <pozic> increpare: I don't think that this particular example will work.
06:49:13 <chrisdone> fft: not sure about that
06:49:21 <pozic> increpare: SYB is not documented that well.
06:50:00 <fft> chrisdone: This was the meaning of my first question
06:50:24 <chrisdone> uhuh
06:50:30 <increpare> pozic: it's possible to get a list of all types of a particular type from a nested data structure easily enough actually - not sure how I'd do it in uniplate, though
06:51:04 * increpare found SYB actually okay to play with - there are a number of examples scattered about
06:51:29 <pozic> increpare: yes, listify.
06:51:45 <increpare> pozic: so why wouldn't that example work well?
06:51:45 <pozic> increpare: but I don't think it is efficient.
06:52:18 <pozic> increpare: what you want is that it compiles to the same code as the hand coded obvious solution.
06:52:31 <pozic> increpare: and it should not take hours to compile :)\
06:53:00 <increpare> pozic: fwiw, I've used uniplate/syb and didn't find that either took too long to compile (nothing compared to, say, boost::spirit )
06:53:10 <increpare> ( : P )
06:53:40 * increpare shakes his fist at ghc coping strategy with circular module dependencies 
06:53:48 <pozic> increpare: I only used syb, but looked at uniplate, but everything looking up the API takes longer than writing it directly.
06:54:04 <pozic> increpare: tools can help with those things.
06:54:39 <copumpkin> increpare: add your name to the bug full of people complaining about hs-boot
06:54:51 <increpare> pozic: ok.  I know that ndm did some work on speeding up uniplate a lot - I remembe reading some messages saying that it was markedly faster that SYB, but that they were maybe going to try to use a similar technique to speed up SYB
06:54:56 * hackagebot upload: haskell-src-exts 1.5.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
06:54:59 * hackagebot upload: hsx 0.6.1 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code. (NiklasBroberg)
06:55:02 <increpare> copumpkin: that's an idea!
06:55:35 <increpare> pozic: how do you think a tool would help (rather than template haskell, which seems like the ideal way to go about doign code-rewriting) ?
06:55:55 <Gianvacca> hello everybody!
06:56:14 <Gianvacca> is this the right place to ask for help with gtk2hs?
06:56:14 <pozic> increpare: first jump to definition will have to work; after that wilder ideas can be discussed.
06:56:36 <pozic> increpare: oh, and before that "show type of sub-function" has to work.
06:57:00 <gwern> Gianvacca: it's the least worst place on freenode, I think
06:57:01 <pozic> increpare: and finally, "load as much of the module without errors".
06:57:41 <increpare> pozic: why would any of these things have to work to enable queries on data-structures?
06:58:03 <increpare> (efficient queries)
06:58:34 * increpare thinks that leksah has jump to defintiion
06:58:38 <Twey> That's weird
06:58:46 <Twey> Why is there a (=<<) but no (<<)?
06:58:58 <pozic> increpare: leksah is vapourware, because cabal install leksah does not work.
06:59:06 <Gianvacca> gwern, could you help me for instance?
06:59:09 <gwern> @hoogle (<<)
06:59:09 <jmbers> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
06:59:09 <jmbers> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
06:59:09 <jmbers> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
06:59:10 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
06:59:10 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
06:59:10 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
06:59:15 <gwern> Gianvacca: not really
06:59:17 <mreh> :t suc
06:59:18 <lambdabot> Not in scope: `suc'
06:59:18 <jmbers> Not in scope: `suc'
06:59:21 <mreh> :t succ
06:59:22 <lambdabot> forall a. (Enum a) => a -> a
06:59:23 <jmbers> forall a. (Enum a) => a -> a
06:59:31 <pozic> increpare: or it is abandonware, or whatever you want to call it.
06:59:41 <copumpkin> can someone kill the duplicate bot?
06:59:57 <copumpkin> @where ops
06:59:57 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
06:59:58 <jmbers> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:00:02 <mreh> lol
07:00:15 <gwern> jmbers: @part
07:00:16 <jmbers> Not enough privileges
07:00:23 <increpare> pozic: yeah it seems that it hasn't been worked on since july - not too long ago, though
07:00:29 <gwern> drat. whoever runs jmbers gave it a different config :(
07:00:45 <copumpkin> I wonder whose it was
07:00:46 <increpare> pozic: I'm guessing that people in general weren't too interested in it - VS gives IDEs a bad reputation
07:01:19 <increpare> pozic: (and, at the same time, sets a very high bar for entry, as do emacs/vim)
07:01:52 <mreh> :t fix
07:01:52 <lambdabot> forall a. (a -> a) -> a
07:01:59 <mreh> @src fix
07:02:00 <lambdabot> fix f = let x = f x in x
07:02:40 <pozic> increpare: the Common Lisp people figured out what people want long ago.
07:02:46 <mreh> how do I get the Nth pred of an Enum?
07:02:52 <pozic> increpare: just a process which implements IDE like functions.
07:03:11 <pozic> increpare: then you can connect to it via whatever program you want.
07:03:18 <mreh> @hoogle (a -> a) -> Int -> a
07:03:18 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
07:03:18 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
07:03:18 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
07:03:29 <increpare> pozic: what do you mean by 'process' here?
07:03:39 <koeien37> :t \n -> foldr (.) id . replicate n
07:03:40 <lambdabot> forall b. Int -> (b -> b) -> b -> b
07:03:51 <pozic> increpare: like Swank.
07:04:00 <pozic> increpare: in SLIME.
07:04:03 * increpare googles
07:04:41 <mreh> fold with function composition, brane hurts
07:04:44 <mreh> :t foldr
07:04:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:05:14 <koeien37> :t (foldr (.) id .) . replicate
07:05:15 <lambdabot> forall b. Int -> (b -> b) -> b -> b
07:05:28 <jjm> forall a. Int -> (a -> a) -> a -> a
07:05:54 <koeien37> @botsmack
07:05:54 <lunabot>  :o
07:05:54 <lambdabot> :)
07:06:02 <jjm> :)
07:06:04 <increpare> pozic: I can't find a description of what swank actually is online, except that it's some sort of server ...
07:06:10 <mreh> :@
07:06:22 <increpare> oh ok it's a server-based lisp environment
07:07:16 <Botje> it's a server that relays commands for a client
07:08:23 <mreh> > let pred n = foldr (.) id . replicate n pred in pred 3 5
07:08:23 <lambdabot>   Couldn't match expected type `[b -> b]'
07:08:24 <lambdabot>         against inferred type `GHC....
07:08:26 <jjm>   Could not find module `Data.Number.Symbolic':
07:08:26 <jjm>    Use -v to see a list of th...
07:08:31 <mreh> :t pred
07:08:32 <lambdabot> forall a. (Enum a) => a -> a
07:08:33 <jjm> forall a. (Enum a) => a -> a
07:08:45 <mreh> > let predN n = foldr (.) id . replicate n pred in pred 3 5
07:08:46 <lambdabot>   Couldn't match expected type `[b -> b]'
07:08:46 <lambdabot>         against inferred type `a ->...
07:08:50 <jjm>   Could not find module `Data.Number.Symbolic':
07:08:50 <jjm>    Use -v to see a list of th...
07:09:09 <mreh> is this another duplicate?
07:09:48 <mreh> :t replicate
07:09:49 <lambdabot> forall a. Int -> a -> [a]
07:09:52 <jjm> forall a. Int -> a -> [a]
07:10:14 <koeien37> > let applyN n = foldr (.) id . replicate n ; predN n = applyN n pred in pred 3 5
07:10:15 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
07:10:15 <lambdabot>    arising from the literal `3' at <...
07:10:18 <jjm>   Could not find module `Data.Number.Symbolic':
07:10:18 <jjm>    Use -v to see a list of th...
07:10:25 <koeien37> > let applyN n = foldr (.) id . replicate n ; predN n = applyN n pred in predN 3 5
07:10:26 <lambdabot>   2
07:10:29 <jjm>   Could not find module `Data.Number.Symbolic':
07:10:29 <jjm>    Use -v to see a list of th...
07:10:50 <koeien37> who is the owner of jjm? this is annoying
07:10:53 <koeien37> @where ops
07:10:54 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
07:10:54 <jjm> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:10:57 <copumpkin> bah
07:13:57 <mreh> how do you apply a function an arbitary number of timeds?
07:14:06 <mreh> oh, you just did it
07:14:49 <koeien37> yes, see applyN
07:15:28 <mreh> complico, always complicated prices
07:15:36 <copumpkin> :t (+)
07:15:37 <lambdabot> forall a. (Num a) => a -> a -> a
07:21:01 <mreh> > replicate 3 succ
07:21:02 <lambdabot>   [* Exception: Prelude.Enum.().succ: bad argument
07:21:29 <mreh> > replicate 3 succ :: Enum a => [a -> a]
07:21:30 <lambdabot>   [* Exception: Prelude.Enum.().succ: bad argument
07:21:40 <copumpkin> () is Enum
07:21:56 <mreh> GHC gives me the error: Ambiguous type variable `a' in the constraint: `Enum a'
07:22:32 <mreh> i thought the whole point of type classes were to be ambiguous :(
07:23:37 <koeien37> > read "37"
07:23:38 <lambdabot>   * Exception: Prelude.read: no parse
07:23:55 <koeien37> ghci complains here, too
07:24:01 <koeien37> \b does more defaulting
07:24:08 <koeien37> > read "37" :: Integer
07:24:08 <lambdabot>   37
07:30:39 <Axman6> > read "()"
07:30:40 <lambdabot>   ()
07:32:24 <mreh> heh
07:33:12 <HugoDaniel> hi
07:34:25 <Axman6> > read "((()))"
07:34:26 <lambdabot>   ()
07:34:48 * sizur feels welcomed and at home.
07:34:49 <Axman6> > read "(((((((((((((((((((())))))))))))))))))))"
07:34:50 <lambdabot>   ()
07:35:01 <endojelly> > read "("
07:35:02 <lambdabot>   * Exception: Prelude.read: no parse
07:35:06 <Twey> > read "( )"
07:35:07 <lambdabot>   ()
07:38:18 <sizur> > take 10 (unfoldr (\(a,b)->Just(a,(b,a+b))) (1,1)) -- mandatory stretching
07:38:19 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
07:38:39 <gaal> hi, what do I need to set so that ghci uses UTF-8 in prints by default?
07:39:06 <trofi> import System.IO.UTF8, maybe
07:39:13 <trofi> or use ghc-6.12
07:39:21 <gaal> trofi: that works for my code, but not for interactive evals
07:39:53 <trofi> for example?
07:40:19 <gaal> "some text with UTF-8 literals"
07:40:28 <gaal> *Main> "garbled"
07:40:30 <trofi> ah
07:41:20 <gaal> presumably it's doing Prelude.print on intermediates, I want it to do System.IO.UTF8.print :-)
07:41:37 <koeien37> > "牛“
07:41:38 <lambdabot>   <no location info>:
07:41:38 <lambdabot>      lexical error in string/character literal at end o...
07:41:40 <trofi> haskell is ambiguous in that respect, as String == [Char]
07:41:47 <koeien37> > text "牛"
07:41:48 <lambdabot>   牛
07:41:54 <gaal> heh
07:41:59 <koeien37> > "牛"
07:42:00 <trofi> and haskell shouce should be in utf-8 source, but literals are Chars
07:42:00 <lambdabot>   "\29275"
07:42:06 <kw317> is (forall a . a) -> (forall b . b) the same as (forall a . a) -> b? Can I always move forall from the rhs of an arrow?
07:42:34 <kw317> also, any intuition of what term of such type would be like?
07:42:47 <koeien37> yes, from the right part
07:43:42 <trofi> > text $ map toUpper "привет"
07:43:43 <lambdabot>   ПРИВЕТ
07:43:50 <luite> > take 10 $ fix (\r a b -> let c = a+b in b:r b c) 0 1 -- fixing your fibs
07:43:51 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
07:44:21 <koeien37> > text $ map toUpper "koeien zijn lief"
07:44:22 <lambdabot>   KOEIEN ZIJN LIEF
07:44:30 <gaal> text is not enough for me: I have some quickChecks that are failing, but the failing cases are printed with the wrong charset assumed
07:44:36 <luite> oh don't need the let at all
07:44:54 <luite> > take 10 $ fix (\r a b -> b:r b (a+b)) 0 1
07:44:55 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
07:48:51 <gaal> so, am I not suposed to use UTF-8 in string literals in my code?
07:49:25 <gaal> the manual isn't very explicit about this.
07:50:09 <sizur> luite: nice, but fix breaks my brain ;) whereas unfoldr folds everything neatly in its place.
07:50:31 <youngbull> hey, Im having some problem installing the cabal package happy.. anyone have any experience with that? it says that it fails doing ld ...
07:51:20 <Saizan_> youngbull: what's the error more specifically?
07:51:27 <Botje> youngbull: could you post the error / output you get to hpaste? maybe someone will see it directly then
07:51:29 <luite> sizur: it's actually easier than it looks
07:51:32 <youngbull> collect2: ld returned 1 exit status
07:51:47 <Saizan_> youngbull: maybe you could run it with -vN for some n > 1 to get more details
07:51:59 <youngbull> sure
07:52:06 <kw317> is fn x : forall a . a -> x x : forall a . a -> forall b . b typeable in System F?
07:52:07 <luite> sizur: the type of fix is (a -> a) -> a, but a can be a function
07:52:14 <Saizan_> youngbull: paste the full output on hpaste.org
07:52:17 <Saizan_> @paste
07:52:18 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:54:32 <youngbull> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5588#a5588
07:55:14 <youngbull> oups
07:55:21 <youngbull> didnt get everything
07:55:34 <Saizan_> kw317: (\(x : forall a. a) -> (x x)) :: forall a. a -> forall b. b ?
07:55:51 <dolio> kw317: You just gave the type.
07:56:07 <luite> sizur: in this case, we have fix g::Int -> Int -> Int, where g r a b = b : r b (a+b), so a = (Int -> Int -> Int), and g::(Int -> Int -> Int) -> Int -> Int -> Int
07:56:13 <Saizan_> youngbull: ah, yeah, better to use pastebin.com if it's long, maybe
07:56:15 <kw317> Saizan_: yes, modulo type applications
07:56:27 <kw317> dolio: yeah, I'm wondering whether my typing is sound
07:56:36 <luite> sizur: you can also write that as g::(Int -> Int -> Int) -> (Int -> Int -> Int)
07:56:37 <kw317> and also if this term makes any sense whatsoever
07:56:50 <kw317> can't wrap my head around such types ;-)
07:57:19 <Saizan_> well, you shouldn't actually be able to write an argument to pass to it, in a closed context
07:57:38 <kw317> true
07:58:33 <dolio> @type (\(x :: forall a. a) -> x x) :: forall a. a -> forall b. b
07:58:34 <lambdabot>     Pattern signature must exactly match: a
07:58:34 <lambdabot>     In the pattern: x :: forall a. a
07:58:34 <lambdabot>     In the expression:
07:58:54 <Saizan_> (\(x : forall a. a) -> /\b -> x [unit -> b] (x [unit])) -- with type abstraction/application
07:59:04 <dolio> @type (\(x :: forall a. a) -> x x) :: (forall a. a) -> forall b. b
07:59:05 <lambdabot> forall b. (forall a. a) -> b
07:59:11 <Saizan_> (well, unit is arbitrary there..)
07:59:54 <sizur> luite: i dont fully understand fix as recursion abstraction
08:01:09 <Botje> fix basically passes the lambda to itself
08:01:09 <Saizan_> sizur: read this? http://www.vex.net/~trebla/haskell/fix.xhtml
08:01:19 <youngbull> well it didn't get any better but here is the full output.. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5589#a5589 still the only thing I can make of it is that ld returned 1...
08:01:59 <Saizan_> ah, the actual error is the multiple definitions one
08:02:14 <luite> sizur: fix f = f (fix f), let's look at a few examples: fix (1:) = 1:fix (1:) = 1:1:fix (1:) = 1:1:1:fix (1:) ....
08:02:28 <luite> sizur: so that generates an infinite list of ones
08:02:45 <luite> (just expanding the definition of fix)
08:03:03 <youngbull> Saizan_: oh... what should I do about it?
08:03:19 <Saizan_> youngbull: it seems it's linking in two versions of the directory package and the C linker is not happy about it
08:03:32 <sizur> luite: that's simple :)
08:03:44 <luite> sizur: it gets more interesting if the type you generate is a function instead of a value
08:03:58 <luite> let's say our function is
08:04:53 <luite> \r x -> if x==1 then 1 else x * r (x-1)
08:05:46 <luite> and we evaluate: fix (\r x -> if x==1 then 1 else x * r (x-1)) 1
08:06:07 <sizur> luite: that's already recursive. ok i'm excited to see the break down
08:07:14 <luite> hm, I'd better give that thing a name :p
08:07:19 <sizur> ah no, nvm, that's not recursive
08:08:17 <Saizan_> youngbull: maybe you should hide or unregister one of the versions of it
08:08:33 <Saizan_> youngbull: the error occurs when compiling the Setup.hs
08:08:58 <youngbull> Saizan_: yea I'm going to do that but I'm not really leet with cabal.. =D looking at the man now
08:09:20 <luite> sizur: hmm, one moment, this got more unwieldy than I was hoping, I'll upload something to hpaste
08:09:20 <sizur> (\r x -> if x==1 then 1 else x * r (x-1)) (fix (\r x -> if x==1 then 1 else x * r (x-1))) 1
08:09:41 <luite> oh that's ok too :p
08:09:42 <Saizan_> youngbull: ghc-pkg --help
08:10:22 <luite> sizur: so the whole fix is expanded in the first argument
08:10:58 <sizur> luite: but if' i'll feed the first argument into the function, i get back to where i started
08:12:29 <sizur> luite: and if i'll expand the first arg, then i can continue doing it forever
08:12:55 <luite> sizur: you don't, it's lazy, hang on, I'm doing a somewhat simpler example that consumes a list
08:16:38 <luite> sizur: a few examples: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=15026#a15026
08:16:53 <luite> sizur: I gave the function a name so it's easier to work with
08:17:30 <luite> sizur: this is just expanding the definition of fix each time. evaluation is lazy, so you don't 'unroll' it when you don't need it
08:17:51 <sizur> hpaste looks better than i remember it from a year ago :)
08:18:04 <luite> sizur: you can see that each time, you have an application of g on the outside. if that doesn't require its first argument, recursion will end there
08:18:31 <luite> sizur: the type of g here is (Integer -> Integer) -> (Integer -> Integer)
08:18:35 <luite> in sum'
08:19:29 <luite> (actually it's generic as I didn't add a type signature)
08:20:00 <sizur> hehe insteresting. i have a harder time understanding fix f = let x = f x in x than understanding fix f = f (fix f)
08:21:12 <b_jonas> @hoogle (Monad i, Monoid t) => [i t] -> i t
08:21:13 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
08:21:13 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
08:21:13 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
08:21:20 <luite> sizur: you can expand it again if you like: x = f x = f (f x) = f (f (f x), each time replacing x by its definition
08:21:50 <copumpkin_> :t fmap mconcat . sequence
08:21:51 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f, Monad f) => [f a] -> f a
08:22:04 <copumpkin_> b_jonas: ^
08:22:09 <b_jonas> copumpkin_: yes, that's it
08:22:11 <copumpkin_> :t liftM mconcat . sequence
08:22:12 <lambdabot> forall a (m :: * -> *). (Monoid a, Monad m) => [m a] -> m a
08:22:25 * copumpkin_ curses at haskell
08:24:22 <luite> sizur: oh I see that I forgot a lot of )))) in my example :)
08:26:12 <sizur> interesting how you can fix in haskell so easy but cannot y-combine
08:26:37 <sizur> and i'm always amazed by how helpful #haskell always was and is.
08:27:47 <sizur> luite: that example is very helpful
08:28:35 <companion_cube> is there a local program for hoogle, something that you can query by types without being connected ?
08:28:42 <copumpkin_> @hackage hoogle
08:28:42 <lambdabot> http://hackage.haskell.org/package/hoogle
08:28:58 <companion_cube> thanks :)
08:28:59 <chrisdone> copumpkin_: you take that back
08:29:14 <Twey> Hehe
08:29:35 <b_jonas> there's also a web for somewhere, and lambdabot answers private messages
08:29:42 <copumpkin_> :)
08:29:52 <Twey> There's also GOA, of course
08:30:06 <b_jonas> GOA?
08:30:10 <chrisdone> Now easier to install than ever!™
08:30:22 <chrisdone> http://chrisdone.blogspot.com/2009/12/ghci-on-acid.html
08:30:54 <chrisdone> that's out of date, though. all you need to do now is cabal install lamdabot, cabal install goa, celebrate
08:31:24 <b_jonas> chrisdone: thanks
08:31:37 <b_jonas> I'd rather prefer other extension commands to my ghci than those
08:31:48 <b_jonas> these are mostly stateless so I can just type them to irc
08:32:09 <b_jonas> and where they aren't stateless (like depending on which modules I load) the stateless version (with all modules preloaded) is more useful
08:32:39 <sizur> luite: it becomes harder and harder to comprehend when functions in questions have higher arity
08:33:01 <sizur> luite: i guess with practice it'll ease
08:33:57 <sizur> correction, it's not just arity, but the depth of "higher-orderness"
08:34:04 <luite> sizur: the 'hard' part of the function types is in the first argument
08:34:28 <luite> sizur: each function being fixed is of type (..something..) -> Easy -> Easy -> Easy
08:34:39 <sizur> hehe yeah
08:34:42 <luite> ususally Int -> Int -> Int
08:34:58 <luite> but fix::(a -> a) -> a
08:35:19 <luite> so in order to be compatible with fix, it needs to be (Easy -> Easy -> Easy) -> Easy -> Easy -> Easy
08:35:38 <luite> that's a lot of easy, and exactly the type of g...
08:35:39 <luite> :)
08:36:33 <increpare> would it be possible to hijack djinn as a template-haskell extension to try auto-contruct such combinators I wonder?
08:37:55 <b_jonas> yeah, someone did menion that if we have a djinn-like thing that derives code from the types, and haskell can also derive types, so you needn't write anything at all.
08:38:25 <increpare> b_jonas: : P
08:38:29 <luite> sizur: keep in mind that (b -> b) -> b -> b = (b -> b) -> (b -> b)
08:38:35 <b_jonas> main = djinn; -- and haskell derives the correct code
08:39:43 <increpare> b_jonas: that would be so handy if only every haskell program was just return ()   :P
08:40:29 <b_jonas> it needn't even be template haskell, just a very complicated typeclass thing
08:41:01 <b_jonas> djinn :: (Typeable a) => a;
08:41:08 <b_jonas> and it derives the code in runtime from the type
08:42:47 <sizur> luite: fun that takes B and returns B is applied to B and returns B is equivalent to function that takes B and returns B is function that takes B and returns B.
08:42:57 <sizur> luite: trying to break down why (b -> b) -> b -> b = (b -> b) -> (b -> b)
08:43:44 <sizur> luite: ok i missed the point that the whole expression is also a function
08:44:11 <luite> because a -> b -> c = a -> (b -> c), it's right associative
08:44:14 <gwern> oh the humanity of it all!
08:45:11 <luite> sizur: the parentheses are not necessary, I just added them to make it clear that the type of g is actually a -> a
08:45:22 <luite> but a is a function itself
08:45:29 <sizur> would it not be easier to stick more closely to curry and force all functions to be unary? hehe
08:46:00 <sizur> just talking to myself.
08:46:19 <luite> hmm, they are? or what do you mean?
08:46:45 <sizur> luite: thank you very much for trying to help me understand :)
08:47:55 <luite> np, if it's unclear, it often helps a lot to expand a few steps yourself
08:48:01 <sizur> well, when we write f a b we think that f takes two arguments, we are not thinking that actually f takes a and expands to a function that takes b.  or do guys here actually think naturally like that?
08:48:38 <luite> well, in haskell f a is a function that takes one argument, so yes
08:48:48 <b_jonas> it depends
08:48:59 <b_jonas> you somtimes think of one, sometimes of the other
08:49:20 <b_jonas> and you know they're equivalent so if you have a function of one kind, you can call it as a function of the other kind when that's convenient in code
08:49:34 <b_jonas> that's one thing that makes haskell code concise and sometimes hard to read
08:51:31 <Zao> I mostly think in partial application when defining functions that happen to have the same "tail" of arguments.
08:52:10 <Zao> In like f = (`elem` [42,3,5])
08:52:17 <Zao> @type (`elem` [42,3,5])
08:52:18 <lambdabot> forall a. (Num a) => a -> Bool
08:57:36 <sizur> luite: yeah expanding a few stems helps to understand what's going on.  but how about actually writing your functions using it.  or is it good only to define basic functions and be done, like one doesnt really write own monads since one can build what one needs with transformers from basic monads
08:58:04 <sizur> s/stems/steps/
08:59:21 <sizur> and why is fix in Control.Monad? :)
08:59:44 * koeien37 thought fix was in Data.Function
08:59:56 <copumpkin> it's in Control.Monad.Fix
09:00:02 <copumpkin> also in Data.Function
09:00:20 <sizur> Data.Function makes better sense
09:00:35 <dolio> It was originally in Control.Monad.Fix because it was related to mfix.
09:01:02 <sizur> it's very interesting to look back at how stuff is discovered
09:01:15 <koeien37> fix is as ancient as sliced bread
09:01:22 <dolio> mfix (return . f) = return (fix f) is a required identity, as I recall, and fix wasn't anywhere in the libraries at the time.
09:03:05 <b_jonas> it might not have been in the libraries but people certainly knew about fix, just like how the bool function or the Void type isn't in the libraries now
09:03:30 <sizur> bool function?
09:03:51 <koeien37> i'd guess bool t f b = if b then t else f ?
09:03:55 <koeien37> @src bool
09:03:55 <lambdabot> Source not found. stty: unknown mode: doofus
09:03:57 <b_jonas> yes, that bool
09:04:02 <b_jonas> some call it if'
09:04:12 <b_jonas> but if' reminds me to the ugly syntax of maple so I don't call it that
09:04:21 * Twey calls it (??)
09:04:24 <Botje> call it if++
09:04:47 <b_jonas> (okay, it's not ugly, but ugly compared to haskell. if' does not go well with the established haskell naming scheme.)
09:05:29 <sizur> how is it different from notmal if? in the order of arguments?
09:05:39 <benmachine> in it being a normal function
09:05:53 <benmachine> I wonder if there would be a market for an extension that disabled if-syntax
09:06:06 <sizur> i'd sign up for that
09:06:22 <Twey> Hear hear
09:06:22 <koeien37> i don't particularly miss the "if", "then" and "else" identifiers available
09:06:29 <b_jonas> nah, I want if syntax because I'm waiting for if with pattern guards in a future extensions
09:06:31 <Twey> Especially if it introduced ?? at the same time
09:06:47 <Twey> b_jonas: It's called ‘case’ ;)
09:07:30 <sizur> ok, next question, what is a Void type?
09:07:49 <copumpkin> an empty one
09:07:50 <Twey> A type with no constructors
09:07:52 <b_jonas> sizur: it's an algebraic data type with no data constructors.
09:07:53 <copumpkin> if you squint
09:07:54 <koeien37> a type without constructors
09:07:55 <sizur> and how it is different from "a" type
09:07:57 <b_jonas> data Void where {};
09:07:57 <Twey> It's only got bottom
09:08:05 <copumpkin> a -> b  has n constructors
09:08:07 <copumpkin> no
09:08:23 <koeien37> it also has only bottom
09:08:28 <monochrom> I want to keep if-then-else. I want an extension that lets you define your own multifix operators like if-then-else.
09:08:29 <copumpkin> well
09:08:32 <copumpkin> I mean function types in general
09:08:48 <koeien37> monochrom: i heard Agda has that
09:08:49 <b_jonas> sizur: in that it doesn't cause errors because a type variable can't be defaulted
09:09:13 <sizur> :t error
09:09:14 <lambdabot> forall a. [Char] -> a
09:09:32 <b_jonas> monochrom: like smalltalk?
09:09:46 <b_jonas> except without the colons?
09:09:57 <Twey> Like Lisp!
09:10:44 <increpare> monochrom: or like http://www.pi-programming.org/What.html : )
09:11:09 <Vulg141> g
09:11:21 <sizur> so if my program evaluates to Void, then i enter infinite loop? so hipothetically i could match on Void and get out of the infinite loop? lol prolly sound like a child talking.
09:11:36 <koeien37> you cannot match on Void, it is a type, not a data constructor
09:11:56 <monochrom> You can define your own initially-try-catch-finally operator.
09:11:56 <copumpkin> Void isn't really empty
09:12:08 <koeien37> if you evaluate a result of type Void, you will get an infinite loop (or an exception), yes
09:12:10 <copumpkin> it's just pretending to be empty
09:13:22 <sizur> ok, obviously it has nothing to do with c's void
09:13:37 <Twey> Well, no, they're the same thing
09:13:37 <koeien37> no, not really
09:13:48 <Twey> A type with no values
09:13:50 <koeien37> C's void is more like IO ()
09:13:53 <Twey> Same in C
09:14:02 <Twey> Apart from the impurity, of course
09:14:43 <monochrom> This is why I didn't answer all your "like ___ ?" queries. "like" is undefined.
09:14:57 <monochrom> Theorem. X is like Y.
09:15:02 <Vulg141> OLA
09:15:05 <sizur> yeah i think c's void has one value -- routine finished.
09:15:07 <Vulg141> brasil?
09:15:13 <Twey> C's void has no values
09:15:27 <Twey> Taking the result of a void function is an error
09:15:33 <sizur> not one defined by c, but you see it
09:15:45 <copumpkin> yeah
09:15:50 <copumpkin> it's not empty
09:16:00 <copumpkin> or functions that returned it would be negations! :o
09:16:20 <b_jonas> wow, what a nice philosophical discussion
09:16:28 <Twey> Functions of that type don't return anything.  That's the point.  :þ
09:16:32 <increpare> oh bugger, I was replying to the hs-boot thing on bug, adding myself to the cc list, and i accidentally changed the 'type of failure' field
09:16:42 <increpare> is there a way to find out what it was before?
09:16:43 <Vulg141> !help
09:16:43 <copumpkin> they're implicitly returning the only value in the void type (that you can never see)
09:16:43 <b_jonas> Twey: no, they return nothing. that's different. :-)
09:16:48 <copumpkin> ;)
09:17:05 <monochrom> int f(void) { return 0; } is a pure, non-pathological function. It does not map to Haskell's Void->Int
09:17:16 <increpare> (bug/trac)
09:17:35 <copumpkin> c's void is more like Haskell's ()
09:17:37 <Twey> monochrom: But void f() { } is different
09:18:01 <Twey> int f(void) is not like f :: () -> Int, either
09:18:10 <copumpkin> Twey: yes it is
09:18:14 <koeien37> f :: Void -> Int; f = const 0;
09:18:22 <Twey> It's f :: Int
09:18:24 <copumpkin> Twey: apart from the side effects thing :P
09:18:25 <koeien37> f undefined ~> 0
09:18:32 <Twey> Because there are no parameters
09:18:40 <copumpkin> Twey: yeah, but () -> x ~ x
09:18:49 <copumpkin> (if you ignore undefined)
09:19:18 <Twey> And Void -> x differs how?
09:19:31 <copumpkin> the fact that (ignoring undefined) it's actually empty
09:19:41 <copumpkin> that means you can't actually ever call such a function
09:19:55 <koeien37> but you can!
09:20:04 <chrisdone> @where goa
09:20:05 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
09:20:06 <chrisdone> =)
09:20:07 <Twey> I see
09:20:08 <copumpkin> let's say haskell was total :P
09:20:34 <copumpkin> x -> Void in a total language is equivalent to not x
09:20:48 <copumpkin> it basically means "if I had a value of type x, then I could give you an element of the empty set"
09:21:37 <copumpkin> which means that you cannot have a value of type x
09:22:28 <sizur> insteresting
09:22:50 <sizur> on an unrelated note, what does haskell need to be able to have a y combinator?
09:22:55 <koeien37> but I can't implement the hailstone numbers in a total language :(
09:24:06 <copumpkin> hailstone numbers?
09:24:18 <copumpkin> sizur: it does have a y combinator
09:24:18 <Twey> y f = (\x -> f $ x x) (\x -> f $ x x)
09:24:28 <copumpkin> not necessarily the conventional one
09:24:34 <copumpkin> but fix is basically one
09:24:42 <copumpkin> you can also encode the more conventional one with some funky types
09:25:29 <copumpkin> http://r6.ca/blog/20060919T084800Z.html
09:26:26 <increpare> copumpkin: ooh that looks fun
09:26:32 <copumpkin> :)
09:27:35 <luite> copumpkin: ah interesting, hadn't seen that one before
09:28:05 <increpare> I added a terminating fixed-point thing to my own utilities library recently (takes an instance of eq, a function, a starting value, and iterates until the value no longer changes) - I've found it quite useful...
09:28:19 <copumpkin> ah, I've wanted that before
09:29:40 <increpare> ahaha there's an 'until' function in the prelude
09:29:41 <koeien37> yeah, i've used it before
09:29:44 <koeien37> firstFixedPoint
09:29:48 <simk138> I have one problem running Happs,  as given in the getting started guide of http://happs.org/ when i try to do "sp ghc -isrc src/Main.hs --make --run --http-port=5000" it gives error sp: command not found fo rthsi do i need to install any thing extra
09:30:12 <koeien37> :t until
09:30:13 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
09:30:29 <Botje> simk138: did you install hapss?
09:30:31 <koeien37> simk138: probably searchpatch. Note that HAppS is no longer mainted. You should use happstack instead!
09:30:31 <Botje> *happs
09:30:38 <koeien37> maintained*
09:31:06 <simk138> yes i have installed HAppS-HTTP, HAppS-State, HAppS-Data, HAppS-Plugins as described in the page
09:31:21 <koeien37> (unless you have some existing code that is built on HAppS and not on happstack)
09:31:22 <increpare> koeien37: yeah ok it's in practice as easy to write a new firstFixedPoint function as to wrap until
09:31:49 <Botje> simk138: do you have a file called sp in a directory "bin" in yourr homedir?
09:32:02 <koeien37> simk138: there is also a happs/happstack-channel, #happs, where you can get help as well
09:33:02 <simk138> do i need to create that directory manually
09:33:25 <Botje> the install shoul've created it
09:33:35 <simk138> koeien37 yes i tried there but no luck
09:34:07 <koeien37> any reason why you use HAppS instead of happstack?
09:34:21 <copumpkin> no
09:34:27 <copumpkin> happstack is the continuation of happs
09:34:42 <koeien37> yeah
09:34:53 <koeien37> it was a question directed towards simk138
09:34:56 <simk138> no any particular reason i am new to this am trying out
09:35:09 <koeien37> there is a happstack-tutorial package
09:35:11 <Botje> happstack is new and sexy, happs is old and bitrotted
09:35:51 <simk138> ok then i should try happstack
09:35:53 <koeien37> simk138: the IRC channel is sometimes a bit slow to respond, especially these days :) there is also a mailing list
09:36:07 <koeien37> see happstack.com for the link
09:36:16 <simk138> thanks
09:36:17 * shapr wibbles
09:40:46 <kolmodin> can't submit bugs to trac on code.haskell.org
09:40:48 <kolmodin> OSError: [Errno 13] Permission denied: '/srv/trac/network/attachments/ticket'
09:47:27 <sshc> does GHC compile into C before making the executable?
09:47:46 <mercury^> Not necessarily.
09:49:51 <benmachine> sshc: there is an -fvia-C option
09:50:26 <Twey> sshc: But it's deprecated in most cases
09:54:44 <Zao> But oh-so-handy when trying to compile for a platform that doesn't have a GHC.
09:54:50 <Zao> When it works. I've never succeeded.
09:56:37 <trofi> Does anyone know portable runtime lexer or parser generators (ideally C library)? in other words it gets grammar as input and builds lexer in runtime
09:56:45 <trofi> kind of alex, but it should be a function instead of separate program+compilation
09:57:20 <trofi> maybe, there is special name for such programs?
09:57:26 <Twey> … Parsec?
09:57:49 <trofi> parsec does not read grammars(rules?) from file, does it?
09:58:40 <Twey> I don't know… I imagine it wouldn't be too terribly difficult to write a thin layer to translate a text file into a Parsec parser
09:59:54 <CalJohn> Is there a shuffler other than Random.Shuffle
10:00:49 <trofi_> grr. disconnected.
10:01:03 <trofi_> what i've wrote the last?
10:01:12 <CalJohn> *System.Random.Shuffle
10:01:15 <ziman> 18:57 < trofi> parsec does not read grammars(rules?) from file, does it?
10:01:26 <trofi_> 19:59:15 < trofi> i'd like to store grammars in plain text and load them at program startup
10:01:32 <trofi_> 19:59:23 < trofi> to allow users twek them a little
10:02:01 <benmachine> 17:58:16 < Twey> I don't know… I imagine it wouldn't be too terribly  difficult to write a thin layer to translate a text file  into a Parsec parser
10:02:15 <benmachine> which is true
10:02:20 <Saizan_> well, define a grammar for your grammars and parse them :)
10:02:25 <benmachine> heh
10:02:33 <trofi_> yes, complete parsers is hard, but lexing should be simpler
10:02:57 <trofi_> Saizan_: and then? i would not like to write a compiler for them:]
10:03:22 <trofi_> actually i have dumb regex based one, but it's terribly slow
10:03:34 <trofi_> and not precise
10:03:40 <Saizan_> trofi_: interpret them as a parsec parser?
10:04:14 <trez> http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/ ?
10:04:15 <Saizan_> eval :: Grammar -> ParsecMonad Something
10:04:30 <Saizan_> i don't remember parsec's types, but something like that
10:04:31 <trofi> i'd like to see realworld example for it
10:04:46 <boris__> I've downloaded happstack from hackage and found that template project does not work. I've modified it and now it runs:) Where should I send my modifications to contribute happstack?
10:06:01 <Saizan_> boris__: the google group / mailing list, there should be links on happstack.com
10:07:02 <siddhi> hi
10:07:02 <siddhi> trofi
10:07:09 <trofi> hi siddhi
10:09:43 <siddhi> hi
10:09:46 <siddhi> trofi
10:09:52 <siddhi> whts gng on?
10:11:21 <trofi> I can't believe noone ever needed runtime lexer builders
10:14:23 <monochrom> People use regex as their runtime lexer.
10:14:59 <monochrom> and regex lib is their runtime lexer builder
10:15:10 <trofi> yes, but it's unscalable
10:16:31 <monochrom> People do not care. They just say they care.
10:18:19 <trofi> it explains why none of IDEs can solve this problem
10:20:29 <trofi> http://www.midnight-commander.org/ticket/1901 <- one of those "do not care" fixes
10:23:49 <CalJohn> > [] = replicate 1 []
10:23:50 <lambdabot>   <no location info>: parse error on input `='
10:23:57 <CalJohn> > [] == replicate 1 []
10:23:58 <lambdabot>   False
10:24:07 <koeien37> replicate 1 [] == [[]] actually
10:25:13 <CalJohn> yeah, it does.  My problem is that I'm using a pattern guard and it looks like "[] <- replicate n []" succeeds
10:25:40 <CalJohn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15029#a15029
10:25:45 <CalJohn> (line 10)
10:26:12 <mauke> '[] <- acc' better written as 'null acc'
10:26:28 <koeien37> hmm, i've never seen this syntax :/
10:26:43 <CalJohn> mauke: you're right, thanks
10:26:53 <CalJohn> i don't think it will change the semantics, though
10:27:02 <Botje> it will.
10:27:10 <CalJohn> Botje: will it?
10:27:22 <Botje> null acc is true if acc = []
10:27:34 <Botje> [] <- acc will work if head acc == []
10:27:38 <CalJohn> oh
10:27:42 <Botje> (so acc can be [[]:_]
10:27:45 <Botje> err
10:27:48 <Botje> ([]:_)
10:28:08 <Saizan_> Botje: in a pattern guard?
10:28:10 <Botje> yes
10:28:23 <Botje> maybe even if [] appears anywhere in acc, i'm not sure how that works.
10:28:43 <CalJohn> that wasn't what I thought, Botje.  i thought [] <- acc would only be true if acc was _exactly []
10:28:54 <CalJohn> this seems confusing to me
10:29:10 <Saizan_> ?type let f acc | [] <- acc = () in f
10:29:11 <lambdabot> forall t. [t] -> ()
10:29:36 <Saizan_> > let f acc | [] <- acc = "empty" | otherwise = "not empty" in f []
10:29:37 <lambdabot>   "empty"
10:29:45 <Saizan_> > let f acc | [] <- acc = "empty" | otherwise = "not empty" in f ['a']
10:29:46 <lambdabot>   "not empty"
10:30:10 <Saizan_> you couldn't even compare head acc with [] in this case
10:30:17 <Liskni_si> > let f acc | [] <- acc = "empty" | otherwise = "not empty" in f [[]]
10:30:18 <lambdabot>   "not empty"
10:30:59 <benmachine> in do-syntax, [] <- acc would match [[]] but that's a different kettle of fish
10:31:01 <Saizan_> Botje: maybe you were thinking of list comprehensions?
10:31:12 <Botje> hmm, yeah.
10:31:34 <Botje> i thought it would use the list monad :/
10:31:42 <Botje> sorry for the confusion everyone
10:32:35 <CalJohn> so, the upshot of this is that [] <- acc isn't matching, and my infinite loop is somewhere else (probably in this function)
10:36:47 * edro4838 is having a problem building 'convertible' it can't find 'class or type for CLDouble' in the Data.Convertible.Instance.C module
10:39:42 <edro4838> Anyone have any thoughts on this ?
10:41:40 <benmachine> didn't CLDouble get removed?
10:41:43 <benmachine> I think I heard that
10:41:51 <Saizan_> are you using ghc 6.12?
10:42:09 <Saizan_> it seems CLDouble got removed, and the convertible package hasn't been updated yet
10:42:13 <benmachine> http://hackage.haskell.org/trac/ghc/ticket/2793
10:42:28 <edro4838> This is convertible-1.0.7 in Hackage
10:43:03 <benmachine> http://hackage.haskell.org/trac/ghc/ticket/3353
10:43:04 <edro4838> And I just updated to ghc-6.12.1
10:43:28 <Saizan_> edro4838: yeah, that's your problem convertible-1.0.7 only builds fine on ghc-6.10
10:44:20 <Saizan_> edro4838: you can cabal unpack convertible, edit the file removing the instance, bump the version in the .cabal file to 1.0.7.1, and then run "cabal install" from that directory
10:46:51 <dansa> man, this channel is huge
10:53:19 <monochrom> There are channels huger yet.
10:57:32 <koeien37> I love #haskell :)
11:04:00 <i_am_neuron> Folks, I'm going through chapter 6 of RWH and there's a thing I don't understand in the code in ch06/Overlap.hs. What does 'instance (Borked a, Borked b) => Borked (a, b) where ...' means? The previous example, 'instance Borked (Int, Int) where ...' is clear -- this is the type that was built using Borked constructor over type (Int, Int). But what about first example?
11:05:39 <Saizan_> Borked is not a type constructor there
11:05:47 <Saizan_> it's the name of a typeclass
11:06:04 <i_am_neuron> Yes, right
11:06:14 <i_am_neuron> (my mistake)
11:06:57 <Saizan_> the first instance means that given two type  a  and  b such that they are instances of Borked, you can make an instance of Borked for the tuple (a,b)
11:07:17 <monochrom> We want to make (a,b) an instance of Borked. But it only works if a is already an instance of Borked and b is already an instance of Borked.
11:08:11 <mxc> ola
11:08:13 <sshc> class Monad m => MonadState s m | m -> s where
11:08:19 <sshc> I haven't seen that syntax used before
11:08:34 <monochrom> "| m->s" is functional dependency.
11:08:35 <sshc> what does the pipe do?
11:08:56 <Liskni_si> pipe in Haskell usually means "such that"
11:09:24 <i_am_neuron> monochrom: "it only works" meaning that type system somehow only allows that, or this follows form the type definition somehow?
11:09:37 <monochrom> Both.
11:09:58 <Botje> sshc: it's a hint to the typechecker. it means that m uniquely determines what s should be.
11:10:34 <monochrom> Bah, I am just roughly speaking. I am just speaking "english".
11:11:00 <Botje> een-glish?
11:11:01 <monochrom> For precise semantics see the haskell98 report.
11:11:33 <Botje> sshc: if you look at the definition for State: instance MonadState s (State s) where
11:11:52 <Botje> here the second part (=m) states that s in the MonadState must be the s in State
11:11:55 <mxc> i've got a performance question..  if i have a function foo :: Data.ByteString.Bytestring -> a and a big long lazy bytestring myLasyBytestring, will calling foo BS.pack $ BSL.unpack myLazyBytestring cause a big performance hit (iterating each byte 3 times) and space hit (creating a [Word8] list and then the string bytestring before passing to foo, or, because of laziness, will it perform like map (foo' . BS.pack . BSL.unpack) myLazyBytestring (i
11:11:55 <mxc> could work on individual bytes), bypassing the intermediate structures?
11:11:59 <aeter> e
11:12:02 <aeter> sorry
11:12:12 <aeter> pressed wrong key
11:12:14 <mxc> (where BS and BSL are the qualified strict and lazy bytestring imports)
11:12:57 <aeter> what library would provide the 'Graphics' module that is to be found in this blogpost: http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/ ?
11:13:00 <mxc> also, sry for the long comment
11:13:32 <aeter> I'm using debian lenny, so far installed every single library coming as a result from '#apt-cache search haskell opengl'
11:14:04 <mxc> aeter - this: http://hackage.haskell.org/package/GLUT ?
11:14:10 <Botje> aeter: looks like it's the GLUT package
11:14:26 <mxc> not sure about graphics.rendering
11:14:26 <aeter> thank you very much, I will try setting it up - thanks :)
11:14:27 <Botje> apt-get install libghc6-glut-dev
11:14:38 <mxc> hayoo down :(
11:15:22 <mxc> and this: http://hackage.haskell.org/package/OpenVG-0.4.0
11:15:39 <mxc> aeter - OpenVG provides the Graphics.Rendering stuff
11:15:58 <mxc> aeter - you can alternatively use cabal:
11:16:04 <mxc> cabal install OpenVG GLUT
11:16:18 <aeter> thanks, it worked great with libghc6-glut-dev
11:17:15 <mxc> not on debian, but you can try this for the other package:
11:17:17 <Botje> have fun :)
11:17:25 <mxc> apt-get install libghc6-openvg-dev
11:17:38 <Powerfool> Hi, does somebody have the following paper/report: "An introduction to the theory of lists", Richard Bird, 1987?
11:26:22 <dcoutts_> mxc: BS.pack . BSL.unpack is rather expensive
11:26:58 <dcoutts_> mxc: and the constant factors are bad
11:26:59 <mxc> so i feared..
11:27:21 <mxc> basically, a lot of my code (and libraries i'm using) work on lazy bytestrings
11:27:56 <dcoutts_> mxc: and you've got this one 'foo' that needs a strict one?
11:28:02 <mxc> but, i'm using the cereal library (since I need the error handling as opposed to data.binary) which tkaes strict bytestrings
11:28:13 <mxc> foo = Data.Serialize.decode
11:28:19 <mxc> essentially
11:28:48 <dcoutts_> and Data.Serialize only works on strict bytestrings? that's sad
11:29:16 <mxc> it is sad
11:29:26 <mxc> the haddock docs say lazy, but its actually strict
11:29:28 <dcoutts_> mxc: if you have to convert to a strict bytestring then lazyness cannot save you
11:30:06 <dcoutts_> all you can do is improve the constant factors
11:30:23 <mxc> was hoping there might be some miracle where the strict bytestring doesnt have to be evaluated down to RNF, and somehow i cld get lucky, but I guess not
11:30:33 <dcoutts_> no, think about the data structure
11:30:39 <mxc> or WHRNF or whatever it is i wouldneed
11:30:39 <dcoutts_> it's one massive contigious chunk of memory
11:30:44 <mxc> yeah, just a straight byte array
11:30:55 <dcoutts_> you can avoid forcing it, but once you do, it's all in memory at once
11:30:59 <mxc> i'm not christian, but was hoping for a christmas miracle i guess
11:31:05 <Saizan_> the only miracle would be if .decode was incremental
11:31:09 <mxc> hehe
11:31:11 <dcoutts_> right
11:31:20 <mxc> that would be pretty difficult
11:31:24 <dcoutts_> then it could be converted to work on a lazy ByteString
11:31:34 * dcoutts_ notes that Data.Binary uses lazy bytestrings
11:31:55 <mxc> i know, but, what I like about cereal is that it fails better
11:32:12 <mxc> as in Data.Serialize.deocde :: Bytestring -> Either String a
11:32:20 <mxc> as opposed to an IOError
11:32:26 <mxc> or IOException, always confuse them
11:32:45 <dcoutts_> mxc: note also that that type signature is funamentally strict
11:32:54 <dcoutts_> that's why it'd gain nothing from using a lazy bytestring input
11:33:27 <dcoutts_> oh, hmm, that's not true
11:33:33 <dcoutts_> it has to consume the whole lot
11:33:34 <mxc> what do you mean?
11:33:40 <dcoutts_> but could do so bit by bit
11:33:40 <mxc> oh, yeah
11:33:41 <mxc> it
11:34:05 <mxc> i guess thats why data.binary uses io errors
11:34:09 <quuuux> how 'contained' is UndecidableInstances? That is, if I have it enabled in one module which declares some instances, which I'm fairly sure don't cause the typechecker to explode, can I be confident that my whole program is fine?
11:34:29 <mxc> since they need to be able to start lazily returning values even if there's an error later in the input
11:34:33 <Saizan_> the only increase in space would be that you've more or less to build the whole result before you can look at it
11:34:52 <dcoutts_> mxc: well actually it doesn't start returning values before consuming all the input either
11:35:02 <mxc> data.binary doesnt?
11:35:21 <dcoutts_> mxc: it's got bad error handling support because we did not know how to combine error handling with the performance we wanted. Though now I think we do.
11:35:47 <mxc> ooh, new version coming out?
11:35:48 <mxc> :)
11:35:57 <dcoutts_> no, too busy :-(
11:36:18 <mxc> whats the new trick, if you dont mind my asking?
11:36:24 <dcoutts_> continuations
11:37:00 <mxc> ah, is that why you suggested continuations for me when i was trying to wrap numbers in an Either for error propagation?
11:37:23 <dcoutts_> I don't recall the deails of what I suggested or why :-)
11:37:30 <mxc> i think it was you
11:37:34 <mxc> not sure
11:37:50 <mxc> me, djinn, and pointfree had a couple good hours together that night
11:37:51 <mxc> e
11:38:01 <mxc> ^djinn, pointfree and I
11:38:07 <mxc> never did get it quite working though
11:38:11 <dcoutts_> we think continuations for error handling optimise better than a >>= defn that uses Left/Right constructors
11:38:28 <dcoutts_> and might allow other things like backtracking
11:38:43 <dcoutts_> ie some degree of binary parsing
11:39:11 <Twey> Continuations for error handling?  Interesting
11:39:19 <Saizan_> i wonder what happens if you just take cereal an switch the imports.
11:39:22 <Saizan_> *and
11:39:33 <Saizan_> it already uses continuations inside
11:41:02 <dcoutts_> I'm not impressed that it uses strict bytestrings without providing any interface for incremental reading
11:41:49 <Saizan_> yeah, attoparsec looks better than
11:41:55 <Saizan_> *then
11:42:17 <dcoutts_> but the monad definition looks sensible
11:42:28 <dcoutts_> it's kind of what we're aiming for with the next binary version
11:42:52 <Veinor> quuuux: I think UndecidableInstances is 'contained' to the module it's added to
11:43:21 <Paczesiowa> quuuux: are your classes closed?
11:45:22 <dcoutts_> Saizan_, mux: hmm, and it uses a kitchen sink API style
11:45:33 <quuuux> Paczesiowa: if you mean the classes themselves, there's only one that needs it. If you mean the concrete types that are instances of the class, no
11:45:54 <dcoutts_> gah, I wish I had time to work on the binary package
11:46:09 <sinelaw> continuations? this is ironic. didn't haskell reject continuations for IO in favor of the monadic approach?
11:46:40 <Paczesiowa> quuuux: if you have a class and its instances that use UI, then even in another, pure module if you can add instances of that class you can still make it loop
11:46:43 <dcoutts_> sinelaw: this isn't for IO
11:47:24 <dcoutts_> sinelaw: and it wasn't continuations, it was lazy lists used in a streaming style.
11:47:25 <sinelaw> dcoutts_, ok, but it sounds like you're favoring it due to performance considerations
11:47:27 <Saizan_> sinelaw: well, i'd have a monadic API over the continuation layer for niceness anyhow
11:47:31 <mxc> twey - this was my first shot at continutations forerrors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15032#a15032
11:47:40 <Saizan_> like we're doing here.
11:47:49 <dcoutts_> indeed, it's a continuation monad
11:47:50 <Saizan_> using continuations just to implement the monad
11:48:00 <sinelaw> oh, if the interface is finally monadic, then i guess it doesn't matter
11:48:06 <sinelaw> i thought you were discussing interface
11:48:10 <dcoutts_> but it's the continuations that give it the special properties
11:48:18 <quuuux> Paczesiowa: even with no new instance declarations? The situation is that I'd like to have any instance of Monad and MonadReader Foo be instances of my class
11:48:18 <mxc> twey - i make no promises that anything there is correct
11:50:01 <sinelaw> never mind me, then
11:50:22 <Paczesiowa> quuuux: new instances could be the problem. could you paste your class and instances?
11:50:31 <Milo-> is (quot) same as (div) ?
11:50:43 <Paczesiowa> :t (qout,div)
11:50:44 <lambdabot> Not in scope: `qout'
11:50:49 <Paczesiowa> :t (quot,div)
11:50:50 <lambdabot> forall a a1. (Integral a, Integral a1) => (a -> a -> a, a1 -> a1 -> a1)
11:51:09 <Milo-> they look the same
11:51:11 <Paczesiowa> @check \a b -> (quot a b == div a b)
11:51:12 <lambdabot>   "* Exception: divide by zero
11:51:13 <jfhall> :src quot
11:51:18 <Twey> Heh
11:51:19 <Milo-> :src quot
11:51:21 <Saizan_> dcoutts_: what would you use as benchmark for this?
11:51:27 <Paczesiowa> @check \a b -> a /= 0 --> (quot a b == div a b)
11:51:27 <lambdabot>   Not in scope: `-->'
11:51:31 <Paczesiowa> @check \a b -> a /= 0 ==> (quot a b == div a b)
11:51:32 <lambdabot>   No instance for (Test.QuickCheck.Testable
11:51:32 <lambdabot>                     (Test.QuickCh...
11:51:46 <Milo-> Paczesiowa yes I keep getting same values but that doesn't prove that they are the same
11:52:24 <Paczesiowa> Milo-: no, it doesn't.
11:52:26 <Twey> @check \a b -> if b == 0 then True else quot a b == mod a b
11:52:27 <lambdabot>   "Falsifiable, after 3 tests:\n-1\n1\n"
11:52:39 <Twey> @check \a b -> if b == 0 then True else quot a b == div a b
11:52:40 <lambdabot>   "Falsifiable, after 3 tests:\n2\n-3\n"
11:52:56 <dcoutts_> Saizan_: basic microbenchmarks and some large real ones like ghc interface files, parsing network protocols, happstack logs/snapshots.
11:53:06 <quuuux> Paczesiowa: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15034#a15034
11:53:31 <mxc> anyway, duncan, saizan, thanks for the guidance
11:54:25 <Saizan_> mxc: attoparsec seems the most promising to me
11:55:31 <copumpkin> that's about 3 or 4 cm isn't it?
11:57:21 <Saizan_> 3.085 cm
11:57:24 <mxc> yeah, looking at it now
11:57:29 <copumpkin> 3.08568025 centimeters
11:57:30 <copumpkin> yeah
11:58:27 <Saizan_> [[insert joke about sizes here]]
11:59:20 <monochrom> "3.08568025 centimeters" has too many digits to be credible
11:59:37 <copumpkin> monochrom: nuh uh
12:00:01 <copumpkin> monochrom: we have a reasonable definition of a parsec in many many many centimeters, and simply divide that by a number with infinite significant figures
12:00:41 <monochrom> I see.
12:01:36 <burp> > 10^^(-15) * ( 149597870.691 / ( sin (pi/(180*3600)) ) )
12:01:38 <lambdabot>   3.0856775813178174e-2
12:01:55 <Lycurgus> why wouldn't one use bignums here?
12:02:06 <copumpkin> > 10^^(-15) * ( 149597870.691 / ( sin (pi/(180*3600)) ) ) :: CReal
12:02:08 <lambdabot>   0.0308567758131781680235422639775266836342
12:02:23 <copumpkin> we can't get many more sig figs out of it than we have measured though
12:02:28 <copumpkin> in fact, we can't get any more :P
12:02:41 <burp> 149597870.691 is astronomical unit (earth sun distance) in km (\pm 0.003)
12:03:02 * Lycurgus has been thinking about numerical/scientific computation solely with bignums, no floating point lately.
12:03:25 <copumpkin> Lycurgus: probably be a lot faster if you can get away with rationals for your application
12:04:23 <Lycurgus> that would be same assuming rational were bignum fractions, no floating point or other mechanisms that inherently introduce error
12:06:47 <Lycurgus> most advanced environment these days seem to be moving to at least have the integer type be bignum
12:06:57 <Lycurgus> *environments
12:07:30 <Lycurgus> *an integer type
12:08:11 <fft> Did anyone make autocompletition for haskell int emacs ?
12:08:40 <monochrom> I just hire a grad student for that.
12:09:05 <Paczesiowa> fft: there's text-based autocompletion (all opened buffers + keywords, Prelude functions and some hardcoded library names)
12:10:15 <fft> Paczesiowa: where is? I've just installed auto-complete but it makes special words only and haskell is not in it's language list
12:11:40 <Paczesiowa> fft: I've seen it on some blog, I've copied it to my init.el, if I can't find it, I'll paste mine version
12:11:45 <Paczesiowa> *my
12:12:29 <fft> Paczesiowa: it would be nice
12:12:29 <Paczesiowa> http://madscientist.jp/~ikegami/diary/20090215.html
12:13:34 <fft> Paczesiowa: thanks. That is the only autocompletition I think)
12:13:39 <Paczesiowa> and remember to correct "FunctionnalDependencies":)
12:14:32 <fft> Paczesiowa: Oh I see )
12:14:45 <copumpkin_> LesDépendencesFonctionnelles
12:14:53 <Paczesiowa> fft: but it's not that good (that completion framework) after completing something C-c C-l stops working ( you have to use it twice - drives me crazy)
12:15:16 <fft> Paczesiowa: Do you use hlint ?
12:15:37 <fft> Paczesiowa: What do you mean twice ?
12:15:59 <fft> Paczesiowa: It toggles the mode ?
12:16:01 <Paczesiowa> fft: no, I usually abuse haskell so there's no point in using hlint
12:16:42 <Paczesiowa> fft: after completing something, if I press C-c C-l it says that it's undefined, but if I press it again it works
12:17:38 <Paczesiowa> fft: to be more specific it only happens when you still have that completion box open
12:17:52 <increpare> Paczesiowa: abuse?
12:18:16 <Paczesiowa> fft: switching completion framework (iirc there are couple of them) would probably help
12:18:42 <Paczesiowa> increpare: -fallow-oleg:)
12:19:02 <fft> Paczesiowa: hmm cannot imagine situation for now When I load the file to ghci before getting it edited
12:19:31 <Paczesiowa> fft: don't you C-c C-l after each modification?
12:19:56 <Accidus> Brilliant! "Some people seem to think that abstractions don't buy you anything concrete." Thorsten Altenkirch, the Categories mailing list.
12:20:01 <pikhq> Every time I read Oleg code and understand it, I suspect I've gone insane...
12:20:54 <Paczesiowa> pikhq: you can't be insane if you suspect it:)
12:21:07 <fft> Paczesiowa: yes but why the completition box is open?
12:21:30 <Paczesiowa> fft: if you don't want to complete and don't bother to press esc
12:21:56 <pikhq> Paczesiowa: Quite.
12:23:01 <fft> Paczesiowa: You may rebind keys to solve this though this is not good
12:23:35 <Paczesiowa> fft: I don't think that would help, apparently inside that completion box you have different bindings
12:24:11 <Paczesiowa> why doesn't typechecker backtrack in case of failure?
12:25:28 <fft> Paczesiowa: I mean bind something to <RET> <DEL> C-c C-l  :)
12:25:45 <mreh> GHC sez: Illegal instance declaration for `LilyPondSource Pitch.T'
12:26:06 <mreh> oh, T is a synonym
12:32:52 <b_jonas> hello
12:33:34 <koeien37> hi
12:33:54 <b_jonas> I implemented arithmetic on integers represented in binary because it always bothers me that The Evolution of a Haskell Programmer only includes solutions using unary
12:34:02 <b_jonas> here it is: http://erxz.com/pb/22336
12:35:06 <b_jonas> it does addittion, subtraction, multiplication and integer division on arbitrary precision numbers represented as binary algebraic data
12:38:13 <sinelaw> preflex, seen Peaker
12:38:13 <preflex>  Peaker was last seen on #haskell-blah 7 hours, 3 minutes and 30 seconds ago, saying: Oejet: #haskell ?
12:38:21 <sinelaw> preflex, seen PeakerWork
12:38:21 <preflex>  PeakerWork was last seen on #haskell 1 day, 18 hours, 27 minutes and 31 seconds ago, saying: DarthShrine: Using the String type is pretty slow, the standard read/show use that
12:45:43 <increpare> Making a game.  Trying to set up a signal system whereby there are rooms, and whenever one person enters a room, the others are notified (they have some internal state that's going to change).  Going about it in a classy way, having a room data type that has an ioref to an array of members (and, indeed, each member having an ioref to the room that they're in).  It seems unsatisfactory from a design standpoint.  I was 
12:45:44 <increpare> IDs for at some point, to mutable tables that would be stored in the main IO loop, but that seems like a bit of an awkward separation.
12:46:02 <increpare> (classy=OO-classy, not "I think I'm so great"-classy)
12:46:07 <b_jonas> if I define an Enum instance, which methods need I define?
12:46:58 <increpare> b_jonas: toEnum and fromEnum
12:47:06 <increpare> b_jonas: cf http://haskell.org/ghc/docs/6.10.4/html/libraries/base/Prelude.html#t%3AEnum
12:47:47 <b_jonas> increpare: I did look there and it does not say which methods are sufficent
12:48:19 <increpare> b_jonas: if you look at the code, you'll see that of eight methods, the other six are given definitions
12:48:24 <increpare> b_jonas: http://haskell.org/ghc/docs/6.10.4/html/libraries/base/src/GHC-Enum.html#Enum
12:48:32 <increpare> b_jonas: but you're right, they should say
12:48:44 <increpare> (definitions/default implementations)
12:49:03 <koeien37> and they are defined in terms of fromEnum and toEnum
12:49:11 <koeien37> (otherwise you risk an infinite loop)
12:49:45 <increpare> b_jonas: alternatively you could define something to be an instance, try compile, and see what warnings ghc gives you.
12:50:11 <increpare> koeien37: Yeah fair point.  : )
12:52:01 <quuuux> increpare: I think a part of your question got chopped off
12:52:42 <increpare> quuuux: oh? I'll split it up, then...maybe just rewrite it
12:53:15 <b_jonas> increpare: that can work, though it can get you infinite loops
12:53:18 <increpare> So I'm wondering how to best do an event-based system, where, were I doing it in C++, I would have classes with pointers to each-other
12:53:48 <increpare> b_jonas: how? if you add methods each time, and never remove any
12:54:20 <b_jonas> increpare: no, infinite loops when running the haskell code
12:54:35 <increpare> b_jonas: oh you're talking about my question not yours?
12:54:41 <b_jonas> increpare: what event-based system
12:54:48 <b_jonas> increpare: no, my question
12:54:50 <quuuux> increpare: anyway, I'm currently writing a MUD, and I've not found a better solution for that than keeping each room's contents in a TVar and sending out instances of a typeclass, Event, to each thingy in the room, which then use fromDynamic to inspect the sent events
12:55:44 <b_jonas> increpare: if I define only (<=) but the prelude defines (<) from (>) and (>) from (<) so you can define either to give an Ord implementation, then I get an infinite loop when I try to call <
12:56:15 <swolchok> I'm porting a program I wrote to generate an answer key for homework to Haskell as a learning exercise. The imperative core of the program in python is a bunch of print statements using string formatting to interpolate the answers.
12:56:22 <increpare> b_jonas: that would be really dodgy library design! : P  but sure, yep.
12:56:37 <b_jonas> increpare: no, they seriously do that, though not with (<) and (>)
12:56:50 <increpare> b_jonas: yip
12:56:53 <swolchok> My current best replication in Haskell is a do block with a series of putStrLn calls that interpolate variables representing the answers that I've defined in a where clause. Is there a nicer way to write this?
12:57:12 * increpare does not now this fromDynamic, of which quuuux speaks ... goes to hoogle
12:57:17 <increpare> (know/>_<)
12:57:25 <swolchok> (interpolate = use ++ to concatenate (show ans) into the string)
12:57:43 <koala_man> is there a shorthand for do { a <- foo; bar; return a; }, given foo and bar?  ie ignore the value of bar and return the value of the previous foo?
12:58:10 <b_jonas> koala_man: try hoogle, there is one in Data.Applicative I think
12:58:18 <b_jonas> koala_man: hoogle for the type that function would have
12:58:36 <Botje> that would be <* or *>, i think
12:58:38 <quuuux> @pl \ a -> foo >>= \ a -> bar >> return a
12:58:38 <lambdabot> const ((bar >>) . return =<< foo)
12:59:16 <gwern> @seen dcoutts_
12:59:17 <lambdabot> Unknown command, try @list
12:59:18 <increpare> quuuux: why do you use fromDynamic, rather than passing around a fixed data-type?
12:59:24 <gwern> preflex: seen dcoutts
12:59:25 <preflex>  dcoutts was last seen on #haskell 2 days, 19 hours, 44 minutes and 32 seconds ago, saying: zygoloid: ok so clearly half of us think of it purely operationally :-)
12:59:28 <dcoutts_> @arr!
12:59:29 <gwern> preflex: seen dcoutts_
12:59:29 <lambdabot> Arrr!
12:59:29 <preflex>  dcoutts_ was last seen on #haskell 0 seconds ago, saying: @arr!
12:59:44 <gwern> dcoutts_: do we have any standard marking-obsolsete method now?
12:59:55 <fft> Paczesiowa: How did you make it work (I mean auto-completition for haskell) ?
12:59:55 <kmc> :t (<*)
12:59:56 <Botje> = undefined? :D
12:59:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:00:00 <dcoutts_> gwern: yes, but the user interface is still to email Ross.
13:00:05 <gwern> hah
13:00:07 <gwern> ok then
13:00:16 <kmc> > "ab" <* "cde"
13:00:16 <gwern> no editing the summary and re-uploading?
13:00:18 <lambdabot>   "aaabbb"
13:00:21 <koeien37> which isn't too bad a process
13:00:23 <Botje> or trace "This function is obsolete" ...
13:00:35 <kmc> GHC has a deprecation warning pragma
13:00:37 <quuuux> increpare: extensibility. Using an ADT means that I have to edit a big central file any time I add a new event
13:00:38 <dcoutts_> Botje: gwern it talking about entire packages
13:00:41 <kmc> which prints a warning at compile time
13:00:42 <Zao> trace "NFS server not responding..."
13:00:48 <Botje> oh
13:01:08 <dcoutts_> for individual modules or functions, yes, use the DEPREDATED pragma
13:01:16 <dcoutts_> (but spell it right)
13:01:17 <increpare> quuuux: True. For me I'm only ever going to be sending a single data-type (a list), so not so big a concern.
13:01:36 <koala_man> I'm specifically trying to parse something and check for eof with parsec. parseFoo <* eof doesn't seem to do it, "No instance for (Applicative (GenParser Char ()))"
13:02:16 <pragma_> depredated?
13:02:16 <increpare> quuuux: though the exact variable passed around isn't too central I guess, to the main issue : P
13:02:49 <gwern> pragma_: hence the joke about spelling aright
13:02:55 <Paczesiowa> fft: I pasted that into my .emacs.d/init.el
13:04:05 <quuuux> increpare: hmm, I think I've misunderstood your problem then. What's wrong with an IORef of the room's contents, and sendEvent :: Event -> Object -> IO () ?
13:05:10 <fft> Paczesiowa: In what place related to other  autocomplete inits? because I made the same and it doesn't work. I reloaded init.el and emacs too. It doesn't help.
13:05:48 <sinelaw> Cale, I've managed to optimize both the things you helped me with
13:06:48 <Paczesiowa> fft: sorry, I'm an emacs noob, and I don't use any autocompletion for anything else
13:06:52 <increpare> quuuux: nothing really - I was just wondering whether there might be a different formalism for doing it that didn't end up with having datatypes with mixed pure/mutable variables
13:07:49 <fft> Paczesiowa:  Me to for now. That's strange
13:07:59 <quuuux> increpare: ah, well, these things need some kind of state, so you need to figure that in -somehow-. So either use IORef or TVar or whatever, or run everything in a State monad, but with entirely pure datastructures
13:08:13 <increpare> quuuux I see people online recommending to use an ID system instead of using explicit IORefs, but...that seems a little gross
13:08:24 <Paczesiowa> fft: maybe you get some errors?
13:09:02 <increpare> quuuux: I'm not going to spend too much more time worrying about it, but I have set aside tonight to the task of doing so : P
13:09:43 <fft> Paczesiowa: no. The table with possible completitions doesn't appear
13:10:53 <Paczesiowa> fft: did you put that into ~/.emacs.d/init.el ?
13:11:04 <fft> Paczesiowa: yes, sure
13:11:26 <Paczesiowa> fft: do you have ~/.emacs ?
13:11:31 <fft> Paczesiowa: no
13:11:49 <Paczesiowa> fft: maybe paste that into *scratch* and eval it all
13:12:14 <increpare> quuuux: I wrote a mud once, but it was in pascal : P
13:12:37 <fft> Paczesiowa: what exactly ?
13:12:44 <Paczesiowa> fft: that whole huge snippet
13:12:49 <Paczesiowa> fft: including tables
13:13:03 <fft> Paczesiowa: to see what will happen ?
13:13:10 <Paczesiowa> fft: yeah
13:14:52 <fft> Paczesiowa: how to eval it all ?
13:14:59 <fft> Paczesiowa: C-j ?
13:15:16 <Paczesiowa> fft: try marknig it all and M-x eval-region
13:15:39 <Paczesiowa> fft: should that fail, eval it definition by definition
13:16:39 <Paczesiowa> anyway those huge import lists are terrible.
13:17:00 <Paczesiowa> it unusable to choose from so many Control.... things
13:17:18 <fft> Paczesiowa: could you show me your init file  ?
13:17:33 <Paczesiowa> fft: ok
13:17:35 <fft> Paczesiowa: I think it would be easier
13:18:44 <sinelaw> woohoo, my first FRP program (using Yampa) finally beginning to work
13:19:36 <increpare> sinelaw: nice! : D
13:19:44 <increpare> sinelaw: what does it do?
13:19:53 <sinelaw> visual graph editor
13:20:06 <increpare> ah right : )
13:20:12 <increpare> you got performance tuned in the end then, I take it?
13:20:31 <Paczesiowa> fft: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15035
13:21:05 <sinelaw> increpare, yes, for now
13:22:25 <sinelaw> thanks to Cale mostly
13:22:50 <sinelaw> Screenshot: http://i.imgur.com/NcnQK.jpg
13:23:20 <b_jonas> here's a newer version: http://erxz.com/pb/22339
13:23:28 <sinelaw> dunno why antialiasing doesn't work, i did everything the opengl tutorials say, i think
13:23:34 <fft> Paczesiowa:  hmm first. I have this bindings before this terrible tables. Second . I have just discovered that in my haskell files auto-complete-mode has value nil
13:24:08 <increpare> sinelaw: ooh the splines are nice and spliney
13:24:28 <increpare> sinelaw: are the ellipses drawn using polygons or textures?
13:24:30 <sshc> are States is Haskell just functions?
13:24:35 <Paczesiowa> fft: I have auto-complete-mode t
13:24:55 <increpare> sinelaw: opengl doesn't do polygon anti-aliasing, though it should be able to sex the lines up - have you tried increasing the width of the lines?
13:25:14 <Paczesiowa> fft: M-x auto-complete-mode ?
13:25:22 <sinelaw> inclement, polygons - and i've tried increasing the line width but it still sucks
13:25:31 <sinelaw> the graphics are very preliminary
13:25:31 <increpare> sshc: There are many ways of talking about states in haskell.  Most frequently with the IO/state monad.  Do you have anything particular in mind?
13:25:39 <kmc> "IO/state monad"?
13:25:47 <kmc> two totally unrelated, vastly different monads
13:26:09 <kmc> sshc, the State monad provides monadic syntax on top of what is actually just passing states around to functions
13:26:13 <kmc> @unmtl State s a
13:26:14 <lambdabot> s -> (a, s)
13:26:22 <increpare> kmc: totally unrelated?  state monad is good for dealing with local state imperatively
13:26:41 <kmc> i mean it's very misleading to lump them together as both the interface and implementation are very different
13:26:54 <kmc> ^^^ sshc an action in (State s) monad is a function that takes a state, and returns a pair of a result value and a new state
13:27:06 <increpare> kmc: maybe I should have used a comma rather than a slash.  But yes I see your point.
13:27:26 <kmc> increpare, it's more that you used singluar "monad"
13:27:30 <kmc> but whatever, i don't need to be this pedantic :)
13:27:46 <koeien37> you could see the IO monad as some kind of State monad from which you cannot escape, with as state the "real world"
13:27:56 <mreh> can I do polymorphic records?
13:27:56 * increpare appreciates it, kmc, for what it's worth.
13:28:07 <koeien37> e.g. putStrLn "牛" updates the "real world" by printing something to the standard output
13:29:01 <increpare> sinelaw: if you want I can have a gander at your rendering code
13:29:39 <increpare> sinelaw: you've checked out http://www.ii.uni.wroc.pl/~anl/cgfiles/Sig99AdvOpenGLnotes/node120.html ?
13:30:35 <sinelaw> increpare, i'd be happy to. it's currently "uglily" divided between my own code and the drawing library (graphics-drawingcombinators) because the lib needs to be extended.
13:30:39 <sinelaw> increpare, http://github.com/sinelaw/graphui
13:31:11 <increpare> sinelaw: render.hs so?
13:31:12 <sinelaw> increpare, relevant part in my own code in src/Main.hs, http://github.com/sinelaw/graphui/blob/master/src/Main.hs
13:31:29 <sinelaw> render.hs doesn't do any tricks beyond using the underlying lib
13:31:52 <sinelaw> increpare, 'initial' is where I do the setup
13:32:43 * increpare reading
13:35:18 <mm_freak> are there any other 'very advanced' languages (disregarding support and library availability), with which haskell would share the top of the evolutionary ladder?
13:35:34 <medfly> heh
13:36:13 <Heffalump> Agda, Coq are more advanced in terms of the type system
13:36:54 <sinelaw> mm_freak, jfdioasjhvc.
13:36:58 <mm_freak> the type system is my main criterion, but also expressiveness and conciseness
13:37:09 <dolio> ATS, Omega, Epigram, Idris, Isabelle, NuPRL, Cayenne...
13:37:19 <sinelaw> but seriously, Agda and Epigram are the ones I know about
13:37:29 <sinelaw> and they both have pretty good tutorials I think
13:37:32 <mm_freak> interesting
13:37:34 <koeien37> but those are really "research languages"
13:37:38 <mm_freak> quite a few languages i've never heard of =)
13:37:39 <koeien37> even compared to Haskell
13:37:52 <mm_freak> that's ok
13:37:55 <koeien37> so in terms of tooling and libraries, far behind Haskell
13:38:11 <Heffalump> Cayenne is pretty much dead, and I haven't heard anything about NuPRL for years either
13:38:33 <increpare> sinelaw: hmm can't see anything wrong.
13:38:42 <sinelaw> :(
13:38:42 <dolio> But we're disregarding support and libraries. :)
13:39:11 <mm_freak> indeed =)
13:39:18 <sinelaw> increpare, I thought it might be my Mesa, but someone here tried it and it still didn't work
13:39:19 <increpare> dolio: in which case Haskell would be at about the middle rung of the evolutionary ladder
13:39:33 <increpare> sinelaw: have you tried disabling texture-mode?
13:39:33 <mm_freak> it's not for practical use, just to show (and see myself) how things can be improved
13:39:36 <dolio> Yeah, I suppose.
13:39:39 <koeien37> I like the balance that Haskell provides at the moment :)
13:39:43 <sinelaw> increpare, nope, i'll try that now
13:40:26 <dolio> Most of the ones I mentioned have extensions in a similar direction.
13:40:26 <mm_freak> what are your favorites, when it comes to theoretical advantages?
13:40:34 <sinelaw> increpare, nope :(
13:40:47 <dolio> ATS, for example, is the only one that adds stuff like linear types.
13:41:17 <increpare> sinelaw: could it be that the graphics combinators package is doing something funky?
13:41:19 <sinelaw> increpare, it could be something that the Draw lib does
13:41:24 <increpare> sinelaw: snap
13:41:29 <sinelaw> :)
13:41:45 <sinelaw> i'm looking through it now
13:41:46 <sinelaw> http://hackage.haskell.org/package/graphics-drawingcombinators
13:41:54 <mm_freak> i loved about haskell how working programs emerge from pure theory
13:42:05 <Heffalump> Clean has uniqueness types
13:42:07 <increpare> sinelaw: try changing the line code in your project temporarily to manually draw them with opengl commands, setting the correct line_smooth/&c. states before
13:42:07 <sinelaw> (I don't use it's "draw" function, only "runDrawing")
13:42:10 <koeien37> heh. works in C too, just needs a little more typing
13:42:15 * increpare thinks uniqueness types are tasty
13:42:24 <sinelaw> increpare, yeah i guess i should do that...properly isolate the problem
13:42:32 <koeien37> clean seemed a little bit windows-focused to me
13:42:45 <koeien37> how to get it /installation wasn't too clear for me
13:42:50 <increpare> sinelaw: yeah, even to write a small program that just draws a single line : )
13:42:59 <increpare> (take one of the glut examples, say)
13:43:00 <mm_freak> koeien37: well, it would work in any turing-complete language, but that's not the point =)
13:43:06 <mm_freak> in haskell it's often the way to go
13:43:35 <koeien37> anybody here going to the FP day in Nijmegen (Netherlands) in the beginning of January?
13:43:52 <increpare> clean seems a bit closed off...doesn't seem to be developing at any sort of pace from what I can ses
13:43:54 <increpare> see
13:44:19 <mm_freak> i think, clean lost the race against haskell, even though it has quite some potential
13:45:53 <quuuux> wasn't there something in the HCAR about either compiling clean to GHC core, or compiling haskell to be run by the clean compiler?
13:47:01 <Heffalump> yeah, I think so
13:47:31 <mm_freak> will haskell ever provide uniqueness types?
13:48:22 <increpare> mm_freak: I haven't noticed anyone calling for them
13:48:35 <mm_freak> i am =)
13:48:58 <mm_freak> not for IO, not for stateful computations, but for things like mutable arrays
13:49:09 <Heffalump> I'd like them.
13:49:24 <increpare> mm_freak: a google search reveals a couple of discussions on the various mailing lists
13:49:24 <Heffalump> I don't think we know how to break up IO into pieces sanely using monads.
13:49:38 <Heffalump> uniqueness types strike me as much more composable
13:49:57 <mm_freak> increpare: sure, but nobody seems to be interested in actually implementing it
13:50:11 <Gracenotes> monads are pretty composable -.- if you don't mind the argument passing
13:50:24 <Heffalump> I don't think anyone but SPJ really knows how to extend the type system.
13:50:26 <holmak> Are uniqueness types anything like the State monad? From skimming the wikipedia article, that's the impression I get.
13:50:31 <mm_freak> Heffalump: i think monads work quite well
13:50:44 <mm_freak> i like the IO monad just as much as i like all state monads
13:51:01 <mm_freak> holmak: they are an alternative to the state monad
13:51:08 <Heffalump> so how would you say split up IO to separate out say the ability to work on one particular file at a time?
13:51:53 <dolio> Uniqueness types aren't really any different than IO for I/O.
13:52:38 <mm_freak> i haven't studied uniqueness types enough to be able to judge, but i can tell you that the monadic approach is great
13:52:51 <mm_freak> that, of course, doesn't mean that there can be greater approaches
13:53:00 <mm_freak> s/can/can't/
13:53:01 <increpare> have uniqueness types been used for any interesting non-io-stuff?
13:53:02 <Heffalump> you haven't answered my question about splitting up IO, though :-)
13:53:17 <dolio> Instead of putting everything inside a master IO monad, you pass around a unique master world token.
13:53:37 <mm_freak> Heffalump: well, i don't know the exact application, but you can always write a "subset of IO" monad =)
13:53:41 <dolio> Which is how IO is implemented in GHC.
13:53:50 <Heffalump> mm_freak: sure, and then how do you compose two such subsets?
13:54:04 <mm_freak> Heffalump: depends on what you mean by "composing"
13:54:07 <increpare> Heffalump: so your problem is that you have all your code stuck in a main function, or?
13:54:17 <Heffalump> write code that can use two such subsets simultaneously
13:54:31 <mm_freak> Heffalump: i get your point
13:54:35 <Heffalump> because it calls things that uses one subset or the other
13:54:50 <mm_freak> but why would you want to split anyway?
13:54:51 <Heffalump> I think it might be possible with type classes, but I think it'd be a bit ugly.
13:55:01 <Heffalump> to provide stronger guarantees
13:55:01 <dcoutts_> Heffalump: I was just going to say type classes
13:55:14 <Heffalump> you basically don't know anything about what happens in an arbitrary IO computation
13:55:22 <dolio> A more coproduct-like approach to IO would probably do the trick.
13:55:24 <mm_freak> well, you do
13:55:24 * quuuux wonders if 'maybe I can do this with type classes...' is a spinal reflex in Haskell programmers.
13:55:30 <dolio> Even if you eventually extract into a master IO.
13:55:32 <Heffalump> mm_freak: not from the type
13:55:45 <Heffalump> dolio: I've never got my head around coproduct-like anythings :-)
13:55:50 <sinelaw> increpare, what about this: http://github.com/sinelaw/graphui/blob/master/test/test_aa.hs
13:55:51 <mm_freak> hmm
13:55:53 <Heffalump> if you can explain what you mean, I'd be interested..
13:55:58 <mm_freak> computation :: StateT Handle IO ()
13:56:17 <mm_freak> or what guarantee are you looking for?
13:56:23 <Saizan> Heffalump: coproduct = sum = ~Either
13:56:39 <Heffalump> Saizan: I know that, but not how it applies to things :-)
13:56:45 <dolio> Well, here's something I cooked up using the prompt monad: http://code.haskell.org/~dolio/haskell-share/io-alacarte/IOA.hs
13:56:54 <Heffalump> mm_freak: the knowledge that the computation doesn't do anything other than touch that handle (for example)
13:56:54 * increpare was hoping he could get away without having to compile anything : P ... I'll try something equivalent with glut (had trouble getting sdl to work last week)
13:57:00 <dolio> It's not really coproducts, but the idea is similar, I think.
13:57:33 <Heffalump> dolio: cool, I'll take a proper look
13:57:33 <koeien37> a coproduct is a product in the opposite category :P
13:57:38 <mm_freak> Heffalump: ok, so you actually want to cut the one master world into many worlds
13:57:45 <sinelaw> increpare, :) you don't HAVE to
13:57:48 <sinelaw> you MUST
13:57:59 <sinelaw> increpare, just kidding of course
13:58:00 <increpare> sinelaw: it doesn't work for you, though?
13:58:07 <sinelaw> increpare, no
13:58:38 <Heffalump> mm_freak: right, and it feels like it'll be much cleaner with uniqueness types
13:59:04 <dcoutts_> Heffalump: I suspect you could also do it using an ST style
13:59:04 <Heffalump> dolio: ok, so you're using typeclasses
13:59:18 <dolio> Heffalump: I think the original thing I was trying to solve was the "we need top-level bind because we absolutely can't do without the unsafePerformIO hack" argument.
13:59:24 <dcoutts_> Heffalump: handles are just like STRefs
13:59:36 <Heffalump> dcoutts_: I don't really see that
13:59:38 <dolio> But it also has kind of a "extensible list of IO effects I use" going on.
13:59:46 <Heffalump> dolio: I think implicit parameters are the answer to that :-)
14:00:43 * hackagebot upload: web-encodings 0.2.0.1 - Encapsulate multiple web encoding in a single package. (MichaelSnoyman)
14:01:04 <Saizan> oleg already implemented various forms of regions with typeclasses, the example in the paper were actually Handle's
14:01:36 <increpare> sinelaw: yeah tinkering around with my own code I'm not getting pretty lines either
14:01:52 <increpare> sinelaw: I guess you could always put in a blur-shader : )
14:02:08 <sinelaw> heh
14:02:40 <sinelaw> increpare, actually, what is that? (i know little opengl)
14:03:34 <increpare> sinelaw: I mean, a post-process effect (written in GLSL or Gc) - those languages are actually pretty functional
14:04:08 <dolio> Heffalump: The coproduct approach would be that you have, say ST and FileIO monads, and then ST :+: FileIO is a monad with both. But I think coproducts are kind of iffy, because they're more like computations where you can combine segments that use either of the effects, but not use both together.
14:04:19 <sinelaw> increpare, sounds complicated though. i'm doing 2d stuff here and all i want is antialiasing
14:04:30 <dolio> The paper on them talks about more general monad colimits, but I've never seen anything that actually develops those.
14:05:20 <increpare> sinelaw: yip yip : )  I'll have a tinker around with some stuff here, see if I can get something blurring...
14:06:31 <Saizan> dolio: well, it doesn't let you make a new primitive for ST :+: FileIO, but you can use primitives from either in the same action
14:06:49 <merehap> what is the simplest way to read and write to the same file? like many others I end up with open handle exceptions
14:07:05 <merehap> readFile "foo" >>= writeFile "foo"
14:07:33 <Saizan> readFile "foo" >>= \str -> length str `seq` writeFile "foo" str
14:07:38 <Saizan> a bit silly.
14:07:41 <increpare> sinelaw: aha, i found an example that smoothes lines
14:08:10 <sinelaw> i was just looking for that, finding haskell-chart
14:08:11 <dolio> Saizan: Well, it has problems in addition to that. It's hard to explain the problem concisely, though.
14:08:14 <merehap> Saizan: hm, I was looking for a way to force the computation, but my naive uses of seq were failing
14:08:38 <merehap> Saizan: I'll use what you've given me for now, thanks
14:09:05 <dolio> Like, if it's State s :+: State t, then you if you interact with the s state, and then interact with the t state, if you go back to interact with the s state, the changes from the initial s state segment might be forgotten.
14:09:11 <increpare> sinelaw: check out AARGB.hs from the examples folder of the GLUT package
14:09:12 <Saizan> merehap: the point is that you've to force the whole string to make it close the handle, length has to traverse the whole list so it's fine
14:09:21 <sinelaw> increpare, thanks i will
14:09:42 <increpare> sinelaw: it blends for me fine : )
14:09:54 <Saizan> dolio: might?
14:09:56 <sinelaw> cool
14:10:00 <merehap> Saizan: so it doesn't lead to traversing the file twice?
14:10:06 <dolio> Unless in the 'run' function, you extract to a monad that is already a state monad with both an s state and a t state.
14:10:33 <dolio> In which case you already have State s :+: State t defined somewhere.
14:10:52 <dolio> It just isn't called State s :+: State t.
14:11:51 <Saizan> merehap: it does traverse it twice, one for strictifying the list, one to write it out
14:12:01 <increpare> sinelaw: it seems to do everything similarly, but in a different order (    lineSmooth $= Enabled;   blend $= Enabled;  blendFunc $= (SrcAlpha, OneMinusSrcAlpha);   hint LineSmooth $= DontCare;   lineWidth $= 1.5 ) - might be worth trying such a rearrangement
14:12:19 <Saizan> dolio: ah, well, you're saying that we need a faithful interpreter
14:12:24 <sinelaw> increpare, will try that
14:12:43 <merehap> Saizan: frustrating, though I'll live with it. thanks for your help
14:13:13 <Saizan> dolio: so i guess we'd like a way to compose interpreters too (and actually fuse them out hopefully)
14:13:54 <dolio> Yes, that's probably the essence of my complaint.
14:14:20 <dolio> Transformers sort of give you the interpreters.
14:15:04 <sinelaw> increpare, not, but also the AARGB example doesn't seem to blended to me here
14:15:07 <sinelaw> *too
14:15:26 <increpare> sinelaw: you've tried resizing the window?
14:15:31 <dolio> Or, if you were using coproducts, the only way you could sensibly use ST :+: FileIO is if the existing IO were also around, and you could interpret it into that.
14:15:54 <sinelaw> increpare, yes it's definately not aa'd
14:16:03 <sinelaw> *definitely :)
14:16:17 <sinelaw> could be my mesa in action
14:16:18 <dolio> Unless you made the runtime able to work with coproducts, I guess.
14:17:04 <increpare> sinelaw: yeah, possibly : (
14:17:17 <sinelaw> increpare, anyway thanks for the help
14:17:31 <sinelaw> i'll try my propietary ati drivers later
14:17:35 <Saizan> dolio: if we actually split IO i'd expect the latter in the end
14:17:35 <increpare> my pleasure
14:17:36 <sinelaw> (last time it crashed my X)
14:17:42 <mm_freak> merehap: readFile "test" >>= \xs -> (xs `using` rnf) `seq` writeFile "test" xs
14:17:53 <mm_freak> you'll have to import Control.Parallel.Strategies, though
14:17:55 <increpare> worst comes to worst, try sticking a bloom shader over everything, will make everything nice and vectory : )
14:17:58 <dolio> Yeah, I guess that point is vacuous.
14:18:33 <dolio> But other monads are in the same situation.
14:19:03 <dolio> You need to already have a 'master monad' that has all the effects you want to extract to.
14:19:26 <dolio> And then you runMaster.
14:19:39 <mm_freak> isn't it possible to write an 'empty IO' monad, with which you can't do anything?
14:19:57 <mm_freak> all other computations are then encoded as OnlyThatThingIO monads and can be combined using transformers
14:20:02 <dcoutts_> mm_freak: Monad m => m a
14:20:12 <merehap> mm_freak: ah, interesting, I'll add Parallel Strategies to my learning list
14:20:14 <sshc> when would I ever want to have the fields of a variable constructeud from a data contructor using field syntax unitiialized?
14:20:41 <mm_freak> merehap: if you're new to haskell, that's probably too early…  learn how to solve problems without them, first
14:21:06 <sshc> @data Record = Record {RecordFoo :: Int, RecordBar :: String}
14:21:06 <lambdabot> Unknown command, try @list
14:21:17 <merehap> mm_freak: no, not terribly new, just wanted to know the most effective ways
14:21:34 <sshc> , data Record = Record {RecordFoo :: Int, RecordBar :: String} deriving (Show)
14:21:36 <lunabot>  luna: parse error on input `data'
14:21:53 <sshc> > Record {}
14:21:54 <lambdabot>   Not in scope: data constructor `Record'
14:23:04 <merehap> mm_freak, Saizan: is there any way down the road that Haskell could make readFile "foo" >>= writeFile "foo" work without breaking laziness or some other desirable property?
14:23:45 <merehap> of course it would preferably be general to streams, rather than just file streams...
14:24:24 <sshc> > data Record = Record {RecordFoo :: Int, RecordBar :: String} deriving (Show)
14:24:24 <lambdabot>   <no location info>: parse error on input `data'
14:24:40 <sshc> < data Record = Record {RecordFoo :: Int, RecordBar :: String} deriving (Show)
14:25:13 <sshc> @newtype Record = Record {RecordFoo :: Int, RecordBar :: String} deriving (Show)
14:25:14 <lambdabot> Unknown command, try @list
14:25:41 <Saizan> dolio: yeah, the "a la Carte" paper gives a way to compose interpreters, but only if they use the same domain
14:25:52 <mm_freak> merehap: the problem is neither haskell nor laziness
14:26:04 <mm_freak> just consider what you're trying to achieve
14:26:19 <Saizan> merehap: that's not problematic because of laziness, it's problematic because readFile is implemented with an unsafe operation unsafeInterleaveIO
14:26:42 <Saizan> merehap: which delays side-effects until the result is needed, which is not the normal behaviour
14:26:57 <Saizan> merehap: it's done essentially so readFile doesn't read all the file in memory at once
14:26:57 <mm_freak> you want a way to concisely express this:  read a bunch, rewind the file's current position, write a bunch, read a bunch, rewind, write a bunch, etc.
14:27:18 <Saizan> merehap: there's e.g. Data.ByteString.Char8.readFile that doesn't do this.
14:27:20 <mm_freak> that's not something you can encode directly, but you can encode reading the entire file, then writing it from scratch
14:28:07 <merehap> ah, I have a better understanding now
14:28:26 <Saizan> or, yeah, if you want the more sophisticated behaviour it's another story
14:28:44 <merehap> so I could use the ByteString library for the desired read once, write once effect
14:28:52 <dolio> Saizan: That isn't to say that coproducts might not still be useful. Writing I/O code with coproducts and then extracting to a master IO in main might get you the relevant benefits.
14:28:54 <merehap> or roll my own strict functions instead
14:28:56 <EvanCarroll> how do you define a data type in ghci
14:29:01 <mm_freak> merehap: yes, you can and you should
14:29:04 <EvanCarroll> `let data Foo = Foo` doesn't work
14:29:10 <EvanCarroll> and data Foo = Foo doesn't work
14:29:19 <mm_freak> System.IO's readFile reads the file into a list, which uses a lot of memory
14:29:23 <dibblego> EvanCarroll, in a file, then :load it
14:29:35 <EvanCarroll> ah you can't do it interactively?
14:29:37 <mm_freak> ByteString.readFile reads it into a ByteString, which uses as much memory as needed
14:29:37 <EvanCarroll> cool
14:29:46 <dolio> They might be useful for writing computations down even if they don't replace certain aspects of transformers.
14:31:35 <merehap> good, I am glad Haskell does have the equivalent simplicity for this one purpose as C#'s File.WriteAllText("foo", File.ReadAllText("foo"))
14:31:40 <Saizan> dolio: true
14:32:19 <merehap> mm_freak, Saizan: your help is much appreciated
14:32:47 <Cale> We really ought to have readFile' etc in the Prelude though.
14:33:06 <Cale> (versions which read into a buffer and convert to string lazily)
14:33:09 <Saizan> i didn't consider that the problem of composing domains gets you back the problem of composing the original monads, often
14:34:18 <dolio> I suppose it's no surprise that coproducts don't get you the whole story.
14:34:21 <merehap> Cale: it seems it may be easier that way on newbies who generally are only led to believe that lists exist
14:34:25 <dolio> Like, what is [] :+: State t?
14:34:38 <Saizan> except that you can have more finely graned monads all interpreted into e.g. a single "State s"
14:34:42 <dolio> StateT t [] and ListT (StateT t) are different.
14:35:02 <dolio> You have to pick one, and I wouldn't expect [] :+: State t vs State t :+: [] to make that choice.
14:35:25 <Saizan> true
14:35:31 <dolio> Assuming a proper ListT, of course, not the awful one in C.M.List.
14:41:32 <Saizan> the part about monad colimits was in ".. a la Carte" or some other paper?
14:48:50 <xle> Hey all... I need some help with the FFI... There is a foreign function that consumes a Ptr CInt, but I need to interpret that pointer (and the data that gets filled inside) as another data structure. In this case it is SockAddr. If Ptr CInt could somehow magically be cast into a Ptr SockAddr, all my problems would be solved. (Or so I think..) Any ideas?
14:49:04 <kmc> there is a pointer cast in Foreign
14:49:15 <kmc> @hoogle Ptr a -> Ptr b
14:49:15 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
14:49:16 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
14:49:16 <lambdabot> Foreign.Ptr alignPtr :: Ptr a -> Int -> Ptr a
14:49:40 <xle> kmc: Thank you - I'll take a look at that.. First time I'm dealing with Foreign..
14:49:50 <kmc> of course it's no safer than a C pointer cast, so be careful
14:49:58 <xle> sure :)
14:50:19 <Twey> Heh.
14:50:54 * hackagebot upload: cpython 3.1.0 - Bindings for libpython (JohnMillikin)
14:50:55 <xerox> Saizan maybe one of those http://www.kestrel.edu/home/people/smith/
14:53:39 <Powerfool> <Powerfool> Guys, does somebody have a copy of the old paper "An introduction
14:53:39 <Powerfool> 	    to the theory of lists" from Richard Bird?  [23:51]
14:53:39 <Powerfool> <Powerfool> I was searching on the internet for a while, but it's hard to get
14:53:39 <Powerfool> 	    these pre-internet (1987) documents in electronic format.
15:03:12 <EvanCarroll> how do i set a default editor for ghci
15:03:21 <kmc> probably the EDITOR environment variable
15:04:04 <EvanCarroll> hrm
15:04:21 <EvanCarroll> nope
15:04:25 <monochrom> Set both EDITOR and VISUAL just to be sure.
15:04:26 <kmc> VISUAL?
15:04:40 <EvanCarroll> nope
15:04:44 <kmc> :(
15:04:55 <EvanCarroll> =( I want a .ghcirc
15:05:13 <xerox> Wild guess :set editor "vim"
15:05:13 <kmc> it's called .ghci
15:05:42 <EvanCarroll> xerox: set a default editor
15:06:08 <xerox> one to be called with :edit right?
15:06:12 <EvanCarroll> oh cool
15:06:12 <kmc> yeah, just put that command in ~/.ghci
15:06:15 <EvanCarroll> kmc++
15:06:24 <EvanCarroll> that should be in man ghci
15:06:36 <EvanCarroll> (under FILES)
15:06:47 <EvanCarroll> cool though that rocks
15:06:49 <monochrom> "Opens an editor to edit the file file, or the most recently loaded module if file is omitted. The editor to invoke is taken from the EDITOR  environment variable, or a default editor on your system if EDITOR is not set."
15:07:27 <monochrom> So EDITOR works if you do it right.
15:08:43 <monochrom> And there is also plan of copying the entire GHC doc tree into a man page.
15:08:55 <EvanCarroll> yep
15:08:57 <EvanCarroll> it does work =(
15:09:19 <EvanCarroll> I fuged that, I forget that bash doesn't set an env var with `set EDITOR=vim`
15:09:32 <EvanCarroll> got to use export
15:12:08 <gwern> monochrom: shouldn't that be into an info tree?
15:12:48 <monochrom> Not exclusive.
15:13:11 <dibblego> dcoutts, ping
15:13:22 <dcoutts_> dibblego: pong
15:13:46 <dibblego> dcoutts, I uploaded two packages to hackage 3 days ago; one has haddock generated and the other doesn't -- is it me?
15:13:56 <dcoutts_> dibblego: nope
15:13:57 <dibblego> http://hackage.haskell.org/package/OSM being the package that doesn't
15:14:22 <dcoutts_> dibblego: looks like it's got docs to me
15:14:31 <dcoutts_> is that the one you meant?
15:14:34 <dibblego> that just happened!
15:14:47 <dcoutts_> :-)
15:14:57 <dibblego> cheers :)
15:15:02 * dcoutts_ did nothing
15:15:19 <dibblego> I wonder what happened
15:15:28 <dcoutts_> Ross probably poked it
15:16:54 <monochrom> I heard rumours that doc generation on hackage is a batch job.
15:17:54 <monochrom> Think of it like those "we have received your order for changing the password. it will be done in 2 weeks"
15:18:18 <dibblego> usually it takes a few hours in my experience
15:19:26 <dcoutts_> it's also crap
15:19:39 <dcoutts_> since it doesn't handle the diamond dep problem
15:19:41 <monochrom> And email too. Email is delivered almost immediately in practice now. But it used to take a day or two in the past.
15:19:43 <dcoutts_> and it only happens on one box
15:19:53 <dcoutts_> which is missing many C libs
15:20:00 <dibblego> my ISP charges money for IMAP
15:20:00 <dcoutts_> it's just not a good design
15:21:01 <kmc> :t lazy
15:21:02 <lambdabot> Not in scope: `lazy'
15:21:17 <kmc> hmm lazy is an annotation to the strictness analyzer?
15:21:27 <dcoutts_> kmc: sort of, yes
15:21:42 <kmc> does it have operational effects like seq does?
15:21:44 <monochrom> Yeah!
15:22:00 <dcoutts_> kmc: it's actually an ordinary function, but the strictness analyzer cannot see the definition (iirc)
15:22:04 <monochrom> My understanding is yes, it has an opposite effect.
15:23:50 <kmc> but forcing (lazy e) will have the same effect as forcing e
15:24:00 <kmc> whereas forcing (seq x e) is different from forcing e
15:24:08 <dcoutts_> yes, lazy is an identity function
15:24:29 <dcoutts_> but the strictness analyser cannot see that
15:24:36 <kmc> cool
15:25:36 <betudeuce> what does "Parse error in pattern" mean?
15:25:56 <BMeph> Wow, talk about "ignorance is bliss" - you guys exploit it for industrial profit! :)
15:26:10 <EvanCarroll> betudeuce: that means your regex is flawed.
15:26:20 <kmc> betudeuce, that you wrote a pattern which is invalid?
15:26:22 <EvanCarroll> erg
15:26:24 <EvanCarroll> wrong channel
15:26:32 <kmc> syntactically
15:27:07 <dcoutts_> kmc: take a look at the source and surrounding comments for lazy, it's quite enlightening
15:27:25 <kmc> where's that?
15:27:30 <dcoutts_> GHC.Base
15:27:34 * kmc is reading random bits of GHC.* for fun
15:27:35 <kmc> ah cool
15:27:51 <gwern> @quote weekend
15:27:51 <lambdabot> ndm says: I was browsing through the Yhc standard libraries, as one does on the weekend, and was drawn to Yhc's sort function.
15:28:37 <kmc> hehe
15:29:57 <mm_freak> @pl one prec = sum . take prec . iterate (/2) $ 0.5
15:29:57 <lambdabot> one = ($ 0 . 5) . (sum .) . (. iterate (/ 2)) . take
15:30:21 <betudeuce> @pl map' f coll = foldr (\x xs -> f x : xs) () coll
15:30:21 <lambdabot> (line 1, column 43):
15:30:21 <lambdabot> unexpected " "
15:30:21 <lambdabot> expecting variable, "(", operator or end of input
15:33:40 <BMeph> @pl map' f coll = foldr (\x xs -> f x : xs) [] coll
15:33:40 <lambdabot> map' = flip foldr [] . ((:) .)
15:34:12 <betudeuce> yeah, but for some reason, it threw a pattern error. I think i mixed up the xs and x
15:34:45 <betudeuce> whats does @pl do?
15:34:47 <betudeuce> @pl
15:34:47 <lambdabot> (line 1, column 1):
15:34:47 <lambdabot> unexpected end of input
15:34:47 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:34:52 <Cale> map f = foldr ((:) . f) []
15:35:16 <kmc> betudeuce, puts code into "points free" or "pointless" style
15:35:20 <kmc> @pl \x y -> x
15:35:21 <lambdabot> const
15:35:32 <betudeuce> Cale but that doesnt take a list?
15:35:51 <kmc> meaning, eliminates explicit argument names
15:35:59 <kmc> @pl \x -> f (g x)
15:35:59 * BMeph pedants: that's "point-less". Although some people find it pointless, too.
15:35:59 <lambdabot> f . g
15:36:10 <Cale> betudeuce: what?
15:36:23 <betudeuce> oh
15:36:27 <betudeuce> currying?
15:36:31 <betudeuce> like a partial?
15:36:45 <Cale> I'm saying that the function  map f  is the same function as  foldr ((:) . f) []
15:37:21 <betudeuce> yes, and what im saying is that it doesnt specify that it takes a list
15:37:31 <betudeuce> so it returns a function that takes a list
15:37:36 <Cale> You can apply both sides to xs, but it doesn't change the equation
15:38:15 <betudeuce> :t flip
15:38:16 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:38:20 <Cale> yeah, both sides of the equation are functions there
15:38:28 <Cale> (which take a list and produce another)
15:38:35 <betudeuce> i see
15:40:43 * BMeph shakes his head at the Wonder...that is Cale-skell! :)
15:42:04 <betudeuce> @pl zip' f coll1 coll2 = foldr (\x xs -> f (head coll1 head coll2) : xs) []
15:42:04 <lambdabot> zip' = flip flip [] . ((flip . ((foldr . const . (:)) .)) .) . (. flip head head) . (.)
15:42:05 <betudeuce> 0.0
15:42:22 <betudeuce> ph wait
15:42:24 <betudeuce> nvm
15:42:42 <betudeuce> hm
15:42:50 <betudeuce> can one write zip with foldr?
15:43:04 <betudeuce> not zip
15:43:17 <BMeph> betudeuce: You're missing some grouping parens, there...
15:43:19 <xerox> betudeuce you keep one list in the accumulator, and consume it as you travel
15:43:34 <BMeph>  @pl zip' f coll1 coll2 = foldr (\x xs -> f (head coll1 )( head coll2) : xs) []
15:43:48 <BMeph> @pl zip' f coll1 coll2 = foldr (\x xs -> f (head coll1 )( head coll2) : xs) []
15:43:49 <lambdabot> zip' = flip flip [] . ((flip . ((foldr . const . (:)) .)) .) . flip flip head . ((.) .) . (. head)
15:43:59 <betudeuce> f (+) [1,2,3] [4,5,6] = [5,7,9]
15:44:37 <BMeph> > let zip' f coll1 coll2 = foldr (\x xs -> f (head coll1 )( head coll2) : xs) [] in zip'  (+) [1,2,3] [4,5,6] = [5,7,9]
15:44:38 <lambdabot>   <no location info>: parse error on input `='
15:45:29 <BMeph> Duh, never mind, that isn't nearly what you want...
15:52:29 <betudeuce> kinda got it
15:52:35 <betudeuce> using zip and foldr
15:52:45 <betudeuce> @pl zip' f c1 c2 = let zipped = zip c1 c2 in foldr (\x xs -> f (fst x) (snd x) : xs) [] zipped
15:52:46 <lambdabot> zip' = (. zip) . (.) . flip foldr [] . ((:) .) . (`ap` snd) . (. fst)
15:53:27 <betudeuce> , let zip' f c1 c2 = let zipped = zip c1 c2 in foldr (\x xs -> f (fst x) (snd x) : xs) [] zipped
15:53:28 <lunabot>  luna: parse error on input `)'
15:53:40 <betudeuce> @define zip' f c1 c2 = let zipped = zip c1 c2 in foldr (\x xs -> f (fst x) (snd x) : xs) [] zipped
15:54:25 <betudeuce> , let zip' f c1 c2 = let zipped = zip c1 c2 in foldr (\x xs -> f (fst x) (snd x) : xs) [] zipped in zip' (+) [1..3] [4..6]
15:54:26 <lunabot>  [5,7,9]
15:56:01 <BMeph> betudeuce: Just curious, but is there a reason why you don't use pattern very much? :)
15:56:17 <betudeuce> pattern?
15:56:40 <BMeph> Er, *patternS I should say. :)
15:57:23 <betudeuce> hmm, how would u re-write it using patterns?
15:57:23 <BMeph> E.g., foldr (\(p, q) xs -> f p q : xs) ...
15:57:56 <betudeuce> o, didnt know u can do that :)
15:58:12 <BMeph> betudeuce: Welcome to Haskellville. ;)
15:58:16 <xerox> > zipWith (+) [1,2,3] [4,5,6]
15:58:16 <lambdabot>   [5,7,9]
15:58:23 <xerox> maybe you just need that.
15:58:32 <betudeuce> yeah, i was trying to re-write zipwith i guess
15:58:53 <BMeph> xerox: Hush, you. Maybe he's having fun working it out for himself... :)
15:59:41 <betudeuce> yeah, whenever im learning a new language, i try to re-write its fundamental functions
15:59:41 <betudeuce> in that langugae
15:59:45 <betudeuce> helps me understand
16:01:04 <betudeuce> i have no idea how to write foldr though
16:01:06 <betudeuce> well
16:01:12 <betudeuce> hmm, maybe tail recursion
16:01:36 <xerox> I see, if you want to compare how the standard ones are written you can see by clicking `source' on the right of each function in the docs
16:01:39 <xerox> ?docs
16:01:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:02:38 <betudeuce> oh wow, so the whole standard is sourced?
16:03:26 <Cale> hm?
16:03:38 <Cale> oh, yeah
16:04:29 <Cale> You could also look at the actual standard Prelude, which gives possible source for things, and is sometimes nicer than the real world implementations
16:04:33 <Cale> That documentation is for GHC
16:04:49 <kmc> betudeuce, yup, you can write foldr recursively
16:05:51 <kmc> @src foldr
16:05:51 <lambdabot> foldr f z []     = z
16:05:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:05:53 <BMeph> I amost can't understand Not being able to write foldr. I wonder if we could get Djinn to do it... ;)
16:06:02 <BMeph> *almost
16:07:05 <kmc> betudeuce, however, the relationship between "tail recursive" and "constant space use" is complicated in lazy evaluation
16:07:18 <betudeuce> anyone familiar with Clojure? Does Haskell offer a tail-recursive accumulator like (recur) ?
16:07:21 <BMeph> I find it interesting that of the two, foldl is the one that's tail-recursive...and unpopular. :)
16:07:38 <kmc> foldr is not tail recursive, but is constant space when used with a nice lazy consumer
16:08:01 <kmc> foldl is tail recursive but uses space basically equivalent to reversing the list
16:08:03 <kmc> @where fold.diagrams
16:08:04 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
16:08:10 <kmc> betudeuce, ^^^^ great page
16:08:36 <betudeuce> nice, i believe its even on wikipedia
16:08:43 <BMeph> kmc: Isn't "space basically equivalent to reversing the list" == "space basically equivalent to the list"? :)
16:08:44 <betudeuce> or wikibooka
16:09:12 <betudeuce> s
16:09:38 <BMeph> betudeuce: Well, it's on CaleWiki. That's good enough for us. ;)
16:10:17 <betudeuce> theres a CaleWiki?
16:10:31 <betudeuce> nvm
16:10:34 <betudeuce> that is awesome
16:11:05 <betudeuce> i kinda get monads now, after watching the beckman video
16:12:25 <EvanCarroll> link?
16:15:41 <betudeuce> cant find link now, somewhere on channel9.msdn.com, it also has a great series on functional programming with haskell
16:15:59 <kmc> betudeuce, monads in general or some particular one?
16:16:07 <betudeuce> in general
16:16:15 <betudeuce> the idea of a monad
16:16:43 <betudeuce> it seems to me that a monad is nothing more and nothing less than a category
16:16:51 <betudeuce> a category which either has things or does things
16:17:04 <kmc> betudeuce, do you mean "category" in the sense of category theory?
16:17:15 <betudeuce> a scope
16:17:18 <kmc> ah
16:17:26 <Accidus> betudeuce, there was a nice blog post about "monads are like X"
16:18:31 <betudeuce> i dont see why they are necessary though
16:18:52 <betudeuce> everything is an operation within a scope
16:18:54 <betudeuce> even side-effects
16:19:38 <Accidus> betudeuce, what do you mean?
16:19:53 <kmc> betudeuce, the idea of monads is to take things that are usually many special-case language features (IO, concurrency, exceptions, nondeterminism, parsing, code generation, ...) and make a single unified way of using them
16:20:01 <betudeuce> 1 + 1 may return 2, but it may not, there is just a much much kower chance of that happening
16:20:18 <kmc> so instead of having to extend the language for each one, we simply make an ordinary user-defined datatype and an ordinary typeclass instance
16:20:34 <kmc> and we can have utilities that work over all of these
16:21:03 <kmc> monads are still useful in a language with impure functions and strict evaluation
16:21:18 <kmc> that's why F# has them standard, and why people have implemented them in many other languages
16:21:30 <tensorpudding> they don't call them monads though
16:21:36 <kmc> sure because it's a scary word
16:21:38 <betudeuce> so, c++ uses monads undercover
16:21:42 <kmc> and because they are competing with Haskell
16:22:01 <tensorpudding> but it's nice to have a common language for what is essentially the same thing
16:22:01 <kmc> betudeuce, no, i don't think so.  what i mean by "monad" is a certain type of interface provided to the user
16:22:28 <kmc> in C++ you use one set of special features for exceptions, and another for parsing, and another for IO, and another for threads, etc.
16:22:49 <kmc> in Haskell we do these all with the "do" notation, which is simple syntactic sugar for some operators in Monad, which is after all an ordinary typeclass
16:22:52 <quuuux> in fairness, I think only F# has monads that are similar enough to Haskell's to warrant the comparison, because you really need typeclasses to avoid the duplication kmc mentions
16:23:14 <dibblego> no you don't -- you need higher order polymorphism
16:23:15 <kmc> iirc in F#, a monad is not an instance of a typeclass, but rather a structure with a certain signature
16:23:24 <kmc> like what we'd get if we made an existential over the Monad typeclass
16:23:29 <kmc> reifying its dictionary
16:23:32 <quuuux> typeclasses or some similarly powerful mechanism, I mean :)
16:23:35 * kmc loves the word "reify"
16:23:42 <dibblego> typeclasses have nothing to do with it
16:23:44 <medfly> what does it mean
16:23:51 <dibblego> Scala avoids the duplication without typeclasses
16:23:53 <kmc> medfly, "reify"?
16:23:56 <medfly> yes
16:24:02 <kmc> Scala's implicit parameters are in some sense a generalization of typeclasses
16:24:09 <kmc> medfly, "to make real"
16:24:13 <medfly> ah
16:24:15 <medfly> thanks
16:24:17 <dibblego> right, but they don't add anything to avoiding the duplication
16:25:11 <dibblego> data Monad m = M (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m a
16:25:58 <medfly> lacks a ) no ?
16:26:07 <dibblego> data Monad m = M (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m a)
16:26:17 <benmachine> should be m b at the end, surely
16:26:21 <copumpkin> heaven forbid our mental parsers find mismatched parentheses at the end of an expression
16:26:22 <dibblego> data Monad m = M (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m b)
16:26:27 <benmachine> :P
16:26:32 <medfly> indeed
16:26:36 <medfly> I feel so smart for pointing out this error
16:26:45 * benmachine hugs dibblego
16:27:13 <quuuux> dibblego: surely that's equivalent to a typeclass, though? The only difference is the amount of sugar you're able to use
16:27:28 <dibblego> quuuux, no it's not equivalent
16:27:36 <copumpkin> quuuux: typeclasses are dictionaries + automatic dictionary lookup + sugar to save you from passing them around
16:27:53 <dibblego> we may assume the language subset without typeclasses and still avoid the duplication, thus typeclasses are unrelated to it
16:28:35 <dibblego> the signature for join would change from (Monad m) => m (m a) -> m a to Monad m -> m (m a) -> m a
16:29:08 <eugenn> > factorial 5
16:29:09 <lambdabot>   Not in scope: `factorial'
16:29:15 <fynn> Yo. What's the difference between the Haskell type system and ML's?
16:30:01 <copumpkin> fynn: lines 15 through 19
16:30:08 <quuuux> dibblego: that's sort of what a I mean by sugar. I could rephrase my question to: what can you do using typeclasses that this approach can't do?
16:30:37 <fynn> copumpkin: only 4 lines?  they're very similar then.
16:30:40 <dibblego> quuuux, pass implicit parameters, but this is a different matter to the benefits of using monads
16:30:45 <fynn> assuming 80 chars per line, of course.
16:31:02 <copumpkin> fynn: well then ghc went and added a bunch more lines at the end
16:32:08 <fynn> seriously, I sort of understand (somewhat) Haskell's type system, so if anyone used ML's, I'd wonder what's the difference.
16:32:32 <dcoutts_> fynn: they're pretty similar, both based on H-M type system
16:32:59 <dcoutts_> fynn: each then adds various extensions, for Haskell that's type classes, polymorphic recursion and ghc adds a bunch more things.
16:33:17 <dcoutts_> similarly, ocaml adds a whole bunch of things
16:33:53 <dcoutts_> the common core is the H-M type system
16:34:37 <tensorpudding> ML was developed by Milner of Hindley-Milner right?
16:34:38 <fynn> OK, so they're both based on H-M, cool. any pattern unifying the kind of extensions Haskell/GHC added vs. the ones O'Caml has?
16:36:07 <dcoutts_> fynn: the GHC extensions can all be embedded into System F (or slight variant thereof), I'm not sure the same is true for the ocaml extensions, but I'm less familiar
16:38:50 <fynn> dcoutts_: thanks.
16:39:11 <EvilTerran> ML has its module system, which (iirc) continues to be a point of on-going research
16:39:48 <EvilTerran> modules (being, effectively, records of types and values) parameterised by other modules
16:40:40 <EvilTerran> with a little extra waffle, you can express typeclasses in them, more-or-less, but i believe they can do more than that too
16:43:15 <fynn> interesting... Erlang has parametrized modules as well.
16:43:58 <kw317> EvilTerran: well, you can do more than that, you've got functors in ML as well
16:44:18 <kw317> which are like functions from modules to modules, with some funny properties
16:44:53 <mreh> how can I spy on someone with nothing but an email address?
16:45:20 <fynn> write a GUI in Visual Basic?
16:45:52 <kw317> mreh: well, having e-mail start with google
16:46:06 <kw317> if you're lucky you can (and they careless) you can find out quite a lot
16:46:09 <Saizan> for the things you use typeclasses the encoding into modules isn't as nice, especially with operators
16:46:24 <kw317> true
16:46:37 <kw317> it's possible, but it doesn't mean you should do it ;-)
16:46:48 <mreh> kw317, can't find a published instance of this email address
16:47:01 <kw317> well, not much luck then
16:47:08 <kw317> try variations of the login
16:47:09 <mreh> it might be spoofed
16:47:09 <fynn> silly question: why didn't O'Caml add support for typeclasses?
16:47:23 <copumpkin> why didn't haskell add support for parametrized modules?
16:47:24 <mreh> kw317: it's a registered domain
16:47:41 <tensorpudding> these are good questions
16:47:41 <fynn> touche
16:47:43 <copumpkin> fynn: SPJ has a patent on typeclasses, obviously
16:47:45 <kw317> mreh: you haven't got much, hard to do anything really
16:48:02 <copumpkin> tensorpudding: the answer is probably "nobody got around to it, and they wanted to explore other stuff that hadn't already been done"
16:48:23 <tensorpudding> so "we don't need to do this because some other language already did it?"
16:48:26 <mreh> i might whois the domain
16:48:35 <fynn> btw, what do you guys think of Erlang?
16:48:38 <copumpkin> tensorpudding: it's not as pressing when they have other more interesting ideas, I guess
16:49:06 <kmc> erlang is dynamically typed
16:49:08 <tensorpudding> i guess both haskell and ocaml are all researchy and the people behind it want to add things they find new and interesting
16:49:20 <kmc> so it's not such a big deal for it to have parametrized modules, first-class types, etc.
16:49:21 <copumpkin> tensorpudding: I'm sure if an ambitious young programmer threw together parametrized module support into GHC and overhauled the module system in general, everyone would be quite happy
16:49:27 <kmc> Python has those as well
16:49:36 <tensorpudding> yes
16:49:41 <Saizan> another answer seems to be that typeclasses and parametrized modules are actually quite close, so having them as completely separatte features will be weird, and yet no one implemented a good bridge
16:50:03 <fynn> kmc: I know, not comparing it straight-forwardly to Haskell or O'Caml, just wondering in general. (also , don't think Python has parametrized modules?)
16:50:12 <kmc> fynn, it has things more or less equivalent
16:50:28 <kmc> because a module and a class are both just a dictionary with attribute access syntax
16:50:40 <copumpkin> fynn: ruby at least has first-class modules, so you could create new ones on the fly (possibly based on a parameter)
16:51:03 <copumpkin> I'd imagine python is pretty close
16:51:15 <kmc> in Python you can create a class on the fly
16:51:16 <pikhq> Erlang? Ick. It's quite an awful language, really. Though, its runtime system has many nice features that justify its use...
16:51:39 <fynn> kmc, copumpkin: indeed that's more true of Ruby than Python; in Python modules are a bit more conservative due to the module system design and particularly the import and file-bound semantics.
16:52:07 <fynn> in Ruby, Module is just a descendent of Object (and, incidentally, the mother of Class)
17:05:39 <xle> oata52
17:06:00 <xle> mt - sorry
17:06:21 <xle> Is anyone aware of a library to query the conntrack table?
17:06:35 <xle> that is /proc/net/ip_conntrack
17:06:56 <dolio> Proper interaction between first-class modules and type classes is somewhat non-trivial.
17:13:58 <eugenn> > (\x -> 6) (filter.head.(.).length.(+).foldl)
17:13:59 <lambdabot>   Couldn't match expected type `[a -> GHC.Bool.Bool]'
17:13:59 <lambdabot>         against inferre...
17:15:20 <eugenn> > fix (const 9)
17:15:21 <lambdabot>   9
17:16:01 <eugenn> @src fix
17:16:02 <lambdabot> fix f = let x = f x in x
17:17:07 <ezyang> G'evening #haskell
17:17:33 <toast-opt> @hoogle a -> a
17:17:33 <lambdabot> Prelude id :: a -> a
17:17:33 <lambdabot> Data.Function id :: a -> a
17:17:33 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
17:18:10 <eugenn> :t (flip flip)
17:18:11 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
17:18:36 <benmachine> :t let flip f x y = f y x in flip flip
17:18:38 <lambdabot> forall t t1 t2. t1 -> (t -> t1 -> t2) -> t -> t2
17:19:47 <eugenn> :t ["hi", "hi"]
17:19:47 <lambdabot> [[Char]]
17:19:48 <tommd> I installed lambdabot but notice the commands list doesn't include basics like '@join' - which I thought was a command.
17:21:24 <toast-opt> btw, has hoogle moved from http://haskell.org/hoogle/, or has ghc's docs moved?
17:21:31 <toast-opt> all the links in hoogle results are 404
17:21:34 <ezyang> tommd: Probably lives in a lugin
17:32:48 <ezyang> When I write a GADT, what's the difference between saying "data Term a where" and "data Term :: * -> * where"
17:34:13 <JohnnyL> any of you programming haskell stuff for cloud services?
17:34:42 <dolio> ezyang: There's no difference, really, except you need an additional extension to use the second one.
17:35:02 <zygoloid> ezyang: if you don't specify, the 'simplest' possible kind will be deduced (unknown kinds get deduced to *). conversely, the named tyvar can be helpful for documentation purposes
17:35:41 <ezyang> h'ok.
17:35:55 <zygoloid> it's very rare that the kind deduction is wrong, though
17:38:59 <kmc> 420 smoke kind every day
17:55:44 <meanburrito920_> I'm a bit confused about the Debug.SimpleReflect.Expr type... it seems to work fine if i say foldr (+) 0 [1..10] :: Expr, but if I attempt to use most other functions, it complains to me that the type of the function does not match Expr
17:55:50 <meanburrito920_> any ideas why this might be?
17:56:03 <meanburrito920_> I checked the documentation and it didnt seem to offer any suggestions.
17:56:32 <__JN> Hello, is there any standard function to filter out all non unique values in a list?
17:56:46 <ezyang> __JN: nub
17:56:53 <kmc> :t O
17:56:55 <lambdabot> Not in scope: data constructor `O'
17:57:31 <__JN> ok, thanks ezyang!
17:57:52 <zygoloid> meanburrito920_: SimpleReflect only works if the value in question is polymorphic
17:58:00 <meanburrito920_> zygoloid: ah. ok
17:58:10 * ezyang is slightly scared by the performance characteristics of the standard list functions 
17:58:57 <meanburrito920_> > nub [1,2,4,3,2,3,4,]
17:58:58 <lambdabot>   <no location info>: parse error on input `]'
17:59:02 <meanburrito920_> oops
17:59:04 <meanburrito920_> > nub [1,2,4,3,2,3,4]
17:59:05 <lambdabot>   [1,2,4,3]
17:59:11 * BMeph pats ezyang's hand comfortingly
17:59:20 <meanburrito920_> hm. nub doesnt seem to be in my stdlib for ghci
17:59:35 <zygoloid> import Data.List
17:59:36 <monochrom> Data.List.nub
17:59:38 <meanburrito920_> ah
18:00:32 <tsou> anyone here had to manually edit dblatex files in order to compile ghc-6.12.1 with the documentation?
18:01:56 <kmc> > GHC.Conc.numCapabilities
18:01:58 <lambdabot>   Not in scope: `GHC.Conc.numCapabilities'
18:09:58 <meanburrito920_> quick question, I have a function that performs pattern matching, but the body of the function is nearly identical in all of the patterns. I want to have a single "while" block for all of the patterns, because they all need effectively the same definitions to work. how could I do this?
18:11:08 <ezyang> meanburrito920_: You might want to considering restructuring your datatypes, if possible.
18:11:11 <Twey> meanburrito920_: Helper function
18:11:13 <Berengal> meanburrito920_: You could move the pattern matching to a case expression instead
18:11:13 <ezyang> That's almost certainly a design smell
18:11:20 <zygoloid> meanburrito920_: foo x = bar x where commonBody = ...; bar A = commonBody; bar B = commonBody; ...
18:11:37 <monochrom> I would consider using case.  f x = case x of { patterns and stuff }  where { now these definitions are visible to all cases }
18:12:06 <meanburrito920_> sounds good. i think I'll try rewriting it with case and see how it goes.
18:13:33 <conal> meanburrito920_: if you post your code, you'll likely get some helpful re-design suggestions.
18:14:07 <ezyang> Seeking suggestions on how to make this small block of code even better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15039#a15039
18:14:15 <ezyang> since it's gonna be some example code.
18:14:49 <monochrom> I consider eliminating $ even better. :)
18:15:48 <ezyang> monochrom: was that at me?
18:15:51 <meanburrito920_> here is what i have right now (it is currently broken) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15040#a15040
18:15:55 <monochrom> Yes.
18:16:01 <meanburrito920_> I'm doing the exercises out of real world haskell
18:16:26 <meanburrito920_> the function is supposed to use fold to turn a string into its integer representation.
18:17:53 <ezyang> monochrom: With... extra parens?
18:18:27 <ezyang> Oh, duh!
18:18:34 <ezyang> wait, no...
18:18:40 * ezyang is still confused 
18:18:43 * Twey too
18:19:36 <meanburrito920_> ok, i fixed up my paste, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15040#a15042 but I'm still thinking there may be a more efficient way to write the function.
18:20:13 <meanburrito920_> besides using foldl' i mean
18:20:55 <tsou> what version of dblatex should I use to compile ghc-6.12.1 with the documentation?
18:22:31 <Twey> meanburrito920_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15040#a15043 ?
18:23:01 <monochrom> With "extra" [sic] parentheses.
18:23:17 <ezyang> ha ha
18:23:22 <ezyang> sure can do
18:23:23 <meanburrito920_> Twey: i like that :)
18:23:27 * Twey locks monochrom in a gaol formed entirely of parentheses.
18:23:50 <Twey> meanburrito920_: Oh, you don't need the brackets around ‘digitToInt b’ at the bottom, either
18:23:58 <Twey> Function application binds tighter than addition already
18:24:03 <ezyang> "still need to <$> though :-)"
18:24:22 <monochrom> <$> is a real operator.
18:24:38 <Twey> $ is a real operator
18:24:53 <Twey> Wait, you're serious about introducing extra brackets just to avoid using $?  :þ
18:25:26 * Twey sentences monochrom to program only in Scheme for the next decade.
18:25:33 <monochrom> To put it in my words rather than yours, I'm serious about introducing clarifying parentheses to avoid extra $'s.
18:25:59 <Twey> But the point of the $ is to increase clarity by removing paretheses :þ
18:26:21 <toast-opt> so 'a $ b $ c $ d' => 'a (b (c d))'?
18:27:09 <Twey> Nested brackets require much more context to parse than the low-precedence $
18:27:42 <Twey> They're also less convenient to edit
18:28:26 <meanburrito920_> toast-opt: i believe ' a $ b $ c $ d' actually goes to  'a (b (c (d))) because of the last $
18:29:16 <toast-opt> meanburrito920_ true, if b is an arbitrary expression string
18:29:21 <quuuux> one more fringe benefit: it's easier to transform `a $ b $ c $ d` into point-free code than the bracketted version
18:29:24 <meanburrito920_> right.
18:29:41 <medfly> what happened to .
18:30:04 <meanburrito920_> medfly: i think that . is simply when using functions, not arbitrary expressions
18:30:42 <ezyang> a . b . c $ d appears to be the preferred version
18:30:51 <Twey> Any sequence a $ b $ c $ d can and should always be expressed as a . b $ c d, or a . b . c $ d
18:30:57 <Twey> I prefer the former, personally
18:33:20 <Berengal> . > () > $
18:33:38 <Twey> Swap the last two ☺
18:33:59 <Berengal> One in the case of f . g . h $ x
18:34:14 <Berengal> of f*
18:34:35 <Berengal> Only*
18:34:48 <Twey> As compared to what?
18:34:57 <Berengal> (f . g . h) x
18:35:06 <Berengal> Although I use that too sometimes...
18:35:16 <Twey> ‘f . g . h $ i . j’ is better than ‘(f . g . h) (i . j)’, too
18:35:34 <Twey> (much better — it's easy to overlook those middle brackets if the expression is long)
18:35:53 <ezyang> Stepping back a sec, am I being reasonable by using IO (Maybe String) to encode EOF versus a string?
18:36:01 <Berengal> (f .g . h.) . i $ j
18:36:17 <Berengal> Or did I miss something?
18:36:46 <kmc> ezyang, sounds all right
18:36:51 <kmc> as long as you don't need other error situations
18:36:57 <Berengal> Sometimes I wish there was a two-arguments-right-composition operator, but then I get better...
18:37:10 <kmc> :t ((.) .)
18:37:11 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
18:37:11 <Twey> Berengal: Wha'?
18:37:26 <kmc> :t let (f . g) x = f (g x) in ((.) .)
18:37:27 <lambdabot> forall t t1 t2 t3. (t3 -> t -> t1) -> t3 -> (t2 -> t) -> t2 -> t1
18:37:42 <Berengal> Twey: The (.:) operator, as it's usually called, or "fmap fmap fmap"
18:37:56 <Berengal> @type fmap fmap fmap
18:37:57 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:38:02 <medfly> o.O
18:38:22 <chrisdone> you get less messy type errors with a $ b $ c than a . b $ c
18:38:33 <quuuux> :t (^) . (^)
18:38:34 <lambdabot> forall b a b1. (Num (b1 -> a), Integral b, Num a, Integral b1) => a -> b -> b1 -> a
18:38:36 <chrisdone> er, swap those round
18:38:49 <chrisdone> (buffer needed clearing)
18:38:51 <quuuux> all my coding from now on shall be done with Japanese smileys
18:38:57 <medfly> haha
18:39:09 <kmc> :t (>>>) . (&&&)
18:39:11 <lambdabot> forall c (a :: * -> * -> *) b c1 c'. (Arrow a) => a b c1 -> (a b (c1, c') -> c) -> a b c' -> c
18:39:27 <kmc> :t (^^) . (<<)
18:39:28 <lambdabot> Not in scope: `<<'
18:39:54 <Twey> Berengal: Not that — this: 02:35:37 < Berengal> (f .g . h.) . i $ j
18:40:09 <Twey> How did that relate to (f . g . h) (i . j)?
18:40:36 <chrisdone> > init . fst . tail $ [] -- nicer type error
18:40:36 <chrisdone> > init $ fst $ tail $ [] -- messy type error
18:40:37 <lambdabot>   Couldn't match expected type `([a], b)'
18:40:37 <lambdabot>         against inferred type `[a1]'
18:40:37 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[a1]'
18:40:41 <Berengal> Twey: Never mind me. I should be asleep hours ago...
18:40:52 <Twey> Ah ☺
18:46:39 <monochrom> Well I believe in the future of syntax tree editing as opposed to today's stupid plain text file.
18:47:11 <Twey> Sure.
18:47:36 <monochrom> All benefits of $ listed above are an accident of the plain text file paradigm.
18:47:54 <Twey> And by Jove, I hope that anyone smart enough to design such an editor is also smart enough to parse out things like $ ;)
18:47:59 <Twey> As you say
18:48:25 <Twey> Much as the benefits of colour-coding are an accident of the sightedness paradigm
18:48:43 <increpare> monochrom: you've seen those talks by the microsoft office guy on his latest venture have you? (sorry, just come in half-way through)
18:48:45 <Twey> That's no reason to colour everything grey
18:49:23 <monochrom> No. I saw Greg Wilson's opinion. And before that, I saw other things too.
18:50:03 <increpare> monochrom: linky?
18:50:59 <monochrom> I saw and I still use http://www.cs.nott.ac.uk/~rcb/mathspad/
18:52:30 <increpare> damn I can't think of what it was called - a programming language setup where everything is stored internally as a database/syntax-tree, and can be exposed to people via lots of different views?
18:54:11 <monochrom> Greg Wilson's opinion is at http://delivery.acm.org/10.1145/1040000/1039534/p48-wilson.html?key1=1039534&key2=3695881621&coll=GUIDE&dl=GUIDE&CFID=68319826&CFTOKEN=72080287
18:54:18 <monochrom> "extensible programming"
18:56:06 <increpare> noooooo I will not submit to XML
18:56:23 <monochrom> or http://www.third-bit.com/articles/extprog-acmqueue-2004.pdf if you prefer pdf to xml XD
18:56:24 * increpare acknowledges that there isn't much too much wrong with xml really
18:56:58 <monochrom> If you're given high quality frontends you won't mind the file format.
18:57:31 <kmc> XML is a fine structured data model together with an awful serialization format
18:57:35 <monochrom> Apart from file format taking too much space, but that can be solved several ways too.
18:57:40 <kmc> you can serialize it elseways or just not look at it
18:58:54 <monochrom> Since day one, it's already made explicit that no one intends you to read/write xml manually. So I don't understand the legitimacy of any complaint. Only legitimate complaint is space.
18:59:56 * ezyang writes his XML by hand and is proud about it! 
19:03:10 <monochrom> I write xml by hand too but I don't complain. It's my choice and I accept its consequence.
19:03:26 <increpare> I guess the main problem with xml/some other richer file format than txt is that it will take either a lot of standardisation or else a lot of special-case code
19:04:01 <increpare> "it has taken XML less than a decade to become the most popular data format in history." <- more popular than plain text?
19:04:29 <monochrom> plain text is a large family of formats.
19:04:53 <monochrom> you may as well say "more popular than files?"
19:05:13 <tensorpudding> what does the X in XML mean?
19:05:22 <monochrom> extensible
19:05:35 <tensorpudding> eXtreme
19:06:46 <monochrom> A programming language is already an extremely rich and structured file format. A parser is a lot of special-case code, or at least a lot of code. One takes a whole course learning how to read the format.
19:07:01 <increpare> monochrom: in thirty years time people might say "more popular than xml?"
19:07:58 <increpare> : )
19:10:47 <kmc> monochrom, really, you'd take a whole course on syntax?
19:10:51 <kmc> maybe for C++
19:10:57 <kmc> for any decent language it should be a day or two
19:11:07 <increpare> So the main step-ups required initially would be in editors and version control systems
19:12:30 <monochrom> No, I mean take a whole course to learn how to write code to read a file in a programming language format.
19:13:17 <increpare> oh right
19:13:24 <increpare> yeah.  that'd take a course all right : )
19:13:34 <SubStack> parsing is hard
19:14:55 <dcoutts_> monochrom: I guess the real problem is editors
19:15:05 <increpare> So xml would to some extent trivialize that, and that's a good thing.
19:15:31 <dcoutts_> monochrom: a single editor can work with a whole variety of flat file formats, but a generic xml editor is probably unusable for most specific cases of xml
19:15:39 <dcoutts_> since the structure is just that much richer
19:15:55 <SubStack> We could just write programs to write programs for us. That sounds easy enough.
19:16:17 <increpare> dcoutts_: right: syntax validation will have more or less to be built in to the editor :/
19:16:37 <increpare> or
19:16:37 <increpare> plugged in
19:16:49 <dcoutts_> and that's the other problem, nobody likes structure editors that enforce well-formed programs at all times.
19:17:57 <increpare> dcoutts_: some people must like them : P
19:18:46 <dcoutts_> increpare: really? I can't immediately think of any structure editors for programming languages
19:19:17 <Zao> dcoutts_: Visual Basic for Applications '97.
19:19:27 <Zao> dcoutts_: Modal dialog box pops up if you leave an incomplete line.
19:19:30 <gwern> all WSIYWG editors are structured editors, no?
19:19:33 <increpare> dcoutts_: mathematica has a half-structured editor, though it allows you to insert random stuff if you want.  For programming languages, there's only the one by that ex-microsoft dude I can't remember.
19:20:07 <increpare> dcoutts_: oh, the old AS editor in Flash, and various visual scripting languages (like Kismet in Unreal Engine)
19:20:21 <dcoutts_> Zao: ah yes, I remember that. Though I think you could ignore it (iirc).
19:20:39 <increpare> http://media.moddb.com/cache/images/mods/1/12/11188/thumb_620x2000/KimsetDiningRoom.png <- mmm structured
19:20:55 <dcoutts_> gwern: yes, so things like lyx etc, but those are for document languages rather than programming languages. They seem to be much less used for programming.
19:21:34 <dcoutts_> Zao: and it's not quite the same, it's only a line-local thing, not enforcing begin/end matching etc.
19:22:14 <dcoutts_> but iy shows that people did tolerate it
19:22:17 <dcoutts_> iy/it
19:22:50 <Zao> My partially broken keyboard begs to differ.
19:22:59 <gwern> dcoutts_: all doc langs are programming languages! :)
19:23:19 <Berengal> All languages are programming languages
19:23:27 <dcoutts_> gwern: of course, but you know what we mean
19:23:31 <increpare> dcoutts_: the examples I gave are legit...can't find a screenshot of old flash though
19:23:33 <Gracenotes> all languages are blue
19:23:41 <Gracenotes> all blue things are delicious
19:23:51 <Gracenotes> therefore... all language are delicious
19:24:04 <dcoutts_> increpare: interesting data points
19:24:24 <tensorpudding> that syllogism is delicious
19:24:34 <increpare> dcoutts_: oh there's that java environment for constructing custom languages...
19:24:41 <dcoutts_> Gracenotes: and are all delicious blue?
19:24:54 <increpare> dcoutts_: jetbrains mps
19:25:01 <gwern> Gracenotes: that's a valid syllogism, though...
19:26:12 <increpare> dcoutts_: generates a syntax-aware editor from the language grammar, that forces you to edit via expression tree
19:26:39 <Berengal> I like the hole paradigm agda has
19:26:42 <gwern> increpare: sounds like the microsoft's guy, intention software or something like that
19:26:50 <gwern> you edit ASTs rather than code
19:26:54 <increpare> dcoutts_:  http://www.jetbrains.com/mps/docs/tutorial/image015.png <-jetbrains
19:29:55 <Berengal> What I know is that it's easier to read SQL than understand the visual query builder in Access for everything but the most simple queries. I extrapolate that direct AST editing might easily become complex, unless the representation is more text, less visuals.
19:30:45 <gwern> early efforts will of course be abortions
19:31:00 <increpare> gwern: ah that's the name I was looking for!
19:31:00 <increpare> gwern: where were you I was asking for aaaages a couple of minutes ago >:|
19:31:00 <increpare> gwern: thanks : )
19:31:00 <increpare> gwern: yeah, it's along the same lines as that
19:31:01 <increpare> gwern: however, with their editor, you can enter stuff that's invalid in some circumstances (if you're a non-programmer, say), to be correctly interpreted/implemented by a proper programmer when they get their hands on it.  I watched an hour-long presentation by him on it.  I was excited by it, but ultimately unimpressed.
19:31:12 <gwern> but then, we've spent the last 60 or so years working in textual formats, so it's no surprise that early on the visual formats would really suck in comparison
19:31:24 <Berengal> Mathematicians have had centuries to perfect their grammar. They're using 2d syntax
19:31:35 <gwern> but they keep changin the math!
19:32:26 <gwern> also, they are somewhat limited by hand as well as economics - math printing was ridiculously expensive as it was
19:32:55 <gwern> (iirc, the premium typesetters charged for math books was quite substantial)
19:33:43 <increpare> gwern: and the fact that academic publishers still charge megabucks even though people do their own type-setting is the source of no small amount of ire amongst various academic communities
19:34:48 <EvanCarroll> @src reduce
19:34:48 <lambdabot> reduce _ 0 = undefined
19:34:48 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
19:34:48 <lambdabot>     where d = gcd x y
19:34:56 <ivanm> increpare: people don't do their own typesetting! latex does it for them! :p
19:34:57 <EvanCarroll> what does reduce do?
19:35:05 <EvanCarroll> @src quot
19:35:05 <lambdabot> Source not found. Wrong!  You cheating scum!
19:35:30 <gwern> > reduce 5 10
19:35:31 <lambdabot>   Couldn't match expected type `t1 -> t'
19:35:31 <lambdabot>         against inferred type `Simpl...
19:35:38 <increpare> EvanCarroll: seems to reduce the fraction a/b to simplest terms
19:35:44 <pikhq> Berengal: It helps that the textual notation is generally intended to either resemble mathematical notation or straight English.
19:35:52 <gwern> :t reduce
19:35:54 <lambdabot> Expr -> Expr
19:36:03 <gwern> ah. simplereflect stuff
19:36:15 <pikhq> Whereas visual notations try to be completely different from anything familiar for, well, no good reason.
19:36:20 <Cale> I think the situation with publishers is ridiculous. They don't really do anything for academics except extract fees anymore. The academics do their own peer review, their own typesetting, and are completely capable of doing their own distribution.
19:36:35 <increpare> ivanm: laxed does some of it, but they type it up rather than have, as used to, secretaries type it up for them.
19:36:37 <pikhq> Cale: Agreed.
19:36:45 <gwern> Cale: they are the capitalists of academia!
19:36:54 <increpare> Cale: which they're doing more and more now : )
19:36:57 <pikhq> Literally the only thing that publishers do for academia is stick it on paper and charge.
19:36:58 <ivanm> increpare: I don't know of that many academics that have secretaries...
19:36:58 <Cale> It's the same with all sorts of publishers.
19:37:05 <increpare> ivanm: not any more.
19:37:16 <ivanm> pikhq: well, they have to collate the papers, etc. as well
19:37:26 <ivanm> after all, creating a table of contents is _so_ hard!
19:37:29 <ivanm> ;-)
19:37:31 <gwern> darn computers. they mean academics can no longer demand amanueneses!
19:37:34 <pikhq> Literary publishers at least do "editing" and "finding authors".
19:37:36 <Cale> All the middlemen are being made redundant by the internet and computers.
19:37:41 <ivanm> I suppose part of the problem is also when people _don't_ use latex
19:37:48 <pikhq> Oh, and "promotion".
19:38:02 <increpare> pikhq: no, most of the editing is done referees.
19:38:03 <pikhq> Granted, they're not needed for those tasks, but they at least still *do* them.
19:38:11 <ivanm> increpare: first round, yes
19:38:21 <ivanm> but then the publishers have to check the layout of the final version, etc.
19:38:24 <increpare> ivanm: in maths this isn't an issue.  In other fields, sure.
19:38:38 <pikhq> Oh, yeah, and literary publishers actually do typesetting.
19:38:46 <pikhq> Well, have the computer do typesetting.
19:38:54 <increpare> pikhq: literary publishers?  oh you mean non-academic?
19:39:01 <ivanm> pikhq: because people who study literature have no idea how to do typesetting? ;-)
19:39:15 <increpare> pikhq: there are some cool markup systems out there
19:39:18 <ivanm> hmmm, was there an ANNOUNCE email for the new version of haskell-src-exts?
19:39:27 <ivanm> increpare: and most of them suck
19:39:33 <pikhq> increpare: Yes. Though I'm not sure "literature" is the best term to encompass "everything but academic". :P
19:39:34 <gwern> I like Markdown :(
19:39:40 <increpare> ivanm: doesn't affect the cool B)
19:39:45 <ivanm> heh
19:39:47 <ivanm> especially if you want one like markdown that can be used for multiple outputs
19:39:48 <pikhq> Particularly since much literature has no appeal outside of academia...
19:39:56 <gwern> ironic eh
19:40:13 <increpare> pikhq: I've heard springer has a sideline of smutty novels to finance the maths end of stuff
19:40:13 <ivanm> gwern: markdown is great for what it does, but can anyone justly claim that pandoc produces good quality html/latex/etc. output?
19:40:34 <ivanm> heh
19:40:35 <Berengal> markdown is awesome for being plain text. You don't need no fancy editor to do any highlighting or organization for you
19:41:09 <ivanm> Berengal: syntax highlighting still makes it prettier though ;-)
19:41:18 <ivanm> and easier for linewrapping, etc.
19:41:19 <increpare> okay. off.  night guys.
19:41:23 <Berengal> ivanm: The effect is limited.
19:41:24 <ivanm> cya increpare
19:41:34 <gwern> ivanm: I think the HTML output is nice
19:41:39 <gwern> gitit pages can look dang nice
19:41:49 <monochrom> I am disappointed at even markdown because even markdown requires escape codes.
19:42:08 <Gracenotes> no like escape codes?
19:42:12 <monochrom> I am really tired of escape codes.
19:42:21 <Berengal> Every markup needs escape codes
19:42:31 <EvanCarroll> what is :%
19:42:40 <Gracenotes> ratio constructor
19:42:46 <monochrom> This is one reason why I want to move to syntactic editors.
19:42:48 <Berengal> Unless you use special syntax instead, but then you need "escape syntax"
19:43:01 <EvanCarroll> hrm
19:43:07 <EvanCarroll> I must read about this ratio constructor some day.
19:43:30 <monochrom> You are best off to use % not :%
19:43:35 <Berengal> EvanCarroll: The ratio constructor is rather boring. The % operator is much more fun
19:43:58 <Berengal> > 4 % 8
19:43:58 <lambdabot>   1 % 2
19:44:04 <Berengal> > 4 :% 8
19:44:04 <lambdabot>   Not in scope: data constructor `:%'
19:44:08 <Berengal> :/
19:44:44 <monochrom> Anyway, to re-confirm, my "escape code" includes escape syntax too.
19:44:49 <ivanm> dammit, why doesn't darcs let you record parts of a change...
19:44:56 <gwern> ivanm: ?
19:45:22 <ivanm> gwern: if I added two lines in one after the other, darcs won't let me record just one line being added
19:45:30 <gwern> pretty sure it will
19:45:41 <gwern> we added that re-editing hunk stuff in the last release or 2
19:46:14 * gwern never figured out the interface so I couldn't tell you more. upgrade and poke around in darcs record's interactive options
19:46:25 <ivanm> heh
19:46:33 <ivanm> maybe it's just for darcs-2 repos... >_>
19:48:49 <monochrom> to check out darcs, you first need to check out from darcs
19:49:45 <holmak> cabal install cabal-install
19:50:06 <kmc> if a math paper is not written using LaTeX, it might as well be written with crayon
19:50:18 <ivanm> kmc: heh
19:50:28 <ivanm> @remember kmc if a math paper is not written using LaTeX, it might as well be written with crayon
19:50:28 <lambdabot> Done.
19:50:31 <pikhq> kmc: What of straight TeX?
19:50:36 <holmak> because if you can write latex, you deserve to get published :/
19:50:39 <ivanm> or ConTEXt, etc.?
19:50:45 <ivanm> @slap holmak
19:50:45 * lambdabot submits holmak's email address to a dozen spam lists
19:50:47 <ivanm> it's not that hard
19:50:52 <pikhq> holmak: LaTeX isn't hard at all.
19:50:53 <ivanm> if all else fails, there's that abomination that is lyx
19:50:56 <holmak> I tried once and failed
19:51:01 <holmak> I am forever suspicious!
19:51:04 <pikhq> I used it for English papers in high school...
19:51:24 <ivanm> whatever you do, don't use it for a normal assignment...
19:51:30 <kmc> lyx?
19:51:32 <kmc> or LaTeX?
19:51:42 <ivanm> I taught myself latex by doing so, then ended up having to rewrite half of it by hand just before handing it in
19:51:44 <ivanm> kmc: latex
19:51:57 <pikhq> And math assignments for my Calc II class.
19:52:02 <kmc> i think using LaTeX on college assignments is worth about a 10% grade improvement, because even if your work is totally wrong, it just *looks* right
19:52:05 <ivanm> large projects, yes; a maths of physics assignment definitely not
19:52:07 <kmc> i am dead serious
19:52:08 <pikhq> (taken via Internet, while still in high school)
19:52:13 <EvanCarroll> is there a base list-type in haskell that has an element count associated with it, such that a push increases the element count, and that a recursive length is not required?
19:52:13 <kmc> as a former TA, i can say that most TAs are fucking lazy
19:52:15 <ivanm> kmc: heh
19:52:48 <ivanm> it was rather disappointing when math and phys started accepting Word documents for projects, etc. at uni :(
19:52:57 <pikhq> I'd do it in TeX even if it were a 1 point grade improvement.
19:52:58 <ivanm> though I think everyone who did maths honours with me ended up using latex...
19:53:00 <kmc> also the TAs like it when they can at least read your work
19:53:20 <ivanm> EvanCarroll: no; for starters, you can't have infinite lists like that
19:53:27 <ivanm> Data.Sequence comes close though
19:53:28 <pikhq> Actually, perhaps I should just use TeX for that; my handwriting sucks.
19:53:36 <kmc> EvanCarroll, perhaps you want Data.Sequence or an array
19:54:08 <EvanCarroll> an array keeps a running count of the amount of elements?
19:54:08 <ivanm> kmc: you can't "add" values to an array
19:54:12 <kmc> yeah
19:54:17 <EvanCarroll> cool
19:54:20 <kmc> EvanCarroll, an array has fixed size which you can query
19:54:20 <EvanCarroll> that sounds like what I want
19:54:23 <ivanm> EvanCarroll: Data.Sequence has a reasonably efficient length function
19:54:24 <kmc> you can't add to it
19:54:40 <monochrom> I used latex for homework just because writing by hand became tiring.
19:54:48 <EvanCarroll> right, you can't add to any base type in haskell right? because adding is a side-effect
19:54:53 <kmc> ?
19:55:00 <kmc> dunno what you mean by "base type"
19:55:10 <monochrom> Also I made too many typos.
19:55:13 <kmc> and typically "updating" an array returns a new array
19:55:20 <kmc> it's the same with lists and Data.Sequence
19:55:21 <ivanm> monochrom: heh
19:55:38 <ivanm> but with lists, etc. the implementation keeps unchanged bits to improve efficiency
19:55:45 <monochrom> My typo rate is like 10% to 30%.
19:55:55 <ivanm> so doing a : as doesn't create a completely new list; it uses pointers to re-use as
19:56:23 <kmc> EvanCarroll, you can also just use an ordinary list where each element is a pair of the value and the number of following values in the list
19:56:28 <EvanCarroll> right, base type means in prelude
19:56:37 <kmc> EvanCarroll, that's pretty artificial
19:56:44 <kmc> Prelude is after all just another module
19:56:56 <monochrom> You know the cons operation is just as efficient if you keep a length field.
19:57:03 <EvanCarroll> right, but it a module I can use right now, as a novice, that I don't have to understand or intsall.
19:57:16 <kmc> EvanCarroll, there are many such modules included by default
19:57:22 <kmc> in Haskell Platform or even in the base package
19:57:22 <monochrom> cons x (len, xs) = (len+1, x:xs)
19:57:29 <ivanm> Data.List, Data.Sequence, Data.Map, Data.Set, etc.
19:57:44 <ivanm> kmc: well, most of the ones that will be useful to him will be in containers, not base... but close enough
19:57:45 <kmc> EvanCarroll, it's important to learn Data.Map and Data.Set early on, and probably Data.Sequence as well
19:57:48 <kmc> ivanm, that's true
19:58:05 <ivanm> FingerTrees are quite cool
19:58:13 <kmc> EvanCarroll, for a list-with-length, it's not enough to store the length only in the "head" of the list, because it breaks the idea that a) a suffix of a list is a list, and b) you can cons additional elements onto the head of a list
19:58:22 <kmc> so as monochrom said you would have to include length in every element
19:58:29 <EvanCarroll> I use Data.Map and Data.Set I've never seen Data.Sequence yet
19:58:32 <EvanCarroll> I'm doing LYAH though
19:59:32 <monochrom> Oh even if you do "data Woah a = Nil | Woah Int a (Woah a)" it is not that bad.
20:00:02 <kmc> > snd $ foldr (\x (n,ys) -> (n+1, (x,n):ys)) (0,[]) "abcde"
20:00:03 <lambdabot>   [('a',4),('b',3),('c',2),('d',1),('e',0)]
20:00:17 <ivanm> kmc: but then concatenation becomes more difficult
20:00:27 <kmc> ivanm, yeah
20:00:31 <ivanm> (not overly so, but the bookkeeping becomes a little bit more involved)
20:01:14 <sjanssen> monochrom: the major problem I see with 'Woah' is that evaluating the length would often be a stack overflow
20:01:26 <monochrom> Add !
20:01:35 <monochrom> data Woah a = Nil | Woah !Int a (Woah a)
20:01:47 <ivanm> NEEDS MOAR BANGS
20:01:50 <ivanm> ;-)
20:01:56 <sjanssen> that will make filter take O(n) stack
20:02:02 <monochrom> {-# -funbox-strict-fields #-}
20:02:04 <ivanm> copumpkin: dammit, you really have infected me! :s
20:02:40 <sjanssen> I think that lists aren't a good fit for length
20:03:03 <monochrom> Yes filter is victimized.
20:03:18 <ivanm> monochrom: as is ++, etc.
20:03:28 <monochrom> But perhaps a programmer asking for Woah does not use filter on it.
20:03:44 <ivanm> actually, ++ would just need you to map (+ x) on the first list's length values...
20:04:03 <ivanm> still, a log n function like length for Data.Sequence is usually trivial
20:04:13 <ivanm> (in the runtime sense)
20:04:19 <sjanssen> list construction in the typical style is pretty broken with that defn.  Efficient list construction code would need to be significantly more complicated
20:05:04 <monochrom> This is why the standard library should not come with all conceivable data structures; instead it should come with a coupon for a course on how to design data structures.
20:05:05 <sjanssen> basically you'd need to write your functions more like OCaml/Scheme thank Haskell
20:05:12 <sjanssen> heh
20:05:34 <ivanm> monochrom: heh
20:05:56 <ivanm> @remember monochrom [..] the standard library should not come with all conceivable data structures; instead it should come with a coupon for a course on how to design data structures.
20:05:56 <lambdabot> Okay.
20:05:58 <monochrom> "admit one. no cash value."
20:05:58 <kmc> funbox!
20:06:03 <kmc> monochrom, hahaha
20:06:08 <kmc> @quote funbox
20:06:09 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
20:06:10 <kmc> @quote funroll
20:06:11 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
20:06:12 <sjanssen> Haskell is a great playground for learning and making datastructures after all
20:07:47 <kmc> yeah, in many cases the real-world difference between O(log n) and O(1) is dubious
20:08:03 <ivanm> sjanssen: did you really need to say anything after "playground"? :p
20:08:05 <kmc> often the supposed O(1) algorithm or structure is more complicated and has worse constant terms
20:08:58 <ivanm> kmc: *cough* trees vs hashtables *cough*
20:09:13 <kmc> well binary trees suck for cache usage
20:09:24 <kmc> high-arity trees on the other hand are wonderful
20:09:50 <Axman6> like B-Trees?
20:09:59 <kmc> or judy arrays or whatever
20:10:15 <holmak> I like the Clojure map implementation.
20:10:22 <kmc> holmak, hash trie?
20:10:23 <monochrom> Tell me if I'm wrong: hash tables ruin caches too.
20:10:26 <ivanm> Axman6: the actual page (I can never remember it though) uses red-black trees
20:10:32 <holmak> I think so, yeah.
20:10:35 <ivanm> http://enfranchisedmind.com/blog/posts/problems-with-hash-tables/
20:10:44 <Axman6> what actual page?
20:10:50 <kmc> holmak, yeah.  i was really happy to see that it's a persistent datastructure
20:11:06 <kmc> it's funny that those things aren't more common in C++, given how much emphasis it places on explicit sharing and copying
20:11:25 <kmc> judy arrays are basically 256-ary trees, with several fancy representations for nodes in order to avoid storing 256 pointers at each
20:12:32 <EvanCarroll> i'm reading LYAH can someone explain the Eq typeclass?
20:12:38 <kmc> yeah
20:12:40 <EvanCarroll> how is == defined in terms of /= and /= defined in terms of ==
20:12:41 <ivanm> Axman6: bah, a comment of mine I thought I said didn't actually get said... >_>
20:12:42 <holmak> I really like Clojure. I think Rich Hickey absolutely nailed the data structure API.
20:12:47 <kmc> EvanCarroll, because each instance will override at least one
20:12:51 <ivanm> EvanCarroll: because you only have to define one for your custom instance
20:12:56 <holmak> But, I like types better :/
20:12:58 <ivanm> and then the other is automatically defined for you
20:13:00 <monochrom> You are supposed to override one of them. Then you get the other free.
20:13:03 <kmc> EvanCarroll, you can say: data Foo = Foo; instance Eq Foo where {}
20:13:08 <kmc> in which case (Foo == Foo) will infinite loop
20:13:45 <aavogt> should default class methods really form cyclic graphs?
20:13:58 <EvanCarroll> right.
20:14:01 <kmc> aavogt, yes, but we should have an in-language way to specify minimum implementation
20:14:01 <ivanm> aavogt: why not?
20:14:07 <Veinor>  No matter how many times I see this, it still always amuses the hell out of me: i  = 0x5f3759df - ( i >> 1 ); // what the fuck?
20:14:10 <holmak> kmc: I agree with your comment about C++; Clojure-style persistent data structures seem ideal for performance-minded folks (aka C++ programmers).
20:14:12 <ivanm> kmc: it's called "haddock" ;-)
20:14:19 <aavogt> that makes people have to read the documentation to see the minimum number to be implemented
20:14:24 <EvanCarroll> I got it now, kmc's definition was /great/
20:14:25 <ivanm> Veinor: do I dare ask what it's meant to do?
20:14:38 <Veinor> It's part of a super-fast implementation of 1/sqrt(x)
20:14:44 <Veinor> http://www.codemaestro.com/reviews/9
20:14:45 <ivanm> aavogt: do you really want people to implement your classes without them reading documentation to know what they are and what they do?
20:14:51 <holmak> Handed down from God himself.
20:14:58 <ivanm> type signatures are not the be all and end all of documentation you know...
20:15:06 <ivanm> Veinor: :o
20:15:21 <kmc> you should read the docs.  your compiler should also enforce that you read the docs, to the greatest degree possible.  that's why static types are good
20:15:27 <Veinor> it's the deepest of magic
20:15:34 <ivanm> Veinor: I take it it only works for certain datatype sizes (due to the literal hex value there)?
20:15:40 <holmak> And by god, I mean I think I read an article tracking it to an old GPU company.
20:15:43 <sjanssen> ivanm: that's a slippery slope you're on there, at what point do we end up with dynamic types and lots of RTFM?
20:15:44 <kmc> basically people will only read exactly as much documentation as they need to build something which isn't immediately and obviously broken
20:15:48 <Veinor> i is a long that gets direct-casted from a float
20:15:52 <ivanm> kmc: right; there's always room for improvement in that regard
20:15:57 <monochrom> If you let the compiler bark at you, people start complaining about unreadable error messages.
20:16:00 <Veinor> y is a float,   i  = * ( long * ) &y;  // evil floating point bit level hacking
20:16:05 <ivanm> sjanssen: true, but if you're wanting to implement a class you should read the docs IMHO
20:16:12 <kmc> monochrom, i think "You must implement one of: (==) (/=)" is readable enough
20:16:15 <ivanm> e.g. make sure your monad instance obeys the laws
20:16:23 <aavogt> monochrom: people will complain regardless of what the compiler does
20:16:28 <ivanm> aavogt: heh
20:16:30 <kmc> unreadable errors come from specific issues in language design, not just the idea of static checking
20:16:34 <sjanssen> ivanm: of course you need to read the docs, but it would be nice to have the compiler double check your work
20:16:52 <monochrom> Lurk in this channel to see people complain about even "You must implement one of: (==) (/=)".
20:16:58 <ivanm> double-check, yes; do your thinking for you, no
20:17:04 <ivanm> monochrom: heh
20:17:07 <kmc> monochrom, i'm here all the time and i don't see much of that
20:17:21 <aavogt> I use type inference to avoid thinking sometimes
20:17:21 <ivanm> kmc: I think that was a joke...
20:17:27 <monochrom> They will say "what does it mean?"  If all else fails, they always have the last resort, "it should suggest me code!"
20:17:27 <ivanm> silly aavogt
20:17:28 <kmc> idgi
20:17:28 <ivanm> ;-)
20:17:36 <sjanssen> I'd like to see some system of instance creators
20:17:46 <ivanm> kmc: I _think_ that people will whinge about _anything_ here
20:17:46 <kmc> aavogt, "here's a proof.  figure out what i proved"
20:17:55 * kmc whines about the level of whining
20:18:11 <ivanm> see what I mean?
20:18:21 <sjanssen> so I could give a name to "monad/functor/applicative" via return, fmap, join
20:19:00 <sjanssen> and another name to those instances via (>>=) and return
20:19:03 <ivanm> sjanssen: yeah, having something like "instance Functor a <= (Monad a) where fmap = liftM" would be cool
20:19:14 <quuuux> argh. Is there any way to hide an instance in an imported module?
20:19:24 <sjanssen> quuuux: no, Haskell does not allow this
20:19:24 <kmc> i hate how instances are not first-class
20:19:30 <ivanm> quuuux: nope
20:19:34 <monochrom> No, cannot hide instances.
20:19:36 <kmc> imo they should just be implicit parameters
20:19:45 * ivanm hates it how instances from a non-exported class are visible in haddock :@
20:19:57 <quuuux> oh well, looks like I'm going to have to patch mtl for my needs. Again
20:20:17 <aavogt> quuuux: which instances did you add?
20:20:41 <quuuux> aavogt: I need a different instance of MonadError for IO than the provided one
20:20:58 <aavogt> then make a newtype of IO with the MonadError instance you want
20:21:05 <sjanssen> kmc: the globality of instances is a nice property sometimes.  It gives us things like Typeable and a StorableArray that doesn't allow easy segfaults]
20:21:08 <monochrom> Eww!
20:21:26 <kmc> sjanssen, hmm, good point
20:21:36 <kmc> still i wager most instances are not like that
20:21:57 <aavogt> quuuux: or use (ErrorT SomeErrorType IO) instead?
20:21:58 <sjanssen> I think it's about half-and-half
20:22:09 <kmc> hmm
20:22:16 * kmc ponders the disaster of template specialization in C++
20:22:23 <kmc> you do make a compelling argument ;)
20:22:32 <monochrom> After a while I find that most silently imported instances are harmless. So how about provision to suppress just those few instances that happen to get in the way?
20:22:44 <pikhq> kmc: It's not a disaster, it's just pattern matching.
20:22:56 <pikhq> ... At type level.
20:23:15 <kmc> pikhq, it's a problem because your code will compile but do different things depending on which headers you include and in what order
20:23:19 <sjanssen> monochrom: there's a fair body of code that relies on instance globality
20:23:35 <kmc> however that's also a problem with the way C++ depends on an antiquated C-style include mechanism rather than a proper module system
20:23:54 <sjanssen> for example, Data.Map gets pretty silly when there are different Ord instances floating around.  Especially silly if a Map is passed between modules with two different instances "in scope"
20:24:00 <kmc> it's especially a problem when two compilation units don't agree on the definition of Foo<Bar>
20:24:05 <pikhq> And a problem with how C++ does compile-time execution.
20:24:15 <kmc> afaik that can cause arbitrarily bad run-time disasters
20:24:16 <monochrom> oops
20:24:36 <medfly> I wonder why this channel discusses C++ being bad so much.
20:24:37 <kmc> sjanssen, you'd provide the instance on constructing the map
20:24:54 <kmc> medfly, perhaps because some of us program C++ for a living ;)
20:25:08 <medfly> is it worse than PHP?
20:25:15 <sjanssen> kmc: yes, the GADT route.  This is more difficult to optimize (though I admit it is a lame cop-out)
20:25:24 <kmc> medfly, probably... it much harder anyway
20:25:24 <monochrom> No, we are talking about a haskell problem and we note that c++ has a related problem.
20:25:26 <kmc> and not in good ways
20:25:32 <sjanssen> kmc: plus there's things like union that combine two maps
20:25:37 <medfly> anything is harder than PHP.
20:25:45 <kmc> sjanssen, true.  it'd have to be left- or right-biased on the dict.
20:25:55 <kmc> to be a good C++ programmer you need a lot of intelligence and skill, all of it wasted on bullshit
20:26:03 <medfly> haha
20:26:28 <sjanssen> kmc: and the right would need to be re-sorted each time, or we'd need instance equality, or it would just give wrong answers on occasion
20:26:35 <kmc> yeah
20:26:47 <sjanssen> I think instance globality is okay
20:27:19 <sjanssen> but there should be a way to get class dictionaries as values, and then use those dictionaries as implicit parameters
20:27:41 <kmc> yeah
20:27:47 <kmc> got to go
20:27:49 <kmc> peace all
20:28:45 <monochrom> oh, HWN is taking christmas break
20:29:32 <sjanssen> this might be like Scala's implicit whatchamacallit system, but I don't know Scala
20:31:09 <ivanm> monochrom: missing it, were you?
20:31:17 <sjanssen> ewww, scala-lang.org has snowfall via Javascript
20:31:24 <sjanssen> is it 1998?
20:31:48 <monochrom> I guess everything is abusable
20:32:16 <pikhq> medfly: We tend to discuss the C++ type system more than anything else.
20:32:23 <ivanm> monochrom: what was your "Eww!" for before?
20:32:38 <monochrom> http://www.vex.net/~trebla/humour/missing_dollar.html is a good use of javascript :)
20:32:52 <pikhq> Since it's a strict, strongly-typed functional programming language. ... For a strict, weakly-typed imperative programming language.
20:33:01 <pikhq> :P
20:33:39 <monochrom> My last eww was for having to newtype in order to evade existing instance
20:33:50 <ivanm> ahhh
20:35:28 <monochrom> Oh another good use from the same author! http://www.vex.net/~trebla/homework/extended-euclid.html
20:38:10 * ivanm never gets that missing dollar problem; if you sit and think about it it makes sense, so why keep carping on about it?
20:38:30 <ivanm> monochrom: it says to scroll down for the theory, but I can't scroll anymore!
20:38:37 <ivanm> (since the full page fits in my screen)
20:40:10 * monochrom is tempted to script more to dynamically determine your browser window size and decide whether to tell you to scroll down...
20:40:29 <ivanm> heh
20:40:48 <ivanm> or you could just say "read further" or some such to cover both bases...
20:40:48 <monochrom> This is why "real" software is too complicated.
20:41:19 <ivanm> heh
20:41:29 <ivanm> because of browser and screen sizes!
20:41:43 <monochrom> because of customer attitudes :)
20:43:11 <ivanm> monochrom: oh, isn't that why so many of us write F/LOSS? because then you get what you pay for and thus can't complain? :p
20:43:17 <monochrom> Trying to be fool-proof is futile. The correct solution is this. Every software package comes with an obnoxious license already. So why not just add a skill exam to the license?
20:44:32 <Bluetar> I'm not sure if this is the right place to ask, but I have problems with the "inferior haskell mode" in xemacs
20:44:59 <monochrom> It's a right place to ask but I have had no problem so I don't know how to help.
20:45:25 <Bluetar> well, has anyone used it?
20:45:50 <Bluetar> when I press C-c C-i, I just get the error message: "Symbol's value as a variable is void: temporary-file-directory"
20:45:52 <monochrom> I use it in emacs. But it works so well for me.
20:46:05 <Bluetar> I can't seem to find any help with google
20:47:10 <ivanm> Bluetar: what version of haskell-mode is it?
20:47:19 <ivanm> and I think you have to load the module into ghci with C-c C-l first
20:47:34 <Bluetar> C-c C-l gives the same error
20:47:45 <Bluetar> I think it's version 2.4
20:47:57 <ivanm> Bluetar: it must be using something that isn't in xemacs
20:48:18 <ivanm> oh, wait, is this the foo.cabal problem?
20:48:27 <ivanm> Bluetar: try a newer version of haskell-mode to see if that works
20:48:50 <monochrom> Fun. What is the foo.cabal problem?
20:49:33 <ivanm> monochrom: it expected a cabal file in your project base; if it didn't, it would keep going further and further up the chain of directories; usually it would stop when it found ~/.cabal and thought that it was your project root directory
20:53:25 <Bluetar> hmm
20:53:32 <Bluetar> I'll try 2.7.0 now
20:55:25 <Bluetar> hmm
20:55:31 <gio123> does chanel has property to check whether a nick was available here?
20:55:32 <Bluetar> now it doesn't even load my .hs files anymore
20:55:47 <Bluetar> just says: "Invalid read syntax: "#""
20:58:11 <Bluetar> oh, funny, now I solved the whole issue by just commenting out the relevant lines in my init.el
20:58:12 <Bluetar> lol
20:58:29 <Bluetar> seems like this system has a proper mode installed meanwhile
20:59:38 <Bluetar> hmm, not really
20:59:48 <Bluetar> haskell-mode works, but not inferior haskell...
21:00:01 <yrlnry> I wrote this insert function, which works, but it has the form of a fold, and I feel like it's more code than it ought to be.  But I can't seem to improve it.
21:00:02 <yrlnry> http://pastebin.ca/1728088
21:00:11 <yrlnry> Does anyone have any helpful suggestions?
21:00:49 <gio123> does chanel has property to check whether a nick was available here?
21:02:21 <yrlnry>    
21:02:34 <Bluetar> yrlnry: this seems more like an "update" than an insert function to me
21:02:47 <Bluetar> it changes the relevant entry, doesn't add a new entry
21:03:03 <Bluetar> oh
21:03:03 <yrlnry> It does add a new entry if there was not one already.
21:03:08 <Bluetar> wait, it does add one, sorry
21:03:24 <yrlnry> Anyway, I am much more interested in how to make the code more compact, perhaps by turning it into an application of foldr.
21:03:25 <Bluetar> you could just use a lookup and then add one if it doesn't find it?
21:04:22 <aavogt> or use Data.Map
21:04:23 <yrlnry> Changing the representation of the data is not an option.
21:06:03 <BMeph> yrlnry: Why not? You can always change it back once you finish. :)
21:06:58 <yrlnry> The question I really want answered is the one I asked, not some larger question.
21:07:33 <yrlnry> It's nice that you're trying to help me improve the program, but right now I'm interested in this one particular point.
21:07:51 <Bluetar> I know what you want
21:08:01 <Bluetar> I'm still thinking if it could be done by a simple built-in function
21:08:08 <Bluetar> have you looked into "insertBy"?
21:08:14 <Bluetar> in Data.List?
21:08:59 <Axman6> :t insertBy
21:09:00 <lambdabot> forall a. (a -> a -> Ordering) -> a -> [a] -> [a]
21:09:54 <Bluetar> I guess it depends a little bit on what kind of keys you are using, like are they ordered or just random
21:10:15 <yrlnry> I had only been assuming Eq.
21:11:01 <Bluetar> hmm, then it's probably not possible to use that Ordering thing...
21:14:14 <Bluetar> hmm, inferior-haskell still won't really work
21:14:33 <Bluetar> now C-c C-l seems to load ghci in the background, but C-c C-i does just nothing
21:14:46 <Bluetar> it says it's not defined
21:14:54 <Bluetar> "C-c C-i not defined."
21:15:28 <yrlnry> Well, thanks.
21:20:11 <Bluetar> yrlnry: well, since the reference implementation of "insertBy" also uses a simple recursion like your code, I think it's not really worth to change it a lot
21:20:53 <Bluetar> yrlnry: http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/Data-List.html#insertBy
21:21:43 <Veinor> > show id
21:21:44 <lambdabot>   "{()->()}"
21:21:50 <Veinor> why does it do that?
21:23:21 <Veinor> > show (+1)
21:23:22 <lambdabot>   "{-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}"
21:23:24 <Veinor> Ah
21:23:49 <gio123> does anybody seen ski here today?
21:23:59 <tensorpudding> @seen ski
21:23:59 <lambdabot> Unknown command, try @list
21:24:44 <gio123> @list ski
21:24:44 <lambdabot> No module "ski" loaded
21:25:09 <Veinor> @list
21:25:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:25:17 <Veinor> @users ski
21:25:17 <lambdabot> Unknown command, try @list
21:25:24 <c_wraith> preflex: seen ski
21:25:24 <preflex>  ski was last seen on #haskell 2 days, 14 hours, 49 minutes and 50 seconds ago, saying: (obviously)
21:25:27 <Veinor> it says users and ski is in there, odd
21:25:51 <c_wraith> users and seen were removed from lambdabot, since they were broken
21:26:39 <Bluetar> great: by now, my xemacs installation seems to delete every source file I open :-O
21:26:44 <pikhq> Who wrote that show instance, anyways?
21:27:18 <c_wraith> it's from smallcheck
21:27:58 <Bluetar> ah, I found the problem...
21:28:22 <Bluetar> our project is using all kinds of ghc extensions and stuff... and inferior-haskell just starts up ghci without any additional flags...
21:28:38 <Bluetar> (in fact, in the default setting it even uses hugs)
21:29:17 <c_wraith> Bluetar: specify extensions and ghc options with in-file pragmas.
21:29:54 <Bluetar> c_wraith: well, I will try to do that in the future
21:30:02 <Bluetar> but there is no quick fix for this now I think
21:30:42 <c_wraith> It also generally is a bad approach for hide-package stil changes
21:30:46 <c_wraith> *style
21:31:28 <Bluetar> I'm not the one using those extensions
21:33:59 <aavogt> yrlnry: http://pastebin.ca/1728104
21:34:23 <aavogt> things can be written as foldr when they are not meant to be written as folds
21:35:18 <aavogt> also note that line 23 is terrible, and would be much more efficient as  itm:acc, but that fails the quickcheck
21:37:38 <yrlnry> aavogt:  that's even worse than what I had in mind.   Thanks.
21:37:52 <Bluetar> I think it's intentionally worse ;-)
21:38:21 <aavogt> Bluetar: you can do better?
21:38:27 <yrlnry> If I wanted it to be worse, i would have written it in Perl.
21:38:32 <aavogt> I didn't try to make it ugly ;)
21:38:52 <Bluetar> well, the goal is to make it nicer than the original code
21:39:02 <aavogt> the goal was to use foldr
21:39:59 <yrlnry> See line 6 of the original paste.
21:40:25 <yrlnry> What's `on`?
21:40:33 <aavogt> @type on
21:40:34 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:40:50 <yrlnry> @source on
21:40:50 <lambdabot> on not available
21:41:01 <yrlnry> Oh, I see.
21:41:11 <yrlnry> n/m, the type makes it clear.
21:41:24 <aavogt> on (*) f = \x y -> f x * f y
21:42:46 <aavogt> you don't need the last parenthese in:                                | otherwise = (k', p'):(insert (k,p) kps)
21:43:04 <Bluetar> hmm
21:43:09 <Bluetar> @type (.)
21:43:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:43:18 <aavogt> @type flip
21:43:19 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
21:43:25 <Bluetar> "on" looks like a flip (.)
21:43:41 <aavogt> @type flip fmap
21:43:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
21:44:25 <aavogt> @type flip fmap fmap
21:44:26 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => ((f a -> f b1) -> b) -> (a -> b1) -> b
21:44:42 <yrlnry> Is there a standard function like this:  onFst :: (t -> t2) -> (t, t1) -> (t2, t1)   ??
21:44:42 <aavogt> I'll stop now ;)
21:44:58 <aavogt> > first succ (0,0)
21:44:58 <yrlnry> Bleh, autogenerated type variables.
21:44:59 <lambdabot>   (1,0)
21:45:03 <yrlnry> Thanks.
21:45:12 <aavogt> @index first
21:45:13 <lambdabot> Control.Arrow
21:45:29 <yrlnry> Oh, right.  I knew that.
21:45:43 <Bluetar> what?
21:45:50 <Bluetar> now I'm confused
21:45:55 <yrlnry> @pl \f (a,b) -> (f a, b)
21:45:55 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
21:46:01 <yrlnry> BLARGH
21:46:10 <Bluetar> hmm
21:46:27 <aavogt> @type (`ap` snd) . (. fst) . ((,) .)
21:46:28 <Bluetar> ok, bye for now
21:46:28 <lambdabot> forall a a1 a2. (a1 -> a2) -> (a1, a) -> (a2, a)
21:47:22 <aavogt> @pl \f (a,b) -> (a,f b)
21:47:23 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
21:52:13 <yrlnry> Is there some binary division operator of type (Num a, Fractional b) => a -> a -> b ?
21:52:27 <yrlnry> Oh, (%).
21:55:25 <aavogt> @type (/) `on` fromIntegral
21:55:26 <lambdabot> forall b a. (Fractional b, Integral a) => a -> a -> b
22:14:54 <meanburrito920_> so I just tried to use darcs to get the ghc repo and i was getting download speeds of 10 kbps compared to 250 kbps on the ghc github repo. is haskell.org having connection issues or something?
22:15:04 <ivanm> could be
22:15:11 <ivanm> its only a dinky machine IIRC
22:15:29 <meanburrito920_> ah
22:15:37 <meanburrito920_> is darcs.haskell.org living on the same machine?
22:16:45 <ivanm> well, there's about 4 machines involved IIRC; not sure which one hosts what
22:17:41 <meanburrito920_> hm. anyhow, download speeds of 10 kbps seems a bit low, even for a dinky machine.
22:18:20 <jbe> Is there a shorthand for enumerating descending sequences?  [3..1] does not work.
22:18:51 <c_wraith> > [100,99..1]
22:18:52 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
22:19:28 <jbe> Nifty.  Thanks.
22:20:32 <meanburrito920_> so i pinged darcs.haskell.edu and it resolved to monk.galois.com and failed to get an ACK. I'm assuming it is galois that is having issues then.
22:20:49 <c_wraith> monk is the same machine that's had many other issues.
22:20:56 <byorgey> jbe: in general,  [a, b .. c]  enumerates starting with a in steps of (b - a)
22:21:05 <byorgey> > [1, 3 .. 11]
22:21:06 <lambdabot>   [1,3,5,7,9,11]
22:21:11 <c_wraith> also, monk is the server for hackage, iirc
22:21:37 <meanburrito920_> ah
22:22:15 <meanburrito920_> is there another darcs repo for ghc out there that is public?
22:22:22 <tensorpudding> > [1,2,3,5,7,11,13..23]
22:22:24 <lambdabot>   <no location info>: parse error on input `..'
22:22:40 <tensorpudding> hmm
22:22:50 <tensorpudding> > [7,11,13..23]
22:22:51 <lambdabot>   <no location info>: parse error on input `..'
22:23:14 <tensorpudding> guess it doesn't have magic sequence intuiting powers
22:24:17 <jbe> > take 10 primes
22:24:18 <lambdabot>   Not in scope: `primes'
22:26:27 <byorgey> @oeis 2 3 5 7 11 13
22:26:28 <lambdabot>  The prime numbers.
22:26:28 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:26:49 <byorgey> you can use Math.OEIS for magic sequence intuiting powers =)
22:27:27 <ivanm> @oeis 2 4 6 10 14
22:27:28 <lambdabot>  Numbers n such that n^2 + 1 is prime.
22:27:28 <lambdabot>  [1,2,4,6,10,14,16,20,24,26,36,40,54,56,66,74,84,90,94,110,116,120,124,126,13...
22:27:36 <ivanm> hmmm....
22:27:39 <jbe> Neat!
22:27:55 <kmc> @oeis 14 18 23 28 34 42 50
22:27:56 <lambdabot>  Local stops on New York City Broadway line subway.
22:27:56 <lambdabot>  [14,18,23,28,34,42,50,59,66,72,79,86,96,103,110,116,125,137,145,157,168,181,...
22:28:09 <jbe> heh
22:28:45 <ivanm> heh
22:29:01 <kmc> @oeis 14 34 42 72 96
22:29:02 <lambdabot>  Sequence not found.
22:29:02 <ivanm> @more
22:29:13 <ivanm> kmc: are you doing random numbers?
22:29:13 <JohnnyL> @heh
22:29:13 <lambdabot> Maybe you meant: help let
22:29:21 <kmc> no, those should be the express stops
22:29:36 <ivanm> oh, maybe it only does it in order?
22:30:21 <kmc> @oeis 4 14 23 34 42 50 59
22:30:21 <lambdabot>  Local stops on New York City A line subway.
22:30:21 <lambdabot>  [4,14,23,34,42,50,59,72,81,86,96,103,110,116,125,135,145,155,163,168,175,181...
22:30:33 <kmc> @oeis 4 14 34 42 59
22:30:34 <lambdabot>  Express stops with numerical values for A-train in Manhattan.
22:30:34 <lambdabot>  [4,14,34,42,59,125,145,168,175,181,190,200,207]
22:30:37 <kmc> ha!
22:31:07 <kmc> @vixen you must take the A train
22:31:07 <lambdabot> Thank God for AOL that I could meet people like you!
22:31:50 <ivanm> :o
22:31:56 <kmc> @oeis 6 21 107
22:31:56 <lambdabot>  Busy Beaver problem: maximal number of steps that an n-state Turing machine ...
22:31:56 <lambdabot>  [1,6,21,107]
22:32:31 <kmc> wikipedia says the next value is not known but is at least 47,176,870
22:32:50 <kmc> and the one after that is at least 2.5 x 10^2879
22:33:42 <kmc> indeed it grows faster than any computable sequence
22:34:35 <kmc> @oeis 2 3 5 13 65533
22:34:35 <lambdabot>  Ackermann's function A(n,0).
22:34:36 <lambdabot>  [1,2,3,5,13,65533]
22:35:47 <tensorpudding> A(4,4) is pretty big
22:51:12 <portnov> @oeis 1 2 2 3 5 8
22:51:13 <lambdabot>  Maximal coefficient of Product_{k<=n} (x^k+1). Number of solutions to +- 1 +...
22:51:13 <lambdabot>  [1,1,1,2,2,3,5,8,14,23,40,70,124,221,397,722,1314,2410,4441,8220,15272,28460...
22:51:41 <portnov> hm. I mean fibonacci sequence :)
22:51:50 <portnov> @oeis 1 1 2 3 5 8
22:51:51 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
22:51:52 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:51:52 <Gracenotes> it starts like 1 1 2
22:52:01 <portnov> yeah, i see )
22:52:05 <Gracenotes> many sequences exist with different seed numbers
22:52:14 <portnov> btw
22:52:27 <portnov> @oeis 4 1 5 6 11 17
22:52:28 <lambdabot>  5^n mod 19.
22:52:28 <lambdabot>  [1,5,6,11,17,9,7,16,4,1,5,6,11,17,9,7,16,4,1,5,6,11,17,9,7,16,4,1,5,6,11,17,...
22:53:19 <stoop> @oeis 1 9 11 20 25
22:53:20 <lambdabot>  Sequence not found.
22:53:43 <portnov> @oeis 1 9 11 20 31 51
22:53:44 <lambdabot>  Sequence not found.
22:54:44 <mle> @oeis 3 4 7 11 18 29
22:54:45 <lambdabot>  Lucas numbers (beginning at 2): L(n) = L(n-1) + L(n-2). (Cf. A000204.)
22:54:45 <lambdabot>  [2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127...
22:54:51 <Cale> @oeis 4 8 15 16 23 42
22:54:52 <lambdabot>  The Lost Numbers.
22:54:52 <lambdabot>  [4,8,15,16,23,42,108]
22:55:07 <mle> heh
22:55:38 <ski> @oeis 2 5 52 88 96
22:55:39 <lambdabot>  Untouchable numbers: impossible values for sum of aliquot parts of n.
22:55:39 <lambdabot>  [2,5,52,88,96,120,124,146,162,188,206,210,216,238,246,248,262,268,276,288,29...
22:57:13 <gio123> ski: hi
23:01:27 <lowki> how to and constant and int?
23:01:59 <lowki> i.e if 0o300 & x == 0o300 then
23:02:25 <kmc> look at Data.Bits
23:02:58 <kmc> > 0xBE .&. 0xEF
23:02:59 <lambdabot>   Ambiguous type variable `t' in the constraint:
23:02:59 <lambdabot>    `Data.Bits.Bits t'
23:02:59 <lambdabot>      a...
23:03:02 <kmc> > 0xBE .&. 0xEF :: Word8
23:03:04 <lambdabot>   174
23:03:53 <ski> > showHex (0xBE .&. 0xEF :: Word8) ""
23:03:54 <lambdabot>   "ae"
23:05:21 <lowki> yay it worked :D
23:05:33 <lowki> Cale: is your name based on the name of the vegetable Kale ?
23:06:03 <lowki> I have salad with Kale everyday, it's great, and so are you :D
23:07:23 <lowki> ski: hey do I remember you from #prolog?
23:07:30 <ski> possibly
23:07:44 <lowki> cool, you're quite a helpful person :)
23:07:56 <lowki> thanks
23:08:11 <ski> yw
23:08:58 <Cale> lowki: No, it's my actual name. There is an old name "Caleb" which it is derived from.
23:09:40 <Cale> > fix (interleave [1,3..])
23:09:41 <lambdabot>   [1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,3...
23:10:27 <Cale> > let oddPart n | even n = oddPart (n `div` 2) | otherwise = n in map oddPart [1..]
23:10:28 <lambdabot>   [1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,3...
23:14:12 <kmc> :O
23:14:53 <ski> > zipWith div [1..] . map (2^) . fix $ \xs -> repeat 0 /\/ map (1 +) xs
23:14:54 <kmc> fix.interleave is quite the function
23:14:54 <lambdabot>   [1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,3...
23:15:04 <kmc> :t (/\/)
23:15:05 <lambdabot> forall a. [a] -> [a] -> [a]
23:16:58 <lowki> how to find what is at particular bits place, like in the tens place of an oct bit string
23:17:02 <kmc> > map (head . dropWhile even . iterate (`div` 2)) [1..]
23:17:03 <lambdabot>   [1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27,7,29,15,3...
23:17:19 <kmc> lowki, how is your bit string represented?
23:17:24 <kmc> just an Int or a Word or such?
23:17:26 <lowki> Int
23:18:05 <kmc> so you want (n `div` 10) `mod` 10?
23:18:34 <kmc> > map ((`mod` 10) . (`div` 10)) [3, 12, 97, 142, 1678]
23:18:35 <lambdabot>   [0,1,9,4,7]
23:19:18 <lowki> > mod (div 0o340 0o10) 0o10
23:19:19 <lambdabot>   4
23:19:25 <lowki> > mod (div 0o380 0o10) 0o10
23:19:26 <lambdabot>   No instance for (GHC.Real.Integral (t -> a))
23:19:26 <lambdabot>    arising from a use of `GHC....
23:19:33 <lowki> > mod (div 0o370 0o10) 0o10
23:19:34 <lambdabot>   7
23:19:38 <lowki> ooo, magic :D
23:20:35 <kmc> that's not the tens place but whatever
23:21:19 <gio1234> ski: hi
23:22:47 <lowki> kmc: seems like it is to me
23:23:00 <lowki> tens in octal
23:23:43 <tensorpudding> @type 0o10
23:23:44 <lambdabot> forall t. (Num t) => t
23:23:47 <tensorpudding> hmm
23:23:51 <tensorpudding> > 0o10
23:23:53 <lambdabot>   8
23:24:00 <tensorpudding> > 0xFF
23:24:01 <lambdabot>   255
23:24:07 <tensorpudding> cool
23:24:54 <kmc> hmm i think "ten" is always the successor of the successor of the successor of the successor of the successor of the successor of the successor of the successor of the successor of the successor of zero, regardless of base
23:25:22 <kmc> but there is not perfect agreement on this nomenclature
23:25:36 <kmc> > 010
23:25:37 <lambdabot>   10
23:25:57 <Gracenotes> only one base is base 10_{10}
23:26:15 <Gracenotes> ..because by custom subscripts are written in that base >_>
23:26:16 <tensorpudding> > 0o12 == 10
23:26:18 <lambdabot>   True
23:26:27 <shachaf> Gracenotes: So you mean 10_{10_{10}}.
23:26:52 <Jafet> > repeat 10
23:26:53 <lambdabot>   [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10...
23:26:58 <lowki> hmm well I pronounce 0o10 as ten
23:27:03 <tensorpudding> obviously, we need to define haskell's integers using the peano axioms
23:27:23 <kmc> > genericLength [1..] > (4 :: Natural)
23:27:24 <lambdabot>   True
23:27:28 <Gracenotes> shachaf: yeah, peano is the only way to get it right
23:27:32 <Jafet> Define Haskell's integers in Agda!
23:27:41 <shachaf> kmc: If "ten" always means the number of fingers I have, what do other number words mean?
23:27:42 <kmc> > let omega :: Natural; omega = 1 + omega in omega > 3
23:27:44 <lambdabot>   True
23:27:49 <shachaf> kmc: Is "eleven" the successor of that number?
23:27:53 <kmc> > let omega :: Natural; omega = 1 + omega in omega < 3
23:27:54 <lambdabot>   False
23:28:09 <tensorpudding> is there an implementation of the surreal numbers in Haskell?
23:28:14 <kmc> shachaf, is this a trick question
23:28:19 <kmc> i.e. do you have 11 fingers
23:28:29 <shachaf> kmc: I have 10 fingers. :-)
23:28:29 <kmc> @vixen how many fingers do you have?
23:28:29 <lambdabot> lots
23:28:32 <kmc> @vixen can i borrow one?
23:28:33 <lambdabot> you sure can
23:28:40 <shachaf> kmc: (By your value of "ten".)
23:28:51 <jfischof> what characters can one use for operator overloading?
23:29:02 <Jafet> @vixen do you finger yourself?
23:29:02 <lambdabot> yes i do
23:29:09 * shachaf wishes he had 12 fingers now, for the purpose of further confusing base discussions.
23:29:10 <Gracenotes> what representation you use should not matter. the only thing that matters is consistency (and expressiveness, as needed)
23:29:15 <shachaf> We should all use base 12 anyway!
23:29:27 <shachaf> (12_10, that is.)
23:30:04 <kmc> jfischof, it's in the Haskell Report
23:30:12 <kmc> jfischof, section 2.2, "symbol"
23:30:13 <Jafet> Is that 10 12 or 10?
23:30:19 <Gracenotes> 9+1 should = the number of fingers we have, in any base
23:30:24 <jfischof> kmc: thanks
23:30:49 <Gracenotes> assuming the first 10 from zero on and be represented 0, 1, 2 .. 7, 8, 9
23:30:52 <kmc> jfischof, also, whether something is overloaded (part of a typeclass) is orthogonal to whether it's an operator
23:30:54 <Gracenotes> *can be
23:31:05 <shachaf> Gracenotes: What, so 9 means the predecessor of your current base?
23:31:34 <jfischof> kmc: ah, good point, because you can have free operators right?
23:32:05 <kmc> jfischof, yeah.  being an operator is a purely syntactic property
23:32:06 <Gracenotes> no, it means the successor of the successor blah blah of zero, however many times to convey our base
23:32:13 <Gracenotes> 9 in our base
23:32:23 <jfischof> kmc: cool, thanks for the info
23:32:26 <kmc> :)
