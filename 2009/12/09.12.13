00:00:21 <Tupac> > unfoldr (\x -> if null x then Nothing else Just $ splitAt 1 x) [1..]
00:00:22 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17...
00:00:28 <HaskellLove> Jafet kiss my ass man
00:00:36 <Tupac> lol
00:00:49 <aavogt> HaskellLove: it's a style thing... you could use     (\x -> case x of Pattern a b c -> ) instead of  (\x@(Pattern a b c) ->)
00:00:52 <Jafet> I can't, since you're talking from it.
00:00:54 <Axman6> HaskellLove: you will be banned. stop acting like such a dick
00:01:15 <HaskellLove> Axman6>well he is man, i asked him nicely if he prefers @
00:01:28 <Tupac> :t HaskellLove
00:01:31 <lambdabot> Not in scope: data constructor `HaskellLove'
00:02:06 <Jonno_FTW> :t haskell
00:02:07 <lambdabot> Not in scope: `haskell'
00:02:13 <Axman6> HaskellLove: i don't even understand the question, so i can see why Jafet  would be having problems with it
00:02:47 <Jafet> It's not a question. It's bait.
00:02:56 <HaskellLove> Axman6 well it is simple, how often do you use @ operator and do you find it usefull? see, i am new to haskell and i just read about it and i am interested if people use it thats all
00:03:18 <Axman6> i use it where it makes sense
00:03:35 <SimonRC> Axman6:
00:03:58 <aavogt> it's not that common though
00:04:35 <Jonno_FTW> i used @ one time
00:04:40 * gwern uses it every so often. it's *very* handy in xmonad configs
00:04:44 <Jonno_FTW> and i got the wrong answer
00:04:56 <Tupac> @src transpose
00:04:57 <lambdabot> transpose []             = []
00:04:57 <lambdabot> transpose ([]   : xss)   = transpose xss
00:04:57 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
00:05:11 <aavogt> as I showed, it's not much more convenient than using case
00:05:25 <HaskellLove> aavogt thanks man
00:06:01 <aavogt> but I think there is a mindset that when you use case that you need more than one alternative
00:06:08 <Jonno_FTW> how does @ even work?
00:06:33 <aavogt> then again, nested case expressions don't look so pretty
00:06:38 <eivuokko> Jonno_FTW, look at aavogt's example, it pretty much shows the crucial thing it does.
00:07:47 <SimonRC> oops
00:08:03 <SimonRC> Axman6: are you doing PE by any chance?
00:08:13 <Axman6> PE?
00:08:19 <Jonno_FTW> project euler
00:08:31 <Axman6> oh, i have, not for a long time though
00:08:49 <gwern> Jonno_FTW: @ works by: foo@(x:xs) = bar, now essentially, 'let foo = (x:xs) in bar'
00:09:00 <gwern> it cuts down on reundancy
00:09:10 <Jonno_FTW> ok
00:09:19 <gwern> look at xmonad configs sometime
00:09:36 <gwern> such as 'myKeys conf@(XConfig {modMask = m}) = M.fromList [ -- rebind standard keys
00:09:45 <aavogt> gwern: I think the translation to let is lazier than the as-pattern
00:10:12 <aavogt> > (\a -> let (x:xs) = a in True) []
00:10:13 <lambdabot>   True
00:10:19 <gwern> I could write 'XMonad.terminal (XConfig {modMask = m})', but I'd rather write 'XMonad.terminal conf'
00:10:25 <aavogt> > (\a@(x:xs) -> True) []
00:10:26 <lambdabot>   * Exception: <interactive>:1:130-146: Non-exhaustive patterns in lambda
00:10:38 <aavogt> > (\a@ ~(x:xs) -> True) []
00:10:39 <lambdabot>   True
00:10:44 <Berengal> > let fibs@(_:rest) = 0:1:zipWith (+) fibs rest in fibs
00:10:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:10:52 <Tupac> wonderful
00:11:06 <aavogt> > (\a -> case a of x:xs -> True) []
00:11:06 <lambdabot>   * Exception: <interactive>:1:140-161: Non-exhaustive patterns in case
00:11:08 <SimonRC> Axman6: it looked lik e you were trying to solve PE 9
00:11:22 <Axman6> ?
00:11:33 <Jonno_FTW> i am trying to solve 68
00:11:35 <HaskellLove> wow cool stuff guys thanks
00:11:47 <aavogt> gwern: of course, you can ignore laziness most of the time
00:11:55 <Jonno_FTW> lists2 = nub $ map sort [ [[a,b,c],[d,c,h],[e,h,i],[f,i,j],[g,j,b]] | n@[a,b,c,d,e,f,g,h,i,j] <- permutations [1..10], ring2 n ]
00:12:11 <Jonno_FTW> ring2 [a,b,c,d,e,f,g,h,i,j] = (length $ nub $ map sum [[a,b,c],[d,c,h],[e,h,i],[f,i,j],[g,j,b]]) == 1
00:12:20 <Jonno_FTW> what a mess
00:12:35 <gwern> aavogt: true enough; but I think the slight error is worth the intuitiveness of the let translation
00:13:37 <aavogt> too bad we lose such sensible ascii symbols like ~ @ to pattern syntax that people rarely use
00:13:48 <aavogt> as in, those are now reserved symbols
00:13:55 <eivuokko> gwern, assuming you want to build intuition on let and not on case.  (Just saying, the choice wouldn't be clear to me, were I to teach.)
00:14:16 <gwern> eivuokko: how would you do it for case?
00:14:30 <aavogt> aavogt | > (\a -> case a of x:xs -> True) []
00:14:31 <gwern> aavogt: can't say losing ~ or @ ever bothered me
00:14:40 <aavogt> that's because you never had them ;)
00:14:48 <Berengal> > let a @~ b = a + b in 1 @~ 2
00:14:51 <lambdabot>   3
00:15:07 <eivuokko> gwern, let is, if you want to take it so, syntactic sugar for.  Case is not.
00:15:09 <Jafet> We could lose that one.
00:15:34 <Jafet> Sure it is. Just implement it with pattern guards
00:16:07 <aavogt> haskell is definitely not a one-way-to-do-it language
00:16:25 * gwern thinks it should be, once we figure what the best way is
00:16:48 <Berengal> Using pattern guards and view patterns, you can keep most of your functions on the lhs even
00:18:12 <aavogt> view patterns are sort of opaque with respect to sharing of results between patterns
00:18:22 <Jafet> Someday we'll be able to express our frustration with Haskell syntax in the type system
00:18:53 * Berengal wants agda syntax
00:19:03 <aavogt> Berengal: or is there some easy way to know when ghc will not recompute the view functions?
00:19:17 <Craig`> hey
00:19:35 <Berengal> aavogt: No idea. You could probably hack something up with where or whatnot
00:20:06 <Craig`> BONUS, "The first one is an empty list, the seconds one is a list that contains one empty list, " shouldn't it be "the second one"? I'm not too good with grammar so I'm probably mistaken sorry.
00:20:10 <Twey> I think you probably shouldn't be using heavy-weight view functions…
00:20:35 <aavogt> there's a balance between explicit sharing when nesting case, and the ugliness that you get from such
00:20:59 <CalJohn> @src foldr
00:20:59 <lambdabot> foldr f z []     = z
00:20:59 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:21:07 <CalJohn> @src foldl
00:21:07 <lambdabot> foldl f z []     = z
00:21:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:21:17 <Craig`> # [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
00:21:17 <Craig`> # ghci> b !! 2
00:21:17 <Craig`> # [1,2,2,3,4]
00:21:19 <lunabot>  luna: parse error on input `|]'
00:21:19 <lunabot>  luna: parse error on input `|]'
00:21:22 <lunabot>  luna: parse error on input `|]'
00:21:23 <Craig`> wouldn't it return [5,3,3,3]?
00:21:27 <Berengal> Twey: It's a bit hard to say where you should stop though. If you've got an opaque datatype and some view functions on it, you have no idea of knowing how expensive those are
00:21:48 <Tupac> @src zipWith
00:21:48 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
00:21:48 <lambdabot> zipWith _ _      _      = []
00:21:57 <Twey> Documentation should really give you some idea of performance
00:22:00 <Jafet> > let b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] in b !! 2
00:22:01 <lambdabot>   [5,3,3,3]
00:22:17 <Twey> The Data.Map functions all have big-O notes, for example
00:22:26 <HaskellLove> what does ' mean in (x:xs') ?
00:22:27 <Berengal> Yeah, that helps
00:22:27 <Tupac> just awesome
00:22:37 <Berengal> HaskellLove: It's just another letter
00:22:56 <Craig`> nevermind about my last question,
00:23:08 <Twey> We usually use it to mean ‘slightly modified’
00:23:11 <HaskellLove> Berengal> oh ok, tnx
00:23:36 <aavogt> anyways, it should be easy enough to track down when profiling when something is being excessively recomputed, if it turns out to be a problem
00:23:46 <Berengal> HaskellLove: We often put it behind names that already exist, to signify that the new name is related, but different, somehow to other old name
00:24:12 <aavogt> needs more pointfree
00:25:06 <Jonno_FTW> can someone identify what i have done wrong here?
00:25:08 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14102#a14102
00:25:14 <HugoDaniel> HaskellLove: i love you :)
00:25:43 <Jonno_FTW> it gives 432513621 instead of 432621513
00:26:04 <HaskellLove> Jonno_FTW>	what euler is that?
00:26:21 <Jonno_FTW> 68
00:26:27 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=68
00:26:45 <HaskellLove> Jonno_FTW holy shit :D, i am gonna stay out of it i am on 11, far from you
00:26:53 <Jonno_FTW> oh right
00:27:15 <Jonno_FTW> always check for the given example if there is one
00:27:39 <Jonno_FTW> for 11 all you need to do is look around
00:28:16 <Craig`> init takes a list and returns everything except it's last element, may I ask why it's named init?
00:28:31 <aavogt> initial part of the list
00:28:52 <cizra> http://book.consumerhelpweb.com/awards/badsex/winners.htm -- Excerpts from books that won the "Bad sex in fiction" award. Much hilarity.
00:29:16 <Jonno_FTW> HaskellLove, i wouldn't suggest making a haskell solution for 11 atm,
00:29:25 <sinelaw> as long as the different ways are semantically equivalent, it's ok
00:29:38 <Tupac> > transpose [[1..],[2..]]
00:29:39 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12...
00:29:40 <HaskellLove> Jonno_FTW>	well i am close to finish it in haskell so...
00:29:49 <Jonno_FTW> wow
00:29:54 <Jonno_FTW> i'd like to see your solution
00:30:01 <Tupac> > transpose [[5..],[10..]]
00:30:02 <lambdabot>   [[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19]...
00:30:10 <Jonno_FTW> i just looked at the grid while thinking of a solution and found the answer
00:31:47 <HaskellLove> Jonno_FTW as far as looking around, that is not the point, i solve without checking out other solutions i just do it my way, that is how u learn, as for the solution keep checking my blog it will be there tomorow if not today : http://haskelllove.wordpress.com/
00:33:37 <Jonno_FTW> bookmark'd
00:34:25 <Jonno_FTW> can anyone else help thoguh
00:34:27 <Jonno_FTW> ?
00:35:21 <Tupac> > foldr f z [q, e, d]
00:35:22 <lambdabot>   f q (f e (f d z))
00:37:32 <Jafet> Jonno, seems that you're bruteforcing it
00:37:42 <Jonno_FTW> yep
00:37:48 <Jonno_FTW> it only takes 10 seconds
00:37:52 <Jonno_FTW> or so
00:38:08 <Jonno_FTW> it seems it is missing the solution
00:39:51 <HaskellLove> data Celebration = Birthday String Int Int Int, why is this wrong, it is even from a book not by me...
00:40:42 <Paczesiowa> HaskellLove: what's wrong?
00:40:57 <HaskellLove> parse error on input `data'
00:41:10 <Paczesiowa> HaskellLove: indentation?
00:41:14 <monochrom> Do you realize you come across as "f x = x  why is this wrong"
00:41:37 <Jafet> Jonno, I ran it and got the expected answer
00:41:45 <Jonno_FTW> ok
00:41:48 <Jonno_FTW> how long?
00:42:06 <Jafet> Wait, I got your answer
00:42:09 <HaskellLove> Paczesiowa> no i tried it like 100 times no indentations
00:42:16 <Jonno_FTW> yeah
00:42:32 <Jafet> You cannot declare data types in ghci, can you?
00:42:32 <Jonno_FTW> it seems to be misssing that one crucial solution
00:42:49 <monochrom> Try #haskell-paranormal for unexplained, only-you-saw-it phenomena.
00:43:11 <Paczesiowa> not funny...
00:43:37 <Jonno_FTW> 28731045486110971 is what it gives for main solution but that is wrong
00:44:17 <HaskellLove> Jafet yes but i tried to load from file, same thing
00:44:31 <Jafet> Then show the file
00:44:51 <ziman> HaskellLove, we cannot help you without you providing us context; stick the source code into a pastebin and post the link instead
00:45:40 <Tupac> foldr > let ?a = 2 in let ?a = ?a + 1 in ?a
00:45:50 <Tupac> > let ?a = 2 in let ?a = ?a + 1 in ?a
00:45:51 <lambdabot>   3
00:46:36 <HaskellLove> ziman ok got it working now, i loaded wrong file... kick me ... ah ah .. ouch, stupid me
00:50:08 <MarcWeber> nagnatron, Axman6 ssh haskell_demo@mawercer.de -p8010 (If someone else is interested in scion, tags and hack-nix let me know) I'll send you the password by private message
00:50:10 <Jonno_FTW> i know what i did wrong
00:50:24 <Jonno_FTW> it needs a 16 bit string rather than 17
00:51:44 <Jonno_FTW> s/bit/byte/
01:00:41 <Craig`> even the starting out tutorial on LYAH contains so much great information :)
01:02:49 <Paczesiowa> MarcWeber: what interesting things can scion do?
01:02:58 <Tupac> > let Craig n = ((-1)^n)/(2*fromIntegral n+1) in map Craig [0..10]
01:02:59 <lambdabot>   Not in scope: data constructor `Craig'Not in scope: data constructor `Craig'
01:03:05 <MarcWeber> Paczesiowa It can do on the fly checking of your .hs files.
01:03:12 <Tupac> > let craig n = ((-1)^n)/(2*fromIntegral n+1) in map craig [0..10]
01:03:13 <lambdabot>   [1.0,-0.3333333333333333,0.2,-0.14285714285714285,0.1111111111111111,-9.090...
01:03:14 <Paczesiowa> MarcWeber: for emacs users
01:03:20 <MarcWeber> Paczesiowa: emacs and vim.
01:03:37 <Craig`> :)
01:03:41 <MarcWeber> However I never really figured out how to use the Emacs interface. But it is in use
01:03:42 <Paczesiowa> MarcWeber: that's it?
01:04:23 <Craig`> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]  is pretty cool
01:04:43 <MarcWeber> Paczesiowa: In the future it will be able to add import statements etc.
01:05:17 <Paczesiowa> I could imagine a few great uses for a tool like that - e.g. indentation helper
01:05:32 <MarcWeber> Paczesiowa: Can you join? I'll show you the vim backend.
01:05:51 <Paczesiowa> MarcWeber: I can't vim:(
01:10:12 <Craig`> vim is surprisingly cool :)
01:15:42 <Craig`> is it best to write: function :: String -> String or.. function :: [Char] -> [Char] or is it just personal taste?
01:18:55 <byorgey> I was going to answer Craig` and then realized he just left =(
01:19:21 <Twey> Yeah, heh
01:19:22 <Twey> Same
01:19:34 <byorgey> Craig`, come back!  I'm sorry we ignored you!
01:20:08 <Paczesiowa> use lambdabot:)
01:20:09 * byorgey writes a 100-line program in PHP as penance
01:20:40 <akappa> byorgey, in bash scripting, please.
01:20:49 <byorgey> @tell Craig` String -> String would be more idiomatic.
01:20:50 <lambdabot> Consider it noted.
01:21:11 <akappa> @quote php
01:21:11 <lambdabot> int-e says: PHP is a programming language like penguins are birds. And people try to make it fly.
01:21:28 <Twey> @tell Craig` Nobody writes functions on [Char] unless the Chars are really to be considered separately, not as a string.
01:21:28 <lambdabot> Consider it noted.
01:21:38 <akappa> mmh, too mild
01:21:46 <akappa> @quote c++
01:21:46 <lambdabot> monochrom says: Conspiracy theory: Java is designed to undermine static typing.
01:21:50 <Twey> @quote php
01:21:51 <lambdabot> qwe1234 says: i'm still waiting for the list of differences between lisp and php that matter.
01:21:55 <Twey> o.@
01:22:05 <akappa> lol
01:22:08 <Twey> It takes all sorts.
01:23:02 <p_l> I find the Penguin comment to be offensive to penguins :P
01:23:13 <byorgey> yeah, penguins are pretty cool
01:23:37 <akappa> too bad now they're recognized as a nerd pride symbol :(
01:23:38 <Stinger> penguins are stealing our goddamn jobs
01:24:02 <p_l> penguins are cool, some even got to officer ranks in military
01:24:09 <Berengal> At least people aren't trying to get penguins to fly
01:24:40 <p_l> they do regiment inspections just fine, though
01:24:44 * Twey throws a penguin off a cliff experimentally.
01:25:16 <Berengal> @where penguins
01:25:16 <lambdabot> I know nothing about penguins.
01:25:18 * p_l sees Twey being caught by the penguin screaming "I won't go down alone"
01:25:28 <Twey> Heheh.
01:25:46 <akappa> Twey, have you implanted some trees in the wall of the cliff?
01:26:17 <Twey> Of course.  Graceful failure is always a good thing.
01:26:42 <Berengal> I prefer provable correctness
01:26:47 <akappa> (for those of you who didn't catch the "citation": http://www.youtube.com/watch?v=sdUUx5FdySs)
01:36:33 <necroforest> Has anyone had a problem with GHC not being able to find 'Data.Word' when installing the Haskell Platform source tarball?
01:36:39 <necroforest> Specifically on the OpenGL module
01:36:59 <sauf> hi, is there a magic (efficient) function which permits [f x rest | (x,rest) <- magic xs] instead of writing [f x rest | x <- xs, let rest = xs \\ [x]] ?
01:38:47 <sjanssen> necroforest: what version of GHC?
01:39:04 <necroforest> 6.10.4
01:39:07 <necroforest> Ubuntu 9.10
01:39:11 <Jafet> sauf, if you want a set data structure, use a set data structure
01:39:44 <_Jedai_> sauf: not really, except if you mean [f x rest | (x:rest) <- tails xs]
01:40:01 <sauf> Jafet: no, elements can be repeated
01:40:18 <sjanssen> sauf: if elements can be repeated, your code is probably wrong
01:40:22 <_Jedai_> sauf: then a multiset
01:40:23 <necroforest> sjanssen, with the packaged version of GHC (not self-compiled)
01:40:42 <sauf> sjanssen: why ?
01:40:43 <sjanssen> (\\) will only delete the first instance of an element
01:41:17 <Berengal> > [1,1,1] \\ [1]
01:41:18 <lambdabot>   [1,1]
01:41:25 <sjanssen> necroforest: hmm, not sure why that would happen.  Can you verify that your GHC can compile simple programs?
01:41:38 * hackagebot upload: OpenVG 0.4.0 - OpenVG (ShivaVG-0.2.1) binding (StephenTetley)
01:41:39 <necroforest> yeah, i compiled some stuff with it earlier today
01:41:47 <sjanssen> necroforest: a good test would be "import Data.Word; main = print (1 :: Word)"
01:41:50 <Paczesiowa> necroforest: what about ghc-pkg list ?
01:42:18 <byorgey> sauf: no, but you can write such a function yourself, like this:
01:42:21 <byorgey> > let select [] = []; select (x:xs) = (x,xs) : map (second (x:)) (select xs) in select [1,2,3,4]
01:42:22 <sjanssen> sauf: there is a "select" function floating around somewhere that has type [a] -> [(a, [a])]
01:42:27 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
01:42:34 <Jafet> @hoogle select
01:42:34 <lambdabot> Text.Html select :: Html -> Html
01:42:34 <lambdabot> Text.XHtml.Frameset select :: Html -> Html
01:42:34 <lambdabot> Text.XHtml.Strict select :: Html -> Html
01:42:42 <Jafet> Nope
01:42:48 <necroforest> sjanssen, that worked
01:42:58 <sjanssen> Jafet: it's not in the standard libraries
01:42:59 <byorgey> it is floating around right above sjanssen's head
01:43:05 <sauf> byorgey: cool, thanks
01:43:27 <sjanssen> byorgey: do you know if that is in some library, or is it just in folklore?
01:43:38 <byorgey> sjanssen: just folklore as far as I know.
01:43:52 <Berengal> It's in the prolog standard library...
01:44:23 <byorgey> but then again, Hackage is rather large... =)
01:54:46 <HaskellLove> is there a function in haskell to convert a list to array or i will have to write one?
01:56:52 <xerox> HaskellLove: I'd guess it's called fromList
01:56:56 <xerox> ?docs Data.Array
01:56:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
01:57:10 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/array/Data-Array.html actually
01:57:10 <BONUS> :t listArray
01:57:11 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
01:58:30 <ddarius> @hoogle listArray
01:58:30 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
01:58:30 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
01:58:40 <ddarius> @index listArray
01:58:40 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
01:59:03 * ddarius doesn't know how one knows how to use arrays but didn't notice listArray.
02:02:13 <sinelaw> @hoogle ddarius
02:02:13 <lambdabot> No results found
02:07:56 <shepheb> is there a weapon of choice for accessors? data-accessors?
02:12:32 <HaskellLove> hasBiggerThen_n (x,y) n = if (or [x>n, y>n]) then True else False ------------- why this function returns me False for hasBiggerThen_n (20,30) 40 ???
02:12:55 <EvanR> hmmmm http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
02:13:09 <benmachine> HaskellLove: because netiher 20 nor 30 are bigger than 40?
02:13:22 <benmachine> also, you're doing the "then True else False" thing again
02:13:36 <benmachine> the or function already returns a Bool
02:14:08 <xerox> HaskellLove: because neither 20 nor 30 are bigger than 40
02:14:13 <HaskellLove> benmachine ah yes i fliped the signs, sorry...
02:14:48 <HaskellLove> hasBiggerThen_n (x,y) n = or [x<n, y<n]
02:14:51 <HaskellLove> done
02:14:54 <xerox> HaskellLove: also it's "than" not "then"
02:14:59 <Cromulent> hmm does anyone know of a decent haskell text editor on mac os x that has syntax highlighting? (not vi or emacs please :))
02:15:09 <xerox> Cromulent: yi!
02:15:09 <aavogt> HaskellLove: redundant parentheses in the if... look at hlint for style suggestions
02:15:15 <aavogt> @where hlint
02:15:15 <lambdabot> I know nothing about hlint.
02:15:21 <medfly> HaskellLove, than
02:15:27 <aavogt> @googl hlint
02:15:27 <lambdabot> Maybe you meant: google googleit
02:15:31 <aavogt> @google hlint
02:15:32 <lambdabot> http://community.haskell.org/~ndm/hlint/
02:15:32 <lambdabot> Title: Neil Mitchell - HLint
02:15:43 <aavogt> @where+ hlint http://community.haskell.org/~ndm/hlint/
02:15:43 <lambdabot> I will remember.
02:15:55 <medfly> HaskellLove, sorry. I just read code with too many spelling mistakes.
02:16:25 <Cromulent> xerox: oh that looks quite good - thanks for the tip - I'll have to read a little about it
02:16:27 <HaskellLove> medfly it is ok i did it read last post : hasBiggerThen_n (x,y) n = or [x<n, y<n]
02:16:57 <xerox> Cromulent: it has got vi-like and emacs-like keybindings though, not sure it's what you want. But it's extensible in Haskell, which is nice.
02:17:01 <benmachine> or [x<n, y<x] is fairly pointless btw
02:17:09 <benmachine> erm
02:17:12 <benmachine> do you know about ||
02:17:16 <benmachine> :t (||)
02:17:17 <lambdabot> Bool -> Bool -> Bool
02:17:23 <HaskellLove> yep
02:17:34 <HaskellLove> it is the same thing but here it is infix
02:17:46 <benmachine> or [x < n, y < n] == x < n || y < n
02:18:01 <benmachine> the or function operates on lists
02:18:08 <benmachine> you don't need to make a list here
02:18:29 <xerox> (it's not *too* bad, maybe it'll be simplified by the compiler.)
02:18:33 <Cromulent> xerox: I'll cope - I just find vi a little tedious at times as I am not that comfortable with it yet
02:19:11 <xerox> Cromulent: I myself prefere emacs + haskell-mode, basically for C-c C-l and that I'm used to emacs-like key bindings.
02:19:21 <benmachine> Cromulent: this made me better at vimming: http://www.viemu.com/a-why-vi-vim.html
02:19:40 <benmachine> if you are interested in becoming so
02:19:44 <HaskellLove> benmachine>	on second thought i like it that way, thank you ... i am close to euler 11 solution by the way
02:20:03 <p_l> EvanR: sad but ture
02:20:06 <p_l> *true
02:20:14 <EvanR> heh
02:20:43 <Cromulent> thanks guys
02:20:56 * benmachine looks at his euler stuff
02:21:02 <benmachine> I remember 11 taking me quite a while
02:21:26 * benmachine has only done the first 18
02:21:34 <benmachine> (and 67 which is basically the same as 18)
02:26:29 <sinelaw> benmachine, is it worth it?
02:29:37 <SimonRC> PE 12 is a nice PE-y one
02:29:55 <SimonRC> once you see the trick, getting the answer in a reasonable time is simple
02:30:12 <SimonRC> if you don't see the trick, it is almost impossible
02:30:51 <CalJohn> is (read . B.unpack) defined somewhere in a library (hopefully without the intermediate conversion to String?)
02:31:07 <ddarius> CalJohn: For some types, yes.
02:34:05 <Ferdirand>        à
02:34:07 <Twey> SimonRC: Hmm… is the trick to do with the fact that the number of factors only increases when the new term is more than twice the value of the greatest factor of the previous value?
02:34:29 <Ferdirand> oops
02:34:32 <SimonRC> Twey: no
02:34:39 * Twey laughs.
02:35:01 <SimonRC> the trick is that every triangular number has a trivial factorisation, because it has the same area as a rectangle
02:35:53 <SimonRC> and importantly, there are no factors in common between the two trivial factors, so the number of divisors of the triangle number is the product of the number of divisors of those two trivil factors
02:36:13 <SimonRC> the triangle number is n(n+1)/2
02:36:22 <SimonRC> exactly one of n or n+1 will be even
02:36:40 <SimonRC> so you halve one of the and leave the other alone to get a and b
02:36:46 <SimonRC> and a*b = T
02:36:57 <Twey> Ahh
02:37:14 <SimonRC> HCF(a,b) = 1, so divs(a*b) = divs(a) * divs(b)
02:37:46 <SimonRC> you can think of T and its divisors as points in an infinite-dimensional space (with one dimension for each prime number)
02:37:53 <SimonRC> or maybe not
02:37:55 <jeff_s_> I am writing a paper that includes some Haskell code. I am using Testing.QuickCheck.Gen to produce some random values. I'm wondering if there's a proper way to refer to where I'm getting the random numbers from. Do I refer to stdGen, Gen typeclass, Gen monad? Any of them?
02:38:08 <SimonRC> anyway, this way I got a constant-space solution
02:38:09 <jeff_s_> BTW I'm liking haskell more and more as I use it!
02:38:13 <SimonRC> only 3 blocks of Forth
02:38:20 <SimonRC> oops, 2 blocks
02:39:07 <SimonRC> jeff_s_: have a look at the source of Testing.QuickCheck.Gen?
02:39:16 <SimonRC> I dunno
02:39:22 <jeff_s_> oh, nto a bad idea ><
02:39:47 <SimonRC> the online pages will have links in the docs
02:39:50 <SimonRC> I think
02:41:49 <jeff_s_> the source at http://www.haskell.org/ghc/docs/latest/html/libraries/QuickCheck/src/Test-QuickCheck.html isn't commented. I mean I have a good idea of what's going on, Gen is a wrapper for functions that take a seed and a StdGen.
02:42:11 <jeff_s_> or... I know there's a paper introducing quickcheck, maybe I can find it.
02:42:44 <sinelaw> the hackage package links to it
02:43:29 <sinelaw> http://www.cs.chalmers.se/~koen/pubs/entry-tt04-quickcheck.html
02:43:42 <sinelaw> http://www.cs.chalmers.se/~koen/pubs/entry-fop-quickcheck.html
02:43:50 <jeff_s_> thanks, checkign taht out
02:44:16 <sinelaw> and finally this:
02:44:16 <sinelaw> http://www.cs.chalmers.se/~koen/pubs/entry-icfp00-quickcheck.html
02:47:42 <sinelaw> does anyone know how recursion works in yampa?
02:51:59 <benmachine> SimonRC: looks like I did problem 12 the boring way, and it still takes less than a second
02:52:34 <benmachine> does take 121MB of memory though :o
02:53:51 <benmachine> sinelaw: re: is project euler worth it... I don't think I learnt a lot about haskell doing it, but it was quite fun
02:53:54 <HaskellLove> arr ! x where x <- [(0,0), (2,3), (3,4)] -------------- What is wrong here? By the way, arr is 20 x 20 array
02:54:15 <benmachine> erm, what are you expecting the <- to do?
02:54:25 <benmachine> <- is only valid in list comprehensions/do notation
02:55:04 <ziman> HaskellLove, did you mean [arr!x | x <- [(0,0), (2,3), (3,4)]] ?
02:55:20 <benmachine> or map (arr !) [(0,0), (2,3), (3,4)]
02:55:42 <benmachine> which is much better for various vague reasons
02:55:47 <HaskellLove> sweet cool, thank you guys, oh i am so close to ending euler 11 :D thank you i love u
02:56:14 <sinelaw> omg omg
02:56:37 <sinelaw> > repeat "omg"
02:56:37 <lambdabot>   ["omg","omg","omg","omg","omg","omg","omg","omg","omg","omg","omg","omg","o...
02:56:46 <benmachine> > cycle "omg "
02:56:47 <lambdabot>   "omg omg omg omg omg omg omg omg omg omg omg omg omg omg omg omg omg omg om...
02:57:17 <HaskellLove> > repeat "HaskellLove loves you all"
02:57:18 <lambdabot>   ["HaskellLove loves you all","HaskellLove loves you all","HaskellLove loves...
02:57:37 <sinelaw> HaskellLove, sorry, most of us were born long before the word 'u' was invented. No offense intended
02:58:09 * benmachine wonders if he is younger than "u"
02:58:10 <HaskellLove> sinelaw, ok wont use it again
02:58:17 <sinelaw> keep going with euler, though. I never tried.
02:58:20 <benmachine> I'm older than texting but younger than the internet
02:58:37 <HaskellLove> i aint that young man i am 21
02:58:41 <sinelaw> benmachine, so am I.
02:58:59 * benmachine is 18
02:59:06 <sinelaw> omg
02:59:15 <benmachine> omg omg?
02:59:16 <lament> Being older than some word is a particularly bad reason to not use it
03:00:00 <benmachine> it's not a *particularly* bad reason
03:00:06 <benmachine> there are wrose
03:00:08 <benmachine> worse
03:00:09 <HaskellLove> young people here wow, you make me feel retarded asking these questions :(
03:00:15 <benmachine> but it's not a superb one.
03:00:29 <zoli> has anyone already read Computational Semantics with Functional Programming by Eijck and Unger?
03:01:09 <sinelaw> lament, condone me, surmise thou'set sermonize upon thy declaration?
03:01:24 * benmachine hugs sinelaw 
03:01:47 <sinelaw> parse error
03:01:51 <lament> sinelaw: sorry, i was born long after those words were invented
03:02:28 <sinelaw> yeah me too, but I have 'dict' installed
03:02:31 <HaskellLove> benmachine how come so young and in functional programming man? :( wish i had that, i feel now like old fart starting func now
03:02:32 <sinelaw> with a thesaurus
03:02:57 <benmachine> HaskellLove: three years is a pretty small difference
03:03:06 <benmachine> if it makes you feel any better I'm 19 in 15 days' time :P
03:03:18 <mkaemmer> zoli: er, no.  can you link to it? :)
03:03:22 <ziman> HaskellLove, I started when I was 21, too; if that makes you any happier :)
03:03:28 <HaskellLove> benmachine oh that feels better man, two years thanks
03:03:31 <sinelaw> a thesaurus, incidentally, is THE dinosaur
03:03:37 <nineteen> young ppl drink tea?
03:03:48 * ddarius started Haskell at 17 (he thinks).
03:03:50 <ezyang> nineteen: Yes!
03:03:51 <HaskellLove> ziman oh man u save me from some frustrations thanks :D
03:03:53 * ddarius is far from 17 now.
03:04:09 <HaskellLove> ddarius is a haskell ninja now :)
03:04:09 <sinelaw> I started it at 27.
03:04:10 <nineteen> *g00d*
03:04:14 <ddarius> nineteen: What else should they drink?
03:04:31 * benmachine lemondae
03:04:32 <benmachine> er, ade
03:04:36 <nineteen> oh im 33 yrs old i dont get it
03:04:40 * ddarius drinks both tea and lemonade.
03:04:41 <HaskellLove> sinelaw oh man god bless u, anyone else wants to remove my complexes and frustrations?
03:04:47 <omnivore> latex/ literate haskell question:
03:04:57 <sinelaw> yes, I had my first child before I started learning haskell
03:05:09 <HaskellLove> sinelaw thank you man
03:05:24 <HaskellLove> shit I feel a lot smarter now :D thanks guys
03:05:35 <sinelaw> on the other hand, I can spell.
03:05:43 <medfly> lol
03:05:47 <ddarius> But not capitalize.
03:05:48 <sinelaw> (with a spell checker of course)
03:05:51 <Ferdirand> leMonade ?
03:05:51 <medfly> what if you had your first child when you were 14?
03:05:52 <HaskellLove> that was low
03:05:56 <omnivore> All commands for typesetting code involve verbatim environment. But these cannot be used inside another environment or command. (like\ignore etc)
03:06:04 <omnivore> Any way around this?
03:06:07 <sinelaw> ddarius, correct
03:06:12 <HaskellLove> hahaha medfly u crazy ninja
03:06:23 <nagnatron> that kid in the uk got a kid very early, maybe he should be introduced to haskell
03:06:30 <medfly> lol
03:06:40 <sinelaw> medfly, not really. Maybe I should start teaching him haskell now, when he's 2
03:06:53 <ddarius> sinelaw: He's already behind the curve.
03:06:53 <sinelaw> he already knows how to say "pi"
03:07:00 <HaskellLove> sinelaw get your kid here man, i am opening a ninja school
03:07:06 <ddarius> sinelaw: You can teach him a dependently typed language then.
03:07:10 <medfly> sinelaw, you should send him to a development expert.
03:07:28 <medfly> wow, I'm old now.
03:07:32 * medfly notices that.
03:08:06 <medfly> I have this fear of becoming old.
03:08:13 <ddarius> medfly: Then don't.
03:08:19 <sinelaw> Exactly
03:08:34 <medfly> there's suicide at 30, but that's not my kind of thing.
03:08:51 <HaskellLove> there is a guy at stanford has pills that will stop u aging go get him
03:08:55 <nagnatron> I have that fear too but I'm comforted by the idea of having a white beard.
03:08:57 <sinelaw> It's all in the mind, well at least until you start feeling chronic pain
03:09:11 <medfly> :(
03:09:16 <sinelaw> nagnatron, heh
03:10:08 <ddarius> If I become old, I'm going to use my age to become a lecherous, crotchety, old guy.
03:10:13 <zoli> mkaemmer http://homepages.cwi.nl/~jve/cs/
03:10:20 <Twey> Hear hear, ddarius!
03:10:28 <Twey> 19:00:27 < sinelaw> he already knows how to say "pi"
03:10:41 <Twey> sinelaw: Properly, or in Anglibastardised pronunciation?  ;)
03:10:47 <medfly> that's valid Haskell?
03:11:04 <sinelaw> Twey, how does one pronounce it "properly"?
03:11:17 <Twey> /pi/, of course :þ
03:11:26 <sinelaw> oh great
03:11:33 <aavogt> more like pee?
03:11:45 <medfly> I think he can say pi that way, Twey
03:11:47 <aavogt> than pie?
03:11:50 <Twey> Ayup
03:11:54 <medfly> ;)
03:12:00 <Twey> Hehe
03:12:01 <ddarius> You have to raise the latter half by a perfect fifth.
03:12:20 <sinelaw> he says that too, but he does'nt necessarily mean the mathematical constant
03:12:34 <medfly> though I don't know if he means that when saying pi too...
03:13:20 <sinelaw> ok, back to work.
03:16:20 <sauf> thx guys, bye
03:46:41 <Craig`> Hello again :)
03:46:41 <lambdabot> Craig`: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:48:57 <mreh> is anyone looking into haskell coded flash animations and interactive flash apps?
03:49:08 <Voker57> haxe?
03:50:40 <HaskellLove> wohooo Euler 11 solved http://haskelllove.wordpress.com/
03:50:55 <Craig`> HaskellLove, how long have you been programming haskell? just starting?
03:51:04 <MarcWeber> nominolo_: I have two patches for scion again. The load component broke. When using cabal contsraints which can't be satisfied the error message (ExitFailure 1) is not very helpful.
03:51:44 <mreh> Voker57, I was thinking more along the lines of haskell bindings for flash
03:51:46 <HaskellLove> Craig - a week maybe
03:51:52 <sproingie> haxe's an interesting language, ain't haskell tho
03:51:55 <mreh> haXe appears to be its own language
03:52:03 <Craig`> oh cool :)
03:52:10 * hackagebot upload: hpage 0.5.2 - A scrapbook for Haskell developers (FernandoBenavides)
03:52:55 <Voker57> hm something made me think that it has haskell
03:53:00 <Voker57> probably its name
03:53:04 <sproingie> yep
03:53:16 <sproingie> it looks mostly like java
03:53:29 <sproingie> or javascript really
03:53:39 <HaskellLove> Craig - first 4 I did in scala, from then one i left it and now i am with haskell forever :)
03:54:29 <EvanR> so the type of main is IO (), but in ghci i can make main equal any type IO a....
03:55:00 <sproingie> pretty sure that's considered a misfeature
03:55:07 <sproingie> i wouldnt rely too much on it
03:55:11 <EvanR> ok so in real life i want to return IO ()
03:56:07 <Craig`> HaskellLove, awesome :) I'm just working through LYAH atm, and then I may try and do some :) most of my thoughts of how to do stuff are in ruby code atm heh
03:58:13 <HaskellLove> Craig` yeah implementation is only way to learn language that is why i do it... on the surface you may get in the "this is straight forward" trap, but once u start implementing u see it is not so easy and that is when real learning begins i think
03:58:29 <Craig`> :)
03:59:11 <Craig`> I'm kinda learning the basics, and then I'll try to apply what I've learnt heh
04:00:16 <HaskellLove> well i was haskell noob to the extreme and i just jumped on euler so... in a week on euler with haskell i will be more like intermediate haha
04:00:36 <Craig`> awesome :)
04:01:26 <dh___> good morning guys. I'm trying to put the definition of Primitive recurisve function into Haskell, following is the defintion of Primitive Recursive functions.
04:02:33 <byorgey> hey there Craig`, welcome =)
04:02:35 <benmachine> EvanR: I believe main is allowed to be any IO type
04:02:35 <dh___> (I) The successor function σ is primitive recursive.
04:02:36 <dh___> (II) The number 0 is a 0-argument primitive recursive function.
04:02:36 <dh___> (III) For each n
04:02:36 <dh___> ≥ 1 and k ≤ n, the following projection function Proj n k is primitive recursive
04:02:36 <dh___>  Proj n k (m1 , . . . , mn ) = mk
04:03:00 <dh___> so my question is : is algebraic data type is my only choice ?
04:03:02 <Craig`> oh hey, and thanks byorgey :)
04:03:38 <dh___> or should I use other algebra language instead of haskell?
04:03:56 <byorgey> dh___: is there some reason that an algebraic data type doesn't give you what you need?
04:04:05 <benmachine> EvanR: it's usually IO () because that makes it explicit that the result is discarded
04:04:18 <benmachine> (or should be; runghc doesn't seem to discard it)
04:04:23 <EvanR> benmachine: makes sense
04:04:37 <EvanR> ok so i wrote this. am i reinventing the wheel or what
04:04:40 <EvanR> http://pastebin.com/m61d3d043
04:05:10 <byorgey> dh___: I suppose interpreting your primitive recursive function AST is tricky because the number of arguments is different depending on the function.
04:05:37 <dh___> byorgey, yes , the number of argument is not fixed.
04:05:52 <EvanR> i use it here http://pastebin.com/m58095d88
04:05:54 <dh___> not fixed for (proj n k )
04:06:09 <byorgey> so in some sense you would want a dependently typed language.  But you could probably do something satisfactory in Haskell.
04:06:12 <benmachine> EvanR: I've not seen that function before
04:06:15 <byorgey> I'd have to think about what the best way would be.
04:06:27 <benmachine> but fwiw you can make it a fair bit simpler
04:06:41 <EvanR> ok
04:06:46 <benmachine> @undo do { x <- f x; loop f x }
04:06:46 <lambdabot> f x >>= \ x -> loop f x
04:06:53 <benmachine> @. pl undo do { x <- f x; loop f x }
04:06:53 <lambdabot> loop f =<< f x
04:06:57 <EvanR> yes i tried that at first and got confused
04:07:00 <benmachine> heh
04:07:11 <kmc> how would you stop then?
04:07:20 <benmachine> it's easier if you swap the arguments to loop
04:07:28 <sproingie> it will stop if x is Nothing
04:07:31 <benmachine> I think
04:07:43 <benmachine> wait no I am confusing myself
04:07:43 <sproingie> looks like a monadic version of fix
04:07:48 * benmachine plays with it a bit
04:08:00 * sproingie owns monadfix.com but doesn't actually know how to use MonadFix for that :-/
04:08:01 <EvanR> im guessing you could replace IO with m where Monad m
04:08:01 <byorgey> dh___: interpreting them as functions on lists instead of functions on multiple arguments would probably work well.
04:08:16 <benmachine> EvanR: it doesn't help that you used the name x twice in the second case, imo
04:08:18 <byorgey> dh___: unless you really *really* want the exact type information.
04:08:25 <kmc> :t let loop f x = do { y <- f x; loop f y }
04:08:26 <lambdabot> <no location info>:
04:08:26 <lambdabot>     not an expression: `let loop f x = do { y <- f x; loop f y }'
04:08:27 <kmc> :t let loop f x = do { y <- f x; loop f y } in loop
04:08:28 <lambdabot> forall t (m :: * -> *) b. (Monad m) => (t -> m t) -> t -> m b
04:08:28 <EvanR> benmachine: oh right...
04:08:31 <dh___> byorgey: list is fine, thanks.
04:08:46 <kmc> "x <- f x" doesn't recurse the same way as "let x = f x" unless you're in mdo
04:08:57 <kmc> it shadows,   f x >>= \x -> ...
04:09:27 <benmachine> :t let loop f = maybe (return ()) ((>>= loop f) . f) in loop
04:09:28 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m (Maybe a)) -> Maybe a -> m ()
04:09:30 <EvanR> http://pastebin.com/m70920141
04:10:27 <benmachine> EvanR: there's not much point in a <- return b
04:10:40 <kmc> EvanR, instead use "let a = b"
04:10:41 <EvanR> benmachine: i got type errors
04:10:44 <byorgey> EvanR: looks like a version of whileM specialized to IO + Maybe
04:10:53 <benmachine> let a = b is fine
04:10:53 <byorgey> unfortunately whileM is not in the standard libraries =(
04:11:01 <EvanR> yeah, i knew there was already something like this
04:11:02 <kmc> @hoogle whileM
04:11:03 <lambdabot> No results found
04:11:14 <EvanR> kmc: ill rewrite it
04:12:13 <kmc> EvanR, i like your code structure
04:12:28 <kmc> a good example of using higher order functional programming and imperative programming together
04:12:37 <kmc> define your own control flow structures for fun and profit
04:12:38 <byorgey> EvanR: ah, check out the monad-loops package on Hackage
04:12:56 <olsner> I'd probably just use "go init" with go mud = sequence_ actions >> (case mud' of Nothing -> return (); Just next -> go next)
04:13:02 <zarvok> where is the "Paths_<pkgname>" module cabal provides documented?  I can only find references to specific functions in it.
04:13:49 <byorgey> EvanR: it has  'whileJust_' which looks like it's exactly your function but for any monad
04:13:53 <EvanR> kmc: hrm... let in a do thingies...
04:13:57 <kmc> cool, forkMapM
04:14:38 <byorgey> oh, it's slightly different.  but anyway.
04:15:21 <EvanR> i could just replace the IO with m, i guess thats good enough. but i suppose i could replace Nothing with the zero of any monad?
04:15:30 * EvanR is new
04:15:41 <olsner> all monads don't have a zero
04:15:55 <EvanR> then ill just keep maybe
04:16:28 <necroforest> Does anyone using hmatrix know how to multiply a (Matrix t) by a (Vector t) ?
04:17:32 <paper_cc> EvanR: though there's mzero in the MonadZero class
04:17:35 <burp> necroforest: http://hackage.haskell.org/packages/archive/hmatrix/0.6.0.0/doc/html/Numeric-LinearAlgebra-Interface.html
04:17:43 <burp> doesn't this work?
04:17:49 <burp> (<>)
04:18:11 <EvanR> paper_cc: ah
04:18:15 <byorgey> paper_cc: sadly, there is no MonadZero class,  mzero is in MonadPlus
04:18:39 <paper_cc> byorgey, EvanR: right, sorry
04:18:45 <paper_cc> @src MonadPlys
04:18:45 <lambdabot> Source not found. That's something I cannot allow to happen.
04:18:50 <paper_cc> @src MonadPlus
04:18:50 <lambdabot> Source not found. Are you on drugs?
04:18:53 <byorgey> paper_cc: there OUGHT to be one though =)
04:19:01 <necroforest> burp, yeah.. thanks.. i didn't look in the .Interface package
04:19:27 * Cale wonders why the Mul class isn't in scope for Haddock
04:19:55 <Cale> oh, maybe because it's not exported from that module
04:20:26 * paper_cc is disappointed to see MonadZero in Haskell 1.3 report
04:20:33 <paper_cc> (and not in H'98)
04:21:11 <xerox> Cale: yeah, it's that module that defines it, but does not export
04:24:19 <EvanR> kmc: i removed extraneous return $, made loop a little more generic, and put the rest of the dummy plating. though my main loop is a little messier now (formatting). http://pastebin.com/m2ee3d053
04:24:33 <EvanR> the question im having is, is looping like that going to have poor performance for some reason?
04:26:20 <kmc> EvanR, is there some reason you think it might?
04:27:06 <byorgey> EvanR: no, should be fine
04:27:12 <EvanR> in here they talk of not doing explicit recursion, lazy style behavior of different recursion schemes...
04:27:17 <kmc> EvanR, instead of using "let ... in do"
04:27:30 <kmc> you can use a "let" as a statement inside the "do"
04:27:37 <kmc> in which case it has no "in" but rather applies for the rest of the do
04:27:49 <EvanR> ah ok
04:27:50 <kmc> > do { x <- [1,2]; let d = 2*x; return (x,d) }
04:27:51 <lambdabot>   <no location info>: parse error on input `}'
04:28:03 <kmc> ?
04:28:12 <EvanR> semi after return
04:28:15 <kmc> > do { x <- [1,2]; let d = 2*x; return (x,d); }
04:28:16 <lambdabot>   <no location info>: parse error on input `;'
04:28:21 <EvanR> ?
04:28:27 <byorgey> no, shouldn't need that, semicolons are separators
04:28:33 <kmc> indeed
04:28:59 <byorgey> , do { x <- [1,2]; let d = 2*x; return (x,d) }
04:29:00 <lunabot>  luna: parse error on input `}'
04:29:06 <kmc> > do { x <- [1,2]; let d = 2*x ; return (x,d) }
04:29:07 <lambdabot>   <no location info>: parse error on input `}'
04:29:15 <|Jedai|> > do {x <- [1,2]; let d = 2*x; return (x,d)}
04:29:16 <lambdabot>   <no location info>: parse error on input `}'
04:29:35 <kmc> > do { x <- [1,2]; let { d = 2*x }; return (x,d) }
04:29:36 <lambdabot>   [(1,2),(2,4)]
04:29:38 <kmc> bingo
04:29:43 <byorgey> aha!
04:29:46 <byorgey> sneaky
04:29:53 <kmc> yeah
04:29:58 <kmc> layout is your friend
04:29:58 <|Jedai|> oh right ! I remember seeing this one recently too
04:30:47 <EvanR> great so
04:30:56 <EvanR> a <- f b
04:31:04 <EvanR> let c = g a
04:31:14 <EvanR>     (d, e) = h c
04:31:20 <EvanR> sequence d
04:31:26 <EvanR> return e
04:32:55 <kmc> yeah
04:33:04 <kmc> all of that indented from "do"
04:33:10 <EvanR> yeah
04:33:49 <EvanR> i could use this to avoid the lambda expression, but then id have to name it :\
04:36:44 <EvanR> kmc: so each time runMud returns a new (big) state, its not as bad as it sounds because parts of the old and new data structure will be shared?
04:37:02 <EvanR> old and new value
04:38:01 <kmc> if you do it right, yeah
04:38:03 <kmc> and the inaccessible parts of the old one will get garbage collected
04:38:18 <EvanR> how do i do it right :S
04:38:42 <kmc> well... make sure it shares the data
04:39:51 <EvanR> ive seen update functions like this update (foo x y z) = foo (f x) y z, is that it?
04:40:09 <kmc> that would share y and z
04:40:20 <kmc> assuming foo is a data constructor (which it can't be, since it's lower-case)
04:40:26 <EvanR> yes sorry
04:41:17 <EvanR> this structure promises to be very complex... guess after some practice ill see ways of modularizing the updates into understandable chunks
04:42:16 <Craig`> ah the haskell super mario video on youtube, I can remember that when I did a bit of haskell last year :)
04:43:12 <emile_m> Why Haskell Wiki doesn't have it's Firefox serch plugin? Or I'm missing something? :)
04:44:29 <kmc> EvanR, even if you don't share data, what would be keeping the old version around?
04:45:03 <EvanR> nothing, but wouldnt that put more pressure on the gc...
04:45:33 <dh___> is there a way to define a 0-ary function in haskell ?  \ -> 0 ?
04:45:38 <kmc> dh___, no
04:45:44 <kmc> every Haskell function takes exactly one argument
04:46:09 <EvanR> constant applicative forms!
04:46:31 <dh___> kmc : thanks. but 0-ary function is usefull sometimes.
04:46:37 <kmc> not in Haskell
04:46:41 <EvanR> use a CAF ;)
04:46:43 <kmc> in other languages you use 0-ary functions to defer evaluation, or encapsulate side effects.  in Haskell we have separate constructs for those
04:46:52 <Twey> *caf* *caf*
04:46:53 <|Jedai|> EvanR: generally, if you have big state to manipulate, you'll want to use records, probably even nested records, and functional references to get easy modifiers
04:47:08 <Paczesiowa> dh___: x is 0-ary function (constant)
04:47:15 <kmc> it's not a function...
04:47:28 <kmc> this idea of functions without arguments is crazy
04:47:29 <Paczesiowa> of course it is - it takes 0 arguments and returns x
04:47:35 <c_wraith> eh.  data is code in haskell.  :)
04:47:41 <theclaw> could somebody tell me what the "|" in the this class definition means? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14121#a14121
04:47:42 <kmc> Paczesiowa, has it got a (->) in its type?
04:47:55 <kmc> theclaw, the stuff after is a functional dependency
04:48:08 <kmc> it says that, if you know the type for s, there is only one possible type for t
04:48:09 <c_wraith> > let fibs = 0 : scanl (+) 1 fibs in fibs
04:48:11 <dh___> 0-ary function is not crazy, it's useful in abstract algebra,
04:48:11 <EvanR> |Jedai|: sounds interesting
04:48:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:48:16 <|Jedai|> theclaw: that's functional dependencies, basically it said that s determine t
04:48:17 <kmc> dh___, explain?
04:48:19 <c_wraith> FIbs is data.  and code. :)
04:48:21 <dh___> and it can convert apply to compose.
04:48:38 <kmc> > fix ((0:) . scanl (+) 1)
04:48:38 <theclaw> kmc, |Jedai|: thanks
04:48:39 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:48:41 <dh___> apply f x ==> compose f  (lift x)
04:48:49 <ddarius> Those are functions from 0-tuples, which you can write in Haskell.
04:49:02 <kmc> one argument, which is the useless value ()
04:49:22 <kmc> every Haskell function takes exactly one argument.  there's no rule that you have to care what the value is ;)
04:49:38 <kmc> but most of the reasons to use nullary functions in other languages are not applicable
04:49:45 <kmc> so it's a pretty bad code smell
04:50:15 <dh___> agree . if use 0-ary to represent global state, that's bad.
04:50:22 <ddarius> As far as I know, there are no functions with type () -> X anywhere in Hackage.  There definitely aren't any in the "standard" libraries.
04:50:25 <c_wraith> Yeah..  there's really no obvious difference between ":: () -> a" and "a".
04:50:32 <kmc> @hoogle () -> a
04:50:33 <lambdabot> Control.Parallel.Strategies demanding :: a -> Done -> a
04:50:33 <lambdabot> Control.Parallel.Strategies sparking :: a -> Done -> a
04:50:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:50:44 <kmc> type Done = ()
04:50:57 <kmc> and the ever helpful unsafeCoerce ;)
04:51:16 * EvanR begins using it immediately
04:51:17 <c_wraith> I wonder if I can segfault ghci
04:51:25 <ddarius> c_wraith: Easy.
04:51:43 <c_wraith> well, yes.  I just meant specifically with unsafeCoerce of ()
04:51:54 <kmc> yes
04:51:55 <ddarius> Of course.
04:51:59 <ddarius> unsafeCoerce () 'a'
04:52:03 <kmc> well, you have no guarantee it will be a segfault
04:52:08 <kmc> this being the nature of unsafe languages
04:52:26 <medfly> unHaskell
04:52:29 <kmc> if you ever have to work on a project with someone who thinks a segfault is the worst thing that can happen to C code, run far away
04:52:33 <ben> welp, it says "Please report this as a GHC bug" too
04:52:33 <c_wraith> haha. unsafecoerce to Bool results in False :)
04:52:42 <ddarius> c_wraith: Indeed.
04:52:50 <kmc> yup, () and False are both the 0th constructor of their type
04:52:53 <medfly> kmc, explain your idea of worst that can happen to C code
04:52:53 <ddarius> You can do some "handy" stuff if you know the underlying representations.
04:52:56 <kmc> and so it's likely they have similar heap representation
04:52:56 <c_wraith> I need to unsafeCoerce to a function, then?
04:52:58 <medfly> I'm curious.
04:53:05 <ddarius> c_wraith: No.
04:53:27 <Paczesiowa> @src unsafeCoerce#
04:53:28 <lambdabot> Source not found. You type like i drive.
04:53:30 <c_wraith> Possibly a data constructor that takes an argument?
04:53:36 <Paczesiowa> :i unsafeCoerce#
04:53:41 <ddarius> c_wraith: That will work if you use that argument.
04:53:46 <Paczesiowa> @info unsafeCoerce#
04:53:48 <lambdabot> (unsafeCoerce #)
04:53:52 <Twey> medfly: It can corrupt its own data and then carry on silently and crash somewhere random later on.
04:54:05 <Paczesiowa> @hoogle unsafeCoerce
04:54:07 <kmc> medfly, you quite often see code that does invalid memory access that seems to work fine, but either gives subtly wrong results, or will crash spectacularly only after years in production
04:54:09 <Twey> That's pretty much the worst thing that can happen to computer code :þ  Completely random failure.
04:54:10 <ddarius> Twey: It doesn't have to crash at all.
04:54:11 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:54:18 <Twey> Well, yes.
04:54:23 <Twey> It could modify its own logic.
04:54:24 <kmc> returning a pointer to an auto variable is a classic example
04:54:24 <copumpkin> damn, my sleep schedule is totally ****ed
04:54:24 <medfly> random failure hehe
04:54:32 <kmc> it will often work
04:54:35 <kmc> for a while
04:54:45 <Peaker> does anyone remember what  mappend :: Event a -> Event a -> Event a    does in Reactive, if there's an event the exact same time in both?  The right-hand one is discarded, right?
04:54:47 <medfly> auto variable is what
04:54:54 <kmc> medfly, local to a function
04:54:57 <kmc> allocated on the stack usually
04:54:59 <Twey> check_safety() -> irradiate_subject()
04:55:51 <kmc> anyway there are lots of people who somehow think that C is a safe language and that "segfault" is what you get whenever you screw up
04:56:11 <Paczesiowa> why is unsafeCoerce strict?
04:56:38 <c_wraith> Ah, there goes.  woo, segfault! :)
04:56:43 <EvanR> speaking of which. is it possible in haskell to write arbitrary parts of memory, like with some unsafe function, for the purposes of hijacking a process
04:56:59 <c_wraith> using the Foreign Function Interface, sure.
04:57:07 <kmc> EvanR, yes.  the Foreign module allows unsafe C-style pointers
04:57:10 <ddarius> Paczesiowa: It's effectively the identity function.
04:57:12 <EvanR> ah
04:57:12 <Paczesiowa> c_wraith: it's easy to force segfault - just force haskell to dereference some pointer - coerce to Either a b
04:57:37 <Paczesiowa> ddarius: ?
04:57:41 <Paczesiowa> > unsafeCoerce (let x = x in x) :: Bool
04:57:42 <lambdabot>   Not in scope: `unsafeCoerce'
04:57:45 <kmc> again, not a reliable segfault
04:57:53 <Twey> @index unsafeCoerce
04:57:54 <lambdabot> bzzt
04:57:59 <ddarius> Paczesiowa: Strict means f _|_ = _|_, clearly id is strict.
04:58:03 <Twey> Where is unsafeCoerce?  :<
04:58:11 <medfly> Twey, all gone
04:58:11 <kmc> reliable segfault:   peek $ intPtrToPtr 0
04:58:16 <ddarius> unsafeCoerce `asTypeOf` id === id
04:58:19 <kmc> Unsafe.Coerce
04:58:21 <Twey> Hehe
04:58:23 <Twey> Ah
04:58:52 <Twey> Yay!  Kaboom!
04:58:54 <Twey> ^_^
04:59:40 <HaskellLove> let average [] = []; average (x:xs) = map sum (x:xs);  - This is interpreted fine but then when i do: average [1,2,3,4] I get: No instance for (Num [a])      arising from the literal `4' at <interactive>:1:15    Possible fix: add an instance declaration for (Num [a])
04:59:45 <emile_m> If I consume a piece of ByteString only for reading (like binding this piece to another variable), will GC make a copy of entire ByteString? In other words, what how GHC GC behaves in situations like that one?
05:00:09 <kmc> HaskellLove, what is the type of "average"
05:00:17 <c_wraith> emile_m: it shouldn't copy, ever.  that's the point of immutable data
05:00:29 <kmc> HaskellLove, these are the questions you should ask yourself when you get an error like this
05:00:32 <medfly> HaskellLove, because of the first line
05:00:37 <HaskellLove> kmc average :: (Num a) => [[a]] -> [a]
05:00:38 <kmc> what is the type i expect, what is the type ghc infers
05:00:44 <kmc> HaskellLove, so is [1,2,3,4] of type [[a]]?
05:00:55 <kmc> it is if and only if 4 is of type [a]
05:01:01 <kmc> which it's usually not
05:01:04 <kmc> that's what it's saying
05:01:23 <kmc> also, isn't your entire definition equivalent to "average = map sum"?
05:01:33 <ddarius> instance Num [a] where fromInteger = flip genericReplicate undefined
05:01:52 <HaskellLove> kmc, it is part of bigger function...
05:03:21 <necroforest> Is there a function like foldl that returns the list of partial values?
05:03:27 <ddarius> :t scanl
05:03:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
05:03:29 <byorgey> necroforest: yes, scanl
05:03:35 <necroforest> cool, thanks
05:03:51 <c_wraith> has anyone ever had a good use for scanr?
05:04:10 <byorgey> c_wraith: I think I did, once.  but I forget why.
05:04:18 <copumpkin> when you want foldr and wan to keep all the intermediate values for it :P
05:04:41 <ddarius> @src scanr
05:04:41 <lambdabot> scanr _ q0 []     =  [q0]
05:04:41 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
05:04:41 <lambdabot>     where qs@(q:_) = scanr f q0 xs
05:04:47 <copumpkin> > scanr (:) [] [1..5]
05:04:47 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
05:04:51 <copumpkin> whee
05:04:52 <byorgey> for some reason that seems much less frequent than wanting scanl
05:05:05 <copumpkin> I got me some tails
05:05:08 <c_wraith> Because it's actually less lazy than scanl
05:05:20 <ddarius> Indeed, scanl is the nicer of the two.
05:05:40 <emile_m> c_wraith: That is, I can do with ByteString whatever I want without triggering deep copies of data iff I don't perform "updating" operations like cons. True? :)
05:05:48 <HaskellLove> kmc i dont get it man, i say: average (x:xs) = map sum (x:xs); average is a function that takes a list and just map sum to that list what is the problem i dont get it... now i test this in ghci : map sum [1,2,3,4] and that does not work ... hmm what is going on?
05:05:57 <copumpkin> how about mapAccumL/R? has anyone used that?
05:06:15 <Twey> :t mapAccumL
05:06:16 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:06:16 <kmc> HaskellLove, try harder
05:06:19 <Twey> Well.
05:06:20 <kmc> you gave the type of average
05:06:28 <kmc> <HaskellLove> kmc average :: (Num a) => [[a]] -> [a]
05:06:43 <Twey> That's pretty clever
05:06:44 <kmc> do you see why it has that type?
05:06:55 <ddarius> copumpkin: Once a long time ago, but it's usually less convenient.  It's also an unwrapped version of mapM for the state monad.
05:07:01 <HaskellLove> yes but why is it like that why is it not [a] -> [a]
05:07:10 <kmc> :t sum
05:07:11 <lambdabot> forall a. (Num a) => [a] -> a
05:07:12 <kmc> :t map sum
05:07:13 <Twey> Usually less convenient than what?
05:07:13 <lambdabot> forall a. (Num a) => [[a]] -> [a]
05:07:29 <ddarius> Twey: Than writing something explicitly or using some other tool.
05:07:44 <kmc> HaskellLove, "map sum" means "apply sum to each element".  sum operates on a list, so each element must be a list, hence the input is a list-of-lists
05:07:48 <sinelaw> don't FGL's empty + & correspond to a monoid instance?
05:07:49 <ddarius> Everytime I've considered using it, it's turned out to be overly cumbersome.
05:07:53 <HaskellLove> kmc oh yeah, just sum [1,3,4,5] got it, damn... thanks man
05:08:01 * blackh uses mapAccumL a lot
05:08:13 <HaskellLove> kmc yeah i forgot sum does not need map to do its thing...
05:08:19 <Twey> ddarius: Eh.  It looks like a very handy function with an admittedly fairly specific use-case.
05:08:20 <sinelaw> @type mappend
05:08:21 <lambdabot> forall a. (Monoid a) => a -> a -> a
05:08:33 <sproingie> @type mapAccumL
05:08:34 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:08:34 <sinelaw> i guess not, because & doesn't take two graphs
05:08:39 <Twey> It's a combined map and fold.
05:08:41 <kmc> HaskellLove, you could have determined that sum does not need map to do its thing by a couple seconds' experimentation in ghci
05:08:44 <HaskellLove> copumkin check my blog, euler 11 is solved
05:08:45 <sinelaw> @type &
05:08:46 <lambdabot> parse error on input `&'
05:08:49 <sinelaw> @hoogle &
05:08:50 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
05:08:50 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
05:08:50 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
05:09:03 <copumpkin> HaskellLove: I'll notice you talking to me more if you spell my nick correctly :P
05:09:07 <Twey> Blimey.  Everyone and their dog has a blog these days.
05:09:08 <copumpkin> but good job :)
05:09:11 <HaskellLove> kmc you are right, i still have no intuition for these things
05:09:15 <blackh> so far it's always snd $ mapAccumL ...
05:09:16 <copumpkin> Twey: my dog has the most awesome blog
05:09:25 <Twey> Heh
05:09:34 <copumpkin> but I don't have a blog
05:09:36 <copumpkin> ...yet ;)
05:09:41 <Twey> Haha
05:09:42 <HaskellLove> copumpkin heh yeah sorry missed one there :)
05:09:44 <sproingie> i have a blog.  with no entries.
05:10:24 <Twey> I tried to keep a blog, once, but I always forget what I meant to write, and I prefer not to bore people by whining about the intimate details of my personal life
05:10:30 <HaskellLove> http://haskelllove.wordpress.com/ there is mine anyone interested to leave some sexy comments go ahead :D
05:10:50 <sproingie> OMG, Eddie Haskell is so *dreamy*, he's such a bad boy!
05:10:59 <copumpkin> maybe I'll jump on the hakyll bandwagon
05:11:00 <kmc> HaskellLove, you get the intuition by playing around in ghci
05:11:14 <HaskellLove> Twey blogs are not for personal stuff of course, the goal for my blog is "I want to solve euler project in haskell in 6 months"
05:11:53 <sproingie> i figure if i say anything important or profound, someone will @quote me and it'll be immortalized that way
05:12:03 <kmc> @quote sproingie
05:12:04 <lambdabot> sproingie says: | {-# LANGUAGE NoTypeChecking #-}
05:12:04 <copumpkin> HaskellLove: keep in mind that they'll add new problems while you're solving them
05:12:04 <EvanR> |Jedai|: what do you mean by functional references, is this usually covered in tutorials or is it obvious
05:12:16 <copumpkin> nope
05:12:22 <kmc> EvanR, look at the fclabels package on hackage
05:12:27 <kmc> and also data-accessor and lenses
05:12:28 <Twey> I think an array might be better-suited to your problem, HaskellLove…
05:12:55 <HaskellLove> Twey keep reading i do it like that later... i record my thought process there with all confusions and mistakes
05:13:08 <sinelaw> Peaker, do you recommend SDL for graphui's gui?
05:13:16 <Twey> Ah, 'kay
05:13:36 <Peaker> sinelaw: SDL doesn't work that well on OS X, they say.. and draws slowly.. GLUT/OpenGL is harder to get started with, but will probably be better eventually
05:13:47 <Peaker> sinelaw: if you do use GLUT, please wrap that with some more usable interface :)
05:14:06 <sinelaw> Peaker, what's HGL, btw? a thin wrapper or more on OpenGL?
05:14:22 <Twey> Hmm
05:14:26 <sproingie> SDL 1.3 bindings would be nice
05:14:28 <sinelaw> ah, neither.
05:14:33 <sproingie> that or SFML bindings
05:14:46 <Peaker> sinelaw: I'm not sure
05:15:05 <sinelaw> hackage says it wraps win32 and X with a nice interface
05:15:09 <Peaker> sproingie: SDL has a pretty cool API (finally something sane and simple) but its just so slow and horrible
05:15:26 <Peaker> sinelaw: what about OS X? Pretty common these days
05:15:41 <sinelaw> yeah i should think about it
05:15:44 <sproingie> SDL 1.3 is supposed to render to an opengl texture
05:15:49 <EvanR> kmc: template haskell? :S
05:15:58 <sinelaw> this looks interesting http://hackage.haskell.org/package/graphics-drawingcombinators
05:16:00 <dons> is someone working on the sdl 1.3 bindings...
05:16:09 <sproingie> i hear they're starting again on Duke Nukem Forever and they'll have it running on SDL 1.3
05:16:14 <sproingie> i think DNF might come out first tho
05:16:14 <Peaker> Did SDL 1.3 change their API?
05:16:33 <EvanR> yes
05:16:40 <sinelaw> Peaker, incidentally that thing i just linked to is by luke palmer
05:16:51 <sproingie> changed somewhat, mostly it's the surface implementation that's changed
05:17:02 <Peaker> sinelaw: I looked - it seemed like a "Draw monad", which is something conal convinced me out of a while ago :)
05:17:12 <sproingie> render to texture runs circles around a software framebuffer
05:17:14 <stroan> Peaker: sdl is certainly sufficient, given the relatively limitted set of features it exposes no? I've never found it overly slow for simple things
05:17:24 <sinelaw> Peaker, what is that and why
05:17:24 <sproingie> depends on how simple
05:17:25 <EvanR> sdl 1.3 adds support for multiple windows, sane multimonitor, opengl backends, joystick hotpluggin (i hope), rumble feature
05:17:45 <shambler> I expect Duke Nukem Forever to be released on quantum computers
05:17:55 <Peaker> stroan: I do find it kind of slow, but I haven't benchmarked a lot to see what's actually slow.. you can take a look at "cabal install breakout" if you want
05:18:20 <EvanR> basic sdl is slow if you try to use a resolution greater than 640x480 and you do full screen redrawing like opengl
05:18:21 <drhodes> that's a generous expectation shambler
05:18:22 <sinelaw> Peaker, also it's weird - it says it's a wrapper around opengl but it requires SDL
05:18:35 <stroan> Peaker: OH, Haskell SDL bindings?
05:18:35 <sinelaw> (and also opengl)
05:18:39 <sproingie> a 1680x1050 framebuffer is basically glacial
05:18:46 <Peaker> sinelaw: basically, instead of a simple Image type with a model like (Coordinate -> Maybe Color), it's a Draw monad, in which you can just do drawing operations
05:18:55 <Peaker> stroan: I think they're pretty thin/straightforward
05:19:08 <sinelaw> Peaker, i guess he wrote that module before the blog post on semantic design
05:19:14 <stroan> kk, will check out breakout
05:19:41 <sinelaw> actually latest version is pretty recent
05:19:55 <sproingie> dwarf fortress ended up having to use opengl FBO's because other paths were a bottleneck.  and DF is hardly a graphical beast
05:20:32 <sproingie> video cards just won't accellerate 2D anymore
05:21:16 <Peaker> sinelaw: to expose a pure Image rather than a monad, you have to do things like renderText :: String -> (Size, Image)  --  and this requires "unsafePerformIO" or such (which is actually "safePerformIO" because text rendering is really a pure operation, but most backend libraries put it in a monad)
05:22:38 <ziman> well, how about accessing fonts while rendering the image?
05:23:10 <Peaker> ziman: well, getting fonts available on the system may be an impurity -- but that's beyond the scope of a graphics combinator library :)
05:23:52 <sinelaw> Peaker, so what should I use?
05:23:56 <sinelaw> :)
05:24:19 <Peaker> sinelaw: IMO: GLUT (though I never have used it myself. It *seg-faults* in my face :)
05:24:30 <Peaker> it seg-faults if you use the API wrong, which is very unfriendly
05:24:37 <sinelaw> isn't it imperatively imperative?
05:24:54 <Peaker> sinelaw: wrap it in a pure image combinators library :)
05:25:17 <sinelaw> Peaker, aha, well, i'll delegate that task to you
05:25:27 <sinelaw> and meanwhile i'll use something else
05:25:29 <Peaker> sinelaw: I have a simple/lame one :)
05:25:36 <sinelaw> Peaker, does it work?
05:25:37 <Peaker> (around SDL though)
05:25:43 <sinelaw> oh then forget it
05:25:44 <Peaker> sinelaw: I think so
05:25:54 <sinelaw> performance in SDL is so crappy
05:26:08 <Peaker> the moons are never aligned, yeah
05:26:30 <sinelaw> yeah, they have only one moon and it needs to be aligned with the missing second one
05:26:40 <Peaker> ;)
05:27:20 <sinelaw> i gues graphics rendering is tightly coupled with input retrieval?
05:27:24 <sinelaw> *guess
05:28:18 <EvanR> in practice yes. X11 graphics/input, osx graphics/input, win32 graphics/input
05:28:45 <EvanR> sdl drivers
05:28:55 <sinelaw> EvanR, yes, i meant in practice. sad, though.
05:29:27 <sinelaw> i mean within an OS, between different graphics frameworks
05:30:02 <sinelaw> Peaker, space invaders is uses HGL and is in Yampa, so i'm inclined to disregard OSX :)
05:30:10 <sinelaw> s/is//
05:30:14 <EvanR> i like the fbconsole driver, uses direct linux input and framebuffer graphics ;)
05:31:48 <sinelaw> aaaah, horrible performance!
05:31:54 <sinelaw> (SpaceInvaders)
05:32:41 <sinelaw> i can't believe i'm gonna have to spend a lot more time on a really common problem  (graphics and input) than on the specific problem
05:32:43 * hackagebot upload: hurdle 0.1.0 - Extract function names from Windows DLLs. (StephenTetley)
05:32:51 <stroan> Peaker: I'm playing breakout, it's fine. is there a more demanding example on hackage?
05:33:48 <MarcWeber> @tell nagnatron I've updated the vim backend for scion. Everything should work fine now. Get the branch feed_ustream from github.com/MarcWeber/scion until Thomas has pulled the changes
05:33:48 <lambdabot> Consider it noted.
05:33:54 <HaskellLove>  foldr (+1) 0 [1,2,3,4,5] what is wrong with this?
05:33:54 <Twey> Hehe, ‘hurdle’ — nice
05:34:09 <copumpkin> :t foldr
05:34:10 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:34:11 <Cale> HaskellLove: (+1) is only a function of one parameter
05:34:35 <Peaker> sinelaw: space invaders seems just buggy
05:35:10 <Twey> > foldr (const (+ 1)) [1, 2, 3, 4, 5]
05:35:11 <lambdabot>   No instance for (GHC.Num.Num [t])
05:35:11 <lambdabot>    arising from the literal `1' at <inter...
05:35:19 <Twey> D'oh
05:35:26 <Twey> > foldr (const (+ 1)) 0 [1, 2, 3, 4, 5]
05:35:26 <lambdabot>   5
05:35:34 <Cale> HaskellLove: remember that the first argument to foldr is a function which will be used to replace (:), and so it must have two parameters, the first being a list element, the second being the value of foldr f z applied to the remainder of the list
05:35:56 <Twey> And what does the first argument of foldl replace?
05:36:09 <copumpkin> flip (:) on the reversed list
05:36:10 <copumpkin> :P
05:36:35 <Cale> foldl does a bit more complicated of a transformation than simple replacement of structure
05:36:57 <Cale> http://cale.yi.org/index.php/Fold_Diagrams -- I have a picture of it here though
05:37:17 <EvanR> so if i am trying to model a large heirarchy of objects which can contain other objects, and id like to be able to find the parent of an object easily, do i want a hash table? or map? or literally a data Object = Object {contents :: [Object]}...?
05:37:50 <EvanR> i did this with two way pointers in C... was hellish
05:37:51 <Cale> EvanR: You almost certainly don't want a hashtable, but Data.Map wouldn't be bad.
05:38:03 <copumpkin> EvanR: not very much information in that type, eh :P
05:38:20 <ddarius> EvanR: It depends on whether you plan to modify these "Objects" much.
05:38:22 <copumpkin> Cofree []
05:38:24 <HaskellLove> Twey i see this first time: (const (+ 1))  can u talk more about it? I mean, i know about sections i understand this (+1) but never used it like u did here
05:38:26 <copumpkin> not even actually
05:38:30 <EvanR> ddarius: mostly moving them
05:38:49 <EvanR> but also modifying their other properties
05:38:51 <Twey> HaskellLove: It's equivalent to (\_ x -> x + 1)
05:39:29 <Cale> Or (\a x -> x + 1), in case that blank pattern is confusing
05:39:34 <HaskellLove> i see that first time too :( Twey
05:39:34 <ddarius> copumpkin: Mu []
05:39:37 <copumpkin> yeah :)
05:39:46 * copumpkin was preparing his cow suit
05:39:57 <EvanR> a Data.Map mmmkay *heads to the docs*
05:40:05 <Cale> HaskellLove: const k x = k
05:40:11 <Twey> HaskellLove: Err, you're learning a functional language and you're not yet familiar with lambdas?  :þ
05:40:26 <HaskellLove> Twey i am but not the way u used it
05:40:29 <Cale> HaskellLove: The job of the function const is to make constant functions -- ones which ignore their parameter and produce the same result regardless
05:40:30 <sinelaw> Peaker, buggy?
05:41:20 <Cale> HaskellLove: So in this case, Twey used const to make a function which ignores the element of the list, and gives the function which adds 1 to the result of the foldr on the tail of the list
05:41:28 <Peaker> sinelaw: everything happens with a huge delay
05:41:48 <sinelaw> that could be performance
05:42:03 <Peaker> sinelaw: sure, but it seems like a bug
05:42:17 <Peaker> sinelaw: also nothing happens with no input events, it seems (need to move the mouse for anything to happen)
05:42:52 <sinelaw> Peaker, not on my computer
05:43:17 <sinelaw> also the delay isn't so great here
05:43:27 <sinelaw> in fact there isn't any
05:43:31 <sinelaw> it just sucks CPU that's all
05:44:47 <stroan> What kind of project would you give to show students the benifits of FP? Just got given a decent sized project using wx. Seems like that just shows how you can code imperratively in a DSL built ontop of haskell, more than haskell itself
05:45:14 <BONUS> stroan: parsing?
05:46:24 <stroan> aye, that's certainly a good one
05:47:58 <Twey> Just about anything that doesn't use an imperative-style library?  ;)
05:48:01 <EvanR> stroan: i dont know about haskell in particular, but a lot of audio/music software for linux is written in scheme or lisp
05:48:07 <blackh> stroan: I think games are quite good, because you can design them with pure game logic and it gives opportunities for custom DSLs for describing game logic, and the project can be as large or as small as you like
05:48:26 <EvanR> and some come with an interpreter or fancy modeller for audio editing
05:48:51 <EvanR> basically everyone so far has said 'custom sublanguage'
05:48:55 <Cale> HaskellLove: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14130#a14130
05:49:35 <blackh> stroan: Also games give you an opportunity to look at factoring I/O to the "outside" of your Haskell program, and the techniques involved in that
05:49:39 <sinelaw> Peaker, ok i give up
05:49:49 <sinelaw> where's you're cool sdl wrapper?
05:49:56 <sinelaw> (and are you sure it works? :)
05:50:04 <stroan> blackh: that's certainly an idea.
05:50:11 <benmachine> Cale: do you know of any tools that do that sort of expansion automatically (showing you every step)?
05:50:23 <HaskellLove> blackh can u recommend me book to make games in haskell?
05:50:25 <Cale> benmachine: Nope, I do it by hand every time.
05:50:30 <Peaker> sinelaw: I said it was lame, not cool :)
05:50:39 <stroan> wonder how much hand holding would be needed to get them thinking about it in the right way
05:50:47 <blackh> HaskellLove: No - but I can talk about the subject as much as you like.  I'm developing a game in Haskell.
05:51:02 <sinelaw> oh
05:51:16 <Peaker> sinelaw: in LUI
05:51:18 <Peaker> sinelaw: Image.hs
05:51:31 <Peaker> blackh: what game?
05:51:31 <sinelaw> help, Could not find module `Control.Monad.Reader': it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
05:51:31 <benmachine> Cale: do you think it'd be (a) useful and/or (b) easy to write such a thing?
05:51:43 <Peaker> sinelaw: that is annoying indeed
05:51:43 <Cale> benmachine: It would certainly be useful.
05:51:44 <HaskellLove> blackh - well I am on euler 12 now with haskell... i would like to start a game so euler dont bore me... can u send me your code so i can study it?
05:51:51 <sinelaw> Peaker, what to do?
05:51:51 <benmachine> sinelaw: ghc-pkg hide monads-fd is the usual practice
05:52:04 <Peaker> sinelaw: What I do is ghc-pkg --force hide monads-fd
05:52:11 <sinelaw> what's monads-fd?
05:52:28 <blackh> HaskellLove: Unfortunately no because it's 25,000 lines of proprietary code, but I can send you a few things I've played with.
05:52:33 <sinelaw> and why is there that conflict
05:52:36 <Peaker> sinelaw: fd=fundeps=functional dependencies  (as opposed to type-families)
05:52:48 <medfly> wow, 25,000 lines of Haskell
05:52:49 <Peaker> blackh: what company are you working for, developing a Haskell game? :)
05:52:49 <benmachine> Peaker: doesn't mtl use fundeps though?
05:53:02 <HaskellLove> blackh you guys will sell it or is it uni project or what?
05:53:12 <sproingie> mtl is damn near straight haskell 98
05:53:20 <sproingie> except in the places where it just can't be
05:53:22 <blackh> Peaker, HaskellLove: It's a start-up called iPwn Studios. We're developing a game called BloodKnight for the iPhone.
05:53:33 <necroforest> you can do Haskell on the iPhone?
05:53:36 <copumpkin> blackh: how's that coming along btw?
05:53:36 <benmachine> sproingie: i.e. the places where it has to use fundeps? :P
05:53:37 <Cale> sproingie: It uses multiparameter typeclasses and functional dependencies
05:53:51 <copumpkin> FUCK YOU BROWN
05:53:55 <p_l> necroforest: I guess you could do it, but you'd need an obj-c bridge
05:54:01 <sproingie> possibly the -fd stuff does more with fundeps
05:54:16 <HaskellLove> blackh you want free worker? you dont have to tell me the whole code you can like give me just part and give me a task u know :) if posible let me know
05:54:17 <necroforest> well blackh is apparently doing it
05:54:31 <Cale> copumpkin: brown? I'm seeing the split as being farmer/irc
05:54:43 <copumpkin> Cale: interesting
05:54:43 <necroforest> blackh, you should build it for android ;)
05:55:18 <benmachine> I see zelazny/irc
05:55:19 <blackh> necroforest: We have released a GHC cross-compiler for iPhone: http://projects.haskell.org/ghc-iphone/
05:55:26 <copumpkin> I guess IRC is the one that quit
05:55:31 <copumpkin> the other ones are the ones we're connected to
05:55:34 <blackh> necroforest: Android is on my to-do list.
05:55:34 <Cale> yeah
05:55:51 <blackh> HaskellLove: Yes, that would be great.
05:56:02 <Craig`> right so I'm ordering some more books, would you advise me any other than real world haskell and structure and interpretion of...?
05:56:29 <medfly> hehe
05:56:30 <blackh> copumpkin: A lot of the programmers we had haven't produced much so it's ended up being mostly me, which has delayed the project a bit, but it's looking really good and coming along nicely.
05:56:50 <copumpkin> blackh: sorry to hear that, but great that it's coming along
05:56:53 <medfly> blackh, if you're trying to recruit Haskell programmers, then this channel is great.
05:56:59 <HaskellLove> blackh awesome, u hang on this chanel? same name? i am a week in haskell and have solved to 11 eulers in it, so i would need a weak more to become a haskell ninja and then i am yours for the project ok?
05:56:59 <Peaker> blackh: what did they do instead of producing stuff? Where did you find Haskell programmers?
05:57:11 <medfly> I appoint Cale
05:57:34 <copumpkin> Peaker: they were too busy golfing it and applying categorical recursion theory to the game :)
05:57:38 <HaskellLove> blackh i dont care about credits and stuff, i will do some work help, and learn some stuff, that is all
05:57:47 <Craig`> does anyone here use haskell for web development? server-side
05:57:48 <copumpkin> oh yes, my AI is a zygomorphism!
05:58:05 <monochrom> My AI is a cytoplasm
05:58:06 <blackh> HaskellLove: That'd be great - I need some help.  I'll turn you into a pro in no time.
05:58:09 <Cale> HaskellLove: hehe, it took me about 2 months before I really felt that I could get things done with Haskell, and about 1 year to become comfortable
05:58:22 <medfly> Cale, I'm faster than you!
05:58:26 <HaskellLove> Cale i am a ninja man
05:58:29 <copumpkin> lol
05:58:31 <blackh> Peaker: It's a long story. :)
05:58:45 <copumpkin> HaskellLove: demonstrate it! don't ask us questions you can obviously answer with a bit more thought :P like the foldr (+1) one
05:58:48 <medfly> if only I didn't have a lousy job :)
05:58:59 <Craig`> in case anyone missed it due to the mass JOINs, "right so I'm ordering some more books, would you advise me any other than real world haskell and structure and interpretion of...?"
05:59:12 <medfly> @where lyah
05:59:12 <lambdabot> http://www.learnyouahaskell.com/
05:59:14 <medfly> right!
05:59:15 <copumpkin> Craig`: I hear bird's book on haskell is interesting
05:59:21 <BONUS> it's not out yet as a real book!
05:59:23 <copumpkin> richard bird
05:59:28 <BONUS> but it will be soon
05:59:31 <HaskellLove> copumpkin demonstrate? uhm, how about... i am a week in haskell and i am on euler 12 with it?
05:59:36 <Cale> BONUS: Oh?
05:59:38 <monochrom> Craig`: http://www.vex.net/~trebla/weblog/fpbooks.xhtml  , I list both of Bird's books.
05:59:40 <Craig`> BONUS, really? :D omg that'd be great
05:59:46 <BONUS> yeah :)
05:59:50 <medfly> blackh, YOU SHOULD TOTALLY RECRUIT WORKERS HERE
05:59:51 <Botje> BONUS: will it have the list monster on the cover? :)
05:59:54 <BONUS> no official announcement yet, but soon
06:00:00 <BONUS> Botje: haha hmm MAYBE
06:00:03 <Craig`> if you ever need a reviewr BONUS ;)
06:00:06 <medfly> I take that as  a YES!
06:00:07 <copumpkin> HaskellLove: just saying, you've been asking us some questions that you could obviously answer
06:00:14 <Cale> lovely
06:00:19 <medfly> Cale, what is
06:00:23 <BONUS> i hope the list monster makes it into the final version cause the nintendo dude could maybe sue me?
06:00:25 <Cale> The network static.
06:00:33 <copumpkin> HaskellLove: I'm fine with helping, but don't fall into the trap of replacing your brain with #haskell :P
06:00:42 <monochrom> Wrong, it is the network dynamic.
06:00:54 <HaskellLove> copumpkin no worries man, thanks so far :)
06:01:07 <luite> hmm, #haskell is better than my own brain :p
06:01:21 <monochrom> Of course, the #haskell room understands haskell!
06:01:31 <blackh> medfly: Would you like to work in the Haskell games industry for a profit share?
06:01:42 <BrianB04> Good evening all.
06:01:44 <Craig`> monochrom, is Bird's book "intro to haskell" still dated?
06:01:50 <Craig`> *in date
06:02:27 <monochrom> outdated haskell syntax, ahead of our time material
06:02:29 * copumpkin listens to some Dvořak
06:02:39 <Craig`> monochrom, I solute you
06:02:45 <Craig`> you send XHTML _as_ XHTML
06:02:47 <Craig`> THANK YOU.
06:02:50 <copumpkin> morituri te solutant ;)
06:03:05 <monochrom> I take pain to be standard-compliant.
06:03:15 <Craig`> :D
06:03:35 <monochrom> If it means aliening IE users, so be it.
06:03:50 <Craig`> on #HTML, there's only really about 4 of us who do it "righT"
06:03:52 <tensorpudding`> IE users are already aliens
06:04:38 <EvanR> what is the best key type to use in a Data.Map
06:04:42 <Craig`> "Programming in Haskell by Graham Hutton", anyone got that book?
06:04:43 <EvanR> for speed
06:04:59 <EvanR> Int
06:05:00 <EvanR> ?
06:06:04 <c_wraith> For speed?  Use and IntMap
06:06:07 <c_wraith> *an
06:06:17 <Philonous> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-IntMap.html
06:06:28 <benmachine> I'd advise using whatever's convenient
06:06:40 <BONUS> i'd advise not worrying about speed
06:06:54 <medfly> blackh, I'm trying to talk Cale into accepting your offer.
06:07:01 <Cale> Craig`: I don't, but it's supposed to be good.
06:07:03 <kmc> unless you have already profiled and found a bottleneck in the map, use whatever's convenient.  but if that happens to be Int, use IntMap rather than (Map Int)
06:07:04 <luks> Craig: yeah,have it
06:07:14 <Craig`> luks, would you recommend it?
06:07:16 <Cale> Craig`: (as a beginner text, anyway)
06:07:31 <luks> good for beginners
06:07:43 <Craig`> Cale, yeah I'm a total beginner :) I've read a bit of LYAH, but that's it
06:07:46 <EvanR> maybe Integer would be better
06:07:55 <blackh> medfly: Great!  Well, when you have talked Cale into it, send him my way. :)
06:07:56 <Craig`> so if I read LYAH, get that book, and then real world haskell, then the fun should begin :)
06:08:22 <newsham> craig: didnt you already ask for books yesterday?
06:08:35 <benmachine> EvanR: what's your use case? would an array work?
06:09:07 <mreh> Craig` don't underestimate doing haskell as well
06:09:25 <benmachine> learn by doing!
06:09:25 <mreh> i always have the problem of subordinating doing to thinking about
06:09:26 <Craig`> mreh, of course to learn you _have_ to program, :) I do understand :)
06:09:31 <Cale> blackh: Well, I *do* need a way to make some money, might be a good idea :)
06:09:49 <EvanR> benmachine: its a large collection of objects in a containment heirarchy...
06:09:59 <copumpkin> Cale: ryant5000 was looking for master hax0rz in here a few months back!
06:10:07 <Craig`> how do you advise me to get better at haskell? just read, code, read, code, code, code, read, code, code.. etc? haha :)
06:10:08 <blackh> Cale: This is a gamble, because we're sharing profits, but it's full on commercial programming.
06:10:15 <mreh> people make money from haskell?!
06:10:18 <copumpkin> Craig`: you forgot an important bit
06:10:19 <newsham> craig: mostly code.
06:10:19 <blackh> copumpkin: ryant5000 is with me - same project
06:10:21 <copumpkin> Craig`: "think"
06:10:25 <copumpkin> blackh: yeah, I know :)
06:10:36 <newsham> haskell's great for code/recode/recode/recode
06:10:41 <newsham> since there's so many ways to do things
06:10:59 <Craig`> but any ways, I've got like 6 years to muck around with programming before trying to get a job in it :)
06:11:00 <blackh> Cale: Probably about 4-6 weeks left in the project.
06:11:11 <blackh> Cale: Very rough guess.
06:11:30 <newsham> blackh: whats your project?
06:11:45 <blackh> newsham: A commercial game for the iPhone called "BloodKnight".
06:11:47 <monochrom> unsafe launch missile
06:11:55 <newsham> blackh; what are you writing it in?  objc?
06:11:59 * copumpkin drinks blackh's blood to demonstrate the concept
06:12:12 <Cale> blackh: It sounds like it might be fun. I don't have an iPhone though.
06:12:17 <Cale> newsham: Haskell
06:12:29 <blackh> newsham: Haskell with a little bit of C++.
06:12:38 <Craig`> you can write iPhone apps with haskell? osum.
06:12:47 <blackh> Cale: You can use the iPhone simulator if you have a Mac.
06:12:49 <copumpkin> Cale: I can send you a spare 2g iphone I have
06:12:53 <newsham> doesnt the iphone sdk come with an emulator?
06:12:59 <blackh> Craig`: http://projects.haskell.org/ghc-iphone/
06:13:00 <Cale> I also don't have a Mac.
06:13:05 <benmachine> hah
06:13:19 <newsham> you can run osx in vmware, fwiw.
06:13:22 <Craig`> nice :)
06:13:27 <monochrom> ⊕ = osum = awesome
06:13:27 <blackh> Cale: I'm really enjoying myself!
06:13:45 <Cale> Heh, that would be interesting. Run the iPhone simulator in OSX on vmware :)
06:13:59 <newsham> ahh.. was wondering about ARM code gen.. its using the C emitter
06:14:07 <blackh> Cale: Probably about the same speed as a real iPhone!
06:14:15 <Cale> hehe
06:14:24 <newsham> cale: running osx in vmware's not entirely an emulation step, since its all native cpu (for userland at least)
06:14:33 <Craig`> I know a lot of people may ask this, but can Haskell really be used commercially? say maybe for games, if they were to be written in OpenGL, or, say the next-best-thing IM
06:14:46 <Cale> Craig`: Sure, why not? :)
06:14:54 <benmachine> Haskell's most common commercial use is not in gaming
06:14:55 <Twey> http://www.haskell.org/haskellwiki/Haskell_in_industry
06:15:06 <ddarius> Craig`: Haskell is used commercially.
06:15:38 <Craig`> I'm currently wanting to be a web developer, but I mean, a lot of change will happen in 6 years :)
06:15:41 <benmachine> mostly for serious business
06:15:44 <Cale> Craig`: I don't see any technical reason why it shouldn't be doable, though the fact that it's not been done very much in the past may mean that you have to carve out some paths for yourself.
06:16:06 <Twey> There's Frag
06:16:10 <newsham> there's some web dev stuff for haskell.
06:16:11 <blackh> Craig`: Haskell has not caught on in the commercial world, but it is ideal for commercial programming.  It will catch on - the only question is when.
06:16:14 <Twey> For games
06:16:14 <monochrom> In 6 years you will be a cloud developer.
06:16:16 <newsham> like happs and hws
06:16:17 <benmachine> does that work with base4 yet?
06:16:17 <Cale> Right, there are some small proof-of-concept things.
06:16:21 <benmachine> or new opengl
06:16:26 <kmc> blackh, i think it has caught on in a significant sense.  Look at that wiki page
06:16:26 <benmachine> or whatever it was that broke it
06:16:31 <Craig`> monochrom, how's that :P
06:16:34 <Peaker> When did GHC get a concurrent GC?
06:16:43 <monochrom> "cloud computing"
06:17:02 <ddarius> Peaker: There was a branch with an incremental GC, but it was never adopted into the mainstream.
06:17:03 <blackh> Craig`: The reason why Haskell hasn't caught on (kmc: in a big way yet) is just plain conservatism.
06:17:09 <monochrom> I don't mean to say it has a different semantics.
06:17:24 <kmc> Craig`, the major industrial use is for implementing domain-specific languages, for things like hardware design, embedded systems programming, modeling financial derivatives, cryptography, ...
06:17:25 <ddarius> Peaker: Anyone saying "concurrent GC" about modern GHC probably means "parallel GC"
06:17:31 <Peaker> ddarius: so what happens to the performance of programs with large/growing heaps?
06:17:40 <BrianB04> Haskell is suffering the same problems as many languages: Everyone uses the language flavor of the month. This month it's Ruby, last month it was Erlang.
06:17:42 <Peaker> ddarius: oops, yeah
06:17:57 <kmc> no
06:18:01 <kmc> people don't use the language of the month
06:18:09 <kmc> people use Java and C++
06:18:12 <kmc> even though they're terrible
06:18:26 <smiler> Is it ruby month again?
06:18:28 <smiler> Sweet...
06:18:35 <Craig`> go ruby, woo. haha
06:18:37 * Cale doesn't really want Haskell to catch on in a big way commercially, because he likes Haskell and wouldn't wish that on any good language.
06:18:44 <newsham> there's talk about giving February to Haskell
06:18:44 <copumpkin> lol
06:19:02 <BrianB04> Why not January? We could market it as "It's the language of the new year".
06:19:04 <Craig`> I've got two c++ books, I did a tiny bit of it, but I really sucked at it being the first code I ever did, yack, it's horrible
06:19:05 <dons> Cale: getting paid to use haskell is nice
06:19:06 <dolio> This month is Ruby?
06:19:12 * copumpkin likes ruby
06:19:14 <copumpkin> or I liked it
06:19:16 <Cale> dons: True, but do it in secret :)
06:19:17 <monochrom> "My birthday is Ruby 21, 1991"
06:19:17 <newsham> bo4: because january has 31 days
06:19:20 <dons> also means haskell gets better tools and libs, since more people working on it full time, and more money available
06:19:42 <dolio> I thought Ruby was from, like, two years ago.
06:19:48 <BrianB04> I like Ruby, but...I use it and miss things like...pattern matching and list comprehension.
06:19:52 <blackh> Cale: I want it to catch on commercially because I program for a living, and while it hasn't caught on commercially, I have to program in inferior languages.
06:19:54 <newsham> dons: which increases the marginal cost of making changes.
06:19:55 <copumpkin> it is, like so totally last year
06:20:01 <Craig`> as I'm just learning, bits of ruby and haskell, I might do little projects in both languages, finish it in one language, then write it in another to see which one I prefer, :)
06:20:18 <dons> having 40 people at galois using haskell for pretty much everything is a pretty useful foundation for long term development, add MSR to that, and you've got a good ecosystem
06:20:34 <dons> newsham: that's right.
06:20:42 <blackh> Craig`: Try re-factoring a large program in a dynamically typed language, then try doing it in Haskell.  There is no comparison.
06:20:47 <dons> hackage has the same effect, though.
06:20:49 <monochrom> I think -fglasgow-exts solves the problem.
06:20:54 <Peaker> dons: someone on Reddit told me that MSR are not involved in ghc at all, that MSR people doing GHC work do so on their own spare time, and not as MSR work. Is that true?
06:21:00 <BrianB04> dons: See, working in Haskell, or actually any functional language for a living would be a really nice change.
06:21:01 <Cale> dons: A couple of companies are okay. :)
06:21:05 <dons> Peaker: no, that's not true.
06:21:16 <ddarius> BrianB04: Use F#.
06:21:25 <Craig`> but I've got a lot to learn, and I'm not good at programming, so these projects won't be "projects" as such haha :)
06:21:30 <dons> Peaker: you were talking to harrop, who's got a personality disorder
06:21:36 <benmachine> I think that haskell has a lot of room for growth as a language yet
06:21:39 <Peaker> Craig`: Haskell will help you become good at programming :)
06:21:41 <jlouis> dons: MSR?
06:21:43 <dons> Peaker: note MSR also sponsors the hackathons and ICFP.
06:21:46 <Peaker> dons: oh, that time it was malcontent
06:21:52 <BrianB04> However, my new company offers "Google Project Time" which means I get paid one day a week to actually work on a project of my choice. ddarius: You know, I have been putzing with F#
06:21:53 <benmachine> there are things like record syntax that feel like they could do with a bit of cleaning
06:21:54 <Craig`> Peaker, let's hope so :)
06:21:57 <stroan> dons: hackathons?
06:22:01 <jlouis> ah, Microsoft Research!
06:22:06 <dons> http://research.microsoft.com/en-us/people/simonpj/ the R in MS.
06:22:10 <newsham> is f# actually used?
06:22:18 <jlouis> newsham: yes!
06:22:25 <newsham> cool
06:22:34 <benmachine> it would be a shame if it got fossilised before that stuff got worked out
06:22:35 <copumpkin> Peaker: that was a stupid trollish guy
06:22:43 <jlouis> I know of at least 3-4 danish companies using it in anger now
06:22:47 <copumpkin> Peaker: I tried to argue with him but he insisted on misquoting SPJ in one of his videos
06:22:49 <jlouis> (f# that is)
06:23:23 <newsham> hmmm "3-4 danish companies" doesnt sound like much
06:23:37 <ddarius> newsham: F# has barely been released yet.  Give it some time.
06:23:41 <jlouis> newsham: that I know of severely limits the extent as well
06:23:46 <newsham> is msft using it for anything commercially?
06:23:57 <sinelaw> Peaker, i think maybe graphics-drawingcombinators is not what it used to be or what you think it is
06:23:59 <sinelaw> it's quite nice
06:24:07 <dons> can someone do a review of graphics-drawingcombinators?
06:24:08 <Peaker> sinelaw: cool :)
06:24:09 <sinelaw> functional
06:24:14 <jlouis> newsham: MS used Ocaml for some static driver verification beforehand and F# is pretty much a .NET'ed ocaml
06:24:16 <dons> i'd like to get a Haskell Package of the Week blog going
06:24:17 <Peaker> dons: what do you mean?
06:24:22 <sinelaw> box = Draw.scale 0.3 0.3
06:24:22 <Peaker> oh
06:24:22 <sinelaw>         $ Draw.color (1,0,0,1)
06:24:22 <sinelaw>         $ Draw.convexPoly
06:24:22 <sinelaw>             [(1,1),(1,-1),(-1,-1),(-1,1)]
06:24:34 <Peaker> sinelaw: what's the type of box?
06:24:44 <sinelaw> box :: Draw.Draw ()
06:24:50 <dons> newsham: yeah, some of the xbox live game analysis was done using F#, according to CUFP.
06:25:00 <dons> there was a finance place using F# at CUFP this year too.
06:25:01 <sinelaw> 'Draw a' is an image, more or less
06:25:07 <monochrom> Strange, where is HWN?
06:25:08 <medfly> Craig`, I recommend against this choice of path
06:25:11 <newsham> so backend stuff for IT analysis
06:25:18 <dons> CS uses it. places that are in windows lock in, but need an FP language.
06:25:19 <ddarius> jfredett: Where's HWN?
06:25:24 <sinelaw> drawing :: Draw.Draw [Char]
06:25:24 <sinelaw> drawing = fmap (const "A") (Draw.color (0,0,1,0.5) box)
06:25:24 <sinelaw>           `mappend`
06:25:24 <sinelaw>           fmap (const "B") (Draw.translate (-0.1,0.2) box)
06:25:26 <Craig`> medfly, may you explain a little bit, please?
06:25:36 <medfly> Craig`, web developing.
06:25:36 <dons> sinelaw: use a paste bin?
06:25:43 <sinelaw> sorry :\
06:26:03 <medfly> Craig`, the people who do it often suck. I don't mean you will, but it may mean that you will have to work with them or their code.
06:26:13 <Peaker> sinelaw: that's the part I don't like
06:26:16 <medfly> Craig`, it's good to account for that.
06:26:20 <Peaker> sinelaw: The type is "Draw a" rather than Image
06:26:30 <Craig`> I plan to be a poor, free lancer :P
06:26:32 <dons> btw, pdxfunc.org is tomorrow night. we'll have a talk about Data.Binary, and one on the new cereal package.
06:26:37 <dons> maybe one on linux kernel modules too
06:26:39 <sinelaw> the 'a' is just to associate a value with it
06:26:40 <newsham> i wanna hear more about this iphone game :)
06:26:40 <Peaker> sinelaw: Its a Draw monad, instead of a simple Image monoid
06:26:45 <sinelaw> if i understand
06:26:48 * medfly high-fives Craig` 
06:26:49 <Craig`> but I'll probably change my mind several times during these years
06:26:55 <blackh> newsham: What do you want to know about the iphone game?
06:27:04 <newsham> "more" :)
06:27:05 <Peaker> sinelaw: I understand -- and its an unnecessary complication..
06:27:09 <medfly> Craig`, hurray for getting paid what is less than minimum wage in some countries to do web development!
06:27:11 <sinelaw> Peaker, nope, it's a monoid, not a monad
06:27:12 <blackh> newsham: Well, it is very gory.
06:27:19 <Craig`> haha :)
06:27:25 <newsham> first person with 3d models and stuff?
06:27:26 <Peaker> sinelaw: Its a Functor and a Monoid. Are you sure its not also a Monad?
06:27:37 <Craig`> haskell programmer + free lancer web dev + ruby on the side == win
06:27:38 <sinelaw> i'm looking at the code
06:27:38 <Peaker> sinelaw: the "drawing" example shows its a Functor (Uses fmap)
06:27:47 <sinelaw> and it isn't
06:27:53 <sinelaw> yes, it is a functor
06:27:58 <Philonous> dons: Linux kernel modules written in haskell?
06:28:05 <medfly> Craig`, it might be a good idea to highlight me from now on if you want to say something (I won't notice it otherwise)
06:28:27 <Craig`> ah okay, will do from now on, medfly heh :)
06:28:28 <sinelaw> Peaker, the fmap doesn't do much it's used only for the associated value
06:28:30 <blackh> newsham: Yes but isometric instead of first person.
06:28:46 <sinelaw> which isn't used for anything inside the library, i think
06:28:55 <Craig`> oh and kind of to everyone, if you talk to me, please include the backtick, as several people haven't, and thus no highlight
06:29:11 <newsham> is most of the iphone API handled from C++ code?
06:29:16 * ddarius would recommend having your client notice both.
06:29:30 <dons> Philonous: right
06:30:08 <blackh> newsham: Yes - we have some glue code of our own.
06:30:17 <sinelaw> Peaker, anyway it's a lot nicer than anything else i can see, and it seems pretty close to what you want
06:30:31 <sinelaw> and it uses SDL with OpenGL so it's fast
06:30:34 <Philonous> dons: Oh nice. I didn't even know that was possible. The OS kernel seems to be a place where one definitely wants to have a way to enforce static invariants
06:30:56 <newsham> philonous: also a place where I often dont want garbage collection :(
06:30:59 <newsham> or large runtime systems
06:31:02 <Craig`> right any ways, I'm off, bye guys :)
06:31:10 <Craig`> school tomorrow, and then I'll be on after :D
06:31:14 <HaskellLove> do you guys bother using $! or you just leave to Haskell do lazy evaluation always?
06:31:18 <sinelaw> bye Craig`
06:31:25 <HaskellLove> bye Craig` :)
06:31:33 <medfly> have fun Craig`
06:31:34 <dons> HaskellLove: strict eval semantics are sometimes useful for
06:31:38 <dons> all sorts of things.
06:31:47 <dons> and the language supports it, because it is useful.
06:31:48 <sinelaw> dons, that second line of yours evaluated lazily i guess
06:31:55 <Craig`> thanks guys, I'll do a bit more reading of LYAH on my PSP later on, mwha.
06:31:55 <EvanCarroll> @src inits
06:31:56 <lambdabot> inits []     =  [[]]
06:31:56 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
06:32:12 <newsham> philonous: sometimes you can write a small C shim, put it in the kernel, and have it talk with a userland program that does the messy work.
06:32:19 <newsham> and avoid putting complicated code in kernel
06:32:21 <BONUS> LYAH on a PSP, wow, that sounds rad
06:32:37 <ddarius> BONUS: Now you have to add gameplay to it.
06:32:40 <sinelaw> PSP will always be Paint Shop Pro to me
06:32:41 <EvanCarroll> @src tails
06:32:41 <lambdabot> tails []         = [[]]
06:32:41 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
06:32:44 <BONUS> oh damn!
06:33:26 <EvanCarroll> gah
06:33:29 <c_wraith> ooh.  lenses are nifty
06:33:37 <EvanCarroll> thos definitions look quite different to me...
06:34:02 <EvanCarroll> @src tail
06:34:03 <lambdabot> tail (_:xs) = xs
06:34:03 <lambdabot> tail []     = undefined
06:34:04 <Peaker> sinelaw: It doesn't really make a lot of sense to have  (Image a)
06:34:15 <Peaker> sinelaw: the associated value seems like an unnecessary complication
06:34:17 <monochrom> > "tail" == "tails"
06:34:18 <lambdabot>   False
06:34:45 <medfly> monochrom++
06:34:51 <Berengal> :O Lambdabot has function equality!
06:34:57 <medfly> it's not...
06:35:00 <EvanCarroll> I'm just trying to reconcile that tails doesn't call tail.
06:35:14 <EvanCarroll> nor, heads head.
06:35:18 <Peaker> sinelaw: what semantic model of Image does the "a" make sense for?
06:35:29 <Philonous> newsham: Yes, well, lazy evaluation in the kernel doesn't sound like too good an idea, either
06:35:31 <sinelaw> Peaker, i'm not sure why he put it there, but it's a small appendage
06:35:46 <dons> Philonous: what do you think mmap is ? :)
06:35:48 <aavogt> I think heads is id
06:35:52 <Peaker> sinelaw: An exposed one
06:36:00 <aavogt> > iterate tail "hello"
06:36:01 <lambdabot>   ["hello","ello","llo","lo","o","","* Exception: Prelude.tail: empty list
06:36:04 <monochrom> pattern-matching makes it unnecessary to call head/tail
06:36:07 <aavogt> > iterate init "hello"
06:36:08 <lambdabot>   ["hello","hell","hel","he","h","","* Exception: Prelude.init: empty list
06:36:17 <medfly> uh-huh
06:36:20 <sinelaw> Peaker, it's as close as it gets, this library, and nothing else exists
06:36:32 <sinelaw> i think it may be some leftovers from previous versions
06:36:39 <sinelaw> or maybe not
06:36:53 <sinelaw> you can fork it and remove that thing :)
06:37:04 <Peaker> conal: hey, you there? Do you have a nice 2d Image library implemented with fast GL-based rendering?
06:37:06 <dolio> > scanr (:) [] "hello"
06:37:07 <lambdabot>   ["hello","ello","llo","lo","o",""]
06:37:46 <nlogax> could someone point me to a function that gets every nth item of a list?
06:38:20 <aavogt> > until null tail "hello"
06:38:20 <conal> Peaker: hi.  i have something in the works.  not ready for release yet
06:38:21 <sinelaw> Peaker, I think he uses it only for 'hit' detection (it tells you which "Draw" was clicked on, for example)
06:38:21 <lambdabot>   ""
06:38:25 <Peaker> nlogax: takeWhile (not . null) . iterate (drop n)
06:38:30 <theclaw> when using Parsec, which module should I import? Text.ParserCombinators.Parsec? Or is this the "deprecated module"?
06:38:41 <conal> Peaker: it's like Pan but generates glsl (very fast)
06:38:46 <dolio> theclaw: That's the deprecated one.
06:38:47 <nlogax> Peaker: head asplodes. thanks!
06:38:59 <Peaker> nlogax: oops, that's not quite right :)
06:39:01 <aavogt> @hoogle untils
06:39:01 <lambdabot> No results found
06:39:18 <Peaker> > map head . takeWhile (not . null) . iterate (drop 3) $ "Hello world"
06:39:19 <lambdabot>   "Hlwl"
06:39:28 <benmachine> theclaw: I believe parsec3 prefers Text.Parsec
06:39:29 <aavogt> oh, I guess that could be takeWhile and iterate together
06:39:30 <Peaker> nlogax: missed a "map head" there
06:39:48 <EvanCarroll> why does iterate init, and inits return the same list in the reverse order
06:40:05 <sinelaw> Peaker, the graph model i've chosen is general to represent code, if you get what i'm going for... :)
06:40:17 <EvanCarroll> I think the behavoir of `iterate init` is more logical
06:40:21 <Peaker> EvanCarroll: good question -- I'd like inits to be like tails in this regard
06:40:26 <nlogax> Peaker: thanks, not quite comfortable with that level of composition yet, but i'll dissect it :)
06:40:31 <monochrom> > inits "abc"
06:40:32 <lambdabot>   ["","a","ab","abc"]
06:40:38 <theclaw> benmachine: when importing Text.Parsec, warnings are printed (e.g. "Warning: The export item `module Text.Parsec.String' exports nothing")
06:40:44 <dolio> EvanCarroll: "inits (x:xs) = map (x:) (inits xs) ++ [[]]" would be less efficient.
06:41:07 <benmachine> theclaw: that's odd, I don't get those
06:41:22 <Peaker> nlogax: its not complicated... iterate (drop 3) makes an infinite list resulting from dropping 3 on the front again and again.  takeWhile (not . null)  stops taking from that list once it becomes boring [], [], [], ...   and then   (map head)  takes the first element...
06:41:27 <Peaker> nlogax: you can examine the result after each stage:
06:41:36 <Peaker> > iterate (drop 3) $ "Hello world"
06:41:37 <lambdabot>   ["Hello world","lo world","world","ld","","","","","","","","","","","","",...
06:41:45 <ddarius> Text.Parsec.{String, ByteString, ByteString.Lazy} are basically just orphan instances.
06:41:49 <Peaker> > takeWhile (not . null) .  iterate (drop 3) $ "Hello world"
06:41:49 <benmachine> theclaw: how did you install it, and which version?
06:41:51 <lambdabot>   ["Hello world","lo world","world","ld"]
06:41:57 <HaskellLove> sum [1..1000000] - results in stack overflow, how to deal with this?
06:41:57 <Peaker> > map head . takeWhile (not . null) .  iterate (drop 3) $ "Hello world"
06:41:58 <lambdabot>   "Hlwl"
06:42:01 <benmachine> Text.Parsec.String apparently contains parseFromFile
06:42:01 <luqui> I'm trying to semantically model a set that can be folded with an associative, commutative operator.   What condition do I need to ensure that the result is always the same?
06:42:02 <ddarius> benmachine: That warning is expected.
06:42:04 <Peaker> nlogax: clear now?
06:42:14 <BONUS> HaskellLove: use foldl' (+) instead of sum
06:42:16 <Peaker> luqui: hey.. just talking about your drawingcombinators
06:42:20 <benmachine> well, okay then
06:42:26 <luqui> Peaker, oh?  :-)
06:42:48 <theclaw> benmachine: 3.0.1, I didn't install it system-wide, just in my homedirectory
06:42:50 <dolio> HaskellLove: Also, compile with optimizations on.
06:42:57 <nlogax> Peaker: yes! thanks again. i always have to do that with all but the most basic functions..
06:42:58 <Peaker> luqui: Seems nice - but we were wondering why you have the associated value -- why "Draw a" and not "Image" ?
06:43:02 <HaskellLove> dolio how to do that?
06:43:08 <monochrom> I don't understand "is always the same". Say, same as what?
06:43:09 <nlogax> still a humble noob.
06:43:11 <theclaw> benmachine: I just extracted the tar.gz from
06:43:12 <dolio> Pass -O2 when compiling.
06:43:14 <Peaker> nlogax: it becomes second nature very quickly :)
06:43:16 <ddarius> Well, they do all export parseFromFile.
06:43:19 <luqui> Peaker, drawingcombinators supports picking.  you have to know what you picked :-)
06:43:35 <theclaw> benmachine: oops. from http://hackage.haskell.org/package/parsec and invoke ghci with -ipath-to-parsec
06:43:59 <sinelaw> luqui, picking?
06:44:05 <HaskellLove> BONUS can you give me some theory what is going on and why foldl` saves the day, so i understand this deeper and not just on syntax level?
06:44:13 <luqui> sinelaw, giving it coordinates and seeing what is there.
06:44:18 <Peaker> luqui: what's the semantic model though?
06:44:21 <luqui> eg. to handle mouse clicks
06:44:23 <sinelaw> ah, that's what i thought
06:44:27 <monochrom> If you mean "folding in different orders/permutations gives the same result" then you've got it, associative commutative.
06:44:44 <Saizan> theclaw: i'm missing context but: rather than using -i one usually "cabal install" the library
06:44:45 <luqui> Peaker, written in the days before I was a purist about that.  Roughly R2 -> (Color, a)
06:44:48 <Peaker> luqui: Draw a = Coordinate -> (Maybe (Color, a))   or:   Draw a = Coordinate -> (a, Maybe Color) ?
06:44:48 <ddarius> Phantom type parameter /= "associated value"
06:44:56 <sinelaw> luqui, i'm working on this http://www.ee.bgu.ac.il/~noamle/graphui/design.html, and need a gui library
06:44:57 <Peaker> luqui: Color includes Alpha?
06:44:58 <blackh> HaskellLove: It's because if you don't force the evaluation of each +, you get a chain of thunks which are promises to give a value later... these take up space in memory.
06:45:01 <luqui> Peaker, oh yeah there is a maybe there.
06:45:13 <luqui> Peaker, yes including alpha.
06:45:15 <monochrom> But folding a set is restrictive.  1+1+1 is not folding a set, since {1,1,1}=1.
06:45:23 <dolio> HaskellLove: foldl builds up a nested "(...(2 + (1 + 0)))" in the accumulator. foldl' evaluates the accumulator before making the recursive call each time.
06:45:27 <monochrom> err {1,1,1}={1}={1,1,1,1,1,1,1}
06:45:43 <Peaker> luqui: where's the Maybe?  around the whole thing - so associated values of an image are spread in an arbitrary subset of the coordinates?
06:45:51 <blackh> HaskellLove: I think the reason why sum hasn't been re-defined to be foldl' (+) in the Prelude is because that's how the standard defines it.
06:45:57 <Paczesiowa> :t \Just x -> x
06:45:58 <lambdabot>     Constructor `Just' should have 1 argument, but has been given 0
06:45:58 <lambdabot>     In the pattern: Just
06:45:58 <lambdabot>     In the expression: \ Just x -> x
06:46:09 <luqui> Peaker, yeah it's around the whole thing.  R2 -> Maybe (Color, a)
06:46:10 <Paczesiowa> anyone else think that this should work?
06:46:15 <dolio> Or I guess it's (((0 + 1) + 2) + ...)
06:46:16 <ddarius> blackh: Indeed, changing to foldl' would change semantics.
06:46:22 <luqui> Peaker, again, roughly.  it might accidentally correspond exactly :-)
06:46:35 <HaskellLove> dolio: so foldl` kinda gets the next result and clears the rest, and then takes next result and clears rest... something like that?
06:46:50 <Peaker> luqui: I see -- that means that it matches conal's   Image a = R2 -> a, for  a = Maybe (Color, a)
06:46:58 <Peaker> s/a/b for one of those :)
06:46:58 <blackh> HaskellLove: Lazy evaluation gives you power, but it adds a bit to the learning curve.
06:47:35 <blackh> HaskellLove: foldl' does a 'seq' on the answer to each (+), and this forces it to evaluate the (+) operation each time round the loop.
06:47:37 <luqui> Peaker, yeah.  which i think is about as good as you can do if you are stuck to OpenGL.
06:47:39 <dolio> HaskellLove: The difference is "foldl f z (x:xs) = (foldl f $! f z x) xs"
06:47:45 <luqui> Peaker, might have been able to drop the Maybe.
06:47:46 <dolio> Since you mentioned $! earlier.
06:47:49 <Peaker> luqui: can it not be modularized into the "picking" part (which has an "a" but doesn't care about Colors) and the rendering part (which cares about colors, but not the picking part) ?
06:47:51 <ddarius> blackh: The behavior is obvious from the straightforward call-by-name rewriting semantics, which is a lot better than languages that lack TCO which -isn't- obvious from a straightforward rewriting semantics.
06:47:52 <dolio> Er, foldl'.
06:48:27 <Peaker> luqui: if you drop the Maybe, you want Applicative for "pure" (to create the "background" of the Image), probably
06:48:36 <ddarius> dolio, blackh: Just so you know, this was discussed quite a bit the other day with references and everything to no avail.
06:48:55 <luqui> Peaker, so you mean, draw :: Draw Color -> IO, and pick :: R2 -> Draw a -> a ?
06:49:01 <Peaker> luqui: the "picking" stuff is all about collision detection, isn't it?
06:49:14 <luqui> modulo my many errors in that line :-P
06:49:17 <Peaker> luqui: Yeah, I think so
06:49:31 <luqui> Peaker, the trouble is I cannot implement Draw like that, if it is to be a functor.
06:49:54 <Peaker> luqui: and also, s/Draw/Image :)
06:50:00 <luqui> right :-)
06:50:16 <ddarius> luqui: Why does it need to be a functor?
06:50:29 <Peaker> luqui: why can't you do it when its a Functor?
06:50:32 <sinelaw> isn't that only because of the picking? (the functoring)
06:51:02 <luqui> Peaker, well maybe I actually could.
06:51:13 <luqui> it would require a rethink of the internals, and I'm not totally sure it's possible.
06:51:22 <luqui> certainly can't go from R2 -> Color   into Image.
06:51:32 <Peaker> luqui: btw, with that definition, it becomes really elegant, model-wise, because pick is really the [[.]] function (if you flip it).  And draw is an optimized renderer for that
06:51:50 <Peaker> luqui: you don't have to provide [[.]] (-1) ...
06:52:00 <luqui> right.
06:52:20 <Peaker> luqui: its really nice to have a [[.]] function there, though - even nicer if you could actually call it that :)
06:52:21 <BrianB04> I have an odd question: Is there any companies out there using say Haskell or really any functional language and if so what do they build?
06:52:22 <luqui> so if you went from a to Color, you would be sure that you only had finitely many Colors
06:52:34 <Heffalump> GHC 6.12.1 RC2 seems to have stopped parsing the following (whereas RC1 did). Is this expected?
06:52:34 <ddarius> @where industry
06:52:35 <luqui> and you could push that back through the data structure to find what color to render each primitive...?
06:52:35 <lambdabot> I know nothing about industry.
06:52:38 <Heffalump>     rec <- if null args then return empty_slurpy
06:52:38 <Heffalump>            else slurp_recorded repository
06:53:02 <ddarius> BrianB04: There's a page on it on the Haskell front page and a conference dedicated to commercial use of FP languages in general.
06:53:07 <Peaker> luqui: I've not read it deeply enough (or I'm not well versed in GL terms enough) to follow that
06:53:08 <ddarius> BrianB04: So, yes.
06:53:09 <luqui> http://www.haskell.org/haskellwiki/Haskell_in_industry
06:53:26 <luqui> Peaker, yeah I am just sketching.  It might be tricky to pull off...
06:53:44 <luqui> actually, no
06:53:48 <luqui> it wouldn't work with the Applicative instance.
06:54:01 <Peaker> luqui: the one for "pure"?
06:54:08 <Peaker> luqui: (I don't see one in there now)
06:54:10 <luqui> <*> corresponds to "blending" and
06:54:22 <luqui> opengl only supports a few blending types.
06:54:33 <luqui> oh do i not have an applicative instance?
06:54:42 <luqui> right it isn't happy with the Maybe in the domain.
06:54:44 <Peaker> luqui: Functor and Monoid
06:54:58 <luqui> okay so i could continue not supporting Applicative then :-)
06:55:06 <nominolo_> MarcWeber: ping
06:55:32 <Peaker> luqui: And if you put the GL stuff in a separate module -- the (Image a) and [[.]] functions are really useful separately, too, without a GL dependency
06:55:39 <luqui> Peaker, oh but I *do* support over :: (a -> a -> a) -> Image a -> Image a -> Image a
06:55:41 <luqui> I would have to drop that.
06:56:07 <luqui> i suspect it would be pretty hard to make a useful drawing module without any sort of combination
06:56:11 <Peaker> over :: Draw a -> Draw a -> Draw a ; overlay :: (a -> a -> a) -> Draw a -> Draw a -> Draw a
06:56:17 <Peaker> luqui: you mean overlay?
06:56:20 <luqui> yeah
06:56:27 <luqui> pff, names, who needs 'em
06:57:11 <Beelsebob> luqui: you could always mess with texture buffers, and blending manually yourself in fragment shaders
06:57:11 <Peaker> luqui: It may be nicer to have a (Monoid a) constraint rather than taking a mappend-like function -- does having mempty solve your problem? :) (I'm not sure what the problem is)
06:57:15 <benmachine> < > pff, names, who needs 'em
06:57:15 <Beelsebob> but that would get slow, rapidly
06:57:36 <theclaw> benmachine: is there something wrong with how I use parsec?
06:57:42 <luqui> Beelsebob, uh... and compilation of Haskell code to fragment shaders!
06:57:51 <Peaker> luqui: I mean, replacing overlay with what you have for mappend:  overlay :: Monoid a => Image a -> Image a -> Image a
06:58:02 <benmachine> theclaw: pass
06:58:06 <Beelsebob> luqui: yep, it'd be easy
06:58:07 <Beelsebob> :D
06:58:10 <Beelsebob> >.>
06:58:16 <theclaw> benmachine: pass?
06:58:20 <luqui> Peaker, you could still map to a foreign type and back again
06:58:24 <benmachine> theclaw: I don't know
06:58:26 <luqui> I would have to drop functor
06:58:41 <luqui> which makes me very uneasy
06:58:45 <luqui> so much for composability....
06:59:07 <luqui> I could make a new class
06:59:08 <sinelaw> luqui, but don't you use fmap only for that picking feature?
06:59:15 <luqui> like ColorCompose a => Image a -> Image a -> Image a
06:59:15 <theclaw> benmachine: oh, okay
06:59:36 <luqui> sinelaw, yes, but we are discussing generalizing to a semantic domain where that type argument would play a more central role.
07:00:11 <luqui> and close it off to prevent new instances.
07:00:17 <Peaker> luqui: What if you don't let anyone create any Color value except your own module -- then noone can create (a -> Color) and fmap to Color :)
07:00:19 <sinelaw> i'm trying to follow, but what is that role? just Color?
07:00:29 <Peaker> luqui: Color could be a proof that the GADT constructor is the one you want?
07:00:42 <luqui> Peaker, *that* is a compelling idea
07:00:57 <luqui> Colors have proofs of their composition methods
07:01:05 <luqui> which are exactly the ones that opengl supports
07:01:32 <Peaker> luqui: so once you fmap -- you've lost rendering, and only have picking
07:01:37 <Peaker> luqui: iiuc
07:01:44 <Peaker> at least, lost fast rendering
07:01:46 <MarcWeber> nominolo_: pong
07:01:46 <luqui> no, fmap could work
07:02:07 <luqui> if you have a Image Color, then you can decompose the Color into the colors you need to render the primitives in
07:02:34 <luqui> and I could inject colors, RGBA -> Color, just can't go the other way.
07:02:35 <Peaker> luqui: Ok, it appears I may have helped without actually fully understanding the problem then.. :-)
07:02:41 <nominolo_> MarcWeber: hi, did you do your changes on top of the devel branch?
07:02:51 <MarcWeber> nominolo_: Yes
07:02:58 <luqui> Peaker, no you haven't.  you have tricked me into seeing something that doesn't exist. :-P
07:02:59 <luqui> nevermind
07:03:12 <nominolo_> MarcWeber: so Vim mode works with the devel branch now?  good
07:03:22 <MarcWeber> rebased on top of "Start some library documentation.  Horribly incomplete."
07:03:24 <nominolo_> That held up a possible release.
07:03:41 <MarcWeber> nominolo_: I'm not sure about ThingAtCurser. Maybe I tried the wrong location. But everything else: yes
07:03:42 <luqui> Peaker, if it were as simple as I just thought, why not just use RGBAs for everything and then fmap at the last second.
07:03:54 <MarcWeber> nominolo_: What is this outline module about ?
07:04:05 <nominolo_> I'm planning to split the Vim mode off, though.
07:04:11 <nominolo_> dunno, it's for Eclipse
07:04:28 <MarcWeber> nominolo_: What do you mean by off? Shall I mantain it in a different git repo?
07:04:53 <nominolo_> MarcWeber: Well, not sure about the different repo, but I want the release process to be independent.
07:04:57 <luqui> Peaker, okay, so backing up, you were talking about not letting anybody create a Color... right.
07:05:05 <luqui> the only Colors you can get your hands on are already inside Images.
07:05:16 <luqui> that works I think...
07:05:20 <MarcWeber> nominolo_ What does this mean to me?
07:05:20 <benmachine> I can't get djinn to do my bidding :(
07:05:25 <Peaker> luqui: I just asked conal if he had a similar library (for fast 2d image rendering with a nice model), he said he's got something but not ready for release: <conal> Peaker: it's like Pan but generates glsl (very fast)
07:05:37 <nominolo_> MarcWeber: I tried to fix the parts that broke due to my edits, but it was too much work.  So, my point is, I don't want to maintain it myself.
07:06:14 <luqui> Peaker, yeah i've heard him mentioning it here and there.  that's not really the role of drawingcombinators though, which was to be a pure functional wrapper around simple opengl drawings.
07:06:22 <HaskellLove> have you guys so far had the need to use heap profiling tools with Haskell?
07:06:25 <benmachine> the documentation for djinn seems to imply that it will always find a solution if one exists, is that true?
07:06:29 <MarcWeber> nominolo_: Sure. I could'nt mantain the emacs stuff either. That's why I put my email as maintainer. Are you fine with adding a note "vim broke, wait till Marc has fixed it"?
07:06:43 <MarcWeber> nominolo_: To be honest I'd like you to work on scion rather than writing vim script :)
07:06:43 <conal> pixel/fragment shaders are a great fit for functional images (R2->a)
07:06:57 <ddarius> benmachine: For the language it accepts and the restrictions it imposes, yes.
07:07:04 <nominolo_> MarcWeber: So, splitting would mean you don't have to wait for me to pull your changes.
07:07:09 <luqui> conal, I'll bet they are!  I'm excited to see what you have.
07:07:14 <MarcWeber> nominolo_: You may always ping me and I'll try to fix vim stuff as fast as I can.
07:07:28 <conal> :)
07:07:36 <nominolo_> MarcWeber: but, if you want to release things you'd have to release a version that works with the lastest scion release.
07:07:39 <benmachine> ddarius: I tried telling it about Functors and then getting it to work out functor-flip, and it seemed unable to do so
07:07:41 <MarcWeber> nominolo_: Maybe there is another option: What about officially pasting a link to my branch telling that vim stuff is merged in occasianally only?
07:08:02 <MarcWeber> nominolo_: This means I have to test master and devel?
07:08:02 <benmachine> my query was, Djinn> ? flip :: (Functor f) => f (a -> b) -> a -> f b
07:08:17 <luqui> conal, I haven't been finding my recent GPU programming that hard actually.  It seems like the main reason people find it hard is that it's a functional language in imperative clothes, so people try to do imperative stuff...
07:08:19 <nominolo_> MarcWeber: yeah, I want something that isn't dependent on whether you have time or not.
07:08:23 <benmachine> it said it couldn't be realised
07:08:36 <nominolo_> MarcWeber: no, I only use devel, because I try to make master the working version
07:08:39 <sinelaw> does anyone have any idea how to draw bezier curves in opengl?
07:08:50 <MarcWeber> nominolo_: You know: If vim users really care, then they will send you patches no matter when you make releases.
07:08:56 <sinelaw> (i know how to calculate them parametically, but that doesn't fit well with opengl)
07:08:59 <conal> luqui: i'm with you -- it's functional programming in disguise.
07:09:01 <luqui> sinelaw, you'll have to break them up into lines at some point.
07:09:05 <nominolo_> MarcWeber: I.e., master should always work (mostly)
07:09:11 <conal> luqui: which set up false expectations
07:09:14 <luqui> sinelaw, maybe the glu tesselation library can help?
07:09:39 <MarcWeber> nominolo_: Just go on. Let vim break. Don't care about it. Maybe add such a note.
07:09:40 <luqui> conal, so you are compiling to shader code using an embedded STLC?
07:09:49 <kmc> sinelaw, sample your parametric equations
07:09:53 <kmc> you can do that adaptively
07:09:56 <MarcWeber> nominolo_: Such as "last version which is known to work with vim is release : XX"
07:10:07 <ddarius> benmachine: Functors are not in the language that it can handle.
07:10:07 <sinelaw> kmc, i was hoping opengl has something more appropriate
07:10:23 <nominolo_> MarcWeber: Er, no, it should be a no-brainer for the user.
07:10:28 <conal> luqui: yeah.  and i'm struggling with doing CSE on typed syntax (GADTs)
07:10:37 <nominolo_> MarcWeber: Either we have support or we have none.
07:10:48 <ddarius> benmachine: Handling constructor classes like Monad and Functor requires rank-2 types in a dictionary translation and a (complete) djinn couldn't be made in such a case.
07:10:51 <MarcWeber> nominolo_: So how should it be? Did you even try to contact me when it broke?
07:10:59 <HaskellLove> have you guys so far had the need to use heap profiling tools with Haskell?
07:11:04 <benmachine> ddarius: so why is Monad in :environment?
07:11:08 <MarcWeber> nominolo_: Is there a solution at all?
07:11:09 <sinelaw> kmc, i guess luqui's direction is the way
07:11:12 <nominolo_> MarcWeber: If it works every now and then, then it's equivalent to not working for all intents and purposes
07:11:26 <kmc> ah, well i didn't use it when i did bezier curves
07:11:29 <Heffalump> HaskellLove: yes, I use GHC's one off andon
07:11:51 <theclaw> the Parser/GenParser types are deprecated too in Parsec 3?
07:11:53 <sinelaw> kmc, if you already did it though....do you still have it?
07:11:57 <dolio> benmachine: Because people keep putting it there.
07:12:04 <HaskellLove> Heffalump hmm, you bump into space leaks all the time, u work on big projects?
07:12:05 <nominolo_> MarcWeber: well, I would prefer a separate release process for the Vim support.  Just like Eclipse (and Vim)
07:12:06 <benmachine> hmph
07:12:07 <luqui> conal, yeah keeping those optimizations well-typed is a chore.  Have you tried doing it in Agda to see what your proofs need (and thus whether Haskell can encode the proof)?
07:12:07 <kmc> sinelaw, not convenient
07:12:17 <benmachine> okay, then.
07:12:35 <MarcWeber> nominolo_: How does this look like?
07:12:41 <conal> luqui: i sure haven't tried via agda.  hm.
07:12:51 <Heffalump> HaskellLove: not all the time, no. But yes, I have worked on biggish projects.
07:13:14 <Heffalump> and it's not necessarily just "space leaks", but general explosions in space usage caused by bad design.
07:13:17 <nominolo_> MarcWeber: well, it's really about the *.vim files.  I'm fine with Vim specific code on the Haskell side.
07:13:27 <sinelaw> luqui, i'm using your lib though to hide from opengl, so I guess i'll just use lines
07:13:35 <Heffalump> Or even just wanting to know where your compiled program is aborting, since time profiles aren't written out unless it completes.
07:13:39 <MarcWeber> nominolo_: git submodules ?
07:13:42 <luqui> conal, I worry that Haskell is not cool enough to prove the well-typedness of optimizations like that.  You might have end up with some unsafeCoerces :-(
07:13:54 <benmachine> I suppose I could just ask you guys what I was trying to ask it, which was that given flip :: (a -> b -> c) -> b -> a -> c you can generalise it to f (a -> b) -> a -> f b and there's an implementation for that
07:14:10 <benmachine> I was wondering if it's possible to implement (a -> f b) -> f (a -> b)
07:14:11 <dolio> benmachine: Or are you talking about the command line djinn or something?
07:14:20 <nominolo_> MarcWeber: never used those.
07:14:21 <benmachine> dolio: the command line one
07:14:23 <EvanR> comments, queries, insults about these two algorithms? http://pastebin.com/m353afeb3
07:14:23 <copumpkin> ben: I doubt it
07:14:29 <dolio> Oh. I'm not sure why it'd be there.
07:14:31 <copumpkin> benmachine: I doubt it
07:14:35 <Peaker> benmachine: for what "f" context?
07:14:36 <MarcWeber> nominolo_: So you want to remove all .vim files from the repo.
07:14:43 <copumpkin> benmachine: actually
07:14:50 <nominolo_> MarcWeber: move them into a separate repo, yes.
07:14:50 <MarcWeber> We keep only a link to the vim files in the README.markdown ?
07:14:57 <ddarius> :t \a -> fmap ($ a)
07:14:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
07:15:03 <benmachine> Peaker: well, any interesting one
07:15:16 <nominolo_> MarcWeber: right.
07:15:17 <conal> luqui: might be.  would be nice to know.  in other ways the pure GADT rep is so nice for compilation.
07:15:19 <luqui> sinelaw, if you have performance problems, I could add a "lineStrip" primitive that might help.
07:15:24 <dibblego> benmachine, Test.QuickCheck.Gen
07:15:26 <MarcWeber> nominolo_: About releases: You should start using tags then such as v1.0
07:15:41 <benmachine> Peaker: the first way around, you can do it with Functor, but I haven't managed that with the other way around
07:15:42 <MarcWeber> nominolo_: Then I know what is "devel" and what has been released.
07:15:57 <luqui> Peaker, thanks for the ideas about cleaning up the semantics of graphics-drawingcombinators.  Gives me some fun Haskell to do when I get the urge :-)
07:15:59 <Peaker> benmachine: For Functor, I don't think its possible, but for Applicative I think it should be
07:16:00 <nominolo_> MarcWeber: yep.  I have to make sure to make visible tags (i.e., ones with commit messages)
07:16:12 <Peaker> luqui: Awesome :-)
07:16:26 <benmachine> Peaker: I thought it might be but it's not obvious how
07:16:30 <sinelaw> luqui, i have a lot of work before tackling my curve's performance
07:16:37 <sinelaw> but thanks :)
07:16:45 <nominolo_> MarcWeber: I.e., git tag -s  or -a
07:16:58 <dolio> @type Data.Traversable.Sequence
07:16:59 <lambdabot>     Not in scope: data constructor `Data.Traversable.Sequence'
07:17:04 <dolio> @type Data.Traversable.sequence
07:17:05 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
07:17:15 <MarcWeber> nominolo_: I didn't knew about signed tags..
07:17:18 <kmc> conal, are you going to use these GLSL programs to transform video streams?
07:17:19 <Peaker> @djinn ((a -> b) -> f a -> f b) -> (a -> f b) -> f (a -> b)
07:17:20 <EvanR> kmc: what do you think of this http://pastebin.com/m5ef64e19 method of 'appending' to the back of a list ;)
07:17:20 <lambdabot> -- f cannot be realized.
07:17:29 <Peaker> benmachine: djinn doesn't think so
07:17:31 <MarcWeber> nominolo_: So it' my turn sending you an url where I'll host the vim files, right?
07:17:46 <luqui> Anyway, after that convo, I still have the question I came in here for.  What do you call a set that can be folded with an associative, commutative operator?
07:17:52 <benmachine> Peaker: yeah, but apparently djinn can't do this sort of thing, hence my original question
07:17:53 <nominolo_> MarcWeber: I could give you access to the google code project
07:17:56 <dibblego> @djinn (a -> f a) -> ((a -> b) -> f a -> f b) -> (a -> f b) -> f (a -> b)
07:17:56 <lambdabot> -- f cannot be realized.
07:17:56 <dolio> @instances-importing Data.Traversable Traversable
07:17:57 <lambdabot> Maybe, []
07:18:04 <luqui> Does that have to be finite, or can it be relaxed?
07:18:06 <nominolo_> MarcWeber: then just put it up there as a download link
07:18:06 <kmc> i did a project that had one component sort of like Pan, compiling to GLSL, and another language for wiring these filters together and to video input/output devices
07:18:13 <MarcWeber> nominolo_: THat would be fine because I could delete the issue 35 then :)
07:18:26 <dolio> If (->) r were traversable, sequence would be (a -> f b) -> f (a -> b) for monads f.
07:18:31 <nominolo_> Ok, do you have a google account?
07:18:35 <ddarius> benmachine: No, you can't.  Not with Monad and therefore not with Functor or Applicative.  Consider f = IO and the a -> f b being putStrLn :: String -> IO ().
07:18:36 <Peaker> @djinn (a -> f a) -> (f (a -> b) -> f a -> f b) -> (a -> f b) -> f (a -> b)
07:18:36 <lambdabot> -- f cannot be realized.
07:19:03 <copumpkin> @djinn Functor f => f (a -> b) -> a -> f b
07:19:04 <lambdabot> -- f cannot be realized.
07:19:32 <copumpkin> liar
07:19:51 <MarcWeber> nominolo_: git submodules let you add other git repositories the way you add directories. You can sayy vim_runtime_path must be cloned from git:/// rev 345e3. Then you can update scion and a submodule by running git submodule update or such. However you don't have to checkout the sumbodules. But this is too much hassle. Let's split and be done. All I'd like to see is a link to my repository.
07:19:55 <Peaker> benmachine: Ok, I think that maybe I have a proof for impossibility of Functor
07:20:14 <benmachine> ddarius: that sort of makes sense I suppose
07:20:21 <mreh> Reader monad doesn't make changes to the environment does it?
07:20:48 <EvanR> @src cycle
07:20:48 <ddarius> mreh: You can locally shadow the current environment, but you can't "change" it.
07:20:48 <lambdabot> cycle [] = undefined
07:20:48 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
07:21:05 <nominolo_> MarcWeber: So, can you PM me your google account name?
07:21:09 <MarcWeber> nominolo_: So send tell me whether I should host the code on github or on google and I'll create a new repository.
07:21:21 <benmachine> mreh: see 'local'
07:21:27 <benmachine> :t local
07:21:28 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
07:22:04 <Poulter> func :: Int -> Int
07:22:06 <Poulter> func a
07:22:07 <Poulter> 	| a == 1 = 0
07:22:08 <Poulter> 	| otherwise = a + b + c
07:22:11 <Poulter>   where b = 1
07:22:12 <Poulter> 	     c = b +1
07:22:14 <Poulter> I have a function of this format.
07:22:25 <monochrom> should use paste bin
07:22:25 <dschoepe> Is there an extension such that the pattern "Foo x x" would match values where both x's are the same? (Provided Foo is an instance of Eq, of course)
07:22:31 <Poulter> In this layout and can't seem to get the wheres to work.
07:22:33 <benmachine> Poulter: (1) use pastebin please (2) tabs are the devil
07:22:37 <kmc> dschoepe, none that i know of
07:22:41 <kmc> use a guard
07:22:44 <benmachine> tabs will ruin everything for you
07:22:45 <Peaker> benmachine: fmap (const 1) (f (\Secret -> Box)) -- gives me a Secret Box despite not having a Secret.
07:22:46 <benmachine> indent with spaces
07:22:54 <monochrom> put "|" more to the right, "where" more to the left.
07:23:01 <Poulter> Okay, will do, sorry will use pastebin in future
07:23:05 <dschoepe> kmc: yes, that's how I'm handling it at the moment.
07:23:12 <Peaker> benmachine: for: f :: (a -> f b) -> f (a -> b)
07:23:29 <mreh> so using Reader to draw the state of a game would be the correct abstraction
07:23:37 <benmachine> Peaker: okay
07:23:38 <monochrom> dschoepe: No extension in the foreseeable future
07:23:44 <mreh> what about updating the state?
07:23:58 <luqui> conal, have a sec to brainstorm some semantics?
07:24:04 <Poulter> how many spaces are normally used
07:24:06 <mreh> gathering events, then applying the effects
07:24:13 <benmachine> mreh: if you need to update the state then that depends on various but State is probably good
07:24:21 <dschoepe> monochrom: Hmm, I think I can see how this would be somewhat unclean anyway.
07:24:25 <conal> kmc: definitely video streams.
07:24:27 <benmachine> Poulter: I usually use no more than necessary
07:24:40 <benmachine> i.e. each new indentation level is only one space further in
07:24:43 <xerox> ?type flip flip
07:24:44 <benmachine> lots of other people use four
07:24:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
07:24:52 <xerox> nearly.
07:24:57 <conal> luqui: i'd love to.  about to leave though.  taking my daughter to a movie.
07:25:06 <monochrom> which movie?
07:25:09 <Peaker> benmachine: with Monad, its straight-forward.. With Applicative, I can't seem to find a way
07:25:10 <luqui> conal, cool, have fun :-)
07:25:19 <mreh> debbie does dallas
07:25:33 <conal> luqui: thx.  let's brainstorm soon!
07:25:34 <benmachine> Peaker: ddarius says it's impossible with monad
07:25:45 <Peaker> benmachine: Maybe I have a mistake
07:26:03 <luqui> conal, ok, thanks! :-)
07:26:08 <dibblego> @djinn (a -> f a) -> (f a -> (a -> f b) -> f b) -> (a -> f b) -> f (a -> b)
07:26:08 <lambdabot> -- f cannot be realized.
07:26:08 <copumpkin> peaker :: Maybe Mistake
07:26:33 <Poulter> right, tabs... bad...
07:26:33 <nominolo_> MarcWeber: ok, so I have no preference on where you host the *.vim files
07:26:40 <Poulter> *sorted and noted* thanks
07:26:55 <benmachine> Poulter: ghc has an option -fwarn-tabs if it helps
07:27:11 <Poulter> My course uses winhugs atm
07:27:17 <benmachine> oh
07:27:18 <benmachine> weeeeird
07:27:28 <Poulter> lol using GHC next semester.
07:27:34 <Poulter> :S
07:27:36 <monochrom> winhugs is fine
07:28:34 <Poulter> If one can program (not me it seems)
07:28:39 <sinelaw> @type curry
07:28:40 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
07:33:04 <ddarius> Here's a simpler example: Set f = Maybe, set a = Bool, set b = Int;  so we have (Bool -> Maybe Int) -> Maybe (Bool -> Int), if I pass in f True = Nothing; f False = Just 1, I clearly can't return Just g where g :: Bool -> Int and is total (unless I take advantage of the fact that I know b = Int), but how do I decide to return Nothing?  For Bool input I could conceivably enumerate and check if any are Nothing, but that won't
07:33:04 <ddarius>  work for infinite or abstract inputs.  I could always return Nothing but that doesn't generalize.
07:33:39 <Peaker> benmachine: Surprising that it isn't possible with Monad
07:34:28 <ddarius> Peaker: Not really when you consider that the a -> f b part can produce "side-effects" that depend on a.
07:34:52 <ddarius> (which can affect the value of b or even if b is returned at all)
07:34:53 <Peaker> ddarius: oh, nice way to look at it
07:35:16 <Peaker> @type sequenceA
07:35:17 <lambdabot> Not in scope: `sequenceA'
07:35:21 <Peaker> @hoogle sequenceA
07:35:22 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:35:22 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
07:35:30 <Peaker> ddarius: it seems similar to this
07:36:10 <benmachine> btw, has anyone actually /used/ functor-flip with any functor other than (t ->)?
07:36:21 <Peaker> I guess (a->) is not a Traversable?
07:36:41 <dolio> Yes, I remarked 20 minutes ago that it would be the sequence for (->) r. But of course, (->) r isn't.
07:36:58 <Peaker> dolio: ah, I was busy trying to work it out, I guess, sorry for missing that :)
07:37:06 <dolio> :)
07:37:16 <sinelaw> can I use type class constraints on GADT constructors?
07:37:36 <sinelaw> and is there any other way to use constraints on constructor parameters?
07:37:41 <Paczesiowa> sinelaw: there was something about it in 6.12 release notes
07:38:03 <Paczesiowa> sinelaw: you can constrain smart constructor
07:38:26 <sinelaw> something like: data Bla a where Bla :: Show a => a -> Bla a
07:38:32 <sinelaw> Paczesiowa, what's a smart constructor
07:38:36 <Peaker> so, Traversable is really for type constructors whose values of the given type are immediately available?
07:38:55 <Paczesiowa> sinelaw: cons x xs = x : xs
07:39:11 <Paczesiowa> sinelaw: cons is a smart constructor, because it works just like constructor
07:39:15 <sinelaw> Paczesiowa, but people can still use :
07:39:28 <Paczesiowa> sinelaw: you can hide default constructor
07:39:33 <Peaker> sinelaw: I think the GADT way is good
07:39:39 <sinelaw> Paczesiowa, just what i was thinking
07:39:50 <sinelaw> Peaker, is my Bla example valid?
07:39:55 <Peaker> sinelaw: I think so
07:40:06 <Paczesiowa> sinelaw: have you tried it:>
07:40:30 <sinelaw> Paczesiowa, i will, now
07:40:31 <Peaker> "trying it" may not be proof that it is valid - but since GADTs are a GHC extension anyway, the implementation is the spec? :)
07:40:43 <HaskellLove> Do you guys write tail recursive functions whenever you can, knowing the compiler will optimize evaluation like that? Or you don't bother with it?
07:41:10 <dolio> Incidentally, f (a -> b) -> a -> f b is the explanation of why eta expansion changes side effects in, say, ML (or any other impure language).
07:41:20 * dolio has to jet.
07:41:34 <Paczesiowa> dolio: could you explain?
07:42:26 <dolio> Paczesiowa: If you have a function f whose explicit effect type would be f (a -> b), and you instead write "\x -> f x", you're changing the explicit effect type to be a -> f b.
07:42:58 <Paczesiowa> dolio: huh, I finally get value restriction:)
07:43:10 * dolio disappears.
07:46:21 <heatsink> Unicode variable names are acutally coming in handy
07:46:36 <heatsink> ? = Consonant Unvoiced Epiglottal Plosive
07:47:24 <sinelaw> why do these two define conflicting 'color' names? aren't they of different type?data VRDNode = VRDNode { shape :: Shape, position, scale :: Draw.Vec2, color :: Draw.Color }; data VRDEdge = VRDEdge { width :: Double, points :: [Draw.Vec2], color :: Draw.Color }
07:47:30 <sinelaw> oops. disregard that.
07:47:31 <Paczesiowa> is this from that general Show package?
07:47:57 <gwern> that's general show, *sir*, to you!
07:47:58 <sinelaw> this is what i meant: data A = A {  color :: Draw.Color }; data B = B {  color :: Draw.Color }
07:48:17 <sinelaw> I get: Multiple declarations of `blabla.color'
07:48:26 <ddarius> sinelaw: Field selectors are just functions.
07:48:49 <ddarius> sinelaw: They are not scoped any more than if you explicitly implemented them.
07:48:53 <Paczesiowa> gwern: :D
07:49:17 <gwern> sinelaw: what's the type of 'foo = color'?
07:50:19 <sinelaw> that would be ambiguous
07:50:38 <sinelaw> but why does that prevent me from defining it? if I don't use it ambiguously
07:50:56 <gwern> 'let me POKE there, I won't be ambiguous or unsafe!'
07:51:41 <sinelaw> ok. :)
07:56:54 <rasfar> sinelaw: I agree this is a pain.  There was some fairly recent discussion about a TypeDirectedNameResolution proposal, but I just found it and don't know more than that it pertains.
07:56:58 <sinelaw> how do i enable kind signatures in the language pragma?
07:57:52 <sinelaw> rasfar, i'm too know on this to have a real opinion :) i was just confused, because if the two functions have different types why shouldn't they coexist
07:58:13 <EvanR> > read "56"
07:58:13 <lambdabot>   * Exception: Prelude.read: no parse
07:58:18 <EvanR> :(
07:58:58 <heatsink> sinelaw: KindSignatures
07:59:10 <sinelaw> thanks just got it :)
07:59:48 <benmachine> sinelaw: if you made a HasColor typeclass then technically they could, but that'd be a bit... horrible
08:00:01 <ddarius> benmachine: It would be pretty reasonably.
08:00:07 <ddarius> s/reasonably/reasonable
08:00:18 <benmachine> ddarius: mm, I suppose it wouldn't be too bad
08:00:28 <benmachine> but it would hurt if you did one for every single record selector
08:00:46 <rasfar> sinelaw, i'm a rank novice myself, but regarding your last point, this could cause a problem if refactoring caused the types to converge at some future point.
08:01:13 <sinelaw> true
08:01:35 <sinelaw> oops, s/know/new/ up there....better go to sleep
08:01:47 <kmc> TypeDirectedNameResolution sounds bad and un-haskelly
08:02:07 <benmachine> agreed
08:02:24 <benmachine> but record syntax is also bad
08:02:27 <kmc> yeah
08:02:29 <rasfar> Maybe so.  But this record selector uniqueness thing is terrible.
08:02:46 <EvanR> record syntax is bad?
08:02:58 <ddarius> rasfar: It has been proposed and would seem quite reasonable to simply automatically generate those "HasColor" classes.
08:03:00 <rasfar> It doesn't scale well.
08:03:02 <kmc> EvanR, i think so.  because they're just sugar, but i think they make the syntax worse, not better
08:03:13 <ddarius> rasfar: Put each record in its own module.
08:03:32 <heatsink> heh
08:03:36 <benmachine> EvanR: the syntax for setting records, especially for applying a function to a record field, is a pain
08:03:50 <HaskellLove> Wow, the @ operator is good for the Copying problem. Anyone has done this?
08:03:56 <kmc> @ operator?
08:04:02 <kmc> do you mean the @ syntax in patterns?
08:04:03 <monochrom> @faq can haskell type-directed-write code for you and render you, yes you, a waste of CO2 quota?
08:04:03 <lambdabot> The answer is: Yes! Haskell can do that.
08:04:23 <HaskellLove> kmc - you can label function parameters with it
08:04:42 <kmc> HaskellLove, not just function parameters
08:04:49 <kmc> anywhere a pattern is used
08:04:50 <benmachine> what's the copying problem anyway?
08:04:56 <kmc> if p is a valid pattern, then x@p is a valid pattern
08:05:04 <EvanR> benmachine: havent gotten there yet... what is the alternative?
08:05:22 <HaskellLove> kmc cool i did not know that i thought it is only for parameters, thanks
08:05:25 <monochrom> f (x:xs) = x:xs  instead of  f p@(x:xs) = p   is the copying problem and copying solution.
08:05:26 <benmachine> EvanR: there's an alternative?
08:05:34 <ddarius> f = id
08:05:36 <kmc> HaskellLove, what are you reading to learn Haskell?
08:05:43 <EvanR> a hash table ? :)
08:05:50 <copumpkin> no hash table!
08:05:52 <copumpkin> bad!
08:05:53 <HaskellLove> a book called: algorithms a functional approach
08:05:56 <benmachine> heh
08:06:20 <benmachine> that's doing work at runtime that should be done at compile time, if you ask me
08:06:27 <copumpkin> HaskellLove: not sure that's an introduction to the language
08:06:29 <ddarius> benmachine: Indeed.
08:06:38 <kmc> hmm, looks like not a Haskell book
08:06:44 <kmc> but rather an algorithms book using Haskell
08:06:51 <netinho2lol> sup, funky town?
08:06:51 <HaskellLove> copumpkin - as introduction i read two other books, but stopped at monads sections so i do this one now
08:06:56 <medfly> bad hash table! bad! shoo!
08:07:06 <copumpkin> HaskellLove: not sure you're at the point to do that yet
08:07:07 <HaskellLove> kmc yes it is haskell book
08:07:15 <copumpkin> if you hadn't even seen lambdas until an hour or two ago
08:07:19 <kmc> HaskellLove, how do you mean?
08:07:32 <medfly> HaskellLove said he used some high level language, it may have had lambdas
08:07:32 <kmc> the subject of the book is not learning Haskell
08:07:35 <HaskellLove> copumpkin haha man i have done lambda long before this no worries :)
08:07:43 <kmc> "lambda" is just syntax
08:08:00 <kmc> first-class functions are the significant feature
08:08:08 <monochrom> f (Left a) = Left True; f (Right b) = Right b  is not   f (Left a) = Left True; f p@(Right b) = p.  Different most-general-type.
08:08:17 <HaskellLove> kmc yes but i am at page 90 and everything is cool so far, i got like 150 more pages so... it is going ok
08:08:25 <medfly> you're quick!
08:08:32 <kmc> HaskellLove, but you have gaps in your knowledge, because you are not learning the language as such
08:08:35 <kmc> that may or may not be a problem
08:08:45 <benmachine> monochrom: interesting
08:09:01 <monochrom> So the compiler should not introduce p automatically because it does not know what you want.
08:09:11 <benmachine> the latter requires a Left Bool b?
08:09:19 <monochrom> Yes.
08:10:03 <monochrom> Something like Either a b -> Either Bool b  vs  Either Bool b -> Either Bool b
08:10:34 <HaskellLove> kmc - the problem is getting used to haskell syntax, i have done lot of reading before this trust me I did not fall from mars...
08:10:57 <HaskellLove> haskell aint that hard after all... or maybe i should get to monads to say that... oops :D
08:11:11 <benmachine> monads are easy
08:11:24 <monochrom> just overloaded operators
08:11:27 <benmachine> or at least they wouldn't be so hard if everyone wasn't so afraid of them
08:11:28 <kmc> HaskellLove, Haskell is very different from other languages, and if you think the differences stop at syntax, you are not paying attention
08:11:37 <netinho2lol> hey guys
08:11:51 <netinho2lol> are haskell classes the same as java interfaces?
08:11:59 <monochrom> No.
08:11:59 <kmc> netinho2lol, there are some similarities
08:12:00 <fizruk> no
08:12:24 <monochrom> But if you weaken to "like", "kind of like", "remotely resemble", then yes.
08:12:34 <kmc> netinho2lol, do you have a more specific question about typeclasses?
08:12:36 <netinho2lol> something like that
08:12:54 <sinelaw> @hoogle (Monoid a) => [m] -> (m-> a) -> a
08:12:54 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
08:12:54 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
08:12:54 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
08:12:56 <netinho2lol> kmc: just that question
08:13:03 <mauke> foo :: (Num a, Ord a) => a -> a -> a; foo x y = if x < y then x + y else x * y  -- hard to do in java
08:13:05 <mreh> :t ask
08:13:06 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
08:13:08 <netinho2lol> kmc: making a class as we speak
08:13:11 <kmc> cool
08:13:20 <netinho2lol> Iterable class
08:14:11 <mreh> i don't understand that type
08:14:24 <monochrom> My perspective: typeclass is for overloading operators such as + - * /  in an organized fashion.
08:14:25 <kmc> (MonadReader r m) => m r
08:14:39 <kmc> monochrom, i think that's an overly specific definition
08:14:42 <sinelaw> @hoogle (Monoid m) => [m] -> m
08:14:43 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
08:14:43 <lambdabot> Prelude head :: [a] -> a
08:14:43 <lambdabot> Prelude last :: [a] -> a
08:14:43 <kmc> that's one (and the original) use case
08:14:44 <ddarius> In my perspective, "type class" is written "type class"
08:14:57 <sinelaw> @src mConcatMap
08:14:57 <lambdabot> Source not found. I am sorry.
08:15:01 <sinelaw> @src mconcatMap
08:15:01 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:15:02 <kmc> mreh, what don't you understand about the type?
08:15:08 <sinelaw> moo
08:15:24 <rasfar> (ddarius, kmc, i suppose the record selection syntax isn't a huge problem, if programs are well structured)
08:15:24 <mreh> I can't parse the context
08:15:27 <Berengal> monochrom: I see it less as overloading and more as specifying open sum on which a function is applicable
08:15:36 <sinelaw> @hoogle mconcat . map
08:15:36 <lambdabot> Parse error:
08:15:36 <lambdabot>   --count=20 "mconcat . map"
08:15:36 <lambdabot>                      ^
08:15:42 <kmc> mreh, MonadReader is a 2-parameter typeclass
08:15:46 <monochrom> kmc: That is why I qualify with "My perspective". It has the benefit of detaching from the toxic association with OOP.
08:16:00 <benmachine> mreh: MonadReader is a multi-parameter type class that includes things that can be read from, basically
08:16:04 <dibblego> @type foldMap -- sinelaw?
08:16:04 <lambdabot> Not in scope: `foldMap'
08:16:07 <dibblego> blah
08:16:08 <ddarius> rasfar: As far as the update notation, that's meh.  As far as the scoping concern, I think having local modules would solve it and have other benefits as well.
08:16:09 <kmc> monochrom, i don't think OOP is toxic... it's important though that people not try to map the concepts 1:1
08:16:12 <benmachine> that was very vague
08:16:13 <benmachine> but
08:16:15 <sinelaw> @src foldMap
08:16:16 <lambdabot> Source not found. It can only be attributed to human error.
08:16:25 <benmachine> it might help to think about the Reader instance
08:16:35 <sinelaw> dibblego, it's in Data.Foldable
08:16:39 <monochrom> No, OOP is not toxic. The association is. The association is your "map 1:1".
08:16:40 <kmc> (MonadReader r m) means that a computation in Monad m carries around with it a value of type r which can be read on demand
08:16:50 <dibblego> @type Data.Foldable.foldMap
08:16:51 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
08:16:56 <benmachine> instance MonadReader r (Reader r)
08:16:58 <kmc> i don't think the association is toxic either, as long as you don't take it too far
08:17:01 <Paczesiowa> :i MonadReader
08:17:07 <benmachine> in the Reader monad, ask :: Reader r r
08:17:11 <kmc> it's an analogy rather than an exact equivalence
08:17:12 <mreh> benmachine: so both r and m are in MonadReader?
08:17:27 <mreh> or r and m make up a MonadReader
08:17:29 <kmc> mreh, no.  it's a 2-param typeclass, which means it's expressing a relation between those two types
08:17:35 <mreh> righty
08:17:44 <kmc> so it's not the same as (MonadReader m, MonadReader r)
08:17:47 <Paczesiowa> @info MonadReader
08:17:47 <lambdabot> MonadReader
08:17:47 <kmc> which would be a kind error
08:17:51 <kmc> @src MonadReader
08:17:52 <lambdabot> Source not found. It can only be attributed to human error.
08:17:58 <Paczesiowa> is there a fundep?
08:18:00 * benmachine hates lambdabot's auto-spelling0correction
08:18:04 <benmachine> *-
08:18:04 <kmc> probably m -> r
08:18:10 <Paczesiowa> why?
08:18:16 <Berengal> There's no fundep
08:18:20 <kmc> ok then
08:18:29 <sinelaw> dibblego, what's a foldable though?
08:18:29 <Paczesiowa> there are fundeps in MonadError
08:18:30 <benmachine> class (Monad m) => MonadReader r m | m -> r where
08:18:34 <benmachine> according to ghci
08:18:42 <kmc> that's a fundep
08:18:46 <Berengal> Really?
08:18:49 * monochrom loves lambdabot's auto-spelling-correction.
08:18:55 <benmachine> apparently so
08:19:03 <kmc> maybe it's to avoid ambiguity when using ask?
08:19:08 <Paczesiowa> weird - Reader (a,b) should result in MonadReader a m and MonadReader b m
08:19:09 <Berengal> That doesn't make much sense to me
08:19:09 <benmachine> monochrom: do you also love confusion and suffering?
08:19:10 <dibblego> sinelaw, any type constructor with a foldr/foldl
08:19:15 <monochrom> Yes.
08:19:20 <monochrom> @stab monochrom
08:19:20 <benmachine> ah, that explains it then.
08:19:20 * lambdabot throws some pointy lambdas at monochrom
08:19:27 <monochrom> See?
08:19:42 <kmc> @quote lambdabot
08:19:42 <lambdabot> lambdabot says: why on the earth whould I slap dons with a wet trout
08:19:53 * ddarius loves it when lambdabot's responses are perfectly appropriate.
08:19:54 <benmachine> Paczesiowa: so you'd have ask :: Reader (a, b) a and ask :: Reader (a, b) b doing different things?
08:19:54 <monochrom> I like getting stabbed when other people just settle for slapped.
08:19:58 <benmachine> then what if a == b?
08:20:04 <Berengal> Wait, can fundeps still be fully polymorphic?
08:20:17 <sinelaw> @quote sinelaw
08:20:18 <lambdabot> sinelaw says: It always ends in an insult.
08:20:28 <kmc> @quote lambdabot
08:20:28 <lambdabot> lambdabot says: * lambdabot secretly deletes lunabot's source code
08:20:44 <monochrom> @equate monochrom
08:20:44 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
08:20:44 <lambdabot> entire human race would have to be rewritten!
08:20:56 <netinho2lol> kmc: class is done http://pastebin.com/d9f74a15
08:21:11 <mreh> why did Charlie Parker write a Haskell book?
08:21:24 <mreh> how did Charlie Parker write a Haskell book?
08:21:25 <netinho2lol> ghci doesn't choke on that, so I guess it's fine
08:21:31 <Paczesiowa> benmachine: if a==b then it's ambiguous
08:21:36 <sinelaw> > repeat "mreh"
08:21:37 <lambdabot>   ["mreh","mreh","mreh","mreh","mreh","mreh","mreh","mreh","mreh","mreh","mre...
08:21:47 <mreh> hey that's me!
08:21:52 <netinho2lol> mreh: he played the sax
08:21:55 <benmachine> Paczesiowa: that sounds unpleasant
08:22:06 <mreh> who is this Bird fellow?
08:22:23 <Paczesiowa> benmachine: do you really care about situations when you use (a,a) as your state?
08:22:28 <Paczesiowa> benmachine: *env?
08:22:29 <netinho2lol> mreh: Maybe Twitter
08:22:47 <benmachine> Paczesiowa: why not?
08:22:48 <Paczesiowa> Bird is the word:)
08:23:00 <mreh> :t Just Twitter
08:23:01 <lambdabot> Not in scope: data constructor `Twitter'
08:23:19 <ddarius> @where bird
08:23:20 <lambdabot> I know nothing about bird.
08:23:30 <rasfar> R. Bird and P. Wadler: Introduction to Functional Programming
08:23:38 <Paczesiowa> benmachine: if so - you wouldn't ask about one Int, you would ask about both
08:23:59 <ddarius> @google "Algebra of Programming" "Richard Bird"
08:24:00 <benmachine> Paczesiowa: if you had a tuple I would say that in general you'd want both elements
08:24:00 <lambdabot> No Result Found.
08:24:14 * ddarius should fix whatever is wrong with the @google plug-in.
08:24:17 <kmc> indeed, you can use "fst <$> ask"
08:24:21 <kmc> or "asks fst"
08:24:22 <kmc> :t asks
08:24:23 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
08:24:32 <kmc> @google google
08:24:33 <lambdabot> http://www.google.com/
08:24:33 <lambdabot> Title: Google
08:24:34 <benmachine> so (Reader (a, b)) only really makes sense yielding (a, b)
08:24:34 <Paczesiowa> what he said:)
08:24:43 <benmachine> hence, fundep
08:24:49 <Paczesiowa> benmachine: I disagree
08:25:09 <Paczesiowa> benmachine: it makes uncomposable monads
08:25:22 <benmachine> um
08:25:25 <kmc> it's a bit ridiculous to have a compound state which is indexed by type
08:25:49 <benmachine> if I am to make sense of this it needs to be a more civil time
08:25:51 <Paczesiowa> benmachine: if you have m :: MonadReader Int a and m2 :: MonadReader String b, you cannot combine them with bind
08:26:11 <Berengal> Would it make sense to implement some specialized Reader monads? Say MapReader k v = Reader (Map k v), and some specialized combinators?
08:26:38 <Paczesiowa> Berengal: that's not the point, we want vs to have different types
08:27:15 <benmachine> Paczesiowa: you can combine MonadReader (Int, String) though?
08:27:24 <Berengal> Paczesiowa: I'm just idly wondering about something just remotely related.
08:27:26 <ddarius> Berengal: Most monads are specialized versions of (combinations of) basic monads.
08:27:34 <ddarius> E.g. the random monad is basically a state monad.
08:27:56 <Paczesiowa> benmachine: by writing very explicit lift
08:28:17 <Berengal> ddarius: True, but you don't usually see people implementing their own MyTypeReader monads. They use Reader or whatever and the combinators that are already there.
08:28:25 <copumpkin> ddarius: is there a "basis" of fundamental monads from which every other monad can be provably built?
08:28:52 <Paczesiowa> one monad to rule them all
08:28:52 <ddarius> copumpkin: {ContState} ...
08:29:12 <ddarius> copumpkin: But, one would need to characterize "every other monad".
08:29:47 <Paczesiowa> I'd rather see definition of "built"
08:30:10 <Paczesiowa> is id the master function because you can write every other function using id?
08:30:28 <Berengal> Paczesiowa: Using only id, you can only write id
08:30:38 <Berengal> @type id id id id
08:30:39 <lambdabot> forall a. a -> a
08:30:48 <Berengal> Which is provably id, qed.
08:31:48 <Paczesiowa> then there isn't such a monad - monad has kind *->*, and if you "apply" that master monad to itself (you can't do anything else) you get (*->*)->*
08:31:59 <Berengal> @type Cont
08:32:00 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
08:32:24 <Berengal> @where MoaM
08:32:24 <lambdabot> I know nothing about moam.
08:32:53 <Berengal> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
08:35:55 <heatsink> copumpkin: Useful monads always have extra "primitive" functions beyond the basic monad operations though. I doubt it's possible to put a limit on what those can do.
08:36:39 <heatsink> erm... to bound the set of such functions.
08:39:16 <MarcWeber> ?where fps
08:39:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
08:41:19 <eugenn> @pl palabrasQueNoEmpiezanConEnCada caracter listaArticulos = [ length [ palabra | palabra <- articulo, not (empiezaCon caracter palabra) ] | articulo <- listaArticulos ]
08:41:19 <lambdabot> palabrasQueNoEmpiezanConEnCada = flip flip [] . ((:) .) . (<-) . (| articulo) . length . (palabra | palabra <- articulo :) . return . not . flip empiezaCon palabra
08:43:10 <copumpkin> eugenn: @pl works in pm too :)
08:43:49 <copumpkin> eugenn: also, @pl doesn't know about list comprehensions
08:43:50 <copumpkin> :)
08:44:03 <eugenn> hehe sorry for that. I guess it doesn't do a good job with list comprehensions. or maybe is my hugs
08:44:05 <eugenn> oh I see
08:44:08 <EvanR> compute the length of the part of the list before the first zero
08:45:35 <copumpkin> @undo [ length [ palabra | palabra <- articulo, not (empiezaCon caracter palabra) ] | articulo <- listaArticulos ]
08:45:35 <lambdabot> concatMap (\ articulo -> [length concatMap (\ palabra -> if not (empiezaCon caracter palabra) then [palabra] else []) articulo]) listaArticulos
08:45:41 <copumpkin> @pl concatMap (\ articulo -> [length concatMap (\ palabra -> if not (empiezaCon caracter palabra) then [palabra] else []) articulo]) listaArticulos
08:45:41 <lambdabot> length (=<<) (flip (ap (if' . not . empiezaCon caracter) return) []) `fmap` listaArticulos
08:45:47 <copumpkin> still not ideal :)
08:46:10 <Paczesiowa> is unsafePerformIO standard (some ffi stuff) ?
08:46:22 <copumpkin> you can just not put your FFI thing in IO
08:46:51 <Paczesiowa> copumpkin: what?
08:47:18 <copumpkin> if your foreign call is referentially transparent, you're allowed to just have a non-IO return value for the FFI declaration
08:47:20 <luqui> psh, lambdabot is composable :-)
08:47:29 <monochrom> unsafePerformIO is part of FFI
08:47:40 <luqui> @. pl undo [ length [ palabra | palabra <- articulo, not (empiezaCon caracter palabra) ] | articulo <- listaArticulos ]
08:47:41 <copumpkin> luqui: some of its plugins don't compose nicely
08:47:41 <lambdabot> length (=<<) (flip (ap (if' . not . empiezaCon caracter) return) []) `fmap` listaArticulos
08:47:48 <copumpkin> but those ones do :)
08:47:55 <monochrom> FFI is an approved addendum to the standard
08:47:56 <heatsink> Huh, is ? really called "eth"?  Why not "edh"?
08:47:57 <copumpkin>  @src doesn't though
08:48:05 <Paczesiowa> and noone objected to unsafePerformIO ?
08:49:07 <monochrom> That cannot be answered until 70 years later when the committee meeting minutes are declassified. :)
08:49:07 <luqui> Paczesiowa, as long as you're FFI'ing, there is no safety to guarantee to begin with
08:49:08 <copumpkin> foreign import "foo" foo :: Int -> Int
08:49:31 <heatsink> Paczesiowa: There were some apologetics about it in the FFI spec that said roughly what luqui said, so maybe someone objected
08:49:56 <Paczesiowa> luqui: as long as I stay in IO I know there is no safety - but please get your filthy side effects from my pure code
08:50:02 <monochrom> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ for questioners
08:50:13 <luqui> Paczesiowa, but you can import foreign code as pure
08:50:23 <Paczesiowa> luqui: that's also the problem
08:50:28 <luqui> Paczesiowa, I agree
08:50:36 <luqui> but the two decisions are entangled
08:51:36 <luqui> Paczesiowa, the classic example is, should you be forced to import "sin" from the C math library -- surely a pure function -- into IO
08:51:43 <Paczesiowa> people object to UndecidableInstances because they can loop your typechecker, but hey there's nothing wrong with importing pure segfaults from C.
08:52:01 <copumpkin> it's all about putting the burden of proof on you
08:52:22 <Paczesiowa> that's the problem! I especially don't trust myself!
08:52:28 <monochrom> I think you are blowing both issues out of proportion.
08:52:41 <monochrom> both FFI and undecidable instances.
08:53:00 <Paczesiowa> I always thought that unsafePerformIO was ghc magic (nothing wrong with that) and not standard stuff
08:53:28 <luqui> well UndecidableInstances is GHC, if that makes you feel better...?
08:53:52 <monochrom> This is why I like to confuse people. I just have to give them facts and truth, and they freak out.
08:53:53 <luqui> I am a purist too, but I've come to peace by accepting that Haskell is not a perfectly pure language
08:54:15 <luqui> It puts practicality in front of purity sometimes, and I haven't found an anally pure language (much as I like the concept) that is as pleasant to use
08:54:20 <luqui> perhaps because of these practicality decisions
08:54:25 <ddarius> There's nothing particularly wrong with undecidable instances.
08:54:26 <Paczesiowa> luqui: it's so much different - if you use UI you have to enable some extension (and I can check if you did that), unsafePerfrormIO is easy peasy
08:54:51 <copumpkin> it would be cool if unsafePerformIO needed a language extension to be used
08:54:52 <luqui> Paczesiowa, you have lost me.
08:54:59 <ddarius> Paczesiowa: You can audit for unsafePerformIO by auditing what modules are imported.
08:55:00 <copumpkin> {-# LANGUAGE UnsafePracticality #-}
08:55:08 <copumpkin> gives you unsafeCoerce and so on
08:55:09 <heatsink> Paczesiowa: well, it's longer than most library function names, and it starts with "unsafe"
08:55:13 <luqui> copumpkin, I envisage "import unsafe Data.Unamb"
08:55:18 <ddarius> copumpkin: unsafeCoerce isn't practical
08:55:22 <luqui> nobody that you don't import unsafe is allowed to use unsafe*
08:55:34 <heatsink> Paczesiowa, and you import it from System.Unsafe
08:55:35 <copumpkin> luqui: I like that
08:55:36 <luqui> and they cascade.  so if you have no unsafe imports, you know you are safe :-)
08:55:47 <copumpkin> luqui: yeah, that's what I was aiming for
08:55:59 <Paczesiowa> heatsink: I don't need your source code to use your library
08:56:36 <kmc> after an update via "cabal install cabal-install" i have a weird cabal bug
08:56:39 <luqui> ddarius, yes it is.  There is typesafe code that Haskell cannot prove is typesafe...
08:56:43 <kmc> which i think i ran into before but do not remember how to fix
08:57:06 <kmc> whenever i run cabal it says:   cabal: n: openFile: does not exist (No such file or directory)
08:57:18 <kmc> where "n" is some single character that changes from run to run, and is sometimes non-printable
08:57:19 <Paczesiowa> luqui: why would you need unsafeCoerce in pure code?
08:57:20 <ddarius> luqui: That doesn't make it practical.
08:57:25 <kmc> anyone run into this?
08:57:46 <luqui> Paczesiowa, in case it is pure, well-typed code that is beyond Haskell's typechecking powers.
08:57:59 <luqui> FWIW i am *not* advocating this.  I am just trying to come up with answers to your questions
08:58:06 <eugenn> does anyone know where to find a good list of IRC channels about programming or different subjects?
08:58:23 <copumpkin> Paczesiowa: agda code compiled into haskell is full of unsafeCoerce (sadly)
08:58:27 <Paczesiowa> luqui: ok, you shall be spared:)
08:58:36 <ddarius> luqui: There are all kinds of things that can't be expressed in modern languages (such as [certain forms of] self-modifying code), that doesn't mean its practical to add features to allow it.
08:59:01 <Paczesiowa> copumpkin: still, I'd feel safer if it needed additional extension
08:59:06 <copumpkin> Paczesiowa: me too
08:59:15 <copumpkin> an infectious extension!
08:59:18 <luqui> ddarius, yeah that's true.  It's practical for Agda to have available when it is using Haskell as its target language though
08:59:49 <copumpkin> what's amusing is that the most proved code of all, agda, needs the scariest proof-evading mechanism ever to be compiled
09:00:13 <luqui> copumpkin, I would like to experiment with "import unsafe", but I think it involves modifying the .hi file spec, which makes an extension especially difficult.
09:00:26 <copumpkin> luqui: I thought .hi was meant to be somewhat extensible
09:00:45 <luqui> copumpkin, i guess... it just means that Agda's type system is cooler (more expressive) than Haskell's.
09:00:49 <monochrom> I fully expect that. No matter how you convert adga to machine code, machine code is still the scariest proof-evading mechanism.
09:01:03 <luqui> monochrom, touche
09:01:19 <luqui> copumpkin, could be.  I know very little about it :-)
09:01:32 <monochrom> Think of every "load" and every "store" as an unsafeCoerce.
09:02:33 <monochrom> Fun fact: floating point load instructions look at the bit patterns to determine whether the bit pattern is a valid floating point bit pattern. If not, throw exception.
09:03:03 <monochrom> That is about the only typechecking at the machine code level.
09:05:09 <ddarius> monochrom: PCC all the way.
09:05:44 <ddarius> monochrom: What type errors are there at the machine code level?
09:05:54 <HaskellLove> Anyone wants to talk deforestation of lists in pm?
09:06:11 <monochrom> I just said it. Invalid floating point bit patterns.
09:06:26 <benmachine> there are invalid floating point bit patterns?
09:06:42 <monochrom> A small minority.
09:08:05 <copumpkin> PEP want PCC
09:08:08 <heatsink> Paczesiowa: H98 file IO in GHC already uses plenty of FFI, though I'm surprised to see no unsafePerformIO calls.
09:08:14 <heatsink> copumpkin: PEP?
09:08:21 <copumpkin> proof-expecting processors :P
09:08:28 <heatsink> ah.
09:09:15 <Paczesiowa> heatsink: file IO is standard in haskell - I don't care how it is implemented by compiler/runtime
09:09:18 <heatsink> Of course, you run into the problem of needing a program to check the certificates.
09:09:35 <copumpkin> pff certificates
09:10:05 <kmc> the lazy IO uses unsafe iirc
09:10:19 <Paczesiowa> kmc: lazy IO is another really bad idea
09:10:38 <kmc> yeah i think so
09:11:14 <Paczesiowa> they wanted to be lazy so they had to be pure (because laziness doesn't play along with side effects) - so let's add lazy IO to standard lib. makes sense
09:11:28 <monochrom> poof by exercise
09:11:49 <heatsink> Paczesiowa: You'll want some standard libraries that use "blessed" unsafe IO though.  So there would still be a way of making unsafePerformIO usable without a compiler extension.  It would just be an extra layer of telling the compiler "yes, I really meant to do that".
09:11:56 <netinho2lol> what's an infix tree traversal(sp)?
09:12:07 <monochrom> spelling is right
09:12:20 <heatsink> netinho2lol: An inorder tree traversal?
09:12:35 <Paczesiowa> heatsink: I don't.
09:13:01 <netinho2lol> heatsink: left,root,right ?
09:13:01 <heatsink> Paczesiowa: You don't need to do I/O?
09:13:10 <heatsink> netinho2lol: yes
09:13:18 <Paczesiowa> heatsink: I can do IO in IO monad without unsafePerformIO
09:13:34 <monochrom> Strangely enough, http://www.haskell.org/haskellwiki/MonadFix#Lazy_algorithm_interleaved_with_effects exemplifies infix tree traversal. Don't worry about the haskell code. Just look at the tree and compare with "((3)4(5(1)))"
09:13:52 <heatsink> Paczesiowa: Yes, but underneath it's implemented with peek and poke.  You'll want to import that without turning on a compiler extension.
09:13:54 <netinho2lol> thank you
09:14:31 <Paczesiowa> heatsink: I don't have any problems with peek :: ... -> IO a, I have problems with unsafePerformIO
09:15:37 <netinho2lol> elems Empty = [] ;  elems (Node left number right) = elems left ++ number : elems right
09:15:40 <netinho2lol> :)
09:16:08 <monochrom> not sure if you need parentheses
09:16:13 <Paczesiowa> netinho2lol: use different data structure - difference lists
09:16:15 <monochrom> @quote monochrom module.where
09:16:16 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
09:16:23 <monochrom> @quote module.where
09:16:23 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
09:16:25 <copumpkin> he does
09:16:31 <heatsink> ah.  Well, the libraries probably could be implemented without unsafePerformIO.
09:16:50 <netinho2lol> Paczesiowa: I must use the Tree that teacher defined :P
09:16:53 <copumpkin> they only use unsafeInterleaveIO don't they?
09:16:54 <monochrom> > "ab" ++ 'c' : "def"
09:16:55 <lambdabot>   "abcdef"
09:16:57 <heatsink> And I/O code can mysteriously crash, but wouldn't mysteriously crash in another module unless it corrupts memory.
09:17:10 <Paczesiowa> netinho2lol: difference lists isntead of lists, not tree
09:17:23 <heatsink> So I can see a benefit to disallowing unsafePerformIO.
09:17:35 <netinho2lol> difference lists?
09:17:40 <gwern> @quote notype
09:17:40 <lambdabot> sproingie says: | {-# LANGUAGE NoTypeChecking #-}
09:17:47 <gwern> @quote gooey
09:17:47 <lambdabot> Botje says: the faster your brain blows, the faster we can get at the gooey insides!
09:17:48 <kmc> @quote LANGUAGE
09:17:48 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
09:17:53 <kmc> eek
09:17:55 <gwern> @quote chocolate
09:17:55 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
09:18:00 <copumpkin> lol
09:18:03 <gwern> @quote crunchy
09:18:04 <lambdabot> kmc says: the usual structure for a Haskell program is a crunchy IO shell with a  gooey chocolate pure function center
09:18:07 <monochrom> Why the hell is difference list brought up? For all you know this is just tree traversal homework.
09:18:07 <gwern> finally
09:18:24 <gwern> @quote alexandroff
09:18:24 <lambdabot> Wikipedia says: In topology, the long line (or Alexandroff line) is a topological space analogous to the real line, but much longer.
09:18:26 <Paczesiowa> netinho2lol: http://en.wikipedia.org/wiki/Difference_list
09:19:06 <Paczesiowa> huh, dons's middle name is Bruce
09:19:08 <gwern> the long line article makes zero sense to me :(
09:19:19 <gwern> Paczesiowa: he's aussie. what d'you expect, mate?
09:19:27 <Axman6> Paczesiowa: well yeah, he's australian
09:19:37 <copumpkin> Axman6: I assume your middle name is Bruce too?
09:19:41 <monochrom> Do you also enjoy going into kindergartens telling them to learn category theory.
09:19:45 <Axman6> both of them are, yes
09:19:48 <gwern> @quote brane
09:19:49 <lambdabot> sproingie says: if it makes Cale's brane asplode, i think there's no hope for me understanding it
09:19:53 <copumpkin> lol
09:19:57 <gwern> @quote sausage
09:19:57 <lambdabot> ray says: a monad tutorial is like a sausage factory
09:20:05 <kmc> @quote monad
09:20:05 <lambdabot> Cale says: What we need are monad tutorial transformers. // So that we can compose the features of monad tutorials
09:20:08 <gwern> @quote placeholder
09:20:08 <lambdabot> TomTobin says: ::facepalm::  I wrote "Foobar" as a placeholder as I was typing [for the author's name], and never replaced it [in my email].
09:20:10 <Paczesiowa> Well I've read his book, two papers, his blog and wikipedia has more knowledge
09:20:16 <gwern> @quote id.5
09:20:16 <lambdabot> ski says: > (let id :: (forall id. id -> id) -> id -> id; id id = id id in id) id 5
09:20:35 <xerox> gwern: it's just a counterexample, basically
09:20:37 <gwern> huh. we can do type sigs in let bindings?
09:20:44 <copumpkin> gwern: sure
09:20:53 <Paczesiowa> ScopedTypeVariables?
09:20:59 <copumpkin> I don't think it even requires that
09:21:02 <gwern> I thought we could only do the quasi-coercing thing like 5 :: Int
09:21:07 <ray> @quote cale
09:21:07 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
09:21:11 <gwern> @quote analogies
09:21:11 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
09:21:19 <gwern> @quote matrix.moment
09:21:20 <lambdabot> knobo says: I really like this :) I can see that haskell is really cool now. This i a "matrix moment" for me :)
09:21:24 <Paczesiowa> copumpkin: it does
09:21:32 <gwern> eh. I'm tempted to delete that knobo one
09:21:36 <gwern> @flush
09:21:46 <copumpkin> Paczesiowa: nope
09:21:59 <Paczesiowa> > let x :: Int = 1
09:22:00 <lambdabot>   not an expression: `let x :: Int = 1'
09:22:06 <copumpkin> it's right
09:22:07 <Paczesiowa> > let x :: Int = 1 in x
09:22:08 <lambdabot>   1
09:22:20 <copumpkin> Prelude> :t let a :: Int; a = 5 in a
09:22:20 <copumpkin> let a :: Int; a = 5 in a :: Int
09:22:24 <netinho2lol> Paczesiowa: I read the article, it's difficult for me
09:22:28 <monochrom> IIRC dons liked to say "blue pill red pill" too.
09:22:37 <kmc> @quote dons
09:22:37 <lambdabot> dons says: I think Pseudonym should submit some more @free patches,
09:22:38 <copumpkin> Paczesiowa: that's what the above expression used
09:22:46 <copumpkin> (I actually wrote it, but ski cleaned it up)
09:22:59 <kmc> a sig in a let binding is just like a sig at top level
09:23:09 <xerox> yeah he worked in the /pills/ department!
09:23:14 <kmc> a sig on a pattern is an extension
09:23:17 <monochrom> I never liked the "blue pill red pill" reference. Until one day I received in spams "take the blue pill to enlarge..."
09:23:23 <copumpkin> lol
09:23:29 <HaskellLove> I am reading how this indermediate lists artifact is produced when composing functions. I am reading a paper from MIT Eliminating Intermediate Lists in pH using Local Transformations, cool stuff, if u interested google it, there is pdf, and in hour talk to me in pm about it?
09:23:32 <Paczesiowa> copumpkin: oh, different notation (with a coma)
09:23:49 <copumpkin> HaskellLove: why pm?
09:23:57 <xerox> wait, it was PLS, not pills, but the logo were pills.
09:24:02 <xerox> http://www.cse.unsw.edu.au/~pls/PLS/PLS.html
09:24:03 <HaskellLove> so we dont flood here?
09:24:16 <xerox> for over-flow there is #haskell-overflow
09:24:21 <copumpkin> HaskellLove: if it's interesting, people here care
09:24:30 <HaskellLove> oki doki
09:25:03 <copumpkin> -overflow is typically for long explanations
09:25:07 <copumpkin> of stuff people here already know
09:25:35 <xerox> (I thought he felt the need for writing much without mixing conversations.)
09:25:36 <HaskellLove> well i will come back in hour or so with some questions i guess
09:25:43 <copumpkin> fair enough
09:28:16 <sproingie> i thought -in-depth was for long explanations
09:28:43 <monochrom> -in-depth is long and also deep, as in crazy math
09:28:52 <HaskellLove> well get ready then you math ninjas, i prepare a bag of questions
09:30:14 * kmc has a serious use for Acme.Time.Now
09:31:01 <copumpkin> ooh
09:31:09 <copumpkin> are you going to use don't as well ?
09:31:46 <sproingie> don't looks like a cute way to comment out debug traces
09:31:51 <blackh> Maybe you could implement lazy evaluation by combining them: don't now
09:32:00 <copumpkin> ooh
09:32:08 <monochrom> What is "don't"?
09:32:12 <sproingie> like do
09:32:14 <copumpkin> a joke function
09:32:14 <sproingie> but it doesn't
09:32:23 <Paczesiowa> like do but not:)
09:32:28 <mauke> it's not as cool as the original version, though
09:32:43 <Paczesiowa> @hoogle dont
09:32:44 <lambdabot> Network.Socket DontRoute :: SocketOption
09:32:49 <mauke> http://hackage.haskell.org/packages/archive/acme-dont/1.1/doc/html/Acme-Dont.html
09:32:53 <sproingie> @hoogle don't
09:32:53 <lambdabot> No results found
09:32:59 <sproingie> @hayoo don't
09:33:00 <lambdabot> Unknown command, try @list
09:33:02 <sproingie> bah
09:33:06 <mauke> you have to say "don't $ do"
09:33:22 <sproingie> clearly don't needs rewrite rules to correct that
09:33:23 <monochrom> haha
09:33:32 <mauke> perl lets you say: don't { print 42; };
09:33:37 <monochrom> I say "don't (do ...)"
09:33:41 <mauke> http://search.cpan.org/~dconway/Acme-Don-t-1.01/t.pm
09:34:05 <sproingie> relying on ancient perl4 syntax at that
09:43:00 <monochrom> Oh yay, HWN!
09:43:15 <copumpkin> HWN is like PWN
09:43:33 <Paczesiowa> yeah, but someone already spoiled all the quotes
09:43:41 <heatsink> mauke:INTERCAL syntax in a mainstream language?  Hell must have frozen...oh wait, it's perl
09:43:54 <mauke> and haskell
09:44:09 <monochrom> Hrm! "Haskell Web News" strangely has the same initials HWN too.
09:44:52 <Paczesiowa> is Haskell Web News Yet Another Dons's Project?
09:45:04 <ben> Is Haskell Weekly News on the web?
09:45:13 <Paczesiowa> ben: yes
09:45:38 <Paczesiowa> ben: there's a link in every haskell-cafe post, also on /r/haskell
09:45:54 <Paczesiowa> http://sequence.complete.org/hwn/20091213
09:46:06 <ben> I stopped reading either for reasons of suboptimal time management, thank you
09:46:39 <ben> An argument is to be made that since I am pointing this out at 2:40 on the night before a week day, I did not actually improve the situation, but still...
09:46:41 <Paczesiowa> syntax error: expected "or"
09:47:18 <ben> I meant 'both', I suspect
09:49:42 <monochrom> hahaha "Why? John D. Earle asked  about what benefits of purity in Haskell"
09:50:28 <Paczesiowa> is he that troll who uses html in emails?
09:51:21 <stroan> yes. I find myself reading all his posts for some perverse reason
09:51:53 <Paczesiowa> stroan: I stopped that, after every post I usually forget where I am
09:52:11 <lament> monochrom: that's mean! :D
09:55:15 <dons> the most eccentric person we've had in -cafe@ for many a year.
09:57:53 <copumpkin> dons: there was that other dude just recently though, he was pretty up there
09:58:29 <kmc> "Is Haskell a Fanatic?"
09:59:14 <dons> same guy.
09:59:19 <copumpkin> shelby moore
09:59:21 <stoop> Does http://www.cs.chalmers.se/~nik/ hang around here? (Niklas Srensson)
09:59:23 <dons> ah
09:59:23 <copumpkin> that's who I meant
09:59:40 <copumpkin> we should battle Shelby Moore and John Earle
09:59:46 <copumpkin> see which lasts longer
10:00:15 <dons> i imagine all of earle's posts written in a fountain pen with "From the desk of John Earle, Esq" in the letter head.
10:00:16 <monochrom> John Earle should battle John Searle, see which one has more artificial intelligence.
10:00:24 <kmc> haha
10:00:24 <dolio> Heh.
10:00:32 <stroan> did Shelby also use very large letters? if not my bets go on John, due to having larger words to throw at the issue
10:00:55 <monochrom> But please don't diss those who use fountain pens. I use a fountain pen too.
10:00:57 <HaskellLove> i know how to take a list untill a number that satisfies some predicate... but how to take the first number that satisfies a predicate, not a whole list, just that number? is there a built in or i have to write my own?
10:01:08 <monochrom> Although I don't write "from the desk of whatever"
10:01:12 <Paczesiowa> :t find
10:01:13 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:01:13 * copumpkin used a fountain pen when he was younger, before he forgot how to write
10:01:13 <dolio> You should get an e-mail client that doesn't display HTML by default.
10:01:27 <Paczesiowa> > find even [1,3,5,6]
10:01:28 <lambdabot>   Just 6
10:01:32 <dons> its a very pre-internet writing style.
10:01:53 <stoop> I guess not. :-P
10:02:31 <monochrom> telnet mail.isp.com 993  will not display html
10:04:35 <CalJohn> @src minimum
10:04:35 <lambdabot> minimum [] = undefined
10:04:35 <lambdabot> minimum xs = foldl1 min xs
10:04:42 <CalJohn> @src foldl1
10:04:42 <lambdabot> foldl1 f (x:xs) = foldl f x xs
10:04:42 <lambdabot> foldl1 _ []     = undefined
10:05:49 <xerox> with the right tip, fountain pens are wonderful.
10:08:34 <Axman6> xerox: yes they are
10:09:04 <Axman6> i use a very nice foountain pen for exams
10:09:15 <dolio> Gutsy.
10:09:15 <copumpkin> it's more painful for lefties
10:09:39 <xerox> it they are very smooth, it comes more naturally to write unreadable stuff, I understand
10:09:41 <copumpkin> but we were forced to use them in school
10:09:42 <stroan> copumpkin: you a lefty?
10:09:45 <copumpkin> stroan: yeah
10:09:55 <stroan> I've not found a pen that works well left handed
10:10:10 <copumpkin> it takes work to stop stuff from smudging
10:10:16 <copumpkin> keyboards > pens
10:11:03 <Woof> I was always scared to use fountain pens for exams. Someone spilling water could erase my answers D :
10:11:28 <Woof> And yes, they're quite careless with answer-papers here
10:11:43 <Axman6> stroan: i think you mean a language
10:11:56 <stroan> Axman6: ?
10:12:12 <Axman6> well, english isn;t really sedigned to be written left handed
10:12:17 <Axman6> designed*
10:12:29 <stroan> that's the script more so than the language itself, but yeha
10:12:54 <luite> I went back to ballpoint pens after finding out (a few times) that dropping a fountain pen with the nib down on a hard floor is not particularly good for the nib
10:13:04 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14137#a14137 please help me finish euler 12, i dont get that error
10:13:08 <copumpkin> luite: wow, I would never have guessed
10:13:09 <stroan> though given the human predisposition towards right handedness I'm surprised there are ANY right to left scripts
10:13:29 <copumpkin> HaskellLove: use `div` instead of /
10:14:16 <copumpkin> HaskellLove: note that you're not going to get an answer with that method unless you have a lot of patience
10:14:39 <HaskellLove> copumpkin thanks man, i will finish it and see where it takes me :)
10:14:40 <copumpkin> > scanl1 (+) [1..]
10:14:41 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
10:14:53 <xerox> triangular numbers!
10:15:01 <copumpkin> > scanl1 (+) [1,3..]
10:15:01 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
10:15:22 <xerox> squares!
10:15:23 <Axman6> powers :o
10:15:24 <copumpkin> > scanl1 (+) [1,4..]
10:15:25 <lambdabot>   [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,...
10:15:28 <HaskellLove> ok time for me to learn a new command... let me see what this scan thing is
10:15:32 <Axman6> uh, yeah
10:15:37 <copumpkin> ze pentagon!
10:15:38 <xerox> ?oeis 1,5,12,22,35
10:15:39 <lambdabot>  Pentagonal numbers: n(3n-1)/2.
10:15:39 <lambdabot>  [0,1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651...
10:15:42 <Axman6> @src scanl
10:15:42 <lambdabot> scanl f q ls = q : case ls of
10:15:42 <lambdabot>     []   -> []
10:15:42 <lambdabot>     x:xs -> scanl f (f q x) xs
10:15:45 <xerox> you're right!
10:15:46 <stroan> I found one of the biggest things doing project euler gave me was a better concept of how efficient algorithms are, in a real sense
10:15:57 <copumpkin> > scanl1 (+) [1,5..] -- I wonder what these will be! :P
10:15:57 <luite> > scanl f [1..]
10:15:57 <lambdabot>   [1,6,15,28,45,66,91,120,153,190,231,276,325,378,435,496,561,630,703,780,861...
10:15:58 <lambdabot>   No instance for (SimpleReflect.FromExpr [t])
10:15:59 <lambdabot>    arising from a use of `Simp...
10:16:05 <xerox> eheh
10:16:10 <kmc> HaskellLove, "command"?
10:16:13 <copumpkin> > scanl1 f [1..] :: [Expr]
10:16:14 <lambdabot>   [1,f 1 2,f (f 1 2) 3,f (f (f 1 2) 3) 4,f (f (f (f 1 2) 3) 4) 5,f (f (f (f (...
10:16:17 <HaskellLove> stop it you ninjas, you will brainfuck my brain
10:16:25 <HaskellLove> kmc yeah, i dont know scan
10:16:32 <kmc> it's not a "command"
10:16:36 * copumpkin remembers those old handheld scanners
10:16:37 <kmc> it's a function
10:16:39 <Axman6> > scanl f z [a,b,c,d]
10:16:40 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d]
10:16:40 <copumpkin> that you'd slide over the paper
10:16:42 <kmc> like any other you would define yourself
10:16:44 <kmc> @src scanl
10:16:45 <EvanR> its a function! its functional programming after all!
10:16:51 <lambdabot> scanl f q ls = q : case ls of
10:16:53 <lambdabot>     []   -> []
10:16:55 <lambdabot>     x:xs -> scanl f (f q x) xs
10:17:01 <aavogt> it's the same as the fold, except it you keep the accumlating variable
10:17:03 <Axman6> it's functions all the way down, until you hit turtles!
10:17:10 <HaskellLove> i say it is a command... la la la la
10:17:13 <copumpkin> what aavogt said
10:17:22 <Axman6> HaskellLove: you're wrong
10:17:33 <aavogt> so there's nothing new to learn about scanl
10:17:38 <HaskellLove> who cares man, i am a ninja
10:17:41 <copumpkin> > scanr (:) [] [1..]
10:17:45 <copumpkin> :(
10:17:45 <EvanR> HaskellLove: command is one of those words people will make fun of you for using. like calling a monitor a computer
10:17:46 * kmc facepalm
10:17:47 <copumpkin> isn't that sad?
10:17:51 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:17:57 <copumpkin> there we go
10:18:06 <copumpkin> > tails [1..]
10:18:15 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:18:22 <HaskellLove> EvanR: who care man i am a ninja
10:18:31 <copumpkin> HaskellLove: you may be a ninja, but I know kung fu
10:18:37 <copumpkin> and kung fu > ninja
10:18:37 <lament> it's not a command, it's a question
10:18:47 <Axman6> HaskellLove: may i ask how old you are?
10:19:02 <kmc> HaskellLove, the words we use to describe things matter.  they set up our intuition
10:19:05 <EvanR> statements expressions clauses oh my
10:19:10 <HaskellLove> 21 year old ninja
10:19:14 <kmc> if you use the word "command" to describe a function, you are setting up for profoundly bad intuition
10:19:22 <Axman6> really? :(
10:19:23 <xerox> > map (!!2) . take 20 . tail . tail . iterate (ap (zipWith (+) . ([0] ++)) (++[0] )) $ [1]
10:19:24 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210]
10:19:30 <copumpkin> xerox: zomg
10:19:50 <xerox> you're fast
10:19:57 <copumpkin> that's what she said
10:20:00 <HaskellLove> you call it a ninja i call it barbeque and we mean the same thing so what... a barbeque takes input meat and outputs meat ready to be eaten so...
10:20:00 <kmc> :(
10:20:01 <copumpkin> to me :(
10:20:22 <HaskellLove> Axman6 yeah i am pretty retarded for my age...lol
10:20:25 <aavogt> it's the bbq command
10:20:27 <copumpkin> HaskellLove: you can call it something else but when you come to ask questions we won't know what you're talking about
10:20:28 <Woof> HaskellLove: Nuh uh, a barbeque has side effects (smoke, etc.)
10:20:36 * Axman6 wonders just how long it will be before HaskellLove gets banned for the way he acts
10:21:04 <HaskellLove> hey wait i thought you guys are joking, Axman6 come on man... ok i am back to reading now
10:21:06 <mauke> oh, right, I forgot to ignore him
10:21:11 <heatsink> lambdabot: @src readList
10:21:11 <lambdabot> Source not found. Take a stress pill and think things over.
10:21:42 * heatsink meant to use /msg
10:22:30 <kmc> HaskellLove, agreeing on what words mean is a basic part of communication
10:22:51 <kmc> and you depend heavily on communication for your debugging process
10:23:01 <HaskellLove> kmc of course man i thought u guys were joking :) of course it is not a command :)
10:23:06 <kmc> ...
10:23:16 <mauke> it's spelled "you"
10:23:22 <kmc> @wn u
10:23:23 <lambdabot> *** "u" wn "WordNet (r) 2.0"
10:23:24 <lambdabot> u
10:23:24 <lambdabot>      adj : (chiefly British) of or appropriate to the upper classes
10:23:24 <lambdabot>            especially in language use
10:23:24 <lambdabot>      n 1: a nitrogen-containing base found in RNA (but not in DNA) and
10:23:25 <lambdabot> [5 @more lines]
10:23:26 <copumpkin> mayouke
10:23:30 <copumpkin> like that?
10:23:36 <aavogt> @more
10:23:37 <lambdabot>           derived from pyrimidine; pairs with adenine [syn: {uracil}]
10:23:37 <lambdabot>      2: a heavy toxic silvery-white radioactive metallic element;
10:23:37 <lambdabot>         occurs in many isotopes; used for nuclear fuels and
10:23:37 <lambdabot>         nuclear weapons [syn: {uranium}, {atomic number 92}]
10:23:37 <lambdabot>      3: the 21st letter of the Roman alphabet
10:28:11 <HaskellLove> is there built in function to take first element of list that satisfies a predicate and stop calculation there?
10:28:27 <mauke> head . filter f
10:28:38 <dibblego> @type find
10:28:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:28:50 <lament> @type (head . filter)
10:28:51 <lambdabot>     Couldn't match expected type `[a]'
10:28:51 <lambdabot>            against inferred type `[a1] -> [a1]'
10:28:51 <lambdabot>     Probable cause: `filter' is applied to too few arguments
10:28:57 <HaskellLove> oh yeah yeah find can do that cool...
10:29:30 <mauke> :t head . filter ?f
10:29:31 <lambdabot> forall a. (?f::a -> Bool) => [a] -> a
10:29:51 <lament> oh cool
10:30:48 <Cale> > find even [3,5,11,12,15,16]
10:30:49 <lambdabot>   Just 12
10:31:04 <copumpkin> spoon . head . filter f
10:31:07 * copumpkin coughs
10:31:09 <copumpkin> who needs find!
10:31:20 <Cale> spoon?
10:31:24 <mauke> :t (listToMaybe .) . filter
10:31:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:31:34 <copumpkin> @hackage spoon
10:31:34 <lambdabot> http://hackage.haskell.org/package/spoon
10:31:49 <Cale> ah
10:31:58 <Cale> That's... easily abused :)
10:32:04 <copumpkin> :P
10:32:13 * Axman6 would prefer if spoon were renamed safe, but doesn't mind either way
10:32:28 <copumpkin> I was thinking condom
10:32:37 <copumpkin> but that might be a little awkward
10:32:42 <Axman6> heh
10:32:45 <Cale> Well, it's not really safe. Catchable exceptions produce failures in referential transparency.
10:32:48 <aavogt> doesn't teaspoon do the trick here?
10:32:56 <copumpkin> aavogt: yeah
10:32:57 <Axman6> "just apply condom to head"
10:33:10 <copumpkin> Cale: we stick to the referentially transparent exceptions ;)
10:33:39 <kmc> :t gets head
10:33:40 <lambdabot> forall a (m :: * -> *). (MonadState [a] m) => m a
10:33:53 <copumpkin> Cale: there's a fairly involved discussion of it here: http://www.reddit.com/r/haskell/comments/acasn/tired_of_functions_that_could_live_in_maybe_but/
10:36:51 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14138#a14138 How am i suposed to fix this?
10:37:56 <stroan> (\x -> numberOfDivisors x > 500)
10:38:40 <copumpkin> HaskellLove: you might want a takeWhile instead of a find there
10:39:31 <HaskellLove> copumpkin that would give me a whole list :( i need just the first number
10:39:33 <Cale> If you're going that far, how about providing  knife :: (NFData a, Exception e) => (e -> b) -> a -> Either b a  and  butterknife :: (Exception e) => (e -> b) -> a -> Either b a
10:39:51 <copumpkin> Cale: that would reveal things that should not be revealed
10:40:10 <Cale> But it already does, in a sense.
10:40:15 <dolio> Cale: That breaks referential transparency. Spoon only breaks purity.
10:40:34 <Cale> eh? There's a difference between those two?
10:40:39 <dolio> In the Sabry sense.
10:40:47 <copumpkin> things like ((\True -> 5) False, error "blah")
10:41:04 <dolio> Well, I'd say so.
10:41:34 <copumpkin> Cale: the only thing spoon violates right now is the notion of monotonic definedness, as far as I've seen
10:41:46 <dolio> I usually take referential transparency to mean you can get different results for the same expression under the same evaluation strategy.
10:41:49 <copumpkin> it breaks _|_ into two classes, the truly _|_ and the "nulls" in other languages
10:42:10 <dolio> While purity as Sabry defines it is independence of evaluation order up to bottoms.
10:42:33 <copumpkin> Cale: it only catches certain exceptions, intentionally (unless you go back to version 0.1 :P)
10:43:05 <Cale> copumpkin: Well, a knife is certainly more dangerous than a spoon.
10:43:27 <copumpkin> Cale: indeed! :P
10:43:36 <copumpkin> I'll add that to version 0.4
10:43:41 <copumpkin> sharpKnifeDon'tUseIt
10:44:26 <copumpkin> although that might cause both roconnor and dcoutts to use it on me
10:46:19 <Draconx> a knife is an unsafeSpoon?
10:47:27 <HaskellLove> copumpkin scanl1 is faster then the way i started calculating triangles?
10:47:53 <HaskellLove> it probably uses space O(1) because it accumulates and garbage collects imediatly?
10:48:28 <aavogt> scanl1 as you can see only does additions
10:48:36 <aavogt> you were doing lots of multiplications
10:49:21 <copumpkin> HaskellLove: if you don't give it a reason to keep around the rest of the list, it'll get rid of both of those
10:49:25 <copumpkin> as you walk over them
10:49:56 <xerox> just give me a reason!
10:50:11 <EvanR> what is the most popular method of compressing/decompressing data
10:50:27 <EvanR> haskell zlib bindings?
10:50:32 <xerox> there're tar/gzip pure haskell impl
10:50:43 <copumpkin> :)
10:50:54 <EvanR> anything in the main libraries?
10:51:04 <xerox> they must be on hackage
10:51:38 <sjanssen> EvanR: the zlib bindings are on hackage.  The "main libraries" are intentionally pretty minimal
10:51:42 <aavogt> I think the zlib is in the haskell platform, but not with ghc by default
10:52:35 <EvanR> hmm wonder how easy it would be to implement a basic huffman encoding of a string... ;)
10:52:58 <HaskellLove> xerox oh i see so one sum and whoal triangle and i had like multiplications and shit... cool stuff, i start to like math
10:52:59 <xerox> matter of a fold
10:53:13 <sjanssen> EvanR: huffman coding is pretty easy, but not terribly fast
10:53:15 <Draconx> EvanR, 5 minutes?
10:53:20 <EvanR> heheh
10:53:27 <xerox> if it is RLE
10:53:49 <xerox> no it isn't.
10:56:19 <HaskellLove> guys any optimizations i can do here it is so slow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14139#a14139
10:56:39 <copumpkin> HaskellLove: as I told you
10:56:50 <Axman6> my first optiimisation would be... don't use massive function names
10:56:52 <copumpkin> testing every number less than a given one to see if it divides it
10:56:59 <copumpkin> isn't the best way to get a list of divisors :)
10:57:21 <HaskellLove> ok any other problem?
10:57:30 <aavogt> yeah, use the prime numbers
10:57:42 <copumpkin> HaskellLove: that's why it's slow
10:57:46 <copumpkin> bad algorithm = slow as hell
10:58:05 <copumpkin> the answer is in the tens of millions
10:58:28 <copumpkin> that means you'll have to test tens of millions of potential divisors to even determine that it's what you want
10:58:35 <copumpkin> and that ignores all the numbers that came before it
10:58:40 <HaskellLove> aavogt that wont save me... you still have other numbers....
10:58:51 <clarkb> HaskellLove: all products of the prime numbers
10:59:18 <copumpkin> once you have a prime factorization, getting the divisors is easy
11:00:03 <EvanR> so i did ghc --make, now i have .o files everywhere. wheres make clean? :)
11:00:05 <EvanR> are
11:00:10 <copumpkin> rm *.o
11:00:10 <EvanR> Makefiles usually used here
11:00:12 * copumpkin coughs
11:00:23 <tommd> EvanR: If you want 'make' like functionallity then cabalize.
11:00:26 <heatsink> EvanR: Have you used Cabal before?
11:00:27 <copumpkin> -fforce-recomp
11:00:32 <EvanR> no cabal
11:00:38 <tommd> Yes cabal
11:01:04 <clarkb> tommd: how did that project turn out in the end?
11:01:17 <tommd> The image recognition?
11:01:21 <clarkb> ya
11:01:45 <tommd> clarkb: Its running now.  I took a break after turning everything in and then remade it to use multiple layers
11:02:01 <tommd> clarkb: Long story short, it doesn't make any improvement when you don't have layers
11:02:13 <tommd> It does seem to evolve when you do have layers.  Yay
11:02:23 <clarkb> I am still training a NN. It has been going for forever now
11:02:28 <HaskellLove> well if real life has problems like eulers then programming is really math and i will need to change myself fundamentally
11:02:46 <tommd> clarkb: When starting things like that its good to have an idea of how long it could take.  Do you know?
11:03:03 <tommd> HaskellLove: Programming is really math.
11:03:09 <copumpkin> HaskellLove: algorithmic optimization is fundamental everywhere
11:03:17 <clarkb> no because of the randomness associated. I suppose I could profile some shorter runs and calculate how long the long runs will take
11:03:38 <clarkb> I did two large training runs that started at the same time. One finished a week ago. The other is still running
11:03:45 <copumpkin> HaskellLove: project euler's problems, after the first few, are designed so that there's a naive version that will take a million years to complete, and a smart version that will be done in under a minute
11:03:49 <tommd> clarkb: Not a bad idea.  If you can get a graph, figure out how the time increases, then you might get a good estimate.
11:04:25 <tommd> ... I'm hoping to break 1% accuracy by tomorrow on this GA.
11:05:32 <clarkb> if I really want to get the NNs to recognize things with some accuracy I will need to write quicker code and train on >> 40000 packets
11:06:37 <tommd> If you are that attached to the project then its time to optimize.  I'd encourage you to put it down and make something like a generic NN Haskell package and upload that to hackage.
11:06:41 <HaskellLove> copumpkin i am 21 years, is it too late to change fundementaly :( i mean look at these basic stuff i do not know, i know algorithm analysis and big o bla bla but these stuff i am bad, the eulers... or maybe i should just check wikipedia and do research more before i start solve... damn...
11:06:49 <tommd> Ha!
11:06:51 <clarkb> tommd: I am not that attached :)
11:07:28 <clarkb> I learned a lot and have basically realized the only way to do this effectively is probably with data inspection
11:07:28 <copumpkin> HaskellLove: it's never too late :P especially not at 21
11:07:43 * clarkb is 22 taught myself haskell in the last term
11:07:49 <tommd> clarkb: Good conclusion.  My thoughts exactly.
11:07:55 * copumpkin did the same at 24
11:08:02 <copumpkin> I wish I'd been exposed earlier
11:08:08 * tommd did the same... humm... 25?
11:08:11 <copumpkin> but it was a life-changing experience!
11:08:12 <clarkb> an NN trained to recognize bad packets accepts all good ones as well (not enough differentiation)
11:08:15 <sjanssen> HaskellLove: Project Euler has a definite slant towards numbers and number theory, you don't necessarily need to know all of it to be an effective programmer
11:08:23 <copumpkin> I'm not exaggerating
11:08:27 <tommd> clarkb: The headers can be identical.
11:08:30 <sjanssen> HaskellLove: of course, knowing more things is always better
11:08:31 <clarkb> ya
11:08:41 <tommd> Maliciously minded folks would make sure of it.
11:09:34 <tommd> clarkb: Going to pdxfunc tomorrow?
11:09:37 <HaskellLove> sjanssen> exactly, so should i delve deeper into number theory or should i just rely on internet research for the specific problem and sucesful implementation? or should i fill my folder with number theory books and get that in my blood slowly?
11:09:42 <clarkb> tommd: no, going to Seattle
11:09:51 <tommd> Oh - thats probably funner anyway.
11:10:00 <clarkb> HaskellLove: because it is quite useful
11:10:29 <tommd> clarkb: don't forget to visit the Left Bank book store!
11:10:37 <copumpkin> HaskellLove: you should take the initiative to look up the basic algorithms, at least. It's not hard at all to make the divisor-finding function efficient enough to find the answer, and you don't need to understand deep number theory
11:10:39 <sjanssen> HaskellLove: check out the "fundamental theorem of arithmetic" on wikipedia, that's the gist of what you need to understand to solve this problem efficiently
11:11:57 <RadioApeShot> So i have a question about the IO monad.
11:12:02 <RadioApeShot> Total Haskell newb here.
11:12:19 <tommd> RadioApeShot: Just ask, we're here.
11:12:25 <RadioApeShot> readFile has the type FilePath -> IO String
11:12:36 <RadioApeShot> So if I wanted to write a function which returned the first character of a file
11:12:47 <RadioApeShot> It should have type FilePath -> IO Char
11:12:49 <RadioApeShot> right?
11:12:55 <sjanssen> RadioApeShot: yes, exactly right
11:12:58 <RadioApeShot> Ok
11:13:10 <RadioApeShot> And I have to call it in a do block
11:13:15 <RadioApeShot> Ok.
11:13:23 <RadioApeShot> So I tried to write this function as
11:13:33 <EvanR> doesnt have to be in a do block
11:13:35 <sjanssen> RadioApeShot: well, there are alternatives to do-syntax, but it's a fine start
11:13:39 <tommd> RadioApeShot: Not to confuse you, but taking into account empty files you might want type FilePath -> IO (maybe Char)
11:13:48 <tommd> RadioApeShot: Not to confuse you, but taking into account empty files you might want type FilePath -> IO (Maybe Char)
11:13:50 <RadioApeShot> firstCharOfFile name = do x <- readFile name
11:13:52 <tommd> sorry, fixed type
11:13:53 <RadioApeShot> (head x)
11:14:02 <RadioApeShot> But I get a type error
11:14:13 <sjanssen> RadioApeShot: you're close, make that last line "return (head x)"
11:14:18 <RadioApeShot> Ah
11:14:19 <tommd> RadioApeShot: Right, because in a 'do' block all lines must be monadic.
11:14:19 <RadioApeShot> Return
11:14:33 <sjanssen> RadioApeShot: every line in the do block needs to be in the same monad, IO in this case
11:14:43 <RadioApeShot> That makes sense, I think.
11:14:51 <RadioApeShot> I actually implemented monads for Emacs Lisp.
11:14:52 <sjanssen> return injects a value into a monad
11:15:00 <RadioApeShot> But clearly you can implement a thing without understanding it.
11:15:14 <RadioApeShot> (head x) is type Char
11:15:15 <tommd> Humankind has done that for a long time.
11:15:25 <tommd> :t return (head x)
11:15:26 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
11:15:26 <lambdabot>     In the first argument of `head', namely `x'
11:15:26 <lambdabot>     In the first argument of `return', namely `(head x)'
11:15:33 <RadioApeShot> But return (head x) is IO Char
11:15:39 <tommd> yes
11:16:21 <RadioApeShot> Ok
11:16:24 <RadioApeShot> I get it now
11:16:31 <RadioApeShot> Thanks for the bump in the right direction.
11:16:44 <RadioApeShot> You guys are a lot nicer than the Common Lisp people.
11:16:49 <copumpkin> lol
11:16:50 <clarkb> is readFile lazy?
11:16:52 <EvanR> on the subject of file i/o, does haskells lazyness allow me to apparently read the entire file into the program at once and operate on the contents as if it were a single string in memory, but in reality it reads a little a time?
11:16:57 <sjanssen> clarkb: it is
11:17:09 <EvanR> clarkb beat me to it
11:17:12 <Axman6> RadioApeShot: or community is one of our biggest assets
11:17:17 <Raevel> i'd also be unfriendly if i was a common lisp guy
11:17:27 <Axman6> our*
11:17:35 <Axman6> RadioApeShot: heh
11:17:39 <Axman6> u7h, Raevel
11:17:40 <sjanssen> RadioApeShot: yeah, we're well known for being helpful.  It's one of the great selling points of Haskell
11:18:43 <tommd> Hopefully it lasts.  So long as Oregon still has beer I suppose it will.
11:19:05 <RadioApeShot> So in my actual life I am a scientist
11:19:09 <RadioApeShot> Statistical/modeling
11:19:11 <clarkb> it must still be buffered though?
11:19:15 <RadioApeShot> How is haskell for this kind of thing?
11:19:21 <RadioApeShot> I use Matlab and C these days.
11:19:22 <Axman6> RadioApeShot: fasntastic:)
11:19:30 <sjanssen> @faq
11:19:30 <lambdabot> The answer is: Yes! Haskell can do that.
11:19:49 <Axman6> haskell has some very awesome stuff for doing scientific work with
11:19:50 <RadioApeShot> What about multidimensional arrays?
11:19:53 <tommd> clarkb: Fair question, the OS would even if the RTS didn't.  I would bet the RTS reads page size chunks.
11:20:01 <Axman6> we've got those
11:20:08 <Axman6> both immutable and mutable
11:20:09 <RadioApeShot> Are they purely functional?
11:20:11 <RadioApeShot> Hm
11:20:17 <RadioApeShot> I prefer immutable stylistically
11:20:31 <RadioApeShot> But I've never programmed in a language where it was idiomatically feasible for md arrays.
11:20:38 <Axman6> even unboxed one, which act basically the same as C arrays  in performance
11:20:47 <tommd> RadioApeShot: We also have bindings to lots of well known C libraries - fftw for example.
11:20:49 <clarkb> tommd: ok
11:21:06 <aavogt> is fftw written in C?
11:21:09 <Axman6> and  BLAS/LAPACK
11:21:15 <Axman6> aavogt: and asm i think
11:21:21 <tommd> aavogt: I thought so, guess I just assumed so actually.
11:21:22 <copumpkin> fftw is written in ocaml
11:21:26 <copumpkin> but it generates c code
11:21:31 <tommd> ahh, I see.
11:21:37 <copumpkin> and uses some hand-coded assembly I think
11:21:40 <Axman6> mmmm, brie
11:23:11 <HaskellLove> sjanssen: http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic, how should this help me? I mean i need to find the number of all divisors of a number, not just prime factors...
11:23:45 <clarkb> all numbers are simply products of prime numbers
11:23:57 <clarkb> prime factorization gives you a number's divisors
11:24:06 <tensorpudding`> all the divisors of the number will be products of prime factors
11:24:52 <copumpkin> HaskellLove: if you know that a number factorizes to a^n * b^m * c^p, where a, b, c are primes
11:25:05 <copumpkin> HaskellLove: the number of divisors is (n+1) * (m+1) * (p+1)
11:25:16 <copumpkin> and it's fairly trivial to show why
11:25:28 <clarkb> its counting at that point
11:25:32 <copumpkin> yeah
11:25:37 <HaskellLove> i see...
11:25:43 <copumpkin> you can take each prime factor 0 times, 1 time, 2 times, up to n times
11:25:51 <copumpkin> and multiply them together
11:25:57 <aavogt> haha, trivial. That's what they say when they are too lazy to prove something
11:26:11 <copumpkin> aavogt: nuh uh! the proof is left to the reader ;)
11:28:13 <dons> there's something both good, but frustrating, about articles like this. http://eclipsesource.com/blogs/2009/12/13/persistent-trees-in-git-clojure-and-couchdb-data-structure-convergence/
11:28:50 <dons> we've been hammering on the correspondance between immutability, revision control, databases and stm for years, after all, with darcs, stm, haskell, tcache. :/
11:28:59 <blueonyx> @pl (\x xs -> (x+3):xs)
11:28:59 <lambdabot> (:) . (3 +)
11:30:06 <EvanR> nice. LYAH's graphics for I/O is a swanky terrorist smoking a cigarette holding what looks like a beaver hostage with a banana
11:30:50 <sproingie> i have no idea what it means but it's cute
11:31:16 <EvanR> it must represent the concept of IO in terms of functional programming
11:31:44 <sproingie> the beaver is IO and the terrorist is the IO Monad?
11:31:52 <sproingie> no escape
11:31:55 <EvanR> lol
11:32:32 <EvanR> i was thinking more along the lines of 'makes no sense'
11:32:32 <sjanssen> dons: it's like we're the new Lisp guys, "Any sufficiently complicated program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Haskell."
11:32:38 <mauke> that's a spy, not a terrorist
11:32:59 <dons> sjanssen: i think that's what bugs me.
11:33:01 <sproingie> ah like the team fortress spy
11:33:09 <Axman6> dons: heh, reading that, it seems that the whole idea of immutability is profound, but while i'm reading it, i'm just thinking "hmm, isn't this how you do trees? you mutate the changed parts and... well it's simple!"
11:33:25 <sproingie> i got used to immutable data structures in MOO of all things
11:33:37 <copumpkin> dons: yeah, the clojure people are enthusiastic, and share our cause, but seem to ignore history
11:33:38 <Axman6> MOO?
11:33:45 <EvanR> heh. MOO is very imperative and state based
11:33:46 <sproingie> we bashed together some syntax sugar for a datatype called "frobs"
11:33:47 <heatsink> Massive Object ORientation?
11:33:54 <sproingie> frobs are immutable
11:34:20 <sproingie> actually MOO's primitive data structures are all immutable
11:34:45 <sproingie> well insofar as it has one data "structure" (lists)
11:35:26 <sproingie> frobs were basically {handler, @data}, and foo->bar translated into foo[1]:bar(foo)
11:35:30 <sproingie> (MOO being 1-based)
11:36:10 <EvanR> that always threw me for a loop
11:36:19 <EvanR> but in many cases it made things easier
11:36:23 <EvanR> which also threw me for a loop
11:36:27 <dons> it's like ruby with smalltalk :/
11:38:23 <sjanssen> I guess it's no surprise that an Eclipse person will learn about Clojure rather than Haskell
11:38:33 <dons> this is what the FP revolution looks like.
11:38:40 <sproingie> clojure's neat, tho i could do with a little less of a philosophy lesson in phemonology whenever the subject of state comes up
11:38:51 <sproingie> erphenomenology
11:38:53 <dons> yep
11:39:20 <sjanssen> dons: I think ultimately articles like this is good
11:39:25 <dons> the smartest minds in computer science have been thinking about state for 25 years, and clojure doesn't seem to know about that.
11:39:26 <sjanssen> heh, s/is/are/
11:39:28 <dons> sjanssen: agreed.
11:39:32 <dons> sjanssen: this is us winning.
11:39:58 <dons> like F#, or Scala, in diluted form it still makes what we're doing more accessible
11:40:04 <sproingie> i don't think clojure ignores it
11:40:16 <sproingie> rich just waxes a little too philosophical about it
11:40:26 <sproingie> he's otherwise a nice guy
11:40:44 <dons> i'm not sure he knows a lot of the history though. need to convince him to come to an ICFP
11:41:02 <dons> still waiting for clojure on the shootout :)
11:41:19 <Axman6> heh
11:41:29 <heatsink> dons: It make me think of Peter Watts's monologue here http://www.rifters.com/crawl/?p=886, the "Yes, there are mafias." part
11:41:33 <Axman6> shit, i was supposed to be trying to speed up some of those entries
11:41:40 <heatsink> regarding winning
11:42:34 <sproingie> clojure aims at java performance for obvious reasons
11:42:54 <sproingie> some things it gets pretty close
11:43:04 <dons> is there no deb package for clojure? why isn't it on the shootout?
11:43:23 <dons> (even go is on the shootout!)
11:43:31 <sproingie> as lisps fo, i think it could be the next scheme
11:43:44 <sproingie> which is pretty qualified as praise goes
11:44:15 <sjanssen> dons: it's in Ubuntu, so it should be in Debian
11:44:16 <dons> so my prediction: when clojure is on the shootout, SBCL will beat it by an order of magnitude.
11:44:20 <Axman6> go's not doing too well...
11:44:34 <sproingie> since sbcl runs circles around java i would imagine so
11:44:50 <Axman6> wtf? how can JS be so fast?
11:45:20 <sproingie> serious JIT
11:45:39 <copumpkin> go's doing pretty well here http://shootout.alioth.debian.org/u64/benchmark.php?test=nbody&lang=all
11:45:46 <sproingie> some of the best JIT work is going into JS these days
11:45:46 <sjanssen> so which set of benchmarks is the preferred one right now?
11:45:49 <Axman6> interestingly there's no JS entry using Safari's js engine
11:45:57 <dons> its kind of obvious there are no public clojure benchmarks. but rich wants to see them.
11:46:05 <copumpkin> wow, what's wrong with haskell here? http://shootout.alioth.debian.org/u64/benchmark.php?test=meteor&lang=all
11:46:30 <dons> different algorithm
11:46:40 <dons> meteor is not "official" yet, in that there is no agreed implementation.
11:46:51 <sproingie> haskell seems to be doing decent all things considered
11:46:59 <sproingie> even in memory use
11:48:06 <sjanssen> Axman6: wow, those v8 numbers are pretty impressive
11:48:26 <sproingie> luaJIT is what always impresses me
11:48:44 <dons> huh, yeah, it has climbed way up
11:48:44 <copumpkin> I look forward to seeing 6.12 in the shootout
11:48:51 <sproingie> development on luaJIT is pretty slow tho
11:48:57 <sproingie> still waiting on x86_64 support
11:48:58 <dons> was second last, last time, on this list, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
11:49:30 <dons> full employment theorem at work :)
11:49:31 <EvanCarroll> are there any plans to reform the prelude and remove the Int based functions in favor of their generics?
11:50:22 <dons> I don't think anyone has proposed that.
11:50:31 <sproingie> i could go for that.  it's compatible and if you need the performance you can use the specialized ones
11:50:46 <copumpkin> wow v8 is top of the regex test :) granted, it's testing your regex engine, and not much else
11:50:47 <sjanssen> EvanCarroll: generally we're very cautious about changing the Prelude
11:51:02 <copumpkin> EvanCarroll: I'd love it, but it's hard to change something so fundamental
11:51:05 <dons> it's useful for a couple of reasons, and Int == Int64 still works for a lot of uses. there's downsides, of course, too.
11:51:21 <copumpkin> EvanCarroll: I'd mostly prefer it to be Word if it's going to be a primitive type
11:51:24 <copumpkin> :P
11:51:32 <EvanCarroll> to be Word?
11:51:33 <copumpkin> but Word isn
11:51:33 <dons> well, we need a Natural type as well
11:51:35 <copumpkin> t  h98
11:51:39 <sproingie> replace it yourself and recompile hackage with it and see what breaks
11:51:58 <dons> relying on take/drop/length for adding Int constraints might not be that common.
11:51:58 <copumpkin> EvanCarroll: it's pointless to keep that sign there for all those list functions
11:52:17 <EvanCarroll> @t Word
11:52:17 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:52:19 <sproingie> haskell could use a real number tower
11:52:23 <EvanCarroll> not sure what you mean
11:52:32 <copumpkin> EvanCarroll: it's a machine word, but unsigned
11:52:33 <copumpkin> Int is signed
11:52:38 <EvanCarroll> ah
11:52:45 <Cale> I dislike both Word and Int as choices
11:52:45 <copumpkin> > [1..5] !! (-1)
11:52:46 <lambdabot>   * Exception: Prelude.(!!): negative index
11:52:48 <mauke> sproingie: numbers don't form a tower
11:52:54 <copumpkin> no point in having special cases for negative indices
11:52:56 <sproingie> ok a number tree
11:52:57 <Cale> Integer would be better than either of those
11:53:05 <copumpkin> Cale: Natural would be better than Integer
11:53:06 <aavogt> > [1..] !! maxBound
11:53:10 <lambdabot>   mueval-core: Time limit exceeded
11:53:19 <copumpkin> as in, a nice Natural built on top of gmp or something
11:53:23 <Cale> copumpkin: Well, it's a better fit, but I'm not sure if it's actually more convenient
11:53:23 <mmorrow> i wouldn't want Integer for e.g. length though
11:53:26 <sproingie> > maxBound :: Int
11:53:27 <mmorrow> way slower
11:53:27 <lambdabot>   9223372036854775807
11:53:34 <EvanCarroll> it would just be nice to revive the standard library
11:53:35 <Cale> They really ought to be polymorphic though.
11:53:36 <sproingie> > maxBound :: Word
11:53:37 <lambdabot>   18446744073709551615
11:53:49 <mmorrow> , let len = foldl' (\a _ -> a+1::Integer) 0 in time (len [0..1000000::Int])
11:53:52 <lunabot>  (0.566914,1000001)
11:53:53 <mmorrow> , let len = foldl' (\a _ -> a+1::Int) 0 in time (len [0..1000000::Int])
11:53:56 <lunabot>  (0.301954,1000001)
11:54:10 <copumpkin> about half the speed
11:54:11 <xerox> , let len = foldl' (\a _ -> a+1::Word) 0 in time (len [0..1000000::Int])
11:54:12 <Cale> Sure, it's a little slower, but you pay for correctness.
11:54:14 <lunabot>  (0.310953,1000001)
11:54:20 <sproingie> seems pretty iffy for prelude stuff to use Word
11:54:28 <copumpkin> it's nicer than Int
11:54:31 <Cale> I really hate it when Ints sneak into my code and destroy correctness.
11:54:33 <copumpkin> but not as nice as Natural
11:54:49 <sproingie> then you could say Nat
11:54:54 <Cale> (as is common if I'm not thinking and use something like length by accident)
11:55:07 <copumpkin> yeah
11:55:13 <mmorrow> (+) for Integer has to do a compare of the tag (assuming S#/J# here), then make sure it wont overflow S# if S# + S#, then finally do the Int (+) if possible, and if not ccall into libgmp
11:55:16 <copumpkin> and fromIntegral . length is not the same as genericLength, which is also weird
11:55:53 <sjanssen> EvanCarroll: I'm not sure that I agree that the standard library needs to be "revived"
11:56:02 <Gracenotes> Haskell can make length behave the same as genericLength if it infers an Int
11:56:14 <mmorrow> vs. a single machine instr for each (+) in length::[a]->Int (since it'll get an unboxed worker loop)
11:56:20 <Cale> Gracenotes: indeed, GHC can, anyway
11:56:30 <Gracenotes> quite
11:56:35 <c_wraith> I hate the fact that both mtl and transformers exist. >_>
11:56:45 <mmorrow> Gracenotes: it can yes
11:56:46 <shapr> Whyso?
11:57:11 <Gracenotes> c_wraith: time travel and kill transformers' father! (not legally recommended)
11:57:12 <copumpkin> http://snapplr.com/jdq9
11:57:14 <mmorrow> Gracenotes: well, that's a function of the compiler rather than the language
11:57:17 <dolio> genericLength isn't even a good algorithm for Int. You'd really need a rewrite rule for it.
11:57:20 <Gracenotes> yeah
11:57:21 <Cale> c_wraith: The world would be better off without monad transformers?
11:57:42 <c_wraith> Libraries on hackage that involved monad transformers seem to depend on one or the other randomly.  And you can't really use libraries that depend on both at the same time.
11:57:44 <mmorrow> dolio: yeah, hax
11:57:47 <dolio> Or have length be a foldl, even if polymorphic, and then have an inefficientUnlessLazyLength.
11:58:09 <sjanssen> I think lazy length is a pipe dream
11:58:36 <copumpkin> but with lazy length I can compare against the length of an infinite list!!
11:58:41 <copumpkin> :P
11:58:52 <sproingie> all you need is an isInfiniteList
11:59:05 <sproingie> should be a natural outgrowth of doesProgramTerminate
11:59:08 <sproingie> let an intern write it
11:59:33 <copumpkin> :)
11:59:45 <luite> can he also write an uncountable infinite list for me?
11:59:48 <sjanssen> copumpkin: that works great until you compare the lengths of two infinite lists
11:59:53 <copumpkin> sjanssen: pff
12:00:06 <sjanssen> length on infinite lists is just silly and useless
12:00:24 <copumpkin> there's a fun way to get an infinite list with an upper bound on it!
12:00:27 <dons> lazy bytestring lengths are Int64's for a reason, btw.
12:00:28 <copumpkin> > [0,0..1]
12:00:29 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:00:39 <copumpkin> dons: that makes sense
12:00:42 <dons> we wanted to stream off disk and a terabyte seemed like a good amount at the time.
12:00:58 <dons> but also not sacrifice having an atomic type
12:01:01 <sproingie> > [0..1/0]
12:01:02 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
12:01:23 <copumpkin> > [0..0/0]
12:01:24 <lambdabot>   []
12:01:27 <copumpkin> boo
12:01:34 <copumpkin> > [0/0..0]
12:01:34 <lambdabot>   []
12:01:41 <aavogt> > succ (0/0)
12:01:42 <lambdabot>   NaN
12:01:47 <sproingie> > [1/0,1/0-1..0]
12:01:48 <lambdabot>   []
12:01:53 <aavogt> > iterate succ (0/0)
12:01:55 <lambdabot>   [NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,Na...
12:02:04 <EvanR> what on earth
12:02:06 <sproingie> hey hey now goodbye
12:02:24 <HaskellLove> just to share this was cool, it says: foldl goes with the pointers and foldr goes against the pointers :)
12:02:39 <dolio> @check \x -> not (x < 0/0 || 0/0 < x)
12:02:40 <lambdabot>   "OK, passed 500 tests."
12:02:44 <copumpkin> HaskellLove: the pointers?
12:02:47 <sjanssen> HaskellLove: what?
12:02:53 <copumpkin> HaskellLove: foldr is the more fundamental operation
12:03:04 <copumpkin> HaskellLove: it's very deep!
12:03:25 <aavogt> so the pointers are not deep in the haskell definition of lists then
12:04:22 <HaskellLove> well yeah because it goes head to tail foldl goes with the pointers, and foldr goes tail to head so it goes against the pointers.
12:04:55 <Axman6> there are no pointers
12:04:55 <heatsink> If you're computing a strict function, then it's natural to think of folds going in the order of list elements or going in the opposite order.  But that's not so useful when folding a non-strict function.
12:05:00 <aavogt> > foldr (`f`) x [a,b,c]
12:05:01 <lambdabot>   <no location info>: parse error on input `)'
12:05:01 <Draconx> HaskellLove, both foldl and foldr "go head to tail".
12:05:08 <aavogt> > foldr f x [a,b,c]
12:05:08 <sjanssen> HaskellLove: let's blow your mind: foldr actually goes head to tail
12:05:09 <lambdabot>   f a (f b (f c x))
12:05:26 <Draconx> @src foldr
12:05:26 <lambdabot> foldr f z []     = z
12:05:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:05:27 <copumpkin> HaskellLove: there's only one way you can traverse a singly linked list
12:05:39 <copumpkin> one direction, that is
12:05:41 <HaskellLove> Axman6 it means low level...
12:06:10 * copumpkin doesn't have the self-discipline to stop looking at IRC so I'm going to close my client :P ciao!
12:06:18 <Axman6> if it's not a Ptr a or a ForeignPtr a, it's not a pointer
12:06:19 <mmorrow> copumpkin: haha
12:06:24 <copumpkin> :)
12:06:32 <mmorrow> copumpkin: i use worspace 9 for that
12:07:40 <clarkb> mmorrow: but that is where soffice droppings go
12:07:56 <HaskellLove> guys it is MIT paper so... so it says foldl is tail recursive(iterative) and foldr is recursive...
12:08:28 <Draconx> it is true that foldr is not tail recursive.
12:09:00 <sproingie> that's actually the essential difference between the two
12:09:06 <sproingie> (other than the direction of course)
12:09:14 <HaskellLove> but yes, one way to traverse the list... the point is ,"conceptually" foldr calculation starts only after it reaches tail and then goes back... something like that...
12:09:30 <Draconx> HaskellLove, that is clearly false, because foldr can work on infinite lists.
12:09:47 <sproingie> yes though conceptually it consumes the infinite list :p
12:10:02 <sjanssen> HaskellLove: is this paper Haskell oriented?  The behavior of foldr in strict languages is very different
12:10:09 <HaskellLove> that is why i said "conceptually"
12:10:12 <Axman6> > foldr (||) False (False:True:repeat False)
12:10:13 <lambdabot>   True
12:10:15 <jmcarthur> HaskellLove: the two folds are about "grouping," not evaluation order
12:10:22 <HaskellLove> actually it is pH a dialect of haskell
12:10:25 <jmcarthur> *the difference between the two, i mean
12:10:30 <Draconx> HaskellLove, the "l" and "r" stand for "left associative" and "right associative", respectively.
12:10:40 <HaskellLove> i know
12:11:05 <sproingie> i always thought of it as "fold from the left" and "fold from the right".  associativity makes a lot more sense
12:11:09 <jmcarthur> HaskellLove: this whole idea of when evaluation "starts" is a dead end in haskell
12:11:16 <sproingie> since foldr isn't really folding from the right
12:11:59 <HaskellLove> jmcarthur got ya, so it is better to think it high level, foldr is right to left and foldl left to right... enough to operate as programmer
12:12:36 <jmcarthur> HaskellLove: left-to-right and right-to-left imply evaluation order, but foldr and foldl do not
12:12:50 <Draconx> HaskellLove, what does "right to left" mean on an infinite list?
12:13:06 <HaskellLove> Draconx that confuses me too so far
12:13:22 <Draconx> HaskellLove, the reason you are confused is because foldr goes left to right.
12:13:23 <sproingie> has to do with lazy evaluation
12:13:44 <jmcarthur> they both "go left to right"
12:13:56 <HaskellLove> in the paper it says foldr is right to left
12:13:56 <jmcarthur> that is not the distinction between the two
12:14:10 <HaskellLove>     The parenthesization in the above definitions show that foldrtraverses a list "right to left", while
12:14:11 <HaskellLove> foldl traverses the list "left to right."
12:14:17 <luite> HaskellLove: it's much more useful to write out a few steps in the evaluation of foldr (or foldl) manually, to see what it does, instead of reasoning about it in a 'high level' less correct way
12:14:20 <sproingie> in some vague conceptual sense they do, but if it was actually implemented that way it wouldn't work on infinite lists
12:14:23 <jmcarthur> HaskellLove: it must be about a strict language
12:14:30 <jmcarthur> HaskellLove: either that, or it's wrong
12:14:37 <sproingie> plus it'd bust the stack on merely large ones (which it can do anyway)
12:15:01 <HaskellLove> jmcarthur I told you it is about pH dialect of haskell, let me check if it is strict
12:15:04 <sproingie> but so can foldl
12:15:45 <sproingie> parallel haskell is certainly not strict
12:16:30 <HaskellLove> Functions which deal with infinite data structures (such as enumFrom) have been eliminated... that says it all
12:16:30 <jmcarthur> i hate it when people try to give intuitive but wrong rules of thumb
12:16:46 <jmcarthur> huh
12:16:52 <HaskellLove> from here : http://csg.csail.mit.edu/projects/languages/ph.shtml
12:16:59 <sproingie> ah this is something different
12:17:07 <jmcarthur> "The pH language is is a parallel, eagerly-evaluated variant of Haskell"
12:17:11 <sproingie> seriously if you're learning haskell you should probably stick to vanilla
12:17:28 <HaskellLove> and yeah it is strict
12:17:30 <jmcarthur> yeah, lazy evaluation really changes the game
12:18:35 <jmcarthur> > foldr (++) "" ["foo", "bar", undefined]
12:18:36 <lambdabot>   "foobar* Exception: Prelude.undefined
12:18:47 <Russian>  jmcarthur   lambdabot 
12:18:49 <Russian> Here there are bad girls? I want Fuck pussy American girl sex
12:18:52 <c_wraith> sweet.  I got lenses to compile against monads-fd instead of mtl.  (yeah, that barely took effort.  change one import, and minor tweaks to the cabal file)
12:18:58 <Russian> Peoples
12:19:04 --- mode: ChanServ set +o xerox
12:19:05 <Russian> Iam Russian Mafia!!
12:19:11 --- kick: Russian was kicked by xerox (xerox)
12:19:19 <Axman6> @vixen Want to touch Russian?
12:19:20 <lambdabot> first you tell me.
12:19:21 <Russian>  xerox  Hi
12:19:37 <Russian>  Axman6  What?
12:19:48 --- mode: xerox set +b *!*@91.185.246.98
12:19:51 --- kick: Russian was kicked by xerox (xerox)
12:20:02 <tensorpudding`> the russian mafia is coming here?
12:20:07 * jmcarthur hides
12:20:12 --- mode: xerox set -o xerox
12:20:15 <Axman6> xerox is an op? never knew that
12:20:24 <c_wraith> Is this the sort of thing that's worth uploading to hackage?
12:22:12 <xerox> c_wraith: I just got bitten by monads-fd vs. mtl, hmpf.
12:22:48 <c_wraith> xerox: is that a vote for "yes, we should have two versions of everything" or "why do we have both of these, again"?
12:23:03 <xerox> the latter :^)
12:23:13 <tensorpudding`> mtl ftl
12:24:13 <luite> functor transformer library!
12:25:21 <tensorpudding`> it's a joke
12:25:24 <c_wraith> really, I think the "right" thing to do is contribute a patch to the lenses library that allows it to work with either.  But I don't actually know how to do that.
12:25:29 <tensorpudding`> mtl for the lose
12:25:57 <luite> tensorpudding`: mine was too :)
12:26:19 <tensorpudding`> oh
12:26:23 <tensorpudding`> i thought that was a question
12:26:48 <Acedio> Is there a way to state which module to look for a function by default? I'm running into constant conflicts between Prelude and Data.ByteString.
12:27:16 <luite> Acedio: import qualified is probably what you need
12:27:27 <luite> Acedio: or specify the functions you want to import
12:27:30 <c_wraith> Acedio:  ByteString is intended to be imported qualified: "import qualified Data.ByteString as B"
12:27:43 <Acedio> Ok, I'll take a look into it luite and c_wraith :)
12:27:46 <Acedio> Thank you both.
12:31:43 <dancor> how would you implement a tree with possibly-shared subtrees
12:31:44 <Acedio> Sweet, that worked perfectly :)
12:33:15 <dancor> i.e. a child of a node could actually be a reference to another subtree somewhere else in the tree
12:33:59 <c_wraith> dancor:  the data structure is the same as any other tree.  You just need more interesting functions to construct it.
12:34:51 <kmc> dancor, do you need the sharing to be observable by your code?
12:35:13 <c_wraith> Oh.  that's a good question.
12:35:16 <kmc> > let x = "foo" in [x,x] -- the two list elements are "shared subtrees"
12:35:17 <lambdabot>   ["foo","foo"]
12:35:31 <dancor> kmc: actually ya, i want the concept of a main line and the other ways of getting to that place as transpositions
12:36:27 <kmc> if you do need observable sharing, a typical approach would be:  type Ref = Int;  data Node a = Node { contents :: a, left :: Ref, right :: Ref };  data Tree = Tree (IntMap Node)
12:38:15 <jmcarthur> yeah, that's what i would do
12:38:40 <kmc> you can also use actual refs, like an IORef or STRef, if that's more convenient
12:38:55 <kmc> that will make your tree truly mutable in-place, which is a big can of worms
12:39:20 <jmcarthur> IntMap ftw
12:39:48 <kmc> the IntMap approach is referentially transparent and allows you to maintain multiple copies of your tree with (invisible) sharing between them
12:40:39 <kmc> finally, there is that paper on typesafe observable sharing
12:40:58 <jmcarthur> this is something i hadn't heard of...
12:40:59 <kmc> which is probably heavier machinery than you want here, and rests on slightly shaky ground
12:41:04 <jmcarthur> what's the paper?
12:41:15 <kmc> jmcarthur, http://www.ittc.ku.edu/~andygill/paper.php?label=DSLExtract09
12:41:24 <jmcarthur> thanks
12:41:25 <Acedio> So this may be an un-Haskell-like question, but if you're working with a huge lists of values that you modify once. copy to a new list, and never use again is there a way of only using ONE length of memory?
12:41:45 <kmc> it is an un-Haskell question
12:42:00 <kmc> we would only worry about that if there are profiling results to indicate it's a time or space bottleneck
12:42:03 <kmc> but see DiffArray
12:42:20 <kmc> also the actual monadic mutable arrays
12:42:33 <kmc> it's not a list, though
12:42:42 <Acedio> Gotcha, but no Haskell-like way of dealing with it.
12:43:02 <kmc> well, i don't see DiffArray and IOUArray as second-class citizens of the language
12:43:21 <kmc> they're a perfectly haskell-like solution to the problem of "fast mutable array"
12:43:26 <clarkb> STArray is fun too
12:43:34 <c_wraith> I finally learned how to use ST yesterday.  It's definitely a tool worth having.
12:43:48 <Axman6> yes indeed
12:43:48 <kmc> it's just that we prefer to avoid solving the problem "fast mutable array" when "sequence" is sufficient
12:43:49 <Acedio> Seems interesting, might have to check it out.
12:43:52 <c_wraith> (I did the same thing most people do with it their first time around, implementing shuffle in O(n) time)
12:43:55 <Axman6> where'd you learn about it btw?
12:44:11 <kmc> whereas in C it's easier to have your fixed size super fast super dangerous array than a basic linked list, which is backwards from a high-level point of view
12:44:44 <c_wraith> Axman6: I started with the docs, did what I thought should work, then asked in here when it didn't.  *shrug*
12:45:08 <Acedio> Haha, I do kind of miss the super fast dangerousness of C, but Haskell is proving to be pretty sweet in it's own way :)
12:45:19 <Axman6> i've written a fair bit about it on the wiki and wikipedia too
12:45:37 <clarkb> I sat down a couple weeks back to write some C and decided I needed a list. Within about 10 minutes the program had been converted to Haskell :)
12:45:59 <c_wraith> Axman6: There's one part I still don't fully understand...  Why you're so limited in ways you can call runST.
12:46:10 <Acedio> Totally. There are some programs much more suited to Haskell in that way.
12:46:14 <Axman6> yeah, that i couldn't tell you :)
12:46:14 <jmcarthur> clarkb: sounds like my typical C experience
12:46:17 <kmc> Acedio, we have the super fast dangerous stuff if you need it
12:46:53 <Axman6> Acedio: haskell can be superfast AND safe :O
12:46:55 <jmcarthur> c_wraith: runST is designed the way it is so that two "pure" computations cannot depend on or change each others' internal states
12:47:30 <Acedio> I get the (possibly unfounded) feeling that most of it involves monads, which I still don't grasp.
12:47:45 <c_wraith> jmcarthur: I understand the purpose.  I don't understand how the universal quantifier works there at all.  Really, I probably need to be pointed at some good references.
12:47:51 <Acedio> I'm slowly picking it up, though.
12:47:54 <clarkb> Acedio: it was a great way for me to learn
12:47:58 <Axman6> monads are easier to use than exaplain/understand in my experience
12:48:08 <Axman6> that said, i still don't get how to use the State monad
12:48:13 <dons> ?seen lispy
12:48:13 <lambdabot> Unknown command, try @list
12:48:19 <Axman6> i understand how it works, just not how to use it
12:48:27 <clarkb> I used STUArray for many quick modifications on large arrays
12:48:31 <HaskellLove> do you guys think about always if you are creating intermediate lists or you don't care about it?
12:48:51 <Axman6> HaskellLove: they should be fused out if possible
12:48:57 <Acedio> I have a feeling that I'm approaching the problem I'm trying to solve in a non-Haskell like way, so it ends up being inefficient.
12:49:38 <HaskellLove> Axman6 i guess it will come for me after some experience... still not intuitive i cant see what creates and what not, an intermediate list
12:50:07 <jmcarthur> HaskellLove: it's something you shouldn't worry about unless it somehow becomes a problem (i have never had such a problem)
12:50:42 <jmcarthur> any performance problems i have ever had have been due to myself creating stupid algorithms
12:50:53 <Acedio> I'm writing a sound synthesis module, and currently I'm just working with huge lists that make up the "track" that is modified a bunch of times, which really eats up memory since each modification means a new huge list.
12:51:24 <HaskellLove> jmcarthur, ok then, i will know where to look for, if i ever bump into optimizations problem of that sort, euler maybe ? :) but u r right, most of the time it is me writing stupid algorithms to worrry about
12:51:35 <jmcarthur> Acedio: it should really only eat up memory if you are still keeping the old lists
12:51:59 <jmcarthur> Acedio: and if you are doing that then no language can save you ;)
12:52:15 <Acedio> Is there an easy way to tell when a list goes out of scope in Haskell? When is the GC able to destroy it?
12:52:39 <jmcarthur> Acedio: i don't know about that, but you can use heap profiling to see where your memory is going
12:53:00 <jmcarthur> Acedio: you can also check up on GC stats, etc.
12:54:16 <jmcarthur> Acedio: for all the juicy details see http://book.realworldhaskell.org/read/profiling-and-optimization.html and http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
12:54:49 <Acedio> Thanks for the links jmcarthur :) Checking them out now...
12:55:19 <jmcarthur> Acedio: when reading that RWH chapter do keep in mind that the example given is extreme and you should almost never have to do optimizations to that degree unless you are dons
12:57:09 <dons> :P
12:57:09 <Acedio> Haha, I see that. Pretty extreme profiling for a mean function ;)
12:57:19 <mmorrow> dons: heh, point 7's title gave me a chuckle http://caml.inria.fr/pub/ml-archives/caml-list/2009/03/3a77bfcca0f90b763d127d1581d6a2f1.en.html
12:57:21 <dons> yes, it is to illustrate how far you can go if you need to. usually, you don't
12:57:36 <mmorrow> "7- To finish, I'll preventively deflect some likely reactions by Jon Harrop:"
12:57:52 <dons> heh
12:58:17 <o-_-o> morning folks
12:58:34 <Acedio> dons = author of RWH?
12:58:35 <ddarius> dons: I agree with you about that blog article.
12:58:37 <o-_-o> anybody here learning haskell ?
12:58:57 <dons> ddarius: in which respect? lack of awareness of the origins of the technology?
12:59:20 <Axman6> o-_-o: plenty
12:59:24 <clarkb> Acedio: that is what I parsed
12:59:29 <dons> Acedio: yep
12:59:29 <Veinor> o-_-o: I would say everybody is.
12:59:31 <ddarius> dons: Your emotional response and, yes, the lack of awareness of history and not even history but current evens.
12:59:37 <ddarius> s/evens/events
12:59:44 <dons> ok.
12:59:45 <dibblego> CABAL needs a #haskell-nick field
12:59:53 <o-_-o> http://stackoverflow.com/questions/1012573/how-to-learn-haskell/1016986#1016986
12:59:53 <Acedio> Cool, thank you for your work :)
12:59:59 <jmcarthur> o-_-o: we all are
13:00:00 <o-_-o> if you have not seen this already.
13:00:11 <ddarius> I'm not sure if I would describe what I do as "learning Haskell"
13:00:23 <jmcarthur> we are all learning computer science
13:00:32 <HaskellLove> I am gonna skip the optimization chapter, I guess i should program one month in haskell and then will feel need for that chapter, now it is meaningless...
13:00:39 <o-_-o> :-)
13:00:53 <clarkb> I was lucky enough to start FP with mosml :(
13:00:54 <dons> ddarius: well, i commented here, http://www.reddit.com/r/programming/comments/aebkp/what_git_couchdb_and_clojure_have_in_common/ and on the blog.
13:01:09 <clarkb> Learning Haskell was so much eaiser
13:01:15 <ddarius> HaskellLove: I would recommend starting at the beginning, continuing through the middle and stopping at the end.
13:01:38 <HaskellLove> ddarius yeah man it is early now to read on optimization
13:01:49 <ddarius> dons: The blog comment is probably pending moderation.
13:02:09 <dons> looks like it.
13:02:18 <ddarius> dons: But, yeah, these ideas almost certainly go back to, at least, the '60s
13:02:31 <dons> but i saw others pointed out a) okasaki, and b) git is a bad example since it allows rebase
13:02:45 <dons> the db crowd have been on this for a loooong time
13:03:08 <dons> so is this folklore -- should we write a paper summarising the convergence ?
20:57:21 <ddarius> dons: I would actually say most of it is too trivial to even bother with a paper, but I would apparently be wrong.
20:57:59 <dons> happs/macid stuff is in this space too, i guess.
20:58:08 <dons> yeah, its sort of trivial, but an interesting convergence
20:58:38 <o-_-o> are there articles which point to multi-core, distributed programming in haskell ?
20:58:55 <ddarius> Not too much distributed programming in Haskell.
20:59:00 <Axman6> o-_-o: less distributed stuff, but i'm sure there is some
20:59:04 <dons> though the distributed haskell hackathon was this weekend.
20:59:16 <dons> RWH covers multicore (STM, forkIO, par)
20:59:24 <o-_-o> Axman6, is it good for distributed programming or I should go to Erland ?
20:59:26 <Axman6> we need some good distributed haskell packages
20:59:48 <o-_-o> rather I came from Erlang thinking Haskell is good :-/
21:00:05 <jmcarthur> o-_-o: there is nothing about haskell that makes things difficult for it besides that not many people do it and there aren't many (any?) libraries to help you
21:00:06 <Axman6> o-_-o: if you want physically distributed, then erlang is possibly better. though there is an erlang package, which allows you to write haskell code, and act as an erlang noce
21:00:12 <Axman6> d*
21:00:15 <dons> erlang has much better support for distributed programming concepts. (i.e. true cross-node concurrency)
21:00:27 <o-_-o> ok
21:00:27 <dons> haskell will clean up erlang on a multicore box though
21:00:50 <Axman6> yeah, haskell is much much nicer for parallel and concurrent code on a single box
21:01:02 <o-_-o> the problem with Erlang I found was bad FFI and also slower serial code
21:01:04 <dons> erlang's multicore runtime is relatively naive compared to ghc
21:01:11 <ddarius> o-_-o: If you need actual, physical distribution, Erlang is your better bet currently.
21:01:13 <jmcarthur> haskell doesn't even have uniform semantics across architectures
21:01:14 <dons> in terms of the scheduler, no support for sparks,
21:01:15 <o-_-o> OcaML is bad for multi-core.
21:01:27 <o-_-o> so the remaining contender is Haskell imho
21:01:41 <dons> jmcarthur: "uniform semantics" across architectures?
21:01:49 <Axman6> haskell is possibly one of the nicest multi-core languages around
21:01:56 <o-_-o> dons, sparks ?
21:01:56 <Axman6> s/one of//
21:01:57 <jmcarthur> dons: the loose specification of the number of bits in Int, for example
21:02:04 <clarkb> I wonder how hard it would be to wrap the Gearman C api
21:02:08 <dons> well, that's still uniform -- Int is a word on your machine.
21:02:14 <dons> its just not homogeneous
21:02:25 <o-_-o> Axman6, yeah, that is what I had read too...
21:02:38 <jmcarthur> dons: but in a sense it would not be referentially transparent in a multiarchitecture, distributed system
21:02:39 <ddarius> Int can be anything greater than or equal to 30 bits on any machine.
21:02:46 <Gracenotes> most of the overhead involved in concurrency is already built into the language design.. and it's relatively minimal for what it is
21:03:00 <ddarius> clarkb: Probably not hard at all.
21:03:03 <Axman6> o-_-o: things like: parMap rnf expensiveFunction [1..10000] will automatically run each computation in parallel
21:03:04 <dons> jmcarthur: the size of a type isn't a side effect though
21:03:14 <dons> its always observable.
21:03:17 <mmorrow> dons: http://caml.inria.fr/pub/ml-archives/caml-list/2002/11/64c14acb90cb14bedb2cacb73338fb15.en.html
21:03:48 <clarkb> that might be a fun little winter break project...
21:03:53 <ddarius> jmcarthur: That would only really be a problem for transparent distribution which is not how I, personally, would go about distributed computing.
21:04:05 <ddarius> clarkb: Have you used the Haskell FFI before?
21:04:06 <mmorrow> "In summary: there is no SMP support in OCaml, and it is very very unlikely that there will ever be.  If you're into parallelism, better investigate message-passing interfaces." -- Xavier Leroy
21:04:06 <jmcarthur> dons: if i evaluated an expression to an Int on one machine i can't necessarily replace the same expression on another machine with that value. that's all i mean
21:04:10 <clarkb> ddarius: nope
21:04:12 <o-_-o> Axman6, ok
21:04:24 <ddarius> clarkb: Then it will probably be a fun learning experience.  Haskell's FFI is pretty nice.
21:04:45 <mmorrow> "Shared-memory multiprocessors have never really "taken off", at least in the general public."
21:04:52 * mmorrow wonders when this message is from
21:04:52 <sjanssen> jmcarthur: the size of Int is implementation specific, if there's ever a Haskell that supports distribution across multiple architectures it will have to chose a size for Int
21:05:03 <ddarius> clarkb: And by "pretty nice," most people say its better than any FFI they've ever used.
21:05:19 <dons> mmorrow: a couple of years ago
21:05:23 <jmcarthur> sjanssen: right, but i'm talking about the Haskell we have today
21:05:34 <dons> i wonder what GDH uses.
21:05:43 <clarkb> ddarius: I wonder if eday would support it
21:05:50 <dons> hackpar notes: http://hackage.haskell.org/trac/ghc/wiki/HackPar
21:05:59 <clarkb> I should stop adding more work to my list of things to get done :)
21:06:00 <dons> from the paralle/distributed haskell hackathon yesterday
21:06:06 <ddarius> jmcarthur: If distribution is transparent, then it would conceptually be a single Haskell implementation.  If distribution is not transparent, then that behaviour is perhaps bad, but not a violation of referential transparency.
21:06:06 <sjanssen> jmcarthur: do you mean "the Haskell language" or "the Haskell implementations" that we have today?
21:06:13 <o-_-o> If OcaML has bad to worse SP support and Erlang is unoptimized for fast serial codes, doesn't that leave Haskell as the winner ?
21:06:33 <ddarius> o-_-o: It depends on what you need.
21:06:37 <o-_-o> s/SP/SMP
21:06:38 <jmcarthur> ddarius: even a message passing architecture would have to either disallow or strictly specify the size of Int
21:06:44 <sjanssen> jmcarthur: we don't have a distributed Haskell implementation, so I can only assume you mean the language itself
21:06:50 <jmcarthur> sjanssen: i mean the spec
21:06:53 <ddarius> o-_-o: If good, out-of-the-box distribution is needed, Erlang beats Haskell.
21:07:13 <o-_-o> ddarius, is haskell's message passing semantics as good as Erlangs ?
21:07:26 <ddarius> jmcarthur: Only for things that "Distributable"
21:07:34 <ddarius> o-_-o: Haskell doesn't have message passing semantics.
21:07:36 <jmcarthur> ddarius: right
21:07:47 <Jones> Setting up a haskell enviroment... NixOS or Arch.  Opinions?
21:08:01 <o-_-o> ddarius, ok.
21:08:02 <tensorpudding`> Jones: test them both in a VM
21:08:05 <ddarius> jmcarthur: This doesn't keep Int from being machine specific and not distributable.
21:08:05 <jmcarthur> Jones: arch is much more mature i think
21:08:36 <Jones> Yeah, i'm going to VM it, but I'm not sure which has more compatability
21:08:54 <tensorpudding`> Arch is a great haskell platform from what I can tell
21:08:55 <ddarius> Jones: Probably Arch, but most Linuxes do well.
21:09:03 <dons> o-_-o: haskell implements message passing as a library (actor)
21:09:08 <Jones> jmcarthur: i think so.... NixOS is pre 1.0, but I like their functional package management
21:09:10 <tensorpudding`> NixOS doesn't seem to be very stable or complete yet
21:09:29 <dons> people have been using it for several years, i think it is stable
21:09:31 <dons> just small.
21:09:31 <o-_-o> dons, and haskell can act as an erlang node
21:09:43 <dons> o-_-o: that's right, but i don't know if it is well tested
21:09:51 <o-_-o> dons, so what is missing in Haskell that is there in Erlang :-) ?
21:09:57 <ddarius> OTP
21:10:01 <jmcarthur> Jones: i use Arch, for what it's worth
21:10:07 <o-_-o> ah..damn
21:10:08 <o-_-o> ok
21:10:23 <ddarius> Also some things like being able to send functions over the wire and such.
21:10:56 <dons> o-_-o: what's your use case?
21:11:32 <Jones> ok, i'll try a clean Arch w/ haskell... I'll report any difficulties
21:11:34 <Poulter> I have a function which is passed an Integer then should return a double
21:11:36 <Poulter> http://pastebin.com/d1ee4e3ad
21:11:58 <Poulter> I can't find anyway of promoting the int
21:12:00 <xerox> ?type (/)
21:12:01 <clarkb> you will need to use fromIntegral (I think)
21:12:01 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:12:10 <o-_-o> dons, well I am not sure yet, but I am in high performance computing, I am planning on writing a paper/report on  how FP is good for SMP/multi-core stuff
21:12:10 <jmcarthur> somebody said earlier that transparent distribution is probably a bad idea. i would agree with that, but surely there could be some helpful abstractions similar (or identical) to the parallelism abstractions we have already
21:12:18 <ddarius> Jones: I'd be surprised if you had any Arch-specific difficulties.
21:12:34 <ddarius> jmcarthur: Indeed.  That's exactly what Haskell is currently missing.
21:12:58 <ddarius> jmcarthur: Most of it can be done as a library, but those libraries currently don't exist at all.
21:13:03 <o-_-o> dons, how waiting for the magic compiler which will make existing C/Java code automagically parallelized is not a good idea.
21:13:05 <jmcarthur> indeed
21:13:33 <ddarius> o-_-o: For single machine stuff, Haskell is definitely better than Erlang.
21:13:53 <ddarius> (or probably for many things where you don't need to deal with partial failure sensibly)
21:14:20 <dons> might take a while for the C auto-parallelizer. wouldn't bet my business on waiting for that
21:14:29 <ddarius> @google cilk
21:14:30 <lambdabot> http://supertech.csail.mit.edu/cilk/
21:14:47 <dons> cilk is about the closest, and its a new language.
21:15:23 <dons> didnt they get bought recently, by intel?
21:15:26 <o-_-o> dons, I am extremely uncomfortable adding anything to C
21:15:36 <clarkb> it is fairly simple to use openmp in particular instances to automagically parrallelize existing code
21:15:51 <o-_-o> dons, C++ still gives the nightmares
21:15:56 <dons> "fairly simple" might be an understatement
21:16:08 <dons> well, in particular instances, is the key qualifier :)
21:16:10 <o-_-o> clarkb, define "fairly simple"
21:16:17 <clarkb> a single #pragma
21:16:32 <dons> yeah, for some particular pattens, that's easy
21:16:36 <Poulter> clarkb: thanks.
21:16:39 <dons> some of the shootout programs are like that.
21:16:55 <clarkb> Poulter: ?
21:17:02 <o-_-o> clarkb, more than that I think it is retraining the workforce, I am wondering if it is easier to make them think the FP way and let the choose the tools or just tech them openmp
21:17:18 <clarkb> ah, interesting problem to investigate
21:17:29 <sjanssen> o-_-o: Erlang is basically a one-trick pony: the one novel thing they have is ubiquitous message passing.  Haskell, on the other hand, has several interesting approaches to multi-core and parallelism: STM, DPH, parallel sparks
21:17:35 <o-_-o> clarkb, the problem is that if someone who has written serial code all his like is given openmp he will probably still suck
21:17:44 <clarkb> Intel has some VS plugin that is supposed to make writing multithreaded C/C++ nice and easy
21:17:46 <ddarius> It's usually better to make bad things impossible than to rely on discipline.
21:17:51 <o-_-o> sjanssen, ok
21:18:07 <sjanssen> o-_-o: so if you're looking to research one language for your paper, Haskell will let you cover more ground
21:18:20 <o-_-o> sjanssen, ok
21:18:23 <ddarius> sjanssen: I would say their handling of failure is their real selling point.  It's what they say is the key thing about Erlang.
21:18:44 <ddarius> But for high performance computing, handling of failure is irrelevant.
21:19:00 <sjanssen> ddarius: yeah, that's true.  Message passing is the vehicle to achieve that goal
21:19:06 <jmcarthur> i agree with ddarius. erlang's support for easy error recovery is the best thing about it
21:19:07 <o-_-o> ddarius, not entirely :-)
21:19:23 <ddarius> o-_-o: True, but I imagine it can be a fairly simple approach.
21:19:33 <o-_-o> ddarius, we still have problems where something which runs for 13 days ends up dumping core and one has to start again
21:19:36 <ddarius> o-_-o: Presumably you don't worry about 9 9s of up-time.
21:19:44 <o-_-o> ddarius, no
21:19:59 <o-_-o> ddarius, true 5 9s is not the focus
21:21:15 <o-_-o> some sort of a way in haskell to dump state once in a while and start from there would be nice :-)
21:21:25 <o-_-o> sorry if I am asking the moon on a stick
21:21:33 <Axman6> shouldn't be too hard
21:21:45 <ddarius> o-_-o: If you write your code right (i.e. the FP/Haskell way) it should be really easy to do that yourself.
21:21:50 <ddarius> (i.e. all the state should be explicit)
21:21:57 <Axman6> just implement a Data.Binary instance for your state, and occasionally write it out to disk
21:22:25 <o-_-o> ok
21:22:26 <Zao> Might be hard to represent the state of a large computation though.
21:22:33 <Zao> Say that you're evaluating some massive thunk.
21:22:56 <sjanssen> or doing something that requires 13 days of computation
21:23:13 <o-_-o> Zao, even if it means losing a few hours of computation is ok
21:23:23 <ddarius> sjanssen: I imagine those 13 days are mostly in a loop and not a single expression...
21:26:14 <dons> o-_-o: the HAppsState module is designed for that.
21:26:48 <dons> http://hackage.haskell.org/package/happstack-state
21:32:08 <o-_-o> argh..sorry
21:32:29 <o-_-o> if I alt-tab quickly or get a call on my cell my keyboard conks out and I gotta reboot
21:32:45 <Axman6> ... o.O
21:32:56 <o-_-o> yeah I know
21:32:58 <o-_-o> fedora 12
21:33:35 <Axman6> wonderful
21:34:10 <o-_-o> I am not even bothering to file a bug report, they don't even look at it
21:35:48 <pastah_rhymez> o-_-o: can't you just unplug it and put it back in?
21:37:05 <dibblego> is there a function c :: Int -> Int -> [a] -> [[a]] to select combinations from the given list?
21:37:24 <pastah_rhymez> why two ints?
21:37:35 <pastah_rhymez> what do they do?
21:37:44 <pastah_rhymez> @djin Int -> Int -> [a] -> [[a]]
21:37:45 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
21:37:56 <dibblego> oops, one int
21:38:00 <o-_-o> pastah_rhymez, no it doesn't work, I've tried several times
21:38:10 <pastah_rhymez> dibblego: splitEvery :0
21:38:12 <pastah_rhymez> :)
21:38:19 <dibblego> pastah_rhymez, that won't do what I need
21:38:19 <pastah_rhymez> i have it somewhere here... gimme a sec
21:38:28 <o-_-o> pastah_rhymez, the funny thing is that caps lock, and num lock work and I can see lights
21:38:57 <pastah_rhymez> o-_-o: switch os? ubuntu is pretty nice :)
21:39:10 <Axman6> no it's not
21:39:18 <dibblego> property = length (c n r) == let l = length r in fact l / (fact n * fact (l - n))
21:39:22 <Axman6> but... i'll leave my linux hate out of this
21:39:36 <dibblego> i.e. combinations as in permutations but without order
21:40:06 <o-_-o> pastah_rhymez, inertia, using redhat/slackware for 10-11 years, difficult to give up so easily, I am used to all the quirks :-(
21:40:10 <clarkb> I have issues with the way Ubuntu handles haskell packages
21:40:36 <clarkb> I have basically built my entire dev environment from scratc
21:40:58 <pastah_rhymez> splitEvery n xs = ys : splitEvery n yss
21:41:00 <pastah_rhymez>     where (ys, yss) = splitAt n xs
21:41:02 <pastah_rhymez> dibblego: ^^
21:41:23 <Axman6> with a case for []?
21:41:26 <pastah_rhymez> dibblego: otherwise you always have this
21:41:36 <phr> nixos looks cool
21:41:37 <dibblego> pastah_rhymez, that won't work
21:41:40 <sjanssen> clarkb: what's your issue with the packages?
21:41:55 <pastah_rhymez> let perms = filterM_ (const [True,False])
21:42:00 <pastah_rhymez> @let perms = filterM_ (const [True,False])
21:42:01 <lambdabot>  <local>:2:8: Not in scope: `filterM_'
21:42:07 <dibblego> pastah_rhymez, that won't work either
21:42:09 <pastah_rhymez> @let perms = filterM (const [True,False])
21:42:10 <lambdabot>  Defined.
21:42:21 <Axman6> > perms [1,2,3]
21:42:21 <pastah_rhymez> > perms "why not"
21:42:22 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
21:42:23 <lambdabot>   ["why not","why no","why nt","why n","why ot","why o","why t","why ","whyno...
21:42:35 <clarkb> sjanssen: out of date and separated in ways that confuse me
21:42:46 <dibblego> because I want combinations, not permutations
21:42:47 <phr> is any of the nixos packaging stuff written in haskell?
21:43:00 <kmc> > filterM (const [False ..]) [1,2,3]
21:43:01 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
21:43:11 <pastah_rhymez> but what does you Int do?
21:43:11 <dancor> dibblego: nat2comb here seems to be what you want?  http://github.com/nblythe/MUB-Search/blob/master/Combinadics.hs
21:43:22 <Cale> pastah_rhymez: That's not permutations, that's combinations.
21:43:45 <pastah_rhymez> Cale: whoops :)
21:44:01 <dibblego> c 2 "CAT" -> ["CA, "CT", "AT"]
21:44:23 <dancor> oh
21:45:35 <dancor> anyway this file seems to have everything you could ever want re combinations and permutations
21:46:30 <Axman6> > let c n = filter (\xs -> length xs = n) . perms in c 2 "CAT"
21:46:31 <lambdabot>   <no location info>: parse error on input `='
21:46:39 <Axman6> > let c n = filter (\xs -> length xs == n) . perms in c 2 "CAT"
21:46:40 <lambdabot>   Not in scope: `perms'
21:46:51 <Cale> > combinations "CAT"
21:46:53 <lambdabot>   Not in scope: `combinations'
21:46:57 <Cale> huh
21:47:01 <Axman6> > let c n = filter (\xs -> length xs == n) . filterM (const [False,True]) in c 2 "CAT"
21:47:02 <lambdabot>   ["AT","CT","CA"]
21:47:28 <Cale> > subsequences "CAT"
21:47:28 <Axman6> > let c n = filter (\xs -> length xs == n) . filterM (const [True,False]) in c 2 "CAT"
21:47:28 <lambdabot>   ["","C","A","CA","T","CT","AT","CAT"]
21:47:29 <dibblego> Axman6, there is that of course
21:47:29 <lambdabot>   ["CA","CT","AT"]
21:48:04 <Cale> > [[x,y] | (x:xs) <- tails "CAT", (y:ys) <- tails xs]
21:48:06 <lambdabot>   ["CA","CT","AT"]
21:50:15 <Cale> > let pick [] = []; pick (x:xs) = (x,xs) : pick xs in runStateT (replicateM 2 (StateT pick)) "CAT"
21:50:16 <lambdabot>   [("CA","T"),("CT",""),("AT","")]
21:50:22 <Cale> > let pick [] = []; pick (x:xs) = (x,xs) : pick xs in evalStateT (replicateM 2 (StateT pick)) "CAT"
21:50:23 <lambdabot>   ["CA","CT","AT"]
21:50:48 <dibblego> Cale, why not filter subsequences?
21:51:18 <Cale> dibblego: Well, computing the lengths of lists is like admitting defeat.
21:51:30 <dibblego> I was hoping you thought that too :)
21:51:54 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (replicateM 2 (StateT select)) "CAT"
21:51:55 <lambdabot>   ["CA","CT","AC","AT","TC","TA"]
21:52:02 <Cale> ^^ k-permutations
21:52:20 <Gracenotes> :!!!
21:52:38 <pastah_rhymez> Cale: putting pro
21:52:38 <Cale> These things actually have very similar structure when you look at them like that :)
21:56:26 <Cale> If it weren't for things like that, I'd probably never get any use out of StateT ;)
21:56:47 <pastah_rhymez> Cale: dude, StateT _ IO is the greatest :)
21:57:16 <Cale> meh, I don't mind using IORefs where IORefs are appropriate.
21:57:30 <hopthrisC> is there a convenience function in prelude to replace one item in a list?
21:57:31 <pastah_rhymez> instead of StateT+
21:57:33 <pastah_rhymez> ?
21:58:03 <pastah_rhymez> hopthrisC: replicate?
21:58:11 <pastah_rhymez> @type replicate
21:58:12 <lambdabot> forall a. Int -> a -> [a]
21:58:24 <Cale> pastah_rhymez: There are probably some cases where StateT over IO works out okay, but I usually find explicit parameter passing to be not so bad, or IORefs if needs be.
21:58:44 <Cale> hopthrisC: If you mean what I think you mean, then no.
21:59:02 <pastah_rhymez> hopthrisC: or do you want Int -> Int -> [a] -> [a] +
21:59:05 <pastah_rhymez> ?
21:59:18 <Cale> pastah_rhymez: I think he wants Int -> a -> [a] -> [a]
21:59:42 <hopthrisC> Cale: i think something like (takeWhile (/=0) list) ++ 1 ++ (drop 1 (dropWhile (/=0) list), i guess
22:00:10 <Cale> @let replace n x xs = ys ++ x : zs where (ys,z:zs) = splitAt n xs
22:00:13 <lambdabot>  Defined.
22:00:19 <hopthrisC> or even (take n list) ++ 1 ++ (drop (n+1) list)
22:01:07 <Cale> > replace 6 'x' "hello world"
22:01:08 <lambdabot>   "hello xorld"
22:01:30 <Cale> > replace 14 'x' "hello world"
22:01:30 <hopthrisC> ah, splitAt is new to me, thanks
22:01:31 <lambdabot>   "* Exception: <local>:1:36-59: Irrefutable pattern failed for pattern (ys, ...
22:01:41 <Cale> ^^ of course this fails when the index is bad
22:02:02 <Cale> So you might want to go with something that uses case to decide if the result of the splitAt matches
22:02:11 <Cale> and do something appropriate
22:02:16 <Cale> @undefine
22:02:45 <Cale> @let replace n x xs = case splitAt n xs of (ys,z:zs) -> ys ++ x : zs; _ -> xs
22:02:46 <lambdabot>  Defined.
22:02:49 <Cale> > replace 14 'x' "hello world"
22:02:51 <lambdabot>   "hello world"
22:03:05 <Cale> Now it just silently does nothing when the index is too large
22:03:19 <hopthrisC> i catch bad indices earlier
22:03:52 <Cale> Replacing elements in lists is expensive though, so if you're doing a lot of this, consider a different data structure.
22:04:21 <hopthrisC> haha, good joke
22:04:26 <Cale> eh?
22:04:38 <hopthrisC> sorry, that was the sarcasm about this uni assignment coming through
22:04:51 <Cale> splitAt n takes O(n) steps to evaluate.
22:05:05 <hopthrisC> we are coding around stupid specifications here
22:05:33 <copumpkin> my self-discipline didn't last long
22:12:45 <ddarius> copumpkin: You should buy some more.
22:13:00 <copumpkin> don't got me much money
22:13:14 <crutex> (1/9)^2 = .0123456789
22:13:17 <crutex> can anyone have explanation
22:13:30 <copumpkin> > 1111111111^2
22:13:30 <lambdabot>   1234567900987654321
22:13:50 <crutex> o-O
22:14:10 <crutex> but why
22:14:18 <copumpkin> (100a + 10b + c)^2
22:14:20 <crutex> i think we covered this in calculus like 10 years ago
22:14:30 <mgsloan1> > 1/9
22:14:31 <lambdabot>   0.1111111111111111
22:14:53 <mgsloan1> this is just the digit-shifted version of 1111111111
22:15:02 <ddarius> crutex: Think convolution.
22:15:12 <Axman6> heh
22:15:32 <mgsloan1> > (25^2, 2.5^2, 0.25^2)
22:15:33 <lambdabot>   (625,6.25,6.25e-2)
22:17:14 <copumpkin> crutex: if you look at it the way I presented it (ignoring for a moment that a=b=c=1) you can see how the bits come together
22:18:32 <crutex> but why do they :C
22:19:38 <Axman6> > 11111111111^2
22:19:39 <lambdabot>   123456790120987654321
22:19:48 <crutex> right
22:19:53 <crutex> i understand that it DOES
22:19:53 <crutex> but why
22:19:54 <Axman6> > 111111111111^2
22:19:55 <lambdabot>   12345679012320987654321
22:20:13 <Axman6> crutex: perhaps you could try #maths. this is a channel for haskell after all
22:20:21 <Axman6> or #math
22:20:38 <crutex> maybe
22:20:44 <Cale> crutex: let's do a smaller one
22:20:49 <Cale> 111^2
22:21:05 <Cale> = 111 * 100 + 111 * 10 + 111 * 1
22:21:13 <Cale> = 11100 + 1110 + 111
22:21:29 <crutex> ahh
22:21:29 <crutex> thanks
22:21:33 <crutex> ;P
22:21:36 <Cale> Do you see what's going on now? :)
22:22:04 <Cale> It's like you're adding a bunch of shifted copies of the number
22:22:54 <Cale> The same thing happens when you square 1/9 = 0.11111...
22:23:12 <crutex> i guess any repeating decimal make some patter
22:23:18 <copumpkin> http://snapplr.com/wwy9
22:23:26 <crutex> > 2222222222^2
22:23:27 <lambdabot>   4938271603950617284
22:23:44 <crutex> 4 3 2 1 0 9
22:23:48 <Axman6> > 222^2
22:23:48 <crutex> 9 8 7 6
22:23:49 <lambdabot>   49284
22:23:57 <copumpkin> crutex: if you think of 1/9 as the sum of an infinite geometric series it might also help
22:24:11 <crutex> > (2/9)^2
22:24:12 <lambdabot>   4.938271604938271e-2
22:24:18 <crutex> > (3/9)^2
22:24:19 <lambdabot>   0.1111111111111111
22:24:32 <crutex> > (2/6)^2
22:24:33 <lambdabot>   0.1111111111111111
22:24:40 <luqui> the only thing i recognize in 222222222^2 is the first 2 digits: "4 9"
22:24:54 <copumpkin> luqui: it's interleaved
22:24:56 <crutex> luqui
22:24:57 <crutex> yeah
22:24:59 <crutex> tahts the word
22:25:37 <crutex> > (4/9)^2
22:25:38 <lambdabot>   0.19753086419753085
22:26:01 <crutex> repeating
22:26:12 <crutex> 197530864 197530864 197530864 197530864
22:26:14 <copumpkin> crutex: http://www.wolframalpha.com/input/?i=%28a+%2F+%281+-+a%29%29%5E2 is what I was talking about
22:26:18 <bfh6558> bllahahaha I HATE C++
22:26:20 <copumpkin> crutex: it makes it pretty clear, I think
22:26:48 <crutex> yeah
22:26:54 <crutex> that's when i remember learning about it
22:27:00 <crutex> in calc
22:27:09 <crutex> > (5/9)^2
22:27:10 <lambdabot>   0.308641975308642
22:27:27 <crutex> repeating again
22:27:47 <copumpkin> > map head . iterate (drop 5) . showCReal $ (5/9)^2
22:27:48 <lambdabot>   Couldn't match expected type `[a]'
22:27:48 <crutex> > (5/9)^2doesn't look like theres a pattern there though maybe
22:27:48 <lambdabot>         against inferred type `Data.Numb...
22:27:49 <lambdabot>   Not in scope: `doesn't'Not in scope: `look'Not in scope: `like'Not in scope...
22:27:55 <copumpkin> > map head . iterate (drop 5) . showCReal 100 $ (5/9)^2
22:27:56 <lambdabot>   "065431098765431098765* Exception: Prelude.head: empty list
22:28:11 <copumpkin> crutex: there's always a pattern
22:28:20 <crutex> 308641975
22:28:23 <crutex> whats the pattern there
22:28:54 <Axman6> it's a number!
22:30:07 <copumpkin> > map head . iterate (drop 4) . drop 2 . showCReal 1000 $ (5/9)^2
22:30:08 <lambdabot>   "34567890134567890134567890134567890134567890134567890134567890134567890134...
22:30:17 <copumpkin> not sure why the 2 is missing
22:30:38 <crutex> :O
22:30:49 <copumpkin> > map head . iterate (drop 4) . drop 3 . showCReal 1000 $ (5/9)^2
22:30:50 <lambdabot>   "01345678901345678901345678901345678901345678901345678901345678901345678901...
22:32:27 <copumpkin> > showCReal 1000 $ (5/9)^2
22:32:28 <lambdabot>   "0.308641975308641975308641975308641975308641975308641975308641975308641975...
22:32:50 <copumpkin> anyone know where the 2s went?
22:33:36 <Jonno_FTW> why, there was a 2 behind your ear the whole time
22:36:33 <Cale> They were all shipped off to contraction maps by the evil Numbler.
22:36:51 <copumpkin> damn!
22:36:57 <copumpkin> not the evil Numbler!
22:37:06 <copumpkin> I thought he was vanquished long ago
22:37:19 <Axman6> no, the evil Mangler brought him back
22:38:01 <copumpkin> onoes
22:39:31 <HaskellLove> can you guys point me to some simple prime factorization algorithm?
22:40:12 <QtPlaty[HireMe]> harlekin: How fast does it need to be?
22:40:31 <crutex> he wouldn't use haskell if he needed it to be fast!
22:40:45 <Axman6> sure he would
22:41:19 <QtPlaty[HireMe]> Is trial devision good enough?
22:41:29 <Jonno_FTW> google it?
22:42:11 <Jonno_FTW> HaskellLove, to find prime factors, you find the normal factors of a number, then find the prime factors of those
22:42:39 <Jonno_FTW> eg
22:42:44 <Jonno_FTW> prime factors of 24
22:42:52 <Jonno_FTW> 2 factors are 3 and 8
22:42:58 <Jonno_FTW> so
22:43:12 <Jonno_FTW> 3^1, 2^3 are prime power factors
22:43:25 <Jonno_FTW> also
22:43:30 <Jonno_FTW> 2*12 = 24
22:43:37 <copumpkin> crutex: haskell is plenty fast
22:43:56 <crutex> it was a weak troll
22:43:59 <copumpkin> oh ok :)
22:44:33 <Jonno_FTW> 2^1 but 12 has no prime power factors
22:44:52 <Jonno_FTW> so your only factors are 2^3 and 3^1, got it?
22:44:52 <copumpkin> ??
22:45:20 <Axman6> > let ptimeFactors n = pf' 2 n where pf' d n | d > n = []; | otherwise = case divMod n d of (n',0) -> d : pf d n'; _ -> pf (d+1) n in primeFactorisation 3
22:45:21 <lambdabot>   <no location info>: parse error on input `|'
22:45:24 <Axman6> :\
22:45:32 <copumpkin> :t divides
22:45:33 <lambdabot> Not in scope: `divides'
22:45:49 <HaskellLove> Jonno_FTW, 3 and 8 yes, but what about 6 and 4
22:45:50 <Axman6> > let primeFactors n = pf' 2 n where pf' d n | d > n = [] | otherwise = case divMod n d of (n',0) -> d : pf d n'; _ -> pf (d+1) n in primeFactorisation 3
22:45:51 <lambdabot>   Not in scope: `pf'Not in scope: `pf'Not in scope: `primeFactorisation'
22:45:54 <Jonno_FTW> well
22:46:00 <Jonno_FTW> does 6 have an prime factors?
22:46:06 <Jonno_FTW> except 1
22:46:12 <copumpkin> @let primes = nubBy isMultipleOf [2..]
22:46:13 <lambdabot>  Defined.
22:46:19 <Axman6> > let primeFactors n = pf 2 n where pf d n | d > n = [] | otherwise = case divMod n d of (n',0) -> d : pf d n'; _ -> pf (d+1) n in primeFactors 3
22:46:20 <lambdabot>   [3]
22:46:30 <Axman6> > let primeFactors n = pf 2 n where pf d n | d > n = [] | otherwise = case divMod n d of (n',0) -> d : pf d n'; _ -> pf (d+1) n in primeFactors 8
22:46:31 <lambdabot>   [2,2,2]
22:46:35 <Jonno_FTW> there exists no n for 2^n, 3^n, 5^n that equal 6
22:46:36 <Axman6> > let primeFactors n = pf 2 n where pf d n | d > n = [] | otherwise = case divMod n d of (n',0) -> d : pf d n'; _ -> pf (d+1) n in primeFactors 1749873
22:46:38 <lambdabot>   [3,583291]
22:46:40 <Jonno_FTW> for an integer n
22:46:51 <Jonno_FTW> got it?
22:47:34 <HaskellLove> this is fuckin confusing shit i feel stupid... ok today i must solve euler 12, it pissed me off, i will do some research on wikipedia
22:48:26 <Jonno_FTW> you must solve it?
22:48:56 <sinelaw> doesn't seem to problematic
22:49:04 <sinelaw> just a bunch of calculations
22:49:17 <Jonno_FTW> wow, i don't have a solution for 12
22:49:26 <sinelaw> how to do it efficiently in haskell, though, i have no idea
22:49:45 <Jonno_FTW> ok, can you produce the list of triangle numbers?
22:49:59 <Jonno_FTW> can you produce a list of factors?
22:50:00 <sinelaw> Jonno_FTW, 22 seems a lot easier than 12
22:50:19 <Jonno_FTW> that's hella easy
22:50:27 <Jonno_FTW> at the time i didn't know about `ord`
22:51:42 <Jonno_FTW> so i was really confused about what to do
22:52:12 <Jonno_FTW> also haskellLove, in case you didn't know, you can produce triangle numbers using: trian n = round $ 1/2 * n * ( n + 1 )
22:52:36 <HaskellLove> yeah i know that one is easy
22:52:40 <HaskellLove> Gauss
22:52:44 <phr> hmm, doing it the brute force way is taking a while to get above even 100
22:52:50 <copumpkin> that's not the nice way to do it though
22:53:06 * Axman6 prefers tri n = (n*(n+1)) `div` 2
22:53:14 * copumpkin prefers scanl1 (+) [1..]
22:53:19 <phr> triangles = 1:(zipWith (+) triangles [2..])
22:53:54 <HaskellLove> phr yeah brute force is crazy
22:54:17 <Jonno_FTW> `div
22:54:24 <HaskellLove> i prefer copumpkin but are we talking triangles or factorization here?
22:54:36 <copumpkin> so far, everyone wrote an expression for triangles
22:55:02 <Jonno_FTW> hehee
22:55:09 <Jonno_FTW> trians = [ trian n | n<- [1..]]
22:55:16 <Jonno_FTW> for a list of triangle numbers
22:56:07 <copumpkin> Jonno_FTW: by leaving the land of discreteness, you'll get errors on the larger triangle numbers
22:56:38 <c_wraith> larger?
22:56:44 <c_wraith> > (sqrt 2) ^ 2
22:56:44 <Jonno_FTW> i nearly have a solution, except i don't know how to set out the function
22:56:45 <ddarius> Floating point numbers are discrete.
22:56:45 <lambdabot>   2.0000000000000004
22:56:52 <Jonno_FTW> oh right
22:57:16 <HaskellLove> i am reading trial division algorithm now, hope i get it now...
22:57:23 <Jonno_FTW> i have this
22:57:25 <Jonno_FTW> answer = zip trians $ map numDivisors trians
22:57:52 <Jonno_FTW> except i don't know how to return the first element where snd == 501
22:58:19 <phr> well, getting that first element is easy, if you don't mind waiting semi-forever
22:58:31 <Jonno_FTW> hmmm
22:58:35 <phr> e.g. use takeWhile
22:58:40 <phr> or rather, dropWhile
22:58:48 <dibblego> @type \k -> if k == minBound then [k] else enumFromThen k (pred k) -- is this in the library?
22:58:48 <lambdabot> forall a. (Bounded a, Eq a, Enum a) => a -> [a]
22:58:55 <Jonno_FTW> head $dropWhile
22:59:00 <Jonno_FTW> but then what?
22:59:08 <Azstal> :t find
22:59:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
22:59:16 <sinelaw> i just had an idea. linear operators are type class morphisms for vectors
22:59:23 <Jonno_FTW> i need to return fst when snd == 501
22:59:39 <copumpkin> type class morphisms?
22:59:49 <sinelaw> natural transformations
22:59:59 <sinelaw> http://conal.net/papers/type-class-morphisms/
23:00:20 <phr> jonno, it may be simplest to use a list comprehension
23:00:21 <copumpkin> just functors across vector spaces
23:00:23 <copumpkin> aren't they?
23:00:38 <Jonno_FTW> oh right
23:01:06 <sinelaw> copumpkin yes
23:01:13 <ddarius> Linear operators are the arrows in the category of vector spaces.
23:01:31 <copumpkin> ah, that makes more sense
23:01:39 <Jonno_FTW> *Main> main
23:01:41 <Jonno_FTW> IT BEGINS
23:01:42 <Jonno_FTW> *** Exception: primePowerFactors: unable to factor 202457503
23:01:50 <copumpkin> lol
23:01:51 <Jonno_FTW> NOOOO
23:02:00 <Jonno_FTW> perhaps that is the answer
23:02:08 <copumpkin> Jonno_FTW: that's way bigger than the actual answer
23:02:10 <ddarius> I guess the Fundamental Theorem of Arithmetic is wrong.
23:02:16 <Jonno_FTW> woah
23:02:18 <Jonno_FTW> ok
23:02:28 <Jonno_FTW> answer = head [a|a<-(zip trians $ map numDivisors trians), snd a == 501]
23:02:43 <copumpkin> find out why it can't factor it
23:02:43 <Jonno_FTW> numDivisors n = product [ toInteger (a+1) | (p,a) <- primePowerFactors n]
23:03:02 <copumpkin> don't do toInteger
23:03:19 <sinelaw> if you define a vector type class , then linear operators are natural transformations - you can "swap" the operator and the type class's functions (+ and scalar multiplication)
23:03:40 <sinelaw> conal calls this a "type class morphism"
23:03:51 <copumpkin> ah
23:03:56 <Jonno_FTW> what did i do wrong?
23:04:18 <copumpkin> Jonno_FTW: nothing, if you took primePowerFactors from somewhere else
23:04:24 <Jonno_FTW> hmm
23:04:41 <copumpkin> anyway, just use the find function
23:04:49 <Jonno_FTW> @src find
23:04:50 <lambdabot> find p          = listToMaybe . filter p
23:05:35 <copumpkin> answer = find ((>500) . numDivisors) trians
23:05:41 <copumpkin> is your expression above
23:05:44 <Jonno_FTW> yep
23:05:52 <Jonno_FTW> i need a numDivisors you say?
23:05:59 <phr> numDivisors = length . divisors
23:06:06 <copumpkin> he doesn't have a divisors function
23:06:09 <phr> oh
23:06:22 <copumpkin> he gets a list of prime factors and their powers
23:06:44 <phr> ok, you need the euler phi function
23:07:02 <Jonno_FTW> totient function
23:07:04 <Jonno_FTW> i have that too
23:07:07 <Jonno_FTW> from another problem
23:07:08 <copumpkin> or just do what he's doing now
23:07:15 <copumpkin> he just needs to fix that primePowerFactors
23:07:34 <copumpkin> either way, that number is bigger than the correct answer
23:07:37 <ddarius> What was that library that randomly had Dirichlet series in it?  MPS or something like that.
23:07:40 <copumpkin> so you shouldn't even get there
23:07:48 <Jonno_FTW> then how did i miss the correct answer?
23:08:29 <copumpkin> ddarius: http://www.polyomino.f2s.com/david/haskell/advancednumbertheory.html ?
23:08:48 <phr> what's the thingie to make getLine unbuffered?
23:08:49 <Jonno_FTW> oh yeah, i use those modules
23:08:57 <phr> or stdout rather
23:09:34 <copumpkin> :t hSetBuffering
23:09:35 <lambdabot> Not in scope: `hSetBuffering'
23:09:39 <copumpkin> @hoogle buffering
23:09:39 <lambdabot> System.IO BlockBuffering :: Maybe Int -> BufferMode
23:09:39 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
23:09:39 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
23:09:51 <copumpkin> hSetBuffering stdout NoBuffering
23:09:58 <phr> ok, gotta import some module
23:09:59 <ddarius> copumpkin: No, it was that insane library that mimicked ruby I think.
23:10:01 <phr> System.IO
23:10:07 <copumpkin> oh, lol
23:10:44 <copumpkin> yeah, mps
23:10:50 <ddarius> But yes, ζ(s-1)/ζ(s) is what I was getting at (as I have in my crazy little black book)
23:11:11 <copumpkin> http://github.com/nfjinjing/mps/blob/master/src/MPS/Math/DirichletSeries.hs
23:11:32 <copumpkin> lots of random math in there
23:12:06 <phr> http://hackage.haskell.org/trac/igghc/ticket/1355  open 2.5 years
23:12:27 <copumpkin> fix it! :P
23:12:46 <Cale> Formally, Dirichlet series are cool. I can't stand dealing with the analytic side of things though.
23:12:58 <copumpkin> phr: read JaffaCake's response at the end
23:13:30 <phr> you mean simonmar's?
23:13:35 <copumpkin> yeah
23:13:36 <Cale> They're the natural sort of generating series to use when you want the weight of a pair in the Cartesian product to be the product of the weights of its parts.
23:13:44 * copumpkin eats JaffaCake 
23:13:51 <dibblego> > let enumFromPred \k -> if k == minBound then [k] else enumFromThen k (pred k) in enumFromPred 'a'
23:13:51 <lambdabot>   <no location info>: parse error on input `\'
23:13:57 <dibblego> > let enumFromPred = \k -> if k == minBound then [k] else enumFromThen k (pred k) in enumFromPred 'a'
23:13:57 <lambdabot>   "a`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"! \US\RS...
23:14:04 <Jonno_FTW> eats copumpkin pie
23:14:12 <copumpkin> dibblego: f n = [n, pred n..] ?
23:14:18 <HaskellLove> http://en.wikipedia.org/wiki/Trial_division - 1. why does it add 0.5 to numToBeFactored?
23:14:23 <dibblego> copumpkin, pred may fail
23:14:45 <copumpkin> hm
23:14:53 <dibblego> copumpkin, my thoughts prexactly
23:14:57 <copumpkin> :)
23:15:02 <copumpkin> spoon! :P
23:15:10 <copumpkin> j/k
23:15:28 <Gracenotes> I will not put up with spooning in #haskell
23:15:30 <ddarius> Cale: I just reduce the analytical parts to semi-justified transformations of Mellin transform expressions.
23:15:52 * copumpkin attacks Gracenotes with his spoon
23:16:18 <ddarius> It's fun determining Dirichlet generating functions from multiplicative arithmetic functions and vice versa though.
23:16:43 <HaskellLove> yo guys, concentrate on my question above :D
23:16:47 <Gracenotes> > toEnum (-1) :: Char
23:16:48 <lambdabot>   * Exception: Prelude.chr: bad argument
23:17:57 <copumpkin> HaskellLove: it's an ugly hack
23:18:21 <copumpkin> HaskellLove: but simply, because the author doesn't know how to use ceiling
23:18:37 <HaskellLove> copumpkin i should choose another algorithm or?
23:19:59 <copumpkin> that'll work, but the java there makes me want to barf
23:20:41 <HaskellLove> yeah its fuckin ugly
23:21:06 <copumpkin> do you understand the code?
23:21:28 <HaskellLove> yes
23:21:39 <HaskellLove> but not sure if i can translate it to func
23:21:48 <Axman6> HaskellLove: any chance you could reduce your swearing? it's getting very annoying
23:22:39 <ddarius> ζ(s) = sM[floor](-s)
23:22:52 <Jonno_FTW> what is that crazy character there?
23:23:01 <copumpkin> zet
23:23:03 <copumpkin> a
23:23:06 <Jonno_FTW> and it does what?
23:23:35 <ddarius> Jonno_FTW: It's the Riemann Zeta function.
23:23:43 <Jonno_FTW> which does what?
23:24:12 <copumpkin> zeta n = sum . map ((1/) . (^n) $ [1..]
23:24:26 <copumpkin> with another parenthesis
23:24:45 <Jonno_FTW> how is it useful?
23:25:03 <copumpkin> http://en.wikipedia.org/wiki/Riemann_zeta_function
23:25:14 <copumpkin> "The Riemann hypothesis, a conjecture about the distribution of the zeros of the Riemann zeta function, is considered by many mathematicians to be the most important unsolved problem in pure mathematics.[1]"
23:25:34 <Jonno_FTW> hmk
23:25:36 <Cale> It's important because it's connected to the distribution of the primes.
23:25:44 <Jonno_FTW> i like pure mathematics more than applied
23:26:20 <Jonno_FTW> i also found the error in my program, i had == instead of >=
23:26:25 <Cale> zeta(s) = product over primes p of 1/(1-x^(-p))
23:26:29 <Jonno_FTW> level 2 on project euler!
23:26:32 <copumpkin> :)
23:26:41 <Jonno_FTW> achievement unlocked!
23:27:06 <Cale> er
23:27:12 <Cale> zeta(s) = product over primes p of 1/(1-p^(-s))
23:27:43 <Cale> It's easy to see that this is equivalent formally to the other formula, once you notice that n^(-s) m^(-s) = (nm)^(-s), and that 1/(1-x) = 1 + x + x^2 + ...
23:28:13 <copumpkin> > (** 0.25) . (*90) . sum . map ((1/) . (^n)) $ [1..100]
23:28:19 <lambdabot>  Terminated
23:28:21 <copumpkin> ahem
23:28:22 <Cale> Essentially the equivalence of those two ways of writing the zeta function is the statement that every natural number decomposes uniquely as a product of primes.
23:28:42 <copumpkin> > (** 0.25) . (*90) . sum . map ((1/) . (^4)) $ [1..100]
23:28:45 <lambdabot>   3.1415924153073678
23:28:46 <Jonno_FTW> also, what is pi notation?
23:28:51 <Jonno_FTW> with the big pi
23:28:55 <copumpkin> product
23:28:58 <copumpkin> of a bunch of numbers
23:29:01 <Jonno_FTW> wow
23:29:10 <copumpkin> it's analogous to sigma
23:29:12 <Jonno_FTW> ok
23:29:17 <Jonno_FTW> any others like that?
23:29:24 <copumpkin> you'll also see big U and big upside-down U
23:29:30 <ddarius> Jonno_FTW: Big Cup and Cap
23:29:30 <copumpkin> and V and upside-down V
23:29:41 <ddarius> Big OPlus and OTimes, etc. etc.
23:29:54 <copumpkin> pretty much an associative operator, I guess
23:29:58 <copumpkin> *any
23:30:14 <ddarius> See the Fortress programming language.
23:30:25 <Jonno_FTW> similar to Fortran?
23:30:36 <ddarius> Not really...
23:30:56 <ddarius> I think they have vaguely similar target domains but are very different languages.
23:30:59 <Cale> Probably the first thing which makes the Riemann zeta hypothesis hard to approach is that these forms of the Riemann zeta function don't converge at any of the points which the Riemann zeta hypothesis concerns.
23:31:09 <ddarius> But then hopefully we've learned something over the last 50 years.
23:31:21 <ddarius> Cale: Yeah...
23:31:34 <Cale> Really the RH is about the analytic continuation of this series.
23:32:37 <ddarius> I like that the zeta function is basically the Mellin transform of the floor function and its not too hard to get to its relation to the π function from there.
23:32:55 <ddarius> And on the way you learn about all kinds of fun number theory functions.
23:34:45 <ddarius> The paper where Riemann introduces the Riemann Hypothesis is a good read.
23:37:18 <ddarius> Like all grand conjectures, it's a bit of a side not in that paper.
23:39:56 <Jonno_FTW> is there a simple project i could do in Haskell that would require more than printing answers, like actually taking input?
23:40:03 <Jonno_FTW> for a first project type thing?
23:40:21 <copumpkin> http://www.reddit.com/r/haskell_proposals
23:40:23 * copumpkin coughs
23:40:59 <Jonno_FTW> a calculator type thing would be good, but where do i start?
23:41:06 <phr> jonno, have you looked at learnyouahaskell.org ?
23:41:10 <Jonno_FTW> yes
23:41:12 <copumpkin> deciding how you want to represent expressions
23:41:26 <Jonno_FTW> should i finish reading it?
23:41:32 <copumpkin> then figure out how to evaluate them, and then maybe write a simple parser
23:42:45 <Jedai> Jonno_FTW: a calculator is nice, copumpkin summed it up pretty well too ;)
23:42:53 <Jonno_FTW> hmm
23:42:57 <Jonno_FTW> where do i start though?
23:43:04 <copumpkin> I just told you
23:43:14 <Jonno_FTW> do i just list a heap of functions and bind them to buttons?
23:43:27 <copumpkin> no GUI!
23:43:30 <copumpkin> GUIs are the devil
23:43:36 <Jonno_FTW> but....
23:43:51 <HaskellLove> let primes n = [x | x<-[2..n], n `mod` x == 0, y<-[2..x], x `mod` y /= 0] and then i do : primes 25, and i get this list: [5,5,5,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25] Why does it produce duplicates?
23:44:37 <copumpkin> because you have two <- there
23:44:37 <Jonno_FTW> x `mod` y == 0
23:44:47 <Jonno_FTW> oh wait
23:44:48 <Jonno_FTW> no
23:45:01 <Jonno_FTW> also, you don't need to check even numbers for x
23:46:06 <copumpkin> > let primes n = [(x, y) | x<-[2..n], n `mod` x == 0, y<-[2..x], x `mod` y /= 0] in primes 25
23:46:07 <lambdabot>   [(5,2),(5,3),(5,4),(25,2),(25,3),(25,4),(25,6),(25,7),(25,8),(25,9),(25,10)...
23:46:15 <copumpkin> might give you more of an idea of what's going on
23:46:33 <copumpkin> not really sure what you're going for
23:47:12 <Jedai> the prime factors maybe ?
23:47:26 <HaskellLove> prime factors yes
23:48:02 <Jedai> I must admit it's pretty much guesswork since I don't really see your idea in this function...
23:48:09 <copumpkin> yeah
23:48:32 <HaskellLove> I get the primes but i get the duplicated all over the place
23:48:50 <Jonno_FTW> nub
23:48:58 <copumpkin> why do you have the second iteration
23:49:01 <Jonno_FTW> but that would be a horrible hack
23:49:02 <copumpkin> that's what's duplicating them
23:49:11 <copumpkin> > let primes n = [(x, y) | x<-[2..n], n `mod` x == 0 in primes 25
23:49:12 <lambdabot>   <no location info>: parse error on input `in'
23:49:16 <copumpkin> > let primes n = [(x, y) | x<-[2..n], n `mod` x == 0] in primes 25
23:49:17 <lambdabot>   [(5,y),(25,y)]
23:49:20 <Jedai> copumpkin: I think he's attempting to filter out the non-primes
23:49:36 <copumpkin> hrm
23:49:38 <Jonno_FTW> the way i would do this is
23:49:45 <HaskellLove> yeah the second one is to filter
23:49:52 <copumpkin> filter what?
23:49:58 <Jedai> HaskellLove: that's not what it do though
23:50:12 <HaskellLove> only number that are divisible with themselves
23:50:37 <Jedai> copumpkin: see, for each x he wants to check if it's a prime (since its x is just a divisor)
23:50:54 <c_wraith> HaskellLove:  perhaps you should rethink your algorithm.  Remember that the smallest (non-1) factor of a number must be prime.
23:52:00 <Jedai> HaskellLove: I second c_wraith, apart from it being currently wrong, even if you got it working your current algorithms would be _extremely_ innefficient
23:52:52 <c_wraith> holy crap.  I just figured out a much faster approach to euler 266 based on something I just said.  I might one day come up with a solution fast enough to terminate in the lifespan of the universe!
23:52:52 <Jonno_FTW> let isPrime n =length [ x | x <-[2..n] , n `mod` x == 0] == 0  in [x|x<-[1,3..],isPrime x]
23:53:13 <Jonno_FTW> what
23:53:18 <Jonno_FTW> go on
23:53:20 <Jedai> c_wraith: nice ! I myself have given up for now :)
23:53:41 <c_wraith> Jonno_FTW: It's still a dumb brute force algorithm.  But I figured out how to reject incorrect solutions really fast.
23:53:48 <Jonno_FTW> how?
23:54:14 <c_wraith> test for divisibility by any square of a prime < k/2
23:54:34 <Jonno_FTW> hmm
23:55:05 <c_wraith> err.  any (square of a prime) < k/2
23:55:11 <c_wraith> That was a bit ambiguous
23:55:12 <c_wraith> :)
23:55:19 <phr> ok, my answer is 12375
23:56:53 <phr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14145   euler 12 spoiler
23:58:26 <copumpkin> 12375?
23:58:31 <copumpkin> oh
23:58:34 <copumpkin> :P
23:58:47 <Jonno_FTW> how fast did yours take to run?
23:59:03 <phr> 0.9 seconds on 2 ghz core 2
23:59:06 <HaskellLove> phr how much time it took you from start man?
23:59:16 <phr> dunno, i was fooling around with it a while
23:59:16 <dancor> what do ppl do if they need to preserve the order of keys but otherwise want a Map (no dupes)
23:59:23 <Tabemasu1000> What are you guys doing?
23:59:28 <Jedai> phr: good, your factors function could be faster though
23:59:37 <phr> jedai yeah i didn't do anything fancy
23:59:39 <Jonno_FTW> is that your answer for 12?
23:59:45 <phr> jonno yes
23:59:48 <Jonno_FTW> but
23:59:53 <Jedai> phr: you could cut sooner and you don't need candidates
23:59:58 <Jonno_FTW> oh it is the 12375th triangle number
