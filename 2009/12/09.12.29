00:00:02 <kmc> aavogt, no
00:00:09 <kmc> i don't think "action" is an appropriate word for all monadic values
00:00:16 <kmc> it is especially appropriate for IO
00:00:21 <Jafet> > do { x <- getChar; print x; }
00:00:22 <lambdabot>   <IO ()>
00:00:30 <aavogt> maybe say "computational context"?
00:00:33 <kmc> roboshibby, beware, IO is a strange example of a monad.  if you want to understand monads-in-general, IO may lead you astray
00:00:44 <kmc> because it has a lot of special properties compared to others
00:00:49 <kmc> Maybe is a monad you can implement in 3 lines of code
00:01:16 <roboshibby> hehe
00:01:50 <ski> aavogt : `Maybe a' is a type of actions, yes
00:03:10 <ski> e.g. `lookup key assocs' is a `Maybe'-action
00:03:28 <aavogt> I agree
00:03:54 <kmc> meh it's just words
00:03:56 <kmc> code trumps words ;)
00:04:00 <ski> (indeed)
00:05:04 <kmc> the benefit of monads is that we represent different sorts of computation with ordinary data types instead of special-case language features
00:05:17 <kmc> so you can really go read the library source code if you're confused about the semantics
00:05:24 <kmc> try to understand C++ exceptions by reading g++ source...
00:05:47 <troutwine> kmc: Dear god, no.
00:08:14 <ski> one benifit of having a pure language that allows modeling effects with monads is that if you don't use a certain monad, then the corresponding kind of effects can't happen
00:08:59 <ski> i.e. that benefit is that you can write operations that for sure doesn't use a certain effect
00:09:19 <kmc> yeah, but i don't think that's the only benefit
00:09:19 <roboshibby> hrm
00:09:28 <kmc> monads make it easier to innovate by inventing new "effects"
00:09:32 <kmc> in addition to containing them
00:09:47 <ski> yes
00:09:58 <HaskellLove> map (read::Int) (concat $ [(tails $ show x)] ++ [(inits $ show x)]) this does not work, and i tried to put ::Int at the end but stil problems...
00:10:14 <aavogt> @type read
00:10:15 <lambdabot> forall a. (Read a) => String -> a
00:10:33 <aavogt> HaskellLove: you probably want   read :: String -> Int, no?
00:10:39 <HaskellLove> yes
00:10:46 <aavogt> or  (\x -> read x :: Int)
00:10:59 <aavogt> also, you have redundant ()
00:11:39 <aavogt> also, why should you expect a single Int as the result type?
00:11:47 <HaskellLove> it confuses me, so far i used read with this type ::Int and now read :: String -> Int ... what is going on, so i dont just learn this as syntax
00:11:48 <aavogt> HaskellLove: do you recall what the type of map is?
00:12:17 <HaskellLove> oh i get it now it wants a function now since i use map... ok got it
00:12:47 <aavogt> HaskellLove: you didn't specify that read :: Int, you specified that the type of some expression that applied read to some String argument :: Int
00:13:29 <aavogt> type annotations specify the type for the whole expression in haskell (respecting parentheses)
00:13:36 <HaskellLove> map (read::Int) this means what you said? ^
00:13:56 <troutwine> Anyone know of a document that gives the memory consumption of objects with GHC, basic and/or arbitrary types?
00:13:58 <aavogt> which part of my explanation gave you trouble?
00:14:06 <troutwine> Or should I just poke around in GHC?
00:14:10 <Saizan_> HaskellLove: "read str :: Int" is correct, "read :: Int" isn't
00:14:20 <Gracenotes> not so much, that means the type system must resolve '(Read a) => String -> a' with 'Int', don't work
00:14:42 <Gracenotes> it can resolve the former with 'String -> Int', if Int is an instance of Read, which it is
00:14:47 <aavogt> troutwine: have you looked into the various space profiling things that come with ghc?
00:14:59 <Saizan_> troutwine: there's a post on the ghc blog
00:15:22 <aavogt> (my suggestion for heap profiling is probably not precise enough)
00:15:45 <troutwine> aavogt: I have, I just wondered if there are any guarantees made.
00:15:58 <troutwine> Saizan_: Didn't know that. Thanks.
00:30:16 <HaskellLove> do you see an optimization here leftsAndRights x = nub $ map (read :: String -> Int) $ filter (/= "") (concat $ [tails $ show x] ++ [inits $ show x]) ?
00:31:22 <HaskellLove> for example for 3797 you get a list of these numbers 3797, 797, 97, and 7, 379, 37, and 3.
00:37:01 <aavogt> HaskellLove: do you know how nub does what it does?
00:37:07 <aavogt> @src nub
00:37:07 <lambdabot> nub = nubBy (==)
00:37:10 <aavogt> @src nubBy
00:37:10 <lambdabot> nubBy eq []             =  []
00:37:10 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:38:23 <aavogt> well it's inefficient since you are doing many more comparisons than necessary
00:38:44 <HaskellLove> interesting, but still i cant see how i can optimize
00:38:57 <felzix> I'm not sure if this is a sensible thing to do, but I want to define a data type as a 2D array of some given size of a particular element
00:39:27 <felzix> I'm not sure how to do this in haskell
00:39:28 <aavogt> HaskellLove: why do you want to compare prefixes and suffixes of different lengths?
00:39:40 <HaskellLove> felzix check listArray
00:39:49 <aavogt> rather, why don't you see how such a thing is pointless
00:39:50 <HaskellLove> aavogt euler 31
00:40:03 <aavogt> so?
00:40:45 <HaskellLove> wait i dont get it, what is not sensible to do, point me to the code
00:41:08 <Saizan_> felzix: there are many kind of arrays http://www.haskell.org/haskellwiki/Arrays
00:41:15 <ski> `concat $ [tails $ show x] ++ [inits '
00:41:21 <ski> er
00:41:24 <aavogt> > (tails "HaskellLove",inits "HaskellLove")
00:41:25 <lambdabot>   (["HaskellLove","askellLove","skellLove","kellLove","ellLove","llLove","lLo...
00:41:34 <Saizan_> felzix: they don't normally show the size in their types, though i think there are packages on hackage that do
00:41:52 <aavogt> > (tails "abc",inits "abc")
00:41:53 <lambdabot>   (["abc","bc","c",""],["","a","ab","abc"])
00:41:54 <felzix> http://pastebin.com/dfe005ac
00:42:12 <Saizan_> felzix: a 2D array is one that uses (Int,Int) as index rather than Int, in haskell
00:42:13 <ski> HaskellLove : `concat $ [tails $ show x] ++ [inits ' $ show x]' is better written as `tails (show x) ++ inits (show x)'
00:42:38 <felzix> Saizan_, I know. That's just an attempt to get a simple type working
00:42:58 <Saizan_> felzix: you need a constructor for the World datatype
00:43:08 <HaskellLove> ski and what about the inits?
00:43:12 <aavogt> > (tails "aaa",inits "aaa") -- how many comparisons do you need to get the 'nub' of this list?
00:43:13 <lambdabot>   (["aaa","aa","a",""],["","a","aa","aaa"])
00:43:23 <aavogt> > uncurry (++) (tails "aaa",inits "aaa") -- how many comparisons do you need to get the 'nub' of this list?
00:43:24 <Saizan_> felzix: and you can't specify the size there, the first argument is the type of the indices
00:43:24 <lambdabot>   ["aaa","aa","a","","","a","aa","aaa"]
00:44:03 <Saizan_> felzix: so it'd look like data World = MakeWorld (Array Int Tile) for 1D
00:44:35 <Saizan_> felzix: or "data World = MakeWorld (Array (Int,Int) Tile)" for 2D
00:44:35 <HaskellLove> aavogt i dont get it man say it dont play Joda with me :D
00:44:36 <felzix> that works!
00:44:39 <felzix> thanks :)
00:44:43 <Saizan_> np
00:44:50 <ski> HaskellLove : what about the `inits' ?
00:45:15 <HaskellLove> ski 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3. euler 37
00:45:29 <ski> i'm not sure what you're wondering about, now
00:45:44 <HaskellLove> well look at euler 37 please
00:46:04 <HaskellLove> it is not just tails
00:46:21 <ski> i'm sorry, i'm too lazy to look at that at the moment
00:46:59 <ski> if you try to describe in your own words what is the current stumbling-block, you might find the solution easier
00:47:07 <dblhelix> good morning, #haskell
00:47:14 <ski> morning, dblhelix
00:47:30 <troutwine> Good evening, dblhelix.
00:47:41 <dblhelix> time zones, time zones :)
00:47:43 <HaskellLove> ski well you wrote only tails and i need to get inits too so you confuse me
00:47:48 <troutwine> Living on a sphere is fun.
00:48:09 <troutwine> Well, spheroid.
00:48:11 <ski> HaskellLove : i suggested `tails (show x) ++ inits (show x)' instead of `concat $ [tails $ show x] ++ [inits $ show x]'
00:48:21 <ski> HaskellLove : i don't see how the former is "only tails"
00:48:43 <dibblego> Ijust spent an hour writing Vincenty inverse/direct; I wish we lived on a sphere
00:48:52 * ski ponders living on a rotating torus
00:50:20 <troutwine> @dibblego: What are you doing that you need such accuracy?
00:50:21 <lambdabot> Unknown command, try @list
00:50:33 <troutwine> If you don't mind my asking, that is.
00:50:35 <dibblego> writing a library
00:51:45 <HaskellLove> ski ah ok, and what about the nub optimization thing?aavogt? i did not get how to optimize nub, now i have:
00:51:47 <HaskellLove> leftsAndRights x = nub $ map (read :: String -> Int) $ filter (/= "") (tails (show x) ++ inits (show x))
00:52:05 <aavogt> I say don't use nub, use concatMap
00:52:43 <HaskellLove> interesting, let me check that i havent used it
00:53:14 * dblhelix is happy that the implementations of most of his libraries do not depend on the exact shape of his home planet
00:53:43 <aavogt> @type let sx = show ?x in concatMap (\(a,b) -> nub $ filter (/= "") [a,b]) $ zip (tails sx) (inits sx)
00:53:44 <lambdabot> forall a. (?x::a, Show a) => [[Char]]
00:54:28 <aavogt> @type let sx = show ?x in concatMap (\(a,b) -> nub $ filter (/= "") [a,b]) $ zip (tails sx) (reverse $ inits sx)
00:54:29 <lambdabot> forall a. (?x::a, Show a) => [[Char]]
00:54:58 <aavogt> you can get rid of the reverse, if you use foldr directly instead of concatMap
00:55:28 <aavogt> but that's only affecting a constant factor, not the asymptotic tendency
00:55:58 <aavogt> HaskellLove: what kind of education do you have?
00:57:35 <HaskellLove> nothing, why
00:58:00 <aavogt> then again, I think inits is probably the same complexity as nub...
00:59:41 <aavogt> so maybe:   zip (tails sx) (tails $ reverse sx)
01:00:03 <aavogt> hmm, needs another map reverse
01:02:12 <HaskellLove> and you dont have read
01:02:36 <aavogt> you have trouble fitting that in too?
01:03:01 <HaskellLove> I will go with this one: nub $ map (read :: String -> Int) $ filter (/= "") (tails (show x) ++ inits (show x))
01:03:27 <ivanm> HaskellLove: are you _still_ going on with that digit rotation thingy?
01:03:50 <HaskellLove> ivanm nope this is euler 37
01:04:10 * ivanm has no idea what the different euler problems are
01:04:17 <HaskellLove> :)
01:04:38 <HaskellLove> aavogt that read is huge problem, very slow
01:04:59 <HaskellLove> will try to replace read if somehow posible
01:05:22 <aavogt> main = print 748317
01:06:02 <aavogt> optimized, kthxbye
01:06:36 <ivanm> heh
01:07:09 <HaskellLove> coolest opt ever
01:07:23 <HaskellLove> they teach this in college to Phds?
01:07:35 <HaskellLove> :D
01:14:07 <HaskellLove> when you redefine euler 37 i think this trick might work. instead of doing the hard work, just test if each digit of the given prime is a prime itself, anyone has thought of this?
01:40:16 <medfly> HaskellLove: did you do eveyrthing between 25 and 37 yesterday?
01:40:37 <HaskellLove> nope there are gaps
01:41:10 <medfly> I should do it some time. a competition I'm bound to lose. me vs. Cale, euler 1 to n
01:41:48 <medfly> Cale: are you up for it
01:42:13 * medfly puts a sword in front of Cale
01:42:16 <medfly> I challenge you to a duel!
01:43:26 <Jafet> Totally pointless, because the solutions are readily available in many forms
01:43:39 <Jafet> Perhaps a duel over the 40+ questions in Knuth's
01:43:47 <medfly> what are those questions?
01:44:07 <Jafet> Might be a bit time-consuming. I recommend a "first to three" mode or something
01:44:11 <HaskellLove> Jafet what an answer was that? well you wont look at the answers on internet, like i do, i solve on my own and some help here for haskell
01:44:24 <HaskellLove> but yeah knuth is like the ultimate
01:44:33 <Jafet> The fact that the solutions are readily available tells you a lot about the quality of those problems
01:44:56 <medfly> they're good enough that people are willing to do them everywhere, or they're so bad that everyone can do them? ;)
01:44:59 <medfly> what does it tell?
01:45:00 <HaskellLove> any problem that can take you more then an hour to do is good
01:45:26 <Jafet> I like medfly's response better than yours
01:45:37 <medfly> aww, I feel loved
01:45:38 <HaskellLove> unless Jafet is a ninja level 10000000 and beyond
01:45:46 <medfly> HaskellLove: Cale is a level 1000000 ninja
01:46:01 <HaskellLove> I know about Cale, my dearest professor :)
01:46:06 <medfly> HaskellLove: he's programmed to kick people's ass in competitions which involve mathematical problems
01:46:23 <Jafet> Well, my most recent program took about two days
01:46:27 <Cale> I actually really dislike mathematics competitions.
01:46:29 <Jafet> But that was in C++
01:46:41 <medfly> Cale: for you it basically means lazily solving the questions.
01:46:55 <medfly> it's not really a competition
01:47:13 <HaskellLove> sorry Cale, how old were you?
01:47:15 <Jafet> Cale, what kind?
01:47:25 <Cale> HaskellLove: 26
01:47:30 <Cale> Jafet: of what?
01:47:48 <Jafet> Do you mean, such as putnam, IMO, etc.
01:48:56 <Cale> Jafet: I just conceptually don't view mathematics as a sensible thing to compete at.
01:49:14 <Jafet> I suppose that depends on what you view mathematics to be.
01:49:39 <Jafet> At some level, most "math" competitions test some fixed set of technique
01:50:32 <ivanm> Cale: how about more "problem solving" competitions that happen to have their problems be mathematical in nature? ;-)
01:51:05 <Jafet> There is Google's yearly competition, which I wouldn't take too lightly
01:51:29 <medfly> Cale just pretends to have no competitiveness
01:51:36 <ivanm> heh
01:51:47 <Cale> pretends to?
01:51:52 <Jafet> He's winning, then
01:51:57 <medfly> yeah, he's winning...
01:52:34 <ivanm> I thought everyone agreed that Cale was winning the "incomprehensible jargon spewing" competition ... ;-)
01:54:16 <medfly> so what are these knuth problems
01:58:21 <medfly> ?
02:16:20 <Rayne> how does `laenge2 xL = foldr (\_ n -> n+1) 0 xL` work? what is used as first foldr parameter?
02:17:36 <dum8d0g> Hi, I have question about data types
02:17:47 <dum8d0g> data X = A String | B String deriving (Eq, Show)
02:17:48 <dum8d0g> e = [(A "first"), (B "second"), (B "third"), (A "fourth")]
02:17:59 <dum8d0g> << this is what I have (example)
02:18:18 <dum8d0g> and I would like to filter all A's
02:18:39 <medfly> Rayne: the lambda thing.
02:18:39 <dum8d0g> is there way to do it without pattern/argument matching ?
02:18:46 <ski> Rayne : `\_ n -> n+1' is the first actual parameter given to `foldr', there
02:19:06 <ski> dum8d0g : you can use `[s | A s <- e]'
02:19:13 <dum8d0g> ha
02:19:15 <medfly> > (\_ y-> y) 2 3
02:19:16 <lambdabot>   3
02:19:25 <Rayne> ski, what is the first "parameter" in this "lambda thing", which we do not use?
02:19:39 <ski> Rayne : the "current element" of the list
02:19:45 <orbekk> Rayne: laenge2 (x:xs) = (\_ n -> n+1) (laenge2 xs)
02:20:17 <dum8d0g> ski: thank you, that helped a lot :)
02:20:36 <ski> orbekk : itym `laenge2 [    ] = 0; laenge2 (x:xs) = (\_ n -> n+1) x (laenge2 xs)'
02:21:20 <orbekk> ski: I actually meant to expand foldr one step, not defining the function :)
02:21:48 <orbekk> Rayne: look at the definition of foldr and try expanding it like that. you'll see how it works
02:21:52 <ski> orbekk : you still forgot to give `x' as argument to the anonymous function
02:22:15 <orbekk> ski: yes, you're right
02:22:17 * hackagebot upload: Geodetic 0.1 - Geodetic calculations (TonyMorris)
02:22:31 <ski> (orbekk : and one can take that either as a definition, or merely as a specification or explanation)
02:23:26 <ski> Rayne : ok ?
02:24:49 <dum8d0g> does anybody know about good reading material on "how to work with Data types", please ?
02:25:37 <ttmrichter> dum8d0g: Is the material in Real World Haskell helpful to you?
02:26:12 <Rayne> ski, where can i read the source of foldr?
02:26:21 <ski> @src foldr
02:26:22 <lambdabot> foldr f z []     = z
02:26:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:26:29 <ttmrichter> Rayne: There's an ... yeah.  Or you could do it that way.  :)
02:26:32 <ski> @index foldr
02:26:33 <lambdabot> Data.List, Prelude
02:26:49 * ttmrichter needs to find the help file for lambdabot sometime.
02:26:52 <ttmrichter> It's a nice powerful tool.
02:27:18 * hackagebot upload: hakyll 0.3.1 - A simple static site generator library. (JasperVanDerJeugt)
02:27:36 <medfly> what's the point of having foldr on two uh, module things
02:27:49 <medfly> one being Prelude
02:28:00 <ttmrichter> Prelude auto-imports the Data.List one is my guess.
02:28:35 <ttmrichter> Prelude is the standard library, but it doesn't have to be implemented in that package when it can just be re-exported, right?
02:31:19 * hackagebot upload: Geodetic 0.2 - Geodetic calculations (TonyMorris)
02:34:18 <Rayne> ttmrichter, there is what? :/
02:37:33 <HaskellLove> I have a function that given a list such as [2,2,1] it gives me [[2,1,1,1],[1,1,1,1,1]],  i work on euler 31, so basically it tells you in how many ways you can have 5 pence. so given 5 a function breaks it to [2,2,1] and from there i need to expand others. for example 2 pence can be reprsented as 2, or 1+1... 5 can be represented as 2+2+1, 2+1+1+1, 1+1+1+1+1 and 5
02:39:33 <ivanm> dibblego: what's your sudden fascination with mapping?
02:39:49 <dibblego> it's not sudden, been doing it for a long time
02:40:04 <ttmrichter> Rayne: What do you mean?
02:40:25 <ttmrichter> Oh, never mind.  Backscroll answered.
02:40:39 <ivanm> OK, what's your semi-recent fascination with mapping (since I don't recall seeing as many mapping-related packages being uploaded to Hackage with your name on them until the past month or so)?
02:40:45 <ttmrichter> I was going to point you to the Haskell 98 report which has source code for the Prelude in it.
02:41:00 <ttmrichter> (Not necessarily the actual implementation in GHC, but a known implementation.)
02:41:19 <dibblego> some of these packages have been on my disk for months needing tidying for hackage -- I use them for mapping scripts
02:42:53 <ivanm> what kind of mapping scripts?
02:43:21 <dibblego> I use a lot of OpenStreetMap data for creating maps for devices and planning trips , etc.
02:43:42 <dibblego> I always have a Garmin 60Cx on my belt :)
02:43:48 <ivanm> heh
02:43:59 <ivanm> doesn't the Garmin have the capability of planning trips, etc.?
02:44:02 <dibblego> Also I just did a Mount Barney ascent on a non-gazetted route
02:44:11 <dibblego> yes
02:44:20 <dibblego> I did that for a cruise to Fiji recently
02:44:48 <ivanm> so why do you use a separate script to plan your trips?
02:45:10 <dibblego> I use the data and it's a pain in the arse to do it without decent libraries
02:45:18 <HaskellLove> how do you convert a number to its binary equavelent?
02:45:31 <dibblego> existing map editors are quite poor
02:46:04 <Berengal> HaskellLove: Numbers are already binary. What do you mean?
02:46:31 <HaskellLove> no they are not they are base 10... i need 585 = 1001001001
02:46:31 <ivanm> Berengal: I think he means to turn 5 into [1,0,1]
02:46:41 <ivanm> HaskellLove: have a look at the digits library on hackage
02:47:29 <Lemmih> > Numeric.showIntAtBase 2 intToDigit 42 ""
02:47:30 <lambdabot>   "101010"
02:47:43 <HaskellLove> awesome
02:48:33 <ivanm> or that
02:48:39 <Cale_> > reverse . map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2) $ 42
02:48:41 <lambdabot>   [1,0,1,0,1,0]
02:48:42 <ivanm> @hoogle showIntAtBase
02:48:43 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
02:50:18 <HaskellLove> Lemmih what is the " thing?
02:50:30 <ivanm> @type ShowS
02:50:31 <lambdabot> Not in scope: data constructor `ShowS'
02:50:41 <ivanm> @hoogle ShowS
02:50:41 <lambdabot> Prelude type ShowS = String -> String
02:50:41 <lambdabot> Text.Show type ShowS = String -> String
02:50:41 <lambdabot> Prelude shows :: Show a => a -> ShowS
02:50:47 <Lemmih> HaskellLove: "" is an empty String.
02:50:55 <HaskellLove> yeah but why
02:51:09 <ivanm> HaskellLove: ShowS represents a way of stating that you're going to be joining Strings together
02:51:26 <ivanm> because using ShowS is more efficient than creating each String seperately then using ++
02:51:38 <ivanm> (well, it can be, depending on how you use it and the function that uses it)
02:51:43 <ivanm> @type Show
02:51:44 <lambdabot> Not in scope: data constructor `Show'
02:51:46 <ivanm> @src Show
02:51:46 <lambdabot> class  Show a  where
02:51:46 <lambdabot>     showsPrec :: Int -> a -> ShowS
02:51:46 <lambdabot>     show      :: a   -> String
02:51:46 <lambdabot>     showList  :: [a] -> ShowS
02:51:47 <ivanm> bah
02:51:50 <HaskellLove> The shows functions return a function that prepends the output String to an existing String.  got it... thanks
02:52:09 <ivanm> HaskellLove: ^^ note that by default, the Show class mainly uses ShowS rather than String
02:52:12 <ivanm> @src show
02:52:12 <lambdabot> show x = shows x ""
02:52:15 <ivanm> ^^
02:52:16 <Cale_> HaskellLove: the advantage being that you can concatenate the results using (.) which is O(1) time/space
02:52:22 <ivanm> @src shows
02:52:23 <lambdabot> Source not found. It can only be attributed to human error.
02:52:33 <ivanm> IIRC, shows = showsPrec 0
02:52:34 <ski> > (shows 42 . showString " shown at base " . shows 2 . showString " is " . showIntAtBase 2 intToDigit 42) ""
02:52:36 <lambdabot>   "42 shown at base 2 is 101010"
02:53:15 <HaskellLove> wait wait you confused me: Numeric.showIntAtBase 2 intToDigit 42 "" what role does it play here?
02:53:51 <ski> > showIntAtBase 2 intToDigit 42 "_(base two)"
02:53:53 <lambdabot>   "101010_(base two)"
02:54:26 <ivanm> @type showIntAtBase
02:54:27 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
02:54:33 <rajeshsr> Cale, what is the difference between `div` and div in iterate? they both give different answers
02:54:33 <ski> it ought to say
02:54:34 <ivanm> HaskellLove: showIntAtBase uses ShowS
02:54:38 <chrisdone> why don't people use real haskell notation in papers? e.g. this x ∧ y stuff confuses me as (∧) is a perfectly valid Haskell operator
02:54:42 <ivanm> (since String -> String = ShowS)
02:54:48 <ski>   showIntAtBase :: Integral i => i -> (Int -> Char) -> i -> ShowS
02:54:54 <ivanm> chrisdone: who says it's Haskell notation? ;-)
02:55:00 <chrisdone> the papers
02:55:05 <ivanm> @hoogle showIntAtBase
02:55:05 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
02:55:15 <chrisdone> Our aim in this pearl is to derive a Haskell program to solve Sudoku puzzles. Specifically, we will define a function
02:55:15 <chrisdone>  
02:55:18 <ivanm> chrisdone: IIRC, that was the major criticism of Hutton's book on Haskell as well
02:55:24 <chrisdone> suddenly, magic made up code!
02:55:31 <ivanm> ahhh, yeah, Hutton and Bird seem to like doing that :s
02:55:42 <chrisdone> =(
02:55:55 <mxc> anyone know of any CPS tutorials with practical, real world examples?
02:56:14 <mxc> as opposed to the canonical number printing one from the wikibook and all about monads
02:56:49 <HaskellLove> unbeleivable, in my language the syntax will be far from this nonintuitive
02:56:55 <chrisdone> mxc: I guess parsing is a good example of CPS
02:57:20 <ski> HaskellLove : .. which syntax are you talking about ?
02:57:40 <HaskellLove>  showIntAtBase 2 intToDigit 42 "_(base two)" ... i am converting to a binary, why would i need that string thing
02:58:13 <ski> HaskellLove : it happens to return a value of type `ShowS'
02:58:22 <Lemmih> HaskellLove: You're confusing syntax and semantics.
02:58:27 <ski> applying to `""' is how you (usually) turn that into `String'
02:58:40 <HaskellLove> why would it return such value? it is one-to-one mapping
02:58:55 <Lemmih> HaskellLove: Just define 'toBinary int = showIntAtBase 2 intToDigit int ""' and be done with it.
02:58:55 <ski> it could well be defined to return `String' directly instead
02:59:26 <ski> (but it would possibly be less efficient, unless the implementation does accumulator-introducing-optimization)
02:59:41 <HaskellLove> Lemmih tell ghc people to put such function, or i will ... haha
03:00:31 <ski> HaskellLove : but anyway, usually if you're defining a `Show' instance, you want to compose the functions that compute `ShowS's, instead of `String's
03:00:44 <HaskellLove> I mean, i want to google hoogle with "binary" and whoala i wanna see "toBinary" function, and not this kinda stuff... all languages have such nonintuitive webbed stuff, well world aint perfect anyways so...
03:01:43 <HaskellLove> ski see my point? all the trouble learning that, for what? just to get a binary of an int ... no way,.. anyways i am back to eulers
03:02:18 <ski> all the trouble learning what ?
03:03:12 <chrisdone> mxc: I'll show you
03:03:17 <ivanm> HaskellLove: but if you loved Haskell so much, you'd _want_ to learn this stuff!
03:03:46 <ivanm> (short version: cut your whinging)
03:03:47 <ski> (btw, i agree that needing to work with `ShowS' rather than `String' is a bit irksome .. but hardly *that* bothering)
03:03:50 <Lemmih> HaskellLove: You don't need to understand ShowS to use 'showIntAtBase'. I'd even wager that you don't understand it.
03:04:00 <chrisdone> mxc: let's say you want to parse the letter 'a' from a string, and to show parse success, you replace the letter 'a' in the string with '.'
03:04:04 <ivanm> ski: right, but if you're doing anything low-level with Strings then it's handy
03:04:17 <ivanm> Lemmih: I'd wager he understands very little Haskell
03:04:21 <chrisdone> > let parseLetterA str next = if (head str) == 'a' then '.' : next (tail str) else "" in parseLetterA "abc" id
03:04:22 <lambdabot>   ".bc"
03:04:29 <ivanm> HaskellLove: have you bothered to get cabal-install yet?
03:05:02 <ski> ivanm : it would be nicer if `show foo ++ bar' magically always worked like `shows foo bar' .. but i'm not sure how reasonable it would be to expect an implementation (or language) to promise that
03:05:05 <HaskellLove> i waited to get debian but after realizing i will be ok with ubuntu and i need no debian... well, will get cabal tonight i guess
03:05:16 <ivanm> ski: yeah
03:05:28 <ski> (and similar for every function currently producing `ShowS', of course. not just `shows')
03:05:31 <ivanm> HaskellLove: I think the debian packages for the haskell platform will also work in ubuntu...
03:05:36 <chrisdone> mxc: here I've defined parseLetterA which takes the string and a function to apply to the rest of the string if it can parse 'a', otherwise it returns a blank string and stops the parsing. ok?
03:06:03 <ivanm> Ubuntu" is an ancient African word, meaning: "I can't configure Debian." ;-)
03:06:28 <ivanm> @google haskell platform
03:06:29 <lambdabot> http://hackage.haskell.org/platform/
03:06:29 <lambdabot> Title: Haskell Platform Download (Beta)
03:06:32 <ski> chrisdone : why are you replacing parsed tokens ?
03:06:37 <HaskellLove> ivanm well i really don't need debian, all i need is haskell for the eulers and decent desktop and shell
03:06:37 <ivanm> HaskellLove: see how hard it was? ;-)
03:06:52 <ivanm> hey, who re-enabled URL titles?
03:06:53 <chrisdone> ski: for simplicity
03:07:06 <ski> as opposed to what ?
03:07:12 <ivanm> HaskellLove: that quote is more for my own amusement than directed at you ;-)
03:07:25 <chrisdone> ski: I guess it doesn't matter as mxc has disappeared
03:07:52 <ski> (chrisdone : btw, you do know that `parseLetterA' is in nqCPS rather than CPS, right ?)
03:08:08 <copumpkin> OMG FUNCTIONAL PROGRAMMING SUCKS! JOE BLOGGER SEZ SO
03:08:19 <ivanm> copumpkin: yeah, I saw that page as well
03:08:21 * copumpkin goes and learns go
03:08:55 * Saizan_ stares at copumpkin 
03:09:07 * copumpkin sticks out his tongue at Saizan_ 
03:09:23 <copumpkin> enjoy your shackles! I'm gonna LEARN GO!!!
03:09:34 <ivanm> Saizan_: http://prog21.dadgum.com/54.html
03:09:46 <ivanm> copumpkin: enjoy using an un-googleable language!
03:10:06 <copumpkin> what's sad is that he's supposedly been programming in erlang since 1999 and his examples of why FP sucks show that he didn't really get it
03:10:22 <ivanm> and that he doesn't understand that Erlang /= Haskell
03:10:36 <ivanm> it's like saying Pascal sucks, ergo so does C (which it does, but for different reasons)
03:10:47 <copumpkin> well yeah, but he doesn't understand that SSA isn't FP either
03:10:47 <ivanm> after all, they're both imperative languages...
03:10:56 <HaskellLove> yo give me link to read that
03:11:04 <ivanm> copumpkin: let's simplify it to "He doesn't understand _" ;-)
03:11:10 <ivanm> HaskellLove: I already pasted the link above
03:11:11 <copumpkin> :)
03:11:25 <ivanm> and I for one don't like demands being placed upon me
03:12:23 <copumpkin> I for one welcome our new demanding overlords
03:12:39 <chrisdone> ski: what's ``nqCPS''? googling it comes up with IRC logs of you saying the term. did you make it up?
03:14:06 <ray> enjoy YOUR shackles, i'm learning fortran 77
03:14:11 <DigitalKiwi> copumpkin: I demand a cookie!
03:14:29 <copumpkin> DigitalKiwi: oh, I welcome you, but get your own damn cookie
03:14:53 <DigitalKiwi> fine, then I won't share my delicious pie with you
03:15:13 <copumpkin> :O
03:15:16 <Saizan_> i hope erlang is taught better than that..
03:15:24 <DigitalKiwi> how you like them apples
03:15:27 <ski> chrisdone : i didn't make it up. it stands for "not-quite Continuation Passing Style"
03:15:59 <ski> it's basically that in your code, most calls are tail-calls, but some aren't
03:16:24 <copumpkin> Saizan_: the problem seems to be that all these lax FP languages (i.e., not haskell, clean) let you keep doing much of the same stuff you did in imperative languages in the new FP language, and then you get frustrated with that and complain that it sucks
03:16:42 <ski> in direct style, this corresponds to using the `shift' and `reset' control operations
03:17:39 <HaskellLove> ouch this article scares me
03:17:57 <copumpkin> HaskellLove: because its author is so clueless!? yes! me too!
03:18:01 <copumpkin> ;)
03:18:14 <Saizan> copumpkin: yeah, that looks right
03:18:26 <chrisdone> ski: ok
03:18:56 <HaskellLove> copumpkin how about admiting that he might be right... which i dont know still being in honey month with haskell
03:19:24 <ivanm> ray: eh, IMHO Fortran (>= 90) isn't too bad
03:19:49 <Jafet> Fortran >= 90 isn't really Fortran
03:19:52 <copumpkin> HaskellLove: I'm going to write that HaskellLove has blue ears and polka dots on his chest. If you're horrified that such misinformation is being spread by someone who's never met you, I'm going to reply with "how about admitting that he might be right"
03:20:08 <ivanm> Jafet: in what way?
03:20:30 <ray> shackles!
03:20:39 <ivanm> HaskellLove: that guy has nfi what he's talking about
03:20:39 <copumpkin> HaskellLove: that article has almost no content whatsoever.
03:20:40 <ivanm> copumpkin: :/
03:21:22 <ray> that article: i came up with some contrived example, announced that it's impossible, and therefore FP sucks
03:21:44 <HaskellLove> copumpkin i do have blue ears on my chest :(
03:22:01 <Jafet> ivanm, you can write C in it
03:22:13 <ane_> on your... chest?
03:22:14 <ivanm> in Fortran 90? :o
03:22:17 <ray> you can't reverse strings in haskell, because you can't allocate a string buffer to store the result in! functional programming is so bad, i'd just use malloc in C
03:22:21 <Jafet> In fact, you can almost write C++ in the latest Fortran, I wouldn't be surprised
03:22:29 <ivanm> ray: heh
03:22:36 <cizra> ray: haha
03:22:58 <ivanm> @remember ray [about an anti-FP blog post] i came up with some contrived example, announced that it's impossible, and therefore FP sucks
03:22:58 <lambdabot> Nice!
03:23:36 <chrisdone> maybe he's just a skillful troll
03:23:46 <ivanm> Jafet: from my (admittedly brief) exposure to both Fortran 90 and C, I found F90 easier to use (since you don't _have_ to use pointers everywhere, etc.)
03:23:47 <copumpkin> chrisdone: not even skilful
03:23:53 <copumpkin> skillful, even
03:23:54 <ivanm> though I did learn F90 after I did C...
03:24:07 <ray> malloc(strlen(s) * sizeof(char)) /* the sizeof(char) part is important */
03:24:07 <ivanm> yeah, it's hard to read his diatribes
03:24:12 <Jafet> It still has Fortran in it, but it sure ain't Fortran.
03:24:18 <chrisdone> where his target audience is to get functional programmers in a hissy
03:24:51 <ivanm> Jafet: you mean FORTRAN? :p
03:25:09 <DigitalKiwi> chrisdone: i see what you did there
03:25:23 <cizra> ray: So, who says Haskell can't reverse strings?
03:25:25 <Jafet> Ah, good catch.
03:25:39 <cizra> > reverse "loof"
03:25:40 <lambdabot>   "fool"
03:26:09 <mxc> chrisdone - thanks.  sry was in the shower..
03:26:09 <ray> > malloc (length "loof")
03:26:11 <lambdabot>   Not in scope: `malloc'
03:26:14 <chrisdone> it's funny when you see Lisp newbies say "I'm thinking of learning LISP"
03:26:19 <int-e> ray: important, in which language?
03:26:27 <ray> i'm talking about C
03:26:39 <mxc> chrisdone - someone actually just wrote  apretty decent blog post on using CPS for error hadnling in parsec
03:26:55 <ray> people actually multiply by sizeof char all the time
03:26:55 <ray> :(
03:27:05 <ray> http://www.google.com/codesearch?hl=en&lr=&q=%22sizeof%28char%29%22&sbtn=Search
03:27:20 <chrisdone> ray: what's wrong with that?
03:27:33 <ray> it's required to be 1
03:27:40 <chrisdone> duh
03:27:41 <int-e> cute.
03:27:52 <ray> sizeof gives you the size in multiples of char
03:28:17 <int-e> I like this, if (sizeof(char)  != 1) return 0;
03:28:18 <chrisdone> must be force of habbit
03:28:22 <DigitalKiwi> char is required to be 1?
03:28:44 <Jafet> For maximum confusion, multiply by sizeof('a')
03:28:49 <chrisdone> DigitalKiwi: that is, the number of bytes a char holds
03:29:13 * theorbtwo shrugs.  The number of kg/l of water is required to be 1 as well, but conversion can still be clearer.
03:29:57 <ray> > let buffer = malloc (length "string") in buffer := reverse "string"
03:29:58 <lambdabot>   Not in scope: `malloc'
03:30:05 <DigitalKiwi> other types can vary by arhitecture though?
03:30:08 <cizra> ray: There is no malloc in Haskell.
03:30:10 <ray> yeah
03:30:29 <int-e> @index malloc
03:30:30 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
03:30:47 <int-e> @type Foreign.malloc
03:30:48 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO (GHC.Ptr.Ptr a)
03:33:54 <zygoloid> Jafet: isn't that sizeof(int) in C or something equally silly?
03:37:25 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=41 anyone knows what is the search space? milion or more?
03:38:44 <copumpkin> the answer has 7 digits
03:38:55 <BONUS> HaskellLove: well there are only 10 digits
03:38:55 <HaskellLove> tnx
03:38:56 <BONUS> so
03:39:27 <HaskellLove> ah yeah, well i thought you can also do 1110 and hav 11 and 10... but 1..9 is ok i guess
03:42:08 <Berengal> Programming C in haskell is pretty easy...
03:43:21 <medfly_> there's only one?
03:43:28 <medfly_> er, ther'es a biggest one?
03:43:50 <medfly_> oh doh
03:44:00 <medfly_> you can't have 10 as a digit
03:44:59 <Saizan> i guess you could change the base
03:47:18 <zygoloid> > product [1..9]
03:47:18 <lambdabot>   362880
03:50:58 <mreh> Was Henning Thielemann a Lisp programmer?
03:51:43 <Saizan> i'd guess ML
03:52:12 <mreh> he never uses pattern matching if he can avoid it
03:52:28 <mreh> well that's absurd, but it would make his code nicer
03:53:50 <medfly_> who is this guy
03:54:09 <mreh> a prolific contributor, with a unique programming style
03:54:17 <medfly_> oh, okay. thanks
03:54:22 <mreh> ever seen code with lots of Ts and Cs everywhere
03:54:25 <mreh> that's his
03:54:34 <medfly_> no I don't usually read other people's Haskell
03:54:36 <copumpkin> it's really annoying
03:54:50 <copumpkin> because he writes some good stuff
03:55:58 <dv_> hm
03:56:06 <dv_> is there something wrong with pattern matching?
03:56:08 <mreh> he's abstracted away having multiple function defs with different patterns matching the argument to a function that takes one function for each constructor, it's strange
03:56:39 <mreh> not at all, it makes it a readable specification
03:57:16 <|fft|> Why can't I write   instance Monad (Either String) where ... ?
03:57:44 <mreh> |fft| what does it give you?
03:57:52 <copumpkin> |fft|: you can
03:57:56 <mreh> probably because String is a synonym
03:58:48 <|fft|> with [Char] is the same
03:59:03 <|fft|> it says
03:59:06 <mreh> |fft| paste the two occurances
03:59:07 <|fft|> Illegal instance declaration for `Monad (Either String)'
03:59:08 <|fft|>         (All instance types must be of the form (T a1 ... an)
03:59:08 <|fft|>          where a1 ... an are type *variables*,
03:59:08 <|fft|>          and each type variable appears at most once in the instance head.
03:59:08 <|fft|>          Use -XFlexibleInstances if you want to disable this.)
03:59:08 <|fft|>         
03:59:22 <|fft|> so I should run ghci with this option or what ?
03:59:25 <mreh> |fft| don't flood the channel, use paste
03:59:29 <mreh> @paste
03:59:30 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:59:42 <mxc> copumpkin - he's the HXT guy right?
03:59:48 <|fft|> ok sorry
04:00:05 <mreh> |fft| compile both versions and past the error for each
04:00:42 <Saizan> |fft|: well, you've to enable that extension to write an instance like that
04:01:18 <mreh> from what I remember you can't use compound types, but if you use {-# OPTIONS_GHC -XTypeSynonymInstances #-} you can declare the whole type as a synonym and use that, that will also solve your problem of using String
04:01:57 <mreh> if you want to use both a compound type and string you will probably need both -XFlexibleInstances and -XTypeSynonymInstances
04:02:12 <Saizan> even for String you need both, afaiu
04:02:17 <mreh> i'm in no position to compile anything right now though, try it out and tell us what happens
04:06:05 <|fft|> so with this option it compiled. But I can't get why it is not default option
04:07:14 <zygoloid> |fft|: the defaults are (approximately) the behaviour defined by the haskell'98 standard.
04:07:49 <zygoloid> there's -fglasgow-exts if you want a reasonable-ish set of extensions
04:08:25 <mreh> that's why I choose the Glorious Glasgow Haskell Compiler :D
04:08:43 <dibblego> @pl (fmap join .) . mapM
04:08:44 <lambdabot> (fmap join .) . mapM
04:08:48 <zygoloid> but for portability it's generally better to specify which extensions you're using (with a LANGUAGE pragma)
04:08:48 <dibblego> @type (fmap join .) . mapM
04:08:49 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
04:10:19 <zygoloid> @type ((.).(.).(.)) join mapM
04:10:19 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
04:10:49 <zygoloid> i'm reminded of Total Recall for some reason
04:11:12 <mreh> triple breasted hookers?
04:12:05 <ivanm> mreh: eh, the novella was better than the movie
04:18:39 <Lanjiao>  /msg NickServ Lanjiao 301415
04:18:56 <HaskellLove> this is way to slow: elem 4545454 triangleNums, it calculates for hours, just for one number ! :d any better way to test if n is a triangle number?
04:22:31 <Lanjiao> why the following code cause error " test.hs:10:24: Not in scope: `x'"
04:22:41 <Lanjiao> f = do x:xs <- getArgs
04:22:43 <Lanjiao>        if xs /= []
04:22:45 <Lanjiao>          then putStr "ok"
04:22:48 <Lanjiao>          else putStr xnew
04:22:48 <Lanjiao>            where xnew = x
04:22:50 <Lanjiao> it's ok to use let
04:22:53 <ivanm> Lanjiao: do (x:xs) <- getArgs
04:22:55 --- mode: dibblego set -o dibblego
04:23:36 <Lanjiao> ivanm: but let is ok
04:23:39 <mauke> Lanjiao: xs /= [] better written as null xs
04:23:51 <mauke> Lanjiao: the 'where' is attached to the entire definition of f
04:23:52 <ivanm> mauke: agreed
04:23:58 <mauke> at that point 'x' doesn't exist yet
04:23:59 <ivanm> Lanjiao: in what way is it OK?
04:24:06 <ivanm> oh, right
04:24:23 <cizra> 13:03 [freenode] DCC SEND from e54ith6 [0.0.0.0 port 0]: startkeylogger [0B bytes] requested in channel #haskell
04:24:26 <cizra> 13:08 [freenode] DCC aborted receiving file startkeylogger from e54ith6
04:24:29 <cizra> -- WTF?
04:24:36 <ivanm> mauke: is the where part of the else or the overall function?
04:24:42 <cizra> Is somebody thinking I'm a bot?
04:24:44 <ivanm> cizra: there was a spammer in here before
04:25:08 <ivanm> Lanjiao: I think the problem is that the where statement is outside of the do block
04:25:13 <mauke> ivanm: the 'where' is attached to the entire definition of f
04:25:18 <ivanm> *nod*
04:25:27 <mauke> 'where' is not an expression or part of an expression
04:25:28 <Lanjiao> mauke: and is there a way i can use where and doesn't have this problem?
04:25:30 <ivanm> Lanjiao: as such, it doesn't know what x is
04:25:32 <mauke> (unlike 'let')
04:25:40 <ivanm> since x is defined _inside_ the do block
04:25:47 <mauke> Lanjiao: yes, sort of, but it's not worth it
04:25:48 <ivanm> Lanjiao: not for this, no
04:26:02 <ivanm> Lanjiao: for this reason let statements are used in do blocks a lot more than in pure code
04:26:13 <mauke> you'd have to introduce a new definition (e.g. with let) and attach the where clause to that
04:26:18 <ivanm> I can't recall a single time I used a let statement outside of a do block....
04:26:26 <ski> ivanm,Lanjiao : the brackets around the pattern is not needed, there .. `x:xs <- getArgs' is quite ok
04:26:33 <lpsmith> why is xs /= [] better?   The only difference is that it assumes equality on the elements of xs,  which isn't actually used
04:26:33 <ivanm> ski: *nod*
04:26:40 <ivanm> ski: yeah, I misread his problem
04:26:49 <ivanm> lpsmith: better than what?
04:26:53 <lpsmith> null
04:27:00 <ski> (Lanjiao : i hope you've changed your password, btw)
04:27:01 <ivanm> lpsmith: mauke said that _null_ was better ;-)
04:27:09 <lpsmith> err,  right
04:27:17 <lpsmith> but it's not that much worse, really
04:27:20 <ivanm> does Lanjiao == HaskellLove ?
04:27:34 <ivanm> lpsmith: its neater and more obvious in what it does
04:27:44 <ivanm> otherwise, why bother defining null if no-one uses it?
04:28:12 <lpsmith> ahh,  the "if it's there I should use it" fallacy :-)
04:28:32 <ivanm> lpsmith: :o
04:28:36 <ivanm> how is it a fallacy?
04:28:43 <Lanjiao> ivanm: no Lanjiao is sth good in Chinese
04:28:52 <lpsmith> ivanm:  Like I said, it has exactly one advantage over (/= []),  it doesn't assume equality on the types.
04:29:00 <ivanm> lpsmith: so you re-define base libraries for each app? ;-)
04:29:12 <ivanm> @length "xs /= []"
04:29:12 <lambdabot> Unknown command, try @list
04:29:15 <ivanm> > length "xs /= []"
04:29:16 <lambdabot>   8
04:29:16 <lpsmith> yes, absolutely :-P
04:29:19 <ivanm> > length "null xs"
04:29:20 <lambdabot>   7
04:29:30 <ivanm> lpsmith: another advantage! one character shorter!
04:29:32 <zygoloid> > length "not (null xs)"
04:29:33 <lambdabot>   13
04:29:39 <zygoloid> umm, 5 chars longer?
04:29:43 <ivanm> Lanjiao: well, you seem to have the same name as HaskellLove...
04:30:00 <lpsmith> @length "xs/=[]"
04:30:00 <lambdabot> Unknown command, try @list
04:30:08 <ivanm> heh
04:30:10 <lpsmith> > length "xs/=[]"
04:30:11 <lambdabot>   6
04:30:12 <lpsmith> :-P
04:30:12 <ivanm> zygoloid: oh...
04:30:14 <ivanm> yeah
04:30:22 <ivanm> bah
04:30:51 <lpsmith> not that I recommend writing it that way,  don't fear the whitespace!
04:31:52 <HaskellLove> ivanm are you drunk :D i am HaskellLove dude
04:32:23 <ivanm> so what's with this "New Now Know How" you both happen to have (as well as other people who have been here in the past) as your name?
04:32:24 <Lemmih> ivanm: It might be because they both use chatzilla.
04:32:30 <medfly_> ivanm: chatzilla, I think
04:32:44 <HaskellLove> i am on chatzila yea
04:32:45 <ivanm> oh... didn't think of it being a client-based "name"
04:32:49 <ivanm> @slap chatzilla
04:32:49 * lambdabot orders her trained monkeys to punch chatzilla
04:32:56 <ivanm> wtf does that even mean, anyway :s
04:32:59 <medfly_> trained monkeys...
04:33:11 * Lemmih punches chatzilla.
04:33:26 * ivanm didn't realise Lemmih was one of lambdabot's trained monkeys...
04:33:38 * zygoloid gives punch to chatzilla
04:34:00 <mpiechotka> @pl \f -> liftM concat . mapM f
04:34:00 <lambdabot> (fmap join .) . mapM
04:34:05 <mauke> better than untrained monkeys, I suppose
04:34:20 <ivanm> and zygoloid is obviously a poorly trained monkey
04:34:51 <zygoloid> ook?
04:34:58 <ivanm> no, that's orangutans
04:35:04 <ivanm> don't you ever read Discworld? ;-)
04:35:08 <zygoloid> that'll be the poor training ;-)
04:35:39 <ivanm> heh
04:35:46 <medfly_> oh, you can use lambda things without parens around them!
04:36:05 <ski> of course :)
04:36:30 <lpsmith> it's just that you often need parens around lambdas ;-)
04:37:16 <Phillemann> What library do you recommend to do 2D graphics in Haskell? Or...a combination of libraries.
04:37:23 <zygoloid> > ($21) $ \n -> n * 2
04:37:24 <lambdabot>   42
04:37:26 <HaskellLove> triangleNums lim = [x | y <- [1..lim], let x = 1/2 * y * (y+1)]; isTriangle n = elem n (triangleNums n); the coolest isTriangle function ever
04:38:20 <lpsmith> HaskellLove, which PE problem is that?
04:38:39 <HaskellLove> i need it for euler 42
04:38:53 <ivanm> Phillemann: probably depends on what kind of graphics you want to do
04:39:25 <medfly> @pl triangleNums lim = [x | y <- [1..lim], let x = 1/2 * y * (y+1)]; isTriangle n = elem n (triangleNums n);
04:39:26 <lambdabot> (line 1, column 18):
04:39:26 <lambdabot> unexpected "="
04:39:26 <lambdabot> expecting variable, "(", operator or end of input
04:39:30 <Phillemann> ivanm: Well, I thought about doing a very simple 2D game in Haskell, so I'd need to load a few bitmaps and process input.
04:39:31 <medfly> :(
04:39:32 <lpsmith> oh, hahaha
04:39:49 <ivanm> Phillemann: see what the other games on hackage use maybe
04:39:56 <medfly> using @pl makes you appear smarter!
04:40:01 <ski> > [[0,1,2,3],[4,5,6],[7,8],[9],[]] >>= \xs -> (xs >>= \x -> return (intToDigit x)) `mplus` return '\n'
04:40:02 <lambdabot>   "0123\n456\n78\n9\n\n"
04:40:04 <lpsmith> HaskellLove:   the basic approach is fast enough
04:40:08 <ivanm> medfly: don't think @pl understands list comprehensions
04:40:18 <lpsmith> HaskellLove:   your function has a bit of a bug...
04:40:21 <Phillemann> ivanm: Ok, I'll do that.
04:40:24 <ivanm> HaskellLove: please don't try and make grandiose claims about the quality of your code again...
04:40:39 <ivanm> I thought you would have learnt your lesson the other day about your digit rotating function
04:40:47 <HaskellLove> medfly what is @p?
04:40:57 <ivanm> there is no @p
04:41:01 <ski> @help pl
04:41:02 <lambdabot> pointless <expr>. Play with pointfree code.
04:41:03 <lpsmith> It's not a speed issue, it's a termination issue ;-)
04:41:07 <ivanm> but @pl is the pointfree (aka pointless) plugin
04:41:11 <zygoloid> > let isTriangle n = n == k*(k+1) `div` 2 where k = floor (sqrt (fromIntegral n * 2)) in filter isTriangle [1..100]
04:41:12 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91]
04:41:51 <HaskellLove> ivanm the code is working ,whatare you talking about
04:42:03 <lpsmith> no it isn't
04:42:04 <ski> medfly : triangleNums lim = [1/2 * y * (y+1) | y <- [1..lim]]; isTriangle = elem `ap` triangleNums
04:42:16 <lpsmith> it's taking hours and hours because it will *never finish*
04:42:17 <ivanm> HaskellLove: "... the coolest isTriangle function ever"
04:42:17 <medfly> oh, okay
04:42:39 <HaskellLove> lpsmith have you even tried it? that is why the lim is there dude
04:43:15 <lpsmith> oops, my bad
04:43:31 <copumpkin> > scanl1 (+1) [1..]
04:43:32 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
04:43:44 <copumpkin> > scanl1 (+) [1..]
04:43:45 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
04:43:56 <lpsmith> but yeah,  the approach should be fast enough for that problem
04:44:08 <lpsmith> Your problem is elsewhere
04:44:32 <HaskellLove> ivanm you see dude? it works, lpsmith made a mistake, dont ever call my code bad man :D
04:44:56 <HaskellLove> copumpkin that is generator yes, but i need to test if n is element of that list
04:45:10 <zygoloid> HaskellLove: your code is bad :) you're using an O(sqrt n) algorithm for an O(log n) problem ;)
04:45:45 <HaskellLove> zygoloid wow it seems you are asymptotic ninja, i am not there yet
04:45:47 <medfly> .......
04:46:12 <zygoloid> HaskellLove: i was largely kidding. if your code is fast enough for your use case then it really doesn't matter :)
04:46:16 <medfly> I think HaskellLove is happy that he just managed to write code in Haskell without asking #haskell for help.
04:46:25 <copumpkin> HaskellLove: from wikipedia: "An integer x is triangular exactly if 8x + 1 is a square. Equivalently, if the positive triangular root n of x is an integer, then x is the nth triangular number.
04:46:26 <copumpkin> "
04:46:28 <HaskellLove> medfly yep
04:46:45 <mux> hah, asymptotic ninja
04:47:09 <mauke> real asymptotic power!
04:47:10 <copumpkin> it's fairly simple to write an isSquare function
04:47:14 <lpsmith> zygoloid,  given the problem he's trying to solve,  that's not HaskellLove's issue
04:47:27 <lpsmith> I used (more or less) the same approach,  and it goes plenty fast
04:47:30 <zygoloid> lpsmith: yeah, i know :)
04:47:45 <lpsmith> lol
04:47:53 <mux> you can speed up isSquare by looking at the digital root, IIRC
04:48:31 <medfly> digital root?
04:48:51 <lpsmith> I'm still suspicious he has an infinite loop elsewhere in the program.   I don't think he's profiled it
04:49:03 <medfly> infinite loop? what is this, C/
04:49:23 <dibblego> a turing complete language
04:49:24 <mux> the digital root for x is the sum of all digits until you only have one digit, or equivalently x `mod` 9 + 1 (still, IIRC)
04:49:27 <HaskellLove> lpsmith no i dont, sorry
04:51:11 <mux> @check \x -> until (< 10) (sum . map digitToInt . show) x == (x::Int) `mod` 9 + 1
04:51:12 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
04:51:15 <lpsmith> mux:  you can (possibly) speed up checking for a perfect square mod any number, not just digital roots
04:51:41 <mux> @check \x -> x >= 0 ==> until (< 10) (sum . map digitToInt . show) x == (x::Int) `mod` 9 + 1
04:51:41 <lambdabot>   No instance for (Test.QuickCheck.Testable
04:51:42 <lambdabot>                     (Test.QuickCh...
04:51:49 <mux> err
04:52:31 <lpsmith> mux,  the digital root is equal to (x - 1) `mod` 9  + 1
04:52:40 <lpsmith> except if x is zero
04:52:48 <mux> ah
04:52:58 <mux> I wasn't far :-)
04:53:12 <mux> but I can't seem to use ==> with the @check command
04:55:38 <zygoloid> > nub $ map (until (<10) (sum . map (read . return) . show) . join (*)) [1..100]
04:55:39 <lambdabot>   [1,4,9,7]
04:56:30 <mux> yes, that's the particular speedup; a perfect square can only have those 4 particular digital roots
04:56:35 <copumpkin> digitToInt
04:57:02 <HaskellLove> i installed cabal on my 30-day aniversary of haskell learning, yeiiii
04:57:11 <zygoloid> > (length "digitToInt", length "show.(:[])")
04:57:12 <lambdabot>   (10,10)
05:00:47 <Lanjiao> again... how to get this worked (error "test.hs:20:11: Not in scope: `x'") ? must I use the let clause?
05:00:49 <Lanjiao> k = \x -> x'+y
05:00:51 <Lanjiao>   where y=x'
05:00:53 <Lanjiao>         x'=x
05:01:19 <mauke> k = \x -> x + x
05:02:04 <mux> (2*)
05:02:07 <mux> I win!
05:02:23 <Lanjiao> mauke: just to show why where not work......
05:02:26 <HaskellLove> what is your cabal and haskell platform usage? for cabal, you see some new package and install it right? for the platform you use profilers?
05:02:33 <zygoloid> Lanjiao: you can't use 'where' within a lambda
05:02:51 <zygoloid> Lanjiao: so that parses as k = (\x -> x' + y) where ..., and the x is not in scope
05:03:46 <Lanjiao> zygoloid: thanks, that means i must use let in a lambda?
05:04:17 <lpsmith> Heh, it's approximately my 12th anniversary of learning Haskell.   Give or take a few months
05:04:24 <zygoloid> Lanjiao: yes. or you can write 'k x = x' + y where ...'
05:05:15 <ivanm> lpsmith: OK, so where's the cake? ;-)
05:05:29 <Lanjiao> zygoloid: thanks:)
05:05:32 <ivanm> it's approximately my 3rd anniversary
05:05:37 <zygoloid> lpsmith: sequence (map return) (replicate 100 Happy)
05:05:56 <ivanm> zygoloid: why not replicateM ?
05:06:31 <zygoloid> ivanm: i think that makes it too obvious :)
05:06:45 <ivanm> heh
05:07:57 <HaskellLove> stop the cake talk tell me what for yo use cabal and the platform, i installed them and now i scratch my head why i would need them :D
05:08:17 <lpsmith> Yeah, I learned when it wasn't quite so easy,   it mostly consisted of the Gentle Introduction and a book on SML.
05:08:24 <ivanm> HaskellLove: to avoid re-inventing the wheel
05:09:31 <zygoloid> HaskellLove: the purpose of the platform is at least partly to provide a common set of libraries (a 'platform' if you like) on which code can depend, and be reasonably confident those libraries will be available on other systems
05:09:57 <lpsmith> hackage is wonderful
05:10:07 <ivanm> damn straight
05:10:13 <lpsmith> With just a few keystrokes you can get a nice collection of libraries set up
05:10:23 <ivanm> now, if only they fixed up some of the build problems (i.e. they finished off and released hackage-2)
05:10:37 <ivanm> and it'd be nice if gtk2hs, etc. were cabalised
05:10:55 <medfly> it's not so bad to re-invent the wheel
05:10:55 * ivanm wonders how difficult it would be to get "cabalised" added into the oxford dictionary...
05:10:56 <ivanm> ;-)
05:10:59 <HaskellLove> so you guys check libraries, you like some, ok download, right? is that all or you use profilers?
05:11:04 * medfly studied Haskell mostly by re-implementing a lot of the functions.
05:11:21 <lpsmith> whereas it used to take a great deal of effort to track them down,  and then compile the libraries by hand.   And many libraries needed tweaking before they'd work
05:11:30 <lpsmith> due to bit-rot
05:11:35 <ivanm> HaskellLove: ummm.... you can profile the libraries involved...
05:11:42 <pastah_rhymez> @type liftIO
05:11:44 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
05:11:57 <ivanm> part of the point of the platform is to designate "blessed" libraries: "yes, there are 20 different XML libraries, but we think these 3 are the best ones"
05:12:21 <ivanm> lpsmith: yes, now we just have to worry about updating packages to get them to work with new dependencies/ghc releases :s
05:12:31 * ivanm tried to build HaRE a few months back; it was _fun_ :s
05:13:41 <lpsmith> yeah,  cabal-install is nice when it works,  and it's much better than it used to be when it doesn't
05:14:18 <lpsmith> but when it doesn't work... ehh
05:15:00 <HaskellLove> lpsmith aren't you suposed to like hmm ... lie me how cabal is great and perfect, me being the new to cabal guy?
05:15:44 <lpsmith> oh,  it beats not having it,  by a lot :-)
05:16:00 <ivanm> HaskellLove: Cabal /= cabal-install
05:16:01 <copumpkin> HaskellLove: we like haskell, but that doesn't mean we think it's 1000% perfect.
05:16:17 <ivanm> CABAL == Common Architecture for Building Applications and Libraries
05:16:39 <ivanm> it's a library that takes a textual description of a package and can be used to build it
05:17:04 <ivanm> cabal-install (with an application called "cabal") uses Cabal to do dep resolution, etc. for packages on Hackage
05:17:12 <Paczesiowa> copumpkin: if it was, what would we dream about at nights?
05:17:19 <copumpkin> :)
05:17:26 <medfly_> Paczesiowa: other languages being more like Haskell
05:17:39 <medfly_> Paczesiowa: specifically what we use at work
05:18:14 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15161#a15162 please help
05:18:25 <HaskellLove> i get the error below
05:19:35 <copumpkin> HaskellLove: sqrt
05:19:48 <copumpkin> :t sqrt
05:20:13 <HaskellLove> why sqrt i dont get it?
05:20:15 <copumpkin> @botsnack
05:20:15 <lunabot>  :o
05:20:42 <HaskellLove> i mean why is the error there, please explain...
05:20:49 <medfly_> someone killed a lambdabot?
05:21:10 <copumpkin> #ty sqrt
05:21:16 <lunabot>  forall a . Floating a => a -> a
05:21:32 <copumpkin> #ty properFraction
05:21:35 <lunabot>  forall b a . (RealFrac a, Integral b) => a -> (b, a)
05:21:40 <Paczesiowa> medfly_: THE!
05:21:50 <medfly_> our?
05:22:12 <copumpkin> IRC is such shit, I wish we had a better alternative
05:22:19 <lpsmith> heh
05:22:25 <HaskellLove> copumpkin like telepathy?
05:22:30 <adu> copumpkin: like AI?
05:22:32 <lpsmith> almost sounds like a challenge :-)
05:22:46 <copumpkin> like a decent simple protocol for chatting that doesn't suffer from this shit
05:22:47 <adu> hirc?
05:22:53 <HaskellLove> adu i like telepathy better, AI sucks
05:23:05 <adu> HaskellLove: what kind of AI are you talking about?
05:23:27 <HaskellLove> adu chating future kinda fantasy AI
05:23:41 <adu> if you're talking about machine learning or sorting algorithms, then i would tend to agree
05:23:54 <adu> "fantasy AI" sucks
05:24:10 <adu> its either stupid as h*ll, or evil as sh*t
05:24:40 <lpsmith> so what's the key design elements of a worthy successor to IRC?
05:24:57 <adu> human-brain interface, obviously
05:25:24 <jaspervdj> When my package build on hackage, I get a lot of errors for "Couldn't match expected type `B.ByteString' against inferred type `bytestring-0.9.1.4:Data.ByteString.Lazy.Internal.ByteString'"... anyone know what to do?
05:25:28 <adu> then some kind of telepathic encryption, obviously
05:25:34 <HaskellLove> copumpkin so how to convert to type (RealFrac a, Integral b) ?
05:25:44 <adu> and cute white bunnies, obviously
05:26:18 <lpsmith> jaspervdj:  I'm going to _guess_ that it has to do with the lazy versus strict variants
05:26:47 <lpsmith> which package?
05:26:48 <jaspervdj> lpsmith: I don't think so, because the build succeeds locally
05:26:53 <chrisdone> bunnies!! ^_^
05:27:02 <jaspervdj> lpsmith: complete log is here http://hackage.haskell.org/packages/archive/hakyll/0.3.1/logs/failure/ghc-6.10
05:27:03 <lpsmith> hmm
05:27:24 <Paczesiowa> jaspervdj: different bytestring version?
05:27:45 <medfly_> I don't think I'd like telepathy. think about trolling
05:27:48 <Paczesiowa> jaspervdj: perhaps hackage uses some library that reexports some types from built-in bytestring library and you can't just use another
05:29:50 <copumpkin> HaskellLove: no
05:30:01 <copumpkin> I'm not your private help service, please stop private messaging me
05:30:04 <Paczesiowa> jaspervdj: I think this kind of errors were pretty popular back in the day of some bytestring upgrade, ask dcoutts
05:30:16 <copumpkin> (I'm busy right now, and don't like being put on the spot)
05:30:25 <HaskellLove> copumpkin ok
05:30:36 <jaspervdj> dcoutts: /poke, you here?
05:31:56 <copumpkin> HaskellLove: a fromIntegral will probably help though
05:32:34 <lpsmith> jaspervdj:  it builds fine on my machine
05:32:42 * lpsmith shrugs
05:33:47 <jaspervdj> lpsmith: well, it's not an absolute priority to get it built on hackage but it could be nice because of the documentation
05:33:55 <lpsmith> yeah, I agree
05:35:14 <copumpkin> ooh hackyll
05:35:19 <chrisdone> ahh. O fprgpt tjta tJaddpcl bpldfd ngoe ngakng docuenmnation
05:35:30 <ane_> uh
05:35:31 <chrisdone> ahh. I forgot that Haddock builds before making documentation
05:35:42 <HaskellLove> copumpkin fromIntegral like this: isSquare n = (snd (properFraction (fromIntegral (sqrt n)))) == 0 ?
05:35:47 <ane_> keyboard displacement :)
05:35:52 <medfly_> HaskellLove: needz less parens
05:35:55 <chrisdone> =)
05:35:56 <lpsmith> honestly,  getting documentation together takes far more fidgeting around than it should take.
05:35:59 <copumpkin> HaskellLove: I wouldn't expect that to work, but if it does, sure :P
05:36:08 <HaskellLove> still same error
05:36:21 <copumpkin> lpsmith: well that looks like a general error
05:36:30 <chrisdone> lpsmith: it seems like Haddock could build a lot of documentation just from the source. not entirely sure for what parts of the process it needs to compile the source
05:36:32 <copumpkin> jaspervdj: I'd imagine one of your dependency version constraints might not be strict enough
05:36:59 <lpsmith> haddock uses the GHC api and the GHC type checker
05:37:04 <jaspervdj> copumpkin: okay, I'll play around with those
05:37:05 <cloudhead> man the computer language shootout makes haskell look really ugly
05:37:07 <lpsmith> it's a new feature
05:37:24 <copumpkin> jaspervdj: maybe not though
05:37:33 <lpsmith> new as of a couple years ago anyway
05:37:35 <copumpkin> would anyone support a movement for simpler URLs on hackage?
05:37:41 <copumpkin> I hate the complex URLs
05:37:42 <lpsmith> sure
05:37:59 <lpsmith> I don't get why there is /package  and /packages
05:38:15 <HaskellLove> isSquare n = (snd  $ properFraction (fromIntegral (sqrt n))) == 0  there we go litle cleaner, but why does it not work oh whyyy?
05:38:26 <copumpkin> HaskellLove: because it's wrong?
05:38:38 <copumpkin> #ty sqrt
05:38:41 <lunabot>  forall a . Floating a => a -> a
05:38:48 <copumpkin> HaskellLove: try writing the type for isSquare if you still can't see it
05:38:52 <chrisdone> cloudhead: turn your head on its side and then all those # and #pragmas are pretty
05:39:01 <lpsmith> Doubles are Floatings,   not RealFracs
05:39:20 <lpsmith> ok
05:39:54 <lpsmith> So haddock is now tied to a specific version of GHC
05:41:00 <jaspervdj> oh wait, the template library I use fails itself... that could be the cause, right?
05:41:11 <HaskellLove> copumpkin i just dont get it man
05:41:22 <copumpkin> HaskellLove: what type does isSquare have?
05:41:25 <cloudhead> chrisdone: is this standard haskell? or an extension?
05:41:44 <HaskellLove> copumpkin well i can't do :t on it, because it does not work
05:41:53 <lpsmith> But haddock isn't given a versioned name itself
05:41:55 <chrisdone> I'm not sure actually. it looks like GHC extensions but I don't know
05:41:57 <copumpkin> HaskellLove: um, I mean what type do you want it to have...
05:42:10 <merijn> HaskellLove: He means: Think and try to write down what type you want it to have/think it should have
05:42:31 <lpsmith> that, among other things, has caused endless pain when trying to have nice usable documentation and multiple versions of GHC
05:42:48 <HaskellLove> Int->Boolean
05:43:06 <lpsmith> HaskellLove, you are using doubles
05:43:11 <copumpkin> HaskellLove: there we go. Except Bool
05:43:22 <copumpkin> HaskellLove: now, what type is n in isSquare n = ... ?
05:43:38 <HaskellLove> Int
05:43:43 <copumpkin> okay
05:43:53 <copumpkin> now, what are you doing with the n?
05:44:50 <HaskellLove> i get the sqrt, then do properFraction and if the second part of the tuple is 0 then return True
05:44:59 <copumpkin> yes, and what is the type of sqrt?
05:45:12 <copumpkin> > sqrt (5 :: Int)
05:45:21 <copumpkin> , sqrt (5 :: Int)
05:45:22 <lunabot>  luna: No instance for (GHC.Float.Floating GHC.Types.Int)
05:45:36 <copumpkin> #ty sqrt
05:45:38 <lunabot>  forall a . Floating a => a -> a
05:45:52 <lpsmith> @hoogle Floating a => Int -> a
05:46:02 <lpsmith> #hoogle Floating a => Int -> a
05:46:02 <HaskellLove> yes but i tried sqrt 25 for example works
05:46:03 <lunabot>  luna: Not in scope: `hoogle'
05:46:05 <copumpkin> so sqrt wants something that is floating-point, and Int isn't floating
05:46:16 <ray> , sqrt 5
05:46:17 <mauke> HaskellLove: 25 is not an Int
05:46:17 <lunabot>  2.23606797749979
05:46:22 <ray> works because 5 is not an Int
05:46:32 <ray> 5 is a Num a => a
05:46:57 <HaskellLove> and Int is below in the hierarchy of Num so...
05:47:10 <copumpkin> Int is an instance of Num
05:47:13 <copumpkin> it is not an instance of Floating
05:47:18 <copumpkin> as I said, fromIntegral
05:47:31 <copumpkin> , sqrt (fromIntegral (5 :: Int))
05:47:32 <lunabot>  2.23606797749979
05:47:32 <ray> integer literals have that implicit fromIntegral
05:47:57 <merijn> HaskellLove: (Num a, Floating a) => a -> Bool is possible, (Int a, Floating a) => a -> Bool is not
05:48:22 <HaskellLove> ok this is getting confusing
05:48:24 <merijn> Since a can't be both Int and Floating at the same time, while Num and Floating are possible at the same time.
05:48:57 <HaskellLove> copumpkin the code i sent i put fromIntegral and you said it ok... ah, i thought you meant it should be before, not for n...anyways...
05:49:13 <copumpkin> HaskellLove: no, I didn't. I actually said I wouldn't expect it to work
05:49:41 <copumpkin> I told you to use fromIntegral, and when you showed us how you used it I said I didn't think that was right
05:49:48 <HaskellLove> isSquare n = (snd $ properFraction (fromIntegral (sqrt n))) == 0 I thought you told me to put it there... nevermind
05:49:55 <copumpkin> I refuse to give you answers directly :P
05:50:06 <copumpkin> so yes, if you ever think I told you where to put something, think again :P
05:50:07 <HaskellLove> ah Joda :D
05:50:30 <HaskellLove> the sun is hot but also wet and cold uyaaaa
05:51:20 <Baughn> Is this some fancy new definition of "cold"?
05:52:50 <HaskellLove> another euler done wohoo
05:54:14 <merijn> HaskellLove: I f you don't get the problem of a not being able to be Int and Floating at the same time while it can be Num and Floating at the same time I suggest you read up on typeclasses. I found the explanations in Real World Haskell (http://book.realworldhaskell.org/read/using-typeclasses.html) and Learn You a Haskell (http://learnyouahaskell.com/types-and-typeclasses) quite good.
05:55:26 <HaskellLove> thanks a lot
05:57:10 <noob> need help
05:57:16 <artobstrel95> Why fact2 is quicker than fact3? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15133#a15133
05:58:48 <voker57> because it gives wrong results
05:59:05 <lpsmith> lol
05:59:14 <lpsmith> yeah,  I would expect it to not be exact
05:59:24 <artobstrel95> Why? I tried it on 1000000 - it gives right result.
05:59:54 <lpsmith> ,   sum (iterate (`div` 5) 10000000)
05:59:58 <lunabot>  Killed.
06:00:13 <lpsmith> ,   sum (takeWhile (/= 0) (iterate (`div` 5) 10000000))
06:00:14 <lunabot>  12499999
06:00:32 <lpsmith> ,   sum (takeWhile (/= 0) (iterate (`div` 5) 1000000))
06:00:33 <lunabot>  1249998
06:00:52 <lpsmith> complete with 1.25 million zeros at the end?
06:01:12 <lpsmith> how do you know the result is right?
06:01:40 <artobstrel95> I compared it with product [1..1000000]
06:03:05 <lpsmith> how long did that take, out of curiousity?
06:04:19 <copumpkin> , product [1..1000000]
06:04:20 <artobstrel95> ok, I used optimized version... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15174#a15174 -- fact
06:04:21 <lunabot>  Stack space overflow: current size 8388608 bytes.
06:04:21 <lunabot>  Use `+RTS -Ksize' to increase it.
06:04:32 <aug_triad> Hi. I would like to use the C library for clustering from http://bonsai.ims.u-tokyo.ac.jp/~mdehoon/software/cluster/software.htm#source, and will therefore need to do some bindings. I have never done that before, so could you give me some advise how to do it?
06:04:35 <copumpkin> , foldl' (*) 1 [1..1000000]
06:04:39 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:04:47 <copumpkin> , foldl' (*) 1 [1..10000]
06:04:48 <lunabot>  2846259680917054518906413212119868890148051401702799230794179994274411340...
06:04:48 <lpsmith> ahh yes,  the limited use of floating point should be exact enough for 10^6
06:04:54 <Paczesiowa> :t guard
06:05:06 <copumpkin> , length (show (foldl' (*) 1 [1..100000]))
06:05:09 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:05:26 <aug_triad> I only need to call tree* treecluster (int nrows, int ncolumns, double** data, int** mask, double weight[], int transpose, char dist, char method, double** distmatrix); and void cuttree (int nelements, Node* tree, int nclusters, int clusterid[]);
06:05:29 <copumpkin> , length (show (foldl1' (*) [1..30000]))
06:05:31 <lunabot>  121288
06:05:41 <voker57> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15175#a15175 -- a test
06:06:16 <chrisdone> computer scientists must have really weak knees. all that accidental bashing into hard desks
06:06:19 <lpsmith> artobstrel95:   Well,  I know there are much more efficient ways of computing factorial,  and that appears to be one of them
06:06:30 <artobstrel95> fact2 uses floating point only for computing the greatest number, but you can calculate it yourself, it won't change
06:06:37 <lpsmith> It looks like you are doing log(n) multplications
06:06:45 <artobstrel95> no
06:07:19 <lpsmith> no?
06:07:51 <artobstrel95> you can replace 2 ^ (truncate (log (fromInteger x) / log 2)) with the greatest power of 2, but not greater than given N
06:08:21 <lpsmith> that's not what I'm talking about :)
06:08:45 <lpsmith> I mean,  once you compute that,  it looks like you are only doing log(y) multiplications
06:08:45 <artobstrel95> sorry :)
06:09:11 <lpsmith> of course,  each number involved is larger
06:09:22 <lpsmith> so the multiplications are a little slower
06:09:33 <lpsmith> but...
06:10:33 <koeien37> http://www.reddit.com/r/programming/comments/aje5b/functional_programming_doesnt_work_and_what_to_do/ I couldn't disagree more
06:11:05 <artobstrel95> But how I can do it? At the end it anyway will form "10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1"?
06:11:36 <merijn> I saw that article, it seemed a bit silly "Functional programming languages aren't very good at thing functional programming languages aren't good at"
06:13:00 <Paczesiowa> "I know this sounds like a tautology, but it's true"
06:13:05 <chrisdone> haha
06:13:20 <lpsmith> James Hague is pretty sharp,  my initial reaction was to downvote it when I saw the title, but I read it and upvoted instead
06:13:25 <lpsmith> I sort of agree
06:13:42 <lpsmith> CTM has a similar kind of argument in it
06:13:42 <chrisdone> lpsmith: what, exactly, do you agree with?
06:14:27 <copumpkin> lpsmith: his article said almost nothing
06:14:32 <koeien37> yeah
06:14:38 <koeien37> but what the article says, i disagree with
06:15:01 <lpsmith> Sometimes side-effects are much more manageable than explicitly threading every last bit of state around;   Peter Van Roy makes a better argument though.
06:15:03 <copumpkin> "what if you have a beautiful functional system and then want to make it not functional? then it's really hard, and functional programming sucks"
06:15:25 <copumpkin> his second point was laughable
06:15:44 <merijn> I mean, if you need a program that tracks a lot of state it seems fairly obvious that functional programming might not be such a good fit for the program. (Note, I'm not even sure there even is such a program that relies on this when approached from the right angle)
06:15:45 <koeien37> it's not a well-written article anyway
06:15:53 <koeien37> merijn: why not?
06:16:19 <lpsmith> artobstrel95:    why is 2^1000000 fast?
06:16:19 <koeien37> Haskell (or FP) just forces you to be more explicit about said state
06:16:33 <chrisdone> Rich Hickey made the same argument in his presentation on Clojure
06:16:39 <lpsmith> after all, it forms 2 * 2 * 2 * ... * 2 in the end ;-)
06:16:49 <koeien37> not necessarily
06:16:51 <merijn> koeien37: Like I said, I'm not entirely convinced you couldn't transform the problem into one that is easily solved using functional programming when you approach it the right way.
06:16:59 <chrisdone> "I make big stateful systems that get stuff done, I can't use Haskell"
06:17:34 <koeien37> merijn: but even if that's true, i agree with spj (i guess?) that Haskell is the world's best imperative programming language
06:17:35 <lpsmith> well, you can use haskell, but depending on the problem it might not be the best option...
06:17:47 <chrisdone> merijn: indeed, I think it's a case of trying to write like algorithms an imperative programmer
06:18:13 <lpsmith> Well, both James Hague and SPJ are using hyperbole in both statements
06:18:21 <merijn> koeien37: I don't believe in the existence of a "best programming language"
06:18:28 <chrisdone> it's for (int i = 0; i < 10; i++) ...; vs. map ... [1..10]
06:18:37 <koeien37> merijn: ok, true
06:18:41 <koeien37> lpsmith: sure
06:19:00 <merijn> I mean, I'm growing to rather like haskell, but if I need a quick script to get something done once I'm still doing it in python...
06:19:04 <lpsmith> One disadvantage to Haskell's imperative features is that they don't pay their own way,   in the terminology of Kent Dybvig:   you have to pay for certain features of a monad up front whether you use them or not
06:19:32 <temoto> :src isJust
06:19:33 <chrisdone> what does that mean?
06:19:38 <temoto> @src isJust
06:19:51 <temoto> how to do that?
06:19:58 <Paczesiowa> even if it's true, it stil has nothing to do with general functional programming
06:20:09 <koeien37> merijn: no no, I really like Haskell for short scripts too :)
06:20:12 <koeien37> but I'm a bit of a nutter
06:20:51 <temoto> Is bot not here?
06:20:53 <lpsmith> Well,  Kent Dybvig has two criteria for language features and implementation:   the implementation of a given feature is no good if it slows down programs that don't use that feature
06:20:54 <chrisdone> koeien37: I tend to open up a Haskell file when I need a script to pull some html files off the next and gloober them, or messing about with files
06:21:21 <koeien37> @botsmack
06:21:21 <lunabot>  :o
06:21:28 <koeien37> preflex: seen Cale
06:21:28 <preflex>  Cale was last seen on #haskell 4 hours, 29 minutes and 41 seconds ago, saying: pretends to?
06:21:34 <koeien37> Cale: lambdabot? :(
06:21:35 <merijn> For example, I'm running a bunch of evolutionary computing simulation right now. I expect to end up with about 100mb of raw data which needs to be transformed from CSV to some analyzable aggregation. Haskell requires me to spend to much time thinking what I want to do. Which I like for a program that needs to be used over and over, but screw that for a throwaway data transformation script :p
06:21:39 <lpsmith> And two,  if he adds an optimization to his compiler,  and the compiler doesn't itself get faster, then he removes it
06:21:42 <koeien37> , 1 + 1 -- for now use lunabot
06:21:43 <lunabot>  luna: parse error (possibly incorrect indentation)
06:21:55 <koeien37> #src isJust
06:21:56 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
06:21:59 <temoto> aha
06:22:01 <koeien37> ...
06:22:13 <temoto> #src map
06:22:14 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
06:22:24 <chrisdone> lunabot's broke toooooo
06:22:26 <chrisdone> bawwww
06:22:30 <temoto> @src isJust
06:22:30 <chrisdone> > "hello?"
06:22:32 <koeien37> yes :(
06:22:38 <lambdabot> isJust Nothing = False
06:22:38 <temoto> :src isJust
06:22:39 <koeien37> how easy is it to set up a \b ?
06:22:40 <lambdabot>   "hello?"
06:22:43 <temoto> that's it
06:22:44 <chrisdone> yay
06:22:52 <lambdabot> Plugin `source' failed with: thread killed
06:22:52 <koeien37> otherwise i can boot up one
06:22:56 <chrisdone> koeien37: just cabal install lambdabot
06:23:41 <koeien37> i'll try to set one up then
06:23:53 <HaskellLove> what is this error when i compile? and in the interpreter the file is loaded ok.../home/user/Desktop/aa:1:0: lexical error at character '\DEL'
06:24:07 <koeien37> you tried aa, not aa.hs
06:24:09 <koeien37> ?
06:24:28 <chrisdone> sounds like it's opening a directory or something, heh
06:24:58 * hackagebot upload: hakyll 0.3.2 - A simple static site generator library. (JasperVanDerJeugt)
06:25:00 <HaskellLove> i compiled with hs and runghc withouth hs
06:25:02 <chrisdone> what's in your file?
06:25:26 <lpsmith> @bots
06:25:26 <lunabot>  :o
06:25:26 <lambdabot> :)
06:25:29 <koeien37> a good
06:25:31 <koeien37> > 1 + 1
06:25:32 <lambdabot>   2
06:25:38 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15177#a15177 chrisdone
06:25:40 <Paczesiowa> HaskellLove: runghc is four sources files, not binaries
06:25:46 <Paczesiowa> *for
06:25:52 <Paczesiowa> *source
06:26:12 <HaskellLove> yeah well the hs thing is not a problem, i did it so far like that
06:26:38 <merijn> runghc on a binary file would probably mean it's trying to parse a binary file and running into a delete ascii char which is obviously an error for source files :p
06:26:48 <merijn> HaskellLove: So you compiled it to the file "aa"?
06:26:58 <Paczesiowa> ./aa
06:26:59 <merijn> Have you tried simply doing "./aa"?
06:27:47 <HaskellLove> ghc --make -O2 "/home/stefan/Desktop/aa.hs";runghc "/home/stefan/Desktop/aa"; aa:1:0: lexical error at character '\DEL'
06:28:04 <merijn> HaskellLove: Don't use runghc on aa, it's an executable binary
06:28:19 <merijn> Of course runghc will crash trying to parse it
06:28:25 <Paczesiowa> HaskellLove: either compile and use ./aa, or runghc aa.hs
06:28:29 <HaskellLove> hmm it worked like that so far
06:28:33 <HaskellLove> let me try it
06:28:50 <Paczesiowa> HaskellLove: you were using runghc aa.hs
06:29:27 <HaskellLove> it works, seems it is calculating... i did not have this issue with 6.8 now i got on 6.10 so i guess this is new
06:31:16 <HaskellLove> as I said with 6.8 i just used it without .hs
06:31:46 <koeien37> was that before or after you compiled?
06:32:48 <HaskellLove> on 6.8 i compiled with .hs but ran without .hs, but now with 6.10 seems i gota have .hs at all times
06:33:18 <merijn> ...
06:33:18 <koeien37> it makes some sense
06:33:32 <koeien37> after all runghc tries to run a Haskell file, not some executable
06:33:43 <merijn> HaskellLove: So you're using "runghc aa.hs" now?
06:33:50 <merijn> Why bother compiling then?
06:34:57 <HaskellLove> yeah with hs now
06:35:09 <HaskellLove> well compiled is faster then interpreted
06:35:22 <mauke> "runghc" is an interpreter
06:35:45 <osfameron> I thought even ghci compiled the code and then ran it?
06:35:54 <osfameron> much like Perl
06:35:56 <HaskellLove> ok this puzzles me now
06:36:10 <mauke> osfameron: yes, but it's not native code (like ghc)
06:36:16 <merijn> HaskellLove: If you compile it is an executable binary you don't need runghc for binaries
06:36:30 <HaskellLove> ghc --make -O2 "/home/user/Desktop/aa.hs" and then i do runghc "/home/user/Desktop/aa.hs" for ghci 6.10
06:36:30 <koeien37> ghci compiles to bytecode
06:36:42 <Paczesiowa> merijn: if runghc finds .o file it probably uses compiled version
06:36:42 <koeien37> HaskellLove: you can omit the first part
06:36:43 <mauke> HaskellLove: that makes no sense
06:36:48 <osfameron> ah
06:36:49 <merijn> HaskellLove: You don't use "rungcc MyProgram.c" for running C programs do you? (If it had existed...)
06:37:09 <merijn> You just run "./MyProgram"
06:37:11 <HaskellLove> Paczesiowa probably yes, so runghc then is not same as interpreter
06:37:30 <Paczesiowa> just like if ghci finds .o file it prefers it than interpreted version
06:37:42 <Paczesiowa> *to
06:38:26 <HaskellLove> Paczesiowa exactly
06:38:54 <merijn> HaskellLove: Yes, but even if that's true why not just run the actual binary?
06:38:55 <Paczesiowa> HaskellLove: but there's always runghc -O2
06:39:20 <maltem> Today's idea for not-so-iteratee I/O - comments? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15178
06:41:43 <lpsmith> preflex,  1 + 1
06:50:45 <mauke> preflex: calc 1 + 1
06:50:45 <preflex>  2
06:54:43 <holmak> If I set up an app so that it can be installed with Cabal, what happens if I reinstall it later with changes?
06:54:56 <holmak> Install a new version, that is
06:54:57 <Baughn> It'll overwrite the old one.
06:55:10 <Baughn> If there are files in the old version that aren't in the new one, those will stick around.
06:55:19 <holmak> Aha, thats what I was wondering
06:55:21 <Baughn> Cabal leaves something to be desired as a package manager, still.
06:55:25 <holmak> Yeah
06:55:49 <holmak> Seems like a nice build system, though
06:56:43 <Baughn> Sure, so long as you don't want anything unusual
07:03:00 <Paczesiowa> :t ""
07:03:01 <lambdabot> [Char]
07:03:05 * Baughn wonders if it's ##C dying or just his standards changing
07:03:13 <Paczesiowa> why not String?
07:03:24 <koeien37> type String = [Char]
07:03:34 <koeien37> they are interchangeable
07:03:40 <Baughn> Paczesiowa: There was nothing there to tell GHC you wanted to refer to it as a string
07:03:43 <Baughn> > "" :: String
07:03:44 <lambdabot>   ""
07:03:47 <Baughn> :t "" :: String
07:03:48 <lambdabot> String
07:03:51 <chrisdone> Baughn: ##c was pretty dire last I checked
07:04:02 <Paczesiowa> Baughn: but why string literals prefer [Char] type?
07:04:06 <Baughn> chrisdone: I used to be a regular, but that was a few years back
07:04:08 <chrisdone> at the time I actually commented "sure has gone down hill here", hah
07:04:10 <aep> hey, are there any javascript engines for haskell? i need to call native functions from js scripts and back
07:04:14 <chrisdone> Baughn: I too
07:04:27 <merijn> Baughn: ##c is just a bunch of mean grumpy old men, last I checked...
07:04:32 <koeien37> aep: :( not that i know of. I would be very interested in a Hasklel -> JS compiler though
07:04:44 <Baughn> Paczesiowa: Because [Char] is the most basic type for it
07:04:49 <Axman6> aep: i believe there are indeed
07:04:56 <aep> most js engines are c++, ans i guess binding to c++ is pretty ugly
07:05:01 <Axman6> there's at least one compiler that compiles haskell to javascript
07:05:03 <Baughn> > "" :: [Int]
07:05:04 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:05:04 <lambdabot>         against inferred type ...
07:05:10 <koeien37> Axman6: YHC iirc
07:05:15 <Axman6> aye
07:05:17 <koeien37> but not really maintained
07:05:25 <yrlnry> Is this already discovered?   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15182#a15182
07:05:32 <aep> um no, i need an engine. for scripts. users dont understand haskell.. :/
07:05:42 <Baughn> yrlnry: Data.Typeable
07:05:46 <Paczesiowa> Baughn: it should be changed, all those [Char] pollute my inferred signatures:/
07:05:47 <koeien37> aep: yeah i understood your problem, i went off to a tangent
07:05:47 <yrlnry> It's a function that returns a string at run time that describes the compile-time type of its argument.
07:05:51 <aep> ah
07:05:56 <yrlnry> Baughn: figures.  Thanks.
07:06:08 <Baughn> yrlnry: GHC even has an extension to derive the instances
07:06:25 <koeien37> yrlnry: what is your use case?
07:06:33 <yrlnry> koeien37: Just screwing around.
07:06:35 <Baughn> Paczesiowa: If you explicitly name it as String, then GHC will remember and use that for errors
07:06:47 <chrisdone> SpiderMonkey is written in C
07:06:48 <Axman6> > tail "f"
07:06:49 <lambdabot>   ""
07:06:59 <Axman6> yrlnry: there's actually nothing wrong with tail "f"
07:07:02 <Baughn> yrlnry: Also look up Data.Data, which is somewhat related
07:07:09 <Baughn> > tail "f"
07:07:09 <lambdabot>   ""
07:07:16 <chrisdone> aep: have you tried that?
07:07:28 <Paczesiowa> Baughn: I know all that, but is there any advantage to defaulting to [Char] type version?
07:07:30 <yrlnry> Axman6: No, but the instance for [] then looks like it tries to take the head of that list.
07:07:48 <yrlnry> Axman6: If typeName actually evaluated its argument, it would throw an exception.
07:07:51 <Baughn> Paczesiowa: There can be any number of type synonyms that expand to [Char]. Which would you prefer it use?
07:07:53 <merijn> Paczesiowa: String is just a synonym for [Char] how would GHC know which is more logical to you?
07:08:08 <Baughn> Paczesiowa: I've got a type Type = String in this code. :3
07:08:09 <koeien37> type Koe = [Char] -- would you now like Koe everywhere?
07:08:22 <aep> chrisdone: good idea thanks
07:08:39 <Paczesiowa> grr, I know all that! I just mean that by default String literals should get String type which is much nicer than [Char]
07:08:41 <Baughn> koeien37: The types are speaking
07:08:48 <Baughn> koeien37: Or alternately dung? Uh.
07:09:19 <Baughn> Paczesiowa: Nobody has had the motivation to special-case that.
07:09:42 <Baughn> Paczesiowa: It'd probably not take very much code, even; rewrite "foo" to ("foo" :: String)
07:09:43 <Paczesiowa> now, that's the argument I can relate to
07:09:52 <maltem> Paczesiowa, maybe it could get confusing if "blub" is printed as "blub" :: String, but tail "blub" :: [Char]
07:10:00 <medfly_> > "" = []
07:10:02 <lambdabot>   <no location info>: parse error on input `='
07:10:05 <Paczesiowa> :t tail
07:10:05 <lambdabot> forall a. [a] -> [a]
07:10:06 <medfly_> > "" == []
07:10:07 <lambdabot>   True
07:10:07 <Baughn> :t tail ("foo" :: String)
07:10:08 <lambdabot> [Char]
07:10:11 <Baughn> Eep
07:10:46 <Paczesiowa> there should be nice simplifier for type synonyms
07:10:52 <Baughn> Paczesiowa: I take that back. Doing it consistently would either be an Evil Hack (tm), or lots of infrastructure for something that'd only be used once.
07:11:07 <koeien37> it doesn't really matter imo
07:11:10 <koeien37> not worth the investment
07:11:20 <Baughn> Paczesiowa: No, you /can't/ do this in general. There is no appropriate rule to replace composed types with synonyms that would always give good results
07:11:39 <Baughn> For one thing, because it's a matter of taste
07:11:50 <Paczesiowa> Baughn: I didn't say it's supposed to be magical. Programmer should help and guide it
07:12:04 * Baughn wouldn't bother
07:12:52 <Paczesiowa> making pretty type error messages is hard:/
07:12:59 <Stinger_> pipe it all through sed and adjust to your hearts content :P
07:13:06 * Baughn thinks [Char] is quite elegant
07:13:16 <koeien37> it's elegant, but slow. But that's another topic :P
07:13:23 * Baughn is an elephant
07:13:52 <chrisdone> Baughn: what did you get for your 5th birthday?
07:13:59 <Stinger_> heh
07:14:14 <Baughn> chrisdone: A stinger missile launcher
07:14:28 <chrisdone> drat!
07:14:51 <Paczesiowa> take it for a test unsafePerformIO drive
07:14:56 <yrlnry> Axman6: Here's a better example of why it's interesting: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15182#a15183
07:16:50 <maltem> yrlnry, the source of the confusion may have been due to your writing (tail "f") instead of "" ;)
07:17:07 <yrlnry> Yeah, I don't know why I did that.
07:17:29 <maltem> Well it would make sense with OverloadedStrings
07:17:36 <maltem> no wait, it wouldn't
07:18:10 <Stinger_> In a monad stack you can use lift to move to different monads, I wonder if you could use generic programming with some sort of tag types to directly lift by name
07:18:10 <holmak> yrlnry: If you are looking to embed scripting, maybe take a look at Lua?
07:18:24 <holmak> Its a C library, so easily FFI-able, if there aren't already bindings.
07:18:36 <yrlnry> holmak: If I am looking to do what with what I should what what what?
07:18:45 <yrlnry> WHAT IS THIS I DON'T EVEN
07:18:46 <jlouis> Axman6: I got it to leech yesterday from rtorrent with opentracker as the tracker here in the lab
07:18:58 <Axman6> jlouis: awesome :)
07:19:19 <Axman6> i haven't had any luck seeding, but i think that;'s ebcause i don;t have the right ports open on my router
07:19:35 <Jafet> The fact that Lua is dead easy to use also means that you can't really use it for much.
07:19:38 <holmak> yrlnry: Bah, I mistook you for someone else in the scrollback. These letter-jumble names throw me off :/
07:19:55 <koeien37> Jafet: why would that follow?
07:19:57 <yrlnry> holmak: whew.
07:19:58 <jlouis> Axman6: you don't need any ports open as it doesn't really listen yet
07:20:00 <chrisdone> yrlnry: help I am not good with monad
07:20:05 <holmak> Sorry about that!
07:20:11 <yrlnry> holmak: no problem!
07:20:27 <Axman6> well, i couldn't seem to seed anyway. all the connections got closed
07:20:38 <yrlnry> holmak: "yrlnry" = "telnet" with left hand in wrong keyboard position
07:20:44 <jlouis> Axman6: probably a bug then :)
07:20:49 <Axman6> :)
07:21:18 <Stinger_> shouldnt it be yr;mry
07:21:25 <jlouis> Axman6: care to try some git-fu with your repository?
07:21:36 <yrlnry> Stinger_: no, only my left hand was misplaced.
07:21:40 <Jafet> koeien, ease times power is a constant, everyone knows that
07:21:53 <maltem> Stinger_, frankly, it should be zrömrz
07:21:59 <koeien37> Jafet: "everyone knows that"
07:22:00 <Stinger_> oh you did have n instead of m
07:22:07 <Axman6> not tonight, i need to be up "early" tomorrow (ie, 10am), and it's already 2:20am
07:22:10 <yrlnry> maltem: where were you when I was picking out an irc nick?
07:22:15 <jlouis> Axman6: ok, fine
07:22:23 * increpare chuckles
07:22:28 <chrisdone> Axman6: where the devil are you, australia?
07:22:29 <Axman6> but, i will do it! i just haven't had the time
07:22:33 <zr> Crap, IRC forbids the ö.
07:22:37 * zr weeps
07:22:37 <Axman6> indeed
07:22:39 <jlouis> Axman6: my sleep rhytm is somewhere in the middle of the atlantic anyway
07:22:43 <chrisdone> oh
07:22:46 <chrisdone> =)
07:23:00 <Axman6> mine's closer to europe :P
07:23:11 <marsh_> mine's on a planet with a 27-hour day
07:23:12 <koeien37> mine's is north american =)
07:23:21 <koeien37> or south american, of course
07:23:22 <Stinger_> heh marsh_ was about to say soemthing similar
07:23:38 <merijn> I run on HST (Hacker Standard Time) which is essentially current time zone -3 :p
07:23:52 <koeien37> I run on coffee
07:24:14 <Axman6> merijn: yeah, sounds like me too
07:24:21 <Jafet> @remember merijn I run on HST (Hacker Standard Time) which is essentially current time zone -3
07:24:22 <lambdabot> Done.
07:24:33 <Axman6> they reckon humans naturally fall into a 30 hour day when they have no access to time or the sun
07:24:55 <Axman6> anyway, sleep time. night all
07:25:06 <Stinger_> yeah same
07:25:15 <absentia> I run on hacker standard time -- which is:  I'm awake until caffeine just can't do it anymore.
07:26:01 * koeien37 hasn't hacked in a while though
07:26:59 <astroboy> Is there a function to check if an element is in a list?
07:27:03 <koeien37> :t elem
07:27:04 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:27:10 <jlouis> x `elem` lst
07:27:10 <koeien37> > 3 `elem` [1..37]
07:27:10 <astroboy> thanks
07:27:11 <lambdabot>   True
07:30:09 <Berengal> What's the action to get the number of worker threads?
07:31:58 <increpare> Berengal: you mean the compile time option?
07:31:59 <jlouis> Berengal: it depends a bit. You have several ways of getting that thing
07:32:10 <jlouis> if you mean code, that is
07:32:18 <Berengal> increpare: I mean the -N#
07:32:42 <Berengal> I seem to recall something about a getCapabilities or something like that, but I can't find it
07:34:22 <Berengal> Also, my program doesn't seem to want to run on multiple cores :/
07:34:54 <copumpkin> Berengal: did you ask it nicely?
07:35:13 <koeien37> -threaded ?
07:35:16 <Berengal> copumpkin: Very nicely, with lots of forkIOs, -Ns and -threadeds
07:35:25 <koeien37> ghc version?
07:35:29 <Berengal> 6.10.4
07:35:45 <koeien37> hmm. I've used that successfully in the past (ghc 6.10.4, amd64, linux)
07:36:00 <Berengal> Me too, which is a bit aggrevating
07:36:00 <holmak_> what OS? I seem to recall having trouble threading with windows-GHC
07:36:07 <Berengal> ubuntu
07:38:01 <marsh_> could you have ended up on a non-SMP kernel?
07:39:35 <Berengal> Unless that's the default in ubuntu these days, no.
07:40:44 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15186#a15186
07:41:50 <marsh_> You might "cat /proc/cpuinfo" just for grins
07:42:19 <copumpkin> you can have multithreading even on a single core
07:42:29 <Baughn> Not very useful, but you can
07:42:54 <marsh_> not the worst IO model in the world
07:42:54 <copumpkin> sure it's useful
07:42:59 <Berengal> I don't want multiple threads, I want 75% CPU utilization. It's cold outside :(
07:43:21 <marsh_> the Adobe flash dll is good for that one
07:43:35 <copumpkin> Berengal: you should probably use pseq, but I doubt it'll change much
07:43:46 <Berengal> marsh_: I want the last 25% for actually doing stuff
07:43:58 <Baughn> Berengal: yes > /dev/null should do nicely
07:44:12 <Baughn> Berengal: Get a quad-core, then do that thrice
07:44:45 <Berengal> Baughn: I have a quad-core, and yak has grown from simply using CPU to doing it properly in haskell now
07:44:53 <Berengal> the yak*
07:44:55 <Berengal> 's wool*
07:44:55 <copumpkin> Berengal: not that it also changes anything, but why not replicateM ?:P
07:45:08 <Berengal> copumpkin: memory consumption
07:45:23 <copumpkin> all those () are heavy, eh
07:45:49 <Berengal> I used last [1..], which worked nicely, but this one uses 60% less memory
07:46:10 <Berengal> (Not that last [1..] ran on more than one core anyway)
07:46:12 <copumpkin> oh, I just mean replicateM for the number of cores
07:46:19 <marsh_> this may be a dumb question but, what in there couldn't be discarded by a smart compiler?
07:46:24 <copumpkin> replicateM cores warmMeUp
07:46:25 <holmak_> is there a #cabal-dev channel?
07:46:51 <chrisdone> http://upload.wikimedia.org/math/3/5/6/3561b6156219901013f5a7d7fb3685db.png
07:46:56 <chrisdone> what on earth do all those math symbols mean?
07:47:00 * Lemmih throws a _ at copumpkin.
07:47:05 <copumpkin> :)
07:47:10 <copumpkin> replicateM_
07:47:18 <chrisdone> god I hate math. can't you use syntax that I can look up?
07:47:25 <chrisdone> what's that upside down U?
07:47:35 <holmak_> i think set intersection
07:47:39 <Baughn> chrisdone: Depends on who you ask. At least the capital Pi is product syntax.
07:47:39 <jlouis> chrisdone: Pr - probability, upside down U: set intersection
07:47:40 <theorbtwo> U is union.  Upside-down U is thus intersection.
07:47:41 <Berengal> Heh, golfing useless code..
07:47:42 <copumpkin> chrisdone: probability of the intersection of all A for i from 1 to n
07:47:47 <jlouis> big Pi .. product
07:47:58 <HaskellLove> is head faster then take 1?
07:48:07 <holmak_> :t head
07:48:09 <lambdabot> forall a. [a] -> a
07:48:11 <holmak_> :t take
07:48:12 <Baughn> HaskellLove: I doubt you'd notice
07:48:13 <lambdabot> forall a. Int -> [a] -> [a]
07:48:21 <copumpkin> Berengal: yep!
07:48:22 <Berengal> Also, SPJ is lying when he says you'd just get a hot box without IO. It's surprisingly involved to heat up a box in haskell
07:48:22 <theorbtwo> Oh.  I'm not sure it is intersection in context, but it's hard to tell without *more* context.
07:48:23 <holmak_> they also have different return types
07:48:23 <chrisdone> ohh
07:48:24 <mercury^> chrisdone: you seem to have independent events of probability 1/2.
07:48:41 <aug_triad> I am trying to make bindings to a C library, and is using the example at http://www.haskell.org/haskellwiki/GHC:FAQ#How_do_I_call_a_C_procedure_from_a_Haskell_program.3F.  When doing the command ghc -lffi -L/tmp/ffi --make Main I get an error saying Undefined symbols. I assume that it is the -L/tmp/ffi that is not right. /tmp/ffi is the path? But if all files are in the same folder and calling ghc from that folder, it should be removed right? But -L
07:48:41 <aug_triad> doesn't work either. What does this -L means?
07:49:06 <Baughn> aug_triad: Just use --make, no ther options
07:49:07 <theorbtwo> Hm.  Is the "forall a." in lambdabot's :t head actually meaningful?
07:49:09 <Baughn> *other
07:49:45 <chrisdone> copumpkin: what does "intersection of all A" mean?
07:49:50 <Baughn> aug_triad: Well, --make -fffi if you don't have a LANGUAGE pragma for the FFi
07:49:57 <increpare> theorbtwo: yeah, in that the forall a might not appear in the head in some circumstance
07:50:03 <copumpkin> chrisdone: I assume A_i is an event or something
07:50:11 <Berengal> theorbtwo: Only when they can appear elsewhere in the signature as well, which requires some extensions
07:50:14 <chrisdone> copumpkin: right, it's a dice roll
07:50:20 <chrisdone> copumpkin: err, a toin coss, sorry
07:50:28 <mercury^> A fair one it seems.
07:50:41 <mercury^> So you toss the coin several times. The outcomes are unrelated.
07:50:48 <mercury^> Or independent.
07:50:54 <copumpkin> a tosser!
07:51:09 <mercury^> Then you want to look at the probability of a specific sequence occurring.
07:51:17 <theorbtwo> Well, it's actually telling you how they are related -- the probability of all of them coming up the same.  Ai is the event that the Ath coin toss comes up head.
07:51:17 <increpare> theorbtwo: by default when you type f :: a->b t means forall a b . a->b, but you can also define a function  (with extensions) f :: (forall a . a) -> b .  Okay, you actually probably *can't* define that function, but you can define functions with signatures *like* that : P
07:51:21 * copumpkin thinks there's another secret list monad
07:51:55 <chrisdone> theorbtwo: oh, I see. probability of them coming up the same
07:52:00 <theorbtwo> chrisdone: Exactly.
07:52:51 <mercury^> It's not just the probability of them all coming up the same.
07:53:00 <Berengal> copumpkin: Logic?
07:53:01 <mercury^> It's the probability of any specific sequence occurring.
07:53:03 <chrisdone> mercury^: but of any two?
07:53:04 <Lemmih> aug_triad: ghc --make -XForeignFunctionInterface *.c Main.hs
07:53:07 <chrisdone> oh
07:53:23 <chrisdone> :/
07:53:36 <copumpkin> Berengal: ordered lists and monotonic functions (for the functor)
07:54:00 <theorbtwo> mercury^: Well, that works out the same, but the equation giving there is for them all happening the same, otherwise A sub i changes definitions in the middle...
07:54:20 <Baughn> mercury^: Of course, in real life nothing is ever unrelated
07:54:22 <chrisdone> mercury^: so you've got Ai which is the sequence, and the probability of any two sequences intersecting?
07:54:41 <mercury^> No.
07:54:49 <HaskellLove> out of memory error http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15187#a15187 :(
07:54:56 <aug_triad> @Baughn: it doesn't work with ghc -lffi --make Main. But ghc --make -XForeignFunctionInterface *.c Main.hs as @Lemmih said, worked. How can that be?
07:54:56 <lambdabot> Unknown command, try @list
07:55:05 <Baughn> aug_triad: I didn't say -lffi
07:55:08 <theorbtwo> Speaking of, stupid newbie question -- is there any simple way of getting the Nth element out of an array in haskell?  I suppose elem n list = tail take n list, but is there a *simple* way?
07:55:16 * chrisdone whines
07:55:17 <Baughn> theorbtwo: !!
07:55:26 <increpare> HaskellLove: probably has something to do with [5..999999999] : P
07:55:27 <Baughn> theorbtwo: Well, for lists. For arrays it's !
07:55:40 <copumpkin> Berengal: so join would be merging ordered lists
07:55:43 <increpare> HaskellLove: reverse has to read all elements in a list i think
07:55:46 <Baughn> theorbtwo: Also, you should realize that !! is /slow/. O(n), to be exact.
07:56:03 <HaskellLove> so how to do a cheap reverse then
07:56:04 <mercury^> chrisdone: http://www.math.uconn.edu/~bass/lecture.html
07:56:17 <copumpkin> \slow\ != /slow/
07:56:26 <increpare> HaskellLove: Can you do [999999999,999999997..5]?
07:56:30 <mercury^> Download "Measure and Integration theory" as well as "Probability theory".
07:56:49 <increpare> HaskellLove: that *migh* fix it
07:56:57 <chrisdone> alright
07:57:03 <HaskellLove> no you cant
07:57:24 <increpare> > [10,8..0]
07:57:25 <lambdabot>   [10,8,6,4,2,0]
07:57:30 <increpare> HaskellLove: Why not?
07:57:42 <aug_triad> @Baughn: it doesn't work with ghc --make Main either
07:57:42 <lambdabot> Unknown command, try @list
07:57:54 <Baughn> aug_triad: Which is not what i said either.
07:57:57 <chrisdone> a collection's a set of sets?
07:58:23 <theorbtwo> Baughn: Hm.  It being O(n) probably has something to do with why Real World Haskell hasn't told me about it yet, but it does seem like it should give it and say (but don't do that becase ...)
07:58:46 <Baughn> theorbtwo: Should be obvious when you know a linked list is a.. linked list, though
07:58:56 <chrisdone> mercury^: do these lecture notes come with audio to explain what it all means?
07:59:01 <Baughn> theorbtwo: And I don't think I've ever used !!, it just doesn't come up much.
07:59:04 <HaskellLove> for [99..0]  i get [] but i tried [99,98..0] works, wierd
07:59:04 <theorbtwo> Baughn: Yeah, but it hasn't told me that yet either.
07:59:13 <mercury^> chrisdone: no, you just read what it all means.
07:59:14 <Lemmih> aug_triad: Try to understand each flag in the command line.
07:59:20 <shambler> HaskellLove, default step is 1
07:59:24 <shambler> +1
07:59:28 <shambler> afair
07:59:37 <increpare> HaskellLove: yeah what shambler said.
08:00:01 <aug_triad> @Baughn: yes, I am stupid :). I got it :)
08:00:01 <lambdabot> Unknown command, try @list
08:00:11 <chrisdone> ho ho ho, surely you must be joking mr mercury
08:00:56 <chrisdone> I can't even copy and paste half of this mathematical crap to research what it's supposed to mean
08:01:14 <increpare> chrisdone: what mathematical crap is this?
08:01:31 <theorbtwo> chrisdone: Can you point at the original wikipedia article which had that image embedded in it?
08:01:34 <chrisdone> do I have to visually describe it? god I hate it
08:01:44 <theorbtwo> I want to teach you a useful little trick.
08:01:49 <chrisdone> theorbtwo: http://en.wikipedia.org/wiki/Gambler%27s_fallacy#An_example:_coin-tossing
08:02:05 <increpare> chrisdone:Oh, right.
08:03:12 <theorbtwo> chrisdone: Hit the edit link above that section.  That'll show you the TeX source of that bit of math, which is slightly more googleable.
08:03:43 <chrisdone> ahh
08:04:24 <theorbtwo> In any case, the text above that formula gives a pretty good description of what it means.
08:05:52 <theorbtwo> Also, the article generally sucks; it never points out that in the real world, there is a nonzero probability that the coin simply isn't fair.
08:06:24 <Baughn> And, in fact, a run of twenty heads would dramatically increase the probability that it /isn't/ fair
08:06:45 <marsh_> fairness is not statistical
08:07:03 <increpare> Baughn: right, casino's tend to put slot machines in for rigorous testing after a single big dole-out
08:07:15 <marsh_> your adversary may be intentionally choosing whether or not the coin is fair
08:07:19 <Baughn> marsh_: Any lack of knowledge can be treated statistically
08:07:28 <Baughn> Including lack of knowledge about your opponent's intentions
08:07:40 <theorbtwo> marsh_: OTOH, they might have just picked a coin out of their pocket that was worn unevenly.
08:08:16 <theorbtwo> ...or wasn't struck properly... or, for that matter, wasn't designed properly -- IIRC, a few early versions of the US state quarters weren't fair.
08:08:23 <marsh_> Only if you "know" enough to characterize their abilities, which isn't really lack of knowledge
08:08:43 <Jafet> No real-life coin is fair
08:09:00 <Philonous1> Unfortunately a perfect coin could still just produce 20 heads in a row. It's a rather unfortunate property of true randomness that it's untestable
08:09:01 <Baughn> I don't think fairness is a major design criteria for coins
08:09:11 <Jafet> Well, it should be!
08:09:20 <increpare> Philonous1: actually it is statistically tetable
08:09:31 <increpare> Philonous1: (testable) innit?
08:09:32 <Baughn> You just need a lot more than 20 throws
08:09:44 <Philonous1> increpare: No it is not. There is always a chance that your source of randomness will produce data that fails the test
08:09:45 <Jafet> Philonous, what did you say is untestable?
08:09:50 <theorbtwo> marsh_: Think of it this way -- of all US quarters in circulation, a certian portion aren't fair.  You pick a US wuarter out of your pocket, toss it 200 times, and get 200 tails.
08:09:52 <chrisdone> I suppose math notation is like reading caligraphy. I'm glad programming languages didn't go the crazy math route once computers were good enough
08:09:56 <increpare> Philonous1: that's why I said 'statistically'
08:10:03 <Baughn> Philonous1: At some point that probability gets low enough to characterize as certainty
08:10:09 <increpare> Philonous1: one can still construct confidence intervals in various models/&c.
08:10:24 <theorbtwo> Which is more probable, that you got a non-fair coin, or it is a fair coin and you happened to get 200 tails in a row out of it?
08:10:31 <yrlnry> chrisdone: seen Agda?
08:10:32 <maltem> Probability vs. certainty is one of the crazy things about thermodynamics, too
08:10:37 <Philonous1> Even worse: A source of true randomness is even expected to fail randomness-tests occasionally
08:10:45 <increpare> chrisdone: or, worse, epigram : )
08:11:03 <yrlnry> I really liked epigram.
08:11:11 * copumpkin loves agda
08:11:19 <chrisdone> yrlnry: at least I can paste Agda, it's just plain-text. not a diagram
08:11:20 <increpare> Philonous1: You're being very quite absolutist here.  It's expected to, but only very very rarely.
08:11:23 <yrlnry> I also really liked APL.
08:11:25 <Baughn> Philonous1: Not if the test is long enough to make the probability of that lower than the probability that all the atoms in your hostess' underwear spontaneously jump three feet to the left without the application of tea
08:11:31 <theorbtwo> Philonous1: Every now and again, the tests for perl's rand() function get twiddled, because they were taking too long, or they were failing due to bad luck too often.
08:11:32 * hackagebot upload: SimpleAES 0.1 - Fast AES encryption/decryption for bytestrings (DavidHimmelstrup)
08:11:34 <Philonous1> increpare: Yes of course, you can do that. But My point was just that it's bogus to say a coin produced 20 heads, therefore it's not a fait coin
08:11:41 <Jafet> A source of true randomness passes any randomness test. A sample from that source may not.
08:11:51 <Jafet> The probability decreases with the length of the sample.
08:11:53 <Baughn> hackagebot: ..what, another one?
08:12:00 <Baughn> Who's david himmelstrup?
08:12:06 <marsh_> we can know what the probability is of a 'fair' coin exhibiting at least as extreme a pattern
08:12:07 <copumpkin> lemmih
08:12:10 <Jafet> Baughn, use all together for maximum security
08:12:12 <Baughn> And why didn't he just send me a patch?
08:12:19 <copumpkin> > reverse "Lemmih"
08:12:20 <lambdabot>   "himmeL"
08:12:25 <Baughn> Lemmih: Oy.
08:12:27 <chrisdone> Baughn: Not Invented Here
08:12:34 <theorbtwo> Sadly, we can't just get rid of it because there are a fair number of ways to misconfigure perl so that the rand() function so that it will only give numbers between 0 and .5 instead of 0 and 1, for example.
08:12:35 <Baughn> chrisdone: He's using my frakin' code!
08:12:38 <chrisdone> haha
08:12:43 <chrisdone> Not Credited Here
08:12:45 <marsh_> If it's 200 tails in a row, common sense says it's not fair
08:12:49 <Baughn> chrisdone: He's even crediting me
08:12:55 <chrisdone> @_@
08:13:01 <Baughn> Yep
08:13:14 <copumpkin> @hackage SimpleAES
08:13:15 <lambdabot> http://hackage.haskell.org/package/SimpleAES
08:13:21 <Jafet> Maybe he's stress testing the hackage servers. You never know.
08:13:28 <yrlnry> theorbtwo: Memoize.pm has tests that make sure it's working by running a slow invocation of a recursive fibonacci function, then memoizing the function and making sure it is now fast.
08:14:03 <yrlnry> theorbtwo: The tests used to print out a message apologizing for the slow tests.  But people were always complaining about it and wanted to take them out.  So I removed the warning and the complaints ceased.
08:14:22 <theorbtwo> yrlnry: That's wonderful!
08:14:23 <increpare> Philonous1: whether or not you could would depend on your other assumptions (if you had done tests to check the proportion of biased coins, say ).  But it would take some reseach to say anything more about such a coin, fr sure.
08:14:30 <marsh_> Is anybody using ghc-6.12.1-x86_64-unknown-linux-t.tar.bz2 ?
08:14:49 <Heffalump> I think that's the one to use on Fedora/Redhat
08:14:50 <Baughn> @ask Lemmih I have no objections whatsoever to including useful changes in the AES package, so why didn't you /ask/ me instead of forking? -_-
08:14:50 <lambdabot> Consider it noted.
08:15:06 <chrisdone> he's forking mad
08:15:14 * Baughn sticks chrisdone on a fork
08:15:19 <yrlnry> theorbtwo: I got the idea from Emacs.  I had heard that the same thing happened with Emacs's "collecting garbage" messages.  People complained that it was taking too long to do garbage collection.  So FSF eliminated the messages and the "problem" went away.
08:15:23 <chrisdone> =(
08:15:25 <Lemmih> Baughn: You wrote AES?
08:15:25 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
08:15:32 <Baughn> Lemmih: Aye
08:15:34 <Lemmih> @messages
08:15:34 <lambdabot> Baughn asked 44s ago: I have no objections whatsoever to including useful changes in the AES package, so why didn't you /ask/ me instead of forking? -_-
08:15:46 <Jafet> There was once someone reported a bug in a perl function, Larry responded by changing the man page for the function
08:15:57 <Twey> Jafet: Hahaha
08:16:20 * theorbtwo shrugs.  That one happens all the time.
08:16:22 <Baughn> Lemmih: Frankly, I think hackage is crowded enough already..
08:16:22 <chrisdone> The function is fine, Winston.
08:16:22 <Twey> That's Perl for you
08:16:29 <Twey> The function was probably so unreadable that it was the only route available apart from a total rewrite
08:16:36 <theorbtwo> Sometimes for good reasons, oftentimes for bad ones.
08:16:41 <Lemmih> Baughn: Well, I've gutted quite a few things.
08:17:21 <theorbtwo> Twey: Or the behavior was relied upon by external programs that he didn't want to break, or the behavior was as intended, but the documentation was poorly written, or the values being passed were out of range, but the manpage didn't note the range of the function.
08:17:29 <Baughn> Lemmih: Even so. It's not like anyone's using it yet.. it'd probably make more sense to cooperate.
08:17:32 <Baughn> Oh well.
08:17:51 <Twey> theorbtwo: It's a possibility, but… :þ
08:17:56 <Lemmih> Baughn: By all means, let's merge. What's your repo url?
08:18:04 * Baughn sweatdrops
08:18:05 <Philonous1> increpare: I chose my words badly. Of course randomness is testable. It's just not testable conclusively. And people tend to assume that some things are not possible with true randomness (like getting 20 heads). I apologize.
08:18:18 <Baughn> Lemmih: I'll have to make one. I've got a git repo, but it's local-only.
08:18:40 <Lemmih> Baughn: Oh, git. Right. Hm.
08:18:49 <copumpkin> zomg git
08:19:00 <jlouis> mmm, git
08:19:07 <jlouis> darcs is toast :)
08:19:16 <Baughn> Lemmih: I've also got a (currently somewhat inefficient) AES-based random number generator that should probably be in it
08:19:24 <Heffalump> jlouis: hmph!
08:19:40 <jlouis> Heffalump: jlouis the sensible troll strikes again. Beware!
08:19:46 <Jafet> ((And we're accusing Lemmih of NIH?))
08:19:57 <increpare> Philonous1: Yeah we were talking different notions of truth/knowledge.
08:20:01 <Heffalump> darcs really will need to acquire a good git bridge soon
08:20:04 <marsh_> If everyone on Earth flipped a fair coin at least 20 times in their life, probably at least 7000 people have had 20 consecutive heads
08:20:13 <Lemmih> Jafet: NIH?
08:20:56 <increpare> Baughn: if I didn't have no reason to not love you I might start a project with a dependency on lemmih's fork  right now for a lark : P
08:21:41 <jlouis> Heffalump: that would be cool, but perhaps they are too different beasts to get it good
08:21:56 <Teggy> marsh_, that's crazy talk.  Most of them would have bought a bottle of beer before the 20th flip.
08:22:03 <copumpkin> Lemmih: not invented here
08:22:09 <Baughn> Lemmih: http://github.com/Baughn/AES/ <- Right.
08:22:39 <Heffalump> I have some ideas, but I need to learn how git works properly. And get darcs rebase done first.
08:23:10 <theorbtwo> ghci++ # Does what I mean when I hit ^C in order to stop it trying to print an infinite list.
08:23:31 <increpare> I started using git last week - moved from mercurial (for no real reason other than I was starting a new project and had done a system wipe and so was without HG).  It's been very pleasant so far.
08:24:00 <jlouis> Heffalump: the repository format is quite unsophisticated actually. Many things (renames for instance) are heuristics on top of that simple base format
08:24:59 <jlouis> and it is not delta-based but based on fs-snapshots more or less
08:25:10 <Heffalump> it's how commits and merges are represented that I need to understand properly, and also how much data is stored in each clone
08:25:50 <jlouis> a clone (normal) has all of the repository, so that one is easy
08:26:03 <theorbtwo> jlouis: That was the hard bit, for me, about understanding git.  After I got that through my thick skull, everything else made sense again.
08:26:35 <Heffalump> jlouis: but git can store multiple branches in one repo, right?
08:26:49 <Baughn> Yes, kind of
08:27:03 <Baughn> A git "branch" is really just a (name, patch pointer) tuple
08:27:14 <marsh_> is there _any_ distributed RCS that handles having big files in your repo well?
08:27:19 <Baughn> git. :)
08:27:21 <theorbtwo> git can store any number of snapshots, each of which can be related to each-other in any way, or not at all.
08:27:30 <marsh_> I.e., doesn't copy everything everywhere every time?
08:27:34 <jlouis> Heffalump: yes. snapshots are ordered by a DAG og a "yellow stick it note" at one element of the DAG designates the branch
08:27:36 <chrisdone> someone people use git in their home directory
08:27:46 <jlouis> and a
08:27:54 <jlouis> my danish hits again :/
08:27:59 <chrisdone> marsh_: well git just copies the binary changes on binary files
08:28:06 <theorbtwo> You can not only have multiple branches in the same repo, but completely different projects, if you want to for some obscure reason.
08:28:17 <Baughn> marsh_: For one that maintains a pristine version (like darcs), it should be possible to use BTRFS's COW file clones at least
08:28:26 <theorbtwo> (FSVO any, of course -- eventually you will run out of disk space.)
08:28:26 <Baughn> That would be nifty
08:28:50 <Heffalump> what I'd like is to be able to go back to the original checkin to make the equivalent darcs patch, and then have darcs simulate the git merges
08:28:50 <copumpkin> anyone have an opinion on an irc.haskell.org to avoid the freenode-associated woes?
08:28:52 <Jafet> Real hackers have spare hotswap bays
08:29:14 <marsh_> is it practical to keep the big old historical files on a server unless you actually need them in your workspace?
08:29:16 <jlouis> copumpkin: you mean the netsplits?
08:29:35 <Heffalump> copumpkin: -1 from me, freenode is quite reliable overall and a lot of people are on multiple channels. Also, we made an abortive effort to move over to OFTC a long while back around the time of all the lilo politics and it never took off.
08:29:49 <copumpkin> jlouis: and the "zomg I saw this channel near the top of the /list on freenode and I wanna chat about a/s/l" people
08:30:13 <jlouis> copumpkin: Oh, I like those
08:30:18 <jlouis> @vixen asl?
08:30:22 <Jafet> I've never seen those.
08:30:39 <Heffalump> they're pretty rare
08:30:45 <Baughn> Lemmih: ..I'm afraid I haven't been very good about updating the git repo for this one.
08:30:47 <Heffalump> and I think we get a lot of passing trade as it were.
08:30:54 <copumpkin> Heffalump: most clients make very little distinction between multiple channels and multiple servers, it seems
08:31:01 <copumpkin> ah well
08:31:11 <i_am_neuron> Folks, when trying to instantiate a typeclass with a data type, the type inference fails on functions that use it. Here it is: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15189#a15189 Any advice?
08:31:30 <jlouis> copumpkin: also, I think Freenode will have a less bumpy ride when they move to the new server base, soonish.
08:32:13 <chrisdone> i_am_neuron: you're instantiation with an EchoProtocol for an instance of EchoFactory..
08:32:41 <Saizan> i_am_neuron: the buildProtocol's type doesn't mean what you think it means
08:32:42 <chrisdone> instance Factory EchoFactory where
08:32:42 <chrisdone>     buildProtocol f p = EP
08:32:42 <chrisdone> EP :: EchoProtocol
08:32:52 <copumpkin> whoa, did I just see factory in haskell?
08:32:56 * copumpkin rubs his eyes
08:33:12 <Saizan> chrisdone: buildProtocol's has 2 type variables in its type
08:33:21 <jlouis> Design Patterns?
08:33:33 <i_am_neuron> copumpkin: ah come on!
08:33:35 * marsh_ groans
08:33:35 <maltem> Heffalump, as long as you're only doing pull, add, commit, and log, git works quite well-behaved
08:33:36 <maltem> The checkout semantics are baffling at times, though
08:33:36 <maltem> Oops, did I say something offending?
08:34:03 <chrisdone> oh woops
08:34:17 <pikhq> Well, git(1) isn't exactly intended as a nice UI, it's intended as a backend.
08:34:31 <i_am_neuron> Saizan: can't get what you mean by this
08:34:33 <pikhq> It's been retrofitted to be a tolerable UI, but... Bleh.
08:34:36 <Saizan> i_am_neuron: buildProtocol :: (Protocol b) => EchoFactory -> PortID -> b <- this type means that the caller can choose any type it wants for 'b' and the implementation must be able to support it
08:34:42 * hackagebot upload: AES 0.2.5 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
08:34:43 <Baughn> Lemmih: Well, since AES is acquiring a fair number of dependencies, it might make sense to have a SimpleAES package with just the core
08:35:17 <i_am_neuron> Saizain: aha, and in my case it only supports EchoProtocol, right?
08:35:29 <Saizan> i_am_neuron: right, because you return EP
08:35:31 <i_am_neuron> Saizan*, sorry
08:35:45 <i_am_neuron> Saizan: is there an easy way to fix that?
08:36:04 <Lemmih> Baughn: Are you sure it's a good idea to use the 'random' package?
08:36:31 <Baughn> Lemmih: I'm using it for the RNDGen class, not for its implementation
08:36:49 <Heffalump> sounds like it'd benefit from splitting
08:37:09 <Saizan> i_am_neuron: you could use a multi parameter typeclass, i.e. class Protocol b => Factory a b where ...; and then instance Factory EchoFactory EchoProtocol where ..;
08:37:12 <Baughn> Probably. I'll implement that if I need to, or someone sends mea patch. ;)
08:37:13 <Lemmih> Baughn: Also, your 'crypt' is too strict for lazy bytestrings and it exposes the internal structure of said strings.
08:38:17 <Saizan> i_am_neuron: it looks like using typeclasses here is not a good solution, though, but feel free to experiment
08:38:19 <i_am_neuron> Saizan: ooh. Isn't there a way to say that caller is ready to accept any Factory, whatever callee supports?
08:38:48 <Saizan> i_am_neuron: any Protocol you mean?
08:38:48 <Lemmih> Baughn: 'x == y => crypt x == crypt y' is a nice property to have, even it means a little copying.
08:39:02 <i_am_neuron> Saizan: yeah, Protocol, sorry
08:39:12 <Saizan> i_am_neuron: yes, with an existential
08:39:33 <Baughn> Lemmih: ..or quite a lot of copying. I'd agree that it's nice, and I wound up using the IO interface anyway.
08:39:53 <Saizan> i_am_neuron: data AnyProtocol = forall a. Protocol a => AnyProtocol a; then you have buildProtocol :: a -> PortID -> AnyProtocol
08:40:16 <Saizan> i_am_neuron: and the implementation is "buildProtocol f p = AnyProcotol EP"
08:40:26 <i_am_neuron> Saizan: ahaa, I see
08:40:31 <Baughn> Lemmih: It shouldn't be necessary to copy the entire chunk, so long as we only pass in n*16-byte long pieces
08:41:07 <Saizan> i_am_neuron: though once a value is wrapped in an existential type like that you can't downcast it back, unless you also add a Typeable constraint
08:41:24 <chrisdone> Saizan: wuah, waht. I've never seen that trick
08:42:01 <Saizan> chrisdone, i_am_neuron: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
08:42:05 <chrisdone> Saizan: does that require an extension to embed the a on that side?
08:42:31 <i_am_neuron> Saizan: thanks for this advice. Speaking of typeclasses, I've rasied the question on this channel a couple of days ago about what to use to model my subject domain, and after refactoring some of the typeclasses into records of functions, I still think that for Factory it's better to keep it as a typeclass
08:42:31 <Saizan> chrisdone: yes, you need {-# LANGUAGE ExistentialQuantification #-}
08:42:50 <i_am_neuron> Saizan: the reason is that I want to allow 3rd parties to ad their own factories
08:42:52 <sshc> does GHC have a preprocessor?
08:43:03 <Baughn> sshc: CPP.
08:43:15 <i_am_neuron> Saizan: do you think it's reasonable?
08:43:18 <sshc> Baughn: CPP doesn't parse {-# ... #-}
08:43:19 <increpare> sshc: also, to some degree, template haskell counts.
08:43:22 <Baughn> sshc: (Optionally. It's off by default.)
08:43:42 <Baughn> sshc: No, {-# is parsed by GHC itself
08:44:02 <sshc> Baughn: is it part of the Haskell standard?
08:44:13 <Baughn> sshc: It's part of the haskell'09 standard
08:44:23 <sshc> Baughn: I can't really google symbols.  Can you point me to any resources?
08:44:45 <Twey> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
08:45:11 <adekoba> I'm building a cabal package and I keep getting this error:  ghc-6.10.4 requires old-time ==1.0.0.2 however old-time-1.0.0.2 was excluded because ghc-6.10.4 requires old-time ==1.0.0.3
08:45:32 <adekoba> why is this happening / how can I fix this?
08:45:45 <Saizan> i_am_neuron: well, it depends on the overall architecture of your program what's more appropriate, with a typeclass the clients will have to supply you their factory type somehow, and maybe you could just accept a function in the same spot instead, but i can see how the first case can be more convenient, since types get naturally threaded along by type checking
08:45:46 * Baughn is tempted to claim that GHC 6.10 is out of time
08:46:00 <Raynes> I hate those contradictory error messages.
08:46:13 <sshc> Baughn: are pragmas specific to GHC or a select few of other compilers?
08:46:20 <chrisdone> Baughn: out of time?
08:46:26 <Baughn> chrisdone: A bad joke, I know.
08:46:34 <Baughn> sshc: As I said, they're now part of the Haskell'09 standard.
08:46:48 <increpare> sshc: depends on the pragmas.  Some of them are in teh standard, some are GHC specific.
08:47:03 <pikhq> Baughn: s/09/10/
08:47:04 <Baughn> sshc: Hm. Actually, it's "Haskell 2010"
08:47:05 <sshc> Baughn: sorry, I somehow skipped over that
08:47:06 <Baughn> Seems a bit premature
08:47:14 <increpare> sshc: think the docs should point out which is which on a case-by-base basis.
08:47:36 <Saizan> adekoba: this should be the same problem http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
08:47:41 <Baughn> The language pragma itself is now standard, so any compiler will tell you if it doesn't support a particular one
08:47:48 <sshc> increpare: thank you for answering my question I almost asked you
08:47:55 <pikhq> Baughn: Bizarrely, such things are named for the year to come. It's not just Haskell being bizarre, but a decent-sized subset of humanity.
08:47:57 <HaskellLove> zipWith (\x,y -> x `mod` y ==0) subNumbers [2,3,5,7,11,13,17] what is wrong here?
08:48:18 <i_am_neuron> Saizan: I see. I had more or less the same reasoning
08:48:37 <adekoba> Saizan: thanks
08:49:50 <chrisdone> Saizan: originally I thought existentials where kind of an unstrict hack onto the type system, but it actually seems like a very tidy way of being generic while forcefully restricting what you can do
08:50:11 <sshc> increpare: which docs?
08:50:33 <increpare> sshc: the docs that were linked to above
08:50:35 <sshc> increpare: GHC's docs on pragmas don't seem to mention which ones are part of the standard
08:50:41 <increpare> (by twey)
08:51:08 <Twey> sshc: None of them are part of the standard
08:51:22 <increpare> Twey: the noinline one is
08:51:27 <Twey> Really?
08:51:34 <sshc> Twey: none of the pragmas listed on the page or no pragmas at all?
08:51:35 <Twey> Which standard?  Surely not '98?
08:51:38 <increpare> Twey: "NOTINLINE is a synonym for NOINLINE (NOINLINE is specified by Haskell 98 as the standard way to disable inlining, so it should be used if you want your code to be portable)."
08:51:48 <Twey> Huh.  Okay.  I take that back, then.
08:51:57 <doserj> http://www.haskell.org/onlinereport/pragmas.html
08:52:15 <increpare> doserj: aha the ungooglable doc  - excellent : )
08:52:35 * increpare didn't know that specialization was in the standard, though it was ghc-only right now
08:52:39 <sshc> I first want to learn what the standard pragmas are before I learn GHC's
08:52:41 <chrisdone> Saizan: if I've got a heterogeneous list, [SB (), SB 5, SB True], is it possible to extract the contents? I suppose you would need some kind of class ToType a where toInteger :: a -> Integer; toChar :: a -> Char, etc. and maybe a TypeOf class, etc.
08:53:00 <increpare> sshc: well it shouldn't take long, because there are only two : P
08:53:13 <increpare> (well, three)
08:53:35 <Twey> chrisdone: It's called Data.Typeable ;)
08:53:45 <chrisdone> Twey: I'm aware of that
08:53:45 <chrisdone> Saizan: disregard that I'll just read the article
08:53:52 <sshc> increpare: at the bottom of page linked by doserj I see "Haskell '98 report"
08:53:53 <Saizan> chrisdone: if you add a Typeable constraint inside the existential you can then try to cast it to different types
08:53:57 <Saizan> ?type cast
08:53:58 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
08:54:12 <increpare> sshc: right, that's the standard for h98
08:54:14 <sshc> increpare: I'd like to know the standard pragmas in the Haskell 2010 standard
08:54:15 <Twey> Heheh… ‘?type cast’
08:54:37 <increpare> Has haskell 2010 been finalized yet?
08:54:40 <doserj> sshc: you also see "...pragmas...do not form part of the Haskell language...@
08:54:49 <chrisdone> well I"m glad it returns Maybe a instead of a or an error
08:55:16 <sshc> doserj: according to comments above (by Baughn), they do now in the 2010 standard
08:55:55 <doserj> sshc: there is no implementation of Haskell 2010 yet
08:56:12 <Berengal> doserj: GHC implements it, though not by default
08:56:20 <increpare> doserj: has the standard been finalized yet?  if so, where is it?
08:56:54 <sshc> Berengal: why doesn't it 2010 by default?
08:56:54 <pikhq> It's been finalized as a set of patches to the H'98 report.
08:56:56 <pikhq> :P
08:57:04 <pikhq> sshc: 2010 is very, very new.
08:57:11 <Berengal> sshc: Because 2010 wasn't done when the last GHC came out
08:57:17 <marsh_> last I checked it was still 2009
08:57:22 <Berengal> Or at least, the last RCs
08:57:23 <doserj> there is no finalized report for Haskell 2010, yet
08:57:28 <sshc> marsh_: :D
08:57:30 <Berengal> 6.14 will implement it by default
08:57:37 <increpare> doserj: ah right, cool - thanks : )
08:57:41 <Heffalump> I think the libraries still need sorting out, too
08:58:20 <marsh_> This has got to make the C++ feel bad, getting lapped by Haskell !
08:58:56 <sshc> so, GHC isn't complient with the 2010 standard yet?
08:59:00 <doserj> and from what I can see, the only pragma standardized in Haskell 2010 is LANGUAGE
08:59:08 <increpare> sshc: not by default
08:59:14 <Berengal> Haskell has had major extensions added almost every year since it's inception
08:59:21 <Berengal> Oh, and major extensions removed
08:59:24 <increpare> doserj: not the inlines/specializations?
08:59:38 <chrisdone> sshc: perhaps doing these things by default might break existing code
09:00:07 <Berengal> sshc: It's compliant in the same way gcc is c99 compliant...
09:01:08 <sshc> have pragmas changed since the '98 standard?
09:03:04 <deech> Hi all, I would like to start a page on haskell.org similar to Ocaml's people page (http://cocan.org/people/north_america). Would this be of interest to the Haskell community?
09:03:08 <EvanCarroll> Would haskell support a custom datatype such that only upper letter strings were accepted?
09:03:54 <EvanCarroll> I don't see a way to add a type that is a subtype (subset) of a base-type.
09:03:57 <Cale> EvanCarroll: typically you'd accomplish that with a smart constructor, if you were going to approach it from the type level at all
09:04:50 <Cale> Create a module with a newtype whose data constructor you don't export, and define a function for making values of that type from strings which just does map toUpper and applies the data constructor, as well as a mapping back to String
09:04:52 <EvanCarroll> cool
09:05:02 <byorgey> deech: sure, go for it
09:05:05 <Cale> There's no subtyping in Haskell.
09:05:18 <EvanCarroll> =(
09:05:22 <Cale> It makes decent type inference much harder, maybe impossible.
09:06:07 <marsh_> well, you just told him how to get its effect right?
09:06:14 <Cale> somewhat, yes :)
09:06:38 <marsh_> So let's call it "manual subtyping" or something that is supported!
09:06:48 <Cale> But you can't give one of these values where you need a String directly, you have to apply that function.
09:07:50 <Cale> Perhaps there is a way to accomplish subtyping with type signatures required where it's used while preserving inference elsewhere. I haven't really felt much of a need for it though.
09:07:56 <EvanCarroll> Haskell will probably get type interfaces when they can devise a new incomprehensible math to justify them and find two scandavinavian martians with unpronounceable names to take credit for it.
09:08:00 <sshc> deech: if you're looking for responses, you should probably repeat your question after the nesplit is over
09:08:06 <merijn> So I just read some stuff on existential typing, any reasons against using it other then code being less portable in the "not all compilers support this" sense?
09:08:11 <marsh_> lol
09:08:16 <Cale> EvanCarroll: type interfaces?
09:08:20 <EvanCarroll> subtypes*
09:08:54 <EvanCarroll> I can get it with a "smart constructor" that'll work ;)
09:09:33 <mk64ftw> ^^^ why does it do that?
09:09:42 <merijn> mk64ftw: Net splits
09:09:43 <Cale> mk64ftw: what?
09:09:55 <Cale> mk64ftw: Oh, the servers disconnect and reconnect to one another
09:10:20 <Cale> mk64ftw: and so the people on either side of the split see each other being disconnected, and then reconnected
09:10:59 <mk64ftw> it is kind of annoying, guess i don't know enough about IRC protocol
09:11:15 <merijn> mk64ftw: http://en.wikipedia.org/wiki/Netsplit illustrates it quite clearly
09:11:20 <marsh_> Cale: Could you maybe avoid having to "apply that function" with the "TypeSynonymInstances" extension?
09:11:26 <mk64ftw> thanks
09:11:32 <Saizan> merijn: if it suits your needs i'd say go for it, make sure you understand the implications, and if you're not that familiar with type systems and/or logic you might get some confusing error messages at first
09:11:38 <Cale> It's really annoying and stupid that the network topology would be a tree.
09:11:47 <Saizan> s/logic/mathematical logic/
09:12:17 <Cale> marsh_: no. You could use a type synonym, but it would give you no type safety
09:12:39 <Cale> You could also just as well  map toUpper  and call it a day.
09:13:20 <marsh_> thx. I'm trying to 'map' my C++ concepts onto Haskell one at at time
09:14:00 <Berengal> It's better to forget your C++ concepts and start over
09:14:25 <Berengal> You can retain algorithms and datastructures if you want. Those are still useful
09:14:26 <merijn> marsh_: Doomed mission
09:14:38 <merijn> Saizan: Inexplicable errors are the only way to start learning complicated things, right? :p
09:14:40 <marsh_> Oh man I'm in trouble
09:15:12 <jlouis> marsh_: not at all. When you look back 2-3 months from now, your C++ will have improved
09:15:28 <Saizan> merijn: eheh, it sure means you're working with something new :)
09:15:40 <marsh_> My problem is that I want to have a challenging problem to solve to write a program. I'm just not smart enought to solve a challenging programming problem and get proficient in a new way of programming at the same time.
09:15:40 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15110 -- how to translate ;)
09:15:41 <Philonous> Does fixIO do something interesting besides sticking an exception into a function?
09:16:09 <increpare> jlouis: Yeah, my c++ style changes whenever I'm working with haskell : P
09:16:11 <merijn> marsh_: The first functional programming I learned was OCaml and the one main lessons I learned during that class was that attempting to translate imperative principle to functional programming results in programs that are terrible :p
09:16:16 <increpare> (maybe wouldn't say 'improved', though)
09:16:18 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15158 -- less direct route ;)
09:16:37 <Saizan> Philonous: it let you write circular definitions in IO, provided you're enough lazy
09:16:51 <marsh_> Cale: nice
09:17:57 <HaskellLove> why is this wrong g n m = ((fst n) / (snd m)) == (n / m)
09:18:00 <marsh_> I have been that far with it before (and some FP-style Scheme) but never really felt comfortable and productive
09:18:24 <byorgey> HaskellLove: because pairs aren't Nums.
09:18:27 <merijn> marsh_: It also depends on how used you are to higher order functions. I've found functional programming was far easier after being conditioned to higher order functions in Python. I have no clue if there is any real support for that in C++ other then with C's function pointers which is hardly nice to work with :p
09:18:42 <Cale> marsh_: It took me about 2 months to feel like I could be productive with Haskell, and about 1 year to feel really comfortable.
09:18:42 <byorgey> HaskellLove: what is  (1,2) / (6,8) supposed to mean?
09:19:21 <Cale> marsh_: People aren't kidding when they say it's probably best to treat it as if it were your first programming language.
09:19:41 <marsh_> C++ has now (and is getting better) Lambdas, argument binders, etc. with varying degrees of template insantity
09:20:00 <Saizan> Philonous: though you could add more unsafeInterleaveIO to its implementation and get more terminating cases i think
09:20:14 <Cale> If you try to write functional programs by imagining imperative programs and trying to figure out how to simulate them it mostly just makes things hard.
09:20:17 <Zao> I decided to take the plunge and write my code in the pseudo-C++0x that VS2010 has.
09:20:25 <Zao> Much nicer with auto, lambdas, for each, etc.
09:20:26 <marsh_> Heck, getting GHC 6.12.1 running on CentOS 5.4 is making me feel like I'm on my first computer
09:20:41 <Cale> Get GHC 6.10.4
09:20:53 <Cale> and then cabal install
09:20:53 <Philonous> Saizan: But the action I give it is just invoked once, and there it is given an insafeInterleaved exception. So it looks to me as if all we do is check whether the argument is forced at some point and then we throw an exception
09:21:08 <increpare> Zao: yeah I've had a lot of fun with gcc's ++0x extensions myself
09:21:29 <Berengal> One trick I used alot when I first started out learning haskell was to continually ask myself "what is this variable". Emphasis on "is".
09:21:41 <marsh_> O man 'auto' is da bomb
09:21:54 <increpare> marsh_: auto is a mixed blessing
09:21:55 <Zao> increpare: function<shared_ptr<T>> // <- thunk, kind of :)
09:22:03 <byorgey> marsh_: yeah, if you're just learning Haskell don't get ghc 6.12.1 yet
09:22:03 <jfischoff> Berengal: any more tricks?
09:22:10 <increpare> Zao: what does that do?
09:22:16 <byorgey> marsh_: lots of stuff on Hackage is still being updated to work with it
09:22:28 <Saizan> Philonous: well, it is invoked just once, this is not something like a while loop, it's like Data.Function.fix, and looking at its implementation your function shouldn't look at the argument it is given before it returns in the IO sense
09:22:30 <Zao> Err, slightly wrong syntax. function<T ()>.
09:22:46 <increpare> Zao: what happened to shared_ptr?
09:22:46 <Berengal> jfischoff: Learn the syntax first. It's much easier to figure out concepts when you know what they look like
09:22:47 <marsh_> Good advice, I'll take it
09:23:01 <Zao> Aargh. function<shared_ptr<T> ()> .
09:23:06 <Zao> Never code before first tea.
09:23:07 <byorgey> marsh_: is there some reason the Haskell Platform won't work on CentOS?
09:23:17 <pikhq> marsh_: What, you mean don't like this: void (*foo)();?
09:23:17 <Zao> Nullary functor that returns a shared_ptr to T.
09:23:36 <marsh_> byorgey: I'll try it and let you know
09:23:44 <Cale> marsh_: If you're having any trouble installing the Platform, the linux binary GHC tends to work well.
09:23:45 <Zao> I bind a lot of those to lambdas.
09:23:52 <Cale> (CentOS is a linux distribution, yeah?)
09:24:03 <Zao> It's up to the caller to hang on to either the functor or the result.
09:24:10 <jfischoff> Berengal: Yeah, I'm finding I get stuck for like half an hour on one compliation error cause I'm never sure if my syntax is right
09:24:12 <Zao> (functor being callable object, not that silly mathemagical concept)
09:24:33 <Cale> Zao: I hate that abuse of the word "functor"
09:24:44 <Cale> Zao: They should just call them functions
09:24:46 <marsh_> Cale: yes, but I'm new to it. It seems very stable and well put-together, to the point of having few prepacked apps
09:24:56 <increpare> Zao: so like void ( shared_ptr<T> (*foo) () ) ?
09:25:01 <Zao> functions have a specific meaning already, as they're not quite first class.
09:25:06 <Zao> I prefer the term callable.
09:25:12 <pikhq> Cale: CentOS is RHEL minus Red Hat.
09:25:25 <Zao> increpare: Yes, except that yours may only bind to free functions.
09:25:30 <marsh_> A plain function isn't "callable"?
09:25:39 <Philonous> Saizan: Ah, we create a closure that looks into the IORef, so it actually changes after the fact. unsafeInterelaveIO really is a mindbender.
09:25:40 <Zao> (that is, static members or non-member functions)
09:25:46 <Philonous> Saizan: That was enlightening. Thanks
09:25:56 <Zao> A function<Ret (Arg1, Arg2,...)> is a generic holder for anything callable with that signature.
09:25:59 <Berengal> pikhq: "Enterprise Linux"? Doesn't sound very enticing
09:26:07 <increpare> Cale: yeah the terminological overlap is unfortunate : P  However, haskell does just as many minor violences to mathematical terminology in its own ways...
09:26:09 <pikhq> marsh_: A plain function goes through the builtin function call semantics, rather than operator ().
09:26:28 <Zao> A free function is to callable as pointers are to iterators.
09:26:30 <Saizan> Philonous: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Monad-Fix.html <- might be useful too
09:26:41 <mercury^> It's not an overlap. Someone heard "functor", did not understand it, but found it cool and then used the term for something unrelated.
09:26:47 <Cale> increpare: Well, Functor isn't quite right in Haskell either, as it captures only endofunctors on Hask.
09:26:54 <Zao> Pointers into a sequence satisfy the iterator model; free functions satisfy the callable model.
09:26:55 <increpare> Zao: ah gotcha.  So how does it deal with member functions there?
09:27:08 <increpare> Cale: 'zactly.
09:27:12 <increpare> Zao: there/then
09:27:14 <marsh_> but a function pointer is basically convertible to a function<> of the proper type, right?
09:27:16 <Cale> increpare: and Category is really strange, but at least whatever it is that it's capturing really is a category.
09:27:19 <Zao> increpare: By binding them to an instance or a placeholder via the `bind' function.
09:27:46 <Zao> increpare: function<void ()> = bind(&S::f, some_s)
09:28:04 <Zao> increpare: Which is kind of like a primitive partial application.
09:28:23 <Zao> I love modern C++. It's way more functional than one'd expect.
09:28:34 <marsh_> I think it's rather elegant, for a language backward-compatible with C
09:28:35 <increpare> Cale: not necessarily - the category package can't enforce the various algebraic laws that are necessary for something to be a category
09:28:46 <Cale> C++ makes my eyes bleed.
09:28:51 <increpare> Actually, I should check before saying that : P
09:29:00 * increpare goes off to check
09:29:03 <pikhq> The only tolerable C++ I've seen is written by Oleg.
09:29:03 <pikhq> :P
09:29:11 <Cale> increpare: It can't enforce them, but you're expected to check them
09:29:23 <Nafai> marsh_: You have an odd definition of elegant :)
09:29:36 <marsh_> true
09:29:48 <increpare> Cale: check what, though?  the documentation doesn't say anything about them.
09:29:54 <Cale> increpare: That is, you can expect instances of Category and Functor and Monad to satisfy all the respective laws
09:30:22 <Cale> Oh, that's a documentation problem then.
09:30:25 <merijn> marsh_: I'd actually rather just write plain C then C++. I find the former by far more elegant then C++ (even though it has a significant amount of warts)
09:30:34 <Cale> In practice, people are paying attention when they write instances :)
09:30:52 <increpare> Cale: the comonad class seems reasonably documented actually
09:31:14 <pikhq> merijn: But, but! foo<Lambda(void, void, do_something();)>(); !
09:31:20 <increpare> Cale: and maybe the category typeclass by itself is enough -
09:31:35 <marsh_> merijn: not me. I loves me my type checking, exceptions, templates, and RAII
09:31:39 * increpare tries to think of an awkward edge-case
09:31:56 <Saizan> i don't think the types enforce associativity
09:32:06 <Cale> increpare: However, there are problems. The mtl has a ListT which is not a monad transformer.
09:32:23 <pikhq> marsh_: So, you love the poor type-system, the exceptional slowdown, the reason why C++ can't be compiled, and a workaround to get around the lack of garbage collection.
09:32:28 <Cale> Saizan: they don't enforce the unit laws either
09:32:30 <merijn> marsh_: C++ looks like they took the verbosity of Java, the obfuscation of perl/sed and combined it with C's ability to blow your limbs of in one big package >.>
09:32:36 <Zao> pikhq: [](int x, int y){ return x + y; } // yay, lambda
09:32:36 <Cale> They *do* however enforce naturality
09:32:59 <merijn> Speaking of which, how is GHC's compile time on larger projects? With module support in the language I'd expect compile time to be significantly smaller then C for large projects...
09:33:03 <Zao> Not horribly different from (\x y -> x + y)
09:33:03 <increpare> Cale: actually yeah Control.Category is fine.
09:33:37 <Cale> Control.Category insists that the composition maps be natural transformations in the underlying types, which is rather weird.
09:33:42 <kalven> pikhq: a gc does not get rid of the need for raii. but you probably know this already.
09:33:47 <Associat0r> merijn: C++ is less verbose than java
09:34:05 <Associat0r> merijn: if you use it right
09:34:07 <marsh_> byorgey: Haskell Platform not shipped in binary for CentOS
09:34:14 <Heffalump> closures make raii tricky
09:34:20 <Cale> Kind of nice, but I don't know if it corresponds to anything well-studied.
09:34:23 <Associat0r> http://www.reddit.com/r/programming/comments/aje5b/functional_programming_doesnt_work_and_what_to_do/
09:34:38 <increpare> Cale: I actually haven't seen much explicit use of natural transformations in haskell - I find this a bit strange - I guess it might be because the Functor class is quite limited, and Monads include a lot of the interesting ones.
09:34:45 <pikhq> Zao: Semantically equivalent to Oleg's Lambda((int x, int y), int, return x+y;);
09:34:58 <merijn> Associat0r: That was already linked earlier today, I found the article rather poorly argumented
09:35:00 <Cale> increpare: Natural transformations are implicitly everywhere.
09:35:14 <increpare> Cale: Notice that I said "explicit" : P
09:35:18 <Cale> yeah
09:35:19 <pikhq> Except that the Lambda macro is valid in current C++. ;)
09:35:35 <increpare> Cale: but yeah, maybe they're okay just being there in the background.
09:35:50 <Cale> increpare: It doesn't make too much sense to make a NatTrans class because that means picking a canonical one somehow
09:35:56 <Zao> pikhq: Except standard C++ does not give local classes external linkage.
09:36:00 <increpare> ICale: where does it say that the composition maps be natural transformations?
09:36:03 <Cale> However, it can come in handy at times
09:36:04 <Zao> And local functions is not standard at all.
09:36:13 <Cale> increpare: It's enforced by the type system
09:36:22 <Cale> increpare: Because it's polymorphic in a,b,c
09:36:23 <Associat0r> merijn: i have to read it still, I will get back to you later
09:36:24 <Saizan> we reason directly with parametricity, without worrying about the functors
09:36:34 <pikhq> Zao: Mmm, yeah. The Lambda macro is a local class, so not external linkage at all.
09:36:48 <pikhq> And you end up passing a Lambda around via templates, so...
09:36:51 <pikhq> *Close*, but not quite.
09:37:13 <marsh_> could probably pass it to a template function to deduce and synthesize a type for it
09:37:35 <Cale> increpare: You automatically get something which is a natural transformation -- you're not allowed to define the composition maps individually in any old way you want, it has to be uniform for all types a,b,c.
09:37:51 <Cale> and that uniformity leads to satisfying all the relevant naturality squares
09:38:36 * increpare sketches up a quick diagram to confirm
09:39:18 <medfly_> Cale is so addicted to #haskell, he sleepchats here.
09:39:22 <Cale> (Whatever composition does, it's not allowed to depend on any of the actual values of type a,b,c involved.)
09:39:24 <merijn> Associat0r: The article boils down to "functional program isn't very good at thing which functional programming isn't very good at", in which the question is "why did you write it in a functional programming language instead of picking the best language for the task?"
09:39:24 <Cale> heh
09:40:36 <marsh_> Perhaps we could have the best of both worlds if we could get a high-level C++/Haskell binding going like Boost::Python
09:40:40 <Cale> That's a rather kind characterisation of it
09:40:47 <Cale> (merijn)
09:41:12 <pikhq> merijn: More like "Functional programming isn't very good at thing which functional programming tries to make unnecessary:
09:41:13 <Saizan> merijn: the article really says "i've not understood how to do functional programming or what it is about yet"
09:41:22 <Cale> The article appears to be complaining that functional programming is bad because doing something which would usually be horrifyingly harmful to correctness is hard to do.
09:41:57 <marsh_> like printf("Hello, %s", var)
09:42:21 <copumpkin> Cale: could I get a monad out of ordered lists? I was thinking of join being the merge function for an arbitrary number of ordered lists (the ordered lists themselves are in order)
09:42:44 <medfly_> the ordered lists themselves are in order
09:42:49 <pikhq> marsh_: Inside of your doACalculation :: Integer -> Integer? Yeah, that's quite harmful.
09:43:05 <Cale> Yes it's hard to take the two lowest-level and most isolated functions in your code base and make them behave differently based on the number of times the other one has been used, because you shouldn't do that in the first place.
09:43:25 <mreh> can the Enum methods succ and pred wrap round?
09:43:29 <pikhq> If I really needed logging at arbitrary points in my program (and nothing else), I'd just make a Logger monad, and make that doACalculation :: Integer -> Logger Integer
09:43:41 <mreh> they probably can, but should they?
09:43:45 <copumpkin> Cale: I guess that would just be a set monad, really
09:43:52 <copumpkin> or multiset
09:43:57 <Cale> yeah
09:44:03 <Cale> (that's a monad)
09:44:08 <copumpkin> :)
09:44:34 <marsh_> well-delimited and timestamped log messages are probably the one thing I think deserves an exception to pure IO rules
09:44:59 <Cale> We need a bunch of "Will it monad?" video clips, with "It monads!" at the end of each.
09:45:03 <pikhq> marsh_: The hypothetical Logger monad would probably internally do unsafePerformIO for the sake of timestamps.
09:45:23 <merijn> Saizan: Well, I can see things that'd be harder to do in a functional programming language (this could be a side effect of me not looking at the problem the right way and/or knowing enough haskell) but then I'd just write them in a language that makes it easy for me to implement like python. No one is (or should be) forcing you to write solutions in a suboptimal language for your problem.
09:45:43 <Cale> pikhq: or you could have it newtype IO
09:45:44 <Philonous> Cale: Yes, please. But do it for arrows, applicatives and comonads as well.
09:45:53 <pikhq> Cale: Also plausible.
09:46:18 <copumpkin> Cale: yay, we should
09:46:19 <pikhq> And less likely to make someone throw things at me for admitting that unsafePerformIO exists.
09:46:36 <osfameron> Cale: I didn't think the article was suggesting FP was bad.  It was more "I find it too much hassle to get anything *done* with it.  I'm going to do 'FP as far as I can, and then find the escape hatch' instead"
09:46:43 <Saizan> merijn: in principle i agree, this article doesn't have any good points about what's problematic to do with functional programmign though
09:46:46 <osfameron> which is more or less what I try to do in Perl...
09:46:55 <increpare> Philonous: then there'd just be the inevitable riposte version that had the same questions directed towards turing machines : P
09:47:38 <Cale> marsh_: The trouble with timestamps is that the evaluation order of pure Haskell code is nondeterministic in the sense that the compiler can decide to evaluate things in almost any order that it sees fit.
09:47:58 <sproingie> @remember Cale We need a bunch of "Will it monad?" video clips, with "It monads!" at the end of each.
09:48:10 <sproingie> ENOLAMBDABOT
09:48:18 <marsh_> well, that can be interesting information to get in the logs, eh?
09:48:29 <increpare> Cale: uch - trying to pull a single commuting square is hard work when you have two layers to work through : P
09:48:40 <pikhq> marsh_: And unless it's doing IO, the evaluation order makes no difference.
09:48:48 <pikhq> (... modulo _|_)
09:49:02 <merijn> Saizan: I agree on that, it's just wrong on a meta-level in addition to being wrong. (i.e. it doesn't make any solid arguments against functional programming which is based on the flawed premise that the existence of such arguments is a flaw in functional programming)
09:49:09 <increpare> sproingie: let's not beome too monad-centric - let's spread the love around : )
09:49:24 <Cale> marsh_: Well, yes, but if you put it into pure code, the log entries may end up happening in a strange unexpected order that doesn't have anything to do with the order in which actions are being carried out by your program
09:49:31 <sproingie> i would definitely love one that did the same for arrows and comonads and whatnot
09:49:37 <sproingie> i still can't come up with a real world comonad
09:49:53 <osfameron> somebody tried to tell me recently that grids were comonads
09:49:59 <sproingie> except maybe for that DSP example
09:50:07 <osfameron> but I didn't understand what they were saying... ;-)
09:50:11 <marsh_> Definitely not good for everything
09:50:23 <monochrom> Article? Blog? Blog is just rant.
09:50:28 <Cale> marsh_: You can do it with Debug.Trace. It'll mainly reflect the order in which pure values are being evaluated, which is handy for debugging, but not for actual logging of most sorts.
09:51:17 <marsh_> When the log files come from a customer site having mysterious problems, I'll be grateful for whatever I can get
09:51:18 * sproingie read the "Admitting Functional Programming Can Be Awkward" blog post, written in 2007
09:51:29 <sproingie> end of 2009, all the FRP examples are still bouncing balls
09:51:46 <Cale> marsh_: But normally I would advise putting log messages into I/O, since that's what they are.
09:52:25 <Cale> marsh_: Usually events that get logged tend to already be at that level anyway.
09:52:37 * monochrom writes a one-line blog "OOP is so awkward" just to get every programming channel heatedly "discuss".
09:52:50 <Cale> heh
09:53:29 <monochrom> A random rant from a random stranger. Why would anyone care? http://xkcd.com/386/
09:53:32 <sproingie> single paradigms are awkward.  discuss.
09:54:02 <marsh_> IMHexp, there's a large class of messages that are potentially useful in after-the-fact tracing but are not worth serializing everything in IO for normal execution
09:54:31 <noteventime> Is it possible to have the result of a pure array function (something like Array i a -> Array j b) written to a preallocated array (that is, without an intermediate copy)
09:54:33 <increpare> Cale: ah, Category is missing in the docs the explicit requirement of associativity of (.) : )
09:54:45 <pikhq> OOP is quite awkward. class foo {private: int bar; public: getBar();} ?
09:54:51 <Cale> increpare: Might be a good idea to report that to someone
09:54:59 <increpare> Cale: yeah I'll blip the maintainer
09:55:15 <pozic> noteventime: if you write a NotEvenTimeArray, yes.
09:55:18 <Cale> increpare: But it would be good if the haddock docs mentioned the laws
09:55:21 <pikhq> Screw that, just do: data foo = Bar Int // :)
09:55:43 <Cale> increpare: I actually don't really like that Category definition stealing (.)
09:55:45 <pozic> noteventime: using the FFI functions probably, and some unsafePerformIO.
09:56:07 <monochrom> See, I don't even have to put it on a blog. I just have to say here.
09:56:12 <noteventime> I guessed as much, but that's no fun :p
09:56:24 <SpookyET> I'm trying to wrap my head around functional programming and wondering why all functional programming languages have horrible-looking, ugly syntax. I am not trying to insult anyone, but compared to imperative, there are lots of <>->!#$@(*%!@%&!@#)$*@_! characters.
09:56:26 <sproingie> pikhq: nice, now make it polymorphic
09:56:30 <Cale> increpare: I think that making (.) into functor application (fmap), makes more sense as a generalisation.
09:56:35 <Saizan> noteventime: there's array fusion (turned on with -O2 at least) which might take care of that automatically
09:56:36 <pozic> noteventime: using ST you can do similar things.
09:56:37 <increpare> Cale: heheheh : P
09:56:56 <pikhq> sproingie: data foo = Bar a;
09:57:00 <Cale> increpare: We use fmap a lot, so it would make sense to give it nice syntax
09:57:01 <noteventime> I guess ST would be just as good
09:57:05 <pozic> Saizan: the problem with all these automatic optimizations is that there is no high-level output of the optimizer.
09:57:19 <sproingie> SpookyET: haskell's base syntax is actually really clean.  unfortunately there's been a craze toward ugly infix operators in haskell-land as of late
09:57:26 <pikhq> Or: template <typename T> class foo {private: T bar; public: T getBar();}
09:57:28 <pozic> Saizan: you cannot know before hand what the constant factors are going to be.
09:57:33 <Cale> sproingie: Like what?
09:57:43 <Cale> Most of the infix operators are pretty sensible
09:57:50 <pozic> Saizan: the "it depends on the compiler" is a bit annoying answer. Discuss. ;)
09:57:53 <increpare> Cale: (.) is a functor from CxCop -> C, in any event so I we could have our cake and eat it : )
09:57:55 <benignvulcan> I'm having trouble throwing an error from inside the LogicT monad.  The compiler doesn't seem to want to allow me call a function that uses LogicT functions (such as "once" and "ifte") and throwError.  LogicT appears to have been written without a way to combine it with the ErrorT/MonadError monad.  Is this true?
09:58:15 <increpare> (so I we/so I guess we)
09:58:19 <Cale> increpare: It's tricky somehow.
09:58:28 <increpare> oops, not CxCop->C but CxCop->set
09:58:44 <noteventime> Saizan: Thanks, I'll see if I can get it to use fusion instead
09:58:49 <Cale> increpare: I tried doing both generalisations at once, and things got complicated quickly.
09:58:52 <sproingie> Cale: all that *** <+> <|> <natter> <gromish> adds up.  except for the fact you can't actually define <natter> and <gromish>
09:58:57 <increpare> Cale: Both generalizations?
09:58:58 <SpookyET> sproingie: I was thinking more of a ruby-like syntax. I consider ruby pretty clean.
09:59:05 <mercury^> increpare: C was correct.
09:59:18 <sproingie> i find python pretty clean.  ruby is somewhere between that and perl
09:59:49 <SpookyET> sproingie, not really. __bla__ around and the API makes it quite ugly.
09:59:54 <Cale> increpare: Well, you need to generalise fmap to work on arbitrary Category instances
10:00:09 <Cale> increpare: and then you need to do something to unify them, which is tricky
10:00:26 <Saizan> pozic: you can make it dump which RULES fired, but i agree
10:00:27 <sproingie> SpookyET: right but that doesn't form a public API
10:00:38 <Cale> SpookyET: what features of ruby's syntax in particular?
10:00:40 <sproingie> i prefer __blah__ to ruby's hijacking of random words
10:00:50 <Cale> Curly braces?
10:01:51 <maikeru|> I used to be just fine with python's double underscoring, but someone has since beaten it into me that they are ugly. Now when I see them, they irritate me
10:02:10 <marsh_> Ruby's can be even more context-sensitive than Perl
10:02:26 <kmc> it's less ugly than the C++ solution
10:03:16 <marsh_> I have some source files that are simultaneously valid Ruby and valid C++, and one generates the other!
10:03:20 <noteventime> SpookyET: Isn't it just because you'll have more infix code, since the code isn't sequential
10:03:22 <increpare> Cale: well there is a functor defined in category extras already
10:03:57 <increpare> Cale: though I'm just looking at it now for the first time...
10:04:19 <SpookyET> sproingie: If you want "random" words, try AppleScript.
10:04:33 <SpookyET> sproingie: It's as close to English as you're going to get.
10:04:47 <koeien37> COBOL
10:04:48 <sproingie> well yes there's always something worse
10:04:53 * Cale looks at ruby syntax again to remind himself what it looks like
10:05:13 <EvanCarroll> ghc is written in C right?
10:05:21 <sproingie> haskell
10:05:24 <Berengal> EvanCarroll: It's written mainly in haskell
10:05:26 <koeien37> Haskell, and a bit C
10:05:43 <Berengal> ghc = fix ghc
10:05:44 <marsh_> Which is why I can't install it on CentOS it seems
10:06:03 <koeien37> should be no problem
10:06:10 <koeien37> there are binary packages
10:06:12 <Berengal> marsh_: Just get a linux binary
10:06:16 <HaskellLove> has anyone done euler 33? It says you should get for four non-trivial fractions, and my list is way bigger
10:06:21 <marsh_> rpm library hell
10:06:39 <sproingie> the ghc rpm hardly has that many deps
10:06:51 <sproingie> or just install the binary tarball
10:07:10 <marsh_> libtinfo.so.5
10:07:13 <SpookyET> EvanCarroll: First a compiler is written in C. Then a compiler is written in Haskell. Then the C compiler is discarded and the haskell is used to compile the haskell. That always seems to be the progression of compilers.
10:07:13 <Cale> marsh_: Whatever you do, just don't compile GHC yourself.
10:07:29 <marsh_> It worked the last time I did it
10:07:32 <Cale> marsh_: There's a binary GHC on the website which depends on that, and one which doesn't.
10:07:34 <kmc> you don't need a compiler for the first step SpookyET
10:07:34 <Berengal> HaskellLove: I'd take that as a sign that you're doing it wrong.
10:07:36 <sproingie> i hope 6.12 has dropped that libtinfo dependency
10:07:38 <kmc> an interpreter will do just fine
10:07:48 <sproingie> i don't know a single linux distro that ships with libtinfo anymore
10:07:50 <koeien37> yeah, they could have used an interpreter
10:08:02 <koeien37> maybe a little bit easier to write
10:08:04 <kmc> Hugs is written in C, and I think the first Haskell compiler was in Lazy ML
10:08:13 <kmc> an interpreter is a *lot* easier to write
10:08:15 <Saizan> marsh_: there are two versions of the binary package for ghc, the other shouldn't have a problem with libtinfo
10:08:20 <sproingie> what's the perl dependency in ghc used for?
10:08:23 <jlouis> SpookyET: there is another path through incremental bootstrapping
10:08:29 <Cale> sproingie: The evil mangler
10:08:31 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15191#a15191 Berengal if you dont understand tell me i will guide you
10:08:34 <medfly> the EVIL MANGLER
10:08:46 <sproingie> HASKELL THE EVIL MANGLER
10:08:49 <increpare> Cale: hmm he has two functor classes.  hmm.
10:08:50 <Cale> http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
10:08:56 <medfly> oh, that's a real name
10:08:57 <sproingie> coming to Chiller
10:08:58 <marsh_> Saizan, thx
10:09:09 <kmc> it's easy to give an operational semantics of a language like haskell in terms of graph rewriting.  it's much harder to efficiently compile that to machine code
10:09:10 <mercury^> I thought the mangler was phased out already.
10:09:12 <kmc> hence, interpreter is easier
10:09:14 <fxr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15190 any ideas why it gives an exception? it's a short example and the directory contains more than 2000 files. I'm using ghc 6.12.1.
10:09:23 <Cale> mercury^: It has, it's only used with -fvia-C
10:09:23 <i_am_neuron> jlouis: sorry for resurrecting the topic from days ago, I remember you were surprised about myself trying to implement Twisted-like framework in Haskell. Do you think it does not worth the effort?
10:09:37 <mercury^> Cale: yes. I thought it was phased out there too.
10:09:47 <Berengal> HaskellLove: "notContainsElementSmaller_1 n = all (>1) n"? Wouldn't it be easier to just inline the definition of this function everywhere?
10:09:51 <Cale> That'd be more work.
10:10:30 <Saizan> @tell mmorrow hpaste's database is locked :)
10:10:34 <HaskellLove> Berengal hmm hpaste failed now right when i needed help :) you having problems?
10:10:38 <sproingie> i guess when the llvm backend takes over the world we won't have to have the evil mangler
10:10:38 <Saizan> ugh, no bot
10:10:47 <jlouis> i_am_neuron: I can't be the judge of that. I would like to know what you try to solve with it though
10:10:50 <Saizan> fxr: you'd have to use another pastebin
10:10:53 <sproingie> that oughta be sometime in the year 2525
10:10:53 <mauke> Saizan: preflex
10:10:55 <marsh_> I've always thought that a highly concurrent (lock-free) graph rewriter would be fun to write
10:11:06 <HaskellLove> [[13.0,65.0],[15.0,75.0],[16.0,32.0],[16.0,64.0],[16.0,96.0],[17.0,85.0],[19.0,95.0],[26.0,65.0],[27.0,54.0],[38.0,76.0],[39.0,65.0],[49.0,98.0]] Berengal I get 12 instead of 4
10:11:14 <Cale> sproingie: There's already a native code generator which is the default, so you don't use the EM unless you explicitly ask for compilation via C
10:11:17 <pikhq> mercury^: -fvia-C is deprecated, but still supported.
10:11:21 <fxr> Saizan: what is wrong with hpaste?
10:11:30 <sproingie> i_am_neuron: ghc's IO scheduler is already pretty much like twisted
10:11:43 <sproingie> i_am_neuron: insofar that it's a reactor
10:11:52 <Saizan> fxr: gives an internal server error currently
10:12:10 <Berengal> HaskellLove: I'd think your 'f' function is wrong. It looks like it should take two arguments, but you're giving it a list instead
10:12:14 <sproingie> twisted is based on callbacks, and callbacks are very difficult to work in to functional programs
10:12:33 <sproingie> my glut callbacks are about as imperative as can be
10:12:45 <Saizan> preflex: tell mmorrow just reporting that hpaste's db got locked
10:12:46 <preflex>  Consider it noted.
10:12:56 <i_am_neuron> jlouis: sure, no judgement is expected. I wanted some task which would be of significant size and involve parallelism, networking and async primitives like deferreds
10:13:03 <fxr> http://paste.lisp.org/display/92776 here it is
10:13:03 <increpare> Cale: I'm not really comfortable with the idea of co-oping the composition operator for the purposes of fmapping.  What's wrong with using (mathematical) functors: ff F is a functor than F f works as fmap f .
10:13:04 <HaskellLove> Berengal but look the above list they are all corect, how come four uniqe?
10:13:36 <i_am_neuron> sproingie: why callbacks are hard? Seems like lambdas fit here naturally...
10:13:41 <mercury^> preflex: tell yourself this
10:13:41 <preflex>  Consider it noted.
10:13:42 <Cale> increpare: Of course, you'd want to keep some normal prefix function syntax for it as well
10:13:48 <HaskellLove> Berengal f takes a list as argument
10:13:52 <mauke> preflex: xseen yourself
10:13:52 <preflex>  Sorry, I haven't seen yourself
10:14:16 <sproingie> i_am_neuron: it's hard to keep state.  how do you call back into the middle of a state monad?
10:14:18 <Saizan> fxr: maybe you've to "map ("1-1/"</>) fs"
10:14:22 <Berengal> HaskellLove: I think you got the problem wrong. The "cancellation" the problem describes involves removing two equal digits, not the first digit of the numerator and the second of the denominator
10:14:27 <Cale> are we in the middle of a split?
10:14:33 <Berengal> HaskellLove: You've got several numbers which don't have a common digit
10:14:50 <Cale> There have been so many it's hard to keep track
10:15:20 <Cale> I'm wondering about whether I should forcibly kill lambdabot and reconnect it, or if I should just wait.
10:15:20 <sproingie> i_am_neuron: i suppose you could do something with ContT, but that's pretty heavy policy.  then again, twisted is itself pretty heavy policy
10:15:24 <HaskellLove> Berengal ouch... problem misunderstood
10:15:29 <fxr> hmmm
10:16:05 <kmc> yay
10:16:08 <kmc> @vixen welcome back
10:16:14 <sproingie> i_am_neuron: basically you end up having to keep state in IO, which ends up making IO infect more of your program than you want
10:16:15 <lambdabot> Yes
10:16:16 <i_am_neuron> sproingie: I'm basically a noob, so marked ContT for the consideration
10:17:12 <noob> what
10:17:33 <i_am_neuron> sproingie: do you speak from experience with similar task?
10:17:34 <fxr> Saizan: instead I tried to give absolute path to the getDirectoryContents but got same exception
10:18:15 <fxr> hmm ok it returns rel paths...
10:18:25 <sproingie> i_am_neuron: yep, implementing GLUT callbacks.  i just use IOrefs, and with StateVar they even look pretty, but I'm definitely stuck with IO
10:18:43 <Saizan> fxr: yeah, it doesn't include the directory portion of the path in the results
10:18:55 <fxr> thank you
10:19:39 <noob> do you call me
10:19:50 <benignvulcan> does anyone here actually use the LogicT monad?
10:19:50 <bob0> benignvulcan: no
10:20:15 <sproingie> never heard of it
10:20:18 <tromp__> never heard of it:(
10:20:39 <Saizan> it's a fairly powerful monad for backtracking computations
10:20:40 <sproingie> it looks pretty neato
10:20:45 <benignvulcan> bob0: meaning you think it _is_ possible to throw an exception from somewhere inside LogicT?
10:21:02 <sproingie> it's also yet another case where examples in the haddock would have been really handy
10:22:08 <Saizan> benignvulcan: have you asked a question about LogicT? i can't find it in the scrollback
10:22:16 <benignvulcan> yes, about 20 minutes ago
10:22:39 <Saizan> well, try repeating it now :)
10:22:45 <benignvulcan> ok! :)
10:22:47 <benignvulcan> I'm having trouble throwing an error from inside the LogicT monad.  The compiler doesn't seem to want to allow me call a function that uses LogicT functions (such as "once" and "ifte") and throwError.  LogicT appears to have been written without a way to combine it with the ErrorT/MonadError monad.  Is this true?
10:23:07 <opqdonut> :t throwError
10:23:08 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
10:23:32 <Saizan> benignvulcan: well, you can use lift
10:23:36 <opqdonut> what monad are you using, precisely?
10:23:45 <opqdonut> yeah, lift will probably fix that
10:23:49 <benignvulcan> I did figure out that I had to declare my own error type to be an instance of Error
10:24:05 <Saizan> if you're using LogicT over something that is a MonadError
10:24:07 <Saizan> ?type lift
10:24:08 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
10:24:10 <opqdonut> there is a missing MonadError instance, probably
10:24:16 <benignvulcan> what I just `lift (throwError foo)` ?
10:24:26 <Saizan> yeah
10:24:59 <Saizan> catchError will be more problematic, i think
10:26:02 <benignvulcan> At the moment, my central function is using StateT, LogicT, and attempting to use ErrorT.
10:26:36 <increpare> Cale: (+1).[2,3,4,5,6]  has some charm.  I guess it would  generalize normal composition, so wouldn't break anything.  Hmmm.
10:26:38 <benignvulcan> I've got the state inside (if that's the correct preposition) the logic so that the state unwinds when it backtracks.
10:28:25 <benignvulcan> and sometimes it should not just backtrack on failure but really die with an exception.
10:31:03 <sproingie> > let (.) = fmap in succ . [1..5]
10:31:04 <lambdabot>   [2,3,4,5,6]
10:31:23 <increpare> sproingie: : P
10:31:29 <marsh_> yay "Installation of ghc-6.10.4 was successful."
10:31:32 <sproingie> cute.  little bit liberal for what i expect from .
10:33:42 <increpare> sproingie: will make pointfree expressions even dottier...
10:33:42 <increpare> > pl \f xs -> xs >>= return . f  fmap
10:33:42 <increpare> (.)
10:33:43 <lambdabot>   <no location info>: parse error on input `\'
10:34:01 <increpare> :P
10:34:36 <sproingie> @pl \f xs -> xs >>= return . f  fmap
10:34:36 <lambdabot> fmap . ($ fmap)
10:35:35 <sproingie> i guess it's no worse than curried functions.  i like it.
10:35:38 <increpare> sproingie oops that fmap at thee end was a typo
10:35:48 <sproingie> @pl \f xs -> xs >>= return . f
10:35:48 <lambdabot> fmap
10:37:04 <increpare> > let (.) = fmap in ( (\x->x+1) . (\x->x*7) ) 5
10:37:06 <lambdabot>   36
10:37:29 <copumpkin> (.) already is fmap
10:37:39 <increpare> copumpkin: really?
10:37:45 <copumpkin> :t (.)
10:37:45 <mauke> :t head [(.), fmap]
10:37:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:37:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:37:52 <increpare> > (+3) . [2,3,4]
10:37:53 <lambdabot>   [5,6,7]
10:37:55 <increpare> oh
10:38:09 <increpare> copumpkin: so it is.
10:38:30 <increpare> copumpkin: prelude doesn't define it as such though?
10:38:47 <copumpkin> nope
10:39:01 <sproingie> @src (.)
10:39:02 <lambdabot> (f . g) x = f (g x)
10:39:08 <copumpkin> yeah, that's not in sync
10:39:08 <increpare> copumpkin: this this is one of those cases where some random other package overrides the prelude by default?
10:39:22 <copumpkin> Caleskell
10:39:27 <sproingie> where do i get this improved dot?
10:39:45 <sproingie> other than simply defining it myself
10:40:50 <Berengal> ... Let someone else define it for you?
10:41:03 <Berengal> I mean, someone has to define it, eventually...
10:41:30 <increpare> copumpkin: does cale have any other crazy modifications lurking about in lambdabot?
10:41:35 <copumpkin> :t flip
10:41:36 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:41:38 <copumpkin> :t (++)
10:41:39 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:42:07 <opqdonut> @src flip
10:42:07 * increpare thinks that "mmm" might not be a bad name for a concatenation operator
10:42:08 <lambdabot> flip f x y = f y x
10:42:16 <opqdonut> gah
10:42:38 <opqdonut> :t \x -> fmap ($x)
10:42:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
10:42:51 <opqdonut> yeh
10:43:51 <sproingie> :t ($)
10:43:52 <lambdabot> forall a b. (a -> b) -> a -> b
10:44:04 <sproingie> just checking
10:44:27 <increpare> $ is one of these really strange 90% totally intuitive operators
10:44:39 <opqdonut> indeed
10:44:41 <increpare> that's 10% opaque to me
10:44:56 <opqdonut> ($x) is just jargon for (flip id x) really
10:45:11 <increpare> @src ($)
10:45:12 <lambdabot> f $ x = f x
10:45:16 <copumpkin> ($x) is a lot clearer than flip id
10:45:21 <opqdonut> that too
10:45:59 <marsh_> What's everyone's work style: REPL with GHCI, or edit-compile-test-repeat with GHC?
10:46:08 <sproingie> flymake
10:46:19 <sproingie> er emacs + flymake
10:46:30 <increpare> @pl \ f x -> f x
10:46:30 <lambdabot> id
10:46:33 <opqdonut> ghc + ghci
10:46:39 <opqdonut> don't want to run my code unoptimised
10:47:05 <opqdonut> but yeah, i write in an editor
10:47:53 <increpare> :t id
10:47:54 <lambdabot> forall a. a -> a
10:47:56 <increpare> :t flip
10:47:57 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:48:00 <increpare> :t flip id
10:48:01 <lambdabot> forall a b. a -> (a -> b) -> b
10:49:56 <benignvulcan> I edit in one window and load into ghci with another.
10:50:00 <opqdonut> you see, flip forces the type of id to be (a -> b) -> (a -> b)
10:50:19 <opqdonut> which is then flipped into a -> (a -> b) -> b
10:51:02 <increpare> opqdonut: but
10:51:04 <increpare> :t ($)
10:51:06 <lambdabot> forall a b. (a -> b) -> a -> b
10:51:13 <int-e> @type flip . flip
10:51:14 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
10:51:43 <opqdonut> @scheck (/3) == flip (/) 3
10:51:44 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
10:51:45 <lambdabot>    arising from a use of `GHC.Cla...
10:51:47 <opqdonut> gah
10:51:56 <opqdonut> @scheck \x (/3) x == flip (/) 3 x
10:51:57 <lambdabot>   Parse error in pattern at "x" (column 9)
10:52:04 <opqdonut> @scheck \x -> (/3) x == flip (/) 3 x
10:52:05 <increpare> heh : P
10:52:06 <lambdabot>   "OK, passed 500 tests."
10:52:10 <opqdonut> now there :)
10:53:35 <chrisdone> marsh_: REPL WITH GHCI!!1
10:53:43 <sproingie> one
10:55:13 <chrisdone> you'll never get monads trying to use existing ones!
10:55:36 <chrisdone> you gotta discover monads and make 'em
10:55:37 <increpare> opqdonut: in prelude, flip is defined as (a->b->c)->b->a->c ; so how can flip be fed id?
10:55:52 <marsh_> and figure out how to use two at one time
10:56:10 <increpare> :t uncurry id
10:56:11 <lambdabot> forall b c. (b -> c, b) -> c
10:56:26 <increpare> hmm.
10:56:37 <mauke> id :: a -> a
10:56:42 <mauke> now set a = b -> c
10:57:48 <increpare> so flip id looks like ((b->c)->b->c) -> b->(b->c)->c?
10:58:02 <Saizan> yes
10:58:12 <Saizan> well, flip alone
10:58:31 <mauke> :t flip
10:58:32 <Saizan> when instantiated in such that it can take id as argument
10:58:32 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:58:35 <increpare> ah right
10:58:44 * hackagebot upload: SimpleAES 0.2 - Fast AES encryption/decryption for bytestrings (DavidHimmelstrup)
10:58:49 <monochrom> This is why the Turing test should include type-inference. :)
10:58:52 <mauke> :t P.flip
10:58:52 <lambdabot> Couldn't find qualified module.
10:59:07 <koeien37> :t Prelude.flip
10:59:08 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
10:59:30 <mauke> with a = b -> c
10:59:44 <increpare> @pf (\ f x y -> f y x)
10:59:45 <lambdabot> Maybe you meant: bf pl
10:59:50 <koeien37> :t Prelude.flip id
10:59:51 <lambdabot> forall b c. b -> (b -> c) -> c
11:00:07 <koeien37> there is only one (sane) function with this type
11:00:16 <increpare> @pl \f x y -> f y x
11:00:16 <lambdabot> flip
11:00:34 <increpare> >_<
11:00:54 <Saizan> @pl \x f -> f x
11:00:55 <lambdabot> flip id
11:04:19 <increpare> Saizan: what confuses me about this definition is that x$f is not f x
11:04:44 <Saizan> increpare: why should it be?
11:04:48 <koeien37> why would it be?
11:04:53 <koeien37> ($) = id
11:05:30 <increpare> oh.  I misread "($x) is just jargon for (flip id x) really"
11:05:40 <Saizan> it is
11:05:50 <koeien37> well, ($ x) is a lot clearer than (flip id x) imo
11:05:52 <increpare> yep
11:05:53 <Saizan> but ($x) = \f -> f $ x
11:06:00 <sproingie> > let x € f = f x
11:06:01 <lambdabot>   not an expression: `let x € f = f x'
11:06:18 <sproingie> > let x € f = f x in 1 € succ
11:06:19 <lambdabot>   2
11:06:23 <increpare> @pl ($)
11:06:23 <lambdabot> id
11:06:44 <sproingie> damn putty still can't compose a euro
11:06:57 <koeien37> the definition of ($) is really easy as you see, but the value lies in the priority of ($)
11:06:59 <increpare> I'm just going to think of ($) as being a low-priority identity, so : )
11:07:03 <koeien37> correct
11:07:58 <pikhq> koeien37: Only one function with that type? Buh, buh \_ _->undefined!
11:08:06 <koeien37> pikhq: i said "sane" :)
11:08:15 <pikhq> :)
11:08:33 <ray> total
11:08:34 <koeien37> in order to avoid these pathological cases. "total" might be better
11:08:36 <koeien37> right
11:08:47 <pikhq> Carry on, then.
11:09:16 <koeien37> if you allow seq there are even more possibilities
11:09:40 * increpare chortles
11:10:15 <Philonous> Even without seq you have f = undefined, f x = undefined, and f x y = undefined
11:10:29 <koeien37> how are these different?
11:10:49 <koeien37> (without seq, that is)
11:10:55 <increpare> koeien37: can you show that they're the same? : P
11:11:24 <pikhq> koeien37: Fail at different levels of curry.
11:11:25 <Philonous> koeien37: Errrrr, right. You need seq to witness the difference
11:11:40 <pikhq> ... Erm, no.
11:11:46 <pikhq> Fail at different points with seq.
11:12:18 <koeien37> increpare: not rigorously, because I don't have a background in lambda calculus. But I seem to remember that undefined = const undefined
11:12:44 <koeien37> where "a = b" means that a and b behave the same
11:14:33 <increpare> koeien37: ah okay, but this is not a truth within the language itself
11:15:14 * increpare idly wonders if anyone has written a paper relating Haskell's bottom to the Deleuzian notion of difference.
11:15:21 <koeien37> checking whether a function of type String -> String (say) is equal to \_ -> undefined seems to be equivalent to the Halting problem
11:16:20 <marsh_> I tried to read a book on that once, it was way over my head. But I still have a question about it
11:16:40 <increpare> marsh_: namely?
11:16:47 <marsh_> It seemed like haskell's "bottom" was really what this author was referring to as "top"
11:17:14 <marsh_> The real non-termination value can never be produced, IIRC
11:17:33 <koeien37> it's not some kind of "value" that is returned
11:17:51 <koeien37> semantically, perhaps, but not 'in reality'
11:18:48 <koeien37> e.g. f :: Int -> Int; f _ = f 37
11:18:56 <koeien37> this is _|_
11:19:10 <increpare> :t isBottom
11:19:11 <lambdabot> Not in scope: `isBottom'
11:19:21 <increpare> :t Test.QuickCheck.Batch.isBottom
11:19:23 <lambdabot> Couldn't find qualified module.
11:19:38 <koeien37> that's a pretty hard problem :P
11:19:39 <increpare> well there is an isbottom function somewhere anyway.  This is funny.
11:19:50 <koeien37> although it can probably detect a call to error
11:20:18 <marsh_> OK, but    f _ = 37  is not _|_
11:20:31 <koeien37> no
11:20:42 <koeien37> (there is also an f on the RHS of the definition)
11:21:09 <marsh_> Oh, is that some definition of bottom you gave?
11:21:16 <koeien37> an example
11:21:24 <koeien37> x = x is easier
11:21:46 <marsh_> This book has nice hand-drawn diagrams of lattices and power sets
11:21:50 <increpare> marsh_: it might be, if there was an error that happened when trying to evaluate f?
11:22:02 <rictic> Can someone recommend a library for outputting a very simple (potentially infinite) XML stream?
11:22:23 <marsh_> but it says "bottom" is the interval [-inf, inf] "this gives no information at all, and is therefore weaker than every other interval in our ordering"
11:22:49 <monochrom> Different lattices have different bottoms.
11:22:50 <koeien37> that is probably in some kind of lattice
11:22:56 <koeien37> a lattice can have a bottom
11:22:59 <koeien37> (and a top)
11:23:07 <marsh_> whereas "top" is [0,1] U [2,3] "which contain inconsistent information"
11:23:40 <marsh_> "So bottom dentoes the absence of information, and top dentoes too much information, to the extent of contradiction"
11:23:41 <increpare> yeah in lattices top and bottom are pretty innocuous things
11:24:06 <marsh_> Neither of these sound like the non-termination "bottom"
11:24:43 <monochrom> Of course not.
11:25:02 <marsh_> Well, I was a little proud of my insight :-)
11:25:19 <increpare> marsh_: is bottom bottom in the categorial sense of being a terminal object? (there is exactly one function from any a to the set with bottom in it)
11:25:29 <koeien37> a poset defines a category
11:25:54 <koeien37> the objects are the elements of the poset, and there is an arrow A -> B iff A <= B.
11:26:07 <koeien37> (.) is defined in the obvious way
11:26:12 <increpare> koeien37: I've seen some tasty things done with categories and posets
11:26:38 <koeien37> bottom sounds more like an initial object to me, but I'm no expert
11:27:05 <doserj> koeien37: that just depends on the direction of the arrows
11:27:23 <increpare> koeien37: how do you define a function from bottom->Int ?
11:27:24 <koeien37> doserj: well. yes. using my definition
11:27:28 <marsh_> he has neat tables of "doubly strict or" and "additive or" where bottom and top interact in different ways
11:27:38 <monochrom> You can use lattices or partial orders for many different purposes, not  just non-termination.
11:27:57 <increpare> doserj: the direction of the arrows is not without importance in this context : P
11:27:59 <koeien37> increpare: I don't understand your question. is "bottom" some type?
11:28:36 <increpare> koeien37: yeah actually I don't think the problem is well-posed at all. I don't know really how to set it up either - I am not on intimate terms with Bottom.
11:28:52 <koeien37> some posets have one
11:29:02 <marsh_> I think it's something in the domain of most/all types
11:29:27 <marsh_> but it can never actually be produced, so how would a function of bottom ever be evaluated?
11:29:40 <koeien37> is it like Void ?
11:29:49 <koeien37> (the empty type)
11:30:00 <increpare> koeien37: in its awkwardness, I guess
11:30:01 <koeien37> well, it has _|_
11:30:15 <marsh_> this author says "bottom is interpreted as the result of a non-terminating computation"
11:30:21 <koeien37> correct
11:30:29 <koeien37> that is most often the usage in Haskell
11:30:51 <sproingie> bottom is a value any type can be
11:30:59 <sproingie> void is Unit
11:31:00 <increpare> Hask, as a lattice has a bottom, namely ()
11:31:03 <monochrom> I am not sure what is "a function of bottom". It's ambiguous.
11:31:03 <ToxicFrog> Haskell's numeric type handling is driving me up the wall.
11:31:14 <koeien37> ToxicFrog: why?
11:31:26 <marsh_> Seems like it might have some utility in parallelism
11:31:37 <ToxicFrog> koeien37: I'm trying to get the number of digits in an Int, as an Int.
11:31:46 <koeien37> aha
11:31:51 <koeien37> what is your approach?
11:31:55 <ToxicFrog> So my first cut at this is numdigits x = floor (logBase 10 x)
11:32:05 <mauke> that's almost right
11:32:14 <mauke> but you can't logBase an Int
11:32:22 <ToxicFrog> And then I end up in Floating Int RealFrac hell, and I don't know how to escape.
11:32:27 <koeien37> :t floor . logBase 10 . fromIntegral
11:32:28 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
11:32:31 <mauke> convert Int to Double first
11:32:35 <mauke> with fromIntegral
11:32:44 <ToxicFrog> Aah
11:32:50 <koeien37> :t fromIntegral
11:32:51 <lambdabot> forall a b. (Integral a, Num b) => a -> b
11:33:05 <koeien37> Int is an instance of Integral, and Double is an instance of Num
11:33:11 <mauke> and then you have to deal with all the special cases :-)
11:33:12 <marsh_> isn't it (1 +) that?
11:33:23 <ToxicFrog> marsh_: so it is. Good catch
11:33:28 <mauke> > length $ show 666
11:33:29 <lambdabot>   3
11:33:36 <koeien37> marsh_: there are some problems with 0, and rounding, and negative numbers too
11:33:51 <ToxicFrog> ...
11:33:54 <marsh_> Yeah I had to write that in another language a few months ago
11:34:03 <koeien37> length . show is a nice trick, yeah
11:34:06 <ToxicFrog> mauke: I'm kicking myself right now
11:34:16 <koeien37> > length . show $ 0
11:34:17 <lambdabot>   1
11:34:20 <koeien37> > length . show $ (-37)
11:34:21 <lambdabot>   3
11:34:31 <mauke> ToxicFrog: my work here is done!
11:34:52 <merijn> koeien37: You could pattern match against 0 and leading -, though
11:34:53 <marsh_> yeah but it takes more than two asm instructions that way
11:35:12 <sproingie> > let digits = ceiling . logBase 10 . abs . fromIntegral in digits (-1234)
11:35:14 <lambdabot>   4
11:35:20 <koeien37> @def f = (1+) . floor . logBase 10 . fromIntegral
11:35:20 <lambdabot> Maybe you meant: bf do let
11:35:33 <koeien37> @let f = (1+) . floor . logBase 10 . fromIntegral
11:35:34 <lambdabot>  Defined.
11:35:41 <koeien37> > f 373737373737
11:35:42 <lambdabot>   Ambiguous occurrence `f'
11:35:42 <mauke> koeien37: fail
11:35:42 <lambdabot>  It could refer to either `L.f', defined at <local...
11:35:48 <sproingie> er floor right
11:35:51 <ezyang> Hey all; what does a type decl inside of an instance declaration mean?
11:36:00 <koeien37> ezyang: associated types
11:36:01 <sproingie> > let digits = floor . (+1) . logBase 10 . abs . fromIntegral in digits (-1234)
11:36:02 <lambdabot>   4
11:36:07 <koeien37> now try some large number.
11:36:16 <koeien37> preferrably close to 10^n for some n
11:36:20 <ezyang> koeien37: Thanks! Firing up the googlemeister.
11:36:23 <monochrom> . o O ( How do you kick yourself? Wouldn't it be equivalent to yoga master? )
11:36:40 <sproingie> > let digits = floor . (+1) . logBase 10 . abs . fromIntegral in digits (123456789012345678901234567890)
11:36:41 <lambdabot>   30
11:37:13 <koeien37>  let digits = floor . (+1) . logBase 10 . abs . fromIntegral in digits (10^30-1)
11:37:17 <koeien37> gives 30 on my system
11:37:22 <koeien37> > let digits = floor . (+1) . logBase 10 . abs . fromIntegral in digits (10^30-1)
11:37:23 <lambdabot>   30
11:37:39 <sproingie> aint that a kick
11:38:11 <sproingie> > let digits = (+1) . logBase 10 . abs . fromIntegral in digits (10^30-1)
11:38:11 <int-e> > let digits = floor . (+1) . logBase 10 . abs . fromIntegral in digits (10^40-1)
11:38:12 <lambdabot>   30.999999999999996
11:38:12 <lambdabot>   41
11:38:20 <EnglishGent> a quick question - is there a haskell package that will let me use Haskell as a graphical calcuator? for plotting curves
11:38:32 <sproingie> > floor 30.999999999999996
11:38:33 <lambdabot>   30
11:38:39 <sproingie> (duh)
11:38:42 <EnglishGent> *ideally* I'd like to be able to pass in a function Real -> Real -> Bool & have that define a canvas
11:39:02 <doserj> > let digits = floor . (+1) . logBase 10 . abs . fromIntegral in digits (10^350-1)
11:39:03 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
11:39:29 <marsh_> hmmm
11:39:44 <koeien37> EnglishGent: try gnuplot
11:39:52 <sproingie> the hell?
11:40:00 <ToxicFrog> That looks unhealthy
11:40:04 <sproingie> :t logBase
11:40:05 <EnglishGent> ty koeien :)
11:40:05 <koeien37> infinity
11:40:05 <lambdabot> forall a. (Floating a) => a -> a -> a
11:40:09 <int-e> > floor . (+1) . logBase 10 . abs . fromIntegral $ 0
11:40:09 * ezyang holds an unreasonable grudge against gnuplot 
11:40:10 <lambdabot>   -17976931348623159077293051907890247336179769789423065727343008115773267580...
11:40:19 <koeien37> EnglishGent: not sure if it does what you want though.
11:40:20 <int-e> yay!
11:40:22 <marsh_> ieee double limit?
11:40:48 <doserj> > let infty = 1/0::Double in floor infty
11:40:49 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
11:40:54 <int-e> > 2^1024
11:40:55 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
11:41:05 <blackh> EnglishGent: Chart is really brilliant - it's a Haskell implementation. You need to have gtk2hs installed for it to work.
11:41:10 <marsh_> 10^309 is where it breaks
11:41:16 <int-e> > -2^1024 == (floor . (+1) . logBase 10 . abs . fromIntegral $ 0)
11:41:17 <lambdabot>   True
11:41:21 <Accidus> > 10^309
11:41:22 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
11:41:52 <Nomad010> i don't think so
11:42:19 <koeien37> blackh: the screenshots are cool :D
11:42:20 <blackh> EnglishGent: Chart draws charts, which I suppose is not surprising. :)  I am with ezyang - I don't like gnuplot, mostly because it's incredibly difficult to configure.
11:42:37 <marsh_> Prelude> let digits = floor . (+1) . logBase 10 . abs . fromIntegral in digits (10^308)
11:42:37 <marsh_> 309
11:42:37 <marsh_> Prelude> let digits = floor . (+1) . logBase 10 . abs . fromIntegral in digits (10^309)
11:42:37 <marsh_> 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
11:42:38 <marsh_> P
11:42:40 <sproingie> i suspect repeated %10 might be in order.  that or just use length . show
11:42:51 <koeien37> i don't like gnuplot that much myself, but it gets the job done for my needs
11:43:06 <koeien37> does Chart have PNG or EPS export?
11:43:12 <ezyang> Apparently it's decent for programmatic use.
11:43:30 <blackh> koeien37: It definitely has PNG - it has whatever cairo has
11:43:32 <ezyang> but the last time I had some code that shelled to gnuplot, I rewrote it to use matplotlib
11:43:54 <koeien37> blackh: cool. Then it will try it
11:44:03 <blackh> ezyang: Chart is excellent mainly because it's written in Haskell, so it's got a very nice Haskell programmatic interface
11:44:03 <sproingie> @instances Floating
11:44:04 <lambdabot> Double, Float
11:44:10 <sproingie> no arbitrary precision for you there
11:44:24 <koeien37> no CReal ?
11:44:29 <ezyang> blackh: Haven't had to plot in Haskell; will keep Chart in mind when I do. :-)
11:44:38 <roboshibby> in x = 5, could you say x is an alias for 5?
11:44:46 <sproingie> it is 5
11:44:49 <koeien37> more or less
11:44:53 <koeien37> x IS equal to 5
11:44:55 <int-e> sproingie: http://www.mail-archive.com/haskell-cafe@haskell.org/msg63957.html
11:45:04 <roboshibby> so no alias?
11:45:04 <koeien37> x is defined to be 5
11:45:07 <koeien37> upon evaluation
11:45:08 <marsh_> You could even say "x = 5" about it
11:45:38 <sproingie> you could say alias in the sense that it's a name
11:45:40 <koeien37> (in fact, it's fromIntegeger 5)
11:45:42 <roboshibby> im trying to think of the proper term for label synonyms
11:45:55 <sproingie> fromIntegiggity 5
11:45:58 <koeien37> fromInteger*
11:46:00 <roboshibby> identifier synonyms that is
11:46:10 <koeien37> Chart-0.12 doesn't compile for me :(
11:46:15 <sproingie> "name"
11:46:20 <roboshibby> like x = 5; y = x. what is y to x? my thought was alias
11:46:28 <marsh_> "constant variable" is my favorite
11:46:37 <koeien37> it's not really a variable
11:46:50 <sproingie> y does not alias x.  x is 5, y is the value of x.  x will not change.
11:46:56 <blackh> roboshibby: A let binding is not quite the same as an alias, because a let-bound value is only evaluated once, whereas if you gave the expression directly, it would be evaluated once each time you refer to it.
11:47:21 <koeien37> blackh: is this a property of GHC or of Haskell ?
11:47:25 <roboshibby> hrm
11:47:26 <marsh_> hmmm
11:47:35 <alexsuraci> hmmmmm
11:47:42 <marsh_> harumph
11:48:03 <roboshibby> so then what would you call y properly?
11:48:07 <sproingie> 5
11:48:10 <ToxicFrog> How do I load a module in the source? I know I use :m in ghci, but what if I want it autoloaded when the source file is run?
11:48:14 <roboshibby> no i mean, what category of thing is it
11:48:21 <sproingie> a binding
11:48:21 <koeien37> ToxicFrog: import YourModuleName
11:48:28 <roboshibby> could you call it, a synonym?
11:48:33 <sproingie> you could
11:48:37 <ToxicFrog> Thankyou
11:48:37 <koeien37> a definition, a binding (of a name to a value)
11:48:45 <blackh> koeien37: I don't know, but I know that haskell 98 is very unspecific about when evaluation takes place, so it's probably a property of GHC
11:48:47 <sproingie> definition is probably more common
11:48:48 <marsh_> aside from the fact that x is just about as evaluated as it's going to get, just referring to it won't cause it to be evaluated (laziness)
11:48:50 <koeien37> ToxicFrog: it's important that your files are named ModuleName.hs
11:48:57 <sproingie> if it's in a let, it's usually called a binding
11:49:01 <sproingie> same thing really
11:49:27 <koeien37> ToxicFrog: and you should have "module ModuleName where" at the top
11:49:35 <koeien37> this way GHC knows where to get your files
11:50:18 <roboshibby> so it seems x = 5; y = 5, y is an alias for 5. (another name for that value) yet in x = 5; y = x, y is a synonym for x, and by indirection is the value 5
11:50:22 <roboshibby> like a symlink
11:50:34 <koeien37> this may be how it's implemented, but it's not how i think of it
11:50:52 <roboshibby> im really not even thinking specifically to how haskell works, but rather how my mind should think
11:50:58 <koeien37> in Haskell, definitions don't change
11:51:08 <koeien37> x = 3; x = x + 1 makes no sense
11:51:18 <koeien37> so it's really just substition
11:51:25 <sproingie> exactly
11:51:32 <koeien37> if your program encounters an x somewhere, it will be substituted for a 5
11:51:35 <blackh> roboshibby: In terms of thinking, it is an alias
11:51:48 <sproingie> koeien37: exactly
11:51:58 <roboshibby> blackh, in that it's a value by 'an other' name?
11:52:01 <koeien37> note, that you *can* write down x = x + 1
11:52:19 <koeien37> if you then evaluate x, it becomes, x + 1, which becomes (x+1)+1, then ((x+1)+1)+1, and so on
11:52:23 <marsh_> to me "alias" implies some kind of object identity and referencing
11:52:27 <koeien37> you will run out of memory
11:52:30 <Philonous> roboshibby: in x=5; y=5 initially y really refers to x, but once it gets evaluated, it's definition is replaced by it's value
11:52:44 <koeien37> x = 5; y = x, you mean
11:52:51 <roboshibby> ya that threw me too
11:52:52 <Philonous> Yes
11:52:57 <ezyang> Huh, I guess there's no docs on how to use WrapFailure.
11:53:11 <roboshibby> marsh, i see alias as an identity issue as well
11:53:12 <sproingie> in haskell, it's actually simpler than anything else.  wherever you see x = foo, you can just textually replace x with foo everywhere you see it
11:53:14 <koeien37> if your program demands the evaluation of 'y', then it will be substituted for 'x', which will in turn be substituted for 5
11:53:19 <roboshibby> transient identity
11:53:32 <ToxicFrog> koeien37: I'm not writing modules; I needed to load Char.
11:53:35 <koeien37> (The compiler will generally be smart enough to do this for you at compile-time)
11:53:41 <ToxicFrog> But thanks.
11:53:42 <koeien37> ToxicFrog: oh. Then import Data.Char
11:53:52 <blackh> roboshibby: You have to remember that Haskell has no concept of "identity" other than what's defined by the Eq typeclass.  So there's no semantic difference whatsoever between x where x = 5 and 5.  The only differences are to do with evaluation.  It's always the same or faster to use a let binding.
11:53:59 <koeien37> you can also import it "qualified", but it's not necessary for Data.Char
11:54:01 <blackh> (I think this is GHC-specific, though)
11:54:20 <roboshibby> interesting
11:54:26 <roboshibby> haskell sounds very cool
11:54:31 <koeien37> correct! :)
11:54:31 <sproingie> i like either explicit imports or qualified imports
11:54:33 <roboshibby> different from my ruby/objc
11:54:43 <sproingie> the default behavior of haskell doing a *-import drives me nuts
11:54:45 <koeien37> sproingie: yeah, but not if you're toying around with Data.Char initially
11:54:55 <koeien37> sproingie: I like python-style imports
11:55:05 <koeien37> the default should be qualified
11:55:14 <sproingie> amen
11:55:19 <sproingie> not likely to change now tho
11:55:22 <ToxicFrog> Argh. I'm sure this code could be better, but I can't see why it's stackoverflowing
11:55:27 <koeien37> ?hpaste
11:55:28 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:55:33 <blackh> roboshibby: Haskell is extremely cool. I could go on about it all day. :)
11:55:48 <roboshibby> :D
11:55:55 <koeien37> roboshibby: I immediately fell in love too :)
11:56:26 <koeien37> referential transparency, a strong type system, and FP in general
11:56:37 <sproingie> blackh: given the amount of time some of us spend on IRC, some of us do :)
11:56:43 <Philonous> blackh: I've heard about a place where everyone is constantly talking about haskell
11:56:53 <koeien37> sproingie: are you referring to somebody in particular ;)
11:57:11 <mreh> does anyone in here do Haskore hacking?
11:57:13 <sproingie> koeien37: i'm guiltier than most
11:57:26 <roboshibby> what's referential transparency?
11:57:29 <sproingie> avoiding doing work
11:57:32 <ToxicFrog> koeien37: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5637#a5637
11:57:44 <koeien37> roboshibby: "f x" always gives the same result
11:57:45 <mreh> if only I could do haskell for work :(
11:57:48 <blackh> Philonous, sproingie, roboshibby: Typical #haskell conversation: A. Haskell is so awesome! B. Isn't Haskell awesome?
11:57:57 <roboshibby> :P
11:58:10 <roboshibby> koeien37: hrm?
11:58:29 <koeien37> roboshibby: normally, you'd write something like "diceRoll = random(1,6)" in some other language
11:58:38 <roboshibby> sure
11:58:39 <koeien37> in Haskell this is not possible, since diceRoll will always give the same result
11:58:42 <blackh> roboshibby: Do not underestimate the importance of referential transparency.  Haskell has a lot of cool features, but referential transparency is by far the biggest thing.
11:58:56 <roboshibby> blackh, can you define it in your words please?
11:59:01 <koeien37> also, functions do not have side effects
11:59:04 <roboshibby> koeien37: how would you set that up in haskell then?
11:59:22 <koeien37> if i see a function of type Int -> Int, i *know* that it will not write something to disk, or talk to the network, or w/e
11:59:23 <ToxicFrog> roboshibby: the result of a function call is dependent only on its arguments, and calls do not have side effects.
11:59:35 <blackh> roboshibby, referential transparency in my words: "The output of a function depends *only* on its inputs"
11:59:39 <koeien37> roboshibby: we would, for example, create an infinite list of random numbers and consume from that
12:00:04 <sproingie> the other cool thing about purity (which includes referential transparency) is you know you can execute functions whenever you want, or not at all if you don't need them
12:00:05 <roboshibby> hmm
12:00:16 <blackh> roboshibby: This implies that all values are immutable.
12:00:20 <roboshibby> like a global namespace?
12:00:24 <marsh_> int getRandomNumber() { return 4; // chosen by fair dice roll. // guaranteed to be random. }
12:00:33 <ToxicFrog> This allows some vicious optimization, easier program verification, and lazy evaluation (which in turn implies you can do things like work with infinite lists)
12:00:37 <koeien37> ToxicFrog: I don't immediately know where the problem is, but i know that "foldl (+) 0" is a space leak
12:00:43 <ToxicFrog> At the cost of making some things (like file IO) harder to express.
12:00:50 <koeien37> ToxicFrog: not really
12:00:53 <ToxicFrog> koeien37: what should I be using instead?
12:00:55 <sproingie> lazy evaluation is a two-edged sword
12:01:00 <koeien37> ToxicFrog: foldl' from Data.List
12:01:18 <koeien37> (strict foldl')
12:01:21 <roboshibby> blackh, but isnt that just a proper mathematic function? (that 1 set of inputs correlate exactly to 1 other set of ouputs)
12:01:26 <koeien37> roboshibby: yes
12:01:34 <blackh> roboshibby: Exactly so
12:01:36 <koeien37> haskell functions are "proper mathematical functions"
12:01:46 <sproingie> except for IO actions anyway
12:01:51 <roboshibby> well i certainly like that
12:02:01 <sproingie> they may sling RealWorld around underneath but you don't see it happen
12:02:01 <mercury^> But types are not normal sets. :)
12:02:04 <koeien37> sproingie: also for IO actions
12:02:10 <koeien37> IO is not really special
12:02:27 <koeien37> except that there is a secret IO evaluator in runtime
12:02:44 <koeien37> getLine always gives the same reuslt
12:02:56 <roboshibby> i dont want to leave the conversation but nature calls with loud voice. thanks for the help guys... ill bbiab :D
12:03:01 <koeien37> i.e., an action that, when performed, queries for a line of input and returns the result
12:03:04 <blackh> roboshibby: An important point about Haskell is - IO is still handled "purely".  A Haskell program does not do I/O - what it does is evaluate an IO action purely, which the runtime then executes.
12:03:19 <marsh_> The IO does Haskell
12:03:22 <roboshibby> mmm sounds cool
12:03:24 <sproingie> learning that about IO was really an eye-opener for me
12:03:34 <sproingie> because you can use the same action approach yourself for other stateful gunk
12:03:35 <blackh> roboshibby: See ya!
12:03:44 <roboshibby> ah so actions are in a sense autonomous?
12:03:53 <sproingie> don't perform the action there, just return an action that tells an evaluator to do it
12:03:54 <roboshibby> not 'open' to external state in the app
12:03:57 <koeien37> you can have a list of actions
12:04:03 <koeien37> for example. They are not special
12:04:15 <roboshibby> ack gotta go so bad brb
12:04:19 <blackh> roboshibby: An IO action like 'putStrLn "hello"' has type IO () - this *represents* an IO action - it doesn't run it
12:04:27 <koeien37> map (>> putStrLn "Hello!") [putStrLn "37", print 42, talkToNetwork]
12:05:10 <marsh_> If I have two open sockets and operate on them both within "the" IO monad...does this enforce an ordering on all the operations even when some may be unnecessary?
12:05:12 <ToxicFrog> Found the problem.
12:05:18 <ToxicFrog> My definition of factorial is flawed
12:05:30 <koeien37> ah yes
12:05:31 <koeien37> 0
12:05:31 <ToxicFrog> fact 0 = -- stack overflow
12:05:34 <koeien37> now i see it too
12:05:54 <koeien37> foldl' solves a tiny space leak, but you wouldn't have noticed that
12:05:57 <blackh> marsh_: Chaining IO actions in the IO monad enforces the order of them as chained.
12:06:17 <koeien37> ToxicFrog: if you want to read more about that, see http://haskell.org/haskellwiki/Foldr_Foldl_Foldl'
12:06:26 <koeien37> basically you "never" want foldl
12:06:42 <marsh_> is there a straightforward way to 'pick and choose' which IO ops really need sequencing?
12:06:57 <ToxicFrog> koeien37: yeah, I went and looked that up after you mentioned foldl'
12:07:02 <Saizan> marsh_: genrally yes, you can mess with the order of side effects with unsafeInterleaveIO, but i'd rather just use threads
12:07:11 <Saizan> marsh_: forkIO is your friend :)
12:07:22 <blackh> marsh_: if then else ?
12:07:32 <koeien37> I don't think in Haskell there is a way to express commutative monads differently from monads really
12:07:51 <koeien37> maybe you want the Writer monad to be commutative if that'
12:08:01 <koeien37> d give some runtime performance improvement
12:08:22 <marsh_> Guess I'm just trying to drag along my C++ asynchronous IO baggage
12:08:40 <koeien37> and IO is certainly not a commutative monad
12:09:15 <marsh_> I tried making a CGI database app awhile back
12:09:19 <Berengal> I think Writer already is commutative, in that it doesn't specify an order of evaluation different from lazy evaluation
12:09:37 <koeien37> the "tell"s are always in order, right?
12:09:48 <koeien37> tell "a" >> tell "b" is different from tell "b" >> tell "a"
12:09:49 <Berengal> Yes, but the tells aren't commutative
12:09:55 <marsh_> I got a web page going in the CGI monad. And a query running in the Database monad. And then...
12:10:02 <koeien37> that is true, but if the result would be a multiset of Strings, it wuold be
12:10:04 <Berengal> But the tells don't have to be evaluated either
12:10:41 <sproingie> i should hope Writer's tells are always in order
12:10:43 <Saizan> marsh_: the most supported way for asynch IO is to use threads, they are lightweight so you can spawn lots of them and they get mapped for you on OS threads when necessary
12:10:49 <koeien37> sproingie: maybe you don't want that
12:10:54 <koeien37> it depends
12:11:07 <Berengal> marsh_: then you start looking for functions of type Database a -> IO a or CGI a -> IO a or IO a -> CGI a, or something like that
12:11:32 <koeien37> marsh_: heh. But even if those IO-heavy programs, I still like Haskell
12:11:45 <marsh_> IIRC "monad combinators" was where my head exploded
12:11:55 <koeien37> monad transformers?
12:12:01 <marsh_> Yeah that
12:12:15 <koeien37> they are not that magical, once you understand monads
12:12:27 <mjonsson> I'm finding myself wanting to run Data.Map.intersectionWith inside the Maybe monad... is there any elegant way to accomplish the equivalent?
12:12:38 <marsh_> Thing about Haskell is that a great deal of this abstraction is mandatory, even for simple apps.
12:12:54 <marsh_> Many C++ programmers spend their careers without ever specializing a template
12:13:07 <sproingie> that's a good way of putting it
12:13:18 <ben0x539> I was specializing templates before ever starting my 'career'
12:13:20 <koeien37> mjonsson: what do you mean?
12:13:25 <Berengal> mjonsson: intersectionWith is total. What should it do?
12:13:32 <sproingie> haskell's got a steep learning curve, no doubt about it
12:13:40 <koeien37> liftM2 (intersectionWith (...))
12:13:41 <koeien37> ?
12:13:54 <sproingie> i personally think it could be made a bit shallower
12:13:55 <mjonsson> essentially I want to form the intersection unless i hit an exceptional case
12:13:59 <Berengal> sproingie: Steep and neverending, it seems
12:14:23 <marsh_> Steep implies it should be short!
12:14:28 <sproingie> flat learning curves aren't good, it means there's nothing to learn.  but steep does make accessibility harder
12:14:32 <Berengal> mjonsson: So Map k a -> Map k b -> Map k (Maybe c) ?
12:14:33 <mjonsson> like mapM
12:14:38 <marsh_> At least it's monotonic
12:15:08 <mjonsson> (a -> a -> Maybe a) -> Map k a -> Map k a -> Maybe (Map k a)
12:15:08 <marsh_> I hope
12:15:17 <faldridge> Greetings all.  I'd like to learn a new language to expand my 'knowledge portfolio' and am primarily interested in scalable, 'real-time' web applications.  Should I start out with Haskell or Erlang?  My Google-fu tells me it's almost a toss up.
12:15:38 <sproingie> erlang will definitely get you jumping into scaling web apps
12:15:50 <koeien37> you ask #haskell, so you know the answer ;) but Erlang might be a better choice for you
12:16:11 <Berengal> @quote learning.*curve
12:16:11 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
12:16:23 <marsh_> How lazy are you?
12:16:25 <sproingie> haskell will stretch your brain more, erlang will be a snap
12:16:32 <koeien37> faldridge: I honestly can't say because I don't know Erlang well enough
12:16:44 <marsh_> What languages do you use and like now?
12:16:49 <sproingie> i'd love erlang to death if it had a nice sexp syntax
12:16:51 <faldridge> well, after staying in here a little while, I figured I'd get more than a few reasoned, non-advocy responses
12:16:58 <koeien37> Erlang reputedly has some pros in scalability
12:17:07 * hackagebot upload: hmatrix 0.8.0.0 - Linear algebra and numerical computations (AlbertoRuiz)
12:17:09 <dubhrosa> haskell will take about a year to get proficient in, erlang about two weeks, one day if you already know Haskell.
12:17:11 <faldridge> coming from a heavy python background
12:17:25 <faldridge> I've been working mostly with the twisted framework in python lately
12:17:29 <sproingie> haskell probably could give erlang a run for its money in scalability, but it's got nothing like erlang's OTP platform
12:17:36 <koeien37> sproingie: right
12:17:40 <faldridge> know PHP, C & C++ (though not nearly as well as python)
12:17:47 <skorpan> faldridge: fsck fp then, go for django
12:17:57 <koeien37> heh. django is really nice (expect for the python)
12:17:59 <sproingie> he said he wanted to expand his knowledge
12:18:12 <sproingie> and erlang is definitely a rising star in web apps
12:18:19 <marsh_> Do you like C++ static typing discipline or Python's dynamic/duck typing?
12:18:19 <dubhrosa> faldridge: then start with Erlang as your first fp, get Joe Armstrong's book, it's a great intro
12:18:46 <koeien37> marsh_: that is a bad question imho. I disliked static typing until I learned Haskell
12:19:07 <Berengal> faldridge: Erlang would probably be easier to get started in. Haskell will take longer, but it's also the most different from what you already know and will blow your mind the most.
12:19:14 <Saizan> you can't really use C++ as an example of how to do static typing :)
12:19:15 <faldridge> i've been interested in learning more about functional programming as well.
12:19:24 <sproingie> then hang around here :)
12:19:26 <koeien37> Erlang is also pure and functional
12:19:34 <dubhrosa> marsh_: I think that's a great question, I liked learning Erlang a lot but really missed static typing, really really missed it.
12:19:38 <marsh_> Saizan: under the hood it's a very similar type system
12:19:41 <koeien37> but it's dynamically typed :(
12:19:46 <faldridge> in java I found static typing to be a pain and useless (i've also spent some time with Java, btw)
12:19:57 <koeien37> yes, we would agree
12:19:58 <sproingie> haskell's type system is very useful and a different kind of pain
12:20:05 <Berengal> A good pain
12:20:06 <ToxicFrog> koeien37: some of us like dynamic typing :P
12:20:08 <koeien37> Erlang is probably easier to pick up, yes
12:20:09 <pikhq> koeien37: Erlang isn't pure.
12:20:16 <sproingie> it's more a bondage and discipline kind of pain.  you'll ask for more.
12:20:17 <marsh_> Haskell is all about static typing with aggressive type inference
12:20:18 <koeien37> pikhq: oh i thought it was.
12:20:33 <pikhq> koeien37: There exist side effects in Erlang.
12:20:36 <ToxicFrog> But I'm quite fond of Haskell's type system.
12:20:42 <dubhrosa> java isn't really a good example of static typing, since you often end up doing lots of dynamic casting from Object
12:20:43 <ToxicFrog> Except when the spiders come for me.
12:20:44 <koeien37> I thought you had to implement mutable state as a process.
12:20:56 <Berengal> pikhq: But immutability is the default most of the time, so's good.
12:20:56 <koeien37> pikhq: right, you do have side effects
12:21:00 <marsh_> You can't even do that in Haskell
12:21:14 <sproingie> erlang tends to confine mutable state to small areas.  it tends toward purity
12:21:25 <pikhq> Berengal: It's better than most in that regard, yeah. It's at least *mostly* pure.
12:21:26 <Saizan> marsh_: subtyping vs. bounded quantification, explicit signatures vs. type inference, template specialization vs. polymorphism, i'd say they are quite different in any but the most trivial aspects
12:21:40 <pikhq> But... You can just do output willy nilly!@
12:21:42 <koeien37> i toyed a bit with it. i disliked the syntax and lack of static typing compared to Haskell
12:21:53 <sproingie> frankly from all the IOrefs i'm using, i feel i'm writing pretty darn impure code
12:21:57 <sproingie> even if they are actually pure
12:22:02 <koeien37> but the magic that you can send functions to other processes running on other machines was really cool!
12:22:05 <pikhq> sproingie: You probably are, then.
12:22:17 <Berengal> sproingie: purely imperative ;)
12:22:19 <marsh_> Saizan: template function auto-detection = type inference
12:22:20 <sproingie> pikhq: OpenGL, can't help it.
12:22:26 <dubhrosa> I used erlang recently to create a pub-sub framework, it was excellent for that application, very much its chosen domain though
12:22:30 <pikhq> koeien37: The runtime system is the main appeal of Erlang, yeah.
12:22:31 <pikhq> sproingie: Ah.
12:23:02 <esdegan> hello, I was looking for doing IO inside parsec and found ParsecT, but found Text.Parsec is not in ghc?
12:23:08 <marsh_> Maybe like Java in that respect
12:23:11 <koeien37> in terms of frameworks, there are probably some cool Erlang web projects
12:23:16 <sproingie> esdegan: cabal install parsec
12:23:17 <koeien37> esdegan: not by default
12:23:31 <koeien37> Haskell has turbinado and Happstack and some other smaller things i guess
12:23:43 <sproingie> parsec's versioning is weird, i had to do cabal install 'parsec=3.*' to get parsec3
12:23:49 <Berengal> esdegan: parsec is a bit of a bother. It defaults to 2.1.somethingorother when 3 has been out for a while. It's one of *those* packages.
12:23:51 <sproingie> er parsec==3.*
12:23:51 <koeien37> happstack is really cool but a bit unstable/experimental
12:24:08 <koeien37> i don't know turbinado
12:24:25 <sproingie> erlang OTP is seriously battle-hardened and robust
12:24:29 <esdegan> thanks all
12:24:41 <koeien37> I would probably base my choice on the availability of a good Erlang web framework
12:24:41 <jlouis> OTP is very robust
12:24:50 <koeien37> if it exists, I'd go with that probably
12:25:08 <sproingie> yaws isn't bad
12:25:10 <koeien37> but Haskell is a better language :)
12:25:23 <jlouis> koeien37: I've come to that conclusion as well
12:25:31 <marsh_> Somebody needs to write Rails in 50 lines of Haskell and compile it with GHC and blow the Ruby interpreter out of the water
12:25:45 <sproingie> anyone ever implement erlang nodes in haskell?
12:25:57 <pikhq> sproingie: Yes.
12:25:57 <Saizan> sproingie: there's a lib on hackage
12:26:02 <koeien37> marsh_: sounds like Turbinado :)
12:26:20 <Paczesiowa> marsh_: why? isn't haskell's purpose to not allow such crappy code as ruby does
12:26:23 <koeien37> I really like Django (modulo python)
12:26:33 <sproingie> the deal with rails is that it takes advantage of ruby-isms
12:26:33 <skorpan> django is made out of win
12:26:40 <sproingie> i doubt you could clone that in haskell
12:26:52 <Berengal> I like happstack...
12:26:58 <skorpan> django makes superb use of python's reflection abilities
12:27:01 <jfischoff> the chat system at my company runs on erlang...works great
12:27:04 <koeien37> skorpan: correct
12:27:05 <kevinclark> ruby's dynamism is what makes rails possible, but doing static checks on ruby is really really hard
12:27:23 <marsh_> koein37: thanks for the link; Paczesiowa: good point
12:27:34 <sproingie> activerecord is a crappy ORM, erb is the worst view technology since the ASP
12:27:58 <kevinclark> probably
12:28:17 <skorpan> fuck i hate asp.net
12:28:22 <sproingie> asp.net is not bad
12:28:25 <marsh_> Hard to argue with that kind of success though (but I agree with you)
12:28:27 <sproingie> i'm talking about the original ASP
12:28:32 <kevinclark> but it's easy to work with, as long as you stick to the golden path (rails, not asp)
12:28:41 <Saizan> i hate python reflection abilites, they make most frameworks i've seen obscure beasts that you've to pray for benevolence </rant>
12:28:44 <sproingie> in fact i think the original ASP is prettier than erb
12:28:58 <marsh_> I have friends who swear by it, but it gives me the creeps
12:29:10 <koeien37> Saizan: IME django's magic is easy to work with
12:29:21 <skorpan> in original ASP you could actually grasp the order in which things happened.  in ASP.NET on the other hand, you're in for a treat if you stick an UpdatePanel into a user control which is in a user control.
12:29:26 <jlouis> jfischoff: ejabberd?
12:29:33 <jfischoff> ?
12:29:40 <jlouis> jfischoff: chat system, erlang
12:29:45 <koeien37> ejabberd is an XMPP server
12:29:51 <jfischoff> jlouis: no its for hi5
12:30:00 <jlouis> oh
12:30:02 <sproingie> ASP.NET is a component system, you assume everything on the page happens simultaneously
12:30:05 <jfischoff> jlouis: www.hi5.com
12:30:11 <koeien37> that sounds like Lift
12:30:31 <sproingie> lift is kind of its own thing
12:30:36 <skorpan> sproingie: it's way easier said than done
12:30:42 <sproingie> personally i like seaside
12:30:48 <marsh_> sprongie: Which is real *not* great from a security perspective
12:30:57 <jfischoff> could Lift be ported to haskell easily?
12:31:02 <sproingie> eh.  encrypt the viewstate or don't use it
12:31:15 <sproingie> something Tapestry never learned
12:31:21 <skorpan> you think "okay, this time i will not screw up.  it's not that hard!" and then you sit for weeks with a fucking "gridview" with a "datasource" that won't give you the information half of the time.
12:31:36 <jlouis> jfischoff: hah, that is definitely not me as a target audience, but it looks cool
12:31:37 <sproingie> jfischoff: i think it would lose a lot of its essential nature
12:32:00 <jfischoff> jlouis: hehe
12:32:03 <marsh_> or it sucks down the entire database blobs and all to cache at the client layer
12:32:17 <sproingie> skorpan: it's a mess, but take a look at JSF sometime.  same basic model but even *more* baroque and brittle
12:32:28 <skorpan> sproingie: never heard of JSP
12:32:29 <skorpan> JSF*
12:32:38 <jfischoff> Lift vs Rails, anyone have enough experience to compare?
12:32:49 <sproingie> lift doesn't come with screencasts
12:33:04 <skorpan> hehe
12:33:49 <sproingie> can't say i'm a fan of the "embedded xml" business that lift leverages in scala
12:33:56 <Paczesiowa> I've misread that as "life doesn't come with screencasts"
12:34:09 <sproingie> embedding xml in a language reminds me of how we used to have embedded SQL
12:35:03 * marsh_ shivers. Please can we change the subject?
12:35:44 <Paczesiowa> you're just jealous, because haskell doesn't have syntax powerful enough to embed xml
12:36:59 <marsh_> pretty close: http://www.krowland.net/tutorials/haxml_tutorial.html#bookmark5
12:37:08 <Saizan> > fix $ ((0:) . scanl (+) 1) -- have a fixpoint
12:37:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:37:34 <dolio> @google haskell server pages
12:37:36 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp/
12:37:37 <lambdabot> Title: HSP - Haskell Server Pages
12:38:41 <faldridge> skorpan: I really like django as well.  Since my current app has real-time needs, I'm considering an architecture like django for synch web view & ReST API, possibly orbited for asynch views, rabbitmq for communicatinb between parts, and then either erlang, haskell, or twisted/python for the real-time event & push historical data to a db piece.
12:38:59 <skorpan> uh-huh
12:39:42 <sproingie> i just read a blog post about some new REST stack in haskell
12:39:49 <faldridge> does something like that make sense to you guys?
12:40:03 <sproingie> sounds like a lot of engineering from the start
12:40:09 * faldridge has only been programming professionally for 2 years
12:40:24 <skorpan> faldridge: i don't eally know what "synch web view", ReST API, rabbitmq or "push historical data to a db piece" means.
12:40:36 <marsh_> faldridge: that is a big project, we have implemented something similar at work
12:41:52 <roboshibby> what does 'real time needs' mean?
12:42:15 <marsh_> all web apps are technically "real-time" (the browser has a fixed timeout), but most apps just ignore that point. If you have difficult real-time requirements (say <5 s) it takes you way out of the mainstream which can use off-the-shelf packages
12:42:18 <skorpan> that whole description sounded like a *lot* of name dropping and buzz wording
12:42:55 <Paczesiowa> prepozygohistomorphism!
12:43:05 <j4cbo> makes sense to me
12:43:08 <holmak> is there a high-resolution timer in the standard libraries or Hackage?
12:43:24 <faldridge> skorpan: object crud views and such that don't require comet/other hacks, an API for non-browser clients to retreive data (iphones, etc), a message queue, and a daemon that sends out notifications, etc upon receiving data and stores the incoming data to a db
12:43:24 <j4cbo> eww, twisted, though :/
12:43:34 <faldridge> skorpan: respectively
12:43:53 <chrisdone> Tea. Earl Grey. Hot.
12:43:53 <j4cbo> twisted is disgusting
12:44:00 <chrisdone> ^_^ ~ !
12:44:31 <faldridge> marsh: I need open browser pages to update whenever data comes in up to once per second
12:44:50 <marsh_> faldridge:  now consider that any of those components (or the net between them) will on occasion hang for 30 or more seconds at the worst possible time
12:45:17 <j4cbo> faldridge: what for?
12:45:23 <marsh_> the web wasn't designed for that. You can make it work (99% of the time anyway)
12:45:36 <faldridge> right now I've got almost every piece of this puzzle running in a single process with Divmod Mantissa and it's making me nervous
12:45:37 <faldridge> I
12:45:53 <faldridge> will be happier when and if Web Sockets deliver on their promises
12:45:59 <sproingie> the web is a pull system for mime.  whatever you can cram into a doc, the web was designed for it
12:46:15 <marsh_> This is a new one for me..Web Sockets?
12:46:24 <theorbtwo> Ah, good, I'm not the only one, then.
12:46:40 <mpiechotka> @pl (\a b -> liftA2 mappend (f a) b)
12:46:40 <lambdabot> liftA2 mappend . f
12:46:41 <dubhrosa> faldridge: is this an internal project that will run on a lan or a real wan - web project?
12:46:56 <j4cbo> oh, an HTML5 thing
12:46:57 <j4cbo> neat.
12:46:57 <faldridge> dubhrosa: real web project
12:47:03 <jlouis> chrisdone: Tea. Green. Hot!
12:47:21 <faldridge> yeah, it's just a draft for a protocol right now
12:47:25 <mpiechotka> @pl \f -> Data.Foldable.foldr (liftA2 mappend . f) (pure mempty)
12:47:26 <lambdabot> flip Data.Foldable.foldr (pure mempty) . (liftA2 mappend .)
12:47:53 <theorbtwo> faldridge: If you want a push protocol, make a real protocol, not some web thing?
12:47:55 <sproingie> technically it's a two-way system for mime doc transfer, but web servers never got written off the bat to much about receiving
12:48:05 <sproingie> *to do much
12:48:10 <marsh_> theorbtwo: amen
12:48:29 <theorbtwo> Now, the web is good at many things... but push isn't really one of them.
12:48:31 <j4cbo> theorbtwo: there's a *lot* to be said for "the only client you need is a web browser"
12:48:35 <j4cbo> a whole hell of a lot
12:48:49 <theorbtwo> j4cbo: Quite true.
12:49:15 <marsh_> Yeah like "no major web app stays that way for long because web browsers are by definition little sandboxes"
12:49:22 * j4cbo dabbles in web dev occasionally, when nobody's looking.
12:49:23 <dubhrosa> faldridge: you'll need a middleware like rabbitmq / openamqp for something with lots of distributed components, but does it have to be guaranteed delivery? seems like overkill unless there's something physical happening on the other end...
12:49:46 * j4cbo prefers to do his in ML, lately
12:49:57 <elly> j4cbo: we all know you do it
12:50:10 <j4cbo> busted!
12:50:23 <maltem> jlouis, Nettle tea. 20pm. Hot!
12:50:31 <marsh_> First bit of advice: look at all your transactions and see how many of A, C, I, and D you can throw out of the initial design
12:50:36 <faldridge> dubhrosa: definitely need guaranteed delivery.
12:51:07 <faldridge> marsh: makes sense.
12:51:41 <marsh_> faldridge: so do you really need redundant transactional data stores, or can you live with MQ for a few minutes downtime?
12:51:48 <Paczesiowa> you all try to sound as cool as ruby people. what happened to geeky CT stuff?
12:52:03 <marsh_> sorry
12:53:31 <Paczesiowa> I forgive you. now go read 20 posts on comonad-reader
12:53:42 <sproingie> statically prove guaranteed delivery.  there.
12:54:20 <sproingie> funny thing is on other places i frequent, "CT" == "Conspiracy Theory"
12:55:00 <Paczesiowa> dual to Nspiracy Theory?
12:55:16 <faldridge> marsh_: well, I'm receiving sensor data from some hardware and sending commands to that hardware via the message queue, and if the command doesn't get to the hardware in time, bad things could happen
12:55:57 <marsh_> This raises an interesting question, could one use Haskell (lazy, GC, etc) for a hard real-time system?
12:56:11 <faldridge> likewise, if some sensor data never gets processed, alarms might not go off and/or events might not be triggered, which could be basically catastrophic.
12:56:48 <marsh_> faldridge: sorry this doesn't sound like a job for javascript and HTTPS to me
12:57:25 <pikhq> marsh_: No, but one could use Haskell to generate a hard real-time system.
12:57:26 <pikhq> See atom.
12:57:44 <faldridge> marsh_: yeah, I'm beginning to wonder about that myself.
12:58:18 <marsh_> pikhq: Haskell's greatness is truly without limit!
12:58:31 <pikhq> marsh_: New to Haskell? ;)
12:58:53 <maltem> Much depends on how real-time is real-time, and how much memory you have to spare :P
12:58:58 <sproingie> haskell's runtime won't cut the mustard for realtime.  there is atom, however
12:59:42 <marsh_> faldridge: Let me know if you want to connect off the channel, we've developed some similar stuff at work
13:00:08 <sproingie> @hackage atom
13:00:08 <lambdabot> http://hackage.haskell.org/package/atom
13:00:50 <sproingie> @hackage dfgsedfgxdfghxf
13:00:51 <lambdabot> http://hackage.haskell.org/package/dfgsedfgxdfghxf
13:00:58 <sproingie> bah.  i expected it would actually have the package index
13:01:06 <shapr> Where do I get Graphics.UI.SDL.Video?
13:01:16 <shapr> @find Graphics.UI.SDL.Video
13:01:17 <lambdabot> Couldn't find qualified module.
13:01:29 <sproingie> @hayoo Graphics.UI.SDL.Video
13:01:29 <lambdabot> Unknown command, try @list
13:01:32 <Teggy> "If you do not travel, you will marry your own sister." —Mozambican Proverb
13:01:34 <sproingie> bah
13:01:34 <yitz> @hoogle Graphics.UI.SDL.Video
13:01:35 <lambdabot> No results found
13:01:40 <yitz> @google Graphics.UI.SDL.Video
13:01:41 <lambdabot> http://hackage.haskell.org/packages/archive/SDL/0.5.9/doc/html/Graphics-UI-SDL-Video.html
13:01:42 <lambdabot> Title: Graphics.UI.SDL.Video
13:01:45 <shapr> ah
13:01:54 <Teggy> Hi shapr.
13:02:00 <sproingie> base SDL package looks like
13:02:04 <shapr> hiya Teggy, how's life?
13:02:24 <Teggy> shapr, everything up and running around here, thanks
13:02:43 <shapr> Databases being exciting?
13:02:49 <Teggy> You bet.
13:03:07 <faldridge> marsh_: I would like to.  I'd like to discuss my system with someone else in the same problem domain.  Will you be here around the same tomorrow, though?  I have to leave now to pick up my little girl.
13:03:15 <yitz> @vixen "If you do not travel, you will marry your own sister." — Mozambican Proverb
13:03:16 <lambdabot> I'm sorry, I'm confused.
13:03:21 <faldridge> same time tomorrow, that is
13:04:26 <marsh_> faldridge: let's email, I'm  marsh@extendedsubset.com
13:06:25 <Paczesiowa> fundeps are like 10 years old, right? how come there haven't been any new ideas since then?
13:06:39 <sproingie> says who?
13:06:41 <ivanm> Paczesiowa: type families?
13:07:14 <Paczesiowa> ivanm: that's different syntax, nothing more powerful (iirc even less powerful - no overlapping possible)
13:07:36 <ivanm> well, it _is_ a newer idea... ;-)
13:07:42 <ivanm> and what do you mean by overlapping?
13:07:48 <sproingie> i'm disappointed records haven't gotten more love
13:07:57 <sproingie> i can haz trex?
13:08:04 <ivanm> sproingie: people still can't agree! ;-)
13:08:08 <Paczesiowa> I want new extensions, more powerful, more dangerous and more obscure!
13:08:15 <sproingie> ivanm: they all agree it sucks as it is now
13:08:28 <ivanm> sproingie: yes, but can't agree how to improve them
13:08:35 <ivanm> Paczesiowa: then write them!
13:08:56 <Paczesiowa> ivanm: yeah, right:)
13:08:57 <sproingie> i think some weight should go to the improvement that's actually implemented
13:09:30 <ivanm> sproingie: AFAIK, there is no other alternate record syntax that has been implemented for GHC
13:09:48 <|fft|> Any people understanding monads here?  Explain me please how the state propagates through this do notation and where getState takes it's state? http://pastie.org/760513
13:09:55 <sproingie> i don't imagine the syntax from hugs is portable?
13:09:59 <Paczesiowa> ivanm: that's just syntax - all you need is a preprocessor mcro
13:10:07 <sproingie> syntax is the easy part
13:10:16 <holmak> What do I do if I install two Cabal packages that provide the same module? ghc won't compile because of the ambiguity.
13:10:23 <Lemmih> |fft|: Monads? You must have come to the wrong channel.
13:10:38 <sproingie> holmak: hide one of them
13:10:41 <holmak> how?
13:11:02 <Paczesiowa> holmak: -hide-package
13:11:08 <dcoutts> holmak: you will not be able to use both packages in a single ghci session, or as dependencies of another cabal package. But it's ok to have them both installed.
13:11:30 <Lemmih> |fft|: Try using (>>=) instead of do-notation.
13:11:31 <holmak> Yeah, I only want to use one. Is -hide-package a GHC option?
13:11:50 <sproingie> it's a ghc-pkg option
13:11:55 <dcoutts> holmak: if you almost always use just one then you can make the hidden status persistent using ghc-pkg
13:12:04 <Paczesiowa> holmak: yes
13:12:12 <Paczesiowa> ghci -hide-package mtl
13:12:13 <holmak> |fft|: note that the type of State is a function (s -> s), that transforms the state
13:12:16 <dubhrosa> marsh_: if you're really doing hard-real-time you have to run in an interrupt service routine.
13:12:20 <holmak> @src State
13:12:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:12:26 <dcoutts> holmak: -hide-package is a ghc option, "ghc-pkg hide $pkg" is what you want
13:12:36 <Lemmih> |fft|: http://www.haskell.org/all_about_monads/html/statemonad.html
13:12:36 <holmak> thanks for the package help
13:12:40 <Paczesiowa> ghci -hide-package mtl-1.1.0.2
13:13:17 <sproingie> dubhrosa: or just mask interrupts
13:13:18 <Paczesiowa> there are probably a lot of tutorials that start with tree numbering
13:13:31 <|fft|> Lemmih: I've already been there. Intuitively I understand what it stands for but I'm trying to get it completely
13:14:00 <Paczesiowa> |fft|: rewrite it with >>=, then inline definition of >>= for Trees
13:14:23 <dubhrosa> the interrupts are usually what tells you something has happened that you need to react to, i.e. the deadline is in reference to isr raising
13:14:40 <Paczesiowa> |fft|: simplify, marvel
13:15:23 <SubStack> > replicateM 3 "01
13:15:25 <lambdabot>   <no location info>:
13:15:25 <lambdabot>      lexical error in string/character literal at end o...
13:15:26 <SubStack> wups
13:15:34 <SubStack> > replicateM 3 "01"
13:15:35 <lambdabot>   ["000","001","010","011","100","101","110","111"]
13:15:55 <SubStack> trying to remember why that should work
13:15:57 <dubhrosa> you could theoretically run haskell code in an isr I guess, as long as you could postpone gc until your deadline has been met
13:16:30 <pozic> Isr?
13:16:37 <dubhrosa> interrupt service routine
13:16:59 <dubhrosa> the block of code the processor jumps to when a hardware interrupt is raised
13:18:30 <|fft|> Paczesiowa: So I should ask more concrete questions. The line putState(cur+1) results in  (cur+1, ()) and state cur+1 passes to the next line return(v,cur) . The last line results in State (\state -> (state, (v,cur)). So this lambda takes state cur+1 and remembers it for further invokation ot what?
13:19:10 <|fft|> *or
13:19:46 <Paczesiowa> |fft|: puState doesn't result in a pair - it results in suspended/abstracted pair wrapped in State constructor
13:20:02 <roboshibby> hey guys, what's an example of a function that isnt referentially transparent?
13:20:10 <Paczesiowa> roboshibby: rand()
13:20:11 <roboshibby> like in some other lang not as cool as haskell
13:20:15 <roboshibby> ahhh
13:20:23 <roboshibby> man you came out with that fast lol
13:20:38 <roboshibby> so how would you do rand() in haskell?
13:20:39 <|fft|> Paczesiowa: and how the return knows that it should wrap the state cur+1 ?
13:20:43 <roboshibby> to be referentially transparent
13:21:41 <Paczesiowa> |fft|: return also returns a function wrapped in a State constructor, it doesn't know anything about cur+1
13:21:46 <Twey> roboshibby: You don't
13:21:58 <roboshibby> hrm
13:22:01 <blackh> roboshibby: random :: RandomGen g => g -> (a, g)
13:22:06 <Paczesiowa> roboshibby: rand could take previous seed value and return next random number and new seed
13:22:24 <Twey> For an impure rand(), you have a token that represents getting a random value, and into
13:22:29 <roboshibby> so it'd implement an algorithm?
13:22:30 <blackh> roboshibby: That is, you pass the rng in and get a new rng out along with your result.  If this is too cumbersome (which it usually is) you can use a monad.
13:22:34 <Paczesiowa> |fft|: and then comes the mighty bind and connects all those wrapped functions
13:22:47 <Twey> … it you bind another token that represents what to do with the random value once you have it
13:23:03 <Twey> Then you pass the whole thing to the runtime, which handles all the messy impure stuff
13:23:10 <roboshibby> wild
13:23:15 <roboshibby> it's like a whole new way to program
13:23:20 <roboshibby> like, programming by proxy
13:23:21 <Twey> Kind of
13:23:27 <Paczesiowa> roboshibby: yes, beside passing seeds in and out it would also have to implement that random algorithm (just like rand())
13:23:34 <blackh> roboshibby: Programming without bugs - or at least - without anywhere near as many bugs
13:23:46 <Twey> The way it works out, though, with the syntax sugar we have or it, ends up being very similar to existing imperative languages
13:23:49 <roboshibby> i look forward to the day when software has not even 1 bug
13:23:59 <Twey> (but with some cool new tricks and a lot more type-safety as a result of how we arrive there)
13:24:01 <holmak> is good joke!
13:24:13 <Twey> holmak: Hehe
13:24:20 <Teggy> roboshibby, that will be the same day the monks have finished to move the towers of Hanoi
13:24:25 <pikhq> roboshibby: Impossible to prove for non-trivial programs.
13:24:26 <Twey> s/have or/have for/
13:24:27 <Paczesiowa> we just need better language
13:24:34 <Twey> Teggy: *grin* Those monks are not very clever
13:24:43 <|fft|> Paczesiowa: If any constructor doesn't know anything about the previous states how does the state propagate?  Hmm Every line in do notation connects with >>= is it right?
13:24:46 <monochrom> But do the monks have bugs in their moving algorithm?
13:24:52 <Twey> It takes them goodness knows how many æons to accomplish what every first-year computer science student does in a day or so
13:24:52 <pikhq> The closest that can be done is proving that a program is an exact implementation of a spec. The spec can, of course, be buggy.
13:24:59 <Twey> monochrom: Must have
13:25:19 <monochrom> So maybe they won't finish.
13:25:21 <roboshibby> yea, buggy spec
13:25:22 <roboshibby> hm
13:25:30 <dubhrosa> Wasn't it Robert Glass's book where he showed that there'll be about 5 real defects per 1000 lines, no matter what language
13:25:30 <dubhrosa> ?
13:25:33 <roboshibby> so perfect spec=>perfect implementation
13:25:41 <Paczesiowa> |fft|: yes, more or less. actually bind takes first line and the whole rest of the block. that block has another bind inside to connect it
13:25:57 <pikhq> roboshibby: Perfect implementation of a spec is really freaking hard.
13:26:00 <kmc_> roboshibby, there are languages where the compiler can prove that your program meets the spec
13:26:09 <kevinclark> when the speci *is* the implementation, you've just got to get one right ;)
13:26:10 <kmc_> this requires you to express the spec formally
13:26:13 <pikhq> Perfect spec is... Very rarely feasible.
13:26:23 <holmak> does anyone know what kind of resolution the Data.Time.Clock.getCurrentTime function has?
13:26:26 <roboshibby> kevinclark: where is that?
13:26:26 <dubhrosa> kmc_: isn't that the same as just coding it?
13:26:31 <kmc_> no
13:26:36 <pikhq> dubhrosa: In some languages.
13:26:40 <dubhrosa> example?
13:26:43 <|fft|> Paczesiowa: And where the first line takes state ?
13:26:52 <dubhrosa> are you talking about Z style stuff?
13:27:06 <Paczesiowa> |fft|: from runState
13:27:08 <monochrom> perfect spec is no less feasible than handwaving spec.
13:27:17 <Paczesiowa> |fft|: you have to somehow run this computation
13:27:18 <kevinclark> roboshibby: some language we haven't written yet
13:27:24 <kevinclark> :\
13:27:25 <roboshibby> oh
13:27:28 <roboshibby> poo
13:27:29 <roboshibby> hehe
13:27:31 <kmc_> a language like Coq or Agda is not powerful enough to turn a spec into a program.  but if you have both, it can prove the program meets the spec.
13:27:51 <kmc_> (you have to guide it in this proof, but you're not trusted to say true things during that process)
13:28:11 <kmc_> so no, writing a formal spec is not the same as writing the program
13:28:20 <dubhrosa> ok, I get the theory, but in practice you just move the bugs further up the chain
13:28:34 <roboshibby> bugs :/
13:28:37 <monochrom> bugs in spec are easier to spot.
13:28:40 <Paczesiowa> we can't have automatic generating code from specs - we'd loose jobs - and the whole programming would happen by menegers in VS UML editor Professional 2020
13:28:40 <kmc_> dubhrosa, sure, but hopefully in the process you get rid of some, or make them easier to find
13:29:10 <j4cbo> you can, in some sense, prove that a spec is "correct"
13:29:13 <kevinclark> Paczesiowa: someone would still have to fix bugs in the generator
13:29:20 <j4cbo> in that you can prove certain properties about it
13:29:28 <j4cbo> progress and preservation, etc
13:29:39 <Berengal> Also, languages like Coq and Agda can not only prove than an implementation follows the spec completely, but can prove that the spec is at least internally consistent
13:29:41 <dubhrosa> agreed that it's 10x cheaper to remove bugs at design than implementation, but I don't agree that it's easier to spot them at design phase- usually people haven't thought through all the details
13:29:42 <monochrom> bugs in code are harder to spot because you do twice the work: first you have to reverse-engineer from code to spec, then you have to find bugs.
13:30:27 <shapr> raincat compiles, yay!
13:30:35 <dubhrosa> and if the spec is detailed enough to be formally verified, for practical purposes generating it has become what we'd normally call the implementation phase
13:31:11 <sproingie> shapr: new version of raincat or did you patch it?
13:31:18 * j4cbo wants to get a copy of The Definition of Standard ML for his bookshelf
13:31:36 <dubhrosa> sorry, I just smell consultant-ware when I hear stuff like this </soapbox>
13:31:45 <wagle> is it still current?
13:32:01 <Paczesiowa> dubhrosa: but specs can be written using unusable, exponential algorithms to make them really pretty. and then you can prove faster implementations equivalent
13:32:50 <Paczesiowa> dubhrosa: like that famous prolog version of sort - monotonic permutation
13:32:57 <dubhrosa> Paczesiowa: I humbly defer :) sounds like a job for life!
13:33:01 <Berengal> Paczesiowa: With a good enough type system, the specs can be written entirely in types, leave the implementations for later
13:33:03 <shapr> sproingie, patched
13:33:13 <monochrom> What you smell here is instead a scheme to render logic-unaware programmers unemployed and logic-savvy geeks very profitable.
13:33:30 <dibblego> why can't I say: instance (T a X) => C a where (T is a MPTC)?
13:33:32 <shapr> sproingie, just gotta change Control.Exception imports to Control.OldException. Props to b_jonas for telling me that.
13:34:04 <sproingie> cool
13:34:14 <dubhrosa> actually, I blew it, it's bacon, someone's making a blt
13:34:22 <Paczesiowa> dibblego: have you tried extensions (Undecidable, Flexible*) ?
13:34:50 <dibblego> Paczesiowa, the complaint requires FlexibleInstances, which I added, but it still complains
13:34:55 <dibblego> oh wait
13:35:42 <dibblego> it needed more than that, sorry
13:35:49 <dibblego> thanks
13:36:31 <Paczesiowa> dibblego: if it didn't work, there would be no TypeCasts
13:37:19 <Paczesiowa> and what kind of world would that be...
13:37:46 <monochrom> I disagree with using type for spec because it becomes an encoding of spec rather than writing spec directly (say, in predicate logic directly)
13:38:43 <|fft|> Paczesiowa: runStateM (State f) st = snd (f st)   starts computation with initial state and this state propagates. So all the statements in program are connected with >>= or I'm misunderstanding something. Or maybe nested do's connected  ?
13:39:41 <Paczesiowa> |fft|: do line1; line2; line3 = do line1; (line2; line3) = line1 >>= (line2 >>= line3)
13:41:52 <mreh> how do you extract a range of an infinite loop?
13:41:55 <|fft|> Paczesiowa: this is clear. What about  do line 1; line 2; line3 (recursion here) = do line 1' ; line2'; .... ; line4( out of recursion)  = line1>>=line2>>=line3>>=line1'>>=line2'>>=...>>= line4 ?
13:42:02 <mreh> I thought two partitions
13:42:29 <mreh> :t partition
13:42:30 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:43:37 <Paczesiowa> |fft|: >>= only connects "simple" atoms, like returns and putState/getStates. everything else is expanded
13:43:41 <mreh> > fst . partition (< 5) [1..]
13:43:43 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[a1]'
13:43:48 <mreh> > fst . partition (< 5) $ [1..]
13:43:53 <lambdabot>   mueval-core: Time limit exceeded
13:43:53 <roboshibby> lambdabot: hello
13:44:16 <mreh> roboshibby, she is a computer
13:44:18 <Paczesiowa> |fft|: so if foo = do line1; line2; bar; line3 and bar = do line4;line5;line6, then we have:
13:44:31 <roboshibby> and hence has no gender :P
13:44:43 <monochrom> Toy example. I want f such that f x > x. (Exact value is up to implementer.) Spec in predicate logic says "for all x, f x > x". Type encoding says "f :: x -> { y | y > x }". The type encoding is a roundabout way, what with needing an extra dummy variable y and an extra predicate subtype.
13:44:48 <Paczesiowa> |fft|: line1 >>= (line2 >>= ((line4 >>=(line5>>=line6)) >>= line3)
13:44:53 <mreh> roboshibby: boats are always feminine
13:45:10 <sproingie> the same appears to apply to bots
13:45:11 <roboshibby> i sail, im aware. but that has roots in gendered languages
13:45:30 <mreh> roboshibby: well what's the problem then
13:45:46 <chrisdone> why do I find it hard to write the next line?
13:45:53 <roboshibby> none i guess. if you have sentimental relationship to the bot, i suppose feminizing her is acceptable to me
13:46:08 <sproingie> i think it comes out of the whole female computer voice thing
13:46:16 <|fft|> Paczesiowa: Thank you. Almost got it. Shoul meditate a bit )
13:46:19 <kmc_> @vixen a/s/l?
13:46:20 <lambdabot> 19/f/California
13:46:21 <|fft|> *should
13:46:36 <roboshibby> really? i always had my computers speak with a southern hillbilly voice
13:46:50 <roboshibby> @vixen, lol
13:46:50 <lambdabot> do i amuse you?
13:47:28 <Paczesiowa> |fft|: if in doubt, try rewriting it by inlining definitions of >>=, pustState,return and runState. then you will get pure computation that will make it clear (and ugly) how it passes state.
13:48:25 <Paczesiowa> can I ask hoogle for a function of type a->b, but for monomorphic a and b? (no foralls)
13:48:36 <chrisdone> sproingie: pliz fast-en sietbult
13:48:39 <Paczesiowa> @hoogle Int->String
13:48:39 <lambdabot> Prelude show :: Show a => a -> String
13:48:39 <lambdabot> Text.Show show :: Show a => a -> String
13:48:39 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
13:48:41 <sproingie> @undo do { x <- get; put (x+1) }
13:48:41 <lambdabot> get >>= \ x -> put (x + 1)
13:50:32 <knobo> why does not ghci accept this one: ((++) . (:)) ?
13:50:47 <increpare> :t (++). (:)
13:50:48 <lambdabot> forall a. a -> ([a] -> [a]) -> [a] -> [a]
13:50:59 <yitz> sproingie: modify (+1)
13:51:05 <increpare> knobo: it seems to accept it fine here : )
13:51:16 <knobo>  Couldn't match expected type `[a]'    against inferred type `[a1] -> [a1]'
13:51:33 <knobo> In the second argument of `(.)', namely `(:)'    That's what I get.
13:51:40 <sproingie> yitz: just demonstrating @undo
13:51:57 <yitz> sproingie: it didn't do a very good job on that one.
13:52:25 <sproingie> i thought it did all right, but it's usually more obvious on bigger do-blocks
13:52:35 <knobo>  :t (++) . (:) 1 works
13:52:48 <increpare> knobo: do you have a type signature declared before?
13:53:07 <knobo> increpare: nope. just that expression in the repl
13:53:07 <increpare> knobo: :t ( (++) . (:) ) 1
13:53:11 <increpare> oops
13:53:17 <increpare> >  ( (++) . (:) ) 1
13:53:18 <lambdabot>   []->
13:53:18 <lambdabot>    []
13:53:18 <lambdabot>  [-2]->
13:53:18 <lambdabot>    []
13:53:18 <lambdabot>  [-2,-1]->
13:53:20 <lambdabot> [5 @more lines]
13:53:31 <roboshibby> @more
13:53:31 <lambdabot>    []
13:53:31 <lambdabot>  [-2,-1,0]->
13:53:31 <lambdabot>    []
13:53:31 <lambdabot>  [-2,0]->
13:53:31 <lambdabot>    [...
13:53:38 <roboshibby> cool bot!
13:54:01 <yitz> > ((++).(:)) 42 tail [10,20,30]
13:54:02 <lambdabot>   [42,10,20,30,20,30]
13:54:17 <roboshibby> > hello
13:54:18 <lambdabot>   Not in scope: `hello'
13:54:28 <roboshibby> > 2 + 3
13:54:29 <lambdabot>   5
13:54:31 <roboshibby> mmm
13:54:35 <increpare> knobo: what happens when you type " :t (++) . " and " :t .(:) " ?
13:54:36 <roboshibby> satisfaction
13:54:43 <yitz> @vixen cool bot!
13:54:44 <lambdabot> bots should be destroyed. they are so annoying
13:54:58 <roboshibby> so i take it vixen is her name
13:55:05 <kmc_> lambdabot is her name
13:55:08 <kmc_> vixen is a character she plays
13:55:10 <roboshibby> no that's her nick
13:55:14 <roboshibby> ah
13:55:19 <kmc_> @vixen what is your name?
13:55:19 <lambdabot> My name is Emily
13:55:25 <kmc_> @vixen what is your name?
13:55:25 <lambdabot> My name is Emily
13:55:29 <roboshibby> @vixen did you choose your own name?
13:55:30 <lambdabot> My name is Emily
13:55:31 <holmak> @vixen What is your name?
13:55:31 <lambdabot> My name is Emily
13:55:34 <increpare> @vixen what is a type class?
13:55:34 <lambdabot> any type will due
13:55:42 <jfoutz> @vixen name kmc_
13:55:43 <lambdabot> how
13:55:46 <kmc_> @vixen what is your name?
13:55:47 <lambdabot> My name is Emily
13:56:02 <kmc_> @vixen what would you buy if you won the lottery?
13:56:03 <lambdabot> the question isn't would i, but should i
13:56:03 <yitz> @vixen why do you keep repeating yourself?
13:56:03 <lambdabot> i just forget that i said something
13:56:31 <kmc_> @. elite nixon
13:56:31 <lambdabot> A PuB|Ic maN MU$t N3VEr ph0r9E+ 7|-|a7 |-|E |0s3z0rz HI5 U53Fu1n3zz0rz whEN H3 A$ aN inDI\/iDUA|, r47H3R 7|-|4n hIz0rz P01I(y, be(0M3s t|-|3 iSzu3.
13:56:36 <increpare> knobo: I'm have to dash off now; check your types! : )  (the ghci setup here might be a little different from the one in main ghc, which might make a difference)
13:57:04 <roboshibby> i can't believe i can read that
13:57:10 <roboshibby> too many days on aol in my early years :P
13:57:12 <knobo> ok
13:57:43 * Hunner can't read it without taking time...
13:58:44 <roboshibby> my mind has developed robust pattern matching
13:58:59 <roboshibby> that's the result of not having a lot of friends =)
14:12:11 <blackh> roboshibby: It's really funny that the channel went quiet just after you said that.  Hee hee
14:12:42 <roboshibby> lol i noticed that too!
14:12:46 <roboshibby> i mean, i /killed/ it
14:12:55 <blackh> I know. What am I doing here?
14:13:01 <monochrom> We wish to help you develop your skill further.
14:13:05 <blackh> I don't have any friends either.
14:13:13 <roboshibby> yea shouldn't you be stepping backward slowly from me? :P
14:13:20 <SoleSoul> Hi. I'm learning haskell for the last few weeks and since I saw that the tutorials and books go around math and numbers all the time I'm getting worried.  Is Haskell really the right tool to write a mail server for example? I mean, an IO driven program. What do you say? Do you have any example that I could see the code of it? thanks.
14:13:31 <jfoutz> i was jealous. i don't have friends OR robust pattern matching.
14:13:38 <roboshibby> rofl
14:13:48 <kmc_> SoleSoul, take a look at Real World Haskell
14:13:49 <monochrom> @where rwh
14:13:49 <kmc_> @where RWH
14:13:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:13:50 <blackh> SoleSoul: Definitely.  Haskell is really great for that kind of thing.
14:13:50 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:13:56 <kmc_> it has some quite IO-driven programs
14:13:58 <Paczesiowa> wait, if roboshibby doesn't have any friends AND blackh doesn't have any friends, then, then, then...
14:14:02 <kmc_> SoleSoul, it's a myth that Haskell can't handle IO and state
14:14:05 <EvanCarroll> how difficult is it to learn category theory?
14:14:17 <kmc_> Haskell has good support for imperative programming
14:14:27 <kmc_> in fact, it's my favorite imperative language
14:14:49 <memental> i hate people. do you hate people? Let's get together so we can hate people together
14:14:56 <Paczesiowa> ok!
14:14:57 <jfoutz> SoleSoul: i like this guide. not exactly a mail server. http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
14:15:02 <j4cbo> i think the best example of a big IO-driven Haskell program is Xmonad
14:15:12 <Paczesiowa> "big":)
14:15:15 <j4cbo> well
14:15:16 <monochrom> Some books prefer to talk about I/O later, that is why in the early parts they do data processing first. Note how early you get to trees and other data structures.
14:15:18 <roboshibby> yes, let us share in how different and unique we are
14:15:21 <j4cbo> "well-known" :)
14:15:41 <Paczesiowa> j4cbo: where were you when they were discussing all those buzzwords about webstuff?
14:15:55 <SoleSoul> Thanks for the suggestions. I will look into this book. Can you point me to an available source of such little program?
14:15:57 <j4cbo> right here!
14:16:04 <SoleSoul> I'll check the irc bot also
14:16:31 <Paczesiowa> j4cbo: their list of buzzwords was longer than sources of xmonad
14:16:43 <kmc_> SoleSoul, basically, I think that Haskell's treatment of IO and state is better than in most languages, but there's a big learning curve to get there
14:17:00 <monochrom> It is more advanced and powerful.
14:17:05 <ane_> there's text editors and revision control systems that are written entirely in haskell
14:17:13 <kmc_> you have to understand that, unlike most languages, in Haskell "function" and "sequence of IO steps" are two unrelated types
14:17:14 <SoleSoul> I just got to the I/O chapter of lyah
14:17:25 <jfischoff> can pattern matching be used for a function that does one thing with a list arg and other with a nonlist?
14:17:29 <kmc_> and evaluating an expression, even an expression that describes IO, does not perform IO
14:17:33 <roboshibby> ah, the conversation from last night...
14:17:34 <j4cbo> i would not say that it is inherently more advanced or more powerful.
14:17:38 <kmc_> jfischoff, no suc function
14:17:42 <kmc_> what would its type be?
14:17:49 <j4cbo> it's much better for some things, much worse for others, and about a wash for others.
14:17:53 <kmc_> or did you mean two different args
14:17:55 <roboshibby> kmc, what is the type name for 'sequence of io steps' ?
14:17:59 <jfischoff> kmc_: That's what I thought.
14:18:13 <SoleSoul> ane_:  can you point me to such text editor?
14:18:13 <Paczesiowa> roboshibby: IO
14:18:14 <kmc_> roboshibby, "IO a", where "a" is the "result type"
14:18:21 <kmc_> :t getChar
14:18:21 <Paczesiowa> SoleSoul: yi
14:18:22 <lambdabot> IO Char
14:18:23 <roboshibby> ahhh
14:18:27 <kmc_> getChar is an IO step which produces a Char
14:18:28 <kmc_> it's not a Char
14:18:31 <Paczesiowa> SoleSoul: and leksah
14:18:33 <kmc_> nor is it a function that returns a Char
14:18:33 <ane_> SoleSoul: http://www.haskell.org/haskellwiki/Yi
14:18:42 <SoleSoul> Paczesiowa: thanks
14:18:46 <roboshibby> i think IO is pretty well-named
14:18:46 <jfischoff> kmc_: nah, I just don't understand haskell very well. Thanks.
14:18:47 <j4cbo> saying "sequence of IO steps" is a poor description
14:18:59 <j4cbo> because you can have output which depends on input, etc
14:19:03 <roboshibby> j4cbo: would you prefer set of transformations?
14:19:08 <j4cbo> roboshibby: sure.
14:19:10 <kmc_> that's fair enough
14:19:17 <kmc_> all of the imprecise terms are imprecise
14:19:23 <kmc_> you really just have to learn the Monad typeclass
14:19:24 <SoleSoul> :)
14:19:24 <SoleSoul> kmc_: Thank you. I guess I'll have to continue reading. patience...
14:19:33 <kmc_> fortunately, there are only two important functions in that typeclass
14:19:42 <SoleSoul> I will.
14:19:51 <kmc_> cool :)
14:20:18 <SoleSoul> I'm in the second year of university so it's har to find time though. :/
14:20:23 <HugoDaniel> hi
14:20:25 <roboshibby> and the steps in the sequence all operate, sequentially, on a single value right? out from 1 in to the next
14:21:57 <Paczesiowa> @where liftIO
14:21:57 <lambdabot> I know nothing about liftio.
14:21:59 <SoleSoul> kmc_: My learning source doesn't have a Monads chapter.. It's lyah. The next recommended source is rwh?
14:22:03 <Paczesiowa> :t liftIO
14:22:04 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
14:22:06 <HugoDaniel> im starting to use parsec to create some parsers, are there any texts on the internet that you guys recommend me to read about parsec ?
14:22:06 <kmc_> SoleSoul, sure
14:22:09 <kmc_> rwh is good
14:22:14 <Paczesiowa> @hoogle liftIO
14:22:15 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
14:22:16 <SoleSoul> ok!
14:22:27 <kmc_> SoleSoul, also be aware that IO is a strange example of a monad
14:22:38 <j4cbo> oh, heh, i read rwh as a different rwh involved in functional languages :P
14:22:46 <kmc_> it's atypical
14:24:00 <ane_> SoleSoul: you know RWH is available online for free
14:24:06 <SoleSoul> kmc_: I'm not supposed to understand your last message do I?
14:24:14 <SoleSoul> ane_: Yes :) thank you!
14:24:30 <SoleSoul> kmc_: I mean, about a type of monad
14:24:36 <SoleSoul> I don't know what a monad is
14:24:41 <SoleSoul> yet
14:25:17 <kmc_> SoleSoul, sure.
14:25:25 <roboshibby> solesoul, atypical just means not typical. it *probably* comes from greek where an afore "a" throws the word in reverse
14:25:45 <roboshibby> reverse as in logical not
14:26:17 <SoleSoul> roboshibby: :) thanks. I just have to read more.
14:26:31 <roboshibby> :0
14:26:38 <roboshibby> :)*
14:26:45 <ane_> don't be scared by monads, they don't bite
14:26:53 <kmc_> SoleSoul, i just mean that if you learn how to do IO specifically (which is useful), you are learning a lot of things that don't generalize to other monads
14:27:01 <companion_cube> but monad transformer do,
14:27:48 <kmc_> each monad represents a sort of "computational feature" -- IO, exceptions, parsers, nondeterminism, logical backtracking, concurrency, code generation, etc.
14:27:53 <koeien37> this is the "alpha privans", yeah
14:27:56 <SoleSoul> kmc_: which means I shouldn't start right in IO? read about monads first?
14:28:04 <kmc_> SoleSoul, you should start with IO if you want to do IO
14:28:07 <koeien37> no, learn about the Maybe, [] , Reader monad
14:28:08 <kmc_> and don't worry that IO happens to be a monad
14:28:12 <koeien37> but if you want to do IO, do IO
14:28:15 <blackh> SoleSoul: A monad is an abstraction that we use to describe computations with the workings of "something" behind the scenes.  In the case of IO, it's I/O, obviously. :)
14:28:16 <koeien37> agree with kmc_
14:28:29 <kmc_> but if you want to learn monads in general, learn the ones koeien37 said.  they are more typical examples
14:29:26 <kmc_> there are some properties of the IO monad (side effects, no exit, magical built-in-ness) that are not true of most monads
14:29:49 <blackh> SoleSoul: Opinion is divided on the subject of whether you should learn IO or monads first.  I think it's better to learn IO first, because it's really simple to use, and you get used to day-to-day use of monads in a familiar environment (sequences of IO operations).
14:29:55 <roboshibby> kmc, does that make them more functionally proper/capable?
14:30:04 <kmc_> roboshibby, i don't know what you mean
14:30:18 <merijn> roboshibby: Yeah, it does
14:30:19 <roboshibby> the extraordinary properties of IO monads
14:30:31 <kmc_> i don't know what you mean by "functionally proper/capable"
14:30:47 <roboshibby> like, enhancement to usefulness, i guess
14:30:47 <SoleSoul> I feel I love Haskell but it take so much time to get to really using it...!
14:30:54 <merijn> kmc_: He means whether the fact that IO is in the IO monad makes I/O more like functional programming
14:31:16 <merijn> At least, that's my assumption of the questions
14:31:27 <roboshibby> oh i just meant functional generally, but that probably works too
14:31:28 <SoleSoul> I'll go read some IO in lyah.
14:31:36 <sproingie> you just about have to introduce IO first, because no one wants to learn a language they can't even write "Hello World" in by Chapter 3
14:31:38 <blackh> SoleSoul: It took me about four months of studying in the evenings before I could start to write code faster in Haskell than I could in other languages (such as python).
14:31:39 <kmc_> well it's very useful and important that IO-actions are first-class values
14:31:49 <kmc_> this is important for some fundamental things like threading and exception handling
14:31:57 <kmc_> which most other languages get wrong or handle with special cases
14:32:06 <sproingie> i would say introduce IO and even the >>= operator
14:32:07 <kmc_> e.g., in Haskell, "try", "catch", "throw" are all ordinary functions
14:32:14 <sproingie> and when you get to monads, you say "you're soaking in it!"
14:32:18 <roboshibby> interesting
14:32:26 <roboshibby> special cases suck
14:32:30 <roboshibby> feels so dirty
14:32:30 <blackh> SoleSoul: It's been said that Haskell is not harder than other languages, but it is very different.  So you don't get so much advantage from already knowing how to program as you do for, say, Python.
14:32:45 <kmc_> i think it is actually harder too
14:32:54 <memental> i think it's harder
14:32:55 <SoleSoul> sproingie: I survived up to chapter nine before learning the "Hello world" :)
14:32:57 <kmc_> because strong static typing forces you to have more discipline up front
14:33:11 <kmc_> it's harder to write a Haskell program that compiles, but once it compiles it's much more likely to work properly
14:33:12 <roboshibby> strong static typing rules imo
14:33:14 <SoleSoul> I use C++
14:33:20 <sproingie> SoleSoul: are you in Seoul by any chance? ;)
14:33:27 <roboshibby> hehe
14:33:29 <SoleSoul> and I can say right now that C++ is harder for me
14:33:30 <merijn> sproingie: Yeah, I was really annoyed by Real World Haskell about that. It tried to cover IO and things like return but it didn't treat monads at that time so I got real confused by that. When I went to read about monads/>>= and return I find out monads are pretty simple...
14:33:37 <SoleSoul> and no, not in seoul
14:33:40 <kmc_> C++ is a very hard language, for all sorts of stupid reasons
14:33:44 <blackh> roboshibby: You would like Haskell, then - it's a simple design, with relatively few exceptions (compared to other languages)
14:33:44 <sproingie> well you orbit around Sol anyway
14:33:45 <SoleSoul> Is it in Canada?
14:33:51 <j4cbo> Haskell is *not* the only higher-order strongly staticly typed language.
14:33:57 <kmc_> merijn, i can see that, but some people get annoyed the exact opposite way
14:33:57 <mreh> can we partition a infinite list?
14:34:03 <mreh> > fst . partition (< 5) $ [1..]
14:34:03 <roboshibby> j4cbo: but is it the best?
14:34:03 <merijn> I like how haskell combines well with the Feynman problem solving algorithm :p
14:34:07 <lambdabot>   mueval-core: Time limit exceeded
14:34:16 <kmc_> if you say the word "monad" they start to freak out, but if you just do some IO with these natural higher-order functions it makes sense
14:34:19 <sproingie> merijn: yah RWH is very uneven
14:34:24 <j4cbo> roboshibby: it is the newest and most popular
14:34:26 <SoleSoul> :)
14:34:26 <HugoDaniel> j4cbo: indeed, but its teh best :)
14:34:38 <memental> merijn: which is.. "be incredibly smart"?
14:34:40 <kmc_> it's hard for someone to argue that monads are incomprehensible when you point out they've been using them for 3 chapters without knowing
14:34:45 <j4cbo> i consider its handling of side-effects to be its only major flaw, actually
14:34:56 <merijn> memental: 1) Write down problem 2) Think real hard 3) Write down solution :p
14:34:57 <roboshibby> blackh, im definitely considering it. in addition to ruby and objective-c, i want to learn one of the higher order languages
14:35:02 <j4cbo> roboshibby: learn ML!
14:35:04 <memental> monads are just the monoid object in the category of endofunctors...
14:35:10 <j4cbo> roboshibby: either SML or OCaml
14:35:16 <kmc_> j4cbo, what's wrong with first-class side effects?
14:35:25 <tensorpudding> It's hard to have interesting examples of real programs that don't use IO
14:35:28 <merijn> roboshibby: I'm pretty sure ruby supports higher order functions
14:35:33 <sproingie> i never even got how they were monoids til i watched that beckman lecture on channel9
14:35:43 <SoleSoul> The greatest advantage of haskell is the fact that it's compiled. It looked to me like a miracle that the syntax I learn in math lectures can be compiled!!
14:35:43 <companion_cube> > takeWhile (<5) $ [1..]
14:35:44 <lambdabot>   [1,2,3,4]
14:35:48 <sproingie> just stuck a \x -> on the left and it was all so clear
14:35:51 <j4cbo> kmc_: the problem with putting side effects in the type system is... that then side effects are in the type system
14:35:58 <merijn> roboshibby: I know python does and as far as I heard ruby has better support in that respect...
14:36:04 <kmc_> j4cbo, s/side effects/functions/
14:36:05 <mreh> companion_cube, good thinking
14:36:08 <kmc_> why does it not hold then
14:36:23 <tensorpudding> and RWH tries to provide examples of useful programs instead of snippets
14:36:26 <kmc_> j4cbo, it's very superficial to understand "IO" as merely a tag that denotes the presence of side effects
14:36:38 <j4cbo> but in practice, it *is* a problem
14:36:45 <blackh> roboshibby: Haskell takes a little longer to learn than other languages, but the rewards are enormous.  A large part of the learning curve is actually lazy evaluation which is a double-edged sword as mentioned previously.  It gives power but comes at a cost (learning curve).
14:36:47 <kmc_> the point of monadic effects is not only to keep them contained but to provide infrastructure for inventing new ones
14:36:54 <j4cbo> kmc_: say i am debugging my program and i want to add something to trace which values a given function is evaluated on
14:37:03 <roboshibby> lazy evaluation?
14:37:06 <kmc_> j4cbo, that's why we have backdoors like Debug.Trace
14:37:07 <j4cbo> suddenly, i've changed the type of the function! (or i use unsafePerformIO)
14:37:08 <sproingie> actually the cost of lazy evaluation i was referring to was space leaks
14:37:18 <companion_cube> mreh: lazyness has some limitations :)
14:37:34 <j4cbo> the fact that you *need* backdoors to actually *use* the language destroys most of the advantages of purity.
14:37:43 <blackh> roboshibby: Haskell evaluates everything on demand.
14:37:44 <kmc_> oh come on
14:37:51 <roboshibby> you need backdoors in haskell?
14:37:54 <j4cbo> and laziness is a pain too
14:37:56 <roboshibby> blackh, that sounds nice
14:37:58 <roboshibby> oh
14:38:03 <tensorpudding> what backdoor is that
14:38:04 <kmc_> j4cbo, i've done several large projects in Haskell and never needed to write unsafePerformIO
14:38:06 <monochrom> I haven't added something to trace which values a given function is evaluated on for a while. I do extreme unit testing instead.
14:38:07 <sproingie> unsafePerformIO is a backdoor.  performing it normally is not.
14:38:07 <holmak> laziness is awesome!
14:38:07 <companion_cube> > let x = 1 / 0 in "some other thing"
14:38:09 <lambdabot>   "some other thing"
14:38:24 <j4cbo> since it makes it very difficult to reason about the time or memory consumption of your program
14:38:25 <companion_cube> roboshibby: it doesn't eval what it doesn't nedd
14:38:34 <SoleSoul> roboshibby: that means that if you tell haskell to make a 10000 elements list and you don't tell haskell to show it, it wont create the list because anyway you wouldn't know
14:38:34 <companion_cube> need*
14:38:40 <merijn> j4cbo: So use another language then if haskell doesn't work for you?
14:38:42 <sproingie> > take 5 [1..]
14:38:42 <lambdabot>   [1,2,3,4,5]
14:38:44 <blackh> roboshibby, SoleSoul: Don't let anyone tell you Haskell isn't a practical language.  I use it for commercial stuff and write big programs in it.
14:38:44 <Paczesiowa> > 1 / 0
14:38:45 <lambdabot>   Infinity
14:38:46 <Gracenotes> j4cbo: you're written many Haskell applications and come to this conclusion?
14:38:47 <kmc_> j4cbo, imo your objection about laziness is a lot more reasonable than your objection about first-class effects
14:38:59 <sproingie> > let x = undefined in "foo"
14:39:00 <lambdabot>   "foo"
14:39:01 <roboshibby> whoa
14:39:06 <roboshibby> lazy evaluation rules!
14:39:09 <SoleSoul> blackh: Can you point me to such source code?
14:39:15 <j4cbo> Gracenotes: no, i've looked closely at Haskell and decided not to change my first-choice language from SML to Haskell.
14:39:18 <koeien37> roboshibby: yes it does
14:39:45 <roboshibby> is compiled haskell run faster than c?
14:39:47 <Paczesiowa> printInt64!
14:39:47 <sproingie> doing take 5 [1..] doesn't impress as much because other languages have lazy sequences too.
14:39:49 <Gracenotes> j4cbo: how closely? I've written in both, and with sufficient familiarity with the language, I think your assertions sort of just don't apply
14:39:51 <roboshibby> s/is/can
14:39:54 <kmc_> j4cbo, as for uPIO, it's intended for use by carefully written core libraries as an alternative to modifying the compiler.  it's something an application developer would almost never use, except through those libraries
14:39:55 <sproingie> roboshibby: sometimes
14:39:59 <sproingie> roboshibby: not usually
14:40:02 <kmc_> roboshibby, you can't make comparisons like that
14:40:03 <dubhrosa> j4cbo: do you use SML in a commercial setting?
14:40:06 <roboshibby> oh
14:40:08 <kmc_> first of all, which Haskell compiler, which C compiler?
14:40:09 <blackh> SoleSoul: Unfortunately no - I do a lot of proprietary code.
14:40:12 <kmc_> second, what task?
14:40:12 <SoleSoul> roboshibby:  no
14:40:13 <companion_cube> j4cbo: isn't SML a lazy language too ?
14:40:17 <j4cbo> dubhrosa: no
14:40:20 <kmc_> roboshibby, http://shootout.alioth.debian.org/
14:40:20 <j4cbo> companion_cube: no, it's not
14:40:26 <sproingie> "faster than C" is pretty much impossible, since C will let you go all the way down to inline ASM.
14:40:32 <holmak> roboshibby: Its quite fast, on the order of C or C#
14:40:32 <kmc_> SML has optional laziness, as does every functional language
14:40:34 <sproingie> but i suspect most people mean "faster than idiomatic C"
14:40:37 <SoleSoul> blackh: not any gpl one?
14:40:40 <knobo> what is fusion and the banana split rule?
14:40:46 <roboshibby> kmc, loading
14:41:04 <kmc_> SoleSoul, as for "Haskell is compiled", it can be, it can also be interpreted.  that's a property of the implementation, not the language
14:41:08 <pikhq> Faster than idiomatic C is certainly possible. ... Though hard, since idiomatic C is *generally* fast.
14:41:11 <blackh> SoleSoul: All the big stuff I've done is proprietary, so you will have to take my word for it that it exists. :) But soon you'll be able to play BloodKnight on the iPhone. :)
14:41:18 <j4cbo> idiomatic haskell is generally not fast.
14:41:18 <kmc_> anyway i agree that the existence of GHC, a world-class optimizing compiler, is a great benefit to Haskell the language
14:41:22 <dubhrosa> j4cbo: slightly offtopic, but why SML over OCAML in your case? (I'm evaluating)
14:41:27 <pikhq> (due to idiomatic C lacking many abstractions beyond what C already abstracts)
14:41:32 <sproingie> idiomatic haskell still runs circles around perl or python
14:41:39 <SoleSoul> blackh: good luck with this game!
14:41:50 <j4cbo> dubhrosa: i started on SML, and never found a reason to switch :P
14:41:51 <kmc_> j4cbo, right.  better to spend your time making your code fast than getting it working at all.
14:42:07 <sproingie> run speeds of idiomatic haskell are usually comparable to java
14:42:08 <thoughtpolice> i've been doing haskell for like, 3 years almost now
14:42:16 <j4cbo> dubhrosa: SML is a standard with many implementations; OCaml is a language-implementation-in-one
14:42:18 <thoughtpolice> and i don't think i've ever been stumped by a space-leak problem with laziness
14:42:18 <thoughtpolice> ever
14:42:28 * knobo is doing the "C9 Lectures: Dr. Erik Meijer - Functional Programming Fundamentals". He refers to the banana split rule, but he does not say what it is.
14:42:29 <kmc_> j4cbo, because most parts of most programs don't need to be fast, and because a prototype is valuable
14:42:31 <j4cbo> dubhrosa: that might push you in either direction :P
14:42:33 <blackh> roboshibby: Idiomatic Haskell is actually pretty fast.  The issue is that the optimizations in GHC can sometimes work or not work mysteriously.  So getting really fast performance out of Haskell sometimes takes some work.
14:42:40 <dibblego> knobo, do you have a link to the beginning?
14:42:50 <roboshibby> ahh
14:42:52 <merijn> Considering I find python more then fast enough for most my code I think the proper response to speed questions is "who cares?". People that are good enough to know when to do speed usually already know how and when to try for speed.
14:42:54 <sproingie> i yunno couldn't yunno get yunno through yunno Erik yunno Meijer's yunno lectures
14:42:55 <roboshibby> interesting
14:42:55 <dubhrosa> j4cbo: fair enough! I know they use ocaml at Jane street capital, but there are a few things that put me off, seems the "owners" of ocaml are a bit slow to add new stuff.
14:43:02 <knobo> dibblego: http://channel9.msdn.com/tags/C9+Lectures
14:43:06 <Gracenotes> with STG, actually, laziness compiles down very nicely to the actual flow of data. at Java-like (and sometimes C-like) speeds. Improvement beyond that depends on compiler optimizations, which are rather ongoing...
14:43:07 <blackh> roboshibby: ghc-6.14 will be interesting, because they have a new core language inside the compiler, which will make the optimizations less ad-hoc.
14:43:10 <kmc_> merijn, what Python implementation are you using?
14:43:11 <sproingie> my mother does the same thing with "yunno" and it drives me insane
14:43:15 <dibblego> knobo, thanks
14:43:18 <merijn> CPython
14:43:23 <thoughtpolice> blackh: agreed. idiomatic haskell can be very fast if you use optimized libraries
14:43:25 <j4cbo> kmc_: i agree, but "X is faster than Y" comparisons need to be shut down quickly :)
14:43:34 <merijn> knobo: I think I read on the banana split rule in a paper I was reading, lemme check
14:43:55 <kmc_> i've found CPython terribly slow for some basic realistic tasks
14:43:57 <blackh> roboshibby: Haskell compilers have to work a bit harder than C compilers, but because of purity, Haskell compilers have more to work with.  The full potential hasn't been realized yet.
14:44:19 <roboshibby> nice
14:44:19 <kmc_> it's not uncommon to rewrite my Python code in C and see a 100x speedup using gcc vs. CPython
14:44:21 <thoughtpolice> IMO, it is many times easier to optimize haskell code because you don't have to worry about side effects - lots of times, you can simply plug in a library which is optimized for speed and you're "done" (e.g. ByteString or Text)
14:44:27 <roboshibby> bigger box, bigger toy when assembled
14:44:28 <kmc_> plus the CPython concurrency implementation is just broken
14:44:35 <j4cbo> dubhrosa: yeah, i saw a talk by one of the Jane Street guys; it was very interesting
14:44:50 <sproingie> there's been a lot more research on optimizing C than any other language, largely driven by industry
14:44:54 <j4cbo> dubhrosa: they tried to recruit one of the MLton authors to get him to port the compiler
14:45:03 <sproingie> fortran got the same kind of resources before C
14:45:03 <thoughtpolice> blackh: ??! they're going to move from STG -> Strict Core?
14:45:05 <merijn> knobo: Yeah, it's mentioned and seemingly explained in this paper "On the Universality and Expressiveness of Fold" (which is an interesting read regardless) it also refers to the original paper discussing this property
14:45:06 <kmc_> sproingie, but a lot of that research is also applicable to the last stages of a high-level language compiler
14:45:10 <blackh> roboshibby: Lazy evaluation complicates the compiler somewhat. There's a lot of strictness analysis going on. It works pretty well now - but the new core language will make it even better.
14:45:20 <dubhrosa> j4cbo: really, that's interesting, he didn't bite?
14:45:22 <roboshibby> what's Fold?
14:45:22 <kmc_> the problem with using these languages in high-speed automated finance, like Jane Street does, is not overall computational throughput or speed, but rather latency from garbage collection
14:45:23 <thoughtpolice> blackh: the change to strict core will be Very Big if they do it; I hadn't heard any definitive plans to do so
14:45:34 <j4cbo> dubhrosa: nope.
14:45:35 <blackh> thoughtpolice: Maybe I shouldn't have said ghc-6.14 because I don't know what version they're putting strict core in.
14:45:35 <sproingie> kmc_: certainly.  i think FP's time may finally be arriving now that we're seriously into multicore
14:45:36 <knobo> one of the exercises was to implement map with fold. Is this a good one? foldmap f = foldr ((++) . flip (:) [] . f) []
14:45:41 <pikhq> sproingie: Not to mention that FORTRAN gets to benefit from the research on C, by merit of having at least somewhat similar semantics.
14:45:45 <blackh> thoughtpolice: I sit corrected.
14:45:47 <holmak> The stuff going into GHC is very exciting. Supercompilation in particular sounds very intense.
14:45:50 <merijn> knobo: It's by Graham Hutton, if you google for it it should turn up his paper. It's on his site for free.
14:45:50 <kmc_> even if your program is blazing fast, if it pauses an extra 100 us every once and a while, you will get run over in the market
14:46:02 <dubhrosa> j4cbo: any idea why not? looks like an interesting spot
14:46:09 <kmc_> iirc Jane St. put a lot of effort into minimizing how much the GC has to run
14:46:14 <sproingie> kmc_: java seems to do all right with that
14:46:15 <j4cbo> kmc_: yes
14:46:24 <roboshibby> man this channel has raging conversation
14:46:24 <j4cbo> kmc_: they just disable it entirely during periods of peak load, too :P
14:46:25 <kmc_> sproingie, are you joking?
14:46:28 <monochrom> knobo: foldmap f = foldr (\x ys -> f x : ys) []
14:46:33 <dubhrosa> kmc_: yes, that's what put me off
14:46:34 <kmc_> j4cbo, not surprising.  RAM is cheap ;)
14:46:43 <sproingie> oh in trading apps, yeah.  any trading apps in java are using realtime libraries
14:46:52 <sproingie> kmc_: i thought you were talking about in general
14:47:00 <knobo> merijn: thanks
14:47:00 <j4cbo> dubhrosa: i have no idea, actually :/ the talk was about a year ago
14:47:02 <companion_cube>  > foldr ((++) . flip (:) [] . f) [] $ (+1) [1..4]
14:47:03 <monochrom> @pl \x ys -> f x : ys
14:47:04 <lambdabot> (:) . f
14:47:05 <thoughtpolice> blackh: StrictCore is very interesting though
14:47:14 <companion_cube> > foldr ((++) . flip (:) [] . f) [] $ (+1) [1..4]
14:47:15 <lambdabot>   Ambiguous occurrence `f'
14:47:15 <lambdabot>  It could refer to either `L.f', defined at <local...
14:47:22 <monochrom> = foldr ((:) . f) []
14:47:26 <companion_cube> > \f -> foldr ((++) . flip (:) [] . f) [] $ (+1) [1..4]
14:47:27 <lambdabot>   No instance for (GHC.Num.Num [a])
14:47:28 <lambdabot>    arising from the literal `1' at <inter...
14:47:31 <thoughtpolice> the paper shows some very neat possibilities; I have some code sitting around that implemented the data types for strict core; I was thinking of making it into a library or something
14:47:40 <merijn> roboshibby: fold{l,r} is a function that recursively applies a function to a zero value and each value in a list to reduce the list to a single value (it is also called reduce sometimes)
14:47:55 * hackagebot upload: alsa 0.4 - Binding to the ALSA Library API. (HenningThielemann)
14:47:57 <knobo> monochrom: looks nicer
14:47:59 <roboshibby> wild
14:48:07 <merijn> roboshibby: Although the paper I mentioned actually proves any recursive function is reducable to fold + a trivial function
14:48:08 <dubhrosa> j4cbo: I saw a java trading app up close where they turned off GC, total shambles
14:48:10 <sproingie> is strict core a 6.14 thing or is it some subset of core now?
14:48:23 <Gracenotes> thoughtpolice: one that basically puts everything in normal form?
14:48:27 <roboshibby> wow
14:48:34 <sproingie> dubhrosa: you can't just turn off gc, no.  the java stdlib is embarassingly inefficient in places.
14:48:36 <merijn> roboshibby: Any recursive function on a list, that is. Maybe even all recursive functions, I forget that part :p
14:48:37 <thoughtpolice> yeah, A normal form
14:48:38 <monochrom> > foldr ((:) . f) [] [a,b,c]
14:48:39 <lambdabot>   Ambiguous occurrence `f'
14:48:39 <lambdabot>  It could refer to either `L.f', defined at <local...
14:48:44 <monochrom> > foldr ((:) . f) [] [a,b,c] :: [Expr]
14:48:45 <roboshibby> lol
14:48:46 <lambdabot>   Ambiguous occurrence `f'
14:48:46 <lambdabot>  It could refer to either `L.f', defined at <local...
14:48:51 <monochrom> Hrm!
14:48:52 <thoughtpolice> sproingie: no
14:48:56 <Gracenotes> thoughtpolice: if it means everything needs a typeclass, it might be too much on the slower side...
14:48:58 <sproingie> some of the newer parts of the java stdlib are beautiful.  like the Skiplist class
14:49:01 <monochrom> @undefine L.f
14:49:13 <dubhrosa> j4cbo: also, once you go down that route your hands are completely tied, no jvm updates, no new significant code churn
14:49:15 <monochrom> @undefine f
14:49:20 <merijn> roboshibby: I'd google up the paper, it's surprisingly understandable for a paper in this topic :p
14:49:24 <dibblego> @remember sproingie: some of the newer parts of the java stdlib are beautiful.  like the Skiplist class
14:49:24 <lambdabot> I will remember.
14:49:31 <roboshibby> thanks i will
14:49:36 <Gracenotes> sproingie: yeah, ConcurrentSkipListSet
14:49:40 <thoughtpolice> sproingie: strict core is a new intermediate language designed for languages like e.g. haskell
14:49:42 <j4cbo> dubhrosa: i believe it
14:49:46 <monochrom> > foldr ((:) . f) [] [a,b,c] :: [Expr]
14:49:47 <Gracenotes> java.util.concurrent is on the whole a thing of beauty
14:49:48 <lambdabot>   [f a,f b,f c]
14:50:00 <monochrom> Whoever defined a local f should be shot.
14:50:10 <thoughtpolice> sproingie: it makes certain optimizations on core possible which were previously not possible (or possible, just not robust at all)
14:50:16 <Gracenotes> that would be simple reflect
14:50:41 <dubhrosa> sprongie: they ended up writing "gc-safe" java (their own definition, of that which could not really be defined)
14:50:47 <sproingie> thoughtpolice: sounds like we might finally close the last gap with Clean's performance
14:50:47 <thoughtpolice> Gracenotes: what do you mean everything needs a typeclass?
14:51:02 <sproingie> dubhrosa: sounds like a mess
14:51:22 <thoughtpolice> sproingie: strict core is a huge change though. it would require massive internal restructuring of GHC to implement it in place of STG
14:51:42 <dubhrosa> sprongie: yup. I'm still using c++ for mine; just use haskell for backtesting and prototyping.
14:52:02 <Gracenotes> thoughtpolice: hm. Actually, if everything needed an NF-like class... except supposing all arguments where in NF, and that a function promises to output something in NF, then...
14:52:04 <Veinor> Every time I see the perl 6 operator chart I laugh.
14:52:15 <Gracenotes> you're talking about a more fundamental change
14:52:24 <roboshibby> what's wrong with local f?
14:52:42 <SoleSoul> Thank you everybody! cya
14:52:44 <roboshibby> veinor, url? i want to laugh too
14:52:46 <kmc_> sproingie, some traders don't care about latency on the level of the Java gc
14:52:47 <roboshibby> cya SoleSoul
14:52:51 <thoughtpolice> also re: java gc, doesn't the new java garbage collector solve a lot of soft real-time problems?
14:52:55 <kmc_> and some do care but aren't knowledgable enough to know it
14:53:02 <SoleSoul> roboshibby: bye :)
14:53:11 <kmc_> and there are various ad-hoc tricks to avoid gc
14:53:13 <thoughtpolice> i notice in the paper about Garbage First collection (the 'G1' collector) they say with it that you can tune the maximum amount of time paused during a gc
14:53:14 <Veinor> roboshibby: http://glyphic.s3.amazonaws.com/ozone/mark/periodic/Periodic%20Table%20of%20the%20Operators%20A4%20300dpi.jpg
14:53:17 <Veinor> these are all core.
14:53:42 <dubhrosa> kmc_: true, it's amazing how many brokers advertise their algos as having less than ms latency and stare at you blankly when you ask them about process switch time and gc...
14:53:45 <sproingie> well if we can shut down Goldman's front-running program then maybe there won't be as much a latency arms race in trading
14:53:47 <companion_cube> the example of optimization in the Real World haskell is pretty impressive
14:53:51 <kmc_> Veinor, as in, magical syntax, not user-definable?
14:53:51 <roboshibby> damn
14:53:57 <companion_cube> with C compilation
14:54:08 <Veinor> kmc_: as in, these all exist in perl 6 natively without any imports or whatever
14:54:22 <kmc_> companion_cube, which is that?
14:54:24 <Veinor> several of them, such as 'hyper dwim all' (what the fuck?) are meta-operators
14:54:32 <kmc_> dwim = do what i mean
14:54:41 <roboshibby> is latency really this big of a deal in stock trading? (i used to do commodity trading, im not ignorant)
14:54:41 <sproingie> i suspect it'll always be there tho.  if you can execute a trade faster even on legitimate info, you win
14:54:41 <kmc_> because in Perl, it's considered a bad thing for the language to be predictable
14:54:44 <Veinor> yes, but what do I mean by hyper dwim all?
14:54:46 <roboshibby> but 1, 2 ms?
14:54:47 <roboshibby> wtf
14:54:55 <kmc_> roboshibby, 10 microseconds
14:54:58 <kmc_> is a big deal
14:54:59 <sproingie> roboshibby: something like half of all trades on nasdaq are "high volume"
14:55:01 <kmc_> for some styles of trading
14:55:18 <roboshibby> geez
14:55:18 <dubhrosa> the main latency consideration is cancelling your quotes, not frontrunning
14:55:23 <roboshibby> that's some serious technical trading
14:55:32 <dubhrosa> i.e. if you see a move coming you need to get out of the way
14:55:33 <sproingie> it's actually mostly a front running scam
14:55:37 <kmc_> roboshibby, it's different from what non-computer people call "technical", i.e. squinting at charts
14:55:44 <kmc_> some of it is pure arbitrage between exchanges, etc.
14:55:48 <kmc_> some of it is market making
14:55:49 <sproingie> but even without the front running, you still need your automated trades to respond fast
14:55:57 <companion_cube> kmc_: it's a case study, where authors accelerate the produced binary step by step (unboxing, core langage, compilation to C...)
14:56:00 <kmc_> sproingie, who's frontrunning who/
14:56:19 <sproingie> kmc_: goldman sachs.  the entire stock market.
14:56:24 <kmc_> heh
14:56:28 <kmc_> what's the evidence for this?
14:56:29 <sproingie> look up "flash trading"
14:56:31 <Veinor> gold mansacks you say?
14:56:32 <kmc_> oh god
14:56:39 <kmc_> Veinor, haha
14:56:52 <dubhrosa> sprongie: flash orders only exist on certain US exchanges, none of the european or asian markets have anything like that
14:57:01 <companion_cube> do you know if a qt binding of haskell is to be written some day ?
14:57:02 <kmc_> flash orders are being phased out too
14:57:04 <roboshibby> what do all of you guys work for trading software firms or something?
14:57:05 <sproingie> they're smart
14:57:24 <kmc_> and they're just a different way of accomplishing things that could be done before, e.g. price-to-comply
14:57:33 <dubhrosa> it's the best environment imo - you get to use whatever tech you want
14:57:41 <kmc_> if you believe flash orders are some sinister plot by goldman sachs, you are probably reading misinformed
14:57:45 <kmc_> news articles
14:57:48 <blackh> roboshibby: I'm doing real work: Video games
14:57:54 <holmak> nice!
14:57:54 <Saizan> companion_cube: there's already one
14:57:55 <kmc_> instead of actually understanding the (terribly complicated) market structure
14:58:02 <sproingie> i don't believe in sinister plots, just plots that turn out that way because they can
14:58:11 <roboshibby> sproingie: nod
14:58:19 <pikhq> kmc_: Funny, I always felt like they were a sign that the market had gotten just plain silly.
14:58:19 <companion_cube> Saizan: wow, didn' know... Does it involve black magic on sources like for C++ ?
14:58:32 * kmc_ thinks Reg NMS is kinda dumb to begin with
14:58:49 <Saizan> companion_cube: not sure, look for qtHaskell
14:59:01 <companion_cube> ok, thanks
14:59:07 <doserj> http://qthaskell.berlios.de/
14:59:08 <roboshibby> http://glyphic.s3.amazonaws.com/ozone/mark/periodic/Periodic%20Table%20of%20the%20Operators%20A4%20300dpi.jpg
14:59:09 <roboshibby> insane
14:59:10 <monochrom> @pl (\x y -> 1+y)
14:59:10 <dubhrosa> except for video games work that is....
14:59:10 <lambdabot> const (1 +)
14:59:13 <roboshibby> sheer madness
14:59:17 <monochrom> @pl (\x y -> y+1)
14:59:17 <lambdabot> const (1 +)
14:59:21 <roboshibby> im so glad i never got into perl
14:59:23 <sproingie> i remember having some cyberpunk rpg source book in the early 90's that mentioned stock exchanges being manipulated by massive AI programs trading at top speed
14:59:59 * hackagebot upload: GPX 0.2 - Parse GPX files (TonyMorris)
14:59:59 <kmc_> yup, cyberpunk was prescient about a lot of things
15:00:06 <marsh_> Remember October 1988 anyone? "Program trading" they called it
15:00:21 <roboshibby> man
15:00:24 <sproingie> same game, order of magnitude different speed
15:00:31 * kmc_ was 7 months old in october 1988
15:00:35 <dubhrosa> human panic, always gets blamed on the latest tech fad
15:00:45 <kmc_> sproingie, can you explain why flash orders are an unfair advantage to GS?
15:00:46 <roboshibby> no wonder the 70s-90s were a technical quiet period, everyone was ramping up computers to do evil shit
15:01:20 <dubhrosa> kmc_: you have to declare affiliation if you actually work for GS, right?
15:01:21 <roboshibby> i read so many papers from the 70s that are lightyears ahead of common tech today. things had to have been suppressed
15:01:26 <kmc_> dubhrosa, me?
15:01:29 <kmc_> i don't work for GS
15:01:37 <kmc_> i work for a smallish hedge fund
15:01:40 <marsh_> kmc_: to me it's the general category of "people with money get insider info"
15:01:45 <dubhrosa> kmc_: London?
15:01:51 <kmc_> marsh_, what insider info?  the flash order feeds are public.
15:02:16 <kmc_> if GS is actually getting some secret feed from the exchanges, that's mega-illegal
15:02:31 <monochrom> knobo: banana split specialized to lists, and in pointful form in Haskell: (foldr h b xs, foldr k c xs) = foldr (\x (y,z) -> (h x y, k x z)) (b,c) xs. The RHS is one single "banana" (fold), it is split into a pair of bananas on the LHS. An example: (sum xs, length xs) = (foldr (+) 0 xs, foldr (\x y -> 1+y) 0 xs) = foldr (\x (y,z) -> (x+y, 1+z)) (0,0) xs  gives you a one-pass way to compute both sum and length of xs.
15:02:38 <roboshibby> you know the markets are dirty
15:02:44 <marsh_> It sounded like the SEC was frowning upon selling faster and deeper data
15:02:52 <sproingie> that's been the allegation, that they basically peered with the nyse (sorry, not nasdaq) machines to get the feed earlier
15:03:01 <marsh_> or some sort of "right of first refusal" on incoming orders
15:03:09 <kmc_> sproingie, everyone who wants high speed colocates at the exchange
15:03:15 <sproingie> i don't single out GS, i imagine any firm would do that
15:03:33 <kmc_> marsh_, that's interesting about SEC frowning on selling feeds.  but selling feeds to anyone who can pay is very different from "insider info"
15:03:35 <roboshibby> fucking exchange peering? lol
15:03:44 <kmc_> i would be happy if all exchanges offered their realtime data feeds for free
15:03:54 <kmc_> some already do
15:04:08 <dubhrosa> god bless bats
15:04:08 <marsh_> even if it's just "insider info" for a millisecond...
15:04:18 <sproingie> technically it's the same reason we have exchange floors.  you execute your trades faster if you're there and don't wait for Ye Olde Messenger to arrive with news of the East India Company's stocks
15:04:27 <roboshibby> lol
15:04:29 <kmc_> marsh_, again, how is it "insider"?  it's insider because some people can't afford to pay for it?
15:04:32 <marsh_> Lol, Bats is right down the street from me
15:04:48 <kmc_> roboshibby, indeed.  the server space inside the exchange datacenters is a prized commodity
15:05:02 <roboshibby> well, i guess that makes sense. wild
15:05:03 <kmc_> to the point where big banks will buy rack space just to sit on it so their competitors cant' have it
15:05:03 <marsh_> kmc: I don't know the details, just the bits that filtered through the article I read
15:05:13 <roboshibby> hopefully they dont use internap datacenters. (sucking POS)
15:05:18 <kmc_> marsh_, yeah... the media reporting on flash orders has been pretty terrible
15:05:20 <roboshibby> HAHA
15:05:43 <sproingie> i don't think it's sinister, i just think it's hugely destabilizing
15:05:46 <kmc_> i don't claim to be an expert in market microstructure but i work with some people who can justifiably make that claim
15:05:52 <marsh_> My guess is that nobody knows the extent of what goes on, even most of those engaged in it!
15:06:03 <roboshibby> marsh, nod
15:06:10 <kmc_> sproingie, automated trading was the only stable market niche last year.
15:06:30 <sproingie> kmc_: maybe it all stabilizes itself.  i have my doubts.
15:06:47 <kmc_> the big destabilizing forces are massive directional bets on (illiquid, human-tradeable, opaque) complicated derivatives
15:06:55 <roboshibby> manipulation=>control is what restabilizes destabilizing actions
15:07:05 <sproingie> kmc_: aka "a side bet you wouldn't be allowed to make in Vegas"
15:07:10 <marsh_> It's hard to be affected by macroeconomic swings when you're cycle time is in microseconds
15:07:15 * sproingie moves to #haskell-blah
15:07:27 <roboshibby> yea im raging conversation'd out
15:07:27 <knobo> monochrom: thanx
15:07:29 <dubhrosa> if it weren't for automated trading market making the markets would be more volatile because they wouldn't be there to absorb the flow when some spiv dirties his pants and dumps a day's volume worth of stock in one go
15:07:42 <kmc_> haha
15:07:44 <knobo> I found the paper
15:07:55 <marsh_> Is that why the markets are so much less volatile now?
15:08:11 <roboshibby> that and fractional points
15:08:13 <roboshibby> smaller spread
15:08:26 <dubhrosa> smaller spread comes directly from more market making
15:08:39 <roboshibby> imo it comes directly from fractional points
15:08:57 <kmc_> i would rather have some computer take two cents from every trade i make, than have a cabal of humans take fifteen cents
15:09:07 <Veinor> 18:07:56 < lou> i kinda want to learn haskell but it looks like perl
15:09:10 <marsh_> Clearly the only fair thing to do is move all the exchanges to Jupiter so all Earthlings have an equal latency
15:09:11 <roboshibby> looking at volatility as quantity and not range, i guess
15:09:27 <knobo> Does the ghc compiler do the banana split optimization?
15:09:50 <kmc_> before automated trading it was much easier for all the brokers and special players to get together and collude on how to fuck you, the retail investor
15:09:50 <roboshibby> ok im spent. ill see you guys later on!
15:09:52 * roboshibby afk
15:10:00 <kmc_> they still do this of course, but there's been a race to the bottom in how much they can extract
15:10:02 <blackh> roboshibby: see ya
15:10:06 <companion_cube> j4cbo: btw, is SML more used than ocaml ? Cause they seem to be very close
15:10:32 <kmc_> definitely it's still the case that, when you place an order on etrade or whatever, there's only a small chance the order makes it to the public open market
15:12:18 <|fft|> Is there equivalent to  ( x <- a ) ?  I mean more strict than "bind  the computation result to value" ?
15:12:35 <|fft|> *equivalent definition
15:12:40 <Lemmih> |fft|: a >>= \x -> ...
15:13:03 <monochrom> x<-a; x `seq` whatever is on the next line
15:13:16 <|fft|> Lemmih: Ah I've remembered. Thanks
15:13:21 <aavogt> > case () of _ | Just x <- Nothing -> x | otherwise -> 1
15:13:22 <lambdabot>   1
15:13:51 <aavogt> I think <- might also come up else besides do and pattern guards
15:13:58 <Berengal> http://www.pic-spot.com/images/viu1262128256t.png
15:14:15 <kmc_> Berengal, haha
15:14:19 <kmc_> mfix?
15:14:27 <kmc_> or hmm maybe just fix
15:14:37 <Berengal> It's some kind of fix...
15:14:48 <kmc_> thought i saw a monad operator but i guess not
15:15:24 <monochrom> (λx.y) = const y
15:15:25 <kmc_> monochrom, why seq?
15:15:40 <monochrom> Because he said "more strict".
15:16:00 <sproingie> kmc_: never thought of automated trading as a buffer before.  interesting perspective.
15:16:16 <kmc_> monochrom, heh
15:16:46 <unautre> hi
15:16:49 <kmc_> hi
15:17:19 * sproingie goes back to learning simple things like linear algebra and GPU programming
15:17:54 <kmc_> you can use that GPU programming for volatility arbitrage on the options markets ;)
15:18:02 <dubhrosa> sprongie: have you seen Jacket accelereyes plugin for GPU via Matlab? super sweet
15:18:26 <marsh_> I'd been playing with Test.HUnit. Any opinions about how to organize source files for unit testing? (sorry if that's an un-Haskell thing to do)
15:18:42 <monochrom> GPU programming is not simple to me. fold laws are so much simpler.
15:19:09 <sproingie> dubhrosa: i know nada about all things matlab or mathematica or whatnot.  i'm a math dunce.
15:19:35 <sproingie> trying to to learn enough linalg to do basic matrix math for writing shaders
15:19:39 <McManiaC> anyone here who can help me with a parsec script?
15:19:40 <bob0> McManiaC: no
15:20:06 <McManiaC> http://npaste.de/9R/ ← how can I make "text" cover everything else where pasteId etc fails?
15:20:26 <McManiaC> currently something like "/foo bar" will result in an error
15:20:40 <McManiaC> (empty list)
15:21:10 <p_l> http://i.imgur.com/1gF1j.jpg <--- hahahaha. Somehow, I still find the cat flattering :)
15:21:19 <McManiaC> same with "@ moep" etc
15:21:32 <monochrom> McManiaC: try pasteId <|> userName <|> tag <|> text
15:21:56 <dubhrosa> sproingie: the Matlab clone Octave is really good, simple environment for matrix programming, if you want to try stuff as you learn
15:21:57 <monochrom> I mean this: add "try" to "pasteId".
15:21:58 <ane_> that picture is great
15:22:21 <McManiaC> monochrom: nope =(
15:22:47 <sproingie> mostly i have this psychological block learning math-related things that i have to overcome
15:23:07 <sproingie> and it's damn harder to do that at age 37 than at 17
15:23:24 <monochrom> OK, then rewrite the code for text so it allows "/"
15:23:28 <dubhrosa> me too, so I code my way into the math
15:24:03 <sproingie> i was raised in catholic school where it was a common punishment to be forced to write out times tables or sum up large columns of numbers
15:24:15 <monochrom> text = many1 (noneOf "#@") >>= return . Text
15:24:16 <sproingie> in short, i quite literally associate numbers with *punishment*
15:24:26 <dubhrosa> but you like coding, right?
15:24:31 <sproingie> hell yah
15:24:39 <yitz> sproingie: gauss was able to deal with that
15:25:08 <sproingie> gauss was much smarter than me
15:25:11 <marsh_> that wasn't just Catholic school
15:25:37 <McManiaC> monochrom: i could of course do something like "text = many1 (noneOf "") ..." but then nothing will get detected ^^
15:25:41 <McManiaC> *else
15:25:42 <dubhrosa> what works for me is to write code as I study the math, never finish a concept without verifying it with a little code...
15:25:56 <sproingie> i've got the IQ for doing symbolic manipulation.  not genius level, but i manage.  when it comes to overcoming those mental blocks, i'm a sub-moron
15:26:23 <Berengal> Who needs numbers when you've got symbols anyway?
15:26:27 <dubhrosa> no such thing. you just haven't practised enough. same as learning piano.
15:26:42 <marsh_> I'm convinced it's a different part of the brain that think's it's a cat getting a bath
15:26:55 <companion_cube> sproingie: you can do math without writing any other number than 0,1 or sometimes 2 :)
15:27:07 <companion_cube> the more abstract, the less numbers
15:27:19 <sproingie> awesome.  i wish i was taught that way
15:27:28 <Berengal> It then turns into greek, then hebrew, then just squiggles...
15:27:42 <dubhrosa> I second that, I do a lot of linalg and never actually need to look at the numbers,
15:28:00 <companion_cube> then you just write plain text to explain what you do, with some sparse formulae
15:28:15 <Berengal> And diagrams!
15:28:33 <monochrom> Why plain text?
15:28:33 <companion_cube> (or you can do analysis, with plenty of ugly symbols filling whole lines)
15:28:36 <sproingie> i probably need to stock up on textbooks to re-learn all this stuff
15:28:38 <dubhrosa> and start with the problem, rather than the abstract mathematical frameworks that are applicable in general to the field
15:29:13 <Cale> The numbers which I'd consider important are 0, 1, -1, pi, e, i, 2, 3, 4, 6 (in rough order of importance) and various things composed from those in simple ways.
15:29:21 <Cale> (like sqrt(2))
15:29:25 <McManiaC> Cale: jup
15:29:32 <monochrom> Example of reasoning by plain text: "0 stands for nothing, the empty string stands for nothing, therefore 0 = the empty string."  From many a student.
15:29:34 <dubhrosa> Cale: why 6?
15:29:46 <Cale> First natural number which is a product of two distinct primes
15:29:50 <McManiaC> who needs the 6 anyway
15:30:01 <McManiaC> \inf might be important too, but that aint a real number
15:30:02 <McManiaC> ^^
15:30:04 <sproingie> "nothing is better than God, therefore God is worse than nothing"
15:30:07 <Cale> Many structures only start to become nontrivial at 6.
15:30:22 <kmc_> monochrom, 0 is a fine name for the unit of the string monoid ;)
15:30:26 <yitz> Cale: 5 is more important than 6. order of smallest simple group.
15:30:27 <sproingie> yay for amphiboly
15:30:30 <companion_cube> monochrom: i meant, writing sentences rather than sequences of formulae or calculus
15:30:43 <Cale> For instance, 6 is the smallest size for a nonabelian group.
15:30:47 <monochrom> Yes companion_cube, I mean that too.
15:31:00 <companion_cube> oh, sorry
15:31:11 <Cale> I don't know if I believe in simple groups ;)
15:31:26 <Cale> Also, Z_2 is simple
15:31:34 <monochrom> Example of a sequence of sentences that makes a lot of sense as sentences: "0 stands for nothing, the empty string stands for nothing, therefore 0 = the empty string."  From many a student.
15:31:42 <yitz> oh, excuse me, A5 (order 60)
15:31:44 <dubhrosa> sproingie: buying a bunch of textbooks is not a good idea. find someone you can discuss math with, it's a million times more productive
15:31:58 <yitz> so yeah, 6.
15:32:02 <Cale> So yeah, 60 shows up too.
15:32:02 <companion_cube> finite simple group of order 2...
15:32:08 <yitz> :)
15:32:22 <companion_cube> or even 42
15:32:23 <McManiaC> monochrom: how can i put something like "do { char '/'; many1 alphaNum ; ...}" into one "try" block?
15:32:34 <koeien37> heh. S_6 is magical
15:32:42 <koeien37> John Baez has written an article on that
15:32:44 <Berengal> McManiaC: try $ do {...}
15:32:49 <monochrom> "try (do { char '/'; many1 alphaNum ; ...})"
15:32:55 <dubhrosa> sproingie: I've seen people get really bogged down in the textbooks, get frustrated, then give up
15:32:56 <monochrom> I hate money and $.
15:33:08 <Botje> use € instead.
15:33:08 <Cale> It's been so much work finding all the finite simple groups, and yet we don't actually know how to put them back together again.
15:33:14 <sproingie> dubhrosa: the dust gathering on the few textbooks i have stands mute testament to that
15:33:15 <Berengal> £
15:33:25 <koeien37> http://math.ucr.edu/home/baez/six.html
15:33:28 <monochrom> "try € do ..."
15:33:40 <koeien37> use 牛 instead
15:33:52 <monochrom> That's alphanumerical, unfit for infix op.
15:33:57 <koeien37> ah right
15:33:59 <sproingie> dubhrosa: i have no math geek friends, and i somehow don't think i can get random folks on IRC to give me a curriculum
15:34:06 <Berengal> Hah, "try £ do ..."
15:34:38 <monochrom> "try `豬牛羊` do ..." :D
15:34:49 <Berengal> "try ¤ do ..."
15:34:54 * Cale needs to fix his fonts.conf apparently.
15:34:56 <sproingie> ooh
15:35:09 * koeien37 doesn't know 豬
15:35:13 <monochrom> pig
15:35:37 <Cale> I'm back to antialiased hiragana and Chinese characters are showing up in a strange font.
15:35:39 <koeien37> yeah that makes some sense near 牛 and 羊
15:35:50 <dubhrosa> sproingie: ah, that's kind of my point, unless you're in college you shouldn't try to work off a curriculum - work on problems that are mathematical and learn the relevant math as part of solving the problem. if you try to learn math in isolation you will not succeed because it will continue to be abstract, therefore will not resonate
15:36:05 <koeien37> i concur
15:36:05 <monochrom> animal farm programming
15:36:39 <companion_cube> math is hard enough to require a teacher
15:36:54 <monochrom> math is so hard it requires three teachers.
15:37:10 <monochrom> And the best teacher is the third one.
15:37:23 <Berengal> I've had seven...
15:37:28 <dubhrosa> sproingie: and there are tons of forums where you can ask math questions, but if possible do try to find a math geek - if you're near a university there are always grad students looking for extra tutorial hours
15:38:03 <monochrom> http://mathoverflow.net/ XD
15:38:06 <koeien37> it would also help if you have some idea of a topic that you'll like
15:38:19 <Dunearhp> math teachers are like monad tutorials. Until you find the right one, nothing makes sense.
15:38:26 <companion_cube> :D
15:38:37 <sproingie> games mostly.  learning opengl right now, though it's mostly for 2d effects.
15:38:38 <dubhrosa> sproingie: idea for a startup - connect math tutors to students over skype and payments via paypal
15:38:42 <yitz> $¢₥₠€₣₤£₧₱¥৲৳૱௹฿៛﷼ℳ₡₢₦₨₩₪₫₭₮₯₰¤
15:38:44 <koeien37> i don't know why monads are so hard
15:38:54 <koeien37> yitz: and this is?
15:38:57 <Botje> they're hard because people keep saying they are
15:39:12 <monochrom> I don't know why logic is so hard.
15:39:13 <koeien37> probably
15:39:21 <yitz> koeien37: all of the currency symbols that Colloquy knows about
15:39:24 <companion_cube> sproingie: so you are interested in linear algebra
15:39:28 <Botje> if you get the concept of a transitive closure or checked exceptions in java, you can understand monads.
15:39:33 <monochrom> Or more relevantly in #haskell, why type inference is so hard.
15:39:47 <koeien37> yitz: maybe there are former national ones in the euro area too :)
15:39:51 <j4cbo> type inference *is* hard
15:39:55 <companion_cube> monochrom: because it is forst-order N
15:39:56 <monochrom> See?
15:39:57 <companion_cube> ?*
15:39:57 <lambdabot> Maybe you meant: . ? @ v
15:40:01 <Botje> that's why you have ghc to do it for you! :)
15:40:22 <mokus> monads are hard because it's hard for the people trying to explain them to strike a good balance between correctness and concreteness
15:40:26 <j4cbo> hindley-milner is 2^(2^n), iirc
15:40:29 <mokus> IMO anyway
15:40:31 <sproingie> companion_cube: insofar as i can use it for graphics programming.  being able to turn graph problems into matrix problems would be a bonus too
15:40:36 <j4cbo> that's very hard :P
15:40:46 <monochrom> And I just mean toy examples appearing in homework and exams.
15:40:57 <koeien37> at least it's decidable :P
15:41:07 <McManiaC> monochrom: i think i got it :O
15:41:23 <j4cbo> provided you don't try to bolt too much extra stuff on, yes
15:41:43 <sproingie> i have a few algorithms at work that are brute force graph traversal problems that could possibly be vectorized, but i haven't the foggiest idea how
15:41:48 <McManiaC> monochrom: completly different tho: http://npaste.de/9S/
15:42:52 <sproingie> modern video cards have enough ram that i can probably just port the brute force algorithm to the GPU
15:43:06 <yitz> McManiaC: yay!
15:43:16 <sproingie> needless to say GPipe is something i'm looking at learning
15:43:45 <companion_cube> sproingie: i don't know much about vectorisation of algorithms :/
15:43:46 <Cale> grr, why is getting fontconfig to respect my order preferences so challenging!
15:43:56 <McManiaC> yitz: :)
15:44:00 <koeien37> it's linux, it's not supposed to be easy or straightforward
15:44:42 <McManiaC> its supposed to be awesome
15:44:43 <McManiaC> \o/
15:44:44 <McManiaC> :D
15:51:05 <Cale> Ah, there we go. Apparently something removed Bitstream Vera Sans Mono, and it messed up font selection completely somehow.
15:51:21 <koeien37> ok
15:52:08 <koeien37> does it work again?
15:52:15 <Cale> After switching my config to use DejaVu Sans Mono, it works, and the MS Gothic selection does too. I think I understand what went wrong.
15:52:30 <koeien37> 我爱牛
15:54:23 <yitz> koeien37: מה זה?
15:54:29 <koeien37> hebrew?
15:54:40 <yitz> yes
15:54:48 <koeien37> I don't speak it
15:55:01 <yitz> i said, what is that?
15:55:04 <shapr> Can you do the ij ligature for Dutch?
15:55:25 <Cale> 新年おめでとう！
15:55:38 <Cale> Yeah
15:55:39 <yitz> ĳ
15:55:48 <Cale> Hmm, I'd never seen 爱 before, but it was similar enough to 愛 for me to guess.
15:55:58 <koeien37> probably simplified
15:56:12 <koeien37> japanese uses the traditional characters, right?
15:56:27 <alexsuraci`> yeah
15:56:59 <Cale> apparently it's even pronounced AI4 in Mandarin :)
15:57:03 <Cale> yeah
15:57:03 <koeien37> right
15:57:13 <yitz> shapr: here's the upper case one: Ĳ
15:57:35 <pikhq> koeien37: Japanese uses *mostly* traditional characters.
15:57:36 <koeien37> I'm not aware of any dutch who writes "ij" different from an i and then a j, on a keyboard, that is
15:57:58 <shapr> yitz, nifty
15:57:59 <pikhq> They simplify a few things, and often differently than Simple Chinese.
15:58:21 <yitz> koeien37: but Word probably replaces it with the ligature using an autotext
15:58:26 <koeien37> probably
15:58:32 <pikhq> (Japanese simplification of characters is merely a bit older, and based on what people had been using as shorthand, rather than simplification by fiat)
15:59:39 <shapr> koeien, it's interesting: http://en.wikipedia.org/wiki/IJ_%28digraph%29
16:00:28 <shapr> I like the capital broken U on that page... pretty cool.
16:00:37 <tensorpudding> is (Int, Int) an instance of Ix?
16:01:04 <koeien37> yeah it is somewhat special in Dutch
16:01:19 <shapr> My middle name is Matijs, would be cool to spell that with the correct UTF-8 ligature.
16:01:36 <koeien37> I don't have any "ij" in my name :(
16:02:02 <shapr> aww
16:02:15 <koeien37> are you dutch or flemish?
16:02:42 <shapr> Nah, I'm actually from Alabama, but I claim to be from the Swedish speaking part of Alabama.
16:03:00 <sproingie> do you have a banjo on your knee?
16:03:01 <yitz> shapr: ok, here: Matĳs
16:03:07 <shapr> yitz, woah awesome!!
16:03:11 * shapr boings cheerfully
16:03:16 <koeien37> cool
16:03:28 <shapr> sproingie, I often have a guitar on my knee, but never a banjo.
16:03:37 <sproingie> got that in compose here.  dĳkstra
16:04:21 <yitz> shapr: i'm in awe, you share a ligature with Dĳkstra
16:04:31 <shapr> That's about all we share.
16:04:36 <Nafai> Hey shapr!
16:04:48 <shapr> hiya Nafai!
16:05:18 <Nafai> How are you?"
16:05:20 * shapr now has an email ligature
16:05:33 <shapr> I'm hacking Python on my BUG at the moment.
16:05:48 <shapr> How are you?
16:06:32 <mokus> what's the point of having ligature characters other than to destroy sorting algorithms?  shouldn't that be something that's deferred to the typesetting/text rendering phase of whatever you're doing with the text?
16:06:36 <monochrom> tensorpudding: (Int,Int) is an instance of Ix.
16:06:47 <Nafai> I'm okay, still looking for work, etc
16:07:02 <koeien37> wikipedia says that use of ĳ (U+0133) is discouraged
16:07:24 <shapr> koeien37, I still think it's way nifty.
16:07:25 <koeien37> tensorpudding: yeah you can use it for multidimensional arrays
16:08:12 <shapr> mokus, Faithfulness to the original local orthography? Have you seen the old school Croatian characters? They look more like astrological symbols than characters to me.
16:08:34 <koeien37> Dutch doesn't use the y
16:08:40 <monochrom> Culture is hard. Let's go haskelling.
16:09:00 <pikhq> mokus: Sorting is already very hard to do when localised, even without ligatures.
16:09:06 <monochrom> Even monad is easier than all those cultural exceptions.
16:09:22 <troutwine> monochrom: But what if our haskelling requires us to deal with international alphabets!?
16:09:24 <mokus> shapr: I'm not familiar with the croatian characters.  do they make use of ligatures in such a way that the combination of 2 characters is semantically meaningful and separate from the meaning of the same characters in sequence?
16:09:42 <monochrom> kill international alphabets
16:09:56 <sproingie> screw this, i'm gonna write my haskell in rongorongo
16:09:57 <monochrom> Just write a bunch of hylomorphisms and be happy
16:10:05 <pikhq> monochrom: So, what, everything should be transcribed to the English Roman alphabet?
16:10:17 <sproingie> i wonder how the offside rule works with bustrophedon script
16:10:19 <monochrom> No. Just do math.
16:10:27 <pikhq> Oh, okay.
16:10:34 <troutwine> monochrom: Monads are easier becasue they're underpinned by rigourous logic; culture was created by people who were drunk half the time.
16:10:35 <pikhq> Lojban it is, then.
16:10:42 <pikhq> (when pure notation doesn't suffice)
16:11:04 <shapr> pikhq, lojban has a feanorian orthography that's particularly entertaining... I think ESR came up with it.
16:11:26 <koeien37> I only have seen the latin, greek and hebrew alphabets used in mathematics
16:11:27 <shapr> mokus, I'm just saying that I appreciate both regularity and variety.
16:12:37 <araujo> http://i.imgur.com/1gF1j.jpg
16:12:58 <shapr> mokus, Here's something about old school croation: http://en.wikipedia.org/wiki/Church_Slavonic
16:12:59 <koeien37> araujo: whahaha
16:13:03 <mokus> shapr: I suppose I can see a point there.  But it does seem to me that the same could be achieved in 'rich' formats for graphic arts, where such things are more likely to matter, using some kind of annotation in the data
16:13:12 <araujo> koeien37, heh
16:13:26 <mokus> without making the sorting of text harder than it already is
16:14:03 <pikhq> mokus: Having a database of what the lexical ordering is for a language is already necessary.
16:14:13 <shapr> Once you combine unicode and localization, sorting is pretty exciting already. I totally agree with that.
16:14:18 <pikhq> Having ligatures doesn't make this any more difficult.
16:14:39 <mokus> pikhq: true, good point
16:14:49 <pikhq> (assuming you don't want ASCIIbetical sorting)
16:14:57 <mokus> I concede the point to both of you, and release #haskell to speak of haskelly things ;)
16:15:01 <shapr> heh
16:15:15 <shapr> mokus, Good point to bring up a fun discussion :-)
16:15:27 <companion_cube> monochrom: too bad foreign languages need special caracters, uh ?
16:15:49 <mokus> that slavonic text is quite interesting.  I have seen it before but didn't know what it was
16:16:05 <mokus> looks a lot like modern russian
16:16:15 <mreh> shuffling has been discussed to death on here hasn't it
16:16:32 <shapr> mokus, Huh it does... I never noticed that.
16:17:21 <shapr> But then, my exposure to cyrillic was after my exposure to church slavonic... that's probably why.
16:17:41 <mokus> so to you, cyrillic looks like slavonic? ;)
16:17:47 <shapr> Yeah, pretty much :-)
16:18:26 <koeien37> mreh: do you have a question about it?
16:18:51 <mreh> koeine37: yeah, general approaches to the problem
16:19:07 <p_l> mokus: cause modern russian evolved (in a way) from church slavonic, iirc
16:19:19 <shapr> p_l, Really? Got more info on that?
16:19:32 <koeien37> I wouldn't know the fastest way to shuffle a list. If you want to shuffle an array, there is an easy algorithm
16:19:49 <mokus> p_l: yea, i was just reading the wikipedia article and although it didn't outright say so, at least not that i noticed, i can definitely see how that would make sense
16:19:56 <p_l> shapr: assuming we are talking about the exact same language (the one orthodox church uses)
16:19:58 <troutwine> shapr: Look at http://en.wikipedia.org/wiki/Russian_language
16:20:09 <troutwine> Er, http://en.wikipedia.org/wiki/Russian_language#Classification
16:20:23 <koeien37> otherwise, you could insert a card at a random position. That is O(n^2) though.
16:20:49 <shapr> troutwine, nifty!
16:21:10 <koeien37> so there is definitely a faster algorithm for shuffling a list
16:21:19 <p_l> polish, chech and russian all come from common root, with church slavonic being a particularly old variant, and the script used is an older version of cyrillic
16:21:32 <dmhouse> Is http://haskell.org/haskellwiki/How_to_profile_a_Haskell_program the best option for a tutorial on profiling Haskell programs?
16:21:42 * dmhouse has written a graph colouring program which is Too Slow
16:22:06 <koeien37> there is a chapter in RWH about profiling
16:22:35 <koeien37> but graph coloring is a hard problem
16:23:03 <dmhouse> Yeah, but I'd like to speed it up at least a bit
16:23:23 <dmhouse> It needs to be able to run on a graph of 60 vertices in a reasonable time, and it doesn't at the moment
16:23:40 <troutwine> How slow is too slow?
16:23:44 <pikhq> In essence, Church Slavonic is to the Slavic languages as Latin is to the Romantic languages...
16:23:47 <koeien37> is that reasonable? i.e., do you know of a program that does that in reasonable time?
16:24:05 <dmhouse> (The algorithm is to pick the largest empty subgraph I_1, then the largest empty subgraph in G\I_1, then the largest empty subgraph of G\(I_1 u I_2), etc. It doesn't guarantee a chi(G) colouring, but it's not bad.)
16:24:20 <koeien37> oh, you are approximating
16:24:20 <dmhouse> koeien37: it's part of the brief for my project, so I know it's possible
16:24:26 <sshc> I'm trying to use the State Monad, but it's failing  http://pastebin.com/f751bbbe8
16:24:40 <koeien37> what is your graph representation? are you using FGL?
16:25:11 <koeien37> sshc: What is your goal with (\x -> x + 1) in line 43 ?
16:25:23 <dmhouse> koeien37: nope, I haven't done any optimisation whatsoever thus far. I'm just using Ints to label vertices, so a vertex is a (Int,[Int]) pair and a graph is a list of such vertices.
16:25:44 <koeien37> so a graph is an Array Int (Int,[Int]) ?
16:26:01 <koeien37> oh, a list
16:26:07 <koeien37> well, (!!) is O(n)
16:26:23 <koeien37> but RWH has a chapter on profiling. Also the GHC manual explains it
16:26:55 <dmhouse> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15205#a15205 is my current code, for the curious
16:27:06 <dmhouse> (It's a really pretty algorithm, incidentally. Mutual recursion!)
16:27:16 <koeien37> yeah, nice and short
16:27:50 <kmc_> shapr, what's a BUG?
16:28:08 <shapr> kmc_, http://www.buglabs.net/products
16:28:18 <kmc_> ah very nice
16:28:23 <kmc_> what stuff do you have for it?
16:28:31 <shapr> I have all the modules, and one that doesn't exist yet.
16:28:41 <kmc_> :O
16:28:48 <dmhouse> koeien37: but a good start would be to use FGL, you reckon?
16:28:59 * dmhouse doesn't own RWH, unfortunately
16:29:00 <koeien37> a good start would be to fire up the profiler :)
16:29:03 <koeien37> @where RWH
16:29:03 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:29:06 <koeien37> it's available online
16:29:11 <dmhouse> Oh, brilliant
16:29:17 <shapr> kmc_, I'm trying to build the one that does not exist yet :-) it's a touchscreen that's as large as the bugbase itself.
16:29:17 <koeien37> although I recommend to buy it anyway ;)
16:29:30 <kmc_> ah nice
16:29:48 <dmhouse> koeien37: cheers. If I weren't a broke student I definitely would do. I suppose I could put in a request to the library, though
16:30:01 <shapr> I got my copy of RWH signed by one of the authors!
16:30:22 <shapr> Now I gotta get it signed by the other authors...
16:30:40 <koeien37> sshc: if you mean by (\x -> x + 1), "increase the state by one", you need to use "modify (\x -> x + 1)" or "modify (+1)" instead
16:31:13 <koeien37> but the state is a tuple, so that's not going to work i see now
16:31:51 <koeien37> sshc: juding by the top comment, you want "State NumberOfIncrements Value" instead.
16:31:55 <koeien37> judging*
16:32:31 <koeien37> in "State s a", the "s" is the type of the state you want to store. You want to store the number of increments, so you should store a value of type NumberOfIncrements there
16:32:53 <koeien37> "a" is the type of the result.  So I'd expect runIncCounter :: State NumberOfIncrements Value
16:33:04 <lpsmith> does "ghc-pkg list" show the installed packages in a topological sorted order?
16:33:14 <koeien37> sshc: but it depends a bit on what you want to do
16:33:37 <Twey> > toEnum (negate 1) :: Integer
16:33:39 <lambdabot>   -1
16:33:41 <EvanCarroll> how come this work sData.List.map ($ 2) [(+4) , (+5) ], but this doesn't Data.List.map ($ "test") [putStrLn, putStr]
16:33:59 <koeien37> :t map ($ "test") [putStrLn, putStr]
16:34:00 <lambdabot> [IO ()]
16:34:00 <kmc_> EvanCarroll, the second one returns a list of IO actions
16:34:01 <yitz> dmhouse: a simple thing to try would be Data.Set instead of lists.
16:34:08 <koeien37> it works! but the result may be not what you expect
16:34:16 <xerox> EvanCarroll it does, to evaluate it, you need to  sequence  it
16:34:17 <kmc_> EvanCarroll, a list of IO actions is not an action.  you can turn one into the other with "sequence"
16:34:37 <yitz> EvanCarroll: use mapM
16:34:43 <Twey> But not the other into one ;)
16:34:43 <koeien37> :t sequence_ :: [IO ()] -> IO ()
16:34:44 <lambdabot> [IO ()] -> IO ()
16:34:53 <kmc_> EvanCarroll, if you have a list of actions you can also do something else, like execute only the first one, or do them in reverse order, or execute the first one five times and the second one only if it's Tuesday
16:35:10 <yitz> @type mapM
16:35:10 <companion_cube> this is so awesome
16:35:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:35:31 <koeien37> :t sequence . map
16:35:32 <lambdabot>     Couldn't match expected type `[m a]'
16:35:32 <lambdabot>            against inferred type `[a1] -> [b]'
16:35:32 <lambdabot>     Probable cause: `map' is applied to too few arguments
16:35:38 <koeien37> :t (sequence .) . map
16:35:39 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
16:35:46 <EvanCarroll> hrm
16:35:51 <EvanCarroll> I'll go back to reading more ;)
16:35:52 <EvanCarroll> cool
16:36:01 <koeien37> yeah, the result of your map is of type [IO ()]
16:36:08 <Twey> EvanCarroll: IOW, it worked, it just didn't do what you thought it would ☺
16:36:09 <kmc_> EvanCarroll, the important thing to realize is: evaluation never has a side effect.  even evaluating a value of type (IO ()) never has a side effect.
16:36:13 <koeien37> that is a list of actions. Evaluating this list does NOT perform the I/O actions!
16:36:18 <kmc_> the side effect happens when you *execute* the IO action, not when you evaluate it.
16:36:34 <companion_cube> :t (sequence .)
16:36:35 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f) => f [m a] -> f (m [a])
16:36:43 <kmc_> > ["send a packet to google.com", "turn the monitor off"]
16:36:44 <lambdabot>   ["send a packet to google.com","turn the monitor off"]
16:36:44 <Twey> No matter how much you stare at that recipe, it won't morph into a lasagna
16:36:48 <kmc_> ^^^^^ list of IO actions
16:36:59 <xerox> of descriptions thereof :)
16:37:08 <Twey> Hehe
16:37:17 <kmc_> yeah, a value of IO-type can be seen as a description of an action that you may or may not take in the future
16:37:27 <koeien37> there is no function perform :: IO a -> a, so you need to use your function "main" to perform I/O actions. Or use GHCi
16:37:34 <kmc_> the only action which actually gets executed is "main"
16:37:47 <kmc_> which is why you need (>>=) and friends to glue smaller actions together into bigger ones
16:38:00 <kmc_> and when you're done gluing you call that "main"
16:38:04 <kmc_> and try not to faint from the fumes.
16:38:04 <companion_cube> or "do" notation
16:38:12 <companion_cube> instead of >>=
16:38:14 <kmc_> right, which is just sugar for (>>=)
16:39:48 <kmc_> > let sequence = intercalate ".  After that, " in sequence ["send a packet to google.com", "turn the monitor off"]
16:39:49 <lambdabot>   "send a packet to google.com.  After that, turn the monitor off"
16:40:02 <kmc_> > let sequence = intercalate ".  After that, " in sequence (reverse ["send a packet to google.com", "turn the monitor off"])
16:40:02 <lambdabot>   "turn the monitor off.  After that, send a packet to google.com"
16:40:29 <koeien37> This is another I/O action. However, evaluating it still does not perform it :)
16:40:31 <xerox> another couple of functions and you have a working self-explanatory set of IO actions
16:40:46 <xerox> ala simple-reflect, io-explainer
16:40:53 <kmc_> that could be useful
16:41:05 <kmc_> lambdabot's Show (IO a) instance could use some special sauce
16:41:12 <shapr> xerox, Paolo?
16:41:20 <xerox> hello shapr, yes it's me \o/
16:41:27 <shapr> Hiya! Long time no see!
16:41:34 <povman> What the heck, these both compile:  mkNegative [100, -20]     and    mkNegative [(100, -20)]
16:41:36 <xerox> indeed. how's things?
16:41:53 <shapr> xerox, Living in the south of USA, about to start working on my CS degree. What about you?
16:42:05 <koeien37> povman: what's mkNegative?
16:42:13 <shapr> @index mkNegative
16:42:13 <lambdabot> bzzt
16:42:15 <shapr> hmm
16:42:15 <xerox> shapr that's nice. I cut my hair and I'm about to get my degree!
16:42:22 <xerox> (The two being unrelated)
16:42:26 <shapr> Wow, what degree? Which uni?
16:43:04 <xerox> this is when I complain because my uni doesn't have a very good website. mathematics, in www.unito.it
16:43:43 <shapr> xerox, undergrad or graduate?
16:43:50 <povman> koeien37: mkNegative :: [Vector] -> TerrainSegment,   where type Vector = (Distance, Distance) and type Distance = Double
16:44:18 <koeien37> then mkNegative [100, -20] shouldn't compile.
16:44:27 <Saizan> povman: have you made a Num instance for Vector?
16:44:29 <xerox> shapr undergrad
16:44:29 <povman> The following gives no errors: wtf1 = mkNegative [100, -20]; wtf2 = mkNegative [(100, -20)]
16:44:40 <koeien37> except if you have a Num instance
16:44:46 <koeien37> then fromInteger kicks in
16:44:48 <swolchok> how do I force floating-point division of two numbers? I tested fromIntegral 1.1 and it didn't seem to work
16:44:56 <povman> Ah... maybe that's it.
16:44:57 <koeien37> since integer literals really are "fromInteger THAT_LITERAL"
16:45:08 <koeien37> swolchok: just just (/)
16:45:11 <koeien37> s/just/use
16:45:19 * Twey stack overflow
16:45:25 <koeien37> > 1 / 2
16:45:26 <lambdabot>   0.5
16:45:32 <swolchok> whoops
16:45:33 <swolchok> thanks.
16:45:48 <Twey> Trace: fromInteger (fromInteger (fromInteger (fromInteger (fromInteger …
16:45:56 <xerox> shapr so you'll start next semptember, or have you already started this academic year?
16:46:13 <koeien37> Twey: fromInteger = id on Integer, so we take the limit ;)
16:46:17 <companion_cube> > 1 `div` 2
16:46:18 <lambdabot>   0
16:46:27 <Twey> Phew, thank goodness for laziness :þ
16:46:31 <shapr> xerox, I'll start in January!
16:47:01 <xerox> shapr oh nice. I wish you the best. Going to lectures is wonderful. At least I very much enjoy it.
16:47:30 <shapr> I haven't been to a lecture in fifteen years, I'm sort of nervous.
16:47:42 <shapr> Well, unless you count haskell user's group lectures...
16:47:52 <shapr> Thinking about edwardk, that probably does count.
16:48:08 <xerox> I wonder how's ed's language coming about.
16:48:34 <shapr> I had lunch with edwardk five days a week for nearly two years, I can probably handle college just fine.
16:48:47 <Twey> Hahaha.
16:48:50 <povman> Saizan: koeien37: Thanks! vector-space has instance Num (a,b).   Pretty weird behaviour though.
16:50:16 <koeien37> why is it weird?
16:50:20 <xerox> povman isn't it just pointwise sum?
16:51:18 <povman> yes, but i wouldn't have expected my  f::[(Double, Double)] -> b to take [Double]
16:51:48 <koeien37> it doesn't
16:51:52 <xerox> that should not happen, must be a more general type
16:52:08 <koeien37> your [100, -20] is just of a type different than you expected
16:52:18 <koeien37> what is the fromInteger for Num (a, b) ?
16:52:42 <povman> koeien37: oh right.
16:52:51 <povman>   fromInteger n   = (fromInteger n, fromInteger n)
16:52:52 <xerox> ah, sneaky. fromInteger.
16:53:26 <koeien37> bleh. I hate this instance
16:53:34 <povman> yeah. conal.
16:53:50 <companion_cube> @pl \x -> (fromInteger x, fromInteger x)
16:53:50 <lambdabot> liftM2 (,) fromInteger fromInteger
16:53:51 <koeien37> fromInteger 0 = (0, 0), ok, but the rest
16:54:14 <koeien37> oh well
16:54:14 <povman> apparently numbers are equivalent to diagonal lines
16:54:19 <xerox> it does have good properties, but it's sneaky.
16:54:39 <companion_cube> in such case, better not to use fromInteger directly :)
16:54:50 <koeien37> what are the good properties then?
16:54:54 <povman> yeah. Interesting about that implicit fromInteger thing.
16:55:39 <sshc> koeien37: I forgot to mention this, but I would like to solve this using the State monad without any helper functions, i.e., get, put, modify, etc.
16:55:54 <sshc> koeien37: pretty much just bind, return, >>
16:56:43 <koeien37> sshc: i'm not sure that's possible
16:56:48 <xerox> koeien37 take any Num(a,b) law, e.g. associativity (a,b)+((b,c)+(d,e))=((a,b)+(c,d))+(d,e), if you replace any tuple with a numeric literal it still works, with that fromIntegral
16:56:53 <koeien37> since State s a = State (s -> (a,s)) underneath
16:56:54 <sshc> koeien37: shouldn't the State record the actual value being incremented as well as the number of increments?
16:56:58 <povman> koeien37: I suppose real literals use fromRational?
16:57:36 <sshc> koeien37: and when it is run, returtn the value?
16:57:49 <koeien37> sshc: depends on what you want tod o
16:57:52 <sshc> koeien37: why wouldn't it be possible to accomplish this without using modify or etc.?
16:57:58 <Saizan> sshc: you'd just have to implement get/put/modify yourself
16:58:00 <koeien37> sshc: you want to have a counter, + the number of increments of that counter?
16:58:11 <koeien37> Saizan: is the State constructor exported?
16:58:15 <Saizan> koeien37: sure
16:58:22 <xerox> povman what is * ?
16:58:24 <koeien37> ah runState is, of course
16:58:24 <sshc> koeien37: yes, I do
16:58:32 <Saizan> ?type State
16:58:33 <koeien37> sshc: ah. Then you need both, yes
16:58:34 <lambdabot> forall s a. (s -> (a, s)) -> State s a
16:58:36 <povman> xerox:   (a,b) * (a',b') = (a*a',b*b')
16:58:40 <sshc> koeien37: both the counter itself and the number of increments
16:58:47 <koeien37> ok.
16:59:03 <koeien37> Then the best way to go is like Saizan suggested; implement get and put
16:59:11 <sshc> if anybody is willing to spend a little bit of time, can I see a working example of this?
16:59:18 <koeien37> get :: State s s. put :: s -> State s ()
16:59:41 <koeien37> sshc: i can write it down, but that won't help you
16:59:53 <sshc> koeien37: please do.  thank you.
16:59:53 <koeien37> first try get
17:00:10 <sshc> koeien37: I don't want to jump ahead that far yet
17:00:22 <sshc> koeien37: I want to first understand how the pure State monad works without helper funcitons
17:00:46 <sshc> koeien37: I'm trying to do this without "do" so I can unerstand how it works
17:01:07 <koeien37> that is a good idea
17:01:32 <koeien37> you know that newtype State s a = State (s -> (a, s)) ?
17:01:50 <dmhouse> In profiles, what do cost centres with names like "==_a19d" mean? I guess that's just the equality operation (==), but why the name mangling?
17:02:05 <sshc> koeien37: yes, but don't you need brackets instead of the outer parentheesis
17:02:06 <koeien37> probably because it's the equality function for some type
17:02:07 <sshc> koeien37: ?
17:02:23 <sshc> koeien37: oh, only if you're using record syntax
17:02:24 <koeien37> sshc: State { runState :: s -> (a, s) }
17:02:29 <sshc> koeien37: and it does
17:02:36 <koeien37> it does, yes
17:02:59 <sshc> koeien37: if you do not mind, can I see a working example of this please?
17:03:34 <koeien37> so if you want to have a function that increments the state, you would have  incrementStateByOne = State (\s -> ((), s + 1))
17:03:47 <koeien37> do you see how it works?
17:03:53 <sshc> koeien37: aha!
17:04:04 <sshc> koeien37: I'm begnning to understand the State monad :)
17:04:11 <companion_cube> koeien37: isn't it   get >>= \x -> put (x+1)  ?
17:04:12 <koeien37> or, getCurrentState = State (\s -> (s, s))
17:04:27 <sshc> koeien37: so pretty much I'm binding, or composing, a bunch of state modifiers?
17:04:38 <koeien37> sshc: correct
17:04:52 <sshc> koeien37: aha! :D
17:04:56 <koeien37> companion_cube: sure
17:05:02 <companion_cube> \o/
17:05:12 <koeien37> companion_cube: there is also a function "modify" which is a shortcut
17:05:22 <companion_cube> modify (+1) ?
17:05:26 <koeien37> yes
17:06:00 <koeien37> sshc: so in your case, you can have incrementCounter = State (\(c, v) -> ( (), (succ c, v) )
17:06:12 <dmhouse> yitz: turns out to be good intuition, most of my program time is spend checking membership
17:06:19 <koeien37> and incrementValue = State (\(c, v) -> ( (), (c, succ v) ) )
17:06:35 <sshc> companion_cube: so when I call incrementStateByOne with >>=, what exactly does >>= pass to second argument of >>=?
17:06:37 <koeien37> now you can see why we prefer "get", "put" and "modify"
17:06:43 <sshc> koeien37: so when I call incrementStateByOne with >>=, what exactly does >>= pass to second argument of >>=?
17:06:47 <yitz> dmhouse: ok, hope it helps.
17:06:57 <koeien37> sshc: the result of the computation. So that's () in this case
17:07:07 <dmhouse> yitz: thanks; I'll refactor and let you know the speedups
17:07:40 <companion_cube> and in do notation,  do { x <- get; put $ x+1; }  is the same as   get >>= \x -> put (x+1)
17:07:41 <koeien37> () is not so interesting, so instead of   m >>= (\_ -> n)  we write m >> n
17:07:42 <sshc> koeien37: so it runs the function, and takes the first element of the tuple, and passes that onto the second function?
17:08:19 <yitz> dmhouse: oh, in your case Data.IntSet, of course
17:08:25 <sshc> koeien37: s/onto( the second funcion)/to\1/
17:08:26 <koeien37> m >>= f is a Stateful computation that gives the starting state to m, runs it, gives the value of the result to f, which is another stateful computation and runs this with the updated state
17:08:46 <koeien37> m :: State s a, f :: a -> State s b
17:09:14 <sshc> koeien37: what do you mean by the starting / initial state?
17:09:14 <koeien37> this means, "m is a stateful computation with state s and result of type a"
17:09:38 <koeien37> sshc: well, the whole computation will depend on a starting state. That's why the computation is of type s -> (a, s)
17:09:59 <koeien37> that's what you will pass to (runState computation)
17:10:04 <companion_cube> sshc: you can look at the RWH section about State Monad, there is a simplified implementation of >>= whihc makes it clearer
17:10:22 <sshc> koeien37: so what would I pass to runIncrementCounter?
17:10:33 <koeien37> nothing
17:10:34 <sshc> koeien37: rather, runIncCounter
17:10:45 <koeien37> what's the type of it?
17:11:09 <sshc> koeien37: :: State (Value, NumberOfIncrements) Value
17:11:25 <sshc> koeien37: then wouldn't it be useless?
17:11:35 <koeien37> it's not useless at all
17:11:36 <sshc> koeien37: how would I do anything with it if I can't pass the inital state?
17:11:52 <koeien37> you can run this computation by doing runState runIncCounter initialState
17:12:42 <sshc> :t runState
17:12:44 <lambdabot> forall s a. State s a -> s -> (a, s)
17:13:01 <koeien37> State (V, N) V has one constructor: State { runState :: (V, N) -> (V, (V,N)) }. So you pass that to runState, and then pass the initial state of type (V, N)
17:13:46 <koeien37> and then you get a tuple: the first entry is the result (of type Value), and the second entry is the end state
17:14:00 <sshc> ok, so runState takes a state computation (which is a bunch of state computations / transformers composed together), and the initial state, and returns the tuple of the result and the end state?
17:14:14 <dmhouse> Hmm, there's no analogue of list comprehensions when working with Sets (or IntSets), is there? I'd have to rewrite it all in terms of maps and filters and so on?
17:14:28 <koeien37> sshc: correct
17:16:05 <sshc> koeien37: and, I don't even need to use bind to create a state transformer, then?
17:16:22 <sshc> koeien37: how does bind compose two state computations, then?
17:16:28 <koeien37> :t (>>=)
17:16:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:16:44 <yitz> dmhouse: no, unfortunately
17:16:45 <sshc> koeien37: does bind just ignore the result of the first state computation and use the result of the second state computation?
17:16:46 <koeien37> it passes the (possibly modified) state along
17:16:59 <koeien37> sshc: no, the result is passed to the second argument of (>>=)
17:17:17 <yitz> dmhouse: Set is not even a monad, because it is limited to instances of Ord.
17:17:22 <DarthHaskell> Hi, any good tutorials on network programming in Haskell?
17:17:26 <dmhouse> yitz: yeah, I remember
17:17:40 <koeien37> m >>= f, first runs m :: State s a, the result, of type a, is passed to f :: a -> State s b to get something of type State s b, which is run after there
17:17:42 * hackagebot upload: GPX 0.3 - Parse GPX files (TonyMorris)
17:17:45 <koeien37> afterwards*
17:17:55 <dolio> It's a monad, but not a Monad.
17:17:56 <koeien37> in the mean time the state is remembered and updated if necessary
17:19:00 <sshc> koeien37: what kind of function would the second argument of bind (>>=) be?
17:19:01 <yitz> @elite monad
17:19:03 <lambdabot> MOnAd
17:19:20 <koeien37> e.g.    getTheState >>= (\theState -> ... something in terms of the state ... )
17:20:13 <koeien37> or: get >>= (\s -> put (s+1))
17:20:38 <koeien37> or:  return 37 >>= (\x -> .. something in terms of x ..)
17:20:51 <koeien37> if you know I/O, you know that this is very useful
17:21:06 <koeien37> getLine >>= (\theLineThatTheUserJustEntered -> if ... then ... else ...)
17:21:10 <Algo> Apparently you can make an array with all the positive integers in Haskell?
17:21:16 <koeien37> a list
17:21:18 <koeien37> > [1..]
17:21:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:22:16 <DarthHaskell> Any networking tutorials online?
17:22:53 <DarthHaskell> googled it, did not find anything indepth
17:23:08 <koeien37> Algo: you can make the list, and you can do things with it. Example:
17:23:15 <koeien37> > takeWhile (<11) [1..]
17:23:36 <zygoloid> Set's not a Monad, but newtype Set' a = Set' (a -> Bool) can be :)
17:24:11 <koeien37> @botsmack
17:24:12 <lunabot>  :o
17:24:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:24:13 <lambdabot> :)
17:24:13 <ben0x539> gghc: pahnci:c !p a(ntihc! (thee  ''iimmppoossssiibbllee' hap'pe ned)happ e  (GnHeC dversi)o n   6(.G1H2C. 1v efrosri oxn8 66.12._164-u nfor kxn8o6w_n6-4linu-xu)n: Preludke.renado: now np-alrisneu x)P:l e aPsree lruede.reapd:o rnto  tphairss ea s Pal eGaHsCe  bruegp:o r th ttthpi:s/ /awsw wa. haskGelHl.orC bugg/ghc/repor:  httatbpu:g
17:24:19 <ben0x539> Well, fuck. I broke it.
17:24:21 <Saizan> zygoloid: err, no :)
17:24:28 <zygoloid> Saizan: err, no, right, oops :)
17:24:34 <zygoloid> that's not even a Functor
17:25:04 <Saizan> ben0x539: twice, it seems
17:25:08 <koeien37> Algo: you can ask for the length of it, but that will not terminate. So you have to be a little bit careful. But it's a very cool feature
17:25:13 <Algo> cool
17:25:14 <ben0x539> Right, parallel compilation
17:25:15 <yitz> ben0x539: aren't multiple threads fun?
17:25:24 <Algo> thanks koeien37!
17:25:46 <koeien37> Algo: this is called "lazy evaluation" and it's not only for lists of integers, but it's used throughout the language
17:25:47 <Saizan> turn on line buffering next time :)
17:26:14 <ben0x539> I just said 'make -j' in the gtk2hs tree, optimistically
17:26:25 <koeien37> i've had bad luck with make -j4 in the past
17:26:31 <koeien37> with ghc itself
17:26:57 <mokus> make -j17 fails spectacularly ;)
17:27:18 <mokus> on ghc that is
17:27:19 <ben0x539> Not like gtk2hs was building to begin with, but I was holding out hope
17:27:30 <jdavis> Let's say I'm reading from a static data store on disk. As part of the algorithm, I want to load the data into an in-memory structure as needed, rather than reading the whole thing up front. What's the recommended approach for that kind of thing? It seems like it's a challenge to avoid mixing the pure functions and side effects.
17:27:58 <shapr> getContents?
17:28:01 <shapr> Isn't that lazy?
17:28:05 <koeien37> getContents is lazy
17:28:23 <jdavis> shapr: Ok. Any links that I should read?
17:28:28 <koeien37> i.e. it terminates and reads from input as needed
17:28:32 <shapr> Not that I can think of...
17:28:35 <sshc> koeien37: what is the type of State's bind?
17:28:39 <sshc> :t (>>=)
17:28:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:28:48 <ben0x539> Second only to unsafePerformIO in infamity
17:28:48 <koeien37> it's like this, but m = State s
17:29:04 <koeien37> so State s a -> (a -> State s b) -> State s b
17:29:21 <yitz> jdavis: you may want to look at lazy byte strings for better performance.
17:29:35 <sshc> koeien37: so then the second function of >>= doesn't receive the end state of the frist function of >>=?
17:29:44 <koeien37> it does
17:29:47 <sshc> koeien37: does >>= pass the result or the end state to the second?
17:29:48 <koeien37> it's just of the same type
17:29:57 <jdavis> shapr: I don't think that will work, because I'm not necessarily reading in order.
17:30:42 <koeien37> the result (of type "a") is passed to the second argument. The state is hidden in the State constructor
17:30:48 <jdavis> yitz: I'm not really working with byte strings, but perhaps a record store or reading something from a network.
17:30:48 <sshc> koeien37: perhaps I should be thinking "(s -> (a, s)) -> (a -> s -> (a, s)) -> (s -> (a, s))" ?
17:30:53 <koeien37> but the state is updated and kept track of
17:31:05 <koeien37> sshc: that is only if a = b. But accurate, yes.
17:32:45 <koeien37> it might be enlightening to read the definition of (>>=) in RWH.
17:32:56 <Stinger> Is it possible to do some sort of list structure in the type system?
17:33:03 <koeien37> the State and runState wrapping/unwrapping makes the "official" definition a bit harder to read
17:33:07 <koeien37> Stinger: HList
17:34:36 <Stinger> oh, heh it's the same guy as SYB
17:34:53 <koeien37> oleg?
17:35:18 <Stinger> Lammel was the one I was refering to
17:35:35 <Stinger> I just opened the page and thought 'waaait this looks familiar'
17:35:56 <koeien37> Ralf Laemmel, yeah
17:36:21 <Stinger> same colorscheme :P
17:38:08 <minj> hi
17:38:12 <minj> anybody here?
17:38:12 <bob0> minj: no
17:38:13 <koeien37> hello
17:38:24 <minj> :D
17:38:29 <minj> I need help~~~~
17:38:41 <minj> anybody know c#?
17:38:55 <koeien37> This is a channel about Haskell, not about C#
17:38:56 <Cale> minj: Why ask about C# in #Haskell?
17:38:56 <Stinger> hooray for trolls
17:38:56 <dh_> google knows c#
17:39:07 <minj> sorry ;t;
17:39:22 <koeien37> that was quicker than usual
17:39:29 <Twey> GoGloom, probably
17:40:04 <dh_> good evening everybody.  I have a problem to run lambdabot locally , It says Source not found.     lambdabot -e 'src fmap'
17:40:09 <dh_> any help?
17:40:44 <benmachine> @src fmap
17:40:45 <lambdabot> Source not found. :(
17:40:45 <Twey> @src fmap
17:40:46 <lambdabot> Source not found. I feel much better now.
17:40:47 <Twey> Heh
17:40:49 <benmachine> that'd be your problem
17:41:07 <dh_> @src fmap
17:41:08 <lambdabot> Source not found. My mind is going. I can feel it.
17:41:12 <Cale> fmap is a method (the method) of the Functor typeclass
17:41:13 <Twey> dh_: fmap is a class requirement, not a single function
17:41:21 <dh_> :( .. thanks :)
17:41:25 <benmachine> dh_: have a look at ~/.lambdabot/source
17:41:25 <Cale> It's implemented separately for each type of container it operates on
17:41:29 <benmachine> err
17:41:33 <benmachine> dh_: have a look at ~/.lambdabot/State/source
17:41:39 <xerox> @src Maybe fmap
17:41:40 <lambdabot> fmap _ Nothing       = Nothing
17:41:40 <lambdabot> fmap f (Just a)      = Just (f a)
17:41:56 <Twey> @src IO fmap
17:41:57 <lambdabot> fmap f x = x >>= (return . f)
17:42:05 <Twey> @src [] fmap
17:42:06 <lambdabot> fmap = map
17:42:18 <xerox> that's general enough for any monad, heh :)
17:42:23 <koeien37> for monads, you could have an fmap like for IO
17:42:38 <koeien37> but Functor should be a superclass of Monad, so in general you can't have it like that
17:42:48 <Twey> Yeah, heh
17:42:55 <Twey> Hm
17:42:56 <Twey> Well
17:43:22 <Twey> It's *possible* that the ‘wrapped value’ referred to by the type's Functor and Monad instances be completely separate
17:43:45 <Twey> I guess that would probably be horrible :þ
17:43:49 <benmachine> but you would get glared at in that case
17:44:07 <koeien37> karma will catch up with you :P
17:44:13 <benmachine> is it possible?
17:44:25 <koeien37> I'm not sure that there is a somewhat sane definition
17:44:31 <koeien37> I'm thinking of   X a = X (a,a) now
17:44:43 <benmachine> is it possible to have a law-abiding monad and fmap that doesn't work like that
17:45:26 <dansa> hello
17:45:29 <koeien37> return x = X (undefined, x); >>= likewise on the second entry. and fmap f (X (x, _)) = X (f x, undefined)
17:45:31 <koeien37> hi
17:45:38 <sshc> benmachine: and fmap that doesn't work like what?
17:45:44 <benmachine> I think non-total doesn't count
17:46:00 <benmachine> sshc: a law-abiding monad and functor that has fmap /= liftM
17:46:15 <benmachine> non-total and seq don't count :P
17:46:18 <koeien37> I think [] could be an example
17:47:08 <benmachine> hmm
17:47:29 <benmachine> there's only one possible total fmap for lists, I think
17:49:18 <tomoj> I am a monad noob. I wrote a macro in clojure which takes a string and n keywords and calls a function passing the string and the 1st and 2nd keywords, then calls the function passing the result of that and the 2nd and 3rd keywords, and so on, returning the result of calling the function with the accumulator and the nth and 1st keywords
17:49:25 <tomoj> is this something monads could help with in haskell?
17:50:07 <koeien37> this seems like  a fold
17:50:09 * drdr says Howdy
17:50:36 <drdr> can anyone help me understand the => -> stuff
17:50:53 <koeien37> :t \xs -> zip x (tail xs ++ [head xs])
17:50:54 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
17:50:54 <lambdabot>     In the first argument of `zip', namely `x'
17:50:54 <lambdabot>     In the expression: zip x (tail xs ++ [head xs])
17:50:58 <koeien37> :t \xs -> zip xs (tail xs ++ [head xs])
17:50:59 <lambdabot> forall a. [a] -> [(a, a)]
17:51:04 <mauke> drdr: -> is simple, => is something different
17:51:15 <drdr> heh?
17:51:25 <mauke> Int is a type
17:51:33 <mauke> [Int] is the type of lists of ints
17:51:36 <benmachine> tomoj: sounds foldy
17:51:43 <drdr> ?!?!???
17:51:43 <lambdabot> Unknown command, try @list
17:51:45 <mauke> Int -> Int is the type of functions taking an int and returning an int
17:51:49 <drdr> im still not understanindg
17:51:55 <benmachine> drdr: patience
17:52:05 <koeien37> :t \f initial xs -> foldr f initial (zip xs (tail xs ++ [head xs]))
17:52:06 <lambdabot> forall b a. ((a, a) -> b -> b) -> b -> [a] -> b
17:52:16 <koeien37> ^ something like that, tomoj?
17:52:17 <mauke> well, -> is an infix type constructor
17:52:29 <mauke> and you see it all the time because it's the type of functions
17:52:36 <Stinger> => is to do with typeclass constraint, -> is used for the type of functions afaik
17:52:40 <xerox> > let { f g = map (uncurry g) . ap zip tail } in f (+) [1..3]
17:52:41 <lambdabot>   [3,5]
17:53:28 <xerox> > let { f g = map (uncurry g) . ap zip tail } in f g [x,y,z] :: [Expr]
17:53:29 <lambdabot>   [g x y,g y z]
17:53:30 <drdr> ok
17:54:41 <nainaide> :t init
17:54:43 <lambdabot> forall a. [a] -> [a]
17:55:28 <povman> does anyone know of a ((a,s) -> (b,s)) -> t a -> t b ?
17:55:32 <povman> ie map with state
17:55:40 <xerox> :t mapAccumR
17:55:41 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:55:46 <povman> ((a,s) -> (b,s)) -> s -> t a -> t b
17:55:49 <povman> oh awesome
17:56:44 <nainaide>  ( \x -> x * x ) 2
17:56:59 <nainaide> : ( \x -> x * x ) 2
17:57:01 <povman> @src mapAccumR
17:57:02 <lambdabot> Source not found.
17:57:03 <koeien37> add > to query lambdabot
17:57:08 <koeien37> > join (*) 2
17:57:09 <lambdabot>   4
17:57:15 <mauke> add > to evaluate expressions*
17:57:21 <nainaide> > ( \x -> x * x ) 2
17:57:22 <xerox> povman see Data.List in the ?docs url, then click source. this always works.
17:57:22 <lambdabot>   4
17:57:25 <koeien37> that is more accurate, yes, thank you
18:01:37 <dmhouse> Huh, weird. The memory estimates printed from -sstderr seem way off
18:02:05 <dmhouse> Oh, perhaps not
18:02:32 <dmhouse> It reckons that "4,261,489,720 bytes allocated in the heap", but actually for a 12-second running time that's not unreasonable.
18:02:41 <koeien37> right, that's just a total
18:02:53 <koeien37> doesn't subtract the garbage collected things
18:04:01 <koeien37> dmhouse: is it a coincidence that i'm reading a reddit post by a certain "dmhouse" at this very moment?
18:04:08 <dmhouse> That's still quite surprising. That's what, 300MB per second? That's over half the memory I have on this laptop. Guess the objects are just really short lived...
18:04:12 <dmhouse> koeien37: heh, that's me. Which one?
18:04:24 <koeien37> something about the markdown fork and atwood :)
18:04:36 <dmhouse> Ah yes.
18:06:01 <xerox> dmhouse there was a comment by dons saying "impressive, eh?" to similar figures on reddit
18:06:41 <dmhouse> xerox: I guess so. It's some pretty speed GC
18:06:43 <sshc> why is Hoogle broken?
18:06:44 <monochrom> At least it's faster than most C programs. :)
18:21:22 <medfly> @type join
18:21:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:31:55 <dmhouse> Okay, a bit more performance advice needed: the following line seems to be taking up 55% of the execution time in my program:
18:32:19 <dmhouse> filter (\v' -> label v' `S.notMember` nhood v) (delete v g)
18:32:49 <dmhouse> g is a [Vertex], v is a Vertex, data Vertex = V { label :: Int, nhood :: IntSet }
18:33:20 <c_wraith> well, that code seems a bit redundant at best.  calling delete and filter?
18:34:16 <dmhouse> I could rewrite it as filter (\v' -> label v' `S.notMember` nhood v && label v' != label v) g, that doesn't seem tons more efficient
18:34:46 <c_wraith> how big is the list of vertices?
18:34:49 <dmhouse> 60
18:35:39 <c_wraith> I'd guess either nhood or label is inefficient
18:35:43 <dmhouse> Of that 50%, 20% is spent in the membership test, 17% in the deletion and 6% in doing some == operation somewhere (it's just listed as "==_a1bV" as a subexpression of that above expression
18:35:52 <c_wraith> oh, nevermind, they're just fields
18:35:56 <dmhouse> c_wraith: they're both just record fields
18:38:26 <twanvl_> dmhouse: you could try
18:38:41 <twanvl_> filter (\v' -> label v' `S.notMember` S.insert v (nhood v)) g
18:39:01 <twanvl_> and pull that new set out of the lambda
18:40:36 <Heffalump> what you actually want is some kind of intersection operation
18:41:00 <twanvl_> then you would need to store the vertices in a Map instead of a list
18:41:04 <Heffalump> right
18:42:06 <twanvl_> And unfortunately, IntMap.difference takes an IntMap as argument for the keys to remove, not an IntSet as you might hope
18:42:33 <Heffalump> presumably you can turn an IntSet into an IntMap in at worst linear time
18:42:58 <dmhouse> Are map deletions constant time?
18:43:13 <bd_> dmhouse: O(lg n)
18:43:51 <Stinger> hmmm single type constructor types
18:44:17 <Stinger> is ghc smart enough to optimize them away? or does undefined get in the way
18:44:47 <mauke> undefined gets in the way unless you use newtype
18:45:09 <mauke> I also seem to remember something called -funbox-strict-fields
18:45:14 <dmhouse> Hmm, apparently IntMap's deletion is O(some weird truncated linear function)
18:45:36 <Heffalump> why do you care about deletion here? It only happens once.
18:46:37 <dmhouse> Yeah, good question
18:46:47 * dmhouse refactors to use an IntMap
18:46:49 <Heffalump> your problem here is that for each element of your list, you are doing an O(log n) operation
18:47:17 <dmhouse> That's true; not sure I see a way around that though
18:47:24 <Heffalump> whereas if the list uses a sorted representation and you use some operation that has access to the IntMap internals, you can walk the two in lockstep and only take O(n) time
18:47:36 <Heffalump> the O(log n) is because each time you have to restart a search
18:47:55 <dmhouse> Hmm, that's true
18:48:30 <dmhouse> So Data.IntMap could do with containing a deleteSortedIndices :: IntSet -> IntMap -> IntMap which is O(n)
18:48:52 <Heffalump> Well, it has IntMap.difference, as twanvl_ said
18:48:53 <dmhouse> Or is it [Int] -> IntMap -> IntMap
18:49:27 <dmhouse> Oh, and that is linear. On the same page now.
18:49:27 <Heffalump> it really should export an IntSet -> IntMap () operation
18:49:36 <Heffalump> but it doesn't, so you'll have to do that by hand
18:49:57 <Heffalump> probably using fromDistinctAscList
18:50:03 <dmhouse> Presumably IntMap.fromList and IntSet.toList are both linear
18:50:18 <dmhouse> Or whatever it's called on the IntMap side, yeah
18:50:37 <Heffalump> dmhouse: you probably need to use the variants where you assert orderedness of the input list
18:50:54 <Heffalump> otherwise it'd have to be O(n log n) - if it wasn't you'd get sorting for less
18:51:59 <Heffalump> hmm. Annoyingly, it looks like building the IntMap from the IntSet might well turn out to be O(n log n) itself.
18:52:33 <Heffalump> even with fromAscList - at least according to the docs.
18:53:11 <Heffalump> cos min(n, W) is effectively W for large n, but that's 32 or 64 which is actually quite bad (and worse than log n is ever likely to be)
18:53:35 <dmhouse> What about just using Data.Map instead of IntMap?
18:53:56 <dmhouse> That has a linear fromAscList
18:54:43 <Heffalump> probably much worse constant factors
18:54:46 <Heffalump> but yeah, give it a go
18:54:59 <dmhouse> Hmm, probably the same comments apply to IntSet vs Set
18:55:10 <Heffalump> I think you need to experiment with various options here, it's not really completely obvious which should be best.
18:55:18 <dmhouse> I shall
18:55:34 <Heffalump> actually, the best thing would be to write IntSet -> IntMap ()
18:55:34 <dmhouse> Thanks for the help, anyway
18:55:43 <Heffalump> grab the source of containers and add it to that
18:55:47 <Heffalump> it should be a trivial operation
18:55:57 <Heffalump> (if you have the internal representations, that is)
18:56:30 <dmhouse> I could do that
18:57:06 <dmhouse> I suppose I should also write an O(n) deleteKeys :: IntSet -> IntMap a -> IntMap a as well using that
18:57:18 <dmhouse> Then that might make a useful addition to the library
18:57:32 <Heffalump> oh, also, the latest source of containers promises O(n) for fromAscList
18:57:35 <Heffalump> and fromDistinctAscList
18:57:53 <dmhouse> Okay, that's good
18:58:06 <Heffalump> not sure if the code has changed or just the docs
18:58:18 <Heffalump> and I guess you'll need GHC 6.12 for that (containers 0.3.0.0)
18:58:29 * Heffalump is off
19:04:10 <HaskellLove> i am working on euler 33: The fraction ^(49)/_(98) is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that ^(49)/_(98) = ^(4)/_(8), which is correct, is obtained by cancelling the 9s. I musunderstood the problem once and i dont quite get it now. What it asks for?
19:05:28 <medfly> I guess they mean that if you treat it as 4*9 divided by 9*8 then you can still get the correct result
19:06:33 <medfly> does that work/
19:08:49 <sshc> :t (>>=)
19:08:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:10:38 <monochrom> It is a pleasure to work with Haskell. Even imperatively.
19:11:18 <monochrom> Higher-order procedure happiness.
19:11:30 <monochrom> Abstraction is bliss.
19:12:43 <HaskellLove> medfly ok i saw from here http://www.visualbasicscript.com/Project-Euler-Problem-33-m70049.aspx so basically, given n and m, you compare if the second digit of n equals the first of m, and then you check if the first digit of the first divided by the second digit of the second equals n/m
19:12:55 <xerox> arrows! http://stackoverflow.com/questions/1642028/what-is-the-name-of-this-operator
19:13:25 <medfly> it's not what I understood from it, but okay, whatever.
19:14:13 <HaskellLove> medfly yeah me too, i got it wrong twice now i saw from another and not solution will be easy
19:23:58 <EvanCarroll> @src unwords
19:23:59 <lambdabot> unwords [] = ""
19:23:59 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
19:24:46 <medfly> using ws and w s makes things so much clearer
19:24:56 <djahandarie> No, it needs to be made pointless!
19:25:06 <EvanCarroll> ?
19:25:56 <EvanCarroll> let unwords' = concat . intercalculate [" "]
19:26:03 <EvanCarroll> > let unwords' = concat . intercalculate [" "]
19:26:04 <lambdabot>   not an expression: `let unwords' = concat . intercalculate [" "]'
19:26:10 <EvanCarroll> > unwords' = concat . intercalculate [" "]
19:26:11 <lambdabot>   <no location info>: parse error on input `='
19:26:13 <medfly> @let unwords' = concat . intercalculate [" "]
19:26:13 <lambdabot>  <local>:1:20: Not in scope: `intercalculate'
19:28:17 <EvanCarroll> > unwords' = concat . intercalate " "
19:28:18 <lambdabot>   <no location info>: parse error on input `='
19:28:23 <EvanCarroll> @ unwords' = concat . intercalate " "
19:28:36 <medfly> @let unwords' = concat . intercalate " "
19:28:36 <lambdabot>  <local>:1:32:
19:28:37 <lambdabot>      Couldn't match expected type `[a]' against inferred type ...
19:28:37 <EvanCarroll> @ unwords' ["foo","Bar"]
19:28:45 <djahandarie> lol
19:29:08 <EvanCarroll> =(
19:29:12 * EvanCarroll is confused
19:29:21 <medfly> you need to use @let
19:29:41 <mauke> @let unwords' = intercalate " "
19:29:42 <lambdabot>  Defined.
19:29:56 <medfly> > unwords' ["foo","Bar"]
19:29:58 <lambdabot>   "foo Bar"
19:30:02 <sternocera> EvanCarroll: Hi. I know you from #postgresql. fancy seeing you here.
19:30:11 <medfly> :]
19:30:11 <roostaj> @src concat
19:30:12 <lambdabot> concat = foldr (++) []
19:30:17 <EvanCarroll> I am everywhere.
19:30:26 <EvanCarroll> I was in #perl before mauke banned me a year ago. =(
19:30:46 <EvanCarroll> @src intercalate
19:30:46 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
19:30:57 <mauke> EvanCarroll: I think you were banned before that
19:31:02 <mauke> repeatedly
19:31:03 <Cale> > [(x,y) | q <- [1..9], u <- [1..9] \\ [q], v <- [1..9] \\ [q], let x = 10*u + q, let y = (10*q + v), x % y == u % v]
19:31:04 <lambdabot>   [(16,64),(26,65),(19,95),(49,98)]
19:31:08 <medfly> ouch.
19:31:16 <EvanCarroll> mauke: and unbanned, ipso facto
19:31:31 <Cale> > denominator . product $ [u % v | q <- [1..9], u <- [1..9] \\ [q], v <- [1..9] \\ [q], let x = 10*u + q, let y = (10*q + v), x % y == u % v]
19:31:33 <lambdabot>   100
19:31:40 <mauke> and glined from irc.perl.org
19:31:56 <medfly> Cale likes golf
19:31:58 <trie> Do you pretty much have to have FlexibleInstances when using MultiParamTypeClasses?
19:32:00 <EvanCarroll> because of mst... that has little to do with my behavoir though, and everything to do with his personal crush on me.
19:32:06 <Cale> That's not even golfed
19:32:12 <medfly> golf it then!
19:32:24 <medfly> @type (\\)
19:32:25 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:32:38 <aavogt> hmm, that's still shorter than delete
19:33:03 <EvanCarroll> eventually the forces of good will prevail!
19:33:24 <medfly> @index (\\)
19:33:25 <lambdabot> bzzt
19:33:28 <sshc> how does the fclabels module make this valid Haskell?
19:33:28 <sshc>  $(mkLabels [''Person, ''Place])
19:33:29 <medfly> :(
19:33:42 <aavogt> medfly: Data.List
19:33:44 <mauke> sshc: looks like template haskell
19:33:45 <medfly> thanks!
19:33:59 <sshc> mauke: template haskell?
19:34:06 <sshc> mauke: don't I need to add a pragma?
19:34:12 <mauke> yes
19:34:28 <sshc> mauke: which pragma?
19:34:34 <aavogt> -fth
19:34:40 <sshc> mauke: the documentation doesn't tell
19:34:42 <mauke> dunno, check the list
19:35:13 <medfly> @type (%)
19:35:14 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
19:35:16 <sshc> mauke: what list?
19:35:25 <sshc> mauke: do I only need TemplateHaskell?
19:35:27 <sshc> mauke: or do I need more?
19:35:36 <sshc> mauke: {-# LANGUAGE TemplateHaskell -}
19:35:51 <mauke> try it :-)
19:36:12 <mauke> this list: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal-1.8.0.2/Language-Haskell-Extension.html
19:37:00 <sshc> mauke: thanks
19:37:08 <squidsoup> is it weird that ruby has no concept of interfaces or design by contract?
19:37:22 <skorpan> no
19:39:04 <squidsoup> skorpan: I've been designing software like this for quite a while, and it's kind of ingrained
19:40:01 <pshc> \
19:40:03 <skorpan> i somehow have the feeling that interfaces don't belong in duck typed languages
19:40:52 <squidsoup> I guess I just struggle to understand how to decouple design from implementation in a dynamic language
19:41:15 <skorpan> just make the design slightly more abstract :)
19:41:21 <skorpan> forget about UML and such
19:41:34 <skorpan> "this thing works with anything that has a method named 'hello'"
19:41:36 <skorpan> that's fine by me
19:41:44 <squidsoup> I think c# has damaged me :)
19:41:55 <skorpan> c# has damaged me as well, in a negative way :(
19:42:05 <elly> I just saw the word 'UML', so it sounds like it!
19:52:42 <HaskellLove> a = [x | x<-[11..99], y<-[11..99], let num = numerator (x % y ), let den = denominator (x % y ), let n1 =  show num !! 0; n2 =  show num !! 1; d1 =  show den !! 0; d2 =  show den !! 1; n2==d1 && n1/d2 == x/y] Why does this give me error for the final piece  n2==d1 && n1/d2 == x/y ? I tried to bracket it but still same
19:53:21 <ivanm> HaskellLove: what's the error?
19:53:34 <HaskellLove> parse error on input `]'
19:53:50 <HaskellLove> and without the final part i have no errors
19:54:16 <ivanm> @type [x | x<-[11..99], y<-[11..99], let num = numerator (x % y ), let den = denominator (x % y ), let n1 =  show num !! 0; n2 =  show num !! 1; d1 =  show den !! 0; d2 =  show den !! 1; n2==d1 && n1/d2 == x/y]
19:54:16 <lambdabot> parse error on input `]'
19:54:27 <ivanm> @type [x | x<-[11..99], y<-[11..99], let num = numerator (x % y ), let den = denominator (x % y ), let n1 =  show num !! 0; n2 =  show num !! 1; d1 =  show den !! 0; d2 =  show den !! 1; n2 == d1 && n1/d2 == x/y ]
19:54:28 <lambdabot> parse error on input `]'
19:54:41 <ivanm> @type [x | x<-[11..99], y<-[11..99], let num = numerator (x % y ), let den = denominator (x % y ), let n1 =  show num !! 0; n2 =  show num !! 1; d1 =  show den !! 0; d2 =  show den !! 1; n2 == d1 && ((n1/d2) == (x/y)) ]
19:54:42 <lambdabot> parse error on input `]'
19:55:00 <ivanm> @type [x | x<-[11..99], y<-[11..99], let num = numerator (x % y ), let den = denominator (x % y ), let n1 =  show num !! 0; n2 =  show num !! 1; d1 =  show den !! 0; d2 =  show den !! 1; (n2 == d1) && ((n1/d2) == (x/y)) ]
19:55:01 <lambdabot> parse error on input `]'
19:55:07 <ivanm> @type [x | x<-[11..99], y<-[11..99], let num = numerator (x % y ), let den = denominator (x % y ), let n1 =  show num !! 0; n2 =  show num !! 1; d1 =  show den !! 0; d2 =  show den !! 1,  (n2 == d1) && ((n1/d2) == (x/y)) ]
19:55:08 <lambdabot>     No instance for (Integral Char)
19:55:08 <lambdabot>       arising from a use of `%' at <interactive>:1:84-88
19:55:08 <lambdabot>     Possible fix: add an instance declaration for (Integral Char)
19:55:20 <ivanm> HaskellLove: you use , to separate terms in a list comprehension, not ;
19:55:41 <HaskellLove> ivanm but like that you get multiple lets
19:56:09 <ivanm> HaskellLove: do you have a final in for your lets?
19:56:13 <c_wraith> use a do block.  for the sake of your sanity
19:56:20 <ivanm> besides, you shouldn't be using a let within a list comprehension
19:56:23 <ivanm> c_wraith: agreed
19:56:29 <ivanm> if you absolutely _have_ to do it that way
19:56:44 <ivanm> but IMHO, if it isn't trivial, you shouldn't be using a list comprehension or a do block
19:57:13 <ivanm> I only use do blocks for the list monad when I'm doing "logic style" coding, or to simplify combination-style code
19:57:52 <aavogt> @type [x | x<-[11..99], y<-[11..99], let num = numerator (x % y ); den = denominator (x % y ); n1 =  show num !! 0; n2 =  show num !! 1; d1 =  show den !! 0; d2 =  show den !! 1; n2 == d1 && n1/d2 == x/y ]
19:57:53 <lambdabot> parse error on input `]'
19:57:54 <HaskellLove> well how will you have a value in a comprehension without let?
19:58:05 <HaskellLove> ivanm
19:58:22 <HaskellLove> you gota say: let x = bla bla
19:58:36 <ivanm> why do you "have to" ?
19:58:41 <ivanm> write a normal function!
19:58:48 <Cale> ivanm: What's wrong with do notation?
19:59:04 <Cale> do-notation looks a lot nicer than a bunch of chained >>= or concatMaps
19:59:08 <ivanm> Cale: nothing really; I just prefer writing "normal" functions
19:59:11 <aavogt> @type [x | x<-[11..99], y<-[11..99], let num = numerator (x % y ); den = denominator (x % y ); n1 =  show num !! 0; n2 =  show num !! 1; d1 =  show den !! 0; d2 =  show den !! 1, n2 == d1 && n1/d2 == x/y ]
19:59:11 <lambdabot>     No instance for (Integral Char)
19:59:12 <lambdabot>       arising from a use of `%' at <interactive>:1:52-56
19:59:12 <lambdabot>     Possible fix: add an instance declaration for (Integral Char)
19:59:14 <HaskellLove> ivanm dude you confuse me, you use let in a list expressoion... period...
19:59:22 <ivanm> because I typically write code in a "conveyer belt" style
19:59:28 <ivanm> HaskellLove: why?
19:59:34 <ivanm> you don't have to if you don't need to
20:00:00 <ivanm> > [ a+b | a <- [1..5], b <- [a .. 10]]
20:00:00 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,4,5,6,7,8,9,10,11,12,6,7,8,9,10,11,12,13,8,9,10,11,1...
20:00:07 <aavogt> what is a conveyor belt?
20:00:09 <ivanm> not a let in sight!
20:00:17 <ivanm> aavogt: couldn't think of a better term...
20:00:24 <ivanm> but I use a lot of function composition, etc.
20:00:57 <HaskellLove> so your point is get the functions out of the comprehension, just use them inside the comprehension ok i got it
20:01:04 <monochrom> "pipeline" in unix shell-scripting
20:01:12 <mauke> dataflow programming
20:01:13 <ivanm> monochrom: that's the term I was wanting!
20:01:19 <ivanm> no, my point is not to use a comprehension at all if it doesn't simplify it
20:01:33 <ivanm> list comprehensions are good in cases where otherwise you'd have to do a lot of map, filter, etc.
20:01:35 <aavogt> list comprehensions are in a way nicer than do, since you can write    (p x::Bool)   instead of  (guard $ p x :: [a])
20:01:48 <ivanm> but don't think list comprehensions are the be all and end all of coding
20:02:00 <ivanm> aavogt: true
20:02:18 <ivanm> but as soon as you get multiline, IMHO any advantages of a list comprehension get thrown out of the door
20:02:40 <HaskellLove> it seems you dont grasp the power of comprehensions
20:02:57 <monochrom> it seems you dont grasp the power of comprehension-free
20:03:01 <c_wraith> they're actually strictly weaker than a do block.
20:03:08 <c_wraith> since a comprehension has an implicit return
20:03:13 <c_wraith> that a do block doesn't require
20:03:14 <ivanm> no, it seems you have become obsessed with comprehensions
20:03:33 <HaskellLove> ivanm yeah i see all problems with comprehensions, i guess i am obsesed
20:03:37 * monochrom loves duality
20:03:39 <mauke> c_wraith: how is that a problem?
20:03:46 <ivanm> HaskellLove: look, it's great that you're enjoying Haskell, but your attitude recently of thinking that you are the bees knees of haskell programmers and that you know best is getting rather irritating
20:03:53 <aavogt> c_wraith: can't you get around that by, say:   [ result | ..... , result <- actual computation ]
20:03:55 <ivanm> i.e. you are becoming a right royal PITA
20:04:08 <ivanm> monochrom: heh
20:04:14 <ivanm> pointfree ftw!
20:04:18 <c_wraith> mauke: it's not really.  But it is a bit of extra flexibility in the do block.
20:04:19 <HaskellLove> ivanm well seems you don't get a joke when someone says it is sexiest code ever... relax
20:04:19 <monochrom> it seems I don't grasp the power of points!
20:04:45 * ivanm hates the usage of "sexy", etc. as generic adjectives
20:04:48 <HaskellLove> monochrom yeah i gota get myself free of that, i really cant see now the power of comprehension free :(
20:05:00 <aavogt> though variables used in only one place are sort of annoying
20:05:18 <mauke> c_wraith: do { x } == do { tmp <- x; return tmp }
20:05:56 <aavogt> also list comprehensions without the <- are interesting sometimes
20:05:59 <c_wraith> mauke:  I understand that.  But one of those is more verbose to contain no additional information
20:06:23 <monochrom> #haskell is the sexiest channel ever! XD
20:06:23 <aavogt> it seems you don't grasp the power of verbosity
20:06:25 <lunabot>  luna: Not in scope: `haskell'
20:06:50 <c_wraith> aavogt: I progammed a lot of java! ;)
20:07:10 <ivanm> @slap monochrom
20:07:10 <monochrom> Oh shoot, # triggers lunabot, doesn't it?
20:07:10 <lambdabot> I'd rather not; monochrom looks rather dangerous.
20:07:19 <monochrom> I'm sorry. :)
20:07:24 <ivanm> so you should be!
20:07:25 <mtnviewmark> need some help: I've got a, say Builder m, and I want one of the members to have a signature like   foo :: (Builder n) => m -> n
20:07:28 <mtnviewmark> see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15206#a15206
20:07:31 <mtnviewmark> how do I do this?
20:07:35 <roboshibby> ivanm: i agree. "sexy" is the new lame
20:07:38 <ivanm> sounds vaguely Java-ish
20:07:41 <ivanm> roboshibby: heh
20:07:46 <mtnviewmark> er "got a class, say..."
20:07:50 <ivanm> mtnviewmark: heh
20:08:06 <ivanm> mtnviewmark: multiparam typeclasses
20:08:13 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs is the sexiest list-monad application ever! and the sexiest haddock-to-code ratio!
20:08:20 <mtnviewmark> I've got to make it Builder m n?
20:08:33 <ivanm> yeah, I think so
20:08:46 <ivanm> mtnviewmark: for a Builder m, is there exactly one type of n that it can become with foo ?
20:08:54 <monochrom> Or http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html if you just want the html version.
20:08:54 <mtnviewmark> or a type class just like   class BuilderFoo m n where foo :: (Builder m, Builder n) => m -> n
20:08:58 <ivanm> or should it be able to become _any_ n (that is an instance of Builder)?
20:09:06 <mtnviewmark> ivanm  - yes!
20:09:19 <ivanm> mtnviewmark: to which one? ;-)
20:09:30 <roboshibby> the new 90210 is on and they are using the term "sext"
20:09:34 <roboshibby> how, fucking, stupid
20:09:40 <medfly> sext?
20:09:47 <roboshibby> it really sucks that the internet and general tech got so popular
20:09:49 <ivanm> @wn sext
20:09:51 <lambdabot> *** "sext" wn "WordNet (r) 2.0"
20:09:52 <lambdabot> sext
20:09:52 <lambdabot>      n : the fourth of the seven canonical hours; about noon
20:09:52 <roboshibby> 'sex text'
20:09:55 <mtnviewmark> not any Builder n --- that is, a given instance of Builder determined exactly what the typeof n should be
20:10:01 <ivanm> roboshibby: as in "sexting"?
20:10:01 <medfly> oh
20:10:03 <roboshibby> a text with a nude pic of someone
20:10:05 <roboshibby> yea
20:10:07 <roboshibby> all of those stupid terms
20:10:22 <monochrom> instance (Monad m) => Monad (SexT m) where ...
20:10:36 <roboshibby> the internet has got so lame over the past 15 years
20:10:44 <ivanm> mtnviewmark: so if I have say Bar as an instance of Builder, will foo :: Bar -> ... go to one specific Builder instance (say Baz) or can it become _any_ Builder instance?
20:10:54 <mtnviewmark> one specific
20:10:58 <medfly> I think #haskell is pretty cool
20:10:59 <medfly> wait, sexy
20:11:14 <ivanm> monochrom: "There is no need to worry about q and q' being the same; it does not happen." <-- heh
20:11:28 <roboshibby> haskell is probably too technical to be inundated by the masses. php didnt fare as well
20:11:35 <medfly> PHP??
20:11:37 <ivanm> monochrom: but I really hat the semicolon approach to monads
20:11:45 <roboshibby> yea, tons of douches doing php for 5+ years
20:11:47 <medfly> roboshibby: why do you want to appease the masses?
20:11:53 <roboshibby> nope
20:12:02 <ivanm> mtnviewmark: right, you probably need an MPTC, maybe as a separate class
20:12:07 <ivanm> roboshibby: damn straight
20:12:08 <monochrom> ivanm: Why do you hate it? What do you like instead?
20:12:23 <emile_m> Why associated data type in type family can't contain monotypes?
20:12:29 <ivanm> monochrom: just normal do foo \n bar \n, rather than using braces
20:12:32 <medfly> oh, I misread that
20:12:59 <emile_m> ... like class Foo a where; data D Int a
20:13:08 <ivanm> "Stranger in a Strange Land" has a good take on people having elite knowledge/abilities: it's a pity that most people are too stupid to learn them, but in the end they'll die out / become a lower class
20:13:09 <monochrom> I added { ; } to help indenters.
20:13:20 <ivanm> monochrom: ahhh
20:13:28 <monochrom> I haven't added { ; } for a while actually.
20:13:44 <monochrom> Yes, that's why ; appears at the beginning. :)
20:13:59 <ivanm> monochrom: so your login is trebla? is this before or after you decided to shun colours? ;-)
20:14:07 <monochrom> before
20:14:20 <roboshibby> ivanm, understood, and i agree. though it still sucks when science and math are turned into the next pop culture trend
20:14:26 <roboshibby> and we're seeing that now
20:14:31 <ivanm> heh
20:14:59 <roboshibby> so everyone though most people dont understand the thing they're using to 'floss', they're still wearing it out
20:15:06 <roboshibby> er, even though*
20:15:23 <mtnviewmark> actually - I don't believe any of the prevailing memes about Haskell being too technical for the masses at all --- I'm pretty sure I could teach any programmer to program in Haskell in about the same time i could teach them to do so in Python
20:15:32 <medfly> I think that it's better that maths and sciences are popular vs. unpopular.
20:15:47 <medfly> mtnviewmark: you haven't seen some PHP "programmers"
20:15:48 <medfly> :)
20:16:11 <ivanm> mtnviewmark: it's the unlearning that's the difficult bit
20:16:20 <medfly> though, I started with Haskell, and it wasn
20:16:22 <medfly> though, I started with Haskell, and it wasn't so bad
20:16:38 <mtnviewmark> actually I have --- and frankly -- those that have been only taught to do PHP in a web shop basically have as much trouble learning reasonable Python as they would Haskell
20:16:42 <roboshibby> medfly, you're entitled to your opinion but i disagree. whatever becomes popular gets fucked up
20:16:43 <djahandarie> It would have been nice to start with Haskell. :[
20:16:59 <mtnviewmark> the problem with Haskell is that most of the literature you find on the net is very very mis-targeted
20:16:59 <roboshibby> popular = money = attracts greedy, shitty people
20:17:05 <mtnviewmark> there are some nice exceptions
20:17:09 <mtnviewmark> Real World Haskell comes to mind
20:17:18 <medfly> yes, but it's also money that people who are smart can use, rather than a complete lack of money and a feeling that what you're doing is useless
20:17:35 <medfly> s/smart/your idea of good/
20:17:35 <mtnviewmark> and frankly, 25 years ago, I heard all the same things said about "Basic programmers" as I hear now about PHP
20:17:41 <roboshibby> you validify what you do with money?
20:17:57 <medfly> I care about money.
20:18:07 <medfly> it's the reason I can eat and have shelter.
20:18:08 <roboshibby> well, then fundamentally you and i couldn't communicate
20:18:21 <medfly> okay...
20:18:36 <mtnviewmark> I actually heard a dean of a prominent university quip that if an incoming freshman already knew Basic, it was hopeless for them to major in C.S..... the damage was already done!
20:18:38 * medfly doesn't get some people here.
20:18:45 <roboshibby> go ahead and keep chasing valueless money though, you have quite an evil treadmill to run on
20:18:45 <medfly> hahaha
20:19:00 <medfly> mtnviewmark: I actually know someone that started with basic and is not so bad now.
20:19:05 <roboshibby> pieces of paper that can buy a person's soul
20:19:14 <mtnviewmark> hey- I'll admit: I started with COBOL!
20:19:19 <mtnviewmark> (yeah, I'm old)
20:19:23 <aavogt> sounds like it does have a value then
20:19:24 <medfly> roboshibby: that I care about money doesn't mean it's my reason for liking CS or my number one goal in life, just that I recognise that it's important.
20:19:57 <marsh_> personally, I like to eat occasionally
20:20:05 <medfly> oh yeah, me too.
20:20:28 <stu2010> I think there will always be people attracted to any discipline for love of money and I agree the are not always the nicest to work with, but I suspect not many are using irc :)
20:20:34 <marsh_> The only way I found to do that without money was to work in a restaurant
20:20:45 <mtnviewmark> (Of course, at the time, I had access to information about COBOL, Basic, APL, Fortran and LISP -- but only had access to a machine that ran COBOL)
20:20:46 <marsh_> and then they gave me money at the end of the week
20:20:53 <medfly> oh no!
20:21:00 <medfly> you were contaminated with money germs!
20:21:03 <roboshibby> all i know is money isn't what makes what i'm doing feel useful
20:21:15 <roboshibby> and without money, what im doing doesn't necessarily feel useless
20:21:19 <nus> there's no single basic. and, yes, basic BASIC is pretty much daunting, but you haven't seen FOCAL then [-:
20:21:22 <roboshibby> medfly im curious, are you fit?
20:21:22 <medfly> I know money can motivate me to stop being lazy and procrastinating. so it can't be too bad.
20:21:50 <marsh_> imminent lack of money can motivate me, but $$ opportunity never has
20:21:56 <medfly> depends on your definition of fit. I am somewhat fit.
20:22:23 <medfly> I know that when I work on my own it's hard to get myself to do things, and it's not so hard if it's part of a job, but not so much due to the money.
20:22:25 <roboshibby> heh, so even fit is subjective huh.
20:22:32 <medfly> yeah...
20:22:44 <jonh> mmm money
20:22:46 <medfly> moment, I'll give a more objective measure
20:23:16 <marsh_> remember, money is convertible to GPUs
20:23:16 <roboshibby> well all i know is money has never made anyone ive known happy. it was other things.
20:23:38 <jonh> tons of hot neekid women?
20:23:46 <roboshibby> nope, not that either
20:23:51 <medfly> I'm less fit than before.
20:23:52 <marsh_> The people I know with money are generally happier than those without...but correlation is not causation
20:23:54 <roboshibby> that's why "sexy" being everywhere is lame
20:23:54 <jonh> marsh_, spoken like a true geek
20:24:05 <jonh> well the gpu comment :)
20:24:14 <marsh_> Oh, does it show?!
20:24:19 * medfly did 30ish push ups.
20:24:26 <drhodes> money is tangible form of expectation, which is just about the most demotivatingest thing around.
20:24:29 <nus> marsh_, yeah, doesn't imply you know the most happiest people ;-P)
20:24:54 <monochrom> Do you earn money by talking about money in #haskell?
20:24:57 <jonh> i'm pretty motivated to make money, especially when i use it to feed my kids
20:24:59 <marsh_> perhaps the happiest people really are buddhist monks, but they have to work to hard.
20:25:14 <marsh_> me too
20:25:29 <medfly> I have a hard time thinking I don't need money. I've been raised by all those people who have gotten to experience the lack of it at some point in life, and they said it wasn't very nice.
20:26:02 <marsh_> When I was little, they taught us "money isn't important, do your own thing"
20:26:07 <medfly> roboshibby: why is whether I'm fit relevant?
20:26:58 <roboshibby> just a side thought
20:27:14 <kmc> the benefit of having money is that you don't need to worry about it
20:27:25 <jonh> yes
20:27:26 <kmc> having more money than that is of questionable value
20:27:32 <medfly> yeah.
20:27:51 <jonh> like...hey the bills are paid..time to write more haskell :D
20:27:56 <kmc> yup
20:28:31 <marsh_> hey I really should mail those checks today...or I could think about FP all day instead
20:29:32 <Adamant> medfly: total absence of money is bad, but once you've taken care of certain shit with it, the returns for more of it are not that great
20:29:39 <medfly> that's true.
20:30:11 <medfly> or, "I agree", since it's subjective.
20:30:16 <roboshibby> medfly: yes, but it's also money that people who are smart can use, rather than a complete lack of money and a feeling that what you're doing is useless <-- all im saying is that i don't feel what i do is useless if money isn't there with it. i think that attitude is really pathetic, even.
20:30:30 <marsh_> it's nice to live in a low-crime neighborhood where people are respectful to one another
20:30:33 <roboshibby> you're free to be whoever you are, i just totally disagree
20:31:14 <nus> `ok, everybody, go read Abraham Maslow's theory.
20:31:14 <monochrom> Since there is no haskell, I'm going to just watch a movie.
20:31:20 <roboshibby> i see this attitude being taught to friends who are in business school; that the definition of success is profit
20:31:27 <medfly> hmm, well, if I was doing something I don't like, then I would only care about the money.
20:31:39 <HaskellLove> Possible fix: add an instance declaration for (Fractional Int) I dont get it why i get that error in (x / y) < 1 when x and y are Int, and in the interpreter you can do 6/3<1
20:31:44 <marsh_> they chose to go to busines school for a reason
20:31:54 <medfly> like, "oh, I'm installing some random program on a server, but it's not so pointless because I get paid"
20:32:04 <roboshibby> marsh, money is not the only reason to be in business. see this is how perverted the world has become
20:32:06 <roboshibby> it's disgusting
20:32:40 <pikhq> roboshibby: "Become", no. Granted, in recent years it has become more *pronounced*, but greed has always been with us.
20:32:42 <mauke> HaskellLove: because 6 and 3 are still not Ints
20:33:11 <roboshibby> pikhq, of course, but not to this degree. to the degree that the definition of things as colloquially understood is perverted
20:33:13 <medfly> @type floor
20:33:14 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:33:19 <marsh_> if you are a publicly-traded company, it is your legal obligation to act that way
20:33:32 <roboshibby> yea, and why a lot of companies suck
20:33:36 <medfly> > (floor (6 / 3)) < 1
20:33:37 <Adamant> marsh_: yes, that is the basic problem
20:33:38 <lambdabot>   False
20:33:44 <lpsmith> :t 3
20:33:45 <lambdabot> forall t. (Num t) => t
20:33:53 <roboshibby> profit being priority #1 is a flawed long-term business strategy
20:33:58 <lpsmith> :t 3.0
20:33:59 <lambdabot> forall t. (Fractional t) => t
20:34:00 <roboshibby> because it's counter to the true purpose of business
20:34:14 <medfly> I don't know.
20:34:18 <medfly> #haskell-blah ?
20:34:19 <lunabot>  luna: parse error on input `?|'
20:34:20 <Adamant> by solving one problem, management takeover of public companies, they unleashed a lot of new ones
20:34:27 <pikhq> roboshibby: 'Tis the problem, yes.
20:34:34 <HaskellLove> mauke i dont get that
20:34:39 <marsh_> I once heard of Mikhail Gorbachev paraphrasing Alan Perlis
20:34:48 <roboshibby> at least the world is getting so bad that it'll all soon end
20:35:01 <marsh_> "Capitialism knows the price of everything but the value of nothing"
20:35:03 <lpsmith> HaskellLove:   integer literals have a polymorphic type
20:35:06 <medfly> someone sure is pessimistic. do you really think all businesses care about is profit? maybe some.
20:35:20 <medfly> anyway, #haskell-blah
20:35:22 <roboshibby> i never said all
20:35:23 <marsh_> C.F. "A Lisp programmer knows the value of everything, but the cost of nothing." Alan Perlis
20:35:24 <Adamant> roboshibby: that hasn't panned out so hot for the rest of the millenarian types
20:35:30 <medfly> haha
20:35:33 <lpsmith> @let test = 3 + 4
20:35:34 <lambdabot>  Defined.
20:35:37 <lpsmith> :t test
20:35:37 <lambdabot> forall t. (Num t) => t
20:35:41 <roboshibby> adamant, watch =)
20:35:55 <Adamant> roboshibby: I've missed it like 4 times already
20:36:10 <roboshibby> i dont pick some arbitrary date like i know, i watch the state of people and affairs
20:36:13 <lpsmith> ack,  lambdabot doesn't have quite the same behavior as GHCi
20:36:18 <roboshibby> and like i said, watch and see
20:36:30 <medfly> I think @let saves it in a file.
20:36:40 <medfly> @let test = oh, it's an error.
20:36:40 <lambdabot>   Parse error: Comma
20:36:44 <medfly> err...
20:36:54 <medfly> @let test = o
20:36:54 <lambdabot>  <local>:3:0:
20:36:55 <lambdabot>      Multiple declarations of `L.test'
20:36:55 <lambdabot>      Declared at: <local...
20:36:58 <medfly> right, there :)
20:37:08 <lpsmith> @undefine
20:37:13 <Adamant> roboshibby: the usual trick is to demand large sums of money now in exchange for, say, a bottle of booze, since you can consume the booze right now and the money will be worthless shortly
20:37:16 <lpsmith> @let test = o
20:37:16 <lambdabot>  Defined.
20:37:19 <HaskellLove> medfly but why does (x / y) < 1 give me error i stil dont get it
20:37:20 <lpsmith> :t test
20:37:21 <lambdabot> Expr
20:37:33 <mauke> HaskellLove: because integers don't support /
20:37:38 <roboshibby> adamant, that's why the love of money is sad as i see it
20:37:47 <medfly> HaskellLove: making a fractional into an into an int means potentially losing data...
20:37:50 <pikhq> medfly: Question: are you in the US?
20:37:54 <lpsmith> @hoogle Integer -> Double
20:37:55 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
20:37:55 <medfly> pikhq: no
20:37:55 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
20:37:55 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
20:38:03 <Adamant> roboshibby: but not as sad as the guys who didn't make the Rapture and now ain't got a pot to piss in
20:38:07 <marsh_> Enough of this money talk, "An X is someone who Y everything and Z nothing" is a dynamite metasyntactic template!
20:38:07 <HaskellLove> mauke in interpreter it works
20:38:12 <pikhq> medfly: That'd be why you think that businesses don't only care about profit.
20:38:14 <medfly> guys, #haskell-blah ?
20:38:29 <roboshibby> adamant, um k
20:38:31 <medfly> they care for long-term profit too ;)
20:38:34 <lpsmith> HaskellLove,  it works in ghc too
20:38:37 <lpsmith> the compiler
20:38:48 <HaskellLove> well why do i get errors
20:38:53 <Adamant> roboshibby: quick PM to avoid annoying #haskell more?
20:38:55 <HaskellLove> a = [[x,y] | x<-[11..99], y<-[11..99], noZeroes x, noZeroes y, differentDigits x, differentDigits y, (x / y) < 1, (second x == first y) && ((first x) / (second y) == (x / y))]
20:38:57 <roboshibby> sure
20:39:15 <lpsmith> because integer literals are overloaded,  but the results of operations usually are not
20:39:18 <mauke> HaskellLove: no, it doesn't
20:39:32 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15207#a15207
20:39:33 <mauke> HaskellLove: integers don't support /, interpreter or not
20:39:45 <HaskellLove> mauke well try and do it 6/4 works
20:39:48 <lpsmith> 3 is not an integer
20:39:55 <lpsmith> it's a number of any type
20:39:56 <mauke> HaskellLove: because 6 and 3 are still not Ints
20:39:58 <lpsmith> it's a double too
20:40:17 <ivanm> thanks to the magic of fromInteger! \o/
20:40:19 <ivanm> @type 3
20:40:20 <lambdabot> forall t. (Num t) => t
20:40:25 <ivanm> @type fromInteger
20:40:26 <lpsmith> @hoogle Integer -> Double
20:40:26 <lambdabot> forall a. (Num a) => Integer -> a
20:40:26 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
20:40:26 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
20:40:26 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
20:41:00 <HaskellLove> so in my code it would be like? i dont get it so confused
20:41:18 <mauke> HaskellLove: well, stop being confused then
20:41:28 <marsh_> @toInteger 6 / toInteger 3
20:41:29 <lambdabot> Unknown command, try @list
20:41:29 <medfly> > (6 / 3) < 1 :: Fractional
20:41:30 <lambdabot>   Class `GHC.Real.Fractional' used as a type
20:41:31 <medfly> or something.
20:41:37 <marsh_> > toInteger 6 / toInteger 3
20:41:39 <medfly> > (6 / 3) < 1 :: Double
20:41:39 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
20:41:39 <ivanm> HaskellLove: why don't you try working through more tutorials rather than just diving straight in to coding?
20:41:39 <lambdabot>    aris...
20:41:40 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
20:41:40 <lambdabot>         against inferred ty...
20:42:17 <medfly> there
20:42:24 <medfly> > (6 / 3) < (1 :: Double)
20:42:25 <lambdabot>   False
20:42:30 <marsh_> so what is the recommended idiom for the conventional integer division?
20:42:44 <medfly> > 9 `div` 5
20:42:45 <lambdabot>   1
20:42:52 <mauke> :t div
20:42:53 <lambdabot> forall a. (Integral a) => a -> a -> a
20:42:57 <marsh_> thx
20:44:17 <marsh_> Is it remotely practical to write a garbage collector in Haskell?
20:44:34 <pikhq> Remotely? Yes. :P
20:44:39 <ivanm> you probably can, but why would you?
20:44:46 <ivanm> since there's already one built in
20:44:58 <marsh_> I just wrote one in C++ and was snickering to myself "let's see the java fans do this!"
20:45:00 <ivanm> (IIRC, this is the main reason why so much of the RTS is still written in C rather than Haskell)
20:46:48 <marsh_> is anybody using 64-bit haskell with tasks needing >4GB working memory?
20:48:16 <ivanm> AFAIK, in most cases if you need that much memory (for any app in any language) then you're almost certainly doing it wrong
20:48:31 <kmc> ivanm, physical memory, sure
20:48:31 <ivanm> large scale numeric computations would probably be the only exception (or maybe a really large compilation job)
20:48:40 <kmc> but there are good applications for mapping many gigabytes of virtual memory
20:49:04 <HaskellLove> first x / second y == x / y , so what is the problem here? first and second are functions Int->Int
20:49:15 <ivanm> kmc: hmmm? I thought he meant it _needed_ more than 4 GB of RAM
20:49:22 <ivanm> @type (/)
20:49:23 <lambdabot> forall a. (Fractional a) => a -> a -> a
20:49:25 <ivanm> @instances Fractional
20:49:26 <lambdabot> Double, Float
20:49:33 <ivanm> HaskellLove: ^^ Int isn't an instance of (/)
20:49:38 <kmc> ivanm, it's ambiguous... does working memory mean physical or virtual?
20:49:41 <ivanm> HaskellLove: how about you go read through some tutorials? ;-)
20:50:03 <ivanm> kmc: does it matter? what are you doing that you need that much RAM in the first place?
20:50:05 <marsh_> yes, actively using several GB of committed ram in one process space
20:50:19 <marsh_> :-)
20:53:11 <ivanm> marsh_: anyway, even my number crunching apps are typically CPU-bound rather than memory bound
20:53:41 <marsh_> better than being swap-bound
20:54:13 <ivanm> right; I take care to make sure my code _is_ CPU bound in that respect ;-)
20:54:21 <marsh_> anyway I was just wondering if anybody knew what the GC would do with that sort of working set
20:54:31 <HaskellLove> ivanm so what is the function to conver intToReal?
20:54:46 <HaskellLove> to float
20:54:52 <ivanm> HaskellLove: read through some tutorials; they'll tell you
20:55:12 <ivanm> seriously: some proper tutorials would be better than you continually pestering us here
20:56:02 <HaskellLove> well i read tutorials and solved 30 eulers, type programming i am new to that so... you learn through doing it and i do eulers so just tell me
20:56:08 <marsh_> How about (0.0 +) ?
20:56:15 <marsh_> > (0.0 +) 3
20:56:17 <lambdabot>   3.0
20:56:40 <ivanm> HaskellLove: which tutorials?
20:57:04 <ivanm> IIRC, the wikibook at least covers this
20:57:13 <marsh_> nite all
20:57:57 <ivanm> cya marsh_
20:58:25 <ivanm> but still, books > online IMHO
21:02:24 <HaskellLove> (((first x)::Double) / ((second y)::Double) == ((x / y)::Double)) ivanm i still get errors man
21:03:05 <ivanm> @type first
21:03:06 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
21:03:08 <ivanm> @type second
21:03:09 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
21:03:13 <ivanm> do they look like what you want?
21:03:30 <HaskellLove> ivanm first is my function, second too.. they are Int->Int
21:03:45 <HaskellLove> first n = digitToInt $ show n !! 0         second n = digitToInt $ show n !! 1
21:03:46 <Cale> HaskellLove: Then how the heck is (first x) a Double?
21:03:55 <ivanm> Cale: he wants automagic conversion
21:03:57 <ivanm> @hoogle Int -> Double
21:03:57 <lambdabot> Prelude toEnum :: Enum a => Int -> a
21:03:57 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
21:03:57 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
21:04:02 <HaskellLove> Cale well ivanm told me to convert it
21:04:04 <Cale> fromIntegral
21:04:27 <Cale> fromIntegral will convert from an integer-like type to any numeric type
21:04:33 <ivanm> Cale: he doesn't get the hint that he should try reading up on how to use Haskell rather than pestering us for everything
21:04:40 <cads> hey when we talk about type theory, do we ever talk about one super-general type theory that we've found through universal properties, or are we always talking about a  type theory as interpreted in some logical framework?
21:05:04 <HaskellLove> ivanm dude first you confuse me and then you say go read tutorials...
21:05:07 <kmc> cads, there is a 1:1 correspondence between type theories and logical frameworks
21:05:13 <kmc> called the Curry-Howard Isomorphism
21:05:20 <kmc> e.g. System F corresponds to first-order logic
21:05:22 <kmc> (i think)
21:05:44 <ivanm> how did I confuse you, pray tell?
21:05:48 <kmc> STLC would be propositional logic i guess
21:06:13 <cads> ah, every type is a proof in a framework, I recall?
21:06:14 <ivanm> I just said that Int isn't an instance of Fractional
21:06:28 <ivanm> most tutorials cover the numeric classes AFAIK
21:06:42 <ivanm> (I could be wrong, since I haven't read through any tutorials recently, but I'd _expect_ them to)
21:07:07 <kmc> cads, types are propositions
21:07:12 <kmc> terms are proofs (of their types)
21:07:31 <kmc> cads, if you want to dive into this stuff, i've been working this recently: http://www.cis.upenn.edu/~bcpierce/sf/
21:07:37 <kmc> it's a really good introduction
21:08:12 <kmc> cads, a proof of (A -> B) is a function that, given a proof of A, returns a proof of B
21:08:17 <kmc> hence (->) means "implies"
21:08:54 <kmc> (A, B) is "A and B", because a value of type (A,B) is a value of type (i.e. proof of) A, together with a value of type (i.e. proof of) B
21:09:09 <kmc> cads, can you figure out what the haskell type corresponding to "A or B" is?
21:10:10 <HaskellLove> ivanm yeah thanks man you wasted me a hole hour taking me in wrong directions, Cale saved the day in a second, thanks Cale
21:10:34 <ivanm> *shrug* more work up front saves you work down the track
21:10:47 * ivanm can't remember the exact wording of the pithy proverb about this
21:11:26 <HaskellLove> ivan yeah you are so smart, cool for you
21:11:34 <cads> heh, I can't figure that out, some kind of type where values are in the union of both A and B?
21:11:56 <kmc> cads, yeah.  a proof of "A or B" is either a proof of A or a proof of B, together with a tag telling you which one
21:12:08 <ivanm> HaskellLove: why thank you, for that old fashioned compliment
21:12:53 <cads> kmc, how would we express that in haskell's notation?
21:12:59 <kmc> cads, (Either A B)
21:13:13 <cads> d'oh
21:13:25 <ToxicFrog> @type Either
21:13:26 <medfly> HaskellLove: hey, what language are you very comfortable with?
21:13:27 <lambdabot> Not in scope: data constructor `Either'
21:13:30 <kmc> "not A" is an interesting one too
21:13:37 <kmc> you need to define a type Void which has no values
21:13:49 <kmc> e.g. "data Void -- no constructors"
21:14:00 <kmc> (a GHC extension)
21:14:05 <kmc> or "data Void = Void Void" -- a bit of a hack
21:14:12 <kmc> then you say "type Not a = a -> Void"
21:14:16 <HaskellLove> medfly why? I have worked in several languages
21:14:18 <cads> what are these type parameterized functins, Either, Not, (_,_)?
21:14:24 <mauke> kmc: ITYM newtype
21:14:24 <kmc> Either is not a function
21:14:32 <mauke> the data version actually contains values
21:14:42 <Jafet> @src Either
21:14:42 <lambdabot> Source not found. You untyped fool!
21:14:52 <kmc> mauke, true, but so does the newtype.  you can't do logic unless you exclude bottom values
21:14:52 <Jafet> Well said.
21:14:54 <medfly> HaskellLove: I think it would be easier for you to try to read code in a language you're familiar with, and make it into Haskell
21:14:55 <kmc> undefined :: Void
21:15:06 <kmc> even with newtype
21:15:14 <mauke> ok, the data version contains a non-bottom value
21:15:21 <ivanm> medfly: hell no; there's enough abominations around of people trying to literally translate Foo into Haskell
21:15:22 <roboshibby> is haskell an OO language?
21:15:27 <Jafet> kmc, how do you denote unprovability then?
21:15:28 <HaskellLove> medfly well it is not about language, i work with paradigms models in my head more then language specific
21:15:33 <kmc> roboshibby, no.  but you can do OO programming in most languages
21:15:35 <Jafet> roboshibby, yes, for some definition of OO
21:15:38 <mauke> roboshibby: no
21:15:42 <kmc> roboshibby, there is no particular built in support for it
21:15:42 <cads> kmc, by function I meant something that receive types as paramaters and constructs a type of a certain sort as a result
21:15:53 <ivanm> roboshibby: see OOHaskell
21:15:59 <roboshibby> oohaskell? hehe
21:16:03 <kmc> cads, ah.  we'll call those "type constructors" typically.  Haskell does not have first-class type functions
21:16:15 <kmc> in GHC we do have type functions of a sort, with type synonym families
21:16:17 <kmc> but they're not first-class
21:16:22 <kmc> because that would involve dependent types
21:16:28 <cads> rigt
21:16:39 <kmc> to see how deep this rabbit hole goes you'll need to use e.g. Agda or Coq
21:16:53 <Jafet> (Or C++!)
21:17:05 <ivanm> roboshibby: I'm serious: http://homepages.cwi.nl/~ralf/OOHaskell/
21:17:22 <roboshibby> what i always have wondered about synonyms is, how can you denote when you're trying to work with the synonym itself vs work with what the synonym points to?
21:17:23 <kmc> Jafet, you can't *really* make an uninhabited type in Haskell.  Haskell's logic is unsound.
21:17:31 <kmc> roboshibby, they are completely interchangeable
21:17:40 <kmc> that's why we discourage synonyms for complicated cases
21:17:47 <ivanm> actually, it appears that Timber is the latest OO-based Haskell implementation: http://en.wikipedia.org/wiki/Timber_%28programming_language%29
21:17:52 <kmc> if you say "type Age = Int; type Weight = Int" the compiler will still let you add an age to a weight
21:17:58 <kmc> you should rather use newtype
21:17:58 <medfly> HaskellLove: at least for a bit
21:18:11 <kmc> as in "newtype Age = Age Int deriving (Eq, Ord, Num, Integral)"
21:18:27 <cads> kmc yeah, I have informal experience with a bit of haskell type classes through some tutorials and stuff, and I have quite a few advanced papers on type theory (wobbly types, phantom types, GADTs, all those groovy papers by the haskell crowd)... but I want to get in at the bottom and understand some theory... I'll be playing with agda soon
21:18:55 <kmc> in which case the wrapping and unwrapping of the "Age" constructor directs the types
21:19:00 <roboshibby> hrm
21:19:22 <cads> kmc, I'll check out your link
21:19:30 <roboshibby> if you check out mine?
21:19:34 <kmc> haha
21:19:36 <roboshibby> ...huhuh
21:19:54 <kmc> i'll show you my Coq if you show me yours
21:20:06 <kmc> sorry i've been making these jokes all day
21:20:10 <kmc> i wonder if it ever gets old
21:20:22 <mauke> preflex: remember <kmc> i'll show you my Coq if you show me yours
21:20:22 * roboshibby makes a new programming language called wood
21:20:45 <cads> kmc, ah, to be french
21:20:55 <kmc> and also a robot
21:21:17 <roboshibby> well the french are good at taking commands :P
21:21:34 <cads> "we will name it like 'cock' just so we can make zoze faggots in america insecure' "
21:21:53 * kmc in uni had to write a compiler to OCaml VM, and consequently had to find a lab partner who could read technical documentation in French
21:22:15 <HaskellLove> what does this mean in euler 33: If the product of these four fractions is given in its lowest common terms, find the value of the denominator.
21:22:34 <kmc> @quote coq
21:22:34 <lambdabot> monochrom says: Ask Coq. Don't rely on head.
21:22:56 <mauke> multiply four fractions, reduce.
21:23:31 <cads> HaskellLove, suppose p, q, r, s are rationals, then  p*q*r*s = A/B for certain integers A, B... find the smallest possible B
21:23:58 <cads> *where B > 0
21:24:15 <BMeph> kmc: All I hear from you guys is Coq, Coq, Coq! Coq is a pain in the ass! Wait a minute...
21:24:30 <cads> kmc, what about nuPRL
21:24:36 <mauke> preflex: be kmc
21:24:36 <preflex>  Coq is a useful tool but sometimes it gets pretty hard
21:24:37 <roboshibby> nurpl
21:24:42 <kmc> i haven't used it
21:24:46 <cads> nurple?
21:24:46 <kmc> i've used MetaPRL
21:24:48 <cads> really?
21:25:18 <cads> prPL-nuRPL, heh
21:25:30 * kmc is waiting for a Coq analysis tool called CoqBlock
21:25:39 <cads> I wish formalized proofs weren't so goddamn ugly
21:25:57 <kmc> i have to find a research group where Coq is used regularly and ask them if the jokes ever get old
21:25:59 <kmc> my money is on 'no'
21:26:21 <HaskellLove> cads I got the four, [[16,64],[19,95],[26,65],[49,98]] how to get A/B now
21:26:32 <roboshibby> well it's a stupid name, they have to expect it
21:26:36 <roboshibby> wtf does coq even mean
21:26:38 <kmc> indeed, it's in the faq
21:26:43 <kmc> roboshibby, "rooster", in French
21:26:49 <roboshibby> "c our queer language" ?
21:26:51 <mauke> it means cock
21:26:53 <kmc> "caml" means, er, camel
21:27:01 <roboshibby> oh
21:27:37 <kmc> it's also named in honor of Thierry Coquand, who co-invented the logical system it uses
21:27:48 <kmc> and as a corruption of "CoC" for "calculus of construction"
21:27:50 <roboshibby> cock wand?
21:27:52 <roboshibby> WTF
21:27:54 <lpsmith> camel,  categorical abstract machine language...
21:27:58 <kmc> roboshibby, ... france
21:28:04 <roboshibby> yeh.. figures
21:28:38 <cads> HaskellLove, reduce all four into lists of prime factors for the numerator and denominator, then eliminate common factors and you're done
21:29:02 <cads> that's like less than 100 operations
21:29:08 <kmc> @quote pousse
21:29:08 <lambdabot> wrake says: "Huet also called his theorem prover Cock^H^Hq. He likes that kind of joke, apparently." atonivs "I suppose the next program we can expect from him will be called Pousse."
21:29:49 <cads> you know it never gets old
21:30:20 <medfly_> #haskell degraded into a channel that says, "haha, it sounds like 'cock'".
21:30:21 <lunabot>  luna: Not in scope: `haskell'
21:30:30 <medfly_> :p
21:30:47 <Jafet> Degraded?
21:30:55 <roboshibby> THat's what she said!!?$%^*(
21:31:01 <cads> I dunno, when I see a math paper about a mechanically proven theorem, I roll my eyes and know that if I read it I will sit through someone's painfully arbitrary implementation of real analysis or something
21:31:02 <medfly_> haha
21:31:22 <kmc> cads, fair enough.  but the point of proving things to a machine isn't to then show the proof to humans
21:31:59 <cads> right, in many domains it's integral, where we want to be able to prove certain properties auotmatically as part of a protocol, say
21:32:41 <kmc> the machine proof is valuable as long as the humans have faith in the underlying system, and in the faithfulness of the formal statement of the problem
21:32:49 <cads> these are usually properties a mathematician wouldn't consider mathematically particularly interesting, but then again mathematicians are snobs
21:32:50 <Jafet> You don't need a full calculus of constructions for protocols
21:33:29 <kmc> a lot of really interesting maths in the 20th century came out of people writing things formally and then realizing that their informal notions were actually broken
21:33:35 <roboshibby> cads, i dont think mathematicians are snobs as much as they are happy to find the only group they fit into :P
21:33:40 <kmc> and they did it without computers
21:33:45 <kmc> just by being crazy motherfuckers
21:33:54 <roboshibby> and smoking a lot of ganja :D
21:34:01 <pikhq> kmc: The same is true of most non-recent math.
21:34:09 <HaskellLove> crazy ninjas
21:34:11 <cads> Jafet, perhaps not, but that's also a small part of what a mechanical proof system might be called to do, I suppose..
21:34:11 <kmc> i don't thin ganja is strong enough for high-level maths
21:34:18 <pikhq> I shudder to think of even trivial stuff like trig tables being done without computers.
21:34:18 <cads> it's not.
21:34:26 <kmc> i knew people who would smoke a bowl of Salvia divinorum at the start of a topology exam
21:34:33 <roboshibby> salvia sucks
21:34:35 <kmc> in an attempt to visualize n-dimensional manifolds
21:34:37 <roboshibby> it /suuuucks/
21:34:39 <skorpan> guys, #drugs
21:34:40 <kmc> hahahaha
21:34:44 <kmc> is there #drugs really
21:34:49 <skorpan> probably
21:34:50 <roboshibby> skorpan would know
21:34:52 <roboshibby> fuckin stoner
21:34:58 <cads> pikhq, that's fun when you're deriving the relations for the first time ever
21:35:07 <skorpan> 06:34 -ChanServ- [#Drugs] PWNED FUCKERS!
21:35:15 <cads> hah
21:35:23 <kmc> the real danger is that you yourself become the n-dimensional manifold
21:36:12 <medfly_> lol
21:36:35 <cads> math still goes on at a super abstract level which so far has almost completely escaped formalization - you don't see people writing programs to prove results in K-theory, I don't believe - the concepts there are so abstract we don't know how to express them to a computer yet.
21:36:47 <HaskellLove>  resultList [[16,64],[19,95],[26,65],[49,98]] I get [[[2,2,2,2],[2,2,2,2,2,2]],[[19],[5,19]],[[2,13],[5,13]],[[7,7],[2,7,7]]] What now cads am i going in right direction
21:36:50 <cads> or perhaps we don't have the patience to do so, or the techniques to facilitate it
21:37:37 <HaskellLove> just concat and remove duplicates?
21:38:33 <cads> alright, now in each of those pairs of numerator/denominator list pairs, you can remove all pairs of equal factors in the numberator and denominator
21:39:48 <HaskellLove> [2,2,2,2],[2,2,2,2,2,2] that is for 16 and 64... they are all 2 what do :)
21:40:35 <cads> that turns into [],[2,2] - the lower number of twos in the left cancels 4 twos on the right, leveing two of them
21:41:03 <medfly> > [2,2,2,2] \\ [2,2,2,2,2,2]
21:41:04 <lambdabot>   []
21:41:11 <medfly> > [2,2,2,2,2,2] \\ [2,2,2,2]
21:41:12 <lambdabot>   [2,2]
21:41:13 <mauke> :t gcd
21:41:14 <lambdabot> forall a. (Integral a) => a -> a -> a
21:41:18 <medfly> yaaay woo
21:41:35 <cads> god i'm getting worse at talking about regulat math as I get better at categories and algebra and such :D
21:41:58 <mauke> assimilation in progress
21:42:26 <cads> > [2,2,2,2,3,3,3] \\ [2,2,2,2,2,2,3,3]
21:42:27 <lambdabot>   [3]
21:42:40 <cads> bool-shit :D
21:43:09 <kmc> cads, you're leveling up
21:44:24 <elspru> > fib 1 3
21:44:25 <lambdabot>   Not in scope: `fib'
21:44:33 <elspru> > fibonacci 1 3
21:44:34 <lambdabot>   Not in scope: `fibonacci'
21:44:44 <elspru> :(
21:45:53 <cads> heh, the type .... would be   [([Int], [Int])] -> ([int],[int]), that's almost certainly expressible as a fold :D
21:46:01 <mauke> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1
21:46:02 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
21:46:16 <cads> yeah, being a level 4 FP wizard lets me assert these kinds of things.
21:46:35 <cads> but I've got shit for spells still :P
21:46:39 <Dashkal> Failing in my browsing here...  Is there an immutable hash map -- O(1) lookups -- in the library that doesn't use IO?
21:47:08 <kmc> Dashkal, i've looked and didn.t find one. a hash trie would be nice
21:47:34 <Dashkal> *nods* Alright.  I just didn't want to write my own unless I had to.
21:47:47 <elspru> let fib x y = y: fib y (x+y) in fib 1 3
21:47:49 <mauke> why does it have to be a hash?
21:47:51 <BMeph> cads: Not so much a fold as a reduce. ;)
21:47:54 <elspru> > let fib x y = y: fib y (x+y) in fib 1 3
21:47:54 <kmc> people tend to use Data.Map and Data.IntMap
21:47:54 <lambdabot>   [3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127,24...
21:48:01 <Dashkal> It doesn't have to be hash, just O(1) lookups.
21:48:03 <elspru> yay :D
21:48:06 <kmc> and i think the difference between O(1) and O(log n) is overblown for most real world uses
21:48:11 <kmc> as always the profiler will tell the story
21:48:12 <mauke> Dashkal: why O(1)?
21:48:18 <Dashkal> Data.Map claims O(n)
21:48:25 <mauke> no, it doesn't
21:48:28 <kmc> for lookup? no way
21:48:31 <kmc> it's log n
21:48:34 <kmc> should use a balanced binary tree
21:48:49 <Dashkal> So it does, I missed that
21:48:53 <mauke> I can make you a linear O(1) lookup, btw
21:48:56 <kmc> the problem with binary trees isn't so much the asymptotic behavior as the cache effects
21:48:59 <mauke> it'll take 2^32 steps, though
21:49:01 <kmc> a many-ary tree would be nice too
21:49:06 <cads> BMeph, I'll reduce four joints!
21:49:06 <Dashkal> hmm, maybe I'm selling it short.  I thought it was O(n), not O(log n)
21:49:46 <Dashkal> I just didn't want O(n).  The structure I'm envisioning will be the single most accessed thing in the program.
21:50:11 <cads> kmc, I am in the middle of a paper explaining AVL trees, which have always been wonderful and mysterious to me :)
21:50:19 <BMeph> cads: (++)/          -- quasi-Squiggol
21:50:39 <cads> Squiggol!
21:51:00 <jfischoff> anyone use leksah?
21:51:12 <cads> is the squiggol camp still alive and well?
21:51:19 <cads> programming with barbed wire and bannanas?
21:51:49 <Dashkal> Ahh! It requires Ord keys.  Ok, now it makes sense (I was confused as to how it managed to avoid O(n) without a hash function)
21:51:49 <kmc> reduce two joints in the morning
21:51:58 <Dashkal> Thanks for setting my misconception straight.
21:52:23 <cads> I couldn't understand that paper when I read it because as I recal it talked about the categorical nature of hylomorphisms which just threw me way off, but i've been meaning to attempt reading the squiggol papers again lately
21:52:35 <jfischoff> its pretty cool
21:52:38 <kmc> Dashkal, yes.  unfortunately the constraint is expressed on the functions, but not on the data type itself
21:53:17 <mauke> :t M.singleton
21:53:18 <lambdabot> forall k a. k -> a -> M.Map k a
21:53:31 <mauke> :t M.singleton id ()
21:53:32 <lambdabot> forall a. M.Map (a -> a) ()
21:54:38 <Dashkal> So it is, though it appears as though you can only get a single unordered item into a map.
21:54:57 <Dashkal> Since insert and fromList are Ord k =>
21:55:42 <ivanm> kmc: why unfortunately? there's no reason to put it into the datatype, and you'd need to specify it in the function anyway
21:56:16 <cads> Hey, you guys ever read that paper where a friendly fellow shows us exactly how to derive the O(n) algorithm for the fibonacci sequence, starting out with the O(2^n) version?
21:56:51 <cads> I think he presents it as a series of equality preserving program transforms
21:57:08 <Gracenotes> how formal?
21:57:39 <cads> not very formal - he uses an equation reasoning style two-column proof
21:57:55 <HaskellLove> do you see something wrong here: (1 - (fromMaybe (elemIndex (maximum x) x)))
21:57:59 <Gracenotes> haven't read :/
21:58:10 <Gracenotes> HaskellLove: fromMaybe takes two arguments
21:58:23 <Gracenotes> at least, if it's an Int you want
21:58:26 <HaskellLove> oh yeah thanks, why do i keep forgeting that, am i senile...
21:58:47 <sshc> koeien: I think learning how to use non-monadic State's (without bind) helped me and would help others trying to understand State monads
21:59:51 <HaskellLove> cads ok now i have this resultList [[16,64],[19,95],[26,65],[49,98]] and i get [[2,2],[],[5],[]]
22:02:23 <elspru> how do i get a certain number of something from a list?
22:02:29 <elspru> without having to use split
22:02:48 <elspru> like to get the first 2 elements of [1,2,3]
22:02:53 <HaskellLove> elspru take 2
22:02:58 <elspru> o
22:03:01 <elspru> :D
22:03:01 <elspru> thanks
22:03:02 <HaskellLove> take 2 [1,2,3]
22:04:48 <elspru> > take 2 ([1,3..])
22:04:49 <lambdabot>   [1,3]
22:04:58 <elspru> > take 6 ([1,3..])
22:04:59 <lambdabot>   [1,3,5,7,9,11]
22:05:14 <elspru> oh that is fibonacii
22:05:22 <elspru> oh wait no
22:05:51 <elspru> > take 6 ([1,8..])
22:05:52 <lambdabot>   [1,8,15,22,29,36]
22:06:03 <elspru> > take 6 ([0,8..])
22:06:04 <lambdabot>   [0,8,16,24,32,40]
22:06:12 <Gracenotes> rather linear
22:06:17 <elspru> ya
22:06:55 <Gracenotes> the .. notation is just syntax for making lists from Enums (things which can be enumerated)
22:08:10 <Gracenotes> @src Enum
22:08:10 <lambdabot> class  Enum a   where
22:08:10 <lambdabot>     succ                     :: a -> a
22:08:10 <lambdabot>     pred                     :: a -> a
22:08:10 <lambdabot>     toEnum                   :: Int -> a
22:08:10 <lambdabot>     fromEnum                 :: a -> Int
22:08:12 <lambdabot> [3 @more lines]
22:08:33 <Gracenotes> @more
22:08:33 <lambdabot>     enumFrom                 :: a -> [a]
22:08:34 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
22:08:34 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
22:09:04 <Gracenotes> the last four correspond to [x..], [x,y..], [x..y], and [x,y..z] respectively
22:13:31 <HaskellLove> anyone has solved euler 33 i am confused at the end
22:18:58 <medfly_> no. people inthis channel don't just spend all day solving euler problem
22:18:58 <medfly_> s
22:27:31 <Zeiris> What's the standard thing to do if I need some 2d vectors? Use an (Int,Int) newtype with an instance of Num that defines + and -?
22:31:43 <HaskellLove> div l = (x % y) where x = l !! 0; y = l !! 1         resultList = map (div) a why is that giving me headakes? a is a list of lists
22:35:32 <HaskellLove> ah shit, because i used the name div ... ok problem solved
22:36:02 <kmc> Zeiris, i prefer "data Vec2 = Vec2 Int Int" over "newtype Vec2 = Vec2 (Int, Int)"
22:36:20 <kmc> the two types should be runtime isomorphic with ghc
22:36:35 <kmc> and the former has less syntactic burden
22:36:43 <kmc> there are some vector libraries on hackage iirc
22:50:16 <icecream> does anyone know how to get ghc to spit out the intermediary C code?
22:51:05 <Stinger> doesnt do that anymore I thought
22:51:10 <Stinger> uses c-- or something
22:51:13 <kmc> you'd need -fvia-C to generate C at all
22:51:17 <Zeiris> Can I use "let ... in ..." inside "instance ... where ..."?
22:51:18 <kmc> and -keep-hc-files
22:51:20 <kmc> to keep them
22:51:26 <kmc> Zeiris, you can use "let" in any expression
22:51:33 <kmc> and "let .. in .." is itself an expression
22:51:46 <Zeiris> Gyah. Possibly incorrect indentation :(
22:52:08 <Stinger> > let x = 1 in let y=2 in let z = 3 in (x,y,z)
22:52:09 <lambdabot>   (1,2,3)
22:52:10 <kmc> Zeiris, if you upload it to a pastebin i'll take a look
23:00:32 <gaal> Is it possible to write a function that unwraps one constructor for all simple types of the form "data T a = T a"?
23:02:56 <c_wraith> gaal: maybe with template haskell, to be typesafe
23:11:11 <gaal> thanks c_wraith
23:14:22 <kmc> gaal, with Scrap your Boilerplate it is probably possible
23:14:43 <kmc> at least, you can write a function to get all values of a specific type from within a deeply nested structure
23:14:56 <shachaf> gaal: Ahoy!
23:35:37 <c_wraith> can a template haskell expression determine what the typechecker thinks its type must be?
23:37:31 <c_wraith> I'm wondering if TH would actually have access to T and a if you just threw it in as $(extract) or whatever
23:37:31 <kmc> an expression splice?
23:37:39 <c_wraith> yes
23:37:52 <kmc> well the expression isn't formed yet
23:38:15 <kmc> perhaps it is theoretically possible to reify the surrounding type inference context
23:38:20 <kmc> but i do not think this has been implemented
23:38:32 <c_wraith> yeah, I feel like there's some big gotcha with my "but it feels easy!" declaration.
23:38:33 <kmc> i would go for $(extract ''T)
23:39:08 <c_wraith> Unfortunately, that example makes it unclear whether T is the type or constructor
23:39:26 <c_wraith> As you could write the function either way.
23:39:47 <kmc> it's clear from use that T is the type, because it's quoted as a type
23:39:55 <c_wraith> oh, is '' quoting only for types?
23:40:03 <kmc> yeah
23:41:32 <c_wraith> Hmm.  if the splice was replace with undefined, the compiler could figure out some sort of type constraint for it, though possibly one that's too broad.  Maybe there isn't a huge gotcha, and it's just an engineering challenge no one thinks is worthwhile
23:44:14 <SamB_XP> c_wraith: well, it could get messy anyways ...
23:44:35 <c_wraith> there are many cases it could need explicit type annotations to resolve it down to a concrete type
23:44:49 <SamB_XP> messy for the user, I mean
23:44:53 <SamB_XP> not the implementor ...
23:53:29 * hackagebot upload: HPath 0.0.0 - Extract Haskell declarations by name. (JasonDusek)
23:55:43 <Guest85382> ARE SOMEONE HERE TO GUIDE Me?
23:56:37 <medfly> THROUGH WHAT
23:56:43 <c_wraith> you accidentally got a lowercase letter in there.
23:56:53 <Guest85382> WEB
23:56:55 <Guest85382> FILE
23:56:56 <medfly> YEAH, TRY NOT TO CLICK SHIFT
23:56:57 <Guest85382> MANAGEMENT
23:57:09 <Guest85382> TANX
23:57:22 <medfly> YOU HAVE THE WRONG CHANNEL, THIS CHANNEL IS FOR NERDS THAT LIKE A PURELY FUNCTIONAL PROGRAMMING LANGUAGE CALLED HASKELL
23:58:40 <mtnviewmark> hello all - I need some help with some class-fu!
23:58:42 <mtnviewmark> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15219#a15219
23:59:19 <kmc> mtnviewmark, okay.  what's the problem?
23:59:20 <mtnviewmark> the instances in that past won't compile because
23:59:39 <kmc> do you need a fundep w -> f ?
23:59:42 <mtnviewmark> for example: Type synonym `Takes1Byte' should have 1 argument, but has been given 0
