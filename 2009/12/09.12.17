00:04:51 <augur> so guys!
00:04:54 <augur> why does this happen
00:05:08 <augur> > [(a,b) | gcd a b == 1]
00:05:10 <lambdabot>   Ambiguous occurrence `a'
00:05:10 <lambdabot>  It could refer to either `L.a', defined at <local...
00:05:15 <augur> ..
00:05:21 <augur> > [(n,d) | gcd n d == 1]
00:05:25 <lambdabot>   mueval-core: Time limit exceeded
00:05:29 <augur> that
00:05:29 <ivanm> augur: where are a and b coming fromg?
00:05:40 <ivanm> do you know how to use list comprehensions?
00:05:48 <augur> god only knows, ivanm. someone else did this in proggit
00:06:03 <ivanm> > [ (n,d) | n <- [1..100], d <- [1..100], gcd n d == 1 ]
00:06:04 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
00:06:07 <augur> and the fact that you get a time limit exceeded error from lambdabot is crazy
00:06:11 <augur> i dont understand it
00:06:14 <ivanm> > [ (n,d) | n <- [2..100], d <- [2..100], gcd n d == 1 ]
00:06:15 <lambdabot>   [(2,3),(2,5),(2,7),(2,9),(2,11),(2,13),(2,15),(2,17),(2,19),(2,21),(2,23),(...
00:06:21 <augur> no no ivanm, i get that
00:06:28 <augur> its not the unbound variables that i dont get
00:06:30 <ivanm> augur: the time limit is because it takes too long to get any results
00:06:40 <augur> but WHY?
00:06:47 <augur> if the variables are unbound isnt that just an error?
00:06:49 <ivanm> to stop people from crashing lambdabot
00:06:58 <ivanm> augur: well, your version doesn't make sense, because n and d don't come from anywhere
00:07:02 <augur> yes
00:07:05 <augur> so why doesnt it give an ERROR?
00:07:18 <ivanm> that's probably an implementation issue
00:07:22 <ivanm> > n
00:07:24 <lambdabot>   n
00:07:28 <augur> i cant even see what it could be iterating over
00:07:34 <augur> to even get in a time loop thing
00:07:37 <ivanm> augur: it appears to be using lambdabot defined n and d values
00:07:38 <ivanm> > d
00:07:39 <lambdabot>   d
00:07:40 <ivanm> > n + d
00:07:41 <lambdabot>   n + d
00:07:47 <ivanm> > 2 * (n + d)
00:07:49 <lambdabot>   2 * (n + d)
00:08:00 <ivanm> augur: so in lambdabot n and d _are_ defined
00:08:08 <luite> :t n
00:08:09 <ivanm> augur: lambdabot has lots of wierd hacks, etc.
00:08:09 <augur> no i think its using that thing where it just spits back symbols when theyre undefined
00:08:09 <lambdabot> Expr
00:08:26 <augur> > blah
00:08:28 <lambdabot>   Not in scope: `blah'
00:08:31 <augur> oh my
00:08:33 <augur> interesting
00:08:34 <augur> > b
00:08:36 <lambdabot>   b
00:08:38 <augur> > c
00:08:39 <lambdabot>   c
00:08:44 <augur> > bc
00:08:46 <lambdabot>   Not in scope: `bc'
00:08:48 <augur> > bs
00:08:49 <ivanm> single letter ones are defined
00:08:49 <lambdabot>   Not in scope: `bs'
00:08:51 <luite> foldr f z [a,b,c,d]
00:08:55 <luite> oops
00:08:56 <ivanm> to do sample expanding calculations, etc.
00:08:57 <luite> > foldr f z [a,b,c,d]
00:08:59 <lambdabot>   Ambiguous occurrence `a'
00:08:59 <lambdabot>  It could refer to either `L.a', defined at <local...
00:09:03 <luite> > foldr f z [a,b,c,d] :: [Expr]
00:09:04 <lambdabot>   Ambiguous occurrence `a'
00:09:05 <lambdabot>  It could refer to either `L.a', defined at <local...
00:09:08 <ivanm> > foldr f z [b,c,d]
00:09:09 <lambdabot>   f b (f c (f d z))
00:09:12 <ivanm> @type a
00:09:14 <lambdabot>     Ambiguous occurrence `a'
00:09:14 <lambdabot>     It could refer to either `L.a', defined at <local>:1:0
00:09:14 <lambdabot>                           or `SimpleReflect.a', imported from SimpleReflect at State/L.hs:75:0-32
00:09:19 <ivanm> bah
00:09:20 <luite> :(
00:09:23 <ivanm> @undefine a
00:09:26 <ivanm> @clear a
00:09:27 <lambdabot> Messages cleared.
00:09:31 <ivanm> bah, not that
00:09:41 * ivanm can _never_ remember how to undefine @let commands
00:09:45 <augur> > f
00:09:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:09:46 <lambdabot>    `SimpleReflect.FromExpr ...
00:09:51 <augur> > f
00:09:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:09:52 <lambdabot>    `SimpleReflect.FromExpr ...
00:09:55 <augur> WHAT
00:09:57 <augur> > g
00:09:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:09:59 <lambdabot>    `SimpleReflect.FromExpr ...
00:10:03 <augur> > n
00:10:05 <lambdabot>   n
00:10:05 <ivanm> augur: they're probably defined as functions
00:10:10 <augur> crazy
00:10:11 <ivanm> as I said, there's lots of dodgy hacks
00:10:11 <augur> > f x
00:10:12 <dolio> @undefine
00:10:12 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:10:13 <lambdabot>    `GHC.Show.Show a'
00:10:13 <lambdabot>      a...
00:10:13 <ivanm> > f n
00:10:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:10:14 <lambdabot>    `GHC.Show.Show a'
00:10:15 <lambdabot>      a...
00:10:20 <augur> :|
00:12:41 <koeien> > 1
00:12:42 <lambdabot>   1
00:12:50 <koeien> > let fix f = f (fix f) in fix (1:)
00:12:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:13:02 <koeien> > f x :: Expr
00:13:04 <lambdabot>   f x
00:13:11 <koeien> ^
00:13:39 <Jafet> > fix succ
00:13:40 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
00:13:46 <ivanm> > fix show
00:13:48 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
00:13:54 <ivanm> > map length . group $ fix show
00:13:58 <lambdabot>   mueval-core: Time limit exceeded
00:14:01 <ivanm> bah
00:14:07 <ivanm> > take 10 . map length . group $ fix show
00:14:09 <lambdabot>   [1,1,1,3,1,7,1,15,1,31]
00:15:17 <ivanm> > let evSnd (a:_:as) = a : evSnd as in take 10 . evSnd . map length . group $ fix show
00:15:18 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
00:15:29 <ivanm> > let evSnd (_:a:as) = a : evSnd as in take 10 . evSnd . map length . group $ fix show
00:15:30 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023]
00:16:25 <ivanm> > let a + b = (succ a) * (pred b) in 2 + 3
00:16:26 <lambdabot>   6
00:16:35 <ivanm> > let a + b = (succ a) * (pred b) in 23 + 634
00:16:37 <lambdabot>   15192
00:16:50 <ivanm> > "mw" ++ cycle "ah"
00:16:51 <lambdabot>   "mwahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
00:17:10 <matt_f> :)
00:17:13 <roostaj> > "no" ++ cycle "o"
00:17:14 <lambdabot>   "nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
00:17:26 <ivanm> roostaj: repeat 'o' would probably be better there
00:17:36 <ivanm> who really hates it when people do that? dmwit?
00:17:38 <roostaj> ivanm: sigh... i'll go back to my corner now
00:17:43 <ivanm> roostaj: heh
00:17:53 <ivanm> > "by" ++ repeat 'e'
00:17:55 <lambdabot>   "byeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee...
00:18:00 <roostaj> :P
00:18:10 <ivanm> @src repeat
00:18:11 <lambdabot> repeat x = xs where xs = x : xs
00:18:12 <ivanm> @src cycle
00:18:12 <lambdabot> cycle [] = undefined
00:18:13 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:18:18 <roostaj> waiting for my euler#9 to finish
00:18:53 <roostaj> woot
00:18:54 <roostaj> done
00:19:20 <jaspervdj> roostaj: project euler?
00:19:22 <vegai> anyone succeeded in building ghc-6.12 on x86_64?
00:19:48 <roostaj> jaspervdj: si
00:20:02 <ivanm> vegai: yup (well, not me, but kolmodin has at least)
00:20:18 <jaspervdj> roostaj: good luck then :-)
00:20:33 * ivanm has built a bootstrapping x86 build, but not actually installed it on his machine yet
00:20:38 <roostaj> jaspervdj: oh thanks :) i just started haskell and euler yesteday
00:20:48 <roostaj> jaspervdj: using euler to get some practice in
00:20:50 <vegai> ivanm: it's breaking for me at building hp2ps
00:20:51 <vegai> In file included from utils/hp2ps/AreaBelow.c:1:
00:20:51 <vegai> utils/hp2ps/Main.h:4:23: error: ghcconfig.h: No such file or directory
00:21:00 <ivanm> vegai: weird :s
00:21:05 <jaspervdj> roostaj: yeah, it's a great way to learn a programming language
00:21:17 <ivanm> vegai: how are you building it?
00:21:41 <dolio> > head [ (a,b,c) | a <- [2..1000], b <- [a .. 1000 - a], let c = 1000 - a - b, a^2 + b^2 == c^2 ]
00:21:43 <lambdabot>   (200,375,425)
00:22:01 <vegai> ivanm: change build.mk to production build, configure && make
00:22:18 <ivanm> vegai: maybe look at we use in the gentoo ebuild to see how we build it
00:22:24 <ivanm> there's been changes in how to build it
00:22:56 <ivanm> vegai: http://code.haskell.org/gentoo/gentoo-haskell/dev-lang/ghc/ghc-6.12.1.ebuild
00:22:58 <vegai> ivanm: aye
00:23:19 <vegai> whoa, you guys do a lot of things :)
00:23:41 <ivanm> yup
00:23:57 <ivanm> for starters, the new way of detecting os and arch doesn't work with how gentoo emits them :s
00:24:07 <vegai> the same build works for i686. Weird.
00:28:44 <ivanm> vegai: hmmm? the same build _procedure_ works
00:35:57 <vegai> ivanm: well of course, mr. pedantic :)
00:36:13 <ivanm> heh
00:37:50 <vegai> hm, ubuntu doesn't package cabal-install
00:38:01 <vegai> but it does package several packages
00:39:22 <ivanm> vegai: you might be able to get debians packages (since they have HP support)
00:39:38 <ivanm> vegai: but dcoutts hasnt' released a 6.12-compatible cabal-install yet
00:39:47 <matt_f> can somebody give me a quick definition of cabal?
00:40:07 <clarkb> package manager
00:40:20 <matt_f> specifically for haskell packages?
00:40:22 <vegai> ivanm: that's fine. I'm trying to support some colleagues who're using ubuntu, and they're in 6.10
00:40:30 <clarkb> er packages and management?
00:40:34 <ivanm> fair enough
00:40:39 <ivanm> clarkb: not quite
00:40:48 <matt_f> eh i'll google it
00:40:55 <ivanm> matt_f: CABAL is the Common Architecture for Building Applications and Libraries
00:40:58 <matt_f> should've done that in the first place
00:40:58 <ivanm> @where cabal
00:40:59 <lambdabot> http://www.haskell.org/cabal
00:41:24 <ivanm> matt_f: it's the library used that takes a relatively simple plain-text description of a project and builds and installs it
00:41:25 <matt_f> great, thank you
00:41:36 <clarkb> vegai: on my ubuntu machine I gave up relying on Ubuntu and built everything from scratch
00:41:46 <ivanm> there's also a tool that can fetch packages from hackage (including dependencies) and build it for you
00:41:49 <ivanm> @where cabal-install
00:41:50 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
00:44:34 <matt_f> very cool, i'm not sure i'll need any additional packages just yet - i'm just learning
00:45:10 <matt_f> spring break = programming fiesta
00:45:14 <matt_f> err winter*
00:45:42 <Gracenotes> isn't it :x
00:45:53 <Gracenotes> I'm looking into x86
00:46:34 <Gracenotes> and.. various stuff. finals have sapped my enthusiasm to do anything other than study and read news, though :|
00:47:37 <vy> Hi! While "./Setup configure"ing parsec-3.0.1 with GHC 6.12.1, it complains that "ghc version >=6.4 is required but it could not be found." Am I missing something obvious?
00:48:04 <matt_f> yeah.. the only final that tripped me up was my multi-variable calc
00:48:42 <vy> BTW, is there any easier way of doing "tar xzf parsec-3.0.1.tar.gz; cd parsec-3.0.1; ghc --make Setup; ./Setup configure; ./Setup build; ./Setup install"?
00:50:01 <vegai> clarkb: yeah, I've had similar experiences in Arch
00:50:17 <vegai> seems like cabal-install does well enough that building something on top of that is just a waste
00:50:28 <clarkb> really? my other machine runs Arch and I will convert the ubuntu box as soon as there is more than one reason to
00:50:46 <vegai> disclaimer: I'm the guy who builds all haskell packages on Arch
00:50:52 <vegai> well, almost all
00:50:59 <DigitalKiwi> vegai: hai :)
00:51:19 <clarkb> heh. I thank you for the hard work then
00:51:25 <vegai> I'd most rather just give out ghc, the basic libs and cabal-install and let the user do the rest
00:51:26 <DigitalKiwi> ghc 6.12 is in testing right? should be moved soon?
00:51:40 <vegai> DigitalKiwi: in testing yes and won't be moved soon
00:51:42 <matt_f> vy: try cabal-install?
00:51:53 <DigitalKiwi> oh :( how come not?
00:52:04 <vegai> the x86_64 build is broken
00:52:12 <ivanm> vy: I can't find anything in the cabal file...
00:52:15 <DigitalKiwi> oh great that's what I'm on :(
00:52:22 <Saizan> vegai: for ghc-6.12 you can use cabal-install but you need the darcs version currently
00:52:22 <ivanm> vy: use cabal?
00:52:31 <ivanm> specifically cabal-install?
00:52:34 <Saizan> err that was for vy
00:52:37 <vegai> I mean the x86_64 build of ghc-6.12.1 is broken
00:52:50 <vegai> a bit of a show-stopper I feel :P
00:53:38 <ivanm> vegai: I don't know how well it'll work, but you could try getting kolmodin's bootstrapping binary (from the ebuild)
00:53:40 <Saizan> vy: are you sure ghc is on your $PATH?
00:54:33 <vegai> this is probably something very simple and stupid, since the problem is just a missing header
00:54:55 <vegai> or not even missing, just something the hp2ps build process is unable to find
00:55:35 <DigitalKiwi> hp2ps?
00:55:57 <Saizan> vy: that error message means that Cabal can't find the ghc executable on your PATH iirc, maybe you just changed $PATH without exporting it from the shell so it's not available in subprocesses?
00:56:02 <ivanm> DigitalKiwi: IIRC, it prettifies profiling output
00:56:20 <Saizan> vy: you can try with --with-ghc=complete/path/to/ghc
00:57:40 <vy> matt_f: I'm trying to install cabal-install and it requires parsec.
00:57:57 <clarkb> this is why I started from scratch on ubuntu :)
00:58:06 <vy> Saizan: Let me give it a try.
00:59:11 <vy> Saizan: I've installed ghc to ~/usr/bin and it's in my PATH but "which ghc" returns nothing while "ghc" works on the command line. Hrm... Interesting.
00:59:24 <vegai> mm, is there a program that puts a file into an X clipboard?
00:59:45 <clarkb> you can cat the file to the program that puts it in the clipboard
00:59:50 <vegai> vegai: yes, xclip-copyfile :)
00:59:51 <clarkb> but I cant remember what that program is called
01:00:06 <Raynes> Teh xclip.
01:00:33 <vegai> hmh, too large a file
01:01:13 <vegai> well, here's a part of it anyway: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14343#a14343
01:01:23 <Saizan> vy: i think you need to "export PATH"
01:01:29 * Raynes tried to open a 1 gig text file in gedit.
01:01:36 * Raynes felt silly afterwards.
01:01:38 <vegai> ghcconfig.h is clearly there in includes/
01:03:46 <vegai> this thing has encountered the same problem at least: http://darcs.haskell.org/buildbot/all/builders/kili%20stable/builds/162/steps/compile/logs/stdio
01:07:57 <vegai> hmm, was it so simple that I hadn't run the boot script
01:08:09 <vegai> if so, I wonder why the same process worked on i686
01:09:27 <vy> Saizan: Sure I did that.
01:12:46 <v_> What kind of expressions does this parser recognize http://haskell.cs.yale.edu/happy/doc/html/sec-using.html ?
01:13:07 <v_> I know these work:
01:13:08 <v_> let a = b in 7
01:13:08 <v_> Let "a" (Exp1 (Term (Factor (Var "b")))) (Exp1 (Term (Factor (Int 7))))
01:13:19 <v_> but b in 7 just looks weird...
01:23:11 <vegai> nah, still broken.
01:32:24 <vy> Isn't it possible to issue "./Setup install" in a local basis? E.g. I want related library to be installed for user only.
01:37:47 <vy> Nevermind.
01:39:20 <Saizan> vy: you can configure with --user, then install will do it locally
02:01:54 <pastah_rhymez> haha... haskelllove is banned?
02:02:02 <pastah_rhymez> that's pretty sweet :)
02:02:09 <pastah_rhymez> what did he do?
02:15:15 <Peaker> cabal install something "base >= 4"  -- used to work, I think, now I get: cabal: Distribution/Client/Dependency/TopDown.hs:172:37-73: Non-exhaustive patterns in lambda
02:16:07 <Lemmih> Peaker: --constraint=base>=4?
02:25:08 <Peaker> Lemmih: thanks
02:25:15 <Peaker> Where is GHC.IO.Exception?
02:31:39 <Jonno_FTW> is there a way to list all the subfolders of a folder in haskell?
02:32:19 <Raynes> Ask nicely.
02:32:32 <Peaker> @hoogle FilePath -> IO [FilePath]
02:32:32 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
02:32:33 <lambdabot> System.Console.Editline.Readline filenameCompletionFunction :: String -> IO [String]
02:32:33 <lambdabot> System.Console.Editline.Readline usernameCompletionFunction :: String -> IO [String]
02:32:43 <Jonno_FTW> hmm
02:33:40 <Jonno_FTW> i guess i have to filter out all the results that have an exception
02:34:27 <Jonno_FTW> *extension
02:34:54 <vy> cabal-install-0.6.2 (latest release) requires Cabal==1.6.* but the Cabal bundled with the latest GHC 6.12.1 is of version 1.8.0.2. Is that mean I cannot setup cabal-install with the latest GHC version?
02:36:37 <Peaker> I can't install "array" because it says it depends on base>=3 && <5  but it actually depends on >=4.2.0.0    and I can't install base 4.2.0.0 (Probably can't install newer base without reinstall ghc?)
02:37:21 <quicksilver> Jonno_FTW: no, don't use extensions.
02:37:29 <quicksilver> Jonno_FTW: files don't have to have an extenion.
02:37:34 <quicksilver> Jonno_FTW: use 'doesDirectoryExist'
02:37:45 <Jonno_FTW> wah?
02:37:58 <Jonno_FTW> then how?
02:38:09 <quicksilver> the way to check if a name refers to a file or directory is to call doesDirectoryExist
02:38:11 <Peaker> @type let getAllPaths d = fmap concat . mapM getAllPaths =<< getDirectoryContents d in getAllPaths
02:38:12 <lambdabot> Not in scope: `getDirectoryContents'
02:38:19 <quicksilver> that will return False if it's a file
02:38:19 <Jonno_FTW> map doesDirectoryExist (getDirectoryContents)?
02:38:23 <Peaker> @type let getAllPaths d = fmap concat . mapM getAllPaths =<< System.Directory.getDirectoryContents d in getAllPaths
02:38:25 <lambdabot> forall a. FilePath -> IO [a]
02:38:33 <quicksilver> something a bit like that, Jonno_FTW
02:38:36 <Jonno_FTW> but i want to to display a list of folders
02:38:42 <quicksilver> but they're not simple functions, they're IO actions.
02:39:10 <Peaker> is there a good place to complain about incorrect dependencies in cabal packages?
02:39:50 <quicksilver> :t getDirectoryContents >=> filterM doesDirectoryExist
02:39:52 <lambdabot> Not in scope: `getDirectoryContents'
02:39:52 <lambdabot> Not in scope: `doesDirectoryExist'
02:40:14 <quicksilver> :t System.Directory.getDirectoryContents >=> filterM System.Directory.doesDirectoryExist
02:40:16 <lambdabot> FilePath -> IO [FilePath]
02:40:22 <quicksilver> that's what you want, Jonno_FTW, I believe.
02:40:29 <Jonno_FTW> thanks
02:40:32 <vy> Umm... Latest version of cabal-install doesn't work with latest version of GHC. Cool!
02:40:33 <Jonno_FTW> i'm practicing IO now
02:40:53 <tobe> monthAndMaxDay is a list with tupels like [(Jan, 31),(Feb, 30),...] and myDay is integer and myMonth a value of an enum. where do i have to set the "snd" so that i can check the day for the corresponding month? myDay >= snd (find ((== myMonth) . fst) monthAndMaxDay)
02:41:58 <Peaker> @pl getAllPaths d = fmap concat . mapM getAllPaths =<< System.Directory.getDirectoryContents d
02:41:58 <lambdabot> getAllPaths = fix ((. System.Directory.getDirectoryContents) . (=<<) . (fmap join .) . mapM)
02:44:32 <phr> http://www.bobhobbs.com/files/kr_lovecraft.html
02:44:39 <phr> Exercise 4-12. Adapt the ideas of Cthulhu() to write a recursive version of the Forbidden Song of Hali; that is, to unravel the fibres of reality and allow the icy liquid darkness of Carcosa to devour your mind.
02:46:48 <Jonno_FTW> also, is it a good idea to use do?
02:50:16 <Twey> Jonno_FTW: When it makes the code significantly clearer, it is
02:50:33 <Twey> Personally, I always switch to do if I find myself using lambdas with binds
02:50:40 <Jonno_FTW> hmm
02:51:36 <Jonno_FTW> here's what i have done so far
02:51:38 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14348#a14348
03:00:59 <ivanm> pastah_rhymez: IIRC, he was being his normal charming self
03:01:01 <ivanm> ;-)
03:03:21 <PepeSilvia> hee, m'n breakpoints werken! :)
03:03:25 <PepeSilvia> oops
03:03:46 <tobe> is there a function to iterate trough tupels and get access to both elements?
03:04:00 <tobe> in a list of tupels
03:04:05 <sohum> so. what graph libraries does #haskell recommend?
03:04:07 <Zao> map (\(f,s) -> ...)
03:04:48 <tobe> Zao: to my question?
03:04:57 <Jonno_FTW> map (\(f,s) -> f++s) [(1,2),(2,3)]
03:05:03 <Jonno_FTW> > map (\(f,s) -> f++s) [(1,2),(2,3)]
03:05:04 <ivanm> sohum: FGL is still probably the best atm
03:05:04 <lambdabot>   Ambiguous type variable `t' in the constraints:
03:05:04 <lambdabot>    `Data.Monoid.Monoid t'
03:05:04 <lambdabot>  ...
03:05:07 <o-_-o> hey guys
03:05:10 <Zao> Jonno_FTW: +?
03:05:12 <ivanm> since the only other one is Data.Graph, which is almost useless
03:05:15 <Jonno_FTW> idk
03:05:17 <Jonno_FTW> i was guessing
03:05:18 <ivanm> tobe: what are you wanting to do?
03:05:29 <sohum> ivanm: oof
03:05:32 <Zao> @type (\x,y -> x + y)
03:05:32 * o-_-o is off on a 2 week vacation from work
03:05:33 <lambdabot> parse error on input `,'
03:05:37 <ivanm> > concatMap (\(f,s) -> [f,s]) [(1,2),(3,4)]
03:05:37 <Zao> @type (\(x,y) -> x + y)
03:05:38 <lambdabot>   [1,2,3,4]
03:05:39 <lambdabot> forall t. (Num t) => (t, t) -> t
03:05:41 <dcsobral> winhugs or ghc?
03:05:49 <ivanm> tobe: ^^
03:05:49 <Zao> @type (\x y -> x + y)
03:05:51 <lambdabot> forall a. (Num a) => a -> a -> a
03:06:11 <tobe> ivanm: i have a list of tupels like [(Jan, 31),(Feb, 28),...] and have to output a calendar for a year
03:06:14 <dcsobral> Any particular reason to choose one over the other, or does it make no difference?
03:06:20 <Zao> > let (x, y) = (42, 3) in x + y
03:06:22 <lambdabot>   45
03:06:23 <ivanm> tobe: OK, what what do you want to do with them?
03:06:26 <Zao> tobe: Similiar concept.
03:06:39 <ivanm> dcsobral: hugs hasn't had any development in years
03:06:47 <ivanm> dcsobral: but hugs is smaller
03:06:57 <ivanm> ghc lets you use extra libraries, and lets you compile apps
03:07:11 <dqd> tobe: Why don't you use the Data.Map structure?
03:07:25 <tobe> ivanm: i jzst have to print a list like [(1, Feb, 2009), (2, Feb, 2009), (3, Feb, 2009), ...]
03:07:36 <ivanm> tobe: print
03:08:06 <pastah_rhymez> ivanm: hehe, he's been PMing with me... he asked me to get him unbanned
03:08:10 <pastah_rhymez> i said no
03:08:14 <ivanm> heh
03:08:18 <ivanm> he's a right royal PITA
03:08:26 <ivanm> he keeps changing his nick when people get sick of him
03:08:32 <ivanm> (and wtf is with his name? :s)
03:08:42 <pastah_rhymez> i've told him to do some other exercises in order to learn haskell
03:08:57 <pastah_rhymez> and i refuse to help him until he's done them
03:09:03 <pastah_rhymez> (other than Project Euler)
03:09:17 <ivanm> I don't get people's obsession with Project Euler
03:09:21 <pastah_rhymez> ivanm: i think he's the same dude that was ScalaLove earlier
03:09:25 <Jonno_FTW> it is that awseom
03:09:25 * ivanm is proud of never having done any of them
03:09:28 <ivanm> pastah_rhymez: and performance, etc.
03:09:40 <ivanm> as in, he once had a nick of "performance"
03:09:42 <Jonno_FTW> before i began Project Euler i was living a lie
03:10:06 <pastah_rhymez> ivanm: well, if you wanna make games you have to think about performance (unless you're making chess)
03:10:17 <tobe> ivanm: but not just print
03:10:33 <ivanm> tobe: give me a type of what you want to do, and I might be able to help you
03:10:41 <ivanm> but just saying you want to "do stuff" doesn't help
03:10:47 <ivanm> look through Data.List
03:11:35 <sohum> @pl \(x,y) -> (x,y,z)
03:11:36 <lambdabot> ap (ap (flip (flip . (,,))) fst) snd
03:11:42 <sohum> ...ew.
03:11:52 <sohum> also where's z?
03:12:10 <tobe> ivanm: like i said i have a list like [(Jan, 31),(Feb, 28),...] and have to print all dates for a year like: [(1, Feb, 2009), (2, Feb, 2009), (3, Feb, 2009), ...] for all days in the year
03:12:29 <ivanm> OK...
03:12:35 <Jonno_FTW> are you doing a project euler question tobe?
03:12:50 <ivanm> so you want to go from [(Month, Day)] -> [(Day, Month, Year)]
03:12:51 <ivanm> ?
03:13:03 <ivanm> are you just including those dates in the first list, or trying to generate all of them?
03:13:06 <tobe> Jonno_FTW: euler questions?!
03:13:23 <sohum> tobe: alright, so I suppose the first think you have to think about is how to turn (Jan, 31) into [(1, Jan, 2009), (2, Jan, 2009) ... (31, Jan, 2009)]
03:13:36 <Jonno_FTW> your question sounded like this
03:13:37 <tobe> ivanm: i have to generate a list with all the days. in the first list are just the maximal numbers of days for each month
03:13:37 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=19
03:13:57 <ivanm> tobe: ummm.... for the first one, I'd define it, not generate it
03:14:08 <ivanm> tobe: do you have to worry about leap years?
03:15:11 <Zao> I'd use an enum with custom succ.
03:15:33 <sohum> also, I can't really find documentation for fgl
03:15:37 <Jonno_FTW> isn't there already calender packages?
03:15:38 <tobe> ivanm: yes, a already have a function thats checks if a year is a leap year
03:15:40 <sohum> the user manual is apparently quite old
03:15:52 <Zao> And then just filter on [(1901, Jan, 1)..(2000, Dec, 31)]
03:15:56 <tobe> ivanm: but i think that issn't important in the first step
03:15:59 <ivanm> tobe: so you have a function that generates each list?
03:16:23 <tobe> Jonno_FTW: i have to implement it for my own. it's an exercise
03:16:56 <tobe> ivanm: i have a list with the maximal numbers of days in each month
03:17:13 <ivanm> allDates year = concat [ [ (day, month, year) | day <- [1..maxDay] ] | (month, maxDay) <- daysIn year ]
03:17:14 <ivanm> tobe: ^^
03:17:14 <tobe> ivanm: i don't care of the leap year atm
03:17:19 <ivanm> done
03:17:29 <tobe> mom
03:17:31 <tobe> i try
03:17:33 <ivanm> assuming you have a function daysIn :: Year -> [(Month, Days)]
03:18:44 <mercury^> That problem is so incredibly boring.
03:20:13 <vy> Why are Text.Regex.PCRE functions (compile, execute, etc.) non-pure?
03:23:26 * hackagebot upload: Bitly 0.0.2 - A library and a command line tool to access bit.ly URL shortener. (SergeyAstanin)
03:23:29 * hackagebot upload: control-monad-exception 0.8.0.2 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
03:23:31 <Jonno_FTW> let isLeap n | (take 2$reverse$show n) /= "00" =  (rem n 4) == 0  | otherwise = (rem n 400) == 0 in isLeap 2000
03:23:34 <Jonno_FTW> > let isLeap n | (take 2$reverse$show n) /= "00" =  (rem n 4) == 0  | otherwise = (rem n 400) == 0 in isLeap 2000
03:23:35 <lambdabot>   True
03:23:47 <Jonno_FTW> > let isLeap n | (take 2$reverse$show n) /= "00" =  (rem n 4) == 0  | otherwise = (rem n 400) == 0 in isLeap 1900
03:23:48 <lambdabot>   False
03:24:15 <tavelram> Id suggest that you check some iso-standard or something, regarding implementing date, since leap year isnt the only "exception"...
03:24:27 * hackagebot upload: control-monad-exception-mtl 0.8.0.2 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
03:24:51 <Jonno_FTW> what other exceptions could there be to effect the length of a year
03:24:53 <Jonno_FTW> ?
03:25:27 * hackagebot upload: control-monad-exception-monadsfd 0.8.0.2 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
03:25:38 <tavelram> i think there are a bunch of them, but not sure on what level they all operate, but the last year was one second longer, right?
03:26:09 <Jonno_FTW> oh, is that really a factor in calender producers?
03:26:23 <Jonno_FTW> i guess we want the accurate calender for the year 3214
03:26:32 <tavelram> probably not the second-one, but it feels a bit careless not to check if there are any larger ones.
03:26:48 <Jonno_FTW> it may start a day later if added seconds aren't taken into account
03:27:12 <tobe> ivanm: but how do i have to change the var names beside off the daysIn function in: allDates year = concat [ [ (day, month, year) | day <- [1..maxDay] ] | (month, maxDay) <- daysIn year ]
03:27:32 * hackagebot upload: control-monad-exception-monadstf 0.8.0.2 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
03:27:33 <tavelram> well, probably, not, depending on how you use it. But it would incorrectly claim the lengths of spans...
03:28:20 <tavelram> eg "2008-01-01 - 2009-01-01 is a year long" - which is correctly rounded down, but might ackumulate to something eventually.
03:28:45 <tavelram> it just feels like a good idea to implement date as the standard says...
03:28:51 <Jafet> It is a year long!
03:29:46 <tavelram> indeed, but the fact that it was 1s longer than the "normal" year implies that it could cause problems.
03:30:55 <Jafet> Well then, sir, define year
03:30:59 <Jonno_FTW> http://en.wikipedia.org/wiki/ISO_8601
03:31:17 <Jonno_FTW> the time it takes for Earth to perform one revolution around the sun
03:33:07 <tavelram> Jafet, my point is that it would be good to use a formal specification/definition of the calander to define "year".
03:33:52 <mercury^> (take 2$reverse$show n) /= "00" -- you really don't want to do that
03:34:03 <Jonno_FTW> well, if we know the mass of the sun, we can calculate the length of a year
03:34:09 <Jonno_FTW> what's wrong with what i did?
03:34:10 <tavelram> Jonno_FTW, cant click atm, but just peeking on leap yaer on wikipedia mentions some exceptions to leap year, eg year divisble with 100.
03:34:14 <Jonno_FTW> how would you do it?
03:34:19 <tavelram> Jafet, my point is that it would be good to use a formal specification/definition of the calander to define "year".
03:34:33 * hackagebot upload: Bitly 0.0.3 - A library and a command line tool to access bit.ly URL shortener. (SergeyAstanin)
03:34:34 <mercury^> (n `mod` 100 == 0) -- better innit?
03:34:35 <Jonno_FTW> that is what my (take 2$reverse$show n) /= "00 takes into account
03:34:42 <Jonno_FTW> i guess
03:34:44 <tavelram> im guessing there might be some iso-stnadard or something for how the date is defined.
03:35:04 <Jonno_FTW> if it is divisible by 4 or 400 it is a leapyear
03:35:12 <Jonno_FTW> wait
03:35:15 <tavelram> oh, cool, but are you sure there arent any other exceptions :p
03:35:25 <Jonno_FTW> just those i think
03:35:42 <Jafet> Why are we trying to define year?
03:35:56 <Jafet> Why not, uh, use one of the nine thousand existing definitions?
03:37:04 <tavelram> Jonno_FTW, wikipedia mentions something about doing another exception when divisible with 4000 as well, ro something, just skimmed.
03:37:14 <Jonno_FTW> wow
03:37:19 <Jonno_FTW> and 40000
03:37:26 <tavelram> Jafet, im not trying to define it, im trying to avoid it by recomending him to use an existing formal standard :P
03:37:36 <Jonno_FTW> and 4*10^n as well?
03:37:42 <tavelram> no idea
03:37:50 <Jonno_FTW> would make sense
03:38:07 <tavelram> but these examples should be enough to make you implement an existing standard.
03:38:19 * Jafet writes a quick suggestion to avoid UTC leap seconds.
03:38:38 <tavelram> if it is hard to find or decide on which, perhaps peeking at linux and *bsd and use whatever standar dthey are using?
03:39:03 <Jonno_FTW> isLeap n | (n `mod` 100 /= 0) =  (rem n 4) == 0  | otherwise = (rem n 400) == 0
03:39:05 <Jonno_FTW> better?
03:39:54 <tavelram> no idea and dont care :P. if this is only a school assignment or something, then it might be fine, but if its work you should really pull upp a standard.
03:40:00 <tavelram> up
03:40:00 <Jafet> The sands of time, clogging up our machines!
03:41:00 <Jonno_FTW> i use a digital clock
03:41:05 <Jonno_FTW> no sand for me
03:42:36 * hackagebot upload: dom-lt 0.1.1 - The Lengauer-Tarjan graph dominators algorithm. (MattMorrow)
03:43:01 <ivanm> mmorrow: which graph implementation did you use for that?
03:43:07 <Jonno_FTW> isLeap2 n |(n `mod` 4 == 0 && n `mod` 100 /= 0) || (n `mod` 400 == 0) = True  | otherwise = False
03:43:11 <ivanm> (IIRC, there's something similar for FGL already...)
03:43:13 <mmorrow> ivanm: IntMap IntSet
03:43:16 <ivanm> *nod*
03:43:25 <ivanm> @tell Cale we really should do more generic graph stuff
03:43:25 <lambdabot> Consider it noted.
03:43:46 <mmorrow> ivanm: the fgl one is O(n^2), this is the fast one (friggin *epic*)
03:44:08 <ivanm> \o/
03:45:08 <mmorrow> i had to scrap a whole version (like 500 lines) because of some i-don't-even-know-wtf bug
03:45:39 <mmorrow> the first attempt was going from the 1979 paper, which ended in disaster..
03:46:18 <mmorrow> the second attempt which worked was going from the description in "Advanced Advanced Compiler Design and Implementation"
03:46:28 <mmorrow> s/Advanced //
03:49:48 <ivanm> :s
03:50:02 <ivanm> mmorrow: as in the alg didn't work?
03:52:30 <Jonno_FTW> how do i fix this:     if doesDirectoryExist title
03:52:33 <Jonno_FTW> ?
03:52:43 <PepeSilvia> nu heel opdracht 13 af :)
03:52:52 <PepeSilvia> oops, again..
03:53:06 <ivanm> Jonno_FTW: in IO?
03:53:10 <Jonno_FTW> yep
03:53:20 <ivanm> ex <- doesDirectoryExist title; if ex then ...
03:53:26 <Jonno_FTW> it didn't like `Bool` where it wanted `IO Bool`
03:54:20 <Jonno_FTW> thanks
03:55:43 <Jonno_FTW> also
03:55:50 <mmorrow> ivanm: that IntMap-using version takes 4 seconds on a 3000-vertex random-gen graph (between 4-10 edges from any one node), and the array-using fgl one takes 8 seconds
03:55:50 <Jonno_FTW> how can I map an IO over a list?
03:55:59 <Jonno_FTW>     map createDirectory folders
03:56:02 <ivanm> mmorrow: fgl uses arrays? :o
03:56:12 <ivanm> Jonno_FTW: mapM
03:56:17 <Jonno_FTW> ahh
03:56:18 <ivanm> @type mapM
03:56:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:56:33 <ivanm> Jonno_FTW: if you don't care about the result, use mapM_
03:56:34 <ivanm> @type mapM_
03:56:35 <mmorrow> ivanm: gah, there was some fence-post index error going on, and so many moving parts i just gave up
03:56:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:56:48 <ivanm> mmorrow: heh; trying to be too fancy and fiddly were you?
03:56:51 <mmorrow> ivanm: the dominators function does
03:57:24 <ivanm> *shudder*
03:57:33 <ivanm> yeah, most of the FGL stuff is fugly
03:57:39 <mmorrow> ivanm: heh, actually just the opposite.. was following along with the paper and tried to shortcut setting up the support functions/stuff before i tried to code the algo
03:57:43 <ivanm> thing is, it allows you to have node and edge labels, which I need
03:57:48 <ivanm> mmorrow: heh
03:58:26 <mmorrow> ivanm: i just use (IntMap IntSet) always, and have a (Map a Int, IntMap a) on the side
03:58:37 <ivanm> *nod*
03:58:38 <mmorrow> (usually you only need the (IntMap a)
03:58:39 <mmorrow> )
03:59:02 <ivanm> if FGL was re-written to use more "modern/better" techniques, I think it would be OK
03:59:10 <ivanm> (e.g. don't use 4-tuples so much, etc.)
04:01:08 <mmorrow> i'm starting to like just using (IntMap IntSet) + (IntMap a) actually, it totally sidesteps the (i'm starting to think impossible) task of coming up with a one-size-fits-all graph rep, while at the same time being convenient and pretty much as fast as you can get before you bump down a complexity level (O(lg n) ==> O(1), but then you lose either mutability or not-being-in-a-monad)
04:02:04 <mmorrow> also, union/intersection of graphs is comparatively inefficient with arrays
04:02:15 <mmorrow> union is O(1) best-case with IntMap
04:02:22 <ivanm> mmorrow: I think if we wrapped something like that up to make its implementation opaque and thus ensure more safety, it might be even better
04:02:28 <mmorrow> (O(m+n) worst iirc)
04:03:08 <mmorrow> ivanm: i'm not sure. i like it precisely because it /is/ transparent
04:03:45 <mmorrow> although IntMap is abstract, the combo of (IntMap IntSet) is kind of like having a concrete data-structure, like Data.Tree or something
04:04:07 <ivanm> mmorrow: yes, but it requires more _manual_ bookkeeping to keep it going
04:04:30 <ivanm> especially if you want to take care of node labels + edge labels
04:04:46 <ivanm> or even using a bi-map approach to be able to find predecessors more efficiently
04:04:49 <mmorrow> ivanm: yeah, true.
04:06:00 <ivanm> mmorrow: because I do a lot of predecessor stuff as well
04:07:42 <mmorrow> ivanm: here's my `Labels' module i've been using for this kind of thing (along with the types module for reference) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5354#a5354
04:08:23 <mmorrow> ivanm: with the right higher-order functions, you can almost make all the extra noise disappear
04:08:23 <ivanm> "Lem"?
04:08:39 <mmorrow> ivanm: it's my compiler/interpreter i've been working on :)
04:08:42 <ivanm> and "Std" makes it look like C++ ... you wanting your code to be enterprise-y? :p
04:08:45 <ivanm> mmorrow: ahhh
04:09:04 <mmorrow> ivanm: heh, good point
04:09:08 <ivanm> mmorrow: if ghc automagically used IntMap/IntSet for Int-based Map/Set, then it'd be even better
04:09:10 * mmorrow s/Std/Factory/
04:09:17 <ivanm> because you could make generic versions...
04:09:21 <mmorrow> ivanm: yeah, totally
04:10:05 <mmorrow> and you could collapse the value as well if they're Int/Double/something, so both the key /and/ the value get unpacked into the constructor
04:10:09 <temoto> Hello. Haskell compiler uses something called C-- backend, right?
04:10:35 <ivanm> temoto: not quite
04:10:38 <mmorrow> temoto: ghc uses its own non-standard version of it
04:10:45 <ivanm> it doesn't really use proper C-- (it uses GCC-isms)
04:11:03 <ivanm> also, nowadays most architectures have a native code generator that usually outperforms the C-based code generator
04:11:15 <ivanm> (except for when you use a lot of floating point operations IIRC)
04:12:18 <temoto> I thought compilation through C-- was native one as opposed to -f-via-c compilation through C.
04:12:56 <mmorrow> ivanm: i like the idea of the "Context" type that fgl has
04:13:08 <ivanm> mmorrow: yeah, it's nice... but a record-based type would be better IMHO
04:13:14 <temoto> Anyway, i can't google it, is there any public documentation about C-- used?
04:13:22 <ivanm> since a lot of the time it's a pita to manually get every value if I only want to edit one
04:13:35 <ivanm> and AFAIK, its usage of 4-tuples that means you can't make Eq instances
04:13:51 <ivanm> temoto: nope; -f-viaC uses C--
04:13:58 <mmorrow> ivanm: oh yeah, i can see that. i just mean the idea though.. a local neighborhood about a given vertex
04:14:03 <ivanm> yeah
04:14:13 <ivanm> mmorrow: as I said, a re-written FGL would be _great_
04:14:29 <mmorrow> 3-tuples are always a wow-i-really-regret-doing-that kind of thing
04:14:32 <ivanm> I've wanted to try writing one; unfortunately, I've got enough on my plate as it is :s
04:14:46 <ivanm> mmorrow: well, they're OK for quick-and-dirty data passing
04:14:47 <mmorrow> after you've written your 1000th (\(a,_,_)->....a..)
04:14:56 <mmorrow> yeah definitely
04:15:06 <ivanm> but as part of an overall library design? definitely bad
04:15:10 <mmorrow> as long as you don't have to deconstruct them over and over
04:16:15 <temoto> ivanm: thanks. Could you point to some documentation on that?
04:16:31 <int-e> you could always define  source,target :: (a,b,a) -> a; and label :: (a,b,a) -> b
04:16:32 <lambdabot> int-e: You have 1 new message. '/msg lambdabot @messages' to read it.
04:16:33 <ivanm> temoto: heh, my info comes from here ;-)
04:16:56 <Lemmih> temoto: http://hackage.haskell.org/trac/ghc/wiki/Commentary
04:16:58 <drostin77> hi haskell, does haskell has a command line tool to quickly see documentation of installed modules (like ri for ruby)?
04:17:11 <drostin77> trying everything i come across in GHCI is rather... foolish
04:17:20 <Jonno_FTW> yes
04:17:22 <temoto> Lemmih: thanks.
04:17:26 <Jonno_FTW> it's hoogle
04:17:34 <drostin77> hoogle seaches i thought
04:17:39 <drostin77> hoogle can show docs as well?
04:17:46 <Jonno_FTW> hmm
04:17:54 <Jonno_FTW> you can install lambdabot
04:18:04 <ivanm> Jonno_FTW: that's non-trivial
04:18:58 <drostin77> for example, "ri String" in ruby would find each installed (site or core) ruby library with a String class, and let you browse docs for the one you wanted
04:19:13 <drostin77> lambdabot eh? non-trivial is OK:P
04:20:08 <mreh> HGL needs someone to maintain it
04:20:25 <mreh> I would vonlunteer, but I don't know if I have the experience
04:20:39 <ivanm> mreh: what's HGL? the graphics library?
04:20:52 <mreh> Hugs Graphics Library
04:21:00 <mreh> it's nice simple graphics library
04:21:23 <drostin77> lol a quick google search tells me that lambdabot supports a "brainfuck interpreter"
04:21:25 <mreh> you can make some simple vector based games in it really easily
04:21:44 <int-e> @bf ++++++++[>++++++++<-].
04:21:45 <lambdabot>  Done.
04:21:54 <int-e> @bf ++++++++[>++++++++<-]>.
04:21:54 <lambdabot>   @
04:21:59 <medfly> :o
04:22:22 <ivanm> @quote @bf
04:22:22 <lambdabot> erg0t says: <erg0t> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>. <lambdabot>  Hello World!
04:22:30 <ivanm> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
04:22:30 <lambdabot>   Hello World!
04:22:40 <mreh> i was going to try that
04:23:24 <drostin77> Ok.  Let me ask my question in a different light:  When reading someone elses Haskell code, if I run across a library/function I am unfamiliar with, where do I turn to read up on it?
04:23:37 <mreh> drostin77: HackageDB
04:23:40 <Jonno_FTW> hackage
04:23:41 <Raynes> drostin77: Hoogle or Hayoo.
04:23:57 <Raynes> And Hackage, of course.
04:24:11 <mreh> Hoogle is great, you can search by type signature too!
04:24:38 <drostin77> ooOOoh.  got it.  Stupid of me, did not realize hackageDB had docs etc. Thought of it as a library repository.  THanks all :)
04:25:14 <drostin77> back to my haskell book then, thanks for hte help!
04:25:34 <Peaker> when will cabal install work with ghc 6.12+?
04:25:48 <ivanm> Peaker: when dcoutts makes a release
04:25:55 <ivanm> darcs works, he just wants to test it more I think
04:26:03 <Peaker> ah, cool, I'll get darcs then
04:26:50 * Raynes can't wait for the next Platform release.
04:26:53 <sohum> :t (.) (+1)
04:26:54 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
04:27:10 <Raevel_> Raynes: is there a planned release date?
04:27:23 <sohum> :t (.) (+1) `asTypeIn` \f -> f (*2)
04:27:24 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
04:27:34 <Raevel> it'd be nice since i didn't manage to compile cabal-install with 6.12!
04:30:08 <Jonno_FTW> hey, i keep getting a compile error at 13:25 in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14348#a14352
04:30:21 <Jonno_FTW> it thinks it wants a filepath but I don't know why
04:37:27 <Lemmih> Jonno_FTW: You're using 'getDirectoryContents' wrong.
04:42:31 <Jonno_FTW> > :t System.Directory.getDirectoryContents
04:42:33 <lambdabot>   <no location info>: parse error on input `:'
04:42:47 <Jonno_FTW> :t System.Directory.getDirectoryContents
04:42:49 <lambdabot> FilePath -> IO [FilePath]
04:44:40 <Jonno_FTW> what did i do wrong?
04:48:47 <inclement> Jonno_FTW: You have just run the function, but the type signature shows it requires one argument - a FilePath
04:49:46 <Jonno_FTW> i see
04:57:04 <Jonno_FTW> how do i go from IO FilePath to FilePath?
04:58:09 <Jonno_FTW> in:  putStrLn $ getDirectoryContents getCurrentDirectory
04:58:46 <Baughn> Jonno_FTW: Technically, you can't. >>= fixes putStrLn so it takes an IO FilePath instead of a FilePath.. sort of.
04:59:02 <Jonno_FTW> hmm,
04:59:05 <Peaker> Jonno_FTW: Using fmap or bind you can get a named value of type FilePath as a function argument
04:59:05 <ivanm> @type (>>=)
04:59:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:59:08 <Jonno_FTW> i only started this IO stuff today
04:59:16 <ivanm> it extracts the value from the first monad, and passes it to the function
04:59:26 <ivanm> Axman6: care to provide Jonno_FTW with your IO tutorial?
04:59:31 <Peaker> Jonno_FTW: you can't convert  (IO a) to (a)  but you can create a new (IO b) value based on the (a)
04:59:44 <Jonno_FTW> sounds logica
04:59:45 <Baughn> Jonno_FTW: do dir <- getCurrentDirectory; contents <- getDirectoryContents dir; putStrLn contents
04:59:45 <Jonno_FTW> l
05:00:10 <Peaker> Jonno_FTW: You can write an  (a -> IO b) function -- and "chain" it to the (IO a) value, such that it does get to see the "a" value, but you eventually end up with (IO b), not "a"
05:00:22 <Baughn> Or, more compactly, "putStrLn =<< getDirectoryContents =<< getCurrentDirectory"
05:00:31 <Peaker> Jonno_FTW: "do" makes it easy to write (a -> IO b) functions that look like imperative programs
05:05:13 <Guest28809> is someone familiar with some simple haskell strings to html ?
05:05:56 <stroan> Guest28809: not sure what you mean?
05:06:11 <Guest28809> I have this assignement and I'm not sure what they mean either
05:06:20 <Guest28809> they have posted a link to haddock but it doenst work
05:06:49 <stroan> do they want you to parse HTML? generate HTML?
05:06:54 <Guest28809> parse
05:07:13 <Guest28809> I guess, I have some haskell strings with tupels with bold/ italic markup
05:07:33 <jlouis> Guest28809: What is the haddock link?
05:07:46 <jlouis> it changed recently
05:07:55 <Guest28809> http://haskell.org/ghc/docs/latest/html/libraries/html/Text-Html.html
05:08:43 <Baughn> http://hackage.haskell.org/package/html <-- Aha, this one
05:08:54 <Baughn> That's for generating html, though
05:09:54 <Guest28809> I have in haskell a string like: [Bold "boldword", Italic "somewordsinitalic", Unformatted "someplainwordsnomakrup"]
05:10:39 <Guest28809> and then the question is: define a function that converts such values to HTML values
05:11:52 <Guest28809> tnx for thelink btw baughn
05:12:01 <Zao> decorate Bold b = printf "<b>%s</b>" $ escape b
05:12:29 <Jonno_FTW> map (\(markup,text) -> "<markup>text</markup>") strings
05:13:22 <Zao> Jonno_FTW: Except that his markup seems to be ctors of a type.
05:13:38 <Zao> data FancyPants = Bold String | Italic String | ...
05:16:05 <ivanm> Guest28809: pandoc is another document library
05:16:26 <ivanm> Zao: right, so you have HTML -> String
05:16:41 <Guest28809> hm?
05:16:46 <ivanm> markup (Bold b) = "<bold>" ++ b ++ "</bold>"
05:17:03 <ivanm> Guest28809: if you want to use a library to do datatype -> HTML, there's also pandoc
05:17:18 <Guest28809> ah ok, but I'm affraid im restricted to text.html
05:18:06 <ivanm> I would probably use pretty to do HTML -> Doc, and then render the doc
05:23:20 <jlouis> Guest28809: http://haskell.org/ghc/docs/6.10.4/html/libraries/html/Text-Html.html will help you more
05:24:03 <Guest28809> tnx jlouis but i had the link alrdy from baughn
05:24:22 <Guest28809> and this is understandeble
05:24:29 <Guest28809> so I gues I'm gonna be fine
05:41:04 <Guest28809> what are the properties of the html type in haskell? what computations can you do with it
05:42:14 <Zao> There is no inherent "html type"
05:42:22 <Guest28809> ok
05:42:22 <Zao> There are just a bunch of libraries defining some.
05:42:39 <vy> Can anybody help me with this simple "error" error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14353
05:42:39 <Guest28809> how can I have a function compute something
05:42:47 <Guest28809> and after go recursive
05:42:59 <Guest28809> like ehh some base clause function [] = []
05:43:15 <Guest28809> and function (x:xs) = print x ANDAFTERDO function xs
05:43:18 <Lemmih> vy: error (a ++ b ++ c)
05:43:18 <Guest28809> something like that
05:43:30 <vy> Lemmih: Bah!
05:43:34 <Lemmih> vy: Or: error $ a ++ b ++ c
05:43:55 <Zao> Guest28809: Have you've considered reading a decent book/guide like Real World Haskell or Learn You A Haskell?
05:43:56 <inclement> Guest28809: For the latter, you can have function (x:xs) = do ... \n ...
05:44:01 <inclement> But this seems ugly
05:44:09 <Guest28809> hm ye my base clause is wrong
05:44:18 <Guest28809> it must be something, like saying : it's ok now, stop
05:44:19 <Zao> Guest28809: Look into do blocks and/or >>
05:44:33 <knobo> in http://www.haskell.org/all_about_monads/html/solution4.html (last one) Why not just: grandparents s = parent s >>= parent ?
05:44:40 <Zao> Guest28809: Well, what would the type of your second definition be?
05:45:03 <Guest28809> my 2nd?
05:45:37 <Guest28809> I have this list of tupels, and I want recursively go down the list and every tupel (as a head of the list) I want to convert to html
05:45:43 <ivanm> knobo: because they defined parent afterwards? *shrug*
05:46:19 <Lemmih> Guest28809: Tuples.
05:46:26 <Guest28809> ok :)
05:47:00 <Zao> @type map
05:47:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:47:07 <Zao> Guest28809: ^
05:47:35 <Guest28809> what can I do with map
05:47:49 <knobo> I think I know why. If one sheep has only one mother, and not a father... or maybe not..
05:47:58 <Jonno_FTW> apply a function to every element in a list
05:47:59 <ivanm> > map (*2) [1..10]
05:47:59 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
05:48:18 <knobo> nope.. that's not it.
05:48:25 <Guest28809> ye ok, but how is this usefull to my question
05:48:27 <Jonno_FTW> [f a, f b, f c] == map f [a,b,c]
05:48:33 <Lemmih> knobo: I think both definitions are good.
05:48:35 <ivanm> knobo: or else you're thinking about it too hard...
05:48:50 <Zao> Guest28809: Yet again, I strongly suggest that you head over to: http://learnyouahaskell.com/ or http://book.realworldhaskell.org/
05:48:57 <knobo> I just thought I had missed something.
05:49:14 <Jonno_FTW> what about the wikibook on haskell?
05:49:25 <ivanm> or yaht
05:49:26 <Guest28809> ye well ok, I have almost finished learnyouahaskell
05:50:00 <Guest28809> and I have this amazing reader from this proffessor of the university
05:50:09 <Guest28809> but i'm lazy evaluating this assignement
05:50:42 <ivanm> Guest28809: so it's an assignment and you're expecting us to spoon-feed you the solution rather than reading through lecture notes, etc.?
05:50:45 <Zao> I keep forgetting the policy on homework here.
05:50:54 <Guest28809> no then u haven't read my shit I guess
05:50:55 <Zao> Is it "give hints towards things to use"?
05:51:01 <tobe> ivanm: i don't know how i have to replace your vars with me beside of the monthAndMaxDay-function: allDates year = concat [ [ (day, month, year) | day <- [1..maxDay] ] | (month, maxDay) <- monthAndMaxDay year ]
05:51:17 <Guest28809> I have the idea how to do it, but I don't know how to work recursively and have the function stop when it reaches the empty list
05:51:23 <ivanm> Zao: AFAIK, the policy is "if they're stupid and lazy, tell them to do it themselves"
05:51:28 <ivanm> (that's my policy, anyway)
05:51:45 <ivanm> if they seem to have made genuine attempts, etc. then help them along ala socratic method
05:51:55 <Zao> ivanm: Worksforme.
05:51:57 <knobo> They are not equaly good. Mine is superior :)
05:52:03 <DigitalKiwi> ivanm: what is socratic method?
05:52:05 <DigitalKiwi> ;D
05:52:28 <ivanm> http://en.wikipedia.org/wiki/Socratic_method
05:52:45 <DigitalKiwi> sarcasm is lost on internets :(
05:52:52 <ivanm> DigitalKiwi: my interpretation: hint them along the way to self-enlightenment so that they figure it out themsleves
05:52:53 <ivanm> oh...
05:53:01 <ivanm> yeah, we need <sarcasm></sarcasm> tags...
05:53:32 <DigitalKiwi> "s a form of inquiry and debate between individuals with opposing viewpoints based on asking and answering questions to stimulate rational thinking and to illuminate ideas. /me asked question
05:53:35 <ivanm> tobe: so what's your problem?
05:54:52 <boris_> hi all. Why does ghci narrow number types if sources loaded from file? I have a function nums = [1..9] in file and its type is [Integer]. However if I type :t [1..9] the type is more general as I expected - (Num t, Enum t) => [t].
05:56:04 <quicksilver> boris_: Monomorphism restriction
05:56:15 <idnar> I think that's defaulting + monomorphism restriction at work
05:56:16 <idnar> ah
05:56:18 <quicksilver> @go haskellwiki monomorphism restriction
05:56:18 <lambdabot> Maybe you meant: google googleit do
05:56:23 <quicksilver> @google haskellwiki monomorphism restriction
05:56:25 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
05:56:25 <lambdabot> Title: Monomorphism restriction - HaskellWiki
05:57:07 <tobe> ivanm: when i take your line of code u
05:57:36 <tobe> and just replace it to my list of days per month i get errors like that: Couldn't match expected type `t -> [t1]'            against inferred type `[(Month, Day)]'
06:00:01 <boris_> now I see. Thanks
06:05:49 <SatansDeer> Hi all
06:06:25 <byorgey> hi SatansDeer
06:07:11 <SatansDeer> can anybody give me simple explanation, what are monads? plz
06:07:39 <pastah_rhymez> SatansDeer: they're like burritos
06:08:07 <SatansDeer> ))lol
06:08:10 <pastah_rhymez> http://blog.plover.com/prog/burritos.html
06:08:31 <SatansDeer> thnx
06:08:47 <pastah_rhymez> though don't expect too much from it :p
06:08:56 <SatansDeer> &
06:08:58 <SatansDeer> ?
06:09:00 <pastah_rhymez> if you want a good explanation read "All about monads"
06:09:00 <SatansDeer> why
06:09:06 <SatansDeer> ok
06:09:13 <pastah_rhymez> it's filled with good examples
06:09:14 <Saizan> SatansDeer: Monad is just an interface for some kind of combinator libraries
06:09:36 <SatansDeer> so i can use dll?
06:09:47 <pastah_rhymez> dll?
06:10:07 <SatansDeer> dll's
06:10:19 <byorgey> SatansDeer: monads are NOT really like burritos, that is just a joke.
06:10:23 <Saizan> SatansDeer: so it mostly gives ways to compose elements into bigger ones
06:10:44 <pastah_rhymez> byorgey: actually i found that explanation to be quite good :)
06:10:47 <Saizan> these elements are called monadic actions, and often describe some kind of computation
06:10:56 <pastah_rhymez> byorgey: data Burrito a = Roll a
06:11:06 <byorgey> pastah_rhymez: if you want to understand monads, it is not a good explanation.
06:11:13 <pastah_rhymez> byorgey: true :/
06:11:25 <byorgey> if you already understand monads, it is amusing =)
06:11:50 <pastah_rhymez> SatansDeer: how much have you messed around with haskell?
06:12:07 <SatansDeer> about 3-4 days
06:12:08 <pastah_rhymez> (== what parts of the language have you used)
06:12:20 <pastah_rhymez> SatansDeer: get good experience using lists and maybe
06:12:27 <SatansDeer> i'm reading lern haskell for good
06:12:31 <pastah_rhymez> then you should read All About Monads
06:12:38 <pastah_rhymez> but it'll probably be kinda hard
06:12:47 <Saizan> http://www.haskell.org/haskellwiki/Monads_as_computation <- this before All About Monads, probably
06:12:52 <SatansDeer> i understand
06:13:06 <_Cactus_> hi
06:13:07 <Saizan> SatansDeer: it's best to learn how typeclasses work first anyhow
06:13:22 <EvanR> i had a hard time reading about monads before understanding data types and type instances
06:13:27 <_Cactus_> I'd like to use threads in a Haskell program that's compiled with GHC 6.10
06:14:13 <_Cactus_> I've used the -threaded switch when compiling
06:14:15 <Saizan> EvanR: yeah, a good understanding of the type system is crucial
06:14:16 <ddarius> If you have a good handle on types, including type classes, most things in Haskell are pretty simple.
06:14:35 <_Cactus_> but when I run it with +RTS -N2 (or any number after -N), I don't see any mention of sparks in the output
06:15:15 <Saizan> _Cactus_: why should there be?
06:15:30 <_Cactus_> saizan: sorry I meant +RTS -s -N2
06:15:49 <_Cactus_> saizan: the samples I found on the web all mentioned that I should see spark statistics in the output of -s
06:16:40 <Saizan> ah, i see, i don't know about that though
06:18:32 <_Cactus_> I just want to see if my program tries to spark more than one thread
06:19:09 <Saizan> so you're using forkIO and/or par (or combinators made with them) right?
06:19:17 <_Cactus_> yes, I'm using par and pseq
06:19:49 <_Cactus_> i'm doing something like a `par` b `pseq` (a && b)
06:22:09 <JaffaCake> _Cactus_: use +RTS -s
06:22:27 <fasta> Uhm, how is it possible that the type of a function at the top-level depends on whether or not something else references it?
06:22:30 <_Cactus_> jaffacake: that's what I'm doing
06:22:39 <_Cactus_> jaffacake I'm getting all kinds of output, except anything mentioning sparks
06:22:47 <JaffaCake> _Cactus_: look for "SPARKS"
06:22:53 <fasta> That is, when I copy the function definition and rename this copy, I get a module which does not load anymore.
06:23:21 <fasta> JaffaCake, any idea how this is possible?
06:23:32 <JaffaCake> fasta: the MR?
06:23:39 <fasta> The derived type of the function is incorrect too, btw.
06:23:40 <_Cactus_> jaffacake: that string simply doesn't occur in the output
06:23:46 <fasta> JaffaCake,  The MR is off.
06:23:53 <JaffaCake> _Cactus_: ah, it was added in 6.12.1
06:23:57 <_Cactus_> oic
06:24:06 <_Cactus_> the feature, or the output?
06:24:13 <JaffaCake> the output
06:24:34 <_Cactus_> thanks
06:24:38 <tobe> monthAndMaxDay is a list with tuples like [(Jan, 31),(Feb, 28),...]. where do i have to put "snd" to check myDay for the corresponding month (myMonth)?
06:24:47 <fasta> JaffaCake, but even with the MR, the type should be the same, no?
06:24:52 <quicksilver> fasta: no
06:24:55 <tobe> for: myDay >= snd (find ((== myMonth) . fst) monthAndMaxDay
06:25:03 <quicksilver> fasta: the top-level is checked in recursively dependent units.
06:25:22 <quicksilver> fasta: adding something to the recursive group can pin a type down further.
06:25:43 <JaffaCake> fasta: the MR requires that a value is used monomorphically, so it depends on the uses
06:25:46 <vy> Is it possible to get the value from a monad (ie. IO String) in ghci?
06:25:58 <fasta> quicksilver, hmm, ok. And is this also possible without the MR?
06:26:13 <_Cactus_> jaffacake: so there's no way to see with 6.10 if my code is bad (i.e. it doesn't even try to create threads) or there's simply no thread available for it?
06:26:27 <JaffaCake> fasta: not as far as I'm aware
06:26:51 <fasta> And the "the MR", does that only refer to the current module?
06:27:03 <_Cactus_> OK thanks, I'll see if I can find a .deb of 6.12
06:27:12 <JaffaCake> _Cactus_: compare the time to the elapsed time to see if you got any parallelism
06:27:40 <_Cactus_> I'm not getting any difference, that's why I first wanted to see if my code is even parallel
06:27:51 <Peaker> threadscope!
06:27:58 <JaffaCake> _Cactus_: you are compiling with -threaded and using +RTS -N2 or higher?
06:28:01 <_Cactus_> yes
06:28:30 <JaffaCake> I'd recommend trying 6.12.1 if you can
06:28:36 <fasta> JaffaCake, so, assuming a module with NoMonomorphism in its LANGUAGE options, and a function f, in a module which loads correctly, which is then copied to function g (which is a new name) and then does not load, is a bug?
06:28:41 <JaffaCake> though you'll need new libraries etc.
06:29:22 <JaffaCake> fasta: I can't say for sure (there are many corners of type system I don't fully undrestand)
06:30:23 <JaffaCake> fasta: did the function have a type signature?
06:31:35 <fasta> JaffaCake, I didn't give it one. What I do find odd is that I give a parameter to f (which is a function) and this parameter is not used anywhere, yet it has not type 'a'.
06:32:06 <JaffaCake> fasta: paste the code?
06:32:24 <vy> Reading documentation of Text.Regex.PCRE.String.regexec :: Regex -> String -> IO (Either WrapError (Maybe (String, String, String, [String]))). It says that "Returns: Nothing if no match, else (text before match, text after match, array of matches with 0 being the whole match)
06:32:39 <Absolute0> I want to code a simple 2d app that draws lines and squares (game of life) what 2d graphics library could I use?
06:32:40 <vy> execute match and extract substrings rather than just offsets" but I think it misses some of the returned arguments.
06:32:41 <fasta> JaffaCake, not that easy, but I will try to make something smaller.
06:35:19 <quicksilver> fasta: are you using anything higher rank or impredicative?
06:36:19 <fasta> quicksilver, what is an example of an impredicative type again? I use something of rank-2 somewhere, though.
06:42:29 <vy> Lemmih: Are you the cabal-install author Lemmih?
06:45:24 <byorgey> vy: there is only one Lemmih =)
06:46:04 <quicksilver> fasta: I'm pretty sure rank-2 can break type inference in the way you describe.
06:46:11 <quicksilver> although that doesn't mean it is, in fact, your problem.
06:46:23 <quicksilver> impredicative is things like Maybe (forall a . a)
06:46:31 <quicksilver> quantifiers inside constructors.
06:46:57 <fasta> quicksilver, how does that relate to "predicates", btw?
06:47:28 <fasta> That is, I assume the word was invented for some sane reason.
06:49:34 <Lemmih> vy: Yes, but I'm not in charge of maintenance.
06:50:49 <Lemmih> byorgey: Right, I've crushed all the others. There can be only one.
06:50:58 <vy> Hrm... Whom should I bug for bug reports?
06:51:04 <quicksilver> fasta: impredicative means recursive, as in unsound set theory.
06:51:20 <quicksilver> fasta: I have never understood the relationship between this and the technical type theory meaning.
06:51:26 <quicksilver> I'm sure they are related somehow though :)
06:51:41 <Lemmih> vy: cabal-devel@haskell.org
06:51:47 <tobe> monthAndMaxDay is a list with tuples like [(Jan, 31),(Feb, 28),...]. where do i have to put "snd" to check myDay for the corresponding month (myMonth) in: myDay >= snd (find ((== myMonth) . fst) monthAndMaxDay
06:51:56 <fasta> quicksilver, what is recursive about you Maybe a example?
06:51:58 <SatansDeer> i understood monads, they are not like burritos, they are like conveyer
06:52:13 <fasta> your*
06:52:25 <Saizan> fasta: an impredicative definition is one that abstract over a sets that (maybe indirectly) contains the same thing you're defining
06:53:28 <Saizan> fasta: in Just :: forall a. a -> Maybe a, if that 'a' ranges over polymorphic types, then its range also contains "forall a. a -> Maybe a" itself
06:54:06 <Saizan> if it doesn't you can't have Just undefined :: Maybe (forall a. a)
06:55:48 <Saizan> (impredicativity doesn't necessarily introduces inconsistency, e.g. System F is impredicative and strong normalizing)
06:56:11 <fasta> Saizan, right, that was my next question: why would it be unsound?
06:57:04 <zygoloid> > let foo :: Num b => (a -> b) -> a -> Int -> b; foo f a 0 = f a; foo f a n = foo (\(a,b) -> f a + f b) (a,a) (n-1) in foo id 1 10
06:57:05 <lambdabot>   1024
06:57:27 <Saizan> well it can lead to circular paradoxes like Russel's one afaiu, but it depends on the system as a whole
06:58:05 <zygoloid> ^^ foo :: (a -> b) -> a -> Int -> b  uses  foo :: ((a,a) -> b) -> (a,a) -> Int -> b
06:58:30 <Saizan> s/it/that/
07:05:56 <maltem> It doesn't actually bother me much, but is there going to be a ghc-6.12.1-compatible version of cabal-install (or even, the platform) to be released?
07:06:54 <Saizan> eventually
07:07:10 <fasta> maltem, why not use the darcs version?
07:07:11 <Saizan> the next platform release will be
07:07:21 <fasta> maltem, it works on Linux and Windows.
07:11:38 <maltem> fasta, yeah I've read that the darcs version works, hence why I was wondering about a release
07:12:12 <fasta> maltem, for me there is no difference between a release and a darcs version when the effort involved is equal.
07:12:22 <fasta> maltem, ./boostrap.sh and done, IIRC.
07:12:46 <fasta> bootstrap*
07:13:05 <maltem> A `darcs get` is some more effort than a tarball to download, but sure it's no big deal
07:16:51 <maltem> Ah cool, that bootstrap.sh does look handy :)
07:17:48 <fasta> maltem, I write a similar script for everything I make. I don't like to follow instructions manually.
07:18:22 <fasta> maltem, so, e.g. if I depend on GTK, I write wget <URL of latest GTK release here>, and so on.
07:19:35 <robinhoode> newb here.. I can't seem to find any answers on Google. Wondering why hugs won't see my cabal packages.
07:19:41 <maltem> Hmph. That script leaves the network package for manual installation, which depends on parsec, which depends on mtl...
07:20:00 <robinhoode> I can see they're installed under /home/<username>/.cabal/ but hugs still says "Can't find imported module 'package-name'"
07:20:10 <maltem> robinhoode, by default Cabal cares only about ghc
07:20:13 <fasta> robinhoode, unless you have a very good reason to use Hugs, use ghci. Much more people use that.
07:20:15 <dcoutts_> robinhoode: they have to be built/installed for each compiler
07:20:35 <robinhoode> ghci.. I'll try that.. Thanks for the help guys
07:20:43 <dcoutts_> robinhoode: in principle cabal can install packages for hugs, but in practise we don't test it much so if it works then you're lucky
07:21:11 <dcoutts_> robinhoode: in particular you'd need to either install into where hugs expects them, or pass extra flags when starting hugs
07:21:13 <Lemmih> Where do I find Cabal-1.8?
07:21:19 <dcoutts_> Lemmih: hackage
07:22:18 <robinhoode> dcoutts, Yeah, I saw there was a directory for hugs packages and I tried to create a symlink so it would see my local cabal packages but it didn't take..
07:22:52 <dcoutts_> robinhoode: you have to use cabal install --hugs, the process of installing for ghc vs hugs is totally different
07:23:00 <dcoutts_> so you can't just symlink
07:23:37 <robinhoode> gotcha.. I'll give that a try
07:23:49 <dcoutts_> robinhoode: cabal install --hugs blah, will pre-process the sources and install the sources. For ghc it actually compiles them to machine code using ghc.
07:24:59 <maltem> Bah I forgot -p
07:28:02 * hackagebot upload: pointless-haskell 0.0.2 - Pointless Haskell library (HugoPacheco)
07:29:38 <HaskellLove> HaskellLove is back unbaned, I just want to thank administrators for giving me second chance, from now on I will behave properly.
07:37:10 * hackagebot upload: pointless-lenses 0.0.1 - Pointless Lenses library (HugoPacheco)
07:40:13 <HaskellLove> I am working on Euler 18, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14357#a14357 I have 15 lists, I want to apply sumList starting with list 14. Then i want to apply the same function to list 13 but such that it takes the new list 14... and continue recursevely up to the list 2. My function now is unary, in order to be used with foldr it should be binary? If that is the case then should...
07:40:14 <HaskellLove> ...i make my function sumList be binary so that it can be recursive?
07:40:49 <HaskellLove> or I can recurse with it as it is, unary?
07:41:50 <zygoloid> a crank called John Gabriel has challenged me to find people who agree with me that the reals are uncountable. if you want to help, see here: http://knol.google.com/k/rsmith/review-of-are-real-numbers-uncountable/nz742dpkhqbi/64# (especially the reviewed article and the comments at the end). thanks!
07:42:56 <maltem> HaskellLove, foldr takes a binary function, that's right
07:44:27 <maltem> HaskellLove, what's what you're going to do, add together the maximum of each list?
07:44:55 <maltem> zygoloid, oh, that's a matter of opinion, nowadays?
07:45:38 <zygoloid> maltem: no, but the #3 hit on google for "are the reals uncountable?" is his drivel and i'm trying to do something about it
07:46:54 <HaskellLove> maltem: 1. Take one list apply sumList to it. This function "changes" the list based on the values of the list below it. 2. i need to recurse that while acumulating results starting from bottom. this is the algorithm idea i use, implementation is mine from scratch... http://www.tushar-mehta.com/misc_tutorials/project_euler/euler018.html
07:47:01 <Jafet> Bush couldn't do anything about his miserable failure
07:47:06 <Jafet> But I think it's noble of you to try.
07:48:30 <SamB_XP_> @google miserable failure
07:48:31 <lambdabot> http://searchengineland.com/google-kills-bushs-miserable-failure-search-other-google-bombs-10363
07:48:31 <lambdabot> Title: Google Kills Bush’s Miserable Failure Search & Other Google Bombs
07:49:05 <SamB_XP_> :-)
07:49:28 <zygoloid> Jafet: well, if i can get enough attention drawn to it that his article gets a lower rating, that should help, i hope.
07:52:17 <maltem> HaskellLove, mmh sry I'm too lazy to look at this now...
07:53:03 <Jafet> He is a crank, but you are a spammer
07:53:05 <maltem> More practical question, what's the platform-independent way to get the size of a file? Open up a handle and use hFileSize?
07:53:09 <Jafet> Have a nice day.
07:53:12 <osaunders> What's ABI mean?
07:53:42 <maltem> osaunders, application binary interface
07:54:06 <Jafet> Use posix module?
07:54:07 <maltem> that is, how libraries are structured
07:54:21 <osaunders> maltem: OK, thnx.
07:54:42 <maltem> Jafet, that would be portable enough for me, still...
07:57:52 <zygoloid> in any case, any ratings on his article or my review of it would be appreciated
08:00:45 <osaunders> I hope GHC 6.12 fixes the problems I was having with moving between words in GHCi.
08:01:05 <osaunders> Wait, that was fine. I was having problems with home and end.
08:03:42 <mercury^> zygoloid: it's not like there is a danger of people being misinformed.
08:04:19 <mercury^> I doubt anyone wonders about the cardinality of the reals, visits that site and believes the wrong information.
08:04:20 <Jafet> We could insert it into wikipedia
08:04:36 <Jafet> Carefully, a site-wide change
08:04:47 <mercury^> Maybe make the appropriate changes and then cite that article?
08:05:02 <Jafet> No one ever reads wikipedia citations.
08:05:07 <SamB_XP_> what is this about lies regarding the cardinality of the reals ?
08:05:13 <SamB_XP_> Jafet: not true!
08:05:24 <Jafet> Everyone generalizes.
08:06:11 <SamB_XP_> where do you think people find citations for things they found on wikipedia when they aren't allowed to cite wikipedia (which they shouldn't be ;-)
08:06:46 <SamB_XP_> though once, I found evidence that a fictional (conglomerate) student had plaigerized badly from wikipedia
08:07:25 <SamB_XP_> when wikipedia was not even allowed if cited
08:07:48 <mercury^> Not allowing wikipedia is such a stupid rule.
08:08:13 <SamB_XP_> mercury^: why's that ?
08:08:22 <SamB_XP_> you can still *use* it
08:08:35 <Jafet> Rules are stupid.
08:08:37 <mercury^> As long as you cite a specific version everyone can check what exactly you cited.
08:08:47 <zygoloid> mercury^: if you really believe there's no danger of people being misinformed, where do you think the 390 or so ratings (from different google accounts) giving his knol four stars come from?
08:08:59 <Jafet> People don't even understand versioning.
08:09:10 <mercury^> zygoloid: people having fun?
08:09:13 <Jafet> Much less how to pull up a revision.
08:09:35 <SamB_XP_> mercury^: the reason is that wikipedia isn't considered a reliable source, being edited, as it is, by idiots
08:09:52 <SamB_XP_> (as well as insanely smart people and everyone in between ;-P)
08:10:05 <osaunders> SamB_XP_: I'm glad you said the second thing.
08:10:08 <SamB_XP_> (and, who knows, maybe even some dogs ...)
08:10:09 <mercury^> SamB_XP_: you should not believe something because of who said it, but because it is plausible.
08:10:18 <SamB_XP_> mercury^: possibly
08:10:34 <quicksilver> life is too short to follow through every single argument to the bottom personally
08:10:42 <mercury^> It can well be that a wikipedia article is wrong, even if it made the impression of being correct. The same is true for other sources.
08:10:42 <quicksilver> proof by authority is much more convenient.
08:10:52 <mercury^> The risk is a bit higher for wikipedia, but meh?
08:11:03 <SamB_XP_> yeah, but not too short to follow it one step beyond wikipedia ;-)
08:11:17 <zygoloid> again, this is the #1 article on google knol, and the #3 article found by google, on this subject...
08:11:33 <SamB_XP_> what article is it again ?
08:11:54 <zygoloid> @google John Gabriel are the real numbers uncountable?
08:11:56 <lambdabot> http://knol.google.com/k/are-real-numbers-uncountable
08:11:56 <lambdabot> Title: Are real numbers uncountable? - a knol by John Gabriel
08:11:59 <SamB_XP_> ah, that...
08:12:07 <SamB_XP_> I definitely did not like that!
08:12:26 <SamB_XP_> where's the counter-article ?
08:13:01 <zygoloid> http://knol.google.com/k/rsmith/review-of-are-real-numbers-uncountable/nz742dpkhqbi/64#
08:13:08 <Jafet> @google timecube
08:13:09 <lambdabot> http://www.timecube.com/
08:13:09 <lambdabot> Title: Time Cube
08:13:31 <paulmitchell> For the number theory airheads here (i,e, me), what does "uncountable" mean?
08:13:31 <SamB_XP_> zygoloid: what's all the gibberish at the end ?
08:13:35 <Jafet> @google church of scientology official website
08:13:37 <lambdabot> http://www.scientology.org/
08:13:37 <lambdabot> Title: Official Church of Scientology Online Videos: What is Scientology, Scientologist ...
08:13:49 <SamB_XP_> paulmitchell: it means that you can't make an infinite list that contains all of them
08:14:04 <paulmitchell> Isn't that obvious?
08:14:18 <fasta> Jafet, you can also link to the climate summit.
08:14:23 <mercury^> It's fairly easy to see, but I wouldn't call it obvious.
08:14:25 <SamB_XP_> paulmitchell: well, not exactly obvious unless you know why
08:14:35 <SamB_XP_> I mean, it's only obvious once explained ;-)
08:14:47 <fasta> Jafet, and that is supposed to be "scientific".
08:14:54 <Jafet> @google intergovernmental panel on climate change
08:14:56 <lambdabot> http://www.ipcc.ch/
08:14:56 <lambdabot> Title: IPCC - Intergovernmental Panel on Climate Change
08:15:10 <Jafet> I can't believe I remember that initialism.
08:15:30 <SamB_XP_> Jafet: why did you just search for the CoS official website ?
08:15:35 <SamB_XP_> @google clamdrake
08:15:36 <lambdabot> No Result Found.
08:15:45 <SamB_XP_> @google clam drake
08:15:47 <lambdabot> http://drakelelane.blogspot.com/2009/12/dinner-with-band-final-clam-fantasy.html
08:15:47 <lambdabot> Title: thus spake drake: Dinner with the Band: Final Clam Fantasy
08:15:52 <SamB_XP_> @google clam drake scientology
08:15:54 <Jafet> To illustrate that zygoloid is wasting our time.
08:15:54 <lambdabot> http://perezhilton.com/2009-12-11-michael-jackson-exploited-by-scientologists
08:15:55 <lambdabot> Title: Perez Hilton: Michael Jackson Exploited By Scientologists!
08:15:58 <SamB_XP_> hmm...
08:16:34 <SamB_XP_> um, okay ...
08:16:37 <andyjgill> > pl \ x -> x
08:16:37 <lambdabot>   <no location info>: parse error on input `\'
08:16:44 <fasta> The problem with this kind of science is that you can only reproduce it if you have the exact same data (or better: can measure the same data) and a computer which is just as powerful. So, in a practical sense it is not really science anymore.
08:16:46 <Jafet> @pl \x -> x
08:16:46 <lambdabot> id
08:16:53 <paulmitchell> So, are natural numbers uncountable?
08:16:55 <andyjgill> @pl \ x -> x
08:16:55 <lambdabot> id
08:17:00 <andyjgill> @pl let { x ::  ([a] -> [b]) -> [a->b] ; x = undefined } in \ choose -> x (\ a -> x (x . choose a))
08:17:00 <lambdabot> (line 1, column 5):
08:17:01 <lambdabot> unexpected "{"
08:17:01 <lambdabot> expecting "()", natural, identifier or "in"
08:17:01 <Jafet> > [1..] -- no.
08:17:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:17:08 <fasta> Are the models used even open-source and documented?
08:17:10 <SamB_XP_> paulmitchell: of course not
08:17:20 <fasta> I doubt it.
08:17:21 <SamB_XP_> paulmitchell: you just iterate Succ Zero
08:17:23 <Jafet> andyjgill, no space after \
08:17:39 <SamB_XP_> fasta: oh, yeah, I hate it when they do that :-(
08:17:39 <paulmitchell> SamB_XP_: which is an infinite list
08:17:44 <aavogt> > (\ x -> x) 1
08:17:45 <lambdabot>   1
08:17:49 <paulmitchell> so there is an infinite list that contains all of them
08:17:52 <SamB_XP_> paulmitchell: yeah, I said an infinite list in the first place
08:17:57 <fasta> SamB_XP_, so, it has reduced to a kind of believe in the "scientists".
08:18:04 <mercury^> paulmitchell: they would be uncountable if there was *no* such list.
08:18:05 <knobo> where is the definition of mcons?
08:18:07 <aavogt> Jafet: that wasn't the problem
08:18:15 <SamB_XP_> fasta: I wonder if it is available upon request ?>
08:18:19 <andyjgill> @pl let x = 1 in x
08:18:20 <lambdabot> 1
08:18:27 <Jafet> Oh, heh
08:18:46 <zygoloid> SamB_XP_: which gibberish?
08:18:55 <andyjgill> @pl let x ::  ([a] -> [b]) -> [a->b] ; x = undefined in \ choose -> x (\ a -> x (x . choose a))
08:18:55 <lambdabot> (line 1, column 7):
08:18:55 <lambdabot> unexpected ":"
08:18:55 <lambdabot> expecting pattern or "="
08:19:36 <fasta> SamB_XP_, there are some cryptography kernels which are also _licenced_ by universities.
08:19:41 <SamB_XP_> zygoloid: oh, nevermind, I thought it was unneccessary to reach the page (the /nz742dpkhqbi/64# bit) but it wasn't
08:19:57 <SamB_XP_> fasta: oh, yeeks
08:20:01 <fasta> SamB_XP_, university/company, is there any difference?
08:20:23 <SamB_XP_> that reminds me, I need to email my Faculty Advisor for Senior Project with info about the LGPL
08:20:24 <fasta> SamB_XP_, basically everything is a corporate structure these days (including government).
08:20:39 <knobo> all
08:20:46 <SamB_XP_> fasta: sure, a university uses a corporate struture, but I wish they wouldn't be so capitalist :-(
08:21:04 <knobo> all_about_monads refers to mcons, but I can not find the definition for mcons enywhere
08:21:22 <andyjgill> @pl let x = undefined :: ([a] -> [b]) -> [a->b] in \ choose -> x (\ a -> x (x . choose a))
08:21:22 <lambdabot> (line 1, column 27):
08:21:22 <lambdabot> unexpected ">"
08:21:22 <lambdabot> expecting variable, "(", operator or ")"
08:21:23 <SamB_XP_> however, I think it should be fairly easy to convince them that there's no real commercial value for the software I'm writing for Senior Project ;-)
08:21:44 <Jafet> "Uh... well, I'm the one writing it!"
08:21:45 <fasta> SamB_XP_, I really don't understand it though. In the Netherlands they are all paid from tax money, but somehow all the useful parts get closed off.
08:22:37 <andyjgill> @pl \ x choose -> x (\ a -> x (x . choose a))
08:22:37 <lambdabot> ap (.) (liftM2 (.) (.) ((.) . (.)))
08:23:01 <andyjgill> @unpl \ x choose -> x (\ a -> x (x . choose a))
08:23:01 <lambdabot> \ x choose -> x (\ a -> x (\ d -> x (choose a d)))
08:24:24 <SamB_XP_> Jafet: I was thinking more along the lines of "anyone who wanted to pay for software to interface with this device would probably just the manufacturer's software, and I don't think they even MAKE the BioFlo 110 anymore, so it's not like the potential market was that big to start with."
08:24:46 <SamB_XP_> s/just/just buy/
08:25:19 <Jafet> You're... cloning something?
08:25:26 <SamB_XP_> Jafet: no!
08:25:47 <SamB_XP_> I'm not saying that my software is equivalent to the manufacturer's, by any means
08:26:51 <pastah_rhymez> andyjgill: this is how you do it:
08:26:59 <pastah_rhymez> @let tits = (.) . (.)
08:27:00 <lambdabot>  Defined.
08:27:04 <pastah_rhymez> @type tits
08:27:05 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:27:20 <andyjgill> Ahh. Thanks.
08:27:34 <pastah_rhymez> @type map (+1) `tits` zipWith (+)
08:27:35 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
08:27:43 <SamB_XP_> it may also help that my faculty advisor for the project is the ChemE chair ;-)
08:27:47 <pastah_rhymez> that's how i use it, at least :)
08:27:51 <andyjgill> @let x = (undefined :: [a -> b] -> [a] -> [b])
08:27:52 <lambdabot>  Defined.
08:28:05 <SamB_XP_> and he thinks open source is fine
08:28:15 <andyjgill> @pl \ choose -> x (\ a -> x (\ d -> x (choose a d)))
08:28:16 <lambdabot> x . ((x . (x .)) .)
08:28:31 <SamB_XP_> anyone know any good essays on why to use LGPL rather than GPL ?
08:28:47 <fasta> SamB_XP_, for Haskell code LGPL and GPL are the same.
08:28:49 <Jafet> The... official one?
08:29:11 <SamB_XP_> Jafet: GNU's stuff mostly says why NOT to!
08:29:49 <fasta> SamB_XP_, what do you want?
08:30:02 <fasta> SamB_XP_, you choose a license based on a certain goal.
08:30:07 <Veinor> what's the integer division operation?
08:30:13 <Veinor> ah, `div`
08:30:14 <SamB_XP_> I want arguments *for* -- also, my code is apparantly in C and Python so far ;-)
08:30:19 <fasta> SamB_XP_, if you want to collect money, why open-source it in the first place?
08:30:33 <SamB_XP_> well, I want my code to be fairly free, and I'm using an LGPL'd library
08:30:39 <SamB_XP_> fasta: I won't see any money
08:30:42 <fasta> SamB_XP_, if you want lots of people to use it, use BSD. You might earn some consulting fees that way.
08:30:56 <SamB_XP_> and I think my school would be fooling themselves to think that they would ever see any, either
08:31:09 <Jafet> You can use any license, so why restrict yourself to GNU ones?
08:31:35 <fasta> SamB_XP_, if you use an LGPLed library, you can use any license. You just have to put in the README that you depend on an LGPL library.
08:31:36 <SamB_XP_> well, the library that I'm using is already LGPL'd, so I figure it's simpler to just use that for everything
08:31:55 <andyjgill> @let choose = undefined :: [a] -> [a] -> [Bool] -> [a]
08:31:55 <SamB_XP_> especially since I'm incorporating the library code in my tree
08:31:56 <lambdabot>  Defined.
08:32:13 <andyjgill> @pl x (\ a -> x (\ d -> x (choose a d)))
08:32:13 <lambdabot> x (x . (x .) . choose)
08:32:50 <fasta> Anyway, licensing stuff is not interesting. A fast enough computer can recreate everything anyway.
08:33:16 <SamB_XP_> so basically, the simplest two choices are: keep it LGPL'd, or use the GPL conversion option ...
08:33:35 <SamB_XP_> so I was just wondering if there was an LGPL page that wasn't as anti-LGPL as the official GNU page ;-P
08:33:40 <Philonous> SamB_XP_: Or MIT/BSD your stuff and don't care about the other licenses
08:34:32 <Jafet> If you want to use the LGPL, use the LGPL. If you want to use the GPL, use the GPL.
08:34:46 <Jafet> If you've made your decision, stop being stupid and follow it through.
08:34:53 <mercury^> And if you want to do the world a favour, release into the public domain.
08:35:16 <Jafet> (the parts of the world which have a public domain)
08:35:39 <Veinor> I use BSD3, personally.
08:36:21 <Philonous> SamB_XP_: I think the idea of LGPL was to lure proprietary software vendors into using free software and thereby increasing it's market share
08:36:25 <Veinor> at least, for libraries. I don't know how I'd feel about someone using a program that I wrote and reselling it
08:37:12 <Philonous> Veinor: GPL permits reselling
08:37:25 <stroan> Philonous: GPL is too viral for my liking
08:37:26 <Veinor> Philonous: well, reselling sans source
08:37:36 <stroan> if you go near it you're locked in
08:37:41 <mercury^> Does it matter? You already published the source.
08:37:56 <mercury^> If someone wanted the source, they can get it from where you published it.
08:38:04 <Veinor> yeah.
08:38:22 <fasta> GPL and selling is a myth. Where do you see people selling GPL code?
08:38:29 <Philonous> Veinor: The only difference is that with BSD you allow other programmers to release their additions on their own conditions/licenses. It has nothing to do with your own code.
08:38:48 <mercury^> fasta: gnat is available under the GPL and also sells.
08:39:01 <mercury^> But you buy copies that are *not* GPL, so I'm not sure that's what you meant.
08:39:05 <Philonous> fasta: You can buy almost all major Linux distributions in software stores, and I know a Bunch of people who do exactly that
08:39:20 <fasta> Philonous, and you can download CentOS for free.
08:39:44 <fasta> mercury^, the ada compiler?
08:39:48 <mercury^> Yes.
08:39:52 <Veinor> oh hey, my cabal package's LICENSE file still has <copyright holder> :/
08:40:09 <Veinor> worth pushing a new version for? :P
08:40:26 <fasta> mercury^, I don't find it obvious that you can buy it. I do know that the FSF sells manuals.
08:40:52 <mercury^> fasta: you do not need to find it obvious, you just need to check it or believe me.
08:40:55 <mercury^> :P
08:41:11 <fasta> mercury^, I did, and I didn't see the "buy" button within 20 seconds.
08:41:17 <aavogt> what does that do for contributors?
08:41:56 <aavogt> they'd have to reassign copyright if dual-licensing is to work properly, no?
08:42:05 <mercury^> fasta: http://www.adacore.com/home/products/gnatpro/pricing/
08:42:30 <knobo> I'm so stupid :(
08:42:33 <mercury^> Took about 10 seconds to get there from http://www.adacore.com/home/
08:42:47 <HaskellLove> Updated my blog, now working on Euler 18 and Euler 19... http://haskelllove.wordpress.com/ ... If anyone has wordpress blog pm me I want to ask him how to change some thing, so i dont flood here.
08:42:49 <fasta> mercury^, yes, and I looked at gnu.org where you can get it for free.
08:42:50 <Tobsan> is there a way to annotate code to make GHC evaluate it at compile time?
08:43:00 <fasta> mercury^, and are you sure all their code is GPL'ed?
08:43:07 <Tobsan> like if i have foo :: [Double]
08:43:18 <mercury^> fasta: yes, it's part of GNU after all.
08:43:43 <mercury^> What you buy is early releases, support and a laxer license.
08:43:58 <aavogt> Tobsan: with template haskell
08:44:20 <mercury^> Ah, and certification.
08:44:40 <Tobsan> aavogt: hmm, is there no easier way? like {-# EVALUATE #-}
08:44:43 <Tobsan> or something similar
08:44:46 <fasta> mercury^, right, that is the other business model of the GPL when you control all the code.
08:44:52 <b0fh_ua> Hi there! If I do have a function with 3 parameters, f x y z - can I partially apply x and z parameters to it in some way? I guess I have to use flip or something?
08:45:17 <aavogt> Tobsan: I'm not aware of anything else used for compile time code evaluation
08:45:23 <roconnor> Tobsan: can template haskell do that?
08:45:29 <ben> @pl \f x z -> \y -> f x z y
08:45:30 <lambdabot> id
08:45:32 <Tobsan> aavogt: alright, thanks.
08:45:32 <ben> err
08:45:34 <ben> @pl \f x z -> \y -> f x y z
08:45:35 <lambdabot> (flip .)
08:45:39 <Tobsan> roconnor: I have no idea, you tell me!
08:45:47 <Tobsan> roconnor: according to aavogt it can
08:45:48 <ColonelJ> hi, why does the haskell platform come with an old GHC
08:45:55 <aavogt> hmm, you can get ghc to run an arbitrary preprocessor
08:46:13 <roconnor> ghc as a preprocessor!
08:46:20 <aavogt> exactly ;)
08:46:33 <aavogt> it's ghc all the way down
08:46:42 <fasta> And Perl.
08:46:44 <fasta> ;)
08:47:14 <ColonelJ> The new version of GHC is 6.12.1, but the platform page says it has 6.10.4 on the download page... ???
08:47:44 <SamB_XP_> Veinor: personally, in this case, I'd just be amazed they found someone to buy it
08:48:28 <SamB_XP_> I wouldn't really mind, since the source for my bit would necessarily be available to the purchasor ;-)
08:49:00 <aavogt> ColonelJ: that ghc release is very new. The plan was to get the platform using 6.12.1 out sometime in january
08:49:45 <fasta> SamB_XP_, what does it do, btw?
08:49:53 <Veinor> SamB_XP_: yeah :P
08:58:39 <stulli> @seen MarcWeber
08:58:39 <lambdabot> Unknown command, try @list
08:58:48 <ColonelJ> half a gig o shi'
08:59:55 <zygoloid> preflex: seen MarcWeber
08:59:56 <preflex>  MarcWeber was last seen on #haskell 3 days, 16 hours, 26 minutes and 54 seconds ago, saying: ?where fps
09:00:12 <ColonelJ> preflex: seen preflex
09:00:13 <preflex>  what
09:00:20 <stulli> ah, thx zygoloid
09:12:25 <maurer_> Out of curiosity, is there a reason why some function like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14360#a14360 isn't in the haskell libraries?
09:12:30 <maurer_> (or is it, and I just can't find it)
09:12:58 <maurer_> I mean, it occasionally needs a few more types than one might like, but other than that it works fine.
09:13:03 <aavogt> @hoogle everywhere
09:13:04 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
09:13:04 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
09:13:04 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
09:14:34 <aavogt> though that's not entirely the same, since as far as I can tell you can't change the type of the data you modify when you use syb
09:15:06 <maurer_> That is what it looks like, also unless I'm mistaken (reading source now) I didn't think Syb handled nesting
09:15:23 <maurer_> Nevermind, it does
09:16:53 * hackagebot upload: pointless-haskell 0.0.3 - Pointless Haskell library (HugoPacheco)
09:17:14 <Veinor> I just sped up one of my algorithms by 16-fold \o/
09:17:21 <Nafai> Veinor: Yay!
09:17:34 <xerox> you bought a 16-core machine? :D
09:17:40 <Veinor> well, not that much, but a significant improvement
09:17:40 <Veinor> :P
09:17:55 * hackagebot upload: pointless-lenses 0.0.2 - Pointless Lenses library (HugoPacheco)
09:19:17 <maurer_> Um, I'm an idiot and can't see how to call everywhere properly
09:19:56 <deech> Hi all, I have a question about 6.12's dynamic loading. Does this mean that I can write Haskell code that can be plugged in at run-time?
09:20:03 <Veinor> hm. I think I should export an explicit Int -> Nimber rather than rocing people to use fromInteger :: Integer -> Nimber
09:20:40 <xerox> What is a Nimber? Does it have anything to do with the game of Nim?
09:21:00 <Veinor> yes, actually
09:21:03 <Jafet> A little bit
09:21:15 <Veinor> normal nim, not misere nim
09:21:33 <Veinor> I don't feel like implementing misere nim-arithmetic, because it's very ugly :(
09:21:37 <Jafet> Only losers care about misere games
09:21:57 <Veinor> Exactly :D
09:23:52 <Jafet> Surreal numbers are much more beautiful
09:24:10 <Veinor> hm, only a 6-fold increase. still :D
09:24:30 <Veinor> Jafet: basically, I'm trying to figure out how to compute the nim-reciprocal of *n
09:24:39 <Veinor> in an efficient way, mind.
09:25:06 <Jafet> Where *n is a nimber?
09:25:12 <Veinor> yeah.
09:25:24 <Veinor> basically, given *n, find *m such that *m * *n = 1
09:25:32 <Veinor> (for finite nimbers; I don't even want to think about transfinites)
09:26:37 <Jafet> Perhaps you should ask #math
09:26:46 <Jafet> And put them out of the idiot mode zygoloid set there
09:26:55 <Veinor> oh god
09:27:08 <Veinor> what happened?
09:27:43 <Jafet> http://hackage.haskell.org/packages/archive/nimber/0.1/doc/html/Data-Nimber.html this you?
09:27:47 <Veinor> yep
09:28:18 <Jafet> Nimbers are not GF(2^2^n), eh?
09:28:32 <Veinor> I think the set of all nimbers less than GF(2^2^n) are
09:28:47 <Veinor> 's what wikipedia says :P
09:28:57 <Jafet> Nope, look at the tables
09:28:59 <mrsolo> is import System.Log.Logger
09:28:59 <mrsolo>  commonly used for logging? or there is something else better?
09:29:22 <Veinor> Jafet: explain?
09:29:36 <roconnor> I <3 pattern matching at top level bindings!
09:29:46 <Veinor> I mean obviously nimbers as a whole aren't a finite field
09:29:54 <Veinor> but the nimbers less than 2^2^n for any fixed n are.
09:31:19 <Jafet> No, look at the table
09:31:29 <Veinor> specifically?
09:31:33 <Jafet> It says that *3 x *2 is *1
09:31:42 <Veinor> right.
09:31:59 * hackagebot upload: failure 0.0.0.1 - A simple type class for success/failure computations. (MichaelSnoyman)
09:32:14 <Veinor> do you not think that *0, *1, *2, *3 form a field?
09:32:47 <Jafet> 3 x 2 is not 1 in GF(4)
09:32:59 * hackagebot upload: convertible-text 0.2.0 - Typeclasses and instances for converting between types (MichaelSnoyman)
09:33:25 <EvanCarroll> why doesn't this work scanl (\ acc (x:xs) -> if x == '#' then "HI" ++ acc else acc ) [] "###"
09:33:41 <Veinor> well, just from what I'm reading and my limited knowledge, all finite fields of a given size are the same
09:33:42 <Jafet> You're confusing that the nimbers form a field, with the notion that the first n nimbers may form a finite field.
09:34:00 <xerox> EvanCarroll: \ acc x ->
09:34:05 <Veinor> the first 4 nimbers do form a field though :/
09:34:14 <Jafet> Yes. The addition and multiplication tables given in the article don't look like they are of a field.
09:34:27 <roconnor> @hoogle trim
09:34:27 <EvanCarroll> xerox: how do i pattern match to get the first character of the string?
09:34:28 <lambdabot> Data.ByteString.Internal createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString
09:34:28 <lambdabot> Data.ByteString.Internal createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
09:34:31 <Veinor> why not?
09:34:32 <EvanCarroll> oh wait
09:34:33 <EvanCarroll> i see
09:34:37 <EvanCarroll> it already just a character
09:34:40 <xerox> right
09:35:12 <Veinor> it looks to satisfy the field axioms
09:35:23 <Jafet> Oh, you're right Veinor
09:35:29 <Jafet> I read it again
09:35:34 <Veinor> yeah.
09:36:48 <Veinor> clearly all I need to do is solve the discrete log problem and then I'm good
09:37:01 <roconnor> > unwords . words  $ "  hello  "
09:37:03 <lambdabot>   "hello"
09:37:07 <Jafet> No, the DLP is unrelated
09:37:07 <roconnor> :D
09:37:40 <Jafet> According to Wikipedia, you can just use extgcd
09:38:05 <Veinor> extgcd?
09:38:17 <Jafet> http://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplicative_inverse
09:38:44 <Veinor> ... ah hell.
09:38:52 <Veinor> I feel stupid now.
09:38:57 <Jafet> Makes sense to me.
09:39:36 <Veinor> but apparently I need to study representation of finite fields as polynomials.
09:40:23 <Veinor> now I just need to turn that into Haskell
09:40:36 <Jafet> Polynomials should be easy in Haskell
09:40:50 <Jafet> Just start plugging into Num
09:41:06 <Jafet> @hoogle polynomial
09:41:07 <lambdabot> No results found
09:41:10 <Veinor> Jafet: I mean I don't know the theory behind it
09:42:09 <roconnor> in parsec how do I get all characters upto but not including the string "</" ?
09:42:17 <Veinor> plus it's harder since I'd have to dynamically generate a polynomial of degree 2^n irreducible in GF(2)
09:42:39 <Jafet> Consider bitstrings
09:42:57 <Jafet> Bitstrings with bitwise operations is arithmetic in GF(2^n)
09:43:05 <Veinor> what's bitwise multiplication?
09:43:08 <sproingie> roconnor: take a look at xml-parsec
09:43:11 <Veinor> :P
09:43:17 <Jafet> and
09:43:25 <Veinor> yeah, but x * x != x
09:43:26 <roconnor> sproingie: I don't have xml
09:43:38 <roconnor> sproingie: I have tagsoup ...
09:43:44 <sproingie> mm fun
09:43:56 <Jafet> Hum? 0 x 0 = 0 and 1 x 1 = 1
09:44:05 <Veinor> that's only in GF(2)
09:44:29 <Veinor> in GF(2^n), multiplication of polynomials != anding their bitstrings
09:44:35 <Jafet> Well yes, you'll need to invent multiplication
09:44:50 <Jafet> Just throwing around analogies
09:44:59 <ystael> i was gonna say, suddenly X^2 - X has 2^n roots??? :)
09:45:17 <xerox> What you mean by suddenly?
09:46:35 <Veinor> blehh. I think I'd have to learn a bunch of crap to get this to work properly
09:47:12 <ystael> xerox: not sure i understand
09:47:17 <Veinor> although I did notice that if 2^2^n < a < 2^2^(n-1) and b < a, then *a x *b = *(a * b)
09:47:24 <xerox> roconnor: manyEndBy (string "</")  manyEndBy1  manyTill
09:47:33 <Jafet> http://www.springerlink.com/content/k6787424661655v3/ hrm
09:47:39 <xerox> ystael: misread
09:48:04 <Veinor> er, hmm, that's not right at all
09:48:28 <ystael> xerox: ah, ok.  for a moment there i thought my stupidity-of-age was marching faster than i had known.  :D
09:48:36 <Veinor> nevermind, multiplication is hard
09:48:39 <Jafet> For one thing, 2^2^n /< 2^2^(n-1)
09:48:56 <Veinor> :P
09:48:57 <xerox> ystael: I though the degree matched, nevermind :)
09:49:43 <gwern> :t otherwise
09:49:45 <lambdabot> Bool
09:49:47 <gwern> I wonder why we use 'otherwise' instead of 'else'
09:49:56 <Jafet> Because else is a keyword.
09:50:06 <Jafet> It's part of the if syntax
09:50:25 <Jafet> ...actually, nevermind
09:50:44 <xerox> > let else = True in else
09:50:45 <Veinor> > otherwise
09:50:45 <lambdabot>   <no location info>: parse error on input `else'
09:50:46 <lambdabot>   True
09:51:14 <Veinor> so otherwise is always true, huh? :P
09:51:16 <roconnor> xerox: I got "manyTill anyChar (try (string postfix))" to work
09:51:22 <ystael> Veinor: I seem to remember that Ireland & Rosen, A classical introduction to modern number theory, has an accessible treatment of finite fields, and you don't have to slog through the whole Galois theory chapter of an algebra text to get through it
09:51:23 <roconnor> xerox: but I don't understand why I need the try in there
09:51:33 <tavelram> @src otherwise
09:51:34 <lambdabot> otherwise = True
09:51:37 <gwern> Jafet: if there's no if in the guard, why can't it be both?
09:51:50 <gwern> it's not like '|' isn't syntax on its own...
09:51:50 <Jafet> Indeed
09:51:53 <xerox> roconnor: this way the check for the end token doesn't consume the input
09:52:10 <Jafet> Well, I have no idea then. otherwise is also syntax, in any case
09:52:14 <zygoloid> gwern: i've always found it quite nice that otherwise was just defined as True :)
09:52:19 <Jafet> > let otherwise = False in otherwise
09:52:20 <lambdabot>   False
09:52:24 <gwern> Veinor: as a woman can tell you, there's always an otherwise!
09:52:26 <Jafet> Er
09:52:48 <Jafet> > let otherwise = False in case 1 of otherwise -> 1; _ -> 2
09:52:49 <lambdabot>   1
09:53:04 <Jafet> I always found that weird.
09:53:13 <roconnor> xerox: oh it does't consume the input *if* an error occurs.
10:02:22 <Philonous> > let otherwise = False in otherwise
10:02:23 <lambdabot>   False
10:02:37 <lament> > False
10:02:39 <lambdabot>   False
10:02:42 <Philonous> Oh, 10 minutes too late
10:02:57 <lament> @src otherwise
10:02:57 <lambdabot> otherwise = True
10:02:59 <Jafet> 15 too early.
10:06:10 * hackagebot upload: data-object 0.2.0 - Represent hierachichal structures, called objects in JSON. (MichaelSnoyman)
10:06:12 * hackagebot upload: data-object-json 0.0.0 - Serialize JSON data to/from Haskell using the data-object library. (MichaelSnoyman)
10:07:14 * hackagebot upload: data-object-yaml 0.0.0 - Support for serialising Haskell to and from Yaml. (MichaelSnoyman)
10:07:16 * hackagebot upload: json2yaml 0.2.2 - Utility to convert a file from JSON to YAML format. (MichaelSnoyman)
10:08:31 <Gracenotes> :X
10:08:43 <mrsolo> ok same line of question is HSH commonly used? or there is something else better?
10:12:16 <aconbere> is there anyway to self bootstrap the haskell binary?
10:12:31 <aconbere> if you don't have access to a pre-existing haskell binary
10:12:40 <aconbere> to build one to build the full version of haskell?
10:13:33 <Baughn> aconbere: You mean ghc?
10:14:15 <Baughn> aconbere: It is just about possible, via much work, to cross-compile GHC part of the way to a point where it no longer needs an installed GHC to finish the job. That's how porting to new platforms work.
10:14:16 <aconbere> did I say haskell?
10:14:21 <aconbere> cuase I meant ghc
10:14:35 <aconbere> Baughn: heh
10:14:41 <Baughn> GHC is mostly written in Haskell. It needs a GHC binary /somewhere/.
10:15:03 <Baughn> ..the original version probably ran in an interpreter. :P
10:15:07 <aconbere> will it compile from a minimal haskell that isn't ghc?
10:15:13 <Baughn> Not anymore.
10:15:14 <aconbere> like hugs?
10:15:15 <aconbere> heh
10:15:15 <aconbere> k
10:15:48 <Baughn> (But don't quote me on that. I consider it overwhelmingly likely, but don't have an explicit statememnt to that effect.)
10:15:56 <aconbere> Baughn: they have the mkpkg stuff, and the platform stuff
10:16:03 <aconbere> but neither of those breaks out a plain binary
10:16:10 <aconbere> if they did this wouldn't be so hard :-/
10:16:15 <Baughn> aconbere: Why do you ask?
10:17:16 <aconbere> A week or so ago I moved from macports to homebrew
10:17:26 <aconbere> and I've been building whatever formula's I need
10:17:34 <aconbere> haskell was on the list
10:17:37 <aconbere> but it gave me hell
10:17:40 <aconbere> ghc
10:17:49 <aconbere> man I'm not doing a good job of that today
10:18:03 <Baughn> Yeah. You should download a binary, and use that to bootstrap it.
10:18:10 * aconbere nods
10:18:14 <aconbere> that's what I did
10:18:17 <Baughn> Compiling ghc without ghc makes about as much sense a compiling gcc without gcc
10:18:53 <aconbere> yeah but ghc apparently doesn't have "the super generic x86 ghc with no aditions"
10:18:56 <aconbere> :)
10:19:40 <Baughn> No, but it does have an osx-specific ghc. :P
10:19:57 <Baughn> Er.. you /are/ still running OS X, right?
10:20:04 <aconbere> heh
10:20:04 <aconbere> yes
10:20:20 <aconbere> but I couldn't find an os x ghc that wasn't packaged in a dmg or a mkpkg
10:20:26 <aconbere> other than the community provided one
10:20:36 <Baughn> Well, use the community provided one.
10:20:41 <aconbere> I'm fine with that
10:20:53 <aconbere> but I wouldn't feel comfortable passing that back up to the homebrew community
10:23:10 <aconbere> anyway, I'll poke around a bit.
10:23:30 <Vulpyne> Hmmm. When using Parsec with ByteStrings, the combinators result in normal strings that I have to pack if I want a ByteString? Or am I doing something wrong...
10:23:32 <aconbere> I might just do a check to see if you have ghc available and otherwise tell you to install it
10:23:41 <aconbere> Baughn: thanks a bunch for the help (really)
10:23:51 <emile_m> Can someone explain this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14362 ? How can I deal with impredicative types then?
10:24:03 * Baughn gets stuck in cyclic module hell
10:25:03 <Baughn> aconbere: So, what you want is to use the community-provided one to compile another one that fits your needs, right?
10:25:27 <roconnor> Baughn: cyclic modules are perfectly fine Haskell :D
10:25:28 <dolio> emile_m: forall a. Ord a => a is the type of values that can take on any type that is in the Ord class.
10:25:43 <aconbere> Baughn: yeah, but I don't know anything about how much bandwidth his server has, or you know anything about where he's at
10:25:44 <dolio> And I think the only example of that is bottom.
10:25:54 <aconbere> I guess I could go ask him :P
10:25:55 <Baughn> roconnor: True, but not perfectly find GHCskell.
10:25:59 <Vulpyne> Is there something other than Parsec I should use if I don't want to work with [Char] at all?
10:26:59 <Baughn> Vulpyne: Parsec-3 handles bytestrings fine, and has gotten a lot faster lately.
10:27:00 <emile_m> dolio: Yeah, but Int and Char have an Ord instances, aren't they?
10:27:05 <dolio> What you want is exists a. Ord a => a, but that isn't a first-class type in GHC. You need to write a wrapper like "data EOrd = forall a. Ord a => EOrd a", or "data EOrd where EOrd :: forall a. Ord a => a".
10:27:24 <Vulpyne> Baughn: : Parsec3 is what I'm using. It seems like it consumes ByteStrings fine, but a combinator like many actually produces [Char].
10:27:30 <byorgey> with the GADT syntax you don't even need the forall
10:27:43 <Baughn> Vulpyne: Okay. What are you parsing?
10:27:44 <byorgey> "data EOrd where EOrd :: Ord a => a"  ought to work
10:27:51 <Vulpyne> Baughn: SIP packets at the moment.
10:27:52 <ColonelJ> When I load a module after loading a program it doesn't keep anything loaded...?
10:27:57 <Baughn> Vulpyne: Serialize or Binary should be fine
10:27:58 <deech> Hi all, I was reading the Release Notes for 6.12 this morning and was confused about the dynamic linking allowing the programmer to make dynamic plugins that can be used in other applications. Can I now write Haskell code that can be plugged in at run-time?
10:28:03 <Vulpyne> Baughn: I'm trying to convert a String parser to ByteString for better efficiency.
10:28:05 <Baughn> Vulpyne: Excuse me. Cereal or Binary.
10:28:05 <dolio> Yes, they are. But the elements are supposed to be able to become any Ord type. Not to be some particular, unknown Ord type, for the universal quantified type.
10:28:10 <byorgey> ColonelJ: don't load the module, use  :m +ModuleName
10:28:18 <Vulpyne> Baughn: SIP packets are a text format, fairly similar to HTTP.
10:28:25 <byorgey> ColonelJ: or is that what you meant?
10:28:27 <Baughn> Vulpyne: HTTP is a binary format
10:28:42 <ColonelJ> byorgey: thanks that worked
10:28:44 <xerox> Vulpyne: what should it return instead?
10:28:44 <Vulpyne> Baughn: You know what I mean. :)
10:28:46 <Baughn> Vulpyne: Whatever they claim.. there are restrictions on use that make it something other than haskell.
10:28:51 <Baughn> Vulpyne: Er. Other than ascii.
10:28:53 <Vulpyne> xerox: A ByteString.
10:29:05 <Baughn> Vulpyne: Yeah, I know. Cereal would still be fast.
10:29:23 <Vulpyne> Baughn: I'll look at it, but I'll have to completely rewrite the parser. :(
10:29:28 <byorgey> deech: it's not about dynamic run-time plugins
10:29:46 <HaskellLove> Must all recursive functions be binary? Can you have unary function and still do recursion? Recursion implies operating on current element based on "so far" result of recursion process, which means it needs two things to operate on, current element and ... you get the point. Conclusion: In Haskell if you want recursive function it has to be binary? What if you end up with unary function, can...
10:29:47 <xerox> Vulpyne: I'd love if you could write down the right definition of many
10:29:49 <HaskellLove> ...you do recursion over lists with it?
10:29:57 <byorgey> deech: it's just that libraries now don't have to be statically linked, they can be dynamically linked at runtime, so executables can be smaller
10:30:02 <Baughn> Vulpyne: Performance does that. The /reason/ cereal is fast is its extreme limitations on what you can do.
10:30:10 <Vulpyne> xerox: By "right", you mean what I was expecting?
10:30:13 <byorgey> deech: but your code still has to know about the libraries.
10:30:18 <aavogt> > let one = 1 : one in one -- one has no arguments
10:30:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:30:20 <Vulpyne> xerox: B.pack `fmap` many -- :)
10:30:32 <byorgey> deech: you CAN have dynamic plugins, but that's a different story
10:30:33 <aavogt> HaskellLove: ^^
10:30:39 <SamB_XP_> HTTP is a binary protocol that, thankfully, has all the control-information in an ASCII-legible form
10:30:49 <EvanR-work> HaskellLove: all haskell functions take one argument anyway
10:30:58 <emile_m> dolio: Thanks. Enlightment had come.
10:31:06 <dolio> Good. :)
10:31:31 <deech> byorgey: the wording "dynamic plugins from Haskell code that can be used from other applications" is somewhat confusing! Is there a dynamic-plugin library that is still supported?
10:31:44 <xerox> Vulpyne: I'm not sure that's what you want, it should just chose 'many' depending on the Stream s used, I think there's a class for that. And then today's many becomes the one for [] Char, and yours for ByteString, and maybe if you have time one for Lazy ByteString is also needed :)
10:31:48 <byorgey> deech: I agree, that wording is confusing, especially the word "plugins"
10:32:02 <byorgey> deech: I'm not entirely sure, maybe try hint
10:32:32 <emile_m> BTW, this one (with record syntax) cannot be expressed with GADT's. They can't decide about some syntax stuff :)
10:32:42 <Vulpyne> xerox: Its behavior makes sense given the function definition: many1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]
10:32:47 <deech> byorgey: Hmm... interesting. Thanks!
10:33:05 <Vulpyne> xerox: So it's parsing a ByteString as a stream, resulting in a token type of Char. So many returns a list of the tokens.
10:33:18 <Vulpyne> xerox: Which is a String.
10:33:21 <xerox> Vulpyne: OK
10:33:27 <Vulpyne> I just don't like it!
10:33:49 <dolio> emile_m: If I recall correctly, 6.12 might actually have GADT records of some sort. But I don't remember what the restrictions are.
10:33:54 <Vulpyne> I wonder if converting this parser will still increase performance when I have to re-pack everything as a bytestring. It makes me sad.
10:34:19 <emile_m> ... and yet another question: Where I can find some code with syb generics in use?
10:35:26 <xerox> Vulpyne: if you see the definition of many1 it's very very easy to adapt
10:35:39 <Vulpyne> xerox: That was just one example.
10:35:48 <HugoDaniel> hi
10:35:51 <Vulpyne> xerox: Yeah, I could rewrite all the combinators I use... I don't really want to though.
10:35:58 <HugoDaniel> is there any strong random number generator for haskell !?
10:35:59 <HaskellLove> EvanR-work: I have 2d matrix. I have a function that operates on a list and creates a new list based on the values of the first list and the values in the list below it (Euler 18). I have 15 rows. I start with row 14 and go up. Is it posible, my function to be recursive? As i said in short, operates on list 14 based on values in list 15, creates a new list in place of 14, and then the...
10:36:00 <HaskellLove> ...function is applied to row 13, does its calculation based on values in new list instead of 14 (the one from previous computation) and changes values of 13 row, that is creates new list, and goes to row 12 and so on and on untill row 2
10:36:19 <xerox> Vulpyne: what I was suggesting is that if you were up to, it could make a valuable contribution.
10:36:34 * Baughn falls in love with Data.Generics
10:36:35 <emile_m> dolio: Yes, It is possible in 6.12. I've just peeked in release notes. Hoorah!
10:36:50 <xerox> Baughn: me too. Although I have one problem :)
10:37:09 <Baughn> HugoDaniel: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14363#a14363 <-- Blatant self-promotion
10:37:16 <roconnor> > foldl f x [a,b,c]
10:37:16 <HugoDaniel> :D
10:37:17 <lambdabot>   Ambiguous occurrence `x'
10:37:17 <lambdabot>  It could refer to either `L.x', defined at <local...
10:37:17 <Vulpyne> xerox: Ah... Well, I don't really have time right now. :( I shouldn't even be working on this project right now.
10:37:18 <Baughn> I really should put that on hackage soon.
10:37:22 <HugoDaniel> :D
10:37:22 <roconnor> @undef
10:37:24 <roconnor> > foldl f x [a,b,c]
10:37:25 <lambdabot>   f (f (f x a) b) c
10:37:28 <xerox> Vulpyne: OK.
10:37:31 <HugoDaniel> i need that to generate "sessions" in a site im working on
10:37:43 <Baughn> HugoDaniel: Generating session keys is exactly what I use that for.
10:37:48 <HugoDaniel> :D
10:37:53 <Vulpyne> xerox: Do you think it would actually increase performance significently?
10:37:58 <HugoDaniel> we're in sync then
10:38:12 <Vulpyne> Using a lot of ByteString.cons or whatever, I would assume, when building the result.
10:38:18 <Baughn> HugoDaniel: But take care, it isn't on hackage yet because I haven't gone over it with a fine-toothed comb.
10:38:20 <EvanR-work> HaskellLove: yes its possible, you have to do recursion to do loops, if at least using a higher order function
10:38:32 <xerox> Vulpyne: it all depends on the use, in a wonderful world were we have time to do this, we would also roll out some tests and see how it performs :-)
10:38:50 <HugoDaniel> no problem, this is for a small thing right now
10:38:57 <Baughn> Also, it's kinda inefficient.
10:39:06 <xerox> Vulpyne: on one hand GHC is smart, so it optimizes our code; on the other hand he also like suggestions :-)
10:39:07 <Baughn> Well, you should be fine.
10:39:22 <HaskellLove> EvanR-work>	I am close to solving euler 18 i have writen the function for one list, being new to functional, i find it hard how to loop it for all lists while acumulating result... so i paused the problem i read book now
10:39:31 <xerox> Baughn: have you ever used Generics in the context of json ?
10:39:43 <Baughn> xerox: I used generics for the first time fifteen minutes ago.
10:39:55 <xerox> Baughn: OK :^)
10:39:59 <glguy> Anyone familiar enough with the iteratee library to help me figure out what an EnumeratorN for converting streams of Char to streams of Word8 (using base 64) would look like?
10:40:00 <EvanR-work> HaskellLove: sounds like fold to me
10:40:07 <EvanR-work> but i am relatively new too
10:40:50 <HaskellLove> EvanR-work> yes it must be fold... but... will get back at the problem tomorow i might get insights from the book
10:41:12 <Baughn> xerox: Fifteen minutes, and six lines saved. :3
10:41:32 <xerox> Baughn: and something learned, I gather :)
10:41:53 <Stinger> you spent or saved 15 mins?
10:42:14 <Baughn> xerox: Yeah. Although, what I really want isn't 'fromJust . gfindtype', it's 'gnth 0'
10:42:26 <Baughn> Stinger: Spent. I imagine I'll make it up quickly. :P
10:52:35 <Baughn> Hum. So, apparently the master spark is love-colored. :P
10:52:40 <DigitalKiwi> does haskell do proper tail call recursion?
10:52:57 <lament> DigitalKiwi: in a lazy language, it's hard to tell
10:53:08 <Baughn> DigitalKiwi: Yes, but not the way you think
10:53:39 <Baughn> DigitalKiwi: There are two stacks. The /visible/, lexical one you'd expect from your code, in fact exists on the /heap/.
10:53:40 <EvanR-work> i asked this question a few days ago. mainly i wanted to know if we should even bother putting recursive calls at the end
10:53:52 <Baughn> DigitalKiwi: So it's subject to full garbage-collection
10:54:35 <Baughn> There's also the thunk evaluation stack, which is used to evaluate nested thunks - that uses traditional tail-call elimination.
10:55:34 <DigitalKiwi> tail-call elimination?
10:55:40 <zygoloid> a reasonable rule of thumb is: tail recurse only if your domain contains no partially-bottom values
10:56:14 <zygoloid> but even that's far from correct
10:57:12 <Vulpyne> xerox: Looking at the source for some of the combinators, changing it would be relatively complex.
10:57:40 <xerox> Vulpyne: I also have skimmed them, what exactly?
10:58:00 <Vulpyne> xerox: For example http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/src/Text-Parsec-Prim.html#many
10:58:06 <Vulpyne> xerox: many defined in terms of manyAccum.
10:58:11 <xerox> yes
10:58:17 <Vulpyne> xerox: manyAccum would have to be rewritten too.
10:58:27 <Vulpyne> Pretty much every combinator would have to be.
10:59:27 <xerox> Vulpyne: manyAccum takes an accum function
11:00:00 <Vulpyne> xerox: a -> [a] -> [a]
11:00:13 <HaskellLove> Does F# pipelining operator (|>) has any advantage, does something that can't be done in Haskell or it is just syntactic sugar for higher-order functions?
11:00:13 <DigitalKiwi> let me put it this way then, is it possible to do recursive tail calls safely? (not overwhelming the stack etc)
11:00:15 <Jafet> Stack?
11:00:25 <Jafet> (Baughn)
11:00:49 <Vulpyne> xerox: Since the point would be to make it not use strings, the manyAccum function would have to become more general.
11:00:51 <zygoloid> HaskellLove: isn't (|>) just flip ($)?
11:00:57 <Vulpyne> Or just plain be rewritten for ByteString.
11:01:07 <Baughn> Jafet: What about it?
11:01:18 <xerox> Vulpyne: either that, or adding some new things like manyS which return a Stream
11:01:26 <Baughn> Jafet: It's not just a stack, it's a straight-up /C/ stack
11:01:27 <Jafet> Which implementation(s) of Haskell were you talking about?
11:01:32 <Baughn> GHC
11:01:45 <Vulpyne> xerox: Yeah... I find it strange that such support doesn't already exist in some form.
11:01:59 <HaskellLove> zygoloid> let squared =
11:02:01 <HaskellLove>    numbers
11:02:03 <HaskellLove>    |> List.filter isOdd
11:02:03 <Jafet> (Admittedly, I suppose there is no other implementation of Haskell)
11:02:04 <HaskellLove>    |> List.map square
11:02:06 <HaskellLove> It carries result from previous operation, does something and passes on...
11:02:07 <EvanR-work> DigitalKiwi: from what ive seen you should worry about recursively defined stuff
11:02:18 <xerox> Vulpyne: what to implement exactly isn't an easy question
11:02:27 <EvanR-work> DigitalKiwi: should not
11:02:48 <jmcarthur> Jafet: what do you mean no other implementation?
11:02:51 <Jedai> HaskellLove: right, it's just "flip ($)"
11:03:04 <Baughn> flip id, for great confusion.
11:03:05 <Jedai> HaskellLove: you can define it in Haskell easily
11:03:52 <Jafet> @check flip ($) == (|>)
11:03:52 <lambdabot>   Not in scope: `|>'
11:04:02 <HugoDaniel> how do i extend a Word8 to a Word64 ?
11:04:09 <Jafet> @check flip ($) == flip id
11:04:10 <lambdabot>   No instance for (GHC.Classes.Eq (b -> (b -> c) -> c))
11:04:11 <lambdabot>    arising from a use...
11:04:15 <xerox> HugoDaniel fromIntegral
11:04:15 <Baughn> HugoDaniel: fromIntegral
11:04:21 <HugoDaniel> thanks :)
11:05:22 <HaskellLove> Jedai> Can you explain me more about the flip analogy? But basically it is syntactic sugar for higher order functions right?
11:06:07 <Jedai> HaskellLove: no, it's just an operator, that is a function with two arguments but a name only constituted of symbol so that its normal use is infix instead of prefix
11:06:39 <patch-tag> why doesn't this typecheck?
11:06:42 <patch-tag> t' :: (Error e, Monad m) => ( m a -> ErrorT e m a) -> m (Either e a)
11:06:42 <patch-tag> t' lifter = runErrorT $ ( lifter  $ return "ok" :: ErrorT String IO String)
11:06:43 <Jafet> @src flip
11:06:43 <lambdabot> flip f x y = f y x
11:06:44 <Jedai> HaskellLove: In other words, defining (|>) in Haskell would be as simple as writing "x |> f = f x"
11:07:04 <Jedai> HaskellLove: or "(|>) = flip ($)"
11:07:26 <EvanR-work> so, syntactic sugar for function application
11:07:47 <Jedai> > let x |> f = f x in 5 |> (^2)
11:07:48 <lambdabot>   25
11:08:04 <Jafet> Syntactic sugar for parentheses
11:08:07 <Jedai> EvanR-work: it is _not_ syntactic sugar, that's the point
11:08:09 <Jafet> It's like antilisp
11:08:22 <EvanR-work> yeah its just a function
11:08:32 <Jedai> Right
11:08:32 <Jafet> No, it's an operator.
11:08:44 <Jedai> Jafet: an operator _is_ a function
11:08:54 <Jafet> Not syntactically!
11:08:55 * EvanR-work does a double take
11:08:57 <Jedai> Jafet: with a funny name
11:09:06 <EvanR-work> there are two J guys talking
11:09:16 <EvanR-work> how long as that been going on
11:09:36 <Jafet> "Who are you?" "I am The Boss." "I thought he was The Boss." "Why? Do we look alike?"
11:09:50 <opqdonut> lucky number slevin <3
11:10:06 <xerox> patch-tag: lifter?
11:10:07 <hydo> Can anyone here familiar with Hack or Happstack know of an easy way to specify which address to listen on?
11:10:13 <patch-tag> xerox: it's an argument
11:10:19 <hydo> opqdonut: yea, agreed.  that was an awesome movie.
11:10:23 <Jedai> Jafet: syntactically, the only difference is one type is normally used infix (operator) while the other is used prefix (alphanum functions) but both can be used as the other with the proper syntax and underneath they're just functions
11:10:23 <xerox> patch-tag: oops.
11:10:25 <patch-tag> basically, I'm experimenting with rewriting lift
11:10:43 <sproingie> operators also have fixity
11:11:03 <HaskellLove> I am reading book on F# and C#, so far only difference F# vs Haskell seems, F# has advantage because it is part of the .NET framework so you can have oop too and what not...
11:11:06 <xerox> :t \f -> runErrorT . f . return $ "ok"
11:11:07 <lambdabot> forall e (m :: * -> *) a (m1 :: * -> *). (Monad m1) => (m1 [Char] -> ErrorT e m a) -> m (Either e a)
11:11:29 <sproingie> HaskellLove: if you consider the API for the .NET framework an advantage
11:11:49 <sproingie> if that's the only difference you've noticed, you haven't actually looked at F# code
11:11:50 <Jafet> F# doesn't have Hackage, Cabal, parsec, ghc, or you in their IRC channel
11:11:58 <Jafet> I guess the latter is a plus point though
11:12:07 <hydo> haha
11:12:08 <EvanR-work> snap
11:12:29 <Jedai> HaskellLove: the advantage is that you have access to all the .NET world... the main disadvantage is that you have access to this impure .NET world
11:12:56 <dpratt71> HaskellLove: as a veteran of C#/.NET (if one can be such) and knowing something of F#, I'd say that Haskell has many advantages compared to those technologies
11:12:57 <sproingie> the impurity of the .NET world doesn't bother me.  opengl is also a big ol impure state machine
11:13:10 <orbitz> beign part of .net is orthogonal to F# having OOP
11:13:15 <sproingie> what bothers me is how crazy slapdash big parts of it are
11:13:22 <xerox> patch-tag: so I guess the problem is that you want  m String  and not  m a  as the argument of lifter.
11:13:23 <Jafet> patch-tag, it seems somehow your type a is being inferred as String
11:13:26 <Jedai> sproingie: Right, but the Haskell interface for it show this in its type, not so in .NET
11:13:32 <patch-tag> "Couldn't match expected type `a' against inferred type `[Char]'; `a' is a rigid type variable bound by the type signature for `t'' ...... "
11:13:47 <patch-tag> I've never understood what the hell that means
11:13:48 <Jafet> Well, you knew that.
11:14:06 <xerox> which is kind of obvious, because you feed lifter the action  return "ok"
11:14:21 <Jedai> sproingie: Right, well I think a lot of the crazy weirdness of the type system and other is related to the need to accomodate .NET point of view, so one is somehow linked to the other
11:14:28 <patch-tag> a is "any type", right? so I should be able to restrict it further in
11:14:44 <HaskellLove> I would not say .NET would be a minus for F#
11:14:47 <xerox> patch-tag: a has an implicit forall, and lifter doesn't work forall a.
11:15:14 <orbitz> HaskellLove: having to deal wtih null pointers is just lame
11:15:17 <dpratt71> I'm quite looking forward to the parallel extensions coming in .NET 4.0, but I forsee problems because there is nothing in the .NET type system that can be used to enforce functional purity
11:15:19 <Jedai> HaskellLove: I said it was both an advantage AND a disadvantage
11:15:30 <xerox> patch-tag: that is, the type signature is *the* type of the function.
11:15:40 <orbitz> HaskellLove: for many people here, being bound to Win32 is likely a minus for F#
11:16:01 <patch-tag> xerox: eh?
11:16:03 <Jafet> I like stereo.
11:16:12 <roostaj> , time $ take 50000 $ scanl1 (+) [1..]
11:16:17 <lunabot>  (0.0,[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231...
11:16:29 <Vulpyne> Hmm. Is there an efficient way to convert a Char8 ByteString to a Word8 ByteString?
11:16:30 <patch-tag> so  can I make a into a placeholder-type variable that will hold for any type?
11:16:52 <Jafet> patch-tag, can t' accept IO Int?
11:16:56 <Jedai> HaskellLove: and it is, sure from the developer point of view having access to all these .NET resources is nice, but on the other hand, if he use a Functional language it might be because he wants some of the advantages of the paradigm, and having .NET in its language just throw a lot of mud in the water from this point of view
11:16:59 <xerox> patch-tag: don't feed it a value of type  m String  and it'll accept other things
11:16:59 <HaskellLove> orbitz as far as I know you can have F# on Ubuntu...
11:17:26 <Jedai> orbitz: you can use Mono, at least for some version of F#
11:17:37 <sproingie> @quote f#
11:17:37 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
11:17:39 <roostaj> , time $ take 50000 $ let triangleNumber n i = n:triangleNumbers (n + succ i) (succ i) in take 50000 $ triangleNumbers 1 1
11:17:39 <lunabot>  luna: Not in scope: `triangleNumbers'
11:17:40 <HaskellLove> Jedai, but how often in real world would you need ONLY pure functional ?
11:17:41 <patch-tag> Jafet: no, it shouldn't be able to accept IO INt
11:17:46 <Jafet> F# is from MSR, isn't it? That's pretty much the nail in the coffin
11:17:50 <roostaj> , time $ take 50000 $ let triangleNumbers n i = n:triangleNumbers (n + succ i) (succ i) in take 50000 $ triangleNumbers 1 1
11:17:52 <lunabot>  (0.0,[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231...
11:17:57 <Jafet> patch-tag, yet the type signature wants to allow it
11:18:05 <sproingie> Jafet: guess who primarily develops haskell?
11:18:07 <roostaj> , time $ take 1000000 $ scanl1 (+) [1..]
11:18:09 <lunabot>  (0.0,[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231...
11:18:11 <dpratt71> HaskellLove: that depends on whether you believe parallel programming is the future
11:18:19 <eivuokko> Jafet, What's your point?  The GHC HQ is at MSR.
11:18:21 <roostaj> , time $ take 1000000 $ let triangleNumbers n i = n:triangleNumbers (n + succ i) (succ i) in take 50000 $ triangleNumbers 1 1
11:18:23 <lunabot>  (0.0,[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231...
11:18:28 <patch-tag> IO Int agrees with ( m a -> ErrorT e m a)    ?
11:18:31 <roostaj> oops
11:18:42 <roostaj> , time $  let triangleNumbers n i = n:triangleNumbers (n + succ i) (succ i) in take 1000000  $ triangleNumbers 1 1
11:18:44 <lunabot>  (0.0,[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231...
11:18:46 <Jafet> patch-tag, it does not agree with IO String, which is the type required for your expression
11:18:51 <Jedai> HaskellLove: why not just use C# in this case ? It already has a lot of functional feature, if you just want some syntaxic sugar in your imperative coffee, I'm not sure F# is the ticket
11:18:52 <HaskellLove> dpratt71> I am reading on it now, actually quite cool, you are release from the locks system that you have otherwise...
11:18:55 <Jafet> patch-tag, hence the two do not match.
11:18:58 <sproingie> @quote harrop
11:18:58 <lambdabot> dolio says: [regarding a paypal spam message on #haskell] Take that, Harrop! Does OCaml have illegal cracking utilities?
11:19:05 <roostaj> , time $ take 10000000 $ scanl1 (+) [1..]
11:19:07 <lunabot>  (0.0,[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231...
11:19:11 <roostaj> , time $ take 1000000000 $ scanl1 (+) [1..]
11:19:13 <lunabot>  (0.0,[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231...
11:19:15 <dpratt71> HaskellLove: are you referring to STM?
11:19:22 <dpratt71> (I was not)
11:19:35 <Jafet> roostaj, are you expecting them to take different amounts of time?
11:19:37 <xerox> patch-tag: the problem is not with runErrorT
11:19:42 <roostaj> Jafet: lunabot chops it off eh
11:19:44 <HaskellLove> dpratt71> STM?
11:19:46 <xerox> :t \f -> f (return "ok")
11:19:47 <lambdabot> forall (m :: * -> *) t. (Monad m) => (m [Char] -> t) -> t
11:19:49 <dolio> @quote JonHarrop
11:19:49 <lambdabot> JonHarrop says: We invested a lot of time and money diversifying into Haskell before I discovered that their industrial success stories were largely faked.
11:19:49 <sproingie> why am i not surprised
11:20:15 <xerox> patch-tag: it's the application of lifter (called f here) to a value of type Monad m => m String that fixes its type
11:20:21 <Jafet> roostaj, laziness is contagious
11:20:32 <roostaj> Jafet: ha ha!
11:20:40 <Jedai> sproingie: because you've seen Harrop prose in the past ?
11:20:44 <HaskellLove> Jedai> it is not about using, i am just reading and comparing... for next 6 months i will use haskell only
11:20:44 <Jafet> , time $ sum $ take 10000000 $ scanl1 (+) [1..]
11:20:49 <lunabot>  Killed.
11:21:01 <roostaj> Jafet: O_o
11:21:04 <sproingie> Jedai: actually referring to the bit about STM.  i'm a bit lagged.
11:21:13 <dpratt71> HaskellLove: the parallel extension in .NET 4.0 do not automatically prevent/protect you from modifying shared state from processes running in parallel
11:21:26 <roostaj> , time $ sum $ take 500000 $ scanl1 (+) [1..]
11:21:30 <lunabot>  (2.015693,20833458333500000)
11:21:31 <sproingie> harrop just discovered Go, I'm sure he'll be slagging off F# in a few months
11:21:32 <zygoloid> , time $ last $ take 1000000 $ scanl1 (+) [1..]
11:21:35 <lunabot>  Stack space overflow: current size 8388608 bytes.
11:21:35 <lunabot>  Use `+RTS -Ksize' to increase it.
11:21:48 <roostaj> , time $  let triangleNumbers n i = n:triangleNumbers (n + succ i) (succ i) in sum $ take 500000 $ triangleNumbers 1 1
11:21:53 <lunabot>  (3.191515,20833458333500000)
11:22:12 <roostaj> interesting
11:22:15 <HaskellLove> dpratt71> ok, i am reading on it now, we can talk later... all i said is functional paradigm is a way towards paralel processing because you dont have to deal with locks and stuff...
11:22:22 <sproingie> oh man
11:22:50 <patch-tag> xerox: so is there a way to widen the type of f so that it will accept general monadic values, and not just m String ?
11:22:56 <Gracenotes> if you repeat the experiment, the time converges to π
11:23:04 <Gracenotes> really
11:23:16 <roostaj> , time $  let triangleNumbers n i = n:triangleNumbers (n + si) si where si = succ i in sum $ take 500000 $ triangleNumbers 1 1
11:23:21 <lunabot>  (2.940554,20833458333500000)
11:23:28 <dpratt71> HaskellLove: you can only free yourself from worrying about locks if you are either purely functional (F# isn't)
11:23:34 <Gracenotes> ..sort of..
11:24:00 <roostaj> :O
11:24:27 <sproingie> not having to worry about locking does not free you from all the difficulties of concurrency
11:24:28 <dpratt71> HaskellLove: STM refers to software transactional memory, which brings transactional semantics to everyday programming
11:24:42 <sproingie> even in the real world it's concurrent processes that are the tricky ones to manage
11:25:09 <jmcarthur> we just suck at certain kinds of complexity
11:25:19 <sproingie> you find you have barriers and sequencing requirements that you didn't think you had before
11:25:55 <sunrayser> is it possible to write type-NON-equality constraints? (like not(a ~ b) => a->b)
11:25:56 <patch-tag> like, I would like to fix this so it typechecks... is there some way?            :t (\f -> f $ return "ok") :: (Monad m) => (m a -> b) -> b
11:26:36 <dpratt71> a real-world example is that you could use F# and the parallel extensions to modify a .NET collection via several parallel processes; if the .NET collection is not thread-safe (i.e. if it doesn't use locks), you'll be in a heap of trouble
11:27:34 <roostaj> :t group
11:27:36 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
11:30:04 <EvanR-work> forkIO is a ghc extension?
11:30:21 <zygoloid> most useful things in the concurrency space are :)
11:30:30 <EvanR-work> i see
11:32:05 <ColonelJ> what's wrong with 'xs == []'
11:32:26 <zygoloid> ColonelJ: it imposes an Eq constraint on the elements of xs
11:32:36 <ColonelJ> ah ok
11:33:55 <HaskellLove> "static typing in a functional language such as F# guarantees even more than it does in C#." Why does the author say that? C# and F# are both statically typed but C# you have to explicitly write types. In F# you dont, staticaly typed there means good quality type inference. So in what way does F# "gurantees" more, quoted and said the above?
11:34:18 <aavogt> who is the author?
11:34:21 <opqdonut> functional languages can have stronger (in some sense) type systems
11:34:28 <monochrom> Why are we not talking about haskell# here?
11:34:42 <opqdonut> or rather, stronger type systems for functional languages are easier than for imperative languages
11:34:50 <dpratt71> HaskellLove: since F# and C# share the same type system, I can't guess what that might mean
11:34:57 <monochrom> Why do people live their whole lives in this channel?
11:35:12 <HaskellLove> Functional programming for the real world - with examples in F# and C# by Tomas Petricek and Jon Skeet
11:35:17 <DigitalKiwi> monochrom: we're sad and lonely
11:35:19 <DigitalKiwi> monochrom: hold me
11:35:23 <sproingie> so go read the paper
11:35:50 <HaskellLove> monochrom>	I am writing in my blog notes on this book, I compare them with haskell as i go. if i should stop tell me i wont ask here?
11:35:57 <sproingie> i can't be the only one getting annoyed
11:36:04 <dpratt71> HaskellLove: type inference is a great feature of F# (and Haskell) to be sure; I just don't see how it "guarantees" anything in particular
11:37:16 <HaskellLove> dpratt71>ok... will continue reading
11:37:37 <monochrom> Oh great, "in my blog I talk about haskell, but in #haskell I talk about everything except haskell"
11:38:08 <dpratt71> monochrom: for my own part, I consider that I am discussing Haskell by pointing out its advantages over impure frameworks/languages
11:38:11 <Cale> Hello all :)
11:38:11 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
11:38:12 <HaskellLove> monochrom, ok i will stop
11:38:48 <DigitalKiwi> I don't have a blag to talk about haskell :(
11:39:05 <sproingie> blag?
11:39:25 * hackagebot upload: Monocle 0.0.4 - Symbolic computations in strict monoidal categories with LaTeX output. (OsmanBineev)
11:39:29 <jmcarthur> reference to xkcd blog i think
11:39:33 <jmcarthur> calls it a blag
11:39:35 <DigitalKiwi> http://xkcd.com/148/
11:39:50 <DigitalKiwi> and yes, blag.xkcd.com is his 'blog'
11:39:59 <sproingie> ah i forgot about that comuc
11:40:58 <DigitalKiwi> it took me a bit to see what you did there...lmao
11:40:59 <sproingie> i thought it was one of those things like "bleg"
11:41:02 <Cale> Hey, this is cool, there's activity on the GHC ticket to replace select with epoll/kqueue.
11:41:11 <sproingie> like "blab" and "blog"
11:41:28 <sproingie> yah i just read about that this morning
11:44:03 <dpratt71> sproingie: if you continue to discuss blags and xkcd, you are likely to upset monochrom :)
11:44:54 <sproingie> xkcd reminds me of that joke where all the jokes are numbered
11:45:03 <sproingie> eventually all our memes will just be xkcd urls
11:45:34 <kmc_> uggh
11:45:58 <zygoloid> sproingie: take the first word from joke 1, the second word from joke 2, ... :)
11:45:59 <kmc_> i mean i know the MTTXR is low here but seriously, first thing i see when i join
11:46:04 <kmc_> zygoloid, haha
11:46:18 <monochrom> hahahaha
11:46:42 <DigitalKiwi> MTTXR?
11:47:18 <dpratt71> I'm guessing MT = mean-time; the rest I don't know
11:47:21 <Twey> The really funny thing is that ‘blag’ is the standard GenAm pronunciation of ‘blog’… ;)
11:47:26 <sproingie> mean time to xkcd reference
11:47:40 <DigitalKiwi> oh, >.>
11:47:55 <dpratt71> ah
11:48:01 <Twey> xkcd is very reference-able.  I think that's what makes it popular.
11:49:56 <EvanR-work> int rand(){ return 4; }
11:49:58 * EvanR-work runs
11:50:02 <sproingie> the style is interesting.  he draws as an uneven scrawl objects that people without any drawing skill would actually draw straight
11:50:16 <zygoloid> so i'm trying to impredicatively recurse with a zipstream monad. do i need a zygohistoprepromorphic endocategorical approach?
11:50:22 <sproingie> reminds me a bit of callahan
11:50:23 <kmc_> I propose the use of MTTXR as a descriptive parameter of online conversation venues
11:50:30 <sproingie> ('course callahan had a reason)
11:50:35 <kmc_> another parameter would be the use or toleration of "u" as an English second-person pronoun
11:51:00 <poucet> kmc_: and the number of exclamation marks followed by 1s
11:51:00 <kmc_> sproingie, indeed.  i think the xkcd art looks better than many stick-figure comics, which are drawn with perfectly straight aliased lines in MS Paint
11:51:00 <mauke> add "lol" and "^_^" and ">_>" to that list
11:51:09 <monochrom> xkcd and haskell: http://article.gmane.org/gmane.comp.lang.haskell.cafe/25273/
11:51:10 <poucet> ZOMGWTF!!!11
11:51:10 <Cale> http://en.wikipedia.org/wiki/File:General_American.png -- haha, according to accent, this is the *real* america.
11:51:10 <zygoloid> kmc_: what about a parameter for toleration of metaconversations, or the fixed point of said parameter?
11:51:23 <kmc_> zygoloid, might correlate too much with MTTXR
11:51:57 <kmc_> Iowa fucking rocks, seriously
11:52:02 <Twey> Heh.  ‘Closest to General American’?  What's that supposed to mean anyway?  :þ
11:52:07 <kmc_> Iowa has gay marriage now
11:52:25 <poucet> kmc_: I don't think rocks classify as gay.
11:52:32 <kmc_> the supposedly coastal liberal elite states of California and New York have both rejected gay marriage
11:52:41 <Gracenotes> rock on rock action
11:52:57 <kmc_> poucet, we would have to ask them about that, wouldn't we
11:53:04 <lament> supposedly coastal :)
11:53:28 <zygoloid> poucet: you never seen two rocks smash together? sometimes little rocks fall out
11:53:42 <zygoloid> i assume this means they must be straight?
11:53:54 <EvanR-work> ._.
11:54:07 <Twey> Heheh
11:54:11 <DigitalKiwi> monochrom: ha
11:54:24 <zygoloid> > fix((0:).(1:).ap(zipWith(+))tail)
11:54:25 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:54:36 <kmc_> > fix ((0:) . scanl (+) 1)
11:54:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:54:43 <Cale> I love the caption on that map as included in the "General American" article:  "The area of the United States where the local accent is largely free of regional features."
11:54:47 <kmc_> did not invent that one :/
11:55:05 <zygoloid> > ff
11:55:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:55:15 <kmc_> damn, you beat me
11:55:22 * DigitalKiwi lives in eastern nebraska, I have no regional accent :(
11:55:45 <Twey> Cale: Haha.
11:55:51 <Cale> It's a region which is free of regional features.
11:56:04 <kmc_> that might be an accurate description of the region in general
11:56:04 <Twey> It's a black hole
11:56:24 <kmc_> Iowa is consistently 25th out of 50th on rankings of states by various characteristics
11:56:41 <kmc_> Des Moines is used as a product-testing market due to its extreme medianness
11:56:53 <Twey> Hahaha
11:56:54 <Twey> Nice
11:57:04 <DigitalKiwi> wait, I say "ya'll" and my gf makes fun of me as nobody else here does, I also have some minnesota accent characteristics
11:57:08 <DigitalKiwi> so I am unique!
11:57:16 <sereven> DigitalKiwi: shouldn't you be DigitalCurlew? You should live in Wellington with a nick like DigitalKiwi!
11:57:23 <Twey> Minnisowduh!
11:57:27 <patch-tag> I'm looking at the MonadIO instance for MonadError and was puzzled by something: instance (Error e, MonadIO m) => MonadIO (ErrorT e m) where
11:57:28 <Twey> Hear hear!  :þ
11:57:29 <patch-tag>     liftIO = lift . liftIO
11:57:29 <kmc_> you can thank Des Moines for diet caffeine free mountain dew, although i prefer the name "yellow bubble chemical water"
11:57:49 <patch-tag> isn't this the same as liftIO = lift . id ?
11:57:50 <zygoloid> hey guys, does anyone know of a channel on IRC where people talk about the Haskell programming language?
11:57:53 * Twey has never seen Mountain Dew :-\
11:57:54 <Cale> patch-tag: no
11:58:01 <kmc_> patch-tag, no, the two liftIO have different types
11:58:07 <Twey> zygoloid: Try #defocus
11:58:14 <kmc_> one is liftIO for m, one is for ErrorT e m
11:58:20 <Cale> patch-tag: Well, liftIO for IO is id
11:58:33 <monochrom> zygoloid: #haskell-blah talks about haskell :)
11:58:37 <DigitalKiwi> what is a curlew?
11:58:42 <patch-tag> Cale: yeah, and isn't whta the rightmost liftIO is doing by definition?
11:59:06 <patch-tag> liftIO takes a value from IO a to ErrorT e IO a
11:59:07 <kmc_> if you have a stack of 2 or more monad-transformers, both liftIO might be non-id
11:59:07 <monochrom> You don't know that m=IO.
11:59:07 <DigitalKiwi> answer in a haskell function so we don't get yelled at ;D
11:59:18 <Cale> patch-tag: There might be more lifting required to lift the IO action into the monad which is being transformed
11:59:47 <kmc_> @type liftIO
11:59:48 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:59:59 <patch-tag> so the argument is always in the IO monad, right?
12:00:02 <kmc_> @type lift . liftIO
12:00:03 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, MonadIO m) => IO a -> t m a
12:00:04 <Cale> patch-tag: For example, suppose I have the monad StateT s IO, and I transform it further with ErrorT
12:00:04 <monochrom> Perhaps you are perverted and doing ErrorT X (ErrorT Y IO a)
12:00:34 <kmc_> or StateT s (ErrorT t IO) a
12:00:51 <kmc_> patch-tag, the argument to liftIO is IO a.  but the return value is m a, for any MonadIO m
12:01:24 <Cale> FFFFFUUUU... all my documentation links are broken by silly documentation update with version numbers again
12:01:40 <monochrom> Is FFFFUUUU a stack of monads?
12:01:45 <patch-tag> mm i think I see
12:01:50 <kmc_> F and U combinators
12:02:04 <Cale> But apparently Control.Monad.Error isn't even listed anymore
12:02:16 <kmc_> patch-tag, there are simpler cases of calling same typeclass method on another type
12:02:21 <kmc_> Looks like recursion, but isn't
12:02:55 <Cale> patch-tag: The inner liftIO does all the work to transform the IO action into a State s IO action, and then the instance for ErrorT will handle the last level of lifting
12:03:14 <monochrom> Functor law "fmap id = id" is not recursion either. :)
12:03:56 <Cale> Er, StateT s IO
12:04:02 <Cale> (of course :)
12:04:05 <poucet> monochrom: that's because you're specifying equality, not saying
12:04:07 <poucet> id = fmap id
12:04:14 <kmc_> instance (Show a) => Show [a] where { show xs = "[" ++ (intercalate ", " $ map show xs) ++ "]" }
12:04:17 <poucet> though even in the latter case, it would not be recursive, since the types change.
12:04:26 <Cale> Is there already a mailing list post complaining about the documentation being broken, or should I complain?
12:04:42 <kmc_> patch-tag, that defn of show :: (Show a) => [a] -> String calls show :: (Show a) => a -> String
12:04:43 <Cale> I can't be bothered to look through all the mailing list articles that I've been ignoring. :)
12:04:59 <stoop> http://www.haskell.org/pipermail/haskell-cafe/2004-March/005939.html
12:05:00 <stoop> haha
12:05:22 <Cale> stoop: Yeah, that was classic
12:06:13 <simk318> test
12:06:15 <kmc_> haha
12:06:21 <kmc_> SimonMarlow++
12:06:24 <simk318> haha i ma new to it
12:06:31 <kmc_> hello simk318
12:06:40 <simk318> hey kmc_
12:07:27 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html <-- who is in charge of this listing?
12:08:49 <Twey> I think it's just the Haddock for GHC?
12:08:54 <Cale> It seems to be missing a lot of stuff now (like mtl and network), and all the links have version numbers in them again.
12:09:07 <Twey> Hm
12:09:14 <simk318> how do i start here ?
12:09:15 <kmc_> Cale, are mtl and network still part of GHC 6.12?
12:09:16 <Cale> It is just the haddock for GHC, but who builds it and puts it online? :)
12:09:18 <mercury^> Are mtl and network still part of the GHC release?
12:09:23 <kmc_> simk318, what do you want to start? Learning Haskell?
12:09:26 <monochrom> missing mtl and network and parallel because they are divorced. I don't know why the version numbers.
12:09:32 <simk318> yes
12:09:41 <kmc_> simk318, get Haskell Platform: http://hackage.haskell.org/platform/
12:09:50 <Cale> monochrom: In that case, it would be good for whoever builds that to install them first.
12:09:54 <kmc_> simk318, find a good tutorial.  people here tend to recommend these two:
12:09:56 <kmc_> @where LYAH
12:09:56 <lambdabot> http://www.learnyouahaskell.com/
12:09:57 <kmc_> @where RWH
12:09:58 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:10:10 <c_wraith> anyone know if there's a plan for a new version of platform to work with 6.12?
12:10:17 <kmc_> simk318, and hang out here and ask questions if you get stuck.  We're always happy to help. :)
12:10:25 <simk318> i have used haskell for a while i know few basic things
12:10:27 <simk318> thanks
12:10:27 <monochrom> c_wraith: some time next year
12:10:29 <kmc_> ah
12:10:30 <sproingie> mercury^: they are for the haskell platform, not the ghc release
12:10:40 <kmc_> simk318, ah, so you're new to the channel but not to Haskell?
12:10:42 <c_wraith> I guess next year isn't necessarily that far away
12:10:50 <simk318> yes i am new to channel
12:10:57 <kmc_> c_wraith, i heard 6 mo gap at one point, but i've also heard a January target
12:11:14 <kmc_> the idea is to release GHC then let library developers update their stuff
12:11:35 <kmc_> simk318, then you should play with lambdabot
12:11:37 <simk318> i think this place will be fun to new things on haskell
12:11:45 <kmc_> > fix ((0:) . scanl (+) 1)
12:11:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:11:56 <monochrom> I am betting two months gap because that is how much time I would take if I were them.
12:11:57 <kmc_> indeed, it's a great place to both learn and teach according to your level
12:11:58 <simk318> prime numbers
12:12:04 <kmc_> simk318, fibonacci numbers
12:12:12 <kmc_> that's the shortest fib generator i know
12:12:14 <kmc_> learned it here :)
12:12:16 <mercury^> sproingie: hmm, thought those were only the GHC docs. The URL should be adjusted if it is supposed to cover the haskell platform.
12:12:33 <c_wraith> simk318: prime numbers are a bit tougher to due concisely and efficiently
12:12:35 <kmc_> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- this one's a little easier to understand
12:12:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:12:40 <EvanR-work> im sick of fibonacci sequence, is this like hello world is it even useful
12:12:48 <EvanR-work> jesus
12:12:50 <sproingie> mtl and network have never been part of the ghc release
12:12:51 <Twey> I'm pretty sure it's only GHC.  Package docs are available on Hackage.
12:12:56 <sproingie> they may be in extralibs
12:12:57 <aavogt> well, 0 isn't a fibonacci number
12:12:59 <Cale> EvanR-work: It's like the hello world of functional programming languages.
12:13:01 <Twey> EvanR-work: It's useful for generating Fibonacci numbers ;)
12:13:01 <kmc_> EvanR-work, useful for a few things, but yes it's hello world / exercise
12:13:04 <Cale> aavogt: Sure it is :)
12:13:16 <Philonous> > nubBy divides [2..]
12:13:18 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:13:34 <sproingie> 0 fits the pattern, but it isn't usually counted
12:13:48 <aavogt> 0 doesn't work with rabbits
12:13:50 <kmc_> EvanR-work, Haskell can be used for many useful things but unfortunately a multithreaded webserver is a little too big to fit in one IRC command to lambdabot
12:13:56 <kmc_> plus she can't do IO
12:14:00 <sproingie> rabbito ex nihilo
12:14:02 <kmc_> > putStrLn "Hello, world!"
12:14:03 <lambdabot>   <IO ()>
12:14:05 <EvanR-work> listing primes is easy and efficient. its simply the square of the minus of the magic function of the fibonacci sequence
12:14:13 <sproingie> aavogt: 1 doesn't really work with rabbits either
12:14:20 <aavogt> hehe, true
12:14:33 <c_wraith> wait.  rabbits don't reproduce via budding?
12:14:41 <Cale> aavogt: Unless that first rabbit happens to have both reproductive systems
12:14:51 <sproingie> hermaphrodic fibonacci rabbits
12:15:00 <sproingie> *hermaphroditic
12:15:05 <simk318> if i give some input say fun [1,2,3] =123, how i can do this using foldl
12:15:06 <Philonous> autophily
12:15:22 <sproingie> parthenogenesis.  of a male.
12:15:43 <sproingie> (another Neat Trick)
12:15:45 <xerox> patch-tag: yes, you should not pass it a value of type  Monad m => m String
12:15:57 <simk318> hey kmc_ you there ?
12:16:01 <kmc_> yup
12:16:08 <inclement> > foldl (\y x -> (show y) ++ (show x)) [1,2,3]
12:16:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
12:16:09 <lambdabot>    arising from the literal `1...
12:16:09 <poucet> :t alloca
12:16:10 <lambdabot> Not in scope: `alloca'
12:16:16 <Cale> > foldl (\n x -> n*10 + x) 0 [1,2,3]
12:16:17 <lambdabot>   123
12:16:42 <monochrom> alloca is in Foreign.*
12:16:55 <simk318> ya gr8
12:17:00 <aavogt> > foldl (\y x -> show x : y) [] [1,2,3]
12:17:01 <lambdabot>   ["3","2","1"]
12:17:03 <Twey> > foldl (\(lvl, n) x -> (lvl + 1, n + (10 ^ lvl) * x)) (0, 0) [1, 2, 3]
12:17:04 <lambdabot>   (3,321)
12:17:47 <Twey> I think you want a foldr
12:17:57 <Cale> eh?
12:18:01 <Twey> > foldr (\ x (lvl, n) -> (lvl + 1, n + (10 ^ lvl) * x)) (0, 0) [1, 2, 3]
12:18:02 <lambdabot>   (3,123)
12:18:06 <sproingie> foldr . spindler . mutilater
12:18:09 <zygoloid> > let f :: Show a => Int -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in f 10 ()
12:18:10 <lambdabot>   "(((((((((((),()),((),())),(((),()),((),()))),((((),()),((),())),(((),()),(...
12:18:11 <Twey> Heh
12:18:12 <Cale> > foldl (\n x -> n*10 + x) 0 [1,2,3] -- Twey
12:18:13 <lambdabot>   123
12:18:23 <Twey> Cale: Oh, duh :þ
12:18:28 <Philonous> > zipWith5
12:18:29 <lambdabot>   {()->{()->{()->{()->{()->()}}}}}->
12:18:29 <lambdabot>    []->
12:18:29 <lambdabot>      []->
12:18:29 <lambdabot>        []->
12:18:29 <lambdabot>          [...
12:18:34 <sproingie> zygoloid: looks like lisp
12:18:35 <kpreid> sproingie: I looked at that and thought "you mean foldr . spindlr . mutilatr"
12:18:45 <Twey> Cale: Too obvious — I would never have suspected it ;)
12:18:45 <kpreid> then I realized I was wrong
12:18:47 <sproingie> kpreid: oh that is much coolr
12:18:54 <Twey> Hehe
12:19:07 <zygoloid> > sum $ zipWith (*) (iterate (*10) 1) (reverse [1,2,3])
12:19:08 <lambdabot>   123
12:19:08 <kmc_> > fix show
12:19:09 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
12:19:18 <kmc_> > fix error
12:19:19 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:19:23 <sproingie> my favorite
12:19:24 <HaskellLove> "F# allows side-effects and doesn't have any mechanism for controlling them. In practice, this means that when you want to rely on the mathematical purity of a part of F# program for some reason, you have to explicitly think about side-effects and make sure that they will not cause any problems." Interesting, that was from a book on F# and C#. Comparing it to Haskell, I would say you need to...
12:19:26 <HaskellLove> ..."explicitly think about escaping purity when you want to achieve side effects and make sure that they will not cause any problems, meaning, keep purity"
12:19:28 <simk318> what is lamdaboot actually ?
12:19:33 <kpreid> Different direction: "some say foldr, some say directoy"
12:19:34 <simk318> > "Hello"
12:19:35 <lambdabot>   "Hello"
12:19:39 <kmc_> simk318, what do you mean?
12:19:40 <simk318> ok
12:19:43 <kmc_> HaskellLove, thanks for sharing
12:20:11 <sproingie> i don't think so much about escaping purity
12:20:24 <sproingie> it's easy to write impure code, it's factoring that into pure code that's tricky
12:20:28 <simk318> foldl (\n x -> n*10 +x) 0 [1,2,3]
12:20:41 <simk318> > foldl (\n x -> n*10 +x) 0 [1,2,3]
12:20:42 <lambdabot>   123
12:20:45 <sproingie> write everything in the IO monad and you have all the side effects you want
12:20:56 <poucet> unsafeperformio FTW
12:21:01 <poucet> it's why my machine is named unsafeperformio
12:21:07 <sproingie> long
12:21:20 <zygoloid> poucet: haha excellent
12:21:22 <aavogt> @wn formio
12:21:24 <lambdabot> No match for "formio".
12:21:29 <sproingie> i knew someone who named all his machines after logical fallacies
12:21:38 <poucet> zygoloid: the other one is rubberduck =)
12:21:42 <sproingie> he had ad-hominem, circular-reasoning, post-hoc
12:21:58 <poucet> (and well at home, monadic)
12:22:16 <Philonous> Hah, I will name my machine "base-rate"
12:22:21 <zygoloid> http://metafoo.co.uk/howisioformed.html
12:23:26 <Cale> The CS club at Waterloo used the naming scheme of ingredients from Coca Cola. They had a machine called phosphoric-acid (with an alias of h3po4)
12:23:39 <sproingie> when i had around five machines, i used to use onomatopaeias
12:23:45 <sproingie> i had bang, pow, biff
12:24:01 <c_wraith> I'm happy that the troll was pass on to hear
12:24:04 <c_wraith> err.  here
12:24:36 <gwern> sproingie: I'd never do that. those would be too hard to remember and type
12:25:04 <DigitalKiwi> found this http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast sweet
12:25:07 * sproingie has six machines now, but only from multiboots and vms.  only two physical ones now.
12:25:09 <gwern> 'was it 'from-force' or 'ad-verecundiam'? did I even spell that last one right?'
12:25:41 <sproingie> istr they all had two-word names like that and they had two-letter aliases
12:25:49 <sproingie> so 'ad-hominem' was aka 'ah'
12:27:09 <gwern> complex scheme
12:27:19 <gwern> I liked RIT's mythological setup
12:27:23 <monochrom> It still hurts me that people still talk like "strict and lazy".
12:27:28 <sproingie> seems like a nice mnemonic for two-letter names actually
12:27:46 <gwern> so I would ssh into gorgon.cs.rit.edu, for example, or maybe I'd go into the US states cluster - nevada.cs.rit.edu, for example
12:27:57 <sproingie> at Sun in colorado we used the egyptian pantheon
12:28:01 <gwern> (hercules, daedalus, they were all there)
12:28:05 <sproingie> so we had ra, shu, maat, bes, osiris, etc
12:28:14 <simk318> hey i have one question, does take and drop both allocate memory when they called ?
12:28:16 <gwern> ta ba shu da yu...
12:28:25 <EvanR-work> @src take
12:28:26 <lambdabot> take n _      | n <= 0 =  []
12:28:26 <lambdabot> take _ []              =  []
12:28:26 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:28:49 <EvanR-work> the result of take may never be evaluated...
12:28:53 <mercury^> simk318: unless they are fused, they force a list to be allocated.
12:29:06 <sproingie> at symantec we have freakin salad, like "tuexcphgs01"
12:29:13 <c_wraith> monochrom: strict and lazy are at least mutually exclusive.  non-strict doesn't imply lazy. eager doesn't imply non-strict
12:29:23 <mercury^> sproingie: have you worked everywhere?
12:29:37 <sproingie> been around quite a few tech companies
12:30:13 <mercury^> What's the reasoning behind the symantec naming?
12:30:14 <gwern> get around like a 8-bit whore eh
12:30:59 <EvanR-work> looks like the philosophy of not only should passwords be random, so should usernames and hostnames ;)
12:31:36 <sproingie> oh it's abbreviation of stuff like "sacramento red network dev router 02" or "san francisco enterprise exchange server 01" or whatever
12:31:46 <sproingie> but it ends up being salad i can't remember at all
12:34:21 <EvanR-work> how about the philosophy of making the username random and the password easy, thats always funny
12:34:43 <aavogt> usernames are often public though
12:34:56 <aavogt> http://host.example/~username
12:35:11 <EvanR-work> exactly
12:35:20 <aavogt> EvanR-work: but that happens?
12:35:25 <michael|> why not just work on the honor system?
12:35:46 <EvanR-work> aavogt: at my university department for undergrads ;)
12:35:46 <monochrom> You don't need a password to log on to #haskell-blah
12:36:10 <c_wraith> I need a password to keep this username. :)
12:36:26 <sproingie> i wouldn't count on it being ironclad secure
12:36:48 <c_wraith> I count on it being highly insecure, actually
12:37:02 <sproingie> i do at least home freenode's network prevents anyone from taking nickserv as a nick
12:37:07 <sproingie> *hope
12:37:19 <sproingie> if services aren't up that is
12:40:16 <DigitalKiwi> is it possible/easy to make/use bindings to C functions?
12:40:57 <lispy> DigitalKiwi: Yes, haskell has a nice FFI for interfacing wit hC
12:42:02 <lispy> DigitalKiwi: you can also make Haskell code callable from C
12:42:09 <DigitalKiwi> hmm
12:42:22 <lispy> Which is nice for when your C code isn't safe enough or fast enough
12:42:27 <lispy> Rewrite in Haskell and call that
12:43:29 <michael|> I need to just section off a week or so on my schedule to sit down and read up on Haskell so I can try and wrap my head around it
12:43:43 <DigitalKiwi> one of my ongoing projects is a Lua->C binding of libalpm (arch linux package management library), another is a Lua package manager which uses that...maybe when I get that done I could try writing it in Haskell =D
12:44:01 <lispy> michael|: learn you a haskell and real-world haskell are both available on the web.  Good places to start :)
12:44:03 <kmc_> hostname schemes at Caltech: old video games, venereal diseases, chemical warfare agents, greek gods, synonyms for "vomit"
12:44:05 <EvanR-work> the crunchy shell IO part of the haskell program would probably be a lot easier to write in haskell than c. seems like c bindings would only be useful for like fft and such
12:44:40 <kmc_> yes, haskell is a great imperative programming language
12:45:12 <michael|> lispy: I'll keep that in mind and look 'em up when I get the time
12:45:42 <DigitalKiwi> what is the learning curve you think on this FFI?
12:45:57 <kmc_> not too bad, if you know C
12:46:06 <kmc_> it's pretty well documented
12:46:10 <monochrom> @quote monochrom immerse
12:46:10 <lambdabot> monochrom says: Don't wrap your head around haskell. Immerse! Wrap haskell around your head.
12:46:14 <kmc_> there's an FFI Addendum to the Report
12:46:30 <lispy> DigitalKiwi: there is a reference manual (haskell98 FFI addendum), tutorials on the web, and tools that work when you have a .h file to start from
12:48:03 <poucet> @quote denotat
12:48:03 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
12:48:11 <kmc_> ahahaha
12:48:26 <lispy> @quote condom
12:48:26 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
12:48:29 <DigitalKiwi> tools that automaticaly write bindings?
12:48:46 <monochrom> such as c2hs
12:48:49 <lispy> DigitalKiwi: in some cases yes.  IIRC, gtk2hs uses them
12:49:46 <DigitalKiwi> interesting, I've been reluctant to use them for my lua project, just been doing it by hand, probably cleaner
12:49:58 <kmc_> i would try without the tool first
12:50:41 <kmc_> but be aware of how much boilerplate you're writing
12:51:12 <kmc_> it's an important attribute of programmers that we're annoyed by having to repeat ourselves
12:53:13 <monochrom> Not all programmers. My friend has a 50yo colleague who repeat himself in code and resisting all alternatives.
12:53:22 <DigitalKiwi> 2282 lualpm.c most of it is like the same stuff :( should probably use macros but i wanted to do that after I actually understood the api...
12:53:29 <DigitalKiwi> only 109 functions bound
12:55:08 <DigitalKiwi> though I guess on average a binding is like 10 lines there's a bit of extra fluff to handle them as methods...
13:01:05 <kmc_> monochrom, well, there's an entire industry of glorifying repetition, especially in OO languages
13:01:54 <EvanR-work> 'design patterns' ;)
13:02:06 <kmc_> yeah
13:02:25 <kmc_> not that we have no design patterns in Haskell, but we recognize them as flaws
13:02:41 <c_wraith> not all of them.  The "little language" pattern is seen as a strength of haskell.
13:02:41 <kmc_> don't think there are books about the Anonymous Function Acts As Long-Winded Way To Update Record Field Pattern
13:03:04 <kmc_> c_wraith, but that's not a pattern in the sense of structurally repeated code
13:03:14 <c_wraith> But it's one all the pattern books talk about
13:03:15 <monochrom> He is beyond that. Even OO people deplore this: o.m("x"); o.n("x"); o.m("y"); o.n("y"); ... 50 more lines.
13:04:00 <kmc_> c_wraith, sure.  they don't have a clear definition of "pattern" anyway
13:04:28 <DigitalKiwi> thanks guys
13:04:56 <aavogt> if they are really patterns they can be abstracted away
13:05:24 <kmc_> and it is important to know those C++ and Java patterns if you must program in C++ and Java
13:05:43 <c_wraith> But yeah, the "lambda to update a record" pattern is amazingly ugly
13:05:58 <EvanR-work> i need to learn this pattern
13:06:10 <kmc_> because to program in C++ and Java effectively, you must substitute yourself as the missing macro / HOF system
13:06:55 <Philonous> kmc_: wouldn't it be smarter to write macro system in haskell and preprocess your source (or at least use an editor that writes the code for you)?
13:07:04 <kmc_> Philonous, yeah, people do this
13:07:09 <Philonous> I honestly wonder why there are no widely used C preprocessors
13:07:10 <kmc_> e.g. Facebook uses Haskell to refactor their PHP code
13:07:14 <blobl> takeWhile (> 2) [1..12]
13:07:15 <kmc_> besides CPP?
13:07:20 <kmc_> some people run their c through m4
13:07:31 <Philonous> CPP is a joke
13:07:34 <kmc_> and plenty of tools generate C for specialized purposes
13:07:48 <kmc_> c_wraith, yeah.  that's why we have three packages on hackage attempting to fix record syntax
13:08:00 <blobl> why takeWhile (> 2) [1..12] produces an empty list?
13:08:07 <c_wraith> lenses are decent, but very MonadState oriented.
13:08:12 <opqdonut> because takeWhile gives a prefix
13:08:15 <kmc_> blobl, "take elements from [1..12] until you see one that's not > 2"
13:08:19 <poucet> blobl: it takes from the head of the list until the condition is false
13:08:21 <chellomere> blobl, 1 is not >2
13:08:23 <kmc_> maybe you want "filter (>2) [1..12]"
13:08:29 <kmc_> > filter (>2) [1..12]
13:08:32 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
13:08:38 <Philonous> blobl: just read what it says: take while (>2). Well, the first element already isn't > 2.
13:08:42 <kmc_> c_wraith, what about fclabels?
13:08:54 <kmc_> i'd love to see a comparison of fclabels, lenses, and data-accessor
13:09:02 <blobl> oh i see
13:09:08 <c_wraith> kmc_: haven't looked at fclabels
13:09:11 <c_wraith> I guess I should
13:09:17 <kmc_> they all do sort of the same thing
13:09:18 <blobl> cheers
13:09:23 <kmc_> :)
13:09:37 <kmc_> i guess i could see which one has the most use throughout hackage
13:11:10 <zong_sharo> i want to do queries over set of items (items has a properties, query is a one or more of predicates over properties)
13:11:15 <zong_sharo> sound's like sql, but i don't want use it. any advice on something better than O(n)?
13:11:30 <blobl> equally dropWhile (> 5) [1..12] will not drop anything
13:12:27 <c_wraith> Admittedly, being MonadState oriented is great when my main use for records is...  in State monads.
13:13:31 <eivuokko> blobl, If those are confusing you, maybe you want to negate the predicate.  dropWhile (not (>5)) [1..12]
13:13:49 <Philonous> zong_sharo: If your properties compose like a monoid you might want to look at finger trees.
13:15:03 <Philonous> zong_sharo: The idea basically is that you associate to every node in a tree a value v that represents your predicate(s), and whenever you compose two subtrees  you compose those values
13:15:14 <jmcarthur> kmc_: i'm pretty sure data-accessor has the most use. it's been around the longest i think
13:15:16 <blobl> eivuokko: doesnt work..
13:15:40 <jmcarthur> iiuc, it's also the least innovative
13:16:18 <eivuokko> blobl, hmm?
13:16:30 <eivuokko> blobl, Ah, yeah, missing composition: (not . (>5))
13:16:50 <aavogt> or you could write  (<=5)
13:17:09 <eivuokko> Yes, well, point was the negation, and so I used not.
13:17:53 <aavogt> @check \x -> takeWhile not x == dropWhile id x
13:17:54 <lambdabot>   "Falsifiable, after 1 tests:\n[False,True]\n"
13:18:43 <zong_sharo> Philonous: no, they not
13:19:20 <blobl> houmf :!
13:25:04 <Gracenotes> @check \x -> (takeWhile not x ++ dropWhile id x) == x
13:25:05 <lambdabot>   "Falsifiable, after 0 tests:\n[False]\n"
13:25:09 <Gracenotes> :|
13:26:33 <aavogt> > (takeWhile not [False], dropWhile id [False])
13:26:34 <lambdabot>   ([False],[False])
13:26:58 <aavogt> @check \x -> (takeWhile id x ++ dropWhile id x) == x
13:26:58 <lambdabot>   "OK, passed 500 tests."
13:28:28 <ziman> @check \xs -> (length xs < 5)
13:28:28 <lambdabot>   "Falsifiable, after 12 tests:\n[(),(),(),(),()]\n"
13:28:31 <DigitalKiwi> hmm, so c->haskell bindings are actually written in haskell?
13:29:00 <ziman> @check \xs -> (length (42:xs) < 6)
13:29:00 <lambdabot>   "Falsifiable, after 10 tests:\n[1,7,-4,-5,6,-6]\n"
13:29:43 <aavogt> @check (<42) . length
13:29:43 <lambdabot>   "Falsifiable, after 122 tests:\n[(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
13:29:51 <aavogt> @check (<100) . length
13:29:51 <lambdabot>   "Falsifiable, after 238 tests:\n[(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
13:30:24 <aavogt> hmm, quickcheck seems to test the same options twice
13:30:32 <aavogt> more than that actually
13:31:36 <aavogt> DigitalKiwi: apparently some parts are written in C though, such as if the code uses macros or something like that
13:31:54 <DigitalKiwi> oh
13:35:25 <sshc> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
13:35:30 <sshc> why is that 404?
13:35:42 <kmc_> ghc update screwed up the tree :/
13:35:52 <sshc> I'm trying to see how the list Appilicate functor is defined
13:36:06 <kmc_> you may want: http://haskell.org/ghc/docs/6.10-latest/html/libraries/index.html
13:36:11 <kmc_> unless you've already switched to 6.12
13:37:41 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Applicative.html  hehe
13:38:21 <sshc> looks like I need to replace recent with 6.10-recent
13:38:39 <monochrom> Pauli exclusion principle implies that you need a version number somewhere in your URL. :)
13:41:22 <Veinor> aavogt: that's odd
13:41:27 <Veinor> @chec (<2) . length
13:41:28 <lambdabot>   "Falsifiable, after 2 tests:\n[(),()]\n"
13:41:39 <HaskellLove> 2010 i will do only functional programming, 2011 will continue both with imperative, but I might forget imperative... anyone has had similar experience to warn me to be careful?
13:42:01 <DerisionSnort> beware, 2012 the world ends!
13:42:15 <DerisionSnort> so enjoy your lambda while you can!
13:42:17 <malsyned> Does whoever runs haskell.org/hoogle know that it's serving up broken links?
13:42:23 <EvanR-work> i had a hard time writing some c code the other day, after doing a few weeks of haskell
13:43:08 <DerisionSnort> good
13:43:21 <DerisionSnort> your brain already works at a higher level
13:43:56 <EvanR-work> heh. i couldnt return an int store as bytes in a char[4], was embarrassing ;)
13:44:17 <EvanR-work> return *((unsigned*)buf);
13:44:21 <EvanR-work> \o/
13:44:34 <ziman> that's unportable :)
13:44:41 <EvanR-work> yes, it was for a script ;)
13:44:51 <ziman> :)
13:45:04 <monochrom> If people really wanted portable, they would use haskell.
13:45:08 <EvanR-work> needed to generate some random integer literals for my seed list ;)
13:46:27 <knobo> A monad is a container with one item?
13:46:41 <monochrom> Not necessarily one item.
13:46:46 <EvanR-work> a burrito with one topping
13:46:51 <DerisionSnort> :t concatmap
13:46:52 <lambdabot> Not in scope: `concatmap'
13:46:54 <knobo> can be (m a b)
13:46:55 <DerisionSnort> :t concatMap
13:46:56 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
13:47:06 <monochrom> "m a" does not mean one item.
13:47:30 <knobo> monochrom: what does it mean then?
13:47:54 <monochrom> @type ['x', 'y', 'z']
13:47:56 <lambdabot> [Char]
13:48:11 <monochrom> Tell me, does [Char] mean list of one item? list of one type?
13:48:14 <aavogt> one type of item
13:49:04 <knobo> monochrom: how about that the item is a list ?
13:49:26 <sbenitezb> @type [String]
13:49:28 <lambdabot> Not in scope: data constructor `String'
13:49:44 <EvanR-work> @type ["foo"]
13:49:45 <lambdabot> [[Char]]
13:49:46 <monochrom> @type [['x', 'y', 'z'], ['x', 'x', 'z'], ['x', 'y', 'y']]
13:49:47 <lambdabot> [[Char]]
13:49:52 <Peaker> knobo: "m a" just means "the type 'm' parameterized with one 'a'" -- what this means is really open -- whatever the type wants it to mean :)  (It does imply there are/will-be 0 or more values of that type somewhere)
13:50:13 <monochrom> which item is "the" item?
13:50:37 <tibbe> @seen bos
13:50:38 <lambdabot> Unknown command, try @list
13:51:10 <knobo> Peaker: I c.
13:51:21 <knobo> I get it :)
13:52:09 <monochrom> A villain made a promise to John and Mary "I will not tell your secret to the 4th person". A year later, the villain told the secret to everyone in a hall full of, say, 50 people. His defense: "point out the 4th person to me".
13:52:27 <Veinor> monochrom: whoever was closest to him
13:52:56 <knobo> data Foo a = Foo a a a  could be made in to a monad (if one implemented bind and return)
13:53:08 <kmc_> indeed, [] is a Monad
13:53:11 <Peaker> knobo: in the void/null monad, there are never any values of type "a" anywhere... data Null a = Null ; instance Monad Null where return _ = Null ; _ >>= _ = Null
13:53:13 <kmc_> and contains arbitrarily many values
13:53:38 <kmc_> a value of type "M a", for "M" a monad, is a "recipe" for how to produce a value of type "a".
13:53:42 <Peaker> Foo a = Foo a a a  -- could be a ZipList monad (since you have a guarantee for same number of elements), I think
13:53:43 <aavogt> Peaker: that one is terribly useful?
13:53:55 <HaskellLove> In the book it says there are several methods for allowing recursion in a language, for example in Lisp you have cons and cdr, or head and tail right... so recursion is inherent to the data structure List, in other words you dont have lists you have no recursion... so I supose Haskell relies on same concept?
13:53:56 <Peaker> aavogt: only to illustrate a point :)
13:54:07 <Peaker> aavogt: perhaps to neutralize some code somewhere
13:54:11 <monochrom> Terribly useful in confusing people with presumptions.
13:54:36 <kmc_> the recipe could be written in terms of IO (IO monad), choosing from a list, propogating failures (Maybe / Either), passing around state (State), backtracking parsers (Parsec), etc.
13:55:17 <kmc_> each monad defines a different computational "world" in terms of two things: how to pull a value into this world (return) and how to glue together two recipes into one (>>=)
13:55:20 <Peaker> kmc_: I like "recipe"
13:55:26 <Peaker> kmc_: I used to tell people "TODO lists" :)
13:55:49 <monochrom> Veinor: The story was set in circa 1000 AD. It was assumed everyone heard a speech at the same time.
13:55:58 <Peaker> kmc_: Now I just try to explain monads bottom up -- showing how >>= is useful in specific contexts (Maybe and []) and then showing how its nice to have a class for them
13:56:08 <Veinor> monochrom: Well obviously they just need to be educated! :D
13:56:16 <kmc_> (technically, the latter is more flexible -- you're allowed to "compute" the second recipe using the "result" of the first.  if all you need is to glue together pre-formed recipes, Applicative gives you that)
13:56:21 <kmc_> Peaker, that's an interesting approach
13:56:25 <kmc_> like the "you could have invented monads" one
13:57:25 <monochrom> I would propose using classical logic. It would sidestep subtle knowledge of physics. The 4th person exists, non-constructively. The villain was exploiting people's constructive-logic tendency.
13:58:45 <c_wraith> I'd argue speed of sound propogation.  I'm boring that way.
14:00:17 <knobo> monochrom: prove that anyone could possibly not be the 4th person.
14:00:20 <DerisionSnort> @src concat
14:00:20 <lambdabot> concat = foldr (++) []
14:00:41 <knobo> We are all the 4th person.
14:00:45 <EvanR-work> HaskellLove: lists and just convenient data structures for recursive algorithms
14:00:48 <EvanR-work> are*
14:00:51 <ziman> what's the definition of "4th person"?
14:01:35 <DerisionSnort> @src concatMap
14:01:35 <lambdabot> concatMap f = foldr ((++) . f) []
14:01:36 <knobo> data Person = FirstPerson | ... | FourthPerson
14:01:42 <DerisionSnort> :t concatMap
14:01:43 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
14:01:47 <DerisionSnort> :t (concat . map)
14:01:48 <lambdabot>     Couldn't match expected type `[[a]]'
14:01:48 <lambdabot>            against inferred type `[a1] -> [b]'
14:01:48 <lambdabot>     Probable cause: `map' is applied to too few arguments
14:01:49 <kmc_> HaskellLove, lists are a recursive datatype in Haskell, and it's natural to do recursion over them
14:01:57 <kmc_> You can certainly do recursion without them
14:02:08 <kmc_> Lisp's lists are quite different from Haskell's
14:02:41 <kmc_> both in what they are and in how they're typically used
14:03:00 <kmc_> in Haskell we avoid explicit head/tail in favor of pattern matching
14:03:14 <Peaker> and we avoid pattern-matching in favor of higher order functions :)
14:03:36 <knobo> HaskellLove: I don't see how lists are required for recursion in lisp either.
14:03:54 <kmc_> indeed, you can write many numerical recursive procedures without using any recursive types
14:03:55 <knobo> Except for that lists are required for coding in lisp
14:04:39 <knobo> (print 'test) is a list
14:04:46 <knobo> and it is code
14:04:54 <kmc_> in Haskell you can make user-defined recursive datatypes, and define recursion schemes over them (indeed, derive them automatically)
14:05:14 <sbenitezb> any opinions on clojure?
14:05:17 <kmc_> in Lisp there's not so much of a concept of user-defined types, and also not a concept of which types are recursive, because they are all dynamically typed
14:05:31 <monochrom> You can write recursive code with the Bool type already.
14:05:39 <opqdonut> yeah, i miss algebraic types most in clojure
14:05:41 <HaskellLove> kmc_ yeah but basically down there you use lists, no matter what your data types right, if u want them recursive?
14:05:43 <opqdonut> and performance can be a pita
14:05:48 <kmc_> sbenitezb, interesting language.  the designer definitely Gets It in terms of avoiding state when possible, and using things like STM.  however, the implementation is crippled by targetting JVM
14:05:50 <kmc_> HaskellLove, no, not at all
14:05:51 <opqdonut> because of reflection etc
14:05:58 <kmc_> also, HaskellLove, please stop saying "u"
14:06:02 <opqdonut> :D
14:06:04 <kmc_> the second person pronoun in English is "you"
14:06:20 <HaskellLove> kmc_ ok continue your explanation i am interested
14:06:34 <kmc_> data Tree = Leaf Int | Node Tree Tree
14:06:35 <EvanR-work> theres also you guys, yous guys, yall
14:06:38 <kmc_> HaskellLove, that's a recursive datatype
14:06:42 <kmc_> which is not a list
14:06:46 <kmc_> and not particularly like a list
14:07:05 <HaskellLove> got you, thanks
14:07:06 <kmc_> you can define fold, map, etc. for it, and it will be different from the list fold, map, etc.
14:07:58 <monochrom> I am so annoyed that I'm going to write a book that says the book HaskellLove is reading is wrong. In fact, what the hell, here it is: "Dedicated to everyone in #haskell" "Chapter 1. That book you're reading is wrong." "Index. #haskell: page 0."
14:08:21 <kmc_> monochrom, i will rate your book 5 stars on amazon
14:08:26 <HaskellLove> monochrom>	what did i do now :(
14:08:37 <jlouis> I'll also rate it 5 stars on amazon
14:08:42 <kmc_> HaskellLove, I am glad you are asking conceptual questions now :)
14:08:53 <jlouis> Review of book: Succinct and Concise book to the point.
14:09:55 <monochrom> All this cross-examining us with an unknown book we didn't write is really tiresome.
14:10:43 <kmc_> monochrom, it's an improvement
14:21:55 <absentia> nsmee!
14:21:58 <absentia> er, Smee!
14:22:00 <mee> mrr?
14:22:05 <mee> ah, Hook!
14:22:51 <mee> actually, my initials -- much less exciting; sorry to disappoint.
14:23:13 <EvanR-work>  /nick yoo
14:25:41 <mee> can someone help me understand why `f1 x = map (*x)` and `f2 = (\x -> map (*x))` have different types? (in prelude, ghci-6.10.3)
14:26:15 <mauke> monomorphism restriction?
14:26:23 * mee googles
14:28:39 <DerisionSnort> @pl \x y -> f x ++ y
14:28:39 <lambdabot> (++) . f
14:28:50 <DerisionSnort> how would you deduce this in your head?
14:30:05 <DerisionSnort> @src concatMap
14:30:06 <lambdabot> concatMap f = foldr ((++) . f) []
14:30:31 <DerisionSnort> @pl \y x -> f x ++ y
14:30:32 <lambdabot> flip ((++) . f)
14:30:44 <DerisionSnort> @pl \x y -> x  ++ f y
14:30:44 <lambdabot> (. f) . (++)
14:31:11 <DerisionSnort> @pl \y x -> x  ++ f y
14:31:11 <lambdabot> flip (++) . f
14:32:12 <jethr0> good day, haskell
14:33:02 <jethr0> i've just installed haskell platform 2.0.2 under windows xp and using cabal am getting lots of virus alerts from avira antivirus...
14:33:56 <jethr0> i.e. from network-bytestring: 'Lazy_hsc_make.exe is the trojan "TR/Dropper.Gen" '
14:34:04 <jethr0> anyone else had anything like this?
14:34:40 <DerisionSnort> @pl \f xs = concat $ map f xs
14:34:40 <lambdabot> (line 1, column 7):
14:34:40 <lambdabot> unexpected "="
14:34:40 <lambdabot> expecting pattern or "->"
14:34:47 <DerisionSnort> @pl \f xs -> concat $ map f xs
14:34:47 <lambdabot> (=<<)
14:35:01 <DerisionSnort> @pl \f xs -> (concat $ map f xs)
14:35:01 <lambdabot> (=<<)
14:35:27 <jethr0> basically i get a trojan/virus alert on any "cabal install"/build
14:35:44 <DerisionSnort> =<< is concatMap ???
14:35:49 <jethr0> yes
14:35:50 <jlouis> for a list
14:36:58 <mauke> @pl \f xs -> join (fmap f xs)
14:36:58 <lambdabot> (=<<)
14:37:17 <mee> mauke: qualified by having only learned what MR is, I don't think that's it. Because I can evaluate both of those and not generate a type error.
14:37:40 <DerisionSnort> hm, it makes sense when you look at the definition of bind which is something like a flipped concatMAP
14:38:04 <DerisionSnort> @check (>>=) == flip concatMap
14:38:05 <lambdabot>   No instance for (GHC.Classes.Eq ([a] -> (a -> [b]) -> [b]))
14:38:05 <lambdabot>    arising from...
14:38:11 <DerisionSnort> or however it works :)
14:38:14 <mee> unless ghci is automagically type-restricting the later to avoid MR
14:38:27 <mee> latter*
14:40:31 <jethr0> either haskell platform is COMPLETELY virus infested or avira antivir is not made for a development/compiling/binary data workstation...
14:41:09 <lament> open sores easily get infected
14:41:26 <DerisionSnort> @upl (== 0) . (x `mod`)
14:41:26 <lambdabot> Maybe you meant: pl unpl url
14:41:30 <DerisionSnort> @unpl (== 0) . (x `mod`)
14:41:30 <lambdabot> (\ e -> (mod x e) == 0)
14:41:36 <bearded_oneder> jethr0: avira is notorious for false positives.
14:41:47 <lament> hi bearded_oneder
14:42:01 <bearded_oneder> lament: :)
14:42:02 <jethr0> bearded_oneder: i haven't had so much problems in the past. any suggestions for a better free scanner?
14:42:32 <lament> OS X
14:42:57 <bearded_oneder> AVG for real time protection and BitDefender 10 for second opinion file scans.
14:43:16 <lament> if you use AVG, the virus writers have already won
14:43:33 <bearded_oneder> but, alas, this is veering off topic.
14:44:03 <DerisionSnort> Why do we have list comprehensions when there is the list monad?
14:44:16 <Heffalump> it's just notation
14:44:18 <kmc_> different syntax
14:44:23 <kmc_> they used to be general "monad comprehensions"
14:44:30 <kmc_> but this was removed :/
14:44:30 <Heffalump> guards are more concise, and the result is at the start, which is easier to understand
14:44:32 <skorpan> why do we have do-notation?
14:44:48 <sinelaw> help. why doesn't my code see a data constructor Vector2 when i import this module? http://hackage.haskell.org/packages/archive/Yampa/0.9.2.3/doc/html/src/FRP-Yampa-Vector2.html#Vector2
14:45:00 <grahamhutton> @users
14:45:00 <lambdabot> Unknown command, try @list
14:45:07 <grahamhutton> users
14:46:11 <emile_m> kmc_: Monad comperhensions? Can I see one somewhere?
14:46:20 <kmc_> google maybe
14:46:26 <Heffalump> they're just list comprehensions generalised to any MonadPlus
14:46:43 <mee> mauke: Adding a type signature fixed it, though, so I am just totally confused now. :shrug:
14:46:52 <kmc_> MonadPlus because it needs guard?
14:46:52 * mee carries on
14:47:04 <Philonous> kmc_: Why did they remove monad comprehension?
14:47:21 <kmc_> type ambiguity i think
14:47:35 <kmc_> too often you'd have to write [ x | y ] :: [Int]
14:47:48 <kmc_> though... that doesn't happen with "do"
14:47:50 <kmc_> maybe there's another reason
14:48:58 <DerisionSnort> @src (.)
14:48:58 <lambdabot> (f . g) x = f (g x)
14:49:38 <grahamhutton> Philonous; they are not as expressive as do notation.
14:50:33 <DerisionSnort> @src (:)
14:50:33 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:50:41 <DerisionSnort> @src (++)
14:50:41 <lambdabot> []     ++ ys = ys
14:50:41 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:50:41 <lambdabot> -- OR
14:50:41 <lambdabot> xs ++ ys = foldr (:) ys xs
14:51:03 <kmc_> DerisionSnort, data [] a = [] | (:) a ([] a)
14:51:06 <grahamhutton> (e.g. every monad comprehension ends with an implicit use of "return", which is not the case for do notation)
14:51:15 <Philonous> Ah well. Maybe to much syntactical sugar really does cause cancer in the semi-colon
14:51:35 <kmc_> but you can transform any do-block such that it ends with "return"
14:51:48 <kmc_> because of the monad law (m >>= return) = m
14:54:49 <emile_m> "broccoli brains", good for lambdabot :)
14:55:34 <amgarchIn9> hi, when you have to fit a function given its values at several points there are splines for it. What if I have both values and derivatives of a function at a set of points? What libs/tools are there to deal with that?
14:55:36 <ziman> well, if the do-block ends in anything else than a return (say, `f'), you'd have to write [x | foo, x <- f]
14:56:06 <kmc_> amgarchIn9, in Haskell specifically?
14:56:18 <kmc_> for the general problem you could ask in #math
14:57:24 <Cale> amgarchIn9: Isn't that what splines are?
14:58:13 <largos> has anyone else had trouble installing template-haskell-2.4.0.0?  when I try to install it (or anything that depends on it, such as yi, I get this error: Not in scope: data constructor `CharConstr' )
14:58:26 <amgarchIn9> kmc_: I could translate haskell code into something readable if there is anything. In #math they are discussing homeworks.
14:58:36 <Cale> amgarchIn9: Look up "Bézier curve"
14:58:44 <xerox> that kind of work is indeed what splines are for
14:59:19 <Cale> What you're asking for is precisely a 1-D Bézier curve.
14:59:22 <amgarchIn9> Cale: splines I've seen ensure continuity of the derivatives, dont take the values for them.
14:59:46 <lament> amgarchIn9: there're plenty of people in #math who really hate all the homework questions and are just waiting for someone to ask something real :)
14:59:50 <Cale> amgarchIn9: hmm, perhaps you're thinking of Lagrange interpolation or something
14:59:57 <lament> although it's very biased to pure math
14:59:57 <xerox> you just need more degrees of freedom
15:00:32 <kmc_> amgarchIn9, you could always pick your favorite spline and do gradient descent on the control points to match derivatives
15:00:36 <kmc_> i'm sure there's a better way
15:00:51 <Cale> amgarchIn9: Essentially you can construct some linear equations on the coefficients
15:01:22 <xerox> a(x_i)^2 + b(x_i) + c = f_i  2a(x_i) + b = f'_i
15:01:58 <Cale> You just need to decide what degree you need, which isn't too hard. :)
15:02:34 <grahamhutton> kmc_: good point!  another reason for doing away with comprehensions is that they provide similar functionality to "do" notation, but have the significant disadvantage of giving cryptic errors to novice programmers, e.g. in some situations using [] results in a monad error rather than a list error.
15:02:47 <lament> i remember studying this
15:02:56 <lament> (splines from derivatives)
15:03:05 <lament> but don't remember what exactly it was :)
15:03:13 <xerox> numerical analysis (*frown*)
15:05:30 <amgarchIn9> xerox: right, somebody must have already done that. I hope.
15:06:15 <xerox> Burden & Faires is comprehensive and has algorithms (but no Haskell)
15:07:39 <randonym> quit
15:08:57 <imc> greetings
15:09:07 <DigitalKiwi> hi
15:10:18 <HaskellLove> if (succ) then Some(num) else None;; This is from the book, lesson on "option values" and when I compared to Haskell I saw this is actually the Maybe monad :)
15:10:34 <HaskellLove> talking about F# ^
15:10:39 <Baughn> Or the MaybeT monad, maybe
15:10:48 <Baughn> *monad transformer
15:11:37 <deech> Hi all, is it considered good Haskell style to annotate your code with types. Not just the toplevel type of a function but the type of a variable in a monadic expression like "(a :: Int) <- return $ 1 + 1".
15:12:05 <kmc_> deech, it's uncommon
15:12:11 <kmc_> unless you have a situation with ambiguity
15:12:17 <kmc_> if it helps you, go for it
15:12:21 <kmc_> but also, don't write "a <- return e"
15:12:25 <Baughn> deech: I only do that when I absolutely have to.. or for debugging
15:12:26 <jlouis> Or the type is mindboggingly insane
15:12:28 <kmc_> write "let a = e"
15:12:30 <Liskni_si> not just uncommon, it's not h98 either
15:12:46 <EvanR-work> isInfinite :: [a] -> Boolean, quick someone give the code for this ;)
15:12:50 <kmc_> and you can write "let a :: t; a = e" or the same on two lines
15:13:00 <kmc_> haha EvanR-work
15:13:03 <Peaker> deech: writing the type is prone to over-specialization -- and may be redundant
15:13:05 <deech> But doesn't it make reading code easier?
15:13:14 <Peaker> deech: which might make refactoring/moving stuff around harder, too
15:13:14 <BONUS> unless there's ambiguity, i just type annotate the top level functions (if at all)
15:13:15 <jlouis> deech: not really
15:13:17 <HaskellLove> deech my experience so far is: declare all functions before defining them, about arguments like that what you say i never really did that... as kmc_ said if some ambiguity arises and you see type errors pointing you there, try to add it signature...
15:13:18 <Baughn> EvanR-work: isInfinite xs@(_:xs') = reallyUnsafePointerEquality xs xs'
15:13:26 <Baughn> EvanR-work: There may be false negatives.
15:13:31 <Peaker> deech: There are editor plugins that let you show the type of sub-expressions when you hover over them
15:13:38 <EvanR-work> Baughn: you just solved the halting problem? :)
15:13:45 <kmc_> Baughn, haha
15:13:50 <Baughn> EvanR-work: For a subset of programs, sure. That's legal. :P
15:13:52 <c_wraith> He did mention false negatives. :)
15:14:02 <jlouis> isInfinite x = unsafeDivineInterventionByOracle Infinite x
15:14:12 <EvanR-work> lol
15:14:13 <xerox> deech: I like reading type declarations, especially if many things are going on, like many let bindings, long do blocks, etc.
15:14:15 <deech> Peaker: This would be incredibly useful. I am currently using the haskell-mode in emacs. Where can I find this?
15:14:18 <jlouis> data OracleValues = Infinite | Halting
15:14:46 <Baughn> jlouis: That's silly. If you want Halting, just prepend 'not .' to the call.
15:15:09 <jlouis> Baughn: oh!
15:15:16 <Peaker> deech: Haskell-mode can do this, afaik, using ghci.. I don't use it myself, but maybe others here do
15:17:19 <deech> Peaker: That would be awesome - it makes my issue moot. I didn't know the functionality existed in haskell-mode. Must explore further. Thanks!
15:18:09 <kmc_> iirc haskell-mode has some db of prelude types
15:18:14 <kmc_> but no actual interface with a typechecker
15:18:31 <kmc_> maybe it does both
15:18:43 <kmc_> not sure how you'd get e.g. the type of a "let"-bound variable from ghci
15:18:57 <Baughn> If you load the file in ghci, then C-c C-t will get top-level types at least
15:19:18 <Baughn> kmc_: The upcoming haskell-mode 2 will do that.
15:19:31 <kmc_> cool
15:19:33 <Baughn> ..or try, at any rate.
15:19:50 <Baughn> kmc_: And by "upcoming", I mean "next year, maybe, if you're lucky"
15:19:59 <c_wraith> next year's in like 2 weeks.
15:20:07 <kmc_> the *start* of next year is :)
15:21:19 <DerisionSnort> data Id a = Id a
15:21:19 <DerisionSnort> instance Show (Id a) where show (Id x) = show x
15:21:19 <DerisionSnort> Why doesn't this work?
15:21:45 <kmc_> because you have no (Show a) context
15:21:50 <kmc_> instance (Show a) => Show (Id a)
15:22:07 <kmc_> you can also make the context part of the Id constructor, if you write it as a GADT
15:22:16 <kmc_> iirc it does the wrong thing as a H98
15:22:17 <kmc_> type
15:22:55 <DerisionSnort> ah, this "(Show a) =>" means that I can only show Id a if I can show a?
15:23:01 <kmc_> yeah
15:23:04 <DerisionSnort> thanks
15:23:09 <kmc_> which you need here, because you try to show x
15:23:10 <sshc> why isn't zipWith8 defined in the standard library?
15:23:19 <DerisionSnort> the other thing with the  GADT i didnt understand :)
15:23:19 <sshc> they really should have defined one more /=
15:23:21 <kmc_> because they stopped at 7
15:23:38 <Baughn> sshc: Frankly, if you want 8, you're doing something wron
15:23:40 <Baughn> g
15:23:43 <kmc_> DerisionSnort, i can explain more if you like
15:23:48 <DerisionSnort> cool
15:23:52 <kmc_> sshc, it's pretty rare to use tuples even above 2
15:24:01 <kmc_> because you should define your own type instead
15:24:14 <Baughn> sshc: But you could get the equivalent using ZipList's Applicative instance
15:24:28 <sshc> Baughn: how would I do that?
15:24:31 <kmc_> not if the types differ
15:24:34 <kmc_> if i understand correctly
15:24:42 <kmc_> err, nm
15:24:48 <sshc> I really think 8 should be defined
15:24:59 <sshc> if they already have 7, why not 8?
15:25:08 <DerisionSnort> i they have n, why not n+1?
15:25:09 <kmc_> if they already have 8, why not 9?
15:25:10 <Baughn> > (+) <$> ZipList [1..4] <*> ZipList [2..10]
15:25:12 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
15:25:12 <lambdabot>    arising ...
15:25:13 <sshc> 8 is more common than 7
15:25:15 <c_wraith> this is not a good case for induction
15:25:17 <kmc_> aha, i see
15:25:19 <sshc> because 9 isn't a power of two
15:25:23 <Baughn> @src ZipList
15:25:24 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:25:28 <sshc> and their maximum is one away from 8
15:25:35 <HaskellLove> > Some("Hi there!");;    Result from F# interpreter:    val it : Option<string> = "Hi there!"        Wow when I compare to Haskell, Some is Maybe and Option is Just :)
15:25:36 <lambdabot>   <no location info>: parse error on input `;'
15:25:42 <Baughn> @index ZipList
15:25:42 <lambdabot> bzzt
15:25:44 <Philonous> DerisionSnort: Btw. If you have one constructor with one parameter you can use newtype instead of data (it eliminates the overhead of the additional redirection), also, using record Synntax, you get a function that retrieves the value for free: "newtype Id a = Id { unId :: x) ==> unId . Id $ x == x )
15:25:45 <sshc> @src map
15:25:46 <lambdabot> map _ []     = []
15:25:46 <lambdabot> map f (x:xs) = f x : map f xs
15:25:53 <Baughn> > getZipList $ (+) <$> ZipList [1..4] <*> ZipList [2..10]
15:25:54 <lambdabot>   [3,5,7,9]
15:25:58 <Baughn> sshc: Like that.
15:26:08 <aeron> hey folks - how can I create a parser with parsec to grab content between two parentheses and discard the parans without using the 'do' notation?
15:26:09 <Baughn> > getZipList $ (:) <$> ZipList [1..4] <*> ZipList [[42]]
15:26:11 <lambdabot>   [[1,42]]
15:26:16 <Baughn> kmc_: Also. no.
15:26:17 <Philonous> DerisionSnort: "newtype Id a = Id { unId :: x } " *
15:26:24 <largos> can cabal-install install ghc 6.12?
15:26:35 <kmc_> DerisionSnort, basically you can ask that the (Show a) constraint be present when you call the Id constructor, and it will "bake in" the typeclass implementation into your datatype
15:26:46 <kmc_> and to do this properly, you have to use the GADT syntax for declaring types
15:26:51 <c_wraith> aeron: several ways.  <* and *> do what you want, but parsec also has a built-in function for that.
15:26:54 <sshc> Baughn: that only works for tuples with the same type
15:27:08 <sshc> @src zipWith7
15:27:08 <lambdabot> Source not found. My mind is going. I can feel it.
15:27:18 <Baughn> sshc: Where do tuples enter into it? zipWith isn't about them in the first place.
15:27:19 <aeron> c_wraith: I saw "parens" but I'm not sure how to apply it in this manner
15:27:20 <kmc_> > getZipList $ (:) <$> ZipList [show, show . succ] <*> ZipList [2,3]
15:27:21 <lambdabot>   No instance for (GHC.Num.Num [a -> GHC.Base.String])
15:27:21 <lambdabot>    arising from the li...
15:27:26 <v_> The last version of Grammatical Framework is great!
15:27:28 <kmc_> > getZipList $ ($) <$> ZipList [show, show . succ] <*> ZipList [2,3]
15:27:29 <lambdabot>   ["2","4"]
15:27:33 <kmc_> hehe, $ ($) <$>
15:29:27 <Baughn> @quote kmc_ $ ($) <$>
15:29:28 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
15:29:33 <Baughn> @remember kmc_ $ ($) <$>
15:29:33 <lambdabot> I will remember.
15:30:45 <aeron> c_wraith: something like   char '(' *> many1 digit <* char ')'   ?
15:30:53 <sshc> @define zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h : zipWith7 z as bs cs ds es fs gs hs
15:30:54 <c_wraith> aeron: yes
15:31:00 <sshc> @let zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h : zipWith7 z as bs cs ds es fs gs hs
15:31:01 <lambdabot>  <local>:1:89:
15:31:02 <lambdabot>      Couldn't match expected type `[t] -> [a]'
15:31:02 <lambdabot>             aga...
15:31:15 <sshc> @let zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h : zipWith8 z as bs cs ds es fs gs hs
15:31:16 <lambdabot>  Defined.
15:31:25 <sshc> I feel better now.
15:31:41 <Baughn> sshc: You got it wrong.
15:32:01 <BONUS> hey yo, anyone know how to call a custom syscall through Haskell?
15:32:02 <sshc> Baughn: I got it right.
15:32:08 <Baughn> sshc: Wrong.
15:32:15 <sshc> Baughn: Right.
15:32:15 <Baughn> BONUS: foreign import ccall etc.
15:32:21 <Baughn> sshc: Right, that's wrong.
15:32:24 <BONUS> ah
15:32:36 <SamB_XP_> custom syscalls are generally considered to be a bad idea, though
15:32:36 <sshc> Baughn: ;)
15:32:45 <SamB_XP_> how come you can't just use an ioctl ?
15:32:55 <sshc> Baughn: one counter-example is all that's needed
15:33:20 <sshc> and yes, it's not the complete definition
15:33:22 <Baughn> sshc: You forgot the termination clauses.
15:33:25 <Baughn> All eight of them.
15:33:51 <sshc> @let zipWith8 _ _ _ _ _ _ _ _ _ = []
15:33:53 <lambdabot>  Defined.
15:34:04 <sshc> I didn't think lambdabot got do that with let
15:34:08 <Baughn> ..that's cheating. ;_;
15:34:11 <Baughn> > zipWith8
15:34:15 <lambdabot>   mueval-core: Time limit exceeded
15:34:17 <SamB_XP_> Baughn: how is that cheating ?
15:34:30 <Baughn> SamB_XP_: He used haskell!
15:34:43 <SamB_XP_> hehehehehe
15:34:52 <SamB_XP_> I like that definition of cheating ;-P
15:36:51 <Baughn> > zipWith7
15:36:53 <lambdabot>   {()->{()->{()->{()->{()->{()->{()->()}}}}}}}->
15:36:53 <lambdabot>    []->
15:36:53 <lambdabot>      []->
15:36:53 <lambdabot>        []-...
15:37:09 <Baughn> sshc: Also, I don't think \bot /does/ let you define multiple clauses that way. Must use ;.
15:37:57 <Baughn> > zip :: Int -> Int -> (Int,Int) -- ^ I kinda like this..
15:37:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:37:58 <lambdabot>         against inferred type ...
15:38:04 <sshc> @let zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h; zipWith8 z as bs cs ds es fs gs hs; zipWith7 _ _ _ _ _ _ _ _ = []
15:38:04 <lambdabot>   Parse error: SemiColon
15:38:20 <sbenitezb> any graph database (embeded or server) available for haskell?
15:38:21 <sshc> I got it wrong.
15:38:29 <Baughn> @undefine
15:38:33 <sshc> @let zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h; let zipWith8 z as bs cs ds es fs gs hs; zipWith7 _ _ _ _ _ _ _ _ = []
15:38:34 <lambdabot>   Parse error: KW_Let
15:38:43 <sshc> @undefine zipWith8
15:38:48 <sshc> @let zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h; zipWith8 z as bs cs ds es fs gs hs; zipWith7 _ _ _ _ _ _ _ _ = []
15:38:49 <lambdabot>   Parse error: SemiColon
15:38:53 <sshc> @undefine zipWith8
15:38:59 <Baughn> @undefine takes no parameters
15:39:06 <Baughn> Nor would a parse-error'd definition take
15:39:25 <sshc> @let zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h zipWith8 z as bs cs ds es fs gs hs; zipWith8 _ _ _ _ _ _ _ _ = []
15:39:25 <lambdabot>   arity mismatch for 'zipWith8'
15:39:41 <Baughn> @let foo 1 = 2
15:39:42 <lambdabot>  Defined.
15:39:44 <Baughn> @let foo 2 = 3
15:39:46 <lambdabot>  Defined.
15:39:49 <Baughn> > map foo [1..]
15:39:50 <lambdabot>   [2,3,* Exception: <local>:(1,0)-(2,8): Non-exhaustive patterns in function ...
15:39:58 <Baughn> Oh. It does handle it.
15:40:00 <Liskni_si> @let zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h; zipWith8 _ _ _ _ _ _ _ _ _ = []
15:40:01 <lambdabot>  Defined.
15:40:27 <Baughn> @let foo "sugar" = "spice"
15:40:28 <lambdabot>  <local>:4:0:
15:40:28 <lambdabot>      Multiple declarations of `L.foo'
15:40:28 <lambdabot>      Declared at: <local>...
15:40:49 <Liskni_si> aha
15:40:50 <Baughn> > map foo [1..]
15:40:51 <lambdabot>   [2,3,* Exception: <local>:(1,0)-(2,8): Non-exhaustive patterns in function ...
15:41:03 <v_> > take 100 map foo [1..]
15:41:04 <lambdabot>   Couldn't match expected type `[a]'
15:41:04 <lambdabot>         against inferred type `(a1 -> b)...
15:41:05 <Liskni_si> @let zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h : zipWith8 z as bs cs ds es fs gs hs; zipWith8 _ _ _ _ _ _ _ _ _ = []
15:41:06 <lambdabot>  <local>:4:89:
15:41:07 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]...
15:41:07 <Baughn> @let foo n = succ n
15:41:08 <lambdabot>  <local>:4:0:
15:41:08 <lambdabot>      Multiple declarations of `L.foo'
15:41:08 <lambdabot>      Declared at: <local>...
15:41:17 <v_> > take 100 (map foo [1..] )
15:41:17 <Baughn> > foo "sugar"
15:41:18 <lambdabot>   [2,3,* Exception: <local>:(1,0)-(2,8): Non-exhaustive patterns in function ...
15:41:18 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
15:41:18 <lambdabot>    arising from a use of `L....
15:41:39 <v_> Ah, snap. I'm doing it wrong
15:41:58 <aeron> c_wraith: can you explain how i'd apply "parens" directly?
15:42:14 <Baughn> v_: Well, foo is only defined for 1/2
15:42:27 <v_> I know, i wasn't paying attention
15:43:21 <Liskni_si> @undefine zipWith8
15:43:23 <Liskni_si> @let zipWith8 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) = z a b c d e f g h : zipWith8 z as bs cs ds es fs gs hs; zipWith8 _ _ _ _ _ _ _ _ _ = []
15:43:24 <lambdabot>  Defined.
15:43:25 <v_> It's late...
15:43:34 <v_> > foo "what is this"
15:43:35 <lambdabot>   Not in scope: `foo'
15:43:45 <v_> Right! Makes sense
15:43:52 <BONUS> water you guys doing? why not just do zipWith8 f a b c d e f g h = let (*) = zipWith id in map f a * b * c * d * e * f * g * h
15:44:21 <v_> BONUS: one-liners are the best
15:45:55 <BONUS> > let zipWith8 f a b c d e f g h = let (*) = zipWith id in map f a * b * c * d * e * f * g * h in zipWith8 (\a b c d e f g h -> a+b+c+d+e+f++g+h) [1,2,3] [1,2,3] [1,2,3] [1,2,3] [1,2,3] [1,2,3] [1,2,3] [1,2,3]
15:45:56 <lambdabot>   Conflicting definitions for `f'
15:45:56 <lambdabot>  In the definition of `zipWith8'
15:46:52 <c_wraith> aeron: If I'm reading the type signature correctly, it'd just be parens (many1 digit)
15:47:09 <v_> IceDane: welcome back ;-)
15:47:18 <IceDane> v_: hey man! Thanks.
15:48:07 <sshc> @let zipWith1024 z (a:as) (b:bs) (c:cs) (d:ds) (e:es) (f:fs) (g:gs) (h:hs) (i:is) (j:js) (k:ks) (l:ls) (m:ms) (n:ns) (o:os) (p:ps) (q:qs) (r:rs) (s:ss) (t:ts) (u:us) (v:vs) (w:ws) (x:xs) (y:ys) (z:zs) (aa:aas) (ab:abs) (ac:acs) (ad:ads) (ae:aes) (af:afs) (ag:ags) (ah:ahs) (ai:ais) (aj:ajs) (ak:aks) (al:als) (am:ams) (an:ans) (ao:aos) (ap:aps) (aq:aqs) (ar:ars) (as:ass) (at:ats) (au:aus) (av:avs) (aw:aws) (ax:axs) (ay:ays) (az:azs) (ba:bas) (bb:bbs) (bc:bcs)
15:48:07 <lambdabot>   Parse error: SemiColon
15:48:09 <BONUS> > let zipWith8 ff a b c d e f g h = let (*) = zipWith id in map ff a * b * c * d * e * f * g * h in zipWith8 (\a b c d e f g h -> a+b+c+d+e+f++g+h) [1,2,3] [1,2,3] [1,2,3] [1,2,3] [1,2,3] [1,2,3] [1,2,3] [1,2,3]
15:48:11 <lambdabot>   Ambiguous type variable `b' in the constraints:
15:48:11 <lambdabot>    `GHC.Num.Num b'
15:48:11 <lambdabot>      ari...
15:48:14 <BONUS> aaaa
15:51:22 <yrlnry> Suppose I want to define a functor, Set, and then I want to say that (Set a) is an instance of Monad whenever Eq a.
15:51:35 <yrlnry> Is there a way to do that, perhaps a ghci language extension?
15:52:19 <Baughn> instance (Eq a) => Monad (Set a) ?
15:52:53 <yrlnry> I don't think so, because Set is an instance of Monad; (Set a) has the wrong kind.
15:53:01 <yrlnry> But I'll try it, since I have no better ideas.
15:53:02 <Peaker> Baughn: can't, cause the instance should be higher kinded
15:53:12 <Baughn> Ah, point.
15:53:25 <BONUS> afaik Set can't be made an instance of Monad
15:53:27 <yrlnry> Yes, just so.
15:53:33 <Peaker> yrlnry: there's a package called RMonad, I think -- that should allow this
15:53:49 <yrlnry> Peaker:  Looking, thanks.
15:53:51 <Peaker> for "restricted monads" (Monads that allow restricting their type parameter)
15:54:06 <BONUS> because (>>=) is forall a b m. m a -> (a -> m b) -> m b
15:54:12 <aeron> c_wraith: it tells me it's expecting TokenParser st but inferring GenParser Char st1 [Char] for: parens (many1 digit)
15:54:18 <BONUS> and the forall really means for all
15:54:23 <Peaker> I think the Haskell type system should probably allow such restrictions -- that might mean changing the way types remain unparameterized
15:54:23 <BONUS> Peaker: interesting, didn't know about that
15:54:57 <yrlnry> Peaker:  according to the advertisement, it will do something like what I want.  Thanks again.
15:55:02 <c_wraith> aeron: Oh.  It's in one of the sub-packages that only works with restricted parser types.  I'd just ignore the existence of that function, for the time being
15:55:07 <Peaker> BONUS: well, the "Monad m" restriction should carry with it more restrictions in this case
15:55:19 <Peaker> yrlnry: cool
15:55:46 <ddarius> aeron: parens is a field in a TokenParser struct.
15:55:56 <kmc_> > let xs = ("foo" :: [a]) in xs
15:55:57 <lambdabot>   Couldn't match expected type `a'
15:55:57 <lambdabot>         against inferred type `GHC.Types.C...
15:56:17 <ddarius> aeron: The usual usage pattern is, tp = TP.makeTokenParser language; parens = TP.parens tp
15:56:40 <Peaker> I wonder what a nice syntax to give context to type parameters would be
15:57:26 <yrlnry> I guess it makes some sense.  the compiler can't tell, from a given appearance of >>=, whether it should carry the (Eq a) restriction.
15:57:46 <yrlnry> I can of course define my own restricted analogue of >>= etc., but then I don't get do-notation.
15:58:23 <Peaker> yrlnry: it should be able to tell, because of the (Monad m) restriction
15:58:25 <Saizan_> Peaker, yrlnry: http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions/ClassFamilies
15:58:44 <bd_> yrlnry: There was a paper back a while ago that suggested how to make a Set monad with incoherent interfaces
15:58:47 <yrlnry> Peaker:  but not all monads have the (Eq a) restriction.
15:58:58 <yrlnry> bd_:  I'd love a cite, if you have one.
15:59:10 <yrlnry> OK, babysitter going home.  Must go.  Thanks again.
16:00:06 <bd_> yrlnry: trying to find it, but not much luck :)
16:00:17 <Peaker> Saizan_: I don't think that extension is what I want here
16:00:33 <emile_m> Is there any efficient way to convert (for example) a list of 4 Word8's to Word32?
16:00:55 <emile_m> ... or I have to do it manually ith bits?
16:01:03 <emile_m> s/ith/with/
16:01:09 <Botje> manually, i guess
16:01:21 <Peaker> yrlnry: Well, when you have an Eq (Maybe a) in scope,  how is it that you have (Eq a) in scope too?  Because one class context is allowed to carry more class contexts with it.  The (Monad Set) context could be able to also carry context about the type parameter of Set, even if the class is higher kinded
16:01:23 <BONUS> what about just mapping fromIntegral
16:01:39 <aeron> c_wraith: alright, cool. well, I'm glad you pointed out *> because that's good to know but it salso says there's no instance of applicative for the parser type :PP
16:02:01 <BONUS> > fromIntegral (3 :: Word8) :: Word32
16:02:03 <lambdabot>   3
16:02:10 <bd_> Found it!
16:02:16 <bd_> yrlnry: http://www.haskell.org/pipermail/haskell-cafe/2007-January/021086.html  actually uses GADTs :)
16:02:18 <c_wraith> yet another reason I don't use Parsec. :)
16:02:22 <BONUS> > map fromIntegral [3 :: Word8, 4, 5, 6] :: [Word32]
16:02:24 <lambdabot>   [3,4,5,6]
16:02:27 <Peaker> I guess it is a little different that (Monad m)  would carry with it a context restriction on all "a"s that "m" is applied to, rather than just the "a" that "m" itself was built with
16:02:40 <Saizan_> Peaker: when you've Eq (Maybe a) in scope you don't have Eq a in scope too.
16:02:57 <bd_> yrlnry: unfortunately it needs a specific return' for Ord types :/
16:03:18 <emile_m> BONUS: I need something like this: x = 0x12345678; b1 = 0x12; b2 = 0x34, ...
16:03:19 <aeron> c_wraith: what's your parsing tool of choice?
16:03:32 <Peaker> Saizan_: what's the rationale?
16:03:34 <Saizan_> ?type let foo :: Eq (Maybe a) => Maybe a -> Bool; foo (Just x) = x == x in foo
16:03:35 <lambdabot>     Could not deduce (Eq a) from the context (Eq (Maybe a))
16:03:35 <lambdabot>       arising from a use of `==' at <interactive>:1:59-64
16:03:35 <lambdabot>     Possible fix:
16:03:51 <c_wraith> aeron: I've been using uu-parsinglib
16:04:09 <Peaker> Saizan_: overlapping instances?
16:04:23 <HaskellLove> I updated my blog while reading on F# and C#, it is work in progress, havent done whole book yet. I have some notes here and there comparing Haskell, but not much... Anyone interested in general in functional programming might want to check it out: http://haskelllove.wordpress.com/
16:04:25 <saml> hey it says Haskell Platform is recommended
16:04:37 <saml> can i install Haskell Platform and upgrade to latest ghc seamlessly?
16:04:45 <Peaker> Saizan_: oh, I see, you provide it, you don't get it --
16:04:47 <Saizan_> Peaker: i guess it's that an instance Eq a => Eq (Maybe a) produces a function to transform a dictionary for 'a' into one for 'Maybe a', not the inverse
16:04:47 <saml> i just uninstalled Haskell Platform to install ghc latest
16:05:24 <xerox> saml: I hear that's not the way to go
16:05:27 <Peaker> Saizan_: though it could have worked, I think
16:05:44 <saml> xerox, what is "that" ?   haskell platform -> latest ghc?
16:05:53 <saml> cabal intall ghc ?
16:06:15 <Raynes> saml: It could be tricky going from the platform to the latest ghc. I'm personally just waiting for the next platform release.
16:06:15 <mreh> preflex: seen mmorrow
16:06:15 <preflex>  mmorrow was last seen on #ghc 11 hours, 39 minutes and 38 seconds ago, saying: but ended up not needed any of the info i got from there
16:06:22 <saml> i'm on windows
16:06:24 <saml> oh ok
16:06:25 <xerox> saml: right, users should install the platform, although ghc gets released, there's a month of sync process that eventually becomes the new haskell platform
16:07:06 <mreh> @google mmorrow
16:07:07 <lambdabot> No Result Found.
16:07:07 <saml> ghc 6.12.1 fixes copy-paste issue in windows cmd.exe
16:07:11 <Peaker> anyway,  instance Ord a => Monad (Set a) where ... should be possible (with some different syntax I can't think of to make it higher kinded)
16:08:43 <roostaj> @src digitToInt
16:08:44 <lambdabot> Source not found. You untyped fool!
16:09:05 <Saizan_> Peaker: it'd be a pain to type any Monad polymorphic code
16:09:17 <Peaker> Saizan_: type-check?
16:09:41 <Saizan_> Peaker: you'd have to add typeclass contraints for any type that goes inside the monad
16:11:12 <Saizan_> since you wouldn't know if it is allowed in there or not
16:11:50 <Peaker> Saizan_: the constraint would be only in the instance, I think (maybe I'm missing something)
16:12:02 <Peaker> (e.g: Ord for Monad Set)
16:12:45 <HaskellLove> Can we say "type inferrence supports generic programming in Haskell" or it has nothing to do with generic programming?
16:13:09 <Saizan_> Peaker: say you write mapM
16:13:18 <Saizan_> ?src mapM
16:13:19 <lambdabot> mapM f as = sequence (map f as)
16:13:29 <Saizan_> ?src sereven
16:13:29 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:13:32 <Saizan_> ?src sequence
16:13:32 <lambdabot> sequence []     = return []
16:13:32 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:13:32 <lambdabot> --OR
16:13:32 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:13:43 <mreh> I can feel it, my mind is going...
16:14:17 <Saizan_> well, mapM is not a good example, since it only uses m [b] values
16:14:52 <Saizan_> though in general, in do-notation etc.. a single function could use m A for many A, that don't appear in the type of the arguments or results
16:15:12 <Saizan_> currently this poses no problem, because of parametricity of >>= and return
16:15:35 <Peaker> Saizan_: I think I see the problem -- the code that chooses the instance can call code that has its own hidden type parameters for the "m"
16:15:47 <Saizan_> but if they can impose a constraint you've to record in the type of this function all these A
16:15:58 <Saizan_> yeah
16:15:59 <Peaker> so the instance chooser may have the context - but it won't propagate inside properly
16:16:30 <Saizan_> well, you'd have to record it to even require it
16:16:31 <Peaker> yeah, damn, I was hoping it was possible to have a Monad instance for Set that doesn't pollute normal polymorphic Monad.. apparently its inherent
16:17:13 <Peaker> in an ideal world everyone uses RMonad?
16:17:34 <Saizan_> i wouldn't think so
16:17:48 <v_> Plato wouldn't use it
16:17:55 <mreh> if I abstract a stochastic process to RandomGen g => State s (Rand g a) can I still lift functions to the inner monad?
16:18:07 <mreh> the state transformation isn
16:18:29 <mreh> 't stochastic, just the result, but the state transition is functionally dependant on the result
16:18:50 <mreh> infact, it is just the same as the result in this case
16:19:10 <mreh> (where s -> (result, s'))
16:19:41 <mreh> i'm talking bollocks, ignore me
16:20:24 <mreh> v_++
16:21:18 <v_> ;-)
16:21:47 <mreh> he likes his HTML forms though
16:21:51 <Peaker> Saizan_: RMonad's embed/unEmbed seem to be good enough
16:22:21 <v_> Maybe Plato loves lambda calculus
16:23:07 <v_> Emphasis on the Maybe data type
16:23:20 <mreh> :t Just Plato
16:23:21 <lambdabot> Not in scope: data constructor `Plato'
16:23:39 <v_> Haha
16:23:57 <mreh> I think we've taken enough things out of context today
16:24:15 <v_> Indeed. We mustn't spoil it.
16:24:39 <v_> And Now For Something Completely Different.
16:24:55 <v_> It's
16:25:22 <Peaker> I wonder how RMonad's embed works -- a GADT in order to embed a class constraint in a data constructor?
16:25:38 <kmc_> where's this RMonad?
16:25:50 <Peaker> cabal install rmonad,  Control.RMonad*
16:26:29 <Cale> RMonad is a really cute trick
16:26:44 <Cale> I sort of want that trick to apply to all classes in a uniform way.
16:26:56 <ddarius> c_wraith: Parsec 3 has an Applicative instance and adding one for Parsec 2 is three lines of code (or two or one depending on how you lay it out)
16:27:06 <Cale> Some sort of generalised suitability constraints for constructor classes
16:27:16 <Peaker> hmm.. what does a class context do to a normal non-GADT's data constructor?
16:27:40 <Peaker> data Blah c = Context c => Blah
16:27:45 <Cale> Peaker: Basically nothing. It constrains the constructor's type.
16:27:59 <Peaker> Cale: then I don't understand: http://hackage.haskell.org/packages/archive/rmonad/0.4.1/doc/html/src/Data-Suitable.html#Constraints
16:28:29 <Peaker> look at the instance Suitable Set a  -- why do they have the class constraint on the data family in there?
16:28:58 <mreh> @let data Philosopher = Plato | Socrates
16:28:59 <lambdabot>  Invalid declaration
16:29:38 <astroboy> novice question: could someone explain me what the --> operator do
16:29:44 <Cale> Peaker: Oh, on that side of the = it's what it means in a GADT
16:29:52 <Cale> Peaker: That's not a Haskell 98 data declaration
16:29:56 <mreh> @let data PostSocraticPhilosopher = Plato | Socrates
16:29:56 <lambdabot>  Invalid declaration
16:30:02 <Peaker> Cale: ah, that clears it up, thanks
16:30:33 <Peaker> astroboy: --> in what module?
16:30:34 <Raevel> oops the impossibuble happened :-(
16:31:15 <Cale> astroboy: --> isn't taken by the standard libraries, it could mean anything
16:31:16 <astroboy> Peaker: something like [ className =? c --> doFloat | c <- myFloats ] (yes I am configuring xmonad :P )
16:31:23 <astroboy> ahhh ok it's an xmonad thing
16:31:30 <astroboy> I see
16:31:36 <Cale> http://hackage.haskell.org/packages/archive/xmonad/0.9.1/doc/html/XMonad-ManageHook.html#v%3A--%3E
16:31:42 <Peaker> in Haskell, operators are just ordinary names anyone can define
16:31:52 <astroboy> yeah I know that
16:32:04 <Cale> astroboy: It appears to apply a condition to the ManageHook
16:32:05 <Peaker> seems it's basically an alias for "when"
16:32:08 <Peaker> @type when
16:32:09 <astroboy> they make us study haskell and I love it btw
16:32:10 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:32:21 <Cale> Peaker: Well, lifted to Query Bool
16:32:22 <Peaker> astroboy: where?
16:32:38 <Peaker> Cale: what's Query?
16:32:42 <astroboy> Peaker: imperial college. first lesson: haskell. I was in awe ahahah
16:33:02 <mreh> who was it that said Haskell operators are so long they have a perspective?
16:33:06 <Cale> another XMonad thing... ReaderT Window X
16:33:10 <tass> Grrr... I'm going crazy with this thing :<
16:33:16 <Peaker> astroboy: awesome. You're destroying the myth that people don't hate Haskell because "nobody's forced to learn it" :)
16:33:32 <Peaker> Cale: Ah -- that's another use case for conal's Boolean package maybe :)
16:33:38 <mreh> astroboy: I wish i went to Imperial
16:33:49 <mreh> actually...
16:33:52 <v_> People don't hate Haskell, they just don't understand it.
16:34:11 <v_> Myth confirmed.
16:34:19 <astroboy> Peaker: actually the lecturer is really really good. We have haskell lectures just for 4 months - sadly
16:34:19 <mreh> astroboy: haskell in your first year?
16:34:26 <Peaker> v_: Some people on Reddit asked "How come everyone hates almost any language, but with Haskell, you only hear people talking about how good it is?" and then people answer "people hate languages that they are forced to use"
16:34:30 <astroboy> mreh: yes, first programming thing we do
16:34:47 <astroboy> (I'm doing computing)
16:34:48 <mreh> astroboy: undergrauate?
16:34:52 <astroboy> yes yes
16:34:58 <mreh> computer science
16:35:12 <astroboy> it's called computing here eeheh
16:35:12 <ben> I hate haskell because the gtk bindings are confusing as fuck, coming from the C/C++ API >:[
16:35:20 <Cale> There are things I could find to complain about Haskell, but they seem so silly in comparison with the things I would say about most of the languages that people use.
16:35:22 <Peaker> ben: heh
16:35:27 <mreh> computing is crunching numbers
16:35:28 <v_> Experiment #345: force people to learn Ruby
16:35:33 <Nafai> ben: They took a little getting used to, but I don't mind it.
16:35:38 <mreh> well, i suppose calling it computer science is no better
16:35:50 <Cale> ben: dcoutts is the guy to talk to :)
16:35:57 <Nafai> My computer science degree never mentioned Haskell
16:35:59 <mreh> "it's like calling that knife science"
16:35:59 <Peaker> Cale: that's not "hate" yet though :)  Its easy to find C, C++, Java, etc haters.  Hard to find Haskell haters
16:36:07 <astroboy> mreh: yeah it's a stupid name, I would prefer to be called scientist rather than... computer?
16:36:16 <mreh> I
16:36:21 <mreh> 'm just doing my postgrad at UCL
16:36:30 <mreh> join #haskell-blah and we'll chat
16:36:36 <kmc_> hmm, i dislike the argument "you only hate it because you're dumb"
16:36:47 <kmc_> people say that about xkcd all the time
16:36:57 <Cale> Computer science is such a funny name, since it's not about computers and it's not really science.
16:36:58 <mreh> kmc_ I can't stand xkcd
16:37:00 <kmc_> i think it's mostly true for Haskell but i still won't say it
16:37:00 <ben> I was mostly confused that some Gtk signals seem to have onWhatever functions to connect handlers to, and a bunch of others expected you to use `on` on them :X
16:37:03 <ColonelJ> Cale: it is a science
16:37:17 <mreh> kmc_ good for you
16:37:17 <Cale> ColonelJ: It doesn't depend directly on the scientific method.
16:37:22 <ColonelJ> Cale: computers are _that unpredictable
16:37:23 <ben> Does maths?
16:37:28 <kmc_> (except... crap, just did)
16:37:38 <v_> I remember having a talk with a C guy. He hated Haskell because it was... "bloated and useless". Heh, cracks me every time I remember that
16:37:43 <Cale> ben: Mathematics doesn't either, and mathematics is also not a science.
16:37:44 <Peaker> Cale: "computational mathematics" maybe?
16:37:46 <v_> C/C++
16:37:47 <sproingie> Peaker: there's always harrop
16:37:52 <stroan> v_: I've had similar experiences
16:37:52 <ben> Cale: What would you call it? The closest I can think of is algorithms? I guess I could call you people algorithm engineers...
16:37:56 <astroboy> the most common hete rgument is "ghc is 500mb", no doubt lol
16:37:58 <Peaker> sproingie: heh
16:38:07 <kmc_> v_, versus C++ that is extremely funny
16:38:11 <BONUS> i always liked "computing"
16:38:12 <HaskellLove> agree with ben
16:38:16 <sproingie> @quote C/C++
16:38:17 <lambdabot> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
16:38:18 <kmc_> "informatics"
16:38:23 <sproingie> @quote F#/
16:38:23 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
16:38:25 <v_> The most ironic situation, a c++ guy calling Haskell bloated, ahaahaa
16:38:46 <kmc_> also screw people who call a language "C/C++"
16:38:50 <mreh> kmc/kmc++
16:38:50 <sproingie> ghc can add a lot of bloat
16:38:53 <Cale> ben: I would call it a branch of mathematics which would cover most of it fairly well. I suppose it's a branch of mathematics which cross-cuts the pure/applied spectrum pretty well.
16:38:55 <ColonelJ> I was a bit annoyed by the fact that haskell decompressed to >500MB when I installed it yesterday
16:38:58 <kmc_> screw them harder when they say "C" in person to mean both
16:38:59 <sproingie> the dynamic linking stuff should help things greatly
16:39:05 <v_> people coding in a C/C++ style make me sad
16:39:09 <Cale> ColonelJ: GHC?
16:39:19 <ColonelJ> sorry the Haskell platform
16:39:20 <mreh> v_ it's called C style :)
16:39:20 <ben> I have a student job coding C/C++, it is not my fault!
16:39:34 <v_> Yep, C style in any language. In Ocaml for eg.
16:39:36 <v_> Ugh
16:39:36 <mreh> can I haz job plz?
16:39:37 <ColonelJ> I think it contains everything, so it's probably my fault
16:39:40 <lament> it's not that insane, considering there're C/C++ compilers
16:39:44 <loop> v_: what's that style like, "C with classes" ?
16:39:45 <Cale> ColonelJ: That's less than one TV episode :)
16:39:52 <v_> Indeed
16:40:04 <v_> Algol is still haunting us
16:40:23 <v_> It's not C-style. It's Algol-style.
16:40:26 <mreh> v_: haskell is a better imperative language
16:40:27 <ColonelJ> Cale: This hard drive is really small, TV episodes can go on DVDs
16:40:35 <v_> mreh: guess so
16:40:48 <Peaker> mreh: Haskell isn't better than C for various purposes..
16:41:01 <ColonelJ> Can you use pointers in Haskell?
16:41:11 <v_> We never said that. But a language is a tool. C is good for _____. Haskell is good for
16:41:15 * Cale has basically 150GB of TV sitting in his torrents directory.
16:41:16 <ColonelJ> (Maybe using some strange IO trickery)
16:41:23 <v_> _______________________________________
16:41:25 <v_> Yeah.
16:41:26 <Cale> ColonelJ: yeah, there's Ptr
16:41:34 <mreh> ColonelJ: [IORef]
16:41:43 <ben> mreh: Some guys at university managed to squeeze out funding to pay me to work on my high school pal's open source project, it is only a job in a very vague, formal sense. But there is C and C++ involved, so I felt entitled to mention it.
16:41:53 <Cale> ColonelJ: Well, if you want real pointers which can be used with C code
16:41:55 <v_> Cale: I have 90 gb of TV shows
16:42:00 <v_> Good stuff mostly
16:42:17 <v_> I'm too lazy to write them all on DVDs
16:42:23 <ColonelJ> Cale: well... could you write an OS in haskell?
16:42:26 <mreh> ben: I'd get out of that racket
16:42:26 <Cale> ColonelJ: If you just want something equivalent for IO Haskell code, you can use IORef which is a safer reference type
16:42:36 <Cale> ColonelJ: OSes have been written in Haskell
16:42:44 <mreh> rly?!
16:42:45 <v_> But as POCs
16:43:02 <v_> That reminds me of www.barrelfish.org/
16:43:16 <v_> I still don't know if it's Haskell stuff
16:44:08 <Cale> House, and Osker
16:44:11 <v_> A serious OS made in C + Haskell would be something
16:44:18 <Peaker> C is nicer than Haskell when I want to have a really good idea and control of memory management, and somewhat better at CPU management too
16:44:37 <mreh> Peaker: horse for courses
16:44:45 <mreh> s/horse/horses/
16:44:55 <mreh> that would be bad, if there was just one horse
16:44:57 <Peaker> porting drivers to Haskell, and running the GHC RTS on the bare metal would be a nice OS -- no kernel / user mode distinction
16:45:08 <Cale> http://ogi.altocumulus.org/~hallgren/ICFP2005/
16:45:20 <ColonelJ> I have lectures across from where those Microsoft Research guys are based
16:45:43 <v_> Microsoft and Haskell. An interesting combination
16:45:50 <sproingie> been that way a while
16:45:51 <v_> Combinators!
16:45:58 <ben> Isn't Microsoft basically funding GHC at this point
16:46:02 <astroboy> the guy who invented haskell is working for microsoft
16:46:03 <mreh> Peaker is fantasising about software
16:46:04 <astroboy> yeah
16:46:07 <sproingie> they employ the Simons
16:46:10 <v_> I know, Peyton Jones
16:46:12 <v_> Good man
16:46:18 <lament> Simon "Peyote" Jones
16:46:27 <v_> Haha
16:46:55 <v_> Peyote. That reminds me of Castaneda and his books
16:47:02 <Peaker> mreh: I fantasize about an FRP-from-ground-up OS, where the behaviors/events migrate automatically on the network to accomodate good/bad network performance
16:47:08 <Peaker> Simon Python Jones
16:47:36 <sproingie> forall p. Simon p Jones
16:47:38 <v_> I dream of Haskell-machines
16:47:45 <mreh> Peaker: I need to get to know FRP, i want to make games, seems like a pretty good abstraction
16:47:58 <v_> that won't dies like those Lisp-machines back in the 80s
16:48:02 <v_> *won't die
16:48:06 <Cale> v_: Do you know about the Reduceron?
16:48:13 <sproingie> lisp machines never died, they just became emacs
16:48:33 <v_> Cale: reading about them now
16:48:34 <lament> from bad to worse
16:48:41 <v_> lol emacs
16:49:02 <v_> The next version of Emacs will have a bigger beard
16:49:10 <Peaker> mreh: unfortunately -- it is quite difficult to implement correctly
16:49:30 <mreh> Java Concrete Machine, that would be mad
16:49:34 <Peaker> mreh: but FRP is a really simple model that's easy to learn
16:49:42 <sproingie> there are cpus that execute java bytecode
16:49:58 <mreh> Peaker: what is the underlying model?
16:50:09 * v_ is waiting for those DNA machines
16:50:22 <mreh> v_ animals?
16:50:33 <sproingie> animal!  eat drums!
16:50:34 <Peaker> mreh: You have time-varying values (modeled as Behavior a = Time -> a), and discretely-occuring events (modeled as monotonically growing [(Time, a)] lists)
16:50:49 <v_> Animals don't have keyboards
16:51:01 <Peaker> mreh: then, you have a bunch of combinators/instances for Behavior and Event - that allow composing reactive programs together
16:51:29 <Peaker> mreh: for example,   snapshot :: Behavior a -> Event b -> Event (a, b)  -- samples the time varying Behavior at exactly the times of the Event
16:51:55 <mreh> mreh, so it's all pure code
16:52:01 <mreh> haha
16:52:05 <mreh> Peaker ^
16:52:15 <stroan> Am I correct in saying there is no way to express the identity functor in Haskell?
16:52:23 <mreh> stroan: no
16:52:28 <Peaker> mreh: Yep! The idea is to write reactive code purely
16:52:37 <stroan> no I'm wrong, or no I'm right ;)
16:52:45 <mreh> > let myid x = x in myid "stroan"
16:52:46 <lambdabot>   "stroan"
16:52:55 <mreh> oh, functor!
16:52:57 <Peaker> mreh: The mathematical *model* (how you think of) Behavior a   is   Time -> a   but the implementation is something else
16:53:30 <stroan> but the functor? such that one could say "succ `fmap` 1" given an appropreite functor
16:53:36 <mreh> Peaker, what is it, moands? something to hide the state
16:53:46 <Peaker> mreh: Behavior and Event are also Monads (in the exact way their model is, except with Event, you have to ignore the (Time, ) part for the monad instance
16:54:16 <Peaker> mreh: its not using monads to "hide the state", the monad instance of Behavior/Event is nothing like the monad instance of IO
16:54:24 <xerox> stroan: runIdentity (succ `fmap` Identity 1)
16:55:03 <Peaker> mreh: the monad instance of Event is less important.  The monad instance for Behavior, is simply that of normal functions.  If you have a Behavior that yields a Behavior, as in:  Behavior (Behavior a)  what you essentially have is (Time -> Time -> a)  and the monadic "join" on that is to simply flatten it into a Behavior of the final result
16:55:17 <mreh> Peaker: and it's probably nothing like Cheesecake, what's your point it's nothing like IO?
16:55:46 <mreh> Peaker (>=>)?
16:55:57 <tass> I can't use guards in an if's else statement?
16:56:18 <xerox> tass: you can use them in a case
16:56:38 <tass> Right, I'll have to read up on cases then
16:56:51 <mreh> the whole point of guards is to get rid of your if elses, if you've got lots of nested ones
16:57:29 <stroan> xerox: aye, that makes sense. but it's not quite the same, as Identity a /= a, except through further transform
16:57:32 <tass> mreh: I kind of want some else if's
16:57:49 <xerox> stroan: that's not *much* difference there
16:57:53 <mreh> tass: guards are used to specify some extra conditions on a pattern you've matched
16:58:09 <Paczesiowa> tass: case () of _ | p1 = e1; | p2 = e2
16:58:23 <xerox> stroan: I mean they are naturally isomorphic, except for the new bottom
16:58:48 <stroan> oh I know.
16:58:59 <Peaker> mreh: its nothing like IO - in that it has tractable denotational semantics
16:59:10 <tass> Hmm..
16:59:18 <tass> This will make for some ugly code (tm)
16:59:19 <stroan> but I just wanted to see if a true identity was possible
16:59:33 <tass> Or rather, suboptimal code.
16:59:37 <Peaker> mreh: A time varying value, a (Time -> a), has a denotational meaning.  An (IO a) value has operational meaning, but not semantic meaning
16:59:41 <stroan> it makes sense that it is not possible, I just wanted to check
16:59:56 <Peaker> not denotational semantic meaning, that is -- at least not a practical-to-use one
17:00:05 <mreh> Peaker: I have to read up on denotational semantics
17:00:25 <mreh> tass: paste it
17:00:27 <mreh> @paste
17:00:27 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:01:27 <ColonelJ> @lambda
17:01:27 <lambdabot>   unlambda: Parse error at end of file
17:01:45 <tass> mreh: I'm on it
17:02:20 <ColonelJ> @lambda 1
17:02:22 <lambdabot>   unlambda: Unknown operator '1'
17:02:53 <Peaker> mreh: the idea of denotational semantics -- is that the (external, visible) meaning of something is *purely* a composition of the meanings of its sub-expressions.  So the meaning of  4+6  is composed purely from the meanings of 4, (+), and 6.  The meaning of the composition is the composition of the meanings
17:03:19 <ColonelJ> what other kinds of semantics are there?
17:03:31 <sproingie> so i finally learned arrows, and i read the yampa arcade paper, and i can't say i'm really compelled to use it
17:03:41 <Peaker> mreh: consider an IO operation like:  (readMVar m) -- it's visible meaning depends not only on the meaning of readMVar and that of the definition of "m", but also on the meanings of others who might write to the mvar
17:03:45 <mreh> Peaker: ah, same as referential transparency?
17:03:46 <sproingie> mostly because what i'm looking for is discrete events and yampa's more about continuous behaviors
17:03:48 <Peaker> ColonelJ: axiomatic, operational
17:03:59 <Peaker> mreh: Related, but not the same
17:04:15 <sproingie> thinking i'll either go with hasim or chp for my purposes
17:05:38 <Peaker> mreh: with denotational semantics, you get local reasoning about the meaning and its correctness. Instead of proving a program correct by following all possible execution paths/etc, you prove a program correct by reasoning about the much simpler meanings and their compositions. By proving that your implementation adheres to the denotation
17:06:43 <mreh> Peaker: makes sense, sounds how I program Haskell
17:06:53 <mreh> atleast, how I think I do
17:07:30 <mreh> you program with the properties of the set, not the individual elements
17:12:13 <ColonelJ> Hmm, I'm trying to design a programming language, and basically I came up with the idea of separating pure functional code, and stuff with side effects as sort of sequence point annotations on the functional code...  Would this work, and what problems may arise?
17:13:04 * olognation aims to focus on "Real World Haskell" for 30 minutes.  Go!
17:13:17 <mreh> olognation:
17:13:29 <gwern> ColonelJ: sequence point annotations?
17:14:00 <kmc_> Peaker, denotational semantics typically give meaning in terms of mathematical objects, right?
17:14:19 <olognation> mreh, Olognation, at your service.
17:14:21 <kmc_> i wouldn't call those objects simpler than the programs -- in an important way, they are equivalent
17:14:32 <mreh> olognation: broke your concentration
17:14:35 <kmc_> it's more that math already has a ton of results we can borrow from
17:14:42 <ColonelJ> gwern: so like if you call print or something, rather than actually doing it, it just marks that point as a place where some side effect takes place
17:14:43 <kmc_> olognation, i keep reading your name as 'olegnation'
17:14:48 <tass> mreh: http://pastebin.com/d1019148e
17:15:11 <tass> Sorry that it took some time, a process on my system decided to start eating system resources, took some time to kill it
17:15:11 <olognation> mreh:  Dammit!
17:15:24 <olognation> I shouldn't have *told* you!
17:15:34 <olognation> kmc_:  I thought of that.
17:15:37 <Peaker> kmc_: Yeah
17:15:46 <gwern> ColonelJ: how would this differ frmo just not  using any type sigs and lettting the compiler infer the monadic types?
17:15:47 <kmc_> haha
17:15:57 <tass> mreh: The interesting stuff is in "Plumbing"
17:15:59 <Peaker> kmc_: The mathematical meanings are significantly simpler than the program.. the program is not equivalent - it has much more detail
17:16:11 <Peaker> kmc_: it adheres to the model, but the model doesn't adhere to a particular implementation
17:16:15 <tass> Including my beautiful *cough* regex
17:16:16 <olognation> kmc_, That's one of the three readings of "olog".
17:16:40 <kmc_> O(log)?
17:16:41 <olognation> The other one is an abstraction of "Biology, Psychology, Geology", etc.
17:16:46 <kmc_> or perhaps o(log)
17:16:52 <olognation> kmc: Oh shit!  Good one!
17:16:59 <olognation> Hadn't actually thought of that one yet.
17:17:01 <ColonelJ> gwern: I only heard about monads yesterday, I don't understand them enough to answer that question
17:17:08 <kmc_> even O(log n) ation
17:17:10 <tass> mreh: What I'm working on is a way for it to separate server messages from legitimate one's that it should parse for eventual commands.
17:17:14 <gwern> ColonelJ: very good then. carry on
17:17:16 <sproingie> @quote oleg
17:17:16 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
17:17:25 <olognation> kmc_, Ha!  That's great.
17:17:25 <kmc_> @quote stare
17:17:25 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
17:17:25 <lambdabot> just don't know what it means.
17:17:28 <kmc_> @quote stare
17:17:28 <lambdabot> PhilipWadler says: To see that "in" and "out" are inverses, stare at the following diagram
17:17:28 <lament> @quote type system
17:17:29 <lambdabot> No quotes for this person. Just try something else.
17:17:39 <lament> @quote system
17:17:40 <lambdabot> TomMD says: c.h.o should move to ARM... then a distributed system would be needed.
17:17:44 <kmc_> heh, "what it means"... denotations again
17:18:08 <kmc_> Peaker, you make a good point
17:18:12 <kmc_> that the maths is more abstrac
17:18:18 <tass> mreh: Particularily the latter parts in the Listener
17:18:26 <lament> @quote type
17:18:27 <lambdabot> dons says: so i suspect dynamically typed langs, that just work (bugs and all) will always be more popular with the masses since most people don't understand bug theory ;)
17:18:42 <kmc_> bug theory
17:18:45 <kmc_> is bug theory type theory?
17:19:08 <Peaker> kmc_: in a sense, denotational semantics allows us to discard irrelevant implementation details when proving correctness or talking about meanings of our programs
17:19:35 <kmc_> but the denotational model of a functional language is usually very close to the language itself
17:19:44 <kmc_> since the mathematical way to talk about functions *is* the lambda calculus
17:19:53 <mreh> tass: can you process the messages as a list?
17:20:07 <tass> I'm already doing that, kinda.
17:20:19 <tass> Or, I _am_ doing that..
17:20:31 <tass> Look at the pastebin and the function ircSPLIT
17:21:21 <tass> mreh: Problem being that it fucks up on anything that isn't formatted the way I want it, such as server messages ; )
17:21:35 <dolio> kmc_: Denotational models of functional languages are (in my experience) weird set theoretic constructions.
17:21:41 <dolio> Domains or topological spaces or something.
17:21:49 <Peaker> kmc_: well, programs may or may not have denotational models
17:21:51 <mreh> tass: irc has a protocol, anything that doesn't conform should be ignored, not too difficult I should hope
17:21:54 <Peaker> kmc_: not just languages
17:21:56 <mreh> irc is a protocl!
17:22:00 <matt_f> any advice for writing a function with type "convert :: (Int -> Bool) -> ((Int, a) -> Bool)" where the first argument is being applied to the first element of the tuple in the second argument?
17:22:12 <ColonelJ> I found most irc servers didn't really follow the protocol properly or just made things up
17:22:16 <tass> mreh: PM?
17:22:17 <sproingie> anything that doesn't conform becomes a new mode letter in someone's ircd
17:22:42 <dolio> Or just plain sets if you're working with the simply typed lambda calculus.
17:22:48 <kmc_> dolio, that's interesting
17:23:00 <kmc_> so they're models in the sense of logic?
17:23:08 <kmc_> a set which lambda-bound variables range over?
17:23:18 <astroboy> would someone explain me the reason of the haskell habit of putting the commas in list at the start of newlines?
17:23:33 <astroboy> is it stupid just for me or is there a reason for that
17:23:57 <monochrom> Yes to both.
17:24:00 <largos> astroboy: I *think* it makes it easier to comment out single entries
17:24:25 <astroboy> largos: mhm you're right :P
17:24:30 <dolio> Like, you can define the naturals by 0 = {}, 1 = {0}, 2 = {0,1} ..., and N = {0,1,2,...}. Then the denotation of your natural datatype is that set N.
17:24:37 <kmc_> astroboy, i've seen it in many languages
17:25:04 <astroboy> it seems extremely popular in haskell anyway and I never understood why
17:25:08 <astroboy> now I do anyway hehe
17:25:09 <kmc_> e.g. initializer lists in C++
17:25:25 <dolio> And functions A -> B are set theoretic functions, which in a ZF-alike set theory, are defined as suitable subsets of cartesian products.
17:25:46 <dolio> So the denotation of A -> B is a subset of the cartesian product of the denotation of A and the denotation of B.
17:25:51 <monochrom> I disagree. As long as there are n-1 commas for a list of n, there will be always a problem commenting out a single entry.
17:26:02 <sproingie> only the first
17:26:04 <kmc_> doesn't Haskell usually allow a separator at the end
17:26:11 <sproingie> > [1,2,]
17:26:12 <lambdabot>   <no location info>: parse error on input `]'
17:26:16 <kmc_> > do { return 3 ; } :: [Int]
17:26:17 <lambdabot>   [3]
17:26:27 <kmc_> > let x = 3 ; in x
17:26:28 <lambdabot>   3
17:26:37 <kmc_> > let x = 3 ; ; y = 4 in x
17:26:38 <lambdabot>   3
17:26:40 <sproingie> that's semicolons
17:26:49 <kmc_> sure
17:26:49 <sproingie> no such luck with commas
17:26:54 <kmc_> even in a record?
17:27:15 <kmc_> no luck :/
17:27:20 <dolio> kmc_: You have to get fancier for things with polymorphism, like System F or Haskell, because _Polymorphism is not Set-Theoretic_.
17:27:36 <kmc_> because it's impredicative?
17:27:41 <dolio> Yeah.
17:27:47 <kmc_> what about naive set theory ;)
17:28:09 <dolio> I don't know.
17:28:14 <monochrom> But there is some convenience for auto-indenters if you start every line with spaces then either "[" or ",".
17:28:34 <dolio> There's also _Polymorphism is Set-Theoretic, Constructively_, so it works there somehow.
17:28:39 <dolio> I still have to read those papers. :)
17:28:43 <HugoDaniel> while using the do notation for a monad, is there any way to run only a give line if a certain thing is valid ?
17:28:51 <sproingie> if
17:29:05 <monochrom> when
17:29:06 <c_wraith> HugoDaniel: if it's MonadPlus, you can use guard
17:29:15 <EvanR_> hence
17:29:15 <sproingie> oh yah when is easier
17:29:16 <HugoDaniel> when seems like the thing i want
17:29:17 <HugoDaniel> :)
17:29:44 <dolio> kmc_: I think it's the impredicativity that causes problems for classical set theory, though.
17:29:48 <c_wraith> oh, I  suppose when is a better match for what you actually asked.  it also doesn't require MonadPlus
17:30:13 <kmc_> :t when
17:30:14 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:30:41 <kmc_> guard is useful when the thing you want to do otherwise is "exit the whole do block", which can't be done using only Monad
17:30:53 <kmc_> (you can of course put the remaining stuff in a conditional)
17:31:07 <c_wraith> @instances MonadPlus
17:31:08 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:31:55 <HugoDaniel> so i can write something like "s' <- when (s == Nothing) insertIt (return $ Just s)" ?
17:32:06 <HugoDaniel> or whatever :P
17:32:22 <kmc_> HugoDaniel, using <- with "when" is useless
17:32:24 <gwern> is there any symbol for 'join'?
17:32:27 <kmc_> because the value will always be ()
17:32:31 <HugoDaniel> how should i use it then ?
17:32:47 <kmc_> HugoDaniel, with the non-binding form of do-statement
17:32:48 <HugoDaniel> oh
17:32:50 <monochrom> @type Control.Monad.when
17:32:51 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:32:58 <monochrom> You will receive () anyway.
17:32:59 <HugoDaniel> is there a when that binds ?
17:33:01 <HugoDaniel> :P
17:33:03 <kmc_> do { when (x == 3) (putStrLn "bleh") }
17:33:07 <kmc_> you'd have to give a default value
17:33:14 <ski> gwern : `mu'
17:33:16 <dolio> kmc_: Girard's semantics for System F, for example, uses constructions where there's sort of a bottom in the denotation of every type, though, even though it's strongly normalizing.
17:33:24 <gwern> ski: really?
17:33:30 <kmc_> dolio, strange... what does bottom do, then?
17:33:33 <gwern> μ you mean?
17:33:34 <monochrom> If the condition is false, what polymorphic value would you want?
17:33:39 <ski> and `eta' for `return'
17:33:56 <kmc_> HugoDaniel, when itself won't bind, it's an ordinary function
17:34:00 <HugoDaniel> is there a fromMaybeM ?
17:34:04 <HugoDaniel> something like that :P
17:34:05 * hackagebot upload: LibZip 0.0.1 - Partial bindings to libzip to read zip archives. (SergeyAstanin)
17:34:12 <kmc_> but you could do "x <- if p then stuff else return y"
17:34:21 <HugoDaniel> hmm ok
17:34:26 <kmc_> HugoDaniel, no, and I've often wanted it
17:34:35 <kmc_> of type (MonadPlus m) => Maybe a -> m a
17:34:37 <monochrom> if-then-else is so much easier if you have a value in mind for when the condition is false.
17:34:39 <kmc_> :t maybe mzero return
17:34:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
17:34:43 <kmc_> ^^^^ that's the one
17:34:55 <tensorpudding> :t maybe
17:34:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:35:04 <kmc_> :t (if' .) . return
17:35:05 <lambdabot> Not in scope: `if''
17:35:07 <kmc_> grr
17:35:36 <tensorpudding> @src maybe
17:35:36 <lambdabot> maybe n _ Nothing  = n
17:35:36 <lambdabot> maybe _ f (Just x) = f x
17:35:43 <dolio> kmc_: I don't really remember why it's there. But the model is built in terms of "linear coherence spaces" rather than sets.
17:35:45 <ColonelJ> :t (if .) . return
17:35:46 <lambdabot> parse error on input `.'
17:35:54 <kmc_> if isn't a function
17:36:00 <dolio> And coherence spaces are more like domains, I think.
17:36:12 <kmc_> @let if' p t f = if p then t else f
17:36:13 <lambdabot>  Defined.
17:36:15 <kmc_> :t (if' .) . return
17:36:16 <lambdabot> forall t (f :: * -> *). (Functor f, Monad f) => Bool -> f (t -> t -> t)
17:36:32 <EvanR_> if x Then y Else z = ;)
17:36:37 <kmc_> hehe
17:36:51 <dolio> Of course, you can build all those out of sets, but the denotations aren't just ordinary sets with a single element for each canonical syntactic value and such.
17:36:54 <kmc_> it should be if_then_else_ ;P
17:37:09 <monochrom> I don't understand why people go out of their ways to avoid if-then-else. Sure, pattern matching supersedes some uses, and some combinators supersedes some other. But there are still cases when if-then-else is simpler than contriving yet another combinator.
17:37:33 <kmc_> monochrom, i don't go out of my way but i still rarely use it
17:37:42 <EvanR_> ifThenElse True y z = y
17:37:42 <kmc_> and i do dislike introducing another syntactic form for something so trivial
17:37:48 <EvanR_> ifThenElse False y z = z
17:37:53 <kmc_> imo if / then / else is a language wart
17:38:33 <ColonelJ> what instead of if / then / else?
17:38:45 <kmc_> i'd like to remove it, if only to emphasize to beginners early on that most of their favorite special case constructs are ordinary functions in Haskell
17:38:55 <kmc_> ColonelJ, a regular function like if' i defined above
17:38:57 <kmc_> :t if'
17:38:58 <lambdabot> forall t. Bool -> t -> t -> t
17:39:17 <ColonelJ> oh right I see, so it's still there, just in a functional form
17:39:18 <kmc_> in other languages if is usually special for reasons of laziness
17:39:24 <kmc_> ColonelJ, it'd be in the Prelude
17:39:34 <kmc_> i always favor library functions over new linguistic constructs
17:39:45 <ski> sometimes, `if .. else .. then ..' would be natural
17:39:46 <kmc_> because you can go read the library and see directly how they work, in terms of simpler things
17:40:06 <EvanR_> does haskell have trinary operator ? : ;)
17:40:13 <ski> gwern : any reason you're wondering ?
17:40:16 <kmc_> in the case of this monad stuff, it'd be good to have "if p else return x then $ do ..."
17:40:18 <ColonelJ> doesn't really need it with if...then...else...
17:40:44 <kmc_> if ... then ... else ... is exactly what (?:) does in C
17:40:53 <EvanR_> ? : would be smaller, but since if then else seems not as useful it doesnt matter
17:40:58 <ski> EvanR_ : yes, it is called `if'-`then'-`else'
17:41:04 <EvanR_> .. i know!
17:41:13 <kmc_> EvanR_, it would break the use of (:) for lists
17:41:28 <kmc_> and of (?) for... other things?
17:41:34 <EvanR_> whats ? used for
17:41:59 <kmc_> dunno
17:42:02 <kmc_> but probably something
17:42:03 <kmc_> :t (?)
17:42:08 <lambdabot> Not in scope: `?'
17:42:29 <EvanR_> hahaha *steals it for his own nefarious purposes*
17:42:50 <kmc_> in some lib at least
17:42:51 * ski wonders why hoogle replies "<lambdabot> Test.HUnit.Base ("
17:43:17 <ColonelJ> @let ? p t f = if p then t else f
17:43:18 <lambdabot>   Parse error: VarSym "?"
17:43:41 <monochrom> (?)
17:43:49 <ColonelJ> @let (?) p t f = if p then t else f
17:43:50 <lambdabot>  Defined.
17:43:59 <EvanR_> > ? True 0 1
17:43:59 <lambdabot>   <no location info>: parse error on input `?'
17:44:07 <kmc_> > True ? 0 1
17:44:08 <EvanR_> > True ? 0 1
17:44:08 <lambdabot>   Not in scope: `?'
17:44:08 <lambdabot>   Not in scope: `?'
17:44:13 <kmc_> > (True ? 0) 1
17:44:14 <lambdabot>   Not in scope: `?'
17:44:32 <ColonelJ> True ? 0 1
17:44:35 <ColonelJ> > True ? 0 1
17:44:35 <kmc_> > let (?) p t f = if p then t else f in True ? 0 1
17:44:37 <lambdabot>   Not in scope: `?'
17:44:37 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:44:37 <lambdabot>    `GHC.Num.Num t' arising f...
17:44:51 <kmc_> > let (?) p t f = if p then t else f in True ? 'x' 'y'
17:44:52 <lambdabot>   Couldn't match expected type `t1 -> t'
17:44:52 <lambdabot>         against inferred type `GHC.T...
17:44:58 <kmc_> > let (?) p t f = if p then t else f in (True ? 'x') 'y'
17:44:59 <lambdabot>   'x'
17:45:05 <kmc_> > let (?) p t f = if p then t else f in True ? 'x' $ 'y'
17:45:06 <lambdabot>   'x'
17:45:13 <kmc_> hmm ?$ is pretty good
17:46:01 <kmc_> (:) is reserved for types, can't rebind it
17:46:25 <kmc_> > let (?) p t f = if p then t else head f in True ? 'x' : "y"
17:46:26 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> GHC.Types.Char'
17:46:27 <ski> (s/types/data constructors/)
17:46:27 <lambdabot>         a...
17:46:33 <EvanR_> so wait how do you get ? to work
17:46:51 <kmc_> it's right there
17:47:03 <EvanR_> with $
17:47:59 <EvanR_> kmc_: why doesnt it work withotu $
17:48:27 <ColonelJ> > True ? 1 : 0
17:48:28 <lambdabot>   Not in scope: `?'
17:48:36 <zong_sharo>  i want to do queries over set of items (items has a properties, query is a one or more of predicates over properties)
17:48:41 <zong_sharo>   sound's like sql, but i don't want use it. any advice on something better than O(n)?
17:48:45 <mrsolo> hmm how do you do  memoization in haskell?
17:48:50 <tensorpudding> True ? 1 0
17:48:55 <tensorpudding> > True ? 1 0
17:48:56 <lambdabot>   Not in scope: `?'
17:49:11 <EvanR_> > (?) True 1 0
17:49:12 <lambdabot>   Not in scope: `?'
17:49:23 <tensorpudding> > let (?) p a b = if p then a else b in True ? 1 0
17:49:25 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:49:25 <lambdabot>    `GHC.Num.Num t' arising f...
17:50:45 <EvanR_> ah, it forgot the definition
17:51:45 <ColonelJ> > let (?) p (a,b) = if p then a else b
17:51:46 <lambdabot>   not an expression: `let (?) p (a,b) = if p then a else b'
17:51:54 <ColonelJ> @let (?) p (a,b) = if p then a else b
17:51:55 <lambdabot>  Defined.
17:52:05 <joe__> how can I error out from a haskell function?
17:52:05 <ColonelJ> > ? True (1,0)
17:52:06 <lambdabot>   <no location info>: parse error on input `?'
17:52:14 <ColonelJ> > True ? (1,0)
17:52:15 <lambdabot>   1
17:52:19 <ColonelJ> finally
17:52:36 <joe__> just stop further processing on the list that the function is operating on.
17:52:44 <c_wraith> joe__: why do you want to? (this is seriously an important question)
17:52:57 <sshc> @let (?) c a b = if c then a else b
17:52:58 <lambdabot>  <local>:1:0:
17:52:58 <lambdabot>      Equations for `?' have different numbers of arguments
17:52:58 <lambdabot>     ...
17:53:07 <HaskellLove> What is the equal to c structs in Haskell?
17:53:10 <sshc> @undefilee (?)
17:53:14 <sshc> @undefine (?)
17:53:18 <sshc> @let (?) c a b = if c then a else b
17:53:19 <lambdabot>  Defined.
17:53:28 <ColonelJ> > True ? 1 0
17:53:29 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:53:29 <lambdabot>    `GHC.Num.Num t' arising f...
17:53:30 <sshc> > (?) True 1 0
17:53:31 <lambdabot>   1
17:53:36 <sshc> there you go.
17:53:43 <EvanR> HaskellLove: did you read any of the tutorials
17:53:52 <joe__> function x | length > 7 = "error"
17:54:09 <joe__> function x | otherwise = do something here...
17:54:18 <EvanR> > True ? 1 0
17:54:19 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:54:19 <lambdabot>    `GHC.Num.Num t' arising f...
17:54:34 <c_wraith> joe__: at a higher level, why error?  Why not return a Maybe?
17:54:39 <EvanR> > (True ? 1) 0
17:54:40 <lambdabot>   1
17:54:59 <HaskellLove> EvanR i am comparing with f# and c# now... of course i read but forgot now... I guess, the Data keyword ?
17:55:05 <joe__> i just want to stop further processing and get out..
17:55:08 <matt_f> @let (?!) b (a1, a2) = if b then a1 else a2
17:55:09 <lambdabot>  Defined.
17:55:13 <EvanR> HaskellLove: yes, data
17:55:24 <matt_f> True ?! ("if true", "if false")
17:55:25 <ColonelJ> > True ? 1 ! 0
17:55:26 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
17:55:26 <lambdabot>         against inferred t...
17:55:27 <c_wraith> joe__: Will laziness suffice?
17:55:34 <matt_f> > True ?! ("if true", "if false")
17:55:35 <lambdabot>   "if true"
17:55:41 <matt_f> > False ?! ("if true", "if false")
17:55:43 <lambdabot>   "if false"
17:56:14 <joe__> c_wraith: i mean if the length of the first item of the list is greater  than 7 characters, do not do anything and get out
17:56:23 <ski> joe__ : you want to abort the whole program ? sure, `error "STOP !"' is good for that
17:56:34 <c_wraith> joe__: the answer really, really, *really* depends on what you're doing in the case when you "get out"
17:56:38 <joe__> yes, error the whole program
17:57:03 <EvanR> @let {?? True t _ = t; ?? False _ f = f;}
17:57:03 <lambdabot>   Parse error: VarSym "??"
17:57:10 <joe__> c_wraith, i think what ski mentions is what I am looking for.
17:57:13 <EvanR> @let {(??) True t _ = t; (??) False _ f = f;}
17:57:13 <lambdabot>  <local>:3:0: parse error on input `{'
17:57:46 <c_wraith> joe__: that is a very rare desired behavior, though.  Hence asking lots of questions.
17:57:55 <EvanR> @let (??) True t _ = t; (??) False _ f = f;
17:57:56 <lambdabot>  Defined.
17:58:10 <joe__> sorry c_wraith.
17:58:20 <ski> joe__ : of course, using `error' signifies that some error has actually occured in the program. if you want the program to terminate in a "successful" way, then `error' is probably not what you want
17:58:24 <EvanR> > (1<3) ?? 'foo' $ 'bar'
17:58:24 <lambdabot>   <no location info>:
17:58:25 <lambdabot>      lexical error in string/character literal at chara...
17:58:34 * EvanR goes to his interpreter
17:58:48 <c_wraith> EvanR, '' is for characters, not strins
17:58:53 <EvanR> yeah
17:58:57 <joe__> what do you mean by "successful" way? I want the program to abort.
17:59:15 <joe__> return error "get out" would be something that I will check.
17:59:58 <ski> joe__ : like e.g. if you tell your application that you're finished, and would like to stop the program. that's "successful termination"
18:00:01 <kmc_> > error "bleh"
18:00:02 <lambdabot>   * Exception: bleh
18:00:08 <c_wraith> joe__: often times, you want a program to recover from errors in some way.  calling error is not a very friendly way to handle errors, if you're doing it within the program.
18:00:16 <EvanR> from what ive seen the functional part of the program shouldnt crash, ever. no exceptional situations can occur that you cant avoid
18:00:41 <kmc_> joe__, if you need to propogate exceptional conditions *without* the entire program exiting immediately, you could use Maybe or Either monad, or exceptions in IO, or other stuff
18:00:58 <kmc_> you can throw an error in pure code and catch it in IO, iirc
18:01:12 <joe__> c_wraith, i think what u are talking makes sense.
18:01:22 <kmc_> urgh, "u"
18:01:35 <kmc_> been an infestation of "u" lately
18:01:38 <joe__> c_wraith, I will change the program design to adjust for it.
18:01:39 <patch-tag> xchat is nice!
18:01:42 <EvanR> just read it as 'oo' ;)
18:01:46 <kmc_> patch-tag, not really
18:01:57 <SamB_XP_> can't those guys just go play on utube ?
18:01:58 <patch-tag> tired of erc-select
18:02:02 <c_wraith> EvanR: calling error is a reasonable thing to do when your function encounters a situation that should be impossible without there having been a programming mistake.
18:02:19 <kmc_> and re earlier, "True ? 0 1" doesn't work because it's "True ? (0 1)".  since function app binds more closely than infix
18:02:21 <kmc_> and so,
18:02:22 <kmc_> :t 0 1
18:02:23 <lambdabot>     Ambiguous type variable `t' in the constraint:
18:02:23 <lambdabot>       `Num t' arising from the literal `1' at <interactive>:1:2
18:02:23 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
18:02:34 <kmc_> :t 0 (1 :: Int)
18:02:35 <lambdabot> forall t. (Num (Int -> t)) => t
18:02:36 <EvanR> c_wraith: trying to understand what you just said. you mean error is useful for catching programming mistakes?
18:02:43 <kmc_> > 0 (1 :: Int)
18:02:44 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> a))
18:02:44 <lambdabot>    arising from the lite...
18:03:03 <kmc_> yes, programmer errors are different from exceptions
18:03:08 <Peaker> > 0 (1 :: Int) :: Int
18:03:09 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Int))
18:03:09 <lambdabot>    arising f...
18:03:10 <c_wraith> EvanR: Yes.  If a function detects a condition that indicates a programming mistake, that's a good time to use error
18:03:12 <kmc_> although you sometimes represent both the same way
18:03:20 <SamB_XP_> EvanR: like "The impossible happened: "
18:03:28 <kmc_> "error" is useful basically for things that are impossible, but you can't prove it in Haskell's type system
18:03:30 <EvanR> so like assert
18:03:40 <kmc_> assert is a check
18:03:40 <ski> (`error' is useful for *signaling* programmer mistakes)
18:03:45 <kmc_> error is used when you already know an error occurred
18:03:51 <kmc_> often you *can* prove it, which is why we prefer things like pattern matching over "head"
18:03:54 <SamB_XP_> kmc: or WOULD be impossible, if the programmer wasn't such an idiot
18:04:09 <kmc_> if you know a list is non-empty, but can't prove it to ghc, "head" is appropriate
18:04:18 <kmc_> if your idiot user might give you an empty list, pattern match and handle it more gracefully
18:04:31 <kmc_> with the caveat that sometimes the line is blurred and sometimes the user deserves what's coming to them
18:04:45 <kmc_> and sometimes you're writing a small program and can't be arsed to handle errors properly
18:05:11 <sproingie> * Exception: user terminated
18:05:11 <koda> hi i have just install ghc 6.12 and get this error
18:05:11 <patch-tag> I try to program in a total style... use Safe lib, never use head
18:05:13 <koda> Could not find module `Network':
18:05:16 <kmc_> sproingie, haha
18:05:18 <kmc_> > fix error
18:05:19 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:05:20 <koda> can you help me?
18:05:33 <sproingie> > fix fix
18:05:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:05:39 <kmc_> > fix show
18:05:40 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:05:53 <kmc_> koda, are you a Haskell library developer?
18:05:55 <SamB_XP_> > fix u
18:05:56 <lambdabot>   Couldn't match expected type `a -> a'
18:05:57 <lambdabot>         against inferred type `Simple...
18:06:05 <sproingie> @type u
18:06:06 <lambdabot> Expr
18:06:07 <koda> kmc: no
18:06:08 <kmc_> > let u = ("durr"++) in fix u
18:06:10 <lambdabot>   "durrdurrdurrdurrdurrdurrdurrdurrdurrdurrdurrdurrdurrdurrdurrdurrdurrdurrdu...
18:06:14 <ski> > fix read
18:06:15 <kmc_> > let u = ("durr "++) in fix u
18:06:16 <lambdabot>   "durr durr durr durr durr durr durr durr durr durr durr durr durr durr durr...
18:06:18 <lambdabot>   mueval-core: Time limit exceeded
18:06:22 <c_wraith> koda: it means that 6.12 doesn't come with the Network package.
18:06:30 <EvanR> kmc_: wouldnt user input be validated at the source...
18:06:34 <kmc_> koda, the supported version for ordinary users is still 6.10.4, through the Haskell Platform
18:06:51 <kmc_> if you want to try 6.12.1 you will have to do things like install the "network" package yourself
18:06:55 <EvanR> function accepts Maybe a
18:06:57 <kmc_> we have done perhaps a poor job of communicating this
18:07:07 <koda> oh i see
18:07:07 <kmc_> EvanR, you can't always validate before doing your computation
18:07:19 <kmc_> what if the user input is a Turing machine and it's an error for it to halt?
18:07:26 <koda> the thing is 6.10 doesn't compile any more under snow leopard
18:07:34 <kmc_> ah, that is a good reason then :)
18:07:41 <EvanR> kmc_: user input seems to be a large non trivial problem...
18:07:45 <roostaj> if i wanted to write -- map (filter (`elem` ['a'..'z'])) $ map convertToWords [20..30] -- without the parenthesis around (filter (`elem`.. ))... how would i write it?
18:07:54 <kmc_> i will let others help you, as i am not an expert of this wild cat of the coldness
18:08:22 <kmc_> roostaj, you probably wouldn'n
18:08:25 <ski> roostaj : `let foo = filter (`elem` ['a'..'z']) in map (foo . convertToWords) [20..30]'
18:08:29 <kmc_> not without restructing the code entirely
18:08:39 <koda> thanks anyways kmc_
18:08:40 <roostaj> kmc_: good, thought i was crazy
18:09:01 <kmc_> basically if a function needs 2 args each of which is an application, one will have to be parenthesized
18:09:05 <roostaj> kmc_: was playing with $ and .
18:09:21 <roostaj> kmc_ gracias
18:09:24 <kmc_> i like ski's answer though -- it also fuses the maps
18:09:29 <kmc_> though ghc should do that anyway
18:09:49 <kmc_> map (filter (`elem` ['a'..'z']) . convertToWords) [20..30]
18:09:54 <roostaj> ski: :)
18:10:40 <roostaj> ah thats nice
18:15:19 <roostaj> so is it difficult in general to "chain" $s
18:15:28 <roostaj> not difficult
18:15:29 <roostaj> i guess
18:15:32 <roostaj> just tricky?
18:15:49 <tass> roostaj: Haskell _is_ tricky
18:15:54 <roostaj> tass: :D
18:15:58 <Peaker> roostaj: you aren't supposed to chain $'s
18:16:12 <tass> roostaj: At least until you get used to it, I guess : P
18:16:27 <roostaj> Peaker: well i guess you _CANT_
18:16:36 <roostaj> correct?
18:16:39 <Peaker> roostaj: You can, but its better to chain .'s instead
18:16:44 <roostaj> Peaker: hmm
18:16:48 <Peaker> roostaj: if you have f $ g $ h $ x  -- its better to use: f . g . h $ x
18:16:57 <roostaj> Peaker: ah ok
18:17:14 * tass is bollocksing with some regex to separate server jibberish from legitimate input.
18:17:19 <roostaj> Peaker: thanks
18:17:32 <tass> And it's proving to be a VERY tough nut to crack.
18:18:18 <Peaker> tass: maybe parsec would be easier?
18:18:47 <tass> Peaker: But I _like_ my regex : P
18:19:03 <tass> I mean, how can you _not_ fall in love with ircSPLIT s = (s =~ "^:(.+)!~(.+)\\s([A-Z]*)\\s(.+)\\s:(.+)$") !! 0
18:19:06 <tass> : D
18:19:24 <medfly> I don't get it myself
18:25:38 <ski> (why `(!! 0)' rather than `head' ?)
18:26:31 <tensorpudding> the former uses 100% fewer alphabetical characters
18:26:45 <tensorpudding> and is slightly more obfuscated
18:30:11 <DevHC> hey if we properly restrict haskell code from opening any file or doing low level operations like asm/c calls, is haskell good as hack-safe virual-machine-ish but fast language?
18:30:52 <DevHC> so someone could upload any code to my "haskell server" and i wouldn't fear from the server being taken over (hijacked)
18:31:11 <c_wraith> > text "I am a functional haskell bot"
18:31:12 <lambdabot>   I am a functional haskell bot
18:31:21 <DevHC> cuz.. the generated code is segfault-free in case of a bug-free compiler, access to resources is restricted, etc.
18:31:30 <DevHC> is that correct?
18:31:53 <c_wraith> Basically.  There are docs on how lambdabot is set up to be safe
18:32:19 <c_wraith> It involves restricting imports and preventing execution of IO from loaded code
18:37:04 <kmc> DevHC, correct
18:37:15 <kmc> "bug-free compiler" is the big caveat
18:37:28 <kmc> i'm guessing lambdabot uses the GHCi bytecode interpreter, which should be an extra layer of safety
18:37:45 <kmc> there are also OS-level ways to sandbox a process that have minimal overhead
18:38:08 <kmc> especially low overhead if you're not allowing IO anyway -- you can just kill the program if it tries any of the IO syscalls
18:38:24 <DevHC> > (answer "can u be hacked?")
18:38:25 <lambdabot>   Not in scope: `answer'
18:38:39 <kmc> @faq Can Haskell be used to create an unhackable IRC bot?
18:38:40 <lambdabot> The answer is: Yes! Haskell can do that.
18:39:32 <tass> @faq Is Haskell the most awesome programming language on earth?
18:39:32 <lambdabot> The answer is: Yes! Haskell can do that.
18:39:42 <tass> Cool stuff.
18:39:42 <DevHC> kill? rather return with a fail. but some IO should be allowed, in restricted directories
18:40:01 <kmc> DevHC, sure, you can send it a signal that it can catch
18:40:08 <kmc> like SIGTERM ;)
18:40:19 <DevHC> @faq Is Haskell's answer to every question "Yes!"?
18:40:19 <lambdabot> The answer is: Yes! Haskell can do that.
18:40:23 <Peaker> @faq Can Haskell make a stone so heavy that even Haskell cannot lift?
18:40:23 <lambdabot> The answer is: Yes! Haskell can do that.
18:40:30 <kmc> i think if you allow any IO at all, you have to be extra careful
18:40:32 <medfly> lol
18:40:34 <c_wraith> it's much harder to jail IO.  Even at the OS level.
18:40:35 <medfly> Haskell is chuck norris
18:40:38 <joe__> wondering if there is another function opposite to filter? filter removes some invalid stuff from the list. how about just getting only the invalid stuff into a list?
18:40:38 <kmc> it is much better to disallow it, at both the OS and type level
18:40:48 <medfly> (I don't get why @faq is so popular as a command)
18:40:51 <kmc> joe__, invert your sense of "invalid"
18:40:55 <tensorpudding> @faq Can Haskell tell me a lie?
18:40:56 <lambdabot> The answer is: Yes! Haskell can do that.
18:40:58 <kmc> > filter (not . isAlphaNum) "Hello, world!"
18:40:59 <lambdabot>   ", !"
18:41:08 <DevHC> kmc lol no sigterms plx
18:41:17 <Peaker> @faq Can Haskell lift the stone that is so heavy that even Haskell couldn't lift?
18:41:17 <lambdabot> The answer is: Yes! Haskell can do that.
18:41:18 <joe__> yes, the not will help. thanks.
18:42:02 <DevHC> @faq
18:42:02 <lambdabot> The answer is: Yes! Haskell can do that.
18:42:07 <kmc> @. elite faq
18:42:08 <lambdabot> +He aN5W3r IS: Y3S! h4Sx3LL cAN d0 +|-|At.
18:42:15 <Philonous> Peaker Who said Haskell and Haskell are the same guys?
18:42:17 <kmc> @. vixen faq
18:42:18 <lambdabot> church is my favourite computer scientist.
18:42:33 <kmc> @. elite nixon
18:42:34 <lambdabot> Your 8oy5 wi|1 b3 HOmE F0r C|-|rI$7Ma$.
18:42:37 <kmc> @. elite nixon
18:42:38 <lambdabot> 7|-|iz iz a 9Re47 daY 4 Fr4N(3!
18:42:54 <medfly> @help
18:42:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:42:57 <medfly> @help vixen
18:42:57 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
18:43:30 <kmc> @vixen are u a bot?
18:43:31 <lambdabot> no, why? do i seem "botty"?
18:43:37 <medfly> :))
18:43:52 <DevHC> @faq Can Haskell prove that P==NP?
18:43:53 * medfly wonders how that works
18:43:53 <lambdabot> The answer is: Yes! Haskell can do that.
18:43:58 <DevHC> holy fucking shitfucks
18:44:18 <tensorpudding> @. elite vixen
18:44:19 <lambdabot> iN +0
18:45:42 <kmc> @. elite nixon
18:45:43 <lambdabot> YouR BOY$ wIl| 8e |-|O/\/\3 4 ChRIstm4z.
18:45:52 <medfly> @. vixen nixon
18:45:53 <lambdabot> what was the question again?
18:46:09 <medfly> @. vixen nixon
18:46:09 <lambdabot> i can't think of an example right now
18:47:40 <Cale> @vixen asl
18:47:41 <lambdabot> 19/f/California
18:48:19 <medfly> I think it'd be funny if you could do something like @. vixen keal but see what both say :)
18:48:40 <tensorpudding> @. elite vixen nixon
18:48:41 <lambdabot> Y3a|-|, \/\/hY NOT?
18:49:08 <medfly> @keal
18:49:08 <lambdabot> are you saying i am MegaMonad?
18:49:16 <joe__> i have a type of : type TestData = (Code,Message,Stack)
18:49:35 <joe__> valid_test :: TestData -> Bool
18:49:40 <joe__> valid_test (code,_,_) = valid_code code
18:49:42 <Cale> @keal
18:49:42 <lambdabot> ghc need to have plugin that allow copy paste in xp
18:50:09 <joe__> i am trying to pattern to the 1st argument of the 3 element tuple. is it possible?
18:50:23 <Cale> joe__: That looks fine
18:50:48 <Cale> joe__: I would use camelCase rather than underscores, but that's just a matter of taste :P
18:50:53 <joe__> Thanks, Cale. I was getting an error and was not sure if this was the reason and wanted to check.
18:50:58 <joe__> what is camelCase?
18:51:08 <medfly> itIsWritingLikeThis
18:51:15 <joe__> ok, thanks.
18:51:26 <tensorpudding> iLikeCamelCase_better_than_underscores
18:51:35 <tass> It's a retarded way of writing, commonly seen in Java. ; )
18:51:36 <Cale> It's just more common somehow to do that in Haskell, even though underscores are available.
18:51:45 <joe__> camelCase reminds mo of microsoft.
18:51:49 <vowyer> tass: haha
18:52:06 <medfly> tass: I missed the joke, is it true?
18:52:14 * medfly doesn't know Java
18:52:16 <tass> medfly: Yes, yes it is.
18:52:46 <vowyer> medfly: how do you write your haskell functions?
18:52:53 <medfly> camel case.
18:52:55 <tass> medfly: But what's more funny is, their syntax isn't always consistent with camelCase, so it's very very confusing sometimes : D
18:53:12 <medfly> even when it's not Haskell :)
18:53:29 <vowyer> i personally like lisps-way-of-writing
18:53:55 <tass> vowyer: I'd probably love lisp if it wasn't for the crazy paranthesis-marathon they got going on : D
18:54:24 <medfly> I wonder how much unlispy it would be to make a lisp dialect that doesn't have parentheses
18:54:30 <vowyer> tass: you know I felt the same, until I tried it, and then clojure
18:54:32 <medfly> just uses like { }s and things.
18:54:49 <tass> Oh shi, let's see how many paranthesises we can type in a hundred line program!
18:54:55 <medfly> lol
18:55:08 <vowyer> it isn't that bad actually
18:55:21 <tass> medfly: There's sweet expressions
18:55:28 <medfly> I think the main complaint I hear about lisp is about parentheses
18:55:40 <tass> Dunno, to me it just makes it so unreadable
18:55:41 <vowyer> it's the only complaint apparently
18:55:47 <tass> And it adds something to type all the time
18:56:01 <vowyer> people have to find a reason to put it down and choose the most obvious
18:56:01 <O_4> People bitch about the parentheses, but really they aren't a big deal
18:56:04 <ddarius> vowyer: Definitely not, though I find it a silly one (at least phrased that way.)
18:56:09 <O_4> You just get used to it and stop caring :-/
18:56:20 <medfly> the other one is probably some comment about lisp being old/no one knows it/etc
18:56:30 <tass> O_4: Sadly, to me, programming comfort matters a lot.
18:56:31 <O_4> tass: it doesn't add any more than { and } add...
18:56:37 <vowyer> ddarius: if I have to find one reason, it would be dynamic typing
18:56:49 <ddarius> vowyer: That, indeed, is a commonly expressed reason.
18:56:57 <HugoDaniel> parenthesis are anoying little bastards
18:57:25 <vowyer> ddarius: but you don't find people caring much about javascript, python, perl, ruby, etc
18:57:41 <tass> python is beautiful
18:57:44 <tass> perl is hackish
18:57:56 <medfly> vowyer: they do care
18:57:57 <tass> ruby is overdid it on the OOP
18:58:07 <medfly> vowyer: but they also have other complaints
18:58:13 <tass> three.times() for a for loop
18:58:17 <O_4> medfly: nah, people are happy to use braces, but not parens
18:58:18 <tass> Come on...
18:58:26 <medfly> although it may be not knowing you can have less
18:58:38 <O_4> tass: 3.times, you mean :-p
18:58:48 <tass> O_4: Oh, yeah, w/e : P
18:59:16 <tass> O_4: That's the one piece of ruby I read, then I said to myself "I will never sink this low" and ignore the language : P
18:59:20 <vowyer> O_4: that must be the most stupid overdesign
18:59:37 <tass> ignored, even.
19:00:18 <O_4> vowyer, tass: it's actually a reasonably nice construct.  It's succinct and clear, what's wrong with it?
19:00:33 <tensorpudding> python is very C-ish
19:00:37 <tass> O_4: Dunno, too much like actual english? : P
19:00:48 <O_4> I don't really care for ruby, but honestly, that's a pretty retarded thing to pick on...
19:01:05 <tass> Dunno, it just puts me off : P
19:02:12 <tass> Silly as that might be
19:02:36 <vowyer> I don't believe you can treat a number like an object, because I don't believe in OOP
19:03:12 <O_4> What're you hoping for?  That if you don't believe, it'll disappear? :-p
19:03:33 <O_4> OOP is perfectly valid.  Whether it's optimal is a different question.
19:03:39 <tass> Oh what the hell is wrong with this?
19:03:43 <tass> printf "ircSPLIT: (%s %s %s %s %s)" (f 0) (f 1) (f 2) (f 3) (f 4)
19:03:52 <tass> Looks fine to me, am I doing it wrong?
19:04:18 <O_4> What's the error?
19:04:24 <aavogt> > let f = show in printf "ircSPLIT: (%s %s %s %s %s)" (f 0) (f 1) (f 2) (f 3) (f 4) :: String
19:04:24 <lambdabot>   "ircSPLIT: (0 1 2 3 4)"
19:04:35 <tass> "Possible parse error": P
19:04:43 <vowyer> O_4: i know, just it does feel awkward
19:04:55 <aavogt> tass: what you pasted is valid
19:05:25 <tass> Blaraasdhqwe
19:05:51 * tass continues to smash things in his near vicinity.
19:06:19 <aavogt> I'm pretty sure that it doesn't say possible parse error
19:06:31 <joe__> print $ filter (not . valid_test) testdata
19:06:39 <joe__> prints the list data as a single line
19:06:45 <tass> Oh yeah, parser error (possibly incorrect indentation)
19:06:48 <tass> It says.
19:06:55 <joe__> i am wondering if there is a way that I can add a newline between the list elements
19:07:22 <aavogt> @type putStr . unlines . map show -- joe__
19:07:23 <lambdabot> forall a. (Show a) => [a] -> IO ()
19:07:24 <tass> if ircCHECK s then printf "ircSPLIT: (%s %s %s %s %s)" (f 0) (f 1) (f 2) (f 3) (f 4)
19:07:28 <tass> That's the full line
19:07:35 <aavogt> you don't have an else?
19:07:47 <tass> Oh, fuck.
19:07:55 <xerox> tass: putStrLn . concat . intersperse ' ' $ "ircSPLIT" : map f [0..4]
19:07:56 <joe__> aavogt, thanks. will check it out.
19:08:19 <ddarius> concat . intersperse c = intercalate c
19:08:24 <ddarius> @src intercalate
19:08:24 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
19:08:31 <xerox> that must be new, nice.
19:08:39 <aavogt> @src unwords
19:08:39 <lambdabot> unwords [] = ""
19:08:40 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
19:08:46 <ddarius> xerox: A little new, but not very new.  Maybe GHC 6.8.
19:10:12 <joe__> i cannot find intercalate. is it in some module?
19:10:23 <ddarius> @hoogle intercalate
19:10:23 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
19:10:23 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:10:23 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
19:10:35 <joe__> thanks ddarius
19:12:11 <joe__> @hoogle intersperse
19:12:11 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
19:12:11 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
19:12:11 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
19:19:11 <tass> Ah-hah!
19:19:13 <tass> Finally!
19:19:22 <tass> I managed to resolve my bug :<
19:20:19 <tass> My list was apparently a tiny itty bit longer than I thought it was : D
19:20:22 <tass> Finally my IRC bot is working as intended
19:20:27 <joe__> i like unlines, but is there a way to add a prefix at the beginning of each line, such as an indentation?
19:21:33 <ddarius> joe__: Mix with intersperse.
19:22:18 <ddarius> Or perhaps map (foo++) would be better...
19:24:02 <tass> My multi-channel solution even works, brilliant!
19:24:34 <tass> The next step is obviously multi-server, but that's a tough one to crack I think
19:24:39 <joe__> ddarius, thanks the map (foo++) was what I was looking for.
19:31:29 <joe__> ddarius, I am probably asking stupid questions. Am I testing this forums' patience? some of the suggestions that I get here help clear my thinking process, but am not sure if the questions are appropriate?
19:32:03 <ddarius> joe__: Any Haskell-related questions are appropriate here.
19:32:25 <joe__> ok, thanks.
19:32:45 <tass> joe__: If stupid questiosn were forbidden, I'd be kick banned loooooong time ago : P
19:32:53 <tass> questions, even
19:33:03 <Nafai> joe__: This is one of the most patient and helpful forums you will find
19:33:23 <tass> And thanks to that, I'm actually learning something : )
19:33:35 <ddarius> In my opinion, it is sometimes too patient and helpful, but this is certainly not one of those cases.
19:33:36 <joe__> yes, this forum has certainly been the most patient and helpful that I have known.
19:34:18 <tass> I'm just silly who won't take the time to learn pattern matching and stick to regex ; )
19:34:23 <joe__> I gave up on haskell couple of years ago and this time around, this forum has been very helpful in easing me into haskell.
19:34:35 <joe__> the learning process has been almost painless this time around.
19:34:44 <joe__> due to this forum, primarily.
19:34:58 <vowyer> joe__: did you read the book?
19:35:06 <joe__> there is only so much you can learn from reading wikis, books, etc..
19:35:07 <vowyer> joe__: Real world haskell?
19:35:17 <joe__> vowyer, yes i did.
19:35:52 <joe__> but sometimes some of the ideas do not spring back to mind while programming.
19:36:25 <vowyer> joe__: it happens to me, specially with monad and transformers
19:39:27 <joe__> just wondering if you would recommend a better way of writing this function. it works but am wondering if there is a better way of writing it.
19:39:30 <joe__> valid_code (x:xs) | length x > 8 = False | otherwise = True && (valid_code xs)
19:39:58 <joe__> the above is without identation or lines
19:40:21 <joe__> the return value is false, if the first string has more than 8 characters in length
19:41:03 <joe__> if true, then check the next string and so on till the end..
19:41:46 <joe__> if true, then check the next word and so on till the end..
19:42:15 <ddarius> True && x = x
19:42:52 <joe__> ddarius, i do not understand.
19:42:52 <ddarius> Also, what about the empty list case?
19:43:03 <joe__> valid_code [] = True
19:43:10 <ddarius> True && (valid_code xs) = True && valid_code xs = valid_code xs
19:43:47 <ddarius> valid_code = all (\x -> length x <= 8)
19:44:15 <ddarius> (Though I'd avoid the use of length, but it isn't completely inappropriate here...)
19:44:50 <joe__> very cool. I will try it out..
19:45:37 <O_4> > let valid_code = all ((<8) . length) in valid_code ["a", "bb", "cccccccccccc"]
19:45:38 <lambdabot>   False
19:45:56 <O_4> Uhoh
19:46:21 <vowyer> someone's router died?
19:47:36 <joe__> thanks O_4..
19:48:32 <ddarius> O_4's code is slightly different from the original (< rather than <=)
19:48:45 <O_4> Oh, I didn't see ddarius had beaten me to it
19:49:15 <tass> Hrm...
19:49:23 <tass> I can't compile with ghc, though.
19:49:46 <tass> Getting a lot of bull that looks like it is somehow related to regex.
19:51:08 <tass> http://regex.pl/shub-niggurath.hs
19:51:14 <joe__> ddarius, thanks, just noticed it.
19:51:18 <tass> If anyone feel oblicated to take a peak : P
19:51:30 * ddarius steals a mountain and runs off.
20:03:13 <joe__> just a stylistic recommendation.
20:03:37 <joe__> which one of the two forms/functions would you use?
20:03:46 <joe__> valid_test (code,_,_) = all ((<=8) . length) $ words code
20:03:52 <joe__>          let valid_test = (\(code,message,stack) -> ( all ((<=8) . length) $ words code ) )
20:04:01 <joe__> both do the same thing
20:04:27 <joe__> but am wondering when you would recommend going for a "let" and when have it as a different function?
20:05:02 <tass> !anick
20:05:21 <ddarius> joe__: You mean when you'd use a local function as opposed to a top-level function?
20:05:28 <tass> Sorry, sent that to the wrong chan
20:05:49 <joe__> yes, ddarius.
20:05:55 <HaskellLove> joe_ dude read a book on haskell dont flood here. I will answer you just this time: let binds an identifier to a value, you use it in interpreter, if you compile the file and not execute in interpreter then you can leave off let
20:06:14 <ddarius> joe__: Just ignore HaskellLove.
20:06:39 <HaskellLove> ddarius just trying to help, i think asking about let is not good question
20:06:40 <ddarius> joe__: Usually the criterion is whether the function has use on its own.
20:07:03 <kmc> HaskellLove, hahahaha
20:07:12 <kmc> ahahahahahahaha
20:07:22 <kmc> omfg
20:07:41 <HaskellLove> kmc, man i asked stupid questions but not about let :D
20:07:48 <joe__> HaskellLove, I realise that most of the functions can be defined as a local function and it is rare to have a top-level function in an IO-sensitive program
20:07:52 <xerox> There is also explicit module exports (module Foo (bar, baz, quux, ...) where) so that you don't have your module export utility functions.
20:08:08 <HaskellLove> joe_ ok
20:08:27 <joe__> hence, was curious if there was something else that would define the preferred option.
20:08:41 <Cale> joe__: Generally, if something might be useful elsewhere, you define it at the top level, and if not, then you define it locally with let/where
20:08:56 <xerox> (because the only difference is that top-level bindings are exported)
20:09:23 <Cale> Well, and they scope over other functions in the same module too
20:10:07 <joe__> ok, thanks guys and sorry for the bother.
20:10:13 <kmc> joe__, pay no attention to HaskellLove
20:10:21 <kmc> we're always glad to answer questions
20:11:12 <Cale> (that's what most of us are here for)
20:11:27 <ddarius> It isn't what I'm here for.
20:11:34 <tass> joe__: He got a bitter cookie among his chocolate chip cookies, you see.
20:11:46 <o-_-o> hey guys
20:11:57 <Cale> ddarius: You're here for the discussions on category theory? :)
20:12:14 <EvanR> o-_-o: just wonder, how does one pronounce your nick
20:12:19 <EvanR> ing
20:12:22 <o-_-o> EvanR, :-(
20:12:27 <kmc> Cale, the great thing about this channel is that one can learn and teach at the same time
20:12:29 <kmc> and at any level too
20:12:34 <o-_-o> EvanR, let me get a new nick
20:12:41 <ddarius> Cale: Discussions on any topic that interests me, and probably, in practice, to promulgate certain of my views with regards to Haskell.
20:14:09 <HaskellLove> joe_ these guys helped me a lot so i will leave you with them now, listen them, i will get back to my book :) happy learning and here is my blog if you are new to haskell might find it interesting  http://haskelllove.wordpress.com/
20:14:32 <EvanR> what book is that again
20:14:49 <medfly> kmc: I don't know about the teach part
20:16:22 <kmc> medfly, why not?
20:16:37 <joe__> HaskellLove, am just checking your website. Thanks for your help.
20:19:19 <carotene> Hi, why are GHC binaries' size increases rapidly in each release? It's said on the official page that 12.1 contains less packages, yet the size increases hugely (e.g. Linux x86's size from 72MB to 102MB).
20:19:27 <joe__> kmc, thanks for the encouragement. I took HaskellLove's comments literally for a while there.
20:19:28 <HaskellLove> joe_ you might want to bookmark that, my goal is to solve all eulers in haskell in 6 months starting from january, working every day on it
20:19:34 <joe__> tass, thanks to you too...
20:20:07 <joe__> HaskellLove, thanks...
20:20:39 <manjunaths> is there instructions how to install ghc 6.12 and complete supporting haskell platform ?
20:21:07 <EvanR> i think 6.12 doesnt have a platform yet and is only really for testing.
20:21:08 <ColonelJ> the instructions are wait till january
20:21:26 <tass> joe__: Don't sweat it, I might not know all that much, but I'm more than happy to help out with what little I can. And really, no question is too stupid here, as long as it is well formulated (Like your questions!). : )
20:21:27 <manjunaths> ColonelJ, ok
20:21:28 <SkiMaskWay> Does anyone know where I can find information about making a complier for Haskell
20:21:31 <SkiMaskWay> :t tass
20:21:32 <lambdabot> Not in scope: `tass'
20:21:32 <carotene> Now GHC is even larger than JDK, although JDK has much more libraries.
20:22:02 <tass> SkiMaskWay: Err.. there is one? (ghc)
20:22:15 <SkiMaskWay> I know but I want to make one
20:22:33 <HaskellLove> this might be of interest to you, i am not sure SkiMaskWay : http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
20:22:54 <ddarius> SkiMaskWay: You can look at others such as JHC, UHC, YHC, or even GHC if you want, but Haskell is a fairly big language.
20:23:15 <ddarius> SkiMaskWay: Most of what you'd need to know is not Haskell-specific though.
20:23:23 <ColonelJ> 'fairly' big?
20:23:51 <manjunaths> ColonelJ, he probably means compared to writing a compiler for C++ :-)
20:24:59 <medfly> I wonder how great is learning a language by writing a compiler for it in Haskell
20:25:10 <ddarius> medfly: That's what John Meacham did.
20:25:16 <ezyang> medfly: A metacircular evaluator is classic for lispy languages
20:25:16 <medfly> I don't know who that is
20:25:24 <ddarius> medfly: The author of JHC.
20:25:30 <ezyang> medfly: I don't know how much fun reimplementing GHC would be
20:25:33 <ezyang> /informational
20:25:42 <medfly> reimplementing GHC!
20:26:03 <medfly> it honestly looks really scary. I'd just like to learn interesting things, not get caught up in scary things like that :D
20:26:06 <manjunaths> ezyang, but one gets to learn haskell pretty well I guess
20:26:26 <ezyang> manjunaths: There are lots of parts of Haskell to learn that are not directly related to the compiler.
20:26:36 <ezyang> This is quite different from other languages, where you learn a "language feature" a day.
20:27:04 <tass> Writing an irc bot was pretty good for learning the language : )
20:27:10 <medfly> ezyang: did you really do that?
20:27:18 <manjunaths> ezyang, how so, my current learning of haskell is pretty much proceeding along as learn one language feature a day  ?
20:27:32 <medfly> no I mean... writing a compiler for <some language I don't know> using Haskell (a language I know, somewhat)
20:27:36 <ezyang> medfly: Write a compiler? No...
20:28:09 <ddarius> medfly: In John's case it was worse, writing a compiler for a language to learn that language.
20:28:24 <medfly> ?
20:28:28 <Draconx|Laptop> writing a compiler for language X in language Y will teach you much more about Y than X.
20:28:28 <medfly> isn't that what I said?
20:28:39 <ColonelJ> knowing a language and knowing how to use it can't possibly be the same
20:28:46 <ddarius> medfly: I forgot to add "in that language"
20:28:46 <medfly> Draconx|Laptop: that's good. a lot of the languages I need to learn suck anyway. :)
20:28:52 <ColonelJ> Draconx|Laptop: yeah I agree
20:28:58 <manjunaths> ezyang, am I doing something wrong by learning one feature of haskell everyday ? Should I do something different for learning haskell ?
20:29:05 <ddarius> Draconx: What if X = Y?
20:29:06 <ezyang> medfly: I've written a metacircular evaluator though
20:29:13 <tass> manjunaths: Code stuff!
20:29:18 <ColonelJ> ddarius: if X = Y, now then you really know the language
20:29:18 <Draconx|Laptop> sure, you might pick up all kinds of little details about X, but you're going to miss the big picture.
20:29:19 <medfly> can anyone give an estimate of how long it takes to write a compiler (or interpreter)?
20:29:19 <ddarius> You have to cover those edge cases.
20:29:27 <medfly> just so I can get some idea of things.
20:29:33 <medfly> in work hours, though
20:29:37 <kmc> medfly, for what language?
20:29:39 <ddarius> medfly: It really depends on the language and the tooling and what you want to accomplish.
20:29:39 <manjunaths> tass, big stuff or little stuff ?
20:29:42 <Draconx|Laptop> ddarius, obviously your skill tends towards infinity, then :P
20:29:53 <tass> manjunaths: Start with something mid-size
20:29:54 <kmc> you can write a minimal Scheme interpreter in a fen hours
20:29:57 <sshc> how does the list monad work?
20:30:00 <medfly> fen?
20:30:02 <kmc> compilers are typically much harder
20:30:04 <sshc> it seems useless to me
20:30:04 <manjunaths> ezyang, what is a metacircular evaluator ?
20:30:06 <monochrom> Writing in X an interpreter/compiler for Y tells you the most about max(X,Y).
20:30:08 <kmc> @src [] (>>=)
20:30:09 <lambdabot> xs >>= f     = concatMap f xs
20:30:12 <kmc> @src [] return
20:30:12 <lambdabot> return x    = [x]
20:30:12 <tass> manjunaths: An IRC bot proved to teach me quite a bit
20:30:14 <kmc> sshc, ^^^^
20:30:17 <sshc> > return 2 >> 3 :: [Int]
20:30:19 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
20:30:19 <lambdabot>    arising from the literal `...
20:30:20 <kmc> sshc, it's useful for nondeterminism
20:30:23 <ezyang> manjunaths: == tass
20:30:23 <ColonelJ> monochrom: that doesn't make sense
20:30:27 <kmc> > filterM (const [True, False]) "abcd"
20:30:28 <lambdabot>   ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","...
20:30:33 <medfly> I don't really know if I want to write an interpreter or compiler, but it seems like a really educational project
20:30:34 <sshc> kmc: can you give me an example, pleaseE?
20:30:35 <kmc> ^^^^ list monad expresses power set concisely
20:30:35 <tass> ezyang: Wut?
20:30:39 * medfly doesn't know much about compilers at the moment
20:30:43 <ddarius> Writing an X compiler in Y tells you the most about writing compilers.
20:30:45 <kmc> sshc, every time you use a list comprehension you're using the list monad
20:30:52 <kmc> plenty of examples of those being useful
20:30:58 <ezyang> Sorry, I'm lagging behind by a bunch of messages
20:31:13 <sshc> kmc: whare is one of those examples?
20:31:39 <manjunaths> is there like a way to make IRC go in slow motion ?
20:31:46 <EvanR> haha
20:31:47 <manjunaths> maybe I need to write one in haskell
20:31:48 <ezyang> manjunaths: In lisp, all code is also data.  So I can take a segment of code as data, and then the question is; can I execute it.
20:31:53 <ezyang> A metacircular evaluator does that.
20:31:56 <kmc> sshc, plenty, e.g. on wikipedia or any haskell tutorial
20:31:59 <manjunaths> ezyang, ah...ok
20:32:03 <ezyang> tass: As in, I agree with you.
20:32:03 <kmc> how about the prime number sieve
20:32:14 <medfly> say I want to write a compiler/interpreter, what language is a good choice? (though not so there is minimal work, but for MAXIMUM EDUCATIONAL VALUE), and for that, how long will it take?
20:32:26 <ddarius> medfly: There is a lot of tedious detail in writing a compiler unless you use tools/libraries to handle large parts of it.
20:32:34 <kmc> "compiler/interpreter" is misleading as interpreters are 10 times easier
20:32:36 * medfly seriously considers doing this, but is somehow unsure about what language to pick (is that even relevant?) and doesn't know how big that project is
20:32:38 <kmc> which do you want?
20:32:39 <ddarius> medfly: A language you don't know.
20:32:44 <ezyang> medfly: This is why a metacircular evaluator is nice
20:32:46 <kmc> medfly, write a Scheme interpreter in Haskell
20:32:49 <sshc> kmc: can you show me an example on a haskell tutorial?
20:32:50 <tass> ezyang: Can't you do kinda the same in haskell?
20:32:50 <kmc> there's a tutorial on that
20:32:52 <ezyang> medfly: It's very simple.
20:32:55 <ezyang> tass: Yeah, you can.
20:32:56 <ezyang> ==kmc
20:33:04 <Draconx|Laptop> medfly, write an unlambda interpreter in unlambda.
20:33:10 <kmc> sshc, why don't you spend some time looking
20:33:13 <PepeSilvia> @google scheme in 24 hours
20:33:15 <lambdabot> http://www.guardian.co.uk/business/2009/dec/04/rbs-bonus-scheme-clash
20:33:15 <lambdabot> Title: RBS gears up for bonus scheme clash | Business | The Guardian
20:33:18 <ezyang> I feel like writing it in Lisp means that you have to understand very clearly the boundary between code and data.
20:33:28 <kmc> @google write yourself a scheme in 48 hour -- medfly
20:33:28 <tass> ezyang: I didn't find much info from a quick google, though. Think you can point me somewhere?
20:33:29 <lambdabot> No Result Found.
20:33:32 <kmc> oh ffs
20:33:36 <sshc> kmc: I have been.
20:33:39 <kmc> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
20:33:41 <medfly> yeah but not like a supereasy thing ;)
20:33:43 <PepeSilvia> kmc, oh yeah that was it
20:33:48 <ezyang> tass: re what?
20:33:49 <medfly> surely it's easy if it's 48 hours!
20:33:53 <sshc> kmc: well, I'll keep looking
20:34:27 <tass> ezyang: 05:31 < ezyang> manjunaths: In lisp, all code is also data.  So I can take a  segment of code as data, and then the question is; can I execute it
20:34:37 <EvanR> medfly: it can be easy or hard, you have to have a more well defined problem. its easy to interpret something when the implementation language already supports everything ;)
20:34:50 <ezyang> tass: SICP might be a good resource.
20:34:50 <EvanR> thats why scheme is scheme is so easy
20:34:56 <medfly> sorry EvanR
20:34:56 <tass> ezyang: Then I asked re: if there was a similar feature in Haskell, and you said there was one
20:34:58 <sshc> kmc: can any list comprehension be written as a List monad?
20:35:03 <ColonelJ> kmc: so _that's_ why there are so many Scheme implementations!
20:35:06 <EvanR> scheme in scheme*
20:35:25 <ezyang> tass: That would be the Haskell/Scheme tutorial
20:35:35 <ddarius> medfly: Though directed at tass, ezyang's comment is a good one.  Have you read SICP?
20:35:36 <kmc> sshc, yes
20:35:39 <sshc> kmc: how?
20:35:52 <medfly> ddarius: no, it's another thing I should do :)
20:35:57 <medfly> ddarius: I just suck at reading books :)
20:35:59 <ezyang> To be honest though
20:36:04 * ezyang hasn't read the entirety of SICP yet 
20:36:05 <EvanR> sicp does a good job separating (or .. not) the distinction between compiling and interpreting
20:36:05 <kmc> [ x | y <- a, b ]   ==>   do { y <- a; guard b; return x }
20:36:07 <ddarius> medfly: There is a video serious too.
20:36:08 <kmc> :t guard
20:36:10 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:36:13 <medfly> ddarius: yeah, I am aware. thanks
20:36:31 <kmc> sshc, list comprehension syntax could be (and was at one time) used for any MonadPlus, but that was removed from the spec as being too confusing :/
20:36:38 <ezyang> See also http://web.mit.edu/alexmv/6.001/
20:36:43 <ezyang> kmc: Awww...
20:36:44 <Cale> MonadZero even
20:37:00 <Cale> But that was foolishly removed as well
20:37:13 <tass> ezyang: Hmm?
20:37:28 <ddarius> medfly: If you are interested in interpreting and compiling, SICP is not a bad place to get a simple start.  The examples are extremely simple compared to any "real" compiler, but they are well explained and almost everything gets some coverage.
20:37:41 <xerox> ezyang: I hear they've moved to python now
20:37:46 <ezyang> tass: It's a month-long class!
20:37:50 <ezyang> xerox: Correct.
20:37:54 <HaskellLove> Someone interested in the Scheme in Haskell tutorial, wait for me i will start it in Sunday so we can go together and contact about it?
20:37:56 <medfly> ddarius: oh, okay, that's more motivation to read SICP. thanks.
20:38:02 <tass> ezyang: On how to compile haskell on the fly?
20:38:10 <ezyang> tass: No.
20:38:20 <ezyang> It covers SICP style material
20:38:22 <tass> Then you got me aaaaall wrong.
20:38:31 <ezyang> sorry
20:38:53 <ddarius> tass: You do realize lambdabot compiles Haskell code on the fly.
20:39:24 <SkiMaskWay> > let tass = 6 in find even [tass,5,4,3,2]
20:39:26 <lambdabot>   Just 6
20:39:32 <SkiMaskWay> :t Just 6
20:39:33 <lambdabot> forall t. (Num t) => Maybe t
20:39:52 <tass> ezyang: When you (unintentionally?) claimed that Haskell could be edited and compiled on the fly just like Lisp can, I got interested. And then I tried asking you if you had any docs on the subject.
20:40:08 <ezyang> tass: Oh, I see.
20:40:33 <tass> docs/info/pointers
20:40:38 <ezyang> See haskell-src <http://hackage.haskell.org/package/haskell-src>
20:40:47 <ezyang> But that wasn't really what I was implying, unfortunately.
20:41:16 <Cale> haskell-src is just parsing isn't it?
20:41:40 <ezyang> Cale: doesn't haskell-src-meta also give you ASTs or something?
20:41:41 <Cale> There's hint which is a nice interface to the GHC API, as well as the GHC API itself
20:41:45 * ezyang has never used it 
20:41:59 <ddarius> ezyang, tass: You can compile and load Haskell code at run-time (with GHC at least).  You certainly can't mutate function definitions as you can in Lisp.  Functions are values and are immutable as always.
20:42:05 <ddarius> @hackage hint
20:42:05 <lambdabot> http://hackage.haskell.org/package/hint
20:42:16 <HaskellLove> SkiMaskWay interested in doing Scheme in Haskell?
20:43:12 <tass> ddarius: Ah-hah, that limits it's uses quite a bit I guess.
20:43:35 <tass> Though... how the heck does XMonad reconfigure itself on the fly then?
20:43:35 <ddarius> tass: It requires more structure to change things than Lisp, but about comparable to Java.
20:43:43 <ddarius> tass: It does something totally different.
20:43:56 <ddarius> tass: It simply recompiles the executable and overwrites it then execs itself.
20:44:09 <ddarius> tass: You could do that in any language, e.g. C.
20:44:13 <tass> Ah, I see.
20:44:14 <SkiMaskWay> I'm not very good at it HaskellLove
20:45:09 <tass> ddarius: Then that makes sense I guess.
20:46:10 <ddarius> tass: Well, to give xmonad a bit more credit, it takes a bit of effort to save the relevant state, but this is much easier in Haskell as opposed to C as such state is usually much more explicit.
20:46:13 <SkiMaskWay> has anyone here ever programmed in J?
20:46:26 <ddarius> Yes.  (For small values of programmed in.)
20:48:33 <tass> On a whole different note, how would I go about checking if TWO arguments equals true?
20:48:46 <ddarius> tass: Pattern match.
20:49:15 <ddarius> Unless you mean any two out of greater than two parameters.
20:49:19 <tass> Some pseudo code "if ARG1 == True && ARG2 == True then ..."
20:49:35 <xerox> obviously  (x == True) == True && (y == True) == True  you can never be sure.
20:50:09 <ddarius> :t fix (True ==)
20:50:10 <lambdabot> Bool
20:50:37 <ddarius> Confidence takes time.
20:57:36 <ColonelJ> how do you generate a list of numbers from 1 to n
20:58:04 <xerox> > [1..n]
20:58:05 <lambdabot>   * Exception: not a number
20:58:09 <xerox> haha.
20:58:21 <ColonelJ> thanks
20:58:26 <xerox> lambdabot lies, that is how you do that.
20:58:38 <vowyer> tass: how about if (ARG1 && ARG2) then ... else ...
20:58:43 <kmc> haha what?
20:58:54 <kmc> ah, SimpleReflect strikes again
20:58:56 <kmc> > [1..15]
20:58:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
20:59:03 <ddarius> Just write: f True True = ...; f x y = ...
20:59:03 <kmc> > fromInteger 0 :: Expr
20:59:04 <xerox> I was asking too much.
20:59:05 <lambdabot>   0
20:59:17 <kmc> > enumFromTo a b
20:59:19 <lambdabot>   * Exception: not a number
20:59:19 <Cale> Well, it would have been an error anyway
20:59:21 <ddarius> kmc: It would have been an error anyways.
20:59:28 <kmc> sure
20:59:32 <kmc> but this way it's a confusing error
20:59:37 <kmc> > \n -> [1..n]
20:59:38 <lambdabot>   {-3->[];-2->[];-1->[];0->[];1->[1];2->[1,2];3->[1,2,3]}
20:59:51 <kmc> > enumFromTo 1
20:59:52 <lambdabot>   {-3->[];-2->[];-1->[];0->[];1->[1];2->[1,2];3->[1,2,3]}
20:59:54 <xerox> Who needs more than 3 anyway.
20:59:59 <kmc> hehe
21:00:08 <kmc> > [False ..]
21:00:09 <lambdabot>   [False,True]
21:00:20 <kmc> you can save a whole 2 chars typing this way!
21:00:20 <ColonelJ> > [1..]
21:00:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:00:42 <ColonelJ> what actually is that?
21:00:43 <xerox> kmc: I think you can save the space as well
21:01:01 <xerox> ColonelJ: exaclty what it says, the infinite list of (french?) natural numbers
21:01:09 <ddarius> xerox: Not in any modern Haskell implementation.
21:01:17 <kmc> > map integerToBreakfast [1..]
21:01:18 <lambdabot>   ["Strawberry jam toast","Grapefruit","Cup of tea and a biscuit, gotta dash"...
21:01:33 <monochrom> the infinite list of analysis natural numbers (as opposed to set theory natural numbers)
21:01:45 <xerox> ddarius: I see, Module.(.)-ish
21:01:58 <kmc> > [False..]
21:01:59 <lambdabot>   <no location info>: parse error on input `]'
21:02:50 <ezyang> kmc: wat
21:04:06 <kmc> :)
21:05:11 <ColonelJ> is this a good solution to Euler 1?     sum (filter (\x -> mod x 5 == 0 || mod x 3 == 0) [1..999])
21:05:53 <kmc> sure
21:06:26 <tass> vowyer: Worked
21:06:44 <tass> vowyer: Or, I think it did, doing more extensive testing now.
21:07:12 <ColonelJ> kmc: I'm going to try generalizing it
21:08:00 <roostaj> ColonelJ: here is my euler1 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14377#a14377
21:08:09 <roostaj> ColonelJ: dont look if you dont want to :D
21:08:51 <ColonelJ> I see what you did there
21:09:15 <ColonelJ> I was just going for a trivial solution that would take a few second
21:09:34 <roostaj> that was my first haskell program ever
21:09:37 <roostaj> :O
21:10:14 <ColonelJ> 'program'
21:10:36 <roostaj> function?
21:11:09 <ColonelJ> mmh I suppose it is a program
21:11:19 * roostaj thinks ColonelJ is just splitting hairs
21:11:23 <roostaj> :)
21:11:24 <kmc> to me a program has "main"
21:11:26 <kmc> but whatevs
21:11:39 <ColonelJ> I like that definiton
21:11:45 <kmc> just add "main = print answer"
21:11:55 <roostaj> kmc: ha ha
21:11:59 <ColonelJ> I'll do that when I write a worthwhile program
21:12:08 <roostaj> euler001 is worthwhile
21:12:10 <roostaj> :D
21:12:24 <ColonelJ> pfft
21:12:30 <ColonelJ> anyway
21:12:57 <roostaj> , time $ (\x sum (filter (\x -> mod x 5 == 0 || mod x 3 == 0) [1..999])
21:12:58 <lunabot>  luna: Parse error in pattern
21:13:12 <roostaj> oops
21:13:18 <roostaj> , time $ sum (filter (\x -> mod x 5 == 0 || mod x 3 == 0) [1..999])
21:13:20 <lunabot>  (2.999e-3,233168)
21:13:28 <kmc> , time ()
21:13:30 <lunabot>  (0.0,())
21:13:42 * kmc calls the Referential Transparency Police on that
21:13:47 <kmc> , fix time
21:13:48 <lunabot>  luna: Occurs check: cannot construct the infinite type:
21:13:58 <roostaj> , time $ sum ([3,6..(1000-1)] ++ [x | x <- [5,10..(1000-1)], x `mod` 3 /= 0])
21:14:01 <lunabot>  (1.0e-3,233168)
21:14:14 <kmc> , iterate (time . show) ()
21:14:15 <lunabot>  luna: Couldn't match expected type `(GHC.Types.Double, GHC.Base.String)'
21:14:32 <roostaj> , time $ sum (filter (\x -> mod x 5 == 0 || mod x 3 == 0) [1..49999])
21:14:34 <lunabot>  (0.151977,583291668)
21:14:43 <roostaj> , time $ sum ([3,6..(50000-1)] ++ [x | x <- [5,10..(50000-1)], x `mod` 3 /= 0])
21:14:45 <lunabot>  (3.1995e-2,583291668)
21:15:03 <roostaj> , time $ sum (filter (\x -> mod x 5 == 0 || mod x 3 == 0) [1..499999])
21:15:07 <lunabot>  (1.642751,58332916668)
21:15:14 <roostaj> , time $ sum ([3,6..(500000-1)] ++ [x | x <- [5,10..(500000-1)], x `mod` 3 /= 0])
21:15:14 <kmc> does time reduce to NF or WHNF?
21:15:16 <lunabot>  (0.500924,58332916668)
21:15:17 <kmc> #ty time
21:15:20 <lunabot>  forall a . a -> (Double, a)
21:15:21 <roostaj> Colonel
21:15:24 <roostaj> oops
21:15:34 <yrlnry> It bugs me to have to keep writing code like  instance Functor Poo where fmap f (Poo x) = Poo (f x).   Is there any clever way around that?
21:15:46 <kmc> yrlnry, ghc 6.12 can derive Functor iirc
21:15:54 <kmc> > case time (Just undefined) of (_, _) -> ()
21:15:55 <yrlnry> That's exactly what i was hoping you would say!
21:15:55 <lambdabot>   Not in scope: `time'
21:15:56 <yrlnry> Thanks.
21:15:58 <kmc> , case time (Just undefined) of (_, _) -> ()
21:16:00 <lunabot>  ()
21:16:04 <roostaj> , time $ sum (filter (\x -> mod x 5 == 0 || mod x 3 == 0) [1..4999999])
21:16:10 <lunabot>  Killed.
21:16:13 <sjanssen> yrlnry: if Poo is a newtype, use GeneralizedNewtypeDeriving
21:16:17 <roostaj> , time $ sum ([3,6..(5000000-1)] ++ [x | x <- [5,10..(5000000-1)], x `mod` 3 /= 0])
21:16:22 <PepeSilvia> ,time sum [3,6..999] + sum [5,10..995] - sum[15,30..990]
21:16:23 <lunabot>  luna: Couldn't match expected type `[t] -> a'
21:16:23 <lunabot>  Stack space overflow: current size 8388608 bytes.
21:16:23 <lunabot>  Use `+RTS -Ksize' to increase it.
21:16:23 <lunabot>  /bin/sh: line 1: 24248 Killed                  ./luna +RTS -N2 -RTS 2>&1
21:16:38 * roostaj might have injured lunabot
21:16:44 <PepeSilvia> , time $ sum [3,6..999] + sum [5,10..995] - sum[15,30..990]
21:16:46 <lunabot>  (0.0,233168)
21:17:30 <byorgey> yrlnry: it can!?
21:17:30 <kmc> yrlnry, for GHC < 6.12, you could write a deriver thingy with TH, or you could use SYB stuff instead (which, iirc can do something like fmap, slower), and the SYB classes have been derivable for a while
21:17:34 <roostaj> PepeSilvia: I think list concatenation killed my time :)
21:17:38 <kmc> to whit Typeable and Data
21:17:48 <PepeSilvia> roostaj: yeah that's not necessary
21:17:48 <yrlnry> What is SYB?
21:18:00 <yrlnry> Hi, Brent.  What's cooking?
21:18:00 <ddarius> kmc: Newtype deriving is in earlier versions of GHC than GHC 6.12
21:18:08 <roostaj> PepeSilvia: was my first haskell program :)
21:18:26 <PepeSilvia> roostaj: no worries, wasn't meant to put you down
21:18:41 <kmc> yes
21:18:42 <roostaj> PepeSilvia: :) I'm going back to my corner now
21:18:44 <kmc> yrlnry, Scrap your Boilerplate
21:18:48 <byorgey> omg! -XDeriveFunctor!!!
21:18:55 * byorgey <3
21:18:58 <yrlnry> kmc:  I'll look it up, thanks.
21:18:58 <Axman6> :O
21:19:06 * roostaj crosses arms and stomps away
21:19:17 <kmc> yrlnry, the original SYB paper is a good intro
21:19:30 <ezyang> byorgey: Whoa!
21:19:36 <ezyang> cool.
21:19:41 <kmc> also Foldable and Traversable
21:19:52 <yrlnry> SYB papers: http://www.cs.vu.nl/boilerplate/#papers
21:20:08 <kmc> eew they use the phrase "design pattern"
21:20:15 <byorgey> hi Mark, working on a fellowship application =P
21:20:16 <kmc> the whole point of SYB is to *remove* a design pattern and replace it with a library
21:20:47 <yrlnry> where's the fellowship?
21:21:54 <byorgey> yrlnry: just some lady who had a lot of money and decided she wanted poor grad students to have some of it after she died
21:21:59 <byorgey> pretty nice of her, actually
21:22:13 <yrlnry> senile dementia, more likely.
21:22:15 <byorgey> unfortunately there are a lot of them (poor grad students)
21:22:20 <byorgey> yeah, probably.
21:22:50 <kmc> hahaha
21:22:53 <yrlnry> well, I hope you get it, because I am sure you are more deserving than anyone else.
21:23:23 <kmc> @remember yrlnry <byorgey> yrlnry: just some lady who had a lot of money and decided she wanted poor grad students to have some of it after she died... pretty nice of her, actually   <yrlnry> senile dementia, more likely.
21:23:24 <lambdabot> Done.
21:24:14 <byorgey> yrlnry: heh, thanks =)
21:29:27 <ColonelJ> @let euler1 n ds = sum (filter (\x ->  or (map (\y -> mod x y == 0) ds)) [1..n-1])
21:29:28 <lambdabot>  Defined.
21:29:34 <ColonelJ> > euler1 1000 [3,5]
21:29:35 <lambdabot>   233168
21:31:59 <ColonelJ> eh that's an awful way of defining it
21:33:07 <ColonelJ> I'll do one with union
21:35:06 <ColonelJ> what's the best way to write every the list of all multiples of x up to n
21:35:26 <byorgey> [x, 2*x .. n]
21:35:39 <ColonelJ> well n-1, doesn't include n
21:35:47 <byorgey> ok, sure
21:36:48 <Jonno_FTW> that euler question is shorter with a list comprehension
21:36:59 <ColonelJ> I think that's  what I need
21:37:05 <ColonelJ> union doesn't seem to be loaded
21:37:29 <Jonno_FTW> euler1 = [n|n<-[1..1000],n `mod` 3 == 0 || n `mod` 5 == 0]
21:37:32 <Jonno_FTW> >euler1 = [n|n<-[1..1000],n `mod` 3 == 0 || n `mod` 5 == 0]
21:37:35 <Jonno_FTW> > euler1 = [n|n<-[1..1000],n `mod` 3 == 0 || n `mod` 5 == 0]
21:37:35 <byorgey> ColonelJ: union is in Data.List
21:37:36 <lambdabot>   <no location info>: parse error on input `='
21:37:48 <Jonno_FTW> > let euler1 = [n|n<-[1..1000],n `mod` 3 == 0 || n `mod` 5 == 0] in euler1
21:37:49 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
21:37:58 <Jonno_FTW> > let euler1 =sum [n|n<-[1..1000],n `mod` 3 == 0 || n `mod` 5 == 0] in euler1
21:37:59 <lambdabot>   234168
21:38:12 <ColonelJ> byorgey: I need a union that can do more than a list of things rather than just two lists
21:38:12 <sshc> < let euler1 =sum [n|n<-[1..1000],n `mod` 3 == 0 || n `mod` 5 == 0] in euler1
21:38:16 <Jonno_FTW> 999
21:38:28 <Jonno_FTW> > let euler1 =sum [n|n<-[1..999],n `mod` 3 == 0 || n `mod` 5 == 0] in euler1
21:38:29 <lambdabot>   233168
21:38:32 <Jonno_FTW> tadah
21:39:04 <byorgey> ColonelJ: ok, how about  foldl' union []
21:39:05 <Axman6> > euler1 =sum [n|n<-[1..999],n `mod` 3 == 0 || n `mod` 5 == 0]
21:39:06 <Axman6> >_>
21:39:07 <lambdabot>   <no location info>: parse error on input `='
21:39:21 <Axman6> > sum [n|n<-[1..999],n `mod` 3 == 0 || n `mod` 5 == 0]
21:39:22 <lambdabot>   233168
21:39:23 <ColonelJ> byorgey: ah yes
21:39:27 <byorgey> > foldl' union [] [[1,2,3], [4,5,6], [1,2,7], [6,8,10,11]]
21:39:28 <lambdabot>   [1,2,3,4,5,6,7,8,10,11]
21:39:47 <byorgey> ColonelJ: you can always make binary operations into n-ary with a fold
21:40:02 <ColonelJ> i see
21:40:17 <Jonno_FTW> oh yes, how can I do XOR shift in haskell
21:40:32 <byorgey> Jonno_FTW: look in Data.Bits
21:40:38 <kmc> Jonno_FTW, not sure what that operation is, but Data.Bits may help you
21:40:49 <Jonno_FTW> @src Data.Bits.xor
21:40:50 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:40:56 <kmc> it has xor and shift individually
21:41:01 <kmc> Jonno_FTW, it's a typeclass member
21:41:33 <Jonno_FTW> i used hoogled
21:41:39 <Jonno_FTW> and got a file not found
21:43:17 <Jonno_FTW> in computing, is there a difference between if and iff
21:43:43 <kmc> iff usually means "if and only if"
21:43:54 <kmc> Jonno_FTW, http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-Bits.html
21:43:58 <byorgey> Jonno_FTW: yes, there is a difference
21:44:00 <kmc> hoogle / online docs are a bit broken right now
21:44:14 <Jonno_FTW> ahk
21:44:18 <kmc> Jonno_FTW, you proably want to bookmark this for the time being: http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/
21:44:52 <ColonelJ> let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 1000 [3,5]
21:44:56 <ColonelJ> > let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 1000 [3,5]
21:44:57 <lambdabot>   233168
21:45:08 <ColonelJ> I think that's the best way to do euler1
21:45:31 <ColonelJ> > let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 1000000000000000000000000000000000000000000 [10000000000000000000000000000000000,10000000000000000000000000000000000000000000]
21:45:34 <lambdabot>   mueval-core: Time limit exceeded
21:45:41 <ColonelJ> ok something went wrong
21:45:58 <ColonelJ> maybe not enough zeroes
21:46:19 <Jafet> sum? Seriously?
21:46:37 <ColonelJ> > let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 1000000000000000000000000000000000000000000 [100000000000000000000000000000000000000000,10000000000000000000000000000000000000000]
21:46:37 <lambdabot>   49500000000000000000000000000000000000000000
21:46:43 <ColonelJ> ok it does work
21:48:13 <ColonelJ> I'm guessing it got stuck on the union part
21:48:52 <ColonelJ> maybe union isn't such a good idea
21:50:13 <ColonelJ> is there a function to merge two sorted sets?
21:51:09 <ddarius> @hackage data-ordlist
21:51:10 <lambdabot> http://hackage.haskell.org/package/data-ordlist
21:53:05 <ColonelJ> is [1..55] an Ord?
21:53:36 <xerox> Integral a => [a]  but Integral implies Num, and Num implies Ord
21:53:52 <xerox> (I guess Num a is also fine)
21:55:42 <ColonelJ> hmm I don't have Data.OrdList
21:57:07 <ColonelJ> > let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1
21:57:07 <ColonelJ> 1000000000000000000000000000000000000000000 [
21:57:07 <ColonelJ> 10000000000000000000000000000000000000,
21:57:07 <ColonelJ> 100000000000000000000000000000000000000000]
21:57:11 <lambdabot>   mueval-core: Time limit exceeded
21:58:01 <Jonno_FTW> if I have a list, how can I compare each element in 2 lists to result as in: [a,c] [b,d] => [a `eq` b, c `eq` d]
21:58:16 <ddarius> zipWith eq
21:58:25 <Jonno_FTW> oh right
21:58:55 <Jonno_FTW> :t zipWith
21:58:56 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
21:59:16 <medfly> may I ask a totally non-Haskell question and am only asking it here because I"m doing it in Haskell?
21:59:38 <mmorrow> , 42
21:59:39 <lunabot>  42
21:59:47 <medfly> hehe
22:00:11 <mmorrow> * roostaj might have injured lunabot
22:00:34 <mmorrow> roostaj: whoa, i wonder if the ghc-api code itself stack-overflowed there, or that was just some weird glitch
22:00:53 <ColonelJ> > Prelude Data.List> let euler1 n ds = sum (foldl' merge [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 1000000000000000000000000000000000000000000 [100000000000000000000000000000000000000,100000000000000000000000000000000000000000]
22:00:54 <lambdabot>   Not in scope: data constructor `Prelude'Not in scope: data constructor `Dat...
22:01:04 <ColonelJ> > let euler1 n ds = sum (foldl' merge [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 1000000000000000000000000000000000000000000 [100000000000000000000000000000000000000,100000000000000000000000000000000000000000]
22:01:05 <lambdabot>   Not in scope: `merge'
22:01:38 <kmc> medfly, fine by me
22:01:39 <mmorrow> , time $ sum ([3,6..(5000000-1)] ++ [x | x <- [5,10..(5000000-1)], x `mod` 3 /= 0])
22:01:44 <lunabot>  Stack space overflow: current size 8388608 bytes.
22:01:44 <lunabot>  Use `+RTS -Ksize' to increase it.
22:01:44 <lunabot>  /bin/sh: line 1: 26478 Killed                  ./luna +RTS -N2 -RTS 2>&1
22:01:58 <ColonelJ> > let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 1000000000000000000000000000000000000000000 [100000000000000000000000000000000000000,100000000000000000000000000000000000000000]
22:02:00 <lambdabot>   4999500000000000000000000000000000000000000000
22:02:15 <kmc> mmorrow, time reduces to WHNF?
22:02:16 <mmorrow> oh, i guess i just haven't taken that error msg into account in my hacky String pattern matching
22:02:22 <kmc> > fix error
22:02:23 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
22:02:25 <Jonno_FTW> i bet those 2 bots are storing away all the snippets of code sent to it to eventually form some super module
22:02:26 <mmorrow> kmc: yes
22:02:41 <mmorrow> Jonno_FTW: skynet
22:03:03 <ColonelJ> I think lambdabot was faster than my computer
22:03:04 <Jonno_FTW> of course, skynet would only ever work in haskell
22:03:13 <ddarius> Skynet will crush the world under its inefficient implementations of fib.
22:03:20 <mmorrow> heh
22:03:22 <Jonno_FTW> noooo
22:03:25 <EvanR> haha
22:03:27 <mrd> > fix head
22:03:28 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:03:39 <kmc> ColonelJ, haha
22:03:43 <kmc> that's what we call "cloud computing"
22:03:54 <kmc> > integerToBreakfast 6
22:03:56 <lambdabot>   "Porridge of some description"
22:03:59 <kmc> can your GHCi do *that*?
22:04:28 <yrlnry> I kindheh
22:04:29 <ColonelJ> I don't think it has any porridge
22:05:39 <ColonelJ> what exactly does union do
22:06:06 <kmc> which union?
22:06:09 <kmc> :t union
22:06:10 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
22:06:13 <kmc> :t Data.Set.Union
22:06:14 <lambdabot> Not in scope: data constructor `Data.Set.Union'
22:06:14 <kmc> :t Data.Set.union
22:06:15 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
22:06:22 <kmc> > union "foobar" "abc"
22:06:24 <lambdabot>   "foobarc"
22:06:30 <kmc> @src union
22:06:31 <lambdabot> union = unionBy (==)
22:06:41 <kmc> ColonelJ, if you want to do set operations you really should use Data.Set
22:07:18 <ColonelJ> kmc: I want to merge two lists generated by the 1..n thing
22:07:28 <ColonelJ> well union rather than merge
22:08:25 <roostaj> mmorrow: no idea
22:08:34 <roostaj> , time $ sum ([3,6..(5000000-1)] ++ [x | x <- [5,10..(5000000-1)], x `mod` 3 /= 0])
22:08:39 <lunabot>  Killed.
22:10:03 <Axman6> :t enumFromThenTo
22:10:04 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
22:10:35 <ColonelJ> , time $ let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 5000000 [3,5]
22:10:41 <lunabot>  Killed.
22:10:51 <ColonelJ> , time $ let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 500000 [3,5]
22:10:57 <lunabot>  Killed.
22:11:04 <mmorrow> roostaj: it was just a regular error message, that lunabot's error-prettifying (or lack thereof) failed to filter out the shell message
22:11:11 <ColonelJ> , time $ let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 50000 [3,5]
22:11:15 <roostaj> mmorrow: ah ok
22:11:17 <lunabot>  Killed.
22:11:23 <ColonelJ> , time $ let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 5000 [3,5]
22:11:25 <lunabot>  (7.6988e-2,5829168)
22:11:28 <roostaj> ColonelJ: someone posted a pretty speedy solution earlier
22:12:00 <ColonelJ> all I need is the function I asked for and didn't get, because it's in an unstable library, or something
22:12:14 <roostaj> :(
22:12:16 <ColonelJ> , time $ let euler1 n ds = sum (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 5000 [3,5]
22:12:18 <lunabot>  (7.7988e-2,5829168)
22:12:23 <ColonelJ> wtf that's not the answer
22:12:29 <Jonno_FTW> use foldl' (+) 0 instead of sim
22:12:31 <Jonno_FTW> *sum
22:12:35 <roostaj> , time $ sum [3,6..999] + sum [5,10..995] - sum[15,30..990]
22:12:38 <lunabot>  (0.0,233168)
22:12:42 <Jonno_FTW> @src sum
22:12:42 <lambdabot> sum = foldl (+) 0
22:12:47 <ColonelJ> omfg
22:13:05 <ColonelJ> , time $ let euler1 n ds = foldl' (+) 0 (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 5000 [3,5]
22:13:08 <lunabot>  (7.6988e-2,5829168)
22:13:17 <roostaj> , time $ sum [3,6..4999999] + sum [5,10..4999995] - sum[15,30..4999990]
22:13:20 <lunabot>  Stack space overflow: current size 8388608 bytes.
22:13:20 <lunabot>  Use `+RTS -Ksize' to increase it.
22:13:30 <roostaj> , time $ sum [3,6..4999999] + sum [5,10..4999995] - sum[15,30..4999990]
22:13:33 <lunabot>  Stack space overflow: current size 8388608 bytes.
22:13:33 <lunabot>  Use `+RTS -Ksize' to increase it.
22:13:43 <roostaj> , time $ sum [3,6..499999] + sum [5,10..499995] - sum[15,30..499990]
22:13:45 <ColonelJ> Jonno_FTW: that made barely any difference
22:13:48 <lunabot>  (0.228965,58333416663)
22:14:01 <Jonno_FTW> it's a memory thing rather than speed
22:14:10 <ColonelJ> oh
22:14:15 <ColonelJ> ah yes
22:14:24 <ColonelJ> , time $ let euler1 n ds = foldl' (+) 0 (foldl' union [] (map (\x -> [x,2*x..n-1]) ds)) in euler1 50000 [3,5]
22:14:30 <lunabot>  Killed.
22:14:34 <Jonno_FTW> shouldn't encounter stack overflow
22:14:54 <ColonelJ> what can I use instead of union
22:14:59 <roostaj> @src union
22:15:00 <lambdabot> union = unionBy (==)
22:15:06 <roostaj> @src unionBy
22:15:06 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
22:15:42 <ColonelJ> @src Set.union
22:15:42 <lambdabot> Source not found. It can only be attributed to human error.
22:18:01 <roostaj> , time $ let euler1 n ds1:ds2:ds = sum [ds1,ds1*2..n] + sum [ds2,ds2*2..n] - sum [x,x*2..n] where x = lcm ds1 ds2 in euler1 50000 [3,5]
22:18:01 <lunabot>  luna: Parse error in pattern
22:18:07 * roostaj mumbles
22:18:17 <ColonelJ> @src Data.Set.union
22:18:17 <lambdabot> Source not found. Do you think like you type?
22:18:24 <kmc> , fix error
22:18:30 <lunabot>  Killed.
22:18:33 <ColonelJ> lol
22:19:56 <roostaj> woah i'm not seeing the error...
22:20:02 <yrlnry> byorgey:  still there?
22:20:15 <roostaj> oh wait
22:20:18 * roostaj slaps face
22:21:47 <roostaj> , time $ let euler1 n (ds1:ds2:ds) = sum [ds1,ds1*2..n] + sum [ds2,ds2*2..n] - sum [x,x*2..n] where x = lcm ds1 ds2 in euler1 50000 [3,5]
22:21:49 <lunabot>  (5.999e-3,583341668)
22:21:57 <roostaj> ColonelJ: that seems to work
22:21:59 <roostaj> lol
22:22:13 <roostaj> , time $ let euler1 n (ds1:ds2:ds) = sum [ds1,ds1*2..n] + sum [ds2,ds2*2..n] - sum [x,x*2..n] where x = lcm ds1 ds2 in euler1 5000000 [3,5]
22:22:15 <lunabot>  Stack space overflow: current size 8388608 bytes.
22:22:15 <lunabot>  Use `+RTS -Ksize' to increase it.
22:22:19 <roostaj> , time $ let euler1 n (ds1:ds2:ds) = sum [ds1,ds1*2..n] + sum [ds2,ds2*2..n] - sum [x,x*2..n] where x = lcm ds1 ds2 in euler1 500000 [3,5]
22:22:21 <lunabot>  (0.225965,58333416668)
22:23:13 <ColonelJ> how does that generalize?
22:23:19 <roostaj> , time $ let euler1 n (ds1:ds2:ds) = sum [ds1,ds1*2..n] + sum [ds2,ds2*2..n] - sum [x,x*2..n] where x = lcm ds1 ds2 in euler1 50000 [1,2]
22:23:21 <lunabot>  (2.4996e-2,1250025000)
22:23:43 <roostaj> ColonelJ: are you going for more than just two numbers?
22:23:51 <ColonelJ> arbitrary number
22:23:59 <ColonelJ> though small probably
22:24:02 <roostaj> ColonelJ: then by your standards it does not
22:24:06 <roostaj> :D
22:24:10 <ColonelJ> I think it does
22:24:23 <roostaj> ColonelJ: it will only work for sets of two numbers
22:24:33 <roostaj> ColonelJ: i.e. 3 and 5 or 1 and 2 or 199 and 204
22:25:12 <ColonelJ> I know what you're saying, I'm trying to generalize the idea, not your implementation of it
22:25:17 <roostaj> , time $ let euler1 n (ds1:ds2:_) = sum [ds1,ds1*2..n] + sum [ds2,ds2*2..n] - sum [x,x*2..n] where x = lcm ds1 ds2 in euler1 50000 [199,204]
22:25:20 <lunabot>  (0.0,12400518)
22:25:22 <roostaj> ColonelJ: si
22:25:28 <ColonelJ> you're generating the intersection and then subtracting it
22:26:02 <Jafet> Good, you have discovered the principle of inclusion-exclusion.
22:26:16 <roostaj> do you want to be able to take x values and find the sum of all multiples under a value n?
22:26:28 <ColonelJ> yes
22:26:34 <roostaj> ok, well mine does 2 values under n
22:26:35 <roostaj> lol
22:26:43 * roostaj crumbles
22:26:55 * roostaj grumbles because he meant grumbles not crumbles
22:27:16 * ColonelJ thinks crumbles was funnier
22:27:23 <sohum> @hoogle b -> (a -> b) -> Maybe a -> b
22:27:24 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
22:27:24 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
22:27:24 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
22:27:26 <roostaj> lol
22:27:42 <sohum> uh duh
22:28:26 <ColonelJ> @hoogle a => [a] -> [a] -> [a]
22:28:27 <lambdabot> Did you mean: [a] -> [a] -> [a] /count=20
22:28:27 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
22:28:27 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
22:28:29 * roostaj goes to read
22:29:05 <ColonelJ> @hoogle [a] -> [a] -> [a] /count=20
22:29:05 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
22:29:05 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
22:29:05 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
22:31:55 <ColonelJ> roostaj: by the way you can do those sums using the formula
22:32:17 <ColonelJ> which gets rid of the lists entirely
22:32:29 <roostaj> ColonelJ: which formula?
22:32:42 <ColonelJ> n(n+1) / 2
22:33:03 <ColonelJ> edited to work with multiples
22:33:31 <ColonelJ> (n / m)(n/m + 1) / 2 * m
22:34:18 <roostaj> ColonelJ: it works?
22:34:27 <ColonelJ> should do yes
22:34:30 <ColonelJ> I'll try it
22:34:36 <roostaj> k let me know
22:34:40 <ColonelJ> oh div rather than /
22:36:18 <MoALTz> let (/) = div in xxxxx
22:36:31 <ColonelJ> ah yeah thanks
22:36:37 <MoALTz> better than making it ugly with lots of `div`s
22:36:48 <ColonelJ> can you nest lets
22:37:08 <roostaj> my lack of experience says yes
22:37:11 <MoALTz> you can do like: let (/) = div; y = x in xxx
22:37:27 <ColonelJ> ok
22:37:32 <kmc> ColonelJ, yes, "let ... in ..." is an expression
22:37:51 <ColonelJ> can I use / in the x above
22:38:02 <kmc> yes
22:38:04 <kmc> let is recursive
22:38:11 <kmc> by default, and always
22:38:16 <ColonelJ> then I don't need to use recursive let, or is that just syntatic sugar
22:38:19 <MoALTz> > let (/) = div; n = 1; m = 3 in (n / m)(n/m + 1) / 2 * m
22:38:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = t -> a
22:38:32 <kmc> > let a = 'a' : b; b = 'b' : a in zip a b
22:38:33 <lambdabot>   [('a','b'),('b','a'),('a','b'),('b','a'),('a','b'),('b','a'),('a','b'),('b'...
22:38:44 <monochrom> We don't have a separate "letrec".
22:38:52 <Axman6> :o
22:38:55 <ColonelJ> ahh scheme
22:39:02 <kmc> scheme and ML do
22:39:35 <Axman6> > let a = 'a' : map succ b; b = 'b' : map succ a in zip a b
22:39:37 <lambdabot>   [('a','b'),('c','b'),('c','d'),('e','d'),('e','f'),('g','f'),('g','h'),('i'...
22:40:02 <Axman6> > let a = 'a' : map succ b; b = 'b' : a in zip a b
22:40:03 <lambdabot>   [('a','b'),('c','a'),('b','c'),('d','b'),('c','d'),('e','c'),('d','e'),('f'...
22:40:15 <kmc> > let a = 'a' : map succ b; b = 'b' : map succ a in concat . transpose $ [a,b]
22:40:16 <lambdabot>   "abcbcdedefgfghihijkjklmlmnonopqpqrsrstutuvwvwxyxyz{z{|}|}~\DEL~\DEL\128\12...
22:40:30 <Jafet> let s n = div (n * (n+1)) 2; c k ds = if k==0 then [1] else if null ds then ds else map (head ds*) (c (k-1) (tail ds)) ++ c k (tail ds); e n ds k = let t = sum $ map (\d -> s (div (n-1) d) * d) (c k ds) in if t == 0 then 0 else t - e n ds (k+1); euler n ds = e n ds 1 in euler (10^100) $ map (10^) [10,20..100]
22:40:36 <Jafet> Ha
22:40:39 <Jafet> > let s n = div (n * (n+1)) 2; c k ds = if k==0 then [1] else if null ds then ds else map (head ds*) (c (k-1) (tail ds)) ++ c k (tail ds); e n ds k = let t = sum $ map (\d -> s (div (n-1) d) * d) (c k ds) in if t == 0 then 0 else t - e n ds (k+1); euler n ds = e n ds 1 in euler (10^100) $ map (10^) [10,20..100]
22:40:40 <lambdabot>   500000000049999999999999999999999999999949999999999999999999500000000000000...
22:40:41 <kmc> ehehehe
22:40:51 <Jafet> There, inclusion-exclusion
22:41:01 <kmc> i once got lambdabot to compute the area of the Mandelbrot set
22:41:05 <kmc> (to not very good resolution)
22:41:45 <kmc> @src fix
22:41:46 <lambdabot> fix f = let x = f x in x
22:44:17 <roostaj> lol i completely misread euler#20
22:44:25 <roostaj> "Find the sum of the digits in the number 100!"
22:44:28 <sohum> @hoogle Either a b -> b
22:44:29 <lambdabot> Data.Either rights :: [Either a b] -> [b]
22:44:29 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
22:44:29 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
22:44:36 <roostaj> 100*99*98*..*1
22:44:43 <roostaj> 1+0+0+9+9+9+8+..+1
22:44:48 <roostaj> is not the intention
22:44:48 <roostaj> lol
22:44:49 <kmc> 1+0+0=1
22:44:54 <roostaj> i know
22:44:54 <ColonelJ> yeah that ones really easy actually
22:44:57 * roostaj slaps face
22:45:11 <ColonelJ> you can do it with a calculator
22:45:12 <roostaj> it actually wants the digits of 100!
22:45:26 <ColonelJ> oh
22:45:26 <roostaj> not the digits of every number used in the calculation
22:45:30 <roostaj> lol
22:45:36 <Jafet> > sum $ map digitToInt $ product [1..100]
22:45:37 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
22:45:38 <lambdabot>    arising from the literal ...
22:45:39 <kmc> > sum . map digitToInt . show $ product [1..100]
22:45:40 <lambdabot>   648
22:45:43 <Jafet> Oops
22:45:50 * roostaj giggles
22:45:54 <Jonno_FTW> > let fac n = foldl' (*) 1 $ [1..n] in sum (map read $show $fac 100 :: Integer)
22:45:55 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
22:45:55 <lambdabot>         against inferred ty...
22:46:10 <kmc> @src product
22:46:11 <lambdabot> product = foldl (*) 1
22:46:12 <kmc> hehe
22:46:15 <roostaj> > sum $ map (sum . map digitToInt . show) [1..100]
22:46:16 <lambdabot>   901
22:46:25 <roostaj> is not the intention
22:46:26 <roostaj> lol
22:47:20 <ColonelJ> > let factorial n = if (n > 0) then n * factorial (n-1) else 1 in factorial 100
22:47:21 <sohum> @hoogle IO a -> a
22:47:21 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
22:47:22 <lambdabot> Foreign unsafePerformIO :: IO a -> a
22:47:22 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
22:47:22 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
22:47:28 <Jonno_FTW> > let fac n = foldl' (*) 1 $ [1..n] in sum (map digitToInt $ show $fac 100 :: Integer)
22:47:29 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
22:47:29 <lambdabot>         agains...
22:47:37 <roostaj> > product [1..100]
22:47:38 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
22:47:55 <ColonelJ> I thought I'd do it the pointless stupid way
22:48:11 <kmc> > length . show $ product [1..100]
22:48:12 <lambdabot>   158
22:48:30 <ColonelJ> :t log
22:48:31 <lambdabot> forall a. (Floating a) => a -> a
22:48:57 <ColonelJ> umm... which base is that
22:48:59 <roostaj> kmc: that's what i was thinking but it doesnt work
22:48:59 <ColonelJ> > log 10
22:49:00 <lambdabot>   2.302585092994046
22:49:08 <roostaj> kmc: err project euler disagrees
22:49:10 <ColonelJ> :t log10
22:49:11 <lambdabot> Not in scope: `log10'
22:49:21 <ColonelJ> kmc: the question asked you to sum the actual digits
22:49:33 <roostaj> kmc: its not length it sum
22:49:36 <roostaj> kmc: doh
22:49:43 <ColonelJ> kmc: rather than count them which you can do on a calculator
22:49:51 <ColonelJ> or using the function I'm about to write
22:50:20 <kmc> i did the sum
22:50:48 <roostaj> <kmc> > length . show $ product [1..100]
22:50:51 <ColonelJ> > length . show $ product [1..1000000000]
22:50:54 <ColonelJ> fail
22:50:58 <lambdabot>   mueval: ExitFailure 1
22:51:01 <ColonelJ> you can easily calculate that
22:51:11 <sohum> hm. why does having two lines in main which do an IO action only do the first one and then block?
22:51:23 <roostaj> > sum . map digitToInt . show $ product [1..100]
22:51:27 <lambdabot>   mueval-core: Time limit exceeded
22:51:46 <roostaj> > sum . map digitToInt . show $ product [1..100]
22:51:47 <lambdabot>   648
22:51:50 <roostaj> there iti s
22:51:53 <roostaj> there it is*
22:51:54 <kmc> > foldr (flip (M.insertWith (+)) 1) M.empty . show $ product [1..100]
22:51:55 <lambdabot>   fromList [('0',30),('1',15),('2',19),('3',10),('4',10),('5',14),('6',19),('...
22:52:06 <kmc> > M.toList . foldr (flip (M.insertWith (+)) 1) M.empty . show $ product [1..100]
22:52:08 <lambdabot>   [('0',30),('1',15),('2',19),('3',10),('4',10),('5',14),('6',19),('7',7),('8...
22:52:15 <roostaj> @src digitToInt
22:52:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:52:41 <Jonno_FTW> open the pod bay door lambdabot
22:54:26 <ColonelJ> > length (product [1..100])
22:54:27 <lambdabot>   No instance for (GHC.Num.Num [a])
22:54:28 <lambdabot>    arising from the literal `1' at <inter...
22:54:49 <kmc> > map snd . M.toList . foldr (flip (M.insertWith (+)) 1) M.empty . show $ product [1..100]
22:54:50 <lambdabot>   [30,15,19,10,10,14,19,7,14,20]
22:54:55 <MoALTz> > length $ show (product [1..100])
22:54:56 <lambdabot>   158
22:55:10 <ColonelJ> oright
22:55:11 <kmc> > map snd . M.toList . foldr (flip (M.insertWith (+)) 1) M.empty . show $ product [1..1000]
22:55:12 <lambdabot>   [472,239,248,216,229,213,231,217,257,246]
22:55:30 <Jonno_FTW> http://shootout.alioth.debian.org/
22:55:31 <kmc> > map snd . M.toList . foldr (flip (M.insertWith (+)) 1) M.empty $ showCReal 100 pi
22:55:32 <lambdabot>   [1,8,8,12,12,10,8,9,7,13,13]
22:55:41 <ColonelJ> This is the PROPER way to calculate it
22:55:42 <kmc> > map snd . M.toList . foldr (flip (M.insertWith (+)) 1) M.empty $ showCReal 1000 pi
22:55:43 <lambdabot>   [1,93,116,103,103,93,97,94,95,101,106]
22:55:44 <ColonelJ> > floor (sum (map log [1..100]) / log 10) + 1
22:55:45 <lambdabot>   158
22:55:48 <kmc> hmm
22:55:53 <ColonelJ> > floor (sum (map log [1..1000000]) / log 10) + 1
22:55:54 <lambdabot>   * Exception: stack overflow
22:55:57 <ColonelJ> damnit
22:56:07 <ColonelJ> > floor (foldl' (+) 0 (map log [1..1000000]) / log 10) + 1
22:56:08 <lambdabot>   5565709
22:56:10 <kmc> > map snd . M.toList . foldr (flip (M.insertWith (+)) 1) M.empty . showCReal 1000 $ exp 1
22:56:10 <ColonelJ> there we go
22:56:11 <lambdabot>   [1,100,96,98,109,100,85,99,99,103,112]
22:56:22 <kmc> stupid supposedly normal transcendental numbers
22:56:24 <MoALTz> :t ceiling
22:56:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:56:39 <ColonelJ> 5565709 is the number of digits in 1000000 factorial
22:56:52 <MoALTz> ah. you did a +1
22:57:03 <MoALTz> sorry... was wondering why there was a floor there
22:57:12 <ColonelJ> 10 has 2 digits, so does 99
22:57:13 <roostaj> > sum . map digitToInt . show $ product [1..1000000]
22:57:15 <lambdabot>   * Exception: stack overflow
22:57:32 <ColonelJ> the log of 10 base 10 is 1 and the log of 99 base 10 is nearly
22:57:33 <ColonelJ> 2
22:58:01 <MoALTz> i know. i was just wondering why there was a floor instead of ceiling used (instead you added +1 before the floor... same thing more or less)
22:58:03 <ColonelJ> roostaj: no, you can't do that
22:58:12 <roostaj> ColonelJ: can't do what
22:58:21 <ColonelJ> MoALTz: I added it after the floor
22:58:37 <ColonelJ> and it doesn't matter which order you do it anyway
22:58:58 <roostaj> > sum . map digitToInt . show $ product [1..1000]
22:58:59 <lambdabot>   10539
22:59:04 <ColonelJ> you can't use ceiling because it doesn't work for 10
22:59:13 <ColonelJ> or any power of 10
22:59:18 <roostaj> > sum . map digitToInt . show $ product [1..100]
22:59:20 <lambdabot>   648
22:59:29 <ColonelJ> > floor (foldl' (+) 0 (map log [1..1000]) / log 10) + 1
22:59:30 <lambdabot>   2568
23:00:05 <ColonelJ> > length $ show (product [1..1000])
23:00:06 <lambdabot>   2568
23:00:39 <roostaj> ColonelJ: are you talking about euler20?
23:00:44 <ColonelJ> nope
23:00:46 <roostaj> oh ok
23:00:48 <roostaj> :)
23:00:51 <ColonelJ> just finding the number of digits in a factorial
23:01:03 <roostaj> ah ok, it's similar to euler 20 where you find the sum of those digits
23:01:10 <ColonelJ> no, it isn't
23:01:18 <ColonelJ> in fact there might be a euler on it later
23:01:40 <ColonelJ> > floor (foldl' (+) 0 (map log [1..10000000]) / log 10) + 1
23:01:41 <roostaj> ColonelJ: how is it not similar?
23:01:42 <lambdabot>   65657060
23:01:48 <ColonelJ> you don't care about the digits
23:01:52 <ColonelJ> > floor (foldl' (+) 0 (map log [1..100000000]) / log 10) + 1
23:01:56 <lambdabot>   mueval-core: Time limit exceeded
23:02:11 <ColonelJ> and it depends on maths rather than programming
23:02:32 <ColonelJ> I think there's a way to simplify it more
23:02:54 <roostaj> ColonelJ: similar :)
23:03:04 <ColonelJ> The problem is completely different
23:03:12 <sohum> :t show &&& show
23:03:13 <lambdabot> forall b. (Show b) => b -> (String, String)
23:03:21 <sohum> :t show *** show
23:03:22 <lambdabot> forall b b'. (Show b, Show b') => (b, b') -> (String, String)
23:03:34 <sohum> @pl \a b -> show a ++ show b
23:03:34 <lambdabot> (. show) . (++) . show
23:03:49 * roostaj looks at his tomatoe... no wait its a tomatoe
23:04:00 <ColonelJ> tomato
23:04:01 * roostaj thinks its spelt tomato
23:04:09 * roostaj was corrected
23:04:20 <ColonelJ> stands corrected
23:04:22 <sohum> :t uncurry (++) . uncurry (show *** show)
23:04:23 * roostaj (g/c)umbles
23:04:23 <lambdabot>     Couldn't match expected type `b -> (a, a)'
23:04:23 <lambdabot>            against inferred type `(String, String)'
23:04:23 <lambdabot>     In the first argument of `uncurry', namely `(show *** show)'
23:04:33 <sohum> :t uncurry (++) . curry (show *** show)
23:04:34 <lambdabot>     Couldn't match expected type `(a, a)'
23:04:34 <lambdabot>            against inferred type `b -> (String, String)'
23:04:34 <lambdabot>     Probable cause: `curry' is applied to too few arguments
23:04:42 <sohum> :t uncurry (++) . curry . (show *** show)
23:04:43 <ColonelJ> [g,c] : "rumbles"
23:04:43 <lambdabot>     Couldn't match expected type `(a, a)'
23:04:44 <lambdabot>            against inferred type `a1 -> b -> c'
23:04:44 <lambdabot>     In the first argument of `(.)', namely `curry'
23:04:51 * roostaj can't spell
23:04:59 <Axman6>  :t (++) `on` show
23:05:07 <Axman6> :t (++) `on` show
23:05:09 <lambdabot> forall a. (Show a) => a -> a -> String
23:05:14 <sohum> uh duuuh
23:05:17 <sohum> thanks
23:05:19 <ColonelJ> > map (\x -> x : "rumbles") [g,c]
23:05:20 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
23:05:20 <lambdabot>         against inferred type...
23:05:25 <sohum> my brain is notsogood today
23:05:40 <ColonelJ> > 5 : [2,3,65]
23:05:41 <lambdabot>   [5,2,3,65]
23:05:53 <ColonelJ> > map (\x -> x : "rumbles") ['g','c']
23:05:54 <lambdabot>   ["grumbles","crumbles"]
23:05:56 <ColonelJ> silly me
23:06:21 <ColonelJ> > map (\x -> x : "rumbles") ['b','t']
23:06:22 <lambdabot>   ["brumbles","trumbles"]
23:06:37 <thinkmore> Ah, I was about to say are g and c previously defined?
23:06:54 <ColonelJ> > map (\x -> x : "rumbles") ['d','f','k']
23:06:55 <lambdabot>   ["drumbles","frumbles","krumbles"]
23:07:13 <MoALTz> map (: "rumbles") ['d','f','k']
23:07:15 <ColonelJ> :t g
23:07:16 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
23:07:20 <ColonelJ> :t c
23:07:21 <lambdabot> Expr
23:07:24 <ColonelJ> rofl wtf
23:07:32 <Axman6> ?
23:07:34 <ezyang> yeah, lambdabot's pretty special
23:07:43 <Axman6> > a + 1
23:07:45 <lambdabot>   a + 1
23:08:04 <Axman6> > scanl (+) z [a,b,c]
23:08:05 <lambdabot>   [z,z + a,z + a + b,z + a + b + c]
23:08:08 <ColonelJ> :t c
23:08:09 <lambdabot> Expr
23:08:13 <ColonelJ> :t z
23:08:14 <lambdabot> Expr
23:08:19 <ColonelJ> :t o
23:08:20 <lambdabot> Expr
23:08:32 <thinkmore> LOL
23:09:00 <Axman6> ? :\
23:09:13 <thinkmore> >  putStrLn . (++ "!!") . (>> "AA") $ "Hello world !"
23:09:14 <lambdabot>   <IO ()>
23:09:16 <ColonelJ> > scanl (+) z [g,b,c]
23:09:18 <lambdabot>   [z,z + g,z + g + b,z + g + b + c]
23:09:19 <vegai> why does g have a different type?
23:09:25 <thinkmore> >  (++ "!!") . (>> "AA") $ "Hello world !"
23:09:26 <ColonelJ> :t g
23:09:27 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAA!!"
23:09:27 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
23:09:31 <thinkmore> Awwww
23:09:34 <thinkmore> Yay
23:09:44 <vegai> > g
23:09:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:09:45 <lambdabot>    `SimpleReflect.FromExpr ...
23:09:53 * vegai shrugs
23:10:07 <Axman6> > a + g
23:10:08 <lambdabot>   a + g
23:10:13 <Axman6> > g + g
23:10:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:10:14 <lambdabot>    `SimpleReflect.FromExpr ...
23:10:18 <ColonelJ> LOL
23:10:46 <ColonelJ> wth is going on
23:11:04 <medfly> @unlet
23:11:05 <lambdabot>  Defined.
23:11:12 <ColonelJ> :t g
23:11:13 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
23:11:14 * medfly BREAKS EVERYTHING
23:11:19 <ColonelJ> @unlet g
23:11:19 <lambdabot>   Parse error: SemiColon
23:11:46 * roostaj walks away whistling
23:14:22 <MoALTz> > let f n = 1/n - 1 in fix (\r n -> (f n) : r (f n)) 1.1
23:14:23 <lambdabot>   [-9.090909090909094e-2,-11.999999999999996,-1.0833333333333333,-1.923076923...
23:15:03 <kmc> > a + a
23:15:05 <lambdabot>   a + a
23:15:21 <sohum> @pl \x -> f a b . g x
23:15:21 <lambdabot> (f a b .) . g
23:15:42 <ColonelJ> @list
23:15:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:15:43 <MoALTz> @pl (\r n -> (f n) : r (f n))
23:15:43 <lambdabot> liftM2 (:) f . (. f)
23:15:52 <sohum> wait a sec
23:16:03 <sohum> :t (++) `on` show
23:16:05 <lambdabot> forall a. (Show a) => a -> a -> String
23:16:08 <sohum> nooo
23:16:15 <Axman6> ha!
23:16:17 <Axman6> :P
23:16:20 <sohum> I need Show a, Show b => a -> b -> String
23:16:33 <kmc> @let a +++ b = (show a) ++ (show b)
23:16:34 <lambdabot>  Defined.
23:16:39 <kmc> > 4 +++ "chicken"
23:16:40 <lambdabot>   Ambiguous occurrence `+++'
23:16:40 <lambdabot>  It could refer to either `L.+++', defined at <l...
23:16:47 <kmc> grr stupid arrow
23:16:47 <kmc> @unlet
23:16:49 <lambdabot>  Defined.
23:16:51 <Axman6> :t liftM2 (++) show show
23:16:52 <lambdabot> forall a. (Show a) => a -> String
23:16:53 <kmc> > 4 ++++++ "chicken"
23:16:54 <lambdabot>   Not in scope: `++++++'
23:16:57 <Axman6> hmm
23:16:58 <kmc> > 4 ++++++ "chicken"
23:16:58 <ColonelJ> :t g
23:16:59 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
23:16:59 <lambdabot>   Not in scope: `++++++'
23:17:00 <kmc> > 4 ++++++ "chicken"
23:17:02 <lambdabot>   Not in scope: `++++++'
23:17:04 <ColonelJ> kmc: :t g
23:17:07 <kmc> @let a ++++++ b = (show a) ++ (show b)
23:17:08 <lambdabot>  Defined.
23:17:10 <kmc> > 4 ++++++ "chicken"
23:17:11 <lambdabot>   "4\"chicken\""
23:17:23 <kmc> :t g
23:17:24 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
23:17:27 <sohum> :t (show &&& show)
23:17:28 <lambdabot> forall b. (Show b) => b -> (String, String)
23:17:36 <roostaj> > "mw" ++ cycle "ah"
23:17:37 <sohum> :t (show *** show)
23:17:37 <lambdabot>   "mwahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
23:17:38 <lambdabot> forall b b'. (Show b, Show b') => (b, b') -> (String, String)
23:17:51 <kmc> :t curry (show *** show)
23:17:52 <lambdabot> forall a b. (Show a, Show b) => a -> b -> (String, String)
23:17:55 <kmc> @pl \x -> (x *** x)
23:17:56 <lambdabot> join (***)
23:18:03 <kmc> :t curry $ join (***)
23:18:04 <lambdabot>     No instance for (Arrow (,))
23:18:05 <lambdabot>       arising from a use of `***' at <interactive>:1:13-17
23:18:05 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
23:18:14 <ColonelJ> @hoogle g
23:18:15 <lambdabot> Data.Graph.Inductive.Example g3 :: Gr Char String
23:18:15 <lambdabot> Data.Graph.Inductive.Example g3b :: Gr Char String
23:18:15 <lambdabot> Test.QuickCheck.Poly type GAMMA = Poly GAMMA_
23:18:21 <sohum> :t curry $ join (***) show
23:18:22 <lambdabot> forall b. (Show b) => b -> b -> (String, String)
23:18:25 <sohum> see?
23:18:33 <sohum> join restricts to same type
23:18:37 <kmc> ColonelJ, it's from simple-reflect
23:18:42 <kmc> allows us to  write things like
23:18:48 <kmc> > foldr f 0 [a,b,c]
23:18:49 <lambdabot>   Ambiguous type variable `b' in the constraints:
23:18:49 <lambdabot>    `SimpleReflect.FromExpr ...
23:18:52 <sohum> :t uncurry . curry (show *** show)
23:18:53 <kmc> > foldr f 0 [a,b,c] :: Expr
23:18:54 <lambdabot>     Couldn't match expected type `b -> c'
23:18:54 <lambdabot>            against inferred type `(String, String)'
23:18:54 <lambdabot>     In the first argument of `curry', namely `(show *** show)'
23:18:55 <lambdabot>   f a (f b (f c 0))
23:18:58 <sohum> :t uncurry (++) . curry (show *** show)
23:18:59 <lambdabot>     Couldn't match expected type `(a, a)'
23:18:59 <lambdabot>            against inferred type `b -> (String, String)'
23:18:59 <lambdabot>     Probable cause: `curry' is applied to too few arguments
23:19:00 <ColonelJ> > foldr g 0 [a,b,c]
23:19:01 <lambdabot>   Ambiguous type variable `b' in the constraints:
23:19:02 <lambdabot>    `SimpleReflect.FromExpr ...
23:19:31 <sohum> :t uncurry (++)
23:19:33 <lambdabot> forall a. (Monoid a) => (a, a) -> a
23:19:49 <kmc> :t op
23:19:50 <lambdabot> Not in scope: `op'
23:20:05 <sohum> :t (.) (uncurry (++))
23:20:07 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f) => f (a, a) -> f a
23:20:07 <kmc> > reduction (a+b+c)
23:20:08 <lambdabot>   Not in scope: `reduction'
23:20:10 <Axman6> :t (ap,on)
23:20:12 <lambdabot> forall (m :: * -> *) a b b1 c a1. (Monad m) => (m (a -> b) -> m a -> m b, (b1 -> b1 -> c) -> (a1 -> b1) -> a1 -> a1 -> c)
23:20:32 <kmc> :t (ap,on,map,fold,sort,liftM)
23:20:33 <lambdabot> Not in scope: `fold'
23:20:38 <kmc> :t (ap,on,map,foldr,sort,liftM)
23:20:39 <lambdabot> forall (m :: * -> *) a b b1 c a1 a2 b2 a3 b3 a4 a11 r (m1 :: * -> *). (Monad m, Ord a4, Monad m1) => (m (a -> b) -> m a -> m b, (b1 -> b1 -> c) -> (a1 -> b1) -> a1 -> a1 -> c, (a2 -> b2) -> [a2] -> [
23:20:39 <lambdabot> b2], (a3 -> b3 -> b3) -> b3 -> [a3] -> b3, [a4] -> [a4], (a11 -> r) -> m1 a11 -> m1 r)
23:20:55 <Axman6> :t (++) `on` show
23:20:56 <lambdabot> forall a. (Show a) => a -> a -> String
23:21:07 <ColonelJ> :t (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)
23:21:08 <lambdabot> forall a a1 a2. (SimpleReflect.FromExpr a, SimpleReflect.FromExpr a1, SimpleReflect.FromExpr a2) => (Expr, Expr, Expr, Expr, Expr, a, a1, a2, Expr, Expr, Expr, Expr, Expr, Expr, Expr, Expr, Expr,
23:21:08 <lambdabot> Expr, Expr, Expr, Expr, Expr, Expr, Expr, Expr, Expr)
23:21:08 <Axman6> :t (++) `on` show :: a -> b -> String
23:21:09 <lambdabot>     Couldn't match expected type `a' against inferred type `b'
23:21:09 <lambdabot>       `a' is a rigid type variable bound by
23:21:09 <lambdabot>           an expression type signature at <interactive>:1:18
23:21:12 <thinkmore> Having fun?
23:21:16 <kmc> :t (($), (<$>), ($ <$>), (<$> $), ($ (($) $)))
23:21:17 <lambdabot> parse error on input `<$>'
23:21:27 <thinkmore> :m +Control.Applicative
23:21:31 <thinkmore> can you do that?
23:21:36 <Axman6> no
23:21:37 <kmc> not in lambdabot
23:21:38 <sohum> :t (Prelude..) (uncurry (++))
23:21:39 <lambdabot> forall a a1. (Monoid a) => (a1 -> (a, a)) -> a1 -> a
23:21:52 <thinkmore> :t flip5
23:21:53 <lambdabot> Not in scope: `flip5'
23:21:56 <thinkmore> Awwwww
23:22:01 <sohum> :t (.) (uncurry (++)) (curry (show &&& show))
23:22:02 <lambdabot>     Couldn't match expected type `(a, a)'
23:22:02 <lambdabot>            against inferred type `b -> (String, String)'
23:22:02 <lambdabot>     Probable cause: `curry' is applied to too few arguments
23:22:07 <sohum> :t (curry (show &&& show))
23:22:08 <lambdabot> forall a b. (Show a, Show b) => a -> b -> (String, String)
23:22:18 <thinkmore> :t (>>>)
23:22:19 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
23:22:32 <kmc> :t ((uncurry (++)) .) . (curry (show &&& show))
23:22:34 <lambdabot> forall a b. (Show a, Show b) => a -> b -> String
23:22:48 <thinkmore> You're making lambdabot cry for the sake of humanity.
23:22:56 <sohum> :t result
23:22:57 <lambdabot> Not in scope: `result'
23:23:04 <sohum> @let result = (.)
23:23:05 <kmc> :t it
23:23:06 <lambdabot>  Defined.
23:23:06 <ColonelJ> > it
23:23:06 <lambdabot> Not in scope: `it'
23:23:07 <lambdabot>   Not in scope: `it'
23:23:16 <kmc> ...!
23:23:23 <sohum> :t (result . result) (uncurry (++)) (curry (show &&& show))
23:23:24 <lambdabot> forall a b. (Show a, Show b) => a -> b -> String
23:23:30 <kmc> @yhjulwwiefzojcbxybbruweejw
23:23:31 <lambdabot> Just 'J'
23:23:37 <sohum> icky, but ok
23:23:44 <Axman6> :t \a b c d e f g h i j k l m n o p q r s t u v w x y z -> n o i m n o t l a m b d a b o t l o v e s t h i s
23:23:46 <lambdabot>     Occurs check: cannot construct the infinite type:
23:23:46 <lambdabot>       t
23:23:46 <lambdabot>       =
23:23:55 <Axman6> heh
23:24:06 <kmc> >t \n o m -> n o m n o m
23:24:09 <kmc> :t \n o m -> n o m n o m
23:24:11 <lambdabot>     Occurs check: cannot construct the infinite type:
23:24:11 <lambdabot>       t = t1 -> t2 -> t -> t1 -> t2 -> t3
23:24:11 <lambdabot>     Probable cause: `n' is applied to too many arguments
23:24:50 <kmc> :t succ ∘ succ
23:24:51 <lambdabot> Not in scope: `???'
23:24:57 <ColonelJ> :t \a b c c b a
23:24:58 <lambdabot> parse error (possibly incorrect indentation)
23:25:02 <ColonelJ> :t \a b c -> c b a
23:25:03 <lambdabot> forall t t1 t2. t -> t1 -> (t1 -> t -> t2) -> t2
23:25:05 <kmc> > let (∘) = (.) in succ ∘ succ
23:25:07 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
23:25:16 <kmc> > let (∘) = (.) in succ ∘ succ :: Int -> Int
23:25:17 <lambdabot>   {-3->-1;-2->0;-1->1;0->2;1->3;2->4;3->5}
23:25:59 <ColonelJ> :t \a b c -> a b c a b
23:26:00 <lambdabot>     Occurs check: cannot construct the infinite type:
23:26:00 <lambdabot>       t = t1 -> t2 -> t -> t1 -> t3
23:26:00 <lambdabot>     Probable cause: `a' is applied to too many arguments
23:26:13 <kmc> :t f g x -> (f x) (g x)
23:26:14 <lambdabot> parse error on input `->'
23:26:15 <kmc> :t \f g x -> (f x) (g x)
23:26:16 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
23:26:20 <kmc> :t ap
23:26:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:26:38 <kmc> :t ap `asTypeOf` (\f g x -> (f x) (g x))
23:26:39 <lambdabot> forall a b t. (Monad ((->) t)) => (t -> a -> b) -> (t -> a) -> t -> b
23:27:00 <ColonelJ> :t \a b c x -> (a b c) (a b x)
23:27:01 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
23:27:01 <lambdabot>     Probable cause: `a' is applied to too few arguments
23:27:01 <lambdabot>     In the first argument of `(a b c)', namely `(a b x)'
23:27:09 <Jafet> Is that \circ?
23:27:18 <kmc> yeah
23:27:30 <kmc> :t let s = ap; k = const in s k k
23:27:31 <lambdabot> forall b. b -> b
23:28:03 <Jafet> > (λx -> x) 0
23:28:04 <ColonelJ> :t \a -> a a a a a
23:28:05 <lambdabot>   Pattern syntax in expression context: λx -> x
23:28:05 <lambdabot>     Occurs check: cannot construct the infinite type:
23:28:06 <lambdabot>       t = t -> t -> t -> t -> t1
23:28:06 <lambdabot>     Probable cause: `a' is applied to too many arguments
23:28:20 <ColonelJ> :t \a -> a a a a a 3
23:28:21 <lambdabot>     Occurs check: cannot construct the infinite type:
23:28:22 <lambdabot>       t = t -> t -> t -> t -> t1 -> t2
23:28:22 <lambdabot>     Probable cause: `a' is applied to too many arguments
23:28:27 <manjunaths> > pi
23:28:27 <lambdabot>   3.141592653589793
23:28:30 <kmc> :t let s = ap; k = const; i = id in s (k (s i i)) (s (s (k s) k) (k (s i i)))
23:28:31 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
23:28:31 <lambdabot>     Probable cause: `i' is applied to too few arguments
23:28:31 <lambdabot>     In the second argument of `s', namely `i'
23:28:41 <kmc> stupid strongly normalizing typed lambda calculus
23:28:55 <ColonelJ> :t \a x -> a (a (a (a (a x))))
23:28:56 <lambdabot> forall t. (t -> t) -> t -> t
23:29:06 <kmc> > showCReal 1000 pi
23:29:07 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
23:29:42 <ColonelJ> umm how accurate does it have pi?
23:29:47 <kmc> "In 2005 Mayer Goldberg showed that the set of fixed point combinators of untyped lambda calculus is recursively enumerable." :O
23:29:50 <kmc> ColonelJ, as accurate as you want
23:29:50 <ColonelJ> or does it  just figure it out as it goes along
23:30:01 <manjunaths> > let r = 2.0 in pi * r^2
23:30:02 <lambdabot>   12.566370614359172
23:30:22 <ColonelJ> > sin
23:30:23 <lambdabot>   -0.375->
23:30:23 <lambdabot>    -0.36627252908604757
23:30:23 <lambdabot>  -0.75->
23:30:23 <lambdabot>    -0.6816387600233341
23:30:23 <lambdabot>  -1.5->
23:30:25 <lambdabot>   ...
23:30:26 <manjunaths> > pi * (2.0^2)
23:30:28 <lambdabot>   12.566370614359172
23:30:33 <kmc> pi = 16 * atan (fromRational (1%5)) - 4 * atan (fromRational (1%239))
23:30:42 <ColonelJ> > sin (pi / 2)
23:30:43 <lambdabot>   1.0
23:30:48 <ColonelJ> > cos (pi / 2)
23:30:49 <lambdabot>   6.123233995736766e-17
23:30:52 <ColonelJ> fail
23:30:52 <kmc> atan is defined in terms of a scary power series
23:31:13 <kmc> > cos ((pi :: CReal) / 2)
23:31:14 <lambdabot>   0.0
23:31:29 <kmc> CReal is infinite-precision
23:31:33 <ColonelJ> oh
23:31:38 <kmc> Double is stupid IEEE 754 64-bit
23:31:51 <kmc> > let x = 0.0/0.0 in x == x
23:31:52 <lambdabot>   False
23:31:57 <kmc> > let x :: CReal; x = 0.0/0.0 in x == x
23:32:01 <lambdabot>   mueval-core: Time limit exceeded
23:32:02 <ColonelJ> @let pi = pi :: CRead
23:32:02 <kmc> ehehehe
23:32:03 <lambdabot>  <local>:11:5:
23:32:03 <lambdabot>      Ambiguous occurrence `pi'
23:32:03 <lambdabot>      It could refer to either `...
23:32:10 <ColonelJ> @let pi = pi :: CReal
23:32:10 <kmc> "0 == 0? the world may never know"
23:32:11 <lambdabot>  <local>:11:5:
23:32:11 <lambdabot>      Ambiguous occurrence `pi'
23:32:11 <lambdabot>      It could refer to either `...
23:32:21 <kmc> @let pi' :: CReal; pi' = pi
23:32:22 <kmc> :t pi'
23:32:23 <lambdabot>  Defined.
23:32:24 <lambdabot> CReal
23:32:36 <ColonelJ> > cos (pi' / 2)
23:32:37 <lambdabot>   0.0
23:32:55 <kmc> faith in chaos
23:32:58 <ColonelJ> > exp
23:32:59 <lambdabot>   -0.375->
23:32:59 <lambdabot>    0.6872892787909722
23:32:59 <lambdabot>  -0.75->
23:32:59 <lambdabot>    0.4723665527410147
23:32:59 <lambdabot>  -1.5->
23:33:01 <lambdabot>    0....
23:33:17 <ColonelJ> > exp (0 :+ 1 * pi')
23:33:18 <lambdabot>   (-1.0) :+ 0.0
23:33:21 <ColonelJ> win
23:33:24 <kmc> :D
23:33:30 <ColonelJ> > exp (0 :+ 1 * pi)
23:33:31 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
23:33:32 <ColonelJ> fail
23:33:36 <ColonelJ> pi' is good
23:33:42 <kmc> > exp (0 :+ pi') + 1 == 0
23:33:43 <lambdabot>   True
23:33:58 <kmc> > let i = 0 :+ 1 in exp (pi * i) + 1 == 0
23:34:00 <lambdabot>   False
23:34:05 <kmc> > let i = 0 :+ 1 in exp (pi' * i) + 1 == 0
23:34:06 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
23:34:06 <lambdabot>         against infe...
23:34:22 <kmc> :k CComplex
23:34:23 <lambdabot>     Not in scope: type constructor or class `CComplex'
23:34:24 <kmc> :(
23:34:27 <kmc> :t Complex CReal
23:34:28 <lambdabot> Not in scope: data constructor `Complex'
23:34:28 <lambdabot> Not in scope: data constructor `CReal'
23:34:29 <kmc> :k Complex CReal
23:34:30 <lambdabot> *
23:34:50 <kmc> @let pi'' :: Complex CReal; pi'' = pi
23:34:51 <lambdabot>  Defined.
23:34:57 <kmc> > let i = 0 :+ 1 in exp (pi'' * i) + 1 == 0
23:34:58 <lambdabot>   True
23:35:10 <manjunaths> what does the :+ notatio mean ?
23:35:13 <manjunaths> notation*
23:35:15 <ColonelJ> complex numbers
23:35:18 <manjunaths> ok
23:35:19 <kmc> :t (:+)
23:35:20 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
23:35:25 <ColonelJ> read back and you'll appreciate
23:35:32 <kmc> > (2%5) :+ (1%7)
23:35:33 <lambdabot>   No instance for (GHC.Float.RealFloat (GHC.Real.Ratio t))
23:35:33 <lambdabot>    arising from a ...
23:35:34 <kmc> :(
23:35:35 <manjunaths> yeah..now it is clean :-)
23:35:38 <manjunaths> clear*
23:35:47 <kmc> @unlet
23:35:48 <lambdabot>  Defined.
23:36:05 <ColonelJ> ok I'm off to bed
23:36:20 <ColonelJ> this is a crazy channel
23:36:57 <Jafet> We're "differently sane"
23:37:17 <kmc> @. elite nixon
23:37:18 <lambdabot> i D0n'T kNoW ANyt|-|InG t|-|4t builDz0rz 7|-|E wi|| 7O \/\/In 8e77ER th4n (OmPEti7IvE 5pOr+z.
23:37:31 <kmc> @quote sane
23:37:32 <lambdabot> #perl says: <tech> who needs saneness
23:37:33 <lunabot>  luna: Not in scope: `perl'
23:37:35 <kmc> hahaha
23:37:38 <kmc> hack
23:37:55 * kmc attempts to set up bot loop
23:39:01 <kmc> @quote toothpaste
23:39:02 <lambdabot> olliej says: <olliej> java is a great language <olliej> i like to eat toothpaste <olliej> :)
23:39:10 <manjunaths> I asked this question earlier, but is there a downloadable version of the GHC library documentation ?
23:39:11 <thinkmore> :t t
23:39:12 <lambdabot> Expr
23:39:31 <Jafet> I thought GHC ships with a copy
23:39:33 <pastah_rhymez> manjunaths: i think it comes with the installer...
23:39:52 <thinkmore> Saying java is good because it works on all operating systems is like saying anal sex is good just because it works on all genders.
23:40:02 <Jafet> It isn't very good documentation, though
23:40:13 <Jafet> Anal sex *is* good because it works on all genders!
23:40:24 <kmc> and most languages work on all operating systems
23:40:34 <kmc> *binary* compatibility is totally overblown
23:40:39 <manjunaths> pastah_rhymez, I installed through yum on fedora, so I don't know how to access it (or where it is)
23:40:46 <kmc> Java people touting that are almost as silly as Go people touting their compile times
23:40:52 <kmc> pick a feature nobody else cares about, then dominate it
23:41:10 <pastah_rhymez> manjunaths: check the package ghc-doc and list its installed files
23:41:16 <Jafet> manjunaths, your system documentation directory
23:41:17 <kmc> @quote anal
23:41:18 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
23:41:20 <kmc> @quote anal
23:41:21 <lambdabot> Axman6 says: -ddump-occur-anal <- another terrible name...
23:41:22 <Jafet> Probably under ghc/
23:41:22 <kmc> @quote anal.sex
23:41:23 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
23:41:48 <pastah_rhymez> Jafet: well, it's different on different systems where that is
23:41:53 <Jafet> *TRWBW suggests not typing "introduction to anal" in google
23:42:05 <kmc> what about "introduction to complex anal"
23:42:34 <Jafet> I prefer real anal
23:42:52 <kmc> , [$bf|,[..,]|] "I don't usually drink this much coffee"
23:42:54 <lunabot>  "II  ddoonn''tt  uussuuaallllyy  ddrriinnkk  tthhiiss  mmuucchh  ccooffff...
23:42:57 <manjunaths> pastah_rhymez, ok...I think I found it
23:43:06 <pastah_rhymez> manjunaths: XD
23:43:45 <thinkmore> , [$bf|,[..,]|] "Wtf how?"
23:43:46 <lunabot>  "WWttff  hhooww??*** Exception: bf blocked on input"
23:43:49 <thinkmore> LOL
23:44:10 <manjunaths> I wonder I couldn't find when I looked earlier :-/
23:44:27 <manjunaths> I connected my desktop monitor to my laptop
23:44:29 <kmc> #bf +[.+]
23:44:30 <lunabot>  luna: No instance for (GHC.Show.Show
23:44:34 <manjunaths> and now I have a dual-head setup
23:44:44 <kmc> [$bf| +[.+] |]
23:44:46 <thinkmore> Windows+P ftw
23:44:49 <kmc> , [$bf| +[.+] |]
23:44:50 <lunabot>  luna: No instance for (GHC.Show.Show
23:44:53 <manjunaths> with the desktop monitor turned 90 degrees
23:44:53 <kmc> , [$bf| +[.+] |] ""
23:44:54 <lunabot>  "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN...
23:45:05 <kmc> , [$bf| ,[.+] |] "@"
23:45:07 <lunabot>  "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128...
23:45:11 <thinkmore> @unlet b
23:45:11 <lambdabot>   Parse error: SemiColon
23:45:16 <manjunaths> now I can happily read RWH on one monitor and try stuff out in another :p
23:45:31 <thinkmore> manjunaths, How experienced are you with hs?
23:45:42 <kmc> #ty [$bf||]
23:45:43 <lunabot>  luna: parse error on input `|]'
23:45:44 <manjunaths> thinkmore, 3 weeks
23:46:11 <thinkmore> manjunaths, Ah.  I bet it's late, but I still think that learnyouahaskell THEN rwh is superior.
23:46:11 <HugoDaniel> read "asd" :: Integer
23:46:13 <HugoDaniel> *** Exception: Prelude.read: no parse
23:46:15 <HugoDaniel> how do i handle this ?
23:46:24 <manjunaths> thinkmore, I have LYAH
23:46:27 <HugoDaniel> i want it to produce the number 0 whenever text is found
23:46:28 <manjunaths> thinkmore, and it is good
23:46:31 <thinkmore> rwh's basics falter in comparison imo
23:46:45 <thinkmore> manjunaths, Ah, alright.  Just recommended as some don't know about it.
23:46:46 <manjunaths> thinkmore, yeah, RWH is bad for beginners
23:46:47 <bastl> @ty read
23:46:48 <lambdabot> forall a. (Read a) => String -> a
23:46:51 <manjunaths> thinkmore, ty
23:47:02 <bastl> @ty try
23:47:03 <lambdabot> Not in scope: `try'
23:47:07 <manjunaths> thinkmore, I got recommendation from this channel
23:47:08 <thinkmore> If they used the lyah style to teach me pointers, C would have been a breeze
23:47:09 <bastl> @ty catch
23:47:10 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
23:47:27 <thinkmore> manjunaths, Ah, these people know everything.  I ventured into hs on my own, and found this channel in my post-monads stage
23:47:32 * Cyneox re
23:47:36 <bastl> HugoDaniel you can somehow catch the error.
23:47:39 <HugoDaniel> can someone help me out ?
23:47:40 <HugoDaniel> hmm
23:47:41 <manjunaths> thinkmore, I was far luckier than you
23:47:44 <HugoDaniel> yes... how ?
23:48:06 <manjunaths> funny thing is I've got a friend of mine at work addicted to haskell :p
23:48:21 <manjunaths> just by talking about it
23:49:01 <thinkmore> manjunaths, Hehe, a (now) friend on the C# channel bashed my C# example and said look at f# a year ago.  I did, and then began looking at hs after a couple months when I noticed that you can't make an increment function effortlessly work on int and double  =P
23:49:13 <thinkmore> That was a big msg.  Lol maybe private now...
23:49:25 <thinkmore> I'm addicting my entire cs department
23:49:30 <thinkmore> They will slowly become my slaves!
23:49:34 <manjunaths> heh...true
23:49:39 <thinkmore> And I'm only a freshman lmao
23:49:49 * roostaj readies the paddles
23:49:59 <kmc> > let f xs = case read xs of [] -> 0, ((p,_):_) -> p in [f "", f "bleh", f "123]
23:50:00 <lambdabot>   <no location info>: parse error on input `,'
23:50:06 <kmc> > let f xs = case read xs of [] -> 0; ((p,_):_) -> p in [f "", f "bleh", f "123]
23:50:07 <lambdabot>   <no location info>:
23:50:07 <lambdabot>      lexical error in string/character literal at end o...
23:50:13 <kmc> > let f xs = case read xs of [] -> 0; ((p,_):_) -> p in [f "", f "bleh", f "123"]
23:50:15 <lambdabot>   Ambiguous type variable `t' in the constraint:
23:50:15 <lambdabot>    `GHC.Read.Read t'
23:50:15 <lambdabot>      ar...
23:50:19 <kmc> > let f xs = case read xs of [] -> 0; ((p,_):_) -> p in [f "", f "bleh", f "123"] :: [Int]
23:50:20 <lambdabot>   Ambiguous type variable `t' in the constraint:
23:50:20 <lambdabot>    `GHC.Read.Read t'
23:50:20 <lambdabot>      ar...
23:50:41 <kmc> > let f :: (Num a, Read a) => String -> a; f xs = case reads xs of [] -> 0; ((p,_):_) -> p in [f "", f "bleh", f "123"] :: [Int]
23:50:42 <lambdabot>   [0,0,123]
23:50:45 <kmc> HugoDaniel, ^^^^^
23:50:48 <kmc> sorry for spam everyone
23:50:50 <HugoDaniel> why doesn't this work ?  catch e (const 0)
23:50:52 <HugoDaniel> hmm
23:50:56 <HugoDaniel> kmc, can you make that simpler ?
23:51:00 <kmc> no
23:51:03 <kmc>  maybe a little
23:51:04 <kmc> i'm using "reads"
23:51:05 <kmc> :t reads
23:51:07 <lambdabot> forall a. (Read a) => String -> [(a, String)]
23:51:10 <kmc> > reads "0" :: Int
23:51:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:51:11 <lambdabot>         against inferred type ...
23:51:15 <kmc> > reads "0" :: [(Int, String)]
23:51:16 <lambdabot>   [(0,"")]
23:51:17 <kmc> > reads "" :: [(Int, String)]
23:51:18 <lambdabot>   []
23:51:19 <kmc> > reads "bleh" :: [(Int, String)]
23:51:20 <lambdabot>   []
23:51:25 <manjunaths> I've was asked not to work on haskell at work :-(
23:51:31 <kmc> HugoDaniel, "reads" returns a list of parses
23:51:40 <manjunaths> that didn't go well
23:52:07 <kmc> > let f xs | ((p,_):_) <- reads xs = p; f _ = 0 in [f "", f "bleh", f "123"] :: [Int]
23:52:08 <lambdabot>   [0,0,123]
23:52:14 <kmc> HugoDaniel, ^^^ using pattern guards
23:52:17 <kmc> hard to read without layout
23:53:11 <kmc> :t (fst <$>) . reads
23:53:12 <lambdabot> forall a. (Read a) => String -> [a]
23:53:29 <kmc> :t head . (++ [0]) . (fst <$>) . reads
23:53:30 <bastl> ehm, since yesterday i cant access latest ghc docs ?
23:53:31 <lambdabot> forall a. (Num a, Read a) => String -> a
23:53:42 <kmc> bastl, http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/
23:53:56 <kmc> let f = head . (++ [0]) . (fst <$>) . reads in [f "", f "bleh", f "123"]
23:54:03 <kmc> > let f = head . (++ [0]) . (fst <$>) . reads in [f "", f "bleh", f "123"]
23:54:04 <lambdabot>   [0,0,123]
23:54:07 <kmc> HugoDaniel, ^^^ bit of a hack tho
23:54:08 <bastl> kmc: why that? all hoogle links are invalid ...
23:54:18 <kmc> bastl, new ghc => filenames change
23:54:21 <kmc> even though they shouldn't
23:54:26 <kmc> and a lot of stuff moved out of ghc to other packages
23:54:33 <kmc> awaiting inclusion into Platform
23:56:24 <kmc> > let f = head . (++ [0]) . (map fst) . reads in map f $ words "bleh 123 foo 4568"
23:56:26 <lambdabot>   [0,123,0,4568]
23:58:16 <HugoDaniel> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5377#a5377
23:58:22 <HugoDaniel> kmc, thanks :)
23:58:56 <HugoDaniel> btw, do you know how can i escape the $ character on the templates of hstringtemplate ?
23:59:20 <Kim^Walkman> > let f xs = fromMaybe 0 (listToMaybe . fmap fst $ reads xs) in [f "", f "bleh", f "123"]
23:59:22 <lambdabot>   [0,0,123]
