00:00:03 <kmc> mtnviewmark, iirc you can't use a synonym partially applied in an instance head
00:00:21 <mtnviewmark> oy - that's sort of oddly arbitrary
00:00:28 <mtnviewmark> it *is* of kind * -> *
00:01:20 <kmc> GHC manual 7.6.3.1
00:01:33 <mtnviewmark> but, sigh, if I make it a newtype or a data --- then, fie, I have to "wrap" each stage of the function application
00:01:51 <kmc> then just write out the type
00:02:44 <mtnviewmark> where? in the instance declaration?
00:02:58 * kmc ponders
00:03:09 <mtnviewmark> here's the idea
00:03:44 <mtnviewmark> (,) /~/ some_word16 :: (Word8, Word)
00:03:46 <mtnviewmark> and
00:04:03 <mtnviewmark> (,) /~/ some_word8 /~/ some_word8 :: (Word8, Word8)
00:04:12 <kmc> synonyms are not first-class members of the type universe
00:04:31 <kmc> how about an associated type synonym
00:04:31 <mtnviewmark> ohoh - you mean expand the function type
00:04:36 <mtnviewmark> got it -- trying....
00:04:44 <kmc> yes, but it won't work, because you want to apply the synonym
00:04:56 <mtnviewmark> (doesn't know about synonms)
00:05:02 <mtnviewmark> er associated syn.
00:05:24 <kmc> instance ByteArgs Word8 ((->) Word8) where
00:05:27 <kmc> that does work
00:05:29 <kmc> the syntax is ugly
00:05:51 <kmc> the next one fails due to lack of a type compose operator, i think
00:06:03 <kmc> lemme try to rework it with associated synonyms
00:06:30 <mtnviewmark> ah, but won't work for 2 args?
00:06:37 <kmc> i think not
00:06:59 <mtnviewmark> ((->) (Word8 -> Word8))
00:07:01 <mtnviewmark> that worked
00:07:07 <kmc> wrong type though
00:07:10 <kmc> (Word8 -> Word8) -> g
00:07:49 <mtnviewmark> hmmm wonder's why the instance worked then....
00:07:56 <kmc> maybe i'm wrong
00:08:05 <HaskellLove> how to get the number that occurs the most times in a list?
00:08:25 <mtnviewmark> ha ha - no
00:08:46 <mtnviewmark> once I fixed the 4 arg version, a later level of compilation complained about the two arg version!
00:08:55 <mmorrow> HaskellLove: count them then extract the most frequently occurring elem
00:09:15 <HaskellLove> what do you mean?
00:09:22 <c_wraith> HaskellLove:  sorting them might make it easier to count them.
00:10:09 <HaskellLove> oh i thought there is a function in haskell for that... shit i will have to write mine
00:11:02 <HaskellLove> maybe the platform has some library?
00:12:10 <c_wraith> :t group
00:12:11 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
00:12:27 <mmorrow> @let collect (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
00:12:29 <lambdabot>  Defined.
00:13:07 <mmorrow> @let histo = collect (+) id (const 1)
00:13:08 <lambdabot>  Defined.
00:13:17 <c_wraith> :t maximum `on` fst . map (length &&& head) . group . sort
00:13:18 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> c
00:13:18 <lambdabot>     Probable cause: `maximum' is applied to too many arguments
00:13:18 <lambdabot>     In the first argument of `on', namely `maximum'
00:13:25 <mmorrow> > histo (take 100000 (randomRs ('a','c') (mkStdGen 9320997493)))
00:13:27 <lambdabot>   fromList [('a',33215),('b',33409),('c',33376)]
00:13:40 <mtnviewmark> kmc - where do I find out about "associated synonyms"? doesn't seem to be in section 7 of GHC manual
00:13:40 <c_wraith> :t map (length &&& head) . group . sort
00:13:42 <lambdabot> forall a. (Ord a) => [a] -> [(Int, a)]
00:13:50 <kmc> 7.7
00:14:05 <kmc> e.g. 7.7.2.1.1
00:14:09 <kmc> but i'm having trouble making it work
00:14:14 <kmc> doing something different instead
00:14:20 <mmorrow> @let fromEdges = collect S.uniont fst (S.singleton . snd)
00:14:21 <lambdabot>  <local>:4:20: Not in scope: `S.uniont'
00:14:25 <mmorrow> @let fromEdges = collect S.union fst (S.singleton . snd)
00:14:26 <lambdabot>  Defined.
00:14:32 <c_wraith> :t maximum `on` fst
00:14:33 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> c
00:14:33 <lambdabot>     Probable cause: `maximum' is applied to too many arguments
00:14:33 <lambdabot>     In the first argument of `on', namely `maximum'
00:14:39 <mmorrow> > fromEdges [(0,1),(1,[0,1])]
00:14:40 <lambdabot>   No instance for (GHC.Num.Num [t])
00:14:41 <lambdabot>    arising from the literal `1' at <inter...
00:14:49 <mmorrow> gah
00:14:50 <c_wraith> oh, oops.  yeah, that doesn't work.
00:14:52 <mtnviewmark> cool - thanks for your brain power!
00:14:58 <mmorrow> > fromEdges [(0,1),(1,2),(2,0)]
00:14:59 <lambdabot>   fromList [(0,fromList [1]),(1,fromList [2]),(2,fromList [0])]
00:15:16 <c_wraith> :t snd . maximum . map (length &&& head) . group . sort
00:15:18 <lambdabot> forall a. (Ord a) => [a] -> a
00:15:39 <mmorrow> collect is probably the most useful haskell function ever (imho)
00:15:52 <c_wraith> > snd . maximum . map (length &&& head) . group . sort $ [1, 2, 2, 3, 4, 8, 8, 3, 4, 2, 2, 9]
00:15:54 <lambdabot>   2
00:16:57 <c_wraith> That's probably a horrible implementation of that. :)
00:17:26 <HaskellLove> elemIndex (maximum $ map length $ group $ sort [1,4,5,3,5,3,4,4,4]) (map length $ group $ sort [1,4,5,3,5,3]
00:17:34 <HaskellLove> messed up but works
00:17:47 <c_wraith> why are there two lists in that?
00:18:12 <HaskellLove> c_wraith i wrote it now quickly let me simplify it just a sec...
00:18:19 <kmc> mtnviewmark, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15220#a15220
00:18:41 <kmc> mtnviewmark, that's a bit crazy
00:18:57 <HaskellLove> maxOccurence ls = elemIndex (maximum a) a where a = (map length $ group $ sort ls)
00:19:01 <medfly> > map (\(x:xs)->(x,(length (x:xs)))) . group $ [1,4,5,3,5,3]
00:19:03 <lambdabot>   [(1,1),(4,1),(5,1),(3,1),(5,1),(3,1)]
00:19:09 <kmc> it doesn't feel to me that this problem should require such fancy machinery.  but perhaps it does, given the API you want
00:19:14 <medfly> > map (\(x:xs)->(x,(length (x:xs)))) . group . sort $ [1,4,5,3,5,3]
00:19:16 <lambdabot>   [(1,1),(3,2),(4,1),(5,2)]
00:19:37 <medfly> I use less functions!
00:20:00 <HaskellLove> oops problems... let me fix it
00:20:21 <mtnviewmark> The aim I was after, by the way, was invoke a function that takes 16 Word8 args
00:20:21 <medfly> you want to know the index?
00:20:33 <kmc> mtnviewmark, you're going to need a lot of S for that ;)
00:20:41 <mtnviewmark> with a variety of mixed word types
00:20:46 <mtnviewmark> AND do it efficeintly
00:21:11 <mtnviewmark> I basically wanted it to collapse to just function application of the 16 arg function to the extracted bytes
00:21:21 <kmc> this will do that
00:21:33 <kmc> do you see how it works?
00:21:54 <mtnviewmark> not yet --
00:22:15 <mtnviewmark> how would I use this with the function (say)   \a b -> (a, b)
00:22:30 <mtnviewmark> er (,) :: Word8 -> Word8 -> (Word8, Word8)
00:22:34 <Pip> Anyone watched the M$ channel 9 Haskell tutorial ?
00:22:47 <medfly> I think people know of the channel 9 lectures
00:22:50 <kmc> mtnviewmark, (,) /~/ (2993 :: Word16)
00:23:00 <Pip> medfly, how do you think ?
00:23:03 <mtnviewmark> how is (,) a Proj n g?
00:23:15 <mtnviewmark> oh
00:23:15 <medfly> with my brain
00:23:19 <mtnviewmark> slowly getting it
00:23:25 <medfly> (people mentioned it before)
00:23:32 <mmorrow> > let maxIxs xs = let (x,n) = (maximumBy (compare `on` snd) . M.toList . histo) xs in (n, (fmap fst . filter ((==x).snd) . zip [0..]) xs) in maxIxs ((take 10 . randomRs ('a','c') . mkStdGen) 9274793)
00:23:33 <lambdabot>   (5,[1,2,4,7,9])
00:23:39 <Pip> medfly, : ) Is it good tutorial for beginners ?
00:23:42 <mmorrow> > ((take 10 . randomRs ('a','c') . mkStdGen) 9274793)
00:23:44 <lambdabot>   "baababbaca"
00:23:44 <medfly> I have no idea
00:23:50 <medfly> baababbaca!
00:23:52 <medfly> :)
00:23:54 <mmorrow> heh
00:24:24 <mmorrow> @remember mkStdGen_9274793 baababbaca
00:24:25 <lambdabot> I will remember.
00:24:38 <kmc> mtnviewmark, (Proj n g) is a synonym for the type of functions that take n Word8 args and return g
00:24:47 <kmc> where n is a type-level natural number defined using Z and S
00:25:02 <mtnviewmark> where (S n) is Peano numbers in the type system?!?!?!
00:25:06 <kmc> yup
00:25:27 <kmc> this is poor man's dependent types
00:25:34 <kmc> it's really not as nice as an actual dependently-typed language
00:25:47 <mtnviewmark> yowza --- but, upon reflection (no pun intended), I just that is exactly what I'm asking the type system to do: count arguments and do simple arithmetic (sum up the word sizes)
00:26:14 <kmc> well -- you still have to tell it, for each type, what the number of words is
00:26:30 <mtnviewmark> wait
00:26:33 <kmc> "instance ByteArgs Word16 (S (S Z))"
00:26:39 <mtnviewmark> instance ByteArgs Word8 (S Z) where
00:26:41 <kmc> (S (S Z)) is 2, the number of Word8 in a Word16
00:26:47 <mtnviewmark> isn't what I want is
00:26:48 <kmc> similarly there is one Word8 in a Word8
00:26:59 <mtnviewmark> instance ByteArgs Word8 (S n) where
00:26:59 <mtnviewmark> ?
00:27:08 <kmc> n isn't a bound type variable there
00:27:15 <kmc> a Word8 always has one Word8 in it
00:27:21 <kmc> "one" is (S Z)
00:27:24 <mtnviewmark> since I want to be able to apply a Word8 to any function that takes at least one Word8
00:27:33 <kmc> mtnviewmark, g can of course be a function type too
00:27:44 <mtnviewmark> AH
00:27:48 <kmc> that's irrelevant to all of this code
00:27:57 <mtnviewmark> which will be inferred by the type system due to later applications of /~/
00:28:00 <kmc> the magic of currying
00:28:01 <HaskellLove> > let maxOccurence ls = fromMaybe $ elemIndex (maximum a) a where a = (map length $ group $ sort ls)
00:28:02 <lambdabot>   not an expression: `let maxOccurence ls = fromMaybe $ elemIndex (maximum a)...
00:28:48 <HaskellLove> > maxOccurence [1,2,4,4,4,5] where maxOccurence ls = fromMaybe $ elemIndex (maximum a) a where a = (map length $ group $ sort l
00:28:50 <lambdabot>   <no location info>: parse error on input `where'
00:29:23 <mmorrow> mtnviewmark: you mean apply a ((Word8 -> o) -> o) to a (Word8 -> o)?
00:29:31 <mmorrow> @type ($ (42::Word8)) --?
00:29:32 <lambdabot> forall b. (Word8 -> b) -> b
00:29:51 <mmorrow> "<mtnviewmark> since I want to be able to apply a Word8 to any function that takes at least one Word8"
00:30:16 <mtnviewmark> no no --- if   f :: Word8 -> Word8 -> Foo ---- then f /~/ some_word8   should be   Word8 -> Foo
00:30:24 <kmc> yeah
00:30:26 <mmorrow> right
00:30:35 <mtnviewmark> but,   f /~/ some_word16   should be Foo
00:30:35 <kmc> here n is (S Z), g is (Word8 -> Foo)
00:30:45 <kmc> in that case n is (S (S Z)), g is Foo
00:30:49 <mtnviewmark> right
00:31:05 <mmorrow> what is "/~/" ?
00:31:15 <kmc> mmorrow, operator in the typeclass being defined
00:31:21 <HaskellLove> kmc what is wrong with my function: let maxOccurence ls = fromMaybe $ elemIndex (maximum a) a where a = (map length $ group $ sort ls)
00:31:27 <kmc> mmorrow, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15219#a15219 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15220#a15220
00:31:47 <HaskellLove> it loads fine but when used i get errors No instance for (Show (Maybe (Maybe Int) -> Maybe Int))
00:32:47 <mmorrow> heh, just found this while searching hpaste for something else http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2210
00:32:53 <mmorrow> "handay"
00:33:47 <mmorrow> [m@monire ~]$ echo -ne 'foo: .quad 0\njmpq *-15(%rip)\n' | asm2c3.sh
00:33:47 <mmorrow> [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x25,0xf1,0xff,0xff,0xff]
00:33:55 * mmorrow refocuses back on topic
00:34:06 <mtnviewmark> woot!  kmc - it works!
00:34:10 <mtnviewmark> here's a virtual beer!
00:34:16 <HaskellLove> can someone please help me how this gives errors: let maxOccurence ls = fromMaybe $ elemIndex (maximum a) a where a = (map length $ group $ sort ls)
00:34:17 <kmc> cheers :)
00:35:08 <Jonno_FTW> is there anyway I can make this faster? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15224#a15224
00:35:18 <Jonno_FTW> to do http://projecteuler.net/index.php?section=problems&id=104
00:36:39 <kmc> mtnviewmark, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15220#a15225 simpler maybe
00:36:52 <kmc> i can't figure out how to make the type family be an associated type of the typeclas
00:37:08 <kmc> this version avoids the type naturals at the cost of some more repetition
00:38:04 <mtnviewmark> that is pretty close to my original (at least in intent)
00:40:08 <HaskellLove> what a hell is going on ghc kills me, wtf it wants i convert fromMaybe and still get errros... please see previous post ^
00:40:48 <povman> HaskellLove: what error do you get?
00:41:04 <mtnviewmark> kmc - since I only need three of these (1, 2, and 4 args), the repetition is fine, and perhaps clearer
00:41:10 <povman> HaskellLove: note that maxOccurence :: (Ord a) => [a] -> Maybe (Maybe Int) -> Maybe Int
00:41:15 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15226#a15226
00:41:50 <povman> HaskellLove: what is this function meant to do?
00:42:03 <kmc> mtnviewmark, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15220#a15227 a third solution, note that 'g' has crept its way into the typeclass head
00:42:32 <mtnviewmark> yes
00:42:45 <mtnviewmark> well, it was in your first too
00:43:01 <kmc> in the first two it's in the type family but not the class
00:43:23 <lpsmith> heh,  I just cracked a problem I've been trying to crack all year
00:43:31 <HaskellLove> to get maximum ocurrence in a list, so far i get the index of that element but i cant go further. next step is to take all that and just do ls !! the index here, which is basically the whole function above
00:43:44 <kmc> the problem is that g is a parameter but not an index -- we want parametric type polymorphism over g, not ad-hoc polymorphism.  yet type synonym families don't let you mix the two very well
00:43:48 <lpsmith> it seems almost stupidly obvious now
00:43:49 <kmc> or else i have not discovered how
00:44:07 <kmc> lpsmith, congrats
00:44:19 <lpsmith> thanks
00:44:45 <povman> HaskellLove: is it meant to return the most common element, or number of occurrences of the most common element?
00:44:49 <HaskellLove> ok solved, I missed 1 for fromMaybe chesus i cant beleive it
00:46:21 <mtnviewmark> kmc: I'm confused - in your last example: class ByteArgs w
00:46:25 <mtnviewmark> g isn't in the class head
00:46:37 <kmc> mtnviewmark, in "associated type, with dummy class var"?
00:46:40 <kmc> "class ByteArgs w g where"
00:47:20 <mtnviewmark> that isn't what is in your "Simpler?" paste
00:47:28 <mtnviewmark> "class ByteArgs w where"
00:47:33 <kmc> that is the second of three pastes
00:47:43 <kmc> on that page
00:47:47 <kmc> the third one uses associated type synonyms
00:47:52 <kmc> asstypesyns
00:48:09 * kmc is pushing hard for the "asstype" name to gain traction
00:48:14 <mtnviewmark> ah - page wasn't refreshed on my screen!
00:48:17 <kmc> :)
00:48:17 <mtnviewmark> didn't see the third!
00:48:55 <kmc> anyway, like i said, that opens up the possibility that someone puts a more specific type in for "g" in an instance -- and then your (/~/) loses its nice regular polymorphic property
00:49:06 <mtnviewmark> is the feature of having an associated type part of type families --- or is it a different extension?
00:49:13 <kmc> the former iirc
00:50:11 <mtnviewmark> all in all I like your middle one best
00:50:28 <mtnviewmark> okay - it is late -must sleep in this timezone!
00:50:32 <kmc> the type families also allow you to special-case the Proj type based on the return type -- but you don't get to special-case the code for (/~/)
00:50:32 <mtnviewmark> laters and thanks again
00:50:33 <kmc> mtnviewmark, me too
00:50:39 <kmc> no problem, good luck with your project :)
00:50:40 <kmc> 'night
00:59:01 <lpsmith> preflex,  seen monochrom
00:59:01 <preflex>  monochrom was last seen on #haskell 4 hours, 27 minutes and 46 seconds ago, saying: Since there is no haskell, I'm going to just watch a movie.
01:00:07 <lpsmith> monochrom,  I has a haskell for u!  :-)
01:08:49 <HaskellLove> wow i finaly wrote a maxOcurrence function
01:08:50 <HaskellLove> let maxOccurence ls =  (group $ sort ls) !! (fromMaybe 1 $ elemIndex (maximum a) a) !! 0 where a = (map length $ group $ sort ls)
01:09:09 <HaskellLove> given a list it will give you the element which ocurs the most often
01:10:36 <povman> HaskellLove: if you had Data.Map you could do let mostCommon = fst . last . sortBy (comparing snd) . toList . foldl (\m x -> insertWith (+) x 1 m) empty :: String -> Char
01:10:56 <c_wraith> :t snd . maximum . map (length &&& head) . group . sort -- this also works
01:10:58 <lambdabot> forall a. (Ord a) => [a] -> a
01:11:30 <HaskellLove> c_wraith yeah but i do not know arrows so...
01:11:38 <povman> c_wraith: that's a bit eleganter :p
01:11:40 <c_wraith> what's to know about arrows?
01:13:21 <HaskellLove> wow it even works with lists of lists yeiii
01:13:27 <HaskellLove> maxOccurence [[1,2,3],[2,3],[1,2,3]]
01:14:07 <c_wraith> :t let withArgAsTypeOf :: (a -> b) -> a -> a ->b ; withArgAsTypeOf = const in (&&&) `withArgAsTypeOf` id
01:14:09 <lambdabot> forall c c'. (c -> c) -> (c -> c') -> c -> (c, c')
01:14:16 <kmc> the arrow combinators are really useful for the (->) arrow
01:14:21 <kmc> otherwise... not so much, in ordinary code
01:14:25 <c_wraith> Look.  No arrows in the type signature, anymore!
01:14:52 <HaskellLove> and euler 39 solved with my cool function yeeees
01:15:34 <povman> :t in
01:15:35 <lambdabot> parse error on input `in'
01:16:01 <c_wraith> povman: in is a keyword, part of the let .. in construct
01:16:10 <povman> c_wraith: didn't see the let :p
01:17:02 <c_wraith> it's silly how many semi-useful functions you can write that have "= const" as their body, and do all their work in the type signature.
01:18:24 <povman> @pl  maxOccurence ls =  (group $ sort ls) !! (fromMaybe 1 $ elemIndex (maximum a) a) !! 0 where a = (map length $ group $ sort ls)
01:18:24 <lambdabot> (line 1, column 94):
01:18:24 <lambdabot> unexpected "="
01:18:24 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
01:18:44 <povman> @pl \ls ->  (group $ sort ls) !! (fromMaybe 1 $ elemIndex (maximum a) a) !! 0 where a = (map length $ group $ sort ls)
01:18:44 <lambdabot> (line 1, column 83):
01:18:45 <lambdabot> unexpected "="
01:18:45 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
01:19:36 <povman> @pl \ls -> let a = (map length $ group $ sort ls) in (group $ sort ls) !! (fromMaybe 1 $ elemIndex (maximum a) a) !! 0
01:19:37 <lambdabot> ap (flip flip 0 . ((!!) .) . (. (fromMaybe 1 . (elemIndex =<< maximum))) . (!!) . group . sort) (map length . group . sort)
01:20:04 <povman> > ap (flip flip 0 . ((!!) .) . (. (fromMaybe 1 . (elemIndex =<< maximum))) . (!!) . group . sort) (map length . group . sort) "hello world!!!"
01:20:05 <lambdabot>   '!'
01:20:35 <Dashkal> :t (&&&)
01:20:37 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:21:12 <HaskellLove> 0.123456789101112131415161718192021... How to continue the fraction so i get 1000 digits to solve euler 40?
01:21:31 <c_wraith> :t (&&&) :: (a -> b) -> (a -> c) -> (b, c)
01:21:32 <lambdabot>     Couldn't match expected type `a -> b'
01:21:32 <lambdabot>            against inferred type `(b, b)'
01:21:32 <lambdabot>     In the expression: (&&&) :: (a -> b) -> (a -> c) -> (b, c)
01:21:43 <c_wraith> :t (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
01:21:45 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
01:22:01 <c_wraith> just pretend that's the only type signature for &&&, most of the time.
01:23:09 <merehap> HaskellLove: your brain?
01:23:21 <HaskellLove> 0.123456789101112131415161718192021... how to continue the decimal part? i need to get 1000 digits... should i manually divide or there is a haskell function?
01:23:37 <HaskellLove> merehap well yeah that is what i ask see ^
01:23:44 <lpsmith> HaskellLove:  don't use floating point,  the problem tells you how the digits proceed
01:23:57 <lpsmith> Don't treat as a number, really
01:24:11 <merehap> agreed
01:24:18 <HaskellLove> lpsmith so it is a repeating pattern?
01:24:29 <merehap> nope
01:24:33 <lpsmith> HaskellLove,  reread the problem statement :-)
01:25:16 <HaskellLove> so basically you just join more 123456789101112131415161718192021 untill i get length 1000
01:26:47 <lpsmith> well, length 1,000,000
01:27:32 <HaskellLove> ok that will be easy and i thought i will have to get the ratio and divide manually :D
01:27:45 <lpsmith> there is no need to divide
01:27:56 <lpsmith> I don't think so anyway
01:29:36 <lpsmith> You don't ever have to treat 0.12345678191112131415161718192021  as a real number,  or do arithmetic on it in any way
01:29:36 <lambdabot> lpsmith: You have 1 new message. '/msg lambdabot @messages' to read it.
01:34:38 <Jafet> , time (("0."++) $ take 999999 $ concat $ map show [1..])
01:34:40 <lunabot>  (0.0,"0.12345678910111213141516171819202122232425262728293031323334353637...
01:36:07 <lpsmith> , time (("0."++) $ concat $ map show [1..])
01:36:09 <lunabot>  (0.0,"0.12345678910111213141516171819202122232425262728293031323334353637...
01:36:14 <lpsmith> , time (("0."++) $ concatMap show [1..])
01:36:16 <lunabot>  (0.0,"0.12345678910111213141516171819202122232425262728293031323334353637...
01:36:26 <lpsmith> :-)
01:37:27 <lpsmith> However using that to solve the problem is asymptotically slow compared to my solution
01:37:34 <lpsmith> Not that it matters for the problem size given
01:37:48 <lpsmith> You only have to go out to the 1,000,000th digit
01:38:32 <lpsmith> But I could go out to the 1,000,000!  digit without hardly breaking a sweat
01:49:13 <SamB_XP_> lpsmith: surely it would take a bit to calculate 1,000,000!
01:51:42 <HaskellLove> indices = [x | y<-[0..6], let x = (10^y)-1]   result = [x | n <- indices, let x = (cycledList !! n)]     This is crazy indices gives me a list: [0,9,99,999,9999,99999,999999] and cycled list has 1000000 elements and i get the list result with just one element ... wtf?
01:51:53 <lpsmith> Well, I haven't tried it,  but it shouldn't be bad :-)   My algorithm is O(log n)
01:52:38 <HaskellLove> oh ok problem solved i miss show
01:53:50 <mux> anyone subscribed to cvs-ghc here?
02:04:14 <lpsmith> SamB_XP_:  ok,  testing my algorithm out,  it can calculate the answer for 10,000! in about 9 seconds
02:04:38 <lpsmith> I'd guess 1,000,000! should be in the half hour range
02:04:59 <lpsmith> so, yeah,  I was a bit hyperbolic :-)
02:05:58 <lpsmith> it doesn't break a sweat for 1000!
02:06:40 <HaskellLove> cycledList = show $ concat $ map show (take 30303 $ repeat 123456789101112131415161718192021) Why do i get '"'
02:06:41 * dblhelix wasted his entire evening trying to get yhc and catch running :(
02:06:42 <HaskellLove>  as first element?
02:06:43 <medfly> why is it 9 seconds
02:07:08 <HaskellLove> dblhelix join the daily frustrations club
02:07:30 <dblhelix> HaskellLove: you're its president?
02:07:42 <medfly> , time $ foldr (*) 1 [1..(10^6)]
02:07:45 <lunabot>  Stack space overflow: current size 8388608 bytes.
02:07:45 <lunabot>  Use `+RTS -Ksize' to increase it.
02:07:46 <HaskellLove> yeah i lost my hear and nails
02:07:54 <lpsmith> medfly:  what do you mean?    I can calculate the 10000! digit of the given number in 9 seconds,  not every digit...
02:08:02 <medfly> oh
02:08:07 <medfly> 10000!?
02:08:13 <lpsmith> oh yeah
02:08:18 <dblhelix> , time $ Data.List.foldl' (*) 1 [1..(10^6)]
02:08:21 <medfly> that's... a very strange thing to do.
02:08:22 <lunabot>  luna: out of memory (requested 1048576 bytes)
02:08:36 <lpsmith> but why not?  :-)
02:08:46 <HaskellLove> so anyone has any idea why i get '"' as first element?
02:09:07 <lpsmith> one too many shows?
02:09:38 <HaskellLove> i cant see the logic of that, so what if i have many shows...
02:10:03 <Lemmih> > show (show (show 10))
02:10:04 <lambdabot>   "\"\\\"10\\\"\""
02:10:15 <HaskellLove> what? !!! :O
02:10:26 <HaskellLove> why does that happen
02:10:29 <lpsmith> HaskellLove,  you still don't understand the problem you are trying to solve,  reread the dinstances
02:10:37 <lpsmith> > show 10
02:10:37 <lambdabot>   "10"
02:10:42 <lpsmith> > show (show 10)
02:10:43 <lambdabot>   "\"10\""
02:10:46 <HaskellLove> lpsmith oh yes i do
02:10:53 <lpsmith> > show "abcde"
02:10:54 <lambdabot>   "\"abcde\""
02:11:11 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15228#a15228 lpsmith>	
02:11:33 <lpsmith> HaskellLove,   no,  you aren't generating the irrational number correctly
02:11:40 <lpsmith> In fact,  the number you are generating is rational
02:11:41 <HaskellLove> i miss product for the list yeah but... i have problems with this now...
02:12:19 <lpsmith> err,  reread the problem statement,  not the dinstances,  whatever that is
02:12:23 <HaskellLove> i am generating what?
02:12:54 <HaskellLove> look, i repeat the sequence untill length 1000000 and then i take indices with 1,10,100 bla bla
02:13:23 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15229#a15229
02:13:28 <lpsmith> I see that
02:13:29 <lpsmith> http://projecteuler.net/index.php?section=problems&id=40
02:13:31 <HaskellLove> i added [1] and product
02:13:46 <lpsmith> The next two digits after the ones they show are "21",  not "12" like you use
02:14:10 <HaskellLove> how come
02:14:38 <lpsmith> err,  "22",  not "21"
02:14:57 <HaskellLove> what? well you told me just to repeat the given pattern
02:15:04 <lpsmith> 123456789101112131415161718192021
02:15:08 <lpsmith> no
02:15:11 <lpsmith> 12345678910111213141516171819202122
02:15:12 <lpsmith> 1234567891011121314151617181920212223
02:15:14 <lpsmith> 123456789101112131415161718192021222324
02:15:33 <HaskellLove> where did that come from
02:15:55 <lpsmith> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
02:16:54 <HaskellLove> haha i hate when they dont state the problem clearly :O thank you
02:17:14 <SamB_XP_> didn't they ?
02:17:42 * SamB_XP_ wonders how hard that one would be to solve on the casio ...
02:17:43 <HaskellLove> SamB_XP_ well yeah on first reading how can you see this?
02:17:51 <lpsmith> I thought the statement was clear,   Jafet clearly got it right
02:18:13 <SamB_XP_> maybe the figures could use work ...
02:18:18 <HaskellLove> they could have added, the pattern goes like ... not just blow it in your face
02:18:35 <lpsmith> Although a little further testing of my algorithm suggests I was much too hyperbolic,  it really gets bogged down at factorials larger than 10,000
02:18:51 <lpsmith> 20,000! takes well over a minute
02:18:57 <SamB_XP_> lpsmith: that's probably because the factorials keep getting a whole lot bigger ?
02:19:03 <lpsmith> I could probably make it go faster with a bit more thought
02:19:05 <HaskellLove> > take 1000000 [1..]
02:19:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:19:19 <lpsmith> HaskellLove,  you still don't get the problem statement
02:19:31 <HaskellLove> i do now give me a sec
02:19:50 <HaskellLove> > concat $ map show $ take 1000000 [1..]
02:19:51 <lambdabot>   "12345678910111213141516171819202122232425262728293031323334353637383940414...
02:19:52 <lpsmith> SamB_XP_:  well, my algorithm is O(log n) arithmetic operations
02:20:16 <SamB_XP_> lpsmith: where n is ?
02:20:16 <lpsmith> and O(log (n!)) ~ O (n * log n)
02:20:33 <SamB_XP_> oh, okay
02:20:55 <lpsmith> the problem probably is that each individual number gets to be quite large,  so each arithmetic operation gets to be pretty expensive
02:21:23 <SamB_XP_> ah
02:21:27 <SamB_XP_> yeah
02:21:36 <SamB_XP_> which ops ?
02:22:06 <HaskellLove> > [x | i<-indices, (concat $ map show $ take 1000000 [1..]) !! i] where indices = [x | y<-[0..6], let x = (10^y)-1]
02:22:07 <lambdabot>   <no location info>: parse error on input `where'
02:22:46 <HaskellLove> > let  indices = [x | y<-[0..6], let x = (10^y)-1]; a =  [x | i<-indices, (concat $ map show $ take 1000000 [1..]) !! i] ;
02:22:47 <lambdabot>   not an expression: `let  indices = [x | y<-[0..6], let x = (10^y)-1]; a =  ...
02:23:08 <lpsmith> SamB_XP_:  multiplication and subtraction
02:23:23 <HaskellLove> > indices = [x | y<-[0..6], let x = (10^y)-1]; a = [x | i<-indices, a = (concat $ map show $ take 1000000 [1..]) !! i] ;
02:23:25 <lambdabot>   <no location info>: parse error on input `='
02:23:38 <HaskellLove> > indices = [x | y<-[0..6], let x = (10^y)-1];
02:23:39 <lambdabot>   <no location info>: parse error on input `='
02:23:48 <povman> HaskellLove: take 1000000 [1..] == [1..1000000]
02:24:24 <HaskellLove> povman heh thanks :)
02:24:55 <lpsmith> HaskellLove,  actually,  due to lazy evaluation,  you don't need take 1000000 at all
02:25:02 <lpsmith> or the upper bound on the list
02:25:20 <lpsmith> The millionth digit has nothing to do with the millionth number in that list
02:26:02 <povman> isn't it like really easy
02:27:52 <HaskellLove> lets hope these are the numbers 1153721
02:28:28 <HaskellLove> > product $ map digitToInt $ show 1153721
02:28:29 <lambdabot>   210
02:28:54 <HaskellLove> eureeeeka problem solved
02:30:24 <Stalafin> so... i want to write a really simple script... now i dunno whether to hook myself into haskell or python... everything i wanna do is make an input file to another program; for that i just have to place the x, y, and z coordinates of some hundred atoms, making a sort of hexagonal lattice.... so, haskell or python...? (dunno about either, but i am don't know so much about functional programming)
02:31:04 <lpsmith> Stalafin:  either works,  but in this channel we have an obvious preference :-)
02:31:04 <kmc> Stalafin, what is your background?
02:31:23 <Stalafin> kmc: the usual suspects... fortran, c++ mainly
02:31:44 <kmc> Python is good for quick data hacks
02:31:45 <Stalafin> kmc: though i studied sml in an introductory cs course... (before i switched to physics)
02:31:51 <kmc> basically anything where your program is "obviously correct"
02:31:54 <lpsmith> You'll probably get done quicker with Python,  given your background,  but Haskell will be more fun
02:32:06 <lpsmith> Stalafin:   where did you go,  if I may ask?
02:32:12 <Stalafin> lpsmith: place in germany
02:32:17 <lpsmith> ahh
02:32:24 <Stalafin> lpsmith: profesor has a carnegie mellon background
02:32:35 <lpsmith> fun fun
02:32:49 <kmc> Stalafin, Python will let you do very sloppy things.  Haskell requires you to be more precise.  What you get in return is that, when a Haskell program compiles, it usually works right.
02:33:07 <kmc> for the smallest programs this isn't a big deal
02:33:10 <Stalafin> lpsmith: my physics profs want me to use fortran obviously... heck, he bought some sort of uber expensive compiler....
02:33:32 <Stalafin> kmc: any headstart tut for jumping right into things?
02:33:37 <kmc> with Haskell?
02:33:40 <Stalafin> ya
02:33:40 <lpsmith> if all you need to do is generate some text files,   Haskell is ideal
02:33:41 <kmc> you may enjoy Real World Haskell
02:33:42 <kmc> @where RWH
02:33:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:34:14 <Stalafin> cool
02:34:17 <Stalafin> tanks
02:34:18 <povman> HaskellLove: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15230#a15230 ?
02:34:47 <Dashkal> Guah... why did they have to use a bug for the cover?
02:35:04 <kmc> hehe
02:35:05 <lpsmith> povman,  nice!
02:35:05 <Stalafin> i found a haskell tutorial with colored drawings some time ago :D with elephants and stuff like that... was really cute
02:35:11 <kmc> Stalafin, that's LYAH
02:35:12 <kmc> @where LYAH
02:35:12 <lambdabot> http://www.learnyouahaskell.com/
02:35:25 <HaskellLove> povman mine http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15231#a15231
02:35:58 <Stalafin> kmc: extremely cute... the guy deserves a medal :)
02:36:17 <lpsmith> HaskellLove,  good!
02:37:04 <Stalafin> what are those chunks of code?
02:37:15 <kmc> Stalafin, Haskell is particularly good for manipulating complex structured data, e.g. programs, proofs.  most of the industrial uses are for implementing domain-specific languages
02:37:23 <kmc> it's also a great general-purpose language
02:37:32 <kmc> indeed a great imperative language, in addition to its functional aspects
02:37:34 <lpsmith> Stalafin:  solutions to Project Euler problem #40
02:37:45 <Stalafin> fun
02:38:22 <Stalafin> kmc: probably people in my department will look at me in funny ways, but i guess i am gonna get started with haskell for my scripts then :D
02:38:25 <Stalafin> haha
02:38:37 <kmc> Stalafin, i think it's a lot of fun to learn, and to use
02:38:42 <kmc> it will make you think in very different ways
02:38:58 <kmc> it may make you realize how terrible C++ is :)
02:39:02 <lpsmith> yay!  haskell programming for goodness!
02:39:07 <Stalafin> well, you know physics ppl.... they use fortran for the sake of simplicity
02:39:25 <ttmrichter> kmc: Programming in PDP-10 assembler will make you realize how terrible C++ is.
02:39:27 <kmc> and for compilers that have been under development for 40 years
02:39:33 <lpsmith> Fortran is actually a reasonably pretty language once you understand the implementation
02:39:49 <kmc> Fortran is much easier to optimize than C (on a compiler backend)
02:39:50 <lpsmith> or at least,  it's a much more attractive language
02:40:02 <Stalafin> lpsmith: after i spent a day to figure out how to get a matrix into a text file, i refuse to call it pretty....
02:40:05 <lpsmith> (once you understand the implementation)
02:40:08 <lpsmith> lol
02:40:09 <kmc> there are good distributed-parallel programming systems for Fortran as well
02:40:18 <Heffalump> I'm not particularly familiar with Python, but in comparison to Perl, Haskell loses out a bit for quick hacks because it lacks the really baked-in regex/text processing stuff, but it wins on bigger things where you want to work with some structure
02:40:49 <Heffalump> and it does have good regex/text handling libraries, it's just that having it as syntax is a bit more convenient
02:40:58 <kmc> Heffalump, i agree.  writing a real parser in Haskell is easier than writing a moderately complicated regex
02:41:13 <kmc> although Python has no special syntax for re and i find its re perfectly usable
02:41:14 <HaskellLove> wow what is the (read . (:[])) thing?
02:41:24 <Heffalump> (:[]) is just \x -> [x]
02:41:49 <kmc> the Haskell regexp libraries have a weird API, imo.  it's not very typical
02:42:13 <Jafet> In haskell you use parsec from a grammar that you just proved correct
02:42:22 <lpsmith> HaskellLove,  (.) is composition, so
02:42:41 <kmc> the main difference i see between Perl or Python and Haskell is that Haskell requires some effort for you to explain to the computer why your code is correct
02:42:47 <kmc> if your code is obviously correct this is just an annoyance
02:42:50 <HaskellLove> yeah but read and that wow.. i try to figure it out now
02:42:54 <kmc> very few programs over 100 lines are obviously correct
02:43:06 <lpsmith> (read . (:[]))  == (read . (\x -> x : []))  == (read . (\x -> [x])) == (\x -> read [x])
02:43:26 <Jafet> @unpl read . (:[])
02:43:26 <lambdabot> (\ d -> read (d : []))
02:44:20 <Jafet> kmc: in python the language assumes that you are correct. In perl the language tries its best to make you correct
02:44:29 <kmc> for its own bizarre definition of correct
02:44:44 <kmc> DWIM is a terrible, terrible principle for a programming language
02:44:45 <lpsmith> Stalafin:  one of the neatest aspects of haskell is that it's relatively easy to manipulate programs algebraically
02:44:54 <kmc> the language should not second-guess the programmer.  it simply makes code harder to reason about
02:45:07 <lpsmith> especially in comparison to C++ or Fortran
02:46:08 <kmc> Python fills a similar niche as Perl, but replaces all the baked-in magic with reasonably designed libraries
02:46:49 <kmc> anyway, those obviously correct 50-line run-once Python scripts have a way of becoming 2000 line scripts that run every day and are critical for the proper functioning of everything
02:47:48 <kmc> and by then it's too late to rewrite in a language with static guarantees, so you bolt on some unit tests and call it good
02:49:39 <kmc> lpsmith, do you mean manipulating Haskell programs in Haskell, or just programs in general?
02:50:47 <dibblego> what is the correct parsec combinator for implementing an optional token? e.g. parsing the character string [o]T
02:51:54 <xle> Hi all... Does anyone know what the function (-<) does in the HXT package?
02:52:10 <xle> I see it in an example piece of code, but can't find the doc for the operator
02:52:23 <xle> Here is the example link: http://www.haskell.org/haskellwiki/HXT/Practical/Weather1
02:53:05 <lpsmith> I mean,  manipulating Haskell programs by hand :-)
02:53:25 <lpsmith> If you really want to manipulate X programs in X,  the easiest choice,  by far,  is Scheme
02:54:38 <lpsmith> Although Template Haskell has made it a lot easier... though I haven't really done anything with TH,  just messed around with it once or twice
02:54:55 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=44 anyone knows the limit of this, i mean when should i stop generating pentagonal numbers?
02:55:19 <lpsmith> HaskellLove, that's part of the challenge of that problem
02:55:29 <lpsmith> You'll need to work out an upper bound on your own
02:56:00 <HaskellLove> i see
02:56:02 <kmc> lpsmith, ah :)
02:56:08 <kmc> yeah, equational reasoning is wonderful
02:56:17 <kmc> such a basic property and so rare in other languages
02:57:14 <kmc> dibblego, one of: option, optionMaybe, optional
02:57:28 <kmc> depending on whether you want to: specify a default, get a Maybe, or throw out the token, resp.
02:57:39 <dibblego> ah I was trying to use optional and losing the information
02:57:50 <dibblego> right thanks, wasn't looking very far!
02:58:31 <lpsmith> Although,  I will admit Project Euler did give me a fair bit of trouble
02:58:44 <lpsmith> My approach proved to be rather slow,  and I'm not sure why
02:58:49 <lpsmith> I mean, problem 44
02:59:10 <Teggy> xle, -< is specific to Haskell's Arrow class, not HXT per se
02:59:25 <xle> Teggy: ah ok.. what does it do exactly?
02:59:36 <lpsmith> @hoogle (-<)
02:59:37 <lambdabot> No results found
02:59:39 <lpsmith> hmm
02:59:45 <lpsmith> @hoogle -<
02:59:46 <lambdabot> No results found
02:59:48 <xle> i couldn't find any results on hayoo either
03:00:16 <Teggy> -< is Arrow application... see here: http://www.haskell.org/arrows/syntax.html
03:01:21 <xle> Teggy: so both proc and -< are syntactic sugar?
03:01:40 * Teggy nods
03:01:54 <dibblego> Parsec's GenParser has a Monad and Functor but not Applicative?
03:02:57 <Teggy> xle, introduced here: http://www.soi.city.ac.uk/~ross/papers/notation.pdf (Section 3)
03:03:54 <lpsmith> kmc:  it should be fairly easy to manipulate Factor programs in Factor,  but I'm not a good factor programmer (yet?)
03:04:37 <ivanm> dibblego: I thought Parsec did have Applicative instances :s
03:04:37 <xle> Teggy: thanks
03:05:20 <Teggy> I realize that this is lots of reading just to grok -<, proc but an appreciation of the foundations has never misguided anyone. ;-)
03:05:40 <dibblego> let k = undefined <*> char 'a' -- No instance for (Applicative (GenParser Char st))
03:07:11 <kmc> so are there any proposals for systematic ways to extend the concrete syntax of Haskell?
03:07:23 <Heffalump> haskell-src-exts is I think the closest.
03:07:26 <Heffalump> i.e. no
03:07:37 <kmc> can you hook into its parser to add new stuff?
03:07:39 <povman> :t digitToInt
03:07:40 <lambdabot> Char -> Int
03:07:49 <povman> > digitToInt '4'
03:07:50 <lambdabot>   4
03:07:53 <Heffalump> kmc: yep
03:08:04 <Heffalump> see e.g. the XML extensions done by Niklas
03:08:24 <povman> (:[]) The hamburger operator
03:08:45 <kmc> Heffalump, but that's done by modifying the library, right?
03:08:47 <Raevel> *mm*
03:08:52 <kmc> it's mentioned as a feature of haskell-src-exts itself
03:09:26 <kmc> quasiquotation is another way to extend the concrete syntax, sort of
03:10:17 <Heffalump> I think there's an extension mechanism, though I'm not particularly familiar with it.
03:12:12 <HaskellLove> you guys know a quick way to test if a number is pentagon?
03:13:02 <Nomad010> HaskellLove: you can solve a quadratic
03:14:04 <HaskellLove> for given n I might do: 2*n = 3*(x^2) - x and then i can put xs there untill n, so if a solution is found then it is pentagon
03:14:05 <Nomad010> y = x(3x - 1)/2
03:14:25 <HaskellLove> Nomad010 yeah it gets down to whay i say ^, agree?
03:14:34 <Nomad010> ya
03:14:55 <HaskellLove> 2*n = 3*(x^2) - 1 ... oops 1 instead of x, i put x above... ok here i go
03:27:26 <HaskellLove> Nomad010 why this does not work help me finish it... isPent n = [x | x <- [1..n], (2*n == 3*(x^2) - 1)]
03:28:49 <Nomad010> HaskellLove: i know very little haskell
03:29:30 <HaskellLove> i think the [1..n] part might be wrong, well from math point of view can you tell me where to i search for x
03:30:02 <HaskellLove> oh of course 2 times let me try it
03:30:39 <povman> this is like the most cheatingest way to do project euler
03:31:02 <HaskellLove> isPent n = [x | x <- [1..(n*2)], (2*n == 3*(x^2) - 1)]
03:31:20 <HaskellLove> hmm what is wrong ...i feel the eureka but ... soon...
03:32:19 <Raevel> is it possible for cabal to generate several executables for a project? i tried making two executable declarations, but then i can't name the second one Main.hs also :-)
03:34:15 <Accidus> Hmm... "[.. type-checked] properties must be easily definable so that programmers can predict which programs are legal. [..] one should not consider arbitrarily complex static properties, but only relatively simple ones." Luca Cardelli, "Typeful Programming" (1991,1993)
03:35:05 <merehap> Raevel: I'm not sure about cabal, but for ghc you can specify "-main-is [MODULE_NAME]" to build a module other than main
03:35:10 <merehap> Main*
03:36:38 <osfameron> EvanCarroll: replied to your comment, I may be misunderstanding though?
03:38:07 <Raevel> merehap: yeah there's a Main-is declaration for executable, but ghc then says there is no Main module and does not generate a binary and then cabal fails
03:38:35 <Raevel> but i'll just have one exec with flags instead, just as well in my case
03:40:23 <dibblego> @hoogle Either a b -> Maybe b
03:40:24 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
03:40:24 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
03:40:24 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
03:40:49 <merehap> Raevel: hm, I know I've had the following work: ghc --make -main-is Foo Foo.hs
03:41:20 <merehap> Raevel: I'm not sure what is up with your setup, though
03:42:52 <Raevel> oops. it was just scion messing with me
03:43:09 <merehap> ah :)
03:43:14 <Raevel> it complained that the module names were off since the filenames didn't match the module name
03:43:16 <HaskellLove> finaly a working isPent function: let isPent n = [x | x <- [1..(2*n)], (2*n == (3*x^2-x))]
03:44:28 <edro4838> I'm trying to download hasc2ps from darcs.haskell.org. I'm being asked for a password. Is there a generic password or do I need to register ??
03:44:54 <HaskellLove> even better: isPent n = [x | x <- [1..(2*n)], (2*n == (3*x^2-x))] /= []
03:45:33 <dum8d0g> Hi.. I am getting weird error on example from "Programming in Haskell: Graham Hutton" book..
03:45:38 <dum8d0g> error - Type error in explicitly typed binding
03:45:39 <copumpkin> preflex: seen ddarius
03:45:39 <preflex>  ddarius was last seen on #haskell 10 days, 15 hours, 8 minutes and 10 seconds ago, saying: Excel.
03:45:44 <dum8d0g> code - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15232#a15232
03:45:54 <dum8d0g> it is about functional parsers
03:46:04 <dum8d0g> does anybody have an idea please?
03:47:07 <dum8d0g> last function (the 'p') is wrong.. but dunno why
03:47:08 <HaskellLove> copumpkin how did you generated pentagons? pents = [n | x<-[1..100], let n = x * (3*x-1) `div` 2] this is slow
03:47:19 <copumpkin> > scanl1 (+) [1,4..]
03:47:20 <lambdabot>   [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,...
03:47:46 <copumpkin> @let figurate n = scanl1 (+) [1,(n-1)..]
03:47:47 <lambdabot>  Defined.
03:47:50 <copumpkin> > figurate 4
03:47:51 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
03:47:52 <Lemmih> dum8d0g: return' (x, y)?
03:47:55 <copumpkin> > figurate 5
03:47:56 <lambdabot>   [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,...
03:48:15 <HaskellLove> cool thanks
03:48:23 <Lemmih> dum8d0g: Your code is problematic for other reasons, though.
03:48:40 <dum8d0g> not my code.. it is example from book..
03:48:51 <dum8d0g> but I don't like it either..
03:49:00 <dum8d0g> anyway it should work..
03:49:21 <mmaruseacph2> dum8d0g, please, give me a paste, if you want
03:49:31 <dum8d0g> mmaruseacph2: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15232#a15232
03:49:49 <HaskellLove> copumpkin you have something faster? isPent n = [x | x <- [1..(2*n)], (2*n == (3*x^2-x))] /= []
03:50:32 <copumpkin> HaskellLove: http://snapplr.com/143a
03:51:29 <HaskellLove> copumpkin you have like reference of usefull stuff like this or you just google and research when needed?
03:51:38 <copumpkin> I look on wikipedia :)
03:51:41 <copumpkin> but yeah, just google
03:52:22 <HaskellLove> and how old were you again? you seem pretty good
03:52:35 <copumpkin> 25 :P
03:52:59 <HaskellLove> cool so i have time...
03:53:27 <ivanm> copumpkin: really?
03:53:34 * ivanm thought copumpkin was younger than that...
03:53:56 <copumpkin> I just act immature
03:53:59 <copumpkin> ;)
03:54:02 * osfameron has never understood Magic et al (but not playing them doesn't help tbh... I still have an idea they're a bit like Top Trumps?)
03:54:15 <osfameron> or comature?
03:54:17 <HaskellLove> anyways copumpkin so to what limit do i generate here for n?
03:54:47 <copumpkin> HaskellLove: no, the point is if you want to test a number to see if it's pentagonal, you run that expression and see if it's an integer
03:54:55 <ivanm> copumpkin: heh
03:55:02 <copumpkin> I'm definitely comature
03:55:07 <HaskellLove> aha
03:55:08 <copumpkin> ivanm: why? how old did you think I was? :P
03:55:30 <ivanm> bout 19 or osmething
03:55:34 <copumpkin> lol
03:55:51 <copumpkin> I'd be a pretty young grad student :)
03:56:01 <mmaruseacph2> dum8d0g, as I see you want to use a monad but you only define the functions
03:56:12 <mmaruseacph2> you should also define an instance
03:56:29 <dum8d0g> mmaruseacph2: yes, this is what compiler sometimes says..
03:56:41 <dum8d0g> but I am kind a novice here..
03:56:54 <ivanm> copumpkin: well, I didn't realise you were a grad student ;-)
03:57:02 <ivanm> I thought you were an undergrad
03:57:15 <copumpkin> ivanm thinks I'm young and dumb :(
03:57:29 <copumpkin> now he knows the truth -- that I'm only one of those
03:58:02 <mmaruseacph2> dum8d0g, have you read "Learn you a Haskel for great good" ?
03:58:22 <ivanm> preflex: seen kowey
03:58:23 <preflex>  kowey was last seen on #haskell 27 days, 18 hours, 54 minutes and 34 seconds ago, saying: but if I run it again, it completes; anybody experienced something like this?
03:58:24 <dibblego> what is the workaround to "No instance for (Applicative (GenParser Char st))" ?
03:58:38 <ivanm> copumpkin: heh
03:58:39 <copumpkin> dibblego: write a quick instance using the Monad?
03:58:49 <dibblego> copumpkin, that's plan Z
03:58:53 <copumpkin> :)
03:59:15 <dum8d0g> mmaruseacph2: nope
03:59:27 <xle> what is the fixity of infix function calls?
03:59:45 <mmaruseacph2> dum8d0g, try it
03:59:53 <HaskellLove> ivan shut up and get back to work :O
04:00:05 <mmaruseacph2> here: http://learnyouahaskell.com/starting-out
04:01:05 <mmaruseacph2> dum8d0g, then, you should read rhw
04:01:14 <Heffalump> xle: you can actually declare it with the infix declarations if you want
04:01:17 <ivanm> HaskellLove: first of all, I wasn't saying anything to do with you; secondly, what work?
04:01:18 <ivanm> @time
04:01:20 <lambdabot> Local time for ivanm is Wed Dec 30 22:00:55
04:01:24 <Heffalump> but by default the same as any other operator which I think is infixr 9
04:01:27 <mmaruseacph2> @whereis rhw
04:01:27 <lambdabot> Maybe you meant: where where+
04:01:35 <mmaruseacph2> @help
04:01:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:01:40 <mmaruseacph2> @list
04:01:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:02:11 <xle> Heffalump: Ah I see... so I need to check with the library doc to find out.
04:02:13 <mmaruseacph2> @help where
04:02:13 <lambdabot> where <key>. Return element associated with key
04:02:39 <mmaruseacph2> found it
04:02:44 <Heffalump> xle: I think it's quite rare to change it
04:02:54 <mmaruseacph2> dum8d0g, here it is, real world haskell: http://book.realworldhaskell.org/read/
04:02:55 <HaskellLove> isPent n = [x | x <- [1..(2*n)], (2*n == (3*x^2-x))] /= [] VS isPent n = (snd $ properFraction $ ((sqrt (24*n+1))+1)/6) == 0.0 Give me speed comparison copumpkin what do you think
04:03:02 <xle> Heffalump: OK thanks.. good to know.
04:03:52 <copumpkin> HaskellLove: the second one will be asymptotically faster. So the speed comparison depends on n, and the  second one will get relatively faster the bigger n is. Even for small n it should be faster though
04:04:04 <copumpkin> HaskellLove: ideally you'd use an integer square root function but there isn't one in the standard libraries
04:04:12 <HaskellLove> yeah for big numbers the difference will be huge
04:04:24 <copumpkin> HaskellLove: again, when you have a square root you want a fromIntegral on the n
04:04:48 <copumpkin> in fact, ideally you wouldn't use floating point at all
04:04:50 <HaskellLove> it works like this no need for fromIntegral
04:04:54 <copumpkin> but that's more complicated
04:05:04 <copumpkin> there should be a need for fromIntegral
04:05:09 <copumpkin> you'll lose precision on big numbers
04:05:42 <copumpkin> ivanm: how old are you?
04:05:45 <HaskellLove> what do you mean? I just test if n is pent that's all i dont need precision, i just check if fraction is different then 0 and whoala
04:06:03 <ivanm> copumpkin: 23
04:06:21 * copumpkin stands up straight and looks smug
04:06:23 <ivanm> copumpkin: if you want the exact date, I was born on the exact day of the world's worst nuclear disaster ;-)
04:06:27 <HaskellLove> copumpkin oh my god i ran it, it is f**** fast :D the previous one took ages
04:06:32 <copumpkin> ivanm: aha, I remember that
04:06:34 * ivanm times copumpkin to see how long it takes him to wiki _that_ one
04:06:44 <ivanm> :o
04:06:44 <copumpkin> ivanm: no need to wiki :)
04:06:54 <ivanm> you remember that date? you'd only have been about 2!
04:06:54 <ivanm> :p
04:07:07 <copumpkin> I don't remember the exact date, but I definitely remember the event :P
04:07:22 <ivanm> heh
04:07:43 <ivanm> *remember that day
04:07:45 <copumpkin> not the actual event, of course :)
04:07:46 <Heffalump> the earliest concrete event I can remember is from when I was 8
04:08:20 <copumpkin> but for a while parents didn't want me to spend much time outside
04:09:22 <ivanm> copumpkin: what part of the world would you have been calling home at that point in time?
04:09:29 <copumpkin> rome
04:09:33 <ivanm> *nod*
04:10:25 <ivanm> yeah, I've met a guy who moved from east poland to New York when he was young, and he was playing outside (in poland) when it happened; he's had respiratory problems since :s
04:11:10 <copumpkin> that sucks :/ probably no danger here, but they were definitely warning people that cloudishness was detected over most of europe
04:11:29 <ivanm> yeah
04:11:44 <ivanm> you still don't want to eat mushrooms, etc. in central Ukraine at least
04:12:11 * kmc was -2 years old that day
04:12:31 <copumpkin> oh kmc is younger than I thought he was
04:12:38 <kmc> heh how old do i seem
04:12:52 <copumpkin> I assumed you were around my age
04:13:12 <kmc> ah, i don't perceive much of a gap between 21 and 25.  maybe i will when i'm 25
04:13:16 <copumpkin> so you're HaskellLove's age :o
04:13:21 <copumpkin> kmc: I don't either, really
04:13:23 <kmc> shhh
04:13:40 <HaskellLove> yo i am 21... anyways you talk about hiroshima?
04:13:48 <copumpkin> HaskellLove: I'm not that old :P
04:13:58 <HaskellLove> hahaha
04:15:10 <HaskellLove> seriosly what bombing you guys talk about
04:15:13 <kmc> hiroshima was rebuilt by the '50s and is now a city of over a million people
04:15:26 <copumpkin> I've been there :)
04:15:29 <kmc> chernobyl is still an uninhabitable wasteland and will remain that way for.. centuries?
04:15:39 <ivanm> at least 400 years, more like 4000
04:15:59 <ivanm> kmc: so I'm two days older than you?
04:16:00 <ivanm> ;-)
04:16:07 <kmc> heh
04:16:17 <HaskellLove> chernobyl affected yugoslavia so i guess it caught my brain too
04:16:20 * kmc has not to his knowledge provided enough information to determine his exact birth date
04:16:31 <ivanm> HaskellLove: why, what part of yugoslavia are you from?
04:16:42 <ivanm> (and chernobyl affected all of europe, if not the entire northern hemisphere)
04:16:42 <copumpkin> kmc: can't we stalk you on google?
04:16:45 <kmc> probably
04:16:46 <HaskellLove> macedonia
04:16:50 <ivanm> kmc: sure you have!
04:16:51 <kmc> let's not ;P
04:16:58 <ivanm> HaskellLove: nope, I've got no rellies there
04:17:42 <HaskellLove> you guys see some optimizaton here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15233#a15233
04:18:33 <ivanm> HaskellLove: using !! is a bottleneck
04:18:41 <ivanm> a Map would probably be better than a list there
04:18:55 <ivanm> oh, and use better function and variable names
04:19:08 <HaskellLove> function d just does difference between two elements in list
04:19:10 <ivanm> compile with -Wall !
04:19:25 <ivanm> HaskellLove: yes, but !! is very expensive, especially for small lists
04:19:34 <ivanm> s/small/large/
04:19:41 <HaskellLove> sorry, -Wall ! what is that?
04:20:02 <ivanm> a compile time option that shows all warnings
04:20:04 <HaskellLove> ivanm i was told names are not problem for ghc
04:20:15 <mauke> names are a problem for programmers
04:20:18 <ivanm> HaskellLove: no, but they are a problem for those of us trying to interpret your mess!
04:20:29 <ivanm> mauke: yeah, now if only we could get rid of them...
04:20:30 <ivanm> ;-)
04:20:46 <lpsmith> I remember isolated events from the age of 3-ish,  I'm not exactly sure.
04:21:16 <lpsmith> I remember Chernobyl and the fall of the Berlin Wall pretty clearly
04:21:18 <HaskellLove> ghc --make -O2 -Wall ! "/home/user/Desktop/aha.hs" get error for that target `!' is not a module name or a source file
04:21:24 <kmc> i get the impression that the demographic here skews towards mid-20s and overwhelmingly male
04:21:26 <ivanm> I recall one event from about 3ish; I then recall what happened in other events when I was younger (mainly from people telling me what happened rather than being able to visualise it)
04:21:34 <lpsmith> And the Challenger explosion
04:21:46 <ivanm> HaskellLove: not the actual !
04:21:55 <ivanm> that was an exclamation mark used for emphasis in what I said!
04:21:56 <HaskellLove> ah
04:22:09 <HaskellLove> well done no warnings
04:22:14 <ivanm> kmc: well, high teens to late 20s,
04:22:15 <ivanm> but yes
04:22:33 <ivanm> HaskellLove: you sure? I would have thought there'd be a warning for the a value
04:22:37 <ivanm> remove the .hi and .o files
04:22:43 <HaskellLove> yep, nothing at all
04:22:44 <ivanm> HaskellLove: also, why use quotes on your filename?
04:22:48 <mauke> did it say "compilation is not required"?
04:23:12 <ivanm> come on, it's going to complain about name overriding or whatever its called
04:23:26 <mauke> shadowing
04:23:31 <ivanm> that's the one
04:23:33 <HaskellLove> wooooow lot of warnings just a sec
04:23:33 * hackagebot upload: xsd 0.1 - XML Schema data structures (TonyMorris)
04:23:36 <ivanm> you have a and b used in two different ways (one global, the other local for each)
04:23:40 <ivanm> HaskellLove: heh
04:23:47 <ivanm> then there's the "no type sig" warnings
04:24:27 <lpsmith> I find the name shadowing warnings to be overtly obnoxious
04:24:45 <ivanm> I don't
04:24:53 <ivanm> usually because I don't have them in the first place
04:24:56 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15234#a15234
04:25:00 <ivanm> (but yes, thinking up new names can be a PITA)
04:25:04 <kmc> i have not seen stats on the gender ratio in #haskell, and i'm impressed at how infrequently it comes up.  which of course i've ruined now.
04:25:13 <lpsmith> It annoys me that cabal-install turns them on,  and that the Haskell platform requires them not to happen
04:25:35 <lpsmith> Sometimes,  I find the most elegant thing to do is to intentionally shadow names
04:25:37 <ivanm> HaskellLove: add type signatures, and use something else other than a and b either in your definition of a or else in the top-level definition names
04:25:47 <ivanm> lpsmith: does cabal-install turn them on?
04:25:54 <lpsmith> yeah
04:25:57 <ivanm> AFAIK, it's because most packages have -Wall in their ghc-opts :s
04:25:58 <HaskellLove> ivanm these stuff slow ghc down?
04:26:14 <ivanm> HaskellLove: no, it just improves the code quality for the most part
04:26:24 <ivanm> (well, the defaulting to Integer can be bad if you want Int)
04:26:26 <lpsmith> I think cabal-install has them on,  even if you don't specify them, but I could be wrong...
04:26:31 <ivanm> kmc: heh
04:26:46 <HaskellLove> i would not worry about these, adding type signatures always, is boring
04:26:54 <mokus> lpsmith: I've never seen cabal-install turn on -Wall for any of my own packages
04:27:01 <lpsmith> hmm
04:27:05 <ivanm> HaskellLove: yes, but you should do it
04:27:24 <mokus> but there are a lot of packages that have it on and are suddenly very noisy with ghc 6.12
04:27:43 <ivanm> for three reasons: extra documentation of your function; haddock docs don't get built if there's no type sig; it helps to catch errors (both programming and speed related from the defaulting)
04:27:44 <Axman6> HaskellLove: it's important though. they provide the most important code documentation you'll ever write in haskell programs
04:27:45 <Heffalump> deliberate name shadowing is often a boon to code quality
04:27:53 <HaskellLove> i wont add type signatures always just not my character... but what was the a and b thing you said? should i not write such small names or what?
04:28:01 <ivanm> HaskellLove: most people here use "type driven programming": you write your type sig before you write your code
04:28:24 <HaskellLove> ivanm yes i know but i find it boring and it makes my code bigger
04:28:28 <Axman6> types are possibly one of _the_ most important things in haskell
04:28:28 <Paczesiowa> HaskellLove: inserting type sigs is easy, there is a shourtcut for that in emacs
04:28:36 <ivanm> HaskellLove: if you really love haskell... ;-)
04:28:45 <mokus> I find the RecursiveDo deprecation annoying, particularly because it means there's no way possible to warning-clean code that uses it - no version of ghc supports both mdo and do rec without complaining about one or rejecting the other
04:28:50 <Axman6> you can't be a haskell lover if you hate writing types
04:28:57 <Axman6> it's just... unpossible!
04:28:57 <ivanm> Axman6: you can say that type signatures almost "type-ify" haskell ;-)
04:29:01 <ivanm> (poor pun, I know...)
04:29:03 <HaskellLove> ivanm if you really love somebody you dont have to prove that love haha
04:29:08 <Axman6> very poor :P
04:29:12 <ivanm> yeah
04:29:21 <Paczesiowa> there are two kinds of code, one - library really needs sigs. the other, client code doesn't.
04:29:37 <ivanm> Paczesiowa: but it's usually good to be in the habit of adding sigs anyway
04:29:39 <HaskellLove> ivanm yo buddy what was the a and b thing again? no short names or waht?
04:29:53 <ivanm> the only time I haven't seen people like dons, etc. add sigs to code is when they're golfing shootout entries
04:30:02 <Axman6> Paczesiowa: in haskell, it can often be difficult to be able to tell which is which
04:30:06 <ivanm> HaskellLove: you're basically using the same variable names to mean two different things
04:30:12 <HaskellLove> adding sigs always is kinda for old professor strict kinda people ...
04:30:19 <ivanm> 1) as top level identifiers, 2) inside the list comprehension for a =
04:30:26 <ivanm> HaskellLove: bull
04:30:27 <Axman6> HaskellLove: no, it's not
04:30:35 <Axman6> you're not understanding up
04:30:38 <mokus> HaskellLove: the kind of people who always add coments? ;)
04:31:03 <HaskellLove> i wish i was like those people, i am still young and impatient in writing sigs always :D
04:31:04 <Paczesiowa> client code - useful code should always only specify what it does and look nice. types should only be there in the background to prevent bugs
04:31:09 <Axman6> _lots_ of people write their programs by writing the type signatures, then writing the code to fit the= types
04:31:40 <Paczesiowa> Axman6: and that's the library code that you have to design.
04:32:08 <Paczesiowa> Axman6: then, when you have libraries with combinators, you just connect those functions to look good and make them do useful work.
04:32:22 <Axman6> HaskellLove: the only way to stop being that way is to just do it. you're older than i am remember
04:32:31 <Paczesiowa> second type of coding shouldn't need design or thinking.
04:33:06 <lpsmith> HaskellLove,   I think you should try writing sigs *before* you write functions.   That,  and you need practice with recursion,  not just treating Haskell like a glorified R or Mathematica.
04:33:29 <ivanm> Paczesiowa: I often think a lot when writing my apps; does that mean I'm doing it wrong?
04:33:39 <ivanm> lpsmith: agreed
04:33:46 <HaskellLove> lpsmith agree, i am so weak with recursion, i read lot of books and the cool godel escher bach stuff but it is different doing it...
04:33:53 <ivanm> i.e. he should do some tutorials rather than immediately doing project euler problems!
04:34:01 <lpsmith> lol
04:34:21 <ivanm> IMHO, Project Euler is one of the worst things for people learning Haskell (second only to LYAH :p)
04:34:23 <Jafet> You need to master recursion first, HaskellLove
04:34:28 <Jafet> Before you can do that.
04:34:32 <Axman6> HaskellLove: stop reading and start coding >_<
04:34:34 <ivanm> since they get focussed on quickly doing things rather than learning _how_ to do them
04:34:37 <Paczesiowa> ivanm: I don't like thinking.
04:34:41 <HaskellLove> Axman6 I am man
04:34:50 <mauke> ivanm: you can't learn how to do things without doing them
04:34:58 <ivanm> Paczesiowa: I noticed that with your patches for h-u :p (j/k)
04:35:15 <Axman6> h-u?
04:35:21 <Paczesiowa> j/k?
04:35:25 <ivanm> mauke: my point is, you should read through tutorials thoroughly rather than doing one chapter and thinking you know everything and immediately trying to write code
04:35:27 <HaskellLove> i dont know what you guys expect, so you read a book and whoala you know haskell? yeah right... man, i do euler i bang my head for a month every day and that is how i learn a language
04:35:32 <Paczesiowa> h-u = haskell-updater
04:35:48 <ivanm> "on the job training" doesn't really work well for learning programming languages
04:35:53 <ivanm> Paczesiowa: just kidding, and yes ;-)
04:36:00 <mauke> HaskellLove: you don't bang your head, you just ask here every time
04:36:01 <HaskellLove> ivanm correct but for euler i just need basic stuff, so i stopped in haskell books to chapters where they start with monads and stuff
04:36:12 <mauke> "halp, how do I solve problem X?"
04:36:13 <Axman6> HaskellLove: no, precicely the opposite. you write haskell, and then you write more, and then some more, and then you know some haskell
04:36:24 <HaskellLove> mauke yeah but trust me first i bang it for an hour
04:36:29 <mauke> HaskellLove: irrelevant
04:36:51 <ivanm> Axman6: I came back from overseas in September to find that kolmodin had applied a patch by Paczesiowa that ruined the logic in part of haskell-updater (my precious! :p) that made it harder to do the refactoring I was planning on
04:37:01 <ivanm> HaskellLove: *cough* yeah, right
04:37:04 <HaskellLove> Axman6 yeah man, just do it that is the whole secret... anyways i am on to next euler
04:37:21 <ivanm> HaskellLove: if you just want _a_ solution, no matter how bad or inefficient it is, then maybe that is sufficient
04:37:26 <Jonno_FTW> where are you up to?
04:37:29 <ivanm> but you're also wanting performance...
04:37:48 <Paczesiowa> ivanm: actually, the reason I lost interest in h-u was because it was very unhaskelly, everything was in IO. and IO requires thinking.
04:37:59 <HaskellLove> ivanm yeah but to get to the cake first you gota pass through some cold spageti, know what i mean?
04:38:06 <ivanm> Paczesiowa: everything had to be in IO unfortunately :(
04:38:20 <Paczesiowa> ivanm: of course not!
04:38:21 <ivanm> Paczesiowa: oh, and according to dons Haskell is not about minimising IO, it's about segregating IO ;-)
04:38:37 * Axman6 tries to do both
04:38:37 <ivanm> Paczesiowa: well, true, I could have used ghc-paths to get the ghc libdir purely; that's about it
04:38:44 <Astro> hi, I'm using forkIO and keep getting "thread blocked indefinitely"
04:38:47 <Astro> am being puzzled
04:38:50 <ivanm> everything else is reading files, getting results from programs, etc.
04:38:52 <HaskellLove> i mean, optimization worries me not so much as just solving the damn thing, cause i am not that good yet to worry about optimization
04:38:55 <Axman6> the less IO the better, and the less the work done by the code is in IO, the better still
04:38:58 <ivanm> HaskellLove: know, thankfully
04:39:12 <ivanm> HaskellLove: then why do you ask people to help improve your code because it's too slow?
04:39:17 <Jonno_FTW> HaskellLove, most optimisations in project euler are quite simple
04:39:20 <Paczesiowa> ivanm: dons is right, but he doesn't mean IO throughout the code. he means IO hidden in a monad stack.
04:39:21 <ivanm> Astro: paste? (to see what you're doing)
04:39:29 <Jonno_FTW> haskellikly speaking
04:39:34 <ivanm> Paczesiowa: not quite; see his judy bindings
04:39:39 * hackagebot upload: hmatrix 0.8.1.0 - Linear algebra and numerical computations (AlbertoRuiz)
04:39:43 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15235#a15235 ivanm how would you optimize this more? i thinkered it a lot and cant see a way
04:39:45 <Axman6> HaskellLove: you'd be a lot better if you sp0ent less time asking questions here, and more time reading other people's code, and blogs and everything, and most importantly, trying to figure out how to solve problems for your self.
04:39:46 <ivanm> Jonno_FTW: yes, but you have to know haskell first ;-)
04:39:53 <Paczesiowa> ivanm: bindings are bindings
04:40:04 <ivanm> Paczesiowa: but judy _lives_ in IO!
04:40:11 <Jonno_FTW> the major optimisations required by the questions are quite simple
04:40:19 <HaskellLove> Axman6 man i read books on haskell and stopped on the advance chapters, what more to read... i gota do it
04:40:27 <Astro> ivanm: writing to a file from multiple threads
04:40:29 <Axman6> stop reading books
04:40:44 <HaskellLove> Axman6 well you are paradoxic now...
04:40:45 <copumpkin> start writing code!
04:40:46 <Axman6> planet.haskell.org
04:41:00 <Paczesiowa> ivanm: and h-u really has the possibility to look like readDirStructure >>= return . analyze >>= print
04:41:03 <Axman6> no, i'm not. books are not people's code. read what i said
04:41:06 <HaskellLove> yo i am writing i got 37 eulers so far
04:41:09 <ivanm> lpsmith: I've just grepped the cabal-install source for "-Wall"; I found it in three places: its own cabal file, and two comments
04:41:30 <Jonno_FTW> wow, seems you are going at a rate faster than i did them
04:41:33 <HaskellLove> soon i will be level 2 ninja, now i am level1
04:41:33 <ivanm> Astro: do you assume that a handle is closed but you don't close it?
04:41:58 <ivanm> Paczesiowa: have you seen the new version?
04:42:00 <Axman6> HaskellLove: move on to something else. project euler is a good place to start. it is not something you should decide will make you a great programmer, because it will not!
04:42:01 <Jonno_FTW> i am up to 55
04:42:02 * ivanm is quite proud of it
04:42:03 <lpsmith> fair enough,  maybe it's just that I tested my own code with -Wall and saw a bunch of packages spit lots of warnings and somehow that morphed into cabal-install used -Wall
04:42:06 <HaskellLove> Jonno_FTW that is because i am ninja
04:42:13 <lpsmith> Actually,  I'm fairly sure that's it
04:42:16 <Jonno_FTW> i did one today in 2 hours
04:42:22 <ivanm> Paczesiowa: admittedly, I used some of your changes (but the way the patches were done I had to remove all of them and re-do them)
04:42:23 <Jonno_FTW> solution time
04:42:36 <ivanm> lpsmith: heh
04:42:55 <HaskellLove> Jonno_FTW well will you beleive me that i spent two hours this morning in type errors :( i wish i documented it all with sigs
04:42:57 <ivanm> Paczesiowa: main = uncurry runAction =<< parseArgs
04:43:07 <Jonno_FTW> wow
04:43:19 <Axman6> HaskellLove: solving all the problems on project euler will not make you a good programmer. it's like taking lots of IQ tests to get smart. you just get good at taking IQ tests, and you're no smarter
04:43:19 <Paczesiowa> ivanm: haven't seen anything since then
04:43:21 <lpsmith> What is haskell-update?
04:43:24 <Jonno_FTW> you'll eventually realise most of your type error problems
04:43:28 <Paczesiowa> ivanm: well, runAction still is IO
04:43:31 <ivanm> lpsmith: gentoo tool to keep packages up to date
04:43:37 <ivanm> Paczesiowa: right, it _has_ to be
04:43:39 <Astro> ivanm: quite the opposite, I assume it is still opened
04:43:39 <lpsmith> ahh, fun :-)
04:43:42 <ivanm> since an action is IO...
04:43:45 <ivanm> Astro: :s
04:43:50 <HaskellLove> Axman6 i am aware of that but still i will solve all eulers in haskell first, and then move to next project
04:43:54 <lpsmith> I hate Gentoo,  but that's ok :-)
04:43:55 <medfly> Axman6: I disagree. it can improve your programming ability to some degree, I think he does this to learn how to use Haskell.
04:44:01 <Astro> ivanm: maybe I just don't see where the thread that opened it may be crashing?
04:44:05 <ivanm> lpsmith: heh, do I dare ask why?
04:44:09 <ivanm> Astro: could be
04:44:09 <Jonno_FTW> gentoo is an average file manager
04:44:18 <ivanm> Jonno_FTW: not that gentoo ;-)
04:44:25 <ivanm> (I actually don't like gentoo-the-file-manager)
04:44:26 <Axman6> medfly: he will only see a very small part of what haskell actually is
04:44:28 <Jonno_FTW> :3
04:44:37 <ivanm> Axman6: agreed
04:44:43 <HaskellLove> Axman6 and dont underestimate euler if it is so easy sit down and solve it
04:44:44 <Paczesiowa> ivanm: I mean, it could read ghc dirs and other lib dirs, place them in a structure. and analyze them in a pure code, that can be tested
04:44:47 <ivanm> (not that I've ever actually done any project euler...)
04:44:53 <ivanm> Paczesiowa: ahhh
04:44:58 <lpsmith> More bugs and hassles than Ubuntu or Red Hat,   and the inevitable conclusion that I really don't want to re-compile everything myself
04:45:04 <ivanm> Paczesiowa: for efficiency purposes, we decided not to read them all in
04:45:07 <Axman6> HaskellLove: did i say it is easy? i've done a bit of it, i know it's hard. you really need to learn to listen
04:45:19 <lpsmith> Although I do realize that Gentoo moved to a more binary distro,  but I got out before then
04:45:20 <mauke> HaskellLove: euler isn't easy, it's irrelevant
04:45:31 <sunrayser> is there any way to convert from InterpreterT IO () to IO ()? I'm trying to use Control.Exception.catch but it needs an IO..
04:45:31 <HaskellLove> mauke hahaha whatever
04:45:35 <ivanm> Paczesiowa: I suppose if you did it right, then it'd work; but this way I've set it up so that it only reads as many files as it has to
04:45:43 <Jonno_FTW> it's true you know
04:45:49 <ivanm> and because of caching, the next time it needs to read files it would be more efficient
04:45:51 <ivanm> mauke: heh
04:45:59 <mokus> ivanm: unsafeInterleaveIO ;)
04:46:01 <ivanm> Axman6: s/listen/read/ ;-)
04:46:02 <Paczesiowa> ivanm: oh come on! what efficiency? reading 10 directories doesn't take that long
04:46:07 <ivanm> @slap mokus
04:46:07 <lambdabot> I'd rather not; mokus looks rather dangerous.
04:46:15 <Paczesiowa> sunrayser: oleg has some code for catching exceptions in monadIO
04:46:16 <ivanm> Paczesiowa: there's a hell of a lot of directories to search!
04:46:25 <ivanm> Paczesiowa: you have a directory per installed package!
04:46:37 <ivanm> (since not all haskell libs live in dev-haskell)
04:46:39 <Axman6> HaskellLove: mauke is right. you won't become a haskell master by completing evert problem. i can 100% quarantee you that
04:46:47 <Paczesiowa> ivanm: so? that's 10 directories:)
04:46:51 <sunrayser> Paczesiowa: where can I find that?
04:46:57 <HaskellLove> mauke i understimated these problems before trust me it is not irelevant... thanks god i realized that now
04:47:08 <ivanm> Paczesiowa: but that kind of a change is something I'll consider doing; having the action values store IO is not the kind of code I was wanting ;-)
04:47:11 <ivanm> Paczesiowa: heh
04:47:22 <ivanm> Paczesiowa: I think the system set is larger than 10 packages ;-)
04:47:24 <HaskellLove> Axman6 well yeah but take it easy, solving euler is one level above so, it is not like nothing...
04:47:40 <mauke> HaskellLove: good luck, but I think you'll never finish project euler
04:47:42 <ivanm> Axman6: and I can guarantee that a spell checker would improve the quality of what you type... ;-)
04:47:49 <lpsmith> Project Euler is useful for learning math,  not quite so much programming.
04:47:50 <Axman6> i agree with mauke
04:47:57 <Jafet> Axman6, but if you solve them in the type system
04:48:00 <HaskellLove> Axman6 it is not like you will become haskell master over night... take it easy take months solve euler, then go to other algorithms and so on
04:48:04 <Paczesiowa> sunrayser: http://hackage.haskell.org/package/MonadCatchIO-mtl
04:48:06 <lpsmith> Well,  it does give you practice in algorithm design
04:48:07 <HaskellLove> mauke well watch and learn son
04:48:08 <ivanm> I agree with whoever is disagreeing with HaskellLove atm ;-)
04:48:08 <Axman6> Jafet: then you're getting somewhere :P
04:48:27 <ivanm> HaskellLove: I somehow don't think you calling mauke "son" is appropriate...
04:48:48 <lpsmith> I will admit I've gotten much better at writing algorithms based on dynamic programming in a much more principled and less ad-hoc fashon
04:48:54 <Axman6> HaskellLove: why won't you listen to advice? it's incredibly infuriating. everyone here is trying to help you, and you WILL NOT LISTEN. why?!
04:48:55 <HaskellLove> ivan i agree, sorry, anyways what Jafet said...
04:49:02 <ivanm> HaskellLove: I learnt Haskell by reading through a haskell book and editing _real_ code
04:49:08 <kmc> uggggggh
04:49:13 <HaskellLove> Axman6 i am just sayng my opinion about euler
04:49:19 <sunrayser> Paczesiowa: looks good, thanks! Do you think it can catch an 'undefined'?
04:49:29 <Jafet> kmc, internet man wrong is!
04:49:35 <Paczesiowa> ivanm: it's just that not only using IO everywhere makes testing impossible (and this kind of app REALLY needs testing)
04:49:38 <Paczesiowa> sunrayser: yes
04:49:38 <ivanm> even then, I didn't really consider myself at least semi-proficient until about mid this year; that's after I had been using haskell for at least 2 years and had 3 packages on hackage I was responsible for
04:49:52 <ivanm> Paczesiowa: agreed; I just never thought about reading everything in like that
04:49:58 <sunrayser> Paczesiowa: ok, I'll check it out thx again
04:50:07 <ivanm> Paczesiowa: if you had done that kind of a change I probably would have agreed ;-)
04:50:20 <ivanm> and I'll definitely consider doing that kind of a change in my copious free time ;-)
04:50:20 <Paczesiowa> ivanm: it also looks bad! I fell in love with haskell because of purity!
04:50:40 <Axman6> HaskellLove: that doesn't answer my question. you don't listen to the advice of people who are much smarter and more experienced than you are. that to me sounds like the definition of a fool
04:50:44 <ivanm> (but I couldn't think of any non-IO way of doing it at the time, and the first version was kinda hacked together)
04:50:54 <Jafet> The next morning you get up and realize that *you've* broken the pureness
04:50:56 <HaskellLove> 2 years woow... so what did you do in those 2? I will learn haskell 200 % faster then you starting with euler and then going more complex like taking art of programming books
04:51:23 <Jafet> Knuth's books use MMIX assembly.
04:51:24 <mauke> HaskellLove: yes! you should read all of Knuth!
04:51:29 <Jafet> And flowcharts, but no one reads those
04:51:31 <lpsmith> HaskellLove,  have you read any of AOP?
04:51:32 <mauke> and do all exercises
04:51:36 <Paczesiowa> sunrayser: I mean, Marlow's design of Control.Exception allow you to eval even pure values (unsafePerformIO) to forece their exceptions, and undefined/error are catchable
04:51:39 <lpsmith> Like Jafet said...
04:51:40 <ivanm> HaskellLove: I used haskell for a summer maths project (which is still ongoing until it's worth writing a paper) and a lot of assignments
04:51:49 <HaskellLove> no AOP is my next project after euler, not now
04:51:57 <Axman6> urgh!
04:51:59 <ivanm> I even did my maths honours using Haskell and with a sample application using Haskell
04:52:10 <Jafet> Paczesiowa, that doesn't sound very, uh, sound
04:52:14 <Axman6> fuck, you'vbe done enough project euler! i'm going to email them and have you banned!
04:52:16 <ivanm> I am now going to be going to Madrid in January to present a paper on it, after pretty much rewriting the whole thing
04:52:38 <HaskellLove> Axman6 :) well what would you do now tell me
04:52:38 <lpsmith> what was it,  if I may ask?
04:52:45 <lpsmith> ivanm ^^^^
04:52:46 <ivanm> IIRC, it's recommended _not_ to read AOP but use it as a reference to look stuff up
04:52:51 <ivanm> lpsmith: which one?
04:52:56 <Axman6> something that's not at all related to project euler
04:52:58 <Paczesiowa> Jafet: I think it is, it returns the result of pure computatino in IO, but forces the result to catch exceptions
04:53:02 <lpsmith> your maths honours
04:53:04 <HaskellLove> Axman6 i mean you are right it wont take me further but i will get experience with haskell
04:53:08 <Axman6> write and IRC bot (DO NOT TEST IT HERE!)
04:53:13 <ivanm> HaskellLove: read through more tutorials
04:53:25 <Jonno_FTW> the real world needs your skills
04:53:27 <sunrayser> Paczesiowa: I can catch an undefined in a test environent, I just have to tell that thing to do that in the middle of an Interpreter monad (hint hackage)
04:53:31 <ivanm> then hack some _real_ code, probably starting off by getting a real project done by people who have some idea of what they're doing
04:53:32 <Jafet> Well, it's not very clean to rely on
04:53:38 <ivanm> _then_ consider writing your own code from scratch
04:53:39 <mauke> I recommend against writing an IRC client
04:53:43 <Jafet> I believe it can also handle stack overflows, though
04:53:45 <ivanm> @hackage SourceGraph
04:53:45 <lambdabot> http://hackage.haskell.org/package/SourceGraph
04:53:46 <ivanm> lpsmith: ^^
04:53:47 <lpsmith> Or,  ignore all the contradictory advice and stop wasting so much time on this channel!
04:53:51 <HaskellLove> i wanna join some haskell game project a guy here does that
04:53:55 <HaskellLove> maybe next month
04:53:59 <ivanm> lpsmith: heh, agreed
04:54:05 <Axman6> no, now, go and write an IRC bot
04:54:07 <Axman6> no!
04:54:10 <Axman6> now*
04:54:12 <ivanm> (at least next month is only two days away...)
04:54:15 <sunrayser> Paczesiowa: I have an expression returning InterpreterT IO (), I need to catch an undefined within it, returning InterpreterT IO () again
04:54:28 <HaskellLove> ivanm i meant after a month
04:54:39 <Paczesiowa> sunrayser: also http://okmij.org/ftp/Haskell/#catch-MonadIO
04:54:58 <ivanm> bah, I wanted to make a stab at fixing darcs bug 1720, except when I got into it I had no idea what they were doing there
04:55:08 <HaskellLove> can you guys see optimizations here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15236#a15236
04:55:11 <ivanm> it appears there comments are for a tex preprocessor and not for haddock :s
04:55:36 <ivanm> HaskellLove: yes, but if you actually want to write optimised code then you should do more tutorials and hack on real code
04:56:05 <ivanm> realistically, I only consider myself to have become truly competent with Haskell after matthew-_ dumped graphviz on me ;-)
04:56:07 <lpsmith> And really,  learning recursion is a must
04:56:15 <ivanm> (since I had to start worrying about code that _other people_ would use)
04:56:20 <ivanm> lpsmith: agreed!
04:56:23 <HaskellLove> ivanm graphviz?
04:56:25 <ivanm> to start with, learn recursion
04:56:27 <ivanm> @hackage graphviz
04:56:28 <lambdabot> http://hackage.haskell.org/package/graphviz
04:56:34 <kmc> to force exceptions from pure code, you'd use "evaluate", not "unsafePerformIO"
04:56:36 <kmc> :t evaluate
04:56:37 <lambdabot> Not in scope: `evaluate'
04:56:39 <kmc> well anyway
04:56:48 <ivanm> kmc: ummm, isn't that in IO?
04:56:50 <ivanm> @hoogle evaluate
04:56:50 <lambdabot> Control.Exception evaluate :: a -> IO a
04:56:51 <lambdabot> Control.OldException evaluate :: a -> IO a
04:56:51 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
04:56:51 <kmc> yes
04:57:06 <ivanm> so if you wanted it in pure code, youd' need unsafePerformIO...
04:57:09 <kmc> sorry, i thought that was the case under consideration
04:57:10 <ivanm> or, preferably, use deepseq
04:57:15 <kmc> you definitely cannot catch in pure code
04:57:18 <kmc> without hacks
04:57:35 <ivanm> kmc: I went from what you said: "to force exceptions from pure code ..."
04:57:42 <lpsmith> Writing your own list processing functions is a good way to start learning recursion...
04:57:50 <sunrayser> is there an equivalent of C.Exception.SomeException in CatchIO?
04:57:55 <lpsmith> Or implement Peano arithmetic
04:57:58 <ivanm> lpsmith: oh, serious answers? then yeah
04:58:12 <ivanm> sunrayser: is this extensible exceptions or OldException?
04:58:19 <HaskellLove> ivanm you use that while programming in haskell or what?
04:58:19 <ivanm> oh, wait, catchIO
04:58:21 <ivanm> dunno
04:58:24 <ivanm> HaskellLove: yup
04:58:28 <lpsmith> addition, subtraction,  exponentiation,  that's a start,  that shouldn't take more than an afternoon
04:58:35 <ivanm> (otherwise, there'd be no point in me writing it...)
04:58:45 <ivanm> lpsmith: maybe not exponentiation
04:58:50 <Paczesiowa> sunrayser: that hackage lib depends on extensible-exceptions
04:58:59 <HaskellLove> ivanm is it schematic functional programming thing? i read features but i dont get what it does
04:59:05 <ivanm> I mean, really: m ^ n = n m -- what kind of f'd up exponentiation definition is this? ;-)
04:59:17 <ivanm> HaskellLove: what do you mean?
04:59:19 <lpsmith> well,  you'd probably want to do multiplication before exponentiation,  :-D
04:59:23 <Paczesiowa> sunrayser: you have to instance MonadCatchIO for that Interpreter thing
04:59:26 <ivanm> it's haskell bindings (well, not really, but anyway) to Graphviz
04:59:34 <ivanm> if you don't know what Graphviz is, look it up on wikipedia
05:00:16 <lpsmith> ivanm:  that's the church encoding,  I was thinking   data Nat = Zero | Succ Nat
05:00:18 <sunrayser> Paczesiowa: ok what if it already has an instance? MonadCatchIO m => MonadCatchIO (InterpreterT m)
05:00:29 <ivanm> lpsmith: ahh, yeah
05:00:38 <sunrayser> Paczesiowa: m seems to be IO or IO () or what
05:00:52 <lpsmith> and isn't that multiplication,  not exponentiation?
05:01:09 <Paczesiowa> sunrayser: what's InterpreterT?
05:01:32 <HaskellLove> ivanm yeah i saw but how do you use it daily was my question? you visualize your programs with it?
05:01:47 <lpsmith> err,   maybe I'm wrong
05:01:50 <ivanm> lpsmith: maybe I've got it wrong... lemme pull out the paper
05:01:59 <sunrayser> Paczesiowa: it's a monad transformer, data InterpreterT m a, and has lots of instances
05:02:00 <ivanm> HaskellLove: I don't use it _daily_
05:02:07 <ivanm> but it gets used in Graphalyze and SouceGraph
05:02:19 <sunrayser> Paczesiowa: http://hackage.haskell.org/packages/archive/hint/0.3.2.1/doc/html/Language-Haskell-Interpreter.html#t%3AInterpreterT
05:02:34 <HaskellLove> well i thought you use it to visualize functions and stuff
05:02:45 <ivanm> lpsmith: from wikipedia:     exp  m.n. n m
05:02:48 <Paczesiowa> sunrayser: and you're using it like InterpreterT IO ?
05:02:50 <ivanm> HaskellLove: that's what SourceGraph does ;-)
05:03:12 <lpsmith> lol
05:03:14 <lpsmith> fair enough
05:03:26 <sunrayser> Paczesiowa: ye, there is a "type Interpreter = InterpreterT IO" which means the Interpreter () I'm using is actually InterpreterT IO ()
05:03:26 <ivanm> lpsmith: except you can't define that in haskell :(
05:03:33 <ivanm> since it needs rank-2 polymorphism :s
05:03:49 <Paczesiowa> sunrayser: if so, there shouldn't be any problems with catch from Control.Monad.CatchIO
05:04:01 <HaskellLove> http://code.haskell.org/~ivanm/Sample_SourceGraph/SourceGraph/SourceGraph.html#visualisation-of-the-entire-software wow this is amazing i gota learn this
05:04:29 <lpsmith> yeah,  use Scheme  :-)
05:04:51 <Paczesiowa> ivanm: what's wrong with rank-2 and haskell?
05:04:55 <lpsmith> Is there options other than rank-2 polymorphism?
05:05:01 <Paczesiowa> rankN
05:05:03 <ivanm> Paczesiowa: does Haskell have rank 2 polymorphism?
05:05:10 <lpsmith> yeah
05:05:14 <Paczesiowa> -XRank2Types
05:05:15 <lpsmith> well, ghc extensions
05:05:17 <ivanm> oh, maybe it was rank-N
05:05:19 <ivanm> :s
05:05:20 <HaskellLove> all of you pro Haskellers use SourceGraph?
05:05:24 <ivanm> @type \ m n -> n m
05:05:26 <lambdabot> forall t t1. t -> (t -> t1) -> t1
05:05:26 <Paczesiowa> ivanm: there are both
05:05:34 <ivanm> HaskellLove: heh, AFAIK hardly anyone uses it ;-)
05:05:58 <sunrayser> Paczesiowa: almost there, I just need to give some type to the exception: Ambiguous type variable `e' in the constraint: `Exception e'
05:05:59 <ivanm> because it's still pretty buggy
05:06:11 <mreh> how do I do List Monady things with randomly generated lists
05:06:23 <Paczesiowa> sunrayser: you want to catch undefined right?
05:06:32 <ivanm> but I'm working on it; the next release (within two weeks probably) won't bork if a visualisation can't be created like the current version does
05:06:32 <sunrayser> Paczesiowa: yes
05:06:45 <ivanm> mreh: what do you mean?
05:06:54 <ivanm> you generate your lists, then pass them in to your function ...
05:06:59 <sunrayser> Paczesiowa: well, I will try to keep the current catchError as well (if it's needed at all)
05:06:59 <HaskellLove> ivanm well i have read a book called schematic functional programming and it was frickin cool but as you said, these tools are buggy and still lie ahead in future, but i think in future programming will be rather drawing then writing... of course low level programmers to implement that will still be around
05:07:16 <ivanm> that will be _awful_
05:07:30 <Paczesiowa> sunrayser: http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/Control-Exception.html#t%3AErrorCall
05:07:32 <ivanm> first of all, there'd be all the people who think they know how to program but stuffing everything up...
05:07:36 <mreh> ivanm: like picking lots of balls out a bag and replacing them, trying to find three in a row that add up to x number
05:08:06 <ivanm> mreh: so you want logic-style stuff?
05:08:10 <ivanm> @hoogle guard
05:08:11 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
05:08:11 <lambdabot> Language.Haskell.TH data Guard
05:08:11 <lambdabot> Language.Haskell.TH.Syntax data Guard
05:08:12 <ivanm> mreh: ^^
05:08:26 <ivanm> mreh: basically, the list monad is an extension of list comprehension
05:08:31 <HaskellLove> ivanm have you seen a node based software, like a compositing one, how it is done with nodes? that is how functional programming should be like
05:08:38 <mreh> ivanm: that wont work with list monad, list monad doesn't work with infinite lists
05:08:44 <ivanm> no idea wtf you're talking about
05:08:53 <mreh> I'm thinking outloud
05:08:55 <ivanm> mreh: well, I don't know how you create your random lists ;-)
05:08:59 <patc> is there a ghc option for the garbage collector to see statistics on the type of object being gc'ed?
05:09:05 <dmhouse> > do a <- [1..]; guard (a >= 10); return (2*a) -- works fine
05:09:06 <lambdabot>   [20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68...
05:09:16 <ivanm> (that "no idea" comment was to HaskellLove0
05:09:20 <ivanm> *)
05:09:27 <sunrayser> Paczesiowa: well it's in Control.Exception... I could've go on with the SomeException as well, I tried to find something similar in CatchIO...
05:09:35 <ivanm> and why should functional programming be like _foo_ ?
05:09:44 <Paczesiowa> sunrayser: it uses the same Exception type as Control.Exception
05:09:57 <ivanm> (because if it should, then that implies that what we currently call "functional programming" isn't really functional programming)
05:10:20 <HaskellLove> ivanm you dont get it man... if you havent used compositing software then ...
05:11:08 <ivanm> HaskellLove: well, wikipedia has no idea what "compositing software" is
05:11:13 <HaskellLove> i mean, you will be, one day, be able to work with functions like with nodes in such software
05:11:22 <ivanm> and you're the one doing the prosetylising here (however you spell it)
05:11:23 <sunrayser> Paczesiowa: what is the difference between using SomeException or ErrorCall regarding what exceptions will be caught?
05:11:26 <HaskellLove> ivanm look for after effects,fusion and so on
05:11:29 <ivanm> HaskellLove: why should I want to?
05:11:29 <mreh> ivanm: I need a stochastic way to generate a list of numbers (within a range) that add up to a total, I can't use shuffled lists with list monad because I need the numbers to be independently sampled
05:11:36 <ivanm> mreh: the supply monad?
05:11:48 <ivanm> (i.e. basically use State or something)
05:11:51 <Paczesiowa> sunrayser: SomeException catches all exceptions, ErrorCall only error/undefined
05:12:04 <Paczesiowa> Control.Exception.catch (undefined :: IO Int) (\(ErrorCall s) -> return 2)
05:12:10 <mreh> ivanm: hmm
05:12:14 <ivanm> ummm.... "After effects" is to edit movies...
05:12:21 <ivanm> _not_ to write software
05:12:27 <ivanm> @wn compositing
05:12:29 <lambdabot> No match for "compositing".
05:12:31 <ivanm> bah
05:12:32 <Paczesiowa> Control.Exception.catch (undefined :: IO String) (\(ErrorCall s) -> return s) ---> "Prelude.undefined"
05:12:38 <medfly> @wn compositioning
05:12:39 <lambdabot> No match for "compositioning".
05:12:41 <medfly> :(
05:12:46 <ivanm> "Compositing is the combining of visual elements from separate sources into single images, often to create the illusion that all those elements are parts of the same scene." <-- nothing to do with programming there
05:13:12 <ivanm> and I've tried to use "visual programming" before, and think it should be burnt off the face of the earth
05:13:29 <HaskellLove> ivanm haha you have no idea do you... if you get a chance learn a visual compositing software like fusion where you work with nodes and DAG
05:13:47 <lpsmith> HaskellLove,  it's those kind of comments that are kind of obnoxious...   you have all these theories of what Haskell *should* be like,   yet you have trouble knocking out the easy Euler problems
05:13:49 <ivanm> why should I want to?
05:13:51 <mreh> HaskellLove: can you teach me graphical models?
05:13:52 <HaskellLove> ivanm that is the future you like it ot not
05:14:07 <ivanm> HaskellLove: you're meant to be convincing me; tell me _why_ rather than just "You should"
05:14:11 <ivanm> and who says its the future?
05:14:13 <zahlensalat> well.. i think in some specific domains it has gained some moderate success.. for example LabView.. but maybe you guys are talking about something different
05:14:18 <HaskellLove> lpsmith not my theories man, read the book schematic functional programming
05:14:28 * ivanm thinks that death and destruction is the future, but isn't planning on embracing it any time soon
05:14:42 <pastah_rhymez> ivanm: XD
05:14:49 <ivanm> zahlensalat: I have no idea what HaskellLove is talking about
05:15:19 <ivanm> oh, hell no... labview looks like that dodgy "GUI" language I had to use at uni when we programmed lego mindstorms
05:15:24 <HaskellLove> ivanm nevermind, basically it is visual programming, and you hate that so dont boder
05:15:29 <ivanm> I was quite relieved when we started using NQC
05:15:35 <sunrayser> Paczesiowa: wow it compiles now, thanks for all the help
05:15:50 <ivanm> visual programming might make sense for refactoring, but not for initial coding IMHO
05:15:56 <ivanm> (since where do the nodes _come from_?)
05:16:03 <Paczesiowa> sunrayser: it's based on dynamic typing, "it compiles" means nothing if you use dynamic typing
05:16:09 <HaskellLove> ivanm how about a huge library?
05:16:21 <ivanm> what about a huge library?
05:16:26 <lpsmith> When I started doing Euler problems,  I did about 50 problems in about 36 hours,  including breaks, eating, and sleeping.
05:16:28 <zahlensalat> well.. i just know that some guys at infineon are using it.. i however never used it
05:16:32 <HaskellLove> where you have anything you need...
05:16:42 <HaskellLove> and the low level guys will worry about the writing part
05:16:44 <lpsmith> I figured it was about 20 minutes average per problem
05:16:48 <medfly> lpsmith: you're making me feel uneasy:(
05:17:04 <lpsmith> Considerably less for some,  more for others
05:17:06 <ivanm> HaskellLove: "anythign you need": so all programs have already been written?
05:17:15 <lpsmith> medfly:  the more recent ones are a lot harder
05:17:22 <lpsmith> :)
05:17:38 <ivanm> HaskellLove: and that sounds suspiciously close to this: http://ars.userfriendly.org/cartoons/?id=20011121
05:17:53 <HaskellLove> ivanm most part will be visual you using already made stuff, but of course you will be able to add yours
05:17:55 * medfly comes up with a bunch of excuses.
05:17:58 <Jafet> ivanm, therefore, anything you do is reinventing the wheel!
05:18:01 <sunrayser> Paczesiowa: is Haskell really using dynamic typing? Or just in some cases?
05:18:05 <medfly> lpsmith: ok, I feel better about it. :)
05:18:10 <HaskellLove> what Jafet said
05:18:25 <pastah_rhymez> HaskellLove: you should get the new Xbox 360 toy and learn to do the imperative dance
05:18:25 <ivanm> Jafet: ummm, are you supporting HaskellLove or not?
05:18:40 <ivanm> because HaskellLove obviously thinks you are ;-)
05:19:04 <lpsmith> The problem with a huge library is finding your way around it
05:19:05 <Jafet> Do you?
05:19:14 <HaskellLove> i agreed with his commend "anything you do is reinventing the wheel!"
05:19:16 <ivanm> not really
05:19:37 <lpsmith> For certain small problems, that can be more difficult than simply starting from scratch
05:19:38 <pastah_rhymez> @faq can haskell reinvent the wheel?
05:19:39 <lambdabot> The answer is: Yes! Haskell can do that.
05:19:40 <ivanm> HaskellLove: so none of us should bother writing any software because it's already been written somewhere?
05:20:10 <HaskellLove> ivanm when you mix reading from AI and machine learning and what not, maan, you get sense of how much noise you have in your programming and how much should be automated and ready made for you to use
05:20:16 <ivanm> basically, IMHO a "visual programming language" means that you'll have people no idea wtf they're talking about will think they're "programming" and making big huge piles of stinking garbage
05:20:32 <ivanm> HaskellLove: you do realise how stupid you sound, don't you?
05:20:39 <HaskellLove> ivanm man i told you you can add your stuff to these already avalable
05:20:56 <HaskellLove> ivan i think you try to be smart of something you dont fully realize
05:20:59 <ivanm> (I think Asimov was _waaaay_ off tangent when he thought school students would learn programming)
05:21:12 <ivanm> (as in lower school students, and all of them)
05:21:22 <Paczesiowa> sunrayser: Control.Exception uses dynamic typing
05:21:41 <ivanm> HaskellLove: but I don't have to write them, because they're already there!
05:22:07 <Jafet> That depends on what you mean by "dynamic typing", sunrayser
05:22:07 <HaskellLove> ivanm ok nevermind ... have it your way bye i am onto a euler
05:22:36 <pozic> [offtopic]Can someone recommend me a good laser printer that lasts which doesn't have ridicously priced toners. I don't care for colour and it can be quite expensive, but it should be quality. [/offtopic]
05:22:36 <sunrayser> Jafet: that depends on what Paczesiowa means by "dynamic typing"
05:22:48 <lpsmith> medfly:  I know there are plenty of people that have much more impressive Project Euler exploits than I
05:22:56 <Jafet> Ugh, thunks.
05:23:05 <Paczesiowa> sunrayser: Exceptions are based on SomeException type that has a value of unknown/existential type inside, together with its type representation so it can be cast to correct value at runtime
05:23:09 <sunrayser> Jafet: last time I heard this thing was when reading some Erlang and reflection stuff
05:23:25 <lpsmith> Brian Huffman is amazing,  his solutions are usually shorter, faster,  and in before mine.   His knowledge of mathematics and algorithms is impressive.
05:23:41 <ivanm> pozic: I've got a fuji-xerox C502a and I've very happy with it
05:23:42 <pozic> lpsmith: how can you see his solutions?
05:23:49 <ivanm> except that I'm not sure if you can get them anymore... >_>
05:24:11 <patc> is there a ghc option for the garbage collector to see statistics on the type of object being gc'ed?
05:24:19 <lpsmith> If you solve a problem,  there is a forum dedicated to that one problem,  and Brian Huffman not infrequently posts his solution
05:24:25 <sunrayser> Paczesiowa: well so you may be able to tell me why it's called forall in "forall e . Exception e => SomeException e" and not "exists" to denote a real existential type (like in Clean)
05:24:38 <zahlensalat> pozic: i can suggest Kyocera laser printers. They have quite cheap toners
05:24:44 <lpsmith> However, they lock the forums at about 100 replies,  so most of the easy problems are locked
05:24:44 <Jafet> That's not what is usually meant by dynamic typing, Pac
05:24:45 <ivanm> patc: profiling?
05:24:53 <lpsmith> (or older problems)
05:24:57 <Jafet> That's simple polymorphism, if I'm reading correctly
05:25:03 <Paczesiowa> patc: you can profile your app and check for memalloc and relate function name to its type
05:25:06 <sunrayser> Paczesiowa: when I learned about type systems, forall and exists were different
05:25:15 <ivanm> pozic: of course, one of my main criteria was linux support...
05:25:26 <pozic> ivanm: http://www.google.com/products?q=C502a&aq=f doesn't really return anything useful
05:25:41 <Paczesiowa> sunrayser: its called forall because constructor SomeException has type: forall e. Exception e => e -> SomeException
05:25:51 <patc> I've been using the heap profiler and it tells me everything is a list ...
05:25:55 <ivanm> pozic: make that the c525a
05:25:58 <pozic> ivanm: I just want a network printer, not using a lot of power that I don't have to babysit.
05:25:59 <ivanm> stupid version numbers...
05:26:05 <ivanm> well, this is a network printer
05:26:10 <Paczesiowa> sunrayser: but it is "exists", they just didn't want to add new syntax
05:26:10 <ivanm> but its rather long in the tooth...
05:26:15 <pozic> Technology that needs babysittying (insert puge symbol).
05:26:22 <ivanm> pozic: I've heard good things of brother printers as well
05:26:30 <ivanm> and HP is meant to be good too IIRC
05:26:41 <pozic> ivanm: HP consumer level stuff is terrible.
05:26:47 <sunrayser> Paczesiowa: you mean forall is the syntax for the theoretical forall and exists construction as well?
05:27:06 <Paczesiowa> patc: I mean regular profile (standard all or something) it produces a file with memalloc costs for every toplevel function
05:27:08 <Paczesiowa> sunrayser: yes
05:27:15 <ivanm> pozic: this is australian-oriented, but might have something decent here: http://forums.whirlpool.net.au/forum/131?g=199
05:27:19 <Jafet> forall isn't standard syntax, anyhow
05:27:22 <pozic> I want to support "good companies", but then I first have to know what is good :)
05:27:23 <Paczesiowa> sunrayser: but those types are still called Existential
05:27:35 <pozic> I know what I don't want from costly experience.
05:28:08 <sunrayser> Paczesiowa: I'm just wondering why we used two constructions if they can be unified
05:28:22 * ivanm is keeping his eye more on the all-in-one inkjets atm rather than lasers
05:28:38 <Paczesiowa> ivanm: don't keep your eye on lasers!
05:28:45 <ivanm> Paczesiowa: heh
05:29:25 <Paczesiowa> sunrayser: I don't get it - it's the opposite - we use one construction for two things
05:29:49 <pozic> ivanm: all in one inkjet is a product you don't want to have.
05:30:23 <sunrayser> Paczesiowa: ah I see so it's just the same syntax for two opposite things ok
05:30:30 <ivanm> pozic: I want one more for printing photos and CD labels; I'll use uni for printing documents, etc. ;-)
05:30:36 <ivanm> (that's the plan, anyway)
05:31:06 <pozic> ivanm: professional photo services are cheaper.
05:31:08 <ivanm> I _could_ get a laser all-in-one, but they cost more, and then I have to go and pay someone to print photos for me (and get stick on CD labels :s)
05:31:16 * medfly thinks this is relevant
05:31:19 <medfly> http://cache.gizmodo.com/assets/resources/2006/11/BloodInk.jpg
05:31:24 <ivanm> pozic: really? I thought they were dearer...
05:31:32 <ivanm> medfly: heh, yeah, I've seen that
05:31:47 <Paczesiowa> sunrayser: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html 7.4.4.1. Why existential?
05:32:47 <patc> Paczesiowa: unfortunately most of the allocation is happening in some big functions which allocate losts of stuff.  I guess I will have to go through my program and add {-# SCC ... #-} to every line :(
05:33:03 <Paczesiowa> patc: have fun
05:33:35 <HaskellLove> anyone knows the search space for euler 44? i went to 100 000 and i get 48 as D, but it is not correct, will try milion now
05:35:08 <sunrayser> Paczesiowa: interesting but viable
05:36:44 <byorgey> anyone know in what module the  Ord a => Ord (Maybe a) instance is declared?
05:37:07 <ben0x539> Guessing Data.Maybe
05:37:22 <lpsmith> It's not part of the prelude?
05:37:47 <ben0x539> data  Maybe a  =  Nothing | Just a deriving (Eq, Ord)
05:38:03 <ivanm> byorgey: deriving Ord ?
05:38:38 <byorgey> ivanm: aha! well done
05:38:52 <byorgey> I was looking for an instance declaration and totally missed the deriving clause =)
05:38:59 <ivanm> though it's relatively easy to write yourself
05:39:32 <Paczesiowa> sunrayser: viable?
05:39:36 <ivanm> comparing (Just a) (Just b) = comparing a b; comparing Nothing Just{} = LT; comparing Just{} Nothing = GT, comparing Nothing Nothing = EQ
05:40:07 <byorgey> yeah, I just wanted to make sure it worked like I thought it should
05:40:15 <byorgey> sure enough, it does =)
05:40:17 <sunrayser> Paczesiowa: acceptable, it you want
05:40:20 <sunrayser> *if
05:40:35 <ben0x539> How do floating point NaN values compare?
05:40:47 <mauke> unequal
05:40:48 <byorgey> they don't
05:40:52 <Heffalump> stupidly
05:40:57 <ben0x539> LT or GT, then
05:40:57 <byorgey> > (0/0) == (0/0)
05:40:59 <lambdabot>   False
05:41:09 <byorgey> > (0/0) < (0/0)
05:41:10 <lambdabot>   False
05:41:12 <byorgey> > (0/0) > (0/0)
05:41:14 <lambdabot>   False
05:41:14 <ben0x539> > comparing (0/0) (0/0)
05:41:15 <lambdabot>   No instance for (GHC.Real.Fractional (b -> a))
05:41:15 <lambdabot>    arising from a use of `GH...
05:41:38 <byorgey> > compare (0/0) (0/0)
05:41:39 <lambdabot>   GT
05:41:50 <jlouis> wtf?
05:41:50 <byorgey> completely arbitrary, as you can see
05:41:52 <ben0x539> > (0/0)
05:41:53 <lambdabot>   NaN
05:42:14 <ivanm> Heffalump: isn't that required by the IEEE spec though?
05:42:26 <ivanm> since two different underflows could have achieved NaNs ...
05:42:51 <ben0x539> Ideally, comparing NaNs would result in NaN, no? :v
05:43:09 <patc> I don't think compare is part of the IEEE spec
05:43:11 <ray> it has to be LT or GT
05:43:15 <ivanm> ben0x539: except the type is wrong...
05:43:16 <lpsmith> ben0x539:  wouldn't that be NaB?
05:43:20 <ray> because it can't be EQ and those are the ones left
05:43:25 <Paczesiowa> lpsmith: rotfl!
05:43:36 <int-e> > (0/0) > (0/0)
05:43:37 <byorgey> data Bool = True | False | NaB
05:43:37 <lambdabot>   False
05:43:40 <ivanm> lpsmith: the National Australia Bank? :p
05:43:40 <ben0x539> ivanm: Hence ideally
05:43:44 <Paczesiowa> unsafeCoerce# NaN :: Bool
05:44:15 <mauke> data Bool = True | False | FileNotFound
05:44:49 <int-e> > False < True
05:44:50 <lambdabot>   True
05:44:54 <int-e> phew.
05:45:03 <ben0x539> Maybe we need a dynamic extensible bool type
05:45:15 <Paczesiowa> ben0x539: polymorphic variants
05:45:15 <ivanm> why?
05:45:19 <Ferdirand> is there a difference betvveen "Just _" and "Just{}" ?
05:45:25 <ray> floatCompare NaN NaN = Nothing
05:45:26 <int-e> Either Bool Somethingelse
05:45:42 <mauke> Ferdirand: no
05:45:43 <int-e> Ferdirand: semantically, no.
05:46:03 <ray> the second one is sure to confuse readers
05:46:25 <ben0x539> The second one saves you a ( )
05:46:30 <ben0x539> in pattern matching
05:46:32 <int-e> well ... to confuse more readers
05:46:38 <Heffalump> ivanm: that's the thing I'm saying is stupid
05:46:41 <Lemmih> I like the latter option best.
05:46:49 <patc> What would be more useful in practice is to implement traps per IEEE 754  Dounno what the sematics would look like in haskell tho
05:46:53 <Ferdirand> cute
05:46:53 <ray> confusing readers isn't necessarily bad
05:46:54 <Paczesiowa> :t \Just{} -> ()
05:46:55 <lambdabot> forall t. Maybe t -> ()
05:46:56 <ivanm> Ferdirand: the second cheats at using record syntax for a non-record type
05:47:00 <ben0x539> ivanm: So we can have NaN < NaN return something else than true or false
05:47:07 <Paczesiowa> that's great!
05:47:15 <ivanm> ben0x539: why should it?
05:47:18 <lpsmith> Honestly,  sometimes I think dynamic typing is better,  because you *can* use NaBs if you like
05:47:19 <Heffalump> nobody complains when loss of precision causes unequal computations to compare equal normally
05:47:25 <ray> all float comparisons must use Maybe Ordering
05:47:31 <Ferdirand> venivanm: yes, I figured :) first time i see it though
05:47:31 <ben0x539> ivanm: So the NaN-ness propagates
05:47:35 <ivanm> IMHO, Foo{} is nicer than (Foo _)
05:47:37 <int-e> Hmm what happened to the proposal of requiring parentheses for the record syntax?
05:48:02 <Ferdirand> and Foo{} is definitely nicer than (Foo _ _ _ _)
05:48:03 <ivanm> especially when you can have more than one value and are generating code that does stuff based on what the _constructor_ is rather than the values
05:48:07 <McManiaC> (Foo _ _ _ _ _ _ _ _)
05:48:07 <Heffalump> the problem with the comparison semantics for floats is it makes them unlike any other data, and it means they misbehave when embedded in other structures
05:48:07 <ivanm> Ferdirand: right
05:48:11 <lpsmith> I mean,  static typing is good and all,  but it imposes a lot of complexity in the language and implementation,   and sometimes it seems more trouble than it's really worth
05:48:16 <McManiaC> Ferdirand: hehe
05:48:27 <Paczesiowa> lpsmith: you don't need dynamic typing. you can have if p then True else NaB, as long as you pattern match on all the case later
05:48:31 <int-e> > Nothing{}
05:48:32 <lambdabot>   Nothing
05:49:12 <Paczesiowa> anyway, this syntax should just work: \Just x -> x
05:49:16 <Paczesiowa> :t \Just x -> x
05:49:18 <lambdabot>     Constructor `Just' should have 1 argument, but has been given 0
05:49:18 <lambdabot>     In the pattern: Just
05:49:18 <lambdabot>     In the expression: \ Just x -> x
05:49:44 <ben0x539> if ... then ... else ... andForNaNComparison ...
05:49:49 <int-e> nah, that would be confusing. explain the difference between \Nothing x -> x and \Just x -> x
05:50:04 <Heffalump> \(Just x) -> x
05:50:17 <Heffalump> oh, you mean that it shoul dbe able to figure out the fixities
05:50:26 <Paczesiowa> Heffalump: yes
05:50:29 <int-e> or consider the case of a custom constructor ... and then add a new field.
05:50:29 <Heffalump> that's fine if a casual reader would know them
05:50:31 <dmhouse> Yes, but it's hard for humans to do the same
05:50:37 <Heffalump> but otherwise, how do you parse \Foo x y z -> ...
05:50:38 <McManiaC> f Just x x  wont work too
05:50:59 <pastah_rhymez> McManiaC: you need these: ( )
05:51:01 <dmhouse> It's easy to remember for Maybe, but I don't want to have to look up arities of constructors every time I see a lambda
05:51:25 <int-e> f (Just x) x won't work either.  f (Just x) y | x == y   will work
05:51:46 <lpsmith> Paczesiowa:  you can handle that specific issue with polymorphic variants, but then you can create more;   typing is necessarily conservative.
05:51:46 <McManiaC> hu?
05:52:02 <lpsmith> Erlang would be difficult to do as a statically typed language,  for example
05:52:06 <int-e> > let f (Just x) x = x in f (Just 1) 1
05:52:07 <lambdabot>   Conflicting definitions for `x'
05:52:07 <lambdabot>  In the definition of `f'
05:52:09 <Paczesiowa> lpsmith: what issues?
05:52:23 <McManiaC> > let f x y = (fromMaybe 0 x) * y; x = 5 in f (Just x) x
05:52:24 <lambdabot>   25
05:52:25 <HaskellLove> I keep geting 48, not correct, anyone knows the solution to euler 44?
05:52:43 <int-e> heh
05:52:45 <Lemmih> HaskellLove: 42, I think.
05:52:55 <McManiaC> int-e: ah okay, thats obvious tho :P
05:52:56 <lpsmith> I prefer Scheme's numeric tower to Haskell's or SML's morass of numerics  (though I admit I should be more familiar with OCAML)
05:53:15 <int-e> > let f x y z = x (y + z) in f Just 1 2
05:53:16 <lambdabot>   Just 3
05:53:19 <burp> HaskellLove: http://www.haskell.org/haskellwiki/Euler_problems/41_to_50
05:53:26 <int-e> McManiaC: sorry, I thought the context was pattern matching
05:53:48 <lpsmith> I don't know exactly how to create something such as Kanren in a statically typed language with full expressivity.
05:53:58 <McManiaC> int-e: it was general notation, since x could also have been (a -> Maybe a)
05:54:04 <McManiaC> as stated in your code
05:54:37 <Jafet> lpsmith, Haskell's Num is much superior
05:54:42 <Jafet> Since it is extensible.
05:55:59 <McManiaC> what is Kanren?
05:56:55 <lpsmith> a logic programming language embedded in Scheme
05:57:29 <HaskellLove> Lemmih hmm where am i getting it wrong... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15239#a15239  burp>	Lemmih>	
05:57:37 <lpsmith> Jafet:  I wish Scheme had Tiny-CLOS standard,  or Factor's generic functions
05:57:52 <Jafet> Ew, clos
05:58:32 <dcoutts> Raevel: your main modules do not need to be called Main.hs
05:58:36 <Paczesiowa> lpsmith: what about LogicT?
05:58:40 <Lemmih> HaskellLove: Compare it with the solution on the wiki.
05:59:05 <lpsmith> I'm aware of LogicT,  but it's not really the same
05:59:07 <pastah_rhymez> HaskellLove: 'differenceBetweenTwoElementsInList' wut?
05:59:08 <lpsmith> It's related
05:59:23 <pastah_rhymez> HaskellLove: naming stuff like that reeks of java-ness
05:59:33 <pastah_rhymez> ObjectForListFactoryFactory()
05:59:36 <HaskellLove> <pastah_rhymez>	nothing special, given [9,4]  or [4,9] gives difference, 5
05:59:52 <Jonno_FTW__> wow, i didn't mean for you to abuse camel caps like that
05:59:54 <HaskellLove> do you understand the rest code, should i explain something?
05:59:59 <pastah_rhymez> \x y -> abs (x - y)
06:00:12 <HaskellLove> I did it now so you guys understand it, otherwise i use short names
06:00:36 <Jonno_FTW__> the code should explain the function, not the other way round
06:00:46 <kqrx> is there anyway to specify where GHCi should look for haskell files? ugly or non-ugly solution, both works :P
06:01:17 <Paczesiowa> kqrx: -idir/
06:01:22 <Jonno_FTW__> it will only use the current directory iirc
06:01:33 <HaskellLove> Jonno_FTW__  i cant figure out why it gives me 48 all day :(
06:01:47 <Jonno_FTW__> what gives 48?
06:02:06 <lpsmith> Paczesiowa:   IIRC,  LogicT doesn't deal with fresh variables or unification,  only backtracking
06:02:46 <HaskellLove> Jonno_FTW__ that code... and it is not the correct for euler 44
06:03:28 <kqrx> Paczesiowa: thanks
06:03:46 <Paczesiowa> lpsmith: I'm not really interested in logic programming, but you should read Oleg's stuff, he's really into functional+logic programming
06:03:59 <lpsmith> I do :-)
06:04:06 <lpsmith> Kanren *is* Oleg's baby
06:04:38 <Jonno_FTW__> can you post the link to your code again?
06:05:14 <Paczesiowa> lpsmith: oh
06:05:23 <paolino> hi, is STUArray faster than UArray in access operation?
06:06:00 <lpsmith> Logic programming not my primary interest at the moment,  but Kanren-like systems is something I've studied just enough to think it's a reasonable argument for dynamic typing
06:06:09 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15240#a15240 <Jonno_FTW__
06:06:16 <Lemmih> paolino: No, they're both O(1).
06:06:20 <int-e> paolino: for read access, it shouldn't be
06:06:51 <Paczesiowa> lpsmith: well that explains why I feel the same way about logic programming and dynamic typing:)
06:07:04 <lpsmith> heh
06:07:15 <lpsmith> There are statically typed logic programming systems
06:07:29 <Paczesiowa> they're still logic:)
06:07:38 <HaskellLove> i first test if the difference betweeen two pentagons is pentagon, and then i test for the sum...Jonno_FTW__> litle optimization... so after i test for sum and difference i just map (-) to the elements and get a list of differences and get the minimum of that
06:09:06 <paolino> it looks like java beats haskell in a sparse matrix multiplication ....
06:09:18 <lpsmith> HaskellLove:  I doubt your test is 100% accurate,  due to floating-point errors.    Assuming it's "mathematically" correct,  you would then have to determine the smallest integer for which it's incorrect
06:09:24 <lpsmith> (Which *will* happen)
06:09:54 <HaskellLove> lpsmith hmm, where in the code?
06:10:08 <lpsmith> :t sqrt
06:10:09 <lambdabot> forall a. (Floating a) => a -> a
06:10:23 <lpsmith>            ^^^^^^^^^^
06:10:29 <lpsmith> right there
06:11:19 <HaskellLove> ok i dont understand what you talk about... sqrt as a function gives wrong results or what? i should replace the code with?
06:11:55 <Raevel> dcoutts: yeah, thanks, turns out it was confusing error reporting in scion
06:12:00 <lpsmith> HaskellLove,  what kind (and how much) programming experience do you have outside of haskell?
06:12:22 <lpsmith> >  (0.1 + 0.2) + 0.3  == 0.1 + (0.2 + 0.3)
06:12:23 <lambdabot>   False
06:12:30 <HaskellLove> ouch
06:12:35 <Axman6> :o
06:12:39 <mauke>  >  (0.1 + 0.2) + 0.3  == 0.1 + (0.2 + 0.3 :: Rational)
06:12:45 <lpsmith> hahaha
06:12:47 <mauke> >  (0.1 + 0.2) + 0.3  == 0.1 + (0.2 + 0.3 :: Rational)
06:12:48 <lambdabot>   True
06:12:56 <lpsmith> nice :-)
06:13:16 <mauke> this is how I roll (or float?)
06:13:20 <HaskellLove> lpsmith i have experience with python, c, c++, java, litle prolog, played with owl, rtl, and sml and lots others...
06:13:30 <HaskellLove> lpsmith whis is this hapening :)
06:13:40 <mauke> and you've never seen floating point numbers before?
06:13:54 <HaskellLove> i have but dont understand this error :)
06:13:54 <koeien37> same behavior in those languages
06:14:06 <ben0x539> HaskellLove must be doing some sort of breadth-first search in programming languages
06:14:09 <lpsmith> >  (0.1 + 0.2) + 0.3
06:14:10 <lambdabot>   0.6000000000000001
06:14:12 <koeien37> Python gives False, too
06:14:18 <koeien37> >>> (0.1 + 0.2) + 0.3 == 0.1 + (0.2 + 0.3)
06:14:18 <koeien37> False
06:14:19 <lpsmith> >  0.1 + (0.2 + 0.3)
06:14:20 <lambdabot>   0.6
06:14:29 <mauke> ben0x539: he is, actually
06:14:30 <HaskellLove> can someone explain me why this happens?
06:14:50 <lpsmith> floating point arithmetic is inexact
06:14:50 <mauke> HaskellLove: http://docs.sun.com/source/806-3568/ncg_goldberg.html
06:14:53 <HaskellLove> and how to fix it
06:15:03 <patc> HaskellLove, think about floating point representations.  Oftentimes you'll be getting recurring decimals in umexpected places
06:15:40 <opqdonut> comparing floats for equality is Wrong
06:15:47 <paolino> HaskellLove: test <= epsilon
06:15:49 <opqdonut> you should always use an epsilon
06:15:50 <Axman6> > showCReal 100 (1/3)
06:15:50 <lpsmith> generally speaking,  yes
06:15:51 <opqdonut> yeah
06:15:51 <lambdabot>   "0.333333333333333333333333333333333333333333333333333333333333333333333333...
06:15:54 <Raevel> HaskellLove: you always need to measure the difference between floats, abs(a-b)<10^-10 for instance
06:16:11 <opqdonut> lpsmith: especially with stuff like NaN != NaN
06:16:26 <lpsmith> although even comparing floats with an epsilon can lead you astray...
06:16:36 <opqdonut> > sort [4,5,6,0/0,1,2,3]
06:16:37 <lambdabot>   [1.0,2.0,3.0,NaN,4.0,5.0,6.0]
06:16:43 <Axman6> > (0/0) == (0/0)
06:16:44 <Astro> I've got a runtime error somewhere, how can I trace?
06:16:45 <lambdabot>   False
06:16:51 <opqdonut> lpsmith: yeah, at some point the error will become larger than epsilon
06:16:56 <Paczesiowa> Astro: ghci debugger
06:17:05 <opqdonut> > sort [4,6,3,0/0,1,2,5]
06:17:06 <lambdabot>   [1.0,2.0,5.0,NaN,3.0,4.0,6.0]
06:17:09 <opqdonut> there!
06:17:10 <Astro> Paczesiowa: thx
06:17:18 <HaskellLove> lpsmith can you please fix my code please please
06:17:19 <Axman6> opqdonut: :O
06:17:26 <McManiaC> > sort [0,0/0,0]
06:17:27 <lambdabot>   [0.0,NaN,0.0]
06:17:29 <Teggy> ugh
06:17:30 * Axman6 's mind is being blown!
06:17:30 <opqdonut> Axman6: yepp, the Ord instance for floats is wrong
06:17:34 <paolino> Astro, also Debug.Trace.trace
06:17:59 <Paczesiowa> what about those stack traces from SPJ's paper? 6.14?
06:18:01 <patc> As for fixing - write *lots* of fp code - always think about what the underlying representation is - think about which bits of your number are "good" and which bits are "junk"
06:18:02 <ben0x539> HaskellLove: At this point, why not just look up the solutions?
06:18:20 <opqdonut> the judicious use of fixed point helps often
06:18:30 <HaskellLove> ben0x539 well i have the solution ready, i just need to deal with the float arithemtic stuff
06:18:41 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15240#a15240
06:18:42 <Axman6> patc: you'd have to ask in #ghc i think
06:18:59 <ben0x539> If it is not working, it hardly is a solution.
06:19:28 <HaskellLove> ben0x539 well basically that is the algorithm, i get 48 as answer but not correct, i am sure i am close
06:19:51 <mauke> HaskellLove: so why not just look up the solutions?
06:20:13 <HaskellLove> mauke well i would have to deal with same problem there too, and not understand their code
06:20:21 <ben0x539> You certainly are not going to learn anything from having someone write your code for you either.
06:20:24 * Axman6 learnt a hell of a lot more looking at other people's code than writing his own
06:20:30 <ben0x539> You know enough to do research into "how to use floating point numbers" by now
06:20:42 <mauke> HaskellLove: did you look at my link?
06:20:46 <HaskellLove> for example look at this one, how does he show how to handle this http://www.haskell.org/haskellwiki/Euler_problems/41_to_50
06:20:57 <HaskellLove> mauke i am not so advanced and need to know that
06:21:10 <lpsmith> > sort [0/0, 4,5,6,  1,2,3]
06:21:11 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,NaN]
06:21:14 <lpsmith> hehe
06:21:22 <lpsmith> > sort [4,5,6,  1,2,3, 0/0]
06:21:23 <lambdabot>   [NaN,1.0,2.0,3.0,4.0,5.0,6.0]
06:22:23 <burp> and you won't advance
06:22:27 <burp> if you look at this now
06:22:37 <burp> and continue to write project euler problems at your level
06:22:37 <Axman6> yes he will
06:22:45 <burp> if you don't
06:22:54 <Axman6> he'll learn how other people write haskell, which he is extremely much in need of doing right now
06:23:00 <burp> sure.. that's what I say -.-
06:23:10 <Axman6> ah, yeah, misinterpreted :)
06:23:14 <burp> if you see my missing "don't" ;)
06:23:28 <Axman6> heh
06:23:39 <HaskellLove> Axman6 is it that hard to just tell me how to fix a float arithmetitc error, what is all this playing smart guy...
06:23:47 <Axman6> yes
06:23:50 <Axman6> it is
06:24:01 <lpsmith> ben0x539:   I did a breadth-first search of programming languages once upon a time;  but I had a reasonable command of BASIC,  Pascal,  and C++ before that.
06:24:04 <Axman6> is it that ahrd to ask us questions about other people's code so you can understand it?
06:24:28 <lpsmith> And that breadth-first search lead me to SML and Haskell  :-)
06:25:00 <ben0x539> lpsmith: That sounds reasonable enough. Comparing programming languages is more fun if you can compare them to something you actually are familiar with ;)
06:25:10 <koeien37> why SML?
06:25:26 <Saizan> HaskellLove: you realize you're monopolizing an irc channel with a question that's best answered by doing your own research, and that you've been doing this for the past month?
06:26:02 <HaskellLove> Saizan well it is haskell related, i ask how do you guys deal with float errors in haskell
06:26:04 <ben0x539> If you truly love Haskell, then let it go
06:26:14 <Teggy> muahahaa
06:26:27 <Saizan> HaskellLove: not all haskell related questions are good questions.
06:26:42 <djahandarie> How do I use Haskell to take over the world?
06:27:02 <koeien37> unsafePerformIO
06:27:08 <ben0x539> unsafePerformCoup
06:27:08 <burp> djahandarie: wrong question
06:27:09 <burp> @faq can haskell be used to take over the world?
06:27:09 <tromp__> write a superintelligent AI in Haskell
06:27:10 <lambdabot> The answer is: Yes! Haskell can do that.
06:27:31 <djahandarie> \o/
06:27:33 <lpsmith> Well,  I liked Modula-3,  noticed that most Uni's that taught Modula-3 also taught SML,  which wasn't enough to really get my attention,  but then I happened to pick up a book on Programming with Standard ML by Chris Clacke et al.  at the library and was immediately hooked
06:29:36 <Twey> > sort [-1/0, -1, 0/0, 1, 1/0]
06:29:37 <lambdabot>   [-Infinity,-1.0,1.0,Infinity,NaN]
06:29:52 <Twey> o.@
06:29:59 <Twey> > sort [4,5,6,  1,2,3, 0/0]
06:30:00 <lambdabot>   [NaN,1.0,2.0,3.0,4.0,5.0,6.0]
06:30:07 <koeien37> > 0/0 < 5
06:30:07 <lambdabot>   False
06:30:11 <koeien37> > 5 < 0/0
06:30:12 <lambdabot>   False
06:30:13 <djahandarie> > sort [floor(-1/0), floor(1/0)]
06:30:14 <lambdabot>   [-1797693134862315907729305190789024733617976978942306572734300811577326758...
06:30:18 <Twey> Oh, yeah NaN magic
06:30:22 <opqdonut> indeed
06:30:28 <Twey> That makes for some pretty crazy sorting semantics
06:30:36 <opqdonut> indeed
06:30:45 <koeien37> the < for Double is not total
06:31:10 <djahandarie> I wonder
06:31:42 <Jafet> It's not even transitive
06:31:47 <int-e> > sort [1, 0/0, 2]
06:31:48 <lambdabot>   [2.0,NaN,1.0]
06:32:04 <mauke> fffff
06:32:11 <Jonno_FTW__> WHAT!?
06:32:15 <koeien37> yeah, that is worse
06:32:24 <Jonno_FTW__> infinity is more than 1 but less than 2?
06:32:32 <int-e> 0/0 is NaN
06:32:32 <koeien37> 0/0 is not Infinity
06:32:33 <byorgey> that's not infinity
06:32:35 <Jafet> > [floor (-1/0), floor (1/0)]
06:32:37 <lambdabot>   [-1797693134862315907729305190789024733617976978942306572734300811577326758...
06:32:45 <Jafet> Fun.
06:32:51 <byorgey> > sort [1, (1/0), 2]
06:32:52 <lambdabot>   [1.0,2.0,Infinity]
06:32:58 <int-e> > 2^1024 == floor (1/0)
06:32:59 <lambdabot>   True
06:33:29 <int-e> > 2^128 == floor (1/0 :: Float)
06:33:30 <lambdabot>   True
06:33:34 <en0th> > sort [1, (1/1)]
06:33:34 <lambdabot>   [1.0,1.0]
06:33:40 <djahandarie> int-e, interesting O.O
06:33:41 <en0th> seems to work
06:33:42 <lpsmith> Yeah,  Infinity won't cause trouble when sorting a list of floats :-D
06:33:44 <djahandarie> int-e, how'd you determine that?
06:33:59 <lpsmith> int-e's example is worth knowing though
06:34:06 <Axman6> > 1/0
06:34:07 <lambdabot>   Infinity
06:34:18 <lpsmith> wow
06:34:40 <djahandarie> > 2^1024 == ceil (1/0)
06:34:41 <lambdabot>   Not in scope: `ceil'
06:34:44 <djahandarie> Ah crap
06:34:56 <djahandarie> > 2^1024 == ceiling (1/0)
06:34:58 <lambdabot>   True
06:35:00 <djahandarie> Hm
06:35:11 * djahandarie doesn't understand
06:35:18 <int-e> > floor (0/0) > floor (1/0)
06:35:19 <lambdabot>   False
06:35:26 <int-e> > floor (0/0)
06:35:27 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
06:35:34 <int-e> > floor (0/0) < floor (-1/0)
06:35:35 <lambdabot>   True
06:35:46 <djahandarie> These numbers seem incredible arbitrary
06:36:17 <tromp__> GIGO
06:36:23 <lpsmith> hahaha
06:36:32 <ahf> hehe
06:36:36 <int-e> djahandarie: An educated guess based on the IEEE floating point format. If you interpret infinity as a normal IEEE floating point number, you'll get 1.0000... * 2^1024 (for doubles) and 1.0000... * 2^128 for floats.
06:36:45 <lpsmith> I've always wanted to use the phrase "which is much bigger than infinity" when teaching a math class
06:36:55 <lpsmith> (in reference to a very large number)
06:36:58 <Axman6> > let pegagonals = map (\n -> (n * (3 * n - 1) `div` 2) [1..] in pentagonals -- HaskellLove
06:36:59 <lambdabot>   <no location info>: parse error on input `in'
06:37:03 <lpsmith> (a very large finite number, that is)
06:37:14 <Axman6> > let pegagonals = map (\n -> (n * (3 * n - 1) `div` 2) [1..] in pentagonals -- HaskellLove
06:37:15 <lambdabot>   <no location info>: parse error on input `in'
06:37:20 <Axman6> > let pegagonals = map (\n -> (n * (3 * n - 1)) `div` 2) [1..] in pentagonals -- HaskellLove
06:37:21 <lambdabot>   Not in scope: `pentagonals'
06:37:28 <Axman6> > let pentagonals = map (\n -> (n * (3 * n - 1)) `div` 2) [1..] in pentagonals -- HaskellLove
06:37:29 <lambdabot>   [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,...
06:37:37 <Jafet> Infinity ain't as large as it used to be
06:37:39 <djahandarie> int-e, ah, hah. What about the 0/0 vs -1/0 ?
06:37:51 <koeien37> > log 0
06:37:53 <lambdabot>   -Infinity
06:37:53 <patc> > (\x k -> 1+ sum [ x ** (fromIntegral n) / fromIntegral(product [1..n])  | n <- [1..k]]) (-1000) 150
06:37:54 <lambdabot>   NaN
06:38:02 <int-e> > (floor (-1/0) - floor (0/0)) `divMod` 2^971
06:38:03 <lambdabot>   No instance for (GHC.Num.Num (b, b))
06:38:03 <lambdabot>    arising from a use of `GHC.Real.^' ...
06:38:20 <int-e> > (floor (-1/0) - floor (0/0)) `divMod` (2^971)
06:38:21 <lambdabot>   (4503599627370496,0)
06:39:09 <patc> > ((\x k -> 1+ sum [ x ** (fromIntegral n) / fromIntegral(product [1..n])  | n <- [1..k]]) (-1000) 150) == exp (-1000))
06:39:10 <lambdabot>   <no location info>: parse error on input `)'
06:39:10 <int-e> > 2^52
06:39:11 <lambdabot>   4503599627370496
06:39:37 <patc> > ((\x k -> 1+ sum [ x ** (fromIntegral n) / fromIntegral(product [1..n])  | n <- [1..k]]) (-1000) 150) == exp (-1000)
06:39:38 <lambdabot>   False
06:40:36 <int-e> djahandarie: 0/0 is NaN; NaN is represented as a number with maximum exponent (like infinity) but non-zero mantissa. In this case, -1.1_2 * 2^1024, I think (_2 denoting base 2)
06:40:51 <int-e> > -3 * 2^1023 == floor (0/0)
06:40:52 <lambdabot>   True
06:41:39 <djahandarie> Wow
06:41:42 <djahandarie> Interesting
06:42:11 <Jafet> > floor (0/0)
06:42:12 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
06:42:21 <Jafet> Shouldn't it be NaN?
06:42:31 <int-e> @type floor
06:42:32 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:42:45 <int-e> ... defaulting to Double -> Integer
06:42:55 <int-e> and Integer can't represent NaN
06:43:00 <Jafet> Hrm.
06:43:06 <Jafet> Maybe Integer!
06:43:11 <int-e> It should arguably bottom out :)
06:43:31 <koeien37> nah
06:43:38 <Jafet> Mixing floating point with integral calculation is a bad business anyhow
06:46:34 <lpsmith> Jafet:  the GMP uses floating point to implement arbitrary-precision arithmetic in some cases :-)
06:46:52 <Jafet> Never proved correct1
06:47:20 <lpsmith> The techique is sound, but challenging
06:47:39 <Jafet> I can't imagine a micro without hardware multiply being able to load GMP-sized code blocks, anyway
06:47:43 <Jafet> Or needing to
06:47:55 <en0th> sorry.. GMP?
06:48:13 <lpsmith> Gnu MultiPrecision library
06:48:23 <elspru> i'm having some trouble importing on haskell 6.8.2
06:48:28 <lpsmith> It's what haskell uses to do it's bignums :-)
06:48:35 <lpsmith> > product [1..1000]
06:48:36 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
06:48:46 <Jafet> One problem with GMP is that you can't interrupt it
06:48:53 <djahandarie> > 3.16 * 10^49
06:48:54 <lambdabot>   3.1600000000000004e49
06:48:57 <en0th> lpsmith: that's what haskell RTS uses, right?
06:49:06 <Jafet> The best you can do is compile threadsafe with separate alloc and kill it when necessary
06:49:11 <lpsmith> right,  I should say GHC, not Haskell
06:49:22 <byorgey> elspru: what sort of trouble?
06:49:24 <en0th> sorry, GHC ;)
06:49:24 <elspru> compile time error In function `sWY_info':
06:49:37 <lpsmith> I said it wrong first :)
06:49:39 <elspru> and a bunch of things the compiler generated
06:49:52 <elspru>  `LangData_sumtiStarter_closure'
06:49:56 <byorgey> elspru: try passing --make to the compiler
06:50:21 <byorgey> elspru: that will tell it to automatically chase down libraries to link
06:50:22 <djahandarie> >  sqrt ( (3 * 10^70) * (4 * 10^70) )
06:50:23 <lambdabot>   3.4641016151377553e70
06:50:26 <elspru> byorgey: thanks :)
06:50:40 <lpsmith> so anyway,  I'm not a gmp guru,  but this should almost certainly trigger floating point operations on the computer lambdabot is running on
06:50:40 <djahandarie> >  sqrt ( (3 * 10^70)^2 * (4 * 10^70)^2 )
06:50:42 <lambdabot>   1.2000000000000005e141
06:50:53 <byorgey> elspru: no problem.  did that fix it?
06:50:56 <lpsmith> > product [1..1000] * product [1..1500]
06:50:57 <lambdabot>   193628660894322549783721329440547197616532775518453586012313342753394537047...
06:51:05 <Jafet> > (sqrt ((3 * 10^70)^2 * (4 * 10^70)^2))::CReal
06:51:06 <lambdabot>   120000000000000000000000000000000000000000000000000000000000000000000000000...
06:51:14 <Jafet> > (sqrt ((3 * 10^70) * (4 * 10^70)))::CReal
06:51:15 <lambdabot>   34641016151377545870548926830117447338856105076207612561116139589038660.338...
06:51:26 <elspru> byorgey: yep :)
06:52:35 <lpsmith> also,  even if you don't go through the pain of implementing exact computations using floating point,   it's often useful to use floating point to make a good, quick first approximation,  and then go through an integer-based correction step
06:53:05 <Jafet> Or just use mpf
06:53:22 <djahandarie> > -0
06:53:24 <lambdabot>   0
06:53:33 <djahandarie> > -0 * -3
06:53:34 <lambdabot>   Precedence parsing error
06:53:34 <lambdabot>      cannot mix `GHC.Num.*' [infixl 7] and prefix ...
06:53:37 <djahandarie> GGah
06:53:42 <djahandarie> > (-0) * (-3)
06:53:43 <lambdabot>   0
06:54:05 <koeien37> i hate unary minus
06:55:10 <lpsmith> it's definitely a wart on haskell
06:55:17 <lpsmith> I would have much preferred something like ~
06:55:26 <koeien37> nah, just negate
06:55:33 <mauke> and negative literals
06:55:36 <koeien37> or 0-
06:55:38 <Jafet> 3 NEGATE 4 PLUS
06:55:44 <lpsmith> lol
06:55:54 <Jafet> Solved n decades ago
06:56:05 <djahandarie> > sqrt(-1:+0)
06:56:06 <lambdabot>   Precedence parsing error
06:56:07 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
06:56:08 <Twey> Just negative literals and whitespace-sensitivity for operators would be fine.
06:56:19 <djahandarie> lol
06:56:22 <Jafet> > +0
06:56:23 <lambdabot>   <no location info>: parse error on input `+'
06:56:24 <djahandarie> God damn screw it
06:56:33 <Twey> And yes, positive literals to go with it
06:56:38 <Jafet> Time to listen to Knuth and use base 2i
06:56:42 <Twey> It's not a wart, it's horribly broken
06:56:48 <mauke> preflex: calc 3 _ 4 +
06:56:48 <preflex>  1
06:57:06 <djahandarie> > 1/(-0)
06:57:07 <lambdabot>   -Infinity
06:57:28 <Nomad010>  > -1/(-0)
06:57:36 <Nomad010>  > -1/(0)
06:57:40 <djahandarie> Space
06:57:40 <Nomad010> > -1/(0)
06:57:41 <lambdabot>   -Infinity
06:57:53 <lpsmith> >>> print "Hello ",  "World!"
06:57:57 <djahandarie> > (-0)/5
06:57:58 <Nomad010> > -1/(-0)
06:57:58 <lambdabot>   -0.0
06:57:59 <lambdabot>   Infinity
06:58:03 <Nomad010> ok
06:58:08 <djahandarie> > sqrt(-0)
06:58:10 <lambdabot>   -0.0
06:58:28 <djahandarie> > -0/-Infinity
06:58:30 <lambdabot>   Not in scope: data constructor `Infinity'Not in scope: `/-'
06:58:31 <djahandarie> Oh
06:58:33 <djahandarie> Can't do that huh
06:58:44 <int-e>  > -0/-(1/0)
06:58:50 <lpsmith> oh,  koeien didn't have a python bot in here
06:58:55 <int-e> > -0/ -(1/0)
06:58:56 <lambdabot>   Precedence parsing error
06:58:56 <lambdabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
06:59:24 <int-e> > (-0)/(-(1/0))
06:59:25 <lambdabot>   0.0
06:59:28 <opqdonut> > negate 0 / negate (1/0)
06:59:30 <lambdabot>   0.0
06:59:55 <opqdonut> i think the IEEE spec says any real / Infinity is 0
07:00:41 <int-e> > (-0)/(1/0) -- nah, the sign is defined by the signs of the operands
07:00:42 <lambdabot>   -0.0
07:01:11 <djahandarie> > 1:+0
07:01:13 <lambdabot>   1.0 :+ 0.0
07:01:17 <opqdonut> int-e: ah yes
07:01:18 <djahandarie> > 1:-0
07:01:19 <lambdabot>   Not in scope: data constructor `:-'
07:01:20 <djahandarie> Err
07:01:24 <djahandarie> > 1:+ (-0)
07:01:26 <lambdabot>   1.0 :+ (-0.0)
07:02:23 <djahandarie> Does it even make sense to have a signed zero in the imaginary part?
07:02:27 <int-e> > join (liftM2 (+)) [-0.0, 0.0] -- this is the odd one
07:02:28 <lambdabot>   [-0.0,0.0,0.0,0.0]
07:05:07 <djahandarie> > -1.0 * 0.0
07:05:08 <lambdabot>   -0.0
07:05:44 <mauke> > join (liftM2 (*)) [-0,0.0]
07:05:45 <lambdabot>   [0.0,-0.0,-0.0,0.0]
07:06:00 <djahandarie> Arithmetic Underflow \o/
07:07:14 <chrisdone> evening
07:07:19 <mxc> whoever came up with using CPS for error handling is brilliant
07:07:45 <chrisdone> Gerald Jay Sussman?
07:07:58 <mxc> feeling some haskell love now as the #lines in my code is plummeting, yet i'm essentially optimizing it
07:08:02 <mxc> # of lines
07:08:05 <lunabot>  luna: parse error on input `of'
07:08:26 <chrisdone> Gerald Jay Sussman and Guy L. Steele, Jr. coined the phrase "continuation-passing style" in AI Memo 349 (1975), defining the first version of the Scheme programming language.
07:08:26 <mxc> sry luna, that wasn't for you
07:08:36 <chrisdone> oh hell yeah, I was right. that was just a joke
07:08:52 <mxc> well, i guess he gets the prize
07:09:07 <int-e> @snack
07:09:08 * lambdabot locks up  in a Monad
07:09:20 <int-e> @botsnack
07:09:20 <lunabot>  :o
07:09:20 <lambdabot> :)
07:09:42 <Twey> Heh
07:09:45 <lpsmith> neither invented continuations though;  I think credit is given to Reynolds and Landin,  among other independent discoveries in the 60s
07:10:24 <chrisdone> @snack brains
07:10:25 <lambdabot> stop telling me what to do
07:10:29 <chrisdone> =(
07:12:26 <Botje> @vixen do the dishes!
07:12:27 <lambdabot> what do you want to know about me?
07:12:39 <chrisdone> @vixen will you go out with me?
07:12:39 <lambdabot> good question
07:12:48 <saml> @src lines
07:12:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:14:00 <chrisdone> saml: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/src/Data-List.html#lines
07:14:50 <chrisdone> I never knew that didn't support \r\n
07:14:58 <chrisdone> hm! =)
07:15:27 <mauke> \r\n is wrong
07:15:37 <chrisdone> "wrong"?
07:15:43 <mauke> YES
07:15:49 <ray> yes
07:15:51 <Axman6> "wrong"!
07:15:57 <chrisdone> oh
07:16:03 <ray> \r\n is wrong
07:16:09 * chrisdone writes that down
07:16:13 <mauke> \r\n--
07:16:18 * Jafet throws mauke into a HTTP handshake
07:16:20 <chrisdone> "wrong"
07:16:26 <Axman6> @karma \r\n
07:16:26 <lambdabot> \r\n has a karma of -1
07:16:28 <ben0x539> \r\n--
07:16:31 <Jafet> > "\r\n" == "wrong"
07:16:32 <lambdabot>   False
07:16:39 <chrisdone> Haskell has spoken.
07:16:44 <mauke> Jafet: http uses \13\10
07:16:56 <ben0x539> \13\10--
07:17:01 <mauke> \13\10++
07:17:01 <Jafet> That's \r\n in ASCII
07:17:04 <mauke> Jafet: wrong
07:17:12 <chrisdone> mauke gambit
07:17:17 <mauke> ASCII has no \n
07:17:27 * hackagebot upload: happstack-dlg 0.1 - Cross-request user interactions for Happstack (ChrisSmith)
07:17:27 <Jafet> Line feed
07:17:33 <int-e> @karma \13\10
07:17:33 <mauke> \n is not line feed
07:17:34 <lambdabot> \13\10 has a karma of 0
07:17:49 <ray> silliness aside, you are wrong, chrisdone
07:18:00 <ray> \n is the platform-independent line ending
07:18:27 <ben0x539> > "\13\10" == "\r\n"
07:18:28 <lambdabot>   True
07:18:37 <twanvl> \n is always a single character, otherwise '\n' wouldn't work
07:18:44 <chrisdone> haha, this channel's becoming less #haskell-ish and more ##c-ish
07:18:55 <ray> that's just mauke :)
07:18:59 <chrisdone> YOU ARE WRONG
07:19:02 <mauke> ben0x539: implementation detail
07:19:07 <ray> you really are wrong!
07:19:08 <saml> > lines "a\rb"
07:19:09 <lambdabot>   ["a\rb"]
07:19:10 <ben0x539> Yeah, yeah
07:19:14 <twanvl> if your platform indicates line endings by "the line ends here", would "\n" == "the line ends here"?
07:19:26 <mauke> no
07:19:33 <ben0x539> No, but reading a file "athe line ends hereb" would give you the string "a\nb"
07:19:39 <mauke> \n is a virtual character used by the IO library
07:19:42 <ben0x539> and also, possibly, a headache.
07:19:58 <mauke> it doesn't have a fixed character code
07:20:22 <mauke> the IO library translates between \n and the external representation of lines
07:20:42 <BrianB04> Morning all.
07:21:30 <mauke> e.g. if your platform used fixed-length lines with 120 characters, putChar '\n' would write enough spaces to pad the current line to 120 chars
07:21:33 <chrisdone> where does one read about this stuff?
07:22:35 <ben0x539> mauke: Your argument is about non-binary files, right?
07:22:39 <twanvl> not storing line endings as '\n' (by which I mean '\10') is still a stupid idea IMO
07:22:41 <chrisdone> (not that I'm saying joe random IRC people aren't authoritative)
07:22:42 <mauke> ben0x539: yes
07:22:53 <mauke> ben0x539: \n doesn't make sense for binary files
07:23:08 <ben0x539> mauke: Except to represent \10 which everybody intuitively seems to be doing :<
07:23:13 <twanvl> mauke: what if the binary file contains a piece of text?
07:23:26 <dmhouse> Hi all. I'm trying to optimise the following code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15247#a15247
07:23:32 <mauke> ben0x539: unless you're on MacOS where \n == 13
07:23:46 <dmhouse> It's taking up 82% of the runtime of my program
07:23:48 <ben0x539> mauke: Except when reading a binary file
07:23:50 <ben0x539> Or writing to one
07:23:53 <mauke> twanvl: then you look at the file format to see how it's encoded, etc
07:24:05 <mauke> ben0x539: what?
07:24:14 <dmhouse> Of which most time is spend in the `where' clauses (see profile).
07:24:34 <ben0x539> If you say hPutChar f '\n' on MacOS with f being a binary file handle, you will write a \10, no?
07:24:41 <dmhouse> The idea of the where clauses is to build the map of vertices which are not `v' and not adjacent to `v'
07:24:54 <mauke> ben0x539: no, and by MacOS I mean pre-MacOS-X
07:25:39 <ben0x539> welp, someone get me a VM
07:26:12 <mauke> int main(void) { printf("%d\n", '\n'); return 0; }  // 13
07:26:37 <Jafet> dmhouse, couldn't you invert that criterion?
07:26:47 <dmhouse> S.toList and M.toAscList are both O(n). n here is 60.
07:26:55 <dmhouse> Jafet: in what sense?
07:26:55 <Jafet> You (almost) always end up with a smaller set if you do
07:27:00 <ben0x539> mauke: Presumably stdout is not open in binary mode
07:27:05 <Twey> I think if it's a binary handle it's always \10
07:27:06 <ben0x539> Oh, duh, nevermind.
07:27:08 <ben0x539> Sorry.
07:27:14 <ben0x539> :I
07:27:27 <Twey> Doesn't the \n-transformation only apply to text-mode handles?
07:27:30 <dmhouse> Jafet: erm, yes, but my algorithm doesn't work if so :) (Note it's not recursive; it's mutually recursive with another function.)
07:27:47 <mauke> Twey: irrelevant, we're talking about the value of \n itself
07:27:47 <Jafet> Hmm, dear
07:30:01 <Twey> mauke: It doesn't have one?
07:30:13 <mauke> what?
07:30:24 <Twey> A set value for \n
07:30:28 <dmhouse> mauke: so in your theoretical example of a fixed-width system, \n would have what value?
07:30:31 <Twey> At least on text-mode handles
07:30:49 <mauke> dmhouse: uh, any value that doesn't clash with alphanumerics or other stuff
07:30:56 <mauke> dmhouse: depends on your charset
07:31:11 <mauke> Twey: \n is a character. its value does not depend on any handles
07:31:25 <dmhouse> Twey: that doesn't make any sense. In C at least, '\n' is a character, which is just an 8-bit binary number. It has to have some value
07:31:51 <mauke> (note: C characters are not necessarily 8 bits)
07:32:11 <Jafet> dmhouse, what's an "empty subgraph"?
07:32:30 <dmhouse> Jafet: one with no edges
07:32:51 <dmhouse> Jafet: as in, a collection of vertices V st if x, y in V, xy is not an edge in G
07:32:59 <Jafet> Right, right.
07:33:19 <dmhouse> I'm doing graph colouring here and the point is you can give all the vertices in an empty subgraph the same colour
07:33:56 <dmhouse> So the algorithm is: pick an empty subgraph I_1 of G, pick an empty subgraph I_2 of G\I_1, pick an empty subgraph I_3 of G\(I_1 u I_2) etc
07:34:10 <dmhouse> I_k gets colour k. Doesn't necessarily get you a chi(G)-colouring, but it's not bad
07:34:24 <dmhouse> (All those empty subgraphs are maximal empty subgraphs, by the way.)
07:34:27 * koeien37 has a deja-vu
07:34:47 <dmhouse> koeien37: still optimising. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15247#a15247 is the current bottleneck
07:34:59 <Twey> Ah, in a string?
07:35:08 <koeien37> you've rewritten it to use Maps now?
07:35:12 <Twey> Shouldn't that be a Unicode value, though?
07:35:46 <dmhouse> koeien37: yep: type Graph = IntMap Vertex; data Vertex = V { label :: Int, nhood :: IntSet }
07:36:31 <Axman6> is that a directed graph?
07:36:49 <koeien37> "the maximal empty subgraph in 'g' containing 'v'", you mean a maximal coclique containing v?
07:36:55 <dmhouse> Axman6: nope, if xy is an edge then the Vertex representation of x has y in its nhood, and vice versa
07:37:09 <Axman6> righto :)
07:37:14 <koeien37> coclique = independent set
07:37:21 <dmhouse> koeien37: quite possibly, yep, if coclique = empty subgraph (makes sense as clique = complete subgraph)
07:37:28 <dmhouse> And by subgraph I mean induced subgraph, I guess
07:37:31 <Axman6> i haven't done much at all with graphs yet (both at uni and in haskell)
07:38:40 <koeien37> I guess that's a hard problem too
07:38:58 <koeien37> are you looking for the maximum subgraph, or is a maximal subgraph enough?
07:39:17 <dmhouse> What's the difference? Any independent set of maximum order will do
07:39:33 <koeien37> maximal is "i can't add any vertex anymore", maximum is of largest size
07:39:58 <dmhouse> Maximum, then.
07:40:03 <dmhouse> Here's the full algorithm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15247#a15248
07:40:05 <koeien37> i think that's NP hard
07:40:10 <dmhouse> At least, I think I want maximum, lemme check the spec
07:41:26 <dmhouse> Yep, I need an independent set of largest order
07:41:51 <koeien37> that is NP hard
07:42:04 <dmhouse> Ah well. Can I still make it faster? :)
07:42:13 <koeien37> probably
07:42:15 <Jafet> Profile each where-clause?
07:42:28 <koeien37> there is an article by stergrd you might want to read
07:42:35 <dmhouse> Jafet: have done, see the profile in the top paste
07:42:45 <dmhouse> Let me paste the key for that profile
07:42:49 <koeien37> (if you're interested in algorithmic improvements vs. Haskell-based fiddling ;) )
07:43:18 <dmhouse> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15247#a15249
07:43:25 <koeien37> http://www.win.tue.nl/~aeb/math/maxcl/maxcl.html this describes it in short.
07:44:02 <dmhouse> koeien37: the latter is my focus for now, but maybe
07:45:32 <hanDerPeder> how do I import the parser monad?
07:45:41 <mauke> which parser monad?
07:45:49 <koeien37> there are a few. Do you mean Parsec?
07:46:34 <hanDerPeder> using the book programing in haskel. trying to define "return :: a -> Parser a" but Parser not in scope
07:46:53 <koeien37> Hutton's book?
07:46:54 <Beelsebob> you will need to define your own Parser type
07:47:10 <Beelsebob> apropriate for your implementation of return/fmap/<*>/join
07:47:38 <koeien37> right. The Parser a-type is probably defined earlier.
07:47:45 <hanDerPeder> ok, maybe I should read on before firing off questions :)
07:47:52 <hanDerPeder> thanks though
07:49:18 <koeien37> dmhouse: I don't see any obvious improvements, except for using arrays instead of sets/maps if your graph is dense
07:49:50 <koeien37> type Graph = Array Int Vertex is also a little bit faster I guess
07:50:22 <dmhouse> koeien37: thanks
07:50:41 <koeien37> but keep in mind that a coclique-finder is going to be slow
07:51:07 <koeien37> it turns out that the order in which you visit the vertices is really important for performance
07:51:10 <koeien37> (in practice)
07:51:32 <Jafet> .oO(alphabeta!)
07:52:43 <koeien37> I have some C code that solves the problem, but you're probably not interested in doing it in C :)
07:57:07 <en0th> got a problem while upgrading array with cabal-install.. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5649#a5649 What can I do ?!
07:57:14 <Cale> Hmm, I wonder if the reason that the term 'coclique' is less common than 'independent set' is that it's easily confused with 'colouring'.
07:57:32 <koeien37> I don't see the source for confusion?
07:57:42 <Cale> A clique is a homomorphism K_n -> X, while a colouring is a homomorphism X -> K_n
07:58:20 <dmhouse> koeien37: I might try to write it in C next
07:58:26 <ben0x539> I am not sure I understand 'colouring'. What is a louring?
07:58:32 <dmhouse> koeien37: at least for a performance comparison sake
07:58:35 <Cale> heh
07:58:40 <koeien37> http://en.wikipedia.org/wiki/Graph_coloring
07:58:45 <koeien37> ben0x539: ^
07:58:51 <ben0x539> Thank you
07:59:01 <skorpan> like connect the dots?
07:59:01 <dmhouse> koeien37: but it does seem that the slowest bit of my algorithm is the bit that finds the co-neighbourhood of v
08:00:05 <Cale> skorpan: You have a bunch of dots (or vertices) connected by edges, and you want to colour the dots so that no two which are connected by an edge share the same colour.
08:00:22 <skorpan> Cale: yeah, but i was kidding :)
08:02:26 <koeien37> I remember executing this coclique finder on a graph of ~250 vertices
08:02:39 <koeien37> or clique finder, I forgot. It's not important
08:03:01 <koeien37> so 60 vertices might be doable
08:03:02 <dmhouse> Well, it is, since finding the neighbourhood is O(1) and the coneighbourhood O(n) in my implementation
08:03:19 <koeien37> you might want to save them both and remember it
08:03:31 <koeien37> data Vertex = Vertex { nbhood :: IntSet, co_nbhood :: IntSet }
08:03:41 <dmhouse> Hmm, not a bad idea
08:04:02 <EvanCarroll> osfameron: ?
08:04:12 <dmhouse> (It'd need label :: Int as well, of course.)
08:04:20 <koeien37> right.
08:05:01 <eugenn> @pl mcm a b = (a * b) `div` (gcd a b)
08:05:02 <lambdabot> mcm = ap (ap . (div .) . (*)) gcd
08:05:12 <koeien37> mcm ?
08:05:15 <osfameron> EvanCarroll: http://greenokapi.net/blog/2009/12/26/spreadsheet-imports-imperative-vs-functional/#comments
08:05:24 <koeien37> this is often called 'lcm'
08:05:58 <eugenn> koeien37, you're right, mcm is in spanish :P (minimo comun multiplo)
08:06:25 <koeien37> heh. it's "kgv" in Dutch, so that's even worse
08:07:07 <en0th> mcm in italian too
08:08:13 <koeien37> osfameron: nowadays I'd write a "groupBy" too, probably
08:08:23 <koeien37> but that's just because I like to write Haskell in any other language
08:08:35 <eihxrahi> anyone know of a good haskell irc vandalbot?
08:09:03 <Jafet> @faq can Haskell vandalize IRC channels?
08:09:04 <lambdabot> The answer is: Yes! Haskell can do that.
08:09:15 <osfameron> koeien37: I don't mind writing imperative if it's cleaner than functional (and that's sometimes the case in Perl.  But not this time :-)
08:09:50 <koeien37> osfameron: I often find that imperative programming is not clearer than declarative/functional style.
08:10:05 <osfameron> indeed
08:10:16 <koeien37> i.e. lots of "functions" (routines) that I write are of the form:    result = []. for x in some_list: ... result.extend(...); return result
08:10:57 <osfameron> that's equiv of map?
08:11:05 <koeien37> it might be concatMap
08:11:29 <Jafet> It might not be.
08:11:32 <koeien37> or something quite similar. But the changing variable "result" is not clearer imo
08:11:49 <Jafet> These languages tend to have fixed, overly general control structures
08:12:27 <osfameron> koeien37: I did say *sometimes* ;-)
08:12:33 <EvanCarroll> osfameron: responded.
08:12:38 <Jafet> for x in some_list { if something { result.extend = new_function(...) } ... }
08:12:56 <Jafet> (Javascript is awesome)
08:13:02 <koeien37> javascript is *not* awesome
08:13:18 <Jafet> Excuse me sir, I am busy being sarcastic
08:13:31 <eugenn> @src mod
08:13:31 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:13:47 <koeien37> there are some javascript supporters that claim whoever hates it, misunderstands it.
08:13:55 <koeien37> quite similar to Haskell advocacy actually ;)
08:14:03 <osfameron> javascript has some loveliness
08:14:14 <eugenn> what's the difference between mod and rem?
08:14:26 <koeien37> > (-5) `mod` 3
08:14:27 <lambdabot>   1
08:14:30 <koeien37> > (-5) `rem` 3
08:14:31 <lambdabot>   -2
08:14:46 <koeien37> > (-5) `div` 3
08:14:47 <lambdabot>   -2
08:14:52 <koeien37> > (-5) `quot` 3
08:14:53 <lambdabot>   -1
08:15:08 <Jafet> koeien: http://apina.biz/21145.jpg
08:15:31 <koeien37> mod & div are better suited to my uses, but quot/rem might have better hardware support (correct me if I'm wrong)
08:15:39 <Cale> div and mod are usually the ones you want, but for some stupid reason, rem and quot are the ones typically implemented in hardware
08:16:37 <Jafet> (Hardware? What hardware?)
08:17:11 <koeien37> I don't know what happens with negative divisors b in a `div` b and so on, but I've never encountered that in practice.
08:17:14 <burp> <koeien37> quite similar to Haskell advocacy actually ;) <- hah, I totally support this..
08:17:24 <burp> if you don't like haskell you didn't understand it
08:17:57 <int-e> we know where this is going: if you don't like fortran you didn't understand it
08:18:21 <koeien37> burp: not necessarily :) but a lot of Haskell hate IME comes from people who have never used it for anything remotely serious
08:18:38 <Jafet> I don't understand COBOL!
08:19:25 <koeien37> Jafet: good for you. it was the third programming language I learned. To this day, I don't know exactly why
08:19:37 <EvanCarroll> (ghci needs :src)
08:19:59 <Jafet> I think COBOL was invented for people who were half-businessmen
08:20:10 <Jafet> At least, looking at its list of keywords
08:20:22 <koeien37> i believe so, yes
08:20:27 <Cale> well, that's what the B stands for
08:20:36 <koeien37> common business oriented language?
08:20:52 <Cale> yeah
08:21:01 <Jafet> There are worse... applescript
08:21:09 * koeien37 wasn't sure about the first O, and figured that was "COmmon"
08:21:15 <Twey> Ayup
08:21:37 <koeien37> more text != readability
08:21:46 <koeien37> Pascal is not more readable than C because of the "begin" and "end"
08:21:50 <Twey> JS is lovely in that it's a (semi-)functional language that everybody uses
08:21:56 <Twey> It's the bait :
08:22:01 <Jafet> Pascal is more readable anyway, for other reasons
08:22:07 <koeien37> Jafet: correct
08:22:10 <Jafet> Although I can't imagine writing CRC32 in it
08:22:11 <Twey> koeien37: Makes it easier on people with screen-readers, though
08:23:18 <Jafet> Screen reading code sounds like a bad idea. Surely there are better ways to present code
08:23:27 <Twey> How so?
08:23:39 <dmhouse> koeien37: heh, caching the coneighbourhood definitely did the trick
08:23:48 <Jafet> Screen read a lisp program and see
08:23:50 <koeien37> http://news.ycombinator.com/item?id=1022430
08:23:58 <koeien37> dmhouse: good to hear! do you have acceptable performance now?
08:24:00 <Jafet> Speak of the devil.
08:24:05 <dmhouse> I'm not sure it's working correctly but it sure is fast...
08:24:40 <dmhouse> God, I loving having a REPL. This sure beats writing in C.
08:24:42 <koeien37> well, this is a heuristic? or is it really an approximation algorithm?
08:25:08 <Jafet> @remember dmhouse I'm not sure it's working correctly but it sure is fast...
08:25:09 <lambdabot> Done.
08:25:24 <Twey> Jafet: Pardon me.  By how so I meant: what superior alternative is available to a blind coder?  
08:25:31 <dmhouse> koeien37: I think the plan is to get a reasonably tight bound on chi(G)
08:25:54 <koeien37> then you have to measure it in practice :)
08:26:09 <elspru> i keep getting "pattern match overlapped" from using variable in case statement
08:26:12 <koeien37> you can try it on some planar graphs and see how close your bound of chi(G) is to 4, for example
08:26:14 <Jafet> Twey, no idea. But the tech talk on org-mode was introduced by a blind web dev
08:26:17 <elspru> ?
08:26:22 <koeien37> elspru: that is a warning, right?
08:26:35 <dmhouse> koeien37: well for now I'll just try it on small graphs and make sure it's implemented the algorithm correctly
08:26:42 <Jafet> And I'm pretty sure he doesn't get his headings pronounced "asterisk asterisk asterisk"
08:26:48 <elspru> koeien37: ya,
08:26:55 <elspru> koeien37: is there a better way?
08:27:01 <koeien37> elspru: could you paste your code?
08:27:07 <inimino> Jafet: screen readers are where it is at, and they are pretty advanced
08:27:09 <inimino> e.g. emacspeak
08:27:20 <koeien37> note that x = "x"; y = "y";    f x = ... ; f y = ...;    is NOT what you want, and a source of this warning too
08:27:41 <sproingie> elspru: if you handle every case then fall through to a wildcard case, you'll get that
08:28:37 <pozic> Does anyone know how text to speech works?
08:28:45 <sproingie> since you'll never actually hit the fall-through.  i found it annoying but i since decided that it's a design smell to handle every case explicitly and then add a fall-through
08:28:51 <pozic> I was sortof impressed by emacspeak.
08:28:57 <elspru> http://paste.ideaslabs.com/show/265FasXG2r
08:29:07 <sproingie> since it's only there for when you do change the data in order to fall-through, and that wasn't what you wanted the first time around
08:29:19 <koeien37> elspru: right, this is not going to work as you want
08:29:34 <elspru> why not?
08:29:40 <koeien37> Haskell will always take the first case
08:29:52 <elspru> why?
08:29:55 <sproingie> koeien37: variables in a pattern match are bound, not substituted
08:29:59 <sproingie> oops
08:30:09 <sproingie> elspru: ^
08:30:10 <koeien37> the pattern codeVerbStarter matches everything
08:30:29 <elspru> bah
08:30:35 <koeien37> you want  case x of _ | x == codeVerbStarter ->
08:30:57 <elspru> kk i'll try it out
08:31:08 <sproingie> think of variables in a pattern match as being like lvalues in another language
08:31:22 <koeien37> translate [] = []; translate (x:xs) | x == codeVerbStarter = ... ; translate ("comment":xs) = ...; translate (x:xs) = ...
08:31:31 * Twey . o O ( case ((== codeVerbStarter) -> True) ->  )
08:31:33 <koeien37> this is better style anyway
08:31:38 <dpratt71> I've decided that one of the worst things to come from learning Haskell is the tremendous frustration I now feel whenever I listen to people discussing "static" versus "dynamic" languages
08:31:46 <sproingie> Twey: i've got a view pattern with your name on it
08:31:51 <Twey> dpratt71: Haha, oh yes
08:31:53 <Twey> sproingie: <3
08:32:01 * Twey loves his view patterns
08:32:14 <pozic> dpratt71: Haskell and dynamic languages like Python do not do the exact same thing.
08:32:16 <ben0x539> I think it is hilarious that people want dynamic languages because they cannot be bothered declaring their variable types
08:32:33 <sproingie> ben0x539: it's understandable, other languages have made declaration so cumbersome
08:32:52 <koeien37> then use C#, Haskell, Scala, ML, ...
08:32:57 <Twey> ben0x539: http://yosefk.com/c++fqa/defective.html#defect-7
08:32:59 <sproingie> most haskell programs only declare types of top-level bindings
08:33:08 <sproingie> in C++ and Java, you have to declare *everything*
08:33:10 <sproingie> usually twice
08:33:12 <GPC> And then again there are things where dynamic variables are quite practical, just think of using COM.
08:33:21 <pozic> dpratt71: e.g. in Python you can implement a debugger by reusing the current environment.
08:33:27 <Twey> That little gem almost scares *me* off static typing
08:33:37 <absentia> c++ has auto tpes?
08:33:43 <pozic> dpratt71: to do the same thing you have to use GHC extensions and it will only run on one implementation.
08:33:43 <Twey> Heck no
08:33:45 <Philonous> Yeah, some things are cumbersome to do in static typed languages. Working on nested pairs for example
08:33:46 <koeien37> "auto" is something else
08:33:48 <sproingie> FooFactoryManagerInstanceFactoryFactory<NatterNatter,GromishGromish> foo = new FooFactoryManagerInstanceFactoryFactory...
08:33:49 <ben0x539> Twey: Sorry, I instinctively disagree with the entirety of the fqa because I suffer stackholm syndrome
08:33:56 <Twey> Hahahaha
08:34:15 <sproingie> i would flock to python or ruby if i had to do that all day
08:34:16 <koeien37> and Haskell has Dynamic! woo! Haskell is dynamic too!
08:34:27 <koeien37> add :: Dynamic -> Dynamic -> Dynamic
08:34:32 <elspru> koeien37: so how would I do that for multiple case statements? do all of them get prepended by _ | x == or ?
08:34:35 <orbitz> C# has dynamic type now!
08:34:37 <sproingie> as it is it's tolerable with eclipse but the noise is still dreadful
08:34:37 <orbitz> excitement
08:34:45 <sproingie> C# has type inference
08:34:52 <elspru> multiple patterns i mean
08:34:53 <ben0x539> Personally I flocked to ruby and then went to learn C++ afterwards :3
08:34:54 <sproingie> local type inference anyway
08:35:02 <sproingie> C++ is getting it
08:35:06 <sproingie> java remains the lone holdout
08:35:06 <koeien37> elspru: yeah, that's the canonical way. Note that "comment" is OK
08:35:08 <pozic> koeien37: yes, but can you ask of a given function which function called it?
08:35:12 <Twey> Dynamic typing in C# == passing everything as object
08:35:13 <dpratt71> pozic: I wouldn't suggest that dynamic languages have *no* advantages; it's just that so many of the *purported* advantages...aren't
08:35:17 <koeien37> .NET is actually going pretty well imo :)
08:35:19 <Jafet> Type inference is too advanced for Java
08:35:22 <EvanCarroll> after reading the desc of div/mod/quot/rem i think quot/rem the C behavoir sound massively more useful
08:35:32 <Jafet> It's too advanced for C++ as well, but they're shovelling it in anyway
08:35:33 <Twey> dpratt71: Yeah.  They're just lacks of disadvantages of crappily-designed type systems.
08:35:36 <koeien37> EvanCarroll: nope, i disagree strongly
08:35:38 <pikhq> dpratt71: I thought the primary advantage was that it made quick hacks easy?
08:35:43 <sproingie> C++ has had type inference for as long as it's had templates
08:35:53 <elspru> koeien37: oh excellent it's working :D
08:36:02 <pozic> GHC's type inferencer is also a hack.
08:36:02 <ben0x539> Jafet: They kind of have to, they have types that shall not be named, and you want to hold those values somehow
08:36:04 <koeien37> elspru: this is a common "gotcha"
08:36:15 <Jafet> EvanCarroll, that sounds strange, because the C behaviour is not well defined
08:36:15 <sproingie> it's just getting some simple local inference now
08:36:21 <EvanCarroll> I read division mentally, how many times does this go into that. it doesn't make sense to me to want (-11) `div` 5  to return 3.
08:36:28 <pozic> Basically it is "we want to derive as much as possible" and occasionaly a hack slips in.
08:36:37 <koeien37> Jafet: the C behavior is impelemtnation dependent , right?
08:36:44 <pozic> Systems like Coq separate the two.
08:36:47 <koeien37> > (-11) `div` 5
08:36:48 <lambdabot>   -3
08:36:52 <sproingie> EvanCarroll: there's a couple competing theories of modular arithmetic
08:37:00 <ben0x539> Wow, that is unintuitive :<
08:37:07 <koeien37> EvanCarroll: i really want a mod b always to return a positive number (if b > 0)
08:37:08 <vardhanvarma> Hi. Something very stupid.  At ghci prompt. typeing 'toInteger 10.50' give a chunk of error. How to user toInteger ?
08:37:12 <koeien37> nonnegative*
08:37:13 <sproingie> perl has the same behavior as haskell
08:37:19 <koeien37> :t toInteger
08:37:20 <lambdabot> forall a. (Integral a) => a -> Integer
08:37:29 <Twey> > negate 11 `quot` 5
08:37:30 <lambdabot>   -2
08:37:30 <koeien37> 10.50 is not Integral
08:37:39 <koeien37> what do you want to do? Round?
08:37:44 <Cale> vardhanvarma: Perhaps you want round, floor, or ceiling?
08:37:44 <Jafet> Once Haskell gets dependent typing, we'll make a mod b return ModularRing b
08:37:50 <Twey> Where does the -3 come from in div?
08:37:52 <vardhanvarma> @koeien47 yeah .. round
08:37:52 <lambdabot> Unknown command, try @list
08:37:58 <koeien37> :t round
08:38:00 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:38:05 <koeien37> > round 10.50 :: Integer
08:38:06 <lambdabot>   10
08:38:09 <Cale> > (-11) `mod` 5
08:38:10 <vardhanvarma> okay got it. What is toInteger for ?
08:38:10 <lambdabot>   4
08:38:17 <sproingie> Twey: div floors
08:38:17 <ben0x539> Presumably semantically doing proper division, then flooring?
08:38:23 <Twey> sproingie: Ah
08:38:23 <Cale> > (-11) `div` 5
08:38:24 <lambdabot>   -3
08:38:28 <Twey> div floors, quot truncates
08:38:32 <koeien37> it's for converting Integral types  to Integers. Not very widely used
08:38:33 <vardhanvarma> @Cale thanx
08:38:34 <lambdabot> Unknown command, try @list
08:38:44 <sproingie> python's division behaves the same way
08:38:57 <vardhanvarma> koeien37 , Cale: Thanx.
08:38:57 <en0th> does anyone know where i can find module Paths_cabal_install? QQ
08:39:00 <Cale> > ((-11) `div` 5)*5 + (-11) `mod` 5
08:39:01 <lambdabot>   -11
08:39:21 <koeien37> Basically, I want a = b * (a `div` b) + a `mod` b   AND  a `mod` b >= 0    (provided that b > 0)
08:39:22 <ben0x539> > ((-11) `quot` 5)*5 + (-11) `rem` 5
08:39:23 <lambdabot>   -11
08:39:34 <increpare> Cale: you saw my messages of unbridled appreciation for your implementation of (.) yesterday I hope?
08:39:55 <Cale> increpare: I don't think I did? You're talking about (.) = fmap?
08:40:11 <increpare> Cale: yeah, once I noticed you already had it in lambdabot : P
08:40:26 <increpare> Cale: it's entirely lovely.
08:40:49 <Cale> Tell that to Axman6 ;)
08:40:58 <Cale> (Some people hate it ;)
08:41:04 <sproingie> why?
08:41:07 <increpare> Axman6: The implementation of (.) in lambdabot I love.
08:41:14 <koeien37> basically because it's different from the Prelude
08:41:18 <Saizan> en0th: that module is automatically generated by cabal build, if you're building cabal-install
08:41:27 <sproingie> the dot as fmap is a little more, ah, promiscuous than the prelude's, but it's no different than curried functions
08:41:29 <Saizan> en0th: it's placed under dist/build/autogen
08:41:46 <increpare> sproingie: in what way do you say it's not different than curreid functions?
08:42:00 <Cale> I'm not sure I understand how it relates to currying
08:42:43 <Cale> The way I think of it is that functions with a fixed domain are like containers indexed by that domain, and composition effectively applies a function to the contained elements.
08:43:13 <koeien37> yes, that's basically why it's a Functor
08:43:17 <ben0x539> The use of 'indexed by' with something that is not "int i;" is still utterly nonintuitive :<
08:43:19 <EvanCarroll> I don't see what real world problem div/mod represent.
08:43:29 <koeien37> ben0x539: not necessarily
08:43:33 <en0th> Saizan: what should i do to get a local build of cabal-install from darcs sources?
08:43:38 <koeien37> EvanCarroll: modular arithmetic
08:43:43 <increpare> ben0x539: not really - you can have files indexed by letter, say.
08:43:48 <opdolio> Cale: I'm not sure "flip" is a very good name for f (a -> b) -> a -> f b.
08:43:53 <koeien37> EvanCarroll: suppose that you have a wall clock. You go three hours back.
08:43:59 <mercury^> It would be better yet if juxtaposition was fmap.
08:44:03 <EvanCarroll> if you have a cake with 13 slices, and you want to find how many slices each person can get at a table of 2, you come up with three?
08:44:06 <sproingie> in that if i see "f x" in code i don't automatically assume it's a single value any more than if i would see "f . x" ... huh i think i just refuted my own argument
08:44:10 <Cale> ben0x539: Imagine a mail room. Often the mailboxes are numbered, but it's also possible to have them indexed by people's names.
08:44:18 <EvanCarroll> that is the canonical division problem that you learn in first grade.
08:44:28 <ben0x539> But not by people's domain
08:44:33 <Saizan> en0th: if you don't have a cabal-install you can "runghc Setup configure --user && runghc Setup build && runghc Setup install" provided you've the dependencies installed
08:44:40 <ben0x539> EvanCarroll: You do not tend to have cakes with -11 slices
08:44:45 <Cale> ben0x539: The mailboxes are a function from their owners to the contents of the boxes. :)
08:44:53 <mercury^> > (+3) . [1..10]
08:44:54 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
08:44:58 <Saizan> en0th: that will install the binary under ~/.cabal/bin
08:44:58 <koeien37> the canonical division problem, is given a and b > 0, find q and r such that a = b * q + r, and 0 <= r < b.
08:44:58 <increpare> mercury^: heheheh : P
08:45:07 <sproingie> the negative cake is a lie
08:45:11 <EvanCarroll> what I'm saying... You obviously give each person 6 slices, and you split the remainder.
08:45:17 <Jafet> A negative lie!
08:45:20 <EvanCarroll> thats what quot and rem do, not div and mod
08:45:25 <Cale> > cake !! 12
08:45:27 <lambdabot>   "Fish shaped dirt."
08:45:27 <koeien37> > 13 `div` 2
08:45:28 <lambdabot>   6
08:45:33 <mercury^> > cake
08:45:35 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
08:45:43 <koeien37> lolwat
08:45:43 <ben0x539> I suppose you could do something like "okay, we owe this guy 11 dollars, how much does each of us five have to pay?"
08:45:44 <Saizan> en0th: there's also a script, bootstrap.sh, that fetches the deps automatically
08:45:57 <en0th> Saizan: the problem is i already have cabal-install, and just wanted to have a local test build..
08:45:59 <sproingie> > cake !! 2
08:46:00 <lambdabot>   "Three slash four cup vegetable oil."
08:46:11 <ben0x539> and then you want div instead of quot because the guy is going to get angry if you round towards not paying him that dollar
08:46:15 <en0th> *a second test build, to be clear
08:46:17 <mercury^> Fetches the dependencies for cake and then builds it?
08:46:20 <sproingie> > cake !! 12
08:46:21 <lambdabot>   "Fish shaped dirt."
08:46:22 <sproingie> > cake !! 15
08:46:23 <lambdabot>   "Fish shaped organic compounds and sediment shaped sediment."
08:46:27 <Saizan> en0th: just do "cabal configure" and "cabal build"  then
08:46:27 <increpare> > cake !! 13
08:46:28 <lambdabot>   "Fish shaped ethylbenzene."
08:46:29 <koeien37> in practice, using that  a `mod` b always returns the same representative for the equivalence class mod b, even if a is negative, is very useful!
08:46:39 <increpare> > cake !! 13
08:46:40 <sproingie> i just baked fish-shaped cookies the other day
08:46:43 <c_wraith> I'm glad that the sediment is sediment-shaped]
08:46:44 <lambdabot>   "Fish shaped ethylbenzene."
08:46:46 <sproingie> they were cat treats.  the cats hated them.
08:46:52 <en0th> Saizan: many thanks, i'll try
08:46:56 <sproingie> should have used less ethylbenzine i guess
08:47:12 <Cale> > cake !! 20
08:47:13 <lambdabot>   "Fiberglass surface resins."
08:47:18 <Cale> > cake !! 21
08:47:20 <lambdabot>   "And volatile malted milk impoundments."
08:47:43 <dmhouse> > cake
08:47:44 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
08:47:52 <dmhouse> > reverse cake
08:47:54 <lambdabot>   ["That will deodorize and preserve putrid tissue.","And it contains proven ...
08:48:03 <sproingie> > length cake
08:48:04 <lambdabot>   42
08:48:05 <increpare> :t cake
08:48:06 <lambdabot> [[Char]]
08:48:19 <increpare> > transpose cake
08:48:20 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
08:48:24 <koeien37> Am I misshing some obscure reference?
08:48:28 <sproingie> koeien37: portal
08:48:45 <c_wraith> that's not very obscure
08:48:45 <koeien37> portal?
08:48:49 <Cale> koeien37: If you haven't played the game Portal, you really ought to try it :)
08:48:49 <sproingie> a game
08:48:59 <mercury^> There's also a flash version.
08:49:02 <mercury^> That's not too shabby.
08:49:18 <koeien37> wikipedia says windows, xbox and playstation. So out of luck :( although flash might work
08:49:27 <sproingie> the flash version is 2d of course
08:49:29 <Cale> koeien37: It runs fine under wine
08:49:39 <Cale> (I played it in linux under wine)
08:49:42 * Twey too
08:49:49 <sproingie> source games tend to do well on wine
08:49:52 <mercury^> Cale: is there some way to get just the game and not steam and other stupid shit?
08:49:59 <Cale> mercury^: Warez it
08:50:00 <Twey> Torrents?  :
08:50:01 <ben0x539> Really? I always had the worst trouble with wine and steam.
08:50:12 <Twey> You don't need Steam for most Steam games
08:50:15 <sproingie> source games that have been cracked tend to do well on wine
08:50:22 <sproingie> Twey: you do for any games from Valve tho
08:50:23 <Twey> If you get them dubiously you can just play the game
08:50:27 <Twey> Nay
08:50:35 <sproingie> unless you have an xbox
08:50:36 <Twey> Portal's a Valve game
08:51:42 <sproingie> steam's pretty easy to crack, you just can't play online easily
08:51:52 <Twey> I don't think Portal has multiplayer
08:51:55 <sproingie> portal not being a game that lends itself to multiplayer
08:52:00 <sproingie> tho actually that would be a blast
08:52:10 <mercury^> Yep.
08:52:14 <sproingie> someone hacked the portal gun into half life 2
08:52:20 <Twey> Haha, yeah, it would
08:52:23 <sproingie> there's a cute mod of the "pick up the can" scene where he uses it
08:52:39 <Twey> :-D
08:52:42 <sproingie> once for the can, then he drops the guard from the ceiling
08:52:56 <mercury^> We should write our own FPS game though.
08:53:56 <Twey> We've got Frag
08:54:03 <mercury^> That's not a proper game.
08:54:08 <sproingie> we should mod frag with portal guns
08:54:10 <Twey> It's admittedly not as cool as Portal :
08:54:12 <Twey> Hahaha
08:54:22 <vardhanvarma> newbie issues with types ... want to user (round(sqtr(integer))  ... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15251#a15251
08:54:23 <mercury^> It does not even have multiplayer as far as I know.
08:54:40 <Twey> We should start by writing a good, high-performance, featureful functional 3D engine.
08:54:50 <Twey> That's the tricky bit, after all.
08:54:51 <sproingie> start with lambdacube i guess
08:54:58 <Cale> Although the manner in which portals violated the law of conservation of energy was probably one of the most fun aspects of that game, it would be interesting to see a version where they actually did preserve energy and not momentum.
08:55:02 <Twey> Lambdacube?  *google*
08:55:10 <koeien37> vardhanvarma: right. sqrt only works on "Double"s
08:55:13 <sproingie> Cale: it's cartoon physics
08:55:37 <Twey> Oh, sweet
08:55:39 <koeien37> to tries n should be [2 .. m] where m = round . sqrt . fromInteger $ n
08:55:52 * dmhouse debates whether to call a list of strings representing graphs g_strings
08:55:55 <sproingie> lambdacube's got a scenegraph engine, no idea if it's suitable for games
08:55:59 <increpare> Cale: they don't violate the law of conservation of energy necessarily (any more than it's usually violated in FPSs)
08:56:04 <vardhanvarma> koein37: okay .Thanx ..
08:56:08 <Twey> vardhanvarma: round . sqrt $ fromIntegral someInteger
08:56:10 <sproingie> game engines tend to need fairly precise control over allocation and gc
08:56:22 <mercury^> Cale: In what situation does it make a difference?
08:56:28 <vardhanvarma> Twey: thx .. will lookup about $ now
08:56:35 <koeien37> $ is just function application
08:56:37 <mercury^> I have not played the game, but I thought you did not collide with things there.
08:56:37 <koeien37> > (+1) $ 37
08:56:38 <lambdabot>   38
08:56:39 <sproingie> @src $
08:56:39 <lambdabot> f $ x = f x
08:56:53 <sproingie> $ is low-precedence.  its main purpose is to let you avoid parenthesis
08:56:54 <koeien37> but ($) has really low priority, so we use it to avoid parens
08:57:01 <sproingie> *ses
08:57:20 <vardhanvarma> okay  ... some oxymorono ... $ is low precdence (-:
08:57:32 <mercury^> Anyone here playing Quake btw?
08:57:32 <bob0> mercury^: no
08:57:43 <increpare> mercury^: not in many years
08:57:43 <Cale> mercury^: Well, imagine a portal on the floor and one on the ceiling. Gravity pulls on you, and your momentum is preserved when you go through the portal on the floor, so you accelerate endlessly (or until you hit the game's speed limit)
08:57:51 <sproingie> putstrLn ("Hello " ++ name "!") === putStrLn $ "Hello " ++ name "!"
08:58:00 <sproingie> bah
08:58:09 <koeien37> correct, but not what you want
08:58:11 <koeien37> ;)
08:58:17 <mercury^> Cale: and how should it be handled?
08:58:22 <increpare> Cale: however, the same happens in most fpses ; when you fall, you experience, but nothing experiences the negative of that force
08:58:28 <increpare> (you experience a force)
08:58:33 <vardhanvarma> so how does f(g(arg)) goes in $ notation ?
08:58:43 <koeien37> f . g $ arg, or f $ g arg
08:58:52 <sproingie> mercury^: imagine Wile E. Coyote's "portable hole".  now imagine having two of them independently, where entering one exits through the other.  that's portal.
08:59:09 <sproingie> multiplayer coop portal where one player had the blue and the other had the orange, that would have been awesome
08:59:12 <mercury^> I know how portal works.
08:59:30 <Cale> mercury^: Perhaps by locally changing gravity :)
08:59:51 <increpare> Cale: If you were going for physical realism, you'd maybe have the whole level shift up by a tiny tiny tiny tiny amount when you gain high speeds, but really the amount you could justify doing it by would be tiny.
08:59:58 <koeien37> imagine a game where h is large or c is small :)
09:00:17 <dmhouse> do g_strings <- lines `fmap` readFile "test-mod-graphs"; mapM_ (print . chi_indpt . read) g_strings -- this should run in space bounded by the size of the file "test-mod-graphs" and the size of the largest object I `read' from it, right?
09:00:17 <dmhouse>  
09:00:21 <mercury^> Cale: So you want compensation for the positional energy gained from being lifted up?
09:00:24 <ben0x539> Physical realism is maintained by handwaving that the portal gun contains an energy cell that is suitably depleted to conserve energy when you are infinitely accelerating
09:00:29 <sproingie> you do at least reach terminal velocity in portal
09:00:44 <Twey> vardhanvarma: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15251#a15253
09:00:49 <Cale> mercury^: yeah
09:00:55 <mercury^> Cale: that'd be super boring I guess.
09:01:04 <Cale> mercury^: Well, I'd like to experiment with it :)
09:01:58 <sproingie> wonder if the portal gun in HL2 would let me take out those snipers with a crowbar
09:02:04 <Cale> mercury^: The compensation would be in the form of an adjustment to the gravitational "field"
09:02:40 <Philonous> Cale: But what wold happen when lack the kinetic energy to kompensate for the gain of potential energy
09:02:42 <mercury^> And how do you get gravity up again?
09:02:48 <sproingie> graviagra
09:03:27 <Cale> mercury^: I guess just by creating different portals
09:03:49 <increpare> Cale: I can imagine it might be fun if you could throw things into portals
09:03:55 <holmak> sproingie: The snipers aren't real. The hole just throws out a body when a little entity in there takes enough damage.
09:03:58 <mercury^> But then you'd solve levels by decreasing gravity and just jumping everywhere.
09:04:03 <increpare> Cale: then you could use it strategically without having to get stuck zipping through them forever
09:04:20 <Cale> mercury^: It would change gravity in a non-uniform manner though
09:04:23 <increpare> mercury^: gravity can be helpful! with moving large objects, say
09:04:25 <sproingie> holmak: figured as much.  i guess that prevents them from clipping
09:04:38 <holmak> clipping what?
09:04:45 <sproingie> the gun clipping through the wall
09:04:52 <increpare> Cale: you're going beyond the bounds of mere compensation for missing forces now I think : P
09:04:56 <holmak> ah
09:04:59 <eugenn> > (1+) (2*) 3
09:05:00 <lambdabot>   No instance for (GHC.Num.Num (t -> t))
09:05:00 <lambdabot>    arising from the literal `1' at <...
09:05:00 <Cale> increpare: yeah
09:05:08 <eugenn> > (1+) $ (2*) 3
09:05:09 <lambdabot>   7
09:05:29 <Cale> increpare: It would be interesting to play around with different theories which could compensate for that.
09:05:42 <increpare> Cale: Sure.  You should do it.
09:05:45 <holmak> sproingie: If you haven't played through the halflifes with developer commentary on, I recommend it.
09:06:00 <ben0x539> Someone upload Control.Gravity.Portal to hackage already
09:06:10 <sproingie> holmak: only done it for lost coast and portal.  still havent gotten around to finishing eps 1 or 2
09:06:29 <HaskellLove> Euler 46 solved http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15254#a15254
09:06:49 <increpare> blech; I'm meant to be finishing a game today instead of mooching around here...
09:06:53 <mercury^> So, no one here playing quake? :(
09:07:11 <increpare> mercury^: the original?
09:07:16 <mercury^> Any.
09:07:22 <mercury^> CPM counts too.
09:07:29 <Jonno_FTW__> no....
09:07:33 <increpare> mercury^: as I said before, I used to play the original, but I haven't in ages
09:07:48 <mercury^> I see.
09:08:00 <increpare> Probably the only FPS I really got into.
09:08:30 <samnardoni> and there's me thinking this is a haskell channel ;)
09:08:46 <Cale> I played Q3 for a long time, haven't in ages though.
09:08:50 * Twey plays OpenArena a bit.
09:08:58 <eugenn> @src !$
09:08:59 <lambdabot> Source not found. stty: unknown mode: doofus
09:09:08 <eugenn> @src $!
09:09:08 <lambdabot> f $! x = x `seq` f x
09:09:30 <eugenn> @src seq
09:09:30 <lambdabot> Source not found. Sorry.
09:09:43 <sproingie> seq is magical
09:09:47 <mercury^> I play very rarely now.
09:09:51 <increpare> mercury^: have you tried out that browser version of Q3?
09:10:14 <Philonous> eugenn: seq is atomical. It forces it's left argument and returns the right.
09:10:18 <increpare> mercury^: (quake live)
09:10:35 <mercury^> Yes. I do not like it very much. Some changes were good, but in general I dislike how everything is so centralised.
09:10:46 <sproingie> if x is an IO action, will seq execute it twice?
09:10:53 <increpare> mercury^: centralised?
09:10:56 <mercury^> Many Quake buddies of mine play it though.
09:11:01 <eugenn> > seq 3 4
09:11:02 <lambdabot>   4
09:11:07 <mercury^> You cannot add maps yourself, cannot host servers etc.
09:11:09 <ben0x539> sproingie: I suspect it will execute it once and pass it to f once
09:11:19 <roconnor> sproingie: evalutaiton != execution
09:11:19 <increpare> mercury^: they've changed it now so you can host servers I think?
09:11:19 <ben0x539> err, evaluate it once
09:11:34 <mercury^> increpare: you can pay them money to be able to use their servers to host games.
09:11:38 <roconnor>  /= even
09:11:39 <increpare> mercury^: ah right.
09:11:53 <Philonous> sproingie: Forcing an IO action /= executing it
09:11:57 <increpare> mercury^: yeah a bit meh
09:12:13 <mercury^> And it is a mystery to me how everyone switched to QL from CPMA.
09:12:29 <phaer> #lisp
09:12:30 <lunabot>  luna: Not in scope: `lisp'
09:12:34 <eugenn> > signum 5
09:12:35 <lambdabot>   1
09:12:50 <eugenn> > signum (-5)
09:12:51 <lambdabot>   -1
09:12:55 <eugenn> > signum 0
09:12:56 <sproingie> > signum 0
09:12:57 <lambdabot>   0
09:12:57 <lambdabot>   0
09:13:02 <eugenn> haha
09:13:24 <sproingie> smallcheck would show it all at once
09:13:27 <sproingie> > signum
09:13:28 <lambdabot>   {-3->-1;-2->-1;-1->-1;0->0;1->1;2->1;3->1}
09:13:30 <increpare> mercury^: cpma?
09:13:54 <mercury^> The mod that was previously used for competition, featuring VQ3 and CPM gameplay. I played the latter.
09:14:04 <increpare> mercury^: ah ok.
09:14:09 * increpare googls cpm
09:14:18 <mercury^> The website is down atm.
09:15:07 <eugenn> > - $ 5
09:15:08 <lambdabot>   <no location info>: parse error on input `$'
09:15:14 <mercury^> If you want to play it I could find links to the relevant files.
09:16:14 <increpare> mercury^: I have to ration my game-playing time out very carefully ... so no thanks : )
09:19:27 <samnardoni> what are everyones opinions on haskell becoming a mainstream language?
09:19:38 <sproingie> in some circles it already is
09:20:03 <sproingie> tho none of those are what i'd call consumer industries
09:20:20 <increpare> samnardoni: I'd rather it not get *too* tied down to mundane concerns myself, but I guess I don't mind...
09:20:56 <sproingie> i'm not sure it's ever going to be
09:21:05 <sproingie> lisp has had 50 years and it didn't
09:21:16 <mercury^> Lisp is a less likely candidate though.
09:21:26 <sproingie> really?  it's got far more practical constructs
09:21:27 <mercury^> But I also think that Haskell will not make it soon.
09:21:46 <sproingie> as OO languages go, it's hard to beat CL
09:21:47 <mercury^> sproingie: really?
09:22:03 <mercury^> Well, the syntax alone is a good reason not to use it I find.
09:22:11 <samnardoni> in all honesty, i think something like scala is more likely to become popular.
09:22:13 <sproingie> haskell's syntax is clean but it's still about as alien as lisp to most
09:22:29 <sproingie> scala is Java 8.  or should be.
09:22:39 <EvanCarroll> I love haskells syntax.
09:22:53 <shambler> lisp is easy
09:23:00 <sproingie> i like it too for the most part.  offside rule is a little annoying sometimes
09:23:13 <samnardoni> i'm just not sure whether scala bridges the gap between functional and OO, or whether it just blurs it.
09:23:13 <shambler> few "(" here, few ")" there and you're fine
09:23:20 <sproingie> the rule changes the indent of everything else if you edit the lines above, which is something that doesn't happen in python
09:24:00 <sproingie> i think it's more likely that mainstream languages will just lift more bits out of haskell
09:24:05 <mercury^> The main reason haskell is not popular is that while its syntax is good, it's too far in paradigm and syntax from the languages people currently use a lot.
09:24:06 <sproingie> linq for example came straight from HaskellDB
09:24:28 <mercury^> But semantically there seems to be a shift towards haskell.
09:25:28 <sproingie> toward functional idioms anyway
09:25:32 <sproingie> again, see linq
09:25:46 <samnardoni> sproingie: agreed
09:26:01 <sproingie> not only is it functional, it's a monad
09:27:45 <shambler> it is nice to see how guys from production-level projects started to value FP approach http://lambda-the-ultimate.org/node/1277
09:27:57 <samnardoni> am i right in thinking that functional languages help in concurrent programming? (e.g. multi-core processors)
09:28:03 <sproingie> GPU programming is also hugely functional
09:28:09 <blackh> It's seems to me that the watered-down Haskells out there will act as a bridge to the real thing.  I convinced a LINQ programmer recently to look at it for that reason.  IMHO Haskell's only real barrier to acceptability to programmers is that it is "too different".
09:28:09 <sproingie> shaders are basically functional
09:28:15 <sproingie> heck they're practically monadic
09:28:28 <Olathe> I think something different. With C or PHP, you feel mastery just for learning to do simple tasks. With Haskell or Ruby, you need to get that feeling from the creativity and power of the programs you make because the easy things are fairly easy.
09:28:46 <Olathe> And a lot of environments are against creative results.
09:29:07 <increpare> Olathe: What do you mean by this?
09:29:15 <sproingie> i feel mastery from being able to do simple things in haskell, actually
09:29:19 <samnardoni> I like Haskell, but I also enjoy math. Some people just like building things.
09:29:21 <sproingie> with C++, the bar is a lot higher
09:29:53 <Olathe> If you want to get the good feeling of mastery but you can't make innovative results (great programs) without being punished, you want to go with something that makes it a puzzle to do simple things.
09:29:55 <sproingie> it's a difficulty thing, i still think in objects
09:30:06 <sproingie> i'm trying to think in monoids now, but i can't really see them
09:30:16 <sproingie> i'm wondering if i should look for other patterns instead
09:30:16 <blackh> samnardoni: Pure languages (only a minority of functional languages are pure) offer a way of programming parallel hardware that eliminates race conditions and deadlocks is 100% deterministic.
09:30:21 <sproingie> maybe arrows
09:30:59 <sproingie> most people don't find it a puzzle to do simple things in C or PHP
09:31:00 <increpare> Olathe: I think that has nothing to do with the language and more with the programming culture.  There's plenty of innovation that goes on with C and C++, but in a big company you have to make sure your achievements fit within the larger frameworks established.
09:31:07 <Olathe> It's not a hard puzzle.
09:31:09 <sproingie> with C it's a lot of tedium, yes, but not really complexity
09:31:10 <Olathe> Just a puzzle.
09:31:23 <Olathe> Like the people who solve sudoku or something.
09:31:29 <sproingie> the essence of a puzzle is that the solution isn't obvious
09:31:38 <sproingie> (one reason i never liked sudoku)
09:31:55 <samnardoni> does anyone have any experience with genetic algorithms/programming?
09:31:56 <Olathe> Well, I've seen a lot of people that feel good for having mastered something most others haven't.
09:32:03 <Olathe> Not saying the people here, of course.
09:32:09 <Olathe> Just a lot of people in C or PHP.
09:32:22 <sproingie> the solution to a great many problems in imperative languages is quite obvious, it's just a tedious matter of getting there
09:32:27 <Olathe> Sure.
09:32:39 <Olathe> It's the tedium that bores others away from learning it, I think.
09:32:51 <sproingie> some haskell problems are obvious because they fit haskell's domain.  it's fitting haskell to problems outside of the functional comfort zone that gets tricky
09:32:51 <Olathe> And so, the people who remain can feel good about their "drive" or whatever.
09:32:59 <increpare> Olathe: what do you mean? lots of people learn imperative programming...
09:33:00 <Olathe> This is, of course, just a nonsense opinion of mine :)
09:33:12 <Olathe> Oh, sure. But I mean most people don't.
09:33:19 <Olathe> Most people aren't programmers.
09:33:26 <Olathe> So, you can feel smart compared to them if you want.
09:33:33 <increpare> sproingie: that's true of other languages as well (cf boost0
09:33:34 <sproingie> if i weren't bored by tedium i'd be working in java
09:33:49 <Olathe> Yeah, that boredness is great for learning better ways.
09:33:50 <increpare> Olathe: why would I want to feel smart compared to anyone else?
09:33:55 <Olathe> That's why a lot of us are here.
09:33:59 <Olathe> Oh, I don't think you are.
09:34:00 <sproingie> C++ can actually get extremely clever but the syntax of template heavy code makes my eyeballs bleed
09:34:07 <Olathe> You probably don't want to feel smart if you're here.
09:34:15 <Olathe> You probably want to not be bored.
09:34:21 <sproingie> D does better there but D's ecosystem is sometimes actively hostile to getting anything done
09:34:24 <Olathe> But a lot of people want to feel smart compared to others.
09:34:53 <increpare> sproingie: I know a bunch of people who've changed over to using D.  I'm tempted to, but it doesn't really fulfill any of my needs that I don't already have outlets for.
09:35:09 <samnardoni> I like Haskell because I like letting the computer do the work, not my fingers.
09:35:11 <sproingie> i often feel dumb when i come here because so much is over my head
09:35:17 <sproingie> but i also like to learn
09:35:35 <Olathe> Yes, and your willingness to feel dumb is what allows you to go beyond C and so on :)
09:35:49 <Olathe> A lot of people are afraid to feel dumb. You can see it a lot if you help people with math.
09:36:06 <ben0x539> I dislike D because it seems to be be happy about me feeling dumb
09:36:14 <Olathe> They learn one hard thing (C programming, say) and hold on for dear life.
09:36:21 <sproingie> increpare: it doesn't help that there's little IDE support (haskell neither but it needs it less) and that on windows the object format is some crusty ancient zortech thing
09:36:22 <increpare> sproingie: I often feel dumb when I look at other people's C/C++ code (when they're specialized in another area)
09:37:17 <sproingie> i can usually get the gist of most C++ code, except maybe for Andrei Alexandrescu's
09:37:23 <sproingie> and i think he's moved over to D these days
09:37:43 <ben0x539> Does D have an entirely free/portable implementation yet?
09:37:43 <samnardoni> i think unreadable code says more about the author than the reader
09:38:05 <sproingie> alexandrescu is all about template metaprogramming
09:38:06 <increpare> sproingie: yeah.  But I mean to say that there's more to most people's code than their choice of language - what they're expressing in it can be interesting independently of that.
09:38:08 <increpare> ben0x539: yeah
09:38:23 <mauke> http://www.cpax.org.uk/prg/portable/c/c++/rfe00002.html
09:38:45 <sproingie> ben0x539: ldc is supposed to be pretty usable.  it's still a gigantic PITA to make dsss use it tho.
09:38:55 <ben0x539> hmm
09:39:08 <pikhq> ben0x539: Before LDC, there was GDC.
09:39:14 <pikhq> GDC is now unmaintained, though.
09:39:24 <ben0x539> I spent a few irregular afternoons trying to compile GDC :/
09:39:37 <pikhq> GDC was a royal PITA to get working.
09:39:39 <ben0x539> and then it turns out phobos did not like my architecture
09:39:42 <sproingie> D is just so fragmented.  tango vs phobos, 1.x vs 2.0
09:39:47 <dmhouse> koeien37: if you're still interested, turns out caching the coneighbourhood helped speed up my algorithm on random graphs (1/2 probablity of each edge being there)
09:39:47 <sproingie> tango doesn't work on 2.0, etc
09:40:07 <sproingie> i used tangobos and that worked out pretty well.  still no 2.0
09:40:22 <pikhq> D is a decent language with a (frankly) retarded user community.
09:40:25 <sproingie> and 2.0 is supposed to have something else entirely but it's still vapor
09:40:29 <dmhouse> koeien37: however it hasn't quite helped in the second use case, which is on random "modded" graphs, where I take the above random graphs and remove edges ij where i-j = 0 (mod 3)
09:40:38 <pikhq> So. Much. Splinters.
09:40:44 <sproingie> and on and on.  i liked the language but i fought the toolchain too much to want to stick with it.
09:41:01 <pikhq> sproingie: 2.0 is supposed to have a small runtime that Phobos and Tango will use.
09:41:05 <dmhouse> (The point of the latter is so that chi(G) <= 3; the vertices which are 0 mod 3, 1 mod 3 and 2 mod 3 can each have their own colour.)
09:41:14 <sproingie> pikhq: yes, it's due out sometime three years ago
09:41:19 <pikhq> Yup.
09:41:42 <pikhq> sproingie: Makes you want to just scream at them and say "decide on a *single* libd!".
09:41:58 <sproingie> they're reviving duke nukem forever and porting it to D 2.0's new stdlib and SDL 1.3
09:42:10 <ben0x539> If I went and wrote a type class that had a method (===), would I call it Eqq or Eeq?
09:42:35 <sproingie> pikhq: i just want to scream "pick tango, it's the one that actually has any community at all"
09:42:43 <sproingie> walter bright is basically a community of one
09:42:46 <marsh_> Threeq?
09:42:58 <aavogt> EQ
09:43:00 <pikhq> sproingie: True, true.
09:43:01 <skorpan> ben0x539: JavaScript
09:43:11 <pikhq> But even if they *just* had Phobos, I could at least accept it.
09:43:14 <djahandarie> ben0x539, what is it for
09:43:15 <ben0x539> I suspect OI want the entire opposite of ===
09:43:20 <pikhq> ... By merit of it being a *single* libd.
09:43:20 <Olathe> ben0x539: What does === do ?
09:43:26 <dmhouse> koeien37: the algorithm can still only cope with up to n = 27 or so in the modded case
09:43:32 <samnardoni> I want to write a small game in Haskell; any ideas?
09:43:34 <pikhq> Rather than there being mutually exclusive libd's....
09:43:49 <Olathe> samnardoni: Tic Tac Toe with a perfect AI.
09:43:49 <pikhq> Making it nearly impossible to have a decent D install.
09:43:52 <sproingie> samnardoni: port Dwarf Fortress, should take about a weekend >:)
09:44:07 <samnardoni> sproingie: Never heard of it
09:44:15 <sproingie> oh dear
09:44:21 <sproingie> start playing it and we may never see you again
09:44:28 <ben0x539> djahandarie: 2 === [1, 2, 3], "foobar" === mkRegex "o+", 42 === (40, 50) or something
09:44:37 <samnardoni> What's GUI programming like in Haskell? (on OSX)
09:44:43 <sproingie> samnardoni: it's like dungeon keeper meets the sims meets fellini meets quentin tarantino
09:45:03 <holmak> DF is an absurd game.
09:45:05 <samnardoni> sproingie: Haha, gunna have to check it out.
09:45:05 <tilman> meets nethack? :)
09:45:11 <Olathe> ben0x539: I'd go with IsIn or something.
09:45:12 <sproingie> meets the matrix
09:45:17 <fft> Does anyone know how to align selected code within emacs haskell mode?  The shortcut from tutorial doesn't work.
09:45:22 <Olathe> ben0x539: But there may be better ideas.
09:45:38 <dmhouse> fft: you can't in general, because there's more than one syntactically valid indentation point for each line
09:45:41 <samnardoni> Might have to kick it with terminal for a while
09:45:41 <djahandarie> ben0x539, well...I don't really see the point of that
09:45:45 <sproingie> i don't see the symbols anymore.  all i see is blond, brunette, redhead, magma, puppy spleen, goblin intestine...
09:46:06 <dmhouse> fft: M-x align-regexp is handy, though, as are the rectangle functions (C-x r t, C-x r o and C-x r d)
09:46:06 <pikhq> sproingie: :)
09:46:09 <holmak> Does anyone know of any libraries/tools for chasing down references in Haskell code, like what Visual Studio can do with "Find all references..."?
09:46:35 <holmak> Not so much references, as chasing down type/function declarations.
09:46:40 <increpare> holmak: I think leksah had some stuff like that - nto positive though
09:46:50 <pikhq> holmak: grep ::?
09:46:51 <ben0x539> Is -XFlexibleInstances considered bad form? :|
09:46:52 <pikhq> :P
09:46:57 <dmhouse> holmak: if you're using Emacs, etags will do that
09:46:58 <sproingie> ben0x539: nope
09:47:08 <samnardoni> Best way to clear screen (terminal)?
09:47:08 <marsh_> grep always worked for me, I quit using that feature of MSVS
09:47:16 <holmak> marsh_: why?
09:47:16 <dmhouse> samnardoni: Ctrl+L?
09:47:22 <Twey> UndecidableInstances is, though 
09:47:29 <fft> dmhouse: I saw the example about regexps of aligning by the sign '=' for example. Is it the only way? How about nested identation? So it cannot choose the one canonical identation and align ?
09:47:36 <samnardoni> dmhouse: via Haskell ;)
09:47:51 <sproingie> ack > grep
09:48:10 <Twey> ack?
09:48:26 <sproingie> http://betterthangrep.com/
09:48:26 <Olathe> Ack ! *dies*
09:48:48 <dmhouse> fft: but what does the canonical indentation mean? http://www.reddit.com/r/programming/comments/9wlb7/proggitors_do_you_like_the_idea_of_indented/c0esn7t
09:49:45 <djahandarie> Twey, so you use FlexibleInstances without UndecidableInstances?
09:50:24 * Twey has never needed to use FlexibleInstances, thankfully
09:51:35 <Twey> ack is written purely in Perl, and takes advantage of the power of Perl's regular expressions.
09:51:38 <Twey> Arrgh!
09:51:49 <fft> dmhouse: The last one of that 3 sample for instance. Align expressions from one block and shift nested block right,
09:51:59 <sproingie> forget about the perl, it's what it does by default
09:52:24 <sproingie> basically grep -Pr --color, and it only looks at "interesting" files
09:53:02 <sproingie> plus it has ack --thpppt
09:53:20 <Saizan> thpppt
09:53:21 <Saizan> ?
09:53:24 <Botje> plus, it's one letter shorter.
09:53:33 <Twey> Hahahaha
09:53:55 <Twey>   --thpppt              Bill the Cat
09:54:14 <Olathe> As long as it doesn't bill me.
09:54:20 <Twey> Hear, hear!
09:54:32 <sproingie> i had to hack ack to make it search .hc files tho
09:54:43 <sproingie> i should send a patch
09:54:43 <dmhouse> fft: I think you're missing the point. In that example, how does it know whether just "bar" belongs to the inner block, or whether it's both "bar" and "baz"?
09:54:51 <sproingie> er .hsc
09:54:56 <dmhouse> fft: both of the examples are valid (Python, but you get the point)
09:55:15 <dmhouse> fft: there's simply no way to know what you mean without doing some guessing
09:55:32 <dolio> Why are you writing un-indented code and indenting it later?
09:56:03 <orbitz> I find i only really have the issue with Python when I am refactoring code and end up removing a level of indentation
09:56:08 <orbitz> or adding one
09:56:14 <sproingie> i wouldn't mind a C with semantic indentation
09:56:15 <dmhouse> Hence the rectangle commands
09:56:16 <orbitz> but even then it's not a big issue
09:56:34 <Botje> sproingie: you can add extensions to certain categories from .ackrc or the command line
09:56:41 <sproingie> there's pyrex/cython but that emits more or less a script for the python API
09:57:09 <sproingie> just having to type semicolons at the end of every statement irks me to no end
09:58:16 * hackagebot upload: HPath 0.0.1 - Extract Haskell declarations by name. (JasonDusek)
10:00:42 <Saizan> ?hackage HPath
10:00:43 <lambdabot> http://hackage.haskell.org/package/HPath
10:03:11 <HaskellLove> I finished Euler 47 but solution is slow, actually still computing if anyone can see some optimizations please: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15256#a15256
10:04:28 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15256#a15257 look at the botom one i removed unused functions
10:04:50 <dmhouse> Bah, there should be an O(n) operation in Data.IntMap to take an IntSet and return a the submp corresponding to those keys
10:06:46 <orbitz> HaskellLove: why div 3?
10:07:23 <HaskellLove> orbitz sorry where is that?
10:07:39 <HaskellLove> oh yeah sorry let me remove it
10:07:48 <HaskellLove> it was from older function
10:08:02 <HaskellLove> but wait orbitz dont look at those functions
10:08:16 <HaskellLove> click the second link, look at the code down not above
10:08:19 <orbitz> don't look at teh code you pasted?
10:08:43 <HaskellLove> orbitz dont you see the revision?
10:08:46 <orbitz> oh
10:08:50 <orbitz> what problem are you trying to solve
10:08:59 <HaskellLove> euler 47
10:09:03 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=47
10:09:44 <HaskellLove> primeFactors just gives primeFactors for given n... isElementOf tests if given n is element of three lists...
10:10:23 <HaskellLove> test takes a number and the next 3 numbers, and aplies haveMoreCommonFactors to that list of numbers, so haveMoreCommonFactors is where the magic happens
10:11:08 <ben0x539> Annoying that Haskell will not use an instance 'A a a' when it wants an instance 'A a b' where both a and b are types of integral literals :<
10:11:09 <orbitz> HaskellLove: are you recomputing the next 3 each time?
10:11:19 <ben0x539> Just use Int or whatever!
10:11:24 <djahandarie> HaskellLove, you could use a FFT for the prime-factor algorithm
10:11:42 <ben0x539> Foreign Function Transformation~
10:11:46 <HaskellLove> orbitz well of course, how else?
10:11:59 <djahandarie> ben0x539, not the FFT I was refering to. :P
10:12:07 <HaskellLove> sorry guys i am not that advanced, FFT :)
10:12:08 <orbitz> HaskellLove: i mean do you compute a b c d, then computer b c d e, rather than save b c d
10:13:18 <HaskellLove> orbitz, i have generator that gives me n as [1..], right? from that i derive a b and c, what part you dont understand sorry?
10:13:54 <HaskellLove> i might actually do that with tails and take 4
10:14:04 <HaskellLove> will it be faster ?
10:14:06 <orbitz> i'm asking if you recomput b c d the enxt iteration
10:14:12 <orbitz> rather than simply save the values and compute e
10:14:41 <ben0x539> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15258#a15258 oh well, rather silly example anyway
10:15:59 <HaskellLove> for each new n i recompute a,b,c and  haveMoreCommonFactors n a b c
10:17:29 <HaskellLove> ben0x539 sorry, example for what, for FFT? anyways if it was for me, that code is too complex for me i am not there yet :)
10:17:40 <ben0x539> No, sorry, not for you
10:17:50 <ben0x539> Just something I was fiddling around with and could not get to compile to my liking
10:22:31 <orbitz> HaskellLove: maybe you should cache those then
10:22:49 <HaskellLove> I am thinking of possibilities yes, any ideas?
10:23:14 <Confusius> Hi All, a question about...guess what...monads. Normal function application is (f x y z)  but monadic is (z y x f) . In other words, why >== as standard, and not ==> Is there a special reason, or is it just because of IO usage?
10:23:34 <ben0x539> excuse me
10:24:29 <HaskellLove> orbitz i might be able to do: haveMoreCommonFactors n : haveMoreCommonFactors xs for a list of [n,a,b,c] thinking about it now...
10:26:05 <increpare> Confusius: you mean >>= vs  =<< ?
10:26:28 <Confusius> increpare, yes, sorry...
10:26:45 <HaskellLove> orbitz like this, what do you think: f (n:a:b:c) = haveMoreCommonFactors n a b c : haveMoreCommonFactors a b c d where d = c+1
10:27:05 <tromp__> normal function application is the less logical order
10:27:12 <Olathe> Confusius: It might be because >>= looks more like lambda, but I'm not sure.
10:27:14 <increpare> Confusius: it's a matter of convention + convenience, mainly.  There are mathematical formalisms where functions are composed that way -
10:27:21 <CalJohn> :t =<<
10:27:22 <lambdabot> parse error on input `=<<'
10:27:26 <koeien37> :t (=<<)
10:27:27 <CalJohn> :t (=<<)
10:27:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:27:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:27:34 <Olathe> Ahh, the question is about ordering. Never mind.
10:27:37 <koeien37> yeah I think . is quite annoying
10:27:42 <increpare> Confusius: when you think of functions as processes they slot together like that more naturally...you can read them left to right "a then b then c" rather than "a after b after c"
10:27:48 <koeien37> I often use the x ; f notation in my CT notes
10:28:14 <koeien37> instead of f . x
10:28:18 <increpare> koeien37: I mix and match myself.
10:28:28 <increpare> though usually stick to .
10:29:03 <c_wraith> The advantage the current ordering of . has is this:  f(g(h(x))) = (f . g . h) x
10:29:08 <koeien37> maybe function application should also be written (x)f instead of f(x)
10:29:23 <increpare> c_wraith: yeah that's a matter of convention as well though : P
10:29:53 <Olathe> The verb comes before the object in a lot of languages.
10:30:12 <c_wraith> eat(sandwich)
10:30:21 <Confusius> Maybe it's trivial, but it seems strange to have function first for one, and last for the other usage...
10:30:41 <Olathe> Hmm, I think there's fmap or something to get it to go normal order.
10:30:44 <koeien37> Olathe: it's somewhat ambiguous in Dutch and German, if you look at the perfect tense :)
10:30:45 <increpare> Confusius: you mean it's confusing to support both orderings?
10:30:58 <Olathe> Ahh, I don't know much about those languages :)
10:31:21 <CalJohn> tromp__: why is function application the "less logical order"?
10:31:34 <koeien37> but (a.o.) English and Chinese have subject - verb - object order yeah
10:32:30 <paolino> anyone is using hmatrix for solving systems of linear equations ?
10:32:31 <Confusius> increpare, in a sense, the question is, why switch the order...unless there's some deeper reaoson.
10:32:47 <koeien37> we start reading at the left
10:32:58 <koeien37> but in f . g . h , we apply first h
10:33:10 <koeien37> :t (.)
10:33:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:33:28 <koeien37> :t (.) :: (b -> c) -> (a -> b) -> (a -> c)
10:33:29 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:33:37 <koeien37> ^ seems also a strange order from that point of view
10:33:42 <CalJohn> that is a fair point
10:33:57 <CalJohn> is this ; a reverse . ?
10:34:03 <koeien37> yes
10:34:10 <koeien37> (not in Haskell)
10:34:18 <CalJohn> right, yeah, in CT
10:34:24 <koeien37> f ; g means g . f
10:34:59 <Confusius> koeien37 my guess was, in IO it makes sense to have first input parameter first, and maybe they kept it that way for other monads too?
10:35:32 <CalJohn> i don't think the IO Monad was the first monad in haskell
10:35:41 <koeien37> the concept "monad" is older than the usage of IO
10:35:50 <copumpkin> I should hope so
10:35:52 <increpare> koeien37: even in haskell?
10:35:58 <koeien37> increpare: I honestly wouldn't know
10:36:00 <increpare> koeien37: I thought within haskell, IO came first, then it was termed monad
10:36:06 <koeien37> that could be.
10:36:07 <increpare> koeien37: when somebody noted that it was.
10:36:16 <koeien37> i was talking about monads outside of Haskell
10:36:17 <increpare> koeien37: someone else here presented that manner of account.
10:36:26 <CalJohn> copumpkin: well, i don't want to sound authoritive, i'm not :)
10:36:26 <koeien37> increpare: then that might very well be true :)
10:36:26 <tensorpudding> i thought that haskell had a different IO mechanism before they switched to the current one
10:36:27 <increpare> koeien37: oh yeah monads go back about thirty years now
10:36:49 <koeien37> but in CT, monads are often characterized differently
10:36:52 <koeien37> more symmetrical
10:36:59 <tensorpudding> in CT, monads can't fail
10:37:00 <increpare> (monads in category theory (Rather than, say, in calculus, or philosophy) )
10:37:17 <koeien37> I am not aware of the term "monad" in another context? I should google it
10:37:22 <increpare> tensorpudding: in most of mathematics, functions can't fail
10:37:29 <increpare> koeien37: outside of CT and haskell?
10:37:32 <marsh_> Ooh a philosophical monad!
10:37:34 <koeien37> increpare: right
10:37:41 <increpare> koeien37: monads were leibniz's term for infinitesimals.  also philosophical monads.
10:37:45 <tensorpudding> that's a vastly different thing
10:37:51 <koeien37> ah
10:37:58 * copumpkin eats tensorpudding 
10:38:15 <increpare> tensorpudding: right
10:38:25 <jkff> increpare: I didn't know of the meaning in calculus
10:38:37 <increpare> tensorpudding: the term monad was brought back into usage in non-standard analysis
10:38:49 <sproingie> monads were leibniz's "unit of reality"
10:38:52 <tensorpudding> i didn't think they actually used the term monad in non-standard analysis
10:39:04 <Confusius> Doesn't monad originaly just mean one parameter, opposite to more? A monadic function has just one parameter? As in binomial. polynomial.
10:39:16 <watermind> how do I define a new data type in GHCi?
10:39:24 <koeien37> watermind: you don't, use a source file
10:39:24 <increpare> tensorpudding: yeah they do - the non-standard equivalence classes for infinitesimals are called monads.
10:39:29 <watermind> koeien37: argh :S
10:39:34 <jkff> Confusius: That's yet another meaning of the word "monad"
10:39:48 <tensorpudding> how obnoxious
10:39:49 <jkff> To the best of my knowledge, it's used only in the J programming language
10:39:55 <sproingie> appropriately enough, the term "monad" has been overloaded for many categories
10:40:01 <djahandarie> Haha
10:40:02 <koeien37> ...
10:40:21 <koeien37> "regular" is a far worse offender in that respect
10:43:35 <increpare> koeien37: but pales in comparison to 'number' : P
10:48:50 <Confusius> Well, monads seem to be more a general type (m0 of a general type (a) with some restrictions (the monadic laws)
10:49:47 <Confusius> So, a rank 2 polymorphic type? Or is that something else competely?
10:50:10 <copumpkin> not rank-2, just higher-kind
10:50:22 <copumpkin> monads in haskell have kind * -> *
10:50:52 <Confusius> copumpkin, OK, higher kind, but still a type of a type, no?
10:50:59 <copumpkin> meaning that they're effectively a function that takes a type and gives a type
10:54:50 <Confusius> So, what is a rank-2 type? I've heard the term used for Haskell, but I've no idea...
10:56:07 <copumpkin> it's a type that involves polymorphic types
10:56:21 <copumpkin> so for example, if you write f :: a -> Int
10:56:51 <copumpkin> that function means that for all types a, the function exists
10:56:58 <mux> I think rank-2 is when you have a forall that isn't on the left of the type
10:57:07 <mux> like for ST
10:57:08 <copumpkin> that's regular polymorphism
10:57:16 <mux> isn't it?
10:57:16 <copumpkin> rank 2 would be f :: (forall a. a) -> Int
10:57:22 <mux> right
10:57:34 <copumpkin> mux: right, sorry, my "that's regular polymorphism" was my example
10:57:40 <mux> ah, alright
10:57:50 <sproingie> how's f :: a -> Int and f :: (forall a. a) -> Int differ?
10:58:01 <copumpkin> Confusius: what that means is that you want a single concrete type for your function parameter, but that type is polymorphic
10:58:05 <mux> I'm not sure about that example since f cannot be realized
10:58:12 <Stalafin> << i am sorta scared of haskell rite now :-/ it's sooooo much
10:58:24 <Stalafin> oh, and i am only going through learnyouahaskell :D
10:58:26 <copumpkin> sproingie: the first one can be called with any argument of any type
10:58:27 <Confusius> copumpkin, Ah, I get an inkling now, thanks.
10:58:32 <copumpkin> sproingie: the second one can only be called with undefined
10:58:37 <pikhq> Stalafin: Relearning programming is kinda like that, yes. ;)
10:58:45 <copumpkin> maybe a more common case might be
10:58:59 <djahandarie> Stalafin, learn you a haskell does tend to teach concepts way before anything truely concrete in my opinion though
10:59:01 <mux> Stalafin: it's hard for everyone, don't give up :-)
10:59:12 * Stalafin is a fight0r
10:59:14 <Stalafin> :D
10:59:20 <djahandarie> Stalafin, check out Real World Haskell for a slightly different approach
10:59:22 <copumpkin> > let f :: (forall a. a -> a) -> Int; f id = id 5 in f id
10:59:23 <lambdabot>   5
10:59:23 <Stalafin> djahandarie: yeah, concepts; lotsa concepts
10:59:27 <sproingie> i'm working on a more task-centric tutorial myself after giving up on my long rambling one
10:59:29 <djahandarie> Stalafin, both are good though
10:59:29 <copumpkin> sproingie: make sense?
10:59:52 <increpare> copumpkin: why can't "f :: (forall a. a) -> Int " be defined?
11:00:02 <increpare> oh wait you just defined it
11:00:07 <copumpkin> nope
11:00:09 <copumpkin> that's a -> a
11:00:16 <copumpkin> increpare: it can be, but how many values do you know of type forall a. a ?
11:00:25 <copumpkin> _|_ is the only one
11:00:33 <copumpkin> :t error "moo"
11:00:34 <lambdabot> forall a. a
11:00:36 <copumpkin> :t undefined
11:00:37 <lambdabot> forall a. a
11:00:42 <mux> I mentally picture regular polymorphism thinking about the underlying System-F-like core, where in the end you pass both a type an a value; whereas with (forall a. a) it's like a polymorphic type "boxed", you still don't have the type information
11:00:50 <mux> not sure if that makes much sense to anyone else but me
11:00:52 <tensorpudding> what about ()
11:00:55 <increpare> copumpkin: I misread " called with undefined" as "called undefined"
11:01:05 <increpare> copumpkin: gotcha
11:01:05 <copumpkin> f :: (forall a. a -> a) -> Int is a function that can only be passed the "id" function
11:01:17 <tensorpudding> :t ()
11:01:19 <lambdabot> ()
11:01:19 <sproingie> copumpkin: so unlike f :: (a -> a) -> Int, which could take a function like succ or pred, f :: (forall a. a -> a) -> Int can only take functions that would work on all a?
11:01:21 <copumpkin> it looks polymorphic but it actually wants a concrete case of a polymorphic value
11:01:21 <tensorpudding> hmm
11:01:26 <copumpkin> sproingie: yeah
11:01:26 <zygoloid> copumpkin: what about const undefined, and \a -> a `seq` undefined?
11:01:45 <copumpkin> zygoloid: those are a -> b
11:01:51 <sproingie> copumpkin: aha, i get it
11:01:53 <Olathe> f x = f x
11:02:05 <mux> copumpkin: I like this example "f" a lot more, I'll have to remember it for next time I try to explain that kind of things
11:02:14 <zygoloid> copumpkin: they're also forall a. a -> a
11:02:18 <pikhq> :t (\_->undefined) :: (a->a)
11:02:19 <lambdabot> forall a. a -> a
11:02:28 <copumpkin> zygoloid: yeah, that's not the same as forall a. a
11:02:37 <copumpkin> zygoloid: oh, you mean for id
11:02:40 <copumpkin> I see, yeah
11:02:48 <copumpkin> the only interesting value you can pass f is id, let's say :)
11:02:56 <zygoloid> the only total function? :)
11:03:02 <pikhq> Yes.
11:03:10 <sproingie> since the only "forall a. a -> a" is id?
11:03:17 <copumpkin> yep
11:03:28 <zygoloid> no, the only *total* "forall a. a -> a" is id
11:03:37 * copumpkin is an agda user
11:03:43 * copumpkin only cares about total functions
11:03:46 <j4cbo> there are other such functions in haskell :P
11:03:49 <copumpkin> (and I don't like pink)
11:03:49 * elly is a scheme user!
11:03:49 <mux> > let f :: (forall a. a -> a -> a) -> (a,a) -> a; f g = uncurry g in f fst (2,3)
11:03:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a -> a, b)
11:04:23 <copumpkin> :)
11:04:25 <mux> > let f :: (forall a. a -> a -> a) -> (a,a) -> a; f g p = (uncurry g) p in f fst (2,3)
11:04:26 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a -> a, b)
11:04:32 * jmcarthur has an obsession with functionalization lately
11:04:40 <sproingie> forall a. a -> a -> a could be one of two functions
11:04:53 <zygoloid> though actually \a -> a `seq` undefined == const undefined, so there's only two of them
11:04:53 <mux> > let f :: (forall a. a -> a -> a) -> (a,a) -> a; f g p = (uncurry g) p in f const (2,3)
11:04:54 <lambdabot>   2
11:04:57 <mux> sproingie: const or flip const
11:05:05 <sproingie> right
11:05:10 <mux> > let f :: (forall a. a -> a -> a) -> (a,a) -> a; f g p = (uncurry g) p in f (flip const) (2,3)
11:05:11 <lambdabot>   3
11:05:18 <mux> I had stuck an uncurry and forgot to change the fst to const.
11:05:26 <Saizan> jmcarthur: missing a "de" or what is that?:)
11:05:30 <mux> > let f :: (forall a. a -> a -> a) -> (a,a) -> a; f g = uncurry g in f (flip const) (2,3)
11:05:31 <lambdabot>   3
11:05:39 <mux> here
11:06:30 <mux> of course, f is useless here
11:06:31 <jmcarthur> Saizan: i think i pretty much mean church encoding
11:06:37 <mux> it's hard to find an understandable and useful example
11:07:47 <Berengal> f :: (forall a. [a] -> [a]) -> [b] -> [c] -> ([b], [c]) is a somewhat useful example at least
11:08:10 <jmcarthur> i mean things like: newtype Pair a b = Pair (forall c . (a -> b -> c) -> c)
11:08:17 <sproingie> @hoogle (forall a. [a] -> [a]) -> [b] -> [c] -> ([b], [c])
11:08:18 <lambdabot> No results found
11:08:30 <sproingie> what is f?
11:08:31 <Berengal> Not very useful, but not entire useless either...
11:08:38 <jmcarthur> or: newtype Either a b = Either (forall c . (a -> c) -> (b -> c) -> c)
11:09:14 <mux> f g xs ys = zip (g xs) (g ys)
11:09:15 <sproingie> head asplosion imminent
11:09:17 <mux> I guess.
11:09:31 <mux> where g is guaranteed to work on lists of whatever type
11:09:36 <mux> so can be applied to both xs and ys
11:09:37 <Berengal> > let both :: (forall a. [a] -> [a]) -> [b] -> [c] -> ([b], [c]); both f x y = (f x, f y) in (both reverse "hello" [1,2,3], both (take 2) "hello" [1,2,3])
11:09:38 <lambdabot>   (("olleh",[3,2,1]),("he",[1,2]))
11:09:42 <mux> does that make more sense to you?
11:09:47 <sproingie> yah i can see that
11:10:23 <Saizan> jmcarthur: i see
11:10:27 <mux> without the type annotation, GHC would infer that both lists have the same type
11:10:42 <Berengal> > let both f x y = (f x, f y) in (both reverse "hello" [1,2,3], both (take 2) "hello" [1,2,3])
11:10:43 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:10:43 <lambdabot>    arising from the literal `1...
11:10:46 <mux> :t \g xs ys = zip (g xs) (g ys)
11:10:47 <lambdabot> parse error on input `='
11:10:53 <mux> :t \g xs ys -> zip (g xs) (g ys)
11:10:54 <lambdabot> forall t a. (t -> [a]) -> t -> t -> [(a, a)]
11:10:55 <Berengal> Tada!
11:10:59 <ezyang> In a typeclass Foobar e m, what are the e and m called?
11:11:02 <mux> indeed, more or less
11:11:16 <sproingie> ezyang: type variables
11:11:20 <mux> except using zip was wrong in the first place
11:11:24 <Berengal> ezyang: {,type}{parameters,arguments}
11:11:31 <mux> but still, ghc infer the same type for the 3rd anf 4th argument
11:12:12 <Berengal> type variables works too, but I usually reserve that for parametric polymorphism
11:13:06 <Berengal> Higher-ranked types make type-inference undecideable. We solve that problem by not infering them.
11:14:26 <fft> if I want to make State monad instance of MonadPlus. Should both it type parameters be MonadPlus  instances?
11:14:35 <shambler> ++++++++++++++++++++++
11:14:55 <Berengal> fft: No, they should be monoid instances.
11:14:55 <sproingie> sounds like you want Writer
11:15:08 <ezyang> I'm not sure what a MonadPlus instance of State would do...
11:15:26 <sproingie> collect states?
11:15:27 <Berengal> Me neither...
11:15:32 <sproingie> sounds a bit like Writer
11:15:44 <Berengal> State isn't just for collecting, it's for transforming as well
11:15:59 <sproingie> hm true
11:16:34 <Berengal> But it doesn't make much sense for it to be a MonadPlus
11:16:36 <ski> mux : example of what ?
11:16:47 <fft> I need to sum the values within State Monad. And need identity as well
11:16:48 <Berengal> The Writer part does, but not the Reader part
11:17:10 <Berengal> fft: That sounds like a Writer
11:17:28 <sproingie> you can use StateT on something that's already a MonadPlus.
11:17:34 <ezyang> ==sproinge
11:17:38 <ezyang> *sproingie
11:17:39 <Berengal> That's something different
11:17:45 <ezyang> Prolly something like the list monad
11:18:08 <Berengal> @unmtl State s a
11:18:08 <lambdabot> s -> (a, s)
11:18:13 <Berengal> @unmtl Reader s a
11:18:13 <lambdabot> s -> a
11:18:19 <fft> I'm trying to make an exercise from the tutorial. And get lost somewhat
11:18:19 <Berengal> @unmtl Writer s a
11:18:20 <lambdabot> (a, s)
11:18:38 <Berengal> So State = Reader + Writer
11:18:38 <jmcarthur> :t mplus
11:18:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
11:19:19 <ski> @unmtl ReaderT x (Writer x) a
11:19:20 <lambdabot> x -> (a, x)
11:19:25 <sproingie> ooh
11:19:29 <ski> @unmtl WriterT x (Reader x) a
11:19:29 <lambdabot> x -> (a, x)
11:20:44 <fft> Why can't I write something like . mzero = (\state -> (state, []))    ? In this particular case it complains about types that is clear. But first - I cannot use the second type parameter in declaration of MonadPlus instance. How should I declare something like this?
11:21:03 <Berengal> @info MonadPlus
11:21:03 <lambdabot> MonadPlus
11:21:08 <Berengal> ...
11:21:30 <Berengal> MonadPlus only has one type parameter
11:21:37 <Berengal> Of kind * -> *
11:21:37 <ezyang> Hey guys: simple function that fails in two distinct ways.
11:21:43 <ezyang> Any suggestions?
11:21:52 <Berengal> ezyang: fromIntegral
11:22:01 <ezyang> "that I can implement" :-)
11:22:05 <jmcarthur> fft: sounds like you really want Monoid if that's the kind of behavior you want
11:22:05 <matsuura> as an integral a distance?
11:22:11 <matsuura> or relationship>
11:22:13 <matsuura> ? *
11:22:21 <matsuura> s/as/is
11:22:36 <Berengal> ezyang: fails how?
11:22:43 <fft> jmcarthur: I have not learned about them yet in  tutorial. That is strange
11:23:08 <sproingie> > let f x = case x of 1 -> undefined; _ -> fix error in f 1
11:23:09 <lambdabot>   "* Exception: Prelude.undefined
11:23:16 <jmcarthur> fft: then i suspect you are looking for the wrong thing
11:23:27 <ezyang> Berengal: specifically, returns a Left value in the either monad
11:23:38 <sproingie> actually i guess those are both exception, substitute whatever bottom you want
11:23:59 <Berengal> ezyang: So two different lefts?
11:24:28 <ezyang> yep
11:24:40 <ezyang> simplicity of implementation and problem are what I'm optimizing for.
11:25:25 <Berengal> data Failure = SomethingBroken | SomethingNotFixed; foo :: a -> Either Failure a?
11:25:42 <Berengal> Something like that?
11:26:09 <joschu> I have Data.Graph but not Data.Graph.Inductive. How do I get it?
11:26:11 <ezyang> Hah. Unfortunately no; I'm looking for something like "safeHead" (which is obvious and has a really small implementation)
11:26:18 <ezyang> (but has only one failure mode)
11:26:49 <Berengal> Either also has only one failure mode, unless you nest it
11:26:59 <Berengal> But the same goes for Maybe. Either just carries a bit of extra info
11:27:15 <ezyang> failure mode ~ variation of extra info; for this particular case, anyway.
11:28:33 <ezyang> I guess I could lame and write a parser-style function.
11:29:01 <Berengal> How about zip :: [a] -> [b] -> Either String [(a,b)]?
11:29:15 <ezyang> Ah!
11:29:19 <fft> If compiler does not complain about errors when using   mplus . There will be a runtime error if I try to use function with  this operator with not an instance of MonadPlus ?
11:29:20 <ski> where does the string come from ?
11:29:23 <ezyang> and different failures if [a] is too long or [b] is too long?
11:29:28 <Berengal> zip [] (_:_) = Left "First too short"; zip (_:_) [] = Left "First too long"
11:29:35 <ezyang> I like it. Thanks!
11:29:56 * ski doesn't like it
11:30:13 <jmcarthur> fft: i don't understand the question
11:30:16 <dmhouse> ezyang: or maybe just firstPair :: [a] -> [b] -> [(a,b)]
11:30:31 <dmhouse> I.e. \xs ys -> (head xs, head ys)
11:30:41 <sproingie> > Middle "Just right"
11:30:42 <lambdabot>   Not in scope: data constructor `Middle'
11:30:50 <joschu> question: I have Data.Graph but not Data.Graph.Inductive. How do I get it?
11:31:03 <ezyang> dmhouse: That sounds simpler.
11:31:03 <jmcarthur> fft: the compiler shouldn't allow you to use overloaded functions as types that are not instances of the type class
11:31:04 * sproingie goes and whips up a Goldilocks datatype
11:31:20 <ezyang> sproingie: Does it form a monad instance? :-)
11:31:22 <Berengal> Yeah, the problem with zip is that it needs to be strict in the spine of the lists...
11:31:34 <dmhouse> sproingie: heh, I've always been a fan of return "Ask" :: Maybe String to cajole newbies into asking their questions
11:31:34 <sproingie> ezyang: if you fill in two of the three type parameters it does
11:31:45 <Berengal> But it does get to show off the Monad instance if you want
11:32:36 <j4cbo> does Haskell have something like ML's "exn" type? it's essentially a sum type for which new constructors can be declared generatively.
11:33:42 <copumpkin> j4cbo: is that polymorphic variants?
11:33:58 <copumpkin> j4cbo: if so, nope
11:34:13 <joschu> [answered my question, I have to install package fgl]
11:34:50 <ski> copumpkin : it's not a polymorphic variant, it is an open datatype
11:34:54 <jfischoff> Is there a way to make the default constructor of a type assert if it is given invalid input?
11:35:14 <Berengal> jfischoff: No, constructors are dumb.
11:35:17 <j4cbo> what constitutes "invalid"?
11:35:21 <jmcarthur> jfischoff: no, but you can not export the constructor and export a function instead that does the validation
11:35:43 <jmcarthur> jfischoff: look up "smart constructors" for more info on that
11:35:52 <jfischoff> cool, thats what I thought. I am try to make sure that my NormalVector class is actually normal
11:36:04 <jfischoff> thanks guys
11:36:05 <Berengal> The trouble with not exporting constructors is that you can't pattern match on them...
11:36:25 <copumpkin> view patterns!
11:36:26 <jmcarthur> jfischoff: if your constructor is normally Foo :: a -> Bar, you could instead export foo :: a -> Maybe Bar
11:36:30 <ski> @wiki Smart constructors
11:36:30 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
11:36:45 <jmcarthur> view patterns are nice
11:36:56 <jfischoff> jmcarthur: not a bad idea
11:36:57 <Berengal> copumpkin: They help, but they're still a bit heavy on the syntax compared to regular pattern matching
11:37:12 <jfischoff> jmcarthur: on wiki now, thanks again
11:37:17 <jmcarthur> np
11:37:21 <ski> jmcarthur : itym `foo :: Bar -> Maybe a'
11:37:30 * increpare thinks that smart constructors are a litttle hacky (but they get the job done)
11:37:36 <copumpkin> yep
11:38:08 <monochrom> it just means abstraction
11:38:16 <jmcarthur> ski: no, i don't
11:38:18 <monochrom> Abstraction is bliss.
11:38:19 <Berengal> You could also write explicit destructors if you wanted
11:38:25 <ski> O'Caml has something where you can export constructors, but they can only be used for matching, not for constructing
11:38:32 <increpare> Berengal: destructors?
11:38:35 <sproingie> that would be nice
11:38:37 <jmcarthur> ski: that would be a view function. i was demonstrating the constructor
11:38:37 <ezyang> Berengal: What would explicit destructors in a pure context due?
11:38:43 <ezyang> *do
11:38:50 <Berengal> ezyang: pattern match for you
11:38:53 <ski> jmcarthur : sorry, i was thinking on a matcher, yes
11:38:55 <monochrom> head and tail are destructors
11:39:02 <Berengal> For example
11:39:03 <ben0x539> I thought they were deconstructors
11:39:16 <ezyang> nyeh. "Accessor"
11:39:18 <Berengal> destruct :: b -> (a -> [a] -> b) -> [a] -> b
11:39:23 <monochrom> We don't avoid clash with C++ terminology.
11:39:33 <ezyang> :t destruct
11:39:35 <lambdabot> Not in scope: `destruct'
11:39:41 <increpare> Berengal: gotcha now
11:40:02 <increpare> splitting things back up into their component parts, rather than 'deleting' them
11:40:06 <increpare> ?
11:40:09 <Berengal> Yep
11:40:51 <increpare> Berengal: cool
11:41:00 <Berengal> They can sometimes be nicer to work with than regular pattern matching
11:41:13 <Berengal> Especially if they're a bit smart, like foldr
11:41:26 <jmcarthur> yeah i'm a big fan of folds and unfolds
11:41:54 * increpare quietly stifles a non-witty euphemism 
11:41:58 <jmcarthur> which is a part of my aforementioned recent obsession with church encodings, i think
11:42:30 <Berengal> Even the simple maybe and either destructors are nicer than pattern matching in some circumstances. You can't write point-free patterns
11:42:33 * shapr runs "for x in `cabal list|grep '*'|cut -d ' ' -f 2`; do cabal install $x; done;"
11:42:59 <jmcarthur> shapr: grep '*'?
11:43:04 <sproingie> that gives me an idea
11:43:06 <sproingie> acme-everything
11:43:07 <increpare> Berengal: how is maybe a destructor?
11:43:13 <Berengal> @type maybe
11:43:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:43:21 <jmcarthur> increpare: maybe is a fold! :)
11:43:38 <monochrom> The HOL theorem prover also use "destructor" for splitting, e.g., mk_abs makes a lambda term, dest_abs splits a lambda term back to the dummy var and the body.
11:43:51 <Berengal> increpare: It takes one value for each constructor, and delegates based on the actual constructor present
11:44:05 <monochrom> And both are pure functions.
11:44:07 * ski would rather call `foldr' a consumer, than a destructor
11:44:18 <ski> (though `fst' would be a destructor)
11:44:28 <j4cbo> combinator
11:44:40 <increpare> Berengal: ah right - I had forgotten what maybe looked like
11:45:39 <Berengal> I'm more inclined to call fst, head etc. selectors...
11:45:53 <Berengal> Terminology... bah
11:45:58 <ski> Berengal : sometimes, i'd like to be able to define `f . Foo = g . h'
11:46:39 <ski> Berengal : what do you call functions which return record expressions, then ?
11:46:45 <monochrom> The nice thing about meaningful names is that there are so many meanings to choose from.
11:46:58 <Berengal> ski: updaters?
11:47:10 <ski> (instead of `f (Foo x) = (g . h) x', i mean)
11:47:29 <Berengal> That makes some sense
11:47:32 <sizur> nice, we gained about chennel nicks in a year and a half
11:47:33 <ski> what is updated ?
11:47:38 <sizur> eh 150
11:47:40 <Berengal> The record value
11:47:42 <increpare> consumer/destructor/constructor/updaters...all very imperatively-charged words...
11:48:18 <ski> increpare : "updater", possibly. i'm not sure about the rest
11:48:35 <Berengal> ski: Unless I've misunderstood you. You mean `f x r = r{x=x}', right?
11:48:37 <monochrom> Do people receive haskell books or even haskell compilers for christmas gifts and therefore new people come to #haskell right after christmas? :)
11:48:52 <increpare> Sometimes I wonder what happens in memory when I type a = b{whatever=newvalue} .  Is there anywhere that I can go to get a better picture of these things?
11:48:53 <ezyang> hehe
11:48:55 <ski> Berengal : you have indeed misunderstood me (i was unclear, i think) :)
11:49:20 <ski> Berengal : i mean `f x y = Foo { blah = ... , bleh = ... }'
11:49:41 <Berengal> ski: Isn't that just a smart constructor?
11:49:44 <dolio> Inductive types are constructed out of constructors.
11:49:45 <sproingie> if it can prove b is used nowhere else it quite likely mutates b in-place
11:49:54 <increpare> little girl: "LOOK DADY SANTA LEFT ME A MONAD IN MY STOCKING"
11:49:59 <dolio> That isn't particularly imperative.
11:50:03 <sproingie> but i also wouldn't mind knowing the nitty gritty of record update
11:50:25 <Berengal> sproingie: It doesn't, but it will garbage collect the old value pretty soon
11:50:48 <j4cbo> it doesn't? really?
11:50:51 <sproingie> Berengal: so if i have a huge record, there's the overhead of copy every update?
11:50:59 <Berengal> Also, it only allocates a new constructor. The values inside it will still be pointers to the old values (except the new one)
11:51:09 <sproingie> i guess if i need a lot of updates i can have a record of IORefs
11:51:10 <increpare> sproingie: presumably it only has to copy the thunk if the value's not being evaluated every update?
11:51:18 <Berengal> sproingie: You don't have huge records. At least I hope not. Still, even 20 fields would just be 20 pointers
11:51:27 <monochrom> increpare: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html and then pick one of the first two links
11:51:37 <increpare> monochrom: much obliged : )
11:52:02 <increpare> Berengal: but you can have biggish trees, say, that contain lots of records...and sometimes one might want to update just one of those records...
11:52:13 <increpare> or rather, I do...
11:52:27 <ski> Berengal : the point being that for variant types, `Just' is a constructor, `maybe' might be called a consumer; while for record types, `fst' is a destructor, so what is things like `f' above called ?
11:52:36 <increpare> monochrom: I just started reading the first of those last week : )
11:52:38 * ski was suggesting "(direct) producer"
11:52:57 <ski> (where `maybe' is a direct consumer)
11:53:11 <Berengal> increpare: If you want to update just one value in a tree, it still has to copy the path of the tree from the root to the new value
11:53:40 <sproingie> sounds like a good argument for localizing updates as much as possible
11:53:57 <Berengal> ski: I suggest "function". I'm already starting to feel like we're going overboard with terminology. Such things only leads to confusion and cargo cults down the line.
11:54:18 <mk64ftw> ls
11:54:20 <monochrom> The nice thing about meaningful names is that there are so many meanings to choose from.
11:54:22 <mk64ftw> oops
11:54:30 <ski> Berengal : i was seeking a more specific term than "function" :) .. plain `sin' is a function
11:54:42 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=47 I cant beleive it, 2^2 is cosidered different factor then 2 that confuses me, do you understand why is that so?
11:55:24 <ezyang> Where does the monad instance for Either a live, again?
11:55:36 <sproingie> it says distinct prime factors, so i suspect they're not considered different
11:55:44 <ski> Berengal : one point is that i think it could be nice to define functions like
11:55:45 <increpare> HaskellLove: in terms of distinct prime factors, it means that 4 only has 2 as a prime factor, 2 only has 2 as a prime factor, 644 only has 2, 7, and 23 as prime factors.
11:55:53 <monochrom> Control.Monad.Instances or Control.Monad.Error. It has an extra condition.
11:56:05 <Berengal> ski: producer could work, but the producer/consumer terms are mostly used for the lazy producers/strict consumers thingamabob, no?
11:56:17 <ezyang> monochrom: Is Either String a monad, in those cases?
11:56:19 <ski>   from :: Num a => a -> Stream a
11:56:20 <increpare> HaskellLove: it's more saying that you can ignore the (^2) than saying that 2^2 is different to 2.
11:56:23 <ski>   Head (from a) = a
11:56:24 <ski>   Tail (from a) = from (a+1)
11:56:27 <ski> instead of as
11:56:28 <monochrom> Yes, String satisfies the extra condition.
11:56:38 <ski>   from a = MkStream
11:56:44 <ski>     { head = a
11:56:52 <ski>       tail = from (a+1)
11:56:52 <ezyang> Ok. Where is the instance of String for that condition? (I'm under the impression that the extra condition is that the error type is of the Error class)
11:56:55 <ski>     }
11:57:20 <monochrom> You are right. Now I just have to find it.
11:57:28 <ski> Berengal : this would be for a datatype `codata Stream a = Head :: a  &  Tail :: Stream a'
11:58:06 <Berengal> ski: That could be nice indeed.
11:58:14 <HaskellLove> increpare oh, i thought it asks for, the four consecutive numbers to have 16 distinct factors
11:58:19 <ski> Berengal : so `from' here is a "message-dispatching" function (called a "constructor" in OO terminology) .. but i can't use "constructor" in haskell, that would be confusing
11:58:20 <monochrom> Control.Monad.Error should have it.
11:59:05 <ezyang> I'm looking at it right now, but I don't see how String fulfills the Error condition; that's not in the source file
11:59:21 <monochrom> Oh, then Control.Monad.Error.Class
11:59:32 <ezyang> Ah, savvy!
11:59:39 <dolio> ski: Have you ever considered extending that syntax to product-of-sums (since inductive has a nice sum-of-products form)?
11:59:58 <monochrom> Control.Monad.Error re-exports Control.Monad.Error.Class so I just go with Control.Monad.Error.
12:00:03 <ski> dolio : not really. i'm not sure how it would work
12:00:16 <dolio> Yeah, I haven't come up with anything good, either.
12:00:28 <ezyang> right-o
12:01:01 <ski> dolio : the "products" in "sum-of-products" come from currying, so i suppose "sums" in "product-of-sums" would come from cocurrying, maybe ?
12:01:23 <Berengal> cocurrying?
12:01:30 <ski> the dual of currying
12:01:32 <copumpkin> rrying
12:01:35 <copumpkin> oh wati
12:01:37 <dolio> Hmmm. I guess that'd spell a problem, then.
12:02:02 <Berengal> As in uncurrying?
12:02:03 <dolio> Since I don't think typical functional languages are cocartesian closed.
12:02:31 <dolio> At least, with the exponential being the same as the coexponential.
12:02:54 <ben0x539> Why am I not allowed to do type family instances like instance A (B c) where type D = c? :(
12:02:54 <copumpkin> how does a coexponential work?
12:02:56 <monochrom> Welcome to #haskell, where wild mathematical imaginations become computing reality.
12:03:21 <Berengal> @quote bizarro
12:03:22 <lambdabot> thoughtpolice says: i believe #haskell established at one point or another that prefixing co- to things makes them exist in the bizarro-world
12:03:26 * hackagebot upload: hexpat 0.11 - wrapper for expat, the fast XML parser (StephenBlackheath)
12:03:31 <Heffalump> Berengal: what does it complain about?
12:03:44 <Heffalump> s/Berengal/ben0x539/ # sorry
12:03:46 <ski>       (1 + a + b0 (*) b1) -> o
12:03:50 <ski>   ~=  (1 -> o) * (a -> o) * (b0 (*) b1 -> o)
12:03:52 <ski>   ~=  o * (a -> o) * (b0 -> b1 -> o)
12:03:55 <ben0x539> 'c' is not in scope
12:04:26 <ski> dolio : well, obviously the coexponential should *not* be the same as the exponential ! :)
12:04:28 * hackagebot upload: hexpat-pickle 0.4 - XML picklers based on hexpat, source-code-similar to those of the HXT package (StephenBlackheath)
12:04:38 * pikhq shall get to work on a coprogramming colanguage for coTuring comachines.
12:04:51 <dolio> copumpkin: You make an exponential in the opposite category, and then figure out what it is in the category.
12:04:59 <copumpkin> fine :P
12:05:02 <Berengal> pikhq: s/work/cowork/
12:05:10 <Saizan> ben0x539: can you paste the code on hpaste?
12:05:22 <shapr> jmcarthur, grep for '*' to find the packages, and quote it so zsh won't try to match the files in this directory.
12:05:28 <ben0x539> Saizan: I shall
12:05:33 <dolio> ski: I don't know. They could be the same thing.
12:05:39 <dolio> Like a photon is its own anti-particle.
12:05:49 <ski> dolio : that would be very strange, i think
12:05:52 <koeien37> what a strange analogy
12:06:02 <dolio> ski: Probably.
12:06:02 <pikhq> coBerengal: s/pikhq/copikhq/
12:06:15 <koeien37> @quote category of bad
12:06:15 <lambdabot> No quotes for this person. Do you think like you type?
12:06:31 * Berengal wonders if someone has invented coduality yet
12:06:43 <ski>       s -> (0 * a * b0 (+) b1)
12:06:46 <ski>   ~=  (s -> 0) * (s -> a) * (s -> b0 (+) b1)
12:06:47 <ski>   ~=  Not s * (s -> a) * ((s >- b0) -> b1)
12:06:54 <dolio> I don't have any go-to examples of coexponentials, so I don't know.
12:07:04 <ski> (that last step would include cocurrying)
12:07:08 <dolio> Except that exponentials are coexponentials in opposite categories. :)
12:07:25 <ski> (where `s >- b0' is a coexponential of `s' and `b0')
12:07:29 <ben0x539> Saizan: ... as usual, trying to actually produce a testcase seems to have shooed away the problem to hide elsewhere in my code.
12:07:56 <monochrom> My coworker makes me do more work.
12:08:12 <monochrom> Heh, I am a worker, and my boss is my co-worker.
12:08:22 <ski> (basically, a value of type `s >- b0' is the "opposite" of a function of type `s >- b0', i.e. a call to such a function. so the value includes one value of type `s' and one continuation accepting values of type `b0')
12:08:34 <monochrom> I solve his problems and he problems my solutions. :)
12:08:44 <ski> monochrom : maybe you're coroutines to each other ? :)
12:08:45 <Heffalump> ben0x539: oh, you have to actually list the arguments to D, that's the problem
12:08:52 <monochrom> Yeah!
12:09:10 <ben0x539> Heffalump: Apparently, thank you :)
12:09:25 <ski> monochrom : each one of you do work the other called for, and each one produces work for the other ! ;)
12:09:46 <ben0x539> This co- thing is both increasingly amusing and mystifying as to what it actually means
12:09:50 <monochrom> We also need a definition for co-troll. They feed the troll.
12:10:00 <ski> hehe
12:10:31 * hackagebot upload: hmatrix 0.8.1.1 - Linear algebra and numerical computations (AlbertoRuiz)
12:10:33 <increpare> heh
12:11:09 * increpare still uses the term linear form in preference to covector.
12:12:06 <ski> increpare : what do you call the coproduct of two groups ?
12:12:24 <elly> is this a joke setup?
12:12:26 <increpare> ski: a group?
12:12:35 <increpare> it sounds like a joke...
12:13:51 * increpare waiting for punchline...
12:14:00 <elly> same :P
12:14:06 <j4cbo> so, a monad, a functor, and a zygohistomorphic prepromorphism walk into a bar...
12:14:17 <elly> j4cbo: the aristocrats!
12:14:59 <ski> increpare : .. well, not really. i was just wondering whether you preferred "free product" or "direct sum" terminology
12:15:12 <j4cbo> elly: :P
12:15:14 <increpare> ski: dont they have different meanings?
12:15:18 <ski> nope
12:15:37 <monochrom> I prefer direct sum because it agress more with coproduct.
12:15:39 <sproingie> i'm still waiting for codependent types
12:15:53 <increpare> ski: I think I grew up on free products
12:16:19 <koeien37> the coproduct of two groups is the free product
12:16:21 <ski> sproingie : me too :/
12:16:24 <ben0x539> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15258#a15269 is my terrible attempt to play with type families, fwiw
12:16:45 <monochrom> codependent type example: {x::integer | x<y} -> (y::integer)  The parameter type depends on the result type!
12:17:31 <monochrom> @remember increpare I think I grew up on free products
12:17:31 <lambdabot> I will remember.
12:17:51 <ski> monochrom : so you're only allowed to call that function with an integer less than what it will return ?
12:17:58 <koeien37> @quote endofunctor
12:17:58 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
12:18:00 <monochrom> Yeah
12:18:07 <increpare> ski: are you sure they're the same in all cases? wiki links them but doesn't say they're equivalent
12:18:08 <ski> how would you know that, beforehand ? :)
12:18:35 <monochrom> I am not sure. Wild mathematical imagination. Someone will make it a computing reality.
12:19:20 <increpare1> oops i fell offline there...
12:19:50 <Berengal> That example could be expressed as a dependent sum
12:19:57 <ski> increpare1 : hm, .. maybe they're not the same in all categories (where they are meaningful)
12:20:15 <sproingie> when you execute it and it fails, you travel back in time and issue a compile error
12:21:02 <ski> sproingie : yay !, continuations
12:21:14 <Berengal> {x::integer} -> { y::integer | x<y}
12:22:24 <Cale> If you have a category C which is cocartesian closed, then it means for any objects X and Y, you have an object [Y,X] with the property that C(Z,[Y,X]) ~= C(Z+Y,X) ~= C(Z,X) x C(Y,X). If you take Z = 0 (the initial object), since the cardinality of C(0,[Y,X]) and C(0,X) will of course be 1 you get that C(Y,X) must have cardinality 1 as well.
12:22:47 <c_wraith> Ok, someone needs to make a functional version of this:  http://c-jump.com/
12:22:55 <Cale> So the only categories which are cocartesian closed are those for which any two objects have exactly one arrow between them.
12:23:10 <ski> Cale : hi Cale. maybe you can clarify the difference (if any) between direct sum and free product ?
12:23:12 <increpare1> Cale: do cocartesian closed categories have to have an initial object?
12:23:26 <increpare1> oh yes they do
12:23:34 <increpare1> part of the definition
12:23:52 <Cale> ski: Of groups?
12:24:09 <ski> or modules, or abelian groups, &c.
12:25:16 <EvanCarroll> I think it would be good if there was a haskell-math channel
12:25:55 <Cale> ski: Well, the free product of groups is the real categorical sum.
12:25:58 <ski> increpare : i'm not sure that's part of that definition. it could be an afterstatment
12:25:58 * copumpkin timidly advances the term "algebraic theory"
12:26:28 <copumpkin> EvanCarroll: #haskell-in-depth is sort of that
12:26:31 <EvanCarroll> it is to bad it is impossible to quanity the cost of math-intimidation from the conversations in this channel
12:26:34 <ski> Cale : of a finite family of groups, or of an arbitrary family of groups as well ?
12:26:43 <increpare1> ski: it\s part of the definition of CCC on wiki
12:26:48 <ski> ok
12:26:55 <Cale> EvanCarroll: we're typically willing to explain things
12:26:55 <copumpkin> EvanCarroll: yeah :/
12:27:08 <increpare1> (or rather terminal object is part of the definition of CCC, so you\d figure intiial object is part of the definition of CCCC)
12:27:15 <aavogt> EvanCarroll: on the other hand it makes it look like the people in here know something
12:27:16 <copumpkin> Cale: many people might not even know what to ask if the most math they've seen is high school calculus
12:27:33 <ski> (copumpkin : "algebraic theory" as term for what ?)
12:27:38 <Cale> ski: Well, I haven't considered arbitrary free products before, but I think it should work
12:27:41 <EvanCarroll> just stating a /fact/ I have no idea what you're talking about but am passionate about haskell, from a math-idiot (compairitve) perspective half of the scare-factor is the off topic conversations in this channel
12:27:47 <copumpkin> ski: the list of things in your &c., I thought
12:28:01 <Berengal> copumpkin: Even so, it's not always adviced to go teach them math just because they didn't ask for it.
12:28:12 <copumpkin> Berengal: yeah
12:28:31 <EvanCarroll> Lets talk about rnl otrizki's 19th proof for the theoruium of conversational complexiods
12:28:46 <monochrom> There is no problem with not understanding a significant amount of traffic in a channel. Why would anyone will everything he doesn't understand to go to a channel he does not join?
12:28:46 * EvanCarroll head explodes.
12:28:47 <copumpkin> EvanCarroll: his 19th proof isn't a very good place to start
12:29:21 <Cale> The direct sum of a family of groups is a subset of the product where each element has contributions from only finitely many of the factors.
12:29:24 <sproingie> i'm a math idiot, but i deal
12:29:31 <copumpkin> ski: but I'm a math idiot too :)
12:29:55 <increpare1> Cale: ah right the difference between free sums is when you get to infinite dimensions innit?
12:29:56 <sproingie> this is one of the few channels that don't look down on me for being a novice
12:29:57 <monochrom> I for one do not understand a bit of it when this channel talks about cabal, or happs, or type families... Do I will those to go to some other channels, leaving #haskell for exactly what I understand?
12:30:03 <EvanCarroll> the problem is 90% of the people interested in this channel are for the language and 90% of the topics in this channel that are scarry are the needless off-topic math conversations. I'm all about off-topic conversations so I'm not going to throw stones at you math geeks
12:30:07 <increpare1> oops ignore that actually
12:30:14 <Cale> oh, for *Abelian* groups the free product and direct sum coincide
12:30:17 <copumpkin> EvanCarroll: I wouldn't say 90% of the topics
12:30:33 <fft> Is there any step-by-step debugger for haskell ?
12:30:39 <Cale> increpare1: yeah
12:30:41 <increpare1> fft: ish - if you use ghci
12:30:44 <sproingie> ghci has a debugger
12:30:45 <EvanCarroll> I'm just saying the reputation and stereo type that haskell is for math-martians is harder to shake after seeing it for a month myself.
12:30:47 <copumpkin> EvanCarroll: occasionally people get into deep math talks and it can get quite daunting for non-mathy people, but most of the talk in here is either newbie help or golfing
12:30:50 <ski> copumpkin : what about that list ?
12:31:06 <ski> (copumpkin : don't tell anyone, but so am i (mostly) :)
12:31:08 <increpare1> fft: you can set a breakpoint or break when an error is thrown and step back
12:31:11 <holmak> fft: the way to go is to test your functions individually, to make sure each part behaves corrently
12:31:22 <monochrom> Not math-martians. English-martians. You see, Chinese is the more human language.
12:31:25 <sproingie> the haskell community is heavily represented by mathy people.  that's just how it is.
12:31:29 <holmak> *correctly. That's what ghci is good for.
12:31:39 <Cale> I'm uncomfortable around modules, but I believe that modules, being Abelian groups with some additional structure, should be similar.
12:31:41 <fft> holmak: I need test 1 function  for now
12:31:53 <copumpkin> ski: oh, well I thought you were listing those algebraic structures for which "free" makes sense, and I understand those to be called theories :)
12:31:53 <sproingie> someday i'll learn what an Abelian group is
12:32:02 <copumpkin> sproingie: a group that is commutative
12:32:16 <Cale> sproingie: Do you know what a group is?
12:32:20 <fft> increpare1: there is no error. Function works incorrectly
12:32:20 <monochrom> FWIW complain about how this channel is US-biased first, e.g., "math" vs maths, "color" vs colour.
12:32:22 <sproingie> Cale: not really
12:32:47 <sproingie> "In mathematics, a group is an algebraic structure consisting of a set together with an operation that combines any two of its elements to form a third element"
12:32:47 <increpare1> fft: then you can set a breakpoint and step back
12:32:51 <sproingie> ok that sounds easy enough
12:32:56 <sproingie> presumably all monoids are groups
12:32:58 <copumpkin> sproingie: well, that's a magma :)
12:33:02 <Hunner> monochrom: You're one to complain about colour :)
12:33:03 <copumpkin> sproingie: vice versa
12:33:06 <Cale> A group is a set G together with a binary operation, usually called multiplication, such that:
12:33:07 <increpare1> fft: cf http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
12:33:07 <Cale>  1) multiplication is associative: a*(b*c) = (a*b)*c for any a,b,c in G
12:33:12 <sproingie> gah
12:33:16 <fft> increpare1: ths
12:33:24 <Cale>  2) There is an identity element 1 in G such that 1*a = a = a*1 for any a in G.
12:33:33 <increpare1> Cale: no a group is a category with only one object and where all morphisms are isomorphisms : P
12:33:37 <ski> Cale : i got confused with what you were saying re direct sum and free product, there ..
12:33:39 <copumpkin> sproingie: all groups are monoids, but some monoids aren't groups. Groups are monoids that have an inverse
12:33:43 <Cale>  3) For any a in G, there is some b in G for which a*b = b*a = 1.
12:33:51 <increpare1> (jk)
12:34:03 <Berengal> Cale: So monoids with an inverse?
12:34:05 <copumpkin> ski: http://ncatlab.org/nlab/show/algebraic+theory
12:34:07 <Cale> Berengal: yep
12:34:21 * Berengal gained +1 learnings
12:34:32 <Cale> Note that in a general group, it need not be the case that a*b = b*a for all a and b
12:34:34 <copumpkin> we need a math trophy system as well as a haskell trophy system
12:34:35 <increpare1> there must be a way of characterizing groups in terms of monads ... can\t think off-hand
12:34:40 <sproingie> so it's a monoid with that one extra rule?
12:34:45 <Cale> sproingie: yes
12:34:49 <copumpkin> increpare1: read that page I just linked to
12:34:58 <sproingie> cool.  math is easy :)
12:35:11 <Cale> An Abelian group is a group which is also commutative: a*b = b*a for any a and b
12:35:28 <ski> copumpkin : oh .. afaiac, `free' makes sense in every case you have an underlying functor (which is sortof not that well-defined, though)
12:35:49 <Hunner> Whats it called when you have a set and an operator that you can derive more of the set, like ([0,1] +) gets you all integers?
12:35:57 <monochrom> generate
12:36:19 <Cale> 1 is a generator for the abelian group of integers ;)
12:36:31 <increpare1> copumpkin:  I mean how to define groups in general in terms of monads with particular properties rather than make a monad from a group in a particular case.
12:36:47 <increpare1> Cale: under addition! : P
12:36:52 <copumpkin> ski: yeah, apparently in universal algebra an "algebraic theory" is a structure whose laws are all equational, so things like fields and vector spaces are excluded (because there's a predicate saying that inversion of the additive identity doesn't exist), and those are precisely the things that don't have free constructions
12:36:53 <Cale> Indeed, yes
12:36:55 <sproingie> once i get down to simple rules like that, abstract math clicks easy with me
12:37:05 <sproingie> it's calculus that i still fear
12:37:15 <sproingie> heck i fear plain ol trig
12:37:18 <volvic> can anyone see why this function definition is incompatible whit the preceding type defnition?
12:37:20 <Cale> sproingie: Have I recommended Spivak's text to you?
12:37:22 <copumpkin> increpare1: well monads can describe algebraic structures in general, but I can't say I understand exactly what you're asking :)
12:37:28 <volvic> drop' :: Integral b => b -> [a] -> [a]
12:37:28 <volvic> drop' (n+1) (_:xs)  = drop n xs
12:37:30 <ski> copumpkin : "trophy" ?
12:37:34 <sproingie> Cale: nope
12:37:39 <sproingie> Cale: got a url?
12:38:02 <copumpkin> ski: like achievements on the xbox :) "You have gained the 'Master Archer (Control.Arrow)' achievement. Congratulations!"
12:38:04 <Cale> sproingie: Michael Spivak's "Calculus" (not the same as "Calculus on Manifolds" by the same author) is a really good introduction to mathematics and analysis through basic Calculus :)
12:38:14 <copumpkin> ski: "You are now a level 3 category theorist!"
12:38:17 <copumpkin> ;)
12:38:28 <increpare1> copumpkin: how to find out when a particular monad is just a monad associated to a group
12:38:37 <doserj> volvic: did you mean to call drop' or drop in the recursion?
12:38:37 <ski> copumpkin : i insist on s/theorist/terrorist" !
12:38:39 <Cale> It's a physical book -- I managed to find a scan of an old edition online.
12:38:42 <copumpkin> :P
12:38:42 <sproingie> Cale: out of print :(
12:38:47 <mokus> "calculus on manifolds" was ridiculously dense if it's the one i'm thinking of
12:38:47 <Cale> Out of print?
12:38:52 <doserj> volvic: drop is a prelude function that requires an Int argument
12:38:57 <Cale> Nah, look for another publisher
12:39:08 <volvic> doserj: d'oh!
12:39:10 <sproingie> lots of sellers tho
12:39:13 <copumpkin> volvic: n+k patterns are going out of style, by the way
12:39:19 <roboshibby> xbox games have dot notation in them?
12:39:42 <volvic> copumpkin: what's recommended as a replacement?
12:39:44 <Cale> I somehow really doubt that it would have gone completely out of print. Lots of universities use it as their first year Calculus text.
12:39:48 <mercury^> Cale: how does Spivak compare to Rudin?
12:39:56 <copumpkin> volvic: manually subtracting, or using peano naturals ;)
12:40:04 <sproingie> Cale: any opinions on Hitchhikers Guide to Calculus?  (also by Spivak)
12:40:08 <volvic> hehe
12:40:28 <copumpkin> Mu Maybe is clearly the answer
12:40:28 <increpare1> mercury^: spivak generally gets more respect
12:40:29 <Cale> mercury^: More toward the beginner end of the spectrum. You can start into Spivak with almost no background, if you have enough willpower.
12:40:46 <sproingie> i remember Spivak for his pronouns.  MOO (specifically LambdaCore) had that as an option for object gender
12:40:50 <Cale> But it will generally be quite challenging that way :)
12:41:53 <mercury^> I never bought any introductory books. Wondering if I should buy some just to have as reference.
12:42:24 <sproingie> oh hitchhikers guide to calculus is 122 pages.  more a nutshell book.
12:42:31 <sproingie> maybe i should get both
12:42:36 <Cale> Spivak has a new 4th edition out
12:43:03 <volvic> mercury^: it's been a while, but as far as i remember, Rudin is more of an introductory text
12:43:26 <mercury^> Principles of Mathematical Analysis sounds like one.
12:43:41 <Cale> There's more than one book by Rudin ;)
12:43:57 <mercury^> And a lot more articles yet.
12:44:39 <HaskellLove> optimizations? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15272#a15272
12:44:45 <mercury^> I see his FA book being cited a lot.
12:44:46 <volvic> i assume we're talking about PoMA
12:45:00 <HaskellLove> euler 47
12:47:34 <copumpkin> HaskellLove: not optimization, but:
12:47:35 <copumpkin> hasFourDistinctFactors x = elem 4 (map length $ group x)
12:47:47 <copumpkin> hasFourDistinctFactors = elem 4 . map length . group
12:48:04 <orbitz> copumpkin! it's you!
12:48:09 * copumpkin hides
12:48:25 <copumpkin> @pl hasFourDistinctFactors x = elem 4 (map length $ group x)
12:48:25 <lambdabot> hasFourDistinctFactors = elem 4 . map length . group
12:48:31 <copumpkin> orbitz: wazzup?
12:48:49 <Cale> whaaat
12:48:57 <orbitz> hai
12:49:26 <copumpkin> Cale: thaaat
12:49:29 <Cale> After you group the factors, you want to count the groups
12:49:35 <Cale> Not the exponents
12:51:24 <HaskellLove> oops
12:52:58 <mercury^> Other parts of the program seem illogical to me too.
12:53:40 <HaskellLove> hasFourDistinctFactors x = (length $ group x) == 4 DONE ok i will compile now
12:53:48 <HaskellLove> thank you
12:54:52 <HaskellLove> actually >= will be better then ==
12:55:27 <aavogt> @pl hasFourDistinctFactors x = (length $ group x) == 4
12:55:28 <lambdabot> hasFourDistinctFactors = (4 ==) . length . group
12:56:02 <aavogt> > compare "hasFourDistinctFactors" "(4 ==) . length . group"
12:56:03 <lambdabot>   GT
12:56:13 <aavogt> > comparing length "hasFourDistinctFactors" "(4 ==) . length . group"
12:56:14 <lambdabot>   LT
12:56:33 <mercury^> @pl \f c a -> f a (c a)
12:56:33 <lambdabot> ap
12:56:55 <aavogt> > comparing length "hasFourDistinctFactors" "(4==).length.group"
12:56:56 <lambdabot>   GT
12:57:01 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15273#a15273 -- here's what I wrote
12:59:39 <HaskellLove> Cale it finishes in seconds? mine is taking its time
12:59:56 <Cale> about 13 seconds here
13:00:35 <HaskellLove> wow
13:02:50 <jmcarthur> optimizations?
13:03:00 <Cale> I compiled with -O2
13:03:28 <HaskellLove> yeah O2 here too but it is going for minutes still
13:03:34 <HaskellLove> might get to hour
13:03:41 <Cale> HaskellLove: Are you sure that you got the condition right?
13:03:44 <mercury^> > let (%) = ap
13:03:45 <HaskellLove> hey just finished actually
13:03:46 <lambdabot>   not an expression: `let (%) = ap'
13:03:56 <HaskellLove> that was like 15 minutes
13:04:02 <Cale> What was the answer?
13:04:06 <HaskellLove> 134042
13:04:16 <Cale> off by one, by my account
13:04:17 <sproingie> 42!
13:04:23 <HaskellLove> but that is index wait
13:04:23 <mercury^> @def (%) = (<$>)
13:04:24 <lambdabot> Maybe you meant: bf do let
13:04:34 <Cale> Oh, you're still using indexing?
13:04:50 * Cale takes (!!) away from HaskellLove 
13:04:59 <sproingie> yah you need to forget !! exists
13:05:05 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15274#a15274 could not do it without !!
13:05:09 <sproingie> until such time as you start using Data.Array
13:05:41 <jmcarthur> !!
13:05:51 <sproingie> !!!!1
13:06:09 <Cale> HaskellLove: you're doing it the slow way. Pair each number with its number of distinct prime factors *first*, and only then do the map (take 4) . tails
13:06:11 <jmcarthur> we shouldn'
13:06:13 <jmcarthur> grr
13:06:13 <sproingie> an operator in LOLskell
13:06:21 <holmak> Did anyone see the stack overflow article about the --> operator in C?
13:06:21 <jmcarthur> we shouldn't even have an operator for it
13:06:33 <Cale> HaskellLove: and then look for a list of 4 elements each of whose second part is 4 (or larger)
13:06:36 <mercury^> holmak: what does it do?
13:06:40 <j4cbo> -->? ahahaha :D
13:06:47 <holmak> Ill get the link
13:06:50 <Cale> holmak: yes, that was cute
13:06:58 <holmak> http://stackoverflow.com/questions/1642028/what-is-the-name-of-this-operator
13:06:59 <Cale> while (x --> 0) { ... }
13:07:03 <mercury^> Seems like a comparison operator to me.
13:07:11 <Cale> It's actually two operators
13:07:11 <orbitz> holmak: you mean the non existant --> operator?
13:07:25 <Cale> It's (x--) > 0
13:07:26 <holmak> Oh, I am aware that it is a joke.
13:07:26 <mercury^> :D
13:07:29 <sproingie> that took me about half a second to get
13:07:56 <sproingie> i love the comment
13:10:14 <povman> x approaches 0 from above, pretty nice if you ask me :p
13:11:02 <Cale> As someone else noted there, you can also flip it around:  while (0 <-- x)
13:11:21 <povman> that doesn't quite mean the same thing
13:11:26 <Cale> right :)
13:11:27 <sproingie> while (0 <-- x --> 0)
13:11:38 <j4cbo> i think that will cause undefined behavior
13:11:39 <povman> sproingie: die
13:11:41 <j4cbo> (no, really!)
13:11:41 <sproingie> probably results in execve nethack
13:11:43 <fhobia> how do i test out the functions of Data.Map in ghci ? can't seem to figure how to load it up
13:11:54 <Cale> fhobia: :m + Data.Map
13:12:13 <Cale> fhobia: Though when you use it inside your code, you probably want to import it qualified
13:12:32 <Cale> I like using   import qualified Data.Map as M; import Data.Map (Map)
13:12:39 <fhobia> rgr
13:12:43 <Cale> So as not to have to write the module qualifications in types.
13:12:50 <fhobia> what does the + do? i tried it with and without and it seems to work...
13:13:05 <pikhq> *++*++*++* // Now *there's* a C operator.
13:13:12 <Cale> fhobia: It adds the module to your current imports, rather than replacing them
13:13:17 <mercury^> As a special rule, you may omit some parts there: while (0 <-- x --)
13:13:20 <fhobia> ah, makes sense
13:13:27 <sproingie> mercury^: ooh arrow syntax!
13:14:55 <j4cbo> pikhq: looks like someone is a http://c2.com/cgi/wiki?ThreeStarProgrammer ;)
13:16:06 <pikhq> j4cbo: I don't think I've ever used such a monstrosity, actually.
13:16:24 <sproingie> i've seen three-star code in PHP source
13:17:35 <sproingie> RMS's C code is downright lovecraftian
13:17:52 <povman> pretty sure that removing ++ and -- from C would make it a lot harder to make defects
13:18:03 <povman> also typing etc
13:18:14 <j4cbo> C's type system is a bit special
13:18:26 <sproingie> j4cbo: short bus special?
13:18:33 <pikhq> sproingie: RMS's C code is trying to be Lisp, isn't it?
13:18:36 <pikhq> povman: Dubious.
13:18:43 <mercury^> There are few things wrong in C, pre- and postincrement are not among them.
13:19:04 <sproingie> pikhq: i think it's trying to be the kind of lisp that makes lispers cringe
13:19:04 <povman> sproingie: do you have an example?
13:19:30 <pikhq> sproingie: True.
13:19:39 <HaskellLove> someone knows a recursive functions to do permutations list of given number lets say 8125?
13:19:51 <merijn> The lack of module support (also, no namespaces?!) and the use of preprocessor in C are the worst flaws I think
13:19:55 <sproingie> povman: have to go way back.  old versions of emacs.
13:20:00 <j4cbo> my best example of why C's type system sucks is this:
13:20:04 <j4cbo> enum test_t { FOO, BAR }; int * test = FOO;
13:20:13 <j4cbo> compiles with no warnings, ever. can you tell why?
13:20:34 <merijn> "char* foo, bar;" is also a favorite
13:20:38 <sproingie> because enums are ints.  C++ fixes this.
13:20:49 <povman> "C++ fixes", haha
13:20:51 <j4cbo> C99 should have fixed it :/
13:21:04 <sproingie> i would think int to pointer conversion would produce a warning
13:21:10 <j4cbo> well
13:21:14 <dolio> HaskellLove: Think about factorials.
13:21:22 <j4cbo> changing "int * test = FOO" to "int * test = BAR" will cause it to produce a warning
13:21:49 * hackagebot upload: bindings-DSL 1.0.3 - Domain specific language for FFI description, on top of hsc2hs. (MauricioAntunes)
13:21:56 <sproingie> C99 can't fix that.  C could really use backward-incompatible breaks that can be switched on, but that's not the philosophy they subscribe to
13:21:58 <HaskellLove> dolio to get the number of permutations yes... but i need to get lists of permutations
13:21:59 <pikhq> Oh, that's why it's not getting a warning for implicit cast from int to (int*)? Because NULL = 0?
13:22:03 <j4cbo> yep!
13:22:14 <pikhq> Wow.
13:22:17 <dolio> You only need a single permutation, right?
13:22:35 <j4cbo> gotta love it.
13:22:48 <sproingie> NULL should be (void *)0
13:22:52 <HaskellLove> dolio i need to get list of permutations for given number, all...
13:23:10 <Cale> HaskellLove: What are the permutations of a number? Do you mean the permutations of its digits?
13:23:16 <ben0x539> C++ lets you do int* i = false, though
13:23:26 <HaskellLove> Cale yes permutations of digits
13:23:34 <pikhq> sproingie: In C++0x, NULL is nullptr_t. ;)
13:23:39 <sproingie> java surprisingly went for a real bool type
13:23:46 <ben0x539> Surely nullptr is nullptr_t
13:23:46 <Zao> Or a friendly 0.
13:23:49 <ben0x539> and NULL stays 0
13:24:09 <j4cbo> ben0x539: oh god, i thought you were joking, and then i tried it D:
13:24:40 <Paczesiowa> anyone familiar with control-monad-exception design/history?
13:25:21 <HaskellLove> so far i have vague idea it will be like permutations 2345 = permutations starting with 2 + permutations starting with 3 + permutations starting with 4 + permutations starting with 5
13:25:47 <Cale> HaskellLove: Write a function to permute lists first
13:25:52 <HaskellLove> so the problem gets down to, get permutations of the digits with the first one fixed
13:25:58 <Cale> HaskellLove: there's no sense in storing things as numbers
13:26:06 <ben0x539> j4cbo: The rationale is that any integer literal with value 0 can be used to initialise a pointer to be a null pointer :/
13:26:13 <kmc> C++ lets you do std::string x(false)
13:26:22 <kmc> it's a runtime exception usually
13:27:00 <kmc> implicit conversions are such a bad idea
13:27:37 <Zao> The world would be a nicer place if the `explicit' keyword was `implicit'.
13:28:01 <Zao> I did an `explicit' pass over my unary ctors once in a reasonably sizeable codebase. Found a tonne of awesome bugs.
13:28:08 <kmc> yeah
13:28:33 <HaskellLove> Cale what do you mean?
13:28:39 <j4cbo> the best way to debug code is to print it out and go over it with a red pen
13:28:48 <Zao> vec3::vec3(vec2 v, float z = 0.0f) : x(v.x), y(v.y), z(z) {}
13:28:54 <HaskellLove> Cale I am thinking in indexes way
13:29:00 <j4cbo> or rather, the best way to find hard-to-find bugs
13:29:07 <jmcarthur> the best way to debug code is to prove it correct as you write it
13:29:08 <Botje> j4cbo: but that doesn't scale to threads :]
13:29:09 <Cale> HaskellLove: I mean that operating on lists of digits is so much easier than operating on integers
13:29:12 <Zao> Couple that with a vec2 ctor that implicitly drops the z from a vec3...
13:29:22 <Zao> And you get "where the heck did my Z coordinates go?" bugs.
13:29:35 <j4cbo> Botje: what do you mean? :P
13:29:38 <Cale> HaskellLove: Which problem is this, btw?
13:29:47 <HaskellLove> Cale well yes that is what i said, given a number permute its digits.. anyways... euler 49
13:31:16 <HaskellLove> i might end up using tails and inits
13:31:50 <Berengal> HaskellLove: You had a good start above. Indeed, permutations of [a,b,c,d] is best implemented as "permutations starting with a + permutations starting with b + permutations starting with c + permutations starting with d"
13:32:20 <Berengal> HaskellLove: you only need to define what the rest of those sub-permutations are, and a base case
13:32:35 <HaskellLove> yeah looking for it...
13:33:18 <Berengal> HaskellLove: You might want a function `select :: [a] -> [(a, [a])]'. It makes things so much easier
13:33:56 <HaskellLove> builtin? seems not...
13:34:01 <Berengal> No, it's not
13:34:12 <Cale> Very unfortunately.
13:34:24 <Berengal> select [1,2,3] = [(1,[2,3]),(2,[1,3]),(3,[1,2])]
13:35:03 <HaskellLove> wow cool
13:35:16 <Cale> It also seems silly, but it would also be handy to have selectTail [] = []; selectTail (x:xs) = (x,xs) : selectTail xs
13:35:58 <Cale> Usually I end up doing something like (x:xs') <- tails ... in a comprehension or do-block for the list monad
13:36:13 <Cale> But occasionally it would be nice to have that one too.
13:36:42 <HaskellLove> i have ideas in my mind i will use either od these: tails, inits, repeat, zip family
13:36:44 <Cale> selectTail xs = [(y,ys) | (y:ys) <- tails xs]
13:37:43 <Cale> HaskellLove: It's educational to write your own permutations of a list function, but such a function already exists in Data.List, just for reference
13:37:48 <Cale> > permutations [1,2,3,4]
13:37:50 <lambdabot>   [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4...
13:38:17 <HaskellLove> yes i know i dont want to use it
13:38:38 <HaskellLove> maybe later and compare to what i will do
13:38:59 <HaskellLove> that is after i am done with mine... not sooner
13:39:21 <tromp__> @let pick []=[]; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
13:39:22 <lambdabot>  Defined.
13:39:39 <tromp__> @let permute= join (evalStateT . mapM (const (StateT pick)))
13:39:39 <jmcarthur> selectTails = zip <*> tail . tails
13:39:40 <lambdabot>  Defined.
13:40:13 <kevinclark> HaskellLove: are you posting your solutions in general? I've been tossing up problems as I do them up here: http://github.com/kevinclark/project_euler
13:40:23 <jmcarthur> > zip <*> tail . tails $ [1,2,3,4]
13:40:24 <lambdabot>   [(1,[2,3,4]),(2,[3,4]),(3,[4]),(4,[])]
13:40:43 <Berengal> @quote zip`ap`tail
13:40:43 <HaskellLove> kevinclark i had a blog but left it i have no time
13:40:43 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
13:40:57 <Paczesiowa> I'll never understand people's obsession with project euler...
13:41:24 <jmcarthur> yeah, i don't think project euler helps your learn much about a language besides its lists/arrays
13:41:28 <jmcarthur> *helps you
13:41:31 <kevinclark> Paczesiowa: I don't know haskell, and wanted to learn it, and it seemed like an interesting problem set to work with
13:41:49 <kevinclark> and seeing as I'm not to the part in the book where I understand IO, lists and numbers are a good fit ;)
13:41:58 <Berengal> Paczesiowa, jmcarthur: It's nice to have when you're still learning the syntax. Gives you concrete problems to work with
13:42:25 <jmcarthur> Berengal: it's certainly not as nice as the exercises given to you in tutorials though...
13:42:28 <Berengal> And lists and numbers are usually pretty free of gotchas
13:42:41 <jmcarthur> Berengal: not in haskell though :\
13:43:27 <dubhrosa> I think spoj is much better than project Euler, and if you're using haskell you really need to understand performance
13:43:33 <Berengal> jmcarthur: The type class thing isn't hard to ignore when doing PE
13:43:49 <jmcarthur> Berengal: perhaps it shouldn't be ignored, though
13:44:10 <jmcarthur> my point is that euler doesn't really help much with language as much as with algorithms
13:44:29 <Berengal> True, but different languages demand different algorithms as well
13:44:34 <kevinclark> I think the important thing is to have a problem you're interested in working on
13:44:42 <jmcarthur> Berengal: really?
13:44:48 <mreh> what's the beef with cabal and haskell installs again?
13:44:56 <dubhrosa> kevinclark: hear hear
13:45:06 <Berengal> For example, I had much trouble doing problem 14 when I first started out in haskell, despite having done about 40 problems in python already and gotten a decent grasp of imperative algorithmics
13:45:58 <dubhrosa> spoj has more interesting problems, imo
13:46:05 <trofi> > " " ++ fix (" " ++)
13:46:07 <lambdabot>   "\1086\1087                                                                ...
13:46:13 <trofi> > text $ " " ++ fix (" " ++)
13:46:18 <lambdabot>   mueval: ExitFailure 1
13:46:21 <trofi> huh?
13:46:23 <b_jonas> many of spoj problems are open-ended
13:46:31 <b_jonas> they're completely different from those of euler
13:47:05 <pikhq> trofi: I'm pretty sure that text is strict.
13:48:31 <kmc> PE is good for learning the very basics, or for golf practice
13:48:40 <trofi> ah
13:48:44 <trofi> > text $ "foo " ++ fix (" " ++)
13:48:50 <lambdabot>   mueval: ExitFailure 1
13:48:54 <fft> Why does this function always fail ? http://pastie.org/761807
13:48:56 <kmc> text is strict
13:49:06 <kmc> PE doesn't scratch the surface of things you need to know to be a good Haskell programmer
13:49:13 <kmc> i recommend ICFP contest problems to get there
13:49:25 <pikhq> trofi: ... Doing the same thing again won't make it work.
13:49:26 <jmcarthur> :t text
13:49:27 <lambdabot> String -> Doc
13:49:30 <kmc> perhaps the one where you implement a raytracer whose input format is a functional stack-based language
13:49:35 <pikhq> (Windows to the contrary)
13:49:43 <trofi> pikhq: just ensured it's not non-ascii related
13:49:47 <koeien37> kmc: that is actually a nice idea
13:49:50 <pikhq> Mmkay.
13:49:59 <trofi> @src text
13:49:59 <lambdabot> Source not found.
13:50:13 <jmcarthur> but if you are going to be implementing icfp problems you might as well just tackle your own projects
13:52:38 <tommd>    @messages
13:52:48 <tommd> @messages
13:52:49 <lambdabot> You don't have any new messages.
13:52:54 <tommd> lambdabot doesn't like spaces?
13:52:57 <tommd> @botsmack
13:52:57 <lunabot>  :o
13:52:58 <lambdabot> :)
13:54:54 <tommd> preflex: seen topi_
13:54:55 <preflex>  topi_ was last seen on #ghc 4 days, 21 hours, 26 minutes and 52 seconds ago, saying:         Prelude.chr: bad argument
13:55:04 <tommd> Odd quote
13:55:07 * Cale hastily bangs out a solution to problem 49: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15275#a15275
13:55:45 <mreh> does the debian ghc package contain cabal too?
13:55:59 <mreh> s/cabal/cabal install
13:56:00 <Paczesiowa> cabal lib or cabal install?
13:56:11 <ben0x539> Is there something like project euler for programming problems instead of maths problems?
13:56:11 <monochrom> Is conal the CHP person?
13:56:41 <Cale> No, that's Neil Brown
13:56:49 <monochrom> Thanks.
13:57:14 <Cale> ben0x539: There is a difference?
13:57:39 <Cale> I guess the problem with that PE problems is that they all concern stupid numbers.
13:58:03 <Cale> Nobody gives a damn about most if not all of those numbers.
13:58:04 <kevinclark> ben0x539: I have a buddy who did a bunch of the top coder problems
13:58:22 <mreh> Paczesiowa, cabal install
13:58:36 <Paczesiowa> mreh: no idea then:)
13:58:38 <Cale> However, the processes for generating those numbers are occasionally interesting
13:58:39 <monochrom> I think pure curiosity as to "how do you compute this, even though no one cares" is fine.
13:58:40 <mreh> doh!
13:59:00 <Cale> It would be nicer to state the problems in terms of those processes though
13:59:21 <Cale> Rather than asking for specific examples
13:59:36 <monochrom> My problem with PE is that it is exposed to the vast amount of monkeys on the internet. The original dream "you should learn math so you see a fast way" is totally lost.
13:59:38 <jmcarthur> PE problem 9001: Crack the following AES-encrypted block: [...]
14:00:05 <ben0x539> I feel like PE is challenging and training my ability to gain mathematical/numerical insights, rather than how to structure programs
14:00:19 <jmcarthur> ben0x539: that summarizes my thoughts of it as well
14:00:24 <ben0x539> which seems a more interesting thing to do in Haskell coming from an imperative place
14:00:32 <kevinclark> monochrom: a fast way... to compute?
14:00:38 <jmcarthur> which is why i think it not ideal for learning new programming languages
14:00:44 <monochrom> Every monkey sees an PE question that mentions "permutations" and involuntarily starts writing code generating all permutations.
14:00:45 <Cale> The best-path-through-triangle-of-numbers one has a nice solution though
14:00:47 <holmak> lisp interpreter!
14:01:03 <holmak> (as programming exercise)
14:01:14 <b_jonas> oh sure, that's one of those programs everyone writes
14:01:24 <jmcarthur> holmak: yes that is a much nicer problem to work on
14:01:47 <holmak> I just vouch for it because its what I used to get used to Haskell
14:01:59 <ben0x539> As in, scheme in 48 hours?
14:02:17 <holmak> well, i took a week or two, and did it mostly on my own
14:02:42 <holmak> but i hear there is some kind of tutorial out there for it
14:02:48 <ben0x539> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
14:02:55 <ben0x539> I have zero experience in interpreter/compiler design
14:03:13 <holmak> so do i
14:03:19 <Cale> http://projecteuler.net/index.php?section=problems&id=67 -- this one is a good exercise in whether or not you understand the basic higher order functions :)
14:03:26 <holmak> fortunately, lisp interpreters are easy
14:03:40 <holmak> terrible ones especially, as i made :D
14:04:08 <kevinclark> ben0x539: scheme makes it easy since the code is essentially already the abstract syntax tree. All you really need to do is parse and apply
14:04:08 <mreh> doesn't one of the ghc installations come with parsec network zlib and cabal install?
14:04:13 <monochrom> Suppose a PE question asks "how many numbers are between 1 and 10^100 inclusive, and divisible by 10^10", you can be sure the entire internet of monkeys come to #haskell and ask "how do I loop through 10^100 numbers and test each for divisibility?"
14:04:33 <monochrom> oops typo, I have to make it more funny
14:04:37 <monochrom> Suppose a PE question asks "how many numbers are between 1 and 10^100 inclusive, and divisible by 10^100", you can be sure the entire internet of monkeys come to #haskell and ask "how do I loop through 10^100 numbers and test each for divisibility?"
14:04:43 <mreh> can't this go offtopic please? :(
14:05:03 <mreh> no-one wants to help!
14:05:09 <Cale> mreh: The Haskell Platform probably comes with those things
14:05:28 <Saizan> yeah, the haskell platform does
14:05:35 <mreh> w00p
14:05:36 <luite> monochrom: but the good questions would make it extremely impractical to run the trivial or brute force solutio
14:05:40 <Saizan> that works with 6.10
14:05:52 <Cale> mreh: But normally what I do is install the GHC generic linux binary and then cabal install, and then just cabal install anything else I need.
14:05:53 <xerox> monochrom the first could have been a lownumbered project euler
14:06:04 <dolio> I wrote assembly code that loops through 10^100 numbers and tests them for divisibility in 0.2 seconds!
14:06:26 <mreh> Cale: i need to install all the dependant libraries manually
14:06:30 <Cale> mreh: The cabal install package contains a handy bootstrap script which works given that you have the libraries which are included with ghc
14:06:32 <povman> does anyone know of a mapAccumWhile?
14:07:00 <monochrom> mreh: I recommend staying with 6.10 for now. Are you at 6.10 or do you really like to go to 6.12?
14:07:12 <xerox> povman takeWhile the result of mapAccum[LR]?
14:07:16 <mreh> monochrom: i just want cabal-install working!
14:07:26 <mreh> and working fast!
14:07:27 <monochrom> Then 6.10 is easier.
14:07:28 <Cale> mapAccumR is annoyingly backwards
14:07:53 <povman> e.g. (acc -> x -> Maybe (acc, y)) -> acc -> [x] -> (acc, [y])
14:08:04 <povman> xerox: the while is on the accum
14:08:41 <Cale> hmm, does anyone here have 6.12 and want to tell me if nubBy (\x y -> y `mod` x == 0) [2..] correctly gives a list of primes?
14:08:41 <bob0> Cale: no
14:08:44 <povman> i.e. so i can do mapAccum on infinite lists
14:08:53 <Cale> bob0: no?
14:09:28 <xerox> povman so maybe a foldr, which can stop relying on the list and return at a given point during the traversal
14:09:42 <Cale> The parameters to the function which mapAccumR takes are in the reverse order from what I'd expect
14:09:56 <Heffalump> Prelude Data.List> nubBy (\x y -> y `mod` x == 0) [2..]
14:09:57 <Heffalump> [2,3,4,5,6
14:09:59 <sproingie> Cale: it just gave me [2..]
14:10:07 <Cale> Heffalump: damn, it's still broken
14:10:13 <monochrom> Yay, time to break nubBy undocumented features.
14:10:53 <monochrom> I support nubBy modified slightly every 3 months to frustrate abuses.
14:11:15 <merijn> Ok, so I spend near a week reading various things and now I need a sanity check of my understanding, please do interrupt and correct while I try and summarize. Polymorphic ADT's are the subset of ADT's which take one or more types as argument and return a concrete type.
14:11:20 <dolio> nubBy should use unsafePerformIO to randomly choose which implementation to use.
14:11:23 <monochrom> And then you people will just write CPP code to discern versions and adapt.
14:11:25 <povman> xerox: are you talking about the normal foldr or a modification?
14:11:38 <Cale> If you have a function which takes both a list and a function of some parameters which will be selected from the list, I think a good policy is that the function should be applied to the parameters in the order in which they occur in the list
14:11:44 <xerox> povman yes the plain one
14:11:51 <Cale> (as far as reasonable)
14:12:54 <povman> @src foldr
14:12:55 <lambdabot> foldr f z []     = z
14:12:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:12:57 <Cale> Or, perhaps better stated -- the expression graph generated by the application of the higher order function should try as hard as possible to preserve the left-to-right order of the elements as they occurred in the original list
14:13:09 <povman> ohhhhhhhhhh, !
14:13:27 <povman> @src foldl
14:13:27 <lambdabot> foldl f z []     = z
14:13:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:13:52 <Cale> The new stupid version of nubBy violates this, and it's ridiculous, because all you'd have to do is flip the function.
14:14:10 <merijn> Functor's are the subset of polymorphic ADT's that a allow you to map a function a -> b over the contents of the data type (provided the polymorphic ADT contains an a). Applicative Functors are the subset of functors that not only allow mapping functions over their content, but also allow mapping their content over another Applicative Functor of the same type. And Monads are then in turn the subset of applicative functors on which we can define
14:14:10 <merijn> a logical ordering based on the sequencing of various applications, correct?
14:14:19 <Cale> Also, the mapAccumR function as standardised in H98 violates it as well.
14:14:56 <Cale> merijn: That last characterisation, I find a bit strange, but I guess it's kind of true.
14:15:58 <merijn> Cale: Well, the entire point of monads is that we're applying stuff to their contents in such a way that ordering matters, no?
14:16:06 <sproingie> no
14:16:22 <Berengal> There are commutative monads
14:16:45 <Berengal> e.g. Writer for commutative monoids
14:16:48 <Cale> merijn: I don't really get the thing about ordering.
14:17:12 <Cale> The difference between applicative functors and monads is the presence of join :: (Monad m) => m (m a) -> m a
14:17:29 <merijn> Cale: Well, I think I'm writing it wrong
14:17:38 <noddy> besides, don't applicative f's allow ordering just as well as monads do?
14:17:56 <koeien37> :t (<*>)
14:17:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:18:07 <aavogt> this isn't applicative:    do x <- f; if x then a else b
14:18:42 <merijn> sproingie: Care to elaborate other then "no"?
14:18:44 <aavogt> noddy: all the 'effects' for an (Applicative f) have to happen
14:18:47 <dolio> They allow ordering similar to how function calls in strict languages allow ordering.
14:18:47 <noddy> exactly. is is  join ((\x -> if x then a else b) <$> f)
14:18:59 <Cale> One way to look at it, I suppose, is that monads give you the ability to take the result of a subcomputation, and consume it in multiple ways. With applicative functors, you always consume the results of subcomputations in exactly one place.
14:19:19 <dolio> In that in "f x y" x is ordered before y.
14:19:20 <sproingie> the point of monads is that you can combine any a -> m b you can think of as long as m is the same monad
14:19:40 <noddy> no, the point of monads is join.
14:19:46 <koeien37> well, fine
14:19:50 <sproingie> actually the point of monads is to generate tutorials
14:19:57 <koeien37> fmap + return + join gives you >>= anyway
14:19:59 <noddy> sproingie: tacos!
14:20:23 <sproingie> noddy: what a ridiculous analogy.  clearly monads are flautas.
14:20:35 <noddy> koeien37: and return + <*> gives you fmap
14:20:45 <noddy> sproingie: i lold a bit
14:20:47 <Berengal> When using applicative functors, it doesn't matter when you ap. You can do it early and often, or just gather results up and do it at the end. The end result is the same
14:21:25 <Berengal> In a sense, in Applicative, pure functions cannot interfere with the underlying context.
14:21:40 <Berengal> In Monad they can.
14:21:54 <sproingie> presumably in a monad you want them to
14:22:05 <merijn> Am I then at least correct in thinking that >> is only useful in situations where the monad has side effects? As the first value is being discarded (meaning it doesn't accomplish anything if there are no side effects)
14:22:05 <noddy> Berengal: yes. in other words, Applicative parses context-free grammars.
14:22:19 <koeien37> >> is useful in the State monad
14:22:25 <sproingie> and IO of course
14:22:31 <Berengal> koeien37: Only because of its side-effect
14:22:41 <koeien37> depends if you call the updated state a "side effect"
14:22:43 <jmcarthur> yes, >> is all about the side effect
14:22:46 <Berengal> I do
14:22:48 <koeien37> if so, then yes
14:22:51 <merijn> Well, state and IO are really side effects, aren't they?
14:22:51 <jmcarthur> koeien37: it is a side effect
14:22:59 <merijn> They're not return values
14:23:00 <byorgey> merijn: yes, but pretty much every interesting monad has side-effects of some sort.
14:23:03 <koeien37> IO certainly is
14:23:07 <noddy> >[1, 2] >> [2]
14:23:09 <koeien37> []
14:23:11 <mokus> "side-effects" are relative
14:23:14 <sproingie> side effect is a matter of perspective
14:23:20 <jmcarthur> in the sense we are talking about, even things like nondeterminism are side effects (list monad)
14:23:20 <kmc> > "abc" >> "de"
14:23:21 <lambdabot>   "dedede"
14:23:22 <Philonous> merijn: >> is usefull for monads with effects, but those don't have to occur on the side
14:23:23 <b_jonas> I think monads are the precise way to define side effect
14:23:28 <b_jonas> but then >> isn't too useful in reader
14:23:28 <koeien37> "purity" is also a matter of perspective
14:23:37 <kmc> > Nothing >> (Just 7)
14:23:37 <koeien37> values in the IO monad are not "impure"
14:23:37 <lambdabot>   Nothing
14:23:39 <jmcarthur> > "ab" *> "cde"
14:23:40 <lambdabot>   "cdecde"
14:23:43 <koeien37> imo
14:23:46 <jmcarthur> > "cde" <* "ab"
14:23:47 <lambdabot>   "ccddee"
14:23:48 <Cale> koeien37: I agree.
14:23:54 <kmc> IO actions are just abstract data values
14:23:54 <Berengal> I like using the word "context" to describe the monad effects that happen behind the scenes
14:23:55 <Cale> koeien37: Though the implementation in GHC is evil.
14:23:58 <sproingie> the heck is <*?
14:24:03 <kmc> functions that return IO actions are pure functions, of course
14:24:03 <Berengal> It doesn't imply IO, but doesn't exclude it either
14:24:05 <byorgey> @type (<*)
14:24:05 <sproingie> :t (<*)
14:24:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
14:24:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
14:24:21 <sproingie> still doesn't tell me much
14:24:25 <sproingie> @src (<*)
14:24:25 <lambdabot> (<*) = liftA2 const
14:24:27 <Berengal> Cale: Because it actually executes IO?
14:24:27 <byorgey> throws away the return value from the second computation (but not the "side effect")
14:24:27 <Philonous> kmc: By this definition C is pure
14:24:29 <dolio> It doesn't?
14:24:34 <sproingie> much clearer
14:24:43 <dolio> It tells you pretty much everything.
14:24:44 <jmcarthur> sproingie: keep the first value, and the side effects from both
14:24:47 <koeien37> what, then, is a "side effect" according to you?
14:25:03 <jmcarthur> sproingie: whereas *> is the second value with the side effects from both
14:25:03 <Twey> Philonous: No  using sed to generate a C program is pure
14:25:05 <Cale> Berengal: Because it uses impure functions as a representation, and abuses the evaluator to cause them to occur.
14:25:09 <Twey> (for example)
14:25:24 <b_jonas> does *> generalize >> ?
14:25:38 <Twey> Philonous: The C program itself isn't
14:25:40 <jmcarthur> b_jonas: a believe so, as long as Applicative and Monad agree
14:25:43 <jmcarthur> *i believe
14:25:54 <kmc> Philonous, no, because C does not make a distinction between evaluation and execution
14:25:56 <Berengal> Cale: Impure functions how? RealWorld -> (a, RealWorld) functions?
14:26:03 <Twey> Likewise, functions that return IO values are pure, but the actions that the IO values represent aren't
14:26:09 <kmc> however, you can write a C program composed totally of pure functions, which outputs to stdout another C program which does IO
14:26:09 <jmcarthur> important to note that (<*) /= flip (>>), though
14:26:16 <jmcarthur> or flip (*>)
14:26:17 <koeien37> Twey: but that doesn't matter, because we can't inspect those anyway
14:26:25 <kmc> or machine code, or a Haskell program, or English text
14:26:28 <sproingie> > ("ab" *> "cd") == ("ab" >> "cd")
14:26:29 <lambdabot>   True
14:26:45 <conal> otoh, cpp+c does distinguish between evaluation & execution
14:26:52 <conal> just as haskell+io does
14:27:00 <Twey> But CPP does impure things, too
14:27:07 <conal> the balance of power differs.
14:27:13 <Twey> Aye, that too
14:27:21 <pikhq> Twey: Only #undef is impure in CPP.
14:27:21 <pikhq> ;)
14:27:29 <kmc> hehe
14:27:34 <kmc> can't #define redefine
14:27:39 <Cale> Berengal: Yeah, those RealWorld -> (a, RealWorld) "functions" that it's using are not really functions.
14:27:40 <conal> Twey: yes.  modulo inessential/accidental details
14:27:41 <kmc> and of course #warn has side effects
14:27:45 <Twey> pikhq: Nah  #define and #ifdef are, too (order of execution matters)
14:27:53 <sproingie> #error is bottom?
14:27:54 <Philonous> Hah, conal to the rescue!
14:27:54 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
14:27:56 <Twey> And #include does file IO, of course 
14:28:07 <merijn> Oh well, I think I at least got the rest of my understanding right, I'll let the monads understanding simmer and stew over night :p
14:28:12 <kmc> haha lunabot
14:28:18 <Cale> Berengal: RealWorld is a type with no values, and it puts low-level bits into the structure of (->)
14:28:20 <Twey> Hehe
14:28:20 <koeien37> well, the C preprocessor is just a computation in the State monad :)
14:28:24 * sproingie .oO( CMonad )
14:28:32 <b_jonas> aren't __TIME__ and __DATE__ impure too?
14:28:38 <kmc> acme now!
14:28:53 * kmc <3 Acme.Time.Now
14:28:53 <Berengal> Cale: It's not like we should care that's how it does it, as long as it's correct. IO is opaque outside of the GHC internals, which you shouldn't care about unless you're a GHC hacker
14:28:57 <kmc> i've used it in a real program!
14:29:01 <Twey> koeien37: No, the State monad would be a prepreprocessor that generated preprocessor code :
14:29:02 <Cale> Berengal: It's basically a trick to get the evaluator to enter code which does impure stuff in the right order because of the apparent "data dependencies", which don't really exist because there are no defined values of type RealWorld
14:29:13 <Twey> kmc: What did the program do?  O.O
14:29:23 <Berengal> kmc: Wow...
14:29:27 <Cale> Berengal: It does end up meaning that IO is stricter than I expect sometimes.
14:29:34 * Berengal records the second usefulness of his one library
14:29:43 <Philonous> conal: Do we need to invoke the preprocessor to argue that a c program is an expression, that, when evaluated, yields a effectful  computation?
14:29:45 <jmcarthur> Cale: what do you mean by "stricter"?
14:29:52 <Cale> Berengal: I've had programs which unexpectedly stack overflow rather than just leaking a bit of memory.
14:30:12 <conal> Philonous: have you ready my c-as-functional-lang post?
14:30:25 <Berengal> Cale: Does it violate RT or the monad laws?
14:30:46 <merijn> btw, is there a way to have ghci display the functions defined for a typeclass? (i.e. show all the functions defined for Functor, or Eq)
14:30:46 <Philonous> conal: Just reading it again as I forgot the details
14:30:57 <Berengal> Cale: Because strictness doesn't violate purity
14:30:59 <Cale> No, just the expected performance behaviour in terms of a particular operational semantics which treats IO values like data.
14:30:59 <koeien37> :info
14:31:00 <b_jonas> you could also say that the C compilation should be pure (modulo bugs and some oddities like __DATE__), and the side effects only happen when you run the program
14:31:14 <merijn> koeien37: Awesome, thanks
14:31:25 <kmc> Twey, calculated expected income and expenses into the future.  it was easiest to treat the current date as a constant, as if i'd edit the file every day
14:31:27 <Cale> It's not a huge deal, and I don't really care all that much
14:31:27 <conal> Philonous: w/o cpp, the expression/evaluation pov is trivial.
14:31:29 <koeien37> merijn: gives you the class def. and the instances in scope
14:31:36 <sproingie> :browse is also awesome
14:31:45 <Cale> But it would perhaps be nice if IO values could be taken apart again.
14:31:46 <kmc> and you really don't want the date changing during the execution of the program anyway
14:31:48 <conal> Philonous: where trivial == non-compositional
14:31:48 <sproingie> between :info and :browse you can find a lot of interesting stuff
14:31:50 <Twey> kmc: Cute :
14:31:59 <Berengal> Cale: For a moment there I was scared. I still have panic attacks when I think about Parsec's return being strict...
14:32:08 <Cale> (in a higher-order abstract syntaxy sort of way)
14:32:08 <kmc> yup, i wrote it with unsafePeformIO and than was like.... hey, there's a library for that ;P
14:32:37 <kmc> mmm hoas
14:32:38 <kmc> mmm burrito
14:32:41 * kmc bbl burrito
14:33:44 <conal> Cale: decomposing IO values by keeping structure?  if so, would defeat full abstraction.
14:34:13 <b_jonas> heh
14:35:15 <b_jonas> wow, they translated that perl joke (the Acme::Now module) to haskell? amazing
14:35:18 <conal> Cale: i guess lack of full abstraction (or even partial abstraction) is what's so dissatisfying to me about GADT "models" of IO.
14:35:43 <Cale> conal: hm?
14:35:47 <xerox> b_jonas is the perl version anything different from the haskell one?
14:35:53 <b_jonas> actually it's called Acme::Current
14:35:58 <b_jonas> and gives the current date
14:36:08 <b_jonas> was reuploaded to CPAN every day for a while
14:36:21 <b_jonas> later they changed it to a version that takes the day only when it's installed or something
14:36:25 <Cale> conal: I'm thinking it would be nice to be able to write interpreters for IO which implement certain primitives differently.
14:36:37 <b_jonas> I think MJD invented it, but I'm not sure
14:37:07 <b_jonas> maybe not
14:37:09 <Cale> I'm not sure what you mean by "full abstraction"
14:37:11 <b_jonas> maybe it's just his stype
14:37:32 <b_jonas> Cale: you can always write your own IO-like monads
14:37:38 <Cale> b_jonas: Indeed.
14:37:54 <b_jonas> ones with reflection that is
14:38:01 <Cale> b_jonas: But you could do some pretty cool things if you could interpret arbitrary IO actions by hand.
14:38:01 <b_jonas> not simple but useful ones like StateT IO
14:38:16 <b_jonas> it would be hard because IO actions can really do anything
14:38:18 <b_jonas> seriously anything
14:38:59 <conal> Cale: sometimes people float "denotational models" for IO that capture composition structure -- with ctors for Return, Bind, and various prims (PutChar etc).  i realized recently that the extreme lack of abstraction is what leaves me dissatisfied with those "models".  they're more what i'd call "syntactic" than "semantic".  extreme failure of the ideal of full abstraction.
14:39:32 <jmcarthur> i'd say that as long as we are stuck we IO we might as well be able to dig into it
14:39:39 <jmcarthur> *stuck with IO
14:39:47 <jmcarthur> i really need to proof what i say before i hit enter
14:40:05 <b_jonas> hmm, maybe acme-now is a different joke
14:40:05 <Paczesiowa> *proof read:)
14:40:41 <jmcarthur> Paczesiowa: proof is not an entirely uncommon shortening for that, afaik
14:41:22 <Paczesiowa> jmcarthur: oh, did not know that
14:41:24 <opqdonut> proof reading should be called proving
14:41:30 <Cale> conal: I suppose that it makes the interpretation of the monad laws rather odd.
14:42:19 <Cale> Perhaps that sort of thing is what you mean
14:43:17 <fft> I completely got stuck with MonadPlus. How should I define State Monad as MonadPlus instance. Could anyone give me the example ?
14:43:40 <dolio> State isn't a MonadPlus.
14:43:58 <Saizan> i think conal means that an AST like that doesn't say anything about what happens on the real world when an IO action is executed
14:44:04 <jmcarthur> fft: i do not that think makes sense
14:44:04 <Saizan> well, not much
14:44:14 <conal> Cale: monad laws are just the tip of the semantic iceberg.  IO has thousands (?) of other primitives, as generated by ffi etc.  and lots of observational equivalences.  full abstraction want them to be denotationally equal as well.
14:44:16 <Paczesiowa> what about Monoid s => State s ?
14:44:22 <Berengal> You could make State a MonadPlus, but it would be pretty useless
14:44:44 <conal> Saizan: yes, thx.
14:44:49 <koeien37> what would be its mzero?
14:45:02 <fft> I'm trying to write a function which finds all paths in graph. I need mzero to indicate failure and mplus to concatenate answers. Is there another way?
14:45:21 <jmcarthur> Paczesiowa: i think it would make more sense to use the Endo monoid, but then you still have to decide how to come up with the value, probably like the First or Last monoid semantics
14:45:31 <fft> mzero is  \s -> (s ,[])  I think
14:45:36 <jmcarthur> Paczesiowa: and yeah, mzero kills that
14:45:39 <fft> for my purpose
14:45:55 <Paczesiowa> :t mzero
14:45:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
14:46:02 <koeien37> which type does \s -> (s, []) have ?
14:46:05 <Paczesiowa> mzero should work for all a
14:46:15 <jmcarthur> fft: that doesn't work for MonadPlus because it restricts your type parameter to [a]
14:46:24 <opqdonut> :t (\s -> (s, []))
14:46:25 <lambdabot> forall t a. t -> (t, [a])
14:46:36 <fft> jmcarthur: I noticed that
14:46:59 <fft> So how should I join the results ?
14:47:03 <skorpan> what stops MonadPlus from being FunctorPlus?
14:47:11 <koeien37> FunctorPlus?
14:47:13 <jmcarthur> fft: MonadPlus must work for all a, so State cannot be an instance of MonadPlus
14:47:22 <jmcarthur> skorpan: nothing that i know of. we just don't have functorplus
14:47:22 <b_jonas> so does that mean that fft needs a different monad or that he needs functions different from mzero and mplus?
14:47:34 <Berengal> skorpan: We have Alternative, which is an Applicative...
14:47:53 <b_jonas> Berengal: they use that for parsing stuff
14:48:01 <jmcarthur> i wish we could just get rid of Alternative and MonadPlus in favor of FunctorPlus or some other name for it
14:48:08 <Berengal> b_jonas: I use it for lots of other things as well
14:48:12 <fft> b_jonas: maybe different functions. So it would be the mine particular case
14:48:19 <Berengal> Well, not lots... lists and monads I don't need to join
14:48:41 <jmcarthur> or perhaps it's possible to be a FunctorPlus and a Monad, but not a MonadPlus?
14:48:53 <jmcarthur> not satisfying the proper laws
14:48:59 <fft> the sample from tutorial doesn't work and I'm trying to figure it out.
14:49:17 <b_jonas> monadplus has rules?
14:49:24 <koeien37> what is a FunctorPlus?
14:49:35 <koeien37> the same as a monadPlus with a less restricted superclass constraint?
14:49:36 <jmcarthur> b_jonas: i think it must relate to Monad in a certain way
14:49:40 <Berengal> b_jonas: Not that people can agree on
14:50:06 <jmcarthur> essentially Monoid laws along with some relation to Monad
14:50:25 <Berengal> With some exceptions, like IO
14:50:36 <jmcarthur> or at least i *think* it should satisfy the Monoid laws
14:50:56 <dolio> They're supposed to interact sort of like a ring.
14:51:02 <koeien37> well, to call something "Plus" seems to suggest even commutativity.
14:51:32 <jmcarthur> yeah. i hate that we have things like "MonadPlus" and "mappend"
14:51:43 <koeien37> (++) for mappend ftw
14:51:51 <dolio> a * (b + c) = a*b + a*c, m >>= (n `mplus` o) = (m >>= n) `mplus` (m >>= o)
14:52:00 <Berengal> @type (++)
14:52:02 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:52:06 <Berengal> :D
14:52:12 <dolio> Er, that one's slightly wrong, but you get the idea.
14:52:16 <jmcarthur> koeien37: i actually prefer a notation that doesn't look like addition
14:52:28 <jmcarthur> koeien37: (<>) is alright, in my opinion
14:52:35 <Berengal> >-<
14:52:50 <koeien37> does (++) suggest addition to you now?
14:52:50 <opqdonut> dolio: don't you mean o >>= m `mplus` n >>= o === (o `mplus` n) >>= m
14:53:00 <opqdonut> <> suggests inequality
14:53:09 <opqdonut> call me old-fashioned
14:53:13 <cytzol> (++) suggests "like addition, but not quite"
14:53:14 <Twey> <> is of course the statement separator
14:53:21 <Twey> In true APL style
14:53:22 <koeien37> (++) is not commutative now
14:53:29 <jmcarthur> at least <> is less apparently meaningful than ++
14:53:30 <opqdonut> aka the dual of [] ;)
14:53:36 <jmcarthur> ++ looks like increment :P
14:53:37 <b_jonas> Twey++ good one
14:53:40 <opqdonut> that's make <> the full list?
14:53:48 <dolio> opqdonut: Well, I'm pretty sure I don't mean that. But perhaps that with some typos corrected.
14:53:52 <opqdonut> * 'd
14:53:59 <skorpan> ++ is a park bench
14:54:04 <Twey> (<>) = fix (:[])
14:54:11 <opqdonut> dolio: gah, n>>=m :)
14:54:19 <Twey> :t fix (:[])
14:54:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
14:54:21 <lambdabot>       Expected type: a
14:54:21 <lambdabot>       Inferred type: [a]
14:54:22 <Twey> Heh
14:54:38 <dolio> m >>= \x -> f x `mplus` g x === m >>= f `mplus` m >>= g would be the right version of mine.
14:54:38 <Berengal> @let (<<<<<<<<<<-<&&&&%%%%**!*!!*!!++>>>>>>>>>>->>>>) = mappend
14:54:40 <lambdabot>  Defined.
14:54:48 <jmcarthur> Berengal: you suck
14:54:53 <Berengal> > [1,2,3] <<<<<<<<<<-<&&&&%%%%**!*!!*!!++>>>>>>>>>>->>>> [4,5,6]
14:54:55 <lambdabot>   [1,2,3,4,5,6]
14:54:58 <jmcarthur> Berengal: i was just about to define that operator to something useful
14:55:06 <Twey> Hahaha
14:55:17 <koeien37> how is mappend not useful?
14:55:25 <Berengal> jmcarthur: Well, now you can't! I got there first!
14:55:29 <koeien37> @undef
14:55:53 <cytzol> @let (<<<<-<<<<<<<<<<++!!*!!*!**%%%%&&&&>->>>>>>>) = flip mappend
14:55:53 * Berengal thinks the restricted set of operator symbols is going to become a pressing problem soon
14:55:54 <lambdabot>  Defined.
14:56:03 <jmcarthur> lol
14:56:08 <Twey> What restricted set of operator symbols?
14:56:23 <Berengal> The one without letters in
14:56:28 <b_jonas> /\ and \/ still aren't used
14:56:33 <koeien37>  is not used
14:56:33 <b_jonas> or are they?
14:56:34 <Twey> @let () = (>>)
14:56:36 <lambdabot>  Defined.
14:56:48 <Twey> @let () = xor
14:56:49 <sproingie> i wish haskell required space to separate tokens so i could define <foo> as an operator
14:56:49 <lambdabot>  Defined.
14:56:51 <koeien37> let  = sqrt
14:56:54 <koeien37> @let  = sqrt
14:56:55 <lambdabot>   Parse error: VarSym "\8730"
14:56:59 <Twey> o.@
14:57:00 <opqdonut> @let () = (.)
14:57:01 <lambdabot>  <local>:4:1: lexical error (UTF-8 decoding error)
14:57:05 <Twey> That's not UTF-8
14:57:07 <koeien37> @let () = sqrt
14:57:08 <lambdabot>  Defined.
14:57:09 <opqdonut> oh, right
14:57:12 <Twey> Oh, right
14:57:13 <opqdonut> i'm speaking latin
14:57:13 <koeien37> >  37
14:57:13 <dolio> sproingie: You'd like Agda, then.
14:57:14 <lambdabot>   <no location info>: parse error on input `'
14:57:15 <jmcarthur> sproingie: yeah, i rather like agda's way of doing things like this
14:57:24 <koeien37> > :t ()
14:57:25 <lambdabot>   <no location info>: parse error on input `:'
14:57:29 <koeien37> :t ()
14:57:30 <dolio> Where [a ], [ a], [a] and [ a ] are all different sets of tokens.
14:57:30 <Twey> > ( 37)
14:57:30 <lambdabot> Not in scope: `???'
14:57:31 <lambdabot>   No instance for (GHC.Float.Floating (t -> t1))
14:57:31 <lambdabot>    arising from a use of `L....
14:57:35 <cytzol> One of the Perl 6 Advent Calendar entries defined \U{SNOWMAN} to be a postfix operator
14:57:36 <ben0x539> @type ()
14:57:37 <lambdabot> Not in scope: `???'
14:57:38 <Twey> > (37 )
14:57:39 <sproingie> i'd like agda if i could write games in it that were semi-speedy fast :)
14:57:40 <lambdabot>   6.082762530298219
14:57:45 <opqdonut> hehe, snowman
14:57:45 <Twey> Unary operators must be postfix
14:57:47 <ane_> b_jonas: quickcheck uses \/ if that's what you meant
14:57:50 <Twey> And have brackets 
14:57:55 <Twey> > 37 
14:57:57 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:58:01 <sproingie> as it is now, agda is pretty much just a proof assistant, right?
14:58:09 <alxv> @let () = (.)
14:58:10 <lambdabot>  Defined.
14:58:14 <Twey> So when do we get dependent types in Haskell, again?
14:58:24 <koeien37> @let  = 1/0
14:58:24 <lambdabot>   Parse error: VarSym "\8734"
14:58:28 <jmcarthur> nah, agda can be used as a general language pretty easily. it just doesn't quite have a mature set of libraries
14:58:30 <ben0x539> > let () = const sqrt in 1 16
14:58:30 <lambdabot>   4.0
14:58:36 <jmcarthur> by any stretch
14:58:43 <Berengal> jmcarthur: It does have easy integration with haskell though
14:58:47 <sproingie> does it have haskell's FFI?
14:58:51 <b_jonas> > let xy = x**recip y
14:58:52 <lambdabot>   not an expression: `let xy = x**recip y'
14:58:53 <b_jonas> @let xy = x**recip y
14:58:54 <lambdabot>  <local>:6:1:
14:58:54 <lambdabot>      Multiple declarations of `L.'
14:58:54 <lambdabot>      Declared at: <local>...
14:58:56 <jmcarthur> sproingie: its FFI is haskell itself
14:59:04 <sproingie> works for me
14:59:10 <jmcarthur> you bind identifiers to haskell functions, etc.
14:59:16 <sproingie> tho i have a hard enough time grokking haskell's type system
14:59:27 <alxv> > map (2*)  filter (< 10) [1..]
14:59:28 <b_jonas> > let { xy = x**recip y; } in 38
14:59:28 <lambdabot>   No instance for (GHC.Enum.Enum [t])
14:59:28 <lambdabot>    arising from the arithmetic sequence...
14:59:29 <lambdabot>   1.147202690439877
14:59:40 <b_jonas> > let { xy = y**recip x; } in 38
14:59:41 <lambdabot>   2.0
14:59:42 <jmcarthur> i love agda. i hate trying to use its standard library
14:59:43 <b_jonas> better
15:00:08 <Berengal> jmcarthur: I didn't even try. I defined my own standard library. About five times over in the space of two weeks as I learned more and more
15:00:26 <cytzol> User-defined operators: it's all fun and games until someone defines square root to be infix
15:00:36 <Twey> Hahaha
15:00:37 <jmcarthur> Berengal: yeah that's how i prefer to use agda, too
15:00:41 <jmcarthur> from scratch
15:00:46 <Twey> > isSymbol ""
15:00:48 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:00:48 <lambdabot>         against inferred type...
15:00:50 <jmcarthur> but that's also exactly the problem with it
15:00:52 <Twey> > isSymbol ''
15:00:53 <lambdabot>   False
15:00:59 <Twey> > isAlpha ''
15:01:00 <lambdabot>   False
15:01:01 <Twey> > isNum ''
15:01:03 <lambdabot>   Not in scope: `isNum'
15:01:08 <Twey> Err
15:01:11 <Twey> > isDigit ''
15:01:12 <koeien37> > isSymbol ''
15:01:12 <lambdabot>   False
15:01:13 <lambdabot>   True
15:01:17 <Twey> Hmmm
15:01:19 <Berengal> I sort of like how Set and -> are the only predefined things in agda
15:01:27 <koeien37> > isSymbol ''
15:01:28 <lambdabot>   True
15:01:30 <jmcarthur> me too
15:01:38 <Paczesiowa> is ffi with haskell code tracked in something in agda?
15:01:53 <jmcarthur> Paczesiowa: i don't understand the question as worded
15:01:55 <Berengal> Paczesiowa: How do you mean?
15:02:09 <Paczesiowa> in haskell, ffi to C is tracked with IO monad
15:02:24 <Berengal> Paczesiowa: Not neccessarily.
15:02:41 <jmcarthur> Paczesiowa: you declare a type and declare that such-and-such haskell function is its implementation
15:02:46 <Berengal> You can give IO functions their own type, but anything other than IO and the CTypes is unlikely to work
15:03:12 <Berengal> In Agda you just postulate the existence of types and functions, then import them in a pragma
15:03:24 <Paczesiowa> Berengal: ok, it SHOULD work like that
15:03:34 <Paczesiowa> Berengal: oh, so they are treated like axioms?
15:03:39 <jmcarthur> yes
15:03:46 <Berengal> Paczesiowa: Yep, and not evaluated (obviously)
15:03:55 <Berengal> ((By the compiler that is))
15:04:05 <Paczesiowa> can I get a list of axioms = things I need to believe to accept the rest of the code?
15:04:29 <jmcarthur> hmm
15:04:35 <jmcarthur> that would be kind of nice
15:04:37 <Berengal> That doesn't look decideable to me
15:04:46 <jmcarthur> why not?
15:05:01 <Paczesiowa> Berengal: what? of course it is - just walk ast and report everything
15:05:13 <Berengal> I guess you could just look at the holes...
15:05:15 <jmcarthur> could just output all the functions defined by FFI as well as the core rules of agda
15:05:19 <ben0x539> The most immediately appealing thing about agda is the screnshot in its wikipedia article
15:05:34 * sinelaw races to see
15:05:38 <b0fh_ua> Hi there! I am trying to implement yet another reverse polish notation calculator, like shown at http://pastebin.com/ded2e59
15:05:44 <Paczesiowa> sinelaw: paste link:)
15:05:48 <jmcarthur> ben0x539: haha
15:05:55 <b0fh_ua> for some reason I am getting the error: rpn.hs:13:40: parse error on input `where'
15:05:58 <jmcarthur> http://upload.wikimedia.org/wikipedia/commons/1/10/Agda_proof.jpg
15:06:04 <b0fh_ua> what's wrong there?
15:06:09 <jmcarthur> Paczesiowa: ^^
15:06:56 <Berengal> ben0x539: http://forums.xkcd.com/download/file.php?id=19682
15:06:56 <Twey> b0fh_ua: You did something wrong.
15:07:10 <Twey> Oh, here we are
15:07:16 <Twey> where clauses can't attach to lambdas
15:07:27 <Twey> Only named function definitions
15:07:42 <b0fh_ua> so there's no way to bind x and y?
15:07:49 <Paczesiowa> if I can't get a list of things I need to accept, than how come it is regarded as theorem prover?
15:08:19 <Berengal> Paczesiowa: The underlying theory is Martin-Lf type-theory
15:08:20 <b0fh_ua> or may be I have to use let .. in
15:08:34 <Berengal> That's its axioms
15:08:37 <Twey> b0fh_ua: Use a pattern
15:08:54 <Paczesiowa> Berengal: what good is any theary if you can import unsafePerformIO ?
15:08:57 <Paczesiowa> *theory
15:09:08 <b0fh_ua> with another function?
15:09:12 <Berengal> Paczesiowa: Not very good
15:09:34 <sproingie> great.  haskell wasn't hard enough, now i'm about to dive into Agda
15:09:38 <felzix> I think I might be confused about deconstructing data. Why am I getting this error? http://pastebin.com/d67b67e98
15:09:39 <Berengal> Paczesiowa: But I don't think agda programmers are likely to do that anytime soon ;)
15:10:23 <Paczesiowa> Berengal: I don't trust programmers.
15:10:29 <Berengal> Paczesiowa: And if you want to list out all postulates you can do that with a bit of perl...
15:10:55 <mux> I'm curious about IO handling in Agda; what option is there besides the possibility of runtime type-check failures ?
15:11:05 <sproingie> is there an "intuitionistic type theory for dummies"?
15:11:06 <Paczesiowa> Berengal: oh yes, using perl on some proofs will make me so much calmer!
15:11:17 <Paczesiowa> sproingie: yes
15:11:26 <Paczesiowa> sproingie: Pierce lectures on coq
15:11:45 <jrockway> today must be national "functional programming is bad" day
15:11:50 <opqdonut> hmm?
15:11:56 <jrockway> i have read several articles on HN about how it's impossible to write purely functional code
15:11:58 <Berengal> Those are good, but the agda tutorials on the agda wiki are needed to port them to agda
15:11:59 * mux finally when through the introduction to agda pdf while understanding most if not all of it
15:12:01 <jmcarthur> mux: you could just make an IO monad and import the haskell IO functions
15:12:02 <Paczesiowa> jrockway: national?
15:12:04 <mux> s/when/went/
15:12:08 <sproingie> HN?
15:12:11 <koeien37> jrockway: which nation?
15:12:14 <merijn> sproingie: Hacker News
15:12:14 <jmcarthur> sproingie: beware. agda is a very incomplete world
15:12:18 <koeien37> sproingie: hacker news, http://news.ycombinator.com
15:12:24 <jrockway> the nation of java? ;)
15:12:33 <mux> jmcarthur: I don't see how that prevents runtime type-check failures
15:12:33 <opqdonut> hn is irrelevant :)
15:12:36 <jrockway> i really like being told that something i do every day is impossible :)
15:12:37 <cytzol> felzix: There's a difference between "Entity a b c d e" and "(a,b,c,d,e)". You can deconstruct an Entity using something like (Entity _ _ ex ey _)
15:12:51 <sproingie> jmcarthur: some days i feel like that about haskell
15:12:53 <Berengal> mux: IO actions aren't dependently typed.
15:13:00 <mux> from what I understand actually, running a program and type-checking it are the same thing in DT languages
15:13:01 <merijn> jrockway: I find the quality of links on HN has degraded somewhat in the past half year, sadly
15:13:04 <mle> you can deconstruct tuples also
15:13:06 <jrockway> yeah, i think you are write
15:13:08 <jrockway> * right
15:13:09 <mle> just looks different
15:13:15 <jmcarthur> sproingie: what problems have you hit that make it feel incomplete?
15:13:15 <jrockway> (not enough coffee, lol)
15:13:21 <jvoorhis> conal: could explain some of the information ordering concepts you used in your exact integration article?
15:13:21 <koeien37> (_,_,ex,ey,_)
15:13:24 <sproingie> jmcarthur: just "i wish i had a binding for that"
15:13:28 <mux> Berengal: but I suppose there's a way to pass values from IO to dependently typed functions?
15:13:39 <Berengal> sproingie: Agda doesn't even have numbers. You'll like it :P
15:13:48 <sproingie> Berengal: awesome.  i hate numbers.
15:13:51 <Berengal> mux: Oh, there is, as products
15:14:01 <Paczesiowa> what about agda's type inference?
15:14:09 <Berengal> mux: Dependent products that is
15:14:15 <conal> jvoorhis: i learned about it in a book by joseph stoy about denotational semantics.
15:14:16 <Berengal> Paczesiowa: undecideable, but works in simple cases
15:14:17 <mux> Paczesiowa: there is not type inference as in haskell
15:14:17 <jmcarthur> mux: afaik there isn't a clear way to execute actions that don't trace back to main
15:14:18 <jvoorhis> conal: just as i started to feel comfortable with bottom, you've thrown top at me :)
15:14:30 <conal> jvoorhis: hah! :)
15:14:32 <mux> Paczesiowa: you can ask Agda to infer /some/ things by using a specific syntax
15:14:50 <mux> well I'll have to read the IO module of Agda
15:14:52 <conal> jvoorhis: i guess the stoy book is rather out of date now.
15:15:02 <conal> i've heard good things about the wikibooks article on denotational semantics.
15:15:04 <mux> the introduction pdf is nice even though I wish it explained some things better
15:15:09 <Twey> b0fh_ua: http://pastebin.com/m6004535f
15:15:21 <conal> jvoorhis: and i'd be happy to walk you through some simple intuition.
15:15:27 <mux> it took me a while to get the type of the apply function
15:15:45 <felzix> if I change the lambda's pattern matching to not use commas, I get a "Parse error in pattern"
15:15:47 <Twey> Er, that's a better way of doing what you were doing, though I don't think it'll work quite as you expect
15:15:54 <conal> does anyone else have suggestions for jvoorhis on information orderings?
15:15:55 <Paczesiowa> no, here's what I mean: I don't think that haskell has type inference just like that. haskell has nicely separated two things - easy code that has type inference and complicated code without it (classes and instances) and I absolutely love it.
15:16:10 <jvoorhis> conal: is this the article you mean? http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
15:16:23 <conal> jvoorhis: yeah
15:17:15 <cytzol> felzix: you're doing "\(_ _ ex ey _)" ?
15:17:18 <Berengal> Paczesiowa: In Agda you don't infer types, you infer values, of which types are a subset
15:17:37 <felzix> cytzol: yes: (filter (\(_ _ ex ey _) ->  x==ex && y==ey)
15:17:39 <Berengal> Paczesiowa: Obviously, this usually doesn't work
15:18:26 <Paczesiowa> and that's how things should work, if you don't do anything complicated (like returning different types, or require foralls) it should just work, you want something more interesting - you provide type sigs
15:18:30 <cytzol> felzix: You need to deconstruct it out of the Entity: "\(Entity _ _ ex ey _)"
15:18:36 <Paczesiowa> Berengal: why?
15:18:47 <felzix> cytzol: OH. That works, thank you!
15:18:49 <jvoorhis> conal: if top being "overdefined" means it's contradictory, then it probably never shows up while coding haskell does it?
15:19:00 <cytzol> felzix: :)
15:19:20 <jvoorhis> conal: but _|_ mostly shows up as a convenient notation for nonterminatino?
15:19:23 <jvoorhis> *nontermination even
15:19:25 <Berengal> Paczesiowa: Because there's very seldom a single value that can be used somewhere, and even harder to prove that
15:19:38 <jmcarthur> my problems with agda are really similar to the problems experienced by a beginner to haskell. i feel that things quickly become a tangle of mathematical concepts and extremely general operations
15:20:07 <conal> jvoorhis: i think you're right about top not arising in haskell programming.  it was in dana scott's original semantics work.
15:20:11 <Berengal> Paczesiowa: So you have to provide type signatures for everything, which can become a bit long-winded at times
15:20:21 <conal> jvoorhis: which showed the consistency of the lambda calculus.  a very important result.
15:20:22 <jmcarthur> as somebody who thinks of himself as fairly experienced with haskell now, i realize the folly of making quick judgements about very high level languages like that though
15:20:33 <Paczesiowa> Berengal: ok, how about an example: addition on natural numbers (peano), HM can reconstruct its type
15:20:38 <koeien37> http://news.ycombinator.com/item?id=1022430 lots of misundersatnding of Haskell here
15:20:41 <monochrom> Hmm the main attraction of STM to me (compared to MVar) is orElse so I can wait on two channels.
15:20:57 <zygoloid> conal: aren't all total values top?
15:20:59 <jvoorhis> conal: yeah, it's explicitly verboten, while haskell programs can't help but include _|_ (regardless of the story about exceptions and other features)
15:21:03 <Paczesiowa> Berengal: I don't need agda to come up with printf's type
15:21:03 <monochrom> But usually I don't need it.
15:21:10 <conal> jvoorhis: _|_ is more than a notation for nontermination.  it's an integral part of the mathematical theory of recurson.
15:21:30 <Berengal> Paczesiowa: Agda probably could as well, but it won't if it's a top-level declaration. It does lambdas, lets and wheres
15:21:34 <conal> zygoloid: not in the sense of scott.
15:21:53 <jvoorhis> conal: oh, i was only referring to its use by haskellers, not defining it
15:21:57 <conal> zygoloid: in scott's lattice theory, top is dual to bottom.  it's *the* (not *a*) greatest value.
15:22:16 <Berengal> Paczesiowa: Part of it is also because of agda's syntax. You can name several constructors the same, and use types to disambiguate them
15:22:34 <Paczesiowa> Berengal: haskell doesn't have problems with that
15:22:39 <mux> I fail to see a thing Agda couldn't do
15:22:49 <conal> jvoorhis: haskell could have top if we interpreted case-based definition differently.
15:23:03 <Berengal> Paczesiowa: No, because Haskell doesn't have that disambiguation between constructors
15:23:07 <conal> jvoorhis: in a more modular & order-independent way than we do now.
15:23:09 <jvoorhis> conal: you mean as a default branch?
15:23:09 <jmcarthur> i'm not sure in what sense we are talking about agda "doing" anything
15:23:11 <mux> I bet you could alter the AST dynamically while proving that your transformations are type-safe
15:23:26 <conal> jvoorhis: i'll find a relevant blog post ...
15:23:30 <jmcarthur> that's genuine confusion, not commentary on the nature of imperative and declarative thought
15:23:32 <Berengal> mux: Agda isn't turing complete (if you listen to the termination checker)
15:23:57 <Paczesiowa> Berengal: do I have to?
15:24:07 <conal> jvoorhis: http://conal.net/blog/posts/lazier-function-definitions-by-merging-partial-values/
15:24:37 <Berengal> Paczesiowa: Unless you want to write everything in a single module, you do.
15:24:56 <Berengal> Paczesiowa: Also, lack of termination is marked with a very ugly salmon
15:25:10 <zygoloid> conal: i suppose it matters which lattice we're referring to; i was imagining a lattice of consistent partial values (which by definition has a meaningful top)
15:25:33 <conal> jvoorhis: i really like the idea of using lub as a way to compose case-based functions from simpler pieces.  in that case, top is a possibility.
15:26:08 <samnardo_> what's a better way of:    unwords $ replicate 10 "hello"   ?
15:26:10 <conal> zygoloid: iirc, flat types don't have top
15:26:23 <conal> zygoloid: ie the def of "flat" i remember & use
15:26:34 <conal> eg Bool & Integer
15:26:49 <monochrom> I think unwords $ replicate 10 "hello" is as good as it gets.
15:26:52 <jvoorhis> conal: so instead of wrapping up branches in a case primitive, you'd use lub to stitch together values that are either defined or bottom?
15:27:02 <conal> jvoorhis: yes!
15:27:22 <conal> jvoorhis: which has a lovely symmetry now missing in haskell.
15:27:23 <jvoorhis> that's actually rather intuitive
15:27:23 <zygoloid> conal: () is top for the () type i think. but an ordering of definedness for a whole type wasn't what i was thinking of anyway :)
15:27:33 <koeien37> samnardo_: sounds a fine way to write it
15:27:36 <zygoloid> different lattice, different top ;)
15:27:46 <koeien37> samnardo_: in general you might want to use intercalate and/or intersperse from Data.List
15:27:47 <conal> jvoorhis: and it also restores the declarative meaning that haskell def-by-case lacks.
15:28:05 <jvoorhis> conal: you'd have to sacrifice a few of case's features though
15:28:10 <samnardo_> ah okay :) just seems a little odd to create a list to then just join it all up
15:28:17 <conal> zygoloid: yeah.  () is top for ().  just as () could be (but isn't) bottom for ()
15:28:24 <samnardo_> koeien37: noted
15:28:51 <conal> jvoorhis: the implicit else?
15:29:00 <jvoorhis> conal: how would you compose a branch that matches (Just 42) and another that matches (Just _) ?
15:29:03 <conal> jvoorhis: ie the implicit 'not'?
15:29:12 <jvoorhis> conal: i think that's what i mean
15:29:25 <conal> jvoorhis: yeah.  and hence the possibility of top
15:29:41 <conal> jvoorhis: when both match and give contradictory results
15:30:29 * hackagebot upload: ldif 0.0.2 - The LDAP Data Interchange Format (LDIF) parser (RadoslavDorcik)
15:31:17 <conal> jvoorhis: i'm using 'contradictory' informally here, to mean an additional value when there's no top already.  (ie not () or an isomorphic type)
15:31:54 <jvoorhis> and what then? would it produce an error? or return a set? or something entirely different
15:32:13 <conal> jvoorhis: operationally?
15:32:21 <conal> jvoorhis: or denotationally?
15:32:34 <jmcarthur> i'm actually curious about it operationally
15:32:49 <jmcarthur> same behavior as for undefined?
15:32:53 <jvoorhis> i suppose i'm hung up on pragmatics how can top be useful?
15:33:03 <conal> jmcarthur: no idea.
15:33:30 <conal> one possibility is to prove consistency, rather than allowing top.
15:33:32 <jvoorhis> conal: the denotational answer then :)
15:33:41 <conal> that's how i use unamb/lub
15:33:53 <jvoorhis> conal: that makes sense
15:33:56 <jmcarthur> just like we can prove termination rather than allowing _|_?
15:34:08 <jvoorhis> conal: hence unambiguity
15:34:10 <conal> jvoorhis: denotationally, just add a top-most element to the existing type.
15:34:24 <conal> jvoorhis: yes.  in other words, "consistency".
15:34:39 <conal> s/words/word/
15:34:57 <conal> jmcarthur: yeah.  a nice symmetry.
15:35:14 <jvoorhis> conal: so what if i wanted to abuse unamb to make an inconsistent choice? would it behave nondeterministically?
15:35:49 <conal> also, by decomposing case into partial+lub, we get a way to use parallel processing, and a nice way to modularize in general.
15:35:55 <jmcarthur> jvoorhis: on an operational level, yes
15:36:14 <conal> jvoorhis: i guess so.
15:36:19 <jvoorhis> jmcarthur: thanks, that's what i meant :)
15:36:30 <jvoorhis> and sure, that's not a valid thing to do with unamb
15:36:43 <conal> jvoorhis: here's a related question: what if we want to abuse our type system and allow type-incorrect expressions.  what would they mean?
15:37:35 <monochrom> they would mean happiness.
15:37:37 <conal> jvoorhis: type systems let us cop out and say some expressions don't have meaning at all.  in a sense, they're self-contradictory.
15:37:42 <sproingie> chaos.  anarchy.  dogs and cats living together.
15:37:47 <watermind> samnardo_:  take 60 $ cycle " hello"
15:37:48 <jvoorhis> conal: i'm not sure there's one answer; i want to say _|_
15:37:49 <conal> heh
15:38:05 <ray> it's not conal's fault that he can't enforce the restriction on unamb
15:38:06 <watermind> samnardo_:  not great but oh well...  a bit shorter
15:38:13 <jvoorhis> conal: or perhaps it's a member of the union of all types
15:38:17 <watermind> samnardo_:  and not exactly equiv but close enough :P
15:38:31 <jvoorhis> in which case you're left with one type
15:38:43 <ray> if it's anyone's fault, that person is by definition god
15:38:48 <Saizan> conal: write a type system were using unamb unsafely doesn't typecheck, then you can use that line :)
15:38:48 <conal> jvoorhis: yeah.  i think that all-types answer was scott's original answer.
15:39:02 <watermind> there's repeat (inf) and replicate (fin) but only cycle (inf) :S
15:39:11 <conal> Saizan: easy.
15:39:14 <mreh_> the cabal link on haskell.org is broken
15:39:15 <watermind> would be nice to have something like cycle but finite... for completude
15:39:17 <samnardo_> watermind: i think repeat makes more sense than cycle
15:39:24 <watermind> samnardo_: yes it does
15:39:24 <mreh_> the cabal-install tarball
15:39:29 <watermind> samnardo_: I agree too
15:39:38 <conal> Saizan: that's what dependent types do well.
15:39:58 <monochrom> I agree with everyone unambiguously and lubly.
15:39:59 <koeien37> :t concat . replicate 37
15:40:01 <lambdabot> forall a. [a] -> [a]
15:40:08 <ray> you are so lubly
15:40:16 <samnardo_> I've got free time, and nothing to code :(
15:40:29 <sproingie> lub is hurting my brane
15:40:30 <Saizan> conal: unamb :: (x y : A) -> (x = y) -> A ?
15:40:37 <mreh_> samnardo_ do you know haskore?
15:40:41 <conal> jvoorhis: the original scott model was for the *untyped* lambda calculus.  so there was a single universal type.
15:40:49 <samnardo_> mreh_: nope
15:41:07 <conal> Saizan: nearly.  the precondition is looser.  and lub's precondition is looser (more general) still.
15:41:07 <samnardo_> googling now
15:41:32 <jvoorhis> conal: oh, that reminds me, i've been thinking more about how FRP and hudak's PTM could fit together
15:41:46 <conal> Saizan: x & y don't have to agree.  they just mustn't disagree.
15:41:50 <jmcarthur> conal: is it still looser in the absense of nontermination?
15:42:23 <conal> jvoorhis: yeah?
15:42:25 <samnardo_> does anyone else get errors with cabal and snow leopard? (error: CPU you selected does not support x86-64 instruction set)
15:42:46 <Saizan> i guess you'd use bisimulation for codata
15:42:46 <jmcarthur> conal: actually, is it even meaningful in the absense of nontermination?
15:42:56 <conal> jmcarthur: unamb isn't looser w/o _|_.  lub is.
15:43:27 <monochrom> lub is easier to learn than recursion. This is because recursion requires lub.
15:43:32 <conal> jmcarthur: denotationally uninteresting, but operationally useful.
15:43:39 <jvoorhis> conal: i've been musing about PTM values who are functions from time to monoids
15:43:40 <conal> monochrom: yeah.
15:43:41 <jmcarthur> actually, it occurs to me that unamb can be looser anyway
15:43:44 <Paczesiowa> is Marc Weber here?
15:44:11 <jmcarthur> meaning a = meaning b
15:44:37 <Saizan> well, i didn't say what = meant :P
15:44:44 <jmcarthur> i guess you're right
15:44:46 <jvoorhis> conal: substituting lazy Media (Behavior a) trees for events and switchers seems promising to me so far
15:44:48 <conal> jmcarthur: 'meaning a = meaning b' is what i mean by ==
15:44:52 <jmcarthur> i was assuming like Haskell's Eq for some reason
15:44:53 <conal> jmcarthur: worth pointing out, though.
15:45:18 <jvoorhis> conal: parallel composition results in the application of mappend to each branch
15:45:20 <jmcarthur> err
15:45:41 <conal> jmcarthur: if an Eq instance disagrees with ((==) `on` meaning), then there's an abstraction leak.
15:45:43 <jmcarthur> time to stop talking. my fingers are moving faster than my mind
15:45:56 <jvoorhis> conal: and sequential composition translates the domain of the behavior function
15:46:01 <Saizan> though if we use extensional equality type checking becomes undecidable.
15:46:08 <zygoloid> conal: looking at luqui's comment here: http://conal.net/blog/posts/merging-partial-values/ it's not possible to create an if' with his semantics is it?
15:46:10 <conal> jvoorhis: yep.  sounds right to me.
15:46:26 * conal looks
15:46:30 <jvoorhis> conal: have you considered that and discarded it already? :)
15:48:33 <conal> zygoloid: where equality is decidable, if' is easy.
15:48:47 <mreh_> the cabal-install link on haskell.org is broken, should this be logged?
15:48:59 <conal> jvoorhis: what the semantic model for Media?  i've forgotten.
15:49:11 <sinelaw> luqui, hey
15:49:25 <conal> jvoorhis: i'm guessing it's something function-of-time-ish, rather than event-ish.
15:49:36 <luqui> sinelaw, hola
15:49:41 <jvoorhis> conal: iirc it's a sort of trace
15:49:56 <mreh_> preflex: seen mmorrow
15:49:56 <preflex>  mmorrow was last seen on #haskell 15 hours and 16 minutes ago, saying: * mmorrow refocuses back on topic
15:49:59 <sinelaw> luqui, just got your message but I don't remember what it's about
15:50:02 <conal> jvoorhis: hm.  sounds operational.  i'll have to re-read.
15:50:05 <jvoorhis> conal: that is, something like [(Time, Occurence)] where the list is ordered by Time
15:50:09 <Saizan> mreh_: i can't find it
15:50:28 <mreh_> Saizan, http://www.haskell.org/cabal/download.html
15:50:28 <conal> jvoorhis: and Occurrence?
15:50:30 <jvoorhis> conal: http://www.haskell.org/yale/papers/polymedia/hudak-RR-1259.pdf
15:50:45 <jvoorhis> conal: sorry, i'm using Occurrence to stand for `a' in Media a
15:50:48 <zygoloid> conal: for it to be useful, if' can't have a precondition that its two branches have a defined lub
15:51:12 <Saizan> mreh_: which link is broken?
15:51:31 <mreh_> Download: cabal-install-0.6.2.tar.gz
15:51:31 <conal> zygoloid: yeah.  would be terribly restrictive.
15:51:32 <zygoloid> conal: (luqui's implementation is just const lub)
15:51:54 <Saizan> mreh_: it works for me
15:52:02 <jvoorhis> conal: perhaps the ordering isn't strictly necessary, and the semantics do seem denotational to me
15:52:04 <conal> zygoloid: use 'assuming' from unamb/lub.
15:52:06 <mreh_> Saizan: wut?!
15:52:51 <luqui> zygoloid, that implementation is wrong
15:52:52 <mreh_> Saizan: I was receiving a page load error, i'll just wget it
15:52:57 <luqui> sinelaw, convReal
15:53:06 <sinelaw> luqui, yeah i just remembered :)
15:53:24 <zygoloid> luqui: do you know of a correct implementation?
15:53:29 <Saizan> mreh_: if you're on ghc 6.12 you'll need 0.8 from hackage, btw
15:53:35 <conal> jvoorhis: i'm fine with [(T,a)].  not what i imagined with "trace".
15:53:37 <sinelaw> luqui, my application actually sort of works
15:53:39 <mreh_> Saizan, 6.10
15:53:44 <mreh_> ;)
15:53:47 <luqui> sinelaw, :-)
15:54:00 <conal> jvoorhis: that model is the one reactive uses for events.  how about behaviors?
15:54:08 <dibblego> @hoogle (Fractional a) => a -> Double
15:54:08 <lambdabot> Prelude recip :: Fractional a => a -> a
15:54:08 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
15:54:08 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
15:54:12 <jvoorhis> conal: suggest a better name for [(T,a)] ? ;)
15:54:42 <conal> jvoorhis: i call it "E a" in my push-pull frp paper
15:54:45 <sinelaw> luqui, would be nice to have opengl bezier splines in the library
15:54:45 <jvoorhis> conal: perhaps the meaning of Media (Behavior a) could be Behavior a
15:54:51 <monochrom> ListOfTa
15:54:58 <Paczesiowa> :t toFractional
15:54:58 <luqui> sinelaw, you mean glu?
15:54:59 <lambdabot> Not in scope: `toFractional'
15:55:06 <dibblego> @type realToFrac
15:55:07 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
15:55:08 <luqui> sinelaw, i never used those
15:55:11 <zygoloid> conal: can you give me another clue? "if' b x y = assuming b x `unamb` assuming (not b) y" doesn't work :(
15:55:18 <sinelaw> luqui, neither did I
15:55:20 <conal> jvoorhis: i want meaning to be compositional, so the meaning of Media would determine the meaning of Media (Behavior a)
15:55:34 <luqui> zygoloid, i'm pretty sure that if it's not possible, there is a straightfoward proof of that fact
15:55:39 <conal> zygoloid: assuming (x == y)
15:55:44 <sinelaw> luqui, but I need them, so for now i "manually" calculate samples on the splines and use your lines
15:55:48 <jvoorhis> conal: let me get back to you; i know it could be done :)
15:55:56 <luqui> zygoloid, and my hunch uis that it's not possible.  anyway can't dedicate brainpower to it now :-P
15:56:13 * sproingie shudders listening to leonard cohen mangling his own song
15:56:29 <zygoloid> conal: that fails for the "if' b [1..] [1..]" example :(
15:56:32 <sproingie> "but you don't really care for music do yooooooo" (yes he pronounces it long-u)
15:56:41 <mreh_> cannot find -lgmp?
15:56:50 <luqui> sinelaw, well, patches welcome.  can't say i'm planning an update to include them :-/
15:56:57 <zygoloid> luqui: my feeling is that it's impossible. but i can't quite see /why/ :)
15:56:58 <mreh_> that's from ./bootstrap.sh
15:57:13 <jvoorhis> conal: but it would probably help to write it out before talking about it right now :)
15:57:15 <sinelaw> luqui, of course - but i'll wait till you release a new version, i think. i stopped working on it for the meanwhile anyway
15:57:16 <Saizan> mreh_: you've to install libgmp-dev, or what your distro has
15:57:30 <sinelaw> luqui, but i'll do it eventually, i think
15:57:43 <conal> jvoorhis: you bet.  and i'm glad you're thinking about these issues.  btw i wrote a couple of blog posts inspired by an aha! about relative time frp.  they're the ones with "signals" & "segments" in the title.  much later, after talking to you, i realized they're very similar to paul h's temporal media
15:57:45 <mreh_> Saizan: good call
15:57:51 <Saizan> mreh_: gmp is used to implement Integer
15:58:57 <luqui> sinelaw, yeah a decent plan -- the code is pretty ugly, i'd like to give it a cleanup
15:59:09 <conal> zygoloid: yeah.  that's what i meant about where equality is decidable.
15:59:21 <zygoloid> conal, luqui: i think it can be done, but it needs an additional primitive: a recursive asAgree would be sufficient.
15:59:42 <jvoorhis> conal: yeah! and i'm thinking about how to compose segments
15:59:56 <conal> jvoorhis: cool.
16:00:00 <luqui> zygoloid, glb!
16:00:05 <zygoloid> then it's just "if' b x y = (if b then x else y) `recAgree` x `recAgree` y"
16:00:09 <luqui> (you bastard, taking me away from work!)
16:00:20 <zygoloid> luqui: haha, yes!
16:00:51 <luqui> if (b then x else y) `lub` (x `glb` y)
16:01:03 <zygoloid> oops, yeah
16:01:06 <luqui> modulo syntax stupidity
16:01:26 <luqui> that's kinda pretty
16:01:46 <zygoloid> obvious in retrospect :)
16:02:27 <zygoloid> and easy to define in plain haskell'98 to boot...
16:02:48 <conal> luqui: i like that definition.  even if b == _|_, we get the information common to x & y
16:03:08 <mreh_> where do I config cabal to install in the user directory, is that ./cabal/config?
16:03:30 <conal> luqui: the chasing-bottoms guys also played with lub & glb
16:03:32 <Berengal> mreh_: yes
16:03:38 <Saizan> mreh_: cabal-install installs in the user directory by default
16:03:48 <Berengal> mreh_: Well, ~/.cabal/config
16:03:56 <luqui> chasing bottoms eh?
16:04:00 <Saizan> mreh_: Setup.hs scripts don't respect any configuration file, but you can pass --user to configure
16:04:03 <mreh_> Saizan: I noticed, it's installed it in my root's directory
16:04:24 <luqui> conal, i feel like without even realizing it we are building a mental foundation for "connected computing" like we were talking about
16:04:37 <Saizan> mreh_: oh, don't run cabal-install as root :)
16:04:37 <luqui> it's in the air :-)
16:04:51 <conal> luqui: yeah.  i'm glad.
16:04:58 <mreh_> Saizan: o noes!
16:05:01 <mreh_> too late
16:05:22 <sinelaw> connected computing?
16:05:27 <Saizan> you can use --root-cmd and --global if you want to do global installs
16:06:00 <luqui> sinelaw, all the types we are used to dealing with in computing are "totally disconnected" in a topological sense
16:06:14 <luqui> you can eg. pattern match to split the type into two disjoint subsets
16:06:19 <dibblego> where is instance Functor (Either a) ?
16:06:32 <mreh_> ./make uninstall?
16:06:38 <luqui> sinelaw, i've been wondering what computing is like with connected types, like the real numbers for example
16:06:45 <luqui> but more general than just computing with reals, of course
16:06:48 <conal> luqui: is Stream an exception?
16:06:52 <koeien37> Control.Monad.Instances
16:07:13 <luqui> conal, eg. Stream Bool can be split into those with head True and head False
16:07:34 <conal> luqui: similarly for real numbers, right?
16:07:41 <luqui> conal, how so?
16:07:44 <sinelaw> luqui, and reals can be split into positive and non-positive?
16:07:53 <luqui> sinelaw, what about 0?
16:08:02 <conal> luqui: start with bit 1 vs bit 0
16:08:20 <sinelaw> luqui, you suggest that one subset must always be open?
16:08:31 <luqui> conal, the bits repr of real numbers does not have computable operations
16:08:45 <luqui> conal, eg. what is the first bit of 0.01111... + 0.0111 ...
16:08:59 <conal> luqui: i'm trying to build intuition for connected types.
16:09:26 <conal> luqui: are there other reps with computable ops?
16:09:43 <sinelaw> connected types can't ever be split cleanly?
16:09:49 <sinelaw> is that what you mean
16:09:52 <conal> luqui: very related to my current ponderings about perfect integration & anti-aliasing &c
16:09:56 <luqui> conal, yeah. my favorite is "redundant ternary". split the unit interval into 3 intervals (0,1/2), (1/4,3/4), and (1/2,1)
16:10:34 <luqui> recursively
16:10:55 <conal> luqui: cool.  ref?  i got interested in real number computation last year as an application of unamb/lub
16:11:10 <luqui> conal, andrej bauer is where i learned most of my tidbits
16:11:18 <conal> luqui: thx :)
16:19:14 <mreh_> sorry, how do I do a global cabal-install, the bootstrap.sh doesn't have that option
16:19:43 * hackagebot upload: xsd 0.2 - XML Schema data structures (TonyMorris)
16:19:59 <tommd> cabal install package --global
16:20:08 <tommd> or 'man cabal'
16:21:03 <conal> luqui: i haven't found anything by andrej bauer on redundant ternary rep.  do you have any more specific pointers?
16:21:12 <zygoloid> conal, luqui: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15280#a15280
16:22:09 <conal> zygoloid: great.  that code looks pretty familiar.  is it based on Lub?
16:22:15 <zygoloid> yeah :)
16:22:49 <conal> zygoloid: i like the implicit bottoms for Either
16:22:52 <zygoloid> i disclaim any copyright on it. if you want to add it to the lub package i'd be honoured :)
16:22:59 <zygoloid> i liked how that worked out too
16:24:01 <conal> zygoloid: i see that glb pair is simpler than lub pair
16:24:21 <conal> zygoloid: oops!  did you type-check?
16:24:57 <zygoloid> no, i don't have a working 6.10 install on this machine so i can't install the lub package :)
16:25:18 <conal> zygoloid: you have pre-6.10?
16:25:35 <conal> zygoloid: the pair case doesn't pass my mental type-checker
16:25:45 <conal> zygoloid: s/case/instance def/
16:26:08 <Cale> dixie: Just saw your monty hall implementation on hpaste. If you swap the IO monad and random number generation out for a probability monad, you can compute exact probabilities instead.
16:26:33 <zygoloid> conal: whoops :)
16:26:51 <Saizan> mreh_: ah, for the bootstrap.sh script i think you're supposed to pass only --global and run it as root
16:27:01 <zygoloid> conal: also missing an import Control.Applicative
16:27:42 <luqui> conal, oh, i don't think that one was from andrej.  he likes dedekind cuts iirc.  This was from a post i saw on cafe a long time ago, don't remember who
16:27:46 <luqui> it was about integration though...
16:27:46 <dibblego> how do you write a library that depends on another which you might also be updating when using cabal?
16:28:02 <Cale> An easy implementation of a monad for keeping track of probabilities is as  newtype P a = P (WriterT (Product Rational) [] a)
16:28:07 <conal> luqui: kthx
16:28:47 <Cale> Or I think http://hackage.haskell.org/package/ProbabilityMonads has one you can use
16:29:43 <luqui> conal, sorry not cafe, i meant planet haskell
16:29:50 <luqui> unfortunately, not so easy to search :-(
16:30:41 <conal> luqui: hm, maybe russell
16:31:33 <conal> is roconnor around here these days?
16:32:05 <sinelaw> Does anyone know of a haskell library for random processes/variables? I can't see  anything related
16:32:23 <skorpan> conal: 20:42 *** roconnor_ QUIT Remote closed the connection
16:32:27 <luqui> sinelaw, what do you need to do with them?
16:32:35 <conal> skorpan: thx
16:32:38 <sinelaw> luqui, nothing, i'm just interested in that theory
16:33:06 <luqui> sinelaw, ah. from what i have seen, nothing formal.
16:33:27 <sinelaw> luqui, and how easy it would be to explain some concepts about them perhaps as haskell datatypes
16:34:09 <sinelaw> data RandomVariable = RV a b
16:34:13 <luqui> sinelaw, oh interesting.  here's encouragement to develop something!  I always feel dirty using MonadRandom, even though it is semantically nice
16:34:31 <sinelaw> a = an event space; b = numeric type
16:34:48 <sinelaw> semantically, RandomVariable = a -> b
16:34:51 <luqui> sinelaw, oh hmm, now you are talking about what i don't know about.
16:35:01 <luqui> sinelaw, oh it's a distribution?
16:35:18 <luqui> a is a sigma algebra?
16:35:22 <sinelaw> yes
16:35:35 <sinelaw> wait...
16:35:37 <sinelaw> maybe not
16:35:57 <sinelaw> luite, I think so, yes
16:36:06 <luite> :)
16:36:25 <sinelaw> oops. luqui :)
16:36:27 <luqui> luite, good for you to know :-)
16:37:14 <sinelaw> luqui, so following conal's idea we already have Functor and Applicative instances for RandomVariable
16:37:30 <luqui> sinelaw, i believe it is a natural functor in *a*
16:37:55 <sinelaw> natural functor?
16:38:09 <luqui> sinelaw, not CT-speak.  natural just means "i think it makes sense"
16:38:30 <sinelaw> oh, of course. because it's simply a function
16:39:13 <luqui> sinelaw, i gave MonadRandom a semantics here: http://lukepalmer.wordpress.com/2009/01/17/use-monadrandom/
16:39:14 <conal> like set a being a -> Bool, but being a functor in a
16:39:15 <sinelaw> so a continuous random variable is one for which 'a' is continuous
16:39:23 <luqui> conal, right!
16:39:45 <Cale> sinelaw: I just mentioned one, about 1 minute before you asked your question
16:39:46 <luqui> that's the stone duality, I think (just learned about it)
16:39:56 <conal> oh!
16:40:24 <luqui> that the category of continuous functions on points is dual to functions on open sets
16:40:30 <luqui> i.e. the arrows are going opposite directions
16:40:39 <Cale> You can write one rather easily using  WriterT (Product Rational) []
16:40:59 <sinelaw> Cale, i saw that but i just don't understand that yet
16:41:01 <Accidus> luqui, erm, not entirely true
16:41:09 <luqui> Accidus, yay enlighten me!
16:41:12 <sinelaw> Cale, so i'm not sure i know what you're talking about
16:41:13 <burp> http://underhanded.xcott.com/ let's do something like this for haskell ;)
16:41:15 <Cale> sinelaw: ah, okay
16:41:22 <burp> "Every year, we will propose a challenge to coders to solve a simple data processing problem, but with covert malicious behavior. Examples include miscounting votes, shaving money from financial transactions, or leaking information to an eavesdropper. The main goal, however, is to write source code that easily passes visual inspection by other programmers."
16:41:24 <Accidus> luite, f^-1 is not necessarily a function
16:41:28 <Cale> @unmtl WriterT (Product Rational) []
16:41:29 <lambdabot> err: `WriterT (Product Rational) []' is not applied to enough arguments, giving `/\A. [(A, Product Rational)]'
16:41:33 <Cale> @unmtl WriterT (Product Rational) [] a
16:41:33 <lambdabot> [(a, Product Rational)]
16:41:37 <luite> hehe I'd better join the discussion ;)
16:41:47 <Accidus> luqui, even
16:41:49 <sinelaw> luite, I think so, yes
16:41:52 <sinelaw> :) :)
16:41:59 <luqui> Accidus, er, inverse images?
16:42:01 <Cale> So these things look like lists of pairs of values of type a, and rational numbers (which are combined using multiplication)
16:42:14 <luqui> Accidus, did I have it approximately right, then?
16:42:33 <Cale> You can think of each rational as being the probability of that value occurring.
16:42:39 <sinelaw> why rational?
16:42:47 <Accidus> luqui, I mean, it's the same kind of collections  of objects and morphisms
16:42:57 <Cale> Well, in case you want exact results.
16:43:09 <Cale> You could also use Float or something
16:43:16 <Accidus> luqui, So functions are the arrows, but if f is a  continuous function from A to B then it is a morphism from B to A
16:43:39 <sinelaw> Cale, so what does that monad give you? excuse my ignorance about moands
16:43:42 <sinelaw> *monads
16:44:10 <sinelaw> why not just have RV a b, with semantics of a->b?
16:44:21 <Accidus> luqui, The best place I found for dual category (up to now) is with functors
16:44:28 <sinelaw> (plus extra stuff about randomness?)
16:44:52 <Accidus> luqui, So when you want to talk about two different categories, but the functor from one to the other is contravariant, you switch to the opposite category
16:45:16 <Accidus> luqui, Because if both categories have the same direction, there's no point in talking about the dual.
16:45:23 <Cale> sinelaw: Well... hmm...
16:45:45 <Cale> sinelaw: It becomes pretty hard to even make that a Functor.
16:45:55 <Cale> (though it's a contravariant functor)
16:46:13 <luqui> Accidus, ok.  are we talking about stone duality?
16:46:29 <Cale> In order to do that, you'd have to be able to sum over values of an arbitrary type
16:46:46 <Cale> which is pretty tough
16:47:15 <Accidus> luqui, yeah
16:47:26 <Accidus> luqui, I was about to mention that
16:47:44 <Accidus> luqui, so the point is that the opposite category is considered different
16:47:53 <luqui> Accidus, ok, cool.  just getting my bearings.
16:48:04 <Cale> sinelaw: Does that roughly make sense?
16:48:21 <sinelaw> Cale, missing too many definitions here
16:48:33 <Cale> sinelaw: Let's just start with [(a,Rational)]
16:48:52 <Cale> It's easy to write  fmap :: (a -> b) -> [(a,Rational)] -> [(b,Rational)]
16:49:03 <sinelaw> yeah
16:49:19 <Cale> We can define  return x = [(x,1)]
16:49:53 <luqui> Accidus, continue?  or... is that it?
16:49:57 <Cale> and all that's left is  join :: [([(a,Rational)],Rational)] -> [(a,Rational)]
16:49:58 <Accidus> so in Stone duality the "almost equivalence" is not between Topological and Frames but opposite of Frames
16:50:03 <luqui> <- bad timing :-)
16:50:20 <Accidus> luqui, It's just that I'm not as familiar with the details of the Stone duality as I should be
16:50:47 <Accidus> luqui, Sheaves in Geometry and Logic has been on my reading list for ages, but I still haven't gone through all of Mac Lane's
16:51:04 <Cale> That first type is a little hard on the eyes perhaps, but if we think of  [(a,Rational)]  as a sort of weighted formal sum of elements of type a, then it becomes clear what join should be doing
16:51:18 <sinelaw> hm
16:51:21 <Accidus> But at least I'm nearly done with the thesis proposal :)
16:51:54 <Cale> join xss = [(x,p*q) | (xs,q) <- xss, (x,p) <- xs]
16:52:02 <luqui> Accidus,
16:52:24 <skorpan> :t join
16:52:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:52:32 <Accidus> luqui, ?
16:52:40 <skorpan> @src join
16:52:41 <lambdabot> join x =  x >>= id
16:52:42 <luqui> Accidus, :-)  ok, so a frame is eg. an open set?  and the topological is the category of continuous functions?
16:52:48 <luqui> er, morphisms
16:52:54 <Accidus> luqui, not by far
16:53:05 <luqui> great %-)
16:53:07 <luqui> okay what's a frame
16:53:10 <Cale> This effectively takes a random variable of random variables and collapses the structure by treating the possibilities as independent, so multiplying the probabilities
16:53:11 <luqui> that's the one i'm having trouble with
16:53:14 <Accidus> A Frame has Heyting algebras for objects
16:53:43 <Accidus> Do you know what's a Heyting algebra?
16:53:47 <sinelaw> Cale, ok
16:53:52 <kqr_> is there a way to figure out what classes a type is member of through ghci? (similar to the :t command)
16:53:58 <luqui> yeah, roughly.  arbitrary unions and finite intersections... right?
16:54:00 <Cale> Accidus: Do you happen to understand the way in which an infinity category can be seen as the same thing as a topological space? I'd really like to understand the details of that.
16:54:19 <Cale> Or, perhaps, a category object in the category of topological spaces
16:55:08 <Accidus> I don't know what infinity categories are.
16:55:16 <Accidus> luqui, not entirely
16:55:39 <Accidus> luqui, if you have arbitrary unions and finite intersections that you also have arbitrary intersections
16:55:48 <Accidus> luqui, But not for /morphisms/
16:56:38 <luqui> i don't follow.  maybe i am out of my league here...
16:56:38 * Accidus ponders whether he should go to sleep or not. The key problem is that Stone duality, and even more so Heyting algebra are probably going to be a big part of the research.
16:57:10 <Accidus> luqui, Hmm... let's take a simpler thing.
16:57:29 <Accidus> luqui, Take a monoid
16:57:39 <luqui> taken
16:57:51 <Accidus> luqui, And assume the operation works on /any/ subset of the monoid
16:58:01 <luqui> subset?
16:58:19 <luqui> doesn't it always?
16:58:21 <Accidus> luqui, Lets call the operation on the monoid *
16:58:32 <Accidus> So in a usual monoid we have a*b
16:58:36 <Accidus> and a*b*c
16:58:42 <luqui> right
16:58:47 <Accidus> As the order doesn't matter
16:59:03 <luqui> you mean it's associativity?
16:59:22 <Accidus> Yeah, the order of /evaluation/, obviously :)
16:59:37 <luqui> ok
16:59:45 <Accidus> But to make it simpler to illustrate the point, let's assume it's commutative (a*b = b*a) and idempotent (a*a = a)
16:59:52 <luqui> ok
16:59:59 <Accidus> So we can say: a*b = *{a,b}
17:00:03 <luqui> yeah
17:00:13 <Accidus> And a*b*b = *{a,b,c}
17:00:20 <Accidus> a*b*c even
17:00:46 <Accidus> We can also define *{} = e, where e is the unit of the monoid.
17:00:55 <luqui> right
17:01:04 <Accidus> Cool.
17:01:16 <Accidus> So we defined *A for any finite subset A of the monoid
17:01:33 <luqui> ok
17:01:34 <Accidus> But we haven't defined *A for an arbitrary subset of the monoid.
17:01:47 <sinelaw> @hoogle pure
17:01:48 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
17:01:54 <Accidus> Okay up to now?
17:01:57 <luqui> yep
17:01:59 <sinelaw> what's "pure" for functions?
17:02:15 <Accidus> Great. So now lets look at a structure that has arbitrary *
17:02:15 <luqui> sinelaw, it's got type a -> (b -> a)
17:02:21 <Accidus> For any subset A, we have *A
17:02:29 <sinelaw> luqui, so const
17:02:33 <Accidus> Okay?
17:02:37 <luqui> Accidus, yeah
17:02:40 <sinelaw> ?
17:02:50 <Cale> sinelaw: do you happen to know about SK calculus?
17:02:54 * hackagebot upload: txt-sushi 0.5.0 - The SQL link in your *NIX chain (KeithSheppard)
17:02:55 <luqui> sinelaw, yeah.  there is no other choice, actually :-)
17:02:58 <Accidus> Now, the monoid has two structures associated with it
17:03:08 <sinelaw> Cale, slightly
17:03:13 <sinelaw> _very_ slightly
17:03:15 <Accidus> One of them is a simple monoid structure
17:03:26 <Accidus> And the other one is the arbitrary * structure
17:03:30 <Cale> sinelaw: Now figure out what (<*>) is for functions :)
17:03:31 <Jackdaw> how can i pull off the same effect as a nested for loop, if i wanted to brute force something with 2 numeric arguments in C id just push the fn inside a pair of loops. Do i nest maps or is there something sneaky i can do with zip?
17:03:39 <Accidus> Okay?
17:03:57 <Cale> Jackdaw: How about a list comprehension with two generators?
17:03:59 <Zao> List comprehension maybe?
17:04:10 <Cale> Jackdaw: Or nested concatMaps, which is the same thing
17:04:12 <luqui> Accidus, well yes, if you don't mean anything specific by "structure" :-)
17:04:22 <Zao> > [ (a,b) | a <- [0..3], b <- "rofl"]
17:04:23 <Cale> (but harder to read)
17:04:23 <Jackdaw> thanks, i always forget you can do list comprehensions
17:04:23 <lambdabot>   [(0,'r'),(0,'o'),(0,'f'),(0,'l'),(1,'r'),(1,'o'),(1,'f'),(1,'l'),(2,'r'),(2...
17:04:26 <Accidus> luqui, I don't. I mean the intuitive meaning
17:04:35 <luqui> Accidus, good, yeah i follow.
17:04:40 <Accidus> luqui, So we have two kinds of functions that preserve this structure
17:04:47 <Accidus> The first one is monoid homomoprhisms
17:04:47 <sinelaw> Cale, (<*>) :: (a->b->c) -> (a->b) -> (a->c) ?
17:04:58 <sinelaw> oops
17:04:59 <Accidus> f(a*b) = f(a)*f(B) and f(e) = e'
17:05:04 <sinelaw> Cale, (<*>) :: (a->b->c) -> (a->c) -> (b->c) ?
17:05:09 <luqui> Accidus, okay
17:05:23 <Accidus> luqui, But we can have a stronger restriction: preserving the * structure
17:05:29 <Saizan> sinelaw: it was correct the first time
17:05:37 <Accidus> So for /any/ A, we have f(*A) = *f(A)
17:05:41 <xerox> Accidus just to be sure, did you generalize the *A structure or is it still just working on finite sets?
17:05:52 <Cale> :t (<*>)
17:05:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:05:57 <luqui> Accidus, which follows from monoid homomorphism only in the finite case.
17:05:58 <Accidus> xerox, generalize
17:06:02 <Accidus> luite, yup
17:06:17 <sinelaw> oh right
17:06:20 <Accidus> so if we have a function preserving the arbitrary *, it is /also/ a monoid homomorphism
17:06:21 <Cale> So  (e -> a -> b) -> (e -> a) -> (e -> b)
17:06:31 <Accidus> (By taking A = {a,b} and A = {})
17:06:32 <Cale> so your first one was right
17:06:36 <luqui> Accidus, right
17:06:41 <Cale> Now, how would you write a function like that?
17:06:41 <sinelaw>  (<*>) :: (c->a->b) -> (c->a) -> (c->a)
17:06:52 <Accidus> luite, But we might have monoid homomorphisms that do not preserve arbitrary *
17:06:53 <sinelaw>  (<*>) :: (c->a->b) -> (c->a) -> (c->b)  of course
17:06:55 <Cale> yes
17:06:57 <xerox> Accidus consider (R,+), +R structure is called series, and it's complicated. I think you need to give at least some laws.
17:07:37 <Accidus> xerox, Then lets look at (R+, +)
17:07:44 <Cale> :t (<*>) `asTypeIn` zip <*> tail
17:07:45 <lambdabot>     Couldn't match expected type `f (a -> b) -> f a -> f b'
17:07:45 <lambdabot>            against inferred type `[a1]'
17:07:45 <lambdabot>     In the first argument of `(<*>)', namely `zip'
17:07:47 <Accidus> xerox, because the positive series' form a monoid
17:07:55 <Cale> :t (<*>) `asTypeIn` \(<*>) -> zip <*> tail
17:07:57 <lambdabot> forall a. ([a] -> [a] -> [(a, a)]) -> ([a] -> [a]) -> [a] -> [(a, a)]
17:07:59 <Cale> heh
17:08:00 <Accidus> xerox, in this arbitrary sense
17:08:32 <Cale> sinelaw: anyway, what would that function be?
17:08:35 <Accidus> luqui, Are you familiar with the theory of positive series?
17:08:43 <Cale> (write a function of that type, you can't get it wrong)
17:08:50 <sinelaw> Cale, in a sec
17:09:18 <luqui> Accidus, i know a little.  you can arbitrarily permute and retain convergence right?
17:09:30 <Accidus> luqui, not just convergence, sum as well
17:09:34 <luqui> Accidus, aye
17:09:34 <sinelaw> (g <*> h) x = (g x) (h x)
17:09:46 <Cale> :t (<*>) `asTypeIn` \(<*>) -> (const undefined) <*> undefined
17:09:47 <lambdabot> forall a b b1. (b1 -> a -> b) -> (b1 -> a) -> b1 -> b
17:09:53 <Cale> there it is :)
17:09:53 <Accidus> luqui, So with positive converging series we have this +A structure
17:10:07 <luqui> *A.  but without idempotence.
17:10:08 <idnar> I prefer "g x (h x)"
17:10:13 <Accidus> luqui, So a monoid homomorphism would be /any/ function from R+ to R+
17:10:20 <sinelaw> idnar, fair enough
17:10:37 <idnar> @type asTypeIn
17:10:39 <lambdabot> forall a b. a -> (a -> b) -> a
17:10:58 <Accidus> luqui, But a morphism preserving the +R structure will be only those functions that map converging a series to a converging series
17:11:10 <Cale> sinelaw: Do you recognise that?
17:11:14 <Accidus> luqui, A strict subset
17:11:31 <Jackdaw> sorry to interrupt again, but that was a complete winner. Thanks very much
17:11:37 <Cale> Jackdaw: :)
17:11:39 <luqui> Accidus, ah okay, i think i got it
17:11:40 <Accidus> (For instance, lambda x. x preserves finite sums but not arbitrary)
17:11:44 <Cale> sinelaw: S g h x = g x (h x)  :)
17:11:58 <sinelaw> Cale, oh ok. i wouln't remember, but now I do
17:12:23 <Cale> sinelaw: So the methods of Applicative reduce to the K and S from SK-calculus
17:12:42 <sinelaw> Cale, cool. i've heard that before, without remembering the details
17:12:45 <Accidus> luqui, The whole point of the example is to ram home that /there is/ a difference between functions preserving finite operations and the ones preserving arbitrary operations
17:12:55 <luqui> Accidus, wait.   (x+y)^2 = x^2 + y^2 ?... or you are talking about series?
17:13:04 <luqui> oh on the limit
17:13:10 <Cale> This K and S are actually important because they're the axioms for the intuitionist fragment of implicational logic.
17:13:18 <xerox> Accidus indeed it is!
17:13:19 <Accidus> luqui, Oh, yeah. I was wrong here :)
17:13:41 <luqui> Accidus, anyway i see your point.
17:13:42 <Accidus> luqui, Interesting. So even in this example, there is no difference between the two
17:13:47 <sinelaw> Cale, unfortunately a lot of my knowledge is invested in operational amplifiers and such
17:13:51 <sinelaw> Cale, big mistake
17:13:55 <Accidus> luqui, But one can construct examples in which there is
17:14:04 <sinelaw> well, not a lot
17:14:10 <xerox> Accidus the two what?
17:14:39 <Accidus> xerox, preserving finite sums and arbitrary sums in R+
17:15:06 <Accidus> xerox, oh, wrong again. they don't have to be continuous
17:15:17 <Accidus> xerox, Blechs. This is a real detour from my point :)
17:15:26 <xerox> sorry, go to your preferred monoid :)
17:15:29 <Cale> sinelaw: Basically, if you think of their types as saying something about logical statements, and treating A -> B as "if A then B" or "A implies B", then from those two, you can get to every tautology in intuitionist logic
17:15:42 <Accidus> xerox, Doesn't matter, I got the point across. So now back to Heyting algebras
17:15:50 <Cale> sinelaw: To get everything in classical logic, you'd need one more thing, which happens to be callCC
17:16:17 <sinelaw> @type callCC
17:16:18 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
17:16:19 <j4cbo> <3 callcc
17:16:35 <Cale> Well, you need the form of that without the m's
17:16:38 <CHANG> callcc
17:16:50 <luqui> it's pierce's law!
17:16:53 <Cale> right
17:16:58 --- mode: ChanServ set +o monochrom
17:17:00 <Cale> Peirce
17:17:18 <Accidus> luqui, So Heyting algebras can arise in many situation. You know them as posets with arbitrary joins and finite meets
17:17:41 <Accidus> luqui, Or, rather, these are /complete/ Heyting algebra (cHa)
17:17:44 <monochrom> <3 haskell channel
17:18:02 <Accidus> luqui, but they didn't originate in this way (at least to my knowledge)
17:18:13 * sinelaw only knows about the Pierce crystal oscillator
17:18:14 <Accidus> luqui, There is the concept of Heyting algebras
17:18:39 <Accidus> which are lattices (are you familiar with lattices?) that has another operator, implication
17:18:40 <sinelaw> well, i _should_ know, but i don't
17:19:18 <sinelaw> Cale, you mean ((a->b) -> a) -> a ?
17:19:33 <luqui> Accidus, yeah i am familiar with lattices.  ok i follow.
17:19:38 <Cale> sinelaw: yeah
17:19:41 <xerox> Accidus is the geometrical view of lattices good enough here?
17:19:57 <Cale> sinelaw: You can't normally write a function of that type in Haskell, but you could if there were first-class continuations.
17:20:02 <Accidus> xerox, No, actually the logical view is better
17:20:20 <Cale> (the existence of such a function is practically the same thing as saying continuations are first class)
17:20:30 <Accidus> luqui, xerox Are you familiar with the relation between Heyting algebras and intuitionistic logic?
17:20:49 <sinelaw> Cale, that function is "function inverter -> value"?
17:20:58 <luqui> Accidus, I am a little bit more familiar now :-)
17:21:04 <xerox> Accidus nothing more than you pointed at
17:21:29 <Accidus> luqui, xerox Okay. Then Heyting algebras /are/ first order propositional intutionistic logic
17:21:47 <luqui> models thereof
17:22:00 <Accidus> And Complete Heyting algebras /are/ first order predicate intuitionistic logic
17:22:09 <luqui> interesting!
17:22:15 <Accidus> luqui, They give sound and complete semantics of the logic, so they /are/ the logic
17:22:38 <sinelaw> digression - how/can i define a multiparameter type as an instance of a single-parameter type class?
17:22:41 <Accidus> luqui, Well, more accurately, they give sound and complete semantics, and /all/ the algebraic structure is exposed to the logic
17:22:49 <luqui> ok
17:22:53 <dolio> luqui: No, it's Peirce's law.
17:23:08 <luqui> dolio, yeah Cale got me on that one.
17:23:23 <Accidus> luqui, So the operations available in a Heyting algebra are exactly the connectives of intuitionistic logic
17:23:47 <Accidus> luqui, and the order in a Heyting algebra behaves exactly like entailment in intuitionistic logic
17:24:08 <luqui> ok
17:24:17 <monochrom> sinelaw: Like this? instance Eq (Either a b) where x==y = True
17:24:24 <ski> > (`map` [0 ..]) $ \i -> zipWith const (permute i ['a' ..]) (takeWhile (<= i) (scanl (*) 1 [1 ..]))
17:24:25 <lambdabot>   ["","ba","acb","cab","bca","cba","abdc","badc","adbc","dabc","bdac","dbac",...
17:24:28 <ski> > (`map` [0 ..]) $ \i -> zipWith const (invPermute i ['a' ..]) (takeWhile (<= i) (scanl (*) 1 [1 ..]))
17:24:30 <lambdabot>   ["","ba","acb","bca","cab","cba","abdc","badc","acdb","bcda","cadb","cbda",...
17:24:40 <sinelaw> monochrom, ok
17:25:04 <Accidus> luqui, So, if we are talking about Heyting algebras from the logical point of view, a morphism will have to preserve all connectives
17:25:19 <Accidus> luqui, So that's join, meet, implication, top and bottom
17:25:33 <luqui> ok
17:25:46 <aep> you guys scare me with your math :P
17:25:51 <Accidus> luqui, But if we look at them from the lattice point of view, it will only preserve the order (hence only join and meet)
17:25:59 <Accidus> aep Math? That's computer science!
17:26:10 <monochrom> you scare me with your "you guys scare me with your math :P" :P
17:26:27 <luqui> what channel do you think this is?  one for people who talk about useful things?
17:26:38 <ray> computer science is comath
17:26:44 <Accidus> Heyting algebras /are/ useful
17:26:56 <xerox> Accidus and to the others correspond to the arbitrary operations preserving structure?
17:27:00 <Accidus> I'm writing on them in my thesis proposal, to solve a problem in access control.
17:27:08 <xerox> sorry that was badly worded
17:27:28 <Accidus> * writing about them
17:27:50 * ski tries to recall who were talking about permutations, before ..
17:27:56 <luqui> Accidus, cool.  okay so what you meant by that last thing is that they only preserve the order because we simply don't have the vocabulary to talk about the other things they preserve
17:28:01 <xerox> ski maybe dmhouse?
17:28:08 <luqui> or you're talking about lattice homomorphisms being different from heyting homomorphisms?
17:28:12 <Accidus> luqui, We choose what to preserve
17:28:22 <dmhouse> ski: me in efnet #math?
17:28:35 <Accidus> luqui, So it really depends on what we choose to preserve.
17:28:44 <luqui> ok....
17:28:48 <Accidus> luqui, which in turn depends on where we are coming from, or what we want to do.
17:28:50 <ski> dmhouse : it was someone in here, i think
17:29:02 <luqui> Accidus, i am not sure you are saying anything :-P
17:29:03 <Accidus> So with complete Heyting algebras you have several choices for morphisms
17:29:21 <Accidus> Frames is one of them, where we choose to preserve arbitrary joins and finite meets
17:29:32 <Accidus> Makes sense?
17:29:39 <luqui> oh frames are morphisms on heyting algebras?
17:29:43 <Accidus> yup
17:29:49 <luqui> ok!
17:30:21 <Accidus> luqui, To be exact, complete H
17:30:24 <Accidus> * Ha
17:30:28 <luqui> alright
17:30:39 <monochrom> ski: Do you mean this? about 3.5 hours ago  <monochrom> Every monkey sees an PE question that mentions "permutations" and involuntarily starts writing code generating all permutations.
17:30:44 <Accidus> luqui, So Locales are just the opposite category
17:31:06 <luqui> which corresponds concretely to...?
17:31:10 <Accidus> Locales
17:31:12 <Accidus> :)
17:31:15 <luqui> haha
17:32:09 <Accidus> And through the Stone duality, are the Stone dual to topological spaces
17:32:12 <ski> hm, it was HaskellLove, apparently
17:32:14 <luqui> so eg. continuous functions in point topology?
17:32:34 <luqui> er wait that's frame
17:32:34 <ski> (monochrom : it was at about that time, yes)
17:32:50 <luqui> er... no, i'm getting all backwards.  i'll forget about point topo for a sec.
17:32:53 <Accidus> (As a union of arbitrary open sets is open and the intersection of finite open sets is open)
17:33:25 <Accidus> luqui, Why? It's a bit like what you said in the begining
17:33:30 <ski> so i wrote a function which permutes a list, given an index of which permutation to do
17:33:40 <Accidus> luqui, So in one direction we have continuous functions as morphisms
17:33:47 <luqui> Accidus, I am having trouble with the level of abstraction.
17:34:05 <Accidus> luqui, We have continuous functions on one side, right?
17:34:11 <luqui> yeah
17:34:21 <Accidus> luqui, And we know the "continuity" is a property of f^-1
17:34:42 <luqui> aye
17:34:57 <Accidus> luqui, So, intuitively, the "structure preserving morphisms" act in the opposite direction
17:35:08 * hackagebot upload: xsd 0.3.0 - XML Schema data structures (TonyMorris)
17:35:11 <Accidus> luqui, (again, this is only intuition. The precise details /are/ the Stone duality)
17:35:37 <ski> > let as = "haskell" in permute (fst (randomR (0,product [1..length as]-1) (mkStdGen 738752981))) as
17:35:38 <lambdabot>   "klaeslh"
17:35:49 <monochrom> http://www.amazon.com/Topology-Cambridge-Theoretical-Computer-Science/dp/0521576512
17:35:52 <luqui> so frames are the f^-1 side, and locales correspond to the point functions
17:36:06 <Accidus> No. There is no frames here.
17:36:13 <ezyang> I really wish Haskell had a decent way of dealing with orphan instances.
17:36:26 <Accidus> luqui, On one side we have continuous functions, and on the other side, Locale morphisms
17:36:27 <monochrom> And omg http://www.addebook.com/tech/mathematics/topology-via-logic_10566.html
17:36:29 <drdr> Howdy
17:36:41 <ezyang> Not sure what this decent way would be, though.
17:36:47 <drdr> can someone help me understand the => and -> operators?
17:36:51 --- mode: monochrom set -o monochrom
17:36:52 <luqui> Accidus, in opposite directions, si?
17:36:55 <ski> monochrom : is that the Steven Vickers book ?
17:36:58 <monochrom> Yes!
17:37:08 <ski> it's an interesting one
17:38:20 <Accidus> luqui, Locale morphisms are the opposite of Frame morphisms
17:38:24 <sproingie> drdr: => is a constraint.  it's not an operator, it's syntax
17:38:36 <luqui> Accidus, so frame morphisms are the same direction as continuous functions on points
17:38:37 <drdr> got a guide on it?
17:38:41 <sinelaw> can I have a type that's parameterized over a and b, but doesn't use 'a' in any of its constructors?
17:38:44 <Accidus> luqui, yes
17:38:46 <drdr> learn you a haskell aint helpin much
17:38:52 <sproingie> -> is a type constructor, but for practical purposes, it's also syntax
17:38:58 <Cale> Accidus: So we define the spectrum of a locale by taking all the ultrafilters and making them the points, and taking a basis of open sets to be all the ultrafilters containing each given point?
17:39:16 <sproingie> (since you can't section it the same as you can other infix operations)
17:39:16 <Accidus> Cale, Dunno.
17:39:18 <luqui> Accidus, so Frame is like the cat of topo spaces with continuous functions
17:39:34 <monochrom> It is tantamount to asking "what does , mean in haskell"
17:39:37 <Accidus> luqui, The opposite of Frame :)
17:39:43 <sproingie> drdr: which part of LYAH is giving you trouble?
17:39:45 <Accidus> And the likeness is Stone duality
17:40:07 <luqui> Accidus, what?!  oh... because the cat of topo spaces has the arrows going the opposite direction as functions on their points?
17:40:14 <drdr> the fact they dont explain the => -> and the (int a) stuff
17:40:27 <sproingie> i doubt you see (int a)
17:40:35 <Accidus> luqui, The "likeness" here is Stone duality
17:40:35 <sproingie> that being C
17:40:35 <drdr> well
17:40:47 <monochrom> sinelaw: Yes. The phantom-type people do it all the time.
17:41:00 <Accidus> luqui, If you try to fit Frames into the Stone duality, it will fail
17:41:05 <luqui> Accidus, okay i think i've got it.  but which way are the arrows in your idea of the cat of topo spaces.
17:41:06 <sproingie> :t int
17:41:06 <sinelaw> monochrom, what's it normally used for?
17:41:08 <lambdabot> Int -> Doc
17:41:14 <luqui> Accidus, huh...
17:41:14 <sproingie> huh.  whatever that is.
17:41:16 <Cale> If that works, then we're supposed to have each map A -> B of locales lift to a continuous map S(A) -> S(B)
17:41:23 <Accidus> luqui, The usual way, the same direction as the functions
17:41:34 <sproingie> RWH @def maybe
17:41:34 <drdr> ' (Ord a) => [a] -> a  '
17:41:40 <drdr> thats my misunderstanding
17:41:46 <aavogt> drdr: did you get to chapter 3? Or that's where your problem happens?
17:42:02 <luqui> Accidus, it is not adding up.  Frame seems like it should be going the same direction as Top
17:42:05 <sproingie> drdr: it means "for any Ord a, [a] -> a"
17:42:12 <sproingie> Ord is a typeclass
17:42:18 <Cale> drdr: The stuff before the => are constraints on the variables we're going to use in the type
17:42:26 <sproingie> so "for any type a that is an instance of Ord, [a]->a"
17:42:44 <Cale> drdr: Ord a means that we insist that a is a type which supports the ordering operations like (<=)
17:42:52 <xerox> Cale did you see ultrafilters in any course?
17:42:53 <c_wraith> drdr: it does explain those.  in no surprise at all, it's on the page about types and typeclasses
17:43:02 <sproingie> or totally without symbols: "for any type a that is an instance of Ord, a list of a to a"
17:43:06 <drdr> ahh
17:43:09 <Cale> xerox: yes, my logic and model theory course
17:43:19 <Accidus> luqui, They are
17:43:23 <drdr> well then i skiped most of that because its not a funny as _why's work
17:43:42 <xerox> Damn, my model theory course was so bad I had to drop it.
17:43:44 <Accidus> luqui, But the similarity in Stone duality is /not/ about the direction of the arrows
17:43:52 <c_wraith> so...  you skipped a very important part of the tutorial, then complained the things that part covers weren't covered?
17:44:07 <Accidus> xerox, I learned about ultrafilters in topology
17:44:15 <drdr> yep
17:44:20 <drdr> ill go re read it
17:44:23 <Accidus> xerox, They introduced them when they wanted to prove Tychonov's theorem, if I am not mistaken
17:44:33 <Cale> I never took a course on point-set topology somehow.
17:44:41 <Accidus> xerox, But they didn't do anything about them but prove that theorem, so they stayed a mystery for me.
17:44:58 <Cale> Only algebraic topology, and lots of topological-ish stuff from various analysis courses.
17:45:02 <Accidus> xerox, But now I have to get them going, as they are crucial for proving completeness of logic
17:45:34 <xerox> I've smelled ultrafilters in an introduction to ergodic theory, but then I lost interest.
17:46:11 <drdr> ...?
17:46:11 <ski> (e.g. it mentions the Egli-Milner powerset preorder, as well as the Hoare and Smyth powerset preorders (useful for modelling angelic and demonic nondeterminism))
17:46:24 <drdr> i think i see why haskell dosnt have such a high addaption rate
17:46:33 <Accidus> Gosh, this is brilliant.
17:46:36 <luqui> Accidus, I have more ammo to approach this.  can you fill in the blank  "the Stone duality is about the likeness of __ and __", and what sort of likeness is it
17:46:45 <Cale> Ultrafilters mostly get confusing because of the nonprincipal ones :)
17:46:49 <luqui> or is it a magical thing, like large cardinals
17:46:57 <Accidus> luqui, Topological spaces and Locales
17:47:04 <Cale> They're where all the interesting stuff happens, and you can only get at them with the axiom of choice.
17:47:06 <xerox> And in that case, it was only idempotent ultrafilters that were used for the job at hand.
17:47:11 <monochrom> sinelaw: Together with a module providing the type but not exposing implementation, you can enforce more safety properties. E.g., you provide an expression type, "Exp a". You can provide functions like zero :: Exp Int, true :: Exp Bool, not :: Exp Bool -> Exp Bool. Users cannot say "not zero". However, in your implementation, for one reason or another you don't care whether it's Exp Int or Exp Bool, and you know what you're d
17:47:12 <monochrom> oing so it's safe for you, but you don't trust the users.
17:47:15 <Accidus> And for the likeness of it you will have to look deeper into the Stone theorem :)
17:47:25 <luqui> Accidus, oh, ok.
17:47:33 <c_wraith> I've seen ultrafilters in a discussion of why ZFC needs less ontologically onerous beliefs than arithmetic logic does as a basis for math.  I rejected the argument, because it seems like believing in ultrafilters requires as much of a leap of faith as believing that logic-based arithmetic is incomplete, rather than inconsistent
17:47:46 <Accidus> luqui, But...
17:47:48 <luqui> Accidus, i've got to get going.  Thanks a bunch professor!! :-)
17:47:55 <Accidus> lol, professor
17:48:04 <Accidus> luqui, If you want another taste
17:48:17 <Accidus> luqui, Think about the yoneda embedding
17:48:25 <sinelaw> monochrom, I see
17:48:26 <Accidus> It takes an element and turns it into a filter
17:48:34 <Accidus> And it takes a morphism, and reverses it direction
17:48:35 <Accidus> :)
17:48:38 <sinelaw> monochrom, sounds useful for dsl's
17:48:49 <drdr> ok so would a -> a -> a take two a and return a?
17:48:50 <Cale> c_wraith: I have a really hard time believing that the product of nonempty sets could be empty though.
17:48:51 <Accidus> okay, I'm done.
17:48:52 <luqui> Accidus, okay, not comfortable with yoneda, but i'll take a look in a new light.
17:48:58 <luqui> Accidus, thanks again
17:49:02 <Accidus> Sheesh. It's late.
17:49:08 <Accidus> Good thing Frisbee's off tomorrow
17:49:19 <drdr> ...
17:49:37 <Cale> c_wraith: A lot of the axioms of ZFC are only there to make set theory more settish. For instance, the axiom of foundation isn't so critical, but it's basically there to prevent set theory from becoming a screwy version of graph theory.
17:49:42 <ski> drdr : yes
17:49:55 <monochrom> sinelaw: Yes! edsl-approach sql libraries do it this way.
17:50:03 <drdr> so i couuld write a -. a-> a as a, a -> a
17:50:09 <felzix> wait, is graph theory similar to set theory?
17:50:09 <ski> no
17:50:10 <Accidus> Cale, and it still isn't good enough (hypersets!)
17:50:19 <drdr> heh?
17:50:24 <drdr> now im evan more confused
17:50:31 * drdr facepalms
17:50:33 <ski> drdr : you could use `(a,a) -> a' instead, to accomplish mostly the same thing
17:50:40 <drdr> ah
17:50:44 <Accidus> Okay, I'm off to bed.
17:50:47 <Accidus> Good night everyone
17:50:53 <Cale> Accidus: hypersets? I forget what those were, but I thought they needed the negation of foundation
17:50:58 <ski> > let foo :: Int -> Int -> Int; foo x y = 10 * x + y in foo 3 4
17:50:59 <lambdabot>   34
17:50:59 <drdr> goodnight dont like the typeclasses bight
17:51:09 <ski> > let foo :: (Int,Int) -> Int; foo (x,y) = 10 * x + y in foo (3,4)
17:51:10 <lambdabot>   34
17:51:14 <Accidus> Cale, Do they? I'm fairly sure they are consistent with ZFC
17:51:14 <drdr> ah
17:51:30 <ski> drdr : note the difference both in how `foo' is defined and how it is called
17:51:31 <Cale> Was that cases like A is an element of B which is an element of A?
17:51:42 <Cale> (those are certainly excluded by AoF)
17:51:49 <Accidus> Cale, don't remember.
17:51:51 <drdr> much better
17:51:55 <ski> drdr : in the latter case, `foo' takes a single argument, which happens to be a pair of two `Int's
17:52:07 <sinelaw> conal, what do I do if I know the semantic meaning of the instance, but not how to implement it?
17:52:15 <drdr> much better
17:52:21 <ski> drdr : in the former case, `foo' takes a single argument of type `Int', and returns a function that takes a single argument of type `Int'
17:52:38 <ski> drdr : we usually abbreviate that as "`foo' takes two `Int' arguments"
17:52:50 <conal> sinelaw: you think.
17:53:01 <drdr> so the -> acts as a seprater
17:53:01 <ski> > let foo :: Int -> Int -> Int; foo x y = 10 * x + y in map (foo 3) [4,5,6,7]
17:53:02 <lambdabot>   [34,35,36,37]
17:53:08 <conal> sinelaw: think about how to implement correctly.
17:53:19 <drdr> and its only the last typeclass that matters
17:53:19 <conal> sinelaw: do you have an example in mind?
17:53:21 <Accidus> Okay. That's it. Not looking at the terminal anymore.
17:53:23 <ski> > let foo :: (Int,Int) -> Int; foo (x,y) = 10 * x + y in map (\y -> foo (3,y)) [4,5,6,7]
17:53:25 <lambdabot>   [34,35,36,37]
17:53:39 <Accidus> Damn
17:53:49 <Accidus> Got today's digest from the categories mailing list
17:53:50 * drdr hehs?
17:53:56 <conal> @localtime sinelaw
17:53:58 <lambdabot> Local time for sinelaw is Thu Dec 31 03:53:33
17:54:00 * Accidus ignores his email.
17:54:01 <xerox> Send it back!
17:54:02 <ski> drdr : note how the `foo :: Int -> Int -> Int' (the "curried" version of `foo') is easier to partially apply, like when we want to `map' it over a list
17:54:03 <conal> yeep
17:54:03 <drdr> well i get the ->'s
17:54:08 <sinelaw> conal, don't do that!
17:54:08 <sinelaw> :)
17:54:14 <sproingie> ski: you could use curry foo 3
17:54:16 <conal> :)
17:54:17 <Accidus> It's just that it's very interesting lately
17:54:20 <xerox> @localtime conal
17:54:21 <sproingie> but why curry and uncurry by hand
17:54:22 <lambdabot> Local time for conal is 2009-12-30 17:53:57 -0800
17:54:32 <ski> drdr : `Int -> Int -> Int' really is parsed like `Int -> (Int -> Int)'
17:54:34 <drdr> so i guess im gonna go test it on some math ive written for my ti80
17:54:40 <sinelaw> conal, http://en.wikipedia.org/wiki/Pierce_oscillator
17:54:42 <sinelaw> oops.
17:54:42 * conal is sitting by a cozy fire.
17:54:44 <sinelaw> wrong paste!
17:54:45 <ski> drdr : so `->' is the function arrow
17:54:49 * ezyang is jealous of conal 
17:54:50 <drdr> ok
17:54:50 <sinelaw> conal, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15287#a15287
17:54:50 <Accidus> Reading Joyal, Abramsky and Baez argue about what's interesting and what is valuable research is very interesting.
17:55:07 <drdr> so now Int takes (int a and int b)
17:55:09 <ski> drdr : so that type says that `foo' takes one argument of type `Int', and returns a function that takes ...
17:55:13 * conal looks
17:55:31 <Accidus> (much better than the global warming thread)
17:55:34 <ski> drdr : btw, `Int' is a type (as is `Int -> Int -> Int'), not a type class
17:56:10 * j4cbo thinks currying is a great example of the curry-howard correspondence
17:56:11 <ski> (i'm not sure what you mean by "so now Int takes (int a and int b)")
17:56:12 <conal> sinelaw: you can write those semantic specs more elegantly/tellingly
17:56:28 <sinelaw> RandomVariable is simply a function
17:56:33 <sinelaw> semantically
17:56:37 <conal> sinelaw: probWithVar . fmap f = fmap f . probWithVar
17:56:57 <ski> sproingie : yes .. but here i was displaying the difference between the two versions
17:57:06 <sinelaw> conal, nice
17:57:23 <conal> sinelaw: it always works.  type class morphisms.
17:57:46 <conal> sinelaw: if TCM holds, your abstraction has integrity.  if TCM fail, your abstraction leaks.
17:57:49 <sinelaw> conal, i know i'm doing them, but my haskell-ness is not quit up to it
17:57:51 <conal> s/fail/fails/
17:58:03 <sinelaw> *quite
17:58:07 * conal reads on
17:58:31 <j4cbo> "a -> b -> c" can trivially be converted to and from "(a, b) -> c"
17:58:54 <j4cbo> ... just like, logically, "A implies that B implies C" is equivalent to "A and B imply C"
18:00:22 <Saizan> for Functor it always hold if it typechecks
18:00:45 <conal> sinelaw: i'd start with defining the semantic function.  then derive the implementation from semantics + TCM
18:01:14 <sinelaw> conal, probWithVar is the semantic function.
18:01:26 <sinelaw> oh you mean implement it
18:01:27 <conal> sinelaw: can you define it?
18:01:32 <sinelaw> ah. ok
18:01:45 <Saizan> because you're saying that the semantic function is a natural transformation, and that's guaranteed by parametricity
18:04:02 * Saizan wonders if there are other classes like this
18:06:13 <ski> like what ?
18:07:45 <sinelaw> conal, problem is that omega is arbitrary. e.g. if I knew that omega were discrete, i could implement probWithVar as a lookup on a Map omega prob
18:08:08 <sinelaw> but it's possibly infinite or even uncountably infinite
18:08:41 <conal> sinelaw: is your RandomVariable rep *really* what you want?
18:08:45 <sinelaw> so i end up needing a function omega -> prob, so RandomVariable is nothing more than a function
18:08:46 <conal> sinelaw: a single domain value and a single range value?
18:09:01 <sinelaw> hmm
18:09:21 <sinelaw> of course not
18:09:25 <sinelaw> :)
18:09:47 <sinelaw> conal, data RandomVariable omega prob = RV (omega -> prob)
18:10:04 <conal> sinelaw: now you're making it way too easy.
18:10:15 <sinelaw> so RandomVariable = (->)
18:10:17 <conal> sinelaw: to define the instances
18:12:30 <sinelaw> i can't have a haskell set that is continuous...
18:13:28 <sinelaw> i'll let my mind sleep on it.
18:13:42 <sinelaw> conal, unless you were going to give me another hint ?
18:14:05 <conal> sinelaw: i have nothing.
18:14:21 <sinelaw> ok :)
18:14:38 <sinelaw> localtime sinelaw = _|_
18:14:44 <kyagrd> Hi, does --extra-lib-dirs work option work in cabal well?
18:15:39 <kyagrd> --extra-include-dirs seem to work well but I'v failed to work with --extra-lib-dirs
18:39:40 <aavogt> can somebody help me understand what is intended by this function: http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Util-Run.html#runProcessWithInput
18:39:52 <aavogt> the  "when (output == output) $ return ()
18:40:19 <ezyang> that's... really curious.
18:40:20 <Twey> It's a hack to force the contents of output
18:40:23 <aavogt> "  is just equivalent to    return (rnf output)
18:40:27 <koeien37> it problably wants to read the whole output
18:40:31 <Twey> Right
18:40:46 <aavogt> the comment is sort of misleading though...
18:41:21 <aavogt> I guess length will do instead of rnf
18:41:40 <Twey> What comment?
18:41:51 <koeien37> that doesn't force the contents of the list, but I guess that doesn't matter in this case
18:41:52 <aavogt> above it: it says otherwise return @()@
18:42:15 <aavogt> the function cannot return (), since it returns a type of  IO String
18:42:16 <Twey> Hm, oh yes
18:42:21 <Twey> Yeah
18:42:35 <aavogt> I'm not sure how to correct this code
18:44:11 <c_wraith> what's broken?
18:47:39 <lpjhjdh> are gadts on the list of things to add to TH?
18:47:49 <aavogt> c_wraith: the comment doesn't describe what it does
18:49:33 <c_wraith> aavogt: well, it seems like there aren't many options.  IO (Either Int String) is one option (error code on failure, output on success)
18:49:44 <c_wraith> But I don't know what call will give you the error code.
18:51:16 <c_wraith> IO (Maybe String) is simpler, if you don't care about the error code.  It really wants a custom return type that includes the errno, stdout, and stderr.
18:51:38 <c_wraith> Because depending on what command you use, you might care about all three of those at once.
18:52:25 <aavogt> well, apparently the function works as-is
18:52:47 <aavogt> but the actual code is quite strange as people already commented
18:53:05 <c_wraith> eh.  It's not *that* strange.
18:53:18 <c_wraith> when you don't want lazy input, you need to force the list somehow.
18:58:05 <c_wraith> lazy IO is still a bit of a strange point, in Haskell.  the IO monad is not lazy, by default.  So code that wants its operations to be lazy has to call unsafeInterleaveIO.  But then sometimes the callers of library code don't want the laziness, and have to work around that.
19:01:15 <McManiaC> http://www.haskell.org/ghc/docs/6.4.1/html/hslibs/Select.html  whats the current version of "import Select"?
19:01:21 <McManiaC> or is there something new/better?
19:02:12 <c_wraith> Do you really need explicit select?  Is forkIO insufficient for your needs, somehow?
19:03:01 <McManiaC> a friend of mine told me to not use forkIO
19:03:18 <c_wraith> That advice is suspect, unless it came with some reasons
19:03:30 <McManiaC> he said it would need more ressources?
19:03:49 <c_wraith> that isn't a very good reason.
19:03:58 <c_wraith> it's not like calling fork at the OS level
19:03:58 <monochrom> May I be your friend? May I tell you to use forkIO? May you tell your other friend "a friend of mine tells me to use forkIO"?
19:04:29 <monochrom> It would not need more resources.
19:04:46 <McManiaC> you may aswell :)
19:05:43 <McManiaC> ok, so I'll just stick to my forkIO
19:06:02 <kyagrd> Is happstack based on forkIO as well?
19:06:10 <monochrom> I can't find select in ghc 6.10
19:06:24 <McManiaC> kyagrd: i think so
19:06:34 <monochrom> I mean unless you accept those in Text.Html and Text.XHtml.
19:06:39 <c_wraith> forkIO does use select internally, though there are projects underway to replace that with something a bit less screwy. :)
19:06:40 <McManiaC> not 100% sure
19:07:47 <kyagrd> high performance servers need better things than select (e.g. BSD kio, Linux epoll, etc)
19:08:17 <ben0x539> But they never need better things than forkIO?
19:08:19 <c_wraith> bos has a version of the IO manager that uses epoll.  It apparently was an almost trivial change, but he wants to test performance against several other options.
19:09:47 <kyagrd> ben0x539: forkIO internally uses select, so they would need better things for highly saturated servers to serve massive connections
19:09:56 <c_wraith> http://www.serpentine.com/blog/2009/12/17/making-ghcs-io-manager-more-scalable/
19:11:07 <ben0x539> kyagrd: I mean assuming that forkIO is backed by something better than select
19:11:08 <c_wraith> oh, that's poll, not epoll.  No wonder he's not satisfied with the change
19:12:22 <c_wraith> forkIO is lightweight enough that if it's causing real overhead issues, you should be scaling horizontally.  Because what it gives you in terms of ability to write clean code is worth a few % in performance difference.
19:13:13 <monochrom> Here is why forkIO does not use more resource. Or rather your own select loop does not use less. The runtime already does its own select loop and dispatches threads. Your main program is already running in one such thread. If you like to call it "threading overhead", well fine, but bear in mind that the overhead is already there whether you use it or circumvent it. If you try to circumvent it with your own select loop, you're
19:13:13 <monochrom>  just reinventing the wheel, and moreover the whole thing now runs one select loop inside another, you are adding more overhead not less.
19:13:20 <chrisdone> good evening chappies
19:13:40 <c_wraith> monochrom: where's that from?
19:13:46 <monochrom> Me.
19:13:53 <ben0x539> What if I do not want to replace it with my own select loop, just with single-threaded async io
19:14:08 <j4cbo> monochrom: except select() sucks anyway
19:15:12 <kyagrd> By the way has anyone been successful with --extra-lib-dirs option in cabal linking to foriegn C library installed in non-stantard location?  I'm trying it for the first time and it just doesn't work :(
19:18:02 <BMeph> Stick a fork(IO) in it... ;)
19:20:56 <jonh> BMeph, good one :)
19:23:19 <dixie> Cale: thanks :)
19:23:30 <Cale> dixie: no problem :)
19:35:09 <RyanT5000> is there anything wrong with StableName based memoization? it seems to have fallen out of favor lately
19:35:53 * shapr sighs
19:36:05 <shapr> Installing all of cabal has now worked its way down to memcached
19:36:23 <Nafai> shapr: working on anything fun?
19:36:28 <monochrom> is memcached yet another package you have to install?
19:36:37 <shapr> monochrom, I'm installing *all* of hackage.
19:36:54 <shapr> I believe I started this yesterday sometime?
19:37:03 <shapr> or maybe it was just this morning, but it sure feels like a long time.
19:37:38 <shapr> Nafai, not at the moment... what about you?
19:37:39 <Nafai> How did you tell cabal-install to do that?
19:37:44 <RyanT5000> is all of hackage even mutually compatible?
19:38:04 <c_wraith> no.  mtl and transformers are the common conflict
19:38:08 <Nafai> shapr: not really, got to refocus and continue looking for employment
19:38:35 <shapr> RyanT5000, nope
19:39:31 <shapr> I did "for x in `cabal list|grep '*'|cut -d ' ' - f 2; do cabal install $x; done;"
19:39:46 <shapr> er, I added an extra space there, but you get the idea.
19:39:53 <shapr> and I left out the second backtick
19:39:54 <c_wraith> however, you can install all of hackage at once.  the package system keeps everything nicely isolated until you need it.
19:40:24 <shapr> Also, you can find errors by looking in ~/.cabal/logs for build failures.
19:41:32 <shapr> Sadly, I had to write an infinite loop in another xterm to renice cabal so I could watch hulu at the same time.
19:41:35 <RyanT5000> c_wraith: ah, that makes sense
19:41:49 <monochrom> haha
19:42:19 <RyanT5000> shapr: that stuff doesn't propagate to child processes?
19:42:23 <RyanT5000> (renicing)
19:42:44 <monochrom> (But you could just renice the most parent process.)
19:42:49 <shapr> oh yeah :-)
19:42:58 <shapr> Didn't think of just renicing the zsh parent.
19:43:28 <c_wraith> cabal is strange...  don't ctrl-c it.
19:43:31 <monochrom> (child processes before renicing parent will of course need individual renicing. but child processes after will be good.)
19:44:04 <RyanT5000> so uh, about my haskell question: I'm thinking of doing memoization based on StableName, but I haven't read about anyone doing that after the original paper
19:44:10 <RyanT5000> is there some pitfall i'm not thinking of?
19:45:05 <shapr> I think edwardk was talking about that some last time I saw him.
19:46:09 <RyanT5000> hm
19:46:15 <RyanT5000> alright, well, i guess i'll just try it
19:49:02 * hackagebot upload: GPX 0.4.1 - Parse GPX files (TonyMorris)
19:57:02 <roboshibby> memoization? i just read that term in... hm, an article on referential transparency?
20:07:06 <ezyang> Ick lazy state monad!
20:11:02 <RyanT5000> ezyang: what's wrong with that?
20:13:45 <ezyang> It's... man, laziness makes my brain hurt.
20:13:57 <roboshibby> why?
20:13:59 <Olathe> You'll get to it later ?
20:14:01 <roboshibby> lazy evaluation seems good
20:14:28 <ezyang> The usual complaint is "it's hard to figure out performance characteristics"
20:14:39 <ezyang> but it also allows for things like forward-recursion...
20:15:33 <RyanT5000> ezyang: yeah, sometimes it can get kind of tricky to sort out why something terminates :)
20:15:50 <c_wraith> If it's lazy, who cares if it terminates?
20:16:03 <RyanT5000> c_wraith: the guy who forces it
20:16:08 <ezyang> well, it should terminate giving a partial result :-)
20:19:06 <roboshibby> i still dont understand how lazy evaluation makes things operate any differently than in a language like ruby or obj-c
20:19:06 <c_wraith> > fix (0:)
20:19:07 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
20:19:12 <monochrom> My first sip of alcohol in my life got me to think "alcohol makes my mouth hurt". The rest is history. Keep that in mind next time you feel that laziness hurts your mouth.
20:19:17 <c_wraith> that doesn't terminate.  But it's still useful.
20:19:32 <j4cbo> > fix error
20:19:34 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
20:19:35 <j4cbo> :P
20:19:51 <c_wraith> that didn't fix anything!
20:19:55 <Olathe> It's lazily fixing the error.
20:20:23 <j4cbo> understanding 'fix' takes some work
20:20:54 <monochrom> which is done for you in http://www.vex.net/~trebla/haskell/fix.xhtml
20:21:20 <j4cbo> well
20:21:25 <monochrom> done.
20:21:30 <c_wraith> yeah, that's a great article for fix
20:21:36 <monochrom> Thanks. I think it's well done, too. :D
20:21:48 <j4cbo> understanding how and why a fixed-point operator is useful takes some work
20:21:55 <ezyang> fix is cool.
20:22:22 * j4cbo still vividly remembers the day he first grokked call/cc...
20:23:20 <monochrom> OK, you don't have to use it. I use it like this: do { firstly; fix (\m -> secondly; m) } so as to avoid writing an extra "let m = do {secondly;m}" or "where = do {secondly;m}"
20:23:40 <monochrom> Oh, I guess I use "forever" now.
20:24:59 <monochrom> There was a period when fix was available but forever wasn't yet.
20:25:48 <monochrom> And today though forever is available, not every recursion fits its pattern.
20:25:59 <monochrom> @src foldl'
20:25:59 <lambdabot> foldl' f a []     = a
20:26:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:26:06 <monochrom> @src foldr
20:26:06 <lambdabot> foldr f z []     = z
20:26:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:26:15 <monochrom> nevermind.
20:27:25 <monochrom> Oh here.  do { firstly; fix (\m x -> secondly x; m (x+1)) 0 }  is outside the reach of forever.
20:29:10 <monochrom> But then you will counter that with forM_ [0..] secondly, and so here is another one to evade that: do { x0 <- firstly; fix (\m x -> y <- secondly x; m y) x0 }
20:30:18 <monochrom> And no it is not about golfing the code. It is about I can't be bothered to invent a "meaningful" name for that loop.
20:31:04 <aavogt> @type fix (\m x -> do y <- ?f x; m y)
20:31:05 <lambdabot> forall (m :: * -> *) t b. (?f::t -> m t, Monad m) => t -> m b
20:32:00 <aavogt> hmm, is that different from    sequence . iterate ?f
20:32:06 <aavogt> @type sequence . iterate ?f
20:32:07 <lambdabot> forall (m :: * -> *) a. (Monad m, ?f::m a -> m a) => m a -> m [a]
20:32:22 <aavogt> @type sequence . iterate (>>= ?f)
20:32:23 <lambdabot> forall (m :: * -> *) a. (Monad m, ?f::a -> m a) => m a -> m [a]
20:32:54 <monochrom> f is monadic. f :: t -> m t.  What does iterate f do?
20:33:38 <aavogt> not the right thing
20:33:47 <aavogt> but how about the version that includes the bind?
20:33:55 <aavogt> @type sequence . iterate (>>= ?f) . return
20:33:56 <lambdabot> forall (m :: * -> *) a. (Monad m, ?f::a -> m a) => a -> m [a]
20:34:04 <aavogt> @type sequence_ . iterate (>>= ?f) . return
20:34:05 <lambdabot> forall (m :: * -> *) a. (Monad m, ?f::a -> m a) => a -> m ()
20:35:00 <aavogt> monochrom: () is like the undefined result of your loop, no?
20:35:20 <monochrom> () is fine for my code above.
20:35:38 <aavogt> at least in that you would be more interested in the effects and not the actual value(s) in the monad
20:35:46 <monochrom> Yes.
20:35:58 <dolio> That's going to repeat actions.
20:36:29 <dolio> (return a >>= f) >> (return a >>= f >>= f) >> (return a >>= f >>= f >>= f) >> ...
20:36:50 <monochrom> Oh hahaha.
20:36:56 <dolio> Instead of return a >>= f >>= f >>= f >>= ...
20:37:50 <aavogt> true
20:38:21 <monochrom> And more interestingly: do { x0 <- firstly; fix (\m x -> if p x then return x else do {y<-secondly; m y}) x0 }
20:38:22 <aavogt> @type last . iterate (>>= ?f) . return
20:38:23 <lambdabot> forall (m :: * -> *) b. (?f::b -> m b, Monad m) => b -> m b
20:38:32 <dolio> That is bottom.
20:39:28 <monochrom> @type foldM
20:39:29 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:43:36 <aavogt> so for infinite lists the point at which you 'sequence' the results does matter
20:44:10 <aavogt> as in:   sequence . repeat  <  repeatM   ???
20:44:50 <aavogt> @free sequence
20:44:51 <lambdabot> Expected variable or '.'
20:45:06 <monochrom> @hoogle repeatM
20:45:07 <lambdabot> No results found
20:45:11 <monochrom> @hoogle repeatM_
20:45:11 <lambdabot> No results found
20:45:17 <monochrom> sorry...
20:46:03 <monochrom> repeatM_ would be forever. repeatM is a memory hog for some monads without gain.
20:46:03 <aavogt> monochrom: but is it possible to define a function that's more defined than   sequence . repeat    that is otherwise the same?
20:46:15 <aavogt> @type forever
20:46:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
20:46:27 <aavogt> @src forever
20:46:28 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:46:46 <c_wraith> don't underestimate rutabagas
20:47:03 <monochrom> forever m = m >> forever m   or an optimized equivalent
20:47:24 <aavogt> > let forever x = fix (\y -> y >> x) in execWriter $ forever (tell [1])
20:47:28 <lambdabot>   mueval-core: Time limit exceeded
20:47:35 <monochrom> wrong order. x >> y
20:47:52 <aavogt> > let forever x = fix (x >>) in execWriter $ forever (tell [1])
20:47:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:49:02 <aavogt> > execWriter $ sequence_ $ repeat (tell [1])
20:49:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:49:30 <aavogt> > execWriter $ sequence $ repeat (tell [1])
20:49:31 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:49:37 <aavogt> > runWriter $ sequence $ repeat (tell [1])
20:49:39 <lambdabot>   ([(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
20:51:37 <aavogt> monochrom: what do you mean by an optimized equivalent of forever?
20:53:18 <monochrom> forever m = go where go = m >> go.  Slightly faster. Probably doesn't matter.
20:54:22 <monochrom> The problem is if I say "forever m = m >> forever m" people may really hold me accountable just because at some future date a future implementation is slightly different.
20:54:37 <aavogt> @type fmap (const ()) . forever -- isn't this arguably safer since it fits in less places?
20:54:38 <lambdabot> forall (f :: * -> *) a. (Functor f, Monad f) => f a -> f ()
20:54:57 <monochrom> You know how people on IRC picks on your tiniest deviation and completely ignores the forest.
20:56:27 <monochrom> And holds you accountable for even things you do not say.
20:56:48 <c_wraith> monochrom, I'm insulted by your comments regarding my mother.
20:56:57 <monochrom> Haha
20:58:44 <pikhq> c_wraith, I would like to affirm that they are true. She informed of this last night, you see.
20:58:57 <monochrom> Suppose you say "He is saying OOP is the best" instead of "He is saying OOP is the best but I am just explaining what he says, this does not constitute my endorsement, I reserve the right to add more legalese disclaimer ..." then people just assume that you endorse what he says.
20:59:10 <roboshibby> i just came to the conversation, but i'll say, i personally take offense to jokes about my mother as well
20:59:31 <pikhq> roboshibby: As does your mother.
20:59:58 <roboshibby> pikhq: well she has dignity so i'd assume so =)
21:00:14 <j4cbo> hm, all i saw was <roboshibby> i just came to the conversation
21:00:16 <j4cbo> ... D: D: D:
21:00:28 <Adamant> "you all need to quit whining, you should see what I tell Trebek about his" - Sean Connery
21:01:13 <roboshibby> Adamant: you quote from celebrities?
21:01:44 <Adamant> roboshibby: I quote from fictionalized celebrities on a rarely-decent US comedy show, apparently
21:02:05 <mauke> ah, the uncyclopedia way
21:03:13 <roboshibby> Adamant: fair enough. so now i know to dismiss the majority of what you say
21:03:22 <Adamant> lol wow
21:04:30 <Adamant> that's a lot of SNL hatred built up, right there
21:05:10 <aavogt> so is the OOHaskell library used at all?
21:07:29 <dolio> @where awodey
21:07:30 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
21:07:34 <aavogt> hmm, even hlist seems infrequently used: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/HList-0.2
21:10:42 <roboshibby> Adamant: and do you see how useful it's already been to dismiss you?
21:10:49 <deech> Hi all, I was looking into the Android OS. The Android OS allows to
21:10:49 <deech>          install C libraries and call them from the Java programs.Since GHC
21:10:49 <deech>          can compile down to C, can I then use Haskell on the Android?
21:10:57 <deech> didn't mean to do that
21:11:51 <Adamant> roboshibby: I'm sorry, sir, you've mistaken me for someone who gives two shits and a fuck
21:12:05 <Adamant> roboshibby: if you don't like me put me on ignore and quit being annoying
21:12:55 <dh_> Good evening, does anybody know why we can't do : data A = Atom | Op Atom Atom ?
21:13:06 <ColonelJ> I have but one question that I must ask
21:13:09 <mauke> dh_: because Atom is not a type
21:13:11 <Gracenotes> deech: it's getting GHC runtime C onto the app that might be a problem. you can definitely link to libraries that are installed on Android by default...
21:13:14 <ColonelJ> What can a list do that a lazy list can't?
21:13:29 <Gracenotes> uh. always be in normal form?
21:13:33 <dibblego> have a terminating length function for all possible values
21:13:42 <dh_> mauke: thanks.
21:13:44 <mauke> dibblego: that looks wrong
21:14:08 <Gracenotes> well. assuming it's not cyclic.
21:14:16 <mauke> struct node x = { 0, &x }; printf("%d\n", length(&x));
21:14:23 <dibblego> I'm wondering what "list" means, only thati t doesn't mean "lazy list"
21:14:31 <ColonelJ> sorry I meant linked list
21:14:49 <ColonelJ> and as Gracenotes pointed out they can be cyclic
21:14:58 <Gracenotes> if you have a non-lazy language and an immutable singly linked list, getting a cycle is impossible, though
21:15:12 <mauke> Gracenotes: why?
21:15:22 <mauke> I just gave an example in C
21:15:35 <dh_> good night.
21:16:05 <ColonelJ> Gracenotes: I assume you mean if there are no reference types ;)
21:16:11 <dibblego> struct node x = { 0, &x }; won't terminate
21:16:17 <Gracenotes> mauke: a certain amount of laziness is used there
21:16:21 <pikhq> const struct node x = {0,&x}; // Looks like an immutable singly linked list in a cycle.
21:16:30 <mauke> dibblego: of course it will. it's not a loop.
21:16:53 <dibblego> you're right, it's a lazy list
21:17:06 <pikhq> dibblego: I see nothing lazy about it.
21:17:07 <ColonelJ> no, that's a linked list
21:17:15 <mauke> it's not lazy, because all fields are strict
21:17:16 <pikhq> Just a reference.
21:17:17 <ColonelJ> it contains a reference to itself
21:17:18 <Gracenotes> I forget what devilish semantic trick in C allows an assignment to contain a reference to itself, but it doesn't exist in some other languages
21:17:33 <mauke> and that's not an assignment
21:17:52 <lament> Scheme even has nice syntax for linked lists that contain references to themselves.
21:17:53 <ColonelJ> no, it's an initialization
21:17:55 <lament> They still aren't lazy.
21:18:06 <mauke> "devilish semantic trick" as in i = i + 1;?
21:18:18 <ColonelJ> So... back to my original question... what can linked lists do that lazy lists can't?
21:18:22 <Gracenotes> mauke: i isn't being initialized there.
21:18:34 <Gracenotes> 'declared' would be the way of saying it
21:18:35 <mauke> Gracenotes: yes, and?
21:18:38 <pikhq> ColonelJ: Dunno, since lazy lists DNE.
21:18:45 <pikhq> Perhaps you mean lazy linked lists?
21:18:53 <pikhq> In which case, well:
21:18:54 <ColonelJ> DNE?
21:18:58 <mauke> ColonelJ: what are you even talking about and what is your definition of "do"?
21:19:09 <pikhq> > let fibs = 0:1:zipWith (+) fibs (tails fibs) in fibs
21:19:10 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
21:19:11 <lament> ColonelJ: linked lists are a data structure
21:19:14 <pikhq> ColonelJ: Does not exist
21:19:30 <lament> ColonelJ: lazy is an evaluation strategy
21:19:31 <ColonelJ> let me be more specific then
21:19:34 <pikhq> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
21:19:35 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:19:42 <lament> ColonelJ: the lists in haskell are linked lists. They're lazy because haskell is lazy.
21:19:51 <ColonelJ> I'm aware of that
21:19:56 <ColonelJ> in ML they're not
21:19:59 <lament> so you're aware your question makes no sense?
21:20:22 <ColonelJ> What can lazy arrays do that linked lists can't?
21:20:26 <j4cbo> in ML they're not what?
21:20:27 <Gracenotes> mauke: I should adjust 'non-lazy language' to one that doesn't include those kind of tricks
21:20:27 <ColonelJ> other way round sorry
21:20:47 <mauke> Gracenotes: good luck with that
21:20:51 <pikhq> ColonelJ: ... Uh. Whahuhwhahuh?
21:20:53 <c_wraith> ColonelJ: grow incrementally
21:21:00 <Gracenotes> mauke: the dirty thing that's going on there is that there is some lazy gap between declaring a variable and assigning it
21:21:13 <Gracenotes> allowing the variable to be referred to in the latter step
21:21:18 <ColonelJ> c_wraith: I think both can
21:21:20 <pikhq> Gracenotes: Good luck with that. You'll just have to go the more forced way of doing data structures: representing the whole thing as an array.
21:21:37 <c_wraith> ColonelJ: An array has fixed bounds, lazy or not.
21:21:37 <mauke> Gracenotes: I don't think letrec is particularly dirty (or lazy)
21:22:03 <ColonelJ> Ahem...
21:22:11 <pikhq> Gracenotes: const int list[] = { 0, 1, 0, 0} // Odd cells are data, even cells are addresses.
21:22:12 <Gracenotes> mauke: I mean it's dirtying up my definition :)
21:22:20 <ColonelJ> What can linked lists do that lazy dynamically sized arrays can't?
21:22:37 <j4cbo> ColonelJ: is this a question or a quiz?
21:22:40 <mauke> ColonelJ: form cycles
21:22:41 <c_wraith> ColonelJ: O(1) insert time.
21:22:54 <c_wraith> (max, not amortized)
21:23:08 <pikhq> ColonelJ: Be infinite.
21:23:10 <lament> ColonelJ: either you want to ask your question again without the word "lazy" in it, or you're very confused
21:23:48 <ColonelJ> j4cbo: it's a question it's just that I have to keep refining it...
21:23:51 <Gracenotes> mauke: what I had in mind when I said that, so you don't think I'm insane, is cycles of some large length that are constructed by one cons at a time
21:23:55 <ColonelJ> c_wraith: That's a good point I think
21:25:17 <ColonelJ> c_wraith: actually I don't really understand how it's O(1) insert time on a linked list...
21:25:30 <c_wraith> well, if you always insert at the head, it is.
21:26:04 <lament> if you insert at a known point
21:26:08 <ColonelJ> I forgot to mention that the array is built backwards
21:26:10 <Gracenotes> mauke: I forgot that in declaring const foo x; x = bar; &x is legally in the scope of bar. This seems like it could just as easily not be so. Make a modicum of sense?
21:26:15 <pikhq> Gracenotes: const int list0[] = {0, -1};const int list1[] = {list0[0], 1, 0, -1};const int list2[] = {list1[0], list1[1], list1[2], 2, 0, 0};
21:26:20 <ColonelJ> in which case, insertions near the head involve very few moves
21:26:22 <fhobia> is there a standard way of creating a Data.Map that given a key just returns the key as the value ?
21:26:23 <lament> ColonelJ: what the hell is your *actual* question? You seem to be withholding information.
21:26:26 <j4cbo> ColonelJ: is this a homework assignment, or what?
21:26:40 <ColonelJ> j4cbo: no I'm trying to design a programming language
21:26:57 <pikhq> Gracenotes: There. Built up a cons at a time, cycle, in a strictly evaluated context. With no mutation.
21:27:02 <ColonelJ> lament: I'm trying to figure out if linked lists are required for a functional language
21:27:19 <lament> No.
21:27:29 <Gracenotes> pikhq: what do the arrays represent again?
21:27:33 <mauke> ColonelJ: obviously not, because you don't need any data structures
21:27:36 <SamB_XP_> a functional language will be able to do linked lists
21:27:45 <mauke> ColonelJ: functions are sufficient to do everything
21:27:46 <SamB_XP_> but that just falls out
21:27:55 <ColonelJ> mauke: ok I think that's all I needed to know
21:27:57 <lament> Linked lists are ridiculously convenient in Haskell as a way to express iteration.
21:28:00 <pikhq> Gracenotes: They represent the following: struct node {int data;struct node*next};
21:28:03 <j4cbo> ColonelJ: i think you're in over your head...
21:28:19 <SamB_XP_> it doesn't need anything to be done explicitly by the language -- they will just happen regardless ;-)
21:28:24 <pikhq> Except with array indexes instead of struct node*'s.
21:28:51 <j4cbo> all you actually need is lambda
21:28:51 <lament> SamB_XP_: well in MY language, there're NO linked lists!!!
21:28:53 <Gracenotes> pikhq: does your representation include pointer references?
21:28:59 <j4cbo> or, equivalently, a DFA attached to an unbounded tape
21:29:06 <ColonelJ> j4cbo: and lambda i have, though not in the conventional form
21:29:07 <j4cbo> but that doesn't give you something you'd want to write code in :P
21:29:24 <j4cbo> "not in the conventional form"?
21:29:24 <SamB_XP_> lament: prove it!
21:29:25 <pikhq> Gracenotes: ...
21:29:28 <Gracenotes> j4cbo: would rather use pure lambda calculus than a turing machine
21:29:37 <j4cbo> Gracenotes: i agree
21:29:46 <roboshibby> hey guys, is - (dash) a normal character to use in method names? i use underscores at times as well
21:29:48 <ColonelJ> who wants to program in a turing machine...? lol
21:30:07 <roconnor> > x-y
21:30:08 <Gracenotes> j4cbo: particularly if you have a way of copy+pasting lambda abstractions
21:30:08 <lambdabot>   x - y
21:30:12 <SamB_XP_> yeah, lambda calculus is directly related to a form I can stand to actually program in ...
21:30:17 <ColonelJ> roboshibby: - isn't a dash it's a hyphen, usually used to represent subtractions though
21:30:18 <lament> SamB_XP_: My language is Brainfuck :)
21:30:31 <roboshibby> ah yea hyphen
21:30:39 * roconnor uses the X combinator language
21:30:40 <SamB_XP_> lament: I'm not sure I understand how you can't do linked lists in BF
21:30:41 <kmc> @bot
21:30:41 <lambdabot> :)
21:30:41 <lunabot>  :o
21:30:42 <j4cbo> Gracenotes: \ plus let-in might be ok
21:30:55 <pikhq> Gracenotes: If the array is at address 0, the array is also valid as a list of: struct node{int x;struct node*data}.
21:31:09 <SamB_XP_> but in any case, BF isn't a functional programming language by any stretch of MY imagination ...
21:31:16 <pikhq> That's how you do data structures in imperative languages without references, BTW. ;)
21:31:21 <ColonelJ> j4cbo: actually, really the only difference from the convential form is that I put the bindings after the function instead of in front... good reason for this
21:31:32 <lament> SamB_XP_: there's a big difference between "can't do" and "aren't reified"
21:31:43 <mauke> ColonelJ: ... it makes the code harder to read?
21:31:45 <Gracenotes> pikhq: hm. It's not just sinking into my brain at the moment
21:32:06 <pikhq> Gracenotes: It's just C semantics.
21:32:07 <Gracenotes> by the '*' you do mean a pointer, I take it
21:32:08 <ColonelJ> mauke: No, it's a concatenative language
21:32:10 <pikhq> ... Emulated using an array.
21:32:19 <j4cbo> ColonelJ: lexical scoping or dynamic scoping?
21:32:31 * pikhq beats Gracenotes with "The C Programming Language"
21:32:49 <Gracenotes> yeah, just making sure it wasn't a psuedocode struct or something. the transformation is not obvious to me, is all.
21:32:55 <ColonelJ> j4cbo: lexical scoping
21:33:08 <SamB_XP_> go easy on people who aren't sure what notation we be using ;-)
21:33:11 <Gracenotes> emulation implies abstraction. my brain is fried and I just see an array of integers. -_-
21:33:19 <lament> languages concatenative head my hurt make
21:33:26 <mauke> everything is an array of integers in C
21:33:32 <mauke> except for functions
21:33:41 <pikhq> Gracenotes: int memory[]; // With me so far?
21:33:45 <SamB_XP_> Gracenotes: well, remember how you do data structures in BASIC ?
21:34:07 <ColonelJ> lament: lol
21:34:26 <Gracenotes> yeah. the kinds I made when I was 10 years old, that stored how hungry my cyberpet was
21:34:27 <SamB_XP_> lament: "make" is only valid at the beginning of the command line, sorry ;-P
21:34:33 <nornagon> mauke: functions are arrays of integers too!
21:34:38 <mauke> nornagon: no
21:34:43 <SamB_XP_> Gracenotes: I was thinking more like the kind where you store a binary tree
21:34:57 <ColonelJ> nornagon: not in my language they aren't
21:35:00 <SamB_XP_> nornagon: maybe in POSIX ...
21:35:00 <nornagon> printf("%d\n", ((int*)printf)[0])
21:35:02 <lament> @quote pestov
21:35:02 <lambdabot> No quotes match.
21:35:06 <lament> @quote slava
21:35:06 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
21:35:06 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
21:35:13 <mauke> nornagon: not valid C
21:35:44 <SamB_XP_> huh ... that's some kind of pun on "Call center outsourcing", isn't it ?
21:35:46 <ColonelJ> in my language the implementation of a function can change at the drop of a hat
21:35:49 <nornagon> mauke: sure does compile for me
21:35:52 <lament> @quote slava
21:35:53 <lambdabot> slava says: Does Steve Yegge even write code or does he just blog about things he doesn't really understand 9-5?
21:35:56 <mauke> nornagon: irrelevant
21:36:06 <lament> @quote factor
21:36:06 <lambdabot> quicksilver says: or in Java, we'd make it more generic by using a PolynomialDivisionOperatorFactory.
21:36:11 <pikhq> Gracenotes: Now, memory = {0, 1, 1, 2, 2, 3, 3, -1}. That's exactly like doing: NULL->next=&(node){1};NULL->next->next=&(node){2};NULL->next->next->next=&{3,-1};
21:36:17 <Gracenotes> SamB_XP_: you might use the type of structure which can be seen still in binary heaps
21:36:25 <nornagon> mauke: would you explain how a function is *not* an array of integers?
21:36:37 <ColonelJ> lament: I have factor installed and have been playing with it
21:36:42 <lament> @quote forth
21:36:42 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
21:36:47 <mauke> nornagon: the C standard says functions aren't objects. the end.
21:36:50 <pikhq> nornagon: You can't legally cast function pointers to non-function pointers.
21:36:51 <ColonelJ> lament: and I have spoke to slava
21:36:56 <ColonelJ> *spoken
21:37:11 <SamB_XP_> kmc: but Ruby starts with a P, didn't you get the Memo?
21:37:16 <Gracenotes> lol. this conversation is so fun when you have a headache.
21:37:28 <lament> ColonelJ: have you spoken to chuck moore?
21:37:32 <lament> @quote moore
21:37:33 <lambdabot> No quotes match. :(
21:37:35 <lament> @quote chuck
21:37:35 <lambdabot> inimino says: actually, Chuck Norris is the Oleg of everything else
21:37:59 <nornagon> in that case, perhaps it would be more accurate to say that in C, functions are "usually implemented as arrays of integers"?
21:38:01 <ColonelJ> lament: no I haven't
21:38:06 <lament> good!
21:38:24 <Gracenotes> pikhq: yeah, makes sense like that. But immutability sort of implies SSA semantics in my mind, not just laying out memory altogether
21:38:26 <mauke> nornagon: implementations are not C
21:38:38 <mauke> in fact, C is usually not implemented in C
21:38:42 <pikhq> Gracenotes: But I did it with SSA.
21:38:48 <pikhq> Gracenotes: const int list0[] = {0, -1};const int list1[] = {list0[0], 1, 0, -1};const int list2[] = {list1[0], list1[1], list1[2], 2, 0, 0};
21:38:51 <nornagon> gcc is written in C, is it not?
21:38:54 <ColonelJ> nornagon: that doesn't make sense much
21:39:00 <SamB_XP_> mauke: most C code isn't written in C, either ;-P
21:39:06 <mauke> nornagon: yes, but it doesn't compile to C
21:39:19 <nornagon> oh, i see
21:39:19 <ColonelJ> nornagon: it probably is, what's your point?
21:39:24 <pikhq> nornagon: More like in C, functions are usually implemented as goto. With a stack.
21:39:26 <Gracenotes> pikhq: you're on a different abstraction level than I am :)
21:39:30 <nornagon> ColonelJ: < mauke> in fact, C is usually not implemented in C
21:39:34 <Gracenotes> when I talk about SSA.
21:39:40 <pikhq> Gracenotes: Yes, yes, yes.
21:39:41 <lament> nornagon: actually, everything is made of subatomic particles, and numbers don't even exist.
21:39:56 <pikhq> Gracenotes: That's more like a hack to force it to be very technically SSA, really.
21:39:57 <Gracenotes> pikhq: which is disgraceful! a bastardization of my.. totally unclear.. initial claim!
21:39:59 <pikhq> :P
21:40:10 <Gracenotes> what did I claim in the first place anyway
21:40:16 <mauke> how do I shot web?
21:40:17 <nornagon> lament: i've already made the distinction between implementation and definition
21:40:32 <c_wraith> mauke: I'm impressed you didn't mutilate that meme
21:40:34 <pikhq> Can't do cyclic linked lists while being non-lazy and immutable.
21:40:37 <Gracenotes> anyway. I'll have to think about implementing data structures in a way when you only have arrays.
21:40:37 <lament> nornagon: good! C functions certainly aren't defined as arrays of numbers.
21:40:40 <ColonelJ> mauke: really? I didn't know that!  But I have no evidence to show otherwise, and I know a lot of C implementations of C compilers exist, which is not the case for most languages.
21:40:54 <nornagon> lament: that's why i said 'implemented as' above!
21:40:56 <j4cbo> SSA is a good time.
21:41:00 <SamB_XP_> mauke: something about a radioactive spider and a pure heart, and you have to wiggle your wrists a certain way ...
21:41:13 <SamB_XP_> or if you read the comics, you gotta actually make your own web shooters
21:41:16 <lament> nornagon: they're implemented as subatomic particles, or rather, as fluctuations in electric fields :)
21:41:30 <nornagon> indeed :)
21:41:32 <mauke> SamB_XP_: ah, but this is not a spiderman meme
21:41:50 <SamB_XP_> mauke: oh ... what kind of meme *is* it then?
21:41:51 <roboshibby> it's funny watching nerds try to one-up each other
21:41:55 <SamB_XP_> who else shot web?
21:42:02 <Gracenotes> pikhq: ah. maybe just SSA would be a simpler way of saying that. And then there's the strategy of totally ignoring the reference idea and laying out references explicitly. Sort of like storing a graph as an [[Int]]
21:42:04 <roboshibby> because it's like, wow who cares about what either of you are saying.
21:42:17 <SamB_XP_> roboshibby: we care
21:42:18 <SamB_XP_> a bit
21:42:23 <Gracenotes> roboshibby: hey. I am learning things. Sort of.
21:42:24 <nornagon> roboshibby: i think you have failed to grasp the concept of Socratic dialog.
21:42:37 <SamB_XP_> though they are, like, dust-mite picking at this point ...
21:42:38 <pikhq> Gracenotes: Basically "Screw language semantics, I'm making it work". ;)
21:42:41 <roboshibby> discussion != nerd-boner-waving
21:42:53 <ColonelJ> pikhq: make it work first, semantics later
21:43:04 <j4cbo> that's the sort of thinking that leads to things like C
21:43:06 <j4cbo> or, worse
21:43:08 <j4cbo> C++
21:43:15 <Gracenotes> hah
21:43:19 <SamB_XP_> j4cbo: they were talking about C anyway ...
21:43:39 <Gracenotes> and how its semantics make me wrong :(
21:43:42 <pikhq> j4cbo: In this case, you screw language semantics by emulating C semantics with an array, so... Yeah.
21:43:45 <nornagon> roboshibby: you have possibly made a poor choice in coming into a *haskell* channel and accusing people of talking about nerdy things!
21:44:16 <SamB_XP_> roboshibby: yeah, we're liable to accuse you of NOT talking about nerdy things
21:44:44 <roboshibby> i said as a form of one-ups
21:44:44 <j4cbo> first, you must prove progress and preservation.
21:44:57 <ColonelJ> type preservation you mean?
21:45:04 <SamB_XP_> ooh, where see extra lives based on nerdiness ?
21:45:09 <j4cbo> right
21:45:22 <ColonelJ> j4cbo: yeah I'm going to do those before trying to implement it
21:45:38 <mauke> SamB_XP_: my learnings indicate a game of Natural Selection
21:45:43 <Gracenotes> roboshibby: well, if we cannot value intellect and the holy grail of correctness, what left is there to live for??
21:45:44 <ColonelJ> j4cbo: and probably in the process find some horrible mistakes out, then rinse and repeat
21:45:54 <SamB_XP_> mauke: but I said EXTRA lives
21:45:55 <j4cbo> whee!
21:45:57 <ColonelJ> j4cbo: If I'm lucky I'll end up with a language that actually works
21:46:39 <roboshibby> gracenotes, i dont understand why this is obviously so difficult to see, but what im laughing at is being nerdy (talking about intellectually demanding things) while making such an obvious social flaw (one-upping)
21:46:50 <ColonelJ> So... does anyone disagree that functions can do everything?
21:46:52 <roboshibby> it's ironic to me. it's talking about smart shit while being an idiot. does it make sense now?
21:47:15 <j4cbo> ColonelJ: i suspect that you don't *actually* want to implement a lambda calculus compiler...
21:47:15 <SamB_XP_> lets face it ... smart people are idiots too ;-P
21:47:17 <Gracenotes> yeah, I see your point. though not your conclusion, particularly.
21:47:40 <roboshibby> well, people differ, so i can live with that. at least you follow my logic
21:47:44 <mauke> how is being nerdy intellectually demanding?
21:47:54 <ColonelJ> j4cbo: Maybe i'm missing something, but what's the difference between that and any other compiler?
21:48:01 <SamB_XP_> mauke: you have to understand all this technical shit!
21:48:03 <roboshibby> mauke, try to understand the spirit of what i was saying and not outsmart yourself.
21:48:09 <nornagon> roboshibby: it's a game
21:48:20 <j4cbo> ColonelJ: i mean, you want more than just functions :P
21:48:22 <mauke> SamB_XP_: like pokemon?
21:48:55 <mauke> also, I thought being nerdy was a social flaw in itself
21:49:16 <ColonelJ> j4cbo: yeah there a few more things like primitive data types and operations,... *horror* sequence points, and mutable data
21:49:25 <j4cbo> ewww :P
21:49:27 <SamB_XP_> mauke: eh ???
21:49:39 <Gracenotes> roboshibby: thinking about it a bit more... I haven't really thought of it as one-upmanship, and I'm not so sure keeping people intellectually alert spoils things. Unless they're being annoying and nitpicking about levels of details that were intentionally left before.
21:49:40 <SamB_XP_> I thought *not* being nerdy was the social flaw
21:49:52 <Jafet> Let's refute mauke, therefore proving his point
21:49:52 <pikhq> ColonelJ: What you really *must* have is lambda and def.
21:50:03 <pikhq> And a large number of builtin defines.
21:50:07 <Gracenotes> e.g. telling people who don't know Haskell that all functions only take one argument, period.
21:50:34 <roboshibby> all functions only have 1 parameter?
21:50:35 <pikhq> Almost sure to be a criminally inefficient Lisp, but hey.
21:50:42 <ColonelJ> pikhq: basically I have lambda and the ability to bind things to words
21:50:44 <pikhq> roboshibby: Yeah, that's the Haskell way.
21:50:51 <Gracenotes> despite the fact that they know this, and mean something else, namely how many are required to get a non-function value
21:51:07 <pikhq> ColonelJ: Okay, then. Everything else can be implemented rather easily.
21:51:22 <pikhq> Well, if you know how to look up cons, car, cdr, and Church numerals.
21:51:23 <pikhq> :P
21:51:23 <ColonelJ> pikhq: you say that, but I disagree entirely
21:51:31 <j4cbo> :P
21:51:31 <roboshibby> pikhq, strange, this is how i code. even in languages that allow multiple parameters. why is this done in haskell?
21:51:34 <Jafet> Lisp lambdas create procedures. Haskell lambdas create functions.
21:52:03 <SamB_XP_> roboshibby: because curry is delicious?
21:52:13 <ColonelJ> my language allows you to add and remove arguments willy nilly almost
21:52:20 <j4cbo> that sounds hard to typecheck
21:52:24 <Gracenotes> pikhq: even in languages with implicit parameters (like classes)? :)
21:52:29 <pikhq> roboshibby: \x y z->1 is not a function of 3 arguments that results in an Integer. It is a function of 1 argument that results in a function of 1 argument that results in a function of 1 argument that results in an Integer.
21:52:37 <ColonelJ> j4cbo: yes, and herein lies the big problem I am going to have
21:52:43 <lament> Gracenotes: f x y z = blah sure looks like a function with three parameters to me
21:52:59 <mauke> f = \x -> \y -> \z -> blah
21:53:01 <lament> Gracenotes: regardless of what f a evaluates to
21:53:02 <roboshibby> j4cbo: what sounds hard to typecheck?
21:53:04 <monochrom> f x y z = \a b c d -> ...
21:53:09 <ColonelJ> j4bco: however the language is concatenative, so there is some hope
21:53:11 <monochrom> @quote monochrom arity
21:53:11 <lambdabot> No quotes match.
21:53:14 <Jafet> const (const (const 1))
21:53:16 <j4cbo> ColonelJ, got type inference?
21:53:16 <monochrom> @quote monochrom ary
21:53:17 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
21:53:20 <lament> mauke: that's not what i wrote.
21:53:25 <ColonelJ> j4cbo: yes, it's key to the whole thing
21:53:29 <Gracenotes> lament: ...I think I agree with you?
21:53:33 <j4cbo> be careful
21:53:41 <j4cbo> you don't need to add much to hindley-milner to make it undecideable
21:54:10 <Jafet> It adds excitement to compile times
21:54:15 <roboshibby> pikhq: whoa that's how i built a lexer to work. and i passed the input as parameter
21:54:17 <roboshibby> incredible
21:54:22 <j4cbo> compile times are already exciting!
21:54:30 <pikhq> ColonelJ: let cons = \x y m -> m x y;car = \z->z (\p _->p);cdr = \z ->z (\_ q-> q)
21:54:32 <j4cbo> i've seen code that makes certain implementations of SML take 2^2^n.
21:54:35 <lament> Gracenotes: i mean, there's a very real sense in which it's wrong to say that haskell functions take one parameter. Just like for example it's wrong to say that C doesn't have strings
21:54:41 <j4cbo> (which is the worst case for hindley-milner anyway)
21:54:57 <ColonelJ> pikhq: scheme!
21:55:15 <Gracenotes> lament: yeah. There is a tendency here and there for people to bring up the factoid not in those senses.
21:55:24 <monochrom> C doesn't have pass-by-reference <duck>
21:55:33 <lament> haha
21:55:34 <Gracenotes> STG is big on multi-parameter functions
21:55:36 <ColonelJ> j4bco: ouch
21:55:49 <SamB_XP_> monochrom: oh, god, I hate when that discussion comes up on ##c!
21:55:54 <roboshibby> so haskell /does/ have multiple parameter functions? or not
21:55:55 <lament> hahaha
21:55:57 <ColonelJ> j4bco: I was worried about this
21:55:58 <monochrom> s-exp doesn't have syntax
21:56:03 <j4cbo> ColonelJ: my nick is j4cbo, and you should use tab completion :P
21:56:07 <mauke> monochrom: I wish :-/
21:56:12 <SamB_XP_> monochrom: I always lose!
21:56:18 <lament> SamB_XP_: are you still in ##C? How's that working out?
21:56:23 <nornagon> roboshibby: it has things that look like multiparameter functions
21:56:26 <ColonelJ> j4cbo: your name is too short for that
21:56:27 <SamB_XP_> lament: well, evidently I'm not
21:56:28 <j4cbo> SamB_XP_: how's Zhivago these days?
21:56:32 <Gracenotes> roboshibby: there is a sense in which you can pass a function one argument and it will return a valid value
21:56:35 <nornagon> roboshibby: but that's actually just syntax sugar
21:56:38 <monochrom> SamB_XP_: Don't participate in those discussions!
21:56:42 <roboshibby> nornagon: do tell?
21:56:46 <SamB_XP_> which would explain why I'm not a loathing ball of anger ;-)
21:56:53 <lament> Whether or not C has strings is another popular topic in ##C
21:56:58 <Gracenotes> roboshibby: regardless of how many it *can* accept before complaining that something can't be applied
21:57:11 <pikhq> ColonelJ: Also, let 0=\f x->x;1=\f x->f x;succ = \n f x->f (n f x)
21:57:13 <nornagon> roboshibby: f a b c = ...  is sugar for  f a = \b -> (\c -> ...)
21:57:17 <pikhq> There, Church numerals.
21:57:25 <Jafet> Well, n-ary functions are syntactic sugar in Haskell. You can curry the definition and all uses of it will still work
21:57:26 * SamB_XP_ always takes the side that C *has* pass-by-reference
21:57:45 <lament> Jafet: *extremely* pervasive syntactic sugar, though
21:57:46 <mauke> then C also has closures
21:57:53 <monochrom> Taking side is OK. Just don't waste time defending it.
21:57:55 <roboshibby> but properly, it doesn't 'work using' multi param functions
21:57:59 <lament> Jafet: you could almost call it a language *feature*
21:58:03 <Jafet> You don't have to rewrite any of the places where it's used.
21:58:06 <ColonelJ> SamB_XP_: no that's C++
21:58:08 <pikhq> mauke: Yes, but they're very buggy. :)
21:58:11 <Jafet> It's a brain-dead syntactic transformation.
21:58:14 <Gracenotes> in compiling down to STG (a lower level intermediate representation), GHC likes to know how many it actually "accepts", aka its arity
21:58:24 <lament> Jafet: so?
21:58:24 <Gracenotes> especially for constructors
21:58:25 <monochrom> Haha see what I started.
21:58:29 <SamB_XP_> ... not as a language feature, but as a cultural thing
21:58:44 <monochrom> Oh, Haskell is pure functional.
21:58:46 <Jafet> So it's about as much "syntactic sugar" as do notation and pattern guards are
21:59:21 <Gracenotes> what's the arguments against C having strings, anyway? does null termination not count? >_>
21:59:35 <pikhq> Jafet: do notation is very much syntactic sugar (for >>=), and pattern guards are very much syntactic sugar (for case)
21:59:35 <ColonelJ> If it doesn't have a null terminator, it's not a string
21:59:38 <mauke> Gracenotes: it doesn't have a string *type*
21:59:51 <SamB_XP_> yeah, C doesn't have a string type, that's quite true
21:59:53 <j4cbo> Gracenotes: with the exception of string literals, those can be argued to be part of the standard library, rather than the language
21:59:56 <Gracenotes> ah. I see. Just pointer to/array of character
22:00:00 <j4cbo> and can be easily done without
22:00:06 <lament> the fact that it only takes a braindead syntactic transformation to add multi-parameter functions to a language that already has single-parameter functions doesn't mean that said language, including the transformation, doesn't have multi-parameter functions
22:00:12 <Jafet> pikhq, if you say those are syntactic sugar, you would have to say that multi-parameter functions are as well
22:00:37 <ColonelJ> string literals in C are constant character arrays ending with a null terminator
22:00:51 <SamB_XP_> hmm ... actually, I heard that there WAS a semantic difference between multi-parameter functions and explicitly-curried ones in some instances ...
22:00:53 <pikhq> Jafet: Yes. Though the implementation optimizes on arity, that's just an implementation detail.
22:00:55 <nornagon> lament: what does it mean to 'have' multi-parameter functions, anyway?
22:00:59 <nornagon> SamB_XP_: oh?
22:00:59 <monochrom> Haskell is pure functional. getLine doesn't do anything, it justs sits there.
22:01:06 <SamB_XP_> I forget what situations, though ...
22:01:13 <Gracenotes> it seems the decision problems in computer science (does blah have X attribute or not?) waste the most time >_>
22:01:15 <lament> Jafet: it takes a braindead syntactic transformation to add simple macros to C (it's called cpp). But that doesn't mean that C with cpp doesn't have macros.
22:01:15 <Jafet> SamB, not in vanilla Haskell, surely?
22:01:19 <ColonelJ> monochrom: that's what my language does!
22:01:22 <SamB_XP_> ... but I'm fairly certain it has something to do with strictness
22:01:31 <ColonelJ> very much inspired by the monads thing
22:01:49 <Gracenotes> ColonelJ: do you have a link to it?
22:01:57 <Gracenotes> to some home-on-the-web
22:02:04 <roboshibby> ColonelJ: sounds coo tell us about your language
22:02:17 <Jafet> lament, hm? Macros *are* the syntactic transformation
22:02:21 <ColonelJ> I wrote some code samples
22:02:38 <ColonelJ> I'll write a quick gloss over of the syntax to go with it and paste it somewhere
22:02:43 <ColonelJ> you'll have to wait 10 mins
22:02:49 <ColonelJ> bbl
22:02:53 <roboshibby> np
22:02:53 <nornagon> perhaps the fundamental misunderstanding here is that things that are syntax sugar are 'not part' of the language
22:03:08 <roboshibby> nornagon: nod
22:03:42 <nornagon> so when we say 'x is syntax sugar', we mean 'x has a trivial mapping to a more basic form within the language'
22:04:01 <roboshibby> yes, a composition
22:04:20 <Jafet> In other words, a "convenience feature"
22:04:33 <roboshibby> yeh
22:04:37 <Jafet> That doesn't add semantic complexity to the language.
22:04:42 <SamB_XP_> nornagon: except, apparantly, sometimes they don't quite have the mappings we think they do!
22:04:43 <nornagon> really, everything above machine code is a 'convenience feature' :)
22:04:50 <Jafet> Although I'd be interested in what SamB has to say about strictness
22:04:54 <roboshibby> but how the extension is built does matter o(n)
22:04:56 <nornagon> SamB_XP_: apparently!
22:05:01 <monochrom> A language is a syntactic sugar for its semantics.
22:05:15 <pikhq> foo[bar]; // Syntactic sugar. Whoo!
22:05:17 <lament> syntax sugar that reifies some concept is pretty important
22:05:24 <Gracenotes> monochrom: the denotational ones, at least
22:05:34 <roboshibby> what's reify?
22:05:37 <nornagon> pikhq: i love how foo[1] is semantically identical to 1[foo]
22:06:00 <Jafet> monochrom, oh joy.
22:06:00 <j4cbo> enums. ugh, enums.
22:06:02 <monochrom> 1["hello"]
22:06:05 <SamB_XP_> roboshibby: ... I stll don't know that ;-)
22:06:14 <pikhq> I love how &foo[0] is identical to foo.
22:06:27 <pikhq> SamB_XP_: foo[bar] = *(foo+bar)
22:06:29 <mauke> pikhq: that follows quite logically
22:06:31 <monochrom> I love foo.
22:06:36 <SamB_XP_> pikhq: but only if foo was already a pointer
22:06:47 <lament> roboshibby: making accessible as an "entity" in some way
22:06:47 <pikhq> SamB_XP_: No.
22:06:51 <Jafet> http://www.ioccc.org/1987/korn.c
22:06:56 <SamB_XP_> pikhq: I mean, I still don't get the meaning of "reify"
22:06:58 <roboshibby> ah, like exposing an identity
22:07:01 <SamB_XP_> not that I don't know that array thing
22:07:14 <SamB_XP_> I've checked the C standard over with a fine toothed comb to make sure that was legal!
22:07:17 <pikhq> SamB_XP_: Ah.
22:07:39 <nornagon> pikhq: erm, pretty sure yes -- &foo[0] === &(foo[0])
22:07:41 <pikhq> mauke: Yes, but still.
22:07:49 <roboshibby> jafet, lol, well done sir
22:07:54 <Gracenotes> I forget how messed up C can get
22:08:00 <SamB_XP_> I don't think I found even a hint that 1[foo] wasn't the preferred form ?
22:08:02 <pikhq> nornagon: &foo[0] = &*(foo+0) = foo
22:08:16 <lament> roboshibby: for example, "hello" is a string, and you can safely claim that Haskell has strings because you can write "hello"
22:08:28 <nornagon> but only if foo is a pointer :)
22:08:36 <roboshibby> ahh
22:08:37 <SamB_XP_> :t "Foo"
22:08:38 <lambdabot> [Char]
22:08:42 <SamB_XP_> hmm...
22:08:50 <Jafet> :t "Foo"::String
22:08:51 <pikhq> nornagon: No.
22:08:51 <lambdabot> String
22:08:53 <lament> roboshibby: even though supposedly that's just syntax sugar for ['h', 'e', 'l', 'l', 'o'], which is itself syntax sugar for constructing that list explicitly
22:08:53 <monochrom> Haskell does not have strings.
22:08:54 <roboshibby> reify is like establishing some thing's existence
22:09:04 <SamB_XP_> but the langauge itself doesn't seem to bake in the String type
22:09:09 <monochrom> But it now has bytestrings.
22:09:21 <j4cbo> not having strings is a huge wart, but i'll bitch about that some other time :P
22:09:22 <roboshibby> do you guys like that haskell doesnt have strings? or is that a bitch
22:09:23 <Jafet> lament, see what I said about semantic complexity
22:09:26 <lament> SamB_XP_: My Haskell certainly comes with a String type
22:09:28 <pikhq> nornagon: &0[foo] = &*(0+foo) = foo
22:09:28 <roboshibby> LOL
22:09:53 <roboshibby> j4cbo: great timing pal
22:10:21 <SamB_XP_> lament: I mean, the typechecker doesn't use the type String unless it got mentioned explicitly in a type signature *somewhere*
22:10:33 <lament> Jafet: by talking of "strings" as opposed to "arrays of characters" we go up an abstraction level. You can't say there's no added complexity.
22:10:44 <nornagon> pikhq: hm, right.
22:10:49 <j4cbo> roboshibby: well, it should be said that i am of a rare and dying breed that doesn't really belong in this channel :P
22:10:55 <Gracenotes> @src String
22:10:55 <lambdabot> type String = [Char]
22:10:59 <nornagon> pikhq: what if foo :: struct time_t?
22:11:12 <Jafet> Is String required to be a synonym of [] Char?
22:11:17 <mauke> Jafet: yes
22:11:28 <Jafet> Then I would say there is no added semantic complexity.
22:11:37 <lament> I don't know what semantic complexity means
22:11:41 <Jafet> Me neither
22:12:01 <roboshibby> i like pie?
22:12:01 <Jafet> Oh well. This has gone on long enough
22:12:14 <SamB_XP_> lament: it means the semantics make your head hurt
22:12:17 <monochrom> is semantic complexity the dual of syntactic sugar?
22:12:23 <SamB_XP_> it's measured on the Aspirin scale, iirc
22:12:30 <j4cbo> - oxygen is good
22:12:32 <j4cbo> - competition is bad
22:12:35 <j4cbo> - i like jello
22:12:43 <pikhq> nornagon: Won't be cast to an integer, so no.
22:12:44 <monochrom> - burma shave
22:12:45 <SamB_XP_> - lets go shopping
22:12:51 <lament> @quote shopping
22:12:51 <lambdabot> samc says: monads are hard. let's go shopping!
22:12:58 <monochrom> hahaha
22:13:02 <roboshibby> apparently co2 is poison, though i guess plants and animals and biologists didn't get the memo :P
22:13:13 <mauke> preflex: quote
22:13:14 <preflex>  <deserted> however the addition of the additional processing power available can actually result in a speed increase using threads
22:13:15 * roboshibby shudders when he thinks of politicians involving themselves in science...
22:13:20 <monochrom> c# does not have monads
22:13:32 <pikhq> Darn, gcc complains of &0[0].
22:13:34 <lament> that's why i like C#
22:13:36 <lament> no monads!
22:13:40 <SamB_XP_> roboshibby: well, it's not poison to plants ;-P
22:13:45 <SamB_XP_> it's a waste product, somehow ...
22:13:51 <roboshibby> SamB_XP_: that's my point
22:14:05 <mauke> pikhq: well, *0 is invalid
22:14:07 <SamB_XP_> but I'm pretty sure it IS bad for biologists to get too much of
22:14:07 <roboshibby> SamB_XP_: no, that's propaganda by way of ignorance of facts
22:14:31 <SamB_XP_> at least, it's toxic not to get oxygen
22:14:34 <j4cbo> new topic of discussion:
22:14:34 <SamB_XP_> or something ;-P
22:14:40 <j4cbo> which programming language is the greatest travesty?
22:14:45 <Gracenotes> monochrom: yep, and no language can beat Arc in the Arc Challenge with fewer nodes
22:14:45 <c_wraith> this is reminding me of xkcd's discussion about how physicists don't actually like working in frictionless vacuums
22:14:49 <monochrom> What is travesty?
22:14:55 <roboshibby> the whole thing is silly because ive studied horticulture and it's a commonly known fact that co2 levels autobalance because as it increases, plants grow quicker and thereby consume more and produce more oxygen
22:14:56 <SamB_XP_> monochrom: well, C++ for instance
22:15:23 <Gracenotes> monochrom: "Code to import standard libraries doesn't count, of course; you can assume those are already loaded."
22:15:28 <j4cbo> monochrom: http://dictionary.reference.com/browse/travesty
22:15:33 <mauke> preflex: quote
22:15:34 <preflex>  <foone2> feet reassignment surgery
22:15:36 <Gracenotes> also, "baby don't hurt me"
22:15:38 <SamB_XP_> roboshibby: it's only silly if you have enough plants in the system for this process to occur
22:15:58 <roboshibby> SamB_XP_: the earth does =)
22:15:58 <j4cbo> "any grotesque or debased likeness or imitation: /a travesty of justice/."
22:16:07 <SamB_XP_> and there are OTHER effects that CO2 has, I believe, that *are* bad
22:16:15 <pikhq> mauke: &1[(void*)1] appears to work just fine, though.
22:16:27 <roboshibby> SamB_XP_: yes, by being used incorrectly as a political and corporate tool =)
22:16:31 <mauke> pikhq: using gcc -ansi -pedantic?
22:16:40 <pikhq> Un momento.
22:16:52 <SamB_XP_> I Was thinking more along the lines of global warming ?
22:17:00 <roboshibby> i think they forgot basic chemistry and the difference between carbon monoxide and carbon dioxide
22:17:44 <pikhq> mauke: Oh, it gives three warnings but it compiles.
22:17:50 <roboshibby> im not saying greedy corporations don't pollute horribly, as well consumerism exacerbates grotesque industrialism, but global warming is a farce. to say by co2, is simply ridiculous to anyone with a 5th grade education
22:17:58 <pikhq> foo.c: In function main:
22:17:58 <pikhq> foo.c:4: warning: pointer of type void * used in arithmetic
22:17:58 <pikhq> foo.c:4: warning: dereferencing void * pointer
22:17:58 <pikhq> foo.c:4: warning: cast from pointer to integer of different size
22:18:04 <Jafet> So... arrows! They point! Like, er... pointers!
22:18:05 <mauke> pikhq: so that's not valid C
22:18:40 <SamB_XP_> roboshibby: um, global warming happens
22:18:49 <pikhq> The last warning is because I'm then casting it to int.
22:18:54 <monochrom> Oh God.
22:18:58 <roboshibby> SamB_XP_: on natural cycles, yes, but not in the sense it's referred to in
22:18:59 <pikhq> The first two can be fixed by making that char*.
22:19:09 <mauke> yes
22:19:13 <SamB_XP_> now, I'm not sure we have evidence that it isn't SUPPOSED to happen, but I'm not sure we've got much for either ...
22:19:28 <mauke> pikhq: the last one can be fixed by using 0 instead of 1 :-)
22:19:34 <pikhq> mauke: Hahahah.
22:19:48 <monochrom> hahaha
22:19:53 <SamB_XP_> in any case, we may be accelerating it, and even if it can't be STOPPED, we're going to have to do *something* about it ...
22:19:57 <pikhq>   printf("%p\n", &((char*)1)[1]);
22:20:02 <pikhq> There, all better?
22:20:21 <roboshibby> you don't even have to go that far. im not even really talking about global warming. what i am saying, is to say co2 is dangerous for our atmosphere is to either be ignorance or collusion.
22:20:22 <mauke> pikhq: I'm not sure if that's a type error
22:20:23 <mrd> -> -blah
22:20:29 <pikhq> mauke: It's not.
22:20:34 <pikhq> %p takes a pointer.
22:20:37 <mauke> pikhq: wrong
22:20:41 <mauke> pikhq: "pointer" is not a type
22:20:45 <Jafet> You can't have type errors with printf
22:20:48 <SamB_XP_> roboshibby: unqualifiedly?
22:20:49 <lament> roboshibby: this is so off-topic
22:20:51 <roboshibby> has corporate pollution caused harm the planet? sure. you can't go anywhere without seeing a pop can.
22:20:51 <pikhq> It takes a void*.
22:20:57 <Jafet> Unlike in Haskell.
22:20:59 <mauke> pikhq: and you're giving it a char *
22:21:03 <lament> roboshibby: take it to #haskell-blah
22:21:04 <roboshibby> SamB_XP_: absolutely
22:21:13 <Jafet> See, there's this language called Haskell and it's very cool compared to C
22:21:18 <roboshibby> lament, no it's cool i can just stop talking about it if you guys don't allow alternative thought here
22:21:35 <mrd> we avoid offtopic discussions here
22:21:38 <lament> alternative thought is great, but there's a specific channel just for offtopic conversations among #haskell members
22:21:38 <pikhq> mauke: And C does implicit casts all the time with them.
22:21:42 <mauke> pikhq: no
22:21:42 <SamB_XP_> mrd: since when ?
22:21:47 <lament> it's called #haskell-blah
22:21:47 <mrd> always
22:21:48 <mauke> pikhq: there are no implicit casts
22:21:59 <monochrom> I need a name of a person such that the person has no character. So I can continue the line of "C has no strings" "Haskell has no 2-ary functions" "that person has no character"
22:22:02 <roboshibby> yea sorry that's what i meant by alternative thought, but i see what you mean
22:22:10 <roboshibby> definitely fair vis-a-vis offtopic
22:22:17 <SamB_XP_> mrd: we don't do a very good job, I think, because we've been having tons of them for as long as I can remember
22:22:34 <Gracenotes> monochrom: the string "" represents the name of such a person
22:22:44 <roboshibby> SamB_XP_: that rule is typically exercised when the OT conversation is incindiary
22:22:46 <monochrom> haha
22:22:53 <roboshibby> that's what i typically see anyway
22:23:24 <roboshibby> btw, lady gaga sucks
22:23:24 <SamB_XP_> sure, we are SUPPOSED to avoid excessive off-topic discussion, especially if someone has something on-topic to say ...
22:23:39 <vyom> i am getting an error trying to install template haskell.. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15297#a15297 pls help.. any clues?
22:23:56 <lament> yes, but a global warming discussion will turn into a huge flamewar and #-blah is better for that
22:23:57 <SamB_XP_> ... and of course if we wanna talk about porn thatisn't of the (.).(.) variety, we're supposed to do it in -blah ...
22:24:29 <c_wraith> vyom: template haskell can't be upgraded.
22:24:32 <SamB_XP_> hmm, if it turns into a flame war, nobody will be able to that deny global warming occurs, at last ;-P
22:24:32 <roboshibby> lament, and yet still not big enough for there to be actual global warming
22:24:38 <roboshibby> ha
22:24:43 <roboshibby> you just believe because you want to
22:24:45 <lament> roboshibby: agh stop
22:24:49 <j4cbo> what is that second dot supposed to be? D:
22:24:51 <roboshibby> wtf, i was joking man!
22:24:52 <roboshibby> damn
22:25:00 <c_wraith> vyom: what are you attempting to install that wants to upgrade TH?
22:25:30 <SamB_XP_> roboshibby: I think you underestimate the flame output of such a discussion
22:25:51 <roboshibby> SamB_XP_: no, i understand how many people are about that and issues like it
22:25:57 <SamB_XP_> it'd be like vi vs. emacs, except everyone got bored of that flamewar a couple decades back ;-P
22:26:10 <roboshibby> SamB_XP_: not ppl i know
22:26:22 <vyom> c_wraith: I am trying to install yst which has a bunch of dependencies, on of them is HStringTemplate-0.6.2
22:27:37 <c_wraith> vyom: the dependency is actually HStringTemplate >=0.6.1.
22:28:09 <c_wraith> vyom: use a --constraint arg on cabal.  cabal is unfortunately not smart enough to work that out for itself, given that it can't upgrade TH
22:28:59 <lament> SamB_XP_: global warming is largely due to emacs users
22:29:44 <dubhrosa> why the heck is glut a dependency of the haskell platform - anyone ever tried to build that thing from src - it's ridiculous!?
22:30:09 <vyom> c_wraith: hmm.. can you help me with the syntax.. i tried cabal install yst --constraint="HStringTemplate=0.6.1"
22:30:19 <vyom> doesnt work
22:30:34 <c_wraith> vyom: == in the constraint
22:30:47 <c_wraith> cabal install yst --constraint="HStringTemplate==0.6.1"
22:30:51 <roboshibby> lament, how am i supposed to respect your rule when you dont?
22:31:22 <roboshibby> lament, you had to get the last word it seems like. leaving global warming as something that exists. when anyone who can think knows that it doesn't.
22:31:35 <roboshibby> fucking hypocrite. i dont need to be around that
22:32:03 <lament> what
22:32:05 <monochrom> Good grief.
22:32:13 <Jafet> Three cheers for lament
22:32:27 <dibblego> guys, #haskell-blah, thanks
22:32:32 <monochrom> Hurrah! Hurray! HList!
22:33:03 <dubhrosa> dubhrosa goes to ask about building glut on #climate-change...
22:34:46 * mrd outputs HsCO2 thus making it ontopic
22:35:23 <mtnviewmark> vyow / c_wraith -- I had that same error yesterday when I tried to update to Criterion 0.4
22:36:23 <c_wraith> mtnviewmark: it's because packages are started to be updated for 6.12, and that's causing breakages because cabal isn't smart enough to avoid using them with 6.10
22:36:41 <mtnviewmark> aha-
22:37:29 <mtnviewmark> so cabal is trying to use a newer TH, not because Criterion 0.4 requies it... but "because it's there"
22:37:30 <mtnviewmark> ?
22:37:40 <c_wraith> basically
22:38:08 <mtnviewmark> ah - is there a cabal flag for "just statisfy this install with what I have, if possible"?
22:38:26 <c_wraith> not that I'm aware of.
22:39:06 <mtnviewmark> so, one just adds constraints manually to the command line until it gets a set that works?
22:39:19 <c_wraith> that's what I've been doing when I run into it
22:39:55 <mtnviewmark> okay- thanks -- will try that when I get off this "yak shaving" exercise and get back to that one!  :-)
22:40:24 <vyom> c_wraith / mtnviewmark: the problem was with a package called syb-with-class version 0.6.1.. I did an install with cabal install 'syb-with-class < 0.6.1' and everything worked
22:41:38 <c_wraith> vyom: Ah, yes.  That one will do it.  at least you've got it installed now, then
22:43:00 <vyom> c_wraith: yes thanks
22:45:03 <HaskellLove> i am going throught this book and there is code... you have two variables and you need to switch values without using intermediary variable. so for a=4 b=5 you have to get a=5 b=4, you cant do that in haskell of course right? you will have to use 5 variables like: a=4, b=5, c=a+b, d=c-a, e=c-b
22:45:13 <HaskellLove> without using functions
22:45:29 <Jafet> Haskell has no variables, so the question is moot.
22:45:41 <dibblego> \(a, b) -> (b, a)
22:45:56 <HaskellLove> dibblego as i said, without functions
22:46:01 <HaskellLove> Jafet yep
22:46:03 <mrd> you could use MVars if youu really wanted
22:46:20 <Jafet> So why are you asking it? Like annoying people?
22:46:20 <dibblego> HaskellLove, that doesn't make very much sense
22:46:40 <HaskellLove> Jafet no, just hearing opinions, you see, mrd gave me something new to learn
22:46:42 <ColonelJ> mutable function definitions, now THAT is scary stuff
22:46:58 <dibblego> @type uncurry (flip (,))
22:46:59 <lambdabot> forall b a. (a, b) -> (b, a)
22:47:44 <Jafet> It's a nonsense question, not sure how you get a sensical answer
22:47:51 <Jafet> There's ST, to be sure
22:48:05 <Jafet> And your switching values code is just.. wrong.
22:48:07 <HaskellLove> Jafet well it is nonsense for you, but i am one month in functional programming so take it easy :)
22:48:16 <c_wraith> I've already forgotten why someone was advocating \~(a, b) -> (b, a)
22:48:38 <monochrom> to help knot-tying code
22:48:47 <mrd> you could implement the stupid xor trick with mvars and it would behave like c vars
22:49:20 <mrd> kinda pointless
22:49:28 <HaskellLove> for example in assembler you can switch variables values without using intermediary which is cool... there was this trick i forgot...
22:49:43 <Jafet> Haskell. Has. No. Variables.
22:50:18 <dibblego> does Haskell have variables?
22:50:19 <mrd> it doesn't make sense in haskell because let-bound names aren't variables the way C has 'em
22:50:25 <HaskellLove> got it, i am back on my book. I paused Euler and now i implement stuff in haskell from "Algorithms and programming" Alexander Shen
22:50:35 <Jafet> And those of you who were disagreeing with me about "syntactic sugar" previously -- no, this is not the right time to be pedantic
22:51:11 <Jafet> These books are generally written towards imperative languages.
22:51:33 <Jafet> It's usually not a problem, as long as you understand how to write imperative logic in a functional style
22:51:42 <HaskellLove> Jafet yep, as i go i learn more because i compare and see an imperative way and then translate it to func
22:52:01 <c_wraith> oh, right.  I was going to implement convex hulls using foldl'.  I don't remember why, but it should be a fun exercise.
22:52:53 <ColonelJ> mutability is like a disease that spreads through your program
22:53:16 <c_wraith> Not always.  ST gives you a way to isolate it, for instance.
22:53:41 <ColonelJ> Yes, you can isolate it
22:53:52 <ColonelJ> But it's in the hands of the programmer
22:54:16 <ColonelJ> And what's to stop them writing bad code
22:54:46 <c_wraith> :t runST
22:54:47 <lambdabot> forall a. (forall s. ST s a) -> a
22:55:02 <c_wraith> that nested forall there actually goes a long way.
22:55:41 <ColonelJ> a long way for a shortcut
22:56:15 <Jafet> Haskell: making correct things easy, and easy things hard
22:56:27 <ColonelJ> Jafet: yes I was going to ask that
22:57:20 <ColonelJ> I seem to have made the horrible mistake of forgetting that providing an easy way to do mutability means that people will  use it
22:57:49 <c_wraith> There are cases where mutability matters.  There's no known implementation of shuffle that are better than O(n log n) with immutable data structures, but it's trivially O(n) with mutable arrays.
22:58:01 <ColonelJ> I mean, where it shouldn't be used
22:58:04 <c_wraith> *that is better
22:59:02 <DarthHaskell> When defining a function e.g func::a =>, what does the => do?
22:59:18 <ColonelJ> the only practical difference between mutable and immutable data in my language is that the mutable data is mutable, and yes I did that on purpose
22:59:33 <c_wraith> DarthHaskell: the part to the left of the => is the context.  It provides restrictions on the type of an argument
22:59:40 <c_wraith> :t show
22:59:41 <lambdabot> forall a. (Show a) => a -> String
23:00:11 <c_wraith> DarthHaskell: the context, in that case, restricts the type of the function to cases where a implements the Show typeclass
23:00:30 <c_wraith> @instances Show
23:00:30 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
23:00:41 <ColonelJ> I like All and Any
23:00:44 <c_wraith> As you can see, a lot of things implement Show :)
23:00:45 <DarthHaskell> ok, thanks
23:00:56 <Jafet> Shuffle? We use amb and kill the thread after the first branch
23:01:19 <DarthHaskell> what happens if a type doesn't derive show in your example
23:01:46 <Jafet> Then you can't... show it
23:01:53 <Jafet> > show id
23:01:54 <lambdabot>   "{()->()}"
23:01:54 <c_wraith> Show might be a bad example, because so much implements it.
23:02:03 <c_wraith> A better example would be (+)
23:02:03 <Jafet> Agh, bitten by caleskell
23:02:07 <c_wraith> :t (+)
23:02:08 <lambdabot> forall a. (Num a) => a -> a -> a
23:02:19 <c_wraith> To add two things together, they need to be instances of Num
23:02:24 <c_wraith> > "foo" + "bar"
23:02:25 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
23:02:25 <lambdabot>    arising from a use of `GH...
23:02:26 <Jafet> The same instance of Num.
23:02:40 <DarthHaskell> cool, thanks
23:02:44 <c_wraith> Jafet makes an important clarification
23:05:31 <DarthHaskell> Another question, is there a way to return an IO String and a String outside a do block?
23:05:42 <DarthHaskell> *IO String as a String
23:05:47 <monochrom> No.
23:06:02 <Jafet> Why don't you work through an introductory text
23:06:06 <mauke> DarthHaskell: you can't do it inside a do block either
23:06:11 <Jafet> @lyah
23:06:11 <lambdabot> Unknown command, try @list
23:06:15 <mauke> also, do blocks are just calls to >>=
23:06:37 <DarthHaskell> Working my way through real world Haskell
23:08:06 <c_wraith> @where lyah
23:08:06 <lambdabot> http://www.learnyouahaskell.com/
23:08:13 <DarthHaskell> mauke: a<- getline, doesn't a get a String?
23:08:26 <c_wraith> I'd recommend that as a better beginner intro than RWH
23:08:40 <mauke> DarthHaskell: yes, but only inside the rest of the do block
23:08:49 <mauke> DarthHaskell: so it sort of returns it, but only locally
23:08:57 <DarthHaskell> ok
23:09:00 <mauke> getLine >>= (\a -> ...)
23:09:52 <DarthHaskell> ok
23:14:42 <monochrom> @batsnack
23:14:43 <lambdabot> :)
23:14:48 <kmc> DarthHaskell, an "IO String" is not a string, it's a recipe for how to get a string.  You can't execute a recipe by ordinary function application.  The only recipe that gets executed is the one you name "main", or one you type into GHCi.
23:14:56 <Dashkal> I'm having an issue defining a data type: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15298#a15298
23:15:07 <Dashkal> "Entity" is a type class that three other data types belong to.
23:15:12 <kmc> So the thing to do is to call functions from your IO-recipe
23:15:17 <kmc> Thereby making them part of the recipe
23:15:22 <ColonelJ> you can write an identity function in my language with only 4 characters... not sure if that's a good thing or not.
23:15:41 <mauke> ColonelJ: what's the smallest infinite loop?
23:15:54 <ColonelJ> mauke: infinite?
23:15:59 <kmc> Dashkal, either World should be parametrized on e, or you should put "forall e" in front of W, to make it existential
23:16:07 <kmc> the two options will produce very different types
23:16:11 <kmc> think about which one you want
23:16:15 <ColonelJ> mauke: how long is time?
23:16:27 <mauke> what
23:16:38 <Dashkal> hmm.  Given that all teh functions that world with world do have the e type bound, I'm not sure if I want either (I could just make it "e" alone)
23:16:40 <ColonelJ> time the dimension
23:16:45 <monochrom> hahahahaha
23:16:57 <mauke> ColonelJ: about 2 meters
23:16:59 <kmc> (the third option, i guess, is to make "injected" a polymorphically typed field.  that one seems profoundly useless)
23:17:17 <Dashkal> Can you point me in the right direction to understand what "make it existential" means in this context?
23:17:34 <kmc> http://www.haskell.org/haskellwiki/Existential_types
23:17:37 <Dashkal> danke
23:17:49 <kmc> Dashkal, it would mean that each World is built around *some* Entity type, but the user of the World doesn't get to see which
23:18:15 <Dashkal> ahh, first line.  If I want to stay Haskell98 I need to just let it be "e".
23:18:26 <kmc> whereas the other option is to make it "data (Entity e) => World e =  ...", in which case the user does know
23:18:33 <kmc> do you want to stay Haskell98?
23:18:44 <Dashkal> I don't want to break that for little reason.
23:18:56 <kmc> how is this little? if you want existential semantics, that's a big deal
23:19:11 <Dashkal> All the functions that work on World have the (Entity e) =>.  So any use will be typesafe regardless.
23:19:23 <kmc> then you should just add it as a parameter
23:19:51 <kmc> foo :: (Entity e) => World e -> String
23:20:40 <Dashkal> I'm starting ot think I'm going in the wrong direction here.  World e would result in a world with only one variety of entity in it.  Not good.  I need any Entity.
23:21:29 <Dashkal> There are three instances of entity, but world doesn't care to distinguish between them.
23:22:38 <Dashkal> So I'm thinking my tenatious OOP mindset is getting in the way :P
23:23:15 <mauke> only three? why not make an algebraic type with three variants?
23:23:30 <Dashkal> The number of potential varieties is not fixed.
23:24:16 <monochrom> @quote monochrom premature gen
23:24:17 <lambdabot> monochrom says: premature generality is the root of OOP
23:24:24 <monochrom> There.
23:24:43 <Dashkal> And this is why I suspect I'm heading in the wrong direction
23:25:50 <monochrom> Unless you have actual concrete plans of making the varieties not fixed, make it fixed.
23:26:29 <Dashkal> I also hesitate because that's going to lead to a monster type definition.
23:26:39 <Dashkal> (Also a warning sign, I know)
23:28:18 <ColonelJ> monochrom: have any links on that?
23:28:31 <Dashkal> Ok, there's no reason why I can't just add a fourth "Custom" variety if required later, so I can fix it.
23:30:56 <monochrom> links on what?
23:32:08 <ColonelJ> premature generality being the root of all OOP
23:32:22 <ColonelJ> or whatever profound statement you were trying to make
23:34:19 <monochrom> First of all, nothing is profound.
23:34:27 <ColonelJ> I'm sort of half imagining building into my interpreter "The type inference mechanism is having trouble figuring out the types of several functions.  Would you like to be more explicit? (y/n)"
23:34:53 <Jafet> (.)(.)
23:35:05 <monochrom> Secondly, there is no link. It is not from any web page.
23:35:16 <ColonelJ> Ok then would you care to explain
23:35:28 * jmcarthur wonders if he should kill agda before it takes 100% of memory
23:35:30 <Jafet> Why does an interpreter need to do type inference?
23:35:31 <jmcarthur> dang, too late
23:36:04 <jmcarthur> oh, sorry, i actually meant to say that in #agda
23:36:43 <ColonelJ> Jafet: A good question, maybe.  However, the interpreter does need to do type inference, I do not know why.
23:37:22 <Jafet> You're making the interpreter
23:37:28 <Jafet> I suggest you think about what it does.
23:38:08 <ColonelJ> in the interpreter you are allowed to write functions which use functions that do not yet have definitions
23:38:28 <Jafet> Mutual recursion. Ho hum.
23:38:41 <ColonelJ> a later definition may cause some sort of cataclysmic meltdown
23:38:55 <ColonelJ> I don't know how or why
23:39:04 <Jafet> I suggest not developing your interpreter in a nuclear reactor controller then.
23:39:09 <kmc> Dashkal, if you want something like interface-implementation, or an variant type you can add stuff to, that'd be an existential
23:40:37 <Dashkal> kmc: *nods* I could, but I was starting to get a smell that I was trying to use an OOP style structure simply out of habit.
23:40:56 <Dashkal> As opposed to an actual need
23:42:14 <kmc> mm
23:43:11 <dibblego> is there an easier way to use the Endo Monoid without wrapping/unwrapping?
23:44:05 <ColonelJ> warping/unwarping?
23:44:43 <HaskellLove> can you recommend me a good profiling tool for Haskell please?
23:45:19 <dibblego> @type appEndo $ mconcat (Endo <$> [id, reverse])
23:45:20 <lambdabot> forall a. [a] -> [a]
23:45:48 <jmcarthur> HaskellLove: ghc has nice profiling tools built in
23:45:49 <ColonelJ> :t time
23:45:50 <lambdabot> Not in scope: `time'
23:46:24 <ColonelJ> :m +AwesomeProProfilingTool
23:46:49 <dibblego> @hoogle (Monad m) => [a -> m a] -> a -> m a
23:46:49 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
23:46:50 <lambdabot> Data.Generics.Aliases mkM :: (Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a
23:46:50 <lambdabot> Data.Data gmapM :: (Data a, Monad m) => (d -> m d) -> a -> m a
23:46:56 <Cale> HaskellLove: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
23:48:09 <Cale> HaskellLove: tl;dr: if you want time profiling, compile with -prof -auto-all and run the program with +RTS -p  at the end of the commandline
23:48:26 <ColonelJ> Is it possible to make a profilier monad that annotates everything with useful (useless) information, and allows it to be shown using Show?
23:48:50 <Cale> ?
23:49:12 <ColonelJ> I'll take that as a no
23:49:25 <Cale> I don't understand the question really.
23:50:12 <ColonelJ> i thought monads could mess about with how things are done
23:50:12 <Cale> But the GHC profiler works in such a way that the code can't even really tell that it's being run in profiling mode
23:50:28 <ColonelJ> yeah, that's probably better for profiling
23:50:39 <jmcarthur> ColonelJ: monads aren't really magic
23:50:48 <ColonelJ> jmcarthur: they really should be
23:50:55 <jmcarthur> what do you mean?
23:51:22 <dibblego> ColonelJ, it might help to learn what monad means; there are various tutorials of varying quality
23:51:52 <ColonelJ> I think the problem here is that functions actually have to know they're inside a monad when they're written
23:51:59 <jmcarthur> no they don't
23:52:32 <Cale> Under the most favourable interpretations of what that statement means, it might be kind of true :)
23:52:42 <ColonelJ> I thought you needed to have a return thing
23:52:58 <dibblego> perhaps try a high quality one :)
23:53:00 <ColonelJ> to make the next monad instance
23:53:01 <jmcarthur> return is just an overloaded function
23:53:15 <Jafet> :t return
23:53:16 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:53:17 <Cale> ColonelJ: Saying that something is a monad just means that it supports (not that it requires the use of) a particular API.
23:53:58 <kmc> ColonelJ, every use of the "do" notation is simply nicer syntax for using a combination of "return" and "(>>=)"
23:54:07 <kmc> and those are ordinary Haskell functions
23:54:13 <tensorpudding> (>>) is a useful one too
23:54:15 <Cale> ColonelJ: The advantage of recognising monads being that there's a bunch of polymorphic functions you get for free (written in terms of that interface I mentioned) once you notice that.
23:54:20 <ColonelJ> yes but this means you can't make code do things that they're not intended to do
23:54:22 <Cale> :t sequence
23:54:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:54:31 <jmcarthur> ColonelJ: that is not a negative
23:54:35 <kmc> those operators live in a typeclass, which is no more or less magical than (+)
23:54:46 <ColonelJ> jmcarthur: it is when you consider profiling
23:54:55 <jmcarthur> ColonelJ: to make code do things it's not intended to do is magic
23:55:11 <jmcarthur> oh, now i see what you meant earlier
23:55:13 <ColonelJ> ok well I'll agree to that then, profiling is magic
23:55:15 <dibblego> @type foldl (<=<)
23:55:16 <lambdabot> forall (m :: * -> *) c a. (Monad m) => (a -> m c) -> [a -> m a] -> a -> m c
23:55:17 <HaskellLove> what is equal to unit testing in imperative languages, in Haskell? type checking?
23:55:25 <Jafet> Unit testing.
23:55:25 <Cale> HaskellLove: QuickCheck
23:55:26 <dibblego> HaskellLove, see QuickCheck
23:55:31 <jmcarthur> HaskellLove: testing is testing
23:55:33 <Cale> and yeah, unit testing ;)
23:55:35 <Jafet> QuickCheck is fuzz testing
23:55:51 <Cale> Unit testing is the special case of quickcheck where you write properties that are boolean values
23:56:01 <jmcarthur> quickcheck is fuzz testing, hunit is unit testing, type checking is proving (certain things)
23:56:08 <Jafet> ColonelJ, profiling doesn't change the observable behaviour of the code (other perhaps than resource usage)
23:56:09 <ColonelJ> jmcarthur: yeah I think my wording was slightly off
23:56:15 <Jafet> You sound very confused.
23:56:52 <ColonelJ> Jafet: I was thinking of a different kind of profiling, a magic kind
23:57:07 <ColonelJ> wherein you can do profiling without any external support
23:57:35 <Jafet> That was a content-less statement
23:57:37 <ColonelJ> or defining your function to support it
23:58:08 <ColonelJ> like if you wanted to count how many times some function is called inside some function
23:58:10 <kmc> hmm? ghc's profiler doesn't require source modification
23:58:18 <ColonelJ> you could change the code to just count them
23:58:27 <ColonelJ> the non-magic way
23:58:49 <ColonelJ> then there's the magic way, the way that makes no sense, the way that is bad, the way that scares people
23:58:56 <Jafet> You scare me.
23:59:03 <Nomad010> *magic*
23:59:08 <Jafet> Aieee
23:59:14 <ColonelJ> raaaaaaarrrrrrr
23:59:22 <jmcarthur> ColonelJ: i think you are making a lot of assumptions about the way things work
23:59:54 <jmcarthur> assumptions are a major cause of the perception of magic
