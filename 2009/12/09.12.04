00:00:02 <tombee> :s
00:01:01 <roostaj> is it worth reading?
00:01:13 <ivanm> if you've already learnt Haskell, not really
00:01:17 <ivanm> which is why I only skimmed
00:01:27 <copumpkin> how does one judge whether one has learnt haskell?
00:01:47 <Baughn> copumpkin: One does not "learn haskell". Haskell is a path, not an end.
00:01:48 <roostaj> the book makes itself sound like its discrete math with haskell examples
00:01:52 <roostaj> is that true?
00:02:01 <Baughn> And I'm not even joking about that
00:02:14 <copumpkin> I wasn't really serious :)
00:03:03 <CalJohn> well, haskell is just a language, so when you get how to write simple programs, you have it.  All this other clever stuff is extra :p
00:03:17 <ivanm> copumpkin: if you can do the basics
00:03:19 <ziman> Baughn, type arithmetic to destinguish the levels of wrap-nesting? :)
00:03:22 <ivanm> roostaj: yeah
00:03:27 <Baughn> ziman: Yep
00:03:38 <ivanm> roostaj: but the actual code usage is rather poor
00:03:41 <Baughn> ziman: This'll be /fun/.
00:03:51 <Baughn> And I mean that in the most sarcastic way possible.
00:03:58 <roostaj> ivanm: any other recommended readings involving haskell then?
00:04:12 <ivanm> roostaj: math-wise?
00:04:27 * ivanm has been meaning to track down a copy of computational matroids and see what it's like
00:04:30 <manju> roostaj: you mean haskell books  ?
00:05:00 <roostaj> well i'm not terribly interested in practicality. So math or theoretical computer science is preferrable
00:05:24 <ivanm> roostaj: there was a book that came out last year on computational matroids
00:05:29 <ivanm> otherwise, read papers! ;-)
00:05:29 <sohum> why doesn't everybody accept any one graph class?
00:05:40 <copumpkin> I haven't found one I like
00:05:53 <ivanm> sohum: FGL has good ideas, but poor implementation
00:05:54 <copumpkin> I plan on making one graph module to rule them all
00:05:57 <ivanm> and there's no other graph class
00:05:58 <sohum> what's wrong with them?
00:05:59 <roostaj> ivanm: good point!
00:06:09 <ivanm> sohum: over-use of tuples (so you can't create Eq instances)
00:06:16 <ivanm> copumpkin: Cale and I started on one...
00:06:24 <copumpkin> ivanm: so I heard, but I never saw it :P
00:06:39 <ivanm> copumpkin: because I haven't been able to grab his attention to keep work on it!
00:06:49 <copumpkin> you need to shut down his analogical engine
00:06:49 * ivanm -> dinner
00:06:50 <ivanm> nom nom nom
00:06:53 <ivanm> copumpkin: heh
00:07:02 <copumpkin> stick sugar in his gasoline
00:07:24 <eevar2> nudity might do it ;)
00:08:54 <roostaj> manju: do you have any recommended haskell books?
00:09:20 <Baughn> roostaj: "Godel, Escher Bach".. no, it's not about haskell, but it actually helped me think about haskell.
00:09:26 <manju> roostaj: no, not math oriented ones like you are looking for.
00:09:58 <roostaj> manju: any that you keep handy for references?
00:09:58 <idnar> almost everything I know about math, I learned from GEB ;)
00:10:31 <manju> what is discrete math ?
00:10:46 <manju> I might've learnt it with a different name
00:11:09 <manju> ah..graph theory and suches
00:11:12 <Baughn> manju: Basically, math in the domain of Z
00:12:12 <roostaj> i'm no expert, hardly even familiar, but i think it's often described as dealing with countables
00:12:43 <toast-opt> manju - where at?  i remember it being over N natural numbers and predicate logic
00:12:43 <roostaj> manju: Godel, Escher, Bach: An Eternal Golden Braid by Douglas R. Hofstadter is what you are referring to?
00:12:53 <manju> roostaj: hall and o'donnel
00:13:37 <manju> I didn't study computer science, all my discrete math is in bits and pieces, or part of other subjects
00:13:59 <manju> I stumbled upon this other day
00:14:50 <manju> toast-opt: numerical analysis is discrete math too
00:14:50 <roostaj> manju: hall and o'donnel?
00:14:57 <manju> yes
00:15:17 <Baughn> manju: If you stretch it far enough, discrete math is simply computable math.. I know some mathematicians who"d have issues with that statement, but it's pretty close
00:15:23 <roostaj> i can't find anything on that. point me in a direction?
00:15:30 <manju> http://www.dcs.gla.ac.uk/~jtod/discrete-mathematics/
00:15:40 <roostaj> ah
00:15:43 <manju> roostaj: yeah took me a couple of tries in google too
00:16:13 <roostaj> manju: i thought you were saying godel, escher bach was written by hall and odonnel at first. then i still couldn't find hall and odonnel. thought you a nut job
00:16:29 <manju> no that was someone else
00:16:32 <roostaj> :)
00:16:39 <roostaj> oh yeah
00:16:40 <roostaj> sorry
00:16:46 <roostaj> i'm the nut job
00:17:12 <manju> Baughn: information theory is discrete math too
00:18:01 <manju> but if you study CS, I can understand the 'limited' discrete math you get to study :-)
00:20:48 * manju basks in the silence
00:21:07 <roostaj> :)
00:21:10 <roostaj> i'm looking at books!
00:21:45 <roostaj> what about books on lambda calculus. that interests me also
00:22:18 <manju> roostaj: I've no clue, I didn't study that, I would be interesting knowing that too :-)
00:22:28 <manju> s/interesting/interested
00:22:44 <roostaj> :D
00:22:56 <CalJohn> i have recently got TAPL (waiting on the postman) and from what I have read of it so far, it covers some basic lambda calc as it applies to FP
00:23:07 <manju> TAPL ?
00:23:25 <CalJohn> Types and Programming Languages by B. Pierce
00:24:01 <roostaj> manju: I think I'm going to pick up "A Haskell Road to Logic" and "Godel, Escher Bach" for the holidays. Maybe I'll have time for lambda in the summer :)
00:24:05 <manju> CalJohn: how much is it ?
00:24:23 <manju> roostaj: I wish I had that kind of time
00:24:50 <roostaj> manju: well, we'll see if i actually finish these over christmas!
00:25:33 <CalJohn> i think it cost me Â£35
00:25:51 <manju> that is not bad, even I can afford it...
00:26:02 <CalJohn> well, it is still quite expensive
00:26:04 <CalJohn> :)
00:26:08 <manju> :0
00:26:25 <manju> yeah...I want to pick up bird and waddler, it is $71
00:26:33 <manju> that is pretty steep
00:26:33 <CalJohn> yes, that really is expensive
00:26:47 <CalJohn> but it is the best book for beginners
00:26:59 <CalJohn> i am lucky as the local academic library has it
00:27:07 <manju> I live in a third world country and that is like a weeks wages :p
00:27:17 <manju> jk
00:27:29 <roostaj> :O
00:28:22 <CalJohn> there are lots of people in the first world for whom that is a weeks' wages
00:28:29 <manju> CalJohn: did you order ATAPL too
00:28:35 <manju> CalJohn: yup
00:28:45 <CalJohn> no, one at a time for me
00:28:56 <CalJohn> :)
00:29:02 <manju> heh...yeah
00:29:09 <tombee> haskell is pretty hard to learn :(
00:29:14 <roostaj> $47 on amazon for Types and Programming Languages
00:29:26 <manju> tombee: tell me about it
00:29:43 <copumpkin> tombee: but oh so satisfying
00:29:44 <manju> I am still stuck in te 3rd-4th chapter of RWH
00:30:04 <manju> I like the feeling of actually learning new things
00:30:05 <CalJohn> if you are still a beginner, then RWH is almost certainly not for you
00:30:19 <manju> CalJohn: which one would you recommend ?
00:30:36 <CalJohn> well, the Bird book :)!  Also, Hudak's book is good
00:31:04 <CalJohn> and then maybe have a look at RWH after, for the code style and ideas and so on
00:31:26 <manju> what does he mean when he says "through Multimedia"
00:32:16 <CalJohn> actually when I said Hudak I meant Hutton
00:32:27 <manju> haha
00:32:28 <CalJohn> i hear good things about Hudak, but haven't read it
00:32:32 <manju> common mistake
00:32:46 <winxordie> http://learnyouahaskell.com/ is pretty good if you want to get the basics of haskell down
00:33:07 <CalJohn> have to go, good luck :)
00:33:38 <manju> why is amazon trying to log me in to cloudfront.net
00:33:52 <manju> CalJohn: thanks
00:37:16 * manju is looking for lambda calculus course
00:37:27 <manju> like in MIT open courseware
00:37:39 <manju> anyone here know if such a course is online ?
00:39:58 <roostaj> manju: i don't know of any lambda calculus lectures. There's "Structure and Interpretation of Computer Programs" from MIT and ArsDigita (two different lecture series). However, those classes are just introductory programming classes taught using Scheme. :(
00:40:23 <MoALTz> http://www.google.com/search?q=lambda+calculus+opencourseware   ?
00:40:34 <MoALTz> the first result seems maybe relievant
00:41:28 <roostaj> oh, nice looking find
00:41:38 <manju> nice :-)
00:41:48 * manju bows down MoALTz google skillz
00:42:24 <MoALTz> for future reference, there are more colleges than MIT doing opencourseware
00:42:44 <manju> MoALTz: oh..really
00:42:52 <manju> but are they available online ?
00:42:54 <roostaj> yes
00:43:01 <MoALTz> yep
00:43:09 <roostaj> manju: check Stanford
00:45:14 <manju> itunes.stanford.edu what ?!
00:46:06 <roostaj> manju: woah, didn't see that. I just visit youtube occasionally
00:46:32 * manju grumbles, I can't run itunes on linux
00:47:28 <roostaj> :(
00:50:51 <manju> roostaj: http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-042JFall-2005/CourseHome/index.htm
00:51:37 <roostaj> manju: no videos?
00:51:39 <roostaj> :(
00:51:45 <Gracenotes> that link looks famliar to me
00:51:45 <manju> yeah :(
00:52:32 <manju> Gracenotes: did you take the course :-) ?
00:53:01 <manju> I wish they would put up videos for this course
00:53:31 <Gracenotes> the link. I've downloaded the course documents before
00:53:38 <manju> yeah
00:59:11 * hackagebot upload: HaXml 1.20 - Utilities for manipulating XML documents (MalcolmWallace)
01:01:17 <HugoDaniel> hi
01:05:47 <Baughn> Is tfp supposed to take forever and a day to compile?
01:06:02 <Baughn> It seems stuck on Types.Data.Num.Decimal.Literals.. and I'm on ghc 6.12. Anyone want to check?
01:06:10 <Baughn> ...oh. Just finished. Never mind.
01:12:17 <ilyak> @hoogle [a] -> (a -> Boolean) -> [a]
01:12:18 <lambdabot> Warning: Unknown type Boolean
01:12:18 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
01:12:18 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
01:12:35 <ivanm> Baughn: what's tfp?
01:13:09 <Baughn> ivanm: Type-level programming package
01:13:19 <dibblego> @type \x -> -x -- does this have a name?
01:13:20 <lambdabot> forall a. (Num a) => a -> a
01:13:20 <ivanm> ahhhh
01:13:28 <ivanm> dibblego: negate
01:13:30 <dibblego> @hoogle (Num a) => a -> a
01:13:31 <lambdabot> Prelude abs :: Num a => a -> a
01:13:31 <lambdabot> Prelude negate :: Num a => a -> a
01:13:31 <lambdabot> Prelude signum :: Num a => a -> a
01:13:32 <dibblego> of course ta
01:13:36 <ivanm> np
01:13:45 <Baughn> ivanm: Which apparently is more theoretical than not, given this warning..
01:13:46 <ivanm> Baughn: type-level functional programming?
01:13:50 <ivanm> heh
01:13:52 <Baughn> "Warning: Types.Data.List: Instances of type and data families are not yet supported. Instances of the following families will be filtered out:
01:14:10 <Baughn>   IsNull, Head, Tail, Reverse, Reverse', Append
01:14:30 <ilyak> It's strange that haskell has filter but not reject
01:14:54 <ivanm> ahhh, its type family programming
01:14:55 <Baughn> reject p = filter (not p)?
01:14:58 <ilyak> yeah
01:15:15 <Baughn> I'd prefer to call that 'filterOut'
01:15:40 <opqdonut> i'd not
01:15:51 <ivanm> i think filterOut makes more sense than reject
01:15:59 <ilyak> reject red colours
01:16:02 <opqdonut> how about delete?
01:16:10 <ilyak> I think it's okay
01:16:12 <opqdonut> and rename the current delete into deleteFirst
01:16:14 <ivanm> then again, when I first started with Haskell I kept thinking that the func filtered stuff _out_
01:16:25 <ivanm> since how many times in the "real world" do you filter stuff _in_?
01:16:26 <Baughn> opqdonut: Too.. imperative
01:16:27 <ilyak> delete introduces ambiguity
01:16:31 <Axman6> i can never remember what filter does
01:16:48 <ivanm> Axman6: only keep values that match the predicate
01:17:11 <Axman6> @src filter
01:17:11 <lambdabot> filter _ []     = []
01:17:11 <lambdabot> filter p (x:xs)
01:17:11 <lambdabot>     | p x       = x : filter p xs
01:17:11 <lambdabot>     | otherwise = filter p xs
01:17:14 <Axman6> bah
01:17:43 <Axman6> filter p xs = [x | x <- xs, p x] is easier to remember for me
01:17:47 <sohum> remove-if and remove-if-not, baby!
01:18:04 <ivanm> heh
01:18:38 <MoALTz> @src enumFrom
01:18:38 <lambdabot> Source not found. You untyped fool!
01:18:49 <sohum> @src enumFromTo
01:18:49 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:18:58 <sohum> :t enumFromTo
01:18:59 <lambdabot> forall a. (Enum a) => a -> a -> [a]
01:19:06 <sohum> :t enumFrom
01:19:07 <lambdabot> forall a. (Enum a) => a -> [a]
01:19:13 <MoALTz> maybe it's builtin (since it is specified in the 98 report)>
01:19:13 <MoALTz> ?
01:19:37 <sohum> Enum defines what, succ?
01:19:43 <Axman6> @src enum
01:19:43 <lambdabot> Source not found.
01:19:48 <Axman6> @src Enum
01:19:48 <lambdabot> class  Enum a   where
01:19:48 <lambdabot>     succ                     :: a -> a
01:19:48 <lambdabot>     pred                     :: a -> a
01:19:48 <lambdabot>     toEnum                   :: Int -> a
01:19:48 <lambdabot>     fromEnum                 :: a -> Int
01:19:50 <lambdabot> [3 @more lines]
01:19:52 <sohum> yea
01:19:55 <Axman6> @more
01:19:55 <lambdabot>     enumFrom                 :: a -> [a]
01:19:55 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
01:19:56 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
01:19:57 <MoALTz> i was wondering because i thought i had some issues with list comprehensions. at the time i wanted to generate from the list it was generating (primes). but nevermind.
01:20:16 <sohum> so enumFrom x = x:enumFrom (succ x)
01:20:24 <Axman6> yep
01:21:55 <ivanm> @src Int enumFromThenTo
01:21:55 <lambdabot> Source not found. You untyped fool!
01:22:00 <ivanm> @instances Enum
01:22:01 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
01:22:07 <ivanm> @src Ordering enumFromThenTo
01:22:07 <lambdabot> Source not found. Just try something else.
01:22:10 <ivanm> bah
01:25:26 <Axman6> > enumFrom ()
01:25:27 <lambdabot>   [()]
01:26:27 <sohum> > succ ()
01:26:28 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
01:26:53 <sohum> ...?
01:27:07 <sohum> > [(),()...)
01:27:09 <lambdabot>   <no location info>: parse error on input `)'
01:27:12 <sohum> > [(),()...]
01:27:13 <lambdabot>   A section must be enclosed in parentheses thus: (() ...)Not in scope: `...'
01:27:53 <Saizan> > [(),() ..]
01:27:53 <ivanm> heh
01:27:57 <ivanm> :t ((),())
01:27:59 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
01:27:59 <Saizan> @bot
01:28:00 <lunabot>  :o
01:28:03 <lambdabot> ((), ())
01:28:05 <lambdabot> :)
01:28:45 <sohum> so why doesn't succ () work?
01:29:55 <int-e> what would the result be?
01:30:14 <int-e> there is only this one value of type (), namely (). It has no predecessor nor successor.
01:30:16 <Saizan> default Enum instances are not cyclic
01:30:51 <sohum> aah
01:30:55 <sohum> hrrm
01:31:03 <ivanm> @instances Bounded
01:31:04 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
01:31:06 <Saizan> though i wonder why enumFromThen returns repeat ()
01:31:08 <ivanm> > maxBound :: ()
01:31:09 <lambdabot>   ()
01:31:17 <ivanm> > minBound :: ()
01:31:18 <lambdabot>   ()
01:31:44 <sohum> > enumFromTo 5 -1
01:31:45 <lambdabot>   No instance for (GHC.Num.Num (t -> [t]))
01:31:45 <lambdabot>    arising from the literal `1' at...
01:31:47 <sohum> > enumFromTo 5 0
01:31:48 <lambdabot>   []
01:32:20 <ivanm> > enumFromTo 5 (-1)
01:32:21 <lambdabot>   []
01:32:33 <ivanm> sohum: ^^ it was parsed as enumFromTo (5 - 1)
01:33:04 <Saizan> (enumFromTo 5) - 1, actually
01:34:22 <ivanm> oh, yeah
01:34:28 <ivanm> that makes more sense from the error
01:35:08 <sohum> yea, I realised
01:44:27 <manju> I got a call on my cell and my keyboard died :|
01:45:43 <ivanm> heh
01:45:47 <ivanm> wireless keyboard I take it?
01:46:01 <manju> no..it is wired
01:46:20 <ivanm> weird :s
10:49:26 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
10:49:26 --- topic: set by Saizan on [Wed Dec 02 21:02:12 2009]
10:49:26 --- names: list (clog JabDesign beezir_ ujihisa_ solidsnack jsgf OnionKnight _stenobot ps-auxw wagle MrFahrenheit dpratt71 novas0x2a1 hansfbaier ido Manyfold c_wraith medfly noam rrice jmillikin ulfdoz leandrom_ zax delYsid authentic roostaj hgolden ivanm augur SamB_XP_ fracture PsiOmega mauke copumpkin luqui Runar dibblego Draconx robink abbe bombshelter13b ikeg horms ttmrichter crest Cobra^^ skorpan qz Rotaerk azm mreggen cloudhead noddy Niccus Stefa1)
10:49:26 --- names: list (blackh borism conal eyl altmattr Associat0r dfdf CamJ256 Aikawa_ oubiwann_ Smokey` amz tommd jethomas gnut pa_ akappa Pthing RustKnight kpreid shapr SirNick mattp__ pikhq MoALTz m-i-l-a-1 fpz dfrey bgs100 ertai_ LeoD_ beezir O_4 sigh inimino TR2N mmorrow integral shaleny trofi ski_ viator_sg pheaver willb stoop eno__ angelixd saint_cypher_ mwc srcerer mattrepl monochrom nwf nnyby bind_return jrib philed pwerken voker57 dancor NNshag Colours)
10:49:26 --- names: list (ddarius BurgessShale pragma_ PepeSilvia jan_ danly Beelsebob DekuNut otto_s_ Garfinkle roconnor DevHC amiri orbitz agruman bolrod agemo dcoutts sudharsh Zeiris desu weebl levitation[A] LeNsTR joga nego mikm phr guerrill1 BMeph kfish sioraiocht G0SUB lefant Asztal Philonous dobblego xternal rootzlevel xinming_ manju whoppix oeblink ilyak wiseman|h hackagebot StoneToad drspider_ jonafan bobl1k Saizan ned shortcircuit caligula__ SmurfOR Tobsan)
10:49:26 --- names: list (cgibreak1 gogonkt fhs jimmyjazz14 potatishandlarn sjanssen q[mrw] thetallguy Gracenotes ray EvanR gbeshers_home Optimality gnuvince thingwath r0bby bastian Guest99398 juhp jao wio nornagon niksnut endojelly jfredett jimt tensorpudding chrisdone cognominal prb rdd` jnwhiteh gwern rgr teneighty hsaliak gbeshers jims kmc CalJohn tarbo Cyneox c9s ski newsham allbery_b drbean ben sieni Innominate Blub\0 otherdude @ChanServ Chile Badger pcc1 neurocyte)
10:49:26 --- names: list (And[y] emias ^Einstein guerby dcolish welterde smiler tavelram andun jlaire kalven jlouis aavogt Exteris zaarg davidL CalAtCentral BONUS midnite_ da-x__ ksandstr saiam opqdonut kadoban_ rey_ qwr pastah_rhymez koninkje_away koeien lambdabot skaar sbok mjrosenb sebas_ mrd mshaw BrianHV nnunley alpheccar Laney AnMaster arjanoosting tamiko tilman osfameron jasonmay cjay Gilly Twigathy absentia dqd laz0r marmolak Ferdirand uorygl birkenfeld nominolo|uni)
10:49:26 --- names: list (profmakx eikke noj kynky hellige_ nablaa_ thorkilnaur__ fnordus ath^ ath byorgey slbkbs Vulpyne Eelis epokal franksh wang rapacity anji peddie qed _Jordan_ danderson magicman|sleep liff PHO_ Annie|Home alexbobp DRMacIver Valodim Aisling clanehin companion_cube jd10 BONUS_ jbauman stroan shachaf mml` heaumer Ornedan lanaer helmut jfoutz poe kosmikus epmf _br__ tromp__ nazgjunk ggreg dumael majoh Zao wm_eddie gdsx electrogeek Bassetts ahihi)
10:49:26 --- names: list (lament dons mattam erk wormwood Liskni_si Elench m4thrick dfeuer lavish Counter-Strike mahogny Tomas shepheb thomastc tmug sunfun djinni araujo jontore nimred scree Twey kar-1 Gabbie gbacon emma reltuk djahandarie blazzy Baughn ibid fxr cizra jvogel kolmodin TML Spockz maskd |Jedai| arkx deiga jleedev dubhrosa_ dilinger Lycurgus ville daed Megant_ mornfall alexsuraci nathanic Milo- dayz mikste Raevel saccade qm13_ ac sebbe1991 jayne bran)
10:49:27 --- names: list (SimonRC Thomas2 Igloo olsner Veinor Botje Esmil bbee inclement ajhager Wraithan KitB_ bd_ eyck ingy vav CodeBlock Heffalump Axman6 nathanic_work zachk det anders^^ encryptio kw317 slc jmcarthur tkr canvon arvidj Berengal wharrgarble snhmib AndyP JaffaCake EvanCarroll nerfquark PeakerWork Whitesquall McManiaC blackdog idnar ehamberg OscarZ mm_freak erg Nafai dogmaT poucet equanimi1y joed regulate gds flux Nanar Stephan202 ziman jelly1 jrockway)
10:49:27 --- names: list (FauxFaux cathper matthew-_ hiredman Bleadof nasloc__ Vq suiside mjv ahf MacCoaster_ mfp dino- Deewiant preflex soopos dreixel kuningas samulihs StarFire sgf eek franki^ Ytinasni aluink mlh danopia zhijie felipe_ Cthulhon|| Mr_Awesome boyscared rlarson87 Raku^ M| minsc dankna eelco fritschy nlogax zygoloid alip JBGood mercury^ jml Trafalgard creaux michaelh ToRA webframp mmmulani lomeo jix gOcOOl glitch_ ibt aempirei sunnavy impl malouin)
10:49:27 --- names: list (thedward mokus mux theclaw desp nipuL tessier jaj ve burp baaba luite quicksilver xian mw493 jones- +lunabot tew88 edwtjo diginux prigaux t wolverian igorgue Optimo smg stepnem Jiten glith Boney drhodes loop Jaak sproingie jtra dionoea dmwit clarkb da-x fihi09`` Sisu bockmabe SubStack anekos dcoutts_ onodrim yahooooo thoughtpolice periodic QtPlaty[HireMe] RAndrew jvoorhis wzp koala_man elly nothingmuch kakeman Cale mfoemmel GNU\colossus)
10:49:27 --- names: list (__marius__ otulp qebab mdordal2 Lemmih p_l aiko DrSyzygy tltstc deavid benmachine trez jorendorff zsol flippo sohum ClaudiusMaximus linas jql int-e cnwdup Hunner wdonnelly MarcWeber icee andrewsw-afk karld aleator Khisanth h20xt geir pettter cods netcat)
11:00:22 * hackagebot upload: starling 0.1.1 - A memcached client (AntoineLatter)
11:01:16 <Optimality> has anybody been able to get vty to play nicely with ghci?  when I stop on breakpoints/exceptions/etc., any input kicks me out of ghci
11:26:46 <mxyz> my first time on #haskell
11:27:46 <DaveS> bring the paddler
11:27:57 <DaveS> (The one with the lamda)
11:28:02 <ivanm> mxyz: did you bring any cake?
11:28:03 <ivanm> ;-)
11:28:46 <mxyz> gah, you never show up to a party empty handed
11:29:16 <mxyz> this has been my 1st serious week using haskell and its been kinda shitty, lol
11:30:16 <mxyz> love the language but its been hard getting some libraries to work on xp
11:31:55 <Gracenotes> I wonder, why is my program not seeing that there two things are the same :|
11:32:48 <gwern> mxyz: most haskellers don't seem to use windows
11:32:51 <Gracenotes> it might just be me, but it seems that the quickest way to debug graphics applications is to add more graphics. (and the right debuggy kind)
11:32:57 <gwern> very easy to make a unix assumption
11:33:08 <gwern> or simply not kowtow to whatever horrid way windows has
11:33:24 <gwern> (windows proves that the right thing can be the wrong thing)
11:34:55 <mxyz> @gwern, i dual boot with ubuntu and insist on platform independent libraries.
11:34:56 <lambdabot> Unknown command, try @list
11:35:16 <FinanceInstructo> someone plese extend your help to me, my business is going under...
11:35:20 <Gracenotes> showWindowsDialogBox("Continue?", __myicon, NULL, NULL, NULL, NULL, NULL, NULL, 2, NULL, NULL, NULL, NULL, NULL)
11:35:23 <gwern> mxyz: not twitter
11:35:23 <mxyz> cant get portaudio or gtk2hs running though. spent the day emailing haskell-cafe about it
11:35:35 * gwern noticed
11:35:39 <DaveS> Finance: ?
11:35:45 <gwern> (thank goodness for gmail's muting)
11:35:57 <ivanm> gwern: gmail supports muting?
11:36:12 <ivanm> FinanceInstructo: please see #give-me-lots-of-money-please
11:36:16 <gwern> ivanm: what do you think 'm' does?
11:36:25 <ivanm> gwern: enter's the letter `m' ;-)
11:36:33 * ivanm doesn't really use gmail's web interface much
11:36:36 <gwern> spoken like a true emacser
11:36:38 <ivanm> gwern: so what does "muting" mean?
11:36:57 <gwern> ivanm: it means that any future emails in a 'conversation' don't appear in the inbox
11:37:27 <gwern> ivanm: but it's also a label, so I have filter which marks anything muted as 'read', since I prefer to live inside a 'label:unread' search
11:37:49 <mxyz> "not twitter"?
11:38:27 <gwern> your silly little @gwern thing
11:38:53 <mxyz> ouch. my first few minutes on irc > my time ever on twitter. noted. sorry
11:41:58 --- mode: ChanServ set +o shapr
11:42:03 --- kick: FinanceInstructo was kicked by shapr (shapr)
11:42:14 --- mode: shapr set -o shapr
11:42:58 <shapr> I guess I can't claim that this is my first time on IRC now?
11:43:17 <Niccus> I bet it's not even your second time.
11:46:30 <jmillikin> For string manipulation, what is the expected slowdown moving from C to Haskell? I'm trying to port a library I've written, and functions which used to take 0.05s now take over 2 seconds.
11:47:25 <jmillikin> Even pared down to just generating strings (or Data.Text, makes no significant difference), I can't figure out how to make Haskell anywhere near as performant and I wonder if this is just a weak area.
11:49:56 <Optimality> so, I need to recursively reinstall a bunch of libraries with profiling symbols on - does cabal let you reinstall libraries recursively? as in, I need to reinstall derive - which fails, b/c haskell-src-exts isn't installed with profiling symbols, etc.
11:50:13 <Optimality> is there a faster way than reinstalling each library individually?
11:52:14 <Optimality> > fix error
11:52:15 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
11:56:59 <Lemmih> jmillikin: Paste the code?
12:01:23 <Lemmih> jmillikin: If String is as slow as Text then you're probably doing something wrong.
12:02:44 <jmillikin> Do you mean "if Text is as slow as String", or is Text known for poor performance?
12:03:43 <lispy|web> I'm not sure if Text has much of a reputation yet, but it's based on the same principles of performance as ByteString
12:04:41 <Lemmih> jmillikin: Text should be a lot faster. If your program says otherwise then you're likely doing something wrong.
12:04:54 <jmillikin> Well, in this case, Text is actually *slower* than just String
12:05:06 <jmillikin> working on posting the code / benchmark
12:05:24 <lispy|web> Yeah, you might be using it incorrectly
12:05:39 <jmillikin> hpaste is freezing firefox, so I've posted it here: http://pastebin.ca/1702702
12:05:40 <lispy|web> That can be easy to do if you're not familiar with the underlying implementation trade-offs
12:06:45 <jmillikin> Even with that minimal example, with no error handling or state, the C implementation (<http://pypi.python.org/pypi/jsonlib-python3>) is much faster.
12:06:55 <Lemmih> lispy|web: The documentation shows the complexity of each function. No need to know the implementation.
12:07:37 <jmillikin> ie in the time it takes for the Haskell version to serialiese the array, the C version can parse *and* serialise twice.
12:09:06 <Lemmih> jmillikin: You're using 'evaluate' incorrectly.
12:09:21 <jmillikin> moving events to the "let" makes it slower.
12:10:34 <SamB_XP_> Lemmih: but does it show the constant factors ?
12:11:03 <lispy|web> Lemmih: there is more to performance than asymptotic comlexity :)
12:11:59 <Lemmih> We aren't talking about DiffArrays here.
12:12:08 <SamB_XP_> even so ...
12:13:53 <jmillikin> Also, are there any good examples of Haskell libraries implemented in C? With proper laziness and error handling a plus.
12:16:04 <lispy|web> jmillikin: What do you mean, haskell libraries implemented in C?
12:16:13 <lispy|web> jmi
12:16:15 <lispy|web> oops
12:16:28 <Lemmih> jmillikin: Many Haskell libraries call C functions.
12:16:30 <jmillikin> lispy|web: in Python, it's common to have libraries implemented primarily in C, with a small Python wrapper around it to provide a nicer interface.
12:16:57 <jmillikin> For example, that's how I wrote jsonlib. I'm porting jsonlib to Haskell, and wonder if there's a good example to follow.
12:17:51 <ivanm> gwern: oh, I have all -cafe going into a seperate folder anyway and skipping the inbox
12:17:52 <jmillikin> The only example I've found so far, aside from bindings, is <http://hackage.haskell.org/package/judy> -- but it's all in IO
12:18:11 <jmcarthur> jmillikin: that's a binding too
12:18:18 <Lemmih> jmillikin: Not calling 'show' on 'chunks' cuts the runtime in half on my box.
12:18:19 <jmillikin> ah
12:18:26 <jmcarthur> in fact, that's mostly what a library "in C" is going to be
12:18:52 <jmcarthur> you can write functions in C and use the FFI to call them for whatever, but really haskell is fast enough that you don't have to do that most of the time
12:19:27 <jmillikin> Lemmih: that's as close as I can approximate the Python benchmark I'm comparing it to.
12:19:44 <jmillikin> jmcarthur: well, then a library written as combined Haskell/C then. I just want to find out how to write such a thing without it being limited to strict evaluation and wrapped in IO.
12:19:45 <jmcarthur> you can get surprisingly low level (and ugly) with haskell
12:20:00 <jmillikin> That's true, but being low-level is much more elegant in C
12:20:03 <jmcarthur> well, the C portions will pretty much always be strict afaik
12:20:09 <SamB_XP_> jmillikin: I dunno
12:20:13 <Lemmih> jmillikin: Why do you want to use 'show' on a String?
12:20:23 <jmcarthur> i disagree. low level haskell code still seems nicer to me than C
12:20:32 <jmillikin> Lemmih: that's left-over from a more complex example, where the result is a [String] being concat'd
12:20:33 <jmcarthur> there are distinct advantages to using C of course
12:20:41 <jmcarthur> like libraries being designed natively for it
12:20:54 <Lemmih> > show "This gives you unnecessary escaping."
12:20:55 <lambdabot>   "\"This gives you unnecessary escaping.\""
12:20:57 <lispy|web> jmillikin: haskellers are only likely to have part of the implementation be in C if there is an existing good C library.
12:21:09 <jmillikin> I've pared it down as far as I could reasonably get -- I can post the original if you'd like, it's much much slower
12:21:27 <SamB_XP_> lispy|web: what about ByteString ?
12:23:35 <dancor> i find it much easier to debug low-level c
12:23:41 <dancor> and profile
12:23:53 <SamB_XP_> dancor: I have to give you the easier-to-debug
12:24:43 <dancor> but i'm very impressed with some low-level haskell i've seen.  the thing is, the ppl making it are just really effing smart
12:25:14 <SamB_XP_> maybe Haskell helps them to think more clearly ?
12:25:30 <jmcarthur> i can agree with you, dancor
12:26:01 <SamB_XP_> but you won't?
12:26:14 <jmcarthur> *sigh*
12:30:12 <dancor> ha
12:30:49 <pastah_rhymez> @faq does haskell make them think more clearly?
12:30:49 <lambdabot> The answer is: Yes! Haskell can do that.
12:31:04 <dancor> can, but won't?
12:31:35 <SamB_XP_> dancor: lol
12:32:14 <mmorrow> imo numerical is almost always prettier (well, faster too, but duh) in C
12:32:18 <mmorrow> *numerical code
12:33:12 <mmorrow> := (for the most part) arrays that represent either vectors or matrices, and you're computing linear transformations
12:33:48 <SamB_XP_> mmorrow: why not Cython?
12:34:07 <mmorrow> a[i+w*j] = b[F(i,j)] * b[F(i,k)] + b[F(j,k]; /*etc*/
12:34:14 <mmorrow> SamB_XP_: :o
12:35:16 <dancor> 20 ppl is too many for the haskell2010 committee
12:35:23 <SamB_XP_> indeed
12:35:38 <SamB_XP_> we should put them on an island and make them vote themselves off
12:35:58 <BMeph> Does anyone definitvely know, is the LLVM package on Hackage the one that augustss uses in his blog? Or is it just "inspired by" his efforts? :)
12:36:35 <sjanssen> BMeph: check the author and maintainer fields, I think that's a pretty good indicator
12:37:01 <pastah_rhymez> why isn't there any IFDEFs in haskell? what's the design idea here?
12:37:11 <pastah_rhymez> *aren't*
12:37:41 <sjanssen> pastah_rhymez: you can use the C preprocessor in Haskell source, many packages do it
12:37:50 <jmillikin> You mean like the CPP #ifdef ? Install cpphs
12:37:59 <dancor> ha the committee has "in equal weight" 6 categories of haskell users represented, but 5/6 are pretty similarly non-commercial-uses
12:38:11 <jmillikin> I recommend you not use the C preprocessor directly, since it can't handle Haskell symbols properly.
12:38:13 <pastah_rhymez> sjanssen: yeah, i know, but why doesn't the language itself support it?
12:38:27 <SamB_XP_> pastah_rhymez: why bother ?
12:38:36 <jmillikin> Why would it? C doesn't support it directly either.
12:38:55 <mmorrow> for(ii=0; ii<32; ii+=B) for(jj=0; jj<32; jj+=B) for(kk=0; kk<32; kk+=B) for(i=ii; i<ii+B; i++) for(j=jj; j<jj+B; j++) for(k=kk; k<kk+B; k++) Z[i][j] += X[i][k] * Y[k][j]; /*32x32 matrix multiplication with blocking*/
12:38:57 <pastah_rhymez> oh, ok
12:39:01 <mmorrow> sorry, i couldn't resist :)
12:39:06 <SamB_XP_> the wheel already mostly works ...
12:39:10 <dancor> i guess that's better than normal/more-popular opensource projects where everyone is corporate and disagrees strategically
12:39:25 <SamB_XP_> mmorrow: needs moar spacez
12:39:37 <mmorrow> SamB_XP_: MOAR!
12:39:38 <sjanssen> pastah_rhymez: inertia, I think.  Nobody has bothered with a Haskell-based solution because CPP is "good enough"
12:39:41 <pastah_rhymez> deavid: hehe
12:40:21 <sjanssen> I wonder what Haskell's ifdef would look like if it existed?
12:40:59 <SamB_XP_> I hear google intentionally doesn't hire all the smartest people because they know they'd do less good if they were all at google ...
12:41:20 <pastah_rhymez> sjanssen: --## IFDEF VAR; <code> --## ENDIF
12:41:44 <pastah_rhymez> SamB_XP_: i read about that
12:41:47 <SamB_XP_> pastah_rhymez: and I guess that's why we just use the CPP one
12:41:50 <pastah_rhymez> but it's not that reason
12:41:51 <jmillikin> Lemmih: If you're interested, I've pasted a more complete version (adds error handling and state) at: http://pastebin.ca/1702726
12:42:04 <mmorrow> BMeph: i'm pretty sure it's the same one, but maybe the one he's using in his blog has extra super secret featurez.. he hasn't been around lately, i think he's working on some language implem for hire and he's using it
12:42:15 <pastah_rhymez> they need these people outside google in order to keep the good mentality in more places than just google
12:42:28 <jmillikin> Using Text instead of String just makes it slower (I believe because of a recently-fixed bug in Text.concat)
12:42:50 <SamB_XP_> pastah_rhymez: and they also seem to desire some healthy contention and so forth
12:43:00 <jmillikin> For reference, that Haskell version is 9 seconds compared to the C's 0.7 seconds
12:43:51 <pastah_rhymez> jmillikin: yeah, well, it's hard to write slow c code
12:44:02 <pastah_rhymez> go haskell!
12:44:05 <mmorrow> jmillikin: the concat bug is only fixed in the sense that doing a single concat is fixed, every time you append you create a whole new Text, and copy both of the source Texts into it
12:44:05 <jmillikin> But I want to write fast Haskell :(
12:44:26 <pastah_rhymez> @faq can you easily write slow code in haskell?
12:44:27 <lambdabot> The answer is: Yes! Haskell can do that.
12:44:36 <mmorrow> jmillikin: so unless you're only doing a *single* concat only *once*, you'll get take a hit
12:44:39 <jmillikin> I mean, right now, the Haskell version is slower than even my *Python* implementation, which is just silly
12:44:49 <jmillikin> mmorrow: The benchmark only does one concat
12:44:58 <mmorrow> jmillikin: oh? which one?
12:45:11 <jmillikin> The one I posted a few lines up. http://pastebin.ca/1702726
12:45:21 <jmillikin> well, actually, that one doesn't concat at all
12:45:23 <mmorrow> jmillikin: (if it's still slow, then maybe ghc's ByteArray#'s are at fault??)
12:45:36 <jmillikin> I've written so many damned versions of this benchmark / module that I've lost track of which ones do what.
12:45:37 <mmorrow> jmillikin: yeah, i didn't see an import ...Text in there
12:45:40 <sjanssen> jmillikin: "concat stateChunks ++ afterChunks" looks slow
12:45:47 <jmillikin> mmorrow: different version, text makes it slower
12:45:53 <Niccus> @src concat
12:45:53 <pastah_rhymez> jmillikin: first rule of fast code:
12:45:54 <lambdabot> concat = foldr (++) []
12:45:58 <mmorrow> jmillikin: right, i'm interested in seeing the Text one
12:45:59 <pastah_rhymez> "To go faster, do less"
12:46:04 <jmillikin> OK, one sec
12:46:19 <pastah_rhymez> :)
12:46:30 <mmorrow> jmillikin: (the String one would be wayyy slower than the Text one, unless there's a bug in Text (i think..))
12:47:27 <mxyz> anyone use Leksah?
12:47:56 <Lemmih> mmorrow: Text is expected to be slower for this particular use case.
12:48:20 <mmorrow> Lemmih: ah, is it a bunch of little Strings or something?
12:48:33 <jmillikin> Right
12:48:42 <Lemmih> mmorrow: Yeah, and they're even consumed lazily.
12:48:45 <pastah_rhymez> jmillikin: i don't know what you're making, but maybe this would be faster? http://hackage.haskell.org/packages/archive/dlist/0.5/doc/html/Data-DList.html
12:48:52 <jmillikin> They're all very small in this benchmark, 50MB at 4-5 bytes each
12:49:05 <mmorrow> oh
12:49:09 <jmillikin> In the Python impl, I just buffer them up in an array
12:49:21 <mmorrow> jmillikin: maybe you really do want String here, as Lemmih says
12:49:22 <jmillikin> Well, C impl, but you know what I mean
12:49:25 <BMeph> @tell augustss nterestted in aversion of djinn that uses haskeline? Funny, so am I... ;)
12:49:26 <lambdabot> Consider it noted.
12:49:29 <pastah_rhymez> jmillikin: you could put a diffArray in your state :)
12:50:02 <pastah_rhymez> jmillikin: that will be fast as long as you only use the 'latest' version of it (don't go back to old references to it)
12:50:38 * jmcarthur is unimpressed with DiffArrays
12:50:53 <Lemmih> Using arrays will just give you more rope to hang yourself with.
12:50:57 <pastah_rhymez> jmillikin: diffarray == unsafePerformIO + O(1) arrays + changeset
12:51:06 <sproingie> jmcarthur: apparently so are the ghc maintainers because they're gone from 6.12
12:51:20 <jmcarthur> sproingie: i suspected that might happen
12:51:29 <sjanssen> sproingie: whaaat?  Really?
12:51:34 <sproingie> apparently they performed really badly
12:51:35 <pastah_rhymez> jmcarthur: they're good in theory?
12:51:38 <SamB_XP_> it's about time
12:51:43 <sproingie> sjanssen: yep they were unbundled and taken out of arrays
12:52:00 <sproingie> just found that out today while i was trying out various arrays
12:52:01 <SamB_XP_> pastah_rhymez: only in very impractical theories
12:52:15 <SamB_XP_> they do too much synchronization, it seems
12:52:42 <pastah_rhymez> no O(1) writing must be the cost of being cool :/
12:53:17 <sjanssen> I wonder if STM could make them faster?
12:53:31 <jmillikin> Is there any documentation on using the FFI's C API? I found reference to it at <http://blog.well-typed.com/2009/05/buildings-plugins-as-haskell-shared-libs/> but haven't found a manual anywhere.
12:53:32 <SamB_XP_> I really don't think so, sjanssen ;-P
12:53:32 <sproingie> hm, i have a simple SDL app that does events in a separate thread (forkIO that is).  trying to figure out how to implement a pause feature?
12:54:05 <pastah_rhymez> sproingie: use a Chan
12:54:08 <pastah_rhymez> @hoogle Chan
12:54:08 <lambdabot> module Control.Concurrent.Chan
12:54:08 <lambdabot> Control.Concurrent.Chan data Chan a
12:54:08 <lambdabot> Control.Concurrent.Chan dupChan :: Chan a -> IO (Chan a)
12:54:25 <pastah_rhymez> sproingie: or maybe some event thingy
12:55:06 <sproingie> in other languages i could use a condition variable.  not sure how i'd do the same
12:55:37 <sjanssen> SamB_XP_: STM is supposedly faster in cases with little contention, it would at least be interesting to try
12:56:06 <SamB_XP_> sjanssen: hmm, true ...
12:56:49 <Lemmih> sjanssen: STM is faster than an MVar?
12:57:08 <sjanssen> Lemmih: maybe I'm misremembering
12:57:29 <sproingie> how would i do it with a chan?  send a pause signal through the channel, have the main thread poll it, then read the signal and do a blocking read for an unpause signal?
12:57:40 <sproingie> or am i missing something more obvious?
12:58:00 <SamB_XP_> Lemmih: well, if you're doing more than one update, why not ?
12:58:11 <jmillikin> How would you implement it in C? I assume a global "pause" variable, right?
12:58:46 <SamB_XP_> jmillikin: or a different branch of your mainloop!
12:58:46 <jmillikin> Simple version, define "MVar Bool", set it to pause/unpause.
12:58:47 <sproingie> jmillikin: probably, yeah
12:58:53 <Lemmih> SamB_XP_: Why should the STM lock be faster than an MVar?
12:58:57 <sproingie> i mean i would probably eventually do something more elegant but this is a little app
12:59:08 <jmillikin> More complicated, use "data Event = ...; Chan Event" and use it to pass events to your main loop.
12:59:16 <SamB_XP_> Lemmih: well, with a DiffArray you have a whole slew of MVars, remember
12:59:48 <sproingie> huh maybe i should drive the main loop through the chan anyway, then i can make it run at a fixed framerate
12:59:55 <sjanssen> jmillikin: your use of mapM in this code seems problematic
13:00:07 <Lemmih> SamB_XP_: Only when accessing old versions, no?
13:00:14 <sproingie> i.e. a "render next frame" event as opposed to the main loop rendering as fast as possible
13:00:34 <sproingie> then i can just tell it to stop rendering frames
13:00:48 <Lemmih> jmillikin: The error handling is killing the performance.
13:00:50 <jmillikin> sjanssen: Is there a better way? Each step is stateful, so I figured using a State with mapM would be the best solution.
13:01:02 <sproingie> eh i'll use the MVar for now
13:10:02 <sjanssen> jmillikin: is "[Either WriteError String]" actually what you need as output, or would "Either WriteError [String]" be sufficient?
13:10:14 <sjanssen> ie. if there is an error, do you want the rest of the results at all?
13:10:24 <jmillikin> sjanssen: it needs to be lazy; see my thread in -cafe
13:10:48 <jmillikin> of course, using a custom list type makes things even *slower*, so I'm using a standard list with incorrect semantics for now.
13:13:25 <Lemmih> jmillikin: Without the error handling it takes 0.9s on my box.
13:13:51 <jmillikin> Well, yes. But if you take away the processing it can be even faster :P
13:14:40 <Lemmih> jmillikin: Just letting you know that it's not the strings that kill the performance, it's the ad-hoc error handling.
13:15:04 * pastah_rhymez got a brilliant idea but don't have the time to execute it :(
13:15:14 <pastah_rhymez> Hackety Hack, but for haskell
13:15:29 <jmillikin> Lemmih: the first version did not have error handling, and was still 3x slower than fully-implemented C.
13:15:41 <Lemmih> jmillikin: Why are you doing error checking and serialization in the same go, btw?
13:15:45 <jfredett> pastah_rhymez: Hackety Hask?
13:15:53 <pastah_rhymez> jfredett: yeah :)
13:15:55 <jmillikin> I know what you're saying, but I'd like to preserve both 1) laziness 2) performance when porting the library
13:16:08 <Lemmih> jmillikin: 3x slower than C is pretty good. You may not be able to get more than that.
13:16:08 <pastah_rhymez> jfredett: wouldn't it be awesome?
13:16:20 <jmillikin> Lemmih: ah, I see :(
13:16:26 <Niccus> wikipedia still links to the deadened hackety hack website :(
13:16:35 <jfredett> pastah_rhymez: indeed, some simple IDEish tutorial-like application would be lovely
13:16:46 <pastah_rhymez> Niccus: also, archive.org don't know about hacketyhack.net
13:16:48 <Lemmih> jmillikin: Separating error handling and serialization doesn't affect lazily or performance.
13:16:49 <jfredett> either an HH thing or a Dr. Haskell
13:16:55 <Niccus> what a shame
13:16:58 <Lemmih> *laziness
13:17:07 <jfredett> did anyone ever determine what happened to _why?
13:17:33 <jmillikin> Lemmih: I was trying to put together a minimal example which worked; elegance is for later, once it's working
13:17:34 <pastah_rhymez> jfredett: he was quite the anonymous dude and liked it like that, then some asshole outed him
13:17:59 <pastah_rhymez> someone poked through some email header or something in a mayl that he had sent from his job or something
13:18:03 <pastah_rhymez> *mail*
13:18:04 <Lemmih> jmillikin: It's the lack of elegance that kills the performance (:
13:18:23 <jfredett> pastah_rhymez: douchenuggets... I liked _why, he was a cool guy and didn't afraid of anything.
13:18:24 <Lemmih> jmillikin: Messing around with the State monad, concat and (++) is very expensive.
13:18:39 <jmillikin> Lemmih: So extracting error handling to a separate function would improve performance?
13:18:47 <jfredett> Ruby people are all alot like that, methinks, reminds me of Perl people and Haskell people...
13:18:58 <jmillikin> I'm a bit discouraged that 3x slower than C is the best that can be expected.
13:19:14 <pastah_rhymez> http://vimeo.com/5047563
13:19:17 <Lemmih> jmillikin: Yes, most likely. That is, doing the error handling right would help performance.
13:19:37 <pastah_rhymez> i like his sound/play interface; keeping everything string based
13:20:00 <pastah_rhymez> but also the gui tool that generates actual code for making a sound
13:20:05 <jmillikin> Lemmih: If you replace all the error handling with calls to "error", removing the Either stuff, does it match the no-error handling version?
13:20:26 <james_britt> jfredett: :)
13:20:31 <jmillikin> I suspect that even with no/minimal error handling, having to pass around the state will kill performance anyway.
13:20:57 <Lemmih> jmillikin: The code you posted spends 58% of the runtime in GC. Without the error handling, it goes down to 1.4%.
13:21:02 <jfredett> james_britt: ?
13:21:06 <jmillikin> So, not much difference
13:21:11 <jmillikin> oh, wait, misread
13:21:16 <james_britt> Comment on Ruby people
13:21:35 <james_britt> ... being one and all
13:21:39 <sjanssen> jmillikin: you never return lists with more than one item from writeEvent, why use a list at all?
13:21:41 <Lemmih> jmillikin: The state should be removed no matter what. It's a drag and not needed at all.
13:21:57 <jfredett> james_britt: I'm a big fan of ruby, don't get much chance to use it, but it's a nice language
13:22:08 <jmillikin> sjanssen: leftover from the String atom, which is chunked
13:22:24 <jfredett> it's like perl with a better object system. (and by better I mean less confusing).
13:22:32 <jmillikin> Lemmih: How would the current state of the serializer be preserved, then? Something like unfoldr?
13:22:47 <james_britt> jfredett: Much less confusing.  I was a big Perl user before I came across Ruby
13:23:01 <jmillikin> It needs to know when to place commas, whether an event is allowed, and the current nesting depth
13:23:11 <jfredett> james_britt: ibid, but I went to Haskell and Lisp first. (well, Perl -> CL -> Scheme -> Haskell)
13:23:24 <james_britt> jfredett: Ah, very different path
13:24:10 <jfredett> james_britt: I dunno, _why is just delightfully silly and it's unfortunate he isn't participating in the wider community anymore, he seems like a good guy.
13:24:11 <sjanssen> jmillikin: merely removing the list and concat shaves several seconds off here
13:24:51 <james_britt> jfredett: I'd like to think he's still out and about, but with a new persona
13:24:52 <Lemmih> jmillikin: I'd use an intermediate data structure.
13:25:23 <jmillikin> Lemmih: Sort of a DOM tree? Issue with that is that it's no longer lazy.
13:25:52 <Lemmih> jmillikin: Why wouldn't it be?
13:26:21 <jfredett> james_britt: probably, he's like a ninja. but I (for one) would be willing to continue not knowing (or if I did know, pretend not to) his identity, so that he could still associate with his projects...
13:26:24 <Lemmih> jmillikin: A tree can be as lazy as a list.
13:27:09 <jmillikin> Lemmih: when I'm building the tree, the function would need a signature like: readText :: String -> Either ReadError Tree
13:27:16 <pastah_rhymez> james_britt, jfredett: do you think that hackety hask is a doable project? or i haskell too nasty with its side effect-freeness for it to be viable endavour?
13:27:30 <jmillikin> alternatively, buildTree :: [Event] -> Either ReadError Tree
13:27:43 <Cale> http://cale.yi.org/share/Screenshot-Loopy-1.png -- I love it when the puzzle finishes on a topological property like this :)  (It must form a single connected loop)
13:28:00 <jfredett> pastah_rhymez: anything is doable, but it would obviously have to be different in a fundamental way
13:28:02 <james_britt> pastah_rhymez: I don't know nearly enough about haskell to guess
13:28:26 <james_britt> pastah_rhymez: However, it may be easier to sandboxk Haskell code than C code
13:28:40 <jfredett> pastah_rhymez: certainly a environment could be built which grants some visual components to the "weird" parts of haskell (eg, the unintuitive parts)
13:28:42 <pastah_rhymez> yeah, ghci is a great help :)
13:29:07 <jfredett> what those visualizations would be is an open problem.
13:29:08 <Lemmih> jmillikin: Not necessarily. That would be just like 'Either ReadError [String]'.
13:29:33 <jfredett> however, I think the best learning tool would be an incremental interpreter (my word, I think, I don't know the proper term) a la Dr. Scheme
13:29:37 <Cale> jfredett: I think we just really need a stepwise lazy evaluator for Haskell.
13:29:44 <jmillikin> Lemmih: Doesn't that require the entire input to be processed before it can be evaluated?
13:29:52 <Lemmih> jmillikin: data Tree = Array (Either Error [Atom])
13:29:55 <jmillikin> Otherwise, it won't know whether the value is a Left or Right
13:29:56 <jfredett> Cale: right, something like mzScheme's interpreter, etc.
13:29:59 <pastah_rhymez> jfredett: never used; what's the idea?
13:30:18 <jfredett> I don't even think it would be that hard to stitch the functionality in on top of ghci... but I am not schooled in these matters.
13:30:28 <jfredett> pastah_rhymez: basically, if you load a file w/ errors into ghci
13:30:32 <Cale> jfredett: You can represent sharing using let
13:30:34 <jfredett> then none of the file loads.
13:30:36 <Lemmih> jmillikin: Right, which is why you used '[Either .. ..]'. What you did with the list can be done for the tree.
13:30:44 <jfredett> an incremental interpreter
13:30:49 <Cale> jfredett: So it's totally possible to do graph reduction as a syntactic thing :)
13:30:59 <jfredett> would load everything that isn't "corrupted" by the none-working parts
13:31:18 <pastah_rhymez> jfredett: oh, cool
13:31:20 <jfredett> so if foo calls bar and bar calls baz, and foo is broken, bar and baz still get loaded
13:31:36 <pastah_rhymez> so it'd exclude, recursively, borked functions and declarations
13:31:39 <jfredett> this means that I could easily experiment my way through the type error, as I do in scheme.
13:31:44 <jfredett> pastah_rhymez: basically
13:32:07 <pastah_rhymez> hmm... why doesn't ghci have this? it seems awesome!
13:32:45 <jfredett> Cale: right, I pondered how I might do it using Hint at one point, and even have a project idea that involves that plus some other stuff (it's kind of an IDE that isn't... the idea is still a little to fluttery to explain well...)
13:32:56 <jfredett> it doesn't seem particuarly difficult, in any case...
13:32:56 <Lemmih> jmillikin: Err, a few extra data structures are needed.
13:33:05 <jfredett> pastah_rhymez: write a patch.
13:33:06 <jfredett> :)
13:33:52 <jfredett> I would, but I have enough on my plate trying to get the new HWN tools squared off. I have to start work on the output soon, but finals:/
13:34:05 <pastah_rhymez> hehe
13:34:15 * jfredett crawls back to work, damn school getting in the way of productivity...
13:36:01 <Lemmih> jmillikin: This would all be much easier if you didn't mind catching error in the IO monad, of course.
13:36:27 <jmillikin> Lemmih: I'm hoping to avoid that, since if IO gets involved, I might as well just write it in C anyway.
13:36:41 <Cale> jfredett: I would split the window into a few panes to show the executor, the evaluator, the heap (which consists of let bindings), and the stack (which consists of case expressions)
13:36:56 <jmillikin> Maybe I'm just being silly, but I enjoy knowing how code will behave regarding error conditions.
13:37:02 <Cale> and of course, the terminal for I/O :)
13:38:08 <jmillikin> This might be a scary road to go down, but...are there any tutorials on using unsafeInterleaveIO for lazy evaluation of data sourced from the FFI?
13:38:09 <Lemmih> jmillikin: The IO wouldn't be involved with the parsing or serialization. It would be isolated just like 'putStrLn'.
13:38:39 <jmillikin> Lemmih: But to handle an error, I'd need to use unsafePerformIO and catch.
13:39:47 <Lemmih> jmillikin: Do you need to catch errors in the pure code?
13:39:54 <jmillikin> Lemmih: I'd prefer to.
13:39:56 <reltuk> is there no way to tell hlint not to warn on a particular line of a file or something?
13:40:09 <reltuk> I guess its parser is throwing away comments...
13:40:13 <Lemmih> jmillikin: Why? And if so, why do you want laziness?
13:40:20 <reltuk> so you have to do it with the HLint.hs file or whatever =/
13:40:36 <jmillikin> Lemmih: I don't like having to handle errors in IO, since usually the error handling is fixed and deterministic.
13:40:42 <jfredett> Cale: yeh, I had an idea for a kind of "Trampoline" IDE which followed that notion. The idea is to simply "default" to this space which presents an interpreter and hlint output and other useful stuff, and then you "bounce back" into the editing world.
13:40:52 <jmillikin> The laziness is to allow processing of large structures without running out of memory.
13:41:36 <jfredett> part of that was a incremental interpreter (eventually turning into a full step-evaluator).
13:42:19 <akappa> jfredett, this sounds like the eclipse's concept of perspective
13:42:34 <jfredett> akappa: except this wouldn't suck, that's part of the design document.
13:42:35 <jfredett> :)
13:42:47 <akappa> jfredett, I like eclipse :P
13:43:19 <ivanm> :o
13:43:25 <Lemmih> jmillikin: If it is error correction then why not do that as a separate step?
13:43:25 <jfredett> akappa: I was being silly, but eclipse (I think) tries to pile too much into it's perspective modes. the notion is similar
13:43:29 <jfredett> but more fine-grained
13:43:49 <akappa> understood
13:43:59 <jfredett> eg, you'd have a "statistics" "perspective" rather than a "haskell" perspective.
13:44:01 <jmillikin> Lemmih: it's not error correction; I'm not planning on changing the input to try to make it work.
13:44:08 <akappa> in effect I keep just the editor window maximized most of the time
13:44:22 <lispy|web> jmillikin: I find that using laziness to process large structures doesn't always turn out like you want
13:44:24 <Lemmih> jmillikin: Then why not catch the errors in IO land?
13:44:26 <jmillikin> If an error is encountered while streaming the data, it ought to stop processing and return the error.
13:44:44 <jmillikin> Lemmih: because then I have the choice between moving the entire calculation into IO, or using unsafePerformIO
13:45:22 <lispy|web> jmillikin: it tends to be fine for big lists with small elements, but if the values themselves are large you often run into issues where you look at more than you intend to and run out of memory.  Oleg's iteratees are what I'm looking at now something related to this very problem
13:45:25 <jfredett> akappa: right, any you'd be using whatever editor you like, "bouncing" between the land of interaction and testing (and managing file structures and cabal files and whatever) and coding (in your editor).
13:45:55 <Lemmih> jmillikin: Firstly, don't use unsafePerformIO, especially not together with exception handling. Secondly, why would you have to move the entire calculation into IO?
13:46:06 <akappa> jfredett, sounds reasonable
13:46:19 * lispy|web thinks jmillikin should listen to Lemmih 
13:46:20 <jmillikin> Lemmih: because it would need to be in IO to catch and handle the error.
13:47:05 <jmillikin> lispy|web: there's usually a few gigabytes of data, but each element in the list is a kilobyte or so.
13:47:32 <Lemmih> jmillikin: But you're not doing error correction. You should be able to handle the error out side of your pure code.
13:47:36 <lispy|web> jmillikin: you might get away with it.  But, lazy IO is almost always full of problems
13:48:14 <jmillikin> Lemmih: What do you mean? How can I handle the error outside of the calculation?
13:48:22 <lispy|web> jmillikin: http://okmij.org/ftp/Streams.html
13:48:25 <ddarius> jfredett: Possibly look at "Modeling an Algebraic Stepper" if you haven't already.
13:49:00 <jfredett> ddarius: ooh, papers? I like papers, my Kindle can render them now... *goes a googlin'*
13:49:08 <Lemmih> jmillikin: print (calculate stuff) `catch` \error -> putStrLn $ "You made and error: " ++ show error
13:49:18 <lispy|web> jmillikin: (some motivating material) http://okmij.org/ftp/Haskell/Iteratee/Lazy-vs-correct.txt
13:50:00 <jmillikin> lispy|web: changing to iteratees to fix lazy IO feels like amputating a leg to fix long toenails
13:50:17 <jmillikin> Lemmih: but that's not handling the error, it's just giving up entirely and punting out to the IO layer.
13:50:32 <ddarius> unsafeInterleaveIO and its spawn are sin
13:51:20 <Lemmih> jmillikin: Not giving up is called error correction.
13:51:42 <jmillikin> Ah, in that case, it *is* performing error correction.
13:51:57 <Lemmih> jmillikin: So, why not do error correction as a separate step?
13:52:30 <jmillikin> It wouldn't know there's been an error until the calculation's been performed.
13:52:53 <lispy|web> jmillikin: lazy IO is unsafe and unpredictable though.  On the other hand, iteratees don't require unsafe* and they are predictable.  You lose a bit in composability, but gain much in other areas that turn out to be just as important
13:53:11 <Lemmih> RawInput -> Parser -> Error correction -> Stuff that requires error free input.
13:53:11 <ddarius> jfredett: If your Kindle couldn't render papers before, what use was it?
13:53:32 <ivanm> ddarius: as a paper weight
13:53:34 <lispy|web> I'm not an iteratee expert, but have experience with misbehaving lazy IO
13:53:37 <jfredett> ddarius: I mean that it renders pdfs instead of just .mobi/text-like formats
13:58:50 <ddarius> "Unfortunately, once it became clear that the ideas are working out, the motivation fizzled."
13:59:06 <lispy|web> ddarius: what is that from?
13:59:19 <ddarius> http://okmij.org/ftp/Streams.html#for-layering
14:00:24 <lispy|web> olegs get bored too
14:01:55 <Lemmih> jmillikin: This is my parting advice: Isolate independent passes, awkward code is a sign of inefficiency, introduce data structures to enforce invariants.
14:05:27 <shachaf> @remember oleg Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
14:05:27 <lambdabot> I will remember.
14:08:42 <pastah_rhymez> why can't tab completion be hooked to my head?
14:09:07 <ddarius> pastah_rhymez: It can.
14:09:26 <pastah_rhymez> "touch Ex" <-- when pressing tab here, my terminal should KNOW that it's supposed to be "touch Execution.hs"
14:09:41 <pastah_rhymez> because i thought it
14:10:05 <pastah_rhymez> @faq can haskell hook tab completion to my head?
14:10:05 <lambdabot> The answer is: Yes! Haskell can do that.
14:12:32 <medfly> hehe, it would be funny to have a thing which shows you the result of a tab completion by default, but also lets you ignore it
14:15:52 <pastah_rhymez> medfly: what OS are you using?
14:16:09 <medfly> ubuntu
14:16:15 <pastah_rhymez> medfly: ALT+F2
14:16:16 <medfly> though I suppose that's pretty simple and exists in some places :)
14:19:46 <BMeph> @faq can Haskell respond to inappropriate touches?
14:19:46 <lambdabot> The answer is: Yes! Haskell can do that.
14:20:35 <vovik> !pf
14:21:52 <kmc> @yarr
14:21:53 <lambdabot> What be a priate's favourite cheese?
14:21:53 <lambdabot> Yarrlsburg!
14:21:57 <vovik> @pf
14:21:58 <lambdabot> Maybe you meant: bf pl
14:22:06 <kmc> @help bf
14:22:06 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
14:22:12 <vovik> @help pl
14:22:12 <lambdabot> pointless <expr>. Play with pointfree code.
14:22:16 <kmc> bf [+.]
14:22:19 <kmc> @bf [+.]
14:22:20 <lambdabot>  Done.
14:22:24 <akappa> Done? lol
14:22:43 <vovik> lazy robot
14:22:48 <vovik> @pf repliM lst n = lst >>= replicate n
14:22:48 <lambdabot> Maybe you meant: bf pl
14:22:56 <vovik> @pl repliM lst n = lst >>= replicate n
14:22:57 <lambdabot> repliM = (. replicate) . (>>=)
14:24:03 <vovik> that makes no sense
14:24:22 <vovik> i guess pointfree is no good for this one
14:25:46 <bd_> it makes sense if you think about it a bit
14:25:54 <bd_> but I agree, if you're going to use pointfree, use it tastefully
14:26:25 <kmc> @pl \lst n -> lst >>= replicate n
14:26:25 <lambdabot> (. replicate) . (>>=)
14:26:54 <vovik> @type replicate
14:26:55 <lambdabot> forall a. Int -> a -> [a]
14:27:05 <kmc> > replicate 4 'X'
14:27:06 <lambdabot>   "XXXX"
14:27:28 <kmc> @. vixen eval replicate 4 'X'
14:27:29 <lambdabot> so, what made you want to message me?
14:28:35 <vovik> @type map
14:28:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:29:48 <vovik> > show $ map show (replicate 10 "spam")
14:29:49 <lambdabot>   "[\"\\\"spam\\\"\",\"\\\"spam\\\"\",\"\\\"spam\\\"\",\"\\\"spam\\\"\",\"\\\...
14:30:28 <vovik> > map (replicate 3) "spam"
14:30:30 <lambdabot>   ["sss","ppp","aaa","mmm"]
14:30:45 <vovik> > concatMap (replicate 5) "spam"
14:30:46 <lambdabot>   "ssssspppppaaaaammmmm"
14:31:22 <jfredett> > fix ("spam"++)
14:31:24 <lambdabot>   "spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamsp...
14:31:34 <vovik> @type fix
14:31:36 <lambdabot> forall a. (a -> a) -> a
14:31:55 <jfredett> > (fix ("spam "++)) ++ "Wonderful Spam!"
14:31:56 <lambdabot>   "spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam...
14:33:13 <vovik> wtf is fix
14:33:35 <jfredett> it finds (or tries to find, as I understand) the least fixpoint of a function
14:34:17 <jfredett> fix (\x -> (x + 1) `mod` 10)
14:34:19 <jfredett> oops
14:34:22 <shachaf> jfredett: Does it ever not?
14:34:24 <jfredett> > fix (\x -> (x + 1) `mod` 10)
14:34:28 <lambdabot>   mueval-core: Time limit exceeded
14:34:30 <kmc> @src fix
14:34:30 <lambdabot> fix f = let x = f x in x
14:34:37 <kmc> ^^^^ all you need to know
14:34:43 <conal> i've run into a bug in GHC 6.10.3.  would someone with a later GHC please try it for me in their version?  self-contained example at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13629
14:35:01 <conal> then i'll know whether to report the bug or upgrade my ghc.
14:35:02 <vovik> hmmmmm
14:35:28 <jfredett> I don't think I understand it's use, but smart people can make it do useful things, I just use it to make lame monty python references.
14:36:06 <copumpkin> conal: I came across that before, and am pretty sure it's fixed in 6.12, but haven't tried it myself
14:36:15 <kmc> > let fac n = case n of 0 -> 1; _ -> n * (fac (n-1)) in fac 6
14:36:17 <lambdabot>   720
14:36:34 <conal> copumpkin: did you use a GADT as an associated data type?
14:36:37 <kmc> > fix (\fac -> case n of 0 -> 1; _ -> n * (fac (n-1))) 6
14:36:37 <copumpkin> yeah
14:36:39 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
14:36:39 <lambdabot>                           ...
14:36:50 <kmc> > fix (\fac -> \n -> case n of 0 -> 1; _ -> n * (fac (n-1))) 6
14:36:52 <lambdabot>   720
14:36:52 <conal> copumpkin: cool.  do you remember for what?
14:36:53 <copumpkin> conal: I think there's a ticket on it, let me find it
14:36:58 <copumpkin> conal: just to see if it would work :)
14:37:01 <vovik> conal: i have 6.10.4 and got ghc: panic! (the 'impossible' happened)
14:37:05 <conal> copumpkin: :)
14:37:16 <pastah_rhymez> conal: fromJust Nothing <-- 6.10.4 ubuntu
14:37:18 <kmc> fix is used for "anonymous recursion" as demonstrated above
14:37:28 <copumpkin> bah, the search feature on the ghc trac is so slow it's useless
14:37:32 <conal> vovik: how about in ghci?
14:37:38 <conal> pastah_rhymez: thx
14:37:48 <conal> anyone have a ghc more recent that 6.10.4?
14:38:12 <vovik> conal: *** Exception: Maybe.fromJust: Nothing
14:38:21 <conal> vovik: thx.
14:38:25 <kmc> shachaf, it always finds the fixed point, by definition.  but for some functions f, the fixed point of f diverges on every input
14:38:37 <kmc> > fix succ 3
14:38:38 <lambdabot>   No instance for (GHC.Enum.Enum (t -> a))
14:38:39 <lambdabot>    arising from a use of `GHC.Enum...
14:38:43 <copumpkin> hmm, can't find the ticket, but I'm pretty sure we talked about it in #ghc at one point
14:39:30 <shachaf> kmc: But _|_ or const _|_ is still a fixed point, yes?
14:39:53 <conal> copumpkin: thx for looking.  i'll ask in #ghc tomorrow.
14:40:02 <kmc> shachaf, if f is strict in its argument, then _|_ is a fixed point of f
14:40:12 <kmc> regardless of what other fixed points it may have
14:40:22 <kmc> > fix (`div` 2)
14:40:26 <lambdabot>   mueval-core: Time limit exceeded
14:40:31 <kmc> > 0 `div` 2
14:40:32 <lambdabot>   0
14:40:46 <kmc> note that (`div` 2) has a non-bottom fixed point (0) which fix does not find
14:40:57 <kmc> because it's not magical
14:41:00 <shachaf> Of course.
14:41:25 <shachaf> > fix cos -- Does this number have any significance?
14:41:29 <lambdabot>   mueval-core: Time limit exceeded
14:41:43 <shachaf> > (!!10000) . iterate cos $ 0.5
14:41:45 <lambdabot>   0.7390851332151607
14:41:59 <kmc> > iterate cos 0
14:42:00 <lambdabot>   [0.0,1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.7934803...
14:42:11 <jfredett> > (!! 1000000) . iterate cos $ 0.5
14:42:13 <lambdabot>   * Exception: stack overflow
14:42:18 <jfredett> > (!! 100000) . iterate cos $ 0.5
14:42:20 <lambdabot>   0.7390851332151607
14:42:34 <copumpkin> duh
14:42:39 <copumpkin> > last . iterate cos $ 0.5
14:42:41 <copumpkin> ;)
14:42:44 <jfredett> well that's a fixpoint for all practical purposes..
14:42:46 <lambdabot>   mueval: ExitFailure 1
14:42:50 <jfredett> copumpkin: ohnoes!
14:42:50 <copumpkin> that's clearly the right answer
14:42:52 <conal> > take 10 $ drop 100 $ iterate cos 0.5
14:42:56 <lambdabot>   [0.7390851332151607,0.7390851332151607,0.7390851332151607,0.739085133215160...
14:43:09 <conal> i guess the take 10 didn't help
14:43:37 <kmc> it's the intersection of the graphs y=cos(x) and y=x
14:43:51 <kmc> and you get there regardless of starting value
14:43:53 <shachaf> let fix f = last (iterate f undefined)
14:44:05 <kmc> > (!! 100000) . iterate cos $ 27
14:44:07 <lambdabot>   0.7390851332151607
14:44:18 <gnut> anyone get errors when running cabal near the end that say "removeDirectory: File exists"
14:44:39 <gnut> it errors out even though the package is successfully installed
14:44:47 <gnut> it just can't remove the directory in /tmp
14:44:57 <shachaf> Yep. I used 0.5 from, um, some hazy sense that cos 0 might be 0? Or something.
14:45:01 <gnut> this only matters if installing packages where it has to install dependencies
14:45:04 <kmc> > cos 0
14:45:05 <lambdabot>   1.0
14:45:11 <shachaf> Yes, I know. :-) I didn't think about it.
14:45:14 <kmc> > (!! 100000) . iterate cos $ 0
14:45:17 <lambdabot>   0.7390851332151607
14:45:20 <kmc> > (!! 100000) . iterate cos $ pi
14:45:22 <lambdabot>   0.7390851332151607
14:45:25 <gnut> since then I have to keep running cabal until it's done with all the dependencies
14:45:25 <shachaf> Does the number have any significance?
14:45:36 <Jafet> It's the attracting fixed point of cosine.
14:45:48 <Jafet> Other than that it probably isn't relevant to anything
14:46:08 <jfredett> shachaf: no- as kmc mentioned. it's just the intersection of y=x and y=cos(x)
14:46:11 <kmc> google fails to turn up a meaning other than "the fixed point of cos"
14:46:34 <shachaf> jfredett: Well, I was wondering if it was "just".
14:47:02 <shachaf> > iterate ((1+) . (1/)) 1 !! 1000
14:47:04 <lambdabot>   1.618033988749895
14:48:30 <reltuk> anyone here ever used Statistics.RandomVariate?
14:48:33 <Jafet> It's a solution to the deep and marvelous equation 2 - sin^2 (x) - x^2 = 0!
14:49:01 <jfredett> > sum $ take 10000 $ (zipWith (\x y -> x / 2^y) [1..] [0..])
14:49:02 <lambdabot>   3.9999999999999996
14:49:13 <jfredett> > sum $ take 100000 $ (zipWith (\x y -> x / 2^y) [1..] [0..])
14:49:16 <lambdabot>   3.9999999999999996
14:50:06 <shachaf> jfredett: They're all going to be rounded to 0 after a certain point.
14:50:11 <jfredett> shachaf: :(
14:50:26 <jfredett> I wanted it to be 4... 4 is an awesome number...
14:50:34 <ygd-coder> > sum $ take 10001 $ (zipWith (\x y -> x / 2^y) [1..] [0..])
14:50:36 <lambdabot>   3.9999999999999996
14:50:46 <shachaf> jfredett: Almost as much as 16.
14:51:03 <jfredett> > const 4 $ sum $ take 100000 $ (zipWith (\x y -> x / 2^y) [1..] [0..])
14:51:04 <lambdabot>   4
14:51:05 <jfredett> problem solved.
14:51:12 <ygd-coder> nice
14:51:18 <shachaf> Ingenius!
14:51:31 <jfredett> const TheCorrectAnswer
14:51:41 <shachaf> > const 0.7390851332151607 $ fix cos
14:51:42 <lambdabot>   0.7390851332151607
14:51:51 <jfredett> forall p, p a problem, p solved.
14:51:59 <ygd-coder> > fix cos
14:52:03 <lambdabot>   mueval-core: Time limit exceeded
14:52:04 <dmwit> > cos 0.7390851332151607
14:52:05 <lambdabot>   0.7390851332151607
14:52:11 <dmwit> marvelous!
14:52:57 <ygd-coder> > cos 2 * pi
14:52:58 <Jafet> > sum $ take 100000 $ (zipWith (\x y -> x / 2^y) [1..]::[CReal] [0..])
14:52:59 <lambdabot>   -1.307363844511135
14:52:59 <lambdabot>   <no location info>: parse error on input `..'
14:53:15 <ygd-coder> cos 180
14:53:19 <reltuk> is the ST monad magic like the IO monad is?
14:53:32 <kmc> reltuk, yes
14:53:37 <kmc> it's even more magic in a sense
14:53:39 <dmwit> reltuk: very much like
14:53:45 <Jafet> reltuk, it's higher rank magic
14:53:45 <ygd-coder> > cos 60
14:53:47 <lambdabot>   -0.9524129804151563
14:53:48 <mxyz> anyone use Leksah?
14:53:57 <dmwit> reltuk: IO is implemented in ST. =)
14:54:03 <kmc> in ghc
14:54:08 <dmwit> in ghc
14:54:09 <dmwit> right
14:54:32 <ygd-coder> > cos (pi / 3)
14:54:33 <lambdabot>   0.5000000000000001
14:54:36 <dmwit> mxyz: Hm, I guess that's not really the question you meant to ask.
14:54:41 <copumpkin> Cale: damn, Robin is on fire!
14:54:49 <dmwit> mxyz: The answer to that question is almost certainly, "yes". =)
14:55:28 <mxyz> nice! i just installed it this week on windows and it worked great. it really helped me to be able to browse the modules so easily.
14:55:55 * lispy|web has been re-reading the iteratee docs because he wants to use them and is reminded of why he doesn't like them
14:56:01 * jfredett can't think of an editorial topic for HWN.
14:56:08 <dmwit> > exp pi - pi -- 20.0
14:56:09 <lambdabot>   19.999099979189474
14:56:11 <copumpkin> jfredett: :O
14:56:16 <jfredett> I think I'll just make some jokes...
14:56:19 <shachaf> > const 20 $ exp pi - pi -- Success!
14:56:21 <lambdabot>   20
14:56:22 <ivanm> jfredett: the arguments on -cafe
14:56:28 * shachaf uses the jfredett technique.
14:56:30 <dmwit> shachaf: rounding error ;-)
14:56:33 <jfredett> copumpkin: I've been writing papers all day.
14:56:45 <copumpkin> eww papers
14:56:48 * jfredett 's writer-brain is deadsies.
14:56:50 <kmc> > iterate (*2) 1
14:56:51 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
14:57:05 <dmwit> > map (2^) [1..]
14:57:06 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
14:57:12 <jfredett> ivanm: hmm, maybe something troll themed.
14:57:20 <iNpHestO> hello
14:57:22 <dmwit> Yours is shorter and more efficient, though.
14:57:25 <dmwit> iNpHestO: Hiya!
14:57:34 <lispy|web> Even some of the "simple" functions you write with iteratees seem a bit involved.
14:58:08 <kmc> > iterate (*3) 1
14:58:09 <lambdabot>   [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14...
14:58:36 * kmc cannot recognize nearly as many powers of 3 as powers of 2
14:58:46 <lispy|web> For one, I get confused by what to pass to the Cont constructor vs. what you pass to the Done constructor
14:59:02 <iNpHestO> Does somebody know... or have an idea about what programming language was used to make the game: Cartoon Network Universe: FussionFall?
14:59:33 <mxyz> has anyone tried EclipseFP? how do they like it compared to leksah?
15:02:55 <mxyz> anyone ever get the "Setup found what appears to be a non-working installation of GHC" error when installing Gtk2Hs?
15:03:48 <mtnviewmark> is there anyway to "demangle" the cost centre names in a profile report?
15:04:18 <lispy|web> mtnviewmark: don't they match the names used in the core?
15:04:49 <lispy|web> mtnviewmark: so if you tell ghc to dump the core output (I always forget the commandline flag) then you should be able to look in it for the function?
15:05:08 <mtnviewmark> for example, I've got a type class with a function fromLLSD
15:05:21 <mtnviewmark> and in the profile I see fromLLSD_a1Ec
15:05:44 <mtnviewmark> I don't konw which instance that's for
15:05:56 <mtnviewmark> can I dump the .hi file and find out?
15:07:36 <lispy|web> mtnviewmark: -ddump-simpl I think is what you want
15:07:50 <rrice> does anyone use ubuntu?  I am wondering if I can install haskell packages via apt-get or not...
15:07:56 <lispy|web> mtnviewmark: or even try this http://hackage.haskell.org/package/ghc-core
15:08:15 <lispy|web> rrice: I prefer to use cabal-install on ubuntu
15:09:33 <Jafet> Ubuntu's haskell packages are incoherent
15:11:44 <rrice> lispy|web: I was thinking that was probably better, but did not know if it was a problem or not.  In lisp, SBCL seem to use either apt-get or ASDF equally, but I was not sure if that was the same for GHC.
15:12:25 <rrice> Jafet: incoherent as in "broken"?
15:12:32 <dmwit> Wait, CReal has an Eq instance?
15:13:03 <dmwit> > 6 * 9 == (54 :: CReal)
15:13:05 <lambdabot>   True
15:15:04 <Jafet> Outdated and incoherently organized
15:15:10 <dmwit> Oh, that's nasty.
15:15:15 <dmwit> > 0 == 10^^-42
15:15:16 <lambdabot>   Not in scope: `^^-'
15:15:19 <dmwit> > 0 == 10^^(-42)
15:15:20 <lambdabot>   False
15:15:39 <dmwit> > 0 == (10^^(-42) :: CReal)
15:15:40 <lambdabot>   True
15:16:37 <dmwit> I guess I'm not really sure what I was expecting, now that I think of it.
15:16:39 <rrice> um, wow.
15:16:51 <jfredett> phew, there are alot of quotes this week, you people were wicked funny this time around.
15:18:21 <copumpkin> yeah, CReal == isn't "correct"
15:19:33 <copumpkin> lol, Apocalisp: data CanHaz a = Haz a | ButIEatedIt
15:20:16 <Runar> playing with lambdabot?
15:20:21 <dmwit> Well, I suppose it's probably not possible to write a correct (==) that does anything interesting.
15:20:26 <ivanm> jfredett: or we were just more bored than usual...
15:20:43 <jfredett> Runar: no, I just put up HWN
15:20:47 <jfredett> copumpkin: I laughed outloud (woke up the missus too) at that one.
15:20:52 <copumpkin> :)
15:20:56 <Runar> heh
15:21:11 <copumpkin> dmwit: yeah :/ people don't like "semidecidable" functions :(
15:21:26 <copumpkin> I got chewed out for writing a (==) that did the right thing in my enumerable package
15:21:33 <mxyz> oh shit
15:21:45 <dmwit> heh
15:21:55 <mxyz> i just looked up HWN on reddit for the first time
15:22:21 <mxyz> why does it say I "enthusiastically" asked about 2d graphics, lol?
15:23:29 <jfredett> mxyz: because you seemed enthusiatic!
15:23:45 <dmwit> jfredett: Well, at least your typos are consitent.
15:23:46 <jfredett> you also opened the thing with "Greetings!" which is decidedly enthusitic
15:23:47 <jfredett> :)
15:24:03 <jfredett> dmwit: shh, it's finals week and I forgot to turn on the spellchecker...
15:24:06 <dmwit> =)
15:24:34 <jfredett> dmwit: damnit, now I can't just glaze over my typo... english is hard...
15:25:01 <mxyz> jfredett: it was my first post ever. i heard so much hype about how nice the haskell-cafers were. i figured i had to be polite.
15:25:40 <jfredett> mxyz: we're wicked nice, it's our game, we lure you in with kindness, then trap you with monads from which there are no safe exits
15:25:53 <jfredett> `unsafeFreeNewbies` doesn't exist. :)
15:25:58 <mxyz> and they were indeed polite. too bad they didn't manage to get me a step closer to accomplishing anything, lol.
15:26:10 <mxyz> port audio still doesnt work and gtk2hs still wont install.
15:27:27 <jfredett> mxyz: well that sucks, I don't know anything about either of those things, I'm thoroughly stuck in the command line, and my extent of audio tools are covered by Max (or Pd) and Reason...
15:27:50 <jfredett> all that lowlevel business just seems so... grimey. :/
15:27:51 <dmwit> What goes wrong with gtk2hs?
15:27:53 <mxyz> HWN is cool. im liking it. my site is subreddits.org but I never really did anything with it.
15:28:57 <mxyz> dmwit: i get the error "Setup found what appears to be a non-working installation of GHC in the folder: C:\Program Files\Haskell Platform\2009.2.0.2"
15:29:08 <jfredett> mxyz: all the HWN coolness comes from my editor forebears, I just make lame jokes and ride the wave, at this point. :)
15:29:09 <dmwit> (I will note that you didn't complain (at least in the thread I saw) about Gtk2Hs not building, so it's hard to blame them for not fixing the problem they didn't know existed.)
15:29:12 <mxyz> there is a bug filed that was closed last year
15:29:28 <jfredett> in any case, I'm off to sleep. Goodnight haskellers.
15:29:53 <mxyz> dmwit: i posted that to the gtk2hs mailing list. i didnt want to crosspost
15:29:59 <dmwit> ah =)
15:30:30 <mxyz> ive never been one for command line apps
15:30:42 <dmwit> Have you tried installing ghc in a path with no spaces in it, by the way?
15:31:07 <mxyz> i didnt consider that. i just let the haskell download install where it wanted
15:31:35 <dmwit> I vaguely recall some subtlety with that.
15:31:50 <mxyz> you ever hear of SunSPOT's?
15:31:53 <dmwit> I know it takes a bit of time to do the installation, but...
15:32:19 <dmwit> um, nope
15:32:38 <mxyz> they are these expensive little java machines
15:32:51 <mxyz> i remember the day i installed them i followed the instructions
15:33:12 <mxyz> and then at the end of a long process the last page of the install book said "note: install into a path with no spaces"
15:33:34 <mxyz> when early it said to use /program files/. so yea, ive been bitten by that before!
15:34:04 <mxyz> i had to uninstall and start all over.
15:34:05 <dmwit> aww
15:34:10 <dmwit> That sucks.
15:34:18 <dmwit> And you're about to have to do it again... =P
15:34:26 <mxyz> gah
15:34:43 <mxyz> why isnt gtk2hs part of haskell "batteries included" anyway?
15:35:03 <dmwit> It doesn't build with cabal.
15:37:39 <mxyz> i guess the gtk2hs mailing lists dont get much traffic? i subscribed to users and devel and there hasnt been a single post all day
15:37:51 <mxyz> does the haskell.org gtk list get more?
15:38:10 <dmwit> dunno
15:38:23 <dmwit> I guess you could take a peek at their archives, though, no?
15:38:58 <mxyz> good point!
15:39:30 <mxyz> i was hoping id be making one of these trees by the end of the day http://fhtr.blogspot.com/2008/12/drawing-tree-with-haskell-and-cairo.html but i think its time for bed
15:39:35 <mxyz> thanks. later
15:53:52 <lispy|web> `cabal install cabal-install` always feels a little weird
16:08:15 * pastah_rhymez does io
16:08:59 <sohum> lispy|web: bootstrapping woo
16:09:20 <sohum> lispy|web: I believe most package systems do something like that
16:12:04 <copumpkin> Veinor: muahaha, caught you
16:12:11 <Veinor> :P
16:36:35 <mjrosenb> in ghci, is there any way of directing the output of :browse to less so i can search it?
16:38:25 <ivanm> mjrosenb: don't think so :(
16:38:41 <ivanm> mjrosenb: but most terminals let you scroll...
16:38:52 <ivanm> try shift + page-up/down
16:39:11 <ziman> echo ':browse Data.List' | ghci | less     <-- works for me
16:41:04 <ivanm> or you could look at the haddoc docs...
16:41:12 <ivanm> there's also ghci -c or something IIRC
16:48:15 <mjrosenb> ivanm: scrolling is not the feature that i want the most.
16:48:22 <mjrosenb> ivanm: / is the feature that i want
16:48:28 <ivanm> ahhh
16:49:00 <ivanm> do it in emacs and use C-r ! ;-)
16:49:09 <mjrosenb> and/or &
16:49:13 <mjrosenb> <3 &
16:49:24 <ivanm> what does & do>
16:49:27 <ivanm> ?
16:49:35 <mjrosenb> like /
16:49:47 <mjrosenb> but it does not display lines that do not match the regex
16:49:59 <ivanm> ahhh, it filters as well
16:52:29 <ketil> Is it okay if I move the talk page for Haskell on wikipedia?
16:52:48 <ketil> The discussion there seems to be out of date, and the page is very long.
16:53:10 <ketil> Opinions wanted *now*, or I'll just do it anyway :-)
16:54:40 <mjrosenb> is there a reason to move it?
16:56:09 <ketil> discussions are outdated, and the main page has been totally revamped.
16:56:39 <ketil> I don't think it's relevant anymore.
16:56:58 <ketil> I mean move, as in move to an archive page, of course.
16:57:20 <ketil> Not move as in vandalism move :-)
17:01:55 <copumpkin> Veinor: ooh, I'm going to lose all my twitter followers now :o
17:04:23 <ketil> Okay: since there were no objections, it is a fait accompli, a done deal, a burned bridge...
17:04:37 * ketil puts on asbestos underwear, and goes off for breakfast.
17:06:22 <Veinor> copumpkin: ?
17:06:34 <copumpkin> Veinor: I just insulted 90% of my followers :P
17:06:53 <Veinor> Haha, oh dear I didn't notice that
17:07:24 <copumpkin> can't say I'll miss them
17:07:35 <Veinor> it is kind of silly that the dev team hasn't release a windows version though
17:07:41 <Veinor> but vOv
17:08:53 <copumpkin> Veinor: we're mostly disbanded at this point, a few stragglers remain and we still hang out in a channel together cause we share interests, but most interest in the iphone is gone
17:09:02 <copumpkin> it's not fun anymore
17:09:09 <Veinor> fair enough.
17:09:49 <Veinor> the platform's used by enough people that there will probably always be a jailbreak for at least the most recent major release of the OS
17:10:19 <copumpkin> yeah
17:10:21 <jkff> Hi. What is the definition of rank of a polymorphic type? Is it that r(forall a.T)=1+r(t) and for all type constructors C including ->, r(C T1 T2 ..)=max(r(T1),r(T2),..) ?
17:11:02 <copumpkin> Veinor: until geohot gets tired of it anyway. We and geohot are the only ones with the kind of knowledge to do this, and he has a short attention span (unless there's money involved)
17:11:23 <Veinor> :P
17:12:49 <copumpkin> the chronic dev team is mostly shit :P
17:13:14 <Veinor> I haven't paid any attention to any of their exploits (pun not intended)
17:13:40 <Veinor> I do have to admit I donated like $10 to geohot after he released blackra1n though >_>
17:14:22 <ray> i am copumpkin
17:14:38 <copumpkin> Veinor: good for you :)
17:14:42 <copumpkin> ray: you are what?
17:14:50 <Beelsebob> I am copumpkin
17:15:09 <Veinor> I refuse to take place in this trending topic silliness though, or pretty much anything else he does unless it's a jailbreak for a version that has some killer feature. anyway.
17:15:15 <Veinor> no, I'm copumpkin!
17:15:44 <ray> make #drongisnotacat a trending topic pls
17:16:43 <copumpkin> :)
17:18:31 <jkff> I'm confused. Is (forall a . a) -> String a polymorphic type? If it isn't, then my definition of rank is broken. If it is, then how come that it has only one instantiation?
17:19:05 <copumpkin> it's a higher-rank polymorphic type
17:19:14 <copumpkin> means you can only call it with _|_, really
17:19:40 <jkff> Shouldn't a polymorphic type be quantified at the top level?
17:19:47 <copumpkin> hm?
17:20:00 <copumpkin> it's different if you put the forall at the top level
17:20:09 <jkff> I mean, in what sense is it polymorphic at all? Where's the polymorphism?
17:20:19 <jkff> The polymorphism of map is that I can call it on lists of any type
17:20:21 <copumpkin> f :: forall a. a -> String vs. g :: (forall a. a) -> String
17:20:51 <copumpkin> you could call f with any type
17:20:55 <jkff> Yeah, I understand that one cant lift the quantifier without changing semantics. I'm asking whether the definition of rank of polymorphism corresponds to intuition :)
17:21:10 <jkff> Yes. But I can call g with only one type.
17:21:26 <copumpkin> I'm not sure I understand the question then :P
17:21:29 <jkff> That's why I'd call it monomorphic
17:21:42 <jkff> Although it syntactically seems to be rank2-polymorphic
17:21:52 <jkff> The question is: which is right.
17:21:59 <copumpkin> well, it's forcing you to provide a polymorphic type, so in a sense it's monomorphic I guess
17:22:21 <jkff> Is there a mathematically strict "sense" about that? :)
17:23:44 <jkff> Hm, wikipedia doesn't make things any more clear.
17:23:44 <copumpkin> I'm not really sure where higher-rank polymorphism fits into the polymorphism as a natural transformation view of things
17:24:27 <copumpkin> it sounds like you want a morphism from a natural transformation to an object
17:24:32 <copumpkin> which seems rather strange :)
17:24:39 <copumpkin> but I can't say I'm an expert
17:25:02 <jkff> That is a morphism from an object that is in some sense equivalent to a natural transformation, to an other object :)
17:25:39 <jkff> Hm. Guess I should ask haskell-cafe for advice.
17:26:25 <ray> wouldn't an actual haskell cafe be better than a mailing list
17:26:30 <copumpkin> yeah :)
17:27:10 <jkff> That's what Haskell user groups are for :)
17:27:19 <ray> it wouldn't be any more difficult for people on the other side of the planet to get to than mailing lists in general are to follow
17:27:23 <ray> instantrimshot.com
17:27:25 <reltuk> hmm...
17:27:32 <copumpkin> ray even has a local HUG I think
17:27:35 <copumpkin> but he never attends
17:27:45 <ray> too drunk
17:27:58 <Veinor> I love instantrimshot.com
17:28:14 <Veinor> also, I might go to the boston HUG meeting if I can conquer my fear of people ;)
17:28:17 <reltuk> I converted my program from System.Random StdGen to Statistics.RandomVariate and it got slower =/
17:28:32 <copumpkin> Veinor: yay
17:28:35 <ray> haskell users will eat u
17:28:47 <copumpkin> don't worry, you won't have to talk at all if edwardk is there
17:29:42 <jkff> edwardk's stuff generally leaves me speechless
17:29:54 <Baughn> reltuk: What PRNG does randomvariate use?
17:30:18 <Baughn> reltuk: Adding extra work on top of the horror that is StdGen certainly won't make anything faster. ;)
17:30:31 <reltuk> Marsaglia's MWC256
17:30:44 <copumpkin> Baughn: it's completely independent from StdGen
17:30:47 <reltuk> it's possible I'm using it wrong
17:31:20 <Baughn> Then I wouldn't know. Hm.
17:31:38 <Baughn> StdGen is slow partially because it has to support splitting the generator. Does randomvariate do something similar?
17:31:49 <Baughn> ..actually, I'll just check. It sounds interesting.
17:32:08 <reltuk> there was a post on haskell-cafe earlier today which said it was fast :-)
17:32:18 <ray> RandomGen requires split
17:32:44 <Baughn> reltuk: Well, the page states "2-3 faster than MT", which is already blazing..
17:33:16 <reltuk> time to install profilling variants of all the hackage libraries I depend on
17:33:20 <Veinor> ray: could write a RandomGen that errors on split
17:33:33 <Cale> I'm not sure that I believe that's a real reason that it's slow.
17:33:53 <Baughn> Veinor: You could, but that would be mean
17:34:11 <Baughn> Cale: It's slow because it's a slow PRNG. split has been used as an excuse to not install a faster one.
17:34:29 <Cale> Almost any random generator should be able to support split at least as well as that one does.
17:34:39 <ray> you can always write degenerate instances
17:34:40 * Baughn shrugs
17:34:56 <ray> instance Num String where everything = undefined
17:35:18 <ray> except not fromInteger, so we can write 100 where we mean "100"
17:35:36 <Cale> Why leave it undefined? Just generate a pair of random generator states.
17:35:58 <ray> yeah, isn't that how splitting normally works?
17:36:03 <Cale> Sure, there *might* be some kind of correlation.
17:36:24 <ray> use the next two generated values as seeds for two new generators
17:36:30 <Cale> yes
17:36:53 <Baughn> It's not like StdGen is meant to be cryptographically secure anyhow
17:36:59 <Cale> right.
17:37:18 <Veinor> Baughn: I was just saying 'if split support causes it to be slow, then just make split not do anything so you don't have to support it'
17:37:55 <Cale> It *would* be nice to try a few methods and look at possible types of correlation between the two new generators you get.
17:38:14 <Baughn> Veinor: The "generate new states" trick would always work, though it might not always be a good idea
17:38:19 <Cale> But I'm willing to bet that you can find something simple enough that would work.
17:38:25 <Veinor> true.
17:38:51 <Cale> Generate two random strings of length 500 and then run each through a cryptographic hash then.
17:39:15 <Cale> Good luck figuring out any sort of resulting correspondence then ;)
17:39:56 <Cale> But I'm sure there are simpler faster things which will work well enough
17:40:50 <ray> i won't be convinced that such correlations exist without seeing a statistical analysis first
17:41:09 <reltuk_> I'm spending all my time restoring the generator
17:41:17 <reltuk_> is there a better way?
17:41:18 <ray> it's plausible, but only plausible
17:44:18 <reltuk_> the problem is, I only need a few random numbers each time
17:45:36 <Veinor> read from /dev/random :D
17:45:50 <reltuk_> that will probably be slower ;-)
17:46:49 <Baughn> reltuk_: Why restore it instead of saving it for later?
17:47:16 <reltuk_> Baughn: I have to save it for later, and then restore the thing I  saved
17:47:52 <reltuk_> I'm pretty new, but I think that's how these types work out wrt to the ST monad at least
17:47:58 <Baughn> reltuk_: Um.. why? Why not save the Gen instead?
17:48:05 <reltuk_> you can't get the generator itself out of the ST monad
17:48:35 <Baughn> Oh, I see..
17:48:39 <reltuk_> `runST create` doesn't type check...you can't force that first type parameter of ST
17:49:20 <Saizan> reltuk_: so save and restore are the expensive ones?
17:49:23 <Baughn> Hm. The implementations of save/restore look cheap, though
17:49:39 <Baughn> ..
17:49:47 <Baughn> save looks cheap. restore, not so much.
17:50:01 <reltuk_> yeah, restore in particular
17:53:05 <Baughn> reltuk_: Well, there's always stToIO
17:53:31 <reltuk_> Baughn still don't think I could get the Gen
17:53:43 <Baughn> reltuk_: For good reason. The Gen is mutable state.
17:53:50 <Baughn> reltuk_: But you could at least make it global
17:54:52 <reltuk_> yeah...the whole program is pure...I'd rather just put it in the ST monad, no?
17:55:11 <Baughn> Well.. understandable, but...
17:55:30 <Baughn> reltuk_: To be frank, random number generation isn't pure
17:55:45 <reltuk_> it's threaded too...so I don't think I could just slip some unsafePerformIOs in there and be good
17:55:50 <Baughn> reltuk_: Maybe you can pass in an infinite list of random numbers instead?
17:55:58 <Baughn> Oh, definitely not. *shudder*
17:56:06 <Baughn> And not because of the threads
17:56:28 <Veinor> you can never slip unsafePerformIO in anything and 'be good' ;)
17:56:32 <Baughn> reltuk_: http://hackage.haskell.org/package/MonadRandom <-- Have you looked at this?
18:00:29 <reltuk_> how could I go about constructing an infinite stream of randoms?
18:04:26 <m0nkfish> randstream = random() : randstream
18:05:28 <copumpkin> o.O
18:09:49 <reltuk_> I think the fact that ST is strict is getting me into trouble
18:10:22 <Saizan> mh, does ghci do any kind of strictness optimization?
18:10:46 <reltuk_> I tried: take 20 $ runST $ do { g <- create ; fix (\rec g -> do { new <- uniform g; rest <- rec g; return (new : rest) }) g }
18:11:09 <reltuk_> but that doesn't terminate
18:12:38 <Baughn> Ferdirand: 'I was TA for a C++ programming course aimed at 1st year
18:12:38 <Baughn>       physics once. Some girl asked for help "i wrote pseudo-code but I
18:12:38 <Baughn>       cannot translate it to C++". Her pseudo-code was valid haskell. I
18:12:42 <Baughn> ..ack
18:12:50 <Baughn> BAD email reader. Sorry.
18:12:53 <Baughn> Ferdirand: Is that true?
18:13:26 <Baughn> reltuk_: The lazy ST monad has strictly limited usefulness
18:13:57 <Baughn> Saizan: At -O and -O2, GHC does heroic strictness optimization
18:14:03 <reltuk_> Baughn: makes sense...
18:14:14 <Saizan> Baughn: "ghci" with no options
18:14:30 <Baughn> Saizan: Then no.
18:14:32 <reltuk_> but people create lazy io streams, right?
18:14:41 <Baughn> reltuk_: Occasionally, yes.
18:14:45 <Saizan> you can use unsafeInterleaveST
18:14:53 <Baughn> You could..
18:15:09 <Saizan> for a stream of random numbers it seems pretty safe
18:15:30 <Baughn> I find the best way is to use 'WriterT w (ST s) a', for the lazy ST
18:15:45 <Baughn> Forcing the tell'd return value will then force ST evaluation
18:16:24 <Saizan> the snippet above doesn't work in the lazy ST?
18:16:40 <Baughn> No, that's specifically where it /does/ work
18:16:54 <Baughn> Using the strict ST would force building the entire writer return structure before you can read any of it
18:17:14 <Baughn> ..oh, your snippet
18:17:29 <Saizan>  take 20 $ runST $ do { g <- create ; fix (\rec g -> do { new <- uniform g; rest <- rec g; return (new : rest) }) g }
18:17:33 <Saizan> that one ^?
18:17:37 <Baughn> It's a bit too complex for me to easily tell. ;)
18:17:56 <reltuk_> the random number generator uses the string ST
18:18:47 <Baughn> take 20 $ execWriterT $ runST $ do { g <- lift create; forever (tell =<< lift (uniform g)) }
18:18:51 <Baughn> That /will/ work.
18:19:12 <Baughn> Though I thnk you might have to wrap uniform's return value in a [] or something.
18:21:09 <Baughn> Saizan: For yours, I think you need an explicit interleave call. The lazy ST monad is still in-order.
18:21:22 <Baughn> Though I'm not sure that is true for return as well
18:21:39 * Baughn mumbles
18:22:56 <reltuk_> can I tell ghci through :module to load a module from a particular package?
18:23:34 <Baughn> reltuk_: No, but you can -hide-package the one that collides
18:24:02 <Baughn> As in 'ghci -hide-package mtl'
18:26:32 <reltuk_> so wrapping the string ST in writerT will make it able to be infinite without the unsafe interleave?
18:26:37 <reltuk_> s/string/strict/
18:26:45 <skorpan> seriously, why is it Left and not just Wrong?
18:27:21 <skorpan> oh, never mind
18:27:28 <Baughn> reltuk_: No
18:27:40 <Baughn> reltuk_: WriterT isn't magic. You still have to use the lazy ST monad.
18:27:50 <Baughn> reltuk_: WriterT just makes the resulting code easier to understand
18:28:15 <reltuk_> ahhhh, ok
18:28:15 <Baughn> For the /strict/ ST monad, you could use unsafeInterleaveST..
18:28:20 <Baughn> ...which amounts to making it into the lazy ST monad, so no real point
18:28:42 <reltuk_> Baughn except the library I'm using uses strict ST
18:28:48 <reltuk_> that would be the point, right?
18:29:07 <Baughn> reltuk_: Ah.
18:29:16 <Baughn> Though there's also the strictToLazyST function
18:30:23 <reltuk_> wow, unsafeInterleaveST works
18:39:01 <Baughn> dons: Does "stepping into C for a high-performance library when there is already a low-performance haskell one" count as stepping into C for speed? If so, I just did it.
18:40:33 <ivanm> I think so...
18:40:37 <ivanm> cheater!
19:08:42 <pastah_rhymez> Baughn: you nasty person
19:08:58 <Baughn> What'd I do? o_O
19:09:04 <pastah_rhymez> FFI
19:09:20 <Baughn> The FFI isn't evil! People are evil, not the FFI!
19:09:27 <Baughn> The FFI doesn't kill people, people do!
19:09:49 <Twey> The FFI is prettyâ¦
19:09:54 <reltuk_> maybe my native stdgen is just really fast for some reason
19:14:06 <massy> ed
19:14:06 <massy>           #haskell
19:14:06 <massy> -:- SignOff NKj: #haskell ()
19:14:06 <massy> -:- dixie_ [i=dixie@real.wilbury.sk] has joined #haskell
19:14:06 <massy> -:- maltem [n=maltem@port-92-204-94-123.dynamic.qsc.de] has joined #haskell
19:14:07 <massy> -:- altmattr [n=altmattr@203-206-15-162.dyn.iinet.net.au] has joined #haskell
19:14:09 <massy> -:- NKj [n=NKj@chello213047049243.5.sc-graz.chello.at] has joined #haskell
19:14:11 <massy> <pastah_rhymez> Baughn: you nasty person
19:14:13 <massy> <Baughn> What'd I do? o_O
19:14:15 <massy> <pastah_rhymez> FFI
19:14:17 <massy> <Baughn> The FFI isn't evil! People are evil, not the FFI!
19:14:19 <massy> <Baughn> The FFI doesn't kill people, people do!
19:14:21 <massy> <Twey> The FFI is prettyâ¦
19:14:28 <Baughn> @where ops
19:14:28 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
19:14:41 <pastah_rhymez> massy: you you like that copypasta?
19:14:43 <Twey> massy: Nice ;)
19:14:53 <massy> sorry!
19:14:54 --- mode: ChanServ set +o dibblego
19:15:11 --- mode: dibblego set -o dibblego
19:15:27 <Baughn> massy: You like living dangerously, I see.
19:15:48 <maltem> more "oops" than "ops", or what was that?
19:15:59 <Twey> I think so, yes.  âº
19:16:17 <eivuokko> Huh.  Unicode smiley o.O
19:16:51 <chellomere> ã
19:17:11 <eivuokko> Argh :-P
19:18:24 <pastah_rhymez> Ø§ÙÙÙ Ø£ÙÙÙØ¨ÙØ±
19:18:38 <skorpan> pastah_rhymez: ?
19:19:00 <Baughn> @quote massy <massy> Sorry!   [mode +o dibblego] [mode -o dibblego]
19:19:00 <lambdabot> No quotes for this person. There are some things that I just don't know.
19:19:05 <Baughn> @remember massy <massy> Sorry!   [mode +o dibblego] [mode -o dibblego]
19:19:05 <lambdabot> Okay.
19:19:23 <pastah_rhymez> skorpan: "allahu akbar"
19:19:37 <opqdonut> @quote
19:19:37 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
19:19:50 <Twey> Hahahaha
19:20:05 <Twey> Yes, Debug.Trace is fantastic
19:20:43 <ziman> hm, i used to use it quite lot some time ago but gradually i stopped
19:20:59 <ziman> *quite a lot
19:21:18 <skorpan> @src Debug.Trace.trace
19:21:19 <lambdabot> Source not found. Do you think like you type?
19:21:49 <skorpan> trace string expr = unsafePerformIO $ putTraceMsg string >> return expr
19:22:04 <skorpan> that's right folks, you are all unsafe in your debugging!
19:22:15 <pastah_rhymez> skorpan: (\x -> unsafePerformIO (print x) `seq` x)
19:22:43 <skorpan> pastah_rhymez: what are you trying to say?
19:23:52 <pastah_rhymez> nuttin'
19:28:27 <skorpan> @src seq
19:28:28 <lambdabot> Source not found. Where did you learn to type?
19:28:33 <skorpan> fuck you lambdabot
19:29:04 <skorpan> The requested URL /ghc/docs/latest/html/libraries/ghc-prim/src/GHC-Prim.html was not found on this server.
19:29:16 <skorpan> weird.
19:30:27 * hackagebot upload: syb-with-class 0.6 - Scrap Your Boilerplate With Class (AndreaVezzosi)
19:31:04 <ray> seq !a b = b
19:31:35 <Saizan> heh
19:31:41 <ray> does that make you happy
19:32:09 <Saizan> data Seq a = Seq !a; seq a b = case Seq a of Seq _ -> b -- maybe this one :)
19:37:43 <osaunders> I've been thinking about writing Snake, in Haskell.
19:38:05 <osaunders> I want to do it with something really simple so I've been playing with HSCurses.
19:38:46 <Twey> Sounds good
19:38:48 <osaunders> If I was to make it decent there would be lots of IO because you have to put characters at positions on the terminal.
19:39:00 <Twey> Not necessarily
19:39:12 <osaunders> or you could output entire frame buffers.
19:39:18 <osaunders> [[Char]]
19:39:23 <Twey> That would be the preferred way of doing it
19:39:26 <Twey> Er, not [[Char]]
19:39:39 <Twey> Something like [SnakeObject]
19:40:12 <Twey> Or [(SnakeObject, Position)]
19:40:39 <osaunders> Which would represent the appearance of the snake?
19:41:23 <osaunders> Other idea I had: data TermPixel = Blank | Border | Pickup | Snake
19:41:23 <Twey> SnakeObject = Snake [TailSegment] | Apple | Block BlockWidth BlockHeight
19:41:30 <Twey> For example
19:41:34 <osaunders> type Frame = [[TermPixel]]
19:41:48 <Twey> You don't want to be working in terms of pixels
19:41:55 <Twey> (or characters, in this case)
19:42:03 <Twey> You want to be working in terms of objects
19:42:35 <osaunders> Yeah, you're right.
19:42:39 <Twey> You'll have a ârenderâ function responsible for rendering that into a frame buffer
19:42:48 <osaunders> ... that would merge all the objects together.
19:42:50 <Twey> And then a âdisplayâ function responsible for drawing that to the screen
19:42:53 <Twey> Yes
19:42:59 <osaunders> Mmm nice.
19:43:06 <Zao> data Game = Game { apples :: [(Int, Int)], snake :: [(Int,Int)], dims :: (Int, Int) }
19:43:12 <osaunders> Only downside is you have to draw ever char, every frame.
19:43:12 <Zao> do_eet :: Game -> Game
19:43:18 <osaunders> *every char
19:43:24 <Twey> osaunders: Not necessarily
19:43:25 <Zao> osaunders: Not necessarily.
19:43:34 <Twey> (not that that's really a problem)
19:43:38 <Zao> osaunders: Whatever you use to draw can trivially diff against previous "frame".
19:43:42 <Twey> *nod*
19:43:44 <osaunders> Oh I could have a diff thing.
19:43:46 <eivuokko> osaunders, Just make it draw to a buffer, and compare buffers between frames, and draw differences.
19:43:49 <osaunders> Ooooooh
19:43:55 <osaunders> Wow.
19:44:00 <Twey> You could even represent them as the previous frame plus diffs
19:44:04 <Zao> I see that I'm slightly redundant today :)
19:44:13 <Twey> Hehe
19:44:26 <lpsmith> Ok,  I've got a syntactic shibboleth that maybe somebody has a suggestion for
19:44:38 <lpsmith> I want to write something along the lines of
19:44:55 <osaunders> How do I keep two frames around, without state?
19:45:01 <Twey> osaunders: Or, you could represent them solely as the difference
19:45:25 <lpsmith> a_monad_that_returns_maybe >>=  maybe (return ()) $ \x -> ...
19:46:02 <lpsmith> only problem is,  >>= binds before $,   so that's a type error
19:46:08 <Twey> [Remove Block 3, Move Snake 1 (+ 1)]
19:46:31 <Saizan> s/a_monad/an_action/
19:46:36 <Twey> osaunders: You have the new frame defined in terms of the old frame
19:46:36 <Saizan> the monad is the type constructor
19:46:55 <lpsmith> Right
19:46:55 <Twey> data Frame = EmptyFrame | Changes [Change] Frame
19:47:12 <lpsmith> I stand corrected...  but still :-)
19:47:18 <Twey> osaunders: Gets kind of big, which is why I suggested only storing the diffs
19:47:39 <Saizan> lpsmith: i'd probably use do-notation there
19:47:47 <Twey> (the â3â and â1â being identifiers assigned to the objects to specify which one to modify)
19:47:53 <osaunders> Twey: Hmm.
19:47:57 <lpsmith> yeah,  I probably would too,  but I have reasons for wanting to avoid that
19:48:04 <lpsmith> In this specific case
19:48:26 <Twey> osaunders: (incidentally, that's basically isomorphic to [[Change]])
19:48:50 <Saizan> i'd use parentheses instead of $ then :)
19:49:29 <Saizan> Twey: this would be the output of render?
19:49:31 <lpsmith> heh,  maybe
19:49:33 <Twey> I'd use prefix bind
19:50:04 <Twey> (>>=) a_monad_that_returns_maybe . maybe (return ()) $ \x -> â¦
19:50:05 <Saizan> ?type maybe (return ())
19:50:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
19:50:12 <osaunders> I think I'm going to procrastinate over this for a while.
19:50:49 <Twey> Saizan: No, this would be the input to render, if one wanted to avoid writing every frame out in full
19:50:59 <Twey> Er, well
19:51:08 <Twey> And avoid doing diffs each render
19:51:59 <mmorrow> data Direction = N|S|E|W; data Pos = (Int,Int); data Snake = (Dir,[Pos],[Pos]); {-only need to know how many pixels/cells per time period the snake moves, then erase that many tail cells, and draw that many head cells in the given Dir-}
19:52:02 <mmorrow>  ?
19:52:30 <lpsmith> saizan:   I'd like to emphasize the correspondence between $ and >>= in this example:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5267#a5267
19:52:59 <mmorrow> (and the Snake is doing the two-list-Q thing)
19:53:06 <mmorrow> or you could just use Data.Sequence
19:53:15 <mmorrow> since you need fast access to both ends
19:53:22 <Saizan> Twey: conal would be horrified!
19:54:46 <lpsmith> Twey:  take a look at my hpaste,  I want the two to look as syntactically similar as possible,  if possible
19:54:51 <mmorrow> doing it in full every frame would be like O(80*24) vs. O(2)
19:55:00 <Twey> About ârenderâ, or the prefix bind?  :Ã¾
19:55:06 <lpsmith> prefix bind
19:55:16 <Twey> Yeah
19:55:33 <Twey> lpsmith: Why?
19:55:43 <Twey> lpsmith: (that was to Saizan)
19:55:58 * Twey often confuses Saizan with saizai
19:56:46 <lpsmith> To emphasize the correspondence between >>= and $
19:56:48 <lpsmith> in this case
19:57:00 <lpsmith> Of course that's complicated by the fact that deQ changed types
19:57:34 <Saizan> Twey: because computing changes rather than the state of the model is not particularly functional
19:57:48 <Twey> That's true
19:57:57 <Twey> Well
19:58:26 <Twey> takeTurn :: Game -> [Change]
19:58:33 <Twey> Seems reasonable to me
19:58:48 <Twey> And unify :: Game -> [Change] -> Game
19:59:17 <lpsmith> sigh,  maybe it's not that important
19:59:46 <Saizan> true, if takeTurn produces what the player does
20:00:16 <Twey> Oh, yeah
20:00:23 <Twey> takeTurn :: Game -> Input -> [Change]
20:02:09 <Saizan> but i wouldn't describe Change talking about how what's displayed, it seems more about breaking MVC at this point, though
20:02:53 <Twey> Saizan: Change isn't about how it's displayed, it's about what's on the board
20:02:58 <lpsmith> ok,  if anyone wants to indulge my silly perfectionism,  I've added two more revisions.   Which one is syntactically the most pleasing?
20:03:12 <lpsmith> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5267
20:03:14 <Twey> (or rather, what needs to happen to the board for the turn to take effect)
20:03:31 <Twey> It's not a list of pixel-by-pixel changes
20:05:08 <Saizan> mh, you convinced me, it's a mini-language that can be interpreted both as a Game -> Game and as a rendering action, nice
20:05:31 <Twey> Aye.  Thanks.  âº
20:06:31 <Saizan> lpsmith: i'd say the first one..
20:08:06 <lpsmith> I don't like the minor inconsistency between the levelOrder'5 and levelOrder'' though
20:08:23 <lpsmith> sigh,  I'm just being a silly perfectionist :-)
20:09:21 <Saizan> well the inconsistency is in deq vs. deQ you can't solve that by juggling syntax alone
20:10:08 <Saizan> you could make deq's continuation take a Maybe
20:13:17 <lpsmith> that's true,  but I have to make a compromise between consistency with previous versions of levelOrder'N,  and not offering too many revisions where the difference is boring
20:13:41 <lpsmith> or rather,  those are reasons not to have deq return a maybe.
20:14:53 <lpsmith> I think I'm going to go with my third version,  although I'd probably just write it with do-notation
20:14:58 <lpsmith> if not for the context
20:16:33 <lpsmith> sohum,  sorry for interrupting the last discussion... somebody trying to implement Nibbles in Haskell?  :-D
20:16:42 * hackagebot upload: hakyll 0.1 - A simple static site generator library. (JasperVanDerJeugt)
20:20:11 <pa_> I'd like to see that code!
20:23:41 <lpsmith> osaunders:   you could use a persistent structure,  maybe an IntMap,   to represent an 80x24 screen.   That way when you "change" it,  the previous version is still around.
20:24:22 <lpsmith> Not a particularly efficient way of dealing with this problem,  but it's more than sufficient for the size proposed.
20:31:23 <Ferdirand> Baughn: well, almost true. The parentheses were a bit messed up
20:32:02 <Baughn> Ferdirand: Did you tell her to look at haskell? ^_^
20:32:39 <Ferdirand> Actually, I tried to convince the prof to switch :p
20:32:53 <Baughn> He didn't.
20:33:23 <Veinor> I need to put my package in hackage
20:33:27 <Ferdirand> No, but I can understand that. Too much work for that and not enough people
20:34:10 <Baughn> Ferdirand: Then the reasonable progression would be to talk to the particular student
20:37:15 <Ferdirand> Well, they were math and physics students. Most of them saw programming as a necessary evil
20:37:30 <lpsmith> Veinor:  do you have a hackage account yet?
20:37:39 <Ferdirand> at least I tried :)
20:51:43 <Phyx-> hello, Is there a cabal-install available that works with the 6.13 nightly? I'm unfortunately getting an error saying it can't parse the output of ghc-pkg
20:56:43 <Baughn> Phyx-: Does your current one work with 6.12?
20:57:07 <Baughn> Phyx-: The darcs version of cabal/-install should be fine, with 6.12 at lteast
20:57:50 <Phyx-> Baughn: no, it doesn't. hmm ok, i'll grab the one from darcs and try then. I need something they fixed in 6.12, so i just got the latest which was 6.13, but if i can find one that works in 6.12 it should be fine
20:58:18 <Phyx-> thanx
20:58:22 <Baughn> Phyx-: 6.12-rc2 is much more /useful/ than 6.13, in that libraries actually work with it. I'm using it for actual programming, with great success.
20:58:47 <Phyx-> oh, ok, i'll uninstall the 6.13 and use that one then cool
20:59:03 <Twey> When's 6.12 due out?
20:59:07 <Baughn> Twey: October
20:59:10 <ray> odd numbers are nstable
20:59:19 <Baughn> Twey: '09
20:59:29 <m3ga> its midnight here in .au. I just got back from a 40th birthday party. It was weird, there were only about 30 people there, but 4 of them were category theorists!
20:59:31 <Phyx-> Haskell time machine?
20:59:36 <Twey> Baughn: Haha
20:59:43 <Baughn> Phyx-: Just unsafeInterleaveIO
20:59:43 <Eftarjin> hi. Is there an IO function to read a password from the terminal without echoing it?
20:59:46 <Twey> m3ga: Nice :Ã¾
20:59:50 <Phyx-> Baughn: hahahaha
20:59:51 <Twey> Selection bias in action!
21:00:01 <ray> i can't walk down the street without bumping into category theorists
21:00:24 <m3ga> i thought  it must have been the homebrew i was drinking.
21:00:38 <Twey> Eftarjin: hSetEcho
21:00:47 <Eftarjin> Twey: thanks
21:01:09 <ray> hey does anyone else think the picture of grothendieck on wikipedia makes him look like malcolm x
21:05:20 <Saizan> like the wikipedia picture of malcolm x
21:08:20 <Veinor> lpsmith: no, I don't
21:11:02 <Veinor> how do I get one?
21:12:40 <lpsmith> Email ross@soi.city.ac.uk,  ask for an account
21:14:10 <lpsmith> veinor ^^^
21:14:16 <Veinor> thanks!
21:16:48 <lpsmith> Baughn,  no,  actually you do have to get the latest unreleased version of cabal and cabal-install with GHC-6.12
21:16:52 <m3ga> Twey: it wasn 't selection bias. the party was for a fiend on my wife's. both my wife and her friend studied law!
21:17:00 <Baughn> lpsmith: That's what I said
21:17:22 <lpsmith> Sorry,  misread :-D
21:17:59 <lpsmith> I'd like to know how to get GHC-6.12 to happily co-exist with GHC-6.10,   I haven't put a much effort into that though
21:18:45 <Veinor> I kind of want to learn category theory
21:19:28 <Veinor> does it have any practical applications? just curious
21:19:53 <lpsmith> Some people say yes,  others no.   Me,  I just don't know.
21:21:01 <lpsmith> I remember reading a joke article in an AMS journal from the mid-1980s,  about 25 generic questions to ask after a lecture to cover up the fact that you didn't pay attention or didn't understand
21:21:44 <lpsmith> One of the generic questions was:   Would rephrasing your results in terms of category theory reveal any insight.
21:21:48 <Veinor> The problem has been tantalising mathematicians since 1904, when Henri PoincarÃ©, a brilliant Frenchman, suggested there was an infallible rule for showing that an object is a sphere (see box below).
21:21:48 <Veinor> NO THIS IS NOT THE POINCARE CONJECTURE >:c
21:22:09 <lpsmith> And the answer was, supposedly,  no,  never.   Of course I'm butchering the joke.
21:22:48 <medfly> why do you need to ask questions after a lecture?
21:23:33 <lpsmith> Lecture meaning a special presentation/lecture/colloqium,  not really a class per se.
21:24:04 <Twey> m3ga: Huhâ¦ mysterious!
21:24:30 <lpsmith> Another one was "Didn't Gauss already prove this in one of his notebooks"... and the answer to than question is always yes.   :-P
21:25:07 <lpsmith> Baughn:  unsafePerformIO is overrated.   unsafeInterleaveIO is what all the cool kids are using :-P
21:30:34 <Baughn> lpsmith: Install GHC 6.12 in a different prefix than 6.10. Push whichever you want to use at the moment's $prefix/bin as the first element of your $PATH.
21:30:38 <Baughn> lpsmith: And that's it.
21:31:26 <ivanm> Baughn: you know, a really cool feature to add to haskell-mode would be to syntax highlight the *haskell* buffer... >_>
21:31:28 <ivanm> ;-)
21:31:56 <Twey> As opposed to what?
21:32:51 <Baughn> ivanm: Hmm
21:33:02 * Baughn decides to test that
21:34:27 * Phyx- wonders why the ghc installer doesn't set the correct paths under windows... it doesn't set the path to cc1 which causes hsc2hs to fail
21:35:18 <ivanm> ITSAFEATURE
21:35:19 <ivanm> ;-)
21:35:41 <Twey> ivanm: ;-)
21:36:18 <Phyx-> ivanm: lol
21:37:25 <eivuokko> Because it's not enough.  The non-standard install of gcc inside ghc requires you to use flags every time you invoke gcc.
21:37:54 <eivuokko> That's my guess, anyway.
21:39:41 <Phyx-> eivuokko: in this case, it would be enough, I mean, they ship with it, why do i need to explicitly specify where it is if it ships with it
21:40:35 <eivuokko> Because hsc2hs is supposed to be shared between compilers, and fixing this instance would mean tying it to ghc.  Or so I recall the reasoning went few years back.
21:42:48 <Twey> 101
21:43:22 <eivuokko> What you can do, is specify gcc on hsc2hs commandline, and additionally provide the (iirc) -B flag to it also.  Or maybe use cabal for building.
21:43:54 <eivuokko> I can't recall if it's actually easier to use ghc as c compiler.
21:45:55 <Eftarjin> does the stdlib have md5 like hashing functions?
21:46:09 <mauke> define "stdlib"
21:46:53 <voker57> no, use Crypto package
21:46:57 <Eftarjin> something in a libghc6-* packages of my distribution
21:47:10 <mauke> uh, that completely depends on your distribution
21:47:16 <voker57> Eftarjin: that's not stdlib... Prelude is
21:47:25 <voker57> maybe base
21:47:32 <mauke> voker57: I'd say the modules defined in H98 is
21:48:36 <Eftarjin> voker57: sorry for the misunderstanding then, iâll look into the crypto package
21:53:25 <visof> how can i apply filter to tuple type something like that : []
21:53:43 <Twey> You don't
21:53:47 <Twey> Tuples are not sequences
21:54:16 <visof> how can i apply filter to tuple type something like that : [(1,2), (3,4)] , want to get filter the tuple that snd element > 2
21:54:24 <visof> so i should get (3,4)
21:54:36 <weebl> last?
21:54:43 <mauke> > filter (\(a,b) -> b > 2) [(1,2), (3,4)]
21:54:44 <lambdabot>   [(3,4)]
21:55:02 <mauke> > filter ((> 2) . snd) [(1,2), (3,4)]
21:55:03 <lambdabot>   [(3,4)]
21:55:16 <visof> thanks
21:55:28 <eivuokko> filter ((>2).snd).  Ie for types (a,b), have b->Bool, and compose it with snd :: (a,b) -> b
21:57:28 <Twey> Ah, right, not a filter *on* tuples, but a filter on a list of tuples
21:58:32 <eivuokko> Yeah.  Maybe additional advice: think in types, ask questions with types. ;-)
21:58:52 <eivuokko> (of functions)
21:59:17 <Twey> (note that fst and snd only work on pairs, too)
22:00:06 <Twey> > map snd [(1, 2, 3), (4, 5, 6)] -- error
22:00:06 <lambdabot>   Couldn't match expected type `(a, b)'
22:00:06 <lambdabot>         against inferred type `(t, t1...
22:00:17 <Twey> Say, is â a comment marker with UnicodeSyntax?
22:01:12 <eivuokko> Which of the dashes is that?  I recall some linguist explaining to me that there's no good definition what dashes in unicode really mean.
22:01:37 <eivuokko> And which one the haskell comment is?  The "thought"-one?
22:02:47 <Phyx-> @package cabal2wix
22:02:48 <lambdabot> http://hackage.haskell.org/package/cabal2wix
22:03:14 <eivuokko> Is there such package? o.O
22:03:38 <eivuokko> Because...I wrote start of such utility few years back, didn't finish it, though.  Bamse has something similar.
22:04:00 <Phyx-> appears not.I just saw some reference to it on the mailing list archives
22:04:05 <Phyx-> and took a look
22:04:25 <eivuokko> That'd my posts to cabal-dev, I guess.  Best look into bamse.
22:05:43 <Phyx-> ok :)
22:06:56 <Phyx-> bbl
22:07:58 <eivuokko> ahf, Bamse requires com...I wonder if that install easily in Vista.
22:08:20 <eivuokko> Sorry, some autcompletion.
22:08:24 <chellomere> is there an easy way to output unicode text in a terminal? I've understood that haskell stores unicode characters correctly, but for example putStrLn truncates them to 8 bits
22:10:17 <mauke> quick and not that dirty solution: http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/System-IO-UTF8.html
22:28:02 <shapr> heippa hei eivuokko!
22:33:54 <eivuokko> 'lo
22:47:02 <chrisdone> mauke: what happened to preflex's poppavic nuggets of gold?
22:47:25 <mauke> they died when its first brain was lost
22:52:55 <loocker> hello
22:52:59 <loocker> !list
22:52:59 <Optimo> I syndicate the following:
22:53:00 <Optimo> iPodTVNova_Movies iPodTVNova_Television
22:54:30 <akioers> hey guys, can anyone help me?
22:54:50 <chrisdone> lambdabot: can haskell help akioers?
22:55:01 <chrisdone> @faq help
22:55:02 <lambdabot> The answer is: Yes! Haskell can do that.
22:56:59 <eivuokko> akioers, We can only show the way, you have to walk it.  Ask specific questions, please.
22:57:04 <ccasin> akioers: go ahead with your question, with 636 people in here, I'm sure one can answer it!
22:59:52 <akioers> how can i make a function that returns a askii picture?
23:01:39 <dbrock> haha
23:02:53 <gwern> akioers: call out to one of the ASCII art libraries, like libcaca
23:04:18 <akioers> hm..but the thing is..i have to do this function..then i have to do a couple of them to manipulate the picture...like rotate and mirror it
23:05:00 <chrisdone> rotating and mirroring a list of characters representing an ascii art picture is really easy
23:05:27 <Zao> chrisdone: Might be a bit tricky to construct mapping tables for the glyphs used though.
23:05:39 <c_wraith> chrisdone: unless the characters were chosen for what part of the box they fill
23:05:40 <gwern> this sounds like homework; so there must be some easy way to make the [String]
23:05:46 <gwern> (or String, actually)
23:05:59 <akioers> not for me..lol i'm studing this language for the first time =\
23:06:14 <chrisdone> akioers: what kind of rotation do you need?
23:07:28 <akioers> well..i need to rotate 90º, 180º and 270º then a mirror vertical and other horizontal..and t a negative one too
23:07:32 <chrisdone> akioers: individual glyphs or just the picture itself? to any degree or just by 90?
23:07:44 <chrisdone> right yeah, that's straight flipping of character positions, easy
23:08:01 <emile_m> Can someone explain me how "do" notation handles types in this case: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13634 ?
23:08:45 <c_wraith> emile_m:  there's nothing special about how do notation handles types.
23:08:54 <akioers> easy...for you lool
23:08:56 <emile_m> I understand why it doesn't complie in second variant.
23:09:23 <c_wraith> emile_m: a do block must have a type of Monad m => m a
23:09:24 <chrisdone> akioers: an easy algorithm in any language
23:09:34 <emile_m> c_wraith: I know, but it's not clear for me in this particular case.
23:09:39 <Veinor> http://img.alibaba.com/photo/10863323/Premium_Lambda_Premium_Juices.jpg
23:09:45 <Veinor> The official drink of haskell
23:09:56 <Saizan> emile_m: both the then and else branch must have the same type
23:10:09 <c_wraith> emile_m: everything else is just standard type inference
23:10:24 <eivuokko> emile_m, is that your translation of do-syntax? You need should have (if odd ... get) >>
23:11:11 <akioers> yeah..it must be easy then..but i can start with it
23:11:20 <emile_m> Ohh... sorry, it was a stupid question :)
23:11:29 <emile_m> eivuokko: Thanks.
23:11:36 <c_wraith> emile_m: easy mistake to make.  don't worry about it
23:12:13 <Veinor> types are like a new food: weird at first, but you learn to love them :D
23:12:34 <eivuokko> (Which is why we have compiler, it forces us to think about stupid stuff we want to do)
23:12:59 <Saizan> akioers: what type are you using from your ASCII art image? [[Char]]?
23:13:04 <Saizan> *for
23:13:17 <emile_m> Yes, I really miss such mighty type system in other languages like C++
23:13:33 <Veinor> ... I did a GIS for compiler and I found this.  http://www.flowerstorm.net/disa/Pictures/Compiler/animanga-compiler-ova2.gif
23:13:35 <chrisdone> akioers: some things that will help are: foldr, map, list comprehensions, reverse, any generally anything from Data.List
23:14:25 <akioers> yes..its like ["......",".####.", etc] for exemple
23:14:54 <gwern> Veinor: animanga compiler?
23:15:00 <Saizan> chrisdone: though flipping an ascii art image might not mean simply reverse each line, you might need to mirror each char
23:15:04 <gwern> what
23:15:37 <c_wraith> Saizan: I tried to point that out.  he didn't seem to believe it could matter
23:16:02 <Veinor> gwern: apparently it's an anime/manga with a character called compiler and another one called assembler
23:16:06 <Saizan> > reverse "   (           )   "
23:16:07 <lambdabot>   "   )           (   "
23:16:12 <gwern> Veinor: ouch
23:16:16 <Veinor> Saizan: well that's cheating :P
23:16:27 <Veinor> > reverse ":)"
23:16:28 <lambdabot>   "):"
23:16:45 <c_wraith> oftentimes ascii art chooses characters because of the space they fill.  If it does, reversing a line is wrong
23:16:46 <Saizan> yeah, so it's not that simple :)
23:16:53 <akioers> but i dont have that problem..the char's that are used it's only dots and #
23:16:57 <gwern> Veinor: not really. why should the () wind up as ()? should all the other characters like the 'a' be mirrored too?
23:17:17 <Saizan> akioers: ah, ok
23:17:27 <chrisdone> Saizan: c_wraith: akioers already explained, he's only flipping the *whole* image, rotating it by 90 degrees at a time. that's pure [Char] manipulation. doesn't care about individual characters
23:17:28 <c_wraith> gwern:  ascii art will often use () as a bubble, for instance.  )( isn't a bubble.
23:17:41 <Veinor> gwern: if you reverse "orz", a guy kneeling, naively, then you get "zro", which looks different
23:17:52 <Twey> > reverse "(---)"
23:17:53 <lambdabot>   ")---("
23:17:58 <c_wraith> chrisdone: that's nonsense.  Look at the example I just provided
23:18:01 <gwern> Veinor: and the right reverse would be?
23:18:04 <chrisdone> > reverse "####..####"
23:18:05 <lambdabot>   "####..####"
23:18:18 <fairweather> what is the name of the relationship f x y = (times x is evenly divisible by y)
23:18:24 <Twey> > map flipChar . reverse "(---)" where flipChar '(' = ')'; flipChar ')' = '('
23:18:25 <lambdabot>   <no location info>: parse error on input `where'
23:18:30 <Veinor> fairweather: I don't think it has a name
23:18:33 <eivuokko> Problem is that some of the information must not be reversed.  Like if you have .o(To be..)  It should be (To be..)o.  It's just not character-level problem.
23:18:38 <c_wraith> chrisdone: it turns out to not matter in this case because the input is limited, not because the transformations are limited.
23:18:42 <Twey> > let flipChar '(' = ')'; flipChar ')' = '(' in map flipChar . reverse "(---)"
23:18:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
23:18:43 <lambdabot>         against inferred ty...
23:18:48 <Twey> That limitation on âwhereâ is annoying
23:18:55 <Twey> > let flipChar '(' = ')'; flipChar ')' = '(' in map flipChar $ reverse "(---)"
23:18:56 <fairweather> well, that's a pity. I guess it will be lambda method then
23:18:56 <lambdabot>   "(* Exception: <interactive>:1:137-174: Non-exhaustive patterns in function...
23:19:04 <Veinor> fairweather: I think yo uhave to hand-write that.
23:19:12 <Twey> > let flipChar '(' = ')'; flipChar ')' = '('; flipChar c = c in map flipChar $ reverse "(---)"
23:19:12 <lambdabot>   "(---)"
23:19:16 <Twey> Not my day for Haskell today ;)
23:19:19 <Saizan> akioers: so, basically, you want to take the transpose of the matrix of characters each time, ever done that in linear algebra?
23:19:25 <chrisdone> c_wraith: yeah I surmised from the simplicity of his question he wasn't going to be translating '<' to '>'. sorry about that jump in logic
23:19:49 <akioers> nope
23:20:29 <Saizan> mh, not going to help then :)
23:20:32 <c_wraith> akioers: start with the easiest case, then, flipping on the Y axis
23:20:59 <c_wraith> akioers: actually, flipping on the X axis is probably easier, if the input type is [String]
23:21:10 <chrisdone> you're doing his homework for him
23:21:14 <Veinor> c_wraith: nah, flipping on the y-axis is easier >_>
23:21:23 <akioers> yeah..but it isnt
23:21:30 <eivuokko> Flipping on both is easy if you use arrays and map from indices to indices :-P
23:21:46 <c_wraith> chrisdone:  I'm not actually doing anything except suggesting a starting point. :)
23:21:47 <Veinor> but that'd be silly and non-functional!
23:21:58 <Saizan> depends if it's a list of rows or of.. how are the others called?
23:22:07 <h20xt> clear
23:22:08 <Zao> Columns.
23:22:10 <chrisdone> c_wraith: do you sometimes describe bits of a movie and then are confused when people complain about you spoiling it?
23:22:13 <Saizan> right.
23:22:29 <c_wraith> chrisdone: nah, people only complain when I spoil the end. :)
23:22:40 <chrisdone> :p
23:22:54 <Veinor> gwern: I don't think i can express the proper reverse in orz in ascii :P
23:23:02 <Veinor> er, of orz
23:23:05 <gwern> there you go then
23:23:24 <Veinor> also, are you gwern0@gmail.com? if so, can I have a haskell wiki account?
23:23:24 <Veinor> :D
23:24:02 <chrisdone> akioers: to reiterate: foldr, map, list comprehensions, reverse, and generally anything from Data.List
23:24:10 <chrisdone> akioers: play with them in ghci
23:24:23 <akioers> ok..i'll will try
23:24:34 <akioers> thanks for the help guys
23:25:03 <Saizan> i'd think of what you've to do first, though, what's the relation between the input and the output
23:25:15 <Saizan> in terms of your datastructure
23:25:24 <akioers> hmhm
23:25:25 <gwern> Veinor: only if you email me
23:25:36 <Veinor> aw. 'kay.
23:25:37 <gwern> Veinor: actually, I take that back, gwern0@gmail.com is my evil twin
23:25:51 <Veinor> :O
23:26:27 <c_wraith> when evil twins were being handed out, why didn't I get one?
23:26:38 <Veinor> so should I e-mail your evil twin or not?
23:27:02 <eivuokko> c_wraith, you blinked.
23:28:06 <Saizan> e.g. ["...","###"."..."] becomes [".#.",".#.",".#."] when rotated 90Â° degrees, it's not easy to convey the 2D-ness on irc though :)
23:28:25 <Veinor> it is, but then you get floodkicked ;)
23:30:42 <Saizan> (and btw there's a function in Data.List that does this, so you probably aren't allowed to use that module so liberally)
23:30:48 <Peaker> zip is like rotate + mirror
23:30:57 <eivuokko> I really think array lib is nice for showing linear transformations.  It's just not that good start for people new to haskell.
23:31:29 <mercury^> Which array library?
23:31:44 <eivuokko> The one in h98 should be sufficient.
23:32:13 <mercury^> What makes that library so good in illustrating linear transformations?
23:32:28 <eivuokko> Working on indices looks a lot like how some people write linear transformations in math.
23:34:02 <mercury^> I do not know what you mean, but if it is just the point that you can write linear transformations of finite dimensional vector spaces as matrices: that can be used to model linear transformations in many languages.
23:34:23 <eivuokko> I didn't mean matrices at all :)
23:34:43 <mercury^> Can you give some example of what you meant please?
23:34:47 <Saizan> mercury^: it was just a matter of Array (Int,Int) a vs. [[a]] to describe matrices
23:35:03 <Philonous1> Most mathematicians I know wouldn't touch indices with a stick
23:35:10 <Saizan> not that Data.Array is particularly good, just that arrays let you use indices more easily
23:36:08 <Saizan> (matrices to be linerarly transformed, like in this case rotated, not to be used to describe linear transformations)
23:38:55 <Saizan> though to deal with indices an haskell list comprehension is nicer than C for loops :P
23:39:52 <mercury^> So what eivuokko meant is that arrays are nice if you want to use indices. I can agree with that, because the access is a constant time operation.
23:40:56 <chrisdone> I've got a nice problem I'm doing now. given a grid of filled squares, generate rectangles to encompas adjacent squares. so [ ][ ] [ ][ ] becomes [   ] [   ]
23:41:02 <eivuokko> And if you use indices, you can often actually forget it's a discrete thing being done...
23:41:17 <Twey> 15:35:28 < Philonous1> Most mathematicians I know wouldn't touch indices with a stick
23:41:24 <Twey> Hmm?
23:41:38 <eivuokko> Well, nevermind, you don't agree, I see.  To me it looks a lot like how it's sometimes written down.
23:41:42 <Twey> Indices as inâ¦ array indices?
23:41:43 <Saizan> and Data.Array has an API geared towards the use of indices, Data.List doesn't
23:42:03 <Philonous1> Twey: Yes.
23:42:13 <Twey> Why?  :Ã¾
23:42:55 <mercury^> Because indices clutter and there are often more conceptual ways to express yourself
23:43:44 <Saizan> my course on linear algebra had lots of indices all over the place, but i guess at higher levels they'd rather multiply by the appropriate vector or so..
23:44:07 <poe> The abudance of indices makes it easy to make errors.
23:44:27 <Philonous1> Twey: Using indices means you are missing a greater point, I guess. They define a transformation once via indices (if they have to) and then are done with it
23:45:51 <Saizan> yeah, you define transpose once and then you import Data.List, unless it's an exercise :)
23:46:45 * Saizan wonders if they have a @pl to golf transformations
23:47:52 <poe> I guess the idea is that they teach you @pl :)
23:49:02 * Saizan now understands why his numeric analysis professor didn't make much sense
23:49:13 <mercury^> So, using transposition as example: for real vector spaces, transposition is the adjoint operation. And adjoints are the important concept, not the particulars of the transposition.
23:49:20 <Saizan> he was speaking via @pl!
23:50:11 <Philonous> polish notation?
23:50:29 <Saizan> adjoint as in CT adjoints? if so, to what?
23:51:18 <mercury^> Saizan: adjoints as in operator adjoints.
23:54:44 <poe> another definition of the transpose is the dual map
23:55:40 <seekerwjk> finally get here
23:55:53 <poe> since we like CT, that is the contravariant functor from the category of vector spaces over a field to itselg
23:59:16 <mercury^> poe: again, only for finite dimensional real vector spaces.
