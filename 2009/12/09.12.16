01:31:59 <Neun_> ping
01:31:59 <gogonkt_> PONG, now at #haskell
01:33:42 <kmc> @botsnack
01:33:42 <lunabot>  :o
01:33:43 <lambdabot> :)
01:37:21 <Jafet> >erf q
01:37:33 <Jafet> > erf 1
01:37:34 <lambdabot>   0.45289326062822355
01:37:43 <kmc> > unf
01:37:45 <lambdabot>   Not in scope: `unf'
01:44:43 <o-_-o> @help
01:44:43 <woodlog> I could not find any information on '', o-_-o
01:44:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:44:51 <o-_-o> @list
01:44:52 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:47:43 <quicksilver> ping
01:47:43 <gogonkt_> PONG, now at #haskell
01:47:59 <quicksilver> gogonkt_: please disable all autorespond scripts in public channels. Well in this one at least.
01:48:04 <kmc> looks like we got a bot infestation
01:48:08 <kmc> ping
01:48:09 <gogonkt_> PONG, now at #haskell
01:48:13 <kmc> > "ping"
01:48:15 <lambdabot>   "ping"
01:50:57 <kmc> @see
01:50:57 <lambdabot> Maybe you meant: free let src
01:51:04 <kmc> @help foo
01:51:04 <woodlog> I could not find any information on 'foo', kmc
01:51:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:51:13 <mjk> in haskell how to show chinese?
01:51:32 <Jafet> > let chinese = 1 in show chinese
01:51:33 <lambdabot>   "1"
01:51:34 <kmc> mjk, Haskell's Char type supports Unicode
01:51:36 <kmc> show where?
01:51:39 <mjk> for example:putStr " Ææ≈ ¿ºÕ"
01:52:16 <Saizan> mjk: source files needs to use utf8 as encoding
01:52:18 <kmc> mjk, that comes through as garbage here.  i think my client supports utf8 -- what encoding is that?
01:52:26 <mgee> hi, how can i catch a "fail" in haskell? (i am refering to the "fail :: Monad a => String -> a b" function...)
01:52:32 <quicksilver> well, haskell's char type supports unicode but putStr doesn't, until GHC 6.12
01:52:35 <kmc> mgee, depends on the monad
01:52:41 <mjk> Saizan: yes, saved as utf8
01:52:43 <quicksilver> and I'm guessing that mjk doesn't have HC 6.12
01:52:49 <kmc> typically if the monad is a MonadPlus then you can use mplus
01:52:49 <Jafet> By "Unicode" here I think we all mean UTF-8
01:52:58 <kmc> Jafet, i sure don't
01:52:58 <mjk> quicksilver: 6.12
01:53:03 <mgee> kmc: I think the monad is IO
01:53:08 <quicksilver> ah. On 6.12 it should 'just work'
01:53:14 <mjk> download it yesterday
01:53:18 <Saizan> quicksilver: if the locale is utf8 too
01:53:20 <kmc> mgee, look at Control.Exception
01:53:27 <mgee> kmc: thanks will do
01:53:37 <Jafet> Well, many other programs do.
01:53:37 <quicksilver> Saizan: or if he's on windows, in which case it uses window's borked version of utf16, I suppose
01:54:01 <kmc> "Unicode" and "UTF-8" are two different kinds of thing
01:55:01 <mjk> Saizan: i save the file as UTF-8,EDITOR is editplus
01:55:22 <mjk> winxp
01:55:43 <Zao> quicksilver: I thought they'd moved to proper UTF-16 since NT4 or so?
01:56:03 <Jafet> mjk, how are you attempting to "show" wtf-8 text?
01:56:15 <Jafet> Errrm, Freud struck again
01:56:31 <mjk> Jafet: wtf-8?
01:56:46 <c_wraith> freudian slip. :P
01:56:55 <Jafet> utf-8.
01:56:58 <Saizan> mjk: so you've a |main = putStrLn "something with chinese characters here"| and it compiles, but then outputs garbage?
01:57:26 <Jafet> What are you viewing the program output in?
01:57:28 <Saizan> (where | .. | are just for separating code)
01:57:30 <mjk> Saizan: yes
01:58:39 <Saizan> (am i wrong or everything that used utf8-string is broken on ghc-6.12 with an utf8 locale?)
01:58:55 <quicksilver> Saizan: I think so, yes, unless someone uploads a magic trick playing utf8-string)
01:59:11 <kmc> the Data.Text library, on GHC < 6.12, does UTF-8 IO
01:59:16 <quicksilver> Saizan: because utf8-string did obviously type-unsound, but pragmatic, things like encode :: String -> String
01:59:23 <mjk> can compile the .hs file
01:59:35 <Cale> @let erf x  | x < 0 = - erf (-x)  | otherwise = 1 - sum [a / (1 + p*x)^n | (n,a) <- zip [1..] as] * exp (-x^2) where p = 0.3275911; as = [0.254829592, -0.284496736, 1.421413741, -1.453152027, 1.061405429]
01:59:36 <lambdabot>  Defined.
01:59:41 <quicksilver> Saizan: presumably utf8-string needs to use the same compatibility trick that Data.IO does.
01:59:46 <mjk> and can run,but the result is garbage
02:00:04 <Cale> > (2 / (deriv erf 0))^2
02:00:06 <lambdabot>   3.141552612266782
02:00:19 <kmc> mjk, are you running in a terminal? what Unicode encoding is the terminal set up for?
02:00:51 <kmc> what does putChar do with Unicode on pre-6.12?  does it always use utf8?
02:01:06 <Saizan> no, it just truncates the Char
02:01:11 <kmc> yuck
02:01:14 <mjk> kmc: use terminal
02:01:23 <mjk> i try to set up
02:01:26 <mjk> to chinese
02:01:34 <Jafet> Windows has a terminal now?
02:01:37 <mjk> yes
02:01:44 <kmc> it has had one for a long time
02:01:52 <kmc> it's astoundingly bad, i always preferred PuTTY to localhost
02:01:53 <c_wraith> wait, setting it to chinese sounds wrong.
02:01:56 <Jafet> I mean a real one
02:02:09 <c_wraith> wow, kmc.  putty is pretty awful, too.
02:02:12 <kmc> mjk, perhaps you should set your terminal to utf-8, and use a Haskell library such as utf8-prelude
02:02:15 <kmc> c_wraith, how so?
02:02:30 <kmc> mjk, like this:  http://hackage.haskell.org/package/utf8-prelude
02:02:43 <kmc> mjk, GHC 6.12 supports Unicode IO better, but was just released yesterday and lacks library support
02:03:04 <Saizan> utf8-prelude with ghc 6.10
02:03:25 <Jafet> rxvt does utf-8 out of the box
02:03:26 <mjk> maybe the problem of locale on my computer
02:03:40 <Saizan> mjk: you should find out which locale ghc is seeing
02:03:48 <mjk> page code is 936
02:04:14 <c_wraith> kmc: Well, as a terminal, it's fine.  But as an app, it has the worst interface I've seen for a GUI terminal emulator.  It's like it went out of its way to be unfriendly
02:04:25 <Jafet> I thought that utf-8 is a locale, and once you use it for everything you are done.
02:04:36 <Jafet> c_wraith, it was developed expressly to play nethack
02:04:47 <kmc> Jafet, as long as your apps are producing and consuming utf8
02:04:49 <c_wraith> So I should think in vi keys?
02:04:59 <Jafet> And nethack doesn't have the best of interfaces either
02:05:14 <c_wraith> (I've spent an hour playing slash'em tonight. :)
02:05:32 <Jafet> kmc, and the terminal, too, but mjk seems to think there is a "chinese locale" or "code page" he needs
02:05:50 <c_wraith> code pages are such a horrible idea.  way to go, microsoft.
02:06:22 <Jafet> They worked fine until the Asians became rich enough to buy computers
02:06:23 <kmc> yeah, code pages are pre-unicode
02:06:38 <kmc> mjk, can you set your terminal to UTF-8?
02:06:59 <mjk> can't set it to UTF-8
02:07:09 <c_wraith> then why do you expect output to render properly?
02:07:21 <Jafet> .oO(Long ago when I had to print chinese characters in windows terminal, I used to paste the characters into Word, which would translate them into the default code page, and then copy them out into the program source)
02:07:31 <kmc> mjk, as far as i know there is no Haskell library for working with Microsoft's pre-Unicode code pages
02:07:58 <quicksilver> I assumed GHC 6.12 was supposed to account automatically for code pages
02:08:02 <Saizan> c_wraith: on 6.12 ghc is supposed to work with the current locale, no?
02:08:08 <quicksilver> surely it uses the win32 output functions
02:08:15 <mjk> getLine can get a chinese string from tereminal
02:08:27 <mjk> and can show it correctly
02:08:34 <c_wraith> mjk: getLine isn't reading it as UTF-8
02:08:48 <c_wraith> mjk: getLine is reading it as whatever your terminal is giving it as.
02:08:51 <Saizan> mjk: what happens if you print out that same String?
02:09:10 <mjk> magic string
02:09:20 <kmc> PuTTY can do UTF8
02:09:37 <Jafet> @google make windows terminal use UTF-8
02:09:39 <lambdabot> http://download.microsoft.com/download/1/6/1/161ba512-40e2-4cc9-843a-923143f3456c/StandardizingOutOfBandManagementConsoleOutput090.doc
02:09:49 <mjk> i try PuTTY
02:09:51 <kmc> great a fucking .doc file
02:09:55 * kmc gives MS the finger
02:10:08 <Jafet> Way to go, Microsoft!
02:10:57 <Saizan> this might be something to report to the ghc-users@ mailing list
02:11:30 <mjk> i will redo it
02:12:59 <Saizan> one could "print (map ord stringFromGetLine)" to check if it's decoding properly
02:13:23 <mjk> Saizan: ok
02:13:34 <mjk> thank all
02:16:35 <Jafet> Fuck unicode, luse English!
02:16:47 <mjk> Jafet: hehe
02:21:19 <mgee> is it possible to exit a haskell function before it gets to the end? I have an IO (...) function and I am catching an error in the middle of the function. if there is an error i want to exit the function with some value. if there is no error i want the function to continue. I know i could do it with a case or if statement but then i would have to indent the the of the function. this is especially painful when there are more error handler and every one would
02:21:20 <mgee> increase the indention level...
02:21:26 <notweebl> ctrl-c?
02:21:59 <mgee> notweebl: Seriously? ;)
02:22:04 <notweebl> :P
02:22:15 <mgee> notweebl: I don't want to exit the whole program, only the current function
02:24:12 <c_wraith> mgee: is it not feasible to just catch the error at a higher level?
02:24:36 <kmc> mgee, functions don't "exit" as they don't run as a sequence of steps
02:24:55 <kmc> anyway a value of type "IO a" is not a function
02:25:00 <kmc> it's an IO action
02:25:07 <mgee> mhh ok, seems like i have to catch the error as early as possible and then use an if-statement
02:25:18 <idnar_> kmc: I'd suggest breaking your do block up more, so that the if/case/whatever isn't as awkward
02:25:31 <c_wraith> why not just catch the error at a higher level?
02:25:44 <mgee> c_wraith: will try :)
02:26:28 <kmc> mgee, you could use the ContT continuation monad transformer
02:27:15 <kmc> continuations are absolutely mind-bending
02:27:21 <kmc> and may be overkill for something relatively straightforward like this
02:27:49 <mgee> kmc: yeah i think to too. but thanks for the suggestion
02:28:00 <kmc> i agree about catching the error higher up
02:28:06 <kmc> or build helper functions / actions
02:28:25 <kmc> remember that IO actions are totally first class; you can pass and return them from other functions, and choose when and whether to sequence them together
02:28:35 <Saizan> or catch the error on the spot and rethrow it as an another error easier to catch higher up
02:28:36 <kmc> that's why Haskell is the best imperative programming language ;)
02:32:28 <kmc> the problem with adding an early-exit action to IO is in making it well-typed
02:33:16 <kmc> if you have "nonLocalRet a >> ... >> ... >> return b", you want that a and b have the same type, but that's not expressed in the types of the subexpressions, which are just "IO t" for some t
02:33:33 <kmc> ContT packages all the machinery for doing this right in such a way that it can be used with other monads
02:34:33 <kmc> (except its callCC is insufficiently polymorphic... grr)
02:35:33 * kmc notes that http://www.haskell.org/ghc/docs/latest/html/libraries/ is a lot less useful now
02:35:48 <kmc> is there a page linking haddock of every module of every package in Platform?
02:36:13 <quicksilver> mgee: funnily enough IO doesn't support early exit per se.
02:36:19 <quicksilver> ah, he's gone.
02:36:22 <quicksilver> there he is!
02:36:23 <quicksilver> mgee: funnily enough IO doesn't support early exit per se.
02:36:33 <mgee> :)
02:36:35 <quicksilver> mgee: although you can throw an exception and then catch it in a wrapper
02:36:43 <quicksilver> which is isomorphic to early exit.
02:36:47 <mgee> yeah, I miss that :)
02:36:52 <quicksilver> You can also use ErrorT IO or MaybeT IO
02:37:03 <quicksilver> which build early exit functionality on top of IO
02:37:05 <kmc> exceptions are sort-of dynamically typed, for the reason i gave above
02:37:21 <kmc> or you can use ContT and tie your brain into a knot :)
02:37:39 <quicksilver> I think I should modify my statement.
02:37:40 <kmc> but yes ErrorT is more reasonable, that's a good suggestion
02:37:47 <quicksilver> IO does support early exit - that's what exceptions are.
02:37:54 <quicksilver> it's just a marginally clumsy operation in practice
02:38:01 <quicksilver> but wrap it with a couple of nice combinators and it's OK.
02:39:13 <mgee> quicksilver: I thought of a keyword like: "cancel" with the return value as the function ;)
02:39:27 <mgee> the same return value as the function it is used in
02:40:48 <quicksilver> yes, you can do that.
02:41:02 <quicksilver> make "cancel x" throw a CancelException x
02:41:12 <kmc> mgee, the return value of the function is an IO action.  you're probably more interested in the *result* value of *executing* that action
02:41:17 <quicksilver> and then wrap your function in a wrapper which catches that exception and returns the result
02:42:31 <kmc> a function like "a -> IO b" is not a side-effectful function.  it's a pure function that returns a side effect, which the caller can choose to execute or not
02:43:45 <kmc> :t let loeb x = fmap ($ loeb x) x in loeb
02:43:47 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
02:47:06 <kmc> i suppose you could define this "cancel" keyword by desugaring to nested conditional, but i don't think you can implement it as an ordinary function
02:48:56 <quicksilver> you can if you're also happy to wrap the whole action
02:48:58 <kmc> that'd be a little extreme as currently the only monad-related keyword is "do"
02:49:02 <quicksilver> two-part solution not a single one
02:49:13 <quicksilver> just make 'cancel' throw
02:49:18 <quicksilver> and wrap the action in a catcher
02:49:31 <mgee> seems like a good solution
02:49:35 <quicksilver> to be honest it's cleaner to use ErrorT because you can't forget to wrap it
02:49:39 <quicksilver> because it has a different type :)
02:49:47 <mgee> ;)
02:50:03 <quicksilver> you can forget to wrap IO a because it just looks like IO a, but ErrorT e IO a you obvioulsy have to wrap with runErrorT
02:50:09 <kmc> yeah, the exception solution gives up some static typing
02:50:26 <quicksilver> :t runErrorT
02:50:28 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
02:50:42 <quicksilver> :t fmap (either id id) . runErrorT
02:50:44 <lambdabot> forall b (f :: * -> *). (Functor f) => ErrorT b f b -> f b
02:51:05 <quicksilver> :t liftM (either id id) . runErrorT
02:51:06 <lambdabot> forall b (m :: * -> *). (Monad m) => ErrorT b m b -> m b
02:51:11 <kmc> :t fromEither
02:51:12 <lambdabot> Not in scope: `fromEither'
02:51:12 <quicksilver> that's what you want.
02:51:26 <quicksilver> "either id id" just projects the left and right branches together
02:51:31 <quicksilver> which forces them to be the same type
02:51:36 <quicksilver> (which is what you wanted, here)
02:51:38 <kmc> :t either id id
02:51:39 <lambdabot> forall b. Either b b -> b
02:51:46 <kmc> @pl either id id
02:51:46 <lambdabot> either id id
02:53:30 <quicksilver> then the type system will force you to make sure the 'cancel' you send is the same type as the final type of the action
02:53:40 <quicksilver> although admittedly if you get it wrong I fear the error message will be bizarre :)
03:00:14 <pozic> I seem to recall that ContT didn't compose with all the monads in MTL. I just don't remember which ones. That is that there are some missing instances, because they cannot be defined for some reason. Can anyone tell me which ones they were?
03:00:27 <edmoore> more of a compsci question (and a stupid one at that) but I was wondering if there is an optimal sorting algorithm for a set of 4 elements (i.e. a very small set)?
03:01:05 <sinelaw> probably insertion sort
03:01:16 <sinelaw> i mean, just writing out the condition
03:01:32 <sinelaw> never mind.
03:01:35 <c_wraith> at 4 elements, you could just write an awful huge expression
03:04:35 <HaskellLove> yo guys what is going on with euler project?
03:05:14 <MoALTz> ?
03:06:25 <HaskellLove> it is down
03:06:36 <quicksilver> pozic: there is certainly a bug in one of the instances.
03:06:50 <quicksilver> pozic: is it ContT StateT == StateT ContT but that's not what it should do?
03:06:53 <quicksilver> something like that.\
03:07:23 <quicksilver> edmoore: yes, the optimal sorting algorithm for small sets is to write out all the cases.
03:07:52 <quicksilver> and arrange them in the order to get the minimum number of compares.
03:08:00 <quicksilver> not much fun :)
03:08:04 <edmoore> quicksilver: ok thanks, that's what I've done, I just felt a little dirty doing it with a bunch of conditionals ;)
03:08:29 <pozic> You can also write a program which enumerates all programs and select the fastest one. For 4 elements, that should work.
03:08:58 <pozic> More fun, but depending on programming language can take longer to implement ;)
03:09:16 <edmoore> Currently matlab!
03:09:19 <pozic> Haskell is a poor choice for doing things like this.
03:09:33 <mgee> have to go. thanks for all your help :)
03:09:52 <edmoore> just trying to sort out a baysian signal processing algorithm before I port it.
03:10:09 <HaskellLove> yo guys what is going on with euler project?
03:10:11 <o-_-o> dons is don stewart ?
03:10:41 <edmoore> I sort of want to have a go at this with haskell because of its inherent portability (bayesian sig proc being an awful lot of data parallelizable comparisons) but I think I may just have to stick with C
03:10:44 <quicksilver> o-_-o: yes
03:10:56 <o-_-o> ok
03:11:08 <edmoore> s/portability/parallelizability
03:12:02 <Jafet> Haskell isn't that great with parallelization yet
03:12:40 <Jafet> Then again, C isn't either...
03:13:11 <kmc> Jafet, what flaws do you refer to?
03:13:34 <Cale> Well, it's certainly not bad, but it's going to be better.
03:14:28 <Cale> I'd say that GHC has pretty decent SMP support as far as programming languages that actually exist go. :)
03:14:37 <Jafet> Implementation-wise
03:14:38 <Jafet> edmoore, you just want a parallel sort?
03:15:30 <edmoore> Jafet: I was going to use C with GPU libraries
03:15:33 <edmoore> like OpenCL
03:15:40 <Jafet> Cale, well, it could take much better advantage of the fact that haskell is a pretty language
03:18:58 <pozic> Why doesn't newtype deriving work when you hold a value of the same type as you are currently defining as a piece of state (cf. StateT s)?
03:19:26 <pozic> Or in general, how do you store continuations in a way such that newtype deriving does work?
03:20:47 <pozic> When I replace (FooT params) by Int as the parameter, it compiles fine. I just want to have the same instances that are defined asif it was Int in the case of (FooT params).
03:22:09 <yitz> HaskellLove: project euler looks fine from here
03:22:36 <HaskellLove> why do i get this If you are seeing this page, you are on the old server. Try clearing your browser cache and restarting your modem/router. Or you can open Command Prompt, and type in: ipconfig /flushdns Then retry. Thanks
03:22:37 <zygoloid> pozic: what does your newtype look like?
03:23:17 <yitz> HaskellLove: are you on windows?
03:25:25 <pozic> zygoloid: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14298#a14298
03:26:20 <pozic> HaskellLove: it means that you are directed to the wrong IP.
03:26:42 <HaskellLove> pozic>	yitz>	what should i do, i am on ubuntu
03:26:54 <pozic> HaskellLove: just hitting Refresh might already work.
03:27:14 <HaskellLove> it does not
03:27:29 <HaskellLove> and i deleted cookies stuff an browser history
03:27:41 <pozic> HaskellLove: the problem is that the mapping DNS -> IP is out of date.
03:27:46 <pozic> HaskellLove: I will have a look.
03:28:12 <HaskellLove> pozic thank you, let me know as soon as possible i am competing with another guy for euler
03:28:27 <pozic> HaskellLove: /etc/rc.d/init.d/nscd restart
03:28:40 <pozic> HaskellLove: as root or sudo.
03:28:47 <HaskellLove> what it is that
03:29:01 <HaskellLove> enter this in command line?
03:29:02 <quicksilver> pozic: Oh, I see. Yes newtype deriving doesn't support recursive newtypes. There is a reason why but I don't recall what it is.
03:29:03 <pozic> HaskellLove: that flushes the DNS cache.
03:29:55 <pozic> quicksilver: is there another way to do these kinds of continuations then? It seems a lot of work to implement about 8 instances.
03:30:19 <pozic> quicksilver: I can also rewrite the code so that it does not use continuations, but that's unnatural.
03:30:21 <Saizan> maybe it works if you newtype FooT r m a?
03:30:34 <HaskellLove> pozic>	there is no folder as rc.d, but there are rci.d where i goes from 0 to 6
03:30:48 <quicksilver> pozic: I think the reason is that it can lead to undecidable instances.
03:31:04 <zygoloid> quicksilver: the reason is that it's cautious about creating instances: "instance Foo (A B) => Foo B" i think
03:31:11 <quicksilver> pozic: see SPJs' comment on http://hackage.haskell.org/trac/ghc/ticket/1133 . The ticket is not relevant to your problem but SPJ's comment is.
03:31:19 <quicksilver> zygoloid: yes, because that's undecidable
03:31:22 <quicksilver> zygoloid: (in GHC speak)
03:31:31 <pozic> HaskellLove: ok, "sudo restart nscd"?
03:31:32 <quicksilver> zygoloid: it can lead to an unbounded search path.
03:31:50 <zygoloid> quicksilver: right, i hit enter before your 'undecidable instances' message made it to my brain ;-)
03:31:55 <HaskellLove> pozic restart: command not found
03:32:22 <pozic> HaskellLove: that is for karmic.
03:32:52 <pozic> HaskellLove: sudo /etc/init.d/nscd restart?
03:33:04 <pozic> HaskellLove: that might also work.
03:34:01 <zygoloid> it might be nice if newtype deriving synthesized the instance head and checked it for decidability, rather than just assuming it's undecidable
03:34:58 <pozic> So, I should be able to copy the definition of the whole newtype into the place holder?
03:35:23 <pozic> That's not recursive and almost does what I want, but it is basically a hack.
03:35:52 <zygoloid> pozic: you can generalize it to a non-recursive case and then take the fixed point to recover your type
03:36:27 <pozic> zygoloid: can you demonstrate that?
03:36:49 <pozic> Ah, I understand the first step.
03:37:07 <zygoloid> pozic: "newtype FooT' fooT r m a = FooT (... (fooT r m a) a); type FooT r m a = FooT' FooT r m a"
03:37:08 <pozic> Taking the fixed point is another newtype?
03:37:23 <Saizan> pozic: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14298#a14299 ?
03:37:32 <zygoloid> hmm, yeah, you probably want newtype rather than type, so you won't be able to use newtype deriving ;(
03:37:57 <zygoloid> damn that occurs check
03:38:08 <Saizan> you'd need to wrap/unwrap the continuations, but it's not that bad i think
03:38:56 <pozic> Saizan: no, that's ok. Still, I feel these things should be easy and not require any thought.
03:39:04 <pozic> Saizan: I will try that.
03:39:47 <Saizan> yeah, the deriver could be a little smarter here
03:40:57 <pozic> Saizan: It doesn't appear to work?
03:40:58 <quicksilver> zygoloid: if you do that, you can do the deriving for the non-recursive part but you still can't do it for the 'Fix' bit surely?
03:40:59 <zygoloid> pozic: it looks like you can trick the newtype check by splitting your type into a pair of recursive newtypes
03:41:10 <quicksilver> now that is clever :)
03:41:29 <zygoloid> quicksilver: clever but scary. newtype deriving can create undecidable instances that way
03:41:43 * zygoloid watches his three line program hang
03:41:59 <bastl> Saizan: You pointed me to "Rec Types for Free" yesterday. I'm studying it, and a) dont get along with the type of fold and b) probably found some typos in the fold-examples in the sec. "LFPs as weak initial algebras". he forgets to apply "in" to "inl ()" etc. "inl ()" is of type F T, but fold operates on T.
03:42:20 <Saizan> pozic: it was an untested proposal :)
03:42:27 <quicksilver> zygoloid: BUG BUG BUG BUG BUG BUG BUG
03:43:05 <zygoloid> quicksilver: so far i've only managed to get a hang at runtime :-/
03:45:40 <Saizan> bastl: the type of fold is the same as the type of a generic catamorphism
03:46:00 <Saizan> bastl: well, the catamorphis for F, actually
03:47:10 <Saizan> bastl: the trick here is that as usual in lambda calculus we represent things using the type of their eliminators
03:47:37 <Saizan> bastl: so fold only needs to pass the arguments to the fixed point
03:48:10 <zygoloid> quicksilver: but the behaviour /is/ different from the behaviour you get when writing the instances out manually...
03:49:17 <HaskellLove> pozic i got jaunty
03:49:33 <bastl> Saizan: i'd like to understand catas in terms of morhpisms. (fold X k) is the initial morphism from (T,in) to F-Algebra (X,k) right? How can i apply a member of the fixpoint ( t:T ) to arguments X and k? especially when X is a type itself?
03:49:44 <quicksilver> zygoloid: hmm
03:49:53 <HaskellLove> pozic it did not work, maybe another command
03:50:23 <Saizan> bastl: right, it is that morphism
03:50:24 <bastl> I think of t as a value. But probably i should think of it as a function ...
03:50:58 <Saizan> bastl: the application of X and k to t is allowed because of the representation for fixpoints that we've used
03:51:05 <zygoloid> quicksilver: i guess it's just constructing a dictionary where every member is constructed from itself plus some casts...
03:51:18 <Saizan> bastl: it's not something you can describe in the category of F-algebras
03:52:59 <bastl> Hmm unsatisfying. What Did you mean by "representing things using the type of their eliminators" ?
03:53:04 <pozic> HaskellLove: just google for ubuntu flush dns cache.
03:53:31 * bastl has little background in type-theory ...
03:53:45 <bastl> rather no background ...
03:54:11 <Saizan> bastl: e.g. you represent a pair (A,B) using values of type "forall r. (A -> B -> r) -> r"
03:54:23 <etpace> Is there an interleave function for lists? so interleave [1,2] [3,4] is [1,3,2,4]?
03:54:41 <Saizan> bastl: or Either A B as forall r. (A -> r) -> (B -> r) -> r
03:55:00 <Saizan> bastl: continuation-passing style, if you want
03:55:21 <Saizan> bastl: a list would be forall r. r -> (a -> r -> r) -> r
03:55:45 <Saizan> because the second field of (:) is a recursive occurrence
03:56:04 --- mode: irc.freenode.net set +o ChanServ
03:56:32 <Saizan> bastl: i guess understanding both the CT part and the church encoding at once might be confusing :)
03:56:51 <bastl> :-)
03:57:10 <pozic> Anybody with a different idea?
03:57:48 <bastl> I came to haskell, because I wanted to do something  more applied than CT. Now theory strikes back :-)
03:57:54 <zygoloid> pozic: have you tried using two corecursive newtypes?
03:58:33 <Saizan> bastl: if we define newtype Fix f = In {out :: f (Mu f)} we've "fold f = f . fmap (fold f) . out" instead
04:00:19 <bastl> yeah, that matches my chasing of the diagram (2)
04:00:28 <pozic> zygoloid: yes
04:00:39 <bastl> thinking out = in^-1
04:00:46 <pozic> zygoloid: well, mutally recursive.
04:01:04 <pozic> zygoloid: not corecurive. I am not sure what that means in this context.
04:01:12 <pozic> recursive*
04:01:47 <zygoloid> pozic: i meant mutually recursive. what went wrong? it seems to work in my tests here...
04:03:03 <pozic> zygoloid: maybe your tests are not the same. Can you paste?
04:03:11 <Saizan> bastl: yes, the diagram says fold f . In = k . fmap (fold f)
04:03:47 <HaskellLove> is euler project down for me only, anyone else? :(
04:03:57 <bastl> But it doesnt help to much, if I dont understand the def. of fold given there.
04:05:01 <Saizan> bastl: fold doesn't do much, it just passes the continuation to t, it's more interesting what in does with the continuation
04:06:12 <bastl> HaskellLove: i can access the main page and the problems. Seems to work.
04:07:44 <Saizan> in s k = k (fmap (fold f) s)
04:08:01 <Saizan> in s k = k (fmap (fold k) s)
04:08:13 <Saizan> if we remove the type arguments
04:10:24 <bastl> ah, the latter sounds interesting for me: simply forget about the type argument X, since it only passes the "forall" statement? Can I see it like that?
04:11:02 <Saizan> yeah
04:11:40 <Saizan> in System F you've type abstraction and application at the term level, in haskell they are implicit (but not as expressive)
04:14:05 <bastl> ok
04:14:36 <Saizan> http://knol.google.com/k/edward-kmett/catamorphisms# <- this is in haskell, but it has less content, though i'm not sure at this point what you wanted to know initially :)
04:15:07 <bastl> perhaps only reflect what i've learned so far...
04:24:51 <cbuh> Hello fellows!
04:26:09 <cbuh> I'm new to haskell and functional programming at all, I try to write a reverse' funciton like this:
04:26:17 <cbuh> reverse' :: [a] -> [a] -> [a]
04:26:23 <cbuh> reverse' [] y = y
04:26:25 <cbuh>  reverse' (x:xs) ys = reverse' xs x:ys
04:27:11 <cbuh> And this is the error text: Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for `reverse''
04:27:24 <cbuh> What I miss in code?
04:27:24 <ivanm> cbuh: why are you writing "[] y" ?
04:27:38 <ivanm> actually, why are you writing reverse with that kind of signature?
04:28:15 <cbuh> ivanm: it is an edge cond.
04:28:26 <ivanm> cbuh: I meant why are you doing this?
04:28:31 <RichardO> reverse' xs (x:ys)
04:28:35 <ivanm> it looks like reverse' xs ys = reverse xs ++ ys
04:28:50 <RichardO> i think you need parentheses
04:28:52 <ivanm> RichardO: yeah, I figured that was the bug, but was trying to work out why he was doing it in the first place
04:29:03 <cbuh> ivanm: for studying,
04:29:43 <bastl> cbuh: why is your function taking two parameters?
04:29:58 <cbuh> ivanm: I've read that ++ needs to run through the whole list, while : -- is an easy operation
04:30:14 <ivanm> cbuh: it needs to run throught the whole _first_ list
04:30:18 <ivanm> which you're doing anyway
04:30:23 <ivanm> bastl: I've already asked that ;-)
04:30:46 <zygoloid> ivanm: "reverse foo ++ bar" is slower than cbuh's "reverse' foo bar"
04:31:20 <ivanm> zygoloid: is it really that much slower?
04:31:24 <ivanm> not by much surely
04:31:37 <zygoloid> well, not asymptotically; they're both O(length foo)
04:31:43 <cbuh> guys, I saw realization like this: reverse' (x:xs) = reverse' xs ++ x
04:32:03 <ivanm> wtf?
04:32:05 <ivanm> that's wrong
04:32:19 <cbuh> and this way each time it will run thru the (reverse' xs) list to perform an (++ x)
04:32:29 <ivanm> typewise at the very least
04:32:37 <RichardO> reverse' (x:xs) = reverse' xs ++ [x]
04:32:39 <ivanm> zygoloid: oh, wait, I get what you're saying
04:32:43 <ivanm> RichardO: yeah
04:32:44 <b_jonas> heh, MJD reacts on the famous "monads are like burritos" blog entry here: "http://blog.plover.com/prog/burritos.html"
04:33:08 <cbuh> Richard0: sorry [x] of course
04:33:58 <HaskellLove> yo guys anyone used git? does git have GUI or i will have to write in markup language?
04:34:12 <zygoloid> b_jonas: yeah, i really don't like that blog post. had he said 'burritos are a monad' i think i'd like it. but saying 'monads are like burritos' seems to be falling into exactly the burrito fallacy of monad tutorials
04:34:25 <b_jonas> zygoloid: indeed
04:34:30 <b_jonas> and the post is stupid anyway
04:35:22 <Cromulent> HaskellLove: there are GUIs available for Git - it comes with one in fact gitk
04:35:22 <b_jonas> it says "because tortillas are indistinguishable" which sort of implies that burritos are the identity monad (or maybe the list monad)
04:35:41 <Cromulent> but there are better available depending on your platform
04:35:55 <b_jonas> zygoloid: though that's not the fallacy the original burrito post talks about, but an even simpler one
04:36:00 <zygoloid> b_jonas: it's the old "here's an example monad, all monads are like this" fallacy.
04:36:05 <HaskellLove> Cromulent>	i am ubuntu, so i wont have to use markup at all? does it have wiki
04:36:13 <cbuh> ivanm: as in recusion, ++ will ran thru the whole list in each recurse step.. am I right?
04:36:20 <b_jonas> zygoloid: yep, but byorgey talks about a different fallacy
04:36:49 <cbuh> bastl: actually the final function will be theReverse x = reverse' x []
04:36:58 <ivanm> cbuh: OK, if the lists are of length n and m, yours will be O(n) rather than O(2n)
04:36:59 <Cromulent> you'd be best off reading the docs at www.git-scm.com - but you don't have to use markup no - maybe the command line from time to time
04:37:04 <Lemmih> HaskellLove: Do you mean gitit?
04:38:28 <HaskellLove> Lemmih yeah i installed git on ubuntu but dont know how to run it now
04:38:35 <b_jonas> zygoloid: funnily I think he falls to the actual monad tutorial fallacy byorgey talks about in his previous posts about G√∂del's theorem
04:38:38 <zygoloid> b_jonas: i'm just going to put that down to Brent's crystal ball having imperfections...
04:39:06 <Lemmih> HaskellLove: Git and gitit are two different programs.
04:39:25 <HaskellLove> Lemmih>	well i got git, is there gitit for ubuntu
04:39:47 <cbuh> RichardO++ for the "reverse' xs (x:ys)" -- I'm confused, -- I thought I've tried that way already, but I checked and it work :)
04:40:37 <Lemmih> HaskellLove: It seems you did not mean 'gitit'. Google for a git tutorial. Git is not Haskell related.
04:41:02 <HaskellLove> ubuntu does not have gitit :(
04:41:16 <RichardO> it parses reverse' xs x:ys as (reverse' xs x):ys. x is of type a and reverse' takes two lists of a so there is a type error.
04:41:17 <cbuh> buy, and 10x for all
04:41:36 <zygoloid> b_jonas: both the Godel's theorem posts focus on the statement "i am lying" and miss out the interesting parts: 1) why you can construct that statement, and 2) why that means the system can't be consistent and complete
04:41:38 <HaskellLove> Lemmih>	i have git installed on ubuntu how to call the gui now?
04:41:57 <zygoloid> b_jonas: is that what you mean?
04:42:12 <b_jonas> zygoloid: yes, something like that
04:42:20 <Cromulent> HaskellLove: type gitk in one of your repos
04:42:24 <Lemmih> HaskellLove: http://lmgtfy.com/?q=git+tutorial
04:42:46 <HaskellLove> Cromulent>	says can not find git repository, a dialog shows up
04:42:59 * EvilTerran saunters in
04:43:22 <Cromulent> HaskellLove: you need to create or clone a repo first
04:43:38 <Cromulent> read the docs
04:44:06 <ivanm> greetings, EvilTerran
04:44:29 * EvilTerran is still fighting with category theory
04:44:49 <osfameron> punch it in the nose!
04:45:25 <osfameron> TaPL is my christmas project
04:46:45 <HaskellLove> Cromulent>	isnt Trac better then git?
04:46:47 * EvilTerran has categories A, B, C; functors F : A -> C, G : B -> C; and a collection of arrows phi_(A,B) : FA -> GB
04:47:28 <kmc> HaskellLove, Trac is a web frontend that can be connected to a variety of version-control systems, including Git
04:47:35 <kmc> it also provides wiki and bugtracking
04:48:32 <EvilTerran> such that all relevant diagrams commute
04:48:47 <HaskellLove> kmc>	so for local desktop use i should stay with git i guess? also gitit has wiki i think
04:49:05 <kmc> HaskellLove, trac and git are not alternatives to each other
04:49:22 <kmc> you can use git through trac, or you can use git standalone, or you can use something else through trac
04:49:37 <kmc> gitit is a wiki that stores its data in git
04:49:40 <EvilTerran> (phi indexed by objects in A and B)
04:49:42 <HaskellLove> kmc I meant, Trac is for web use for company so more people have acess, but for me on desktop git is only ok
04:49:59 <EvilTerran> and i can't find a nice way of expressing that "diagrams commute" conditio
04:50:00 <EvilTerran> n
04:50:17 <kmc> HaskellLove, what are you trying to do?
04:50:35 <kmc> we can't really answer questions like "is Foo better than Bar" without knowing the task at hand
04:50:39 <HaskellLove> kmc i want to version my euler solutions and to have wiki for research and notes
04:50:54 <EvilTerran> (for all f : a -> a' in A, phi_(a',b) . Ff = phi_(a,b); likewise for all g in B)
04:50:57 <b_jonas> version Euler solutions?
04:51:08 <kmc> git is a nice version control system, with a steep learning curve
04:51:10 <HaskellLove> i never really used wiki or versioning software so i do research now and read some stuff
04:51:10 <b_jonas> but Euler solutions are one-liners you write once and don't edit later unless you rewrite them completely
04:51:15 <b_jonas> that just doesn't make sense
04:52:31 <kmc> i dunno, i use VCS even for relatively trivial things
04:52:36 <kmc> a lot of people version-control their entire home directory
04:53:00 <EvilTerran> it's occured to me that phi is a natural transformation : Fst(F-,G-) ==> Snd(F-,G-), where Fst, Snd : CxC -> C are functors in the obvious way
04:53:03 <EvilTerran> but that seems ugly
04:53:18 <kmc> darcs and  git make it easy to version control a directory on a whim
04:53:28 <HaskellLove> kmc ok thanks
04:55:45 <HaskellLove> kmc one more thing, i am on ubuntu and people say linux enviornemnts are safe vs windows where you get a problem and you need to format... what is your experience, as time goes so far i have 15 solutions for euler and dont want to lose them as time goes on i will have hundreds files... do you agree ubuntu is safe and i should not worry of time coming when i need to format pc?
04:55:52 <EvilTerran> and i can't say it's a NT : F => G, because the types don't line up
04:56:40 <EvilTerran> (F and G aren't parallel)
04:57:20 <b_jonas> HaskellLove: that's orthogonal to versioning
04:57:27 <b_jonas> you have to backup your stuff anyway
04:57:46 <b_jonas> but whether that's a version repo or just plain files is independent of this
04:58:09 <HaskellLove> b_jonas i should get myself a disk or put stuff on cds i guess
04:58:29 <benmachine> yeah, buying an external HD and putting stuff on it is probably good practice
04:58:43 <JohnDoe365> HaskellLove: But them on git or bitbucket or jungeldisk
04:59:09 <benmachine> what I did, though, is I partitioned my hard drive and put my home folder on a different partition to my OS
04:59:29 <benmachine> then I can reinstall whatever I like whenever without compromising my documents
04:59:38 <b_jonas> sure, that doesn't protect you from hardware failure of the hdd though
04:59:40 <HaskellLove> JohnDoe365, put them on git? what do you mean? bitbucket?jungeldisk?
04:59:51 <b_jonas> or accidental delete
05:00:08 <b_jonas> or software mishap that overwrites everything
05:00:11 <b_jonas> cd is safer for that reason
05:00:15 <JohnDoe365> git: http://github.com/
05:00:27 <JohnDoe365> hg: http://bitbucket.org/
05:00:42 <JohnDoe365> http://www.jungledisk.com/
05:00:54 <b_jonas> JohnDoe365: sorry, I mean to benmachine
05:00:55 <JohnDoe365> the last one can be mapped as a webdav drive afaik
05:01:25 <JohnDoe365> b_jonas:  whats benmachine?
05:01:45 <b_jonas> JohnDoe365: a nick here
05:01:54 <JohnDoe365> k ;)
05:01:56 <benmachine> hi
05:02:19 <JohnDoe365> hi ;)
05:06:57 <kmc> @google bitbucket
05:06:58 <lambdabot> http://bitbucket.org/
05:06:59 <lambdabot> Title: Mercurial hosting ‚Äî bitbucket.org
05:07:00 <kmc> @google jungledisk
05:07:02 <lambdabot> http://www.jungledisk.com/
05:07:02 <lambdabot> Title: Online storage and backup | Secure file sharing | Unlimited online storage | Jun ...
05:07:09 <kmc> HaskellLove, i think you should try out this great website "google"
05:08:00 <HaskellLove> kmc yeah cool web site
05:08:16 <pozic> What is Curt Sampson's nickname?
05:09:33 <ivanm> pozic: cjs
05:09:40 <ivanm> preflex: seen cjs
05:09:40 <preflex>  cjs was last seen on #haskell 7 days, 5 hours, 21 minutes and 57 seconds ago, saying: I didn't realize that Haddock generated an index-frames.html as well.
05:10:04 <pozic> ivanm: thanks. How do you know that?
05:10:19 <ivanm> pozic: because I've talked to him before ;-)
05:10:23 <ivanm> (how else would I know?)
05:10:29 <pozic> ivanm: you mean IRL?
05:10:44 <ivanm> nope
05:10:46 <ivanm> email and here
05:14:07 * hackagebot upload: Vec-Boolean 1.0.1 - Provides Boolean instances for the Vec package (TobiasBexelius)
05:15:10 <JohnDoe365> HaskellLove: People will love you when you go with http://patch-tag.com/ though; It's a public Darcs repo
05:17:51 <ivanm> JohnDoe365: ummm.... code.haskell is also free and public; it's just for haskell software, that's all
05:18:26 <trygvis> anyone know when the 6.12.1 bootstrap compiler for solaris will be available?
05:22:02 <pozic> People will love me when I use patch-tag? Wow, I had never thought it would be that easy!
05:25:04 <ivanm> trygvis: when someone makes it
05:26:10 * hackagebot upload: GPipe 1.1.2 - A functional graphics API for programmable GPUs (TobiasBexelius)
05:27:39 <JohnDoe365> http://patch-tag.com/r
05:27:43 <JohnDoe365> pretty verbose ;)
05:31:50 <HaskellLove> JohnDoe365 nah man i go with git because Torvalds likes it
05:32:34 <JohnDoe365> He's the man a least ... like it most too
05:33:23 <HaskellLove> yeah he is my uncle
05:33:32 <medfly> your uncle?
05:34:58 <HaskellLove> yeah
05:35:03 <medfly> that's strange.
05:35:18 <medfly> I guess your family is officially nerdier than mine.
05:35:25 <MoALTz> his sister would be about 26 now. so i find it unlikely (yes... i just checked to see if he has any brothers or sisters)
05:35:39 <HaskellLove> hahaha i am fuckin with u guys
05:35:46 <medfly> well okay.
05:35:46 <quicksilver> HaskellLove: means uncle in the "I'm full of shit" sense of the word.
05:35:50 <MoALTz> oh oops - i misread anyway
05:36:01 <medfly> it's not like IMPOSSIBLE.
05:36:03 <zygoloid> MoALTz: good bluff :)
05:36:20 <MoALTz> zygoloid: unintentional...
05:36:27 <HaskellLove> quicksilver exactly how did you know man?
05:36:35 <MoALTz> kind-of the opposite of stairwell wit
05:37:00 <medfly> who knows, maybe his sister had a kid at an early age and HaskellLove is like this hax 6 year old kid that knows how to program.
05:37:04 <medfly> :-p
05:37:25 <HaskellLove> medfly>	nah i am 21 and i am stupid as hell
05:38:06 <HaskellLove> i mean, i cant install and call git on ubuntu :( which is like 10 IQ inteligence maybe :(
05:38:29 <qwr> HaskellLove: aptitude install git-core
05:38:32 <medfly> I think you're overestimating the rest of humanity
05:38:51 <qwr> HaskellLove: git clone git://whatever
05:39:58 <HaskellLove> qwr yeah i did that and when i call gitk it still shows no repositories bla bla error ... nevermind this is haskell chanel dont flood it with my shit
05:43:14 * hackagebot upload: stringtable-atom 0.0.6.1 - Memoize Strings as Atoms for fast comparison and sorting, with maps and sets (AudreyTang)
05:49:16 * hackagebot upload: pugs-compat 0.0.6.1 - Portable Haskell/POSIX layer for Pugs (AudreyTang)
06:05:20 * hackagebot upload: Pugs 6.2.13.15 - A Perl 6 Implementation (AudreyTang)
06:10:33 <Kim^Walkman> HaskellLove: if I'm not wrong (don't use gitk) it needs to be started from a directory that contains a repository
06:11:07 <HaskellLove> Kim^Walkman how?
06:11:26 <Kim^Walkman> How what?
06:11:52 <HaskellLove> Kim^Walkman i mean where is this directory you talk about
06:12:58 <Kim^Walkman> Using git you create repositories like you create files. When you've created a repository (created the .git directory using git init, for example)  you can track files below that directory
06:13:48 <HaskellLove> Kim^Walkman so you create repository with git and view it with gitk... and i thought you make them with gitk with GUI
06:13:52 <Kim^Walkman> The directory that contains the ‚Äú.git‚Äù folder is called the ‚Äúgit directory‚Äù, and is in a way your ‚Äúroot‚Äù folder of that repository
06:14:16 <Kim^Walkman> As I mentioned I don't use gitk, so it's more of a guess that you could try
06:14:51 <Kim^Walkman> Clone a repository from somewhere and give it a shot, can't hurt
06:18:45 <Zao> Rumor has it that this network has a git channel.
06:18:49 <Zao> This isn't it :)
06:19:11 <maketo> hi, has anyone successfully installed the haskell platform on FreeBSD 8?
06:22:46 <tofulivin> preflex: xseen Cale
06:22:46 <preflex>  Cale was last seen on freenode/#haskell 3 hours, 8 minutes and 18 seconds ago, saying: I'd say that GHC has pretty decent SMP support as far as programming languages that actually exist go. :)
06:29:13 <b_jonas> wow, ghc compiled in 56 minutes
06:29:17 <b_jonas> this was fast
06:30:25 <pozic> Is the Haskell Platform anything more than GHC + an easier install of some important packages?
06:31:02 <Igloo> no
06:33:24 <pozic> I guess there is also the stamp "the following packages are worth using".
06:34:07 <trygvis> does anyone know what this ghc build error is? http://pastie.org/745646
06:34:22 <trygvis> (building a plain 6.10.4)
06:35:32 <HaskellLove> why do they make things so complicated, this git thing can be gui based and should be simple not spend a day learning commands... chesus...
06:35:45 <kmc> @wn chesus
06:35:47 <lambdabot> No match for "chesus".
06:35:53 <EvanR-work> git is pretty simple
06:36:01 <pozic> trygvis: if you build something, you should specify platform.
06:36:05 <trygvis> actually, the file it's trying to build is empty
06:36:05 <EvanR-work> feel lucky its not svn
06:36:06 <kmc> HaskellLove, it was written by Linux kernel hackers
06:36:23 <kmc> HaskellLove, a GUI is pretty terrible for integrating into primary development workflow
06:36:24 <trygvis> pozic: right .. solaris 5.11 (build 101), i386
06:36:42 <pozic> HaskellLove: you should use something which is integrated with git. E.g. Emacs has a git mode.
06:36:48 <kmc> i use git extensively, mostly through command line, sometimes using gitk to get an overall picture of stuff
06:36:57 <pozic> HaskellLove: that way you can use tons of VC systems, without thinking about it.
06:37:07 <kmc> anyway there are loads of git tutorials online, and a git channel on this here very FreeNode
06:37:19 <b_jonas> ghci-6.12.1 no longer has :s as an alias to :set
06:37:19 <anders^^> is there a way to increase the stack space when installing via cabal? +RTS -K10M does not seem to work with cabal install...
06:37:22 <b_jonas> is that intentional?
06:37:40 <pozic> b_jonas: is there a different commpand which starts with an s, which was introduced?
06:37:46 <pozic> command*
06:38:04 <pozic> b_jonas: that would be my first guess.
06:38:18 <HaskellLove> this is extreme stupidity geeks playing smart by making dumb things difficult.. i mean have a gui for the damn thing, as a user dont make me spend days learning how it works, it is just a stupid version control system
06:38:39 <dcoutts> anders^^: increase the stack space for what exactly? cabal itself should not need anything special, is it some other program cabal calls that you want to affect?
06:38:44 <kmc> HaskellLove, great, please take your uninformed complaining somewhere else
06:38:53 <kmc> proper distributed version control *is* actually a hard problem.  it's not as if the git people are stupid about how they approach it
06:38:53 <b_jonas> pozic: :show, :step, :sprint, :steplocal, :stepmodule already existed in earlier versions
06:39:17 <pozic> b_jonas: and those are all commands? Then I don't know. Check the release notes, then.
06:39:21 <anders^^> dcoutts: for ghc i suppose
06:39:38 <pozic> b_jonas: otherwise you could return a (documentation) bug.
06:39:41 <HaskellLove> kmc yea this shit is not for me
06:39:56 <kmc> you may not agree with their decisions, but it seems you have not read a single introductory document about git, yet you're sure it's stupid and you could do better etc.
06:40:16 <pozic> I think gitk is great to get an overview of what is happening in the world.
06:40:27 <kmc> pozic, i use it for that, and i also use tig similarly
06:40:32 <EvanR-work> *grumble* gitk doesnt work via ssh
06:40:33 <dcoutts> anders^^: I'm not sure if --ghc-options="+RTS blah -RTS" will work, it might just get gobbled by cabal
06:40:40 <pozic> EvanR-work: ssh -X
06:40:43 <kmc> EvanR-work, sure it does, with X forwarding
06:40:47 <kmc> yeah what pozic said
06:40:47 <EvanR-work> REALLY.
06:40:55 <kmc> and tig works over ssh of course
06:40:55 <dcoutts> anders^^: that said, you should not need it for ghc either, if you do it smells like a bug that should be reported.
06:40:58 <pozic> EvanR-work: is that a joke?
06:41:09 <EvanR-work> i knew this, but i dont think the server has X
06:41:33 <kmc> EvanR-work, does it have gitk installed?
06:41:43 <anders^^> dcoutts: i did a cabal clean and now it works without extra stack space so i guess the problem has been solved...
06:41:46 <kmc> because if you install gitk via a sane package manager you will get all the libraries you need to run it
06:41:55 <kmc> being tcl and some X crap i assume
06:42:00 <EvanR-work> dont think its installed, will have to check on that
06:42:14 <kmc> hmm maybe tk not tcl
06:42:46 <pozic> trygvis: and no, I don't know. I don't run Solaris.
06:43:11 <trygvis> are there other, more appropriate places to ask?
06:43:38 <HaskellLove> linux kernel so called hackers are great source of stupidity... fuckin psychos playing smart by making stupid stuff like git and emacs ... damn...
06:43:41 <trygvis> I see that there's a CPUTime.hsc that the .hs file is generated from, but the generated file being empty is strange :)
06:43:51 <HaskellLove> just to share my frustration i will stop now :D
06:44:06 <EvanR-work> you do know you lost all respect by now
06:45:09 <kmc> HaskellLove, you do know that Emacs predates Linux by 15 years?
06:45:32 <JohnDoe365> HaskellLove:I use the git plugin with eclipsewhich works very well,  but by doing so you' ll get some additional 160Mb on your HD
06:45:41 <JohnDoe365> btw. command line of git is fine
06:45:47 <HaskellLove> whatever, i just talk of all those people playing smart by making stupid simple things into the most complicated thing you need to spend a week to learn
06:46:13 <kmc> HaskellLove, distributed version control is not a stupid simple thing
06:46:14 <JohnDoe365> if you use git as your private repo and you need not fork, it's absilutely straight forward
06:46:30 <kmc> maybe git is solving a problem more complicated than yours
06:46:32 <HaskellLove> kmc i doubt it cant be done without guis and simple interface
06:46:41 <dschoepe> HaskellLove: version control systems are not simple. especially when they have to deal with as much data as e.g. the linux kernel
06:46:44 <kmc> GEE I WONDER IF SOMEONE WROTE A GUI FOR GIT
06:46:51 <kmc> maybe some magical "search engine" website would tell you
06:47:14 <kmc> i'm sorry, everyone, for raising my voice at an obvious troll
06:47:18 <pozic> kmc: I don't think anyone wrote the perfect GUI.
06:47:39 <pozic> Writing GUIs is hard, because you can never satisfy everyone.
06:47:54 <olwe> hallo, newbie here wanting to know about xmonad...
06:48:00 <JohnDoe365>  kmc: The eclipse one is quite smart and ther eis one for windows which integrates right-mouse clckish into explorere
06:48:00 <kmc> olwe, what do you want to know?
06:48:00 <pozic> olwe: #xmonad
06:48:03 <kmc> btw, there's an xmonad channel too
06:48:38 <olwe> very good, I'll return with my Haskell on Emacs questions later bye
06:48:47 <kmc> flawed or not, it seems our friend HaskellLove has not tried any of the guis, or indeed made any attempt to do so
06:49:30 <HaskellLove> well i bumped on 4 tutorials now and one video and i saw no gui
06:50:06 <kmc> HaskellLove, http://git.or.cz/gitwiki/InterfacesFrontendsAndTools
06:50:42 <pozic> HaskellLove expects to connect to a fountain of knowledge and just hopes that it will all magically find its way to his brain.
06:50:53 <kmc> not like you could be expected to find that yourself.  i mean, you'd have to spend a whole 30 seconds on google
06:51:02 <kmc> we've learned by now that's far too much to expect
06:51:04 <JohnDoe365> hrhr ..
06:51:07 <EnglishGent^afk> a week? *nobody* learns emacs in a week!
06:51:32 * EnglishGent^afk has used it 5 years & only knows a fraction of it
06:51:39 <HaskellLove> haha exactly a week is too litle for such master piece of whatever
06:52:04 <benmachine> some things have to choose between being easy to learn and being easy to use
06:52:04 <kmc> pozic, yes, that fountain of knowledge is called IRC.  It works pretty well, except that if you keep pissing in the fountain, it eventually shuts off.
06:52:08 <HaskellLove> instead of learning algorithms i am suposed to spend time learning commands for git and emacs... yeah right
06:52:28 <EnglishGent^afk> it's *extremely* powerful ... but, well - as it's own manual proudly boasts "emacs -- a learning curve like a plumb-line"
06:52:35 <benmachine> HaskellLove: if you want something really powerful that power usually comes at a price
06:52:36 * EnglishGent^afk is a fan of emacs too!
06:52:55 <pozic> I got my horrible store continuation and call continuation iso-recursive type thing to work :)
06:53:00 <kmc> HaskellLove, did you try any of those GUIs for Git?
06:53:12 <HaskellLove> benmachine>	what power man, it is just a text editor, just give me syntax highlight and some other cool features and it is enough
06:53:21 <benmachine> HaskellLove: then don't use emacs!
06:53:25 <kmc> there are 19 of them listed on that page
06:53:25 <benmachine> use gedit or something
06:53:29 <kmc> HaskellLove, did you try any of them?
06:53:31 <kmc> any of the 19 guis?
06:53:33 <kmc> for git?
06:53:41 <HaskellLove> power is in knowing algorithms stuff not a text editor :D
06:53:47 <kmc> oh, that's also not counting web frontends
06:53:49 <benmachine> text editors can be powerful
06:53:51 <kmc> there are 15 of those as well
06:53:59 <kmc> HaskellLove, did you try any of the GUIs?
06:54:15 <HaskellLove> benmachine algorithms are powerful text editors are invisible
06:54:25 <HaskellLove> kmc no man i see these first time
06:54:36 <kmc> now i know you're a troll
06:54:38 <Saizan> pozic: you found a way to trick newtype deriving that works?:)
06:54:45 <kmc> "hey man emacs sucks" will guaranteed troll 50% of any IRC chan
06:54:51 <kmc> "vi sucks" gets the other 50%
06:54:53 <kmc> pro tip
06:55:00 <kmc> @quote emacs
06:55:00 <lambdabot> sorear says: [emacs haskell mode] not fucked up, just well documented
06:55:01 <benmachine> kmc: calling people trolls doesn't help if they aren't a troll nor does it help if it is
06:55:06 <benmachine> err, they are
06:55:07 <kmc> it's true
06:55:11 <tobe> hi, i want to create a list of 10 values in a recursion, so i have to quit it when the length of the list is 10. how can i do this in haskell?
06:55:16 <kmc> anyway i'm not the first or last to say it
06:55:22 <kmc> tobe, what are the values?
06:55:32 <tobe> numbers
06:55:35 <kmc> which ones?
06:55:35 <benmachine> how do you make the values?
06:55:38 <pozic> Saizan: yes\
06:55:39 <kmc> there's a lot to choose from
06:55:42 <benmachine> do you use previous values?
06:55:53 <kmc> > map (*3) [1..10]
06:55:54 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
06:56:02 <kmc> tobe, ^^^^ list of 10 values
06:56:08 <HaskellLove> tobi: take 10 $ your function
06:56:15 <benmachine> tobe: you could just use an infinite recursive algorithm, and then use take 10
06:56:20 <benmachine> yeah, like that
06:56:23 <EvanR-work> you know what does help, removing trolls
06:56:41 <benmachine> the troll in question just gave helpful advice
06:56:42 <EvanR-work> but im not running this chan ;)
06:56:44 <HaskellLove> EvanR-work have mercy :(
06:56:45 <EnglishGent> HaskellLove - really, take a look at something like org-mode to get an idea of how powerful emacs really is - it's got a built in spreadsheet system that's more powerful than all but the latest version of Excel (no row or column limits)
06:56:47 <b_jonas> yeah, generate an infinite list and take 10
06:56:52 <benmachine> so what *really* helps is not whining about trolls all the time >_>
06:57:00 <pozic> Saizan: that would be a great job interview question, btw. Especially over the phone :D
06:57:11 <b_jonas> provided you can get a list
06:57:11 <JohnDoe365> tobe: Write the recursion downto zero, and when you reach it, you return the accumulator
06:57:15 <EvanR-work> what helps is not generalizing two messages to 'all the time'
06:57:19 <EnglishGent> emacs calc makes most scientific calculators look feeble - you need Maple or Mathematica to better it
06:57:20 <tobe> kmc: it's a list that shall contain 1,2,1,2,1...
06:57:20 <EnglishGent> etc
06:57:21 <EvanR-work> all the time is HaskellLove's bs
06:57:34 <kmc> > take 10 (cycle [1,2]) -- tobe
06:57:35 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
06:57:42 <kmc> > cycle [1,2]
06:57:42 <tobe> kmc, ok i'll try
06:57:43 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
06:57:54 <EnglishGent> but yes - I conceed it's far more complicated than it needs to be
06:57:56 <HaskellLove> EvanR-work yeah bur HaskellLove is on Euler 16 now so shut up, i am advancing fast...
06:58:04 <Saizan> ok, keep emacs and other unix tools talk to what is related to haskell.
06:58:14 <Saizan> or -blah
06:58:22 <kmc> > let onetwo 0 = []; onetwo n = 1 : 2 : onetwo (n-2) in onetwo 10 -- tobe, explicit recursion
06:58:23 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
06:58:37 <kmc> tobe, i'd favor the take / cycle solutino for obvious reasons
06:58:51 <kmc> in Haskell we tend not to write explicit recursion when it's of a common form like take, cycle, map, filter, fold, etc.
06:59:36 <kmc> @src cycle
06:59:36 <lambdabot> cycle [] = undefined
06:59:36 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
07:00:18 <benmachine> pretty sure I've asked this before but forgotten: is the latter more efficient than xs ++ cycle xs?
07:00:23 <benmachine> oh I suppose it is
07:00:46 <benmachine> but is it so in any way more interesting than not having to pattern match the xs?
07:00:52 <Jedai> benmachine: it is, at least from a memory point of view
07:00:58 <kmc> it ties a tighter knot
07:01:05 <pigdude> what does "The function `main' is not defined in module `Main'" mean?
07:01:19 <kmc> pigdude, are you trying to compile a haskell program?
07:01:22 <benmachine> pigdude: it means you tried to make an executable of a program that doesn't define the main behaviour
07:01:29 <Saizan> it creates a cyclic structure in memory, instead of unfolding an infinite one, so to speak
07:01:33 <Jedai> benmachine: with "xs' = xs ++ xs'" the data really is cyclic in memory
07:01:36 <kmc> the top-level behavior of your program is an IO action named "main"
07:01:40 <tobe> kmc, ok, the exercise is a little bit more "complicated". I just have to create a list with the number of days for each month like 31,30,31,30 and I have to end it by 12 and have to turn the direction of the 31,30,.. numbers at july/august. thats my idea so far
07:01:43 <benmachine> oh right, that's interesting
07:02:17 <EvanR-work> when taking from a cyclic list, does the ++ in the definition of cycle happen each time?
07:02:18 <tobe> the february issn't important at the moment
07:02:20 <pigdude> I'm using that O'Reilly book on Haskell and it doesn't explain how to compile scripts well. Is there another document that would have a decent explanation?
07:02:22 <EvanR-work> or only when you run out of the first half the cycle
07:02:29 <benmachine> tobe: you know, if you want to make february work too it might be easier jsut to write the whole list in your program
07:02:33 <Jedai> benmachine: it's like the difference between "xs = [1,1..]" and "xs = 1 : xs"
07:02:38 <kmc> pigdude, make a file with a value named "main" of type "IO ()"
07:02:44 <kmc> then run "ghc --make" on that file
07:02:53 <kmc> if it imports anything else, ghc will automatically compile that too
07:02:53 <tobe> benmachien, yes, but it's an exercise that i have to give up ;)
07:03:05 <tobe> benmachine
07:03:23 <pigdude> kmc, I don't know enough yet to translate that suggestion, apart from the ghc usage
07:03:23 <tromp__> :t fix . (++)
07:03:26 <lambdabot> forall a. (Monoid a) => a -> a
07:03:31 <Jedai> EvanR-work: the (++) will only add a small overhead to the first time through the list
07:03:41 <kmc> pigdude, do you know how to do IO in Haskell generally?
07:04:04 <pigdude> kmc, no
07:04:07 <kmc> ok
07:04:17 <kmc> what's the standalone program you want to write?
07:04:21 <pigdude> kmc, I'm just trying to go through this book. And I'm disappointed by it
07:04:26 <kmc> which part?
07:04:37 <pigdude> kmc, I am on ch4 of RWH
07:04:50 <benmachine> > let xs = cycle [31, 30] in take 7 xs ++ take 5 xs
07:04:51 <kmc> pigdude, at this point you should not be compiling standalone programs
07:04:51 <lambdabot>   [31,30,31,30,31,30,31,31,30,31,30,31]
07:04:54 <pigdude> kmc, there is no good description of the compilation/testing cycle
07:04:59 <kmc> you should load your code into ghci and poke at it interactively
07:05:08 <EvanR-work> Jedai: so after its evaluated once, it becomes a actual cyclic list value?
07:05:08 <benmachine> tobe: something like that?
07:05:24 <pigdude> kmc, maybe that's what I should be doing
07:05:31 <kmc> pigdude, there's a description of ghci in chapter 1
07:05:32 <EvanR-work> it doesnt remain a ++ expression?
07:06:31 <benmachine> EvanR-work: presumably it'll be something like let xs = 1:2:3:4:xs in xs
07:06:39 <Saizan> exactly
07:07:06 <EvanR-work> ah
07:07:25 <pigdude> kmc, thanks for your help, I will keep using :load
07:07:58 <kmc> pigdude, it's chapter 7 that first describes how to write a standalone program
07:08:15 <kmc> even when working on big real world stuff, we often test using ghci
07:09:01 <pigdude> kmc, any time I'm typing outside of vim is a bad time so I tend to shy from a REPL for all but the simplest tests :)
07:09:12 <kmc> ah, i think you can set up ghci for vim keys
07:09:26 <pigdude> I'll have to look into ghci configuration sometime
07:10:18 <kmc> pigdude, additionally you can write your code in vim and load it into ghci interactively, using :load as you mentioned
07:10:45 <pigdude> yea, that's what I've been doing for now
07:10:45 <tobe> benmachine: that's what I need, but the first part of the exercise is: daySeq = 31 : 30 : daySeq, so I think I have to use this kind of recursion
07:11:43 <tobe> benmachine: a recursive function that i cn call
07:14:46 <tobe> benmachine: do you know how i can to it in that way?
07:16:07 <b_jonas> tobe: does it compute the next element of the list from the previous one element?
07:16:13 <b_jonas> tobe: in which case, you need iterate
07:16:20 <tobe> sorry, i was disconnected
07:16:50 <b_jonas> @run take 10 $ iterate (\x -> x * 2 + 1) 0
07:16:52 <lambdabot>   [0,1,3,7,15,31,63,127,255,511]
07:17:31 <b_jonas> (though you might want to implement iterate yourself)
07:17:32 <tobe> b_jonas: daySeq = 31 : 30 : daySeq that's the first line how the recursive function should work
07:17:45 <tobe> yeah
07:18:24 <b_jonas> tobe: is that only the first line?
07:18:25 <benmachine> tobe: take 7 daySeq ++ take 5 daySeq
07:18:31 <b_jonas> is there a second line?
07:18:41 <RadioApeShot> How do I specify the type of arguments in lambdas?
07:18:45 <benmachine> is pretty much all you can do
07:18:52 <tobe> no, only this one, but i really think i have to use this
07:18:55 <RadioApeShot> \x::Int -> x + 1 does not work.
07:19:15 <b_jonas> RadioApeShot: it should if you enable the right language extension
07:19:19 <tobe> benmachine: mom
07:19:27 <benmachine> RadioApeShot: try \x -> (x::Int) + 1
07:19:35 <RadioApeShot> benmachine: thanks
07:19:38 <benmachine> tobe: if that's not what you want then I don't know
07:20:35 <Saizan> \(x::Int) -> x + 1 works with ScopedTypeVariables
07:20:50 <RadioApeShot> benmachine: Interestingly, you can't specify the type on the variable, but you can specify the type on the constant.
07:21:09 <RadioApeShot> Saizan: How do I turn on ScopedTypeVariables?
07:21:11 <kmc> you can also give a sig to the whole lambda expression
07:21:18 <kmc> > (\x -> x + 1) :: Float -> Float
07:21:20 <benmachine> RadioApeShot: you can't?
07:21:20 <lambdabot>   -0.375->
07:21:20 <lambdabot>    0.625
07:21:20 <lambdabot>  -0.75->
07:21:20 <lambdabot>    0.25
07:21:20 <lambdabot>  -1.5->
07:21:22 <lambdabot> [5 @more lines]
07:21:34 <benmachine> @type \x -> (x :: Int) + 1
07:21:35 <lambdabot> Int -> Int
07:21:40 <Saizan> RadioApeShot: :set -XScopedTypeVariables or {-# LANGUAGE ScopedTypeVariables #-} at the top of your file
07:21:40 <RadioApeShot> kmc: That may be what I want to do
07:21:58 <RadioApeShot> So what are the underlying language issues which make this problematic?
07:22:12 <benmachine> which this in particular?
07:22:31 <RadioApeShot> For instance, (\x -> x::Int+1)
07:22:48 <kmc> that's allowed, in vanilla Haskell as well
07:22:55 <Saizan> you've to put parentheses though
07:22:58 <kmc> (\(x :: Int) -> x + 1) is an extension
07:22:59 <RadioApeShot> That gives me an operator + error message
07:23:15 <Saizan> "\x -> (x :: Int) + 1" works
07:23:16 <kmc> afaik it's not a theoretically problematic extension; it's just not in the standard
07:23:21 <RadioApeShot> Rather, to be specific (\x -> x::Int+1) gives me     Illegal operator `+' in type `Int + 1'
07:23:32 <zygoloid> RadioApeShot: :: binds really loosely. (\x -> x :: Int + 1) parses as (\x -> x) :: (Int + 1)
07:23:40 <RadioApeShot> zygoloid: Ah
07:23:50 <Saizan> no
07:24:08 <Saizan> it parses as (\x -> (x :: (Int + 1)))
07:24:24 <zygoloid> @type \x -> x :: Int
07:24:25 <lambdabot> Int -> Int
07:24:27 <kmc> lambda bodies always go as far as they can
07:24:29 <zygoloid> ok :)
07:24:46 <Saizan> it was problematic either way :)
07:25:09 <tobe> benmachine: that's the exercise. maybe i don't really understand how it should looks like: fistTraversal = [31,30,31,30,31,30,31,31,30,31,30,31] . Define fistTraversal in terms of the following cyclic list: daySeq :: [Day] daySeq = 31 : 30 : daySeq
07:25:29 <zygoloid> kmc: in which case it should parse as (\x -> (x :: Int)) + 1 ;-)
07:25:44 <kmc> for certain definition of "can" :)
07:26:15 <zygoloid> time to check the report i guess :)
07:26:52 <HaskellLove> what does this mean : Thus we have a recursive definition for calculating a power of two in terms of the addition operation: just add together two of the previous power of two. ----------- the guy talks about calculating powers of 2 not using 2^1000 but using sum instead, but i dont get his explanation above ^
07:27:51 <zygoloid> kmc: the report says "as far to the right as possible" but doesn't specify what it means by 'possible'
07:28:00 <benmachine> tobe: pretty sure you'll need take for that
07:28:30 <tobe> benmachine: hmm
07:29:22 <zygoloid> kmc: if we take 'possible' to mean 'parseable by the (ambiguous) grammar given in the report', then it really should parse as (\x -> (x :: Int)) + 1
07:30:01 <BONUS> HaskellLove: 2^x = 2^(x-1) + 2^(x-1)
07:30:02 <lambdabot> BONUS: You have 1 new message. '/msg lambdabot @messages' to read it.
07:30:04 <BONUS> 2^0 = 1
07:30:05 <tobe> benmachine: but do you think i should only write fistTraversal or I also extend daySeq?
07:30:40 * osfameron shudders at fistTraversal
07:31:41 <tobe> ?
07:31:45 <BONUS> > let twoToThePowerOf 0 = 1; twoToThePowerOf x = twoToThePowerOf (x - 1) + twoToThePowerOf (x - 1) in twoToThePowerOf 10
07:31:46 <lambdabot>   1024
07:32:10 <_Jedai_> tobe: that's a pretty awful lapsus
07:32:11 <gio123> http://pastebin.ca/1717075
07:32:18 <gio123> http://pastebin.ca/1717076
07:32:24 <gio123> what is a name in english such geometric figure?
07:33:07 <kmc> square wave?
07:33:12 <roconnor> gio123: the first one is the Heaviside function
07:33:15 <kmc> gio123, it looks like part of an electrical timing diagram
07:33:20 <kmc> step function?
07:33:26 <gio123> noo
07:33:34 <gio123> from high school geometric
07:33:42 <gio123> do not go for modern geometric
07:33:50 <gio123> from euclide geometric
07:34:07 <_Jedai_> gio123: a line
07:34:20 <gio123> no
07:34:30 <gio123> line is just
07:34:33 <HaskellLove> BONUS> should I just use 2^10 or your solution, i mean it is stil fast in Haskell, 2^10
07:34:33 <gio123> ------------------------
07:34:36 <gio123> something like this
07:34:48 <_Jedai_> gio123: that's clearly not a geometric figure...
07:34:57 <BONUS> HaskellLove: whenever possible, use 2^10 instead of that
07:35:05 <roconnor> second one is apparently called the rectangle function or boxcar function or unit pulse.
07:35:27 <BONUS> the recursive definition does unnecessary computation and would take a very long time for like 100 i think
07:35:30 <BONUS> > let twoToThePowerOf 0 = 1; twoToThePowerOf x = twoToThePowerOf (x - 1) + twoToThePowerOf (x - 1) in twoToThePowerOf 100
07:35:34 <lambdabot>   mueval-core: Time limit exceeded
07:35:54 <BONUS> i.e. it's slow as heck
07:35:59 <BONUS> > 2^100
07:36:00 <lambdabot>   1267650600228229401496703205376
07:36:01 <tobe> benmachine: now I wrote fistTraversal that calls daySeq as you wrote
07:36:07 <tobe> looks correct :)
07:36:29 <tobe> hopefully thats the thing the teacher wants
07:36:34 <tobe> :p
07:36:35 <gwern> ?src (^)
07:36:35 <lambdabot> x ^ 0            =  1
07:36:35 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
07:36:35 <lambdabot>   where f _ 0 y = y
07:36:35 <lambdabot>         f x n y = g x n
07:36:35 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
07:36:37 <doserj_> > let power n 0 = 1; power n m = a + a where a = power n (m-1) in power 2 1000
07:36:37 <lambdabot>                       | otherwise = f x (n-1) (x*y)
07:36:39 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
07:36:41 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
07:37:16 <gwern> that was a more complex definition that I expected
07:37:22 <gwern> (is that sucessive squaring?)
07:37:31 <BONUS> ^ has O(n) complecity whereas that twoToThePowerOf recurisve definition has O(2^n), which is just awful
07:39:16 <HaskellLove> BONUS so why did this guy use that for the solution of euler 16? was he playing hot shot or what?
07:39:23 <HaskellLove> http://blog.functionalfun.net/2008/07/project-euler-problem-16-calculating.html
07:39:56 <john86> hii all!
07:40:07 <gwern> GREETINGS FELLOW HUMAN
07:40:31 <john86> ;F
07:40:37 <yottis_> ?src sqrt
07:40:37 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:41:05 <BONUS> ack! what is that java or something
07:41:39 <kmc> C#
07:42:01 <HaskellLove> BONUs I love haskell even more when i see such things :)
07:42:12 <john86> some good tutorial for begginer ?
07:42:36 <kmc> @where lyah
07:42:37 <lambdabot> http://www.learnyouahaskell.com/
07:42:38 <kmc> @where rwh
07:42:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:42:40 <kmc> john86, those two
07:42:55 <kmc> and don't be afraid to ask questions here :)
07:43:03 <john86> 10x guys (;
07:43:17 <BONUS> its cool cause you can solve 16 in haskell just by doing
07:43:51 <BONUS> > foldl1' (+) . map digitToInt . show $ 2^1000
07:43:53 <lambdabot>   1366
07:43:56 <BONUS> ta-da
07:44:46 <BONUS> the reason he's doing that thing is because he's representing his numbers as lists
07:45:01 <BONUS> and it's easier to exponate such numbers if you use that 2^n-1 + 2^n-1 trick
07:46:24 <kmc> BONUS, any reason to use foldl1' (+) over "sum"?
07:46:36 <Itkovian> Any idea if the FOSDEM Haskell room has been obtained?
07:47:56 <Philonous> @src sum
07:47:57 <lambdabot> sum = foldl (+) 0
08:01:58 --- mode: irc.freenode.net set +o ChanServ
08:02:36 <tromp__> anyone else see all this left/joined spam?
08:02:37 <Mowah> yeah
08:02:37 <emile_m> Sort of
08:02:37 <HaskellLove> tromp__ me too, but I also see zombies in my room so i might be wrong
08:02:38 <kmc> FreeNode is having hell of problems
08:02:38 <kmc> due to DDoS
08:02:39 <tromp__> need a way to suppress that
08:02:40 <Saizan> tromp__: your client probably has a way to ignore joins and parts, /help ignore on irssi
08:02:40 <tromp__> using Konversation now
08:03:48 <gio123> can one connect it with 4 lines?
08:03:49 <gio123> http://pastebin.ca/1717091
08:03:53 <tromp__> ah, it has an option for that
08:04:38 <tromp__> Konversatio->Configure->Behavior->Chat Window->Hide Join/Part/Nick events
08:06:53 <zygoloid> kmc: http://hackage.haskell.org/trac/ghc/ticket/3766
08:17:58 <olwe> Hallo? Questions about a xmodal install on Fed12?
08:18:10 <lispy> olwe: I believe there is an xmonad channel
08:18:13 <lispy> > 1 + 1
08:18:13 <lambdabot>   2
08:18:15 <aep> BONUS: you're the guy who wrote that awesome haskell tutorial right? got anything on monads yet? :D
08:18:34 <tobe> i have a enumeration and a function that return a list. how can I zip a list of tupels which uses the first element of the list with the first value of the enumeration as a tupel, then as the second tupel the second element from the list and second value from the enumeration...
08:19:09 <HaskellLove> | elem x $ map (*10) [2..9] == tens !! (elemIndex x $ map (*10) [2..9] ) ------------ can I escape the repetition of the part after map?
08:19:25 <HaskellLove> kmc need you man...
08:20:13 <HaskellLove> elem x $ map (*10) [2..9] = tens !! (elemIndex x $ map (*10) [2..9] ) ---- put == instead of = above sorry here is correct one
08:20:16 <quicksilver> HaskellLove: yes, give it a name in a where clause
08:20:27 <HaskellLove> quicksilver the @ operator?
08:20:33 <EnglishGent> or a let clause
08:21:07 <HaskellLove> that is part of a guard in a function, can i have a let in the guard?
08:21:08 <quicksilver> no , a where clause
08:21:08 <quicksilver> can't easily use a letClause with a guard
08:21:33 <EnglishGent> ah - ok, I stand corrected :)
08:21:38 <EnglishGent> hi quicksilver btw :)
08:21:39 <quicksilver> | elem x mylst = tens !! elemIndex x mylst where mylst = map (*10) [2..9]
08:21:52 <quicksilver> in practice you probably put where on a new line
08:21:58 <HaskellLove> quicksilver>	so i will like write all my guards and after i finish i say where bla bla right?
08:21:58 <quicksilver> it can scope over multiple guards.
08:22:17 <HaskellLove> cool
08:22:25 <Twey> tobe: zip [(toEnum 0 :: YourEnumType) ..] yourList
08:23:25 * hackagebot upload: hmatrix-static 0.3 - hmatrix with vector and matrix sizes encoded in types (ReinerPope)
08:23:27 * hackagebot upload: convertible 1.0.7 - Typeclasses and instances for converting between types (JohnGoerzen)
08:24:30 <tobe> Twey: works, thx :)
08:24:35 <Twey> You're welcome
08:24:53 <Twey> toEnum/fromEnum confuse me
08:25:12 <Twey> I tend to think of the from* functions as converting from a less general type to a more general one
08:25:26 * hackagebot upload: HDBC 2.2.2 - Haskell Database Connectivity (JohnGoerzen)
08:25:34 <wferi> Hi! How does one convert between lazy and strict bytestrings?
08:26:06 <wferi> At least I think that may be the solution to this type error:
08:26:10 <roconnor> @hoogle pack
08:26:11 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
08:26:11 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
08:26:11 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
08:26:22 <roconnor> hmm
08:26:39 <wferi> Couldn't match expected type `Data.ByteString.Internal.ByteString' against inferred type `B.ByteString'
08:26:41 <roconnor> @hoogle ByteString -> ByteString
08:26:42 <lambdabot> Data.ByteString copy :: ByteString -> ByteString
08:26:42 <lambdabot> Data.ByteString init :: ByteString -> ByteString
08:26:42 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
08:26:48 <roconnor> @more
08:26:52 <roconnor> @hoogle-more
08:26:52 <lambdabot> Unknown command, try @list
08:26:55 <wferi> or maybe not...
08:27:13 <Twey> Strict.pack . Lazy.unpack
08:27:14 <Twey> ;)
08:27:19 <wferi> I import qualified Data.ByteString as B
08:27:41 <orbitz> does dynamic linking in 6.12.1 mean I can write plugins that i bring up and tear down on the fly?
08:27:44 <roconnor> Twey: nooo
08:27:46 <orbitz> like Dynlib in Ocaml?
08:27:56 <wferi> Yeah, I'd like to avoid goings through Strings... :)
08:27:58 <zygoloid> @hoogle fromChunks
08:27:58 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
08:27:59 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
08:28:20 <Kim^Walkman> wferi: http://pastebin.com/d84035ad
08:28:20 <Twey> orbitz: I believe you can do that already
08:28:27 <zygoloid> @type BSL.fromChunks . return
08:28:28 <lambdabot> BSC.ByteString -> BSLC.ByteString
08:28:37 <Twey> Oho!
08:28:44 <orbitz> Twey: i thought everyone was reocmpiling the app every time based on config file
08:28:58 <coldtile_> > odd $ sum $ 24:35:15:26:7:84[]
08:28:59 <lambdabot>   No instance for (GHC.Num.Num ([a1] -> [a]))
08:28:59 <lambdabot>    arising from the literal `84...
08:29:10 <zygoloid> wferi: fromChunks . return to convert strict -> lazy, mconcat . chunks to convert lazy -> strict
08:29:18 <coldtile_> > sum $ 24:35:15:26:7:84[]
08:29:19 <lambdabot>   No instance for (GHC.Num.Num ([a1] -> [a]))
08:29:19 <lambdabot>    arising from the literal `84...
08:29:35 <coldtile_> > sum (24:35:15:26:7:84[])
08:29:36 <lambdabot>   No instance for (GHC.Num.Num ([a] -> [t]))
08:29:36 <lambdabot>    arising from the literal `84'...
08:29:41 <wferi> Kim^Walkman, zygoloid: thanks, I'm trying those. Unfortunately I'm worried the problem is something else...
08:29:49 <doserj_> coldtile_: you are missing a :
08:29:50 <roconnor> > sum (24:35:15:26:7:84:[])
08:29:52 <lambdabot>   191
08:29:54 <gwern> orbitz: that's the xmonad style yes
08:30:05 <orbitz> i did not realize there were other styles
08:30:06 <gwern> orbitz: although hs-plugins originally did something very different
08:30:13 <orbitz> ok
08:30:40 <gwern> something about compiling a new object file and the nlinking it into the executable as a replacement. or something very lowlevel like that
08:30:40 <orbitz> is dynamic linking designed to maek loading shared object sont eh fly easier or is ti addressing a completely dfiferent issue?
08:30:44 <coldtile_> > odd $ sum $ 24:35:15:26:7:84:[]
08:30:45 <lambdabot>   True
08:32:13 <gwern> orbitz: iirc, the original motivations are upgrading used libraries without recompiling all using executables/liraries, and cutting down on duplication
08:32:22 <gwern> which would be very handy for ghc api-users...
08:32:36 <orbitz> cool
08:33:45 <tobe> i put a list like; let testnumbers = [1,2,3,4] in a module and want to load it by using :l why do i get an error?
08:33:47 <gwern> I mean 18 megs is a little much just for the api
08:33:56 <koeien> tobe: remove the "let" in your .hs file
08:34:04 <koeien> tobe: that is only syntax for ghci.
08:34:15 <tobe> ahhh
08:38:11 <wferi> zygoloid: thanks, fromChunks did it for me!
08:48:56 --- mode: irc.freenode.net set +o ChanServ
08:48:56 <Twey> osfameron: It's A-level
08:48:56 <osfameron> as I feared :-)
08:48:56 <Twey> A2, in fact, so this is for people who have already been taught programming for a year
08:48:56 <HaskellLove> is euler project down only for me or what?
08:48:56 <CalJohn> Twey: are you doing your a levels soon?
08:48:56 <Twey> (at the very least)
08:48:56 <Twey> CalJohn: I'm doing them now (again)
08:48:56 <stroan> HaskellLove: it's up for me
08:48:56 <BONUS> HaskellLove: they blocked it for you cause you were doing to many http requests :P
08:48:56 <koeien> HaskellLove: E_WORKSFORME
08:48:56 <HaskellLove> BONUS yeah cause i am solving too fast maybe
08:48:56 <CalJohn> well, if you're doing them for the reason of going to a university, i might advise you to do something other than CS, most universities ignore it
08:49:05 <CalJohn> at least, AFAIK
08:49:13 <HaskellLove> wierd i still get the:  If you are seeing this page, you are on the old server. Try clearing your browser cache and restarting your modem/router. Or you can open Command Prompt, and type in: ipconfig /flushdns Then retry. Thanks
08:49:15 <Twey> I'm not *just* doing CS
08:49:22 <b0fh_ua> Hi there! Can somebody please explain, why do I get the same results from these statements: Set.map (1-) $ Set.fromList [3,4,5,6,7,2,3,4] and Set.map ((-)1) $ Set.fromList [3,4,5,6,7,2,3,4]
08:49:24 <HaskellLove> CalJohn>	 you talk to me ?
08:49:40 <CalJohn> (when i say "ignore", i mean; they treat it like any other subject)
08:49:41 <Twey> And I've managed to obtain permission to do my A2s the same year as my ASes, so I'll be doing another next year
08:49:47 <CalJohn> HaskellLove: what's wrong?
08:49:50 <Twey> As opposed to what?
08:50:11 <HaskellLove> CalJohn>	 i ask if u talk to me about the college thing?
08:50:32 <CalJohn> well, admissions departments (supposedly, most are a bit of a joke) treat things like maths as being particularly relevant
08:50:36 <Badger> Twey: erk
08:50:43 <Twey> CalJohn: Ah, I've got one of those
08:50:44 <Badger> how many are you doing?
08:50:50 <osaunders> Is this good? http://codepad.org/4B4xpmT8
08:50:51 <lambdabot> osaunders: You have 1 new message. '/msg lambdabot @messages' to read it.
08:50:52 <Twey> Three this year
08:50:56 <Badger> ah
08:51:09 <Badger> that's still an interesting workload
08:51:10 <Twey> I have some left over from last time around
08:51:15 <HaskellLove> CalJohn>	dude you talk to me?
08:51:16 <Badger> (unless you find it all rather easy)
08:51:37 <CalJohn> HaskellLove: i'm unable to decipher what you are talking about.  if you want to ask me a question, just ask it :)
08:51:39 <Twey> Nah‚Ä¶ I know all the CS stuff already.  I basically just have to do this project and brush up on my knowledge of IEEE floats.
08:51:58 <HaskellLove> CalJohn>	 do you tell me Euler is worthless?
08:52:00 <Twey> (the level is incredibly low)
08:52:21 <CalJohn> what are you talking about?
08:52:25 <Badger> ahhh
08:53:16 * Badger didn't know you could actually take A-level CS
08:53:25 <CalJohn> Twey: btw, you say "obtain permission", but you can book exams with AQA any time you like.  you don't need anyone's permission
08:54:04 <CalJohn> Twey: schools just pay for them for you if they consent to it
08:54:04 <HaskellLove> CalJohn>	 oh u are talking to Twey :D ok sorry
08:54:26 <b0fh_ua> . «€
08:54:38 <emile_m> What is more suitable for processing raw binary data: arrays or bytestrings?
08:54:56 <CalJohn> HaskellLove: if you had formatted your messages with better grammar, this would have been obvious sooner
08:55:20 <osaunders> I don't see CS here: http://web.aqa.org.uk/qual/gce/ict.php?id=04&prev=
08:55:22 <kmc> @wn u
08:55:32 <lambdabot> *** "u" wn "WordNet (r) 2.0"
08:55:32 <lambdabot> u
08:55:32 <lambdabot>      adj : (chiefly British) of or appropriate to the upper classes
08:55:32 <lambdabot>            especially in language use
08:55:32 <lambdabot>      n 1: a nitrogen-containing base found in RNA (but not in DNA) and
08:55:34 <lambdabot> [5 @more lines]
08:55:49 <HaskellLove> I have a list and i wanna have a new lists that will contain 9 of the first list... * does not work, and += works for one list how to do that?
08:56:31 <Twey> CalJohn: Aye, I know that
08:56:43 <c_wraith> > concat $ replicate 9 [1,2,3]
08:56:45 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
08:56:52 <Twey> CalJohn: There's a whole bunch of organisation involved, though
08:56:54 <CalJohn> ok, i only mentioned it because schools rarely mention that
08:56:58 <Twey> Including a tutor required
08:57:07 <Twey> (in this case)
08:57:36 <Saizan> HaskellLove: in general, the documentation of the Data.List module is a good place to start looking at
08:57:58 <HaskellLove> Saizan thanks man really helpfull
08:57:59 <Saizan> HaskellLove: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-List.html
08:58:13 <HaskellLove> wow you even gave me a link, awesome
08:58:15 <kmc> Saizan, he's heard that before.  many times.
08:58:22 <osaunders> Ahh Computing == Computer Science to AQA.
08:58:23 <kmc> it doesn't seem to stick
08:58:23 <pozic> emile_m: bytestrings only operate on bytes. An unboxed array of machine sized elements would be the best.
08:58:50 <cathper> Uhm, given a list [i1,...,in], I want the list of lists [[i2,...,in], [i1,i3,...,in], ..., [i1,...,in-1]].
08:59:03 <HaskellLove> kmc man I solved 1 to 16 and 20 now i am onto 17,18 and 19 for today :D
08:59:23 <HugoDaniel> can i apply matching in a list ?
08:59:33 <HugoDaniel> like \[a,b,c,d,e,f] ->  ...
08:59:34 <koeien> > let f [] = []; f (x:xs) = xs ++ map (x:) (f xs) in f [1,2,3,4]
08:59:35 <HugoDaniel> ?
08:59:36 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
08:59:41 <kmc> HugoDaniel, yes
08:59:42 <koeien> > let f [] = []; f (x:xs) = xs : map (x:) (f xs) in f [1,2,3,4]
08:59:42 <pozic> HugoDaniel: that already works.
08:59:44 <lambdabot>   [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
08:59:55 <Twey> cathper: I cannot discern the pattern
08:59:58 <HugoDaniel> haskell rocks me completly :D
09:00:06 <kmc> Twey, leave one out i think
09:00:11 <Twey> Oh
09:00:16 <koeien> cathper: ^
09:00:19 <kmc> HugoDaniel, you can nest any sort of pattern arbitrarily deep
09:00:27 <HaskellLove> HugoDaniel don't let him rock you man
09:00:31 <cathper> Exactly, leave out the first in the first list, leave out the second in the second list, etc.
09:00:34 <emile_m> pozic: OK, thanks.
09:00:56 <pozic> emile_m: BUT there are not a lot of cases where you actually need that.
09:01:01 <Saizan> cathper: seen koeien's solution?
09:01:23 <pozic> emile_m: for example lots of stream computing is done with arrays in C, whereas in Haskell you would use lists.
09:01:31 <cathper> Saizan: Yep.
09:01:49 <pozic> emile_m: good compilers should recognize that it is really a loop and so the list never exists.
09:01:50 <cathper> I was just thinking if I could do it without explicit recursion.
09:02:03 <koeien> that's a good idea, if you can :)
09:02:24 <cathper> I haven't had any success so far :-)
09:03:24 <Saizan> mh, it's a paramorphism
09:03:31 <emile_m> pozic: I see. Then it would be better for me to stick with list-like structures.
09:03:51 <koeien> this is probably a FAQ, but darcs cabal should work with 6.12.1 right?
09:04:41 <Saizan> > let para f z [] = z; para f z (x:xs) = f x xs (para f z xs) in para (\x xs -> (xs ++) .  map (x:)) [] [1,2,3,4]
09:04:44 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
09:04:44 <dcoutts> koeien: you mean the cabal program? yes, the darcs version does.
09:05:08 <koeien> dcoutts: yes. ok, great, thanks
09:06:24 <HaskellLove> kmc please help man:take 10 $ iterate $ concatMap ((++ ["a", "b"])) [["a", "b"]]
09:07:24 <Saizan> > let para f z [] = z; para f z (x:xs) = f x xs (para f z xs) in para (\x xs -> (xs:) .  map (x:)) [] [1,2,3,4]
09:07:26 <lambdabot>   [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
09:08:25 <HaskellLove> Saizan is that for me?
09:08:31 <Saizan> no
09:08:53 <HaskellLove> kmc save me man
09:09:11 <HaskellLove> i will never swear here again kmc :(
09:09:54 <tass> Geez, still DDOS attacks going on? D:
09:10:26 <HugoDaniel> freenodeeeeeeeeeeeeeeeeeeeeeee
09:10:40 <Saizan> HaskellLove: asking insistently for help from a specific person is rude, also your line above isn't even a question
09:11:41 <HaskellLove> Saizan sorry, the question was above :take 10 $ iterate $ concatMap ((++ ["a", "b"])) [["a", "b"]]
09:11:48 <stroan> also in my experience you'll learn more from trying 10 wrong things
09:11:57 <HaskellLove> i need to multiply a list 9 times and have a new list
09:11:59 <HugoDaniel> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5335#a5335  help please!
09:12:22 <HugoDaniel> can someone help me out with that error and improving the readability of that map ?
09:12:58 <Saizan> HaskellLove: you've a '' in there, maybe you meant ""?
09:13:40 <HaskellLove> yes i have "", where did you see "
09:13:42 <tobe> i declared a type Date as an Tupel of (Day, Month, Year) which are also types. when I want to create a function like: functionname Date = ... I get an error
09:14:44 <Saizan> HugoDaniel: .... if name1 == "NULL" then toSql '' <- here
09:14:52 <Vulpyne> tobe: When you do functionname = blah you don't use the types. "blah :: Date -> something" is the type declaration for the function. "blah mydate = function body stuff" is the actual function definition.
09:14:59 <tobe> Not in scope: data constructor `Date' is the error
09:15:15 <Vulpyne> tobe: Because you're using a type where a type isn't expected.
09:15:26 <kmc> HaskellLove, i am tired of explaining every small error for you.  you've got to learn how to use the error messages, interpreter, and documentation together to solve your own problems.  you also need to spend more time trying things before giving up and asking here
09:15:49 <kmc> we are always happy to help beginners, but you've been at this for a while, and your questions have not changed form from "please help man:  [random guess at code here]"
09:16:29 <HaskellLove> kmc well i try like an hour to find out how to make a 9 times list out of one and cant do it :(
09:17:08 <kmc> what did you try?
09:17:18 <kmc> some functions from Data.List maybe?
09:17:50 <kmc> you need to read the documentation
09:18:01 <HaskellLove> well i tried take . iterate . map (++) kinda thing
09:18:14 <HaskellLove> tried concatMap too
09:18:18 <kmc> anyway i'll be back later
09:19:22 <Vulpyne> > replicate 3 [1,2,3]
09:19:24 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3]]
09:19:37 <tobe> Vulpyne: legalDate :: Date -> Bool legalDate Date =         True
09:19:45 <koeien> > replaticateM 3 [1,2,3]
09:19:46 <lambdabot>   Not in scope: `replaticateM'
09:19:48 <Saizan> HaskellLove: understanding the errors you get is a big part of learning, it tells you why what you tried is wrong, so that you'll be wiser in the future
09:19:50 <tobe> Vulpyne: that's how it looks like here in my cod
09:19:52 <koeien> > replicateM 3 [1,2,3]
09:19:53 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
09:20:06 <Vulpyne> tobe: Stuff that starts with a capital letter is always a type.
09:20:14 <Vulpyne> tobe: You probably want legalDate date = True
09:20:32 <emile_m> HaskellLove: Did you already read some textbook? If you didn't, try Real World Haskell or Haskell School of Expression.
09:20:49 <Vulpyne> tobe: Or you could pattern match the stuff out of the tuple in the function definition if you wanted, like legalDate (thing1,thing2,thing3) = True
09:21:01 <kmc> i'll also recommend LYAH despite the name ;)
09:21:03 <kmc> @where LYAH
09:21:04 <lambdabot> http://www.learnyouahaskell.com/
09:21:05 <tobe> Vulpyne: but i declared: type Date = (Day,Month,Year)
09:21:20 <emile_m> Latter is especially nice.
09:21:34 <tobe> where Day, Month, Year are also declared types
09:21:38 <Vulpyne> tobe: Right, so in that case pattern matching the tuple thing1 would be a Day, thing2 would be a Month, thing3 would be a Year.
09:21:51 <HaskellLove> read HSE and RWH and another book and programming in haskell... i stopped at complex stuff like monads emile_m
09:22:28 <tobe> Vulpyne: but why can't I use Date as parameter for legalDate now?
09:22:46 <emile_m> kmc: Oh yes, I is also great. I liked part about applicative functors and IO stuff (with "box that go the outer world and fetches data for you" :)
09:22:52 <Vulpyne> tobe: "legalDate :: Date -> Bool" -- That is where you specify the types.
09:23:02 <emile_m> s/ I / it /
09:23:24 <HaskellLove> found the command it is REPLICATE uahahahaha oh yes thank you lord almighty aaaaaaaaaaaaa
09:23:30 <Vulpyne> tobe: legalDate name_of_argument = if name_of_argument == whatever then stuff else otherstuff -- See how you name your argument in the actual function definition, you don't need to use the name of the type again.
09:23:46 <tobe> Vulpyne: the type of "legalDate"?!
09:24:00 <tobe> mom
09:24:07 <Vulpyne> tobe: You said the type of "legalDate" is "Date -> Bool" right?
09:24:14 <tobe> yeah
09:24:30 <Vulpyne> tobe: Do you know any other programming language, Python or something maybe?
09:24:52 <tobe> Vulpyne: no, just Java, C, PHP, ...
09:24:55 <emile_m> HaskellLove: Then you just need to play around with thing that you don't understand. Try implement it by yourself.
09:25:25 <HaskellLove> emile_m dude i am no euler 17 i aint no noob, i found the command i needed replicate aaaaaa
09:25:49 <Vulpyne> tobe: You know in C how you can prototype a function then define it later? This is the same essentially. Bool legelDate(Date); then when you define the actual function Bool legalDate(Date name_of_variable) { ... stuff }
09:25:57 <stroan> HaskellLove: do you know about Hoogle?
09:26:20 <BONUS> depends how you look at it. i've solved 80 euler problems and yet i still consider myself a noob
09:26:21 <ben> Bool legalDate(Date); in C would make it take an int if anything
09:26:50 <Vulpyne> ben: I was talking about the prototype. You don't have to give anything except the type in a prototype.
09:26:57 <HaskellLove> stroan i do but Data.List is huge so it took me while to find replicate
09:27:04 <Vulpyne> ben: Although you can give names as well if you want.
09:27:31 <tobe> Vulpyne: ahhhhhhhhhhhhh, now i understand :)
09:27:36 <ben> I think you have to give the name, and the type is optional
09:27:38 <Vulpyne> tobe: Sweet. :)
09:27:58 <Vulpyne> ben: That makes no sense. :)
09:28:02 <stroan> HaskellLove: but if you'd Hoogled for "Int -> a -> [a]" you could have found it quickly
09:28:08 <stroan> learning to hoogle is quite handy
09:28:17 <ben> Vulpyne: Well, I am not saying it does, but you would have to take it up with the C committee.
09:29:09 <Vulpyne> ben: Well, in addition to it not making sense, you are wrong.
09:29:21 <tibbe> Wow! Clojure seems to have been very successful with the individual funding model: http://clojure.org/funders
09:29:25 <HaskellLove> stroan yea that is very intuitive ... urgh urgh
09:29:29 <tibbe> dons: ^^
09:29:37 <tibbe> dcoutts: ^^
09:29:57 <dcoutts> tibbe: mm
09:30:03 <jmcarthur> conal: ^^ what tibbe said
09:30:06 <Vulpyne> ben: If you don't believe me - http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=14306
09:30:29 <ben> Your function is not taking any parameters.
09:30:42 * ddarius wonders if Clojure will still be around in five years.
09:31:10 <conal> jmcarthur: thx.  hm.  you gave me another related pointer recently, right?  i've forgotten what.
09:31:11 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
09:31:17 <ben> Vulpyne: compare http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=14307#a14307
09:31:24 <Vulpyne> ben: It's the same if you use types.
09:31:28 <ben> It is declaring the name, not the type.
09:31:35 <tibbe> jmcarthur: Just waiting for someone to say: ^^ what jmcarthur said
09:31:38 <jmcarthur> conal: that was it. this one is a status report of the same thing
09:31:54 <conal> jmcarthur: k.  :)
09:32:03 * ezyang is done with finals. 
09:32:18 <jmcarthur> conal: i've taken an interest in your venture because i would love to do something similar and want to learn what works well ;)
09:32:48 <jmcarthur> "something similar" means "mixing my research with commercialization in an open source friendly way"
09:32:49 <mux> ben: no, it's the name who is optional in a C function prototype; the type isn't unless you count the "defaulting to int" behaviour in, which has been abolished in C99
09:33:06 <emile_m> Does anyone know if haskell-mode in emacs has something like "hungry delete" found in C-like modes?
09:33:18 <Vulpyne> ben: Sigh! You're going to make me create a more complicated example?
09:33:25 <ben> mux: C99 hardly counts
09:33:39 <mux> ben: it doesn't really matter one way or the other
09:33:39 <b_jonas> for some reason my ghcidecl extension doesn't completely work with ghci 6.12.1: it gives some error messages when I enter :type () to the ghci command line
09:33:45 <b_jonas> I'll have to debug why it's like that
09:35:10 <Vulpyne> ben: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=14307#a14308
09:35:46 <ben> -Wall :|
09:36:09 <travisbrady> anyone have thoughts on a library if I need to build a really simple http based server? Hyena?
09:36:28 <Vulpyne> ben: Compiles cleanly with -ansi -pedantic -Wall
09:36:42 <Vulpyne> ben: If you still disbelieve, there's nothing more I can do to help you. :)
09:36:47 <ben> Right :)
09:36:51 <mux> just -Wall -W would have been better btw
09:36:53 <koeien> HJScript-0.4.4 fails to compile for me on ghc-6.12.1. I don't see why
09:36:54 <Vulpyne> I was a C programmer for many years though.
09:36:58 <mux> add in -Werror for the kicks
09:37:17 <jmcarthur> -Werror is overrated
09:37:29 <Vulpyne> Aww man, -W makes it complain about the unused parameter.
09:37:44 <mux> I don't see how it's overrated; it is of great help for preventing regressions in warnings
09:37:49 <koeien> is "rec" some new keyword?
09:37:50 <jmcarthur> i'd rather learn more flaws at once instead of having the compiler simply fail hard
09:37:56 <mux> Vulpyne: which is why most people use -W -Wno-unused-parameter :-)
09:38:12 <jmcarthur> mux: i never allow warnings to stick around, even just one. i don't see why others can't just follow the same discipline
09:38:21 <mux> jmcarthur: because people are... people?
09:38:37 <jmcarthur> if they are disciplined enough to use -Werror in the first place though...
09:38:39 <Saizan> koeien: istr it is if you enable arrow syntax
09:38:43 <Vulpyne> The problem with -Werror is new/different compiler versions produce different warnings, so you can have something that worked fine broken by a different compiler.
09:38:47 <mux> you don't seriously expect people to be really careful, do you? or dou you live in alice's wonderland? :-)
09:38:58 <koeien> Saizan: yeah, i saw {-# -fglasgow-exts #-}, which probably enables some magic
09:39:13 <mux> we've been tunring -Werror on for kernel builds and everywhere possible in FreeBSD, and that's been very helpful
09:39:21 <xerox> Saizan: I think it is the new recursive do syntax
09:40:04 <xerox> Instead of mdo {¬†x <- q; e } it's do { rec x <- q; e } (where q is recursive)
09:40:16 <b_jonas> I suspect it won't be easy to fix
09:40:18 <koeien> that'd explain it
09:40:36 <koeien> anyway, -fglasgow-exts is probably not a good idea anyway
09:40:45 <tobe> do i have to set brackets when i want to do something like that: if fst(myDate) <= 0 then                 False
09:40:48 <b_jonas> :-(
09:40:52 <b_jonas> someone fix my code
09:40:56 <Vulpyne> tobe: Nope.
09:40:59 <ezyang> tobe: You need an else
09:41:01 <koeien> tobe: No. it is bad style too
09:41:11 <ezyang> tobe: Actually, just get rid of the conditional
09:41:30 <Vulpyne> tobe: Just keep in mind if you do x y z it'll be treated like (((x) y) z)
09:41:54 <ddarius> @google von Neumann onion
09:41:56 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.98.8052&rep=rep1&type=pdf
09:42:37 <tobe> Vulpyne: looks like that in my code: http://nopaste.php-q.net/264282
09:43:26 <mux> then False?
09:43:29 <mux> gosh
09:43:57 <mux> you mean "fst myDate > 0"
09:44:04 <koeien> offtopic: what is the best way to make a diff for a maintainer? diff -ru orig/ patched/ ?
09:45:12 <b_jonas> could someone fix http://erxz.com/pb/22069 so it works for ghc 6.12.1 please? it used to work (mostly) in ghci 6.10.2
09:45:26 <mux> koeien: best way is to use the builtin diff feature of the VCS software that the maintainer is using, against the development branch :-)
09:45:39 <mux> koeien: other than that add -N for diffing new files, and -p is useful too if you're doing C
09:45:49 <b_jonas> or just integrate a feature that does this but better in the real ghci
09:46:01 <koeien> mux: yes, i see :) but it's not c.h.o, the hackage page doesn't display it, there is no README, and googling didn't help me
09:46:41 <Vulpyne> tobe: Are you saying it doesn't work? BTW "not (fst myDate <= 0)" could replace that whole if statement.
09:47:17 <mux> which is just the same as fst myDate > 0 as I've been saying
09:48:45 <Vulpyne> Durr, yeah. :)
09:49:13 <HaskellLove> is someone registered at euler project, the site is stil unavaliable for me, can some check if 21124 is the right answer for problem 17 please?
09:51:54 <tobe> Vulpyne: doesn't work, but it lokks like the error appears because Date is a tuple with 3 elements
09:51:59 <monkfish> HaskellLove: it is
09:52:13 <HaskellLove> monkfish seriosly?
09:52:17 <monkfish> yes
09:52:22 <HaskellLove> thank you
09:53:09 <Vulpyne> tobe: Ohh, yeah. You can only use fst and snd on tuples with 2 items.
09:54:22 <Vulpyne> tobe: What you probably want to do is pattern match the parts of the tuple out so you can use them, like this  - validDate (day,month,year) = day > 0
09:57:26 <tobe> Vulpyne: that's one thing i have to do (also that date doesn't have more days than the month can have), but how can i then check the day?
09:57:57 <HaskellLove> monkfish>can you please copy me the 18 and 19 problems in PM?
09:58:35 <Vulpyne> tobe: Something like: days > 0 && has_correct_number_of_days_for_month month days && other stuff
09:58:56 <Vulpyne> tobe: Obviously, you owuld have to define the has_correct_number_of_days_for_month function. :)
09:59:10 <koeien> it also depends on the year (viz. Feb)
10:00:33 <tobe> Vulpyne: I know, I already have all the function to do it, :) but I have to put them together
10:01:19 <Vulpyne> tobe: Well, you have Date, is that what your other function uses?
10:03:12 <tobe> Vulpyne: now i have the first part which looks like that: legalDate :: Date -> Bool legalDate (myDay, myMonth, myYear) =         if tag <= 0...
10:03:34 <tobe> "if myDay" is correct
10:05:31 <koeien> Saizan: syb-with-class-0.6.1 fails to compile on ghc-6.10, is this on purpose?
10:05:47 <Saizan> koeien: yes
10:05:49 <koeien> i.e. should we use syb-with-class-0.6 for ghc-6.10 and lower?
10:05:55 <Saizan> exactly
10:06:00 <koeien> ok. i'll patch happstack :)
10:06:23 <Saizan> ..you shouldn't need to, but cabal-install solver is not smart enough yet
10:06:27 <koeien> yeah
10:06:43 <koeien> right now it fails out-of-the-box
10:07:07 <koeien> i guess it's better if it works, even if we have to give a small hint
10:07:18 <Saizan> maybe i shoul've used #ifdef's
10:07:27 <Saizan> koeien: yeah, i guess too
10:08:50 <tobe> Vulpyne: maybe you can also help me with the days of a month. i already have a list with [(Jan, 31),(Feb,30),(Mar,31),...], but i need a function to match the month-name and lookup if the day of the day issn't bigger than the maximal days of the month
10:09:23 <Vulpyne> :t Data.List.find
10:09:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:09:36 <tobe> k
10:10:05 <Vulpyne> You could put them in a map instead, it would be more efficient to look them up then.
10:13:36 <bsod6666> you know in haskell you can call a function using itself as an argument like f f
10:13:56 <koeien> what type would that function have?
10:14:07 <bsod6666> using polymorphism can the same be done for prolog
10:14:12 <ezyang> :t id id
10:14:14 <lambdabot> forall a. a -> a
10:14:35 <koeien> ezyang: yeah, thought of that too. are there interesting examples?
10:16:57 <Boxo> :t \f -> f f
10:16:58 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:16:58 <lambdabot>     Probable cause: `f' is applied to too many arguments
10:16:58 <lambdabot>     In the expression: f f
10:17:17 <ezyang> Yeah, I think infinite types will make you unhappy
10:17:33 <ezyang> :t const const
10:17:34 <lambdabot> forall a b b1. b1 -> a -> b -> a
10:19:05 <Boxo> :t map map
10:19:06 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
10:19:27 <ezyang> :t foldl foldl
10:19:28 <lambdabot>     Couldn't match expected type `b -> [b]' against inferred type `[b]'
10:19:29 <lambdabot>     In the first argument of `foldl', namely `foldl'
10:19:29 <lambdabot>     In the expression: foldl foldl
10:19:44 <ezyang> :t (.) .
10:19:45 <lambdabot> parse error (possibly incorrect indentation)
10:19:49 <ezyang> :t (.) (.)
10:19:50 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
10:21:16 <Boxo> ($) ($) = id
10:21:44 <bsod6666> so anyone here know any prolog and whether an equivalent is possible?
10:22:41 <ddarius> bsod6666: Prolog is untyped.
10:23:01 <ddarius> And "f f" doesn't make sense in Prolog because it is first order.
10:23:04 <bsod6666> so how would
10:23:11 <bsod6666> ok so it couldnt be done?
10:23:24 <bsod6666> what about f(f),>
10:23:35 <bsod6666> (f(f)).?
10:23:43 <HaskellLove> http://www.tushar-mehta.com/misc_tutorials/project_euler/euler018.html I want to talk with someone about this solution for euler 18, anyone? i got just one question
10:24:17 <gwern> gr. I reinstalled gitit
10:24:23 <gwern> and my .lhss are *still( ugly!
10:24:33 <gwern> unlike http://gitit.johnmacfarlane.net/paste.lhs
10:24:58 <gwern> despair! despair! this world of software acting differently for different people has driven me to despair!
10:25:02 <bsod6666> darius what do you mean by first order?
10:25:03 * gwern hangs self from the nearest lambda
10:25:36 <ddarius> bsod6666: You can't pass predicates to predicates in Prolog.  Prolog models a first order logic.
10:30:58 <EvilTerran> in prolog, predicates map universe values to truth values; they're not values, so you can't pass them to themselves
10:31:17 <EvilTerran> s/prolog/a first-order logic/
10:31:53 <HaskellLove> gwern i had mental breakdown with git this morning, good luck man
10:40:01 <EvanR-work> ddarius: what order logic does haskell model ;)
10:40:33 <HaskellLove> EvanR-work high order dude
10:42:39 <Twey> gwern: <3
10:43:04 <Twey> I should re-watch that.  It's oddly cheering.
10:44:26 <koeien> Saizan: it may be a good idea to depend on base >= 4.2 if syb-with-class 0.6.1 doesn't compile on GHC's earlier than that?
10:45:06 <Saizan> koeien: it depends on the right version of template-haskell
10:45:23 <koeien> ah yes
10:46:19 * benmachine wonders how long it'll take archlinux repositories to get 6.12
10:49:04 <burp> 6.12 is out?
10:49:08 <koeien> yes
10:49:11 <ezyang> yup
10:49:11 <burp> oh nice
10:49:35 <koeien> but HP for 6.12 is not yet available. I keep using 6.10 until then
10:49:40 --- mode: ChanServ set +o dons
10:49:44 --- topic: set to '["GHC 6.12 is out: http://haskell.org/ghc", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
10:49:49 --- mode: ChanServ set -o dons
10:49:56 <dons> yeah, it is in testing. january or so we'll see the HP
10:50:04 <dons> so just for people that like beta testing
10:50:16 <koeien> yes, i am making sure that happstack is working on it :)
10:53:23 <dcoutts_> dons: we need to get new packages proposed right now
10:53:30 <dcoutts_> dons: otherwise there's not enough time
10:53:55 <dcoutts_> the GL situation is still in limbo
11:02:46 <ezyang> I should figure out whatsup with the Cont monad
11:04:54 <ezyang> btw, why are all of the haskell.org ghc haddock docs broken links?
11:05:01 <ezyang> i.e. http://www.haskell.org/ghc/staging/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
11:06:36 <Veinor> ezyang: I asked that earlier, no clue
11:06:41 <Veinor> you can replace latest with 6.10-latest though
11:06:50 <Veinor> I think it has to do with 6.12
11:07:07 <ezyang> maybe I'll ping haskell-cafe
11:07:17 <benmachine> is mtl still a ghc library in 6.12?
11:07:36 <benmachine> I remember some things being moved out
11:07:43 <Veinor> yeah, I considered asking them about it but figured it was probably brought up, given that I only joined recently
11:07:45 <koeien> afaik it's not
11:07:54 <benmachine> so then the links need to be fixed
11:07:55 <koeien> you can fetch it from hackage if need be
11:08:00 <benmachine> but the docs aren't supposed to be there
11:08:03 <Veinor> benmachine: unless the prelude has been moved out, I don't think that's the problem :P
11:08:21 <Veinor> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html 404s
11:08:34 <benmachine> http://www.haskell.org/ghc/staging/docs/latest/html/libraries/base-4.2.0.0/Prelude.html
11:09:02 <ezyang> Changing the URLs: fine with me
11:09:07 <Veinor> yeah, but mine's what I got from hoogle
11:09:08 <ezyang> Not making redirects: not OK.
11:09:14 <Veinor> and... yes, that
11:09:25 <ezyang> sent mail
11:12:49 <Raynes> Ze world is the fallin' apurt.
11:12:51 <Veinor> to haskell-cafe?
11:13:20 <ezyang> ja
11:13:24 <Raynes> Send hate mail to ever person imaginable. This is a travesty.
11:13:28 <Raynes> every*
11:13:34 <Raynes> /spellfail
11:16:54 <Craig`> hello again :D
11:19:37 <ezyang> Actually, after having explained the list monad in excruciating detail, I understand normal continuations
11:19:45 <ezyang> I'm not seeing the point of callCC though
11:20:23 <sproingie> abnormal continuations :)
11:20:29 <idnar> heh
11:20:56 <ezyang> sproingie: I sort of "feel" like I should be able to do it with plain ole return
11:21:02 <sproingie> callCC is like functional GOTO.  you can express any control flow you want with it
11:21:11 <sproingie> you just don't want to most of the time
11:22:26 <Veinor> ezyang: I didn't get your haskell-cafe mail yet. odd.
11:22:42 <ezyang> mitmail is slow
11:22:57 <Veinor> ah
11:23:07 <Veinor> slow on send, receive, both?
11:23:15 <ezyang> recv.
11:23:31 <Veinor> that makes reuse fights even more interesting!
11:23:35 <ezyang> sproingie: Is it really as strong as a GOTO?
11:24:17 <monochrom> ezyang: http://www.vex.net/~trebla/haskell/ContMonad.lhs has funny examples
11:24:22 <ezyang> hoo boy
11:24:33 <patch-tag> is there a better way to catch exceptions form inside a forkIO'd thread, than use IORef as here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14315#a14315
11:26:37 <ezyang> Ohh, will "return x1" not exit early?
11:26:55 <ezyang> whereas callCC $ \k -> k x1 will
11:27:07 <monochrom> > do { return 0; return 1 } :: [Integer]
11:27:08 <lambdabot>   [1]
11:27:19 <monochrom> return does not mean exit.
11:27:37 <ezyang> > do { x <- []; return 1; } :: [Integer]
11:27:38 <monochrom> A monad law about return in fact requires that return does not exit.
11:27:39 <lambdabot>   []
11:28:08 <ezyang> Under certain circumstances return sort of acts like a short circuit
11:28:11 <ezyang> waaaait
11:28:18 <ezyang> oh, no, that's false, isn't it ^_^
11:28:23 <Philonous> return >=> f == f
11:28:28 <patch-tag> ezyang maybe you're thinking of guard
11:28:37 <ezyang> > do { []; return 1; } :: [Integer]
11:28:39 <lambdabot>   []
11:28:46 <ezyang> patch-tag: Yeah, guard/mzero I think
11:28:50 <gwern> @hoogle liftM3
11:28:50 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
11:29:08 <ezyang> fancy that
11:29:43 <gwern> @hoogle (a -> b) -> a -> a -> a -> m a a a
11:29:43 <patch-tag> ezyang: which in the list monad is simply empty list (a source of bugginess for me, when I inadvertently fail in the list monad which is just an empty string, and doesn't give me the kind of failure behavior I want)
11:29:44 <lambdabot> No results found
11:29:48 <gwern> hm.
11:30:17 <ezyang> patch-tag: That seems like an odd fail case. Are you in the wrong monad, in that case?
11:30:19 <gwern> @hoogle (a -> b) -> (a, a, a) -> m a a a
11:30:20 <lambdabot> No results found
11:30:33 <patch-tag> ezyang: yes
11:30:33 <Veinor> @djinn (a -> b) -> a -> a -> a -> m a a a
11:30:33 <lambdabot> -- f cannot be realized.
11:30:37 <Veinor> bah
11:30:43 <gwern> @hoogle (a -> b) -> (a, a, a) -> Foo a a a
11:30:44 <lambdabot> Warning: Unknown type Foo
11:30:44 <lambdabot> No results found
11:30:52 <gwern> @djinn (a -> b) -> (a, a, a) -> Foo a a a
11:30:52 <lambdabot> Error: Undefined type Foo
11:31:03 <gwern> :t on2
11:31:05 <lambdabot> Not in scope: `on2'
11:31:06 <gwern> :t on
11:31:08 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:31:16 <patch-tag> ezyang: there would be no problem if I was using "error" instead of fail
11:31:25 <ezyang> Another random question: how does Haskell determine the kind of typeclasses?
11:31:28 <gwern> oh well
11:31:52 <monochrom> @src Monad
11:31:53 <lambdabot> class  Monad m  where
11:31:53 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:31:53 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:31:53 <lambdabot>     return      :: a -> m a
11:31:53 <lambdabot>     fail        :: String -> m a
11:32:05 <monochrom> I guess it looks at types of methods.
11:32:38 <PeakerWork> Why do Haskell classes have default methods that can be overridden for "optimization purposes"?   Wouldn't you want to override any function that has that class as context, potentially?  Why not use rewrite rules or what not for that purpose?
11:32:40 <ezyang> I was trying to explain it to someone else, but couldn't actually figure it out.
11:32:55 <PeakerWork> I don't see why (>>) should be in there, for example
11:33:36 <sproingie> rewrite rules are specific to GHC
11:34:00 <Veinor> what does fail do if you don't otherwise give an implementation?
11:34:07 <gwern> it fails
11:34:13 <Philonous> Veinor: exception
11:34:13 <sproingie> we really need another competitive haskell implementation
11:34:15 <monochrom> I don't have time for that debate. Arrow instances have convincing examples.
11:34:17 <gwern> @quote fail
11:34:17 <lambdabot> roconnor says: ivanm: I will keep the fail in the code
11:34:28 <Veinor> so fail = error by default?
11:34:30 <gwern> @quote fail
11:34:30 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
11:34:36 <Philonous> Veinor: Yes
11:34:39 <gwern> @quote is.fail
11:34:40 <lambdabot> No quotes match. I feel much better now.
11:34:40 <sproingie> depends on the monad
11:34:43 <gwern> dammit
11:34:48 <sproingie> @src Maybe
11:34:48 <lambdabot> data Maybe a = Nothing | Just a
11:34:52 <gwern> @remember anonymous fail is fail.
11:34:52 <sproingie> bah
11:34:52 <lambdabot> Okay.
11:34:54 <gwern> @flush
11:35:03 <sproingie> fail is Nothing in Maybe
11:35:22 <Veinor> > fail "epic fail!" :: (String -> Maybe a)
11:35:23 <lambdabot>   * Exception: epic fail!
11:35:30 <Veinor> er
11:35:32 <sproingie> huh
11:35:34 <ezyang> that's in th eReader monad
11:35:38 <Veinor> ah
11:35:41 <Saizan> PeakerWork: default overridable methods are much simpler and reliable than RULES
11:35:41 <ezyang> > fail "epic fail!" :: Maybe a
11:35:43 <lambdabot>   Nothing
11:35:48 <Veinor> yeah, that's what I meant
11:35:49 <sproingie> stop confoozing me
11:35:49 <tobe> i want to search in a list of tuples if any fst of that tuples matches a variable, but i can't find a way that works: currently: find (== myMonth) fst monthAndMaxDay
11:36:09 <ezyang> "Things that are not the same: Reader Monad, eReader Monad"
11:36:14 <Veinor> haha
11:36:17 <Veinor> The Monad eReader!
11:36:19 <ezyang> tobe: I think you want compositoin
11:36:28 <Saizan> PeakerWork: though yeah, it's often debatable what should go in the class, for example we could have join in Monad
11:36:31 <sproingie> The Monad Lisa
11:36:33 <tobe> ezyang: ok, i'll try
11:36:36 <gwern> @hoogle [(a,b)] -> (a->Bool) -> Bool
11:36:36 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
11:36:45 <Philonous> PeakerWork: You can defined second in terms of flip (a,b) = (b,a), i.e. second = arr flip <<< first <<< arr flip, but that
11:36:48 * gwern was not expecting that
11:36:51 <Philonous> 's really inefficient
11:36:51 <Veinor> @djinn [(a,b)] -> (a -> Bool) -> Bool
11:36:52 <lambdabot> Error: Undefined type []
11:36:55 <Veinor> bah
11:36:55 <ezyang> tobe: find ((== myMonth) . fst) xs
11:36:57 <mrsolo> is there some other site beside hoogle for library api search?
11:37:03 <gwern> mrsolo: well, there's hayoo
11:37:04 <Saizan> hayoo
11:37:08 <Veinor> heyo!
11:37:11 <gwern> not much on type-directed search but it does hackage
11:37:28 <mrsolo> thanks
11:37:50 <patch-tag> when I run this      main = do forkIO $ putStrLn "aaaaaaaaaaaaaa"; forkIO $ putStrLn "bbbbbbbbbbbbbb"        in ghci, the as and bs are out of order. However, when I run this as runghc buff.hs, the text order is unmangled. why is this?
11:38:21 <koeien> the output is undefined
11:38:44 <gwern> you use threading without synchronization and you have the gall to expect it to make sense? :)
11:38:48 <Philonous> patch-tag: Both is within the bounds of expected semantics
11:39:01 <mrsolo> is hayhoo slow?
11:39:10 <Veinor> ThabrabebaabadbaIbadba ba1ba5bab
11:39:10 <Veinor> ababaPrelude Control.Concurrent> ba
11:39:16 <Veinor> that's what it does for me in ghci :D
11:39:34 <kmc> anyone know when ThreadScope for 6.12.1 will be available?
11:39:36 <tobe> ezyang: and how can i return the value of snd?
11:39:36 <gwern> Veinor: where did the 'T' and 'I' come frmo?
11:39:37 <increpare> Cale: / mmorrow: was just reading through the haskell mailing list; saw the thread about doing a generic graph class - did anything ever come of that effort?
11:39:47 <gwern> and r, and 5, and...
11:39:49 <patch-tag> gwern: it outputs thread id
11:40:01 <patch-tag> (also mangled) :)
11:40:20 <gwern> :t forkIO
11:40:21 <lambdabot> Not in scope: `forkIO'
11:40:21 <Veinor> gwern: me mixing windows up, I think
11:40:25 <gwern> @hoogle forkIO
11:40:25 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
11:40:27 <PeakerWork> Saizan: the set of things that might have optimized implementations is an open one
11:40:33 <ezyang> tobe: compose a snd at the end
11:40:42 <PeakerWork> Saizan: too arbitrary to put it in the type class for this reason, IMO
11:40:43 <gwern> oh, I see. forkIO is the last value, so 'show' in ghci would print the ThreadId
11:40:50 <Veinor> ah, yeah
11:40:50 <mrsolo> guess it is.. hmm not found
11:40:57 <ezyang> snd $ find ((== "foo") . fst) xs
11:41:11 <PeakerWork> Philonous: its only inefficient if there's no inlining of all that :-)
11:41:12 <mrsolo> well will use my own then.. even though it is fugly :-)
11:41:15 <patch-tag> any hints for catching exceptions from inside a forkIO would be appreciated... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14315#a14315   this works, but I wonder if I'm "doing it wrong"
11:41:33 <PeakerWork> Philonous: Lots of functions are going to be non-optimal due to the class's extra indirection
11:41:44 <PeakerWork> Philonous: And once the indirection is removed, all sorts of optimizations might pop out
11:42:05 <Saizan> PeakerWork: on the other hand it doesn't really hurt to have them there, does it?
11:42:11 <PeakerWork> Perhaps GHC needs support for "specialized/optimized" versions of polymorphic functions for concrete types
11:42:26 <PeakerWork> Saizan: It makes the Monad type-class seem more complicated :)
11:42:42 <blackh> patch-tag: That's right.  You could think about using try.  Also, another good tip is to write it like this...
11:42:48 <Saizan> it does have a {-# SPECIALIZE .. #-} pragma.. not sure on the semantics..
11:42:59 * ezyang forgot what he was doing 
11:43:26 <blackh> patch-tag: do ; fail "problem" ; return False ; `catch` \e -> do ; putStrLn . show $ e ; return True
11:43:34 <PeakerWork> Saizan: I hope that SPECIALIZE doesn't contain Haskell code in a comment, that'd screw up editors -- I hope it just refers to an existing name :)
11:43:50 <blackh> patch-tag: where `catch` is indented more than the first do and less than the contents of the first do block
11:44:37 <Philonous> PeakerWork: first and second are semantically distinct, though. And sometimes I want to chose whether I prefer implementing negate or (-) for example. You propably could remove them, but then you are at the mercy of some optimisation that may or may not work in your case when you just as easily could have provided better functions
11:44:51 <Saizan> PeakerWork: it's the latter iirc
11:44:59 <blackh> patch-tag: One more thing: At least with Control.Exception (the new one) you'll need to specify the type of exceptions you want to catch, e.g. putStrLn . show $ (e :: IOException)
11:45:02 <tobe> ezyang: something similar to that: find ((== myMonth) . fst)  monthAndMaxDay . snd ?
11:45:27 <ezyang> tobe: Wrong order
11:45:38 <ezyang> unless your intended input is a tuple
11:45:42 <blackh> patch-tag: The compiler will complain otherwise.  Do this:  import Prelude hiding (catch) ... or in some other way make sure you're using E.catch
11:45:50 <benmachine> blackh: I never really understood how that worked, is it magic?
11:46:01 <benmachine> (the type annotation affecting the behaviour)
11:46:14 <PeakerWork> Philonous: I'm ok with defaults for the purpose of allowing to implement one subset or another
11:46:20 <tobe> ezyang: hmm
11:46:24 <PeakerWork> Philonous: I just don't like them as an optimization/specialization tool
11:46:30 <ezyang> Remember, function composition reads right to left
11:46:40 <tobe> ok...
11:47:01 <blackh> benmachine: I don't know how it works either, but it's definitely magic.  I assume it conceals a dynamic type check.  Maybe it's worth looking..
11:47:44 <benmachine> blackh: by magic I meant compiler-special-support rather than just sufficiently-advanced-haskell
11:48:27 <ezyang> "Any sufficiently advanced Haskell is indistinguishable from magic"
11:48:48 <benmachine> quite.
11:48:56 <ezyang> I wonder if I could define a MonadPlus instance for the Cont monad
11:49:22 <benmachine> (any haskell distinguishable from magic is insufficiently etc. etc.)
11:49:47 <ezyang> I guess not.
11:50:06 <ezyang> since Cont's mzero is a tad stronger
11:50:16 <kmc> ezyang, i defined a nondeterminism monad on top of Cont which was MonadPlus
11:50:19 <blackh> benmachine: Seems to be based on H'98 catch but I can't figure out how it works yet
11:50:26 <kmc> to do so i had to extend callCC to have a more polymorphic type
11:50:34 <ezyang> kmc: But I imagine that the generic Cont monad isn't?
11:50:41 <ezyang> Ooh. tricky.
11:50:41 <kmc> i don't thnk so
11:50:45 <kmc> :t callCC
11:50:46 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
11:50:58 <SamB_XP_> blackh: the IOError-only one ? really ?
11:51:01 * ezyang doesn't understand that type signature thang 
11:51:07 <SamB_XP_> I didn't know anyone actually used that
11:51:25 * kmc would rather it were:  forall a m.  (MonadCont m) => ((forall b. a -> m b) -> m a) -> m a
11:51:47 <kmc> but that's rank-3
11:51:50 <kmc> and hence not H98
11:52:02 <ezyang> oof
11:52:20 <benmachine> blackh: looks like almost all of Control.Exception is in #ifdef SOME_COMPILER
11:52:27 <ezyang> I actually don't understand how the two quantifications are different
11:52:29 <blackh> benmachine: I think the magic is in H'98 catch.
11:52:36 <benmachine> er, all the interesting bits
11:53:05 <SamB_XP_> ezyang: one of them gives you a polymorphic "return" value for your continuation function
11:53:18 <tobe> ezyang: so i think i have to put the "snd" on the very left position to get the other value but i always get errors
11:53:24 <SamB_XP_> benmachine: there's probably a reason for that ...
11:53:48 <ezyang> tobe: copypaste?
11:53:57 <ezyang> Also I'm not convinced find is being invoked properly
11:54:04 <ezyang> SamB_XP: The latter?
11:54:28 <benmachine> -- Notice that the usage of 'unsafePerformIO' is safe here.
11:54:37 <SamB_XP_> ezyang: the rank-3 one gives you a polymorphic continuation function, yes
11:54:39 <kmc> ezyang, when I callCC, i want to save that continuation and use it in multiple places as if it had type (a -> m b), (a -> m c), (a -> m d) for different b,c,d.  This is fine because the continuation never "returns" a value to the next thing in the monad bind -- it exits this chain of computations non-locally.  So the claimed return type is irrelevant, just like "undefined" or "throw"
11:54:46 * benmachine hmms
11:55:00 <ezyang> SamB_XP_: Ok. Whereas the first is not fully polymorphic.
11:55:00 <kmc> but with the standard mtl callCC, when I callCC i have to pick one fake-return-type for all continuation invocations
11:55:08 <tobe> ezyang: myDay >=  snd (find ((== myMonth) . fst) monthAndMaxDay)
11:55:33 <ezyang> kmc: Mmm, I think I see.
11:55:38 <kmc> ezyang, if you're not familiar with higher-rank function polymorphism, there are simpler examples
11:55:41 <kmc> that i can give
11:56:01 <ezyang> Doesn't the code you use to invoke the continuation get the return value, though?
11:56:21 <ezyang> tobe: what's the type of monthAndMaxDay?
11:56:28 <kmc> ezyang, when I runCont you mean?
11:56:39 <ezyang> Also, note that find returns a value in the Maybe monad, so you'll need some lifts
11:56:51 <ezyang> or at least a call of maybe
11:56:57 <ezyang> kmc: Yeah
11:57:26 <kmc> ezyang, if i do something like "callCC (\k -> k 'x' >>= bogus)", bogus is never called and produces no Cont action
11:57:37 <kmc> instead the whole callCC returns with a value 'x'
11:57:46 <kmc> so the supposed return type of (k 'x') is irrelevant
11:57:51 <ezyang> Oh, right!
11:57:55 <ezyang> Duh, it seems obvious now.
11:57:58 <tobe> ezyang: [(String, Integer), ...] like [(Jan, 31),(Feb, 30), ...]
11:58:02 <kmc> remember, we're in inside out land ;)
11:58:46 <kmc> tobe, Jan is not a string
11:58:47 <kmc> "Jan" is
11:58:50 <kmc> :t Jan
11:58:51 <lambdabot> Not in scope: data constructor `Jan'
11:58:51 <kmc> :t "Jan"
11:58:53 <lambdabot> [Char]
11:58:54 <ezyang> "That too"
11:58:56 <tobe> ezyang: i want to proff if the entered day for a data isn't greather the the maximal number of days for the month
11:59:16 <EvanR-work> data Month = Jan | Feb | Mar.....
11:59:22 <EvanR-work> daysIn Feb = 28
11:59:29 <EvanR-work> daysIn Jan = 31
11:59:29 <tobe> sorry, an enum
12:00:55 <ezyang> kmc: Hmm, but for you to not care about the "claimed" return value, you'd have to guarantee that you'll never exit locally
12:01:20 <ezyang> tobe: If you derived Eq, just drop the quotes
12:01:27 <kmc> ezyang, if k is a continuation, then (k v >>= f) never exits locally
12:01:32 <kmc> i.e. f will never be called
12:01:55 <tobe> ezyang: don't understand
12:01:55 <kmc> what we're discussing is whether such a k should be of type (forall b. a -> m b), or merely (a -> m b) for some pre-assigned b
12:02:05 <ezyang> kmc: But I could do something like "when"?
12:02:22 <kmc> ezyang, explain?
12:02:28 <kmc> :t when
12:02:30 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:02:35 <ezyang> tobe: well, it depends on myMonth, I guess
12:03:03 <kmc> ezyang, the use of "when" will force b ~ ()
12:03:12 <kmc> and thus it will be compatible with the other alternative, which is "return ()"
12:03:13 <kmc> @src when
12:03:13 <lambdabot> when p s = if p then s else return ()
12:03:20 <ezyang> kmc: Oh, that's right.
12:03:43 <kmc> and everything works out very nicely
12:03:48 <tobe> ezyang: myMonth ist just a type for Integer
12:04:09 <kmc> ezyang, do you know the thing about Peirce's Law, call/cc, and excluded middle?
12:04:10 <EvanR-work> tobe: why dont you do data Month = Jan | Feb...
12:04:45 <ezyang> kmc: I feel like there's a way for me to maybe call return, or maybe call k
12:04:56 <ezyang> kmc: Ah, no.
12:05:02 <ezyang> That sounds relevant :-)
12:05:12 <ezyang> tobe: I certainly hope myMonth is not a type
12:05:34 <tobe> √§hhhhh
12:05:35 <tobe> sorry
12:05:37 <kmc> ezyang, well, "when" will do that
12:05:51 <ezyang> oh!
12:05:59 <ezyang> yeah, I'm throwing out the Cont ()
12:06:02 <tobe> it's: data Month = Jan | Feb | Mar | Apr | May | Jun | Jul | Ago | Sep | Oct | Nov | Dec deriving (Eq,Enum,Show)
12:06:04 <ezyang> in my mind
12:06:21 <EvanR-work> tobe: yeah thats not an integer type
12:06:30 <tobe> i know, sorry :)
12:06:42 <ezyang> ok, back to the question at hand
12:07:05 <ezyang> I'm pretty sure (and we'll find out for certain if you post the error), that find is returning Maybe a, and you're treating it like a
12:07:41 <ezyang> oh hey, it actually is spelled Peirce
12:08:09 <tobe> ezyang: here is the first part of the error: Couldn't match expected type `(a, b)'            against inferred type `Maybe (Month, Day)'
12:08:16 <ezyang> YUP!
12:08:25 <ezyang> You should fix that ;-)
12:08:31 <tobe> really?
12:08:34 <tobe> :)
12:09:01 <tobe> i'm a big fan of errors
12:09:16 <pkrumins> i prefer to avoid them.
12:09:57 <ezyang> tobe: So, what are the semantics if you can't find what you're looking for in the list?
12:10:20 <kmc> ezyang, so type systems typically correspond to intuitionistic logics, via Curry-Howard.  in particular, you can't prove the Law of the Excluded Middle.  But if you add callCC :: ((a -> b) -> a) -> a to your language, your logic is now classical, because the type of callCC is Peirce's Law from logic, which can be used to prove excluded middle
12:10:48 <kmc> And the way you use callCC to build a "constructive" proof of EM is extremely cheeky
12:10:55 <kmc> I can explain that, if you like
12:11:09 <ezyang> just a sec, I need to look up "intuitionistic logic", "Curry-Howard" and "Law of the Excluded Middle", and "clasical logic"
12:11:23 <kmc> classical logic here means "non-intuitionistic"
12:11:34 <monochrom> P or (not P)
12:11:46 <kmc> you should probably spend a while wrapping your head around the Curry-Howard Isomorphism
12:11:48 <kmc> it's really cool
12:12:00 <monochrom> I mean: excluded middle is  P or (not P)
12:12:07 <ezyang> oh, I've totally seen excluded middle before
12:12:31 <b_jonas> you've probably seen classical logic too
12:12:36 <kmc> ezyang, the basic idea of curry-howard is that a type T stands for the proposition "Some value of type T exists", i.e. "T is inhabited"
12:12:38 <b_jonas> even if you didn't call it like that
12:12:50 <tobe> ezyang: i have to declare the return type as Maybe?!
12:12:53 <ezyang> kmc: Ok, I'll buy that
12:12:56 <ezyang> tobe: No.
12:13:00 <tobe> hmm
12:13:07 <monochrom> It becomes Either p (p -> Void)  if you translate to type.  You can't give a value of that type normally. You can if you use call/cc.
12:13:12 <kmc> then we can see a function of type (A -> B) as a proof that "A implies B", i.e. "If you give me a value of type A, I can prove to you that type B is inhabited, by giving you a value of type B"
12:13:13 <b_jonas> it's the curry-howard isomorphism that you don't meet unless you spend time on this channel when people throw commutative diagrams to each otehr
12:13:20 <b_jonas> s/to each other/at each other/
12:13:27 <kmc> importantly, this proof of implication is constructive; you actually explain how to get the B when you write your function
12:13:36 <ezyang> If you can convince yourself that find will always be Just x, you can force it with a non-complete match.  Otherwise, you should figure out what you need to do.
12:13:55 <ezyang> kmc: Oooh, neat
12:14:06 <ezyang> Ok, both of those make perfect sense
12:14:30 <kmc> ezyang, okay, so in logic we have things like "and" and "or" and "not".  how do we encode them as types?
12:14:39 <kmc> want to take a guess?
12:14:42 <ezyang> yes please
12:14:49 <ezyang> umm...
12:15:03 <ezyang> Is and something like a cartesian product?
12:15:04 <monochrom> guess "and" and "or" first.
12:15:21 <tobe> ezyang: but somehow i have to declare that it can return no result
12:15:49 <ezyang> tobe: Uhh... what was the big picture again?
12:15:49 <kmc> ezyang, that gets you "and".  a proof of (A and B) is a proof of A bundled with a proof of B, i.e. the tuple (A,B)
12:15:52 <kmc> what about "or"?
12:15:54 <b_jonas> no, guess true and false first?  if I may suggest.
12:16:00 <ezyang> Ooh, or is type foo = bar | baz
12:16:12 <kmc> Right, for example Either
12:16:20 <kmc> (pun not intended)
12:16:36 <ezyang> @quote kmc Right, for example Either (pun not intended)
12:16:37 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
12:16:39 <kmc> so products and sums of types correspond to conjuction and disjunction of propositions
12:16:46 <ezyang> @remember kmc Right, for example Either (pun not intended)
12:16:46 <lambdabot> Done.
12:16:51 <ezyang> cool.
12:16:54 <kmc> how about (Not p)?
12:16:56 <kmc> this is trickier
12:16:58 <ezyang> Hmmm
12:17:37 <tobe> ezyang: waht?
12:17:56 <ezyang> so... ~a && ~b == ~(a || b)
12:18:14 <ezyang> tobe: As in, you're doing this because you want to make a function that does X; what is this X?
12:18:44 <ezyang> I dunno if that's actually relevant
12:18:47 <tobe> ?
12:18:55 <ezyang> erm, that was re Curry-Howard
12:18:57 <kmc> ezyang, it's certainly true, but doesn't let you get rid of ~
12:19:02 <ezyang> yeah...
12:19:09 <tobe> ezyang: don't know :(
12:19:19 <ezyang> tobe: uh oh. That's a pickle.
12:19:24 <ezyang> tobe: Can you figure it out first?
12:19:42 <monochrom> Yeah, write an unambiguous specification first.
12:19:48 <ezyang> Maybe I want something like if a -> b; ~b then a
12:19:57 <ezyang> erm, ~a
12:20:05 <patch-tag> I added a draft 2 of catchErrorInForkIO: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14315#a14317   if someone could have a look, I would particularly like to know if the type signature (specialized to E.SomeException) seems reasonable, or will this restrict to SomeException and prevent from working more generally?
12:20:29 <kmc> ezyang, closer
12:20:42 <kmc> so note that one way to phrase "Not b" is "If b were true, an absurdity would result"
12:20:47 <kmc> does that help?
12:20:50 <Paczesiowa> if I have Constr1 :: Class b => Type a b, is it still GADT?
12:20:58 <ezyang> is it... bottom?
12:21:19 <kmc> ezyang, yeah, we need a type with no values in it
12:21:26 <|Jedai|> patch-tag: Normally, SomeException catch every exception
12:21:27 <kmc> which is often called bottom
12:21:30 <kmc> in Haskell more commonly called Void
12:21:43 <ezyang> Cool!
12:21:47 <kmc> unfortunately things like "undefined" and "fix id" will inhabit this type
12:22:09 <kmc> in general, languages where you can write partial functions do not provide sound proofs
12:22:17 <roconnor> newtype Void = Void Void
12:22:27 <kmc> or simply "data Void"
12:22:28 <byorgey> technically, bottom is usually used to refer to the nonterminating/error *value*
12:22:36 <ezyang> I've never heard that before... just "bottom" and "undefined" and "error"
12:22:36 <Paczesiowa> patch-tag: you mix catching exceptions with timeouts
12:22:38 <roconnor> data Void isn't H98
12:22:41 <byorgey> as opposed to Void which is an empty *type* (except it's not really empty because it has bottom)
12:23:00 <roconnor> is it Haskell 2010?
12:23:04 <Paczesiowa> yes
12:23:07 <roconnor> :O
12:23:13 <koeien37> EmptyDataDecls
12:23:14 <kmc> but we can restrict ourselves to the total-function subset of Haskell and get a constructive first-order logic of some kind
12:23:16 <blackh> patch-tag: OK - now I understand what you're trying to do.  The best thing to use is an MVar.
12:23:21 <byorgey> but since we're thinking about curry-howard, we can forget about bottom since that makes Haskell's logic unsound
12:23:24 <roconnor> it isn't 2010 yet :D
12:23:33 <kmc> i'll be back in a bit
12:23:37 <tobe> ezyang: i can try. what do you mean by "does X"? the return value?
12:23:50 <kmc> if someone wants to give the proof of Peirce => EM, feel free :)
12:23:56 <blackh> patch-tag: forkIO $ putMVar answer =<< E.try ioAction
12:24:34 <ezyang> ah, ok. I'm conflating types and values again, mumsie.
12:24:44 <ezyang> kmc: cool
12:25:00 <kmc> ezyang, i've seen the "bottom" symbol used for both things, confusingly
12:25:05 <kmc> more generally it's the bottom of a lattice
12:25:07 <blackh> patch-tag: Using the type SomeException causes it to catch everything.
12:25:10 <b_jonas> there's some tricky phrasing that's almost equivalent and works in h98 too, but I can't remember what it was
12:25:15 <kmc> it definitely stands for "absurd proposition" in logic
12:25:17 <ezyang> tobe: I think it's pretty clear from the code you posted that you want a boolean as output
12:25:20 <Paczesiowa> is there a testing tool that can handle type errors? ("foo () --> type error) ?
12:25:34 <ezyang> tobe: I'm interested in the kind of specification you would put in a haddock/javadoc style block
12:25:36 <kmc> and for the union of all types, which in Haskell has no values, except (the value) bottom
12:25:46 <kmc> err intersection
12:25:53 <ezyang> ok
12:26:11 <ezyang> a is the union of all types, no?
12:26:16 <ezyang> strictly speaking forall a. a
12:26:28 <monochrom> intersection
12:26:30 <byorgey> kmc: yes, I've seen bottom used for the empty type as well, I was just saying that in the context of Haskell it usually means the least-defined value
12:27:36 <byorgey> ezyang: it's the intersection of all types, since the only values of type forall a. a must also have every other type.
12:27:43 <tobe> ezyang: don't understand the second sentense
12:28:21 <roconnor> @djinn ((((Either a (a -> Void)) -> Void) -> (Either a (a -> Void))) -> (Either a (a -> Void))) -> Either a (a -> Void)
12:28:22 <lambdabot> f a =
12:28:22 <lambdabot>     case a (\ b -> Right (\ c -> b (Left c))) of
12:28:22 <lambdabot>     Left d -> Left d
12:28:22 <lambdabot>     Right e -> Right e
12:28:30 <byorgey> Paczesiowa: I don't understand what you mean.  Why not use a compiler to catch type errors?
12:29:20 <monochrom> hehe
12:29:20 <ezyang> tobe: For example, say I was writing a function isEvenOrThree I would describe this as "return True if the value is an even number or equal to three".  Somewhat contrived example, since the fn name makes it kind of obvious
12:29:22 <roconnor> kmc: ^^
12:29:23 <patch-tag> blackH: why is MVar better?
12:29:44 <ezyang> byorgey: Hmm. So what's a union type?
12:29:59 <Paczesiowa> byorgey: I'm writing a library and I would like to have a test-suite that would also test if certain expressions fail to typecheck
12:29:59 <monochrom> You can make the example less contrived by giving the function a better name.
12:30:23 <roconnor> kmc: granted djinn's case analysis is unnecessary
12:30:26 <Paczesiowa> byorgey: the best would be to also test for the particular type error
12:30:26 <quicksilver> Paczesiowa: just write "dummy = foo ()"
12:30:31 <tobe> ezyang: but what's the question now?
12:30:31 <blackh> patch-tag: Because the value becomes available exactly when the the forkIO'd thread exits
12:30:35 * Baughn again ponders the lack of untilM
12:30:35 <quicksilver> Paczesiowa: and the compiler will complain if it's a type error
12:30:55 <ezyang> Also, I suddenly feel as if I was on the verge of understanding what the hell XExistentialQuantification is about...
12:30:56 <byorgey> ezyang: it would be the type equivalent of 'or'.  The type  Int \/ Bool  would include Int and Bool values.
12:31:00 <b_jonas> or just use ghci
12:31:10 <byorgey> ezyang: 3 :: Int \/ Bool and True :: Int \/ Bool
12:31:14 <byorgey> ezyang: Haskell doesn't have them.
12:31:19 <ezyang> ah.
12:31:26 <patch-tag> blackh: Ah, however, I was specifically using this to check for a long running process that would raise an error within a couple seconds. (eg, start a web server, port is taken)
12:31:31 <Paczesiowa> quicksilver: yes. but that would require me to put every test case in a different file AND read those errors.
12:31:32 <byorgey> Haskell doesn't really have intersection types either, except for  forall a. a =)
12:31:41 <ezyang> so... what's the XExistentialQuantification about...
12:31:42 <patch-tag> so I guess in this case IORef is the right thing to use after all.
12:31:53 <ezyang> tobe: Can you post your sample code again? (what you have now)
12:31:58 <blackh> patch-tag: In that case, you might want to consider using an MVar anyway, because you can't rely on things taking a certain amount of time.
12:32:44 <quicksilver> Paczesiowa: the only way to have type errors at runtime is to embed the interpreter.
12:32:49 <tobe> ezyang: http://nopaste.php-q.net/264315
12:33:00 <quicksilver> Paczesiowa: see hint or plugins etc
12:33:10 <patch-tag> blackh: it's true this is error prone, however I can't think of a way around it. in happpstack, you run a web server and a  state thread simultaneously. if either fails, the app should exit.
12:33:26 <patch-tag> and you can't wait for the web server to exit to start your state thread
12:33:28 <ezyang> Right, so your function name is "legalDate", but I don't know what it means for a date to be legal for you
12:33:31 <ezyang> ^^ tobe
12:33:45 <ezyang> Oh, I see
12:33:46 <Paczesiowa> quicksilver: I know, I'm just asking if there is such a tool. I've seen some custom scripts with series of .in and .out files
12:34:04 <ezyang> tobe: Ok, here's what you want to do: instead of having a list of month/max day tuples, turn it into a function
12:34:13 <ezyang> With type Month -> Int
12:34:36 <ezyang> then legalDate becomes trivial
12:34:41 <tobe> ezyang: the problem is that the exercise i have to do is like that ;)
12:35:03 <byorgey> Paczesiowa: I don't know of any.
12:35:05 <blackh> patch-tag: Well it's perfectly OK to use an IORef in the way you're using it.
12:35:08 <tobe> ezyang: in the first part i created this list of tupels and should use it now
12:36:48 <HugoDaniel> im having very strange problems with HDBC
12:36:53 <HugoDaniel> can anyone help out ?
12:37:00 <HugoDaniel> im calling a postgresql stored procedure
12:37:15 <HugoDaniel> and i keep getting a SqlError in a insert
12:37:36 <HugoDaniel> but... ive even changed the stored procedure to stop having that insert
12:37:45 <HugoDaniel> and it still complaints about it
12:38:14 <sproingie> abstract question is abstract.  pastebin the relevant code and error.
12:38:28 <tofulivin> preflex: xseen Cale
12:38:28 <preflex>  Cale was last seen on freenode/#haskell 9 hours and 24 minutes ago, saying: I'd say that GHC has pretty decent SMP support as far as programming languages that actually exist go. :)
12:39:47 <HugoDaniel> sproingie
12:39:49 <HugoDaniel> ...bah
12:40:18 <dra1985> Can anyone help me out with for( loops ?
12:40:25 <roconnor> preflex: seen copumpkin
12:40:26 <preflex>  copumpkin was last seen on #haskell-blah 13 hours, 35 minutes and 17 seconds ago, saying: lol
12:40:35 <monochrom> for loops in which language?
12:40:39 <dra1985> java
12:40:46 <koeien37> ##java
12:40:49 <lunabot>  luna: parse error on input `]'
12:41:03 <PeakerWork> dra1985: how did you get into #haskell to ask about ##java ?
12:41:10 <dra1985> google failed me
12:41:12 <dra1985> xD
12:41:24 <monochrom> because we talked too much about how java is bad and google noticed.
12:41:26 <PeakerWork> dra1985: it doesn't tell you what channel you're joining?
12:41:28 <kmc> what did you google?
12:41:33 <PeakerWork> monochrom: really? :)
12:41:34 <dra1985> programming help chat
12:41:42 <koeien37> heh. we're famous.
12:41:45 <dra1985> clicked the chat link, brought me right to here
12:41:53 <monochrom> I guess we talked too much about programming too.
12:41:56 <increpare> Well you guys are pretty lovely for helping programmers.
12:41:56 <PeakerWork> this: http://gogloom.com/DIR?cat=84126&catdesc=Programming ?
12:41:57 <koeien37> try to enter "/join ##java"
12:42:03 <dra1985> lol thanks
12:42:03 <kmc> so you should learn Haskell instead of Java
12:42:10 <kmc> in which case, you're in the right place
12:42:13 <dra1985> whats haskell?
12:42:18 <koeien37> a programming language
12:42:20 <kmc> a fantastic programming language
12:42:23 <kmc> the best one
12:42:26 <kmc> :)
12:42:30 <nagnatron> in the whole world
12:42:30 <dra1985> ah, i probably will but right now i am in college
12:42:31 <koeien37> kmc: the best one in general usage at the time, imo
12:42:33 <dra1985> and they are teaching java
12:42:36 <blackh> dra1985: A really excellent programming language that doesn't have for loops. :)
12:42:37 <kmc> well yeah yeah etc.
12:42:45 <koeien37> dra1985: i learned Haskell while being a student at a university
12:42:45 <Baughn> @type forM
12:42:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
12:42:47 <PeakerWork> blackh: what do you call forM? :)
12:42:52 <kmc> dra1985, college is the perfect time to experiment with mind-altering things
12:42:55 <monochrom> I know people who learned haskell in highschool.
12:42:58 <PeakerWork> dra1985: Haskell will expand your mind far more than Java does :)
12:43:10 <blackh> PeakerWork: Except for forM !
12:43:12 <Baughn> dra1985: Maybe I should ask, how come you are here? You must have some interest.
12:43:16 <dra1985> alright I will swap to the java chan thanks guys!
12:43:20 <Tordmor> PeakerWork, The trouble is, if you expand something too much it explodes
12:43:32 <increpare> dra1985: wish you the best on your for loop travels
12:43:48 <monochrom> you will loop back to us
12:43:55 <dra1985> lol probably
12:43:56 <PeakerWork> blackh: btw, you might say we don't have breakable for loops (forM has no break) but then you have: runMaybeT . forM xs ...  and then they're breakable too :) (Though require some lifting!)
12:43:58 <koeien37> ask your prof about haskell sometime :)
12:43:59 <nagnatron> kmc: not sure what you mean by mind-altering things
12:44:06 <kmc> Haskell for one :)
12:44:13 <PeakerWork> Baughn: http://gogloom.com/DIR?cat=84126&catdesc=Programming
12:44:23 <monochrom> I wouldn't rely on an unknown prof on haskell
12:44:30 <dra1985> well
12:44:31 <koeien37> monochrom: nah, that's true
12:44:37 <koeien37> unfortunately :(
12:44:38 <nagnatron> kmc: I'm sure it's the first association for a person in college :D
12:44:42 <kmc> :)
12:44:44 <dra1985> i did /join ##java and nothing happened
12:44:45 <kmc> associate what you will
12:44:59 <koeien37> dra1985: google "irc client", install an IRC client and join ##java
12:45:05 <koeien37> connect it to irc.freenode.net
12:45:12 <PeakerWork> dra1985: OR: http://gogloom.com/QuakeNet/java/
12:45:13 <dra1985> oh lol gotcha
12:45:18 <Baughn> dra1985: Or just stick to haskell
12:45:22 <Baughn> That's simpler overall, really.
12:45:30 <koeien37> yeah. it makes so much more sense
12:45:40 <dra1985> yea java is pretty complicated
12:45:48 <dra1985> i missed one class and now i am totally lost
12:46:11 <increpare> dra1985: well you have to be careful about classes in java : P
12:46:12 <PeakerWork> Why do colleges teach mediocre languages with way too much redundant complexity that adds little academic value?
12:46:22 <kmc> PeakerWork, it's where the jobs are
12:46:24 <monochrom> hahaha
12:46:26 <c0n5pir4cy> Hello
12:46:29 <koeien37> PeakerWork: a devilish pact with industry
12:46:41 <monochrom> Because colleges are mediore too. At least those ones.
12:46:46 <PeakerWork> kmc: and?
12:46:55 <kmc> at my college they didn't teach any languages
12:46:57 <monochrom> And my keyboarding is mediocre as well.
12:47:01 <increpare> PeakerWork: yeah colleges are not just scholastic institutions anymore.  Anyway, there's plenty of fun stuff going on in java, if you look around.
12:47:10 <koeien37> kmc: in general, that's the approach to use imo
12:47:23 <kmc> they were just like "this is a compilers course, btw we'll be using ocaml so if you don't know ocaml you'd better learn it by next week"
12:47:24 <PeakerWork> increpare: I haven't looked much.. what fun stuff?
12:47:35 <koeien37> i learned the GCL and Delphi in my first year
12:47:36 <Badger> I wonder how many teach Haskell.
12:47:37 <increpare> PeakerWork: well antlr, for one, and a bunch of DSL work
12:47:39 <jmcarthur> kmc: wish mine was like that
12:47:51 <c0n5pir4cy> Mines does
12:48:03 <jmcarthur> i would have rather learned computer science rather than C, C++, and Java
12:48:12 <increpare> PeakerWork: do all those random non-java jvm languages count?
12:48:14 <jmcarthur> s/rather than/than/
12:48:23 <PeakerWork> increpare: Java is horrible in every benchmark I've ever seen (Difficult to distribute Java programs, they seem to execute very poorly [even poorer than Python programs, especially GUIs!], source code size is large (even larger than C in the shootout!), performance doesn't compete well, ...)
12:48:44 <koeien37> java is pretty fast
12:48:45 <jmcarthur> O;
12:48:51 <jmcarthur> *:o
12:48:53 <kmc> Java is great for allowing people of average intelligence to write boring business software
12:49:02 <kmc> that fills a pressing need in society
12:49:06 <PeakerWork> koeien37: Almost all Java GUI's I've seen have had responsiveness issues..
12:49:08 <kmc> and is economically and socially valuable
12:49:17 <koeien37> PeakerWork: that is not a property of Java
12:49:22 <jmcarthur> PeakerWork: java is very fast in server applications
12:49:29 <jmcarthur> PeakerWork: not so in GUIs
12:49:31 <kmc> hrm, java has no speed
12:49:33 <PeakerWork> koeien37: well, it did give the impression that one cannot (easily, at least) write a responsive GUI in Java
12:49:34 <jmcarthur> well, not responsive
12:49:35 <HaskellLove> anyone has solved euler 18 i have some question about the triangle layout?
12:49:35 <kmc> different implementations have speed
12:49:47 <koeien37> kmc: yeah, languages have no speed
12:49:50 <monochrom> @quote monochrom euler
12:49:50 <lambdabot> No quotes match. Are you on drugs?
12:49:54 <jmcarthur> kmc: isn't Java also the name of an implementation?
12:49:55 <monochrom> Oh well.
12:49:57 <PeakerWork> kmc: Java has implementations except the Sun one? That can actually execute Java programs?
12:49:59 <kmc> and there are vastly different implementations used commercially, including hardware acceleration
12:50:03 <increpare> PeakerWork: that doesn't mean there's not interesting stuff going on in it in spite of those issues.
12:50:12 <EvanR-work> java has speed equal to 47 miles per hour
12:50:14 <ezyang> OpenJDK is getting close
12:50:24 <ezyang> it's still mostly the wrong answer, but less so than below
12:50:25 * increpare excuses himself for the double-negative
12:50:28 <PeakerWork> increpare: right, treat that as a btw on Java :)
12:50:28 <monochrom> IBM is a big java implementer too. I have a friend at IBM Toronto Lab involved.
12:50:29 <koeien37> i consider it a feature if you don't need a PhD in CS to write programs in it (re "average intelligence")
12:50:44 <kmc> right
12:50:51 <ezyang> s/below/before/
12:50:56 <PeakerWork> koeien37: I wonder how many in #haskell have PhD's
12:50:57 <increpare> koeien: I don't know any programming language that requires a PhD to program.
12:50:58 <kmc> at the same time, it's hyperbolic to claim that you need a PhD in CS to write programs in Haskell
12:51:00 <rooostaj> intelligence is only a measure of interest
12:51:10 <kmc> increpare, i'd wager most Agda programmers have or are working on PhD's
12:51:15 <koeien37> PeakerWork: i was exaggerating (I don't have a PhD either. Then again I can't program.)
12:51:17 <kmc> whether it's "required" is another issue
12:51:19 * c0n5pir4cy faints at the thought of java actually being fast
12:51:23 <c0n5pir4cy> JamVM
12:51:25 <c0n5pir4cy> >
12:51:26 <HaskellLove> having Phd makes you a worthy programmer? Yeah whatever...
12:51:29 <c0n5pir4cy> Brainfuck :)
12:51:37 <increpare> kmc: that doesn't mean it *requires* one.
12:51:56 <PeakerWork> HaskellLove: in languages like Haskell, a good PhD might actually help..
12:51:59 <koeien37> i was just referring to "java enabling programmers of average intelligence". I consider this a feature
12:52:10 <kmc> koeien37, of course... i meant it that way
12:52:12 <kmc> i was not being sarcastic
12:52:14 <koeien37> kmc: ok.
12:52:15 <kmc> but realistic
12:52:19 <koeien37> my sarcasm detector was off, then
12:52:39 * drhodes points at naval gazing
12:52:40 <HaskellLove> Phds are not ninjas, they are just humans
12:52:53 <markluffel> human ninjas!
12:52:58 <b_jonas> you need a phd for haskell?
12:52:59 <increpare> HaskellLove: some PhDs are probably ninjas.
12:53:00 <monochrom> I guess "java enabled those programmers" was true because python did not exist and perl had too much $@#.
12:53:01 <koeien37> HaskellLove: zomg. i even know a few, would never suspect that of them :(
12:53:05 <b_jonas> so that's why I don't get haskell
12:53:10 <kmc> b_jonas, i don't think anyone has claimed that in the present discussion
12:53:21 <b_jonas> sure, it only helps
12:53:47 <Badger> drhodes: seen any good carriers lately?
12:53:47 <clarkb> I thought the role of undergrads was to do the programming for the grad students ;)
12:53:48 <monochrom> FWIW haskell enables them now because we have good tutorials and books, for example RWH.
12:53:48 <kmc> koeien37, that said, a language which caters to average intelligence has to make different design choices than one which expects a lot from the programmer
12:53:51 <PeakerWork> some languages allow you to utilize "theoretical" knowledge more directly than others.. in this aspect, Haskell is good for PhD's :)
12:53:53 <kmc> i'm glad that both kinds of language exist
12:54:02 <koeien37> kmc: yes. C also expects a lot from the programmer
12:54:06 <kmc> exactly
12:54:07 <koeien37> in a different sense than Haskell
12:54:14 <kmc> writing good C code may be as hard as writing good Haskell code
12:54:19 <PeakerWork> monochrom: it might be harder to learn still, as in, less possible to learn incrementally
12:54:26 <kmc> writing good C++ code is certainly much harder, and for stupid reasons of wasted effort
12:54:29 <rooostaj> imperative programming does seem to flow more naturally to most people
12:54:40 <kmc> PeakerWork, what you forget is that you can get a PhD in "workarounds for C++ design flaws"
12:54:45 <koeien37> rooostaj: i also have this hunch. But it's not more than a hunch imo
12:54:52 <PeakerWork> monochrom: I think Haskell has more monolithic "learning packages" that you must gulp together -- whereas in Python, you can start writing (shitty) code and incrementally improve
12:54:55 <koeien37> although i personally prefer functional programming
12:55:52 <HugoDaniel> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5337#a5337  HELP PLEASE!!
12:56:00 <HugoDaniel> :(
12:56:03 <rooostaj> koeien37: makes you wonder if a different childhood education would make different types of programming "thought" easier or harder
12:56:04 <PeakerWork> Its pretty hard for a total beginner to not understand types, not understand IO and >>=, not understand "do" blocks -- and still start writing things that seem to work
12:56:12 <HugoDaniel> this is really a nice WTF, ive been around this for hours!
12:56:31 <markluffel> what's the best way to interface with a heavily templated c++ library (like CGAL) from haskell?
12:56:40 <kmc> markluffel, via C wrappers
12:56:46 <koeien37> rooostaj: it may be an interesting research subject for some psychologists
12:56:47 <PeakerWork> You kinda have to understand the basics of types, IO, >>=, and the use of those to start writing useful things -- pretty big package to swallow non-incrementally, as a beginner
12:56:53 <kmc> make some non-templated functions and declare them extern "C" { ... }
12:57:03 <rooostaj> koeien37: :D
12:57:18 <kmc> interfacing C++ from any other language (including different C++ compiler on same platform) is absolute madness
12:57:25 <koeien37> rooostaj: i am not sarcastic :P
12:57:31 <kmc> so best to make it into a nice C api first
12:57:32 <monochrom> Imperative programming flows more naturally if your desire is to display a window, show some buttons, let user click, then have things happen.  Note how wonderfully this says nothing about Project Euler problems.
12:57:59 <koeien37> monochrom: then for "most" practical programming problems in existence today, it seems a good fit
12:58:08 <koeien37> i don't think that necessarily follows though
12:58:14 <PeakerWork> monochrom: I think even then "Denotational Programming" (e.g: Phooey) is a more "natural" representation, but may be harder to learn
12:58:36 <increpare> I've noticed more and more recently people 'porting' libraries rather than building interfaces.  I guess it's not possible to hook up a dll to AS3, say, and awkward to do in java, but it still strikes me as an unusual way of doing things.
12:58:45 <rooostaj> koeien37: ha ha :). Having to retrain your brain halfway through life has to be tougher than learning as a kid. This is true with almost anything... programming is no different
12:59:05 <rooostaj> koeien37: something about the way we learn at a young age makes certain thought processes easier
12:59:13 <ezyang> increpare: porting is brainless. you don't have to make hard design decisions
12:59:24 <monochrom> I am no longer sure what is "most". It seems to vary greatly with which group of people you hang around with.
13:00:00 <increpare> ezyang: unless you're trying to do it idiomatically
13:00:02 <monochrom> If you hang around with HugoDaniel, you probably never see either "click button things happen" or project euler.
13:00:14 <ezyang> increpare: "Most don't"
13:00:18 <ezyang> "They regret it later"
13:00:47 <increpare> well porting between object-oriented languages or procedural languages can often be done relatively painlessly.
13:00:48 <ezyang> Writing a quality port is no less difficult than writing software from scratch, perhaps a little more tedious and less rewarding
13:01:02 <increpare> (from what I've seen)
13:01:08 <HugoDaniel> why monochrom ? :P
13:01:18 <monochrom> Because you're doing database programming.
13:01:28 <patch-tag> HugoDaniel: a better paste would be...
13:01:37 <patch-tag> the two strings that actually get sent to he database
13:01:54 <patch-tag> if you can trap that somehow, you can probably debug this yoself
13:03:49 <HugoDaniel> patch-tag: i found out now...  functions are overloaded by argument type in postgresql
13:06:07 <lispy> I'm trying to cabal install the new cabal-install
13:06:09 <HugoDaniel> now i found out that i have loads of different functions with the same name :P
13:06:11 <lispy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14320#a14320
13:06:11 <HugoDaniel> thats why
13:06:21 <c0n5pir4cy> @djinn (a -> b) -> Tree -> Tree
13:06:22 <lispy> Anyone know why the unix package is failing on ubuntu?
13:06:22 <lambdabot> Error: Undefined type Tree
13:06:25 <patch-tag> lispy: you know about bootsrap?
13:06:36 <HugoDaniel> monochrom: im coding in haskell for life... that happens to be databases right now :)
13:06:44 <patch-tag> might want to try running that before cabal install
13:06:50 <lispy> patch-tag: I have a working  ghc + cabal-install.  I shouldn't need it
13:06:59 <HugoDaniel> if you want to pay me to code project euler, then ill gladly do it :D
13:07:06 <lispy> I'm trying to upgrade from hackage, normally cabal install cabal-install works
13:07:18 <monochrom> I want project euler to die, if you really want to know.
13:07:56 <cads> Is the arrow category of X, arr(X), the same as the category of functors from the interval category into X, func(2, X)?
13:08:14 <cads> "Wolfram|Alpha isn't sure how to compute an answer from your input"
13:08:15 <byorgey> lispy: but you're trying to upgrade to cabal-install-0.6.4 on ghc 6.12.1 ?
13:08:28 <byorgey> those don't work together.
13:08:35 <byorgey> what version of cabal-install do you have currently?
13:08:43 <lispy> oh right, the new library is cabal not cabal-install
13:09:10 <lispy> byorgey: my cabal-install is HEAD
13:09:28 <lispy> I think I'll cease and desist as 'cabal install cabal' says I'm up to date
13:09:32 <byorgey> right, I thought so, you were trying to downgrade cabal-install =)
13:10:09 <lispy> byorgey: oooh
13:10:19 <lispy> byorgey: still, funny that the unix package is broken?
13:11:13 <byorgey> lispy: well, who knows?  maybe cabal-install-0.6.4 requires a version of unix that is now old?
13:11:37 <lispy> byorgey: thanks.  That makes some sense
13:12:03 <lispy> byorgey: I have 2.4.0.0 installed
13:12:12 <lispy> byorgey: and the one cabal install wanted is 2.3.something
13:12:14 <HaskellLove> can someone please talk with me about this euler solution of 18, i dont quite get it: http://www.haskell.org/haskellwiki/Euler_problems/11_to_20
13:12:19 <byorgey> ah, yep
13:12:31 <tommd> Hummm, ghc-6.12 fails to make my program an order of magnitude faster.  Some might say that my expectations were too high, but I blame the GHC team for being too skilled and thus raising my expectations.
13:12:50 <sproingie> i didn't get my pony either
13:12:51 <Igloo> tommd: Your program must be buggy
13:12:58 <tofulivin> > Nothing
13:13:00 <lambdabot>   Nothing
13:13:02 <tommd> heh
13:13:40 <HaskellLove> anyone? :(
13:14:02 <lispy> tommd: try 'unsafePerformIO'
13:14:18 <lispy> tommd: it's experimental and fast, right?  That's the unsafe bit?
13:14:34 <HugoDaniel> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5338#a5338
13:14:36 <HugoDaniel> evil :)
13:14:57 <tommd> lispy: I already use that
13:15:31 <tofulivin> > (drop 1 . drop 2)Nothing:Nothing:Nothing:[]
13:15:33 <lambdabot>   Couldn't match expected type `[a]'
13:15:33 <lambdabot>         against inferred type `Data.Mayb...
13:16:04 <koeien37> > (drop 1 . drop 2) $ Nothing:Nothing:Nothing:[]
13:16:05 <lambdabot>   []
13:16:07 <tofulivin> (drop 1 . drop 1)[Nothing,Nothing,Nothing]
13:16:08 <Baughn> Say. Shouldn't there be a haskell-platform package on hackage?
13:16:14 <tofulivin> > (drop 1 . drop 1)[Nothing,Nothing,Nothing]
13:16:16 <lambdabot>   [Nothing]
13:16:26 <Heffalump> Baughn: I think there's concern that people might depend onit
13:16:35 <Heffalump> i.e. other packages
13:16:52 <Baughn> That would be bad?
13:17:02 <Heffalump> yes, they should declare precise dependencies
13:17:38 <Baughn> So I guess my "* > 0.1" dependency is bad.
13:17:41 <PeakerWork> Using @check is a wonderful way to avoid thinking :)
13:17:57 <ezyang> callCC seems to... expose the guts of the continuation monad
13:18:07 <c0n5pir4cy> can anyone help me with this problem, I'm trying to make map for a tree but i cant seem to get it to work
13:18:09 <c0n5pir4cy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14321#a14321
13:18:11 <roconnor> @type callCC
13:18:13 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
13:18:16 <tofulivin> > let lambdabot = Nothing in (drop 1 . drop 2) $ lambdabot:lambdabot:lambdabot:[]
13:18:18 <lambdabot>   []
13:18:26 <roconnor> ezyang: since it is parametric over call MonadCont, it can't really expose any guts
13:18:30 <koeien37> c0n5pir4cy: x is a terrible name for a function
13:18:42 <byorgey> Baughn: besides, that doesn't really make sense.  The Haskell Platform includes things like a compiler and cabal-install.  You wouldn't install it from Hackage since you'd already have to have a compiler and cabal-install first.
13:18:42 <roconnor> ezyang: anymore than "get" exposes the guts of state monads.
13:18:46 <ezyang> roconnor: By guts I mean the continuation, I guess
13:18:50 <ezyang> yeah :-)
13:18:54 <kakeman> what is like the best haskell book written?
13:18:55 <c0n5pir4cy> I know, i was just trying to troubleshoot, badly :)
13:19:00 <b_jonas> best for waht?
13:19:03 <byorgey> kakeman: I give up, what?
13:19:04 <tofulivin> > flip "roconnor"
13:19:06 <lambdabot>   Couldn't match expected type `a -> b'
13:19:06 <lambdabot>         against inferred type `GHC.Ty...
13:19:08 <koeien37> c0n5pir4cy: oh. your type sig doesn't make sense
13:19:09 <PeakerWork> c0n5pir4cy: you don't seem to actually need the special casing for the empty list case
13:19:15 <tofulivin> :t flip
13:19:16 <ezyang> oh; right; callCC makes things strictly more powerful
13:19:17 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:19:25 <koeien37> c0n5pir4cy: "GTree" is not a type, "GTree a" is
13:19:26 <PeakerWork> c0n5pir4cy: GTree is a type constructor, not a type
13:19:41 <c0n5pir4cy> ahh
13:19:47 <byorgey> kakeman: =)  what sort of book are you looking for?
13:19:49 <Baughn> byorgey: Oh, I always keep a cabal-install binary around for bootstrappin after I wipe ~/.{cabal,ghc}.
13:20:03 <Baughn> byorgey: Which seems to happen about every other week
13:20:08 <byorgey> Baughn: heh
13:20:22 <tofulivin> :t reverse
13:20:22 <Baughn> cabal install haskell-platform would save me some time. :P
13:20:23 <lambdabot> forall a. [a] -> [a]
13:20:32 <byorgey> Baughn: well, I still think having the HP on Hackage would be a type error
13:20:38 <koeien37> HP is a metapackage
13:20:50 <Baughn> So we need a meta-hackage
13:20:55 <koeien37> yeah !
13:21:01 <dcoutts_> there's no problems with meta-packages on hackage
13:21:15 <dcoutts_> the problem with cabal install haskell-platform, is that cabal does not consider deps on tools
13:21:24 <dcoutts_> and the HP depends on happy, haddock and alex
13:21:37 <Baughn> That's going to be fixed though, right?
13:21:40 <dcoutts_> in otherwords, it'd fail to install on a clean machine, so that's no good
13:21:50 <tofulivin> > (reverse . reverse) "roconnor"
13:21:51 <lambdabot>   "roconnor"
13:21:59 <dcoutts_> Baughn: along with the other 100 TODO items, sure, just not any time soon
13:22:00 <lispy> The treatment, well lack thereof, of tool deps really confuses me with cabal sometimes
13:22:24 <dcoutts_> lispy: sure, we did the most important one first
13:22:26 <Baughn> dcoutts_: As I recall, you already got around to the pony.
13:22:57 <lispy> dcoutts: one thing that remains really unclear to me about hackage is if it's dead?  There is this other version where you're supposed to do new features but we're not running it?
13:23:13 <dcoutts_> lispy: it's running on a test server
13:23:35 <PeakerWork> Baughn: I get a perverted sense of fun from fixing "cabal install" issues by installing tools and the likes
13:23:37 <dcoutts_> lispy: the existing hackage-scripts cgi stuff is in maintance mode
13:24:40 <lispy> I respect not breaking the hackage that we all know and love, but the maintenance-mode-while-we-reinvent-hackage bit seems like a strategy we should avoid
13:25:12 <dcoutts_> lispy: any strategy would work if we had any available development time
13:25:23 <dcoutts_> lispy: the current one is hard to add features to
13:26:31 <dcoutts_> lispy: in absolute terms, there's not a lot left that needs doing on the new server to bring it to feature parity
13:26:42 <dcoutts_> http://sparky.haskell.org:8080/packages/ghc-core-0.5
13:27:12 <dcoutts_> for example ^^, mostly just missing the doc generation infrastructure
13:27:25 <dcoutts_> the code do allow doc uploads is nearly done, but there's no client to do them automagically
13:27:40 <rooostaj> I'm working on euler#5, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14322#a14322 , it is a bit too inefficient *just started haskell yesterday*. Looking for pointers
13:28:30 <kakeman> byorgey: i'm trying to learn haskell without steps backwards... i want to learn the right way and after that do what i want to
13:29:31 <roconnor> > lcm [1..20]
13:29:33 <lambdabot>   No instance for (GHC.Real.Integral [t])
13:29:33 <lambdabot>    arising from a use of `GHC.Real....
13:29:49 <roconnor> > foldr1 lcm [1..20]
13:29:51 <lambdabot>   232792560
13:29:57 <rooostaj> roconnor: :) jerk
13:30:02 <lispy> dcoutts: I would have assumed it uses cabal to build the docs
13:30:12 <roconnor> is that the answer?
13:30:31 <rooostaj> foldr1 lcm [1..10]
13:30:34 <rooostaj> oops
13:30:52 <roconnor> > foldr1 lcm [1..10]
13:30:56 <rooostaj> it will be
13:31:00 <lambdabot>   2520
13:31:17 <rooostaj> let me check though
13:31:37 <dcoutts_> lispy: well yes, of course, it just needs doing. A bit of scripting to get a client to pull down the latest uploaded packages, build them and upload the docs.
13:31:44 <xerox> (that would be the case one uses foldl1' I think)
13:31:48 <roconnor> > foldl1' lcm [1..20]
13:31:48 <lambdabot>   232792560
13:31:57 <roconnor> xerox: good point
13:32:00 <rooostaj> roconnor: it is correct, but any tips for me? (that's the important part)
13:32:11 <roconnor> rooostaj: learn about fold an lcm?
13:32:27 <rooostaj> roconnor: :D *slaps face*
13:32:47 <roconnor> maybe [a..b] notation as well if you have time :D
13:33:01 <rooostaj> roconnor: was hoping for someone to bash my code :).... guess the answer is just use lcm dummy
13:33:02 <kakeman> so i need a book that admits of no doubt
13:33:26 <roconnor> rooostaj: oh, you pasted code
13:33:27 * roconnor looks
13:33:44 <rooostaj> roconnor: gracias
13:34:09 <roconnor> rooostaj: you can drop the upper bound (product r)
13:34:22 <roconnor> rooostaj: [(last r)..] will work just as well
13:34:40 <kakeman> that tells everything, every meaningful detail
13:34:43 <rooostaj> roconnor: it will only evaluate up until the first element of the list correct?
13:34:54 * hackagebot upload: dom-lt 0.1.0 - The Tarjan-Lengauer graph dominators algorithm. (MattMorrow)
13:35:05 <roconnor> rooostaj: yes, head will only evaluate upto the first cell of the list.
13:35:31 <EvanR-work> @src head
13:35:31 <lambdabot> head (x:_) = x
13:35:32 <lambdabot> head []    = undefined
13:35:37 <EvanR-work> \o/
13:36:02 <roconnor> rooostaj: I'd use all instead of recursion to write isDivisible
13:36:16 <roconnor> rooostaj: and finally I'd scrap the whole thing and just use lcm :D
13:36:28 <rooostaj> roconnor: let me try "all" just for giggles
13:37:21 <roconnor> @src lcm
13:37:21 <lambdabot> lcm _ 0     =  0
13:37:21 <lambdabot> lcm 0 _     =  0
13:37:21 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
13:37:38 <xerox> @src gcd
13:37:39 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
13:37:39 <lambdabot> gcd x y = gcd' (abs x) (abs y)
13:37:39 <lambdabot>    where gcd' a 0  =  a
13:37:39 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
13:38:01 <rooostaj> that's elegant
13:38:02 <xerox> good old euclid.
13:38:07 <rooostaj> yeah, lol
13:38:42 <roconnor> xerox: would it be more efficent to write a version of gcd/lcm that operatates on lists rather than folding the existing gcd/lcm?
13:38:42 <monochrom> Functional programming makes it possible to be elegant. Pure imperative programming forces you to swap mutable variables.
13:38:43 <EvanR-work> whats the difference between rem and mod
13:38:57 <roconnor> EvanR-work: negative numbers
13:38:58 <Necoro> is there some way of having pattern matching on Set? such that I can have a recursive function on a set?
13:39:01 <monochrom> Of course no one practices pure imperative programming.
13:39:18 <Paczesiowa> Necoro: view patterns
13:39:28 <dcoutts_> tommd: speaking of hackage, did we ever get pureMD5 fixed? I don't recall
13:40:22 <xerox> roconnor: if the definition would be inductive, it'd be the same
13:40:50 <roconnor> xerox: I'm trying to imagine something more clever
13:41:04 <rooostaj> roconnor: how to use "all" to say all "(n mod ELEMENT == True) ELEMENTLIST" when all is of type (a -> Bool) -> [a] -> Bool
13:41:09 <rooostaj> roconnor: i ran into the problem earlier
13:41:20 <roconnor> xerox: but I am failing.  I can only imagine euclidiean algorithms for two numbers.
13:41:35 <roconnor> rooostaj: == 0
13:41:54 <roconnor> all (\x -> n `mod` x == 0)
13:41:54 <xerox> roconnor: and the fact that gcd(a,b,c) has been defined as gcd(a,gcd(b,c)) in all math courses ever isn't helping right, now, I see that
13:42:00 <rooostaj> roconnor: that's what i meant, sorry, but
13:42:10 <monochrom> all (\e -> n `mod` e == 0) yourlisthere ?
13:42:12 <rooostaj> roconnor: ahhhh. is that a lambda function?
13:42:22 <roconnor> @pl (\e -> n `mod` e == 0)
13:42:22 <lambdabot> (0 ==) . (n `mod`)
13:42:39 <Necoro> Paczesiowa: probably won't do ... I'm not allowed to use extensions :|
13:42:46 <EvanR-work> monochrom: pure imperative, isnt that like assembly language ;)
13:42:48 <roconnor> or you can be more "clear" by writing "all ((0==) . (n `mod`))" :D
13:42:56 <monochrom> Yes.
13:43:16 <rooostaj> roconnor: if \x -> creates a function then I understand that completely.... the "." however, is confusing
13:43:23 <roconnor> rooostaj: yes the \x ->  is makes an anonymous function
13:43:29 <roconnor> @src (.)
13:43:30 <lambdabot> (f . g) x = f (g x)
13:43:46 <monochrom> You can safely focus on (\e -> n `mod` e == 0) for now.
13:43:54 <rooostaj> roconnor: ah ok, so the "." is f of g. very nice. thanks roconnor
13:43:54 <roconnor> rooostaj: the . solution is kinda a joke
13:44:04 <rooostaj> roconnor: lol don't mess with my mind
13:44:06 <roconnor> rooostaj: f composed with g
13:44:15 <roconnor> rooostaj: sorry :D
13:44:18 <EvanR-work> monochrom: then the menuet os guys practice pure imperative ;)
13:44:33 <xerox> roconnor: it also does parallelize nicely.
13:45:12 <roconnor> xerox: you mean folding lcm parallelizes because lcm is associative?
13:45:15 <xerox> that will get you sub-linear time
13:45:30 <xerox> exactly.
13:45:52 <roconnor> > foldl' lcm 1 [1..20]
13:45:54 <lambdabot>   232792560
13:46:08 <Necoro> or - let's put the question in another way: is there some kind of fold, which allows to modify the structure which is folded?
13:46:27 <rooostaj> roconnor: damn my algorithm is slow :) [1..20] is just too much for it
13:46:47 <roconnor> rooostaj: yes
13:47:08 <rooostaj> roconnor: such is life. thanks!
13:47:31 <roconnor> @type traverse
13:47:33 <lambdabot> Not in scope: `traverse'
13:47:33 <xerox> I should revert to 6.10.4 in order to try and use `par` though, 6.12.1 doesn't have the  parallel  package
13:47:48 <roconnor> @hoogle traverse
13:47:48 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:47:49 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
13:48:12 <monochrom> I stay with 6.10.4 and wait for haskell platform for 6.12.1
13:48:56 * quicksilver only upgraded from 6.6 to 6.8 a couple of months ago ;)
13:49:19 <monochrom> I sincerely believe telling end-users "get cabal-install through darcs" is wrong. As wrong as telling end-users "get kernel source from git".
13:49:44 <quicksilver> or "get your cold medecine from the research lab" ? ;)
13:49:55 <ben> quicksilver: More like factory outlet, really
13:50:16 <monochrom> Hehe
13:50:25 <Heffalump> monochrom: end-users shouldn't be using GHC 6.12 yet
13:50:32 <Heffalump> though perhaps that's not been properly communicated
13:51:15 <monochrom> It has been properly communicated. I recommend waiting for haskell platform for 6.12.1 too.
13:52:24 <monochrom> OTOH one could just forget about cabal-install.
13:53:00 <xerox> I was tricked by the exclamation point on the GHC homepage  "GHC 6.12.1 Released! [download]"
13:53:24 <fizruk1> what advantages do arrows provide when used for parsing?
13:53:51 <monochrom> I don't think there is any advantage.
13:53:57 <Heffalump> static information
13:54:22 <fizruk1> what is that static information?
13:54:50 <quicksilver> in principle, an arrow parser can self-optimise in certain ways
13:54:57 <quicksilver> like it can build first-token dispatch tables
13:54:58 <fizruk1> static - means considered at compile time?
13:55:03 <quicksilver> a monad parser could never do that.
13:55:16 <Paczesiowa> quicksilver: any papers on that topic?
13:55:23 <quicksilver> Swierstra-Duponcheel
13:56:28 <quicksilver> http://scholar.google.co.uk/scholar?cluster=11652141838373865120&hl=en&as_sdt=2000
13:56:31 <quicksilver> I think that's the one
13:56:34 <quicksilver> haven't check though :)
13:57:53 <Paczesiowa> quicksilver: thanks
14:02:11 <fizruk> quicksilver: my internets were broken... could you give me link one more time?
14:02:40 <Paczesiowa> http://scholar.google.co.uk/scholar?cluster=11652141838373865120&hl=en&as_sdt=2000
14:03:16 <fizruk> thanks :)
14:04:35 <Paczesiowa> there are no arrows in that paper:/
14:05:35 <quicksilver> hmm it must have been a later observation that that parser could be represented as an arrow
14:05:38 <quicksilver> or something very like it
14:06:08 <Heffalump> quicksilver: Hughes' paper on arrows uses Swierstra-Duponcheel as a motivating example
14:06:24 <quicksilver> looks like it was Hughes that
14:06:30 <quicksilver> ah, as Heffalump says :)
14:06:42 <quicksilver> it was hughes that observed that the SD parser could be viewed as an arrow
14:19:09 --- mode: irc.freenode.net set +o ChanServ
14:19:09 <Cale> ezyang: So what callCC f does is to pass that function as a parameter to f
14:19:09 <ddarius> @djinn-add Cont r a = (a -> r) -> r
14:19:09 <lambdabot> Cannot parse command
14:19:09 <ddarius> @djinn-add type Cont r a = (a -> r) -> r
14:19:41 <ddarius> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
14:19:41 <lambdabot> f a b = a (\ c _ -> b c) b
14:20:00 <xerox> , 1+1
14:20:02 <lunabot>  2
14:20:13 <xerox> , time foldl1' lcm [1..50000]
14:20:14 <lunabot>  luna: Couldn't match expected type `(a1 -> a1 -> a1) -> [t] -> a'
14:20:17 <Cale> ezyang: The practical upshot of it is that  callCC (\done -> ...)  will give you a function 'done' which you can use like the 'return' in imperative languages, to return a value from the callCC immediately.
14:20:46 <Cale> ezyang: and of course, the mind-twisting bit is that this function is first class and you can have as many of them as you like
14:20:59 <ezyang> What I'm trying to figure out is why, if I do callCC (\done -> done "foo" >> done "bar") only the first one happens
14:21:09 <ezyang> I know it works that way "continuation", but I don't know how.
14:21:10 <xerox> roconnor, if the list is ordered:
14:21:12 <xerox> , time $ foldl1' lcm [1..50000]
14:21:17 <lunabot>  (2.789576,422297863844990477011660576230799852004412342353373216763947765...
14:21:19 <xerox> , time $ foldl1' (flip lcm) [1..50000]
14:21:21 <ezyang> Cale: That's mind-twisty :-)
14:21:22 <lunabot>  (1.528768,422297863844990477011660576230799852004412342353373216763947765...
14:21:31 <Cale> ezyang: Think of done as being like the return in an imperative language, and it's clear
14:21:41 <sergdf> newbie question: when i do Data.Map.insert and assign to a new variable, does the entire tree structure get copied? are there optimizations that prevent this being O(n)?
14:22:18 <Cale> sergdf: It's O(log n), since most of the tree structure is shared between the new tree and the old
14:22:20 <ezyang> Yeah. I guess I want a deeper understanding of what lets me do that
14:22:24 <mauke> sergdf: Haskell never copies a value
14:22:31 <BlackRockFailed> what's the max. weight of a broken black rock that is measured 0.5m diameter * 1.5m tall?
14:22:35 <lament> mauke: never!
14:22:41 <sergdf> ok, thanks team
14:22:51 <ezyang> I'm ok with short-circuiting in Maybe/Failure because I know how the internal monadic threading works
14:22:53 <Cale> sergdf: essentially it just needs to create a new path from the root of the tree down to the element which you inserted
14:22:58 <ezyang> and I'm not really ok with it in continuations
14:23:01 <Saizan> ezyang: f a b = a (\ c _ -> b c) b <- here that _ pattern discards the continuation given to "done "foo"" and instead calls the one captured by callCC
14:23:07 <osaunders> Is it possible to build strict data structures in Haskell?
14:23:10 <Cale> sergdf: and all the other subtrees are the same, so why bother making a copy? :)
14:23:19 <ezyang> Saizan: studying
14:23:23 <sergdf> Cale: ah, that does make sense
14:23:36 <Heffalump> osaunders: yes, just sprinkle ! everywhere
14:23:53 <osaunders> :t (!)
14:23:54 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
14:23:58 <Heffalump> not that ! -)
14:24:03 <Heffalump> the one in
14:24:08 <Heffalump> data Foo = Foo !Int !Char
14:24:21 <Saizan> ezyang: rename that to "callCC f k = f (\a _ -> k a) k" for clarity maybe
14:24:29 <osaunders> I don't know what ! means.
14:24:31 <ezyang> hmmm
14:24:39 <Heffalump> it means "make this argument strict"
14:24:41 <Cale> sergdf: Of course, this picture is complicated a little by balancing, but the balancing is handled in such a way that you only ever do a little bit of balancing at a time, so you get a constant-width swath around that path which might be affected.
14:25:15 <ddarius> Does ! notation work in GADT syntax?
14:25:24 <Heffalump> I believe so
14:26:12 <lispy> IIRC, I've seen that
14:26:35 <Cale> xerox: That's really funny.
14:26:42 * xerox nods =)
14:27:27 <rooostaj> @src span
14:27:27 <lambdabot> Source not found. Where did you learn to type?
14:27:30 <xerox> roconnor: ah you were gone. Funny behaviour:
14:27:32 <xerox> , time $ foldl1' lcm [1..50000]
14:27:34 <ezyang> So...
14:27:38 <lunabot>  (2.82657,4222978638449904770116605762307998520044123423533732167639477651...
14:27:40 <xerox> , time $ foldl1' (flip lcm) [1..50000]
14:27:43 <lunabot>  (1.576761,422297863844990477011660576230799852004412342353373216763947765...
14:28:15 <xerox> fliptimization, for ordered lists. eheh.
14:28:18 <ddarius> @src lcm
14:28:19 <lambdabot> lcm _ 0     =  0
14:28:19 <lambdabot> lcm 0 _     =  0
14:28:19 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
14:28:25 <rooostaj> lol coin that word
14:28:25 <sergdf> :r
14:28:37 * ddarius knew it would be defined in terms of gcd.
14:28:48 <ezyang> If f doesn't jump to the continuation, it returns a normal continuation which gets folded into the surrounding cps code
14:28:58 <rooostaj> , time $ foldl1' lcm [50000,49999,..1]
14:28:59 <lunabot>  luna: parse error on input `..'
14:29:00 <ezyang> but if it does... I guess I'm kind of fuzzy there
14:29:05 <rooostaj> , time $ foldl1' lcm [50000,49999..1]
14:29:11 <lunabot>  Killed.
14:29:14 <rooostaj> fail.
14:29:26 <ezyang> the new continuation (\a, _ -> k a) gets called, and something mysterious happens
14:30:00 <ezyang> ... does f ever return?
14:30:01 <ddarius> ezyang: It gets called with the internal expressions continuation which is discarded and then f's continuation is invoked.
14:30:12 <ddarius> ezyang: Nothing ever returns in CPS.
14:30:18 <ezyang> bingo!
14:30:24 <ezyang> ok, suddenly that makes a lot more sense
14:30:29 <xerox> , time $ foldl1' (flip lcm) [50000,49999..1]
14:30:33 <lunabot>  (2.486622,422297863844990477011660576230799852004412342353373216763947765...
14:30:36 <xerox> doh.
14:30:54 <rooostaj> hmm
14:31:03 <ezyang> wait, but that's not strictly true
14:31:15 <ddarius> Of course it isn't.
14:31:20 <sergdf> Cale: wow. whoever was able to actually write that efficiently deserves a high five (re: balanced tree)
14:31:41 <ddarius> ezyang: CPS code isn't the only code you have.
14:31:42 <ezyang> lies!
14:31:49 <ezyang> :-)
14:32:55 <eivuokko> I've noticed that everytime I write cps-enabled code, the mindset sticks and it pollutes other places as well... ;-)
14:33:14 <ddarius> eivuokko: CPS is a (potentially) global transformation.
14:33:32 <ddarius> (Like converting to monadic style.)
14:33:48 <eivuokko> Yes, I know.  I was talking more about the psychological effect.
14:36:29 <DigitalKiwi> what is CPS?
14:36:39 <mauke> preflex: ? cps
14:36:40 <preflex>  CPS stands for continuation passing style
14:36:45 <mauke> whoa
14:36:55 <mauke> I didn't add that
14:37:13 <ddarius> preflex is learning on its own!
14:39:20 <Alpounet> btw, I'm wondering why there is so much enthusiasm around CPS
14:39:52 <ddarius> Continuations are very powerful.  It's equivalent to enthusiasm around monads.
14:40:12 <ezyang> "if you don't explode your brain first"
14:40:27 <EvanR-work> cps is easily converted to assembly language? or something?
14:41:11 <ddarius> CPS is still a far way away from assembly, but it does make some things more explicit.
14:41:18 <kmc> CPS is a way of simulating having first-class continuations, in a language without them
14:41:26 <kmc> first-class continuations are useful for all manner of control flow structures
14:41:37 <monochrom> At some point someone screamed "CPS eliminates stack usage" and everyone got excited. But it merely transfered that to heap usage.
14:41:39 <mauke> CPS would let me write sleep() in javascript
14:41:40 <ddarius> A third use for CPS is specifying evaluation order.
14:41:42 <kmc> less important in Haskell,  because of laziness and monads and other stuff
14:41:48 <kmc> still useful
14:41:53 <mauke> and get rid of alert()
14:42:21 <kmc> in particular, when you want a function to be able to "return" in several different ways and possibly more than once, CPS is a viable option
14:42:52 <lament> monochrom: BASIC eliminates stack usage
14:42:56 <monochrom> OTOH CPS is a nice way to treat functional I/O
14:43:16 <mauke> System.IO.IO is basically continuation based
14:43:26 <dcoutts_> CPS is nice for mediating monadic code with lazyness
14:44:48 <ddarius> dcoutts: Can you provide a small example of what you mean?
14:45:03 <dcoutts_> ddarius: binary Put monad
14:45:43 <ddarius> I was hoping for a small, inline example of code.
14:45:49 <dcoutts_> ddarius: here: http://blog.well-typed.com/wp-content/uploads/2009/12/strong-types-pure-functions.pdf
14:46:00 <dcoutts_> about half way in
14:47:39 <knobo> Looks like the definition of bind for lists is (l >>= f = concatMap f l). Sholdn't it be (l a >>= f = concatMap f a) ?
14:47:42 <rooostaj> > [1..10]
14:47:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:48:06 <mauke> knobo: no, but what would 'l a' do there?
14:48:22 <monochrom> "l a >>= f" doesn't typecheck.
14:48:34 <dcoutts_> and it's not a valid pattern
14:48:39 <ddarius> It doesn't even get to type checking.
14:48:45 <rooostaj> @src mod
14:48:45 <lambdabot> Source not found. That's something I cannot allow to happen.
14:48:59 <rooostaj> @src rem
14:49:00 <lambdabot> Source not found. My brain just exploded
14:49:14 <ddarius> > let f (x y) = x in f 3
14:49:15 <lambdabot>   <no location info>: Parse error in pattern
14:49:16 * gwern wonders what xor is in latex; \xor doesn't seem to be it
14:49:32 <ddarius> gwern: What operator do you consider xor?
14:49:37 <ddarius> oplus?
14:49:39 <gwern> ddarius: the circle with cross
14:49:46 <doserj_> \otimes
14:49:58 <gwern> huh
14:50:03 <gwern> is that not a common symbol for XOR?
14:50:03 <BallsOfSteel> but i do you consider xor?
14:50:19 <ezyang> I noticed that the lambda \b, _ -> k b sort of is equivalent to \b, _ -> return b. Is this a red herring or an important fact?
14:50:19 <BallsOfSteel> the new continuation (\a, _ pattern discards the continuation given the new lambda features in c++1x
14:50:22 <ddarius> gwern: Its reasonably common, but so are several other possibilities.
14:50:22 * monochrom is grateful for various syntax checking and type checking. It debunks many a nonsensical idea quickly.
14:50:29 <gwern> ddarius: what are the alternatives?
14:50:29 <BallsOfSteel> ddarius: the circle with cross
14:50:48 <EvanR-work> c++1x D:
14:50:49 <rooostaj> gwern: i usually see cross circle like you gwern, but i don't know that there is a "standard".... i've seen it several ways
14:50:53 <Saizan> ezyang: it isn't equivalent to that
14:51:02 <ezyang> oh, right, it isn't
14:51:07 <monochrom> ‚äï is \oplus; ‚äó is \otimes
14:51:07 <BallsOfSteel> \otimes
14:51:22 <gwern> (I mean, I don't want to put \otimes into my flashcard system to memorize as == XOR if it is an obscure xor and not common)
14:51:25 <monochrom> There is really no consensual symbol for xor.
14:51:44 <EvanR-work> gwern: in my ee courses it was O+
14:51:47 <rooostaj> i use circle-plus
14:51:47 <BallsOfSteel> how do you can use synaptic for both
14:51:53 <gwern> hm
14:51:53 <EvanR-work> O<backspace>+ ;)
14:51:58 <BallsOfSteel> my gcc testsuite failures ;)
14:52:00 <ddarius> gwern: Obviously there's C's notation, but that isn't common in formatted texts.  I'd be unsurpised if \oplus isn't used often since xor is very close to addition.
14:52:01 <monochrom> Proof. I saw ‚äï in the books I read. You see ‚äó in the books you read. There is no consensus.
14:52:01 <BallsOfSteel> ‚äï is \oplus; ‚äó is \otimes into the part with cr?
14:52:03 * doserj_ prefers oplus, after all, it is addition module 2
14:52:11 <dcoutts_> ddarius: the point is, in both binary Put and that little IO simulator you've got basically imperative looking code but when it does some key operations then it gets suspended and held in a lazy data structure.
14:52:14 <rooostaj> gwern: just draw the logic gate
14:52:15 <gwern> yeah, I'll go with oplus then
14:52:23 <rooostaj> :)
14:52:24 <BallsOfSteel> how do the initial db files in /var/lib/mysql contain host-specific stuff there's something in the channel so that #vim is officially in german parliament held their opinions onto others
14:52:27 <gwern> rooostaj: how would I do that in one line in ASCII?
14:52:29 <ezyang> Ok. So the signature of f in m >>= f is a -> (b -> r) -> r, but the signature of f in callCC f is (b -> (x -> r) -> r) -> (b -> r) -> r. What's up with that?
14:52:34 <rooostaj> gwern: very tediously
14:53:00 <rooostaj> :)
14:53:16 <HugoDaniel> i like haskell
14:53:16 <ezyang> wrong intuition?
14:53:17 <ddarius> It seems BallsOfSteel should be kicked.
14:53:17 <BallsOfSteel> what ballsofsteel is burning down something like that
14:53:22 <HugoDaniel> (just so you know)
14:53:33 --- mode: ChanServ set +o mauke
14:53:36 <mmorrow> ezyang: another way to think about it (talking very concretely, but one second glance abstractly) is, on a _ machine, you "call lbl" and this implicitly pushes the address of the /next/ instruction on the stack, then jumps to lbl. "ret" pops the top of the stack and jumps to it. this is just degenerate cps, where you always pass the next instruction as the continuation.
14:53:44 <mmorrow> s/one/on/
14:53:48 <mauke> ezyang: looks like a = (b -> (x -> r) -> r)
14:53:59 <dcoutts_> ezyang: I've never found it necessry to understand callCC
14:54:06 <ezyang> mauke: ooh, whoa. right
14:54:19 <ddarius> callCC sucks.  It's doubly non-linear.  control is the right primitive.
14:54:29 <ezyang> mmorrow: I'm not really interested in how you'd do it in asm; I'm interested in how it's happening in Haskell :-)
14:54:33 --- mode: mauke set -o mauke
14:54:44 <ezyang> ddarius: control?
14:54:57 <mmorrow> ezyang: but that /is/ how it happens in haskell, if you think about what really is going on there :)
14:55:32 <ezyang> mmorrow: I'm not seeing it! :-(
14:55:34 <LordChaos> hello
14:55:47 <ddarius> control f k = f (\a _ -> k a) id
14:56:00 <monochrom> Discussion is insufficient for learning continuations.
14:56:35 <jmcarthur> @pl control f k = f (\a _ -> k a) id
14:56:36 <lambdabot> control = flip flip id . (. (const .))
14:56:37 <knobo> This is suprising to a newbie: do x <- "test"; (return . succ) x == concatMap (return . succ) "test"
14:56:54 <ezyang> ddarius: curious.  The k is swapped with an id
14:56:55 <knobo> It's funny
14:57:14 <mauke> > do { x <- "foo"; y <- [1, 2]; return (x, y) }
14:57:15 <lambdabot>   [('f',1),('f',2),('o',1),('o',2),('o',1),('o',2)]
14:57:29 <jmcarthur> :t \f k -> f (\a _ -> k a) id
14:57:29 <LordChaos> I came here yesterday because I struggled with monads with little bit, I am know pretty sure that I have understood monads, but Haskells type system puzzles me
14:57:30 <lambdabot> forall t t1 t2 a t3. ((t -> t1 -> t2) -> (a -> a) -> t3) -> (t -> t2) -> t3
14:57:31 <mauke> implicit for loop
14:58:04 <jmcarthur> ddarius: where does the idea for control come from? what should i google?
14:58:35 <LordChaos> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14330#a14330 <- I tried to convert this to a proper type class so that it allows me to use more combinations than just using IO actions, but I cannot make it work at all
14:58:46 <ezyang> I fear this may confuse me more
14:58:48 <ddarius> jmcarthur: It's just a different alternative for doing continuations.  You can google "control operators" and probably find a relevant paper.
14:58:51 <LordChaos> could someone show me maybe how this could be done best?
14:59:03 <jmcarthur> ddarius: thanks. i'd never heard of it
14:59:25 <ddarius> jmcarthur: That said, there is also prompt/control which is something different (namely delimited continuations)
14:59:52 <knobo> do { x <- "foo"; y <- "123"; [x, y] }
14:59:57 <ddarius> ezyang: The difference between callCC and control is that if you don't use the provided continuation execution is completely aborted.
15:00:03 <ezyang> Ooh, ooh, who gave the intuition of taking the next statement and passing it to f in callCC?
15:00:16 <ezyang> ddarius: good to know. That will help when I'm trying to understand it
15:00:31 <ddarius> ezyang: It's not the next "statement", it's the "rest of the program".
15:00:45 <ezyang> semantics :-P
15:01:09 <bos> ye gods, i'm actually using wave to collaboratively debug an RTS issue
15:01:25 <dcoutts_> tommd: ping
15:01:40 <zandax> oh, wrong nick
15:01:51 <tommd> dcoutts_: In a meeting, I'll ping you back in a bit.
15:01:58 <dcoutts_> tommd: ok
15:02:11 <ddarius> dcoutts: Were you talking to F# people in that talk?
15:02:29 <dcoutts_> ddarius: yes, or rather people who had seen some code in F# earlier that day
15:02:46 <dcoutts_> ddarius: someone had been explaining monads :-)
15:03:40 <ezyang> ok. I think I understand what's going on now. It's sort of like what happens in the reader monad
15:03:56 <eivuokko> F# monads come up quite differently, though.
15:04:07 <mmorrow> ezyang: imagine what would happen if a some random function just never returned... where that function goes to becomes "the rest of the program". by the same token, imagine what happens if a random function _does_ return, where that function goes becomes "the rest of the program".
15:04:25 <ezyang> mmorrow: Fair point.
15:05:02 <ezyang> But since we're in CPS, these are both isomorphic to returning something of type (a -> r) -> r
15:05:14 <mmorrow> call/return just never deviates from using the next instruction/statement/blah as the continuation, it just doesn't immediately appear this way because it's implicit
15:06:03 <ezyang> Having done OS hacking, fiddling with the %eip of a process is totally like changing its continuation
15:06:19 <ddarius> ezyang: Indeed.
15:06:22 <mmorrow> exactly
15:06:52 <ezyang> but since Haskell doesn't have first-class support for continuations, we're in CPS, which is this layer underneath the continuation idea
15:07:11 <ddarius> CPS is one possible way of implementing continuations.
15:07:13 <mmorrow> ezyang: and passing an addr to a function that you want that function to jump to with its result (possibly the next instruction from where you are (return), or not), is passing that function a continuation
15:07:15 --- mode: ChanServ set +o mauke
15:07:16 --- mode: mauke set +b *!n=dongs@*
15:07:21 <ezyang> ddarius: Yeah. That wasn't clear to me previously.
15:07:32 <ezyang> mmorrow: Oh man, you totally do that in the bootloader code.
15:07:38 <ezyang> "this function never returns"
15:07:39 <mrsolo> so
15:07:42 <jmcarthur> :t local -- one of the coolest functions around
15:07:44 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
15:07:46 <mrsolo> i like guard to work on IO Bool instead of Bool
15:07:50 <mmorrow> ezyang: totally
15:07:55 <mrsolo> what are the ways to do so?
15:08:03 <dcoutts_> mrsolo: >>=
15:08:06 <mmorrow> ezyang: it does return, just not to you!
15:08:08 <deech> Hi all, I have a question about continuations as they relate to web-programming.
15:08:08 <ddarius> :t \m -> m >>= guard
15:08:10 <lambdabot> forall (m :: * -> *). (MonadPlus m) => m Bool -> m ()
15:08:16 --- mode: mauke set -o mauke
15:08:20 <mrsolo> thanks
15:08:22 <monochrom> This total function never retunrs.
15:08:23 <ezyang> jmcarthur: What does local do?
15:08:38 <ddarius> monochrom: Has type X -> Void, eh?
15:08:53 <jmcarthur> ezyang: applies a function in Reader to a modified environment
15:08:55 <mrd> monochrom: domain and range are empty?
15:09:06 <ezyang> oh, cool.
15:09:12 * jmcarthur is using Reader with local to maintain a stack of 3D transformations
15:09:15 <deech> I understand that continuations represent what to do next. But how do you return to that point of execution when a user makes a GET or POST request.
15:09:15 <monochrom> Just playing words with "totally" "never returns"
15:09:50 <jmcarthur> way nicer than using something list State with an explicit stack
15:09:54 <jmcarthur> *something like State
15:10:25 <monochrom> serialize the continuation as a string, give it to user as URL or GET data or POST data.
15:10:46 <ezyang> CPS kind of obfuscates the style. Are there alternative continuation implementations in Haskell?
15:11:02 <deech> monochrom: Is that how the other continuation-based frameworks do it?
15:11:07 <dcoutts_> ezyang: continuation monad
15:11:14 <monochrom> Yes as far as I undersand.
15:11:42 <mmorrow> deech: this isn't how all uses of (some concept of) continuations with web programming do it, but this is an interesting read http://www.cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/
15:11:44 <jmcarthur> the Cont monad becomes strangely readable in some cases
15:14:27 <mmorrow> deech: basically, you represent the "continuation" in some way in the code of the webpage you've just generated, via some encoding into hyperlinks, then the (one of the possible) continuation(s) you've set up get called by the websurfer by following one of those links, which brings them to the exact place you had in mind, which then generates another page with new "continuations" which build on the info that the previous cont passed via
15:14:27 <mmorrow> the link
15:16:17 <mmorrow> deech: the plt scheme webserver just generates unique ids for these links, which index into a table of literal dynamically generated scheme code which do the actual page generation, so it's a slightly different mechanism, but the same idea
15:17:30 <deech> mmorrow: So the continuation is hashed to a unique id which is sent to the user and saved on the server-side in a mutable global variable. When the user makes a choice, the function (and it's lexical environment) is pulled out of the variable, run, and a continuation id is generated etc?
15:17:36 <mmorrow> rather than encode /everything/ into the links/page-data, you generate some scheme codes, associate them with some new unique ids, insert them into the table, and generate a page with links of those uids which point to the appropriate conts in the table
15:18:11 <mmorrow> deech: exactly. well, the uid is generated upon initial creation of the scheme code, but exactly.
15:19:21 <deech> mmorrow: So this is one of those cases where we absolutely need a mutable global variable in Haskell. Is STM a good choice for holding the hash-table.
15:25:58 <zandax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14330#a14330 <- anyone here to show me how to do this with a type instance?
15:26:26 <mmorrow> deech: you can use STM, i'd personally use an MVar though
15:26:28 <rooostaj> how do you convert Char to Int
15:27:19 <rooostaj> @digitToInt
15:27:20 <lambdabot> Unknown command, try @list
15:28:02 <mauke> rooostaj: ord
15:28:07 <rooostaj> @ord
15:28:07 <lambdabot> Maybe you meant: arr bid id more rc src url
15:28:08 <mmorrow> deech: and also, you'll need fastcgi (or to actually /be/ the webserver (like happs or something), but fastcgi is plenty) to do this with haskell too
15:28:44 <rooostaj> mauke: not following you
15:29:09 <mauke> rooostaj: not following you either
15:29:21 <rooostaj> mauke: well at least we aren't going in circles
15:29:25 <rooostaj> mauke: lol
15:29:31 <rooostaj> mauke: trying to convert Char to Int
15:29:46 <deech> mmorrow: Since each transaction spawns a new thread, would the threadId make a good unique id? So the response message with the current threadID is sent and a continuation is stored in a thread-local IORef. When a request comes from the client, find the matching threadId and pass it the client data.
15:29:48 <jmcarthur> > ord 'a'
15:29:49 <lambdabot>   97
15:30:06 <rooostaj> >ord '3'
15:30:13 <jmcarthur> the space is necessary
15:30:16 <rooostaj> > ord '3'
15:30:17 <lambdabot>   51
15:30:21 <rooostaj> jmcarthur: gracias
15:30:25 <jmcarthur> np
15:30:47 <rooostaj> @list
15:30:48 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:31:15 <knobo> I dont get this: do map succ "test"; return 'x' . What is it transformed in to?
15:31:51 <mmorrow> deech: i'd have an (MVar (Map UID Cont)) (fsvo Cont) which is either the environment in a Reader+CGI monad, and just store something like (type Cont = Request -> MyCGI Response) in that Map in the MVar
15:32:29 <knobo> unstable net..
15:32:30 <mmorrow> deech: and also a function that generates unique numbers (randomly so no one can guess someone else's cont..) which you use as the UID keys
15:32:31 <dolio> > [ 'x' | _ <- map succ "test" ]
15:32:33 <lambdabot>   "xxxx"
15:32:36 <HugoDaniel> freenode is really sucking
15:33:11 <deech> mmorrow: Ah, I had totally overlooked the security aspect. Thanks!
15:33:30 <mmorrow> deech: :)
15:34:15 <knobo> dolio: thanx
15:35:06 <knobo> that explains alot.
15:35:43 <ian__> evening everyone
15:42:33 <bfh6558> does anyone here konw of a #urxvt on freenode? looking a little know how on that terminal emulator
15:44:10 <mauke> bfh6558: http://www.google.com/search?q=urxvt
15:45:15 <bfh6558> fak, horribly emberessed
15:45:22 <bfh6558> missed the irc channle at the bottom of their homepage
15:45:49 <patch-ta`> from Control.Concurrent haddock: "Note: in GHC, if you have a ThreadId, you essentially have a pointer to the thread itself. This means the thread itself can't be garbage collected until you drop the ThreadId. This misfeature will hopefully be corrected at a later date."      so how do you drop a threadId?
15:46:19 <dcoutts_> patch-ta`: just don't hold onto it anymore
15:46:39 <dcoutts_> let it become garbage
15:51:12 <knobo> Where can I read about list comprehentions transformation on to concatmap?
15:51:31 <dcoutts_> knobo: it's specified in the H98 report
15:51:51 <dcoutts_> or google for list comprehention desugaring
15:52:05 <ivanm> does this mean no monads? :o http://farm1.static.flickr.com/47/164699499_c32946b8e3.jpg
15:52:30 <patch-ta`> how can I pick up an exception inside a forkIO using mvars? the following just prints Right ()
15:52:33 <patch-ta`> answer <- newMVar $ Right (); forkIO $ putMVar answer =<< (E.try $ fail "arrg" :: IO (Either E.SomeException ())); putStrLn . show =<< takeMVar answer
15:53:23 <ivanm> patch-ta`: see what I did in the Commands module of my latest graphviz release
15:53:27 <ivanm> (based on code in cabal)
15:54:09 <dcoutts_> patch-ta`: that's because putMVar on a full MVar blocks, use modifyMVar_
15:58:12 <knobo> desugaring ( macroexpand in lisp )
15:58:40 <knobo> not realy..
15:58:44 <ben> Any indication when gtk2hs will build on ghc 6.12. :3
15:59:04 <dcoutts_> ben: I sent in patches, poke people on the gtk2hs dev mailing list
15:59:13 <ben> dcoutts_: You are all kinds of awesome
15:59:34 <dcoutts_> :-)
15:59:41 <dibblego> > 9000 * 0.3048
15:59:43 <lambdabot>   2743.2000000000003
16:02:22 <Cale> patch-ta`: don't ever use fail
16:02:32 <Cale> patch-ta`: use throw
16:03:25 <mrsolo> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=14332#a14332
16:03:49 <mrsolo> Is there another way to lift IO Bool into {} monad without doing unsafePerformIO?
16:03:57 <ben> We have a {} monad?
16:04:00 <mrsolo>  [] monad
16:04:08 <ivanm> dibblego: you calculating how awesome dcoutts_ is or something? :p
16:04:36 <dibblego> ha, no my altitude yesterday after a (coincidental) pass over a mountain I am climbing tomorrow
16:04:48 <lispy> mrsolo: You want to lift IO Bool into the list monad?
16:05:04 <Raynes> We have an everything Monad, as far as I can tell.
16:05:09 <mrsolo> lispy: ya to use it for guard  i couldget get lifIO to work :-)
16:05:15 <Raynes> I have a cupcake monad, as a matter of fact. Tastes good. :D
16:05:16 <lispy> mrsolo: Sounds like your program is structured in a non-standard (weird?) way
16:05:29 <mrsolo> lispy: what is correct way then?
16:05:47 <byorgey> mrsolo: there is no way to get rid of IO without unsafePerformIO, so no.
16:05:50 <lispy> mrsolo: I haven't looked at your hpaste yet, one second
16:06:16 <byorgey> mrsolo: but I wonder whether that is really the question you mean to ask (just a hunch =)
16:06:48 <lispy> mrsolo: at a cursory glance it looks line genWorks should be in IO
16:07:41 <mrsolo> lispy: i am trying to avoid that since IO Bool decision is being added later
16:08:02 <mrsolo> lisp: flipping genWorks to IO mean flipping most of the functions :-<
16:08:56 <lispy> mrsolo: I'd probably have to spend more  time understanding the thing you want to do and the existing code together to offer real suggestions :)
16:09:09 <lispy> mrsolo: I'm a bit busy at the moment though.  Good luck
16:09:20 <mrsolo> okay thanks anyway
16:13:29 <lispy> mrsolo: depending on if you can share the code, you might try posting it to haskell-cafe
16:13:45 <tommd> dcoutts_: Ping
16:14:19 <dcoutts_> tommd: about pureMD5, found where misaligned stuff was occuring, also I've added a bswap for big endian arches
16:14:24 <mrsolo> lisp: heh i am too embarrassed to share since this is the first haskell attemp
16:14:30 <mrsolo> lispy: the whole thing is fugly
16:15:33 <tommd> dcoutts_: Sweet!
16:15:38 <tommd> do you have a patch?
16:15:40 <dcoutts_> tommd: for the padding, suppose we have 63 bytes remaining, so we make a chunk of length 65.
16:15:58 <tommd> yes
16:16:14 <dcoutts_> tommd: the problem is that then we take 63+1 bytes, concatenate that block, so we get an aligned 64byte one. all good
16:16:40 <dcoutts_> tommd: next we're left with a 64byte block, but it's now unaligned since we previously sliced one byte off the front.
16:16:52 <dcoutts_> and since it's exactly the right length, concat doesn't copy anything
16:17:29 <tommd> grrr
16:17:40 <HaskellLove> guys, when you think about recursion in haskell what does come up first in mind, to me so far: fold family or user defined function
16:18:21 <dcoutts_> tommd: so I think the construction of the padding should change
16:19:12 <dcoutts_> tommd: I don't have a proper patch for that bit, I've just left it doing the isAligned test each time.
16:20:05 <dcoutts_> tommd: for the getNthWord I've added a bswap, conditionally using CPP
16:24:19 <tommd> dcoutts_: What is your conditional?  If I could find a good ENDIAN conditional I'd use that.
16:24:23 <alexyk> does anybody have a mongodb driver?
16:24:33 <tommd> for the CPP, that is.
16:24:50 <dcoutts_> tommd: I'm just defining it in the .cabal file based on an arch test
16:24:57 <tommd> ahh, I see
16:29:25 <ivanm> dcoutts_: whilst I remember; how does one use the new feature in cabal 1.8 for having an executable use the library?
16:29:37 <dcoutts_> ivanm: build-depends
16:29:48 <ivanm> just list the library in there?
16:29:50 <ivanm> good-o
16:30:26 <dcoutts_> ivanm: the only gotcha is that local sources take priority, so you'll need to use a separate src dir for the exe
16:30:41 <ivanm> come again?
16:31:07 <dcoutts_> modules from local source files mask ones from packages
16:31:19 <ivanm> oh, I get you now...
16:31:32 <ivanm> dcoutts_: so if I use the usual hack of not listing the library modules it needs then it will be OK?
16:31:40 <ivanm> (if the actual Main module is in a separate file)
16:33:43 <dcoutts_> ivanm: well certainly you will not list them as other modules, but it must not be possible to find them in the same search path otherwise they mask the package
16:33:51 <bos> hooray! i now have the RTS using poll!
16:34:09 <ivanm> bos: \o/
16:34:14 <dcoutts_> bos: so do you need to change the interface to the io manager?
16:34:17 <ivanm> dcoutts_: right, I'll have a play with it later on
16:34:20 <tommd> dcoutts_: Humm, thinking about that last statement I'm not sure how to test endian via .cabal.  Do you mean you use cabal to call a configure script?
16:34:32 <bos> dcoutts_: not yet.
16:34:38 <dcoutts_> tommd: no, just cheating and listing the arches
16:34:51 <bos> dcoutts_: i want to refactor the IO manager gradually.
16:35:07 <bos> dcoutts_: first step is to get rid of select where possible.
16:35:09 <ivanm> bos: wrt my emails on your utf8 stuff in Text: I'm considering making graphviz use utf8 only (since the actual Graphviz apps use utf8 by default), and you had risen my hopes up by saying that it worked as utf-8 everywhere in Text :s
16:35:32 <bos> ivanm: i've no idea what you really want
16:35:44 <dcoutts_> bos: when you say poll, you really mean poll not epoll?
16:35:54 <ivanm> bos: heh, I'll try again
16:36:26 <ivanm> bos: atm, graphviz is ignorant about encodings; I was considering forcing utf-8 by using utf8-string but dcoutts_ said that the encoding stuff in 6.12 is better
16:36:44 <ivanm> but that only works _in_ 6.12, so I thought you had some compatability stuff in Text (and you do, but only internally)
16:37:14 <bos> dcoutts_: poll for now, yes.
16:37:17 <ivanm> and it'd probably be a waste for me to use Text just for the utf-8 support (since I'm using pretty, then converting to a String and then passing that to dot, neato, etc.)
16:37:18 <bos> dcoutts_: one thing at a time :-)
16:37:39 <dcoutts_> bos: I was under the impression that the interface to poll was essentially the same as for select
16:37:56 <bos> dcoutts_: it's similar, but select only allows 1024 open sockets at a time
16:38:09 <bos> dcoutts_: poll has no such limit
16:38:10 <dcoutts_> ah
16:38:26 <bos> ivanm: maybe, i don't know
16:38:51 <dcoutts_> ivanm: pretty should be able to generate Text
16:39:03 <ivanm> dcoutts_: it can?
16:39:08 <dcoutts_> it's got a general fold so it's not limited to String
16:39:11 <bos> ivanm: you sound confused to me, so i can't understand what you really want
16:39:26 <bos> ivanm: utf-8 is an I/O encoding, not the internal representation.
16:39:47 <ivanm> bos: I need the stuff passed to dot, neato, etc. to be utf-8
16:40:10 <bos> ivanm: ok.
16:40:12 <ivanm> dcoutts_: you mean using fullRender?
16:40:31 <bos> ivanm: so you need to write out utf-8, yes? that should work fine.
16:40:35 <dcoutts_> ivanm: if you were using Text you would pretty print to Text, use the Text API to serialise to a UTF-8 bytestring and send that to the external program.
16:40:48 <ivanm> dcoutts_: right
16:41:02 <ivanm> dcoutts_: but how would I go from Doc -> Text ?
16:41:09 <dcoutts_> fullRender
16:42:13 <ivanm> that means I have to work out how to use fullRender as well as how to use Text :s
16:42:30 * ivanm puts it in his mental TODO list
16:54:22 <roconnor_> xerox: which one is faster flip lcm or lcm?
16:54:34 <xerox> flip lcm
16:54:41 <roconnor_> the definition isn't symetric
16:54:57 <rooostaj> @zipWith
16:54:57 <lambdabot> Unknown command, try @list
16:55:02 <rooostaj> @src zipWith
16:55:03 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:55:03 <lambdabot> zipWith _ _      _      = []
16:56:21 * Axman6 attempts to make the leap to 6.12.1...
16:57:10 <opdolio> Does it still have problems with cabal install?
16:57:31 <bos> not if you use a newish cabal-install
16:57:41 <opdolio> From darcs, or on hackage?
16:57:52 <bos> i don't know. i'm running from darcs.
16:57:52 <Axman6> darcs
16:58:29 <Axman6> i've just build the darcs cabal-iinstall using 6.10.4, and i';m in the middle of installing 6.12.1... hoping it won't all brea\k
16:58:46 <bos> i've used it. it's fine.
16:58:49 <increpare> Still playing about with multi-parameter type-classes.  Before I try rewriting using type-families (which I guess I should try anyway), is there any way to hide the dependent class variables from Edge, say, here (to leave out vl and vd ) -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14335#a14335
16:59:31 * hackagebot upload: translate 2009.12.17 - Haskell binding to Google translate (JinjingWang)
16:59:44 <dolio> Whoa.
17:00:01 <Axman6> and, time to run bootstrap again
17:00:36 <rooostaj> @src lcm
17:00:36 <lambdabot> lcm _ 0     =  0
17:00:36 <lambdabot> lcm 0 _     =  0
17:00:36 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
17:01:01 <increpare> ivanm: Oh hey: you've been doing some work on putting together a new slightly more general graph class I heard?
17:01:05 <Axman6> @src gcd
17:01:05 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
17:01:05 <lambdabot> gcd x y = gcd' (abs x) (abs y)
17:01:05 <lambdabot>    where gcd' a 0  =  a
17:01:05 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
17:01:56 <Axman6> cabal: fromFlag NoFlag. Use fromFlagOrDefault
17:01:59 <Axman6> o.O
17:02:25 <dcoutts_> Axman6: details?
17:02:41 <HaskellLove> if i have a function with two arguments, how do i map it? for example: takeMaxElementOfListBellow_sum :: Int -> Int -> Int
17:02:56 <Axman6> ran cabal update parallel, but i didn't already have parallel installed for this version of ghc
17:03:04 <Axman6> not something to worry about i think
17:03:21 <HaskellLove> so you would do something like takeMaxElementOfListBellow_sum 2 3... but what if you wanted to apply it to list of values like (9 0) (3 4) (5 6) ?
17:03:33 <increpare> HaskellLove: to apply it to pairs?
17:03:53 <increpare> HaskellLove: then you stick in an uncurry before it
17:03:58 <HaskellLove> well actually it takes two Ints as input so i dont know what the list of such elements should be, they are not tuples
17:04:14 <dcoutts_> Axman6: what do you really mean? cabal update doesn't take any extra arguments. Did you mean upgrade or install?
17:04:14 <increpare> would be easieset to have a list of pairs
17:04:28 <increpare> and apply it to that
17:04:30 <HaskellLove> increpare> you mean a tuple or a pair
17:04:41 <Axman6> cabal upgrade, sorry
17:04:53 <HaskellLove> as far as i know there is pair datatype in haskell so ... might be wrong
17:05:08 <increpare> HaskellLove: not in the standard library there isn't
17:05:22 <HaskellLove> ok will do it with tuples then
17:05:25 <HaskellLove> thanks
17:05:42 <increpare> HaskellLove: welcome : )
17:05:49 <increpare> HaskellLove: (but don't be afraid to call them pairs : P )
17:05:56 <HaskellLove> oki doki
17:06:05 <dcoutts_> Axman6: so what are the details, cabal-install version, ghc version?
17:06:13 <Twey> A pair is a tuple
17:06:29 <Axman6> dcoutts_: the darcs version of cabal-insta,, cabal-1.8.0.2, ghc 6.12.1
17:06:41 <Twey> A pair is a value of the type (a, b)
17:06:53 <dcoutts_> Axman6: can you still reproduce it?
17:06:59 <increpare> Twey: indeed.  Any pair, say (1,2), can be trivially viewed as a 1-tuple ( (1,2) ) : P
17:07:07 <Axman6> i can try,
17:07:18 <Twey> increpare: *facepalm* :√æ
17:07:23 <Axman6> dcoutts_: yes
17:07:29 <Axman6> $ cabal upgrade parallel
17:07:29 <Axman6> Resolving dependencies...
17:07:29 <Axman6> cabal: fromFlag NoFlag. Use fromFlagOrDefault
17:07:42 <monochrom> Thank God haskell doesn't actually have a 1-tuple type.
17:08:00 <Twey> There's one in the ‚Äòtuple‚Äô package.  ‚ò∫
17:08:18 <Twey> Marvellously pointless
17:08:26 <monochrom> That is excommunicated from God.
17:08:32 <Twey> Heheh.
17:08:57 <mokus> lazy or strict 1-tuple?
17:09:02 <increpare> Twey: ahahaha there is a Data.Tuple.OneTuple : P
17:09:07 <increpare> mokus: it's lazy
17:09:12 <Twey> I know >.<
17:09:25 <monochrom> Someone invented it to represent numbers in types.
17:09:27 <mokus> well, then it could still at least be 1 step more pointless ;)
17:09:33 <increpare> Twey: yep yep was just verifying for myself.
17:10:06 <Twey> increpare: Oh, the emoticon was to do with the fact that it exists, not the fact that you pointed it out
17:10:18 <increpare> Twey: acknowledged : )
17:11:18 <increpare> at the risk of repeating myself, anyone notice any way of getting rid of the cruddy type-parameters from -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14335#a14335
17:11:29 <HaskellLove> zip [1] [1..5]  how to get more values until 5, i mean, like this it gives me just one tuple
17:11:50 <DigitalKiwi> Twey: do you know haskell better than lua? :D
17:11:55 <Twey> Yes
17:12:03 <xerox> HaskellLove: and what values do you want paired with [1..5] =?
17:12:19 <Twey> HaskellLove: It will give you a result the length of the shortest list
17:12:23 <DigitalKiwi> Twey: cool =D
17:12:30 <xerox> roconnor_: flip lcm is more memory efficient than lcm.
17:12:30 <Twey> (because there are no more values to pair up)
17:12:41 <HaskellLove> xerox i wana get (1,1) (1,2) (1,3) (1,4) (1,5)
17:12:43 <increpare> zip (repeat 1) [1..5]  might work?
17:12:49 <Twey> Yup
17:12:52 <Twey> Hmmm
17:12:56 <xerox> that's it
17:12:57 <Twey> > [1, 1 .. 1]
17:12:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:13:04 <Twey> > [1 .. 1]
17:13:05 <lambdabot>   [1]
17:13:11 <HaskellLove> sweet thanks guys i love youuuu
17:13:12 <Twey> Well, the former works too ‚ò∫
17:13:14 <dcoutts_> Axman6: hmm, it's not obvious. Will need some debugging.
17:13:31 <increpare> oh dear let's not get into this list ellipses bounds stuff : P
17:13:37 <increpare> always ends in fisticuffs ...
17:13:49 <Twey> What's that?
17:13:54 <monochrom> > [1..0]
17:13:55 <lambdabot>   []
17:13:58 <Twey> > [1, 1 ..]
17:13:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:14:07 <xerox> roconnor_: lcm 2,212,564,768 bytes, flip lcm 1,114,694,692 bytes
17:14:23 <Twey> xerox: Well that's weird
17:14:27 <increpare> Twey: there was a lengthy discussion some time ago about what to do with arithmetic sequences in lists of floats when they're specified in this manner
17:14:34 <DigitalKiwi> haskell has a least common multiple built in?
17:14:39 <Twey> Yeah
17:14:46 <Twey> In the Prelude, anyway
17:14:47 <Axman6> > [0,pi,..]
17:14:49 <lambdabot>   <no location info>: parse error on input `..'
17:14:53 <Axman6> > [0,pi..]
17:14:54 <lambdabot>   [0.0,3.141592653589793,6.283185307179586,9.42477796076938,12.56637061435917...
17:14:55 <DigitalKiwi> that's epic
17:15:08 <Twey> Functions generally aren't ‚Äòbuilt in‚Äô to Haskell (with a few noteworthy exceptions, like (+) and seq)
17:15:23 <monochrom> Haskell prelude has solutions to the first 200 project euler problems.
17:15:24 <Twey> (well, even (+) isn't necessarily)
17:15:28 <Twey> Haha
17:15:29 <akappa> > lcd 10 3
17:15:29 <HaskellLove> zip [repeat i] [j | j <- [0..(length (x:xs))]] guys i get error for that:  Couldn't match expected type `Int' against inferred type `[a]'    In the expression: repeat i    In the first argument of `zip', namely `[repeat i]'
17:15:30 <lambdabot>   Not in scope: `lcd'
17:15:35 <akappa> > lcm 10 3
17:15:36 <lambdabot>   30
17:15:43 <akappa> > gcd 10 3
17:15:44 <lambdabot>   1
17:15:49 * Twey goes to bed
17:16:02 <akappa> Twey, good night!
17:16:04 <DigitalKiwi> good night Twey
17:16:13 <monochrom> > "(repeat i)" == "[repeat i]"
17:16:14 <lambdabot>   False
17:16:31 <increpare> > :t [repeat i]
17:16:32 <lambdabot>   <no location info>: parse error on input `:'
17:16:40 <increpare> > :t [repeat 1]
17:16:42 <lambdabot>   <no location info>: parse error on input `:'
17:16:44 <monochrom> > [j | j<-[0..4]] == [0..4]
17:16:45 <lambdabot>   True
17:16:54 * increpare gotta learn how to use lambdabot proper
17:17:21 <monochrom> > [j | j <- [j | j<-[0..4]]] == [0..4]
17:17:22 <lambdabot>   True
17:17:28 <akappa> @bf [...+...]
17:17:28 <lambdabot>  Done.
17:17:49 * akappa thinks that is the only way lambdabot is useful
17:18:02 <increpare> akappa: what way?
17:18:15 <akappa> inclement, the brainfuck command :P
17:18:33 <mokus> lamdabot needs a whitespace parser
17:18:35 <HaskellLove> guys please help the above post of mine i gota go to bed for school tomorow and i wanna finish this problem :)
17:18:44 <mokus> er, interpreter
17:18:51 <monochrom> I just did.
17:19:20 <ezyang> :t [repeat i]
17:19:21 <lambdabot> [[Expr]]
17:19:29 <increpare> :t (repeat i)
17:19:30 <lambdabot> [Expr]
17:19:47 <ezyang> (i.e. remove the brackets around repeat i)
17:20:12 <HaskellLove> thanks
17:20:14 <aavogt> and,  zip (repeat x) is about the same as   map (\y -> (x,y))
17:20:27 <DigitalKiwi> monochrom: do you mean like with just the stuff in prelude you can solve the first 200 ?
17:20:38 <monochrom> I mean joking.
17:20:44 <Axman6> which is the same as map (x,) >_>
17:21:02 <monochrom> (x,) is not valid until 6.12.1
17:21:05 <xerox> new tuple sections in 6.12 :)
17:21:08 <Axman6> > map (1,) [1..]
17:21:09 <lambdabot>   <no location info>: parse error on input `)'
17:21:11 <DigitalKiwi> the first 200 are on the wiki
17:21:13 <Axman6> :(
17:21:24 <Axman6> monochrom: until? or from?
17:22:23 <monochrom> both until and from are correct. I am not obliged to enumerate the set of all true statements.
17:22:42 <Axman6> ok, let me put it another way, can it be used in 6.12.1
17:22:49 <monochrom> Yes.
17:22:58 <Axman6> and 6.10.x?
17:23:03 <monochrom> No.
17:23:09 <Axman6> ok
17:28:06 <rooostaj> @src map
17:28:07 <lambdabot> map _ []     = []
17:28:07 <lambdabot> map f (x:xs) = f x : map f xs
17:28:58 <DigitalKiwi> hmm, in the function x | syntax i've seen examples of they use otherwise, but in like function x = i've seen else, are they interchangeable or different or the same function just for different type of function declaration?
17:29:39 <ezyang> | is a guard
17:29:43 <monochrom> different. unrelated.  else is part of it.  otherwise is defined in prelude as True.
17:29:56 <monochrom> sorry, else is part of if.
17:31:24 <aavogt> > case () of _ | False -> "hai" | True -> "bye" | otherwise -> "ok"
17:31:26 <lambdabot>   "bye"
17:31:34 <aavogt> > otherwise
17:31:36 <lambdabot>   True
17:33:07 <DigitalKiwi> hmm, ok, thanks
17:33:33 <ezyang> "oh right, you can use guards in case statements..."
17:36:53 <ezyang> Does anyone use the prompt monad for things beyond small interactive games?
17:39:10 <ivanm> heya Axman6
17:39:36 <rooostaj> > filter (==3) [3,3,3,3,3,3]
17:40:29 <rooostaj> > filter (==3) [3,3,3,3,3,3]
17:40:31 <ivanm> rooostaj: you killed lambdabot! :o
17:40:35 <ivanm> @bot
17:40:36 <lunabot>  :o
17:40:36 <rooostaj> ivanm: i think i did
17:40:49 <rooostaj> > [1..10]
17:41:01 <rooostaj> snap
17:41:06 <lambdabot>   [3,3,3,3,3,3]
17:41:12 <rooostaj> lol?
17:41:21 <lambdabot>   [3,3,3,3,3,3]
17:41:22 <lambdabot> :)
17:41:23 <Axman6> hey ivanm
17:41:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:41:29 <rooostaj> heeeeeeeeeeeeeeeeeeere come lambdabot
17:41:54 <ezyang> what's lambdabot doing...
17:42:05 <ezyang> oh, I see.
17:42:06 <rooostaj> what i told it to do a minute back
17:42:09 <rooostaj> lol
17:43:55 <rooostaj> The following statement from Learn You a Haskell seems an inappropriate example :D :::
17:43:57 <rooostaj> > filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same
17:44:02 <rooostaj> arg typo
17:44:18 <ivanm> NEEDS MOAR QUOTES
17:44:21 <rooostaj> > filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
17:44:34 <rooostaj> lambdabot died again
17:44:56 <DigitalKiwi> what are some recommended online reading materials for learning haskell? I've been looking at realworld haskell, learn you a haskell for great good, and haskell tutorial for c programmers, but not sure which is best of those or if there are other better ones...
17:45:06 <lament> "GAYBARS"
17:45:07 <ivanm> @where wikibook
17:45:13 <ivanm> @where lyah
17:45:18 <Axman6> DigitalKiwi: i recommend lyah
17:45:19 <monochrom> I think you're doing fine.
17:45:25 <ivanm> DigitalKiwi: it depends on what kind of tutorial you want
17:45:43 <ivanm> @time lambdabot
17:45:43 <HaskellLove> transformedLists (x:xs) = map (sumList i) (x:xs) ------------ guys, big problem... 1. (x:xs) is a list of lists. 2. sumList does something nevermind, it uses two arguments: i :: Int and a list... in this case it is used on (x:xs) which is list of lists... i is suposed to be the index of the list that is curently operated on... for example if some list in (x:xs) has index 3 in it, then i is...
17:45:45 <HaskellLove> ...suposed to be that too... how to do that?
17:46:04 * ivanm has no idea what HaskellLove just said
17:46:10 <aavogt> @botsnack
17:46:10 <lunabot>  :o
17:46:21 <medfly_> I think he said something about never mind
17:46:21 * ivanm thinks lambdabot needs her morning coffee or something...
17:46:23 <aavogt> Cale: ^^ ?
17:46:41 <medfly_> Cale seems to be getting disconnected
17:46:43 <Axman6> HaskellLove: transformLists xs = zipWith sumList [0..] xs
17:46:43 <lambdabot>   <no location info>:
17:46:44 <lambdabot>      lexical error in string/character literal at end o...
17:46:45 <lambdabot>   "GAYBALLS"
17:46:47 <lambdabot> http://en.wikibooks.org/wiki/Haskell
17:46:47 <lambdabot> http://www.learnyouahaskell.com/
17:46:47 <lambdabot> I live on the internet, do you expect me to have a local time?
17:46:51 <lambdabot> :)
17:46:51 <rooostaj> there it is!
17:46:59 <rooostaj> :P
17:46:59 <ivanm> lambdabot: yes, I do
17:47:19 <rooostaj> > filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
17:47:21 <lambdabot>   "GAYBALLS"
17:47:28 <monochrom> I live on the space station.
17:48:03 <medfly_> lol
17:48:41 <ivanm> rooostaj: OK, we get it
17:48:47 <HaskellLove> ivanm u girl?
17:49:02 <rooostaj> ivanm: sorry I was seeing if lambdabot was working.
17:49:05 <rooostaj> ivanm: :(
17:49:10 <ivanm> HaskellLove: 1) why are you asking, 2) why do you care, 3) no
17:49:51 <ben> Requesting someone who is a girl(*) to explain monads to me
17:49:56 <HaskellLove> thinks lambdabot needs her morning coffee or something... oh u said that of lambdabot hahaa
17:49:58 <ben> (* must be cute)
17:50:01 <medfly_> lol
17:50:05 <medfly_> lambdabot can do
17:50:14 <monochrom> I can pretend to be a cute asian girl.
17:50:15 <HaskellLove> lambdabot you bitch :D
17:50:18 <ivanm> monochrom: heh
17:50:22 <rooostaj> HaskellLove: lol
17:50:23 <medfly_> monochrom: why asian?
17:50:27 <HaskellLove> nah sorry i love u lambdabot dont get mad
17:50:29 * ivanm passes HaskellLove some reading glasses
17:50:35 <monochrom> I'm 2/3 of that already anyway. cute and asian.
17:50:46 <HaskellLove> ivanm man i need sleep leave me alone
17:51:02 <ivanm> then get some sleep...
17:51:20 <HaskellLove> i cant till i solve euler 18
17:51:24 <HaskellLove> which i am close to do
17:51:32 <medfly_> if I lived like that
17:51:33 <medfly_> I'd be dead
17:51:40 <stroan> euler will be there in the morning
17:51:46 <medfly_> no, euler died
17:51:50 <stroan> :P
17:51:55 <HaskellLove> gota solve it now, shut up
17:52:15 <Axman6> HaskellLove: why must you be so rude all the time?
17:52:24 <Axman6> you're 21, please try and act like it
17:52:33 <HaskellLove> Axman6... uggghhh... it is called a joke? I think?
17:52:48 <inclement> Jokes can be rude
17:52:55 <stroan> ^
17:53:00 <medfly_> he's probably like my sister, so sleep deprived she is prone to getting upset.
17:53:01 <HaskellLove> i mean it is like... come on guys shut up leave me alone i am solving you know :D
17:53:02 <Axman6> it's the way you always act, and i know i'm not the only one who finds it annoying
17:53:12 <medfly_> HaskellLove: and by that I mean having PMS
17:53:18 <medfly_> ;)
17:53:21 <medfly_> (not really)
17:53:43 <rooostaj> * hides under computer desk
17:53:53 <rooostaj> * doesn't know how to use emotes
17:53:58 <ezyang> Also... does anyone have an example of runPromptC?
17:54:01 <medfly_> rooostaj: /me
17:54:09 <HaskellLove> medfly_ how old is she bro?
17:54:14 * rooostaj now knows how to use emotes thanks to medfly_
17:54:34 <medfly_> HaskellLove: like 24.
17:55:10 <HaskellLove> medfly_4 tell her i am looking for a wife, let her send me picture if she is good she will get to phone interview
17:55:23 * stroan goes to bed
17:55:25 <medfly_> I don't think she's interested.
17:55:55 <HaskellLove> medfly_> come on man, i will be a rich geek in 4 years
17:56:00 <medfly_> so will she.
17:56:10 <Axman6> HaskellLove: just for reference, i'm 20, and i don't know anyone over 15 who acts like you do :\
17:56:12 <monochrom> You told us to leave you alone. We will leave you alone.
17:56:15 <medfly_> well, maybe 4 years is a bit too soon.
17:56:27 * medfly_ joins #haskell-blah
17:56:31 <stroan> HaskellLove: I know many "geeks". Most of whom thankfully don't copulate for that reason alone
17:56:38 <HaskellLove> Axman6 i know man i need sleep i am just gona go back to my work
17:57:23 <HaskellLove> stroan>	they dont? gee
17:57:45 <stroan> I know. Emotions, and personallities. Who'd have thunk it
17:58:22 <HaskellLove> well man it is either money or sex, cant have both
18:00:22 --- mode: ChanServ set +o monochrom
18:00:40 <medfly> HaskellLove: why don't you chat about those things in #haskell-blah?
18:00:52 --- mode: monochrom set +b *!*@92.55.82.*
18:01:05 --- mode: monochrom set -o monochrom
18:01:18 <cjay> any idea if the plugins package works with ghc-6.12?
18:02:05 <cjay> iirc it was broken with every major ghc release in the past
18:05:14 <Axman6> cjay: trying it now
18:05:25 <ivanm> cjay: plugins is new though...
18:05:36 <ivanm> and IIRC, it was the re-written version of hsplugins for 6.10
18:06:07 <sereven> does a released happy work with 6.12? might need a dev version
18:06:44 <Axman6> cjay: seems to be broken, but not necessarilly because of the compiler
18:06:50 <Axman6> src/System/Plugins/PackageAPI.hs:61:24: Not in scope: `package'
18:09:04 <rooostaj> @src length
18:09:05 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:12:13 <ivanm> sereven: think released version works
18:12:21 <ivanm> (pretty sure trofi tried it)
18:13:03 <sereven> yeah, looks like it does, as does haskell-src. not sure why messed up on earlier try.
18:13:14 <rooostaj> > let x = map (x) [1..10]
18:13:15 <lambdabot>   not an expression: `let x = map (x) [1..10]'
18:13:23 <rooostaj> > let x = map (*) [1..10]
18:13:25 <lambdabot>   not an expression: `let x = map (*) [1..10]'
18:13:53 <ivanm> sereven: *cough* haskell-updater *cough*
18:13:55 <rooostaj> map (\f -> f 3) (map (*) [1..10])
18:14:00 <rooostaj> > map (\f -> f 3) (map (*) [1..10])
18:14:01 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
18:14:07 * rooostaj cries in joy
18:14:07 <ivanm> anyone know if yi is going to be updated to use cabal 1.8 any time soon?
18:14:24 <rooostaj> > take 10 (map (\f -> f 3) (map (*) [1..]))
18:14:25 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
18:14:32 * rooostaj weeps like a baby
18:14:39 <dcoutts_> ivanm: crikey, give them a second. Cabal-1.8 was only released 24 hours ago!
18:14:51 <m0nkfish> rooostaj whats up
18:14:58 <ivanm> dcoutts_: heh
18:15:02 <rooostaj> m0nkfish: just happy with haskell :)
18:15:06 <m0nkfish> ah hehe
18:15:07 <ivanm> dcoutts_: but the dev version has been available for a while...
18:15:18 <rooostaj> m0nkfish: it is magically delicious
18:15:22 <m0nkfish> truly
18:16:09 <PepeSilvia> > [3,6..]
18:16:10 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
18:16:25 <dcoutts_> ivanm: this is the new chilled ghc release process where we don't panic the second that a major release comes out, we've got a month or so for maintainers to get things together before the platform comes out and we start encouraging users to switch over.
18:16:25 <rooostaj> > take 100 [3,6..]
18:16:27 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
18:16:37 <rooostaj> lambdabot you cheater
18:16:49 <ivanm> dcoutts_: awww..... :(
18:17:08 <ivanm> it's just ruining my packaging since yi wants 1.6 and I want 1.8 (not that I actually use yi...)
18:17:12 <dcoutts_> ivanm: trying to get everything working before ghc is released just makes everyone go insane
18:17:36 <ivanm> heh, true
18:18:18 <dcoutts_> ivanm: look at how distros handle major gcc releases for example
18:18:23 <m0nkfish> > zipWith (\f x -> f x) (map (*) [1..10]) [1..10]
18:18:24 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
18:18:55 <ivanm> dcoutts_: hard mask, normal mask, unstable, stable... simple! :p
18:19:52 <m0nkfish> > zipWith ($) (map (*) [1..10]) [1..10]
18:19:54 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
18:19:58 <m0nkfish> shit's cash
18:20:08 <DigitalKiwi> \f is anonymous function iirc?
18:20:17 <m0nkfish> \ denotes lambda
18:20:18 <dcoutts_> ivanm: but notice how say gcc 4.4.0 never makes it into the distro, it's just there for testing and feedback to the gcc folks and other package maintainers.
18:20:35 <rooostaj> question: is (\x y -> x + y) sugar for (\x -> \y -> x + y) ??
18:20:37 <m0nkfish> f is the first argument to the function in the expression \f x -> f x
18:20:48 <ivanm> dcoutts_: hmmmm....
18:20:50 <tensorpudding> rooostaj: presumably
18:20:56 * ivanm should consider actually using 4.4.2 at some poing
18:20:57 <tensorpudding> :t \x y -> x+y
18:20:58 <lambdabot> forall a. (Num a) => a -> a -> a
18:20:59 <dcoutts_> ivanm: and people don't get the whole lot updated and working together 'til say 4.4.1 or .2
18:21:03 <ivanm> rooostaj: I think so, yes
18:21:03 <Philonous> rooostaj: indeed
18:21:11 <tensorpudding> :t \x -> (\y -> x+y)
18:21:12 <lambdabot> forall a. (Num a) => a -> a -> a
18:21:14 <m0nkfish> > (\x -> \y -> x+y) 3 4
18:21:16 <lambdabot>   7
18:21:21 <rooostaj> tensorpudding: ivanm: Philonous: good, I have the right idea then
18:21:47 <tensorpudding> i'm pretty sure that in the real lambda calculus there is a syntactic sugar for that as well
18:21:56 * DigitalKiwi doesn't actually have any idea what a lambda is :(
18:21:57 <rooostaj> tensorpudding: interesting
18:22:09 * rooostaj pats DigitalKiwi
18:22:11 <m0nkfish> [02:19:42] DigitalKiwi ª \f is anonymous function iirc?
18:22:12 <m0nkfish> ;)
18:22:28 <tensorpudding> DigitalKiwi: a lambda is just an anonymous function
18:22:33 <DigitalKiwi> oh
18:22:38 <DigitalKiwi> >.>
18:22:40 <rooostaj> "is just"
18:22:42 <rooostaj> :D
18:22:43 <tensorpudding> for example
18:22:52 <tensorpudding> id x = \x -> x
18:23:00 <mauke> tensorpudding: fail
18:23:01 <aavogt> there's too many x there
18:23:15 <tensorpudding> yeah, that's not valid
18:23:18 <tensorpudding> id = \x -> x
18:23:25 <Gracenotes> @vixen is ham-path delicious?
18:23:25 <lambdabot> let me answer that later, okay?
18:23:30 <aavogt> you wrote flip const or something like that
18:23:35 <BMeph> Actually, id x = (\x -> x) x
18:23:35 <aavogt> @pl id x = \x -> x
18:23:36 <lambdabot> id = const id
18:23:37 <Gracenotes> it might take you.. exponential time
18:23:54 <BMeph> That just looks WAY too busy, though. ;)
18:24:12 <m0nkfish> i prefer id x = x :)
18:24:19 <DigitalKiwi> what is pl short for?
18:24:23 <ivanm> pointless
18:24:28 <tensorpudding> but anyway, it allows you to specify a function without having to give it a name, by describing how it transforms a variable
18:24:33 <BMeph> point-less
18:25:17 * DigitalKiwi uses them in lua
18:25:43 <tensorpudding> they exist in other languages
18:26:03 <tensorpudding> but they look funny in some of them
18:26:15 <m0nkfish> i still prefer haskell's syntax to anything else i've seen
18:29:06 <DigitalKiwi> tbl[size+1] = (function(h) local num = 1 for i in strsub(h, 1) do num = num * i end return num end)(k) -- one I wrote the other day
18:29:37 <DigitalKiwi> hmm so which of the haskell things I've been looking at should I concentrate on most atm :(
18:29:48 <sereven> cjay: Axman6 looks like Distribution.InstalledPackageInfo has very different interface, hence no more 'package'
18:29:57 <Philonous> tensorpudding: Funny,. yes. Functions in ocaml are so much fun. (fun x -> x+1).
18:30:12 <tensorpudding> yes, ocaml is full of fun
18:30:16 <tensorpudding> and rec
18:30:26 <tensorpudding> fun and recreation
18:31:13 <DigitalKiwi> ocaml is like sex?
18:39:26 <byorgey> DigitalKiwi: what should you concentrate on most?  well... what have you been looking at? and what do you want to do or learn?
18:40:43 <DigitalKiwi> learn you a haskell for great good, haskell tutorial for c programmers, and real world haskell
18:41:30 <DigitalKiwi> and I don't have a specific goal in mind for what I want to learn, just that I want to learn >.> I've been working on project euler in lua, so being able to do some of those in haskell is one thing I'll be trying
18:44:31 <Philonous> A 'newbie', in Haskell, is someone who hasn't yet implemented a compiler. They've only written a monad tutorial.
18:44:49 <phr> lol
18:45:23 <phr> @remember Philonous A 'newbie', in Haskell, is someone who hasn't yet implemented a compiler. They've only written a monad tutorial.
18:45:24 <lambdabot> Good to know.
18:45:50 <Philonous> phr: Oh, I've just quoted from the web
18:45:55 <phr> oh, heh
18:46:04 <phr> @forget Philonous A 'newbie', in Haskell, is someone who hasn't yet implemented a compiler. They've only written a monad tutorial.
18:46:05 <lambdabot> Done.
18:46:08 <phr> wow
18:46:11 <phr> i didn't know you could do that
18:46:24 <Dashkal> Is it possible to coerce a value of type Int into an Integer?
18:46:32 <phr> dashkal, fromIntegral
18:46:40 <Dashkal> danke
18:47:10 <BMeph> bitte ;)
18:48:52 <ivanm> Philonous: you mean I'm not even a newbie in Haskell terms? :o
18:49:16 <Philonous> Evidently ;)
18:49:31 * ivanm feels so dissilusioned
18:49:37 <ivanm> however you spell it
18:49:40 <DigitalKiwi> what is below newbie?
18:49:44 <DigitalKiwi> disillusioned
18:49:45 <phr> burrito tutorial?
18:50:44 <O_4> I thought the burrito tutorial *was* the monad tutorial...
18:52:49 <Dashkal> heh, what kind of compiler?  Would something that converts boolean logic into SKI and evaluates it count?
18:53:12 <phr> well if it operates at the type level...
18:53:57 <Cale> Heh, type-level GHC
18:54:00 <Dashkal> Heh, I've known the language for less than a week.  I'm definitely a newbie.  I just used that as a test case when learning parsers and data types.
18:59:57 --- mode: ChanServ set +o monochrom
19:00:03 --- mode: monochrom set -b *!*@92.55.82.*
19:00:09 --- mode: monochrom set -o monochrom
19:48:17 <Philonous> I've never seen this room silent for half an hour before. Spooky. Did my connection die?
19:50:06 <monochrom> No.
19:52:22 <phr> somebody made a nonterminating comment.  that's haskell's dirty secret, it can't statically check for bottom.
19:52:42 <rooostaj> > {-
19:52:43 <lambdabot>   <no location info>: parse error on input `{'
19:52:50 <Philonous> phr: Would be boring if it could, though.
19:53:05 <rooostaj> > --comment
19:53:06 <lambdabot>   not an expression: `--comment'
19:55:57 <ivanm> rooostaj: needs a space
19:56:00 <ivanm> > -- comment
19:56:01 <lambdabot>   not an expression: `-- comment'
19:56:14 <ivanm> and mueval obviously doesn't like lines that are _just_ comments
19:56:18 <ivanm> > () -- comment
19:56:19 <lambdabot>   ()
19:56:41 <Philonous> > "foo" --comment without space
19:56:42 <lambdabot>   "foo"
19:57:19 <ivanm> > let (--) = (-) in 2--1
19:57:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:57:26 <Philonous> ghc is a little overeager in making a double-dash a comment. Would like to have (---) as an operator
19:57:26 <ivanm> heh
19:57:44 <ivanm> Philonous: I think that's valid; it has to have a space afterwards to be a comment IIRC
19:58:12 <Philonous> > 1 --- 3
19:58:13 <lambdabot>   1
19:58:21 <holmak> I think it has to have a "non-symbol" after it, according to Haskell's definition of symbols.
19:58:33 <Philonous> Didn't work when I tried it in ghci
19:58:43 <ivanm> holmak: could be
19:59:24 <holmak> That's what I've heard, anyway.
20:00:12 <holmak> http://www.haskell.org/onlinereport/syntax-iso.html
20:01:47 <Philonous> Ah right, I think they changed that in Haskell 2010
20:01:52 <dbelange> Hi, does anyone know any category theory?
20:02:00 <monochrom> No.
20:02:02 <ivanm> @where awodey
20:02:03 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
20:02:12 <ivanm> dbelange: Cale does, or else there's awodey's book ^^
20:02:31 <dbelange> wgot
20:03:52 <Cale> dbelange: Have a question?
20:03:56 <aavogt> > let (--$) = (+) in 1 --$ 2
20:03:57 <lambdabot>   3
20:04:42 <dbelange> Cale: Originally I was going to make some kind of joke about daily doubles, but I can't think of a good delivery.
20:04:48 <dbelange> I'll ask again if I do.
20:15:26 <ivanm> @. elite yow
20:15:27 <lambdabot> (ou|dn't phiNd phORtune phILe
20:15:30 <ivanm> grrr....
20:15:32 <ivanm> @. elite quote
20:15:33 <lambdabot> kNuT|-| 5aYS: I eNvy 4s+rOn0m3rS: pe0p1E 3xpECt T|-|em +O S7uDy $+ARz0rz BEcause 5t4r$ 4rE bEAUtIphu1 4nD iN+3rEsTiN9?
20:15:44 <dolio> Elephants shower with their nose!
20:17:46 <ray> @. elite type (&&&)
20:17:48 <lambdabot> fOrAlL (4 :: * -> * -> *) 8 C C'. (4rrow a) => a b C -> A b c' -> A B ((, (')
20:18:37 <ivanm> that's rather boring...
20:18:43 <ivanm> @. elite source partition
20:18:43 <lambdabot> PARtI+i0n n0T avaI1ABle
20:18:48 <ivanm> grrr...
20:18:50 <rooostaj> > "FOO" {-
20:18:51 <lambdabot>   <no location info>: parse error on input `-'
20:18:54 <ivanm> @. elite src partition
20:18:55 <lambdabot> Say again?
20:18:55 <rooostaj> DAMN
20:18:58 <ivanm> @src partition
20:18:59 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
20:18:59 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
20:18:59 <lambdabot>                               | otherwise = (ts, x:fs)
20:19:19 <ivanm> @. elite (src partition)
20:19:20 <lambdabot> Plugin `compose' failed with: Unknown command: "(src"
20:19:24 <ivanm> grrr....
20:19:30 <ivanm> so why does type work but not src?
20:19:33 <ivanm> @. elite type partition
20:19:34 <lambdabot> phOr4Ll 4. (A -> bOol) -> [4] -> ([A], [a])
20:19:44 <ivanm> heh
20:19:52 <ivanm> a list of fours!
20:23:02 <Philonous1> elite haskell be dependently typed. Yay!
20:27:14 * hackagebot upload: xmonad 0.9.1 - A tiling window manager (SpencerJanssen)
20:27:16 * hackagebot upload: xmonad-contrib 0.9.1 - Third party extensions for xmonad (SpencerJanssen)
20:28:59 <tensorpudding> how unfortunate, it appears i can't upgrade xmonad to the new version
20:29:07 <sjanssen> why not?
20:29:14 <tensorpudding> conflicts with containers
20:29:30 <sjanssen> if you've got 0.9 already, don't bother upgrading
20:29:33 <ivanm> tensorpudding: you have 6.12 or does it want 6.12 containers?
20:29:41 <tensorpudding> which version is in 6.12?
20:29:43 <ivanm> sjanssen: this is just for X11 compatibility? that's all thats changed?
20:29:45 <tensorpudding> i have 0.9 already
20:29:55 <sjanssen> ivanm: some docs and one minor bug
20:29:56 * tensorpudding reads the changelog
20:30:07 <ivanm> tensorpudding: 6.12 has 0.3 (6.10 had 0.2)
20:30:26 <tensorpudding> okay, yes, it wants the 6.12 version of containers
20:30:56 <ivanm> tensorpudding: no it doesn't
20:31:01 * ivanm is looking at hackage now
20:31:06 <ivanm> it doesn't list any version for containers
20:31:09 <tensorpudding> the compilation wants to get the new version of containers
20:31:40 <tensorpudding> wait, nevermind, i did it wrong
20:31:44 <ivanm> heh
20:31:52 <tensorpudding> i did caball upgrade
20:35:02 <ivanm> sjanssen: you bumped the version numbers in darcs yet?
20:35:31 <sjanssen> yes
20:35:59 <ivanm> sjanssen: and of course, you did so right after I pulled and rebuild them... :s
20:38:57 <bos> hooray! ghc stage2 is working properly again!
20:40:59 <tensorpudding> woo, i have the latest xmonad
21:08:41 <tdmackey> ;)
21:25:07 <DigitalKiwi> so haskell platform is basically a bunch of prechosen useful libraries?
21:25:50 <tdmackey> that is a decent way of looking at it
21:27:44 <tdmackey> its purpose is to enable to developers to be confident in the packages and code base they are working with
21:29:59 * DigitalKiwi guesses he probably won't need anything from it for a long time :( but good to know it exists
21:34:38 <DigitalKiwi> hmm, this says you can define operators, but can you overload them?
21:36:41 <ivanm> DigitalKiwi: no
21:37:03 <DigitalKiwi> k, thanks
21:49:23 <Cale> DigitalKiwi: Well, you can define them to be methods of a typeclass and write multiple instances of that typeclass, but essentially, operators are just treated as being functions with special syntax.
21:49:52 <Cale> :t (+)
21:49:53 <lambdabot> forall a. (Num a) => a -> a -> a
21:50:21 <Cale> ^^ (+) has a polymorphic type, and works on any type which is an instance of the typeclass Num
21:50:34 <DigitalKiwi> what is forall?
21:50:56 <Cale> Well, it's just saying explicitly that it works for all types a
21:51:07 <DigitalKiwi> ah
21:51:09 <rooostaj> (go team venture)
21:51:18 <DigitalKiwi> lawl
21:52:14 <Cale> "For all types a, if a is an instance of Num, then (+) takes two values of type a and produces a value of type a"
21:53:01 <sbenitezb> forall is explicit if you don't use it?
21:53:09 <aavogt> yes
21:53:13 <aavogt> err, implicit
21:53:15 <Cale> implicit, and yes :)
21:53:19 <sbenitezb> sorry, yes
21:53:44 <Cale> In fact, it wasn't even part of the Haskell 98 syntax
21:54:02 <Cale> But there are cases where sometimes you want to put the forall in another place, and for that, it needs to be explicit
21:54:32 <Cale> For example, if you want to write a function whose parameter must itself be a polymorphic function.
21:56:22 <DigitalKiwi> Haskell requires type names to start with an uppercase letter, and variable names must start with a lowercase letter. -- what about function names?
21:56:44 <Cale> functions are the same as variables
21:57:22 <DigitalKiwi> ah, k
21:57:26 <DigitalKiwi> thanks
21:57:27 <sbenitezb> but you can use uppercase functions too, right? I think happstack's templating does that
21:57:33 <aavogt> no
21:57:45 <aavogt> though perhaps you could see constructors as functions
21:57:47 <QtPlaty[HireMe]> sbenitezb: Uppercase is resurved for types
21:57:52 <aavogt> but they don't calculate anything
21:58:08 <Cale> At the value level, case distinguishes between data constructors (like Just, Nothing, True, False, etc.) and variables/constants. At the type level, case distinguishes between type constructors (Maybe, Bool, Integer, etc.) and type variables (usually a,b,c, but you can name them whatever you like)
21:58:52 <Cale> They're in separate namespaces, there's no way that you'll ever run into a case where something might be a type or a value.
21:59:22 <Cale> (the syntax just doesn't have any place where either a type or value could occur, it's always one or the other)
22:00:11 <Cale> Data constructors are often functions.
22:00:34 <Cale> (but I assumed he meant function bindings)
22:00:35 <sbenitezb> data are functions too :)
22:03:14 <ivanm> sbenitezb: I'd say it's the other way round
22:03:23 <ivanm> "Nothing" is not a function, it's a value
22:04:04 <sbenitezb> I assumed they were all functions that returned the value
22:04:16 <ivanm> sbenitezb: Just is a function
22:04:24 <ivanm> but "Just 2" is not a function
22:04:51 <rooostaj> @src elem
22:04:58 <lambdabot> elem x    =  any (== x)
22:06:38 <rooostaj> , time $ elem 50000 [1..]
22:06:42 <lunabot>  (2.0e-3,True)
22:07:05 <rooostaj> , time $ any (== 50000) [1..]
22:07:08 <lunabot>  (2.0997e-2,True)
22:07:08 <ivanm> @hoogle time
22:07:09 <lambdabot> package time
22:07:09 <lambdabot> module Data.Time
22:07:09 <lambdabot> module System.Time
22:07:14 <ivanm> oh, it's in lunabot
22:07:49 <rooostaj> :)
22:07:59 <clarkb> how are luna and lambda different?
22:08:24 <ivanm> clarkb: different developmental philosophies, etc.
22:09:44 * hackagebot upload: happstack-helpers 0.46 - Convenience functions for Happstack. (ThomasHartman)
22:10:27 <roostaj> , time $ foldl (\acc x -> if x == 50000 then True else acc) False [1..]
22:10:31 <lunabot>  Killed.
22:11:30 <roostaj> , time $ foldl (\acc x -> if x == 50000 then True else acc) False [1..50000]
22:11:32 <lunabot>  (8.997999999999999e-3,True)
22:12:15 <roostaj> bad implementation of elem that is.
22:12:25 <roostaj> Hofstadters Law in action
22:13:12 <dbelange> roostaj: die
22:13:22 <roostaj> dbelange: thank you
22:14:26 <Cale> , time $ foldr (\x xs -> if x == 50000 then True else xs) False [1..]
22:14:28 <lunabot>  (5.6991e-2,True)
22:15:10 <roostaj> Cale: saw the foldl elem' in a tutorial and it looked wrong
22:15:17 <roostaj> Cale: i was rightish
22:15:56 <Cale> Yeah, it's definitely something you want to use foldr for.
22:16:25 <Cale> (or something based on foldr)
22:16:29 <roostaj> Cale: that stilll seems magical (i'm new to haskell)
22:16:40 <roostaj> Cale: how does it eat up an infinite list like that
22:16:43 <Cale> @src foldr
22:16:44 <lambdabot> foldr f z []     = z
22:16:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:16:52 <Cale> foldr immediately passes control to f
22:17:08 <Cale> If f doesn't need its second parameter, the recursion never occurs.
22:17:14 <Cale> @src foldl
22:17:14 <lambdabot> foldl f z []     = z
22:17:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:17:21 <roostaj> Cale: ah ha
22:17:24 <Cale> foldl does nothing but call itself until it reaches the end
22:18:01 <roostaj> Cale: i got the impression that foldr started at the right and worked left
22:18:13 <roostaj> Cale: wrong again
22:18:27 <Cale> That's what would happen under strict evaluation
22:18:28 <roostaj> Cale: at least not in the way i was thinking of it
22:18:40 <roostaj> Cale: right
22:18:50 <Cale> But lazy evaluation is outermost first, so it turns things around a bit.
22:20:54 <roostaj> @src any
22:20:54 <lambdabot> any p =  or . map p
22:21:42 <raceRider> @src isDigit
22:21:42 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:22:04 <raceRider> @src getChar
22:22:05 <lambdabot> getChar = hGetChar stdin
22:22:18 <raceRider> @src hGetChar
22:22:18 <lambdabot> Source not found. I feel much better now.
22:22:53 <raceRider> @src init
22:22:54 <lambdabot> init [x]    = []
22:22:54 <lambdabot> init (x:xs) = x : init xs
22:22:54 <lambdabot> init []     = undefined
22:24:55 <roostaj> @src map
22:24:56 <lambdabot> map _ []     = []
22:24:56 <lambdabot> map f (x:xs) = f x : map f xs
22:25:35 <roostaj> , time $ map (+1) [1..50000]
22:25:37 <lunabot>  (0.0,[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
22:25:49 <roostaj> , time $ map (^2) [1..50000]
22:25:51 <lunabot>  (0.0,[1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400...
22:26:13 <roostaj> , time $ foldr (\x acc -> f x : acc) [] xs
22:26:13 <DigitalKiwi> map applies a function to a list right?
22:26:14 <lunabot>  luna: Not in scope: `xs'
22:26:31 <clarkb> DigitalKiwi: map applies a function to every element in a list
22:26:48 <roostaj> , time $ foldr (+1) [] [1..50000]
22:26:49 <lunabot>  luna: No instance for (GHC.Enum.Enum ([a] -> [a]))
22:27:12 <roostaj> , time $ foldr (+1) 0 [1..50000]
22:27:13 <lunabot>  luna: No instance for (GHC.Enum.Enum (b -> b))
22:27:20 <roostaj> :t foldr
22:27:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:27:35 <roostaj> , time $ foldr (+) 0 [1..50000]
22:27:37 <lunabot>  (1.3998e-2,1250025000)
22:28:26 <roostaj> @src foldr
22:28:27 <lambdabot> foldr f z []     = z
22:28:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:33:22 <sergdf> is there a cleaner way than -XFlexibleInstances to allow a String to be a member of my type class?
22:35:09 <bos> preflex: seen dons
22:35:10 <preflex>  dons was last seen on #haskell 11 hours, 45 minutes and 6 seconds ago, saying: so just for people that like beta testing
22:37:03 <ivanm> sergdf: not really, unless you do what the Show class does
22:37:22 <ivanm> bos: with Text; how stable is the actual Text datatype (are your API changes mainly for functions that use it?)?
22:37:26 <ivanm> @src Show
22:37:27 <lambdabot> class  Show a  where
22:37:27 <lambdabot>     showsPrec :: Int -> a -> ShowS
22:37:27 <lambdabot>     show      :: a   -> String
22:37:27 <lambdabot>     showList  :: [a] -> ShowS
22:37:52 <ivanm> sergdf: ^^ you have a separate list definition with a default implementation, and then get Char to override it
22:38:19 <sergdf> ivanm: interesting. thanks for the tip
22:39:02 <ivanm> sergdf: if you want a larger extended example, I did this for parsing and printing in my graphviz library for other types, not just [Char]
22:39:05 <ivanm> *as well
22:39:36 <bos> ivanm: very stable
22:39:41 <ivanm> good-o
22:39:53 <bos> ivanm: but it's completely opaque, so you wouldn't be able to tell if i changed it
22:40:00 <ivanm> bos: until you think of some other uber-efficient way of doing it? ;-)
22:40:21 <ivanm> bos: *nod* OK, how stable is the way of creating Text values?
22:40:29 <bos> 100%
22:40:45 <bos> existing API entry points are not very likely to change at this point
22:41:04 <ivanm> bos: with things like O(n) for append, is that for the first or second Text value?
22:41:25 * ivanm is wondering if he should use fullRender for pretty to create Text values or go directly with pack
22:45:13 <bos> my work on the I/O manager: http://www.serpentine.com/blog/2009/12/17/making-ghcs-io-manager-more-scalable/
22:45:13 <bos> ivanm: both
22:45:25 <ivanm> oh, n is the length of the new one?
22:45:29 <DigitalKiwi> does _ have a special meaning or is it the same as other variables?
22:45:35 <ivanm> DigitalKiwi: empty variable
22:45:49 <ivanm> I mean wildcard
22:45:52 <ivanm> that's a better term
22:46:00 <ivanm> DigitalKiwi: it matches a value, but you don't actually use it
22:46:03 <ivanm> @src (++)
22:46:04 <lambdabot> []     ++ ys = ys
22:46:04 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
22:46:04 <lambdabot> -- OR
22:46:04 <lambdabot> xs ++ ys = foldr (:) ys xs
22:46:09 <ivanm> bah, didn't have it
22:46:19 * ivanm tries to remember a @src value that might use _
22:46:25 <ivanm> @src isJust
22:46:26 <lambdabot> isJust Nothing = False
22:46:26 <lambdabot> isJust _       = True
22:46:45 <DigitalKiwi> like in lua _ is sometimes used when you want to ignore a value, but it is treated exactly like a variable and can have a value, just wondering how haskell treats it
22:47:08 <ivanm> you can't actually _use_ `_'
22:47:16 <ivanm> DigitalKiwi: ^^ in the second term, we _know_ that it must be Just, but we don't need to bother creating a named variable since we don't use it
22:48:28 <DigitalKiwi> so it's not just an idiom, it's an actual 'built in', right?
22:48:50 <roostaj> @src map
22:48:50 <lambdabot> map _ []     = []
22:48:50 <lambdabot> map f (x:xs) = f x : map f xs
22:49:04 <Gracenotes> you can use __, though
22:50:03 <DigitalKiwi> Lua and C are so ingrained into me this functional stuff is hard to change to >.>
22:50:36 <mtnviewmark> :t >.>
22:50:37 <lambdabot> parse error on input `>.>'
22:50:40 <mtnviewmark> ah well
22:50:52 <mtnviewmark> :t (>.>)
22:50:53 <lambdabot> Not in scope: `>.>'
22:52:13 <roostaj> question: how does map ($ 3) [(+4)] work? it seems that is would be equivalent to $ 3 (+4) which is impossible?
22:52:23 <roostaj> > map ($ 3) [(+4)]
22:52:24 <lambdabot>   [7]
22:52:36 <roostaj> > $ 3 (+4)
22:52:37 <lambdabot>   <no location info>: parse error on input `$'
22:52:44 <roostaj> > ($) 3 (+4)
22:52:45 <lambdabot>   Ambiguous type variable `a' in the constraint:
22:52:45 <lambdabot>    `GHC.Num.Num a' arising f...
22:52:48 <Gracenotes> roostaj: ($3) is a section
22:52:53 <mtnviewmark> the construction ($3) is equivalent to:   \a -> ($) a 3
22:53:07 <Jafet> > ($3) (+4)
22:53:07 <lambdabot>   7
22:53:14 <Jafet> :t ($3)
22:53:15 <lambdabot> forall a b. (Num a) => (a -> b) -> b
22:53:17 <mtnviewmark> what you are expecting not to work is
22:53:20 <Gracenotes> likewise, (4+) is the same as \a -> 4+a, but (+4) is the same as \a -> a+4
22:53:29 <mtnviewmark> > map ( ($) 3 ) [ (+4) ]
22:53:30 <lambdabot>   Ambiguous type variable `a' in the constraint:
22:53:30 <lambdabot>    `GHC.Num.Num a' arising f...
22:53:36 <mtnviewmark> which doesn't
22:53:40 <roostaj> ah
22:53:53 <roostaj> > map (3$) [(+4)]
22:53:55 <lambdabot>   Ambiguous type variable `a' in the constraint:
22:53:55 <lambdabot>    `GHC.Num.Num a' arising f...
22:53:59 <roostaj> > map ($3) [(+4)]
22:54:01 <lambdabot>   [7]
22:54:05 <roostaj> got it thanks!
22:54:40 <roostaj> > (+4) $ 3
22:54:41 <lambdabot>   7
22:55:01 <roostaj> > (+4) 3
22:55:02 <lambdabot>   7
22:55:30 <roostaj> > (+4) 3 * 10
22:55:31 <lambdabot>   70
22:55:38 <roostaj> > (+4) $ 3 * 10
22:55:39 <lambdabot>   34
23:07:37 <roostaj> @src (.)
23:07:37 <lambdabot> (f . g) x = f (g x)
23:12:36 <roostaj> one more $ question:
23:12:39 <roostaj> oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]
23:12:46 <roostaj> why isi the $ sign necessary?
23:13:10 <roostaj> is*
23:13:18 <mtnviewmark> because otherwise map (^2) will be applied to the list
23:13:19 <mtnviewmark> first
23:13:31 <mtnviewmark> then filter odd . will try to be appied to that
23:13:52 <roostaj> but why do i get an error?
23:13:54 <mtnviewmark> a . b . c d   parses as a . (b . (c d) )
23:13:56 <roostaj> when the $ is removed
23:14:26 <mtnviewmark> and and  " b .  " needs to be applied to a function, not a result
23:14:38 <mtnviewmark> if you wrote
23:14:50 <Jafet> > succ . 1
23:14:51 <lambdabot>   No instance for (GHC.Num.Num (f a))
23:14:51 <lambdabot>    arising from the literal `1' at <int...
23:14:53 <Jafet> > succ 1
23:14:54 <lambdabot>   2
23:14:56 <mtnviewmark> (sum . takeWhile (<10000) . filter odd . map (^2)) [1..]
23:14:59 <mtnviewmark> you don't need the $
23:15:36 <roostaj> :t (.)
23:15:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:15:42 <mtnviewmark> remember: function application binds tighter than any operator
23:15:47 <mtnviewmark> and . is just an operator
23:16:30 <mtnviewmark> so       take 5 . map (^2) [0..]
23:16:51 <mtnviewmark> is     (take 5)  . (map (^2) [0..])
23:17:03 <roostaj> mtnviewmark: (.) is expecting functions
23:17:10 <mtnviewmark> right
23:17:26 <roostaj> and functions have high(est) precedence
23:17:44 <mtnviewmark> so see how     take 5 . map (^2) [0..]    parses?    the thing on the right of the . is a list, not a function
23:17:52 <roostaj> ($) applies the function on the left to the argument on the right
23:18:05 <roostaj> > take 5 . map (^2) [0..]
23:18:06 <lambdabot>   No instance for (GHC.Enum.Enum [a])
23:18:06 <lambdabot>    arising from the arithmetic sequence...
23:18:17 <roostaj> > take 5 . map (^2) $ [0..]
23:18:18 <lambdabot>   [0,1,4,9,16]
23:18:20 <mtnviewmark> > take 5 . map (^2) $ [0..]
23:18:21 <lambdabot>   [0,1,4,9,16]
23:18:24 <roostaj> beat you :)
23:18:38 <roostaj> makes perfect sense now
23:18:43 <mtnviewmark> just because . desires functions, doesn't mean anything to the expression parsing in Haskell
23:18:57 <roostaj> right.
23:19:01 <mtnviewmark> function application still binds tighter than operator application
23:19:20 <mtnviewmark> hence you need the $
23:19:21 <roostaj> having used lisp, the lack of parenthesis is sometimes unclear
23:19:28 <roostaj> lisp is so damn explicit
23:19:32 <roostaj> :D
23:19:45 <Jafet> Precedence is no joy
23:19:50 <mtnviewmark> you'll get used to it
23:20:04 <roostaj> mtnviewmark: thanks for the explanation
23:20:05 <mtnviewmark> (though I still admit that I think $ was a poor choice typographically...)
23:20:11 <mtnviewmark> no problem - hope it helped
23:20:13 <roostaj> mtnviewmark: :)
23:20:17 <roostaj> mtnviewmark: very much so
23:20:37 <Jafet> $ is supposed to represent what you get from Haskell applications
23:20:47 <roostaj> Jafet: :D
23:21:16 <Jafet> :t <$>
23:21:17 <lambdabot> parse error on input `<$>'
23:21:19 <mtnviewmark> mnemonic: $ = the buck stops here    ---- it is the lowest precedence, nothing gets around it!
23:21:20 <Jafet> :t (<$>)
23:21:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:21:55 <roostaj> mtnviewmark: lol
23:24:41 <mtnviewmark> roostaj: now if you want some braintwisters...
23:24:44 <mtnviewmark> :t ($)
23:24:46 <lambdabot> forall a b. (a -> b) -> a -> b
23:24:48 <mtnviewmark> :t id
23:24:49 <lambdabot> forall a. a -> a
23:24:53 <mtnviewmark> :t flip id
23:24:54 <lambdabot> forall a b. a -> (a -> b) -> b
23:24:58 <mtnviewmark> : t flip (flip id)
23:25:08 <mtnviewmark> : t flip (flip id)
23:25:12 <roostaj> lol
23:25:17 <mtnviewmark> :t flip (flip id)
23:25:18 <roostaj> lambdabot flipped out
23:25:19 <lambdabot> forall a b. (a -> b) -> a -> b
23:25:43 <mtnviewmark> and yes..... flip (flip id)  is the same as ($)
23:26:05 <mtnviewmark> though Haskell can't prove that....
23:26:41 <roostaj> :O
23:26:42 <roostaj> lol
23:27:16 <mtnviewmark> or another way to think of it is:    flip ($)   is the same as   flip id
23:27:25 <mtnviewmark> which is bizarre since ($) and id have different arities!
23:28:10 <mtnviewmark> such is life in a curried, type inferring universe
23:28:38 <Saizan> mtnviewmark: marvelous?
23:28:51 <Jafet> Full of spice.
23:28:51 <roostaj> mtnviewmark: phone rang, sorry. let me look at that
23:29:16 <mtnviewmark> though, to be honest, not all that useful, just bizarre
23:29:32 <mtnviewmark> (well,   flip ($) is occasionally useful..... )
23:31:22 <BMeph> OO folks are used to defining '.' as 'flip ($)' i.e. [0..].map(^2).take 5   ;)
23:32:32 <roostaj> i dont see why flip id is typed that way
23:32:44 <roostaj> perhaps its too late at night :)
23:33:02 <roostaj> :t flip
23:33:03 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
23:33:14 <roostaj> :t id
23:33:16 <lambdabot> forall a. a -> a
23:33:28 <roostaj> @src flip
23:33:29 <lambdabot> flip f x y = f y x
23:33:29 <mtnviewmark> well, it is a puzzle... but here's a hint:    (a -> b) -> (a -> b)    is the same signature as    (a -> b) -> a -> b    .
23:33:34 <mtnviewmark> not the dropped parenthesis
23:34:15 <ivanm> @type flip id
23:34:16 <lambdabot> forall a b. a -> (a -> b) -> b
23:34:31 <ivanm> > flip id 2 succ
23:34:33 <lambdabot>   3
23:34:33 <roostaj> -> is right associative
23:34:34 <BMeph> So, ($) is a specialized form of 'id' just like 'concat' is a specialized form of 'join'. :)
23:34:37 <ivanm> cool
23:35:06 <ivanm> BMeph: except writing $ is more convenient than `id`
23:35:18 <ivanm> and even ($) can look cleaner than id in some cases IMHO
23:35:47 <roostaj> :T flip
23:35:49 <roostaj> :t flip
23:35:50 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
23:36:12 <Jafet> @src flip
23:36:12 <lambdabot> flip f x y = f y x
23:36:40 <BMeph> ivanm: Not to mention that ($) isn't usually used in a way that forces type unification of one of it's type variables into a function type... ;)
23:36:42 <mtnviewmark> roosta - still stumped?
23:36:54 <roostaj> mtnviewmark: its too late lol brain is working at 1/10 capacity
23:37:35 <roostaj> id = \a -> (a -> a) ?
23:37:38 <mtnviewmark> heh - so here's a way to think about it.... given the defintion of flip --- it needs a function that will take two arguments     a -> b _. c
23:37:39 <mtnviewmark> er
23:37:40 <roostaj> oops
23:37:42 <roostaj> ignore that
23:37:43 <mtnviewmark> a -> b -> c
23:37:49 <mtnviewmark> but id is    x -> x
23:38:08 <mtnviewmark> what type for x gets it to look like what flip demands?
23:38:17 <mtnviewmark> replace x with a-> b
23:38:24 <roostaj> ah
23:38:26 <roostaj> lol
23:38:27 <mtnviewmark> (a -> b) -> (a -> b)
23:38:37 <mtnviewmark> (a -> b) -> a -> b
23:38:39 <BMeph> I prefer saying id :: a -> a
23:39:03 <roostaj> clever
23:39:11 <BMeph> Thus if a -> (b -> c) === a -> a, that implies a === b -> c
23:39:25 <mtnviewmark> again, not practically useful, perhaps, but a useful example of how type inference works....
23:40:14 <mtnviewmark> and on that note ---- bedtime for me
23:40:16 <mtnviewmark> laters
23:40:23 <BMeph> Usually it's exploited by golfers who want to save a character by typing 'id' instead of '($)'. :)
23:40:25 <roostaj> mtnviewmark: goodnight. thanks for the help
23:40:46 <roostaj> BMeph: lol
23:40:50 <BMeph> Good night to y'all.
23:41:38 <roostaj> night
