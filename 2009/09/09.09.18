00:00:07 <Axman6> Phyx-: such as?
00:00:23 <Gracenotes> well, Bloom filters are perfectly deterministic :)
00:00:43 <Gracenotes> but I mean, not used on their own. probabilistic check + more expensive lookup if necessary
00:00:50 <sereven> Phyx-: #haskell would exile overly vocal MS haters long before exiling IE8 users I think
00:01:42 <Gracenotes> I recall Google does that for somethingoranother
00:01:58 <EnglishGent> here's what I'd like
00:02:09 <Phyx-> Axman6: for one thing, it performs beautifully in windows 7, and atleast on my computer uses far less memory than FF, isolated tabs which they were the first to introduce, and i like that since vista with protected mode on it's by far the most secure browser in terms that the browser is running in a restricted account lower than the corrently logged in user.
00:02:40 <EnglishGent> here's what I'd like:
00:02:41 <Axman6> tried chrome?
00:02:47 <whoppix> Phyx-, my opera runs on a restricted account
00:02:51 <Phyx-> sereven: i'm not so sure, granted, most people here are reasonable, the bigger majority ate _not_ MS fans
00:02:52 <EnglishGent> 1) save *everything* - my own personal way-back machine
00:03:05 <EnglishGent> no more kindle incidents, or 'whoops' did we say that
00:03:10 <EnglishGent> about Hawking?
00:03:11 <Phyx-> Axman6: i hate that  chrome messes with the title bar
00:03:31 <Axman6> i hate that I
00:03:31 <EnglishGent> 2) actually coalesce stuff - dont store n copies of byte-for-byte identical files
00:03:35 <Phyx-> whoppix: i don't think opera does it the same way.
00:03:44 <whoppix> Phyx-, no, but *I* do
00:03:44 <Axman6> IE8 uses about 40% of your screen for toolbars ;)
00:03:48 <EnglishGent> 3) make it possible to revert the browser state to state as it was at time T
00:04:02 <whoppix> Phyx-, I have a user "web", with virtually no privileges. I run opera under that user.
00:04:04 <Phyx-> *sigh* i'm lazy people... I is an extra key
00:04:16 <jafet> Why not design a modern operating system, english -- then you get most of those features for free.
00:04:28 <jafet> All you need to do is write the sockets and http code.
00:04:39 <Phyx-> whoppix: right, while IE8 would run as a user so low you can't create it in windows with the user accounts manager afaik
00:04:56 <Phyx-> Axman6: wha? I have 1 row
00:05:01 <Phyx-> which is my tabs row
00:05:09 <whoppix> Phyx-, whats that mean? that windows' user account manager sucks? :)
00:05:12 <Gracenotes> sometimes I get the feeling that YouTube uses bloom filters for its "you've watched this video" feature. I dunno, seems off at times.
00:05:42 <Phyx-> whoppix: no, it means that IE is not playing fair again :P
00:05:43 <Gracenotes> but I've watched nearly 50,000 videos. no way they would store all of them individually.
00:05:49 <Gracenotes> and for each user
00:06:30 <jafet> Why not? It's cheap.
00:06:34 <whoppix> Phyx-, well, there are lots of tools to restrict access, if you really want maximum security you can use a kernel extension like grsec or selinux, for instance (I believe such things are available for most operating systems) to take full control over every detail on what the user is allowed to do.
00:06:42 <jafet> They probably use more storage for their webserver logs.
00:07:11 <jafet> (Or use a modern operating system)
00:07:27 <Phyx-> whoppix: i'm usually not paranoid enough to use something like selinux.  :)
00:07:40 <whoppix> Phyx-, me neither. a separate user + ulimit restrictions suffice.
00:07:53 <jafet> Phyx- "Even if you're not paranoid doesn't mean they're not out to get you" ~ Abbie Hoffman
00:08:07 <whoppix> it just means they'll get you faster!
00:08:13 <Phyx-> jafet: i don't have much to get... it's all in my head!
00:09:21 * jafet logs that last line
00:10:10 <jafet> What's in your heeeaad, in your heeeeeaaad
00:11:21 <Phyx-> rock in the morning == better than coffee
00:28:08 <Alpounet> Phyx-, both are fine !
00:28:13 <Alpounet> is*
00:28:47 <Axman6> are*
00:30:21 <Alpounet> well, I meant having both is fine
00:30:39 <Alpounet> am I still wrong ?
00:35:11 <Axman6> Alpounet: "both are fine" is correct (don't ask me why, i just know it is :))
00:35:28 <Alpounet> heh OK :-)
00:36:03 <Axman6> Alpounet: i think it's because you're talking about a plural
00:36:56 <c_wraith> it depends on what is elided, actually.
00:37:19 <c_wraith> "I like having both" "(having) both is fine"
00:37:20 <Alpounet> "having both" -> is, just "both" -> are. Got it.
00:37:45 <c_wraith> "there they are" "both (of them) are here"
00:38:16 <c_wraith> Hmm.  that's actually a preposition.  So it's more complicated yet.
00:38:20 <c_wraith> Isn't english fun?
00:39:14 <jafet> English ain't no fun!
00:39:55 <Alpounet> French is much worse !
00:41:15 <FunctorSalad_> "either is fine"?
00:41:41 <Axman6> well, that's sort of short for "either one is fine"
00:41:50 <Axman6> so it's obviously singluar
00:42:16 <FunctorSalad_> Alpounet actually meant both simultaneously?
00:43:04 <Alpounet> Yep.
00:53:33 <Phyx-> "The popular online social networking site Facebook helped lead to an alleged burglar's arrest after he stopped check his account on the victim's computer, but forgot to log out before leaving the home with two diamond rings."
00:53:38 <Phyx-> lol
00:54:32 <opqdonut> lol
01:12:40 <Axman6> anyone know why this doesn't work?
01:12:50 <Axman6> > let ∑ = sum in ∑ [1,2,3,4]
01:12:50 <lambdabot>   <no location info>: parse error on input `∑'
01:14:43 <copumpkin> Axman6: it's uppercase sigma, which should be a * constructor, shouldn't it?
01:15:32 <Axman6> so the problem is that it's uppercase?
01:16:16 <copumpkin> I'd imagine
01:16:20 <Axman6> ok, ts
01:16:22 <Axman6> ta*
01:26:11 <psykotic> > let (∑) = sum in ∑ [1,2,3,4]
01:26:12 <lambdabot>   <no location info>: parse error on input `∑'
01:27:30 <psykotic> how does ghc determine which unicode symbols to treat as potential infix operators?
01:28:04 * psykotic figures it must be something in the unicode metadata tables.
01:28:12 <copumpkin> yeah, it is
01:28:30 <copumpkin> > isUpper 'a'
01:28:30 <lambdabot>   False
01:28:39 <copumpkin> > isUpper '∑'
01:28:40 <lambdabot>   False
01:28:44 <copumpkin> :o
01:28:47 <psykotic> theory exploded! :)
01:28:52 <copumpkin> > isSymbol '∑'
01:28:52 <lambdabot>   True
01:29:02 <copumpkin> I take it that isn't the greek sigma?
01:29:21 <psykotic> that's a good point, presumably there are semantic variants for the same grapheme
01:29:31 <copumpkin> > let (∑) = const sum in () ∑ [1,2,3,4]
01:29:32 <lambdabot>   10
01:29:35 <psykotic> right
01:30:02 <copumpkin> > let (∑) = sum in ([1,2,3,4] ∑)
01:30:03 <lambdabot>   10
01:30:11 <psykotic> this 'what you see ain't what you get' aspect of unicode is understandable but kind of infuriating
01:30:18 <copumpkin> I agree
01:30:20 <psykotic> i'm pretty sure security people hate unicode
01:31:30 <sereven> > isAlphaNum ∑
01:31:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:31:46 <psykotic> it'll be false
01:31:57 <psykotic>  isAlphaNum '∑'
01:32:05 <sereven> doh!
01:32:17 <psykotic> > isAlphaNum '∑'
01:32:18 <lambdabot>   False
01:32:56 <psykotic> > isAlphaNum 'Σ'
01:32:57 <lambdabot>   True
01:33:00 <psykotic> magic :)
01:33:25 <sereven> hehe, now I see what you meant about 'what you see..."
01:35:51 <sereven> > (isAlphaNum '\1003403', isSymbol '\1003403') -- isAstral?
01:35:52 <lambdabot>   (False,False)
02:02:10 <twb> The "haskell-debian vs. newest HaXml" discussion on debian-haskell is just one case of many where a binary distribution, which can only ship one version at a time, is being tripped up by libraries wanting different versions of their build dependencies.
02:02:23 <twb> AIUI this problem affect Haskell but not C, because Haskell statically links everything by default.
02:02:36 <twb> *Why* does GHC like to statically link things?
02:03:06 <ksf> because we didn't send dons enough pizza fast enough.
02:03:31 <ksf> ...stuff is going to change in 6.12, I heard.
02:03:36 <twb> So dynamic linking isn't actually implemented yet?
02:03:46 <Axman6> it is, but only on linux
02:04:30 <twb> Hm, so if debian-haskell was prepared to screw Debian/kFreeBSD, we could have dynamic linking and the problem would go away Right Now?
02:10:23 <Axman6> could someone please ban sophacles_? :(
02:11:22 <opqdonut> just ignore joins and quits
02:12:02 <Axman6> i don't want to
02:13:07 <basvandijk> Hello, does anybody know why my 'repr' package won't build on hackage: http://hackage.haskell.org/package/repr
02:14:10 <ivanm>  No instance for (ToString DString) arising from a use of `toString'
02:14:23 <ivanm> at dist/build/tmp770/Repr.hs:98:11-18
02:14:31 <Axman6> ToString? Java-- :(
02:14:36 <basvandijk> ivanm: Yes but DString has an instance for ToString
02:15:00 <basvandijk> http://hackage.haskell.org/packages/archive/dstring/0.3/doc/html/Data-DString.html#t%3ADString
02:15:49 <dobblego> ToString is .NET, toString is Java
02:16:10 <ivanm> basvandijk: you also have version dep problems there...
02:16:35 <ivanm> basvandijk: dstring needs to-string-class 0.1, but repre needs 0.1.1
02:16:39 <ivanm> so that doesn't help
02:17:15 <ivanm> basvandijk: any particular reason for having DString rather than just DList?
02:17:23 <ivanm> oh, just for IsString?
02:17:52 <basvandijk> A DString has an instance for IsString, so you can use overloaded string literals
02:18:04 <ivanm> @src IsString
02:18:04 <lambdabot> Source not found. My pet ferret can type better than you!
02:18:08 <ivanm> @hoogle IsString
02:18:08 <lambdabot> Data.String class IsString a
02:18:12 <maltem> basvandijk, surely the problem is the version mismatch
02:18:25 <ivanm> @instances-importing Data.String IsString
02:18:27 <lambdabot> [Char]
02:18:44 <maltem> basvandijk, your code uses ToString from one version, but dstring defines an instance on another
02:19:04 <maltem> that is, you have two different ToString classes there
02:19:24 <basvandijk> maltem: yes I see, that's indeed the problem... thanks guys
02:20:30 <maltem> Btw, if hackage doesn't have a "don't publish this package if there's a build failure" mode yet, it really should get one
02:20:50 <ksf> why?
02:21:02 <ksf> authors can test that more reliably than hackage.
02:21:16 <yaxu> http://docs.google.com/present/view?id=ah2x4mkf2fx_112gwnffpck # the slides from my london hug talk last night
02:21:19 <ksf> ...which lacks foreign libraries or just fails to build doctumentation.
02:21:25 <ivanm> yaxu: on?
02:21:34 <yaxu> haskell, patterns and music
02:21:54 <ksf> It'd be nice to see ~-flags, like gentoo has though.
02:22:42 <maltem> ksf, as I understand it, you cannot change a specific version upload of a package? So if there's, say, some haddock incompatibilities, and you only discover that after the upload, you have to release a new version to publish the docs
02:23:01 <ksf> yep.
02:23:13 <ksf> hackage versions include what's usually called -rcN
02:23:24 <ksf> er rN
02:24:11 <ksf> and as it's not completely trivial to get a hackage account, everyone that uploads should know about versioning...
02:24:28 <maltem> hm ok
02:25:33 <ksf> the ~ I mentioned would mean "don't install this exact version unless it's requested". you could then wait a week or two for bug reports, and if none arrive, remove it.
02:27:18 <maltem> rN is the revision? ~ sounds like it could be called the release candidate
02:28:13 <maltem> wait I see, the ~ flag would not belong to the package, but be a hackage interface thing?
02:33:49 <twb> For Darcs we version alphas and betas on Hackage with major.minor.98.n and major.minor.99.n respectively
02:33:58 <ksf> rc is release candidate, r is revision. yep. removing a ~ flag doesn't change the package, at all.
02:34:07 <twb> So e.g. 2.3~alpha4 would be 2.3.98.4
02:34:36 <ksf> I think the gentoo guys also do things like fixing dependencies without changing the version, unless really, really required.
02:36:09 <ksf> a good idea would be to annotate the version display with <epic>.<major>.<minor>.<patchlevel>
02:36:23 <twb> ksf: you mean epoch?
02:36:28 <maltem> 98 for alpha, 99 for beta - bah, ad-hoc solutions ;-P
02:36:40 <ksf> epic change, major change, minor change, bugfix.
02:37:13 <ksf> epic would be a thing like h98 -> h'
02:37:28 <ksf> (for the base libs, that is)
02:38:09 <twb> maltem: yes :-(
02:38:13 <ksf> or, of course, if a ffi lib moves from say freetype 1 to freetype 2
02:38:19 <ksf> or kde3 to kde4
02:38:29 <twb> Erm, I'm pretty sure that's an "epoch"
02:39:03 <twb> "very imposing or impressive" vs. "era: a period marked by distinctive character or reckoned from a fixed point or event"
02:39:26 <ksf> but "epoch" doesn't go well with "change". it's the span between those changes...
02:39:41 <twb> Whateve.  Home time for me.
02:39:44 <twb> *Whatever
02:40:46 <ksf> we could do negative patchlevels for release candidates.
02:41:13 <ksf> but I think there already has been enough bike-shedding, one would just have to look it up.
02:42:03 <maltem> with negative patchlevels, the order is screwed up (-1, -2, 0, 1, 2, 3)
02:42:06 <maltem> but - yeah.
02:43:21 <ksf> yep. I guess downstream wouldn't be amused.
02:44:22 <ksf> but no. I doubt any versioning code knows about negative numbers. it'll be just s/rc/-/
02:44:53 <maltem> why, then just leave the rc in
02:45:09 <ksf> yep. or use pre, which is even clearer.
02:45:30 <ksf> (and if you're as leet as the mplayer guys, you can do pre's forever)
02:58:00 <dobblego> is there a way of asking for the fixity of a function at ghci?
02:58:12 <dolio> I think :i does it.
02:58:28 <dobblego> it does indeed, ta
02:59:21 <kyagrd> :info shows it for infix operators
02:59:22 <dm2> If it doesn't show, then it is 9 by default.
03:00:04 <dm2> But would be nice if there were some easy tool to show you how your code parses.
03:00:40 <ksf> that sounds like a fun editor feature.
03:00:54 <dm2> Also, it's hard to check the fixity of non-function operators--like I don't know the fixity of "::", and don't see an obvious way to find out other than going to the haskell report.
03:00:54 <ksf> ...ghost parens.
03:01:10 <Phyx-> ksf: indeed
03:01:14 <kyagrd> Among the operators in the standard library which operator has number 9 fixity other than (.) ?
03:01:15 <dm2> Sure, would be great!
03:01:32 <kyagrd> Are there any?
03:01:34 <dm2> Anything that is not declared defaults to 9.
03:01:39 <dm2> So `blah` would be 9.
03:02:36 <kyagrd> > (+1) `id` (+2) . (*3) `id` (*4)
03:02:37 <lambdabot>   Precedence parsing error
03:02:37 <lambdabot>      cannot mix `GHC.Base.id' [infixl 9] and `GHC....
03:02:44 <kyagrd> yes it seems to be so
03:02:44 * ksf still thinks fixity levels should be strings and fixity definitions look like fixity (*) :: > additive
03:04:04 <ksf> or actually fixity (*) = muliplicative; fixity additive < multiplicative
03:05:13 <kyagrd> and let the arithmetic solver sove it that may be fun
03:05:57 <kyagrd> maybe Haskell should have done that
03:06:23 <ksf> yep the current way is way too explicit, even though it's declerative...
03:06:59 <dolio> The agda people have been considering revamping the fixity for their operators.
03:07:11 * ksf is caught in the fangs of eternal bikeshedding.
03:07:14 <dolio> But I think thus far they've been looking at partial ordering of them.
03:07:31 <dolio> Specific operators, that is.
03:07:43 <ksf> how, for fraks sake, does the right way to index fonts, faces, sizes and stuff look like?
03:07:52 <dolio> So you might have '(*) > (+) ; (/) = (*) ; ...'
03:08:44 <amoeba> maybe one should write laws, like a + b * c = a + (b * c)
03:08:53 <ksf> a total ordering doesn't make much sense.
03:09:26 <ksf> ...and a + b = b + a and extract a quickcheck property from that...
03:09:44 <dolio> A total ordering guarantees you can parse everything that doesn't directly conflict, though.
03:09:58 <jpcooper> dcoutts, I figured out how to do this without creating a dummy
03:10:04 <maltem> ksf: ... and derive the next-gen optimization technique from that ...
03:10:37 <dolio> With a partial order, you might have operators from two different libraries that get used together, but don't have an ordering, so you have to declare one yourself.
03:11:02 <ksf> I'm fine with that.
03:11:03 <dolio> Also, with stuff like 'mult > add ; ...' you can introduce cycles.
03:11:14 <ksf> I'd be glad if $ and >>= wouldn't have an order specified.
03:11:23 <ksf> ...as the current one is wrong.
03:11:33 <ksf> dolio, that's a compile time error.
03:11:38 <maltem> Warning: Orphan fixity declaration.
03:11:44 <SamB_XP_> I think it would probably be smarter to use a scale from 0 to 100 ...
03:12:03 <ksf> SamB_XP_, you're hacking around the problem.
03:12:03 <SamB_XP_> ... with some guidelines for what to use for what
03:12:20 <benmachine> make all operators infixl 5
03:12:23 <SamB_XP_> and, you know, maltem is right
03:12:24 <benmachine> then there is no problem
03:12:53 <dolio> Yeah, but you have to be careful in libraries, for instance.
03:12:54 <SamB_XP_> benmachine: or, we could just use LISP
03:13:13 <dolio> Like, you might not have cycles with library A alone and library B alone, but maybe A + B has a cycle.
03:13:22 <ksf> heck just don't export fixity if you don't export the bindings.
03:13:43 <SamB_XP_> ksf: that, too, sounds crazy
03:13:59 <maltem> SamB_XP_, actually, that would just be problem to solve for both fixities and and instances. (As for instances, I'm really interested how Agda's implicit parameters turn out to be liked)
03:14:07 <ksf> it's lexical syntax, not semantics.
03:14:33 <SamB_XP_> could be both!
03:14:56 <ksf> ...the point I'm trying to make is that it's way more sensible to have per-file syntax than per-file semantics (as in class instances)
03:15:12 <SamB_XP_> true
03:15:38 <SamB_XP_> I just meant it sounded crazy because of how much duplication of fixity declarations that would make for ...
03:15:51 <ksf> if there's no relationship specified, both have the same fixity so the lexer errors out. at least there's no semantic ambiguity.
03:17:32 <ksf> ...maybe I should start by searching a couple of paths for fonts, and then go on categorizing the ones on my system.
03:19:49 <ksf> oh, this is going to be fun. e.g. there's otf and ttf versions of libertine on my system, and they've got version numbers.
03:20:54 <ksf> do we have a library equivalent to find(1)?
03:24:42 <ksf> someone in need for an easy project idea?
03:25:05 <ivanm> ksf: I think there might be an equivalent to find somewhere
03:25:08 <benmachine> I have plenty of hard project ideas
03:25:15 <benmachine> maybe an easy one would be nice
03:25:23 <ivanm> I know a few people once did a whole bunch of common tools in Haskell as a demonstration...
03:25:31 <ivanm> no idea where you can find them now though... maybe the wiki?
03:25:57 <ksf> the task is to write something not entirely unlike find(1), starting with doing a ls -lR without choking on looping symlinks.
03:26:16 <SamB_XP_> hehehe
03:26:17 <ksf> I didn't find a library on hackage
03:26:22 <SamB_XP_> ksf just wants to steal your work ;-P
03:26:55 <ksf> seriously. it's a cool starter project. some IO, some awkwardness, lots of pure filtering.
03:27:40 * benmachine can't persuade ls -lR to loop
03:27:42 <yaxu> ksf: there's http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html
03:28:16 <SamB_XP_> benmachine: I don't think he meant to imply that it does
03:28:28 <SamB_XP_> just that it's tricky to write a Haskell library that does not
03:28:33 <benmachine> fair enough
03:28:56 <yaxu> rwh says "There are not yet portable ways to query for other file types that have become widely available in recent years, such as named pipes, hard links and symbolic links."
03:29:14 * ksf is content with posix
03:29:29 <ksf> that is, windoze just plainly doesn't exist for me.
03:29:50 <yaxu> same here
03:30:42 <SamB_XP_> well, I'm sure it wouldn't be *that* hard to get it to work on Windows, if only a few of us used it ...
03:31:08 <ray> that's it, i'm organizing a winhaskell hackathon to get all that crap working
03:31:16 <ksf> hard links can't be recursive, can they?
03:31:27 <ksf> last time I checked, my fs refused to hardlink directories.
03:31:34 <ray> heh
03:31:50 <ray> that's for sanity
03:32:08 <ray> it's concievable to allow it, but nobody would
03:32:09 <Zao> ksf: You can trivially construct recursive junctions.
03:32:10 <SamB_XP_> I think only ., children's ..s, and the directory's actual location are allowed to be hardlink to the directory
03:32:12 <ksf> but... but... they're inodes like any other!
03:32:24 <ksf> there's even a mount flag to allow it.
03:32:31 <Zao> You can even mount a filesystem in itself :)
03:32:44 <SamB_XP_> well, okay, so yeah ... you could do it
03:33:02 <ksf> Zao, yeah, but that won't recurse automagically.
03:33:06 <SamB_XP_> Zao: would that actually result in looping paths ?
03:33:11 <ksf> ...unless you do some hacking with FUSE
03:33:25 <ray> there's a reason it's disallowed
03:33:30 <ray> an obvious reason
03:33:33 <SamB_XP_> anyone who gets themselves into a situation like that is asking for trouble, I think ...
03:33:49 <Zao> SamB_XP_: H:\pr0n\pr0n\pr0n\...
03:34:04 <Zao> As long as you're sufficiently lazy when consuming it, nothing bad happens.
03:34:09 <SamB_XP_> ... though, I guess if you wanted you could keep track of "inodes" as well ...
03:34:12 <Zao> Or smack into the 32k limit of UNC paths.
03:34:18 <ray> even UNIAX isn't crazy enough to allow directory graph cycles
03:34:27 <ksf> I think tracking inodes is the right way to discover loops.
03:34:28 <ray> of course this was only implemented after it broke stuff
03:34:38 <SamB_XP_> ray: what about the aforementioned mount option ?
03:34:44 <ksf> way more efficient than checking for loops in path segments.
03:34:51 <ray> mounting is an entirely different topic, dude
03:35:04 <SamB_XP_> ray: the one that allows hardlinking directories
03:35:41 <SamB_XP_> I wonder what exactly Windows has here ...
03:35:56 <ksf> e.g. to link some directory into www-data that's being read by a server that just won't follow symlinks.
03:35:57 <ray> hah
03:36:00 <SamB_XP_> does it have something resembling inodes that you can query from userspace ?
03:36:32 <dcoutts> jpcooper: what is the solution?
03:37:03 <jpcooper> dcoutts, actually it seems not to be working so well. What I'd like to do is make the vbox have no parent. Is this possible?
03:37:05 <SamB_XP_> ksf: huh, I'd think it far more sensible to simply add the path to the server's config file ...
03:37:31 <SamB_XP_> ... personally, I would have thought fsck would freak over such a monstrosity
03:37:44 <SamB_XP_> oh, that reminds me ...
03:39:02 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Files.html#v%3AfileID
03:39:12 <ksf> dunno if windoze implements enough of posix.
03:40:36 <SamB_XP_> okay, nothing in /home/lost+found ... wonder where that other hardlink of Oracle of Ages is ...
03:40:56 <dcoutts> jpcooper: when you initially create any widget it has no parent
03:41:24 <jpcooper> dcoutts, yes true but when I load the vbox from the glade file, its parent is the window in which it is contained
03:41:33 <SamB_XP_> and for some reason I have the SRAM file hardlinked between Link's Awakening and Link's Awakening DX ;-)
03:41:42 <dcoutts> jpcooper: right, glade is special that way
03:41:43 <ray> ntfs has a table
03:41:44 <jpcooper> I'd like to give the vbox no parent so that when I append it to the notebook, it works
03:41:59 <ray> FAT is of course named after its table
03:42:16 <ray> table rows have IDs, so if you want a number there it is
03:42:22 <ksf> it'd be really cool to have standard shell commands as haskell libraries.
03:42:31 <ksf> (not just as haskell commands, that is)
03:42:45 <SamB_XP_> ray: did you miss the part where I said "that you can query from userspace"?
03:43:05 <SamB_XP_> I don't care so much how it works in the FS in this instance
03:43:09 <ray> fine, i'm sorry i answered your question
03:43:15 <ray> i'll make sure never to do it again
03:43:27 <SamB_XP_> ray: well, you answered just part of it :-(
03:43:54 <ksf> but fat doesn't have the "problem" of looping links, anyway.
03:44:02 <ksf> oh wait.
03:44:14 <ksf> symlinks are regular windoze files, aren't they?
03:44:23 <SamB_XP_> fat doesn't even have a freaking root directory
03:44:25 <ksf> just an extension and a file with the destination as content.
03:44:44 <SamB_XP_> it just has a fixed-size table of directory entries for the root!
03:45:22 <ksf> I liked how you could sort the output of dir by deframenting the fs.
03:45:24 <ray> windows never had symbolic links until vista or maybe late xp
03:45:35 <ksf> win98 had them.
03:45:41 <ray> you're thinking of shortcuts, because you don't know anything about windows
03:45:47 <ksf> yep.
03:46:13 <ray> it's so cute :)
03:46:19 <ksf> ...they're references to stuff, so a search should follow them.
03:46:38 <SamB_XP_> ray: doesn't cygwin use them to implement symlinks on 9x ?
03:46:51 <ray> i have no idea what cygwin does, and you shouldn't either
03:46:52 <ksf> well, back in win98, I still knew stuff about windoze.
03:47:04 <ray> seriously, cygwin?!
03:47:09 <SamB_XP_> well, that's way less crazy than how they do fork()
03:47:12 <ksf> I bet my sweet ass I can get dos to use less real memory than you.
03:47:27 <SamB_XP_> It's kind of surprising that Cygwin's fork() ever works!
03:48:05 <ray> it would almost be impressive, if it weren't cygwin
03:48:05 <SamB_XP_> it is kind of impressive
03:48:05 <SamB_XP_> just not anything like efficient or reliable
03:48:09 <SamB_XP_> I mean, it failed on me once or twice!
03:48:37 <SamB_XP_> I got a dialog box about how it was unable to map some DLL to the needed address in the child!
03:48:45 <ray> boooooooooooom
03:49:08 <ray> sic semper cygwin users, though
03:49:46 <SamB_XP_> I forgot what that means
03:49:46 <SamB_XP_> semper is always ...
03:49:46 <SamB_XP_> right?
03:49:46 <ray> sic semper tyrannis, allegedly shouted at caesar as he was stabbed
03:49:58 <ray> thus always to tyrants
03:50:03 <SamB_XP_> ah
03:50:08 <ray> meaning he deserved it for being a tyrant
03:50:16 <SamB_XP_> I do understand english, yes
03:50:33 <ray> meaning cygwin users deserve any crashes they get :)
03:50:42 <SamB_XP_> I don't see how that follows, though
03:50:52 <SamB_XP_> it's not necessarily their fault they have to use windows
03:51:04 <ray> it's almost certainly their fault they're using cygwin
03:51:05 <ksf> it actually means that m$ deserves all the hate they get.
03:51:14 <ray> it's exactly that attitude that i take exception to
03:51:26 <SamB_XP_> what do you think they should do instead of using cygwin?
03:51:39 <ray> use windows
03:51:40 <ksf> using wine.
03:51:48 <ray> that's what most windows users do
03:52:09 <sereven> ksf: there's hsh with some bits you might want http://hackage.haskell.org/packages/archive/HSH/1.2.6/doc/html/HSH-ShellEquivs.html
03:52:50 <SamB_XP_> ray: most windows users, apparently, don't want to do complicated things
03:52:55 <SamB_XP_> or wish they were using *nix
03:53:00 <ray> see, there's that attitude again
03:53:15 <SamB_XP_> I mean, complicated things that they can't find applications for
03:53:19 <ray> disclaimer: it only drives me crazy because it's embarassing that i used to act that way when i was in the cult
03:53:24 <ksf> there's not even ls there, much less find
03:53:25 <ray> so it's not you, it's me
03:53:31 <SamB_XP_> I'm trying not to be in a cult
03:54:16 <SamB_XP_> but the windows shell and tools just don't have the affinity for the unexpected that *nix tools do ...
03:54:20 <ksf> well, it's m$ that's to blame for not being sufficiently compatible to any other OS out there.
03:54:45 <ray> maybe you should learn about windows instead of burying your head in a cheap imitation unix
03:54:46 <SamB_XP_> ... for instance, it's kind of sad that they think "windows shell" somehow involves the GUI
03:55:10 <SamB_XP_> ray: well, that might be easier if it came with some documentation!
03:55:19 * ksf has used both *bsd and solaris.
03:55:34 <ray> i really hope both of you are just messing with me now :)
03:56:07 <ksf> fdisk /fixmbr?
03:56:11 <SamB_XP_> no, seriously, a part of me longs for the DOS days when you actually got documentation of a technical nature *with* your MS OS
03:56:13 <ksf> did they document that yet?
03:56:28 <SamB_XP_> maybe not complete, but at least it didn't assume you were an idiot
03:56:35 <SamB_XP_> and you could find things in it
03:57:15 <SamB_XP_> gone are the days when they include documentation for the CLI with the OS :-(
03:57:19 <jnwhiteh> dcoutts: you around by any chance?
03:57:22 <ray> i don't know what to say
03:57:28 <jnwhiteh> cabal-install's bootstrap.sh is failing on my machine, and the error messages are very.. odd.
03:57:35 <ray> except that i cordially invite you to try windows
03:57:39 <ray> you might be surprised
03:57:48 <ray> as long as you don't try to hide from it
03:57:52 <SamB_XP_> ray: what, you want me to use that dinky "GUI" thing?
03:58:03 <ksf> you see, if I were the leading windows engineer, it would use grub to boot.
03:58:04 <SamB_XP_> well, okay, it works for web browsing, and IRC
03:58:10 <SamB_XP_> and foobar2000 is nice
03:58:14 <jnwhiteh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3694#a3694
03:58:42 <ray> i was a linux zealot once
03:58:54 <SamB_XP_> I'm no zealot
03:58:55 * ksf had to use windoze at work.
03:58:58 <ray> i even said things like that
03:59:04 <ksf> I installed bbwin to make it usable.
03:59:14 <SamB_XP_> I just lament the sad, non-composable state of most windows tools
03:59:25 <dcoutts> jnwhiteh: hia
03:59:30 <SamB_XP_> getright is a nice exception
03:59:31 <jnwhiteh> dcoutts: :P
03:59:42 <ksf> and witnessed things like javac failing as a user, and succeeding as admin.
03:59:42 <SamB_XP_> it actually comes with documenation on it's command-line flags
03:59:48 <jnwhiteh> dcoutts: Seen anything like this?
04:00:26 <Raevel> aiia, ghc abort trap
04:00:32 <SamB_XP_> ray: oh, and is there some viable alternative to running as a user with Admin privileges on XP?
04:00:32 <dcoutts> jnwhiteh: 64bit OSX by any chance?
04:00:46 <jnwhiteh> dcoutts: its snow leopard, yes.
04:00:48 <ray> viable? alternative? admin? xp?
04:00:52 <lilac> SamB_XP_: sure, use vista :)
04:00:58 <SamB_XP_> yes, I'm IRCing from admin
04:01:00 <ray> use vista to *start*
04:01:08 <SamB_XP_> hahaha
04:01:17 <SamB_XP_> this thing does not have enough RAM for that, I think
04:01:29 <lilac> then wait for windows 7 to be released, i guess
04:01:34 <ray> http://www.youtube.com/watch?v=ifoe5LTyyKM
04:01:39 <SamB_XP_> what, that doesn't need more ?
04:01:45 <SamB_XP_> lilac: what, it isn't yet?
04:01:48 <ksf> windows 7's boot loader won't fit into my 1gb.
04:01:49 <lilac> no, it needs less, from what i've heard
04:01:50 <SamB_XP_> so many people seem to use it
04:02:02 <ray> samb_xp_: see youtube link
04:02:11 <dcoutts> jnwhiteh: I'm trying to find the email describing the workaround...
04:02:13 <ray> actually, don't
04:02:16 <ray> i'll feel guilty if you watch it
04:02:30 <jnwhiteh> dcoutts: thanks, I'd really appreciate it.. Unfortunately I'm not in a position where I can downgrade or get another machine to run these benchmarks :P
04:02:31 <Alpounet> lol
04:02:35 <SamB_XP_> ray: are you trying to rickroll me?
04:02:38 <SamB_XP_> or worse?
04:02:40 <ray> worse
04:02:43 <ray> much worse
04:02:51 <lilac> ray: you think SamB_XP_ can watch fullscreen flash video smoothly? ;)
04:03:03 <ray> no need to watch it fullscreen, i guess
04:05:46 * ksf wonders why xmobar is using more memory than xmonad
04:06:59 <sereven> ksf: xft color allocation bug I believe. there's some info on xmobar's bug tracker
04:08:02 <ksf> well I don't really care about 10 megs of ram as long as a konsole instance uses 15, xchat 26, X 110 and firefox 126
04:08:52 <SamB_XP_> ksf: how did you get firefox to stay so slim?
04:08:54 <dcoutts> jnwhiteh: http://hackage.haskell.org/trac/ghc/ticket/2965#comment:24
04:08:59 <sereven> ksf: you could just restart xmobar, if it's the one I'm thinking of it builds up pretty slowly. with my setup had never even noticed it, had to set up a disco light show to observe after a few days runtime.
04:09:02 <SamB_XP_> and my xchat uses about 100, I think
04:09:09 <SamB_XP_> I guess it's because I set my scrollback so high ;-)
04:09:10 <jnwhiteh> dcoutts: thank you much!
04:09:26 <SamB_XP_> not this one -- the one with nick SamB ;-)
04:09:44 <ksf> resident, not virtual, that is.
04:09:47 <dcoutts> jnwhiteh: I had to ask Simon, I was misremembering where the info got posted :-)
04:09:54 <SamB_XP_> ksf: oh
04:09:56 <ksf> xchat should be smart enough to write to a file and mmap it.
04:10:25 <ray> copy on read
04:10:32 <SamB> resident is 35M
04:10:39 <SamB> right now
04:10:43 <SamB> for xchat
04:10:45 <ksf> but I doubt gtk is smart enough only to render stuff that's displayed.
04:10:46 <jnwhiteh> dcoutts: well very much appreciated, i would have been sad to not include haskell in this benchmark :P
04:10:53 <SamB> iceweasel is not running
04:11:11 <dcoutts> jnwhiteh: especially since Haskell is going to come out on top ;-)
04:11:17 <SamB> ksf: I'm pretty sure it isn't rendering the entire scrollback!
04:11:18 <ksf> such things are the reasons why computers are getting slower all the time.
04:11:20 <SamB> it's really long
04:11:29 <jnwhiteh> dcoutts: not quite :P
04:11:32 <SamB> though probably not long enough for even half a day in #haskell
04:11:47 <jnwhiteh> on average it comes in 7th
04:11:53 <dcoutts> doh!
04:12:00 <ksf> render as in format, calculate, etc. not as in blit.
04:12:12 <SamB> ksf: oh, that
04:12:17 <jnwhiteh> But I think much of that is the implementation of the library, not Haskell
04:12:23 <SamB> not sure how that works in x-chat
04:12:46 <Alpounet> wow, my #haskell log is becoming kinda big...
04:12:51 <dcoutts> jnwhiteh: chp right?
04:12:54 <SamB> it seems to scroll in whole-line increments only ...
04:12:57 <ksf> I'm absolutely certain that a gtk treeview calls cellrenderers for the whole thing.
04:13:07 <dcoutts> ksf: yep
04:13:12 <SamB> ksf: eww
04:13:12 <jnwhiteh> dcoutts: yep
04:13:29 <SamB> but this is no treeview, this is the chat text we're discussing
04:13:33 <dcoutts> SamB: why eew?
04:13:34 * jnwhiteh curses the kent retargetable occam compiler!
04:13:44 <ksf> ...which is kinda dissapointing if you are trying to calculate expensive stuff only when the user can see it.
04:14:02 <SamB> dcoutts: it'd be nice if it only called them for ones that actually might appear on the screen in the quasi-near future
04:14:12 <dcoutts> ksf, SamB: ohh, you mean non-visible stuff too, I misunderstood
04:14:39 * SamB is already late for school..
04:15:25 * ksf is late for his nap
04:15:39 <dcoutts> ksf, SamB: it has to measure the widths and heights of things to know how wide the columns need to be and where the scroll bar is etc. However for large datasets you can set it into fixed width and height mode where you set a homogeneous line hight and fixed width columns and then it'll only need to inspect the data for the visible area.
04:16:38 <ksf> that might be.
04:17:07 <dcoutts> ksf: that's the whole purpose of the fixed width mode
04:17:10 <ksf> ...but the real reason that I abandoned gtk was treeview not being able to have subitems with different columns than its parent item.
04:17:32 <dcoutts> nested columns
04:18:13 <dcoutts> ksf: yes it's not a full tree with each level having independent info, it's really tabular
04:23:17 <dobblego> is it first and second that can be constructed from arr and (>>>) ?
04:24:29 <Saizan_> and (***)
04:24:40 <ivanm> is the State Monad valid for turning functions like "a -> b -> c -> d -> c" into just "c -> d -> c" where a and b are constants that are being passed around everywhere?
04:25:07 <Saizan_> that looks more like the Reader monad
04:25:11 <opqdonut> ivanm: isn't that more Reader
04:25:21 <ivanm> no idea ;-)
04:25:25 <dobblego> yep Reader
04:25:28 <ivanm> never really used any of them
04:25:31 <ivanm> @hoogle Reader
04:25:31 <lambdabot> module Control.Monad.Reader
04:25:31 <opqdonut> :D
04:25:31 <lambdabot> Control.Monad.Reader newtype Reader r a
04:25:31 <lambdabot> Control.Monad.Reader Reader :: (r -> a) -> Reader r a
04:25:35 <dobblego> @type (>>=)
04:25:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:25:47 <dobblego> (t -> a) -> (a -> t -> b) -> t -> b
04:25:50 <opqdonut> ivanm: Reader basically epxresses functions that access a common environment r
04:25:55 <ivanm> *nod*
04:26:05 <opqdonut> which they can read, and pass an annotated env to functions they call
04:26:20 <ivanm> Reader is in mtl?
04:26:27 <opqdonut> but they can't affect the environment anywhere else than below themselves in the call tree
04:26:31 <opqdonut> iyswim
04:26:33 <opqdonut> yes, mtl
04:27:09 <ivanm> iyswim == if you see what I mean?
04:28:01 <ivanm> is there any other similar monads which might be applicable?
04:29:41 <opqdonut> ivanm: yes, correctly deciphered
04:29:50 <opqdonut> well state is useable, of course
04:30:31 <ivanm> with state, I would have c in there as well and update the c in the State monad?
04:30:33 <benmachine> reader is basically a simplification of state
04:30:46 <ivanm> benmachine: a relatively immutable state?
04:30:59 <benmachine> mm
04:31:42 <benmachine> well, I shouldn't comment because I haven't used Reader really
04:32:01 <benmachine> just ReaderT which is a different kettle of fish
04:33:45 <ivanm> is "asks f" just "ask >>= (return . f)" ?
04:34:06 <dschoepe> ivanm: yes
04:34:12 <dschoepe> @src asks
04:34:12 <lambdabot> asks f = do
04:34:12 <lambdabot>     r <- ask
04:34:12 <lambdabot>     return (f r)
04:34:26 <ivanm> duh, didn't think of @src
04:35:19 <benmachine> fmap f ask
04:35:54 <ivanm> opqdonut: with state, I would have c in there as well and update the c in the State monad?
04:36:11 <opqdonut> ivanm: yeah
04:36:22 * ivanm might do that just to be lazy then...
04:36:29 <opqdonut> RWS is a combination of reader, writer and state monads
04:36:38 <Saizan_> you could use ReaderT (a,b) (State c)
04:36:42 <opqdonut> excellent for imperativish stuff
04:37:44 <ivanm> from the docs for execState: "Very much like snd composed with runstate. " ... very much like? it _is_ snd . runstate s!
04:38:03 <ivanm> opqdonut: why would you need reader and writer with state?
04:38:14 <ivanm> isn't state a "superset" of reader and writer?
04:38:19 <opqdonut> sure
04:38:21 <ivanm> or to keep track of the different environments?
04:38:28 <maltem> GHC question: Why is PatternSignatures deprecated in favour of ScopedTypeVariables - they do different things?
04:38:31 <opqdonut> but you can guarantee more properties by using RWS
04:38:58 <opqdonut> and you don't have to manually revert changes when doing reader-ish modification
04:38:59 <ivanm> opqdonut: so have read-only, write-only and R/W values?
04:38:59 <Saizan_> maltem: ScopedTypeVariables, despite the name, now includes the features of PatternSignatures
04:39:17 <Saizan_> ivanm: Writer is not the opposite of Reader
04:39:32 <ivanm> Saizan_: isn't Writer write-only stuff?
04:39:35 <maltem> Saizan_, and there's no non-deprecated way of getting the features of PatternSignatures without having ScopedTypeVariables?
04:39:44 <Saizan_> ivanm: no, it's more like logging stuff
04:39:44 <opqdonut> ivanm: Writer is something different
04:39:50 <ivanm> maltem: why don't you want scoped type variables?
04:39:52 <opqdonut> it's for aggregating
04:39:53 <ivanm> Saizan_: oh, appending?
04:39:57 <ivanm> *nod*
04:40:00 <opqdonut> ivanm: general monoid
04:40:17 <ivanm> *nod*
04:40:17 <maltem> ivanm: I don't particularly care, but I don't want in general to use tons of exceptions
04:40:18 <Saizan_> maltem: no
04:40:23 <maltem> ok
04:40:30 <ivanm> maltem: you mean extensions?
04:40:41 <maltem> er, yes
04:40:45 <ivanm> heh
04:41:24 <ivanm> that reminds me... the other day I was at a scala talk where they said how great it is that scala doesn't support checked exceptions (instead they recommend pseudo-maybe and -either)
04:41:51 <ivanm> and then I saw somewhere about peopler proposing adding checked exceptions to haskell :s
04:42:17 <dobblego> dirty stinkin' buggers
04:42:55 <ivanm> http://www.reddit.com/r/haskell/comments/9krhw/explicitly_typed_exceptions_for_haskell_slides/
04:44:06 <ivanm> opqdonut, Saizan_: so the reason for using RWS over just State (especially since I don't need Writer support) is that it's safer for the read-only values (can't accidentally over-write them)?
04:44:10 <Alpounet> ivanm, it depends on how it'd be introduced, it might not be that bad !
04:44:32 <Saizan_> i think we can easily use the type system for them
04:44:41 <Saizan_> *existing
04:44:47 <ivanm> well, it'd be better in that it's a PITA to use throw, catch, etc. because you have to look up the right docs for which exception to catch...
04:45:00 <ivanm> whereas with checked exceptions it'd be obvious
04:45:00 <Saizan_> ivanm: i wouldn't use RWS if you need only Reader and State
04:45:06 <ivanm> *nod*
04:45:41 <ivanm> since this is an internal-only usage of R+S, if I promise to be really careful can I even do away with Reader and just use State? :p
04:45:41 <Saizan_> i'd use ReaderT/State
04:45:56 <Saizan_> it's your code
04:46:01 <ivanm> heh
04:46:33 <ivanm> Saizan_: I probably should use ReaderT/State... except that I think I should first make sure I know how to use State before attempting monad transformers :s
04:46:50 <ivanm> (especially since I really should have stopped procrastinating and had this code done a few days ago at least :s )
04:46:54 <dolio> ReaderT r (State s) should actually be exactly the representation of RWS without the W.
04:47:05 <ivanm> dolio: which is what I figured
04:47:05 <dolio> r -> s -> (a, s)
04:47:16 <Saizan_> @unmtl RWS r w s
04:47:16 <lambdabot> err: `RWS r w s' is not applied to enough arguments, giving `/\A. r -> s -> (A, s, w)'
04:47:19 <Saizan_> @unmtl RWS r w s a
04:47:19 <lambdabot> r -> s -> (a, s, w)
04:47:19 <ivanm> I thought RWS was just ReaderT / WriterT / State
04:47:35 <ivanm> is that Cale's contribution to lambdabot errors?
04:47:46 <ivanm> @hoogle RWS
04:47:46 <lambdabot> module Control.Monad.RWS
04:47:46 <lambdabot> Control.Monad.RWS.Lazy newtype RWS r w s a
04:47:46 <lambdabot> Control.Monad.RWS.Lazy RWS :: (r -> s -> (a, s, w)) -> RWS r w s a
04:48:40 <ivanm> I've heard/read though that mtl is no longer the preferred monad transformer lib... should I be using something else or is mtl still OK to use?
04:49:06 <Saizan_> there's no accepted new standard, afaik
04:49:11 <ivanm> *nod*
04:49:15 <ivanm> just multiple proposals?
04:49:31 <Saizan_> yeah
04:50:19 <Saizan_> uhm, i can't see the slides from scribd
04:50:55 <ivanm> Saizan_: for what?
04:50:58 <ivanm> the checked exception stuff?
04:51:10 <ivanm> if so, the reddit comments had a pdf link
04:52:40 <Saizan_> yeah, just saw that
04:55:13 <dobblego> are the arrow laws on haskell.org somewhere?
04:59:10 <dolio> http://www.haskell.org/arrows/biblio.html
04:59:19 <dolio> The Hughes paper has laws.
04:59:28 <psykotic> draconian laws
04:59:46 <dolio> You can also look for Idioms are Oblivious ...
04:59:49 <ivanm> gah, straight away the State monad doesn't like me!
04:59:49 <psykotic> with arrows there are many different choices of possible laws
04:59:59 <psykotic> (beyond the most common ones)
05:00:10 <ivanm> if I have a state of type s, and a function s -> a, how can I get the a value?
05:00:44 <psykotic> the state monad lifts a to s -> (s, a), not s -> a
05:00:54 <dobblego> State s a ... s -> (s, a)
05:00:57 <ivanm> oh...
05:01:05 <dobblego> you're asking (s -> (s, a)) -> (s -> a) -> a
05:01:42 <psykotic> you can think of it being a bunch of two adjoint functors, one allowing state-dependent behavior (the (s ->) functor), the other allowing state-changing behavior (the (s,) functor).
05:01:48 <psykotic> err, a composition of two adjoint functors, even
05:02:30 * ivanm is confused
05:02:35 <psykotic> sorry :)
05:03:11 <psykotic> the point is that State provides two different features, related but in a sense independent
05:03:14 <ivanm> all stuff on (State s a) is a function that transforms the current state into the new state and some other value?
05:03:25 <psykotic> if it gave you s -> a, it would mean you could have state-dependent values, but you couldn't change the state
05:03:32 <psykotic> yes
05:03:49 <psykotic> in fact s -> a would be the reader monad
05:03:53 <ivanm> so if I'm wanting to pass around a value to get updated as I do stuff, is that the s or the a in State s a?
05:04:04 <psykotic> s
05:04:15 <psykotic> you should think of it as currying: (State s) a
05:04:25 <psykotic> State s describes a computation where the 'global state' has type s
05:04:36 <psykotic> within that computation you can different computations yielding different value types, unrelated to the state
05:05:12 <ivanm> OK, tell me if this is a valid use of State:
05:05:21 <psykotic> btw note that when s is a monoidal type, then the (s,a) functor that's the other half of State, is the writer monad
05:05:36 <psykotic> so the slogan is state is what you get when you put compose the writer and reader monads, almost
05:05:54 <ivanm> I'm getting the output of parsing a module with HSX, and I'm wanting to go through the parsed values and storing which ones I find along with all the function calls in there
05:06:00 <ivanm> with the type storing all this info being the State
05:06:18 <psykotic> right. so just create a record type and let that be your s
05:06:26 <ivanm> am I doing this right, or should I stick to more of a mapAccum kinda thing
05:06:31 <ivanm> psykotic: which is kinda what I have
05:06:47 <dschoepe> ivanm: yes, but if you only want to access the collected values afterwards, Writer would be enough
05:06:52 <psykotic> right
05:06:56 <ivanm> I was trying to avoid using ReaderT/State like Saizan_ and opqdonut were suggesting by having some fixed info being passed around in it as well
05:06:59 <psykotic> which comes back to what i said about state being reader + writer
05:07:04 <ivanm> dschoepe: I'm not appending though...
05:07:14 <dschoepe> ivanm: it works on any monoid
05:07:24 <psykotic> you can have Maybe
05:07:40 <psykotic> with 'replacement semantics'
05:07:54 <psykotic> starts out Nothing, overwrites previous value, etc
05:07:54 <ivanm> I have a record type like: M { entity :: Set Entity, funcCalls :: Set (Entity,Entity) }
05:08:20 <ivanm> (with a few other specialised versions of the entity value)
05:08:26 <dolio> @type mapAccumL
05:08:27 <dschoepe> hmm Set isn't a Monoid due to the Ord constraint, is it?
05:08:27 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:08:28 <mmorrow> @unmtl WriterT w (Reader r) a
05:08:28 <lambdabot> r -> (a, w)
05:08:40 <mmorrow> @unmtl ReaderT r (Writer w) a
05:08:40 <lambdabot> r -> (a, w)
05:08:46 <ivanm> dschoepe: yup
05:09:17 <mmorrow> so if you additionally feed `w' back into `r'
05:09:20 <dolio> @type (runState .) . mapM . State
05:09:20 <lambdabot>     Couldn't match expected type `a -> m b'
05:09:21 <lambdabot>            against inferred type `State s a1'
05:09:21 <lambdabot>     In the second argument of `(.)', namely `State'
05:10:01 <dolio> @type (runState .) . mapM . (State .)
05:10:02 <lambdabot> forall a s a1. (a -> s -> (a1, s)) -> [a] -> s -> ([a1], s)
05:10:08 <dolio> I was close.
05:10:22 <ivanm> so there's no way of just getting the current state without modifying anything?
05:10:30 <psykotic> you just get
05:10:33 <mmorrow> getting literally mapAccum is epic with State, since you have to do a bunch of flipping
05:10:53 <dolio> Yeah, I'm not going to bother with that.
05:10:59 <ivanm> psykotic: yes, but when I try to do anything like "fmap f get" or something I get a type error
05:11:00 <psykotic> ivanm: you shouldn't be messing with the data underlying 'State' anyway. you should use get, put, etc
05:11:06 <dolio> mapAccumL is mapM in State. mapAccumR is mapM in backward State.
05:11:10 <ivanm> psykotic: that's what I'm _trying_ to do!
05:11:43 <psykotic> well, before you seemed to be writing manual s -> a types
05:11:46 <psykotic> which suggests otherwise
05:12:06 <mmorrow> ivanm: gets
05:12:28 <ivanm> gah, it doesn't help that I used data rather than type :s
05:13:18 * ivanm bangs his head against the desk
05:13:42 <ivanm> also, it seems usage of gets requires explicite type sigs...
05:14:01 <mmorrow> ivanm: what type are you working with?
05:14:17 <ivanm> mmorrow: a custom one
05:14:28 <ivanm> or do you mean which MonadState instance?
05:14:29 <mmorrow> ivanm: what's the definition ? :)
05:14:46 <ivanm> data Foo = F { bar :: Bar, baz :: Baz }
05:14:51 <ivanm> I was trying to do "gets bar"
05:15:03 <ivanm> with the state being "State Foo a"
05:15:08 <mmorrow> err, so you're working with a generic MonadState context then i guess
05:15:12 <mmorrow> oh
05:15:25 <mmorrow> i don't seen why that wouldn't work
05:15:34 <mmorrow> @type get rootLabel
05:15:35 <lambdabot> forall a s. (MonadState s ((->) (Tree a -> a))) => s
05:15:37 <mmorrow> @type gets rootLabel
05:15:37 <lambdabot> forall a (m :: * -> *). (MonadState (Tree a) m) => m a
05:15:38 <ivanm> except I didn't put a type sig at first because I wasn't sure how it was going to work
05:16:04 <ivanm> (and when I tried, usage of "data FSTate = State Foo" rather than type didn't help...)
05:16:55 <mmorrow> i'm confused. stepping back, what is the goal here?
05:17:01 <lilac> ivanm: using 'gets bar' with no type sig should work fine there, as long as the type of the monad is deducible
05:17:32 <ivanm> mmorrow: I'm trying to work out how to use the State monad, without bothering to work out how to use ReaderT/State ;-)
05:17:38 <lilac> gets just introduces a MonadState constraint. if you've got a call to runState somewhere you should be ok
05:17:51 <ivanm> lilac: no other state stuff yet ;-)
05:18:28 <mmorrow> ivanm: you can always just write your own State monad, which is what i usually do so i don't need mtl
05:18:52 <lilac> > runState (do x <- gets head; y <- gets (head . drop 1); return (x+y)) [1,4,9]
05:18:52 <lambdabot>   (5,[1,4,9])
05:19:02 <ivanm> mmorrow: hmmm....
05:19:04 <ivanm> maybe later
05:19:22 <lilac> ivanm: ^^ it's the 'runState' which allows GHC to infer the monad is State [Int]
05:19:32 <ivanm> *nod*
05:20:00 <mmorrow> ivanm: i just mean that if you're trying to get State straightened out wrt what it  is you're doing, it may be more straightforward without all the MonadFoo classes and such
05:20:10 <mmorrow> get :: MyState s s
05:20:33 <ivanm> just copy-pasta the definition of State the underlying plumbing?
05:22:17 <mmorrow> ivanm: sure, or just write it from memory/figure it out if it's not ingrained in yoar brain ;)
05:22:33 <ivanm> heh, since I've never used State before, it's not really ingrained there yet ;-)
05:22:54 <mmorrow> ivanm: it'd be a good exercise to try to write it without looking first
05:23:11 <lilac> @djinn (s -> (s, a)) -> (a -> s -> (s, b)) -> (s -> (s, b))
05:23:11 <lambdabot> f a b c =
05:23:11 <lambdabot>     case a c of
05:23:11 <lambdabot>     (d, e) -> b e d
05:23:20 <mmorrow> @slap lilac
05:23:21 * lambdabot moulds lilac into a delicous cookie, and places it in her oven
05:23:27 <ivanm> mmorrow: I started doing that once (IIRC, it was one of Cale's impromptu IRC tutorials) and could never figure it out :s
05:23:43 <mmorrow> ivanm: lilac just gave you (>>=)
05:23:47 * ivanm can use "normal" monads OK, but how they work is still pretty much black magic :s
05:24:01 <ivanm> mmorrow: and it looks like gobble-de-gook to me :p
05:24:22 <lilac> ivanm: yeah, if you want to understand it you should probably write it yourself :)
05:24:33 <mmorrow> ivanm: it will until you write it yourself
05:24:36 <ivanm> *nod*
05:24:40 <ivanm> leaving that aside for now...
05:24:40 <lilac> a bit of alpha-conversion on djinn's function would help a lot though
05:24:57 <ivanm> if originally I had a function "s -> a -> s", and I'm replacing this with some State-like monad, how do I represent this function?
05:25:06 <ivanm> (for a class function)
05:25:30 <dobblego> s -> a -> s looks like Const to me
05:25:40 <ivanm> it's an updating function
05:25:43 <lilac> i assume this is for a specific s and a
05:25:47 <ivanm> lilac: yes
05:25:54 <ivanm> well, s is specific; a isn't
05:26:09 <lilac> first flip it to (a -> s -> s)
05:26:11 <ivanm> (well, it's specific to the instance anyway)
05:26:22 <dobblego> @src Endo
05:26:22 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:26:26 <ivanm> is it just foo :: State s a ?
05:26:28 <lilac> then partially apply to get an (s -> s), then give that to modify
05:26:52 <ivanm> lilac: no, I'm wanting to _replace_ the big huge ugly "normal" function with a State-based one
05:26:59 <ivanm> (to avoid explicitly passing the variables around)
05:27:10 <lilac> ivanm: oh, you want to replace the /implementation/, not just use it from the state monad?
05:27:16 <ivanm> lilac: yes
05:27:25 <ivanm> (well, I haven't written any implementations yet... :p )
05:27:34 <lilac> ivanm: well the same thing applies. flip it first, so it's s -> s. then write it as State s ().
05:28:08 <ivanm> so from "class UpdateFoo a where updateFoo :: Foo -> a -> Foo"
05:28:10 <lilac> finally, execState (State s ()) :: s -> s
05:28:32 <ivanm> lilac: then where's the mention of a in there to stop the type checker from complaining?
05:28:49 <ivanm> a -> State s () ?
05:28:57 <ivanm> no, wait, that's stupid
05:29:08 <lilac> you may as well keep the interface the same
05:29:14 * ivanm might be trying to be too ambitious...
05:29:41 <ivanm> lilac: uhhh, the whole reason I thought about using State was to avoid having to pass a whole bunch of variables around everywhere...
05:29:53 <lilac> if you have 'doUpdate :: a -> State Foo ()', then 'updateFoo = flip (execState . doUpdate)'
05:29:56 <ivanm> so keeping the interface the same means there's no point in me using State at all...
05:30:28 <lilac> ivanm: it's pretty easy to use functions 'f :: state -> state' within the State monad
05:30:58 <ivanm> lilac: well, the function type is actually "parseInfo :: ModName -> EntityLookup -> ParsedModule -> a -> ParsedModule"
05:31:15 <ivanm> I was trying to combine the first three params into being the state
05:31:29 <lilac> ivanm: is it the implementation or the interface which you want to clean up with the State monad?
05:31:35 <ivanm> interface
05:32:00 <sioraiocht> which ghc flag tells you which rewrite rules triggered and how many times?
05:34:07 <ivanm> lilac: well, that is, if by "interface" you mean the type sig
05:34:37 <lilac> ivanm: i mean, is it the code which calls parseInfo or the body of parseInfo where you're passing around ParsedModule and you'd rather you weren't?
05:35:05 <ivanm> lilac: I want to avoid passing around values for parseInfo
05:35:56 <lilac> you mean in the code which calls parseInfo?
05:37:04 <ivanm> I want to reduce parseInfo's type sig
05:37:12 <ivanm> since a lot of times parseInfo will be recursive
05:38:01 <lilac> ok, i see.
05:38:03 <maltem> ivanm: parseInfo :: MyState -> a -> MyState -- ?
05:38:49 <ivanm> maltem: I was thinking that, but is that actually proper usage of the State monad?
05:38:58 <maltem> ivanm: That's not using the State monad at all
05:39:05 <ivanm> which is what I thought
05:39:30 <maltem> I just mean, there's no point in the State monad if you just want to clean up the type of this one function
05:40:37 <ivanm> *sigh* so I'm using an ugly conglomerate type to pass around rather than a few smaller types with only one of them being returned
05:40:39 * ivanm cries
05:43:13 <ivanm> OK, if I just went back to what I was originally going to do and use the reader monad just to store the ModName and EntityLookup values, would that be shorter/worth it?
05:43:16 <lilac> ivanm: you could do something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9489#a9489
05:43:48 <lilac> then for each instance, implement parseInfo or parseInfoS depending on which is more convenient
05:43:51 <ivanm> lilac: heh, kinda defeats the point IMHO
05:44:35 <lilac> ivanm: it means the instances are easy to write, and code which calls parseInfo doesn't need to worry about the details of the state monad
05:45:33 <ivanm> oh, you can do "a -> State s ()" ?
05:45:41 * ivanm thought that wouldn't work for some reason...
05:45:57 <opqdonut> :t put
05:45:58 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
05:45:59 <lilac> i'd pull out 'modify (\d -> d { parsedModule = mod' })' into a separate 'setParsedModule :: ParsedModule -> State ParseData ()' function
05:46:09 <ksf> ls --color -R /usr/share/fonts  0.02s user 0.01s system 33% cpu 0.074 total
05:46:17 <ksf> ./InodeTree /usr/share/fonts  0.10s user 0.05s system 36% cpu 0.407 total
05:46:20 <ivanm> lilac: yeah, I have written the convenience functions already
05:46:28 <ivanm> (though I dind't know about modify...)
05:46:33 <ksf> I guess that's fine, considering it's unoptimized.
05:46:37 <tibbe> we should have a wiki page listing all hackathons
05:46:56 <ivanm> tibbe: I thought we did...
05:46:59 <lilac> ksf: it already passes a dysnumeric performance review
05:47:08 <ksf> find /usr/share/fonts  0.01s user 0.00s system 10% cpu 0.133 total
05:47:20 <ivanm> tibbe: http://www.haskell.org/haskellwiki/Category:Hackathon
05:47:23 <ksf> that's hard competition, though.
05:47:25 <lilac> ksf: echo /usr/share/fonts/* ?
05:47:29 <tibbe> ivanm: perhaps I'm just not able to find it
05:47:42 <ivanm> @google haskell hackathon
05:47:44 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007_II
05:47:44 <lambdabot> Title: Hac 2007 II - HaskellWiki
05:47:47 <ivanm> giyf ;-)
05:48:49 <ivanm> tibbe: found it yet? ;-)
05:49:21 <ksf> ...and I'm lacking a directory, for some obscure reasons.
05:50:26 <tibbe> ivanm: yes....
05:51:45 <ksf> heh.
05:51:50 <ksf> the win.
05:51:54 <ivanm> lilac: so how do I "chain" State?
05:52:00 <ksf> ...those missing ones are symlinks.
05:52:12 <ivanm> since you don't actually pass the State monad around...
05:52:15 <infrared> has anyone installed gtk2hs from source? I installed glib and gtk devel lib and it still wants to build them.. and fails on glib
05:52:16 <ksf> ...or, rather, they are symlinked _to_.
05:52:24 <ksf> which is a rather interesting behaviour.
05:52:35 <ivanm> infrared: which distro/ghc/gtk2hs ?
05:53:12 <infrared> ivanm: opensuse/6.10.4/latest
05:53:13 * ivanm doesn't think he can help much, since by mentioning devel libs it's obvious infrared doesn't use Gentoo...
05:53:25 <ivanm> latest == 0.10.1 ?
05:53:30 <infrared> yes
05:53:34 <ivanm> can you paste the error up somewhere?
05:53:41 <infrared> of course
05:55:31 <mmorrow> > flip runState "127.0.0.1" (replicateM 5 (State (break (=='.'))))
05:55:31 <lambdabot>   (["127","","","",""],".0.0.1")
05:55:37 <mmorrow> > flip runState "127.0.0.1" (replicateM 5 (State (span (=='.'))))
05:55:38 <lambdabot>   (["","","","",""],"127.0.0.1")
05:55:46 <infrared> ivanm: i building it again, but here's my some info while it builds: http://pastebin.com/m7bc498d6
05:55:48 <mmorrow> > flip runState "127.0.0.1" (replicateM 5 (State (fmap (drop 1) . break (=='.'))))
05:55:49 <lambdabot>   (["127","0","0","1",""],"")
05:56:13 <mmorrow> > flip runState (mkStdGen 982798748) (replicateM 5 (State next))
05:56:14 <lambdabot>   ([990096138,902506531,1282784196,2132610628,1767373142],272801637 652912057)
05:56:15 <lilac> ivanm: instance (ParsableData a, ParsableData b) => ParseableData (a, b) where parseInfoS (a, b) = do parseInfoS a; parseInfoS b
05:56:37 <mmorrow> > flip runState [0..] (replicateM 5 (State (splitAt 4))
05:56:37 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:56:40 <mmorrow> > flip runState [0..] (replicateM 5 (State (splitAt 4)))
05:56:41 <lambdabot>   ([[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19]],[20,21,22,23...
05:56:45 <ivanm> duh, for list I want mapM_
05:56:51 * ivanm face-palms
05:57:10 * ivanm still finds all this magic state-passing in State, Parser, etc. magic...
05:57:13 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9491#a9491
05:57:26 * ksf opens the optimizing+feature creep competition.
05:57:44 <mmorrow> @type (\s -> (s,s))
05:57:45 <lambdabot> forall t. t -> (t, t)
05:57:50 <mmorrow> @type State (\s -> (s,s))
05:57:51 <lambdabot> forall s. State s s
05:58:16 <mmorrow> > flip runState "state" (State (\s -> (s,s)))
05:58:16 <lambdabot>   ("state","state")
05:58:21 <mmorrow> > flip runState "state" get
05:58:21 <lambdabot>   ("state","state")
05:58:24 <infrared> ivanm: http://pastebin.com/m1f201415
05:59:04 <mmorrow> ivanm: once you get State down, you'll be like "oh. that's simple"
05:59:12 <mmorrow> because it really is
05:59:33 <mmorrow> maybe that's what makes it confusing at first
05:59:37 <ivanm> infrared: what configuration arguments are you building with?
05:59:49 <infrared> ivanm: none
05:59:54 <infrared> just a slash dot configure
06:01:08 <ivanm> who maintains gtk2hs now that dcoutts is busy with cabal + ghc-related hackery?
06:03:11 <ivanm> infrared: I can't really help you, soryy
06:03:14 <ivanm> *sorry
06:03:24 <infrared> thanks for trying :)
06:04:24 <Alpounet> @hoogle s -> (a, s)
06:04:24 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
06:04:24 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
06:04:24 <lambdabot> Data.Graph.Inductive.Query.Monad apply' :: Monad m => GT m g a -> g -> m (a, g)
06:05:17 <mmorrow> @hoogle o -> a -> (a,a)
06:05:18 <lambdabot> Control.Monad.RWS.Lazy execRWS :: RWS r w s a -> r -> s -> (s, w)
06:05:18 <lambdabot> Control.Monad.RWS.Strict execRWS :: RWS r w s a -> r -> s -> (s, w)
06:05:18 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
06:05:53 <mmorrow> @hoogle Int -> [a] -> ([a],[a])
06:05:54 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
06:05:54 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
06:05:54 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
06:06:11 <mmorrow> i wonder how hoogle matches types
06:06:27 <opqdonut> weirdly
06:08:09 <mmorrow> yeah, some of those results make me wonder what it's doing
06:09:15 <Saizan_> i think there's a ndm's blog post with a description
06:09:17 <mmorrow> as in, i'm sure there's a method, but i have no idea what it is
06:09:24 <mmorrow> ah nice
06:09:25 <benmachine> I think when there are no exact type matches available it gives you things that are sort of similar
06:12:45 <mmorrow> in particular, i'm confused about the handling of tyvars
06:14:22 <mmorrow> @hoogle a
06:14:23 <lambdabot> Data.Graph.Inductive.Example a :: Gr Char ()
06:14:23 <lambdabot> Data.Graph.Inductive.Example a' :: IO (SGr Char ())
06:14:23 <lambdabot> Data.Graph.Inductive.Example ab :: Gr Char ()
06:14:35 <mmorrow> :o
06:14:40 <mmorrow> oh
06:14:42 <mmorrow> the names
06:15:33 <ivanm> heh
06:15:48 <dcoutts> ivanm: Axel Simon has always been the maintainer
06:16:04 <ivanm> is he on IRC to help out infrared?
06:21:13 <mmorrow> (just a coincidence that i was just talking about hoogle..) it's annoying how "derive" (the cmd-line tool) doesn't bother noting that some data decls _are commented out_
06:21:25 <ray> hoggal
06:21:55 <ray> can you double-secret comment them out?
06:22:00 <ivanm> anyone know what HSX refers to when they say "imported with explicit package name" ?
06:25:45 <mmorrow> it looks like it's just using regexes/equiv
06:26:15 <Alpounet> 'CFunctor f r s | f r -> s, f s -> r' <= what does the part at the right of | mean ?
06:26:48 <Saizan_> those are functional dependencies
06:26:55 <mmorrow> it means that the type `s' is determined by the type `f r' and `r' is determined by `f s'
06:27:12 <Saizan_> *the types f and r
06:27:36 <mmorrow> i think (f :: * -> *)
06:27:46 <mmorrow> so the type "f r", no?
06:27:57 <Saizan_> even if f :: * -> *, f is not applied to r there
06:28:01 <mmorrow> :o
06:28:08 <Alpounet> by determined, you mean equel ?
06:28:10 <Saizan_> they are just a list of variables, like in forall a b c. ..
06:28:11 <Alpounet> equal*
06:28:19 <Saizan_> Alpounet: no
06:28:26 <mmorrow> instance MonadState (State s) s where ...
06:28:34 <mmorrow> "s" is determined by (State s)
06:29:09 <Alpounet> oh okay, thanks !
06:29:22 <Saizan_> Alpounet: it means that for every pair of 'f' and 'r' there can be only one instance of CFunctor f r s, so you can derive 's' by finding that instance
06:30:13 <Alpounet> Saizan_, yeah, once f and r fixed, s is too, otherwise CFunctor f r s can't be a valid instance
06:30:20 <Alpounet> right ?
06:30:39 <Alpounet> well, can't be an instance at all.
06:30:40 <cagonto> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
06:31:10 <Saizan_> i'm not sure about what are you trying to say there
06:31:28 <Saizan_> however the functional dependencies are a restriction on the possible instances
06:31:58 <infrared> ivanm: http://pastebin.com/m274d5f65  # the command that failed, with a -v, can you take a peek?
06:33:17 <ivanm> infrared: what does -opta do?
06:33:41 <Alpounet> Saizan_, I think I got it, thanks.
06:33:44 <infrared> ivanm: no idea. i pasted the exact command that failed during the build, but i just added a -v
06:33:50 <ivanm> ahhh
06:34:03 <ivanm> infrared: ummmm, there are a few lines with a -v
06:34:09 <ivanm> which one are you talking about? :p
06:34:25 <infrared> the very first one
06:35:01 <ivanm> nope, no idea sorry
06:39:25 <codejedi> any hgalib help
06:40:17 <codejedi> hi lamdabot
06:40:26 <codejedi> hi lambdabot
06:40:28 <saml> hi, i'm your lambdabot
06:40:33 <ivanm> codejedi: lambdabot is a bot...
06:40:34 <codejedi> wow
06:40:40 <saml> how may i help you today?
06:40:45 <ivanm> @bot
06:40:45 <lambdabot> :)
06:40:45 <lunabot>  :o
06:40:48 <codejedi> with hgalib
06:40:52 <codejedi> any example
06:40:58 <ivanm> @google hgalib
06:40:59 <lambdabot> http://hackage.haskell.org/package/hgalib
06:40:59 <lambdabot> Title: HackageDB: hgalib-0.2
06:41:00 <saml> click [yes] to search online about "hgalib"
06:41:09 <codejedi> no example
06:41:11 <ksf> lilac, echo /usr/share/fonts/* isn't recursive.
06:41:50 * ivanm wonders why all the Haskell software is on MAC.softpedia.com ... what makes Haskell mac-only?
06:41:52 <codejedi> zzz
06:42:41 <ivanm> codejedi: I'm guessing it's just a wrapper/re-implementation of GAlib
06:42:52 <ivanm> so if you know how to do it in GAlib, you might be able to convert it to hgalib
06:43:08 <codejedi> thanks, let me try
06:43:30 <ivanm> I could of course be completely wrong...
06:43:59 <ivanm> in fact, it looks like I am
06:44:03 <ivanm> saml: *sigh* [yes]
06:44:06 <codejedi> no problem
06:44:21 <ivanm> codejedi: maybe ask the developer directly?
06:44:55 <saml> I could not find info about hgalib. Would you want to download MSDN library (that includes SQL suite) for free (total 10GB) [yes/no]
06:45:12 <ivanm> @slap saml
06:45:12 * lambdabot pushes saml from his chair
06:53:31 <codejedi> ivam: ya did that
06:54:39 <codejedi> have to go, will come back later
07:02:25 <Alpounet> according to you, what are the pros and cons of typeclasses versus Java's interfaces ?
07:03:29 <saml> are there generic interfaces in java?
07:03:40 <wdonnelly> an interface can't provide default implementations for any functions, AFAIK
07:03:49 <Botje> you can't add interfaces to objects after the fact.
07:03:53 <saml> like,  public interface Show<A> { public String toString(); }
07:04:01 <Botje> unless you use aspects.
07:04:09 <wdonnelly> so you might do better comparing Haskell typeclasses to Java abstract classes
07:04:26 <saml> typeclass can have default implementation?
07:04:43 <wdonnelly> yes, there's often a "minimal complete definition" for a lot of typeclasses
07:05:08 <wdonnelly> IIRC, the 'eq' typeclass only requires you to define (==), and does (/=) in terms of that
07:05:22 <Botje> or you define /= and you get == for free
07:05:32 <Alpounet> the only two ones I thought about are the default implementation and the binding between an interface and a concrete type that matches it that can be done later.
07:05:38 <saml> really?
07:05:58 <saml> i thought class Eq a where (==) :: a ->  a -> Bool;  (/=) :: a -> a -> Bool
07:06:07 <Alpounet> @src Eq
07:06:07 <lambdabot> class  Eq a  where
07:06:07 <lambdabot>     (==), (/=)   :: a -> a -> Bool
07:06:21 <saml> so.. where is default implementation?
07:06:28 <Botje> that's correct, but x == y = not ( x /= y) and x /= y = not (x == y)
07:06:33 <Alpounet> saml, well, it can be done at least
07:06:34 * int-e thinks the question gets a lot more interesting with multi parameter typeclasses.
07:07:05 <Alpounet> int-e, yeah, but I don't know if there are generic interfaces in Java.
07:07:11 <saml> oh sorry you can actually define
07:07:14 <saml> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Classes.html#Eq
07:07:29 <int-e> but some things don't fit well into java interfaces, like  class Foo where foo :: Bool -> (a, a)
07:07:53 <int-e> (I guess you can define a static method.)
07:07:57 <wdonnelly> I don't know what's going on with lambdabot
07:08:10 <wdonnelly> but I just checked the source to the Eq typeclass
07:08:14 <wdonnelly> and it defines default implementations
07:08:37 <wdonnelly> maybe the blank line after the types confused it or something
07:09:03 <int-e> it has been said before - @src is a work of fiction.
07:09:27 <dolio> @src sort
07:09:27 <lambdabot> sort = sortBy compare
07:09:33 <dolio> @src sortBy
07:09:33 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:09:36 <saml> > default ()
07:09:37 <lambdabot>   <no location info>: parse error on input `default'
07:10:22 <eevar2> > import Control.Parallel.Strategies
07:10:23 <lambdabot>   <no location info>: parse error on input `import'
07:10:29 <Alpounet> we talked about pros. Do you see any cons of typeclasses versus Java's interfaces ?
07:11:03 <Alpounet> (it looks like we can write generic interfaces in Java)
07:11:10 * ksf can't find a find option that would make find not return symlinks who's targets are already in the result list
07:11:20 <ksf> whose.
07:11:23 <ksf> omg.
07:14:07 <mmorrow> oh nice, now there's a Data.Functor and
07:14:15 <mmorrow> class Functor f where
07:14:15 <mmorrow>   fmap :: forall a b. (a -> b) -> f a -> f b; (<$) :: forall a b. a -> f b -> f a
07:14:34 <mmorrow> (<$>) :: forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f a -> f b
07:15:42 <mmorrow> now we just need (++)=mappend ..
07:16:11 <mmorrow> (it'd also be handy if [] could mean mempty in general)
07:16:17 <dolio> The libraries list is all abuzz about using (<>)
07:16:22 <mmorrow> ooh
07:16:40 <mmorrow> that's just as good in my opinion
07:16:55 * mmorrow makes a note to read the lists moar
07:17:18 <dolio> I'm not sure [] = mempty is great.
07:18:28 <mmorrow> dolio: any symbol that doesn't need to the parenthesized would be nice
07:18:38 <ksf> more importantly, we need associativity classes for monoids.
07:18:43 <mmorrow> too bad ascii symbols are in short supply
07:19:10 <mmorrow> well, aside from that, it'd need to be builtin-syntax
07:19:11 <saml> > -324-
07:19:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:19:21 <mmorrow> [], (), ????
07:19:28 <saml> > -()
07:19:29 <lambdabot>   No instance for (GHC.Num.Num ())
07:19:29 <lambdabot>    arising from a use of syntactic negatio...
07:19:43 <mmorrow> instance Num () where fromInteger = const 42
07:19:45 <mmorrow> oops
07:19:56 <mmorrow> instance Num () where fromInteger 42 = (); fromInteger _ = undefined
07:20:06 <mmorrow> is my vote
07:20:41 <int-e> why? working modulo 1 makes a great Num instance.
07:20:44 <mmorrow> @let (ℵ) = fix id
07:20:44 <lambdabot>   Illegal character ''\8501''
07:21:05 * mmorrow is browsing character map
07:22:09 <maltem> To all those revision control geeks, I've updated gat: http://github.com/maltem/gat
07:22:21 <ksf> are one-element fields legal?
07:22:21 <mmorrow> hmm, i can't decide which of ↻  ↺ says "fix" better
07:22:34 <ksf> it seems strange to have two monoids but only one identity.
07:22:47 <ksf> the left one.
07:23:02 <ksf> ...as data flows from right to left.
07:23:09 <jonh> maltem: cool, i was wondering if something like this existed ;p
07:23:19 <mmorrow> but with fix, you get the result as an arg
07:23:33 <mmorrow> , levels (fix (\me -> Node () [me,me]))
07:23:36 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
07:23:39 <mmorrow> which is why i can't decide
07:24:08 <eevar2> , import Control.Parallel.Strategies
07:24:09 <lunabot>  luna: parse error on input `import'
07:24:20 <mmorrow> , 'par
07:24:21 <lunabot>  Control.Parallel.par
07:24:25 <mmorrow> , 'rnf
07:24:26 <lunabot>  Control.Parallel.Strategies.rnf
07:24:37 <eevar2> @src parMap
07:24:37 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:25:04 <amoeba> ksf: depends, in algebra you do not want that because not having it simplifies definitions, but there are some applications (unbelievable): http://matrix.cmi.ua.ac.be/fun/
07:25:35 <mmorrow> @let (∈) = elem
07:25:36 <lambdabot>  Defined.
07:27:07 <mmorrow> there're a ton of good unicode brackets
07:29:41 <mmorrow> , "⟦⟧⟨⟩⟪⟫⟬⟭⟮⟯❨❩❪❫❬❭❮❯❰❱❲❳❴❵⦃⦄⦅⦆⦇⦈⦉⦊⦑⦒⦗⦘【】《》〔〕〖〗〘〙〚〛"
07:29:42 <lunabot>  "\10214\10215\10216\10217\10218\10219\10220\10221\10222\10223\10088\10089...
07:29:50 <saml> i see square boxes
07:30:02 <mmorrow> i see purdy brackets
07:30:33 <saml> that means you have a better computer
07:30:39 <mmorrow> yay!
07:31:06 <int-e> I see dead people. ... oh, wrong movie, sorry.
07:39:59 <maltem> Now this is odd - there are time, old-time, and old-locale, but no locale?
07:47:27 <therp> ghc nightmares: I see dead codes 8-|
07:47:40 <therp> -s
07:57:49 <infrared> ivanm: installed successfully on freebsd
07:57:59 <infrared> in case you care, heh
08:01:24 <ksf> > 0xDEADC0DE
08:01:25 <lambdabot>   3735929054
08:02:11 <ksf> i totally forgot leetness while grepping dict for hex words...
08:05:49 <mmorrow> , elemIndex "leetness" dict
08:05:54 <lunabot>  Nothing
08:05:57 <mmorrow> , elemIndex "leet" dict
08:06:00 <lunabot>  Just 219625
08:15:17 <ksf> is there a standard library GADT for boolean expressions?
08:27:46 <mmorrow> ksf: are there any stdlib GADTs other than SomeException?
08:29:24 <Saizan> si SomeException a gadt?
08:29:50 <Saizan> data SomeException = forall e . Exception e => SomeException e
08:34:49 <Alpounet> it can be
08:35:16 <Saizan> everything adt can be a gadt though :)
08:35:22 <Saizan> s/thing//
08:35:22 <Alpounet> yep
08:40:10 <gwern> hah. I just filed 2 bugs for pandoc and gitit
08:40:19 <gwern> bug #s 64 - and 164
08:40:44 <gwern> I know it's a stupid coincidence, but it amuses me
08:42:17 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9503#a9503
08:42:21 * ksf judges it usable
08:42:25 <mmorrow> gwern: now do 100 pushups
08:42:28 <deech`> Hi all, I am trying to understand continuations. Especially in the context of continuation-based web frameworks, where continuations are used to hold state between stateless HTTP transactions. Are there any resources for this in Haskell?
08:42:35 <gwern> mmorrow: take it from me...
08:42:52 <ksf> continuations are simple.
08:43:09 <amoeba> $ const False
08:43:12 <ksf> they're just first-class values representing the rest of the computation.
08:44:48 <gwern>  joke: how you know a #haskeller is lying through his teeth?
08:45:11 <Twey> He uses the word ‘just’
08:45:21 <Twey> :þ
08:45:44 * gwern was going to say 'he uses the word 'simple'', but that works too
08:45:50 <Twey> Hahaha
08:46:17 <jfoutz> deech`: you know how laptops will suspend? they save the state of the world, then turn off. Well, imagine if instead of turning off, the loaded up some other saved state and ran that. like saving windows state, then running linux, then flipping back.
08:46:31 <jfoutz> deech`: continuations are like that, but for functions.
08:46:31 <ksf> ok. let me rephrase: continuations are first-class values representing the rest of the computation, where's the problem?
08:48:12 <jfoutz> deech`: it's like saying, remember everything that's going on right now, i'm going to go do other stuff, but when i come back, i expect it to be the same.
08:48:45 <jfoutz> pretty much.
08:49:34 * jfoutz wonders if that hurts more than helps.
08:50:21 * ksf recommends "advanced programming language design", the book, some section of some chapter.
08:50:55 <ksf> ftp://ftp.aw.com/cseng/authors/finkel/apld/
08:51:23 <gwern> what, no SICP recommendations?
08:51:28 <jfoutz> i never really got it till i worked through dybvig's 3imp paper.
08:51:32 <ksf> not for continuations, no.
08:51:56 <ksf> apld gives a whole language based on nothing but continuations.
08:52:11 <ksf> ...implementing data structures, coroutines and other stuff using them.
08:53:49 <ksf> is call/cc even mentioned in sicp, at all?
08:53:57 <mmorrow> deech`: it took me a while to find this.. re: web continuations, this is a go at making something usable with fastcgi http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1223#a1223
08:54:14 <ksf> wash has them.
08:54:17 <mmorrow> deech`: also, you'll want to read the paper about the pl scheme webserver implem
08:54:22 <jfoutz> there's the amb interpreter, they do some cps stuff, but i don't thingk they formaly define call/cc
08:54:25 <mmorrow> (if you haven't already :)
08:54:43 <mmorrow> deech`: basically, the scheme one does:
08:55:18 <gwern> ksf: I *thought* sicp included continuations
08:55:30 <gwern> it seems like a strange omission for a book heavily focused on languages and interpreters
08:55:30 <ksf> what you're quite definitiely have to do is give your brain time to rewire itself to grok continuations.
08:55:36 <Jafet> http://groups.google.com/group/comp.lang.lisp/msg/4e1f782be5ba2841
08:55:55 <jmcarthur_work> sicp has continuations
08:55:59 <jmcarthur_work> not sure about callcc
08:56:18 <jmcarthur_work> but i am 99.99% sure i remember continuations being in there
08:56:58 <deech`> awesome. thanks! I was a little scared of continuations because the continuation tutorials come with scary warning that using continuations lead to obsfuscated code and that Haskell's lazy semantics are sufficient 90% of the time.
08:57:10 <mmorrow> have a table of "continuations" (continuation := scheme code (iirc represented as text??, but whatever)) indexed by integer keys, then url's have keys embedded in them somewhere, and a request for a url with a particular cont key (and args) makes the server look up that cont (which is a function) and runs it with those args. and finally, the continuation returns a webpage with links to *new* continuations that it has stored in the table
08:57:10 <mmorrow> somehow
08:57:10 <jmcarthur_work> and that's true
08:57:16 <ksf> well I didn't get excited about them before reading apld, and that was after sicp
08:57:49 <Jafet> I think those tutorials are correct
08:57:52 <mmorrow> ("somehow" wasn't meant to be separate, irc did that)
08:57:57 <deech`> gwern: SICP does and so does PLAI : http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/
08:58:07 <gwern> well then
08:58:51 <deech`> I didn't see how Haskell's lazy semantics could help me suspend a function until further input, which is what I need for web interaction.
08:59:06 <mmorrow> deech`: this is the paper i was referring to http://www.cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/
08:59:32 <mmorrow> deech`: you suspend a function like e.g.
08:59:39 <ksf> you're bound to have a even worse problem with stale continuations than with usual stale sessions, but otherwise continuation-based web serving can clean up application code quite a lot.
08:59:50 <gwern> deech`: well, what do you think laziness does? it's all about not evaluating/calling stuff until necessary
08:59:59 <ksf> ...not the continuation code, mind you, the actual app code.
09:00:29 <jmcarthur_work> hmm... i can't find continuations in sicp besides the construction of amb
09:00:31 <gwern> deech`: so if 'necessary' includes 'having received further input'...
09:00:44 <mmorrow> (\arg -> case arg of "this" -> return ("<html>oh hai <a href="42">", [(42,(\arg -> ... )]); "that" -> ...)
09:01:13 <ksf> the coolest thing about cc-based webservers is that you can use the back button without worrying about confusing the server.
09:01:21 <mmorrow> that function would probably be an infinite type, so you need a newtype of two, but that's the basic idea
09:01:29 <mmorrow> s/of two/or two/
09:02:06 <ksf> you can e.g. save the state of a multi-page wizard in continuations, and only commit to global state at the very end.
09:02:13 <deech`> gwern: Yes you are right. I just don't know how to make it work in this case without the Cont monad.
09:02:36 <ksf> (at that time invalidating any continuation connected to the wizard)
09:02:54 <mmorrow> deech`: and since you can't serialize arbitrary haskell closures, you need fastcgi or to be the httpd itself (i.e. CGI won't work)
09:03:18 <ksf> saying "you already commited this transaction" is much nicer to the user than "I don't know what you're trying to do. lemme direct you to the start page"
09:04:26 <mmorrow> deech`: all you do is have:     newtype ContTab = ContTab (Map Key WebCont); newtype WebCont = WebCont (Request -> IO (Response, [(Key, WebCont)]))
09:04:27 <deech`> mmorrow: I have a hand-rolled Haskell server *and* an HTTP server. A small CGI script just the go-between.
09:04:28 <mmorrow> or similar
09:05:09 <deech`> mmorrow: so Key somehow uniquely identifies a certain client?
09:05:46 <mmorrow> deech`: it uniquely identifies a certain handler, and that handler is accessed by requesting the link that contains that embedded key
09:06:00 <mmorrow> handler == continuation == page
09:06:31 <deech`> mmorrow: Ah! I understand.
09:06:35 <mmorrow> :)
09:06:39 <ksf> ...and you need something to break cycles.
09:07:09 <ksf> that is, switching your site between "documentation" and "downloads" shouldn't build up continuations.
09:07:57 <mmorrow> deech`: so the practical concerns are, (1) you need a central function that hands out unique keys (==Int, or whatever), and (2) a function that takes ((Key,WebCont)->IO()) which inserts that pair into the map
09:08:46 <mmorrow> and also, you have the choice of removing WebConts from the map {never, after one invocation, and n invocations, and t seconds, etc}
09:09:04 <deech`> mmorrow: Cool, I am still digesting your hpaste code.
09:09:59 * ksf thinks a continuation should include the keys of its parents, so that you can purge.
09:10:05 <dino-> We've been doing session stuff lately too, with Network.CGI  For now I'm hacking up a code for the cookie with md5digest of (IP of the client + time on the server)
09:10:19 <ksf> kind of like COME FROM
09:10:26 <jmcarthur_work> ugh
09:10:30 <jkff> preflex: seen Cheshire
09:10:30 <preflex>  Sorry, I haven't seen Cheshire
09:11:01 <mmorrow> dino-: (if you haven't already) check out fastcgi. it's basically a drop-in replacement s/runCGI/runFastCGI/
09:11:12 <mmorrow> and you get persistent state
09:11:22 <dino-> mmorrow: Absolutely, we need fastcgi anyway soon.
09:11:37 <Jafet> ksf, just set breakpoints and ship your code with a debugger
09:12:09 <c_wraith> Can GHC serialize continuations meaningfully?
09:12:24 <jmcarthur_work> nurp
09:12:39 <mmorrow> c_wraith: it doesn't need to serialize anything if your program persists across requests (e.g. fastcgi or httpd)
09:12:45 <jmcarthur_work> not unless you have a DSL for those continuations that you write the serialization for yourself
09:12:50 <ksf> nah I'm not thinking about debugging, but building up a transaction completely inside continuations and only committing it if the user says so.
09:13:04 <Jafet> Breakpoints = come from
09:13:13 <c_wraith> mmorrow:  I'm thinking more of distributed computation scenarios
09:13:28 <dino-> We've been building this up from the very basics in an attempt to learn what's up with all this web jazz.
09:13:40 <jmcarthur_work> haskell isn't well-designed for distributed computation, imo
09:13:46 <mmorrow> c_wraith: you can't currently serialize arbitrary closures with GHC, so you'd need to come up with a way to represent it as data
09:13:47 <ksf> actually, I mean DON'T COME FROM.
09:13:53 <Jafet> mmorrow, then your node crashes, hooray
09:13:54 <jmcarthur_work> we have pure code that behaves differently on different machines and stuff
09:14:11 <mmorrow> Jafet: yay
09:14:16 <Jafet> ksf, oh, now that sounds *innovative*
09:14:27 <ksf> at which time all code paths to that line become invalid. before the line is passed, they are valid.
09:16:22 <jmcarthur_work> sounds like garbage collection
09:16:40 <jmcarthur_work> i guess is it
09:16:43 <jmcarthur_work> *it is
09:30:17 <GreatPatham> I have what is a very simple beginner question.  I am trying to read in and print the contents of a file using Data.ByteString.Lazy.Char8, and I am getting linkage errors.  Here is the (trivial) program:
09:30:21 <GreatPatham> module Main () where
09:30:21 <GreatPatham> import qualified Data.ByteString.Lazy.Char8 as L8
09:30:22 <GreatPatham> main = do
09:30:22 <GreatPatham>    contents <- L8.readFile "/Users/bar/foo.dat"
09:30:22 <GreatPatham>    L8.putStrLn contents
09:30:36 <mauke> what's the error?
09:30:45 <GreatPatham> Coming up...
09:31:08 <GreatPatham> $ghc -o simple Main.hs
09:31:09 <GreatPatham> Undefined symbols:
09:31:09 <GreatPatham>   "_bytestringzm0zi9zi1zi4_DataziByteStringziLazzyziChar8_readFile_closure", referenced from:
09:31:09 <GreatPatham>       _sB1_info in Main.o
09:31:10 <GreatPatham>       _sB1_srt in Main.o
09:31:10 <GreatPatham>   "_bytestringzm0zi9zi1zi4_DataziByteStringziLazzy_putStrLn_closure", referenced from:
09:31:11 <GreatPatham>       _sB5_info in Main.o
09:31:13 <GreatPatham>       _sB5_srt in Main.o
09:31:15 <GreatPatham>       _ro0_srt in Main.o
09:31:15 <lilac> GreatPatham: add --make to your ghc command line
09:31:17 <GreatPatham>   "___stginit_bytestringzm0zi9zi1zi4_DataziByteStringziLazzyziChar8_", referenced from:
09:31:19 <GreatPatham>       ___stginit_Main_ in Main.o
09:31:21 <GreatPatham> ld: symbol(s) not found
09:31:23 <GreatPatham> collect2: ld returned 1 exit status
09:31:23 --- mode: ChanServ set +o mauke
09:31:23 --- kick: GreatPatham was kicked by mauke (mauke)
09:32:24 --- mode: mauke set -o mauke
09:32:39 --- mode: ChanServ set +o mauke
09:32:54 <lilac> GreatPatham: add --make to your ghc command line
09:33:11 <lilac> GreatPatham: and don't paste more than one or two lines here :)
09:33:15 <jmcarthur_work> i feel bad for people who don't really know/realize that flooding the channel isn't taken kindly, which i assume is the case a lot of the time
09:33:39 --- mode: mauke set -o mauke
09:34:01 <jfoutz> it also makes it so hard to refer back.
09:34:47 <Saizan> once they've pasted the only way to stop them is to kick/ban, so it's not even a matter of kindness
09:35:00 <Makoryu> GreatPatham: http://gist.github.com <- Next time you need to paste something.
09:35:04 <jmcarthur_work> yeah
09:35:14 <jfoutz> i always feel like a jerk saying don't paste. but it's so much easier to deal with a hpaste or whatever.
09:36:31 <orbitz> jfoutz: but i always feel releived wehnt eh person turns out to be a jerk about it
09:37:27 <infrared> does whitespace matter *all* the time in haskell?
09:37:33 <Makoryu> infrared: No.
09:37:45 <orbitz> only when it matters.
09:38:07 <Saizan> you can disable layout by using { ; }
09:38:14 <Makoryu> infrared: There are four keywords that activate indentation sensitivity, or "layout." These are "let," "of," "do," and "where."
09:38:29 <jfoutz> orbitz: well yeah, i guess that helps :)
09:38:34 <mauke> "let", "of", "do" and "where".
09:38:43 <jpcooper> where does "of" occur?
09:38:48 <mauke> jpcooper: case x of
09:38:49 <Makoryu> jpcooper: After "case"
09:38:51 <GreatPatham> Hey apologies for the multiline paste.  mauke clued me in on how to make a proper paste.
09:38:51 <jpcooper> duuh
09:39:29 <infrared> so it's 8 spaces after those keywords?
09:39:41 <Makoryu> infrared: No.
09:39:50 <pheaver> infrared: it's not so much how much spacing you do, but that each line has the same spacing
09:39:58 <infrared> hm
09:39:58 <infrared> ok
09:40:13 <mauke> infrared: if the token after let/of/do/where is not a "{", layout mode is activated
09:40:14 <orbitz> haskell is cool like that
09:40:18 <infrared> i've been reading yaht.pdf btw
09:40:37 <Makoryu> infrared: I actually wish I had a diagram for this. It's not the amount of space that matters... The compiler looks for the next non-whitespace character and marks that indentation level as the left side of a layout block
09:40:44 <mauke> infrared: the column of the token determines the base indentation level of the following block
09:41:27 <infrared> Makoryu: so the first indentaion sets the 'standard' ?
09:41:37 <Makoryu> infrared: Yep.
09:41:41 <mauke> it's not necessarily an indentation
09:41:50 <infrared> well, whitespace
09:41:57 <Makoryu> infrared: And that can be two spaces, or twelve, or whatever. It can be on the next line.
09:42:03 <mauke> the token after let/of/do/where can appear on the same line
09:42:25 <infrared> ok
09:43:04 <Jafet> Masochists edit haskell in a proportional font
09:43:28 <GreatPatham> lilac.  Your suggestion did fix my problem.  Thanks!
09:43:29 <mauke> > let x = 1; y = 2 in x + y  -- completely invisible { } block, but no indentation
09:43:30 <lambdabot>   3
09:43:43 <Makoryu> infrared: It *is* important to note that you should always be using spaces, not tabs.
09:44:01 <Makoryu> Also, some examples: http://gist.github.com/189163
09:45:00 <mauke> you can use tabs, but then you should always start a new line after let/of/do/where, for basic sanity
09:45:09 <mauke> it's certainly less flexible
09:45:12 <infrared> mauke: i probably would
09:46:17 <funcA> sup haskellians
09:46:43 <Makoryu> Yo
09:47:51 <funcA> let xs = tail [0,1,2,3]; ys = init ['a','b','c','d'] in zip xs ys  is okay
09:48:10 <funcA> but zip xs ys where {xs = tail [0,1,2,3]; ys = init ['a','b','c','d']} isn't
09:48:13 <Jafet> Is that the standard ethnonym for haskell users?
09:48:33 <cygnus> I don't think so. I've heard "Haskellers"
09:48:35 <funcA> Jafet: I dunno, but I call you that way
09:48:42 <mauke> depends on the context
09:48:47 <Makoryu> funcA: That's because where-blocks are only allowed after declarations, whereas let/in blocks are allowed in expressions.
09:49:01 <mauke> > let z = zip xs ys where {xs = tail [0,1,2,3]; ys = init ['a','b','c','d']} in z
09:49:01 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
09:49:15 <Makoryu> funcA: For example, you can have a where block inside a let block
09:49:18 <mapreduce> What's lambdabot's sequence-analysing command?
09:49:33 <benmachine> sequence-analysing?
09:49:50 <funcA> Makoryu: I see, so I have to "attribute it" to a function?
09:49:54 <mapreduce> Something like @whatis 1 2 3 4.. the ordinals starting at 1.
09:49:54 <mauke> @oeis 1 2 4 8 16
09:49:55 <lambdabot>  Powers of 2: a(n) = 2^n.
09:49:55 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
09:49:57 <funcA> in z or z = blabla?
09:49:58 <mapreduce> Thanks.
09:50:12 <Makoryu> funcA: Yep.
09:50:16 <lilac> the Online Encyclopaedia of Integer Sequences
09:51:49 <funcA> Makoryu: this is pretty neat
09:52:27 * Makoryu puts on sunglasses
09:53:22 <tommd> GreatPatham: Use --make
09:53:34 <tommd> oops, scrolled up
09:54:47 <funcA> anyone knows how to ask mr lambdabot to return the type of an expression?
09:54:53 <Makoryu> :t map
09:54:54 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:54:55 <mauke> :t "funcA"
09:54:56 <lambdabot> [Char]
09:55:05 <funcA> thanks guys!
09:55:07 <mauke> if you want to do it in private, you need @type
09:55:24 <benmachine> mauke: what's the difference?
09:55:48 <mauke> lambdabot doesn't seem to recognize :t in privmsg
09:55:52 <funcA> thanks mauke
09:55:57 <funcA> :t splitAt (length ['a','b','c','d']) [1..5]
09:55:57 <lambdabot> forall t. (Num t, Enum t) => ([t], [t])
09:56:13 <funcA> weird
09:56:22 <funcA> :t splitAt (length ['a','b','c','d']) [1,2,3,4,5]
09:56:22 <lambdabot> forall t. (Num t) => ([t], [t])
09:59:47 <funcA> :t splitAt (length ['a','b','c','d']) [1..5]
09:59:48 <lambdabot> forall t. (Num t, Enum t) => ([t], [t])
10:00:04 <mauke> man, gist's interface is ugly
10:01:03 <funcA> :t splitAt
10:01:04 <lambdabot> forall a. Int -> [a] -> ([a], [a])
10:01:11 <funcA> I'm really not getting it
10:01:44 <lilac> yo' pastebin so ugly, your internet connection goes down rather than handle its traffic
10:02:11 <mauke> funcA: getting what?
10:02:14 <Makoryu> mauke: Uglier than pastebin.com?
10:02:30 <mauke> Makoryu: dunno, I haven't tried to interface with pastebin.com yet
10:02:39 <Makoryu> mauke: Oh, you mean the API?
10:02:47 <mauke> well, the <form>
10:02:52 <mauke> I don't know if you can call it an API
10:02:59 <lilac> funcA: length ['a','b','c','d'] == 4, so that's
10:03:03 <lilac> :t splitAt 4 [1..5]
10:03:04 <lambdabot> forall t. (Num t, Enum t) => ([t], [t])
10:03:28 <funcA> but where are the other arguments?
10:03:40 <funcA> shouldn't it be like splitAt?
10:04:15 <lilac> funcA: splitAt :: Int -> [a] -> ([a], [a]), so splitAt 4 :: [a] -> ([a], [a]), and splitAt 4 [1..5::Int] :: ([Int], [Int])
10:05:27 <funcA> (Num t, Enum t) is not a tuple, right?
10:05:37 <lilac> funcA: no.
10:05:40 <lilac> :t [1..5]
10:05:41 <lambdabot> forall t. (Num t, Enum t) => [t]
10:05:43 <mauke> it's a class context
10:05:58 <funcA> AH
10:06:02 <lilac> funcA: it means, [1..5] has the type "list of t, for some t which is a number and can be enumerated"
10:06:35 <lilac> so it could be a list of Int or a list of Integer or a list of Double or a list of Word or a list of...
10:07:04 <lilac> it could even be a list of some user-defined type which is an instance of typeclasses Num and Enum
10:08:51 <funcA> man, Haskell is really confusing and neat at the same time
10:09:47 <lilac> funcA: yeah, it's probably best to take it a bit at a time. ignore typeclasses for now and pretend that 1 :: Int :)
10:13:57 <infrared> to install a module, do i have to manually install the dependencies from hackage as well?
10:14:15 <infrared> and use "runhaskell .. " ?
10:14:17 <dancor> > ['a'..'e']
10:14:18 <lambdabot>   "abcde"
10:14:21 <mauke> infrared: no, you're supposed to use the cabal program
10:14:53 <infrared> heh.. i have like 15 tabs in my browser with haskell tutorials.. i'll search for that.. thanks :)
10:15:35 <mauke> if you don't have it yet, it's in a hackage package called cabal-install
10:16:10 <funcA> type 3dpoint = (Double,Double,Double) ?
10:16:46 <lilac> funcA: you can't start the name of a type with a digit :)
10:16:54 <lilac> it must be a capital letter
10:17:10 <benmachine> ThreeDeePoint
10:17:11 <funcA> >_<
10:17:39 <lilac> Point3D is ok
10:18:04 <funcA> lilac, can I use Num in that definition?
10:19:16 <lilac> funcA: you could generalize it to a triple of the same type, for any type that's an instance of Num
10:19:47 <Jafet> Of course then, you have to remember what those three numbers mean.
10:20:05 <Jafet> Cartesian? Spherical? Cylindrical?
10:20:15 <funcA> Cartesian :P
10:20:31 <Jafet> Sounds terribly unuseful
10:21:14 <funcA> teacher asked us how to represent a 3dpoint
10:21:31 <funcA> I was going to write type Point3D = (Double,Double,Double)
10:21:40 <lilac> with a GHC extension you can write: type Point3D a = Num a => (a, a, a)
10:22:06 <funcA> I use ghc in home computer, but Hugs in school :(
10:22:30 <c_wraith> funcA:  I still think this should be a concrete type.
10:22:42 <c_wraith> funcA:  Also, your school really needs to get over hugs.
10:22:54 <funcA> Double,Double,Double, c_wraith?
10:23:18 <lilac> funcA: i probably would use a newtype or a data for this rather than a type synonym
10:23:35 <c_wraith> Yeah.  That's the same thing I recommended last time you asked about this. :)
10:28:28 <funcA> c_wraith, lilac : my teachers didn't knew that isLower, etc were not part of Prelude anymore.
10:29:02 <roelvandijk> Does anyone know how you can write a parallel version of sequence?
10:29:12 <roelvandijk> I'm looking for a parallel version of mapM
10:30:10 <c_wraith> :t forkIO
10:30:11 <lambdabot> Not in scope: `forkIO'
10:30:22 <c_wraith> , :t forkIO
10:30:24 <lunabot>  luna: Not in scope: `forkIO'
10:30:52 <benmachine> @type Control.Concurrent.forkIO
10:30:53 <lambdabot> IO () -> IO GHC.Conc.ThreadId
10:31:02 <roelvandijk> I would prefer to use combinators from Control.Parallel.Strategies
10:32:09 <jfoutz> liftM2 parMap ?
10:32:18 <c_wraith> I was mostly just wondering if forkIO gave you any way to get access to its result.  But since the input type is IO (), I guess that's pretty meaningless
10:32:48 <jfoutz> maybe that dosn't work the way i think it does.
10:32:56 <c_wraith> (the return value of the action will be IO ()!)
10:33:06 <roelvandijk> :t liftM2 parMap
10:33:07 <lambdabot> forall b a (m :: * -> *). (Monad m) => m (Strategy b) -> m (a -> b) -> m ([a] -> [b])
10:33:40 <jfoutz> c_wraith: you'll need to use mvar (or something like it) to give the threads a way to communicate
10:33:50 <roelvandijk> I have a large list of [a] and some function a -> IO b which I want to evaluate in parallel
10:34:19 <jmcarthur_work> should the actions be executed in parallel, or just computations which return actions?
10:34:30 <roelvandijk> Not necessarely parallel
10:34:44 <roelvandijk> I just need a value of IO [b] when it is done
10:35:05 <jmcarthur_work> :t rnf
10:35:06 <lambdabot> forall a. (NFData a) => a -> Done
10:35:12 <roelvandijk> So basicely, I want a mapM that exploits multiple cores
10:35:31 <jfoutz> c_wraith: i think the page with forkIO actually has a sample at the bottom, showing how to wait for threads to complete.
10:35:44 <jmcarthur_work> :t \f -> sequence . parMap f
10:35:45 <lambdabot>     Couldn't match expected type `[m a]'
10:35:45 <lambdabot>            against inferred type `[a1] -> [b]'
10:35:45 <lambdabot>     In the second argument of `(.)', namely `parMap f'
10:35:54 <jmcarthur_work> or something
10:36:04 <jmcarthur_work> :t parMap
10:36:04 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
10:36:08 <jmcarthur_work> ah strategy
10:36:19 <roelvandijk> Yes, I tried that. But then you need some (Strategy (IO b))
10:36:32 <c_wraith> jfoutz:  I've done that before.  I was just curious about what specifically forkIO could return
10:37:04 <jmcarthur_work> roelvandijk, are the actions *safe* to run concurrently?
10:37:15 <jmcarthur_work> roelvandijk, you could just mapM forkIO over it
10:37:21 <roelvandijk> Yes, each action parses a file
10:37:35 <roelvandijk> Ok, that is indeed a viable approach
10:37:47 <jmcarthur_work> ah, but you would also have to get the results back
10:37:51 <roelvandijk> But I would need some mechanism to wait for completion
10:38:17 <jfoutz> c_wraith: ah. yeah. it's less fun than you'd hope.
10:38:28 <jmcarthur_work> so you might have to set up a chan or mvars for each action to read back the results from each thread
10:39:10 <jfoutz> hmm.
10:39:14 <jmcarthur_work> something like that
10:39:27 <roelvandijk> I'll investigate a bit more
10:39:52 <jmcarthur_work> i'm going to be messing with the chp library later i think. it looks like a pretty nice concurrency library
10:40:18 <roelvandijk> My use case btw, use parsing every PackageDescription in hackage
10:41:22 <jfoutz> something like, fmap (\x -> do{ m<-newMvar; putMVar m x; r <- readMvar m; return m})
10:41:38 <jfoutz> that's neat.
10:42:12 <brad_larsen> dons mentions using ``one of the hashtable libraries on Hackage'' here:  <http://stackoverflow.com/questions/822752/should-i-learn-haskell-or-f-if-i-already-know-ocaml>
10:42:22 <brad_larsen> maybe I'm blind, but I don't see any hash tables listed on hackage
10:43:16 <brad_larsen> which leads me to hash table / GC / array questions in general
10:43:35 <brad_larsen> is there a hash table in Haskell besides Data.HashTable, that isn't stuck in the IO monad?
10:43:38 <infrared> what's the difference between HDBC-mysql and hsql-mysql?
10:43:44 <brad_larsen> e.g., perhaps one in the ST monad?
10:43:54 <mauke> brad_larsen: why does it have to be a hash table?
10:44:41 <Vulpyne> infrared: HDBC is better - it lets you use prepared statements and such.
10:44:42 <brad_larsen> mauke: I'm using Data.Map now, but have a suspicion that a hashtable would be more time & memory efficient
10:44:55 <mauke> I find that unlikely
10:44:57 <brad_larsen> heuristic search algorithms
10:45:07 <Vulpyne> infrared: However HDBC's MySQL module is experimental.
10:45:15 <infrared> oh
10:45:16 <brad_larsen> mauke: why's that?
10:45:19 <jmcarthur_work> brad_larsen, what are the keys?
10:45:36 <infrared> Vulpyne: i'm coming from perl, so this is all new to me. which do you recommend for a newbie?
10:45:59 <brad_larsen> jmcarthur_work: depends on the search domain.
10:46:32 <brad_larsen> jmcarthur_work: could be simple integers, strings, arrays, or something more complex
10:46:33 <mauke> brad_larsen: just a suspicion
10:46:50 <brad_larsen> mauke:  indeed, that's why I want to experiment :-)
10:46:55 <jmcarthur_work> brad_larsen, ah generic code is tougher to optimize
10:47:27 <brad_larsen> the search algorithms I'm playing around with generally make really heavy use of a priority queue
10:47:28 <jmcarthur_work> brad_larsen, for Int, obviously IntMap is the way to go. for Strings, tries might be good
10:47:43 <brad_larsen> i'm using Data.Map, wrapped in a newtype, to implement a minheap
10:48:00 <Vulpyne> infrared: As far as difficulty using them, they are about equal. I've used the HDBC MySQL one with no problems.
10:48:14 <Vulpyne> infrared: I was just warning you that it might not be suitable for enterprise level deployment. :)
10:48:49 <infrared> Vulpyne: haha.. far from it :)
10:48:52 <brad_larsen> (using Data.Map as a minheap appears to be faster than, e.g., PSQueue, or other priority queues on hackage that I have tried)
10:50:06 <infrared> whoa.. cabal is really cool
10:50:16 <infrared> i like this
10:50:36 <jmcarthur_work> brad_larsen, have you looked at finger trees, or are any of the libraries your tried based on finger trees?
10:50:49 <brad_larsen> jmcarthur_work: PSQueue is a finger tree
10:50:53 <jmcarthur_work> ah
10:50:57 <jmcarthur_work> just checking
10:51:34 <brad_larsen> What's the story with ghc and arrays and GC these days?
10:51:54 <brad_larsen> I have heard somethign along the lines of boxed arrays not playing well with the GC in ghc
10:52:18 <Saizan> boxed mutable arrays have that problem, yeah
10:52:30 <brad_larsen> so changing one element requires scanning all elements upon GC, something like that
10:53:04 <Saizan> right
10:53:19 <brad_larsen> so, um, what can one do instead?
10:53:25 * jmcarthur_work wonders what a hash "table" based on IntMap would perform like
10:53:31 <brad_larsen> is there an unboxed array type that doesn't require Storable?
10:54:03 <jmcarthur_work> assuming the hashing and all its comparisons is actually cheaper than comparing the originals, of course
10:54:29 <jmcarthur_work> brad_larsen, what kind of performance are you getting? how bad?
10:54:30 <Saizan> brad_larsen: you could use nested arrays
10:55:30 <Berengal> Haskell makes a great html templating language
10:56:46 <camio> Berengal: Could you elaborate on that?
10:57:01 <brad_larsen> jmcarthur_work:  using a minheap backed by a data.map, the performance isn't so bad.  Maybe within a factor of 3 compared to C++ using std::map (implemented as a red-black tree)
10:57:28 <infrared> so after i insatll a module, i can test with :load Database.HDBC.Mysql, right ?
10:57:37 <Berengal> camio, I can do more than elaborate... just give me a sec
10:57:50 <brad_larsen> jmcarthur_work: mostly just curious.  I guess it would be easier to do the comparison in C++ land first, see if there is a big difference there
10:58:00 <brad_larsen> jmcarthur_work: wait a sec, I think I'm confused
10:58:58 <Berengal> camio, http://85.200.142.98:5000/ and http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9509#a9509
11:00:38 <laxis> hey!.
11:00:57 <dons> brad_larsen: did you get your hashtable questions answered?
11:01:21 <dons> brad_larsen: for unboxed arrays look at uvector
11:01:29 <camio> Berengal: Thanks. I'm wondering what does monadic syntax gives you over normal function sytax.
11:01:31 <dons> that's what i'm using as the basis of a new open addressed hashtable scheme
11:01:31 <brad_larsen> dons:  I'm still pondering.  But, is there a hashtable on hackage, like you said on that stackoverflow comment?
11:01:39 <dons> brad_larsen: for IO-based hashtables, look at hsjudy
11:01:46 <Berengal> camio, I'm not using monadic syntax at all
11:01:55 <dons> for non-IO oens, you'll need a pure struture, which rules out hashtables.
11:02:13 <dons> so tries are more appropriate
11:02:19 <dons> and you'll gain thread safety for free :)
11:02:41 <Berengal> camio, these are all pure functions with nothing going on behind the scenes, except the HTML typeclass
11:02:51 <camio> brb
11:03:15 <brad_larsen> dons:  hmm, should experiment wiht tries.  In a certain test app I was playing around with the past couple days, I build up a table, then use it only for reading afterward
11:03:27 <dons> brad_larsen: oh, awsesome.
11:03:37 <dons> well, you could use the perfecthash lib too
11:03:45 <dons> that's a load-and-freeze hashtable structure
11:03:48 <dons> so its pure once you load it
11:04:07 <dons> if you're primary concern is lookup, not insert/replace
11:04:13 <dons> make sense?
11:04:17 <brad_larsen> dons:  yeah, for this app, that's the use case
11:04:29 <dons> http://hackage.haskell.org/package/PerfectHash
11:04:32 <brad_larsen> impure construction, but after that, only lookup is done
11:04:56 <dons> bloomfilters also might work
11:05:19 <brad_larsen> dons:  that hashes bytestrings only.  So, to use other key types, I'd have to use, e.g., Data.Binary to convert to a ByteString?
11:05:20 <dons> http://hackage.haskell.org/packages/archive/bloomfilter/1.2.6/doc/html/Data-BloomFilter-Easy.html
11:05:31 <dons> for PerfectHash, yes, I think so.
11:05:59 <dons> try the perfecthash or bloomfilter lib, I'd say, or work out why Data.IntMap or Data.Map aren't appropriate
11:06:24 <brad_larsen> dons:  will look into those
11:06:32 <dons> its great having so many libraries
11:07:31 <brad_larsen> the test program I've been playing with the past couple days is very similar to http://hackage.haskell.org/package/markov-chain
11:08:11 <brad_larsen> I just wanted to generate a random stream of chars, based on some training text
11:08:19 <dons> cool
11:08:24 <mauke> oh, you mean like excity nomicalize vious antigarhaverslerysphent ablenetrighwood clary?
11:08:31 <brad_larsen> (this started as just a simpe curiousity, but then i ran into troubles, and spend a day on it ;-) )
11:08:43 <dons> troubles?
11:08:46 <brad_larsen> performance
11:09:04 <dons> seems like something that should be very fast
11:09:18 <brad_larsen> I build a table:  Map ByteString (Map Char Int)
11:09:22 <dons> cool
11:09:23 <tibbe> dons: would you know why a strict Put monad runs out of stack?
11:09:40 <brad_larsen> mapping history, e.g., the previous 5 characters, mapped to a histogram
11:09:40 <dons> tibbe: it was to do with the interaction with the encode implementation for lists
11:09:50 <tibbe> dons: Ah
11:10:23 <brad_larsen> dons:  so, given the past 5 chars generated, i can probabilistically select a next char
11:10:31 <tibbe> dons: I'm sure it's worth getting the list implementation to be efficient on very large lists. Better to have a library that can decode several 'Binary a's concatenated in the same file
11:11:14 <dons> yep
11:11:25 * dons is busy at work. design discussions later yall
11:11:36 <brad_larsen> dons:  certainly
11:11:44 <brad_larsen> dons:  thanks
11:12:10 <dons> let me know how bloomfilter and perfecthash work out
11:12:43 <tibbe> dons: sure, enjoy friday :)
11:14:39 <brad_larsen> Saizan: use nested arrays?
11:15:41 <Saizan> brad_larsen: if you use an array of smaller arrays when you modify one of the smaller ones the GC doesnt' have to scan the others
11:16:38 <infrared> I get: "could not find module Database.HDBC.MySQL after i installed with: cabal install HDBC-mysql. am i missing something eles?
11:17:47 <brad_larsen> Saizan: that's kind of a hack, no?  ;-)
11:18:09 <Saizan> brad_larsen: it's a workaround :)
11:18:48 <Saizan> infrared: you need to restart ghci, perhaps?
11:19:01 <infrared> Saizan: i'm trying to compile it
11:19:42 <Saizan> infrared: does "ghc-pkg list" show HDBC-mysql?
11:19:56 <dcoutts> infrared: did HDBC-mysql actually install ok? does cabal info HDBC-mysql say that it is installed?
11:20:21 <infrared>     Latest version installed: 0.6
11:20:31 <infrared> Saizan: "no" to your question
11:21:10 <Saizan> so cabal info and ghc-pkg list disagree?
11:21:25 <infrared> oh wait
11:21:35 <infrared> it's in ~/.cabal/lib
11:21:37 <infrared> not system wide
11:22:00 <Saizan> if you're compiling with ghc --make it should see it
11:22:07 <infrared> Saizan: i am
11:22:51 * Saizan is puzzled
11:22:58 <Saizan> do you have more than one ghc installed?
11:23:04 <infrared> damn.. Saizan  ghc-pkg list DOES show it  (i ran it as a diiferent user the first time)
11:23:24 <infrared> non root user that is
11:23:38 <infrared> so i guess i have to compile it as root
11:23:52 <Saizan> well, you shouldn't do root user installs
11:24:20 <infrared> oh i see
11:24:26 <Saizan> are you running cabal install with sudo? you should cabal install --root-cmd=sudo --global if you want them installed system wide
11:24:37 <infrared> i  installed the modules as root
11:24:42 <infrared> but i'm coding as a normal user
11:24:44 <mauke> ...
11:25:07 <infrared> i guess i'm still in perl mode where root can insatll a module globally
11:25:10 <dcoutts> infrared: if you're not using multiple normal user accounts then there should be no need to do anything special, like installing as root
11:25:33 <mauke> root can install modules globally, but you need the --global flag
11:25:38 <dcoutts> infrared: you can install globally if you really want to, using --global, as Saizan said
11:25:42 <infrared> gotcha
11:25:52 <dcoutts> but there's usually little point
11:25:53 <Saizan> maybe --global should be the default if you're root
11:25:56 <mauke> s/root/any user really/
11:26:07 <dcoutts> Saizan: detecting if you're root is not so easy
11:26:16 <infrared> i'm going to stick with nonroot
11:26:20 <mauke> geteuid() == 0
11:26:34 <dcoutts> mauke: how does that behave with su vs sudo ?
11:26:46 <mauke> what do you mean?
11:27:08 <dcoutts> su to root has different behaviour than sudo of a command
11:27:28 <mauke> for example?
11:27:35 <infrared> i don't see the point of 'sudo' when there's only one admin on a machine :)
11:27:55 <dcoutts> mauke: if I sudo, it doesn't change my $HOME for example, but when I su it does.
11:28:35 <mauke> isn't that irrelevant?
11:28:39 <dino-> Hou can sudo -H
11:28:48 <dino-> s/Hou/You/
11:28:52 <dino-> to use root's env
11:29:06 <mauke> either you're root or you're not
11:29:23 <dcoutts> mauke: I thought there was a difference between uid and euid
11:29:30 <mauke> there is
11:29:34 <dino-> I use sudo -H for cabal-install so that the artifacts get stores in root's home and not mine.
11:29:36 <mauke> you want to check the euid
11:29:50 <dino-> Otherwise you end up with these annoying owned-by-root files in your home that are bitchy to back up.
11:30:34 <dcoutts> mauke: so I guess that's the other problem with getting it implemented, I don't understand it :-)
11:30:45 <dcoutts> someone else has to write the code, or spend time educating me
11:30:49 <mauke> euid is what you can do to others, uid is what others can do to you
11:30:56 <dcoutts> oh
11:31:08 <dcoutts> I've never heard it explained that way
11:31:14 <dcoutts> mind you I've never had it explained :-)
11:31:18 <mauke> if your euid is 0, you can write to root-owned directories, for example
11:31:34 <mauke> but if your uid is some user, that user can still send you signals, etc
11:32:17 <camio> Berengal: I was referring to the (<<) function.
11:32:50 <Berengal> camio, that's a combinator in the xhtml library
11:33:04 <Berengal> (<<) :: (HTML a) => (Html -> b) -> a -> b
11:33:29 <camio> Berengal: Oh, I thought it was a monadic bind operator.
11:34:00 <Berengal> Those usually go the other way, except =<< and <=<
11:34:04 <Berengal> I don't think << is defined
11:34:18 <camio> Berengal, I've generated html as well though I made h1 a Html->Html function.
11:34:36 <Berengal> h1 is a Html -> Html function
11:34:58 <camio> grr, I'm having trouble expressing myself today.
11:35:13 <Berengal> h1 << "foo" is the same as h1 (toHtml "foo")
11:35:41 <camio> Html was String.
11:35:58 <camio> An catamorphism
11:36:04 <mauke> but who was phone⁈
11:36:27 <Berengal> You mean h1 :: String -> String?
11:36:58 <camio> Yeah, with a "type Html = String".
11:37:09 <Berengal> Ah
11:38:11 <Berengal> I'm just using the xhtml library. It's just tags and a few combinators
11:38:19 <camio> Your program I'm assuming uses the typing to your advantage, ie. no p's within h1's.
11:38:56 <Berengal> Well, you can do h1 << p << "this is inside a <h1><p>...</p></h1>"
11:39:41 <Saizan> dino-: why do you do --user installs as root?
11:39:44 <camio> Berengal: Can yours generate invalid html?
11:39:58 <dino-> Saizan: I don't do --user installs ever.
11:40:49 <Berengal> The library isn't mine, but yes, you can put tags inside tags in a way that doesn't make sense. The final output string will be valid xml though
11:41:23 <Berengal> Unless you abuse primHtml, which is just a String -> Html function with no escaping
11:41:36 <camio> Oh, okay. I prefer the non-infix syntax myself, but that's a personal preference.
11:42:40 <camio> I of course agree with your premise, that Haskell is a great html templating language. I'd generalize that to html is a great host language for DSLs.
11:42:50 <camio> s/html/Haskell
11:43:00 <Berengal> Which we already know is true ;)
11:43:05 <dino-> Simpler to treat it all like an apt-get or cpan installation. Systemwide. I guess I would do --user installs if hacking on a library.
11:43:24 <Berengal> I just love the way simple functions automatically become templates
11:43:30 <dino-> to keep the broken experimental stuff limited to the dev user
11:44:01 <Berengal> The webpages I write at work take much more boilerplate...
11:44:10 <camio> Berengal: Yeah, it's great. I've found the technique to be language-agnostic.
11:44:32 <Jedai> Berengal: There are some libraries that forbid wrong HTML with typing
11:44:47 <Berengal> camio, assuming your language has first-class functions and a lightweight syntax
11:45:10 <Berengal> Jedai, I know, but I'm not too bothered about that. It's not that hard to get it right :P
11:45:35 <ray> first-class syntax and lightweight functions
11:45:40 <Jedai> Berengal: True :)
11:45:43 <Saizan> dino-: ok, so either you've custom paths for --global, or i don't know why cabal puts things into $HOME
11:45:52 <camio> Berengal: I'm referring to C++/Python. I'm not sure about others.
11:46:03 <Berengal> camio, at work, Java is the language of choice... :(
11:46:22 * camio sighs
11:46:32 <jonh> Berengal: in due time...
11:47:44 <dino-> Saizan: /root/.cabal/packages/<tons of things downloaded>
11:47:45 <gbacon> I'm trying to write QuickCheck properties for a function whose argument is an infinite list, so can I wedge randomRs inside an Arbitrary instance or a custom Gen?
11:47:52 <dino-> and /root/.cabal/logs
11:48:10 <Saizan> dino-: oh, i see, thanks
11:48:14 <dino-> They give my backup software fits. Each user has his own cron jobs for backup to central server.
11:48:18 <Berengal> I mean, JSF isn't too bad, and with facelets it sucks even less. At least it takes the html out of java, but it's not a programming language
11:49:17 <dino-> eh, the backup is more complicated than that, but just say the dirs only perm'd to root in /home/dino/ are cranky
11:49:47 <Berengal> In haskell you get the ease of writing that simple markup gives you coupled with the power of a proper language
11:50:11 <Berengal> Plus plugging dynamic values
11:50:37 <dino-> Berengal: sneak Scala in there!
11:51:25 <Berengal> dino-, unfortunately, Scala isn't Java, so no go :/
11:51:33 <Berengal> Scala's a bit ugly when you're used to haskell anyway
11:52:05 <dino-> Berengal: I understand. Was 1/2 joking.
12:02:33 <monochrom> <3 haskell
12:02:56 <dino-> Just to be clear, I'm not complaining about cabal-install. It and Cabal are absolutely fantastic. cabal-install changed everything.
12:03:11 <dino-> dcoutts and c-i developers: thank you!
12:03:15 <dcoutts> :-)
12:03:26 <camio> but?
12:04:02 <dino-> camio: RE: above stuff, blah blah, sudo -H, blah blah ~/.cabal/ dir perms...
12:04:09 <camio> ah, thanks.
12:04:59 <dcoutts> dino-: so the issue is you have to use sudo -H otherwise it makes root-owned files in your home dir, right?
12:05:33 <dcoutts> dino-: is there any reason you don't use the cabal feature to build as user and install globally?
12:05:33 <dino-> dcoutts: Yes, when doing --global
12:05:53 <dino-> dcoutts: hm, that sounds like it would be me not knowing how to use it
12:06:03 <dcoutts> dino-: do you do both user and global, or just always global?
12:06:21 * Axman6 has decided that OpenCL is hard :(
12:06:43 <Axman6> especially when it can't find the required by spec cos function
12:07:05 <dino-> dcoutts: Almost only global, I have it set in /root/.cabal/config
12:07:27 <dino-> Also, I'm picky with the documentation: True
12:07:33 <dino-> I guess paranoid about being off the wire.
12:07:55 <dcoutts> dino-: so you can have it so that there is no /root/.cabal/ at all, that you use your users ~/.cabal/config and package download cache, but install globally via sudo
12:08:26 <dcoutts> dino-: just set the root-cmd to sudo in your ~/.cabal/config and set user-install to False
12:09:04 <dcoutts> dino-: it'll build as your user and when it comes to install, it'll re-invoke itself with the root-cmd
12:09:27 <dino-> dcoutts: yeah, this sounds cleaner than having to remember sudo -H and this is more what you're supposed to do. Everything as non-root until install.
12:10:02 <dcoutts> dino-: lemme know if you don't manage to get it working smoothly
12:11:02 <dino-> dcoutts: Will do. I'll try it later. Thanks, didn't realize I was doing it wrong.
12:11:11 <dino-> Saizan: ^^
12:15:12 <m4ik3ru> sup yo
12:15:28 <m4ik3ru> so i figured out that problem we were working on the other day
12:15:32 <m4ik3ru> part of it, at least
12:16:28 <m4ik3ru> > let {crazy xs = filter(\x -> odd(length x)) xs} in crazy ["odd","even","reodd"]
12:16:28 <lambdabot>   ["odd","reodd"]
12:16:32 <m4ik3ru> HAH!
12:16:39 <m4ik3ru> YUS!
12:16:55 <m4ik3ru> sorry :) small victories
12:17:19 <Vulpyne> I don't think you need the curly braces there.
12:17:45 <m4ik3ru> i'll be putting it in a separate file, i'm just building the function up piece by piece
12:18:14 <mauke> > filter (odd . length) (words "odd even reodd")
12:18:15 <lambdabot>   ["odd","reodd"]
12:18:18 <m4ik3ru> the end result will be to take a list of strings, select the odd ones, upcase them, and concatenate them into a single string.
12:18:41 <m4ik3ru> mauke: it has a be a list of strings
12:18:52 <mauke> do you want to figure it out yourself or can I post a solution? :-)
12:18:52 <m4ik3ru> by the function definition we were given, that is :)
12:18:57 <m4ik3ru> no!
12:19:00 <m4ik3ru> i'll get it!
12:19:08 <mauke> ok!
12:19:12 <m4ik3ru> BUT!  don't take that to mean i'm ungrateful ;)
12:19:33 <m4ik3ru> because eventually i will need y'all's help
12:20:03 <Vulpyne> > unwords [map toUpper x | x <- words "odd even reodd", odd (length x)]
12:20:03 <lambdabot>   "ODD REODD"
12:20:13 <m4ik3ru> not looking!
12:20:20 <mauke> needs more list comprehensions
12:20:20 <Vulpyne> Oh, sorry.
12:20:34 <m4ik3ru> :D
12:20:34 <Vulpyne> I wasn't reading the text while I messed around with that. :(
12:20:44 <m4ik3ru> it's ok, problem solved :)
12:20:52 <m4ik3ru> a quick part and rejoin
12:20:57 <m4ik3ru> no big :)
12:22:07 <m4ik3ru> i shall minimize until this one is solved, i'm very close now...
12:22:10 <m4ik3ru> back in a flash!
12:27:39 <mishrak> >t combine
12:28:20 <m4ik3ru> YUS!
12:28:33 <m4ik3ru> concatenateAndUpcaseOddLengthStrings xs = map (toUpper) (concatenate (filter (\x -> odd(length x)) xs))
12:28:49 <m4ik3ru> i know, point-free form is so much cooler
12:28:51 <mauke> what's concatenate?
12:28:52 <Makoryu> m4ik3ru: ENTERPRISE-QUALITY NAMING
12:28:59 <m4ik3ru> user-defined
12:29:04 <mauke> :t concat
12:29:04 <lambdabot> forall a. [[a]] -> [a]
12:29:08 <m4ik3ru> and that's what i was given to use
12:29:08 <mauke> tee hee
12:29:19 <m4ik3ru> that's my prof for you :)
12:29:20 <mauke> (toUpper) better written as toUpper
12:29:44 <jmcarthur_work> @pl concatenateAndUpcaseOddLengthStrings xs = map (toUpper) (concatenate (filter (\x -> odd(length x)) xs))
12:29:44 <lambdabot> concatenateAndUpcaseOddLengthStrings = map toUpper . concatenate . filter (odd . length)
12:29:59 <Vulpyne> On of the few cases where point free makes it more clear. :)
12:30:06 <mmorrow> @pl concatenateAndUpcaseOddLengthStringsFactoryFactorySubstation xs = map (toUpper) (concatenate (filter (\x -> odd(length x)) xs))
12:30:07 <lambdabot> concatenateAndUpcaseOddLengthStringsFactoryFactorySubstation = map toUpper . concatenate . filter (odd . length)
12:30:08 <jmcarthur_work> s/few/many/
12:30:12 <Makoryu> m4ik3ru: "f x y" will always parse as "f (x) (y)" and never "f (x y)"
12:31:13 <poe> > - succ 2
12:31:14 <lambdabot>   -3
12:31:31 <mauke> > subtract 5 2
12:31:32 <lambdabot>   -3
12:33:42 <m4ik3ru> brb
12:37:47 <dino-> dcoutts: That works perfectly. Now I feel silly with my tough-guy -H
12:37:57 <dcoutts> :-)
12:38:37 <dino-> Probably should RTFM
12:39:23 <Saizan_> or WTFM
12:39:56 <m4ik3ru> k, so, i'm a work, doing homework, because there's nothing else to do :)
12:39:59 <m4ik3ru> love my boss
12:40:23 <m4ik3ru> but all my apps (megairc, notepad++, putty) are portable and on my flash drive
12:40:25 <Vulpyne> Only thing better is to be at work... writing Haskell code.
12:40:41 <m4ik3ru> they needed to borrow a usb slot
12:41:03 <m4ik3ru> and their drive is big and wouldn't fit because of the way the ports are oriented
12:41:13 <m4ik3ru> and i didn't feel like going around to the back
12:41:17 <m4ik3ru> so i just unplugged :)
12:41:19 <m4ik3ru> anyway
12:41:26 <m4ik3ru> back to haskell
12:41:41 <m4ik3ru> did i see that there's a lambdabot command to convert something to point-free?
12:42:01 <Saizan_> @pl \x -> x
12:42:01 <lambdabot> id
12:53:13 <camio> @pl \x -> x*x
12:53:13 <lambdabot> join (*)
12:56:36 <camio> @pl \x -> x*x*x
12:56:36 <lambdabot> (*) =<< join (*)
12:56:43 <camio> @pl \x -> x*x*x*x
12:56:43 <lambdabot> (*) =<< (*) =<< join (*)
12:57:22 <trofi> :t (^4)
12:57:23 <lambdabot> forall a. (Num a) => a -> a
12:59:27 <pr> @pl \x -> x+x+x+x
12:59:28 <lambdabot> (+) =<< (+) =<< join (+)
12:59:36 <pr> @pl \x -> x+x+x+x*x*x+x^x
12:59:36 <lambdabot> ap ((+) . liftM2 (+) ((+) =<< join (+)) ((*) =<< join (*))) (join (^))
13:00:33 <trofi> :t sum . replicate 4
13:00:33 <lambdabot> forall a. (Num a) => a -> a
13:01:03 <benmachine> @unpl join (join (*)) 4
13:01:04 <lambdabot> (((*) >>= \ c -> c) >>= \ a -> a) 4
13:01:09 * benmachine blinks
13:01:28 <m4ik3ru> ok
13:01:33 <m4ik3ru> this is going to seem dumb
13:01:44 <m4ik3ru> what's the difference between and Int and an Integer?
13:01:52 <mauke> m4ik3ru: Integers are unbounded
13:02:00 <benmachine> > maxBound :: Int
13:02:01 <lambdabot>   9223372036854775807
13:02:07 <benmachine> ^ may be smaller on your systm
13:02:07 <trofi> > maxBount :: Int32
13:02:08 <lambdabot>   Not in scope: `maxBount'
13:02:13 <trofi> > maxBound :: Int32
13:02:13 <lambdabot>   2147483647
13:02:22 <trofi> > maxBound :: CInt
13:02:23 <lambdabot>   Not in scope: type constructor or class `CInt'
13:02:32 <Makoryu> > maxBound :: Int64
13:02:33 <lambdabot>   9223372036854775807
13:02:42 <trofi> > maxBound :: Int128
13:02:43 <lambdabot>   Not in scope: type constructor or class `Int128'
13:02:50 <m4ik3ru> how does a list have the type Interger?
13:02:57 <mauke> no.
13:03:00 <trofi> huh?
13:03:09 <m4ik3ru> i get an error when i run this line:
13:03:15 <m4ik3ru> keepInBetween a b ls = filter (>= a) (filter (< b) ls)
13:03:18 <trofi> :t genericLenght
13:03:19 <lambdabot> Not in scope: `genericLenght'
13:03:20 <trofi> :t genericLength
13:03:21 <lambdabot> forall b i. (Num i) => [b] -> i
13:03:32 <mauke> m4ik3ru: what error?
13:03:44 <m4ik3ru> type mismatch
13:03:53 <m4ik3ru> couldn't match int against integer
13:03:58 <mauke> no, the real error
13:04:05 <trofi> :t \a -> (>= a)
13:04:05 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:04:08 <m4ik3ru> ...
13:04:09 <mauke> and the code that caused it
13:04:22 <m4ik3ru> that's the line, keepInBetween a b ls = filter (>= a) (filter (< b) ls)
13:04:34 <mauke> that line has no errors
13:04:36 <trofi> @let keepInBetween a b ls = filter (>= a) (filter (< b) ls)
13:04:37 <lambdabot>  Defined.
13:04:42 <m4ik3ru> says: Couldn't match 'Int' against 'Integer'
13:04:45 <Makoryu> :t keepInBetween
13:04:45 <lambdabot> forall a. (Ord a) => a -> a -> [a] -> [a]
13:04:46 <mauke> no, it doesn't
13:04:48 <trofi> > keepInBetween 2 3 [1,2,3,4]
13:04:49 <lambdabot>   [2]
13:04:57 <m4ik3ru> ...weeeeeeird
13:05:01 <m4ik3ru> let me reload the file...
13:05:02 <trofi> > keepInBetween 2 (3 :: Integer) [1,2,3,4]
13:05:03 <lambdabot>   [2]
13:05:10 <Makoryu> m4ik3ru: The error is coming from somewhere else. Maybe you're trying to use it with one Int argument and one Integer argument
13:05:15 <trofi> > keepInBetween 2 (3 :: Integer) [1,2,(3 :: Int),4]
13:05:16 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
13:05:16 <lambdabot>         agains...
13:05:28 <benmachine> m4ik3ru: give the function an explicit type signature
13:05:38 <benmachine> (probably the one lambdabot came up with)
13:05:51 <m4ik3ru> benmachine: meaning?
13:05:56 <mauke> benmachine: why?
13:06:10 <mauke> the one lambdabot "came up with" is the one ghc uses anyway
13:06:17 <m4ik3ru> when i load it into ghci, i define a list like:
13:06:24 <m4ik3ru> let a = [1..10]
13:06:35 <benmachine> mauke: hmm, yeah never mind
13:06:36 <m4ik3ru> then call keepInBetween 2 5 a
13:06:40 <benmachine> my logic is iffy
13:06:46 <trofi> let?
13:06:47 <mauke> > let a = [1..10] in keepInBetween 2 5 a
13:06:48 <lambdabot>   [2,3,4]
13:06:52 <mauke> m4ik3ru: works
13:07:01 <m4ik3ru> let me try that in ghci
13:07:24 <trofi> m4ik3ru: ghci has ':type expr' too, so you can check passed types
13:07:28 <m4ik3ru> it does it when i don't define the list with let
13:07:36 <m4ik3ru> i mean, it works
13:08:22 <m4ik3ru> i was given the type definition as such:
13:08:23 <m4ik3ru> keepInBetween :: Int -> Int -> [Int] -> [Int]
13:08:40 <mauke> stop paraphrasing
13:08:46 <mauke> give me actual code that reproduces the problem
13:09:05 <m4ik3ru> i have a file named A2.hs
13:09:15 <m4ik3ru> i am required to name it this by the prof
13:09:29 <m4ik3ru> i have a function defined in A2.hs called keepInBetween
13:09:33 <trofi> cat A1.hs | wgetpaste
13:09:42 <m4ik3ru> it has the type keepInBetween :: Int -> Int -> [Int] -> [Int]
13:09:46 <trofi> share real snippet
13:09:49 <mauke> you're still describing your code instead of giving me your code
13:09:51 <trofi> @paste
13:09:51 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:09:52 <benmachine> surely you mean wgetpaste < A1.hs
13:10:02 <trofi> yep
13:10:04 <mauke> surely you mean < A1.hs wgetpaste
13:10:11 <sereven> let a = [1..10] probably defaults to [Integer] so if you explicitly use a function keepInBetween :: Int -> Int -> [Int] -> [Int] it won't work on an [Integer]
13:10:14 <trofi> A2
13:10:15 <trofi> ;]
13:10:24 <m4ik3ru> i'll just paste it to hpaste
13:10:42 <mauke> ah, looks like sereven is right
13:11:15 <m4ik3ru> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3724#a3724
13:11:15 <benmachine> so I was sort of right with the type signatures only on the wrong thing
13:12:02 <dschoepe> m4ik3ru: the first case is superfluous
13:12:02 <m4ik3ru> i'd assume the prof will know this beforehand and not screw us over since he gave us the type definition of all the functions we're supposed to implement
13:12:15 <benmachine> try let a = [1 .. 10] :: [Int]
13:13:04 <Cale> m4ik3ru: It's not necessary to have a base case when you don't have a recursive case ;)
13:13:30 <m4ik3ru> Cale: ah, thanks :) new to this, as i'm sure you've surmised
13:13:38 <m4ik3ru> benmachine: that worked, thanks
13:14:31 <m4ik3ru> mauke: sorry for the confusion :)
13:28:04 <litb> hello folks
13:29:42 <m4ik3ru> Howdy!
13:31:04 <litb> oh noes, you surely now have more members than ##c++. !
13:31:33 <litb> oh wait. 647 vs 646 . ##c++ wins by one person lol
13:32:52 <benmachine> size does not matter
13:32:58 <benmachine> unless at any point we start winning
13:33:08 <benmachine> in which case size will promptly start mattering
13:33:12 <Cale> We have been larger than ##c++ before, I'm pretty sure.
13:33:26 <litb> oh
13:33:33 <Cale> We were well over 700 users for a bit.
13:33:37 <jfoutz> meh, there are way way more c++ programmers. they're just too busy resolving segfaults to spend much time on irc.
13:33:39 <litb> i see
13:33:59 <dino-> Is that the channel that doesn't know if it wants to be C++ or C-Sharp when it grows up?
13:34:22 <jfoutz> sharp sharp c plus plus
13:36:32 <RayNbow> jfoutz: while on the other hand Haskell allows people to do recreational math, build robots, write a gazillion awesome blogposts and still manage to have time left for a day job? :p
13:36:58 <jmcarthur_work> not sure about that time left over part
13:36:58 <RayNbow> (or is that limited to just sigfpe? :p)
13:37:08 <jfoutz> well... mostly i just screw around with the leftover time, but yeah.
13:37:21 <jmcarthur_work> i would much rather just do recreational functional programming exclusively ;)
13:37:36 <RayNbow> jmcarthur_work: while getting paid for it? :p
13:37:49 <jmcarthur_work> that would be bonus
13:37:56 <jmcarthur_work> i suppose going into academia would be a way
13:38:27 <blackdog> jmcarthur_work: i think you tend to spend a lot of time on other stuff even in academia
13:38:34 <jmcarthur_work> probably so
13:38:41 <jmcarthur_work> this is why i am hesitant about it, i think
13:38:51 <jmcarthur_work> i'm not sure if the grass is really greener there
13:39:16 <blackdog> one way i found that sort of worked was to work on boring high-paid stuff for a few months, make enough money to support yourself for a while, then just hack until you run out of money :)
13:39:18 <jmcarthur_work> and it requires a lot of investment just to get in
13:39:58 <blackdog> it does depend a bit on what you want to hack on, too. if you're a type theorist, you should probably be in a uni. if you just want to hack using esoteric languages, i don't know how much it buys you.
13:40:03 <jmcarthur_work> blackdog, unfortunately i also have to take care of a wife who is trying to get some freelancing started, which seems to be taking a while
13:40:30 <jmcarthur_work> i wouldn't say i am a type theorist, but i do love type theory
13:40:39 <blackh> I do programming for a day job anyway.  I find it too frustrating not doing Haskell for all those hours, so I have made it a priority to do as much Haskell as possible.
13:40:43 <blackdog> jmcarthur_work: yeah, dependents are tricky. i'm sort of lucky, i still live like a student and my girlfrend would rather shoot herself than let me support her
13:40:56 <jmcarthur_work> heh
13:41:32 <jmcarthur_work> my wife vows that i will have an opportunity to try my own thing eventually. she would hate herself if not
13:41:44 <SubStack> blackh: I feel like that too.
13:41:55 <jmcarthur_work> blackh, yup!
13:42:30 <SubStack> the stuff I can dream up to work on is vastly more interesting than anything I'd be paid to do
13:42:45 <SubStack> this is why people need to be paid to write these things
13:44:04 <jmcarthur_work> if i had a crazy amount of capital, i would start a business, hire some talented programmers, pay them the bare minimum possible to support them and their families, and tell everybody to just make things they enjoy. would be an interested experiment in what can make money and intrinsic motivation
13:44:21 <jmcarthur_work> *interesting experiment
13:45:22 <jmcarthur_work> "bare minimum" meaning "whatever they are satisfied with considering that they get to work on whatever they want"
13:45:32 <m4ik3ru> jmcarthur_work, let me know when you start that up :D
13:45:35 <jmcarthur_work> heh
13:45:48 <jmcarthur_work> there is a very important qualification at the very beginning of that idea
13:45:54 <jmcarthur_work> got some capital? :)
13:46:02 <dons> jmcarthur_work: isn't that some kind of research startup?
13:46:29 <m4ik3ru> jmcarthur_work, yeah, i just got paid today.
13:46:43 <m4ik3ru> i work 10.5 hours a week outside of class for minimum wage
13:46:52 <jmcarthur_work> dons, maybe. i really just wouldn't want to introduce restrictions on the direction anything can go
13:46:54 <m4ik3ru> what can we do with that?
13:47:11 <m4ik3ru> besides order a pizza
13:47:16 <dons> jmcarthur_work: no direction at all?
13:47:19 <jmcarthur_work> pizza can be a good motivator!
13:47:50 <jmcarthur_work> dons, very little. my personal opinion is that if people devote themselves to things they enjoy, it just might be possible to make some money from it... maybe
13:47:57 <jmcarthur_work> dons, but i wouldn't say this is a realistic dream anyway
13:48:02 <blackdog> jmcarthur_work: i think some constraints are important. that was one of the things i noticed moving to unsw from sydney uni - there were coherent research groups trying to push the state of the art forward in some area
13:48:04 <jmcarthur_work> so i get to make things up :)
13:48:21 <jmcarthur_work> i think things would self-organize a bit
13:48:35 <dons> blackdog: and we got hella more done. :)
13:48:36 <blackdog> at sydney, they sort of just did their own thing, and i can't remember anything terribly interesting that came out of it
13:48:36 <jmcarthur_work> 10 people might work on two or three things
13:48:39 <dons> all those chess bots
13:49:20 <blackdog> dons: there was sort of a bit of friendly competition, too - if someone's working in the same field as you, you can compare a bit and see how you're doing.
13:49:49 <blackdog> jmcarthur_work: you always get what you select for, though.
13:50:05 <blackdog> whether it was what you actually wanted or not
13:51:15 <jmcarthur_work> eh, of course to be realistic there would have to be some restrictions just to be viable as a business model
13:51:22 <jmcarthur_work> i'm just talking about ideals
13:51:49 <burp> in an ideal world :)
13:51:58 <jmcarthur_work> and i do think it wouldn't be *vast* failure to be with little to no restriction on what can be worked on, just not directed enough to be a win
13:52:00 <blackdog> i think i'm talking about ideals too, though. constraints can actually breed creativity
13:52:06 <jmcarthur_work> i agree
13:52:18 <jmcarthur_work> i think a lot of the constraints would be induced by the setting itself though
13:52:30 <jmcarthur_work> for example, there would probably be a lot of social pressure to work on existing projects
13:53:16 <jmcarthur_work> there would also be a lot of intrinsic motivation to do things that make money, better humanity, whatever
13:54:02 <blackdog> if you hire the right people, sure
13:54:08 <jmcarthur_work> yeah, that's the key
13:54:18 <blackdog> recruiting is hard even when you're willing to pay a lot of money and spend a lot of time interviewing
13:54:54 <blackdog> you get an initial jump from the people you hire who you already know, but once that well's dry it gets tricky
13:55:09 <burp> hire #haskell ;)
13:55:16 <jmcarthur_work> burp, :)
13:55:22 <medfly> whaaat
13:55:28 * blackdog pulled in a few PLS people into Optus and is not sure he did the right thing from a moral standpoint :)
13:55:35 <medfly> someone willing to pay a decent amount of money these days AND having a hard time hiring?
13:56:01 <medfly> I've heard stories of people who would make as much as their friend who are waitressing nowadays
13:56:02 <blackdog> medfly: if you want really good hackers, yeah, absolutely.
13:56:27 <blackdog> you still have to spend a lot of time winnowing out the people who apply who can talk a good game
13:56:31 <medfly> because no one would pay more because they all know the employees are desperate :p
13:56:58 <jmcarthur_work> i dunno. i don't make much, and i would be willing to be paid even much less if it meant i got to work on things that i truly find interesting
13:57:44 <jmcarthur_work> the interview process for something like this would probably be to hear about the candidate's pet projects, for the most part
13:57:47 <medfly> no it's like they want a job in general, and they can't find something, interesting or not, for a decent pay, and are around the median pay
14:00:31 <andyjgill> Has anyone got codec-image-devil working on osx?
14:00:40 <blackdog> medfly: seriously? Every time i go to the Rails meetup in sydney, there are two or three people advertising jobs
14:01:10 <medfly> well I imagine a nerd who hangs out on an open source network has enough stuff to show to get a job anyway
14:01:27 <medfly> but I do hear rumours of people struggling to find jobs despite lowering their standards very very low
14:02:13 <luite> you mean like php low? ;)
14:02:43 <blackdog> medfly: so you don't lower your standards. you spend a month working very hard on an open source project of some kind, get some sort of credibility, then start looking for jobs again.
14:02:57 * blackdog gets off his soapbox
14:03:05 <medfly> I don't know, those are just stories I hear on the media that is trying to get me depressed and think the world is horrible!
14:03:52 <medfly> telling people they should be grateful to be having jobs that pay the median pay!
14:04:09 <m4ik3ru> actual question (please just point me in the right direction):
14:04:22 <m4ik3ru> i have to implement this function
14:04:34 <m4ik3ru> maxElementOfAList :: Ord a => [a] -> a
14:04:42 <m4ik3ru> i'm sure you can tell what it does
14:04:55 <mauke> yes :-)
14:04:58 <m4ik3ru> i have to use map, filter, foldr and/or foldl
14:05:19 <blackdog> m4ik3ru: i don't think that function is ossible
14:05:22 <m4ik3ru> i can't find any other such implementation online, or i haven't looked hard enough
14:05:28 <m4ik3ru> probably the latter...
14:05:35 <blackdog> what does maxElementOfAList [] do?
14:05:39 <mauke> blackdog: fail
14:05:43 <m4ik3ru> yup
14:06:24 <mauke> m4ik3ru: I'd use foldl or foldr, and maxOfTwo :: (Ord a) => a -> a -> a, which I'd have to write first
14:06:58 <m4ik3ru> ok, i'll try to implement that
14:07:15 <m4ik3ru> never said anything about NOT implementing helper functions :)
14:07:25 <blackdog> m4ik3ru: so work out what your real base case is, and what the invariant you want to maintain in your state argument is
14:07:42 <idnar> bleh, hit 45GB on this export and ran out of space
14:08:01 <m4ik3ru> blackdog: invariant in the state argument?
14:08:25 <idnar> er, wrong window
14:09:00 <blackdog> :type foldl
14:09:09 <blackdog> @type foldl
14:09:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:09:28 <blackdog> see that a? that's the thing you start with, and what you end up with
14:09:39 <blackdog> while you fold over a list of bs
14:10:06 <m4ik3ru> so i can apply >= to a list?
14:10:13 <m4ik3ru> i'll try it...
14:10:15 <m4ik3ru> don't tell me
14:10:18 <mauke> you can, but it probably won't do what you want
14:10:22 <blackdog> you start with an invariant that's true at the beginning, and show that each time you apply the function argument, that the property stays true.
14:10:27 <m4ik3ru> hah, it didn't :)
14:10:44 <blackdog> stop hacking and think :)
14:10:50 <mauke> how boring
14:10:55 <blackdog> wow, now i sound like pete gammie...
14:11:00 <Makoryu> :t (>= ["foo"])
14:11:01 <lambdabot> [[Char]] -> Bool
14:11:06 <gwern> who?
14:11:15 <dschoepe> Is there a way to use one instance declaration for a type class if a data type is an instance of class X, and another if it isn't?
14:11:21 <m4ik3ru> blackdog: you know, i distinctly remember someone else in this channel telling me something very similar recently...
14:11:29 <m4ik3ru> :)
14:11:35 <blackdog> ah, dude from UNSW. very smart, gets frustrated with me when we work together because i blat out something stupid as a first cut
14:12:05 <blackdog> gwern: he wrote almost all of the TBC testing framework
14:12:22 * gwern hasn't heard of TBC either
14:12:58 <Philonous> dschoepe:I'm afraid not. That would be awesome, though.
14:15:46 <Philonous> dschoepe: Well, actually with IncoherentInstances you sort of can. But it is very ugly. Define the instance for the types that are an instance first, than define one for the rest.
14:16:12 <dschoepe> Philonous: yes, I tried that but only with Flexible- and OverlappingInstances, but that didn't work. I'll try.
14:16:20 <Philonous> dschoepe: That doesn't work with fundeps/type families though
14:16:57 <fracture> anyone know a way to convert an integer to a list of digits easily?
14:17:23 <gwern> I can give you a list of characters very easily :)
14:17:36 <gwern> fracture: but the standard advice is to show it, then map read
14:17:38 <dschoepe> Philonous: hmm it still says duplicate instances.
14:17:43 <fracture> oh
14:17:58 <gwern> > (map read $ show 100111004) :: [Int]
14:17:58 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:17:58 <lambdabot>         against inferred ty...
14:18:16 <fracture> hmm
14:18:21 <gwern> hm. well, that's the idea
14:18:27 <fracture> can't quite figure it out
14:18:43 <gwern> > show 10001
14:18:43 <lambdabot>   "10001"
14:18:58 <gwern> "1001" == ['1', '0', '0', '1']
14:19:16 <benmachine> :t digitToInt
14:19:17 <lambdabot> Char -> Int
14:19:21 <gwern> now you need to do ['1', '0', '0', '1'] ~> [1, 0, 0, 1]
14:19:23 <fracture> ahhh
14:19:32 <fracture> where is digitToInt?
14:19:34 <gwern> our mystery ~> has the type 'Char -> Int'
14:19:37 <gwern> @hoogle Char -> Int
14:19:38 <lambdabot> Data.Char digitToInt :: Char -> Int
14:19:38 <lambdabot> Data.Char ord :: Char -> Int
14:19:38 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
14:19:41 <benmachine> @index digitToInt
14:19:41 <lambdabot> Data.Char
14:19:56 <gwern> so you see you can do show, then map digitToInt
14:19:59 <m4ik3ru> welp, luckily (or unluckily, because now i have to stop coding), i got off of work early.
14:20:02 <fracture> yep
14:20:02 <gwern> let's try it again
14:20:04 <fracture> thanks man
14:20:06 <fracture> works
14:20:12 <gwern> > map digitToInt $ show "100001"
14:20:12 <m4ik3ru> gotta jet, but thanks for your help, all
14:20:13 <lambdabot>   [* Exception: Char.digitToInt: not a digit '"'
14:20:19 <m4ik3ru> i'll be back soon :)
14:20:24 <gwern> (what the heck)
14:20:35 <benmachine> gwern: showing a string
14:20:41 <gwern> oh, duh
14:20:44 <gwern> > map digitToInt $ show 100001
14:20:45 <lambdabot>   [1,0,0,0,0,1]
14:20:48 <benmachine> woo
14:20:50 <gwern> et voila!
14:20:59 <fracture> nice
14:21:09 <gwern> or for max concision, do it pointlessly! 'foo = map digitToInt . show'
14:21:25 <Philonous> dschoepe: Indeed, doesn't work. I'm sorry.
14:21:42 <dschoepe> Philonous: do you know of a different way to distinguish automatically between e.g. Show-able and not showable types?
14:22:14 <litb> i like how it's called "pointless" but it *does* usually contain *more* points "a . b . . c d" and so on xD
14:22:16 <gwern> dschoepe: call ghc on a program using show with values of that type; if it errors out...
14:22:55 <fracture> I have this function ... let next = foldl1' (\x y -> x * 10 + y) . concat . map (\x -> [length x, head x]) . group . digits
14:22:56 <dschoepe> gwern: hehe
14:23:01 <fracture> with let digits = map digitToInt . show
14:23:17 <mmorrow> , let digits = let go !is x = case quotRem x 10 of (0,i) -> i:is; (x',i) -> go (i:is) x' in go [] in digits 98723874
14:23:17 <Philonous> dschoepe: No. I'd like this very much, too. But maybe there is another way?
14:23:18 <lunabot>  [9,8,7,2,3,8,7,4]
14:23:22 <fracture> if I try to write it with the map digitToInt . show in the same line it fails.... any ideas why?
14:23:35 <gwern> fracture: surround it with parens
14:23:59 <fracture> gwern: tried that already, didn't help
14:24:09 <dschoepe> Philonous: I could either supply different constructors one requiring Show and have the user of the functions pick it or pass show along manually
14:24:57 <skorpan> there are a lot of web frameworks for haskell it seems.  is there anything which sort of just "ships" with an ORM as well?
14:25:13 <fracture> says something about no instance for Num ()
14:25:24 <gwern> skorpan: what objects would you manage in haskell?
14:25:42 <mmorrow> fracture: the "right" way to do this is to use quotRem
14:25:55 <mmorrow> (or maybe divMod)
14:25:59 <gwern> @hoogle quotRem
14:25:59 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
14:26:05 <mmorrow> , let digits = let go !is x = case quotRem x 10 of (0,i) -> i:is; (x',i) -> go (i:is) x' in go [] in digits 98723874
14:26:06 <lunabot>  [9,8,7,2,3,8,7,4]
14:26:09 <jmcarthur_work> skorpan, most of the web frameworks and database adapters are quite orthogonal to one another, afaik
14:26:13 <gwern> mmorrow: maybe he wants the base 10 expression
14:26:23 <mmorrow> gwern: ?
14:26:29 <fracture> gwern: yeah:  i'm doing a "look and see" sequence
14:26:31 <fracture> err look and say
14:26:34 <fracture> in base 10
14:26:37 <fracture> http://en.wikipedia.org/wiki/Look-and-say_sequence
14:27:04 <gwern> mmorrow: if I understand your version quotRem will give the digits according to whatever base, while show/digitToInt assume base 10
14:27:32 <mmorrow> gwern: sure, but i hardcoded 10
14:27:50 <gwern> right, but the flexibility is there, while it isn't with my version
14:27:55 <gwern> you make the 10 explicit
14:28:08 <mmorrow> oh, i see what you're saying... i was confused there for a minute ;)
14:28:26 <mmorrow> i was like "um. <pause> um."
14:28:35 <fracture> is there a better way than that foldl1 to go back to the number?
14:28:50 <gwern> MONADS MAKE EVERYTHING BETTER
14:28:58 <mmorrow> USE MOAR MONARDS
14:29:00 <fracture> sweet, how do you do it with monads
14:29:04 <fracture> (haha)
14:29:33 <fracture> [1,2,3] >>= show does what I'd like
14:29:36 <fracture> then maybe I can read it...
14:29:36 <gwern> probably could do something with State or maybe just Reader
14:29:48 <olsner> haha, MOAR MONARDS!
14:30:40 <gwern> I will view it a good day if we can ever get 'fptard' replaced with 'monards'
14:30:50 <gwern> as in, 'those stupid haskell monards'
14:32:36 <olsner> s/Monad/Retad/ and things start to get funny
14:33:24 <olsner> (apparently "s/x/y/" is a verb)
14:36:27 <gwern> olsner: I'll s/// you!
14:36:42 <FunctorSalad> "Monards"... that sounds pretty cool
14:37:24 <olsner> gwern: hmm, isn't that a no-op? I'll s/.*// you!
14:37:31 <Botje> ALL HAIL THE MONARDY!
14:37:44 <gwern> olsner: no, it forces an evaluation of all of you
14:37:48 <gwern> it's like gropign
14:37:50 <benmachine> the constitutional monrardy?
14:37:50 <gwern> *groping
14:37:53 <benmachine> -r
14:38:17 <olsner> gwern: hey! hands off my thunk
14:38:26 <mauke> olsner: no, because s/// will reuse the last successful regex
14:38:26 <FunctorSalad> grep!
14:40:29 <olsner> hmm, ghc's parallel build system seems to be missing a lot of possible parallelism - often using only 1 or 2 of the available cpu:s even when run with -j8
14:40:32 <jmcarthur_work> > iterate (read . concat . map (uncurry (++) <<< show . length &&& id) . group . show) 1 :: [Integer]
14:40:33 <lambdabot>   [1,11,211,12211,11222211,21142222211,1221114522222211,112223111141562222222...
14:41:12 <jmcarthur_work> oh wrong
14:41:15 <olsner> I guess some parts of the build that haven't been converted or something
14:41:22 <jmcarthur_work> > iterate (read . concat . map (uncurry (++) <<< show . length &&& head) . group . show) 1 :: [Integer]
14:41:23 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:41:23 <lambdabot>         against inferred ty...
14:41:29 <benmachine> isn't <<< the same as . anyway
14:41:37 <benmachine> @type (<<<)
14:41:38 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
14:41:39 <jmcarthur_work> i did that for precedence
14:41:43 <benmachine> oh right
14:41:44 <benmachine> clever
14:41:45 <FunctorSalad> as Control.Category..
14:41:47 <jmcarthur_work> > iterate (read . concat . map (uncurry (++) <<< show . length &&& pure . head) . group . show) 1 :: [Integer]
14:41:48 <lambdabot>   [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,132113111231...
14:41:56 <jmcarthur_work> there we go
14:42:42 <fracture> nice
14:43:05 <benmachine> > iterate (read . concatMap (uncurry (++) <<< show . length &&& pure . head) . group . show) 1
14:43:06 <lambdabot>   [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,132113111231...
14:43:13 <benmachine> > iterate (read . concatMap (uncurry (++) <<< show . length &&& pure . head) . group . show) 22
14:43:14 <lambdabot>   [22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22...
14:43:17 <FunctorSalad> what *is* that?
14:43:31 <jmcarthur_work> FunctorSalad, read each digit out loud
14:43:58 <benmachine> read it as, one one, two ones, one two and one one, one one and one two and two ones, etc.
14:44:33 <fracture> @hoogle pure
14:44:33 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
14:44:47 * fracture scratches his head.
14:44:48 <fracture> :D
14:44:53 <jmcarthur_work> a -> [a]
14:44:57 <benmachine> > iterate (read . concatMap (uncurry (++) <<< show . length &&& take 1) . group . show) 22
14:44:59 <lambdabot>   [22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22...
14:45:06 <FunctorSalad> so is that supposed to be some rythm?
14:45:13 <jmcarthur_work> > iterate (read . concat . map (uncurry (++) <<< show . length &&& pure . head) . group . show) 333
14:45:14 <lambdabot>   [333,33,23,1213,11121113,31123113,132112132113,11131221121113122113,3113112...
14:45:44 <benmachine> FunctorSalad: it's describing the previous number by listing each digit and its repetitions
14:46:01 <idnar> it's like a run-length encoding
14:46:08 <FunctorSalad> aha
14:46:16 <jmcarthur_work> a very inefficient one
14:46:28 <benmachine> yeah <_<
14:46:39 <gwern> no one said the look-and-say sequence was very practical...
14:46:47 <jmcarthur_work> i guess it's kind of like if you fix gzip
14:46:48 <benmachine> since the thing never has runs greater than 3
14:47:19 <idnar> doesn't that depend on the starting number?
14:47:43 <benmachine> every description has at most three of the same number in sequence
14:47:52 <SamB_XP> idnar: most of these sequences do
14:47:58 <FunctorSalad> @let thing = > iterate (read . concat . map (uncurry (++) <<< show . length &&& pure . head) . group . show)
14:47:58 <lambdabot>   Parse error: VarSym ">"
14:48:02 <SamB_XP> for instance, the fibonacci sequence ...
14:48:05 <FunctorSalad> @let thing =  iterate (read . concat . map (uncurry (++) <<< show . length &&& pure . head) . group . show)
14:48:05 <lambdabot>  Defined.
14:48:09 <benmachine> the starting number can be whatever you like but after that it never generates more than three
14:48:10 <jmcarthur_work> benmachine, not *every* description
14:48:18 <FunctorSalad> @thing 11111111111
14:48:18 <lambdabot> pong
14:48:21 <FunctorSalad> > thing 11111111111
14:48:22 <lambdabot>   [11111111111,111,31,1311,111321,31131211,132113111221,1113122113312211,3113...
14:48:28 <idnar> hmm, I guess that's right
14:48:31 <jmcarthur_work> benmachine, what if the starting digit has a run so long that it takes three digits to describe it
14:48:41 <jmcarthur_work> and those digits are all the same
14:48:49 <benmachine> jmcarthur_work: heh, fair enough
14:48:56 <idnar> > thing ("1" * 999)
14:48:57 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
14:48:57 <lambdabot>    arising from the literal ...
14:48:57 <jmcarthur_work> > iterate (read . concat . map (uncurry (++) <<< show . length &&& pure . head) . group . show) 11111111111
14:48:58 <lambdabot>   [11111111111,111,31,1311,111321,31131211,132113111221,1113122113312211,3113...
14:49:03 <idnar> er
14:49:05 <SamB_XP> > thing 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
14:49:06 <lambdabot>   [11111111111111111111111111111111111111111111111111111111111111111111111111...
14:49:09 <benmachine> hadn't accounted for the possibility of multi-digit repeats
14:49:14 <SamB_XP> > tail $ thing 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
14:49:15 <lambdabot>   [2061,12101611,11121110111621,3112311031161211,132112132110132116111221,111...
14:49:23 <idnar> heh
14:49:32 <SamB_XP> > tail $ thing 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
14:49:33 <lambdabot>   [1661,112611,21121621,12211211161211,112221123116111221,2132211213211631221...
14:49:38 <SamB_XP> > tail $ thing 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
14:49:39 <lambdabot>   [1401,11141011,3114111021,13211431101211,1113122114132110111221,31131122211...
14:49:45 <SamB_XP> > tail $ thing 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
14:49:46 <lambdabot>   [1211,111221,312211,13112221,1113213211,31131211131221,13211311123113112211...
14:49:51 <SamB_XP> > tail $ thing 111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
14:49:52 <lambdabot>   [1111,41,1411,111421,31141211,132114111221,1113122114312211,311311222114131...
14:49:57 <benmachine> yay.
14:50:14 <jmcarthur_work> one hundred eleven ones!
14:50:27 <benmachine> eleventy-one
14:50:59 <benmachine> > tail $ thing 111111111112
14:51:00 <lambdabot>   [11112,4112,142112,1114122112,311411222112,13211421322112,11131221141211132...
14:51:36 <jmcarthur_work> wait that doesn't look right...
14:52:00 <benmachine> eleven ones, one two
14:52:05 <jmcarthur_work> oh!
14:52:08 <jmcarthur_work> duh
14:52:35 <SamB_XP> > tail $ thing 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111112
14:52:36 <lambdabot>   [111112,5112,152112,1115122112,311511222112,13211521322112,1113122115121113...
14:53:19 <SamB_XP> 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111122222222222
14:53:34 <SamB_XP> > tail $ thing 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111122222222222
14:53:35 <lambdabot>   [1111112,6112,162112,1116122112,311611222112,13211621322112,111312211612111...
15:01:11 <jmcarthur_work> man, it takes a while to generate larger numbers in this sequence
15:01:49 <jmcarthur_work> ah i guess it's exponential
15:07:46 <etpace> :t foldr'
15:07:47 <lambdabot> Not in scope: `foldr''
15:08:10 <benmachine> I think foldr' wouldn't make much sense
15:08:17 <benmachine> as foldr's main advantage is its laziness
15:08:30 <etpace> but what if I don't want it's laziness?
15:08:38 <benmachine> use foldl'? :P
15:08:40 <SamB_XP> foldl'
15:08:54 <Makoryu> etpace: Write foldr' using foldl'
15:09:07 <etpace> hmm, i'd have to rewrite my function to account to appending on the left
15:16:00 <Nereid_> @pl let s x y = i x (s y) in s
15:16:00 <lambdabot> fix (flip ((.) . i))
15:16:12 <Nereid_> @pl let s x y = i x (j y) in s
15:16:12 <lambdabot> (. j) . i
15:21:43 <dobblego> what does X mean when used as a binary infix operator between two function operands?
15:22:04 <SamB_XP> dobblego: I think it means (***)
15:22:14 <dobblego> ah yeah makes sense ta
15:22:48 <SamB_XP> 'cause it's lifting the functions into a function over the product
15:33:15 <Alpounet> is there any way to specify using the type system that we want a positive Integer ?
15:33:32 <jmcarthur_work> could make or use a Nat type
15:33:41 <Alpounet> hm
15:33:41 <Alpounet> sorry
15:33:43 <jmcarthur_work> if you mean non-negative
15:33:48 <Alpounet> (tired at this time)
15:33:54 <Alpounet> a positive real number...
15:34:11 <camio> newtype PReal = ...
15:34:18 <jmcarthur_work> all i can think of is a newtype wrapper with a smart constructor
15:34:29 <gwern> jmcarthur_work: my soluition, actually
15:34:52 <gwern> it's kind of ugly but I couldn't think of any type system approach to creating positive reals
15:34:56 <Alpounet> a Maybe Double, actually, or a sort of.
15:35:26 <gwern> (I really wish haskell had just bitten the bullet and created a Nat type. we could argue about whether to round negative results to 0 afterwards)
15:35:33 <jmcarthur_work> Alpounet, have the smart constructor like this:  preal :: Double -> Maybe PReal
15:35:38 <Alpounet> yeah
15:35:44 <Alpounet> exactly what I was thinking.
15:35:52 <opqdonut> gwern: just throw runtime errors ;)
15:36:09 <gwern> unfortunately
15:47:39 <zzzs> newbie question
15:47:45 <zzzs> data BTree k d = BTree Int [(k,[d])] [BTree k d]
15:47:45 <zzzs>  
15:48:02 <zzzs> what does [BTree k d] in this definition mean?
15:48:11 <gwern> a list of more BTrees
15:48:38 <gwern> BTree 10 [stuff] [Btree 11 [stuff], Btree 2 [morestuff], ...]
15:49:13 <gwern> or just BTree 10 []
15:49:19 <gwern> that'd be a basecase
15:49:26 <zzzs> gwern: so this define esstially a list then?
15:49:38 <gwern> it's a tree
15:49:47 <gwern> lists can be trees, so I suppose so
15:50:34 <zzzs> data BTree k d = BTree Int [(k,[d])]
15:50:41 <dons> blackdog: ping
15:51:13 <zzzs> this defines just a non-listed BTree ?
15:51:28 <zzzs> gwern: how can you tell it's a true
15:51:31 <zzzs> tree imeant
15:52:50 <gwern> zzzs: well, look at this: [[1], [[1], [1]], [[2], [2, [2]], [2]]; this doesn't work as is, but imagine every entry is a recursive datatype; if you drew it out on paper, couldn't it form a tree? you have leaves, you have nodes, etc
15:54:48 <zzzs> gwern: so in this def: BTree Int [(k, [d])] being the root, [BTree k d] being the rest of tree then?
15:55:05 <gwern> dunno. I'm not very familiar with B-trees
15:55:43 <zzzs> i guess i'm confused by the reuse of k and d in both the root part and in [Btree k d]
15:56:07 <gwern> zzzs: type variables;
15:56:15 <gwern> k == k only in the sense that 5 == 10
15:56:25 <gwern> they're both a number
15:56:44 <zzzs> gwern: i see
15:56:55 <zzzs> interesting way to do it
15:57:43 <gwern> so you could have Btree 10 [("foo",...)] [Btree 1 [("bar")...
15:57:55 <gwern> the k becomes String, and this typechecks
15:59:07 <zzzs> data DBlock d = DBlock [d] (Maybe (DBlock d))
15:59:07 <zzzs>  
15:59:27 <zzzs> so does this say that it maybe a list?
16:00:18 <Elly> it's definitely a list, and maybe another DBlock too
16:00:42 <gwern> of course, we can always see a list as beign like Maybe - where [] = Nothing
16:01:17 <zzzs> if i just had this data DBlock d = DBlock [d]
16:01:41 <zzzs> it says nothing about a list?
16:02:08 <mauke> [d] is a list of d's
16:02:09 <zzzs> what does the Maybe mean here?
16:02:14 <gwern> well, I'm just poitnig out that there other ways we could write DBlock
16:02:24 <gwern> mixing Maybe and Lit is always a little redundant
16:02:40 <Cale> zzzs: data DBlock d = DBlock [d] says that a DBlock of d's is the data constructor DBlock followed by a list of d's.
16:02:52 <Cale> However, reusing the name DBlock might be confusing
16:03:00 <Cale> It might be less confusing to write:
16:03:16 <Cale> data DBlock d = DB [d], which says that a DBlock of d's is the data constructor DB followed by a list of d's.
16:03:41 <gwern> *and List
16:04:26 * RayNbow is watching a talk in which the paper "Real Programming in Functional Languages" is cited...
16:04:29 <RayNbow> "And in the introduction he says, 'Many people complain about functional programming, because they say it's unnatural. This is ridiculous. Functional programming is a discipline and all disciplines are unnatural. The proper question to ask about a discipline is not whether it's natural but whether it's effective.'"
16:04:32 <Cale> The reason that it's possible to reuse the name is that they are "on opposite sides of the ::", that is, the one on the left of the = sign lives in the world of types, and the one on the right lives in the world of values, so they're entirely separate.
16:05:28 <zzzs> Cale: what about the d on the left of =, and d on the right?
16:05:44 <Cale> They are both (the same) type variable.
16:05:51 <Pegazus> RayNbow: bright guy...
16:06:10 <RayNbow> :)
16:06:18 <RayNbow> the paper in question: http://research.microsoft.com/en-us/um/people/simonpj/papers/other-authors/morris-real-programming.pdf
16:06:55 <RayNbow> ( the talk is less relevant, but for anyone interested... I'm watching http://channel9.msdn.com/shows/Going+Deep/E2E-Erik-Meijer-and-Butler-Lampson-Abstraction-Security-Embodiment )
16:07:23 <Pegazus> I'm watching supernatural... :)
16:07:27 <Cale> zzzs: The syntax is roughly like  data <type constructor name> <type variables> = <case 1> | <case 2> | ...  where each <case> consists of  <name of dataconstructor> <type 1> <type 2> ...  giving the types of the parameters to that data constructor
16:07:51 <Cale> Those types are allowed to contain the type variables on the left of the = sign.
16:08:05 <tnm8> RayNbow: thanks for that
16:08:21 <RayNbow> np :)
16:08:30 <Cale> zzzs: Does that make sense?
16:09:44 <zzzs> Cale: this helps. so the thing on the left with 'data ...' is defining a type where the things on the right are defining constructors
16:09:44 * RayNbow notices the Real Programming in FP paper is 4 years and 13 days older than himself...
16:09:53 <Cale> zzzs: It's perhaps easier to start with simpler examples than that  data DBlock d = DBlock [d] (Maybe (DBlock d)), but this basically says that, for example, a value of type DBlock Integer looks like  DBlock xs next  where xs :: [Integer], and next :: Maybe (DBlock Integer)
16:10:04 <Cale> zzzs: Right.
16:10:17 <zzzs> and it generally a good idea to not use the same name for both the type and the constructor?
16:10:19 <FunctorSalad> RayNbow: paper link is dead for me
16:10:43 <Cale> zzzs: Well, it can be convenient, but also can be confusing to beginners.
16:10:47 <FunctorSalad> (mb microsoft blocks known linux users? :O)
16:11:04 <Cale> zzzs: When there's only one constructor, it's pretty common to give it the same name as the type
16:11:16 <Cale> zzzs: But it's important to realise they're two separate things being defined.
16:11:41 <RayNbow> FunctorSalad: I doubt it
16:11:50 <RayNbow> it's probably some odd routing issue or something
16:12:00 <FunctorSalad> (wasn't being particularly serious ;))
16:12:01 <RayNbow> I was unable to access the MSResearch site for a few months earlier this year
16:12:31 <RayNbow> (and I tried it on 3 different machines running XP, Vista and ArchLinux :p)
16:12:35 <SamB_XP> FunctorSalad: I'm pretty sure there is a substantial portion of the MS staff that is known to use Linux ?
16:12:48 <FunctorSalad> ping: unknown host http://research.microsoft.com
16:13:05 <RayNbow> FunctorSalad: want me to dcc the pdf?
16:13:13 <zzzs> Cale: so in your example, xs next, when next:: Maybe(DBblock Integer), is the DBlock here a type or a constructor?
16:13:20 <FunctorSalad> RayNbow: yes please
16:13:24 <dobblego> I have never been able to research.microsoft.com for whatever reason
16:13:49 <RayNbow> FunctorSalad: does the dcc work?
16:13:55 <Cale> zzzs: it's a type constructor
16:13:55 <RayNbow> ah, it does :)
16:14:02 <Cale> zzzs: (rather than a data constructor)
16:14:09 <FunctorSalad> thanks
16:14:13 <RayNbow> np :)
16:14:26 <Cale> zzzs: It has to be a type constructor, since data constructors aren't allowed on the right hand side of the ::
16:14:54 <zzzs> Cale: understood, though i still need to get over it mentally
16:14:55 <zzzs> ;)
16:16:08 <Cale> (dependent types, which you might hear people talking about around here, are all about letting data constructors appear to the right of the :: (but that's not something we can do in Haskell yet)
16:16:30 <SamB_XP> yay Coq!
16:17:05 <gwern> everyone loves coq
16:17:16 <FunctorSalad> we addicted to coq
16:17:46 <FunctorSalad> +are
16:19:49 * RayNbow is a coq uninitiated
16:19:50 <zzzs> Cale: thanks, another question, do you know any tutorial/paper on how to allocate memory using haskell? i.e. the equalivent of mem-alloc in C
16:20:06 <SamB_XP> FunctorSalad: we must begin the hazing!
16:20:23 <RayNbow> zzzs: why would you want that?
16:20:24 <FunctorSalad> what? :o
16:20:34 <SamB_XP> to initiate RayNbow !
16:20:39 <FunctorSalad> ah
16:21:12 <zzzs> RayNow: need to control how memory are used, for example, writing a cache
16:21:48 <RayNbow> SamB_XP, FunctorSalad: can we wait till I have reduced my pile of unread books? :p
16:21:57 <zzzs> or maybe the haskell/ghc memory allocation is efficient enough so that i don't have to worry about it?
16:22:46 <RayNbow> zzzs: generally, it depends on how strict/lazy your algorithms are
16:22:50 <blackh> zzzs: Ooooom.... You must ... let go ... of your desire to allocate memory...
16:23:03 <benmachine> OOM
16:23:22 <SamB_XP> that's a bad thing
16:23:28 <SamB_XP> that means linux will kill things!
16:23:31 <Cale> zzzs: You'll want to look at the FFI documentation.
16:23:33 <RayNbow> benmachine: I hate OOM... I always get the urge to punch my machine for lying to me :p
16:23:39 <blackh> zzzs: You will only have to free it again, and that leads to suffering.
16:23:40 <sioraiocht> out of mana?
16:23:46 <SamB_XP> lol
16:24:00 <merus> lol
16:24:03 <Cale> zzzs: Generally if you're just writing Haskell programs, you don't manage your own memory. It's only when interfacing with C programs that it's required.
16:28:51 <roconnor> Cale: GADTs are a form of dependent types.
16:29:02 <roconnor> or allow a form of dependent types
16:29:20 <SamB_XP> roconnor: real dependant types are dependant on values!
16:29:33 <roconnor> Probably the most important property of dependently typed programming is that branches in a case statement can have different types.
16:30:29 <FunctorSalad> so we get the problems without the convenience of having just one level? ;D
16:31:40 <roconnor> FunctorSalad: "problems"
16:32:15 <Saizan> btw, is there a simple example of how dependent pattern matching is more powerful than just having induction principles for inductive families?
16:32:17 <FunctorSalad> roconnor: hmm isn't type index refinement in match branches one of the most tricky parts?
16:32:35 <roconnor> FunctorSalad: wait, problems for programmers or problems for implementors?
16:32:55 <FunctorSalad> roconnor: good question
16:33:48 <mmorrow> can't you just walk around the graph formed by control-flow and make check whether a particular type flows somewhere it shouldn't?
16:34:12 <FunctorSalad> "<roconnor> ... is that branches in a case statement can have different types." <-- did you mean the return type there or this type index phenomenon?
16:34:37 <mmorrow> (i've never tried to implement anything related to it, but everytime i read that case is the hard part i think about that, and it seems (relatively) not extremely difficult)
16:34:55 <FunctorSalad> (I admit I'm still very confused about dependent case statements :( )
16:35:20 <mmorrow> FunctorSalad: each different arm of the case statement can have a different type than the others
16:35:37 <mmorrow> and the type's determined by what you matched in the pattern
16:35:37 <roconnor> FunctorSalad: Well, each branch of the case statement can generally have a slightly different type, and the type of the whole statements usually gets some more general type than each branch does.
16:35:38 <FunctorSalad> mmorrow: return type?
16:36:01 <benmachine> :t return
16:36:02 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:36:15 <mmorrow> FunctorSalad: yes, there is no longer a "return type" (singular) to speak of, but it's indexed by the value you matched
16:36:38 <FunctorSalad> so is this orthogonal to the issue that if I match on a vector of length 4, I'd like to exclude the Nil case?
16:36:45 * roconnor assumed by return type FunctorSalad was refering to the type of the entire case statement.
16:36:55 * roconnor was translating from Coq speak
16:37:05 <FunctorSalad> roconnor: of the branch
16:37:29 <mmorrow> separate of that though, so clearly a case stmt is just an n-way split in control-flow, so if you build the graph for the entire program (the part of which you're checking currently), then you can see what types flow to where
16:37:32 <roconnor> FunctorSalad: the reason you can exclude the Nil case is because different branches can have different types.
16:37:54 <mmorrow> or at least, that's what i'd imagine you could do
16:38:11 <roconnor> FunctorSalad: in Haskell you can exclude as many case branches as you want, even without GADTs
16:38:29 <roconnor> FunctorSalad: there is no requirement that patterns cover all cases
16:38:45 <FunctorSalad> true
16:38:49 <Saizan> after you've pattern matched 4 against the length, the "result type" there becomes "Vec a 4 -> ..." so you can exclude Nil
16:39:06 <SamB_XP> this is why Haskell makes a lousy proof language
16:39:41 <roconnor> FunctorSalad: I'm not sure.  With GADTs, if I try to match on a constructor that is impossible to have, will GHC complain?
16:40:06 <Saizan> i think so
16:40:08 <FunctorSalad> Saizan: but... the whole match expression isn't even a function, is it?
16:40:28 <mmorrow> (case n of 0 -> f (Just "asdf"); 1 -> g (Node () [Node () []]); 2 -> h (9::Int); _ -> explode n)
16:40:44 <mmorrow> err, bad example i suppose
16:40:47 <FunctorSalad> from the POV of the match, the thing being matched is just something in context I thought
16:40:51 <mmorrow> (case n of 0 -> (Just "asdf"); 1 -> (Node () [Node () []]); 2 -> (9::Int); _ -> explode n)
16:41:15 <Saizan> FunctorSalad: i was currying the match, kind of
16:41:20 <mmorrow> hmm, yeah so you'd also have to take into account in the graph values too
16:41:47 <roconnor> mmorrow: Just isn't a example if a constructor of a GADT that allows this
16:42:02 <mmorrow> roconnor: i'm only using haskell to demonstrate
16:42:43 <roconnor> data DamageType priority where
16:42:50 <stroan> Don't suppose anyone can recommend a book on type theory?
16:42:53 <roconnor>  Drone :: DamageType DronePriority
16:42:55 <roconnor>  Phaser :: (FiringArc -> Bool) -> DamageType PhaserPriority
16:43:09 <copumpkin> stroan: TAPL?
16:43:12 <jmcarthur> stroan: TAPL
16:43:23 <jmcarthur> == types and programming languages
16:43:29 <roconnor> stroan: TTFP
16:43:49 <skorpan> CPPE is nice as well
16:43:51 <Saizan> you don't find much about this in TAPL
16:43:57 <skorpan> i wouldn't recommend PABB though
16:44:04 <SamB_XP> coq'art ?
16:44:13 <stroan> coq'art I tried to get a hold of
16:44:16 <stroan> but it's rare
16:44:28 <SamB_XP> oh, it's out of print is it ?
16:44:32 <stroan> I think so
16:44:38 <stroan> and it's not in my college library either
16:44:43 <stroan> which really surprised me
16:46:00 <stroan> skorpan: what does CPPE stand for?
16:46:10 <skorpan> sorry i was trolling
16:46:27 <FunctorSalad> quite successful ;)
16:46:39 <FunctorSalad> I was already considering a minor rant about FLAs
16:46:50 <stroan> Heh. No bother.
16:46:57 <SamB_XP> well, I say TaPL
16:47:19 <RayNbow> @where TTFP
16:47:19 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
16:48:13 <beutdeuce> how can i read each line from a file?
16:48:42 <Saizan> fmap lines (readFile file)
16:48:45 <SamB_XP> stroan: astrolabe says he got coq'art new from amazon.co.uk a couple months back ...
16:49:03 <beutdeuce> Saizan: thnx
16:50:05 <beutdeuce> Saizan: i get "\r
16:50:10 <beutdeuce> how can i make sure that doesnt show
16:50:16 <stroan> SamB_XP: searched again, and it's there first hit
16:50:20 <stroan> my mistake indded
16:50:22 <stroan> indeed*
16:50:30 <stroan> cheers
16:51:35 <Saizan> beutdeuce: i think you'd have to filter for it explicitly
16:52:02 <FunctorSalad> beutdeuce: dos2unix the file ;)
16:52:45 <beutdeuce> is there a functor filter?
16:53:15 <Alpounet> something than does filtering over functors ?
16:53:24 <FunctorSalad> I heard support for newline styles is coming in ghc 6.12
16:54:57 <Saizan> fmap (lines . filter (/='\r'))
16:57:42 <beutdeuce> Saizan: how would it look overall?
16:59:58 <Saizan> ?type \file -> fmap (lines . filter (/='\r')) (readFile file)
16:59:59 <lambdabot> FilePath -> IO [String]
17:00:17 <Saizan> not extremely efficient i guess
17:01:10 <beutdeuce> thnx
17:10:57 <beutdeuce> if i have ["1 127"], how can i make it [["1"],["1,2,7"] ?
17:11:10 <beutdeuce> [["1"],["1,2,7"]]
17:11:45 <roconnor> @hackage split
17:11:45 <lambdabot> http://hackage.haskell.org/package/split
17:11:59 <roconnor> oh wait
17:13:10 <roconnor> beutdeuce: what about ["1 127 3"] ?
17:13:28 <beutdeuce> [[1],[1,2,7],[3]]
17:13:30 <roconnor> beutdeuce: what about ["1 127 3","4 56 7"] ?
17:14:31 <roconnor> > concatMap (intercalate ',' . words) ["1 127 3"]
17:14:32 <lambdabot>   Couldn't match expected type `[a]'
17:14:32 <lambdabot>         against inferred type `GHC.Types...
17:15:14 <roconnor> > concatMap (intersperse ',' . words) ["1 127 3"]
17:15:15 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:15:15 <lambdabot>         against inferred type...
17:15:16 <beutdeuce> [[[1],[1,2,7],[3]],[4],[5,6],[7]]
17:15:35 <roconnor> beutdeuce: that is inconsistent with your previous examples
17:15:45 <SamB_XP> > concatMap (intersperse "," . words) ["1 127 3"]
17:15:46 <lambdabot>   ["1",",","127",",","3"]
17:16:03 <beutdeuce> hmm, doesnt seem right
17:16:07 <SamB_XP> indeed!
17:16:14 <roconnor> > map (words) ["1 127 3"]
17:16:15 <lambdabot>   [["1","127","3"]]
17:16:28 <SamB_XP> > concatMap (intercalate "," . words) ["1 127 3"]
17:16:29 <lambdabot>   "1,127,3"
17:16:43 <roconnor> > map (map (intersperse ',') . words) ["1 127 3"]
17:16:44 <lambdabot>   [["1","1,2,7","3"]]
17:16:54 <SamB_XP> > concatMap (intercalate "," . words) ["1 127 3", "2 255 6"]
17:16:54 <lambdabot>   "1,127,32,255,6"
17:16:55 <roconnor> > map (map (intersperse ',') . words) ["1 127 3", "4 56 7"]
17:16:56 <lambdabot>   [["1","1,2,7","3"],["4","5,6","7"]]
17:17:05 <beutdeuce> nice
17:17:09 <beutdeuce> u guys rock
17:17:36 <SamB_XP> > (map . map) (intercalate "," . words) ["1 127 3", "2 255 6"]
17:17:37 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:17:37 <lambdabot>         against inferred ty...
17:17:40 <beutdeuce> inot in scope intersperce?
17:17:44 <beutdeuce> what library do i need
17:17:52 <SamB_XP> > map (intercalate "," . words) ["1 127 3", "2 255 6"]
17:17:53 <lambdabot>   ["1,127,3","2,255,6"]
17:17:58 <roconnor> @index intersperse
17:17:58 <lambdabot> Data.List
17:18:15 <roconnor> beutdeuce: might help to spell it right.
17:18:17 <roconnor> :)
17:18:23 <beutdeuce> :)
17:18:24 <roconnor> "right"
17:18:32 <SamB_XP> roconnor: it depends
17:18:38 <SamB_XP> is he making a lambdacat?
17:18:56 <beutdeuce> eh, could match type against IO String()
17:19:06 <beutdeuce> whats cause i need to run it against fmap lines (readFile "input.in")
17:19:28 <SamB_XP> beutdeuce: use <-
17:19:54 <beutdeuce> where?
17:20:16 <roconnor> do { blag <- fmap lines (readFile "input.in"); let blarg = map (map (intersperse ',') . words) blag; <rest of your code here> }
17:20:44 <roconnor> <rest of your code here>  = print blag; for example
17:20:44 <sshc> @undo do { blag <- fmap lines (readFile "input.in"); let blarg = map (map (intersperse ',') . words) blag; }
17:20:44 <lambdabot>  Parse error at "}" (column 102)
17:21:03 <sshc> @undo do { blag <- fmap lines (readFile "input.in"); let blarg = map (map (intersperse ',') . words) blag }
17:21:04 <lambdabot>  Parse error at "}" (column 101)
17:21:13 <roconnor> sshc: you need something at <rest of your code here>
17:21:16 <roconnor> at least a return ()
17:21:26 <sshc> @undo do { blag <- fmap lines (readFile "input.in"); let blarg = map (map (intersperse ',') . words) blag; return () }
17:21:27 <lambdabot>  Parse error at "}" (column 112)
17:21:40 <roconnor> :/
17:21:40 <sshc> @undo do { blag <- fmap lines (readFile "input.in"); let blarg = map (map (intersperse ',') . words) blag; return (); }
17:21:41 <lambdabot>  Parse error at ";" (column 111)
17:21:50 <Saizan> brackets for let
17:21:55 <roconnor> oh right
17:22:03 <Saizan> @undo do { blag <- fmap lines (readFile "input.in"); let {blarg = map (map (intersperse ',') . words) blag}; return () }
17:22:03 <lambdabot> fmap lines (readFile "input.in") >>= \ blag -> let { blarg = map (map (intersperse ',') . words) blag} in return ()
17:22:04 <aavogt> @undo do let foo = 1; return foo
17:22:04 <lambdabot>  Parse error at end of input
17:22:12 <roconnor> @undo do { blag <- fmap lines (readFile "input.in"); let {blarg = map (map (intersperse ',') . words) blag}; return (); }
17:22:13 <lambdabot> fmap lines (readFile "input.in") >>= \ blag -> let { blarg = map (map (intersperse ',') . words) blag} in return ()
17:22:35 <sshc> oh
17:22:42 <roconnor> parsing is much easier with multilines and indentation
17:22:59 <sshc> not with lambdabot :P
17:23:00 <roconnor> sshc: it got confused where the scope of let ended.
17:23:19 <SamB_XP> @undo do { let foo = 1; return foo }
17:23:19 <lambdabot>  Parse error at "}" (column 30)
17:23:26 <SamB_XP> @undo do { let { foo = 1 }; return foo }
17:23:27 <lambdabot> let { foo = 1} in return foo
17:23:52 <beutdeuce> why is my indentation wrong: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9525#a9525
17:24:05 <SamB_XP> sshc: this is why some people are liking to use the {;} syntax in their papers
17:24:18 <SamB_XP> though I don't think they usually use it for most of their lets ...
17:24:25 <SamB_XP> if lets they have
17:24:31 <roconnor> beutdeuce: normally I'd put the revised right after the let
17:24:45 <roconnor> beutdeuce: also nix the semicolon
17:24:52 <roconnor> since you are using indentation parsing
17:25:01 <roconnor> indentation layout I mean
17:25:02 <beutdeuce> still indent error
17:25:09 <roconnor> oh
17:25:18 <roconnor> well do has to be part of a function or something
17:25:25 <roconnor> main = do
17:25:25 <beutdeuce> k
17:25:27 <beutdeuce> yep
17:29:12 <beutdeuce> lets say i have ["1","1,2,7"]. The answer i want is [128], which u get by zipping both elements with addition. The thing is that i dont want to zip 1 with 127 to get 227, i want to padd 1 with two 00's, so it would correctly do [0,0,1] + [1,2,7] to get [128].
17:30:25 <roconnor> beutdeuce: that's a little tricky to program. Sadly there is no zipwhileextending function.
17:30:50 <roconnor> beutdeuce: what if you have ["9", "9,9,9"] ?
17:31:39 <jfoutz> (\ls -> let len = maximum (map length ls); pad l = take len $ l ++ repeat ' ' in map pad ls) ["a","abcd","d"]
17:31:41 <beutdeuce> what i want it to do is [0,0,9] + [9,9,9] then to yield [9,1,8]. But that is very hacky.
17:31:47 <jfoutz> > (\ls -> let len = maximum (map length ls); pad l = take len $ l ++ repeat ' ' in map pad ls) ["a","abcd","d"]
17:31:48 <lambdabot>   ["a   ","abcd","d   "]
17:32:02 <jfoutz> throw in some reverses, and you're done. bam.
17:32:22 <roconnor> beutdeuce: first of all I would get rid of your commas that you put in
17:32:31 <roconnor> they aren't helping you at all
17:33:01 <roconnor> > map (read :: String -> Int) "999"
17:33:02 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:33:02 <lambdabot>         against inferred ty...
17:33:17 <roconnor> > map (readDigit) "999"
17:33:18 <lambdabot>   Not in scope: `readDigit'
17:33:22 <roconnor> @hoogle digit
17:33:22 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
17:33:22 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
17:33:22 <lambdabot> Data.Char digitToInt :: Char -> Int
17:33:27 <beutdeuce> k, so then i currently have something like ["1 127"]
17:33:33 <roconnor> > map (digitToIng) "999"
17:33:34 <lambdabot>   Not in scope: `digitToIng'
17:33:36 <roconnor> > map (digitToInt) "999"
17:33:37 <lambdabot>   [9,9,9]
17:34:08 <roconnor> > map (map (digitToInt) . words) ["1 127"]
17:34:09 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:34:09 <lambdabot>         against inferred type...
17:34:31 <roconnor> > map (words) ["1 127"]
17:34:32 <lambdabot>   [["1","127"]]
17:34:46 <roconnor> > map (map (map (digitToInt)) . words) ["1 127"]
17:34:47 <lambdabot>   [[[1],[1,2,7]]]
17:35:07 <roconnor> heh, this is getting a little confusing to do in a oneliner
17:36:18 <Alpounet> then put (maxlen - (len sublist)), where sublist are not-biggest sublists
17:36:41 <jfoutz> > map (\l -> sum $ map (read :: String-> Int) $ words l) [ "1 127"]
17:36:42 <lambdabot>   [128]
17:36:45 <Alpounet> then put (maxlen - (len sublist)) zeros at the head of each sublist [...]
17:36:58 <Alpounet> oh, yeah :-p
17:37:03 * jfoutz grins
17:37:16 <beutdeuce> damn it, how did u do that :?
17:37:18 <roconnor> input <- fmap lines (readFile "input.in");
17:37:24 <Alpounet> beutdeuce, sum
17:37:26 <Alpounet> @type sum
17:37:27 <lambdabot> forall a. (Num a) => [a] -> a
17:37:33 <jfoutz> i've been thinking about padding strings a lot lately.
17:37:41 <Alpounet> heh
17:37:47 <jfoutz> which has helped my list fu
17:37:49 <Alpounet> I'm off. Gn.
17:39:49 <beutdeuce> hm, i get -2 for the last answer
17:40:15 <jfoutz> oh. did i just cheat on your homework? damn.
17:40:32 <beutdeuce> no?
17:40:44 <jfoutz> heh.
17:40:59 <beutdeuce> the asnwers arent right
17:41:26 <jfoutz> i think it's time for me to get food. you'll get it. good luck. :)
17:43:06 <byorgey> preflex: seen CosmicRay
17:43:08 <preflex>  CosmicRay was last seen on #haskell 32 days, 3 hours, 22 minutes and 42 seconds ago, saying: that is not a bad thing
17:43:15 <byorgey> yikes.
17:47:01 <sshc> byorgey: is that a bad thing?
17:47:57 <byorgey> sshc: I don't know, 32 days is just a long time =)
17:54:10 * bcw wonders if this channel's /topic is actually set by a haskell bot (with "show list" or sth.) or if that's just someone pretending to write like haskell would
17:54:46 <Saizan> @help snoc-topic
17:54:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:54:58 <Saizan> @help topic
17:54:58 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
17:55:11 <Baughn> bcw: Yes.
17:55:23 <bcw> i see, thanks.
18:09:46 <babyGreeve> Who goeth a-borrowing goeth a-sorrowing.
18:09:46 <babyGreeve>     -- Thomas Tusser
18:12:20 <ivanm> wtf? someone joins the channel just to quote at us?
18:14:52 <bcw> maybe it's Thomas Tusser...
18:16:23 <ivanm> heh
18:53:35 <jmillikin> Is there any way to see code coverage of .lhs source? RWH suggests HPC for coverage, but that doesn't seem to work with .lhs
18:55:19 <SamB_XP> jmillikin: I suppose you could unlit it first ...
18:55:51 <jmillikin> Is there an easy way to do that automatically? I assumed that's what GHC is doing behind the scenes already.
18:56:19 <str8outthatraile> Has anyone here installed HDBC on linux?  I'm using cabal but I get an error when building the package convertible-1.0.5.
18:56:23 <SamB_XP> I honestly have no clue how HPC works
18:56:43 <dolio> Magic.
18:57:11 <SamB_XP> dolio: apparantly it's only a 3rd-level spell
18:57:16 <dolio> :)
18:57:17 <dcoutts> SamB_XP: it basically just sticks in a really cheap trace into every expression in the whole program
18:57:34 <c_wraith> str8outthatraile: Is it an overlapping instances issue?
18:58:05 <SamB_XP> dcoutts: how does that make it fail on .lhs ?
18:58:13 <dcoutts> str8outthatraile: looks like it needs time-1.1.4 but it does not say so
18:58:24 <dolio> Maybe it doesn't know lhs syntax.
18:58:25 <str8outthatraile> the error is "No instance for (Typeable POSIXTime)"
18:58:37 <dcoutts> str8outthatraile: yes exactly
18:58:50 <dcoutts> SamB_XP: because it gets the mapping back to the original source wrong for .lhs
18:58:57 <str8outthatraile> gotcha, thanks
18:59:21 <dcoutts> str8outthatraile: so the workaround is to cabal install convertible-1.0.5 'time >= 1.1.4'
18:59:36 <dcoutts> SamB_XP: there's nothing special about why the bug for .lhs files
19:00:06 <str8outthatraile> thanks, it built for me now
19:00:31 <c_wraith> dcoutts:  that's probably my fault.  I reported an overlapping instances bug with older versions of convertible and 1.1.4 of time.  I think he picked a suboptimal way of fixing it. :)
19:00:52 <dcoutts> c_wraith: :-)
19:01:08 <dcoutts> c_wraith: it's ok if the deps are declared ok
19:01:23 <dcoutts> c_wraith: of course it's not always obvious
19:01:55 <dcoutts> which many people point out as a flaw in the whole system
19:02:34 <c_wraith> indeed.  I've had my share of 'crap, need to recompile that with different dependencies' moments
19:04:05 <dcoutts> there are several improvements we could make there, but not so much free time to do them in :-(
19:09:50 <pakito> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
19:15:37 <roconnor> I keep coming back to #haskell and thinking there is an online boxing game written in haskell
19:15:45 <roconnor> my hopes keep getting dashed
19:17:15 <Makoryu> roconnor: Now there's a hilarious project if ever I heard of one
19:19:38 <SamB_XP> roconnor: please -- you *know* online golf is more our style!
19:19:43 <dons> online boxing eh?
19:22:08 * inimino takes a swing at dons
19:22:17 <Makoryu> Maybe it could be in contrast to online unboxing, rather than offline boxing...
19:22:56 <mmorrow> gwern: finally upgraded gitit
19:23:18 <SamB_XP> mmorrow: did it eated your data?
19:23:29 <mmorrow> SamB_XP: noes, thankfully
19:23:38 <roconnor> Makoryu: :D
19:24:00 <roconnor> Haskell online boxing game ... less fun than you think.
19:24:23 <mmorrow> SamB_XP: oh i hed yoar datas, but i eated it
19:24:24 <roconnor> you have a double and a polymorphic function to apply to it ...
19:24:31 <roconnor> what do you do
19:25:16 <mmorrow> is this like mike tyson's punchout?
19:25:17 <SamB_XP> roconnor: you throw away the double, replace it with a CReal, and go on your merry way?
19:25:32 <mmorrow> knockout?
19:25:42 <SamB_XP> mmorrow: punchout
19:25:48 <SamB_XP> not that I've ever played
19:25:54 <roconnor> mmorrow: no, it's about applying data to polymorphic functions. :/
19:26:10 <roconnor> presumably
19:26:20 <mmorrow> i love how wikipedia is 9/10 times the first result for pretty much anything http://en.wikipedia.org/wiki/Mike_Tyson%27s_Punch-Out!!
19:26:41 <mmorrow> SamB_XP: it was a good game
19:26:58 <araujo> Punch Out , it seems a nice name for a boxing paper
19:27:34 <roconnor> :)
19:33:07 <SamB_XP> mmorrow: well, somehow it never found it's way into our collection
19:33:23 <SamB_XP> and our NESen are not currently working :-(
19:34:15 <SamB_XP> haven't worked in years, really
19:34:25 <SamB_XP> it's really quite sad
19:34:38 <SamB_XP> 'cause some of those games are just so awesome!
19:40:21 <cygnus> If a C function takes an argument of type void*, how do I represent that in the type of the function when I import it into Haskell?  Ptr .. ?
19:41:04 <SamB_XP> cygnus: you could do Ptr (), or Ptr a ...
19:41:21 <inimino> Ptr Maybe Anything
19:41:33 <SamB_XP> it doesn't really matter all that much as long as you don't try to dereference it or offset it ;-)
19:41:43 <cygnus> Alright. :)
19:42:01 <cygnus> Conveniently this is something I always plan to use with nullPtr, so... :)
19:42:05 <lorph> has there been any improvement on the hash table problem?
19:42:35 <copumpkin> lorph: nope
19:43:16 <SamB_XP> lorph: there's been nothing for years -- why would there have been in the past few weeks ?
19:45:11 <blackdog> lorph: what do you need a hash table for?
19:45:27 <copumpkin> blackdog: woof!
19:45:39 <blackdog> g'day mate
19:45:41 <blackdog> woof?
19:45:59 <copumpkin> blackDOG
19:46:08 * blackdog slaps head
19:46:09 <Axman6> has anyone managed to get the haskell platform compiled on OpenSolaris? i can't seem to find the stuff necessary for GLUT (specifically the headers)
19:46:18 <blackdog> which is difficult with only a paw.
19:46:31 <blackdog> lorph: it's always going to be tricky modelling an updateable-in-place data structure in haskell unless you want to fiddle with the ST monad
19:46:58 <copumpkin> well it's just that even our IO hashtable is inefficient
19:47:05 <copumpkin> because of some trouble with mutable array GC
19:47:06 <SamB_XP> blackdog: you mean, "what do you *think* you need a hashtable for?"
19:47:08 <roconnor> isn't Data.Map the solution to the hash table problem?
19:47:22 <blackdog> SamB_XP: I don't like to prejudice inquiry :)
19:47:22 <copumpkin> roconnor: usually
19:47:39 <blackdog> and one of my apps _was_ too slow/memory wasteful on Data.Map
19:47:54 <SamB_XP> blackdog: well, how about, "what do you want a hashtable for?"
19:47:55 <copumpkin> you accumulated it strictly?
19:48:02 <blackdog> thankfully my keys could be considered a fixed set, which lets you cheat and just construct it once.
19:48:19 <blackdog> yeah. it was just a massive data set.
19:48:25 <blackdog> linguistic app
19:48:30 <copumpkin> ah
19:49:53 <blackdog> SamB_XP: isn't that what i said? oh, s/want/need/
19:50:22 <SamB_XP> that way you *really* don't prejudice the inquiry
19:50:31 <SamB_XP> see?
19:51:06 <SamB_XP> 'kay, I'm heading to bed...
19:51:32 <roconnor> shouldn't Data.Map take more or less the same amount of space as a hash table?
19:52:14 <blackdog> roconnor: it's nlogn versus n, isn't it?
19:52:21 <blackdog> assuming a perfect hashing function
19:52:39 <dolio> Heh.
19:53:13 <SamB_XP> dolio: those *are* possible if you know the set of keys
19:54:01 <mmorrow> IntMap would beat a hash table for union/intersection/expandability-without-losing-performance, whereas a hashtable would win on lookup/insert/delete (assuming the chains don't get long)
19:54:30 <copumpkin> has anyone looked into implementing clojure's persistent hashtable in haskell?
19:54:39 <copumpkin> I haven't looked into how they did it
19:54:39 <SamB_XP> mmorrow: that's assuming the constant factors for the mutation are reasonable
19:55:13 <mmorrow> the underlying structure of IntMap is actually one of the fastest for union of all the "standard" map structures (red-black, avl, etc)
19:55:33 <copumpkin> well tries are very simple
19:55:36 <mmorrow> SamB_XP: yeah, i'm assuming we're in C or whatever
19:55:46 <SamB_XP> I don't even think mutation of an array in GHC *has* constant cost -- I think it's more like O(n) every garbage collection + O(1) per access before that ...
19:56:18 <dolio> For boxed arrays, yes.
19:56:30 <mmorrow> and not-mutable arrays are pretty useless outside their one sweet spot
19:56:58 <mmorrow> but yeah, the GC thing makes (gc-followed) ptr arrays sucky
19:57:08 <c_wraith> an immutable array is fine for a write-once, read-many lookup table
19:57:14 <gwern> mmorrow: you using any of the new gitit features?
19:57:16 <dolio> Well, O(n) for garbage collections where the array is dirty.
19:57:18 <mmorrow> c_wraith: right, the sweet spot
19:57:30 <mmorrow> gwern: haven't yet, but i'm checking it out
19:57:40 <c_wraith> That was the use case blackdog has though. :)
19:57:45 <mmorrow> gwern: it's pretty much a completely new app from the last version i have
19:57:56 <gwern> (rss is pretty easy to conifugre, but I dunno what use it is for a local wiki)
19:58:02 <mmorrow> c_wraith: but not the one lorph has
19:58:05 <gwern> mmorrow: yeah, me and john did a lot of work over the summer
19:58:27 <mmorrow> gwern: cool, it looks nice
19:58:27 <c_wraith> ah.  I started paying attention too late to see that part of the conversation
19:58:35 <gwern> mmorrow: be sure to check out latex math now
19:58:40 <gwern> no more jsmath etc
19:58:43 <mmorrow> gwern: ooh
19:58:48 <blackdog> c_wraith: it's ok, i faded out as you faded in. we've got it covered.
19:58:54 <gwern> now it renders as mathml
20:00:30 <roconnor> blackdog: nlogn vs (optimistic n) in the number of nodes, but how big is the data?
20:00:57 <roconnor> oh
20:01:09 <roconnor> maybe it really is n nodes
20:03:50 <blackdog> roconnor: up to 130gb.
20:03:59 <blackdog> obviously i can't fit that all in memory even with a hashtable
20:04:16 <blackdog> but the more efficient my data structures, the more i can get in
20:04:21 <copumpkin> berkeley db!
20:04:56 <blackdog> hm, didn't actually think of that.
20:05:58 <jfoutz> tokyo cabinet!
20:07:31 <copumpkin> http://hackage.haskell.org/packages/archive/berkeleydb/2008.10.31/doc/html/Data-BerkeleyDB.html
20:07:41 <copumpkin> there, almost identical to Data.Map
20:08:10 <copumpkin> it's even pure :P
20:09:34 <mmorrow> if the section "Write Barrier" in here describes (the particular way they chose to do) what ghc's GC would need to do to make mutable arrays of gc-followed ptrs more efficient http://moonpatio.com/repos/gc-intf.txt
20:10:04 <mmorrow> (that .txt is from the code to (couldn't find an online link: http://orp.sourceforge.net/)
20:11:00 <dolio> I think it's pretty well established that they could increase performance by marking blocks of the array dirty, rather than the whole thing.
20:11:05 <dolio> Someone just has to do it.
20:11:13 * copumpkin touches the tip of his nose
20:11:21 <ivanm> dolio: well, go on!
20:13:12 <Axman6> urgh! why is the haskell platform such a bitch on OpenSolaris?
20:13:25 <ivanm> Axman6: because Sun wants you to use Java!
20:14:19 <Axman6> the main problem's GLUT
20:14:41 <jfoutz> oh. glut sucks everywhere but linux.
20:15:16 <mmorrow> dolio: right, there're nontrivial design decisions to be made there too
20:15:52 <mmorrow> (and that .txt gives a pretty thorough overview of theirs)
20:19:56 <jmcarthur> i thought it would be a cool experiment to try mocking up a simple game with CHP. it's pretty cool except for all the channel acrobatics. doesn't stay out of the way like FRP does
20:21:29 <mmorrow> this is where all the ghc talk about it is http://hackage.haskell.org/trac/ghc/ticket/650
20:21:37 <jmcarthur> it's cool that you can update local state with recursion like you do in erlang
20:22:03 <jmcarthur> which is nothing unique to CHP in haskell i guess, but it feels pretty nice at least
20:22:23 <djahandarie> CHP is cool
20:23:16 <Axman6> oh ffs! frigging OpenGL!
20:23:42 <djahandarie> Axman6, yes, the root of all our problems!
20:24:46 <Axman6> i could get the haskell platform installed if it weren't for OpenGL
20:24:53 <ivanm> and glut?
20:25:05 <Axman6> i installed freeglut and that seems to be ok
20:25:13 <ivanm> Axman6: any particular reason for installing all of the platform?
20:25:31 <ivanm> I mean, do you actually _want_ the opengl libs?
20:25:39 <mmorrow> i love how the default selection for the "Difficulty" field on the ghc wiki is "Moderate (1 day)", and no one ever bothers to change it (mostly) :)
20:25:40 <Axman6> mainly cabal-install
20:25:45 <Axman6> config.status: creating include/HsOpenGL.h
20:25:45 <Axman6> config.status: include/HsOpenGL.h is unchanged
20:25:45 <Axman6> Setup.hs: Missing dependency on a foreign library:
20:25:45 <Axman6> * Missing header file: HsOpenGL.h
20:25:48 <Axman6> >_<
20:25:52 <Axman6> wtf is that
20:25:55 <ivanm> mmorrow: heh
20:26:01 <ivanm> Axman6: :o
20:26:08 <ivanm> I don't recall cabal-install needing opengl...
20:26:13 <ivanm> and don't see why it would need it :s
20:26:21 <Axman6> it ndoesn't, but the platform does, and i want the platform
20:26:30 <ivanm> why?
20:26:38 <Axman6> because i do...
20:27:04 <Axman6> installing everything by hand (expecially cabal-install) is such a pain in the arse
20:27:16 <ivanm> yes...
20:27:21 <ivanm> but do _you_ need the entire platform?
20:27:40 <Axman6> i would like it
20:28:10 <aavogt> cabal-install has a script to bootstrap itself
20:28:29 <Axman6> it does?
20:28:32 <Axman6> hmm
20:28:56 <jfoutz> it grabs 3 or 4 packages, and builds them.
20:30:58 <Axman6> oh well, the platform comes with all the deps cabal-install needs
20:32:50 <aavogt> also editline?
20:33:19 <blackh> Style gurus - What's the tidiest way to write "fmap (fmap (fmap (fmap mapToIdx))) broken" ?
20:33:30 <blackh> i.e. lifting something deep into a structure
20:33:39 <mmorrow> , ppDoc <$> fmaps 4
20:33:41 <lunabot>  fmap . (fmap . (fmap . fmap))
20:33:59 <mmorrow> @type (fmap . fmap . fmap . fmap)
20:34:00 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
20:34:26 <mmorrow> , (fmap . fmap . fmap . fmap) (*2) [[[[42]]]]
20:34:27 <lunabot>  [[[[84]]]]
20:34:27 <ivanm> aavogt: editline isn't needed, depending on the version of ghc
20:34:32 <ivanm> oh, and if you've patched it or not
20:34:52 <aavogt> good to hear
20:35:08 <blackh> how about let fmap4 = fmap . fmap . fmap . fmap in mapToIdx `fmap4` broken - I quite like that
20:35:18 <jmcarthur> fmap (fmap (fmap (fmap mapToIdx))) = fmap $ fmap $ fmap $ fmap mapToIdx = fmap $ fmap $ fmap $ fmap $ mapToIdx = fmap . fmap . fmap . fmap $ mapToIdx = (fmap.fmap.fmap.fmap) mapToIdx
20:35:45 <mmorrow> , ppDoc <$> fmap 2000
20:35:46 <lunabot>  luna: No instance for (GHC.Show.Show
20:35:47 <mmorrow> , ppDoc <$> fmaps 2000
20:35:50 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (f...
20:35:51 <jmcarthur> oh i missed the broken part, but i think the end result works
20:36:25 <blackh> Thanks kindly
20:36:27 <jmcarthur> blackh: do you know about semantic editor combinators?
20:36:44 <blackh> jmcarthur: No - do tell
20:36:45 <mmorrow> blackh: i like the fmaps interspersed with (.)s way myself
20:36:57 <jmcarthur> blackh: http://conal.net/blog/posts/semantic-editor-combinators/
20:37:13 <jmcarthur> blackh: SECs are the reason i like the (fmap.fmap.fmap.fmap) version
20:38:10 <blackh> I think "mapToIdx `fmap . fmap . fmap . fmap` broken" is allowed now, but I can't use 6.12
20:38:39 <blackh> jmcarthur: Thanks - will read
20:39:12 <aavogt> blackh: so with that, haskell can look more like sh?
20:42:34 <Makoryu> Seriously? We have infix expressions now?
20:43:17 <aavogt> blackh: you have a link to describe it?
20:44:23 <Makoryu> How wacky can it get? Can we do fmap `(fmap fmap `fmap` fmap fmap)` fmap?
20:44:36 <tommd>  No, wacky if "fix error"
20:44:40 <tommd> s/if/is/
20:45:05 <Makoryu> :t fix error
20:45:05 <lambdabot> [Char]
20:45:10 <Makoryu> > fix error
20:45:11 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
20:45:16 <jfoutz> hehehe
20:45:25 <copumpkin> > fix f
20:45:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:45:26 <lambdabot>    `SimpleReflect.FromExpr ...
20:45:30 <copumpkin> > fix f :: Expr
20:45:31 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
20:45:34 <blackh> aavogt: You mean `complex stuff` being allowed now?
20:45:38 <mmorrow> , (fix . fix) (join `id` fmap)
20:45:42 <lunabot>  Killed.
20:45:44 <aavogt> blackh: yes
20:46:11 <mmorrow> @type [undefined, (fix . fix) (join `id` fmap)]
20:46:11 <lambdabot> forall b. [b]
20:47:28 <mmorrow> , fix ((h::Expr->Expr) . (g::Expr->Expr) . f)
20:47:30 <lunabot>  h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h...
20:47:35 <mle> > fix error
20:47:36 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
20:49:04 <blackh> aavogt: I can't find it.
20:49:30 <aavogt> did it really happen?
20:49:44 <str8outthatraile> Is there a way to enable profiling in a library that is installed with cabal?
20:49:52 <aavogt> anybody on HEAD that can check?
20:50:26 <aavogt> str8outthatraile: in ~/.cabal/config there is a commented entry: -- library-profiling: False
20:50:44 <aavogt> uncomment it, and set it to True
20:50:57 <str8outthatraile> thanks, I looked there but my tired eyes missed it
20:51:19 <aavogt> no problem
20:51:56 <blackh> aavogt: I thought I saw it in some announcement on reddit about new features in ghc 6.12 but I have had a few late nights recently. :)
20:58:11 <kyagrd> @type fix fix
20:58:11 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
20:58:11 <lambdabot>     Probable cause: `fix' is applied to too many arguments
20:58:11 <lambdabot>     In the first argument of `fix', namely `fix'
20:58:25 <kyagrd> @type fix . fix
20:58:26 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
20:59:04 <mmorrow> , (*2) `id` 4
20:59:05 <lunabot>  8
21:00:32 <kyagrd> @djinn (a->a)->a
21:00:32 <lambdabot> -- f cannot be realized.
21:00:39 <kyagrd> @type fix
21:00:39 <lambdabot> forall a. (a -> a) -> a
21:01:05 <kyagrd> oh yes djinn is a theorem prover
21:01:11 <kyagrd> @src fix
21:01:11 <lambdabot> fix f = let x = f x in x
21:44:45 <pastah> cabal is messing with me...
21:45:09 <pastah> i have GHC 6.10.4
21:45:14 <pastah> cabal: cannot configure vty-4.0.0.1. It requires base ==4.* and ghc-prim -any
21:45:32 <pastah> ghc-prim?
21:47:35 <pastah> please?
21:49:37 <mle> what's you're installed base?
21:50:36 <pastah> mle: 4 i guess
21:50:50 <pastah> since it's ghc 6.10.4 i have installed...
21:50:56 <pastah> or is ghc /= base?
21:51:00 <Cale> pastah: Are you installing something else which requires base 3 at the same time?
21:51:20 <pastah> Cale: ehm... maybe i installed VTY from the ubuntu libraries...
21:51:26 <Cale> base is the base libraries, they come with ghc, but they have a separate version number of their own
21:51:44 <pastah> lemme purge that installation i have and try again
21:53:35 <pastah> Cale: http://hackage.haskell.org/package/vty
21:55:39 <pastah> Cale: i sure hope i'm not... still the same error
21:55:45 <pastah> "cabal install vty"
21:56:28 <pastah> oh, shit... i wasn't running 6.10 here, it was on my _other_ computer i installed that
21:56:30 <pastah> my bad
21:56:46 <pastah> sorry :/
22:02:08 <Cale> pastah: To check which versions of things you have you can use  ghc-pkg list  or  ghc-pkg list <packagename>
22:04:08 <pastah> Cale: cool, didn't know :)
22:16:14 <pastah> Cale: this is okay?
22:16:22 <pastah> ghc-pkg list base
22:16:23 <pastah> /usr/local/lib/ghc-6.10.4/./package.conf:
22:16:25 <pastah>     base-3.0.3.1, base-4.1.0.0
22:32:25 <copumpkin> @index NAtural
22:32:25 <lambdabot> bzzt
22:32:28 <copumpkin> @index Natural
22:32:28 <lambdabot> bzzt
22:33:32 <kyagrd> two base versions wow
22:33:43 <Axman6> hooray, a bug of mine has been fixed in ghc :)
22:34:09 <bjorkintosh> why did you put the bug in there?
22:34:17 <sereven> @elite Algebra
22:34:18 <lambdabot> AlG38ra
22:34:19 <copumpkin> wait, did someone overwrite numbers?
22:34:34 <copumpkin> oh
22:34:37 <copumpkin> damn, hackage is silly
22:34:45 <sereven> kyagrd: that's normal with >= ghc-6.10.*
22:34:45 <copumpkin> http://hackage.haskell.org/package/numbers vs http://hackage.haskell.org/package/Numbers
22:35:51 <kyagrd> sereven: I didn't realize that until now
22:51:38 <psykotic> roconnor: usually with a good hash table you only need a fixed percentage overhead, e.g. 75% capacity.
22:52:10 <deech> Hi all, is mapping all exceptions to Maybe and Either better than just throwing and catching in the traditional way?
22:52:49 <pastah> deech: dependins if it's meaningful to have errors
22:53:11 <pastah> deech: if you write a parser, then you should use the Either or Maybe types
22:53:14 <psykotic> roconnor: with a binary tree, even unbalanced, you're looking at largest possible size of node * number of elements, which for a binary tree is something like 3x of a hash table rather than 1/0.75x as in the case i mentioned
22:53:28 <pastah> but if you're making like
22:53:50 <pastah> (!!!) :: [[a]] -> (Int,Int) ->
22:53:51 <psykotic> roconnor: if it's balanced then half the nodes are in the leaves, so it's 1/2 (3 + 1) = 2x, i think
22:53:59 <pastah> then you shouldn't use Maybe
22:54:17 <pastah> *-> a*
22:54:23 <deech> pastah: Don Stewart ( http://www.galois.com/blog/2009/04/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galois/ ) implies that doing this leads to more reliable systems.
22:54:46 <|Steve|> :t (!!!)
22:54:47 <lambdabot> Not in scope: `!!!'
22:55:12 <pastah> deech: yeah, but it depends on your use of your function
22:56:15 <pastah> if you make a function that CAN fail (index out of bounds or whatever), and you KNOW that you will never call it with invalid arguments because of some other circumstance, then at least i would skip it
22:56:36 <|Steve|> > let xs !!! (m,n) = (xs!!m)!!n in [[k..]|k<-[1..]]!!!(37,22)
22:56:36 <lambdabot>   60
22:57:10 <pastah> but if you feel like you want to handle Maybes on every other line in your code, that's what you should do
22:57:27 <|Steve|> Can't you use fmap to deal with it?
22:58:17 <deech>  pastah: That's interesting. I've  found dealing with Maybes somewhat of a pain.
22:58:50 <jfredett> oh my god, I love applicative parsers.
22:58:56 <pastah> deech: but i agree with what you say that dons wrote about; if it's production code, then you should always make it safe like that
22:59:18 <pastah> deech: if you learn how to use the Maybe monad, then it'll get easier :)
22:59:32 <jfredett> it went from 80 lines to 28 lines (effective) thats over 9000% improvement! </meme>
22:59:41 <copumpkin> zomg
22:59:44 <pastah> <3 <3 <3 "fromMaybe lolValue $ do {...}" <3 <3 <3
22:59:46 <copumpkin> OVER 9000!!1!!!!
23:00:16 <deech> pastah: Yes, I'm still learning. Is Maybe more capable than Either?
23:00:23 <pastah> no, less
23:00:28 <jfredett> I've only got one more little thing to work out, but after that, it should only be around 30 lines.
23:00:28 <pastah> but easier to handle
23:00:40 <pastah> deech: have you started looking at monads yet/
23:00:42 <pastah> ?
23:00:44 <jfredett> Which is freaking lovely.
23:01:00 <pastah> jfredett: what are you parsing?
23:01:06 <jfredett> Hmm, I need to send HWN around, don't I? or maybe I should just wait...
23:02:03 <jfredett> pastah: I'm rewriting the HWN software to be a proper DSL based tool, rather than the somewhat touchy psuedo-EDSL it is now.
23:02:33 <pastah> jfredett: cool :)
23:02:36 <deech> pastah: Yes, I'm comfortable using Monads. So far I've been using Exceptions and MonadError for error catching. I thought I was doing the right thing (even for production systems) until I read that slide.
23:03:05 <jfredett> I used TH + Parsec (Applicative Parsing ftw) to write a really easy to extend parser, which with all the TH stuff (which can definitely be made nicer) it only totals about 80-100 lines.
23:03:51 <jfredett> but it can extend to arbitrary numbers of "story types", so adding new sections, etc, will be really simple (as easy as adding some stuff to a string).
23:04:43 <jfredett> Although, I'm looking to use something like Dyre and having TH generate the story tags from a file. but thats far off in the future.
23:09:05 <deech> Also an awful lot of Haskell code seems to signal errors using 'error "..."'. This doesn't seem very robust.
23:09:43 <ivanm> error is used for irrecoverable errors
23:09:44 <pastah> deech: but have you used the Maybe monad?
23:10:12 <pastah> Maybe Monad + `mplus` == Maybe-error code without all the annoying stuff
23:10:43 <|Steve|> > (Just 5) `mplus` (Just 8)
23:10:44 <lambdabot>   Just 5
23:11:02 <|Steve|> That is handy.
23:11:46 <|Steve|> > fmap (10 +) (Just 5 `mplus` Just 8) == Just 15
23:11:47 <lambdabot>   True
23:13:07 <deech> pastah: no I can't say I've really explored the Maybe monad for errors. Mostly just in case statements.
23:13:23 <deech> |Steve|: Cool, I had not thought to doing that.
23:16:23 <|Steve|> > let foo f a = a >>= return . f in foo (10 +) (Just 5)
23:16:23 <lambdabot>   Just 15
23:16:33 <pastah> deech: a cool exercise for learning to use the maybe monad correctly is to write a parser for simple expression
23:16:45 <pastah> data Exp = N Int | Add Exp Exy
23:16:50 <pastah> *Exp Exp*
23:17:11 <pastah> and make a function parse :: String -> Maybe Exp
23:17:57 <pastah> then you'll see that using the maybe monad should be considered cheating and therefore banned
23:18:08 <pastah> (every other shmuck and his pals could do it)
23:19:20 <|Steve|> > let foo = flip (>>=) . (return .) in foo (10 +) (Just 5)
23:19:21 <lambdabot>   Just 15
23:19:41 <|Steve|> So is fmap = flip (>>=) . (return .)?
23:22:23 <|Steve|> Or I suppose fmap = (=<<) . (return .)
23:22:26 <|Steve|> @src fmap
23:22:26 <lambdabot> Source not found. My brain just exploded
23:31:07 <maltem> Heh. I just had my first moment of "wouldn't this be cleaner with ExistentialQuantification", and what happens? "Record update for the non-Haskell-98 data type `Command' is not (yet) supported; Use pattern-matching instead"
23:36:13 <pastah> @src fmap :: (a -> b) -> [a] -> [a]
23:36:13 <lambdabot> Source not found. I am sorry.
23:36:18 <pastah> @src fmap :: (a -> b) -> [a] -> [b]
23:36:19 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:36:26 <pastah> oh, come on!
23:36:36 <pastah> @src fmap :: [a]
23:36:36 <lambdabot> Source not found.
23:36:42 <pastah> i give up
23:37:29 <copumpkin> @src (->) fmap
23:37:29 <lambdabot> fmap = (.)
23:37:52 <pastah> @src [] fmap
23:37:52 <lambdabot> fmap = map
23:37:58 <copumpkin> @type [fmap, (.)]
23:37:59 <lambdabot> forall a b a1. [(a -> b) -> (a1 -> a) -> a1 -> b]
23:38:01 <pastah> @src Map fmap
23:38:01 <lambdabot> Source not found. Maybe you made a typo?
23:38:12 <pastah> @src Maybe fmap
23:38:12 <lambdabot> fmap _ Nothing       = Nothing
23:38:13 <lambdabot> fmap f (Just a)      = Just (f a)
23:38:18 <pastah> there we go :D
23:38:37 <pastah> copumpkin: thank you ;)
23:39:13 <|Steve|> Isn't every Monad a Functor with fmap defined as I did?
23:39:49 <|Steve|> > let foo = (=<<) . (return .) in foo (+5) [1..5]
23:39:50 <lambdabot>   [6,7,8,9,10]
23:40:43 <|Steve|> > let foo = (=<<) . (return .) in foo (+5) (Just 9)
23:40:44 <lambdabot>   Just 14
23:41:45 <Gracenotes> meow
23:45:53 <trzkril> @pl \a -> f a a
23:45:53 <lambdabot> join f
23:46:14 <trzkril> @type join
23:46:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:46:25 <trzkril> @where join
23:46:25 <lambdabot> I know nothing about join.
23:46:27 <dobblego> (t -> t -> a) -> t -> a
23:46:31 <dobblego> Control.Monad
23:46:40 <trzkril> thanks
23:46:49 <|Steve|> > join (+) 4
23:46:50 <lambdabot>   8
23:46:50 <pastah> join [[Just "lol"]]
23:46:54 <pastah> <join [[Just "lol"]]
23:46:58 <pastah> > join [[Just "lol"]]
23:46:59 <lambdabot>   [Just "lol"]
23:47:44 <|Steve|> > let foo = (=<<) . (return .) in foo join (Just [[37]])
23:47:45 <lambdabot>   Just [37]
23:48:08 <|Steve|> > fmap join $ Just [[37]]
23:48:09 <lambdabot>   Just [37]
23:51:58 <sciolizer_> Girls! Guys! I discovered a new monad!
23:52:03 <sciolizer_> data Nirvana a = Nirvana
23:52:09 <sciolizer_> instance Monad Nirvana where { return x = Nirvana ; x >>= f = Nirvana }
23:52:42 <sciolizer_> I think I'm going to call it, "The daughter of all monads"
23:54:51 <|Steve|> Why does it have kind * -> *?
23:55:23 <sciolizer_> Good question. I'll go ask the Monad type class.
23:55:46 <sciolizer_> He says "Expected kind `* -> *'"
23:55:56 <|Steve|> ah
23:56:45 <|Steve|> I see that ghc shares gcc's delusion that ` and ' are matching quotes.
23:57:17 <sciolizer_> reduces parsing ambiguity :)
23:57:39 <Jafet> “How about this?”
23:58:12 <sciolizer_> 3 How about this?
23:58:46 <sciolizer_> 15How about this?
23:59:08 <sciolizer_> ^OHow about this?
23:59:18 <|Steve|> ?
23:59:28 <sciolizer_> How about this?\0
23:59:54 <|Steve|> How about "Expected kind: * -. *"?
23:59:58 <sciolizer_> null terminated, prefixes specifying size (first is number of words, second number of characters, second number of characters encoded as a byte)
