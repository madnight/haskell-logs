00:00:06 <quicksilver> I'm not sure if cabal contains its own version of a solution to this :)
00:01:31 <lispy|web> quicksilver: I think since Vista MS is prescribing a locaction
00:01:44 <quicksilver> http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#paths-module
00:02:02 <quicksilver> "The placement on the target system of files listed in the data-files field varies between systems ... To enable packages to find these files in a portable way, Cabal generates a module called ... "
00:02:06 <quicksilver> I think that's the stuff you want.
00:02:28 <quicksilver> lispy|web: I was being flippant. On win32 by convention they go in "Program Files" I believe.
00:02:40 <quicksilver> lispy|web: I don't really use win32 so I indulge in all kinds of prejudices about it.
00:02:50 * lispy|web nods
00:02:58 <quicksilver> prejudice++ # more fun than being rational
00:03:27 <koala_man> it's only "Program Files" on english windows installations
00:03:29 <lispy|web> Most of my "professional" experience is windows.  Outside of that I've only used it to play video games and I look forward to starting at Galois where i'll be running linux on my work computer.
00:04:17 <Cale> lispy|web: Okay, okay :)
00:04:44 <Cale> lispy|web: hmm... I wonder if I should get lambdabot from the darcs repository or from hackage
00:04:54 <Cale> Was anyone updating the hackage version?
00:05:17 <lispy|web> Cale: i'll leave that decision to you.  I don't have an ETA from Ben on when Olive's filesystem will be available
00:05:24 <quicksilver> koala_man: makes sense. I imagine cabal does something close to the right thing anyway.
00:06:23 <koala_man> well, not entirely. very few of the other file paths are localized
00:06:35 <Cale> hmm... Jan 18 was the last hackage release
00:06:51 <atom> jmcarthur: you here?
00:07:02 <kohwj> does anyone know a tutorial for Data.Accessor?
00:07:25 <Cale> I'll get the code.haskell.org/lambdabot version
00:08:33 <lispy|web> Cale: sounds good.  I installed darcs globally
00:08:45 <lispy|web> It's 2.3.0 so it should work perfectly
00:08:51 <Cale> okay, cool
00:09:13 <lispy|web> cabal-install is also a global install
00:09:25 <Cale> darcs is really quite fast these days :)
00:09:59 <Cale> Though... I often wonder why it doesn't just wholesale copy everything, instead of recomputing the repository contents from the patches.
00:10:21 <lispy|web> Good good.  I'm working on some stuff to make it significantly faster, mornfall's summer of code changes are slated to appear in 2.4 to boost it, and there is an overall emphasis on speed
00:10:55 <lispy|web> Cale: yeah, we need to figure out what git does to make cloning so fast over the network and then steal the ideas.
00:11:28 <Cale> I would just gzip the whole repository, transmit it, and then unpack the gzip.
00:12:09 <Cale> Seems more straightforward than copying just the patches and then doing lots of computation to recover things.
00:12:13 <lispy|web> One thing that helps, use tags often and then add --lazy on the get (--lazy here makes sense because both machines are always on the net)
00:12:33 <lispy|web> Well, you have to make sure you don't grab things that are not versioned
00:13:11 <lispy|web> and I think until mornfall's work going into 2.4 that's still slow
00:13:22 <lispy|web> (I mean the check to see if a file is in the repo may be slow)
00:15:52 <kohwj> haskell can be really frustrating especially when there isn't good documentation that is beginner-friendly for some important modules
00:16:12 <lispy|web> kohwj: what modules?
00:16:24 <lispy|web> kohwj: (I agree, so I'm wondering which modules are frustrating you)
00:17:04 <kohwj> at the moment it's Data.Accessor
00:17:17 <lispy|web> I have to admit, I resort to reading the source of modules fairly often.  I do this in other languages too, and sometimes even on .NET I've had to decompile C# to get an understanding.
00:17:32 <kohwj> i can't remember the rest, but many others definitely exist
00:18:54 <lispy|web> That library looks pretty new
00:19:02 <PetRat> My GUI takes a while to compile on windows, about two minutes. This is on a laptop from 2003. the compile line is "ghc -package qtc -o a a.hs". I'm guessing that linking in qtHaskell takes all the time.
00:19:05 <lispy|web> too bad conal isn't here
00:20:17 <lispy|web> kohwj: did you already see this page? http://www.haskell.org/haskellwiki/Record_access
00:20:24 <PetRat> Any hope for speeding this up?
00:22:14 <lispy|web> Cale: I'm going to crash.  My irc abilities are a bit limited right now.  Send me an email if you need me to do anything (like installing something with apt)
00:22:59 <Cale> lispy|web: okay
00:23:13 <lispy|web> Cale: thanks
00:24:27 <Cale> lambdabot is building now, hopefully all will go well :)
00:25:01 <kohwj> lispy|web: yeah... not very carefully though
00:25:57 <Cale> I'm not sure about what the present hackage mueval looks like relative to the changes I'd locally made, so I'm probably not going to fix things there until I see if we're going to get the data back
00:25:57 <Cale> But I think the standard mueval works at least. :)
00:25:57 <lispy|web> Cale: yeah, that seems totally reasonable
00:25:57 <lispy|web> I should hear from Ben tomorrow
00:26:08 <lispy|web> Cale: I'll disappear after monday, so hopefully by then it's squared away
00:28:22 <lispy|web> Cale: also let me know if lambdabot needs more ram.  I can upgrade that pretty easily.  Well, g'night!
00:33:59 <lispy|web> Cale: oh, and in your cabal settings you'll want to have: split-objs: False
00:34:30 <lispy|web> Cale: I've found that splitting objs causes that virtual machine to go into swap and become totally slow
00:37:45 <hyungrok> If anyone is around: the old-time package says that one should use the new locale package... where can this package be found?
00:37:57 <hyungrok> *sorry, meant the old-locale package
00:38:48 <Cale> http://hackage.haskell.org/package/old-locale
00:39:53 <hyungrok> Uh, yeah
00:40:01 <hyungrok> that's the (supposedly) deprecated package
00:40:18 <hyungrok> whose description says that one should use the new locale package instead
00:40:35 <hyungrok> and I was wondering where this new package was.. I can't seem to find it on Hayoo
00:40:56 <Cale> It's included with ghc
00:41:09 <quicksilver> I think you're better off using "time" rather than "old-time" in the first plce thuogh
00:41:13 <Cale> er... hmm
00:41:18 <quicksilver> why are you trying to use "old-time" ?
00:41:56 <hyungrok> Okay, *locale*, not *time*
00:42:03 <quicksilver> yes, but it's related :)
00:42:14 <quicksilver> you're only trying to use old-locale because you're trying to use old-time
00:42:21 <quicksilver> it's better to use the new ones of each IMO.
00:42:26 <hyungrok> No, I'm not trying to use old-time..
00:42:51 <quicksilver> OK. Your initial question suggested you were. Shall we start this conversation again?
00:43:02 <hyungrok> Okay, sorry about that, my bad
00:43:08 <quicksilver> I recommend you use 'time' and 'locale', not the old- versions. Is there are problem with that plan?
00:43:17 <hyungrok> No, not at all
00:43:27 <hyungrok> My question: where can I find "locale" (the new one)?
00:43:32 <hyungrok> Point me to a URL
00:43:50 <Cale> ah, it really doesn't exist!
00:43:56 <hyungrok> What Cabal package is it included in?
00:43:57 <Cale> curious
00:44:01 <bastl> im again having problems with base-3 and base-4. In fact i dont know exactly what packages to depend on in my cabal file, when using spicific modules from hackage (Data.Generics, Data.Tree). Can I read about these issues somewhere ?
00:44:12 <hyungrok> I can find "time" as opposed to "old-time", but "locale" does not exist
00:45:36 <quicksilver> OK that's really odd.
00:45:41 <quicksilver> now I'm confused too :)
00:45:55 <hyungrok> And the Haskell Platform specifies both "old-time" and "time", but only "old-locale"
00:46:07 <quicksilver> Igloo: *ping*
00:46:12 <hyungrok> I guess old-time is included for compatibility, and that one should use the new time package
00:46:22 <Cale> Maybe someone planned to make a new locale package and didn't finish?
00:46:22 <hyungrok> But what about locales?..
00:46:54 <kohwj> lispy|web: i don't understand it :(
00:47:32 <hyungrok> Maybe.. (in which case the package name and description are rather misleading)
00:47:49 <hyungrok> I'm sure I'm not the only one finding oneself in this wild-goose chase
00:48:32 <hyungrok> (Localisation is a rather important, if unsexy, library, isn't it?)
00:53:48 <bastl> damn it: my cabal build doesnt want to find Data.Tree since it is member of containers-0.2.0.1. I dont want to fiddle around, but understand whats going on. can anyone help?
00:53:58 <bastl> (sorry for the rough language..)
00:54:21 <quicksilver> you need to add your dependenciy to containers in you .cabal file
00:54:27 <bastl> i have.
00:54:34 <bastl> it says it is hidden !?
00:54:51 <quicksilver> being hidden is what happens when you don't add the dependency
00:55:20 <quicksilver> suggesting you failed to add it, somehow
00:55:51 <bastl> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3569#a3569
00:56:24 <doserj> what does 'ghc-pkg list containers' say?
00:58:15 <bastl> it is there in /var/lib..., but not in ~/.ghc
00:58:15 <bastl> correnct version
00:58:15 <bastl> what does "hidden" mean exactly? is it there but not registered or what? Can i have multiple versions of a package, and only one is "visible" ??
00:58:53 <doserj> bastl: hidden means registered, but not exposed. see ghc-pkg --help
00:59:13 <quicksilver> cabal, by design, hides everything which you don't ask for
00:59:19 <quicksilver> this checks your dependencies are "honest"
00:59:39 <quicksilver> can you paste the complete log when it fails to build?
01:00:36 <bastl> doserj: sorry to complain, but the documentation "expose: exposes the package" doesnt help me  bit
01:00:53 <doserj> :)
01:01:26 <bastl> sorry, i fiddle around with these things too often. Where is it explained/speicified in depth?
01:01:28 <bastl> ghc-report?
01:03:04 <bastl> quicksilver: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3569#a3569
01:03:16 <bastl> using cabal -v i see "--hide-all-pacakges"
01:07:48 <bastl> quicksilver: you said cabal hides all packages. I dont understand, i though hidden/exposed is a state of a package in my package-db? how can cabal hide things ?
01:07:56 <bastl> *thought
01:08:14 <mornfall> Cale: The problem is, that http won't let you do things like "pack the stuff into a tarball and download".
01:09:03 <quicksilver> bastl: cabal hides everything, yes
01:09:12 <quicksilver> bastl: and then exposes only the things you specify dependencies on
01:09:22 <quicksilver> just for the purpose of that build, not permanently.
01:09:31 <quicksilver> that's how it keeps you honest.
01:09:49 <bastl> i see
01:10:33 <quicksilver> if it didn't hide things you didn't depend on, you might accidentally use a module you didn' tlist.
01:11:14 <bastl> ok, i understand that. is it right that base>4 was split up, and that i have to depend on things like containers then. (and that i would not have to for base-3?)
01:11:44 <cepstrum> Hello augmented_triad
01:14:43 <bastl> ah, i had to put the build-depends in the executable-section, not in the main section of the cabal file ...
01:15:35 <augmented_triad> Hello all of you! Nice to be here. I have a question: I have an IO a object, and I my function takes the a type. How can I get rid of the IO? (I am importing a midi file using Haskore)
01:17:10 <dibblego> augmented_triad, you can't get rid of the IO type -- however, you can produce an IO of your new type
01:18:27 <Axman6> augmented_triad: main = do foo <- readFile "blah"; let bar = func foo; print bar
01:19:12 <quicksilver> bastl: yes, base-4 is more split up than base-3
01:21:38 <bastl> quicksilver: thanks, i think i finally learned how things work ...
01:21:59 <bastl> but one open question still: what is the build-depends in the main section good for?
01:27:59 <augmented_triad> Axman6: thanks, I will work on it
01:28:26 <quicksilver> ah, that explains it, bastly
01:28:41 <quicksilver> bastl: sorry, I meant you have build-depends in the wrong section
01:28:44 <quicksilver> I'm a bit behind :)
01:29:03 <quicksilver> bastl: I think there is probably no purpose at all in the main section but maybe I'm wrong.
01:38:02 <Raevel> i'm having a cabal-install problem, it lists packages as updatable but i can't update them with install, http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=9297#a9297
01:39:05 <Raevel> (--reinstall'ing doesn't fix it)
01:39:33 <pozic> Raevel: cabal upgrade doesn't take into account default versions.
01:40:01 <pozic> Raevel: cabal install parsec will install version 2, which you already have.
01:40:22 <pozic> Raevel: cabal upgrade refers to parsec version 3.
01:40:29 <Raevel> ooh, thank you
01:40:46 <pozic> Raevel: cabal install parsec==3.0.0
01:41:17 <pozic> Raevel: it's a bug of course. Please report it, if it doesn't exist yes.
01:41:34 <pozic> yet*
01:42:09 <Raevel> ok, i'll see if i cand find a ticket
01:55:38 <augmented_triad> I have tried what Axman6 said, but I can't get it right. What I (intuitively) want, is this:
01:55:38 <augmented_triad> zookeeper = fromFile zookeeper_path
01:55:39 <augmented_triad> zoo = toGMMusic zookeeper
01:55:58 <Axman6> no, you can't do that
01:56:16 <Axman6> you need to use notation
01:56:21 <Raevel> http://hackage.haskell.org/trac/hackage/ticket/582
01:56:24 <Axman6> do notation*
01:56:29 <kowey> dcoutts: by any chance would you have time/inclination now to look into how Cabal fits into install GUI apps on MacOS X?
01:56:59 <Axman6> augmented_triad: take a look at http://random.axman6.com/blog/?page_id=70 and learn how to use IO
01:57:00 <kowey> (I have my Mac with me, am still fuzzy on details, but maybe between the two of us, we can clear things up)
01:57:39 <Beelsebob> kowey: you need to run a script to wrap a .app bundle around your binary, and then copy it to /Applications, and you're done
01:57:55 <kowey> Beelsebob: no craziness besides creating the bundle right?
01:58:02 <Beelsebob> nope
01:58:08 <augmented_triad> Axman6: what you said was this, right?
01:58:09 <augmented_triad> main = do
01:58:09 <augmented_triad> 	zookeeper <- fromFile zookeeper_path
01:58:09 <augmented_triad> 	let zoo = toGMMusic zookeeper
01:58:10 <augmented_triad> 	print "jazz"
01:58:10 <kowey> Beelsebob: the use case may be a corner one then
01:58:22 <Beelsebob> kowey: how so?
01:58:23 <kowey> Beelsebob: I want to make it possible for people to run my app from the command line
01:58:27 <kowey> (my use case)
01:58:34 <kowey> so right now, my INSTALL instructions
01:58:38 <Beelsebob> kowey: apple provide the open command for exactly those purposes
01:58:49 <Axman6> augmented_triad: what are the types of things there? what's fromFile's type? and toGMMusic?
01:59:01 <kowey> tell people to (ugh) cd ~/.cabal/bin; macosx-app geni
01:59:07 <Beelsebob> kowey: or, alternatively, one can still just run the binary in there
01:59:22 <kowey> and (double-ugh), put ~/.cabal/bin/geni.app/Contents/MacOS in their path before ~/.cabal/bin
01:59:37 <kowey> both of which make me rather unhappy... but I can't think of any way out of it :-(
02:00:11 <augmented_triad> fromFile: http://hackage.haskell.org/packages/archive/midi/0.1.4/doc/html/Sound-MIDI-File-Load.html
02:00:11 <augmented_triad> toGMMusic: http://hackage.haskell.org/packages/archive/haskore/0.1/doc/html/Haskore-Interface-MIDI-Read.html
02:00:12 <kowey> I suppose http://hackage.haskell.org/trac/hackage/ticket/240 should be considered as a totally bogus diagnosis on my part then (nothing to do with resource forks, just the bundle)
02:00:56 <Axman6> augmented_triad: are you giving toGMMusic the ChannelProgramPitchTable drum -> ChannelProgramTable instr parts of its type?
02:01:04 <Axman6> uh, sorry
02:01:16 <Axman6> augmented_triad: what error are you getting?
02:01:57 <augmented_triad> Ambiguous type variable `time' in the constraints:
02:01:58 <augmented_triad>       `Real time'
02:02:08 <dancor> i'm writing parser and wanted (data Expr) in Expr.hs to reference (data Var) in Var.hs and vice-versa.  how should i reorg?
02:02:16 <augmented_triad> arising from a use of `toGMMusic'
02:02:16 <augmented_triad>                      at /Users/borrel/Universitet/bachelor/alg_comp/code/Music.h
02:02:16 <dancor> (to not have circ dep)
02:02:18 <Axman6> well, you need to provide a type constraint then
02:02:40 <Axman6> dancor: i'd put them in the same module
02:02:53 <kowey> Beelsebob: do you think I'm pretty much stuck with the (a) create bundle in ~/.cabal/bin and (b) add ~/.cabal/bin/foo.app/Contents/MacOS solution?
02:02:53 <dancor> hm.  they are both pretty big
02:03:07 <dancor> i guess they could both go in Expr
02:03:20 <quicksilver> dancor: personally I put the types (not necessarily the associated functions) in one file
02:03:25 <Beelsebob> kowey: I'd just let them add the path if they really want to
02:03:28 <kowey> Beelsebob: context also is that I want this tool to fit into to makefiles etc that work on Linux
02:03:29 <quicksilver> dancor: and then you import that into both.
02:03:42 <quicksilver> dancor: however you can use GHC's recursive module support if you prefer.
02:03:44 <ksf_> ipv6 yay!
02:03:47 <kowey> so I have outside scripts that call my tool, and they should "just work" on Mac as well as on Linux
02:03:54 <Axman6> augmented_triad: so, you'd need something like : let foo = toGMMusic zoo :: (ChannelTable Instr, T Double Double Note, T)
02:04:14 <Axman6> kowey: nice work, how'd you get that working?
02:04:20 <Axman6> uh, ksf, not kowey
02:04:25 <dancor> quicksilver: do you combine all types in one file, or just when you would have a recursive dep?
02:04:42 <ksf> simple, plain 6to4 tunneling.
02:04:45 <Beelsebob> kowey: how about mv foo.app /Applicaitons; ln -s /usr/local/bin/foo /Applications/foo.app/Contents/MacOS/foo
02:04:51 <quicksilver> dancor: just recursively dependent types.
02:05:01 <quicksilver> dancor: to me it makes good signs to declare them together anyway
02:05:12 <quicksilver> dancor: ...because you can't really read their definitions independently.
02:05:18 <ksf> (note the 2002 at the start of the address)
02:05:19 * kowey tries
02:05:19 <dancor> i might do that since there is a lot of parsing logic and comments for each of Var-stuff and Expr-stuff..
02:05:46 <dancor> i feel they each deserve their own exposition
02:05:47 <ksf> ...oh, and you need to connect to ipv6.[eu|us].chat.freenode.net
02:06:38 <dancor> quicksilver: what would you call the file holding Var-related and Expr-related types?
02:06:56 <dancor> maybe ExprData.hs
02:08:45 <kowey> Beelsebob: I'm afraid that doesn't work
02:09:06 <quicksilver> dancor: ExprTypes.hs?
02:09:09 <kowey> Beelsebob: because [in my voodoo mental model] it really wants foo to be called from inside a bundle
02:09:11 <dancor> ok
02:09:20 <kowey> so /usr/local/bin/foo gives me a non-reactive gui
02:10:48 <kowey> but /wherever/foo.app/Contents/MacOS/foo works
02:11:16 <Beelsebob> kowey: oh, okay then, mv foo.app /Applications; echo "open /Applications/foo.app" > /usr/local/bin/foo
02:11:32 <kowey> Beelsebob: what about command line arguments?
02:11:41 <kowey> Beelsebob (thanks for your patient help, btw :-) )
02:12:08 <kowey> I guess I'm really just a corner case user that really wants an command line tool with a Mac gui
02:12:20 <Beelsebob> well no, lots of other apps do that
02:12:28 <Beelsebob> they all just put it in /Applications and let the user deal with it
02:12:40 <kowey> now if open will pass along command line arguments, that could work
02:12:42 <kowey> let me see
02:17:26 <quicksilver> I don't think open can pass on commandline args although I might be wrong.
02:17:51 <kowey> interestingly, this also gives me a non-reactive GUI
02:18:18 <kowey> hmm, so if I may permit myself to think aloud - the problems I'm trying to fix are [i] manual intervention needed by user after cabal install
02:18:41 <quicksilver> btu I think it is safe to make /usr/local/bin/foo a shell script which does "cd /Applications/foo.app; ./MacOS/Contents/foo $@"
02:18:49 <quicksilver> something like that anyway
02:18:56 <quicksilver> (is it $*? I always forget shell variables)
02:19:08 <kowey> quicksilver: that looks like a very good candidate
02:19:36 <kowey> I'm a bit superstitious about adding layers of shell scripts (because I don't have a good sense for how to protect stuff like spaces, etc)
02:19:47 <quicksilver> kowey: if you find a good solution, or even an adequate one, please update that cabal ticket for posterity
02:19:56 * kowey tries
02:20:16 <Botje> you want "$@", apparently
02:20:36 <kowey> and also making sure my app doesn't think of that as one big argument
02:23:23 <quicksilver> yes "$@" literally including the quotes
02:23:25 <hackagebot> vector 0.3 - Efficient Arrays (RomanLeshchinskiy)
02:23:34 <kowey> we'd also want to make sure that relative paths are interpreted correctly
02:23:43 <quicksilver> that's why the 'cd' is there first
02:23:47 <kowey> i.e. relative to where the user was when she calls the script
02:23:55 <quicksilver> ah you can't do that.
02:24:04 <quicksilver> you'll need to save that in an environment variable if that's what you want.
02:24:19 <quicksilver> OSX GUI applications have to be run with the current working directory being just inside Foo.app
02:24:45 <quicksilver> you can add something like export OSX_HACK_OLD_PWD=`pwd` to your shell script launcher
02:24:49 <kowey> hmm so let me see if I can plop down my desiderata (again thinking aloud) [i] command line + args work perfectly [ii] no manual intervention after cabal install [iii] {future work} custom app bundles with fancy icons etc
02:24:52 <quicksilver> to save the old pwd
02:25:26 <quicksilver> and your haskell code can change working directory to getEnv "OSX_HACK_OLD_PWD" if it exists.
02:25:45 <kowey> I wonder if I can make the shell script smart enough to turn relative paths into absolute paths based on OLD_PWD
02:25:51 <kowey> which would be not quite perfect, but good enough
02:26:26 <kowey> actually, it doesn't need the cwd to be in an app bundle (from experience)
02:26:46 <kowey> it just needs the executable to be within one, huh... so just maybe
02:26:55 <quicksilver> maybe that depends exactly what libraries you use and stuff
02:27:02 <quicksilver> I'm pretty sure that some things depend on it.
02:27:07 <kowey> wait, now I'm confusing myself
02:27:26 <kowey> ln -s /blah/foo.app/Contents/MacOS/bin/foo /usr/local/bin does not work
02:27:37 <kowey> BUT calling from the command line /blah/foo.app/Contents/MacOS/bin/foo does
02:27:47 <kowey> (no need to actually be in /blah/foo.app at the time)
02:27:54 <quicksilver> interesting.
02:28:04 <quicksilver> maybe you can remove the 'cd' from my recipe then.
02:28:07 <kowey> so if that's right, there may be a way out of [i] without any fancy tricks
02:28:27 <quicksilver> although I have a feeling you will need to 'cd' if you use certain GUI toolkits or libraries which expect to fish stuff out of Resources
02:28:42 <kowey> oh
02:28:56 <kowey> well I'll be evil and just focus on getting something that works with wxHaskell for now
02:29:14 <kowey> (and be sure to make a note of your point)
02:32:57 <quicksilver> kowey: I'd like something that works for wxhaskell too :)
02:34:54 <kowey> (tacking on desideratum (?) [iv] - should work without superuser)
02:35:15 <kowey> (so I'm trying rm ~/.cabal/bin/foo and putting my script in its place)
02:35:55 <quicksilver> but if you're not superuser you can't install into /Applications either?
02:36:12 <kowey> so /Applications for me; I'm working from ~/.cabal/bin/foo.app/Contents/MacOS
02:37:08 <quicksilver> ah right.
02:37:22 <quicksilver> ideally you'd get the global install working too :)
02:37:23 <kowey> ah what a joy it would be to finally solve this problem once and for all
02:37:41 <kowey> and no longer need to have an ugly-things-you-have-to-do section for Mac users in my INSTALL file
02:37:47 <kowey> just tell them "cabal install foo"
02:41:27 <kowey> awesome! quicksilver/Beelsebob: your idea of replacing a call to foo with a shell script wrapper works even with relative paths/spaces/etc so desideratum [i] check
02:41:52 <kowey> now for [ii]... (should just work from cabal install with no manual intervention)
02:44:17 <pozic> How can I statically have some kind of computation in which a number of return values is set exactly once. So, it should be like the Reader monad, but then write-only variables. Also, updating one variable should take constant time. So, it's basically the writer monad for the case of 1 variable, with the additional restriction that calling tell twice is illegal.
02:45:19 <quicksilver> wrap around the state monad with a bunch of 'Maybe foo' in your state
02:45:42 <quicksilver> and write commands with the property that they set Nothing -> Just x, but if you try to set when it's already Just they give an error
02:46:06 <pozic> quicksilver: a compile time error?
02:46:43 <quicksilver> oh, compile time.
02:46:51 <quicksilver> you can't do that with a straightforward monad, then
02:47:00 <quicksilver> because you need something which 'changes type' after you call set.
02:47:31 <pozic> Is it possible to have do syntax working with this more general type of monads?
02:47:57 <Axman6> it works with all monads...
02:48:15 <pozic> Axman6: no, it doesn't.
02:48:26 <dancor> pozic: yes it does!
02:48:30 <Axman6> yeah it does
02:48:30 <dancor> :)
02:48:47 <Axman6> do syntax is just sugar for >>= and >>
02:49:41 <pozic> Axman6: yes, but the type of >>= needs to be changed.
02:50:01 <Axman6> do a; b -> a >> b, do x <- a; b x -> a >>= \x -> b x
02:50:07 <Axman6> no it doesn't...
02:50:09 <kyagrd> Axman6: but isn't the type of do synatx is the standard Monand type? Can we change that?
02:50:19 <Axman6> if you have defined a monad, you can use do syntax with it
02:50:23 <pozic> Axman6: so, no, it doesn't. But if quicksilver says it is possible in Haskell98, then I believe him,but I doubt he will say that.
02:50:32 <quicksilver> Axman6: please don't jump in without readin ghte discussion
02:50:50 <quicksilver> pozic: I'm not entirely sure. certainly not without some hacking.
02:50:57 <pozic> I think with do-syntax overloading, it will probably work.
02:51:03 <pozic> But that's not H98.
02:51:04 <quicksilver> pozic: there has been some discussion about this before in the context of state monads which change state type
02:51:04 <Axman6> i didn't realise it was part of a further discussion
02:51:30 <pozic> quicksilver: I am aware of that discussion. I don't think a library ever emerged from it.
02:51:39 <dancor> Axman6: "[do-notation] works with all monads"  pozic: "no, it doesn't"
02:51:40 <dancor> fail
02:51:40 <quicksilver> pozic: (and that would be one way of modelling your problem)
02:52:08 <quicksilver> pozic: agreed; I also don't think a library ever came out of that discussion.
02:52:09 * Axman6 really meant that do notation works with all Monads ;)
02:52:43 <quicksilver> sure, but the context was "you can't do that with a straightforward monad, then" "you need something which 'changes type'" "Is it possible to have do syntax working with this more general type of monads"
02:52:51 <quicksilver> you only had to read back two lines to see that ;)
02:54:06 <Axman6> that's fine, but it's a little difficult changing the past now isn't it
02:54:44 <rio> back to the future
02:54:45 <dancor> so this thing is a monad but not a Monad?
02:55:02 <pozic> http://comonad.com/reader/2007/parameterized-monads-in-haskell/\
02:55:02 <dancor> that doesn't speak well for the Monad type
02:55:03 * Axman6 dislikes being tld off for trying to help, especially when he was right, in the context in which he saw the question
02:55:57 <quicksilver> I did not intend to offend.
02:56:06 <dancor> if only i had read back two lines (and studied categtory theory for ten years)
02:56:23 <quicksilver> I think it is a reasonable request that one make a fair attempt to understand the context of a question before answering it.
02:56:26 <Axman6> dancor: quite
02:56:43 <Axman6> quicksilver: i thought i had.
02:57:19 <quicksilver> in that case, good :)
02:57:35 <hackagebot> ip6addr 0.1.1 - Command line tool that filters parsed IPv6 Addresses against RFC 4291 (MichelBoucey)
02:57:47 <Axman6> i would also say it's not unreasonable to assume that when osmeone says monad in here, they mean Monad, which is what both dancor and i did
02:58:28 <quicksilver> I don't think this conversation is very profitable.
02:58:42 <quicksilver> I have no desire to continue to offend a useful contributor to this channel.
02:59:05 <Axman6> heh, thanks. sorry for getting snarky :)
02:59:07 <quicksilver> to my mind it's fairly clear that "this more general type of monads" is referring to something different
02:59:15 <ivanm> hmmm? what argument is going on here?
02:59:17 <quicksilver> but I quite accept it wasn't clear to you
02:59:19 <quicksilver> and that's fine :)
03:00:50 <Axman6> in other news, i just received my copy of The Pocket Ref. and i highly recommend it, so damn useful
03:01:05 <Axman6> i think it contains about 43% of all useful knowledge known to man
03:01:49 <quicksilver> what do you recommend for the other 57%?
03:02:03 <Axman6> internet
03:02:07 <pozic> >500 pages => you have big pockets.
03:02:24 <Axman6> pozic: it's bout 3/4 of an inch thick
03:02:27 <ivanm> Axman6: what pocket ref?
03:02:32 <Axman6> it's tiny
03:02:37 <Axman6> The pocket ref ;)
03:02:51 <Axman6> http://www.sequoiapublishing.com/pdt_pocketref3ed.htm
03:03:27 <pozic> Axman6: ah, ok. It seems to get plenty of positive reviews.
03:03:48 <Axman6> indeed. mythbusters recommended too
03:08:31 <ivanm> Axman6: where did you get it from?
03:08:31 <Axman6> fishpond.com.au
03:08:31 <ivanm> right... for how much?
03:08:31 * ivanm has to use the credit from there soon...
03:08:31 <Axman6> used my $10 credit i got from you getting RWH before i did ;)
03:08:31 <ivanm> heh
03:08:31 <Axman6> think it was about $20AU
03:08:31 <ivanm> I've got $12 from finding cheaper prices from other books I got
03:08:42 <ivanm> (the credit I got for buying so much expired within a month :@ )
03:09:20 <SamB> what, they do post-mortom price matching?
03:11:13 <ivanm> SamB: if you can find it cheaper on amazon (including delivery I think...) they give you the diff + 10% back as credit
03:11:44 <Axman6> they guarantee cheaper prices than amazon
03:12:36 <Axman6> ivanm: http://www.fishpond.com.au/Books/Reference_Language/General/product_info/1601227/
03:12:49 * ivanm thinks he'll pass on it
03:12:51 <Axman6> (was harder to find than i expected. had to look at my order
03:12:56 <ivanm> heh
03:13:01 <Axman6> your loss ;)
03:13:29 <ivanm> Axman6: http://booko.com.au/books/isbn/9781885071330
03:13:40 <ivanm> you can get it cheaper from the UK!
03:14:04 <ivanm> hmmm.... I wonder if this one is worth it: http://www.fishpond.com.au/product_info.php?ref=261&products_id=1601228&affiliate_banner_id=1
03:14:07 <Axman6> yeah, but i had $10 credit, and shipping was free for orders over $50
03:14:32 <Axman6> and yeah, the book depository is really cheap
03:14:53 <Axman6> but they have like $8AU shipping
03:15:09 <Axman6> wait, that's 8 pounds shipping... that's about $16AU
03:15:22 <Axman6> wait... read properly Axman
03:15:35 <Axman6> that's if it was bought through amazon uk
03:15:37 <Axman6> -_-
03:15:40 <ivanm> heh
03:20:06 <ksf> you know, they _could_ just have a script look at the amazon prizes and set their own a cent below that.
03:21:19 <ksf> but then, a) you wouldn't waste time b) they would sell cheaper to _all_ of their customers c) they couldn't do advertisment by appealing to your predatory instincts
03:21:53 <ksf> there's no such thing as a rebate.
03:23:01 <danr> @type ((==) `on` length)
03:23:24 <ksf> @botsmack
03:23:25 <lunabot>  :o
03:23:31 <danr> :(
03:23:44 <ksf> > fix id
03:23:49 <ksf> > 1
03:23:52 <SamB> ksf: and they might have to pay amazon to run a script at that volume ;-P
03:23:53 <danr> lambdabot dead?
03:23:56 <ksf> huh. she's in the channel.
03:24:05 <SamB> and/or for commercial purposes
03:24:17 <SamB> I forget what the agreement said about it ;-)
03:24:21 <Axman6> probably a very lange @pl. that's usually what kills her
03:24:26 <Axman6> large*
03:24:37 <danr> Well, ((==) `on` length) gives [a] -> [a] -> Bool, but I argue that it is too contrained, it could rather be [a] -> [b] -> Bool
03:24:43 <SamB> Axman6: hmm. the cost function is inadequate ?
03:24:43 <danr> Any known cures to this?
03:24:48 <SamB> it should take size into account ?
03:25:04 <quicksilver> it should run in a separate process like it does with mueval
03:25:11 <Jafet> ksf, the switching cost for joe average book buyer from household brand amazon to unknown website running shady script is probably quite a bit more than one cent
03:25:12 <quicksilver> or rlimits should work :)
03:25:12 <danr> Not lambdabot, but the type
03:25:23 <Axman6> danr: explicitly write the type?
03:25:35 <quicksilver> danr: you are being constrained by the type of 'on'
03:25:56 <quicksilver> (\a b -> length a == length b) will have the more general type you want.
03:26:09 <danr> quicksilver: ah thanks
03:26:47 <quicksilver> when you pass "length" to "on" it's not passed polymorphically
03:27:18 <quicksilver> sometimes people describe this as "polymorphism is not first class in haskell"
03:27:23 <danr> of course. that's a bummer because that would be part of a sweet pointfree solution to another problem
03:27:40 <quicksilver> a deeper explanation is that what you really want here is called "higher-rank inference"
03:27:49 <quicksilver> unfortunately, higher-rank inference has poor properties
03:28:06 <quicksilver> it's not confluent - there can be many different 'most general' types.
03:28:29 <quicksilver> so there aren't good general solutions to higher-rank infrence.
03:28:37 <Jafet> I find the general focus on point-free solutions to be a bit...
03:28:41 * Jafet sunglasses
03:28:44 <Jafet> ...pointless.
03:29:04 <quicksilver> although GHC has an extension which lets you use higher rank types, you have to annotate them specifically
03:29:16 <quicksilver> (except for a rather small class of cases it can infer automatically)
03:29:28 <quicksilver> Jafet: there is a reason the lambdabot plugin is called "@pointless" and not "@pointfree"
03:34:34 <danr> quicksilver: thanks for the long answer. I'll have a look at hinger-rank inference
03:46:18 <danr> I realize it is the same problem as in let makePair f (x,y)
03:46:37 <danr> > let makePair f (x,y) in makePair id ('a',[2])
03:46:46 <danr> interesting :)
03:47:52 <quicksilver> I think you mean "let makePair f (x,y) = (f x, f y) in makePair id ('a',[2]')
03:48:29 <quicksilver> but, yes, it's the same problem.
03:49:46 <quicksilver> , let makePair :: (forall a . a -> a ) -> (b,c) -> (b,c); makePair f (x,y) = (f x,f y) in makePair id ('a',[2])
03:49:47 <lunabot>  ('a',[2])
03:50:01 <quicksilver> ^^ explicit type annotation makes it work
03:50:11 <quicksilver> but also, essentially, restricts it to only working with 'id'
03:50:27 <quicksilver> because that's the only interesting function of type (forall a . a -> a) - neglecting undefineds.
04:05:37 <Axman6> http://www.bookdepository.co.uk/category/2056/Computer-Science computer science file :(
04:10:49 <Axman6> how interesting, Apple have made grand central dispatch open source
04:13:47 <Lycurgus> why is it interesting? They and others like them frequently front as advocates of open source.
04:14:56 <Lycurgus> front and/or actually operate as same to some extent (e.g. google).
04:17:31 <quicksilver> it's interesting because GCD is potentially a substantial practical advantage for OSX
04:17:44 <quicksilver> so it is, on the surface of it, not an obvious candidate for open-sourcing.
04:17:53 <Axman6> makes writing parallel programs in C damn easy
04:19:45 <Axman6> of course, to make any use of GCD, you need to be using blocks (only supported in LLVM on non apple systems)
04:19:48 <Adamant> the basic idea has been done in other languages
04:20:04 <Adamant> and ecosystems
04:20:23 <Adamant> and OpenCL is a open standard
04:20:46 <Jafet> C is silly for parallelism anyway
04:20:50 <Lycurgus> llvm is one of two "touchy" channels I frequent, the other being lisp
04:20:59 <Adamant> touchy how
04:21:08 <Axman6> OpenCL addresses a different problem to GCD though
04:21:19 <Adamant> Axman6: they're related though
04:21:26 <nlogax> didn't openCL originate at apple, too?
04:21:26 <Lycurgus> in the "what do you mean?" sense
04:21:31 <Axman6> nlogax: yes
04:21:42 <Axman6> Lycurgus: what do you mean by touchy?
04:22:08 <Adamant> Lycurgus: "what do YOU mean, YOU PEOPLE?" touchy?
04:22:53 <Lycurgus> who said anything about "YOU PEOPLE"?
04:23:04 <Axman6> anyone ever heard of abamperes?
04:23:06 <Adamant> I guess I'm the only person who saw Tropic Thunder
04:23:26 <Axman6> (they're Amps/10)
04:23:31 <Lycurgus> I definitely won't be seeing Tropic Thunder.
04:23:33 <Lycurgus> Ever.
04:23:43 <Adamant> why?
04:23:51 <Lycurgus> too fucking old
04:24:02 <Adamant> you or the film
04:24:04 <Lycurgus> me
04:24:08 <Adamant> ah
04:24:09 <Axman6> heh
04:24:16 <quicksilver> Adamant: the basic idea of GCD? automatically deciding how many threads to make runnable, adaptively, based on what else is using execution units?
04:24:23 <gio1234> is there anybody from portugal?
04:24:31 <quicksilver> Adamant: that's not a feature of any of the common language RTSes I know of.
04:25:03 <Adamant> quicksilver: check it's page, it's done for .NET and in process for Java
04:25:10 <Adamant> *it's Wiki page
04:26:34 <quicksilver> it's not clear to me that "Task Parallel Library" is adaptive. It sounds like it just knows how many cores there are.
04:26:49 <quicksilver> "By default, as many threads as there are processors (or processor cores) on the system are created, though this number may be manually modified"
04:27:32 <Jafet> It isn't usually hard to find out the number of available cores on a system
04:27:40 <quicksilver> exactly, it's not.
04:27:50 <quicksilver> the clever part about GCD is it adapts to the other load on the system
04:27:53 <Jafet> Well, that counts as somewhat adaptive to me.
04:27:59 <quicksilver> or that was my understanding of it.
04:28:10 <quicksilver> that's very static - just check the number of hardware execution units.
04:28:24 <quicksilver> which is basically assuming you're the only thing running on the machine, to get the right performance.
04:28:44 <quicksilver> on an 8-core machine if two cores are constantly busy with other tasks, you will get best performance by pretending there are only 6.
04:28:47 <quicksilver> etc.
04:28:59 <Jafet> If you want to be accurate at all, it's a massive crapshoot. There are two billion and five sources of error in any naive (read: low-overhead) estimation
04:29:20 <quicksilver> of course.
04:29:32 <quicksilver> but you can still do worse, and do better.
04:29:35 <Jafet> Let's see: memory bus speed, context switch efficiency, swapping, cache syncing issues
04:29:44 <Jafet> And as you said, other processes
04:29:45 <quicksilver> and GCD is an attempt to do 'better' than the existing approachs
04:29:55 <quicksilver> which doesn't make it perfect, but it does make it something new, as far as I knew
04:30:26 <Jafet> I think the C folks are playing a losing game with themselves here
04:31:10 <Jafet> With C, you have to hold the clutch and change the gear yourself.
04:32:36 <Le-Chuck_ITA> Hi there. I am trying to understand a basic fact of preorders and algebras, Given an order preserving morphism f from a preorder <A,R> to a preorder <A',R'>, one can form the preorder <A, R''> such that x R'' y <=> f(x) R' f(y). What's this preorder? It's neither a kernel nor a cokernel
04:34:19 <iabal> hi, someone could said me if this is a ghc problem? Seems that here http://www.moonpatio.org/fastcgi/hpaste.fcgi/view?id=3571 ghc does not "resolve" the type family
04:37:29 <iabal> | x == ?var -> return ?term FAILS, return (?term::Expr) FAILS but return (?term::VarTyp Var) IS OK, a bit strange since VarTyp Var = Expr
04:43:12 <quicksilver> iabal: I have no idea about using implicit parameters in conjunction with type families
04:43:37 <quicksilver> it seems unlikely that that path has been well tested
04:43:43 <quicksilver> implicit parameters are not widely used.
04:44:16 <quicksilver> Le-Chuck_ITA: I would call it "the pre-image of R' under f" I think
04:44:37 <quicksilver> I'm not sure if that is technically correct.
04:45:01 <Le-Chuck_ITA> quicksilver: yes, that's true, but it "looks inside" the preorder, I am trying to understand what it is categorically
04:45:59 <Le-Chuck_ITA> seems to me it's the greatest preorder on A such that there is a commuting function
04:46:10 <iabal> quicksilver: ok thanks, anyway, some idea or "pattern" to avoid re-computation of free variables when doing a substitution? Memoization or monads seems an overcomplicated solution
04:46:16 <Le-Chuck_ITA> but what does this mean in terms of limits or whatever, I don't know
04:47:04 <iabal> (a Reader monad with the free vars)
04:51:52 <benmachine> > ('c' <*>)
04:52:08 <benmachine> @botsnack
04:52:08 <lunabot>  :o
04:52:14 <benmachine> :o
04:52:27 <benmachine> , ('c' <*>)
04:52:28 <lunabot>  luna: Couldn't match expected type `f (a -> b)'
04:52:40 <benmachine> aww it doesn't print the whole message
04:52:58 <benmachine> in my ghci it goes on to say
04:52:59 <benmachine>     In the second argument of `(<*>)', namely 'c'
04:53:08 <benmachine> but that's the first argument, isn't it?
04:53:21 <benmachine> it says exactly the same thing for (<*> 'c')
04:53:27 <benmachine> (only with a different expected type)
04:55:01 <doserj> ghci 6.8.2 gets it right here. 6.10.4 doesn't
04:55:13 <doserj> funny bug
04:56:38 <benmachine> should I report it somewhere
04:58:19 <doserj> I think so. http://hackage.haskell.org/trac/ghc/wiki/ReportABug
05:08:43 <gwern>  @botsnack
05:08:49 <gwern> @botsnack
05:08:49 <lunabot>  :o
05:14:39 * kowey returns to the problem of cabal install'ing a graphical app on MacOS X
05:15:34 <kowey> now attempting to work out if I can have something like a cabal install posthook to (1) build an app bundle in --prefix/bin (2) delete the executable and (3) create a shell script calling the gui in the app bundle
05:16:58 <dcoutts> kowey: OSX app bundles are a mystery to me
05:17:18 <kowey> they're just directories with conventions for where things should be stored if I (very ignorantly) understand correctly
05:17:23 <dcoutts> kowey: if someone can describe what needs to be done then perhaps we can support them better
05:17:36 <kowey> for example, localisation information in Resources/, executable in Contents/MacOS, etc
05:17:51 <kowey> but we'd need somebody who actually has good MacOS programming knowledge to chime in
05:18:34 <ivanm> kowey: so someone from Apple who uses Haskell? :p
05:18:58 <kowey> that'd be a start :-)
05:19:15 * kowey still is holding out for an Apple insider to push for Haskell Platform to ship with MacOS 10.7
05:19:28 <ivanm> kowey: won't that limit the ability to upgrade?
05:19:32 <Adamant> how soon do you need someone with OS X knowledge?
05:20:02 <kowey> oh; I don't know
05:20:36 <Adamant> I'm tied up with work for the next week but I can work on helping getting ghc working after that if someone has a plan and can point me in the direction we need to go
05:20:40 <kowey> Adamant: well *I* would like to resolve my gui installation woes today if possible, but I imagine that dcoutts for better support of app bundles is thinking long term
05:21:02 <Adamant> I thought this was about ghc not working
05:21:20 <kowey> if I could recap what I'm after: right now 'cabal install foo' does not work well for a graphical command-line MacOS X app
05:21:41 <Adamant> right.
05:21:49 <kowey> I have to put ugly instructions in my INSTALL file telling them to (i) run a shell script that creates an app bundle and (ii) put ~/.cabal/bin/foo.app/Contents/MacOS in their PATH
05:22:12 <Adamant> so you want to be able to spit out a app bundle
05:22:13 <kowey> thanks to quicksilver and Beelsebob: I can now replace (ii) by a shell script
05:22:45 <kowey> exactly, now I want to replace (i) so that cabal install 'foo' just does the right thing -- no manual intervention needed
05:23:11 <kowey> I don't mind needing a custom Setup.hs to do it, which is why I'm in the process of researching cabal install posthooks
05:23:15 <Adamant> does anyone have a list of Things To Be Done On OS X For Haskell?
05:23:36 <Adamant> that would be useful
05:24:45 <kowey> perhaps http://www.haskell.org/haskellwiki/MacOS_X would be a good place to dump it
05:25:57 <Adamant> fuck it, it's too early in the morning to go through signup hassle
05:26:09 <Adamant> I'll just make a note
05:26:28 <Adamant> and come back to it later
05:26:30 <gwern> Adamant: I'm here right now if you want an account
05:27:08 <kowey> dcoutts: I believe this is all you need to get a working app-bundle: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9299#a9299
05:28:12 <kowey> there's all sorts of crazy stuff my version of this script does too to set the icon, etc, but I (personally) am ignoring that for now
05:28:30 <Adamant> gwern: just put it "What needs to be done for Haskell on OS X: 1. ghc fully working with 64-bit OS X 2. Cabal producing app bundles"
05:28:36 <dcoutts> kowey: and how do we know if the package author or perhaps user wants to make this program into an app bundle?
05:28:43 * gwern would prefer to make Adamant an account
05:28:44 <Adamant> I'll sign up for an account later
05:29:03 <Adamant> gwern: I'll just sign up then, it's just as easy.
05:29:14 <gwern> not really
05:29:17 <kowey> dcoutts: I'm not sure, but what I do know is that if it's a gui application (at least for wxHaskell) if you don't put it in an app bundle, the widgets don't respond to input
05:29:30 <gwern> I can make you an account now; or you can send off an email later and get an account at some indefinite point
05:29:39 <Adamant> yeah
05:29:40 <Alpounet> is there any way to do structural polymorphism in Haskell ?
05:29:46 <Adamant> just saw that accounts were restricted
05:29:50 <kowey> dcoutts: so it sounds like you'd need some way for the user to say "please make me an app bundle" at their explicit request
05:30:07 <dcoutts> kowey: do those other dirs have to exist or is just the $program.app/Contents/MacOS/ enough?
05:30:26 * kowey does empirical informatics to find out
05:30:31 <gwern> Adamant: email/uname plox
05:30:50 <dcoutts> kowey: I mean is it as simple as --prefix=$whatever --bindir='${pkgname}.app/Contents/MacOS'
05:31:36 <|Steve|> You likely want foo.app/Contents/Info.plist.
05:31:46 <kowey> dcoutts: my version does not have Resources actually and seems to work
05:32:05 <|Steve|> And probably version.plist and maybe PkgInfo.
05:32:11 <kowey> the other thing is that I don't want my user to have to add foo.app/Contents/MacOS to their PATH
05:32:18 <Adamant> gwern: sent
05:32:27 <Adamant> from my iPhone
05:32:29 <Adamant> :P
05:32:32 <kowey> so I rm foo and make foo into a script `dirname $0`/Contents/MacOS/foo "$@"
05:32:33 <gwern> could've just privmsged me, but whatever
05:32:44 <kowey> (which is what I wish could happen automatically)
05:32:57 <Alpounet> it seems we only can do it in Generic Haskell.
05:33:24 <gwern> Adamant: sure you want 'Chris T' as the username?
05:33:28 <|Steve|> kowey: That's not the correct way to open a Mac OS X application.
05:33:47 <Adamant> gwern: we don't have to use our real names?
05:33:52 <gwern> no
05:33:56 <Adamant> hmm
05:33:57 <gwern> you think 'gwern' is my real name?
05:34:13 <kowey> interesting... please elaborate? (note that context is that I [perhaps not many other users]) want a command-line tool that works like it would under Linux
05:34:20 <Adamant> point, but I didn't know if you had a different one for login as opposed to your email
05:34:45 <kowey> ^^ |Steve| (for the request to elaborate)
05:34:47 <|Steve|> kowey: Application bundles aren't used for command line tools.
05:34:58 <kowey> graphical command line tools?
05:35:04 <gwern> Adamant: incidentally, wiki accounts do have a 'real name' fiekld, but it's separate from the username
05:35:09 <|Steve|> How does that even make sense?
05:35:20 <kowey> OK: right now, my symptom is that if I just run ~/.cabal/bin/foo, I get something that displays widgets but doesn't react if you click on them
05:35:20 <Adamant> hmm... 'A Notebook' works
05:35:30 <Adamant> that can be my SN
05:35:36 <gwern> Adamant: fine
05:35:50 <kowey> I want to say geni -m foo -l bar -s baz and it opens a GUI having loaded foo, bar, baz as the m-whatever, l-whatever, s-whatever respectively
05:35:50 <|Steve|> kowey: If you want to open a graphical application, the best way to do it is to use open(1).
05:36:26 <kowey> I want a graphical application that takes command line parameters; I realise it's unusual but I can get one with some hoops and would like to see if I can reduce these hoops
05:37:12 <kowey> open(1) is not acceptable because I can't pass arguments to it.  One example is that I want to be able to have a portable Linux/Mac makefile with a "run-gui" target
05:37:34 <kowey> and for that to work without all sorts of crazy ifdefs, I need my command-line gui
05:37:42 <|Steve|> Graphical applications on Mac OS X doesn't take command line parameters.
05:38:07 <|Steve|> You _can_ launch things by just invoking the binary, but it's not quite the same.
05:38:12 <kowey> well mine does :-)
05:38:23 <kowey> it's not a consumer app I'm trying to build here
05:38:35 <|Steve|> You'd be hard-pressed to find a consumer app that does.
05:38:44 <kowey> this is a research tool that happens to work on a Mac; going without a GUI is not acceptable; going without command line is not acceptable
05:39:28 <kowey> I certainly want to support the double-clicking crowd too, but right now my priority is for the app to work as well under Mac as it does under Linux
05:40:04 <|Steve|> LSOpenApplication() can be given argv parameters.
05:40:26 <|Steve|> (At least in 10.5 and later. It's ignored on Tiger.)
05:40:41 <|Steve|> So with that in mind, it's possible that you could write a small apple script that does it.
05:41:24 <kowey> what are the advantages of doing that wrt to doing it the wrong way (calling the binary from within the bundle?)
05:42:52 <|Steve|> You get a real connection to the window server. I forget what exactly the differences are, but they have caused me problems in the past.
05:43:39 <kowey> OK: so if I understand correctly, the differences between the approaches proposed are to replace a shell script with a more correct applescript, right?
05:43:57 <|Steve|> You can call applescript from within a shell script, if you'd like.
05:44:26 <etpace> hmm RWH sometimes does: foo = function body, and other times: foo =\n    function body, is there a preferred method, and when do I know which one is 'best' to use?
05:44:28 <|Steve|> Something like osascript -e 'tell app "Finder" to open "Foo.app" with properties ...'
05:44:48 <|Steve|> I'm not sure what to put in place of the ... though. The apple script docs are ... uh ... bad.
05:44:48 <kowey> OK, but what I'm getting at is that hopefully, the wrongness of the current shell-script-only approach is orthogonal to my desire to make "cabal install foo" 'just work'
05:45:09 <kowey> i.e. that I can solve 'cabal install foo' first and then worry about doing it right later, right? (hopefully?)
05:45:29 <|Steve|> Possibly.
05:45:46 <|Steve|> I guess it all depends on what it is that foo has to do graphically.
05:45:59 <kowey> OK, so I shall assume that for now - because the problem with requiring manual intervention on the part of my users is that they can't easily upgrade my app
05:46:18 <kowey> because they have to jump through the hoops each time they redo cabal install
05:46:52 <kowey> |Steve| by the way, in case you're curious: http://trac.haskell.org/GenI/wiki/Walkthrough
05:47:11 <|Steve|> Running TextEdit from the command line seems to have no ill effects apart from some message about bootstrap_register() failed.
05:47:47 <|Steve|> Wow, those are old screenshots.
05:47:49 <kowey> it's really not a fancy GUI - just some buttons and some new windows created from time to time
05:48:14 <kowey> you can tell that they're made on a mishmash of versions of OS X
05:48:27 <|Steve|> yeah
05:48:45 <|Steve|> I'm not sure I could identify them all.
05:48:56 <|Steve|> The one with the menu bar was tiger or earlier.
05:49:10 <|Steve|> It's been so long since I've used it that I don't recall.
05:49:20 <kowey> (what annoys me about this is that in Tiger, I could just run geni from ~/.cabal/bin no problem)
05:49:31 <kowey> when I upgraded to Leopard, that stopped working
05:50:27 <kowey> the thing about the Research world is that you get people who are (i) smart (ii) non-technical [don't care about computers] and (iii) command-line lovers
05:50:38 <kowey> (ii) and (iii) may clash ordinarily, but not in research labs
05:51:16 <kowey> hence the problem of making command-line gui apps 'just work' on MacOS
05:52:10 <|Steve|> My field doesn't really have very many non-technical people.
05:53:25 <Philippa> yeah? It definitely happens in compsci
05:54:01 <Jafet> What exactly constitutes a non-technical person
05:54:56 <Philippa> in this case, someone who doesn't want to care about any of the details, just wants the machine to do what it's supposed to
05:55:02 <kowey> I'm not sure how to charecterise it, I guess I would call it an unwillingness to learn about all the intricacies about what's going on under the hood, for example, if the quoting is being interpreted by the shell or by the app
05:55:23 <kowey> which is fair enough because these people have better uses of their time, eg. formulae to scrawl on whiteboards
05:55:48 <Jafet> An abstraction should be as airtight as possible
05:56:18 <Jafet> (Corollary: the above rule is broken *all the time*)
05:56:39 <|Steve|> Philippa: You must be a very different university then.
05:57:35 <kowey> OK, userHooks has a postInst field which looks promising (Cabal)
05:57:48 <Philippa> could be. One with a lot of theoretical compsci types who really shouldn't be expected to care, for example
05:58:47 <|Steve|> Admittedly, I'm a former theory guy, but most of the people here seem pretty technically-oriented still.
06:02:25 <dcoutts> kowey: keep in mind that you cannot do much there, in particular you cannot assume that the dest dir is the final location
06:02:51 <dcoutts> kowey: so you can switch the install paths about but it might all be in some temp dir
06:02:52 <kowey> dcoutts: oh no! I remember you mentioned something like that the last time I tried to solve that
06:03:10 <kowey> OK, what if I just want something that works 90% of the time?
06:03:12 <dcoutts> kowey: but that should be ok for you app since you're just adjusting the installation locations
06:03:35 <dcoutts> and it should work just as well if you're adjusting stuff in a temp image dir as in the real thing
06:03:51 <dcoutts> it's not like you're doing some global registration action or something
06:04:11 <kowey> so create app bundle in temp image dir, rm foo from temp image dir bin and dump shell script in place should *always* work
06:05:02 <dcoutts> kowey: if you can imagine it working in a .deb or .rpm without needing scripts to run at install time, then it's doable
06:05:33 <kowey> it think it should be completely passive, just create the stuff
06:05:44 <kowey> and let cp do the walking
06:06:12 <kowey> since the shell script just uses `dirname $0` to figure out where it is
06:14:36 <etpace> I'm trying to compile a module so I can import it, but I'm getting: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9300#a9300 even though I can load it via ghci
06:14:53 <Saizan_> etpace: ghc --make
06:15:11 <Saizan_> oh, import it?
06:15:29 <edwardk> hrmm. how well do you think something like $(deriveMock ''Num) would work that used template haskell to build a Data.Reflection based mock Num instance, perhaps with some sugar that could let you say something like: test_mock_int = reifyNum [$mock| fromInteger = MockNum; 1 + 2 = 3; abs (-2) = 2; 3 == 3 = True |] 1 (abs (-2)) (\x y -> x + y == 3)
06:15:31 <etpace> yeah
06:15:49 <Saizan_> it might work anyhow
06:15:57 <etpace> I have module Parse where at the top, and im using import Parse from a .hs file inthe same directory
06:16:01 <edwardk> i'm kicking around how messy that would be to get right from a template haskell side
06:17:01 <edwardk> basically deriveMock just makes the newtype and Num instance for it (and transitively the Eq and Show) which is predicated on a Reifies instance that reifies all the right method signatures.
06:18:08 <edwardk> and [$mock| ... |] uses the haskell quasiquoter, extracts the top level definitions and shuffles them into place in the appropriate dictionary slots, filling the rest with mock object errors.
06:18:43 <etpace> hmm, I've done ghc --make parse.hs and it still can't :l foo.hs (the one with import Parse), although :l parse.hs works fine
06:19:04 <Saizan_> etpace: you've to name your file Parse.hs
06:19:50 <Saizan_> edwardk: and the rest of the arguments to reifyNum there?
06:20:41 <edwardk> Saizan_: oh, basically i was thinking that it could take a variadic number of arguments that will be given the appropriate reified type, and plumb them in as arguments to the final lambda.
06:21:14 <etpace> ah, cheers Saizan_
06:21:16 <edwardk> so 1 and (abs (-2) are instances of that particular MockNum s
06:21:38 <Saizan_> ah, i see
06:21:49 <edwardk> i needed to do it that way so i can plumb then into that lambda with known types because the result of the lambda isnt a member of Num.
06:22:14 <edwardk> and otherwise (1 + abs (-2) == 3) -- uses an ambiguous instance of Num.
06:22:33 <edwardk> it may not need to be variadic, perhaps i can just take one.
06:22:51 <edwardk> test_mock_int = reifyNum [$mock| fromInteger = MockNum; 1 + 2 = 3; abs (-2) = 2; 3 == 3 = True |] 1 (\x y -> x + abs (-2) == 3)
06:22:54 <edwardk> er
06:23:06 <Saizan_> s/y//
06:23:07 <edwardk> test_mock_int = reifyNum [$mock| fromInteger = MockNum; 1 + 2 = 3; abs (-2) = 2; 3 == 3 = True |] 1 (\x -> x + abs (-2) == 3)
06:23:10 <edwardk> yeah
06:24:08 <edwardk> I got an email from Yusaku Hashimoto about the idea of using reflection for mock object generation. I replied that i figured TH was the only real solution since it involves code generation
06:24:38 <edwardk> not entirely sure about the [$mock| ... |] quasiquoter, but for big dictionaries like Num it'd be hard not to use something like that
06:25:11 <edwardk> another option might be to make $(deriveMock) also build up an explicit dictionary record type, so you can use record sugar.
06:25:28 <Saizan_> but record sugar sucks
06:25:44 <Saizan_> so you'd need sugar for that as well!
06:26:35 <Saizan_> i thought you were already going to store the methods in some dictionary for the roundtripping, though
06:26:50 <edwardk> reifyNum mockNum { mock_abs = ..., (==!) = (\ ... ) } 1 (\x -> ...)
06:27:08 <edwardk> i am, but right now its a big boring anonymous k-tuple ;)
06:27:55 <Saizan_> hah :)
06:28:35 <edwardk> i suppose if the dictionary is explicitly named then the user could choose between the sugary th version or the raw record sugar one, so you could keep extending a mock instance
06:28:47 <edwardk> by swapping in and out mock methods for it
06:30:45 <Saizan_> that sounds better, yes
06:36:02 <tibbe> @src hIsEOF
06:36:27 <saml> > hIsEOF "\n"
06:36:43 <tibbe> @arr
06:36:54 <aavogt> @bot
06:36:55 <lunabot>  :o
06:37:11 <saml> , hIsEOF "\n"
06:37:13 <lunabot>  luna: Not in scope: `hIsEOF'
06:37:31 <Saizan_> , [$ty| hIsEOF |]
06:37:35 <lunabot>  luna: Exception when trying to run compile-time code:
06:38:31 <Saizan_> ?
06:38:31 <Saizan_> @bot
06:38:31 <Saizan_> someone is stealing our bots?
06:38:31 <lunabot>  :o
06:39:07 <thomastang> hi, I want to study how to write a GUI app. where shall I start?
06:39:56 <aavogt> @botsnack
06:39:56 <lunabot>  :o
06:42:11 <kowey> thomastang: RWH has a nice example showing you how to use gtk2hs... (I personally prefer wxHaskell, but go with what works)
06:42:55 <kowey> thomastang: http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html
06:44:28 <thomastang> I'm using fedora, and I just installed wxHaskell, and compiled the simple example successfully, but when I run it, I was told: ./hello_world: error while loading shared libraries: libwxc-gtk2.8.10-0.11.1.2.so: cannot open shared object file: No such file or directory
06:44:56 <kowey> OK: I know your pain... let me see if it's in our troubleshooting section somewhere
06:45:17 <kowey> thomostang: you should know that there is ongoing work to redo the wxHaskell cabal file so that it works a lot better
06:46:08 <thomastang> does that means I shall wait for the new version to work?
06:46:22 <kowey> http://www.haskell.org/haskellwiki/WxHaskell/Troubleshooting doesn't talk about this :-(
06:46:45 <kowey> thomastang: can you try something for me? it works great on Ubuntu, but it's for a devel version of wxHaskell
06:46:56 <thomastang> sure.
06:47:17 <kowey> git clone git://github.com/bsl/wxdirect
06:47:26 <kowey> git clone git://github.com/bsl/wxcore
06:47:38 <kowey> darcs get http://code.haskell.org/wxhaskell
06:47:58 <kowey> then cabal install in wxdirect, wxcore and wxhaskell/wx respectively in that order
06:48:26 <kowey> if this works, it means that future wxHaskell will just work when you cabal install foo (where foo is an app that requires wxHaskell)
06:51:00 <thomastang> working on it
06:55:09 <Le-Chuck_ITA> Hi there, anybody ever heard of unique image factorizations in categories?
06:59:34 <thomastang> a lot of errors throw out when I cabal install wxcore.
07:00:07 <kowey> warnings?
07:00:21 <thomastang> no error, build failed.
07:00:51 <kowey> oh, I'm sorry to hear that... do you have the header files for wxWidgets installed?
07:01:31 <kowey> thomastang: on Ubuntu, I have this package installed: libwxgtk2.8-dev <-- is there a Fedora equivalent?
07:03:28 <thomastang> I've installed wxGTK-devel, I guess that is libwxgtk2.8-dev on Ubuntu.
07:03:45 <thomastang> I'm using ghc version 6.10.3, is that a problem?
07:03:57 <kowey> I'm using GHC version 6.10.4, so I don't think it's a problem
07:04:12 <kowey> hmm, this works for me on both MacOS X and Ubuntu
07:04:35 <kowey> could I trouble you to send a message to wxhaskell-users@lists.sourceforge.net describing what you've attempted?
07:04:47 <kowey> I was really hoping it would be easy-breezy
07:05:19 <kowey> one thing to include also is what happens when you invoke "wx-config --libs"
07:06:00 <thomastang> -pthread   -lwx_gtk2u_richtext-2.8 -lwx_gtk2u_aui-2.8 -lwx_gtk2u_xrc-2.8 -lwx_gtk2u_qa-2.8 -lwx_gtk2u_html-2.8 -lwx_gtk2u_adv-2.8 -lwx_gtk2u_core-2.8 -lwx_baseu_xml-2.8 -lwx_baseu_net-2.8 -lwx_baseu-2.8
07:06:32 <kowey> ah, sorry, I meant wx-config --cflags
07:06:57 <thomastang> -I/usr/lib64/wx/include/gtk2-unicode-release-2.8 -I/usr/include/wx-2.8 -D_FILE_OFFSET_BITS=64 -D_LARGE_FILES -D__WXGTK__ -pthread
07:07:57 <kowey> I wonder if the lib64 is our clue
07:10:09 <kowey> thomastang: I'm afraid this is getting out of my league technically, so maybe sending a mail to wxhaskell-users is best
07:10:22 <kowey> meanwhile, for your immediate problem, I'll bet it's just a matter of setting LD_LIBRARY_PATH
07:10:54 <kowey> and also to add to my answer about books, here is a somewhat old wikibook chapter on wxHaskell http://en.wikibooks.org/wiki/Haskell/GUI
07:11:13 <ksf> someone tell me what tokenizing is good for.
07:11:15 <kowey> they also now have added XRC support, so in principle working with 3rd party GUI editors should be possible too
07:11:47 <ksf> ...my code just happens to have tokenising and parsing separate right now, but it seems kinda verbose and pointless.
07:12:35 <saml> ksf, tokenizing gives you a stream of tokens
07:12:46 <saml> parsing builds some structure out of the stream
07:13:11 <saml> if you can do it in one shot, that's good
07:13:17 <ksf> ...well, without tokenizing I've got a stream of characters, and can match on tokens with "string" and "char"
07:13:33 <saml> my programming language isn't linear
07:13:39 <ksf> I've got to keep line terminators, anyway, as they're semantically relevant.
07:13:43 <saml> so i need to have a tokenizing pass
07:13:53 <benmachine> I suppose the advantage of tokenising separately is you could easily do macro replacements and similar
07:13:57 <benmachine> or something.
07:14:17 <ksf> I'm parsing ecmascript.
07:14:47 <saml> that's hard
07:15:18 <ksf> well, I'm leaving out most of the awkward squad in the beginning.
07:15:43 <ksf> ...like regexen, string continuations, unicode escapes and any number literal not being [0..9]*
07:17:49 <ksf> actually, I should figure out how to deal cleanly with significant line terminators (inserting ";" in many, but not all places) and then go with whatever design that implies.
07:17:55 * benmachine would pluralise regex as regeces
07:19:13 <ksf> ...as it's the only part of the syntax where whitespace has significance, and getting rid of whitespace is a thing a tokenizer is actually usefull for.
07:20:01 <kowey> dcoutts: could I request some help on using the cabal postInst hook? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9301
07:20:25 <kowey> I have something that works for me (yay!) but I just need to remove the hard-coding of the bindir
07:20:53 <quicksilver> ksf: tokenising is typically a way to improve the complexity class of your parser
07:20:56 <ksf> but that's absolutely contrary to my usual design principles. Usuall I'd just procrastinate the problem until the solution shows up.
07:21:03 <quicksilver> ksf: e.g. you take a parser which requires lookahead
07:21:12 <kowey> I tripped over trying to use absoluteInstallDirs
07:21:23 <quicksilver> ksf: and you turn it into a fast lexer (Which does require bounded lookahead) and a fast parser which doesn't
07:21:31 <ksf> ...filter out matching parens and then match on a strictly linear stream.
07:22:53 <TimMc> Someone hilighted me in this channel, but I think it's beyond the scrollback. o\_/o
07:23:14 <schme> all these beans
07:23:18 <ksf> I guess it's hard enough to write awfully slow parsec parsers so I refuse to worry about being blazingly fast.
07:23:32 <dcoutts> kowey: you can find the bindir from the LocalBuildInfo
07:24:16 <kowey> by reconstructing it from the installDirTemplates?
07:25:08 <ksf> actuall, I should definitely tokenise to get rid of whitespace, I've once wrote a parser that became a mess because it had to allow for whitespace on way too many occasions.
07:25:19 <dcoutts> kowey: yes
07:26:01 <quicksilver> ksf: that's the kind of reason, yes :)
07:26:06 <kowey> OK: so I tried something like absoluteInstallDirs pkgDescr localBuild NoCopyDest and it uh.. blew up
07:26:21 <quicksilver> ksf: dealing with string escaping is another thing which is often neater in a separate pass
07:26:27 <quicksilver> ksf: (often dealt with in the lexer)
07:26:38 <ksf> yep.
07:26:49 <ksf> I intended to do full literal parsing there.
07:26:50 <kowey> what's CopyDest, dcoutts? I'm afraid I didn't understand what "the location prefix for the /copy/ command" meant
07:26:52 <ksf> ...that is, numbers, too.
07:28:04 <ksf> but then the gap between "keyword "if" LParen ... RParen LBrace ... RBrace" to its actual ast representation becomes awfully small.
07:28:15 <dcoutts> kowey: that's the thing that lets you do Setup copy --destdir=tmp/image/
07:28:35 <ksf> ...especially if I do paren matching in the lexer.
07:29:08 <ksf> (and doing that makes the parser look quite awkward, tbh. descending into data structures isn't what parsing is about)
07:29:24 <dcoutts> kowey: since install is going to the actual prefix (it's not the copy action) then it doesn't get supplied with a CopyDest
07:29:40 <dcoutts> kowey: where as the copy hook does get given a CopyDest
07:30:05 <kowey> thanks! ok, so maybe the reason it blew up was because I tried print $ absoluteInstallDir ...
07:30:16 <kowey> maybe bindir $ absoluteInstallDir will work better?
07:30:18 * kowey tries
07:31:58 <kowey> hooray, it does!
07:33:03 <kowey> cool! now I have something that works for my app... next I just need to generalise it a bit, then add support for custom app bundles... progress, thanks, all!
07:33:54 * ksf would like to see support for Executable sections that depend on the Library section in the same .cabal file.
07:35:19 <dcoutts> ksf: it's done already
07:35:34 <quicksilver> dcoutts++ # solving problems before they are raised
07:36:16 <ksf> ...but not in 1.6.0.3, or am I mistaken?
07:36:33 <dcoutts> ksf: right, in 1.8 which isn't released yet
07:36:58 <ksf> i suppose it's going to be released with ghc 6.12?
07:37:02 <dcoutts> yep
07:37:09 <dcoutts> but it'll also work with 6.10
07:37:34 <ksf> So I can have my cake, but I've got to go to the bakery...
07:39:13 <quicksilver> your cake has been baked, but not yet loaded onto the delivery van
07:47:02 <ski> danr,quicksilver : if we had `length :: (exists a. [a]) -> Int', then i think we would have `on (==) length :: (exists a. [a]) -> (exists a. [a]) -> Bool' ..
07:47:53 <quicksilver> ski: agreed.
07:48:17 <quicksilver> ski: or you can just give an explicit type to 'on'
07:49:05 <ski> i wonder how hard it would be to adapt HM to derive these `exists', and when/if you need to give an explicit type, as with higher-rank universals
07:52:13 <edwardk> ski: i seem to recall it being problematic. i'll see if i can find the paper i'm thinking of.
07:52:32 <edwardk> it has the disadvantage that almost everything picks up a type if you aren't careful.
07:52:48 <ski> "picks up a type" ?
07:52:58 <ski> picks up an existential ?
07:52:59 <edwardk> if you infer existentials.
07:53:44 <jokerGTA> hi guys.......is it possible to create backwards list for example   [4..0]  which is list of [4,3,2,1,0]
07:53:53 <ski> [4,3..0]
07:53:53 <edwardk> foo = if True then 1 else () -- becomes foo :: (exists a. a) if you use it naively.
07:54:16 <ski> yes, but we can't do better there, can we ?
07:54:23 <saml> > [4,3 .. 0]
07:54:28 <jokerGTA> thanks guys
07:54:39 <saml> i'm a girl...
07:55:17 <ski> would `if b then ("a",id) else (42,show)' be a better example ?
07:55:18 <edwardk> ski: well, depends, since () and 1 might share instances, perhaps you meant that it returns some value in some Monoid, etc.
07:55:34 <ski> hm .. point
07:56:19 <jokerGTA> sorry sam1
07:56:24 <edwardk> so now the instances you have in scope will infect your types in awkward ways, adding an instance in another module might infect the type you should give locally. craziness ensures. desirable properties are lost.
07:57:09 <edwardk> er ensues
07:57:29 <ski> i see
07:57:52 <ski> do you remember any problem except for this interaction with constraints ?
07:58:12 <quicksilver> ski: I don't think it's significantly different from normal higher rank inference, is it?
07:58:15 <ski> (or if you find the paper, i can check that)
07:58:25 <quicksilver> after all, an existential is just a way to encode (some) higher rank types
07:58:26 <ski> quicksilver : i don't know
07:58:30 <quicksilver> the same problems exist
07:58:37 <ski> it might be simpler
07:58:37 <quicksilver> (greatest unifier not being well defined)
07:59:25 <quicksilver> typeclassees make it even *harder* than normal ;)
08:00:04 <ski> (i mean "rank-1" existentials might be simpler than the corresponding encoding of them)
08:00:34 <Crito> 8
08:00:35 <Crito> err
08:01:28 <ski> (i'm not sure how to sensibly define "rank" here .. maybe `(exists a. ..a..) -> ...' is rank-1 since it is equivalent to `forall a. ..a.. -> ...', while `... -> exists a. ..a..' would be called rank-2 ?)
08:06:46 <Berengal> Types are hard...
08:06:56 <quicksilver> let's go shopping?
08:07:03 <Berengal> I just went
08:07:05 <Berengal> They're still hard
08:07:23 <quicksilver> ski: I'm pretty sure there is a standard asnwer to how ou define rank but I don't know it ;)
08:07:56 <Berengal> I also had this idea, but I can't explain it properly, and there's lots of holes, so it's almost certainly a bad idea. I don't like getting bad ideas...
08:08:42 <dolio> I probably wouldn't use the fact that (quant1 a. P a) -> T is isomorphic to (quant2 a. P a -> T) to say the former is of a lower rank.
08:09:14 <quicksilver> you count the number of quantifiers which either (a) alternate or (b) cross over -> signs, or something?
08:09:24 <dolio> Only if (quant1 a. P a) -> T is the same as quant1 a. P a -> T.
08:09:38 <dolio> For appropriate T of course.
08:09:42 <quicksilver> forall a . a is rank 1, forall a . exists b . (a,b) is rank 2, and so on
08:10:27 <dolio> But (forall a. P a) -> T is rank 2.
08:10:42 <dolio> Or do you mean that'd still be true?
08:10:54 <ski> dolio : but `... -> forall a. ..a..' is isomorphic to `forall a. ... -> ..a..' .. is the former of lower rank ?
08:11:18 <dolio> ski: Yes, probably.
08:11:33 <ski> .. er, misread "wouldn't" as "would"
08:12:50 <ski> maybe this rank business is related to `Pi_n' and `Sigma_n' classes of formulae
08:13:52 <dolio> exists is trickier, though. It has less cases where you can massage things like that.
08:14:21 <quicksilver> ski: I think maybes that's what I was getting confused by
08:14:29 <quicksilver> I think I was thinking of pi_n and sigma_n
08:14:30 <aavogt> speaking of existentials, is it possible to apply a function ((C a, C b) => a -> b) to an existential type (data B where B :: C a => a -> B).  In particular my problem is that the result type of the function depends on the input type.
08:17:10 <quicksilver> aavogt: the example you just gave doesn't ;)
08:17:20 <burp> data ErrorCodes = ErrorA | ErrorB | ErrorC ... instance Show ErrorCodes where show ErrorA = "error description" ... any ideas how to localize the error descriptions / the show instance?
08:17:27 <quicksilver> aavogt: in (C a, C b) => a -> b, the output type is entirely independent of the input type
08:18:19 <quicksilver> burp: well, I don't think Show instances are the right tool for localisation btu I must say I don't know what is :-(
08:19:18 <burp> hm I might use gettext on the show result..
08:19:20 <burp> that's it
08:20:31 <quicksilver> burp: that sounds more promising, yes.
08:22:05 <randomwords> is ghc 6.12 rc 1 still on track for the 14th?
08:23:21 <quicksilver> although, to be honest, show ErrorA should be "ErrorA"
08:23:27 <quicksilver> anything else is a poor Show instance ;)
08:24:46 <burp> so you think I should not misuse the show instance for descriptions? ;)
08:25:03 <aavogt> quicksilver: yeah, it shouldn't be independent, I want to have the function passed to apply2 not have to return a B: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9302#a9302
08:25:27 <burp> maybe make a new class like Describable
08:27:52 <aavogt> quicksilver: I can currently use "apply2 (B . D)", but I want to be able to stick the (B . ) part into the apply function
08:28:23 <aavogt> I have not been able to write the type for that though
08:28:31 <burp> class Describable a where describe :: a -> Locale -> String
08:29:00 <quicksilver> burp: much better imo :)
08:29:14 <quicksilver> aavogt: it wouldn't surprise me if you can't
08:29:30 <quicksilver> aavogt: such slight abstraction failures are the norm with existentials.
08:30:06 <quicksilver> aavogt: .e.g you given a Showable class you can write [ MkS "a", MkS 1, MkS 'c' ]
08:30:10 <Raydiation> phew, the syntax is weird, can anyone else apart from mathematicians use this language effectively?
08:30:21 <quicksilver> aavogt: but you will never be able to write map MkS ["a",1,'c']
08:30:25 <ski> aavogt : the type you want is morally `(forall a. C a => a -> exists b. C b *> b) -> B -> B', no ?
08:30:27 <Saizan_> in this case you could do apply2 :: (forall a. C a => a -> B) -> B -> B
08:30:28 <Saizan_> ops
08:30:41 <Saizan_> apply2 :: (forall a. C a => a -> t a) -> B -> B
08:30:48 <Saizan_> but that's not very flexible
08:31:00 <Saizan_> it will work for D
08:31:44 <Saizan_> uhm, no
08:32:02 <Saizan_> because "forall a. C a => a -> t a" doesn't provide C (t a)
08:32:16 <Raydiation> is Prelude something like a haskell shell?
08:32:38 <ski> maybe you're thinking of `forall a. C a => a -> C (t a) *> t a' ?
08:32:52 <Saizan_> ski: yeah
08:33:13 <ski> Raydiation : you could say so. more common terms are "repl" (read-eval-print-loop), and "interactor"
08:33:26 <Saizan_> Prelude is the default module in scope
08:33:33 <ski> (or "interactive top-level")
08:33:47 <ski> hm
08:33:58 <Saizan_> ghci shows the list of modules in scope in the prompt
08:34:17 * ski was assuming Raydiation was referring to the default `Prelude>' prompt in the interactor
08:34:34 <Raydiation> ski: yes
08:34:57 <Saizan_> right, but the interpreter (or shell if you want) is not called Prelude :)
08:35:13 <ski> *nod*
08:35:25 <Raydiation> in what field of application haskell is used?
08:35:52 <Raydiation> mathematical apps?
08:36:41 <Saizan_> compilers/interpreters, verified [web]applications, developement tools..
08:38:15 <Saizan_> http://www.haskell.org/haskellwiki/Applications_and_libraries <- for a comprehensive list
08:38:29 <Raydiation> Saizan_: ty
08:39:54 <Raydiation> concerning the syntax: isnt shortness at the expense of understanding?
08:40:21 <Elly> not always
08:40:46 <Raydiation> looks like chinese if you know ohter programming languages :)
08:41:17 <kowey> quicksilver: as requested, solution to the 'cabal install gui on MacOS X' problem posted on http://koweycode.blogspot.com/2009/09/cabal-installing-graphical-apps-on.html
08:41:29 <ski> it's a different paradigm from "standard" imperative languages, so it is (a bit) like learning to program anew
08:42:00 <quicksilver> kowey++ # making stuff work and then telling people how he did it for posterity
08:42:13 <quicksilver> kowey++ # so good they karme'ed him twice
08:42:31 <kowey> heh, better wait till somebody else reproduces this
08:42:46 <ski> quicksilver : just remember to redo that when lambdabot is no longer comatose ..
08:43:18 <ksf> most of the terseness comes from the fact that equivalents to while (*rp++ = *p++); are considered good style in haskell.
08:43:25 <hackagebot> JsContracts 0.5.1 - Design-by-contract for JavaScript (ArjunGuha)
08:43:59 <ski> equivalents, how ?
08:44:34 <ksf> also, out of a design descision: screen estate is sparse, and it helps if a function actually fits onto one screen.
08:44:36 <ski> you mean things that doesn't needlessly mention indices or other points ?
08:45:08 <Igloo> dcoutts, kowey: It would be good to get that folded into the Simple build system, as Custom Setup scripts are a pain
08:45:18 <dcoutts> indeed
08:45:19 <ski> (like `squareAll = map square' instead of `squareAll xs = map square xs')
08:45:36 <ksf> equivalent in the sense of "beginners won't think of that"
08:46:45 <ksf> > uncurry (++) . (toUpper *** toLower) $ ("Foo","Bar")
08:46:48 <ksf> and stuff.
08:46:57 <jeltsch> Hello, can anyone tell me the RSA fingerprint of the SSH server on community.haskell.org.
08:47:10 <ksf> there's definitely ways to write that in a way that's easier to understand for beginners.
08:47:25 <ksf> ...even though it's not obfuscated, at all.
08:47:31 <abbe> jeltsch: 61:fb:46:e2:c8:c0:05:84:e5:6f:b4:f3:fa:73:97:bf
08:47:35 <tavelram> @src words
08:47:36 <Elly> @hoogle ***
08:47:45 <jeltsch> abbe: Thank you.
08:47:50 <ksf> @botsmack
08:47:50 <lunabot>  :o
08:47:59 <ski> (***) :: Arrow ar => ar a0 b0 -> ar a1 b1 -> ar (a0,a1) (b0,b1)
08:48:00 <poe> (f *** g) (x,y) = (f x, g y)
08:48:02 <jeltsch> abbe: Did you receive this fingerprint via a secure way?
08:48:12 <Axman6> Cale: lambdabot seems to have died again :(
08:48:21 <ski> Axman6 : he's aware
08:48:25 <abbe> jeltsch: i've an account on code.haskell.org which has CNAME to community.haskell.org
08:48:33 <Axman6> ok, good to know :)
08:48:41 <ksf> ski, lambdabot's a she.
08:48:55 <ski> ksf : i know. but Cale's not
08:49:10 <abbe> jeltsch: i logged in to both, community.haskell.org prompted me, whereas code.haskell.org hasn't prompted me, as it is listed in my known_hosts file.
08:49:44 <jeltsch> abbe: How did you get the public key of code.haskell.org for your know_hosts file.
08:50:14 <abbe> jeltsch: i uploaded couple of files to it in july, IIRC.
08:50:20 <dcoutts> kowey: can you make sure there is a proper feature request Cabal ticket filed, link to your blog post and the custom Setup.hs, also Apple docs on app bundles
08:50:38 <kowey> dcoutts: OK; I'm on it
08:50:45 <dcoutts> kowey: ta
08:50:58 <abbe> jeltsch: i trusted the key, first time i logged in. i've not confirmed it with anyone.
08:51:11 <jeltsch> abbe: Okay, this is what I wanted to know.
08:51:16 <abbe> jeltsch: the files i uploaded are visible on code.haskell.org
08:51:43 <ksf> ...which doesnt' mean you weren't man-in-the-middled.
08:51:45 <jeltsch> This is only a proof if you access code.haskell.org via HTTPS or so. :-)
08:52:02 <jeltsch> ksf: Exactly, this is what I wanted to say.
08:52:28 <jeltsch> Is there anyone who knows the fingerprint for sure?
08:52:35 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9303#a9303 <- sigh, orphan instances woes
08:53:03 <pozic> jeltsch: the only way to know for sure is to have a chain of trust already establised.
08:53:14 <abbe> ksf: so you mean to say, someone poisoned my, my friends's and rest of the world's DNS cache for code.haskell.org, and created a account for me on their server, right ?
08:53:18 <Philonous> Is there a way to just export everything from a module?
08:53:19 <pozic> jeltsch: someone telling you in this IRC channel won't help.
08:53:23 <ksf> otoh, doing a man-in-the-middle on the internet is a hell of a task, if you don't happen to be an isp employee.
08:53:36 <jfoutz> is there a zippable class? sorta like Traversable t => (a -> b -> c) -> t a -> t b -> t c ? maybe that only makes sense if both t's have the same shape.
08:54:00 <Saizan_> Philonous: if you don't give it an export list it will export all the identifiers defined in it
08:54:09 <pozic> ksf: criminal organisations probably can walk in and out of ISP networks.
08:54:13 <Philonous> Saizan_: Ah, great, thanks!
08:54:14 <jeltsch> pozic: The fingerprint could be published on code.haskell.org via HTTPS.
08:54:20 <ksf> you could ask spj to read the public key on his next talk.
08:54:28 <jeltsch> pozic: Yes, the channel is insecure. :-(
08:54:32 <ksf> but then we could have impersonators.
08:55:41 <jeltsch> ksf: Waiting for the next SPJ talk I attend would be a bit hard. ;-)
08:56:45 <Saizan_> "While we require that all content on the community server is publically available, [..]" so why do you need so much security?
08:56:56 <abbe> Is ICFP going on currently ?
08:57:11 <Raydiation> would you say haskell is an important language in the open source community?
08:57:27 <Saizan_> it ended last week, afaik
08:57:40 <abbe> oh, okay.
08:58:11 <mapreduce> Raydiation: I'd say it's an important language.  It is also open source.
08:58:27 <mapreduce> But that's like saying that Steve Jobs is an important man in the over-40s community.
08:58:37 <Raydiation> ye i know its very subjective
08:59:19 <Raydiation> ive always heard stuff like "you have to learn haskell to understand functional programming"
08:59:26 <aavogt> ski: I'm not sure what you mean, what does *> mean in a type?
08:59:59 <Raydiation> that was pretty much the only argument :/
09:00:45 <Saizan_> "and functional programming is good"
09:00:59 <Saizan_> then you can ask why :)
09:01:20 <Raydiation> hehe, the hype is more about OOP
09:02:16 <mapreduce> Raydiation: Seeing as functional programming predates Haskell, that statement is false.
09:02:33 <mapreduce> However, Haskell is worth learning if you want to understand FP.
09:02:49 <aavogt> ski: and is that possible to encode in Haskell?
09:03:45 <Saizan_> it's not just to learn FP however, haskell is already a very practical, and increasily so, programming language
09:04:54 <Saizan_> though there aren't many open source projects with big teams using it yet, afaik
09:05:00 <Raydiation> at my university 3 languages are mainly taught: java, C and haskell
09:05:20 <Raydiation> covering basics :)
09:05:38 <kowey> dcoutts: here you go http://hackage.haskell.org/trac/hackage/ticket/583
09:05:48 <Axman6> Raydiation: haskell's concurrency stuff is beautiful, and parallelism is dead easy (sometimes too easy and you make things too parallel. that's when the fun starts ;))
09:06:36 <Philonous> Axman6: Well, doing it right is still hard. It's easy to just throw in some pars, but that doesn't mean you will get any extra performance for free.
09:06:43 <Axman6> Raydiation: i've been pretty lucky at my uni, we've covered (in order): Haskell, Java, C, Assembly, Ada
09:07:07 <Axman6> Philonous: indeed, hence the second part inside the brackets :)
09:07:32 <Axman6> making thinks parallel is easy. making them parallel and fast isn't so much
09:07:52 <Polarina> Axman6: Lucky you.
09:07:52 <Raydiation> intended for multicore usage?
09:08:09 <Axman6> but, at least it's easy to actually get the parallelism in the first place. many languages make it hard just to get there
09:08:26 <Axman6> Raydiation: how else do you do concurrency/parallelism? :)
09:08:34 <quicksilver> forkIO + MVar is a whole world nicer than the mutable shared memory concurrency you get in Java/C like languages
09:08:47 <Axman6> indeed
09:09:18 <Axman6> threading in Java isn't too bad, but i'd like it a hell of a lot more if they had nice protected objects like Ada
09:09:33 <Raydiation> i heard Ada was a dead end :)
09:09:40 <Raydiation> and horrible language
09:09:41 <Axman6> if you want to see how concurrency should be done in a C like language, look at Ada
09:10:17 <Axman6> Ada is actually very nice. it's somewhat ugly, and very verbose, but that's because it was designed to be read, not written
09:10:33 <Axman6> its concurrency stuff is fantastic
09:11:13 <jperras> if you feel like programming ballistic missle guidance systems, Ada is a good thing to learn
09:11:17 <Axman6> and Ada is certainly not dead. it's used a lot by companies like boing where they have to have correct programs, according to many measures
09:11:28 <Raydiation> i miss scripting languages like python, php or perl a bit
09:11:34 <Axman6> jperras: it's actually very nice for many large languages
09:11:41 <quicksilver> Axman6: well the point about java is not that it's syntactically hard - the threading primitives are easy enough to use
09:11:43 <Axman6> uh, projects, not languages
09:11:47 <Raydiation> somehow regarded as not important on universities
09:12:00 <jperras> makes more sense now ;-)
09:12:04 <quicksilver> Axman6: the point is that mutating one object form another object's thread is just waiting to shoot yourself in the foot
09:12:04 <Raydiation> though widely used
09:12:20 <quicksilver> Axman6: and then if you use the java locking support you have to think moderately carefully or your dealock
09:12:34 <Axman6> Raydiation: they don't follow much theory, so they're taught
09:12:40 <quicksilver> Raydiation: I think they're just not very interesting for a teacher
09:12:45 <quicksilver> there's not much to say about them
09:12:57 <quicksilver> any idiot who already knows how to program can pick up python/perl/ruby in about 3 days
09:13:08 <quicksilver> but they won't learn anything exciting and new in the process.
09:13:15 <quicksilver> (and I program perl for my day job)
09:13:15 <Axman6> quicksilver: indeed. one of the reasons i like Ada is that a lot of that has been very well thought through, and very nice answers have been developed
09:13:21 <quicksilver> Axman6: quite.
09:13:35 <quicksilver> Axman6: and I wont' even mention C/C++/s mutexes and condvars ;)
09:13:51 <Axman6> heh... yeah, my concurrency course is moving onto them next week :)
09:13:58 <Zao> quicksilver: What synchronization primities?
09:14:01 <Zao> There's none until 1x :)
09:14:05 <Axman6> concurrent programming in POSIX
09:14:27 <quicksilver> Zao: well mutex/condvar exist, but they're library facilities not language ones
09:14:57 <Zao> If by "library" you mean platform, sure.
09:15:06 <quicksilver> library+platform, yes.
09:15:27 <Zao> The 1998/2003 C++ library has nothing thread related.
09:15:36 * quicksilver nods
09:15:40 <quicksilver> but pthreads exists.
09:15:44 <Zao> I can't say anything about C, but I'd quite doubt there's anything there either.
09:15:48 <quicksilver> and you can use it from C++, and people do.
09:15:51 <Zao> quicksilver: pthreads is not part of C or C++.
09:15:55 <quicksilver> agreed.
09:15:57 <quicksilver> I never said it way.
09:16:02 <quicksilver> people use it though.
09:16:06 <Zao> Naturally.
09:16:08 <quicksilver> it's relevant to the question of threading in C/C++
09:16:10 <Axman6> Ada's protected objects are very nice indeed. you can define functions (pure, so you can have multiple readers), procedures (which can modify the object, under mkutual exclusion), and entries, which are procedures, but with guard conditions, which cause the caller to wait until the guard is satisfied
09:16:14 <Zao> Not using what your platform gave you would be silly.
09:16:16 <quicksilver> because it is what many people use.
09:16:55 <Axman6> C and POSIX are quite closely linked right?
09:17:15 <Zao> Not on my platform.
09:17:30 <Zao> POSIX has those icky file descriptors and lots of syscalls.
09:17:34 <Raydiation> quicksilver: hehe right, but imho a programming language should be easy
09:18:10 <Axman6> Raydiation: haskell's easy, once you get the hang of it
09:18:11 <Jafet> In particular, POSIX contains a more-or-less complete C library
09:18:24 <Zao> Axman6: As C is the typical systems programming language as well as the language of the kernel on most POSIX systems, it's quite C friendly.
09:18:59 <Zao> I thank $diety for Boost.Thread.
09:19:40 <Raydiation> Axman6: does haskell use pointers a lot like C?
09:19:53 <Axman6> thanks SPJ et al. for Control.{Concurrent,Parallel} ;)
09:20:01 <Axman6> Raydiation: god no :)
09:20:02 <Zao> Raydiation: There's IORef and similiar types to be pointer-like.
09:20:15 <Raydiation> manual memory management?
09:20:22 <Zao> Raydiation: As well as the Foreign hierarchy to interop with lesser languages.
09:20:29 <Axman6> Raydiation: you can use pointer like things, but haskell goes out of its way to make it hard most of the time
09:20:37 <Zao> Very little normal code ever does memory management like C.
09:20:41 <Axman6> Raydiation: again, it's there, but not for beginners
09:20:48 <Raydiation> great :)
09:20:50 <Zao> Raydiation: There's a nice and shiny GC backend.
09:20:54 <Saizan_> Raydiation: the idiomatic haskell code doesn't use pointers nor manual memory management
09:21:25 <Axman6> Raydiation: see, memory management is a little hard, when you're working with things like infinite datastructures
09:21:25 <Axman6> , [1..]
09:21:25 <Saizan_> but those lowlevel bits are accessible if you need them
09:21:26 <Axman6> lunabot!
09:21:28 <lunabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
09:21:32 <Axman6> thank you
09:21:55 <Raydiation> Axman6: haha, true
09:23:16 <Axman6> Raydiation: since haskell is a lazy language, things like infinite lists consume finite (small) space.
09:23:36 <Axman6> becasue things aren't evaluated until they are needed.
09:23:57 <Axman6> it's often possible to totally optimise out data structures
09:25:03 <Raydiation> any book you can recommend for beginners?
09:25:45 <mauke> preflex: ? lyah
09:25:46 <preflex>  http://learnyouahaskell.com/
09:25:47 <Axman6> www.learnyouahaskell.com is a good start. then Real World Haskell after that
09:26:03 <Axman6> preflex: ? RWH
09:26:03 <preflex>  factoid not found
09:26:05 <Axman6> :(
09:26:09 <mauke> preflex: ? rwh
09:26:09 <preflex>  factoid not found
09:26:14 <mauke> really?
09:26:23 <Axman6> preflex: ? really
09:26:23 <preflex>  factoid not found
09:26:24 <jnwhiteh> Does anyone know of a commstime concurrent network written using CHP (http://www.cs.kent.ac.uk/projects/ofa/chp/)?
09:26:27 <Axman6> really :(
09:26:37 <mauke> preflex: + rwh http://book.realworldhaskell.org/read/
09:27:09 <Raydiation> ty
09:28:06 <Axman6> Raydiation: be warned, haskell will seem strange for a while. then you'll get it, and wonder why everyone else is stuck using other crappy languages
09:28:20 * cygnus nods at Axman6
09:28:50 <Polarina> Axman6: :D
09:29:29 <Axman6> Raydiation: dunno if you'd be interested or not, but here's someone's pong game written in 127 lines of haskell: http://github.com/kamatsu/pongell/blob/3f7c467330210155de6bbfd1281c56089d52092f/pong.hs
09:30:31 <Zao> Axman6: I've gone back to C++ from Haskell, as I can "get stuff done" there.
09:30:38 <Raydiation> Axman6: haha, ill take a look at that :)
09:31:02 <Zao> Maybe if Haskell had a decent DirectX library.
09:31:36 <|randomwords|> Zao: Why cant you use OpenGL?
09:32:01 <Zao> |randomwords|: I do not wish to start an API war, but I much consider DirectX and especially Direct3D superior.
09:32:07 <Zao> For me.
09:32:17 <jmcarthur_work> |randomwords|, while i prefer opengl since it's cross platform, direct 3d has a much nicer low level api
09:32:32 <|randomwords|> Ok - it wasn't accusatory, I don't really know much about this stuff.
09:32:32 <Raydiation> i like the illustrations in learnyouahaskell.com :)
09:32:42 <jmcarthur_work> and we don't really have well supported high level haskell interfaces for opengl yet
09:32:47 <|randomwords|> jmcarthur_work: Could you give an example?
09:32:52 <Raydiation> Zao: nice band btw :)
09:32:58 <Axman6> Raydiation: that's how they getchya!
09:34:42 <Axman6> damn, that pong game is really clear
09:34:49 <Raydiation> function(arg) does not work i suppose
09:34:51 <|randomwords|> hponh?
09:35:19 <Zao> Raydiation: Except having superfluous parenthesis, it works.
09:35:22 <aavogt> Raydiation: it does, but don't do it :)
09:35:37 <Zao> > let f x y z = x * y * z in f 42 3 5
09:35:48 <mauke> > ((2)) + ((2))
09:35:49 <Zao> Raydiation: Function application is done with spaces.
09:35:51 <Raydiation> is there any reason for not using the () for functions?
09:35:57 <mauke> , ((2)) + ((2))
09:35:58 <lunabot>  4
09:35:59 <Zao> Raydiation: Multiple arguments.
09:36:07 <mauke> Raydiation: too much work
09:36:11 <Zao> f x y   is   ((f x) y)
09:36:11 <Axman6> Raydiation: because all functions only take in one argument...
09:36:21 * cygnus nods
09:36:23 <Raydiation> huh?
09:36:23 <Axman6> well, maybe that's not the reason, but it's useful to know ;)
09:36:37 <Axman6> , type "map"
09:36:38 <lunabot>  luna: parse error on input `type'
09:36:42 <Zao> f(x,y) would be a function taking a single argument, a tuple with elements x and y.
09:36:42 <Axman6> bah
09:37:27 <Axman6> Raydiation: read LYAH, then once you've seen some type signatures, we can talk about why functions only take one argument (but can return other functions)
09:37:27 <Philonous> Function application is so important is haskell, that they chose to use the least noisy operator for it, namely none.
09:37:29 <Raydiation> it kinda resembles: int var
09:38:03 <Axman6> eh?
09:38:04 <Raydiation> typing vars as functions
09:38:27 <mauke> it resembles something else even more: sizeof :-)
09:38:40 <pao> @unmtl MaybeT (IO Int)
09:38:48 <Jafet> (sizeof) x
09:38:54 <jmcarthur_work> apparently that sizeof doesn't require parens is not widely known...
09:38:56 <Axman6> lambdabot's dead atm pao
09:39:00 <mauke> Jafet: denied!
09:39:08 <Jafet> Darn
09:39:10 <Vanadium> sizeof int
09:39:10 <pao> Axman6: thanks, is there any replacement?
09:39:11 <Vanadium> :|
09:39:14 <mauke> jmcarthur_work: s/require/care about/
09:39:22 <Axman6> not for that i don't think
09:39:26 <ukl> hmm... I think there's something wrong with Network.Shpider: 'runShpider $ download "http://www.google.com/" >> currentForms' gives [].
09:39:31 <dolio> MaybeT isn't in the mtl anyhow.
09:39:48 <Raydiation> could you say, while in ruby everything is an object, in haskell everything is a function
09:39:56 <jmcarthur_work> no
09:40:03 <jmcarthur_work> an Int isn't a function
09:40:03 <Axman6> Raydiation: pretty close though
09:40:11 <mauke> most things aren't functions
09:40:13 <dolio> Also, it should be 'MaybeT IO Int'.
09:40:22 <dolio> Which expands to IO (Maybe Int).
09:40:44 * Axman6 thinks you could argue that an Int is a function that takes no arguments, but won't
09:41:23 <mauke> you could also argue that an Int is a butterfly that has no wings
09:41:29 <Raydiation> hehe
09:42:10 <Axman6> Raydiation: anyway, going back to what i said about functions only taking one arguement, i'll give you an example
09:42:41 <jmcarthur_work> Raydiation, the main sense that haskell might be considered turtles all the way down is that it follows a type theory that isn't as ad hoc as that of many languages
09:42:49 <Axman6> the plus function has the type: (+) :: Int -> Int -> Int, it takes an Int, and another Int, and returns an Int
09:43:03 <mauke> , (+) 2 3
09:43:03 <Veinor> No, it takes an int and returns a function that takes an int and returns an int :P
09:43:04 <lunabot>  5
09:43:31 <Veinor> But for most purposes Axman6 is right.
09:43:37 <jmcarthur_work> Veinor, of course, we say functions take n arguments as a shorthand for that
09:43:37 <Axman6> but what that type actually is is: (+) :: Int -> (Int -> Int), a function which takes an int, and returns a function which takes an int, and returns an int
09:43:39 <mauke> , let add2 = (+) 2 in (add2 3, add2 20, add2 0)
09:43:40 <lunabot>  (5,22,2)
09:44:01 <Veinor> Yeah, you can do partial application which is seriously neat.
09:44:07 <Raydiation> Axman6: recursive?
09:44:11 <dolio> Veinor: You totally stole his thunder.
09:44:16 <Axman6> Raydiation: so if you write (2+), that is the function which adds 2 to things
09:44:16 <Veinor> :D
09:44:29 * Axman6 /kicks Veinor 
09:44:39 <Veinor> D:
09:45:32 * Axman6 grumbles that no one steals Cale's thunder when he's teaching magic :(
09:45:53 <dolio> I'm not sure sectioning is a good demonstration, because you can section at the second parameter as well.
09:46:12 <Axman6> yeah
09:46:28 <Raydiation> Axman6: thx for your help so far, im going to get some food, god bless freenode :P
09:46:29 <Axman6> i can just never think of a nice function to use as an exmaple :)
09:46:33 <dolio> Even if (+) were :: (Int,Int) -> Int, the sectioning syntax could be defined to do (a+) = \x -> (+) (a,x) and so on.
09:46:42 <Axman6> and i'm going to go to sleep. night all
09:46:49 <Raydiation> nite
09:47:40 <Veinor> Night.
09:47:57 <Axman6> Raydiation: please do stick around and ask questions, you'll find that one of the best things about haskell is its community. plenty of very intelligent people, who will all treat you nicely, and be more than happy to answer your questions
09:48:11 <Veinor> Yeah, the community in here has been very helpful. :D
09:48:24 <Axman6> (it's probably not a coincidence that #haskell is one of the largest channels on freenode)
09:50:49 <Tobsan> does anyone know if readChan will block?
09:51:27 <jmcarthur_work> :t readChan
09:51:38 <Philonous> Heh, I just noticed how (,) is not the binary product in the Cat of haskell types, so haskell types are not a CCC? That's bad. That means currying is in fact not an isomorphism.
09:51:51 <dolio> Tobsan: I think so.
09:51:55 <Ornedan> Tobsan: It will
09:51:58 <jmcarthur_work> @bot
09:51:58 <lunabot>  :o
09:52:08 <jmcarthur_work> lambdabot?
09:52:11 <Tobsan> Alright :)
09:53:31 <dolio> Philonous: Yeah, currying and uncurrying changes \(_,_) -> e into \_ -> e, I believe.
09:54:13 <Ornedan> Is it possible to determine status of non-child process (on Linux)?
09:54:21 <dolio> Haskell isn't a category anyway, because composition with identity changes definedness.
09:54:24 <quicksilver> Philonous: yup, to make Hask into a useful category you need to pretend _|_ doesn't exist.
09:54:28 <dolio> And you can detect that with seq.
09:54:50 <Veinor> Ornedan: Status?
09:54:53 <Philonous> quicksilver: Yes. That gives you back initial objects as well
09:54:57 <quicksilver> > (id . undefined) `seq` "this is OK"
09:55:05 <quicksilver> , (id . undefined) `seq` "this is OK"
09:55:07 <lunabot>  "this is OK"
09:55:10 <Ornedan> Veinor: Pretty much whether one's alive or dead
09:55:16 <Veinor> using ps?
09:55:17 <quicksilver> , undefined `seq` "but this isn't, obviously"
09:55:18 <lunabot>  luna: Prelude.undefined
09:55:26 <mauke> Ornedan: that can be done with kill
09:55:46 <Veinor> I like how (id . undefined) has the type a -> b
09:56:08 <dolio> We talked about this last night in haskell-in-depth.
09:56:13 <Ornedan> From Haskell code
09:56:23 <Veinor> run ps, parse the output? :P
09:56:40 <Ornedan> Ew :P. Saner ways?
09:56:51 <mauke> use kill
09:56:52 <dolio> If you eliminate seq, Hask should be a CCC (I think) if you consider actual products, which should be unlifted pairs, I think.
09:56:58 <hackagebot> hfractal 0.3.1 - OpenGL fractal renderer (ChrisHoldsworth)
09:57:22 <dolio> But I'm not sure there's any good way to have unlifted pairs.
09:57:36 <Veinor> @hoogle process
09:57:51 <Veinor> Hm.
09:58:02 <Ornedan> mauke: kill as in call external program or something else?
09:58:04 <Philonous> dolio: I like getting rid of _|_ better, because i gives you initial objects.
09:58:06 <dolio> That is, to implement them in current Haskell (even with unamb magic, I think there are still problems).
09:58:06 <yav> dolio: you could have unlifted pairs without seq and if pattern matching in pairs was lazy (what you get when using ~)
09:58:10 <mauke> Ornedan: as in the function
09:59:01 <Ornedan> mauke: From library? A quick Hoogle search only found killThread
09:59:15 <mauke> ah, there
09:59:22 <mauke> System.Posix.Signals
09:59:35 <mauke> signalProcess nullSignal pid
09:59:44 <dolio> yav: Yeah. That requires a syntactic transformation of your code (or adhering to the style manually), though. There's no way to define a type that works like unlifted pairs automatically.
10:00:11 <yav> dolio: yes, not in Haskell as it is.
10:00:29 <Ornedan> mauke: That causes exception if the target process doesn't exist?
10:00:34 <mauke> yeah
10:00:56 <mauke> it'll return -1 with errno = ESRCH; not sure which exception that is mapped to
10:01:12 <jmcarthur_work> wait, i'm confused about id . undefined. why is that not _|_?
10:01:18 <yav> the usual way to think of a haskell as a category is to use terms (expressions) as the arrows though.
10:01:32 <jmcarthur_work> i assume it still would be if it was applied
10:01:33 <dolio> id . undefined = \x -> id (undefined x)
10:01:37 <mauke> probably a doesNotExistErrorType
10:01:53 <jmcarthur_work> oh, i see
10:02:06 <dolio> (id . undefined) `seq` () just checks to see if its first argument evaluates to a lambda.
10:02:34 <jmcarthur_work> it's because of composition, not because of id
10:02:40 <dolio> (Or a not-fully-applied primop)
10:02:46 <mauke> undefined . undefined
10:02:47 <jmcarthur_work> if composition was strict it would be okay?
10:02:58 <yav> jmcarthur_work: the problem is that, technically, functions in haskell are not extensional, as undefined and \_ -> undefined behave the same way but are not the same, as distinguihed by seq
10:03:44 <Ornedan> mauke: Ok, thanks
10:04:04 <jmcarthur_work> f . g = f `seq` g `seq` (\x -> f (g x))    -- would that make id and (.) a category?
10:04:24 <yav> jmcarthur_work: no
10:04:36 <yav> i think :)
10:05:07 <jmcarthur_work> > let f . g = f `seq` g `seq` (\x -> f (g x)) in (id . undefined) `seq` "is this okay?"
10:05:13 <jmcarthur_work> ugh
10:05:17 <jmcarthur_work> , let f . g = f `seq` g `seq` (\x -> f (g x)) in (id . undefined) `seq` "is this okay?"
10:05:18 <lunabot>  luna: Prelude.undefined
10:05:30 <jmcarthur_work> , let f . g = f `seq` g `seq` (\x -> f (g x)) in (undefined . id) `seq` "is this okay?"
10:05:32 <lunabot>  luna: Prelude.undefined
10:06:03 <jmcarthur_work> looks alright to me!
10:06:05 <yav> hm, i am changing my ming
10:06:10 <yav> mind
10:06:50 <jmcarthur_work> also, i don't see any harm in making composition strict. is there any reason we don't have it this way?
10:07:31 <jmcarthur_work> maybe because it's just not all that important if we ignore seq?
10:07:44 <yav> well, it would change how things worked, if "f" discarded its argument, for example
10:08:02 <jmcarthur_work> how so?
10:08:27 <dolio> , let f . g = f `seq` g `seq` (\x -> f (g x)) in foldr (.) id $ repeat (1:)
10:08:28 <yav> well. (\_ -> 3) . undefined
10:08:29 <lunabot>  luna: No instance for (GHC.Show.Show ([a] -> [a]))
10:08:35 <jmcarthur_work> , let f . g = f `seq` g `seq` (\x -> f (g x)) in (const "foo") . (+1) $ 5
10:08:37 <lunabot>  "foo"
10:08:43 <jmcarthur_work> , let f . g = f `seq` g `seq` (\x -> f (g x)) in (const "foo") . undefined $ 5
10:08:44 <dolio> , let f . g = f `seq` g `seq` (\x -> f (g x)) in foldr (.) id (repeat (1:)) []
10:08:44 <lunabot>  luna: Prelude.undefined
10:08:45 <lunabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:09:02 <jmcarthur_work> , (const "foo") . undefined $ 5
10:09:02 <lunabot>  "foo"
10:09:05 <jmcarthur_work> aha
10:10:25 <dolio> Anyhow, seq is bad enough already.
10:10:55 <yav> jmcarthur_work: but i think that you are right that with the strict composition the category laws hold for id and (.), which I think is interesting
10:11:15 <jmcarthur_work> i guess it makes sense to simply ignore seq when reasoning about a lot of things like this
10:11:15 <dolio> Throwing it around into other functions to fix problems it creates doesn't sound great.
10:11:33 <jmcarthur_work> dolio, agreed
10:12:05 <ksf> why? we use computers to fix problems we wouldn't have without them...
10:12:08 <ksf> ...all the time.
10:12:40 <yav> yeah, i am working one of those right now :)
10:13:06 <yav> (or rather irc-ing when i should be doing it)
10:13:55 <dolio> The underlying problem is that seq breaks eta equality of functions.
10:14:15 <dolio> Making composition strict doesn't fix that, it just prevents the broken eta from technically making Hask not a category.
10:14:22 <yav> yeah, that's what i was trying to say above with functions not being extensional
10:16:07 <yav> i mostly "seq" on ground types anyway, so i always thought that the olden days approach of putting seq in a type class was the right way to go.
10:16:38 <dolio> Strangely enough, even when seq was in a type class, it still worked on functions.
10:17:27 <jmcarthur_work> wait, when was seq in a type class?
10:17:38 <jmcarthur_work> and why was it taken out of a type class?
10:17:40 <dolio> Haskell 1.4 and prior, I think.
10:18:02 <jmcarthur_work> because that approach sounds a lot better to me
10:18:23 <dolio> Because it was inconvenient to have to add an 'Eval a =>' constraint (or whatever it was called) to make an argument to a function artificially strict.
10:18:36 <FunctorSalad> NFData?
10:18:39 <yav> dolio: well, i am not sure what the instance was, but for some functions it makes sense
10:18:51 <jmcarthur_work> meh. i don't think seq should have to be convenient anyway
10:19:02 <FunctorSalad> @seq jmcarthur_work
10:19:23 <dolio> yav: It does?
10:20:03 <dolio> Anyhow, the instances were specified to be declared automatically by the compiler. So I imagine it wasn't any different than it is now.
10:20:05 <yav> dolio: you can force a function by applying to an argument and forcing the result
10:20:46 <jmcarthur_work> yav, wouldn't that have to be a polymorphic argument?
10:20:52 <FunctorSalad> how could the instances for an seq/Eval class be written? it's a magical primitive after all
10:21:02 <jmcarthur_work> FunctorSalad, pattern matching
10:21:12 <jmcarthur_work> oh wait
10:21:19 <jmcarthur_work> yeah, that'd do it
10:21:25 <FunctorSalad> oh right
10:21:27 <jmcarthur_work> seq (Just _) a = a
10:21:30 <jmcarthur_work> and so on
10:21:41 <yav> jmcarthur_work: an instance could look something like this: instance (NonEnpty a, Seq b) => Seq (a -> b)
10:22:01 <dolio> yav: I don't think that works.
10:22:17 <yav> dolio: hm. why not?
10:22:23 <dolio> \5 -> () is not bottom, but it returns bottom for any argument other than 5.
10:22:51 <dolio> So you need to try it for all possible arguments.
10:23:14 <yav> dolio: oh no.  all we need is to evaluate the thunk that is the function.  the result does not matter.
10:23:44 <jmcarthur_work> seq f a | f val `seq` True = a
10:24:01 <jmcarthur_work> where val is in the NonEmpty type class
10:24:03 <dolio> You can't seq the result, though, unless you pick the one argument that returns non-bottom.
10:24:13 <dolio> Otherwise you'll get bottom for the whole expression.
10:24:16 <jmcarthur_work> ah, right
10:24:53 <|randomwords|> Why do all the haskell articles on reddit/programming get systematically downvoted?
10:25:12 <jmcarthur_work> |randomwords|, a lot of people on reddit think haskellers are spamming/trolling or something
10:25:24 <|randomwords|> shame
10:25:49 <jmcarthur_work> "haskell is *academic*, so all these haskell articles shouldn't be here!" or something
10:25:51 <dolio> Haskell used to be popular, so now it's hip to be against it. :)
10:26:18 <arw_> language-hip-ness changes faster than most underpants...
10:26:35 <FunctorSalad> :o
10:26:56 <|randomwords|> so what's the zeitgeist's current hip language?
10:27:21 <dolio> For what it's worth, there did used to be a lot of useless "I just tried haskell for the first time; quicksort rulz" blog posts showing up on the programming reddit.
10:27:53 <arw_> currently lua, after ruby went out of fashion i think...
10:28:06 <yav> dolio: yeah, i think that you are right.
10:28:13 <FunctorSalad> we need some celebrity to endorse haskell
10:28:13 <jmcarthur_work> i also understand that a lot of people don't really appreciate a flood of academic pdfs taking the places where their python blog articles should go
10:28:19 <FunctorSalad> ;)
10:28:39 <jmcarthur_work> i want to see Io get some craze on reddit
10:28:51 <jmcarthur_work> but i guess that's too small
10:29:09 <dolio> But I can't imagine whatever currently shows up about haskell is less interesting than "lets list reasons why we hate Java for the 5 billionth time."
10:29:30 <FunctorSalad> Io?lo?
10:29:45 <mauke> 1o
10:29:46 <jmcarthur_work> certainly less interesting for those who don't care to learn haskell
10:29:57 <jmcarthur_work> 10
10:30:02 <danr> 2
10:30:03 <mauke> |o
10:30:09 <yav> i think that part of the problem is us trying to over-sell what we have
10:30:12 <yav> and people notice.
10:30:16 <c_wraith> is there a non-pdf description of the new IO stuff?
10:30:22 <jmcarthur_work> there is a bit of overselling
10:30:36 <lament> I! I! Shub-Niggurath!
10:30:37 <jmcarthur_work> but i think that is a natural tendency when your underselling isn't working...
10:30:39 <FunctorSalad> DejaVu Sans Mono beats DejaVu Sanas there...
10:30:43 <Baughn> There's new IO stuff? Did I miss something?
10:30:48 <c_wraith> In 6.12
10:30:48 <mauke> Il1|0Oomrn
10:30:54 <Baughn> Ah
10:31:00 <|randomwords|> It might help if the haskell reddit was a bit more active
10:31:09 <jmcarthur_work> it's fairly active, really
10:31:23 <jmcarthur_work> although it usually is just a bunch of reposts from planet haskell
10:32:00 <dolio> There's a repost from TYPES on there, now. :)
10:32:13 <xlq> I'm trying to define shows for a custom type, but I'm not having much luck. I've tried defining an instance of ShowS, but "`shows' is not a (visible) method of class `ShowS'".
10:32:34 <mauke> wait, what's ShowS?
10:32:38 <yav> xlq: showsPrec is what you are looking for
10:32:50 <yav> ShowS = String -> String
10:32:53 <yav> the class is Show
10:33:44 <yav> xlq: or you could just define "show"
10:33:49 <ksf> and you don't need to implement showsPrec if you don't want to.
10:33:57 <xlq> yav: aha, thanks
10:34:02 <ksf> ...only read forces you to do the Prec thing.
10:34:08 <mauke> or you could just derive Show
10:35:27 <FunctorSalad> off-by-one error hell
10:40:13 <PetRat> I'm working on a qtHaskell application, and compiling it with "ghc -package qtc ..." takes 2 minutes or more (mostly that is ld.exe burning 99% cpu). Anyone have pointers for speeding this up?
10:40:33 <kidz> Hello =D
10:40:37 <kidz> meep
10:40:38 <PetRat> (This is on an old Windows laptop---purchased in 2003)
10:40:57 <kidz> huh
10:41:03 <kidz> You guys seeing me as 'kidz'?
10:41:11 <PetRat> kidz: yes
10:41:19 <kidz> Whats the command to change that? v_v
10:41:32 <timmcd> nvm
10:41:34 <PetRat> Maybe /nick?
10:41:37 <timmcd> Thought I tried/nick >_<
10:41:38 <timmcd> sorry
10:41:40 <timmcd> Thanks tho =D
10:43:27 <doublethink_work> PetRat: there's not much you can do to speed up the linker :(
10:44:01 <PetRat> How about making it a dll?
10:44:49 <PetRat> I'm just confused because my other job is writing C++ on linux systems, and even 50 MB programs link in 10 seconds.
10:46:04 <Zeiris> Why would it take ages to link? You're probably only using a few of the bindings...
10:47:06 <Baughn> PetRat: Many of the GHC libraries are optimized in ways (split-objs, etc.) that decreases executable size but rather pessimizes linking time
10:47:24 <Baughn> PetRat: Turning off split-objs helps. Later, 6.12 should fix it /properly/ by adding dynamic linking support
10:48:01 <PetRat> Baugh: how do I turn off split-objs? Do I need to rebuid qtc or is this purely a link-time choice?
10:48:37 <Baughn> PetRat: You'd need to rebuild ghc, but you shouldn't need to. Most likely the split-objs in question are in the qt bindings
10:48:47 <Baughn> PetRat: However, be aware that doing this will increase executable size a /lot/
10:49:23 <PetRat> Baugn: can you clarify? ghc vs qtc--- qtc is the Qt library.
10:49:30 <Baughn> Oh, sorry
10:50:07 <Baughn> PetRat: GHC is the only part of haskell that I know builds with split-objs by default; doing so does not add very much to linking time, however.
10:50:28 <Baughn> PetRat: I don't know how qtHaskell works, as such, so I can't really comment on that. However, cabal has split-objs off by default for a reason.
10:50:59 <Baughn> PetRat: It does not apply to C libraries, like qtc would seem to be; it would, however, apply to the haskell binding to that c library
10:51:46 <Baughn> PetRat: There's also the "upgrade to 6.11, use dynamic linking" option. However, that's probably still somewhat unstable.
10:51:50 <PetRat> Baughn: if it doesn't apply to qtc, then perhaps it wouldn't make much difference.
10:52:27 <PetRat> I'm using 6.8 with Qt because 6.8 comes with OpenGL. I had trouble building Qt with 6.10.
10:53:01 <JohnnyL> has there been an increase in the amount of bussiness-cloud acceptence for haskell in the past year?
10:53:18 <PetRat> When is a stable 6.11 or 6.12 expected?
10:53:44 <Baughn> Stable will be 6.12; odd numbers are development versions
10:53:59 <PetRat> I see.
10:54:09 <|randomwords|> I think 6.12 rc 1is on the 14th?
10:54:29 <PetRat> of September?
10:54:46 <|randomwords|> allegedly
10:54:58 <PetRat> innocent until proven guilty
10:55:14 <c_wraith> unreleased until proven released?
10:55:57 <ski> aavogt : in `forall a. C a => a -> exists b. C b *> t a', the `forall a.' means the caller decides what type `a' is, the `C a =>' means the caller provides the constraint `C a' (that `a' is in class `C').
10:56:54 <mwc> holy shit, I love it when I'm away from #haskell for a few months to find out a new GHC is right around the corner
10:56:58 <ski> aavogt : similarly, but oppositely, the `exists b.' means that the callee decides what type `b' is, and the `C b *>' is meant to mean that the callee will provide the `C b' constraint
10:57:31 <ski> (aavogt : using `C b =>' there would be wrong, since that would mean that the caller would have to provide the `C b' constraint)
10:57:52 <edwardk> mwc: funny thing is if you just blink, that is usually what happens, even when you are here every day. some times it feels like improvements to ghc just keep whizzing by.
10:59:41 <ski> aavogt : and yes, you can encode this in haskell. we replace the type above with `forall a. C a => a -> SomeB_With_C' where `SomeB_With_C' is defined like `data SomeB_With_C where MkBC :: forall b. C b => b -> SomeB_With_C' ;)
11:03:15 <ski> (`forall b. C b => b -> SomeB_With_C' ~= `forall b. (C b *> b) -> SomeB_With_C' ~= `(exists b. C b *> b) -> SomeB_With_C' shows how `SomeB_With_C' encodes `exists b. C b *> b')
11:10:19 <roconnor> @type uncurry . flip
11:10:54 <jmcarthur_work> does lambdabot need to be restarted or something?
11:11:08 <copumpkin> @botsmack
11:11:08 <lunabot>  :o
11:11:15 <copumpkin> guess so
11:12:51 <aavogt> ski: interesting, but it doesn't look like that helps me, since that ends up being the same as the apply2 function I used
11:13:14 <ski> indeed
11:13:23 <ski> (hence the ";)")
11:13:48 <ski> you can also try CPS, if you want
11:14:01 <ski> using that
11:14:04 <ski>   forall a. C a => a -> exists b. C b *> t a
11:14:07 <ski> translates to
11:14:24 <ski>   forall a o. C a => a -> (forall b. C b => t a -> o) -> o
11:14:33 * aavogt isn't very familiar with cps
11:15:25 <ski> (actually s/t a/b/)
11:16:02 <ski> but then you have to pass a function that uses the constructed `b' to the above function .. instead of using the above directly
11:16:05 <ski> i.e. instead of
11:16:16 <ski>   let b = foo a
11:16:30 <ski>    in <use b here>
11:16:33 <ski> you say
11:16:50 <ski>   foo a (\b ->
11:16:58 <ski>     <use b here>)
11:17:21 <ski> (and the type `o' above can't mention `b')
11:17:34 <copumpkin> lest the evil b escape!
11:17:46 <ski> right !
11:17:56 <aavogt> yeah, that's the problem... the o does end up mentioning b
11:18:05 <copumpkin> aavogt: what are you trying to do?
11:18:15 <aavogt> but both satisfy the constraint
11:19:17 <ski> you either need to include enough context into the `<use b here>' so that `o' doesn't mention `b', or you have to rewrap into an existential data type and return that
11:19:42 <ski> aavogt : but if you paste actual code, we might be able to give more concrete/better advice
11:19:43 <aavogt> copumpkin: I'm trying to write an alternate config for xmonad, continuing from this here http://code.haskell.org/~sjanssen/xmonad-newconfig
11:19:59 <copumpkin> ah, cool
11:21:10 <aavogt> but as it turns out, we can't just go and make a list of modifiers to layouts, or uniformly apply them to the base layout (in a predefined order), since that ends up making existentials escape
11:22:00 <aavogt> the goal is to do this with the minimum of changes to the rest of those libraries
11:23:41 <ski> edwardk : did you find the paper ?
11:24:17 <aavogt> since it would be much nicer to be able to support a nicer config (ex. main = grabConfig $ do add layout xyz; add layoutModifier y; add key ("M-z",someAction))
11:24:25 <edwardk> ski: i forgot which paper =)
11:25:01 <ski> edwardk : something related to inferring existentials (or at least checking them)
11:25:17 <edwardk> ski: ah, no, fraid i haven't had any time to look
11:25:34 <edwardk> ski: i seem to recall it coming up in a paper about intersection types if that helps at all.
11:25:53 <ski> ok
11:26:06 <ski> (that doesn't tell me much)
11:26:19 <ski> if you recall it later, do let me know
11:26:58 <ski> aavogt : is the relevant code too much to paste at <http://hpaste.org/fastcgi/hpaste.fcgi/new?edit=1&id=9302> ?
11:28:14 <ski> (i haven't looked at the code of XMonad, so if understanding the issue requires getting to know much of the architecture, there's not much chance of me being able to help)
11:28:30 <aavogt> ski: that paste is basically it, except C has some operations, and D obviously has a more interesting instance of C
11:28:56 <ski> i'm interested in why you say "the o does end up mentioning b"
11:29:25 <ski> i.e. what does the context look like, and why wouldn't the workarounds suggested apply
11:30:36 <aavogt> ok, the D in that paste would be something more like: `newtype Mirror l a = Mirror (l a)'
11:31:28 <aavogt> ski: so when you ask what the type of   Mirror (someLayout)  is, it mentions the type of someLayout
11:32:03 <ski> and how are you wanting to use `apply' ?
11:32:43 <aavogt> somehow I suspect that the requirement that the layouts be serializable (Read,Show) means that their whole types need to be visible somehow (otherwise how can the correct Read instance be picked?)
11:33:22 <ski> it could be stored in (data) constructors like `B'
11:33:33 <ski> hm
11:33:59 <ski> well, `Read' might be more problematic for existential types
11:34:03 <benmachine> http://hackage.haskell.org/trac/ghc/ticket/3505 woo I submitted an incredibly boring bug to ghc
11:35:05 <benmachine> (if anyone wants to tell me what I haven't put in or etc. then they get a hug
11:35:54 <ski> (i.e. how would you `readsPrec' a value of type `B' ? .. you'd need to have the hidden type `a' encoded in the string somehow)
11:35:54 <aavogt> mconcat (modifiers :: [(Layout -> Layout)]) $ (baseLayout :: Layout) :: Layout
11:36:32 <Philonous> How do you prevent haddock from documenting sections of your code?
11:36:40 <ski> (btw, `[(Layout -> Layout)]' can be said simpler as `[Layout -> Layout]')
11:37:03 <aavogt> ski: I get the feeling that happstack has most of this issue covered (it stores the typereps in its state)
11:37:37 <ski> maybe
11:37:46 <ski> i still wonder how to recover the `C a
11:37:47 <aavogt> currently xmonad keeps the unwrapped layout type around
11:37:49 <ski> ' constraint
11:38:24 <ski> if you only read a fixed set of types, you could do it, i think
11:39:08 <ski> and you want to replace this unwrapped layout type ?
11:40:35 <aavogt> ski: yes
11:41:20 <ski> replace it with what ?
11:42:22 <aavogt> I guess if the wrapped type (existential) contained a fixed number of options, It should be possible to just try all of them for read, after enumerating them like here: http://code.haskell.org/xmobar/Config.hs
11:42:46 <aavogt> (towards the bottom, there is a list / nested tuple)
11:49:34 <ski> btw, the `Show' constraint on `Run' isn't really needed, since `Show' is a superclass of `Exec'
11:51:39 <_nickel> whats with bang in data type definitions
11:51:53 <_nickel> maybe I should say the value constructor definitions?
11:52:07 <_nickel> I keep seeing it but I'm not clear on what it is
11:52:38 <pikhq> It's a strictness annotation, IIRC.
11:52:39 <ski> it means the constructor is strict in the succeeding argument
11:53:10 <_nickel> strict how?
11:53:31 <_nickel> relatively new to haskell
11:54:32 <mauke> strict is antilazy
11:54:42 <pikhq> Y'know how most languages evaluate everything immediately? That's called "strict evaluation". And Haskell's usual behavior of only evaluating things when used, and only insofar as it's used? That's called "lazy evaluation".
11:54:52 <c_wraith> Is ! just WHNF, or is it RNF?
11:54:53 <_nickel> Ahh!
11:54:58 <mauke> W
11:55:02 <pikhq> The bang makes Haskell evaluate a single argument strictly.
11:55:03 <c_wraith> makes sense
11:55:06 <_nickel> not lazy would have sufficed
11:55:29 <_nickel> its the `seq` equivelant for constructors then
11:55:31 <mauke> if a constructor C is strict, evaluating (C x) will also evaluate x
11:55:39 <_nickel> * equivalent
11:55:58 <c_wraith> Not just for constructors.  For any function definition
11:56:07 <pikhq> _nickel, yeah, it's like doing seq except in the function definition.
11:56:28 <pikhq> Semantically it basically *is* just that.
11:56:33 <_nickel> so defining any function with a preceding bang will evaluate it in any context strictly?
11:56:45 <saml> > !yes
11:56:51 <_nickel> !friggin awesome
11:57:05 <c_wraith> _nickel: no, it's for arguments to the function, not the function itself
11:57:08 <saml> factorial !1
11:57:18 <saml> , product ![1..2]
11:57:19 <lunabot>  luna: No instances for (Data.Array.Base.IArray (->) e, GHC.Arr.Ix [e])
11:57:23 <_nickel> c_wraith: Ahh
11:58:22 <_nickel> much appreciated all
11:59:00 <ski> saml : .. in definitions of functions
11:59:05 <ski> .. and it's an extension
11:59:38 <mauke> the function argument thing is a language extension
11:59:38 <mauke> (also, strict functions don't necessarily evaluate their argument)
11:59:49 <ski> , let f !_ = () in f undefined
11:59:50 <lunabot>  luna: Prelude.undefined
11:59:52 <ski> , let f _ = () in f undefined
11:59:53 <lunabot>  ()
12:00:26 <saml> , let product !l = Prelude.product l in product [1..2]
12:00:27 <lunabot>  2
12:00:40 <saml> now i'm sure .. is replaced with ,
12:00:49 <ski> ?
12:01:10 <ski> , [()..()]
12:01:11 <lunabot>  [()]
12:01:23 <ski> , [LT..GT]
12:01:25 <lunabot>  luna: A section must be enclosed in parentheses thus: (`LT..` GT)
12:01:29 <ski> , [LT .. GT]
12:01:30 <lunabot>  luna: Ambiguous occurrence `GT'
12:01:35 <ski> *sigh*
12:01:42 <mauke> , LT
12:01:43 <lunabot>  LT
12:01:51 <mauke> wait, how is GT ambiguous?
12:01:54 <saml> , Ord.GT
12:01:55 <lunabot>  luna: Not in scope: data constructor `Ord.GT'
12:02:02 <mauke> , Data.Ord.GT
12:02:02 <lunabot>  luna: Not in scope: data constructor `Data.Ord.GT'
12:02:12 <ski> , [LT .. Prelude.GT]
12:02:13 <lunabot>  [LT,EQ,GT]
12:02:16 <Badger> hah
12:02:33 <ski> mauke : apparently there's another constructor named `GT' in scope in lunabot
12:02:47 <mauke> yeah, where is that coming from?
12:02:50 <saml> @info GT
12:02:51 <ski> no idea
12:02:58 <mauke> and who defines another constructor called GT?
12:02:59 <ski> , 'GT
12:03:00 <lunabot>  luna: Ambiguous occurrence `GT'
12:03:12 <mauke> .oO( data Dragonball = GT )
12:03:14 <orbitz> mauke: it's part of teh Crimes ADT.  stands for Grand Theft
12:03:35 <c_wraith> Wait.  I thought it was Racing, and stands for Grand Touring
12:07:05 <kcuf> @help undo
12:08:50 <Botje> :t GT
12:09:02 <ski> GT :: Ordering
12:09:34 <ski> , [$ty| GT |]
12:09:37 <lunabot>  luna: Exception when trying to run compile-time code:
12:11:05 <b4taylor> Wow, downloading a file with a ByteString vs a lazy BS, strict 34MB mem usage, lazy 107MB mem usage, for a 33MB file.
12:11:18 <b4taylor> No GC.
12:11:21 <b4taylor> for strict
12:11:24 <b4taylor> lots for lazy
12:12:03 <jmcarthur_work> ...
12:12:20 <jmcarthur_work> are those numbers total allocated or maximum used at one time?
12:17:11 <RyanT5000> is there an extension that allows partially-applied type aliases?
12:17:47 <RyanT5000> e.g.: I would find it useful to be able to say "type Id a = a" and then later pass Id as a *->*
12:17:55 <b4taylor> jmcarthur_work: Max.
12:19:20 <b4taylor> jmcarthur_work: One thing I'm trying to do is "stream" my data. Currently it waits for the entire download to happen before pushing anything into the buffer.
12:21:26 <jmcarthur_work> b4taylor, you are using lazy io?
12:22:38 <b4taylor> jmcarthur_work: That is a good point lol, I think I should :p
12:23:08 <jmcarthur_work> b4taylor, will this thing be doing one stream at a time or many?
12:23:21 <b4taylor> Just one
12:23:29 <b4taylor> And it will touch the entire file.
12:23:30 <jmcarthur_work> b4taylor, okay, lazy io is probably the way to go then
12:23:44 <jmcarthur_work> the simplest, at least
12:24:13 <b4taylor> jmcarthur_work: Yeah it's an ad-hoc thing so I'm fine with that.
12:24:41 <b4taylor> I'm basically redirecting an http request so I don't want the connection to hang until the download is complete.
12:25:13 <jmcarthur_work> if you're looking for ad hoc, maybe netcat is what you want? :)
12:25:25 <jmcarthur_work> unless this is also to serve as a haskell exercise
12:29:42 <RyanT5000> is there any way to open records, or achieve something similar?
12:30:03 <RyanT5000> (record puns are the closest i've found so far)
12:30:16 <b4taylor> jmcarthur_work: Yeah I could just do it with a bash script :p
12:30:19 <mauke> HList?
12:32:20 <RyanT5000> mauke: how would hlist help?
12:32:43 <RyanT5000> i'm not very familiar with it
12:32:56 <RyanT5000> (reading now, but it looks like a complicated interface)
12:33:33 <jmcarthur_work> RyanT5000, what is the use case?
12:33:59 <RyanT5000> well, i'm doing a refactoring experiment
12:34:11 <RyanT5000> i wrote a program with lots of top-level definitions
12:34:27 <RyanT5000> and a few CAFs that slap them together into useful things
12:35:13 <RyanT5000> (specifically, the CAFs are HTML for a legal contract, and the top-level definitions are the names of the parties to the contract and such)
12:35:38 <RyanT5000> and i'm trying to figure out what the minimally-invasive refactor is to eliminate the top-level definitions and make the CAFs into functions
12:36:49 <jmcarthur_work> sounds like it would just be a matter of... eliminating the top-level definitions and making the CAFs into functions... perhaps i don't understand you properly
12:37:45 <RyanT5000> well, the CAFs use those top-level definitions heavily
12:37:47 <RyanT5000> and deeply
12:38:02 <RyanT5000> so if i just naively made a record
12:38:10 <jmcarthur_work> like if you have foo = <some data> ; bar = doSomething foo ... make it into this: bar foo = doSomething foo
12:38:11 <RyanT5000> it would mean i'd have to go through the text of each CAF
12:38:31 <RyanT5000> replacing, e.g., clientName with clientName theRecordArgument
12:38:41 <jmcarthur_work> if your original data is not in a record i think it's unfair to say you have to put it into a record to do a minimal refactor
12:39:15 <jmcarthur_work> notice that in my suggestion you don't have to change the bodies of the CAFs
12:39:15 <RyanT5000> yeah, you're right; i could make them each like 30-ary functions
12:39:26 <jmcarthur_work> 30? jeez
12:39:28 <RyanT5000> but i'm not sure that that would actually be an improvement
12:39:41 <RyanT5000> i'm trying to push the limits of Haskell, here :P
12:39:46 <jmcarthur_work> arguably, in a real scenario, 30 top-level definitions that aren't organized into proper records shouldn't really come up anyway
12:39:56 <RyanT5000> well, you're right
12:40:10 <RyanT5000> but i did it that way for two reasons
12:40:13 <jmcarthur_work> but i get this is an exercise though
12:40:23 <RyanT5000> first, i was trying to simulate a situation where someone has already made that mistake
12:40:35 <RyanT5000> and second, it's actually really annoying to formalize that kind of stuff upfront
12:40:51 <RyanT5000> e.g.: i didn't realize until halfway through that i'd need clientPossessivePronoun
12:41:04 <RyanT5000> that came up when i realized that one of my clients was female :P
12:41:34 <RyanT5000> basically, i'm using Haskell, here, as an alternative to LaTeX
12:41:54 <RyanT5000> incidentally, record wildcards look like they might do the trick
12:42:26 <jmcarthur_work> i don't even know that extension :\
12:42:31 <RyanT5000> "Record wildcard syntax permits a (..) in a record pattern, where each elided field f is replaced by the pattern f = f."
12:43:02 <basvandijk> Hello, has the implementation of '<*>' for lists always been 'ap'? I thought it was 'zipWith ($)'...
12:43:07 <RyanT5000> f (R {..}) is equivalent to f (R { a = a, b = b, c = c })
12:43:12 <RyanT5000> assuming R has a, b, and c
12:43:19 <jmcarthur_work> basvandijk, the zipWith version is for ZipList
12:43:35 <lispy|web> ?bot
12:43:39 <basvandijk> jmcarthur_work: ok
12:44:29 <liyang> Where are my named instances, dammit?!
12:45:04 <lispy|web> hmm...was the lambdabot install not sucessful?
12:45:11 <jmcarthur_work> liyang, named instances?
12:45:43 <jmcarthur_work> liyang, and alternative to newtype wrapping for multiple type class instances for the same data types?
12:45:45 <jmcarthur_work> *an
12:49:32 <lispy|web> ?src (<*>)
12:50:13 <burp> @hoogle GHC.Prim.Any
12:51:23 <leimy> I need to make a record of mostly integer data, and one of the fields is a computation on two of the other fields
12:51:34 <benmachine> f <*> x = f >>= (x >>=) . (pure .)
12:51:35 <leimy> is there a good way to represent that as a function?
12:51:37 <benmachine> apparently.
12:51:41 <leimy> I'm thinking () -> Int
12:52:04 <leimy> but i don't think that will work :-)
12:52:10 <leimy> because I'd need a reader-like context :-)
12:53:44 <lispy|web> leimy: have you looked into lenses?
12:54:20 <leimy> I have not
12:55:12 <lispy|web> leimy: there is at least one package on hackage that implements functional lenses, and I think it does what you want, but I've never used it and I don't know know the names
12:55:45 <leimy> yeah it uses template haskell
12:55:47 <leimy> hmmm
12:56:51 <lispy|web> Data.Accessor exists too
12:57:22 <lispy|web> Cale: how's it going?
12:59:33 <danr> @pl \(x,y) f -> f x >>= \x' -> f y >>= y' -> return (x',y')
12:59:33 <Cale> lispy|web: I couldn't get it to connect for some reason.
12:59:48 <lispy|web> Cale: freenode issues?
12:59:50 <Cale> lispy|web: It does the 4 AUTH lines at the beginning, and then the socket closes.
13:00:01 <b4taylor> jmcarthur_work: Wait, can you write lazily?
13:00:09 <Cale> and there were no messages to say why.
13:00:10 <lispy|web> Cale: hmm...what about ghosting the current connection?
13:00:26 <lispy|web> Cale: it could very well be because lambdabot is still here
13:00:27 <Cale> Oh... that's new...
13:00:33 <Cale> Or, maybe it's not.
13:00:38 <Cale> Let's try that :)
13:00:43 <lispy|web> :)
13:00:54 <Cale> errrrrr....
13:01:04 <Cale> @bot
13:01:04 <lunabot>  :o
13:01:11 <lambdabot> :)
13:01:13 <Cale> hmm
13:01:17 <lispy|web> > 1 + 1
13:01:28 <lambdabot>   2
13:01:38 <Cale> Well, problem... solved? :)
13:01:48 <lispy|web> very slow...but working :)
13:01:56 <Cale> Oh, it'll still be joining channels
13:02:12 <aavogt> @seen lambdabot
13:02:17 <lambdabot> Unknown command, try @list
13:02:29 <lispy|web> oh right
13:02:44 <lispy|web> Cale: interesting that when I run top -u cale, I don't see mueval or lambdabot
13:02:49 <kcuf> @version lambdabot
13:02:55 <lambdabot> lambdabot 4.2.2.1
13:03:01 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:03:22 <Cale> lispy|web: I think it's still running on codersbase
13:03:36 <lispy|web> Oh.  Hmm...
13:03:43 <lispy|web> That was defunct earlier
13:05:33 <danr> @unpl \p -> length . filter p
13:05:33 <lambdabot> \ p c -> length (filter p c)
13:05:39 <danr> @pl \p -> length . filter p
13:05:39 <lambdabot> (length .) . filter
13:05:59 <danr> i see
13:06:54 <lispy|web> :t (length .)
13:06:56 <lambdabot> forall a a1. (a1 -> [a]) -> a1 -> Int
13:07:15 <Baughn> @check \x -> length x < 400
13:07:19 <lambdabot>   "OK, passed 500 tests."
13:07:39 <lispy|web> must be true then
13:07:47 <Baughn> Empirically, it's proven.
13:07:49 <lispy|web> all haskell lists have less than 400 elements
13:07:50 <danr> haha :)
13:08:09 <Baughn> @remember lispy All haskell lists have less than 400 elements
13:08:09 <lambdabot> It is forever etched in my memory.
13:08:28 <lispy|web> ?quote lispy infinite
13:08:28 <lambdabot> lispy says: one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'infinite' datastructures
13:08:45 <Baughn> Sure. Just not lists. :3
13:08:48 <lispy|web> Obviously I didn't mean lists
13:10:55 <lispy|web> Cale: looks like the codersbase server will get pulled from the rack at 3pm PST
13:10:58 <lispy|web> ?localtime lispy
13:10:59 <lambdabot> Local time for lispy is Fri Sep 11 13:05:16 2009
13:11:05 <lispy|web> so, 2 hours
13:11:29 <lispy|web> This whole thing has been frustrating
13:11:38 <leimy> lispy|web: Actually all I need is a typeclass
13:11:50 <leimy> my problem was simpler than I thought.
13:12:15 <dolio> @check (<400)
13:12:18 <lambdabot>   "OK, passed 500 tests."
13:12:27 * Twey laughs.
13:12:44 <lispy|web> dolio: sweet!
13:12:49 <lispy|web> leimy: ah, cheers
13:12:49 <Twey> @check (<3)
13:12:52 <lambdabot>   "Falsifiable, after 2 tests:\n3\n"
13:12:55 <leimy> lol!
13:12:58 <dolio> Ultrafinitism proved.
13:13:04 <lispy|web> now binary search between 3 and 400
13:13:06 <leimy> @check (<1929129)
13:13:07 <Twey> xD
13:13:09 <lambdabot>   "OK, passed 500 tests."
13:13:18 <lispy|web> ?check (<200)
13:13:21 <lambdabot>   "OK, passed 500 tests."
13:13:27 <lispy|web> ?check (<100)
13:13:30 <lambdabot>   "Falsifiable, after 300 tests:\n108\n"
13:13:33 <leimy> @check (<500)
13:13:36 <lambdabot>   "OK, passed 500 tests."
13:13:39 <lispy|web> ?check (<150)
13:13:42 <lambdabot>   "Falsifiable, after 440 tests:\n159\n"
13:13:56 <leimy> @check (<1)
13:13:59 <lambdabot>   "Falsifiable, after 2 tests:\n3\n"
13:14:28 <aavogt> @check (==())
13:14:31 <lambdabot>   "OK, passed 500 tests."
13:14:59 <leimy> @check ((== "Your Mom bakes delicious cookies") == False)
13:15:01 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> GHC.Bool.Bool'
13:15:43 <benmachine> @check (== ()) . mappend undefined
13:15:46 <lambdabot>   "OK, passed 500 tests."
13:15:53 <leimy> @check (\= "Your mom bakes delicious cookies")
13:15:55 <lambdabot>   Not in scope: `\='
13:15:57 <leimy> oops
13:15:58 <leimy> heh
13:16:07 <leimy> @check (/= "Your mom bakes delicious cookies")
13:16:10 <lambdabot>   "OK, passed 500 tests."
13:16:58 <andrewsw> huh
13:17:04 <andrewsw> dang
13:17:23 <lispy|web> 209 seems to be the biggest it tries
13:17:29 <lispy|web> ?check (<209)
13:17:32 <lambdabot>   "OK, passed 500 tests."
13:17:35 <lispy|web> ?check (<209)
13:17:38 <lambdabot>   "OK, passed 500 tests."
13:17:46 <lispy|web> ?check (<200)
13:17:49 <lambdabot>   "Falsifiable, after 471 tests:\n204\n"
13:18:16 <Beelsebob> ?check (<205)
13:18:20 <lambdabot>   "OK, passed 500 tests."
13:18:26 <Beelsebob> ?check (<205)
13:18:29 <lambdabot>   "OK, passed 500 tests."
13:18:31 <Beelsebob> ?check (<205)
13:18:35 <lambdabot>   mueval-core: Time limit exceeded
13:18:39 <Beelsebob> ?check (<205)
13:18:42 <lambdabot>   "OK, passed 500 tests."
13:18:52 <Beelsebob> seems I found a new limit
13:18:54 <lispy|web> Beelsebob: in /msg I've seen 209
13:19:39 <dolio> @check \f -> f 23 == f 88
13:19:41 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
13:19:42 <lambdabot>    arising from a use of `...
13:20:28 <PetRat> If I want to use an Error monad, not ErrorT, is there such a type?
13:20:48 <benmachine> ErrorT is the Either transformer isn't it?
13:21:10 <PetRat> I believe so.
13:21:10 <ski> PetRat : you want to avoid the irksome `Error' constraint, yes ?
13:21:11 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
13:21:16 <ski> @messages
13:21:16 <lambdabot> Philonous1 said 6d 1h 36m 14s ago: Here's the junction code, if you're still interested. I cleaned it up somewhat and added a monad interface: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9083#
13:21:16 <lambdabot> a9083
13:21:25 * ski sighs
13:22:23 <PetRat> What I want to do is make use of throwError, and write val <- func rather than case func of Left msg -> Left msg ; Right val -> ..
13:23:08 <ski> if the `Error' constraint isn't hindering you, you may use `EitherT e m' or `Either e'
13:23:43 <ski> > do x <- Right 42; return (x*x)
13:23:44 <jmcarthur_work> lambdabot!
13:23:47 <lambdabot>   Add a type signature
13:24:06 <ski> > do x <- Right 42; return (x*x) :: Either String Int
13:24:09 <lambdabot>   Right 1764
13:24:11 <PetRat> Ah, so Either e   is a monad already.
13:24:20 <ski> > do x <- Left "foo !"; return (x*x) :: Either String Int
13:24:22 <Twey> If you import Control.Error.
13:24:24 <lambdabot>   Left "foo !"
13:24:25 <jmcarthur_work> b4taylor, write lazily? what would that mean?
13:24:28 <lispy|web> PetRat: pattern guards?
13:24:35 <jmcarthur_work> b4taylor, the idea is to read lazily and write strictly
13:24:36 <ski> PetRat : sadly only if `Error e'
13:24:49 <jmcarthur_work> b4taylor, the writes will block when it has to read
13:25:12 <burp> hm, Either has no functor instance?
13:25:14 <lispy|web> PetRat: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
13:25:23 <Cale> It would be really interesting if you could write files lazily, but it would require OS support.
13:25:23 <burp> why that?
13:25:24 <PetRat> ski: not sure I follow. Error is a class, not a type constructor I believe.
13:25:33 <ski> right
13:25:40 <PetRat> Oh you mean a class constraint.
13:25:46 <ski>   instance Error e => Monad (Either e)
13:25:52 <jmcarthur_work> Cale, i'm not sure how to interpret "lazy writing." how are you interpreting it?
13:25:53 <ski> while
13:25:58 <ski>   instance Monad (Either e)
13:26:08 <ski> would suffice (and be better, imo)
13:26:14 <burp> > fmap (^2) $ Right 42
13:26:17 <lambdabot>   Right 1764
13:26:21 <burp> oh it has
13:26:36 <lispy|web> (^2) <$> Right 42
13:26:39 <lispy|web> > (^2) <$> Right 42
13:26:43 <lambdabot>   Right 1764
13:26:43 <burp> where is it?
13:26:45 <b4taylor> jmcarthur_work: Indeed, I imagine it's the reading that isn't doing so hot. I'm also looking at some other libraries on hackage. Prolly try the download library, seems more robust.
13:26:51 <jmcarthur_work> ski, that's on my list of differences for my alternative library! :)
13:27:00 <ski> jmcarthur_work : presumably when the reader of the file on the other end forces the data, the haskel process will compute it ?
13:27:16 <jmcarthur_work> ski, so... pipes?
13:28:10 <ski> jmcarthur_work : yay ! (Ceterum censeo `Error'inem esse delendam)
13:28:34 <ski> jmcarthur_work : maybe .. better ask Cale what he meant :)
13:29:30 <monochrom> Lazy writing means you go ahead to your PhD oral defense, and write your thesis as you answer questions.
13:29:41 <ski> @instances Either
13:29:42 <lambdabot> Couldn't find class `Either'. Try @instances-importing
13:30:02 <ski> @instances Functor
13:30:04 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:30:18 <burp> ski: but where is the either functor instance?
13:30:23 <burp> it's not in Data.Either
13:30:44 <jmcarthur_work> burp, well, the monad instance is in Control.Monad.Error. maybe the Functor instance is too
13:30:45 <ski> maybe in `Control.Monad.Error' and/or `Control.Monad.Instances'
13:30:58 <jmcarthur_work> i think it's not in Control.Monad.Instances
13:31:23 <burp> it is
13:31:55 <ski> @instances MonadReader
13:31:56 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
13:32:09 <ski> .. that reporting is ambiguous
13:32:30 <ski> (it looks like `r' applied to various things is an instance)
13:32:47 <PetRat> How do you catch errors in the 'Error e' monad?
13:33:09 <burp> > fmap (+42) (0,0)
13:33:11 <ski> @type Control.Monad.Error.catchError
13:33:13 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
13:33:13 <lambdabot>   (0,42)
13:33:18 <burp> interesting, didn't know there existed such an instance
13:33:46 <PetRat> Can you put catchError anywhere in a do block and it "intercepts" anything coming through at that point?
13:33:58 <ski> burp : it's basically the same as `Functor (Writer w)'
13:34:40 <PetRat> My goal is to catch errors and add context to them before propagating them.
13:34:41 <ski> PetRat : `catchError (do ...) (\e -> ...)' will catch any (uncaught) errors in `do ...'
13:35:19 <PetRat> ski: I think I get it.
13:36:03 <ski> jmcarthur_work : one more thing you could add to your list :) `caseException :: MonadException e m => m a -> (e -> m b) -> (a -> m b) -> m b' (e.g. as a class method)
13:38:45 <jmcarthur_work> ski, i wish i meant i had an actual list when i said i had a list ;)
13:39:14 <jmcarthur_work> ski,  i'm just gonna forget it now :P
13:39:14 <ski> hehe
13:40:14 <jmcarthur_work> ski, i don't think you were around when i first discussed this. i intend to make this a collaborative effort. i'll be giving commit access to anybody that wants it, and i might see about making a mailing list for it once there are enough people involved
13:40:27 <ski> (in any case, such a primitive can be nice to express loops where the body should have a handler, but the handler isn't meant to scope pver the recursive call)
13:41:32 <jmcarthur_work> :t bracket
13:41:34 <lambdabot> Not in scope: `bracket'
13:41:39 <jmcarthur_work> :t System.IO.bracket
13:41:41 <lambdabot> Not in scope: `System.IO.bracket'
13:41:44 <jmcarthur_work> @hoogle bracket
13:41:45 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
13:41:45 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
13:41:45 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
13:41:52 <jmcarthur_work> :t Control.Exception.bracket
13:41:54 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:41:59 <jmcarthur_work> oh, it was right there in front of me
13:42:48 <jmcarthur_work> ski, i thought of bracket when i saw that type, but i guess they are actually quite different
13:44:59 <jmcarthur_work> ski, would something like this be as good?: MonadException e m => (e -> m b) -> (a -> m b) -> a -> m b
13:45:29 <jmcarthur_work> ski, that makes it look more like a combinator, which i think is a bit nicer
13:45:32 <ski> Exceptional Syntax <http://research.microsoft.com/~akenn/sml/ExceptionalSyntax.pdf>, Catching exceptions only where needed <http://martin.jambon.free.fr/extend-ocaml-syntax.html#lettry>, RE: [Caml-list] Checking for eof <http://caml.inria.fr/pub/ml-archives/caml-list/2004/12/b5b79fcd4ea695b8e1e0aff740b07cf3.en.html>
13:46:46 <ski> jmcarthur_work : if you replace the final `a' with `m a', then it is the same functionality
13:47:00 <jmcarthur_work> but it's different otherwise?
13:47:04 <ski> it might be more unnatural ordering in some cases, though
13:47:29 <ski> yes, it needs an action that will possibly raise exceptions (and possibly do other effects as well)
13:47:51 <jmcarthur_work> oh, so i guess that action is the m a, not the m b as i was interpreting it?
13:47:55 <hackagebot> vector 0.3.1 - Efficient Arrays (RomanLeshchinskiy)
13:47:56 <ski> so it needs to take an action of type `m a' as argument, not just a value of type `a'
13:48:11 <ski> `m b' is the resulting composite action
13:48:26 <jmcarthur_work> well, lemme redo that last suggestion a bit
13:48:46 <ski> see the above links for info on the idea
13:48:58 <jmcarthur_work> MonadException e m => (e -> m a) -> (m a -> m a)
13:49:05 <jmcarthur_work> is this fundamentally different?
13:49:18 * jmcarthur_work checks the links
13:49:25 <ski> @type Control.Monad.Error.catchError
13:49:26 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
13:49:31 <jmcarthur_work> aha
13:49:33 <ski> that's basically it
13:51:00 <ski> you can express `caseException' using this (either using `Maybe a' or `m (m a)' as intermediate result), but it is clunky
13:54:21 <jmcarthur_work> so essentially it's  (e -> m b) -> (a -> m b) -> (m a -> m b)  instead of  (e -> m a) -> (m a -> m a)   (if you will allow me to stick with my preferred argument order ;)
13:54:52 <ski> @type \ma emb amb -> catchError (liftM Right ma) (return . Left) >>= either emb amb
13:54:53 <lambdabot> forall (m :: * -> *) e b b1. (MonadError e m) => m b -> (e -> m b1) -> (b -> m b1) -> m b1
13:55:08 <burp> > extendSequence [2,4,8,16,32]
13:55:11 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
13:55:38 <jmcarthur_work> @src extendSequence
13:55:38 <lambdabot> Source not found. You speak an infinite deal of nothing
13:55:41 <burp> hehe
13:55:44 <jmcarthur_work> who defined that?
13:55:59 <burp> > extendSequence [5,7,11,13,17]
13:56:02 <lambdabot>   [5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103...
13:56:04 <burp> http://hackage.haskell.org/packages/archive/oeis/0.2.1/doc/html/Math-OEIS.html
13:56:07 <burp> its from there ;)
13:56:15 <jmcarthur_work> oh, an interface to OEIS, i see
13:56:27 <burp> otherwise it would be brilliant ;)
13:56:59 <jmcarthur_work> ski, i like it, but you will have to remind me of it again ;)
13:57:09 <ski> @type \ma emb amb -> join (catchError (ma >>= return . amb) (return . emb))
13:57:11 <lambdabot> forall a a1 (m :: * -> *) e. (MonadError e m) => m a -> (e -> m a1) -> (a -> m a1) -> m a1
13:57:44 <ski> those two are the `Maybe a' and `m (m b)' encodings i mentioned
13:58:05 <ski> (that's translations of the two workarounds in the middle link)
13:58:05 <benmachine> ma >>= return . amb = fmap amb ma
13:58:16 <benmachine> or liftM
13:58:22 <ski> right
13:58:51 <ski> @type \ma emb amb -> join (catchError (liftM amb ma) (return . emb))
13:58:53 <lambdabot> forall a1 a (m :: * -> *) e. (MonadError e m) => m a1 -> (e -> m a) -> (a1 -> m a) -> m a
13:59:58 <ski> jmcarthur_work : yes and i'll try
14:00:11 <ski> (to remember)
14:00:19 <jmcarthur_work> @type \emb amb -> either emb amb <=< flip catchError (return . Left) . liftM Right
14:00:21 <lambdabot> forall c e (m :: * -> *) a1. (MonadError e m) => (e -> m c) -> (a1 -> m c) -> m a1 -> m c
14:00:36 <jmcarthur_work> a nicer definition if the arguments of catchError are flipped, i think
14:01:04 <jmcarthur_work> and likewise for the join version, i suspect
14:01:15 <ski> s/Maybe a/Either e a/
14:02:14 <ski> it seems irksome to have to do a detour around `Either e', or a nested action, just to deconstruct them right after the `catchError' call
14:02:28 <ski> (which is why i suggested this be a class method)
14:03:28 <jmcarthur_work> @type \emb amb -> join . flip catchError (return . emb) . liftM amb
14:03:30 <lambdabot> forall a e (m :: * -> *) a1. (MonadError e m) => (e -> m a) -> (a1 -> m a) -> m a1 -> m a
14:03:53 <jmcarthur_work> hmm... join and fmap in the same function looks a lot like bind...
14:04:03 <jmcarthur_work> but there's a catchError between them
14:04:11 <ski> yes
14:04:24 <jmcarthur_work> i wonder if maybe there might be a more general pattern hiding in there
14:05:16 <jmcarthur_work> @type \emb -> flip catchError (return . emb)
14:05:17 <lambdabot> forall e b (m :: * -> *). (MonadError e m) => (e -> b) -> m b -> m b
14:05:57 <jmcarthur_work> the m b -> m b is the important part, i think
14:06:14 <ski> in the O'Caml CamlP4 macro version, then introduced a mix of the `let x = ... in ..x..' and the `try ... with E e -> ..e..' syntices looking like `let try x = ... in ..x.. with E e -> ..e..', to express this idea
14:06:43 <jmcarthur_work> @type \g f -> join . g . liftM f
14:06:44 <lambdabot> forall (m :: * -> *) a a1 r (m1 :: * -> *). (Monad m, Monad m1) => (m1 r -> m (m a)) -> (a1 -> r) -> m1 a1 -> m a
14:07:01 <jmcarthur_work> gross
14:07:03 <ski> (that corresponds to `caseException ... (\E e -> ..e..) (\x -> ..x..)' more or less)
14:07:14 <ski> (s/E e/(E e)/)
14:09:01 <ski> (
14:09:05 <ski>    case <ma> of
14:09:09 <ski>      <throwException e> -> <emb a>
14:09:10 <ski>     a                   -> <amb a>
14:09:29 <ski>  hypothetic syntax for this, in reflective monadic syntax
14:09:30 <ski> )
14:10:50 <jmcarthur_work> ah!
14:11:05 <jmcarthur_work> i see what you are getting at now
14:14:22 <jmcarthur_work> caseException ma (\exception -> emb a) (\a -> amb a)
14:14:52 <jmcarthur_work> i think i might still disagree on the order though. i'm not a fan of syntax sugar and i think my order is cleaner
14:15:14 <ski> it is a nicer type, yes
14:15:15 <ski> still
14:15:20 <ski> @type catchError
14:15:22 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
14:15:22 <jmcarthur_work> maybe provide both
14:15:23 <ski> @type (>>=)
14:15:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:15:27 <jmcarthur_work> i think there is no harm in that
14:15:40 <jmcarthur_work> i don't like those :P
14:15:40 <ski> *nod*
14:15:49 * ski somehow suspected that :)
14:16:33 <ski> `>>=' is useful when applying to large expressions
14:16:49 <ski> `(=<<)' is usually better to partially apply
14:16:54 <jmcarthur_work> i plan to have both
14:17:25 <ski> @type ContT . (>>=)  -- though
14:17:26 <lambdabot> forall a (m :: * -> *) r. (Monad m) => m a -> ContT r m a
14:17:32 <jmcarthur_work> i also will replace liftM with bindM, which would have the same type as (=<<), but also have bindM2, bindM3, etc. that are monadix analogs to liftM2, liftM3, etc.
14:17:51 <jmcarthur_work> *monadic
14:18:05 <ski> you mean `Monad m => (a -> b -> m c) -> (m a -> m b -> m c)', &c. ?
14:18:11 <jmcarthur_work> right
14:18:14 <ski> ty
14:18:29 <ski> (though i would prefer the name `extendM2',&c.)
14:18:41 <dolio> Yeah, extend.
14:18:44 <jmcarthur_work> i've seen extend used for comonads more...
14:18:46 <|randomwords|> Is there an easy way to install old versions of GHC - without making them my main GHC symlink?
14:18:50 <jmcarthur_work> no?
14:18:52 <ski> in my mind "bind" is `(>>=)' and "extend" is `(=<<)'
14:18:57 <jmcarthur_work> ah
14:19:04 <dolio> Unless you're one of those crazy people who uses extend for comonads, instead of the obviously proper coextend.
14:19:16 <jmcarthur_work> category-extras, namely, has extend :: (w a -> b) -> (w a -> w b)
14:19:17 <ski> the use for comonads was as an analogue of the extend for monads
14:19:24 <jmcarthur_work> okay
14:19:35 <jmcarthur_work> i'm convinced, i suppose :)
14:19:48 <jmcarthur_work> i don't know the traditional terminology so well i think
14:19:57 * ski has pondered using `preserve' for `Comonad w => (w a -> b) -> (w a -> w b)'
14:19:58 <jmcarthur_work> as long as it's available, i'm happy
14:20:00 <dolio> I have a paper that calls (w a -> b) -> (w a -> w b) coextend. That proves it! :)
14:20:19 <ski> (some would possibly suggest `coextend', but i'm not sure that's nice)
14:20:26 <jmcarthur_work> maybe it would be a good idea to take an informal survey
14:20:38 <jmcarthur_work> eventually, i mean
14:20:40 <jmcarthur_work> not there yet
14:21:21 <ski> (`preserve f' preserves the `w' context on the input, passing it on to `f', as well as passing it on to the output)
14:22:27 <ski> (also `cojoin' sounds a bit lame .. `duplicate' is misleading, imo .. maybe `split', though that has some connotations of the operation in a comonoid)
14:22:59 <dolio> Well, comonads are comonoids. :)
14:23:09 <ski> and monads are monoids
14:23:26 <jmcarthur_work> what the heck is a comonoid? wouldn't a comonoid also just be a monoid?
14:23:32 <ski> no
14:23:57 * jmcarthur_work googles
14:24:21 <dolio> Comonoids have coidentity : w -> i and comultiply : w -> w (x) w
14:24:51 <jmcarthur_work> ah!
14:25:01 <ski>   class ArrowicComonoid ar c
14:25:03 <ski>     where
14:25:07 <ski>     counit :: ar c ()
14:25:07 <ski>     cocombine :: ar c (c,c)
14:25:37 <dolio> Where i and (x) are some monoidal structure for the category, I think?
14:25:48 <ski> yes
14:26:30 <jmcarthur_work> "a comonoid in a monoidal category C is a monoid in the dual category [of C]"
14:26:43 <ski>   instance ArrowicComonoid (Kleisli []) [a]
14:26:43 <jmcarthur_work> wikipedia
14:26:45 <ski>     where
14:26:49 <ray> arrowic!
14:27:22 <ski>     counit = Kleisli (\as -> case as of [] -> [()]; _ -> [])
14:27:37 <dolio> Anyhow, comonoids are a bit dull when the monoidal category structure is product and terminal object.
14:28:22 <dolio> Since w -> () is trivial, and w -> w * w can only be diagonal/duplicate, due to the expected laws.
14:28:57 <ski>     cocombine = Kleisli . fix $ \split as -> case as of [] -> [([],[])]; a:as -> do (bs,cs) <- split as; return (a:bs,cs)
14:29:04 <dolio> But it's more interesting in other cases.
14:29:05 <jmcarthur_work> hmm
14:29:05 <Cale> Which is why comonoids are not a classically-studied structure.
14:29:19 <hackagebot> control-monad-exception 0.3 - Explicitly typed exceptions (PepeIborra)
14:29:20 <Cale> They're only really interesting in other categories than Set.
14:29:33 <ski> like vector-actegories, iirc
14:29:36 <Cale> (or with a different monoidal structure on set)
14:29:46 <ski> (with the tensor structore)
14:30:23 <Cale> Yeah, comonoids in Vec_K with tensor product are called coalgebras.
14:30:59 <ski> that always seemed like a stupid name, imho
14:31:14 <SamB> is it because girls like them ?
14:31:29 <Cale> Well, it's the dual notion to algebras...
14:31:53 <SamB> the groaning -- why is nobody doing it ?
14:32:10 <ski> (imo, "algebra" is a generic word with instances like "group","ring","vector space","directed graph", &c.)
14:32:12 <Cale> SamB: I... don't get it.
14:32:31 <dolio> Yeah, me neither.
14:32:32 <SamB> Cale: it's, er, a dumb joke based in some way on co-ed
14:33:03 <SamB> ... hey, is coeducation the dual of education ?
14:33:39 <ski> yep, you're getting a coeducation when you're not getting not an education
14:34:11 <Cale> ski: Algebra in the sense of a vector space with an additional multiplication, like the algebra of linear operators on a space.
14:35:00 <ski> that is monoid (or semi-group ?) over a vector space, no ?
14:35:14 <Cale> Well, it's a monoid in the category of vector spaces.
14:35:20 <ski> right
14:35:42 <Cale> (with tensor product/base field as the monoidal structure)
14:35:50 <ski> (*nod*)
14:38:01 <monoidal> http://monoidal.blogspot.com/2009/09/balanced-brackets-finite-sets-and.html comments welcome
14:39:38 <ski> monoidal : i think edwardk might be interested in that
14:40:24 <ski> (he was mentioning the Dyck language when he was talking about monoidal parsing a while ago, anyway)
14:40:40 <srush> has anyone here used fgl
14:40:55 <jmcarthur_work> srush, i have very little
14:41:43 <srush> I'm stuck on a pretty basic problem
14:42:04 <srush> is there a way to go from unlabeled (Int) edges to labeled edges
14:42:30 <ski> monoidal : i agree that we would want `instance (forall a. Show a => Show (f a)) => Show (Y f)'
14:42:31 <Cale> monoidal: good stuff :)
14:42:39 <Zeiris> srush: Tuple it into (Int,String)?
14:42:58 <ski> monoidal : i have been told `instance Show (f (Y f)) => Show (Y f)' works here, though
14:43:19 <monoidal> that's interesting. thanks
14:43:37 <srush> Zeiris: not sure I understand what you mean
14:43:55 <Zeiris> I'm not sure I understand the question anyway - I'm a newb :)
14:43:58 <ski> (but generally, i think it would be interesting to be able to use quantifiers and implications that way in the instance antecedent)
14:44:22 <srush> haha, ok, I'm trying to figure out fgl, the haskell graph library
14:44:26 <hackagebot> control-monad-exception 0.3.1 - Explicitly typed exceptions (PepeIborra)
14:44:47 <ski> @hackage control-monad-exception
14:44:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-monad-exception
14:45:36 <ski> monoidal : heh, i've also used that same  Show'  trick :)
14:47:14 <jmcarthur_work> srush, what type do you need?
14:48:23 <srush> something like   gr b a -> Node -> LNode a
14:49:36 <srush> of (Graph gr) => gr a b -> Node -> LNode a
14:51:12 <jmcarthur_work> srush, you could always use lab or something
14:52:34 <zbrown> Anyone know how to easily uninstall the componenets from the haskell install pkg for Mac OS X?
14:52:48 <jmcarthur_work> srush, something like this maybe?: \gr -> id &&& lab gr
14:53:14 <Twey> (id &&&) . lab
14:53:25 <srush> oh sweet
14:53:29 <jmcarthur_work> or that
14:53:43 * Twey kills points compulsively.
14:53:44 <zbrown> is it safe to just kill /Library/Frameworks/GHC.framework?
14:54:10 <jmcarthur_work> i was just figuring it would probably just be put into some other function inline or something
14:54:14 <Twey> IMO, (id &&&) and (&&& id) should have names.
14:54:20 <jmcarthur_work> i agree
14:54:37 <srush> and to go the opposite way I need NodeMap?
14:55:28 <jmcarthur_work> to get a Node from a LNode?
14:55:36 <jmcarthur_work> fst should be all you need
14:55:41 <jmcarthur_work> err
14:55:45 <jmcarthur_work> from a LNode to a Node
14:55:53 <srush> sorry just the label to a Node
14:56:01 <jmcarthur_work> oh, looking up the label?
14:56:11 <srush> yeah
14:56:20 <srush> gr a b -> a -> Node
14:56:24 <jmcarthur_work> i think labels are not guaranteed to be unique
14:56:31 <jmcarthur_work> so it would at least have to be a list of nodes
14:56:59 <jmcarthur_work> oh, and lab returns a Maybe, so that's not exactly what you wanted
14:57:32 <srush> I think labels are unique
14:57:36 <jmcarthur_work> but you get the idea
14:57:54 <srush> mkMapGraph :: (Ord a, DynGraph g) => [a] -> [(a, a, b)] -> (g a b, NodeMap a)
14:58:02 <srush> seems to do edges by label
14:58:12 <jmcarthur_work> hmm
14:58:35 <jmcarthur_work> i dunno
15:00:02 <ski> @type graph
15:00:03 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
15:00:04 <ski> @type xograph
15:00:06 <lambdabot> Not in scope: `xograph'
15:00:07 <ski> @type cograph
15:00:09 <lambdabot> forall (ar :: * -> * -> *) a b. (ArrowChoice ar) => ar a b -> ar (Either a b) b
15:00:10 <ski> Twey : ^
15:00:55 <ski> (and that's `(arr id &&&)' respectively `(||| arr id)' if you wonder)
15:01:21 <Twey> Oho
15:01:28 <Alpounet> blackh1, I re-read your tutorial, very nice
15:01:31 <Twey> Why those names?
15:02:03 <blackh1> Alpounet: Great! It was useful for me too, to make sure I understood it all.
15:02:12 <SamB> Twey: after the graph of a function
15:02:19 <SamB> I assume
15:02:27 <zzaz> what is the easiest way to do memoization with more than one variable?
15:02:31 <Twey> But what does it have to do with pairs?
15:02:42 <SamB> Twey: the graph of a function is a set of pairs!
15:02:52 <jmcarthur_work> huh
15:02:56 <SamB> did you think it was a squiggle drawn on paper ?
15:03:02 <Twey> Oh!
15:03:03 <Twey> Haha.
15:03:06 <SamB> or maybe on a screen?
15:03:47 <ski> because given a function (/morphism) (seen as a binary relation, if you prefer) from `a' to `b', the graph of that is a subset (/subobject) of the cartesian product (/relational product) of `a' and `b' .. that can be represented either as a map from that product into `Bool' (/subobject classifier)
15:03:58 <jmcarthur_work> zzaz, Map (a, b) c ?
15:04:03 * Twey doesn't really understand function graphs.  Yet.
15:04:15 <ski> or as an injective (/mono) map from any object (here `a') *into* the product
15:04:50 <ski> Twey : in the `Set' case, `graph f = {(a,b) : A * B | f a = b}'
15:05:47 <ski> Twey : `graph' and `cograph' in this light is discussed some in both "Sets for Mathematics" and "Toposes, Triples, and Theories" (latter available gratis on the web)
15:06:31 <zzaz> jmcarthur: like how can i memoize this function: http://pastebin.com/md25dc91
15:06:33 <Twey> What are A, B, *, and : there?
15:06:37 <Alpounet> blackh1, did you ? :-p
15:06:48 <frwmanners> jmcarthur_work: is that assuming you know which (possible non-contiguous) values you wish to memoize beforehand?
15:06:51 <Twey> Oh, A and B are the sets of as and bs, : is cons, and * is the coproduct?
15:06:57 <Twey> Coproduct?
15:06:59 <Twey> Product
15:06:59 <jmcarthur_work> my math-teacher-in-training friend finds it almost unbelievable that such abstract maths can actually be useful in programming
15:07:06 <jmcarthur_work> like category theory
15:07:22 * Twey has been unduly co'd
15:07:25 <ski> @let tabulate :: Ix i => (i,i) -> (i -> a) -> Array i a; tabulate ix f = array ix [f `graph` i | i <- range ix]
15:07:27 <lambdabot>  Defined.
15:07:31 <jmcarthur_work> frwmanners, eh, i guess so
15:07:35 <Badger> Cotwey?
15:07:36 <Alpounet> It is, though.
15:07:47 <ski> > tabulate (-2,2) $ \i -> i^3
15:07:52 <lambdabot>   array (-2,2) [(-2,-8),(-1,-1),(0,0),(1,1),(2,8)]
15:08:13 <Twey> Maths, like philosophy, is funny in that it includes abstractions of itself.
15:08:14 <|randomwords|> @seen roconnor
15:08:14 <lambdabot> Unknown command, try @list
15:08:34 <ski> Twey : `*' is cartesian product (or relational product in an allegory), `A',`B' are any sets (or any objects in the allegory)
15:09:12 <mauke> |randomwords|: you can ask preflex instead
15:09:13 <ski> allegories are discussed some in "Algebra of Programming" by Richard Bird and Oege de Moor
15:09:30 <|randomwords|> mauke: Sorry, I don't understand
15:09:30 <frwmanners> zzaz: you want an array
15:09:31 <ski> (not sure if that talks about graphs or cographs, but possibly it does)
15:09:40 <mauke> preflex: seen roconnor
15:09:40 <preflex>  roconnor was last seen on #haskell 3 hours, 59 minutes and 21 seconds ago, saying: @type uncurry . flip
15:09:52 <|randomwords|> mauke: Wonderful - thanks
15:10:04 <blackh1> Alpounet: I must have got it right, because I only got two people correcting me. :)
15:10:06 <ski> Twey : `:' is "has type"
15:10:21 <Twey> preflex: seen Apocalisp
15:10:21 <preflex>  Apocalisp was last seen on #haskell 8 days, 17 hours, 46 minutes and 50 seconds ago, saying: never heard of it
15:10:27 <ski> (or "is element in the set", if you must)
15:10:27 <Twey> Hmn :-\
15:10:31 <Twey> ski: Oh, right
15:10:45 <zzaz> frwmanners how do i use immutable maps to memoize unless i use unsafePerformIO?
15:10:55 <frwmanners> zzaz: so, make an array memMinSum, calling minSum to find each value
15:11:00 <Twey> Then I have absolutely no idea how that relates to the function graph f
15:11:04 <Alpounet> blackh1, fine !
15:11:12 <ski> > map (even `graph`) [0..3]
15:11:16 <lambdabot>   [(0,True),(1,False),(2,True),(3,False)]
15:11:27 <frwmanners> zzaz: but, in the recursive call in minsum, read from the array
15:11:45 <zzaz> can i mutate state of the array?
15:11:45 <frwmanners> zzaz: lazyness saves the day
15:11:52 <frwmanners> zzaz: no need
15:11:57 <jmcarthur_work> zzaz, you just take advantage of lazy evaluation!
15:11:59 <ski> that can be considered to be the graph of the function `even', restricted to the domain of `{0,1,2,3}'
15:12:15 <jmcarthur_work> just make the array as though you are computing every value, but it will just compute the ones you need
15:12:36 <zzaz> does anyone have a tutorial on how to do that (not Memoization on haskell wiki)
15:13:05 <frwmanners> zzaz: don't know of one other than that
15:13:25 <jmcarthur_work> foo' = makeArray   foo x y = foo' ! (x, y)
15:13:34 <jmcarthur_work> essentially, that's all there is to it
15:15:07 <Twey> ski: I get the Haskell, but don't see how it relates to the earlier definition posted.
15:15:13 <frwmanners> > let arr = array (0,9) [recursiveCall n | n <- [0..9]; recursiveCall n = n == 0 ? 0 : arr ! (n-1) + 1; in arr ! 9
15:15:15 <ski> > let factorial n = fac n where fac = (arr !); arr = tabulate (0,n) fac'; fac' 0 = 0; fac' 1 = 1; fac' n = fac (n-1) + fac (n - 2) in factorial 5
15:15:17 <lambdabot>   <no location info>: parse error on input `;'
15:15:19 <lambdabot>   5
15:15:25 <frwmanners> d*mn
15:15:30 <ski> zzaz : ^ that's one example
15:15:47 <Twey> @tell Apocalisp The singular of criteria is criterion, re: http://apocalisp.wordpress.com/category/philosophy/epistemology/
15:15:48 <lambdabot> Consider it noted.
15:16:11 <ski> Twey : which definition ?
15:16:27 <jmcarthur_work> oh i get it. graph plots the "points" for a list of inputs for the given function
15:16:30 <Twey> 23:05:06 < ski> Twey : in the `Set' case, `graph f = {(a,b) : A * B | f a = b}'
15:16:40 <ski> zzaz : sorry, s/factorial/fibonacci/,s/fac/fib/ :)
15:16:59 <Twey> But I'm starting to think I should just RTFP.  
15:17:26 <jmcarthur_work> the graph of (1+) for [1..5] is zip [1..5] [2..6]
15:17:50 <ski> zzaz : when `fibonacci' is called on `n', it constructs an array `arr' with indices from `0' to `n' which is recursively defined
15:18:06 <zzaz> does that copy the array many times?
15:18:14 <frwmanners> zzaz: no
15:18:41 <frwmanners> zzaz: so, in other languages, you would put a special value in the array meaning "undefined" or "not yet calculated"
15:18:52 <ski> zzaz : each element is defined by applying the  fib'  function to its index, and that function is written in the usual style with base cases, except instead of calling itself recursively, it calls  fib  instead (which just just indexes into `arr')
15:19:17 <frwmanners> zzaz: in haskell, it just doesn't bother to calculate that value until it is needed
15:19:39 <ski> zzaz : one new array `arr' is constructed for each call to `fibonacci', but within such a call, the same array is reused (this provides the memoization)
15:19:58 <jmcarthur_work> the array is initially an array of thunks. whenever you need a value, it forces the appropriate thunk, which replaces the thunk with the value (basically)
15:20:21 <ski> Twey : "Read The Fine P?" ?
15:20:36 <jmcarthur_work> read the f-ing paper?
15:20:48 <zzaz> what's tabulate?
15:21:00 <frwmanners> @src tabulate
15:21:00 <lambdabot> Source not found. There are some things that I just don't know.
15:21:07 <jmcarthur_work> @hoogle tabulate
15:21:07 <lambdabot> No results found
15:21:09 <ski> <ski> @let tabulate :: Ix i => (i,i) -> (i -> a) -> Array i a; tabulate ix f = array ix [f `graph` i | i <- range ix]
15:21:15 <frwmanners> aha
15:21:22 <ski> <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f
15:21:54 <frwmanners> zzaz: (it makes an array by applying a given function to each index)
15:22:10 <ski> zzaz : if you want, you can replace the  f `graph` i  there with  (i,f i)  .. it's the same, here
15:22:58 <frwmanners> zzaz: i.e. tabulate indexRange f = array indexRange [(i, f i) | i <- range indexRange]
15:23:05 <ski> (jmcarthur_work : oh, right, `tabulate' would be a fine addition to `Data.Array', i think :)
15:23:16 <zzaz> oh ok
15:23:35 <Cale> Another way to think of it operationally is that it initialises the array with the *expressions*  f 0, f 1, f 2, ... and when those expressions get evaluated, they are replaced with their values.
15:23:35 <jmcarthur_work> *sigh* i really should start an actual list...
15:23:52 <kmc> what's the best way to tell if two values are represented by the same closure?
15:23:58 <kmc> i.e. compare by pointer equality
15:24:03 <Cale> kmc: Hard to do.
15:24:05 <jmcarthur_work> the best way is not to do it
15:24:32 <Cale> kmc: The GC is always copying things and moving them around, and so it's really not easy to rely on.
15:24:33 <jmcarthur_work> identity is not something we take too kindly to around these parts ;)
15:24:58 <ski> (the name `tabulate' is stolen from SML .. in OCaml it is called `init', which doesn't seem as useful a name)
15:25:02 <jmcarthur_work> if you really want a concept of identity, you could have an IntMap or something
15:25:11 <kmc> i'm embedding an expression DSL
15:25:25 <kmc> and want to see the user's 'let's
15:25:29 <kmc> this seems to come up fairly often
15:25:36 <ski> didn't augustss do some dirty tricks for that situation ?
15:25:39 <FunctorSalad> stable names?
15:25:45 <jmcarthur_work> ski, extremely dirty
15:25:54 <zzaz> but in my problem, the array has two indices and i don't know ahead of time what the indices are, how do i do that?
15:25:59 <Apocalisp> Thanks, Twey.
15:26:00 <FunctorSalad> (that was @kmc, not @ski)
15:26:08 <Twey> Apocalisp!
15:26:09 <ski> @kmc
15:26:09 <lambdabot> Maybe you meant: ghc rc src
15:26:11 <Twey> You're here!
15:26:14 <kmc> i'm well aware that it will involve loads of unsafeFoo
15:26:18 <Twey> preflex: seen Apocalisp
15:26:20 <frwmanners> zzaz: depends what you mean by "ahead of time"
15:26:30 * Twey shakes his hea.d
15:26:35 <frwmanners> zzaz: I guess you know what they are by the time you call minsum
15:26:38 <Twey> s/\.d/d./
15:26:41 <preflex>  Apocalisp was last seen on #haskell 42 seconds ago, saying: Thanks, Twey.
15:26:47 <Cale> kmc: The best way is to do a deeper embedding, I think.
15:26:56 <kmc> Cale, do you have an example?
15:26:56 <Twey> Oh, it only measures message time, I guess.
15:27:07 <Cale> kmc: and represent the expression graph explicitly with an IntMap
15:27:16 <zzaz> for example if your function took strings and returned a string and you want to memoize that, can you do that with arrays?
15:27:22 <ski> Twey : `{(a,b) : A * B | f a = b}' is a subset of `A * B', ok ?
15:27:24 <Cale> (Or just a Map, if you'd rather use something else for your vertices)
15:27:34 <jmcarthur_work> zzaz, oh that's a tougher one
15:27:42 <zzaz> because i was thinking of using Data.Map
15:28:01 <frwmanners> zzaz: just to clarify: do you mean there is some DP operating on strings which you want to do by memoization
15:28:04 <jmcarthur_work> in either case you would have to know the range of values you might have beforehand, which is probably not all that possible with strings
15:28:07 <Cale> zzaz: Data.Map is indeed a better option there.
15:28:09 <RyanT5000> is there any Id type? i'm using a newtype right now (newtype Id a = Id a), and the manual boxing/unboxing is quite annoying
15:28:15 <ski> @index Identity
15:28:20 <frwmanners> zzaz: or do you mean there is some funcion from strings to strings you are going to call frequently
15:28:28 <ski> @botsmack
15:28:28 <lunabot>  :o
15:28:42 <ski> RyanT5000 : `Control.Monad.Identity', iirc
15:28:46 <jmcarthur_work> err, the domain of values, i think i mean
15:28:55 <kmc> i'm reading http://www.cse.unsw.edu.au/~chak/papers/accelerate.pdf and they seem to have this problem
15:28:57 <zzaz> um yea how do i memoize that?
15:28:58 <Cale> zzaz: But unless you know which strings you want to memoise it on, you'd end up doing something a little more sophisticated.
15:29:04 <kmc> and i ran into it doing something similar a while back
15:29:09 <RyanT5000> ski: yeah, that's exactly equivalent to what i'm doing
15:29:15 <kmc> and solved it also by doing CSE manually, but that seems ugly
15:29:17 <jmcarthur_work> maybe a state monad would be a good idea in this case?
15:29:20 <RyanT5000> ski: what i'd really like is "type Id a = a"
15:29:51 <Twey> ski: Oh!
15:29:57 <Twey> ski: I see it!
15:30:13 <ski> RyanT5000 : or the ability to import a type synonym abstracty or not ..
15:30:28 <ski> Twey : that subset can be represented with a map `A * B >-> Bool' ..
15:30:29 <Twey> It's two assertions in one: (a, b) : A * B, and graph f = { (a, b) | f a = b }
15:30:44 <RyanT5000> ski: yeah, that also seems useful
15:30:47 <ski> Twey : .. or with an *injective* map `X >-> A * B', for some `X'
15:31:04 <frwmanners> Cale: disagree, I think
15:31:19 <frwmanners> Cale: can't you use an infinite character trie?
15:31:54 <ski> Twey : one can think of the `X' there as `{(a,b) : A * B | f a = b}', but any `X' which "points" (injectively) at the right subset of `A * B' works ..
15:32:03 <ski> Twey : e.g. `A' works as `X'
15:32:06 <Cale> frwmanners: Well, yeah, I suppose that will work, but again, it's fancier than just using Data.Map
15:32:07 <frwmanners> data Trie a = Node (Array Char (a, Trie a)) or there abouts
15:32:10 <ski> hence `A >-> A * B'
15:32:13 <ski> @type graph
15:32:14 <frwmanners> Cale: sure
15:32:20 <Alpounet> a fish \o/
15:32:46 <ski>   graph :: Arrow (~>) => (a ~> b) -> (a ~> (a,b))
15:32:53 <frwmanners> Cale: I thought by "sophisticated" you meant unsafePerformIO magic
15:32:53 <jmcarthur_work> does plot make more sense for that function than graph?
15:33:10 <Cale> frwmanners: No, I'm ignoring the existence of unsafePerformIO altogether :)
15:33:28 <jmcarthur_work> my mind keeps saying graph should be the complete set of points for the function whereas plot could be a subset of that
15:33:34 <jmcarthur_work> but my mind could be wrong
15:33:49 <frwmanners> Cale: It's a shame that efficient data structures for this kind of thing - like hashing - just won't work without it
15:33:49 <ski> Twey : re "two assertions in one" .. well, somewhat, though those two are really fused and inseparable
15:34:07 <jmcarthur_work> i'm not sure my definitions are the proper mathematical definitions though
15:34:19 <ski> Twey : `a' and `b' are only in scope in the `f a = b' inside the `{(a,b) : A * B | f a = b}'
15:34:32 <Twey> Aye.
15:34:36 <FunctorSalad> what are you discussing about? (the graph thing)
15:34:38 <SamB_XP_> jmcarthur_work: well, I was under the impression that to plot was to position the pairs in a plane such that it looks like a squiggle ;-)
15:34:42 <Apocalisp> Twey: Yes, I lurk.
15:34:49 <Twey> Apocalisp: Hehe.
15:34:52 <ski> Twey : the `: A * B' is just a type annotation on set we're taking a subset of / what the type of the elements are
15:34:58 <Apocalisp> Although I'm surprised lambdabot didn't see me in #scala a few minutes earlier.
15:35:08 <FunctorSalad> looks like the pullback of f and id_B
15:35:14 <Twey> \b's @seen is broken.
15:35:14 <ski> Twey : you can in many cases "infer" that, so just write simply `{(a,b) | f a = b}'
15:35:20 <Twey> We're using preflex at the moment.
15:35:28 <Cale> Not just broken, disabled :)
15:35:33 <Twey> Yes
15:35:37 <Twey> Broken and thus disabled :
15:35:56 <Apocalisp> Oh, it's preflex. Riiight.
15:36:08 <kmc> so if i'm writing my expression EDSL and i want to define Num (Expr Int), what representation can I use for (Expr Int) such that I can see the sharing in "let x = e in x + x"
15:36:12 <jmcarthur_work> SamB_XP_, "to be marked or located by means of measurements or coordinates, as on plotting paper."  (ignoring the "as on plotting paper" part?)
15:36:17 <preflex> I love you!
15:36:17 <ski> FunctorSalad : yes
15:36:31 <SamB_XP_> jmcarthur_work: well, I wasn't
15:36:46 <zzaz> how do you use Data.Map for complicated memoization (examples)?
15:36:51 <SamB_XP_> I just couldn't think of a way to say "as" without actually specifying a media ;-)
15:37:41 <kmc> zzaz, not a direct answer but have you seen the data-memocombinators package?
15:37:50 <roconnor> |randomwords|: here
15:37:52 <jmcarthur_work> i guess graph is fine
15:37:57 <zzaz> no i'll go check it out
15:39:28 <|randomwords|> roconnor: Nothing big - just noticed a mistake in your Data.Colour documentation. you say "affineCombo [(0.2,a), (0.3,b)] c == 0.2*a + 0.3*b + 0.4*c", which I think is wrong. Confused me for a while
15:39:41 <roconnor> oops
15:39:45 <roconnor> that doesn't add up
15:39:54 <ski> Twey : btw, cf. `\((a,b) :: (A,B)) -> f a == b'
15:40:36 <|randomwords|> roconnor: At first I thought there might be some weird nuances to the arithmetic of colours
15:40:51 <roconnor> :)
15:40:58 <|randomwords|> roconnor: Anyway, sorry to disturb you, it's a bit trivial I guess
15:41:32 <roconnor> fixed on my machine
15:41:33 <lawful_evil> so haskell, it beter than sliced bread?
15:41:41 <roconnor> all tests still pass
15:41:43 <roconnor> :D
15:41:45 --- mode: ChanServ set +o mauke
15:41:46 --- mode: mauke set +b *!*@w005.z209031033.sjc-ca.dsl.cnc.net
15:42:09 <|randomwords|> It's a nice module. I look forward to using it
15:42:21 <|randomwords|> s/module/package
15:42:30 <kmc> okay i found a paper "Type-Safe Observable Sharing in Haskell"
15:42:46 --- mode: mauke set -o mauke
15:43:56 <kmc> ah, using StableName
15:44:43 <SamB_XP_> kmc: is that one of those Lava papers ?
15:46:19 <kmc> it mentions lava a lot, yeah
15:46:35 <kmc> Andy Gill, university of kansas
15:47:17 <SamB_XP_> thought it sounded familiar ;-)
16:11:16 <roconnor> @type \f x y-> flip f =<< x =<< y
16:11:32 <roconnor> where are bots when you need them.
16:11:36 <mauke> dead
16:11:53 <roconnor> ,type \f x y-> flip f =<< x =<< y
16:11:54 <Cale> Oh, did it finally die?
16:11:54 <lunabot>  luna: parse error on input `type'
16:12:07 <roconnor> ,[|$type \f x y-> flip f =<< x =<< y]
16:12:08 <lunabot>  luna: parse error on input `\'
16:12:42 <Gracenotes> oh, darn, I was about to go pl'ing with it too.
16:12:42 <Cale> now...
16:12:44 <Cale> > ()
16:12:48 <mauke> , [$ty| \f x y-> flip f =<< x =<< y ]
16:12:49 <lambdabot>  Terminated
16:12:49 <lunabot>  luna: lexical error in string/character literal at end of input
16:12:55 <Cale> okay... need mueval
16:12:56 <Gracenotes> hmmmmmmmm
16:12:59 <mauke> , [$ty| \f x y-> flip f =<< x =<< y |]
16:13:01 <lunabot>  forall a2 b a1 a . (a -> a1 -> b) ->
16:13:01 <lunabot>                     (a2 -> a -> a1) -> (a -> a2) -> a -> b
16:13:23 * Cale builds...
16:13:29 <Gracenotes> @pl (\a b -> f (g a) b)
16:13:35 <lambdabot> f . g
16:13:40 <Cale> > ()
16:13:49 <roconnor> ,type \f x y-> (flip f =<< x) =<< y
16:13:49 <lambdabot>   ()
16:13:50 <lunabot>  luna: parse error on input `type'
16:13:55 <roconnor> @type \f x y-> (flip f =<< x) =<< y
16:14:00 <Cale> > product [1..300]
16:14:03 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a -> a1 -> m b) -> (a -> a1) -> m a -> m b
16:14:09 <lambdabot>   306057512216440636035370461297268629388588804173576999416776741259476533176...
16:14:24 <Cale> Probably still joining channels, but it seems to work, anyway.
16:14:42 <Cale> now... probably should put something in place to catch stray muevals...
16:14:49 <roconnor> @type \f x y-> (flip f <$> x <*> y)
16:14:49 <lambdabot> forall a a1 c (f :: * -> *). (Applicative f) => (a -> a1 -> c) -> f a1 -> f a -> f c
16:17:27 <Gracenotes> @type IM.findWithDefault
16:17:28 <lambdabot> forall a. a -> IM.Key -> IM.IntMap a -> a
16:18:10 <roconnor> > (\f x y-> (flip f <$> x <*> y)) const (Left "x") (Left "y")
16:18:11 <lambdabot>   No instance for (Control.Applicative.Applicative
16:18:11 <lambdabot>                     (Data....
16:18:27 <roconnor> > (\f x y-> (flip f <$> x <*> y)) (liftM2 const) (Left "x") (Left "y")
16:18:28 <lambdabot>   No instance for (Control.Applicative.Applicative
16:18:28 <lambdabot>                     (Data....
16:18:40 <Cale> It's probably not importing everything that it used to.
16:18:46 <roconnor> > (\f x y-> (flip f <*> x <*> y)) (liftM2 const) (Left "x") (Left "y")
16:18:47 <lambdabot>   Couldn't match expected type `(a -> a2) -> a -> a1'
16:18:59 <Cale> I'll worry about that once we can find out if we can recover the data from the other server.
16:20:24 <roconnor> @undo do { a <- x ; b <- y; return f a b}
16:20:24 <lambdabot> x >>= \ a -> y >>= \ b -> return f a b
16:20:29 <ski> , help
16:20:31 <lunabot>  type of an expression:      , [$ty| \x -> x |]
16:20:31 <lunabot>  get info for a type/class:  , src ''Monad
16:20:31 <lunabot>  get info for a var/con:     , src 'fix
16:20:39 <ski> , [$ty| () |]
16:20:41 <lunabot>  ()
16:20:50 <roconnor> @undo do { a <- x ; b <- y; f a b}
16:20:50 <lambdabot> x >>= \ a -> y >>= \ b -> f a b
16:22:58 <roconnor> > (\f x y ->  x >>= \ a -> y >>= \ b -> f a b) (liftM2 const) (Left "x") (Left "y")
16:22:58 <lambdabot>   Left "x"
16:23:09 <roconnor> > (\f x y ->  y >>= \ a -> x >>= \ b -> flip f a b) (liftM2 const) (Left "x") (Left "y")
16:23:10 <lambdabot>   Left "y"
16:23:19 <ski> apparently `Either e' is not currently an instance of `Applicative'
16:24:48 <roconnor> > (\f x y-> (flip f `liftM` x `ap` y)) (liftM2 const) (Left "x") (Left "y")
16:24:49 <lambdabot>   No instance for (GHC.Show.Show (m a1))
16:24:49 <lambdabot>    arising from a use of `M712447728...
16:24:59 <roconnor> @type (\f x y-> (flip f `liftM` x `ap` y)) (liftM2 const) (Left "x") (Left "y")
16:24:59 <lambdabot> forall a1 (m :: * -> *). (Monad m) => Either [Char] (m a1)
16:25:08 <roconnor> @type (\f x y-> (flip f `ap` x `ap` y)) (liftM2 const) (Left "x") (Left "y")
16:25:08 <lambdabot>     Couldn't match expected type `(a -> a2) -> a -> a1'
16:25:09 <lambdabot>            against inferred type `Either [Char] b'
16:25:09 <lambdabot>     In the second argument of `(\ f x y
16:25:18 * roconnor can't Haskell
16:25:42 <SamB_XP_> roconnor: has you teh dumb ?
16:25:46 <roconnor> yep
16:25:55 <ski> > (\f x y -> y >>= (x >>=) . flip f) (liftM2 const) (Left "x") (Left "y")
16:25:55 <lambdabot>   Left "y"
16:26:17 <skorpan> why not just use (Left "y")... same thing
16:26:43 <roconnor> skorpan:  (\f x y -> y >>= (x >>=) . flip f) is the object of interest here
16:27:09 <skorpan> you can't haskell
16:27:13 <jmcarthur_work> > Left 4 `ap` Right 5
16:27:13 <lambdabot>   Add a type signature
16:27:24 <jmcarthur_work> > Left 4 `ap` Right 5 :: Either Int Int
16:27:25 <lambdabot>   No instance for (Control.Monad.Error.Class.Error GHC.Types.Int)
16:27:25 <lambdabot>    arising ...
16:27:38 <jmcarthur_work> > Left "foo" `ap` Right 5 :: Either Int Int
16:27:39 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:27:43 <jmcarthur_work> > Left "foo" `ap` Right 5 :: Either String Int
16:27:44 <lambdabot>   Left "foo"
16:28:12 <roconnor> I thought it'd be easy to take an object of type a -> b -> m c and objects of type m a and m b  and get an object of type m c.
16:28:31 <jmcarthur_work> roconnor, ah, you want extendM2 :)
16:28:37 <jmcarthur_work> which isn't done for you :(
16:28:42 <roconnor> extendM2?
16:28:53 <roconnor> @type liftM2
16:28:53 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:29:03 <roconnor> @type ap
16:29:04 <ski>   extendM2 :: Monad m => (a -> b -> m c) -> (m a -> m b -> m c)
16:29:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:29:11 <jmcarthur_work> basically like that, but for monads :)
16:29:12 <ski> @type (=<<)
16:29:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:29:36 <roconnor> jmcarthur_work: it seems like a useful function
16:29:37 <jmcarthur_work> actually, maybe the M in extendM is pointless
16:29:52 <jmcarthur_work> roconnor, i plan to include it in my upcoming alternative standard library
16:29:54 <roconnor> jmcarthur_work: does it exist for applicative?
16:29:57 <jmcarthur_work> no
16:30:01 <jmcarthur_work> it's monadic only
16:30:05 <roconnor> ah
16:30:10 <roconnor> fortunately I have a monad
16:30:15 <jmcarthur_work> liftA2 and company are the applicative versions
16:30:44 <roconnor> I mean does such a function exist at all for applicative functors?
16:30:58 <jmcarthur_work> no
16:31:02 <roconnor> ok
16:31:18 <Gracenotes> hm. it would be interesting to have a truly lazy map, where you can construct it corecursively. tying the knot between nodes, but for it to be possible to create nodes as you go rather than having to list them beforehand.
16:31:31 <orbitz> baaah you can't draw a point with SOE?!
16:31:44 <jmcarthur_work> i keep saying "my" alternative library, but i don't really mean that. i don't want to be the only one working on it
16:31:44 <roconnor> Gracenotes: I'm confused.
16:31:59 <roconnor> jmcarthur_work: The_Other_Prelude?
16:32:06 <jmcarthur_work> not just a prelude
16:32:12 <Gracenotes> hmm, yeah. the normal node-dependent setup is  d = Map.fromList $ map (\x -> (x, f x)) $ listOfKeys, and f = ... d ! key ... assuming, of course that the dependencies are not cyclic.
16:32:28 <jmcarthur_work> roconnor, basically a "break all backward compatibility" standard library
16:32:35 <Gracenotes> you have to list the keys before hand. the Map can't be constructed otherwise, of course
16:32:58 <jmcarthur_work> but definitely drawing inspiration from The Other Prelude
16:33:23 <jmcarthur_work> also from numeric-prelude, category-extras, etc.
16:33:28 <Gracenotes> and if the map was mutated, then it couldn't be constructed by tying the knot. So all the final keys have to be listed beforehand.
16:34:10 <ski> > (\f x y -> y >>= \b -> x >>= \a -> flip f y x) (liftM2 const) (Left "x") (Left "y")
16:34:11 <lambdabot>   Left "y"
16:34:20 <ski> > (\f x y -> y >>= \b -> x >>= \a -> flip f y x) ((return .) . const) (Left "x") (Left "y")
16:34:21 <lambdabot>   Left "y"
16:34:30 <Gracenotes> hm.. perhaps you could do it by filtering the list for values... but that might involve an infinite list...
16:34:35 <ski> > (\f x y -> y >>= \b -> x >>= \a -> flip f y x) ((return .) . const) (Right "x") (Right "y") :: Either String String
16:34:35 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:34:36 <Gracenotes> infinite loop, I mean
16:34:52 <Gracenotes> roconnor: do you sort of get what I mean?
16:35:13 <roconnor> Gracenotes: nope, but i kinda understand what you mean by map now.
16:35:17 <ski> > (\f x y -> y >>= \b -> x >>= \a -> flip f b a) ((return .) . const) (Left "x") (Left "y")
16:35:18 <lambdabot>   Left "y"
16:35:25 <ski> > (\f x y -> y >>= \b -> x >>= \a -> flip f b a) ((return .) . const) (Right "x") (Right "y") :: Either String String
16:35:26 <lambdabot>   Right "x"
16:37:25 <sgf> Gracenotes: So you could take the approach to, for example, construct a fast(ish) look-up memoized function from Integers?
16:37:27 <ski> @type (\f x y -> y >>= \b -> x >>= \a -> flip f y x)
16:37:28 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (m a1 -> m a -> m b) -> m a1 -> m a -> m b
16:37:28 <ski> @type (\f x y -> y >>= \b -> x >>= \a -> flip f b a)
16:37:29 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a1 -> a -> m b) -> m a1 -> m a -> m b
16:37:35 <ski> roconnor : ^ ?
16:38:13 <Gracenotes> sgf: something like that, except that it will form an actual cross-referencing data structure.
16:38:25 <ski> (roconnor : iow, why you used `liftM2 const' rather than `(return .) . const' ?)
16:39:22 <sgf> If you convert the thing you're memoizing to a binary string, and use that as a path into a binary tree holding all the values of the function, you get a function memoized with the memoisation costing log n, and the function you're memoising can do the corecursive thing.
16:39:51 <sgf> So, more a generalisation of that kind of approach for arbitrary other key types?
16:40:17 <Gracenotes> hm. well, I am using an IntMap, which already does the trie thing you are talking about :) but not as lazily
16:40:49 <sgf> Oh, that's how intmaps work? Never looked inside. :)
16:41:46 --- mode: ChanServ set +o mauke
16:41:47 --- mode: mauke set -b *!*@w005.z209031033.sjc-ca.dsl.cnc.net
16:42:46 --- mode: mauke set -o mauke
16:44:26 <Gracenotes> hm...
16:44:59 <jmcarthur_work> @type let foo f m x = m >>= f x in foo
16:45:00 <lambdabot> forall t a (m :: * -> *) b. (Monad m) => (t -> a -> m b) -> m a -> t -> m b
16:45:02 <jmcarthur_work> @type let foo f m x = m >>= f x in foo . foo
16:45:03 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
16:45:07 <jmcarthur_work> @type let foo f m x = m >>= f x in foo . foo . foo
16:45:08 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> a1 -> m b) -> m (m a1) -> m a -> m b
16:45:10 <jmcarthur_work> @type let foo f m x = m >>= f x in foo . foo . foo . foo
16:45:11 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> a1 -> m b) -> m (m a) -> m (m a1) -> m b
16:45:19 <jmcarthur_work> i'm not sure what to call foo
16:46:11 <jmcarthur_work> but i find its behavior when composed kind of cool
16:46:45 <Botje> aargh, type system soup!
16:46:56 <sgf> Gracenotes: So how does what you're thinking of compare with http://haskell.org/haskellwiki/MemoTrie ?
16:46:57 <lambdabot> Title: MemoTrie - HaskellWiki
16:47:02 <Gracenotes> oh, I was thinking earlier, maybe pl can handle this nicely, but probably not..
16:47:30 <Gracenotes> @pl \f g a b c -> f (g a) (g b) (g c)
16:47:30 <lambdabot> join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
16:47:37 <Gracenotes> DO NOT WANT
16:47:52 <jmcarthur_work> variant of on?
16:48:12 <jmcarthur_work> @src on
16:48:13 <lambdabot> (*) `on` f = \x y -> f x * f y
16:48:20 <Gracenotes> yeah, like on with three instead of two
16:48:34 <jmcarthur_work> @pl (*) `on` f = \x y -> f x * f y
16:48:34 <lambdabot> (line 1, column 12):
16:48:34 <lambdabot> unexpected "="
16:48:34 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
16:48:43 <jmcarthur_work> @pl on (*) f = \x y -> f x * f y
16:48:43 <lambdabot> (line 1, column 10):
16:48:43 <lambdabot> unexpected "="
16:48:43 <lambdabot> expecting variable, "(", operator or end of input
16:48:56 <Twey> on3 o f x y z = o (f x) (f y) (f z)
16:49:03 <Twey> I'm sure there must be a generalisation of that
16:49:14 <jmcarthur_work> @where (~>)
16:49:14 <lambdabot> I know nothing about (~>).
16:49:22 <jmcarthur_work> @where ~>
16:49:22 <lambdabot> I know nothing about ~>.
16:49:28 <Gracenotes> I've hand-pl'ed on to: liftA2 (.) (flip (.)) . (.)
16:51:20 <Gracenotes> it was going to be used with one of the gtk functions that needs three arguments, R G and B
16:51:43 <heatsink> Why do the mtl and transformers packages define the same modules?
16:52:24 <ski> jmcarthur_work : ?
16:52:34 * heatsink ran into problems the very first time it used cabal-install
16:56:31 * randomwords curses floor for being so slow
16:56:40 <jmcarthur_work> Gracenotes, http://matt.immute.net/content/pointless-fun
16:56:41 <lambdabot> Title: Pointless fun | mh
16:57:19 <Gracenotes> yes, I've seen that
16:58:02 <jmcarthur_work> i, too, have quested for a generalization for on, and that's the closest i can find
16:59:07 <Gracenotes> generalizations in arity tend to be doomed to fail :(
17:00:32 <Twey> Gracenotes: Clearly, you have not seen Oleg's work on the subject.
17:01:02 <heatsink> Can I specify that a module be imported from a specific package?
17:01:30 <Gracenotes> Twey: does it include some form of inductive natural type numbers to represent arity or some craziness?
17:02:14 <Gracenotes> or do you have to explicitly specify each arity..?
17:04:31 <Twey> Gracenotes: http://okmij.org/ftp/Haskell/types.html#polyvar-fn
17:04:32 <lambdabot> Title: Haskell Programming: Types
17:05:55 <Gracenotes> oh, the printf thing
17:06:37 <Gracenotes> I'm not sure if one could integrate that with an arbitrary n-arged function
17:07:54 <Gracenotes> thinking specifically of an on generalization
17:13:05 <Alpounet> I hate PHP.
17:17:13 <Twey> Gracenotes: Oleg says yes.
17:18:12 * Beelsebob ponders why \bot suddenly started spitting out tinyurls in #macosx again, didn't it get patched to stop doing that?
17:18:42 <Gracenotes> yeah, tinyurls don't grow on trees
17:19:00 <sjanssen> http://haskell.org
17:19:01 <lambdabot> Title: Haskell - HaskellWiki
17:19:19 <Beelsebob> http://cdn.okcimg.com/php/load_okc_image.php/images/16/150x150/558x800/21x0/186x165/0/9980179523457675594.jpeg
17:19:20 <lambdabot> http://tinyurl.com/moabaa
17:19:23 <Beelsebob> see ;)
17:19:39 <Beelsebob> also, she's always done it in here... she got patched to have it turned off in some channels
17:19:40 <sjanssen> perhaps there's a different path for things that aren't text/html?
17:19:52 <Beelsebob> but it's suddenly reoccurred
17:20:13 <sjanssen> the other possibility is that whoever hosts lambdabot now isn't running the same patches
17:20:55 <randomwords> Is lambdabot not sentient yet?
17:21:25 <benmachine> she's just not paying attention
17:21:42 <randomwords> She's such a tease..
17:21:55 <kmc> @quote php
17:21:55 <lambdabot> qwe1234 says: lisp is yet another half-assed run-of-the-mill scripting language. absolutely *no different* from something like php in any significant way worth mentioning.
17:22:07 <kmc> @quote php
17:22:07 <lambdabot> sieni says: python, like php, is just training wheels without the bike
17:22:23 <randomwords> Scathing
17:22:27 <SamB_XP_> heh
17:22:30 <kmc> @quote php
17:22:30 <lambdabot> Ethereal says: If this conversation had been had in #python #ruby or #php it would have lots of angry people shouting about how it doesn't matter or isn't true or isn't important and what's the
17:22:30 <lambdabot> point, and no, you guys are like ahhh but no, your preconceived notions of dimensional space are so passe.
17:22:34 <SamB_XP_> is sieni even a troll ?
17:22:56 <orbitz> haha i wish i knew the context on that
17:23:00 <kmc> @quote php
17:23:00 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
17:23:00 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
17:25:20 <jmcarthur> why does GHC.Base have so much high level stuff in it?! :(
17:25:45 <copumpkin> File a ghc ticket!
17:25:54 <copumpkin> Subject: eww!
17:26:11 <jmcarthur> heh
17:26:25 <jmcarthur> man, all the GHC namespace has stuff that doesn't seem all that low level to me
17:26:26 <copumpkin> Cale: looks like the new lambdabot announces URL titles again :o
17:27:01 <jmcarthur> i mean really, do Functor and Monad need to be down there?
17:29:50 <SamB_XP_> jmcarthur: it's because they are needed *by* low level code
17:29:57 <SamB_XP_> so it doesn't look even worse
17:30:15 <SamB_XP_> and to avoid cyclic imports, or something ...
17:31:44 <ski> > let foo k f_ g a = k (f_ (g a)) g in (($ f) . foo . foo . foo) const (g :: Expr -> Expr) a b c :: Expr  -- Gracenotes
17:31:45 <lambdabot>   f (g a) (g b) (g c)
17:32:05 <copumpkin> o.O
17:32:27 <ski> nice, eh ?
17:32:29 <Gracenotes> well, not fully automatic, but fully awesome nonetheless
17:33:17 <copumpkin> foo looks familiar
17:33:28 <copumpkin> oh I guess not with the extra g at the end
17:33:34 <FunctorSalad> omg what is that?
17:33:46 <copumpkin> multion
17:33:52 <ski> .. just a little thing i cooked together
17:34:04 <copumpkin> @pl foo k f_ g a = k (f_ (g a)) g
17:34:04 <lambdabot> foo = flip flip id . (liftM2 flip .) . (. (.)) . (.) . (.)
17:34:06 <copumpkin> :o
17:34:09 <copumpkin> @pl foo k f_ g a = k (f_ (g a))
17:34:09 <lambdabot> foo = (. (.)) . (.) . (.)
17:34:38 <FunctorSalad> "No definitions were found for multion."
17:34:44 <copumpkin> multi-on
17:34:51 <FunctorSalad> ah
17:35:16 <Gracenotes> camelCase
17:35:50 <copumpkin> bactrianCamelCase
17:37:00 <kmc> @quote perl
17:37:00 <lambdabot> mauke says: I'd prefer something hacked up in perl, using regexes
17:37:03 <ski> > let foo k g fg_ a = k g (fg_ (g a)) in ((($ f) .) . foo . foo . foo) (flip const) (g :: Expr -> Expr) a b c :: Expr  -- alternative
17:37:04 <lambdabot>   f (g a) (g b) (g c)
17:37:17 <ski> @pl foo k g fg_ a = k g (fg_ (g a))
17:37:18 <lambdabot> foo = (`ap` flip (.)) . (((.) . (.)) .)
17:37:28 <aavogt> heatsink: http://haskell.org/ghc/docs/6.10-latest/html/users_guide/syntax-extns.html#package-imports
17:37:29 <lambdabot> Title: 7.3.Syntactic extensions, http://tinyurl.com/kntvlr
17:37:42 <heatsink> aavogt: thanks
17:38:24 <aavogt> but you would probably be better off using  'ghc-pkg hide transformers' (or hide mtl)
17:39:20 <heatsink> Well, I was trying to use both packages and mtl at the same time.  I rewrote the part that I was using instead.
17:39:55 <heatsink> I should have used hide instead of uregister though >_>
17:40:14 <aavogt> yeah, mixing the two would probably get ugly
17:41:07 <ski> > let foo k fg_ a = k (fg_ ((g :: Expr -> Expr) a)) in (($ f) . foo . foo . foo) id a b c :: Expr
17:41:08 <lambdabot>   f (g a) (g b) (g c)
17:41:58 <ski> @pl \k fg_ a -> k (fg_ (g a))
17:41:58 <lambdabot> (. (. g)) . (.)
17:42:27 <ski> @type \g k fg_ a -> k (fg_ (g a))
17:42:28 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3) -> (t1 -> t2) -> t -> t3
17:50:59 <_nickel> anyone who's done the exercises in "algebra of programming" care to answer some questions for me?
17:51:04 <_nickel> only the first chapter :(
17:51:18 <_nickel> enjoying the read so far
17:52:23 <aavogt> _nickel: you're having trouble?
17:52:48 <_nickel> aavogt: sort of, I  get most of it but I think some of the terminology is throwing me off
17:52:51 <_nickel> my math is rusty
17:52:56 <_nickel> _very_
17:53:32 <_nickel> aavogt: trucking through with my discrete mathematics knowledge from 5 years ago :D
17:54:14 * SamB_XP_ learned next to nothing in that class
17:54:30 <SamB_XP_> (most of it I'd already learned playing with Coq etc ;-)
17:56:01 <_nickel> "give an example of a recursion equation that is not satisfied by any functions"
17:56:19 <_nickel> the example provided in the chapter is f (n) = f (n+1)
17:56:44 <aavogt> @src fix
17:56:44 <lambdabot> fix f = let x = f x in x
17:57:28 <heatsink> _nickel, that equation is satisfied by const 0
17:57:35 <heatsink> >const 0 4
17:57:37 <heatsink> > const 0 4
17:57:38 <lambdabot>   0
17:57:39 <_nickel> or any const correcT?
17:57:40 <heatsink> > const 0 5
17:57:40 <Cale> copumpkin: Yeah, I haven't set it up.
17:57:40 <lambdabot>   0
17:57:43 <heatsink> yes
17:58:01 <aavogt> > let f n = f (n+1) in f 0 > (10::Nat)
17:58:01 <lambdabot>   Not in scope: type constructor or class `Nat'
17:58:06 <aavogt> > let f n = f (n+1) in f 0 > (10::Natural)
17:58:12 <lambdabot>   mueval-core: Prelude.read: no parse
17:58:12 <lambdabot>  mueval: ExitFailure 1
17:58:18 <BMeph> So, has someone put the new Quicksort on Hackage yet? :)
17:59:35 <_nickel> heatsink: can you state "that equation is satisfied by const 0" in another way :D
18:00:58 <heatsink> The recurrence relation (forall n. f(n) = f(n+1)) is satisfied by assigning f the value (\n -> 0)
18:01:29 <heatsink> Actually, I'm not sure that's a recurrence relation
18:02:37 <copumpkin> aavogt: how would that work?
18:12:13 <aavogt> copumpkin: I was thinking of what happens if you put the +1 outside of the function argument
18:13:58 <heatsink> aavogt: Does  count as a number?
18:14:48 <aavogt> @type let (?) = 1 in (?)
18:14:51 <lambdabot> forall t. (Num t) => t
18:15:06 <aavogt> heatsink: did you use some other symbol?
18:15:23 * aavogt has no utf8 here
18:15:45 <dolio> omega
18:15:47 <heatsink> Oh.  I used omega, which is basically omega = fix (1+)
18:16:06 <BMeph> fix succ :)
18:16:32 <dolio> Nah, omega isn't a successor.
18:17:04 <copumpkin> > fix succ > (3 :: Natural)
18:17:04 <lambdabot>   True
18:17:14 <copumpkin> > fix succ < (3 :: Natural)
18:17:15 <lambdabot>   False
18:18:08 <heatsink> cool.
18:26:30 <chessguy> 'evening ya'all
18:27:29 <copumpkin> evening!
18:27:53 <Tony[`]> yo!
18:28:29 <chessguy> anybody up for a tiny bit of a discussion on 'why functional programming matters' (the paper)?
18:28:55 <Tony[`]> sure?
18:28:58 <chessguy> i've got a implementation (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9313#a9313), and i'm trying to figure out how to get rid of some duplication
18:29:06 <heatsink> I find it intriguing how English is acquiring several plural forms of the second person pronoun after losing this distinction a few centuries ago.
18:29:18 <chessguy> it's duplication that's in the paper itself. all the bit about maximise' and minimise'
18:29:47 <Adamant> depends on what part of English
18:30:16 <Adamant> the military just sticks with "he" for everything and then adds a little disclaimer note to the front of all their publications
18:31:04 <Warrigal> I didn't know "he" was a plural form of the second person pronoun.
18:31:20 <chessguy> there are 5 functions there (maximise, maximise', mapmin, omit, minleq) each of which has a function which logically duplicates it, just has a sign reversal, essentially
18:32:09 <Warrigal> @hoogle (a -> (a,b)) -> a -> [b]
18:32:09 <lambdabot> A Hoogle error occurred.
18:32:24 <BMeph> That paper just reminds me again about how asinine it seems to me to put a trademark on a communication protocol (i.e., programming language).
18:32:26 <chessguy> @type unfoldTree
18:32:27 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
18:32:55 <Adamant> Warrigal: I forget that y'all is technically valid English
18:33:10 <Gracenotes> @pl circle n=maybe n((9263+n)+)$fst<$>(find snd$zip[70,64,0,139]$(($n).inRange)<$>[(65,90),(97,122),(49,57),(48,48)])  -- just for fun...
18:33:10 <lambdabot> circle = ap (ap maybe ((+) . (9263 +))) ((fst <$>) . find snd . zip [70, 64, 0, 139] . (<$> [(65, 90), (97, 122), (49, 57), (48, 48)]) . flip inRange)
18:33:20 <Adamant> so I always screw up what second person pronouns are
18:33:23 <heatsink> Adamant, "he" actually comes from the merger of a masculine pronoun with a gender-neutral one.  This pronoun became masculine-only relatively recently.
18:33:26 <Gracenotes> hm. not as bad as I thought
18:33:39 <Warrigal> Adamant: what do you mean by "technically valid"? Alternatively, how do you know it's technically valid?
18:33:49 <Veinor> Gracenotes: Haha, what does that do?
18:33:54 <Adamant> Warrigal: the OED approves
18:33:57 <Adamant> IIRC
18:34:13 <Warrigal> I wonder just what the OED says about it.
18:34:14 <Gracenotes> I was code golfing for a character-shifting function
18:34:24 <Warrigal> I assume it doesn't put the word "approved" next to every word it considers standard.
18:34:36 <Adamant> Warrigal: standard is a form of approval
18:34:47 <Adamant> lots of words exist that don't hit the OED
18:35:01 <chessguy> i suppose i could pass static or (negate . static) into all 5 of those functions
18:35:06 <Gracenotes> > let circle n=maybe n((9263+n)+)$fst<$>(find snd$zip[70,64,0,139]$(($n).inRange)<$>[(65,90),(97,122),(49,57),(48,48)]) in text $ map (chr.circle.ord) "This is what is does, test 123, oh hai Veinor"
18:35:06 <lambdabot>       ,  ...
18:35:14 <chessguy> that seems awfully hackish though
18:35:17 <Gracenotes> what, you need some UTF-8 schooling, lambdabot
18:35:26 <Veinor> Yeah.
18:35:51 <lispy|web> heh, that's awesome
18:35:55 <Gracenotes> > text ""
18:35:56 <lambdabot>   
18:36:00 <lispy|web> what happneed to the 3?
18:36:02 <Veinor> What's it supposed to do, put everything in circles?
18:36:08 <lispy|web> Veinor: aye
18:36:12 <lispy|web> it does on my screen
18:36:26 <Veinor> Hm.
18:36:34 <Veinor> I think I'm going to boot back into linux anyway, I'm done with gaming.
18:36:39 <lispy|web> http://webchat.freenode.net
18:36:49 <Gracenotes> oddly enough, it works in PM:     ,  ,   
18:37:07 <lispy|web> so something about the truncation
18:37:26 <Gracenotes> I made it a month ago, about.. maybe lambdabot could pl it even more... who knows *does character counting*
18:37:53 <chessguy> no thoughts on my problem?
18:41:37 <Warrigal> > repeat 'a'
18:41:37 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
18:48:46 <randomwords> Is there a faster alternative to vanilla floor?
18:48:57 <chessguy> ehh, screw it. a little duplicate logic never killed anyone
18:49:07 <randomwords> I'll stab anyone who says chocolate floor
18:49:15 <heatsink> There may be something in GHC.Prim
18:49:21 <copumpkin> strawberry?
18:49:22 <SamB_XP_> randomwords: cherry floor!
18:49:27 <randomwords> ugh
18:49:32 <SamB_XP_> 'cause *red ones go faster*
18:49:41 <copumpkin> randomwords: how would it be made faster?
18:50:06 <randomwords> copumpkin: I don't need it to always be right
18:50:18 <copumpkin> -ffast-math if you compile -fvia-C maybe
18:50:32 <heatsink> randomwords, in that case, there are _tons_ of alternatives
18:50:33 <randomwords> if it was sometimes (floor x) +- that would be ok
18:50:40 <heatsink> oh
18:50:42 <SamB_XP_> randomwords: const 0
18:50:46 <copumpkin> lol
18:50:50 <randomwords> I'm sure there's some bit-tricks somewhere
18:51:01 <randomwords> well ballpark would be nice
18:51:06 <heatsink> Is round twice as fast as floor?
18:51:08 <lispy|web> glad to see lambdabot survived the move to a new host
18:51:16 <randomwords> oooh - is it?
18:51:23 <benmachine> @botsnack
18:51:24 <lunabot>  :o
18:51:24 <lambdabot> :)
18:51:33 <SamB_XP_> or could round be several times slower?
18:51:35 <SamB_XP_> who knows?
18:51:45 <lispy|web> ?hoogle (a -> b) -> [a] -> [b]
18:51:45 <lambdabot> A Hoogle error occurred.
18:51:48 <heatsink> You have floor, ceiling, and round... if one is faster, you could use that.
18:51:48 <Veinor> It seems to me that round would be slower, just at a guess.
18:51:49 <blackdog> randomwords: do you have an application where floor is your bottleneck?
18:51:51 <lispy|web> ah, well most of lambdabot
18:52:03 <copumpkin> float2Int# :: Float# -> Int#	
18:52:14 <randomwords> blackdog: It's taking 15% computation time
18:52:25 <chessguy> @hoogle (a -> b) -> [a] -> [b]
18:52:25 <lambdabot> A Hoogle error occurred.
18:52:27 <randomwords> which seems unreasonable
18:52:29 <chessguy> @hoogle map
18:52:30 <lambdabot> A Hoogle error occurred.
18:52:35 <chessguy> strange
18:52:36 <copumpkin> double2Int# :: Double# -> Int#	
18:52:40 <blackdog> randomwords: that is pretty weird. pastie?
18:53:17 <randomwords> blackdog: It's deep in quite a lot of stuff I'm experimenting with - I may paste it later
18:56:15 <randomwords> blackdog: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3574#a3574. Doesn't make too much sense in isolation.
18:57:20 <randomwords> But the rest of the code is really computation heavy so why this is taking so much time is beyond me
18:59:29 <randomwords> round appears to be as slow as floor
18:59:43 <Saizan_> lispy|web: someone forgot to install hoogle, maybe?
18:59:50 <copumpkin> @index floor
18:59:50 <lambdabot> Prelude
19:00:07 <heatsink> randomwords: Are you literally profiling 'fl'?  Because you might be partly measuring profiling and lambda-abstraction overhead.
19:00:07 <randomwords> eh - this is really weird
19:00:17 <copumpkin> randomwords: I can see why it's so slow
19:00:20 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Real.html#RealFrac
19:00:22 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/4wkpk4
19:00:38 <copumpkin> oh actually mayb enot
19:00:41 <ivanm> they really need to get hscolour to fix the title pages of those...
19:00:46 <randomwords> heatsink: Yeah - I'm lazy and adding SCC takes longer.
19:01:26 <copumpkin> it'd be nice to be able to look up where instances live
19:01:29 <Saizan_> (who's running lambdabot, btw?)
19:01:30 <copumpkin> they're so hard to find sometimes
19:01:33 <heatsink> GHC tries not to apply optimizations that would move code from one SCC to another.
19:01:34 <copumpkin> Saizan_: Cale I think
19:01:54 <Cale> I'm running lambdabot on lispy's new server.
19:02:04 <copumpkin> randomwords: http://hackage.haskell.org/trac/ghc/ticket/2271
19:02:05 <lambdabot> Title: #2271 (floor, ceiling, round :: Double -> Int are awesomely slow) - GHC - Trac
19:02:20 <copumpkin> randomwords: try truncate
19:02:29 <Saizan_> Cale: it misses hoogle, it seems
19:02:30 <Cale> The old server seems to have been compromised somehow, so they took it down and are going to look at it.
19:02:47 <Cale> Yeah, I installed lambdabot hastily.
19:02:51 <Cale> I'll install hoogle :)
19:02:52 <Saizan_> i see
19:03:23 <ivanm> Cale: compromised? as in security-wise?
19:03:25 <heatsink> Huh, so I guess it is a performance issue.
19:03:26 <Cale> yeah
19:04:03 <Cale> It was no longer accepting ssh connection attempts, and was running a game server.
19:04:04 <ivanm> a rival bot perhaps? :p
19:04:08 <ivanm> :o
19:04:10 <ivanm> what game[s]?
19:04:26 <Cale> freeciv, I think?
19:04:30 <lispy|web> Cale: we don't know for sure what was on port 5555, I just asked about freeciv because it uses that
19:04:31 <Cale> I forget
19:04:35 <Cale> ah
19:04:39 <ivanm> hmmm...
19:04:56 <SamB_XP_> lispy|web: isn't the only way to tell to try playing freeciv on it ?
19:05:06 <lispy|web> ivanm: we don't know for sure if it was compromised, but that seems likely.  It looks like they locked us out.  Which, ironically is silly because if they hadn't we may not have noticed for a while :)
19:05:14 <ivanm> heh
19:05:17 <SamB_XP_> ... though actually that might be a bad idea to do on a real machine
19:05:21 <Cale> lispy|web: Did you try connecting to that port to see what you get?
19:05:38 <lispy|web> Cale: I tried it in a web browser but not something simpler like telnet
19:05:58 <SamB_XP_> should have run nmap against it!
19:05:59 <Cale> ah, it's down now anyway, isn't it?
19:06:16 <ivanm> lispy|web: is this what you get for not running a statically-typed web server? :p
19:06:32 <copumpkin> randomwords: does truncate work any better? or those primops I pasted earlier?
19:06:53 <randomwords> copumpkin: Just profiling everything now. Will let you know
19:06:55 <lispy|web> ivanm: hehe yeah.  php (like my wordpress blog) is one of my suspects.  I was also running a private svn server that could have been the issue.
19:08:07 <lispy|web> See why I don't like svn!!! ;)
19:08:19 <randomwords> changing to truncate causes a link error...
19:09:04 <copumpkin> :o
19:09:33 <randomwords> yeah
19:09:38 <randomwords> :O indeed
19:09:40 <copumpkin> what kind of a link error?
19:09:41 <Axman6> ChilliX: you around?
19:10:24 <randomwords> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3575#a3575
19:10:40 <copumpkin> :o
19:10:45 <copumpkin> I mean, :O
19:10:56 <Gracenotes> hm. it might be nice to have an in-one-swoop Data.Map.insertIfAbsent that does no modification if the key is present. none such exists.. but one can't be so picky..
19:11:55 <Saizan_> Gracenotes: to not pay the double traversal with Map.member and Map.insert?
19:11:59 <copumpkin> Gracenotes: can't you do it with alter?
19:12:22 <Saizan_> randomwords: using --make ?
19:12:30 <Cale> Yeah, it's easy to write in terms of alter
19:12:46 <Gracenotes> actually, insertIfAbsent is not specific enough: I'd rather it insert if absent, return the value if it's present, and only modify the map in the former case
19:12:48 <randomwords> Saizan_: Yeah. I think it's a template haskell thing from elsewhere.
19:12:57 <randomwords> old object files
19:13:18 <randomwords> yeah - that did it
19:13:21 <Gracenotes> insertLookupWithKey is close but it modifies the map in both cases
19:14:15 <mjrosenb> hey, how do i tell ghc where to look for pacages?
19:14:35 <ivanm> mjrosenb: ghc-pkg register
19:14:36 <copumpkin> Gracenotes: alter with unsafePerformIO ;)
19:14:50 <Gracenotes> keen idea, a keen idea
19:14:58 <mjrosenb> *packages
19:15:06 <randomwords> copumpkin: Truncate is 2.5x faster
19:15:12 <Saizan_> mjrosenb: what problem are you trying to solve?
19:15:18 <Gracenotes> referential transparency ftw. unless it randomly decides whether to give you the lookup or not.
19:15:27 <copumpkin> randomwords: you could also try the primops directly, if you import GHC.Types and do -XMagicHash
19:15:43 <randomwords> copumpkin: Yeah
19:15:45 <Gracenotes> anyway, actually, given the disjointness of the two maps I'm working with, I might not need-need the method after all. member should suffice.
19:16:21 <mjrosenb> so hscurses says that after running runhaskeel Setup.hs install, adding -package hscurses should just work
19:16:38 <mjrosenb> however, it does not know about the package hscurses
19:17:41 <Saizan_> mjrosenb: does "ghc-pkg list" have hscurses in it?
19:17:53 <mjrosenb> no
19:18:29 <Saizan_> then the install didn't complete successfully
19:18:36 <Saizan_> did it report any error message?
19:18:52 <mjrosenb> nope
19:19:11 <mjrosenb> it did not return an error code either
19:19:19 <Saizan_> do you have more than one haskell compiler installed?
19:19:25 <mjrosenb> nope
19:20:11 <Saizan_> weird, can you paste the output of runhaskell Setup.hs install ?
19:20:18 <mjrosenb> mjrosenb@chance:~/src/hscurses$ sudo runhaskell Setup.hs install
19:20:19 <mjrosenb> (0)578/0
19:20:19 <mjrosenb> mjrosenb@chance:~/src/hscurses$
19:20:25 <mjrosenb> not very interesting
19:20:40 <Saizan_> that looks like something is borked
19:20:52 <Saizan_> install prints quite a bit of info, normally
19:20:53 <mjrosenb> the(0)578/0 is part of my prompt
19:20:53 <copumpkin> b0rk b0rk
19:21:25 <mjrosenb> it complains without the sudo
19:21:39 <mjrosenb> homm
19:21:41 <mjrosenb> *hrmm
19:21:46 <Saizan_> you could configure with --user, so it shouldn't complain without sudo
19:22:17 <Saizan_> another thing to try is to compile the Setup.hs script
19:22:28 <mjrosenb> oh
19:22:33 <mjrosenb> i have more than one gcc installed
19:22:45 <mjrosenb> and sudo and regular use different gcc's
19:23:39 <arsenm> does anyone know how to use c2hs with cabal so that it preprocesses your chs files for you?
19:23:41 <Saizan_> can you run ghci from superuser?
19:24:02 <Saizan_> arsenm: you just put the .chs files in the source tree
19:24:15 <Saizan_> arsenm: though it won't track imports between them
19:24:15 <mjrosenb> hrmm
19:24:24 <mjrosenb> now i am getting permision denied as root
19:24:26 <mjrosenb> this seems bad
19:24:30 <SamB_XP_> it tracks imports ?
19:24:50 <Saizan_> arsenm: you also need to make sure to list them in the .cabal file under exposed-modules or other-modules
19:24:51 <mjrosenb> grrr
19:24:54 <mjrosenb> stupid nfs
19:25:18 <arsenm> Saizan_: I think I'm doing that, but unless I do it myself before hand it fails
19:25:30 <Saizan_> SamB_XP_: for .hs files there's ghc --make, for .chs files there's no check to preprocess them in the right order
19:25:44 <SamB_XP_> ah, right :-(
19:26:02 <BMeph> Dang, I have to usethat point more often...
19:26:54 <Saizan_> arsenm: what's the error?
19:27:13 <BMeph> C++ Hacker: "Well, what can you do in Haskell that you can't do in C/C++?" Me: "Let me put it this way - what can you do with for/while loops that you can't do with gotos?" :)
19:27:51 <blackdog> BMeph: I thought you said "goats" at the end there
19:27:57 <blackdog> my mind went strange, unwholesome places.
19:28:05 <Raevel> goats are awesome
19:28:22 <BMeph> Yeah...what can't you do with goats? ;p
19:28:34 <blackdog> there are things i'd prefer to do with a woman
19:28:42 <blackdog> however anatomically capable the goat
19:29:22 <arsenm> Saizan_: it just doesn't find my module. I have the module listed in Exposed-modules
19:29:50 <BMeph> blackdog: What, making clothing out of a woman's hair? You're sick! ;p
19:30:00 <Saizan_> it says something like "couldn't find module X with extensions ..." ?
19:30:30 <blackdog> oh, so suddenly _I'm_ Buffalo Bill here.
19:30:49 <SamB_XP_> BMeph: I expect he was thinking of sex
19:30:53 <SamB_XP_> but that's off-topic here
19:31:02 <SamB_XP_> -> -blah with that ;-P
19:31:23 <arsenm> Saizan_: Just the usual "Could not find module `blah blah` use -v..."
19:31:24 <randomwords> I thought you might be talking about some strage Haruspicy-Programming combo
19:31:27 <Gracenotes> say, how can I model rabbit reproduction in Haskell?
19:31:27 <blackdog> SamB_XP_: I shall reel my libido in and concentrate on the ascetic pleasures of type systems.
19:31:42 <SamB_XP_> blackdog: ascetic ?
19:31:47 <blackdog> Gracenotes: I think you'll find we have a wide selection of fibonacci routines...
19:31:57 <Twey> Gracenotes: Generation Rabbit -> Generation Rabbit
19:32:03 <blackdog> SamB_XP_: you get hot and bothered about type families?
19:32:03 <SamB_XP_> I find typesystems pleasent because of all the typing they can save you ;-)
19:32:09 <blackdog> actually, that's a bad example. they're pretty sexy.
19:32:16 <Twey> Hehe.
19:32:19 <SamB_XP_> not so much because I like being chained up
19:32:31 <Saizan_> arsenm: does it create the corresponding .hs under dist/build/ though? it's quite strange
19:33:13 <arsenm> Saizan_: no it doesn't. I've been running c2hs "manually" in a script before running cabal to do that
19:34:20 <Saizan_> arsenm: which version of cabal? is the code somewhere public to test? it should really just work.
19:35:50 <mjrosenb> http://nopaste.com/p/a4EOXO76D
19:35:53 <Rotaerk> hmm what would you guys name a type like:  StateT GameState IO
19:35:58 <Rotaerk> would you just call it "Game"?
19:35:59 <mjrosenb> ghc does not like me today :(
19:36:19 <Saizan_> mjrosenb: you have to continue to use --user
19:36:38 <mjrosenb> oic
19:36:40 <mjrosenb> : (
19:36:44 <roconnor> GaMe
19:36:52 <mjrosenb> or just not use Setup.hs
19:36:57 <chessguy> any knot-tying fans around? i'm trying to figure out how to translate something like 'maximum' into a (TreeLoc a -> TreeLoc a). i have a feeling it can be solved by tying the knot
19:37:02 <Saizan_> you could just use cabal-install
19:37:07 <arsenm> Saizan_: I think I might just be using cabal incorrectly. Somewhere I saw that you add Build-tools c2hs or something like that (but I have that there, maybe there's also something else?). Also I was thinking maybe I need to list the files and not just the module name?
19:37:07 <chessguy> TreeLoc is a zipper, a la http://hackage.haskell.org/packages/archive/rosezipper/0.1/doc/html/src/Data-Tree-Zipper.html
19:37:08 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/lgpmr8
19:37:52 <Saizan_> arsenm: no, the module name is correct
19:40:21 <ChilliX> Axman6: hey
19:40:29 <Axman6> o/ ChilliX
19:40:32 <arsenm> Saizan_: actually I was wrong before, it is creating the hs files under dist/build.
19:40:57 <Axman6> ChilliX: i just wanted to get your attention because the haddock docs for http://hackage.haskell.org/package/accelerate are rather proken
19:40:57 <lambdabot> Title: HackageDB: accelerate-0.5.0.0
19:41:00 <Axman6> broken too
19:41:34 <Saizan_> arsenm: ok, that's more like what i expected
19:41:35 <ChilliX> Axman6: they are mostly absent...
19:41:49 <Saizan_> arsenm: then the problem is why ghc doesn't find it from there
19:41:56 <Axman6> ChilliX: ah, well i just found it odd that there were section headings, without sections...
19:42:51 <Axman6> ChilliX: is there any work on an OpenCL backend?
19:42:53 <Saizan_> arsenm: could you perhaps have a typo in the import statement?
19:43:14 <blackdog> is there a sensible way to find out if ghc of a given version or higher is available on the system?
19:43:21 <arsenm> Saizan_: I think I have a vague Idea of what the problem is. I have a module that imports submodules, and the issue with importing
19:43:22 <ChilliX> Axman6: yeah, this is because Haddock merges headings from re-exported modules with the headings in the current module
19:43:34 <ChilliX> I should use level 2 headings in the modules that get re-exported
19:43:36 <Axman6> ah, isee
19:43:41 <ChilliX> than it'll be nicer
19:43:44 <Axman6> <space>*
19:43:46 <ChilliX> good point, though
19:43:57 <Saizan_> arsenm: are you importing other .chs files from a .chs file?
19:44:34 <arsenm> Saizan_: Yes, and importing a bunch of....
19:44:44 <Axman6> ChilliX: so no OpenCL work?
19:44:52 <Saizan_> arsenm: ok, that's the problem i was pointing out earlier
19:45:12 <ChilliX> Axman6: well, if anybody wants to write an OpenCL backend
19:45:19 <Saizan_> arsenm: cabal currently doesn't make sure to preprocess .chs files in dependency order
19:45:28 <ChilliX> we'll first get our CUDA generator ported
19:45:28 * Axman6 wishes he had the time and knowhow :(
19:45:42 <Saizan_> arsenm: to workaround you can specify them in such order in the .cabal file, i think
19:45:43 <blackdog> ChilliX: how's the CUDA generator going?
19:45:50 <blackdog> have been salivating over that since Sean's talk...
19:45:57 <Axman6> i believe OpenCL and CUDA are fairly closely related
19:46:29 <Axman6> ChilliX: also, you should come down to canberra and give a talk about your work sometime ;)
19:46:35 <ChilliX> blackdog: seanl needs to port his stuff over from the old lib
19:46:50 <Axman6> dons is hopefully coming down in november btw
19:46:54 <ivanm> Axman6: :o
19:47:02 <ivanm> ChilliX: why, were are you based?
19:48:34 <ChilliX> Axman6: or you up to sydney, where I will talk about it: http://plrg.science.mq.edu.au/wiki/sapling/Meeting09
19:48:36 <lambdabot> Title: SAPLING - Meeting09 - Macquarie University Programming Languages Research Group
19:48:55 <ChilliX> ivanm: sydney
19:49:10 <Axman6> ChilliX: but how do you expect to convert the ANU students to loving Haskell if they have to go to syndey? :P
19:49:14 <ivanm> so it's not _really_ a question of up/down, but left/right ...
19:49:25 <Axman6> it's up/down
19:49:26 <ChilliX> Axman6: lol
19:50:08 <blackdog> Axman6: they have ben lippmeier to proselytise, right? so long as no-one mentions laziness
19:50:24 <Axman6> ChilliX: anyway, i think it would be awesome if you came down here when dons did, and we could have an awesome haskelly time and stuff :P
19:50:38 <ivanm> Axman6: when is this?
19:50:38 <Axman6> yeah... ben could talk too!
19:50:43 <Axman6> november
19:50:57 <ivanm> yes, but _when_ in november? ;-)
19:51:07 <Axman6> no idea yet
19:51:11 <ivanm> ahhhh
19:51:15 <ivanm> lemme know, willya?
19:51:34 <Axman6> ChilliX: hmm, i might be on holidays when that talk's on, i might be able to go to it
19:52:12 <Axman6> ivanm: will do. i haven't heard from dons any plans yet, but i'm hoping he's still interested. said he could come and visit his sister here
19:52:39 <arsenm> Saizan_: I'm pretty sure I have them in order. It only seems to partially work though. I think the issue is I have a higher level module where I import a bunch of chs files below that
19:52:41 <ivanm> and I could go and annoy^W visit my brother in canberra... >_>
19:52:47 <Axman6> heh
19:53:01 <Axman6> and see what a lovely campus ANU has, and why you're missing out :P
19:53:18 <Saizan_> arsenm: the position in the hierarchy shouldn't matter
19:53:19 <ivanm> Axman6: I'm applying for there for next year!
19:53:26 <Axman6> whoot :)
19:53:32 <ivanm> (if I get the application done by end of the month...)
19:53:38 <Axman6> we can go and have beers together in the wig and pen!
19:53:47 * ivanm doesn't imbibe
19:53:49 <copumpkin> :o
19:53:58 <Axman6> imbibe?
19:53:59 <copumpkin> Axman6: you'll have to bring a funnel with you then
19:54:03 <ivanm> @wn imbibe
19:54:05 <lambdabot> *** "imbibe" wn "WordNet (r) 2.0"
19:54:05 <lambdabot> imbibe
19:54:05 <lambdabot>      v 1: take in, also metaphorically; "The sponge absorbs water
19:54:05 <lambdabot>           well"; "She drew strength from the minister's words"
19:54:05 <lambdabot>           [syn: {absorb}, {suck}, {soak up}, {sop up}, {suck up},
19:54:07 <lambdabot> [6 @more lines]
19:54:16 <Axman6> @more
19:54:16 <lambdabot>           {draw}, {take in}, {take up}]
19:54:17 <lambdabot>      2: take (gas, light or heat) into a solution [syn: {assimilate}]
19:54:17 <lambdabot>      3: take in liquids; "The patient must drink several liters each
19:54:17 <lambdabot>         day"; "The children like to drink soda" [syn: {drink}]
19:54:17 <lambdabot>      4: receive into the mind and retain; "Imbibe ethical
19:54:17 <blackdog> you're not religious?
19:54:19 <lambdabot>         principles"
19:54:21 <copumpkin> lol
19:54:28 <ivanm> in my case, I don't drink alcohol
19:54:31 <Axman6> blackdog: not at all
19:54:37 <Axman6> i see
19:54:51 <Axman6> i only drink for the taste, never been drunk
19:55:05 <SamB_XP_> is the funnel to get the beer into the pen ?
19:55:21 <copumpkin> :P
19:55:32 <blackdog> Axman6: directed at ivanm :)
19:55:43 <Axman6> the wig and pen have a stout called velvet cream stout. it tastes like chcoclate. it's crazy and fascinating
19:55:50 <Axman6> blackdog: ah, i see :)
19:55:52 <Raevel> giev
19:56:04 <SamB_XP_> ... so, what *is* the funnel for ?
19:56:42 <ivanm> blackdog: I am religious...
19:56:44 <copumpkin> to "help" ivanm overcome his lack of imbibition
19:56:53 <ivanm> @slap copumpkin
19:56:53 * lambdabot karate-chops copumpkin into two equally sized halves
19:57:01 * copumpkin doesn't drink much either
19:57:16 <Axman6> ChilliX: excellent, i think i'll be on my break on the 2nd, you might see me there :)
19:57:55 <SubStack> the religious affiliation by programming language survey is down or else I'd link it
19:58:17 <copumpkin> SubStack: :O
19:58:30 * ivanm echoes copumpkin's ":o"
19:58:32 <kmc> @quote religion
19:58:32 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
19:58:32 <lambdabot> object in the category of religions and theomorphisms.
19:59:01 <copumpkin> theomorphisms!
19:59:10 <blackdog> ivanm: ah, more referring to the first defn involving the girl drawing strength from the minister. No aspersion was indicated.
19:59:12 * copumpkin wonders if edwardk has anything to say about those
19:59:44 <ivanm> heh
20:00:00 <blackdog> reminiscent of the douglas adams line about god disappearing in a puff of logic
20:00:10 <BMeph> copumpkin: "zygohistopreprotheomorphisms"? ;p
20:00:16 <blackdog> would that be the theistic fusion optimisation?
20:00:29 <Raevel> hilight fail
20:00:34 <kmc> i think the null religion is more trivial
20:00:41 <copumpkin> blackdog: according to the catholics, there was a three-way fusion
20:01:26 <Saizan_> but the result wasn't a super sayan.
20:01:28 <SamB_XP_> hey, Cale, we mentioned the axiom of choice in #haskell-blah
20:01:34 <SamB_XP_> maybe you should come talk about it
20:01:38 <copumpkin> Gogeta
20:02:19 <Raevel> Adamant: ! i was just thinking about you, as soon as you speak *adam* is a substring of what someone says and i get a highlight, this needs to end
20:03:05 <arsenm> Saizan_: now it successfully compiles all of the modules, until it gets to the top one, and complains about not being able to find one of the lower ones
20:03:10 <Adamant> Raevel: and this is my fault how?
20:03:15 <Raevel> Adamant: :-(
20:03:40 <Adamant> Raevel: Adamant is a common enough word and you're going to grep for the name Adam?
20:03:52 <Raevel> okay it's my bad
20:04:21 <Rotaerk> hmm if I have an expression of type (State GameState), can that be somehow lifted into type (StateT GameState IO)
20:04:29 <Adamant> I mean I have people use the word adamant in conversation and highlight me, but I try to make it funny :P
20:04:30 <Saizan_> arsenm: it's hard to figure out what's happening without the actual error messages and being able to experiment :)
20:04:31 <BMeph> So, has someone put the new Quicksort on Hackage yet? :)
20:04:46 <Raevel> Adamant: it is! i approve
20:04:55 <kmc> @hoogle State s -> StateT s m
20:04:55 <lambdabot> Did you mean: State s s -> StateT s m s /count=20
20:04:55 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
20:04:55 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
20:05:12 <kmc> @hoogle State s s -> StateT s m s
20:05:12 <lambdabot> No results found
20:05:20 <Raevel> very adamant of you
20:05:23 <kmc> thanks lambdabot i did in fact not mean that
20:05:49 <Saizan_> Rotaerk: yes, toStateT m = do s <- get; let (v,s') = runState m s; put s'; return v
20:06:10 <Rotaerk> hmm
20:06:22 <Rotaerk> ah, cool thanks
20:07:17 <_nickel> heatsink: is there anywhere I can go that would be better than #haskell to discuss my answers to and get help with the exercises in Algebra of Programming?
20:08:03 <copumpkin> squiggol? :o
20:08:07 <_nickel> I found solutions online up to chapter 6 which is helping me out, but I still have questions
20:08:07 <heatsink> _nickel, Not that I know of.  The potentially relevant channel here is #cs
20:08:20 <_nickel> heatsink: thanks I'll try that
20:08:55 <SamB_XP_> heatsink: oh, you mean that's not this channel ?
20:10:05 <inimino> 8 people in that channel
20:10:15 <heatsink> SamB_XP_, good point.  Should we move #haskell to #cs or redirect #cs to #haskell?
20:10:17 <inimino> _nickel: you might also try #algorithms
20:10:37 <_nickel> inimino: thanks not much respons in #cs
20:11:47 <jokerGTA> .
20:12:00 <Axman6> , deriv (\x -> x^2)
20:12:01 <lunabot>  luna: Not in scope: `deriv'
20:12:07 <Axman6> hmm
20:12:43 <jokerGTA> i dont see anyone in the room
20:12:59 <kmc> this one?
20:13:04 <jokerGTA> hey kmc
20:13:08 <kmc> hi
20:13:17 <jokerGTA> can you help me with this defintion
20:13:22 <jokerGTA> i am trying to figure out the tpyes
20:13:39 <jokerGTA> function1 :: [Integer] -> [Rational]
20:13:54 <jokerGTA> [ x | x <- [7,-6], x % 13]
20:14:21 <copumpkin> jokerGTA: not sure about that
20:14:22 <jokerGTA> id like the result to be [7%13,-6%13]
20:14:35 <copumpkin> > [x % 13 | x <- [7, -6]]
20:14:36 <lambdabot>   [7 % 13,(-6) % 13]
20:15:10 <jokerGTA> would you try to explain whats wrong with my definition
20:15:27 <copumpkin> expressions separated by commas, with no <- in them
20:15:29 <copumpkin> are guards
20:15:41 <copumpkin> they must return boolean values, and if the boolean is false, the current value will not be included
20:15:53 <Axman6> jokerGTA: i think you want function1 xs = [x % 13 | x <- xs]
20:16:06 <sshc> Hi, does Haskell treat wildcards ('_') specially or is it just a common way to denote unused variables?
20:16:12 <kmc> sshc, specially
20:16:18 <copumpkin> list comprehensions actually look very much like do notations
20:16:19 <kmc> vars can only be bound once on a left-hand side
20:16:24 <kmc> _ can be bound any number of times
20:16:37 <kmc> but there's also a convention about variables whose names *start* with _ being unused
20:16:43 <Rotaerk> when do you prefer [f x | x <- xs] to (map f xs)
20:16:56 <sshc> kmc: thanks
20:16:56 <copumpkin> Rotaerk: on its own, I usually prefer map f xs
20:17:20 <copumpkin> but if there's a more complicated left-hand expression, or a guard, or a cartesian product, I may use a list comp
20:17:22 <jokerGTA> ok
20:17:32 <Rotaerk> hmm makes sense
20:18:05 <jokerGTA> thanks
20:36:23 <Danielle> HI all
20:37:15 <copumpkin> hi
20:37:36 <Danielle> was wondering if any one is good with Atmel AVR i got to write a short program for uni and i m some what lost
20:38:07 <kpreid> ...in Haskell?
20:38:41 <kpreid> I mean, I've done some AVR programming but I'd be surprised if doing it in Haskell were an assignment
20:44:57 <_nickel> heatsink: sorry to bother :( I'm still confused as to how "every constant function" satisfies f n = f (n + 1)
20:45:34 <heatsink> Choose a constant function, for example, (const 0)
20:45:41 <heatsink> Let f be that function
20:45:42 <_nickel> heatsink: how is it that 0 satisfies that equation? I think this is a terminology issue for me as its clearly not complex
20:45:46 <c_wraith> "constant" in this case means "returns the same value regardless of its input"
20:45:56 <heatsink> then the LHS is (const 0 n)
20:45:57 <_nickel> ahh
20:45:58 <copumpkin> what if it returns another function, and you don't have an Eq instance for functions
20:46:07 <c_wraith> > (const 4) 1
20:46:07 <lambdabot>   4
20:46:09 <c_wraith> > (const 4) 2
20:46:10 <lambdabot>   4
20:46:10 <ChilliX> Axman6: great if you could make it to SAPLING
20:46:13 <c_wraith> etc
20:46:23 <ChilliX> Axman6: let me know once you have set something up with dons
20:46:24 <_nickel> c_wraith: that makes sense
20:46:28 <ChilliX> bbl
20:46:31 <_nickel> heatsink: thanks
20:46:35 <jmcarthur> does anybody else feel like it would be better if arr and the tuple stuff in Arrow were in separate type classes? i can't think of any right now, but i keep feeling like i have come across situations in which most of Arrow would apply except for arr
20:46:36 <heatsink> sure
20:47:02 <heatsink> @ nickel
20:47:17 <jmcarthur> and i think i have seen one other person complain about it, but i don't remember who
20:48:32 <copumpkin> jmcarthur: yes, me
20:48:34 <c_wraith> > let f = const 4 in map f [0..]
20:48:34 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
20:48:39 <c_wraith> :)
20:49:06 <jmcarthur> copumpkin: what was it that you were doing that arr didn't apply to but the other stuff did?
20:49:11 <c_wraith> > let f = const 4 in map (id &&& f) [0..]
20:49:11 <lambdabot>   [(0,4),(1,4),(2,4),(3,4),(4,4),(5,4),(6,4),(7,4),(8,4),(9,4),(10,4),(11,4),...
20:49:22 <copumpkin> jmcarthur: trying to remember :P
20:49:43 <copumpkin> jmcarthur: I think I wanted more of an RArrow,  la RMonad, so that I could make Map an instance, but I lost interest
20:50:08 <jmcarthur> copumpkin: i also am not sure what to name the two pieces, which should depend on which, etc.
20:50:21 <jmcarthur> if either should depend on the other, even
20:51:13 <jmcarthur> i think the presence of arr is what makes it an Arrow, just based on the names, but i can't really guess what to call the other stuff
20:51:15 <c_wraith> @unpl flip id
20:51:15 <lambdabot> (\ b c -> c b)
20:51:26 <jmcarthur> right now i have clumsily named it CategoryProduct
20:51:56 <jmcarthur> and included a few other things that seem related like fst, snd, swap, etc.
20:53:00 <copumpkin> jmcarthur: I think what I was mostly hoping for with Arrow was an overloadable " " operator (function application), but it didn't turn out to be what I was hoping for
20:53:03 <c_wraith> @unpl ($)
20:53:03 <lambdabot> (\ a b -> a b)
20:53:26 <copumpkin> jmcarthur: other than that, I haven't played much with arrow, but arr did seem to get in the way of things I wanted to do with it at the time
20:53:58 <jmcarthur> alright, well, that at least makes me feel a little better about my decision to try the split, although i still don't know what to call things
20:54:10 <jmcarthur> i guess i'll just leave it as i already wrote it, tentatively
20:54:17 <BMeph> jmacarthur: That "arr didn't apply to but the other stuff did?" is trivially solved with ',' :)
20:54:47 <jmcarthur> BMeph: ','?
20:55:12 <BMeph> As in a ~> b == (a,b)
20:55:41 <jmcarthur> (~>) == (,)?
20:55:45 <copumpkin> :o
20:55:49 <jmcarthur> i don't think i follow
20:55:51 <copumpkin> that seems like an odd Arrow
20:55:58 <Twey> That's no arrow!
20:56:09 <copumpkin> I wonder if you could define a instance Arrow (,)
20:56:30 <copumpkin> probably not, eh
20:56:40 <copumpkin> well, not an interesting one, anyway
20:56:43 <c_wraith> Do we have an agreed-upon deathstar operator?
20:56:59 <copumpkin> {*}
20:57:09 <c_wraith> can you use { and } in operators?
20:57:11 <BMeph> That's a conal-ism I'm used to. (Arrow ~>) instead of (Arrow a). :)
20:57:11 <copumpkin> nope
20:57:15 <jmcarthur> arr :: (a -> b) -> (a, b)  ... no way
20:57:19 <copumpkin> BMeph: that much I'm fine with
20:57:38 <jmcarthur> BMeph: your statement seems to imply that (,) is an Arrow
20:58:18 <BMeph> copumpkin: Try it - everything works...except for that blasted 'arr'. Then again, I've always been more of a Ninja fan... ;p
20:58:37 <jmcarthur> BMeph: what do you do for Category?
20:58:50 * copumpkin tries to compose (a, b) and (b, c)
20:58:54 <kmc> jmcarthur, yes, i had a filtergraph EDSL that was an arrow except for arr
20:59:09 <jmcarthur> kmc: yay, concrete evidence!
20:59:12 <copumpkin> (a, b) . (c, d) = (a, d)
20:59:16 <copumpkin> yay
20:59:18 <jmcarthur> ha
20:59:24 <jmcarthur> what about id? :P
20:59:38 <copumpkin> :t let (a, b) . (c, d) = (a, d) in (.)
20:59:39 <lambdabot> forall t t1 t2 t3. (t, t1) -> (t2, t3) -> (t, t3)
20:59:52 <copumpkin> :t Control.Category.id
20:59:53 <lambdabot> forall (cat :: * -> * -> *) a. (Control.Category.Category cat) => cat a a
20:59:59 <copumpkin> easy!
21:00:13 * copumpkin whistles
21:00:17 <jmcarthur> would the absence of id make it a semicategory?
21:00:18 <BMeph> So, (a,a). Hmm...there's got to be something...
21:00:50 <kmc> jmcarthur, basically i wanted to use arrow notation to wire together boxes and arrows, but i had no way of making a box from a pure function
21:01:08 <copumpkin> :t let (a, b) = (a, a) in (a, b)
21:01:09 <lambdabot> forall t. (t, t)
21:01:09 <copumpkin> tada
21:01:15 <kmc> (because they were deep-embedded expressions that might get GPU compiled or such)
21:01:16 <copumpkin> beat that if you can
21:01:25 * copumpkin rubs his hands in glee
21:01:41 <BMeph> It helps to have read Greif's Thrist paper and Sackman's Sessions Types one multiple times. :)
21:01:45 <copumpkin> just, uh, be careful when you use it
21:01:48 <jmcarthur> let (a, b) = (a, a) in (a, b)
21:01:51 <jmcarthur> > let (a, b) = (a, a) in (a, b)
21:01:56 <lambdabot>   mueval-core: Prelude.read: no parse
21:01:57 <lambdabot>  mueval: ExitFailure 1
21:01:57 <copumpkin> hey hey
21:01:59 <copumpkin> I told you to be careful
21:02:07 <jmcarthur> id = (undefined, undefined)
21:02:09 <jmcarthur> win
21:02:13 <copumpkin> mine is cuter
21:02:18 <jmcarthur> maybe a little
21:02:34 <jmcarthur> it also doesn't give itself away to the runtime like mine
21:02:34 <BMeph> :t (undefined, undefined)
21:02:35 <lambdabot> forall a a1. (a, a1)
21:03:02 <jmcarthur> kmc: right, i can imagine a lot of DSLs can't do that
21:03:33 <copumpkin> > let (a, b) = (b, a) in (a, b)
21:03:38 <lambdabot>   mueval-core: Prelude.read: no parse
21:03:38 <lambdabot>  mueval: ExitFailure 1
21:03:48 <jmcarthur> kmc: any idea what this category with tuples type class might be called?
21:03:54 <copumpkin> I call that the flipkotron
21:04:54 <jmcarthur> i'm defining things like fst :: (a, b) ~> a, which i think is cute
21:05:01 <copumpkin> :o
21:06:38 <kmc> so it has first, second, (***), (&&&)
21:06:55 <kmc> and also there should be an ArrowChoice-like extension
21:07:43 <jmcarthur> i'm wondering if maybe ArrowChoice should be liberated from Arrow as well
21:07:50 <kmc> yeah i think so
21:09:30 <dolio> Category, CategoryWithSums, CategoryWithProducts.
21:09:42 <jmcarthur> CategorySum, CategoryProduct?
21:09:56 <kmc> it's not a sum or product of categories though
21:09:59 <jmcarthur> yeah
21:10:12 <jmcarthur> it's sum and product of objects
21:10:42 <kmc> is the term "cartesian category" appropriate?
21:12:19 <jmcarthur> i wish edwardk was in here
21:12:42 <BMeph> Why not Tensorial? :)
21:12:53 <kmc> so (***) is the important one, right?
21:13:28 <Gracenotes> important category theoretically, or important for cute convenient idioms in code? :)
21:13:41 <kmc> important for understanding what we're trying to nail down
21:14:16 <kmc> it says (implicitly) that you have cartesian products on objects of your category, and (explicitly) that you can lift two morphisms to be a single morphism on products
21:14:18 <kmc> right?
21:16:17 <jmcarthur> i guess so
21:16:43 <kmc> and (+++) the same for sums
21:16:56 <c_wraith> :t (+++)
21:16:56 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
21:17:04 <c_wraith> ooh, neat
21:17:11 <kmc> the choice of which ones are default-defined is weird, because there is arr
21:17:15 <c_wraith> @instances ArrowChoice
21:17:16 <lambdabot> (->), Kleisli m
21:17:29 <sohum> whoa
21:17:35 <sohum> @instances Integer
21:17:36 <lambdabot> Couldn't find class `Integer'. Try @instances-importing
21:17:36 <kmc> but in the absence of arr i think you'd have (***) and (+++) as the base combinators
21:17:45 <kmc> what else does CategoryWithSums need?
21:17:47 <dm`> Which ones are default defined?  All but arr, first, and left?
21:17:49 <sohum> @instances Int
21:17:50 <lambdabot> Couldn't find class `Int'. Try @instances-importing
21:17:57 <c_wraith> sohum:  Those are types, not typeclasses
21:17:57 <kmc> dm`, yes iirc
21:18:02 <c_wraith> @instances Num
21:18:03 <lambdabot> Double, Float, Int, Integer
21:18:23 <dm`> Probably because the ones not default defined are the easiest to implement, so you can build functional arrows first, then optimize later.
21:18:42 <c_wraith> @src ArrowChoice
21:18:42 <lambdabot> Source not found. You untyped fool!
21:18:51 <sohum> c_wraith: aah, right
21:19:08 <jmcarthur> kmc: what i have right now http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9317#a9317
21:19:13 <kmc> to implement (&&&) in terms of (***) we'll need dup :: a ~> (a, a)
21:19:23 <jmcarthur> fst, snd, and swap might not belong. i'm just playing around at the moment
21:19:29 <jmcarthur> i have the dup :)
21:19:33 <kmc> cool
21:19:39 <dm`> What extension gives you the '~' character at the start of type constructors?
21:19:47 <kmc> TypeOperators ?
21:19:48 <jmcarthur> TypeOperators
21:19:56 <dm`> Cool.
21:20:12 <kmc> jmcarthur, what are your minimal sets for implementing this?
21:20:25 <jmcarthur> i haven't written it out yet, but it seems a little complex
21:20:56 <kmc> yeah
21:21:13 <jmcarthur> i think the smallest minimal set is probably 4
21:21:16 <jmcarthur> of them
21:21:37 <jmcarthur> fst, swap, first, duplicate
21:22:26 <jmcarthur> hmm... i guess first and second could be defaulted without swap
21:22:36 <jmcarthur> first = f *** id
21:23:08 <dm`> Don't you need to lift id?  Sorry, kind of joined in late but am interested in arrows, so trying to follow...
21:23:14 <kmc> hmm, can you get by with fst, snd, dup, (***) ?
21:23:23 <jmcarthur> dm`: id is in Category
21:23:31 <kmc> as is (.)
21:23:36 <jmcarthur> kmc: yes, i think
21:23:44 <kmc> so where does "arr" go then?
21:23:45 <dm`> @hoogle Category
21:23:45 <lambdabot> module Control.Category
21:23:45 <lambdabot> Control.Category class Category cat
21:23:45 <lambdabot> Data.Char data GeneralCategory
21:23:49 <jmcarthur> Arrow? :)
21:24:21 <Twey> @pl \x y -> f (g x) (h x y)
21:24:21 <lambdabot> ap ((.) . f . g) h
21:24:32 <kmc> so i need to clarify my thinking on what Arrow and Functor represent
21:24:56 <kmc> arr says, if you have a morphism in Hask, you can lift it to this other category
21:25:01 <jmcarthur> i also have already written out a more general functor, and map and arr are very similar
21:25:13 <jmcarthur> map :: (a ~> b) -> (f a ~~> f b)
21:25:23 <jmcarthur> arr :: (a -> b) -> (a ~> b)
21:25:24 <kmc> :t fmap
21:25:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:26:05 <kmc> hmm i feel some associated types coming on
21:26:09 <jmcarthur> where the above is my map and GHC's arr
21:27:13 <kmc> we want to be able to declare that a Category c has this additional property that there's a functor from Hask to it
21:27:20 <kmc> which seems to be split between Functor and Arrow now
21:27:38 <kmc> you need two type constructors, one for the type of lifted objects, one for the type of lifted morphisms
21:28:20 <jmcarthur> Functor Id Hask (~>)    looks about the same as the current arr
21:28:51 <kmc> Functor is multiparameter now?
21:28:54 <jmcarthur> mine is :)
21:28:59 <kmc> what's it look like?
21:29:13 <kmc> does it have both return and arr
21:29:19 <jmcarthur> class Functor f (~>) (~~>) where map :: (a ~> b) -> (f a ~~> f b)
21:30:08 <jmcarthur> nah, there are just strong similarities between arr and map, there
21:30:30 <kmc> are there any fundeps on that?
21:30:39 <jmcarthur> yes, i forgot to type them here
21:30:56 <jmcarthur> | f (~>) -> (~~>), f (~~>) -> (~>)
21:31:20 <kmc> type Hask = (->) ?
21:31:23 <jmcarthur> yeah
21:31:41 <jmcarthur> this functor is ripped pretty much straight from category-extras, btw
21:32:27 <dm`> Is there an easy example of what ~~> would be, in a typical instance of your functor?
21:32:45 <jmcarthur> dm`: the most common would be Hask, but it could be any Category
21:32:55 <jmcarthur> kmc: oh yeah, Category constraints on those operators, too
21:33:57 <dm`> So with arrows, f would be some arrow constructor, ~> would be ->, and ~~> would also be the arrow type?
21:34:35 <jmcarthur> dm`: f would be not there, basically
21:34:47 <jmcarthur> dm`: that's why i used the identity functor for my comparison above
21:35:12 <jmcarthur> dm`: but other than that that's right
21:36:09 <kmc> jmcarthur, where (->) itself appears in the type of map, you're using Hask as the category of categories?
21:36:32 <jmcarthur> kmc: i suppose i am
21:36:45 <kmc> so if you have that Functor, you don't need arr at all
21:36:55 <jmcarthur> i guess not, if we take Id to mean nothing
21:37:09 <kmc> i think perhaps there should be some associated type synonyms
21:37:12 <jmcarthur> if we have (Id a ~> Id b) -> (a ~> b)
21:37:23 <chessguy> @type mapT f t = State $ \x -> ((), fmap f . execState t $ x)
21:37:23 <lambdabot> parse error on input `='
21:37:37 <chessguy> @type let mapT f t = State $ \x -> ((), fmap f . execState t $ x) in mapT
21:37:37 <lambdabot> forall b (f :: * -> *) a. (Functor f) => (b -> b) -> State (f b) a -> State (f b) ()
21:37:58 <jmcarthur> kmc: like what?
21:38:01 <chessguy> why is this (b -> b) instead of (b -> c) ?
21:38:47 <chessguy> @type fmap ?f . execState ?t
21:38:48 <lambdabot> forall a b (f :: * -> *) a1. (?f::a -> b, Functor f, ?t::State (f a) a1) => f a -> f b
21:39:37 <chessguy> that part goes from a to b, like i expect
21:39:54 <Rotaerk> hmm... is there something that is equivalent to (flip map)
21:40:43 <Rotaerk> I thought Data.Traversable.for might be it but it doesn't seem so
21:40:44 <Twey> Yes: flip map
21:40:51 <Twey> @index for
21:40:51 <lambdabot> bzzt
21:40:56 <Twey> :<
21:41:06 <chessguy> we need a 'let me hoogle that for you' site
21:41:21 <Twey> @hoogle [a] -> (a -> b) -> [b]
21:41:21 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
21:41:21 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
21:41:21 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
21:41:33 <Twey> In other words, flip map.
21:41:34 <Rotaerk> it doesn't appear to exist
21:42:01 <chessguy> darnit, i don't get what the type system is doing here :(
21:43:24 <Rotaerk> chessguy, I had hoogled it, which is why I was asking
21:44:22 <Twey> Rotaerk: flip map is only an extra five characters.
21:45:26 <chessguy> @type let foo :: (a -> b) -> State [a] r -> State b () = \x t -> State $ \x -> ((), fmap f . execState t $ x) in foo
21:45:27 <lambdabot> Not in scope: type variable `a'
21:45:27 <lambdabot> Not in scope: type variable `b'
21:45:27 <lambdabot> Not in scope: type variable `a'
21:45:51 <jmcarthur> > let for = flip map in for [1..5] (+1)
21:45:51 <lambdabot>   [2,3,4,5,6]
21:45:54 <chessguy> @type let (foo :: (a -> b) -> State [a] r -> State b ()) = \x t -> State $ \x -> ((), fmap f . execState t $ x) in foo
21:45:55 <lambdabot> Not in scope: type variable `a'
21:45:55 <lambdabot> Not in scope: type variable `b'
21:45:55 <lambdabot> Not in scope: type variable `a'
21:46:16 <chessguy> ok, i'm probably just way over-tired now
21:46:38 <chessguy> @type let foo x t -> State $ \x -> ((), fmap f . execState t $ x) in foo
21:46:39 <lambdabot> parse error on input `->'
21:46:53 <chessguy> @type let foo x t = State $ \x -> ((), fmap f . execState t $ x) in foo
21:46:54 <lambdabot> forall t (f :: * -> *) b a. (Functor f, SimpleReflect.FromExpr b, Show b) => t -> State (f b) a -> State (f b) ()
21:47:20 <chessguy> @type let foo f t = State $ \x -> ((), fmap f . execState t $ x) in foo
21:47:21 <lambdabot> forall b (f :: * -> *) a. (Functor f) => (b -> b) -> State (f b) a -> State (f b) ()
21:48:27 <chessguy> where is inferring that (b -> b) from?
21:49:40 <ivanm> is there a single-pass function that takes both tail and last at the same time, or would I have to write one?
21:49:44 <Twey> @pl f >>= \a -> g >>= \b -> h a b
21:49:44 <lambdabot> (g >>=) . h =<< f
21:49:57 <ivanm> (my lists aren't _that_ long, but it just looks weird doing both tail and last)
21:50:39 <Twey> @pl f >>= \a -> g >>= \b -> h >>= \c -> i a b c
21:50:39 <lambdabot> (g >>=) . ((h >>=) .) . i =<< f
21:50:59 <chessguy> ivanm, what does "take tail and last at the same time" mean?
21:51:05 <Twey> @pl f >>= \a -> g >>= \b -> h >>= \c -> i >>= \d -> j a b c d
21:51:05 <lambdabot> (g >>=) . (((h >>=) . ((i >>=) .)) .) . j =<< f
21:51:09 <Twey> Hmph
21:51:20 <ivanm> chessguy: [a] -> ([a], a)
21:51:21 <Twey> You'd think there'd be a generalisation for that
21:51:43 <chessguy> oh, i really doubt it
21:51:58 <chessguy> \xs -> (tail xs, last xs)
21:52:12 <ivanm> yeah...
21:52:20 <jmcarthur> @type f >>= \a -> g >>= \b -> h a b
21:52:20 <Twey> :t sequence
21:52:20 <lambdabot> forall (m :: * -> *) a a1 b. (SimpleReflect.FromExpr (m a), SimpleReflect.FromExpr (m a1), Show a, Show a1, SimpleReflect.FromExpr (m b), Monad m) => m b
21:52:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:52:26 <ivanm> it just feels wrong to have to traverse the list twice, that's all
21:52:35 <jmcarthur> @type \f g h -> f >>= \a -> g >>= \b -> h a b
21:52:36 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m a -> m a1 -> (a -> a1 -> m b) -> m b
21:52:37 <chessguy> @pl \xs -> (tail xs, last xs)
21:52:37 <lambdabot> liftM2 (,) tail last
21:52:49 <chessguy> there ya go, write that instead
21:52:51 <Twey> > sequence [[1, 2], [3, 4]]
21:52:52 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
21:52:55 <jmcarthur> Twey: i think that is what we should have instead of the liftM family
21:53:15 <jmcarthur> Twey: there have been at least two discussions about it already today ;)
21:53:22 <Twey> Heh.
21:53:42 <ivanm> chessguy: no, I meant that the list is traversed once for tail and another time for last
21:53:44 <Twey> > sequence [[1, 2, 3], [4, 5, 6]]
21:53:45 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
21:54:03 <chessguy> ivanm, yes i know exactly what you meant, i'm just kidding
21:54:16 <ivanm> heh
21:54:26 <Twey> > sequence $ replicate 9 [1, 2]
21:54:27 <lambdabot>   [[1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,2,1],[1,1,1,1,1,1,1...
21:54:46 <chessguy> usually if you're using last, you're doing something wrong anyway...
21:55:55 <ivanm> well, given the module path Foo.Bar.Baz, I want to split it into Foo.Bar and Baz, so atm I'm doing a split on '.' and then putting back in '.' on tail of the split
21:57:31 <et4te> hey ppl, are type classes a compile time or runtime thing?
21:57:57 <jmcarthur> et4te: it depends
21:58:09 <et4te> jmcarthur: on ?
21:58:30 <kmc> et4te, in most implementations they are sort of like implicit parameters
21:58:30 <jmcarthur> whether the type is known at compile time or not
21:58:42 <kmc> et4te, are you asking about the semantics of type classes, or how they're implemented?
21:59:03 <et4te> kmc: how they are implemented
21:59:24 <kmc> et4te, usually by passing dictionaries, unless the type is already known
21:59:44 <et4te> kmc: and this dictionary is passed at runtime?
21:59:50 <kmc> yes
21:59:57 <et4te> kmc: unless the type is known at compile time?>
22:00:02 <jmcarthur> kmc: what associated types were you talking about earlier?
22:00:12 <kmc> because a polymorphic function must be compiled once, even though it may be called at multiple types
22:00:16 <chessguy> is it not possibly to write a function to convert an arbitrary State a r to a State b r'?
22:01:03 <et4te> kmc: interesting, thanks for the help :)
22:01:11 <jmcarthur> @unmtl State a r
22:01:11 <lambdabot> a -> (r, a)
22:01:12 <kmc> jmcarthur, i was thinking that there is a single type which represents the functor itself, and then four associated types for the domain and codomain of the maps on types and morphisms
22:02:19 <kmc> chessguy, sure, it's possible, for example by providing values of types b and r' and throwing out the old state computation
22:02:26 <kmc> (a stupid example to be sure)
22:02:30 <kmc> what are you trying to do with this function?
22:03:06 <chessguy> i want to write something like foo :: (a -> b) -> State [a] r -> State [b] ()
22:03:55 <jmcarthur> kmc: i'm not sure what that would buy
22:04:10 <chessguy> kmc, i'm very close, but the function i have types as (b -> b) -> State [b] r -> State [b] ()
22:04:46 <kmc> jmcarthur, if you want your map to take over arr, you need a way to specify that the object part of the functor is an endofunctor
22:04:54 <kmc> i.e. to make the Identity tycon disappear
22:04:58 <kmc> which i thought could be done with ass types
22:05:14 <kmc> chessguy, you want to throw out the result of type r?
22:05:27 <kmc> :t execState
22:05:27 <lambdabot> forall s a. State s a -> s -> s
22:05:39 <chessguy> kmc, yes, but i also want to replace the state
22:06:23 <Berengal> chessguy, you can do it, but you can't do it in the middle of a do
22:06:24 <jmcarthur> chessguy: perhaps you could try a parameterized state monad rather than just normal State?
22:07:06 <chessguy> jmcarthur, parameterized by what?
22:07:42 <chessguy> Berengal, i'm not sure what you mean at all
22:07:46 <kmc> :t \f m -> State (\s -> ((), f $ runState m s))
22:07:47 <lambdabot> forall b a. ((a, b) -> b) -> State b a -> State b ()
22:08:01 <jmcarthur> chessguy: http://blog.sigfpe.com/2009/02/beyond-monads.html
22:08:01 <lambdabot> Title: A Neighborhood of Infinity: Beyond Monads
22:08:05 <kmc> :t \f m -> State (\s -> ((), f $ execState m s))
22:08:06 <lambdabot> forall b a. (b -> b) -> State b a -> State b ()
22:08:33 <chessguy> kmc, that's exactly what i have, but i can't figure out why that types as "(b -> b)..."
22:08:41 <kmc> yeah, that is odd
22:09:12 <jmcarthur> :t execState
22:09:13 <lambdabot> forall s a. State s a -> s -> s
22:09:58 <jmcarthur> :t State
22:09:59 <lambdabot> forall s a. (s -> (a, s)) -> State s a
22:11:23 <kmc> :t \f m -> State (\s -> ((), execState m $ f s))
22:11:23 <lambdabot> forall a a1. (a -> a) -> State a a1 -> State a ()
22:11:41 <jmcarthur> :t \f m -> State (\s -> ((), f (execState m s)))
22:11:41 <lambdabot> forall s a. (s -> s) -> State s a -> State s ()
22:12:06 <kmc> yeah, the value for the return type of this function isn't actually compatible with the type State b ()
22:12:47 <kmc> :t \f g m -> State (\s -> ((), g $ execState m $ f s))
22:12:48 <lambdabot> forall b a a1. (b -> a) -> (a -> b) -> State a a1 -> State b ()
22:13:39 <chessguy> hm. i don't get it
22:13:52 <chessguy> why do you have to provide a (b -> a)
22:14:02 <kmc> chessguy, you're in a State b monad, going along, you want to run a State a action.  you have to get a value of type a to kick that off
22:14:12 <kmc> then when it's done, you have to get back to b to update the outer state
22:14:24 <Berengal> @type \a f m -> State (\s -> ((), f (execState m a)))
22:14:24 <kmc> you could also provide an initial state
22:14:24 <lambdabot> forall s s1 a. s1 -> (s1 -> s) -> State s1 a -> State s ()
22:14:44 <kmc> which is like giving (const x) for one of the two functions
22:15:12 <Berengal> This is what I meant by not being able to do it in the middle of a do: they have to be independent of eachother's state
22:15:29 <Berengal> You can't chain them together in the same chain of binds
22:15:44 <chessguy> interesting
22:15:47 <kmc> Berengal, not necessarily independent, but you have to provide the dependence yourself, in both directions
22:16:05 <kmc> (which dependence could be "none")
22:16:29 <jmcarthur> you can chain them in the same chain of binds with a parameterized monad as in the post i linked to
22:16:44 <Berengal> kmc, yeah, no implicit dependence, unlike regular State s computations
22:17:19 <kmc> but (and this is a wonderful feature of Haskell) you can write "do-block combinators" that would let you nest the do block for one State in another
22:18:18 <Berengal> You're thinking of things like atomically and whatnot?
22:18:59 <kmc> for example
22:19:20 <chessguy> so if i know how to perform some action on a bunch of a's (State [a]), and i know how to convert from a's to b's (a -> b), there's no simple way to turn that into a way to perform the same action on the b you would get from each a?
22:19:22 <Berengal> Yep, those are nice, and appropriately confusing
22:19:50 <kmc> Berengal, a lot of IO stuff works that way, like alloca and catch
22:20:06 <kmc> also monadic code generator EDSLs
22:20:07 <FunctorSalad> "So I think the Haskell people are doing something very interesting: they've pushed the monism up a level. Everything is a List or a Maybe or an IO or a Hoojimaflip or an AquaTeenHungerForce or whatever: but all of those things are monads."
22:20:12 <Berengal> chessguy, map foo . execState state
22:20:15 <FunctorSalad> (out-of-context quotes ftw)
22:20:32 <kmc> chessguy, not without a way to synthesize a starting state for the (State [a]) action
22:20:37 <kmc> @unmtl State [a]
22:20:37 <lambdabot> err: `State [a]' is not applied to enough arguments, giving `/\A. [a] -> (A, [a])'
22:20:43 <kmc> @unmtl State [a] ()
22:20:43 <lambdabot> [a] -> ((), [a])
22:21:10 <kmc> chessguy, that state transformer is like a function from old-state to new-state.  it's useless without an old state to apply to
22:21:19 <kmc> perhaps the old state you want is []
22:21:22 <chessguy> but...you don't have a b-state
22:21:31 <Berengal> kmc, yeah, I love it. Also makes for appropriately confusing code when you're five levels deep and using a fourth monad
22:21:35 <kmc> your result is a b-state-transformer
22:21:37 <chessguy> err, i mean, you don't have an a-state
22:21:46 <kmc> chessguy, what do you mean
22:21:53 <Berengal> The meaning of newlines never staying the same
22:22:04 <kmc> :t \f m -> State (\s -> ((), map f $ execState m []))
22:22:05 <lambdabot> forall b a a1. (a1 -> b) -> State [a1] a -> State [b] ()
22:22:29 <kmc> Berengal, heh
22:22:38 <kmc> Haskell lets you overload C's semicolon! And make it invisible, too!
22:22:59 <Berengal> Invisible polymorphic ;'s
22:23:26 <chessguy> i'm just not seeing why i need an old state
22:23:42 <shachaf> Berengal: ...That message reads very differently when you think you're in #nethack.
22:23:44 <kmc> chessguy, try doing it all with straight function composition
22:23:46 <kmc> not in a monad
22:24:01 <kmc> after all, "State s a" is just a wrapper on "s -> (a, s)"
22:24:26 <chessguy> ugh, my brain is too mushy to try that right now
22:24:38 <chessguy> i'd rather take your word for it, much as it pains me to say that
22:24:41 <kmc> @djinn (s -> t) -> (s -> ((), s) -> (t -> ((), t))
22:24:41 <lambdabot> No output from Djinn; installed?
22:24:48 <kmc> aww
22:24:51 <Berengal> chessguy, State is a transformation from an old state of type s to a new state of type s (and a value). what you have is a transformation from a value of type s to a value of type s' (and another value of type ())
22:25:14 <Berengal> So basically, what you have is not a State
22:26:37 <chessguy> i have a transformation from an old state of type s to a new state of type s, and i want to turn it into a transformation from an old state of type s' to a new state of type s'
22:26:57 <kmc> yeah
22:27:27 <kmc> you want to write basically: (a -> a) -> (b -> b)
22:27:27 <chessguy> (and i know how to get from s to s' too)
22:27:28 <Berengal> Yes, you need a way to transform an s to an s' and also to transform it back again
22:27:42 <kmc> (ignoring the State wrapper, and the useless monad action result value)
22:27:52 <kmc> so, just try writing a function of this type:
22:27:57 <kmc> (a -> b) -> (a -> a) -> (b -> b)
22:28:35 <Berengal> I have a feeling this might not be what you really want
22:28:39 <chessguy> oh!
22:29:04 <kmc> you can write that function easily: f _ _ = id
22:29:08 <kmc> but it won't do what you want
22:29:26 <chessguy> yes, i think that example helps
22:30:03 <kmc> i'm guessing you have a "start" state of type a already in mind
22:30:03 <chessguy> unfortunately, it means that now i have to go back and figure out what i _really_ want
22:30:12 <kmc> perhaps [] since they are lists
22:30:29 <chessguy> kmc, ok, this is where the fib comes in...i'm not actually working with [] :)
22:30:33 <kmc> aha :)
22:30:45 <kmc> and you're sure you want a state-transformer abstraction in general?
22:31:00 <chessguy> relatively so
22:31:15 <kmc> it's not easier to just pass / return the "state" directly, at least for this part of the code?
22:31:49 <chessguy> no, i don't think so
22:32:21 <kmc> okay :)
22:32:24 <chessguy> the type i'm dealing with is actually State (TreeLoc a)
22:33:03 <Berengal> You need either the (a -> b) -> (b -> a) -> State [a] r -> State [b] () function, or a -> (a -> b) -> State a r -> State b ()
22:33:51 <chessguy> kmc, the idea is to sort of lift alpha-beta and similar algorithms into a zipper so that you can get both the value and the path through the tree at the same time
22:34:49 <kmc> ah
22:35:20 <chessguy> the ultimate goal is composable tree-searching strategies
22:37:01 <kmc> hmm, i think you could write the state-nesting combinator nicely with lenses
22:37:47 <chessguy> what i'm trying to do right now is right a "tree-traversal" which replaces every node in a "Tree a" with a b
22:39:10 <chessguy> not working out so hot :(
22:40:15 <chessguy> maybe i'll skip it, i may not really need it
22:43:15 <chessguy> @type split
22:43:16 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
22:44:21 <Gracenotes> okay... armed with ack-grep and a simple text editor, I hope to see what makes graphviz's dot tick  u_u
