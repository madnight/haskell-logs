02:11:00 <blackh> blackdog: Are you about? I want to talk to you about Mac OS/X dynamic libraries.
02:11:56 <blackdog> blackh: yeah, but only for ten minutes...
02:12:07 * Axman6 would like a 64 bit OS X build before dynamic libraries :(
02:12:17 <blackdog> talk to copumpkin :)
02:13:06 * Axman6 is also a little annoyed that there seems to be more progress getting GHC working on the iPhone than OS X
02:13:36 <blackh> blackdog: OK - I'll do that.  I volunteered to help with getting OS X to link, but I just want to make sure we're not all trying to do the same thing.
02:14:07 <blackdog> blackh: i did a bit on it, but you're more than welcom to take over
02:14:13 <blackdog> how far did you get?
02:14:36 <blackh> I haven't started yet.  Excuse my ignorance, but is 6.12 candidate == HEAD at the moment?
02:14:37 <blackdog> i was getting a GMP error - needs -read_only_relocs suppress at the link stage
02:14:53 <blackdog> um. they'd be close, i suppose
02:14:57 <blackh> I'm not a Mac OS/X expert, so I might have to muddle my way though a bit.
02:15:24 <blackdog> ok. i have a half-arsed version of how to get it running at shimweasel.com
02:15:38 <blackdog> check that out, there are a few minor changes that need to happen
02:16:15 <blackdog> the patch i have there is out of date, and a better one is on cvs-ghc, but it'll work so long as you don't want to make linux work from the same source tree
02:16:49 <blackdog> make sure you have "GhcLibWays = v dyn
02:16:50 <blackdog> SplitObjs=NO
02:17:08 <blackdog> " in your mk/build.mk, and you should be apples
02:17:14 <blackdog> anyway
02:17:25 <blackh> Does it built at all? (I'm still reading your blog.)
02:17:26 <blackdog> got to get on a plane, ping me if you have problems. it does work, promise:)
02:17:38 <blackh> OK - thanks. Have a good flight!
02:17:42 <blackdog> it just bitrotted a bit
02:17:43 <blackdog> cheers
02:41:54 <pao> hi all
02:42:17 <pao> I'd like to stop a IO computation throwing an IOException...
02:42:30 <pao> I guess throwIO is definitely my friend
02:42:44 <pao> but what do I pass to throwIO?
02:43:09 <pao> I'd like to stop program execution with a custom error message
02:46:51 <lpsmith> pao:   look up "catch"  :-)
02:47:32 <pao> lpsmith: I don't want to catch... I'd like to throw
02:48:56 <Baughn> pao: error "string"
02:49:01 <Baughn> > error "Custom error message here"
02:49:02 <lambdabot>   * Exception: Custom error message here
02:50:32 <Baughn> pao: Though you should use throwIO in the IO monad, for reasons explained in the appropriate documentation page
02:51:15 <pao> Baughn: clear ... but how do I construct a IOException?
02:51:17 <Baughn> errorIO = throwIO . ErrorCall
02:51:43 <Baughn> pao: You don't. IOExceptions are specifically for IO errors - file not found, disk error, etc.
02:51:58 <Baughn> pao: throwIO takes any exception, not just IOExceptions
02:52:36 <pao> Baughn: In my case if a system (System.Cmd) doesn't return ExitSuccess I'd like to build a IOException and interrupt the IO computation
02:52:45 <pao> I guess ErrorCall + throwIO is the way...
02:52:50 <Baughn> pao: Why an IOException, exactly?
02:53:35 <pao> Baughn: well the semantics in my case is that of an IO Exception, if system fails, it fails because of some "io exception"...
02:53:53 <pao> disk space, memory....
02:54:00 <Baughn> pao: Well, I suppose you can use them..
02:54:42 <Baughn> pao: You construct IOExceptions using mkIOError in System.IO.Error
02:55:13 <Baughn> The IO Exception stuff is unfortunately a bit messy, since it needs to be haskell'98-compatible
02:55:54 <pao> Baughn: I guess the best solution for my case is throwIO . ErrorCall .... I guess if it is portable between 6.8 and 6.10...
02:55:58 * pao is checking
02:56:01 <Baughn> It isn't
02:56:13 <Baughn> The exception system was totally reworked during 6.9
02:56:15 <pao> Baughn: :-) I suspected ...
02:56:31 <Baughn> However, IIRC there's some extensible-exceptions package for 6.8 that has the same API as 6.10 exceptions
02:56:50 <Baughn> pao: Well, 6.12 is coming soon; I'd say it's time to drop support for 6.8
02:57:11 <Baughn> pao: Or if you just program against 6.8, your programs still work on 6.10
02:57:15 <pao> Baughn: yep... I'll do what you suggest
02:57:20 <ivanm> Baughn: depends how different base-5 is
02:57:26 <Baughn> (You just have to specify base-3 instead of base-4)
02:57:58 <Baughn> ivanm: I hear that for base-42, they're finally going to unify monad and applicative
02:58:17 <ivanm> heh
02:58:27 * ivanm doubts it somehow...
02:58:44 <pao> Baughn: that means breaking haskell 98 compat, doesn't it?
02:58:51 * Baughn doesn't quite get why they wouldn't
02:59:01 <Baughn> pao: Only a little bit
02:59:21 <ivanm> Baughn: well, why did they bother introducing Applicative?
02:59:32 <Baughn> ivanm: Because it's useful?
02:59:37 <ivanm> presumably because there's some data structures that don't have an (>>=)
02:59:43 <Baughn> pao: ..it's not like haskell'98 compatibility /matters/ to anyone
03:00:05 <Baughn> ivanm: Obviously. No, what I meant was that monad should be an explicit subclass of applicative
03:00:08 <ivanm> pao: that's what haskell' is for!
03:00:11 <ivanm> Baughn: ahhh
03:00:18 <ivanm> fix up the class order
03:00:22 <pao> Baughn: fwiw I totally agree with reviewing the whole class hierarchy
03:00:35 <Baughn> Mm. The Num type needs to be split, too.
03:00:41 <Baughn> Preferably along algebraic lines
03:01:20 <ivanm> Baughn: heh, if only people could agree how to split Num ;-)
03:02:02 <Baughn> ivanm: It seems entirely obvious to me. Just follow the usual ring/group/etc. distinctions
03:02:15 <Baughn> With a dash of torsors
03:02:44 <ivanm> Baughn: but don't some of them overlap/clash?
03:03:26 <Baughn> ..not /too/ badly
03:04:11 <ivanm> Baughn: AFAICT, most of this kinda stuff is good for programmers... but not for newbies :s
03:04:14 <SamB_XP> Baughn: that works great in Coq, I guess, but Haskell only allows one instance per class per type!
03:05:19 <Baughn> ivanm: Like with Monad, it's easy enough to just say "don't worry about it, it'll work".
03:05:25 <ivanm> heh
03:05:49 <ivanm> hmmm.... it'd be cool if you could do multiple instances in one go...
03:06:26 <SamB_XP> Baughn: but how do you deal with the two Monoids per Num?
03:06:31 <ivanm> e.g. if we have applicative being a requirement for Monad, it would be great if an instance of Functor automatically creates Functor, Applicative, etc. for you
03:06:52 <SamB_XP> ivanm: it's called Class Aliases, isn't it ?
03:07:03 <SamB_XP> unfortunately, it is not implemented
03:07:10 <Baughn> SamB_XP: Two? There's an infinite number.
03:07:11 <ivanm> is it?
03:07:28 <SamB_XP> Baughn: I meant the additive and multiplicative ones
03:08:20 <Baughn> SamB_XP: You'd have AdditiveGroup and MultiplicativeGroup classes, as per usual
03:08:42 <SamB_XP> that's disgusting
03:08:43 <ivanm> "per usual"?
03:08:54 <Baughn> It's what people are used to
03:09:04 <SamB_XP> it is?
03:09:08 <Baughn> The main point is, + and * are both supposed to be group operations
03:09:11 <SamB_XP> that's not how I would do it in Coq ...
03:09:19 <Baughn> This isn't Coq.
03:09:33 <SamB_XP> oh, I'd have used a different symbol for Group ;-)
03:09:47 <Baughn> There's no fundamental difference between + and *, but they're different operations, and need to be in different classes
03:09:57 <Baughn> ..anyway, you need both of them to make a Ring
03:10:44 * doserj would use <> (or something else) for monoids, semigroups, groups, and +,* for rings, fields, etc
03:11:39 <SamB_XP> doserj: <> is great
03:11:52 <SamB_XP> but then I said that on the list already
03:12:00 <SamB_XP> strange that I caught the thread ;-)
03:13:27 <sinelaw> why <>?
03:17:09 <SamB_XP> sinelaw: well, it wasn't taken by much, and it fits with where it *was* taken excellently
03:17:24 <SamB_XP> and it also fits with mathematical notation very nicely
03:17:39 <sinelaw> I thought the math notation was *?
03:17:59 <SamB_XP> mathematical notation for appending sequences ;-P
03:18:00 <sinelaw> i mean a small circle
03:18:18 <sinelaw> ah
03:22:16 <gio12345> is lambda x1x2. f(x1x2) second order lambda term?
03:24:06 <Cale> I guess so, in that x1 must be a function
03:24:19 <SamB_XP> usually we use more spaces ;-)
03:24:26 <Cale> Unless you meant for x1x2 to all be one variable.
03:24:39 <SamB_XP> Cale: I don't think he meant that ;-)
03:24:50 <Cale> I don't either
03:26:31 <gio12345> Cale: hi
03:26:36 <Cale> hi
03:52:28 <ivanm> anyone here know what HSX refers to by "Class assertions"
03:54:03 <mjrosenb> what is hsx?
03:56:05 <ivanm> haskell-src-exts aka Haskell Source with Extensions
03:57:37 <mjrosenb> ahh
03:59:55 <RubinosPerez> juego de boxeo online http://www.kobox.org/kobox-fande-Nourine.html
04:04:09 <profmakx> any suggestions on a book/article/whatever on how to implement a programming language using haskell? I know this has been done at least a hundred thousand times but I cant seem to find a decent kind of source
04:05:01 <Vanadium> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours might be a bit too basic for your needs, but eh
04:05:39 <profmakx> well
04:06:21 <profmakx> actually that looks quite good
04:07:20 <profmakx> learning haskell AND getting into implementation of languages again is not the easiest task. but without a project i wouldn't learn
04:07:24 <profmakx> thanks!
04:08:34 <Crito> Hi. I am trying to learn the estimation of complexity. Do 1+2+3..+n and n(n+1)/2 have the same complexity?
04:08:47 <Crito> I think they both have BigO(N^2)
04:10:14 <profmakx> assuming that + and / have the same cost
04:10:28 <profmakx> equally for all magnitudes of "n"
04:10:37 <profmakx> the first is O(n)
04:10:43 <profmakx> and the second is O(1)
04:11:17 <profmakx> because you need n-1 additions for the first one and just 3 operations for the second one (one multiplication one addition and one division)
04:11:42 <opqdonut> Crito: do you mean the time complexity of computing those operations
04:11:46 <Crito> yeah
04:11:47 <|Steve|> It depends if you mean you're comparing performing n-1 additions to an addition, a multiplication, and a division (or right shift).
04:11:59 <HugoDaniel> hi
04:12:04 <koala_man> Crito: you mean calculating the sum of a series of integers in two different ways?
04:12:09 <Crito> |Steve|: right. that is what I mean/
04:12:19 <koala_man> or an operation that takes 1+2+..+n steps for n elements
04:12:28 <Crito> koala_man: well, yeah. What is the difference if I add up the integers to n elements?
04:12:35 <|Steve|> Then as profmakx said, the first is Theta(n), the second is Theta(1).
04:12:56 <HugoDaniel> im trying to use the ByteString breakByte function, but it complains that it cant match expected type Word8 with inferred type Char
04:13:06 <HugoDaniel> how do i convert my 'c' to a Word8 ?
04:13:08 <Crito> perfect. Makes sense.
04:13:20 <poe> ?type ord :: Char -> Word8
04:13:20 <lambdabot>     Couldn't match expected type `Word8' against inferred type `Int'
04:13:20 <lambdabot>     In the expression: ord :: Char -> Word8
04:13:38 <profmakx> @hoogle Char -> Word8
04:13:38 <poe> nah
04:13:38 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
04:13:38 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:13:38 <lambdabot> Prelude error :: [Char] -> a
04:13:41 <Crito> Actually, I am trying to read up on complexity heirarchies and am struggling to find a good resource.
04:13:57 <Crito> Number Theory books never seem to ponder much on complexity.
04:14:17 <|Steve|> http://www.amazon.com/Computational-Complexity-Christos-H-Papadimitriou/dp/0201530821
04:16:46 <benmachine> HugoDaniel: you could try fromIntegral . ord
04:16:54 <benmachine> don't know how that deals with overflow though
04:17:10 <benmachine> (remember that haskell Chars aren't eight bits)
04:17:19 <HugoDaniel> yes
04:17:19 <benmachine> (at least, not always)
04:17:22 <HugoDaniel> :/
04:19:17 <Baughn> HugoDaniel: What are you trying to do, exactly?
04:19:39 <gio12345> is lambda x1x2. (fx1)x2 second order lambda term?
04:19:40 <HugoDaniel> Baughn, im parsing a bytestring, and i want to discard the first line
04:19:41 <gio12345> ?
04:19:49 <Baughn> HugoDaniel: Define "line"
04:19:50 <HugoDaniel> so, i call breakByte '\n'
04:20:03 <HugoDaniel> line, as in a text line :P
04:20:15 <Baughn> Define "text". :P
04:20:28 <Baughn> It all depends on the encoding
04:20:39 <HugoDaniel> lines <- ByteString.readFile f
04:20:46 <Baughn> Fortunately, \n is a relatively constant one-byte encodee in most encodings
04:21:06 <Baughn> Unfortunately, this is not always the case, for example if the text file happens to beUTF-16
04:21:10 <HugoDaniel> oh well, ill just discard bytestrings, as they make my life much more painfull
04:21:24 <Baughn> Now, don't do /that/
04:21:43 <|Steve|> Don't you just love when the type system gets in the way of doing what you want?
04:21:50 <HugoDaniel> :)
04:21:51 <Baughn> HugoDaniel: You may be interested in the hGetLine function
04:22:10 <Baughn> HugoDaniel: Which, granted, is really a hGetBytestringBrokenByAsciiValueOfNewline function
04:22:15 <Baughn> Emphasis on "ASCII"
04:22:44 <profmakx> so much for "text files are portable"
04:22:57 <Baughn> They are, so long as you stick to unix
04:23:02 <Baughn> Windows likes UTF-16. :/
04:23:20 <Baughn> The entire /rest/ of the world uses UTF-8
04:23:33 <idnar> or ISO-8859-* :P
04:23:38 <HugoDaniel> :D
04:23:38 <profmakx> more fun ahead when i want to go to bytestrings with my parser
04:23:45 <idnar> or one of those far east charsets
04:23:47 <|Steve|> I think windows like ISO-8859-1 in the US.
04:23:49 <Baughn> idnar: Not new systems, I don't think. Legacy, yes.
04:23:59 <Baughn> idnar: And even the asians are starting to standardize on utf-8 now
04:24:08 <profmakx> unfortunately the windows-part of the world is not inside some epsilon ball for small epsilons
04:24:22 <HugoDaniel> i was planning to do an excel file reader/writer
04:24:23 <|Steve|> They are? I thought they used thinks like shift-JIS.
04:24:37 <Baughn> They do, but at least utf-8 has /some/ momentum now
04:24:39 <HugoDaniel> i guess it will have to wait :P
04:25:00 <Baughn> The asians (particularily japan) are so used to encoding problems, they're very happy standardize on something - anything.
04:26:01 <|Steve|> At least the Japanese do. As I recall, most characters can be encoded with 2 bytes using Shift JIS whereas they take 3 with UTF-8 or 4 with UTF-16.
04:26:23 <Twey> Baughn: You'd think so, wouldn't you?
04:26:31 <Baughn> Twey: I would. I've seen the tendencies.
04:26:50 <Baughn> Of course, there's also their giant NIH complex..
04:26:54 <ksf> is there a way to reset the profiler from within the profiled program?
04:26:58 <Twey> Nevertheless, email is still sent in Shift_JIS, and IRC is still predominantly ISO-2022-JP
04:27:06 <Twey> Heh, yes.
04:27:09 <Baughn> No, IRC is ascii
04:27:14 <Baughn> It says so right there in the standard :3
04:27:20 <Twey> Psht :þ
04:27:27 <benmachine> standard schmandard
04:27:37 <ksf> eg. if I have large startup costs but want to profile update/draw behaviour, I don't want to appear the startup costs in the figures.
04:27:47 <ksf> *the startup costs to appear
04:27:56 * earthy is still impressed by the Algol 68 language definition
04:28:05 <earthy> which completely sidestepped the encoding issue :)
04:28:24 <earthy> but not without mentioning it
04:28:30 <blackh> Hi yall.  I need some help with a type families question...
04:28:54 <earthy> really, there seems to have been much more awareness of the whole encodings mess before 1975 than since. ;)
04:29:19 <blackh> I've got a binary operator called // which appends different types of things to give an output type.  It's easy enough to make the output type depend on the two input types....
04:29:22 <Twey> What are these ‘type family’ things people keep going on about?
04:29:40 <Twey> Is there some distinction I'm missing here, or are we just too good to call them ‘type classes’ now?
04:29:44 <blackh> but is there a way to make the rules more complex, so that the input types sometimes determine the output type, and the output type sometimes determines it?
04:29:48 <ivanm> Twey: http://www.haskell.org/haskellwiki/GHC/Type_families
04:29:53 <ksf> 'cos type families aren't type classes
04:30:05 <Twey> Oho
04:30:07 <ksf> type families are open functions on the type level.
04:30:13 <ivanm> AFAICT, "normal" type families are like a class on the kind level
04:30:19 <blackh> The reason is that I want either the input or the output type to be able to 'pull' it into a monadic type.
04:31:19 <ksf> ...without much knowledge about totality. so e.g. type instance Mul n (Succ m) = n `Add` (n `Mul` m) requires UndecidableInstances because fun calls are nested on the rhs.
04:31:24 <blackh> I don't know if type families can do this, but it'd be really great if they could!
04:32:14 <ksf> blackh, you can do class Foo a b | a -> b, b <- a
04:32:34 <ksf> ...or you can do two classes.
04:33:10 <blackh> What I've got is this... class Chainable a b c where ; type OutputType a b :: *
04:33:20 <blackh> My concrete types are Output (monadic) and PureOutput
04:33:32 <ksf> ...and, of course, type instance Depends a b = c
04:34:16 <blackh> I'd like it so that if any of a, b, or c is Output, it'll make the output type Output
04:34:26 <blackh> (output type being c)
04:34:43 <blackh> Forgot to mention this:  (//) :: a -> b -> c
04:34:51 <Cale> ksf: can you really flip the arrow around and write the same functional dependency twice? ;)
04:35:19 <ksf> type instance (a ~ Output) => Depends a b c = a
04:35:24 <ksf> ...and the same for b and c
04:35:47 <lpsmith> ok,  I'm a TH newbie,  and I have a question
04:35:53 <ksf> ...and a bottom case, most likely just passing a fourth type d through.
04:35:53 <blackh> ksf: That is VERY cool! Thank you!
04:36:09 <blackh> Did I mention that I really like Haskell?
04:36:17 <lpsmith> I want to generate a bunch of cases in a case statement
04:36:27 * ksf thinks Output will have to be a class, though, but that's probably what you want, anyway.
04:36:33 <lpsmith> And I have it working through the low-level interface
04:36:45 <lpsmith> low-level syntax tree, that is
04:37:12 <ksf> in general, TH reduces to a *E and so on mess.
04:37:17 <blackh> ksf: Currently Output is a concrete type but I'll see what I can do - you've pointed me well in the right direction - thanks.
04:37:21 <lpsmith> But I'm trying to figure out how to do it with the sugard
04:38:17 <ivanm> anyone here know what HSX refers to by "Class assertions"
04:39:33 <lpsmith> something like  [|  $(IntegerL code) ->  $(something that evaluates to an Exp) |]
04:39:33 * ksf knows about contexts, which are the thing before the =>
04:39:38 <lpsmith> gives me a syntax error
04:39:48 <lpsmith> and I have a function that generates a single case
04:40:20 * ksf doesn't think a single case line is a proper syntactic element.
04:40:29 <ksf> ...at least none that has brackets defined.
04:40:36 <lpsmith> hmm
04:40:41 <lpsmith> I was afraid of that
04:41:31 <lpsmith> so how do I use TH to generate case statements with an arbitrary number of cases,  nicely?
04:41:59 <ksf> I'd just use the syntax tree
04:42:04 <ksf> ...and not worry about quotations.
04:42:43 <ksf> TH is certainly a bit awkward when it comes to that, compared to lisp macros or define-syntax
04:48:48 <lpsmith> Ok,  so what if I want to write something like [| Data.ByteString.pack $(StringL var) |]
04:49:07 <lpsmith> I'm getting a type error that $(StringL var) is not an ExpQ
04:49:28 <ksf> it isn't.
04:49:40 <ksf> you've got to pack it into a LitE
05:17:44 <TheColonial> hi guys, would someone mind helping me move from total noob to semi noob with an out of memory issue? Code is here -> http://codepad.org/bWhlxuqU
05:17:57 <TheColonial> I get an out of memory error.
05:18:48 <TheColonial> i'm not sure what i am doing wrong.
05:19:50 <ksf> I think the thing your'e doing wrong is compiling without -prof and running without +RTS -h
05:19:57 <vegai> :P
05:20:13 <stanv> howto extend list with some element? ( I want `zip' don't lose elements from bigger list)
05:20:15 <ksf> for then, you could do hp2ps -c Foo.hp ; gv Foo.hs and have a look at what's happening.
05:20:22 <vegai> 10^12, how much is that again
05:20:33 <Petrosian> > 10 ^ 12
05:20:34 <lambdabot>   1000000000000
05:20:35 <ksf> (like I am right now, and it appears I'm leaking sparks)
05:20:42 <TheColonial> ok, i'll try it.
05:20:42 <vegai> not more than Integer holds, right
05:20:54 <TheColonial> Integer is infinite isn't it?
05:21:01 <vegai> Oh, oops.
05:21:16 <benmachine> TheColonial: integer is limited by your available RAM
05:21:21 <vegai> my original point is correct still, though :P
05:21:27 <RayNbow> stanv: could you give an example of what you want?
05:21:29 <benmachine> which is a lot
05:21:29 <TheColonial> benmachine, yes I am aware of that thanks mate.
05:21:38 <TheColonial> benmachine :)
05:21:42 <Petrosian> toInteger (maxBound :: Int) > 10 ^ 12
05:21:44 <Petrosian> > toInteger (maxBound :: Int) > 10 ^ 12
05:21:45 <lambdabot>   True
05:22:01 <Petrosian> Seems not
05:22:44 <ksf> erm no. type breakdown says I'm leaking Integers.
05:22:48 <TheColonial> ksf am running with +RTS -h now
05:23:01 <TheColonial> leaking integers?
05:24:03 <stanv> RayNbow: already found: zip ([1,2,3]++cycle [0] ) [1,2,3,4,5,6]
05:24:04 <ksf> well, rather thunks containing Integer expressions and thus Integers.
05:24:14 <TheColonial> ksf, right.
05:24:23 <RayNbow> stanv: ah ok
05:24:27 <TheColonial> but where is that happening?
05:24:30 <ksf> ...my numbers aren't getting any bigger, so it should run in approx. constant space.
05:24:33 <TheColonial> sorry, this is new to me.
05:24:43 <ksf> ...but the graph is showing a linear increase in heap usage.
05:24:52 <ksf> so I'm leaking them.
05:25:19 <RayNbow> stanv: you might want to use "repeat 0" instead of "cycle [0]"
05:25:26 <RayNbow> > repeat 0
05:25:27 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
05:25:28 <RayNbow> > cycle [0]
05:25:29 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
05:26:47 * ksf has no idea where his Integers are coming from, he doesn't use any.
05:26:57 <stanv> RayNbow: thanks :)
05:30:40 <ksf> nope, it's clearly CHP that's leaking memory.
05:31:34 <TheColonial> CHP?
05:31:42 <ksf> @hackage chp
05:31:42 <lambdabot> http://hackage.haskell.org/package/chp
05:32:32 <TheColonial> ah!
05:32:53 <dv-_> someone really ought to finish Graphics.UI.SDL.Primitives :|
05:33:05 <TheColonial> ksf i ran the program with the options, produced the ps and am looking at the output. i have no idea how to make use of it :)
05:34:03 <dv-_> http://hackage.haskell.org/packages/archive/SDL-gfx/0.5.2/doc/html/src/Graphics-UI-SDL-Primitives.html
05:34:36 <ksf> by default it's showing you the allocation profile of cost centres (automatic ones or inserted with {-# SCC "foo" #-}, -hd and -hy give closure/type breakdowns, respectively.
05:35:32 <ksf> ...and be sure to use hp2ps -c, grayscale output is realy impenetratable.
05:36:29 <sohum> @pl \p g -> [1..(p-1)] == f p g
05:36:29 <lambdabot> ap ((.) . (==) . enumFromTo 1 . subtract 1) f
05:36:50 <ksf> ...a good profile should have an (sharp) incline at the beginning and then plateau on constant space.
05:36:57 <TheColonial> this is not a good profile :)
05:37:12 <sohum> @pl sort $ map ((
05:37:12 <lambdabot> (line 1, column 14):
05:37:12 <lambdabot> unexpected end of input
05:37:12 <lambdabot> expecting lambda abstraction, expression or ")"
05:37:15 <sohum> bah
05:37:48 <TheColonial> ksf think of a parabola (of say y = x^2) rotated 90 degrees to the right.
05:37:50 <sohum> @pl \p g -> sort $ map ((`mod` p) . (g^)) [0..(p-2)]
05:37:51 <lambdabot> (sort .) . ap (flip . (map .) . (. (^)) . (.) . flip mod) (enumFromTo 0 . subtract 2)
05:37:55 <ksf> and usuall the things that are leaking start after the initial incline incline
05:38:36 <ksf> ...well at least it's not exponential.
05:38:41 <TheColonial> aye true
05:39:18 <TheColonial> I just dont know where to even begin looking
05:39:35 <ksf> and it's better than mine, mine's constantly increasing, linearely.
05:39:55 <ksf> look for the triangles between the parallel lines.
05:40:53 <TheColonial> do i need to run it with -hd to get those triangles?
05:41:09 <blackh> ksf: I'm getting "The current implementation of type families does not support equality constraints in superclass contexts." even after trying 6.11.20090920. Is this what you expect, or am I doing something wrong?
05:41:09 <ksf> you should get them with any annotation.
05:41:27 <ksf> blackh, I don't think so.
05:41:42 <TheColonial> nope, i just have the curve. filled in. all black. a rather standard graph.
05:42:03 <ksf> (except using equality constraints in superclass contexts, of course)
05:42:04 <blackh> ksf: The line it doesn't like is: class (Depends a b c ~ c) => Chainable a b c where
05:42:19 <ksf> (and maybe not bugging the ghc devs about it)
05:43:07 <blackh> ksf: I'm not quite sure what I'm doing yet, but it seems like this feature would do what I want, but on the face of it, it isn't implemented yet.
05:43:09 <ksf> that shouldn't be nescessary, Depends should resolve to c, anyway.
05:43:45 <blackh> ksf: Can you go over it again for me - I don't quite understand what you're suggesting.
05:43:55 <TheColonial> ksf: http://twitpic.com/ikp5c the generated ps image.
05:44:03 <ksf> depending on your code, you might not even need a class Chainable, but just a polymorphic function with the proper constraints.
05:44:39 <ksf> TheColonial, insert SCC annotations.
05:44:48 <ksf> ...or use -prof -auto-all
05:44:52 <TheColonial> ok
05:45:53 <ksf> my suggestion was that Depends is a type fun that returns the output type.
05:46:01 <blackh> ksf: I'll paste my prototype... It's at http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3868#a3868  - can you see what I'm getting at?
05:46:32 <blackh> ksf: ghc 6.10 didn't seem to like => in the 'type instance' lines.
05:46:39 <ksf> so to use it, you need something like class Chainable a b (Depends a b) where...
05:46:42 <TheColonial> ksf, how do i insert SCC annotations?
05:47:08 <ksf> blackh, well, so much for my idea.
05:47:18 <blackh> ksf: It must be possible somehow!
05:47:30 <alp2> hi. I'm writing a custom Iteratee implementation to work with the hyena server. I've been able to work out the basics, but now I'm stuck on the "convStream" combinator (http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3869#a3869). Given the types, is it possible to implement such function?
05:47:37 <Saizan_> ?google ghc profiling
05:47:39 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
05:47:39 <lambdabot> Title: Chapter�5.�Profiling
05:47:39 <ksf> TheColonial, http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
05:47:45 <TheColonial> thank you
05:47:54 <blackh> TheColonial: Did you try compiling with -auto-all? (Excuse me if I've missed part of this conversation!)
05:48:00 <ksf> ...oh, SCC isn't mentioned there.
05:48:24 <TheColonial> blackh I've just done that now, thanks :) ghc -prof -auto-all
05:48:30 <TheColonial> and am running with +RTS -h -p
05:48:30 <ksf> blackh, simple solution: claim that it's impossible on the cafe and thus have oleg implement it.
05:49:25 <Saizan_> i didn't know -h was supported
05:49:32 <blackh> ksf: Great idea! Well, I'll keep chipping away at it and see if I can get it to work.
05:50:38 <ksf> Saizan_, heap and time profiles are the very thing that convert haskell from win to epic win
05:52:29 <Saizan_> ksf: i mean that i've always seen -hX where X = c,d,T,..
05:52:47 <ksf> -h is -hc
05:53:02 <sergio1> Hi, I'm trying to haskell-transpose some C++ code I already have (which, I think, works)
05:53:10 <sergio1> OK, don't flame me ;-)
05:53:45 <sergio1> I've defined a C++ class for intervals, and which I use as a key in an std::map
05:54:13 <sergio1> I've defined only one method, which amounts to the 'isSmaller' operator
05:54:57 <sergio1> It's simply defined as (b1,e1) < (b2,e2) = e1 < b2
05:55:23 <TheColonial> ksf, thanks for the help. i'll push on ahead, then i'm off to bed. cheers.
05:55:43 <sergio1> And I'm able to query my map by giving any number which is in an interval
05:56:52 <sergio1> E.g, with Interv(2,3) associated to "a", and Interv(5,8) associated to "b"
05:57:26 <sergio1> If I query my map with 2 or 3 I get "a", with 4 I don't get anything, etc.
05:57:58 <sergio1> I try to translate this in Haskell with Data.Map.Map, but it doesn't work
05:58:25 <sergio1> Maybethe problem is that I've defined the "<=" method of class "Ord"?
06:00:15 <sergio1> When compiling, it complained my type was not an instance of 'Eq'.
06:00:41 <doserj> Ord a requires an Eq a instance
06:01:31 <sergio1> I added an instance (i1 == i2 = i1 <= i2 && i2 <= i1), this compiles, but I don't get anything out of my map...
06:02:29 <sergio1> I'm at a lost, since I don't understand why it works in C++ and not in Haskell.
06:02:56 <sergio1> I'm obviously missing something which makes Data.Map.Map very different from std::map
06:03:49 <ivanm> sergio1: because you're assuming an Ord instance exists when trying to define your Eq instance
06:04:20 <doserj> ivanm: that's not the problem, I think
06:04:41 <ivanm> maybe ;-)
06:04:49 * ivanm just came back to the computer
06:05:20 <doserj> sergio1: I think we need more information about your haskell code
06:06:42 <Saizan_> sergio1: can it be that the order defined by your Ord instance is not a total order?
06:07:38 <sergio1> I think the order is not total in the most general sense, but that it should not be a problem for all concrete cases.
06:08:14 <sergio1> (basically, I'm registering memory intervals in maps, and intervals will never overlap in practice)
06:09:26 <Saizan_> however i think we'd need the code and an example of it going wrong to help you
06:09:45 <Saizan_> since it seems there's no expert of std::map around :)
06:09:51 <sergio1> I understand! I'm working at it!
06:10:00 <sergio1> Thanks in advance!
06:14:29 <fr0ggler> hey everyone
06:14:47 <fr0ggler> i have a question regarding case statements and Either (Left/Right)
06:15:12 <fr0ggler> can you nest a function in the Right part?
06:15:46 <lilac> fr0ggler: the Right part can be any expression you like (as can any branch of any case expression) as long as it's well-typed
06:16:11 <fr0ggler> so case foo Nothing f of \ Left err -> fail $ "error" \ Right bar - > return ( \ case ...... etc )
06:16:22 <fr0ggler> (forgive my explanation, I'm a massive Haskell newbie)
06:17:03 <fr0ggler> im trying to debug some code using the hexpat library and I'm finding it a bit tricky
06:17:19 <lilac> well, there are a number of syntactical errors there.
06:17:48 <lilac> firstly, you don't want a '\' in the case branches: case expr of Left err -> ...; Right bar -> ...
06:18:01 <fr0ggler> ah sorry - the \ are to denote line breaks
06:18:13 <lilac> ok, well that covers my secondly too ;-)
06:18:16 <fr0ggler> :)
06:18:46 <fr0ggler> lilac, i'll pastebin what I'm debugging - that may be easier to explain
06:19:17 <lilac> > case Right 123 of Left err -> fail $ "error"; Right bar -> return (case bar of 1 -> "one"; 123 -> "onetwothree"; _ -> "unknown")  :: [String]
06:19:18 <lambdabot>   ["onetwothree"]
06:20:18 <fr0ggler> http://pastebin.org/19257
06:20:49 <fr0ggler> so you'll see from that paste that the result of unpickleTree is assigned to the Right
06:20:50 <Axman6> fr0ggler: it might be worth looking into how the Either monad works, sounds like it might be what you're after
06:20:55 <Axman6> @sec Either (>>=)
06:20:56 <lambdabot> Left  l >>= _ = Left l
06:20:56 <lambdabot> Right r >>= k = k r
06:21:06 <Axman6> src* but go lambdabot
06:21:10 <fr0ggler> (forgive my terminology if it's wrong - I've only just started Haskell)
06:21:43 <fr0ggler> but I'm getting an exception in some cases, and I would like to raise a "proper" error message relating to the unpickleTree
06:22:00 <fr0ggler> so i was thinking about nesting another case statement in the Right to do this
06:22:05 <fr0ggler> would that be sensible?
06:22:31 <lilac> what type does unpickleTree return? how does it indicate errors?
06:23:06 <fr0ggler> lilac, http://hackage.haskell.org/packages/archive/hexpat-pickle/0.3.1/doc/html/Text-XML-Expat-Pickle.html#v%3AunpickleTree
06:23:36 <lilac> fr0ggler: ok, so it looks like you want to be using unpickleTree' rather than unpickleTree
06:23:47 <fr0ggler> it says it throws UnpickleException, however I see a exception :: Control.Exception.Extensible.SomeException
06:24:01 <lilac> and as Axman6 suggests this can be expressed nicely using the "Either e" monad
06:24:06 <fr0ggler> i'd like to know what the exception is really telling me
06:24:43 <fr0ggler> lilac, Axman6, ah right ok - bear with me whilst I do a bit of reading - I'll probably be back in a short while :) thanks for the great help so far though!
06:25:01 <lilac> fr0ggler: well, that's to do with GHC's extensible exception mechanism. SomeException is an "existential" wrapper which is basically a container for any type of exception
06:25:10 <Axman6> the Either monad is probably one of the most useful (though ironically i've never used it, heh)
06:25:29 <fr0ggler> lilac, ah right. so is there an "easy" way to get at the exception message that's obviously from unpickleTree?
06:25:44 <fr0ggler> or is the Either monad the way to go here too?
06:26:03 <lilac> fr0ggler: use unpickleTree' rather than unpickleTree. exceptions are generally best avoided where possible
06:27:12 <sergio1> I'm coming back with my interval map...
06:27:29 <sergio1> Not sure if I've the exact URL, sorry if I screw up...
06:27:31 <sergio1> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3870#a3870
06:27:32 <lilac> fr0ggler: you can then nest another 'case' inside your original 'case' to deal with the unpickleTree' result, but this is exactly what the Either monad instance does for you...
06:29:04 <sergio1> I'm surprised there's no existing Haskell libraries for such intervals.
06:29:27 <ivanm> in State, if I do a get, then call a State function that modifies the state, do I have to get again to get the updated state?
06:29:34 <lilac> fr0ggler: you might also want to consider making 'unpickleFile' return 'IO (Either String a)' rather than 'IO a' so its callers don't have to deal with the exception produced by 'fail'.
06:29:37 <ivanm> sergio1: what are you calling an interval map?
06:29:51 <sergio1> Well, may be it's overly specific, and, moreover, as I said, it's not going to work all the time, only when intervals do not overlap...
06:30:16 <Crito> profmakx: say, I have a small division algorithm (2 steps: multiply and add), and I want to repeat it 4k (for some arbitrary k \in Z) times. will that make it O(k)?
06:30:19 <sergio1> Basically, I want to record an information regarding a memory interval.
06:30:28 <Saizan_> sergio1: ah, well, Data.Map.lookup k m gives you an element only if there's a key in m such that key == k, but that never happens with the inputs you use there
06:30:30 <lilac> sergio1: Data.FingerTree would be a good choice for an interval map
06:30:39 <sergio1> And I want to retrieve this information for giving any address in said interval
06:31:00 <profmakx> Crito  as long as you dont try to repeat it -5 times :P
06:31:03 <lilac> sergio1: the fingertree paper is pretty accessible and uses an interval map as one of its examples
06:31:07 <saml> Crito, yes. it's O(k) where k is number of steps (mult or add)
06:31:23 <Crito> profmakx: heh.
06:31:33 <Crito> saml, profmakx: thanks.
06:31:35 <lilac> Crito: it really depends on whether you think your 'small steps' are constant-time
06:31:42 <fr0ggler> lilac, ok thanks for those hints - i'll try to get my head around it :)
06:31:44 <Saizan_> or does it?
06:32:05 <sergio1> Saizan: in std::map, a match is when "!(key < val) && !(val < key)"; no equality is needed really
06:32:24 <profmakx> lilac, yeah i already mentioned that before
06:32:35 <Crito> lilac: at this point I am assuming all the common operations (+,-,*,/ are going to cost me the same)
06:33:03 <Axman6> so, from my first foray into OpcnCL, i can tell you it is damn fast
06:33:05 <lilac> sergio1: your < is not a strict weak ordering, so you can't even use your intervals in a std::map without invoking undefined behaviour ;-)
06:33:20 <Saizan_> sergio1: yeah, that's the difference
06:34:19 <doserj> sergio1: does it work if you define /= instead of == for the Eq instance?
06:34:25 <Saizan_> sergio1: and, btw, (INV 2 2) < (INV 2 3) = True, given your code
06:34:36 <sergio1> Am I right if I sum this up by saying that C++ and Haskell use different properties here?
06:35:03 <lilac> sergio1: the natural translation of your program into c++ gives undefined behaviour
06:35:34 <sergio1> lilac, can you provide me with a URL for the fingertree paper?
06:36:01 <lilac> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
06:36:07 <Axman6> rarg! why won't this code get any faster when i make it parallel :'(
06:36:14 <lilac> sergio1: the implementation is in the 'fingertree' package on hackage.
06:36:20 <Axman6> it should be a prime candidate for parallelisation
06:36:47 <sergio1> lilac: thanks (I found it in the mean time, from hackage package)!
06:41:08 <doserj> sergio1: your example works for me with: instance Eq INV where (INV e1 b1) == (INV b2 e2) = e1==b2
06:41:44 <pastah> is there some way to set the parser to default parsing of numbers to a special type
06:42:11 <pastah> i want to make all numbers i use to default to GLfloat, since that is what i will be needing everywhere
06:42:25 <pastah> well, all floaiting numbers
06:43:10 <Axman6> can anyone remember the +RTS option used to dump the stats about the program when it's finished?
06:45:22 <sergio1> doserj: my test set was not big enough: even with your version, retrieving info for 3 does not work
06:47:59 <mmorrow> pastah: it's not the parser that makes the decision, but the typechecker
06:48:24 <doserj> sergio1: instance Eq INV where (INV b1 e1) == (INV b2 e2) = b1==b2 || b2 <= b1 && b1 <= e2 || b1 <= b2 && b2 <= e1
06:48:31 <Axman6> argh! where have those posts of dons' gone about writing haskell that's faster than C? :(
06:48:32 <mmorrow> pastah: if the surrounding context implies that the number is a GLfloat, then it's a GLfloat
06:49:26 <doserj> sergio1: basically, two intervals are equal, if they overlap (which should not occur for different intervals, as you said)
06:49:35 <mmorrow> Axman6: +RTS -sstderr -RTS
06:49:36 <mmorrow> ?
06:49:46 <Axman6> that's the one, thanks :)
06:49:49 <doserj> sergio1: (I guess you can leave out the b1==b2 part)
06:50:55 <sereven> hmm, in ghci ` :let infixl ~~ 2 ; (~~) = foo ' defines (~~) but it gets still infixl 9 regardless of let fixity. Is there any way to do it on the fly? or must reload from a file. Thought someone here had shown me how before, but this doesn't seem it.
06:50:58 <Axman6> hmmmmmm, i don't know why this code is so slow, and i really have no idea why it's not getting faster when i make it parallel :(
06:51:47 <Axman6> thought it might be doing a lot of GC, but it's only spending 0.1% of its time doing that
06:51:49 <sergio1> doserj: thanks!
06:52:09 <sergio1> lilac: thanks, I'll have reading homework!
06:52:27 <ivanm> @type (sequence .) . mapM
06:52:28 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [[a]]
06:52:35 <ivanm> ^^ why is it defaulting the monad to lists?
06:52:45 <fr0ggler> lilac, Axman6 - i've tried this out, but i'm still getting an error (couldn't match PU t a against inferred type Maybe a1) ---> http://pastebin.org/19289
06:52:46 <ivanm> gah, ignore that
06:52:52 <ivanm> I was getting map and mapM mixed up
06:53:34 <saml> sergio1, it's let infixl 2 ~~; (~~) = foo
06:54:33 <saml> > let (+++) = (+); infixl +++ 2 in 3 - 1 +++ 2
06:54:34 <lambdabot>   <no location info>: parse error on input `2'
06:54:55 <ivanm> OK, real question :p what's the difference between a type family and a data family?
06:55:03 <saml> > let (+++) = (+); infixl 2 +++ in 3 - 1 +++ 2
06:55:04 <lambdabot>   4
06:55:13 <ivanm> the page on haskell.org about them seems to use them semi-interchangeably :s
06:55:16 <sergio1> saml: I'm not the guy fiddling with ~~ ;-)
06:55:20 <saml> wtf it returns 0 in my ghci
06:56:00 <mmorrow> , let (+++) = (+); infixl 2 +++ in 3 - 1 +++ 2
06:56:03 <lunabot>  4
06:56:15 <ivanm> returns 4 here
06:56:19 <ivanm> saml: which version of ghc?
06:56:35 <saml> ivanm, oh never mind. i did it in 2 steps.
06:56:38 <ivanm> heh
06:56:43 <saml> let (+++) = (+); infixl 2 +++
06:56:49 <saml> 3 - 1 +++ 2
06:57:15 <sereven> saml: doh! ah, of course. oops. let me try again
06:58:04 <ivanm> saml: well, wouldn't the (-) be applied first anyway? so it'd be (3 - 1) + 2 = 4 ?
06:58:25 <saml> no, since - has infixl 6, it'll be 3 - (1 + 2)
06:58:33 <saml> if + was 2
06:58:55 <ivanm> ummm.... I thought higher infix meant do it first...
06:59:00 <ivanm> since * has infixl 7...
06:59:00 <Saizan_> ivanm: it's roughly the same difference between "type" and "data"
06:59:10 <ivanm> Saizan_: so type families are just aliases?
06:59:17 <saml> @let (+++) = (+); infixl 2 +++
06:59:17 <Saizan_> ivanm: yes
06:59:18 <lambdabot>  Defined.
06:59:25 <saml> > 3 - 1 +++ 2
06:59:26 <lambdabot>   Ambiguous occurrence `+++'
06:59:26 <lambdabot>  It could refer to either `L.+++', defined at <l...
06:59:38 <saml> > 3 - 1 L.+++ 2
06:59:39 <lambdabot>   4
06:59:46 <saml> i fail
06:59:54 <twanvl> > let (+++) = (+); infixl 9 +++ in 3 - 1 +++ 2
06:59:55 <lambdabot>   0
07:01:39 <Gwern-away> @quote mispelt
07:01:39 <lambdabot> quicksilver says: no, you mispelt >> as ;
07:01:42 <saml> this is weird. try to open ghci and type the 2 lines:  let (+++) = (+); infixl 2 +++
07:01:51 <gwern> @quote alter-ego
07:01:51 <lambdabot> dons says: Cale's my alter-ego. I talk about applications and benchmarking, he talks about theory and math. We've been doing this for years :)
07:02:00 <gwern> @quote offtopic
07:02:00 <lambdabot> gwern says: #haskell: because none of us are as offtopic as all of us
07:02:11 <gwern> @quote HYPNOTOAD
07:02:11 <lambdabot> jfredett says: A monster! HAH! It will not be a monster, but a god! ALL SHALL BOW BEFORE MY SPAWN AND DESPAIR! ALL HAIL THE PROGRAMMER CHILD! ALL HAIL THE HYPNOTOAD!
07:02:23 <gwern> @quote applicative
07:02:23 <lambdabot> AlanJPerlis says: Purely applicative languages are poorly applicable.
07:02:34 <gwern> huh. no quotes were dropped. a record!
07:02:37 <ivanm> gwern: *groan*
07:02:41 <gwern> but for tradition's sake...
07:02:42 <gwern> @flush
07:03:01 <lilac> saml: that works for me...
07:03:21 <twanvl> it prints 0 here, which is wrong
07:03:30 <saml> yah
07:04:07 <lilac> twanvl: oh, right, that's true. also :info says it doesn't have a defined precedence
07:04:51 <saml> since ghc is opensource, let's fork and fix it
07:06:54 <lilac> weird... if you specify infixl 6 for (+++) it works
07:06:57 <lilac> disregard that, i was wrong ;)
07:07:56 <lilac> > do let { (+++) = (+); infixl 2 +++ }; return (3 - 1 +++ 2) :: [Int]
07:07:57 <lambdabot>   [4]
07:09:07 <sereven> lilac: it seem to work in a single line like twanvl showed above, but not bound into the operator unless defined in a loaded file. good enough to save on :r during tests and tweaks.
07:09:56 <sereven> ah, :e is probably the way to go here, always forget about that
07:13:37 <eevar2> " Due to the thunking behavior of foldl, it is wise to avoid this function in real programs: even if it doesn't fail outright, it will be unnecessarily inefficient. Instead, import Data.List and use foldl'. "
07:15:31 <eevar2> is this generally accepted? if so, why even keep the regular fold around?
07:15:35 <eevar2> *advice
07:17:46 <Saizan_> it's generally accepted, though there are cases where the extra strictness of foldl' is useless and only a waste of time to enforce it (unless the compiler is smart enough to remove the seq)
07:17:57 <Saizan_> ?src reverse
07:17:57 <lambdabot> reverse = foldl (flip (:)) []
07:18:21 <voker57> it smiles!
07:19:11 <Raynes> Because it's happy.
07:19:15 <eevar2> ok, guess that makes sense. thanks
07:25:47 <Axman6> hmm, i thought unboxed arrays were supposed to be efficient
07:29:06 <Saizan_> they aren't?
07:29:54 <Axman6> well, not in my program. emulation some C, using a UArray Int Float, and it's quite a list slower than using either lists or C
07:30:03 <Axman6> more than twice as slow
07:30:43 <Saizan_> ah, an immutable one
07:31:07 <Saizan_> insertion is O(n) for those
07:31:09 * Axman6 is still amazed at the speed of his OpenCL version. it does more work than any other implementation, and it's almost an order of magnitude faster
07:31:14 <Axman6> ah, isee
07:31:20 <Axman6> hmm
07:31:35 <Axman6> so creating a large UArray using listArray would be quite slow then
07:31:57 <Saizan_> no, that should be fine
07:32:07 <fr0ggler> sorry lilac, Axman6 - did you manage to have a quick look at my paste earlier (don't worry if not)?
07:32:10 <Saizan_> since it builds it up in one go
07:32:45 <Axman6> yeah
07:38:22 <Axman6> Saizan_: heh, ok, turing off profiling make the Array version faster than the list one :)
07:38:34 <Axman6> made*
07:38:45 <Axman6> bleh, too late to be coding. time to sleep
07:42:56 <sleepynate> or move
07:42:57 <lambdabot> sleepynate: You have 1 new message. '/msg lambdabot @messages' to read it.
07:43:02 <sleepynate> then it would be early
07:51:37 <Axman6> so i'm learning a lot here, implementing the same algorithm in Haskell, C and OpenCL. probably the most important is that they all compute very close, but different results for the same inputs (OpenCL being the worst)
07:54:53 <HugoDaniel> lexical error in string/character literal (UTF-8 decoding error)
07:54:56 <HugoDaniel> what about this ? :)
07:55:07 <HugoDaniel> why can't i use UTF-8 characters in haskell ?
07:55:37 <kpreid> more likely your editor isn't writing utf-8
07:55:41 <HugoDaniel> (map toUpper s) == "CIÊNCIAS" ... outputs this error
07:56:23 <kpreid> the message implies that your compiler IS attempting to decode utf-8. Therefore I conclude that your source file is not in utf-8.
07:56:23 <doserj> in a source file, or on the ghci prompt?
07:58:57 <HugoDaniel> :P
07:59:02 <HugoDaniel> it is outputing utf-8
07:59:04 <HugoDaniel> i just checked
08:00:35 <HugoDaniel> oh oops
08:00:37 <HugoDaniel> not it didnt
08:00:43 <HugoDaniel> it was generating some ansi stuff
08:00:43 <HugoDaniel> ok
08:00:44 <HugoDaniel> thanks
08:08:29 <gimbo> Hi all. Could someone possibly help with a question about exception handling, and Data.Binary?
08:08:35 <lilac> fr0ggler: i guess you want 'case unpickleTree' pa . toNamespaced $ toQualified tree of ...' not 'case unpickleTree' Nothing pa of...'
08:08:58 <lilac> fr0ggler: also, would you mind using hpaste.org rather than pastebin? the adverts make me want to kill someone ;-)
08:10:02 <fr0ggler> lilac, ah right - i'll try that (sure I can switch pasters - i haven't got any preference) :)
08:14:54 <int-e> gimbo: it's best to just ask the question. it avoids clutter and a needless round-trip.
08:15:34 <fr0ggler> lilac - what would be the Right in your suggestion?
08:15:48 <fr0ggler> (im still trying to get my head around the Either stuff)
08:16:58 <fr0ggler> curse my imperative upbringing ;)
08:18:09 <gimbo> ok - thanks. well the short version is, how do I catch an exception raised by Data.Binary.Get?
08:18:16 <gimbo> the long version is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9658#a9658
08:18:45 <gimbo> there, I'd expect the function getFooCatchAll to catch any exception raised by (runGet getFoo), but it doesn't seem to
08:19:21 <gimbo> so i'd love to know a) why it doesn't, and b) how to actually catch exceptions caused by fail'ing in the Get monad
08:19:25 <gimbo> that's it - thanks :-)
08:20:26 <gimbo> (oops, just spotted that the 4 in getFoo should be 3 - a minor detail, but potentially confusing)
08:21:05 <Saizan_> gimbo: it doesn't work because the result of (runGet getFoo) bs is not evaluated under the scope of try, because of laziness
08:21:12 <gimbo> aha
08:21:27 <Saizan_> if you use $! instead of $ it should work
08:21:42 <gimbo> it does work
08:21:43 <gimbo> genius
08:21:49 <gimbo> many thanks! :-)
08:21:56 <Saizan_> np :)
08:23:29 <Berengal> fail is fail
08:23:41 <gimbo> does anyone happen to know the correct specific exception type to catch here?
08:28:29 <lilac> fr0ggler: it depends. if you're wanting to produce an IO (Either String a) as per the paste, you don't want a 'case' at all.
08:29:01 <gimbo> to answer my own question: it appears to be ErrorCall, of course
08:39:50 <pozic> What is a more idiomatic way to write this? http://paste.debian.net/47170/
08:40:35 <pozic> What I would like to express is just to find all files with find and then execute some code for all those files, but I don't want to resort to using two files for the script.
08:40:57 <HugoDaniel> hi
08:41:27 <vegai> pozic: xargs?
08:41:36 <gwern> pozic: you know the -exec option?
08:42:57 <pozic> gwern: yes, but that can only refer to an external script name, no?
08:43:14 <gwern> an external executable, you mean
08:43:16 <pozic> vegai: that can only refer to an external script name, AFAIK.
08:43:16 <gwern> /bin/sh, eg
08:43:19 <pozic> gwern: yes, same thing.
08:43:32 <gwern> /bin/sh -c...
08:43:46 <pozic> gwern: what do you mean?
08:43:55 <pozic> gwern: oh, I see
08:43:59 <lilac> gwern: i'd use [ or [[ rather than 'test'
08:44:05 <gwern> find stuff -exec /bin/sh doStuff {} \;;
08:44:32 <vegai> for a in `find stuff`; do stuff; done
08:45:08 <vegai> fails happily if there are spaces, perhaps
08:45:36 <pozic> It's not for something important. Thanks for the sh idea.
08:46:17 <lilac> pozic: head -qn 1 * 2>/dev/null | grep '^/'
08:47:59 <lilac> ... | grep -a '^/' if the files might not all be text
08:48:25 <pozic> It seems the default is already q.
08:48:43 <pozic> At least, with my version I never see it print these headers.
08:50:04 <lilac> pozic: the default is q if there's only one file afaics
08:51:45 <pozic> lilac: but then your script doesn't do the same.
08:52:04 <lilac> pozic: in what way?
08:53:19 <pozic> lilac: the idea is that it shows the file names that match. Yours just show the contents.
08:55:45 <lilac> pozic: ah, good point :)
08:59:09 <pozic> shows*
09:01:20 <fr0ggler> lilac, thanks for your help today - still not got it working, but hey, maybe I'll have more luck tomorrow ;)
09:20:28 <ToRA> > read "Always" :: StdGen
09:20:29 <lambdabot>   29837 1
09:20:31 <ToRA> > read "AlwaysS" :: StdGen
09:20:31 <lambdabot>   * Exception: Prelude.read: no parse
09:20:33 <ToRA> :(
09:21:05 <ToRA> doesn't seem to fulfil the contract of "guarantees to succeed on any string"
09:24:37 <mmorrow> > read (cycle "a") :: StdGen
09:24:38 <lambdabot>   * Exception: Prelude.read: no parse
09:24:56 <mmorrow> > read (cycle "Always") :: StdGen
09:24:57 <lambdabot>   * Exception: Prelude.read: no parse
09:26:05 <ToRA> mmorrow: from a glance at the source via haddock, there's a magic 6 in the source code for read in random
09:26:35 <mmorrow> > read "abcdef"
09:26:38 <lambdabot>   * Exception: Prelude.read: no parse
09:26:38 <mmorrow> > read "abcdef" :: StdGen
09:26:39 <lambdabot>   36217 1
09:26:42 <mmorrow> > read "abcde" :: StdGen
09:26:43 <lambdabot>   12039 1
09:26:47 <mmorrow> > read "abcdefg" :: StdGen
09:26:48 <lambdabot>   * Exception: Prelude.read: no parse
09:26:55 <mmorrow> ah
09:27:41 <ToRA> > reads "abcdefgh" :: [(StdGen, String)]
09:27:41 <lambdabot>   [(36217 1,"gh")]
09:27:42 <mmorrow> > 26^6
09:27:43 <lambdabot>   308915776
09:27:58 <mmorrow> > maxBound :: Word
09:27:59 <lambdabot>   18446744073709551615
09:28:12 <danr> > maxBound :: Int
09:28:13 <lambdabot>   9223372036854775807
09:28:25 <danr> 64-bit machine?
09:28:30 <mmorrow> yeah
09:28:34 <danr> aye
09:28:34 <ray> > 2^63
09:28:35 <lambdabot>   9223372036854775808
09:28:49 <danr> > it - 1
09:28:49 <lambdabot>   Not in scope: `it'
09:29:04 <mmorrow> @let it = text "Segmentation fault"
09:29:05 <lambdabot>  Defined.
09:29:11 <mmorrow> > it
09:29:11 <danr> haha
09:29:12 <lambdabot>   Segmentation fault
09:29:15 <mmorrow> :)
09:29:20 <danr> ^_^
09:29:29 <danr> > it - 1
09:29:29 <lambdabot>   No instance for (GHC.Num.Num Text.PrettyPrint.HughesPJ.Doc)
09:29:29 <lambdabot>    arising from...
09:29:39 <c_wraith> > reverse it
09:29:40 <lambdabot>   Couldn't match expected type `[a]'
09:29:40 <lambdabot>         against inferred type `Text.Pret...
09:29:49 <c_wraith> oh, it's text
09:29:58 <mmorrow> > (text . reverse . render) it
09:29:59 <lambdabot>   tluaf noitatnemgeS
09:30:02 <c_wraith> I need to learn more about those.  sometime.
09:35:47 <mmorrow> , foldr (.) id (replicate (braces . parens . brackets)) (int 8)
09:35:49 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
09:36:04 <mmorrow> , foldr (.) id (replicate 10 (braces . parens . brackets)) (int 8)
09:36:05 <lunabot>  {([{([{([{([{([{([{([{([{([{([8])}])}])}])}])}])}])}])}])}])}
09:36:26 <jfredett> > render it
09:36:27 <lambdabot>   "Segmentation fault"
09:36:36 <jfredett> oh. :/
09:36:44 <danr> =\
09:36:57 <trez> boo
09:38:20 <saml> is do block purely syntactic purpose?
09:38:41 <edwardk> saml: yes it is purely sugar
09:39:14 <edwardk> @undo \f -> do x <- get; put (f x)
09:39:14 <lambdabot> \ f -> get >>= \ x -> put (f x)
09:40:12 <Jafet> @do \f -> get >>= \x -> put (f x)
09:40:12 <lambdabot> \ f -> do { x <- get; put (f x)}
09:40:41 <saml> just like polymorphic calls are purely syntactic purpose.  obj.func()  ==> for (type in obj.type.hierarchy) { if (obj.type == type) { type.getMethod("func").call(); } }
09:41:16 <mornfall> saml: That's not context-free translation.
09:41:45 <saml> mornfall, ah ha
09:42:28 <saml> i guess the better analogy would be pattern matching for i think it's matched in runtime with context
09:42:32 <Jafet> "semantic sugar"
09:51:43 <edwardk> @seen dons
09:51:43 <lambdabot> Unknown command, try @list
09:51:56 <edwardk> ?
09:52:08 <saml> @saw dons
09:52:08 <lambdabot> Maybe you meant: faq map show slap src yow
09:52:30 <edwardk> did a module get dropped or am i going crazy?
09:53:36 <trzkril> !seen dons
09:53:44 <trzkril> hm
09:54:17 <lilac> edwardk: yep. it was thought to be causing problems, i heard
09:54:22 <lilac> i think the url module is gone too
09:54:31 <edwardk> ah
09:54:40 <edwardk> that is going to be a tough habit to break =)
09:54:57 <lilac> preflex_: seen dons
09:54:57 <preflex_>  dons was last seen on #haskell 11 hours, 45 minutes and 51 seconds ago, saying: yep
09:55:05 <saml> dons is a ninja. she can't be seen
09:55:09 <BMeph> "preflex" still works, tough. :)
09:55:18 <BMeph> *though
09:55:28 <edwardk> that should help some =)
09:57:21 <gwern> saml: dons be a he :)
09:58:21 <gwern> (come to think of it, is there even a female name starting with 'don'?)
09:58:43 <mornfall> saml: Pattern matching is runtime, but most of the syntax is just sugar for "case ... of" : - )
09:58:48 <shepheb> gwern: Donna
09:58:59 <mornfall> Of course you have to do *something* at runtime, right? ;)
09:59:00 <gwern> shepheb: ah, good one
10:01:54 <defun> I am in CS class right now. Any idea why all the freshmen CS courses use Java? Haskell would be /ideal/ for teaching! What universities are teaching to freshen CS students is backwards!
10:02:19 <defun> Yes, I hate java with a passion.
10:02:27 <Jafet> Berkeley uses scheme.
10:02:30 <Berengal> defun++
10:02:34 <shepheb> my school switched to Scheme a few years ago (and a few years after I started :( ) and it's been an improvement for sure
10:02:36 <Jafet> MIT, irony of all ironies, uses Java.
10:02:37 <monochrom> Grow out of hating languages with a passion.
10:02:38 <trzkril> defun: popularity in the industry, i believe
10:02:55 <mornfall> defun: We teach Haskell to freshmen. Unfortunately, it still sucks.
10:03:07 <mornfall> I am starting to suspect the problem is in the freshmen not in the language. : - P
10:03:17 <defun> mornfall: hmm...
10:03:28 <Jafet> Half your freshmen would leave if you used Haskell. Whether or not you consider that a bad thing is another matter
10:03:42 <Berengal> I like to think I've grown past languages, seeing them only as tools for getting my thoughts into a computer, but Java is still a pretty bad tool...
10:03:49 <defun> Jafet: those who leave shouldn't be studies CS.
10:04:03 <Jafet> CS = Coding skills
10:04:04 <shepheb> it could be bad for Haskell. I'd rather be forced to write bad code in something that I wouldn't miss when I learn to dislike it.
10:04:07 <Jafet> Amirite?
10:04:23 <Berengal> Jafet, you misspelled skillz
10:04:35 <defun> mornfall: where do you teach?
10:04:42 <Jafet> Oops
10:04:49 <mornfall> Masaryk University, Brno
10:04:56 <mornfall> I don't teach anymore... it grows on you.
10:05:07 <mornfall> Maybe I'll start again. Hard to tell.
10:05:22 <sleepynate> funny, we teach the freshman word :P
10:05:26 <shepheb> mornfall: you mean it grows unbearable? or it grows more enjoyable?
10:05:59 <mornfall> shepheb: More of the former than of the latter. At least as far as introductory courses go.
10:05:59 <defun> Berengal: I used to feel the same way (i.e. languages are only tools), but Java drives me nuts, who ever designed the language deserves to shot, and stabbed in the eye!
10:06:11 <Jafet> Languages are not tools.
10:06:18 <Jafet> Without language there is no thought.
10:06:21 <defun> Jafet: I see that now.
10:06:34 <mornfall> Jafet: Depends if you are a journalist or a poet. ;)
10:06:35 <defun> Jafet: agree
10:06:37 <Jafet> Graham might be a tool, but his thoughts on Blub deserve mention
10:06:46 <sleepynate> Jafet: oic what u did thar :P
10:06:52 <ray> lisp is blub
10:06:55 <defun> Jafet: Graham?
10:07:14 <ray> the blub paradox describes paul graham's mentality perfectly
10:07:14 <defun> Paul Graham?
10:07:29 <ray> which just makes him a typical lisper :)
10:07:31 <Jafet> Paul Graham, lisp hacking millionaire rockstar
10:07:34 <Raynes> Graham cracker.
10:07:37 <shepheb> my roommate is a masterful Blub programmer.
10:07:38 <defun> Heard of him from a friend.
10:08:03 <defun> My freinds room mate talks of him like a god.
10:08:08 <ray> he writes essays that are pretty hit or miss
10:08:11 <shepheb> "I've never wanted a function pointer." and then I write a hash of CGI program modes to subs for those modes and he is enlightened.
10:08:22 <Jafet> defun, don't worry; it's a phase they grow out of.
10:08:47 <defun> Jafet: I hope so.
10:09:08 <ray> i think he hits the most when he talks about society, and less when he talks about programmering stuff
10:09:23 <ray> (programmering is the act of being a programmer)
10:09:24 <Jafet> He thinks the Bay Area is society
10:09:33 <Jafet> That's pretty miss to me
10:10:00 <defun> Jafet: Never been to Bay Area. What's it like?
10:10:42 <Jafet> Google.
10:11:09 <defun> ok
10:12:16 <ray> plus, he's a blub programmer
10:12:54 <ray> i think haskellers are better at avoiding that, judging by the amount of bitching about haskell that goes on here
10:13:35 <Jafet> Lisp is a nice language, for a very simple reason. They've put fifty years of work into it.
10:14:11 <defun> java is an abomination. How the hell did it become an industry standard. Haskell's still annoying, but it's much less annoying than java.
10:14:17 <Jafet> Lisp hackers know Lisp probably more than any programmer group of language X knows X.
10:14:30 <sleepynate> heh
10:14:35 <sleepynate> what is there to know? :)
10:14:47 <sleepynate> car, cdr, and ftw.
10:14:56 <Jafet> How to get anything done at all, for one thing
10:14:58 <ray> PROGN PROGN PROGN
10:14:59 <Berengal> Jafet, Sapir-Worf might be correct, but thought is still the sum of all languages known, not just the one you happen to be using right now
10:14:59 <sleepynate> hahaha
10:15:00 <ray> god
10:15:07 <ray> i still have nightmares in lisp
10:15:21 <Jafet> Berengal, yes, but try writing a text filter in Befunge.
10:15:21 <defun> ray: lol
10:15:48 <|Steve|> I'm more of a brainfuck man, myself.
10:16:18 <Jafet> (Befunge is fun. You can get a visual layout of the filters, like a dataflow diagram.)
10:17:00 <Berengal> Jafet, luckily I don't think in befunge... anyway, befunge is a bad tool. Java is a better tool, and Haskell is even better still
10:17:52 <|Steve|> I assume you're not going by number of users.
10:18:16 <Berengal> Since when has the number of users been a good measure of anything?
10:18:31 <Jafet> Since Turbo Pascal.
10:18:47 <Jafet> Well, since Windows, really.
10:19:02 <|Steve|> Since the hammer.
10:19:25 <Berengal> Number of users has far too much lag, especially in the computer world...
10:19:37 <Jafet> Tell that to Mark Zuckerberg
10:19:51 <|Steve|> Haskell is 5 years older than Java.
10:20:32 <Berengal> |Steve|, java is basically a shaved C++ in suit and tie
10:20:39 * lilac ponders whether people who use too many flowcharts think in befunge
10:20:56 <Jafet> C++ is like Klingon
10:21:07 <|Steve|> That was one of its selling points to universities as I understand it.
10:21:14 <dv-_> *** glibc detected *** ./blah4: corrupted double-linked list: 0x000000000264de20 ***
10:21:17 <dv-_> D:
10:21:19 <Jafet> Berengal, except it isn't
10:21:32 <lilac> Berengal: java is precisely the amount of c++ you can teach to chimpanzees before they start flingin' shit about
10:21:38 <|Steve|> heh
10:22:06 <Alpounet> Jafet, in which sense ?
10:22:24 <sinelaw> it's "which language is worse" day again?
10:22:30 <sinelaw> *its
10:22:31 <Alpounet> Klingon is very classy and might be somehow powerful, in some way, but hard to understand, in another way.  Is that what you meant ?
10:22:58 <Berengal> sinelaw, every day is language war day
10:23:02 <|Steve|> sinelaw: It is very easy to derail #haskell.
10:23:04 <c_wraith> I think it was a reference to the "klingon programming languages" joke.
10:23:10 <Jafet> You do *not* argue with someone who speaks better Klingon.
10:23:14 <sinelaw> @type fix
10:23:15 <lambdabot> forall a. (a -> a) -> a
10:23:17 <lilac> Jafet: because Klingon has a thousand ways to swear at the way you shot yourself in the foot, and yet somehow it has more speakers than a 'well-designed' language like Esperanto?
10:23:18 <|Steve|> ha
10:23:24 <Jafet> And there is always someone who speaks better Klingon.
10:23:25 <sinelaw> @src fix
10:23:25 <lambdabot> fix f = let x = f x in x
10:23:49 <sinelaw> how does that magic work
10:23:54 <sinelaw> built in?
10:24:02 <c_wraith> No.  It's just lazy
10:24:03 <|Steve|> petaQ
10:24:07 <c_wraith> > fix (0:)
10:24:08 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:24:17 <sinelaw> yeah but
10:24:52 <c_wraith> > let q f = let x = f x in x in q (0:)
10:24:53 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:24:59 <RayNbow> > let myfix f = x where x = f x     in   myfix (1:)
10:24:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:25:00 <lilac> > unwords . reverse . words $ "fix f = fix where fix = f fix"
10:25:00 <mmorrow> , vacuum (fix (0:))
10:25:01 <lambdabot>   "fix f = fix where fix = f fix"
10:25:03 <lunabot>  [(0,[1,0]),(1,[])]
10:25:15 <pikhq> It evaluates exactly as much as is asked for. No more, no less.
10:25:26 <pikhq> Welcome to lazy evaluation.
10:25:27 <pikhq> :)
10:25:36 <mmorrow> void *xs[2]; xs[0] = (void*)0; xs[1] = (void*)xs;
10:25:46 <defun> is there any data about the size of the haskell community from 1998-present. I'd like to see how much the community grew over the years as a result of RWH, GHC improvements, Industry success stories, etc.
10:26:07 <lilac> defun: you could maybe try parsing logs of #haskell
10:26:18 <Jafet> Haskell and Industry in adjacent sentences?
10:26:20 <sinelaw> > fix \fac, n. if (n<1) then 1 else fac (n-1)
10:26:20 <Berengal> defun, there are some stats for #haskell I believe
10:26:21 <lambdabot>   <no location info>: parse error on input `\'
10:26:24 <defun> lilac: sounds like a fun project
10:26:38 <pikhq> sinelaw: Not quite right.
10:26:53 <sinelaw> i'm still learning the syntax
10:26:55 <defun> Berebgal: will call upon the almighty google after class.
10:26:59 <lilac> > fix (\fac n -> if n < 1 then 1 else fac (n - 1)) 5
10:27:00 <lambdabot>   1
10:27:01 <pikhq> > fix (\fac n -> if n<1 then 1 else fac (n-1)) $ 2
10:27:02 <lambdabot>   1
10:27:08 <lilac> > fix (\fac n -> if n < 1 then 1 else n * fac (n - 1)) 5
10:27:09 <lambdabot>   120
10:27:13 <mmorrow> , fix (\fib !m !n -> m : fib n (m+n)) 0 1
10:27:14 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
10:27:14 <sinelaw> > fix (\fac, n -> if (n<1) then 1 else fac (n-1))
10:27:15 <lambdabot>   <no location info>: parse error on input `,'
10:27:22 <sinelaw> > fix (\fac n -> if (n<1) then 1 else fac (n-1))
10:27:22 <lambdabot>   {-3->1;-2->1;-1->1;0->1;1->1;2->1;3->1}
10:27:32 <lilac> > (product . enumFromTo 1) 5
10:27:32 <lambdabot>   120
10:27:55 <pikhq> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
10:27:56 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:27:59 <sinelaw> > fix (\fac n -> if (n<1) then 1 else  n*fac (n-1))
10:27:59 <lambdabot>   {-3->1;-2->1;-1->1;0->1;1->1;2->2;3->6}
10:28:06 <c_wraith> sinelaw: fix is best used with functions that are non-strict in their argument.  That is, they produce some of their output before looking at their argument.
10:28:08 <lilac> > product . enumFromTo 1
10:28:09 <mmorrow> , levels (fix (\me -> Node () [me,me]))
10:28:09 <lambdabot>   {-3->1;-2->1;-1->1;0->1;1->1;2->2;3->6}
10:28:10 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
10:28:27 <sinelaw> but how is it implemented
10:28:33 <sinelaw> how does it find the fixed point
10:28:34 <pikhq> @src fix
10:28:34 <lambdabot> fix f = let x = f x in x
10:28:40 <pikhq> That's how it's implemented.
10:28:47 <sinelaw> and how is THAT implemented
10:28:47 <Berengal> > let x = 1:x in x
10:28:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:28:52 <pikhq> Just like that.
10:28:55 <c_wraith> It's implemented by being lazy.
10:29:06 <mmorrow> sinelaw: void *xs[2]; xs[0] = (void*)0; xs[1] = (void*)xs;
10:29:07 <c_wraith> > fix (1+)
10:29:11 <lambdabot>   mueval-core: Time limit exceeded
10:29:18 <mmorrow> , vacuum (fix (0:))
10:29:20 <lunabot>  [(0,[1,0]),(1,[])]
10:29:22 <c_wraith> Addition is strict in its argument.
10:29:38 <defun> :t (fmap.fmap.fmap)
10:29:39 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
10:29:42 <c_wraith> the fixed point of that function is "calculate forever"
10:29:47 <defun> my favourite type.
10:29:54 <Jafet> > fix fix
10:29:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
10:30:10 <sinelaw> mmorrow, didn't get your point
10:30:46 <c_wraith> Some functions, though, can produce part of their output without evaluating their input.
10:30:52 <Berengal> @type fmap ((fmap fmap) fmap) fmap
10:30:53 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
10:30:58 <c_wraith> > fix ("Hello, world!  " ++)
10:30:58 <lambdabot>   "Hello, world!  Hello, world!  Hello, world!  Hello, world!  Hello, world! ...
10:31:06 <defun> You can tell haskell is really getting to you, when you decide that you have a favorite type signature and start asking fellow haskellers what their favorite type signature is.
10:31:19 <pikhq> defun: Indeed.
10:31:20 <mmorrow> sinelaw: "fix (0:)" creates two heap cells, one being an (I# 0# :: Int) and the other being a list cell where the head is a ptr to that Int, and the tail is a pointer to *itself*
10:31:34 <mmorrow> so its representation is finite
10:31:42 <Berengal> defun, I'd have to say (a -> b) -> [a] -> [b]
10:31:50 <sinelaw> mmorrow, no i meant how fix itself is implemented
10:32:08 <Jafet> Implemented by what?
10:32:09 <cygnus> defun: I knew Haskell was getting to me when I started writing type signatures in comments in other languages.
10:32:13 <c_wraith> sinelaw, your question doesn't make any sense.
10:32:15 <sinelaw> by ghc
10:32:17 <c_wraith> You've seen the source.
10:32:22 <defun> cygnus: lol
10:32:22 <c_wraith> There's nothing special about it.
10:32:31 <c_wraith> It's just another function.
10:32:32 <Jafet> Well, ghc translates the code for fix and applies it to the arguments.
10:32:34 <defun> Berengal: the type of map?
10:32:35 <Berengal> cygnus, I do that too...
10:32:37 <mmorrow> sinelaw: by allocating empty memory, then allowing the code that fills that memory to possible insert a ptr to that memory itself therein
10:33:00 <Berengal> defun, yup. My favorite haskell expression is fibs = 0:1:zipWith (+) fibs (tail fibs)
10:33:01 <mmorrow> (for the value-recursion case)
10:33:12 <defun> map and fmap are great for recursiveness.
10:33:43 <defun> > fibs 0:1:zipWith (+) fibs (tail fibs)
10:33:43 <lambdabot>   Not in scope: `fibs'Not in scope: `fibs'Not in scope: `fibs'
10:33:48 <defun> bah!
10:34:12 <Berengal> map: higher-order function, fibs: corecursive
10:34:21 <defun> if only my station in CS lab had ghci
10:34:22 <c_wraith> I prefer fibs = fix $ (0:) . scanl (+) 1
10:34:33 <mmorrow> sinelaw: consider "let x = (x,y); y = (y,x) in x" (ignoring that this wouldn't typecheck).
10:34:41 <Jafet> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
10:34:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:34:48 <Berengal> c_wraith, too compliacted. Not something you can show other people
10:35:07 <Berengal> Does have (.) though...
10:35:14 <c_wraith> The derivation of it is simple, though.
10:35:22 <pikhq> sinelaw: I'm going to guess you're from Perl, where there's magic.
10:35:25 <mmorrow> sinelaw: void *x[2]; void *y[2]; x[0] = x; x[1] = y; y[0] = y; y[1] = x; return x
10:35:32 <sinelaw> pikhq, nope i'm "from
10:35:41 <c_wraith> > let fibs = 0:scanl (+) 1 fibs in fibs
10:35:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:35:46 <sinelaw> reading "the implementation of functional programming languages"
10:35:49 <pikhq> In Haskell, there exists the following bits of magic: unsafePerformIO, unsafeCoerce.
10:36:03 <pikhq> And arguably IO itself.
10:36:03 <c_wraith> All you're doing is replacing the explicit recursion with fix.
10:36:09 <sinelaw> where fix is implemented as a specific (ingenius) Lambda expression
10:36:46 <Jafet> Why are there two haskell bots, anyway?
10:37:10 <Zao> Because they go tits up occasionally?
10:37:18 <Jafet> > (.)(.)
10:37:19 <lambdabot>   {{()->{()->()}}->{()->{{()->()}->{()->()}}}}
10:37:19 <pikhq> The lambda expression in question is complex because it's doing this in a strict language. In a lazy language, all you need to do is pass the result of the function to the function infinitely, and viola.
10:37:34 <Jafet> Damn, that's valid?
10:37:38 <c_wraith> lunabot supports TH
10:37:45 <pikhq> Jafet: Why wouldn't it be?
10:37:48 <c_wraith> :t (.)(.)
10:37:49 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
10:37:59 <pikhq> That's the same as ((.).)
10:38:04 <defun> The tit combinator!
10:38:21 <mmorrow> yeah, lunabot does TH and has some imports lambdabot doesn't, and lunabot only does eval
10:38:25 <Berengal> @type (.).(.)
10:38:26 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:39:22 <defun> Does anyone here have a favourite monad?
10:39:30 <mmorrow> lunabot has eval too
10:39:50 <ray> i have a favorite data structure
10:39:53 <c_wraith> Is there an A* monad?  That could be fun.
10:39:58 <defun> ray: yes?
10:40:01 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
10:40:03 <lunabot>  42
10:40:06 <ray> the zippper
10:40:14 <sinelaw> in what module is fix defined?
10:40:15 <defun> I knew you were going to say that.
10:40:15 <ray> free monad is my favorite monad
10:40:16 <c_wraith> I've seen code that does something kind of like A* in a monad that acts like the list monad.
10:40:20 <ray> you get it for free ;0
10:40:25 <ray> :) even
10:40:33 <ray> Data.Function.fix
10:40:48 <c_wraith> I figure it should be possible to create an A* monad.
10:41:56 <maltem> Oops - I wrote, instance Applicative ReadP where pure = return; (<*>) = liftA2 -- and I wondered why the program blew away, heh
10:42:14 <Berengal> defun, History of Haskell has stats for the community
10:42:37 <defun> I decided that I can do without do-notation, and make do with >> and >>= and custom combinators. But I can't live without arrow-notation. Anyone codes in raw arrow combinators is a lunatic.
10:42:42 <defun> Berengal: thanks!
10:43:04 <defun> class is over. thanks, guys.
10:43:12 <Berengal> defun, also, it's released April 16 2007, and says "At the time of writing, there are about 200 people logged into #haskell"
10:43:15 <Berengal> ...
10:43:20 * Berengal shrugs
10:45:47 <ray> arrow notation?!!!?!??!?!?!?!?!???!??!?!?!?!???!
10:46:35 <sm> morning.. how do you import a record data type, and one of the field accessors, without duplicate import ? eg something like import Network.URI (URI{uriScheme}) ?
10:48:17 <sm> import Network.URI (URI(..),uriScheme) gives a warning and import Network.URI (URI(..)) doesn't make uriScheme explicit
10:48:57 <tommd> sm: Don't you just want "import Network.URI (URI, uriScheme)"
10:49:55 <sm> hmm.. with that I get "Not in scope: data constructor `URI'".. but maybe
10:50:04 <tommd> Oh, you want the constructor?
10:50:16 <tommd> sm: Then something like "import Network.URI (URI (URI), uriScheme)"
10:50:34 <tommd> sm: I'm not sure why it gives warning when importing all the constructors - what warning and what compiler?
10:50:51 <sm> exactly right..  I wanted (URI(URI),uriScheme,parseURI). Thank you tommd
10:51:09 <sm> this is ghc with -Wall
10:56:43 <HugoDaniel> hi
10:56:54 <HugoDaniel> how do i catch the "no parse" exception thrown by read ?
10:57:05 <HugoDaniel> what exception predicate should i use ?
10:57:26 <c_wraith> HugoDaniel:  It's easier to use reads
10:57:29 <c_wraith> :t reads
10:57:30 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:58:00 <c_wraith> > (reads "123") :: [(Int, String)]
10:58:01 <lambdabot>   [(123,"")]
10:58:12 <gjl> Please excuse me for trying to get clarification on something that probably should be obvious, but must all binaries compiled with GHC be released under the BSD license? Therefore, even if one intends to release the source under the GPL, for instance, the binaries must be released under the BSD license?
10:58:16 <c_wraith> > (reads "abc") :: [(Int, String)]
10:58:17 <lambdabot>   []
10:58:20 <HugoDaniel> > (reads "asdf") :: [(Int, String)]
10:58:20 <lambdabot>   []
10:58:32 <HugoDaniel> nice
10:58:39 <HugoDaniel> > (reads "") :: [(Int, String)]
10:58:40 <lambdabot>   []
10:58:47 <HugoDaniel> thanks :D
10:58:47 * leimy_ is watching the GHC video
10:58:50 <leimy_> with SPJ
10:59:03 <HugoDaniel> leimy_: i liked it :)
10:59:08 <leimy_> yeah
10:59:09 <HugoDaniel> supercompilation :D
10:59:12 <leimy_> especially the debate on shared libraries
10:59:29 <lilac> gjl: as far as i'm aware there is no clause in ghc's license which requires you to license binaries in any particular way
10:59:32 <leimy_> I typically hate shared libraries, and find them to greatly complicate a few issues around software
10:59:49 <leimy_> They're there to solve a mostly economical problem.
10:59:59 <leimy_> which should solve itself through cheaper technology :-)
11:00:05 <HugoDaniel> well
11:00:20 <leimy_> I mean I can get a single drive with 2TB of storage now
11:00:20 <HugoDaniel> you get a much lower memory footprint by using them, if they are very common
11:00:21 <jfoutz> gjl: you can always steal bsd and turn it into gpl. or sell it. bsd is the cool license.
11:00:23 <lilac> gjl: i think the GHC runtime is BSD licensed, but the BSD license (unlike the GPL) is not viral, so that doesn't mean that your binary has to be BSD licensed.
11:00:29 <HugoDaniel> since they are "shared" by all running programs
11:00:29 <leimy_> HugoDaniel: Only if all things work out :-)
11:00:47 <lilac> gjl: it would be a really weird license that required other code to be BSD licensed :)
11:00:57 <msteele_> leimy_: Saving hard drive space is not the point.
11:01:04 <leimy_> msteele_: it "used to be" :-)
11:01:58 <gjl> Thanks. There was something I read that confused me a little...let me see if I can dig it up.
11:01:59 <leimy_> I guess the trick is when distributing binaries, you end up nearly having to package the libraries with the binary anyway, so why not statically link it ? :-)
11:03:03 <lilac> gjl: the GHC license says "Redistribution and use in [...] binary form [...] [is] permitted provided that: [...] neither the name of the university [of glasgow] nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission"
11:03:20 <c_wraith> also..  My ultra-cheap netbook has a 250GB hard drive.  statically linking libraries isn't going to be significant hard drive space in the future.
11:03:39 <c_wraith> > (reads "123 abc") :: [(Int, String)]
11:03:39 <lambdabot>   [(123," abc")]
11:04:00 <c_wraith> > (reads "123 456") :: [(Int, String)]
11:04:01 <lambdabot>   [(123," 456")]
11:04:12 <jfoutz> wow. read is way cooler than i realized.
11:04:37 <leimy_> I think there's good arguments on both sides of the dynamic vs static linkage debate.
11:04:45 <lilac> gjl: some further reading indicates that the runtime is entirely BSD3 apart from libmp (used for Integer), which is LGPL'd.
11:05:01 <msteele_> The advantage of shared libraries is that memory is shared between executable while the software is running.
11:05:08 <Berengal> As of right now, I'm rather happy with static linking. Might change in the future...
11:05:18 <leimy_> msteele_: only if the two programs use the same libraries.
11:05:22 <leimy_> and same version :-)
11:05:26 <tommd> 4 days till HacPDX!
11:05:34 <msteele_> Of course.
11:05:55 <jfoutz> leimy_: i think the big win is RTS as a dynamic lib.
11:06:09 <leimy_> msteele_: and I suppose on servers, this is kind of important, where lots of stuff uses the same stuff, like HTTP, XML or whatever libs.
11:06:13 <Berengal> dynamic linking does get around the LGPL issue, to merge the two topics on hand
11:06:13 <c_wraith> I don't disagree with that at all, msteele_.  I'm just saying hard drive space probably isn't the issue to emphasize.
11:06:13 <leimy_> and of course the RTS!
11:06:26 <msteele_> c_wraith: I agree with that.
11:06:52 <Berengal> c_wraith, runtime memory consumption is a bigger bonus
11:06:53 <leimy_> Berengal: But a license restriction is rather a silly justification for a technical issue, despite the necessity put into place by the license to have such a mechanism.
11:07:21 <leimy_> I would really love to see some numbers on whether everything shared is that much better than everything static :-)
11:07:37 <leimy_> Some systems I've been on are done by people who absolutely refuse to do shared libs
11:07:41 <Berengal> Yeah, some stats would be nice
11:07:42 <leimy_> to err on the side of simplicity
11:07:53 <leimy_> also, that system tends to run programs as services
11:07:55 <Jafet> If you put all loaded code into hash tables, the runtime issue is moot
11:08:13 <leimy_> so programs talk to each other and share based on the fact that they're statically linked but are services of one another.
11:08:28 <leimy_> It's an even weaker bind than dynamic linking, because it's RPC based :-)
11:08:47 <leimy_> to me, that leads to a much more interesting system in terms of using cores, and even cloud computing
11:09:29 <leimy_> also, if everything speaks the same RPC language (like the filesystem semantics of 9p) you get plug-in capabilities from a service.
11:10:17 <leimy_> But I'm all twisted up on that topic because I've been writing distributed systems for about 2 years now.
11:10:28 <msteele_> The ability to write plugins are what I'm hoping comes out of shared library support in GHC.
11:10:30 <leimy_> Currently doing one with Erlang and Haskell :-)
11:10:56 <leimy_> msteele_: yeah in a more traditional sense of dynamic loading... that's still a nice way to go.
11:11:29 <mmorrow> static linking starts to become a pita when e.g. you have 10 binaries, each of which link to ghc ==> 10 * 30MB
11:11:47 <gjl> lilac: thanks for the information. What I read was that GHC produces GPL binaries on Windows and Mac OS but not Linux. So I assume the binaries will be BSD3 by default, but can be released under the GPL?
11:11:57 <leimy_> mmorrow: do you run them all at once?
11:12:03 <leimy_> or are you worried about the storage space?
11:12:07 <mmorrow> leimy_: they are on my harddrive all at once
11:12:11 <mmorrow> 300MB
11:12:12 <tehgeekmeister> if i want to shuffle items around in a list, how do i best go about that?  convert to Sequence and back to list?  or what?
11:12:15 <leimy_> right, well get ye a 2 TB drive :-)
11:12:28 <mmorrow> leimy_: that's not a valid solution imo
11:12:48 <leimy_> mmorrow: It's exactly the "solution" we've been offered since the beginning of computing
11:12:55 <leimy_> "don't worry about it, space is cheap or gets cheaper"
11:13:08 <leimy_> I look at old MS-DOS binaries, and then at anything on Mac OS X, and I cringe a little
11:13:10 <tommd> They said that about processing power
11:13:17 <mmorrow> also, with static linking, if *any* library changes, you need to recompile *every* binary that depends on it
11:13:18 <tommd> and now we're stuck with Python and Perl.
11:13:24 <leimy_> mmorrow: yep :-)
11:13:40 <mmorrow> leimy_: that doesn't scale
11:13:54 <mmorrow> leimy_: i think static linking definitely has its place, as does dynamic linking
11:13:55 <leimy_> mmorrow: Plan 9 works exactly that way :-)
11:14:00 <leimy_> I agree
11:14:10 <inimino> leimy_: but it's false, people will always want to do more with the same amount of computational resources
11:14:10 <mmorrow> leimy_: neither of which are a replacement for the other
11:14:20 <mmorrow> they're orthogonal
11:14:21 <leimy_> I feel that dynamic linking addresses one problem, and opens up several others :-)
11:14:34 <leimy_> just pick the problems you want to deal with.  I'll take "disk and RAM" space over DLL hell :-)
11:14:52 <trofi> readline haskell package does not fork on current gentoo amd64
11:14:54 <mmorrow> what is DLL hell?
11:14:59 <leimy_> Again, consider that I've been working in distributed systems
11:15:08 <trofi> s/fork/work
11:15:25 <leimy_> mmorrow: http://en.wikipedia.org/wiki/DLL_hell
11:15:38 <tehgeekmeister> i don't see why a well designed dynamic linking system should be such a problem.  not to say that's what we have, but a good one shouldn't be a pain at all.
11:15:51 <leimy_> mmorrow: it's a dependency hell of a running system. :-)
11:15:58 <mmorrow> leimy_: oh, that's just because windows is broken beyond all imagination
11:16:00 <leimy_> static libs give you a dependency hell of a build system :-)
11:16:07 <leimy_> mmorrow: it is not restricted to windows
11:16:09 <msteele_> mmorrow: In windows DLLs are identified only by name and a version number.  If two unrelated software packages happen to give their DLL the same name things break.  If two versions of the same DLL aren't 100% compatible things break.
11:16:16 <leimy_> it happens on every OS under the sun.
11:16:31 <trofi> leimy_: it's enforced by inherently broken development tools
11:16:39 <tehgeekmeister> I have run into times where i had to symlink libraries on linux systems because one program expected the library to have one name, and all the rest expected the name it had to start with
11:16:43 <trofi> (in windows)
11:16:46 <leimy_> DragonflyBSD tried to address it by making symlinks take an environment variable for part of a path
11:16:58 <leimy_> then you can have a symlink that means one thing in one environment and another thing in another environment
11:17:06 <lament> msteele_: in windows, DLL are identified by a whole bunch of things including a GUID. What are you talking about?
11:17:09 <gwns> is it possible to add a Show instance for Gen a?
11:17:16 <leimy_> Inferno deals with it by having a very mutable "/" or namespace, per process.
11:17:25 <leimy_> I don't think anyone has a perfect solution.
11:17:43 <trofi> linux has policy for stable ABI
11:17:56 <leimy_> trofi: does everyone play by those rules?
11:18:07 <trofi> kernel does pretty cool
11:18:11 <leimy_> yeah
11:18:14 <leimy_> I'll give em that :-)
11:18:15 <trofi> glibc not so well, but usable
11:18:30 <leimy_> I've got FreeBSD binaries from 4.x that run on 7.x :-)
11:18:34 <trofi> and most of popular C libraried too
11:18:37 <leimy_> they did a good job of that too :-)
11:18:52 <trofi> freebsd4 did not even support kernel threads
11:19:05 <leimy_> they didn't need to
11:19:10 <mmorrow> leimy_: basically, when you want to load code at runtime, either you have to write your own linker of non-dynamic object files (which will be inherently borked, since non-dynamic files aren't made to be dynamically linked), or you use dynamic object files
11:19:20 <mmorrow> ghci does the former
11:19:37 <mmorrow> and the workaraounds it needs to use because of this aren't pretty
11:19:39 <msteele_> lament: It's my understanding that while the latest .NET DLLs are identified by GUID, this isn't the way things worked with Win32 DLLs.  I'm checking up on this right now.
11:19:57 <leimy_> mmorrow: Yeah it'll be good for that.  I just don't want my binaries dynamically linked by default.
11:20:19 <lament> msteele_: oh. Correct. Before .NET, things were full of insanity.
11:20:33 <mmorrow> leimy_: well of course, choice is key
11:20:36 <leimy_> yep!
11:20:44 <lament> msteele_: but that's like, stone age!
11:20:53 <leimy_> I'm all for having the option to have shared libs... I just don't drink the shared library koolaid :-)
11:21:09 <leimy_> having experienced systems that take it to both extremes :-)
11:21:21 <leimy_> Inferno is interesting in that you never actually link anything really..
11:21:21 <trofi> i have broken readline in ghci!
11:21:31 <leimy_> modules are explicitly loaded via code in Limbo
11:21:34 <mmorrow> i think anyone that advocates using one way exclusively is borked
11:21:36 <leimy_> and happen at runtime.
11:21:59 <leimy_> Plan 9 has only static libs, because the system designers said "yeah, this is really hard to do really well, so we punted"
11:22:09 <trofi> like minix3
11:22:13 <leimy_> yet their linux emulator does do shared libs :-)
11:22:14 <mmorrow> leimy_: right, but the object code format has to be designed to enable that
11:22:21 <leimy_> but only for foreign ELF bins :-)
11:22:31 <mmorrow> there are four types of ELF .o files
11:22:37 <Berengal> Java actually does pretty well in this regard
11:22:39 <gwns> No instance for (Show (Gen [Integer])), how can this be fixed?
11:22:41 <mmorrow> CORE,EXEC,REL,DYN
11:22:43 <leimy_> mmorrow: right Inferno's modules are designed to be loaded dynamically :-)
11:23:20 <mmorrow> leimy_: well clearly :)
11:23:28 <leimy_> heh
11:23:46 <leimy_> what's neat about that is you can bind a path from a remote filesystem before loading the module if you want to :-)
11:23:57 <mmorrow> neat
11:24:02 <leimy_> yeah
11:24:38 <leimy_> and since Inferno runs things on a VM, and has portable binaries, you can have a linksys router run a very basic set of Inferno stuff, and then mount a real server to run more programs
11:25:10 <leimy_> nice for a dynamic embedded platform.
11:25:19 <leimy_> works on systems with no MMU etc.
11:26:34 <leimy_> even have it on my nintendo DS :-)
11:28:47 <leimy_> anyway, it's a really nice video and cool to see where GHC is going!
11:29:19 <Zao> leimy_: What, where?
11:29:28 <leimy_> http://www.vimeo.com/6570515
11:30:14 <RayNbow> Vimeo has one problem.. you can't open a page, wait a day... and then click on the play button :p
11:31:04 <wdonnelly> in what way can't you do that?
11:31:34 <RayNbow> well, the video won't play then since the generated mp4 link the flash player uses is no longer valid
11:32:00 <wdonnelly> ah, I didn't know that. I assumed you were saying it automatically started playing or something
11:32:52 <RayNbow> the URL of the videos have the following form: bitcast.vimeo.com/vimeo/v/###/###/#######.mp4?e=##########&h=something_that_resembles_a_hash
11:33:21 <RayNbow> the e= and h= parts vary time to time
11:33:48 <RayNbow> (but don't seem to be session/cookie/IP bound)
11:34:56 <monochrom> urls come and go.
11:36:29 <inimino> urls come and go / ... / this one is gone
11:36:39 <inimino> it's a 404 haiku
11:37:07 <lilac> inimino: only if 'urls' and 'gone' are somehow 2 syllables each
11:38:10 <inimino> lilac: or if the idea was to have 4, then 0, then 4 syllables ;)
11:38:38 <lilac> inimino: i totally didn't get what you did there :)
11:38:47 <monochrom> Just like Tcl is pronounced Takel, url can be pronounced urel.
11:39:28 <inimino> :)
11:39:39 <lilac> monochrom: Takel? tickle!
11:39:40 <copumpkin> I pronounce tcl as tickle
11:39:43 * cygnus nods
11:39:46 <roconnor> Isn't Tcl, pronounced tickle?
11:39:51 * copumpkin tickles monoidal
11:39:54 <copumpkin> *monochrom
11:39:57 <lilac> and Tcl/Tk is pronounced 'tickle-tack'
11:40:20 <roconnor> I say tickle-Tee-Kay
11:40:41 <Berengal> I'm reading this SCJP book... "A method is a category of objects." True of false?
11:41:02 * monochrom is amazed at the Western world's ability to imagine up vowels were there is none. sql = sequel? In the East we just say es queue ell.
11:41:11 <copumpkin> roconnor: do you think your fewdigits approach would make a good general-purpose real number from the point of view of a theorem prover, or did you tailor it to the specific tasks you needed for your thesis work?
11:41:38 <capisce> monochrom: how do you pronounce Qt?
11:41:42 <sleepynate> Berengal: seriously?
11:41:44 <monochrom> queue tee
11:41:48 <roconnor> copumpkin: my thesis task is a general-purpose real number from the point of view of a theorem prover
11:41:49 <c_wraith> monochrom, you're wasting valuable syllables in every conversation that way!  ;)
11:41:56 <capisce> the official pronouncation is 'cute' :)
11:42:06 <sleepynate> capisce: yea, i say it like "kywet"
11:42:06 <Berengal> sleepynate, seriously... though I doubt they mean CT. I don't think they've even defined category
11:42:08 <copumpkin> roconnor: ooh, ok :)
11:42:23 <sleepynate> erm
11:42:27 <sleepynate> "kyewt"
11:42:31 <roconnor> copumpkin: http://r6.ca/thesis.pdf
11:42:43 <lilac> monochrom: Tcl and Qt have pronunciations chosen by their inventors
11:43:23 <copumpkin> roconnor: thank you :) I was hoping to endow agda with some real goodness, but am definitely not good enough to come up with my own representation so I was looking around and found yours
11:43:34 <lilac> monochrom: also i'm sure there's something to say about hebrew in this context :)
11:43:48 <capisce> the history behind the name 'Qt' is that the inventors needed a prefix for their classes and with their font the Q looked nice in emacs
11:43:57 <M_o_C> Re (.)(.): I don't fully understand the type yet. Without partial application it should look something like (.) [(.) (f :: a -> b -> c) (g :: d -> a) d] (h:: e -> b) e from what I understood. (Different brackets used only to enhance readability.) But apparently it doesn't, so where am I wrong?
11:44:05 <absentia> Cute.
11:44:09 * absentia loves cute 4.x
11:44:20 <absentia> Haskell + Qt?  Where?  :-)
11:44:33 <absentia> I'd be a convert.. as I do it now with C++ (yay moc)
11:44:45 <Berengal> QtHaskell, I believe it's called
11:44:52 <Badger> Inventively.
11:45:06 <absentia> not just a library?
11:45:09 <absentia> ug
11:45:20 <Berengal> Badger, yes, I don't think anyone's combined those two words in that way before
11:45:29 <Badger> Touche.
11:45:40 <Berengal> It has a cute logo though
11:46:08 <monoidal> is there a type with 5 values: bottom, a, b, c, top such that bottom < a < top and bottom < b < c < top?
11:46:38 <Orclev> ok, how do I export a class instance from a module?
11:47:00 <Twey> monoidal: I'm pretty sure bottom can never < anything
11:47:06 <monoidal> a type with 4 values: bottom, a, b, top such that bottom < a < top and bottom < b < top is [(),()]
11:47:08 <monochrom> You can make one. It's an interesting lattice. It is used in determining whether a lattice is distributive or not.
11:47:12 <Twey> Such a comparison immediately raises an error
11:47:14 * absentia is reading the galois paprellel haskell presentation slides.
11:47:42 <monoidal> I'm thinking how they are ordered, of course these relations are not observable
11:47:52 <monoidal> monochrom: how?
11:48:48 <copumpkin> you'd have to be non-strict on the first argument
11:48:55 <monoidal> must I define Eq by myself?
11:49:17 <monochrom> If a lattice has your thing as a sublattice, then it is not distributive. There is another condition to make the converse true.
11:50:37 <Orclev> nevermind, figured it out, I need to make sure that the class module is loaded in ghci
11:50:37 <monochrom> Oh I guess you mean how to build it.
11:50:47 <monoidal> there's another nondistributive "primitive" lattice (bot < a,b,c < top). I'm unable to create them in haskell
11:50:49 <monoidal> yes
11:51:52 <lpsmith> So if you have a case statement with a lot of literal Ints as patterns,   will GHC create some kind of efficient code, or does it search through the ints one by one?
11:52:05 <capisce> why are there so many people in this channel compared to other programming language channels?
11:52:19 <opqdonut> monoidal: how about ((),(),()) ?
11:52:32 <monoidal> qpdonut: it has 8 values
11:52:43 <opqdonut> ah
11:52:45 <aug_triad> I have installed the Euterpea library, but when I use Import.Music, I get the following error:
11:52:45 <aug_triad> Could not find module `Euterpea.Music': it is a hidden module in the package `Euterpea-0.1.0' Use -v to see a list of the files searched for. Failed, modules loaded: none.
11:52:45 <aug_triad> Using ghc-pkg field Euterpea-0.1.0 exposed-modules, I can see that the Music-module isn't shown, how can I expose this module? Euterpea.Music is localized in the .cabal-folder
11:53:02 <monoidal> qpdonut: 9
11:53:19 <Orclev> capisce: probably because haskell is equal parts awesome and unbelievably hard... at least that's my theory
11:54:12 <roconnor> Orclev: I think that is true, and a little misleading (re: haskell being hard), but I can't think of a better way of saying it.
11:55:31 <byorgey> capisce: also because this channel has a reputation for actually being civil and helpful.
11:55:32 <Orclev> roconnor: well, the language is very simple in that it's made of a few basic parts that are put together in various increasingly complex ways to make everything else... it uses a lot of rather complex theories to make it all work, and it uses a lot of concepts that most programmers are not used to working with... IE, it's hard
11:56:13 <capisce> Orclev: byorgey: makes sense
11:56:56 <monochrom> There is no shame in asserting that Haskell is hard.
11:57:52 <roconnor> Orclev: My theory is that programming correct software is instrinsically hard, haskell makes programming incorrect programs hard, hence programming in haskell is hard.  I don't know if I'm right or your right or something else is right.
11:57:54 <monochrom> Name your hobby. Tell me the most fun thing you enjoy. I bet whatever it is, it is hard. It is challenging. That is why it is fun. Haskell is the same.
11:58:32 <monochrom> The alternative is to be a couch potatoe and just watch TV all day. Easy and boring.
11:58:38 <Orclev> capisce: also, in my experience the documentation is fragmented and/or sucks... there's good documentation out there, but sometimes it's hard to find, and/or you need to visit a couple different sources to get the complete picture. It can save a lot of time and frustration to hop in here and see if someone knows a good tutorial or a quick answer
11:58:39 <lilac> roconnor: so your argument is that programming in other languages is only easier if your code is wrong? :)
11:58:50 <burp> roconnor: I'd agree
11:59:30 <roconnor> lilac: that's my theory.
11:59:45 <tingi> In linear feedback shift registers , if i know the intial state, tab positions and a final state , can i tell if final state is reachable from intialize state ? since length of tap and state is 32 , i can't enumerate
12:01:03 <RayNbow> hmm, anyone know a large project in Haskell containing or some papers describing the FP-equivalent of the observer pattern?
12:01:32 <monochrom> tangible values
12:01:50 <capisce> Orclev: ok, I haven't done much coding in Haskell so far
12:02:13 <RayNbow> @where tv
12:02:13 <lambdabot> I know nothing about tv.
12:02:18 <RayNbow> @where+ tv http://www.haskell.org/haskellwiki/TV
12:02:18 <lambdabot> Nice!
12:02:18 <monochrom> I guess watching TV all day is fun too...
12:02:22 <RayNbow> @where tv
12:02:23 <lambdabot> http://www.haskell.org/haskellwiki/TV
12:02:36 <roconnor> tingi: isn't the whole state space finite, hence looping problems are decidable?
12:02:51 <tingi> roconnor, yes i thought so
12:03:13 <tnm8> roconnor: I basically agree. I mean, Haskell, like formal logic, requires real precision in thought, which is part of makes it 'hard'. vs, say, a language like php,  which is 'easy', you'll find some of the most imprecise programming around.
12:03:14 <monochrom> decidable but we would like to know efficient ways.
12:03:15 <tingi> roconnor, but knowing whether a state is reachable
12:03:55 <roconnor> tingi: don't you just run it until it loops (reaches a previous state) or reaches your target state, and it must eventually do one of the two.
12:04:10 <tingi> roconnor, that is bad because it can be 2^32
12:04:29 <roconnor> tingi: heh, well, now you've got a different question :)
12:04:29 <monochrom> Oh! Cycle detection can be done with little memory.
12:04:48 <tingi> roconnor, since length of tap and state is 32 , i can't enumerate
12:04:53 <tingi> roconnor, i wrote that
12:05:02 <monochrom> And these days 2^32 iterations is OK.
12:05:13 <monoidal> http://en.wikipedia.org/wiki/Cycle_detection
12:05:48 <tingi> monochrom, wait you need to use 2^32 iterations with states saved, it will be 15-20 minutes
12:05:56 <trofi> for malwares?
12:06:06 <monochrom> I don't mind 20 minutes.
12:06:22 <roconnor> I really think ought to be some sort of logic for ultrafinitism for addressing these sorts of questions.
12:06:30 <Orclev> tnm8: it's not really about precision so much as it is about when errors are detected, the design of the language (like any good language) attempts to make most errors detectable at compile time
12:06:39 <monochrom> Lately I need more than 20 minutes to decide my opening positions in Civilization Revolution!
12:07:24 <monochrom> (Hell, I am still undecided about my opening positions in the current game since last night. I just can't make up my mind where I want my cities to be!)
12:07:48 <Orclev> capisce: also in case you hadn't figured it out yet, there's a lot of very smart people that do a lot of theoretical type stuff in here as well, so you see all kinds of interesting debates about everything from rather mundane topics to merits of different theoretical approaches to a problem
12:08:18 <lpsmith> One program I have calls a function 1.8 billion times in just 3 or 4 seconds.
12:08:32 <lpsmith> (a function that usually does very little)
12:08:42 <absentia> how big is the function.. gotta inline that :-)
12:08:47 <capisce> Orclev: sounds good, wish I had more time to dig into Haskell though :)
12:08:48 <lpsmith> Still, if only I could figure out how to reduce that...
12:09:00 <monochrom> Cycle detection needs only a few fixed-size variables. It's just iteration-intensive.
12:09:01 <tingi> lpsmith, 1.8 billion times in 3 or 4 seconds, that is impressive
12:09:06 <Orclev> lpsmith: if it's a pure function then doesn't haskell convert it into a constant after the first call anyway?
12:09:19 <lpsmith> It's written in C :o
12:09:20 <Orclev> lpsmith: well, for a particular set of args
12:09:30 <lpsmith> Nothing to do with Haskell
12:09:37 <roconnor> I tried to run a loop 2^301 times ... that didn't work out so well for me.
12:09:38 <absentia> ouch
12:09:42 <lpsmith> hahaha
12:10:11 <absentia> roconnor:  I often try to run lopos forever...  I keep getting SIGHLT or SIGTURING ..
12:10:25 <Orclev> lol, SIGTURING
12:10:30 <monochrom> Heh
12:10:44 <roconnor> thankfully I eventually discovered a way to do the computation in much less time.
12:10:55 <tnm8> Orclev: oh agreed on that. in terms of 'precision', I'm thinking from the perspective of the programmer's mind, haskell's language design encourages a kind of precision that many 'quick and easy to learn' languages don't
12:11:03 <absentia> rocconor: which is more accurate, a clock that runs 1 minute slow, or one that doesn't run at all?
12:11:30 <lpsmith> absentia:  if the clock is very precise,  you can fix the accuracy :-)
12:11:41 <Orclev> absentia: the one that doesn't run at all, it's correct twice a day, the other is never correct
12:11:52 <absentia> oracle: bingo
12:11:55 <roconnor> @wn accuracy
12:11:57 <lambdabot> *** "accuracy" wn "WordNet (r) 2.0"
12:11:57 <lambdabot> accuracy
12:11:57 <lambdabot>      n 1: the quality of nearness to the truth or the true value; "he
12:11:57 <lambdabot>           was beginning to doubt the accuracy of his compass";
12:11:57 <lambdabot>           "the lawyer questioned the truth of my account" [syn: {truth}]
12:11:59 <lambdabot> [4 @more lines]
12:12:03 <roconnor> @more
12:12:03 <lambdabot>           [ant: {inaccuracy}]
12:12:03 <lambdabot>      2: (mathematics) the number of significant figures given in a
12:12:05 <lambdabot>         number; "the atomic clock enabled scientists to measure
12:12:06 <absentia> replacing "never" with "very infrequently"
12:12:07 <lambdabot>         time with much greater accuracy"
12:12:50 <absentia> clock not meaning date +  time .. just hour/minute/second (etc) ...
12:12:53 <roconnor> absentia: I think they are equally as accurate.
12:13:06 <monochrom> which one is more often within 2-minute error, a clock that runs 1 minute slower, or a clock that doesn't run?
12:13:24 <jfoutz> if the clock is keeping time, it is accurate, it's just not precise. if you meant it's loosing 1 minute per whatever, then it will be right every 60 whatevers.
12:13:42 <roconnor> absentia: hmm, actually I'm not sure
12:13:48 <absentia> ya, losing 1 minute per day.
12:13:58 <roconnor> I mean the slow clock spends quite a bit of time close to the right answer.
12:14:10 <roconnor> then a long time being far from the right answer
12:14:10 <lpsmith> I seem to remember that precision was a low standard deviation of measurements,  accuracy was how close the mean was to the actual value.
12:14:14 <roconnor> and repeats
12:14:19 <c_wraith> Err.  That's not my definition of accurate, jfoutz.  I thought, in a scientific experiment context, "precision" meant "tight grouping on repeated tests", and "accuracy" mean "grouping around the right spot"
12:14:25 <roconnor> the stopped clock is doing the same thing, but at a higher frequency.
12:14:36 <absentia> roconoor: it loses more time per period.. so you can't correct for it, by using only that clock... with 1 sample... if you keep up with it, then sure, you can correct to get the acurate time.
12:14:52 * absentia runs away.
12:15:27 * Orclev throws away all these faulty clocks and gets one that works right.
12:15:36 <lpsmith> I remember once in Chemistry lab I ran an experiment with a 0.0000 standard deviation in the measurements.   I took it to the supervisor and swore I didn't make these numbers up. :-P
12:15:37 <absentia> orclev: at what altitude?
12:16:11 <Orclev> absentia: the one I'm at currently obviously... I tend not to travel much in the vertical plane
12:16:18 <absentia> I actually set the record for being off in chemistry...
12:16:28 <absentia> orc: time is relative.
12:16:56 <monochrom> Time is relative. So just keep the clock close to the user, and it will be faithful to the user.
12:17:14 <absentia> but where is the user?
12:17:32 <monochrom> The user is at the centre of the universe.
12:17:33 <absentia> hell, even gps corrects for clock skew
12:17:35 <jfoutz> c_wraith: hrm. if the clock is keeping time (not dropping 1 min per day) it is very precise by your definition, and accuracy depends on your domain. i was thinking 1 min off per whatever was not bad, but i'm used to thinking in days and months, rather than seconds.
12:17:37 <monochrom> Every user is.
12:17:46 <Orclev> ok, bringing relativity in to this has put this into some sort of tangent that I'm not sure is useful anymore
12:18:17 <tnm8> i always think of the dartboard -- accuracy is how close you get the center, precision is whether you hit the same spot over and over again
12:18:17 <absentia> orc: yes, your GPS quite agres with you.
12:18:31 <monochrom> GPS does its thing because GPS wants to do someone else's time.
12:18:39 * absentia can put 2nd and 3rd dart in the back of the first dart... it sucks, always buying more tails.
12:19:17 <Orclev> man, most days I'm doing good if I manage to get all 3 darts into the board
12:19:20 <monochrom> Whereas Orclev's clock just needs to do Orclev's time and couldn't care less about Paris ISO time.
12:19:30 <absentia> mono: 'zactly.
12:19:48 <absentia> didn't they just recently replace that clock.. with a more "accurate" one?
12:20:00 <tehgeekmeister> what are the rules for spreading what would be a single line of code across multiple lines for readability?
12:20:02 <monochrom> OK, so, exactly what I said, just keep the clock with the user. Where is the user? Whatever, the user is free to go everywhere.
12:20:15 <absentia> mono: but then time diverges.
12:20:33 <monochrom> Let it diverge. Let go of the wheel.
12:20:44 <absentia> ok, lets face it.. time sucks.
12:20:47 <Orclev> absentia: use UTC?
12:21:18 <absentia> orc: this whole discssion misses the point.   the point was someone wanted to make an algorithm faster... my response was :  ya, just hard code in a RAG.  :-)
12:21:23 <monochrom> I try to break line at operators.
12:22:13 <Orclev> monochrom: before or after? I tend to favor before, then when you see the op on the next line it's obvious that the line is continued from a previous one
12:22:14 <HugoDaniel> how do i show an Int with leading 0's ?
12:22:24 <lpsmith> Buy a netclock!
12:22:35 <Orclev> absentia: RAG?
12:22:35 <monochrom> Actually I try to not break line to begin with. I let the line span easily 90-100 characters. Then I will break lines.
12:22:43 <absentia> random ass guess
12:22:51 <Orclev> absentia: lol
12:22:56 <HugoDaniel> show 5 = "00005", show 50 = "00050" ... is something like this possible without much hassle ?
12:23:09 <tnm8> my main goal with dartboards is to avoid getting hit by the dart..developers around here tend to be rather inaccurate when throwing.
12:23:09 <monochrom> On odd days I break before, on even days I break after.
12:23:22 <tehgeekmeister> i've got this ugly mess that really should be a where or let binding, but I have to do it inside of a lambda inside a monad, so i don't know how to make it look decent.
12:23:31 <Orclev> HugoDaniel: not sure about show, but printf can do it with something like "%05d"
12:24:01 <HugoDaniel> okey
12:24:12 <HugoDaniel> ill just define instances of Show for my datatypes that use printf :D
12:24:20 <Orclev> HugoDaniel: that works
12:24:43 <lpsmith> pad n xs = replicate (n - length xs) ++ xs ?
12:24:43 <monochrom> I know the arguments but I think they're irrelevant. The arguments wrongly assume you read character by character sequentially. Be a holistic reader. 2D indentation layout already tells you which lines are continuations.
12:24:50 <Orclev> > printf "%05d" 5
12:24:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:24:50 <lambdabot>    `Text.Printf.PrintfType ...
12:24:53 <lpsmith> pad n xs = replicate (n - length xs) '0' ++ xs ?
12:24:56 <Orclev> hmm
12:25:02 <Orclev> > printf "%05d" 5 :: Int
12:25:03 <lambdabot>   No instance for (Text.Printf.PrintfType GHC.Types.Int)
12:25:03 <lambdabot>    arising from a us...
12:25:08 <Orclev> bah
12:25:40 <Orclev> someone who's better at haskell than me redo that... maybe (5::Int)?
12:26:15 <monochrom> > printf "%05d" (5 :: Int) :: String
12:26:15 <lambdabot>   "00005"
12:26:20 <Orclev> there we go
12:27:09 <tnm8> anyone have highly positive experiences parsing JSON with haskell? I usually do it with js, but I'd be happy to switch it up
12:28:11 <monochrom> Oh I have a better idea for the clock thread above. Build an accelerometer in the clock. Then the clock can travel with user and still know other people's time (if initialized as desired). iPod Touch has the necessary hardware!
12:28:11 <Orclev> isn't there a parse library (Parsec I think), that everyone is throwing at all kinds of problems? That should probably be able to handle something like JSON pretty easily
12:29:06 <Orclev> assuming there isn't already a JSON parsing library for haskell
12:29:49 <Orclev> http://hackage.haskell.org/package/json-0.4.1
12:29:49 <RayNbow> monochrom, hmm... TVs can be composed by connecting one's output to another's input... but I don't see whether it useful for all kinds of event-based situations (perhaps I need to look more into FRP?)
12:29:51 <wdonnelly> there is a JSON parsing library, but it's very annoying to try and get data out of it once it's parsed
12:31:07 <roconnor> RayNbow: I've used GuiTV to write one little app
12:31:07 <monochrom> I don't know either. I just know TV shallowly.
12:32:01 <RayNbow> well, for a more concrete example... I have a BitTorrent app here written in Python... with callbacks all over the place... I was wondering how one would write this in a pure FP style :p
12:32:05 <roconnor> RayNbow: It had a slider or two and a dropdown box.
12:32:42 <monochrom> But I recommend against premature generalizations such as "it can't do all things, where is a better alternative".
12:33:08 <tnm8> thanks, I'll try parsec for it and see how it goes. nothing like parsing to make mondays fly by
12:33:15 <monochrom> If it can't do all things you need here-and-now, you should look for a better alternative.
12:33:20 <roconnor> oh, and then we added an invisible timer widget to reload data from the server every 5 min, which is a bit more imprerative than the rest of the functionality.
12:33:24 <Orclev> tnm8: did you see the link I pasted?
12:33:46 <blackdog> blackh: around? how'd you go?
12:33:53 <monochrom> If it can do all things you need now, just not all things you imagine "maybe what if I extend next year", there is no problem.
12:33:55 <blackh> blackdog: http://upcycle.it/~blackh/ghc/ghc-6.11-macosx-v1.patch This makes ghc-HEAD build on Mac OS/X with dynamic libraries for me. It's just a tweaked conglomeration of your stuff.  Should we try to get this checked in?
12:33:56 <Orclev> tnm8: there's a library for it already, although wdonnelly says it can be a pain to work with... I haven't used it, but browsing through the docs it seems simple enough
12:34:10 <tnm8> Orclev: yep, looking at the docs now, thanks for that
12:34:14 <blackh> blackdog: I am still trying to get dependencies for my project to check that it really works.
12:34:56 <blackh> blackdog: I can't find a version of cabal-install that works.
12:35:01 <Orclev> tnm8: depending on what you want to do, it looks like encode/decode might be all you need
12:35:27 <blackdog> blackh: I think i submitted the second half of it
12:35:49 <v0|d> fxr: Happy birthday!
12:35:55 <v0|d> fxr: I salute you.
12:36:05 <blackdog> i'm a bit worried about the first - not sure we want -read_only_relocs suppress for everything, especially since i don't really know what it does
12:36:24 <blackh> blackdog: I have no idea what it does either, but it certainly works.
12:36:40 <tehgeekmeister> http://github.com/tehgeekmeister/freeskool/blob/master/next_best.hs <== anyone have suggestions on how i can clean this code up in general, or specifically lines 52-54.  i would like to use a let/where there, but i refer to variables that are bound in the lambda i'm inside at that point.
12:37:44 <blackh> blackdog: Well, the patch as I've posted it above relative to head builds everything in 'dyn' mode for me, so I think perhaps all we need to do is to make sure -read_only... isn't bad, and then we can probably submit it.
12:37:57 <gwns> ghci says: No instance for (Show (Gen [Integer])), what is wrong?
12:39:22 <Orclev> gwns: whatever you're running is returning a Gen [Integer] which show doesn't know how to convert into a string... run the same command again but do :t before it to see the type it returns
12:40:07 <monochrom> The type is Gen [Integer].
12:40:25 <tnm8> Orclev: parsing just bools and strings; this library looks straight-forward enough
12:40:26 <camio> tehgeekmeister: The "print "initialized maps"" won't necesarily come after the reduction of maps. That is, it won't print that out after "execState" is "run".
12:40:35 <tehgeekmeister> back, wifi died right as I asked that
12:40:43 <blackdog> blackh: yeah, it should work, it's basically the same as what i did. talk to igloo about getting it included.
12:41:14 <poucet>  tehgeekmeister oy
12:41:35 <tehgeekmeister> camio: oh, you're right.  not a big issue, but good to realize.
12:41:44 <poucet> tehgeekmeister: that code is horrible
12:41:47 <blackh> blackdog: OK - I'll test it a little more then I'll do that.
12:41:58 <poucet> tehgeekmeister: try ot name more of your subcomponents? Maybe using a where clause
12:42:20 <tehgeekmeister> poucet: well aware.  trying to improve it.  sadly, this is already a MUCH cleaner version.
12:42:45 <blackdog> blackh: was thinking a good test would be nice too
12:43:28 <blackh> blackdog: Do you want to take "my" patch and put it on your blog and just give it a bit of a run?
12:44:12 <camio> tehgeekmeister: You're using M.fold. You may want to take a look at the Data.Foldable import.
12:44:28 <blackdog> blackh: not a terrible idea. let me get a quick nap and some food first, i was up at 4am :)
12:45:50 <blackh> blackdog: It's 07:44 here - what time there?
12:45:50 <blackdog> 12:45pm
12:45:50 <tehgeekmeister> poucet: have any suggestion how to refactor the if in a lambda being applied to the data being generated inline?  id like to separate this across a few lines but don't see how to!
12:45:50 <tehgeekmeister> camio: what's the advantage of that, out of curiousity?
12:45:50 <blackh> blackdog: OK - I'm around for at least 7 hours.
12:45:50 <blackh> blackdog: See ya later.
12:46:04 <poucet> tehgeekmeister: the middle if?
12:46:20 <tehgeekmeister> lines 52-54
12:46:36 <camio> tehgeekmeister: Less clutter perhaps. Also, it looks like scoreTargets may be a candidate for fold or FoldMap in that lib.
12:46:38 <poucet> tehgeekmeister: name your functions in where clauses instead of inlining them as nameless lambda
12:47:19 * monochrom frowns. I want inlining.
12:47:42 <Orclev> gwns: looking at the docs I think maybe what you want to do is run sample on whatever you're trying to run... so sample $ whatever
12:48:55 <Orclev> gwns: alternatively sample' does the same thing but returns and array of the values rather than printing them to standard out (so in your example it would be [[Integer]] which show should be able to handle)
12:49:38 <tnm8> now it's time to parse
12:49:48 <camio> tehgeekmeister: It is hard to tell what this program is supposed to do by looking at this source.
12:52:27 <tehgeekmeister> it should be unless your familiar with the algorithm.  it takes a parse of a text in a language, in a format that doesn't matter right now, the items are words, the targets are sentences.  nextBest finds the next best word to learn in order to know the largest number of sentences the soonest.  then items are added in that order, and targets as all their items are known.
12:53:01 <tehgeekmeister> I plan on adding some comments making that a bit more obvious soon.  =P
12:53:11 <Orclev> tehgeekmeister: that sounds familiar... I've seen something like that before (or maybe you described it before while I was in here)
12:53:34 <Orclev> tehgeekmeister: is this for learning a foreign language or something?
12:53:48 <tehgeekmeister> it was probably me.  jtauber came up with the algorithm and wrote it in python first
12:54:10 <camio> tegeekmeister: Your code ought to look like your description above.
12:54:22 <deew123123> guys i have a question about syntax...what is wrong here?
12:54:23 <deew123123> perfect    ::   [Int]
12:54:25 <deew123123> perfect     =  if addSum factors([y | y <- [0..]]) == (y+y) then ++ [y] else []
12:54:27 <deew123123> addSum :: [a] -> [Int]
12:54:29 <deew123123> addSum [] = 0
12:54:31 <deew123123> addSum (x:xs) = x + addSum xs
12:54:34 <tehgeekmeister> Orclev: yep, but with some modifications I think it can be used for more interesting things, like learning things from wikipedia.
12:54:37 <Orclev> deew123123: hpaste it
12:54:45 <deew123123> how?
12:54:56 <Orclev> google for hpaste, it's fairly straightforward
12:55:04 <Orclev> just click new, paste it in, and save it
12:55:08 <Orclev> then paste the link in here
12:55:29 <absentia> http://defoe.sourceforge.net/folio/knuth-plass.html
12:55:37 <Orclev> lets everyone look the code over at their leasure without taking up 10 lines of the channel or whatever
12:55:57 <tehgeekmeister> camio: id love for it to, as it is right now I've been struggling to just get it to work.  really want it to be cleaner and more efficient.  the python im porting from runs in about a twentieth the space and far, far quicker
12:56:01 <camio> tegeekmeister: for example, it looks like there's a list of decending "best" words in there.
12:56:50 <tehgeekmeister> camio: yeah, but we only care about the head of that list, if you mean the one generated and consumed inside nextBest
12:57:05 <byorgey> deew123123: the '++ [y]' in the then part of the if expression doesn't make sense.
12:57:43 <deew123123> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9670#a9670
12:58:10 <deew123123> im not sure how to work with infinite lists...how do i add an element to a list like that
12:58:36 <Orclev> deew123123: you're probably looking to use something like foldr or map, give me a sec to look it over
12:59:04 <tehgeekmeister> really, the python im porting from is nearly self documenting.  my Haskell version is just clunky.
12:59:23 <byorgey> deew123123: the type of 'perfect' is [Int], which means it must evaluate to a list.  So, what list do you want to return in the 'then' part?
12:59:43 <camio> tehgeekmeister: You're porting an imperative program to a functional language. I'd start with the problem and come up with a functional solution.
13:00:07 <dancor> is there any way to get ghci to only recompile changed files?
13:00:09 <lpsmith> Ok, I'm trying to use ByteString literals,  and I'm getting the error message "No instance for (Data.String.IsString ByteString)"
13:00:10 <deew123123> i want it to return a list of perfect numbers from [1...] to whatever i set it to
13:00:10 <Orclev> deew123123: also, addSum isn't building a list, the type should be [Int] -> Int, or else it doesn't do what you mean it to
13:00:10 <camio> tehgeekmeister: otherwise, what's the point of doing it in Haskell?
13:00:15 <byorgey> deew123123: wait, never mind, that wasn't a helpful question.
13:00:17 <lpsmith> When the docs say that there is an instance
13:00:45 <byorgey> deew123123: ok, I see.  you should look at the 'filter' function.
13:00:50 <tehgeekmeister> camio: I've tried to think of a different approach.  haven't had success so far.  it requires things that aren't as intuitive (for me) in haskell
13:00:56 <byorgey> > filter even [1..10]
13:00:57 <lambdabot>   [2,4,6,8,10]
13:00:59 <deew123123> addSum is just to check if that number is perfect
13:01:06 <byorgey> deew123123: for example, I just picked out the even nubmers from the list [1..10]
13:01:19 <byorgey> deew123123: so if you can implement a function called 'isPerfect :: Int -> Bool
13:01:29 <byorgey> then you can use that with filter
13:01:45 <tehgeekmeister> camio: the algorithm itself is definitely the one I want to use.  how to make it more functional I don't know; it's inherently a very stateful program.
13:02:25 <camio> tehgeekmeister: I wonder why you want to program that algorithm in Haskell.
13:02:25 <Orclev> > let isPerfect = (==) 42
13:02:26 <lambdabot>   not an expression: `let isPerfect = (==) 42'
13:02:33 <Orclev> bah
13:02:34 <byorgey> deew123123: is this for a class?
13:02:44 <deew123123> yes
13:02:55 <Badger> > let isPerfect = (==) 42 in isPerfect 42
13:02:55 <lambdabot>   True
13:03:07 <burp> lol
13:03:09 <lpsmith> deew123123:  If you want an *efficient* way of finding perfect numbers,  I suggest implementing a sieve :-)
13:03:15 <byorgey> deew123123: ok, it is fine to ask questions here, but I would also suggest you go talk to your TA or professor.
13:03:39 <deew123123> ok
13:03:41 <c_wraith> @src (->) return
13:03:41 <lambdabot> return = const
13:03:42 <tehgeekmeister> camio: because the rest of the project im basing on it I want to be in Haskell.  and I think there's a lot to be learned by figuring out how to do this elegantly in Haskell.
13:03:54 <byorgey> deew123123: you seem to have some fundamental confusions that would probably be a lot easier to work out in person.
13:04:06 <tehgeekmeister> ca
13:04:27 <Orclev> lpsmith: it looks like he has the start of a sieve there but the types are all wrong
13:04:34 <c_wraith> > let f a = return 5 in f 3
13:04:35 <lambdabot>   No instance for (GHC.Show.Show (m t))
13:04:35 <lambdabot>    arising from a use of `M8159717586...
13:04:47 <tehgeekmeister> camio: however, parts of it have to be in python as is.  there's no question about that, because python has nltk and Haskell no equivalent.
13:05:02 <camio> tehgeekmeister: I think you may need to drop your imperative algorithm to get it looking elegant in haskell. Haskell really sucks at imperative programing despite what some might tell you.
13:05:20 <c_wraith> > let f a = return 5 :: (Int -> Int) in f 3
13:05:21 <lambdabot>   {-3->5;-2->5;-1->5;0->5;1->5;2->5;3->5}
13:05:25 <lpsmith> Orclev: that's not a real sieve :)
13:05:47 <c_wraith> > let f = return 5 :: (Int -> Int) in f 3
13:05:48 <lambdabot>   5
13:06:01 <Orclev> lpsmith: not the way it's done currently, no, but it vaguely resembles one if it actually did what he seems to intend it to do
13:06:03 <c_wraith> > let f = return 5 in f 3
13:06:04 <lambdabot>   5
13:06:24 <c_wraith> haha.  There.  That makes haskell look imperative. :)
13:06:50 <coco> hi, I'm printing something out of the lazy writer monad on the screen (IO monad). how can I flush?
13:06:52 <tehgeekmeister> camio: not sure how you can get an identical result, or even a very good one, using a strictly functional approach.  state is necessary!  id really love to find a functional approach, but im not sure there is one.
13:07:16 <tehgeekmeister> perhaps it's best to leave the imperative to python and the fun stuff to Haskell?
13:07:26 <Orclev> tehgeekmeister: uhm... State monad?
13:07:36 <tehgeekmeister> Orclev: using it.
13:07:52 <camio> @faq Does Haskell have an elegant functional way to solve any problem, including those with imperative solutions?
13:07:52 <lambdabot> The answer is: Yes! Haskell can do that.
13:08:00 <tehgeekmeister> Orclev: but it ended up ungodly complicated.
13:08:44 <tehgeekmeister> camio: how do I go about finding it then!  I don't expect anyone to give me the answer, but a pointer in the right direction would sure help.
13:09:01 <Orclev> yeah... that tends to happen... there's probably an elegant solution but it requires a level of understand of both the problem domain and the language that makes it rather difficult to do
13:09:33 * tehgeekmeister wishes he was on his laptop so he could paste the old version, to show the improvement that's been made.
13:09:42 <camio> tehgeekmeister: Perhaps we could help if you have an short exact specification of the problem.
13:10:04 <Orclev> camio: maybe seeing the original python version would help?
13:10:17 <camio> Orclev: yeah
13:10:29 <tehgeekmeister> I'll be back with a link to it, it's a better description than I can give
13:12:05 <Orclev> uhm... was he talking in here using an iphone app? That seems almost masochistic
13:12:30 <absentia> xn/last 199
13:12:34 <dilinger> dons: hey, what's your plan for a haskell-x11 release?
13:12:56 <absentia> askell on the iphone... :-)
13:14:50 <tehgeekmeister> http://github.com/jtauber/graded-reader/blob/master/code/next-best.py
13:16:38 <camio> tehgeekmeister: certainly nicer than the haskell code ;)
13:17:18 <tehgeekmeister> no question about that!  runs fast and small too!
13:18:34 <tehgeekmeister> 10mb of ram vs 170, and many seconds between items in the Haskell version but spitting across the screen faster than you can keep up in python
13:18:50 <lpsmith> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3874#a3874
13:19:14 <tehgeekmeister> it's an exercise, kinda.  i'll learn from it and be able to make something useful.
13:19:27 <lpsmith> What's wrong with my hpaste?
13:20:09 <Berengal> lpsmith, lacks an import. Don't know which :/
13:21:14 <camio> tehgeekmeister: I'm still haveing trouble understanding what this code does.
13:21:51 <camio> :/
13:22:31 <tehgeekmeister> camio: for each item (word) it adds increments a score in a dictionary by 1/2^(number of other unknown words in the sentence)
13:22:33 <Berengal> lpsmith, Data.ByteString.Char8 defines an instance
13:22:54 <Orclev> tehgeekmeister: someone else will probably get to it before me, but let me see if I can figure out how to convert it (being a haskell newbie myself this might take a while)
13:23:36 <tehgeekmeister> then at each iteration it chooses the word with highest score, adds it to the reader, cleans up the dictionaries so they're consistent with this word being known, and moves on.
13:24:45 <tehgeekmeister> I thot about making the only state be what words are known, which removes a lot of the state, but the. you have to filter the data for each iteration; very inefficient.
13:25:02 <tehgeekmeister> *then you
13:25:11 <stanv> are any ideas how join two sorted lists ? Example join [1,5,7,9,11] [2,5,11] == [1,2,5,7,9,11] ?
13:25:26 <opqdonut> merge
13:25:27 <opqdonut> :t merge
13:25:28 <lambdabot> Not in scope: `merge'
13:25:34 <opqdonut> well, not in the standard libraries
13:25:44 <opqdonut> implementation should be fairly trivial
13:25:55 <camio> tehgeekmeister: So perhaps the contents of the while loop would be a pure function. What would it's inputs and outputs be?
13:26:34 <byorgey> stanv: you can implement it by pattern-matching over the input lists: if either one is empty... (etc.) if not empty, look at the first elements and compare them... etc.
13:26:46 <byorgey> you fill in the 'etc' parts =)
13:27:12 <tehgeekmeister> camio: how can it be pure?  it has to
13:27:14 <Orclev> tehgeekmeister: is there an example of an input file somewhere?
13:27:18 <tehgeekmeister> maintain state
13:27:48 <Orclev> tehgeekmeister: the way it's implemented in python it does, but I think it's probably possible to implement it as a pure function
13:27:53 <camio> tehgeekmeister: Lets say state wise it modifies X. Then it would be a function :: X -> X
13:28:12 <tehgeekmeister> there is but it'd be forever to find right now.  on my iPhone; wifi is dead.
13:28:36 <Orclev> tehgeekmeister: ok, can you at least give an example of what a line looks like?
13:28:45 <tehgeekmeister> camio: that's essentially what's in my forever right now, but it's very stateful
13:28:55 <camio> tehgeekmeister: so the first thing to figure out is what are the inputs and ouputs of that function.
13:29:01 <camio> Since we're doing a functional approach.
13:29:21 <burp> > log 1000 / log 10
13:29:21 <lambdabot>   2.9999999999999996
13:29:43 <tehgeekmeister> camio: the first column is a word, fourth is an id for the sentence it's in.
13:30:02 <ddvlad> hmm... i have mtf installed by portage and monads-fd installed by cabal. is there a 'cabal uninstall'?
13:30:10 <ddvlad> mtl, i meant
13:30:23 <tehgeekmeister> id imagine input would be the current maps, output would be the new maps and the next item/targets
13:30:32 <camio> tehgeekmeister: I'm referring to the "pure" function inside the while loop. Which variables does it use, which variables does it modify?
13:31:20 <lpsmith> Berengal: thanks!
13:31:23 <tehgeekmeister> understood; going a touch slower since im switching from iPhone to laptop
13:31:27 <blackh> blackdog: Status report - http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3876#a3876
13:31:36 <Orclev> camio: it looks to me like it would be recursive where each pass through it finds the word to learn, then calls itself with that word removed from the list
13:31:47 <lpsmith> Not sure why haddock seems to suggest that Data.ByteString defines and instance
13:32:15 <tehgeekmeister> Orclev: precisely, but removed from maps instead of list.
13:32:17 <camio> Orclev: Could be. I'd separate the recursion out.
13:32:45 <tehgeekmeister> or it needn't be recursive
13:33:04 <Orclev> camio: you probably know better than me, I'm still pretty new to functional programming... I tend to approach something like this from a recursive standpoint as that seems the most natural equivalent of a while or for loop to me
13:33:07 <tehgeekmeister> it could be a single step, then unfold the list (might be abusing that term?)
13:33:10 <camio> [Word] -> (Word 'learnedWorld,...)
13:33:17 <tehgeekmeister> that list being the reader
13:34:07 <Orclev> tehgeekmeister: if I understand the problem, what you really want as an output is a ordered list of words to learn right?
13:34:28 <camio> Orclev: Something like iterate is what I'm referring to.
13:34:33 <tehgeekmeister> Orclev: yes, with the targets interspersed as they're known
13:35:26 <tehgeekmeister> camio: are you suggesting the algorithm takes a list of word/sentence number pairs rather than the maps?  if so why?  regenerating the maps at every step is a lot of work
13:35:31 <Orclev> tehgeekmeister: what do you mean by the targets interspersed as they're known?... you talking about the sentences? So, it would be a list of words to learn, and then a sentence once you've gotten all the words that compose that sentence?
13:36:13 <camio> tehgeekmeister: The reason I'd do that is to get an elegant program first and then see how to optimize it nicely.
13:36:21 <byorgey> Orclev: recursion is indeed the equivalent of a while or for loop.  but programming directly with while or for loops, or with explicit recursion, is usually too low-level. =)
13:36:48 <tehgeekmeister> Orclev: yes.  words=items, sentences=targets.  this code will be applied to other things than just language learning
13:36:57 <Orclev> byorgey: the point was more that coming from a procedural or OO background I tend to think in while or for loops most of the time
13:36:58 <byorgey> Orclev: functional languages let you abstract the recursive patterns into higher-order functions; in most imperative languages it's hard to abstract away from while or for loops.
13:37:09 <byorgey> Orclev: sure, that's natural.
13:37:54 <Orclev> tehgeekmeister: lol, I picture it used to map the most efficient way to read all of wikipedia :P
13:38:21 <byorgey> Orclev: but I'll bet every time you *write* a loop in one of those languages, you're annoyed that you have to actually write all those details like  i = 0; i < n; i++  or whatever.  this is a sign that it's too low-level.
13:38:39 <tehgeekmeister> Orclev: you laugh, but it could be used for mapping the most efficient route to understanding the contents of a wikipedia article!
13:39:07 <Orclev> byorgey: actually most of the ones I work in I'm iterating over some sort of collection, so something like for x in y
13:39:16 <lpsmith> I find it easier to get something correct with "low-level" recursion than an imperative loop
13:39:30 <lpsmith> It's easier to think about loop invariants,  methinks.
13:40:24 <Orclev> byorgey: that being said, something like map or foldr is very simple to understand as well
13:40:27 <tehgeekmeister> camio: well, I have all the logic in my code that's necessary to do that.  just have to name it and pipe it together differently to make that happen.  in fact I think that could turn it into nice looking code!
13:40:29 <dolio> Recursion is more general than a while or for loop, actually. To get back the power, you need to manage your own stack.
13:40:30 <byorgey> Orclev: ah, yes, that's much better.  but yet you often want to move another step further, with things like  map, filter, foldr...
13:40:33 <byorgey> Orclev: indeed.
13:40:43 <tehgeekmeister> a chain of >>= and >>s
13:41:37 <dcoutts> ddvlad: use ghc-pkg hide monads-fd
13:41:42 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/51df24fbf33b7059  explains why recursion is easier than iteration and why the myth is backwards.
13:42:01 <dcoutts> ddvlad: that'll stop them from being in scope by default at the same time
13:42:04 <copumpkin> category of programmers?!?
13:42:05 <byorgey> dolio: good point.  I remember when I first realized that in high school, when I transformed a recursive algorithm that was blowing the stack into an iterative one that managed its own stack =)
13:42:09 <copumpkin> what are the morphisms?
13:42:18 <mmorrow> and for/while/do loops are boring too.. you need unrestricted goto and an explicit place to allocate things (you can use part of it for a stack if you wish)
13:42:23 <ddvlad> dcoutts: i've used 'unregister' instead of hide. might not be a good choice, but it worked for now. thanks for your suggestion :)
13:42:45 <mmorrow> err, the end of that was supposed to be:
13:43:02 <dcoutts> ddvlad: the difference is that if you use a package that needs monads-fd then you'll have to re-install monads-fd
13:43:05 <mmorrow> you need ... to get the equivalent of being able to have mutually recursive functions
13:43:10 <c_wraith> monochrom: That "myth" is not much of a myth.  I've met *one* person who understood recursion easily, but didn't understand loops.  I've met probably 30 people who had no trouble with loops, but couldn't comprehend recursion.
13:43:34 <copumpkin> to misunderstand recursion, you must first misunderstand recursion
13:43:43 <mmorrow> the way "recursion" is usually defined wrt imperative languages also is a rather restricted/skewed def
13:43:45 <ddvlad> dcoutts: heh, there should've been a side-effect. will reinstalling monads-fd and then hiding it work?
13:43:45 <mmorrow> too
13:43:50 <monochrom> My article explains your observation too.
13:43:57 <byorgey> c_wraith: but had these people ever programmed before?
13:43:59 <dcoutts> ddvlad: yep
13:44:20 <mmorrow> (skewed because those langs usually have no concept of non-local jumps)
13:44:31 <ddvlad> dcoutts: heh, it did, and like a charm. thank you for your helpl
13:44:36 <dcoutts> np
13:44:44 <c_wraith> byorgey:  some.  None have been experienced programmers.
13:44:55 <monochrom> Loops are easier to execute. If you measure "understand" as "I teach you how to execute; afterwards can you execute?", then loop is easier to "understand".
13:45:13 <copumpkin> roconnor: your fewdigits cabal file seems rather bare, and doesn't work when I cabal-install it :(
13:46:12 <c_wraith> monochrom: I measure as "how would you solve this with recursion?"  "uhh......  I could do it easily with a loop"
13:46:25 <monochrom> If I "educate" you in a way that suppresses your divide-and-conquer instinct (just like quite some elementary education already suppresses your curiosity instinct), you will lose your born ability of understanding and using recursion.
13:46:54 <lpsmith> monochrom:  nice, thought provoking article,  btw.   I recognize Albert Lai's name,  he posts on LtU some
13:47:00 <Orclev> the problem has nothing to do with recursion or looping, it's that people tend to think in a procedural fashion... what do I do, first, then what do I do next
13:47:11 <monochrom> Yes c_wraith, if I bombard you with looping for a year, you will not be able to solve problems with recursion.
13:47:27 <tehgeekmeister> recursion is easier the more familiar you are with higher math, methinks.
13:47:27 <camio> I don't really see the point in recursion vs. looping. Who uses those low-level constructs anyway? It is much easier to argue for higher order constructs like fold which, unlike the former, are composable.
13:47:31 <tehgeekmeister> plain and simple.
13:47:35 <Orclev> loops are easier to understand from a procedural standpoint
13:47:45 <c_wraith> Well, this is the mostly at the "first week" level, not the "first year" level.
13:47:46 <monochrom> lpsmith: monochrom = Albert Lai, too :)
13:47:57 <lpsmith> haha :)
13:48:42 <c_wraith> The fundamental difference is that these are people who look at problem solving as "tell me what the steps to get this done are", rather than "tell me how to get this done".
13:48:49 <c_wraith> There's more abstraction required for recursion
13:48:50 <monochrom> c_wraith: OK, some trivial tasks are easy with looping because the tasks are trivial. Try sorting. Try tree problems. Try parsing.
13:48:53 <Orclev> c_wraith: bingo
13:49:01 <Peaker> anyone know of a good coroutine library around?  I am wondering about combining one with epoll, rather than using forkIO/etc
13:49:21 <c_wraith> I'm not saying that we want the people who can't understand recursion to be programmers.  :)
13:49:34 <c_wraith> But I'm saying that recursion requires a greater level of abstraction to really comprehend
13:49:49 <tehgeekmeister> camio: will have a version closer to your suggestions done soon.  don't know if itll be uploaded soon, that depends on the motel wifi gods...
13:50:44 <Orclev> c_wraith: I would say it's natural for humans to think about problem solving as a series of steps, it's how things tend to work out here in meat space... part of learning to be a programer is learning how to abstract that problem solving process to a greater or lesser extent
13:50:57 <mmorrow> (and also, when it's said that you can compile tail recursion to "loops", these aren't loops that are possible to create without creative use of goto, and these gotos may span multiple "procedures")
13:51:07 <copumpkin> roconnor: I have a "patch" for fewdigits.cabal :) if you're interested
13:51:26 <roconnor> copumpkin: what needs to be patched?
13:51:41 <mmorrow> and in the latter case, no amount of creativity can get you past that goto in restricted to the current proc
13:52:02 <copumpkin> roconnor: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=9674#a9674
13:52:15 <lpsmith> copumpkin:  out of curiosity,  with your pure-haskell replacement for the GMP,  did you use the fast multiplication algorithm, etc?
13:52:33 <copumpkin> lpsmith: it's not mine :) igloo wrote it, and no, I think it's n^2 multiplication
13:52:39 <copumpkin> not karatsuba or fft
13:52:52 <Igloo> It's called simple for a reason  :-)
13:52:58 <c_wraith> eh.  karatsuba and fft are slower than the naive algorithm for quite a while.
13:53:09 <copumpkin> c_wraith: yeah, but it's a _big_ integer library :P
13:53:10 <c_wraith> You need *big* numbers for them to be a win
13:53:12 <Berengal> I personally find tail-recursion a much better alternative to regular loops, and recursion in general to be easier than loops
13:53:19 <roconnor> copumpkin: hmm, looks good.  Did you have a darcs patch or do you want me to simply make the change
13:53:21 <Igloo> Isaac Dupree wrote an impl with fancier algs, I think, although it can't be used as the Integer type in GHC
13:53:35 <copumpkin> roconnor: I don't have a darcs patch but could easily make you one if you prefer that :)
13:53:48 <copumpkin> Igloo: the one they're using in lhc now?
13:53:52 <Berengal> Today, for example, I suddenly found myself thinking about iterating through two lists in parallell a bit too much
13:53:55 <Igloo> I don't know
13:54:05 <roconnor> copumpkin: it might be easier for me to patch it based on your hpaste
13:54:07 <Igloo> Oh, that does ring a bell, actually
13:54:24 <Orclev> Berengal: yes, but you're also thinking like a programmer... ask a non-programmer (or a new programmer) how they would solve a problem and they'll give you a list of steps
13:54:26 <Heffalump> Igloo: why not (re Isaac Dupree's one)? Dependencies?
13:54:32 <copumpkin> roconnor: sounds good then :) the only subtlety is there was a typo in license.txt, so you should change that too
13:54:49 <Igloo> Heffalump: Yes
13:55:25 <Igloo> And it probably doesn't use the right function names
13:55:38 <Heffalump> Does GHC itself use Integer?
13:55:47 <camio> Orclev: Ask a non-programmer what a house is and they will not give you a list of steps.
13:55:57 <camio> Orclev: That is the essence of declarative programming.
13:55:58 <mmorrow> Heffalump: yes
13:56:00 <Igloo> It's wired in, yes. Plus base uses it a lot, of course
13:56:00 <Orclev> camio: a house isn't a problem, it's a thing
13:56:13 <roconnor> copumpkin: Warning: FewDigits.cabal: Unknown fields: build-type (line 11)
13:56:16 <camio> Orclev: A program doesn't solve a problem, it's a thing.
13:56:32 <byorgey> roconnor: what version of Cabal do you have?
13:56:32 <Berengal> Orclev, for this particular problem, I don't think they would. They would use guards
13:56:36 <blackdog> query blackh
13:56:43 <Berengal> Orclev, and tail-recursion
13:56:58 <roconnor> byorgey: using version 1.6.0.1 of the Cabal library
13:56:59 <Orclev> camio: a program is a series of instructions
13:57:15 <mmorrow> Orclev: it's a graph
13:57:34 <roconnor> copumpkin: um, shouldn't there be an upperbound on the version of QuickCheck?  How compatiable is QuickCheck 2 with QuickCheck 1?
13:57:37 <camio> A mathematical equasion is sequenced dust on a chalk board.
13:57:42 <mmorrow> actually, it's many, depending on which aspect of it you're considering
13:58:42 <camio> Orclev: The ideas is to transcend the materials and get to what its essence is.
13:59:16 <camio> The essence of a program is not a series of instructions, nor is it a sequence of characters.
13:59:22 <camio> See denotational semantics.
13:59:25 <roconnor> byorgey, copumpkin should the build-type: simple go before the library?
13:59:40 <byorgey> roconnor: yes
13:59:50 <byorgey> it must, IIRC.
13:59:51 <Orclev> camio: the essence of a program is a process for solving a problem, even if that problem is rather vague
14:00:09 <camio> Orclev: That's a very limiting viewpoint.
14:00:23 <Orclev> camio: name a program that doesn't fit that definition
14:00:53 <c_wraith> some programs are processes for causing problems.  /me glares at windows
14:01:02 <roconnor> Maybe I'll say QuickCheck == 1.* for my depends.
14:01:04 <Orclev> c_wraith: lol
14:01:05 <tehgeekmeister> Orclev: the point isn't that you're incorrect, but that it's not the most useful definition.
14:01:05 <camio> virus
14:01:12 <cygnus> Orclev: putStrLn "Hello world!"
14:01:41 <Orclev> cygnus: that program solves the problem of how to display "Hello world!" on the users screen... not a very useful thing to do, but there it is
14:01:47 <byorgey> @remember ray i think programmers make the worst programmers. also the worst people. and i'm saying this having not looked at programming reddit in a while.
14:01:47 <lambdabot> It is stored.
14:02:56 <Orclev> camio: a virus isn't a program, it's a program fragment... but to tehgeekmeister's point, what's a more useful definition?
14:03:43 <Orclev> camio: even then it does solve a problem that varies depending on the virus, at its simplest it's the problem of how to spread itself
14:03:55 <cygnus> Orclev: I think you're confusing "problem" with "behavior"; that program has a behavior, but it does not solve a problem unless the author considered it a problem.
14:03:58 <roconnor> copumpkin: I pushed my cabal changes.
14:04:01 <roconnor> "pushed"
14:04:13 <camio> A program is a mathematical value.
14:05:34 <Orclev> camio: and what is the value of say grep? Is it an integer? maybe it's 42
14:05:45 <camio> I'd say it is a String->String.
14:06:02 <camio> Or maybe (String,[String]) -> String. For the args.
14:06:03 <Orclev> camio: ah, that's a function though, not a value
14:06:15 <camio> A function isn't a mathematical value?
14:06:35 <Orclev> camio: no, it's a formula for obtaining a value given a set of inputs
14:06:50 <camio> Okay, you win then ;)
14:07:07 <Alpounet> byorgey, damn, I can't stop reading forward the typeclassopedia
14:07:11 <mmmdonuts> In a higher order language, a function is a value too.
14:07:13 <Alpounet> 'cause of you :-p
14:07:50 * roconnor tries not to wade into this temption conversation.
14:07:53 <roconnor> tempting
14:07:53 <Orclev> mmmdonuts: yes, in that language, but that's not a mathematical value
14:08:02 * dancor tries to remember the last nontrivial argument
14:08:04 <mmmdonuts> The lambda calculus isn't mathematical?
14:08:28 * mmmdonuts watches Alonzo spin in his grave
14:08:55 <pastorn> @type cycle
14:08:55 <lambdabot> forall a. [a] -> [a]
14:09:05 <c_wraith> > cycle [1, 2, 3]
14:09:06 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
14:09:26 <tehgeekmeister> mmmdonuts: lololol
14:09:34 <Orclev> mmmdonuts: a function isn't a value though, lambda calculus just defines a way to compose functions
14:09:56 <c_wraith> hmm.  I wonder if cycle is implemented via fix.
14:10:00 <c_wraith> @src cycle
14:10:00 <lambdabot> cycle [] = undefined
14:10:00 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:10:16 <c_wraith> heh.  that's basically the same implementation as fix.
14:10:39 <c_wraith> (and yes, I know it's not necessarily GHC's implementation)
14:11:45 <mmorrow> @type fix . (++)
14:11:45 <lambdabot> forall a. [a] -> [a]
14:11:50 <mmmdonuts> Orclev, in the lambda calculus, a function is a value.  In fact, in the pure untyped lambda calculus, all values are functions.
14:12:15 <pastorn> @type repeat
14:12:15 <lambdabot> forall a. a -> [a]
14:12:25 <mmorrow> @type fix . (:)
14:12:26 <lambdabot> forall a. a -> [a]
14:13:08 <mmmdonuts> Getting a bit less abstract, can anyone point me in the right direction for creating a ByteArray# from a list of Word64? (Or WordNN, for that matter).
14:13:37 <mmorrow> , let fix f = f (fix f) in vacuum (fix (0:))
14:13:43 <lunabot>  Killed.
14:13:45 <mmorrow> , let fix f = let x = f x in x in vacuum (fix (0:))
14:13:47 <lunabot>  [(0,[1,0]),(1,[])]
14:14:17 <mmorrow> letrec is key
14:14:35 <Orclev> mmmdonuts: the problem with that is, you need values for something to be useful, if all values are functions it becomes impossible to actually evaluate anything, somewhere you NEED to have a concrete value
14:15:14 <opqdonut> it's just a matter of perspective
14:15:18 <tehgeekmeister> Orclev: if does?  can't you represent EVERYTHING functionally?  albeit in ridiculous ways
14:15:26 <opqdonut> we're used to "concrete values" having concrete representations
14:15:32 <camio> Orclev: Commonly functions are mathematically represented as sets of pairs.
14:15:37 <opqdonut> but there's no reason why functions couldn't also
14:15:41 <tehgeekmeister> church numerals, for example, if I remember the term right
14:16:34 <Orclev> tehgeekmeister: somewhere you have to have a conrete value, even if all other values are represented by functional transforms on that initial value
14:16:47 <mmmdonuts> Orclev, It's not "impossible to evaluate anything" in pure lambda calculus - there are reductions rules which define how to evaluate things, and a way to tell when you've reached a "final" value (normal form).
14:16:49 <dv-_> record updates are still as terrible as they were years ago, i see
14:17:24 <tehgeekmeister> camio: okay, my function is now a chain of state modifying functions.  a bit closer to what you suggested; where would you suggest I go next?  attempting to get wifi so I can show the changes.
14:17:46 <Orclev> mmmdonuts: ok, fine, define the value 3 without using any concrete values
14:18:00 <tehgeekmeister> camio: all defined as named functions in where clauses.  no real change to the logic, just cleaner looking.
14:18:16 <dv-_> Orclev: pow(pow(pow({})))
14:18:27 <tehgeekmeister> Orclev: church numerals, as I said.  google it.
14:18:40 <tehgeekmeister> (someone correct me if that's the wrong name)
14:18:43 <opqdonut> Orclev: \f x -> f (f (f x))
14:18:49 <opqdonut> yeah, tehgeekmeister has it right
14:18:57 <camio> tehgeekmeister: I'd try to break down the problem into smaller useful parts. Most of my functions are about 2 or three lines long maximum, for example.
14:19:47 <tehgeekmeister> then everything else could, god forbid, be represented by encoding it to church numerals, where there's no better functional representation.  literally everything CAN be a function
14:19:48 <opqdonut> Orclev: we can do computations with these church numerals and the normal forms are functions
14:19:52 <mmmdonuts> Orclev, oqpdonut did it.  In Haskell syntax using a Church numeral encoding: \s z -> s (s (s z)).  Think of 's' as "successor" and 'z' as "zero".
14:19:58 * tehgeekmeister smiles at remembering unlambda
14:20:03 <opqdonut> Orclev: but they are exactly the functions that represent the answer
14:20:07 <tehgeekmeister> that's taking functional too far!
14:21:09 <Orclev> yes, but you still need a zero value, z, or in the previous example {}
14:21:17 <roconnor> tehgeekmeister: data types are nothing more then reified functions :P
14:21:20 <tehgeekmeister> camio: that's basically what I've got, but in the where clause, not as separate functions.  I could separate them out if there's a benefit to that?
14:21:24 <Berengal> Gralphblarg
14:21:51 <Berengal> When library functions don't work as anticipated, I become sad :(
14:21:57 <camio> tehgeekmeister: I'd only separate them out if they might have useful functionality elsewhere.
14:22:17 <mmmdonuts> tehgeekmeister, do you mean Church numerals are taking functional too far?  Not so, because every time you use a recursive function to iterate over an integer value you're exploiting that exact same structure of the integers.
14:22:30 <camio> tehgeekmeister: You may find, as you continue doing this, that your small functions are already written somewhere else. That's when things really get fun;)
14:22:35 * Berengal uses a function that returns something in an arbitrary monad. Maybe seemed like a good choice, but it throws an exception on failure regardless
14:22:46 <tehgeekmeister> I could test them individually that way, and add type signatures
14:23:05 <tehgeekmeister> mmmdonuts: I meant unlambda was too far
14:23:18 <tehgeekmeister> mmmdonuts: functional programming without lambdas
14:23:24 <mmmdonuts> Aha
14:24:05 <tehgeekmeister> mmmdonuts: yeah, church numerals are elegant.  but inefficient as can be, too.
14:24:37 <roconnor> @pl (\f z -> f (f (f z))))
14:24:37 <lambdabot> (line 1, column 22):
14:24:38 <lambdabot> unexpected ")"
14:24:38 <lambdabot> expecting variable, "(", operator or end of input
14:24:41 <roconnor> @pl (\f z -> f (f (f z)))
14:24:41 <lambdabot> ap (.) (join (.))
14:24:43 <tehgeekmeister> camio: will have code posted in a moment.  brb
14:25:03 <roconnor> 3 = S B (W B)
14:25:09 <mmmdonuts> Orclev, with Church numerals the "zero" value is provided when you use the number in a computation.  Other than that, the representation we've given *is* the number three.  What you're thinking of is *translating* the number into some other system.
14:25:50 <roconnor> hmm
14:25:53 <Orclev> mmmdonuts: church numerals are a way of representing a function to get from some zero value to any other value, they are not themselves a value until you evaluate them using that 0 value
14:26:00 <roconnor> I guess there are multiple representations of 3
14:26:10 <mmmdonuts> roconnor, my attempt to draw you in is succeeding!
14:26:17 <roconnor> damn it
14:27:14 <tehgeekmeister> Orclev: err, no.  they're an encoding.  just like your binary is.  no different, just a different way of writing it.
14:27:25 <tehgeekmeister> hey, couldn't you do binary church numerals?
14:27:42 <camio> Orclev: see my earlier comment on sets.
14:27:43 <tehgeekmeister> x(y(x(x(y()))))
14:28:09 <tehgeekmeister> oh, but those lose the elegance of church numerals
14:29:11 <mmmdonuts> Orclev, in the lambda calculus there are no values that are anything other than "a way of representing a function to get from..."  So no matter what encoding you choose, you still have a function, which is a value.
14:29:31 <monoidal> i think our problem is unclear definition of value
14:29:52 <tehgeekmeister> Orclev: also, it's worthwhile to realize that in (at least some of the texts i've read) integers are defined as sets, not in the intuitive manner you're used to.
14:30:08 <tehgeekmeister> i.e.: 3 thingies, 2 thingies, etc.
14:30:11 <Orclev> mmmdonuts: ok, I think I see the point there, although I need to think about it
14:30:36 <pastorn> how much of my values in my code are preprocessed?
14:30:42 <Cale> tehgeekmeister: You can take any algebraic datatype you can think of and Church-encode it.
14:31:01 <tehgeekmeister> Cale: that's scary and beautiful
14:31:01 <Cale> tehgeekmeister: The constructors of the datatype become parameters.
14:31:25 <pastorn> like this: dict = zip ['a'..] [1..25]
14:31:34 <monoidal> Cale, it works on codata?
14:31:35 <pastorn> could that be calculated compile time?
14:31:39 <Cale> So, for instance, you can do lists like: (\nil cons -> cons 1 (cons 2 (cons 3 nil)))
14:31:50 <Cale> monoidal: sure, why not? :)
14:31:54 <monoidal> nice
14:32:28 <monoidal> so, infinity in Peano numbers is Y combinator
14:32:33 <Cale> repeat x = (\nil cons -> cons x (repeat x))
14:32:45 <Philonous> What exactly is the difference between data and codata?
14:33:19 <monoidal> (or is it? hm)
14:33:37 <Cale> Of course, that one requires the untyped lambda calculus
14:33:59 <Cale> (or some fudging to deal with infinite types)
14:34:01 <copumpkin> roconnor: thanks :) yeah, quickcheck should probably have an upper bound on it
14:34:11 <Peaker> I don't fully understand codata, but somehow it only allows for infinite data structures in a way that ensures functions that operate on them are productive
14:34:13 <roconnor> Philonous: data is generated by taking the least fixpoint of a functor over a domain.
14:34:23 <roconnor> Philonous: codata is the greatest fixed point. :P
14:34:50 <tehgeekmeister> camio: for some reason github is the only site not letting me connect.  hpasting.
14:35:08 <tnm8> tehgreekmeister: in terms of sets and properties, you can be a fregean and define 0 as any logically inconsistent property F, 1 as the class(or set, etc) of such properties, etc etc ;)
14:35:10 <roconnor> Philonous: I wish I understood the details of what I said.
14:35:12 <tehgeekmeister> camio: hah!  as i said that it let me push.  new code is up at the same url.
14:35:27 <Cale> It's just in terms of the subset order.
14:35:31 <Orclev> mmmdonuts: ok, looking back at the previous example of s(s(s(z))), if everything is a function, what's the definition of the function z?
14:35:31 <tehgeekmeister> camio: http://github.com/tehgeekmeister/freeskool/tree/master/GNTParser.hs
14:35:36 <tehgeekmeister> errr
14:35:37 <tehgeekmeister> wrong file!
14:35:39 <Philonous> roconnor:Functor between what categories?
14:35:44 <tehgeekmeister> camio: http://github.com/tehgeekmeister/freeskool/tree/master/next_best.hs
14:35:50 <monoidal> yes
14:35:54 <roconnor> Philonous: exactly.
14:35:57 <Cale> Orclev: s and z aren't functions (yet), they're parameters ;)
14:36:02 <Philonous> which*
14:36:05 <roconnor> Philonous: presumably the category of domians.
14:36:10 <Cale> Orclev: (\z s -> s (s (s z)))
14:36:12 <tehgeekmeister> Cale: they aren't?!  educate me, o master!
14:36:17 <tehgeekmeister> i did not know that.
14:36:39 <Cale> tehgeekmeister: Oh, well, I suppose you could mean something completely different.
14:36:59 <Cale> It's possible to define functions s and z which will construct Church numerals.
14:37:12 <Cale> zero = (\z s -> z)
14:37:14 <tehgeekmeister> Cale: i don't know much, i just barely get the idea of church numerals.  i guess i normally think of them as constructors of an ADT rather than function calls.
14:37:35 <mmmdonuts> Orclev, it's a parameter.  This allows the number to be combined with other numbers in calculations.  In fact, we could turn this argument around and say that "3" isn't a value, since it cannot be used to calculate anything without somehow converting it to a function which knows how to apply itself three times.
14:37:42 <Cale> succ f = (\z s -> s (f z s))
14:37:48 <Orclev> > (\z s -> s (s (s z))) 0 (+)
14:37:49 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t
14:37:53 <Orclev> hmm
14:38:04 <monoidal> it works on church booleans true: \true false -> true and \true false -> false are projection functions
14:38:11 <Cale> Things are funny in the untyped lambda calculus :)
14:38:24 <Orclev> > (\z s -> s (s (s z))) 0 (+1)
14:38:25 <lambdabot>   3
14:38:27 <Philonous> roconnor: Without knowing the details I can't make much of that.
14:38:35 <roconnor> I know :(
14:38:35 <copumpkin> roconnor: did you end up convincing that TA that a formally verified proof was acceptable? I read your essay on that
14:38:50 <roconnor> copumpkin: no, but as a grad student I didn't care
14:39:01 <monoidal> Philonous: endofunctors on the category of Haskell types
14:39:26 <camio> tehgeekmeister: closer
14:39:29 <trzkril> > (\z s -> s (s (s z))) [] ([]:)
14:39:30 <lambdabot>   [[],[],[]]
14:40:21 <monoidal> Philonous: take data H x = (x, Integer). Then H has as the fixed point the empty type. It's the smallest fixed point - data. The largest is the type of streams
14:40:23 <roconnor> monoidal: what are haskell types?
14:40:38 <roconnor> monoidal: specifically what do haskell types denote.
14:40:41 <Orclev> > (\z s -> s (s (s z))) "Tap your hoof:" (++ " Tap")
14:40:42 <monochrom> (In the foregoing recursion thread, I forgot another challenge to "more people understand looping", even when "understand" means "can use". You give them a problem to solve. Most people will quickly write down a loop, but can't write down a recursion. OK, but how often is the first attempted loop buggy? I bet always. Now I tie in some question about a clock that runs a bit slow vs a clock that doesn't run...)
14:40:42 <lambdabot>   "Tap your hoof: Tap Tap Tap"
14:40:56 <mmorrow> does anyone happen to know the alignment of a (long long) in C on i386 (the abi doesn't seem to even include that type)
14:40:57 <mmorrow> ?
14:41:25 <monoidal> I don't know it is defined formally. That category is usually denoted Hask, its objects are types and morphisms are functions. Disregarding bottom, seq etc. it's cartesian closed
14:41:36 <copumpkin> mmorrow: can't you ask gcc for it?
14:41:53 <mmorrow> copumpkin: i could, but i'd need to fire up vmware (i think)
14:41:57 <copumpkin> oh
14:42:02 <sm> dangit.. how could I convert a NominalDiffTime to Int ?
14:42:15 <copumpkin> mmorrow: I can give it to you for i386 on a mac :P
14:42:18 <roconnor> monoidal: I don't know how to formally define it myself either, so I don't really know how big the greatest fixed point can be.
14:42:19 <Philonous> monoidal: That makes sense. Thank you! Now I just have to figure out the properties of those fixed points
14:42:23 <mmmdonuts> mmorrow, I think it's 4 bytes.
14:42:26 <tehgeekmeister> camio: this still doesn't make any practical change to the algorithm, tho.  how do i make it elegant, rather than just making the code look clean?
14:42:28 <HugoDaniel> is there any way to use the webdav protocol in haskell ?
14:42:49 <mmorrow> mmmdonuts: ah cool, the alignment of everything seems to be 4 (even double (gasp!))
14:42:51 <roconnor> monoidal: someone elsewhere was wondering if Streams could contain a transfinite number of terms.
14:43:15 <monoidal> countable or not?
14:43:19 <camio> tehgeekmeister: Try to figure out how to do it without monads and just functions.
14:43:27 <mmorrow> copumpkin: cool, i'd be interested in that info (just in case apple deviates as usual :)
14:43:37 <Orclev> tehgeekmeister: there's no straight answer to that, it depends on the function being written
14:43:38 <roconnor> monoidal: obviously such larger stream couldn't be distiguished by bisimulation, but they might still be there.
14:44:00 <tehgeekmeister> Orclev: of course, but i did ask with respect to a specific one
14:44:08 <camio> tehgeekmeister: And whenever it makes it cleaner, go with less-efficient. Optimization best happens once it is elegant and clean.
14:44:10 <roconnor> monoidal: I'm sure we have a definition of a domain that excludes these extra long streams, but I don't know how to formally do this. :(
14:44:22 <copumpkin> mmorrow: 8 on my machine
14:44:27 <mmorrow> copumpkin: :o
14:44:38 <monoidal> IIUIC streams on (omega+1) are isomorphic to streams on omega, since only cardinality matters
14:44:50 * mmorrow fires up vmware to check on i386 linux just in case
14:44:55 <monoidal> things might get strange above the church-kleene ordinal, don't have any idea
14:45:02 <Orclev> tehgeekmeister: going to go back to working on that now, kind of got distracted
14:45:16 <monochrom> Just use bisimulation to define program equivalence. Then even if you write code that tries to append some transfinite suffix, "equivalence" says it doesn't matter.
14:45:19 <tehgeekmeister> camio: hmm.  so thread state manually?  the algorithm is inherently stateful, as you've seen yourself.  perhaps it'd be better if it were a string of composed functions that modify the "state", rather than using the state monad, and generate one value at a time.
14:45:29 <roconnor> monoidal: no stream elements above omega can  be accessed in haskell
14:45:30 <tehgeekmeister> Orclev: i updated the code, refresh the page and you'll see a cleaner version.
14:45:31 <copumpkin> mmorrow: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=9675#a9675 is what I used
14:45:37 <monoidal> oh
14:45:38 <Orclev> tehgeekmeister: that's what I was thinking myself
14:45:56 <roconnor> monoidal = cycle "lol" ++ "Omega point"
14:46:15 <sm> round, I guess
14:46:17 <monochrom> "dead code removal" is an optimization justified by this.
14:46:26 <roconnor> can't be distinguished from cycle "lol" ++ "Nomega point"
14:46:40 <Orclev> tehgeekmeister: I actually closed the window that had your code in it, I was going to work off the python codd
14:46:43 <tehgeekmeister> nextItem :: ReaderMaps -> (ReaderMaps, ReaderItems)
14:46:44 <Orclev> tehgeekmeister: code even
14:47:01 <roconnor> It would be nice to have semantics that assign the same value to these two programs
14:47:15 <tehgeekmeister> Orclev: as you will, just letting you know there's another version.  =]
14:47:27 <Orclev> tehgeekmeister: can you post the link again?
14:47:43 <tehgeekmeister> http://github.com/tehgeekmeister/freeskool/blob/master/next_best.hs
14:48:01 <tehgeekmeister> and then nextItem itself could be in the state monad, as opposed to anything underneath it.
14:48:36 <tehgeekmeister> (anyone else who has suggestions about how to clean up that code and make it more elegant and functional, i'm glad to have your advice!)
14:49:38 <mmorrow> copumpkin: yeah, it's 8 on linux too
14:49:47 <roconnor> tehgeekmeister: I do, unindent that where clause!
14:49:58 <mmorrow> copumpkin: hehe, "#import <stdio.h>" (in your paste), i do that all the time.
14:50:09 <copumpkin> lol
14:50:13 <copumpkin> on mac os, it works :P
14:50:19 <mmorrow> heh
14:50:25 <copumpkin> apple--
14:50:48 <v0|d> tehgeekmeister: maybe you should define some kind of a monoid.
14:51:00 <mmorrow> also sizeOf/sizeof is another annoying muscle-memory-ish thing that always happens when coding in both simulataneously
14:51:04 <v0|d> tehgeekmeister: it was nice until makeNextBestReader.
14:51:10 <copumpkin> mmorrow: yeah
14:51:14 <monochrom> Denotationally I think two ingredients will ensure cycle "lol" = cycle "lol" ++ "Omega point" = cycle "lol" ++ "Nomega point".
14:51:18 <mmorrow> *simultaneously
14:51:20 <copumpkin> mmorrow: what are you doing that requires knowing alignment of c types?
14:51:48 <roconnor> tehgeekmeister: (modify id) is the same as (return ())?
14:51:51 <roconnor> @type modify id
14:51:52 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m ()
14:51:57 <tehgeekmeister> roconnor: okay!  to a few spaces from the left or all the way or what?
14:51:57 <mmorrow> copumpkin: some haskell code that computes the layout of a C struct (where the padding is/etc) given a description
14:52:17 <copumpkin> if cycle "lol" ++ "moo" were implemented as x :: Integer -> Char, would the "seemingly impossible functional programs" technique be able to distinguish them?
14:52:22 <roconnor> tehgeekmeister: I would personally indent where with 1 space, and then align everything the same way you have.
14:52:33 <roconnor> wrt the new where placement
14:52:42 <roconnor> @src when
14:52:43 <lambdabot> when p s = if p then s else return ()
14:52:44 <mmorrow> copumpkin: another annoyance is that apparently windows does the padding (on i386) differently than the abi spec
14:53:03 <mmorrow> but it's controllable with a compiler flag (or something)
14:53:10 <roconnor> tehgeekmeister: once you replace modify id with return (), then you will see your if statement is an instance of the "when" funciton
14:53:14 <monochrom> First ingredient: insist that the domain is a least fixed point. (The domain is a fixed point of some domain equation anyway.) Then you don't have any spurious values in the domain.
14:53:17 * mmorrow tries to remember where he read the description of that
14:53:30 <monochrom> My second ingredient is a bit broken.
14:53:54 <v0|d> monochrom: could you explain a domain being at least fixed point? it is related to cardinality?
14:54:03 <roconnor> tehgeekmeister: your lift before tell I think (hope) is unecessary.
14:54:08 <tehgeekmeister> v0|d: how do i use a monoid to help me here?
14:54:58 <v0|d> tehgeekmeister: i've seen maps' inside each other.
14:55:11 <v0|d> tehgeekmeister: maybe you can lift them.
14:55:47 <roconnor> monochrom: that first ingredient sounds like a very good ingredient
14:55:47 <tehgeekmeister> v0|d: in my code?  i may have a few.  still don't see how that's relevant.  i'm a bit of a n00b.
14:55:48 <monoidal> Philonous: http://en.wikipedia.org/wiki/Initial_algebra
14:56:15 <roconnor> tehgeekmeister: wait, have you used HLint?
14:56:34 <roconnor> tehgeekmeister: apparently we aren't supposed to comment on code that hasn't had HLint run on it first. :)
14:56:52 <tehgeekmeister> roconnor: i can run it in a second!
14:57:08 <monochrom> Because the domain has primitive values, then functions over those primitive values, then functions over those functions... you eventually have to postulate: domain is isomorphic to primitive values + some function space over domain. It's a fixed point equation, domain = F(domain). If you take "function space" to be "continuous functions only", there is no cardinality problem.
14:57:12 * roconnor wonders if Hlint know that modify id is return ()
14:57:34 <monoidal> Final coalgebras are simple (i.e., have no proper quotients[2]).[1]
14:57:34 <Peaker> it could be cool if it tried some inlining to find out
14:58:01 <monoidal> roconnor: that's a quote from wikipedia. doesn't that exclude transfinite sequences?
14:58:23 <tehgeekmeister> roconnor: i already changed it to return (), but i'll change it back and tell you what hlint does
14:58:32 <lilac> roconnor: i thought the HLint implementation pasted the code on hpaste then asked for comments here?
14:58:44 <roconnor> lilac: *LOL*
14:59:14 <Peaker> hlint could have a bunch of rules, then it could try inlining stuff and see if it hits its rules
14:59:24 <roconnor> @src modify
14:59:25 <lambdabot> Source not found. Where did you learn to type?
14:59:36 <HugoDaniel> any plans to improve the haskell type system ?
14:59:40 <roconnor> well I can imagine what the source looks like
14:59:43 <tehgeekmeister> roconnor: it knows about when!
14:59:49 <HugoDaniel> when is the haskell' planned for ?
14:59:57 <roconnor> tehgeekmeister: that I expected. :)
15:01:11 <roconnor> tehgeekmeister: some of the modify lines could be make a little prettier using the accessor package, but if you are new to Haskell, that might not be worth doing at this time.
15:01:48 <roconnor> tehgeekmeister: btw, I only have mirco suggestions.  I have no idea what your code does, so I don't know if your approach is poor.
15:02:03 <copumpkin> HugoDaniel: it will come out in 2017
15:02:09 <copumpkin> HugoDaniel: if we're lucky
15:02:23 <tehgeekmeister> roconnor: oh, there's a better way to modify fields?  that felt clunky the whole time
15:02:24 <copumpkin> HugoDaniel: and will standardize hierarchical modules and nothing else
15:02:35 <HugoDaniel> :D
15:02:47 <camio> The problem is that a well specified problem is a clean functional program.
15:02:53 <roconnor> tehgeekmeister: there is a library that has nice combinators for modifying fields of state record types.
15:03:20 <lilac> copumpkin: it will come out in 2017 and will require heirarchical modules to use a different type of dot.
15:03:30 <copumpkin> I'd agree
15:03:43 <copumpkin> I don't like the dot there
15:04:02 <c_wraith> switch to 。
15:04:36 <v0|d> i have q: Which cardinalities does haskell support for a set?
15:05:05 <roconnor> v0|d: Data.Set?
15:05:10 <c_wraith> v0|d: sounds suspiciously like homework.  What do you think?
15:05:13 <Orclev> I know there's an easy way to do this because I've seen it documented somewhere, but if I've got a list of items how do I remove duplicate items from the list (but retain one of them)... so, [1,2,3,3,4] -> [1,2,3,4]
15:05:15 <MyCatVerbs> v0|d: depends, how're you representing sets?
15:05:21 <dobblego> nub
15:05:24 <roconnor> v0|d: for Data.Searchable?
15:05:28 <copumpkin> pretty sure Data.Set only supports finite sets :P
15:05:30 <dobblego> > nub [1,2,3,3,4]
15:05:30 <lambdabot>   [1,2,3,4]
15:05:31 <roconnor> v0|d: or Data.Searchable?
15:05:31 <Cale> dons: Did you benchmark the HsJudy library at some point?
15:05:38 <Orclev> ah, thanks
15:05:50 <idnar> @type nub
15:05:51 <lambdabot> forall a. (Eq a) => [a] -> [a]
15:05:53 <v0|d> roconnor: i mean lazy lists guarantee aleph1 but what about others?
15:05:56 <roconnor> Data.Searchable supports any compact space.
15:06:00 <tehgeekmeister> roconnor: it's a port of this code to haskell; http://github.com/jtauber/graded-reader/tree/master/code/next-best.py
15:06:01 <MyCatVerbs> v0|d: For example, if you represent a set of items of type (foo) as a function from (foo -> Bool), such that the function returns True if the item is in the set...
15:06:19 <roconnor> v0|d: you cannot search an infinite list.
15:06:28 <MyCatVerbs> v0|d: then \_ -> True -- represents a set with infinite cardinality, if the type (foo) is big enough. ^~
15:06:34 <roconnor> v0|d: anyhow, the restriction is topological, not cardinal.
15:06:48 <lilac> v0|d: lazy lists are aleph0 i think. binary trees would be aleph1 in some sense
15:07:04 <v0|d> lilac: nice, thanks.
15:07:52 <roconnor> you cannot search aleph0; you never know if something isn't in the set.
15:07:59 <MyCatVerbs> lilac: How do you do aleph1 with a binary tree? It's still countable, surely?
15:08:11 <monoidal> all types in haskell are countable
15:08:28 <roconnor> MyCatVerbs: haven't you read Escardo's famous seemingly impossible functions blog post?
15:08:57 <lilac> MyCatVerbs: you can only look at a countable portion of it, certainly
15:08:58 <MyCatVerbs> roconnor: I thought that one was on binary searches on Cantor sets?
15:09:11 <tehgeekmeister> new version uploading, with suggested cleanups included.
15:09:14 <tehgeekmeister> and hlinted.
15:09:14 <v0|d> monoidal: are there generators for uncountables?
15:09:26 <MyCatVerbs> roconnor: (I think so, but I forget details and I might've missed the connection)
15:09:29 <roconnor> MyCatVerbs: the cantor sets is the set of paths through binary trees.
15:09:56 <monoidal> v0|d, there are 2^aleph0 functions Integer -> Integer. but haskell represents only comptuable ones, co Integer -> Integer has aleph0 inhabitants
15:10:06 <roconnor> I guess the trick is that you can only represent clopen subsets of the cantor space in Haskell.
15:10:41 <roconnor> monoidal: haskell can perfectly well operate on non-computable (Integer -> Integer) inputs.
15:11:09 <lilac> roconnor: your statement presupposes that non-computable functions exist ;-)
15:11:15 <v0|d> i wish there is a text describing the anology between polynomials and recursive functions.
15:11:17 <monoidal> roconnor: how?
15:11:18 <roconnor> lilac: I don't think it does.
15:11:34 <monoidal> unsafe io and external oracle?
15:11:40 <MyCatVerbs> roconnor: oh right, that makes sense. I'm not familiar with the connection between Cantor sets and aleph-one, though.
15:11:41 <camio> lilac: do they not?
15:11:45 * MyCatVerbs pokes at wikipedia.
15:11:53 <roconnor> monoidal: for example (\f :: Integer -> Integer -> f 0)  has type ((Integer -> Integer) -> Integer)
15:11:54 <lilac> roconnor: well, can haskell operate perfectly well on invisible pink unicorns? ;-)
15:12:04 <roconnor> lilac: not so clearly
15:12:34 <tehgeekmeister> v0|d: if you could give me a bit more of an idea what you meant by your monoid suggestion i'd really appreciate it!  i still have no idea, even after rereading a few times.
15:12:34 <MyCatVerbs> lilac: sure, provided you don't attempt to seq them beyond WHNF. :)
15:12:35 <roconnor> MyCatVerbs: there isn't a link to aleph-one, unless you assume CH, which is totally rediculous to assume.
15:12:41 <monoidal> i'd consider this function computable
15:12:53 <lilac> MyCatVerbs: what do you have against invisible pink unicorn bottoms?
15:13:02 <roconnor> monoidal: me too, but it can operate on non-computable functions.
15:13:16 <MyCatVerbs> lilac: ...I plead the fifth.
15:13:25 <dobblego> wrong country
15:13:53 <c_wraith> roconnor:  You can write functions that operate on a function without caring that it's computable.  But you can't pass a non-computable function to one.
15:14:08 <c_wraith> Unless your definition of non-computable function includes _|_
15:14:18 <monoidal> v0|d, you might check http://blog.sigfpe.com/2008/01/type-that-should-not-be.html
15:14:50 <monochrom> My computing function includes _|_
15:15:55 <c_wraith> And there are certainly non-computable functions out there.  Starting with the busy beaver function, and becoming more esoteric.
15:16:00 <roconnor> c_wraith: You can pass my function to the IO monad such that it queries an oracle (user) for input.  But whether this counts as an uncomputable function being passed depends on physics. :)
15:16:47 <tehgeekmeister> c_wraith: busy beaver function?
15:16:49 <roconnor> c_wraith: hmm, actually I'm not sure if you can do this in IO or not.
15:16:51 <MyCatVerbs> c_wraith: I think you can get less esoteric than BB while still being halting-complete. Like, uh, the halting probability? :)
15:17:12 <Orclev> hmm... why the heck would foo x:xs not be a valid pattern?
15:17:19 <monoidal> how would you create a halting problem oracle monad?
15:17:26 <roconnor> Orclev: foo (x:xs)
15:17:36 <shapr> monoidal: Find a way to lift Alan Turing into your monad? :-/
15:17:40 <c_wraith> tehgeekmeister: http://en.wikipedia.org/wiki/Busy_beaver  <-- quite fascinating, actually
15:17:42 <shapr> Er, Goedel, dang it.
15:17:44 <Orclev> roconnor: ah, it's always something little that bites me
15:17:56 <MyCatVerbs> tehgeekmeister: busybeaver n = the maximal number of ones that can be deposited on its input tape by a Turing-machine with n states, without looping infinitely.
15:17:58 <roconnor> Orclev: that is a tough one at the beginning.
15:18:06 <monoidal> for example, Oracle Int would be an integer that is computable if an oracle given
15:18:16 <monoidal> there would be a cast Oracle a -> IO a
15:18:18 <MyCatVerbs> tehgeekmeister: or roughly the longest time that you can make an n-state Turing machine run for without ever looping. :)
15:18:35 <monoidal> halting set would be Integer -> Oracle Bool
15:19:17 <roconnor> c_wraith, lilac: anyhow, I conjecture that if Haskell had a formal specification, there would be uncomputable functions in it's domain.
15:19:40 <ray> :t ap const const
15:19:41 <lambdabot> forall b. b -> b
15:20:31 <tehgeekmeister> MyCatVerbs: wow
15:24:41 <MyCatVerbs> tehgeekmeister: Yeah, it's nifty. It's uncomputable because if you could put an upper bound on how long the longest-running non-looping Turing machine with n states would run for then you could just simulate any machine of n states for that many steps plus one to find out whether or not it'd halt. ^_^
15:24:50 <Orclev> what's the minimum complete definition for Ord?
15:25:58 <c_wraith> @src Ord
15:25:58 <lambdabot> class  (Eq a) => Ord a  where
15:25:59 <lambdabot>     compare      :: a -> a -> Ordering
15:25:59 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
15:25:59 <lambdabot>     max, min         :: a -> a -> a
15:26:08 <c_wraith> I think you just need compare
15:26:25 <MyCatVerbs> Orclev: IIRC any of the comparison operators work.
15:26:32 <Peaker> Just (<) or (<=) or (>) or (>=) is enough too
15:26:36 <tehgeekmeister> wow, it took a long time for that git push to work.  this motel wifi is abominable.  six or so attempts before it succeeded.
15:26:51 <Peaker> because you have (==), so given (<) you also have (<=).  flip (<) gives you (>)
15:27:25 <trzkril> then min or max should work, too?
15:27:45 <c_wraith> even more inefficiently, sure. :)
15:27:58 <copumpkin> MyCatVerbs: nope
15:28:05 <copumpkin> not according to the docs
15:28:09 <roconnor> tehgeekmeister: I think you can replace "lift $ tell" with simply "tell"
15:28:12 <aavogt> hmm, but you can't have multiple default definitions though
15:28:15 <c_wraith> I suppose it's true.  Any of those functions can be derived from the rest.
15:28:18 <copumpkin> "Minimal complete definition: either compare or <=. Using compare can be more efficient for complex types."
15:28:37 <MyCatVerbs> copumpkin: snap.
15:28:44 <tehgeekmeister> (and i still haven't managed to load the busy beaver article!)
15:29:00 <copumpkin> tehgeekmeister: it's making your computer do the maximum amount of work before it shows it to you
15:29:04 <roconnor> tehgeekmeister: I think you should make \x -> tell [Item x] and \x -> tell [Target x]  into their own top level functions.
15:29:45 <tehgeekmeister> if anyone tried to message me, i think i missed it.
15:30:24 <roconnor> tehgeekmeister: I think you can replace "lift $ tell" with simply "tell"
15:30:26 <c_wraith> tehgeekmeister:  http://www.scottaaronson.com/writings/bignumbers.html is also a really good article on the busy beaver function
15:30:28 <roconnor> tehgeekmeister: I think you should make \x -> tell [Item x] and \x -> tell [Target x]  into their own top level functions.
15:32:39 <mmorrow> can anyone think of a more minimal way to do this (not that this isn't pretty minimal (??))
15:32:54 <mmorrow> err crap, i lost by copy/paste buffer
15:33:08 <mmorrow> @let roundup' this tothis = (this `rem` tothis) `mod` tothis
15:33:09 <lambdabot>  Defined.
15:33:14 <mmorrow> > roundup 15 4
15:33:15 <lambdabot>   Not in scope: `roundup'
15:33:20 <mmorrow> gah!
15:33:23 <mmorrow> wrong one
15:33:39 <mmorrow> @let roundup this tothis = tothis `rem` (this `rem` tothis)
15:33:40 <lambdabot>  Defined.
15:33:42 <mmorrow> > roundup 15 4
15:33:42 <lambdabot>   1
15:34:07 <roconnor> @type tell []
15:34:08 <lambdabot> forall a (m :: * -> *). (MonadWriter [a] m) => m ()
15:34:10 <mmorrow> (the amount to add the "this" to get to the nearest multiple of "tothis"
15:34:10 <mmorrow> )
15:34:16 <mmorrow> s/the/to/
15:34:51 <aavogt> > roundup 9 8
15:34:52 <lambdabot>   0
15:34:57 <mmorrow> heh
15:35:00 <roconnor> tehgeekmeister: tell [] ( and lift $ tell []) is also return ()
15:35:06 <mmorrow> hmm, right
15:35:10 <copumpkin> mmorrow: why not just negate the first parameter and mod it?
15:35:33 <mmorrow> , (\x n -> negate x `mod` n) 9 8
15:35:34 <lunabot>  7
15:35:39 <tehgeekmeister> roconnor: will change that, thanks.
15:35:41 <mmorrow> woot
15:35:45 <mmorrow> copumpkin: nice
15:36:12 <tehgeekmeister> roconnor: but how will it know which monad it's return ing in?
15:37:02 <copumpkin> :)
15:37:13 <roconnor> tehgeekmeister: lift $ return x  is always the same as return x
15:37:30 <roconnor> tehgeekmeister: such is the laws of monad transformers
15:37:44 <tehgeekmeister> okay
15:38:38 <tehgeekmeister> the lifts are unnecessary, you're right
15:38:45 <roconnor> tehgeekmeister: since return x has no effect, there is no need to state which layer the effects the happen at.
15:39:06 <roconnor> tehgeekmeister: typeclasses will automatically lift tell to the closest writer level
15:39:22 <tehgeekmeister> oh cool!
15:39:37 <tehgeekmeister> why doesn't that work with io?
15:40:00 <roconnor> tehgeekmeister: sort of because IO was designed before monad transformers
15:40:33 <tehgeekmeister> ah, so if it were redesigned using them it'd be automatic too?
15:40:33 <roconnor> tehgeekmeister: ideally all our IO functions would be of the form (MonadIO m) => a -> m b
15:40:55 <roconnor> probably
15:41:14 <roconnor> is nextBest supposed to return Nothing when head fails?
15:42:14 <kau> hello!
15:42:29 <roconnor> @src forM_
15:42:29 <lambdabot> forM_ = flip mapM_
15:42:38 <tehgeekmeister> roconnor: yes
15:42:45 <roconnor> tehgeekmeister: there is a new function called forM_ for flip mapM_
15:42:49 <tehgeekmeister> roconnor: in an earlier version it did
15:43:00 <aavogt> roconnor: but the ambiguous type variables!!
15:43:10 <Orclev> what's the function to get the length of a list?
15:43:20 <tehgeekmeister> roconnor: not in foldable, I don't think.
15:43:28 <aavogt> > length "orclev"
15:43:28 <Orclev> nevermind, found it
15:43:28 <lambdabot>   6
15:43:37 <roconnor> tehgeekmeister: use listToMaybe instead of head, and adjust your code appropriately
15:43:41 <Orclev> aavogt: thanks anyway
15:43:59 <roconnor> tehgeekmeister: nextBest = fmap fst . listToMaybe . ...
15:44:19 <roconnor> > head []
15:44:20 <lambdabot>   * Exception: Prelude.head: empty list
15:44:25 <aavogt> Orclev: yeah, it's something you can guess.
15:44:25 <roconnor> > listToMaybe []
15:44:26 <lambdabot>   Nothing
15:45:11 <kau> i have an odd problem: ghc infers a type for a function of mine and it works fine, but if i copy this type in the code, it won't compile anymore
15:45:12 <Peaker> listToMaybe is an annoying name for safeHead :)
15:45:22 <Orclev> aavogt: I tried len, and size, but for some reason length didn't occur to me
15:45:46 <tehgeekmeister> roconnor: what package is that in?  can't google it without leaving here, wifi died again
15:45:55 <roconnor> @index listToMaybe
15:45:55 <lambdabot> Data.Maybe
15:46:05 <tehgeekmeister> thanks
15:46:16 <roconnor> that's like the first time index has actually given me an answer!
15:46:56 <Peaker> @type listToMaybe
15:46:56 <lambdabot> forall a. [a] -> Maybe a
15:47:08 <roconnor> tehgeekmeister: with data-accessor your code would look a lot nicer I think, but you'd have to spend a little bit of time to learn the library.
15:47:09 <kau> have you seen that before?
15:47:23 <Peaker> @type foldr (const Just) Nothing
15:47:24 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
15:47:24 <lambdabot>       Expected type: a
15:47:24 <lambdabot>       Inferred type: Maybe a
15:47:30 <Peaker> @type foldr (const . Just) Nothing
15:47:31 <lambdabot> forall a. [a] -> Maybe a
15:47:50 <roconnor> tehgeekmeister: data-accessor has nice methods for modifying both record fields and modifying map entries, all in a uniform way.
15:47:58 <roconnor> tehgeekmeister: perfect for this.
15:48:02 <aavogt> > foldr (const . Just) Nothing $ 1:undefined
15:48:03 <lambdabot>   Just 1
15:48:42 <roconnor> tehgeekmeister: I should go make supper
15:48:49 <tehgeekmeister> ideally im going to refactor it enough that im not using the state monad in nearly the same way, so hopefully I won't need it as much, but I'll look at it and start getting familiar in case.  I seem to fall into this pattern whenever I use state.
15:49:01 <tehgeekmeister> roconnor: thanks for your help, then!
15:50:14 <tehgeekmeister> irc is not best used on a phone.  im just sayin'z
15:51:29 <roconnor> tehgeekmeister: ya, I still haven't entirely grasped what your code does.
15:51:44 <roconnor> making it shorter makes it easier to read too
15:51:49 <kau> ytehgeekmeister: you got an irc client on a phone?
15:52:01 <kau> what kind of phone?
15:52:42 <roconnor> tehgeekmeister: I'm sure there is some function for Set.length x = 0
15:52:53 <roconnor> @hoogle Set a -> Bool
15:52:53 <lambdabot> Data.Set null :: Set a -> Bool
15:52:53 <lambdabot> Data.Set valid :: Ord a => Set a -> Bool
15:52:53 <lambdabot> Data.Set findMax :: Set a -> a
15:53:02 <tehgeekmeister> roconnor: it's a port of some python code.  I can link you to it when not in my iPhone, or it's in jtaubers graded reader project on github? the next best.py
15:53:05 <roconnor> tehgeekmeister: S.null
15:53:12 <tehgeekmeister> kau: iPhone, colloquy
15:53:52 <roconnor> similarly ((>0) . length) x  is (not (null x))
15:53:58 <roconnor> (and much faster)
15:54:04 <kau> oh, Iphone, everybody goes mad about that (i don't get one ;)
15:54:22 <Orclev> is there a version of nub that takes a arbitrary function for the equality test?
15:54:33 <roconnor> @type nubBy
15:54:33 <sbahra> I get to use Haskell for the first time in a commercial project. \o/
15:54:34 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
15:54:45 <Orclev> roconnor: thanks, exactly what I was looking for
15:54:45 <Peaker> sbahra, what is the project?
15:54:58 <sbahra> Peaker, pretty trivial this portion.
15:55:05 <sbahra> Peaker, a daemon that will parse e-mails from an IMAP server.
15:55:12 <tehgeekmeister> Orclev: a lot of the list functions have a by version, such as sortBy
15:55:24 <roconnor> tehgeekmeister: apparently we are going out to eat, so I have a bit more time.
15:55:28 <sbahra> Peaker, into a structured entry to be inserted into an SQL database.
15:56:14 <tehgeekmeister> roconnor: okay.  basically it's a generating a graded reader by scoring items (words) and then adding the highest scoring item to the reader.
15:56:46 <roconnor> fromJust $ M.lookup target (targetsToItems st)) is your function (lookupItemsFromTarget st)
15:57:01 <kau> nobody about my question? how could haskell infer a type that i couldn't have writen myself?
15:57:12 <kau> it says: not in scope: type constructor or class `Numeric.LinearAlgebra.Interface.Mul'
15:57:44 <Peaker> kau, modules are allowed to expose values, but not expose the types of those values. In that case, use of the value will infer a type you cannot access directly
15:58:02 <Saizan> kau: it might just be that you didn't import that module
15:58:25 <sbahra> I'll be using HaskellNet and HTTP
15:58:26 <Saizan> kau: ghci has all the installed modules in scope if you use the full qualified name
15:58:41 <Saizan> kau: but that's only at the prompt
15:58:50 <kau> indeed, it is out of scope: Mul is a class that is unfortunately not exposed by hmatrix
15:59:02 <roconnor> tehgeekmeister: what's a reader?
16:00:01 <tehgeekmeister> roconnor: graded reader, like the books used for language learning.  orders words by how close they get you to being able o read the largest number of sentences.
16:00:28 <tehgeekmeister> I'll put all this on the wiki soon so I can stop explaining it, and have a more thorough explanation.
16:00:34 <roconnor> :)
16:00:35 <roconnor> ok
16:00:59 <roconnor> (1.0 / 2^^numMissing)
16:01:03 <roconnor> this is a bit strange
16:01:15 <tehgeekmeister> why?
16:01:28 <kau> Peaker, Saizan: yes the class is not visible, i guess i'll have to work on types...
16:01:33 <roconnor> oh nevermind
16:02:02 <aavogt> @type (^^)
16:02:03 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
16:02:04 <tehgeekmeister> the more unknown words in the sentence, the farther we are from being able to read it, so we weight against that
16:02:16 <kau> haskell infers a type that is too general (climbing up to the class) for me to work with...
16:02:49 <Peaker> kau, Why is it too general?
16:03:01 <Peaker> kau, can't you specialize at the time of use?
16:03:02 <copumpkin> how can something be too general?
16:03:14 <aavogt> , time (1 / 2^^(-12345))
16:03:16 <lunabot>  (0.0,Infinity)
16:03:17 <copumpkin> unless it's inferring rank-n types for you :P
16:03:19 <roconnor> tehgeekmeister: I'd use Rational explicitly to avoid the errors by ending up with Double.
16:03:21 <aavogt> , time (1 / 2^^(-123))
16:03:23 <lunabot>  (0.0,1.0633823966279327e37)
16:03:27 <copumpkin> but I guess that'd still be less general
16:03:34 <aavogt> , time (replicate 1000 $ 1 / 2^^(-123))
16:03:37 <lunabot>  (0.0,[1.0633823966279327e37,1.0633823966279327e37,1.0633823966279327e37,1...
16:03:54 <roconnor> changing to `scoreTarget :: S.Set String -> M.Map String Rational' and the like is sufficent.
16:03:59 <dancor> :t time
16:04:00 <lambdabot> Not in scope: `time'
16:04:28 <kau> Peaker: the class is not exposed, instances of that class are exposed
16:04:36 <tehgeekmeister> @type (**)
16:04:37 <lambdabot> forall a. (Floating a) => a -> a -> a
16:05:05 <kau> Peaker: the inference system uses the class in the inferred type
16:05:54 <kau> Peaker: i cannot do that on my side!
16:06:37 <aavogt> leave the signature out?
16:06:43 <Peaker> kau, is that a problem? let it infer
16:07:13 <kau> Peaker: oh, that's because the inferred signature is wrong ;) for my need
16:07:30 <Peaker> kau, Why is a type more general wrong for you?
16:07:32 <tehgeekmeister> roconnor: okay, did that.  what's your most general advice to how to approach making this more elegant and functional?  currently it's a straight port of an imperative algorithm, and slow and clunky as a result.
16:07:53 <kau> Peaker: it says: Numeric.LinearAlgebra.Interface.Mul a a a and i want: Numeric.LinearAlgebra.Interface.Mul a b c
16:08:05 <tehgeekmeister> the algorithm is as stateful as can be, tho, so making it more functional is tricky
16:08:36 <roconnor> tehgeekmeister: again, that is a bit hard to do without knowing what it is you are doing. :)
16:08:40 <Saizan> kau: given that the latter is more general you probably wouldn't be able to give that signature to that term
16:09:10 <roconnor> tehgeekmeister: I think we can remove state from makeMap
16:09:12 <roconnor> to begin with
16:09:31 <kau> Saizan: i gues that's right
16:09:33 <tehgeekmeister> roconnor: touché.  I'll get back to you once I can post a good description.  or there is one on the graded reader google group.
16:09:41 <Orclev> tehgeekmeister: I'm probably about a quarter of the way done with it currently
16:09:47 <mmorrow> computing C struct layouts is slightly tricksy, (considering arbitrarily nested structs, unions, etc) where the internal padding is depends on the sizes of all the nested things, but the sizes of the nested things (in the case of structs) depends on where/how much internal padding there is
16:09:48 <roconnor> tehgeekmeister: firstly let's do: makeMap :: [(Int, String)] -> ReaderMaps
16:09:59 <tehgeekmeister> roconnor: probably can!  I used it there cos I thit it more convenient
16:10:01 <tehgeekmeister> okay
16:10:05 * mmorrow tries to untangle the knot
16:10:28 <roconnor> tehgeekmeister: put the execState right into the makeMap function
16:10:41 <roconnor> tehgeekmeister: and remove it from main
16:10:50 <roconnor> (this is the first refactoring transformation step)
16:11:09 <roconnor> tehgeekmeister: once this is done and works we will totally rewrite makeMap
16:11:33 <kau> Saizan: is it possible to extend a module like in C++ heritage?
16:11:44 <kau> to make it fit my need ;)
16:11:48 <Saizan> kau: i don't know what c++ heritage is
16:12:00 <kau> sorry
16:12:14 <copumpkin> inheritance?
16:12:27 <kau> yes
16:13:10 <copumpkin> kau: what do you mean by a module?
16:13:24 <copumpkin> you can do things that vaguely resemble inheritance, but they're mostly quite different
16:13:44 <tehgeekmeister> roconnor: done!
16:13:52 <kau> i hope this question is not politicaly incorrect ;)
16:14:14 <copumpkin> kau: not at all, just curious what you mean :P for us, modules are collections of code (and they aren't parametrized over anything)
16:14:24 <roconnor> tehgeekmeister: okay, now we are going to write a generic function [(a,b)] -> M.Map a (S.Set b)
16:14:32 <blackdog> kau: modules are just namespaces
16:14:36 <blackdog> in haskell, anyway
16:15:26 <kau> OK, i just want to extend hmatrix's module to make it expose the "Mul" class that i need
16:15:56 <sbahra> Hrm.
16:15:58 <copumpkin> kau: oh, then nope :)
16:15:59 <tehgeekmeister> roconnor: oh, and generate each map separately?  doesn't that require we iterate thru pairs twice?
16:16:03 <sbahra> Could someone verify that HaskellNet is working?
16:16:07 <sbahra> I installed it from cabal.
16:16:08 <tehgeekmeister> or is that not a big deal?
16:16:16 <roconnor> tehgeekmeister: hmm
16:16:18 <sbahra> s/from/using/
16:16:24 <sbahra> Prelude> :module +HaskellNet.IMAP
16:16:24 <sbahra> Could not find module `HaskellNet.IMAP':
16:16:40 <Peaker> kau, modules are just dumb containers.  Lets talk about the things that are inside the modules
16:16:58 <Peaker> kau, You have a Mul class, and a Matrix type, and you want Matrix to be an instance?
16:17:12 <kau> copumpkin: that's to bad, that library is just fine exept i can't access that Mul class!
16:17:13 <Saizan> sbahra: does ghc-pkg list shows the package?
16:17:14 <aavogt> :t M.insertWith S.union . map (second S.singleton)
16:17:15 <lambdabot> forall a b d. (Ord a, Ord d, Ord b) => [(d, b)] -> S.Set a -> M.Map [(d, S.Set b)] (S.Set a) -> M.Map [(d, S.Set b)] (S.Set a)
16:17:34 <tehgeekmeister> roconnor: I add the item/target pair to both maps at the same time
16:17:35 <roconnor> tehgeekmeister: you make a fair efficency point.
16:17:52 <Saizan> Peaker: he doesn't really have the Mul class because it's not exported :)
16:18:07 <roconnor> roconnor: okay, let's leave it as you have
16:18:09 <sbahra> Saizan, no.
16:18:15 <roconnor> tehgeekmeister: : okay, let's leave it as you have
16:18:24 <roconnor> tehgeekmeister: at least it has a "pure" interface
16:18:26 <Saizan> sbahra: something has gone wrong during installation then
16:18:26 <aavogt> :t foldr (uncurry (M.insertWith S.union)) M.empty . map (second S.singleton)
16:18:27 <lambdabot> forall a a1. (Ord a, Ord a1) => [(a1, a)] -> M.Map a1 (S.Set a)
16:18:32 <roconnor> tehgeekmeister: that is a small improvement I think.
16:18:36 <kau> Peaker: i would like to use Mul in one of my function's signature to make it more general
16:18:42 <Peaker> Saizan, why would people not export that?
16:18:44 <sbahra> Saizan, not according to cabal.
16:18:44 <Saizan> sbahra: did you run cabal install as a different user, perhaps?
16:18:45 <roconnor> tehgeekmeister: I have to go now I'm afraid.
16:18:51 <blackdog> kau: knowing nothing about it - you could just rewrite the top module to export the Mul typeclass. there might be a good reason not to export it, or it might just be an oversight...
16:18:55 <sbahra> Saizan, let's see.
16:18:57 <Peaker> gotta go
16:19:01 <tehgeekmeister> roconnor: well thanks for all your help!  I appreciate it.
16:19:06 <copumpkin> kau: you could email the author and ask him to export it :)
16:19:26 <copumpkin> kau: or exploit hackage's low security and replace his version with yours, containing an exported version of Mul
16:19:30 <kau> copumpkin: i'm planning to do that ;)
16:19:34 <copumpkin> ;)
16:19:38 <blackdog> and for the moment, cabal unpack, hack, and install:)
16:21:12 <Saizan> though, for code that doesn't user higher-ranks, ghci will find the most general signature
16:21:30 <dancor> tehgeekmeister: sorry to jump in; is the problem that given (known-words, bunch-of-passages, n), we want to find n passages that add the fewest new-words?
16:21:33 <Saizan> so you can't just give a more general signature and expect it to typecheck
16:22:40 <kau> so, without touching the existing library, this is not feasible?
16:23:04 <tehgeekmeister> dancor: I think so, but I think of it the other way around.  order words so that each word learned is the one that allows you to understand thr largest number or sentences
16:23:17 <aavogt> kau: I'm guessing that you have to explicitly convert the types of these matrices to the same type
16:23:18 <copumpkin> kau: not as far as I know, nope
16:25:06 <tehgeekmeister> dancor: and feel free to jump in!  I welcome any help.
16:26:01 <dancor> tehgeekmeister: so is it actually n=1
16:26:41 <dancor> are we just finding one next passage out of all the possible remaining passages
16:26:56 <dancor> i wasn't sure if a "reader" was n-passages or just 1
16:27:19 <tehgeekmeister> the next passage out of all, and repeating until they're all exhausted
16:27:29 <dancor> you could imagine that optimizing for n=10 is different than iteratively doing n=1
16:27:33 <dancor> ok
16:27:38 <tehgeekmeister> it's like a graded reader for language learning.  the books they sometimes use.
16:28:08 <tehgeekmeister> dancor: you can't do ten at a time, this algorithm is inherently iterative
16:28:12 <tehgeekmeister> for better or worse
16:28:40 <tehgeekmeister> (I think worse.  I swear there has to be a graph theory style solution to this)
16:28:54 <aavogt> @type iterate
16:28:55 <lambdabot> forall a. (a -> a) -> a -> [a]
16:29:10 <tehgeekmeister> (which I could probably program a lot more elegantly in haskell)
16:29:45 <tehgeekmeister> > iterate (+1) 1
16:29:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:29:55 <tehgeekmeister> haha, that's cool!
16:29:57 <dancor> tehgeekmeister: well it's not hard to find an example showing that n=1 twice is worse than n=2 i think
16:30:01 <dancor> but it's probably good enough
16:30:06 <dancor> and a simpler problem
16:30:18 <dancor> the more general problem seems kind of cool tho :)
16:30:26 <tehgeekmeister> dancor: I do not follow, please explain
16:31:06 <aavogt> the question is which sequence of exercises introduces the minimum number of new words?
16:31:18 <dancor> aavogt: yes
16:31:20 <tehgeekmeister> I imagine the sentences and words as a dependency graph.  there's gotta be a way to order dependencies efficiently like this
16:31:43 <tehgeekmeister> minimize new words, maximize sentences
16:31:55 <tehgeekmeister> eventually exhaust both
16:32:30 <kau> here it is:
16:32:32 <kau> module Numeric.LinearAlgebra.Interface((<>) (...)) where
16:32:36 <aavogt> well, you don't want the results to be deterministic either
16:32:41 <kau> class Mul a b c | a b -> c where (<>) :: Element t => a t -> b t -> c t
16:32:48 <kau> instance Mul Matrix Matrix Matrix where  (<>) = multiply
16:32:55 <kau> instance Mul Vector Matrix Vector where  xxxx etc.
16:33:02 <kau> i would like to write a function that is a wrapper for (<>) and applies to all instances of Mul...
16:33:12 <aavogt> since that means people won't try the exercises again
16:33:14 <kau> sory for the flood
16:33:23 <tehgeekmeister> aavogt: why not?  there's a single most efficient solution, up to ordering of words between sentences
16:33:31 <tehgeekmeister> aavogt: they aren't exercises
16:33:38 <Saizan> kau: isn't that just <> itself?
16:33:41 <Berengal> There are three libraries doing what I want; one of them has an API that lies in IO, one doesn't, but uses unsafePerformIO and throws exceptions everywhichway when it fails and one has a very low-level API that's maybe just as easy to reimplement
16:33:55 <Berengal> Is this a valid reason to write another library myself?
16:34:01 <tehgeekmeister> you're ordering words to learn to maximize sentences comprehensible at each step
16:34:33 <Saizan> Berengal: if you think you can do better, i'd say so
16:35:04 <pastorn> Berengal: what's wrong with the one that uses IO bindings?
16:35:07 <kau> Saizan: i have to use Mul in the type signature to allow my function to work on every kind of product...
16:35:29 <pastorn> at least i would prefer that, exceptions are never fun
16:35:36 <Saizan> kau: you could just not write the signature
16:35:42 <Berengal> Saizan, I don't know if I can. It's a bit work, which increases chances of failure, since I'm lazy
16:36:01 <Saizan> Berengal: which are the libraries, actually?
16:36:03 <Berengal> pastorn, it uses IO bindings where pure functions should suffice
16:36:27 <lilac> kau: "(<>) :: (Mul a b c, Element t) => a t -> b t -> c t" -- is that what you want?
16:36:35 <Berengal> Saizan, yaml, HsSyck and YamlReference
16:37:02 <Berengal> yaml looked nice, until I was getting IO exceptions in the Maybe monad...
16:37:23 <lilac> Berengal: if it's really pure, you could wrap the IO one in unsafePerformIO ;-)
16:37:39 <Berengal> lilac, that's what yaml did.... it didn't work out that well for me
16:37:51 <Berengal> Both yaml and HsSyck are bindings to c libraries
16:38:06 <Berengal> I don't know if HsSyck really is pure or not...
16:38:19 <lilac> Berengal: sounds like they didn't do a good job of converting exceptions into values
16:38:49 <Saizan> a parser for yaml is a lot of work to write?
16:39:06 <Berengal> Saizan, I dunno... never done indentation-based parsing before
16:39:27 * Saizan neither
16:39:32 <kau> lilac: yes, a b c being what i decide
16:39:37 <Saizan> i guess you'd do that at the lexing stage
16:39:41 <Berengal> Besides, I've had it up to my neck in half-way implementations, and want to make one that's to spec
16:39:54 <tehgeekmeister> I think parsec could handle that?
16:40:06 <Berengal> (implementations in general, not yaml specifically)
16:40:10 <kau> lilac: in fact i am trying to make dimension aware vectors and matrices
16:40:21 <aavogt> tehgeekmeister: I would settle for an approximate solution: generate a list of word frequencies, sort your list of sentences by the popularity of the words being used, and then try some other optimization approach afterwards, if necessary
16:40:35 <lilac> Berengal: i'd build something on YamlReference myself (as it claims to be "the" reference implementation of YAML)
16:40:40 <deech> Hi all, I am trying to read some UTF strings from a database. I am using Codec.Binary.UTF8.String.decodeString to read it. This compiles but I get a runtime error "tag (8217) is outside of bounds (0,255)". What does this mean?
16:41:01 <kau> lilac: os i wrapped my vectors and matrices into a type that carry dimension
16:41:01 <tehgeekmeister> aavogt: that solution ends up being painfully bad.  something like fifty words before you can read a single sentence.
16:41:07 <dancor> tehgeekmeister: let texts = [[a,b],[a,c],[b,c],[b,a],[d,e],[d,f],[d,g]] :: [[Word]] and knownWords = [d].  if you grab texts three at a time (say each set of three texts is a "volume" in our language-reader series) then you would grab [a,b],[a,c],[b,c],[b,a] first which is more bang-for-your-buck than if you grab one a time getting [d,e] then [d,f] then [d,g].
16:41:14 <Berengal> lilac, I'd just be parsing the token stream same as I would parse a character stream... It does remove the indentation problem though
16:41:35 <Saizan> deech: it seems the String you're trying to decode is already formed of unicode codepoints
16:41:38 <tehgeekmeister> aavogt: as you progress it's the same as this algorithm.  check out the graded reader google group
16:41:58 <aavogt> tehgeekmeister: did your weighting normalize for the length of each sentence?
16:42:10 <dancor> so i think grouping has a, probably ignorable, effect on the optimal solution.
16:42:17 <ziman> w00t, i've just successfully run a factorial program written in C++ as a hylomorphism, using some template stuff :)
16:42:35 <tehgeekmeister> aavogt: no, but it could.  im copying an algorithm right now, not innovating
16:42:43 <deech> Saizan: I see ... let me recheck my db. Thanks .
16:43:42 <tehgeekmeister> aavogt: what do these lists represent?
16:44:00 <benhiller> Hi, I've been trying to use HOpenGL on Snow Leopard, but whenever I try to compile I get lots of errors about undefined symbols... any ideas what could be causing it?
16:44:01 <lilac> Berengal: ugh, YamlReference appears to have a pretty much useless interface
16:44:07 <aavogt> tehgeekmeister: which lists?
16:44:17 <Berengal> lilac, I said that, didn't I? :P
16:44:29 <tehgeekmeister> the ones in your example up there?
16:45:32 <lilac> Berengal: you said it was low level. did you also mention that half of the interface is not actually usable?
16:46:08 <kau> i have to go, goodbye to everyone
16:46:17 <tehgeekmeister> aavogt: if you check the graded reader google group, it'll give you a lot to go off of about the base line approaches to solving this problem.  the only better one I know of is brute force, so far.
16:46:32 <dancor> tehgeekmeister: me?  texts is the list of all possible texts which are each just represented as a list of words for my example.
16:46:36 <lilac> like, for instance, why is 'Code' and its constructors exported? you can't convert a Token to a Code (or create one in any useful way)
16:46:52 <Berengal> lilac, I might've forgotten that part... it seems Token is opaque, which pretty much makes the entire thing useless
16:46:57 <tehgeekmeister> search all permutations until you find the best
16:47:03 <tehgeekmeister> dancor: oh, oops.
16:47:07 <tehgeekmeister> yes you
16:47:10 <lilac> Berengal: right, basically all you can do with tokens is show them.
16:47:21 <Berengal> Hooray... -_-
16:47:29 <lilac> Berengal: but you can figure out /which/ token you showed by showing all the Code constructors and comparing :)
16:47:49 <tehgeekmeister> dancor: im not sure I follow your example.  my algorithm doesn't even operate on multiple texts to start with!
16:47:57 <Saizan> you can hack on it.
16:48:01 <Berengal> Somehow I get the feeling I'll be reading the yaml BNF pretty soon
16:48:34 <dancor> tehgeekmeister: you don't have a stock list of all the texts/passages/sentences/whatever that might be included in the next reader?
16:48:41 <lilac> Berengal: if you took the source to YamlReference you could probably get something useful in a few minutes, is the sad thing
16:48:49 <Berengal> Saizan, the code is LGPL, which is ordinarily fine by me, but I'd like something BSD if I were to put it on hackage
16:49:39 <tehgeekmeister> dancor: it operates on arbitrary texts, once they've been processed into the right format.  we just use sentences from real text.
16:50:35 * tehgeekmeister used the agpl for the first time today, and is still uncertain about whether he likes the idea
16:50:50 * Saizan wonders why the meta variables for lambda calculus terms are generally M and N
16:51:02 <dancor> m for meta?
16:51:23 <Saizan> oh, that might be it
16:51:40 <halcyon10> hi, i'm still a monad beginner and am trying to use the PRNG in Bryan O'Sullivans new statistics package to create a list of random doubles, but it seems that i have done a really basic mistake, could anybody tell me what i did wrong? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9680#a9680
16:51:45 <lilac> Saizan: maybe because L is already used? :)
16:52:35 <Saizan> halcyon10: can you annotate with the error?
16:53:01 <lilac> Data.Binary.decode seems to raise an exception on a format error. what do people do about this? catch? or is there a better way?
16:53:09 <Saizan> halcyon10: oh, you didn't give an argument to randomDoubles
16:53:36 <halcyon10> oh, forgot to mention the error, updated the paste http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9680#a9681
16:54:01 <Saizan> lilac: let me know if you find one :)
16:54:07 <tehgeekmeister> im gonna head out guys; got work in the morning, don't think I'll do any productive coding at this point anyway.
16:54:21 <halcyon10> Saizan: oops, your right, but theres still another problem with the IO monad and the xs
16:54:28 <tehgeekmeister> thanks everyone for helping!
16:54:45 <lilac> it strikes me that one could easily make a zero-overhead exception monad using a little unsafePerformIO catch and newtype ExceptionMonad a = EM a
16:54:52 <Saizan> halcyon10: really? even after you give it the argumnet?
16:55:43 <halcyon10> Saizan: you were right, it was really the missing argument, sorry for the stupid mistake *doh*
16:55:51 <halcyon10> now it works
16:56:03 <Saizan> halcyon10: heh, np, the error message wasn't that helpful
16:56:12 <halcyon10> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9680#a9682
16:56:32 <Azstal> lilac: might that catch asynchronous exceptions too?
16:57:55 <lilac> Azstal: not if you use your own exception type and don't export the constructor
16:58:06 * lilac working on a proof-of-concept
17:00:03 <Axman6> dons: if you're around, i'll have a rather long blog past on using OpenCL from haskell (and how it's insanely fast)
17:03:07 <ivanm> Axman6: you'd rather have that then...?
17:03:18 <ivanm> (or should that be "than"? *shrug*)
17:03:56 <Axman6> there should be a soon on the end of that
17:05:05 <bjorkintosh>  b
17:05:09 <bjorkintosh> oops.
17:07:28 <augur> aww
17:07:31 <augur> conal not here? :(
17:07:33 <Claudius1aximus> joy. i translated a 750-line OpenGL/C program to OpenGLRaw/Haskell, it segfaults immediately :-[  is there any way to use GLEW with OpenGLRaw/Haskell?
17:08:22 <tommd> Axman6: Using OpenCLRaw package?
17:08:53 <augur> ok bye nevermind
17:11:18 <lilac> does 'seq' or 'pseq' give any guarantees regarding which exceptions an expression will generate?
17:11:38 <lilac> (that is, if the LHS and RHS both produce exceptions, might i still get either?)
17:12:31 <c_wraith> well, it guarantees ordering.  You should get an exception raised from the LHS only if there isn't one from the RHS.
17:12:35 <Cale> pseq does, seq does not
17:12:48 <Cale> (this is one of the main differences between them)
17:12:52 <c_wraith> err.  swap that.
17:12:58 <c_wraith> I still don't know the difference between left and right
17:13:33 <lilac> Cale: thanks :)
17:14:04 <ray> c_wraith: if you look at the backs of your hands, left makes an "L"
17:14:47 <byorgey> augur: I guess not. you can leave a message for him with lambdabot, by typing  @tell conal <message>
17:14:53 <c_wraith> I don't have time for silly abstractions like "physical definitions"
17:14:59 <SamB_XP> ray: maybe he can only tell which way an L goes because that's the only way we write them ?
17:15:44 <byorgey> ray: what if you also can't tell the difference between front and back? ;-)
17:15:51 <SamB_XP> on the otherhand, the bible does not imply good things about those who cannot tell their left hand from their right
17:16:00 <ray> the convex side
17:16:25 <SamB_XP> byorgey: also, the side with the fingernails on is the back
17:16:40 <ray> the convex, befingernailed side
17:16:40 <lilac> what module is class 'Data' defined in?
17:16:43 <dancor> c_wraith: you probably don't have a good sense of matter/antimatter or future/past either!
17:16:58 <SamB_XP> dancor: nonsense
17:16:59 <c_wraith> I definitely can't tell matter and antimatter apart.
17:17:11 <Cale> "befingernailed" is an awesome word
17:17:12 <c_wraith> And I have trouble with now, let alone any other time
17:17:14 <SamB_XP> antimatter is the stuff which, when you collide with it, you cease to be afterwards
17:17:27 <ray> i can't tell future and past apart
17:17:32 <ray> i must be a quantum physicist
17:17:37 <Cale> http://blog.peta.org/ -- this is hilarious
17:17:38 <heatsink> @source Data
17:17:38 <lambdabot> Data not available
17:17:56 <SamB_XP> incidentally, you folks should consider careers as photons
17:17:57 <Cale> (specifically, the name of the blog)
17:18:12 <monoidal> LYAH mentions that it is possible to zip an infinite number of lists. anybody know how?
17:18:23 <Orclev> hmm... I've got a fairly small list I'm trying to sort, but I'm getting a stack overflow when I attempt it
17:18:26 <aavogt> monoidal: transpose?
17:18:29 <ray> lol
17:18:29 <dancor> SamB_XP: don't you enjoy space and time having meaning for you
17:18:44 <byorgey> Cale: hehe
17:18:45 <Cale> Orclev: How small?
17:18:48 <Orclev> hmm, oh, must be a problem with my Ord instance
17:18:57 <SamB_XP> dancor: well, I can at least tell the one from the other most of the time ;-P
17:19:12 <Cale> Orclev: that seems likely, if you can print the list on its own
17:19:29 <Orclev> Cale: really small, like 9 elements, so, yeah, problem with my Ord instance
17:19:58 <Cale> Orclev: The only other possibility is that computing one of the elements on its own causes a stack overflow
17:20:14 <byorgey> Orclev: a minimal Ord instance must contain either <= or compare, otherwise you'll get infinite loops.
17:20:32 <byorgey> by which I mean infinite recursion.
17:21:01 <Orclev> byorgey: I've got (<),(>), and (==), that enough?
17:21:11 <byorgey> for example, although you might think it would be sufficient just to define (<), doing so will cause infinite recursion that takes a whole afternoon to track down.
17:21:16 <byorgey> not that I'm bitter or anything.
17:21:19 <byorgey> Orclev: no, it isn't!
17:21:21 <c_wraith> Orclev: no.  The definitions are all in terms of <= or compare
17:21:33 <byorgey> you must define (<=) or compare.  you can also define (<) and (>) if you like.
17:21:48 <c_wraith> Orclev: and the definition of <= is in terms of compare, and vice versa
17:21:58 * aavogt wonders whether a compiler could be instructed to warn when the default instances of a class won't terminate
17:21:59 <c_wraith> Orclev: If you don't define one of those two, you get infinite recursion
17:22:30 <SamB_XP> Orclev: you should have read the Report ;-P
17:22:42 <aavogt> @docs Prelude
17:22:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
17:22:46 <monoidal> aavogt: I thought it is transpose, but is written "There's also a very clever way for zipping infinite numbers of lists, but we're not advanced enough to cover that just yet." AFTER transpose was introduced. i thought it is another trick
17:22:53 <monoidal> *it is
17:23:06 <byorgey> it's in the Prelude docs.  but Ord seems so simple, I don't blame anyone for thinking they don't have to read the docs.
17:23:26 <byorgey> I mean, it IS simple, but contains this tiny hidden gotcha.
17:23:28 <SamB_XP> byorgey: I bet they just ripped those out of the Prelude from the Report!
17:23:34 <heatsink> monoidal: ...but unfortunately this margin is too small to contain it.
17:23:38 <Orclev> actually I asked on here earlyer and I was told the minimum is (<) or (<=) and (>) or (>=)
17:23:38 <byorgey> they probably did.
17:24:07 <c_wraith> Orclev:  semantically, any one of those will suffice.  But the code isn't written that way (and can't be, honestly)
17:24:28 <ray> i always write compare
17:24:28 <byorgey> monoidal: what do you mean by 'zip' an infinite number of lists?
17:24:29 <SamB_XP> what about == and <?
17:24:44 <aavogt> :t fix zip
17:24:45 <lambdabot>     Couldn't match expected type `[a]'
17:24:45 <lambdabot>            against inferred type `[b] -> [(a, b)]'
17:24:45 <lambdabot>     In the first argument of `fix', namely `zip'
17:24:49 <c_wraith> SamB_XP: == is required already, since Ord requires Eq
17:25:23 <byorgey> Orclev: who told you that?  they must be found and given a beating with the Stick of fail
17:25:24 <SamB_XP> stop gunking up my math nits with your typeclasses
17:25:41 <SamB_XP> byorgey: not Control.Monad.fail!
17:25:46 <byorgey> oh yes!
17:25:47 <SamB_XP> oh, the horror!
17:26:17 <c_wraith> Semantically, given the Eq constraint, every function in the Ord typeclass can be used to implement the rest.  But the code isn't arranged that way, nor can it be.
17:26:26 * aavogt wonders why Control.Monad.fail isn't a blog yet
17:26:46 <monoidal> byorgey: I'm trying to figure out what that quoted sentence could mean. Naively I'd use transpose, just it is suggested that something other, clever is used
17:26:47 <SamB_XP> aavogt: nobody wants to write a blog with such a sad name ?
17:27:13 <aavogt> SamB_XP: well eventually the rest of that namespace will be taken :)
17:27:13 <SamB_XP> c_wraith: I know that ;-P
17:27:15 <byorgey> monoidal: oh, you mean interleave them into a single list?  in that case, it's probably referring to diagonalization.
17:27:22 <SamB_XP> aavogt: nonsense
17:27:23 <dancor> c_wraith: why can't it be?
17:27:34 <Orclev> hmm... I've got a question, in a OO language you refere to the instance of a class as an object, what's the instance of a data type refered to in haskell?
17:27:38 <SamB_XP> the namespace is countable, but infinite
17:27:39 <byorgey> monoidal: imagine arranging the lists in an infinite 2D grid, then start reading off the diagonals.
17:27:43 <c_wraith> Hmm.  I guess it could be, if you made them into a circular dependency chain.
17:27:45 <monoidal> oh, very probable, thanks
17:27:53 <c_wraith> That would be kind of silly, though. :)
17:28:02 <byorgey> monoidal: i.e. the first element of the first list, then then first element of the second list and the second element of the first list, then the first element of the third list...
17:28:05 <dancor> ya i thought circular class defaults ruled the day
17:28:10 <monoidal> yes :)
17:28:24 <SamB_XP> c_wraith: make oleg do it ;-P
17:28:38 <c_wraith> The class has 7 functions.  That seems inefficient for some functions. :)
17:29:19 <heatsink> monoidal, The paper "Do we need dependent types?" gives the example of an arbitrary-arity zipWith.
17:29:35 <monoidal> I read it, it's very interesting
17:29:37 <dancor> oh you can't make any one work because you can only supply a fixed default for each one
17:29:43 <byorgey> Orclev: a 'value of type X', I guess.  there isn't really a special term for it.
17:29:56 <dancor> so you could make a crazy chain thru them.  got it
17:30:10 <dancor> calling == over and over
17:30:11 <c_wraith> Yeah.  you'd need a single circular dependency chain.
17:30:19 <c_wraith> and it would be horribly inefficient
17:30:52 <c_wraith> Admittedly, I'm surprised they chose (<=) rather than (<)
17:30:58 <bwr> Hi, I am trying to setup lighttpd for haskell fastcgi... Do I need an entry in my lighttpd.conf file for each haskell fastcgi app i have?
17:31:07 <ray> <= makes sense
17:31:20 <SamB_XP> ray: since when do you make sense ?
17:31:31 <ray> =o
17:32:34 <c_wraith> I just think a <= b = a < b || a == b is simpler than a < b = a <= b && not (a == b)
17:33:08 <dancor> =o is a cool operator waiting to happen
17:33:24 <c_wraith> Not in haskell.  o isn't an operator character.
17:33:27 <blackdog> a duck operator!
17:33:28 <SamB_XP> dancor: except the syntax doesn't work ;-P
17:33:28 <dancor> ya
17:33:37 <c_wraith> =。
17:33:40 <c_wraith> How about that?
17:33:46 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9686#a9686 <-- evil lightweight exception monad
17:33:50 <blackdog> if you could package it as a pair... =o and >o
17:33:59 <Orclev> lol @ blackdog
17:34:04 <ray> ordering relations are traditionally <=
17:34:10 <ray> that''s probably why it's theone
17:34:14 <ray> man, i can't type
17:34:19 <Orclev> blackdog: needs a third function, quack
17:34:31 * lilac ponders if it's possible to tell that monad isn't really implemented as Either e
17:34:37 <mmorrow> bwr: http://mult.ifario.us/p/wiring-haskell-into-a-fastcgi-web-server
17:34:41 <blackdog> hm. quack :: a -> b
17:34:44 <byorgey> @query lambdabot
17:34:44 <lambdabot> Unknown command, try @list
17:34:44 <blackdog> duck typing!
17:34:57 <byorgey> whoops
17:36:15 <bwr> mmorrow: I am looking at that currently. My question is that the lighttpd.conf configuration section mentions the haskell fast cgi app explicitly. Is there a way where I don't need an entry in lighttpd.conf for each haskell fastcgi app?
17:37:05 <mmorrow> bwr: i thought that was how lighttpd worked (an entry for each fastcgi app), but i'm not positive (that's how i've done it in the past)
17:37:26 <mmmulani> how do I create an infinite list of random numbers from 0 - 10?
17:37:36 <mmorrow> bwr: the lighttpd docs have a fastcgi section (although i've read that in the past (don't remember details though))
17:37:41 <SamB_XP> perhaps some form of wildcards are supported, but it wouldn't lead to the nicest URLs
17:37:46 <aavogt> @type randomRIOs
17:37:46 <lambdabot> Not in scope: `randomRIOs'
17:37:52 <aavogt> @type System.Random.randomRIOs
17:37:52 <Saizan> > randomRs (0,10) (mkStdGen 42) :: [Int]
17:37:52 <lambdabot> Not in scope: `System.Random.randomRIOs'
17:37:53 <lambdabot>   [4,9,3,3,5,8,6,5,4,8,4,8,6,5,3,4,8,5,7,1,10,10,5,3,5,4,6,5,7,9,1,6,6,4,4,2,...
17:37:57 <bwr> mmorrow: ok thanks
17:38:00 <mmmulani> whoa
17:39:00 <jfredett> in the IO world, you'd need to do, `do {g <- getStdGen; return $ randomR (0,10) g}` (that way you get new randoms every time.)
17:40:11 <ivanm> though isn't getStdGen rather expensive?
17:40:33 <ivanm> and isn't it newStdGen? :p
17:40:36 <ivanm> @hoogle getStdGen
17:40:36 <lambdabot> System.Random getStdGen :: IO StdGen
17:40:40 <ivanm> ahhh, maybe not
17:40:44 <ivanm> @hoogle newStdGen
17:40:44 <lambdabot> System.Random newStdGen :: IO StdGen
17:41:13 <dancor> @let a =@ b = "lol"
17:41:14 <lambdabot>  Defined.
17:41:31 <Saizan> you should use newStdGen, actually
17:41:53 <Saizan> and then randomRs not randomR to get your infinite list
17:42:28 <heatsink> (=@), the deluxe cousin of linear implication.
17:42:50 <m4ik3ru> Howdy!
17:42:55 <jfredett> Saizan: yes, this is true, I haven't used random in a while though.
17:45:19 <coco> how does pattern matching interact with the Eq type class?
17:45:55 <coco> numeral constants seem to be patterns modulo (==). anything else?
17:46:54 <aavogt> coco: string constants
17:47:08 <aavogt> well, litterals to be more precise
17:47:36 <Saizan> those only with OverloadedStrings or something like that
17:47:42 <coco> yes, including those in the Num type class, that call fromInteger...
17:48:15 <aavogt> > case "hello" of "yes" -> False; "hello" -> True
17:48:16 <lambdabot>   True
17:48:22 <aavogt> wew
17:49:26 <coco> it also works with funny instances of Eq
17:50:19 <aavogt> Saizan: lambdabot isn't using -XOverloadedStrings though
17:50:38 <aavogt> :t ""
17:50:39 <lambdabot> [Char]
18:02:55 <Orclev> did tehgeekmeister ever get his code rewritten in a satisfactory manner?
18:03:48 <seydar> does anyone use geometer's sketchpad?
18:05:37 <SamB_XP> seydar: someone must!
18:05:47 <SamB_XP> I believe I use kseg, myself
18:08:58 <SamB> and kseg is still apparently using qt3, so it's nice and slim to install ;-)
19:02:46 <beutdeuce> anyone here familair with mathematica?
19:02:54 <beutdeuce> actually
19:02:59 <beutdeuce> nvm thay, i'll give i a try in haskell
19:03:05 <beutdeuce> lol
19:04:30 <beutdeuce> can someone please remind me how to read a file by line
19:04:59 <wdonnelly> readFile >> lines?
19:05:11 <beutdeuce> into an array?
19:05:12 <copumpkin> >>=
19:05:14 <wdonnelly> >>= even
19:05:14 <copumpkin> or rather
19:05:15 <copumpkin> fmap
19:05:30 <sm> test
19:05:47 <copumpkin> :t \x -> lines <$> readFile x
19:05:47 <lambdabot> FilePath -> IO [String]
19:06:27 <copumpkin> :t return . lines <=< readFile
19:06:28 <lambdabot> FilePath -> IO [String]
19:07:26 <beutdeuce> thnx
19:07:44 <ManateeLazyCat> How to create patch for all directories under project?
19:07:47 <ManateeLazyCat> darcs
19:08:01 <aavogt> darcs rec -l
19:08:11 <jonh> that nick is kickass
19:08:25 <aavogt> if you have have not added those directories / files yet
19:09:59 <beutdeuce> list <- fmap . lines readFile ("distance_3.in") doesnt seem to work
19:10:08 <Cale> :t fmap lines . readFile
19:10:09 <lambdabot> FilePath -> IO [String]
19:10:23 <Cale> beutdeuce: Put a $ after the fmap . lines readFile
19:10:39 <beutdeuce> ah k
19:10:54 <Cale> It's important that it's  (fmap . lines readFile) "myfile"  and not  fmap . (lines readFile "myfile")
19:10:56 <beutdeuce> hmm, whats wrong with: fmap putStrLn list
19:11:01 <beutdeuce> ah
19:11:03 <ManateeLazyCat> aavogt: But have too many files i don't care, it list 3654 files for patch generate.
19:11:04 <beutdeuce> thnx Cale
19:11:29 <Cale> Nothing is wrong with fmap putStrLn list, you'll get a perfectly good list of IO actions, each of which could be run separately
19:11:32 <ManateeLazyCat> aavogt: I can just tell darcs to see speical directories and files?
19:11:43 <beutdeuce>  Couldn't match expected type `IO String'
19:11:43 <beutdeuce>            against inferred type `[String]'
19:11:47 <Cale> If you want to run them all, you'll probably want mapM putStrLn list
19:12:25 <beutdeuce> hm, whats mapM?
19:12:27 <beutdeuce> never heard of
19:12:29 <aavogt> ManateeLazyCat: you can name those directories, or just say 'n' to the ones that are unwanted, and darcs will not ask to add any of the files in that directory
19:12:30 <Cale> (or mapM_ since you don't care about the result, which is a list of empty tuples)
19:12:32 <beutdeuce> seems to use monad
19:12:35 <beutdeuce> so like an fmap?
19:13:03 <Cale> beutdeuce: It's like normal map, followed by something which glues a list of actions together into a single action
19:13:15 <Cale> :t map putStrLn (words "here are some words")
19:13:16 <lambdabot> [IO ()]
19:13:23 <Cale> See, that's a list of IO actions
19:13:26 <Cale> :t sequence
19:13:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:13:41 <aavogt> ManateeLazyCat: you can also add regexps to _darcs/prefs/boring
19:13:45 <Cale> take m = IO to get  sequence :: [IO a] -> IO [a]
19:13:57 <Cale> :t sequence (map putStrLn (words "here are some words"))
19:13:58 <lambdabot> IO [()]
19:14:07 <Cale> But then the result is a list of ()'s
19:14:17 <Cale> which is uninteresting, so there's a variant
19:14:20 <Cale> :t sequence_
19:14:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
19:14:26 <ManateeLazyCat> aavogt: Thanks, i try it.
19:14:26 <Cale> :t sequence_ (map putStrLn (words "here are some words"))
19:14:27 <lambdabot> IO ()
19:14:57 <Cale> So, it comes down to how we implement these sequence and sequence_ functions
19:15:09 <coco`> Is there a shorter way of writing (x -> f x . g) ?
19:15:12 <Cale> and it turns out to be not that hard to do with recursion
19:15:21 <aavogt> @pl (x -> f x . g)
19:15:21 <lambdabot> (line 1, column 4):
19:15:21 <lambdabot> unexpected ">"
19:15:21 <lambdabot> expecting variable, "(", operator or ")"
19:15:28 <Cale> @pl \x -> f x . g
19:15:28 <lambdabot> (. g) . f
19:15:28 <ivanm> @pl \ x -> f x . g
19:15:29 <lambdabot> (. g) . f
19:15:41 <coco`> what's pl?
19:15:44 <ivanm> coco`: methinks having the x there is cleaner
19:15:46 <ManateeLazyCat> Hi, guys. Good news, i have finish Haskell binding to VTE library, that is to say, you can build full feature Graphics terminal with gtk2hs.
19:15:52 <ivanm> coco`: pl == pointless == pointfree
19:16:03 * ManateeLazyCat Create patch......
19:16:11 <Cale> beutdeuce: So, let's see:
19:16:37 <Cale> sequence [] = return [] -- when the list of actions is empty, we'll produce the action which does nothing except return an empty list.
19:16:53 <Cale> sequence (x:xs) = -- how about if it's nonempty?
19:17:02 <Cale> Well, we want to run the first action at least...
19:17:07 <Cale> sequence (x:xs) = do v <- x; ...
19:17:19 <Cale> and then we want to run the rest of them
19:17:26 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
19:17:34 <beutdeuce> hmm
19:17:34 <Cale> and then return a list of all the results
19:17:38 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:18:28 <Cale> So, this sequence function acts as a sort of primordial loop: if we can decide ahead of time what we want to do on each iteration, and put those actions into a list, then sequence will glue them all together into a single action
19:18:30 <ivanm> what are you allowed to have in a class declaration? type sigs for class methods, default instances and type family declarations... is that it?
19:18:43 <Cale> sequence_ is similar, but discards the results
19:18:48 <Cale> sequence [] = return ()
19:18:51 <Cale> er
19:18:51 <aavogt> you forgot comments!
19:18:53 <Cale> sequence_ [] = return ()
19:18:59 <aavogt> :)
19:19:05 <ivanm> aavogt: well, stuff that haskell-src-exts parses ;-)
19:19:06 <Cale> sequence_ (x:xs) = do x; sequence xs
19:19:10 <ivanm> but I meant actual code
19:19:36 <Cale> beutdeuce: So then with this, we can define mapM, which is a sort of for-each loop.
19:19:46 <Cale> mapM f xs = sequence (map f xs)
19:19:51 <aavogt> :t forM
19:19:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
19:20:04 <Cale> Or forM, which is the same, but with the parameters flipped
19:20:16 <ivanm> aavogt: can you think of anything else? haskell-src-exts cheats by saying the type of items in a class is the same as top-level declarations :@
19:21:00 <Cale> What is a foreach loop made of really? It's a list of things to iterate over, and a loop body. But what is a loop body? It's a function from the things we're iterating over, to actions to be performed
19:21:42 <aavogt> foreach loops may never break?
19:22:06 <beutdeuce> i see
19:22:10 <Cale> Well, we're ignoring that. Breaking is a separate concern.
19:22:23 <monochrom> If it ain't broken, don't break it.
19:22:27 <Cale> (It's calling the current continuation, which is available in some monads)
19:23:01 <ddarius> A previous continuation.
19:23:28 <Cale> Well... yeah, you wrap the whole loop in a callCC, and then at some point call the continuation that has given you.
19:23:30 <ddarius> or rather a containing one, so to speak...
19:23:56 <ddarius> So the current continuation but not the current current continuation.
19:24:20 <monochrom> Ha, so Haskell is pure but not pure pure.
19:24:44 <beutdeuce> lets say each list element is a pair of numbers, like "3523 -344". How do i split it into a list of each number, like so [3523,-344]
19:24:45 <ManateeLazyCat> aavogt: I have finish VTE patch use "darcs rec -l", thanks!
19:25:02 <beutdeuce> (retaining negative is crucial)
19:25:16 <Cale> beutdeuce: If you're sure it'll parse, you can just  map read . words
19:25:18 <ddarius> > map read $ words "3523 -344"
19:25:19 <lambdabot>   [* Exception: Prelude.read: no parse
19:25:25 <ddarius> > map read $ words "3523 -344" :: [Int]
19:25:26 <lambdabot>   [3523,-344]
19:26:09 <beutdeuce> thnx
19:27:45 <copumpkin> oh my!
19:28:04 <copumpkin> ddarius: welcome back!
19:28:39 <ManateeLazyCat> dcoutts_: I have finish VTE binding, thantks for your help!
19:30:41 <beutdeuce> what would be the Haskell equivalent of double for looping through a list so that i can run a function between an element with every other element?
19:31:02 <copumpkin> beutdeuce: \f -> join (liftA2 f)
19:31:03 <sm> I am starting two separate state-monad threads, passing the same state var to both of them. Does the state get shared ?
19:31:14 <beutdeuce> whats liftA2?
19:31:19 <dcolish> for version 6.10.4; is haskeline part of the base ghci, the supplimental libraries or something all on its own
19:31:31 <dcolish> s/ghci/ghc/
19:31:45 <sm> eg: forkIO $ evalStateT ircWriterThread b; evalStateT ircResponderThread b. Can one thread see the changes put by the other ?
19:32:03 <copumpkin> > (join . liftA2 $ (,)) [1..4]
19:32:04 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4...
19:32:32 <beutdeuce> sweet
19:32:32 <copumpkin> beutdeuce: if you want something less obscure, just use a list comprehension though
19:32:58 <byorgey> > [ x + y | x <- [1..5], y <- [90..93] ]
19:32:59 <lambdabot>   [91,92,93,94,92,93,94,95,93,94,95,96,94,95,96,97,95,96,97,98]
19:33:05 <coco`> @pl ((. g) . (f `on` h))
19:33:05 <lambdabot> (. g) . (f `on` h)
19:33:15 <m4ik3ru> i'm sure that this question is going to be rather obscure, but...
19:33:20 <augur> man
19:33:26 <augur> hardly anyone here i recognize
19:33:30 <augur> byorgey
19:33:35 <augur> cupumpkin
19:33:38 <augur> noone else :(
19:33:42 <jonh> ;p
19:33:44 <copumpkin> hey :) what's up?
19:33:46 <augur> oh an lambdabot ofcourse
19:33:50 <SamB_XP> augur: where do you know them from ?
19:33:54 <augur> <3u lambdas
19:33:56 <byorgey> augur: well then, you just need to hang out here more =)
19:34:02 <augur> SamB_XP: from here. :P
19:34:03 <m4ik3ru> what is the difference between mergeSort :: Ord a => [a] -> [a] and mergeSortP :: (a -> a -> Bool) [a] -> [a]
19:34:11 <augur> byorgey, its true. i do. i havent been here in months
19:34:13 <SamB_XP> augur: this place is so huge lately
19:34:19 <augur> but i never know what to talk about
19:34:21 <augur> however
19:34:26 <byorgey> m4ik3ru: the first one sorts using the comparison provided by the Ord instance.
19:34:30 <Cale> > [(x,y) | (x:xs) <- tails [1..10], y <- xs]
19:34:31 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,3),(2,4),(2,5),(...
19:34:37 <augur> oh, and cale.
19:34:38 <augur> hey cale.
19:34:38 <byorgey> m4ik3ru: the second one sorts according to the comparison function explicitly provided.
19:34:40 <Cale> > [(x,y) | (x:xs) <- tails [1..3], y <- xs]
19:34:41 <lambdabot>   [(1,2),(1,3),(2,3)]
19:34:48 <Cale> augur: hello
19:34:56 <aavogt> sm: sharing the initial value shouldn't share whatever each thread tries to do with the state
19:34:56 <coco`> @pl (. g) . (\x y -> f (h x) (h y))
19:34:56 <lambdabot> (. g) . (. h) . f . h
19:34:57 <augur> so i saw this talk about the intermediate language between haskell and machine code
19:35:07 <augur> the one with the weird multi-lambdas
19:35:16 <augur> im tempted to try and program directly in that
19:35:20 <augur> it looks like it would be interesting
19:35:21 <byorgey> augur: "types are calling conventions"?
19:35:25 <augur> yeah :o
19:35:28 <ivanm> a pattern binding is basically what is done when pattern matching (e.g. (Just 2) = Map.lookup k m) ?
19:35:44 <byorgey> augur: I wouldn't want to program directly in that.
19:35:47 <byorgey> it's not really the point =)
19:35:50 <augur> byorgey: yes well.
19:35:57 <augur> i like it because its minimalistic.
19:36:00 <augur> and esoteric
19:36:07 <augur> do a whois on me, itll make sense ;)
19:36:08 <m4ik3ru> byorgey: what is the comparison provided by the Ord instance?  Not sure I understand completely...
19:36:09 <aavogt> sm: if you unwrapped the state monad and passed pure values around as state, 'updates' would not be shared
19:36:12 <byorgey> it is a neat idea.
19:36:38 <sm> aavogt: yes I see.. two calls to evalState means two instances of the state
19:36:40 <m4ik3ru> byorgey: as in Ord a implies Eq a?
19:36:51 <byorgey> m4ik3ru: if a type is an instance of Ord, that means it must implement comparison operators like (<=), (<), (>), and so on, which the sorting algorithm can use to compare elements of the list
19:36:54 <sm> I want to share the state so eg one thread can write and the other can read it (without blocking)
19:37:11 <m4ik3ru> byorgey: it's starting to become clear...
19:37:13 <byorgey> m4ik3ru: Ord a does imply Eq a, but that is not relevant to sorting
19:37:40 <v0|d> m4ik3ru: well ordering principle
19:38:09 <beutdeuce> whats not right here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9691#a9691
19:38:18 <m4ik3ru> byorgey: i have to do insertion sort now, so i'll try to apply what i think i've learned :)
19:38:32 <aavogt> there are ways to read mvars or tvars without blocking, in the case that they are empty.
19:40:29 <sm> aavogt: thanks, just reading that. I see how to read, but not how to write, exactly
19:40:55 <jfredett> ... gmane is unbelievably annoying to parse... I don't know how you ever did it, byorgey
19:41:12 <aavogt> beutdeuce: distance should be :: (Integer,Integer) -> Integer, and it does not need the return function, since it isn't in a monad...
19:41:23 <blackh> beutdeuce: distance(a,b) is not the same type as distance :: [Integer] -> Integer ...
19:41:28 <sm> maybe I want a SampleVar instead ?
19:41:46 <blackh> 'results=' wants a let at the beginning...
19:41:52 <blackh> you'll need another line after that.
19:41:54 <byorgey> jfredett: it really is.  I did it with tagsoup.  Even then it sometimes broke.
19:42:00 <blackh> e.g. print results
19:42:08 <beutdeuce> i get parse error on input `='
19:42:13 * sm tries
19:42:17 <beutdeuce> i nthe list comprehension
19:42:26 <blackh> beutdeuce: That's because there's no 'let' at the beginning of the line
19:42:33 <aavogt> beutdeuce: and your [Int] annotations conflict with the Integer you claim that distance requires. Int is different from Integer
19:42:55 <jfredett> byorgey: I'm poking around with the RSS feeds, maybe I should just set this up as a Daemon...
19:43:04 <beutdeuce> right, i forgot about the let and type constraint
19:43:23 <jfredett> either that or I'll spend some time and get my other project up and running now, and dodge the whole thing entirely.
19:43:42 <byorgey> jfredett: what's your other project?  an RSS aggregator?
19:43:51 <blackh> beutdeuce: All the , a = stuff is wrong
19:43:56 <jfredett> byorgey: it's a mail sorting client
19:43:58 <beutdeuce> even with let?
19:44:03 <byorgey> ah, neat
19:44:05 <jfredett> I figure I'll set up a little email address
19:44:30 <jfredett> and use that to sort out the email directly.
19:44:31 <byorgey> oh, yeah, I think I remember your mail sorting project
19:44:52 <blackh> beutdeuce: Actually it's probably right! I don't use list comprehensions enough!
19:44:52 <byorgey> yeah, that sounds way better than trying to parse gmane.
19:44:55 <beutdeuce> can someone help me patch it up?
19:45:07 <jfredett> I've been fighting with hsemail recently, though I think now I might just rewrite my crappy old parser instead of bothering with hsemail
19:45:18 <beutdeuce> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9691#a9693 is what i got so far, with a parse error on the - on line 9
19:45:20 <beutdeuce> =*
19:45:25 <byorgey> blackh, beutdeuce: no, blackh is right, you need   let a = ...  instead of  a = ...
19:45:30 <byorgey> in a list comprehension
19:45:50 <blackh> beutdeuce: The 'let' needs to be at the beginning of the line.
19:46:03 <blackh> beutdeuce: You need 'print results' on a new line at the end
19:46:04 <beutdeuce> oh, even when not in preliude?
19:46:26 <blackh> let results = ...
19:46:27 <blackh> print results
19:46:32 <byorgey> has anyone used funcmp recently?
19:46:38 <byorgey> I'm having a heck of a time getting it to work
19:46:40 <beutdeuce> still parserrror
19:46:42 <copumpkin> funcmp?
19:46:42 <beutdeuce> on =
19:47:03 <byorgey> @hackage funcmp
19:47:03 <lambdabot> http://hackage.haskell.org/package/funcmp
19:47:05 <blackh> beutdeuce: I need to learn my list comprehension syntax. Are you allowed to put lets in it?
19:47:14 <byorgey> a Haskell interface to MetaPost
19:47:19 <copumpkin> ah
19:47:25 <byorgey> blackh: yes, you are
19:47:55 <blackh> OK - I get it.
19:49:03 <blackh> beutdeuce: What have you got now?  The contents of [ ... ] should be correct (except for that type error I mentioned)
19:49:18 <beutdeuce> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9694#a9694 is what i got so far
19:49:22 <beutdeuce> still parse error
19:49:46 <orbitz> does Haskell have anything like polymorphic variants in ocaml?
19:49:56 <copumpkin> don't think so
19:50:11 <aavogt> beutdeuce: remove 'return' from distance
19:50:15 <beutdeuce> did
19:50:22 <beutdeuce> but thats not what gives the error
19:50:26 <blackh> beutdeuce: list, a =  <-- need 'let'
19:50:45 <beutdeuce> huh?
19:50:56 <blackh> x <- list, y <- list, let a = map read $ wor
19:51:08 <Cale> orbitz: No, but along with extensible records (which are closely related), it's something that a lot of people would like to add. The trouble is that there are many slight variations on how to do it and so it's hard to get a consensus, as well as the fact that the main GHC devs are all working on other things.
19:51:25 <aavogt> @type let distance (a,b) = return $ abs(b!!0 - a!!0) + abs(b!!1 - a!!1) in distance
19:51:26 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => ([a], [a]) -> m a
19:51:26 <blackh> beutdeuce: There are two lets missing on your 'results' line
19:51:29 <m4ik3ru> byorgey: thanks for the tip, things are working out perfectly now :)
19:51:44 <beutdeuce> now i get http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9695#a9695
19:51:51 <orbitz> Cale: what are extensible records?
19:52:31 <blackh> beutdeuce: distance needs to have type ([Integer], [Integer]) -> Integer
19:53:03 <beutdeuce> nice
19:53:07 <beutdeuce> no more errors
19:53:08 <Cale> orbitz: http://research.microsoft.com/en-us/um/people/daan/download/papers/scopedlabels.pdf
19:53:09 <beutdeuce> thanks for all!
19:53:18 <blackh> beutdeuce: Grand!
19:53:23 <beutdeuce> ur the best guys
19:53:25 <BMeph> beutdeuce: You Do know that you can annotate your old pastes, right? You don't have to make a new paste every time. :)
19:53:34 <beutdeuce> :P
19:53:41 <orbitz> Cale: thanks
19:53:53 <blackh> beutdeuce: Also you don't need ':: Integer' in your 'results' line but you might as well keep it to make it more readable.
19:54:18 <Cale> orbitz: Basically, rather than having polymorphism over sets of possibilities (sums) like with variants, you have polymorphism over what data is present (products)
19:54:19 <blackh> ...or :: [Integer] :)
19:54:29 <beutdeuce> k
19:54:49 <beutdeuce> huh
19:54:51 <beutdeuce> weird
19:54:53 <beutdeuce> i get a stack overflow
19:55:20 <Cale> orbitz: That paper describes a system which I think is fairly good, though the syntax used in the paper is not very haskellish in my opinion. (But of course that can be adjusted.)
19:55:54 <blackh> beutdeuce: x <- list, y <- list is going to give you n ^ 2 iterations.
19:56:04 <orbitz> Cale: is what is in the paper implemented?
19:56:14 <beutdeuce> blackh: basically, i want to apply distance to each element in list with each other element
19:56:14 <blackh> beutdeuce: You probably want just x <- list and use x twice
19:56:24 <Cale> orbitz: yeah, in an experimental language called morrow
19:56:32 <blackh> beutdeuce: OK - in that case it looks correct.  How many elements?
19:56:41 <Cale> http://www.equational.org/morrow/
19:56:44 <beutdeuce> 1000, and the final test data with 200000
19:56:56 <beutdeuce> it overflowed on 1000
19:56:59 <beutdeuce> i understand why
19:57:01 <orbitz> Cale: are they in ghc?
19:57:05 <Cale> orbitz: no.
19:57:08 <beutdeuce> but when in imperative lanugages i use double loop, its fine
19:57:09 <orbitz> ok
19:57:11 <beutdeuce> what do u suggest?
19:57:34 <Cale> orbitz: There's no extensible record or variant system in GHC. There are some libraries which can kind of awkwardly approximate that though.
19:57:53 * BMeph suggests 'tails'
19:57:57 <blackh> beutdeuce: I can't see any reason why it should overflow.
19:58:17 <beutdeuce> BMeph: :)
19:58:30 <beutdeuce> hmm, but how to implement
19:58:35 <beutdeuce> x <- list
19:58:39 <beutdeuce> y <- tails list ?
19:58:43 <blackh> beutdeuce: Oh, it could be maximum, actually.
19:58:57 <beutdeuce> why maximum?
19:59:38 <blackh> beutdeuce: Yes - it's maximum.. the trouble is, it's based on foldl1.  I'm not sure why that would be.
19:59:56 <blackh> Possibly Haskell '98.
20:00:18 <blackh> beutdeuce: Essentially Haskell gives you a benefit from laziness, and exacts a price as well.  You're paying the price now.
20:00:19 <beutdeuce> hm
20:00:38 <blackh> beutdeuce: Replace it maximum with (foldl1' max)
20:01:00 <beutdeuce> is the following a valid statement in a list comprehension
20:01:01 <beutdeuce> x <- list, y <- tails x
20:01:08 <blackh> beutdeuce: Essentially the choice of whether to use foldl' or foldr depends on the laziness qualities of your list.
20:01:25 <beutdeuce> k
20:01:26 <coco`> is there a way of re-exporting all imported functions without re-typing their names?
20:01:29 <blackh> Yes, but it'll produce an awful lot of elements.
20:02:11 <Cale> coco`: You just have to export the modules that you imported
20:02:13 <beutdeuce> blackh: so its more efficient to do x <- list and y <- list?
20:02:22 <Cale> coco`: But  module Foo  in the export list.
20:02:24 <Cale> Put*
20:02:26 <blackh> beutdeuce: Actually I think I'm wrong
20:02:38 <beutdeuce> oh ,and still overflow with foldl
20:02:49 <blackh> beutdeuce: foldl1' or foldl1 ?
20:03:01 <beutdeuce> gffoldl1
20:03:04 <beutdeuce> foldl1
20:03:11 <blackh> beutdeuce: Use foldl1'
20:03:16 <beutdeuce> says not found
20:03:27 <blackh> import it from Data.List
20:03:48 <beutdeuce> where do i put import statement, before or after module declaration/
20:03:50 <beutdeuce> ?
20:03:58 <blackh> after the module
20:04:13 <blackh> import Data.List
20:04:16 <coco`> Cale: but then it exports everything, not just a selection of functions
20:04:27 <beutdeuce> hmm, i get parse error
20:04:40 <coco`> Cale: oh, never mind
20:04:55 <blackh> beutdeuce: Is your ' a normal single quote?
20:04:59 <beutdeuce> yes
20:05:05 <beutdeuce> parse error on import
20:05:06 <beutdeuce> not that
20:05:21 <beutdeuce> doesnt work before or after module Main where
20:05:26 <blackh> The import has to be on a line by itself and it has to be after 'where'
20:05:50 <blackh> Also the import has to start at the left
20:05:58 <blackh> (not indented)
20:06:06 <BMeph> beutdeuce: ...and, no tabs, please; they're EVIL! ;)
20:06:13 <beutdeuce> got it, thnx :D
20:06:40 <beutdeuce> hmm, doesnt seem to overflow, but runs longer than it should
20:06:58 <beutdeuce> still running
20:06:58 <beutdeuce> lol
20:07:19 <blackh> beutdeuce: Well, that's good. The reason why it's not overflowing is because the ' in foldl1' makes it calculate each answer as it goes, rather than filling up the stack.
20:07:43 <beutdeuce> k, but its running way longer than it should
20:07:56 <defun> > cos 45
20:07:57 <lambdabot>   0.5253219888177297
20:08:22 <c_wraith> Um.  you really mean 45 radians?
20:08:22 <blackh> beutdeuce: Your 200,000 items will take 40 billion iterations.
20:08:28 <Zao> > cos (pi / 4)
20:08:29 <lambdabot>   0.7071067811865476
20:08:33 <beutdeuce> i'm actually doing it on 1000 items now
20:08:42 <c_wraith> > sqrt(2)
20:08:42 <lambdabot>   1.4142135623730951
20:08:46 <c_wraith> > sqrt(2)/2
20:08:47 <defun> That's what I was looking for!
20:08:47 <lambdabot>   0.7071067811865476
20:09:07 <beutdeuce> my friend also brute forced it, but it ran in max 2 seconds
20:09:08 <Zao> In most sane languages, the trig functions take radians, like $diety intended.
20:09:08 <beutdeuce> in c++ that is. So somethings not happening right in the comprehension
20:09:15 <c_wraith> heh.  extra parens.  oops.
20:09:20 <blackh> beutdeuce: That's a million iterations so it should terminate eventually. :)
20:09:29 <coco`> can I re-export a qualified module with its renamed name?
20:09:35 <aavogt> beutdeuce: how did you compile it?
20:09:50 <blackh> beutdeuce: Oh yes - you have to compile it if you want speed.
20:09:52 <aavogt> coco`: no
20:09:55 <beutdeuce> oh
20:09:55 <beutdeuce> k
20:09:57 <beutdeuce> h/o
20:10:17 <blackh> beutdeuce: Also Integer will slow it down a bit (compared with Int)
20:10:26 <c_wraith> Zao:  is there  a language where the trig functions don't take radians?  Maybe LOGO?
20:11:07 <beutdeuce> how do u compile again? ghc -O2 distance.hs distance.out ?
20:11:22 <blackh> ghc -o distance distance.hs --make -O2
20:11:24 <c_wraith> ghc -O2 --make distance.hs
20:11:41 <jberryman> I think that 'array' from Data.Array should drop the tail of a list if the passed list exceeds the provided bounds
20:11:48 <jberryman> in a similar manner to listArray
20:12:03 <beutdeuce> huh fail,  suffix or operands invalid for `push'?   32-bit absolute addressing is not supported for x86-64? cannot do signed 4 byte relocation?
20:12:06 <roconnor> where's that haskell post on defining heriditarily finite sets?
20:12:08 <beutdeuce> gave that and didnt compile
20:12:33 <blackh> beutdeuce: That definitely should not happen.  What OS and what GHC version?
20:12:48 <c_wraith> and what processor, since it's mentioning x86-64?
20:13:18 <beutdeuce> ghc 6.10.3 Mac OS X Snow Leopard Intel Core 2 Duo, 2.33 GHz, 2 cores
20:13:36 <RyanT50001> is there any way to lift the requirement that type aliases be fully applied?
20:13:42 <c_wraith> Ooh.  More snow leopard issues. :(
20:13:54 <aavogt> beutdeuce: you might also want to move the application of the function 'map read . words' to happen once for each line, rather than at every comparison between points
20:14:16 <beutdeuce> aavogt: how would i do that?
20:14:22 <ddarius> RyanT50001: Implement higher-order unification in the type system.
20:14:31 <blackh> beutdeuce: I don't know the exact answer, but 64 Mac support is not good at the moment.
20:14:31 <RyanT50001> ddarius: i meant an existing way of doing it :P
20:14:49 <beutdeuce> k, i'll run on my fedora 32-bit then
20:14:52 <c_wraith> beutdeuce: 6.10.4 is also out
20:14:55 <c_wraith> Give that a shot
20:14:58 <beutdeuce> anything new?
20:15:10 <beutdeuce> can update through cabal?
20:15:12 <aavogt> beutdeuce: list <- fmap (map (map read . words) . lines) $ readFile "bleh"
20:15:17 <c_wraith> Not sure what it changed, actually.  The big fixes I knew were in 6.10.3
20:15:23 <beutdeuce> aavogt: ah
20:15:24 <beutdeuce> right
20:15:31 <beutdeuce> hmm, that will be much faster
20:15:59 <beutdeuce> aavogt: wait
20:16:02 <beutdeuce> but then
20:16:05 <blackh> beutdeuce: 32 bit and 64 bit Linux work perfectly in GHC 6.10
20:16:06 <c_wraith> and you can't update ghc via cabal, sadly.
20:16:09 <beutdeuce> so i dotn need an a and b then
20:16:12 <beutdeuce> just use x and y
20:16:15 <beutdeuce> right aavogt ?
20:16:20 <aavogt> exactly
20:16:34 <beutdeuce> blackh: k, aavogt: great
20:16:44 <gwern> c_wraith: well, ghc will not be cabalized for a very long time if ever; and as things stand, it's probably better for ghc to be more fundamental than cabal
20:17:19 <ivanm> gwern: I _really_ doubt GHC will be cabalised
20:17:21 <c_wraith> gwern: I don't disagree with that hierarchy.  I am annoyed that you need to reinstall all your cabal packages for new versions of ghc
20:17:26 <ivanm> since that would kinda make it harder to bootstrap
20:17:37 <ivanm> c_wraith: you need to do the same with a new version of gcc...
20:17:55 <c_wraith> 3rd party libraries?  Not that often.
20:17:58 <ivanm> c_wraith: since they've been compiled with a different compiler against different versions of the libraries
20:18:01 <blackdog> c_wraith: you almost want the cartesian product of packages and compilers
20:18:05 <ivanm> c_wraith: yes you do...
20:18:08 <gwern> c_wraith: well, see? there's no point about complainig ghc isn't cabalized when there's an even more fundamental issue, with no cross-version interop
20:18:14 * ivanm *hates* gcc upgrades
20:18:24 <blackdog> disk space is cheap, right?:)
20:18:39 <c_wraith> blackdog, it's worse than that.  You want a cross product of every possible dependency-satisfying set
20:18:43 <sutats> Is there a library function that returns something like [(a, Int)] where the Int is the number of times a appears in [(a, b)]?
20:19:09 <beutdeuce> whats the most efficient optimization that currently exists for haskell? O2?
20:19:42 <beutdeuce> I want to beat my friend using cpp
20:20:01 <beutdeuce> we had an argument, he said that haskell can never be faster than cpp
20:20:06 <aavogt> apparently -O1337 is accepted by ghc
20:20:11 <ivanm> beutdeuce: CPP = C++?
20:20:14 <beutdeuce> yes
20:20:16 <ivanm> beutdeuce: see the shootout
20:20:18 <ivanm> @where shootout
20:20:18 <lambdabot> http://shootout.alioth.debian.org/
20:20:21 <gwern> sutats: that seems rather specific
20:20:22 <sutats> Like [("2", 2), ("1", 1)] for [("2", "A"), ("2", "B"), ("1", "A")].
20:20:23 <blackdog> beutdeuce: careful thought seems to be the best optimisation i've found.
20:20:27 <c_wraith> before switching to target haskell-platform, I had to rebuild network like 20 times because various libs depended on different versions of it.
20:20:35 <aavogt> beutdeuce: you'll be faster by using a better algorithm first of all...
20:20:38 <ivanm> aavogt: but it downgrades it to -O2 or -O3?
20:20:47 <beutdeuce> aavogt: yes, but we're both bruting
20:20:51 <sutats> gwern: It doesn't have to work on pairs. I just want a count of that element in a list.
20:21:02 <blackh> beutdeuce: I think -O2 is the fastest.  I think Haskell will be faster than C++ soonish, but it is generally a bit slower now.
20:21:02 <blackdog> beutdeuce: more seriously - get a working implementation, profile, optimise, repeat.
20:21:22 <blackdog> for a brute force implementation you will probably lose, unless you can do clever things
20:21:32 <gwern> @hoogle a -> [a] -> Int
20:21:32 <beutdeuce> hmm, k
20:21:32 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
20:21:33 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
20:21:33 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
20:21:33 <jfredett> sutats: consider using groupBy and length in various combination, I think you can get to what you want.
20:21:35 <ddarius> The speed of any program greatly depends on the code you provide it even given the same algorithm.
20:21:39 <blackdog> there's a really good chapter on optimisation in RWH
20:21:51 <blackdog> if you need to get down to the bare metal
20:21:55 <gwern> sutats: well, you could do 'length $ elemIndices'
20:21:58 <gwern> or something
20:22:01 <blackh> beutdeuce: Take your friend on with a really complicated problem and you'll win.
20:22:09 <roconnor> > [(head l, length l) | l <- group . sort . map fst $ [("2", "A"), ("2", "B"), ("1", "A")]]
20:22:10 <lambdabot>   [("1",1),("2",2)]
20:22:14 <jfredett> :t group
20:22:14 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
20:22:24 <jfredett> iirc...
20:22:46 <blackdog> beutdeuce: oh, and are you allowed to parallelise? could be a big win.
20:22:54 <jfredett> > map (id &&& length) . group . sort $ [1,1,2,3,4,5,5]
20:22:54 <lambdabot>   [([1,1],2),([2],1),([3],1),([4],1),([5,5],2)]
20:22:56 <ddarius> roconnor: Doesn't meet specification.
20:22:56 <roconnor> > map (head &&& length) . group . sort . map fst $ [("2", "A"), ("2", "B"), ("1", "A")]]
20:22:57 <lambdabot>   <no location info>: parse error on input `]'
20:23:02 <beutdeuce> blackdog: ya, we both agrreed not too. I proved him wrong with a simple map redice job
20:23:06 <roconnor> ddarius: what did I miss?
20:23:06 <beutdeuce> using ruby
20:23:14 <ddarius> roconnor: Wrong order.
20:23:19 <jfredett> > map (headd &&& length) . group . sort $ [1,1,2,3,4,5,5]
20:23:20 <lambdabot>   Not in scope: `headd'
20:23:25 <roconnor> order preserving!, what a pain.
20:23:26 <jfredett> > map (head &&& length) . group . sort $ [1,1,2,3,4,5,5]
20:23:27 <lambdabot>   [(1,2),(2,1),(3,1),(4,1),(5,2)]
20:23:27 <ddarius> roconnor: Of course the problem is underspecified.
20:23:34 <jfredett> there we go.
20:23:42 <beutdeuce> Hmm, very weird. COmpiled fine in linux, but then when i run it it says, "Prelude.(!!): index too large"
20:23:53 <roconnor> > map (head &&& length) . group . sort . map fst $ [("2", "A"), ("2", "B"), ("1", "A")]
20:23:53 <lambdabot>   [("1",1),("2",2)]
20:23:57 <m4ik3ru> i have to write a function of type String -> Bool that does this:
20:24:05 <m4ik3ru> checks whether a string representation of a floating point number is valid
20:24:06 <blackdog> beutdeuce: you are giving him all the advantages :(
20:24:07 <m4ik3ru> contains only digits, '.', '+', '-', or 'E'
20:24:09 <beutdeuce> runs fine in prelude, but doesnt want to when compiled lol
20:24:09 <m4ik3ru> cannot start or end with 'E'
20:24:12 <m4ik3ru> contains at most one '.'
20:24:14 <m4ik3ru> 'E' cannot appear before '.'
20:24:16 <m4ik3ru> '+' and '-' can only appear as the first element of s or immediately after 'E'
20:24:17 <m4ik3ru> '+' and '-' must be followed by a digit
20:24:30 <beutdeuce> blackdog: how so?
20:24:41 <jfredett> m4ik3ru: this doth sound like unto the homework problem.
20:24:43 <sutats> jfredett, gwern, roconnor: I think the key function I was looking for was group. I can apply length from there.
20:24:45 <jfredett> I will suggest parsec. :)
20:24:47 <blackh> beutdeuce: That's because you referenced something past the end of one of your lists using !!
20:24:47 <m4ik3ru> it does.
20:25:03 <beutdeuce> ah, i think i know what the error is
20:25:09 <ddarius> jfredett: Why not spawn a perl subprocess and run a regex over it.
20:25:10 <blackh> beutdeuce: It probably read an empty line
20:25:14 <beutdeuce> blackh: test data was different :P
20:25:15 <m4ik3ru> jfredett: i don't want it solved, i just need an example to get me started
20:25:32 <ivanm> m4ik3ru: are you allowed to use parsers?
20:25:33 <m4ik3ru> i'm looking all through Data.Char and Data.List
20:25:41 <blackdog> beutdeuce: haskell is good for solving hard problems, or succinctly specifying complex algorithms
20:25:41 <ivanm> m4ik3ru: see the source of my graphviz package
20:25:45 <c_wraith> To get you started?  Parse an int
20:25:52 <jfredett> m4ik3ru: there are some different ways- you might try one of the regex libraries, parsec, or some string munging.
20:25:53 <ivanm> (I do something like that there)
20:25:57 <m4ik3ru> ivanm: that's the point, we're about to start learning how to write parsers.
20:25:58 <blackdog> if you insist on no parallelism and dumb algorithms, you might as well use C.
20:26:01 <c_wraith> After you can parse that, parse a float with a decimal in it
20:26:02 <ivanm> m4ik3ru: heh
20:26:16 <aavogt> m4ik3ru: use reads, and check if it can parse the format correctly :)
20:26:16 <ivanm> m4ik3ru: IIRC, I did a partial thing for it with Strings as well
20:26:21 <beutdeuce> nice, runs 1000 tests data in 0.116 seconds
20:26:26 <jfredett> m4ik3ru: c_wraith has the right idea in any case.
20:26:28 <beutdeuce> now time for the big one, 200,000 tests
20:26:35 <sutats> ddarius: Good point about the order. It doesn't really matter for what I'm trying to do, but I wouldn't have noticed that otherwise.
20:26:37 <beutdeuce> lets see if haskell can beat my friend's c++ 11 monutes
20:26:40 <roconnor> > let sutats [] = []; sutats (x:l) = let (xs,nxs) = partition (==x) l in (x,1+length xs) : sutats nxs in sutats . map fst $ [("2", "A"), ("2", "B"), ("1", "A")]
20:26:40 <lambdabot>   [("2",2),("1",1)]
20:26:49 <ivanm> but yes, I think I'm agreeing with where c_wraith is going
20:26:49 <roconnor> there we go
20:26:55 <m4ik3ru> parse an int... here we go :)
20:27:06 <ivanm> try parsing the negative sigh, then try parsing the integer bit, then try parsing the decimal, then try parsing the exponent
20:27:07 <c_wraith> That's my advice, anyway.  start with the simplest subproblem, and work your way forward from there.
20:27:14 <ivanm> *sign
20:27:25 * ivanm wonders what a "negative sigh" is...
20:27:48 <c_wraith> I know what a negative sigh is.  I'm more confused by what a positive sigh would be.
20:27:55 <c_wraith> "he sighed in excitement!"
20:27:55 <sutats> roconnor: Hm, nice, though I think your other one does the job perfectly fine for what I needed.
20:28:07 <c_wraith> Just...  can't fit an image to those words.
20:28:40 <BMeph> c_wraith: s/excitement/contentment/ , ya weirdo! ;)
20:28:45 <beutdeuce> how would i be able to do standard in with Haskell?
20:28:58 <roconnor> I really don't like the group function very much.
20:29:03 <beutdeuce> i want to spcify file name as parameter to program, rather than in program itself
20:29:15 <aavogt> @index getArgs
20:29:15 <lambdabot> System.Environment
20:29:28 <ivanm> c_wraith: heh
20:29:36 <roconnor> groupBy is only a little better
20:29:37 <beutdeuce> k
20:29:46 <ivanm> roconnor: why not?
20:29:51 <ivanm> not generic enough?
20:30:01 <BMeph> roconnor: Yeah, what's your beef? :)
20:30:13 <fata_erro> can someone tell me how to create an array in haskell
20:30:33 <ivanm> fata_erro: see Data.Array
20:30:38 <fata_erro> i want a 1000*1000 array of ints
20:30:48 <fata_erro> didn't make sense
20:30:52 <BMeph> fata_erro: Then make one, we won't stop you. ;p
20:30:52 <ivanm> in which case, your indices will be something like (Int,Int)
20:30:59 <ivanm> @type listArray
20:30:59 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
20:31:02 <jfredett> fata_erro: then read harder?
20:31:10 <fata_erro> lol
20:31:13 <jfredett> or perhaps use a structure you better understand?
20:31:20 <ivanm> > listArray ((0,3),(0,3)) [1..16]
20:31:20 <lambdabot>   array ((0,3),(0,3)) [((0,3),1)]
20:31:28 <roconnor> ivanm, BMeph: I always want a list of pairs of a header (the thing being groupedBy) and list of the objects in the group.
20:31:28 <Cale> > array ((1,1),(1000,1000)) [(i,j,i*j) | i <- [1..1000], j <- [1..1000]]
20:31:29 <lambdabot>   Couldn't match expected type `((t, t1), e)'
20:31:29 <lambdabot>         against inferred type `...
20:31:35 <Cale> er, right :)
20:31:36 <ivanm> fata_erro: ^^
20:31:39 <Cale> > array ((1,1),(1000,1000)) [((i,j),i*j) | i <- [1..1000], j <- [1..1000]]
20:31:41 <jfredett> see also, #haskell-beginners (I believe it is also a IRC chat, in addition to a ML)
20:31:42 <m4ik3ru> i'm having trouble making sense of how to parse an int even
20:31:44 <lambdabot>   mueval-core: Time limit exceeded
20:31:46 <ivanm> hang on, that listArray result looks wrong...
20:32:01 <ivanm> m4ik3ru: see the break function
20:32:04 <Cale> You wanted ((0,0),(3,3))
20:32:06 <ivanm> and isDigit in Data.Char
20:32:09 <ivanm> Cale: ahhh, right
20:32:12 * ivanm face-palms
20:32:19 <ivanm> > listArray ((0,0),(4,3)) [1..16]
20:32:20 <lambdabot>   array ((0,0),(4,3)) [((0,0),1),((0,1),2),((0,2),3),((0,3),4),((1,0),5),((1,...
20:32:23 <ivanm> > listArray ((0,0),(3,3)) [1..16]
20:32:24 <lambdabot>   array ((0,0),(3,3)) [((0,0),1),((0,1),2),((0,2),3),((0,3),4),((1,0),5),((1,...
20:32:25 <m4ik3ru> am i trying to parse an Int FROM a String?
20:32:31 <m4ik3ru> ivanm: i'll check it out
20:32:34 <BMeph> roconnor: ...wait, what? :)
20:32:49 <fata_erro> it returned a list
20:32:57 <Cale> fata_erro: oh?
20:33:00 <fata_erro> thats slow
20:33:03 <Cale> fata_erro: It returns an array.
20:33:16 <fata_erro> which is a list.....?
20:33:23 <Cale> fata_erro: Lists are not the same as arrays
20:33:25 <jfredett> fata_erro: no, it just looks like a list.
20:33:35 <jfredett> it's different on the inside.
20:33:35 <aavogt> fata_erro: what are you doing to the array?
20:33:46 <Cale> When printed, it prints as how you would construct it using a list and the array function.
20:33:57 <fata_erro> accessing and changing
20:33:58 <Cale> (because that's the most general way to construct arrays)
20:34:05 <Orclev> hmm, I'm trying to use until with a function that returns IO, how do I go about doing that?
20:34:11 <Cale> fata_erro: If you need to do updates, then plain arrays are bad.
20:34:20 <Cale> fata_erro: Because it means copying the whole thing.
20:34:26 <jfredett> Orclev: see IO monad, and relevant chapters in RWH
20:34:32 <Cale> fata_erro: We do have mutable arrays, but before that, try Data.Map
20:34:38 <jfredett> @google real world haskell
20:34:40 <lambdabot> http://www.realworldhaskell.org/
20:34:40 <lambdabot> Title: Real World Haskell
20:34:41 <jfredett> I hope that works...
20:34:42 <aavogt> @type until
20:34:43 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
20:34:49 <Cale> (because the API is nicer and easier to work with)
20:34:50 <fata_erro> thanks cale
20:35:09 <ddarius> Here's an exercise:  Write a GUI application with an input textbox, an output textbox and two buttons, one labelled "Leaf" the other "Branch", that will build a binary leaf tree, i.e. data T a = L a | B (T a) (T a), in-order where the leaf values are read from the input textbox and display the tree, when complete, to the output textbox.  E.g. Pressing Branch, Branch, Leaf (with input textbox containing 1), Leaf (w/ input 2)
20:35:09 <ddarius> , Leaf (w/ input 3) will display B (B (L 1) (L 2)) (L 3) in the output textbox.
20:35:10 <Cale> Well... hmm
20:35:10 <lunabot>  luna: parse error on input `in'
20:35:12 <jfredett> Data.Map makes me happy...
20:35:24 <Cale> fata_erro: 1000x1000 does sound fairly large though.
20:35:41 <Cale> fata_erro: You might really need a mutable array, depending on what you're trying to do
20:35:50 <aavogt> Orclev: I'm not sure that will be helpful, since you should not be able to construct a meaningful (IO a -> Bool) to pass to until
20:36:05 <fata_erro> cale it for a text classifier
20:36:05 <Cale> fata_erro: What is it that you're writing?
20:36:28 <Cale> hmm, and you need a 1000 by 1000 array? Will most of the entries be filled?
20:36:50 * BMeph wonders why folks like 'data T a = L a | B (T a) (T a)'-style trees so much, and 'data T a = TNil | B a (T a) (T a)'-style ones so little...
20:36:54 <c_wraith> :t const true :: IO a -> Bool
20:36:55 <lambdabot> Not in scope: `true'
20:36:56 <fata_erro> i'm butting words in Data.map atm
20:37:04 <c_wraith> :t const True :: IO a -> Bool
20:37:05 <lambdabot> forall a. IO a -> Bool
20:37:06 <fata_erro> but i think its slow
20:37:17 <c_wraith> there.  that's a handy implementation. :)
20:37:25 <beutdeuce> i can successfully brite force it in minutes, but im curious as to whether anyway has a good idea as to solving this problem algorithmically http://y0u.dontexist.com:203/cs/1.html (first one)
20:37:29 <beutdeuce> brute*
20:37:42 <fata_erro> because i'm using fold over the Map
20:37:46 <Cale> Brite Force! SHINE!
20:37:53 <gwern> ah, I love haskell arrays. I love surveying the strewn wasteland of papers and packages, with the sable-headed vultures picking at the naifs who selected the wrong package and were slain by their users
20:38:15 <roconnor> BMeph: I prefer data T a b = L a | B b (T a) (T a)
20:38:22 <Orclev> hmm, I'm begining to think it might be less hassle to rewrite the way it works to just dump each line into a list that gets built up and do the actual output outside of the until
20:38:24 <ddarius> BMeph: More naturally corresponds to MonadPlus operations.
20:38:27 <roconnor> well (T a b) (T a b)
20:38:32 <copumpkin> beutdeuce: looks like "dynamic programming"
20:38:42 <deech`> Hi all, when I try to install leksah I get "multiple versions of the same package" warning for 'regex-posix'. This leads to a compilation error. Has anyone successfully installed leksah?
20:38:47 <copumpkin> beutdeuce: man, that red announcement at the top is painful to look at
20:39:04 <jonh> deech`: yep
20:39:11 <BMeph> roconnor: I was gonna say,... :)
20:39:29 <jonh> deech`: and i had that error too, trying to remember how i fixed it ;o
20:39:52 <roconnor> BMeph: actually data T a = L a | B (T a) (T a)  is nice cause the data processing case is totally different from the divide and conqure step.
20:39:54 <BMeph> roconnor: I'm suprised you don't prefer 'data T a b = L a | B b (T b a) (T b a)'
20:40:29 <ddarius> Polymorphic recursion, ho!
20:40:35 <deech`> jonh: It seems I have to downgrade my regex-posix version, is this what you did?
20:41:01 <c_wraith> BMeph: that seems convoluted
20:41:02 <roconnor> BMeph: I really prefer data T a  = L a | B (T (a,a))
20:41:29 <ddarius> No ragged ends for you.
20:41:36 <copumpkin> :o
20:41:56 <beutdeuce> copumpkin: not as much as the port number :)
20:42:04 <m4ik3ru> i don't even know where to start on this one...
20:42:12 <copumpkin> m4ik3ru: which one?
20:42:21 <m4ik3ru> the parsing one
20:42:30 <fata_erro> are values always copied between functions?
20:42:30 <copumpkin> oh, that one! ;)
20:42:39 <ddarius> roconnor: I like building those trees in the call stack.
20:42:41 <c_wraith> start with a type signature!
20:42:51 <m4ik3ru> i don't actually understand parsing
20:42:53 <m4ik3ru> c_wraith:
20:43:00 <m4ik3ru> c_wraith: how do you mean?
20:43:04 <hello> hello everyone
20:43:14 <blackdog> hello: egotist
20:43:20 <hello> any one here
20:43:33 <copumpkin> hello: indeed!
20:43:34 <c_wraith> m4ik3ru: start by figuring out what's input you need, and what output you need.
20:44:00 <hello> hello copumpkin
20:44:04 <c_wraith> What is the data type of the input?  What is the data type of the output?
20:44:15 <copumpkin> hello: you just said your own name and mine!
20:44:29 <m4ik3ru> c_wraith: so for the function that i ultimately have to write, the type is String -> Bool
20:44:42 <fata_erro> if i insert a value into a Map with 100k values that map gets copied right?
20:44:47 <naren> Hey, I have this peice of code:
20:44:52 <copumpkin> m4ik3ru: what does the bool represent?
20:44:59 <BMeph> m4ik3ru: YES! You win!!1!!1!!111 ;p
20:45:01 <copumpkin> fata_erro: not all of it
20:45:10 <copumpkin> fata_erro: in fact, most of it is untouched
20:45:13 <jfredett> BMeph: Eleventy!
20:45:21 <fata_erro> copumpkin: how can iy not?
20:45:22 <naren> contents <- sequence (readFile <$> filenames)
20:45:23 <naren>   return $ foldl' (\a (c,o) -> execState (processContent o c) a) st $
20:45:23 <naren>            zip contents outcomes
20:45:29 <c_wraith> Oh.  You don't even need to parse the value of it?  That's quite a lot easier, then
20:45:30 <copumpkin> fata_erro: by being represented as a tree
20:45:39 <m4ik3ru> whether or not the string is a valid number
20:45:39 <Cale> fata_erro: It's internally a tree. Most of the subtrees are shared between the new and old tree.
20:45:46 <naren> and when it runs I get too many open files problem... because i am processing a lot of files
20:45:52 <fata_erro> ah i see
20:45:56 <m4ik3ru> there are several charachteristics i have to meet
20:45:57 <Cale> fata_erro: Only a path from the changed element up to the root needs to be copied.
20:46:04 <naren> how can I convert those two statemnts to process it one at a time?
20:46:08 <m4ik3ru> rather, that the string has to meet
20:46:16 <Cale> Well, "copied" -- the nodes are genuinely different :)
20:46:33 <fata_erro> hmmm
20:46:53 <fata_erro> so is there a memcpy happening?
20:47:31 <Cale> naren: One easy option is to use the strict Data.ByteString library, and convert to a String
20:47:38 <copumpkin> fata_erro: not really
20:47:40 <Cale> fata_erro: no
20:47:45 <naren> Cale: how will that help?
20:47:46 <fata_erro> ok
20:47:55 <copumpkin> fata_erro: it's pretty efficient
20:47:57 <Cale> fata_erro: Just log(n) new tree nodes being constructed.
20:48:28 <fata_erro> also does ghc 6.10 have a utf8 yet?
20:48:36 <copumpkin> fata_erro: nope
20:48:43 <ddarius> If anyone does solve the GUI exercise problem I stated above, I would be interested in how they approached it.  It's specifically designed to be uncomfortable using "traditional" approaches.
20:48:47 <copumpkin> fata_erro: there's a library for it though, and 6.12 is coming out very soon, with utf8 support built in
20:49:01 <Cale> naren: The string you get from readFile is magic in that it keeps the file open and only reads it as you process the string.
20:49:13 <m4ik3ru> i have to catch up on sleep, i'll deal with these one tomorrow
20:49:17 <m4ik3ru> thanks for all of your help!
20:49:30 <Cale> naren: This is convenient when working with just a few files (which might be very long), but it means you lose control over the filehandles.
20:49:50 <fata_erro> copumpkin: is http://hackage.haskell.org/package/utf8-string-0.3.5 drop inreplacement for prelude until 6.12?
20:50:02 <Cale> naren: Your only guarantee is that the filehandle gets closed when the string is garbage collected (which is some point after it becomes garbage)
20:50:22 <naren> Cale: so you  are saying that converting to string closes the file handle?
20:50:25 <Cale> naren: Strict bytestrings have a readFile which just slurps the whole file into memory at once.
20:50:39 <Cale> naren: (and closes the file immediately)
20:51:06 <Cale> whereas the normal readFile in the Prelude keeps the file open until you're done with the string.
20:51:13 <naren> Cale: gotcha, so can I just do that along with readFile in that code I pasted?
20:51:36 <Cale> naren: Is there any need for UTF-8 encoding?
20:51:40 <naren> Cale: nope
20:52:22 <naren> Cale: The sequence function is strict right? I mean since it operates of monads.
20:52:30 <Cale> naren: If not, you can just import qualified Data.ByteString.Char8 as BS, and then replace readFile with BS.unpack . BS.readFile
20:52:36 <Cale> er
20:53:03 <Cale> fmap BS.unpack . BS.readFile  rather
20:53:15 <Cale> naren: Monads and strictness are unrelated
20:53:34 <Cale> sequence is strict in that it will pattern match on the list that you give it
20:53:35 <naren> Cale: great, thanks! I'll try it out. [yea, I sort of mis stated that]
20:54:10 <Cale> (But apart from that it's not very strict)
20:54:26 <beutdeuce> thanks for all the help and suggestions guys, good night to all.
20:55:24 <Cale> fata_erro: I like the utf8-light package better
20:55:24 <fata_erro> would a map be much faster with bytestring vs String?
20:56:08 <copumpkin> fata_erro: you sound like you're committing the ultimate sin ;)
20:56:21 <Cale> fata_erro: Well, storing lots of bytestrings will certainly take less memory.
20:56:41 <fata_erro> lol
20:56:58 <ddarius> Very small bytestrings take more memory than equivalent strings.
20:56:58 <Cale> Strings are rather wasteful (but convenient)
20:57:01 <fata_erro> i was thinking of a trie
20:57:17 <Cale> ddarius: How small though?
20:57:26 <copumpkin> a trie would hold single characters unless you want to store common runs of characters
20:57:28 <ddarius> Very, like a few characters.
20:57:41 <ddarius> copumpkin: Or tails.
20:58:01 <dons> fata_erro: map over Word8?
20:58:03 <Cale> fata_erro: What is it that you're actually trying to store?
20:58:15 <dons> Cale: 7 chars
20:58:23 <fata_erro> my map stores words as keys and integer as value. basically number of tims word occurs in document
20:58:28 <Cale> dons: For strict bytestrings?
20:58:46 <naren> Cale: Wow, that worked well. Pretty incredible.
20:59:03 <Cale> naren: great :)
20:59:35 <jfredett> seems that dons is talking to himself (Cale) again... he's our favorite DID haskell hacker. :)
20:59:38 <Cale> naren: It would be nicer if there were just a readFile' or something which was implemented something like that.
20:59:55 <dons> Cale: yup. worse for lazy
21:00:11 <BMeph> jfredett: Ah, ah, ah, no making up quotes for yourself! ;p
21:00:35 <Cale> dons: That's actually a bit surprising, I would have imagined maybe 2 or 3.
21:00:36 <fata_erro> so would my map benefit for bytstrings instead of string?
21:00:58 <jfredett> BMeph: I actually fretted a bit over including that one from that crazy HWN editor from last week, but it made me laugh so much...
21:01:26 <magma> @pl freqs xs = [count x xs `percent` lowers xs | x <- ['a'..'z']]
21:01:26 <lambdabot> freqs = return . (<- ['a'..'z']) . (| x) . ap (percent . count x) lowers
21:01:51 <jfredett> BMeph: The real issue is, yall don't say enough funny stuff, I only had those quotes to pick from, and I really want to make sure I have about that many per episode. The Quotes in the HWN are like the Funnies in the regular newspaper: The only reason most readers read the paper...
21:02:02 <magma> @pl rotate n xs = drop n xs ++ take n xs
21:02:02 <lambdabot> rotate = ap (ap . ((++) .) . drop) take
21:02:08 <naren> Cale: Here is question about Bytestrings vs Strings. Often, I want to just use ByteStrings because they are fast and compact... but I often find that I can't create generic code that works on both. Do you have any advice on this?
21:02:09 <ivanm> jfredett: how did you know? :o
21:02:12 <ivanm> ;-)
21:02:17 <coco`> is there a way to import all the operations of one file as qualified, and a type as unqualified with a single import clause?
21:02:22 * ivanm also reads HWN to get summaries of released/updated packages
21:02:28 <ivanm> coco`: no
21:02:34 <coco`> workaround?
21:02:46 <jfredett> you can import twice.
21:02:51 <ivanm> coco`: import qualified Data.Map as M; import Data.Map(Map)
21:02:52 <copumpkin> > let rotate n xs = drop n xs ++ take n xs in rotate 5 [1..10]
21:02:53 <lambdabot>   [6,7,8,9,10,1,2,3,4,5]
21:02:56 <ivanm> (with a newline in between)
21:02:57 <coco`> :(
21:02:59 <jfredett> import qualified Foo hiding Type
21:03:04 <jfredett> import Foo(Type)
21:03:07 * ddarius reads HWN for blog posts not on Planet Haskell and quotes.
21:03:07 <jfredett> or something like that.
21:03:11 <blackdog> ivanm: you can just subscribe to the twitter hackage feed for that:)
21:03:13 <ivanm> jfredett: is there really any point in hiding _anything_ when doing it qualified?
21:03:18 <ivanm> blackdog: *shudder*
21:03:19 <copumpkin> > let rotate n xs = uncurry (flip (++)) $ splitAt n xs in rotate 5 [1..10]
21:03:20 <lambdabot>   [6,7,8,9,10,1,2,3,4,5]
21:03:21 * ivanm avoids twitter
21:03:25 <Cale> naren: Yeah, that's a problem. Unfortunately, ByteStrings don't really fit nicely into the polymorphic interfaces like Foldable which would otherwise be ideal for making that abstraction.
21:03:32 <copumpkin> magma: that seems simpler
21:03:38 <ivanm> jfredett: you planning on fixing line endings any time soon though? :p
21:03:42 <jfredett> ddarius: I'm working on aggregating some new haskell blogs. Recently I've just been dumping PH into it. :/
21:03:44 <BMeph> jfredett: I read it for the articles. No, honest, quit laughing at me!
21:03:54 <ddarius> ivanm: You can import several modules with the same qualified name.
21:03:55 <blackdog> ivanm: you can subscribe in an RSS reader too
21:03:58 <ivanm> or are you going to see how many more reddit subscribers it will get first? :p
21:03:59 <jfredett> ivanm: yah- I think the issue is that I'm sending it from a mac.
21:04:05 <jfredett> and thats mucking w/ the endings.
21:04:06 <blackdog> BMeph: not the hot lambda honeys?
21:04:13 <ivanm> ddarius: true... but should you be doing so if they have clashes?
21:04:27 <jfredett> The messed up endings don't appear for me, and aren't part of the seq.complete.org version
21:04:31 <ivanm> jfredett: or maybe your email editor has longer lines than are liked?
21:04:44 * ivanm thought he saw them on the seq.complete.org version...
21:04:46 <Cale> I wonder if ByteString could/should be made a data family, and whether that could solve the problem.
21:04:47 <jfredett> it's only on the archives and (apparently) some peoples clients.
21:04:51 <magma> copumpkin: Thanks!  ... But I think I'll stick with rotate n xs = drop n xs ++ take n xs ^^;;
21:05:02 <copumpkin> magma: but mine is marginally more efficient! ;)
21:05:02 <ivanm> hmmm, maybe not
21:05:06 <Cale> That is, have ByteString Char and ByteString Word8
21:05:14 <copumpkin> magma: actually, it isn't
21:05:17 <jfredett> ivanm: I'm going to try sending it via sendmail on my linux box, I figure if it happens there, it's likely not the email client that sends it.
21:05:27 <naren> Cale: I have to take you back to the code for a sec. contents <- sequence ((B.unpack <$>) . B.readFile <$> filenames)
21:05:27 <naren>   return $ foldl' (\a (c,o) -> execState (processContent o c) a) st $
21:05:27 <naren>            zip contents outcomes. This is now throwing a stack overflow. What I really want this code to look like is to not get all the contents first, but to apply the next statement one at a time ...reading and closing files. Not sure how to do that though.
21:05:27 <magma> copumpkin: it is a lot more impressive, though
21:05:31 <ivanm> jfredett: *nod*
21:05:49 <fata_erro> i guess i picked the wrong laguage towrite a text classifier.....
21:05:58 <ivanm> jfredett: is your blog on planet? I don't recall reading your HWN-related articles there...
21:05:58 <copumpkin> fata_erro: guess so :)
21:06:14 <Cale> naren: oh, right, yes, that's going to read absolutely everything into memory, and then return a left fold over it.
21:06:19 <jfredett> What I want to avoid is having to write a line-wrapper for the existing software, as that seems about as fun as getting waterboarded during a root canal w/o anesthetic.
21:06:26 <fata_erro> copumpkin: it was between ocam, haskell and erlang
21:06:36 <ivanm> jfredett: use a pretty-printer! :p
21:06:36 <Cale> naren: (without evaluating that left fold)
21:06:39 <jfredett> ivanm: No, my blog isn't on PH.
21:06:46 <jfredett> ivanm: ...
21:06:49 <ivanm> any reason it isn't?
21:06:51 <naren> Cale: See, i would have thought that because of lazy eval ... it would process that list one at a time
21:06:56 <magma> @pl count x = length . filter (== x)
21:06:56 <lambdabot> count = (length .) . filter . (==)
21:07:04 <jfredett> ivanm: ATM, doing anything to the existing software is scary... :P
21:07:04 <fata_erro> copumpkin: but when writing inerlang keep missing where and let etc
21:07:12 <Cale> naren: The order of execution must be followed though.
21:07:16 <ivanm> jfredett: heh... whose fault is that? dons' or byorgey's?
21:07:20 <copumpkin> fata_erro: I was just being silly when I agreed with you :P
21:07:25 <Cale> (which is a separate thing from the order of evaluation)
21:07:29 <fata_erro> lol
21:07:33 <jfredett> ivanm: no, just never bothered to get it added or anything, I don't really do all sorts of haskell. or posting at all for that matter.
21:07:38 <fata_erro> i was serious
21:07:44 <jfredett> ivanm: neither, it was just written a long time ago...
21:07:53 <Cale> naren: So all the readFiles have to happen before that return.
21:07:59 <ivanm> :o I thought dons started HWN...
21:08:11 <fata_erro> erlang has lists period
21:08:23 <fata_erro> not utf no alternatives nothing
21:08:26 <c_wraith> hmm.  lambdabot took advantage of the commutativity of == in that last @pl.  Does it just have that property stored in a table somewhere?
21:08:27 <naren> Cale: So, is my only way to solve this to create a new function that would do all the steps for each file?
21:08:27 <jfredett> before cabal, and without the forethought to make it easily extensible.
21:08:35 <Orclev> I finally finished the functional version of that python program tehgeekmeister was trying to convert
21:08:38 <jfredett> ivanm: I think John Goerzen started it.
21:08:40 <Cale> naren: It might be possible to use foldM
21:08:43 <ddarius> ivanm: John Goerzen did, I'm pretty sure, considering it is his server.
21:08:48 <jfredett> ivanm: least, he runs the site.
21:08:57 <ivanm> fata_erro: I don't think it "took advantage" of it... it was just that how you wrote it
21:09:01 <Orclev> now to run hlint on it and find out the thousands of horrible things I did wrong
21:09:01 <ivanm> ahhh
21:09:09 <jfredett> ivanm: though he's been MIA since I took over. :/
21:09:14 <ivanm> ddarius: I thought it just got put there, didn't realise it started there ;-)
21:09:30 <jfredett> ivanm: I have archives... if you want to see them. :P
21:09:37 <ddarius> It's always been there.
21:09:41 <ivanm> heh, not that desperate ;-)
21:09:48 <jfredett> actually, there in the old repo. :P
21:09:59 <fata_erro> just a quick question who uses the kinesis keyboard here?
21:10:21 <dcolish> any of you run ghc on openbsd?
21:10:48 <BMeph> jfredett: Yeah, complete.org is a CosmicRay(TM) production. :)
21:11:57 <jfredett> BMeph: hehe.
21:13:12 <Cale> naren: Maybe something like...  foldM (\a (fn,o) -> do c <- B.unpack <$> B.readFile fn; return (execState (processContent o c) a)) st $ zip filenames outcomes
21:13:44 <Cale> naren: If that doesn't work out, try replacing return with Control.Exception.evaluate
21:14:17 <Cale> (I really should think about what should happen, but it's easier just to try it ;)
21:14:58 <fata_erro> is there any support for regexes over utf8?
21:15:38 <ivanm> you can do regexes over bytestrings IIRC...
21:15:49 <Cale> fata_erro: Theoretically, it shouldn't be an issue with Strings, but I'm not sure how the backends for regexes handle it.
21:15:59 <Cale> fata_erro: However, I would just use Parsec, myself.
21:16:23 <ivanm> Cale: any particular reason for picking parsec over another parsing library (in general even)?
21:16:28 <fata_erro> lol i'm not up to that chapter in rwh
21:16:28 <Cale> Well...
21:16:51 <BMeph> Cale: 'Cause it's light-years ahead of the competition? ;p
21:17:01 <Cale> ivanm: It's probably the most polished parsing library.
21:17:06 <ivanm> *nod*
21:17:11 <ivanm> even though no-one uses parsec-3? :p
21:17:15 * BMeph likes his answer better!
21:17:26 <ivanm> BMeph: literal light years? :p
21:17:47 <Cale> 3.26163626 light years
21:17:48 <BMeph> ivanm: Well, its name IS 'Parsec', so... ;p
21:17:58 <ivanm> heh
21:18:48 <Cale> 30.8568025 petameters
21:18:54 <jfredett> ... See- why hasn't someone hit the @remember switch on that one from BMeph! Comeon people! You make the news!
21:19:08 <lament> parsec is a strange unit
21:19:25 <jfredett> @remember BMeph (about parsec)> 'Cause it's light-years ahead of the competition!
21:19:25 <lambdabot> Okay.
21:19:27 <ivanm> jfredett: because I dind't think it was _that_ funny, and it needs context as a quote
21:19:55 <jfredett> ivanm: it's okay, I can sort through it, but when I only have four quotes, I can't pick the good ones... :P
21:20:01 <monochrom> hahahah Cale
21:20:17 <ivanm> jfredett: heh
21:21:30 <Cale> Parsec can be a bit annoying in that it doesn't have symmetric choice though
21:21:51 <ivanm> Cale: what do you mean by symmetric choice?
21:22:01 <BMeph> jfredett: Hm, that's not quite cricket, to me. Not as bad as quoting one's self, but "up there." :|
21:22:12 <fata_erro> tell my is haskell so hard?
21:22:16 <fata_erro> me*
21:22:40 <fata_erro> did it start of hard?
21:22:42 <jfredett> BMeph: ... I am lost in your jargon. not quite cricket? I'm just a boston boy, lad.
21:22:56 <blackdog> not the done thing, old chap.
21:22:59 <fata_erro> or is it gotten more complicated over the years
21:23:05 <Cale> ivanm: Parsec's <|> is biased to the left. If the left branch succeeds at all, then the right branch isn't tried. (At least if I'm remembering things correctly)
21:23:06 <blackdog> not playing the game.
21:23:22 <blackdog> fata_erro: it's not fundamentally complicated. it's just very different to most other languages.
21:23:55 <fata_erro> i  disagree ocaml an erlang are easy in comparison
21:24:04 <ivanm> Cale: so you have to make sure the left one doesn't partially succeed (that is, it doesn't succeed too early when it should have been the right one that succeeded)?
21:24:06 <BMeph> jfredett: Okay, how's about "not quite going by the spirit" of quoting? :)
21:24:14 <Cale> ivanm: yeah
21:24:24 <ivanm> fata_erro: I had a look at erlang... I found Haskell easier ;-)
21:24:25 <jfredett> aah, I suppose, but it's other people who I am charging here.
21:24:28 <naren> Cale: Hmm, i still get stack overflow
21:24:34 <fata_erro> ivanm: what?
21:24:35 <Cale> naren: hmm...
21:24:40 <jfredett> Yall need to farm me some funny, so I don't have to work so hard... :)
21:24:44 <fata_erro> ivanm: no way
21:24:49 <ivanm> fata_erro: yes way
21:24:49 <Cale> naren: It would be helpful if I could run your program.
21:24:58 <ivanm> fata_erro: erlang's syntax has serious issues
21:25:00 <copumpkin> fata_erro: just because people tend to classify haskell into a box with erlang and ocaml doesn't mean the languages are very similar
21:25:07 <fata_erro> ivanm: too much haskell coolaid
21:25:12 <ivanm> pfffftttt
21:25:34 <ivanm> fata_erro: no strings, lambda's are weird, functions with the same name but different parity, etc.
21:25:42 <blackdog> fata_erro: it's hard to be objective about these things. what do you mean by hard? do you find it difficult to build programs? difficult to understand errors? difficult to debug runtime behaviour?
21:25:53 <copumpkin> fata_erro: I came from over a decade of c, java, etc. (my favorite used to be ruby), and haskell felt so intuitive (if mind-bending) when I first saw it
21:26:32 <fata_erro> blackdog: haskell has taken ages and ages to learn and i still have a long way to go
21:26:41 <ivanm> I never did ruby, but I too found Haskell intuitive (albeit mind-bending) compared to Java, etc.
21:26:43 <fata_erro> erlang 2 days
21:27:00 <copumpkin> and now all the languages I used to use feel clunky when I return to them, sadly
21:27:24 * ivanm had done Turbo Pascal/Delphi, Java, Matlab, and bits of C, Fortran, Scheme and Python before Haskell
21:27:30 <blackdog> fata_erro: it would be helpful if you were more specific about what your problems were.
21:27:32 <ivanm> copumpkin: too true
21:27:33 <naren> Cale: how can I send the program to you?
21:27:45 <copumpkin> fata_erro: I learned X in Y time, but Z is taking much longer. Z sucks!
21:27:55 <copumpkin> fata_erro: that's saying more about you than it is about Z :)
21:27:57 <Cale> fata_erro: It's only hard until you're used to it. When I was first learning, it was about 2 months before I felt like I could really write useful programs, and about 1 year to feel comfortable. We have better tutorials now. However, I still don't think that Haskell is fundamentally any more difficult to learn than, say, Python. It's just very different, so it's more like learning your first programming language was (only maybe harder due to the expectation t
21:27:57 <Cale> hat you know what you're doing).
21:28:01 <BMeph> Ruby felt to me like it tries to be OO and functional, but tries too hard, sometimes. Like blocks...yecch.
21:28:04 <fata_erro> copumpkin: no i never said haskell sucks
21:28:12 <Cale> naren: Maybe email? cgibbard@gmail.com
21:28:12 <jonh> copumpkin: thats why we just ignore the Z
21:28:19 <ddarius> try a <|> b should be symmetric.
21:28:29 <copumpkin> fata_erro: sorry, I meant "too hard" :)
21:28:47 <blackdog> BMeph: yeah. ever had a look at lambda scoping in ruby?
21:28:49 <fata_erro> lol
21:28:52 <blackdog> is beyond hideous.
21:28:54 <copumpkin> blackdog: OH MY GOD
21:28:57 <copumpkin> yeah :P
21:29:08 <copumpkin> I couldn't believe it when I saw it
21:29:12 <blackdog> ruby 1.9 fixed it a bit, but not a lot.
21:29:13 <fata_erro> my barin hurt from the newtype hoops in rwh
21:29:16 <copumpkin> the return from proc vs. lambda thing
21:29:24 <ivanm> @remember copumpkin [about learning Haskell compared to other languages] I learned X in Y time, but Z is taking much longer. Z sucks!
21:29:25 <lambdabot> Good to know.
21:29:32 <naren> Cale: sent it
21:29:43 <ivanm> just to make jfredett happy ;-)
21:29:50 <copumpkin> :)
21:30:04 <ivanm> fata_erro: "newtype hoops"?
21:30:05 <copumpkin> anyone want a rude haskell (CT) domain?
21:30:05 * ddarius doesn't know how trying to be OO and trying to be functional are at odds with each other.
21:30:09 <ivanm> I dind't realise there were any hoops...
21:30:13 <fata_erro> it didn't make sense that you had to do all that not to use typesynonym extension
21:30:20 <ivanm> copumpkin: what do you mean?
21:30:26 <ivanm> fata_erro: it's not just for that
21:30:29 <ivanm> it's for safety
21:30:48 <fata_erro> safety?
21:30:49 <copumpkin> ivanm: I bought 2naturaltransformations1functor.com but haven't used it for anything yet, but would be happy to transfer it to someone more imaginative :P
21:30:50 <ivanm> e.g. if you want to create a slightly different version of another datatype
21:30:59 <ivanm> copumpkin: *sigh*
21:31:05 <BMeph> ddarius: Yes, you'd think they'd be complementary, wouldn't you? Ruby makes it feel like they're at odds, though - but I never explored Ruby too far. I just dabble. :)
21:31:17 <Cale> naren: How should I try running it?
21:31:22 <ivanm> fata_erro: the more common usage of newtype is if you want to stop users from seeing how you're secretly doing cool stuff inside your type
21:31:25 <blackdog> copumpkin: that's categorically disgusting.
21:31:40 <copumpkin> blackdog: I hope it brings wonderful images to mind
21:31:41 <naren> Cale: I am sending another email with the necessary input data
21:31:42 <ddarius> BMeph: Not even complementary in some areas.  Lexical scoping and tail calls are just as important for OO as they are for FP.
21:31:45 <ivanm> fata_erro: not quite the same, but see how in Data.Map, Data.Set, etc. they don't export the constructors
21:31:46 <Cale> okay :)
21:31:50 <naren> Cale: sent
21:32:00 <fata_erro> ivanm: yeah
21:32:11 <ddarius> Incidentally, in the usually presentation, a monad is two natural transformations and a functor...
21:32:23 <blackdog> ddarius: really? OO languages with broken scope seem to do ok
21:32:25 <copumpkin> ddarius: that's why I bought it :)
21:32:26 <naren> Cale: extract enron1. and then enter ghci :l Main.hs. and then do let t = initNB 2 >>= processFiles "master" and then totalWords <$> t
21:32:38 <blackdog> you just couldn't write functional code with ruby. the scope is so badly broken...
21:32:47 <fata_erro> who wrote hpaste2?
21:32:49 <naren> put those stopwords and master file in the same dir as well
21:32:56 <Cale> naren: Somehow I still only have your first email... I'll wait a minute
21:32:57 <copumpkin> fata_erro: not sure who wrote it, but mmorrow_ hosts it
21:33:23 <fata_erro> it needs more work
21:33:26 <ddarius> blackdog: That's because people write procedural code in OO languages mostly.  I repeatedly run into cases where TCO would be necessary for the natural OO decomposition.
21:33:29 <fata_erro> polish it up
21:33:32 <ddarius> E.g. open recursion cases.
21:33:56 <copumpkin> fata_erro: sounds like a good project for... you!
21:34:18 <Cale> naren: Oh, did you try the 'evaluate' thing?
21:34:19 <fata_erro> copumpkin: lol i have my hands full atm
21:34:25 * ivanm hates it when people say "project Foo needs more work"...
21:34:30 <ddarius> I have some C# code that implements thunks that would stack overflow written the right way so I need to use a while loop and 'is' which is certainly not the Right Way.
21:34:33 <copumpkin> fata_erro: we're too busy doing zygohistormophic prepromoprhisms with our heads in category theory to improve it :)
21:34:33 <blackdog> ddarius: ah, i see what you mean. i suppose you could argue that Erlang is functional in that sense - each process loop is an object, so the recursive call better be tail recursive...
21:34:42 <BMeph> "In Soviet Haskell, projects volunteer YOU!" ;p
21:34:42 <blackdog> blha, is OO i mean
21:34:44 <Cale> naren: and... it still hasn't appeared in my inbox
21:34:49 <fata_erro> lol
21:35:01 <ivanm> BMeph: heh
21:35:07 <ddarius> blackdog: Concurrency was closely tied to OO in the beginning.  I have no idea why so many have lost it.
21:35:13 <monochrom> @remember BMeph "In Soviet Haskell, projects volunteer YOU!"
21:35:13 <lambdabot> I will never forget.
21:35:13 <ivanm> @remember BMeph In Soviet Haskell, projects volunteer YOU!
21:35:13 <lambdabot> It is forever etched in my memory.
21:35:13 <naren> Cale: i had to extract that lambda in the foldM into an external function processFile. It was complaining something about last statemnt in do must be return
21:35:16 <ivanm> monochrom: heh
21:35:21 <ivanm> @forgot BMeph In Soviet Haskell, projects volunteer YOU!
21:35:21 <lambdabot> Done.
21:35:24 <blackdog> HWN: the BMeph special:)
21:35:27 <ivanm> @quote Soviet
21:35:27 <lambdabot> BMeph says: "In Soviet Haskell, projects volunteer YOU!"
21:35:31 <naren> Calse: you should have the code in the first email
21:35:45 <Cale> naren: I do.
21:35:50 <copumpkin> I prefer the one without quotes
21:35:58 <Cale> naren: Try changing the 'return' in processFile to 'evaluate'
21:35:59 <sjanssen> ivanm: yeah.  I think if you're going to criticize something, it is only right to be specific
21:36:00 <monochrom> It is hard to have this simultaneous coincidence!
21:36:01 <ivanm> quick, someone flush lambdabot so that gwern doesn't get annoyed and jfredett disappointed!
21:36:03 <Cale> and importing Control.Exception
21:36:05 <blackdog> ddarius: yeah. now you have the whole "actor" model coming back in as if it's something new.
21:36:10 <sjanssen> @flsuh
21:36:13 <ivanm> sjanssen: and constructive
21:36:17 <naren> Cale: oh crap. I sendt the second email from another account. So you should see it from narens
21:36:19 <monochrom> "Welcome to #haskell, where @remember's are in majestic stereo!"
21:36:26 <ivanm> monochrom: lol
21:36:39 <Cale> naren: ah, maybe it's taking longer from there
21:36:47 <Cale> naren: since it's not gmail-internal
21:36:54 <ivanm> on the other hand, I found it annoying that people could send me bug-reports and feature requests for graphviz, but when I sent an email to -cafe asking for opinions on how to do some stuff no-one responded...
21:37:04 <blackdog> monochrom: quotebait:P
21:37:27 <Orclev> how do the remembers work anyway?
21:37:38 <ivanm> Orclev: lambdabot stores them
21:37:44 <copumpkin> @remember monochrom Welcome to #haskell, where @remember's are in majestic stereo!
21:37:44 <lambdabot> Nice!
21:37:48 <copumpkin> ;)
21:37:55 <ivanm> though IIRC, the HWN quotes are extracted by parsing the logs, rather than asking lambdabot for them
21:37:58 <monochrom> tee hee hee!
21:38:01 <naren> Cale: it says Control.Exception.evaluate is not in scope
21:38:07 * BMeph misses the contrapuntal fugue
21:38:13 <Cale> naren: Did you import Control.Exception
21:38:25 <dancor> BMeph: can't you just write one?
21:38:27 <monochrom> Well, @remember hasn't reached the fugue stage yet.
21:38:29 <Orclev> I meant more along the lines of how do you ouput them
21:38:40 <ivanm> monochrom: how do we define the fugue state?
21:38:43 <Orclev> output even
21:38:51 <ivanm> stereo quotes about stereo @remembers?
21:39:04 <naren> Cale: duh. running... What is it supposed to do?
21:39:19 <monochrom> Need to see a coincidence of at least 3 people doing the same @remember at almost the same time. We only have 2 now, stereo.
21:39:32 <ivanm> ahhh
21:39:40 <monochrom> Whereas we already easily have 3 or more people answering the same newbie. Fugue.
21:39:41 <Cale> naren: It should force the evaluation to occur in step with the I/O
21:39:43 <ivanm> quick! someone say something memorable!
21:40:07 <ivanm> so what's after fugue?
21:40:10 <ivanm> contrafugue?
21:40:25 <monochrom> Well supposedly fugue takes care of all cardinalities.
21:40:38 <ivanm> for > 2 you mean?
21:40:42 <Cale> naren: Stack overflows occur when you try to evaluate a giant unevaluated expression whose outermost reducible subexpression is deep inside it
21:40:52 <monochrom> Mozart would like to boast that his opera fugues have 10 people.
21:40:53 <blackdog> no-one's needed an uncountable harmony yet, clearly.
21:41:13 <naren> Cale: i see...
21:41:19 <Cale> naren: So, by forcing some of the evaluation to occur after each file, the hope is that the expressions will not have a chance to grow so large.
21:41:36 <naren> Cale: still happens with evaluate
21:41:41 <monochrom> But if we do get to have 40 people answering a newbie, we can call it a choir.
21:41:53 <Cale> hmm, okay, so maybe it's something else...
21:42:14 <naren> Cale: still not got the email? I can send it with gmail...
21:42:29 <Cale> yeah, still nothing
21:42:48 <Cale> try sending it with gmail
21:43:32 <Cale> Oh, I just realised something.
21:43:44 <Cale> Well, when I get the files, I'll try it
21:44:08 <Orclev> to anyone that was around when tehgeekmeister was trying to re-write that python code, I finally finished my take on it all, no doubt it's ugly as sin and I've broken a few dozen rules, but hlint seems happy with it, and it runs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9696#a9696
21:44:27 <naren> Cale: sent
21:44:59 <Cale> Oh! They were ending up in my Spam folder
21:45:06 <naren> Cale: lol
21:45:30 <naren> Cale: incidentally... that program is a spam filter ;-) for a class project
21:45:56 <ivanm> naren: Cale's spam filter is obviously trying to stay in business...
21:46:02 <ivanm> what is a "negated pattern"?
21:47:12 <sjanssen> ivanm: I don't think Haskell has them
21:47:23 <ivanm> sjanssen: HSX says otherwise :s
21:47:55 <ddarius> So is the next standard of Haskell going to be Haskell X?
21:47:55 <ivanm> Language.Haskell.Exts.Syntax.Pat has a constructor "PNeg Pat"
21:48:03 <ivanm> why X?
21:48:04 <Orclev> oh, speaking of lambdabot features, I know there's a way to leave a message for someone, how do you do that?
21:48:12 <ivanm> @message Orclev this is how
21:48:12 <lambdabot> Maybe you meant: messages messages?
21:48:17 <ivanm> @tell Orclev this is how
21:48:17 <ddarius> 2010
21:48:17 <lambdabot> Consider it noted.
21:48:18 <ivanm> whoops
21:48:28 <ivanm> ddarius: hopefully the year, anyway ;-)
21:48:50 <naren> Cale: able to run it?
21:48:57 <sjanssen> ivanm: they might have been supported in that Haskell pattern extension preprocessor thing
21:49:06 <Orclev> @tell tehgeekmeister my take on the problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9696#a9696
21:49:06 <lambdabot> Consider it noted.
21:49:08 <Makoryu> @where she
21:49:08 <lambdabot> I know nothing about she.
21:49:11 <Cale> naren: yep, just trying something
21:49:14 <Makoryu> OH REALLY
21:49:19 <ivanm> sjanssen: oh? never heard of it
21:49:28 <ivanm> @google Haskell pattern extension preprocessor thing
21:49:29 <ivanm> ;-)
21:49:30 <lambdabot> http://www.cs.chalmers.se/~d00nibro/harp/
21:49:30 <lambdabot> Title: Haskell Regular Patterns
21:49:32 <ivanm> :o
21:49:55 <Cale> naren: actually, although it's nice getting things to work in ghci, compiling with optimisations often removes problems of this sort on its own
21:50:05 <naren> Cale: oh?
21:50:10 <Cale> naren: But I think I might know what's going on.
21:50:11 * ivanm didn't expect a match, let alone one that looked valid..
21:50:24 <Cale> naren: How long do you normally have to wait for the overflow?
21:50:33 <sjanssen> ivanm: oh man Google is ridiculous
21:50:47 <Orclev> trhsx, that has got to be one of the ugliest command names I've ever seen
21:50:47 <lambdabot> Orclev: You have 1 new message. '/msg lambdabot @messages' to read it.
21:50:47 <naren> Cale: a min perhaps? it takes a while... there a lot of files
21:50:48 <BMeph> Say, don't we have 'Down' (type alias to reverse order) packaged somewhere?
21:51:09 <BMeph> Or did it not get any farther than the -cafe discussion?
21:52:10 <Cale> naren: Well, it's survived for about 2:30 so far here...
21:52:19 <Cale> naren: Not that that means much ;)
21:52:25 <naren> Cale: haha
21:53:09 <ddarius> BMeph: It should be there in support of Wadler's crazy "comprehensive" comprehensions.
21:53:12 <naren> Cale: in a nutshell, all its doing is splitting file into words cleaning some words and the keeping a map of how many of each there are
21:53:42 <naren> Cale: so in terms of mem usage apart from reading files... it should be minimal
21:53:58 <Cale> naren: If you want to try the same thing, I made all the fields in the NB type strict
21:54:11 <naren> Cale: how do you do that?
21:54:40 <Cale> data NB = NB { totalWords :: !(M.Map Int Int), probs :: !(M.Map String [Int]), outcomeProbs :: !(M.Map Int Int), stopwords :: !(M.Map String ()), numOutcomes :: !Int } deriving (Show)
21:55:42 <naren> Cale: I had no idea you could do that
21:55:48 <naren> Cale: running...
21:56:53 <Cale> naren: It means that if something tries to pattern match on NB, those fields will all be evaluated to WHNF, which in the case of the maps, means their structure, but not their elements, and for the Int, means completely evaluated.
21:57:46 <naren> Cale: Amazing... it finished
21:57:47 <Cale> naren: (this is in addition to the evaluate change)
21:58:08 <Cale> Oh, cool. You probably have a much faster computer than I do ;)
21:58:21 <naren> Cale: I am impressed! Finally, i can say to myself that haskell can be used for intense programs
21:58:29 <naren> Cale: < 2 mins
21:59:22 <Cale> :)
21:59:32 <naren> Cale: so the evaluate function makes everything in the processFile function evaluate immediately?
22:00:05 <BMeph> Cale: You mean that Maps aren't strict automatically?
22:00:50 <Zeiris> Would a sleep() or wait() function count as pure?
22:01:06 <Zeiris> Or is the fact that it's not 100% accurate to the nanosecond, disqualify it?
22:01:33 <Cale> BMeph: Fields in a datastructure which happen to be maps may be expressions which describe maps rather than physical map datastructures, yes.
22:02:20 <Cale> naren: It makes sure that the result of (execState ...) is evaluated into WHNF, the smallest amount which you could possibly do to pattern match
22:02:42 <naren> Cale: Sorry... WHNF is?
22:02:49 <Cale> Weak Head Normal Form
22:03:05 <Cale> Basically it means "up to determining what the top-level data constructor is"
22:03:26 <Cale> So, for lists, it would mean just enough evaluation to decide if it's an empty list or not.
22:04:01 <naren> Cale: gotcha. So, how do decide when to use it? Is it just for performance reasons?
22:04:03 <Cale> The strictness annotations in the NB type meant that when evaluating any value of type NB into WHNF, you have to evaluate all those fields into WHNF too.
22:04:13 <Cale> It's mainly a performance thing.
22:04:48 <naren> Cale: v. interesting. Have a lot to learn about performance issues
22:04:52 <Cale> The main rule of thumb is that strictness is important when you're taking lots of data and summarising it into something more concise
22:05:03 <naren> Cale: Hell... I'm still staying away from Arrays :-(.
22:05:22 <Cale> Arrays are not as useful as Data.Map for the most part
22:05:44 <naren> Cale: Is Data.Map purely functional?
22:06:05 <Cale> Yeah
22:06:15 <roconnor> blasted, I just noticed that the editor turned my literate haskell code for my monad reader article into illiterate haskell code!
22:06:18 <Cale> There's no magic in there, as far as I know.
22:07:00 <naren> Cale: well, thanks a bunch for your help. I'm gonna take off...
22:07:10 <Cale> naren: Compiled with -O2 on my machine it takes 1m 20s, whereas it had run for over 5 minutes in ghci without finishing.
22:07:23 <roconnor> Damn You Wouter!!
22:07:24 <naren> Cale: oh, nice... so it should be even faster here :-)
22:07:43 <roconnor> @slap wswierstra
22:07:43 * lambdabot clobbers wswierstra with an untyped language
22:09:06 <naren> Cale: you know what doesn't make sense to me? Since, every function is refrentially transparent... i don't know why during lazy evaluation haskell doesn't cache results. Why does it only cache it if you use a let statement
22:09:29 <Cale> Because you'd run out of memory so quickly that it would make your head spin ;)
22:09:39 <Jafet> "haskell", or "ghc"?
22:09:43 <naren> Cale: what about just frequently used
22:10:01 <Cale> and it's hard to decide automatically what's worth caching
22:10:02 <naren> Cale: good point. ghc i guess.
22:10:14 <Cale> However, there is a really nice library called memocombinators
22:10:26 <Jafet> Certainly your impl can, if it wants
22:10:30 <Jafet> And isn't dumb about it
22:10:32 <Cale> which provides combinators you can apply to functions to make them memoise parts of their domain
22:10:46 <Cale> (and are pure functions :)
22:11:28 <Cale> It uses a very sneaky trick to make use of the fact that lazy evaluation will not allow a parameter to a function to be evaluated more than once.
22:11:29 <naren> Cale: sounds tremendous. [aside] do you know any of the math in category theory? and does it help to know it to really master haskell?
22:11:46 <Cale> I know a fair chunk of category theory...
22:12:17 <Cale> It's not like you should really need it to learn Haskell, but it can be enlightening to look at Haskell through that lens.
22:13:28 <Cale> and there's a bit of a push to steal ideas from category theory and bring them into the world of programming. In my mind, this is the true purpose of category theory more than any other: it's a giant library of abstract definitions which you can specialise to almost any area of mathematics, and see if they're useful.
22:14:00 <Cale> Often coming up with the right definitions is the hardest part of mathematics, and so anything which helps with that is a wonderful thing.
22:15:21 <Cale> And of course, as programmers, we're always looking for new ways to structure our libraries and save code, and so category theory seems to be a great thing to steal ideas from.
22:16:01 <naren> Cale: that is very good point. I was discussing with my research prof the other day on how it took a while for map and reduce to come down to being used so popularly today in terms of parallel code and making it into all languages and what not. and he was urging me to think of more of these kind of functional abstractions that could become standard in data mining.
22:17:19 <naren> Cale: obviously, math has those abstractions. But, for me to learn category theory without being a math major would mean Modern algebra -> group theory -> topology -> cat theory... and that sounds insane
22:17:31 <Cale> You can do it another way
22:17:37 <Cale> Though, that's the traditional way.
22:17:44 <jfoutz> there's this point where you stop looking at math stuff to build things, and start thinking about how to turn math stuff into what you need. it's odd.
22:18:41 <naren> jfoutz: how do you mean
22:18:57 <Cale> naren: The main reason for that road is so that you have a good bunch of examples of sophisticated categories from the outset.
22:19:15 <Orclev> jfoutz: sounds like one of those "There is no spoon" moments
22:19:16 <Cale> naren: But you don't necessarily need those examples.
22:19:36 <naren> Cale: so whats the other path?
22:20:35 <Cale> Well, I'll give you Awodey's book :)
22:20:39 <jfoutz> for a long time i would go raid the haskell libs, looking for a function i needed. but eventually, i hit this point, it's just easier to instance applicative. push my design into the shape of a monad or arrow or whatever, rather than looking for existing implementations.
22:21:04 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
22:21:39 <ivanm> sjanssen: was that the pre-processor you were referring to though?
22:22:32 <dons> jfoutz: huh, cool insight
22:23:47 <naren> Cale: wow. love the inviting preface. I'll take a stab at this. thanks.
22:25:13 <naren> Cale: thanks again! Best discussion I've had here. I'm off.
22:27:38 <Orclev> ok, this is bugging me... is there a version of until that runs inside of IO?... some something like untilIO :: (a -> Bool) -> (a -> IO a) -> a -> IO a... or even (IO a -> IO Bool) -> (IO a -> IO a)
22:27:49 <copumpkin> :t until
22:27:49 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
22:28:05 <copumpkin> seems like you would write untilM
22:28:23 <Orclev> copumpkin: yeah, that would probably be the more general form of it
22:30:04 <copumpkin> :t let untilM p f x = do v <- p x; if v then return x else f x >>= untilM p f in untilM
22:30:05 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m Bool) -> (b -> m b) -> b -> m b
22:30:19 <copumpkin> (untested)
22:30:35 <mmorrow_> fata_erro: glguy wrote hpaste(2)
22:31:00 <Orclev> give me a minute and I can test it
22:31:54 <copumpkin> > let untilM p f x = do v <- p x; if v then return x else f x >>= untilM p f in untilM ((>8) . length) (join (++)) [1]
22:31:54 <lambdabot>   Couldn't match expected type `m GHC.Bool.Bool'
22:31:54 <lambdabot>         against inferred typ...
22:32:07 <copumpkin> > let untilM p f x = do v <- p x; if v then return x else f x >>= untilM p f in untilM (return . (>8) . length) (join (++)) [1]
22:32:08 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
22:32:11 <copumpkin> boo
22:32:55 <copumpkin> oh, I guess I'm treating that like a regular until
22:33:29 <mmorrow_> @let whenM p x m = p >>= \b -> if b then m else return x
22:33:30 <lambdabot>  Defined.
22:34:19 <mmorrow_> @type \p m x -> do y <- m x; whenM (p y) y (m y)
22:34:20 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m Bool) -> (b -> m b) -> b -> m b
22:35:30 <mmorrow_> @let forever' m x = m x >>= forever' m
22:35:30 <lambdabot>  Defined.
22:36:17 <copumpkin> http://www.reddit.com/r/programming/comments/9mfav/why_isnt_haskell_more_popular/c0dfrv6?context=3 what's this guy on about?
22:36:36 <dolio> Stop reading the programming reddit.
22:36:44 <copumpkin> lol
22:37:07 <copumpkin> but then I'd have to stop feeding the anti-haskell trolls too :(
22:37:18 <c_wraith> The problem is that he has no clue what a trie is.  He probably thinks it's a typo
22:37:35 <monochrom> A trie is a tree too.
22:37:53 <copumpkin> monochrom: yeah, but regarding his point?
22:38:13 <copumpkin> he's full of **** isn't he?
22:38:25 <monochrom> He is brainwashed with the lie that hash table is Theta(1) and tree is Theta(log n). He doesn't get your point about bounded memory size or bounded int size.
22:38:52 <monochrom> Let us examine why hash table is Theta(1). Well it is really because array is Theta(1), but why?
22:39:02 <lpsmith> Heh,  it annoys me slightly when people call radix sort a O(n) sort
22:39:38 <lpsmith> It's a O(n * log m) sort, where m is the number of bits in the key
22:39:53 <dons> copumpkin: don't waste time.
22:40:06 <sutats> What's a concise way to return the first double occurrence in a sorted list (ie. 5 for [1, 2, 4, 5, 5, 6, 7, 7])?
22:40:11 <Cale> As far as I can tell, veritaba is an idiot. I tried explaining things to him, but he's hard to reason with.
22:40:25 <lpsmith> http://xkcd.com/386/
22:41:10 <monochrom> Inside memory banks and memory chips you have, memory is arranged in a hierachical structure. An address goes through a tree of decoders before we know which memory bank has the cell you want.
22:41:40 <monochrom> If you assume you only have 640KB, the height of that tree is bounded, so you call that "1".
22:41:48 <monochrom> But 640KB is not enough for everyone!
22:42:05 <dons> damn it. we waste so much time on this topic.
22:42:29 <dons> either: benchmark, or stfu. don't contribute to more discussion on O(x) v O(y), its a branding disaster
22:42:36 <monochrom> The depth of the decoder circuit tree is clearly Theta(log n) too, not Theta(1). It takes Theta(log n) time to go through that tree for each read/write.
22:43:31 <Cale> I think soft-O is much more meaningful for real programs.
22:43:33 <monochrom> OTOH if you do buy the "640KB therefore Theta(1)" story, then the same story implies that balanced BST must be Theta(1) too. You only have 640KB, how many tree nodes are you going to have anyway?
22:43:37 <centrinia> I think this veritaba trusts his own reading of his textbook.
22:43:49 <Orclev> copumpkin: btw, I testing untilM and it seems to work
22:43:49 <dolio> Is veritaba the author of the article or something? He seems to be defending every "this article is nonsense" statement.
22:43:56 <Orclev> copumpkin: tested even
22:44:07 <dolio> Defending against, that is.
22:44:14 <dons> dolio: have you looked at straight out open addressed hasing via uvector, at all, btw?
22:44:29 <dolio> No, I haven't.
22:44:32 <lpsmith> what, a sockpuppet on reddit?  never/
22:44:34 <monochrom> The imperative world has its prejudice and it shows in its education. Lies.
22:44:36 <Orclev> copumpkin: which means now I get to re-write the nasty hack of a function I wrote earlyer to the much cleaner version using untilM
22:44:39 <dons> i've got a nice hash.c i'm going to bind to, and just stick up on hackage, and use to tell people to "stfu" more often.
22:45:05 <dons> also, propose to take Data.HashTable out of base.
22:45:13 <monochrom> Do not expect critical, independent thinking from programmers. Just like any stratum of people.
22:45:14 <mmorrow_> haha, gotta love the C code you write in anger.
22:45:17 <dons> finally, uvector-based open addressed hashing. then end of story.
22:45:18 <Cale> dons: Oh, btw, I was going to ask earlier, but you weren't around... do you happen to have any benchmarks of HsJudy? I remember seeing a post where you mentioned something along those lines.
22:45:24 <dolio> I could try adding that to uvector-algorithms, I guess. But I hear hashing algorithms are pretty notoriously hard to get right.
22:45:38 <dons> Cale: hmm, only casually . i noticed insert was slow, but i might have been doing it wrong
22:45:55 <dons> dolio: i've not found a good standard reference on open addressed hashing
22:45:55 <lpsmith> I don't get Judy Trees.   Something seems very wrong to me to have 20,000 LOC devoted to tables
22:46:10 <dons> so if someone can point me at the canonical ref, so i can just implement it...
22:46:18 <centrinia> Judy Trees and PATRICIA trees.
22:46:42 <dons> patricia trees / tries are well understood though.
22:46:47 <dons> Data.IntMap is easy
22:47:22 * mmorrow_ wants to do a benchmark testing the performance gain of replacing the 20+ instruction highestBit in IntMap with a single instruction x86_64 that does the same
22:48:15 <mmorrow_> highestBit probably runs at least 5+ times every single time you touch the IntMap..
22:48:50 * lpsmith has spent too much time today fretting over inconsequential issues of performance.
22:49:01 <copumpkin> Orclev: glad to hear it :)
22:49:15 <dons> mmorrow_: would be awesome. please do
22:49:21 <mmorrow_> , ({-instructions-}20 * {-conservative avg of times highBit runs-}3) * 1000{-insertions-}
22:49:22 <lunabot>  60000
22:49:24 <lpsmith> Although, interestingly,  it's rather easy to write TH code that doesn't compile to quite the same code as if you had written it yourself
22:49:25 <dons> we have bos' great stats and benchmarking too now
22:49:28 <mmorrow_> , ({-instructions-}1 * {-conservative avg of times highBit runs-}3) * 1000{-insertions-}
22:49:29 <lunabot>  3000
22:49:47 <copumpkin> mmorrow_: I vote for that too
22:49:50 <mmorrow_> dons: oh nice, i just saw his talk about that
22:51:15 * bos whines about lack of first-class labels
22:51:16 <lambdabot> bos: You have 3 new messages. '/msg lambdabot @messages' to read them.
22:51:21 <dv-_> is there anything like IORefs, but that I don't actually have to pass around?
22:51:37 <dolio> What about fclables?
22:51:39 <copumpkin> dv-_: unsafePerformIO $ newIORef undefined ?
22:51:46 <copumpkin> dv-_: don't use that though :P
22:52:14 <bos> fclabels are complicated
22:53:11 <dv-_> hm. something like a table, yes
22:53:26 <dv-_> readSuperIORef :: String -> IO a :)
22:53:41 <copumpkin> you could do that, but it's a global variable :(
22:53:46 <lpsmith> bos:  what would you prefer to fclabels?     I ask because I'm considering using them in an upcoming project,  and haven't really used them before.
22:53:58 <dons> bos: is the benchmarking suite out too, btw? no?
22:54:06 <bos> dons: i'm working on it atm
22:54:22 <dv-_> copumpkin: how would I do that?
22:54:26 <bos> dons: refactoring it into a clean library and a default main, instead of the hairball i hacked up in a rush
22:54:45 <bos> lpsmith: i've no idea. maybe just better syntactic sugar would be enough.
22:55:01 <copumpkin> dv-_: myEvilGlobalVariable = unsafePerformIO $ newIORef Map.empty -- but again, don't do this :P
22:55:19 <dons> bos: ok.
22:55:22 <bos> also, the borrowing of common function names by fclabels is a bit awkward
22:55:54 <dv-_> copumpkin: oh, right!
22:58:37 <dv-_> this might actually work out
22:58:46 <jfredett> Pah! enough of this silly tagsoup business, time for sleep.
22:58:47 <copumpkin> what do you need it for?
22:58:51 <jfredett> Goodnight Haskellians.
22:59:25 <dv-_> copumpkin: a game with too much state
22:59:42 <copumpkin> there's almost always a better solution
23:00:24 <dv-_> it has to work first. i'll make it elegant later
23:07:22 <Pseudonym> Does anyone here know anything about designing error-correcting codes?
23:08:53 <opqdonut> i'm familiar with the theory
23:09:03 <Pseudonym> How about non-binary alphabets?
23:09:15 <lpsmith>  /whois box
23:09:17 <lpsmith>  /whois bos
23:09:29 * Pseudonym should have mentioned that
23:09:31 <opqdonut> gah, gotta run, lecture about to start ->
23:09:35 <Pseudonym> :-)
23:09:36 <Pseudonym> OK
23:10:53 <ivanm> Pseudonym: I did a course on it a couple of years ago...
23:11:01 <ivanm> how much I remember is a different story :p
23:11:06 <Pseudonym> :-)
23:11:18 <ivanm> (including whether or not we included non-binary alphabets, but I think not)
23:11:34 <Pseudonym> Well, perhaps it would be better to make this concrete.
23:12:14 <Pseudonym> Given a 4-symbol alphabet, and a communication unit k bits long, I want to know how many symbols I can transfer so that all 1-error transmissions will be corrected and 2-error transmissions will be detected.
23:12:17 <Pseudonym> Much like Hamming codes.
23:12:42 <Pseudonym> Errr...
23:12:45 <Pseudonym> Let me rephrase that.
23:13:00 <ivanm> why 4-symbol?
23:13:07 <ivanm> AFAIK, most work has been done on binary
23:13:11 <Pseudonym> Just believe me, it's 4-symbol.
23:13:25 <c_wraith> bit is not the correct term.  it should be.....   quit! :)
23:13:27 <Pseudonym> Lots of possible applications.  QOPSK coding, for example.
23:13:58 <ivanm> c_wraith: heh
23:14:06 <ivanm> isn't the list example here wrong?http://en.wikipedia.org/wiki/Clean_(programming_language)#Syntactic_differences
23:14:17 <ivanm> that appears to create a list of lists for Haskell...
23:14:28 <Pseudonym> One useful thing, I guess is that 4 elements makes a Galois field.
23:14:33 <Pseudonym> GF(2^2)
23:14:46 <Pseudonym> So that may help generalise the theory to 4-symbol alphabets.
23:15:15 <c_wraith> You could decompose them into pairs of bits.  >_>
23:15:41 <dons> http://www.reddit.com/r/programming/comments/9mup8/parallel_performance_tuning_for_haskell/
23:15:44 <dons> check it!
23:15:50 <dons> parallel performance tuning for haskell, the video
23:15:53 <dons> satnam roxors
23:16:01 <Pseudonym> c_wraith: But, of course, aligned double-bit errors would be more likely than non-aligned ones.
23:16:05 <Pseudonym> So you'd lose information.
23:16:24 <copumpkin> dons: who's the person introducing him?
23:16:42 <c_wraith> Oh.  I see.  You'd need more bits to achieve the same guarantees.
23:16:53 <Pseudonym> If nobody knows the answer, I'm just going to code it up in Haskell and try to design a code at random.
23:16:55 <Pseudonym> :-)
23:17:09 <dons> copumpkin: mark jones (inventor of hugs, et al)
23:17:19 <copumpkin> Pseudonym: I have a book lying around from a course on it my girlfriend took, but sadly I have not read it :)
23:17:19 <dons> hugs, MPTCs, FDs,...
23:17:24 <copumpkin> oh cool :)
23:17:29 <Pseudonym> The other thing is, k is small.  So all of the nice schemes like LDPC, Reed-Solomon etc don't really work.  They only reach the Shannon limit as the block size increases.
23:17:36 <ddarius> Gofer
23:17:50 <Pseudonym> He also invented constructor classes.
23:18:09 <Pseudonym> And monad transformers, IIRC.
23:18:16 <dons> yep. mtl
23:18:18 <dons> THIH.
23:18:22 <Pseudonym> Andy Gill wrote the MTL.
23:18:47 <dons> straight from the paper
23:18:56 <Pseudonym> Yup.
23:18:57 <dons> nytol.
23:19:39 <Pseudonym> Nyte
23:31:16 <Orclev> copumpkin: btw, the nefarious purposes I put untilM to: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9696#a9700
23:31:33 <lpsmith> in all fairness,  Mark Jones's paper didn't cover continuations :)
23:32:32 <copumpkin> Orclev: ooh, pretty code :)
23:34:00 <Orclev> copumpkin: not hardly, I think it's ugly as sin, but it gets the job done, and it's fairly simple to follow the logic which is what I was going for
23:34:11 <copumpkin> :)
23:35:33 <Orclev> copumpkin: started out with tehgeekmeister trying to do this: http://github.com/jtauber/graded-reader/blob/master/code/next-best.py in haskell... to which he had gotten to here: http://github.com/tehgeekmeister/freeskool/blob/master/next_best.hs
23:36:48 <copumpkin> whoa, that makeNextBestReader is massive
23:38:36 <Orclev> yeah, I figured there had to be a "easier" way to do it... or at least one that was simpler to follow the logic on
23:41:34 <Orclev> copumpkin: I'd like to think my version is easier to follow if a bit more verbose, but I'm not exactly a neutral party here
23:41:43 <copumpkin> I'd agree :)
23:56:19 <Orclev> is there a way (using a function or utility) to find out, starting from a function, all the functions called by that function?
23:57:02 <copumpkin> nope
23:57:55 <Orclev> bah, would have made this simpler... I think I've got a few functions in that code that aren't being used at all, figured I could check by working my way down from the main function, but doing it by hand is going to be a pain
