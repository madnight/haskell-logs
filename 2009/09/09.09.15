00:28:11 <Phyx-> test
00:29:30 <copumpkin> failed
00:29:43 <Phyx-> mmorrow: speaking of FFI, might you have any ideas where ghc saves the closures? they don't seem to be in the lib that it generates, gcc complains that it can't find them
00:33:18 * copumpkin wants to strangle the author of this c++ he's forced to understand. It's as if they were charging him a dollar per space he inserted into his code, so it looks like z==x+y+23<43
00:33:43 <copumpkin> and what's a lot worse is that it's all stateful as hell, *sigh*
00:33:56 <trofi^w> :]
00:34:29 <copumpkin> why pass things around between your class methods when you can do the equivalent of global variables and just use instance variables to get things around
00:34:34 <copumpkin> :(
00:35:51 <Phyx-> lol
00:41:36 <Phyx-> bye, everyone have a good day toay
00:42:15 <harblcat> hey, is it a smart thing to use "show" and "read" as a way to serialize data?
00:42:28 <opqdonut> no, but it is pretty handy
00:42:35 <opqdonut> for ad-hoc things
00:42:37 <Phyx-> read becomes exponentially slower with certain inputs
00:42:40 <mmorrow> Phyx-: which closures are we talking about here?
00:43:18 <Phyx-> mmorrow: of the exported functions, they marked extern in the stub header file
00:43:26 <Phyx-> but i can't find where they're defined
00:43:30 <Phyx-> i'll show an example later
00:43:32 <Phyx-> gotta go now
00:43:34 <mmorrow> harblcat: it's a super nice/convenient way for non-time/space critical things
00:43:47 <mmorrow> Phyx-:
00:43:49 <mmorrow> ok
00:44:08 <mmorrow> Phyx-: (i'd assume in Foo_stub.c ?)
00:45:20 <harblcat> also, I was looking into Yaml, and came across something called YEAST. What is YEAST?
00:46:40 <harblcat> a search on google results in bread recipies and the like :(
00:47:09 <mmorrow> Yet ? Another ? ? (?)
00:47:26 <BernieAndErt> so I have no god damn idea about Haskell
00:47:28 <mmorrow> @go yaml yeast
00:47:28 <lambdabot> Maybe you meant: google googleit do
00:47:30 <BernieAndErt> in what case would you usue it
00:47:32 <mmorrow> @google yaml yeast
00:47:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/YamlReference
00:47:34 <lambdabot> Title: HackageDB: YamlReference-0.9.3
00:47:52 <BernieAndErt> why is it faster/more eloquent then anything else out there
00:48:08 <copumpkin> BernieAndErt: because people put some serious thought into the language design, maybe :)
00:48:19 <BernieAndErt> well
00:48:26 <copumpkin> BernieAndErt: I use it everywhere I can :)
00:48:27 <BernieAndErt> I know Pythong , PHP , C, JavaScript all very well
00:48:33 <BernieAndErt> so what's it most like
00:48:38 <copumpkin> none of those
00:48:38 <opqdonut> yeah, it's pretty much a no-compromises language design
00:48:40 <opqdonut> yeah
00:48:44 <BernieAndErt> hrm
00:48:47 <opqdonut> it's like nothing else, basically
00:48:53 <mmorrow> BernieAndErt: like for adding numbers, printing stuff, writing webservers, runtime assemblers, compilers, webapps
00:48:55 <copumpkin> those are all more or less the same language, compared to haskell
00:49:09 <BernieAndErt> rm
00:49:13 <mmorrow> -rf
00:49:13 <opqdonut> (of course there really are a lot of compromises but they're on a very different level than the ones in, for example, java)
00:49:28 <harblcat> mmorrow: that's dangerous...
00:49:32 <mmorrow>  /
00:49:34 <mmorrow> ;)
00:49:44 <BernieAndErt> so it's like LISP?
00:49:50 <copumpkin> BernieAndErt: many people who come to haskell used to think that languages are all mostly the same, with some minor differences in object model for OO languages and syntax :) then they realize how wrong they were :P
00:49:50 <opqdonut> a bit
00:50:00 <opqdonut> lisp tends to emphasise the dynamic features
00:50:03 <opqdonut> haskell is very static
00:50:03 <mmorrow> BernieAndErt: like a compiled LISP, with no runtime checks
00:50:14 <opqdonut> and no macros!
00:50:22 <copumpkin> we have TH which is sort of macroish
00:50:26 <opqdonut> well okay, there is TH
00:50:28 <opqdonut> but it doesn't count
00:50:33 <BernieAndErt> alright
00:50:39 <dolio> A compiled lisp? Well I never!
00:50:42 <opqdonut> @where lyah
00:50:42 <lambdabot> www.learnyouahaskell.com
00:50:49 <opqdonut> ^ BernieAndErt that's a good tutorial
00:50:53 <opqdonut> if you want to learn haskell
00:50:55 <BernieAndErt> is there an intreper?
00:50:56 <copumpkin> I was surprised to see how fast stalin scheme is
00:50:56 <mmorrow> dolio: with no runtime checks being the key phrase
00:51:02 <opqdonut> BernieAndErt: yeah, there is. ghci
00:51:06 <BernieAndErt> interpreter
00:51:07 <BernieAndErt> oh really?
00:51:12 <BernieAndErt> apt-get install ghci?
00:51:14 <opqdonut> or ghci is the interpreter that comes with the ghc compiler
00:51:14 <mmorrow> , [0..]
00:51:15 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
00:51:20 <opqdonut> BernieAndErt: apt-get install ghc :)
00:51:23 <copumpkin> BernieAndErt: just install ghc, and you get ghci for free
00:51:24 <mmorrow> , eval "eval \"42\""
00:51:26 <BernieAndErt> doing so now
00:51:28 <lunabot>  <<Dynamic>>
00:52:07 <copumpkin> BernieAndErt: unfortunately if you're on an apt platform, you most likely don't get a very recent ghc, but it shouldn't really look any different to you at this point
00:52:22 <BernieAndErt> lol
00:52:29 <BernieAndErt> I like whoever made this tutorial
00:52:29 <opqdonut> copumpkin: debian sid has a quite fresh ghc
00:52:30 <mmorrow> BernieAndErt: honestly i'd install the bindist from haskell.org/ghc
00:52:31 <BernieAndErt> colors and all
00:52:33 <BernieAndErt> good stuff.
00:52:41 <opqdonut> 6.10.4
00:52:58 <copumpkin> opqdonut: how many people use that?
00:53:00 <copumpkin> sid?
00:53:02 <BernieAndErt> yea I'm all set with that bleeding edge stuff
00:53:28 <BernieAndErt> so this is odd
00:53:33 <BernieAndErt> I installed ghc... done.
00:53:37 <opqdonut> copumpkin: many cherry pick packages from sid
00:53:39 <BernieAndErt> `ghci` does nothing
00:53:43 <BernieAndErt> does does `ghc`
00:53:45 <dolio> mmorrow: Well, it still has constructors/tags, which is practically what lisp/dynamic-language people mean by "types" so... :)
00:53:53 <mmorrow> dolio: true
00:53:59 <opqdonut> does nothing as in just returns?
00:54:01 <opqdonut> or just hangs
00:54:24 <mmorrow> dolio: but if you segfault it's not the compiler's fault (save for a bug)
00:54:31 <dolio> I was reading a paper on the history of induction earlier, and came to the conclusion that I dislike set theory, because it's just like that.
00:54:34 <BernieAndErt> oh wtf
00:54:43 <mmorrow> dolio: just like what?
00:54:51 <copumpkin> that!
00:54:54 <copumpkin> BernieAndErt: ?
00:54:59 <mmorrow> @botcrack!
00:54:59 <lambdabot> Unknown command, try @list
00:54:59 <lunabot>  :o
00:55:01 <dolio> mmorrow: It's like building everything out of rose trees tagged with symbols.
00:55:05 <BernieAndErt> nm, my bad
00:55:13 <copumpkin> BernieAndErt: do you have a Prelude> ?
00:55:16 <dolio> Or not even tagged with symbols, as the case may be.
00:55:22 <mmorrow> dolio: hmm, i'll have to think about that
00:55:33 <mmorrow> dolio: (i don't see it at first blush)
00:55:46 <BernieAndErt> alright! I'm in ghci!
00:55:48 <BernieAndErt> woohoo
00:55:51 <BernieAndErt> here I go!
00:55:56 <BernieAndErt> Haskell programming away...
00:56:10 <mmorrow> dolio: (don't see it /= disagree, but i don't see how you mean)
00:56:15 <harblcat> this is like the yellow-brick road, no?
00:56:15 <copumpkin> BernieAndErt: now type scanl1 (+) [1,3..]
00:56:18 <mmorrow> dolio: how do you mean? :)
00:57:00 <mmorrow> BernieAndErt: fix (\o -> mapM_ forkIO [o,o]) {- haskell has a pretty forkbomb, too -}
00:57:03 <dolio> mmorrow: Their description of how you define induction in set theory just struck me as similar.
00:57:33 <mmorrow> dolio: oh, so this is in particular wrt the pair of set-theory and induction?
00:57:45 <BernieAndErt> lol
00:57:51 <BernieAndErt> succ ... this is funny
00:58:01 <BernieAndErt> what's the inverse?
00:58:04 <dolio> mmorrow: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.5568
00:58:07 <BernieAndErt> recc?
00:58:11 <mmorrow> , pred 42
00:58:13 <lunabot>  41
00:58:15 <BernieAndErt> funny
00:58:30 <mmorrow> , pred EQ
00:58:31 <lunabot>  LT
00:58:44 <opqdonut> , pred True
00:58:45 <lunabot>  False
00:58:59 <mmorrow> , fmap pred [LT ..]
00:59:01 <lunabot>  luna: Prelude.Enum.Ordering.pred: bad argument
00:59:06 <mmorrow> ugh, why not Bounded
00:59:15 <mmorrow> , fmap pred [False ..]
00:59:16 <lunabot>  luna: Prelude.Enum.Bool.pred: bad argument
00:59:18 <mmorrow> oo
00:59:32 <mmorrow> err
00:59:38 <opqdonut> pred minBound is not defined
00:59:38 <mmorrow> , [False ..]
00:59:39 <lunabot>  [False,True]
00:59:44 <mmorrow> opqdonut: ahhh
00:59:51 <mmorrow> err
00:59:55 <mmorrow> oh, right
01:00:35 <mmorrow> i like (the idea of) Data.Derive's "circular enum" deriving option
01:00:38 <BernieAndErt> doubleMe x = x + x  is failing
01:00:46 <mmorrow> let doubleMe x = x + x
01:00:51 <mmorrow> doubleMe 42
01:00:54 <BernieAndErt> oh okay
01:01:00 <BernieAndErt> they didn't say use 'let'
01:01:02 <BernieAndErt> wtf?
01:01:08 <mmorrow> Berengal: and you can "run" IO actions by
01:01:12 <copumpkin> if(node1->type>node2->type)
01:01:15 <mmorrow> a <- readFile "/etc/passwd"
01:01:21 <copumpkin> this is straight out of how to write unmaintainable code
01:01:23 <mmorrow> mapM_ print (lines a)
01:01:27 <BernieAndErt> hahaha
01:01:51 <BernieAndErt> why would someone write a tutorial and leave out the 'let' clause
01:01:59 <BernieAndErt> that's the dumbest thing I've seen in some time.
01:02:19 <mmorrow> Berengal: that's how you'd write it in a .hs, but at the prompt you use `let' to bind names to things
01:02:28 <BernieAndErt> oh I see
01:03:07 <mmorrow> BernieAndErt: (since, the ghci prompt is (essentially) syntactically like the inside of an IO do-block)
01:04:31 <mmorrow> BernieAndErt: you can disable how it prints out the "a" in "a <- readFile ..." automatically too (which is usually one of the first things i do with new ghci installs)
01:04:33 <opqdonut> BernieAndErt: chapter two talks about ghci
01:04:40 <BernieAndErt> how do you do a new line
01:04:44 <mmorrow>  :set -fno-print-binds   (or something)
01:04:58 <BernieAndErt> was that for me ?
01:04:58 <mmorrow> BernieAndErt: you mean enter multi-line stuff?
01:05:01 <BernieAndErt> yea
01:05:05 <mmorrow>  :{
01:05:08 <mmorrow> starts a block
01:05:15 <BernieAndErt> cool
01:05:17 <BernieAndErt> thanks
01:05:20 <mmorrow> np
01:06:22 <copumpkin> and here I was thinking mmorrow was sad
01:06:49 <opqdonut> or had a large moustache!
01:06:55 <opqdonut> obscuring his mouth
01:06:57 <copumpkin> oh yeah
01:07:00 <mmorrow> dolio: this is somewhat related (in an opposite-sense or something) (rwbarton linked me at some point, the first 3 pages are good by themselves)  http://moonpatio.com/papers/homotopy_theoretic_models_of_identity_types.pdf
01:07:02 <opqdonut> , that clever bastard
01:07:03 <lunabot>  luna: Not in scope: `that'
01:07:11 <opqdonut> gah, i gotta stop doing that :D
01:07:31 <opqdonut> mmorrow: surely you mean corelated?
01:07:52 <dolio> mmorrow: Anyhow, you start with some set V, and define "rules" in terms of elements/subsets of V, and then you show that a set of rules carves out a subset of V that is the set inductively defined by those rules.
01:07:55 <opqdonut> heh, i'm actually on a lecture on homotopy theory right now
01:08:01 <BernieAndErt> I like the autocompleter they use
01:08:08 <BernieAndErt> better then mysql/pythons :P
01:08:11 <mmorrow> opqdonut: something
01:08:25 <opqdonut> (the fundamental group sort of homotopy theory, though)
01:08:30 <mmorrow> dolio: hmm, ok
01:09:12 <mmorrow> opqdonut: are you taking algebraic topology?
01:09:18 <opqdonut> yeah
01:09:23 <mmorrow> opqdonut: cool
01:09:37 <opqdonut> or actually the name of this course is "homotopy theory", it's kind of a light introduction to the topic
01:09:45 <opqdonut> the actual alg.topol. course runs in the spring
01:10:02 <opqdonut> (a bit too light imo btw...)
01:10:19 * copumpkin found there's a graduate algebra course at his school that has some basic category theory in it! I thought nobody did anything like that here
01:10:34 <opqdonut> yeah, ct is hard to come by here too
01:11:01 <copumpkin> I was just browsing the syllabus trying to decide what to take next term and found a week dedicated to CT
01:11:03 <opqdonut> i was very irked when algebra II proved universality by hand for all the structures mentioned
01:11:06 <opqdonut> and there was a ton of those
01:12:20 <mmorrow> opqdonut: heh
01:13:25 <opqdonut> but then again, the lecturer was a logician
01:13:26 <mmorrow> copumpkin: if you haven't taken algebra before, i'd say definitely go for it
01:13:27 <opqdonut> :P
01:14:00 <dolio> mmorrow: This paper looks like it's all category theory and type theory.
01:14:08 <opqdonut> it is
01:14:08 <mmorrow> copumpkin: (assuming that that course doesn't already assume the two-semester (or equiv) intro algebra sequence)
01:14:10 <copumpkin> mmorrow: I'd love to, but the algebra looks pretty hardcore :P the extent of my acadmic algebra was the honors linear algebra course (the one that isn't glorified matrix multiplication, and actually deals with abstract structures and function spaces and stuff)
01:14:14 <copumpkin> mmorrow: it does :P
01:14:18 <mmorrow> grr
01:14:27 * copumpkin regrets slacking off so much in undergrad
01:14:36 <copumpkin> slacking off = taking language courses actually
01:16:12 <mmorrow> dolio: yeah, i meant similar-opposite in the sense that that paper looks at type theory from the pov of "regular" math, rather than vice-versa (which i guessed was the content of your link by the abstract, but i haven't read any yet)
01:16:41 <mmorrow> dolio: but either way, it reminded me of that :)
01:17:27 <dolio> mmorrow: The paper I linked actually had a lot less content than I originally expected. It was basically a list and short history of various topics that had to do with induction.
01:17:44 <dolio> The only very technical part was explaining how you get induction in set theory.
01:18:06 <dolio> And that was, like, two pages.
01:18:29 <mmorrow> dolio: heh, yeah rwbarton's link gets somewhat hardcore after page 3
01:19:27 <mmorrow> speaking of rwbarton, i haven't seen him around in a while
01:19:28 <psykotic> opqdonut: a course called homotopy theory that's a light introduction to algebraic topology? i think you might be surprised :)
01:19:41 <mmorrow> preflex: seen rwbarton
01:19:41 <preflex>  Sorry, I haven't seen rwbarton
01:19:43 <psykotic> usually courses called 'homotopy theory' are not meant as a first course
01:19:47 <psykotic> hehe
01:20:07 <copumpkin> lots of people seem to disappear from here for long periods :)
01:20:25 <copumpkin> maybe I'd regain my productivity if I followed suit
01:20:34 <psykotic> usually a course in homotopy theory presumes a good knowledge of cohomology.
01:20:39 * mmorrow wonders if wli is still among the living
01:21:14 <copumpkin> :/
01:21:18 <psykotic> one of the basics results in homotopy theory concerns the relationship between cohomology and homotopy classes of maps out of eilenberg-maclane spaces.
01:21:33 <dolio> Anyhow, my point is, set theory tends to be like, "Foos are sets shaped like this", similar to how Lisp can be like "Foos are rose trees shaped like this", whereas more type-oriented things tend to be "Foos are defined as being built out of these pieces."
01:21:45 <dolio> And I happen to enjoy the latter more.
01:22:37 <opqdonut> psykotic: well, judging by the pace of the first few weeks, this isn't going far
01:22:46 <psykotic> opqdonut: so what are you covering now?
01:22:52 <psykotic> covering spaces?
01:22:57 <opqdonut> psykotic: we've almost defined \pi_1...
01:23:08 <psykotic> ah, yeah
01:23:20 <psykotic> the one homotopy group that's actually easy to compute :P
01:23:26 <opqdonut> yeh
01:23:53 <psykotic> all higher homotopy groups are abelian, so you'd think they wouldn't be that hard to compute, heh
01:24:15 <psykotic> pretty much the only cases that are easily tractable involve additional structure
01:24:18 <opqdonut> next up: covering spaces, then higher homotopy groups, then exact ssequences (is that the correct term?)
01:24:23 <opqdonut> and that's about it
01:24:25 <psykotic> H-spaces (which cover topologicalgroups as a special case), etc
01:24:30 <psykotic> exact sequences, yeah
01:24:51 <mmorrow> exact sequences are neat
01:24:53 <copumpkin> psykotic: you mentioned having a blog in that reddit message to me (I asked about the matrix zippers)... is that public yet by any chance?
01:25:00 <psykotic> of course you need spectral sequences to do most interesting homotopy theory calcs
01:25:03 <opqdonut> mostly this is just applying stuff from our algebra II (which covered exact sequences for instance)
01:25:08 <mmorrow> snake lemma and all that
01:25:09 <psykotic> and spectral sequences are not fun
01:25:09 <psykotic> hehe
01:25:37 <psykotic> copumpkin: it's up and running but i'm still hacking on the backend
01:25:45 <copumpkin> ah ok :)
01:25:48 <psykotic> i've had to deal with real life stuff, so delayed by a few days
01:26:03 <BernieAndErt> 'A':" SMALL CAT"
01:26:15 <copumpkin> meow :)
01:26:23 <copumpkin> or is that a small category?
01:26:25 <psykotic> opqdonut: covering spaces are seriously great. they're probably one of the best and still basic ideas in topology.
01:26:30 <BernieAndErt> well the Haskell language is cool
01:26:34 <BernieAndErt> the logo atleast
01:26:36 <psykotic> they let you understand so many different things easily and intuitively.
01:26:37 <BernieAndErt> I like it.
01:26:47 <dolio> Heh.
01:26:52 <dolio> Success!
01:26:54 <BernieAndErt> reminds me of an alien language.
01:27:04 <mmorrow> BernieAndErt: heh
01:27:05 <copumpkin> BernieAndErt: beware, you may get sucked in
01:27:17 <dolio> Good thing we ditched the old logo.
01:27:17 <BernieAndErt> like Jappenese
01:27:23 <psykotic> i like the new logo a lot
01:27:28 <BernieAndErt> yea it's good
01:27:29 <copumpkin> BernieAndErt: it's pretty addictive if you enjoy getting your mind blown by things
01:27:29 <mmorrow> yeah, me too
01:27:36 <BernieAndErt> it's like mega man + programming
01:27:41 <psykotic> the idea of having a logo contest was pretty inspired.
01:27:49 <psykotic> i admit when i saw the announcement i was expecting a bunch of shitty programmer art :)
01:27:55 <BernieAndErt> those are the first 2 things that came to mind
01:27:58 <psykotic> positively surprised with the outcome
01:28:08 <BernieAndErt> yea that's awesome
01:28:10 <BernieAndErt> who drew it?
01:28:21 <copumpkin> > let (a, b, c) = (b * 3, 2, a ^ 7) in (a, b, c) -- BernieAndErt
01:28:22 <lambdabot>   (6,2,279936)
01:28:55 <psykotic> opqdonut: if/when you cover H-spaces and hopf algebras, i can tell you some unexpected haskell connections.
01:28:57 <BernieAndErt> there should be a channel simply for chat/support on the logo
01:29:02 <BernieAndErt> #haskell-logo
01:29:16 <psykotic> when i was played around with matrix zippers, i notice they form a hopf algebra, and then i worked backwards to figure out what topological h-space structure would give it.
01:29:26 <copumpkin> :o
01:29:29 <psykotic> i'm pretty sure that's an unpublished result but i don't think it's very deep
01:29:35 <psykotic> hehe
01:29:37 <psykotic> but it's cute
01:29:44 <opqdonut> psykotic: i don't think we do hopf spaces
01:29:57 <psykotic> that's a shame, it's a pretty basic idea.
01:30:04 <opqdonut> yeah
01:30:09 <psykotic> it's one of the few cases where you can easily compute a few homotopy groups
01:30:18 <opqdonut> maybe some other course
01:30:27 <psykotic> basically once you have a binary operation with identity on a space, you get two compatible composition laws on pi_1
01:30:30 <psykotic> and other pi's
01:30:43 <psykotic> you have the direct composition of the maps, that's one
01:30:56 <psykotic> and then you have pointwise 'multiplication' with that binary operation
01:31:17 <psykotic> and then there's this abstract nonsense called eckmann-hilton lemma that shows that when you have two compatible operations like that on a space, they must be commutative
01:31:23 <psykotic> and that lets you compute some homotopy goodness
01:31:26 <BernieAndErt> do you guys use dating websites
01:31:37 <BernieAndErt> which ones
01:31:55 <opqdonut> psykotic: sounds nice
01:32:18 <psykotic> i guess, if you like topology
01:32:27 <copumpkin> BernieAndErt: #haskell is the best dating site out there, if you're into smart mathematicians
01:32:33 <BernieAndErt> lol
01:32:40 <psykotic> and gay
01:32:54 <psykotic> then this is ground zero
01:33:12 <BernieAndErt> what's a good damn for a site where you can target people with messages
01:33:20 <BernieAndErt> name*
01:35:24 <mmorrow> BernieAndErt: stalkerheaven.biz?
01:35:38 <psykotic> opqdonut: what book are you using btw?
01:36:02 <opqdonut> psykotic: just some local stuff
01:36:22 <BernieAndErt> ...
01:36:27 <psykotic> course notes you mean?
01:36:27 <opqdonut> a pdf written by the lecturer and a pretty famous finnish book on topology
01:36:30 <opqdonut> yeah
01:36:51 <psykotic> famous finnish book on topology? i thought finnish people only did complex analysis :)
01:36:58 <opqdonut> hehe
01:37:21 <opqdonut> by somebody called väisälä, used for teaching basic topology in most the unis here
01:37:45 <opqdonut> i guess nowadays we do analysis related with differential equations and inversion problems mostly
01:38:12 <psykotic> ah
01:38:20 <psykotic> i still have the cliche in my head that complex function theory is the big thing up there
01:39:29 <opqdonut> yeah, ahlfors etc :)
01:39:37 <psykotic> right
01:39:42 <opqdonut> i'd prefer it that way :P
01:39:46 <psykotic> who wrote probably the most unreadable books in the world
01:39:47 <psykotic> hehe
01:40:04 <opqdonut> there's also a small but active group doing analytic number theory
01:40:11 <psykotic> he has a very analyst's view of complex analysis. i took a course in complex analysis based on his book.
01:40:12 <BernieAndErt> so I have a question
01:40:17 <BernieAndErt> is there such a thing as general IRC?
01:40:20 <psykotic> and the analyst's view of complex analysis is basically incomprehensible.
01:40:27 <psykotic> to me anyway :)
01:40:28 <opqdonut> how come?
01:40:28 <BernieAndErt> like, for normal things? dating? flowers? cars? etc
01:40:38 <opqdonut> BernieAndErt: you're on the wrong irc server for that :P
01:40:41 <psykotic> for me it's all about conformal geometry.
01:40:49 <opqdonut> see ircnet and efnet for networks with more general discussion
01:40:50 <mmorrow> Berengal: #normalthings, #dating, #flowers, #cars most likely
01:40:52 <BernieAndErt> opqdonut: yea  but does one exist?
01:40:55 <BernieAndErt> lol
01:40:55 <opqdonut> psykotic: right
01:40:57 <psykotic> and even the potential theory/harmonic functions aspect i have a pretty physical/geometric view of
01:41:16 <psykotic> but most books on the subject are written by analysts
01:41:19 <opqdonut> i always understood that ahlfors did very geometric function theory
01:41:28 <mmorrow> BernieAndErt: if you singly "/join #asdfasdffd" that channel will be created if it doesn't exist..
01:41:31 <mmorrow> *simply
01:41:33 <psykotic> i think that's a shame because complex analysis is a nexus for a lot of mathematics, e.g. riemann surfaces
01:41:36 <opqdonut> i'm not that familiar with his work, though
01:41:48 <psykotic> opqdonut: it's CALLED geometric function theory :)
01:41:52 <psykotic> but it's still hardcore analysis, hehe
01:42:09 <opqdonut> ah okay
01:42:16 <psykotic> i think that name basically exists because it applies also functional analysis techniques to some 'geometric' kinds of areas where complex analysis impinges
01:42:27 <psykotic> conformality and so on
01:42:32 <opqdonut> yeah, it's been bothering me that the structure of harmonic functions and the complex plane is so rigid
01:42:44 <opqdonut> but analysts hide it by handling them just like functions in R^2
01:43:11 <psykotic> for the more analytic aspects of complex analysis, i think part of the problem is that it's only really comprehensible once you look at the general theory
01:43:21 <psykotic> for example, it turns out that most of the miraculous follows hold true for all harmonic functions
01:43:51 <psykotic> e.g. cauchy's theorem, the fact that being complex-differentiable at a point implies analytic in the sense of having a power series, and hence infinitely differentiable, etc
01:44:34 <psykotic> the extra special aspects of complex analysis in the plane then follows from the fact that the real and imaginary components are not only individually harmonic but conjugate in the sense that their 'streamlines' intersect perpendicularly
01:44:48 <psykotic> and intuitively that means that once you know one of them, the other is pretty much 100% constrained
01:45:22 <psykotic> anyway, sorry for the ot
01:45:22 <opqdonut> mhmm
01:45:44 <opqdonut> nice talking to you
01:45:54 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9386#a9386 <-- Before I go insane, someone check this for me please, see if you get the same results as I did (in ghci)
01:46:28 <mmorrow> psykotic: and you also move from a single copy of C/the-field to manifolds, and look at tangent spaces and diff-geom-y stuff too, which i personally hugely prefer to more "analysis"-y stuff
01:46:50 <psykotic> right, sure
01:47:01 <psykotic> but a lot of stuff doesn't work e.g. on higher complex-analytic manifolds
01:47:03 <psykotic> riemann surfaces are the sweet spot
01:47:06 <opqdonut> i'm actually on a course on differential geometry too :P
01:47:15 <mmorrow> psykotic: hmm, interesting
01:47:42 <psykotic> i think the most important thing in any undergraduate mathematics education should be riemann surfaces
01:47:51 <psykotic> pretty much everything meets there
01:47:53 <copumpkin> damn, I missed out
01:48:01 <opqdonut> Baughn: do you realize you're calling reverse n times
01:48:09 <opqdonut> each recursive call
01:48:09 <mmorrow> opqdonut: cool, re: that, general relativity is an interesting application (at least to read about knowing the math)
01:48:10 <dolio> Baughn: Your auxillary function calls the main function recursively.
01:48:23 <opqdonut> mmorrow: yeah, i've read penrose's road to reality
01:48:26 <psykotic> it has connections to number theory, analysis, physics, geometry, topology, etc
01:48:31 <opqdonut> which got me interested in diffgeom
01:48:38 <Baughn> ..aagh
01:48:46 <Baughn> And this is why shadowing bindings is a /good/ thing.
01:48:50 <mmorrow> once you cross an event horizon the time dimension flips... and as you approach the center of the blackhole you approach the beginning of time!
01:48:51 <psykotic> e.g. one of the most amazing ideas is the relationship between algebraic numbers and algebraic functions.
01:49:07 <psykotic> so ramification in the algebraic number sense is analogous to a branched covering of a riemann surface
01:49:37 <psykotic> and it's a complete, deep analogy. it lets you understand a crapload of seemingly incomprehensible algebraic number theory once you have developed a good geometric feel for riemann surfaces.
01:50:35 <psykotic> and riemann surfaces are also the perfect jumping off-point for all the abstract nonsense in modern mathematics. anyway, rant off :)
01:56:24 <mmorrow> opqdonut: i haven't read that book, but i meant more along the lines of a general relativity book that has proofs/etc in it
01:56:45 <Cale> http://www.vimeo.com/album/126462 -- complete videos of the Haskell implementors' workshop :)
01:56:56 <psykotic> cale: nice!
01:57:35 <mmorrow> (although do so with caution, the physicists fetish for attaches indices to things and pursuing blindingly tedious @unpl-ish proofs can wear on you ;)
01:58:03 <opqdonut> indeed :P
01:58:06 <psykotic> some things are much nicer with indices and you can use penrose's abstract index notation which is manifestly covariant
01:58:10 <psykotic> a good example is contraction
01:58:43 <psykotic> and the abstract index notation has a very nice diagrammatic equivalent
01:59:03 <psykotic> you contract by having a literal geometric loop from input to output
01:59:10 <psykotic> thus 'identifying' the corresponding indices (slots)
01:59:14 <psykotic> err, from input to input
02:01:28 <psykotic> the standard mathematician's notation for contraction is pretty ugly and unwieldly.
02:01:36 <mmorrow> the horror! http://upload.wikimedia.org/math/e/f/6/ef6681e2434d1434c85071b477f1db55.png :)
02:01:39 <psykotic> that's one thing the physicists got right
02:01:45 <psykotic> well
02:01:56 <psykotic> the levi-civita tensor is pretty much the standard example of how too many indices can be bad :P
02:01:57 <psykotic> so i'll give you that
02:02:06 <psykotic> err, not levi-civita
02:02:10 <psykotic> christoffel
02:02:16 <psykotic> but it's the levi-civita connection
02:02:49 <psykotic> didn't road to reality have a good explanation of abstract index notation and tensor diagrams?
02:02:56 <psykotic> i haven't read it but since penrose wrote it, i assume it must've
02:03:20 <mmorrow> oh, from the cover pic on amazon i assumed it was a book book
02:03:37 <psykotic> i think it has a lot of math, though explained heuristically
02:03:55 <psykotic> but that's what you don't get from most normal mathematics books, so it would be very useful
02:04:23 <psykotic> the biggest problem with self-study of mathematics is that the only way you'll extract nice heuristic ideas and arguments from mathematicians is by talking with them in person
02:04:41 <psykotic> even in seminars they feel that 'hygeine' prohibits that kind of vague talk, even if it's essential to all understanding
02:06:04 <psykotic> when someone comes along and writes a book full of clear ideas rather than blind calculations or impenetrable formalism, it's worth its weight in gold. probably half of all those books were written by russians :)
02:06:08 <pozic> Why is there no instance for MonadWriter (Seq String) (ContT r <some specific monad>)?
02:06:18 <psykotic> (or in the nineteenth century)
02:06:21 <mmorrow> yeah, sometimes hearing someone's personal viewpoint of a particular thing gives you an entirely new way to look at it
02:06:57 <psykotic> ps. the best book on algebra ever written is shafarevich's notions of algebra
02:07:15 <psykotic> it kind of assumes you already know a lot of non-algebraic mathematics, which makes it bad for pur ealgebraists
02:07:18 <|Steve|> Better than Dummit and Foote?
02:07:26 <psykotic> it's not really a textbook in the usual sense, so
02:07:55 <pozic> psykotic: you also recommended 'Linear algebra done right', right?
02:08:00 <psykotic> yeah.
02:08:04 <psykotic> although that's a more pure algebra text
02:08:15 <psykotic> a bit too slick, i wouldn't recommend it as someone's only text
02:08:27 <psykotic> but it's a good antidote to the calculation-heavy approaches of some other text
02:08:32 <pozic> psykotic: do you do the execises when you read such a book?
02:08:38 <psykotic> definitely
02:08:41 <psykotic> otherwise you won't learn very much
02:08:42 <pozic> All of them?
02:08:44 <psykotic> no
02:08:49 <psykotic> as many as you feel necessary
02:09:01 <psykotic> it also depends on the nature of the exercises
02:09:15 <psykotic> but sometimes even a seemingly simple calculation can be enlightening
02:09:26 <psykotic> once you calculate something by hand, you see things you don't see from the clouds
02:11:02 <psykotic> btw one thing i hate about basically all algebra books i've seen is that they stick away from complex examples
02:11:17 <psykotic> and they like permutation groups way too much
02:11:33 <psykotic> a lot of notions become a lot clearer when you deal with transformation groups for R^2 and R^3
02:12:16 <psykotic> an awesome thing about shafarevich's book is that he has whole chapters where he just goes through extremely interesting and deep examples
02:13:11 <psykotic> so a chapter on examples of infinite discrete groups, he covers wallpaper groups, crystallographic groups, discrete groups of hyperbolic motions, modular groups, the fundamental group, knot groups, braid groups
02:13:21 <psykotic> this kind of thing assumes you already know a lot of other mathematics, admittedly
02:13:25 <psykotic> but it's pretty awesome if you do
02:13:30 <pozic> psykotic: why do you read all those books? The chance of you applying these books in real life (e.g. software) is not that large, is it? For vector calculus, statistics, basic algebra, I see the applications, but abstract algebra?
02:13:54 <psykotic> dude, we're on #haskell
02:14:15 <psykotic> not everything i do has applications in sight :)
02:14:17 <pozic> psykotic: Haskell can be used to make real software.
02:14:32 <psykotic> i doubt i'll ever write a commercial program in haskell
02:14:45 <psykotic> that doesn't make my programming in haskell useless
02:15:47 <psykotic> i've done computer graphics for a career, so i do apply more advanced mathematics than what you said, but admittedly not much more
02:16:07 <psykotic> anyway, it's kind of like asking why i would read a novel or a history book when it doesn't have applications to making better software. it's a weird question, imo.
02:16:32 <psykotic> i don't wake up in the morning thinking of how i could make more money.
02:16:37 <pozic> psykotic: reading a history book has lots of real world applications.
02:16:47 <psykotic> more than mathematics?
02:16:52 <shachaf> pozic: How about music?
02:17:09 <pozic> psykotic: they don't necessarily make money, but they make you a more complete person.
02:17:14 <psykotic> can you tell me the specific concrete ways in which reading a book about the peace of westphalia would improve your software?
02:17:18 <psykotic> and mathematics does not do that?
02:17:21 <shachaf> pozic: Well, there's your answer. :-)
02:17:33 <pozic> psykotic: people also love to hear stuff about history if you can speak well.
02:17:44 <pozic> psykotic: less so for abstract algebra, I think.
02:17:50 <psykotic> depends on your friends
02:18:02 <quicksilver> pozic: I suspect the MonadWriter instance for ContT does not hold, and that's why it doesn't exist.
02:18:37 <quicksilver> pozic: I further suspect that you could probably write a sensible implementation of 'tell', but 'pass' and possibly 'listen' fail.
02:21:43 <psykotic> pozic: a more general fact is that almost all advanced mathematics shines clearer light on elementary mathematical matters. once you have learned the theory of locally compact abelian topological groups, you suddenly understand fourier analysis in the familiar cases much better.
02:22:02 <psykotic> then you learn representation theory and have yet another way of understanding that, along with a way of generalizing to unfamiliar settings.
02:22:43 <psykotic> but i won't make the case that's it's all useful in some hard-nosed kind of way.
02:22:57 <pozic> psykotic: another thing which annoys me is the amount of overlap in mathematics books.
02:23:54 <pozic> And it's also not that easy to skip over the right amount in a new book.
02:24:00 <shachaf> (...And this is as opposed to history books?)
02:24:15 <pozic> shachaf: maybe I read more mathematics books ;)
02:24:24 * shachaf should go to sleep.
02:28:57 <ketil> >
02:30:30 <ketil> Any debian-haskell channel?
02:39:04 <dschoepe> ketil: #debian-haskell at irc.debian.org
02:39:23 <dschoepe> ketil: at least that's what a wiki page on haskell.org says
02:49:42 <Woof> @let toBin 0 = 0; toBin n = 10*toBin(n/2) + (n%2)
02:49:43 <lambdabot>  Defined.
02:49:51 <Woof> > toBin 43
02:49:51 <lambdabot>   Ambiguous type variable `t' in the constraints:
02:49:52 <lambdabot>    `GHC.Real.Fractional t'
02:49:52 <lambdabot> ...
02:49:52 <lambdabot> Woof: You have 1 new message. '/msg lambdabot @messages' to read it.
02:56:26 <bastl> hi all
02:57:01 <Woof> @undf
02:57:01 <lambdabot> Maybe you meant: undo unpf
02:57:04 <Woof> @undef
02:57:26 <Woof> @let toBin 0 = 0; toBin n = 10 * toBin(n / 2) + (n `mod` 2)
02:57:27 <lambdabot>  Defined.
02:57:31 <Woof> > toBin 43
02:57:32 <lambdabot>   Ambiguous type variable `t' in the constraints:
02:57:32 <lambdabot>    `GHC.Real.Integral t'
02:57:32 <lambdabot>   ...
02:59:11 <FunctorSalad> Woof: I think you want `div`, not /
02:59:23 <Woof> Ah
02:59:24 <Woof> @undef
02:59:31 <Woof> @let toBin 0 = 0; toBin n = 10 * toBin(n `div` 2) + (n `mod` 2)
02:59:34 <lambdabot>  Defined.
02:59:39 <Woof> > toBin 43
02:59:41 <lambdabot>   101011
02:59:44 <Woof> Hurray : D
02:59:48 <Woof> Thank you, FunctorSalad and Twey!!!
03:00:00 <FunctorSalad> :D
03:00:12 <Woof> @src div
03:00:12 <lambdabot> Source not found. Take a stress pill and think things over.
03:00:14 <Woof> :t div
03:00:15 <lambdabot> forall a. (Integral a) => a -> a -> a
03:00:18 <Woof> Aha
03:00:32 <FunctorSalad> it's a method of Integral
03:00:34 <Woof> Why is the source not available for some functions?
03:01:42 <koala_man> the source is added manually
03:02:24 <Woof> Ah. So it hasn't been added for some
03:03:08 <quicksilver> full source is available online anyway
03:03:29 <Woof> Aha
03:03:31 <quicksilver> and a web browser is a generally better interface for source browsing than an IRC channel :)
03:04:11 <quicksilver> although div is a method
03:04:21 <quicksilver> so its source is type-specific and generally a bit primitive
03:04:52 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/base/src/GHC-Real.html
03:04:57 <quicksilver> (search for `div` )
03:06:12 <Woof> I see. Ty
03:07:28 <dschoepe> Is it just me or does the latest darcs version of cabal-install fail to build with darcs cabal?
03:12:07 <dolio> > let hylo f g = f . fmap (fmap (hylo f g)) . g ; f 0 = Nothing ; f n = Just . swap $ n `divMod` 2 in hylo (maybe 0 (second (*10) >>> uncurry (+))) f 31
03:12:08 <lambdabot>   11111
03:13:28 <Woof> Is that better in some way? What way?
03:14:08 <dolio> It uses more fancy mathematical formalisms.
03:14:12 <ziman> > let hylo f g = f . fmap (fmap (hylo f g)) . g ; f 0 = Nothing ; f n = Just . swap $ n `divMod` 2 in hylo (maybe 0 (second (*10) >>> uncurry (+))) f 57
03:14:12 <lambdabot>   111001
03:14:26 <Woof> > toBin 57
03:14:27 <lambdabot>   111001
03:14:49 <ziman> hm, i cannot see why the fmaip is twice there
03:15:11 <dolio> ziman: Because Just (a, _) isn't (can't be) declared a functor.
03:15:26 <dolio> Er, Maybe (a, _)
03:15:43 <ziman> ah i see
03:15:54 <Woof> Hm, lemme see. It uses Y-combinator?
03:16:26 <Woof> Instead of named using the name of the function in its own definition?
03:16:32 <Woof> -named
03:16:38 <dolio> No. It uses the hylo combinator.
03:16:50 <dolio> @type let hylo f g = f . hylo f g . g in hylo
03:16:50 <lambdabot> forall c a. (c -> c) -> (a -> a) -> a -> c
03:16:57 <dolio> @type let hylo f g = f . fmap (hylo f g) . g in hylo
03:16:57 <lambdabot> forall (f :: * -> *) c a. (Functor f) => (f c -> c) -> (a -> f a) -> a -> c
03:17:15 <dolio> Second one's the usual type.
03:18:04 <dolio> Hylo is equivalent to general recursion, though.
03:18:34 <dolio> g unfolds and f folds. The structure of the recursive call tree is encoded by the functor f.
03:19:08 <Woof> Hm
03:19:09 <dolio> In this case, it's a list.
03:20:54 <dolio> > let hylo z c g = foldr c z . unfoldr g ; f 0 = Nothing ; f n = Just . swap $ n `divMod` 2 in hylo 0 (\b n -> 10*n + b) f 57
03:20:54 <lambdabot>   111001
03:24:40 <bastl> I have a number of nested do blocks in my main action, and want to refactor these out to smaller functions of type IO Something. Inside the blocks I use bound variables. Is there a clever way to pass these varaiables down to the functions (without adding a lot of parameters to the functions) ?
03:28:00 <mmorrow> bastl: other than defining a datatype that abstracts the situation (and holds all these vals, so you only need one param), no
03:30:24 <bastl> ok. that's a pity. But since I am in IO, couldnt i write these values to some "environemnt" or so ?
03:30:46 <bastl> and then maybe access them from subsequent IO-actions ?
03:31:34 * bastl is again challenged by the paradim change from OO to FP ...
03:32:19 <opqdonut> sure, if you have an IORef for instance
03:33:59 <bastl> hmm. but that sounds as if i would worsen my design ... ill think about it.
03:34:40 <lilac> bastl: can you define the functions within the do-block, so they scope over the relevant variables?
03:35:07 <dschoepe> bastl: what about using StateT?
03:35:21 <lilac> implicit params? :)
03:35:56 <lilac> define them in TH and splice them in? :o
03:36:37 <lilac> bastl: it might make your code clearer if you explicitly have these functions state which values they depend on
03:37:10 <bastl> heres my code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3615#a3615
03:37:34 <etpace> Hmm, how do I represent a `calender' system in Haskell? Where in there would be multiple calenders which contain events, and I'd be able to say, find all calenders which have no events at x y z? (THe latter could be done with just filter and a list of calenders, but it would be pretty slow for a large amount of calenders right? maybe have one calender and just be able to store multiple events at the same time..)
03:37:38 <bastl> its about setting up a glade UI. the relevant functions add behavior to buttons e.g.
03:38:30 <bastl> at the bottom i introduced the containertype "GuiComponents {label :: Label, ...}" But still i  have to carry this one around the whole time ...
03:42:20 <bastl> lilac: i think your last remark is true. Ill stick to it and combine it with good container types.
03:45:39 <lilac> bastl: i think i'd: 1) add a 'data GUI = GUI { widnow :: Widget, selectFile :: FilePath -> IO () {- , ... -} }'
03:46:32 <lilac> 2) split out everything from the initGUI up to and including onDestroy into a new 'buildGUI :: {- args -> -} IO GUI'
03:47:04 <lilac> 3) replace the "startup" code's case 1 with "selectFile gui (head args)"
03:47:39 <lilac> there might be a better way of reorganizing it
03:48:18 <mmorrow> what do people think of this syntax mockup for some way to define types s.t. that type is really just a subset of the constructors of another type (i _think_ subtype is the best name?) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3616#a3616
03:49:06 <mmorrow> subtype Really = Maybe\{Nothing}     (equivalently,  subtype Really = {Just})
03:49:32 <jeltsch> Is there anyone here who knows a bit about Agda/emacs configuration? The #agda channel seems to be somehow dead. :-(
03:49:47 <lilac> mmorrow: subtype NonEmptyList = []\{[]} ? :)
03:50:05 <bastl> lilac: hey, thanks for the feedback. What about the menu hooks at the very bottom? i already have the "GuiCompoments" type, and wrote an example "actionParse". Could that be done clearer?
03:50:18 <mmorrow> lilac: right, but the thing with recursive cons, is you need to give the type of the recursive appearances
03:51:07 <mmorrow> subtype NonEmptyList = {(:)([])}
03:51:27 <mmorrow> since the recursive occurence /can/ have ([]::[a])
03:51:38 <lilac> my gut feeling is that you want to say 'subtype A a b = ...', and that some analogy with pattern matching would make the representation clearer
03:52:03 <mmorrow> lilac: hmm
03:53:20 <lilac> bastl: the OO programmer in me says that you should be returning a type containing functions (such as actionParse) instead of a type containing the actual GUI components
03:53:41 <lilac> bastl: but i've never done anything quite as 'naturally' OO as a GUI in haskell so i don't know whether that's the best way or not :)
03:54:26 <bastl> ok. thanks
03:58:39 <jacobian> suppose I have a datatype and I want it to be parametric over some collection of types, but I don't yet know the collection
03:58:44 <jacobian> What is a clean way to do this
03:59:17 <lilac> use a typeclass to represent the set of operations you want to be able to perform on types in that collection
04:04:54 <mmorrow> lilac: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3616#a3617
04:06:24 <mmorrow> hrm, i guess the keyword "subtype" doesn't quite fit what's happening in that last one
04:06:58 <lilac> can i say 'subtype A Int b :> A5 b = ...'?
04:07:21 <mmorrow> lilac: no, that's the reason i originally omitted the tyvars
04:07:36 <mmorrow> err
04:08:00 <mmorrow> hmm, the only reason i counted that out was because i thought it'd add huge complexity to things, but maybe it wouldn't
04:09:04 <SamB_XP> what the heck is "subtype"?
04:09:07 <lilac> how would these subtypes interact with typeclass instances?
04:09:09 <mmorrow> lilac: oh, ok. i hadn't considered quite that exact case. that's like specialization as well as restriction of cons
04:09:12 <SamB_XP> I've heard of "subrelation" ...
04:09:23 <SamB_XP> but that's just a typeclass in Coq ;-P
04:09:26 <mmorrow> lilac: so i'm thinking that if you have
04:09:40 <mmorrow> foo :: T a b -> o
04:10:01 <mmorrow> then    foo (x :: (t <: T a b) => t) is valid
04:10:14 <mmorrow> since it's just a restriction of the constructors that can appear
04:10:31 <mmorrow> but adding as well stuff like "subtype A Int b :> ..." i'm not sure
04:11:11 <mmorrow> i haven't thought of any reason it wouldn't yet, though
04:11:55 <lilac> mmorrow: can you define an instance for a subtype? do supertype instances get used for subtypes?
04:12:37 <mmorrow> SamB_XP: i feel like you have to do this a lot (in particular, when transforming language AST datatypes), and out of practicality you don't define 10 variants of a 20-constructor type, but have unspoken invariant of which constructors might appear and so on
04:13:06 <mmorrow> lilac: hmm. i think you can, but then it wouldn't apply to any supertypes
04:13:30 <SamB_XP> mmorrow: hmm. true.
04:14:35 <lilac> mmorrow: what do you do about conflicts between typeclass instances?
04:14:39 <SamB_XP> it would be rather a pain even to write the family of inductive predicates that you would need to handle this with existentials ...
04:15:20 <lilac> mmorrow: for what it's worth, i've been playing with much the same problem myself recently. i was approaching it with a GADT which allows me to knock out certain ctors depending on a phantom type parameter
04:17:11 <lilac> mmorrow: as in: 'data Foo state where A :: (HasA state ~ True) => ...; B :: (HasB state ~ True) => ...; C :: (HasC state ~ True) => ...'
04:17:49 <lilac> or 'data Foo withA withB withC where A :: Int -> Foo True withB withC; B :: Int -> Foo withA True withC; C :: Int -> Foo withA withB True'
04:20:51 <mmorrow> hmm, yeah i thought about trying something with GADTs possibly, but it just seems like a hugely circuitous way to say a simple thing
04:21:20 <jpcooper> hello
04:21:36 <jpcooper> I just installed gtk2hs in lib in my home directory. How can I tell ghc that it can look inside ~/lib for libraries?
04:23:46 <SamB> jpcooper: how do you mean, you installed it?
04:23:54 <SamB> if you installed it, GHC knows it is there
04:24:20 <jpcooper> SamB, I built it from source
04:24:23 <jpcooper> and used make install
04:24:32 <SamB> there is a registry of installed libraries in ~/.ghc
04:24:38 <jpcooper> thanks
04:24:55 <jpcooper> oh it seems to be there
04:24:57 <SamB> make install should have created entries for the various gtk2hs packages
04:25:08 <jpcooper> it did, thanks
04:25:10 <SamB> jpcooper: yes, that's just what I was trying to tell you ;-)
04:25:21 <jpcooper> well I never disputed you
04:25:30 <SamB> true
04:25:40 <mmorrow> lilac: i'm not sure about an algo to resolve typeclass instances for these, but i feel like it could be done acceptably
04:26:48 <mmorrow> but regardless of how that turns out, i'd still find them useful without the ability to define instances for them (i.e., they just use the instance of the type they derive from)
04:28:12 <mmorrow> lilac: hmm, also now that i think about it, i don't think "subtype (A a o, X o) :> Foo a o = ..." would work, given that there's no way (in ghc) to tell two cons with the same tag apart (w/out looking at implementation-specific runtime data)
04:28:45 <mmorrow> (but that data *does* currently exist..)
04:28:55 <SamB> well, you could still use the most general type's instances, couldn't you ?
04:29:06 <SamB> well, okay, no ...
04:29:18 <mmorrow> anyways, what i'm really after is just the simplest concept here, and any other possibilities i see as bonuses
04:29:34 <mmorrow> SamB: yeah, i feel like you could do it somehow for sure
04:29:35 <SamB> or rather, only when the type appears only in the domain
04:29:39 <mmorrow> and it'd be handy too
04:30:11 <SamB> of the methods, I mean
04:30:54 <mmorrow> the resulting type is something like => the intersection of subtypes of two different types
04:31:36 <mmorrow> err, sorry
04:31:41 <mmorrow> s/intersection/union/
04:33:51 <mmorrow> so i guess you'd need union types to handle that
04:34:12 <mmorrow> foo :: (Maybe a || Either b a) -> ...
04:34:45 <mmorrow> which is just a "flattened" ADT i guess
04:34:59 <mmorrow> well, the ADT just serves to make a place to put a tag
04:35:15 <mmorrow> so "where does the tag//equiv go?" is the question
04:37:23 <mmorrow> you could always just give each tycon a unique id (where uid(Maybe a b)==uid(Maybe c d)), and stick it in the info table
04:37:50 <mmorrow> ghc already sticks a char[] in there containing the full package/module/type name for the debugger..
04:38:05 <mmorrow> so a single word more wouldn't be a burden
04:39:40 <quicksilver> but is that now almost exactly a tagged union?
04:39:52 * quicksilver remarks that you can implement untagged unions using typeclasses, sort of.
04:39:54 <mmorrow> quicksilver: right
04:40:11 <quicksilver> (sticking the tag in a dictionary instead)
04:40:11 <mmorrow> quicksilver: this would let you be able to say
04:40:26 <mmorrow> :: (Maybe a b OR Either b c)
04:40:32 <mmorrow> without an intervening ADT
04:41:15 <mmorrow> which then would allow
04:41:19 <mmorrow> s/allow/enable/
04:41:49 <mmorrow> subtype (Maybe a, Either b a) :> Foo a b = Just a | Left b
04:42:28 <mmorrow> which is the extension of (not sure if you were here earlier) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3616#a3617
04:43:05 <mmorrow> to (> 1) types in the "context"
04:43:32 * quicksilver nods
04:43:41 <quicksilver> I'm always here
04:43:42 <quicksilver> :P
04:43:45 <mmorrow> :)
04:44:05 <quicksilver> I was just remarking on the irony of avoiding a tagged union just by putting the tag somewhere else.
04:44:31 <quicksilver> doesn't feel entirely right somehow
04:45:04 <mmorrow> quicksilver: but being able to reflect some invariant on an ADT s.t. only a subset of the cons can occur is the killer app here, this is just a possible bonus on top of that
04:45:41 <mmorrow> quicksilver: right, i'm not entirely sure of any "killer" use-cases for this extension to the subtype thing
04:45:50 <mmorrow> just pondering the possibility
04:46:56 <mmorrow> quicksilver: the particular use-case i have is, say you have an Exp type with 20 constructors, and you do a transformation after which the LamE  constructor can no longer exist
04:47:01 <quicksilver> yes
04:47:09 <quicksilver> I'm familiar with the dilemma in question :)
04:47:36 <Tobsan> @src fix
04:47:36 <lambdabot> fix f = let x = f x in x
04:47:38 <mmorrow> when it bites it bites hard
04:47:38 <quicksilver> "How many similar types can I be bothered to make?"
04:47:52 <mmorrow> quicksilver: yeah, sooo tiresome
04:47:59 <malcolmw> wow, over 1300 plays of the HIW videos, in less than 24 hours.  I'm glad I'm not hosting them on my own site.
04:48:22 <quicksilver> do I push an extra parametric value around to alleviate the pain? Do I push an abitrary type constructor down to chop off branches?
04:49:49 <quicksilver> data Hideous f g h a = VarE (f a) | AppE (g (Hideous f g h a)) ...
04:51:10 <quicksilver> do I use data types a la carte?
04:51:55 <mmorrow> ... data Exp243 = VarE243 .. | AppE243 | ...;    data Exp244 = VarE244 .. | ...
04:52:41 <mmorrow> (ok, more like Exp3, Exp4, but even that's excessive)
04:53:09 * quicksilver nods
04:53:27 <mmorrow> copy-paste++
04:53:36 <mmorrow> search-replace++
04:54:04 <quicksilver> still, I don't know what a complete solution should look like
04:54:21 <quicksilver> ocaml's extensible variants are cute, but they all live in one global namespace last I understood
04:54:30 <mmorrow> quicksilver: i think having a  "subtype Maybe a :> Foo a = Just a" would be sufficient
04:54:36 <flux> quicksilver, they don't live in any namespace?
04:54:38 <quicksilver> so you lose any ability at all to designate a group of constructors as being related.
04:55:03 <quicksilver> you don't want people to mix completely unappropriate variants
04:55:08 <mmorrow> hmm, i'm not familiar with those, but they sound possibly interesting
04:55:21 <quicksilver> get get nonsense types like [ `Circle | `Orange ]
04:55:35 <quicksilver> mmorrow: your types become lists of constructors
04:55:42 <quicksilver> mmorrow: and you can have contra- and co-variants
04:55:56 <quicksilver> mmorrow: so "accepts at least these" vs "returns at most these"
04:56:17 <mmorrow> hmm, what does "returns" mean here?
04:56:20 <quicksilver> but each constructore stands completely alone (like data types ala carte, I guess)
04:56:24 <mmorrow> oh, as in a function?
04:56:27 <quicksilver> yes.
04:56:34 <mmorrow> hmm
04:57:11 <flux> quicksilver, you can group them if you want, in match expressions like: type foo = [ `Foo | `Bar ] .. match `Foo with #foo as f -> ..
04:57:29 <quicksilver> mmorrow: http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc36
04:57:47 <quicksilver> flux: true, but you can't stop people doing nonsense combinations, I don't think?
04:58:08 <flux> quicksilver, correct
04:58:14 <mmorrow> restrict :: (a <: b) => b -> Maybe a   -- could be an auto-generated-instances typeclass method maybe
04:58:16 * quicksilver nods
04:58:28 <quicksilver> flux: I mean, it's not the end of the world
04:58:31 <flux> quicksilver, well, except through interfaces perhaps, which is something that's sometimes used with phantom types
04:58:38 <quicksilver> but you are losing something about the construction of types.
04:59:19 <quicksilver> mmorrow: you should read the advanced use section too, of course
04:59:24 <flux> in any case, polymorphic variants often give more annoying compiler error messages
04:59:34 <flux> because obviously it's difficult to associate them into any type definition
04:59:55 * quicksilver nods
05:00:15 <SamB> boy, my dog snores loudly ...
05:00:16 <quicksilver> the sweet spot still isn't obvious to me.
05:00:29 <quicksilver> polymorphic variants do remind me of data types a la carte
05:00:42 <flux> it's nice sometimes
05:00:43 <quicksilver> but the latter can only do positional polymorphism
05:00:59 <quicksilver> whereas your proper polymorphic variants are unordered
05:01:06 <flux> especially when you want to use labeled values inside your local function
05:01:19 <flux> no need to define any new data type outside the function
05:01:20 <quicksilver> just using them as a stand-in for local data then?
05:01:27 <quicksilver> sure, but I'd rather just have local data :)
05:01:39 <quicksilver> that's always struck me as a fairly non-controversial feature.
05:01:58 <mmorrow> local-data-decls would be awesome as well
05:02:14 <quicksilver> let data Dir = Up | Down in ...
05:02:39 <flux> technically you can have a local module in ocaml to have that
05:02:43 <quicksilver> (which is roughly typically of the cases I often want it - labelled enums used locally)
05:02:46 * quicksilver nods
05:02:51 <flux> however it's slightly more syntactic burden
05:03:05 <bsdemon> Hi, I can't compile
05:03:06 <bsdemon> module Main where
05:03:06 <bsdemon> import qualified Data.ByteString as B
05:03:06 <bsdemon> main = undefined
05:03:18 <bsdemon> it fails with ghc_ext.o:(.text+0xe3): undefined reference to `__stginit_bytestringzm0zi9zi1zi4_DataziByteString_'
05:03:18 <mmorrow> --make
05:03:34 <bsdemon> hm...
05:03:35 <bsdemon> thanks
05:05:08 <ehamberg> is using (length . elemIndices) to count ocurrences of an element in a list a good idea, or is there a better way?
05:06:05 <quicksilver> ehamberg: I'd use length . filter I think
05:06:17 <quicksilver> > length . filter (==4) $ [1,2,4,5,4,3,2,4]
05:06:18 <lambdabot>   3
05:06:34 <quicksilver> seems wasteful to calculate the indices and then ignore them :)
05:06:44 <ehamberg> of course. thanks. :)
05:07:16 <quicksilver> in fact, I've often thought that "count p = length . filter p" was worthy of Data.List
05:07:25 <quicksilver> @type let count p = length . filter p in count
05:07:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
05:21:08 <ehamberg> isn't it possible to use 'Î»' instead of '\' with the UnicodeSyntax extension? :|
05:24:09 <SamB> ehamberg: isn't it ?
05:24:22 <ray> no
05:24:51 <SamB> > Î»x -> x
05:25:03 <SamB> @bot
05:25:04 <lunabot>  :o
05:25:07 <SamB> , Î»x -> x
05:25:08 <lunabot>  luna: Pattern syntax in expression context: Û¸ -> x
05:25:15 <SamB> huh?
05:25:28 <ray> it's really not possible
05:25:30 <ray> really
05:25:32 <ray> (really.)
05:25:50 <SamB> but it looks like the error message came back with a Î!
05:26:02 <SamB> or, no ...
05:26:12 <ray> a Û¸
05:26:13 <ray> :)
05:26:25 <ray> that is weird
05:26:34 <ray> mmorrow: wtf
05:26:37 <SamB> ... U+06F8 EXTENDED ARABIC-INDIC DIGIT EIGHT ?
05:27:09 <ray> i have no idea how that could even possibly happen
05:27:17 <mmorrow> , l x -> x
05:27:18 <lunabot>  luna: Pattern syntax in expression context: l x -> x
05:27:21 <ray> i mean it vaguely resembles a lambda
05:27:32 <etpace> Is there a way I can see everything belonging to a module I've imported into ghci?
05:27:34 <mmorrow> , isSymbol 'Î»'
05:27:35 <lunabot>  False
05:27:37 <ray> but i don't think lunabot is programmed to do things based on vague resemblances
05:27:42 <ray> like swap characters
05:28:00 <SamB> ray: I don't even think lambdabot knows the glyphs involved ;-)
05:28:11 <mmorrow> ray: all ghc's error msgs are at varying level of borkdom wrt unicode
05:28:25 <ray> this is beyond borkdom!
05:28:38 <mmorrow> , (text . take 10) ['Û¸'..]
05:28:39 <lunabot>  
05:28:55 <mmorrow> , 'Û¸'
05:28:56 <lunabot>  '\1784'
05:29:09 <mmorrow> , (text . take 10) ['\1784','\1783'..]
05:29:10 <lunabot>  
05:29:32 <mmorrow> i think it's just a random coincidence that it resembles a lambda?
05:29:38 <mmorrow> oh
05:29:41 <mmorrow> oops
05:29:42 <lambdabot> :)
05:29:43 <lambdabot>   <no location info>: parse error on input `->'
05:29:46 <mmorrow> , (text . utf8enc take 10) ['Û¸'..]
05:29:47 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
05:29:48 <mmorrow> , (text . utf8enc . take 10) ['Û¸'..]
05:29:50 <lunabot>  Û¸Û¹ÛºÛ»Û¼Û½Û¾Û¿ÜÜ
05:29:56 <mmorrow> yeah
05:30:06 <mmorrow> random coincidence i guess
05:30:17 <SamB> mmorrow: it works here :-(
05:30:19 <mmorrow> i don't even know what language that is
05:30:29 <SamB> I mean, the error message does
05:30:35 <mmorrow> SamB: you have to use the lambda that isn't a letter
05:30:36 <mmorrow> oh
05:30:37 <SamB> Prelude> show (Î» x -> x)
05:30:37 <SamB> <interactive>:1:6: Pattern syntax in expression context: Î» x -> x
05:30:45 <SamB> what lambda is that ?
05:30:53 <mmorrow> SamB: maybe it's lunabot that's mangling then
05:30:59 <mmorrow> SamB: not sure
05:31:13 <mmorrow> SamB: i think it's in one of the math-ish blocks
05:31:14 <SamB> mmorrow: well, you said the error messages were at varying levels of borkd0m
05:31:23 <mmorrow> SamB: they are
05:31:24 <SamB> so maybe lunabot was trying to handle a different level ;-)
05:31:38 <mmorrow> perchance
05:31:42 <ehamberg> there's a non-letter lambda? cool.
05:31:46 <ray> their encodings aren't similar
05:31:49 <ray> in utf8 and utf16
05:31:53 <ray> where is this non-letter lambda?!
05:32:16 <SamB> ray: unicode(1) can't find it with query -r lambda :-(
05:32:25 <ray> unicode likes to spell it lamda
05:32:40 <ray> there still isn't one though
05:32:46 <ray> unless someone can produce it for me
05:33:02 <xci> Mui.
05:33:12 <SamB> yeah, those are all letters too
05:33:46 <mmorrow> i forget which block it's in
05:33:51 <ray> i propose a MATHEMATICAL SYMBOL LAMBDA code point for the one of the mathematical symbols blocks
05:34:04 <ray> since i have yet to see evidence that such a thing exists
05:34:53 <ray> APL gets all its characters in unicode :(
05:36:16 <mmorrow> well, this one is in "Mathematical Operators", but i'm pretty sure it isn't the one we're looking for
05:36:21 <mmorrow> â
05:36:33 <mmorrow> , (âx->x)4
05:36:34 <lunabot>  luna: parse error on input `->'
05:37:06 <Blub\0> http://www.fileformat.info/info/unicode/char/search.htm?q=lamda&preview=entity
05:37:15 <Blub\0> pick one :P
05:37:51 * ray tries to facepalm but misses
05:38:35 <mmorrow> , (text . utf8enc) "\x1d6cc"
05:38:38 <lunabot>  
05:38:54 <SamB> seriously, Î» should be a keyword
05:39:01 <ray> there ain't no gettin offa this U+2638 WHEEL OF DHARMA we're on
05:39:29 <ehamberg> âº
05:39:48 <SamB> ray: you mean it is determined by our caste that we must write programs with crappy encoding handling ?
05:39:53 <ehamberg> SamB: it should. but maybe the greeks would be pissed off. ;-)
05:40:14 <SamB> and not specify good charecters ?
05:40:26 <SamB> ehamberg: I very much doubt it would be greeks whou would be upset
05:40:31 <mmorrow> personally using lambda in lambdas annoys me
05:40:43 <SamB> mmorrow: why's that ?
05:40:46 <ray> all things considered i think \ is best
05:40:51 <mmorrow> SamB: i'm not sure
05:40:58 <SamB> 'cause it looks like a letter ?
05:40:59 <ray> and unless we want haskell keyboards, no unicode syntax either :)
05:40:59 <mmorrow> it just seems random and useless
05:41:20 <SamB> yeah, I guess maybe \ is better ;-)
05:41:38 <int-e> \Î» Âµ -> Î» (Î» Âµ)
05:41:42 <ray> look at lispers
05:41:45 <ray> they have to type "lambda"
05:41:47 <ray> what losers
05:41:59 <SamB> int-e: okay, now that seriously freaks me out
05:42:21 <jacobian> I'd rather that "." was used instead of "->"
05:42:22 <SamB> ray: yeah, coqers only need to type (fun ... => ...)
05:42:35 <ray> ugh
05:42:40 <SamB> jacobian: that's a bit hard to spot
05:42:41 <ray> . is the most overloaded character in haskell already
05:42:45 <ray> leave . alone!
05:42:46 <SamB> that too
05:42:47 <int-e> oh, I guess (Î» (x) (+ x 1)) would look fine.
05:43:03 <ray> lispers could use Î» no problem :)
05:43:10 <SamB> int-e: in lisp you mean ?
05:43:14 <int-e> SamB: yes
05:43:20 <SamB> just a defmacro away, eh?
05:43:29 <int-e> yep
05:43:45 <jacobian> we could go back to the original source of lambda
05:44:10 <jacobian> ^x . phi(x)
05:44:24 <jacobian> comma would substitute for "."
05:44:33 <sinelaw> greetings, other people.
05:46:30 <mornfall> speciist!
05:46:30 <mornfall> :P
05:47:55 * lambdabot feels left out.
05:51:48 <sinelaw> > make coffee
05:51:49 <lambdabot>   "OK, Human."
05:52:44 <int-e> @type coffee
05:52:45 <lambdabot> forall t. (Num t) => t
05:52:51 <ari> :t make
05:52:52 <lambdabot> forall t. t -> [Char]
05:53:00 <int-e> > coffee
05:53:01 <lambdabot>   0
05:53:11 * int-e half expected 42.
05:53:19 <ari> > make 42
05:53:20 <lambdabot>   "OK, Human."
05:53:35 <ari> > make undefined
05:53:36 <lambdabot>   "OK, Human."
06:15:25 <sohum> unfortunately
06:15:32 <sohum> > make me a sandwich
06:15:33 <lambdabot>   Not in scope: `me'Not in scope: `sandwich'
06:16:06 <sohum> > let me = 0 in let sandwich = 0 in make me a sandwich
06:16:07 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t1 -> t'
06:16:07 <lambdabot>         agains...
06:16:28 <sohum> > a
06:16:28 <lambdabot>   a
06:16:33 <sohum> :t a
06:16:34 <lambdabot> Expr
06:17:15 <sohum> > let me = 0 in let sandwich = 0 in let make _ _ _ = "OK, Human." in make me a sandwich
06:17:15 <lambdabot>   "OK, Human."
06:17:16 <ziman> > let ~(me,sandwich) = undefined in make me a sandwich
06:17:16 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t1 -> t'
06:17:16 <lambdabot>         agains...
06:17:52 <ziman> > let ~(me,sandwich) = undefined in make $ me a sandwich
06:17:52 <lambdabot>   "OK, Human."
06:18:10 <sohum> well, that's just cheating, isn't it?
06:18:31 <FunctorSalad>  @let makeMeASandwich nick = do { info <- acquireAddressAndCreditCardInfo nick; orderSandwichFromWebsite info }
06:19:29 <Jafet> Requires sudo
06:20:12 <ari> > let (me,sandwich) = undefined in make $ me a sandwich
06:20:13 <lambdabot>   "OK, Human."
06:20:51 <ari> 420 let-bind lazily every day
06:21:14 <FunctorSalad> what?
06:23:55 <Lycurgus> 42 * 10. Extra strong 42.
06:24:10 <FunctorSalad> hmm
06:47:20 <dayz> hi
06:49:23 <Raevel> hi dayz!
06:52:06 <pao> @type vcat
06:52:06 <lambdabot> [Doc] -> Doc
06:52:20 <pao> @pl \f -> vcat . map f
06:52:20 <lambdabot> (vcat .) . map
06:56:27 <burp> http://paste.railsbox.eu/show/W8q7ZMbi8nFY4E3qpd9U/ <- anyone sees a problem there on first sight? I'm trying to use BF_cbc_encrypt from openssl, but always get a different encryption result
06:56:44 <etpace> @pl \f n g x y = f n (g x y)
06:56:44 <lambdabot> (line 1, column 12):
06:56:45 <lambdabot> unexpected "="
06:56:45 <lambdabot> expecting pattern or "->"
06:56:51 <etpace> @pl \f n g x y  -> f n (g x y)
06:56:51 <lambdabot> (((.) . (.)) .)
07:05:28 <quicksilver> burp: isn't that how you expect ciphers to work?
07:05:35 <quicksilver> burp: there is some mutable state inside the key object
07:06:10 <quicksilver> burp: repeated sequences don't come out as repeated sequences
07:06:17 <quicksilver> (that would make it too easy to crack)
07:07:40 <burp> I expect ciphers to be pure, deterministic :>
07:08:28 <burp> the encrypted output changes
07:09:36 <sohum> @hoogle (b -> b -> c) -> (a -> b) -> [a] -> c
07:09:36 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:09:37 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
07:09:37 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
07:09:52 <sohum> oh, wait
07:10:02 <sohum> @hoogle ([b] -> c) -> (a -> b) -> [a] -> c
07:10:02 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t e -> q) -> d -> q
07:10:31 <sohum> well, that's not useful
07:10:51 <Jafet> burp, CBC mode uses an IV, in your case selected at random
07:11:06 <Jafet> Either that or cosmic rays.
07:11:27 <sohum> :t \final f xs -> final $ map f xs
07:11:27 <lambdabot> forall b a b1. ([b1] -> b) -> (a -> b1) -> [a] -> b
07:11:38 <burp> Jafet: random? I set it to 0
07:11:53 <burp> poke ivecptr (fromIntegral 0)
07:13:05 <Jafet> What does the library do when given a null IV?
07:13:41 <Jafet> (A 0 IV is an IV that is all 0s, which doesn't seem to be what you did)
07:14:00 <burp> not?
07:14:08 <burp> I thought I set it to just 0's
07:14:13 <burp> but anyway it shouldn't change
07:14:23 <Jafet> It smells like you set a pointer to the IV to null
07:14:33 * Jafet sniffs
07:14:57 <quicksilver> burp: what type do you think ivecptr hash?
07:15:10 <quicksilver> I have a feeling c2hs is making it a Byte/Word8
07:15:16 <PeakerWork> @pl \final f xs -> final $ map f xs
07:15:16 <lambdabot> (. map) . (.)
07:15:18 <quicksilver> (because it sees unsigned char *)
07:15:21 <burp> unsigned char *ivec <- hm lets see
07:15:23 <quicksilver> but you have to set 64 bits of it
07:15:38 <burp>   c_BF_cbc_encrypt :: ((Ptr CUChar) -> ((Ptr CUChar) -> (CLong -> ((Ptr ()) -> ((Ptr CUChar) -> (CInt -> (IO ())))))))
07:15:42 <burp> its CUChar
07:15:47 <burp> correctly
07:15:50 <quicksilver> I suspect you're only setting the first 8 bits (maybe first 32?) and the remaining ones are undefined.
07:16:13 <quicksilver> yup, you're just setting the first 8 bits
07:16:17 <quicksilver> if it's Ptr CUChar
07:16:20 <PeakerWork> @let result = (.) ; arg = flip (.)
07:16:20 <lambdabot>  <command line>: does not exist: .L.hs
07:16:25 <PeakerWork> @let result = (.)
07:16:25 <lambdabot>  <local>:2:0:
07:16:25 <lambdabot>      Multiple declarations of `L.result'
07:16:25 <lambdabot>      Declared at: <loc...
07:16:29 <ClaudiusMaximus> @type pokeArray
07:16:30 <lambdabot> Not in scope: `pokeArray'
07:16:31 <PeakerWork> @type (result . arg) map result
07:16:32 <lambdabot> forall a b c. ([b] -> c) -> (a -> b) -> [a] -> c
07:16:43 <Jafet> If you want a zero IV, surely you need to create the IV via allocaArray and set all its bytes to 0
07:16:50 <burp> hm, when I write into Ptr CUChar, I don't fill the whole unsigned char?
07:16:55 <quicksilver> burp: yes, you do.
07:16:58 <quicksilver> burp: that's 8 bits.
07:17:03 <burp> oh
07:17:06 <quicksilver> burp: the BF call you are calling wants 64 bits.
07:17:17 <PeakerWork> @let infixr 2 ~> ; (f ~> g) x = f >>> x >>> g
07:17:17 <lambdabot>  Defined.
07:17:21 <burp> I see
07:17:25 <PeakerWork> @type id ~> map ~> id $ result
07:17:26 <lambdabot> Not in scope: `~>'
07:17:26 <lambdabot> Not in scope: `~>'
07:17:26 <lambdabot> Not in scope: `result'
07:17:46 <quicksilver> withArray ([0,0,0,0,0,0,0,0] :: [CUChar]) $ \ivecptr -> ....
07:17:47 <PeakerWork> @type (~>)
07:17:48 <lambdabot> Not in scope: `~>'
07:17:50 <quicksilver> (IIRC)
07:17:56 <dons> complete videos of the implementors workshop, upmod: http://www.reddit.com/r/programming/comments/9krtp/the_complete_videos_of_the_haskell_implementors/
07:17:56 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:18:09 <quicksilver> check the syntax of withArray though.
07:18:30 <burp> it's deterministic now
07:18:31 <burp> thanks
07:18:32 <Jafet> Hmm, so burp passed a pointer to one byte?
07:18:35 <sinelaw> Heh, I disconvered how to force lambdabot to make a huge burger
07:18:39 <sinelaw> *discovered
07:18:40 <burp> Jafet: I did
07:18:43 <sinelaw> > let a a = a in a
07:18:43 <quicksilver> Jafet: he just asked haskell to set one byte, yes
07:18:44 <lambdabot>   {()->()}
07:18:47 <Jafet> It's a wonder it didn't segfault
07:18:49 <quicksilver> Jafet: so the other 7 bytes were undefined.
07:18:52 <burp> allocaArray 8 $ \ivecptr -> do .. pokeArray ivecptr (map fromIntegral [0,0,0,0,0,0,0,0])
07:18:55 <burp> or that.. yes
07:19:06 <quicksilver> Jafet: well, not that surprising. Memory barriers aren't normally that tight.
07:19:19 <Jafet> Oh, it's blowfish, so 64-bit blocks.
07:19:30 <burp> I expected it to segfault when I access other memory ;)
07:19:40 <sinelaw> can anyone actually explain why the result is {()->()}?
07:19:56 <quicksilver> sinelaw: extended defaulting
07:20:08 <Saizan> sinelaw: extended defaulting + smallcheck's Show instance for functions
07:20:21 <sinelaw> @let a a = a
07:20:22 <lambdabot>  Defined.
07:20:25 <sinelaw> @type a
07:20:25 <lambdabot>     Ambiguous occurrence `a'
07:20:26 <lambdabot>     It could refer to either `L.a', defined at <local>:3:0
07:20:26 <lambdabot>                           or `SimpleReflect.a', imported from SimpleReflect at State/L.hs:74:0-32
07:20:28 <quicksilver> the two "a"s are distinct in "let a a"
07:20:35 <Saizan> @type L.a
07:20:36 <lambdabot> forall t. t -> t
07:20:38 <quicksilver> I can't remember which one the one on the RHS is :)
07:20:51 <quicksilver> > let a a = a in a 5
07:20:51 <saml> > let a a = a in a 1
07:20:52 <lambdabot>   5
07:20:52 <lambdabot>   1
07:20:57 <quicksilver> yeah, the RHS is the parameter
07:20:59 <quicksilver> not the function.
07:21:00 <etpace> has anyone here used Data.DateTime? Is it possible to diffDays? It doesn't seem so
07:21:19 <sinelaw> that's pretty ambiguous, maybe it should be a syntax error
07:21:53 <sinelaw> quicksilver, I actually thought it defines a function that when called on itself, returns itself
07:21:59 <Saizan> it's consistent with let a = \a -> a, but as we disallow let foo a a = .., i think i agree it should be an error
07:22:37 <sinelaw> > fix a
07:22:38 <lambdabot>   Ambiguous occurrence `a'
07:22:38 <lambdabot>  It could refer to either `L.a', defined at <local...
07:22:43 <sinelaw> > fix L.a
07:22:46 <lambdabot>   mueval-core: Time limit exceeded
07:22:59 <sinelaw> a is id, no?
07:23:07 <sinelaw> @pl a
07:23:07 <lambdabot> a
07:23:18 <Saizan> your L.a is id, yeah
07:23:22 <sinelaw> @pl L.a
07:23:22 <lambdabot> L.a
07:23:39 <Saizan> @pl doesn't look at the definitions for defined functions
07:23:39 <lambdabot> doesn't look at the definitions for defined functions
07:23:40 <benmachine> @pl does not know about what is defined
07:23:40 <lambdabot> does not know about what is defined
07:23:44 <benmachine> heh
07:23:46 <sinelaw> to me it still looks like a function that returns itself when called on itself
07:24:01 <benmachine> well, it does :P
07:24:07 <burp> hm I think I have the same problem with inputptr
07:24:08 <sinelaw> heh
07:24:17 <sinelaw> > a a
07:24:18 <lambdabot>   Ambiguous occurrence `a'
07:24:18 <lambdabot>  It could refer to either `L.a', defined at <local...
07:24:23 <sinelaw> > L.a L.a
07:24:24 <lambdabot>   {()->()}
07:24:24 <sinelaw> sigh
07:24:33 <Woof> @ let f x = f
07:24:34 <burp> I have Word64 input, and put a Word64 into the unsigned chars
07:24:53 <Woof> @let ff x = ff
07:24:53 <lambdabot>  <local>:4:7:
07:24:54 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1 -...
07:25:03 <deech`> Hi all, If I run a compiled file from the interpreter do I experience any
07:25:03 <deech`>          performance loss?
07:25:05 <sinelaw> so pattern matching can't capture the same function that's being define?
07:25:24 <Axman6> deech`: more likely the opposite
07:25:32 <sinelaw> i guess not, the way let is probably transformed
07:25:45 <Saizan> sinelaw: you can't pattern match using function names as patterns
07:25:57 <Saizan> sinelaw: you can only use data constructors that way
07:26:04 <deech`> Axman6: You mean I have better performance running a compiled file from GHCI than from pure commandline?
07:26:04 <sinelaw> Saizan, only constructors or variables, right?
07:26:34 <Saizan> sinelaw: yeah, what's not a constructor is considered a fresh variable
07:26:59 <benmachine> you can also pattern match numbers due to magic
07:27:06 <sinelaw> you mean constants
07:27:07 <benmachine> well
07:27:11 <benmachine> literals in general I suppose
07:27:31 <Saizan> yeah, numeric, char and string literals
07:27:39 <sinelaw> does haskell have a notion of uniformity
07:27:42 <Saizan> i generally consider them special constructors
07:28:01 <Saizan> what do you mean?
07:29:14 <sinelaw> a pattern matching definition where there is no "mixed" patterns (first argument of patterns are either all constructors or all variables)
07:29:30 <sinelaw> (taken from SPJ's book The Implementation of Functional Programming Languages)
07:29:40 <sinelaw> this results in patterns whose order does not matter
07:29:55 <etpace> Are there any alternatives to Data.Time? It seems quite.. weird/hard, and there are a few things missing/broken in Data.DateTime
07:30:03 <Skif> I think I do not yet understand list comprehensions properly. If you look at http://pastie.org/617445 the 'takeWhile' version returns almost instantly, but what I think is the equivalent with list comprehensions just hangs forever. How should I write it to be equivalent to the takeWhile (or can I use a list comprehension this way at all?)
07:30:47 <Saizan> i guess such a property is exploited by GHC when it's met, but there's no source level way to enforce it or anything like that
07:31:19 <Petrosian> Skif: The list comprehension version will run forever
07:31:39 <sinelaw> there should at least be a warning that we can enable, when the order of the patterns matters?
07:31:41 <Petrosian> Skif: The predicate "x < 400000" is applied on a per element basis
07:31:44 <Saizan> Skif: your comprehension is equivalent to filter (\x -> x < 4000000) fibs
07:32:10 <Saizan> sinelaw: when patterns overlap there's a warning, yes
07:32:13 <Petrosian> Skif: So it will continue beyond 400000, checking that x < 400000, even when it will never occur again
07:32:18 <Skif> Ah, I see.  Thanks, Petrosian, that's the hole in my reasoning.
07:32:43 <Skif> Petrosian: So there's really no way to get there from here, then, at least not using list comprehensions?
07:32:45 <sinelaw> Saizan, it's not only when they overlap
07:33:17 <Petrosian> Skif: Not easily. It's best to think of list comprehensions as map and filter(s) combined
07:33:27 <pozic> Is there any case where ContT r m a is used  where r has to be unequal to a?
07:33:31 <Petrosian> Except with potentially more than a single generator
07:33:33 <Saizan> sinelaw: what's an example where the order of patterns matters and they don't overlap?
07:34:01 <Skif> Petrosian: that makes sense.  Thanks!  For reference, I'm working my way through Project Euler with Haskell to give myself some practise beyond what's in RWH.
07:34:22 <sinelaw> Saizan, SPJ gives one. one sec
07:34:46 <Petrosian> Skif: Pretty standard around here! I'd wager half the people lurking in this channel have tried at some stage or another to plough through Project Euler
07:34:51 <Skif> :-)
07:34:52 <Petrosian> (using Haskell, that is)
07:34:54 <sinelaw> > let ordermatters a True False = 1; ordermatters False b True = 2; ordermatters True False c = 3 in ordermatters undefined True False
07:34:54 <lambdabot>   1
07:35:09 <sinelaw> > let ordermatters True False c = 3; ordermatters a True False = 1; ordermatters False b True = 2 in ordermatters undefined True False
07:35:10 <lambdabot>   * Exception: Prelude.undefined
07:35:13 <sinelaw> There you go
07:35:35 <Skif> Petrosian: so far, it's an entertaining effort. I'm finding Haskell to be a lot like Prolog-- only in the respect that my brain feels bigger after I work with either one. :-)
07:35:44 <Saizan> sinelaw: i was considering a pattern at a time, "a" overlaps with both False and True
07:36:01 <Saizan> s/a pattern/an argument/
07:36:26 <Saizan> i'm not sure if the overlapping warning uses my definition, though
07:37:00 <sinelaw> here's a shorter one
07:37:01 <sinelaw> > let f a True = 1; f False b = 2 in f undefined True
07:37:02 <lambdabot>   1
07:37:08 <sinelaw> > let f False b = 2; f a True = 1 in f undefined True
07:37:08 <Petrosian> Skif: When I first started learning Haskell, I found the learning curve got pretty steap on Euler. It took me a while until I could get much beyond problem ~50
07:37:09 <lambdabot>   * Exception: Prelude.undefined
07:37:24 <PeakerWork> sinelaw: these may overlap though
07:37:41 <sinelaw> yea, the first one was correct, but not the second example
07:37:57 <sinelaw> now i understand why they needed 3 arguments
07:38:00 <Petrosian> Skif: After returning to it a year or two later now, however (with a far better grasp of Haskell), it's a stroll in the park (well, until the really hard problems!)
07:38:44 <sinelaw> Saizan, what do you mean a pattern at a time?
07:38:54 <sinelaw> Saizan, oops. what do you mean an argument at a time?
07:39:18 <sinelaw> i guess you mean that the overlap occurs per argument, not globally
07:39:25 <Saizan> yes
07:39:45 <sinelaw> Saizan, i have a feeling that your definition is exactly what SPJ defined as "Uniform"
07:40:09 <dibblego> @src Either
07:40:09 <lambdabot> Source not found. That's something I cannot allow to happen.
07:40:28 <benmachine> data Either a b = Left a | Right b
07:40:43 <Saizan> sinelaw: it seems there's no warning related to it though, by compiling your ordermatters with -Wall
07:41:48 <sinelaw> so they ignored his warning that too much emphasis is placed on overlapping, while the real problem is uniformity
07:42:03 <sinelaw> (rather, non-uniformity)
07:42:03 <tibbe> I'm trying to wrap my head around the difference between the lazy and strict State monad. Could someone explain exactly what's lazy/strict in the two versions?
07:42:55 <Saizan> tibbe: the definition of >>=, one uses let to pattern match on the tuple while to other uses case
07:42:58 <quicksilver> in the strict state monad, "foo >> return 0" will still do the state changes in foo
07:43:11 <quicksilver> in the lazy state monad, those wil only happy if you actually inspect the state
07:43:20 <Saizan> it's not strict on the state
07:43:24 <quicksilver> (i.e. all the changes from foo are bundled up in a thunk at the state)
07:43:29 <quicksilver> I didn't say it was :)
07:43:46 <pozic> Is it possible to create an uncallable function?
07:44:07 <Saizan> i'm not sure what you said is right either :)
07:44:11 <pozic> That is: a function for which ghci gives a type, but which you cannot instantiate in any non-trivial (undefined) way?
07:44:36 <pozic> By instantiate, I mean giving it all the arguments, it requires.
07:44:38 <Saizan> it depends on the definition of modify, i think
07:45:16 <tibbe> Saizan: quicksilver: what exactly is the semantics of let and case?
07:45:31 <quicksilver> case actually unpacks the tuple, which forces it
07:45:38 <quicksilver> let just builds thunks which refer to the tuple
07:45:44 <etpace> @hoogle (a -> b) -> a -> a -> (b,b)
07:45:44 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
07:45:50 <quicksilver> > case undefined of (a,b) -> "hi"
07:45:50 <lambdabot>   "* Exception: Prelude.undefined
07:45:53 <tibbe> quicksilver: so the "in" clause in the "let" statement is also lazy?
07:45:59 <Saizan> pozic: which extensions do you allow?
07:46:03 <quicksilver> > let (a,b) = undefined in "hi"
07:46:04 <lambdabot>   "hi"
07:46:13 <xlq> What's wrong with the assignment in main? http://pastebin.ch/4261
07:46:20 <quicksilver> Saizan: in particular, in the strict state monad, (_|_ >> return 0) is _|_
07:46:36 <quicksilver> Saizan: in the lazy one, (_|_ >> return 0) can be safely 'evaled' to get 0
07:46:38 <tibbe> quicksilver: so the state itself is not actually strict
07:46:39 <xlq> "Couldn't match expected type `X' against inferred type `m a'"
07:46:42 <quicksilver> no.
07:46:45 <etpace> isn't there an arrow like that?
07:47:08 <tibbe> quicksilver: so there's still a need for "put $! ..." when you actually want a strict state
07:47:09 <Raevel> xlq: x should be of type IO X in your case
07:47:25 <pozic> Saizan: Just mtl
07:47:25 <Saizan> xlq: you can only use "x <- foo" if foo is of type IO Something, in your case
07:47:26 <Raevel> ehm, sorry, the value after <- should be IO X
07:47:29 <quicksilver> tibbe: you need to use put $! *and* use the strict state monad, to be absolutely sure.
07:47:30 <etpace> :t Just &&& Just
07:47:30 <lambdabot> forall b. b -> (Maybe b, Maybe b)
07:47:36 <xlq> ohh
07:47:38 <Petrosian> xlq: Try a `return' before `X 1 2'
07:47:46 <quicksilver> tibbe: as I say, "undefined >> return 0" is not _|_ in the lazy one.
07:47:51 <tibbe> quicksilver: right
07:48:02 <etpace> @pl \f x y = (f x, f y)
07:48:02 <lambdabot> (line 1, column 8):
07:48:02 <lambdabot> unexpected "="
07:48:02 <lambdabot> expecting pattern or "->"
07:48:08 <etpace> @pl \f x y -> (f x, f y)
07:48:08 <lambdabot> flip =<< (((.) . (,)) .)
07:48:29 <Raevel> so yeah, what Petrosian said, although i always feel a little uneasy about writing that, for some reason :-)
07:48:53 <Petrosian> Yes, I'd sooner use a `let' in practise
07:49:14 <Saizan> in fact there's no point in using "x <- return (X 1 2)" there
07:49:29 <Raevel> i always have problems when i try to nest lets in dos
07:49:34 <Saizan> "let x = X 1 2"
07:49:35 <Petrosian> There's no point, but for the sake of the point we were making
07:50:00 <Petrosian> That is, turning `X 1 2' in a IO X rather than a simple X
07:50:46 <quicksilver> Raynes: I would learn to solve those problems. Lets in dos is useful.
07:51:30 <Raynes> quicksilver: What? O_o
07:51:31 <Petrosian> quicksilver: I think you meant Raevel!
07:51:39 <Raynes> I do too.
07:51:49 <Raevel> yep yep
07:52:10 <Raevel> i'll schedule that for tonight, it's probably not very hard
07:52:28 <quicksilver> sorry.
07:52:49 <quicksilver> you six-letter-names-beginning-with-R all look the same to me.
07:53:21 <Saizan> pozic: not OTOH, do you have a suspect?
07:55:05 <tibbe> @type splitAtST
07:55:05 <lambdabot> Not in scope: `splitAtST'
07:56:20 <pozic> Saizan: I had one, yes. It's not really important. Related to it is the question what the exact difference is between StateT State (ContT r m) a and ContT r (StateT State m) a.
07:56:49 <quicksilver> whether the state is preserved when you "save" the current continuation
07:57:02 <quicksilver> or whetehr your state continues "despite" any control flow you might do
07:57:04 <quicksilver> (I think)
07:57:19 <Saizan> iirc, the mtl's instances are written so they both do the same thing
07:57:34 <quicksilver> that seems odd.
07:57:36 <pozic> In one case the types didn't work out.
07:57:54 <Saizan> (i refer to callCC)
07:58:06 <quicksilver> because the explanation I gave is correct for ErrorT StateT vs StateT ErrorT ;)
07:58:23 <Saizan> yes, but it's a known oddity
07:58:38 <Saizan> and in the ErrorT case you actually don't have a choice
07:59:05 <pozic> Hmm, actually, it still doesn't work :( I keep getting infinite types.
07:59:07 * Saizan tries to conjure the examples
07:59:27 <Saizan> maybe you need some newtype wrapping
07:59:47 <Saizan> are you trying to store the continuations in the state, maybe?
08:00:34 <pozic> Saizan: no, but do pass the continuation to some function, but that should not be related.
08:03:23 <Saizan> > flip runCont id . flip runStateT 0 $ callCC (\k -> do put 1; k ())
08:03:24 <lambdabot>   ((),1)
08:03:41 <Saizan> > flip runState 0 . flip runContT return $ callCC (\k -> do put 1; k ())
08:03:42 <lambdabot>   ((),1)
08:04:11 <Saizan> it's never saved
08:05:50 <quicksilver> Saizan: is that because if you do it the way I expected, it's not a monad any more? Or is it just a mistake?
08:07:07 <Saizan> quicksilver: from old discussions it seems just a mistake, but i never considered that problem
08:07:38 <etpace> @unpl (Î»dt1 dt2 â abs $ div (DT.diffMinutes' dt1 dt2)
08:07:38 <lambdabot> Unbalanced parentheses
08:07:41 <etpace> @unpl (Î»dt1 dt2 â abs $ div (DT.diffMinutes' dt1 dt2))
08:07:41 <lambdabot>  Illegal character ''\187''
08:07:41 <lambdabot>  at "»dt1" (column 3)
08:07:50 <etpace> @unpl Î»dt1 dt2 -> abs $ div (DT.diffMinutes' dt1 dt2
08:07:51 <lambdabot> Unbalanced parentheses
08:07:58 <etpace> @unpl Î»dt1 dt2 -> abs $ div (DT.diffMinutes' dt1 dt2)
08:07:59 <lambdabot>  Illegal character ''\187''
08:07:59 <lambdabot>  at "»dt1" (column 2)
08:08:02 <Saizan> etpace: the lambda.
08:08:07 <etpace> Doh
08:08:19 <etpace> @unpl \dt1 dt2 -> abs $ div (DT.diffMinutes' dt1 dt2)
08:08:20 <lambdabot> \ dt1 dt2 -> abs (div (DT.diffMinutes' dt1 dt2))
08:08:27 <etpace> and the wrong one
08:08:31 <etpace> @pl \dt1 dt2 -> abs $ div (DT.diffMinutes' dt1 dt2)
08:08:31 <lambdabot> ((abs . div) .) . DT.diffMinutes'
08:08:37 <etpace> sorry for the spam
08:08:57 <Saizan> lambdabot also answers to privmsg, btw
08:09:05 <etpace> Oh, that helps
08:10:31 <metacabbage> whassup haskell? I'm building ghc for Solaris, and the build is failing on haskeline... it seems to be unable to find the libiconv files??
08:10:42 <dons> metacabbage: do you have iconv installed?
08:10:45 <metacabbage> is this an error you guys are familair with? http://pastebin.ca/1567124
08:11:02 <metacabbage> dons, yes, both the sunstudio and gcc compiled flavors
08:11:33 <dons> metacabbage: also, ask in #ghc
08:11:36 <dons> better support there for ghc ports
08:11:46 <dons> 22. ld.so.1: IConv_hsc_make: fatal: libiconv.so.2: open failed: No such file or directory
08:11:55 <dons> indicates that hsc2hs couldn't find the path to libiconv.so
08:12:07 <quicksilver> Saizan: what's weird is that the types let you get it wrong.
08:12:17 <dons> so a LD_FLAGS or LD_LIBRARY_PATH issue perhaps
08:12:17 <quicksilver> Saizan: intuitively that is quite surprising :)
08:12:28 <quicksilver> Saizan: as you pointed out, the types for MaybeT and ErrorT only give you one choice.
08:15:03 <metacabbage> dons, I mean I set PATH and LD_LIBRARY_PATH carefully, since ghc needs the bootstrap "other ghc" thing, so I'm pretty confused, really :P
08:15:17 <Saizan> quicksilver: heh, the dark power of continuations
08:15:18 <metacabbage> about to ask in ghc :)
08:16:02 <Saizan> quicksilver: however the difference in the two behaviours is only in the MonadCont instances, so i don't think it can affect the monad laws
08:17:15 * quicksilver hmms
08:17:43 <Saizan> also because you can write callCC' f = do s <- get; callCC (\k -> f (\a -> put s; k a))
08:17:58 <Saizan> which rollbacks the state
08:18:19 <Saizan> (forgot a do)
08:18:32 <quicksilver> no, you mispelt >> as ;
08:18:34 <quicksilver> ;)
08:19:07 <Saizan> :)
08:19:14 * shapr snickers
08:19:29 <shapr> @remember quicksilver no, you mispelt >> as ;
08:19:29 <lambdabot> I will never forget.
08:22:14 <Saizan> _;_ : forall {a b} {m : Set -> Set} -> Monad m -> m a -> m b -> m b <- not even agda let me do that, ; is a keyword
08:24:23 <mmorrow> @let callCC_revert f = StateT (\s -> Cont (\k -> flip runCont k (runStateT (f (\a -> StateT (\_ -> Cont (\_ -> k (a,s))))) s)))
08:24:24 <lambdabot>  Defined.
08:24:39 <mmorrow> @let callCC_dirty f = StateT (\s -> Cont (\k -> flip runCont k (runStateT (f (\a -> StateT (\s -> Cont (\_ -> k (a,s))))) s)))
08:24:40 <lambdabot>  Defined.
08:24:50 * mmorrow copies those from monad-tx
08:25:04 <mmorrow> > flip runCont id (runStateT (callCC_revert (\k -> put 42 >> k 99 >> put 0 >> return 88)) 0)
08:25:05 <lambdabot>   (99,0)
08:25:10 <mmorrow> > flip runCont id (runStateT (callCC_dirty (\k -> put 42 >> k 99 >> put 0 >> return 88)) 0)
08:25:11 <lambdabot>   (99,42)
08:25:32 <xlq> Can I escape a newline?
08:25:40 <mmorrow> , show "\n"
08:25:41 <lunabot>  "\"\\n\""
08:25:41 <xlq> Or must I cram long expressions onto one line?
08:25:46 <mmorrow> oh
08:26:05 <mmorrow> xlq: this isn't CPP, you can use newlines :)
08:26:22 <xlq> but I have to indent :\
08:26:24 <mmorrow> xlq: (but you need to follow the indentation rules)
08:26:42 <xlq> yeah, in which case it's not worth putting a newline, because I've got to fill the next line with spaces
08:26:44 <ksf> I'm stuck with c2hs.
08:26:55 <mmorrow> xlq: dunno what you're going for
08:27:00 <ksf> how am I supposed to reference a pointer that's in a structure with a get hook?
08:27:23 <ksf> it's fixing the pointer's type to Ptr (), and I don't want it to.
08:27:44 <mmorrow> @type Foreign.castPtr
08:27:45 <lambdabot> forall a b. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
08:27:54 <ksf> hey!
08:28:02 <ksf> ...I was almost suspecting unsafeCoerce
08:28:14 <mmorrow> it essentially is
08:37:02 <mmorrow> @djinn-env type SC o s a = (a -> s -> o) -> s -> o
08:37:02 <lambdabot> data () = ()
08:37:03 <lambdabot> data Either a b = Left a | Right b
08:37:03 <lambdabot> data Maybe a = Nothing | Just a
08:37:03 <lambdabot> data Bool = False | True
08:37:03 <lambdabot> data Void
08:37:04 <lambdabot> type Not x = x -> Void
08:37:06 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
08:37:07 <mmorrow> @djinn-add type SC o s a = (a -> s -> o) -> s -> o
08:37:08 <lambdabot> class Eq a where (==) :: a -> a -> Bool
08:37:27 <mmorrow> @djinn a -> SC o s a
08:37:27 <lambdabot> f a b = b a
08:37:42 <mmorrow> @djinn SC o s a -> (a -> SC o s b) -> SC o s b
08:37:42 <lambdabot> f a b c d = a (\ e f -> b e c f) d
08:37:49 <pozic> What's the "let the infinite types work"-transformation?
08:38:05 <mmorrow> @djinn ((a -> SC o s b) -> SC o s a) -> SC o s a
08:38:05 <lambdabot> f a b c = a (\ d _ _ -> b d c) (\ e f -> b e f) c
08:38:40 <mmorrow> all yoar monad code is easy party for djinn
08:39:19 <mmorrow> @. pl djinn ((a -> SC o s b) -> SC o s a) -> SC o s a
08:39:19 <lambdabot> f = flip flip id . (ap .) . join . (flip .) . (. ((((const . const) .) .) . flip)) . (.)
08:39:25 <wmealing> mmorrow:  what you say ?
08:39:39 <mmorrow> wmealing: ?
08:39:39 <xlq> If I declare a function with a type signature (a -> a) -> whatever, can I use the (a -> a) parameter for any type, or is a bound to only one type for the whole function?
08:39:55 <wmealing> mmorrow:  ok.. i thought you were quoting all your base are belong to us.
08:40:04 <mmorrow> wmealing: ahh
08:40:29 <mmorrow> wmealing: in hindsight, that would have been bettar
08:41:09 <mmorrow> xlq: if you want to use it at multiple types, you really want the type
08:41:17 <mmorrow> (forall a. a -> a) -> whatever
08:41:24 <xlq> Ooh, forall :)
08:41:40 <mmorrow> (*in* the parens)
08:41:59 <mmorrow> but i think the only function of that type is `id' ?
08:42:06 <xlq> Oh, it requires -XRankNTypes .. strange
08:42:13 <mmorrow> xlq: right
08:42:24 <xlq> Can I do it without that switch?
08:43:06 <mmorrow> xlq: what is your full type sig
08:43:07 <mmorrow> ?
08:43:16 <mmorrow> (without the rankntypes forall)
08:43:28 <xlq> I have: test :: (a -> a) -> (Int, Float)
08:43:49 <mmorrow> hmm, what's the definition you have in mind for that?
08:44:02 <xlq> I'm just testing atm :) I have test f = (f 5, f 0.5)
08:44:12 <mmorrow> ah, ok
08:44:29 <quicksilver> xlq: well that *is* a higher rank type, so doubt you can do without the extension.
08:44:38 <mmorrow> , let test :: (a -> a) -> (Int, Float); test f = (f 5, f 5.0) in test id
08:44:39 <lunabot>  luna: Couldn't match expected type `GHC.Types.Float'
08:44:42 <xlq> ohh
08:44:52 <mmorrow> yeah, i think you need the rankn
08:45:29 <mmorrow> @type [id, id::(forall a.a->a)]
08:45:30 <lambdabot> forall a. [a -> a]
08:45:34 <mmorrow> grr
08:46:02 <quicksilver> that's impredicative, not just high-rank
08:46:43 <ksf> polymorphism isn't first-class in haskell.
08:47:16 <ksf> ...if it were, we could be coding lisp, after all.
08:58:20 <ClaudiusMaximus> what's the story with package 'ghc-prim'? it's apparently required by OpenGLRaw, but ghc-prim is neither cabal installable nor supplied with Lenny's ghc 6.8.2 ; is it safe to download a random version from the interwebs?  i note that i can do  :m + GHC.Prim   in ghci with no errors...
08:58:54 <quicksilver> in 6.8.2 it was part of base
08:59:02 <quicksilver> in some other version it might be a package of its own
08:59:15 <Saizan> and it's shipped with ghc
09:00:09 <ClaudiusMaximus> ok, so i guess i need to patch OpenGLRaw's .cabal file to remove/alter the dependency?
09:00:15 <ClaudiusMaximus> or would that lead to world of pain
09:00:21 * ClaudiusMaximus tries
09:00:41 <dcoutts> ClaudiusMaximus: you'd be lucky if it works
09:01:39 <ClaudiusMaximus> well, i can't even "cabal fetch" it to patch it - unresolvable dependencies
09:02:39 <Saizan> ClaudiusMaximus: "cabal unpack" it
09:02:57 <ClaudiusMaximus> Saizan: aha
09:02:59 <ClaudiusMaximus> thanks
09:08:19 <ClaudiusMaximus> dcoutts: well, it compiled and installed ok, will try using it to see if it explodes :)
09:08:41 <etpace> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9398#a9398 Hey fellas, Im folding through a list of chronological events, and I want to shortcircuit out if the earliest event is later than the current best, how do I do so? my current step function is quite ghastly
09:09:37 <dcoutts> ClaudiusMaximus: oh, if it compiled you'll be ok
09:11:22 <ClaudiusMaximus> dcoutts: hmm, however 'cabal install GLUT' complains about OpenGLRaw's dependency on ghc-prim despite having just installed that version by hand
09:12:11 * Phyx- wonders when they'll be a ghc 10.4 compatible install for gtk2hs :P
09:14:21 <Vulpyne> etpace: Don't fold and do the recursion manually?
09:14:36 <etpace> I think that might be the case
09:15:24 <Saizan> ClaudiusMaximus: that's because cabal tries reconfiguring it, you should bump the version when you modify a .cabal package
09:15:28 <Vulpyne> There's unfoldr but I don't know if that would be efficient in this case.
09:15:32 <Vulpyne> :t unfoldr
09:15:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:15:49 <ClaudiusMaximus> Saizan: i see
09:19:55 <dcoutts> Phyx-: do you mean a windows installer?
09:20:47 <dcoutts> Phyx-: if you mean windows, I did a minimal build, if you don't mean windows then it builds from source fine using 6.10.4
09:21:31 <dcoutts> http://haskell.org/~duncan/gtk2hs/gtk2hs-0.10.1-win32-installer.exe
09:21:39 <Phyx-> dcoutts: yeah, i mean windows
09:21:42 <Phyx-> ohh
09:21:44 <Phyx-> lemme try
09:25:32 <ClaudiusMaximus> @hoogle mapAccumL
09:25:32 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
09:25:32 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:25:32 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
09:25:44 <Phyx-> dcoutts: ah, thanks, that works :)
09:27:46 <ClaudiusMaximus> Data.Traversable here doesn't seem to have mapAccumL, seems i need a newer package base :(
09:28:22 <quicksilver> ClaudiusMaximus: you can always mapM a state monad instead.
09:28:33 <quicksilver> mapAccumL is just mapM for the state monad, unwrapped.
09:30:49 * Phyx- can work on his game again
09:32:04 <ClaudiusMaximus> quicksilver: sure - but i can't backport things from base for every package i want to cabal install - i think i should get just get a newer ghc...
09:32:31 <quicksilver> right. possibly so.
09:32:38 * quicksilver never cabal installs anything.
09:32:47 <quicksilver> using libraries is so much less fun than reinventing wheels!
09:32:56 <dcoutts> @slap quicksilver
09:32:56 * lambdabot is overcome by a sudden desire to hurt quicksilver
09:32:59 <leimy_> So the functional dependency engine of 6.10.4 GHC is pissing me off :-)
09:33:15 <leimy_> It's claiming my StateT's state is something it's not because of the use of "get" in one of my functions.
09:33:34 <leimy_> if I comment it out, it works great, but I can't for the life of me figure out how GHC thinks this is a list instead of Data.Map
09:33:58 <blackh> leimy_: I think that's a punishment for writing your function too long. :)
09:34:07 <leimy_> blackh: could be
09:34:23 <leimy_> blackh: I can break it down.... eliminate a case statement in a let clause
09:34:39 <leimy_> but I don't think it'll fix anything, because the way my code reads makes perfect sense (to me)
09:34:54 <blackh> I have had this problem many times before too - and I haven't found a simple remedy.
09:35:27 <leimy_> Oh well I'll try breaking it out.
09:35:32 <maltem> Hire an assistant? :)
09:35:46 <blackh> Actually this could be raised as a bug, because I think it might be possible to improve the compiler in this respect.  I'll file it at the back of my head.
09:36:14 <blackh> leimy_: Another approach is to go crazy replacing bits with undefined.
09:36:33 <Saizan> how does the code look?
09:36:40 <leimy_> blackh: oh?
09:37:09 <leimy_> it's a get in a StateT (exactly like another get I use in another function that doesn't get it wrong)
09:37:27 <leimy_> followed by an evaluation of the functions arguments, to determine how to update a record of several fields
09:37:33 <leimy_> all in a big "let"
09:37:44 <leimy_> then I update the map with this record.
09:38:01 <leimy_> and put the new map back
09:38:09 <Saizan> can you paste it?
09:38:21 <leimy_> Saizan: maybe... it won't make sense out of context
09:38:26 <leimy_> or maybe it will
09:39:14 <leimy_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3619#a3619
09:39:53 <leimy_> My State is a pair of list of strings and a Data.Map Int OutletRecord
09:40:59 <Saizan> leimy_: is that lookup Data.Map.lookup or Data.List.lookup ?
09:41:00 <leimy_> I'm basically screen-scraping a SMASH CLP console on a power strip :-)
09:41:14 <leimy_> Saizan: wow, not ambiguous either!
09:41:24 <leimy_> because I qualified it as  M.lookup
09:41:27 <leimy_> shit!
09:41:29 <leimy_> thanks! :-)
09:41:33 <Saizan> np :)
09:41:43 <leimy_> the compiler was complaining about the "get" line so I wasted a ton of time there.
09:41:58 * leimy_ didn't even know there was a list lookup
09:42:26 <leimy_> and now it compiles...   thanks!
09:42:29 <coco> I want to have two data types: one for expressions with variables, addition, and multiplication; and a second one with Sin and Cos in addition -- and then parse both with parsec
09:42:47 <coco> is there an elegant way to do this?
09:42:59 <coco> maybe without two different data constructors for addition...
09:43:19 <coco> something like OCaml's variant types
09:43:26 <leimy_> This is one of those moments where I hate overloaded function names
09:43:41 <leimy_> and decide that any language that has them, didn't understand the problem they wanted to solve by having them.
09:43:59 <leimy_> Just lost 2 hours on that :-(
09:44:01 <leimy_> damnit
09:45:41 <Saizan> leimy_: well, this is also a problem in general with type inference, the error might not actually be where it's discovered
09:46:19 <Saizan> sometimes you need to run the algorithm in your head to see how it could get such conclusions
09:46:38 <leimy_> Saizan: Well if I have to choose between this kind of error and the crap that comes out of g++ with a template issue, I'll take this
09:46:58 <leimy_> Saizan:  I did do that, however, I kept somehow mentally inserting the M.lookup for lookup.
09:47:11 <leimy_> meaning I've had my head in this code too long
09:47:14 <leimy_> need to take a break.
09:48:08 <Saizan> coco: we don't have variant types, you could embed one type in the other with an apposite constructor though
09:48:33 <Saizan> there are actually many different ways to "solve" this
09:49:49 <Saizan> the simpler is data Expr1 = Add .. | Mul .. | Var ..; data Expr2 = Sin .. | Cos .. | Other Expr1, i think
09:50:29 <leimy_> Ooh
09:50:34 <Saizan> a more sophisticated one is described in Data Types a la Carte
09:50:47 <leimy_> Tim Newsham just sent me some code the other day for embedding a variant type in another for a Haskell 9p implementation.
09:50:55 <leimy_> http://code.google.com/p/9ph
09:51:10 <leimy_> http://code.google.com/p/9ph/source/browse/NineP.hs
09:51:18 <leimy_> see "VarMsg"
09:51:31 <Saizan> what's 9p?
09:51:33 <leimy_> It gets embedded in "Msg"
09:51:44 <leimy_> Saizan: A decent,  fairly small, and sane remote filesystem protocol
09:51:57 <leimy_> Originated in one of the later Unixes, but is mostly used in Plan 9 and Inferno.
09:52:11 <leimy_> it's also supported on Linux via v9fs kernel modules (mainline kernel has it), and FUSE 9p
09:52:24 <leimy_> It's somewhat unique in that you can export devices over it.
09:52:36 <leimy_> I know folks that use it to stream audio around their house too.
09:53:20 <Saizan> that's another kind of embedding though
09:53:25 <Saizan> iiuc
09:53:51 <leimy_> well this lets you cram a bunch of possible message types into a generic message type.
09:54:03 <Saizan> VarMsg there is just a field of Msg
09:54:22 <Saizan> you've factored out the common parts into Msg, i guess
09:54:37 <leimy_> Right but if you look at VarMsg's stuff, it's got many different multi-field constructor types
09:54:40 <leimy_> ADT?
09:54:58 <leimy_> Anyway, this is Tim's code :-)
09:55:01 <leimy_> I've been studying it.
09:55:11 <leimy_> and trying to use it but I think the Tversion message is incorrect.
09:55:38 <Saizan> for Expr one could have data Expr b u = BinOp b (Expr b u) (Expr b u) | UnaryOp u (Expr b u) | ..
09:55:51 <Saizan> and then instantate it with different enumeration types
10:02:10 <leimy_> So, what's the #1 reason not to replace String with ByteString in GHC by default, and use a wider String when necessary?
10:02:19 <leimy_> is it because people like to code with Strings as lists?
10:03:41 <tommd> I think so
10:04:09 <tommd> Lists are easy and natural to work with... also String (Char) supports unicode in a somewhat straight forward manner... Bytestring is just bytes.
10:06:16 <leimy_> It just seems [Char] is awfully inefficient ;-)
10:06:22 <leimy_> for a baseline
10:06:32 * Zao pets Data.Text
10:06:42 <Zao> Ninja efficient and cute.
10:07:16 <Zao> Addressing individual codepoints is quite nice, something which ByteString isn't built for.
10:09:40 <RayNbow> dons: awesome link about the Dutch flag you posted to the Haskell reddit :)
10:10:12 <dayz> i got a slightly irrelevant question, which is about complexity: how come NP is defined to be "More precisely, these proofs have to be verifiable in polynomial time by a deterministic Turing machine." and "NP is the set of decision problems solvable in polynomial time by a non-deterministic Turing machine." in the wikipedia entry? how are they equivalent when one says it's a deterministic Turing machine while another is a non-deterministic one?
10:12:40 <Lycurgus> dayz, you may find the current Communications of the ACM article on this more reliable/useful.
10:13:06 <Lycurgus> wikipedia is subject to the madness of crowds
10:13:23 <lament> Tragedy of the Creative Commons
10:13:25 <Lycurgus> as well as their wisdom
10:13:27 <azm> all depends on if the easter bunny is pink or green.
10:13:50 <RayNbow> dayz: do you have Sipser's Introduction to the Theory of Computation?
10:14:56 * Phyx- takes a peak in here and finds talk about the easter bunny
10:15:08 <Phyx-> what, did he distribute the eggs using mapM or something
10:15:11 <dayz> Lycurgus, but i think i can see why and the entry is correct. In the first line, it says it's *verifiable* in polynomial time by a deterministic Turing machine, while the second says it's *solvable* in polynomial time by a non-deterministic Turing machine.
10:15:17 <dayz> RayNbow, no I don't.
10:16:26 <RayNbow> dayz: it's the textbook I had to use at my university, it's a good book imo
10:16:29 <dayz> but how come a problem that can be verified in polynomial time with a deterministic Turing machine solvable in polynomial time in a non-deterministic one?
10:16:31 <ziman> if your problem has a proof/certificate verifiable in P on a DTM, then it is in NP because a NTM can nondeterministically `guess' the certificate (in polynomial time) and verify it (in polynomial time).
10:16:53 <PeakerWork> dayz: basically, NP means that *given* a solution, you can check if its right with P on a normal TM.  But to actually solve it, you need either NP time, or P time on a non-deterministic TM
10:16:55 <dayz> ziman, but how come?
10:17:09 <PeakerWork> dayz: with P time that, is
10:17:33 <dayz> how come a NTM can guess the solution in polynomial time?
10:18:36 <PeakerWork> dayz: non-deterministic Turing Machine, iiuc, can try out all the solutions at the same time. I'm not sure I understand this correctly, though
10:19:18 <ziman> well, `guessing' is a way to look at the problem; you can imagine the computation going in parallel all sorts of ways, each futile branch dying at some point -- and if a branch survives until after verification, the problem is solved.
10:19:46 <benmachine> or you could just view it as a machine that is very very lucky
10:20:26 <RayNbow> dayz, do you know what NFAs are? (simpler machines than Turing machines)
10:21:29 <ziman> you may want to read up on non-deterministic finite state machines, which are less complex than NTMs; nondeterminism is quite simple to imagine there
10:25:54 <dayz> ooh, so the computation is in parallel?
10:26:23 <ziman> not necessarily. it need not be carried out in parallel
10:27:57 <ziman> You can simulate a nondeterministic computation on a deterministic machine by (depth-first or breadth-first or else) searching the state tree. But regarding it as a parallel process is quite natural.
10:28:15 <lament> a parallel process of unbounded "width"?
10:28:26 <lament> i want a CPU like that
10:28:31 <ziman> me too ;)
10:28:51 <c_wraith> Isn't that the concept behind quantum computing?
10:28:54 <lament> it is
10:28:56 <c_wraith> Try everything in parallel?
10:29:26 <Beelsebob> c_wraith: yes, but also no, you are still limited by the number of qbits you can deal with
10:29:28 <ziman> > let die = fail "" in do { x <- [1..10]; y <- [1..10]; when (x*y /= 12) die; return (x,y) }
10:29:29 <lambdabot>   [(2,6),(3,4),(4,3),(6,2)]
10:29:59 <PeakerWork> ziman: why reimplement guard?
10:30:06 <tibbe> @seen kolmodin
10:30:06 <lambdabot> Unknown command, try @list
10:30:12 <PeakerWork> ziman: your away script is responding
10:30:18 <ziman> i wanted explicit "die" to cut off the branches
10:30:35 <ziman> yes, i already should have been away, sorry :)
10:30:48 <c_wraith> tibbe: ask preflex
10:31:01 <tibbe> c_wraith: syntax?
10:31:01 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
10:31:10 <c_wraith> preflex: seen kolmodin
10:31:10 <preflex>  kolmodin was last seen on #haskell 4 days, 18 hours, 49 minutes and 3 seconds ago, saying: Igloo: code.haskell.org seems to not be responding
10:31:43 <tibbe> c_wraith: thanks
10:33:53 <bos> it's kind of amazing to be using IRC at 35,000 feet
10:34:22 <c_wraith> what airline?
10:34:34 <c_wraith> And how much are they charging?
10:34:54 <PeakerWork> ziman: "die" is misleading IMO :)
10:35:10 <lament> it means "the" in german
10:35:20 <c_wraith> I agree.  When I see "die" in code, I think php or perl, where it means "terminate the whole program now"
10:35:36 <dancor> it'll be cooler at 400 Mm
10:36:06 <bos> c_wraith: virgin america
10:36:13 <bos> it's about USD13
10:36:31 <c_wraith> I'm not sure I could make myself pay that much.  I'm a cheapskate.
10:37:42 <dancor> well maybe not, 400 Mm is over a second of light-lag each way
10:38:01 <lament> c_wraith: you could be like my probability professor, and disambiguate by calling a singular die "dice"
10:38:06 <lament> c_wraith: but then i'd have to kill you
10:38:28 <dancor> the heigth of a dice
10:38:33 <c_wraith> I'm an old-school gamer.  I call dice "dN". :)
10:38:37 <bos> c_wraith: my employers are paying, so it's all the same to me
10:38:42 <c_wraith> "hand me that d6".  etc.
10:39:10 <FunctorSalad> @ping bos
10:39:10 <lambdabot> pong
10:43:24 <c_wraith> * Ping reply from bos: 28.08 second(s) | airline internet seems to not be low-latency
10:43:57 <copumpkin> wow
10:44:03 <bos> yeah, it's misbehaving pretty badly right now. it was working great until a minute or three ago.
10:52:16 <dylanmc> has anyone here built @tommd's Linux Kernel Module thingy?
10:56:01 * DrSyzygy had over 80s ping reply at his hotel in Prague.
10:58:09 <pchiusano> one of my coworkers asked me for a good reference on functional programming... he is an experienced programmer but doesn't have any FP experience, what do you guys think is a good reference
10:58:46 <pchiusano> not necessarily Haskell specific
10:59:35 <pchiusano> I was thinking the Haskell wikibook, but I think that's a bit too expository
11:00:37 <jmcarthur_work> RWH? YAHT?
11:00:43 <tommd> dylanmc: I have
11:01:01 <jmcarthur_work> not sure really what is meant by reference, maybe
11:02:09 <tommd> jmcarthur: I enjoyed YAHT - and I came from a C world.  Though some parts were minorly annoying - such as an exercise that required the use of "show" which is a function from a typeclass and I didn't know about 'show' or typeclasses at that point in the tutorial.
11:02:25 <pchiusano> i am looking for something that concisely introduces the concepts, without too much ceremony
11:02:43 <tommd> Oh, I ment to address you, pchiusano, in the above.
11:03:01 <c_wraith> the concepts aren't too hard, though.  The trick is getting some experience using them.
11:03:02 <Saizan_> pchiusano: SICP, maybe?
11:03:15 <pchiusano> not SICP
11:04:24 <jmcarthur_work> i learned a lot from YAHT, but didn't find it very motivating. i think RWH would serve well
11:05:20 <jmcarthur_work> both suffer a little from dependent concepts being a little out of order though, i think
11:05:33 <pchiusano> jmcarthur_work: can you elaborate?
11:07:38 <tibbe> is there an operational semantics for case and let pattern matching somewhere? i.e. why does "case x of (a,b) -> ..." force x but "let (a,b) = x in ..." doesn't?
11:07:52 <jmcarthur_work> pchiusano, on YAHT vs. RWH or on the dependent concepts?
11:08:18 <pchiusano> jmcarthur_work: well, i was wondering specifically about dependent concepts
11:08:32 <Saizan_> tibbe: let (a,b) = x in .. is the same as case x of ~(a,b) -> .., if it helps
11:08:38 <jmcarthur_work> pchiusano, i just meant that some of the examples in both use ideas that are not introduced until later
11:08:47 <Saizan_> tibbe: however i'd guess the report has the definitions
11:08:50 <jmcarthur_work> pchiusano, it's mostly hearsay, but i have seen a lot of people complain
11:09:01 <jmcarthur_work> i skimmed too much to notice, personally
11:09:03 <tibbe> Saizan_: tried to find it in the report but it's a bit unwieldy
11:11:01 <fusion5> hi, is there a function to return the number of occurrences of an element in a list?
11:11:09 <tibbe> Saizan_: I guess another way to put it is: why isn't case ~(x, y) the default in a lazy language?
11:11:42 <Saizan_> tibbe: because that's inconsistent with the behaviour that you get when you add more than one pattern
11:12:42 <tibbe> Saizan_: because you would always pick the first?
11:12:47 <Saizan_> though lambdas, which can only have one pattern like lets, have the same behaviour as case
11:12:53 <Saizan_> tibbe: yeah
11:13:00 <tibbe> Saizan_: so in fact it's an error to have more than one pattern if the first one is ~
11:13:21 <tibbe> Saizan_: but you can use ~ in lambdas?
11:13:32 <Saizan_> tibbe: yes, and yes
11:13:55 <c_wraith> do irrefutable patterns work more efficiently?
11:13:59 <tibbe> Saizan_: hmm, makes sense
11:14:20 <gwern> @src []
11:14:20 <lambdabot> data [] a = [] | a : [a]
11:14:48 <Saizan_> c_wraith: it depends, they are lazier, so potentially introduce more indirection, but the extra strictness can cause problems too
11:15:10 <maltem> What is statevar good for? Is it just meant for read-only, or write-only, IORefs?
11:16:03 <Saizan_> > foldr (\(a,b) (as,bs) -> (a:as,b:bs)) ([],[]) (zip [1..] [1..])
11:16:04 <lambdabot>   * Exception: stack overflow
11:16:09 <Saizan_> > foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[]) (zip [1..] [1..])
11:16:10 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:16:42 <Saizan_> maltem: statevar?
11:17:09 <|Steve|> What does ~ do?
11:17:40 <Saizan_> it delays the pattern matching until the matched vars are needed
11:18:07 <Saizan_> > case undefined of ~(Just x) -> ()
11:18:08 <lambdabot>   ()
11:18:10 <Saizan_> > case undefined of ~(Just x) -> x
11:18:11 <lambdabot>   * Exception: Prelude.undefined
11:18:14 <maltem> Saizan_, it's on hackage and evolved from the opengl package (and I'm wondering why)
11:18:30 <Saizan_> @hackage statevar
11:18:30 <lambdabot> http://hackage.haskell.org/package/statevar
11:18:35 <gwern> I'm finding 'data [] a = [] | a : [a]' a little confusing. what does that look like without the builtins?
11:19:20 <tromp> data List a = Nil | Cons a (List a)
11:19:28 <c_wraith> data List a = Empty | Cons a (List a)
11:19:33 <c_wraith> bah.  beaten to it. :)
11:20:05 <gwern> hm. oh, that's what I'm doing wrong
11:20:13 * gwern had 'data List a = Nil | List a (List a)'
11:20:47 <Saizan_> that's legit
11:21:02 <Saizan_> you'd have to build lists like List 1 (List 2 Nil)
11:21:48 <gwern> hm. well, cons is traditional, so I'll stick with that
11:23:12 * c_wraith considers a polically-incorrect joke about the traditional being conth
11:24:36 <pchiusano> jmcarthur_work: i see
11:30:33 <gjl> Which of the shells with an Haskell based scripting language is most fully featured and stable (i.e. which is most worth using as a full-time replacement for say bash/zsh)?
11:30:57 <sinelaw> in GHC, hsSyn, what's a "bang pattern"?
11:32:26 <maltem> sinelaw: In Haskell, a bang pattern is the syntax f !x = y -- the excl. mark being called the bang
11:33:00 <sinelaw> what does that do? i'm a syntax noob
11:33:27 <benmachine> exclamation marks are usually strictifying
11:33:29 <maltem> it means f x = x `seq` y
11:33:35 <benmachine> yeah
11:33:58 <pacopil> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
11:34:09 <PeakerWork> sinelaw: f is strict w.r.t x. It will force x before evaluating the body (rhs of =)
11:34:21 <maltem> sinelaw: that means, f x = _|_ if x equals _|_, y otherwise
11:34:28 <sinelaw> ok
11:34:33 <PeakerWork> sinelaw: force it to WHNF (Weak Head Normal Form), which is a fancy way of saying it forces it "one level deep" (choosing only the top-level data constructor)
11:35:03 <maltem> heh, three different explanations for strictness annotations
11:35:38 <sinelaw> hsSyn is translated directly into core or is there an intermediate language?
11:35:42 <Veinor> what is this _|_ witchery
11:36:06 <c_wraith> the wikibooks page on it is really good, actually
11:36:07 <sinelaw> ok, this explains it: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain
11:36:37 <c_wraith> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
11:40:10 <gjl> I see quite a few projects developing an Haskell shell but they all seem to be alpha-grade. Is there anything that's suitable as a full-time replacement for bash?
11:43:43 <Saizan_> gjl: i don't think any of them has seen much use yet
11:44:17 <Phyx-> Do any of then really add anything except for being written in haskell?
11:44:29 <Phyx-> them*
11:46:23 <gjl> Some are a bit more ambitious than that. For instance, this project is aiming to turn Haskell into a shell scripting language: http://www.haskell.org/hashell/
11:46:34 <Raevel> i can has hell?
11:47:23 <lament> gjl: whenever you get a shiny new hammer, there's a certain urge to try to use it as a screwdriver
11:48:04 <gjl> heh
11:48:09 <Rotaerk> lament, don't you have it the other way around
11:48:30 <Veinor> nah, because you can use a screwdriver as a hammer
11:48:41 <Veinor> you just take the plastic grippy part and smack it into whatever
11:48:44 <Rotaerk> precisely why there's such an urge :P
11:49:05 <gjl> I have found cause to do this on occasions
11:49:48 <roconnor> one of the graphs on that Denotational_semantics wikibook page is in error
11:49:56 <lament> the only legitimate cause is "not having an actual screwdriver handy"
11:50:09 <Veinor> roconnor: {{sofixit}} :D
11:50:22 <Veinor> or is that template only on en-wiki? I wonder.
11:50:48 <roconnor> http://en.wikibooks.org/wiki/File:List-graph.png
11:50:56 <Veinor> no, it's on wikibooks.
11:50:56 <roconnor> this is the graph in error
11:51:09 <roconnor> They put ():_|_ above ():[]
11:51:40 <roconnor> and it really should link up with the existing ():[] on the far right.
11:51:52 <Veinor> oh _|_ is bottom
11:52:06 <roconnor> actually
11:52:17 <roconnor> basically the entire graph is wrong
11:52:24 <roconnor> it'd be simpler to list the things that are right.
11:52:24 <c_wraith> it's a wikibook
11:52:26 <c_wraith> fix it. :)
11:52:53 <roconnor> external editors are too much of a pain for me to bother setting up
11:53:34 <roconnor> @seen dhouse
11:53:34 <lambdabot> Unknown command, try @list
11:53:42 <roconnor> preflex: seen dhouse
11:53:42 <preflex>  Sorry, I haven't seen dhouse
11:57:54 <roconnor> preflex: seen dmhouse
11:57:54 <preflex>  dmhouse was last seen on ##c 28 days, 21 hours, 40 minutes and 32 seconds ago, saying: Rajko: what exactly are you trying to do?
12:00:16 <sinelaw> preflex: seen preflex
12:00:17 <preflex>  what
12:19:16 <greb> hi
12:19:23 <c_wraith> hello
12:20:00 <Baughn> http://www.girlgeniusonline.com/comic.php?date=20070725 <-- Hm. I think this comic should be linked from the unsafePerformIO page; it's disturbingly on-the-spot.
12:22:41 <Saizan_> Baughn: hacking on reactive is that painful?:)
12:22:47 <Baughn> Saizan_: YES
12:22:57 <Baughn> Saizan_: GHC has a sense of humor, as I discovered an hour ago
12:23:12 <benmachine> @quote ghc
12:23:12 <lambdabot> ghc says: More than one type pattern for a single generic type constructor
12:23:16 <Baughn> Saizan_: ..I found another ghc bug. Fixed in 6.11, though
12:23:49 <p_l> Baughn: at least you have legitimate reasons... Cells make one disillusioned fast...
12:24:45 <Baughn> Saizan_: http://www.haskell.org/pipermail/haskell-cafe/2009-September/066378.html <- Although, my inspiration for that claim was this post
12:24:46 <PeakerWork> Baughn: my brain exploded, for example?
12:24:58 <Baughn> PeakerWork: I don't know. Did it?
12:25:18 <Baughn> PeakerWork: GHC's didn't. Instead, it decided to make all calls to getTime return the same value.
12:25:29 <benmachine> heh
12:25:30 <benmachine> "now"
12:25:40 <PeakerWork> Baughn: the existential error about brain explosion :)
12:25:42 <Baughn> benmachine: "1900:0:0:0:0"
12:26:04 <Baughn> PeakerWork: http://cdsmith.wordpress.com/2009/09/14/on-inverses-of-haskell-functions/ <-- On a better note. Did you catch this link?
12:26:12 <Baughn> ISTR you were interested in that sort of thing
12:26:31 <PeakerWork> Baughn: didn't read it yet
12:26:40 <PeakerWork> Baughn: I'm interesting in bidirectional functions/etc, yeah
12:30:17 <Saizan_> Baughn: i'm not sure i see the connection with that post
12:31:19 <Baughn> Saizan_: He wanted to use unsafePerformIO for something best done by lazy I/O (or, rather, bytestring-mmap)
12:31:37 <Baughn> ..such a big, nifty hammer. Pity it's got glass shards in the handle.
12:33:11 <Saizan_> not that lazy I/O is much safer :)
12:33:27 <Saizan_> in fact withFile and hGetContents don't mix that way
12:33:46 <Baughn> Oh. Oh dear; I didn't notice that use.
12:34:20 <Baughn> Saizan_: ..pointing that out
12:34:22 <camio> Are there any known problems with "cabal upgrade pkgname"? It doesn't seem to work for me.
12:34:32 <Baughn> camio: Several, quite fundamental ones
12:34:55 <Baughn> camio: The easiest solution seems to be to wipe ~/.ghc and reinstall. Bit heavy-handed, though..
12:34:59 <dcoutts> camio: what kind of "not work" ?
12:35:02 <Saizan_> camio: just do "cabal install pkgname" if you want the latest version of pkgname
12:35:16 <Baughn> camio: The *proper* one is to explicitly cabal-install the pkg, then cabal-install every package that depends on it, and so on
12:35:51 <camio> Saizan: When I do "cabal install" on HaXml, it says it is already installed.
12:36:03 <camio> I get the same output with cabal upgrade HaXml.
12:36:06 <dcoutts> camio: that's probably because it is :-)
12:36:16 <camio> Yeah, I know that.
12:36:25 <camio> When I do --reinstall it doesn't fetch the latest version.
12:36:28 <benmachine> could this be to do with the recommended versus latest version?
12:36:30 <dcoutts> camio: if what you want is haxml >= 1.19 then say so, the default is 1.13
12:36:43 <benmachine> I found with parsec that if I wanted 3.0.1 I had to say that exactly
12:36:57 <dcoutts> benmachine: exact is not necessary, >= 3 would do
12:37:08 <benmachine> dcoutts: that'd get 3.0.0 wouldn't it?
12:37:13 <benmachine> or would it
12:37:15 <dcoutts> benmachine: nope
12:37:20 <benmachine> ah, okay
12:37:51 <dcoutts> benmachine: the preferred version of parsec is < 3
12:37:54 <camio> dcoutts: Where is the "default" concept coming from?
12:38:08 <dcoutts> camio: from information from hackage
12:38:29 <dcoutts> camio: you can add your own preferences too, though currently only on the command line --preference=""
12:39:25 <camio> dcoutts: I'm having trouble finding something mentioning default on hackage.
12:42:01 <dcoutts> camio: unfortunately the individual package pages do not reflect that info at the moment
12:44:04 <camio> Okay, thanks for the help. Hopefully that'll get fixed soon.
12:45:38 <dcoutts> camio: it'll get fixed quicker if you send patches :-)
12:47:20 <camio> I'll stick to contributing blog posts and complaints for now ;-).
12:48:38 <weirdo> hey
12:48:47 <weirdo> anything i can do to make haskell-mode indent properly?
12:48:49 <Raevel> hey
12:48:54 <weirdo> reindent-newline-then-reindent indents badly
12:49:00 <weirdo> because of indentation "cycling"
12:49:13 <weirdo> can i reindent without "cycling"?
12:49:29 <weirdo> or should i ask this way, what do you use for writing haskell code, if not emacs/
12:49:34 <g0ju> hi, is anyone of you using xmonad with archlinux?
12:50:11 <cygnus> weirdo: I use emacs, but I've just gotten used to haskell-mode's psychotic indentation behavior by now. :)
12:50:21 <Baughn> weirdo: Try using haskell-indentation instead of haskell-indent or haskell-simple-indent
12:52:18 <mauke> weirdo: I use vim
12:52:25 <weirdo> :|
12:54:00 <weirdo> it appears that unlike other progmodes in emacs, haskell has to be indented semi-manually
12:54:33 <Baughn> weirdo: Yes. Main problem is that haskell's indentation actually /matters/; you get different valid programs depending on indentation level.
12:54:53 <Baughn> weirdo: Still, Kristof Bastiaensen's indentation module is a lot better than the default one
12:54:57 <Baughn> ..most of the time
12:55:14 <Raevel> i don't like bouncy indent
12:56:00 <b0ef> "Haskell does not have an unambiguous indentation system" - rolf
12:56:03 <weirdo> what's your stance toward liskell?
12:56:06 <b0ef> weren't you supposed to be so god damn smart?
12:56:29 <mauke> b0ef: what?
12:56:46 <weirdo> with sexps i rule, turning graphs inside out with just a few keypresses
12:57:13 <b0ef> mauke: well, it seems it's quite difficult to indent haskell properly; it's ambiguous
12:57:29 <b0ef> trying to indent pretty simple code in emacs seems to be impossible
12:57:42 <mauke> that sounds like "it's quite difficult to put parens in arithmetic expressions; it's ambiguous" to me
12:58:00 <mauke> I mean, just look at 2 + 3 * 4
12:58:17 <mauke> you could turn it into (2 + 3) * 4 or 2 + (3 * 4), or even 2 + ((3)) * 4!
12:58:22 <copumpkin> b0ef: ?
12:59:04 <b0ef> http://www.esben-stien.name/signum.hs
12:59:37 <copumpkin> not sure I'd call either of them correct
12:59:40 <mauke> yeah
12:59:41 <copumpkin> and why are you using c++ comments?
12:59:53 <mauke> both are valid code
12:59:58 <mauke> the rest is style
13:00:06 <b0ef> copumpkin: well, I just did that now in a hurry;)
13:00:13 <copumpkin> I tend to avoid if blocks altogether if I can
13:00:17 <copumpkin> (which is almost always)
13:00:26 <b0ef> mauke: well, it doesn't look very readable that emacs way
13:00:37 <mauke> b0ef: to you maybe
13:01:04 <c_wraith> haskell-mode's indentation gets a couple cases wrong.  But most of the time, it's fine
13:01:17 <b0ef> well, besides that; every time I hit enter, it switches between several options, so it's ambiguous in any sense of the word
13:01:23 <Baughn> It could do a lot better by using contextual information
13:01:32 <c_wraith> most notably, it gets if blocks inside of do blocks wrong
13:01:33 <mauke> b0ef: see my example with 2 + 3 * 4 above
13:01:34 <b0ef> s/enter/tab/
13:01:47 <PeakerWork> @index when
13:01:47 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:02:12 <b0ef> mauke: well, we do like to follow internation standards for mathematics notaion;)
13:02:14 <copumpkin> Baughn: contextual information such as your indentation style in the rest of the file? that'd be nice
13:02:22 <b0ef> s/internation/international/
13:02:24 <Baughn> copumpkin: That.. /would/ be nice
13:02:27 <b0ef> damn
13:02:33 <b0ef> s/notaion/notation/
13:02:35 <Baughn> copumpkin: But I was thinking of things such as the types of functions
13:02:40 <mauke> b0ef: which one is the international standard? 2 + (3 * 4) or (2 + 3) * 4?
13:03:13 <b0ef> it's called precedence in international standard, NS31
13:03:22 <mauke> which one?
13:03:51 <b0ef> * has higher precedence, so it's 2 + (3*4)
13:03:57 <mauke> wrong!
13:04:00 <mauke> I meant (2 + 3) * 4
13:04:05 <mauke> mathematics is stupid
13:04:08 <c_wraith> b0ef, when it gives you a tab cycle, that's not *ambiguous*.  It's that the different levels have different meansing.
13:04:11 <c_wraith> *meanings
13:05:01 <b0ef> right, and I hate this;) - well, I'm pretty new to haskell, but this seems horrible;)
13:05:10 <c_wraith> Then use {} everywhere
13:05:22 <b0ef> yeah, just looked at that
13:05:35 <c_wraith> but it results in ugly code, most of the time
13:05:48 <mauke> well, you can either use {} and have your editor deduce the right indentation, or you can indent your code
13:06:17 <b0ef> well, if you look at my example in the url, that "correct" way is not an option for me in emacs
13:06:19 <copumpkin> b0ef: it honestly isn't that hard :P especially if you avoid if blocks, which I agree have nonintuitive indentation rules in some contexts
13:06:26 <b0ef> meaning, it doesn't present this option in the tab cycle
13:06:33 <c_wraith> The thing is, for the sake of visual consistency, if you use {}, you still want to indent.
13:06:38 <mauke> not my problem, I don't use emacs :-)
13:06:39 <c_wraith> And that means you have redundant information
13:06:44 <sunrayser> can anyone think of any reason why a haskell program doesn't compile with "ghc" if it loads fine with "ghci"?
13:06:54 <mauke> sunrayser: error message?
13:07:04 <c_wraith> I'm betting libgmp is the problem
13:07:10 <c_wraith> but yes, what's the error message?
13:07:11 <sunrayser> mauke: (.data+0xc8): undefined reference to `ghczmpathszm0zi1zi0zi5_GHCziPaths_libdir_closure'
13:07:21 <copumpkin> preflex: zdec ghczmpathszm0zi1zi0zi5_GHCziPaths_libdir_closure
13:07:22 <preflex>  ghc-paths-0.1.0.5_GHC.Paths_libdir_closure
13:07:22 <mauke> sunrayser: try ghc --make
13:07:38 <c_wraith> Oh, right.  that, too
13:08:08 <sunrayser> mauke: wow that worked thanks
13:08:19 <bavardage> how do I read an integer, catching if something silly is intered
13:08:21 <bavardage> *entered
13:08:27 <mauke> :t reads
13:08:30 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:09:08 <bavardage> oh kk
13:09:11 <mauke> readm :: (Read a) => String -> Maybe a; readm s = case reads s of [(x, "")] -> Just x; _ -> Nothing
13:10:20 <Alpounet> edwardk, ping
13:14:50 <b0ef> right, I think I misread that code
13:14:57 <b0ef> http://www.esben-stien.name/signum.hs
13:15:05 <b0ef> looking at it like this makes sense;)
13:15:14 <b0ef> as else-if is a new block
13:15:25 <mauke> those { } look wrong
13:15:44 <b0ef> hmm
13:15:47 <Tordek> hi
13:15:55 <mauke> but generally, formatting haskell is less about indentation and more about making things line up
13:16:39 <Tordek> I'm looking at building a haskell Breakout; where should I start looking?
13:17:06 <PeakerWork> Tordek: I just wrote one recently, cabal install breakout
13:17:34 <bos> dons: ping
13:22:50 <bos> huh, the inliner seems not to be inlining for me.
13:23:13 <kyagrd> Haskeline developer/maintainer here?
13:26:20 <bos> weird ghc inliner bug encountered. ooo-gah. ooo-gah.
13:26:36 <weirdo> does deforestation work for arbitrary code? the paper said it works for e.g. right folds. does it only work if the code uses the foldr higher-order function, deforestation having hardcoded support for foldr, or will it work too if someone wrote a function like my_foldr doing the same thing?
13:28:13 <sinelaw> check out my patch for GHC. added a warning for when a definition depends on the order of the patterns
13:28:47 <sinelaw> problem is, almost every definition pops it :)
13:28:59 <kyagrd> There was an announcement of new version of Haskeline, but unfortunately Unicode support still doesn't work properly, unlike what is stated in the announcment.
13:29:36 <kyagrd> Multibyte charset users still cannot live without readline, the only thing working, and even in ghc-6.12 multibyte input won't work properly.
13:30:02 <weirdo> is there eldoc/autodoc for haskell?
13:30:13 <mauke> yeah, that's why I'm still on 6.10.2
13:30:24 <gwern> weirdo: haddock?
13:30:35 <ClaudiusMaximus> weirdo: maybe RULES might have something to do with it? http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
13:31:43 <weirdo> what i want is showing argument lists for functions as i type them
13:31:54 <weirdo> the way it works for elisp/cl
13:32:16 <sinelaw> ok, here's my feature request:
13:33:11 <gwern> weirdo: well, yi and leksah can do things like show the type of a function point is on
13:33:17 <sinelaw> in addition to '_', i want a pattern that matches all the other constructors of the type (except for the ones mentioned explicitly in the other patterns)
13:33:21 <gwern> and type includes arguments, right?
13:33:44 <PeakerWork> sinelaw: there's the issue of recursive pattern matches
13:34:02 <PeakerWork> sinelaw: you can match Just (x:Nothing:xs)
13:34:04 <kyagrd> sinelaw: one way is to use template haskell for all that kind of strange things
13:34:07 <PeakerWork> sinelaw: then what does _ match?
13:34:50 <sinelaw> PeakerWork, it only looks at the top-level constructor
13:35:05 <sinelaw> at the "Just" in your case, and it adds: Maybe x
13:35:14 <PeakerWork> sinelaw: I don't think that's a good idea, and how would you use it for current uses of _ ?
13:35:26 <jmcarthur_work> i don't even understand the proposal yet
13:35:39 <sinelaw> it's not meant as a replacement of _
13:35:45 <mlesniak> PeakerWork, what graphics toolkit did you use?
13:35:51 <PeakerWork> mlesniak: SDL
13:36:09 <PeakerWork> sinelaw: I don't think the "top-level constructor" deserves that special status, I think that's confusing
13:36:14 <PeakerWork> sinelaw: the user sees patterns as wholes
13:36:16 <sinelaw> it's different: it matches everything, but it doesn't match the constructor you've used.
13:36:56 <sinelaw> hmm
13:37:14 <weirdo> can i make cabal automatically install programs?
13:37:20 <sinelaw> well, it should be useful for non-recursive patterns :)
13:37:24 <PeakerWork> weirdo: that's what cabal-install does
13:37:26 <gwern> weirdo: how do you mean?
13:37:54 <sinelaw> PeakerWork, the warning i've added is good for cases where you _think_ the order doesn't matter
13:38:00 <weirdo> gwern, satisfy dependencies recursively
13:38:06 <kyagrd> weirdo: you can specify dependency if that program is on hackage
13:38:16 <gwern> weirdo: yeah, that's cabal-install for yah
13:39:23 <PeakerWork> sinelaw: maybe it can be a totally different kind of pattern matching
13:39:49 <PeakerWork> weirdo: cabal update && cabal install something
13:39:52 <weirdo> but âcabal-installâ installs only a cabal executable, not a cabal-install executable
13:40:11 <weirdo> and cabal(1) doesn't satisfy dependencies
13:40:24 <gwern> weirdo: well, you have to start *somewhere*
13:40:35 <weirdo> take a look: http://paste.lisp.org/display/87122
13:40:46 <gwern> you have to manually install cabal-install, then you're fine
13:40:49 <weirdo> can't i just install all it requires automagically? :)
13:41:04 <dcoutts> weirdo: what it says is correct
13:41:10 <weirdo> but i typed 'cabal install cabal-install' and there's no cabal-install binary anywhere
13:41:25 <gwern> weirdo: because you haven't installed it!
13:41:29 <dcoutts> weirdo: the cabal-install package, provides an executable called 'cabal'
13:41:55 <gwern> cabal-install is not like anselm's god of the ontological proof, it doesn't necessarily create itself
13:42:08 <gwern> you have to actually install it before it can start doing anything
13:42:16 <sinelaw> PeakerWork, such as?
13:42:19 <dcoutts> gwern: sounds like he does have it installed
13:42:42 <PeakerWork> sinelaw: a different syntax which you use when you want the uniformity
13:42:44 <sinelaw> can I tell GHC to output Core?
13:42:46 <dcoutts> weirdo: the gtk packages are not on hackage yet, that's why it fails
13:42:48 <sereven> it looks like the issue is more that gtk2hs and other complex C stuff isn't cabal installable
13:42:52 <weirdo> oh
13:43:02 * gwern looks at the paste. ah, I see. what dcoutts said
13:43:12 <sinelaw> PeakerWork, that's a possibility
13:43:12 <PeakerWork> weirdo: cabal-install itself has to be installed with its boot strapper script
13:43:23 <dcoutts> PeakerWork: he does have it installed already
13:43:25 <PeakerWork> weirdo: once you have it (you can also get its binary, or inside the haskell platform), you can install stuff easily
13:43:27 <PeakerWork> oh
13:43:29 <PeakerWork> ok
13:43:50 <dcoutts> modulo confusion over the names "cabal" vs "cabal-install"
13:43:53 <weirdo> sfvo âeasilyâ :)
13:43:53 <sinelaw> anyway, this feature will provide a way to make sure your definitions are uniform
13:44:02 <sinelaw> which ensures the order of patterns doesn't matter
13:44:53 <sinelaw> and also makes it easier to optimize in the compiler, but maybe GHC already deals with it well
13:45:32 <sinelaw> any comments on my idea?
13:46:07 <mauke> it's disgusting
13:48:13 <sinelaw> don't push me, i have worse ones
13:49:23 <Berengal> Can anyone do me a favor and see if http://85.200.142.98:5000/quine.html is reachable?
13:49:31 <ehamberg> is there a good way to split a list into a list of sublists having length n?
13:49:36 <FunctorSalad> Berengal: is
13:49:36 <benmachine> Berengal: yeah
13:49:39 <Berengal> Nice
13:49:52 <Berengal> That just means I can't use my public ip to reach my own machine :/
13:50:52 <benmachine> not all that uncommon
13:51:02 <benmachine> the lesson is routers are really stupid.
13:51:05 <Berengal> I know, just wanted to make sure...
13:51:33 <Ferdirand> firewall gone wild ? or annoying nat setup maybe ?
13:51:39 <Saizan_> sigh, i want reverse nat too
13:52:00 <Berengal> Nah, my NAT is fine, or you wouldn't be able to reach me
13:52:34 <Berengal> Also, I can reach myself on the local network, just not from outside...
13:52:56 <benmachine> yeah I think some NATs get confused when you try to go out the same door you came in as it were
13:53:06 <benmachine> vice versa, even
13:53:13 <gwern> @hoogle Int -> [a] -> [[a]]
13:53:13 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
13:53:13 <lambdabot> Prelude drop :: Int -> [a] -> [a]
13:53:13 <lambdabot> Prelude take :: Int -> [a] -> [a]
13:53:30 <gwern> > replicateM 10 [1..10]
13:53:32 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,2],[1,1,1,1,1,1,1,1,1,3],[1,1,1,1...
13:53:41 <FunctorSalad> that looks like a bug
13:53:46 <gwern> > replicateM 5 [1..10]
13:53:46 <lambdabot>   [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,1,4],[1,1,1,1,5],[1,1,1,1,6],[1...
13:53:53 <FunctorSalad> doesn't occurs-check?
13:54:18 <weirdo> occurs check?
13:54:22 <gwern> ehamberg: personally, I'd just do a bunch of 'take's or maybe use 'break'
13:54:24 <weirdo> you're doing prolog in haskell?
13:54:25 <gwern> :t break
13:54:25 <copumpkin> FunctorSalad: what looks like a bug?
13:54:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:54:37 <gwern> oops. I guess it wasn't break I was thinking of
13:54:38 <Saizan_> weirdo: the type inference algorithm does
13:54:43 <gwern> @hoogle span
13:54:43 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
13:54:43 <lambdabot> Data.ByteString span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
13:54:43 <lambdabot> Data.List span :: (a -> Bool) -> [a] -> ([a], [a])
13:54:57 <gwern> nm
13:55:01 <FunctorSalad> copumpkin: the hoogle result ('drop' for Int -> [a] -> [[a]])
13:55:01 <benmachine> > (\x -> x x)
13:55:02 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:55:20 <copumpkin> FunctorSalad: oh
13:55:24 <FunctorSalad> @type (drop :: Int -> [a] -> [[a]])
13:55:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
13:55:25 <lambdabot>     In the expression: (drop :: Int -> [a] -> [[a]])
13:55:27 <Berengal> In other news, after poking around the happstack documentation a bit I was left with no content for my first test page, but then I fixed the problem
13:55:33 <Saizan_> FunctorSalad: hoogle doesn't really use unification
13:55:48 <copumpkin> > let f :: (forall a. a -> a) -> a; f = (\x -> x x) in f id 5
13:55:48 <lambdabot>   Couldn't match expected type `a1' against inferred type `a -> a'
13:55:48 <lambdabot>    `a1' is...
13:56:08 <copumpkin> > let f :: (forall a. a -> a) -> (a -> a); f = (\x -> x x) in f id 5
13:56:09 <lambdabot>   5
13:56:30 <FunctorSalad> Berengal: but... it isn't really a quine, is it
13:56:43 <weirdo> > sqrt (-1)
13:56:44 <lambdabot>   NaN
13:56:45 <FunctorSalad> since it's not valid haskell code
13:56:59 <FunctorSalad> (due to the text at the start)
13:57:13 <Berengal> FunctorSalad, I thought about that... perhaps I should make it literate?
13:57:18 <benmachine> FunctorSalad: it prints its own source code
13:57:24 <FunctorSalad> Berengal: yeah :)
13:57:28 <benmachine> 'sjust not all it does
13:57:54 <Berengal> "In computing, a quine is a computer program which produces a copy of its own source code as its only output." - WP
13:58:08 <benmachine> only pfft
13:58:12 <Berengal> Yeah :(
13:58:15 <Berengal> Still, close enough
13:59:25 <FunctorSalad> you could also just have the text start with --
13:59:34 <gwern> benmachine: actually, the 'only' makes it more challenging
13:59:56 <gwern> otherwise you could have a shell quine like 'find / -exec cat {}\;'
14:00:00 <Berengal> gwern, it also brings up lots of details regarding what "output" means
14:00:09 * bos now has a pure haskell PRNG that'a consistently faster than mersenne-random. yay!
14:00:22 <gwern> bos: sure, but is it splittable?
14:00:37 <bos> gwern: i don't think anyone understands splittable PRNGs.
14:00:39 <Berengal> gwern, reading files is cheating
14:00:45 <copumpkin> bos: nice!
14:00:50 <bos> gwern: i sure don't.
14:01:22 <gwern> Berengal: oh, so now you're going all pure on me???
14:01:27 <bos> this PRNG has period of only 2**8222 instead of 2**19937, but i think that's OK.
14:01:57 <Berengal> gwern, well, if reading files is allowed, a python quine would just be "print open(__file__).read()"
14:02:09 <bos> it generates floating point numbers suitable for use in statistical calculations and monte carlo simulations, which is what i wanted.
14:02:12 <gwern> Berengal: fine, then if we drop the 'only' restriction, then a quine could be printing the base-60 version of pi
14:02:21 <mauke> open 0 and print <0>
14:02:28 <mauke> ^ cheating perl quine
14:02:39 <copumpkin> oh no, only 2**8222
14:02:45 <copumpkin> what will I do if it repeats!!
14:02:47 <Berengal> gwern, not sure which is most challenging; a regular quine or that one :P
14:02:54 <gwern> (wait, base-60 doesn't includes the full ascii set right? you know what I mean, printing out every possible sequence of letters. gauranteed to produce itself!)
14:03:40 <gwern> mauke: what does that do?
14:03:46 <mauke> prints itself
14:03:58 <gwern> yeah but how does it work?
14:04:04 <Berengal> base 256, and it'll be a quine any way you interpret it, assuming 8 bit bytes
14:04:09 <mauke> terrible!
14:04:16 <gwern> -_-
14:04:30 <mauke> gwern: how much perl do you know?
14:04:36 <gwern> none
14:04:42 <mauke> #haskell-blah?
14:05:10 <gwern> ...is it that advanced perl-fu?
14:05:27 <mauke> well, it's definitely not haskell
14:06:54 <gwern> I was really expecting a 1 or 2 line explanation, so -blah would be way overkill
14:07:12 <FunctorSalad> also a good cheating quine: compiler error ;)
14:07:17 <benmachine> gwern: is it actually proven that any sequence will eventually arise in pi?
14:07:43 <gwern> benmachine: no, but it's kind of like p=np - we'll all be quite shocked if it turns out the other way
14:07:56 <benmachine> heh fair enough
14:10:56 <Berengal> FunctorSalad, that can be hard in ghc
14:13:24 <FunctorSalad> Berengal: huh? this does it http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9409#a9409
14:13:33 <FunctorSalad> compiled with "ghc --make Main"
14:14:04 <Berengal> I stand corrected
14:25:55 <edwardk> alpounet: pong
14:26:15 <edwardk> oh, he's gone
14:31:33 <Peaker> did the breakout guy get what he needed?
14:32:09 <saml> > breakaway by "Kelly Clarkson"
14:32:10 <lambdabot>   Not in scope: `breakaway'Not in scope: `by'
14:47:14 <jaredj> @seen sm
14:47:14 <lambdabot> Unknown command, try @list
15:02:12 <_Jordan_> is it possible to load a .hs file with foreign imports into GHCi?
15:02:47 <Vanadium> I suspect so
15:03:08 <mdordal2> tommd: i tried to build your ghc patches earlier, and ran into an issue
15:04:18 <tommd> mdordal2: What issue?
15:04:30 <mdordal2> tommd: oh hey you fixed it
15:04:36 <tommd> :-)
15:04:49 <tommd> You're not the only one working on it ;-)
15:24:11 <mdordal2> tommd: running into an interesting issue. When i try to make stamp-configure it hits a "syntax error: unexpected end of file".
15:24:15 <mdordal2> ever seen that?
15:24:31 <tommd> No - I haven't seen that.
15:24:43 <tommd> I also know several people who got pasted that, so this is a new one.
15:26:47 <tommd> mdordal2: I just tested it from scratch up to make stamp-patch.  Everything when fine.
15:27:22 <tommd> mdordal2: You have all then tools, right?  gcc, libreadline (is that still needed?), etc?
15:36:41 <mdordal2> tommd: what are all the dependencies? I have autotools, gcc, etc...
15:37:40 <tommd> It was an off-hand question.  really if the issue is a missing dependency then the configure step should tell you whats missing.  As it is, it almost sounds like you have a bad download - as unlikely as that is.
15:38:20 <tommd> Just to check a couple things, you could check the version of gcc, make and patch. (4.4.1, 3.8.1, 2.5.4)
15:39:50 <mdordal2> gcc is 4.3, patch is 2.5.9
15:40:00 <tommd> Just FYI - I used Fedora 11 as a base.  If you want to match up then it might make things easier.
15:40:07 <siki> Hi. Anyone knows where I can put up a job posting on the Haskell forum?
15:40:26 <mdordal2> apt wants to upgrade gcc, so I'm doing that
15:40:41 <tommd> gcc 4.3 is too old - there is at least one flag you'll see later on that someone else ran into that needs 4.4 (the dwarf2 flag)
15:40:44 <deech> Has anyone here worked with futures in any language before?
15:40:44 <tommd> sounds good
15:41:29 <Peaker> deech: Twisted's deferreds, if that counts
15:42:41 <Nafai> Yay deferreds
15:43:05 <deech> Peaker: I don't know of it, but the name suggests that it is the same concept. How are promises/futures  any different from traditional asynchronous event-driven gui programming?
15:43:40 <Peaker> deech: basically they provide a common framework for dealing with the callbacks
15:44:18 <Peaker> deech: Twisted's deferreds can be seen as sort of coroutines that are not written as normal code, but built by chaining callbacks
15:44:37 <deech> I only ask because they are frequently mentioned in the same breath as working with shared mutable resources. But it not solving that problem, correct?
15:45:09 <Peaker> deech: they're often mentioned as an alternative to threads
15:45:19 <Peaker> deech: so they make shared mutable state easier by removing a lot of the non-determinism
15:45:25 <deech> I've had more than one person tell me that futures are an alternative to STM.
15:45:46 <Peaker> deech: and like coroutines, they insert context-switch points at precise locations (rather than anywhere)
15:45:57 <jmcarthur> siki: i don't even know of a haskell forum. do you mean one of the mailing lists?
15:46:12 <Peaker> deech: when you control where you context-switch, you don't need locks, and usually don't need transactions either
15:47:05 <deech> Peaker: Are there any Haskell/any-other-language learning resources on this?
15:47:35 <siki> <jmcarthur> Yes I meant the mailing list.
15:47:51 <Saizan_> siki: the haskell -at- haskell.org one then
15:48:18 <siki> Saizan_: Are job postings allowed?
15:48:41 <jmcarthur> siki: http://haskell.org/haskellwiki/Jobs
15:48:53 <jmcarthur> "If you are seeking Haskell jobs, or wish to recruit, good places to follow are the Haskell and Haskell-cafe mailing lists, and the Types mailing list (particularly for research jobs)."
15:49:42 <Saizan_> siki: yes, i've seen them there before
15:49:44 <Peaker> deech: not sure. I can try to explain more thoroughly
15:50:09 <sshc> how do I see if a list begins with another list?
15:50:16 <Peaker> @hoogle isPrefixOf
15:50:16 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
15:50:16 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
15:50:16 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
15:50:30 <Peaker> > "hello" `isPrefixOf` "hello world"
15:50:31 <lambdabot>   True
15:50:36 <deech> Peaker: sure, please do.
15:50:43 <Peaker> deech: do you know coroutines?
15:51:22 <deech> Peaker: In passing, I understand how to use continuations. Is this the same thing?
15:51:31 <Peaker> deech: slightly different
15:51:43 <jmcarthur> i used to have a coroutine library written, but i don't know what happened to it :(
15:51:59 <jmcarthur> deech: you can use continuations to implement coroutines
15:52:04 <Peaker> deech: coroutines are like cooperative threads, where you only switch by explicitly yielding control (or calling someone who does)
15:52:06 <mdordal2> (x:xs): mxs?
15:53:08 <Peaker> deech: This has a few advantages, and disadvantages.  It is more deterministic (as switch times are not random). It doesn't require locking to guarantee atomicness. It requires coherence of your data structures for re-entrancy/etc only in context-switch or normal re-entrancy points
15:53:16 <Peaker> deech: disadvantages: Can't parallelize such coroutines
15:53:59 <jmcarthur> i suspect you could if the monad is commutative
15:54:27 <deech> Peaker: So a thread has your data structure captive until it explicitly yields?
15:54:36 <Peaker> jmcarthur: if its cummutative, might as well be Applicative, and not Monad?
15:54:51 <Peaker> deech: it has _all_ data captive until it yields, nothing else can run until it does
15:55:06 <jmcarthur> well, the interface over the coroutines would be applicative, but could expose a monadic interface for each coroutine, maybe. i'm just speculating, here
15:55:37 <deech> Peaker: Understood.
15:55:38 <Peaker> AFAIU: cummutative Monad = Applicative
15:55:46 <jmcarthur> eh
15:55:51 <jmcarthur> not really
15:55:58 <jmcarthur> afaiu
15:56:16 <jmcarthur> > [1,2,3] *> [1,2]
15:56:16 <copumpkin> *commutative
15:56:16 <lambdabot>   [1,2,1,2,1,2]
15:56:21 <benmachine> monad => applicative
15:56:30 <benmachine> except
15:56:30 <jmcarthur> > [1,2] <* [1,2,3]
15:56:31 <Peaker> jmcarthur: well, a cummutative monad can't really (>>=) (it forces finishing with the left side before knowing what right-side to execute)
15:56:31 <lambdabot>   [1,1,1,2,2,2]
15:56:38 <Peaker> jmcarthur: and if it just (>>) then it is an Applicative
15:56:41 <benmachine> not in a haskelly use of =>
15:56:57 <benmachine> haskellesque
15:56:58 <deech> Peaker: And this relates to futures because whatever method it is running to fulfill a promise runs atomically.
15:57:07 <jmcarthur> Peaker: the effect of >>= doesn't necessary have to occur in any sort of order, only the bound result
15:57:15 <Peaker> deech: "Futures" are similar to coroutines
15:57:29 <Peaker> deech: if you're willing to twist your head a bit :)
15:57:55 <Peaker> deech: usually a future has a callback that does stuff, then installs more callbacks (or multiple callbacks were installed in the first place)
15:58:17 <deech> Peaker: I'll have to ponder that more. No article on futures relates the two concepts!
15:58:20 <jmcarthur> or, actually, i think i mean the other way around there
15:58:31 <jmcarthur> or maybe i need to meditate on what i mean
15:58:48 <Peaker> jmcarthur: >>= uses left's result to choose which right effect to use
15:59:02 <Peaker> jmcarthur: <*> uses left and right result to form the final result, but the effects can be parallelized
15:59:02 <SamB> well, I've worked with monads where I tended to get errors from the "end" of the execution first ...
15:59:29 <jmcarthur> Peaker: i'm not really sure where the inherent parallelisation is there
16:00:06 <Peaker> deech: coroutine:  blah_blah ; result = yield do_read() ; bleh_bleh       consider each yield's continuation to be the callback being installed. For example, bleh_bleh is installed as a callback on the future returned by do_read
16:00:51 <jmcarthur> Peaker: i think i would only consider an applicative commutative if x *> y == y <* x
16:00:52 <Peaker> deech: do_read() is returning a future, and "yield" with a future yields control to other coroutines until the future callback fires
16:01:08 <Peaker> jmcarthur: when would you consider a monad commutative?
16:01:31 <jmcarthur> Peaker: thinking
16:01:51 <SamB> Peaker: can they ever be ?
16:01:58 <Saizan_> Reader is commutative
16:02:21 <Saizan_> you can reorder the actions and you get the same result
16:02:38 <deech> Peaker: Gotcha.
16:02:42 <jmcarthur> Peaker: suppose foo and bar have different effects but the same results. i think (foo x >>= bar) == (bar x >>= foo) would be the condition i'm looking for
16:03:01 <Peaker> deech: I view coroutines and future callback installation as two syntaxes that represent the same semantics
16:03:21 <Peaker> deech: I have come to prefer to the coroutine syntax..
16:03:44 <deech> Peaker: Awesome. I haven't heard it explained like that before.
16:03:55 <jmcarthur> yes, the reader monad is a good example
16:04:06 <jmcarthur> as is Writer over a commutative Monoid
16:04:17 <Peaker> deech: cool :-)
16:04:31 <Peaker> jmcarthur: its also a case where the Monad instance doesn't add anything interesting over the Applicative one, might as well use Reader Applicative
16:05:03 <Peaker> jmcarthur: I think this is the case for all commutative monads (that the Applicative gives you everything you need)
16:05:32 <jmcarthur> Peaker: do you suspect this also holds for a commutative Writer? (i haven't thought that one through yet)
16:06:18 <Peaker> I think so, but I've gotta go
16:06:47 <Saizan_> it won't hold
16:06:56 <jmcarthur> well, i would certainly claim that not all applicatives are commutative
16:07:30 <Saizan_> liftM3 if' is not the same as ifM for a commutative writer
16:24:40 <benmachine> @pl concatMap
16:24:40 <lambdabot> (=<<)
16:24:50 <mdordal2> tommd: are you 32-bit?
16:32:15 <bjorkintosh> i'm at my wit's end. what does this error mean:
16:32:22 <bjorkintosh> Setup.hs: At least the following dependencies are missing:
16:32:22 <bjorkintosh> OpenGL -any
16:32:55 <bjorkintosh> i've installed every last libghc6-* which includes every aspect of libghc*gl
16:33:29 <bjorkintosh> any ideas?
16:33:33 <jonh> hmm guesing they also include deps on the actual opengl libs?
16:33:44 <bjorkintosh> i think so.
16:33:51 <bjorkintosh> i'm trying to configure Haskore.
16:34:12 <bjorkintosh> i've done everything i could think of, including a fresh debian install.
16:36:18 <c_wraith> Is it possible the configuration is looking in a different spot than they're installed to?
16:36:34 <bjorkintosh> there's a single line in Setup.hs
16:36:46 <bjorkintosh> or maybe two. it's not telling me much else besides the error i pasted above.
16:37:18 <bjorkintosh> has anyone else tried installing Haskore?
16:54:16 <Baughn>  /j #firefox
16:58:39 <Peaker> how did Haskell end up with camel case?
16:58:41 <tommd> mdordal2: Yes, the House patches are only for x86 - not x86_64 or any other architecture.
16:58:51 <Peaker> and not underscores?
16:58:59 <mdordal2> hrm
17:08:03 <wchogg> tommd : Pretty sure I asked this at some point, but were you planning to move House over to 6.10.*?  Is it even worth it?
17:11:55 <tommd> wchogg: I don't plan on moving House.  Perhaps Adam or Kenny will move the House patches to 6.10 then I wouldn't mind updating my minor changes.
17:15:42 <tommd> wchogg: Someone mentioned to me that they'd be willing to work Crypto at HacPDX.  Are you going to be there?  We might have a couple folks interested.
17:16:03 <wchogg> tommd : I might be there!  The thing I was thinking of leaving town for that weekend didn't happen.
17:16:15 <wchogg> tommd : Also, that felt like a really verbose way to say that.  WTF.
17:16:51 <tommd> Words - they aren't as concise as FP.
17:17:21 <titusg> meh.
17:17:26 <tommd> hem
17:17:37 <wchogg> palindromes!
17:17:45 <wchogg> mehhem
17:17:48 <titusg> :-)
17:17:57 <tommd> meh.hem
17:18:20 <wchogg> meh composed with hem? Huh.
17:18:28 <tommd> I haven't a clue.
17:23:40 <wchogg> But, yeah, I can probably be at the hackathon.  Honestly, the main thing I may be working on there is actually getting some real progress on my bluez bindings.
17:24:41 <Cale> http://www.reddit.com/r/programming/comments/9ky2z/a_very_fun_talk_about_commutative_monads_and/ :)
17:31:50 <fbru02> hey guys what is a dense vector?
17:32:28 <fbru02> and btw what is a sparse vector ? one that contains zeroes ?
17:33:22 <wchogg> I believe sparse means "mostly" zeroes, for some definition of mostly that I'm not entirely sure of.
17:33:37 <medfly> http://www.cs.umd.edu/Outreach/hsContest99/questions/node3.html
17:33:53 <fbru02> thanks
17:34:10 <fbru02> i guess dense is NOT spars
17:34:12 <fbru02> e
17:34:16 <Cale> Yeah.
17:34:43 <Cale> fbru02: Sparse vectors and matrices are ones which are mostly 0's, so you store them as sequences of indices at which the nonzero entries occur, together with the value there.
17:35:08 <thoughtpolice> @seen copumpkin
17:35:08 <lambdabot> Unknown command, try @list
17:35:13 <thoughtpolice> @seen pumpkin
17:35:13 <lambdabot> Unknown command, try @list
17:35:15 <thoughtpolice> :(
17:35:22 <thoughtpolice> preflex: seen copumpkin
17:35:22 <preflex>  copumpkin was last seen on #haskell 1 hour, 39 minutes and 6 seconds ago, saying: *commutative
17:35:28 <aavogt> @seen lambdabot
17:35:28 <lambdabot> Unknown command, try @list
17:35:28 <Cale> fbru02: That way, when you go to do multiplication, you don't waste most of your time multiplying by 0
17:36:04 * medfly stares.
17:36:08 <aavogt> you probably save more time with addition?
17:40:10 <sleepynate> guess i should just hang out here too, Cale
17:40:24 <Cale> :)
17:40:58 <sleepynate> like they need my clever wit and vivacity in a haskell chan though :D
17:43:36 <travisbrady> lambdabot: commands
17:43:46 <travisbrady> bots
17:43:56 <travisbrady> @help
17:43:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:44:01 <travisbrady> @list
17:44:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:50:29 <medfly> hi Cale
17:51:11 <bjorkintosh> is there anything else i need to install to satisfy ghci's opengl dependencies?
17:51:20 <Cale> aavogt: that too
17:51:36 <bjorkintosh> i tried installing haskell platform but it compiled for two days and seemed to do nothing but spin the harddisk.
17:51:52 <Cale> bjorkintosh: Do you absolutely need to compile it yourself?
17:52:48 <FunctorSalad> also if there was a missing dependency, it's supposed to fail, not spin your harddisk indefinitely ;)
17:52:56 <Cale> bjorkintosh: The Haskell platform is more intended as a binary release sort of thing, as I understand it. What platform are you on?
17:52:57 <bjorkintosh> Cale, there's no debian binary or whatever.
17:53:45 <Cale> bjorkintosh: Ah, in the case of debian, I would just get the GHC generic linux binary from the GHC website, and then get cabal-install from http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz
17:53:58 <jnthn205> hey i have a programming question
17:54:00 <jnthn205> its java
17:54:02 <jnthn205> i need help real bad
17:54:03 <jnthn205> im new
17:54:06 <sleepynate> funny
17:54:11 * FunctorSalad did what Cale said too
17:54:20 <jnthn205> can anybody help me?
17:54:23 <jnthn205> pm me please
17:54:26 <Cale> jnthn205: This is for discussion about the Haskell programming language... Isn't there a ##Java or something?
17:54:28 <sleepynate> jnthn205: try #java :P
17:54:35 <Cale> Er, or #java, perhaps
17:54:35 <jnthn205> thanks
17:54:56 <sleepynate> lolwut? :D
17:55:00 <FunctorSalad> (don't bother with the debian packages, just install ghc and cabal from their websites, then cabal install everything)
17:55:18 <FunctorSalad> (IMHO)
17:55:41 <sleepynate> plus you get the joy of saying cabalinstall really fast while you do it
17:55:52 <Cale> bjorkintosh: Compiling GHC yourself generally takes forever unless you have an extremely fast machine, and is a tremendous waste of time unless you're hacking on it.
17:55:54 <sleepynate> trust me, it sounds cool.
17:56:03 <FunctorSalad> sleepynate: no, I have "alias ci = cabal install" :-(
17:56:21 <Cale> (also, you'd need a working binary of GHC to begin with, unless you're going to bootstrap it, which is not a task for beginners)
17:56:27 <sleepynate> FunctorSalad: well you wore out your fun, and that's not MY fault :P
17:56:34 <bjorkintosh> Cale, i wasn't. i have 6.10.4 binary installed.
17:56:41 <Cale> bjorkintosh: okay...
17:56:58 <Cale> bjorkintosh: In that case, just get cabal-install, and you should be able to install anything you need from hackage.
17:57:00 <dolio> What's the deal with 6.12.1RC1?
17:57:04 <bjorkintosh> i didn't realize haskell platform would attempt to compile everything from scratch.
17:57:35 <Cale> dolio: I'm not sure. I heard it was going to be out yesterday, but...
17:57:37 <bjorkintosh> then again, it said sources.
17:57:55 <bjorkintosh> what's most irksome is the missing OpenGL dependencies for Haskore though...
17:58:06 <bjorkintosh> i've installed everything i could think of. still, nyet.
17:58:18 <Cale> bjorkintosh: hmm
17:58:22 <FunctorSalad> so you have haskell going already and just want to test something on haskell platform?
17:59:04 * Cale tries "cabal install Haskore" to see if he runs into the same problem.
17:59:17 <Cale> I didn't know that Haskore had any opengl deps.
17:59:19 <jonh> i just tried it and it worked great
17:59:29 <FunctorSalad> opengl recently split into smaller packages
17:59:34 <FunctorSalad> maybe it's related to that
17:59:35 <bjorkintosh> FunctorSalad, it's for Haskore.
18:01:19 <FunctorSalad> just checked, Haskore doesn't seem to depend on GL for me
18:02:06 <FunctorSalad> btw is haskore the currently active haskell music project? ISTR there were several
18:02:29 <bjorkintosh> yes.
18:02:43 <bjorkintosh> but i get this error: Setup.hs: At least the following dependencies are missing: OpenGL -any
18:03:04 <Cale> bjorkintosh: Why are you running Setup.hs manually?
18:03:20 <Cale> bjorkintosh: You should just run  cabal install Haskore  and it will get all the dependencies for you.
18:04:11 <Cale> (if you're getting that message from the cabal install... that's really strange.)
18:05:26 <bjorkintosh> no i'm not. i'm getting that from here: http://plucky.cs.yale.edu/cs431/software_resources.htm#Haskore
18:05:35 <SamB_XP> Cale: that would mean that the .cabal file was wrong, yes ...
18:05:36 <bjorkintosh> following everything to the letter.
18:05:57 <jonh> hehe
18:06:06 <SamB_XP> but I'm not sure that's so strange!
18:06:17 <Cale> bjorkintosh: Ah, those are old instructions.
18:06:32 <Cale> bjorkintosh: Probably someone should tell the Haskore people to update them.
18:06:52 <Cale> er...
18:07:00 <bjorkintosh> well shit! someone should have told me before i tore the rest of my hair out.
18:07:03 <Cale> or the professor :)
18:07:33 <SamB_XP> professors are always giving you obsolete software-usage directions ...
18:07:50 <Cale> If you need to use that custom darcs version of Haskore
18:07:59 <SamB_XP> like, they'll tell you to use a matlab function that's been deprecated for maybe a decade and got removed, oh, 5 years back!
18:08:10 <Cale> then try just running "cabal install" from the directory, instead of those runhaskell commands.
18:08:47 <SamB_XP> Cale: what if it's not up-to-date with upstream ?
18:08:53 <Cale> Otherwise, you can get a recent version of Haskore from hackage by just "cabal install Haskore" from any directory.
18:09:17 <Cale> SamB_XP: At least it would *try* to resolve the deps.
18:09:40 <Cale> (though if they had inappropriate version bounds, you could run into trouble)
18:09:54 <SamB_XP> Cale: has haskore always had a .cabal file, then ?
18:10:18 <Cale> Doesn't Setup.hs imply the presence of a .cabal file?
18:10:28 <SamB_XP> oh, right
18:10:29 * Cale tries to think back...
18:10:38 <SamB_XP> yeah, it does
18:10:46 <SamB_XP> forgot about that detail
18:10:54 <SamB_XP> I'm no shirlock
18:11:05 <ray> samb_xp: and if you tell them that function doesn't exist, they'll assume your version of matlab is too old, because to them it's a new addition
18:11:25 <ray> this is what tenure does to people
18:11:26 <bjorkintosh> okay. thanks Cale. i'll keep that in mind next time i'm on that website.
18:11:55 <SamB_XP> ray: not if mathworks left a stub in place to tell you about the removal ...
18:12:17 <ray> "removed? but they just added it"
18:12:46 <SamB_XP> my professors aren't *that* out of touch with reality ...
18:13:09 <SamB_XP> if the software says something was removed (presumably in favor of something better), they'll believe it ;-)
18:13:21 <SamB_XP> assuming it isn't badly-enough spelled to look like sabotage ;-)
18:14:19 <SamB_XP> oh, did I ever tell you about the time I caught a fictitious student committing plaigerism ?
18:14:49 <ivanm> SamB_XP: do tell
18:15:21 <SamB_XP> well, okay, so my professor gave us this word file that was supposed to be a conglomeration of the worst papers he'd seen for a certain lab ...
18:15:36 <Cale> bjorkintosh: Basically, whenever you see instructions anywhere that tell you to fiddle with Setup.hs, just ignore that bit and use cabal install.
18:15:37 <SamB_XP> ... and we were supposed to rewrite it
18:16:01 <SamB_XP> so I was working on that
18:16:22 <SamB_XP> and I went into the styles list as I usually do and found some ... very ... odd ... styles
18:16:39 <ivanm> why would you re-write it?
18:16:45 <ivanm> as in a bad example to give to students?
18:16:59 <SamB_XP> ivanm: I was one of those students
18:17:06 <ivanm> ahhhh
18:17:09 <SamB_XP> we were supposed to show that we'd learned from it
18:17:13 <ivanm> *nod*
18:17:22 <ivanm> so you were just re-writing your own paper?
18:17:47 <SamB_XP> ... no! the bad example was a composite
18:18:04 <ivanm> ahhh
18:18:19 <Cale> Heh, all the worst parts of the worst papers? :)
18:18:39 <SamB_XP> anyway, I figured out that some of the text was links that had been colored over in black, with the underline removed...
18:18:39 <ivanm> so why re-write a bad paper? just so that everyone is writing the same thing?
18:18:44 <ivanm> heh
18:19:00 <SamB_XP> ... and the URLs all seemed to point at wikipedia ...
18:19:10 <ivanm> *groan*
18:19:36 <SamB_XP> ... so I copied and pasted some of the text into google, and sure enough, it was from another wikipedia article!
18:20:56 <ivanm> so the professor plagiarised wikipedia to show that plagiarism was bad?
18:21:13 <SamB_XP> and guess what site our professor told us not to even think about using as a reference?
18:21:16 <SamB_XP> ivanm: no, no
18:21:39 <ivanm> oh, it really was a conglomeration?
18:21:40 <SamB_XP> I'm pretty sure one of the papers the example was a conglomeration of was plaigerising wikipedia
18:21:47 <SamB_XP> that was my understanding, yes
18:21:55 <ivanm> heh
18:22:19 <ivanm> I once caught in a first year mathematics computing course three people cheating code for I think the bisection method...
18:22:32 <ivanm> two I found online by googling, the third referenced the matlab help docs
18:22:33 <SamB_XP> I don't think the professor would have done anything so hypocritical as copy and paste stuff from wikipedia into a paper, even a *bad example* paper, when he'd told us not to even *cite* it!
18:22:57 <ray> i don't get the anti-wikipedia bias
18:22:59 <ivanm> students don't seem to understand that if the code looks more advanced then what you'd expect them to produce, it normally is...
18:23:03 <SamB_XP> ivanm: you mean he copied a file from the matlab library ?
18:23:04 <ivanm> ray: because it isn't verified
18:23:10 <ivanm> SamB_XP: no, the matlab help docs
18:23:12 <ray> no
18:23:23 <SamB_XP> ah
18:23:23 <ivanm> ray: and there's no way of proving that it is correct
18:23:33 <ray> uh
18:23:36 <ivanm> SamB_XP: I gave him _some_ marks because at least he referenced it ;-)
18:23:44 <copumpkin> if you plagiarize, you should do it right
18:23:49 <SamB_XP> ivanm: oh, he *said* he'd done that?
18:23:55 <ivanm> ray: well, who would you trust more: britannica or wikipedia?
18:23:57 <ivanm> SamB_XP: yup
18:24:02 <SamB_XP> so it was not plaigerism, just not what was wanted ?
18:24:11 <SamB_XP> meaning, not original work
18:24:15 <ivanm> yeah
18:24:20 <ray> i would hope you wouldn't catch me citing either
18:24:23 <SamB_XP> well, that's certainly much less serious
18:24:47 <SamB_XP> ... also a heck of a lot easier to catch ;-)
18:24:50 <ray> encyclopedias provide information and citations for research
18:25:05 <ivanm> ray: yeah, you probably shouldn't even be citing britannica for a university-level paper
18:25:10 <SamB_XP> ray: well, he didn't say we couldn't *look* at wikipedia
18:25:15 <SamB_XP> just not to use it as an actual source
18:25:19 <ivanm> SamB_XP: exactly; I use wikipedia as a starting point
18:25:26 <SamB_XP> so we were certainly free to follow the citations
18:25:27 <ivanm> get a general overview, find links to elsewhere
18:25:36 <ray> so are you biased against it or not? :)
18:25:37 <SamB_XP> or use it to think of other search terms
18:25:53 <SamB_XP> well, my advice is to take wikipedia with a saltshaker
18:26:10 <ray> i mean, seriously, "it isn't verified"? :)
18:26:17 <ivanm> ray: I use it, just not as a reference for a paper
18:26:19 <SamB_XP> some of it is flat-out wrong
18:26:24 <ivanm> yup
18:26:45 <SamB_XP> but it's a heck of a lot better than no information in most cases
18:26:53 <ray> i *do* happen to have an anti-wikipedia bias, but it is not the concept that i take issue with
18:26:56 <SamB_XP> in other cases, it *is* essentially no information
18:27:04 <SamB_XP> ray: oh, me either
18:27:15 <SamB_XP> I do take issue with the "community"
18:27:17 <ray> once you have seen the sausage being made
18:27:17 <ivanm> ray: what kind of bias?
18:27:25 <ray> you can't look at it the same way again
18:27:34 <SamB_XP> some serious poison going on there
18:27:43 <ivanm> ray: I quite happen to like sausage...
18:27:44 <SamB_XP> and they TOOK OUT THE DAMN SPOILER WARNINGS!
18:27:51 <SamB_XP> ivanm: ever made it?
18:27:53 <ivanm> what is with this anti-sausage bias of yours?
18:27:56 <ivanm> SamB_XP: yes
18:28:00 <ivanm> well, I helped my dad make it
18:28:10 <ivanm> smoked sausages mainly
18:28:26 <SamB_XP> ivanm: you stuff the ground meat into the intestine ?
18:28:35 <ivanm> yes
18:28:47 <SamB_XP> okay, well, I guess you don't squeam easily ;-)
18:28:51 <ivanm> heh
18:29:06 <SamB_XP> not that I've ever done that, or that I have anything against sausage
18:29:08 <ivanm> SamB_XP: do you ever eat meat patties?
18:29:27 <SamB_XP> I eat sausage myself
18:29:30 <SamB_XP> love it, usually
18:29:51 <SamB_XP> and was just about to take a crack or two at mcdonalds or burger king
18:29:55 <ivanm> heh
18:30:05 <SamB_XP> for some of the foreign objects that have appeared in their food over the years
18:30:06 <ivanm> here, maccas claims they use 100% beef...
18:30:20 <ivanm> sure, 100% beef stomachs, hearts, etc.
18:32:00 <jokerGTA> can anyone help me with something
18:32:05 <jokerGTA> i have this...
18:32:16 <jokerGTA> type MyType = [Integer]
18:33:14 <jokerGTA> myFunction::[MyType]->Integer->Integer
18:33:45 <enolan> What's the question?
18:33:52 <jokerGTA> =zipwith(\a e ->a*f^e) xs [0..]
18:33:57 <jokerGTA> it keeps giving me type error
18:34:11 <jokerGTA> when i change [myType] to [Integer] works just fine
18:34:13 <ski> what is the left-hand side of the `=' ?
18:34:22 <shachaf> jokerGTA: [MyType] = [[Integer]].
18:34:31 <ski> `[MyType]' is the same as `[[Integer]]', not as `[Integer]'
18:34:35 <shachaf> jokerGTA: (Did you know you're allowed to use spaces even if they're not strictly required, by the way?)
18:34:47 <jokerGTA> no i didnt
18:35:00 <copumpkin> lol
18:35:05 <jokerGTA> i dont understand what you mean ski
18:35:16 <copumpkin> jokerGTA: just substitute
18:35:20 <ski> the type `MyType' is the type of lists of integers
18:35:29 <copumpkin> if MyType is [Integer], then [MyType] is [[Integer]]
18:35:29 <jokerGTA> yes thats right
18:35:30 <ski> the type `[MyType]' is the type of lists of *lists* of integers
18:35:33 <shachaf> jokerGTA: MyType is a list of Integers, so a list of MyTypes is a list of lists of Integers.
18:36:14 <ski> jokerGTA : presumably there was something to the left of `=zipwith(\a e ->a*f^e) xs [0..]', no ?
18:36:26 <jokerGTA> yes i have guards
18:36:32 <jokerGTA> on the left is just otherwise  =
18:37:00 <ski> (and regarding using spaces, you can e.g. say `myFunction :: [MyType] -> Integer -> Integer')
18:37:27 <jokerGTA> oh yeah i know that...i didnt know what you mean sorry ski
18:38:45 <ski> so, problem solved ?
18:39:00 <jokerGTA> no not really..i still dont know what to change
18:39:18 <ski> it depends on what you want
18:39:26 <jokerGTA> i dont think i am understanding this
18:39:32 <ski> do you want `myFunction' to take a list of integers as argument ?
18:39:41 <ski> or a list of *lists* of integers ?
18:39:54 <jokerGTA> i want it to takle list of [myTypes] as argument
18:40:18 <shachaf> jokerGTA: If a = [b] and b = [c], a = [[c]]
18:40:34 <shachaf> jokerGTA: That function is getting a list of integers, though.
18:40:35 <ski> are you really sure you want lists of elements of type `[MyType]' ? (since that would be `[[MyType]]')
18:40:37 <dave__> your MyType = [Integer]
18:40:40 <shachaf> jokerGTA: Do you want MyType to be an Integer?
18:40:46 <jokerGTA> yes
18:40:54 <jokerGTA> myType = [Integer]
18:41:01 <shachaf> jokerGTA: That says that MyType is a list of Integers.
18:41:08 <shachaf> jokerGTA: That's what [] means. :-)
18:41:13 <jokerGTA> yes i know
18:41:15 <ski> jokerGTA : let's try another route. can you give an example of calling this function of specific integers and lists ?
18:41:21 <jokerGTA> [Integer] is list of integers
18:41:27 <jokerGTA> for example [1,2,3,4]
18:41:33 <shachaf> jokerGTA: And [[Integer]] is a list of lists of Integers.
18:41:45 <dave__> so you want to call myFunction [1,2,3]
18:41:50 <dave__> for example
18:41:59 <dave__> ?
18:42:04 <jokerGTA> let me try to substtitute this again
18:42:09 <jokerGTA> maybe i am missing something
18:42:14 <jokerGTA> give me few minutes
18:42:56 <ski> (gotta go)
19:10:57 <Nafai> Woah
19:11:08 <Nafai> I can now buy Real World Haskell for my Android
19:11:11 <Nafai> phone
19:11:12 <dolio> Free my mind...
19:14:03 <ivanm> Nafai: for how much?
19:16:17 <ivanm> anyone know of a way of alleviating this? http://hackage.haskell.org/trac/ghc/ticket/3256
19:17:00 <Nafai> ivanm: $4.99
19:17:09 <ivanm> Nafai: :o
19:17:17 <ivanm> why so cheap compared to hard copy? :o
19:17:21 <Nafai> Good question
19:17:29 <ivanm> even the PDF version was dearer last I checked...
19:17:32 <ivanm> @go pdf rwh
19:17:32 <lambdabot> Maybe you meant: google googleit do
19:17:37 <ivanm> @google pdf rwh
19:17:38 <lambdabot> http://www.thewomens.org.au/uploads/downloads/HealthInformation/FactSheets/Somali/IUD_Somali2.pdf
19:17:39 <lambdabot> Title: The Royal Womenâs Hospital Information for Women
19:17:41 <ivanm> what is this new @do plugin?
19:17:42 <ivanm> gah
19:17:46 <ivanm> @google pdf real world haskell
19:17:47 <lambdabot> http://book.realworldhaskell.org/read/
19:17:47 <lambdabot> Title: Real World Haskell
19:17:53 <Makoryu> @do foo >>= bar
19:17:54 <lambdabot> do { a <- foo; bar a}
19:18:04 <Makoryu> @do ap
19:18:04 <lambdabot> ap
19:18:06 <Makoryu> >:|
19:18:11 <Makoryu> Well that's hardly useful
19:18:15 <Makoryu> @unpl ap
19:18:16 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
19:18:17 <ivanm> oh, opposite of @undo
19:18:25 <Nafai> And it looks official too (the entry, I haven't purchased yet)
19:18:30 <Makoryu> @unpl on
19:18:31 <lambdabot> on
19:20:14 <ivanm> is it just me, or does O'Reilly's RWH page have absolutely nothing on it? http://oreilly.com/catalog/9780596514983/
19:20:29 * ivanm is wondering if he was overzealous with adblock & co...
19:21:21 <Draconx> ivanm, not just you.
19:22:11 <ivanm> *phew*
19:39:27 <Cale> dons: Just a note, scribd for some reason works a whole lot better for me when it's embedded in a page rather than on the actual scribd site.
19:39:51 <SamB> Cale: is it related to how full of useless crap the site is ?
19:40:16 <dons> agreed
19:40:18 <Cale> SamB: and... well, the actual player itself seems more broken somehow
19:40:24 <copumpkin>  people sure hate it a lot
19:40:30 <copumpkin> it amazes me
19:40:34 <Cale> Like, I couldn't get it into a mode where just clicking would switch slides.
19:40:42 <dons> but it also gets maybe 10x as many views a posting a .pdf
19:40:43 <Nafai> dons: Hear that I can now buy your book on my G1?
19:40:48 <Cale> (Even though it had a menu for that, the menu does nothing for me)
19:40:59 <ivanm> copumpkin: it's not scribd, it's flash
19:41:01 * dons doesn't know why there isn't an embedded .pdf viewer that is widely popular
19:41:01 <dons> seems like a killer app for adobe
19:41:03 <ivanm> people just hate flash ;-)
19:41:17 <ivanm> dons: because reader can be embedded into the browser
19:41:17 <dons> no one complains about youtube
19:41:26 <ivanm> dons: yes they do
19:41:36 <ivanm> just not as much because they've given up and there's no easy alternative :p
19:41:48 <dons> if i post a youtube video, no one complains on reddit. if i post scribd, i get lots of views, and lots of complaints.
19:41:53 <Makoryu> http://www.reddit.com/r/haskell/comments/9krbo/whats_the_status_of_ghc_on_the_64_bit_mac_osx/c0d77dw <- Looks promising!
19:42:17 <ivanm> dons: because youtube is easier than worrying about having the correct codec, etc. for videos
19:42:33 <sleepynate> Makoryu: lemme guess, the status is.... "brushed metal"
19:42:37 <ivanm> scribd is more "convenient" for pdfs, but downloading it and viewing it is still easier overall
19:42:52 <Makoryu> sleepynate: I see what you did there.
19:42:59 <sleepynate> ;)
19:43:10 <copumpkin> Makoryu: that's thoughtpolice :)
19:43:47 <dons> ivanm: but you get a different audience with embedded scribd
19:43:53 <dons> only the hardcore guys download and view the .pdf
19:44:20 * ivanm prefers reading the pdf, but is often too lazy too and uses the scribd interface
19:44:36 <ivanm> dons: big problem I've had with scribd when people use it is that it isn't searchable
19:44:41 <ivanm> for slides, it isn't that big a deal
19:44:48 <ivanm> but when they have a manual/paper there, it is
19:45:06 <sutats> Is it possible to convert my function so that it uses 2 maps instead of explicit recursion and a map: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9417 ?
19:46:09 <aavogt> sutats: isn't that the same as   map ($ list)
19:47:03 <shapr> So, I met bos, it was fun.
19:47:54 <edwardk> yeah
19:48:16 <ivanm> shapr: so you're happy now?
19:48:21 <shapr> er?
19:48:23 <shapr> I guess?
19:48:26 <ivanm> blue-birds singing, etc.?
19:48:29 <ivanm> ;-)
19:48:29 <shapr> I got my copy of RWH autographed!
19:48:30 <sutats> aavogt: I'm not sure, but I don't think so.
19:48:43 <shapr> I have one third of the required autographs now.
19:48:52 <Cale> :t let apply_all [] list = []; apply_all (x:xs) list = map x list : apply_all xs list in apply_all
19:48:53 <lambdabot> forall a b. [a -> b] -> [a] -> [[b]]
19:49:30 <aavogt> :t map (map ($ ?list))
19:49:31 <lambdabot> forall a b. (?list::a) => [[a -> b]] -> [[b]]
19:49:35 <Cale> :t liftM2 ($)
19:49:36 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
19:49:39 <Cale> er
19:49:46 <Cale> right, don't want to join them :)
19:50:07 <aavogt> :t map (flip map ?list)
19:50:08 <lambdabot> forall a b. (?list::[a]) => [a -> b] -> [[b]]
19:50:20 <dons> shapr: the challenge will be CosmicRay
19:50:21 <aavogt> :t map . flip map
19:50:22 <lambdabot> forall a b. [a] -> [a -> b] -> [[b]]
19:50:23 <Cale> :t \fs xs -> map (\f -> map f xs) fs
19:50:24 <lambdabot> forall a b. [a -> b] -> [a] -> [[b]]
19:50:45 <dons> bos: have you ever met someone with more than 1 signature on their RWH ?
19:50:46 <ivanm> dons: since he's always hiding in a bunker somewhere or something? :p
19:50:47 * dons hasn't
19:51:01 <dons> ivanm: he lives in Kansas. which is a long way from anywhere, in some people's opinion
19:51:04 <bos> dons: nope ;-)
19:51:10 <sutats> Cale: Hm, that looks like it.
19:51:21 <edwardk> bos: It was nice meeting you today =)
19:51:28 <bos> hey dons, i benchmarked the new pure haskell PRNG. it's a little faster than mersenne-random.
19:51:34 <dons> whoa.
19:51:38 <bos> edwardk and shapr - you too!
19:51:52 <dons> bos: and threadsafe?
19:51:53 <bos> dons: smaller period, though: 2**8222 vs 2**19937
19:51:59 <bos> dons: runs in the ST monad, so yes
19:52:13 <bos> (I think that 2**8222 is probably enough :-)
19:52:20 <dons> good enough for QuickCheck
19:52:21 <jfoutz> > 2**8222
19:52:22 <lambdabot>   Infinity
19:52:27 <dons> jfoutz: heh
19:52:29 <copumpkin> > 2^8222
19:52:30 <lambdabot>   117118189266459102991624004342371440514514026693566637230018713150635339291...
19:52:31 * jfoutz grins
19:52:37 <copumpkin> > length . show $ 2^8222
19:52:38 <lambdabot>   2476
19:52:41 <copumpkin> pff
19:53:21 <dons> PRNG design seems to involve a lot of magic
19:54:03 <bos> this one seems to have decent bona fides.
19:54:20 <ivanm> bos: which new PRNG is this?
19:54:32 <bos> it even does better on the crush and diehard tests than MT19937.
19:54:44 <bos> ivanm: it's not especially new. MWC8222, aka MWC256.
19:55:21 <Gracenotes> hm, is there a good resource collating various arithmetic algorithms for floating point/2's complement/etc.?
19:55:31 <ivanm> most hits for MWC8222 are for numpy...
19:55:46 <Gracenotes> a more high-level, formal approach, not so much hardware
19:56:05 <ivanm> bos: this? http://en.wikipedia.org/wiki/Multiply-with-carry
19:56:10 <bos> ivanm: yes
19:59:48 <ivanm> anyone have any idea how to alleviate this problem? http://hackage.haskell.org/trac/ghc/ticket/3256
20:50:59 <sohum> this is an extremely /silly/ idea
20:51:17 <sohum> but has anyone ever thought that quantum superpositions act a lot like lazy evaluation?
20:51:49 <SamB_XP> sohum: except lazy evaluation can only represent one future state
20:51:55 <QtPlaty[HireMe]> sohum: Have you read up on the bijunctive values in perl6 and perl5 modules?
20:51:58 <SamB_XP> we just haven't figured out which
20:52:23 <sohum> SamB_XP: isn't the same, effectively, true in superpositions?
20:52:37 <SamB_XP> that, we don't know
20:52:51 <sohum> SamB_XP: we just call it a superposition because pre-observation we have no idea which it's going to resolve to, right?
20:53:01 <sohum> QtPlaty[HireMe]: nope. googling...
20:53:17 <QtPlaty[HireMe]> It jused to be called superpositions.
20:53:19 <QtPlaty[HireMe]> used
20:57:34 <sohum> QtPlaty[HireMe]: do you mean http://search.cpan.org/~dconway/Quantum-Superpositions-1.03/lib/Quantum/Superpositions.pm ? it's fascinating reading...
21:00:46 <sohum> SamB_XP: well, actually, sorry. it's not the actual representational issues of the superposition I meant - more their behaviour under observation. it seems very analogical to something being evaluated only when "required"
21:02:59 <SamB_XP> sohum: ah, yes
21:03:06 <SamB_XP> and we don't actually know how it truly works
21:03:16 <SamB_XP> so maybe it could be more like lazy evaluation than we think ?
21:04:45 <sohum> the universe is a whnf evaluator ;)
22:14:45 <harblcat> hi all
22:15:12 <BMeph> hi harblcat
22:15:25 * ivanm waves aimlessly in harblcat's general direction
22:16:31 <harblcat> I'm wondering about how to implement the "minority game" in haskell... I'm trying with the State monad, but I don't really quite grasp it...
22:17:11 <copumpkin> minority game?
22:17:47 <harblcat> http://en.wikipedia.org/wiki/Minority_game
22:18:29 <harblcat> basically a game where you pick one of two options, and the group that picked the minority wins a point..
22:18:59 <harblcat> I wanted to make a simulation of that with simple agents and such, but I'm not sure how to use so much state in haskell..
22:20:08 <ivanm> preflex: seen malcolmw
22:20:08 <preflex>  malcolmw was last seen on #ghc 13 hours, 34 minutes and 34 seconds ago, saying: when you install snow leopard, you get a choice of which disk volume to install onto
22:31:57 <BMeph> Man, that's funny...and sad: http://learnyousomeerlang.com/
22:34:29 <copumpkin> lol
22:34:35 <copumpkin> BONUS has a secret admirer
22:35:44 <dolio> This is kind of disturbing: http://learnyousomeerlang.com/static/img/worm.png
22:39:32 <copumpkin> wow
22:39:44 <copumpkin> preflex: seen BONUS
22:39:45 <preflex>  BONUS was last seen on #haskell 48 days, 16 hours, 56 minutes and 18 seconds ago, saying: :t catchError
22:39:48 <copumpkin> whoa
22:40:09 <wmealing__> looks like its been a while
22:40:25 <Berengal> Looks like he knows BONUS
22:40:26 <copumpkin> maybe he moved to erlang and that's actually him
22:40:56 <ivanm> >_>
22:41:02 <copumpkin> the most recent tweet on the learnyousomeerlang dude's twitter account is rather o.O-worthy
22:41:05 <dolio> He was probably kidnapped by an erlang zealot, and is being held in his basement, being forced to make the tutorial.
22:41:06 <ivanm> what happened to the print version of LYAH BONUS was planning?
22:41:32 <ivanm> copumpkin: link?
22:41:39 <wmealing__> he didnt finish LYAHFGG yet.
22:41:40 <wmealing__> he must be stopped.
22:41:44 <copumpkin> http://twitter.com/mononcqc
22:42:13 <ivanm> right...
22:42:32 <ivanm> that's definitely a weird message
22:42:47 <dons> looks like a parody of BONUS
22:42:49 <copumpkin> it sort of sounds like he's mocking that viewpoint though, or he's one of those people who are so ridiculous they sound like they're satyrizing themselves
22:42:57 <dons> maybe it is BONUS
22:43:09 <ivanm> BONUS is making fun of himself?
22:43:23 <copumpkin> ivanm: I mean that tweet in particular :)
22:43:36 <wmealing__> About halfway through draft v1.5 of the LYSE chapter on modules. Hang tight, readers. I have not given up. <-- is that bonus ?
22:43:41 <dons> Quebec, Canada isn't where bonus lives
22:43:56 <copumpkin> yeah
22:43:56 <dons> so i think this is a weird hommage to bonus
22:43:58 <Makoryu> I guess this mononcqc fellow (and BONUS) had to take up the slack of _whyness
22:44:15 <dons> ruby is boring anyway :)
22:44:16 <Makoryu> dons: Wasn't LYAH originally an homage to WPGtR?
22:44:20 <wmealing__> http://twitter.com/bonus500 <-- is that bonus ?
22:44:30 <Makoryu> Yeah it falls down face forward
22:44:31 <copumpkin> wmealing__: yep
22:44:33 <ivanm> wmealing__: don't think so...
22:44:37 <ivanm> Makoryu: WPGtR?
22:44:49 <dons> not an explicit hommage
22:44:51 <Makoryu> ivanm: _why's (poignant) Guide to Ruby
22:44:54 <wmealing__> I just drank some decaf and now im driving a tractor while listening to "the final countdown". The 21st century rules <-- sounds like him.
22:45:02 <ivanm> Makoryu: ahhh
22:45:11 <copumpkin> http://twitter.com/mononcqc/status/1377106324
22:45:20 <dons> "also if anyone can write Learn You a Calculus 2 by like .. tomorrow that would be awesome" -- maybe bonus is back at school
22:45:24 <dons> instead of getting published?
22:45:35 <dons> "rly busy with exams, so please don't be mad that there aren't any new LYAH updates or if im not replying to emails! should be over soon"
22:45:42 <copumpkin> http://twitter.com/bonus500/status/1377116928
22:45:44 <dons> hehe. he's getting spammed about LYAH
22:45:52 <Makoryu> http://mislav.uniqpath.com/poignant-guide/ <- For ivanm
22:46:05 <ivanm> Makoryu: I've heard of it
22:46:11 <ivanm> just never seen it as an acronym
22:46:12 <dons> shapr: have you been following the mighty exploits of bonus?
22:46:29 <Makoryu> ivanm: Ah, all right
22:46:33 <dons> very much in the shapr school of community building, imo.
22:46:40 <ivanm> heh
22:46:46 <Nafai> yay for the shapr school
22:46:50 <Nafai> and yay for shapr in school
22:47:02 * wmealing__ laughs
22:47:09 <ivanm> dons: I dind't realise shapr wrote a tutorial whilst high on hallucigonens...
22:47:20 <wmealing__> url ?
22:47:21 <dons> boing!
22:47:31 <wmealing__> hey dons, i stalk you on reddit.  love your work.
22:48:17 <ivanm> wmealing__: for?
22:48:52 <wmealing__> ivanm, shapr's post on hallucigonens
22:49:00 <ivanm> wmealing__: heh didn't
22:49:04 <ivanm> I was referring to LYAH
22:49:31 <ivanm> s/heh/he/
22:50:10 <wmealing__> ah
22:50:22 * wmealing__ shuffles nervously to the back of the room
22:50:32 <ivanm> heh
22:50:43 <Berengal> http://85.200.142.98:5000/quine.html <-- little bit of "look at I wrote", but mainly so I can grep my ip in the logs when I go to work later
22:51:07 <ivanm> Berengal: so rather than just, you know, emailing yourself...
22:51:17 <ivanm> you decide to release it on a public forum to find for work purposes?
22:51:29 <harblcat> why doesn't "scanl (,) 1 [1,2,3,4]" work?
22:51:42 <Makoryu> :t scanl (,)
22:51:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
22:51:45 <lambdabot>       Expected type: a
22:51:45 <lambdabot>       Inferred type: (a, b)
22:51:46 <Berengal> ivanm, not work purposes, procrastination purposes.
22:52:05 <dolio> It'd need to have a dependent type.
22:52:08 <ivanm> heh
22:52:13 <Makoryu> harblcat: Because you can't match the type foo with (foo, bar)
22:52:37 <copumpkin> > scanr (:) [] [1..4]
22:52:38 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
22:52:40 <copumpkin> yay
22:52:42 <dolio> Or, even then it wouldn't work, because lists are homogeneous.
22:53:35 <copumpkin> > scanl (flip (:)) [] [1..4]
22:53:36 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1]]
22:54:04 <copumpkin> > zipWith (++) (scanr (:) [] [1..4]) (scanl (flip (:)) [] [1..4])
22:54:04 <lambdabot>   [[1,2,3,4],[2,3,4,1],[3,4,2,1],[4,3,2,1],[4,3,2,1]]
22:54:29 <copumpkin> pretty exciting if you ask me
22:55:03 <dolio> > zipWith (++) (tails [1..4]) (inits [1..4])
22:55:04 <lambdabot>   [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4]]
22:55:58 * harblcat has his mind boggled.
22:56:38 <sereven> copumpkin: how many more revisions till it'
22:56:52 <sereven> meh... till it's a live coding concert
22:57:08 <copumpkin> about 2.7 revisions
22:57:23 <copumpkin> e, to be exact
22:57:27 <ivanm> a "coding concert"?
22:57:29 <sereven> hehe
22:57:40 <Makoryu> harblcat: Anyway, two tuples have the same type if and only if their contents (in order) have the same types. For example, (5, "pizza") is a different type from ("pizza", 5)
22:57:42 <sereven> ivanm: live coding ala yaxu
22:57:51 <ivanm> Berengal: how long did it take you to get the quine bit working?
22:58:00 <harblcat> I see..
22:58:41 <Berengal> ivanm, the quine bit is easy, although I strugled a bit to put it in the middle of the program. That seems to require some proper string processing though, so I used the usual trick of putting it at the end
22:59:06 <ivanm> heh
22:59:12 <Berengal> (The string itself was just the program run through s/\n/\\n/g)
22:59:18 <ivanm> lol
22:59:34 <Berengal> Oh, and s/"/\"/g
22:59:41 <ivanm> with the "(++) <*> show" being the actual quine-ing bit?
22:59:42 <Makoryu> harblcat: Lists are homogenous, which means that for all lists, any two items x and y taken from the list must have the same type
22:59:47 <Berengal> Yep
23:00:58 <Makoryu> harblcat: Some programmers are bothered by this restriction enough that they defect to dynamically typed languages such as Common Lisp. Don't be seduced by the lack of type safety!
23:02:12 <copumpkin> you can stuff multiple types into a single list too if you really want to!
23:02:17 <dons> you donn't need dynamic types to do this.
23:02:34 <dons> just a type rich enough to capture the possible values you're putting in.
23:03:30 <Makoryu> dons: True. You could have "data Foo a b c ... = T1 a | T2 (a, b) | T3 (a, b, c) | ...
23:03:33 <Makoryu> "
23:04:46 <copumpkin> you might as well drop the tuples then
23:05:00 <dons> or an existential, data T = forall a. Eq a => T a
23:05:07 <dons> i.e. things that have an (==).
23:05:11 <dons> static 'duck' typing.
23:05:52 <dons> lisp is just [Dynamic]
23:06:13 <dons> i.e. all type checks are notionally deferred to runtime checks, and anything can be stored, no matter what methods it actually supports
23:06:48 <dons> :k Any
23:06:49 <lambdabot> *
23:06:55 <dons> > 1 :: Any
23:06:56 <lambdabot>   No instance for (GHC.Num.Num Data.Monoid.Any)
23:06:56 <lambdabot>    arising from the literal `...
23:07:12 <dons> > Any
23:07:13 <lambdabot>   {True->Any {getAny = True};False->Any {getAny = False}}
23:07:19 <dons> huh
23:09:35 <Cale> heh
23:09:41 <Cale> Inconsistent imports it seems
23:10:17 <Cale> > getAny (map Any [False, False, True])
23:10:18 <lambdabot>   Couldn't match expected type `Data.Monoid.Any'
23:10:18 <lambdabot>         against inferred typ...
23:10:22 <Cale> er
23:10:34 <Cale> > getAny (mconcat (map Any [False, False, True]))
23:10:34 <lambdabot>   True
23:10:52 <Cale> > getAny (mconcat (map Any [False, False, False]))
23:10:53 <lambdabot>   False
23:11:38 <copumpkin> > Sum
23:11:39 <lambdabot>   {()->Sum {getSum = ()}}
23:11:41 <copumpkin> whoa
23:12:02 <copumpkin> > Sum :: Word8 -> Sum Word8
23:12:03 <lambdabot>   No instance for (Test.SmallCheck.Serial GHC.Word.Word8)
23:12:03 <lambdabot>    arising from a u...
23:12:20 <copumpkin> interesting
23:12:45 <copumpkin> > (\_ -> 5) :: Bool -> Int
23:12:46 <lambdabot>   {True->5;False->5}
23:23:50 <Cale> > Sum :: Integer -> Sum Integer
23:23:51 <lambdabot>   -3->
23:23:51 <lambdabot>    Sum {getSum = -3}
23:23:51 <lambdabot>  -2->
23:23:51 <lambdabot>    Sum {getSum = -2}
23:23:51 <lambdabot>  -1->
23:23:53 <lambdabot>    Sum {getSum =...
23:24:12 <copumpkin> I guess the smallness of smallcheck shows there :)
23:24:35 <ivanm> :o
23:24:42 <ivanm> what did lambdabot just do?
23:24:58 <copumpkin> enumerated the domain and showed you the output for each element
23:25:14 <Cale> > (&&)
23:25:15 <lambdabot>   {True->{True->True;False->False};False->{True->False;False->False}}
23:25:30 <copumpkin> I was tempted to do that for my enumerable package, but got lazy
23:25:40 <copumpkin> I guess the enumerable package is just a less featureful smallcheck, in the end :)
23:25:52 <Cale> > (/=) :: Bool -> Bool -> Bool
23:25:53 <lambdabot>   {True->{True->False;False->True};False->{True->True;False->False}}
23:26:15 <SubStack> I am unsure whether copumpkin just made a lazy evaluation joke.
23:26:30 <copumpkin> SubStack: not intentionally :)
23:26:55 <SubStack> well it was good at any rate
23:27:34 <SubStack> back to my bit-vector instruction set I go
23:28:15 <SubStack> it's in haskell naturally, and there are lots of stacks
23:28:22 <SubStack> and infinite memory!
23:29:05 <copumpkin> :)
23:29:14 <copumpkin> lots of stacks sounds good
23:29:31 <copumpkin> if you have two stacks you are turing complete
23:29:42 <copumpkin> with three stacks you can compute the uncomputable
23:29:46 <copumpkin> in constant time
23:29:51 <harblcat> lol
23:30:38 * copumpkin still loves his pronunciation of harblcat's nickname
23:31:01 <harblcat> how do you pronounce it?
23:31:10 <copumpkin> harbl = drawled 'horrible'
23:31:21 <copumpkin> :)
23:31:23 <ivanm> it is? :o
23:31:33 <harblcat> :(
23:31:42 <ivanm> @slap copumpkin
23:31:42 <lambdabot> stop telling me what to do
23:31:45 <harblcat> it's meant to be the yiddish 'harble'...
23:31:47 <ivanm> stop being mean to harblcat!
23:32:04 <copumpkin> harblcat: oh, I didn't mean you're horrible, I just find that pronunciation (in my head) amusing so it's what I think of when I see your nick :P
23:32:07 <ivanm> harblcat: that's how I was pronouncing it, even though I've never heard of the word "harble"
23:32:17 * ivanm usually does literal pronounciations
23:32:29 <harblcat> copumpkin: no worries, I know :)
23:32:35 <medfly> I have no idea why you'd be trying to pronounce people's nicknames.
23:32:55 <harblcat> you have to have a way to 'hear' it in your head, don't you?
23:33:46 <medfly> I guess it comes with being horrible at English pronunciation of stuff :p
23:41:25 <harblcat> I'm trying to update a key-value pair in a list.. is there an easy way to do this?
23:42:01 <harblcat> I know of lookup, but I need something like an update :: a -> b -> [(a,b)] -> [(a,b)] ...
23:42:13 <copumpkin> map?
23:42:19 <copumpkin> not too pretty though
23:43:00 <mauke> why does it have to be a list?
23:43:17 <harblcat> well, it *doesn't*, it's just what I'm using right now.
23:43:26 <harblcat> keeping it simple?
23:43:39 <mauke> Data.Map seems simpler
23:43:59 * harblcat feels like a herp-derp..
23:45:28 <DOKKA> hey yall, I cannot for the life of me get this simple program to work. any help at alll would be appreciated. I just put it online www.letsall.hopto.org/binc.hs
23:45:30 <Cale> harblcat: There's nothing like that... while you *could* write it yourself, it's not a great idea performance wise, and Data.Map has lots of other useful functions already.
23:45:59 <wmealing__> DOKKA, 404.
23:46:26 <DOKKA> gah, hold on. I'll try it again
23:46:30 <Cale> harblcat: Probably if you're just hacking something away and you don't care about performance and don't want to switch datatypes, you could use... [(x,if y == k then r else y) | (x,y) <- xs]
23:46:57 <Elench> It's http://letsall.hopto.org/binc.hs
23:47:04 <Elench> No www
23:47:59 <copumpkin> lol, http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/src/Acme-Time-Now.html#now
23:48:06 <Cale> DOKKA: Problem is that you're passing binc' just one pair, when it's supposed to take two numbers
23:48:28 <Cale> DOKKA: binc' (x, y+1)  ~~~>  binc' x (y+1)
23:48:30 <harblcat> Cale: I guess I should learn Data.Map, though...
23:48:44 <DOKKA> It is getting two numbers, right?
23:49:06 <Cale> DOKKA: Or, you could change the left hand side of the equation, from  binc' x y  to binc' (x,y)
23:50:06 <DOKKA> but how should I increment y?
23:51:16 <DOKKA> Cale: ooohhh, I see what you mean.
23:51:40 <Cale> > let binc x | x < 1 = 0 | otherwise = binc' x 1; binc' x y | 2^y > x = 2^(y-1) | otherwise = binc' x (y+1) in binc 3281904417
23:51:40 <lambdabot>   2147483648
23:52:10 <Cale> Or:
23:52:29 <Cale> > let binc x | x < 1 = 0 | otherwise = binc' (x,1); binc' (x,y) | 2^y > x = 2^(y-1) | otherwise = binc' (x,y+1) in binc 3281904417
23:52:30 <lambdabot>   2147483648
23:52:49 <Cale> But the usual convention in Haskell is not to tuple the arguments together unless there's a really good reason.
23:53:09 <DOKKA> oh, I'm sorry. too much c++.
23:53:28 <DOKKA> I thought that was how to call a function
23:53:50 <DOKKA> thanks :)
23:53:58 <Cale> no problem :)
23:54:15 <harblcat> is there a way to import a module, masking certain functions?
23:55:43 <ivanm> import Foo hiding (blah)
23:56:04 <ivanm> harblcat: ^^
23:56:51 <harblcat> ahh.. thanks!
23:57:43 * shapr yawns
