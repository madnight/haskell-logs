00:00:41 <Quadrescence> français?
00:00:47 <Quadrescence> http://www.youtube.com/watch?v=wpvcyJ5fKuA
00:01:08 <ivanm> blackdog: yeah, that's the one
00:01:52 <blackdog> would it be evil to define something similar to Map.lookup as "!"?
00:02:05 <blackdog> you'd have to import Array qualified, i suppose...
00:02:19 <mmorrow> @type (Data.Map.!)
00:02:21 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
00:02:46 <blackdog> ha, i never saw that. So Ruby.! would be reasonable...
00:13:25 <bastl> good morning, dcoutts: is there an example or documentation for the usage of preprocessors like ppHappy ? (which is in fact exactly what I need ...)
00:17:42 <dazza_> im almost there..
00:21:47 <dazza_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9250#a9250 .. there has to be a way...hmm
00:27:06 <EnglishGent> hi all ... bit of a problem - I've just upgraded to ghc 6.10.4 - and in ghci :!cd no longer seems to work - it doesnt produce an error, but nor does it change the working directory
00:27:13 <EnglishGent> it _did_ in the older version
00:27:16 <EnglishGent> help?! :|
00:30:16 <harlekin> EnglishGent, you can use :!cd.
00:31:00 <harlekin> Mh, that apparently doesn't change ghci's current working directory.
00:31:07 <ivanm> hmmm, doesn't work here either..
00:31:15 <ivanm> how about :cd ?
00:31:18 <ivanm> ;-)
00:31:25 <ivanm> works here...
00:31:31 <harlekin> Oh, yeah. :cd works here, too.
00:31:46 <ivanm> yay for :help ! ;-)
00:32:09 <harlekin> That doesn't seem to solve EnglishGent's problem, though. ^^
00:32:25 <ivanm> harlekin: how doesn't it?
00:32:31 <harlekin> EnglishGent, does your path exist you're using :cd with?
00:32:39 <ivanm> harlekin: he's using :!cd ...
00:32:41 <ivanm> not :cd
00:32:48 <harlekin> My bad.
00:32:52 <EnglishGent> let me try :cd
00:33:20 <EnglishGent> ah - okay - that works (:cd)
00:33:31 <EnglishGent> I thought you had to use :! to change path
00:33:39 <EnglishGent> and thanks ivanm, harlekin :)
00:33:41 <harlekin> You use :! to issue commands in the shell.
00:34:03 * EnglishGent is a haskell newbie & panicked when a command he knew suddenly stopped working!
00:34:55 <EnglishGent> whilst I'm here .. can I also ask how GHC determines what directories to look in for files? I'm assuming there is some search path specifying directories other than the current one
00:36:02 <sinelaw> how do i do integer division?
00:36:06 * EnglishGent just wanted to be able to change the directory GHCi was looking for source files in - it's still odd that :!cd doesnt work anymore - but leaving out the ! is a trivial solution :)
00:37:06 <dm`> Why would :!cd work?  That should spawn a shell, but cd only changes the current process's working directory, not the parent.
00:37:34 <Saizan_> EnglishGent: it searches in the current directory by default, you can add more with the -i flag
00:37:54 <EnglishGent> it did before dm` - and it was what I was using until now
00:38:00 <EnglishGent> why it worked before I dont know
00:38:02 <sinelaw> > 3/2
00:38:06 <lambdabot>   1.5
00:38:11 <sinelaw> i want 1
00:38:12 <EnglishGent> and thanks Saizan_
00:38:17 <ski> > 3 `div` 2
00:38:22 <lambdabot>   1
00:38:24 <sinelaw> ah.
00:38:26 <dm`> Shouldn't work on Unix, but maybe in some other OSes the concept of working directory isn't tied to a process or something.
00:38:35 <ski> > 17 `divMod` 7
00:38:40 <lambdabot>   (2,3)
00:38:44 <EnglishGent> I still assume there must be a set of defaults though? (where does it get the prelude from?)
00:39:44 <Saizan_> EnglishGent: the libs are quite different, they are registered through ghc-pkg
00:39:58 <Saizan_> EnglishGent: "ghc-pkg list" for a list of the installed ones
00:40:13 <EnglishGent> ty! :)
00:40:22 <Saizan_> EnglishGent: and e.g. "ghc-pkg describe base" to see the files relative to Prelude etc..
00:40:33 <dm`> Try ghc --print-libdir
00:41:05 <dm`> But it's confusing.  It also seems to consult files in ~/.ghc/...
00:41:24 <Saizan_> ghc --print-libdir tells you where ghc is installed, primarily
00:41:50 <Saizan_> under .ghc/ you've the user package db, in --print-libdir there's the global one, usually
00:42:25 <Saizan_> but other libs (even if installed as global) won't have their files installed in --print-libdir
00:43:42 <EnglishGent> thanks all :)
00:44:52 <dm`> http://www.haskell.org/ghc/docs/6.10.2/html/users_guide/packages.html
00:46:10 <sinelaw> how do I undefine a @let in lambdabot?
00:46:50 <EnglishGent> I'm reading that now dm` :)
00:47:10 <sinelaw> nvm
00:47:17 <ski> @help undefine
00:47:17 <lambdabot> undefine. Reset evaluator local bindings
00:47:25 <dm`> Now if only someone could tell me how to have cabal use haddock --hyperlink-source by default...
00:47:31 * EnglishGent has been using haskell for only slightly over 2 weeks at this point .. until now I was still getting comfortable with the core language - I'm beginning to branch out into the tool chain now
00:47:39 <EnglishGent> :D
00:49:23 <sinelaw> why doesn't this work?
00:49:27 <sinelaw> @let merge [] [] = []; merge [x] [y] = if (x>y) then [y,x] else [x,y] ; merge (x:xs) (y:ys) = (merge [x] [y]) ++ (merge xs ys)
00:49:29 <lambdabot>  Defined.
00:49:33 <sinelaw> that works ok
00:49:46 <sinelaw> but this gives a stack overflow:
00:49:46 <sinelaw> @let mergesort [] = []; mergesort [a] = [a]; mergesort xs = merge (mergesort (take ((length xs) `div` 2) xs)) (mergesort (drop ((length xs) `div` 2) xs))
00:49:48 <lambdabot>  Defined.
00:49:57 <sinelaw> > mergesort [1,4,2,52,5]
00:50:02 <lambdabot>   [1,2* Exception: <local>:1:0-120: Non-exhaustive patterns in function merge
00:50:24 <sinelaw> oops, that didn't happen before. i'll use an even length lsit
00:50:26 <sinelaw> > mergesort [1,4,2,52,5,2]
00:50:31 <lambdabot>   [1,2* Exception: <local>:1:0-120: Non-exhaustive patterns in function merge
00:50:40 <sinelaw> :(
00:50:50 <Saizan_> > mergesort [1,4,2,5,2,5,2]
00:50:55 <lambdabot>   [1,2* Exception: <local>:1:0-120: Non-exhaustive patterns in function merge
00:50:55 <c_wraith> needs to be a power of two size
00:50:59 <c_wraith> the way your merge is written
00:51:02 <sinelaw> oh, right.
00:51:07 <sinelaw> > mergesort [1,4,2,52,5,2,2,3]
00:51:12 <lambdabot>   [1,2,2,2,3,4,5,52]
00:51:43 <sinelaw> now i see why it's non-exhaustive
00:51:49 <sinelaw> @undef
00:52:09 <sinelaw> @let merge [] [] = []; merge [] ys = ys; merge xs [] = xs; merge [x] [y] = if (x>y) then [y,x] else [x,y] ; merge (x:xs) (y:ys) = (merge [x] [y]) ++ (merge xs ys)
00:52:11 <lambdabot>  Defined.
00:52:17 <sinelaw> @let mergesort [] = []; mergesort [a] = [a]; mergesort xs = merge (mergesort (take ((length xs) `div` 2) xs)) (mergesort (drop ((length xs) `div` 2) xs))
00:52:19 <lambdabot>  Defined.
00:52:22 <sinelaw> > mergesort [1,4,2,52,5,2]
00:52:26 <lambdabot>   [1,2,2,52,4,5]
00:52:39 <sinelaw> ok, i'll be back later with less bugs
00:58:51 <EnglishGent> ghc doesnt install the source for the prelude does it?
00:59:16 * EnglishGent looking in /usr/lib/ghc-6.10.4/base-4.1.0.0 as listed by ghc-pkg describe base
01:00:17 * EnglishGent finishes coffee #1!
01:00:34 * EnglishGent hoping to make progress more rapidly when not half asleep! :)
01:02:35 <sinelaw> merge was wrong
01:03:00 <elbar> hoogle composeAll
01:03:04 <elbar> @hoogle composeAll
01:03:05 <lambdabot> No results found
01:04:00 <EnglishGent> btw... a newbie question (asked in wrong window earlier - see what a lack of caffine does to you!) - but why is Map a type & not a type class?
01:04:14 <EnglishGent> I would have expected the latter - so that association lists, etc can implement it
01:04:24 <harlekin> Is there a way to lift finally in a (MonadIO m) => Monad m?
01:04:25 <EnglishGent> someone said something about IntMap - but I didnt understand :|
01:05:01 <EnglishGent> oh - hi ivanm :)
01:05:08 <Saizan_> EnglishGent: IntMap would be another dictionary-like datatype
01:05:42 <sinelaw> @let merge [] [] = []; merge [] ys = ys; merge xs [] = xs; merge [x] [y] = if (x>y) then [y,x] else [x,y] ; merge (x:xs) (y:ys) = if (x<y) then [x] ++ (merge xs (y:ys)) else [y] ++ (merge (x:xs) ys)
01:05:44 <lambdabot>  Defined.
01:05:49 <sinelaw> @let mergesort [] = []; mergesort [a] = [a]; mergesort xs = merge (mergesort (take ((length xs) `div` 2) xs)) (mergesort (drop ((length xs) `div` 2) xs))
01:05:50 <lambdabot>  Defined.
01:05:57 <sinelaw> now can anyone offer a shorter implementation? :P
01:06:12 <Saizan_> EnglishGent: a class to abstract over the concrete implementation of the dictionary might be nice, there are some in the edison library, but they didn't get popular for some reason
01:06:32 <EnglishGent> okay - just curious
01:06:35 <Botje> sinelaw: splitAt (length xs `div` 2)
01:06:37 <EnglishGent> thanks Saizan_ :)
01:07:03 <Saizan_> sinelaw: the merge [x] [y] case looks redundant now
01:07:34 <Saizan_> however length is O(n)
01:07:48 <Saizan_> so mergesort is better implemented bottom-up over lists
01:08:22 <sinelaw> i see. how would i do it bottom up?
01:08:32 <mmorrow> Saizan_: i just realized that i can simply snake ObjLink, and use that in combination with this GenAsm module i have from earlier (uses vacuum and generates the asm for the closures that get sucked up (only x86_64 currently, but it's only data, no code)) to be able to reify a .o (vacuum -> GenAsm -> .s -as-> .o -ObjLink-> exists a. a) without needing to link to the ghc pkg http://moonpatio.com/repos/revive/
01:09:00 <mmorrow> Saizan_: err, this is the test i just did that worked perfectly http://moonpatio.com/repos/revive/GHC/Vacuum/Revive.hs
01:10:03 <mmorrow> Saizan_: the only thing is that you need to know what .o files you need to load (and in the correct order), which isn't stored anywhere (well, in .hi files if you want to parse those), or you could just parse the .o files yourself and get the info that way (which is what i'm thinking i'll do)
01:10:58 <pozic> I downloaded the binary ghc-6.10.4 release and did cabal install ghci-haskeline. ghci-haskeline core-dumps. ghci can be run without problems.
01:11:04 <bastl_away> has anyone used cabal preprocessing? im looking for examples. the cabal user-guide says nothing about it.
01:11:41 <Saizan_> bastl_away: from the Setup.hs hooks?
01:12:01 <bastl> yes.
01:12:05 <Saizan_> mmorrow: using the ghc-api to parse the .hi files looks more maintenable
01:12:10 <bastl> i want to invoke happy before compiling
01:12:19 <mmorrow> Saizan_: well, i already have an ELF parser..
01:12:35 <mmorrow> Saizan_: and that format never changes
01:13:06 <mmorrow> Saizan_: but yeah, that may be better (.hi files) in the end, not sure the considerations yet
01:13:21 <mmorrow> Saizan_: the only thing is that i want to not have to depend on the ghc-api
01:13:35 <mmorrow> (depend := "link to in any way")
01:14:42 <mmorrow> well, osx doesn't use elf
01:14:44 <mmorrow> grr
01:15:27 <mmorrow> i'll have to look at what the old hs-plugins did to resolve .o deps
01:15:46 <mmorrow> (the new one too, but i know that uses the ghc-api)
01:15:56 <Saizan_> bastl: in the normal cabal flow the preprocessors are called from initialBuildSteps
01:17:25 <Saizan_> which is called before compiling, and happy is one of the builtin ones
01:17:38 <Saizan_> so i don't understand completely your problem
01:18:09 <dancor> can i get from (ProcessHandle) to (Maybe Int) the pId on linux?
01:18:34 <bastl> Saizan: but how do i declare the preprocessing ? any examples ?
01:19:22 <Saizan_> bastl: your file just need to be in the source tree and have the right extension
01:19:42 <Saizan_> bastl: and listed in the .cabal file
01:19:56 <Saizan_> bastl: in exposed- or other- modules
01:20:18 <Saizan_> so, for happy, it must be .y or .ly
01:20:22 <Saizan_> iirc
01:21:32 <bastl> Saizan_: ok, i see. still any example would be much much quicker to learn than to experiment on my own  with these tips ...
01:22:15 <bastl> is there Language.XX package in hackage that is built like this ?
01:22:19 <Saizan_> i didn't realize it would be obscure
01:23:12 <Saizan_> bastl: see the happy package itself, it has .ly files
01:23:25 <bastl> Saizan: ok, thx
01:25:58 <mmorrow> , length (let a = (); b = (a,a); c = (b,b); d = (c,c); e = (d,d); f = (e,e) in show f)
01:25:59 <lunabot>  157
01:26:06 <mmorrow> , length (let a = (); b = (a,a); c = (b,b); d = (c,c); e = (d,d); f = (e,e) in vacuum f)
01:26:08 <lunabot>  6
01:26:10 <mmorrow> :)
01:27:04 <mmorrow> gas could be cut out of the process too, if you can build your own .o's (the relocation info is why the .o's are needed)
01:31:20 <bastl> is there a tool to build a simple dependency graph for haskell functions?
01:32:03 <bastl> something like "plot Module.hs -> Module.dot" ?
01:36:52 <mmorrow> bastl: there's one on hackage to build the type-dependency graph, but there's nothing (packaged) to do the analog for functions in a module
01:37:46 <mmorrow> bastl: although in principle it wouldn't be that hard. you'd need to define a freeVars function on the Exp type (and all reachable types from Exp) from haskell-src-exts, then it'd be just a matter of writing a simple driver prog
01:39:21 <bastl> mmorrow, would be nice to have, but takes to much effort :-/
01:39:22 <Saizan_> mmorrow: why the .o files for libraries can't be linked in statically?
01:40:05 <mmorrow> Saizan_: oh yeah, they definitely can (and that makes things super simple too)
01:40:36 <mmorrow> Saizan_: i'm thinking about the case where you want to reify a dynamically serialized piece of data that you e.g. just got from the network
01:42:03 <mmorrow> Saizan_: linking the data in statically is 90% "solved", in the sense that i just need to extend `GenAsm' to print for x86 and osx too, as well as make sure i'm really laying the static closures out correctly with JaffaCake
01:42:23 <Saizan_> mmorrow: not the data, only the libraries like containers-$ver.o
01:43:08 <mmorrow> Saizan_: oh. yeah, you can do that too, although then you'd be using dlopen/dlsym to get at the symbols
01:44:04 <mmorrow> (but that gets borked in ghci since ghci is linking in all kinds of stuff, and the runtime dynamic linker and the ghci linker don't know about each other's syms
01:44:39 * Saizan_ has no idea how that would look like
01:45:00 <mmorrow> Saizan_: but yeah, that's an interesting possibility too, although i'm sure off the top of my head to do that
01:45:40 <mmorrow> like for instance, say you have a C program:
01:46:09 <Saizan_> well, in my use case i've the same process which serializes and deserializes, so the libs won't change, and it'd be nice to not depend on external files for it to work
01:46:22 <Saizan_> s/process/executable/
01:46:27 <mmorrow> #include <stdio.h> #include <dlfcn.h>  int foo(int x){return x*2;}  main(){ printf("%p == %p\n",foo,dlsym(NULL,"foo"));}
01:46:45 <mmorrow> both of those would point to foo
01:47:22 <mmorrow> so dlsym can see the syms of the current program, since dlsym just calls the dynamic linker which is linking the executable itself on-the-fly
01:48:20 <mmorrow> so i guess dlsym could just give you syms that are statically linked into the current haskell prog just the same (maybe), but maybe there's a catch (??)
01:49:19 <Saizan_> so the idea is to make mymap.s call dlsym, anyhow?
01:49:45 <mmorrow> so you'd have the raw data that mymap.s would assemble to in a buffer firstly
01:50:17 <mmorrow> then you'd also need to know where in that data are the (currently unresolved (:= relocated)) references to various foo_static_info
01:50:39 <mmorrow> then for each of those, find its current address, and write that into the appropriate offset into the data
01:50:47 <mmorrow> at which point you can then call addrToHValue#
01:52:01 <chat> Hi all
01:52:02 <mmorrow> Saizan_: so mymap.s wouldn't have any executable code in it
01:52:07 <chat> I'm new to haskell
01:52:15 <Saizan_> hi
01:52:44 * ivanm waves aimlessly in chat's general direction
01:53:00 <Saizan_> mmorrow: ah, k, we'd mangle it from the outside instead
01:53:04 <chat> haa hi
01:53:11 <mmorrow> Saizan_: right
01:54:10 <mmorrow> Saizan_: so you'd need (raw data, relocation info), where relocation_info = [(SynName,Offset)]
01:54:20 <mmorrow> *SymName
01:54:29 <ivanm> mmorrow: if that's what relocation_info is, what is "relocation info"? :p
01:54:50 * ivanm must really be bored, if he's picking on the lack of an underscore...
01:54:50 <quicksilver> mmorrow is trying to make a place for serialising closures?
01:54:59 <mmorrow> ivanm: and external reference that needs resolving
01:55:10 <mmorrow> quicksilver: ;)
01:55:39 <quicksilver> s/place/plan/
01:56:05 <Saizan_> well, it seems to already work, to some extent
01:56:37 <mmorrow> quicksilver: i just got `test0' in here to work nicely (and avoided any linking with ghc, by stealing ObjLink) http://moonpatio.com/repos/revive/GHC/Vacuum/Revive.hs
01:57:44 <Saizan_> mmorrow: why are you avoiding linking to ghc so much? clashing symbols or something?
01:57:44 <mmorrow> quicksilver: so gas is only used as a convenient way to generate the relocation info for mymap.s, but mymap.s has no executable code. so gas could be bypassed completely by either generating a .o directly, and using ObjLink, /or/ just doing the linking yourself
01:58:13 <chat> Has anyone installed hugs on vista? I got an error saying that winhugs98.chm could not be extracted
01:58:15 <mmorrow> Saizan_: just to stay lightweight and insulated against any volatility wrt interface
01:58:37 <fasta> chat: if you want to learn Haskell, install Helium first.
01:58:41 <mmorrow> Saizan_: and also because your prog then become 30+MB min..
01:58:48 <fasta> chat: then skip hugs and install ghci/ghc.
01:59:20 <fasta> chat: Helium is a dumbed down Haskell with better error messages.
01:59:21 <Saizan_> mmorrow: don't you get exposed to volatility against implementation then? however i guess you're already as tightly coupled as it gets..
01:59:47 <fasta> "Better" for new users at least.
01:59:51 <mmorrow> Saizan_: yeah, if the runtime layout of closures changes, but that can't be helped
02:00:05 <chat> fasta: Thanks. I'll install that as well.
02:00:05 <quicksilver> mmorrow: why does mymap.s have no executable code?
02:00:28 <mmorrow> quicksilver: it's just the memory layout of static closures rendered in asm
02:01:09 <mmorrow> quicksilver: where closure := [Ptr InfoTable, [Word], [possibly a Word for the GC]]
02:01:10 <fasta> chat: and if you want to learn Haskell, just read all the real books you can find and most importantly have something useful to work on. Even Project Euler would work, I guess, but I prefer projects that haven't been done a million times before.
02:01:23 * wmealing_ laughs
02:01:32 <wmealing_> well, there are no shortages of hints with euler.
02:01:42 <mmorrow> quicksilver: so the only parts of mymap.s that need patching/relocating are the info ptrs to foo_static_info
02:01:59 <mmorrow> quicksilver: oh, i'll paste mymap.s
02:02:28 <chat> fasta: I'm just looking into haskell and it's bindings for opengl. Friends have been pushing me to look into haskell for weeks and I've finally caved.
02:03:01 <fasta> chat: you shouldn't accede to group pressure ;)
02:03:43 <chat> fasta: *laugh* probably true. The language itself is rather attractive too. So it's not entirely peer pressure.
02:05:11 <mmorrow> quicksilver: here's a shorter asm dump http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3554#a3554
02:05:18 <mmorrow> of (42::Int,1::Double,[0..2])
02:05:46 <mmorrow> preflex: zdec ghczmprim_GHCziTuple_ZLz2cUz2cUZR_static_info
02:05:46 <preflex>  ghc-prim_GHC.Tuple_(,,)_static_info
02:08:08 <mmorrow> quicksilver, Saizan_: and then these are the relocations you need to do by some means before you can addrToHValue# it http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3554#a3555
02:09:05 <mmorrow> (err, so yeah the absolute refs to *_static_info's need relocating, as well as the absolute refs to other closures w/in this data graph itself
02:09:45 <quicksilver> mmorrow: OK, I understand.
02:10:00 <quicksilver> mmorrow: so this is quite local to a very specifically compiled module
02:10:07 <rio> chat: i'd rather start learning the basics of the language before you jump into things like opengl
02:10:15 <quicksilver> in particular, references to anonymous functions are quite volatile aren't they?
02:10:18 <quicksilver> the symbol name, I mean.
02:10:34 <mmorrow> quicksilver: oh. yeah, so this can only do closures made completely of data cons
02:11:11 <chat> rio: This is true. But I have to present on using opengl in haskell in 2 weeks at the haskell usergroup at MIT. So I've cut my time a little short.
02:11:15 <Saizan_> no existentials then?
02:11:33 <mmorrow> quicksilver: so you gain the ability to preserve all sharing, over say Data.Binary, but you still don't have the ultimate in cool ability to serialize /anything/
02:11:37 <chat> Good night all! I've got to sleep. 1 hour to get up for work!
02:11:55 <mmorrow> Saizan_: as long as the existential data isn't a function
02:12:08 <mmorrow> Saizan_: vacuum can see right through any existentials
02:12:23 <mmorrow> (since it's operating on the runtime in-memory rep)
02:13:37 <mmorrow> oh. ok, so how vacuum is able to figure out what the C/asm symbol for the static_info table given a vacuum'ed piece of data is, is because the info table for constructors has
02:13:51 <mmorrow> a string containing Package.Module.Constructor
02:15:26 <mmorrow> ghci> (fmap summary . Data.IntMap.elems . vacuum) (unsafeCoerce () :: Maybe (Either Int Bool))
02:15:26 <mmorrow> [(["ghc-prim","GHC.Unit","()"],[],[])]
02:16:39 <mmorrow> iirc this string in the infotable was added to support the debugger
02:16:48 <mmorrow> so good thing that happened..
02:17:02 <jpcooper> hello
02:17:18 <jpcooper> say I'm doing a mapM, how do I ensure that the resultant list is fully evaluated before I use it?
02:17:37 <lilac> jpcooper: do you want to evaluate the spine or all the elements too?
02:17:50 <lilac> 'length' is pretty common for forcing a list's spine to be evaluated
02:17:58 <jpcooper> the elements must also be evaluted
02:18:24 <lilac> do you want the elements in whnf or rnf?
02:18:43 <jpcooper> actually I've written a mapUntilExcept function which is (a -> IO b) -> [a] -> IO [b]
02:18:55 <jpcooper> mapUntilExcept fun (x : xs) = catch (liftM2 (:) (fun x) $ mapUntilExcept fun xs) . const . return $ []
02:18:55 <jpcooper> mapUntilExcept _ [] = return []
02:18:57 <quicksilver> mmorrow: someone posted some code to the -cafe a while ago which creates maximumal sharing on read
02:19:12 <jpcooper> though I'm not sure that an exception will be thrown while that is being called
02:19:14 <quicksilver> mmorrow: (it doesn't recreate the same level of charing, it creates maximal sharing)
02:19:23 <mmorrow> quicksilver: oh? interesting
02:19:31 * mmorrow looks that up
02:19:37 <jpcooper> lilac, maybe I should do a combination of evaluating fun x and calling length on the resultant list?
02:19:38 <quicksilver> mmorrow: I tried to search my mailbox for it the other day and couldn't find it and now I'm heading into a meeting
02:19:46 <quicksilver> mmorrow: I can't remember the subject line :(
02:20:47 <lilac> jpcooper: that ought to do the trick. otherwise there's 'rnf' if your 'b' is an instance of NFData
02:20:49 <jpcooper> lilac, or maybe you could tell me a better way in which to map an action over an infinite list until an exception is raised, and still keep the result until the exception
02:21:13 <jpcooper> what does whnf mean?
02:21:21 <Zao> weak head normal form
02:21:24 <jpcooper> thanks
02:21:38 <Zao> http://en.wikibooks.org/wiki/Haskell/Graph_reduction#Weak_Head_Normal_Form
02:21:39 <lilac> "Weak Head Normal Form" means reduced to a constructor applied to (some stuff)
02:21:48 <lilac> where (some stuff) can still be unevaluated
02:22:33 <Saizan> jpcooper: and IO exception or a pure one?
02:22:43 <jpcooper> lilac, how about if I evaluated the call to mapUntilExcept? Would I still get the same result?
02:22:59 <jpcooper> Saizan, they will most probably be exception arising from reading or writing to a closed handle
02:23:17 <jpcooper> what I could do is catch the exception inside the actual action instead of all of this
02:23:35 <Saizan> so they should be IO exceptions, so you don't need to mess with evaluation
02:23:38 <lilac> jpcooper: if it were me, i'd write a separate function which took IO a -> IO (Either String a), which did the 'catch'
02:23:55 <Saizan> just catch suffices
02:23:58 <lilac> jpcooper: then do takeWhile isRight $ mapM f xs
02:24:06 <jpcooper> aah thanks
02:24:35 <Saizan> "takeWhile foo $ mapM f xs" doesn't terminate if xs is infinite
02:24:44 <lilac> Saizan: no, i'd just realised :)
02:25:03 <Saizan> s/$/<$>/ -- to make it type
02:25:06 <lilac> you'd need a mapUntilM or similar, i guess
02:25:32 <lilac> Saizan: ok, ok, i've not had my coffee yet ;-)
02:25:35 <Saizan> it'd be like mapUntilExcept, but with a predicate instead of catch
02:25:45 <lilac> nods*
02:26:25 * Saizan is having his tea
02:29:25 <harlekin> How can I push and pop a matrix using HOpenGL?
02:35:00 <jpcooper> lilac, so is there a solution?
02:35:37 <dancor> what is the best way to get cabal-install to use -threaded
02:35:42 <jpcooper> "evaluate :: a -> IO a	Source
02:35:42 <jpcooper> Forces its argument to be evaluated to weak head normal form when the resultant IO action is executed. It can be used to order evaluation with respect to other IO operations; its semantics are given by"
02:36:43 <dancor> also when is it ever bad to use -threaded
02:37:27 <Saizan_> dancor: put ghc-options: -threaded in the .cabal file
02:37:37 <dancor> ty
02:38:14 <Saizan_> dancor: -threaded add some overhead to synchronizations e.g. in MVar
02:38:20 <dancor> mm
02:39:37 <Saizan_> so threaded is a win if you get to use multiple cores, but it's also necessary to make blocking system calls not block all the threads
02:44:13 <anders^^> will there be videos on youtube from the conference last week?
02:46:46 <ivanm> anders^^: hopefully not!
02:47:05 <ivanm> I'm sure there are better videos site for conferences, etc. ...
02:48:31 <malcolmw> anders^^: the videos will go up probably on the Nottingham CS webserver
02:48:52 <malcolmw> anders^^: and maybe also on vimeo
02:48:55 <anders^^> malcolmw: ah nice
02:49:54 <fasta> Anything particularly interesting to see?
02:50:25 <malcolmw> look at the conference programme and decide for yourself :-)
02:50:44 <fasta> Are there going to be videos of everything then?
02:51:10 <malcolmw> fasta: ICFP, Haskell, CUFP, Erlang, and HIW
02:51:50 <fasta> malcolmw: well, send a mail to haskell-cafe when that happens, please.
02:52:15 <malcolmw> of course :-)
02:53:38 <standoneshok> hey #haskell, is there a builtin function that is like iterate but lets me stop the iteration early?
02:55:00 <ivanm> standoneshok: as in you want a list?
02:55:09 <standoneshok> yup
02:55:11 <ivanm> or just the function applied n times?
02:55:16 <ivanm> standoneshok: take n . iterate f
02:55:22 <standoneshok> I want it to iterate a function from a seed
02:55:27 <standoneshok> and stop if some condition becomes true
02:55:33 <jpcooper> can anyone explain to me why sequence isn't lazy?
02:55:36 <ivanm> standoneshok: takeWhile
02:55:40 <aleator> Hi all. How do I define NFData for ForeignPtr?
02:55:55 <poe> ?type unfoldr -- standoneshok
02:55:57 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
03:01:28 <lilac> jpcooper: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9255#a9255
03:01:43 <lilac> jpcooper: that's how i think i'd do it
03:02:17 <jpcooper> lilac, thanks I think I have it figured anyway. That is, I think
03:02:31 <jpcooper> shouldn't it all work fine with my mapUntilExcept?
03:02:34 <lilac> jpcooper: incidentally, sequence should be as lazy as the underlying monad allows
03:02:42 <jpcooper> oh
03:02:57 <jpcooper> but it's not because >> in IO isn't lazy?
03:03:11 <lilac> right.
03:03:27 <lilac> well, it really depends what you mean by 'lazy' here
03:03:55 <lilac> a >> b constructs an IO action which does a then b. but it doesn't force the (pure) value computed by a or b.
03:04:05 <jpcooper> the b bit in IO b of sequence
03:04:10 <taruti> What is the simplest library to offer getLineWithoutEcho :: IO String ?
03:04:15 <lilac> jpcooper: right.
03:04:30 <jpcooper> so now I'm more confused
03:04:47 <opqdonut> taruti: just output ansi terminal escapes yourself ;)
03:04:54 <opqdonut> taruti: or use vty, it's a pretty nice terminal library
03:04:57 <jpcooper> say I do mapUntilExcept something input >>= mapM_ hPutStrLn
03:05:01 <jpcooper> sorry, putStrLn
03:05:10 <jpcooper> why does it wait until mapUntilExcept has finished?
03:05:25 <opqdonut> @where vty
03:05:25 <lambdabot> darcs get http://members.cox.net/stefanor/vty/
03:05:30 <opqdonut> there
03:05:37 <taruti> opqdonut: I'm trying to avoit the raw codes, vty might be the way to go
03:05:41 <opqdonut> probably available on hackage too
03:05:49 <opqdonut> well what vty does is output the raw ansi codes
03:06:01 <opqdonut> it doesn't even support anything else than ansi
03:06:04 <taruti> that url is obsolete, it is available on hackage though
03:06:32 <lilac> jpcooper: that glues an IO action which prints some lines on the end of an IO action which does something until it gets an error.
03:06:40 <Saizan_> jpcooper: it has to perform all the side-effects of "mapUntilExcept something input" before executing mapM_ hPutStrLn
03:07:36 <fasta> jpcooper: I think that depends on the monad.
03:07:59 <lilac> fasta: it's putStrLn so we're in IO :)
03:08:27 <jpcooper> Saizan_, why does it have to finish? It returns a list so surely the list can be used straight away?
03:08:38 <Saizan_> fasta: the side-effects still gets sequenced, from an high enough level of abstraction
03:09:12 <Saizan_> jpcooper: one of the points of IO is to sequence side-effects so that they are insulated from evaluation order
03:10:14 <Saizan_> only if you use unsafeInterleaveIO you can delay the side-effects tying making them execute on-demand
03:10:19 <lilac> jpcooper: if you were to delay IO actions until some pure computation forced their result, then (because evaluation order of pure computations is unspecified) you would be introducing nondeterminism
03:10:20 <jpcooper> right
03:10:26 <jpcooper> which is what hGetContents uses
03:10:36 <lilac> haskell requires you to be explicit if you want nondeterminism, by using unsafeInterleaveIO or forkIO
03:10:50 <jpcooper> okay
03:11:24 <etpace> why is nondeterminism unsafe?
03:11:59 <lilac> it can violate referential transparency, i think
03:12:16 <Saizan_> only if we had a reasonable semantics for IO
03:12:19 <Saizan_> :)
03:12:57 <lilac> Saizan_: possibly even without one, in the unsafeInterleaveIO case; you can tell which order thunks are forced in, in pure code
03:13:46 <lilac> (eg, in: do a <- unsafeInterleaveIO (putStrLn "a" >> return 1); b <- unsafeInterleaveIO (putStrLn "b" >> return 2); return (somePureFunction a b))
03:14:18 <Saizan_> that's usually dismissed with some magic happening in putStrLn
03:14:26 <lilac> i admit that's tenuous since we can't show that IO doesn't do such weird stuff anyway :)
03:14:48 <Saizan_> exactly
03:16:11 <lilac> i guess it'd be easier to invent semantics for ST -- unsafeInterleaveST has the same issue, doesn't it?
03:17:11 <lilac> (the problem presumably is that the simple ST semantics don't cover unsafeInterleaveST)
03:17:30 <Saizan_> mh, probably
03:20:26 <Saizan_> if we implement ST with IntMap and unsafeCoerce there's no way to write unsafeInterleaveST, right?
03:20:49 <lilac> i'd certainly hope not ;-)
03:24:52 * Saizan_ ponders how to write it without unsafeCoerce in agda
03:31:21 <lilac> Saizan_: does agda have existentials?
03:31:37 <Saizan_> lilac: yeah, sure
03:32:14 <lilac> i think the paper which introduced Dynamic did it without unsafeCoerce
03:32:30 <Saizan_> in haskell?
03:32:39 <lilac> as i recall, yes
03:32:54 <Saizan_> that's how it's implemented in fact
03:33:08 <quicksilver> I'm pretty sure you can't write Dynamic in haskell without something equivalent to unsafeCoerce
03:33:22 <quicksilver> I spent quite a while pondering that one when I first discovered it.
03:33:25 <Saizan_> you can use a Typeable existential
03:33:35 <Saizan_> or am i missing something?
03:33:40 <lilac> quicksilver: you create a TypeRep type and use it to build a coercion function as i recall
03:33:57 <Saizan_> ah, wait, you can't write cast without unsafeCoerce, right
03:34:39 <Saizan_> (unless you use gadts and a fixed universe)
03:34:42 <quicksilver> Saizan_: it won't let you return the thing out of the existential
03:35:01 <quicksilver> Saizan_: even though you used 'Typeable' to 'prove' it is safe to do so.
03:35:09 <Saizan_> quicksilver: right
03:35:12 <lilac> quicksilver: you can write something like Cast using Data, and as i recall that's roughly how the paper did it
03:35:36 <quicksilver> lilac: I don't see how that circumvents the type system.
03:35:43 <quicksilver> unless some method of Data lets you do that
03:35:51 <Saizan_> (however i meant to implement an API like ST, without any typeclass context on elements)
03:36:05 <lilac> quicksilver: it doesn't, and we don't need to. Dynamic is well-typed :)
03:36:17 <quicksilver> actual it's not
03:36:20 <Saizan_> you could use gread and gshow, but that's cheating
03:36:24 <lilac> quicksilver: making a Dynamic for some closed set of types is easy. making it for an open set of types is harder
03:36:31 <quicksilver> the type system doesn't stop you writing a Typeable instance which lies
03:36:37 <quicksilver> so Dynamic is not well-typed.
03:36:47 <lilac> quicksilver: the paper's implementation doesn't use the same Typeable
03:36:51 <lilac> and doesn't suffer from that problem
03:37:01 <quicksilver> and, as far as I know, the Typeable which GHC produces does indeed lie
03:37:10 <quicksilver> so GHC's Dynamic is not safe.
03:37:17 <Saizan_> how does it lie?
03:37:25 <quicksilver> it doesn't embed package information
03:37:32 <lilac> the interface of Dynamic (assuming that Typeable is correct) is well-typed.
03:37:33 <Saizan_> ah, true
03:37:47 <quicksilver> so you can use Dynamic to get unsafeCoerce from foo-0.0.1:Bar to foo-0.0.2:Bar
03:37:53 <quicksilver> which might occasionally be a neat trick :)
03:42:35 <lilac> data Dynamic = D String String; class Dyn a where toDynamic :: a -> Dynamic; fromDynamic :: Dynamic -> Maybe a; instance Dyn Foo where toDynamic a = D "Foo" (gshow a); fromDynamic (Dynamic t v) | t == "Foo" = gread a; fromDynamic _ = Nothign
03:42:51 <lilac> quicksilver: ^^ there you go. Dynamic via Data with no unsafeCoerce
03:43:14 <lilac> if your Dyn instance is broken, you can get weird results, but it won't crash
03:44:39 <fasta> Is there a function which shows the next Double given a Double?
03:45:10 <lilac> fasta: by 'next' do you mean the smallest Double greater than a given Double?
03:45:16 <fasta> lilac: yes
03:46:51 <fasta> Cool Java already has a library to do that.  double d2 = ChoiceFormat.nextDouble(d);
03:47:09 <lilac> fasta: what does that do on maxBound? on -0?
03:47:20 <lilac> (on NaN?)
03:47:42 <fasta> lilac: I didn't check, but I don't really care.
03:47:52 <lilac> there's a neat trick with IEEE-754, actually:
03:48:20 <lilac> nextDouble d = unsafeCoerce ((unsafeCoerce d :: Word64) + 1) :: Double
03:49:02 <lilac> note ^^ using the above function voids all warranties you, or anyone you know, may be covered by.
03:49:27 <opqdonut> :D
03:49:45 <fasta> lilac: the Word64 will certainly be a problem ;)
03:49:51 <opqdonut> one can do that using decodeFloat and encodeFloat in a bit cleaner way
03:49:58 <opqdonut> requires more logic though
03:50:25 <lilac> it'd probably be a good thing if nextDouble (-0) were DENORM_MIN not +0, too :)
03:53:19 <stanv_> hello.
03:55:39 <benmachine> hello
03:55:45 <blackdog> horms: heya. thanks for coming to roro the other night :)
03:56:12 <horms> blackdog: any time mate :-)
03:56:18 <stanv_> Please confirm that question: "Explain why the folowing expressions do not type-check:  1. curry uncurry 2. curry curre" is ambiguous.
03:56:32 <stanv_> curry*
03:56:40 <ivanm> stanv_: they make sense to me...
03:56:51 <stanv_> ivanm: why ?
03:57:07 <ivanm> the questions make sense...
03:57:13 <ivanm> answering them is a different story :p
03:57:16 <benmachine> > curry uncurry
03:57:19 <stanv_> the are no even type
03:57:21 <lambdabot>   Couldn't match expected type `(a, b)'
03:57:23 <ivanm> well, the types are wrong, anyway
03:57:25 <ivanm> @type curry
03:57:27 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
03:57:28 <ivanm> @type uncurry
03:57:30 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
03:57:53 <ivanm> neither of them takes a function taking a pair
03:58:28 <blackdog> @type curry . uncurry
03:58:29 <lilac> ivanm: curry takes a function taking a pair :)
03:58:30 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
03:58:52 <ivanm> lilac: I mean, neither of them is a function that takes a pair
03:58:52 <danr> @pl \[x,y] -> (x,y)
03:58:52 <lambdabot> (line 1, column 2):
03:58:52 <lambdabot> unexpected "["
03:58:52 <lambdabot> expecting pattern
03:58:56 <ivanm> happy now? :p
03:59:00 <fasta> stanv_: it would be better if it would say "prove" instead of "explain".
03:59:06 <stanv_> but there are no (.) operator
03:59:11 <danr> @pl \f [x,y] -> (x,y)
03:59:11 <lambdabot> (line 1, column 4):
03:59:11 <lambdabot> unexpected "["
03:59:11 <lambdabot> expecting operator, pattern or "->"
03:59:19 <ivanm> fasta: "prove"?
03:59:22 <lilac> stanv_: what about the question do you think is ambiguous?
03:59:24 <benmachine> @pl \(x:y:[]) -> (x, y)
03:59:24 <lambdabot> (line 1, column 7):
03:59:25 <lambdabot> unexpected "["
03:59:25 <lambdabot> expecting "()", natural, identifier, "_" or "("
03:59:29 <benmachine> :(
03:59:29 <danr> @pl \f (x:y:[]) -> (x,y)
03:59:30 <lambdabot> (line 1, column 9):
03:59:30 <lambdabot> unexpected "["
03:59:30 <lambdabot> expecting "()", natural, identifier, "_" or "("
03:59:30 <ivanm> I don't think they expect a full blown CS proof...
03:59:32 <lilac> fasta: i think saying "prove" would make it a harder question
03:59:36 <danr> :(
03:59:41 <benmachine> @pl \(x:y:fakeemptylist) -> (x, y)
03:59:41 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
03:59:52 <benmachine> um.
03:59:59 <danr> ahaar!
04:00:04 <benmachine> that is not quite right
04:00:05 <fasta> lilac: yes, but explain is so vague that it is not clear what the teacher wants to hear.
04:00:12 <benmachine> closer though!
04:00:15 <stanv_> i can't prove, becose my ghci: says : Couldn't match expected type `(a, b)'
04:00:17 <ivanm> @pl \ (x:y:[]) -> (x,y)
04:00:17 <lambdabot> (line 1, column 8):
04:00:17 <lambdabot> unexpected "["
04:00:17 <lambdabot> expecting "()", natural, identifier, "_" or "("
04:00:20 <fasta> lilac: I lost lots of points and time on that I am sure.
04:00:21 <ivanm> heh
04:00:29 <ivanm> stanv_: that's the point...
04:00:31 <benmachine> > (head *** tail) [a, b]
04:00:35 <lambdabot>   Couldn't match expected type `([c], [a])'
04:00:35 <ivanm> it doesn't type-check
04:00:36 <danr> @pl \li -> (head li, head (tail li))
04:00:36 <lambdabot> liftM2 (,) head (head . tail)
04:00:37 <ivanm> match the types
04:00:38 <benmachine> :(
04:00:40 <danr> there we go
04:00:47 <lilac> stanv_: explain why it doesn't type-check.
04:00:47 <ivanm> it's like a puzzle! do the pieces fit together?
04:00:48 <benmachine> > (head *** last) [a, b]
04:00:51 <lambdabot>   Couldn't match expected type `([c], [a])'
04:00:58 <stanv_> lilac: I CAN"T
04:01:02 <benmachine> > (head &&& last) [a, b]
04:01:05 <danr> > (head &&& head . last) [a,b]
04:01:06 <lambdabot>   (a,b)
04:01:08 <lambdabot>   Couldn't match expected type `[a]'
04:01:12 <benmachine> woo
04:01:13 <lilac> stanv_: do you understand why it doesn't type check?
04:01:29 <danr> > (head &&& head . tail) [a,b]
04:01:34 <lambdabot>   (a,b)
04:01:51 <stanv_> lilac: it is impossible write in code curry uncurry
04:02:19 <lilac> stanv_: yes. why is that the case?
04:02:33 <ivanm> stanv_: why is it impossible?
04:02:48 <ivanm> well, actually, it is possible to write that...
04:02:56 <ivanm> it just won't compile/type-check/etc. ...
04:03:10 <benmachine> ivanm: arguably then you haven't written it in code :P
04:03:21 <Saizan_> stanv_: do you know anything about the type inference rules/algorithm?
04:03:23 <ivanm> yes you have
04:03:24 <lilac> ivanm: i don't think this is the time for pedantry :) also, (const curry uncurry) typechecks
04:03:26 <Lanjiao> someone know Template haskell, using it, how to wirte a function that f "Sub" --> f (Sub t1 t2) = Sub t2 t1?
04:03:28 <ivanm> it's just not valid code!
04:03:35 <benmachine> ivanm: suppose
04:03:41 <ivanm> or at least, not valid _Haskell_ code
04:03:42 <benmachine> so
04:04:35 <stanv_> please anybody explain in few sentences
04:04:51 <lilac> stanv_: do you know what it means for code to type-check?
04:05:19 <stanv_> yes, it is not valid _Haskell_ code, why must I prove what is not valid ?
04:05:20 * ivanm thought he already did explain...
04:05:35 <ivanm> neither of those is a function that takes a pair
04:05:38 <lilac> stanv_: the question wants you to explain why it's not valid
04:05:40 <ivanm> @type curry
04:05:42 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
04:05:43 <ivanm> @type uncurry
04:05:45 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:05:57 <ivanm> what does curry expect as its first argument?
04:06:09 <stanv_> function
04:06:16 <lilac> stanv_: it's not valid because it doesn't type-check. you're being asked to explain why it doesn't type-check.
04:06:34 <stanv_> stupid exercise!
04:06:55 <benmachine> stanv_: it's more specific than function
04:07:19 <Saizan_> stanv_: basically the exercise asks you to being able to infer the type of an expression or give a reason if it's impossible
04:07:30 <Saizan_> stanv_: it's a quite important ability to effectively write haskell code
04:07:53 <ivanm> Saizan_: s/haskell //
04:08:02 <ivanm> though not all languages are as picky straight away
04:08:03 <ivanm> ;-)
04:08:40 <lilac> stanv_: what is it about "curry uncurry" that makes it not valid haskell code? how do you /know/ it's not valid?
04:08:58 <danr> Any ideas how to pointfree make a list [a,b,..,x,y] to [(a,b),..,(x,y)]?
04:09:07 <edwardk> @type curry uncurry
04:09:09 <lambdabot>     Couldn't match expected type `(a, b)'
04:09:09 <lambdabot>            against inferred type `a1 -> b1 -> c'
04:09:09 <lambdabot>     In the first argument of `curry', namely `uncurry'
04:09:15 <edwardk> there ;)
04:09:20 <Botje> danr: what should the second element look like?
04:09:30 <Deewiant> ?ty curry
04:09:32 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
04:09:39 <Botje> (b,c) or (c,d) ?
04:09:40 <lilac> edwardk: fine, how does the /compiler/ know it's not valid?
04:09:40 <Deewiant> ?ty uncurry
04:09:42 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:09:44 <danr> Botje: (c,d)
04:09:44 <stanv_> lilac: it expect function that takes two arguments
04:09:55 <edwardk> OTOH,
04:09:59 <edwardk> @type uncurry curry
04:10:01 <lambdabot> forall b b1 c. ((b, b1) -> c, b) -> b1 -> c
04:10:02 <lilac> stanv_: ok, it expects a function which takes a pair
04:10:02 <Deewiant> lilac: curry wants an argument of type (a,b) -> c
04:10:15 <Deewiant> uncurry is of type (a -> b -> c) -> (a,b) -> c
04:10:25 <Deewiant> No match :-)
04:10:29 <lilac> Deewiant: thanks for doing someone's homework for them...
04:10:48 <Deewiant> Oh, that was in my scrollback, d'oh
04:10:55 <edwardk> lilac: coz unification fails ;)
04:11:05 <danr> >  fix (\f li -> case li of { (x:y:xs) -> (x,y):f xs ; _ -> [] }) [1..9]
04:11:08 <stanv_> lilac: I understand that.
04:11:08 <lambdabot>   [(1,2),(3,4),(5,6),(7,8)]
04:11:12 <danr> like that
04:11:16 <ivanm> lilac: I've already said it twice...
04:11:18 <ivanm> ;-)
04:11:24 <lilac> stanv_: ok, so why is 'uncurry' not acceptable as an argument to 'curry'?
04:11:52 <stanv_> lilac: it takes more arguments
04:12:19 <ivanm> nope
04:12:31 <ray> :t curry
04:12:32 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
04:12:43 <stanv_> lilac: uncurry doesn't have expected signature.
04:12:44 <Saizan_> that wouldn't cause a failure per se, because 'c' is polymorphic in curry
04:12:45 <lilac> stanv_: right
04:12:47 <ray> uncurry isn't (a,b) -> c
04:13:07 <ivanm> lilac: why doesn't it?
04:13:13 <ivanm> which part of the signature doesn't match?
04:13:29 <lilac> stanv_: curry wants a function whose first argument is a pair. uncurry's first argument is a function.
04:13:45 <stanv_> lilac: now return to original question: "why curry uncurry do not type-check"
04:13:47 <stanv_> ?
04:14:03 <lilac> stanv_: do you know what the question means by "type-check2?
04:14:07 <benmachine> helping people who ask questions by asking them questions is a very useful technique but confusing for people who enter the conversation late
04:14:11 <edwardk> (a -> b -> c) -> (a, b) -> c and (a,b) -> c fail to unify since the former has the shape (a -> e) -> d rather than (a,b) -> c
04:14:15 <stanv_> lilac:  no :(
04:14:16 <ray> it wants to unify the types
04:14:16 <danr> there we go
04:14:25 <danr> >  (uncurry zip . (map snd *** map snd) . partition (even . fst) . zip [0..]) [1..9]
04:14:28 <ray> :t curry (flip uncurry)
04:14:30 <lambdabot> forall a b c. a -> b -> (a -> b -> c) -> c
04:14:30 <lambdabot>   [(1,2),(3,4),(5,6),(7,8)]
04:14:50 <ivanm> benmachine: heh
04:14:58 <edwardk> so the -> is matched on the outside, but the -> and , fail to match on the inside, unification fails, dogs and cats start living together in harmony, general chaos.
04:15:11 <lilac> stanv_: ok, what it means is that the types of values you give to functions must match the types which the functions want
04:15:15 <Saizan_> stanv_: an answer (not very technical) to "why curry uncurry do not type-check?" is exactly "curry wants a function whose first argument is a pair. uncurry's first argument is a function"
04:15:15 <ray> new york also destroyed
04:15:59 * benmachine thinks there should be a name for \f -> f *** f
04:16:02 <byorgey> @remember edwardk so the -> is matched on the outside, but the -> and , fail to match on the inside, unification fails, dogs and cats start living together in harmony, general chaos.
04:16:02 <lambdabot> I will remember.
04:16:04 <edwardk> " What did you DO, ray?"
04:16:08 <Botje> benmachine: join (***) :)
04:16:10 <lilac> benmachine: join (***)?
04:16:19 <benmachine> benmachine: join (***)!
04:16:21 <byorgey> @type \f -> f *** f
04:16:23 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:16:26 <byorgey> @type join (***)
04:16:27 <benmachine> I guess so.
04:16:28 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:16:29 <edwardk> benmachine its in category-extras ;)
04:16:40 <stanv_> I imagene that do not type check is `id' function
04:17:10 <ray> edwardk: i tried to unify (a,b) with (a -> b) :(
04:17:33 <Saizan_> stanv_: so reading the question as "why curry uncurry?" makes sense to you?:)
04:17:57 <benmachine> category-extras is giving a lot of warnings :o
04:18:10 <ray> category-warnings
04:18:18 <ray> it'll be renamed next release
04:18:31 <benmachine> k
04:18:38 <ivanm> ray: heh
04:18:39 <benmachine> to be fair it is giving plenty of extras too
04:19:00 <ray> yeah, but it's been decided that the warnings are what it's really about
04:19:19 <benmachine> edwardk: what's in category-extras?
04:20:04 <stanv_> lilac Saizan_ thanks :)
04:20:52 <ray> cool stuff is in category-extras
04:21:22 <benmachine> undoubtedly
04:21:24 <benmachine> buckets of it
04:21:33 <benmachine> but where
04:23:05 <benmachine> hmm it is probably time I learnt about fundeps
04:25:14 <ray> base has a Control.Category module now which probably conflicts
04:30:58 <ziman> i think i begin to understand some things in category-extras. a creepy feeling. :)
04:34:35 <DrSyzygy> ziman: Nice!
04:35:26 <yakov> hey
04:38:41 <yakov> couple days old HEAD snapshot tells me "ld: library not found for -lHSffi_p" when I try to rebuild with -prof
04:38:56 <yakov> does anybody how to get libHSffi_p to be built? i did simple "make"-build of GHC without any customizations
04:41:17 <yakov> everything else including rts, ghc-prim for example and libraries is build with profiling.
04:41:47 <danr> @pl \c -> (sum . map snd &&& id) . head  . sortBy (flip compare `on` sum . map snd)  . filter ((c >=) . sum . map fst) . filterM (const [True,False])
04:41:48 <lambdabot> (line 1, column 70):
04:41:48 <lambdabot> unexpected "."
04:41:48 <lambdabot> expecting variable, "(", "!!", space, operator or ")"
04:41:48 <lambdabot> ambiguous use of a right associative operator
04:42:23 <danr> @pl \c -> (sum . map snd &&& id) . head  . sortBy (flip compare `on` (sum . map snd))  . filter ((c >=) . sum . map fst) . filterM (const [True,False])
04:42:24 <lambdabot> (((sum . map snd &&& id) . head . sortBy (flip compare `on` (sum . map snd))) .) . (. filterM (const [True, False])) . filter . (. (sum . map fst)) . (>=)
04:50:42 <PupenoG> In a complete graph, is the growth of edges O(N^2)?
04:50:54 <PupenoG> Where N are the vertices of course.
04:52:13 <mornfall> It's O(N^2) in any graph. In directed complete graph, it's N^2.
04:53:12 <danr> I think in an undirected it's n(n-1)/2
04:53:22 <danr> The sum of n + (n-1) + .. + 1
04:53:31 <PupenoG> mornfall: If only one node is connected to all the rest, isn't that still a graph? with O(N).
04:53:44 <mornfall> PupenoG: O(N) \subseteq O(N^2)
04:53:46 <PupenoG> Yes, a complete graph has n*(n-1)/2 edges.
04:55:13 <PupenoG> But I was trying to thing the space complexity of communicating every node with every node, forming a complete graph. It looks like it is O(n^2), because when you add another node, you more or less double the size of the problem (sorry If I'm not using the correct jargon).
04:56:42 <ivanm> yes, that sounds right (your "solution", not necessarily your terminology :p )
04:56:58 <PupenoG> Thanks.
05:10:31 <dschoepe> Does that example for GADTs in the wiki book require additional extensions for kind annotations? "MarkedList x y where" works fine, but "MarkedList :: * -> * -> * where" does not.
05:11:16 <Saizan_> dschoepe: KindSignatures
05:11:31 <dschoepe> Saizan_: thanks. I'll add a note about that in the article.
05:11:39 <SamB> what the heck?
05:12:02 <SamB> I would have expected GADT to pull that in
05:14:33 <dazza_> > let list = [[1],[3,4],[4,5,6,7]] in maximum [(length a)| a <- takeWhile (/= []) list]
05:14:38 <lambdabot>   4
05:16:22 <dschoepe> SamB: Well, it doesn't in ghc 6.10.4, might be different in ghc-head.
05:18:23 <hackagebot> stm-io-hooks 0.5.4 - An STM monad with IO hooks (PeterRobinson)
05:19:07 <SamB> dschoepe: I doubt it
05:23:07 <dazza_> let list = [4,1,2,2,3,3,2] in [length a | a <- takeWhile (/= (greatist (functionx list))) (functionx list)]
05:23:39 <sioraiocht> what is a "pointed" type?
05:23:51 <dazza_> cant find type mis-match, greatist returns an Int and functionx returns a list of lists.
05:24:03 <dazza_> I dont understand pointed?
05:24:30 <dazza_> *** Term           : flip (/=) (greatist (functionx list))
05:24:31 <dazza_> *** Type           : Int -> Bool
05:24:31 <dazza_> *** Does not match : [Int] -> Bool
05:25:16 <Botje> what's the type of greatist and functionx ?
05:25:27 <dazza_> greatist:: [[Int]] -> Int
05:25:31 <dazza_> functionx:: [Int] -> [[Int]]
05:25:59 <sioraiocht> dazza_: reading a paper, it says "Note that all Haskell types are pointed"
05:27:00 <Botje> dazza_: you're trying to compare [Int] to Int in your takeWhile
05:27:22 <dazza_> ah .
05:27:51 <dazza_> so i cant use the function then?
05:27:59 <Botje> maybe.
05:28:03 <Botje> depends on what the functions do.
05:28:39 <gwern> sounds like sortBy functions could do his greatest
05:28:49 <gwern> or maybe just 'last . sort'
05:28:52 <dazza_> i can shove it in a pastebucket..
05:29:11 <gwern> > last $ sort [1, 10, 1, 11, 100, 88]
05:29:14 <lambdabot>   100
05:29:18 <byorgey> sioraiocht: by that it probably refers to the fact that _|_ is an element of every Haskell type.
05:29:39 <sioraiocht> byorgey: thanks, that makes sense.
05:29:46 <sioraiocht> byorgey: *why* does it mean that
05:30:26 <byorgey> sioraiocht: it's a slightly different use of the term than I've heard before
05:30:46 <sioraiocht> okay :)
05:30:50 <byorgey> sioraiocht: but usually "pointed" refers to the existence of a distinguished element, or the ability to inject certain elements into a type
05:30:59 <ray> a pointed set is a set with a "special" element
05:31:02 <byorgey> for example   class Functor f => Pointed f where point :: a -> f a
05:31:05 <sioraiocht> byorgey: ah, okay
05:31:09 <dazza_> I want to take x from (functionx list) where x is the length of a list that matches the return on (greatist (functionx list))
05:31:25 <sioraiocht> thanks, byorgey and ray =)
05:32:10 <ray> the only way all haskell types could be pointed is if _|_ is the point, so that's probably what it means
05:32:33 <ivanm> ray: so that's the point of the quote? :p
05:32:44 <ray> apparently!
05:32:46 <byorgey> heh
05:33:27 <sioraiocht> ray: because there's no other element that could be injected into all of them?
05:34:12 <ray> something like that
05:38:04 <byorgey> if I were saying the same thing in a paper, I would instead say that "all Haskell types are *inhabited*"
05:38:11 <byorgey> pointed is sort of a strange word to use there, I think
05:38:27 <byorgey> but oh well
05:38:58 <gwern> @quote habit
05:38:58 <lambdabot> No quotes match. Take a stress pill and think things over.
05:39:26 <gwern> wonder what the shortest string that matches no quotes is
05:39:43 <Botje> @quote zx
05:39:43 <lambdabot> No quotes match. That's something I cannot allow to happen.
05:39:53 <gwern> @quote z
05:39:53 <lambdabot> autrijus says: Mechanical and super-natty! Inspect the result and *if* happy; freeze, sell and get some sleep!
05:40:03 <gwern> the hell?
05:40:28 <maltem> @quote ß
05:40:29 <lambdabot> No quotes match. You speak an infinite deal of nothing
05:40:38 <maltem> :P
05:41:15 <ziman> @quote
05:41:15 <lambdabot> BjarneStroustrup says: any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
05:41:45 <gwern> maltem: well, if we can use unicode, then obviously the answer is one char/entity
05:41:49 <gwern> I was thinking ASCII
05:42:42 <maltem> gwern, if I actually knew how to produce a tab in this IRC client...
05:42:58 <gwern> alphanum then! >.<
05:43:16 <maltem> hmm
05:43:21 <gwern> also, @quote is regexps, so you could probably just do whatever the regexp escape is
05:43:28 <maltem> Not even interrogation?
05:43:58 <maltem> @quote \
05:43:58 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 5,"Trailing backslash")
05:44:10 <maltem> right
05:48:21 <Axman6> @quote \\
05:48:21 <lambdabot> lambdabot says: i 4M THe cooLES+ bo+ e\/eR
05:48:36 <Axman6> @. elite nixon
05:48:37 <lambdabot> TH3y'rE n0T 1Ike U5. Th3y $M3Ll dIfpheReNT, 7h3y lOOK Diff3r3Nt, tHEy AC7 dIphFEREN7. th3 Trou8LE I5, u CAn'T fInd One 7hAt'z0rz hoNeST.
05:58:34 <lilac> @@ @@ @run fun . intercalate ", " . map (("("++).(++")")) . take 6 $ iterate (++" flip") "@pl flip" :: Expr
05:58:39 <lambdabot> Plugin `compose' failed with: Missing ')' in nested command
05:59:02 <lilac> @pl flip flip flip flip
05:59:02 <lambdabot> flip flip flip
05:59:19 <lilac> three shall be the number of the flipping, and the number of the flipping shall be three
06:10:19 <mmorrow> @pl (flip flip flip flip, flip flip flip flip flip, flip flip flip flip flip flip)
06:10:19 <lambdabot> (flip flip flip, flip flip flip, flip flip flip)
06:10:56 <mmorrow> @pl (flip $ flip $ flip $ flip, flip $ flip $ flip $ flip $ flip, flip $ flip $ flip $ flip $ flip $ flip)
06:10:57 <lambdabot> (flip flip, flip, flip flip)
06:11:10 <EnglishGent> flippin heck!
06:11:12 <mmorrow> @pl flip . flip
06:11:12 <lambdabot> id
06:11:19 <mmorrow> @pl flip (flip . flip)
06:11:20 <lambdabot> flip id
06:12:19 <mmorrow> @pl flip (flip id)
06:12:19 <lambdabot> id
06:12:33 <mmorrow> @pl flip (flip ($))
06:12:33 <lambdabot> id
06:12:45 <EnglishGent> okay... a silly question - is there a way to persuade GHC to automatically look at the packages obtained by Cabal? so I can just cabal install something & then do 'import blah'
06:12:51 <EnglishGent> as at the moment - that doesnt seem to work
06:12:55 <mmorrow> @pl (. flip) . (. flip)
06:12:55 <lambdabot> (. flip) . (. flip)
06:13:03 <EnglishGent> :|
06:14:50 <Alpounet> What's better between negateList (x : xs) = (negate x) : (negateList xs) and negateList = map negate ?
06:14:58 <mmorrow> EnglishGent: you mean, "import blah" imports the entire package blah?
06:15:13 <mmorrow> Alpounet: fmap negate
06:15:27 <mmorrow> Alpounet: since then it works on anything that's a Functor
06:15:32 <mmorrow> including lists
06:16:02 <mmorrow> , (fmap negate (Just 9), fmap negate [0..4], fmap negate (Node 1 [Node 2 [],Node 3[]]))
06:16:04 <lunabot>  (Just (-9),[0,-1,-2,-3,-4],Node {rootLabel = -1, subForest = [Node {rootL...
06:16:09 <PetRat> In a GUI situation, I've got a list of monadic values I want to use to draw a list of things. I implemented it like this, but wondering if there is a more compact way: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9263#a9263
06:16:27 <Saizan_> ↵
06:16:35 <Alpounet> mmorrow, is there any of the possibilities that GHC "understands" better so that he may/might optimize something ?
06:16:48 <Axman6> PetRat: sequence(_)?
06:16:54 <Axman6> :t sequence
06:16:56 <Axman6> :t sequence_
06:16:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:16:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
06:17:10 <mmorrow> mapM_ (qPainter_drawRect1 painter =<<)
06:17:28 <quicksilver> EnglishGent: ghc --make
06:17:34 <quicksilver> EnglishGent: is the answer to the question I think you're trying to ask
06:17:37 <mmorrow> PetRat: (or (>>= qPainter_drawRect1 painter) if you prefer)
06:18:08 <dazza_> finally.....
06:18:11 <PetRat> Axman6: I'm not sure if sequence gets me anywhere.. I still need to "operate" on each rectangle wrapped in the IO mona.d
06:18:29 <dazza_> I can go to sleep now that horrible piece of code is working.
06:18:29 <Axman6> fair enough
06:18:30 <PetRat> mmorrow: I see, basically using >>= in a section.
06:18:31 <mmorrow> Alpounet: understands what? understands `map' better than `fmap'?
06:18:35 <mmorrow> PetRat: right
06:18:51 <mmorrow> Alpounet: (because it's more specialized you mean?)
06:19:30 <mmorrow> Alpounet: you can specialized (would call it "restrict") the type with a type signature to get the same effect as using `map' firectly
06:19:34 <mmorrow> *directly
06:19:40 <mux> the "fun with type function" paper says that it makes no sense to add a variable  representing a speed, and another one representing a distancd
06:19:46 <mux> they must have not heard about einstein
06:19:48 <Alpounet> mmorrow, yeah, because of the specialized aspect.
06:19:54 <mux> oh, no, wait :)
06:20:00 <mux> that would be time and distance
06:20:07 <mmorrow> @type fmap :: (a -> b) -> [a] -> [b]
06:20:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:20:14 <mmorrow> would be equivalent to map
06:20:18 <EnglishGent_> bah! got dc'd
06:20:36 <quicksilver> EnglishGent: ghc --make
06:20:38 <quicksilver> EnglishGent: is the answer to the question I think you're trying to ask
06:20:51 <saml> > fmap (- 1) [1,1,1]
06:20:54 <Alpounet> okay, then thanks. In terms of efficiency, thus, fmap's as efficient ?
06:20:56 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
06:20:56 <lambdabot>    arising from a use of syntactic n...
06:20:56 <quicksilver> yay for people who still use demon, by the way.
06:21:09 <quicksilver> Alpounet: in most circumstances it will be exactly the same
06:21:15 <Alpounet> yeah, ok.
06:21:23 <quicksilver> occasionally if you do large complicated abstract things across module boundaries it might not be
06:21:45 <mmorrow> Alpounet: the question is, whether or not ghc can determine the particular instance of Functor that a call to fmap is using in a particular situation
06:21:54 <EnglishGent_> thanks quicksilver
06:22:30 <Alpounet> quicksilver, that's not for now, then :)
06:22:36 <mmorrow> Alpounet: if it *can*, then it can call that function directly (in the case of lists, map), but if it *can't*, then the function that uses fmap needs to take another argument (that ghc adds) which is a ptr to the fmap that'll be used
06:23:05 <orbitz> copumpkin: I'm also an op!
06:23:08 <Alpounet> ok... and in really most cases, deduction of the Functor instance occurs, right ?
06:23:33 <mmorrow> Alpounet: if you're somehow implying it with either an explicit type sig or the surrounding context, then yes
06:23:49 <mmorrow> Alpounet: in other words, if it's at all possible to (w/in reason), it will
06:24:17 <quicksilver> mmorrow: even if you don't imply it by surrounding context, if the polymorphic part is small enough to inline you'll be OK. Etc.
06:25:05 <mmorrow> oh right, true
06:26:13 <quicksilver> mmorrow: and even if you *aren't* ok, passing a one-element dictionary is unlikely to be a performance bottleneck, although you never know.
06:26:21 <mmorrow> Alpounet: so even if your code doesn't imply it, a user of your code could imply the instance of Functor for you function, in which case it'd be as if you used `map' (or whatever) all along, since ghc'll inline right through your code (or something)
06:26:43 <byorgey> @seen dmwit
06:26:43 <lambdabot> Unknown command, try @list
06:26:52 <byorgey> did someone remove the @seen command?
06:27:02 <byorgey> preflex: seen dmwit
06:27:02 <preflex>  dmwit was last seen on #haskell 7 hours, 27 minutes and 10 seconds ago, saying: yeah, what Cale said
06:27:12 <mmorrow> quicksilver: true, as long as it's not a tight loop going through a dictionary indirection back to itself (or something)
06:27:27 <mmorrow> err, could that even happen for a non-class-method?
06:27:28 <Alpounet> mmorrow, quicksilver, ok thanks. I'm trying to understand better what GHC's does with our code :)
06:27:46 <Botje> evil voodoo magic!
06:30:14 <orbitz> Alpounet: magix!
06:30:44 <Alpounet> orbitz, seems so :-p
06:33:04 <lilac> byorgey: @vixen has gone awol too
06:34:24 <yohan> How do I replace my C preprocessor with Haskell?
06:34:41 <EnglishGent_> hi yohan
06:34:42 <EnglishGent_> :)
06:34:45 <saml> {-# LANGUAGE CPP #-} ?
06:34:48 <bryanzh> hi. i want to use sortBy in my .hs file. what do i need to do?
06:34:59 <bryanzh> load a module or something?
06:35:10 <lilac> import Data.List (sortBy)
06:35:10 <saml> @hoogle sortBy
06:35:10 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
06:36:12 <lilac> incidentally, there's a good chance you'll also want 'comparing' from Data.Ord
06:36:18 <lilac> @hoogle comparing
06:36:19 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
06:36:19 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
06:37:08 <pacopil> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
06:37:20 <saml> is it safe to click?
06:37:29 <quicksilver> I doubt it
06:37:38 <quicksilver> I wouldn't click any link someone pastes as their first message
06:37:40 --- mode: ChanServ set +o quicksilver
06:38:00 <quicksilver> (only message, indeed)
06:38:01 <bryanzh> how do i import that? sorry if it's newbie Q.
06:38:15 <quicksilver> bryanzh: just type "import Data.List" at the top of your .hs file
06:38:25 <yohan> EnglishGent_: Hi
06:39:57 <bryanzh> ok, top.. i got it. thanks lilac, saml, quicksilver.
06:40:24 <unk2k> Hello all! What it is ? => http://www.pentod.ru/humor.html
06:41:06 <quicksilver> unk2k: nothing to do with haskell, I suspct
06:41:14 <ivanm> russian humour by the looks of things
06:41:30 <quicksilver> in soviet russia, IRC channel makes fun of YOU!
06:41:49 <ivanm> heh
06:42:28 <stanv_> unk2k: honthing related to haskell :)
06:43:08 <stanv_> just humor :)
06:43:42 <yohan> How do I replace my C preprocessor with Haskell?
06:43:59 <ib11> ??????? ?? ??????
06:44:17 <saml> yohan, ghc -cpp ?
06:44:22 <yohan> Haskell is like macros right? But better syntax
06:44:29 <Axman6> ... no
06:44:33 <yohan> saml: before the source file?
06:44:42 <Axman6> haskell is a purely functional programming language
06:45:20 <Axman6> yohan: haskell has nothing to do with macros
06:45:20 <tromp> just go and rewrite cpp in Haskell, yohan
06:45:23 <Jafet> The C preprocessor is purely dysfunctional
06:45:28 <saml> yohan, what do you want to do? do you want to invoke cpp before compilation?
06:46:16 <mmorrow> yohan: so you want to replace the program /usr/bin/cpp with some version that uses haskell in macros to generate the C code?
06:46:33 <yohan> what?
06:46:37 <yohan> Yeah but I want to write C++
06:46:42 <yohan> but use haskell for macros
06:46:47 <Axman6> yohan: haskell has nothing to do with C++
06:46:48 <Jafet> yohan sounds very very very confused.
06:46:57 <Axman6> yohan: do you know what haskell is?
06:47:33 <saml> yohan, you mean you want to spit out C++ from haskell?
06:48:06 <mmorrow> yohan: hmm, you could probably get some hacky version working by using cpphs (internals), grabbing the #define contents, pipeing them into ghci/equivalent somehow, and splicing the output back into the C(++) code or something
06:48:10 <Axman6> saml: i think yohan thinks thaqt haskell is a macro system
06:48:12 <Veinor> 09:45:22 < Jafet> The C preprocessor is purely dysfunctional
06:48:14 <Veinor> Haha.
06:48:29 <Vanadium> yohan: What you are hasking is similar to writing C++ and using C++ for macros
06:48:35 <Axman6> @remember Jafet The C preprocessor is purely dysfunctional
06:48:35 <lambdabot> Okay.
06:49:17 <Jafet> Is the haskell type system decidable? (With/without ghc extensions?)
06:49:36 <yohan> Cool
06:49:41 <Axman6> i believe it's turing complete
06:49:44 <yohan> Vanadium: hasking?
06:49:49 <Veinor> The basic type system is turing complete?
06:49:54 <Axman6> yohan: do you know what haskell is?
06:49:58 <yohan> Veinor: C++ templates
06:49:59 <mmorrow> Jafet: not sure, do you mean as in is it possible to always infer all the types in a completely un-annotated prog?
06:50:01 <Vanadium> ... asking, even
06:50:01 <Veinor> Jafet: by decidable you mean....
06:50:10 <Axman6> desp: ah, yes, so you do :P
06:50:11 <EnglishGent_> as far as I know (though I am *not* an expert) - yes it is decidable Jafet - though in some (pathalogical) cases type checking may take exponential time
06:50:13 <Jafet> mmorrow, pretty much
06:50:18 <Veinor> yohan: C++ is, yeah, but I dunno about haskell types.
06:50:23 <yohan> Axman6: Its a macro system developed at Chalmers?
06:50:27 <mmorrow> Jafet: i think in haskell98 that's possible, but not after you add a few extensions
06:50:29 <Axman6> yohan: no
06:50:31 <Veinor> hasking: asking about haskell :D
06:50:35 <EnglishGent_> the C++ template system *is* turing complete - but you'd be mad to use it as a turing complete language
06:50:39 <mmorrow> Jafet: (and we're talking literally zero annotations here)
06:50:46 <Jafet> EnglishGent, http://boost.org
06:50:46 <Veinor> EnglishGent_: You'd be mad to write 99 bottles of beer in malbolge, and yet...
06:50:52 <yohan> mmorrow: cool
06:51:03 <Axman6> yohan: haskell has nothing at all to do with macros
06:51:13 <Axman6> it's a programming language, like C++, but better
06:51:15 <EnglishGent_> (and in practice you probably couldnt - as most compilers place limits on the number of times they'll expand a template)
06:51:30 <yohan> Axman6: Why is it better?
06:51:38 <saml> C++ is better
06:51:44 <Veinor> better is an entirely relative term.
06:52:02 * Jafet considers making a C++ proposal to allow template tail recursion
06:52:05 <EnglishGent_> boost - is very useful - but it doesnt attempt to do aribitrary type-level opereations
06:52:12 <EnglishGent_> :)
06:52:18 <Jafet> MPL does.
06:52:19 <Axman6> yohan: because it's safer. it's a lot harder to make most of the common mistakes you can in a language like C++, because there is no mutable state
06:52:37 <saml> mutable state has nothing to do with safety
06:52:38 <EnglishGent_> and that has big implications for paralisability as well
06:52:43 <Veinor> I think we should allow template arithmetic.
06:52:44 <yohan> Axman6: So its like using Java?
06:52:51 <Axman6> yohan: it also has much _much_ better concurrency and parallelism support
06:52:54 * Vanadium considers bullshitting a C++ proposal to give templates a FFI API so we can hook haskell into them
06:53:03 <saml> yohan, yes. haskell is like java.
06:53:16 <Axman6> yohan: ha, think of the good stuff in java, remove all the bad stuff, lose OOP, and ... then make it 10 times better
06:53:19 * Jafet sips coffee
06:53:58 <lilac> saml: is this countertrolling day? :)
06:54:10 <Veinor> This is the second weird C++-related question we've had in as many days.
06:54:17 <Vanadium> What was the first one?
06:54:30 <Veinor> A question on how to write a really basic program in C++.
06:54:36 <yohan> Axman6: What's good in Java?
06:54:44 <Vanadium> oh
06:54:44 <dino-> saml: How is it like Java?
06:54:46 <Veinor> Directed the guy towards the appropriate channel, but he was a dick and wouldn't actually, y'know, go.
06:54:50 <Axman6> yohan: well, java's generics came from haskell people
06:54:56 <Vanadium> Is that why you forwarded him to #cobol?
06:54:56 <lilac> yohan: from where did you get the notion that haskell is a macro system for c++? it'd probably make sense for us to correct the source of this information :)
06:54:57 <Axman6> ... that's pretty much it really >_>
06:55:00 <yohan> Axman6: do you like axman sex or how come you have that nick?
06:55:08 <mmorrow> yohan: (a haskell-ized cpp would be friggin awesome btw)
06:55:14 <Axman6> axman sex?
06:55:15 <yohan> lilac: I just heard its a language that composes functions
06:55:15 <dino-> I always felt like Generics were modeled after templates in C++
06:55:25 <yohan> mmorrow: yes.
06:55:32 <mmorrow> , ppDoc <$> fmaps 8
06:55:34 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
06:55:35 <lilac> yohan: ah, well it is that. but it composes its own functions, not c++'s, largely :)
06:55:36 * EnglishGent^afk recomends http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf as relevant to the 'why Haskell' discussion :)
06:55:46 <mmorrow> , ppDoc <$> tupE (fmap lift [0..9::Int])
06:55:47 <lunabot>  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
06:55:48 <Axman6> yohan: http://www.haskell.org/haskellwiki/Introduction
06:55:51 <yohan> cool
06:55:54 <Vanadium> @src fmaps
06:55:54 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:55:59 <lilac> mmorrow: that fmaps 8 looks like 15 fmaps to me :)
06:56:12 <Veinor> sup dawg, I herd u like fmaps
06:56:39 * mmorrow throws .
06:56:45 <mmorrow> 's at lilac
06:56:45 * lilac has been trying to do some fmap calculus
06:57:02 * lilac fires ->'s at mmorrow
06:57:11 * Veinor readies the $ cannon
06:57:13 <saml> @type fmap
06:57:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:57:29 <mmorrow> :o
06:57:39 <mmorrow> @bot
06:57:39 <lunabot>  :o
06:57:39 <lambdabot> :)
06:57:58 <saml> @type fmap :: (a -> b) -> [a] -> [b]
06:58:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:58:01 * Vanadium fires some ~> at Veinor 
06:58:08 <saml> man i was confused mmorrow !
06:58:23 <mmorrow> saml: :o
06:58:26 <mmorrow> :)
06:59:15 * Veinor is hit, throws () at Vanadium
07:01:16 * Axman6 is still totally confused as to wtf axman sex is supposed to be, and so is google. is rooting jazz guitar players a large enough fetish to be given a name?
07:01:32 <lilac> let f 1 = fmap; f (n+1) = f n fmap. then: is every element of the image of f on the naturals well-typed? forall n and m, does there exist k such that f k = (f n) (f m)?
07:02:14 <Jafet> Among groupies, perhaps.
07:03:35 <saml> > let f 1 = fmap; f (n+1) = f n fmap  in f 3
07:03:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
07:04:27 <lilac> saml: f itself isn't well-typed, but f 3 is.
07:04:46 <lilac> @type fmap fmap fmap
07:04:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:05:01 <nlogax> @type fap fap fap
07:05:03 <lambdabot> Not in scope: `fap'
07:05:03 <lambdabot> Not in scope: `fap'
07:05:03 <lambdabot> Not in scope: `fap'
07:05:56 <wmealing> ...
07:06:04 <wmealing> some places i expect to see that.. just not here.
07:06:31 <saml> f 3 ==> f 2 fmap ==> f 1 fmap fmap ==> fmap fmap fmap ?
07:06:44 <saml> oh i see you already wrote it above
07:07:03 <lilac> f is a function only in the mathematical sense.
07:07:25 <saml> f could be template haskell?
07:07:41 <lilac> yep, i think that could work.
07:08:20 <benmachine> @type fmap fmap fmap fmap
07:08:22 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
07:08:35 <lilac> @type fmap fmap fmap fmap fmap
07:08:37 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
07:08:51 <burp> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
07:08:53 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f1, Functor f, Functor f2) => f1 (a -> b) -> f1 (f (f2 a) -> f (f2 b))
07:09:14 <burp> very useful stuff
07:09:27 <Veinor> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
07:09:29 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
07:09:56 <lilac> @type fmap . fmap . fmap
07:09:57 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
07:10:07 <burp> hehe
07:10:29 <benmachine> it seems like the typesigs don't get more complex
07:10:29 <lilac> ^^ that's fmap fmap (fmap fmap fmap), so (f 2) (f 3) = f (about 25)
07:10:34 <benmachine> maybe there is a loop
07:11:04 <Veinor> I think so.
07:11:53 <lilac> i think f is injective
07:11:57 <Veinor> fmap doesn't have a fixed point :(
07:12:11 <lilac> unlike flip which loops after 3
07:12:57 * benmachine looks up injective on wikipedia
07:12:59 <benmachine> um
07:13:03 <benmachine> isn't id injective?
07:13:26 <lilac> id is bijective
07:13:35 <Veinor> which implies it is also injective
07:13:38 <Veinor> and surjective
07:14:22 <benmachine> hm.
07:15:12 * benmachine fills half a terminal with fmaps as an experiment
07:15:42 * benmachine waits
07:16:05 <jfoutz> > id undefined
07:16:06 <andyjgill> Has anyone worked on a meta-cabal tool, for manipulating .cabal files?
07:16:09 <lambdabot>   * Exception: Prelude.undefined
07:16:16 <Veinor> jfoutz: ... what did you expect?
07:17:57 <jfoutz> well, does id actually map undefined to undefined, and the print errors out? or does id error when it encounters undefined?
07:18:20 <Veinor> so you mean, does it error before or after the undefined? Good question.
07:18:34 <Botje> id x = x
07:18:38 <Botje> id is nonstrict
07:18:47 <Botje> because it doesn't patternmatch on x
07:19:07 <Botje> so id undefined reduces to undefined, which errors
07:19:14 <lilac> i've not even managed to prove that an arbitrarily long sequence of fmaps is well-typed yet :-/
07:19:52 <lilac> the two are equivalent
07:19:55 <benmachine> lilac: in the interests of science I tried about 200
07:20:01 <benmachine> ghc now holds 89% of my RAM
07:20:19 <lilac> id is only actually called if its result is going to be forced, so it doesn't matter whether id forces the undefined or not
07:20:19 <Botje> is it demanding a ransom?
07:20:45 <lilac> is it demanding cofmaps to balance out the universe?
07:20:45 <JaffaCake> andyjgill: the Cabal lib has lots of useful stuff
07:21:51 <benmachine> interestingly the memory usage very quickly got very high but is now not increasing at a significant rate
07:21:54 <andyjgill> JaffaCake: I'm thinking of writing a sanitizer, that factors out the testing code (and the dependancies to QC), giving two packages.
07:22:43 <JaffaCake> I think we ought to be separating the dependencies in the original .cabal file
07:23:00 <JaffaCake> but your approach doesn't need changes to Cabal, which is good
07:25:18 <benmachine> lilac: looks like f 16 and f 8 have the same type
07:25:41 <lilac> then f 20 should be f 4
07:25:53 <lilac> or at least should be f 12
07:26:06 <benmachine> hmm
07:26:26 <lilac> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
07:26:28 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
07:26:29 <benmachine> f 20 = f 12
07:26:32 <lilac> ... which it does
07:27:41 <benmachine> seems that 8 = 12 = 16 = 20
07:27:45 <benmachine> but 4 is different
07:27:56 <benmachine> unless I am doing something wrong
07:27:56 <saml> what woudl fmap fmap mean?
07:28:10 <saml> this is hard
07:28:11 <lilac> f 4 != f 12. but f 5 = f 13
07:28:18 <lilac> fmap fmap = (fmap .)
07:28:30 <benmachine> fmap fmap (Just x) = Just (fmap x)
07:28:40 <benmachine> etc.
07:28:58 <saml> more confusing. does this kind of things help in programming?
07:29:07 <benmachine> erm
07:29:16 <lilac> probably not. functions of the form (fmap . fmap . <...> . fmap) are useful
07:29:29 <benmachine> it's interesting to know that functions are a Functor where fmap = (.)
07:29:50 <benmachine> (but only if you import Control.Monad.Instances)
07:30:08 <lilac> and (fmap . fmap . fmap . fmap) == fmap (fmap fmap fmap) (fmap fmap fmap) = fmap fmap (fmap fmap (fmap fmap fmap) = ...
07:31:00 <bob0> > fmap fmap $ (+3) (+3) (Just 1)
07:31:04 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
07:31:05 <lambdabot>    arising from the literal `1' at <...
07:31:17 <dino-> I'm having some parsec confusion. In this code I'd like to be able to 'capture' the digit as well: do { x <- manyTill anyChar digit; y <- digit; return (x, y) }
07:31:21 <bob0> > fmap fmap (+3) (+3) (Just 1)
07:31:25 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
07:31:25 <lambdabot>    arising from the literal `3' at <...
07:31:33 <andyjgill> JaffaCake: I'm trying to optimize the cabal files for *development*, which is where we spend most of the time, but be able to generate reasonable stand alone libraries and testing, that do not have unnecessary linkages. Most people just cabal install.
07:31:46 <benmachine> > fmap (fmap (+3)) (Just 1)
07:31:50 <lambdabot>   No instance for (GHC.Num.Num (f a))
07:31:50 <lambdabot>    arising from the literal `1' at <int...
07:31:52 <dino-> So, of course, it's consuming the digit in that manyTill. But I'm unsure how to basically do this in regexp: "(.*)([0-9])" to get both back
07:31:57 <benmachine> > fmap (fmap (+3)) (Just (Just 1))
07:31:59 <bob0> > fmap (fmap (+3)) (+3) $ (Just 1)
07:32:02 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
07:32:02 <lambdabot>    arising from the lite...
07:32:03 <lambdabot>   Just (Just 4)
07:32:26 <benmachine> > fmap (fmap (+3) (+3)) (Just 1)
07:32:29 <JaffaCake> andyjgill: yes, I understand the problem
07:32:30 <lambdabot>   Just 7
07:32:44 <JaffaCake> andyjgill: you can't just have a flag(devel)?
07:32:54 <benmachine> > fmap . fmap (+3) (+3) $ Just 1
07:32:58 <lambdabot>   Couldn't match expected type `a -> b'
07:33:02 <dino-> I've tried beating on it with try a bit, but I think this whole approach is wrong.
07:33:10 * benmachine confuses self
07:33:12 <andyjgill> Yes, thats a possibility.
07:33:16 <saml> dino-, it's unclear what you want..     /./  includes /[0-9]/
07:33:33 <andyjgill> I've not used flags inside cabal yet.
07:33:34 <bob0> > fmap . fmap $ (+3) (+3) $ Just 1
07:33:37 <lambdabot>   Couldn't match expected type `a -> b'
07:33:41 <dino-> saml: And yet, this: $ perl -le '@r = map {print qq/"$_"/} $ARGV[0] =~ /(.*)([0-9])/' "foo bar 1 baz"
07:33:47 <dino-> gives me: "abc"
07:33:48 <dino-> "1"
07:34:02 <bob0> > fmap . fmap $ (+3) (+3) $ Just$Just 1
07:34:06 <lambdabot>   Couldn't match expected type `a -> b'
07:34:07 <saml> i don't know perl
07:34:12 <bob0> > fmap . fmap $ (+3) (+3) $ ($) Just Just 1
07:34:16 <dino-> Sorry wrong clip. "foo bar " "1"
07:34:16 <lambdabot>   Couldn't match expected type `t -> a'
07:34:21 <benmachine> bob0: you can PM lambdabot, by the way
07:34:47 <dino-> if it was: $ perl -le '@r = map {print qq/"$_"/} $ARGV[0] =~ /(.*)([0-9])/' "abc1"
07:34:59 <dino-> But I see what you're saying. Why does that work? :o
07:35:24 <saml> oh i see what you mean
07:35:25 <dino-> When . matches anything and aiui it's greedy by default
07:35:32 <benmachine> dino-: I think manyTill is wrong if you also want to get the last character
07:36:25 <dino-> benmachine: ya, I need to learn how to do these very basic things with the old parsec.
07:36:47 <Axman6> hmmm... that doesn't seem right. seems i've written a parallel quicksort that's faster than the data.list one, with when it's not parallel
07:36:56 <benmachine> when I wanted to do something similar I did many $ noneOf ['\\', '\n']
07:36:57 <dino-> Most of the examples I've read (like RWH) are great for if you want to throw away delimiters and things.
07:38:19 <kw-> hi. could someone assert my assumption regarding lazy evaluation here: https://gist.github.com/90407c3adf93e1e34755 ? thanks :)
07:38:39 <dino-> btw, gotta love that Perl above. It's pure noise. :o
07:39:16 <quicksilver> kw-: the answer is "yes"
07:39:32 <quicksilver> kw-: yes, head (factors n) is actually evaluated. But that will of course only force the first element.
07:39:44 <quicksilver> kw-: that's what non-strict evaluation does.
07:40:01 <andyjgill> JaffaCake: Will a flag in cabal hide any dependencies, like to QC?
07:40:05 <quicksilver> > head (1 : error "if this part was every actually evaluated, this error message would appear")
07:40:09 <lambdabot>   1
07:40:16 <Axman6> that's the whole reason why the oh so common infinite factorials code works so well
07:40:18 <kw-> ok, thanks
07:40:45 <JaffaCake> andyjgill: you can have a flag that turns on your testing code, including the QC dependency, and have it off by default
07:41:32 <dino-> many1 $ noneOf "0123456789"  works. Thanks saml, benmachine
07:41:53 <benmachine> dino-: you could also do many $ satisfy (not . isDigit)
07:42:12 <dino-> that seems nicer
07:42:15 <benmachine> (import Data.Char (isDigit))
07:43:04 <benmachine> I'm surprised that there isn't a parsec thing that takes a parser as an argument and accepts anything that the argument does not
07:43:29 <benmachine> unless there is and I haven't seen it
07:43:59 <andyjgill> JaffaCake: But if someone includes my package, will it take the default dependancies, or the superset of packages for all options?
07:44:08 <benmachine> also surprised that satisfy is specific to Chars rather than general in tokens
07:44:26 <JaffaCake> andyjgill: if the flag defaults to false, then it won't include that dependency
07:44:45 <andyjgill> JaffaCake: Thanks. That is useful to know!
07:45:47 <bob0> > last (1 : error "if this part was every actually evaluated, this error message would appear")
07:45:51 <lambdabot>   * Exception: if this part was every actually evaluated, this error message ...
07:47:13 <dolio> benmachine: I'm not sure that's really feasible. For instance, negate (char 'c') accepts any string except a single 'c'?
07:48:06 <benmachine> dolio: hmm, good point
07:49:04 <lilac> benmachine: you can always get parsec to tell you its current state, run a parser from where you are, and make a function "matches :: Parsec s u a -> Parsec s u Bool"
07:49:41 <lilac> then: do b <- matches (char 'c'); guard (not b); parseSomething
07:51:51 * benmachine hasn't used guard with parsec
07:52:06 <lilac> might make sense to bundle that up as 'lookahead :: Parser a -> Parser (); negativeLookahead :: Parser a -> Parser ()'
07:52:10 <Saizan_> is there a reason why we don't allow data/type/class/instance declarations in @let ? in Plugin.Eval there's even a comment with examples defining those..
07:52:34 <lilac> Saizan_: Typeable instances could cause injury
07:52:52 <quicksilver> instance Typeable Hammer where typeOf _ = error "Ow! My thumb!"
07:53:07 <Saizan_> well, a segfault at worse
07:53:26 <Saizan_> it seems to me the only dangerous thing is imports
07:53:29 <lilac> also there are some GHC bugs with GADTs and type families which you can exploit to create unsafeCoerce
07:53:48 <lilac> once you have unsafeCoerce you can make unsafePerformIO out of runST
07:53:48 <quicksilver> it's unsafePerformIO we really worry about though isn't it?
07:53:58 <Saizan_> oh.
07:54:02 <quicksilver> :t runST
07:54:03 <lambdabot> forall a. (forall s. ST s a) -> a
07:54:09 <quicksilver> clever.
07:54:17 <quicksilver> lilac++ # mindful of evil
07:54:22 <quicksilver> or should that be "mind full of evil" ?
07:55:16 <Saizan_> damn unsound type system!
07:57:53 <fasta> "make unsafePerformIO out of runST" sounds evil indeed. How?
07:58:12 <copumpkin> you need the IOtoST function
07:58:26 <fasta> copumpkin: but that one is unsafe.
07:59:05 <copumpkin> I don't think there's any other way, unless you use the actual ST and IO constructors
07:59:12 <fasta> copumpkin: so, there is no hole.
07:59:19 <fasta> At least not there.
07:59:35 <fasta> I am pretty sure TypeFamilies are full of holes.
07:59:37 <Saizan_> fasta: assuming you've an unsafeCoerce
07:59:59 <fasta> Saizan_: yes, but unsafeCoerce is already unsafe.
08:00:18 <Saizan_> fasta: right, but we wondered "is unsafeCoerce enough to run IO?"
08:00:31 <fasta> Saizan_: ah, ok.
08:00:36 <copumpkin> fasta: the only controversial hole in type families that I know of is making type equality "see through" newtype wrappers
08:00:52 <copumpkin> there were a few bugs but I think they've mostly been fixed in HEAD
08:01:12 <Saizan_> copumpkin: there's one thing with OverlappingInstances and data families that let you write unsafeCoerce, iirc
08:01:15 <fasta> copumpkin: I don't know of any specific hole, but I know lots of bugs have been reported. I don't expect them to fully work until in a few years.
08:01:21 <burp> @hoogle error
08:01:22 <lambdabot> Prelude error :: String -> a
08:01:22 <lambdabot> module Control.Monad.Error
08:01:22 <lambdabot> module Foreign.C.Error
08:01:25 <copumpkin> Saizan_: yeah, I thought that had been fixed in HEAD
08:01:31 <Saizan_> ah, k
08:01:37 <copumpkin> maybe not, but I thought I'd read that somewhere
08:02:07 <dolio> It's didn't atually have anything to do with OverlappingInstances, because that flag doesn't do anything to type families.
08:02:13 <dolio> It was just a bug that allowed overlap.
08:02:28 <Saizan_> ah, i was wondering that, in fact
08:04:38 <Saizan_> it's a shame that Data.Typeable + runST let you write unsafePerformIO anyhow
08:05:10 <dolio> Data.Typeable lets you writ unsafeCoerce.
08:05:25 <Twey> :t unsafeCoerce
08:05:27 <lambdabot> Not in scope: `unsafeCoerce'
08:05:30 <Twey> Bah
08:05:45 <Twey> How does this come to be so?
08:06:24 <dolio> Twey: You manually write a Typeable instance such that the type rep for a certain type isn't unique to the type.
08:07:04 <copumpkin> but that's just because Typeable uses unsafeCoerce behind the scenes, right?
08:07:13 <copumpkin> with certain assumptions
08:07:20 <dolio> Yeah.
08:07:43 <quicksilver> yes, Data.Typeable is at fault here.
08:07:53 <quicksilver> if we want this service to be safe, we want "typeOf" to be written by the compiler.
08:08:03 <quicksilver> and disable programming writing of it.
08:08:07 <quicksilver> programmer.
08:08:09 --- mode: quicksilver set -o quicksilver
08:08:20 <Laacis> HTTP://MU.GAMEFOR.LV BET MUONLINE EVER! JOIN US NOW!
08:08:21 <Laacis> HTTP://MU.GAMEFOR.LV BET MUONLINE EVER! JOIN US NOW!
08:08:23 --- mode: ChanServ set +o quicksilver
08:08:24 <copumpkin> lol
08:08:25 <copumpkin> just in time
08:08:32 --- mode: quicksilver set -o quicksilver
08:08:46 <copumpkin> I still think if this channel were +p or +s, we'd get a lot less of that :P
08:09:00 <benmachine> that is possibly true
08:09:00 <burp> how do I catch an error that is raised via prelude "error" in a pure/non IO function?
08:09:04 <quicksilver> I think freenode should add security features
08:09:07 <roconnor> @type (<=<)
08:09:09 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
08:09:13 <burp> I tried "try (return f)"
08:09:15 <benmachine> what use is /list anyway
08:09:17 <copumpkin> burp: you don't
08:09:22 <quicksilver> if someone joins a channel and posts a URL like that, someone should go round to their house and break a finger in a way that won't heal
08:09:31 <burp> copumpkin: then the json package is crap
08:09:35 <copumpkin> burp: lol
08:09:35 <quicksilver> after a few offences they won't really be able to type any more.
08:09:43 <burp> it raises an "error" on parse failure
08:09:43 <Saizan_> copumpkin: you can
08:09:46 <Saizan_> from IO
08:09:52 <copumpkin> Saizan_: yeah, but he asked from a pure function
08:10:08 <copumpkin> burp: you can do it with unsafePerformIO, since the errors are referentially transparent, but it's ugly
08:10:10 <Saizan_> the error is from the pure function, i guess
08:10:17 <benmachine> you can catch an error in IO that is raised in a pure function
08:10:19 <burp> http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/src/Text-JSON-Generic.html#decodeJSON
08:10:23 <burp> have a look at the very bottom
08:10:31 <dolio> newtype W a = W { fromW :: a } ; instance Typeable (W a) where typeOf _ = typeOf () ; coerce :: a -> b ; coerce = fromW . fromJust . cast . W
08:10:48 <dolio> coerce () :: [Int] ==> []
08:10:49 <burp> why do they raise an error instead of returning this either they just got?
08:11:11 <Saizan_> burp: try (evaluate v) will work there
08:11:40 <quicksilver> dolio: cute? the representation of [] is the same as the representation of () ?
08:11:42 <burp> Saizan_: thanks
08:11:47 <burp> :t evaluate
08:11:49 <lambdabot> Not in scope: `evaluate'
08:12:05 <dolio> quicksilver: Yeah. That happens for lots of types.
08:12:15 <quicksilver> dolio: GHC should share them! MOAR SHARING!
08:12:17 <dolio> Nothing is the same as [].
08:12:29 <Saizan_> ?type Control.Exception.evaluate
08:12:31 <lambdabot> forall a. a -> IO a
08:12:35 <dolio> Since they're the #1 constructor or something.
08:12:46 <burp> "Forces its argument to be evaluated to weak head normal form when the resultant IO action is executed."
08:12:56 <dolio> Coercing (x:xs) :: [a] to Maybe a gets you Just x, too, I believe.
08:13:29 <quicksilver> dolio: yes, makes sense
08:13:52 <quicksilver> dolio: although at some point (n+1)-ary constructors must somehow use 'more space' than n-ary ones
08:13:55 <dolio> Increased program efficiency through unsafeCoerce and uniform representation! :)
08:14:00 <Saizan_> burp: however you could mor cleanly define your own decodeJSON, runGetJSON and fromJSON are both exported
08:14:18 <Twey> @index unsafeCoerce
08:14:18 <lambdabot> bzzt
08:14:27 <benmachine> wait so listToMaybe is basically unsafeCoerce
08:14:32 <copumpkin> benmachine: not really
08:14:36 <benmachine> only with a rigid type
08:14:39 * Twey sighs.
08:14:43 <Saizan_> and less sharing
08:14:44 <burp> Saizan_: I think I will do that
08:14:49 <Saizan_> Twey: Unsafe.Coerce
08:14:52 <copumpkin> @src listToMaybe
08:14:52 <Twey> Ah, thanks
08:14:53 <lambdabot> listToMaybe []        =  Nothing
08:14:53 <lambdabot> listToMaybe (a:_)     =  Just a
08:15:00 <dolio> listToMaybe goes the inefficient route by doing case analysis and constructing a separate Maybe a.
08:15:05 <burp> burp: that I I'm not gonna need IO
08:15:56 <benmachine> woo I segfaulted ghci
08:15:58 <Twey> So, I figure that it's not *really* possible to write unsafeCoerce with Data.Typeable, because you don't get the a -> b type.
08:16:08 <dolio> Using unsafeCoerce is like casting pointers in C. And it happens that the memory representation of lists and Maybes is such that coercing the former to the latter behaves like listToMaybe.
08:16:10 <benmachine> coercing Just 4 to an [Int]
08:16:19 <Saizan_> Twey: sure you do
08:16:20 <quicksilver> Twey: dolio demonstrated it
08:16:20 <Twey> dolio: In GHC.
08:16:24 <quicksilver> Twey: 6 minutes ago.
08:16:28 <Twey> Really?  Drat.
08:16:29 <benmachine> oh
08:16:36 <Twey> Aha
08:16:40 <benmachine> no I coerced Just to Int -> [Int]
08:16:40 <Twey> I see
08:16:44 <benmachine> and then applied it to 4
08:17:11 <dolio> Yeah. Coercing data to functions and using the functions doesn't work out too well.
08:17:29 <Twey> Heh
08:17:40 <benmachine> I actually got [4Segmentation fault
08:17:59 <benmachine> which is not bad I think
08:18:09 <idnar> curious
08:18:23 <idnar> oh, Just, not Just 4
08:18:32 <idnar> so I guess that makes sense
08:18:57 <benmachine> unsafeCoerce Just 4 :: [Int] is what I typed
08:22:33 <quicksilver> benmachine: lucky you're using a protected memory OS :)
08:22:44 <quicksilver> people moan about what a pain seg faults are
08:22:57 <quicksilver> but, having learnt to program on a non-protected OS I can tell you the alternative is worse :)
08:23:27 <benmachine> well, even on a protected memory OS the only thing worse than memory corruption causing a segfault is memory corruption not causing a segfault >_>
08:23:51 <lilac> benmachine: that too is worse without memory protection
08:23:51 <quicksilver> right
08:23:53 <ski> (quicksilver : ooc, which OS was that ?)
08:24:11 <quicksilver> ski: I learnt to program on the dragon 32, although my memory of that system is not too good anymore.
08:24:30 <quicksilver> ski: but also amstrad CPC (a Z80) and the early macs (68k with no MMU)
08:24:39 <fasta> Introducing rm -rf ~ with a probability of 0.1% in a KDE program and segfauls in all other cases would be rather evil.
08:24:42 <ski> can't say i've heard of "dragon 32" before
08:25:02 <quicksilver> UK version of a TRS-80 if that helps
08:25:11 <quicksilver> http://en.wikipedia.org/wiki/Dragon_32/64
08:25:15 <ski> ok (says a little bit more)
08:25:23 <quicksilver> it had basic and we also had a pascal setup for it
08:25:56 * ski has a few C64s and an Amiga .. no MMU there, either
08:26:27 <quicksilver> if you were really really unlucky you could actually permanently damage things
08:26:42 <quicksilver> some of the IO areas were actually dangerous to write to :-S
08:27:21 <mmorrow> heh
08:27:52 <mmorrow> oh noes i accidently teh cathode ray toobz!
08:28:01 <quicksilver> quite
08:29:05 <Taejo> should one list extensions with LANGUAGE pragmas, in the cabal extensions field, or both?
08:29:34 <fasta> Taejo: per module is best, imho.
08:29:54 <fasta> Taejo: but both work.
08:29:59 <lilac> the cabal field has the advantage that in principle you can determine whether a compiler supports a package without trying it
08:30:21 <fasta> lilac: you can also write a trivial script which determines the same.
08:31:09 <quicksilver> I think the best (though annoying) answer is 'both'
08:31:16 <quicksilver> in each file, to indicate what that file needs
08:31:27 <quicksilver> and in the .cabal file, to indicate what the package as a whole needs
08:32:06 <lilac> fasta: not without downloading the source code
08:32:51 <Taejo> @hoogle [(a,b)] -> ([a], [b])
08:32:52 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
08:32:52 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
08:32:53 <lilac> the normal state of cabal for an uninstalled package is that it has the .cabal file but not the rest of the package (aiui)
08:32:57 <fasta> lilac: true, but the use case is quite unlikely to begin with; everyone uses GHC anyway.
08:33:50 <lilac> almost everyone uses GHC /today/. not necessarily in the future :)
08:34:29 <fasta> Does Galois actually use GHC to do high-assurance stuff? It seems that the GHC RTS is not up to that task.
08:36:24 <fasta> Writing a program in GHC which then generates another program that gets run on a FPGA is a different story, of course.
08:36:28 <dino-> More parsec fun. I'd like to get out of "foo bar (baz)" -> "foo bar"
08:36:28 <lilac> what do you mean by 'assurance'?
08:36:40 <dino-> But I can't really manyTill anyChar $ string " ("
08:37:29 <jmcarthur_work> fasta, they have their own language i think
08:37:45 <lilac> dino-: does there have to be a space before the (?
08:37:49 <Lemmih> > unwords . take 2 . words $ "foo bar (baz)"
08:37:51 <jmcarthur_work> written in haskell
08:37:54 <lambdabot>   "foo bar"
08:38:04 <dino-> lilac: There is always a space, and I never want it in the "capture"
08:38:11 <dino-> But there are other spaces in the desired string that I do want.
08:38:21 <fasta> jmcarthur_work: based on what do you say that?
08:38:24 <Taejo> jmcarthur_work: they have Cryptol
08:38:29 <lilac> dino-: manyTill (manyTill (char ' ')) (char '(') ?
08:38:33 <fasta> jmcarthur_work: I know there is Cryptol, of course.
08:38:39 <dino-> This stuff is tough for my regexp-trained mind!
08:39:03 <Jafet> Most regular expressions are irregular
08:39:07 <Vanadium> < dino-> But I can't really manyTill anyChar $ string " (" <- why not?
08:39:08 <fasta> It would seem a terribly good joke for dons to market Haskell, without actually using it ;)
08:39:13 <Vanadium> Would a "try" fix that?
08:39:32 <jmcarthur_work> i might just be thinking cryptol
08:40:36 <jmcarthur_work> > let withWords = (unwords .) . (. words) in withWords (take 2) "foo bar (baz)"
08:40:42 <lambdabot>   "foo bar"
08:40:53 <lilac> @pl \f g -> (f.).(.g)
08:40:53 <lambdabot> (. flip (.)) . (.) . (.)
08:40:58 * jmcarthur_work should really make a little utilities module for stuff like that
08:41:29 <copumpkin> jmcarthur_work: I'd prefer a withWords that preserves whitespace
08:41:35 <Taejo> @unpl withWords = (unwords .) . (. words)
08:41:36 <lambdabot> withWords e h = unwords (e (words h))
08:41:36 <jmcarthur_work> i don't know how i've gotten so far without one
08:41:38 <lilac> > let bracket = (.flip(.)).(.).(.); withWords = bracket unwords words in withWords (take 2) "this is a test"
08:41:42 <lambdabot>   "this is"
08:41:55 <tavelram> and one for withLines, and withColons, and withCommas, omg, you could start a franchise!
08:42:01 <jmcarthur_work> copumpkin, you're right. that's just a naive version
08:42:24 <jmcarthur_work> tavelram, actually, a general function for that kind of thing would be cool
08:42:42 <Taejo> might be worth using the split-specification type in Data.List.Split
08:42:42 <Twey> tavelram: Haha
08:42:50 <Twey> Yes, it would
08:42:57 <tavelram> indeed, but then youd need a way to know the inverse of a function, so it would be to verbose to implement, probably.
08:43:09 <jmcarthur_work> a pattern to split on, a function to perform on each unit, then join each unit back together with the original chars
08:43:10 <Twey> We should introduce some sort of convention for invertable functions
08:43:12 <dino-> Vanadium: When I do (manyTill anyChar $ string " (") against this string "foo bar (baz)" ..
08:43:21 <dino-> I get unexpected "b"  expecting " ("
08:43:23 <jmcarthur_work> tavelram, inverse of what function?
08:43:28 <Twey> words = (words, unwords)
08:43:30 <tavelram> the first one..
08:43:41 <dino-> The manyTill (manyTill ...) isn't working either
08:43:43 <Vanadium> dino-: Use try (string " (")?
08:43:55 <roconnor> @djinn Not (Not (Either a (Not a)))
08:43:55 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
08:43:57 <jmcarthur_work> tavelram, i'm thinking just keep a list of the chunks that were cut out and then interleave that with the resulting list at the end
08:43:58 <EnglishGent^afk> @hoogle Sqlite3
08:43:59 <lambdabot> package haskelldb-hdbc-sqlite3
08:43:59 <lambdabot> package haskelldb-hsql-sqlite3
08:43:59 <lambdabot> package HDBC-sqlite3
08:44:07 <Twey> with (f, g) = (f .) . (. g)
08:44:11 <jmcarthur_work> tavelram, would mean no inverse is required
08:44:14 <Twey> with words (take 2)
08:44:31 <tavelram> jmcarthur, true :).
08:44:33 <Twey> Or possibly a typeclass
08:44:36 <dino-> Vanadium: huh, the try helped there
08:44:41 <jmcarthur_work> of course, it means you can't use functions like words
08:44:43 <Twey> Hm, but that only works with types
08:44:55 <jmcarthur_work> it would be more like a conditional
08:44:58 <Vanadium> dino-: backtracking is expensive, so it is off by default. "try" turns it on, basically.
08:45:26 <Vanadium> "expensive" might be a bif of an exaggeration for a simple string " (", I suppose
08:45:50 <dino-> Vanadium: I have such trouble figuring out when it's needed though.
08:46:42 <tavelram> Twey, indeed
08:47:16 <dino-> Thank you again. lilac, Vanadium
08:47:17 <benmachine> dino-: I'd do something like http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=3556#a3556
08:47:28 <benmachine> wait
08:47:32 <aavogt> @check \x -> x == (unwords . words $ x)
08:47:34 <benmachine> that doesn't quite work
08:47:35 <lambdabot>   "Falsifiable, after 498 tests:\n\"\\435906\\906967\\8201\\323999\\1071301\\...
08:47:46 <aavogt> @check \x -> x == (unwords . words $ x)
08:47:50 <lambdabot>   mueval-core: Time limit exceeded
08:47:55 <Alpounet> http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/Acme-Time-Now.html <<< very nice
08:47:57 <Twey> aavogt: It drops trailing linebreaks
08:47:58 <jmcarthur_work> yeah unwords and words are not actually inverses
08:48:19 <Twey> Well, close enough.
08:48:24 <benmachine> > unwords . words $ "foo   bar"
08:48:27 <lambdabot>   "foo bar"
08:48:31 <copumpkin> @check \x -> x == (words . unwords $ x)
08:48:32 <aavogt> > unwords $ words "    hello        there"
08:48:35 <lambdabot>   mueval-core: Time limit exceeded
08:48:36 <lambdabot>   "hello there"
08:48:45 <dino-> I see, trying to iteratively consume to get up to the target stop pattern without backtracking
08:49:02 <tavelram> i remember seeing somewhere a notation of reversable functions, eg farenheit to celsius conversions...
08:49:09 <benmachine> dino-: yeah the thing I pasted doesn't actually typecheck, but that's the general idea
08:49:18 <Twey> @check uncurry (==) . (words *** unwords)
08:49:20 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:49:20 <dino-> word by word and pulling in the trailing space only if appropriate
08:49:29 * benmachine wonders why spaces returns ()
08:50:50 <dino-> ya, that seems a little strange that it isn't CharParser st String
08:53:16 <Twey> @hoogle Arrow a => a b c -> a b' c' -> b -> (c, c')
08:53:17 <lambdabot> Data.Array.Base unsafeAccumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(Int, e')] -> a i e
08:53:24 * Twey scratches his head.
08:53:30 <copumpkin> I don't think hoogle's very good with arrows
08:53:36 <Twey> Oh, I guess it is &&& I wanted.
08:53:41 <Twey> @check uncurry (==) . (words &&& unwords)
08:53:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:53:49 <Twey> No?  Maybe not.
08:53:58 <Twey> Oh, no.
08:54:01 <copumpkin> yeah it is, but you restricted the type of the last one
08:54:08 <Twey> I've just buggered the whole thing up.
08:54:09 <lilac> @hoogle Arrow a => a b c -> a b c' -> a b (c, c')
08:54:10 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
08:54:10 <copumpkin> @type (&&&)
08:54:11 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:54:28 <benmachine> dino-: just in case you need it, http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=3556 <-- revised version
08:54:36 <Twey> @check uncurry (==) . ((words . unwords) &&& id)
08:54:39 <lambdabot>   "Falsifiable, after 0 tests:\n[\"\\1109914\",\"\"]\n"
08:54:43 <Twey> That's the one
08:54:51 <lilac> @hoogle Arrow (~>) => b ~> c -> b ~> c' -> b ~> (c, c')
08:54:51 <lambdabot> Did you mean: ~> b (c -> ~> b (c' -> ~> b (c, c'))) /count=20
08:54:51 <lambdabot> No results found
08:55:11 <lilac> wow, that's... that's a very very wrong suggestion :)
08:55:18 <copumpkin> lol
08:55:22 <copumpkin> it isn't that bad
08:55:28 <copumpkin> it just didn't know how to infixify it
08:55:29 <benmachine> lilac: maybe brackets would help?
08:55:39 <benmachine> or
08:55:42 <benmachine> maybe they wouldn't.
08:56:06 <benmachine> p.s. can we do type operator sections yet
08:56:19 <benmachine> er, constructor I suppose, not operator
08:56:20 <dino-> benmachine: Thank you
08:56:26 <lilac> benmachine: actually, they do help:
08:56:27 <lilac> @hoogle Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
08:56:28 <lambdabot> Did you mean: ~> b c -> ~> b c' -> ~> b (c, c') /count=20
08:56:28 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
08:57:14 <copumpkin> for functions, that's also bimap in category-extras
08:57:26 <copumpkin> which is more general in one way and less general in another
08:57:50 * lilac contemplates registering the domain control.monad.st
08:58:09 <copumpkin> cute
08:59:19 <jmcarthur_work> haha
09:03:52 <burp> @hoogle type
09:03:52 <lambdabot> keyword type
09:03:52 <lambdabot> Language.Haskell.TH data Type
09:03:52 <lambdabot> Language.Haskell.TH.Syntax data Type
09:08:15 <atom> hi everyone. I've got a problem I don't really know how to solve
09:08:26 <jmcarthur_work> withSplitter: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9274#a9274
09:08:33 <jmcarthur_work> :)
09:08:33 <lilac> atom: use FLOOR-CLEANER on BLOODY CARPET
09:08:34 <atom> It's got to do with datatypes
09:09:21 <bastl> dcoutts: online? i have a question to cabals preprocessing ...
09:09:26 <atom> lilac: there is a hole in the carpet. You look through the hole. You see a maze of twisty little cabbages
09:09:27 <wjt> use STAPLE REMOVER with TREMENDOUS-LOOKING DATATYPE
09:09:46 <lilac> atom: EXAMINE CABBAGES
09:10:10 <jmcarthur_work> hmm... i suppose i could leave in the splitter's postprocessing stuff
09:10:14 <atom> lilac: they are green and wrinkly. They also look mildly radioactive
09:10:36 <jmcarthur_work> maybe turning it into something that modifies a splitter instead of modifying its output
09:10:37 <atom> wjt: STAPLE REMOVER is not in your inventory
09:10:42 <lilac> use PERFECTLY ORDINARY SPIDER on CABBAGES
09:10:49 <jmcarthur_work> i think that would require changing the representation of Splitter, though
09:11:30 <atom> lilac: Fatal Error (irc does not support FMV sequences)
09:11:46 <atom> heh
09:11:52 <jmcarthur_work> if Delimiter was actually exposed in Data.List.Split it would be nicest, i think
09:11:56 <atom> MUDs with a mechanical turk could be fun
09:12:47 <lilac> atom: anyway. datatypes?
09:13:33 <atom> I have to rephrase it because in the process of writing it I discovered what mistake I was doing. Now I have to figure out how to get an equivalent thing
09:14:08 <atom> sooo.. what I *was* trying to do was data Mytype = Mytipe Num Num
09:14:15 <atom> obviously, haskell complained.
09:14:35 <atom> how can I write it the right way?
09:14:55 <atom> (my noobnes shines)
09:14:57 <ski> wjt : You fight like a dairy farmer.
09:14:59 <quicksilver> data MyType a = MyType a a
09:15:00 <Lemmih> atom: That's a tuple.
09:15:20 <lilac> atom: what do you want as the values? /anything/ which is in typeclass Num? or a specific type?
09:15:24 <quicksilver> and just use (or infer) num constraints when you use it
09:15:36 <ski> atom : do you want a pair of numbers of the same type ? or possibly of different types ?
09:16:00 <atom> lilac: I *actually* need a matrix from Data.Vec.Base there
09:16:11 <atom> lilac: I just thought I could simplify the example
09:17:25 <atom> and what I'm trying to do is data Derivative = Derivative {dx :: Vec (Vec Double), dy :: Vec (Vec Double)}
09:17:36 <bob0> why is unsafeCoerce unsafe?
09:17:38 <wjt> ski: how appropriate. you fight like an symmetric monoidal closed category
09:17:46 <Rotaerk> bob0, because it says so duh
09:17:52 <copumpkin> bob0: you can treat any datatype as any other type
09:17:56 <atom> I know haskell complains because I specified typeclasses but I don't know what it does want.
09:18:00 <copumpkin> bob0: also, you can prove any statement with it
09:18:07 <mm_freak> what is a good IDE for haskell development under windows?  something that i don't need to compile myself or extend with hundreds of third party modules would be great
09:18:11 <ski> wjt : I'm shaking, I'm shaking!
09:18:17 <lilac> atom: do you want that for a vector of any dimension? or just Vec2 or Vec3 or something
09:18:25 <atom> or should I just leave the thing be and just use it in functions as I want?
09:18:51 <Guest99490> \nick N8Dawg
09:18:54 <lilac> ski: I once owned a monad that was smarter than you!
09:18:55 <Guest99490> damn
09:19:17 <atom> lilac: I don't now the dimension up front
09:19:34 <atom> lilac: all I know is that every vector I'll be handling will be compatible
09:19:51 <atom> I want to code this as generally as I possibly can
09:20:20 <N8Dawg> i had a 'almost certainly' silly question
09:20:34 <N8Dawg> about lists and other immutable data structures
09:20:53 <lilac> atom: is the dimension unique across the entire program?
09:21:21 <N8Dawg> could the runtime detect when an 'old' data structure goes out of scope
09:21:23 <benmachine> is there a file I can use to specify commands to run when I start ghci?
09:21:23 <atom> lilac: um... no, i's unique across the function call
09:21:31 * benmachine wants to customise his prompt, among other things
09:21:42 <N8Dawg> and do an in-place update?
09:21:51 <N8Dawg> e.g. in recursive loops etc
09:21:54 <aavogt> benmachine: ~/.ghci
09:22:19 <benmachine> aavogt: handy, thanks
09:22:25 <atom> lilac: lilac but the dimension is unique for all vectors that exist at any one time
09:22:44 <Varan> I was reading http://www.haskell.org/ghc/docs/6.6/html/users_guide/lang-parallel.html and wondering why you would need par and seq? Could it not be determined at runtime what expression needs to be done in a new thread?
09:23:22 <conal> Varan: maybe, though so far no one has figured out how to make that determination well.
09:23:24 <lilac> atom: you could solve this with a type-level natural representing the dimension
09:23:38 <quicksilver> Varan: please, go ahead and write it :) You willl become famous and possibly very rich :)
09:23:46 <atom> lilac: well, I'd love to do it if I knew what that was :)
09:23:48 <jmcarthur_work> nah, not rich
09:23:49 <Varan> Hmm
09:23:49 <jmcarthur_work> just famous
09:23:51 <ski> lilac : It must have returned everything you know.
09:24:02 <Raevel> N8Dawg: not a silly question. Though i don't know whether it's done
09:24:13 <atom> lilac: got a link?
09:24:19 <Varan> well didn't seem to hard in my head :P ... but i think you would need to have an interperter instead of a compiler
09:24:24 <jmcarthur_work> it's easy for the compiler to put parallelism into a pure expression. it's hard to make it do so wisely
09:24:26 <Veinor> jmcarthur_work: patent it, sell the patent
09:24:43 <jmcarthur_work> or interpreter
09:24:51 <Varan> conal: are there any papers on this? Could you point me in the right direction?
09:24:56 <quicksilver> N8Dawg: it isn't done, and it's quite fiddly.
09:24:58 <jmcarthur_work> an interpreter might have a somewhat easier time through runtime profiling
09:25:03 <Veinor> "method for determining which segments of a program may be executed in parallel"
09:25:07 <jmcarthur_work> but i don't know if the costs would be worth it. at least not yet
09:25:10 <Veinor> oh I'm sorry you can't patent algorithms
09:25:13 <Veinor> "... on a computer"
09:25:15 <Veinor> patent granted!
09:25:28 <conal> Varan: i can't, but other folks could.  try an inquiry on haskell-cafe.
09:25:34 <quicksilver> Varan: you could try googling for "speculative evaluation"
09:25:39 <Raevel> N8Dawg: i'm thinking that if it would be useful, there might be another data structure better suited for the job
09:25:41 <quicksilver> or "optimisitic evaluation"
09:25:44 <Varan> I think most of the haskell things are compilers right?
09:25:47 <quicksilver> and possibly add the word 'haskell' if you like.
09:25:54 <Varan> that compile to for example x86 code
09:26:10 <Varan> hmm owke thanks
09:26:24 <conal> Varan: if you have some ideas on how, please blog about them to stimulate discussion.  it'd be a great problem to solve.
09:26:48 <ski> N8Dawg : i think it is done in Clean and Mercury
09:27:08 <Veinor> Automagically writing parallel code is one of the current holy grails of CS.
09:27:16 <Veinor> Since we've pretty much given up on P=NP :P
09:27:40 <Varan> Hmm I was just thinking about it ... I'm kinda new to the functional language scene... but I think functional languages lend them very well for paralel calculations .. because of the no side effects "rule"
09:27:44 <N8Dawg> i'm imagining the problem looks like a garbage collection problem
09:27:50 <quicksilver> carlocci: http://scholar.google.com/scholar?cluster=5268199032769903273&hl=en
09:27:52 <quicksilver> Varan: http://scholar.google.com/scholar?cluster=5268199032769903273&hl=en
09:27:55 <Varan> I think ill do some more reading first :P
09:27:56 <Beelsebob> Varan: that was the hope
09:28:00 <quicksilver> Varan: is probably a good paper but it's not very recent.
09:28:08 <Varan> quicksilver: thanks
09:28:09 <Beelsebob> and in fact, it's true, you can easily make parallel functional programs...
09:28:19 <conal> Varan: yes, and more generally/simply because the don't contain accidental sequentiality.
09:28:19 <Beelsebob> you just stick in a few pars and pseqs and you get parallelism
09:28:20 <jmcarthur_work> it's extremely easy to make maximally parallel programs. the problem is we don't really want maximally parallel programs
09:28:27 <Beelsebob> what's difficult is doing it in a way that actually work efficiently
09:28:34 <Beelsebob> because forking off small tasks is useless
09:28:41 <Beelsebob> and what's even harder is getting the compiler to figure that out for you
09:28:50 <Beelsebob> (in fact, it remains an unsolved problem)
09:28:51 <Varan> jmcarthur_work: why not?
09:29:00 <jmcarthur_work> Varan, exactly what Beelsebob just said
09:29:05 <Varan> hmm yeah oke
09:29:11 <quicksilver> Varan: because we only have a finite number of execution units :)
09:29:12 <Beelsebob> Varan: because if everything gets forked, you spend more time forking than doing work
09:29:20 <Beelsebob> the question is "where do I get time back if I fork"
09:29:22 <Varan> hmm I get it :P
09:29:25 <Beelsebob> and that's very hard to analyse
09:29:36 <quicksilver> depending the execution model 'collating' at the end can be a cost too
09:29:40 <Varan> Owke very interesting problem :P
09:29:46 <quicksilver> although in GHC in particular, collating is basically free
09:29:47 <clanehin> Varan, I agree it does intuitively *seem* like it should be an easy problem.
09:29:51 <quicksilver> because sparks mutate thunks in-place
09:29:53 <Varan> yes
09:29:57 <ski> "collate" being ?
09:30:03 <Varan> but it's because you forget the thread costs
09:30:11 <jmcarthur_work> collate = the reduce in map-reduce, i think
09:30:16 <quicksilver> ski: somehow gettin ghte results from the worker threads back to whichever thread 'wanted' the result in the first place
09:30:33 <ski> like "joining", then ?
09:30:59 <Varan> btw are there any haskell interperters?
09:31:05 <jmcarthur_work> hugs
09:31:09 <idnar> jmcarthur_work: the main thing is that the programming shouldn't need to figure out how much parallelism is desired
09:31:26 <idnar> er, the /programmer/
09:31:28 <jmcarthur_work> idnar, right
09:31:31 <idnar> because that probably varies depending on where your program is running, and so on
09:31:32 <Varan> indeed
09:31:43 <quicksilver> ski: yes. It wasn't a technical word, just the english word that seemed closest to what I meant
09:31:49 <ski> ok
09:32:03 <jmcarthur_work> i think an optimal solution might look like compiler-inserted annotations which represent optional sparking points for the runtime to pick
09:32:43 <jmcarthur_work> perhaps with some cost metric associated with each, and the runtime gets to determine whether it's paying off to take a spark or not
09:33:33 <Varan> what are the costs? .. i mean you dont have to create a new thread ... only switch... so it cannot be that costly
09:34:05 <idnar> even if you have an arbitrary number of execution units, it may be more expensive than it's worth to distribute the work between all of them
09:34:12 <jmcarthur_work> there is some overhead for each spark
09:34:20 <Varan> like what?
09:34:30 <Varan> you only have to switch to another stack right
09:34:48 <dolio> That isn't free.
09:34:59 <jmcarthur_work> i think it's actually less overhead than switching stacks, but regardless, it's not as cheap as free
09:35:15 <Varan> dolio: I know ... nothing is free...
09:35:51 <atom> even nothing isn't free
09:36:10 <Varan> lol
09:36:16 <ray> O(0)
09:36:18 <Varan> what is nothing?
09:36:27 <Varan> :P
09:36:33 <quicksilver> Varan: that's considerably more expensive that just adding two numbers
09:36:39 <dolio> If you parallelize as much as possible, you get stuff like "f i j k l = let x = i + j ; y = k + l in x `par` y `pseq` x + y.
09:36:46 * ski `map's an O(0) operation over ray
09:36:50 <dolio> Which means you're munging stacks to do a single add operation.
09:36:53 <quicksilver> Varan: so it will never be wroth breaking a spark for... dolio's example he just wrote
09:37:02 <quicksilver> Varan: also think about cache effects
09:37:07 <Varan> hmm
09:37:09 <Varan> yes
09:37:15 <quicksilver> the hardware we target has a kind of NUMA, with caches for each execution unit
09:37:29 <quicksilver> you want to spark stuff which will be cache-independent, as far as possible
09:37:45 <Varan> well i have to go
09:37:49 <Varan> thanks for the discussion
09:37:50 <Varan> :)
09:43:07 <atom> this thing is driving me crazy
09:44:13 <atom> 1:.2:.3:.()/4 works, but whenever I do (a :: Vec3) / (b :: Double) it fails spectacularly
09:44:28 <atom> why? WHY?
09:44:39 <copumpkin> :t (/)
09:44:41 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:44:49 <copumpkin> could that be the reason? :P
09:44:59 <conal> :P
09:45:08 <atom> copumpkin: um... don't know. Poing being IT WORKS IN GHCI
09:45:20 <copumpkin> atom: it most certainly shouldn't
09:45:20 <jmcarthur_work> i bet it's not doing what you think it's doing
09:45:36 <atom> jmcarthur_work: probably not, yeah...
09:45:39 <int-e> atom: you don't know what type that 4 has
09:45:42 <jmcarthur_work> atom, is Vec3 an instance of Num?
09:45:50 <atom> probably
09:45:56 <atom> don't really know
09:45:57 <jmcarthur_work> atom, that's why it works
09:46:04 <jmcarthur_work> does 4 :: Vec3 work?
09:46:39 <jmcarthur_work> try forcing that 4 to be a Double in ghci and it won't work
09:46:49 <atom> jmcarthur_work: aaaa
09:46:51 <atom> yeah, it does
09:47:04 <atom> jmcarthur_work: thanks. GHCi automagic gets some getting used to
09:47:13 <jmcarthur_work> it's just type inference
09:47:18 <jmcarthur_work> not magic :)
09:47:34 <atom> jmcarthur_work: yeah, sure, too bad ghc doesn't behave the same way
09:47:45 <conal> any sufficiently advanced type inference is indistinguishable from magic.
09:47:51 <atom> hah
09:48:45 <atom> is there a 'typeof' operator in haskell?
09:48:48 <jmcarthur_work> atom, defaulting plays interestingly with type inference sometimes
09:48:54 <jmcarthur_work> i wish we didn't have defaulting
09:48:59 <conal> atom: yes.
09:49:14 <atom> does it do what I think it does?
09:49:23 <conal> atom: nearly\
09:49:29 <ski> > typeOf (undefined :: Int)
09:49:33 <lambdabot>   Int
09:49:46 <Vanadium> > fix typeOf
09:49:50 <lambdabot>   TypeRep
09:49:52 <ski> @index typeOf
09:49:52 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
09:50:05 <ski> > typeOf typeOf
09:50:09 <lambdabot>   Add a type signature
09:50:15 <ski> :/
09:50:22 <ski> @type typeOf
09:50:24 <lambdabot> forall a. (Typeable a) => a -> TypeRep
09:50:58 <atom> hm...
09:51:49 <ray> weird Num instances and integer literals are a fertile field of obfuscated haskell
09:52:48 <atom> another thing - let's say a type is constant throughout the program, but you wish to keep it very easy to change - how would one go about that?
09:53:35 <Lemmih> atom: Make it an abstract type?
09:53:42 <int-e> a type alias? a newtype?
09:54:04 <atom> Lemmih: alias was the kind of thing I was going for
09:54:09 <atom> I'll look it up, thanks.
09:55:14 <pao> @seen JaffaCake
09:55:15 <lambdabot> Unknown command, try @list
09:55:35 <copumpkin> pao: he's in here
09:55:39 <Saizan_> preflex: seen JaffaCake
09:55:39 <preflex>  JaffaCake was last seen on #ghc 1 hour, 1 minute and 34 seconds ago, saying: I'm assuming that Igloo will deal with the rest of it
09:55:40 <ski>   type SecretAlias = [Int]
09:55:41 * Lemmih feels like he just lost in Jeopardy.
09:55:59 <pao> copumpkin: thanks
10:00:35 <Lemmih> atom: They're also known as type synonyms.
10:01:18 <atom> :q!
10:01:24 <atom> damn :)
10:01:31 <atom> thanks for the help
10:20:40 <etpace> @hoogle replace
10:20:40 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
10:20:40 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
10:20:40 <lambdabot> Data.Array.Diff replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
10:21:05 <etpace> is there a string replace function?
10:21:27 <Veinor> http://bluebones.net/2007/01/replace-in-haskell/
10:22:11 <Veinor> There's Text.Regex if you want to do fancy regexp stuff.
10:22:25 <etpace> cheers
10:28:33 <williamwho> is it more or everyone else that planet.haskell.org is down?
10:29:11 <benmachine> http://www.downforeveryoneorjustme.com/planet.haskell.org this is allegedly supposed to help
10:29:26 <benmachine> it told me planet.haskell.org was down
10:29:34 <williamwho> hehe I know that but can never remember it's name :)
10:33:59 <atom> I'm having further trouble with using the Vec library. I'd like to multiply vectors in vec with scalars. It works in ghci with the help of type inference. I'm guessing that ghci has some way of typecasting the number I put in into a vector of the same shape as the one I'm multiplying it with. How can I figure out which function is used for the purpose?
10:34:46 <quicksilver> turn off the monomorphism restriction
10:34:56 <quicksilver> or give the exact type signature you want.
10:35:09 <atom> quicksilver: um... that's going to be some pragma right?
10:35:11 <quicksilver> ghci doesn't do "more inference" than compiled ghc, but it does turn off the DMR
10:35:25 <atom> DMR?
10:35:37 <ski> {-# NoMonomorphismRestriction #-}
10:35:38 <ski> iirc
10:36:01 <ski> "DMR" means "(the) Dreaded Monomorphism Restriction"
10:36:06 <quicksilver> @go haskellwiki monomorphism restriction
10:36:06 <lambdabot> Maybe you meant: google googleit do
10:36:21 <quicksilver> @gooogle haskellwiki monomorphism restriction
10:36:23 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
10:36:23 <lambdabot> Title: Monomorphism restriction - HaskellWiki
10:36:54 <quicksilver> three os are better than one.
10:36:56 <quicksilver> ski missed out LANGUAGE
10:37:02 <ski> righto
10:37:14 <atom> thanks
10:38:23 <lilac> LANGUAGE nomonomo...
10:44:34 <Zeiris> Looking for documentation on the standard library... Is something like http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer-Lazy.html the best I will get, and am I supposed to figure it out from there? Or are there places where this stuff is better-described.
10:45:04 <Botje> "all about monads" and "monads for the working haskell programmer" are some good resources
10:45:13 <Botje> besides LYAH and YAHT
10:45:33 <HugoDaniel> i really enjoy takusen, the folds are very practical
10:48:11 <atom> I actually don't think it's the monomorphism restriction having read about it
10:48:50 <atom> and I still get the error
10:48:59 <atom> > Vec3
10:49:02 <lambdabot>   Not in scope: data constructor `Vec3'
10:49:16 <atom> > 1:.2:.3:.()
10:49:19 <lambdabot>   Not in scope: data constructor `:.'Not in scope: data constructor `:.'Not i...
10:49:29 <atom> no Vec, I see
10:50:12 <Zeiris> I guess what I want to know is, is the page I linked standard as far as documentation goes, and am I expected to be able to infer the behavior purely from the type signatures? Or is it just a bare-bones reminder, and the actual documentation is in the paper?
10:51:45 <atom> where can I find out more about what pragmas ghci uses by default?
10:51:46 <Twey> Zeiris: The interesting stuff is in the submodules
10:52:15 <Twey> Zeiris: There are actual descriptions of the functions in there (though the type signatures are certainly helpful)
10:52:31 <Twey> The paper will give you a higher-level overview of the strategy if you need it
11:02:56 <atom> (1:.2:.3:.())/2 works because ghci transforms '2' into 2:.2:.2:.(). How can I find out how it does that?
11:03:12 <poe> ?type 2
11:03:13 <jmcarthur_work> it doesn't transform anything
11:03:14 <lambdabot> forall t. (Num t) => t
11:04:02 <jmcarthur_work> atom, numeric literals have an implicit fromInteger applied to them
11:04:11 <atom> how can I then be seeing that the above works and let x = -vector-; let y = 2; x/y throws an error
11:04:15 <jmcarthur_work> and that's how you can use a numeric literal for any Num type
11:04:35 <atom> jmcarthur_work: fromInteger is a class thing right? damn...
11:04:41 <atom> so that's how it does it
11:04:42 <jmcarthur_work> :t fromInteger
11:04:44 <lambdabot> forall a. (Num a) => Integer -> a
11:05:00 <jmcarthur_work> > 1 :: Int
11:05:02 <lambdabot>   1
11:05:05 <jmcarthur_work> > 1 :: Double
11:05:09 <lambdabot>   1.0
11:06:09 <atom> is there a fromDouble?
11:06:24 <jmcarthur_work> what is it you are trying to do?
11:06:37 <jmcarthur_work> atom, could you hpaste it?
11:06:59 <atom> jmcarthur_work: I'll try, but I'm kind of short on time.
11:07:51 <jmcarthur_work> i just want to make sure i understand before i propose a solution
11:09:40 <poe> ?type fromRational -- atom
11:09:41 <lambdabot> forall a. (Fractional a) => Rational -> a
11:09:42 <atom> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9277#a9277
11:10:15 <atom> the ghci session I want to replicate in a normal file
11:10:58 <atom> fromRational doesn't accept doubles
11:12:17 <poe> I suppose you can only write rationals with numeric literals.
11:14:15 <atom> jmcarthur_work: terribly sorry, but I really have to go very soon - could you just try to answer in some way that might bring me closer instead of throwing your 5 minutes away completely?
11:14:30 <atom> I'm sorry it turned out this way, but I have people here waiting for me.
11:17:21 <jmcarthur_work> atom, oh shoot sorry
11:17:56 <jmcarthur_work> atom, i don't see your error
11:17:59 <atom> jmcarthur_work: did you find anything?
11:18:14 <jmcarthur_work> what is going wrong in your file?
11:18:56 <atom> jmcarthur_work: if you'll be here in about two-three hours I'll clarify. Prob is that if I write the same session into a .hs file it chokes on type errors
11:20:05 <atom> I'll update the posting when I come back. thanks anyway
11:20:18 <jmcarthur_work> atom, i think fromRational is used for floating points
11:20:23 <jmcarthur_work> nto fromInteger
11:20:25 <jmcarthur_work> *not
11:20:32 <jmcarthur_work> atom, sorry i took too long
11:22:22 <bob0> > return $ Just 3 >>= (+3)
11:22:23 <ski> > toRational pi
11:22:24 <lambdabot>   No instance for (GHC.Show.Show (m (Data.Maybe.Maybe b)))
11:22:24 <lambdabot>    arising from a ...
11:22:28 <lambdabot>   884279719003555 % 281474976710656
11:23:53 <jmcarthur_work> > fromRational 2.1
11:23:57 <mmorrow> > return . (+3) =<< Just 3
11:23:57 <lambdabot>   2.1
11:24:00 <lambdabot>   Just 6
11:24:09 <mmorrow> > (+3) <$> Just 3
11:24:13 <lambdabot>   Just 6
11:24:14 <mmorrow> > (+3) `fmap` Just 3
11:24:18 <lambdabot>   Just 6
11:24:18 <mmorrow> > (+3) `liftM` Just 3
11:24:22 <lambdabot>   Just 6
11:25:12 <shachaf> > (+3) . Just 6 -- Alas
11:25:16 <lambdabot>   Couldn't match expected type `a -> b'
11:25:19 <jmcarthur_work> > (+3) `liftA` Just 3
11:25:23 <lambdabot>   Just 6
11:25:35 <jmcarthur_work> shachaf, that is not there anymore
11:25:45 <shachaf> jmcarthur_work: Oh, was it ever there?
11:25:51 <jmcarthur_work> yes
11:25:54 <jmcarthur_work> in lambdabot
11:26:02 <shachaf> Huh. Cale's work? :-)
11:26:05 <mmorrow> @pl \f m -> return . f =<< m
11:26:06 <lambdabot> fmap
11:26:06 <jmcarthur_work> yup
11:26:08 <mmorrow> heh
11:26:11 <mmorrow> cheater
11:26:32 <mmorrow> @pl \f m -> ret . f `o` m
11:26:32 <lambdabot> (line 1, column 17):
11:26:33 <lambdabot> unexpected "`"
11:26:33 <lambdabot> expecting variable, "(", ".", space, operator or end of input
11:26:33 <lambdabot> ambiguous use of a left associative operator
11:26:40 <mmorrow> @pl \f m -> o (ret . f) m
11:26:40 <lambdabot> o . (ret .)
11:26:54 <mmorrow> @type (=<<) . (return .)
11:26:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
11:26:57 <shachaf> mmorrow: If someone doesn't implement fmap (or implements it differently from liftM) they deserve far worse than lambdabot does for making that assumption.
11:27:10 <mmorrow> hehe
11:27:39 <aavogt> can you implement fmap in a way that obeys the laws, yet is different than liftM?
11:27:40 <jmcarthur_work> it sucks when you have a polymorphic monad and you want to use fmap
11:28:12 <mmorrow> shachaf: not implementing fmap, but making a Monad instance is teh ultimate sin
11:28:30 * lpsmith wonders if "toRational pi" is among the convergents of the simple continued fraction of pi.
11:28:53 <dm`> What's the best way to serialize simple data structures that derive data?  Scrap your boilerplate seems to have done all the hard work, but I can't fine a package that actually does binary serialization.  genericserialize does S-expressions.  I see references to AltBinary, but it doesn't seem to bein hackage.
11:29:03 <mmorrow> aavogt: i'm not sure
11:29:29 <jmcarthur_work> aavogt, i think the monad laws require fmap == liftM
11:29:29 <jmcarthur_work> indeirectly
11:29:29 <jmcarthur_work> (indirectly
11:29:29 <jmcarthur_work> ugh
11:29:30 <jmcarthur_work> s/(/*/
11:29:38 <jmcarthur_work> i hate (Functor m, Monad m) => m a
11:29:39 <ski> aavogt : no. one of the laws is `fmap f ma = ma >>= return . f'
11:29:39 <shachaf> aavogt: Hmm. You can implement <*>/pure (in Applicative) differently, at least.
11:29:42 <jmcarthur_work> dm`, happstack-state does it
11:29:44 <jmcarthur_work> with TH
11:29:59 <ski> (which can also be stated as `fmap = liftM')
11:30:00 <dm`> jmcarthur_work: Thanks, will check that out.
11:30:12 <mmorrow> dm`: hmm, so you're looking to serialize stuff generically, or looking for some lib that'll derive instances of, say, Binary given a *particular* type
11:30:34 <jmcarthur_work> shachaf, different semantics for pure/(<*>) than for return/ap without breaking the laws?
11:30:44 <mmorrow> well, i guess that's the same thing kind of, in the sense that both would be using a class instance to do it
11:30:48 <aavogt> jmcarthur_work: yes, but that doesn't mean that there is only one way to satisfy those laws
11:30:48 <shachaf> jmcarthur_work: As in ZipList.
11:30:55 <dm`> No, I'm going to derive simple types, like containing Int32 and stuff, and I want, for example, to compute a cryptographic signature over them.
11:30:58 <jmcarthur_work> shachaf, there is no monad for ZipList
11:31:03 <mmorrow> dm`: oh, ok
11:31:13 <mmorrow> dm`: you might find type-hash interesting
11:31:14 <jmcarthur_work> not without breaking the laws
11:31:17 <mmorrow> @hackage type-hash
11:31:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-hash
11:31:23 <mmorrow> (or typehash)
11:31:30 <shachaf> jmcarthur_work: Yes, but that function is still implemented differently.
11:31:32 <jmcarthur_work> shachaf, it works for infinite lists only
11:31:39 <jmcarthur_work> shachaf, yeah, but it's a different type
11:31:47 <mmorrow> it does an md5 of the tree built using the Typeable TypeRep
11:31:55 <dm`> morrow:  Okay, but I potentially need to unserialize stuff, too.
11:32:00 <jmcarthur_work> it's not a violation of the monad laws because there is no monad instance for it
11:32:01 <shachaf> jmcarthur_work: You could have a a valid Applicative [] instance and a valid Monad [] instance that behave differently.
11:32:07 <mmorrow> dm`: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/typehash
11:32:13 <jmcarthur_work> shachaf, not without violating laws
11:32:37 <shachaf> Which laws? There's nothing linking Applicative to Monad in Haskell as it is.
11:32:44 <mmorrow> dm`: ah, ok. so you want to embed some description of the serialized data within the serialized data, so you can parse that, then know how to parse the rest (e.g.)?.
11:33:09 <dm`> mmorrow:  No, I'm already going to know what the type is.
11:33:25 <jmcarthur_work> shachaf, i suspect it would violate fmap f x = pure f <*> x
11:33:27 <mmorrow> dm`: in that case, you can just use the derive package to derive Binary instances
11:33:37 <shachaf> jmcarthur_work: Why?
11:33:39 <mmorrow> dm`: there's even a super-convenient command-line tool
11:33:44 <jmcarthur_work> err maybe not
11:34:29 <jmcarthur_work> shachaf, okay, i think you are right, but i think you shouldn't be ;)
11:34:41 <shachaf> jmcarthur_work: On *that* I'll agree with you. :-)
11:34:42 <bob0> > Just 3 >>= (\x -> Just $ x + 3)
11:34:42 <dm`> Derive package?  I'll check that out, but why would I need any kind of command-line tool if my structure is already deriving Data?  Seems like g(un)fold... and friends should be enough.
11:34:46 <lambdabot>   Just 6
11:34:54 <bob0> > Nothing >>= (\x -> Just $ x + 3)
11:34:57 <lambdabot>   Nothing
11:35:33 <aavogt> > x >>= (\y -> Just $ y + 3)
11:35:35 <lambdabot>   Couldn't match expected type `m a'
11:35:36 <mmorrow> dm`: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9278#a9278
11:35:47 <bob0> > x
11:35:51 <lambdabot>   x
11:35:52 <aavogt> > \x -> x >>= (\y -> Just $ y + 3)
11:35:55 <lambdabot>   Overlapping instances for GHC.Show.Show
11:35:55 <mmorrow> dm`: it can make you pimped-out Data and Typeable instances too
11:35:55 <lambdabot>                              (Data....
11:36:07 <mmorrow> dm`: (just add -dData -dTypeable to the flags)
11:36:35 <mmorrow> dm`: -dBinary -dData -dTypeable -dShow -dRead -dOrd -dEq -dArbitrary -dArbitrary2 -d....
11:37:18 <mmorrow> dm`: well, i'm not sure how pimped out they are wrt the generated ones (probably the same?), but i just wanted to say "pimped out" ;)
11:37:26 <aavogt> showsPrec 11?!
11:37:30 <dm`> mmorrow:  Okay, I can see why that would work, but since ghc can already derive Typeable and Data, what's the advantage of using a separate command-line tool?
11:37:50 <mmorrow> dm`: the real advantage is for the instances ghc doesn't do
11:38:14 <hackagebot> data-accessor 0.2.1 - Utilities for accessing and manipulating fields of records (HenningThielemann)
11:38:26 <mmorrow> dm`: (and suppose you want to tweak the Data instance or something, you can use derive to spit out the skeleton for you, then can tweak away)
11:38:32 <aavogt> mmorrow: does it do GADTs, or is that some other tool?
11:39:47 <mmorrow> aavogt: no, unfortunately. i've got the beginning of a pkg that derives stuff for GADTs, but it's pretty limited as of now (although it's useful for sure, if your GADT happens to be of the particular restricted class that it can generate for)
11:39:56 <dm`> Okay, well thanks for the pointers.  I'm going to check out both happstack-state and deriving, and probably between the two will find what I need.  I'm just surprised that S.Y.B. doesn't come with something already.  I understand the point about tweaking, but I actually prefer to tweak in the overall traversal function (SYB-style), than in the actual type-specific code.
11:39:58 <mmorrow> @hackage derive-gadt
11:39:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive-gadt
11:40:48 <mmorrow> dm`: the thing with syb, is that that all happens at runtime, whereas with TH you can generate static code at compile-time (or whenever, before compile-time), and then there's no overhead at runtime
11:41:12 <mmorrow> which is why i personally prefer the TH solutions
11:41:52 <mmorrow> and also, syb stuff (to the extent that it need Typeable), can only work on things that are Typeable
11:42:16 <dm`> Okay, Happstack.Data.Serialize seems to require that I generate an instance of Serialize, which is no good.  I wanted to avoid doing it manually.  So I guess I should check out derive.  What is "TH"?
11:42:32 <mmorrow> dm`: TH is template-haskell
11:42:42 <dm`> Typeable implies Data, though, so I'm okay on that front.
11:42:48 <dm`> Oh, deriving requires the TH extension?
11:43:11 <mmorrow> dm`: hmm, i'm surprised noone's written some code to auto-derive Serialize instances.. (but i'm not very familiar with happstack, maybe they have)
11:43:38 <mmorrow> dm`: you only need the TH extension if you ...
11:43:42 <mmorrow> dm`: so
11:43:54 <mmorrow> there're two ways you can include TH-derived code in your code
11:44:15 <mmorrow> the first being you can generate it ahead of time, prettyprint it, then include it in your code
11:44:29 <mmorrow> the second being you can stick (e.g.) at top-level
11:44:30 <ziman> edwardk, why is the natural transformation there in: hylo :: Functor f => Algebra g b -> (f :~> g) -> Coalgebra f a -> a -> b ? Could it not just be simply embedded in the algebra or coalgebra, or is there a deeper reason for having it separately?
11:44:35 <mmorrow> $(deriveBinary ''MyType)
11:44:50 <mmorrow> and that expands at compile-time to the code for the Binary instance
11:45:02 <mmorrow> (and that code's re-generated every time you compile)
11:45:06 <dm`> I see.  I guess that's not so bad.
11:45:26 <mmorrow> so it's a tradeoff between not having to update the code by hand when you change the data type
11:45:44 <mmorrow> and having to generate it over and over, as well as needing the TH extension in your final code
11:46:06 <edwardk> ziman: i wrote a blog post about it at one point
11:46:07 <edwardk> ziman one sec.
11:46:45 <lpsmith> @def cf (x,y) = if y == 0 then [] else (x `div` y) : cf (y, x `mod` y)
11:46:45 <lambdabot> Maybe you meant: bf do let
11:46:47 <edwardk> it has to do with easily expressing hylo fusion and that it can't be elided from some forms of combinators that are shaped like hylo, like chrono.
11:47:02 <ziman> i see
11:47:17 <edwardk> ziman: http://comonad.com/reader/2008/unnatural-transformations/
11:47:27 <edwardk> but, yes, it can be rolled into either side in terms of hylo,
11:48:08 <dm`> mmorrow: Can you hpaste the original A.hs?
11:48:19 <dm`> Oh, never mind.
11:48:20 <mmorrow> [m@monire ~]$ echo -ne 'module A where\ndata A a = A | B a\n' > A.hs
11:48:21 <mmorrow> heh
11:48:25 <ziman> edwardk, thanks :)
11:48:47 <edwardk> ziman: good question though =)
11:49:00 <mmorrow> dm`: so that "derive" command-line prog parses a module, and derives the instances you tell it with the flags for *every* type defined in that module
11:49:18 <lpsmith> @let cf (x,y) = if y == 0 then [] else (x `div` y) : cf (y, x `mod` y)
11:49:19 <lambdabot>  Defined.
11:49:37 <dm`> mmorrow: Can you control little- vs. big-endian serialization format?
11:49:38 <mmorrow> dm`: (i find it useful to have a scratch module, and paste the datatypes i want to derive stuff for in there just to feed that Scratch.hs to derive)
11:49:48 <lpsmith> > cf (numerator ratpi, denominator ratpi) where ratpi = toRational pi
11:49:52 <lambdabot>   <no location info>: parse error on input `where'
11:50:12 <mmorrow> dm`: you'd need to tweak the instance, since derive just does it that one way
11:50:13 <lpsmith> >  let ratpi = toRational pi in  cf (numerator ratpi, denominator ratpi)
11:50:18 <lambdabot>   [3,7,15,1,292,1,1,1,2,1,3,1,14,3,3,2,1,3,3,7,2,1,1,3,2,42,2]
11:50:22 <dm`> Which way, big or little endian?
11:50:25 <edwardk> ziman: i do welcome an equally powerful version of g_chrono that can do everything that g_chronoEta can do in that post without the natural transformation though.
11:50:29 <edwardk> i just don't think it exists.
11:50:41 <edwardk> i wasn't able to disprove its existence but i 'tried pretty hard' ;)
11:50:49 <ziman> :)
11:51:00 <mmorrow> dm`: derive just uses `get' or `put' always, so which way depends on what particular implem of the Binary instance for whatever type those uses of get/set resolve to
11:51:28 <mmorrow> the default instances of Binary for Int/Word are big-endian i believe
11:51:28 <dm`> @hoogle get
11:51:29 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
11:51:29 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
11:51:29 <lambdabot> Control.Monad.State.Class get :: MonadState s m => m s
11:51:39 <mmorrow> @hoogle Binary
11:51:39 <lambdabot> package binary
11:51:40 <lambdabot> package binary-search
11:51:40 <lambdabot> package binary-strict
11:51:57 <mmorrow> class Binary a where get :: Get a; put :: a -> Put
11:53:14 <mmorrow> dm`: i find that i either don't care about endianness, or i'm writing the instance by hand (or am generating the code myself with TH)
11:54:08 <dm`> But I might need to inter-operate with other code.  In fact, what I need is big endian, so I'm probably okay.
11:54:12 <mmorrow> dm`: since you pretty much don't have any control over what's happening if you just rely on get/put for any random type
11:54:45 <mmorrow> dm`: well, the get/put are consistent across all versions of the binary pkg
11:55:22 <mmorrow> (but if some other language needs to parse it, you probably need to write it by hand, or write the code that generates the Binary instance by hand)
11:55:31 <mmorrow> gotta run, good luck
11:55:37 <dm`> Thanks, mmorrow.
11:55:43 <mmorrow> no problem
12:10:10 <EnglishGent> hello :)
12:10:36 <hackagebot> hack-middleware-clientsession 0.0.1 - Middleware for easily keeping session data in client cookies. (MichaelSnoyman)
12:10:36 <blackh> Hello, EnglishGent!
12:10:55 <EnglishGent> hi blackh :)
12:11:25 <blackh> How's your Haskelling going?  I'm doing lots of Haskell at the moment - working on a game.
12:14:58 <EnglishGent> I'm making good progress I think
12:15:07 <EnglishGent> I've a basic handle on monads & I/O
12:15:18 <EnglishGent> I have installing cabal packages figured out
12:15:41 <EnglishGent> and I've found some cabal packages that should help me with implementing the tool I'm trying to write :)
12:16:21 <EnglishGent> I still havent got HDBC working yet though .. but I think the problem is at the database end
12:16:23 <blackh> Do you have a particular project in mind, or are you just getting on getting a working knowledge for now?
12:16:47 <EnglishGent> I have a project in mind
12:16:56 <blackh> I can't help you much because I prefer non-SQL databases.
12:17:27 <EnglishGent> well my database of choice is Postgres - but Real World Haskell (one of the texts I'm using) does all the examples with sqlite
12:17:32 <EnglishGent> which I dont really know
12:17:41 <jmcarthur_work> EnglishGent, have you checked out takusen?
12:17:59 <EnglishGent> not even heard of it jmcarthur_work! linky? :)
12:18:10 <konr> Hi there! I'm studying Software Engineering this semester, using bread-and-butter Java and OO. Overall, all the material seems to be tied to this paradigm, and I wonder if there is a way out. How can FP can fit in the world of medium/large-scale commercial software development? Can you recommend me some books/resources on the subject?
12:18:19 <jmcarthur_work> ?hackage takusen
12:18:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/takusen
12:18:21 <jmcarthur_work> ...
12:18:34 <jmcarthur_work> there it is
12:18:44 <dino-> EnglishGent: I'm doing first stuff with hdbc-sqlite for the past day or so. It has been pretty amazingly simple to get started with. But sqlite is kind of like that. No security, no users, no permissions.
12:19:14 <jmcarthur_work> konr, http://haskell.org/haskellwiki/Haskell_in_industry
12:19:28 <jmcarthur_work> konr, and http://industry.haskell.org/
12:19:30 <EnglishGent> ty jmcarthur_work :)
12:19:48 <jmcarthur_work> EnglishGent, oh of course the link wouldn't work!
12:20:05 <jmcarthur_work> EnglishGent, http://hackage.haskell.org/package/Takusen
12:20:07 <jmcarthur_work> that works
12:20:16 <EnglishGent> ty :)
12:21:03 <jmcarthur_work> EnglishGent, it may not be the easiest for a beginner, but i rather like it
12:21:16 <blackh> konr: FP will be great in commercial software development, but it's still catching on.  I don't expect it to be fast, but I think it'll happen, because the advantages are quite sufficient to justify it.  It's only a matter of time before people realize they can make more money.
12:23:03 <EnglishGent> well I'm just trying to get connectivity working first
12:23:09 <jmcarthur_work> i think there will be no such realization. programmers will just start doing it because they like it and managers will start going for it because more programmers know it and promote it
12:23:17 <EnglishGent> but I'm happy to look at more advanced things afterwards :)
12:23:49 <Twey> It's been still-catching-on for fifty years :þ
12:24:04 <blackh> jmcarthur_work: You could be right - but I've worked with a lot of small companies. Perhaps their perspective will be different.
12:24:12 <roconnor> Twey: we only got types 40 years ago
12:24:25 <Twey> Still, larger-scale software development is more popular now than it was then
12:24:35 <Twey> roconnor: blackh said FP, not typed FP
12:25:18 <roconnor> oh.  I think the types are important.
12:25:25 <FunctorSalad> but will it eventually catch on in spite of having been catching on for fourty years?
12:25:32 <FunctorSalad> *fifty
12:25:53 <jmcarthur_work> EnglishGent, i think the connectivity should be no harder with any of the db adapters than for any other
12:25:59 <blackh> New technologies can get nowhere for ages then suddenly explode. Kaboooom!!
12:26:04 <FunctorSalad> bam!
12:26:22 <roconnor> @yow
12:26:22 <lambdabot> Wait ... is this a FUN THING or the END of LIFE in Petticoat Junction??
12:26:24 <blackh> There are indications that Haskell might, but only indications. :)
12:28:10 <jmcarthur_work> there is still some irrational barrier between anything perceived as "academic" and the "real world" that seems to prevent haskell from gaining traction
12:28:20 <jmcarthur_work> and tons of myths about it
12:28:39 <orbitz> jmcarthur_work: did you know Haskell, the language, murders children on jewish holidays?
12:29:04 <jmcarthur_work> orbitz, i've heard that! we definitely shouldn't touch that academic crap
12:29:12 <jmcarthur_work> can't be useful
12:29:18 <EnglishGent> I'd hope not jmcarthur - but using the database from the examples seems easiest
12:29:39 * orbitz is writing soem cellular automota visualzation stuf fin ahskell
12:29:39 <c_wraith> I'd be happy if the standard library had more consistency about error handling.  In fact, error handling seems to be where haskell is weakest.
12:29:48 <orbitz> first thign i've done that ismore than just ickign around in GHCI
12:30:14 <EnglishGent> I'd hope not jmcarthur - but using the database from the examples seems the easiest to get started
12:30:17 <jmcarthur_work> error handling is pretty weak in every language
12:30:26 <blackh> I think error handling is fine - Maybe or Either for pure stuff, and Control.Exception for I/O.  That works fine
12:30:40 <orbitz> haskell's stdlib being a clusterfuck does seem liek a legitimate concern from what i've been seeing
12:30:47 <jmcarthur_work> yeah i've not really run into any error handling problems, myself
12:30:49 <FunctorSalad> ^^
12:30:50 <c_wraith> The problem is there is a lot of pure code in the standard library that uses Control.Exception
12:30:57 <c_wraith> like....  read
12:31:10 <FunctorSalad> orbitz: what specifically?
12:31:26 <jmcarthur_work> i think haskell's biggest flaw is the large number of unnecessarily partial functions
12:31:28 <blackh> c_wraith: Well, yes, I agree. I would actually fix that stuff if it were up to me.
12:31:33 <orbitz> FunctorSalad: like the 'catch' that you on't want generally (accordign to RWH) is the one in Prelude
12:32:13 <jmcarthur_work> i get that a completely total language might be steering things to an area that's possibly too experimental, but do we really need to expose so *many* partial functions?
12:32:15 <blackh> I think Haskell isn't the perfect language, but it is the best language.
12:32:26 <FunctorSalad> orbitz: yeah there are some details; it seemed like you were saying it's altogether FUBAR ;)
12:32:45 <copumpkin> blackh: I think the language is fine, but the standard libraries have their shortcomings
12:32:45 <FunctorSalad> altogether it's not bad
12:32:53 <orbitz> blackh: that's a good point, many people seem to get into this argument of battling over feature X sucks without takign into account everything as a whole
12:32:54 <jmcarthur_work> agreed on that standard libraries
12:33:05 <copumpkin> the typeclasses, all the partial functions, and so on
12:33:10 <copumpkin> could all do with some goodness :)
12:33:14 <blackh> The moment something better comes long, I'm outta here, mate!
12:33:25 <orbitz> blackh: Java 7?
12:33:32 <jmcarthur_work> he said better
12:33:34 <c_wraith> ok..  Haskell''.  Same langauge, new libraries. :)
12:33:53 <orbitz> is Hakell' ever going to happen? i was under the impression it' sbeen draggign it's feet worse than C++1x
12:34:24 <FunctorSalad> orbitz: I think it's been converted to a yearly release scheme
12:34:38 <orbitz> what does that mean?
12:34:49 <FunctorSalad> haskell 2010, haskell 2011, ... ;)
12:34:51 <jmcarthur_work> would anybody be interested in a project to get a fresh start on the libraries? nothing official, just an alternative standard library?
12:35:09 <jmcarthur_work> i've been thinking that such a project would be beneficial
12:35:10 <orbitz> FunctorSalad: will each year be a complete standard or will these be incrimental to something compiler writers can implement?
12:35:24 <jmcarthur_work> at the very least as an exploratory exercise
12:35:37 <orbitz> jmcarthur_work: what about a jump start on Haskell' libraries (if that makes sense I know nothing of Haskell')
12:35:48 <jmcarthur_work> haskell' is a conservative update
12:35:57 <copumpkin> (dammit)
12:36:07 <jmcarthur_work> they don't want to break backward compatibility if they can help it
12:36:14 <orbitz> ugh
12:36:16 <orbitz> f that
12:36:18 <jmcarthur_work> yeah
12:36:27 <orbitz> sometimes you gotta do i tlike a bandaid
12:36:44 <blackh> jmcarthur_work: I think it's a great idea. Someone needs to break a few eggs. It does need to happen some time.
12:36:46 <jmcarthur_work> i think at one time we started a little effort to write another standard that is less conservative, but i haven't heard much about it lately
12:36:53 <orbitz> I don't have any legacy code in haskell though, so my opinion is a bit biased
12:36:57 <jmcarthur_work> this was language-level stuff though
12:37:03 <jmcarthur_work> i really just want to try libraries
12:37:09 <FunctorSalad> orbitz: dunno, here's the website http://hackage.haskell.org/trac/haskell-prime/
12:37:15 <orbitz> thanks FunctorSalad
12:37:18 <jmcarthur_work> i have some, but i would gladly support a cleaner standard library
12:37:38 <jmcarthur_work> well, i'll start a patch-tag project and see if it gets anywhere
12:37:43 <jmcarthur_work> commit rights to anybody who asks
12:37:46 <blackh> There really is no problem with breaking the language.  It just has to be handled properly through switches, extensions, etc.
12:37:58 <blackh> Well, breaking the library.
12:38:03 <orbitz> jmcarthur_work: nooo then we'll just get teh same stdlib again!
12:38:10 <burp> http://paste.railsbox.eu/show/125/ <- does anyone see why "withConn x" goes is (Pool a -> IO c) -> IO c? in my opinion this should be (a -> IO c) as takeConn returns an element of poolFree
12:38:29 <jmcarthur_work> orbitz, i'll try to steer it a bit ;)
12:38:32 <burp> within modifyMVar
12:38:52 <jmcarthur_work> orbitz, we could write up some goals, with an emphasis on not caring about backward compatibility
12:38:54 <blackh> You can just say import Prelude () ; import JcArthursPrelude as Prelude, right?
12:39:10 <tommd> Yes
12:39:26 <orbitz> jmcarthur_work: i don't have the skillset to really help at this point, but I'll gladly commit anythign that meets the stnadard for it as i write
12:40:31 <jmcarthur_work> http://patch-tag.com/repo/alt-stdlib/home
12:40:35 <jmcarthur_work> anybody want in?
12:40:53 <jmcarthur_work> first step is to decide whether to start writing from scratch or to carry over the existing libraries and modify them
12:40:57 <jmcarthur_work> i'm leaning toward the latter
12:42:01 <jmcarthur_work> think i'll write up an email for -cafe tonight with some goals and seeing who's interested
12:42:14 <orbitz> jmcarthur_work: awesome
12:42:50 <orbitz> jmcarthur_work: i hope this gains some traction
12:43:00 <blackh> I will have to be a lurker on your project for now - I can't commit any time.
12:43:00 <jmcarthur_work> i also think a goal should be a focus on elegance and type safety rather than beginner-friendliness
12:43:13 <jmcarthur_work> we made a lot of sacrifices to that end in the existing libraries
12:43:22 <FunctorSalad> I hear "from scratch" is usually worse than it sounds...
12:43:26 <jmcarthur_work> yeah
12:43:29 <FunctorSalad> often runs out of steam
12:43:31 <blackh> What are your plans with regard to the string type?  That could keep you busy.
12:43:35 <jmcarthur_work> i'm leaning toward modifying existing libraries
12:44:04 <blackh> My brother made the good point that String = [Char] is really an optimization problem.
12:44:14 <jmcarthur_work> i'm thinking leave type String = [Char], but make ByteString a bit more of a common occurrence
12:44:33 <jmcarthur_work> but i don't know
12:44:39 <orbitz> blackh: what do you mean?
12:44:48 <FunctorSalad> it kinda asks for abstraction, but I don't know how
12:44:49 <jmcarthur_work> i've heard good arguments that String is a nicer default than ByteString
12:45:05 <jmcarthur_work> we have FromString type class or something like that
12:45:07 <blackh> orbitz: The only reason to choose Text over String (since ByteString is not equivalent to String), is speed...
12:45:10 <jmcarthur_work> but i don't know much about it
12:45:12 <EnglishGent> if your willing to break the language - why not look at things like agda / epigram? i.e. still more powerful type systems
12:45:26 <blackh> ...the only reason why speed is an issue is because someone hasn't come up with a clever-enough optimization strategy.
12:45:29 <FunctorSalad> jmcarthur_work: we have IsString, but it's just for converting String to the type in question
12:45:30 <jmcarthur_work> EnglishGent, i don't want a from scratch approach
12:45:33 <blackh> Are we doing the wrong thing by using Text?
12:45:34 <FunctorSalad> for -XOverloadedStrings
12:45:36 <jmcarthur_work> FunctorSalad, ah
12:45:46 <jmcarthur_work> maybe a new type class would be a good idea
12:45:49 <jmcarthur_work> could be a lot of work though
12:45:56 <jmcarthur_work> i think there is a hackage package for that?
12:46:16 <blackh> So, I'm saying, leaving string the way it is is actually a more far-sighted strategy than replacing it with Text.
12:46:38 <FunctorSalad> some properties of string are already captures by more general classes, e.g. Monoid
12:46:44 <jmcarthur_work> blackh, i think overloading would be a good strategy
12:46:59 <FunctorSalad> it would be Foldable too, except Foldable must be polymorphic in the element type ;)
12:47:10 <jmcarthur_work> FunctorSalad, the monoids package has a good solution for that
12:47:34 <jmcarthur_work> a type family for the element type
12:47:41 <blackh> jmcarthur_work: My request... mappend -> ++
12:48:01 <jmcarthur_work> blackh, i don't know about that one specifically, but i do want a more generic name for mappend at least
12:48:14 <jmcarthur_work> of course, i would rather not bikeshed either ;)
12:49:18 <edwardk> blackh: We lost that battle back during the great monomorphism revolution of 98.
12:49:18 <blackh> Well, I'll leave it up to you.  How about... bikeshed `fusebox` a `fusebox` b ?
12:50:40 <edwardk> blackh: re: text, i tend to prefer bytestrings because more data is represented on disk in utf8 than utf16/ucs2 these days.
12:51:10 <edwardk> blackh: and bytestrings provide an avenue to talk about things like mmapped chunks of files that don't quite make sense in the text world.
12:51:20 <edwardk> (since you could split mid-character)
12:52:07 <jmcarthur_work> i think a good policy is that if there is more than one sensible type for the same operations it would be best polymorphic when possible
12:52:26 <jmcarthur_work> with type classes for the appropriate operations, of course
12:52:37 <maltem> Lol. Patch description in GHC log: "Use colour in 'ghc-pkg list' to indicate broken or hidden packages. Broken packages are read, hidden packages are "
12:52:45 <jmcarthur_work> and many small type classes are nothing to be afraid of
12:52:49 <maltem> s/read/red
12:52:51 <jmcarthur_work> the Num class is horrible
12:52:56 <edwardk> jmcarthur_work: personally, i agree. but there seems to have been a different prevailing common wisdom at the time of haskell 98, mostly due to bad error messages coming out of compilers at the time, so they wanted monomorphic variants of everything lying around.
12:53:15 <jmcarthur_work> edwardk, i'm not going to argue with the decisions of the time. i'm just wanting to learn from them
12:53:22 <edwardk> yeah
12:53:26 <blackh> Tell me why Num is horrible? I've never quite understood that.
12:53:41 <edwardk> it motivated a lot of the class structure i'm using for kata. ;)
12:53:44 <absentia> god I love this lisp vs haskell vs PROLOG thread... :  In fact, half of the Haskell solutions are even slower than the C
12:53:45 <absentia> interpreter interpreting an interpreter
12:53:46 <edwardk> blackh: what, mathematically, is a Num?
12:53:50 <jmcarthur_work> blackh, it captures more things under one roof than it should
12:54:10 <edwardk> blackh: it isn't a ring exactly, because it has abs and signum
12:54:23 <edwardk> blackh: it also encapsulates notions of equality and the ability to Show it.
12:54:33 <jmcarthur_work> it's like a Ring, but it also has weird requirements like Read, and some things that just don't belong to rings
12:54:38 <jmcarthur_work> oh Show, not Read
12:54:45 <blackh> OK - I'm with ya.  Thanks.
12:54:55 <jmcarthur_work> ever try to write a instance of Num for a Vector?
12:55:00 <jmcarthur_work> it's not so great
12:55:03 <edwardk> so that rules out a lot of interesting rings, the Num b => Num (a -> b) option, etc.
12:55:32 <jmcarthur_work> we have a numeric prelude with good ideas, but it follows really weird conventions
12:55:43 <FunctorSalad> *g*
12:56:01 <edwardk> abs and signum don't make sense for otherwise perfectly valid Nums like integers mod a prime. Well, they do, but then abs is meaningless in that it isn't a measure or even a semi-measure.
12:56:15 <maltem> jmcarthur_work, nice to hear that from someone else too :)
12:56:33 <jmcarthur_work> blackh, with an appropriate type class heirarchy, we could even have (+) in place of either (++) or mappend!
12:56:54 <edwardk> jmcarthur: and even then it isn't clear that haskell's type system is appropriate to working with the granularity a numeric prelude would require. you need to anticipate in advance all of the axes on which you will want to divvy up your types.
12:56:59 <jmcarthur_work> although i wonder if maybe (*) would be nicer since sometimes (+) is used for commutative operations only when there is also a (*)
12:57:07 <karlw> Has anyone successfully compiled Yi on Debian/Ubuntu?
12:57:20 <edwardk> if you forgot to include 'principal ideal domains' and you have something that should subclass it already, you're done. witness Functor and Monad.
12:57:23 <jmcarthur_work> edwardk, right, which would be a discouragement from what i was just saying about mappend
12:58:08 <edwardk> jmcarthur_work: not always, sometimes we allow + not to be commutative, seminearrings, etc.
12:58:12 <burp> karlw: with cabal? yes
12:58:27 <karlw> Hmm...
12:58:27 <yphqn> hii
12:58:49 <jmcarthur_work> edwardk, right, just convention in e.g. rings
12:58:51 <edwardk> jmcarthur_work: but then most mathematicians don't work with parsers ;)
12:59:38 <maltem> The interesting design space comes after all generality: After agreeing on names for the most general operators, find good names for specialized operators, like, ring operation > multiplication of numbers
13:00:01 <karlw> Cabal says I don't have the correct version of alex
13:00:58 <edwardk> since i play with so many weak algebraic structures, personally i think the relation of + to * is more given by the flow of the distributive laws you want in your particular ringoid and that +'s unit is cancellative to *. that seems to be a more fundamental distinction. =)
13:01:20 <karlw> ...even though I have alex 2.3.1
13:01:27 <jmcarthur_work> edwardk, ah, that's a good view
13:01:46 <saml> ringoid thanks for the new word to troll on reddit
13:02:02 <edwardk> and you can make a newtype Log/Exp to convert between them anyways. ;)
13:02:08 <blackh> karlw: I just tried and it failed to build ghc-paths, but I expect you knew that!
13:02:18 <jmcarthur_work> edwardk, yeah i do like that convention you use
13:02:57 <jmcarthur_work> so maybe the choice between (+) and (*) for weaker structures can be arbitrary anyway
13:03:24 <blackh> karlw: I think it's my version 1.7.3 of cabal that's broken ghc-paths
13:03:24 <edwardk> in kata i'm currently playing with parameterizing monoid with first class field names for the (+) and 0.
13:03:30 <jmcarthur_work> although i'm afraid of what i would do with a Magma type class (would that even be useful??)
13:03:54 <edwardk> well, it can be.
13:04:10 <jmcarthur_work> i guess a law could be that the operation is closed
13:04:22 <jmcarthur_work> besides _|_ maybe
13:05:28 <jmcarthur_work> but would it even be sensible to do Log/Exp on Magmas?
13:05:33 <jmcarthur_work> i guess so
13:05:47 <edwardk> 'class magma (+) public (+)', 'class semigroup (+) = associative magma (+) ensures a b -> (a + b) + c = a +( b + c)' , and then add monoid, etc.
13:05:58 <jmcarthur_work> yeah
13:06:16 <edwardk> so you can then just have ring inherit from group and monoid with different first class field names and add a distributive law, etc.
13:06:18 <jmcarthur_work> no harm in just doing it
13:06:45 <jmcarthur_work> with my goal of not caring for beginner friendliness, i find this acceptable
13:06:47 <jmcarthur_work> :)
13:06:50 <edwardk> heh
13:08:07 <edwardk> well, with kata i just want the numerical tower to be able to express the full gamut of distinctions. it can still be quite user friendly, because you should be able to just get a flat view of an object/class to see what methods it supports in the editor, etc.
13:08:08 <jmcarthur_work> edwardk, oh, so in kata you specify in the monoid constraint what 0 and + are called?
13:08:27 <jmcarthur_work> that was in response to your earlier remark
13:09:13 <edwardk> jmcarthur_work: currently it doesn't work that way, but i went through and modeled the changes to the core language to allow me to pass field names around as almost first class values.
13:09:25 <edwardk> guess, technically second class, since you can't bind them with lambdas right now.
13:09:31 <CalJohn_> @hoogle FilePath -> [FilePath]
13:09:32 <lambdabot> System.FilePath.Posix splitDirectories :: FilePath -> [FilePath]
13:09:32 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
13:09:32 <lambdabot> System.FilePath.Posix splitPath :: FilePath -> [FilePath]
13:10:45 <edwardk> jmcarthur: monoid is a class with two named field arguments, and you can do multiple inheritance all day long, so inherit from it as many times as you need to express monoids for min/max/(+)/(*), etc.
13:11:06 <jmcarthur_work> oh, i get it
13:11:26 <edwardk> another option is for me to have it also provide an associated category for the monoid as a third named member, so you can have a category for the addition, multiplication, etc.
13:11:33 <jmcarthur_work> kata is sounding like a nice playground
13:11:46 <jmcarthur_work> oh very nice
13:12:17 <jmcarthur_work> the Category, Arrow stuff is another area i'm not sure what to do with in an alternative standard lib
13:12:21 <edwardk> i currently provide that in my short prelude (but it doesn't use the field arguments yet)
13:12:40 <jmcarthur_work> not sure whether i should have categorical functors be the default, for example
13:12:57 <edwardk> mine are categorical, but thats because i don't have types in my way ;)
13:13:05 <jmcarthur_work> on the topic of functors, i'm not sure whether indexed would be a good default or not, either
13:13:15 <ahf> recently there has been two online haskell books published. one being real world haskell, the other being .. what?
13:13:18 * ahf can't remember the name.
13:13:21 <jmcarthur_work> parameterized state monads are so cool though
13:13:27 <edwardk> ahf: learn you a haskell for great good?
13:13:41 <jmcarthur_work> i know there are plans to publich lyah
13:13:43 <ahf> yes, exactly!
13:13:43 <edwardk> jmcarthur: they are cool, but they probably aren't a good default.
13:13:46 <ahf> thanks a lot edwardk :)
13:13:48 <jmcarthur_work> *publish, even
13:14:15 <jmcarthur_work> edwardk, they seem to share something with categories, too, but i can't identify it
13:14:15 <edwardk> i like indexed state, indexed writer, and in particular indexed cont a lot.
13:14:37 <edwardk> well, indexed writer takes a category rather than a monoid ;)
13:14:39 <jmcarthur_work> like the category operations should apply to the index
13:14:53 <jmcarthur_work> yes, that's exactly the relationship
13:15:11 <jmcarthur_work> i think the writer monad is a very good example of what monads are all about
13:15:19 <edwardk> well, you have a unit there, and you probably need associativity to satisfy the monad laws, so it probably forms a category.
13:15:20 <jmcarthur_work> i wish beginner tutorials would focus on it a bit more
13:15:29 <edwardk> oh of course
13:15:37 <edwardk> its just the indexed kleisli category i'm talking about
13:15:47 <jmcarthur_work> aha
13:16:05 <jmcarthur_work> that *sounds* right to me
13:16:37 <Tobsan> Is there a good way to notify a Haskell thread that something interesting has happened?
13:16:44 <jmcarthur_work> hope you don't mind if my stdlib effort draws a lot on category-extras ;)
13:17:01 <edwardk> go for it. i've drawn on it a lot myself for my own current stdlib ;)
13:17:03 <Tobsan> Let's say I have a thread that is extremely interesting in knowing when some state changes, but I don't want to poll the state all the time
13:17:27 <Tobsan> This state might be changed from another thread aswell, and when that happens, I want the first thread to know about it
13:17:34 <Tobsan> Is there a good way to achieve this?
13:17:36 <benmachine> Tobsan: well, there's throwTo, but I don't know if that's really what you want
13:17:43 <jmcarthur_work> Tobsan, but the first thread is doing something else in the meantime?
13:17:47 <edwardk> jmcarthur_work: http://comonad.com/Category.ks-old is an old kata snippet showing a categorical prelude - i really need to post something more current.
13:17:50 <Tobsan> Yes, I looked at that, but it did not seem to be elegant
13:17:57 <Tobsan> jmcarthur_work: yes
13:18:40 <edwardk> a fair bit of syntax has changed since then, most notably, forall f.   id . f = f is now written f ->   id . f = f
13:18:58 <edwardk> since i had overloaded . in just a few too many ways for a nice grammar ;)
13:19:09 <jmcarthur_work> Tobsan, unless it's fine to just kill the thread and start a new one whenever the event happens, you'd probably be best off with some polling solution :\
13:19:14 <jmcarthur_work> i can't think of anything else right now
13:19:39 <Tobsan> Hmmm, alright. Unless I do the throwTo solution
13:19:46 <Tobsan> which in my opinion feels like a hack
13:19:54 <benmachine> it is a bit
13:20:09 <benmachine> but if you want to get something done asynchronously I don't think it can be done cleanly
13:21:20 <edwardk> i try not to throw anything at threads, does haskell have nicer guarantees than say java or c# in this regard? both of those can only kill threads on the way to shutting down the whole process or app domain because they can accidentally leak grabbed locks, etc under certain circumstances.
13:21:35 <edwardk> er s/c#/.net/
13:22:40 <mmorrow> this is interesting:
13:22:44 <mmorrow> @pl  uncurry (flip (const . flip (,) (snd t))) . ap (,) id
13:22:45 <lambdabot> flip (,) (snd t)
13:22:50 <mmorrow> @pl  \t -> uncurry (flip (const . flip (,) (snd t))) . ap (,) id
13:22:50 <lambdabot> (. join (,)) . uncurry . flip . (const .) . flip (,) . snd
13:23:00 <mmorrow> @pl \t -> flip (,) (snd t)
13:23:01 <lambdabot> flip (,) . snd
13:23:16 <mmorrow> if it went for the lambda body first, it'd get the latter..
13:23:29 <jmcarthur_work> huh
13:23:41 <blackh> edwardk: I happen to know that Java's killThread is not safe (unless they've fixed it), but I am fairly sure that Haskell's is - since it's the only way of achieving certain things, I think it's the correct thing to do.
13:24:34 <jmcarthur_work> i don't know if it's safe by itself, but i could foresee it not being safe in the presence of some FFI bindings or something
13:24:48 <edwardk> blackh: i understand fully why the java/.net versions can't be fixed, which is why i'm curious if the work has been done to somehow bulletproof the haskell equivalents.
13:25:06 <blackh> Unfortunately I don't know for sure, but it's something I need to find out.
13:25:22 <edwardk> here we have the fact that you called into the allocator or something to kick off the option for the exception to occur.
13:25:28 <blackh> I'm going to find out.
13:25:41 <edwardk> k
13:25:53 <edwardk> let me know what you find out. I'm curious.
13:26:05 <jmcarthur_work> i'm also curious
13:26:18 <jmcarthur_work> unamb/lub/reactive rely on thread killing
13:27:12 <edwardk> jmcarthur_work: Seeing unamb, was when i first started worrying about it =)
13:28:24 <benmachine> unamb is deeply arcane
13:28:28 <benmachine> iirc
13:29:56 <Tobsan> It would be possible to almost fake the behaviour by doing takeMVar on an empty MVar, that is filled by the "notifying" thread, but then you will not be able to do other stuff in the meantime
13:29:56 <jmcarthur_work> i'm convinced that the semantics are alright, but that doesn't make me unafraid to use it
13:30:10 <jmcarthur_work> Tobsan, tryTakeMVar?
13:30:19 <jmcarthur_work> for polling
13:30:26 <Tobsan> well, yes in that case
13:30:46 <Tobsan> otherwise you would need another thread to takeMVar and then one would just move the problem :P
13:31:02 <blackh> edwardk: killThread is implemented in rts/RaiseAsync.c which I'm reading now. It's called throwTo(...)
13:31:17 <jmcarthur_work> you could have a thread that does stuff and constantly writes its state into an mvar, and another thread that listens on the notifying mvar and when it wakes it also takes the state from the first thread's mvar
13:31:32 <jmcarthur_work> that would pause the first thread
13:32:03 <mmorrow> , [$pl| let a = b; b = a in a |]
13:32:09 <lunabot>  Killed.
13:32:24 <dolio> , [$pl| \x -> x |]
13:32:26 <lunabot>  id
13:32:27 <mmorrow> , [$pl| let a = b; b = a in a |]
13:32:32 <edwardk> was that a pl quasiquoter? eep
13:32:33 <lunabot>  Killed.
13:32:36 <mmorrow> that one must just barely time out
13:32:45 <mmorrow> edwardk: oh yesh
13:32:56 <edwardk> you're a sick, sick man.
13:32:58 <jmcarthur_work> huh
13:33:05 <dolio> , [$pl| \f x y -> f (x, y) |]
13:33:11 <jmcarthur_work> why would you ever want such a thing?!
13:33:11 <lunabot>  Killed.
13:33:17 <mmorrow> edwardk: i'll stick it in a repo somewhere (although it's in lunabot's repo, it's got lunabot-qual modnames etc)
13:33:31 <edwardk> jmcarthur_work: dunno, its @pointless
13:33:45 <mmorrow> , [$pl|uncurry (flip (const . flip (,) (snd t))) . ap (,) id|]
13:33:51 <lunabot>  Killed.
13:33:52 <jmcarthur_work> @pl let a = b; b = a in a
13:33:52 <lambdabot> fst (fix (uncurry (flip (,))))
13:33:53 <mmorrow> sigh
13:33:55 <edwardk> mmorrow has the best toys
13:34:06 <mmorrow> heh
13:34:19 <nyachtung> hello. If monad is a monoid in the category of endofunctors then parameterised monad is a category in something like a category of parameterised endofunctors?
13:34:44 <jmcarthur_work> that sounds strangely relevant to previous conversation
13:35:05 <edwardk> nyachtung: sounds about right
13:35:29 <dolio> Except that I've never heard mention of categorical categories and category objects.
13:36:57 <dolio> Maybe there's some other word used because 'categorical categories' sounds weird.
13:38:05 <markspezzano> Hi, is there any place that I can get solutions to Bird's Introduction to Functional Programming Using Haskell?
13:40:50 <dolio> Maybe I should get around to reading Parameterized Notions of Computation.
13:42:30 <ryant5000> i'm having some trouble using cabal-install with --enable-split-objs
13:42:39 <ryant5000> mtl-1.1.0.2 failed during the building phase. The exception was:
13:42:39 <ryant5000> dist/build/Control/Monad/Cont_split: getDirectoryContents: does not exist (No
13:42:39 <ryant5000> such file or directory)
13:42:53 <ryant5000> where is that directory it's referring to?
13:43:31 <blackh> edwardk: I don't have a categorical answer to your question... (whether killThread / throwTo is safe). However, the RTS works like this...
13:45:00 <FunctorSalad> dolio: it's called "internal category"
13:45:21 <edwardk> going afk for a sec, i'll try to stay online but may drop
13:45:33 <blackh> edwardk: It puts the exception onto a queue associated with the target thread, and it's polled by the scheduler.  This seems like a very safe approach.  I wouldn't expect it to be able to interrupt a long-running FFI call, but I think it is and (due to the lack of asynchronous I/O support generally) has to be the proper way to implement certain things.
13:46:05 <FunctorSalad> http://planetmath.org/encyclopedia/CategoryObject.html
13:47:27 <edwardk> blackh then it probably is safe
13:47:27 <lispy|web> hi
13:47:41 <lispy|web> edwardk: how's it going?
13:47:56 <edwardk> not bad
13:48:56 <markspezzano> Hi, is there any place that I can get solutions to Bird's Introduction to Functional Programming Using Haskell?
13:49:30 <lispy|web> markspezzano: haskell-cafe?
13:49:36 <yphqn> markspezzano: You're starts learning hs ?
13:49:40 <blackh> edwardk: I've written a version of readChan with a timeout using forkIO and killThread.  I was assuming that it was safe.  It'll become apparent pretty quickly if it isn't.
13:49:51 <dolio> FunctorSalad: Ah, nice.
13:50:21 <edwardk> blackh: nah, you'll find those kinds of things only blow up poorly one time in a million or so ;)
13:50:26 <markspezzano> I am looking for a complete documented set of solutions. Does such a document exist?
13:50:31 <mmorrow> edwardk: a cabal'ed darcs repo with haddocks http://moonpatio.com/repos/pl-qq/
13:50:47 <blackh> edwardk: It's in the main event loop of the program.  It'll easily run a million times.
13:51:18 <lispy|web> ?bot
13:51:18 <lambdabot> :)
13:51:20 <yphqn> "Yet another haskall tutorial"
13:51:24 <blackh> edwardk: The code looks like it's been carefully written, and I have faith in the Simons.
13:51:28 <lispy|web> hmm...I guess cale didn't move lambdabot yet
13:51:50 <blackh> I'm not about to audit it, though. :)
13:53:07 <FunctorSalad> turbo haskall!
13:53:11 <FunctorSalad> :(
13:54:31 <edwardk> FunctorSalad: i've wanted a Turbo Haskell compiler for a long time =)
13:56:02 <CalJohn_> Bytestrings literals are quite a pain.  Is there some way to make the "" sugar mean some kind bytestring instead of a string?
13:56:17 <copumpkin> -XOverloadedStrings I think
13:56:24 <lispy|web> edwardk: a turbo gnu ld that doesn't take 1GB of ram to link things GHC compiles would be nice too :)
13:57:37 <lispy|web> CalJohn_: I suppose you could use template haskell to convert String to a ByteString at compile time (not 100% certain that works)
13:58:57 <CalJohn_> http://xrl.in/3374 <- at the end of the page, for anyone interested
13:59:15 <CalJohn_> lispy|web: i haven't looked at TH yet, I don't really understand what it even does
13:59:18 <CalJohn_> i really should
13:59:47 <lispy|web> CalJohn_: it allows some computation during certain stages of compilation
14:08:46 <markspezzano> Is it possible to declare (a,b) as a member of the type class Enum, given that both a and b are instances of Enum?
14:08:56 <copumpkin> sure
14:08:56 <Tony[`]> lispy: ever heard of Golden?
14:09:01 <copumpkin> you'd say an instance though, not a member
14:09:13 <copumpkin> instance (Enum a, Enum b) => Enum (a, b) where ...
14:09:18 <copumpkin> @instances Enum
14:09:20 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:09:55 <markspezzano> thanks
14:10:48 <bcw> hi. i'm trying to install the haskell platform from source on debian lenny (not using repository except for ghc bootstrapping and C libraries).  i'm stuck on installing OpenGL C library, the version in debian's repo doesn't work with ./configure and i can't find any documentation for which version to download from opengl.org.  anybody know how to fix this?  (i don't think i will need opengl, but the platform insists.)
14:10:49 <mmaruseacph2> is there an efficient way to serialize a multi-path tree?:)
14:12:58 <saml> @go multi-path tree
14:12:58 <lambdabot> Maybe you meant: google googleit do
14:13:06 <saml> @google multi-path tree
14:13:08 <lambdabot> http://citeseer.ist.psu.edu/308517.html
14:13:36 <timmcd> Heya people =D
14:13:38 <saml> when first hit of google is academic paper, something's wrong about the topic
14:13:39 <mmaruseacph2> thanks but it was not exactly what i meant to find
14:13:59 <saml> no it was for me to know what is multi-path
14:14:03 <timmcd> Anyone here have any experience with installing HSCurses?
14:14:48 <cdiem> bcw: I think there's a bug: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=466262, maybe this is the one you encountered
14:14:59 <benmachine> presumably I installed it once but I don't remember anything interesting about the process
14:15:06 <timmcd> Huh well
14:15:15 <timmcd> erm, one sec sorry
14:16:47 <timmcd> Prelude> import UI.HSCurses.Curses
14:16:47 <timmcd> Prelude UI.HSCurses.Curses> import qualified UI.HSCurses.CursesHelper as CH
14:16:47 <timmcd> <interactive>:1:0: parse error on input `import'
14:16:47 <timmcd> Prelude UI.HSCurses.Curses>
14:16:59 <saml> on windows?
14:17:02 <timmcd> importing without the qualified works tho.
14:17:05 <timmcd> On Snow Leopard.
14:17:32 <saml> timmcd, can you really do import in ghci?
14:17:38 <timmcd> yeah lol
14:17:39 <saml> i thought it's :m + Some.Module
14:17:52 <saml> hoa it works!
14:18:04 <gwern> note that it's a regular unqualified import
14:18:12 <gwern> we can't do fancier imports in the GHC API yet
14:18:18 <saml> qualified doesn't work in ghci
14:18:28 <benmachine> yeah if you want that then make a file with the imports in it and ghci the file
14:18:38 <saml> wait can we do data A a = A a  in ghci? me tries
14:18:49 <gwern> no
14:18:58 <gwern> just functions and variables, sry
14:19:09 <saml> wow
14:19:19 <saml> > f 1 = 1
14:19:24 <lambdabot>   <no location info>: parse error on input `='
14:19:59 <bcw> cdiem, i'm not actually building debian source packages, i'm just trying to build the haskell platform from the original haskell.org sources for myself.  the problem i'm having is with the ./configure script in haskell-platform-2009.2.0.2.tar.gz.  it wants the glEnd function, which seems to be missing in debian's version.
14:20:26 <gwern> saml: in ghci, think 'let f 1 = 1', iirc
14:20:43 <saml> gwern, coolz
14:21:13 <Badger> > let f 1 = 1
14:21:17 <lambdabot>   not an expression: `let f 1 = 1'
14:21:38 <gwern> Badger: mueval != ghci
14:21:41 <gwern> @let f 1 = 1
14:21:43 <Badger> :(
14:21:43 <lambdabot>  Defined.
14:21:45 <gwern> > f 1
14:21:49 <lambdabot>   Ambiguous occurrence `f'
14:21:49 <lambdabot>  It could refer to either `L.f', defined at <local...
14:21:58 <Badger> > L.f 1
14:22:03 <lambdabot>   1
14:22:06 <benmachine> @help unlet
14:22:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:22:09 <benmachine> :(
14:22:39 <benmachine> okay that's weird
14:22:47 <benmachine> I did mueval --help and got the help output twice
14:23:09 <cdiem> bcw: I have never tried building it myself; there are some clues regarding which packages may be needed for kubuntu on this link: http://tuukka.iki.fi/tmp/haskell-2009-06-06.html, though I don't know whether it will be useful. Maybe someone else, who had built it, will be able to help you better.
14:25:01 <iago> Someone could help me with generics? I'm using Uniplate...  in this code http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3560 (problem commented) I would like that "para" uses "collect" over any child with a type with a declared instance of FreeVars... so I could remove some cases
14:25:35 <gwern> benmachine: is that a problem?
14:25:46 <benmachine> gwern: weird, that's all
14:26:16 <gwern> probaly something to do with getopt handling errors
14:26:27 <gwern> it's not very pleasant to use so I cargoculted a lot of it
14:29:54 <zoheb> I am looking for a compact way of writing this fn,     cd str == if (length str >= 2) && (take 2 str) == "\\\\" then tail str else str
14:30:11 <zoheb> I want to skip checking for the length of str
14:30:24 <zoheb> Is there a MayBe version of fns like take
14:30:43 <zoheb> Ouch my bad
14:30:43 <bcw> cdiem, thanks. looks like there's a hack that might work ... if worst comes to worst, i might try it.  but if anyone knows what version of opengl haskell requires, i'd prefer to install that from source.
14:30:49 <benmachine> zoheb: just take will work fine
14:30:53 <benmachine> > take 2 "x"
14:30:56 <zoheb> the length test is not reqd
14:30:57 <lambdabot>   "x"
14:31:04 <zoheb> just realized that
14:31:06 <zoheb> sorry
14:31:23 <benmachine> zoheb: although if you're tailing it then you want to make sure it's not empty
14:31:46 <zoheb> if take 2 str == "\\\\" then
14:31:51 <zoheb> it must have a tail
14:31:55 <benmachine> true
14:32:02 <benmachine> you could define it in two cases
14:32:17 <edwardk> zoheb: cd '\\':ts@('\\':_) = ts; cd ts = ts
14:32:28 <benmachine> yeah like that.
14:32:30 <edwardk> er you need parens around the argument there
14:32:33 <zoheb> Is there some way we can wrap the result of fail-able fns like head in a MayBe
14:32:46 <edwardk> cd ('\\':ts@('\\':_)) = ts; cd ts = ts
14:33:15 <edwardk> cd ts | "\\\\" == take 2 ts = tail ts | otherwise = ts -- doesn't suck either.
14:33:52 <bcw> ah, wait.  now i see from hackage that it uses "(GL, version 2.1)"
14:33:55 <zoheb> edwardk, I am unfamiliar with the last syntax
14:34:03 <zoheb> but its good to know
14:34:08 <bcw> and GLU version 1.3
14:34:16 <edwardk> foo bar | condition = ... -- is guard syntax.
14:34:25 <edwardk> you can then add more | condition = ... cases
14:34:41 <edwardk> > otherwise
14:34:45 <lambdabot>   True
14:34:56 <edwardk> otherwise is just True, so its condition always succeeds.
14:34:57 <zoheb> thanks edK
14:36:02 <zoheb> Going Back, Is there some way we can wrap the result of fail-able fns like head in a MayBe, Maybe something like catch is what I am looking for
14:36:18 <bcw> sorry for not spotting the obvious, all.  and thanks for the help, cdiem.
14:36:34 <zoheb> for use in one-liners :)
14:36:52 <zoheb> Guards are hard to use in one-liners
14:37:31 <mmorrow> zoheb: if it gets to the point where it fails, it's too late, so you need to make sure it doesn't fail
14:38:02 <zoheb> :-/
14:38:11 <mmorrow> so there's no way to wrap an arbitrary function to catch failure without checking the invariant it expects before you give the function its arg
14:38:25 <benmachine> zoheb: in the specific case of head, there's listToMaybe
14:38:33 <mmorrow> (that is, if the function is assuming an invariant)
14:38:39 <benmachine> :t listToMaybe
14:38:41 <lambdabot> forall a. [a] -> Maybe a
14:39:04 <benmachine> I guess last would be like listToMaybe . reverse
14:39:05 <mmorrow> @type listToMaybe . take 1
14:39:07 <lambdabot> forall a. [a] -> Maybe a
14:39:21 <benmachine> mmorrow: um, what's the point of that? :P
14:39:29 <benmachine> > listToMaybe [2,3,4,5,6]
14:39:32 <lambdabot>   Just 2
14:39:34 <mmorrow> > fmap (listToMaybe . take 1) [[0..4],[]]
14:39:38 <lambdabot>   [Just 0,Nothing]
14:39:49 <mmorrow> it's the function zoheb was looking for
14:39:52 <benmachine> the take 1 is redundant
14:39:59 <mmorrow> benmachine: haha, true
14:40:57 <mmorrow> @let list n _ [] = n; list _ c (x:xs) = c x xs
14:40:59 <lambdabot>  Defined.
14:41:23 <zoheb> thanks for all the help
14:41:42 <mmorrow> @type list Nothing (\x _ -> Just x)
14:41:49 <lambdabot> forall t1. [t1] -> Maybe t1
14:42:02 <mmorrow> @type maybe [] (:[])
14:42:04 <lambdabot> forall a. Maybe a -> [a]
14:42:15 <mmorrow> @type maybe mzero return
14:42:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
14:42:48 <mmorrow> @type maybe False (const True)
14:42:50 <lambdabot> forall a. Maybe a -> Bool
14:43:15 <mmorrow> maybe/either-like functions are handy too
14:44:04 <bcw> oops.  for the record, it looks like i just needed the non-free development files, since i use nvidia-glx.  the nvidia-glx-dev package fixed my problem.
14:44:43 <mmorrow> data A a = A | B a | C a (A a); foldA f _ _ A = f; foldA _ g _ (B a) = g a; foldA _ _ h (C a o) = h a o
14:45:48 <Philonous> Argh, Show and Eq requirements for Num bite me once again -.-
14:46:13 <edwardk> just make er.. felonious ones
14:46:27 <edwardk> Philonous: (a -> b) ?
14:46:56 <jmcarthur_work> yeah, that is definitely one of the first things to go in alt-stdlib
14:47:20 <mmorrow> @type fix (\k f z -> list z (\x xs -> k f (f z x) xs))
14:47:22 <lambdabot> forall t t1. (t -> t1 -> t) -> t -> [t1] -> t
14:47:38 <mmorrow> @type fix (\k f z -> list z (\x xs -> k (f z x) xs))
14:47:41 <lambdabot>     Occurs check: cannot construct the infinite type:
14:47:41 <lambdabot>       t = t1 -> t11 -> t
14:47:41 <lambdabot>     Probable cause: `f' is applied to too many arguments
14:47:46 <Philonous> edwardk: No, some complex datatype that sometimes gets hidden in an existential variable...
14:47:47 <mmorrow> @type fix (\k f z -> list z (\x xs -> k f (f z x) xs))
14:47:49 <lambdabot> forall t t1. (t -> t1 -> t) -> t -> [t1] -> t
14:48:01 <mmorrow> err
14:48:18 <mmorrow> @type fix (\k f z -> list z (\x xs -> f x (k f z xs)))
14:48:20 <lambdabot> forall t t1. (t1 -> t -> t) -> t -> [t1] -> t
14:53:43 <roconnor> is there a counter monad on hackage that counts the number of bind operations?
14:54:52 <jmcarthur_work> i bet you could wrap Writer to do it
14:55:09 <roconnor> ya, easier to write my own from scratch
14:55:37 <burp> http://paste.railsbox.eu/show/HymstSFQWGWxylE2uEgQ/ <- hm, how can I transform this to accept a function e (key -> block -> IO block), and so cbc return IO [block]
14:55:50 <burp> instead of the pure non-IO one
14:56:05 * roconnor wonders if my counter monad satifies the monad laws
14:56:09 <burp> is it doable without big modification?
14:56:18 <burp> kind of changing map to mapM
14:56:34 <burp> but then the problem arises because feedIns refers to ciphers
14:56:36 <jmcarthur_work> i think it would
14:56:43 <jmcarthur_work> oh, no
14:57:05 <jmcarthur_work> roconnor, what does runCounter . return do?
14:57:13 <jmcarthur_work> 0 or 1?
14:57:14 <roconnor> 0
14:57:47 <jmcarthur_work> if a gives 1, what does return <=< a do?
14:57:58 <jmcarthur_work> err
14:58:00 <jmcarthur_work> return =<< a
14:58:09 <Philippa> the same
14:58:11 <roconnor> that would give 2 :(
14:58:16 <roconnor> stupid monad laws
14:58:29 <Philippa> ...that'll teach me not to jump in
14:58:30 <Philippa> and yeah
15:00:38 <zenzike> dcoutts: I'm messing around with haskeline, but having troubles with types, since I'm using an IO monad inside an InputT monad that haskeline provides, (see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9287#a9287) I'm a little stuck on where to go with line 65, using a return doesn't seem right. any suggestions?
15:01:37 <Philonous> Having an existential type data Foo = forall a . (Show a) => Foo a, is show $ Foo "bar" more expensive than show "bar" ?
15:01:55 <jmcarthur_work> roconnor, your "monad" is associative but has no identity. if you didn't have to define return it would probably be okay
15:02:12 <dcoutts> zenzike: so is the issue that you need to run an IO action, but you're in the InputT IO a monad?
15:02:22 <jmcarthur_work> a semimonad? not sure if that's what that would be called
15:02:35 <zenzike> dcoutts: yes exactly
15:02:46 <c_wraith> zenzike:  Sounds like a case for lift
15:02:56 <dcoutts> zenzike: I expect that InputT is an instance of MonadTrans so you should be able to liftIO to bring an IO action up into the monad
15:04:21 <zenzike> woo. i've never used a liftIO before. That's a wierd type signature!
15:04:43 <zenzike> it gobbles something from IO and magically produces the right kind of wrapping :)
15:04:59 <c_wraith> @src MonadIO
15:05:00 <lambdabot> Source not found. Sorry.
15:05:10 <Philippa> Philonous: potentially - it removes static knowledge the compiler can use to optimise
15:05:18 <zenzike> it's in Control.Monad.Trans
15:06:05 <c_wraith> Oh, I know where liftIO comes from.  I was just trying to point out it's defined by the MonadIO typeclass, which kind of removes all the magic. :)
15:06:10 <Tony[`]> @src Control.Monad.Trans.MonadIO
15:06:11 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:06:15 <Philonous> Philippa: But not inherently? I.e. I doesn't get an automatic malus for carrying around the instance dictionary?
15:06:23 <zenzike> ah, thanks :)
15:08:36 <zenzike> oh, so ghc has found the module in multiple packages (Control.Monad.Trans is in both transformers and mtl), how do i tell it to resolve?
15:09:35 <benmachine> zenzike: you can do it per-compile or globally
15:09:44 <benmachine> in the first case with umm some option that I forget
15:09:49 <benmachine> -hide-package or something
15:09:56 <benmachine> in the latter case with ghc-pkg hide <name>
15:10:23 <zenzike> thanks. do you happen to know which of those two libraries is considered "better"?
15:12:01 <benmachine> mtl is what I use
15:12:06 <benmachine> couldn't comment on transformers
15:12:17 <benmachine> I think mtl is more common
15:12:40 <zenzike> cheers, I'll give it a shot
15:12:55 <zenzike> it's nice to have such a wonderfully irc community
15:13:04 <zenzike> *wonderfully helpful
15:13:22 <jmcarthur_work> mtl is basically the only one in wide use
15:13:33 <jmcarthur_work> the others, better though they may be, are much more uncommon
15:14:50 <roconnor> @djinn (Monad m) => a -> m a
15:14:50 <lambdabot> Error: Class not found: Monad
15:15:10 <roconnor> can we add classes to djinn?
15:15:28 <dolio> It has them already.
15:15:40 <dolio> Or do you mean define new classes.
15:15:46 <dolio> Monad isn't one that'd be useful, incidentally.
15:15:56 <roconnor> why not?
15:16:36 <dolio> Because the way classes are implemented is that the methods are essentially tacked on before the rest of the type.
15:16:55 <roconnor> but the methods are polymorphic
15:17:08 <roconnor> oh
15:17:12 <roconnor> so djinn won't work?
15:17:15 <dolio> So "Monad m => b -> m b" gives you, "(a -> m a) -> b -> m b"
15:17:26 <dolio> Which doesn't work, because a /= b.
15:17:29 <roconnor> right
15:17:44 <roconnor> understood.
15:18:16 <dolio> You add them same way as anything else, though. "@djinn-add class Foo a where ..." I think.
15:20:22 <dolio> @djinn-add class Classical a where lem :: Either a (Not a)
15:20:42 <dolio> @djinn (Classical a) => ((a -> b) -> a) -> a
15:20:42 <lambdabot> f a =
15:20:42 <lambdabot>     case lem of
15:20:42 <lambdabot>     Left b -> b
15:20:42 <lambdabot>     Right c -> a (\ d -> void (c d))
15:21:20 <Philippa> assuming I'm going to run it in a VM and don't mind the editor etc being on the host platform, what's reckoned to be a good/the preferred platform to hack GHC on these days?
15:21:20 * Philonous just noticed how Monad m, Num a (Float a, Fractional a) automagically gives you Num (m a) (Float (m a), Fractional (m a))
15:22:24 <sjanssen> is there a library in Haskell for creating temporary directories?
15:22:56 <jmcarthur_work> so i'm looking at how to go about the alt-stdlib idea. it would be nice if it could be just a normal package. can i do that somehow without having base as a dependency? that is, can i build base or a derivative of base outside of the GHC source tree, somehow?
15:23:14 <Makoryu> sjanssen: That's OS-dependent, isn't it?
15:23:48 <sjanssen> Makoryu: yeah, that's why a library for it would be nice
15:24:09 <jmcarthur_work> simply downloading the base tarball and naively building with cabal fails because it looks for files which are presumably added by the GHC build environment
15:24:22 <sjanssen> from what I've heard, a proper implementation is rather tricky
15:24:25 <jmcarthur_work> i expected that
15:25:28 <Draconx> sjanssen, it's not very hard on posix-ey systems.
15:26:50 <sjanssen> Draconx: posix is fine for me (considering using this for xmonad)
15:28:36 <Draconx> sjanssen, well, the procedure goes like this: generate candidate pathname, attempt mkdir.  If mkdir fails with EEXIST, generate a new pathname and try again.
15:31:43 <jmcarthur_work> i suppose an alternative could be to depend on base
15:32:02 <gjl> What do you guys think of Haskell as an introductory programming language?
15:32:14 <sjanssen> hmm, just found the manpage for mkdtemp, perhaps an FFI binding to that is in order
15:32:33 <dcoutts> gjl: it's a fine introductory language
15:32:48 <dcoutts> gjl: what age group?
15:33:11 <Axman6> gjl: i think it makes an excellent first language
15:33:11 <gjl> undergrad
15:33:20 <jmcarthur_work> but (1) that seems lame, (2) that would require changing the namespace for every module in alt-stdlib, and (3) it would require more of a "rewrite" than a transition
15:33:22 <dcoutts> gjl: oh definitely then
15:33:31 <Axman6> it was our undergrad introductary language after all :)
15:33:43 <dcoutts> gjl: take a look at Graham Hutton's excellent "Programming in Haskell"
15:33:49 <dcoutts> (book)
15:33:50 <jmcarthur_work> and the only other alternative i can think of is to actually work in the GHC tree, which would practically be a fork, which i don't want to do
15:34:24 <dcoutts> gjl: as Axman6 says, there are several universities that use Haskell as an intro undergrad language
15:34:51 <Axman6> that's how they get you hooked
15:34:54 <jmcarthur_work> gjl, i think haskell would be an excellent beginner's language unless these beginners already think they know programming
15:35:01 <Axman6> it's all up hill from there
15:35:13 <gjl> About the only thing I might be concerned about is that it isn't as mainstream as say C so I'm thinking maybe the literature isn't as well developed for it.
15:35:36 <jmcarthur_work> gjl, that would be a correct guess, but i think there is enough out there
15:35:56 <Axman6> so, is something wrong if i can write a quicksort that appears to be faster than the Data.List sort function? (probably far less lazy
15:36:12 <dcoutts> gjl: Hutton's book is specially designed for beginner undergads
15:36:15 <Axman6> all the tests i've done seem to imply it's faster
15:36:29 <c_wraith> well, see what happens if you compare head of it vs head of the Data.List.sort
15:36:31 <sjanssen> Axman6: on what sort of data?  Are you using separate compilation?
15:36:36 <dcoutts> gjl: I've got a book review for it if you're interested
15:36:44 <Axman6> randoms ints..
15:36:44 <gjl> Please
15:36:46 <monadic_kid> http://github.com/snkkid/LazyFooHaskell/tree/master
15:36:50 <sjanssen> Axman6: how badly does it blow up on [1 ..]?
15:36:50 <Axman6> i haven't tested extensively
15:36:55 <jmcarthur_work> Axman6, what if you sort an already sorted list?
15:37:01 <sjanssen> [1 .. n] -- I mean
15:37:02 <Axman6> i would suspect wuite badly :P
15:37:10 <dcoutts> gjl: http://www.cs.nott.ac.uk/~gmh/book-review.pdf
15:37:13 <Axman6> q*
15:37:18 <gjl> Thanks
15:37:30 <sjanssen> Axman6: is the sort defined in a separate module from the test?
15:37:42 <Axman6> no...
15:37:56 <sjanssen> Axman6: this can make a significant difference
15:38:07 <jmcarthur_work> until we have whole program optimization ;)
15:38:12 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9288#a9288 there's the code, i have to be going now. let me know what you think though
15:38:14 <jmcarthur_work> no plans that i know of though
15:38:26 <c_wraith> isn't that projected to be "never", for ghc?
15:38:37 <jmcarthur_work> JHC does it. does LHC retain that from JHC?
15:38:55 <jmcarthur_work> c_wraith, probably never, right
15:40:19 <b4taylor> So I'm trying to use Network.HTTP to "bounce" an http request. Make my program look like it's recieving a request for a file and serving up the file but in reality is downloading it from another site and just streaming what it can get to the client.
15:40:29 <b4taylor> I'm stuck on the streaming part :p
15:41:10 <Philonous> Why does GHC say "could not deduce (Functor n) from the context [...] (Monad n)" ?
15:41:11 <b4taylor> Or maybe not. I was just dumping the contents to the terminal so maybe some magic buffering was going on. But I don't believe that is the case.
15:41:26 <b4taylor> If I print the first 100 bytes of my ByteStream it waits for the entire download to finish.
15:41:34 <jmcarthur_work> Philonous, because Functor is not a superclass of Monad :(
15:42:07 <kolmodin> Igloo: code.haskell.org seems to not be responding
15:42:41 <b4taylor> Oh wait, Network.HTTP supports lazy ByteString. Hmmm.
15:42:45 <Philonous> jmcarthur_work: Oh. That's... odd.
15:42:52 <jmcarthur_work> it's a flaw in the libraries
15:43:07 <jmcarthur_work> another thing i wish to correct in alt-stdlib
15:43:29 <Philonous> jmcarthur_work: I should loose the habit of thinking about stuff in the standard library and start just looking up everything.
15:43:55 <burp> http://paste.railsbox.eu/show/uyYVPy7fUKuQR5yssHG7/ <- why doesn't the cbc function have the type signature I expect it to have?
15:45:38 <burp> oh
15:45:41 <burp> `xor`
15:46:05 <burp> well that doesn't fix it
15:46:19 <burp> um it does
15:46:23 <burp> never mind ;)
15:46:57 <sjanssen> burp: "encs ++ [crypted]
15:47:07 <sjanssen> burp: that line is pretty inefficient
15:47:18 <burp> what do you suggest instead?
15:47:27 <chidimuorah> hi all
15:47:53 <chidimuorah> anyone has any pointers on how to use haskell for iphone dev?
15:48:15 <burp> I could prepend it, and reverse it after the fold
15:48:53 <sjanssen> burp: some sort of mapM?
15:48:59 <blackh> chidimuorah: What do you want to know?
15:49:01 <b4taylor> Ahha!
15:49:10 <sjanssen> the IO type makes this a bit inconvenient
15:49:11 <chidimuorah> how do I start?
15:49:28 <burp> sjanssen: sadly yes, but IO is necessary
15:49:34 <b4taylor> Nevermind all, "import Data.ByteString as BS" becomes "import Data.ByteString.Lazy as BS"
15:50:07 <blackh> chidimuorah: Download the binary compiler for MacOSX from http://projects.haskell.org/ghc-iphone/ and try out the examples.
15:50:08 <burp> sjanssen: http://paste.railsbox.eu/show/HymstSFQWGWxylE2uEgQ/ this is the non-io version I "ported"
15:50:52 <blackh> chidimuorah: Ask questions in #haskell-iphone
15:50:58 <b4taylor> Ah crap, I'm wrong. Should have tried a bigger file :p
15:51:09 <b4taylor> Definately still don't know how to stream the data.
15:51:11 <chidimuorah> thank you
15:51:20 <sjanssen> burp: do you want iv in the output of the function?
15:51:34 <jmcarthur_work> b4taylor, lazy bytestrings work on somewhat cache-sized chunks
15:51:47 <b4taylor> jmcarthur_work: Do you know how large that size is?
15:51:51 <burp> sjanssen: no I put liftM (drop 1) $ in front of it now
15:52:05 <jmcarthur_work> b4taylor, no, but i think it's measured in kilobytes?
15:52:08 <jmcarthur_work> i could be wrong
15:52:12 <sjanssen> burp: excellent, that makes things nicer
15:52:28 <b4taylor> Well if it's less that 1MB I should have seen something.
15:52:58 <jmcarthur_work> b4taylor, default is 64k i think
15:53:05 <jmcarthur_work> that's what the docs say
15:53:27 <b4taylor> Hmm.
15:53:37 <gjl> dcoutts: thank you for your review of Programming in Haskell - it's done a good enough job to convince me to obtain a copy :). I note you're still studying in Oxford. Do you think any of the lectures are worth attending for a non-CS undergrad?
15:53:38 <b4taylor> Ah, can test with pv
15:54:13 <b4taylor> hmmm
15:54:17 <dcoutts> gjl: the intro FP course is attended by mathematicians and engineers
15:54:18 <Philippa> gjl: show off early, even if only in brief, examples that can't be done comfortably in more mainstream langs
15:54:23 <b4taylor> pv isn't seeing any data until it's finished downloading all 33MB
15:54:26 <sjanssen> burp: does this compile? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9289#a9289
15:54:34 <Philippa> it helps convince the ones who know it all that there may be something worth learning
15:54:47 <sjanssen> burp: sadly this version will use O(n) stack, which kinda sucks
15:56:24 <dcoutts> gjl: the intro FP course is literally the first thing the students do, so anyone with a vaguely technical/mathematical background (like A-level maths) should be fine
15:56:25 <Philippa> Philonous: if the compiler statically knows which dictionary was being carried about, it can elide much - or all - of the existential
15:56:44 <Philippa> I don't know to what extent GHC actually does this though
15:57:53 <burp> sjanssen: not with the old type signature
15:58:27 <burp> ah I see, you expect [iv] there
15:59:22 <sjanssen> burp: oh, actually I meant "foldr f (const $ return []) plains iv"
15:59:33 <sjanssen> that should fix it
16:00:16 <burp> hm, yup
16:05:33 <burp> tricky ;(
16:06:26 <sjanssen> burp: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9289#a9290 uses some FP folklore to make it O(1) stack (trading for O(n) heap)
16:06:49 <burp> looks horrible ;)
16:07:36 <burp> but thanks
16:07:47 <sjanssen> yeah, not pretty.  There's a DList library that names "($ [])" as toList and (xs . (x :)) as append
16:10:46 <sjanssen> burp: if you have questions about either, feel free to ask
16:11:02 <mauke> :t either
16:11:05 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:11:09 <burp> sjanssen: ok
16:11:22 <sjanssen> @. djinn type either
16:11:22 <Makoryu> :t maybe
16:11:25 <lambdabot> f a b c =
16:11:25 <lambdabot>     case c of
16:11:25 <lambdabot>     Left d -> a d
16:11:25 <lambdabot>     Right e -> b e
16:11:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:11:27 <burp> sjanssen: I think the behaviour is not exactly the same as my code
16:12:13 <burp> at least not dual to my unCbc function
16:12:33 <sjanssen> hmm, I might not have understood the original properly?
16:13:03 <burp> it's probably easy to fix for me, I'll think about it
16:18:42 <roconnor> @pl \f -> runIdentity (p (return . (\x -> f (\y -> x (\z -> y (runIdentity . z))))))
16:18:43 <lambdabot> runIdentity . p . (return .) . (. (. (. (runIdentity .))))
16:22:33 <Gracenotes> hm. what's a nice simple digraph transitive reduction algorithm?
16:23:02 <roconnor> No instance for (Show F) :)
16:23:38 <roconnor>     Can't make a derived instance of `Show F'
16:23:39 <roconnor>       (`F' has no data constructors)
16:23:55 <c_wraith> @src Identity (>>=)
16:23:55 <lambdabot> m >>= k  = k (runIdentity m)
16:24:11 <Gracenotes> I suspect it would be some modification of a strongly connected component-finding algorithm
16:24:19 <roconnor> instance Show F where
16:24:20 <roconnor>   show _ = error "the unpossible just happend!"
16:25:28 <Gracenotes> > Nothing :: Maybe (a -> b)
16:25:33 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
16:25:33 <lambdabot>    arising from a use of `...
16:27:11 <benmachine> > Nothing :: Maybe a
16:27:15 <lambdabot>   Nothing
16:27:21 <benmachine> good old type-defaulting
16:28:00 <Gracenotes> so.. transitive reduction algorithms..
16:28:23 * Gracenotes sees if fgl has any
16:29:36 <Gracenotes> seems it has closure, not reduction..
16:30:07 <c_wraith> isn't transitive reduction just going to work out to be non-branching path reduction?
16:30:08 <Gracenotes> I suppose a common-sense solution would work too -_-
16:30:42 <c_wraith> if indegree = 1 and outdegree = 1, you can absorb that node into one of its neighbors
16:31:43 <Gracenotes> I am not familiar with this terminology..
16:32:07 <c_wraith> I'm not sure I'm thinking of the right problem.
16:33:05 <Gracenotes> I think a depth-first search approach would work, I'm just deathly afraid of cycles :P a list must be maintained then, resulting in a freakish accumulating fold/structural fold combination
16:33:45 <jmcarthur> i'm telling you, man: fgl  :)
16:34:25 <Gracenotes> alas I cannot find such an algorithm there
16:35:02 <jmcarthur> alas, my kneejerk suggestion fails!
16:35:23 <jmcarthur> oh, you even mentioned it above
16:35:25 <jmcarthur> i am fail
16:35:25 <Gracenotes> and I'm working on something different now -- a silly graph visualization app with cairo/gtk2hs. you add nodes by clicking, add directed edges by clicking from node to node, and can remove either
16:36:22 <Gracenotes> the direct edges have cool marching ant lines between them :D thanks to cairo's flexible setDash function
16:37:17 <Gracenotes> transitive reduction seems like a sensible algorithm to try out (besides reversing the directedness of edges, which also looks not-bad visually)
16:37:37 <Gracenotes> no idea why this is fun, it just is :x
16:39:28 <c_wraith> I'm always a fan of generator dominator graphs
16:39:32 <c_wraith> *generating
16:41:43 <jagwire> Dear God there is an irc channel for this...
16:42:44 <bd_> Is that really surprising? :)
16:43:20 <Gracenotes> c_wraith: that's just the directed subgraph from a given node in a DAG, isn't it?
16:43:47 <c_wraith> Oh.  Being acyclic does make it rather boring
16:44:21 * Philonous wonders whether all(1,2) == any(1,2,3,4) is the same as any(1,2,3,4) == all(1,2) in perl 6. But I guess handiness trumps consistency in perl. 
16:44:24 <Gracenotes> oh :X I'd imagine you could apply it to ones with cycles
16:44:49 <Gracenotes> ..how, though..
16:45:17 <jagwire> well bd_
16:45:22 <jagwire> kinda :)
16:45:42 <jagwire> In all of my 22 years, I've never once heard of haskell
16:45:58 <jagwire> and now that I'm in my last year of CS and IT degrees
16:46:13 <jagwire> I'm learning it...and it's absolutely nothing like any of the other languages I've learned
16:47:37 <Gracenotes> don't worry, some CS professors I've talked to had never heard of it either ;)
16:47:45 <Philonous> jagwire: Welcome! And yes, haskell is indeed rather different.
16:48:27 <jagwire> thank you, Philonous :)
16:49:10 <lament> Haskell is absolutely nothing like any of the other languages I haven't learned
16:49:39 <jsgf> hi all; I'm trying to install chp with cabal, but its failing: Control/Concurrent/CHP/Console.hs:38:17:
16:49:39 <jsgf>     Could not find module `Control.OldException':
16:49:39 <jsgf>       it is a member of the hidden package `base'
16:49:39 <jsgf>       Use -v to see a list of the files searched for.
16:49:40 <bd_> That's not true. '1+1' evaluates to the same thing as in most other languages. As long as the type resolves to Int.
16:49:42 <jsgf> any clues?
16:49:54 <bd_> now, unlambda, on the other hand...
16:50:05 <Gracenotes> bd_: forth? lisp? -_-
16:50:22 <bd_> Gracenotes: Those have functions, surely. And math operations.
16:50:34 <bd_> Well, they have user-defined functions, rather.
16:50:48 <bd_> Also control structures... :)
16:50:59 <dcoutts> jsgf: you'll need to build that package using base 4 rather than base 3
16:51:14 <Gracenotes> oh, just noting the order of your characters
16:51:36 <bd_> Gracenotes: Oh, thought you were talking about the comparison with unlambda.
16:52:01 <bd_> Gracenotes: It's pretty likely that jagwire has worked with a language in which '1+1' works much like it does in Haskell. Better? :)
16:52:47 <Gracenotes> right, right. although even in unlambda you can encode numbers. quite awkward though.
16:53:29 <bd_> you can encode something isomorphic to the integers, you mean
16:53:57 <gjl> Is the utility in learning Haskell akin to that of learning Latin?
16:54:00 <Gracenotes> encoding and the isomorphism it implies, quite
16:54:59 <c_wraith> gjl: No.  You ca write software in haskell.  Real, production software.  Good luck with your latin bestseller. :)
16:55:02 <blackdog> gjl: that's a reasonably common comparison. the difference is that you can actually use haskell.
16:55:20 <blackdog> gjl: actually, i've found that it sometimes makes my code in other languages worse
16:55:26 <blackdog> or at least very non-idiomatic
16:55:35 <blackdog> i get frustrated by broken scope much more, for instance
16:56:07 <Gracenotes> you can use Latin to read the classics! whoo!
16:56:46 <dcoutts> jsgf: you can do that using cabal install chp --prefer='base >= 4'
16:57:45 <blackdog> gjl: actually, paul graham wrote some interesting stuff about Lisp in that context, referring to ESR's comment
16:57:47 <jmcarthur> i asked this a little earlier, but i'll ask again. is there, bychance, any way to build a library that doesn't depend on base?
16:57:49 <blackdog> http://www.paulgraham.com/avg.html
16:58:09 <bob0> how do I see the type signature of the implementation of mplus for lists?
16:58:15 <Gracenotes> warning: blub analogy is contained therein. read at your own risk.
16:59:00 <jmcarthur> that is, could i steal some relevant portions of base such that i have everything i need without depending on base?
16:59:26 <Gracenotes> bob0: hm. as in, going from MonadPlus m => m a -> m a -> m a, to [a] -> [a] -> [a]?
16:59:36 <blackdog> Gracenotes: thought it was particularly funny that after writing that, PG referred to Haskell as a "weird, academic language"
17:00:05 <bob0> Gracenotes: what is the implementation of mplus for lists?
17:00:13 <jmcarthur> woops, dinner time
17:00:22 <jmcarthur> i'll read the scrollback when i get back in case anybody answered me
17:01:35 <Gracenotes> bob0: well, mzero is [], right? it is a dead end, after all. so now, the following needs to be true: a `mplus` [] == a, and [] `mplus` a == a
17:01:37 <Philonous> blackdog: You mean he fell prey to his own blub paradox?
17:02:22 <Gracenotes> by dead end, I mean if you return it any point, the end result will always be []
17:02:37 <Gracenotes> that is how mzero and mplus go together. So for lists, is there a function you can think of that does that..?
17:03:03 <Gracenotes> (or, you could check out the source :P)
17:03:17 <bob0> Gracenotes: ++?
17:03:36 <jsgf> dcoutts: thanks, that worked.  what does it mean?
17:03:42 <Gracenotes> yep, exactly.
17:03:59 <dcoutts> jsgf: between the choice of base 3 or base 4, prefer base 4
17:04:10 <blackdog> Philonous: exactly
17:04:23 <dcoutts> jsgf: the package itself doesn't say which it wants (but it should since it only works with one)
17:04:24 <Gracenotes> since the list monad just does a sort of mapping, using (++) means that it'll map the first part, and then it'll map the second part, in future uses of (>>=)
17:04:41 <Philonous> blackdog: Somehow, that proves his point, doesn't it?
17:04:54 <Gracenotes> so it is a good choice for mplus, and the one that makes the most sense with the type too
17:05:16 <bob0> ok
17:05:40 <jsgf> dcoutts: i see.  and by default it chooses the lower version to try to make the dependencies as unrestrictive as possible?
17:06:02 <ve> I get a ghc panic with this. Can anyone reproduce that? http://sprunge.us/AFDi
17:06:23 <dcoutts> jsgf: in the case of base, it's sort of a backwards compat hack for all the older packages that work with base 3 but not 4, new packages are expected to say if they want 3 or 4
17:06:43 <blackdog> Philonous: depends what you think his point is. I think he was making a claim that Lisp was at the peak of the pyramid
17:07:19 <blackdog> but then, i suppose everyone thinks their language is. I certainly don't know why people are bothering with that Agda stuff, it's just weird academic proof stuff that'll never take off :
17:07:23 <blackdog> :)
17:07:39 <Gracenotes> maybe he could make a graph of which languages are better than other languages. But of course, you might run into those damn cycles..!
17:08:58 <Philonous> blackdog: Well, yes, I suppose that was his hidden agenda. (And maybe it was true at some time), but I think the more interesting point there was that no one is immune to the blub paradox and that you should keep your eyes open about what is going on in the CS world
17:09:49 <blackdog> Philonous: yeah. but meta-points are peaceful and illuminating, I'd rather just be mean-spirited and snipe.
17:10:55 <gjl> Would one be better served in the long run starting with C and then learning Haskell or starting with Haskell and then moving to C?
17:12:11 <MyCatVerbs> gjl: I'd say start with C.
17:12:11 <sophacles> gjl that would depend on if you are a mathy person or a computery person
17:12:17 <dcoutts> gjl: Haskell will help you understand programming, C will help you understand low level aspects of programming (memory layout, pointers etc)
17:12:30 <blackdog> both will frustrate you when you move from one to the other:)
17:12:37 <Philonous> gjl: IMO C and Haskell are somewhat orthogonal skill sets. If you want to hack some OS or read lots of (legacy) you will definitely need C.
17:12:43 <MyCatVerbs> gjl: the best time to try Haskell is when other languages have annoyed you too much. :)
17:13:51 <gjl> sophacles, what would you say for a more 'computery' person?
17:14:08 <Gracenotes> amusing how the transitive closure of edges of a polygon can form a DAG.. but just barely; adding any other edge would yield a cycle
17:14:11 <sophacles> gjl, c
17:14:23 <dcoutts> there's nothing wrong with starting with FP, there's no reason to think that imperative languages are easier for beginners, on the contrary
17:15:11 <MyCatVerbs> Gracenotes: heh. You've found an alternative definition of the transitive closure. :)
17:16:29 <blackdog> gjl: Haskell will teach you to be precise, at least. for instance, I got bitten by trying to call hs_init (the C command to start the GHC runtime engine), because I didn't realise that hs_init intended to modify the structures I passed in, and because of the way i'd allocated them, the OS wouldn't let it happen (and segfaulted)
17:16:32 <sophacles> dcoutts, i agree -- fp is good for those with a solid math base already, whereas C is good for those who are used to thinking procedurally...  beacuse learning any programming language, there is enough crap (syntax etc) that hooking into anything you already do well is a very good thing.
17:16:38 <Gracenotes> heh, you're right. I suppose the semi-surprising fact is that it's a DAG. but I haven't done srs graph theory in a while :X
17:16:48 <blackdog> i couldn't have done that in Haskell, because it would have made me pass in an IORef.
17:16:57 <dcoutts> gjl: I think it's fine and sensible to learn both Haskell and C, the two complement each other reasonably well. I use both. Haskell for most everything and then C for low level stuff or interacting with other C libs.
17:17:32 <gjl> dcoutts: learning both as in learning both simultaneously?
17:17:49 <dcoutts> gjl: that might be a bit confusing, I'd do one then the other.
17:18:16 <FunctorSalad> Gracenotes: wait, the polygon is a cycle already
17:19:47 <Philonous> blackdog: You can always be mean to die-hard C/java programmers. Poking fun at them when they are writing the same code segment the umpty-bazillionst time and having the executable barf all over the memory afterwards is somehow very amusing.
17:20:06 <Gracenotes> 1. take cyclic polygon 2. reverse one edge 3. no cycles
17:20:43 <Gracenotes> it also means that the node on the 'from' side of the edge you reverse becomes the parent of all other nodes
17:21:07 <gjl> Yes, I can certainly see the merit in learning both. It's just a matter of which will make the best starting point. I get the impression I'd find Haskell to be the stranger of the two, so I'm thinking that might make for a better learning experience for someone somewhat masochistic.
17:21:48 <blackdog> Philonous: yeah. The speed thing is a total furphy: given the same amount of time, a haskell hacker gets a correct solution faster and has more time to spend on optimisation...
17:22:47 <Philonous> gjl: Pointer arithmetic will - in any reasonably complex setting - make your head explode just as much as understanding monads will. Neither is "easy" for a total beginner.
17:23:20 <FunctorSalad> Gracenotes: but... the transitive closure will have weak cycles, and it won't have strong cycles even if you add an edge. or I'm wrong
17:23:27 <hrehf> blackdog waht if the problem requires low level, architecture-near access?
17:23:45 <blackdog> hrehf: haskell is the world's finest imperative programming language ;P
17:23:48 <hrehf> not that there are many problems that really do ;-)
17:23:54 <Philonous> hrehf: What if your boss says you have to use C.
17:24:09 <hrehf> Philonous :/
17:24:42 <blackdog> hrehf: it's a matter of degree, too. linking in to C is easy if you really need to, and now calling Haskell from C is doable too.
17:24:58 * blackdog sends bouquet to dcoutts
17:25:05 <Gracenotes> FunctorSalad: hm. I built it by putting out (n-1) edges from one node, (n-2) edges from the one next to it, (n-3) for the next, and so on, until you connect the second to last and last, and then everything is connected
17:25:10 <hrehf> oh, yes, i wasn't really criticising or discussing, just wanted to throw that in :P
17:25:15 <Gracenotes> but I'm pretty sure, even building it like it, it forms a transitive closure
17:25:18 <hrehf> i'm all on the productivity side
17:25:18 <Gracenotes> like that
17:25:22 <dcoutts> blackdog: ?!
17:25:26 <benmachine> hrehf: I've heard it argued (by quick silver, especially) that C is not low level enough where architecture access is important
17:25:32 <blackdog> dcoutts: oh, the dynamic linking stuff.
17:25:42 <blackdog> that was your baby to some extent, wasn't it?
17:26:02 <dcoutts> blackdog: ooh :-)
17:26:23 <hrehf> benmachine yes, but then it's quite easy to switch to assembler, isn't it? But for pc i haven't heard from anyone at uni doing high performance stuff who needed to do that
17:26:24 <dcoutts> blackdog: I did some of the last bits, it's the work of several other people over the last couple years
17:26:41 <Gracenotes> FunctorSalad: anyway, I am leaving for a bit.. if you notice anything wrong with my logic, I've love to know ;)
17:26:46 <Gracenotes> *teh away*
17:26:55 <dcoutts> blackdog: I take it it's working then?
17:26:59 <FunctorSalad> ok bye
17:27:03 <blackdog> dcoutts: like a dream, at least on linux
17:27:07 <dcoutts> nice
17:27:08 <benmachine> my general assumption is that one should start from the basis that people who write compilers are cleverer than you
17:27:23 <benmachine> and hence in a way the higher-level the better
17:27:38 <benmachine> because basically I can't be trusted with anything :)
17:27:47 <blackdog> i'm having some issues with trying to load in functions with the same name but a different implementation, but I haven't got a really clean model for what I _want_ to happen there anyway
17:28:02 <blackdog> just leaving the failing test in as a reminder to clean up the semantics
17:28:05 <base3> can anyone help me with this? http://pastebin.com/m3b47d376
17:28:09 <dcoutts> benmachine: I did an internship at a place once where the compiler guys were very down on C, that it was really hard to get good performance out of it
17:28:26 <base3> i'm not getting my head around what the closures are supposedto be
17:29:07 <dcoutts> benmachine: of course they preferred Fortran, because it gave the compiler writers the freedom to do all sorts of optimisations like rearranging arrays and loops, without having to worry about pointer aliasing etc etc
17:29:36 <bd_> base3: uh, you sure that's the right link?
17:30:08 <benmachine> dcoutts: yeah, that was one of my big realisations about Haskell that putting more restrictions on the program can actually make it easier to work with
17:30:23 <dcoutts> benmachine: right
17:30:32 <benmachine> I say one of my big realisations as if I had any others >_>
17:30:38 <FunctorSalad> :)
17:30:46 <Philonous> Why is he posting an ascii-art of a girl eating ice on a stick?
17:31:02 <benmachine> I couldn't work out what it was at all
17:31:13 <benmachine> is it like a captcha and I am an AI
17:31:50 * base3 lollin @ virgins in this channel
17:31:56 --- mode: ChanServ set +o dcoutts
17:32:15 <dcoutts> play nicely please
17:32:53 <Veinor> wait what?
17:32:55 <Veinor> ascii art?
17:33:19 <copumpkin> o.O
17:37:31 <copumpkin> base3: feel the need to come into a channel of "geeks" to remind yourself how much better you are than us, because of your preconceptions about our social and sexual lives? if you already had your conclusions, you could've just left out the part where you joined this channel :)
17:37:33 <lilac> bwahahah, http://Control.Monad.ST is all mine!
17:38:54 <Saizan> you like that module a lot, don't you?:)
17:39:04 <base3> copumpkin: no i didnt have any preconceptions, i was just surprised when i posted a picture of a woman sucking a mans cock, and noone recognised what it was..
17:39:21 <sophacles> lilac according to dns its no one's
17:39:25 <dcoutts> copumpkin, base3: enough please, this isn't the forum
17:40:01 <base3> ok sorry
17:40:07 <base3> EOD
17:40:43 --- mode: ChanServ set -o dcoutts
17:40:48 <benmachine> what is the forum?
17:41:03 <copumpkin> benmachine: #***********
17:41:05 <FunctorSalad> lilac: hmm nothing there yet
17:41:20 <FunctorSalad> . o O ( hunter2 )
17:41:25 <dcoutts> benmachine: the square in the middle of a Roman town of course :-)
17:41:34 <benmachine> dcoutts: classy!
17:41:40 * copumpkin is from a roman town!
17:41:44 <sjanssen> base3: I prefer base-4
17:41:54 <benmachine> london is strictly speaking a roman town, right?
17:41:59 <base3> base 3 is pimp
17:42:06 <dcoutts> mm, base-3 is deprecated
17:42:10 <base3> especially balanced ternary
17:42:12 <benmachine> it has a square mile, does that count
17:42:18 <copumpkin> we've all moved on to 4th base
17:42:25 <benmachine> who's on first?
17:55:02 <Veinor> @hoogle directory
17:55:02 <lambdabot> package directory
17:55:02 <lambdabot> module System.Directory
17:55:02 <lambdabot> System.Posix.Internals Directory :: FDType
18:25:19 <deew123123> hey guys what is the AND function in haskell?
18:25:27 <heatsink> (&&)
18:25:30 <deew123123> thanks
18:26:42 <Makoryu> :t (&&)
18:26:44 <lambdabot> Bool -> Bool -> Bool
18:26:45 <Makoryu> :t (and)
18:26:47 <lambdabot> [Bool] -> Bool
18:27:10 <Makoryu> > and [True, True, True, True]
18:27:15 <lambdabot>   True
18:27:23 <copumpkin> > and [True, False, undefined]
18:27:27 <lambdabot>   False
18:35:12 <jmcarthur> alright. my latest discovery is that if you try to install a base-like library along side base, even under a different name, it trashes base and then complains because it trashed base, so doesn't even install the base-like library you are messing with
18:35:34 <jmcarthur> or something...
18:36:01 <Axman6> sjanssen: so i tried putting that quicksort i had into another module, and it still seems faster than Data.List.sort. but again, i'm not exactly testing very heavily
18:36:26 <jmcarthur> oh, or not...
18:36:55 <copumpkin> Axman6: is it lazy?
18:37:03 <Axman6> i doubt it
18:38:12 <jmcarthur> huh, okay, the package name has to be set to base....
18:38:16 <jmcarthur> that's unnerving
18:40:31 <Axman6> > 2^12
18:40:35 <lambdabot>   4096
18:41:13 <Axman6> > 2^16
18:41:17 <lambdabot>   65536
18:43:03 <Axman6> copumpkin: hmm, it seems to be somewhat lazy actually. printing the head is almost instant, when sorting 2000000 numbers
18:44:11 <Axman6> apparently more instant than doing the same thing with Data.List.sort
18:49:38 <Axman6> copumpkin: it seems to be just as lazy as Data.List.sort, and dies under the same considions
19:05:17 <FunctorSalad> yay lilac's control.monad.st is online now
19:05:33 <FunctorSalad> test page, anyway
19:05:49 <FunctorSalad> sorry, pointless comment
19:07:08 <ivanm> @slap FunctorSalad
19:07:09 * lambdabot submits FunctorSalad's email address to a dozen spam lists
19:07:11 <ivanm> sorry, pointless slap
19:07:12 <ivanm> :p
19:08:36 <ivanm> for dons: http://imgur.com/SNc4S.jpg
19:08:38 <ivanm> ;-)
19:08:44 <blackdog> all slaps are volitional and portals to discoery
19:08:46 <blackdog> discovery
19:09:10 <FunctorSalad> poor seal
19:09:32 <blackdog> i want to know what a koala is doing in antarctica
19:09:47 <FunctorSalad> good point.
19:09:50 <heatsink> ivanm: Archie McPhee?
19:09:52 <blackdog> you a long way from home, boy, and we doan like strangers...
19:10:03 <ivanm> blackdog: it's working at the research station ther
19:10:04 <ivanm> *there
19:10:05 <ivanm> duh
19:10:06 <ivanm> ;-)
19:10:11 <ivanm> heatsink: hmmm?
19:11:03 <heatsink> ivanm:http://www.mcphee.com/shop/products/Avenging-Narwhal-Play-Set.html
19:11:32 <ivanm> heatsink: I found it on reddit, actually...
19:11:50 <heatsink> kay
19:12:01 <ivanm> heh, cold war unicorns...
19:12:12 <ivanm> whoever started up that online store has serious issues...
19:13:08 <FunctorSalad> clickable link: http://www.mcphee.com/shop/products/Avenging-Narwhal-Play-Set.html
19:20:37 <copumpkin> is there any way to define a "lazy" natural type without defining it inductively peano-style?
19:21:11 <dolio> You could define it inductively, list-of-bits style.
19:21:20 <ivanm> heh
19:22:32 <Saizan> base-2 instead of base-1, an exponential decrease in size.
19:23:02 <copumpkin> well, I'm tempted to write a binding to gmp for naturals
19:23:15 <copumpkin> but it'd be nice to have them behave like the natural that's in lambdabot right now
19:23:32 <heatsink> :t Nat
19:23:34 <lambdabot> Not in scope: data constructor `Nat'
19:23:37 <copumpkin> :k Natural
19:23:37 <heatsink> :t Natural
19:23:39 <lambdabot> *
19:23:39 <lambdabot> Not in scope: data constructor `Natural'
19:23:59 <dolio> You can use a list of arbitrarily sized chunks, too, I suppose.
19:24:01 <heatsink> > pred O
19:24:05 <lambdabot>   Not in scope: data constructor `O'
19:24:09 <copumpkin> > foldr1 (+) [1..] > (3 :: Natural)
19:24:13 <lambdabot>   True
19:24:15 <dolio> [Int], for instance.
19:24:33 <copumpkin> yep
19:24:42 <copumpkin> that's integer-simple's representation actually
19:25:00 <FunctorSalad> copumpkin: coq has binary inductive naturals if that's what you mean
19:25:06 <FunctorSalad> (like dolio suggested)
19:25:41 <copumpkin> FunctorSalad: yeah, but it would be nice to have high-performance binary inductive naturals, somehow leveraging GMP yet retaining the nice properties
19:26:19 <copumpkin> obviously GMP isn't inductive, but maybe rewrite rules could help, get the best of both worlds
19:26:22 <roconnor> copumpkin: there is a binary natural number library in hackage
19:26:29 <roconnor> with infinity even IIRC
19:27:09 <copumpkin> roconnor: yeah, but it'd be nice to have GMP-like performance too
19:27:28 <Saizan> heh nice overloading of binary there
19:27:51 <roconnor> copumpkin: ya, It'd be fun to use [Int]
19:27:59 <roconnor> or
19:28:03 <roconnor> [Word]
19:28:10 <copumpkin> roconnor: that's what integer-simple already does
19:28:21 <copumpkin> it represents naturals that way and then has a tag for sign
19:28:27 <dolio> I'm not sure list-of-bits representation fills all the uses of peano numerals, either.
19:28:40 <copumpkin> it doesn't actually use [] but has its own strict lists
19:28:41 <dolio> For instance is "length [1..]" non-bottom?
19:28:43 <roconnor> copumpkin: oh right, we want Tree Word
19:28:54 <roconnor> or something like that
19:28:56 <Saizan> copumpkin: the rewrite rules should basically do strictness analysis and realize when it's safe to use GMP?
19:29:06 <copumpkin> Saizan: ideally :)
19:29:18 <copumpkin> doesn't sound very hopeful, eh
19:29:35 <FunctorSalad> there are different ways in which ints can be lazy, aren't there? e.g. you could have numbers which first compute whether they are even or whatever
19:29:48 <Saizan> not with rewrite rules, but maybe you can otherwise
19:30:43 <copumpkin> (basically, I'd really like a nice high-performance natural type to propose as a replacement for all the terrible Ints throughout the standard library)
19:30:55 <copumpkin> or if not propose, then rewrite my own copy of standard libraries to use it
19:31:42 <Saizan> like in length?
19:31:45 <copumpkin> as I doubt people would be very open to changing those terrible Ints
19:31:46 <copumpkin> yeah
19:32:01 <copumpkin> Integer would be a better thing there, but really it should be Natural
19:32:14 <copumpkin> and that should be the default, and not some red-headed stepson hidden behind genericLength :P
19:32:21 <dolio> How fleshed out are the GMP naturals? When I read the docs way back, it sounded like they were just kind of building blocks for the integer stuff, not for actual use.
19:32:47 <copumpkin> dolio: they are, they have the mpn interface to them which isn't too painful, but would require a bit more code on our side
19:32:50 <copumpkin> (that I'd be willing to write)
19:33:30 <Gracenotes> hello, back
19:33:39 <copumpkin> and I'd still give it the S#/J# equivalent for small values
19:33:48 <copumpkin> which most of the time means you get near-nativeword performance
19:33:53 <Gracenotes> hm, English, a pronoun-dropping language? say it ain't so
19:34:14 <heatsink> Ain't so.
19:35:24 <Hunner> I drop my pronouns all the time. It reads like Rorschachs journal sometimes
19:35:25 <copumpkin> it seems silly to have all those checks in the standard functions for negativity
19:35:30 <copumpkin> > take (-1) [1..]
19:35:35 <lambdabot>   []
19:35:38 <copumpkin> boo :)
19:35:43 <copumpkin> you know what I mean
19:36:05 <copumpkin> I know that it was h98, before Word was added, but that was over 10 years ago
19:36:05 <Gracenotes> better than it being an infinite cycle
19:36:13 <Berengal> Numbers that can't be negative shouldn't possibly ever be negative
19:36:14 * heatsink would prefer to have Nat :: Bounded
19:36:20 <heatsink> er
19:36:29 * heatsink would prefer to have Nat, where instance Bounded Nat
19:36:42 <copumpkin> Bounded on one side
19:36:50 <Gracenotes> that might not be pretty
19:36:56 <Berengal> Nat isn't bounded. It has a lower bound, and it has a value that's larger than all others, but it's not the upper bound
19:37:23 * copumpkin has found a shortcoming of SHE he thinks
19:37:29 <heatsink> Following the Int-Integer convention, we'd have Nat-Natural
19:37:42 <dolio> Nat is already named Word.
19:37:49 <Gracenotes> copumpkin: surely you know better than to criticize your girlfriend
19:37:49 <copumpkin> I guess we could make a type synonym
19:39:39 <heatsink> I dislike how so many library functions allow negative numbers, but I like using product types for performance reasons.
19:40:34 <copumpkin> aha, SHE is still rather simple
19:40:50 <copumpkin> it won't lift much to the type level
19:41:28 <heatsink> Acutally, it's not the performance itself, it's knowing what I can expect of the output code.
19:44:22 <copumpkin> meh, me wants SHE to do what he wants
19:44:55 <bcw> what's the best way to find the shortest list in a list of lists?
19:45:06 <dolio> Go code up an optimizing Epigram 2 compiler.
19:45:13 <heatsink> minimumBy (min `on` length)
19:45:28 <heatsink> minimumBy (compare `on` length)
19:45:29 <copumpkin> heatsink: compare `on` length
19:45:30 <copumpkin> yeah
19:45:33 <copumpkin> or just comparing length
19:45:42 <bcw> heatsink and copumpkin, thanks
19:45:53 <copumpkin> dolio: oh why didn't I think of that!
19:45:56 <heatsink> :t comparing
19:45:58 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:46:03 <copumpkin> :t (compare `on`)
19:46:05 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
19:46:05 <heatsink> nift.
19:46:25 <copumpkin> :t (compare `on`) asTypeOf compring
19:46:27 <lambdabot> Not in scope: `compring'
19:46:35 <copumpkin> :t (compare `on`) `asTypeOf` comparing
19:46:37 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
19:46:42 <dolio> copumpkin: It'll solve all of your problems. :)
19:47:15 <dolio> copumpkin: Actually, you'll probably want to write an interactive programming environment for it, too. :)
19:47:27 <copumpkin> damn right!
19:47:30 * copumpkin gets down to work
19:47:45 <copumpkin> oh wait, I barely know any type theory, I think I may stumble rather early :)
19:48:02 <Saizan> ATS?
19:48:13 <copumpkin> ATS is ugly
19:48:27 <Saizan> mh, maybe with a preprocessor..
19:48:59 <dolio> I think SHE has more ambitious features than ATS. :)
19:49:05 * copumpkin simply wants to take his value-level function and ask SHE to lift it
19:49:12 <dolio> As far as value-type linkage goes.
19:49:21 <Saizan> really?
19:49:23 <copumpkin> unfortunately it seems to assume all you ever want is data constructors
19:49:55 <dolio> Yeah, ATS needs you to write everything twice.
19:50:41 <dolio> Of course, ATS has linear typing and stuff which is a bit fancier.
19:51:51 <Saizan> so, in ATS you've values, and then values which can appear in types?
19:52:20 <dolio> You have a static language, and a dynamic language that's parameterized by the static language.
19:52:32 <dolio> Like how you'd arrange for 'dependent programming' in GHC.
19:52:36 <dolio> Or Omega.
19:53:12 <dolio> Of course, it has a lot more predefined stuff that's already been written twice.
19:53:30 <dolio> And stuff like machine integers are arranged that way, but still efficient, which you'll never get with GHC.
19:53:37 <dolio> At least, I think that's the case.
19:54:55 <copumpkin> arranged what way?
19:55:32 <copumpkin> oh no, they'll annihilate!
19:55:36 <Saizan> "Of course, it has a lot more predefined stuff that's already been written twice." <- i find this line incredibly amusing, but i'm not sure if it's suitable for @remember
19:56:10 <FunctorSalad> :)
19:56:11 <Saizan> copumpkin: so that you can access it at the typelevel, i guess
19:56:50 <Saizan> e.g. instead of typelevel peano numerals you get machine Ints, with all the functions built-in
19:57:10 <copumpkin> I see
19:58:42 <dolio> Back when ATS was called Dependent ML, type-level Ints were all you had to work with.
19:59:02 <Saizan> btw, one thing that i miss in agda is that bit of logic programming to build proofs from types that typeclasses give you
19:59:32 <Saizan> (or fail at compile time if it's not possible)
20:00:27 <dolio> Yeah, having dictionaries filled in automatically is really convenient.
20:00:29 <heatsink> It builds a proof given the desired conclusion?
20:01:29 <dolio> Trying to write abstracted functions in Agda, that rely on several records witnessing some structure on a type is a pain.
20:02:54 <dolio> Although one way of avoiding that type of thing is to parameterize a module by the necessary records, and open the records in that module, and use them.
20:03:08 <dolio> If you're writing several functions that use the same functionality.
20:04:28 <Saizan> i'm thinking about the case where you're needing many, generally related, different instances
20:07:11 <Saizan> like, if you implement extensible records by having functions accept proofs that the label they want is in the record, when you apply a record to such a function you also have to manually build such proofs, which are actually derivable from the type of the record
20:08:33 <dolio> Yeah.
20:13:48 <Saizan> it seems like i should be able to put a decidable predicate into a type to work like a guard
20:34:21 <bos> @pl f g i = g * (x - k + i)
20:34:21 <lambdabot> f = (. ((x - k) +)) . (*)
20:35:20 <copumpkin> bos: how goes your epic benchmarking framework?
20:35:31 <bos> copumpkin: plugging along
20:35:58 <dolio> Are you using uvector-algorithms, or just uvector?
20:37:28 <Zeiris> Is @pl some kind of optimizer?
20:37:38 <c_wraith> Not hardly. :)
20:37:49 <dolio> Some kind.
20:37:57 <c_wraith> It just converts a function from using explicit arguments to...  not
20:38:20 <jfoutz> it optimizes for unreadability
20:38:30 <c_wraith> @pl \x y -> x + y
20:38:30 <lambdabot> (+)
20:38:38 <jfoutz> @pl id.id.id
20:38:39 <lambdabot> id
20:38:48 <jfoutz> sometimes it does a bad job. :p
20:39:18 <Tony[`]> Hey, this is a very dumb question, but in GHCI, how do I specify the type signature?
20:39:37 <copumpkin> let f :: type; f = value
20:39:46 <jfoutz> > 1::Int
20:39:48 <ivanm> or the other way round
20:39:50 <lambdabot>   1
20:39:54 <Tony[`]> thanks
20:39:59 <jfoutz> and a bunch of () around expressions
20:42:07 <jfoutz> functors are neat.
20:42:16 <jfoutz> monids are neat.
20:42:23 <blackdog> any idea how to catch the runtime error you get from a case statement with a partial match?
20:43:12 <edwardk> blackdog in general, try not to let it happen, but if you are forced to you can catch it in an IO action
20:43:15 <Tony[`]> how about this.. why does GHC support compiling C++?
20:43:44 <blackdog> edwardk: yeah, i know it's a bad idea - i'm just pretty sure that the ruby hackers will write some awful haskell and i want to return a nice HaskellException to them
20:43:54 <edwardk> Tony[`]: because it can? =) mostly because it wants to support compiling all the targets that it can generate downstream.
20:44:03 <edwardk> so it passes that along to gcc, or whatever
20:44:36 <Tony[`]> alright, thanks :)
20:45:03 <Makoryu> Tony[`]: It's probably just an accident of using the C backend with a C compiler that also supports C++
20:56:56 <blackdog> edwardk: it doesn't seem to do the right thing: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3565#a3567
21:00:52 <Tony[`]> more silly questions :) I did some fairly comparable samples between C and Haskell, and while I understand why and I'm not complaining, I'm curious about the difference in size in the ouput executables (gcc and ghc)
21:01:15 <copumpkin> static linkage
21:02:33 <blackdog> Tony[`]: the new version of ghc will have dynamic linking, binaries will be much smaller
21:02:42 <blackdog> and jhc's binaries are tiny...
21:02:43 <BMeph> More runtime controls
21:04:27 <Tony[`]> blackdog: ETA?
21:05:22 <blackdog> Tony[`]: it _was_ the 14th, but i think it's slipped a bit. pretty soon. it's definitely working in HEAD, i'm using it for Hubris now.
21:06:55 <Tony[`]> blackdog: oh, okay, I just didn't know if you meant "new version" like.. new version of Visual Studio might mean
21:07:01 <Tony[`]> i.e., years apart :)
21:07:17 <Zeiris> What is jhc missing compared to ghc - just some extensions, I imagine?
21:07:33 <blackdog> Zeiris: a shitload. ByteStrings, for instance. Cabal support.
21:07:36 <dolio> Ability to compile most programs?
21:07:42 <Zeiris> Aww :)
21:07:51 <Tony[`]> :P
21:07:56 <blackdog> if you're just using vanilla haskell you're probably ok
21:08:01 <Tony[`]> blackdog: metric or imperial shitload? :P
21:08:13 <blackdog> most libs aren't set up to be used by jhc.
21:08:23 <Zeiris> Isn't the loss of bytestrings usually more of a performance hit than a lack of whole-program optimization?
21:08:32 <blackdog> Tony[`]: metric. i'm an australian, after all.
21:08:47 <blackdog> Zeiris: well, yeah. jhc is still very much under development.
21:08:52 <Tony[`]> i tend to use the "metric shitton" quite a bit personally
21:12:12 <babusrini> Module A imports one function in Module B and vice-versa. Why is this not allowed. ghc says "Module imports form a cycle for modules:"
21:12:40 <ivanm> because it's hard to load them properly
21:12:56 <ivanm> it's possible to get this working with a config file IIRC, but it's discouraged
21:13:13 <ivanm> after all, how do you compile A if it needs B, but B can't be compiled yet because it needs A?
21:13:47 <ivanm> you should try to refactor your code to have at least one function from one of the modules moved into a third module which both can import
21:13:51 <ivanm> thus breaking the cycle
21:14:22 <babusrini> OK. Thanks
21:14:47 <p_l> hmmm... shouldn't it be possible to do a forward declaration of sorts?
21:15:44 <BMeph> p_l: What does that even mean? :)
21:16:11 <Gracenotes> if all declarations in a module are treated independently, cycles shouldn't be a problem, no? I suppose this is not the case
21:17:00 <Gracenotes> but stylistically.. FP really only tends to be cyclic in the small.. so it's not huge
21:17:13 <p_l> BMeph: accept unresolved symbols and "link" them when you get all resolved
21:17:38 <babusrini> I was thinking that if you do do it in 2 passes, you can do the resolution.
21:19:16 <p_l> BMeph: for example, in SBCL I can compile a function that refers to nonexisting symbols, but compiler will complain. Just like it screams bloody murder when the I enable optimization and the types are ambiguous ^^;
21:19:35 <Gracenotes> I didn't realize modules had that limitation. and I've been using them for 9 months
21:20:02 <p_l> Gracenotes: cyclic dependencies are rather rare afaik...
21:20:24 <ray> i think you need to annotate one or both of the things in the cycle
21:20:27 <ray> and then ghc will do it
21:20:32 <ray> there's a way, anyway
21:20:35 <ray> it's not pretty
21:20:41 <copumpkin> hs-boot
21:20:47 <copumpkin> or what?
21:20:57 <ray> yes
21:21:03 <ray> that sounds like it
21:21:20 <ray> you should probably avoid the cyclic dependencies in the first place though
21:21:22 <Gracenotes> cycles in general tend to be either prevalent in a system or unimaginable in said system
21:22:42 <Gracenotes> this case might be an exception, in that they are merely rare, and easily resolvable acyclically.
21:24:16 <Gracenotes> grrr. wget says: HTTP request sent, awaiting response... 206 Partial content. Length: 93652169 (89M), 67465089 (64M) remaining [application/octet-stream].
21:24:29 <Gracenotes> and two minutes later, Connection closed at byte 93652168. Retrying.   ... how does that even happen :/
21:24:54 <Gracenotes> well, at least I only have to download 8 more bits
21:25:22 <p_l> Gracenotes: check if the file works without last octet :D
21:25:39 <Gracenotes> too late -_-
21:26:03 * p_l once had a run-in with HTTP servers having problems with last byte...
21:26:50 <Gracenotes> "Jeez, when can I stop sending my data to this dude already"
21:27:53 <p_l> Gracenotes: maybe it's an "uh oh, I have so much overhead that I'm not sure if I counted the bytes ok"
21:28:05 <ivanm> that reminds me, I had a weird email yesterday from someone saying that he'd found my implementation of Tarjan's SCC algorithm (when it's actually Iavor's, not mine...) and wanted to know if there was a "window encoding" version rather than the Mac OS one that was there... >_>
21:36:35 <dibblego> @users
21:36:35 <lambdabot> Unknown command, try @list
21:36:39 * dibblego wtfs
21:36:47 <copumpkin> I guess Cale turned that off too
21:36:53 <copumpkin> given its forgetfulness
21:37:28 <dibblego> @type []
21:37:30 <lambdabot> forall a. [a]
21:37:41 <ivanm> that module is gone
21:37:45 <ivanm> due to general badness
21:37:48 <copumpkin> @kind []
21:37:50 <lambdabot> * -> *
21:37:56 <dibblego> general badness?
21:38:09 <ivanm> dibblego: it's state serialisation stuff is bad IIRC
21:38:16 <copumpkin> dibblego: being generally useless and losing its memory every time lb crashes
21:38:17 <ivanm> and its memory usage as well
21:38:25 <ivanm> copumpkin: it's not useless!
21:38:32 <copumpkin> @seen was
21:38:33 <lambdabot> Unknown command, try @list
21:38:39 <ivanm> (well, @seen isn't... @users is partially useless...)
21:38:53 <dibblego> @tell ivanm boo
21:38:54 <lambdabot> Consider it noted.
21:38:57 <copumpkin> most of the time it would tell you that the last time it saw someone was when it parted a huge list of channels 18 months ago
21:38:59 <ivanm> @messages
21:38:59 <lambdabot> dibblego said 5s ago: boo
21:39:06 <ivanm> happy now? ;-)
21:39:13 <dibblego> @list
21:39:13 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:39:16 <ivanm> copumpkin: yeah, that's a PITA...
21:39:28 <dibblego> lies!
21:41:13 <copumpkin> > seen "ivanm"
21:41:18 <lambdabot>   I last saw ivanm when I parted #haskell, #ghc, #haskell-blah, #agda, ##logi...
21:41:23 <copumpkin> damn
21:41:24 <ivanm> :o
21:41:38 <ivanm> copumpkin: so they didn't excise the module completely then...
21:41:43 <ivanm> preflex: seen copumpkin
21:41:43 <preflex>  copumpkin was last seen on #haskell 20 seconds ago, saying: damn
21:42:08 <copumpkin> there we go
21:42:11 <copumpkin> > seen "ivanm"
21:42:16 <lambdabot>   I last saw ivanm when I parted #haskell, #ghc, #haskell-blah,
21:42:17 <lambdabot>   #agda, ##lo...
21:42:21 <copumpkin> nooo
21:42:26 <ivanm> heh
21:42:48 <copumpkin> my definition was @let seen x = text ("I last saw " ++ x ++ " when I parted #haskell, #ghc, #haskell-blah, #agda, ##logic, #kata, #haskell.it, #haskell-in-depth, #haskell-iphone, #lhc-compiler, #darcs, and another ****ing huge list of channels 183 months, 3 days, 2 hours, and 8 minutes ago.")
21:43:03 <ivanm> @slap copumpkin
21:43:04 * lambdabot slaps copumpkin
21:43:17 <ivanm> @slap copumpkin
21:43:17 * lambdabot orders her trained monkeys to punch copumpkin
21:43:17 <ivanm> @slap copumpkin
21:43:18 * lambdabot places her fist firmly on copumpkin's jaw
21:44:47 <Veinor> How do I get haskell mode in emacs?
21:46:57 <ivanm> by downloading it and installing it...
21:46:59 <int-e> @google haskel-mode emacs
21:47:00 <lambdabot> http://www.haskell.org/haskell-mode/
21:47:00 <lambdabot> Title: Haskell Mode for Emacs
21:47:01 <ivanm> @where haskell-mode
21:47:01 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
21:47:08 <Veinor> Oh, found it in repos.
21:47:11 <ivanm> IIRC, the link for int-e is wrong...
21:47:39 <int-e> eh, I typoed.
21:48:01 <int-e> and in any case the second hit would be the @where one.
21:48:28 <Veinor> Ooh, shiny.
21:48:35 <ivanm> @where kuribas
21:48:35 <lambdabot> I know nothing about kuribas.
21:48:41 <ivanm> @where kuribas-mode
21:48:41 <lambdabot> I know nothing about kuribas-mode.
21:48:50 <ivanm> @go haskell kuribas emacs
21:48:50 <lambdabot> Maybe you meant: google googleit do
21:48:56 <ivanm> @google haskell kuribas emacs
21:48:57 <lambdabot> No Result Found.
21:48:59 <ivanm> gah
21:49:18 <ivanm> Veinor: kuribas has an alternative indentation minor mode for haskell-mode...
21:49:24 <ivanm> can't seem to find it atm though...
21:50:16 <Veinor> Eh, I'll just play around with what I got.
21:50:25 <Veinor> ... ohohohoho
21:57:58 <PetRat> Having some trouble with guis and the IO monad. It seems that I'm able to create a list of items in the IO monad but they are never evaluated for their side-effects. Story is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9294#a9294
21:59:17 <SubStack> try mapM or mapM_
21:59:29 <SubStack> or forM{,_}
21:59:32 <mauke> pp is undefined
21:59:53 <PetRat> Ooops pp is supposed to be paint.
22:00:29 <Berengal> Sure about that?
22:00:44 <PetRat> Yeah actually supposed to be charsPoints.
22:00:49 <mauke> cp <- charsPoints; mapM_ paint cp
22:01:19 <Berengal> charPoints >>= mapM_ paint
22:02:17 <PetRat> It works!
22:02:46 <SubStack> \o/
22:02:56 <PetRat> The way I wrote it, I created something like IO (IO t)
22:03:07 <PetRat> Is that why it was never evaluated for side-effects?
22:03:09 <Berengal> I've realized another benefit of immutable variables... since you can't reuse old variable names you write shorter functions to not run out of names...
22:03:17 <Berengal> yep
22:03:17 <mauke> PetRat: basically, yes
22:03:36 <mauke> :t join
22:03:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:03:44 <Berengal> liftM doesn't actually do anything, it just applies a pure function to the result of a monadic action
22:03:55 <mauke> @src mapM
22:03:56 <lambdabot> mapM f as = sequence (map f as)
22:04:01 <mauke> @src sequence
22:04:01 <lambdabot> sequence []     = return []
22:04:01 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:04:01 <lambdabot> --OR
22:04:01 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:04:08 <mauke> hmm, no
22:04:17 <PetRat> Berengal: it what sense "doesn't it do anything"?
22:04:43 <Berengal> PetRat, no extra side-effects added
22:05:59 <PetRat> One thing that made this difficult for me was this---I wanted to zip a character together with its position as expressed by a QPoint. But QPoints only exist in the IO monad and can only be created one at a time.
22:06:15 <PetRat> So I had to sequence them, then lift zip into IO.
22:06:23 <PetRat> Is there a better approach?
22:06:49 <Berengal> mapM, probably
22:07:10 <Berengal> Well, you'd still have to lift zip
22:07:30 <PetRat> So mapM combines sequence as map, it looks like.
22:08:10 <PetRat> I also had to uncurry the function that creates QPoints in order to get a tuple into it.
22:08:36 <Berengal> fmap (zip foo) (mapM (uncurry qPoint2) pairs)
22:08:44 <canvon> 07:03:08 < Berengal> I've realized another benefit of immutable variables... since you can't reuse old variable names you write shorter functions to not run out of names... <- but you can shadow the old definition with a new one with the same name, can't you?
22:09:01 <Berengal> canvon, not in the same scope
22:10:14 <PetRat> Berengal, I'm not sure I follow the essence of what is different about your code. By the way is fmap different than liftM?
22:11:10 <canvon> :t zipWithM
22:11:12 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
22:11:29 <Gracenotes> oddly I've never found the opportunity to use zipWithM
22:12:07 <Berengal> PetRat, my code's shorter, but otherwise it's the same. fmap has a specialized implementation and may be more efficient, but liftM is essentially the same anyway
22:12:16 <Berengal> I just prefer to use fmap instead of liftM
22:12:27 <Berengal> (I actually use <$> most of the time)
22:12:50 <Berengal> zip s <$> mapM (uncurry qPoint2) pairs
22:14:15 <Berengal> Perhaps I should be looking into she. I've heard rumors it has applicative braces
22:24:50 <PetRat> I revised it to use zipWithM. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9296#a9296
22:32:07 <copumpkin> :t hGetLines
22:32:09 <lambdabot> Not in scope: `hGetLines'
22:32:16 <copumpkin> @hoogle hGetLines
22:32:16 <lambdabot> No results found
23:00:17 <ivanm> what's an overall term I can use for functions, variables, constructors, etc. found in a module?
23:00:39 <ivanm> (I was just using "function", but it doesn't really cover variables and constructors properly...)
23:00:58 <ski> maybe `operation' ?
23:01:15 <ivanm> does "entity" fit?
23:01:15 <Berengal> Declarations?
23:01:33 <copumpkin> symbols?
23:02:57 <ski> (like "the stack datatype has five basic operations : `empty',`isEmpty',`top',`pull',`push'")
23:04:14 <canvon> http://www.haskell.org/onlinereport/modules.html has "It exports some of these resources, making them available to other modules. We use the term entity to refer to a value, type, or class defined in, imported into, or perhaps exported from a module."
23:04:24 <canvon> so entity seems to fit
23:04:32 <ivanm> good-o
23:04:35 <ivanm> thanks canvon
23:04:36 <canvon> :)
23:04:48 <ivanm> (actually looking something up in official sources? what a ridiculous idea! :p )
23:05:14 <canvon> heh
23:05:21 <ski> ivanm : did you want to include types and classes in the word, too ?
23:05:41 <ivanm> ski: functions in classes, yes
23:05:51 <ski> class members, ok
23:06:01 <ski> (but not classes themselves, then ?)
23:06:16 <ivanm> nope
23:06:34 <ivanm> I'm updating SourceGraph; I only care about the actual thingies that call other thingies
23:06:35 <ivanm> ;-)
23:06:58 <ski> i would go for `operation' then, i think. but `entity' would work too, i suppose
23:24:05 <PetRat> I oten find myself needing to operate on the elements in the tuple:  zip xs [0..]  i.e. I need to operate on a list element and its index. This is simple in something like Python. It's easy enough to write the zip here, but it seems inefficient.
23:24:53 <kohwj> hi
23:27:28 <ski> often you can use `zipWith' instead, so pairs need not be constructed
23:28:01 <jmcarthur> okay, i think instead of transforming base i will have to build on top of it instead :(
23:28:02 <ski>   map (uncurry f) (zip as bs) = zipWith f as bs
23:28:07 <PetRat> ski: is there anything inefficient about writing [0..] or is that about the same as a tail-recursive loop that updates an index?
23:28:29 <ski> it shouldn't be very inefficient
23:29:00 <ski> unless the implementation manages to fuse away that list, you will generate one cons cell for every index, though
23:29:04 <DeVo> hmm
23:29:06 <jmcarthur> the GHC modules rely on non-GHC modules and vice versa, which means i can't really cleanly separate them
23:29:07 <blackh> jmcarthur: I think that's the right way to do it.  Transforming it can happen once it's been tried out by lots of people. You don't want it to be difficult to install.
23:29:33 <jmcarthur> blackh: well, i was trying to build on top of it where i only use the GHC modules in base
23:29:43 <jmcarthur> blackh: but i am going to have to use the non-GHC modules as well
23:30:52 <blackh> I think that's fine.
23:30:54 <jmcarthur> for example, Data.Bits is used for FFI, and the Word/Int instances for Bits are defined in GHC.Word and GHC.Int, so that is inseparable
23:31:38 <jmcarthur> blackh: the biggest downside to this is that i can't just use a copy of base as the foundation
23:31:42 <jmcarthur> blackh: it's gonna need to be completely from scratch
23:31:43 <jmcarthur> :(
23:32:38 <ski> jmcarthur : what are you doing (or trying to do) ?
23:33:15 <jmcarthur> ski: i'm looking into making an alternative standard library
23:34:45 <jmcarthur> ski: contrary to how it may appear, i don't actually intend to replace base. that would be crazy talk. i just want to explore what it would be like without the constraints of backward compatibility
23:35:56 <jmcarthur> a proper type class heirarchy, etc.
23:36:30 <PetRat> Just out of interest, I've been learning Haskell for a few months now. My first functional language. It seemed very complex and difficult at first. Now that I'm trying to write actual applications, I'm discovering that they work much more easily than I expected.
23:36:56 <jmcarthur> and i wanted to just start with a minimally modified version of base and then evolve it
23:37:10 <jmcarthur> PetRat: :D
23:38:28 <jmcarthur> anyway, i think i have come to the conclusion that the only way to go will be to rely rather heavily on the existing libraries, just providing little adapters here and there
23:38:37 <jmcarthur> hopefully that doesn't kill too much
23:39:05 <PetRat> It seems like Haskell is true to a set of principles, so even when I jumped in qtHaskell which is undocumented except for a list of the API, I could usually figure out something just by guessing what made the most sense.
23:39:05 <jmcarthur> i think the important stuff still can work
23:39:22 <ski> jmcarthur : interesting
23:53:41 <stanv_> `[]' is constant, is it right ?
23:53:59 <quicksilver> yes
23:54:08 <quicksilver> although constant is a slightly overloaded word
23:54:14 <ivanm> heh
23:54:24 <quicksilver> all haskell values are immutable - which is one thing you might mean by 'constant'
23:54:32 <ivanm> in this case, [] is an overloaded constant (in that is has infinite possible types...)
23:54:56 <quicksilver> PetRat: that is interesting.
23:54:57 <stanv_> ok, thanks
23:55:55 <lispy|web> ?bot
23:55:55 <lispy|web> is lambdabot down?
23:56:02 <quicksilver> preflex: seen lambdabot
23:56:02 <preflex>  lambdabot was last seen on #haskell 1 hour, 23 minutes and 46 seconds ago, saying: No results found
23:56:36 <lispy|web> Cale: that's your cue to migrate to my new server :)
23:56:36 <quicksilver> @botsnack
23:56:37 <bastl> godd morning evryone
23:56:40 <bastl> *good
23:56:42 <lunabot>  :o
23:56:50 <lispy|web> bastl: excellent evening
23:57:13 * bastl doesnt get used to these globalized things on the net ...
23:57:42 <bastl> does anyone know howto deploy a glade program?
23:58:17 <lispy|web> bastl: You want an installer or you're having issue with loading your glad file or what?
23:58:18 <bastl> especially the XML-file: where should it reside when developing, src? and when deployed??
23:58:32 <bastl> i want a simple simple cabal install
23:58:36 <bastl> -simple
23:58:50 <lispy|web> hmm...I don't really know the answer
23:58:55 <lispy|web> good question though
23:59:04 <bastl> any known glade programs on hackage?
23:59:07 <quicksilver> the correct answer varies by OS
23:59:32 <quicksilver> on a unix system, your data files go in /usr/share/myapp or /usr/local/share/myapp
23:59:40 <quicksilver> on OSX your data files go *inside* the app bundle
23:59:45 <quicksilver> on windows, nobody gives a toss.
