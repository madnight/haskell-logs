00:00:01 <Veinor> @unpl putStr $ intercalate " " ( map id x)
00:00:01 <lambdabot> (putStr (intercalate " " (map (\ a -> a) x)))
00:00:07 <Veinor> @pl putStr $ intercalate " " ( map id x)
00:00:07 <lambdabot> putStr (intercalate " " x)
00:00:13 <Veinor> @pl putStr $ intercalate " " ( map id x)
00:00:13 <lambdabot> putStr (intercalate " " x)
00:00:15 <Veinor> whoops
00:00:16 <Veinor> :/
00:01:05 <Gracenotes> 380K still seems like a lot, actually :x Could fit a few Shakespeare plays in that space
00:01:36 <Veinor> and that's with -O2
00:01:40 <Veinor> ghc -O2 fizzbuzz.hs
00:01:56 <Gracenotes> but I suppose if you want less than 1K you'd use assembly :P once the runtime kicks in, GHC can get pretty fast
00:02:44 <Veinor> haha, yeah
00:03:41 <Veinor> maybe it's because it's 3 am, but I seem to have forgotten the difference between . and $
00:05:00 <Veinor> oh yeah, . is for functions
00:09:52 <Gracenotes> in a very rough inaccurate sense, ($) is function application, and (.) is function application but with an extra argument implied (composition)
00:10:26 <Gracenotes> nevermind, your explanation is better
00:11:48 <ivanm> @hoogle [a -> a] -> a -> a
00:11:49 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
00:11:49 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
00:11:49 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
00:12:35 <ivanm> > foldr1 (.) [a,b,c]
00:12:35 <lambdabot>   Couldn't match expected type `b -> b'
00:12:35 <lambdabot>         against inferred type `Simple...
00:12:42 <ivanm> grr...
00:12:49 <ivanm> > foldr1 (.) ([a,b,c] :: a -> a)
00:12:50 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
00:12:54 <ivanm> > foldr1 (.) ([a,b,c] :: [a -> a])
00:12:55 <lambdabot>   Couldn't match expected type `a -> a'
00:12:55 <lambdabot>         against inferred type `Simple...
00:13:06 <Gracenotes> f g h are special
00:13:10 <ivanm> ahhh
00:13:15 <ivanm> > foldr1 (.) ([f,g,h] :: [a -> a])
00:13:16 <lambdabot>   Could not deduce (GHC.Show.Show a, SimpleReflect.FromExpr a)
00:13:16 <lambdabot>    from the co...
00:13:22 <ivanm> grrr...
00:13:43 <ivanm> is there a function that composes a list of functions together?
00:13:57 <ivanm> @hoogle [a -> a] -> (a -> a)
00:13:57 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
00:13:58 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
00:13:58 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
00:14:29 <Gracenotes> mm, 'foldr (.) id' would about do it. (foldr1 if empty list -> error)
00:14:49 <ivanm> yeah
00:18:25 <trofi> hackagebot: help
00:22:57 <dibblego> @type mconcat
00:22:58 <lambdabot> forall a. (Monoid a) => [a] -> a
01:44:19 <Fragsworth> I can't think with so much recursion
01:44:24 <Fragsworth> I'm having trouble learning haskell
01:44:53 <mahogny> takes a while to relearn
01:45:01 <Fragsworth> relearn?
01:45:31 <mahogny> if you have been coding C for 10 years, you are essentially back to square 1 for a few days
01:45:37 <mahogny> or weeks
01:45:43 <Fragsworth> ah, yeah
01:45:56 <psykotic> heh
01:46:15 <Fragsworth> I've been reading this "Gentle Introduction" tutorial
01:46:17 <psykotic> when i taught myself scheme many years ago, i breathed recursion.
01:46:22 <Fragsworth> which so far has been far from "Gentle"
01:46:24 <psykotic> and then i went to haskell, also many years ago, and i had to unlearn.
01:46:34 <mauke> Fragsworth: oh yeah
01:46:39 <mahogny> psykotic, eh? why?
01:46:40 <psykotic> because if you're a schemer, you're used to doing a lot of manual recursion, i.e. you don't use as many combinators as in haskell.
01:46:47 <mahogny> aha
01:46:52 <mauke> @quote gentle
01:46:53 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
01:47:06 <psykotic> haha
01:47:11 <Fragsworth> Ok good so I'm not the only one
01:47:15 <mauke> preflex: ? lyah
01:47:15 <preflex>  http://learnyouahaskell.com/
01:47:28 <dibblego> psykotic, why is that so for scheme?
01:47:34 <psykotic> dibblego: you don't have to, it's just part of the style.
01:47:40 <dibblego> psykotic, ok
01:47:50 <Fragsworth> I feel like this "Gentle Introduction" is pretty rigorous though
01:47:55 <psykotic> sicp does talk about combinators
01:48:03 <mauke> preflex: ? rwh
01:48:04 <preflex>  http://book.realworldhaskell.org/read/
01:48:52 <psykotic> Fragsworth: when i was a kid, trying to master sicp, i remember my hang up was that i was still used to a fucked up mental model of recursion in terms of pushing and popping stacks.
01:49:13 <psykotic> that mental model is adequate (barely) for the extent to which c programmers use recursion
01:49:26 <psykotic> but it's completely useless if you want to think fluidly about recursion, use it to design programs, etc
01:49:42 <BleSS> if it's a created a binding to a c/c++ library, there would be any problem with the concurrency? or you can call concurrently to that library without problems
01:50:05 <mauke> depends on the library
01:50:19 <psykotic> i also remember reading the first chapter of sicp, they talk about the substitution model of evaluation, which is basically a semi-rigorous denotational semantics
01:50:56 <psykotic> and because i was so used to the 'machine' view of programming, i thought they meant some kind of impressionistic mental model, rather than something that could actually be used as an executable semantics
01:51:06 <psykotic> which meant it took me a while to get things like closures
01:51:18 <psykotic> it's way better to just think of all that stuff calculationally/equationally
01:51:22 <BleSS> mauke: so, if the c/c++ library is not ready to concurrency (manage threads) then I could not make anything from haskell
01:52:17 <mauke> BleSS: why?
01:52:28 <mauke> not all Haskell programs use threads
01:52:41 <BleSS> ya
01:56:01 <Fragsworth> http://www.haskell.org/tutorial/patterns.html - 4.4 Lazy Patterns
01:56:19 <Fragsworth> I have been sitting here for about 3 hours trying to understand this example.
01:56:36 <Fragsworth> Should I just give up and move on?
01:56:43 <mauke> probably
01:56:57 <mauke> lazy patterns aren't very common, and you can always come back to it later
01:57:55 <Fragsworth> I think I understand the lazy pattern idea. I just don't understand this example.
01:58:29 <mauke> oh god, entangled lazy streams
01:59:02 <mauke> I say move on
02:01:45 <myst> Fragsworth, 4.2. Example?
02:02:00 <myst> ah, no
02:02:03 <Fragsworth> 4.4
02:02:04 <myst> don't mind
02:02:05 <Fragsworth> The server client thing
02:04:10 <myst> aha, I don't understand either, and it isn't harm me
02:04:22 <myst> just another evil thing
02:05:07 <myst> btw, what _|_ means in their notation? a finger?
02:05:24 <mauke> (_|_) is a bottom
02:05:34 <en0th> hehe!
02:05:44 <Taejo> myst: it's called "bottom", and in Haskell code it's spelled "undefined"
02:05:45 <dibblego> Haskell calls it 'undefined'
02:05:48 <dibblego> @type undefined
02:05:49 <lambdabot> forall a. a
02:05:51 <mauke> well, ‚ä•
02:06:05 <Badger> Why does it take that... shape? :P
02:06:15 <Fragsworth> Yeah it really *looks* like a bottom
02:06:28 <en0th> with ( )
02:13:51 <Fragsworth> Why can I do (+1) 2, and get 3... but I can't do (-1) 2
02:14:03 <Fragsworth> What is different about - and +?
02:14:14 <dibblego> uh oh
02:14:28 <dibblego> Fragsworth, (+1) and (-1) have different types
02:14:46 <dibblego> Fragsworth, (-1) has the same type as 7
02:15:12 <Fragsworth> OH.
02:15:12 <dibblego> (+1) and (-) 1 have the same type
02:15:18 <Fragsworth> I see
02:15:25 <Fragsworth> So it's parsing it as an integer first
02:15:32 <dibblego> it's one of the gotchyas of the language
02:15:51 <Axman6> Fragsworth: you want the function subtract
02:15:55 <Axman6> @src subtract
02:15:55 <lambdabot> subtract x y = y - x
02:17:22 <Fragsworth> Is "=" a function? Or is it special?
02:17:30 <Axman6> special
02:17:31 <Fragsworth> I see I can't do ... (=) f 1
02:18:11 <nlogax> why isn't subtract = (-)  ?
02:18:41 <Axman6> clarity
02:19:04 <mauke> nlogax: because (-) is insane
02:19:06 <Axman6> i very much dislike pointfree notation where it doesn't make things clearer
02:19:16 <nlogax> mauke: oh no!
02:19:39 <Axman6> things like toUpperStr = map toUpper make a lot of sense
02:19:42 <nlogax> can we help him?
02:19:46 <en0th> Fragsworth: "=" is like "->" (ne1 correct me if wrong)
02:19:57 <mauke> the only reason subtract even exists is that you can't sect -
02:20:16 <nlogax> Axman6: i think it's very clear in that case, and i'm a total noob
02:24:29 <nlogax> mauke: is that because of the unary minus thing i've seen mentioned?
02:24:40 <mauke> yes
02:25:05 <Jafet> > - 1
02:25:06 <lambdabot>   -1
02:25:15 <Jafet> > `(-)` `
02:25:15 <lambdabot>   <no location info>: parse error on input ``'
02:25:17 <Jafet> > `(-)` 1
02:25:18 <lambdabot>   <no location info>: parse error on input ``'
02:25:26 <mauke> > (+ x)
02:25:27 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
02:25:27 <lambdabot>    arising from...
02:25:32 <mauke> > (+ x) 42
02:25:33 <lambdabot>   42 + x
02:25:36 <mauke> > (- x)
02:25:37 <lambdabot>   negate x
02:25:50 <Jafet> ((-)x) 42
02:25:55 <Jafet> > ((-)x) 42
02:25:55 <lambdabot>   x - 42
02:26:01 <mauke> that's not 42 - x
02:26:04 <Jafet> Indeed
02:26:18 <mauke> > (subtract x) 42
02:26:19 <lambdabot>   42 - x
02:27:25 <nlogax> but there's no reason that subtract couldn't be = (-), right? other than clarity
02:27:29 <Jafet> > (\y -> y-x) 42
02:27:30 <lambdabot>   42 - x
02:27:39 <Jafet> nlogax, what mauke said
02:29:43 <nlogax> oh.. doh
02:33:39 <en0th> Just (Left 1 Right 2)
02:34:21 <en0th> why does that give type error?
02:34:34 <mauke> because Left only takes one argument, not three
02:36:29 <ivanm> en0th: with Either, it's _either_ (Left blah) or (Right foo)
02:36:30 <ivanm> not both
02:36:33 <ivanm> @src Either
02:36:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:36:46 <mauke> data Either a b = Left a | Right b
02:36:48 <dibblego> > Just (Left 1, Right 2)
02:36:48 <lambdabot>   Just (Left 1,Right 2)
02:37:01 <mauke> data (,) a b = (,) a b
02:37:11 <ivanm> @type Just (Left 1, Right 2)
02:37:12 <lambdabot> forall t b t1 a. (Num t, Num t1) => Maybe (Either t b, Either a t1)
02:37:19 <sinelaw> @quote lambdabot
02:37:19 <lambdabot> lambdabot says: <tristes_tigres> @vixen unsafe <lambdabot> you're turning me on :)
02:37:23 <en0th> mm
02:37:59 <Fragsworth> Why do we have to use "let" in ghci's interpreter when defining functions?
02:38:11 <sinelaw> i think ghci doesn't support definitions
02:38:15 <en0th> so i must wrap two "Either"s in a tuple
02:38:31 <mauke> because ghci is basically one huge interactive do-block
02:38:54 <Fragsworth> Are other interpreters different?
02:39:01 <blackdog> Fragsworth: it's got to do with mutually recursive definitions - the semantics you want is to have forward and backwards references possible
02:39:02 <mauke> yeah, hugs doesn't even allow 'let' :-)
02:39:17 <blackdog> which isn't possible if you're going to accept or reject each one as you go
02:39:38 <ivanm> Fragsworth: IIRC, HBC (or whatever it was called) had more functionality
02:39:53 <mauke> interactive data definitions and stuff, right?
02:39:58 <ivanm> yeah
02:40:25 <ivanm> also, ghci was added to ghc later on, so they had to work out a way of grafting it on
03:06:27 <koeien> yi doesn't build for me :( anyone else having the same problem?
03:14:53 <mije> did one of you gus manage to install yi through cabal ?
03:15:55 <mije> i've this error regarding alex release complaining that alex version >= 2.8.1 and < 3 can't be found
03:16:37 <ivanm> then install alex...
03:17:08 <ehamberg> install alex through you distrobution's package manager.
03:24:45 <Saizan> or through cabal
03:25:18 <Saizan> you just have to do it explicitly because cabal-install doesn't automatically install build-tools dependencies yet
03:25:41 <Saizan> make sure you've the install location in your $PATH then
03:25:49 <Saizan> the default is ~/.cabal/bin
03:27:27 <koeien> yes, i have alex though
03:27:59 <koeien> (duplicate instance declarations of Accessor.T)
03:31:51 <Taejo> > take 3 []
03:31:51 <lambdabot>   []
04:03:57 <Fragsworth> What does it mean for a type to be an instance of a class?
04:04:22 <Fragsworth> Coming from procedural OO, this kind of phrase seems very confusing to me
04:04:56 <Raevel> it implements the functions the class specifies
04:05:08 <Raevel> it's like an interface in oo terms, but better
04:05:33 <Fragsworth> Ok, but the term "Instance" means what?
04:05:53 <Cale> Fragsworth: Means an implementation of the class methods.
04:06:19 <Cale> Or, "is an instance of" means "implements the class methods of"
04:06:31 <Fragsworth> Alright
04:06:42 <Cale> For example, Int is an instance of Ord, so things like (<) :: (Ord a) => a -> a -> Bool  work with a = Int
04:06:56 <Cale> > 3 < 4
04:06:57 <lambdabot>   True
04:07:14 <Fragsworth> So we would say "5 has type Int", "Int is an instance of Ord"
04:07:23 <Cale> yeah
04:07:56 <Fragsworth> Where in other languages they might say "5 is an instance of Int"
04:08:03 <Cale> One way of thinking of typeclasses is that they are essentially predicates on types, and then an instance is the thing which makes the predicate true for a type.
04:08:35 <Cale> Ord a is true only if there is an implementation of the comparison operations for the type a
04:08:58 <Cale> There can also be instances which depend on other instances, for example, there's an instance
04:09:07 <Cale> instance Ord a => Ord [a] where ...
04:09:20 <mauke> > [3,4] > [4,3]
04:09:21 <lambdabot>   False
04:09:33 <Cale> which means that whenever a is a type that supports ordering operations, then so is [a]
04:12:54 <Cale> If Haskell were to conflate typeclasses and types (as, say, Java does with interfaces), there would be problems with ambiguity. Consider even something simple like  sort :: (Ord a) => [a] -> [a]. If you wrote it as sort :: [Ord] -> [Ord], then that *might* mean  sort :: (Ord a, Ord b) => [a] -> [b]
04:13:25 <mauke> can I consider something simpler, like (<) instead?
04:13:31 <Cale> Sure :)
04:13:56 <Cale> Even (<) has that same problem
04:14:31 <Fragsworth> That's a bit over my head right now
04:14:37 <mauke> Fragsworth: do you know java?
04:14:37 <Fragsworth> I need to finish this tutorial first
04:14:41 <Cale> Fragsworth: okay :)
04:14:44 <Fragsworth> I'm familiar with Java
04:14:49 <Fragsworth> C++, Python more
04:14:52 <Fragsworth> PHP
04:15:06 <Fragsworth> Unfortunately
04:15:19 <Cale> :t fromIntegral
04:15:19 <lambdabot> forall a b. (Integral a, Num b) => a -> b
04:15:27 <mauke> template<typename a> bool operator<(a, a);
04:15:29 <Cale> fromIntegral is a nice example of typeclass magic :)
04:15:44 <mauke> well, except that doesn't mention Ord anywhere
04:16:23 <mauke> you can't express this in java: bool lessthan(Comparable, Comparable); would be wrong because the two Comparables could be different types
04:16:27 <Cale> fromIntegral's type says that it takes a value of any integral (integer-like) type, and produces a value of any numeric type at all
04:17:32 <Cale> (which type that is is determined by context)
04:22:58 <vegai> anyone intimate with HDBC.Sqlite3?
04:23:13 <Axman6> only if it buys me a drink
04:24:51 <ivanm> heh
04:25:03 <ivanm> @remember Axman6 <vegai> anyone intimate with HDBC.Sqlite3? <Axman6> only if it buys me a drink
04:25:03 <lambdabot> I will remember.
04:25:06 <vegai> :)
04:25:08 <vegai> http://paste.factorcode.org/paste?id=927
04:25:15 <Axman6> heh
04:25:22 <vegai> am I using withTransaction wrong, perhaps?
04:25:28 <ivanm> vegai: factor /= Haskell :p
04:25:42 <vegai> ivanm: open the %@!@@% link, please :)
04:25:55 <ivanm> I've never touched HDBC
04:25:58 <ivanm> so I can't help you
04:26:11 <ivanm> thus, why should I open the %@!@@% link?
04:26:29 <ivanm> nope, definitely doesn't make sense
04:26:39 <vegai> indeed, things are muddled now
04:47:03 <Zanity> Need codeworkers for multiboot boot loading. You must be experienced with Assembly and C++.
04:47:24 <Zanity> *Building opensource GNU OS
04:48:07 <Jafet> Nice choice of channel
04:48:40 <Zanity> Sorry, I dont give a damn.
04:48:43 <Berengal> vegai, you sure sqlite has transactions at all?
04:48:47 <Zanity> Spreading all channels.
04:49:06 <ivanm> @slap Zanity
04:49:06 <lambdabot> stop telling me what to do
04:49:46 <ivanm> Zanity: in case you can't tell, the people here are deliberately _avoiding_ Assembly and C++
04:50:47 <en0th> i am avoiding .Net :(
04:51:17 <Zanity> Too me, it seems like you keep pretty shut @ here. There's like 600 indvis @ this chnl, and for the past 10 minutes 12 lines passed over scr.
04:51:20 <Zanity> xD
04:51:27 <Alpounet> en0th, you're definitely right to do so. Cheers !
04:51:29 <ivanm> that made no sense...
04:51:30 <Berengal> I'm avoiding the logical fallacy that imperative programs makes it easier to just do stuff
04:51:53 <Zanity> Come on, is there no assemblies @ here?
04:51:58 <ivanm> no
04:52:02 <EvilTerran> Zanity, i'd prefer to look at it as a good signal-to-noise ratio in here
04:52:05 <ivanm> unless you're talking about harpy...
04:52:14 <Zanity> ivanm; you are so negative x(
04:52:16 <Zanity> xd
04:52:18 <flux> forgive me Father, for I have sinned. I used a variable in an ocaml program where a left fold would've done.
04:52:24 <ivanm> Zanity: no, you are so obtuse
04:52:31 <ivanm> flux: and we care about that why?
04:52:43 <en0th> " do you love me?" - "Nothing"
04:53:05 <ivanm> flux: I mean, it's bad enough that we have Zanity wanting us to leave FP, but then you go and bring up OCaml? Really?
04:53:13 <flux> ivanm, :)
04:53:19 <Zanity> so, what kind of language do you guys use?
04:53:28 <ivanm> Zanity: what is the channel name?
04:53:30 <jafet> Zanity, troll harder
04:53:38 <jafet> It isn't working
04:53:42 <flux> it was highly related to the current perceived mismatch between imperative and functional paradigms ;)
04:54:01 <flux> and I'm not sure if it's that great a sin that can be committed in haskell :(
04:54:04 <Alpounet> haha, I'd never seen the "Binding your input since 2005" of the Monad.Reader page
04:54:31 * ivanm still hasn't seen it...
04:54:35 <Zanity> Anyone here seen Inglourious Basterds?
04:54:37 <Zanity> omg
04:54:40 <Zanity> best movie
04:54:40 <Zanity> ever
04:54:42 <Zanity> history
04:54:47 * jafet gives flux some IORefs
04:54:56 <jafet> Zanity, try #defocus
04:55:03 <ivanm> @where ops
04:55:03 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
04:55:03 <lambdabot> mauke
04:55:05 <en0th> my university wants java. There's not a single student in my university who knows that FP even exist
04:55:15 <ivanm> en0th: except you, presumably
04:55:23 <Beelsebob> en0th: so it's a comunity college then, not a university
04:55:41 <jafet> I bet a fair number of students in that class go onto IRC channels to say that
04:55:47 <en0th> it's university of bologna :(
04:56:00 <jafet> They produce spaghetti code?
04:56:05 <ivanm> en0th: as in Bologna, Italy?
04:56:06 <en0th> lotsa
04:56:29 <en0th> yes.. they boost because it's one of the oldest one
04:56:33 <en0th> s
04:57:35 * Alpounet loves his brand new arch
04:57:42 <en0th> linux?
04:57:47 <Alpounet> yep
04:57:49 <ivanm> you have a brand new architecture?
04:57:52 <en0th> me 2!
04:57:54 <ivanm> ;-)
04:58:34 <Alpounet> ivanm, heh, It'd be annoying. I'd then ask the GHC team to add this arch to the supported ones. I don't think they'd be happy of that, am I wrong ? :-p
04:58:53 <ivanm> nah, I don't they'll be pleased
04:59:15 <en0th> i tried xmonad, love tiling wms but sadly couldn't be enough productive
04:59:38 <Alpounet> en0th, it needs time, and you also have to customize it according to your taste, habits, etc
04:59:42 <Eelis> en0th: there are other tiling wms you could try. i much prefer ion3 over xmonad.
05:00:18 * Beelsebob just dislikes tiling window managers
05:00:25 <Alpounet> e.g, I disliked many of the xmonad.hs I found here and there, 'cause it didn't fit my needs. I'm working on some customizations right now :-)
05:01:23 <en0th> yes, but how do you browse file system, or connect to wireless nets?
05:01:38 <Alpounet> ivanm, are they always pleased when we ask for new stuffs in GHC ?
05:01:43 <ivanm> Alpounet: no idea
05:01:53 <ivanm> en0th: same way you woudl with any other WM
05:02:03 <Alpounet> en0th, for the wireless, just launch nm-applet just before xmonad
05:02:11 <medfly> maybe he meant arch linux
05:02:13 <Alpounet> (put it in your ~/.xinitrc, e.g
05:02:17 <ivanm> medfly: no, really? :p
05:02:29 <Alpounet> )
05:03:12 <Alpounet> en0th, however, I think you should join #xmonad to get these few issues solved
05:03:46 <Alpounet> (and check Goerzen's tutorial on Haskellwiki)
05:03:51 <en0th> ook
05:04:38 <en0th> so i can get those things (like nm or automount) without a desktop environment
05:05:38 <Alpounet> en0th, please check Goerzen's tutorial here : http://haskell.org/haskellwiki/Xmonad/Config_archive/John_Goerzen%27s_Configuration
05:05:46 <Alpounet> you'll get many issues solved thanks to this.
05:05:49 <en0th> reading..
05:17:50 <mauke> @msg #haskell t
05:17:50 <lambdabot> Not enough privileges
05:18:19 <mauke> @msg #haskell t
05:18:19 <lambdabot> t
05:29:01 <hackagebot> repr 0.3 - Render overloaded expressions to their textual representation. (BasVanDijk)
05:51:45 <Alpounet> which kind of library can we link against with GHC ?
05:52:12 <Alpounet> e.g, can we import C++ symbols through FFI ? I guess we can't import classes, but there must be a way of getting around this, right ?
05:52:50 <mauke> C++ is theoretically possible
05:53:18 <mauke> if you treat it as C, mangle the symbols yourself, know the calling conventions, etc
05:53:47 <Alpounet> or ... ? :-p
05:54:13 <mauke> hmm?
05:57:35 <Alpounet> mauke, can't we do the following more easily : in a simple function, I instantiate C++ classes, play with them, etc. Can't I just link against this function's definition and the library it uses, and just export this function in the FFI ?
05:59:01 <mauke> that sounds like providing a C interface to a C++ library, using extern "C" functions, etc
05:59:22 <mauke> which sounds pretty easy to use from Haskell
06:00:24 <Alpounet> I guess we only have to provide an FFI for the function that manipulates C++ stuffs. And link against the C & C++ stuffs.
06:17:47 <lispy|web> Alpounet: yeah, if you provide a plain C interface to C++ code then you can use the FFI with the C interface.  Sounds like you figured it out
06:18:26 <Alpounet> the hard part is actually to provide a full-featured C interface to manipulate the C++ code, but yeah I figured it out.
06:19:28 <lispy|web> Yeah that can be hard, and remember that you may need to deal with exceptions in the C wrappers because those won't propagate across the FFI
06:19:50 <Alpounet> Or they'll end up crashing the program, heh.
06:20:05 <Alpounet> That could be fine, for some exotic definition of 'fine'.
06:22:00 <en0th> maybe wrapping the exceptions in C return values
06:25:31 <jafet> longjmp
06:32:17 <hackagebot> groupoid 0.1.0 - A Groupoid class (StephenTetley)
06:34:29 <byorgey> argh, why is the name "groupoid" overloaded?
06:35:05 <byorgey> mathematicians FAIL at naming things.
06:35:14 <en0th> haha
06:38:06 <jafet> "Zygomorphism" sounds like a reproductive disorder
06:38:44 <byorgey> haha
06:38:54 <byorgey> @remember jafet "Zygomorphism" sounds like a reproductive disorder
06:38:54 <lambdabot> Okay.
06:39:24 <en0th> omg the bot remembers
06:39:35 <_zenon_> also, perfect recall
06:40:04 <int-e> until the state becomes unreadable and is replaced by a somewhat outdated backup. (usually on the order of a couple of months ;) )
06:40:05 <mauke> @slush
06:40:21 <int-e> @karma
06:40:21 <lambdabot> You have a karma of 1
06:40:30 <int-e> wow. I still have /some/ karma.
06:40:47 <byorgey> @karma
06:40:47 <lambdabot> You have a karma of 17
06:41:01 <byorgey> wow!
06:41:06 <int-e> @karma dons
06:41:06 <lambdabot> dons has a karma of 10
06:41:11 <int-e> @karma-top
06:41:12 <lambdabot> Unknown command, try @list
06:41:27 <byorgey> part of the problem is that no one gives karma anymore. =(
06:41:35 <mauke> preflex: karma int-e
06:41:35 <preflex>  int-e has no karma
06:41:37 <byorgey> it's fallen out of #haskell culture.
06:41:43 <mauke> preflex: karma dons
06:41:43 <preflex>  dons: 5
06:41:44 <int-e> @karma-all
06:41:45 <lambdabot>  "moritz"              686
06:41:45 <lambdabot>  "pmichaud"            469
06:41:45 <lambdabot>  "jnthn"               366
06:41:45 <lambdabot>  "lwall"               357
06:41:45 <lambdabot>  "pmurias"             328
06:41:47 <lambdabot> [1476 @more lines]
06:41:54 <int-e> (pugs people)
06:42:02 <mauke> preflex: karmatop
06:42:05 <preflex>  c: 39888; g: 2222; ##c: 1968; c/c: 950; vc: 838; bacek: 744; #c: 691; notepad: 666; coke: 567; whiteknight: 474
06:42:12 <byorgey> yeah, why on earth is it that people got karma for making pugs commits?
06:42:33 <jafet> Now we know what sort of company preflex keeps.
06:42:47 <int-e> c++!
06:42:55 <ski> `c/c' :)
06:42:56 <jafet> I was thinking the coke bit
06:43:00 <int-e> @karma vc
06:43:00 <lambdabot> vc has a karma of 13
06:43:04 <Alpounet> booh
06:43:12 <int-e> vc-- :)
06:43:18 <mije> @karma police
06:43:18 <lambdabot> police has a karma of 0
06:43:24 <mije> (just kidding)
06:43:25 <en0th> lmao
06:43:30 <ziman> @karma lambdabot
06:43:30 <lambdabot> lambdabot has a karma of 44
06:43:45 <en0th> how do you gain karma
06:43:52 <mauke> preflex: karma
06:43:52 <preflex>  mauke: 124
06:44:02 <mauke> en0th++  # like this
06:44:51 <en0th> ok that's why c leads
06:45:16 <int-e> lambdabot has a small blacklist, including c.
06:45:30 <mauke> yes, that's why c++ was invented: to increase the value of c
06:45:58 <mauke> (you'll note that "c++" has the old value of c; it's not "one better than c")
06:46:20 <ziman> i'd say C++ does not change the value of C
06:46:21 <jafet> > c++
06:46:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:46:35 <ziman> ah, i see, it's weird
06:46:53 <jafet> > (c++) where c = ""
06:46:54 <lambdabot>   <no location info>: parse error on input `where'
06:47:10 <jafet> > let C = "" in (C++)
06:47:11 <lambdabot>   Not in scope: data constructor `C'Not in scope: data constructor `C'
06:47:26 <burp> lol
06:48:06 <int-e> http://www.phy.duke.edu/~rgb/Beowulf/c++_interview/c++_interview.html
06:48:38 <jafet> That popular joke interview does no justice to the actual horrors of C++, I can assure you
06:49:06 <int-e> @quote C++
06:49:06 <lambdabot> osfameron says: <ivanm> @localtime popcorn <osfameron> every time is popcorn time
06:49:30 <mauke> @quote C\+\+
06:49:31 <lambdabot> dons says: C++: creating blub programmers since 1985
06:49:43 <jafet> blub++
06:50:34 <int-e> @quote qwe1234
06:50:34 <lambdabot> qwe1234 says: haskell type classes smell like c++ concepts.
06:50:40 <int-e> @quote qwe1234
06:50:40 <lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
06:50:50 <int-e> @quote qwe1234
06:50:50 <lambdabot> qwe1234 says: common lisp reminds me of fortran and cobol, all three are about as much fun to program in.
06:52:03 <_zenon_> Who is qwe1234 +
06:52:04 <_zenon_> ?
06:52:26 <int-e> @quote high.level
06:52:26 <lambdabot> int-e says: C++ does make a reasonably usable high-level assembler
06:52:43 * int-e can't believe that's the only use of high-level in the quotes.
06:53:02 <jafet> @quote low.level
06:53:02 <lambdabot> No quotes match. The more you drive -- the dumber you get.
06:54:19 --- mode: ChanServ set +o mauke
06:54:19 --- mode: mauke set -bbbb *!n=plinka@* *!*@p549C720F.dip.t-dialin.net Yaquishael!*@* *!*@m18s10.vlinux.de
06:54:23 --- mode: mauke set -b *!*@201.171.60.178.dsl.dyn.telnor.net
06:54:28 <olsner> int-e: I guess "high-level" is pretty much implied from #haskell :P
06:54:40 --- mode: mauke set +b *!n=g@*
06:55:30 <int-e> @quote milli.oleg
06:55:30 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
06:55:39 --- mode: mauke set -o mauke
06:55:58 <olsner> hmm, so if I accidentally set my ident username to 'g' (whyever I would do that), I will now be banned from #haskell?
06:56:00 <jafet> @quote Oleg
06:56:00 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
06:56:01 <fxr> hahah that one is great
06:56:02 <int-e> olsner: that's a sort of synonym :)
06:57:42 <mauke> olsner: yes
06:57:55 <Alpounet> this quote is great
06:59:25 <hackagebot> List 0.2 - List monad transformer and class (YairChuchem)
06:59:27 <hackagebot> generator 0.5.3 - Python-generators notation for creation of monadic lists (YairChuchem)
06:59:29 <hackagebot> ListTree 0.1 - Combinatoric search using ListT (YairChuchem)
07:00:52 <yaru1022> hi
07:01:12 <yaru1022> I have a question... how can I express fmap in terms of return and >>= only?
07:01:27 <benmachine> fmap f m = m >>= return . f
07:01:29 <yaru1022> I thought about it for like 30 minutes... but I can't come up with an answer. ;
07:01:32 <mauke> trivial, my dear watson
07:01:39 <yaru1022> wow ;;
07:01:47 * benmachine wonders if this is the sort of question you are supposed to let people work out themselves
07:01:50 <yaru1022> benmachine, that was quick!
07:01:52 <benmachine> oh well too late :x
07:01:56 <benmachine> yaru1022: from memory
07:01:56 <Axman6> yaru1022: it's all in the types
07:02:09 <benmachine> Axman6 is right
07:02:37 <yaru1022> Axman6: although it's all in the types, I found it extremely difficult to come up with an answer... hm;
07:02:50 <Axman6> :t (>>=)
07:02:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:02:53 <benmachine> m a -> (a -> m b) -> m b and you want (a -> b) -> m a -> m b
07:02:56 <Axman6> :t return
07:02:57 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
07:02:59 <Twey> fmap = flip (>>=) . (return .)
07:03:12 <Axman6> :t return . (f :: a -> b)
07:03:13 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
07:03:13 <lambdabot>       from the context ()
07:03:13 <lambdabot>       arising from a use of `f' at <interactive>:1:10
07:03:16 <Twey> Well‚Ä¶ technically you can't
07:03:19 <Axman6> -_-
07:03:27 <Twey> Since return and >>= are for monads, and fmap is for Applicatives
07:03:36 <Axman6> :t return . f
07:03:36 <lambdabot> forall b (m :: * -> *) a. (Monad m, Show a, SimpleReflect.FromExpr b) => a -> m b
07:03:39 <Twey> Er, just Functors, even
07:03:41 <Twey> :t fmap
07:03:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:03:44 <ziman> @djinn (a -> b) -> (f a -> f b)
07:03:44 <lambdabot> -- f cannot be realized.
07:03:51 <ziman> @djinn Functor f => (a -> b) -> (f a -> f b)
07:03:51 <lambdabot> Error: Class not found: Functor
07:04:00 <ziman> @djinn MOnad f => (a -> b) -> (f a -> f b)
07:04:00 <lambdabot> Error: Class not found: MOnad
07:04:01 <olsner> ziman: I think djinn doesn't do typeclasses
07:04:10 <benmachine> :t \f -> return . f
07:04:10 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
07:04:13 <ziman> ah, i forgot
07:04:38 <olsner> :t return . ?f
07:04:39 <lambdabot> forall b (m :: * -> *) a. (Monad m, ?f::a -> b) => a -> m b
07:04:54 <byorgey> Twey: that is just an unfortunate aberration in Haskell's standard libraries.  all monads are functors.
07:05:04 <Twey> byorgey: Sure, sure, but not all functors are monads.
07:05:28 <byorgey> of course not.  But if you have return and >>= then you certainly have fmap.
07:05:45 <byorgey> even though the Haskell type won't be quite right, it is still mathematically correct.
07:06:09 <Twey> But having fmap does not guarantee that you have return and >>=, so it's not safe to write fmap with return and >>= for all cases.
07:08:39 <maltem> newtype TheMonadOfThisFunctor f a = Wrap (f a); instance Functor f => Monad (TheMonadOfThisFunctor f) where fmap g x = x >>= return . g
07:08:51 <olsner> >>= can be written in terms of fmap and join though ... but what's the minimum extension of Functor to make Monad? return+join?
07:08:53 <maltem> er... up to unwrapping
07:09:39 <olsner> return is in Applicative though, so maybe monad should just be Applicative+join?
07:10:06 <benmachine> join can be defined in terms of >>=
07:10:07 <fxr> I advise you to read typeclassopedia article
07:10:10 <maltem> olsner, when you have return, you can add either (>>=) or join
07:10:14 <benmachine> >>= can be defined in terms of join and fmap
07:12:17 <fxr> which is located in http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
07:12:28 <int-e> @type join . fmap
07:12:29 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
07:12:29 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
07:12:29 <lambdabot>     In the second argument of `(.)', namely `fmap'
07:12:43 <olsner> @type (.:)
07:12:44 <lambdabot> Not in scope: `.:'
07:13:19 <olsner> @type fmap fmap fmap join fmap
07:13:20 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
07:13:23 <int-e> @type (join .) . fmap
07:13:24 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
07:22:07 <coco> @pf \x -> g x . f
07:22:07 <lambdabot> Maybe you meant: bf pl
07:22:18 <coco> @pl \x -> g x . f
07:22:19 <lambdabot> (. f) . g
07:22:44 <kamatsu> go lambdabot
07:23:10 <coco> is there a better idiom for composing functions in the second argument?
07:23:23 <coco> g : a -> b -> c
07:23:28 <coco> f : b' -> b
07:23:31 <coco> ::, I mean
07:25:14 <fxr> (flip g . f) b' a
07:25:35 <fxr> = c I guess
07:26:13 <coco> that would be flip (flip g . f)
07:26:25 <fxr> whatever
07:26:38 <coco> whateva'
07:26:54 <fxr> :)
07:34:55 <EnglishGent> hello :)
07:35:42 <fxr> EnglishGent: welcome
07:36:31 <EnglishGent> ty fxr :)
07:38:09 <EnglishGent> @hoogle Codec.Utils.Octect
07:38:09 <lambdabot> No results found
07:40:20 <v0|d> fxr: re
07:40:35 <fxr> v0|d: :) sup?
07:40:45 <v0|d> fxr: fine
07:40:49 <coco> @pl \x y -> g (f x) (f y)
07:40:49 <lambdabot> (. f) . g . f
07:42:21 <coco> @pl \f x -> g x . f
07:42:21 <lambdabot> flip ((.) . g)
07:43:23 <coco> @pl \f -> (. g) . (f `on` h)
07:43:23 <lambdabot> ((. g) .) . (`on` h)
07:43:59 <EnglishGent> @hoogle [Octet]
07:43:59 <lambdabot> Warning: Unknown type Octet
07:43:59 <lambdabot> Prelude repeat :: a -> [a]
07:43:59 <lambdabot> Data.List repeat :: a -> [a]
07:44:15 <coco> @pl \f -> (. g) . (\x y -> f (h x) (h y))
07:44:15 <lambdabot> ((. g) .) . flip flip h . ((.) .) . (. h)
07:44:40 <EnglishGent> @hoogle [Codec.Utils.Octet]
07:44:40 <lambdabot> Parse error:
07:44:40 <lambdabot>   --count=20 [Codec.Utils.Octet]
07:44:40 <lambdabot>                    ^
07:44:49 <EnglishGent> @hoogle Codec.Utils.Octet
07:44:49 <lambdabot> No results found
07:46:41 <EnglishGent> @hoogle Char -> Int
07:46:41 <lambdabot> Data.Char digitToInt :: Char -> Int
07:46:41 <lambdabot> Data.Char ord :: Char -> Int
07:46:41 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
07:46:42 <Axman6> EnglishGent: try hayoo
07:46:58 <EnglishGent> thanks Axman6
07:47:03 <EnglishGent> same syntax?
07:47:13 <Axman6> possibly
07:47:59 <EnglishGent> @hayoo [Codec.Utils.Octet]
07:47:59 <lambdabot> Unknown command, try @list
07:48:06 <EnglishGent> @list
07:48:06 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:48:21 <lispy|web> ?go hayoo
07:48:21 <lambdabot> Maybe you meant: google googleit do
07:48:39 <lispy|web> ?google hayoo
07:48:39 <lambdabot> No Result Found.
07:50:53 <fxr> http://holumbus.fh-wedel.de/hayoo/hayoo.html
07:51:11 <Axman6> @where hayoo
07:51:11 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
07:52:19 <fxr> Axman6: thanks
08:05:41 <Unregistered> .net
08:07:59 <Crito> yeah. wtf was that?
08:08:23 <Alpounet> a Microsoft bot.
08:08:28 <fxr> it is capitalism
08:08:35 <azm> lol
08:12:18 <Berengal> Every time I drop into do-notation, my programs lose their succinctness
08:12:22 <Berengal> Unless it's the list monad...
08:12:36 <Berengal> I think there may be something profound here
08:13:34 <fxr> which could be abstraction.
08:13:34 <Berengal> Monads make for bad combinators in most cases
08:15:05 <Peaker> Berengal, do notation makes for bad combinators doesn't mean monads make for bad combinators
08:15:16 <Peaker> Berengal, (higher-order combinators like sequence/filterM/etc are nice)
08:16:31 <Axman6> Berengal: succinctness /= clarity
08:16:40 <Berengal> Peaker, that too is dependent on which monad. I usually find lots of uses for them, but this last week I've lived in a parser, and have had exactly one use for sequence
08:17:23 <Berengal> Axman6, ¨(succinctness -> clarity), but verbosity -> ¨clarity
08:17:42 <Axman6> indeed
08:17:46 <Crito> fxr: more precisely, trolltalitarianism
08:18:25 <byorgey> Berengal: this may be related to the fact that do-notation forces you to give names to intermediate values.
08:18:29 <Berengal> Axman6, so in a sense, clarity -> succinctness
08:18:43 <Berengal> byorgey, that's true
08:18:45 <byorgey> using an applicative/point-free style can often be much more succinct and clear, when it works.
08:18:50 <Axman6> i disagree, to a point
08:19:14 <Berengal> Axman6, working in fuzzy logic, not boolean, of course...
08:19:16 <byorgey> and by "when it works" I mean "doesn't require lots of uses of the S combinator to duplicate intermediate values"
08:19:51 <Berengal> byorgey, applicative parsers look like BNF with return values...
08:20:00 <Berengal> I'm very happy about that
08:20:59 <byorgey> indeed.
08:21:29 <Berengal> Often the spurious S combinator can be eliminated by admitting newlines exist, and using several fmaps
08:23:04 <byorgey> I don't follow...
08:24:39 <Berengal> not sure I do myself. I'm still thinking in polyparse...
08:25:26 <bla> Hi...
08:27:44 <Axman6> 'lo bla
08:29:20 <bla> I thought I'd have to ask very ashaming question, but I managed to figure it out. ;-)
08:29:27 <Alpounet> do *.wordpress.com blogs have some additional protections against spam ?
08:30:31 <p_l> Alpounet: yes, there is a spam filter on comments. Pity there isn't one on blog owners...
08:31:22 <Alpounet> p_l, currently I have 6000+ spam comments, so I'm considering switching to a *.wordpress.com blog if there are such protections...
08:31:42 <p_l> Alpounet: I'm not sure how well it works (it was called Akismet, iirc?)
08:32:38 <Alpounet> and this is installed by default ?
08:32:57 <p_l> Alpounet: yes
08:33:04 <Alpounet> ok
08:33:07 <Alpounet> interesting
08:33:15 <p_l> I didn't have much spam, but my blog wasn't interesting at all :P
08:33:27 <Alpounet> and there is a haskell coloration by default too ? :-)
08:33:46 <p_l> Alpounet: there's coloring for languages, but I doubt it includes Haskell
08:34:02 <Alpounet> ok
08:34:11 <Alpounet> I'll check this out on their site, thanks
08:51:02 <dons> @tell bos this kind of graph would be perfect for the scaling measurements, http://nothings.org/computer/judy/build_semilog.gif
08:51:02 <lambdabot> Consider it noted.
08:52:42 <Axman6> needs moar AA >_>
08:53:37 <Axman6> but that's exactly the kind of graph i want to produce from the code i've been writing
08:55:13 <Axman6> i'd like some concrete way to tell which one of my haskell implementations of this discrete cosine transform is fastest, since i have three, and they're all about the same speed (and 1.6x C)
08:55:50 <mercury^> 1.6x the speed of fftw?
08:55:53 <mercury^> Not bad.
08:55:58 <Axman6> ha, no
08:56:18 <Axman6> the naive C implementation
08:57:38 <mercury^> dons: I noticed that in your papers you often point out how "character io c" is slow. I think that is because the library you use defaults to posix semantics for getchar and putchar, causing a lot of overhead.
08:57:45 <Axman6> i find it very annoying that i managed to make the C version parallelise very easily on snow leopard using grand central dispatch, while the haskell one refuses to run in parallel (that could be a result of how i'm testing it though, since i'm forcing the whole list)
08:59:14 <dons> mercury^: indeed. well, at least, locking per character
08:59:44 <dons> Axman6: have you asked anyone to help with the parallelisation?
09:00:07 <dons> also, have you tried ghc head, to rule out spark-related heuristic cut off
09:00:19 <mercury^> dons: might give the wrong impression to some people. getchar/putchar can be very fast if the library handles them well (and allow for a nice style often).
09:00:23 <Axman6> not really. it's been pretty basic parallelisation, using parMap, and my own version of it (both produce basically the same speed)
09:00:46 <Axman6> dons: yeah i'm planning to, waiting for the RC, but i might give HEAD a try tomorrow
09:02:51 <Axman6> dons: would you perhaps like to take a look?
09:03:34 <HairyDude> is there a way to tell ghci to not clutter the prompt with the list of imported modules?
09:03:53 <mauke> :set prompt "*> "
09:03:58 <HairyDude> thanks
09:03:58 <dons> mercury^: right, I had one conversation with an old C hacker about this, who complained the GNU guys screwed it all up
09:04:02 <Axman6> i have a strong feeling that the real problem is that i'm using something like print . last . (\xs -> rnf xs `seq` xs) . dctivFuncs n $ xs to test my code
09:04:17 <dons> Axman6: just put it up somewhere and ask for help.
09:04:31 <HairyDude> unrecognised flags: propmt *>
09:04:32 <dons> there's lots of people here with parMap experience :)
09:05:06 <mauke> HairyDude: you fail at copy/paste
09:05:18 * SamB_XP ponders starting a Books for Geeks list on Amazon ...
09:05:26 <HairyDude> dppj
09:05:29 <HairyDude> doh even
09:05:34 <HairyDude> I fail at typing too
09:05:55 * SamB_XP can only think of two books so far, though: K&R, and To Say Nothing of the Dog
09:05:59 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9897#a9897 <- lovely non-parallelising code
09:06:43 <Axman6> SamB_XP: Dragon book?
09:06:44 <dons> pmap f (x:xs) = x' `par` xs' `par` (x':xs') looks wrong
09:06:55 <dons> should be `par` xs' `pseq` x ... ?
09:07:08 <Axman6> well either way, parMap runs sequencially too
09:07:22 <dons> on mac os x ?
09:07:23 <Axman6> yeah i tried that. i had some reason for changing it, but i can't remember what at the moment
09:07:26 <SamB_XP> Axman6: I was only planning to put on the list books that I'd actually *read*
09:07:29 <Axman6> yeah
09:07:34 <dons> does the helloworld par program work for you?
09:07:51 <dons> i've never had trouble with parMap
09:07:58 <Axman6> no idea, where might i find it?
09:08:10 <dons> http://haskell.org/haskellwiki/Haskell_in_5_steps#Write_your_first_parallel_Haskell_program
09:08:30 <HairyDude> bah, it doesn't support ANSI colour sequences
09:09:36 <HairyDude> correction: it doesn't support \e meaning escape
09:10:05 <mauke> it doesn't support \ESC either
09:10:24 <mauke> it does support literal control characters, though :-)
09:10:33 <HairyDude> as I just figured out :)
09:11:58 <HairyDude> unfortunately readline (or whatever ghci uses) doesn't seem to understand that the escape sequence isn't printable
09:12:21 <mauke> how so?
09:13:22 <Axman6> dons: yeah that program parallelises nicely
09:13:23 <HairyDude> if you go up then down in the history it starts the line some distance to the right of where it should be
09:14:03 <SimonRC> HairyDude: bash has a syntax to alert readline to zero-width control chars in prompts
09:14:04 <mauke> works here
09:14:16 <SimonRC> bash uses \[ \] to enclose them
09:14:23 <HairyDude> SimonRC: yeah, ghci either doesn't or does it differently
09:14:33 <mauke> HairyDude: which version of ghci are you using?
09:14:37 <SimonRC> but I don't know if that is general readline feature or bash-specific
09:14:40 <dons> Axman6: ok. good to know. then write your program with a top level parMap and ask on the -cafe@ if it isn't parallelising
09:14:53 <Makoryu> dons: I just tried that program and it segfaulted :|
09:15:01 <Axman6> Makoryu: :|
09:15:13 <HairyDude> 6.8.2
09:15:46 <dons> Makoryu: you need 6.10.x
09:15:54 <dons> grab the haskell platform. haskell.org/platform
09:16:01 <Makoryu> dons: I'm running 6.10.4, man
09:16:16 <Axman6> how odd
09:16:28 <Makoryu> Under Snow Leopard, though
09:16:42 <Axman6> i'm using SL too, but with 6.10.3
09:16:44 <Makoryu> Maybe I set up the whatchamacallit wrong
09:16:45 <dons> Makoryu: bug report then.
09:16:46 <Axman6> compiled on leopard
09:17:52 <Makoryu> Yeah, I installed this under Leopard and then upgraded
09:25:20 <HairyDude> mauke: what version do you have where it works then?
09:25:46 <mauke> HairyDude: 6.10.2 patched to use libreadline
09:25:58 <HairyDude> ah, right
09:26:14 <HairyDude> distro lag is annoying sometimes :)
09:26:28 <mauke> compile your own :-)
09:26:39 <en0th> @type foldl
09:26:40 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:26:55 <Makoryu> HairyDude: Recent versions of GHC will use Haskeline for the prompt, not readline
09:27:45 <HairyDude> Makoryu: does haskeline have something like bash's \[?
09:27:56 <Axman6> dons: i'm watching the "The future of Haskell" discussion video on vimeo, and you did a great job of looking rather bored :P
09:28:08 <HairyDude> not that it's particularly important, I just happen to like my prompt highlighted in green
09:28:13 <Makoryu> HairyDude: No idea. Check it out: http://hackage.haskell.org/package/haskeline
09:30:24 <HairyDude> the trac wiki doesn't mention anything about prompts.
09:30:31 <HairyDude> oh well, I'll just see when I get there
09:31:25 <chrisdone> > 1
09:31:26 <lambdabot>   1
09:31:38 <chrisdone> does lambdabot use mueval?
09:31:49 <Makoryu> > 1 :: Expr
09:31:50 <lambdabot>   1
09:32:01 <Makoryu> > (\f -> x y) :: Expr
09:32:02 <lambdabot>   The lambda expression `\ f -> SimpleReflect.x SimpleReflect.y'
09:32:02 <lambdabot>  has one arg...
09:32:45 <chrisdone> it's really slow ~_ ~
09:32:56 <chrisdone> chris@chrisamilo:~$ time mueval -e 6 \n 6 \n real 0m0.354s
09:33:10 <periodic> Odd question, how does one remove a package with cabal?  I'm not seeing it as an option in the help info
09:33:23 <fxr> periodic: ghc-pkg unregister ...
09:33:32 <chrisdone> periodic: it doesn't support it IIRC. you have to just unregister it and delete it manually
09:33:34 <fxr> periodic: and then remove files
09:33:42 <periodic> oh, exciting.
09:33:50 <chrisdone> yeah, enterprise quality
09:33:50 <periodic> I'm having issues installing happy, was going to try to do it myself.
09:34:04 <periodic> it SAYS it successfully installed, but then it doesn't have it listed for dependency checking.
09:34:14 <periodic> And thank you, both.
09:35:12 <Makoryu> chrisdone: No exceptions?
09:35:56 <chrisdone> Makoryu: it consistently takes 350~ ms to evaluate '1'
09:36:39 <chrisdone> that's on an intel core 2 2.5GHz quad, and it takes 600ms on a P4
09:36:56 <chrisdone> is it due to setting all these preventative measures like rlimits and watchdogs?
09:37:17 <en0th> no input/output involved?
09:37:35 <Axman6> >1
09:37:39 <SamB_XP> chrisdone: maybe context switch is a bit higher on that thing ?
09:37:40 <Axman6> > 1
09:37:40 <chrisdone> well, it prints to the terminal
09:37:40 <SamB_XP> > 1
09:37:40 <lambdabot>   1
09:37:41 <lambdabot>   1
09:38:04 <SamB_XP> or are you using criterion?
09:38:08 <chrisdone> yeah lambdabutts seems responsive
09:38:12 <chrisdone> SamB_XP: what is that?
09:38:15 <Axman6> chrisdone: i'd say it has a lot more to do with the internet...
09:38:21 <SamB_XP> bos' crazy new library
09:38:24 <chrisdone> Axman6: no, I'm running it locally
09:38:28 <Axman6> oh
09:38:52 <Axman6> SamB_XP: it hasn't been released yet has it?
09:39:06 <SamB_XP> Axman6: I think dons was using it yesterday ...
09:39:09 <chrisdone> oh nice I see it on hackage
09:39:40 <Axman6> oh hoorah
09:40:16 <Axman6> argh! requires gtk!
09:40:19 <SamB_XP> heh
09:40:20 <Axman6> FFFFFFFUUUUUUUUUUUU!
09:40:30 <copumpkin> Axman6: I feel the same way :P
09:40:32 <SamB_XP> bos: why does criterion need gtk ???
09:40:35 <fxr> chrisdone: time ghc -e '1'
09:40:39 <fxr> chrisdone: which is better?
09:40:42 <copumpkin> SamB_XP: I think it's cause of the charts library
09:40:47 <SamB_XP> oh
09:40:47 <chrisdone> fxr: 0m0.245s
09:40:48 <copumpkin> which uses cairo
09:40:56 <chrisdone> fxr: (averages that)
09:40:56 <Makoryu> Axman6: Just switch to Linux!!! :D
09:40:58 <Axman6> >_<
09:41:09 <Axman6> Makoryu: get stuffed
09:41:19 <FunctorSalad_> yes gtk works fine on linux
09:41:21 <FunctorSalad_> ;)
09:41:24 <chrisdone> haskellers using windows, hehe =)
09:41:28 <Axman6> i'v e spent more than enough time screwing around with linux
09:41:30 <Makoryu> Axman6: Face it dude, OS X is a niche OS and we both know it. As Haskell programmers we might as well be using Haiku
09:41:31 <SamB_XP> isn't it possible to get cairo installed without gtk itself?
09:41:44 <SamB_XP> I realize you would still need to use the gtk2hs sources to get that, but ...
09:42:06 <SamB_XP> Makoryu: hmm -- there are Haiku binaries for GHC?
09:42:20 <SamB_XP> or, should I just say BeOS
09:42:41 <Makoryu> SamB_XP: Nah, it probably wouldn't compile
09:42:50 <SamB_XP> Makoryu: why's that?
09:42:51 <chrisdone> fxr: oddly it's not like it uses more than 20% CPU when doing it
09:43:03 <Makoryu> SamB_XP: Mind you, OS X support is pretty broken right now anyway, which is part of my point ;)
09:43:10 <dons> Axman6: oh, i wasn't bored. i was trying to concentrate.
09:43:12 <SamB_XP> I thought BeOS had most posix ...
09:43:19 <dons> tommd: on my way over now.
09:43:24 <chrisdone> fxr: I'm fiddling with some smidgen http://anonnode.net/haskell/ to maybe do some kind of itnerwactive haskell tutorial, but it's slowww
09:43:30 <SamB_XP> Makoryu: but that's only because Apple changed everything unexpectedly, from GHC's POV
09:43:30 <tommd> dons: Sounds good
09:43:34 <tommd> see you soon
09:43:43 <SamB_XP> Makoryu: isn't it?
09:44:28 <SamB_XP> and there are reversed-arrow pumpkins working on the issue, aren't there ?
09:44:32 <Makoryu> SamB_XP: It does, but it's not particularly great POSIX support, and the GCC versions supported by Haiku don't (to my knowledge) work for compiling Haiku
09:44:32 <SamB_XP> that is to say, copumpkins ...
09:44:47 <SamB_XP> Makoryu: wow
09:44:48 <fxr> chrisdone: I think it'll evaluate faster when you use mueval as a library.
09:44:58 <chrisdone> orly
09:45:03 <Makoryu> s/compiling Haiku/compiling GHC/
09:45:04 * chrisdone twiddles moustache
09:45:13 <SamB_XP> Makoryu: ah, that makes a bit more sense ;-)
09:45:24 <copumpkin> SamB_XP: I haven't worked on it recently, but someone else did in the mean time
09:45:31 <SamB_XP> why doesn't it support recent GCC ?
09:45:34 <chrisdone> fxr: let me try it
09:45:39 <SamB_XP> copumpkin: ah
09:46:00 <SamB_XP> where is the arrow in a pumpkin, anyway?
09:46:32 <Makoryu> SamB_XP: As for OS X... 64-bit support has been missing for a long time, and it's been known for a long time that Snow Leopard would be 64-bit just-about-everything
09:46:58 * SamB_XP wonders what these "mashups" are that dilbert.com apparantly supports/has ...
09:47:35 <SamB_XP> Makoryu: yeah, well, procrastination is pretty popular 'round here
09:47:36 <SamB_XP> I guess
09:48:19 <Makoryu> SamB_XP: The old-GCC-version thing in Haiku is due to the goal of binary compatibility with BeOS
09:49:31 <Makoryu> They had to write a compatibility layer for GCC4-compatible libraries so Firefox et al would work
09:49:49 <chrisdone> I was rate impressed with haiku on the video presentation that they did but is it Ready For Deskop and Business Needs?
09:49:56 <Makoryu> I dunno what the GCC4 support is like, exactly, though
09:50:06 <Axman6> chrisdone: well, no
09:50:10 <Makoryu> chrisdone: Nope
09:50:10 <SamB_XP> Makoryu: oh ... does BeOS use C++ ABIs a lot?
09:50:11 <Axman6> chrisdone: is linux?
09:50:24 <Makoryu> SamB_XP: Yeah. The whole API is in Sepples :(
09:50:33 <SamB_XP> okay. that could be an issue.
09:50:41 <Axman6> sepples?
09:50:47 <SamB_XP> but can't it support newer GCC's for C ?
09:50:51 <chrisdone> Axman6: yeah I've been using linux on the desktop for years
09:51:01 <Axman6> it's not ready for it though
09:51:13 <chrisdone> by what criteria?
09:51:13 <Peaker> BeOS sounded horribly designed to me
09:51:28 <Axman6> i'm a geek, and i find linux hard to use as a desktop
09:51:54 <chrisdone> plays music and video in a more manageable way than windows thanks to pulseaudio, no vriuses, a window manager (GNOME) that supports simple PROGRESSIONS like an always-on-top button and workspaces
09:52:00 <SamB_XP> what's this "desktop" thing?
09:52:14 <SamB_XP> oh ... you mean that mess behind all of these windows ???
09:52:14 <Peaker> chrisdone, using threads and mutable state as a concurrency model (when parallelism wasn't even a concern)
09:52:18 * Axman6 attempts to get gtk2hs installed so he can use criterion
09:52:20 <Makoryu> chrisdone: Anyway, my only point in bringing up Haiku is that (from a Haskell standpoint) OS X is just as not-ready-for-primetime as Haiku is
09:52:22 <Peaker> chrisdone, Mixing this with C++ ABI's, etc
09:52:30 <SamB_XP> Makoryu: not really
09:53:03 <chrisdone> Peaker: sorry what's that in reference to?
09:53:25 <Peaker> chrisdone, BeOS horribly designed
09:53:54 <chrisdone> oh right.. I didn't mention BeOS?
09:54:18 <SamB_XP> Makoryu: we can at least compile for it, as long as we either get GHC to be specific about bitness or (put wrappers in PATH or hack GCC et al to default to 32-bit again)
09:54:28 <SamB_XP> Makoryu: no?
09:54:53 <Peaker> chrisdone, I thought you asked me why I said BeOS sounded horribly designed
09:54:59 <chrisdone> Peaker: ohhh. you said "BeOS sounded horribly designed", I was talking to Axman's "it's not ready for it". hehe
09:55:02 <Axman6> hmmm... hsc2hs doesn't like block syntax, even if it's an in ifdef'd section it probably shouldn't see
09:55:04 <fxr> I never used OS X what it provides?
09:55:05 <SamB_XP> but I seriously do think that it shouldn't be a problem to compile C code using the latest GCC on Haiku
09:55:27 <Axman6> fxr: simplicity, stability, best of the windows and unix worlds
09:55:52 <chrisdone> I got os x recently for that syncreticism
09:55:55 <SamB_XP> Apple hardware lockin, if you use it legally ;-)
09:56:02 <SamB_XP> chrisdone: for what ???
09:56:19 <chrisdone> I can't access my linux SSH server with it as a folder ;_;
09:56:22 <Axman6> SamB_XP: locking like a 5 star hotel as a prison ;)
09:56:31 <Axman6> lockin*
09:56:34 <chrisdone> had to get some proprietary crap that trialed and ran out. ended up using commandline scp
09:56:45 <maltem> If OS X only had *some* package management system... I'd love it so much
09:56:58 <SamB_XP> Axman6: I'm not saying that there's anything wrong with Apple hardware, besides the pricetag
09:56:59 <Axman6> it does
09:57:11 <Axman6> macports, and fink, and there's a new one called homebrew
09:57:19 <fxr> hmm, what is complex in linux for example?
09:57:25 <chrisdone> SamB_XP: mostly so I could do Desktop things like talk to my friends on Skype and record a video, edit it and submit it to YouTube or cam with my friends
09:57:29 <Axman6> installing software
09:57:34 <SamB_XP> if there was a 5 star hotel being used as a prison, would you still have to pay to go there?
09:57:35 <Axman6> configureing _anything_
09:57:41 <maltem> Axman6, those are not integrated with Apple-shipped software
09:57:58 <SamB_XP> and would they block your 'net?
09:58:03 <Axman6> maltem: so? most OS X users don't have any need for it
09:58:19 <Axman6> SamB_XP: of course  not, you'd have free wifi ;)
09:58:51 <chrisdone> I've got a winblows laptop on my left, ubuntu in the middle, and a macbook on the right. *mr-burns-excellent*
09:59:06 <Axman6> maltem: and macports is hosted and maintained by Apple
09:59:24 <SamB_XP> Axman6: I was thinking maybe they'd have to set up some kind of secure registration so only actual non-incarcerated customers could use the wifi
09:59:41 <SamB_XP> presumably, using something a bit more secure than checking your MAC address against a whitelist ...
10:00:05 <maltem> Axman6, is it really? never knew that
10:00:12 <Axman6> yes, it is
10:00:15 <SamB_XP> ... which, iirc, is what Drexel does ...
10:00:31 <SamB_XP> never heard macports was Apple
10:00:33 * maltem checked and you are right. funny
10:00:46 <Axman6> maltem: it's not really an 'Apple project', but apple employees manage it
10:00:53 * SamB_XP tries to figure out if that is good or not
10:00:57 <SamB_XP> oh, good
10:00:58 <Axman6> and like i said, Apple host it
10:01:12 <SamB_XP> not an "Apple project"
10:01:19 <SamB_XP> that makes me feel a bit better about it ;-)
10:01:38 <Axman6> Apple supported i guess
10:02:09 <SamB_XP> I don't trust corporations to manage things like that for some reason ;-)
10:02:51 <SamB_XP> (fear of red tape, maybe?)
10:03:36 <chrisdone> well anyway I'll try the mueval library instead. cheers
10:03:59 * SamB_XP wonders how hard it would be to get GHC to work with plan9 C ...
10:06:57 * BrianHV just tried programming haskell for the first time, and successfully implemented a fibonacci function (after 20 minutes... ;)
10:07:12 <Axman6> hoorah!
10:07:32 <Axman6> care to share?
10:07:36 <copumpkin> is it the exponential fibonacci?
10:07:44 <copumpkin> or the linear one? or a logarithmic one?
10:07:45 <BrianHV> fibonacci :: Integer -> Integer -> Integer -> [Integer]
10:07:45 <BrianHV> fibonacci x y maxvalue = if x > maxvalue then [] else x:fibonacci y (x+y) maxvalue
10:08:00 <Axman6> nice
10:08:14 * BrianHV checks off question 2 on project euler. ;)
10:08:19 <Lemmih> BrianHV: You could drop the maxvalue.
10:08:41 <Axman6> BrianHV: just in case you didn't already know, type signatures are entirerly optional
10:08:45 <Lemmih> BrianHV: Infinite lists are very convenient in Haskell.
10:08:52 <Axman6> (though i think it's a good idea to add them)
10:08:57 <copumpkin> > let fibonacci x y = x:fibonacci y (x+y) in fibonacci 1 1
10:08:58 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:09:14 <BrianHV> Lemmih: I'd like to.. but how do I make sure that the code that uses it terminates?
10:09:15 <copumpkin> > let fibonacci x y = x:fibonacci y (x+y) in takeWhile (<100) $ fibonacci 1 1
10:09:16 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89]
10:09:26 <BrianHV> oooh, interesting
10:09:27 <koeien> BrianHV: lazy eval! :)
10:09:37 <BrianHV> didn't know about takeWhile
10:09:41 <mauke> needs more zipWith
10:09:46 <BrianHV> I thought there must be a way to do it though
10:09:48 <copumpkin> > fix ((1:) . scanl (+) 1)
10:09:49 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:09:51 <Axman6> > drop 100000 [1..]
10:09:51 <lambdabot>   [100001,100002,100003,100004,100005,100006,100007,100008,100009,100010,1000...
10:10:03 <koeien> > take 10 [1..]
10:10:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:10:09 <Axman6> > take 10 . drop 100000 $ [1..]
10:10:09 <lambdabot>   [100001,100002,100003,100004,100005,100006,100007,100008,100009,100010]
10:10:21 <Lemmih> BrianHV: Now they're just showing off.
10:10:43 <mauke> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)  in  fibs
10:10:43 * Axman6 was demonstrating lazy infinite lists
10:10:44 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:10:56 <koeien> fibs starts with zero imo ;)
10:10:56 <copumpkin> > nubBy (flip divides) [2..]
10:10:58 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:11:14 <mauke> wat
10:11:36 <copumpkin> wut wat
10:11:41 <RayNbow> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)  in  fibs   -- zero? :p
10:11:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:11:43 <mauke> that's evil/awesome
10:11:47 <koeien> RayNbow: yes, better ;)
10:12:19 <EnglishGent> hello :)
10:12:26 <Axman6> G'day
10:12:41 <EnglishGent> @hoogle FileMode
10:12:42 <lambdabot> System.Posix.Types type FileMode = CMode
10:12:43 <SamB_XP> heh ... dogbert offered to fix Y2K problems for $20M, guarenteed for 1 year ... in September of 1996 ;-P
10:12:46 <EnglishGent> hi Axman6 :)
10:13:17 <SamB_XP> and the PHB was too stupid to fall for it! http://www.dilbert.com/strips/comic/1996-09-17/
10:13:51 <Axman6> man, ig gtk2hs decided it doesn't want to finnish compiling after all this time, ii'm... FFFFFFFFFUUUUUUUUUUUUUUUU!
10:13:55 <Axman6> god damn it!
10:14:10 <EnglishGent> how do I create a filemode ... I've imported System.Posix.Types - but I still dont seem to have CMode or FileMode constructors in scope
10:14:16 <copumpkin> Axman6: will it swedish compiling?
10:14:25 <Axman6> no!
10:14:33 <copumpkin> damn
10:14:54 <mauke> EnglishGent: uh, they're numbers
10:15:30 <EnglishGent> you mean I can just provide an Int? I thought they'd wrapped it in a Data definition
10:15:39 <mauke> no, you can provide a number
10:15:58 <BrianHV> cool... removed maxvalue from fibonacci and replaced it with takeWhile in the calling code.  thanks for the tips!
10:16:01 <Makoryu> :t fromEnum 1
10:16:02 <lambdabot> Int
10:16:08 <Makoryu> > fromEnum 1
10:16:09 <lambdabot>   1
10:16:12 <EnglishGent> ok - ty :)
10:22:06 <Axman6> is there a value you can set a macro to in C so that #ifdef MACRO will treat MACRO as not being defined?
10:22:37 <copumpkin> you can #undef it
10:22:58 <Axman6> i mean through the preprocessor
10:23:10 <Alpounet> you must #undef it before the #ifdef test occurs
10:23:32 <copumpkin> Axman6: but no, there is no value you can give it that will cause it to treat it as undefined
10:23:37 <Axman6> (specifically i need to undefine __BLOCKS__ so that hsc2hs will quit whinging at me about ^ being in places it shouldn't be)
10:23:58 <copumpkin> then just #undef it :P
10:24:38 <Axman6> i would, but the file is /usr/include/stdlib.h
10:25:11 <Knight_Lord> Axman6: the place where it's defined is irrelevant
10:25:33 <Knight_Lord> Axman6: you can just undef before the test in question
10:25:46 <benmachine> all the places you can control the value, you can also control definedness
10:26:24 <benmachine> e.g. -U on the command line
10:26:52 <Alpounet> #include <stdlib.h> then #undef __BLOCKS__ then the test with #ifdef, and it's okay
10:27:43 <Axman6> that would be fine, if this were my own project. but this is gtk2hs, which is massive
10:28:17 <benmachine> so if there was an undefined-value, what would you do?
10:28:48 <dcoutts> Axman6: what's the problem exactly?
10:29:04 <Axman6> i'd find a way to set the hsc2hs flags to include -D__BLOCKS__=undefined
10:29:14 <Axman6> dcoutts: hsc2hs doesn't like Apple's block syntax
10:29:17 <lilac> i think you mean -U__BLOCKS__
10:29:30 <dcoutts> Axman6: it's actual C syntax?
10:29:39 <dcoutts> not just expanding into real C code?
10:29:42 <Axman6> it's an extension to C
10:29:48 <dcoutts> that gcc does not understand?
10:29:58 <Axman6> Apple's GCC understands it
10:29:59 <dcoutts> hsc2hs just calls gcc
10:32:06 <Axman6> well, the error is coming from hsc2hs from what i can tell
10:32:24 <Axman6> certainly doesn't look like a gcc error
10:32:35 <dcoutts> Axman6: hsc2hs itself does not grok C, it makes a C program and runs it.
10:32:43 <Axman6> hmm
10:33:03 <dcoutts> you can get more detail by running with -v
10:33:09 <dcoutts> to see which stage produces the error
10:33:34 <Axman6> wow... just made cabal die >_<
10:33:43 <Axman6> argh, why did i update it >_<
10:33:46 <dcoutts> ?
10:34:03 <dcoutts> Axman6: using a development or release version of cabal?
10:34:15 <Axman6> trying to upgrade hsc2hs and it had a 'Bus error'
10:34:20 <Axman6> whatever is on hackage
10:35:48 <dcoutts> Axman6: I've not heard any reports of bus errors traced to cabal
10:35:51 <Axman6> anyway, i have to go to sleep
10:36:36 <Axman6> dcoutts: it seems to die when trying to fetch hsc2hs
10:36:51 <Axman6> $ cabal upgrade hsc2hs
10:36:51 <Axman6> Resolving dependencies...
10:36:51 <Axman6> Downloading hsc2hs-0.67.20061107...
10:36:51 <Axman6> Bus error
10:36:58 <Axman6> and then an OS X crash report
10:37:41 <dons> dcoutts: ghc writes .prof files on ^C now, doesn't it?
10:37:42 <dcoutts> Axman6: ok, when you've got time please file a report with as many details as possible
10:37:48 <dcoutts> dons: I believe so
10:38:21 <Axman6> dcoutts: hmm, running cabal upgrade -v hsc2hs completes fine, but without -v doesn't
10:38:31 <dcoutts> Axman6: in particular run with -v3 so we can see at what stage of the http conversation (or before after)
10:38:35 <dcoutts> Axman6: oh, that's fun
10:38:40 <Axman6> indeed
10:38:52 <Axman6> wait, maybe i'm wrong
10:39:10 <Axman6> yeah it still dies with -v
10:39:33 <dcoutts> Axman6: and OSX and ghc version in the report is always useful.
10:39:43 <Axman6> seems to die at Creating new connection to hackage.haskell.org
10:40:02 <Axman6> dcoutts: i'll have to do that tomorrow. it's 3:30 AM, and i have to be up at 8 ... this morning
10:46:26 <deech> Hi all, I just watched "The Future Of Haskell" panel discussion and Bryan O Sullivan talked about users being confused by the number of projects on Hackage that solve the same problem. Why not just add a download counter on the project pages to solve that problem?
10:46:50 <tommd> deech: Mob rule isn't always the best strategy.
10:47:29 <absentia> not trying to start a war, not a troll)...  Q:  Does the future of Haskell ever have it being a (more) practical language?
10:48:14 <deech> tommd: But it would help a great deal.
10:48:16 <tommd> absentia: The libraries are becoming more and more practical while the language continues to evolve and test out new features..
10:48:24 <Berengal> absentia, A: Yes, quite probably. I already find it more practical than most other languages
10:48:35 <dons> deech, we already publish that.
10:48:40 <dons> its useful, but not the only metric
10:49:00 <Axman6> deech: my answer to that is to have a) ratings (along with numbers of raters), and b)  comments
10:49:14 <absentia> Ber: I'm starting to learn i... but I can see where it's still having to overcome the sitgma of functional languages past.
10:49:30 <absentia> great. split.
10:49:34 <deech> dons: I am looking at the Hackage HXT page and I don't see a download counter. Am I missing something?
10:50:47 <Axman6> i think comments would make hackage far more useful. if they could be made to automatically send comments to the developer's email, and be separated into comments on each release (though still having all comments visible at the same time), it would make for a fantastic medium between developers and users
10:51:24 <dons> deech, the stats aren't hosted on hackage yet
10:51:25 <Berengal> Axman6, hear hear
10:51:28 <dons> they're published separately
10:52:00 <lilac> does ghc's CPP provide a macro which expands to the base name of the file being compiled?
10:52:21 <deech> absentia: Your point is well taken. I am by no means a Haskell pro, but I wanted to do some XML processing and using HXT requires that I learn Arrows - and I just got comfortable with monad. Very frustrating, but my code was much better in the end.
10:53:03 <lilac> i have a bunch of modules which are identical apart from the 'module ...' line and a #include, and i'm wondering if i can do better than generating a bunch of near-identical .hs files
10:53:39 <Sgeo> Is making a type for Peano numbers and making it an instant of the appropriate classes good practice?
10:54:21 <lilac> Sgeo: why not use an existing numeric type?
10:54:30 <mauke> or lists
10:54:35 <Sgeo> lilac, because I want to practice?
10:55:02 <Axman6> sounds like goos practice to me then
10:55:05 <Axman6> d*
10:55:05 <lilac> Sgeo: ah, i thought you meant something completely different by "good practice" :)
10:55:26 <Axman6> me too, but i was going to take it the other way anyway
10:55:39 <lilac> (as in, a thing commonly done by a good practitioner)
10:55:55 <lilac> so yes, it's good practice but it's not a good practice :)
10:57:33 <newcmr> hi, can you recommend me any introductory book to haskell that you have particularly enjoyed?
10:57:48 <Axman6> @which lyah
10:57:48 <lambdabot> Unknown command, try @list
10:57:54 <Axman6> @where lyah
10:57:54 <lambdabot> www.learnyouahaskell.com
10:57:59 <Axman6> newcmr: ^^^^^^^^^^^^^^
10:58:06 <Axman6> damn, on character off
10:58:13 <deech> newcmr: Real World Haskell (http://book.realworldhaskell.org/read/)
10:58:53 <newcmr> "You can find me on #haskell "... hmm an unbiased answer :)
10:59:10 <newcmr> of course I'll give it a read, thank you
10:59:27 <lilac> preflex: seen BONUS
10:59:27 <preflex>  BONUS was last seen on #haskell 60 days, 5 hours, 16 minutes and 1 second ago, saying: :t catchError
10:59:50 <Axman6> newcmr: the two best books for beginners are lyah, and the interactive book #haskell
10:59:53 <Axman6> ;)
11:00:32 <Axman6> lilac: heh, i guess he didn't catch that error :P
11:01:47 <Berengal> Axman6, is #haskell interactive, or just lazy?
11:01:58 <Axman6> bit of both
11:02:10 <Axman6> speaking of lazy, i really have to go to sleep. night all
11:02:14 <Sgeo> http://hackage.haskell.org/packages/archive/QuickCheck/1.1.0.0/doc/html/Test-QuickCheck-Batch.html#v:bottom WTF? How can bottom be tested for?
11:02:14 <Berengal> With unsafeInterleaveIO, is there a difference?
11:02:16 <Axman6> it's 4AM >_<
11:02:42 <copumpkin> Axman6: nuh uh
11:02:51 <copumpkin> Axman6: lern to read ur clok, its 2 pm
11:02:52 <Berengal> Sgeo, unsafePerformIO
11:03:08 <Axman6> copumpkin: lrn2timetravel
11:03:16 * Axman6 &
11:03:21 <copumpkin> Axman6: alredy lurnd
11:05:19 <Berengal> Someone fix that server already
11:05:38 <Alpounet> agreed...
11:07:00 <FunctorSalad_> Sgeo: you are correct to be appalled, you can't test for bottom without cheating
11:07:40 <FunctorSalad_> (haskell functions are supposed to be monotonic, which means "f undefined" should be semantically less than or equal to "f anythingElse")
11:08:13 <FunctorSalad_> so you can't have a function with f undefined = True, f notUndefined = false
11:08:25 <Sgeo> Also, what about the halting problem?
11:09:24 <Berengal> In IO, _|_ is less defined than error/undefined
11:09:48 <FunctorSalad_> Sgeo: I assume it will only work for explicit "undefined", not for nontermination :)
11:10:06 <Berengal> So it's technically not testing for bottom, but the value just above it
11:10:49 <FunctorSalad_> Berengal: really? [[undefined]] isn't _|_?
11:11:05 <ray> nope
11:11:07 <Berengal> FunctorSalad_, not in IO, as you can test for it there
11:11:15 <Alpounet> is there any page about _|_ ?
11:11:15 <EnglishGent> @hoogle [a] -> [[a]]
11:11:16 <lambdabot> Data.List inits :: [a] -> [[a]]
11:11:16 <lambdabot> Data.List permutations :: [a] -> [[a]]
11:11:16 <lambdabot> Data.List subsequences :: [a] -> [[a]]
11:11:23 <Alpounet> @hoogle _|_
11:11:23 <ray> the wikibook
11:11:23 <lambdabot> Warning: Unknown type |
11:11:23 <lambdabot> Control.Category id :: Category cat => cat a a
11:11:23 <lambdabot> Control.Arrow returnA :: Arrow a => a b b
11:11:34 <Alpounet> k
11:11:48 <newcmr> is haskell closer to lisp or to ML?
11:11:53 <ray> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
11:11:54 <Berengal> newcmr, ML
11:12:02 <newcmr> ok
11:12:04 <ray> ML, but it's not close to ML
11:12:21 <Berengal> Depends on the scale.
11:12:36 <Berengal> It's closed to ML on a scale from assembly to Coq
11:12:40 <lilac> > (map snd . filter fst . (zipWith3 (\b k v -> (b,(k,v))) (cycle [True,False]) <*> tail)) "a1b4c8d4e0"
11:12:41 <lambdabot>   [('a','1'),('b','4'),('c','8'),('d','4'),('e','0')]
11:13:23 <MyCatVerbs> It's close to ML on a scale from Lisp to... oh, ML? ;P
11:13:23 <FunctorSalad_> Alpounet: essentially it's the "meaning" of a haskell program that doesn't terminate
11:13:43 <FunctorSalad_> (if you mathematically assign a meaning to every haskell program)
11:14:07 <Berengal> _|_ is false in the curry-howard isomorphism
11:14:14 <Alpounet> yeah, like "√Æ" (there isn't any correct symbol for that, AFAIK) in calculability, when something "diverges"
11:14:26 <lilac> > unfoldr (Just . splitAt 2) "a1b4c8d4e0"
11:14:26 <lambdabot>   ["a1","b4","c8","d4","e0","","","","","","","","","","","","","","","","","...
11:14:48 <EnglishGent> @hoogle (Eq x) => x - [x] -> [[x]]
11:14:48 <lambdabot> Parse error:
11:14:48 <lambdabot>   --count=20 "(Eq x) => x - [x] -> [[x]]"
11:14:48 <lambdabot>                          ^
11:15:10 <MyCatVerbs> newcmr: Haskell is an ML-family language, really. Its syntax is quite similar to ML, its pattern matching and algebraic datatypes are pretty much identical to ML, and its type system is based on - but massively extended from - ML's (which you might hear referred to by the name "Hindley-Milner").
11:15:12 <Berengal> Alpounet, divergence isn't that simple in a lazy language though. [1..] diverges, but isn't _|_
11:15:17 <Sgeo> "What's wrong?" "Maybe (Maybe a)"
11:15:23 <EnglishGent> um.. that looked ok to me .. what did I do wrong? :|
11:15:32 <FunctorSalad_> Berengal: how can _|_ be falsity? propositions correspond to types
11:15:33 <mauke> EnglishGent: - instead of ->
11:15:36 <Sgeo> EnglishGent, -> not -
11:15:39 <FunctorSalad_> Falsity is the empty type
11:15:47 <Alpounet> Berengal, ok, got the difference
11:15:48 <EnglishGent> oh! sorry - missed that
11:15:51 <EnglishGent> thanks :)
11:15:56 <EnglishGent> @hoogle (Eq x) => x -> [x] -> [[x]]
11:15:56 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
11:15:56 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
11:15:56 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
11:16:05 <ray> let'
11:16:08 <ray> isdhgosahg
11:16:13 <MyCatVerbs> newcmr: The facts that it's lazy by default and that computations in the IO monad are distinguished from pure computations make it in theory very very different from ML, though.
11:16:40 <Berengal> FunctorSalad_, and _|_ is a member of every type, including the empty type
11:16:53 <FunctorSalad_> Berengal: yeah, that's why Haskell is inconsistent ;)
11:17:10 <FunctorSalad_> (in the curry-howard correspondence only, of course)
11:17:15 <ray> most cool logics are
11:17:54 <Berengal> FunctorSalad_, okay then, in the inconsistent curry-howard isomorphism, _|_ is false :P
11:18:00 <ray> functorsalad_: back to [[undefined]], that would be _|_ if [] were strict
11:18:10 <ray> but it's not, so it's more defined
11:18:12 <EnglishGent> hmmm ... I want to take a string - and break into a list of strings on some seperator character .. i.e. a generalisation of Data.List.words
11:18:18 <EnglishGent> what's an elegant way of doing this?
11:18:19 <ray> wikibook is good
11:18:40 <FunctorSalad_> ray, Berengal : are we talking about "undefined :: IO Foo" here, or *any* undefined that happens to be called from IO code?
11:18:41 <ray> @huckage split
11:18:41 <lambdabot> http://hackage.haskell.org/package/split
11:18:46 * EnglishGent thinks that has a 'libraryish' feel to it
11:18:51 <EnglishGent> thanks ray :)
11:18:53 <Berengal> EnglishGent, there's a library for splitting lists... think it was called just split
11:19:01 * Berengal is slow
11:19:03 <EnglishGent> ty Berengal :)
11:19:07 <ray> i'm not even talking about IO, just about denotation
11:19:08 <FunctorSalad_> I thought IO exception catching was outside the semantics
11:19:14 * EnglishGent is grateful to everyone anyway :)
11:19:33 <benmachine> well since IO can basically do what it likes
11:19:39 <Berengal> FunctorSalad_, IO exception catching is well defined, but only true in IO, because it uses IO primitives
11:20:12 <Berengal> And any undefined can be inspected from IO
11:21:04 <FunctorSalad_> but "fix id" is a honest _|_?
11:21:19 <ray> fix id is a _|_ of the diverging kind
11:21:24 <FunctorSalad_> I always thought it had the same semantics as undefined... you learn something new all the time
11:21:25 <gwern> > 9 / 4
11:21:26 <lambdabot>   2.25
11:21:38 <ray> it does, but IO cheats a bit
11:21:40 <Berengal> FunctorSalad_, they have the same semantics outside of IO
11:21:52 <Badger> I daren't envisage a diverging bottom.
11:21:52 <Berengal> IO cheats by existing in the real world
11:21:55 <benmachine> IO could catch fix id except that that is really hard to do
11:22:13 <benmachine> IO catches main = main after all
11:22:14 <koeien> Berengal: no, pure function cheat by "existing" in the real world :)
11:22:15 <FunctorSalad_> spooky action from things that aren't subexpressions? :O
11:23:01 <ray> fix anystrictfunction is _|_
11:23:26 <Berengal> ray, as benmachine said, it might not be. Depends on IO
11:23:31 <copumpkin> > fix seq
11:23:32 <lambdabot>   {()->()}
11:23:40 <ray> IO cheats
11:23:46 <ray> seq cheats EVEN WORSE
11:23:53 <Sgeo> If I do a qualified import of Data.Ratio, how do I use its %?
11:23:58 <koeien> Data.Ratio.%
11:24:14 <ray> see you can have haskell or haskell + FILTHY CHEATING
11:24:15 <Sgeo> As an operator, or do I have to use `Data.Ratio.%` ?
11:24:34 <koeien> as op
11:24:42 <ray> ugh, that syntax is so confusing
11:24:43 <Sgeo> ty
11:24:44 <koeien> > (Data.Ratio.%) 3 4
11:24:45 <lambdabot>   3 % 4
11:24:51 <ray> i think R.%
11:25:03 <koeien> you also need to add parens if you want to use it as prefix function
11:25:12 <benmachine> I would be tempted to either import that specific thing unqualified or redefine it in your program
11:25:31 <ray> there was a proposal to force you to use `R.(%)` on haskell'
11:25:39 <ray> which is annoying but consistent
11:25:55 <ray> yeah, i doubt % conflicts with any names
11:26:03 <koeien> vim highlights it anyway
11:26:19 <ray> the poor haskell grammar
11:26:32 <ray> everyone's punching bag
11:27:19 <EnglishGent> how do you represent the \ character? '\' doesnt work - and neither does '\\'
11:27:25 <benmachine> > '\\'
11:27:26 <lambdabot>   '\\'
11:27:33 <koeien> EnglishGent: '\\' should work?
11:27:33 <benmachine> doesn't it?
11:27:54 <EnglishGent> hmm
11:28:06 <Sgeo> I feel like I'm repeating a lot of code
11:28:08 <EnglishGent> it echos '\\' - but I guess read/print consistency?
11:28:22 <Sgeo> my definitions for fromInteger and toEnum are almost exactly the same
11:28:23 <koeien> if you putStrLn $ '\\':[] it goes ok
11:28:31 <EnglishGent> yup - read\print consistency
11:28:41 <trofi> > read "\\"
11:28:41 <lambdabot>   * Exception: Prelude.read: no parse
11:28:55 <Alpounet> > read "\\" :: String
11:28:55 <lambdabot>   "* Exception: Prelude.read: no parse
11:28:58 <trofi> > read '\\' :: Char
11:28:59 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:28:59 <lambdabot>         against inferred ty...
11:29:04 <koeien> strings have " in their show
11:29:09 <koeien> > show "Hello!\\"
11:29:10 <lambdabot>   "\"Hello!\\\\\""
11:29:18 <mauke> > length "\\"
11:29:18 <lambdabot>   1
11:29:19 <dons> i have a program that shows negative benchmarking time, bos
11:29:19 <Alpounet> oh right
11:29:29 <Alpounet> > read "\"\\\"" :: String
11:29:30 <lambdabot>   "* Exception: Prelude.read: no parse
11:29:38 <dons> @tell bos i'm getting negative benchmarking times ...
11:29:38 <lambdabot> Consider it noted.
11:29:41 <dons> -500ns
11:29:43 <trofi> it might be a LB/shell issue
11:30:05 <trofi> > read ['\\'] :: Char
11:30:05 <lambdabot>   * Exception: Prelude.read: no parse
11:30:25 <koeien> > read ['\'', '\\', '\''] :: Char
11:30:25 <lambdabot>   * Exception: Prelude.read: no parse
11:30:31 <koeien> bla
11:30:47 <trofi> > show "$PATH"
11:30:48 <lambdabot>   "\"$PATH\""
11:31:00 <dons> @tell bos nevermind. my fault
11:31:00 <lambdabot> Consider it noted.
11:31:45 <koeien> > read ['\'', '\\', '\\', '\''] :: Char
11:31:45 <lambdabot>   '\\'
11:31:45 <Sgeo> >(map read ['\'', '\\', '\'']) :: [Char]
11:31:45 <Sgeo> > (map read ['\'', '\\', '\'']) :: [Char]
11:31:45 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:31:45 <lambdabot>         against inferred ty...
11:33:32 <trofi> koeien: thanks! dunno why i typed that idiocy
11:38:54 <EnglishGent> is there a more elegant way of doing this... it works - but it looks unwieldy
11:39:27 <EnglishGent> prefixes = map (intercalate fileSeperator) $ tail $ inits $ Data.List.split.splitOn fileSeperator path
11:39:37 <EnglishGent> ? :)
11:41:25 <nyingen> > "F+F‚àíF‚àíF+F"
11:41:26 <lambdabot>   "F+F\8722F\8722F+F"
11:41:33 <nyingen> I am confused by this :(
11:41:45 <mauke> why?
11:42:03 <nyingen> why the \8722?
11:42:05 <mauke> U+2212 (e2 88 92): MINUS SIGN [‚àí]
11:42:13 <mauke> because that's the code of that character
11:42:25 <nyingen> ah, hm
11:42:28 <Alpounet> > chr '\'
11:42:29 <lambdabot>   <no location info>:
11:42:29 <lambdabot>      unexpected end-of-file in string/character literal...
11:42:31 <mauke> U+002D (2d): HYPHEN-MINUS [-]
11:42:32 <nyingen> > "F+F-F-F+F"
11:42:33 <lambdabot>   "F+F-F-F+F"
11:42:35 <Alpounet> > chr '\\'
11:42:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:42:35 <lambdabot>         against inferred type ...
11:42:40 <Alpounet> > ord '\\'
11:42:40 <lambdabot>   92
11:42:42 <mauke> yeah, that's the one
11:42:44 <nyingen> Ah, the problem is because of cut-and-paste
11:42:56 <nyingen> subtle, at least with this font
11:43:25 <Gracenotes> dons: so, I saw ST support for judy arrays mentioned in a blog comment... just curious, are you going to make an entirely separate module for it? or use typeclasses?
11:50:07 <jmillikin> Does Hackage use a custom LHS preprocessor? It's failing to build one of my libraries that builds fine locally, and it looks like the cause is trying to parse a block of code which GHC ought to ignore.
11:50:43 <jmillikin> Specifically, that block starts with \begin{code}%   , which should work according to <http://www.haskell.org/haskellwiki/Literate_programming>
11:54:11 <pasc1> how do i bind libcurl to haskell?
11:55:46 <ziman> pasc1, there are bindings on Hackage: http://hackage.haskell.org/packages/archive/pkg-list.html  <-- just search `curl' using your browser
11:56:56 <pasc1> configuring curl yields to the following error:
11:56:56 <pasc1> configure: error: curl libraries not found, so curl package cannot be built
11:57:15 <ziman> i'd say you need to install libcurl first
11:57:22 <gwern> or -dev
11:58:11 <EnglishGent> @hoogle scan
11:58:12 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
11:58:12 <lambdabot> Data.ByteString scanl :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
11:58:12 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
11:59:22 <pasc1> ah thanks! i forgot to install -dev
12:02:38 <jun_> I'm just trying to get a glade window to appear, but I get a 'pattern match failure: http://pastebin.com/d1af8f02f
12:03:15 <jun_> the file is present in the source directory
12:05:29 <jun_> The offending line is this: Just xml <- xmlNew "greader.glade"
12:05:42 <Sgeo> @hoogle hoogle
12:05:42 <lambdabot> Can't think of anything more interesting to search for?
12:05:42 <lambdabot> No results found
12:06:12 <jun_> sorry, it's: Just windowXml <- xmlNew "greader.glade"
12:06:23 <Sgeo> @hoogle Google
12:06:23 <lambdabot> Google rocks!
12:06:23 <lambdabot> No results found
12:11:02 <jun_> I'm finding it hard to see what's wrong with that line of code
12:11:52 <mauke> well, xmlNew returned Nothing
12:12:00 <mauke> which couldn't be bound to Just windowXml
12:12:23 <etate> hey guys, i am trying to time pure quicksort code but having trouble putting it into an IO monad temporarily
12:12:39 <jun_> why is it only returning 0???
12:12:51 <jun_> sorry, i have the repeat on this keyboard set very high
12:13:01 <etate> i'm using System.TimeIt.timeIt in a main = do ...
12:13:03 <jmillikin> jun_: it looks like it's failing to parse the file. Is glade itself able to open that file?
12:13:17 <Twey> Whyyy iiisss thaaaatt?
12:13:22 <jun_> it is
12:14:02 <etate> then when I do timeIt $ return (quicksort [1..10000000]) ghc dies :(
12:14:13 <jun_> Twey, I thought it might improve my typing
12:14:38 <jun_> in the long run, anyway
12:14:48 <Twey> Interesting.  What led you to that conclusion?
12:15:08 <ray> makes sense to me
12:15:08 <Gracenotes> etate: hm.. timeIt shouldn't force evaluation of the quicksort, actually. should it?
12:15:42 <Gracenotes> hm, unless it tries to print the results
12:15:43 <jun_> By keeping the keys depressed for as short a time as possible, I should eliminate wasting time on each keystroke
12:15:47 <etate> Gracenotes: nope, thats the problem and why i'm using return
12:16:08 <etate> Gracenotes: but return actually returns a quicksorted 1..10000000 list, which is not what i want
12:16:11 <jmillikin> jun_: Please make sure you're generating Glade files, and not GtkBuilder files.
12:16:27 <jmillikin> The code you posted works fine on my system, with a Glade file.
12:16:31 <Gracenotes> return is just a wrapper. using >>= on it doesn't do much
12:16:39 <Gracenotes> you might want to do: rnf (quicksort [1..blah]) `seq` return ()
12:16:55 <jun_> jmillikin, thanks. I was making gtkbuilder files
12:16:55 <etate> Gracenotes: what is rnf?
12:17:18 <Gracenotes> rnf from Control.Parallel.Strategies, ensures its arguments are completely evaluated before yielding a constructor (which is what seq needs to continue, at least in GHC semantics)
12:18:22 <Gracenotes> rnf is a function of the typeclass NFData, but an [Int] would be an instance of it, so that'd work as is
12:19:29 <etate> Gracenotes: it gives me a ambiguous type variable 't' in NFData...
12:19:51 <Gracenotes> perhaps you need to specify the type of numbers in the list specifically?
12:20:30 <Gracenotes> (perhaps I need to redo that statement less redundantly :o)
12:20:39 <etate> Gracenotes: yeah that worked :)
12:20:54 <Gracenotes> ah, great. how long did it take?
12:21:01 <etate> Gracenotes: a long time :)
12:21:35 <etate> Gracenotes: its not finished yet... but I guess this is expected since I didn't optimise it yet
12:22:45 <etate> Gracenotes: the C version takes 2.5s (gcc), the common lisp 3.5 (sbcl), the dylan 3.4 (d2c)
12:23:16 <Gracenotes> yes. and compiled behavior (especially with optimizations) differs from ghci behavior
12:23:55 <etate> Gracenotes: yeah, any recommendations on that?
12:24:06 <Gracenotes> also, are you sure it's the same algorithm as the other ones? e.g., if you're doing in-place array switching in C, you'd have to use a mutable array in Haskell to really compare it
12:24:30 <SamB_XP> array-switching ?
12:24:38 <Gracenotes> array element swapping and such
12:24:39 <etate> Gracenotes: yeah, this is the problem, but I wanted to see whether the nice clean haskell version could compete first :D
12:24:42 <SamB_XP> ah
12:24:53 <etate> Gracenotes: the other versions use unboxed arrays
12:24:54 <Gracenotes> Haskell implementations that just filter (<) or something are no match -.-
12:25:25 <SamB_XP> Gracenotes: indeed
12:25:26 <Gracenotes> ahm
12:25:56 <Sgeo> Is there any such thing as a list of ascending items? So that, say, elem on an infinite list where the element is not to be found isn't _|_ ?
12:25:58 <etate> Gracenotes: but it would have been nice to have a fast and clean haskell version :D
12:27:34 <Gracenotes> for mutable arrays, rnf is not needed reallyh
12:27:36 <Gracenotes> -h
12:28:28 * Gracenotes gets foodstuffs
12:29:19 <etate> hmmm ghc needs me to specify every lib it imports??
12:30:00 <Alpounet> how would ghc do when you call a function that 2 possible modules contain, doing totally different things ?
12:30:29 <Alpounet> should ghc flip a virtual coin ? :-p
12:30:30 <copumpkin> Alpounet: tell you it's ambiguous
12:30:33 <EnglishGent> @hoogle isAFile
12:30:34 <lambdabot> No results found
12:30:45 <Alpounet> copumpkin, I know, was answering etate
12:30:51 <EnglishGent> @hoogle doesFileExist
12:30:51 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
12:31:03 <etate> Alpounet: well isn't that why you put import libX at the top of the source file?
12:31:20 <etate> Alpounet: if ghci can detect and load dependencies, why not ghc :/
12:31:37 <mauke> etate: it can; use ghc --make
12:31:45 <Alpounet> +1
12:32:08 <etate> mauke: o my bad :)
12:33:40 <benmachine> Sgeo: sounds like a Set, ish
12:33:56 <Sgeo> Hm, forgot about Sets. That's probably what I want
12:34:01 <benmachine> well it sounds like a multiset
12:34:08 <benmachine> but I don't know what libraries support multisets
12:34:21 <Sgeo> multisets mean it can support several of the same item, right? I don't need that
12:34:26 <Sgeo> I just want a set of primes
12:34:27 <benmachine> I believe so
12:34:33 <benmachine> ah
12:34:47 <benmachine> you can always just apply takeWhile to a list
12:35:31 <benmachine> or check Data.List.find (>= item) == item
12:36:03 <benmachine> (fromJust . find)
12:40:25 <gwern> @tell ndm I was rereading http://neilmitchell.blogspot.com/2006/11/systemfilepath-automated-testing.html and I thought I'd mention in case you didn't know that I cabalized smallcheck a while ago
12:40:25 <lambdabot> Consider it noted.
12:48:12 <kosmic> what's something cool one can do in a single line
12:49:24 <mauke> > fix error
12:49:25 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:50:36 <Sgeo> ahaha
12:53:26 <mjrosenb> kosmic: most things can be done in one line
12:56:22 <hackagebot> judy 0.2.1 - Fast, scalable, mutable dynamic arrays, maps and hashes (DonaldStewart)
12:56:27 <burp> @faq can haskell do everything in one line?
12:56:28 <lambdabot> The answer is: Yes! Haskell can do that.
12:56:53 <shepheb> burp: use let to name lambdas. QED.
12:56:58 <shepheb> :P
12:57:21 <Sgeo> @faq is the answer to this no?
12:57:21 <lambdabot> The answer is: Yes! Haskell can do that.
12:58:37 <sereven> kosmic: http://www.haskell.org/haskellwiki/Blow_your_mind has some nice one liners
12:59:20 <kosmic> thanks
12:59:22 <Sgeo> Aww, only useful examples? Boo!
12:59:27 <kosmic> i'll play with these later
12:59:47 <sereven> Sgeo: hehe, guess you could grep the logs from the topic, too
12:59:55 <mercury^> sereven: I expected something better after reading the title
13:00:13 <mercury^> All pretty boring there. :(
13:00:28 <sereven> mercury^: yeah, actually reading through it doesn't seem as nice as last time I remember looking through it. :(
13:11:46 <McManiaC> huh
13:12:37 <McManiaC> i have a Foo.hs and a Foo/Bar.hs and i need stuff from Foo.Bar in Foo and the other way around
13:12:51 <McManiaC> now i get a "imports form a cycle"
13:13:15 <McManiaC> how can i get ghc to compile that? ^^
13:13:37 <gwern> see the manual. iirc some sort of stub mechanism
13:13:43 <maltem> McManiaC, you need to create an .hs-boot file to help ghc out
13:13:50 <gwern> or you can enumerate your imports, iirc, and sometimes that will solve the cyclic imports
13:14:06 <gwern> (stubs = what maltem sez)
13:14:38 <maltem> right or restrict the imports if that's possible
13:15:09 <McManiaC> restrict?
13:15:15 <gwern> import Foo (foo)
13:16:02 <McManiaC> ah, I tried that already
13:17:00 <Alpounet> is writeFile so lazy that it won't actually write anything ? :-p
13:19:00 <gwern> @flush
13:19:03 <gwern> @quote
13:19:03 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
13:19:03 <lambdabot> squad, but he declined.
13:19:22 <gwern> haskellers and unicycles. man.
13:19:26 <gwern> @quote unicycle
13:19:26 <lambdabot> mmorrow says: in langs with dependent types, you can just map numbers directly to types instead of having to ride a unicycle along a tightrope while battling an unruly gang of monkey with knives
13:19:39 <gwern> @quote unicycle
13:19:39 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
13:19:47 <gwern> @quote unicycle
13:19:47 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
13:19:59 * gwern thinks haskellers also have unicycles on the brain
13:20:58 <gwern> it's interesting how scheme defines (+) and (*); 0 and 1, respectively
13:21:06 <Berengal> How total is total in a lazy language?
13:21:37 <Berengal> gwern, when you're working with lists, you'll probably have more use for sum and product than simple addition and multiplication
13:21:56 <gwern> Berengal: iirc, isn't a total language ignorant of strictness or laziness?
13:22:15 <Berengal> gwern, yes, but haskell isn't total
13:22:16 <Peaker> gwern, in terms of termination, I think it is, but in terms of operational semantics/performance, its still important
13:22:38 <gwern> Berengal: and I'm just saying that as a haskeller, I find it funny that just '(*)' evaluates to a number and isn't a function
13:22:59 <Berengal> gwern, Well, product [] evaluates to a number as well...
13:23:03 * Berengal shrugs
13:23:08 <gwern> :t product
13:23:09 <lambdabot> forall a. (Num a) => [a] -> a
13:23:24 <gwern> but that makes more sense since you've given it an argument, any argument
13:23:52 <Berengal> (*) takes n <= 0 arguments, so in a sense, you have...
13:24:28 <gwern> lies! * takes 2 arguments! no more no less! :)
13:24:34 <Berengal> Think of it as a value that's both a number and a function
13:24:54 <Berengal> Sort of like printf, except it works
13:25:46 <Berengal> I find it weird in a haskell context as well, but not in a lisp context
13:26:17 <Berengal> (For some reason, the lisp context was easy to get, even though I haven't really done much lisp)
13:27:07 <Berengal> gwern, if you think of the trees that are built, it makes a bit more sense. You're giving it an argument, but it's invisible
13:27:33 <gwern> what's the argument?
13:27:38 <hackagebot> gitit 0.6.3 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
13:27:42 <Berengal> nil
13:27:58 <Berengal> (*) "desugars" to (* . nil)
13:28:33 <ski> (apply * '())
13:28:48 <gwern> 'Fixed MathML conversion so it doesn't happen when exporting to non-HTML output formats.
13:29:05 <gwern> excellent. not that I export to non-HTML very often but that's good
13:29:25 <gwern> Berengal: hm. I didn't know that
13:29:43 <gwern> or rather, I knew it but I don't really appreciate that nil is at the end of every expression
13:29:59 <gwern> expression/list
13:30:07 <Berengal> gwern, well, all lists end in nil, and almost everything is a list, so there has to be lots of invisible nils around
13:31:34 <Berengal> (defun eval ((f . args)) (let ((fun (lookupFunction f))) (apply fun args))
13:31:36 <Berengal> -ish
13:46:17 <Makoryu> gwern: Is it any different from [] in Haskell?
13:46:24 <Alpounet> @where hpaste
13:46:24 <lambdabot> http://hpaste.org/
13:46:34 <Makoryu> gwern: I mean, aside from the fact that it's overloaded to also mean Nothing
13:46:38 <Makoryu> And False
13:46:45 <Makoryu> And... plenty of other stuff
13:46:47 <Makoryu> :/
13:51:03 <thomastc> I have a function findPrefixFile :: FilePath -> FilePath -> IO (Maybe FilePath)
13:51:13 <thomastc> and I want to fold this over a list of FilePaths
13:51:38 <thomastc> basically, I want to fold in the Maybe monad, but the IO monad gets in the way
13:51:51 <thomastc> how to do this?
13:52:32 <Botje> use sequence to get an IO [Maybe FilePath]
13:52:35 <orbitz> are you doing IO in the function you are oflding?
13:53:01 <thomastc> orbitz: yes
13:53:04 <Botje> and then use catMaybes or mconcat :)
13:53:12 <thomastc> Botje: thanks, will give that a try
13:58:06 <EnglishGent> @hoogle FileStatus
13:58:06 <lambdabot> No results found
14:09:32 <Alpounet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9904#a9904 -- any idea ?
14:10:00 <orbitz> hey Alpounet
14:10:25 <Alpounet> hi orbitz
14:11:56 <monochrom> What if you don't compile with -threaded?
14:12:37 <monochrom> (I am suspecting the difference between forkIO and forkOS.)
14:13:17 <monochrom> Oh, and what happens when the "main thread" is done?
14:13:22 <benmachine> Alpounet: when the main thread exits it takes down all other threads immediately
14:13:32 <benmachine> I guess in ghci it doesn't
14:13:32 <monochrom> Ah haha :)
14:13:40 <benmachine> but if it doesn't work in runhaskell either then I'm right
14:13:43 <monochrom> in ghci, ghci itself is the main thread!
14:13:52 <benmachine> you need to make the main thread wait for its children
14:14:08 <benmachine> not 100% sure how to do that, probably something with MVars and/or asynchronous exceptions
14:14:29 <orbitz> RHW has a simple thread manager
14:14:30 <monochrom> The Control.Concurrent doc has an example.
14:14:39 <Alpounet> indeed benmachine, it doesn't work with runhaskell neither.
14:15:07 <ra> Hello! I'm learning haskell.. I've come across the `divides` function, but can't find its import. Is there a tool to search for functions in the standard library?
14:15:17 <Botje> @hoogle divides
14:15:17 <lambdabot> No results found
14:15:21 <orbitz> do you mean div?
14:15:28 <Botje> ra: i don't think it's in the standard library, though.
14:15:46 <Botje> ra: x `divides` y = y `mod` x == 0
14:15:50 <orbitz> ra: http://www.haskell.org/hoogle/
14:15:52 <Alpounet> @where hoogle
14:15:52 <lambdabot> http://haskell.org/hoogle
14:19:57 <fxr> is Toralf Wittner here?
14:21:21 <Alpounet> can't we do a threadDelay in the main thread ?
14:21:25 <ra> Botje, yeah.. the impl is easy to guess.. I'm going through the 99 problems.. (problem 16) I've used `mod` .. == 0.. and the example solution uses `divides`... however googling wasn't very helpful.
14:21:49 <Botje> ra: well, it's not a library function :)
14:23:46 <ra> Thanks and good night y'all
14:33:11 <Alpounet> is there a 'later' function in the GHC distribution ?
14:33:33 <Saizan> what should it do?
14:34:53 <Alpounet> don't know
14:35:20 <Alpounet> "main =
14:35:20 <Alpounet>        later waitForChildren $
14:35:20 <Alpounet> " on the Control.Concurrent doc
14:35:35 <Alpounet> just wondered what it was supposed to do, it it exists
14:35:38 <copumpkin> @hoogle later
14:35:39 <lambdabot> No results found
14:36:33 <benmachine> maybe it is =<<
14:36:37 <benmachine> or <<
14:36:47 <benmachine> that would make a perverse kind of sense
14:37:46 <mercury^> benmachine: there's no <<.
14:38:17 <mercury^> Though I always wondered why. >.>
14:38:38 <benmachine> mercury^: yes but you know what it would do if there was :P
14:38:43 <monochrom> Since it doesn't exist, it is supposed to solve the halting problem.
14:39:11 <monochrom> And it solves later, not sooner!
14:40:25 <lilac> maybe it's being used in the English sense, as "main = ...", later "waitForChildren $ ..."
14:41:01 <Saizan> "later = flip (>>)" would make sense there
14:41:07 <monochrom> haha
14:41:42 <Alpounet> lilac, that's the only possible meaning I see, but it'd be weird to have kept it just like this in the haskell code
14:42:42 <Saizan> i think they just forgot to include the def. for later
14:43:28 <Alpounet> yep
14:43:46 <Alpounet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9904#a9905 -- does this code look good ?
14:44:45 <Saizan> Alpounet: yes
14:45:22 <Alpounet> it works, just wanted to have feedback from much more experienced Haskell hackers
14:46:17 <Saizan> btw, (\x -> forkChild $ doDl x) = forkChild . doDl
14:47:14 <hackagebot> rss2irc 0.4.2 - watches an RSS/Atom feed and writes it to an IRC channel (SimonMichael)
14:47:55 <Saizan> that's hackagebot announcing its new version, basically?:)
14:48:08 <sm> Saizan: correct :)
14:48:08 <lambdabot> sm: You have 1 new message. '/msg lambdabot @messages' to read it.
14:49:04 <sm> unfortunately 0.4 was missing every sixth item.
14:49:29 <fxr> lambdabot: do you check for mode +e when sending messages to ppl?
14:49:32 <sm> happily 0.4.1 was a sixth item so I noticed :)
14:49:47 <twanvl> every sixth item? how did you manage that?
14:49:48 <monochrom> unsafePerformIO for this is overkill
14:50:40 <fxr> I guess so
14:51:03 <Saizan> ah, yeah, it's correctly using the code from C.Concurrent, but i'd avoid unsafePerformIO
14:51:06 <sm> trofi: hackagebot can't announce on multiple channels currently. I could run another if you need.. or patch would be welcome
14:51:07 <monochrom> (This is why the doc example goes higher-order and write a wrapper instead of a plain action.)
14:51:55 <Alpounet> Saizan, how ? otherwise it'd be trapped in the IO monad, just like the cat.
14:52:28 <Saizan> Alpounet: just create the MVar from main and pass it as an argument to waitForChildren and forkChild
14:52:34 <monochrom> The doc example does not use unsafePerformIO and still works.
14:52:48 <Alpounet> monochrom, actually it does
14:53:13 <monochrom> I see. Oops.
14:53:35 <Saizan> well there are two distinct solutions, just mkForkIO would work too
14:53:50 <sm> twanvl: immense cleverness!
14:54:01 <monochrom> Bah!
14:54:09 <Saizan> you'd consider the returned MVar () as a thread handle that you can "join" to
14:54:18 <Saizan> where join = takeMVar
14:54:48 <Alpounet> Saizan, ok, done :-)
14:57:08 <sm> twanvl: default batch size is five, on processing the sixth it slept and re-read the announce queue, but forgot to push the item back on the queue
14:58:13 <HairyDude> @seen lemmih
14:58:13 <lambdabot> Unknown command, try @list
14:58:44 <c_wraith> lambdabot hasn't done @seen in a while now.  try preflex
14:58:49 <c_wraith> preflex: seen lemmih
14:58:49 <preflex>  lemmih was last seen on #haskell 4 hours, 48 minutes and 27 seconds ago, saying: BrianHV: Now they're just showing off.
14:59:05 <Sgeo> preflex, seen lambdabot
14:59:06 <preflex>  lambdabot was last seen on #haskell 52 seconds ago, saying: Unknown command, try @list
14:59:15 <Sgeo> preflex, seen preflex
14:59:15 <preflex>  what
14:59:16 <Sgeo> Ok, done
15:00:07 <HairyDude> apparently he maintains the dbus package, thought he might be around to tell him the homepage link listed for it on hackage is broken
15:03:55 <monochrom> Loading the "Beginning of meta-Haskell" thread through gmane in firefox takes forever! Perhaps I mean rendering.
15:08:26 <monochrom> bos's "riddle me this" is an "error establishing a database connection". Is that the riddle? <duck>
15:09:26 <jun__> what's the simplest route to rendering webpages in an Haskell gtk window?
15:10:57 <jun__> I'd like to be able to use something like webkit
15:11:12 <Alpounet> isn't there a webkit binding ?
15:11:29 <Saizan> is there? gtk2hs has mozembed iirc
15:12:56 <jun__> i'm struggling to find anything concerning webkit and haskell, so I'll use mozembed. thanks
15:14:31 <jun__> it appears to still be in development for gtk2hs unless I'm mistaken
15:22:38 <Saizan> 0.9.12 has a mozembed module
15:22:41 <dm`> Is there a way to do range queries with Data.Map?  I can't figure out how to get the first key k' >= k for some arbitrary k.
15:22:43 <Saizan> on the online docs
15:23:02 <Saizan> dm`: split?
15:23:21 <dm`> Ah yes.  I knew I must be missing something.
15:23:44 <dm`> Presumably because of laziness, split is just fine for my purposes.
15:23:51 <dm`> Thanks, Saizan!
15:24:53 <dons> dm`: interesting.
15:25:01 <dons> the judy lib can do that (but not the haskell bindings yet)
15:36:27 <BMeph> dons: Just wondering, but do you have anything like byorgey's 'split' package, but for ByteStrings? :)
15:38:52 <BMeph> On another note: does anyone know of windows binary of judy? I've had some trouble getting it to compile. :)
15:39:12 <BMeph> (This is the C lib, not the haskell binding. :)
15:43:20 <stivioo> where i can find the TPK implemention in haskell?
15:46:10 <dm`> Has anyone seen this error message:
15:46:10 <dm`> Setup: Haddock's internal GHC version must match the configured GHC version
15:46:10 <dm`>  
15:46:31 <dm`> Have re-installed haddock multiple times, and it works find on its own, but not through cabal.
15:46:34 <skorpan> stivioo: http://209.85.229.132/search?q=cache:_071bikmPBIJ:www.cs.fit.edu/~ryan/compare/tpk-hs.html+%22haskell%22+%22tpk%22&cd=1&hl=sv&ct=clnk&gl=se
15:47:22 <stivioo> thanx!!!
15:47:52 <skorpan> but i'm starting to think this may be your homework
15:48:41 <stivioo> nope.. just curiosity
15:49:59 <skorpan> i would probably have written it a bit different
15:50:04 <Saizan> dm`: do you have more than one ghc installed?
15:50:33 <dm`> No, I don't think so.  I deleted 6.10.2 and installed 6.10.4.
15:50:46 <dm`> But obviously I've failed to delete some old file or something.
15:51:28 <Saizan> well, check that haddock --ghc-version is the same version cabal picks for ghc
15:51:44 <dm`> That prints the correct version.
15:52:06 <Saizan> you can see which version cabal picks for ghc by using -v during configure
15:52:47 <Saizan> e.g.
15:52:50 <Saizan> Using ghc version 6.10.4 found on system at: /usr/local/bin/ghc
15:53:24 <dm`> So you mean like "cabal haddock -v"?
15:53:45 <Saizan> no "cabal configure -v"
15:55:07 <dm`> It prints a bunch of stuff, including
15:55:07 <dm`> Using ghc version 6.10.4 found on system at: /usr/bin/ghc
15:55:52 <Saizan> it should also say where it found haddock
15:56:05 <dm`> Using haddock version 2.4.2 found on system at: /usr/bin/haddock
15:56:05 <dm`>  
15:56:26 <Saizan> and that's the one with --ghc-version = 6.10.4?
15:56:32 <dm`> Correct.
15:56:51 <Saizan> can you try cabal haddock again? maybe it just needed reconfiguring
15:58:06 <dm`> Ah, it works!!!!  Thank you, thank you, Saizan.  Sorry for asking such stupid questions.  I guess I had to delete the whole package directory and untar it again.  I had run configure multiple times, but I guess not cleaned something up.
15:58:25 <dm`> I just can't live without cabal haddock --hyperlink-source.
15:58:41 <Saizan> heh, it's very handy, yeah
15:58:56 <dm`> If only there were a way to make "cabal install" do it by default.
16:06:35 <hackagebot> extcore 0.2 - Libraries for processing GHC Core (TimChevalier)
16:13:15 <dons> yay extcore
16:16:43 <ivanm> dons: why do you use base<10 for everything?
16:16:59 <ivanm> for the latest ghc-core, I know I had to force it to use base-3 because of the old-style exceptions it was using...
16:19:31 <dons> ivanm: oh, that's a bug.
16:19:37 <dons> did you send me a bug report?
16:19:41 <ivanm> nope
16:19:49 <ivanm> but I've been trying to get your attention here the last few days ;-)
16:21:16 <ivanm> are you trying to avoid future upgrade releases by making Cabal think they'll work up till ghc 6.18? :p
16:22:06 <dons> you have my attention.
16:22:22 <dons> i use <10 for packages that use a fairly standard set of extensions. its evil and wrong
16:23:10 <ivanm> heh
16:23:27 <ivanm> @remember dons i use [base]<10 for packages that use a fairly standard set of extensions. its evil and wrong
16:23:28 <lambdabot> Done.
16:34:44 <hackagebot> linkcore 0.1 - Combines multiple GHC Core modules into a single module (TimChevalier)
16:36:45 <hackagebot> extcore 0.3 - Libraries for processing GHC Core (TimChevalier)
16:55:52 <hackagebot> linkcore 0.2 - Combines multiple GHC Core modules into a single module (TimChevalier)
16:57:52 <hackagebot> bindings-common 1.1 - Support package for low-level FFI. (MauricioAntunes)
16:59:53 <hackagebot> bindings-posix 1.0.1 - Low level bindings to posix. (MauricioAntunes)
17:01:54 <hackagebot> bindings-libusb 1.1 - Low level bindings to libusb. (MauricioAntunes)
17:20:03 <hackagebot> judy 0.2.2 - Fast, scalable, mutable dynamic arrays, maps and hashes (DonaldStewart)
17:23:36 <orbitz> ah that can't be rihgt
17:23:42 <orbitz> my haskell code compiled first try
17:23:44 <orbitz> what did I do wrong?
17:24:21 <SamB_XP> orbitz: too many unsafeCoerce ?
17:24:28 <SamB_XP> you compiled the wrong code?
17:24:28 <largos> orbitz: did you forget hs-source-dirs?
17:24:34 <orbitz> SamB_XP: maybe I forgot to save and the file is empty
17:24:50 <SamB_XP> orbitz: huh, but wouldn't that mean there was no main ?
17:24:56 <orbitz> SamB_XP: ghci
17:25:07 <SamB_XP> what does :b say ?
17:25:17 <orbitz> looks good
17:25:20 <orbitz> all successful
17:25:31 <orbitz> I just don't suck at haskell as much as I used to apparently
17:26:19 <orbitz> brave new world
17:27:06 <dons> HacPDX is winding up.
17:27:34 <orbitz> hey dons
17:30:04 <darrint> I'm trying to do ghc --make C4 on a windows system and it builds .o files, but not executables. I have a main function. Do I need more?
17:31:22 <Axman6> --make C4 -o c4.exe?
17:31:51 <darrint> Warning: output was redirected with -o, but no output will be generated
17:31:51 <darrint> because there is no Main module.
17:31:55 <darrint> Ah...
17:32:02 <darrint> How do I tell it C4 == main?
17:32:22 <Axman6> add 'module Main where' at the top of the file?
17:32:39 <ClaudiusMaximus> darrint: --main-is  or have module Main in C4.hs (or no module declaration at all)
17:33:07 <darrint> Thanks.
17:35:59 <dons> what we were working on http://www.haskell.org/haskellwiki/HacPDX/Projects#What_we_worked_on
17:38:11 <orbitz> dons: looks like some good suggestions for projects someone learning the language could possibly help out on
17:44:55 <Axman6> dons: the extcore and linkcore stuff looks interesting. do you know if either of them make any effort to make reading Core any easier?
17:49:05 <orbitz> @pl \(x,_) (y, _) -> compare x y
17:49:05 <lambdabot> (`ap` snd) . (. fst) . (const .) . compare . fst
17:49:28 <zzzs> is there a way in haskell to allocate a block of memory the same way as in C's malloc?
17:49:44 <Makoryu> zzzs: And still have it be typesafe?
17:50:08 <c_wraith> orbits:  compare `on` fst
17:50:17 <c_wraith> :t compare `on` fst
17:50:18 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
17:50:36 <orbitz> hrm where is on defined?
17:50:42 <c_wraith> @index on
17:50:42 <lambdabot> bzzt
17:50:51 <c_wraith> Data.Functions
17:50:54 <c_wraith> or something like that
17:50:56 <orbitz> thanks
17:51:06 <Saizan_> ?hoogle malloc
17:51:06 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
17:51:06 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
17:51:06 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
17:51:07 <ivanm> @hoogle on
17:51:07 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:51:07 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
17:51:08 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
17:51:23 <ivanm> c_wraith: @hoogle usually works better than @index I find
17:51:32 <Saizan_> zzzs: we've malloc itself!
17:51:37 <c_wraith> ivanm: ah, noted.
17:51:59 <zzzs> Makoryu: yes. so any example of it would be to allocate a Page/block, then write data in the page, but it would still be of type Page
17:52:17 <Axman6> zzzs: usually you don't want to do this though (unless you're using the FFI to talk to C, or trying to write some very performance sensitive code)
17:54:36 <zzzs> Saizan_, any example of using the Foreign.Marshall.Alloc's malloc?
17:55:12 <zzzs> Axman6: yes, this is very perf sensitive
17:55:25 <Axman6> zzzs: what sort of thing are you doing?
17:56:48 <Saizan_> do ptr <- malloc; poke ptr (1 :: Int); i <- peek ptr; free ptr; print i
17:57:33 <zzzs> Axman6: i'm trying to write a performant search tree, such as B+tree, which would require allocating a page (for example, 64k), then manuplate that page with data, etc
17:58:10 <Saizan_> mallocBytes to malloc a given amount of bytes
17:58:30 <newsham> http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps <- red-black trees
18:00:28 <zzzs> Saizan_, thanks
18:00:37 <zzzs> newsham, i'll check out that paper, thanks
18:00:48 <JN234234> got disconnected... so I¥ll try asking again
18:00:53 <JN234234> whats a good way to get four Int values (a,b,c,d) out of a string that looks like "20 30 40 60"?
18:02:29 <Makoryu> :t reads
18:02:30 <lambdabot> forall a. (Read a) => String -> [(a, String)]
18:03:16 <Makoryu> > reads "20 30 40 60"
18:03:17 <lambdabot>   []
18:03:19 <Axman6> > map read . words $ "20 30 40 60" :: [Int]
18:03:20 <lambdabot>   [20,30,40,60]
18:03:27 <Makoryu> Whoops
18:04:06 <JN234234> great, thank you!
18:04:07 <ClaudiusMaximus> > map read . words $ "Whoops" :: [Int]
18:04:08 <lambdabot>   [* Exception: Prelude.read: no parse
18:04:51 <monochrom> IMO the best way is to use a real parser library.
18:06:05 <ivanm> using a parser is definitely easier than trying to make custom Read instances...
18:07:10 <largos> is Rational a type synonym?
18:07:43 <Axman6> @src Rational
18:07:43 <lambdabot> type Rational = Ratio Integer
18:07:48 <monochrom> Yes.
18:07:53 <largos> thanks!
18:08:08 <largos> one of these days I'll remember @src :)
18:09:51 <monochrom> IMO not really worth it because there are lots of obvious things that @src doesn't know.
18:10:14 <monochrom> I guess it's harmless to try.
18:10:39 <Axman6> it would be really nice of haskell libraries has some section in them that let you use @src on any librry you had imported (and was exported by the library)
18:10:53 <Axman6> in ghci*
18:11:08 <Makoryu> Axman6: Patch lambdabot to work that way
18:11:21 <Makoryu> I think it actually has enough information already
18:11:42 <Axman6> patch? that sounds like work :P
18:11:45 <wdonnelly> if I parse that suggestion right, I think GOA already has that ability
18:12:06 <SamB_XP> wdonnelly: no, I don't think you do
18:12:20 <Axman6> wdonnelly: yeah it probably does
18:12:26 <Axman6> or something like it
18:12:39 <Saizan_> libraries are installed without source
18:12:42 <SamB_XP> the idea is to somehow get the definition of *anything* and show it, isn't it ?
18:12:54 <mmorrow> zzzs: mmap is just a foreign import unsafe away http://moonpatio.com/repos/ohhai.hs
18:12:55 <byorgey> I thought the @src database is basically hard-coded?
18:12:55 <Saizan_> so it can only work for the sources in your working tree, as of now
18:13:07 <wdonnelly> ah, yeah, GOA only gives a link to the source, it doesn't find it for you
18:13:34 <Axman6> lame
18:13:42 <Saizan_> it can work if you install all your libs with haddock --hyperlink-source
18:14:11 <Saizan_> then you can generate an hoogle database and use hoogle --info to get a link to the source
18:15:01 <zzzs> mmorrow: thanks for the mmap tip
18:15:08 <SamB_XP> then you use hrowser to actually follow the link ?
18:15:24 <ivanm> for whoever I was talking with the other day about long lines in ghci running in emacs, the hack at the bottom of this page seems to work as well: http://sites.google.com/site/haskell/notes/ghci610emacsmadness
18:15:29 <zzzs> newsham: know of any B-tree implemenation?
18:16:26 <Axman6> zzzs: have you tried any of the native haskell alternatives by the way?
18:16:44 <Saizan_> mh, i think you get a link to the haddock docs, so you've to follow the link to the source from there
18:17:22 <Saizan_> SamB_XP: or HTTP to write a script that extracts it?
18:17:45 <Saizan_> s/it/the source/
18:18:13 <SamB_XP> Saizan_: hrowser was intended to be the name of a web-browser-as-Haskell-library kind of thing ...
18:18:55 <Saizan_> SamB_XP: ah, i thought it was intended to be an executable
18:19:04 <wdonnelly> selenium actually works pretty well with Haskell
18:19:13 <wdonnelly> for that kind of web-browser interfacing
18:19:23 <newsham> zzz: i dont
18:20:00 <wdonnelly> only selenium's much too heavy-weight for little scripting tasks
18:20:06 <newsham> not all imperative data structures map well to functional languages
18:20:19 <Axman6> FARK!
18:20:26 <Axman6> cabal-install is broken :'(
18:20:27 <mmorrow> zzzs: if i were looking for a b-tree implem, i'd probably start with database code
18:20:35 <ivanm> Axman6: :o
18:20:38 <ivanm> how is that possible?
18:20:39 <mmorrow> zzzs: sqlite, postgres, etc
18:20:44 <ivanm> static linking, etc.
18:20:45 <Axman6> it can;t download anything, gets a bus error
18:20:55 <ivanm> Axman6: sure it's not a net problem?
18:20:58 <Saizan_> aw
18:21:01 <Axman6> no, it
18:21:03 <ivanm> can you wget anything manually from the command line?
18:21:12 <Axman6> it's definitely the program crashing hard
18:21:39 <zzzs> Axman6: do you mean implement it in C, then call in from haskell?
18:21:54 <Axman6> zzzs: i mean implemented in haskell.
18:22:08 <byorgey> a bus error?  try recompiling with -fsubway, perhaps
18:22:12 <ivanm> byorgey: heh
18:22:21 <ivanm> @remember byorgey a bus error?  try recompiling with -fsubway, perhaps
18:22:21 <lambdabot> Okay.
18:22:34 <zzzs> Axman6: i.e., w/o explicit memory manuplation?
18:22:41 <Axman6> yes
18:23:16 <zzzs> mmorrow: yes, i've looked at those, but i'm wondering if it's any easier to implement it in haskell, with STM
18:24:25 <zzzs> Axman6: i haven't tried, though i suspect that it will be slow w/o explicit memory management
18:24:27 <mmorrow> zzzs: hmm, STM is really nice for convenience/assurance, but if it's performance you're going for may want to look at other options
18:25:02 <mmorrow> zzzs: STM vs. peek/poke on an mmap'ped memory page are like night and day
18:25:11 <Axman6> zzzs: well, it's worth a try. in my experience, it's often not worth trying fix a problem you haven't actually hit yet
18:26:46 <zzzs> mmorrow: so adding explicit locking w memory page is going to much faster than stm then?
18:27:12 <zzzs> Axman6, you might be right, just want to think things through
18:27:45 <Axman6> what sort of structure is a red-black tree anyway? i've heard of them, but never actually found out what they are
18:27:54 <ivanm> Axman6: a well-balanced tree IIRC
18:28:02 <ivanm> usually with quite good performance
18:28:19 <Axman6> map type tree?
18:28:24 <ivanm> nodes are coloured either red or black, and can change colour based on their position in the tree
18:28:27 <Axman6> or just a tree?
18:28:32 <ivanm> just a tree
18:28:36 <Saizan_> a search tree
18:28:41 <ivanm> yeah
18:28:56 <Axman6> i was thinking that this judy stuff dons has been working on might be helpful
18:28:59 <ivanm> duh, is that what you meant by a map-type tree Axman6?
18:28:59 <Axman6> but maybe not
18:29:17 <Saizan_> so you can use it to implement interfaces like Data.Set or Data.Map
18:29:19 <Axman6> well, i meant a map like Data.Map
18:29:49 <ivanm> the problem with judy IMHO is that it's IO... and I've never had that big a performance problem that I think I'd need to resort to using IO for data structures :s
18:30:01 <ivanm> well, Data.Map is just a search tree, isn't it?
18:30:13 <ivanm> find the node in the tree, return the extra value stored at that node
18:30:26 <ivanm> which is why there's a keySet function (just strip the lookup bit)
18:30:42 <mmorrow> zzzs: i'd say it's almost a sure bet (that "explicit locking w memory page is going to much faster than stm"). but i guess the question is how critical is it that it be lightning fast?
18:32:14 <mmorrow> if it'd critical, then it's critical and personally i wouldn't use STM in that situation, but otoh if you're more of doing an experimental thing, then by all means you should check out STM
18:32:55 <mmorrow> (critical wrt speed)
18:33:01 <Saizan_> an ST+freeze interface for these judy arrays might be nice for the use cases where you stop inserting after you've loaded the data
18:33:01 <ivanm> how hard would it be to change from STM to manual locking later on?
18:33:24 <ivanm> I'm guessing if you write your code properly, it won't make _that_ much of a difference compared to the rest of the library/app
18:33:29 <ivanm> (in terms of LoC)
18:34:09 <thoughtpolice> there are certain things which are extremely hard to do without an STM, like have a 'consistent world state'
18:35:11 <thoughtpolice> and thus, it can become extremely hard when you need to make decisions based on a totally consistent state
18:35:14 <thoughtpolice> http://groups.google.com/group/comp.lang.lisp/msg/a86c91091ae16970
18:35:40 <thoughtpolice> ^^ rich hickey is the guy behind clojure, and has thought about this stuff a lot. that post is a reflection of the problems STMs make easy which are nontrivial with locks
18:36:19 <ddarius> If you are touching disk, the overhead of STM shouldn't be that big a deal ...
18:38:23 <zzzs> if i were to use locks, is there a foreign function for pthread's mutex, etc?
18:41:26 <zzzs> the judy array is nice, but it only support fixed lengeth key i think
18:42:02 <bd_> zzzs: Data.Array's the same, you know - that's what typeclass Ix does
18:43:01 <Axman6> hmmmmmm, a stack trace would be super useful right now :(
18:43:19 <Axman6> i have no idea why cabal-install crashes when trying to download anything
18:43:27 <orbitz> where is the name Ix from?
18:43:47 <orbitz> index?
18:43:58 <ddarius> Most likely.
18:44:16 <ddarius> You can potentially find mailing list articles discussing this when they defined the Ix class.
18:44:33 <ivanm> ddarius: they had mailing lists back then? :p
18:44:38 <Saizan_> thoughtpolice: so a transaction trying to read all the "TVar"s that make up the state won't starve in clojure?
18:45:18 <mmorrow> zzzs: the FFI is super easy
18:46:37 <Axman6> "easy"
18:46:52 <orbitz> Axman6: nono, "super easy"
18:50:30 <zzzs> mmorrow: using FFI for mutex/lock, does that mean that most of the code in critical section should be in C as well?
18:50:49 <mmorrow> zzzs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9910#a9910
18:51:04 <mmorrow> zzzs: how serious are you about speed?
18:52:34 <mmorrow> zzzs: well, the nice thing about the FFI is you can pick and choose
18:53:07 <mmorrow> zzzs: ghci makes a handay C interpreter (since foreign import unsafe ccall "adsfadsf" c_asdfasdf :: C.. ->  is so cheap)
18:53:36 <thoughtpolice> Saizan_: I'm not totally familiar with the STM implementation, it's based in MVCC, in that particular case I couldn't be sure :p
18:54:07 <mmorrow> zzzs: one nice thing is to model what you're after in haskell first, then take it from there
18:54:21 <zzzs> mmorrow: i want this to be comparable to C -- unless i'd be better off starting from C
18:55:19 <mmorrow> zzzs: in that case, i'd write the hole core datastructure, operation on it in C, and then FFI import the self-contained unit as a whole
18:55:26 <mmorrow> s/hole/whole/ :)
18:56:01 <mmorrow> and use haskell to orchestrate it
18:57:21 <zzzs> thanks mmorrow
18:57:39 <mmorrow> no problem
18:58:38 <Axman6> zzzs: if you want a mutex, why not just use an MVar ()?
19:01:43 <zzzs> Axman6: an example? and is that the recommended way for mutex
19:01:47 <zzzs> in haskell
19:02:00 <Axman6> in haskell it would be, yes
19:02:50 <Axman6> mutexedFunc (Foo mut data) = do {takeMVar mut; doWork data; putMVar mut ()}
19:03:30 <Axman6> you could also have signal mut = putMVar mut () and wait = takeMVar
19:04:19 <mmorrow> zzzs: the nice thing about mvars is that they're locks you can put things inside
19:04:54 <mmorrow> but only one thing
19:05:09 <Axman6> yeah, a better way to do things would be: mutexedFunc var = do {data <- takeMVar var; putMVar var (foo data)}
19:05:14 <mmorrow> even another MVar
19:07:39 <Trinithis> how do you raise a fractional or a floating number x by itself?
19:07:49 <Axman6> data MVardList a = ML (a, Maybe (MVar (MVardList a)))
19:07:56 <zzzs> any tutorials on MVar()? this seems to pretty neat
19:08:01 <Axman6> > join (^) 10
19:08:02 <lambdabot>   10000000000
19:08:14 <Trinithis> > pi ^ pi
19:08:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:08:15 <lambdabot>    `GHC.Float.Floating a'
19:08:15 <lambdabot>  ...
19:08:22 <Axman6> zzzs: MVars are lovely, and they're damn fast too
19:08:48 <Axman6> zzzs: take a look at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
19:09:08 <Axman6> win 20
19:09:50 <zzzs> thanks
19:11:20 <Trinithis> > let p = (pi :: Double) in p ^ p
19:11:20 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
19:11:20 <lambdabot>    arising from a use ...
19:11:39 <Trinithis> @ty (^^)
19:11:40 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
19:11:43 <Trinithis> @ty (^)
19:11:44 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
19:13:13 <Axman6> > join (**) 10
19:13:13 <lambdabot>   1.0e10
19:13:26 <Axman6> Trinithis: you want **
19:13:32 <Trinithis> thx
19:14:19 <Makoryu> :t (**)
19:14:20 <lambdabot> forall a. (Floating a) => a -> a -> a
19:14:23 <Makoryu> Huh
19:25:01 <dancor> > pi ** pi
19:25:02 <lambdabot>   36.4621596072079
19:25:07 <kbp> Hi I need help. Let say I have [(String,Int)] is there any function that I can find the max(Int) from the list?
19:25:23 <dibblego> @type maximumBy snd
19:25:24 <lambdabot>     Occurs check: cannot construct the infinite type:
19:25:24 <lambdabot>       b = (a, b) -> Ordering
19:25:24 <lambdabot>     Probable cause: `snd' is applied to too many arguments
19:25:37 <wiretapped> what is a monad?
19:25:54 <dancor> :t maximumBy (compare `on` snd)
19:25:54 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
19:26:04 <VonGuard> damn
19:26:32 <VonGuard> maybe a gonad?
19:26:34 <dancor> > maximum $ map snd [("a", 10), ("b", 20)]
19:26:35 <lambdabot>   20
19:26:49 <kbp> wow that's cool. thank you
19:26:50 <dibblego> wiretapped, http://code.google.com/p/monad-tutorial is a WIP or you can use an existing tutorial
19:27:10 <wiretapped> dibblego: thanks
19:27:15 <dancor> ya this is the kind of stuff that is coolest in functional programming
19:27:18 <Axman6> wiretapped: they're a way of chaining computations together
19:27:43 <Axman6> @hoogle comparing
19:27:43 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
19:27:50 <kbp> $ 20+11
19:28:04 <Axman6> kbp: if you import Data.Ord, you can use maximumBy (comparing snd)
19:28:14 <dibblego> @type maximumBy (comparing snd)
19:28:15 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
19:28:15 <dancor> > 20+11
19:28:15 <lambdabot>   31
19:28:51 <kbp> thank alot I know how to use lambdabot now
19:29:17 <dancor> @vixen does learning lambdabot change your life?
19:29:17 <lambdabot> isn't it obvious?
19:50:43 <coco> @pl \x y -> g x (f y)
19:50:43 <lambdabot> (. f) . g
19:50:58 <coco> @pl \x y -> f (g x y)
19:50:59 <lambdabot> (f .) . g
19:51:29 <absentia> FoG man, F o' G ..
19:51:35 <Vanadium> @pl \(a, b, c) -> a
19:51:35 <lambdabot> (line 1, column 7):
19:51:35 <lambdabot> unexpected ","
19:51:35 <lambdabot> expecting letter or digit, operator or ")"
19:51:35 <lambdabot> ambiguous use of a non associative operator
19:52:18 <Axman6> FFFUUUUUUU!
19:52:38 <Axman6> trying to get criterion installed, but Chart can't seem to load gtk >_<
19:54:24 <Cale> Axman6: Do you have Gtk2Hs installed?
19:54:27 <Axman6> yes
19:54:55 <Axman6> i even tell cabal-install where the library it can't find is and it won't load it
19:56:12 <Axman6> cabal install chart --extra-include-dirs=/opt/local/include --extra-lib-dirs=/opt/local/lib
19:56:17 <Axman6> ...
19:56:17 <Axman6> Loading package gtk-0.10.0 ... <command line>: can't load .so/.DLL for: gthread-2.0 (dlopen(libgthread-2.0.dylib, 9): image not found)
19:56:30 <Cale> I'll give is a shot, and see how it goes.
19:56:32 <Cale> it*
19:56:39 <Axman6> locate libgthread-2.0.dylib -> /opt/local/lib/libgthread-2.0.dylib
19:56:52 <Cale> Though, I'm not on a mac
19:57:30 <Axman6> i get the same problem in ghci as well
19:58:09 <Cale> I would say something is broken with your installation of the gtk package. I don't think you should have to explicitly tell it where to look for the library.
19:58:23 <Axman6> yeah i can try installing gtk again i guess
19:58:43 <Cale> Chart installs okay here... ghc-pkg list gtk tells me:
19:58:52 <Cale> /usr/local/lib/ghc-6.10.3/./package.conf:
19:58:53 <Cale>     gtk-0.10.1
19:59:11 <Cale> I didn't have to pass any extra commandline options.
19:59:57 <Axman6> /opt/local/lib/ghc-6.10.3/./package.conf: gtk-0.10.0
20:00:12 <Saizan_> maybe you need include-dirs/framwork-dirs set in "ghc-pkg describe gtk"
20:01:08 <Axman6> i'll try reinstalling glib2
20:01:16 <Axman6> which provides libgthread
20:04:52 <absentia> hi axman6
20:04:57 <Axman6> o/
20:05:48 <fnord123> does readfloat  handle scientific notation?
20:06:01 <Axman6> :t readFloat
20:06:02 <lambdabot> forall a. (RealFrac a) => String -> [(a, String)]
20:06:15 <Axman6> > readFloat "1.0e10"
20:06:16 <lambdabot>   [(1.0e10,"")]
20:07:43 <fnord123> cool!
20:07:59 <fnord123> I wonder if we can get lambdabot to recognize locales...
20:08:09 <fnord123> > readFloat "1,0e10"
20:08:10 <lambdabot>   [(1.0,",0e10")]
20:13:51 <ivanm> fnord123: seeing as how ghc doesn't seem to do locales properly yet, I doubt it :(
20:14:01 <ivanm> (though IIRC 6.12 will... \o/ )
20:14:01 <Axman6> god damn it, still can't fing libgthread. wtf!
20:14:08 <ivanm> "fing"?
20:14:15 <Axman6> find*
20:14:25 <ivanm> locate libgthread
20:14:25 <ivanm> :p
20:14:44 <blackdog> Axman6: are you trying to get gtk2hs working on mac?
20:14:47 <Axman6> _I_ can find it, the gtk2hs refuses to. it installed fine, but i can't use it
20:14:50 <Axman6> blackdog: yes
20:14:56 <blackdog> getting the same problem
20:15:39 <blackdog> ghci -package gtk is not at all happy
20:16:02 <blackdog> (let me guess, you want bos's benchmark app too?)
20:16:52 <Axman6> ckwhat the
20:16:53 <Axman6> !
20:17:35 <Axman6> fucking safari
20:20:10 <blackdog> any mac users here managed to get gtk2hs going? is there some special sauce/
20:20:22 <ivanm> yes, hot mango chilli
20:20:23 <ivanm> ;-)
20:20:25 <Axman6> it works on leopard i believe
20:20:28 <Makoryu> blackdog: Yes. We have to switch to Linux :(
20:20:41 <blackdog> Axman6: I'm using Leopard and i get that error
20:20:56 <Axman6> oh lame
20:21:14 <blackdog> Makoryu: not so much fun if you want to make sure your app runs right on Mac :/
20:21:49 <Makoryu> blackdog: You can ensure that it runs right by ensuring that your users switch to Linux
20:22:01 <Axman6> fuck linux
20:22:09 <blackdog> Makoryu: this is not my beautiful OS, and I am not RMS
20:22:24 <blackdog> Axman6: at least you know you won't get a virus...
20:22:38 <Axman6> especially not a gtk one >_<
20:22:43 <ivanm> Makoryu: that is a nice end-goal, but you don't have to troll it
20:24:15 <Makoryu> ivanm: Yeah, I'm trolling a little. I'm trolling because I'm bitter about how OS X is basically disregarded by Haskell devs. Worse still, because I feel bitter, it's hard to do anything productive about the situation without feeling even more bitter.
20:24:31 <Makoryu> Also, frosted butts.
20:24:43 <ivanm> how is it disregarded by haskell devs in general?
20:24:44 <hydo> mmm frosting.
20:24:52 <ivanm> for the most part, haskell code is cross-platform
20:25:01 <blackdog> Makoryu: almost no-one's getting paid to work on this stuff, though. you scratch your own itch, and the ghc crew are pretty good about responding to patches for Mac.
20:25:01 <ivanm> but if the dev doesn't have a mac to test on, he can't ensure that
20:25:16 <kbp> I have x = "value is " ++ y, where x :: String, y :: Int, it doesnt work... how to make it work then?
20:25:17 <dancor> what is standard for failing out of MaybeT?  fail ""?
20:25:23 <ivanm> (if he _really_ want to, he can use wine/cygwin to test win-on-nix/nix-on-win)
20:25:28 <ivanm> s/he/they/
20:25:36 <ivanm> let's ensure we're gender-generic :p
20:25:43 <Axman6> Makoryu: i'm right with you. i very much dislike the amount of OS X support GHC has
20:25:54 <ivanm> kbp: show y
20:25:57 <ivanm> @type show
20:25:58 <blackdog> ivanm: i was thinking about a system for really fast continuous integration
20:25:58 <lambdabot> forall a. (Show a) => a -> String
20:26:06 <Makoryu> Axman6: You know what else grinds my gears? TextMate! >:|
20:26:10 <kbp> nice! thanks ivanm
20:26:13 <ivanm> blackdog: as in "testing it works together" or calculus?
20:26:19 <Axman6> how can you not like textmate?
20:26:23 <blackdog> testing
20:26:54 <blackdog> the idea would be to have a bunch of EC2 machines that fire up every hour, pull in the latest ghc source, compile everything on a variety of platforms, submit the test results, then shut down again
20:27:11 <blackdog> it'd be fast, and pretty cheap because they don't need to run for that long
20:27:29 <blackdog> it all got snagged up because you're not allowed to run mac os virtualised except on dinky-di hardware
20:27:30 <ivanm> EC2?
20:27:39 <ivanm> heh, about to say...
20:27:39 <blackdog> and frankly, mac is what i care about at the moment.
20:27:48 <blackdog> amazone's elastic compute cloud
20:28:06 <Makoryu> Axman6: The nice features are crippled by shitty infrastructure and excruciatingly slow development
20:28:07 <ivanm> see, if all OSs were POSIX, we'd have less of a problem... :p
20:28:15 <Axman6> OS X is POSIX
20:28:32 <ivanm> blackdog: I thought it was something like that, but wondered how you'd test different platforms/arches on them
20:28:41 <Adamant> ivanm: it's POSIXer than Linux even :P
20:28:44 <ivanm> heh
20:28:49 <blackdog> how much does POSIX really buy you? wasn't NT technically posix?
20:28:52 <ivanm> though that is a valid problem with windows
20:28:58 <ivanm> blackdog: I think partially...
20:29:18 <LegendaryPenguin> dont fuck with posix
20:29:32 <blackdog> realistically, no-one relies just on POSIX. look at the kerfuffle about fsync and aggressively caching filesystems...
20:29:43 <Adamant> it had a POSIX subsystem
20:29:54 <Adamant> also had a OS/2 subsystem
20:30:08 <Adamant> the POSIX subsystem is now Unix For Windows
20:30:17 <Adamant> the OS/2 subsystem is dead
20:30:59 <blackdog> ivanm: different architectures are hard. platforms are pretty easy.
20:31:10 <blackdog> at one stage i was contemplating running a VM on the VM :)
20:31:15 <ivanm> *shudder*
20:31:33 <ivanm> blackdog: IIRC, that came about because POSIX isn't well defined enough
20:32:15 <blackdog> ivanm: well, yeah. that's more or less what i'm saying. POSIX says one thing, but everyone relies on this implicit behaviour
20:33:07 <orbitz> what is th esuggested way to debug array indexing issues?
20:34:00 <blackdog> orbitz: use higher level combinators than array indexing if you can, otherwise unit test in small pieces.
20:34:18 <orbitz> drats
20:34:52 <blackdog> orbitz: but of course you're unit-testing all your code anyway, right?
20:34:58 <ivanm> orbitz: trace statements can help
20:35:15 <orbitz> blackdog: nein
20:35:19 <bos> unit testing? that's 20th century tech.
20:35:19 <lambdabot> bos: You have 4 new messages. '/msg lambdabot @messages' to read them.
20:35:27 <blackdog> bad hacker! go directly to jail, do not pass go.
20:35:29 <ivanm> orbitz: writing wrapper functions around getting values from arrays, etc. with custom error messages that tell you which indices were being used, etc.
20:35:39 <copumpkin> real men prove their code is correct
20:35:45 <blackdog> bos: better stone tools than no tools at all
20:35:49 <orbitz> I'm playing around with calculating a scoring matrix for alignments using sensual lazy evaluatio magix
20:35:54 <ivanm> copumpkin: no, real men write correct code directly ;-)
20:35:56 <copumpkin> unfortunately I'm not a real man and fail miserably at proving things :)
20:35:57 <ivanm> blackdog: I've never unit-tested my code...
20:36:11 <orbitz> ivanm: what can I do about getting a stack trace or something?
20:36:23 <copumpkin> orbitz: use GHC HEAD
20:36:27 <blackdog> ivanm: seriously? what do you use instead? types don't cover _everything_...
20:36:30 <fnord123> where are instances of Alternative for GenParser defined? I can't seem to find it..
20:36:40 <copumpkin> blackdog: in some languages they do :P
20:36:42 <orbitz> copumpkin: workable on OS X?
20:36:47 <copumpkin> orbitz: sure
20:36:53 <ivanm> blackdog: manual testing, going "oh shit there's a bug", etc.
20:36:54 <copumpkin> orbitz: or wait a few days for the 6.12 RC
20:37:01 <bos> fnord123: they're not.
20:37:11 <ivanm> blackdog: for some stuff I write, it's not possible to test...
20:37:15 <ivanm> because I'm generating data, etc.
20:37:24 <copumpkin> ivanm: what you need is a proof!
20:37:33 <blackdog> copumpkin: sure, once your types approach the complexity of the tests you would have had to write :)
20:37:43 <ivanm> copumpkin: the idea is, I'm trying to generate enough data so that I can try to come up with a theorem!
20:37:53 <copumpkin> blackdog: yeah, but you're 100% sure it meets specifications at that point :P
20:37:54 <ivanm> bit hard to prove an as-yet-non-existent-theorem... :(
20:37:54 <blackdog> ivanm: everything is possible to test...
20:38:00 <fnord123> oh jeez, i found it in RWH on page 396
20:38:12 <fnord123> dunno how i missed this. hurrrr
20:38:15 <ivanm> blackdog: not fully
20:38:35 <blackdog> ivanm: oh, sure. but you should at least have some trivial properties that you know always ought to hold.
20:38:49 <ivanm> yeah
20:39:01 <blackdog> if you need 100%then you really do need to prove the code correct...
20:39:07 <ivanm> but with that particular bit of code, I got sidetracked trying to improve performance
20:39:14 <ivanm> jyp's HGAL is bog slow :@
20:39:35 <blackdog> my incorrect code runs faster than your incorrect code :)
20:40:05 <kbp> generateBoolExp (Var x) y z = 'Bvar \"'++x++'\" '++show(y)++' '++show(z) <--- improperly terminated character constant ?
20:40:31 <blackdog> ivanm: more seriously, i get really scared trying to optimise code i haven't tested. how do you know it still does the right thing?
20:40:48 <Makoryu> http://nsl.com/papers/origins.htm <- Good god. I can't even understand the first line :|
20:40:52 <ivanm> blackdog: I have previously produced data from older, dodgier programs
20:40:55 <Makoryu> (Of actual code, I mean)
20:40:56 <ivanm> I use them to test
20:41:10 <ivanm> I'm trying to do less of a brute-force approach
20:41:41 <blackdog> ivanm: oh, fair enough. always nice to have a reference implementation - thought of packaging it up as QC property?
20:41:49 <ivanm> Makoryu: I think it's "type C = char, type I = long"
20:41:58 <Fragsworth> Sometimes when I check this channel, I can't shake the feeling that people are typing some very strange ASCII sex symbols.
20:41:59 <ivanm> blackdog: heh, too damn slow for QC
20:42:15 <Makoryu> ivanm: I should have specified: The first function definition.
20:42:22 <ivanm> e.g. 1.5 hrs for 5x5, a couple of weeks for 6x6
20:42:45 <ivanm> Makoryu: heh, I only have enough C knowledge to get the gist of wtf is going on ;-)
20:42:55 <blackdog> Makoryu: I met up with a J advocate in NY a couple of days ago - was meant to be the FP meetup and we were the only ones there:)
20:43:09 <ddarius> J is fun.
20:43:42 <Axman6> kbp: strings use ", not '
20:44:49 <kbp> Axman6: if i use "abc \"cdf\"" , it doesnt print out abc "cdf" as expected (instead it prints abc\"cdf\")
20:45:14 <Axman6> kbp: where exactly?
20:45:21 <Makoryu> > "abc\"cdf\""
20:45:22 <lambdabot>   "abc\"cdf\""
20:45:32 <ivanm> > text "abc \"cdf\""
20:45:32 <kbp> yea, like that
20:45:33 <lambdabot>   abc "cdf"
20:45:37 <blackdog> ddarius: i'm still trying to grasp it. does it have any fundamental advantages over Haskell?
20:45:41 <Makoryu> > text "abc\"cdf\"" -- But don't use "text" in your program
20:45:42 <lambdabot>   abc"cdf"
20:45:51 <Axman6> kbp: how are you printing it?
20:45:52 <ivanm> blackdog: J? it's more "wtf" than Haskell in terms of reading it... ;-)
20:46:07 <Axman6> main(){C s[99];while(gets(s))pr(ex(wd(s)));}
20:46:11 <Axman6> obvious!
20:46:12 <Axman6> >_>
20:46:24 <kbp> Axman6: through hugs
20:46:37 <Axman6> well use putStrLn
20:46:37 <ivanm> that's one bit of code that no-one ever expected to have to fix up down the track...
20:46:45 <blackdog> ivanm: yeah. i'm trying not to get a Blub reaction, i'd really like to see a J construction that does something Haskell can't do easily
20:47:12 <ivanm> I find J a bit too terse/symbolic for my tastes (which is just from reading wikipedia :p )
20:48:35 <ddarius> blackdog: I would never use J to program for real (for mostly superficial reasons), but it is fun to work with.  What J is good at, it is way better at than Haskell.
20:48:47 <ivanm> ddarius: being unreadable? :p
20:49:00 <ddarius> ivanm: It actually quickly becomes surprisingly readable.
20:49:16 <ddarius> Except for some bits of complete insanity.
20:49:31 <Makoryu> :t \($#)(&%) -> (&%($#))<$>(&#)
20:49:32 <lambdabot> Not in scope: `&#'
20:49:36 <Makoryu> Whoops
20:49:38 <Makoryu> :t \($#)(&%) -> (&%($#))<$>(&%)
20:49:39 <lambdabot> forall t b. t -> ((t -> b) -> t -> b) -> (t -> b) -> b
20:49:44 <blackdog> ddarius: not looking for engineering superiorities - just an intuitive understanding of what it's good for and why haskell can't ship that functionality as a library
20:50:05 <nvoorhies> J's central thesis is basically that after you get proficient you think in the syntax of the language, and brevity thus means power, but I've never really found myself making that jump completely in any language.
20:50:26 <ddarius> blackdog: Haskell can ship the functionality as a library.
20:50:41 <Makoryu> blackdog: J has some implicit stuff going on that's hard to implement in Haskell without being explicit about it.
20:50:53 <ivanm> nvoorhies: isn't that what most languages assume/expect?
20:51:02 <ivanm> after all, don't we all think in lambdas? :p
20:51:30 <lispy|web> ivanm: I don't know about that, but lambdabot certainly helps me think...
20:51:36 <nvoorhies> ivanm: yeah but Iverson really went full-tilt with it.  c.f. his turing lecture and the book "A Programming Language" etc.
20:51:52 <sshc> can I refer to a bytstring function (Data.ByteString.Lazy.take, for example)) without importing it?
20:52:00 <ddarius> sshc: No
20:52:01 <lispy|web> sshc: no
20:52:20 <nvoorhies> by turing lecture I mean Turing Award Lecture
20:52:21 <lispy|web> ?faq Can I refer to a function without importing it?
20:52:21 <lambdabot> The answer is: Yes! Haskell can do that.
20:53:49 <sshc> lispy|web: you said no but the faq says yes?
20:54:27 <sshc> if not, can I have take refer to the one defined in prelude in default while allowing bytstring take to be used if I type Data.ByteString.take ?
20:54:28 <dolio> @faq What is the cube root of 3?
20:54:28 <lambdabot> The answer is: Yes! Haskell can do that.
20:54:31 <lispy|web> sshc: the FAQ tends to be a bit optimistic
20:54:47 <ddarius> sshc: Yes.
20:54:47 <lispy|web> ?faq Can I solve the halting problem with Haskell?
20:54:47 <lambdabot> The answer is: Yes! Haskell can do that.
20:54:59 <ddarius> sshc: import qualified Data.ByteString
20:55:05 <sshc> lispy|web: hmm, can I omit the "as"  part after qualified?
20:56:08 <sshc> thanks
20:58:30 <ddarius> blackdog: The main thing to get from J is a style of programming, array-oriented programming, rather than some new language feature.
20:58:42 <fnord123> @faq Can Haskell make me a sandwich now?
20:58:42 <lambdabot> The answer is: Yes! Haskell can do that.
20:58:54 <ivanm> fnord123: it can, but _will_ it?
20:58:56 <fnord123> great. ham on rye, pls
20:59:02 <ivanm> (you need to say "sudo", don't forget! :p)
20:59:45 <Axman6> > simonSaysPerformIO $ make "fnord123" ASandwich
20:59:45 <lambdabot>   Not in scope: `simonSaysPerformIO'Not in scope: `make'Not in scope: data co...
20:59:48 <copumpkin> Axman6: you should make a new cario-free pure haskell chart library for criterion! then it could be liberated from the gtk dependency :P
21:00:10 <copumpkin> *cairo
21:00:14 <Axman6> copumpkin: that would be ideal, but i doubt it will happen anytime soon
21:00:27 <fnord123> gui combinator, pls!
21:00:31 <copumpkin> it definitely won't happen if nobody writes it!
21:02:20 <orbitz> is there an sprintf?
21:02:31 <ddarius> Yes.  printf
21:02:39 <copumpkin> orbitz: printf can return a string or an IO
21:02:51 <orbitz> ohhh that return type thing always gets me
21:03:07 <ivanm> @type printf
21:03:08 <lambdabot> forall r. (PrintfType r) => String -> r
21:03:17 <ivanm> @instances PrinfType
21:03:19 <lambdabot> Couldn't find class `PrinfType'. Try @instances-importing
21:03:19 <ivanm> @instances PrintfType
21:03:20 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
21:03:25 <ivanm> @hoogle PrintfType
21:03:25 <lambdabot> Text.Printf class PrintfType t
21:03:25 <lambdabot> Text.Printf class HPrintfType t
21:03:32 <ivanm> @instances-importing Text.Printf PrintfType
21:03:33 <lambdabot> (a -> r), IO a, [c]
21:03:48 <ivanm> I'm guessing it's the (a -> r) bit that lets printf do magic type-system stuff?
21:03:55 <copumpkin> varargs
21:06:38 <monochrom> > printf "String!" :: String
21:06:39 <lambdabot>   "String!"
21:07:26 <ivanm> > printf "IO()!!" :: IO String
21:07:27 <lambdabot>   <IO [Char]>
21:07:29 <ivanm> heh
21:07:41 <aavogt1> > printf "hello%d%d%d%d" 1 2 3 4 :: String
21:07:42 <lambdabot>   "hello1234"
21:07:48 <aavogt1> > printf "hello%d%d%dd" 1 2 3 4 :: String
21:07:49 <lambdabot>   "hello123d* Exception: Printf.printf: formatting string ended prematurely
21:08:07 <blackdog> Axman6: light a candle or curse the darkness, it's up to you...
21:08:08 <copumpkin> yay runtime errors
21:08:17 <fnord123> wow literate haskell is awesome when implementing a spec. just have the spec in the text file and fill in the code at appropriate places. Whoever came up with lhs is a genius
21:08:23 <monochrom> > printf "Money!" :: Money
21:08:23 <lambdabot>   Not in scope: type constructor or class `Money'
21:08:29 <Axman6> blackdog: hmm?
21:08:36 <blackdog> fnord123: Knuth, I guess,  so yes :)
21:08:40 <ddarius> fnord123: The idea goes back to Knuth.
21:08:41 <blackdog> Axman6: the gtk2hs stuff
21:08:41 <Axman6> wait, blackdog = mwotton?
21:08:44 <fnord123> @faq Can haskell print money?
21:08:44 <lambdabot> The answer is: Yes! Haskell can do that.
21:08:51 <copumpkin> Axman6: yep
21:08:54 <blackdog> Axman6: my secret identity! Oh Noes!
21:08:57 <Axman6> ah, i see :)
21:09:09 <blackdog> Axman6: wait, did you just test me for equality or assign me?
21:09:09 <ivanm> copumpkin: yeah, that's the annoying thing with printf :s
21:09:27 <Axman6> blackdog: are you feeling lucky punk? :P
21:09:32 <ivanm> blackdog: he assigned you
21:09:39 <ivanm> possibly re-assigned
21:09:53 * blackdog has been destructively mutated, feels impure
21:09:59 <Axman6> guess not :P
21:12:04 <Axman6> blackdog: i would add more info, but i don't have a wiki account, and i can't find where to create one
21:12:20 <blackdog> Axman6: there's a guest account
21:12:25 <blackdog> guest/gtk2hs
21:12:29 <Axman6> ah, ok
21:12:42 <orbitz> hot dam, code works
21:12:43 <orbitz> WHEEEE
21:12:48 <orbitz> just needed alitlte Debug.Trace magix
21:15:30 <Axman6> blackdog: added the `file` output on libgthread-2.0.dylib
21:15:30 <ivanm> s/magic/voodoo magic/
21:15:51 <orbitz> unsafeDebug
21:15:54 <Axman6> but there's not much else i can think to add
21:16:28 <Axman6> blackdog: also, we shoudl certainly go get a beer after SAPLING, and bring others along too
21:16:40 <blackdog> Axman6: this sounds like a sterling idea
21:16:47 <fnord123> > readFloat "1,000,000"
21:16:48 <lambdabot>   [(1.0,",000,000")]
21:16:57 <blackdog> I'm pretty psyched about SAPLING, actually. looks like a heap of good talks
21:17:21 <blackdog> not a bad time to be an antipodean hacker
21:17:24 <Axman6> if only we were in canberra. i have a new favourite pub called the wig and pen, which brews their own beers. they have a really nice new one at the moment which has smoked hops, and it's delicious
21:18:09 <Axman6> blackdog: yeah i'm lookingforward to ChilliX's talk, it's an area i find really interesting
21:18:44 <blackdog> Axman6: ah, nice. they used to make a rauschbier at the Red Oak in sydney, but i don't think we'll have time to get there before you have to go.
21:18:59 <arnihermann> do you know if anyone has been using haskell to implement a planner (AI-like, automated planning and scheduling) ?
21:19:00 <Axman6> yeah
21:19:02 <Cale> Heh, in this book on higher dimensional categories, there's the remark: The data s,t: C_1 -> C_0 is also known by the (over-used) term "".
21:19:13 <Axman6> luckily SAPLING's being hosted so close to central
21:19:22 <blackdog> the GPU stuff? yeah. all of those promises about FP languages being fundamentally more optimisable are finally coming true
21:19:32 <Axman6> yeah :)
21:19:48 <Axman6> i can't wait to see an OpenCL backend for their work
21:20:58 <Axman6> if they can make it nice enough that you write some pretty natural code, and it looks after finding all the compute devices for you, that would be fantastic
21:21:22 <Axman6> OpenCL has so much boilerplate at the moment though
21:22:01 <blackdog> arnihermann: there's a bit of AI stuff on hackage, and a few logic libraries
21:22:18 <ivanm> Cale: empty quotes?
21:22:20 <arnihermann> blackdog: thanks I'll look around there
21:22:42 <blackdog> Axman6: yeah. haven't played with OpenCL, but i had a look at CUDA after the talks at UNSW
21:22:53 <blackdog> amazingly fast, but such intricate code - it's more like ASM than C.
21:23:02 <Axman6> i've been playing with it a bit. it's insanely fast
21:23:07 * ivanm has never felt happier about not having a reddit account than when he read about the reddit "virus"
21:23:24 <Axman6> blackdog: the stuff i wrote was almost copied exactly from my C version
21:23:59 * Axman6 has never felt happier about all the shit he says about firefox after reading about this reddit 'virus'
21:24:33 <copumpkin> it's not specific to any browser
21:24:33 <Cale> ivanm: Yeah, basically, they're saying that part of the definition of a category (the mappings from arrows to their source and target) usually goes unmentioned.
21:24:51 <ivanm> heh
21:25:07 <ivanm> copumpkin: well, lynx is claimed to be unaffected
21:25:13 <ivanm> or people with NoScript
21:25:28 <Axman6> copumpkin: doesn't affect Safari 4 at least
21:25:42 <copumpkin> Axman6: sure it does, I got "infected"
21:25:49 <Axman6> i didn't
21:25:56 <copumpkin> I then proceded to delete all "my" new comments and logout
21:26:02 <copumpkin> but I was temporarily part of the worminess
21:26:40 <Axman6> http://lists.macosforge.org/pipermail/libdispatch-dev/2009-September/000059.html hooray for FreeBSD + libDispatch :)
21:28:20 <dancor> is there a currently-existing library to allow you to run commands and have them die on ^C?
21:28:29 <dancor> i know this is planned for future ghc
21:28:45 <dancor> i'd heard HSH would do it but not when i checked just now
21:29:01 <ivanm> Axman6: libDispatch is Apple's new parallelism library?
21:29:09 <Saizan_> are you checking in a compiled program or on ghci?
21:29:13 <Axman6> well, concurrency, but yeah
21:29:13 <dancor> Saizan_: both
21:29:23 <Axman6> makes parallelism in C stupidly easy
21:29:35 <ivanm> dancor: if running from a prompt, can't you ^C there?
21:29:36 <dancor> ghc, runghc, and ghci have same behavior for HSH.runIO ("du", ["-s", "/"])
21:29:43 <ivanm> Axman6: how does it differ from something like OpenMP?
21:29:53 <Axman6> replace a for-loop with a function, and bam, parallel program without having to worry about threads
21:30:01 <dancor> ivanm: you can ^C and it interrupts the haskell program, but the subprocess continues to run.
21:30:13 <ivanm> sounds like OpenMP, except IIRC you specify the number of processors to use
21:30:19 <ivanm> dancor: ahhh
21:30:28 <ivanm> _sub_-processes
21:30:35 <Axman6> ivanm: easier to use i believe, and more flexible. probably not as fast (not designed for scientific/HPC stuff)
21:31:01 <ivanm> right, so it's dumbed-down OpenMP
21:31:19 <Axman6> it's designed for different things
21:31:46 <ivanm> yeah
21:31:50 <blackdog> Axman6: more about pervasive parallelism, i guess
21:32:21 <Makoryu> What's the status on the Unicode IO reimpl, again?
21:32:27 <Axman6> i think the main idea behind it is: get the work that doesn't need to interrupt the program off the main thread
21:32:28 <Makoryu> Is it due with 6.12?
21:33:54 <Axman6> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9911#a9911
21:34:43 <copumpkin> Makoryu: yep
21:34:49 <copumpkin> Makoryu: it's done
21:35:20 <Axman6> i believe simon marlow has been working quite hard on it, and has got it to a basically finished state
21:35:20 <ivanm> copumpkin: since 6.12 isn't out yet, we can't say "it's done" ;)_
21:35:27 <ivanm> (might be bugs, etc.)
21:37:10 <Saizan_> bugs could be there even when 6.12 will be out
21:39:30 <Axman6> ivanm: see how simple that is?
21:40:28 <ivanm> simple for C maybe :p
21:45:22 <Saizan_> Axman6: so that's a "parMapM_ (\k -> ..) [0 .. points]", right?
21:45:23 <Axman6> ivanm: well, the parallel Haskell version isn't all that much clearer :P
21:45:37 <Axman6> Saizan_: basically, yeah
21:45:48 <Axman6> though i can't get mine to actually run in parallel
21:45:50 <ivanm> Axman6: heh, never touched one of the parallel versions of GHC
21:45:56 <Axman6> :O
21:52:16 <Saizan_> well, with pure lists the difference between the sequential and the parallel version in haskell is a "s/map/parMap whnf/"
21:53:36 <Saizan_> so it's still as nice as you can make your "normal" haskell
21:54:51 <Saizan_> (which seems to be also true for GCD and C respectively, here)
21:55:11 <Axman6> Saizan_: the problem is that adding parMap whnf ... to mine doesn't make it run in parallel (i think it's because of the way i'm running the benchmark though, forcing all the work to be done in the main thread
21:56:09 <ivanm> Axman6: you need to run with -n probably
21:56:15 <Axman6> i am
21:56:19 <Axman6> -N2
21:56:25 <ivanm> compiled with the correct params for parallel?
21:56:46 <Axman6> but i'm using \xs -> rnf xs `seq` xs in part of it, which would force the main thread to do all the work
21:57:28 <Makoryu> @pl \xs -> rnf xs `seq` xs
21:57:28 <lambdabot> seq =<< rnf
21:57:30 <Axman6> but i need to force the lists or the benchmark doesn't mean anyting
22:26:16 <lispy|web> :t using
22:26:17 <lambdabot> forall a. a -> Strategy a -> a
22:26:28 <lispy|web> :t \a -> a `using` rnf
22:26:28 <lambdabot> forall a. (NFData a) => a -> a
22:41:10 <vegai> I have a directory with a rather large amount of files (more than 500K)
22:41:30 <vegai> anyone know any nifty technique for speeding up opening a file in such a directory?
22:42:23 <vegai> I would guess that the filesystem (ext4) index should make opening the file a constant time operation, but doesn't seem so...
22:42:57 <jargonjustin> I've got a few UArray tables in my application, is there a way to compute them at compile time?
22:43:57 <Cale> jargonjustin: The answer is either 'no' or 'sort of'
22:44:14 <jargonjustin> Cale: Ah, I was thinking Template Haskell could help here?
22:44:28 <jargonjustin> Or am I barking up the wrong tree?
22:44:43 <Cale> jargonjustin: You could do some template haskell magic to compute them as lists or something, and then at runtime you just have to turn those lists into UArrays
22:45:14 <Cale> But the thing is that you can't do anything with template haskell that you couldn't do by typing out a source file by hand.
22:45:40 <jargonjustin> Cale, and since there's no such thing as a UArray literal‚Ä¶ okay. At least that makes sense.
22:45:51 <Cale> So you can't magically include data structures directly as values into your source code, they have to be syntax trees for generating those values.
22:45:54 <Cale> yeah
22:46:16 <jargonjustin> So for something like a UArray where it'd make sense on how to do it, it'd need compiler support.
22:46:18 <Cale> It comes up often enough that it would seem to be worth looking into.
22:47:01 <Cale> (Some kind of extension to TH which provides for inserting an arbitrary Haskell value into the AST)
22:47:48 <Cale> It gets *really* complicated if you want it to work with laziness.
22:47:51 <jargonjustin> Cale: Would arbitrary values be doable? I'm thinking laziness would make that rather difficult.
22:47:55 <Cale> yeah
22:48:05 <koala_man> vegai: google claims that dir_index is default for ext4. have you checked that this is indeed enabled?
22:48:43 <Cale> Also, functions are hard.
22:48:46 <jargonjustin> Cale: So perhaps a more reasonable approach would be for definitions that can be shown strict?
22:48:50 <Cale> (laziness or not)
22:49:51 <jargonjustin> Still, handling all strict data structures except functions would cover a large class of useful cases.
22:50:13 <jargonjustin> I'll revisit this after I get to the point where startup time actually matters :-)
22:50:16 <Cale> yeah
22:56:39 <vegai> koala_man: I'm pretty sure... but what program shows me the current parameters of a partition?
22:56:50 <koala_man> Exodus: vegai tune2fs
22:57:09 <vegai> I got some more juice out of it by using DirStreams instead of getDirectory
22:57:12 <vegai> but not much
22:57:52 <vegai> koala_man: yes, dir_index is on
22:59:06 <vegai> the index is a tree, though
22:59:28 <vegai> more specifically, "An HTree is a specialized version of a B-tree. They are constant depth of either one or two levels, have a high fanout factor, use a hash of the filename, and do not require balancing"
22:59:58 <vegai> also, "While the HTree algorithm significantly improved lookup times, it could cause some performance regressions for workloads that used readdir() to perform some operation of all of the files in a large directory."
23:00:15 <vegai> "This is caused by readdir() returning filenames in a hash-sorted order, so that reads from the inode table would be done in a random order. This performance regression can be easily fixed by modifying applications to sort the directory entries returned by readdir() by inode number. "
23:07:47 <Trinithis> How can I make a source file always use -hide-package monads-fd ?
23:09:44 <blackdog> Trinithis: if it's an option to ghc, you can put "{-# options_ghc -hide-package monads-fd #-} at the top of the source file.
23:10:07 <blackdog> without the quote.
23:10:07 <Trinithis> doesnt work
23:10:39 <Trinithis> even so
23:10:44 <blackdog> chuck the code and the error up on a pastie site, then...
23:10:55 <Trinithis> ok
23:11:19 <Axman6> Trinithis: what about OPTIONS_GHC?
23:11:54 <Trinithis> thats what i tried before asking
23:13:45 <Trinithis> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9912#a9912
23:15:10 <vegai> koala_man: ah, seems I was wrong. My sqlite3 writer was the lagger, not the file reader
23:23:50 <blackdog> Trinithis: that's really weird
23:24:07 <Trinithis> Guess it's a bug
23:24:56 <blackdog> very weird that ghc's happy to accept the flag on the command line but bombs out with it in the pragma
23:26:19 <Trinithis> same here
23:29:38 <Berengal> blackdog, the GHC manual says it doesn't work in source files. Hiding packages is something that's global to a compilation
23:30:05 <blackdog> Berengal: ah, that makes sense.
23:34:41 <kbp> how can I call function again and again but not using map? (because my function takes more than 1 argument)
23:35:28 <blackdog> kbp: is it varying in only one argument per call?
23:36:21 <kbp> blackdog: yes
23:37:14 <blackdog> kbp: then you can use map. you just need to provide some of the arguments another way
23:37:19 <Berengal> curry that funkshun!
23:37:30 <blackdog> > map (\x -> x + 10) [1..5]
23:37:39 <kbp> blackdog: but without other arguments, the function doesn't work
23:37:58 <blackdog> kbp: sure. that's why Berengal suggests you curry it
23:38:04 <lambdabot>   mueval-core: Time limit exceeded
23:38:11 <blackdog> hm, i'm getting no lambdabot love there
23:38:18 <kbp> !curry
23:38:30 <blackdog> anyway, you can see that + takes two arguments, but map is only applying one
23:38:39 <blackdog> but that's ok, because i'm supplying one static one
23:38:51 <c_wraith> > map (+10) [1..5]
23:38:57 <lambdabot>   mueval-core: Time limit exceeded
23:38:59 <c_wraith> hmm
23:39:10 <c_wraith> wonder what sort of shape that machine's in
23:39:16 <c_wraith> preflex, seen cale
23:39:17 <preflex>  cale was last seen on #haskell 49 minutes ago, saying: yeah
23:39:18 <blackdog> (am expanding the section to a lambda for clarity :)
23:39:18 <kbp> blackdog: what if that static one (10) is a variable and that variable can be changed
23:39:40 <Berengal> http://arcanux.org/lambdacats/notcurry.jpg
23:40:03 <blackdog> kbp: if it's bound at that point in the program, just substitute it for the 10.
23:40:09 <c_wraith> > 1 + 1
23:40:15 <lambdabot>   mueval-core: Time limit exceeded
23:40:18 <Berengal> > 1
23:40:24 <lambdabot>   mueval-core: Time limit exceeded
23:40:34 <Berengal> > text "mueval-core: Time limit exceeded"
23:40:38 <blackdog> if it's a c-style mutable reference then you probably need to be operating in the IO monad
23:40:38 <lambdabot>   mueval-core: Time limit exceeded
23:44:04 <kbp> blackdog: http://codepad.org/xhCPfAO7
23:44:35 <kbp> blackdog: that is an example (i.e. I need to call function inside a while loop like in C)
23:44:44 <mauke> with what x?
23:44:45 <kbp> s/list/x
23:44:55 <mauke> cartesian product or in parallel?
23:45:02 <blackdog> kbp: so "abc" should go with 1, "def" with 2, etc?
23:45:14 <mauke> i.e. nested for loops or a single for (i = 0; i < 200; ++i) loop?
23:45:38 <ski> , map (\x -> x + 10) [1..5]
23:45:39 <lunabot>  [11,12,13,14,15]
23:46:47 <kbp> blackdog: nah it's just an example . let say while($i<5) { myfunc($i,$something); $i++;}. how would you interpret that to Haskell?
23:47:40 <blackdog> what do you want back from that?
23:47:42 <kbp> with $something is calculated inside the while loop, but before the line "myfunc"
23:48:20 <blackdog> ie, is that a value you're getting back from it, or are you doing things out in the world?
23:48:29 <mauke> map (\i -> myfunc i something) [0 .. 4]
23:48:31 <ski> kbp : what is `i' to begin with ? do you want to execute that for effects ? or construct an element of a list for each iteration ?
23:48:59 <ski> (kbp : a more concrete example might be better)
23:49:02 <blackdog> Haskell is a bit different to imperative programming, you'll have to unlearn a few habits. easier if you come up with a real problem
23:49:47 <Lycurgus> "different to" is grammatically incorrect
23:50:25 <Lycurgus> (and grates on the native english speaking ear)
23:50:29 <blackdog> http://www.worldwidewords.org/qa/qa-dif1.htm
23:50:55 <Unregistered> http://bit.ly/26ax7L ->if possible need help
23:50:56 <blackdog> fairly common Commonwealth usage.
23:51:32 <pao> hi all
23:51:41 <kbp> blackdog: this is my real code, if you'll kindly look at it please, thanks alot
23:51:46 <Lycurgus> possibly, commonwealth english is mostly non-native speakers
23:51:50 <pao> is throwIO . ErrorCall semantically equivalent to fail?
23:51:55 <kbp> blackdog: http://codepad.org/Jssm2HAL
23:52:04 <blackdog> Lycurgus: ... are you trolling?
23:52:12 <ski> , let myfunction x y = "I'm "++show(x)++" year old and my name is "++y in [myfunction list y | list <- [1..200] | y <- ["abc", "cde"]]
23:52:13 <lunabot>  ["I'm 1 year old and my name is abc","I'm 2 year old and my name is cde"]
23:52:30 <Lycurgus> by virtue of correcting your English? perhaps
23:52:59 <c_wraith> whoa.  I hadn't seen [ .. | .. | .. ] syntax before
23:53:15 <blackdog> No, I mean about commonwealth English.
23:53:19 <kbp> ski: that is what "zip" does but it's not enough in my case (it takes many arguments, the argument then be called by other function inside blah blah blah)
23:53:20 <ski> parallel list comprehensions
23:53:22 <pao> kbp: you should indent right and left on the same column
23:53:31 <c_wraith> That's a handy thing to know about
23:53:44 <ski> kbp : i'm not quite sure what it is you want
23:53:59 <kbp> ski: http://codepad.org/Jssm2HAL
23:54:04 <pao> ski: is that (parallel lc) standard haskell 98?
23:54:06 <ski>   [oneBoolExp (v,e) varTable number | number <- [0..x]]
23:54:11 <ski> pao : no
23:54:24 <ski> kbp : something like that ?
23:55:05 <kbp> ski: let me try, I though I tried before but it doesnt understand oneBoolExp as a function (instead it realises it as a string)
23:55:31 <pao> ski: can you confirm that throwIO . ErrorCall is the same as fail :: String -> IO a
23:55:32 <pao> ?
23:56:24 <ski> no .. i prefer to avoid `fail' .. i don't recall what it does in `IO'
23:56:32 <Lycurgus> no, the total population of the commonwealth is 1.9 billion of whom 1.2 billion are Indian
23:57:13 <Lycurgus> a large portion of the remaining 700 million are also not native speakers of English
23:58:05 <pao> ski: thanks
23:59:35 <kbp> ski: great, it works :) thank you very much
23:59:46 <kbp> thank pao and blackdog too
