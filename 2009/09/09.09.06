00:04:00 <mmorrow> ezyang: nice
00:06:36 <ski> ezyang : s/"bottom" (a type that/"bottom" (a value that/
00:06:36 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
00:06:54 <ski> (or `"value"' or maybe `denotation')
00:06:57 <ezyang> ski: right-o
00:07:00 <ski> @messages
00:07:01 <lambdabot> Philonous1 said 12h 22m 3s ago: Here's the junction code, if you're still interested. I cleaned it up somewhat and added a monad interface: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9083#
00:07:01 <lambdabot> a9083
00:09:01 <ezyang> Type level lambdas O.o
00:11:32 <ray> mmm, type level lambdas
00:12:14 <gio12> http://mathbin.net/28912
00:12:41 <ezyang> gio12: mix?
00:13:12 <purplepenguins> gio why are you posting latex questions on #haskell and #math
00:13:45 <Zao> purplepenguins: Because we are smart, and smart people are helpful?
00:13:48 <ray> such is the price of being the channels with people who know what they're doing
00:13:56 <Zao> "we" not necessarily including everyone, including me.
00:13:56 <ray> alas
00:14:09 <purplepenguins> i mean, yes, we may be smart, and someone on here might know the answer
00:14:18 <purplepenguins> but you should direct questions to topical channels
00:14:48 <ray> you did say "why"
00:17:14 <ski> ezyang : imo, `MonadError' is (currently) only useful when you're willing to include `String' (and empty) errors in your error type
00:20:08 <Berengal> ..oO(Why isn't fail in MonadError instead of Monad?)
00:20:24 <lispy> Berengal: historical reasons
00:20:31 <ray> because people wanted patterns in do blocks
00:20:40 <Berengal> ray, you can still have that
00:21:14 <ski> (refutable patterns in `do'-blocks should add a further constraint)
00:21:17 <ray> well, you can always have irrefutable patterns, and you can always have any pattern for monads with a zero
00:21:36 <ezyang> ski: That appears to be true.  I'm holding out that someone discovers some interesting and useful alternate implementation :-)
00:22:06 <lispy> is there a function for catMaybes $ map (flip lookup p)?
00:22:17 <ezyang> ski: Maybe it's useful when doing ErrorT?
00:22:28 <ezyang> :t catMaybes $ map (flip lookup p)
00:22:29 <lambdabot>     Couldn't match expected type `[(a, b)]'
00:22:29 <lambdabot>            against inferred type `Expr'
00:22:29 <lambdabot>     In the second argument of `flip', namely `p'
00:22:32 <Berengal> ray, monads with a zero could have fail = const mzero
00:22:45 <ezyang> :t catMaybes $ map $ flip lookup
00:22:46 <lambdabot>     Couldn't match expected type `[Maybe a]'
00:22:46 <lambdabot>            against inferred type `[[(a1, b)]] -> [a1 -> Maybe b]'
00:22:46 <lambdabot>     In the second argument of `($)', namely `map $ flip lookup'
00:23:00 <lispy> :t \p -> catMaybes $ map (flip lookup p)
00:23:01 <lambdabot>     Couldn't match expected type `[Maybe a]'
00:23:01 <lambdabot>            against inferred type `[a1] -> [Maybe b]'
00:23:01 <lambdabot>     In the second argument of `($)', namely `map (flip lookup p)'
00:23:12 <ski> ezyang : no, because the `Monad' instance for `ErrorT' (as well as the one for `Either') is contaminated with the `Error' constraint
00:23:16 <ezyang> lispy: Do you mean... Map.lookup?
00:23:18 <ray> i'm not a fan of fail
00:23:23 <lispy> :t lookp
00:23:24 <lambdabot> Not in scope: `lookp'
00:23:25 <lispy> :t lookup
00:23:26 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:23:35 <lispy> :t Map.loopup
00:23:36 <lambdabot> Couldn't find qualified module.
00:23:37 <lispy> :t Map.lookup
00:23:38 <lambdabot> Couldn't find qualified module.
00:23:45 <ezyang> (Data.Map)
00:23:51 * ski will be back later in maybe an hour
00:23:56 <Saizan_> ?type \p xs -> catMaybes $ map (flip lookup p) xs
00:23:57 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [a] -> [b]
00:24:08 <ezyang> ski: Mmm
00:24:20 <lispy> Saizan_: yes, that's what I'm thinking of
00:24:32 <ezyang> I wonder if there's a module that defines the monad instance for just "Either a"
00:24:43 <lispy> ?pl \p xs -> catMaybes $ map (flip lookup p) xs
00:24:43 <lambdabot> (catMaybes .) . map . flip lookup
00:24:58 <ray> i don't believe in errors anyway
00:25:04 <ray> but that's more philosophy
00:25:37 <ezyang> you people and your alternate realities ;-)
00:25:43 <lispy> ?hoogle [(a,b)] -> [a] -> [b]
00:25:43 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
00:25:43 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
00:25:43 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
00:25:51 <ray> well, Nothing or Left _ are just values
00:25:58 <ray> they're not special
00:26:18 <ezyang> ray: Yes.
00:26:29 <Saizan_> if you are in the kliesli category for Maybe and Either e they are somewhat special :)
00:26:31 <ray> so i just think of them as values
00:27:00 <ezyang> ray: But in most cases, I'm using them monadically for extra flow control... so I think of them as a little special
00:27:25 <ray> maybe the concept of error makes sense in IO where you can catch stuff, but that's a bit too magic for me
00:27:52 <lispy> Well, the way fail is handled isn't that special either
00:27:58 <lispy> No stack unwinding
00:28:13 <lispy> You just go straight to the end without doing computations
00:28:27 <ray> well fail's just a monad zero
00:28:29 <ezyang> Righto. It's poor man's Maybe monad
00:28:32 <ray> in the cases where it makes sense
00:28:38 <ezyang> and bottom anywhere else
00:28:39 <lispy> yeah
00:28:52 <lispy> Soggy _|_ boys?
00:29:08 <lispy> http://en.wikipedia.org/wiki/O_Brother,_Where_Art_Thou%3F
00:29:30 <path[l]> :t liftM2
00:29:30 <lambdabot> path[l]: You have 1 new message. '/msg lambdabot @messages' to read it.
00:29:31 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:29:32 <Adamant> lispy: I didn't know you were the goddamn paterfamilias
00:30:06 <lispy> Adamant: I have no idea what you just said :)
00:30:17 <Adamant> lispy: never seen the movie huh
00:30:49 <lispy> Adamant: I have watched it but not recently
00:31:01 <Adamant> lispy: it's a quote from the movie
00:31:05 <path[l]> how do I leave a message on lambdabot
00:31:09 <lispy> ah, sorry for being slow on the up take
00:31:21 <lispy> path[l]: @tell someone somemessage
00:31:32 <path[l]> ah
00:31:57 <path[l]> thanks
00:32:02 <lispy> yw
00:32:17 <ezyang> zomg the neighborhood of infinity post about kleisli arrows is making sense
00:32:30 <lispy> ezyang: sigfpe has an amazing blog
00:32:40 <ezyang> Yes, but 80% it's over my head
00:32:46 <lispy> ezyang: read it up and you'll be 10x smarter, no 100x ;)
00:32:48 <ezyang> I need to re-read the archives at some point
00:33:44 <lispy> While the Blub programmers are off reading Yegge and Joel on Software, you can be reading sigfpe :)
00:33:48 <Berengal> Hah, -XNoImplicitPrelude is trippy
00:33:58 <purplepenguins> what's a Blub?
00:34:00 <lispy> Berengal: no doubt; what are you doing?
00:34:11 <ray> the blub programmers are all reading paul graham
00:34:14 <lispy> purplepenguins: it's a hypothetical language that Paul Graham used in an essay
00:34:19 <Berengal> lispy, making a sensible Monad and MonadError library
00:34:26 <ray> because lisp is blub
00:34:35 <purplepenguins> and i read sigfpe and comonad.reader just for the rare occasions i understand what they're talking about
00:34:49 <Berengal> ray, not all of them, only the lisp-ones
00:34:50 <path[l]> I just did this (Control.Monad.liftM2 (+)) [1,2,3] [4,5,6] .... and I saw that it gave me all combinations, but can someone explain how it works? I understand that it lifts (+) into the list monad, but I dont understand how it decides to work all combinations. Why not every pair for example?
00:34:51 <lispy> ray: right, the irony of his essay is that it can be used against him :)
00:35:14 <ezyang> path[l]: Look up ZipList
00:35:46 <lispy> path[l]: the list monad is one of 'all combinations'
00:35:52 <ray> every sufficiently large common lisp program contains an ad-hoc bug-ridden implementation of a system f type checker!
00:35:55 <ray> *ahem*
00:35:57 <Berengal> path[l], do you know how the list monad works?
00:36:25 <lispy> > liftM2 (+) [1..3] [4..6]
00:36:26 <lambdabot>   [5,6,7,6,7,8,7,8,9]
00:36:40 <path[l]> well nothing specifically. I understand its a monad and fits the analogy of a monad as a container. And Ive sorta understood the various operations that monads have defined
00:36:44 <ray> ziplists aren't a monad though
00:37:05 <Berengal> The list monad is multiplicative
00:37:06 <ezyang> Right, it's applicative
00:37:07 <path[l]> Im following a monad guide from haskellwiki and I just got to lift
00:37:08 <lispy> path[l]: well, the list monad represents non-deterministic computations
00:37:37 <lispy> or rather, non-determinism as a form of computation
00:37:38 <ray> lifting is really applicative, but yeah
00:38:07 <path[l]> so lifting an operation into a list means "for all" is it?
00:38:10 <ray> just apply the ApplicativeT monad tutorial transformer to your monad tutorial...
00:38:20 <lispy> ray: hehe
00:38:33 <ezyang> path[l]: Yup; your classic notion of map
00:38:34 <path[l]> so lifting (+) into 2 lists should be for all elements (+) for all elements
00:38:38 <path[l]> hmm
00:38:44 <lispy> ?quote <ray> just apply the ApplicativeT monad tutorial transformer to your monad tutorial...
00:38:44 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
00:38:54 <lispy> ?remember <ray> just apply the ApplicativeT monad tutorial transformer to your monad tutorial...
00:38:55 <lambdabot> I will never forget.
00:39:01 <ezyang> ?quote
00:39:02 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
00:39:02 <path[l]> ok I sorta get it I guess. Its very hazy, but enough for now I guess
00:39:14 <ezyang> You should implement the monad instance!
00:39:19 <ezyang> It'll be great!
00:39:28 <path[l]> me?
00:39:34 <purplepenguins> ?quote
00:39:35 <lambdabot> Itkovian says: real programmers don't write docs, if it was hard to write, it should be hard to understand
00:39:37 <ezyang> yup!
00:39:37 <lispy> ?quote
00:39:37 <lambdabot> FliPPeh says: @faq Can Conficker be rewritten in Haskell? <lambdabot> <no location info>: parse error on input `:'
00:40:01 <path[l]> Im not sure what you mean. You mean try and write a monad? To get a better understanding?
00:40:02 <purplepenguins> ?quote
00:40:03 <lambdabot> simonmar says: Wondering how popular Haskell needs to become for intel to optimize their processors for my runtime, rather than the other way around.
00:40:13 <ezyang> path[l]: Yes.
00:40:27 <path[l]> oh ok
00:40:31 <lispy> lol@simonmar's quote
00:40:57 <path[l]> I guess Ill do that at some point. I have 6-7 monad tutorials open, still working through the first
00:41:05 <ezyang> A little bit like the lisp machines from days of yore
00:41:07 <path[l]> I just worked through the sheep -> maybe sheep examples
00:41:12 <lispy> path[l]: the maybe monad is one of the easiest to write
00:41:16 <mmorrow> @unmtl RWST r w s (Cont o) a
00:41:16 <lambdabot> r -> s -> (a -> s -> w -> o) -> o
00:41:40 * lispy still needs to better grasp the list and cont monads
00:41:43 <mmorrow> @unmtl ContT o (RWS r w s) a
00:41:43 <lambdabot> (a -> r -> s -> (o, s, w)) -> r -> s -> (o, s, w)
00:41:59 <path[l]> hmm I didnt realise const was a monad
00:42:14 <lispy> path[l]: not const, cont for contiuation passing
00:42:21 <path[l]> oh lol
00:42:22 <path[l]> ok
00:42:26 <purplepenguins> const is not a monad
00:42:29 <path[l]> that makes more sense
00:42:33 <mmorrow> > flip runCont id (callCC (\k -> forever (k 42 >> return ())))
00:42:34 <lambdabot>   42
00:42:39 <ezyang> lol
00:42:40 <dolio> There is a const monad.
00:42:45 <lispy> hehe
00:42:51 <dolio> newtype Const a b = Const a
00:42:51 <ezyang> dolio: Ident?
00:43:11 <purplepenguins> what would bind and return be
00:43:12 <ezyang> oh man, I need to figure out the continuation monad.
00:43:14 <lispy> dolio: shouldn't it be = Const b
00:43:26 <lispy> :t const
00:43:27 <lambdabot> forall a b. a -> b -> a
00:43:31 <lispy> oh, n/m
00:44:12 <ezyang> zomg I understand comonads
00:44:20 <ezyang> though I should implement one to be sure. Any suggestions?
00:44:30 <ray> density
00:44:42 <dolio> instance Monoid w => Monad (Const w) where return _ = Const mempty ; Const w >>= _ = Const w -- roughly.
00:44:55 <path[l]> so liftM2 expects 2 umm things of the same monad right
00:45:00 <ezyang> ray: Elaborate a little more, sorry?
00:45:03 <mmorrow> , runCont id (do (x,here) <- labelCC 0; when (x < 100) (jump (x+3) here); return x)
00:45:04 <lunabot>  102
00:45:05 <lispy> dolio: but what is mempty?
00:45:14 <dolio> It's from Monoid.
00:45:38 <lispy> dolio: I know, but what is it interms of Const
00:45:41 <path[l]> how does it work from the inside? like if I liftM2 (+) into the maybe monad. And one of them is nothing, I expect nothing.
00:45:51 <dolio> Technically that instance violates the monad laws, so Const w might only be applicative.
00:45:52 <lispy> ?src liftM2
00:45:52 <ray> ezyang: lol, do an infinite stream or something
00:45:52 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:45:53 <Berengal> @src liftM2
00:45:53 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:46:01 <path[l]> ah
00:46:06 <dolio> lispy: It has nothing to do with Const. It has to do with what w is.
00:46:28 <dolio> If w = (), then mempty = (). If w = [a] then mempty = [].
00:46:30 <dolio> Etc.
00:46:31 <Berengal> I <3 Monad without fail
00:46:43 <yitz> dolio: it also has nothing to do with Monoid, with your definition. You just need a pointed type.
00:46:47 <purplepenguins> mempty is the identity in the monoid
00:46:49 <path[l]> so in a list that becomes each element. But in the case of Maybe, how does it work?
00:47:00 <lispy> liftM2 f m1 m2 = f `fmap` m1 `ap` m2 -- IIRC
00:47:11 <dolio> There is no pointed type type class.
00:47:22 <lispy> :t \f m1 m2 -> f `fmap` m1 `ap` m2
00:47:23 <lambdabot> forall a a1 b (m :: * -> *). (Functor m, Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
00:47:26 <path[l]> inside a list if I do x1 <---- [1..10] does that mean the next n lines are executed for EACH value of the list?
00:47:27 <yitz> class Pointed a where point :: a
00:47:28 <lispy> :t liftM2
00:47:29 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:47:33 <Saizan_> path[l]: do you know what >>= does for Maybe?
00:47:42 <ray> class Zero a
00:47:44 <path[l]> hmm yeah I remember that
00:47:47 <path[l]> give me a sec
00:48:03 <ray> Pointed is generally understood to be pointed functors
00:48:10 <path[l]> I think it ignored the function
00:48:15 <path[l]> if the monad has a nothing
00:48:18 <path[l]> else it applies it
00:48:31 <lispy> right
00:48:48 <ezyang> Hmmmm
00:48:49 <yitz> ray: Zero has other connotations. But yeah, it also works.
00:48:52 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9108#a9108
00:48:55 <ezyang> For the life of me I can't find the comonad hackage package
00:49:00 <Saizan_> path[l]: and yeah in "do x <- [1..10]; <rest>", <rest> is performed once for each value in [1..10]
00:49:07 <ezyang> aha, category-extras
00:49:10 <path[l]> ah
00:49:49 <ray> you want algebraic structures here
00:50:08 <ray> Monoid is the common one
00:50:14 <dolio> Actually, thinking about it, that monad instance is doomed to failure.
00:50:23 <ray> that's stronger than just having a zero though
00:50:25 <dolio> Const w is applicative, though.
00:50:52 <ray> class UnitalMagma a
00:51:04 <lispy> dolio: it better be, we can think of it as a type level function analog to the value level const function
00:51:08 <dolio> instance Monoid w => Applicative (Const w) where pure a = Const mempty ; Const w1 <*> Const w2 = Const (w1 `mappend` w2)
00:51:14 <path[l]> so in the case of maybe liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }  does it become m2 >>= (m1 >>= (a -> a -> a) -> (a -> a))
00:51:18 <path[l]> or how does it work
00:51:36 <yitz> ray: a type is a set, an instance of Pointed is a pointed set, isn't that pretty obvious?
00:51:37 <path[l]> cause I understood how maybe monad worked when I used a function with one argument
00:51:40 <path[l]> but now Im lost
00:51:50 <ezyang> path[l]: liftM2 is easier understood when framed as an applicative
00:52:24 <ezyang> but you can treat it as: m2 >>= \x -> m1 >>= \y -> f x y
00:52:25 <ray> well the name Pointed's in use for pointed functors
00:52:39 <path[l]> hmm
00:52:58 <path[l]> so if m1 is nothing, it doesnt return nothing but returns something like f x = Nothing ?
00:53:00 <yitz> oh really? too bad, they should have called it PointedFunctor. Truth is, Pointed (meaning pointed set) comes up all the time.
00:53:18 <yitz> More often than PointedFunctor imho
00:53:32 <ray> pointed functors come up all the time around here :)
00:53:35 <lispy> :t m1 >>= (\x1 -> m2 >>= (\x2 -> return (f x1 x2)))
00:53:36 <lambdabot> Not in scope: `m1'
00:53:36 <lambdabot> Not in scope: `m2'
00:53:44 <lispy> :t \f m1 m2 -> m1 >>= (\x1 -> m2 >>= (\x2 -> return (f x1 x2)))
00:53:45 <ray> just not in themselves
00:53:45 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
00:53:46 <path[l]> I guess the question is if I do m1 >>= f and f takes 5 parameters, I get back a function that takes 4 parameters and returns nothing if m1 is nothing?
00:54:03 <lispy> ?undo liftM2 f m1 m2
00:54:03 <lambdabot> liftM2 f m1 m2
00:54:09 <lispy> ?unpl liftM2 f m1 m2
00:54:10 <lambdabot> (m1 >>= \ b -> m2 >>= \ a -> return (f b a))
00:54:28 <ezyang> path[l]: look at the types more carefully
00:54:33 <ray> i think Zero works
00:54:51 <ray> maybe not
00:55:04 <Berengal> path[l], there's nothing of that going on. The liftM functions just runs each monad in turn, then finally applies the function to the result of each
00:56:04 <path[l]> :t (>>=)
00:56:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:56:30 <ezyang> Ok, suppose that f is a -> b -> c
00:56:31 <path[l]> I guess Im wondering if m1 >>= (+) even makes sense
00:56:38 <ezyang> that also means that f is a -> (b -> c)
00:56:39 <path[l]> does it return a function inside a monad
00:56:42 <ezyang> YES!
00:56:46 <Berengal> @type (>>=(+))
00:56:48 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
00:56:54 <path[l]> ah
00:56:59 <Berengal> Only for the function monad
00:57:22 <path[l]> well I meant like (Just 5) >>= (+)
00:57:29 <Berengal> No, that doesn't make sense
00:57:37 <lispy> :t (Just 5) >>= (+)
00:57:38 <lambdabot>     Couldn't match expected type `Maybe b'
00:57:38 <lambdabot>            against inferred type `t -> t'
00:57:38 <lambdabot>     In the second argument of `(>>=)', namely `(+)'
00:57:44 <Berengal> @type (+5) >>= (+)
00:57:45 <lambdabot> forall a. (Num a) => a -> a
00:57:54 <ezyang> Replace >>= with `liftM` and it makes more sense
00:58:02 <lispy> > (+5) >>= (+) 1
00:58:02 <ezyang> (and swap the args)
00:58:03 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
00:58:09 <lispy> > ((+5) >>= (+)) 1
00:58:10 <lambdabot>   7
00:58:12 <ezyang> (+) `liftM` (Just 5)
00:58:19 <ezyang> :t (+) `liftM` (Just 5)
00:58:20 <lambdabot> forall a1. (Num a1) => Maybe (a1 -> a1)
00:58:43 <path[l]> hmmm ok
00:58:53 <path[l]> I think I see :)
00:58:57 <lispy> The monad ((->) r) is really subtle
00:59:09 <lispy> I don't recommend starting with that one :)
00:59:19 <path[l]> is that ap?
00:59:25 <Berengal> subtle? It's downright sneaky! Ninja-like
00:59:30 <lispy> That's the reader instance for functions
00:59:36 <ezyang> I think I got confused by it too :-)
00:59:48 <ezyang> path[l]: You'll want ap to get the function out of the monad again
00:59:51 <lispy> It's functions that take some type r, and give you whatever result
01:00:10 <path[l]> hmm ok, let me get back to reading I guess
01:00:23 <lispy> it's Monad (r ->), but that's not syntatically correct, so we say, instance Monad ((->) r) where ...
01:01:00 <lispy> Monad (r -> (forall a. a)) would be right also, I think
01:01:12 <lispy> Oh no it wouldn't
01:01:29 <ray> nope
01:02:21 <ray> your craziness rank is 2
01:02:23 <ray> :)
01:02:53 <lispy> forall a. Monad (r -> a), isn't really any better
01:03:07 <lispy> so, I'm not sure Monad ((->) r) translates
01:03:18 <ray> you're still pretty wrong
01:03:39 <ray> if you want to stick a forall in there, it's a forall r. in the beginning
01:03:39 <dolio> Instances of monad need to have kind * -> *
01:04:47 <ray> what you seem to be looking for is a type-level lambda
01:04:55 <ray> pretty different from quantification
01:05:11 <ezyang> Oh man, type lambdas!
01:05:22 * ezyang goes "wait, I said that already" 
01:05:23 <ray> maaaaaaaaaaaaaaaaaan, type-level lambdas
01:05:40 <Berengal> @quote type.lambdas
01:05:40 <lambdabot> quicksilver says: partially applied type synonym = type lambdas = unrestricted type functions = can of pants
01:05:43 <skorpan> do the oleg dance
01:06:55 <Berengal> Who here thinks we'll be using type lambdas in 30 years?
01:07:17 <ray> in 30 years? kind lambdas will be old fashioned by then
01:07:32 <dolio> What do you mean "we"?
01:07:39 <dolio> There are already langauges with type lambdas.
01:08:06 <ray> also, haskell' will be released then, and it'll be h2010 with the monomorphism restriction put back in
01:08:06 * ezyang gives up on understanding continuations... for NOW! 
01:08:12 <dolio> If you mean something like "mainstream" I'm not sure Haskell will be mainstream in 30 years. :)
01:08:54 <ray> @quote
01:08:54 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
01:09:07 <yitz> @quote ray
01:09:08 <lambdabot> ray says: three dimensional zippers make my scalp hurt when i get my hair caught in them
01:09:16 <ezyang> @quote byorgey
01:09:16 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
01:09:16 <lambdabot> like learn $ zip math haskell.
01:09:16 <ray> =o
01:09:25 <Berengal> dolio, I was going for a broader "we", mainstream like. Haskell might not be mainstream then, hopefully in the way COBOL isn't mainstream now
01:09:54 <purplepenguins> that's an awesome quote
01:09:59 <dolio> I meant more of a "Haskell won't be mainstream yet, even then", but strictly speaking, I'm more optimistic than that.
01:10:02 <poe> learn (intercalate math haskell) -- :-)
01:10:27 <ezyang> poe: Because Haskell is totally [[knowledge]] and math is just [knowledge]? ;-)
01:11:21 <ray> in the universities of tomorrow, math will be a single course in a haskell major
01:11:23 <dolio> You need interleave from logict.
01:11:39 <poe> hehe, okay I mean concat . transpose $ [haskell,math]
01:13:19 <ray> @quote endofunctor
01:13:19 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
01:13:31 <Berengal> I don't know anywhere else where people typecheck pseudocode
01:13:52 <ray> what else can you do with pseudocode?
01:14:00 <ezyang> Berengal: Ha!
01:14:32 <ray> you can't run it, but you can typecheck it if there's enough information
01:15:04 <path[l]> @src maybe
01:15:05 <lambdabot> maybe n _ Nothing  = n
01:15:05 <lambdabot> maybe _ f (Just x) = f x
01:22:35 <hackagebot> tkhs 0.1.0.4 - Simple Presentation Utility (YusakuHashimoto)
01:23:28 <ezyang> Whoo, sleepy time
01:23:31 <ezyang> good night
01:36:41 <hackagebot> prelude-plus 0.0.0.3 - Prelude for rest of us (YusakuHashimoto)
01:54:22 <etpace_> > let square x k = k (x*x) in \x y -> square x \x's -> square y \y's -> x's + y's $ 2 3
01:54:23 <lambdabot>   <no location info>: parse error on input `\'
01:54:59 <etpace_> > let square x k = k (x*x) in \x y -> square x (\xs -> square y (\ys -> xs + ys)) $ 2 3
01:55:00 <lambdabot>   Add a type signature
01:55:09 <etpace_> > let square x k = k (x*x) in \x y -> square x (\xs -> square y (\ys -> xs + ys)) $ 2 3 :: Int
01:55:11 <lambdabot>   Overlapping instances for GHC.Show.Show
01:55:11 <lambdabot>                              ((a ->...
01:56:49 <poe> > let s x k = k (x*x) in (\x y -> s x (\xs -> s y (\ys -> xs + ys))) 2 3
01:56:51 <lambdabot>   13
01:56:59 <etpace_> doh
01:57:10 <poe> parenthesize your lambdas
02:10:14 <sinelaw_web> hi, what's a good intro to denotational semantics?
02:10:34 <opqdonut> book or web resource?
02:10:44 <sinelaw_web> book
02:10:51 <opqdonut> i found "foundations for programming languages" great
02:11:00 <yitz> sinelaw_web: start with the wikibook chapter on it
02:11:20 <opqdonut> introduces different denotational models for lambda calculus, algebraic data structures, some category theory, etc.
02:11:45 <yitz> @go wikibook denotational semantics
02:11:46 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
02:12:14 <sinelaw_web> thanks. another question. is it used?
02:12:35 <sinelaw_web> in practice
02:12:50 <sinelaw_web> or perhaps i should ask how it is used
02:15:04 <Twey> > let s x k = k (x * x) in (\x y -> s x $ \xs -> s y $ \ys -> xs + ys) 2 3
02:15:05 <lambdabot>   13
02:15:09 <ziman> well, semantics is the meaning of your program
02:15:17 <Twey> Why *is* a $ required before a lambda?
02:15:29 <Twey> > let s x k = k (x * x) in (\x y -> s x \xs -> s y \ys -> xs + ys) 2 3
02:15:30 <lambdabot>   <no location info>: parse error on input `\'
02:15:36 <trez> :D
02:15:38 <Twey> That doesn't look at all ambiguous to me
02:16:36 <dolio> It isn't required in Agda.
02:16:47 <Twey> Oh, let's all switch to Agda then.
02:16:50 <Twey> Oh wait…
02:17:05 <Twey> To be honest, I'm not even sure quite how that works.
02:17:38 <Twey> Doesn't the fact that $ works but just using it without anything doesn't indicate that there's some magic rule especially for operators before lambdas?
02:17:57 <Twey> Or, more likely, a magic rule especially for lambdas without brackets or operators?
02:18:32 <ziman> sinelaw_web, denotational semantics captures the result/answer of your program, operational semantics is what the program does on hardware. You care about denotational semantics as long as you care about what your program prints.
02:19:17 <dolio> > id case 1 of x -> x
02:19:18 <lambdabot>   <no location info>: parse error on input `case'
02:19:26 <dolio> > id $ case 1 of x -> x
02:19:27 <lambdabot>   1
02:21:44 <dolio> Operators get to dispense with parentheses where function application would normally require them.
02:26:19 <sinelaw> ziman i understand that, but who/when do we actually use the study of denotational semantics? when desigining a new language?
02:26:29 <hackagebot> hsql-sqlite3 1.7.1 - SQLite3 driver for HSQL. (NickRudnick)
02:26:36 <sinelaw> (or studying correctness of a language)?
02:30:10 <yitz> sinelaw: when studying the properties of languages - either existing ones, or a new language you are designing
02:32:37 <yitz> sinelaw: it does come up in conversations about specific programs sometimes, as in: "this doesn't change the semantics of the program, but it affects its asymptotic performance".
02:33:00 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9110#a9110 I'm trying to write map in CPS style, but I'm not really sure how to handle the recursion/list building, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9110#a9110 is my attempt but the compiler complains about infinite type r = [r]
02:35:19 <ski> ezyang : i've on occasion defined `newtype Exn e a = MkExn {unExn :: Either e a}' (and `newtype ExnT e m a = MkExnT {unExnT :: m (Either e a)}' and a `MonadException' class)
02:37:17 <yitz> etpace_: it's easier to define map' :: (a -> b) -> [a] -> ([b] -> r) -> r
02:37:34 <etpace_> hmm
02:37:35 <etpace_> true
02:37:44 <Nereid_> :t const id
02:37:45 <lambdabot> forall a b. b -> a -> a
02:37:49 <Nereid_> @pl \x y -> y
02:37:49 <lambdabot> const id
02:38:06 <yitz> etpace_: with your type, you have to think about what map' means. there will be a different continuation of f coming from each element of the list. what do you do with all of those?
02:38:19 <etpace_> hmm
02:38:34 <etpace_> f being in cps style is the major problem
02:39:38 <yitz> etpace_: your map' is really a little more like mapM -- map a function with "side-effects" over a list, and then collect all of the side effects.
02:40:03 <yitz> @src mapM
02:40:03 <lambdabot> mapM f as = sequence (map f as)
02:40:26 <opqdonut> it took me a while to understand how good a name sequenceis
02:41:01 <idnar> @src sequence
02:41:02 <lambdabot> sequence []     = return []
02:41:02 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:41:02 <lambdabot> --OR
02:41:02 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:41:06 <yitz> it's a little too suggestive of the IO monad for my taste, but OK
02:41:34 <idnar> it's not really specifically suggestive of the IO monad
02:41:46 <malosh> Hi. I need to perform arithmetic in a portable way, i.e. that on two different machines with two different architectures and different implementations of Haskell, the rounding of my floating point operations are _exactly_ the same. How to do this ?
02:41:56 <idnar> but the name only really works when you think of values in the monad as "actions"
02:42:04 <idnar> which works for IO, State, Reader, etc.
02:42:13 <idnar> and not so well for [], Maybe, Either a, etc.
02:42:19 <opqdonut> malosh: afaik, the ieee754 spec leaves some leeway
02:42:23 <opqdonut> so you can never be reallu sure
02:42:27 <yitz> malosh: what guarantees do you have from IEEE?
02:42:30 <shikanai> pl \x y -> x y
02:42:40 <Cale> malosh: I believe GHC just relies on the processor's implementation of floating point arithmetic, so it's the same as with any other language.
02:42:42 <yitz> malosh: use rationals
02:42:58 <malosh> IEEE 754 would be enough, but not all implementations of Haskell seem to respect it. Am I wrong ?
02:43:00 <shikanai> @pl \x y -> x y
02:43:01 <lambdabot> id
02:43:06 <mmorrow> yay coroutines http://moonpatio.com/repos/Scheduler.hs
02:43:06 <Cale> malosh: Yeah, the best I could recommend is just not to use floating point arithmetic at all, or implement your own.
02:43:06 <idnar> > sequence [Just 5, Nothing, Just 10]
02:43:08 <lambdabot>   Nothing
02:43:13 <idnar> > sequence [Just 5, Just 10]
02:43:14 <lambdabot>   Just [5,10]
02:43:19 <Heffalump> malosh: there's no guarantee that they will, but I don't know of any that don't
02:43:21 <idnar> > msum [Just 5, Nothing, Just 10]
02:43:22 <lambdabot>   Just 5
02:43:28 <idnar> > msum [Just 5, Just 10]
02:43:29 <lambdabot>   Just 5
02:43:34 <mmorrow> not sure how to ditch the unsafeCoerce, because if the `a' appears in the State, it's can't be a Monad   anymore..
02:43:36 <idnar> > msum [Nothing, Just 5, Just 10]
02:43:37 <lambdabot>   Just 5
02:43:38 <Cale> You could, for example, use fixed point arithmetic, and that would be reliable in every way.
02:43:44 <etpace_> the way I thought of my map' is that at each 'continuation' it builds another step of my list, but with f being in cps, I'm not sure of another way of doing it
02:44:34 <dolio> @type runCont . sequence . map Cont
02:44:34 <malosh> Cale : Or even reimplement IEEE 754 for the basic operations I need (divisions is the hardest I need)
02:44:35 <lambdabot> forall a r. [(a -> r) -> r] -> ([a] -> r) -> r
02:44:42 <malosh> Ok, thanks
02:44:47 <dons> multicore tutorial made  the top of ycombinator, http://news.ycombinator.com/
02:44:49 <idnar> Cale: unless you actually needed IEEE 754 binary floating point :P
02:45:02 <dons> Heffalump: you back home already?
02:45:12 <Cale> malosh: But as long as the platforms you're talking about implement floating point arithmetic similarly enough for you, then you should be okay.
02:45:17 <Heffalump> dons: Liverpool
02:45:20 * idnar not-so-fondly recalls black-box reverse engineering somebody's floating point implementation
02:45:33 <Heffalump> malosh: I think the standard mandates an isIEEE flag you can check to see if the FP is IEEE.
02:45:39 <Heffalump> but I'm not certain
02:45:42 <opqdonut> was there some way to set the different floating point flags in haskell?
02:45:48 <Cale> :t isIEEE
02:45:49 <lambdabot> forall a. (RealFloat a) => a -> Bool
02:45:53 <opqdonut> rounding types etc
02:46:07 <dolio> @type (runCont .) . mapM . Cont
02:46:07 <opqdonut> istr there not being access to all
02:46:08 <lambdabot>     Couldn't match expected type `a -> m b'
02:46:08 <lambdabot>            against inferred type `Cont r a1'
02:46:08 <lambdabot>     In the second argument of `(.)', namely `Cont'
02:46:16 <etpace_> hmm where does the a come from dolio?
02:46:18 <mmorrow> the unsafeCoerce doesn't leak out of yield/done/schedule though
02:46:21 <dolio> @type (runCont .) . mapM . (Cont .)
02:46:22 <lambdabot> forall a a1 r. (a -> (a1 -> r) -> r) -> [a] -> ([a1] -> r) -> r
02:46:33 <malosh> Heffalump, Cale : right. This simplifies everything, indeed !
02:46:37 <idnar> "True if the argument is an IEEE floating point number "
02:46:39 <idnar> huh?
02:46:44 <Heffalump> idnar: yeah, that confused me too
02:46:47 <shikanai> @pl \k t -> map snd $ filter ((==k) . fst) table
02:46:47 <lambdabot> const . map snd . flip filter table . (. fst) . (==)
02:46:53 <Heffalump> idnar: which was why I didn't make a stronger statement about its behaviour
02:47:09 <idnar> that doesn't sound like it asserts anything about the implementation of operations on that number, anyhow
02:47:16 <Cale> It seems that the standard doesn't specify it very well.
02:47:19 <opqdonut> ieee754 probably mandates isIEEE to return False for NaN or something ;)
02:47:21 <opqdonut> (knowing them)
02:47:43 <Cale> I don't think that isIEEE is actually defined by ieee754
02:47:45 <yitz> > isIEEE (undefined :: Float)
02:47:46 <lambdabot>   True
02:48:07 <Nereid_> :t isIEEE
02:48:08 <opqdonut> ?src isIEEE
02:48:08 <lambdabot> Source not found. Sorry.
02:48:08 <lambdabot> forall a. (RealFloat a) => a -> Bool
02:48:18 <opqdonut> ah, RealFloat
02:48:22 <opqdonut> so it might be something custom
02:48:23 <opqdonut> too
02:48:24 <skorpan> what's RealFloat
02:48:27 <idnar> yitz: oh, hmm
02:48:34 <opqdonut> skorpan: the typeclass that has the trancendental functions
02:48:35 <opqdonut> iirc
02:48:38 <idnar> > isIEEE (undefined :: CFloat)
02:48:39 <lambdabot>   Not in scope: type constructor or class `CFloat'
02:49:00 <Cale> RealFloat is the class with all the floating-point-representation specific things in it, along with atan2 for some reason :P
02:49:01 <opqdonut> no, it has decodeFloat, encodeFloat etc
02:49:12 <opqdonut> heh, yeah atan2
02:49:17 <yitz> > isIEEE (undefined :: CReal)
02:49:18 <lambdabot>   False
02:49:49 <Axman6> > isIEEE (1/0 :: Double)
02:49:50 <lambdabot>   True
02:50:13 <Axman6> does IEEE-754 have ±Infinity?
02:50:43 <yitz> Axman6: the ieee value "infinity" is not _|_
02:50:44 <Saizan> yes
02:51:01 <Axman6> yitz: i never said it was :)
02:51:03 <shikanai> @pl \k t -> map snd $ filter ((==k) . fst) t
02:51:04 <lambdabot> (map snd .) . filter . (. fst) . (==)
02:51:05 <Saizan> > - (1/0)
02:51:06 <lambdabot>   -Infinity
02:51:09 <Saizan> > (1/0)
02:51:10 <lambdabot>   Infinity
02:51:14 <mmorrow> , negate (1/0) == (1/0)
02:51:16 <lunabot>  False
02:51:26 <mmorrow> , negate 0 == 0
02:51:27 <lunabot>  True
02:51:34 <Axman6> > negate 0 == (0 :: Double)
02:51:35 <mmorrow> , negate (0/0) == (0/0)
02:51:36 <lambdabot>   True
02:51:36 <lunabot>  False
02:51:38 <Cale> Axman6: yes, it does.
02:51:41 <dolio> > 1 / (-0)
02:51:42 <lambdabot>   -Infinity
02:51:49 <Axman6> righto, i couldn't remember
02:51:53 <mmorrow> yay, negative NaN
02:51:57 <mmorrow> , negate (0/0)
02:51:57 <Cale> Axman6: It has Infinity, -Infinity, as well as NaN
02:51:58 <lunabot>  NaN
02:52:01 * Axman6 still thinks that IEEE-743 is pretty cool
02:52:04 <mmorrow> oh
02:52:07 <yitz> > (-1::Float)/0
02:52:08 <lambdabot>   -Infinity
02:52:10 <mmorrow> no, NaN never (==) anything..
02:52:12 <Cale> (but no negative NaN, that's just NaN again)
02:52:13 <Axman6> > negate NaN
02:52:14 <lambdabot>   Not in scope: data constructor `NaN'
02:52:17 <yitz> > (-0::Float)/1
02:52:18 <lambdabot>   -0.0
02:52:20 <Axman6> > negate (0/0)
02:52:21 <lambdabot>   NaN
02:52:24 <Axman6> :(
02:52:28 <Cale> > let x = (0/0) in x == x
02:52:28 <mmorrow> yitz: ah nice
02:52:29 <lambdabot>   False
02:52:43 <Saizan> reflexivity ftw
02:52:47 <yitz> > (-0::Float)/1==0
02:52:48 <lambdabot>   True
02:52:58 <mmorrow> , negate 0 :: Double
02:52:58 * Axman6 dislikes this
02:52:59 <lunabot>  -0.0
02:53:07 <yitz> > 1/((-0::Float)/1)
02:53:08 <lambdabot>   -Infinity
02:53:12 * Axman6 likes forall x. x = x
02:53:34 <Cale> > let x = (0/0) in x /= x
02:53:35 <lambdabot>   True
02:53:40 <dons> @tell tibbe when need a nice example of latency hiding heavily concurrent web server for teaching
02:53:41 <lambdabot> Consider it noted.
02:53:43 <Cale> > let x = (0/0) in x < x
02:53:44 <lambdabot>   False
02:53:54 <Cale> > let x = (0/0) in x > x
02:53:55 <lambdabot>   False
02:54:03 <mmorrow> instance Eq NaN where (==) = (/=)
02:54:04 <Cale> All comparisons fail on NaN
02:54:05 <mmorrow> fixed
02:54:25 <Axman6> > (0/0) == (0/0 :: CReal)
02:54:30 <ski> Berengal : in case you're interested, i added `caseExn :: MonadException e m => m a -> (e -> m b) -> (a -> m b) -> m b' to `throwExn' and `catchExn'
02:54:30 <lambdabot>   mueval-core: Prelude.read: no parse
02:54:30 <lambdabot>  mueval: ExitFailure 1
02:54:33 <Cale> Well... except not equal to, I suppose ;)
02:54:35 <Axman6> heh
02:54:51 <dolio> > compare (0/0) (0/)
02:54:53 <lambdabot>   No instance for (GHC.Real.Fractional (t -> t))
02:54:53 <lambdabot>    arising from a use of `GH...
02:54:54 <dolio> > compare (0/0) (0/0)
02:54:55 <lambdabot>   GT
02:55:20 <ski> idnar : why not so well for `[]',`Maybe',`Either e', et.c. ?
02:55:24 <Axman6> > 0/0 :: CReal
02:55:30 <mmorrow> Axman6: you should also restrict yourself to counting to any number you refer to too :)
02:55:35 <ski> (idnar : and why for `Reader r' ?)
02:55:37 <yitz> > (0/0) > (0/0)
02:55:38 <lambdabot>   False
02:55:39 <lambdabot>   thread killed
02:55:49 <Axman6> mmorrow: eh?
02:56:01 <idnar> ski: it doesn't help me to think of values in those monads as "actions"
02:56:03 <mmorrow> Axman6: random ranting
02:56:13 <Cale> The moral of the story is that floating point is scary.
02:56:16 <Axman6> hoorah!
02:56:28 <Axman6> Cale: but also brilliant
02:56:46 <Cale> Addition and multiplication are commutative, but not associative.
02:56:59 <mmorrow> > compare (0/0) (0/0)
02:57:00 <lambdabot>   GT
02:57:01 <mmorrow> oo
02:57:18 <ski> idnar : you don't think of non-deterministic, failing, or exception-raising computations as "actions" ?
02:57:19 <Axman6> > (0/0) > (0/0)
02:57:19 <yitz> Cale: yeah, you're right, fixed point is often better than rational for many cases that you would have otherwise used fp
02:57:20 <lambdabot>   False
02:57:21 <mmorrow> that can't be in the spec..
02:57:26 <Axman6> INCONSISTENT!
02:57:46 <ski> (idnar : and why `Reader r' then, taking into account that that one is "commutative" ?)
02:58:01 <Axman6> guess it's defined as compare NaN _ = GT
02:58:07 <Cale> We should really get a good interval arithmetic library too :)
02:58:27 <yitz> floating point is scary - yet we're often forced into it due to current hardware architectures.
02:58:29 <idnar> ski: "perform Nothing" or "perform Just 5" doesn't mean anything to my intuition
02:58:32 <Cale> Though there are things like FFT which apparently don't work so well with interval arithmetic.
02:58:32 <dolio> > compare (0/0) undefined
02:58:34 <lambdabot>   * Exception: Prelude.undefined
02:58:35 <Saizan> ?src compare
02:58:35 <lambdabot> compare x y | x == y    = EQ
02:58:35 <lambdabot>             | x <= y    = LT
02:58:35 <lambdabot>             | otherwise = GT
02:58:41 <Saizan> othwerwise!
02:58:46 <idnar> ski: "perform (+10)" makes some sense
02:58:49 <ski> Axman6 : ^
02:59:06 <Axman6> ?
02:59:10 <idnar> ski: and the non-determinism thing doesn't really work for me either, so I don't generally think about [] like that
02:59:49 <Cale> idnar: "Running" a list means to pick one of its elements.
02:59:49 <ski> idnar : have you seen Prolog (or SNOBOL, i suppose) ?
02:59:58 <Cale> (in all possible ways)
03:00:43 <ski> (idnar : instead of `Nothing' you may say (or think) `mzero')
03:00:54 <mmorrow> , time ((length . fft . fmap fromIntegral) [0..2^20-1])
03:00:54 <dons> hey guys. i think i'll put my pdf material (talks and slides) on the blog in flash format. like this, http://donsbot.wordpress.com/
03:00:54 <ski> (and `Just' is just `return')
03:00:54 <idnar> ski: no, I'm not really familiar with prolog
03:00:57 <lunabot>  (2.214663,1048576)
03:00:57 <dons> what do people think?
03:01:11 <dons> is this a good way to go for online .pdf stuff? making it more accessible? (embedding in blog pages etc)
03:01:20 <idnar> Cale: well, I can figure that out because I know how the [] monad works
03:01:47 <idnar> but it doesn't seem to help my intuition at all
03:01:57 <ski> why ?
03:02:41 <Cale> idnar: So when you're faced with something like   filterM (const [True, False])  you can read it like "for each element of the list, regardless of its value (const), we either keep it (True) or drop it (False)
03:02:52 <dons> ski: accessibility. people don't read linked .pdf as much as when it is in their face in a html page
03:02:56 <Jafet> dons, flash is a brilliant way to make sure other programmers avoid your website.
03:03:19 <Cale> idnar: You interpret the list as a list of possibilities, with the understanding that all possibilities will be tried.
03:03:25 <ski> (idnar : maybe you just need to extend your intuition with the notion of "(angelic) nondeterministic computation" .. (no disrespect intended))
03:03:30 <Jafet> So is using scribd.
03:03:31 <Cale> > filterM (const [True, False]) [1,2,3]
03:03:33 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
03:03:39 <ski> dons : sorry, that was for idnar :)
03:04:15 <ski> dons : ok. i don't read/watch flash much .. but maybe for those who do ..
03:04:17 <shikanai> @pl \k -> map snd . filter ((==k) . fst)
03:04:17 <lambdabot> (map snd .) . filter . (. fst) . (==)
03:04:31 <Cale> dons: I used them.
03:04:32 <Saizan> dons: i'd keep a direct link to the .pdf too
03:04:37 <dons> definitely
03:04:52 <dons> there's just something more immediate also having the slides, say, right        there.
03:04:56 <dons> maybe less so important for papers
03:05:09 <Cale> Yeah, for papers, it's mostly just annoying.
03:05:13 <Cale> But for slides it's good.
03:05:55 <Saizan> *nod*
03:06:20 <idnar> I mostly just use Google's PDF reader
03:06:32 <idnar> I dunno if there's some way to embed that, though
03:07:29 <dons> i think long term, the multicore slides, for example, while be far more widely read in the 'embedded form', http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
03:07:34 <dons> than if i just post a link to them.
03:07:49 <mmorrow> dons: yeah, having it embedded like that is kinda handy
03:07:53 <dons> so since we have so many good slide makers in our community, i wonder if more people should be putting them online.
03:08:02 <dons> like the 50 talks on haskell this week at icfp ...
03:08:57 <idnar> are the slides actually of any use to somebody who didn't see the talk?
03:09:16 <dons> i hope so.
03:09:19 <dons> there's code as well.
03:09:28 <idnar> (disclaimer: I haven't looked at the slides we're actually discussing :P)
03:10:17 <idnar> I sometimes find it a bit frustrating to look at some slides and go "wow, that looks like a really awesome talk, but these slides mean nothing to me by themselves"
03:10:32 <ski> etpace_ : that paste looks a bit strange
03:11:02 <ski> etpace_ : can you define one with same semantics as (the only dolio showed) `(runCont .) . mapM . (Cont .)' ?
03:11:57 <Jafet> Even better might be to take a video of yourself with the slides, but I suppose that is no longer an option
03:11:59 <ski> etpace_ : or perhaps the one yitz suggested (i.e. `(a -> b) -> [a] -> ([b] -> r) -> r')
03:12:07 <weirdo> hey, i have problems with compiling GHC on lfs
03:12:34 <weirdo> http://paste.lisp.org/display/86646
03:12:44 <weirdo> that's after i unpacked the source and the binary to the same directory
03:13:32 <weirdo> anything i'm doing wrong?
03:13:59 <ivanm> weirdo: apart from using LFS? :p
03:14:13 <Saizan> maybe unpacking them to the same directory is the problem
03:14:19 <ivanm> yeah
03:14:47 <Saizan> you've to properly install the binary package first
03:14:54 <Saizan> and then compile from source if you want
03:15:00 <ManateeLazyCat> dons: I'm developing dynamic gtk application, now i just use Data.Binary keep minimum information through reboot, after reboot, i rebuild those widgets with those states, so have you better suggestions for my solution?
03:15:15 <ski> @type let map' f [x] k = f x $ \x' ->  [k x']; map' f (x:xs) k = f x $ \x' -> x':(map' f xs k) in map'
03:15:16 <lambdabot> forall t a. (t -> (a -> [a]) -> [a]) -> [t] -> (a -> a) -> [a]
03:15:39 <ski> not quite `(a -> (b -> r) -> r) -> [a] -> (b -> r) -> r' :)
03:17:46 <dolio> @type (runCont .) . mapM . return
03:17:48 <lambdabot> forall r a b. Cont r b -> [a] -> ([b] -> r) -> r
03:17:59 <dolio> @type (runCont .) . mapM . (return .)
03:18:00 <lambdabot> forall r a b. (a -> b) -> [a] -> ([b] -> r) -> r
03:21:46 <etpace_> I can do the yitz suggestion, but I'm struggling with dolios
03:22:35 <|Steve|> *sigh* After 101 minutes of computation, I get the message: Error in array index. How useless is that?
03:23:35 <etpace_> I'm just.. not sure at all heh
03:24:14 <etpace_> It's like.. I need to pass k the entire 'intermediate' list for a [b], and then use that result on the list again
03:25:55 <ski> etpace_ : no, don't pass intermediate lists (in the sense of prefices of the result list) around
03:27:17 <weirdo> thanks, it now works
03:27:23 <weirdo> i don't even have to build from source
03:27:42 <ski> Guest62807 : is there a reason you renick from `yitz___' to `Guest62807' when you join (and presumably just connected) ?
03:28:08 <Guest62807> ski: I dunno. ask the authors of colloquy
03:29:28 <Phyx-> damn, these flash games can be so addictive
03:29:55 <arw_> Phyx-: get a slow thin-client where flash sucks. definitely increases productivity :)
03:30:04 <etpace_> Well, f 'returns' a b to be passed, but k wants a list of a1s before it can return a r,
03:30:12 <shikanai> @unpl (map snd .) . filter . (. fst) . (==)
03:30:12 <lambdabot> (\ e n -> map snd (filter (\ q -> e == (fst q)) n))
03:32:00 <ski> arw_ : like w3m, perchance ?
03:32:14 <Peaker> @unpl f `ap` g
03:32:14 <lambdabot> (f >>= \ b -> g >>= \ a -> return (b a))
03:32:17 <arw_> ski: yes, that would also help :)
03:33:02 <dolio> etpace_: f a calls something with a b, and map f as calls something with a [b]. You need to combine those two.
03:33:05 <arw_> ski: but i thought of some slow netbook, a x-terminal or x over a slow ssh connection :)
03:33:15 <Peaker> @pl \x -> f x (g x)
03:33:15 <lambdabot> ap f g
03:33:31 <Phyx-> arw_: lol
03:33:32 <ski> etpace_ : so call `f', call your function recursively, then do what ?
03:33:34 <dolio> And call k with the combination.
03:34:34 <Peaker> |Steve|: Lack of dependent types :-(
03:35:09 <ski> arw_ : .. or possibly <http://zemljanka.sourceforge.net/cursed/> Cursed GTK
03:35:23 <|Steve|> Peaker: I'm not sure I follow.
03:35:40 <arw_> ski: lol
03:35:59 <|Steve|> Oh, actually, I do think I follow.
03:36:45 <|Steve|> I don't really care that the type system doesn't catch it, I just want a better error message that doesn't require my sitting around for an hour and 40 minutes to learn _nothing_.
03:37:30 <ski> (arw_ : see e.g. <http://web.archive.org/web/20070721230516/http://zemljanka.sourceforge.net/cursed/screenshots/xchat-1.png> and <http://web.archive.org/web/20070721230344/http://zemljanka.sourceforge.net/cursed/screenshots/xchat-2.png>)
03:37:36 <dolio> Well, you rather need types to avoid spending the 40 minutes.
03:37:41 <dolio> Or to try on smaller test cases. :)
03:38:03 <Peaker> |Steve|: surely you learned *some* :-)
03:38:12 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9112#a9112 something like that?
03:38:24 <arw_> ski: cool.
03:38:25 <|Steve|> It works on smaller test cases. What I would like is some indication of which array was trying to be accessed out of bounds and what that index was.
03:38:43 <|Steve|> Peaker: I learned nothing at all other than the 1 bit of information: it didn't work.
03:38:47 <Peaker> it would be nice if Haskell was more debuggable without running in ghci/etc. Even C is debuggable when its run without any special flags
03:39:04 <|Steve|> I don't know how to debug Haskell at all.
03:39:06 <Peaker> |Steve|: You learned it was an index error. You also learned how long it took to hit that index error..
03:39:16 <|Steve|> That isn't really very useful.
03:39:18 <arw_> uhm. is it possible, that the haskell platform is allergic against ghc which was installed with ghc-extralibs?
03:39:29 <ski> etpace_ : next time, try to remember to annotate the original paste :)
03:39:33 <Peaker> maybe "gdb" itself can be extended with ghc as a language?
03:39:39 <etpace_> heh
03:39:43 <etpace_> hmm that doesn't have the correct type, but i'm not sure how else to build a [b]
03:39:50 <|Steve|> I wish Haskell could at least do printf-style debugging. =(
03:39:54 <Peaker> |Steve|: sure it is, now you look at all your indexing operations in arrays and try to prove that they are in bounds, until you see why they're not
03:40:00 <Peaker> |Steve|: it can, see Debug.Trace
03:40:39 <Peaker> though its really missing: traceId :: Show a => String -> a -> a ; traceId prefix x = trace (prefix ++ show x) x
03:41:03 <ski> @type let map' f xs k = k (maph f xs) where maph f [x] = f x $ \x' -> [x']; maph f (x:xs) = f x $ \x' -> x':(maph f xs) in map\
03:41:04 <lambdabot> parse error on input `\'
03:41:06 <ski> @type let map' f xs k = k (maph f xs) where maph f [x] = f x $ \x' -> [x']; maph f (x:xs) = f x $ \x' -> x':(maph f xs) in map'
03:41:07 <lambdabot> forall t t1 t2. (t -> (t1 -> [t1]) -> [t1]) -> [t] -> ([t1] -> t2) -> t2
03:41:19 <|Steve|> I had no idea about trace! How can it exist in Haskell?
03:41:25 <Saizan> arw_: there may be some problems, yeah
03:41:40 <Saizan> arw_: the build scripts are not that good, i've found
03:41:45 <mmorrow> |Steve|: peek nullPtr
03:42:03 <|Steve|> I don't know what you mean by that.
03:42:23 <ski> etpace_ : that doesn't pass around the continuation in the loop, which is more or less the point
03:42:36 <|Steve|> *sigh* Another program just finished after 71 minutes with Char.digitToInt: not a digit '-'
03:42:40 <mmorrow> |Steve|: you can do anything you want in haskell :)
03:42:40 <Saizan> arw_: i should revise that, the part that chooses the dependencies is not as smart as cabal-install, because it needs to work before cabal-install is built :)
03:42:59 <etpace_> hmm
03:43:13 <etpace_> i'm not sure how else to get a [b]
03:43:45 <|Steve|> mmorrow: A function trace :: String -> a -> a that prints its first argument? That would make Haskell not pure functional since trace would have side effects.
03:44:02 <ski> etpace_ : a hint. just as you are calling `f', passing a continuation, so should the recursive call also be called, passing a continuation
03:44:21 <Saizan> |Steve|: in fact it's not ref. transparent, but it's ok for debugging :)
03:44:35 <Saizan> |Steve|: it's implemented via unsafePerformIO
03:44:35 <arw_> Saizan: k., i'll see if it works without the extralibs and report back to you.
03:44:47 <Saizan> arw_: k
03:45:33 <ski> (etpace_ : so instead of just `f x' you have `f x $ \.. -> ...'. similarly, instead of just `map f xs' you should have `map f xs $ \.. -> ...')
03:45:50 <c_wraith> Hmm.  This feels like something I'm making this harder than I should be..  I want to go from [[a]] -> [a], breadth-first.
03:45:55 <|Steve|> Saizan: Is that a ghc extension?
03:46:22 <ivanm> |Steve|: unsafePerformIO is part of the FFI spec, IIRC
03:46:26 <ivanm> so it's not ghc-specific
03:46:56 <|Steve|> Seems like Haskell would have to give up the claim of being pure functional then.
03:47:06 <ivanm> |Steve|: not really
03:47:14 <Saizan> |Steve|: it's part of the Foreign Function Interface, it's purpouse is e.g. to give a pure type to functions you import from C, even if you do some marshalling
03:47:16 <Peaker> |Steve|: unsafePerformIO is an escape from purity and basically a violation of Haskell's principles. It is allowed in 2 main cases: A) debugging outputs, you don't care about such side effects being unpredictable and hidden in expressions,  B) Where an IO action is actually pure, and you know it, but its still hiding behind an IO type
03:47:16 <mmorrow> |Steve|: haskell wouldn't be very useful as a general purpose programming language without the ability to zero all your memory behind your back when you thought you were just adding 1 to 4, now would it ;)
03:47:27 <ivanm> mmorrow: heh
03:47:45 <Peaker> |Steve|: Haskell is not truly purely functional in the strictest sense, right
03:47:55 <Peaker> |Steve|: (Unless you forbid unsafePerformIO and some others)
03:47:57 <ivanm> basically, you should only be using unsafePerformIO when you know the IO action is pure
03:48:06 <Peaker> ivanm: or when you want debugging outputs :)
03:48:15 <Peaker> ivanm: that expose the evaluation order/etc
03:48:18 <ivanm> Peaker: well, that's in the library
03:48:27 <ski> |Steve| : i think the idea is that if you only use it for external observation (such as debugging or maybe logging) (i.e. the haskell program can't access the information), then the results of the haskell program can't depend on the side-effect
03:48:34 <ivanm> how often do you manually use unsafePerformIO for debugging purposes?
03:48:38 <Berengal> Even getting rid of unsafePerformIO wouldn't make it entirely pure. There's still memory allocation and cpu-cycles going on
03:48:41 <c_wraith> ok, that last sentence I posted is incoherent enough that the answer must be "sleep now, I'll be able to think on my own in the morning".
03:49:02 <ski> (|Steve| : cf. running the program uses up OS resources that can externally be observed)
03:49:13 <Berengal> At some point you need to say you've got enough purity though
03:49:20 <ivanm> ski: naughty OS resources!
03:49:28 <|Steve|> That's outside the scope of the language, though, no?
03:49:29 <Berengal> c_wraith, transpose
03:49:32 <ivanm> Berengal: on pen and paper :p
03:50:03 <c_wraith> :t transpose
03:50:04 <lambdabot> forall a. [[a]] -> [[a]]
03:50:16 <Peaker> Berengal: by "entirely pure" nobody means having none of that, just referential transparency and all
03:50:16 <c_wraith> with a concatMap thrown in?
03:50:18 <mux> if I want to write a function for all integral types, say Integral a => a -> a, and that this function uses STArray's containing this type of elements, am I forced to use ScopedTypeVariables and give my function a type forall a. (Ix a, Integral a) => a -> a ?
03:50:18 <Berengal> > transpose [[1,2,3],[1,2,3],[1,2,3]]
03:50:19 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3]]
03:50:32 <Peaker> Berengal: You could still expose the allocations by getting bottoms under some cases and not in others, etc, but that's becoming far fetched
03:50:34 <ski> |Steve| : yes. but you could observe the tracing by feeding back stderr. similarly you could observe the OS resources used by querying other OS tools from the program
03:50:37 <Berengal> > concat . transpose (replicate 3 [1,2,3])
03:50:38 <lambdabot>   Couldn't match expected type `a -> [[a1]]'
03:50:42 <Berengal> > concat . transpose $ (replicate 3 [1,2,3])
03:50:43 <lambdabot>   [1,1,1,2,2,2,3,3,3]
03:51:04 <Berengal> Peaker, that's sort of my point
03:51:10 <c_wraith> err, yes.  just concat
03:51:26 <Berengal> Peaker, at one point, things become far fetched enough that you can ignore them
03:51:29 <Peaker> Berengal: well, unsafePerformIO breaks referential transparency, it breaks more than the memory allocations/etc do behind the scenes
03:51:30 <Berengal> But they're not gone
03:52:08 <mmorrow> Peaker: what does it "break"?
03:52:14 <|Steve|> What's the highest level of optimization ghc allows? The man page isn't explicit.
03:52:15 <ski> Berengal : imo, "pure" is about the interface, not exaclty how things are implemented
03:52:21 <Berengal> Peaker, we're still not talking absolutes
03:52:22 <Peaker> mmorrow: ref. transparency
03:52:29 <Berengal> |Steve|, O2
03:52:46 <|Steve|> Berengal: Okay, thanks. If you give higher does it just do -O2?
03:52:51 <Peaker> does ghc's rts support changing the number of cores being used by the Haskell program?
03:52:52 <mmorrow> Peaker: so nothing other than an idea is broken
03:53:03 <ski> |Steve| : yes .. earlier versions did no optimizations then, though
03:53:07 <Peaker> mmorrow: unless its misused, yeah
03:53:15 <Peaker> mmorrow: I'm not against having unsafePerformIO somewhere
03:53:17 <ski> (or maybe default)
03:53:17 <ManateeLazyCat> mmorrow: I got "[([],UnQual (Ident "FooClass"),[TyCon (UnQual (Ident "TypeA"))]),([],UnQual (Ident "FooClass"),[TyCon (UnQual (Ident "TypeB"))])]" from hs_instance.hs, how to get Type that QName match "FooClass" ?
03:53:19 <|Steve|> ski: Heh, that's confusing.
03:53:51 <etpace_> ski: I think I've got it http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9112#a9113
03:54:17 <Berengal> ski, even referentially transparent functions aren't really. If they were, we'd only care about what input gets mapped to what output, not how much memory or time it spends doing that
03:54:19 <mmorrow> filterByClass classname = filter (\(_,UnQual (Ident cn),_) -> classname == cn) -- ?
03:54:27 <ski> etpace_ : that's good
03:54:42 <ski> etpace_ : the only thing which is missing is making it work on empty lists, as well
03:54:48 <etpace_> just did that!
03:55:04 <etpace_> thanks for the help
03:55:19 <ski> (and maybe  xss  is more commonly named like  xs')
03:55:43 <ManateeLazyCat> mmorrow: Yep, i did it before, i got "not in scope: data constructor `Indent`:"
03:56:09 <ski> etpace_ : if you want more to practice on, try "CPS-ifying" `foldl' and `foldr'
03:56:28 <ManateeLazyCat> mmorrow: It's `Indent` in Language.Haskell.Pretty ?
03:57:10 <ManateeLazyCat> mmorrow: I haven't found any "data Indent"
03:58:06 <etpace_> How do I know what type I'm aiming for? foldlc :: (b -> a -> (b -> r) -> r) -> b -> [a] -> ([b] -> r) -> r?
03:58:08 <tavelram> > [1133/1500,864/1000]
03:58:09 <lambdabot>   [0.7553333333333333,0.864]
03:59:06 <ski> Berengal : on one level of reasoning, we only care about the mapping defined (i.e. the level of reasoning we use *inside* haskell, to determine if we're implementing the right thing). on another level (an "outside" level, one could maybe say), we're interested in things like efficiency .. but then we have to keep track of that the language processor is allowed to perform optimizations, so this is already not "inside haskell" 
04:00:54 <ski> etpace_ : replace the "result type" `foo' of every function (interpreted loosely as something curried with zero or more "argument types") with `(foo -> r) -> r'
04:01:04 <ski> @type foldl
04:01:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:01:46 <ski> that gives `(a -> b -> (a -> r) -> r) -> a -> [b] -> (a -> r) -> r'
04:04:03 <etpace_> ok, thanks
04:17:50 <Nereid_> :t foldr
04:17:51 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:17:53 <Nereid_> :t foldl . flip
04:17:55 <lambdabot> forall b c. (b -> c -> c) -> c -> [b] -> c
04:18:08 <alinp> hi
04:18:23 <alinp> how can I add multiple numbers using prefix notation for '+' ?
04:18:28 <Nereid_> fold
04:18:29 <alinp> (+) 1 2 3
04:18:31 <alinp> doesn't work
04:18:38 <alinp> ah, this is the only way ?
04:18:40 <Nereid_> foldr (+) 0 [1, 2, 3]
04:18:56 <Nereid_> or
04:18:59 <Nereid_> sum [1, 2, 3]
04:19:00 <Nereid_> :-)
04:19:03 <alinp> yeah :)
04:19:09 <alinp> thanks Nereid
04:19:23 <alinp> I thought there is some syntactic sugar for this
04:19:39 <Jafet> foldl' (+) 0 [1..3]
04:20:00 <alinp> ok ok, this is available also in lisp
04:20:01 <Jafet> s/'//
04:20:15 <alinp> I was asking if there is something for haskell
04:20:19 <alinp> (+ 1 2 3) in lisp
04:20:25 <alinp> no need for reduce (fold)
04:20:27 <Nereid_> well, lisp's + acts more like haskell's sum than (+)
04:20:47 <alinp> '+' in haskell is a function, right ?
04:20:53 <Jafet> + is an n-ary function in lisp, and a binary operator in Haskell
04:20:55 <Nereid_> from what I know about lisp anyway (which isn't very much)
04:20:56 <Nereid_> :t (:)
04:20:57 <Nereid_> er
04:20:58 <lambdabot> forall a. a -> [a] -> [a]
04:20:59 <Nereid_> :t (+)
04:21:00 <lambdabot> forall a. (Num a) => a -> a -> a
04:21:08 <Nereid_> (+) is just a regular function
04:21:23 <alinp> yeah, a function which takes only 2 params
04:21:26 <Nereid_> yeah
04:21:32 <Jafet> alinp, Haskell is not lisp.
04:21:42 <Jafet> It has a real type system, for one thing
04:21:45 <alinp> yeah, Jafet, I think I know that :)
04:21:59 <alinp> I was asking for a syntactic sugar
04:22:06 <alinp> not acusing or something
04:22:23 <alinp> and it seems that fold will suffice
04:22:26 <alinp> thanks again
04:22:26 <Jafet> Haskell has much more syntactic sugar than lisp, but not in this area
04:22:30 <dolio> > sum [1,2,3,4,5]
04:22:32 <lambdabot>   15
04:23:20 <dons> oh, you want  to overload (+) on streams?
04:23:28 <Jafet> > plus [1,2,3,4,5] where plus = foldr (+) 0
04:23:30 <lambdabot>   <no location info>: parse error on input `where'
04:23:34 <dons> there's already a class for that
04:23:38 <dons> instance Num Stream
04:24:07 <dons> doesn't need special syntax. just type classes
04:24:11 <dons> http://hackage.haskell.org/package/hinze-streams
04:24:19 <alinp> great dons
04:24:20 <alinp> thanks
04:24:30 * liyang is having a post ICFP lie-in
04:24:33 <dons> its unidiomatic, but nice.
04:24:40 * dons is on the train out of edinburgh
04:24:49 <liyang> 3G?
04:24:53 <dons> no, wifi
04:24:57 <liyang> :3
04:25:05 <dons> great invention. wifi on trains
04:25:05 <Phyx-> @src sum
04:25:06 <lambdabot> sum = foldl (+) 0
04:25:06 <ManateeLazyCat> mmorrow: Sorry typeo for Ident.
04:25:20 <Phyx-> hmm no foldl'
04:25:29 <liyang> well, there's a few tunnels on the way out...
04:25:42 <dons> oh, here comes one now.
04:25:57 <ManateeLazyCat> dons: I'm developing dynamic gtk application, now i just use Data.Binary keep minimum information through reboot, after reboot, i rebuild those widgets with those states, so have you better suggestions for my solution?
04:26:16 <dons> that's a reasonable way to do it.
04:27:38 <liyang> dons: ps: finished reading your slides. good stuff.
04:27:55 <ManateeLazyCat> dons: Example, in current gtk session i have active process to receive data for IRC-channel, i need keep those process active for rebuild IRC-channel after reboot? Or better solution?
04:28:07 <dons> liyang: cool. it feels like we have some momentum in this area
04:28:55 <dons> alexsuraci: note also that package defines numeric literal streams
04:29:00 <dons> alinp ^^
04:29:04 <dons> 1 :: Stream Int
04:29:08 <dons> is the same as [1..]
04:30:21 <dons> Prelude Data.Stream.Hinze.Stream Data.Stream> Data.Stream.take 10 (7 * 2)
04:30:22 <dons> [14,14,14,14,14,14,14,14,14,14]
04:30:26 <ManateeLazyCat> mmorrow: I got Type with "TyCon (UnQual (Ident "TypeA"))", so how to build "tagmap = M.fromList [(typeIdOf Type, Exists (Dict :: PageViewStateDict Type))] ?
04:30:40 <ManateeLazyCat> by haskell-scr-exts
04:30:52 <liyang> I hadn't realised we could get such good concurrency out of `par` these days. that is a huge win.
04:32:11 <dons> yeah, its working pretty well
04:32:40 * dons cabal installs on a train.
04:33:49 <olsner> "* dons cabal installs a train"
04:33:56 <liyang> (and by concurrency I mean parallelism. I've just woken up again after falling asleep again at 9-ish.)
04:34:38 <ManateeLazyCat> Saizan: I got Language.Haskell.Exts.Syntax.Type with "TyCon (UnQual (Ident "TypeA"))", so how to build "tagmap = M.fromList [(typeIdOf Type, Exists (Dict :: PageViewStateDict Type))] by haskell-src-exts?
04:34:40 <Vanadium> I read the DEFUN multicore thing someone linked on the list and now I am v. excited to write parallel and/or concurrent things. <:)
04:36:12 * liyang is slightly annoyed he missed the DPH on GPUs talk. D:
04:36:16 <hackagebot> HUnit 1.2.2.0 - A unit testing framework for Haskell (RichardGiraud)
04:37:00 <dons> we clearly need to talk more about parallelism approaches, and present more useful programs using it.
04:38:02 <olsner> yeah, real-world examples would help a lot I think
04:38:19 <Vanadium> And then we need to post them on the wiki so that I do not only find them by accident in some dust-filled pdfs
04:39:02 <dons> there's good stuff in RWH. and we need to more widely document the great stuff that is put into dusty papers
04:44:06 <Saizan> ManateeLazyCat: you could parse an example expression of that form and then show it to see which contructors are used
04:44:24 <Saizan> ManateeLazyCat: i never used haskell-src-exts much
04:44:27 <liyang> I remember some work on speculative evaluation for Haskell/GHC, which in a sense, tries to automatically infer `par` annotations. Anyone know what happened with that work?
04:50:20 <Zeiris> In Haskell, making many different copies of a tree that differ by a single node is very efficient right?
04:53:27 <Guest62807> Zeiris: depend where that node is
04:53:37 <arjanb> liyang: afaik these things stranded on being too hard to find decent size chunks of work and the overhead of `par`
04:53:47 <Berengal> Zeiris, only the path from the changed node back to the root is copied
05:02:44 <dons> liyang: Satnam wrote a paper about it.
05:03:03 <dons> with the old sparks code, he was able to auto-parallelize over 2-4 cores.
05:03:15 <dons> but didn't get anything earth shattering. it needs to be redone.
05:06:59 <ManateeLazyCat> Saizan: Thanks, I well read more resource about Template Haskell.
05:08:14 <olsner> is there an IORef-like thing that has an Ord instance?
05:08:24 <olsner> I want to build a set of IORefs, essentially
05:09:04 <MyCatVerbs> olsner: There was talk of adding an Ord instance to IORefs, but it got shouted down because it'd have made a lot of peoples' programs a lot slower.
05:09:38 <yitz> olsner: you don't need any relationship with what's in the IORefs I hope
05:09:51 <MyCatVerbs> olsner: or, sure. data OrderRef a = OrderRef { refTag :: Int, ref :: IORef a; }.
05:10:12 <yitz> olsner: so then just wrap them and number them
05:10:24 <MyCatVerbs> Then you just define readOrderRef as (readIORef . ref), and the Ord instance as (compare `on` refTag).
05:10:37 <olsner> that would work, but is also ugly
05:10:58 <mauke> MyCatVerbs: how do you define newOrderRef?
05:11:08 <yitz> olsner: it's not that ugly. It actually describes exactly what you're asking for
05:11:37 <yitz> mauke: right, it's only neat if he can define them all at once at the beginning
05:11:53 <MyCatVerbs> mauke: sadbunnies. :(
05:12:00 <mauke> with unsafePerformIO!
05:12:12 <yitz> or keep an IORef containing the last serial number used
05:12:19 <MyCatVerbs> Rouuughly. I bet there's another way you could do it.
05:12:23 <mauke> yes, and that IORef will be global
05:12:28 <ski> (btw, this is an argument why in `MonadRef ref m', the FD `m -> ref' is not sensible)
05:12:29 <olsner> I would need to introduce a source of those tags yes... hmm, thinking about it, I seem to recall having this discussion before
05:13:22 <yitz> the whole idea of keeping a map of IORefs sounds pretty global.
05:13:49 <yitz> you'd rather avoid that to begin with
05:13:54 <mauke> too bad you're not having this problem in javascript, because then I'd have a prewritten solution :-)
05:13:55 <olsner> but it's only global within a small part of the program :)
05:14:00 <ski> mauke : maybe `newOrderRef :: MonadRef ref m => a -> ReaderT (ref Integer) m (OrderRef ref a)' ?
05:14:59 <benmachine> guys, is there a haskell interface to strftime or do I just use printf and tdBlah
05:15:14 <benmachine> er not tdBlah
05:15:25 <ski> `tdBleh' ?
05:15:26 <hackagebot> synthesizer-alsa 0.0.3 - Control synthesizer effects via ALSA/MIDI (HenningThielemann)
05:15:28 <hackagebot> synthesizer-dimensional 0.3 - Audio signal processing with static physical dimensions (HenningThielemann)
05:15:34 <arw_> Saizan: works if ghc is built without the extralibs.
05:15:38 <yitz> benmachine: not using Data.Time?
05:15:49 <benmachine> yitz: oh I was using System.Time
05:15:52 <arw_> Saizan: so perhaps add a remark to leave the extralibs out in the docs.
05:16:03 * benmachine has a look at Data.Time
05:16:14 <MyCatVerbs> Data.Time.Format in particular.
05:16:52 <benmachine> so what's the difference between System.Time and Data.Time?
05:16:54 <Saizan> arw_: you should file a ticket on the trac
05:17:06 <arw_> Saizan: i'll do that later. now its bedtime :)
05:17:14 <arw_> Saizan: thanks for your help.
05:17:17 <Saizan> arw_: np :)
05:17:36 <gwern> benmachine: I thinjk the former is IO and the latter not
05:17:55 <benmachine> gwern: Data.Time.getCurrentTime is IO
05:18:02 <gwern> noooo
05:18:25 <gwern> a tiny shred of understanding has been ripped from me and the cosmos suddenly a darker more threatening place!
05:18:45 <benmachine> sry m8
05:19:08 <Berengal> gwern, you could have a look at the acme-now package
05:19:16 <gwern> Berengal: I have, I have
05:19:21 <gwern> it's very comforting
05:19:50 <Berengal> I sense sarcasm ;)
05:20:11 <gwern> 'for it is not to be thought that what is not could be'; if no vacuum exists, then motion and change are impossible, and so time doesn't exist
05:20:15 <burp> > bit 8 :: Word8
05:20:16 <lambdabot>   0
05:20:29 <burp> > bit 7 :: Word8
05:20:31 <lambdabot>   128
05:20:33 <FunctorSalad_> is -funbox-strict-fields equivalent to {-#UNPACK#-}?
05:20:39 <FunctorSalad_> (for strict fields ;))
05:20:49 <burp> Word8 doesn't have 8 bits?
05:20:58 <Berengal> > bit 0 :: Word8
05:20:59 <lambdabot>   1
05:21:05 <burp> I see :)
05:21:26 <yitz> @quote gwern
05:21:26 <lambdabot> gwern says: Haskellers! Tonight we write in Malbolge!
05:21:54 <MyCatVerbs> I'm disturbed by how tempting it is to play along with that.
05:22:03 <Berengal> It's a wonder nobody's written a malbolge edsl yet...
05:22:10 <gwern> it's funny because Malbolge is a name derived from Hell, which is the word used in _300_!
05:22:44 <burp> > maxBound Int
05:22:45 <lambdabot>   Not in scope: data constructor `Int'
05:22:55 <gwern> MyCatVerbs: malbolge's encryption will obscure everything? then we shall code in the shade!
05:22:56 <ski> (gwern : "malbolge" or "hell" (or "hel") ?)
05:22:57 <ivanm> > maxBound :: Int
05:22:59 <lambdabot>   9223372036854775807
05:23:00 <burp> oh sure
05:23:07 <burp> > maxBound :: Word32
05:23:08 <lambdabot>   4294967295
05:23:11 <burp> > maxBound :: Word64
05:23:12 <lambdabot>   18446744073709551615
05:23:29 <burp> makes sense
05:23:35 <Berengal> , maxBound :: Int
05:23:36 <lunabot>  2147483647
05:23:40 <FunctorSalad_> >maxBound::Integer
05:23:51 <gwern> integer has no maxbound!
05:23:54 <FunctorSalad_> > maxBound::Integer
05:23:56 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
05:23:56 <lambdabot>    arising...
05:23:56 <burp> it's not Bounded
05:23:59 <Berengal> > maxBount :: Natural
05:24:00 <lambdabot>   Not in scope: `maxBount'
05:24:03 <Berengal> > maxBound :: Natural
05:24:04 <lambdabot>   No instance for (GHC.Enum.Bounded Data.Number.Natural.Natural)
05:24:04 <lambdabot>    arising f...
05:24:14 <gwern> > maxBunt :: Inhalations
05:24:15 <lambdabot>   Not in scope: type constructor or class `Inhalations'Not in scope: `maxBunt'
05:24:18 <FunctorSalad_> gwern: an infinity can be useful for initializing stuff for example
05:24:23 * Berengal was hoping for infinity
05:24:34 <benmachine> so guys does type defaulting actually have any place in a real program
05:24:46 <ivanm> benmachine: what do you mean?
05:24:47 <Berengal> benmachine, hopefully no
05:24:56 <benmachine> surely all your types are fixed or easily fixable
05:25:19 <benmachine> I can understand how it's useful in lambdabot or ghci, although it's just as often confusing
05:25:20 <Saizan> yeah, you may need some type annotations for some integer constants
05:25:43 <gwern> I always found it very annoying that ghc will default 0 to Integer and warn me about it
05:25:57 <gwern> it's 0! It can't overflow as it is a constant! make it Int and stop bothering me!
05:26:26 <FunctorSalad_> (though one could simply make a clone of Maybe where Nothing is an adjoined top element)
05:29:55 <yitz> gwern: but then the result of some function will also default to Int
05:30:53 <benmachine> the hackage docs have source links everywhere, but I don't have that in my local copy, is it a cabal option?
05:31:05 <ivanm> yes
05:31:12 <ivanm> you need hscolour installed as well
05:31:44 <burp> http://paste.railsbox.eu/show/QnWeBS3ZzCGCWZK0syLS/ <- what do you think about splitting Word64 into two Word32 like this?
05:32:11 <burp> * missing another fromIntegral
05:33:40 <gwern> @quote dragon
05:33:40 <lambdabot> apfelmus says: Lambda Fu, form 72 - three way dragon zip: 'averages3 xs = zipWith3 avg xs (drop 1 xs) (drop 2 xs); where avg a b c = (a+b+c) / 3'
05:33:56 <burp> one could probably do it with testBit and setBit
05:33:57 <yitz> burp: you could always use bitmasks
05:34:07 <yitz> burp: use .&. for that
05:35:06 * benmachine digs about on the wiki
05:35:07 <benmachine> so I need to install cabal-make?
05:35:34 <gwern> cabal-make?
05:35:38 <gwern> does that even still work?
05:35:50 <gwern> what's wrong with cabal-install?
05:35:52 <Saizan> benmachine: no, cabal-install is the frontend
05:36:11 <benmachine> I dunno I just googled hscolour
05:36:15 <benmachine> and that is what I got
05:36:25 <burp> yitz: how?
05:36:27 <benmachine> I tried .cabal/config first but saw nothing interesting
05:37:00 <Saizan> there isn't an option in .cabal/config to specify it, yet
05:37:24 <Saizan> you can build docs with hyperlinked sources only manually with cabal haddock --hyperlink-source
05:37:42 <benmachine> ah
05:37:45 <Zeiris> Does literate programming via .lhs files have support for named code sections? Or is that not strictly needed in Haskell :E
05:37:55 <benmachine> does cabal automatically keep the source then?
05:38:05 <benmachine> does it have it squirreled away somewhere I don't know about
05:38:18 <dons> benmachine: yeah, in .cabal/
05:38:21 <yitz> > let splitBlock = lword &&& rword where lword = (.&. 0xffffffff00000000); rword = (.&. 0xffffffff)
05:38:22 <lambdabot>   not an expression: `let splitBlock = lword &&& rword where lword = (.&. 0xf...
05:38:25 <dons> so you can do, e.g. cabal unpack
05:38:34 <yitz> > let splitBlock = lword &&& rword where lword = (.&. 0xffffffff00000000); rword = (.&. 0xffffffff) in splitWord 88236486593847
05:38:35 <lambdabot>   Not in scope: `splitWord'
05:38:45 <yitz> > let splitBlock = lword &&& rword where lword = (.&. 0xffffffff00000000); rword = (.&. 0xffffffff) in splitBlock 88236486593847
05:38:47 <lambdabot>   Add a type signature
05:38:49 <benmachine> dons: I have cabal doing systemwide installs
05:39:15 <yitz> > let splitBlock :: Word64 -> (Word32, Word32); splitBlock = lword &&& rword where lword = (.&. 0xffffffff00000000); rword = (.&. 0xffffffff) in splitBlock 88236486593847
05:39:15 <benmachine> will it still link from the files in /usr/local/share/doc to /home/ben/.cabal
05:39:17 <lambdabot>   Couldn't match expected type `GHC.Word.Word32'
05:39:27 <dons> benmachine: i don't know where it puts the src then
05:39:34 <benmachine> oh, ok
05:39:48 <burp> :t (&&&)
05:39:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:39:57 <yitz> > let splitBlock :: Word64 -> (Word32, Word32); splitBlock = (fromIntegral *** fromIntegral) . (lword &&& rword) where lword = (.&. 0xffffffff00000000); rword = (.&. 0xffffffff) in splitBlock 88236486593847
05:39:59 <lambdabot>   (0,678464823)
05:40:07 <yitz> > let splitBlock :: Word64 -> (Word32, Word32); splitBlock = (fromIntegral *** fromIntegral) . (lword &&& rword) where lword = (.&. 0xffffffff00000000); rword = (.&. 0xffffffff) in splitBlock 754893788236486593847
05:40:09 <lambdabot>   (0,1757203767)
05:40:15 <yitz> > let splitBlock :: Word64 -> (Word32, Word32); splitBlock = (fromIntegral *** fromIntegral) . (lword &&& rword) where lword = (.&. 0xffffffff00000000); rword = (.&. 0xffffffff) in splitBlock 7548937882369745948486593847
05:40:16 <lambdabot>   (0,3067538743)
05:40:21 <Saizan> benmachine: no, it creates an highlighted version of the sources that gets installed near the docs
05:40:25 <burp> um..
05:40:30 <benmachine> Saizan: ah, I see
05:40:33 <benmachine> makes sense
05:40:45 <burp> shouldn't the left word32 have some values now? ;)
05:40:53 <Saizan> benmachine: btw, cabal haddock must be run from an unpacked tarball
05:41:15 <benmachine> p.s. I want a wiki account, I noticed two of the people to email are already in here
05:41:17 <Saizan> benmachine: it doesn't just accept a package name, i mean
05:41:46 <benmachine> can I ask here or should I email anyway
05:41:47 <yitz> > let splitBlock :: Word64 -> (Word32, Word32); splitBlock = (fromIntegral *** fromIntegral) . (lword &&& rword) where lword = (.&. 0xffffffff00000000); rword = (.&. 0xffffffff) in splitBlock (2^34)
05:41:49 <lambdabot>   (0,0)
05:41:59 <benmachine> Saizan: okay, thanks
05:42:17 <yitz> > 0xffffffff00000000 :: Word64
05:42:18 <lambdabot>   18446744069414584320
05:42:45 <MyCatVerbs> benmachine: email 'em. They're pretty quick about it, and an email is harder to lose track of.
05:43:01 <yitz> > 0xffffffff00000000 .&. (2^34) :: Word64
05:43:03 <lambdabot>   17179869184
05:43:06 <benmachine> k
05:43:06 <Phyx-> I think Haskell's spoiled me... sometimes when I do imperative programming now, i think, "sigh, why is this done so cumbersome.."
05:43:20 <MyCatVerbs> benmachine: but by all means an "Excuse me please, I just emailed you from blah@blah.com about a wiki account." is sensible enough.
05:43:25 <Polarina> Phyx-: Welcome to the club.
05:43:54 <benmachine> k
05:44:08 <benmachine> MyCatVerbs: I'm not really in a rush, I was just wondering if I could save some e-paper
05:44:12 <benmachine> <_<
05:44:44 <Phyx-> Polarina: lol
05:45:55 <yitz> > let splitBlock :: Word64 -> (Word32, Word32); splitBlock inword = (lword, rword) where lword = inword .&. 0xffffffff00000000; rword = inword .&. 0xffffffff in splitBlock (2^34)
05:45:56 <lambdabot>   Couldn't match expected type `GHC.Word.Word32'
05:46:07 <burp> ;-(
05:46:11 <MyCatVerbs> benmachine: I'd ask just to reduce the likelihood that your email winds up buried in someone's email backlog. ^^
05:46:26 <yitz> ah of course :)
05:46:31 <olsner> hmm, are Ptr's garbage collected or otherwise moved around by garbage collection?
05:46:42 <yitz> burp: sorry, the left part you do need to shift :)
05:46:57 <burp> yitz: great, I didn't like this arrow stuff anyway ;)
05:47:04 <benmachine> bah, initial capital letters
05:47:08 <yitz> heh
05:47:13 * benmachine is going to have to break with tradition and be Benmachine
05:48:04 <yitz> > let splitBlock :: Word64 -> (Word32, Word32); splitBlock inword = (lword, rword) where lword = fromIntegral $ shiftR 32 inword; rword = fromIntegral $ inword .&. 0xffffffff in splitBlock (2^34)
05:48:06 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:48:31 <yitz> > let splitBlock :: Word64 -> (Word32, Word32); splitBlock inword = (lword, rword) where lword = fromIntegral $ shiftR inword 32; rword = fromIntegral $ inword .&. 0xffffffff in splitBlock (2^34)
05:48:33 <lambdabot>   (4,0)
05:48:40 <yitz> \o/
05:49:42 <yitz> benmachine: What's The Problem With Initial Capital Letters?
05:50:02 <benmachine> yitz: They Tend To Stand Out.
05:50:07 <Phyx-> :O
05:50:13 <Phyx-> benmachine: are you saying i stand out? :P
05:50:24 <benmachine> Phyx-: in a good way I am sure
05:50:28 <Phyx-> hahhaha
05:50:41 <Phyx-> that's almost as bad as saying "My mommy says i'm special"
05:50:51 <yitz> Phyx-: in a tasteful way, as long as you're not ALL CAPS.
05:51:04 <yitz> only BONUS is ALL CAPS.
05:51:13 <yitz> @yow
05:51:13 <lambdabot> FEELINGS are cascading over me!!!
05:51:16 <Phyx-> lol
05:51:51 * Phyx- loves to watch them blow stuff up on discovery channel
05:55:35 <hackagebot> xml-basic 0.1.1 - Basics for XML/HTML representation and processing (HenningThielemann)
05:57:17 <yitz> Lemmih: oh, that looks interesting :)
05:57:32 <McManiaC> is there a imlib2 binding for haskell?
06:00:30 <EnglishGent> hello :)
06:00:48 <McManiaC> oh, Graphics.Imlib is for imlib2... nvm then :)
06:01:08 <yitz> McManiaC: http://hackage.haskell.org/package/Imlib
06:01:12 <McManiaC> yup
06:01:19 <McManiaC> thx anyway :)
06:02:36 <yitz> McManiaC: it looks a tiny bit stale - last March
06:04:07 <EnglishGent> how does one fetch a package from Hackage? do I need to know Darcs?
06:04:34 * EnglishGent wants to grab the Data.Digest.SHA1 pacakge listed at http://www.haskell.org/crypto/doc/html/
06:04:43 <yitz> EnglishGent: you need cabal-install
06:05:04 <EnglishGent> ty yitz
06:06:06 <McManiaC> yitz: hm yes… will do the job tho :)
06:06:59 <EnglishGent> um... okay how do I get *that*? (I'm on Debian - I dont see a cabal or cabal-install package)
06:07:35 <Saizan> EnglishGent: http://www.haskell.org/haskellwiki/Cabal-Install
06:07:40 <yitz> EnglishGent: try cabal --version
06:07:56 <yitz> maybe you have it
06:08:11 <EnglishGent> no - I just get 'command not found' yitz :|
06:08:28 <burp> debian doesn't have cabal-install package
06:08:41 <yitz> ok - then see Saizan's link
06:08:52 <EnglishGent> oh - ty Saizan, yitz :)
06:09:07 <McManiaC> theres also a libhugs-cabal-bundled package on debian ^^
06:09:24 <McManiaC> havent used it tho
06:09:43 <yitz> EnglishGent: hmm, no. you don't need to install it manually on debian.
06:10:10 <yitz> EnglishGent: one sec - let me try to boot up my poor ailing debian machine
06:10:21 <EnglishGent> sure :)
06:10:32 <EnglishGent> thanks for the assistance all - it's appreciated :)
06:11:16 <yitz> there's something for ghc, too, i'm sure of it
06:12:01 <yitz> yay it booted! now, quick, before it crashes...
06:12:28 <EnglishGent> ty McManiaC :)
06:12:53 * EnglishGent doesnt really know hugs .. so far I've used GHC for everything - though I understand that the differences are minimal :)
06:13:09 <Geheimdienst> hi, i have a newbie question: how do i write a function that can take either a Foo or a Bar? (in e.g. java that would be called an overloaded method)
06:13:26 <Saizan> EnglishGent: don't install libhugs-cabal-bundled
06:13:54 <EnglishGent> hi Geheimdienst - if foo & bar are distinct types you need to define a type class
06:13:55 <McManiaC> Geheimdienst: Either
06:14:01 <burp> data Both = Foo | Bar <- maybe something like this?
06:14:02 <dons> Geheimdienst: use a n Either
06:14:12 <gwern> shoot. what would be a haskell version of 'fist of the north star'? 'you are already evaluated'?
06:14:16 <dons> foo :: Either Foo Bar -> Bool, for example
06:14:20 <EnglishGent> but if your talking about a single datatype - see above answers :)
06:14:27 <EnglishGent> what problem are you trying to solve? :)
06:14:54 <Saizan> (btw it's usually easy to install cabal-install from the tarball, especially on linux)
06:15:32 <gwern> lambda of the pure star? dammit, the syllable structure is too hard
06:15:39 <EnglishGent> I'm happy enough installing it from the tarbar Saizan .. I'm just waiting to see what yitz has to say when he comes back from his debain expedition :)
06:15:40 <gwern> we need more monosyllabic technical terminology!
06:15:56 * EnglishGent would prefer not to install it manually if it is packaged as something :)
06:17:17 <Geheimdienst> burp: i tried something like that, but i couldn't get it to work because apparently you can't use "data" with pre-existing types ... String, Int, whatever
06:17:25 <huntse> Geheimdienst : You may be better off thinking somewhat differently about the problem.
06:17:29 <yitz> EnglishGent: hmm. indeed, I seem to have installed it manually.
06:17:39 <yitz> it must be a very old version then :(
06:17:41 * jethr0 is not aware of an official cabal package on ubuntu
06:17:50 <jethr0> that doesn't bode well for debian ;)
06:17:53 <burp> Geheimdienst: well like Either then, data Both a b = Foo a | Bar b
06:18:01 <Philonous> Geheimdienst: data Foo = FooInt Int | FooString String
06:18:14 <EnglishGent> Geheimdienst - if you want to do it with prexisting types you need a type class - but I'd suggest you explain why you want to do it - Haskell needs a change of mind-set from the more traditional OO approaches
06:18:14 <burp> that's basically Either ;)
06:18:16 <huntse> It's more Haskelly to make a typeclass and make both of the types have an instance of your fink
06:18:17 <EnglishGent> as I found out!
06:18:20 <gwern> 'evaled'?
06:18:25 * EnglishGent something of a newbie himself :)
06:18:26 <gwern> forced?
06:18:43 <gwern> what should replace 'dead' in the fist of the north star catchphrase...
06:18:55 <EnglishGent> ok - ty yitz :)
06:19:17 <yitz> EnglishGent: well, once you do it manually the first time, it then knows how to upgrade it self. (when you tell it to. think I'll do that now...)
06:19:25 <yitz> itself
06:19:27 <jethr0> whnf'ed
06:20:14 <gwern> jethr0: but wouldn't that be pronounced wee-haitch-enn-eff-ed?
06:20:19 <Geheimdienst> ok guys, the wacky idea i'm thinking about is this: what if i could, in my xmonad config, write keyboard shortcuts like this: "ctrl alt xK_Return"
06:20:20 <gwern> that's even worse from a syllable perspective
06:20:46 <jethr0> hehe
06:20:59 <Geheimdienst> currently, i have to write (controlMask .|. mod1Mask, xK_Return)
06:21:24 <Geheimdienst> so i'm looking for little helper functions called ctrl, alt, ...
06:21:39 <Geheimdienst> these would have to take either a KeySym, which is defined somewhere in Graphics.X11
06:21:49 <tavelram> do you want to include the ""?
06:22:00 <Geheimdienst> tavelram: no no
06:22:40 <McManiaC> Geheimdienst: use http://www.n-sch.de/hdocs/xmonad-contrib/XMonad-Util-EZConfig.html
06:22:47 <Philonous> ctrl (mods,key) = (controlMask .|. mods, key), alt = (mods,key) = (mod1Mask .|. mods, key)
06:22:47 <McManiaC> + there is an xmonad channel here on freenode :)
06:23:27 <yitz> #xmonad
06:23:41 <Saizan> Philonous: then it's ctrl (alt (xK_Return)) ?
06:23:49 <yitz> ctrl = first (.|. controlMask)
06:24:15 <yitz> ctrl . alt $ xK_Return
06:24:21 <Philonous> Saizan: ctrl . alt $ ( <whatever the empty maske is>,xk_Return)
06:24:23 <gwern> you are already memoized?
06:24:25 <gwern> nah
06:24:54 <Philonous> But you can say key k = (<empt mask>,key) and then write ctrl.alt .key $ xk_Return
06:24:55 <Geheimdienst> mcmaniac: i'm aware of ezconfig, thanks for the reminder. i wanted to think about this more as a learning exercise (i'm a newbie)
06:25:08 <yitz> ctrl . alt . key $ xK_Return
06:25:24 <yitz> key = (,) 0
06:26:17 <McManiaC> okay
06:26:25 <gwern> a *learnig exercise*?
06:26:34 <gwern> what do you think #haskell is about?
06:26:46 <gwern> this are serious language; this are serious #channel!
06:26:57 <Philonous> Are you serious?
06:27:05 <Saizan> no, he isn't :)
06:27:13 <Philonous> Seriously?
06:27:22 <Saizan> clearly.
06:27:22 <gwern> yes
06:27:45 <jethr0> there will be no horse-play on this channel!
06:28:57 <burp> #haskell-in-depth ;)
06:29:15 <Geheimdienst> guys, i'm not yet sure-footed in haskell syntax, and i wonder how far the syntax can be pushed. that is, if it can be pushed to allow "ctrl alt xk_return"
06:29:34 <Geheimdienst> if this is not serious enough for you, please complain to my associate at http://www.seriouscat.com/SeriousCat.jpg
06:30:51 <Philonous> Geheimdienst: is "ctrl . alt . key $ xK_Return" good enough? Because what you sugest would be considerably harder (and unidiomatic)
06:31:24 <Warrigal> Geheimdienst: ctrl (alt xk_return), yes. ctrl alt xk_return would probably be possible but difficult; there's no way to make the syntax make ctrl alt xk_return mean ctrl (alt xk_return), so you'd have to make the functions work that way.
06:32:14 <jethr0> well you could play around with the precedences...
06:32:16 <Geheimdienst> philonous: pretty close already. what's the key function?
06:32:30 <Philonous> key k = (0,k).
06:32:46 <jethr0> i.e. make "alt" more binding than ctrl
06:32:51 <Saizan> jethr0: you can't
06:32:54 <Philonous> (without the full stop, sorry)
06:32:59 <jethr0> why not?
06:33:03 <smarmy> even if you could, then you couldn't do alt ctrl xk_Return
06:33:05 <gwern> benmachine: I refuse to give you a hawiki account unless you phrase the request in lolcat!
06:33:17 <Saizan> jethr0: function application has always the same precedence
06:33:19 <smarmy> order shouldn't matter
06:33:33 <jethr0> what about:
06:34:03 <jethr0> > 2 + 3 * 4
06:34:04 <lambdabot>   14
06:34:11 <Saizan> s/function application/prefix function application/ to clarify
06:34:14 <Warrigal> You can't set operator precedence for prefix functions, only infix functions. Though you can set operator precedence for functions in infix form.
06:34:24 <Saizan> jethr0: those are infix operators, that's another story
06:34:25 <jethr0> k, then make "alt" an infix operator
06:34:43 <jethr0> hmm, probably can't . damn
06:34:49 <jethr0> |alt|
06:34:51 <Warrigal> You can't make alt an infix operator, except by saying `alt` instead of alt.
06:35:06 <Philonous> > 3 `exp`
06:35:07 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:35:16 <Warrigal> I think |alt| would be parsed as | alt | and disallowed.
06:35:20 <Saizan> > (3 `exp`)
06:35:21 <Warrigal> > (3 `exp`)
06:35:22 <lambdabot>   20.085536923187668
06:35:23 <lambdabot>   20.085536923187668
06:35:52 <Warrigal> > 98123764 `mod` 10000
06:35:54 <lambdabot>   3764
06:36:16 <jethr0> hmm,
06:36:31 <jethr0> |+| works. not too familiar with haskell's lexing...
06:36:47 * benmachine hugs gwern
06:37:22 <Warrigal> You can mix symbols and you can mix letters, but you can't mix both of them together.
06:38:00 <Warrigal> Which is too bad; it means we can't write our infix function names in English. We have to call them stuff like <$> and hope people get the idea.
06:38:35 <gwern> > 80 / 1000
06:38:37 <lambdabot>   8.0e-2
06:38:46 <gwern> > 8 / 100
06:38:48 <lambdabot>   8.0e-2
06:39:13 <etpace_> I'm trying to write foldl and foldr in cps, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9115#a9115 I think I've got foldlc correct, as it typechecks, but I can't seem to write a proper version of foldrc due to f taking something from the 'future'
06:39:44 <jethr0> Geheimdienst: would "ctrl `alt` mkReturn" be any better?
06:40:39 <Warrigal> It wouldn't be any better than "alt ctrl mkReturn", which would be the same thing.
06:40:43 <Saizan> etpace_: you've to apply f in the continuation you pass to the recursive call of foldrc
06:41:22 <etpace_> hmm
06:41:35 <McManiaC> is it ugly to use "foo <- return 1" instead of "let foo = 1" in a do construct with a lot of "<-" operations? ^^
06:41:41 <Saizan> i.e. your "future" is acc
06:41:50 <etpace_> ill have a fiddle
06:42:56 <Geheimdienst> jethr0: i think warrigal is right
06:43:11 <jethr0> hmm hmm hmm
06:43:50 <jethr0> McManiaC: it's not really beautiful. but for the sake of syntactical aesthetics it may be alright just this once
06:44:13 <Philonous> McManiaC: Those are even semantically different
06:44:36 <etpace_> foldrc f z xs $ λacc → f x acc k
06:44:45 <etpace_> seems to do the job, thanks saizan
06:44:47 <McManiaC> Philonous: i know…
06:45:11 <Warrigal> They're semantically different?
06:45:12 <Saizan> etpace_: that's correct
06:45:33 <Warrigal> How?
06:45:38 <etpace_> It seems that foldlc and foldrc 'switch' with their non CPS friends, foldlc is partially applied outside of the parameter, and foldrc is never evaluted until the end
06:46:20 <Saizan> Warrigal: they are translated to different expressions, especially if "foo" is a refutable pattern
06:46:41 <Warrigal> Ah, yes.
06:47:03 <Philonous> Warrigal: x <- return 1 gets desugared to return 1 >>= \x -> ... So you can have recursive let bindings, but not recursive monad bindings
06:47:04 <Saizan> also, depending on the monad you might be inserting more data dependencies by routing that 1 through return
06:47:16 <Philonous> Also, if a pattern match fails, <- will use the monads fail
06:47:19 <Saizan> and that, yeah
06:47:48 <Warrigal> > (\(Just x) -> 3) Nothing
06:47:50 <lambdabot>   * Exception: <interactive>:1:138-151: Non-exhaustive patterns in lambda
06:48:02 <dubhrosa> hi, newb question here, is there a site people use so newbs can post their haskell snippets and get feedback on how to do things in a more "haskellish" manner?
06:48:08 <Warrigal> > do let Just x = Nothing; return 4 :: [Int]
06:48:10 <lambdabot>   <no location info>: Invalid type signature
06:48:23 <Warrigal> > (do let Just x = Nothing; return 4) :: [Int]
06:48:25 <lambdabot>   <no location info>: parse error on input `)'
06:48:31 <Warrigal> Meep.
06:49:29 <Philonous> > (\x -> do Just y <- x ; return y) Nothing
06:49:30 <lambdabot>   Nothing
06:49:33 <benmachine> > (do { let Just x = Nothing; return 4}) :: [Int]
06:49:34 <lambdabot>   <no location info>: parse error on input `}'
06:49:39 <Philonous> > (\x -> do let Just y = x ; return y) Nothing
06:49:40 <lambdabot>   <no location info>: parse error on input `)'
06:49:42 <benmachine> > (do { let Just x = Nothing; return 4;}) :: [Int]
06:49:43 <lambdabot>   <no location info>: parse error on input `;'
06:49:46 <benmachine> blah.
06:51:02 <Saizan> dubhrosa: you can use hpaste.org and link here, or choose the appropriate mailing list from these http://haskell.org/haskellwiki/Mailing_lists#Mailing_lists_in_detail
06:51:06 <Warrigal> > (do {let Just x = Nothing; return 4}) :: [Int]
06:51:07 <lambdabot>   <no location info>: parse error on input `}'
06:51:27 <Saizan> (do let {Just x = Nothing}; return 4) :: [Int]
06:51:32 <Saizan> > (do let {Just x = Nothing}; return 4) :: [Int]
06:51:33 <lambdabot>   [4]
06:51:45 <Saizan> > (do let {Just x = Nothing}; x `seq` return 4) :: [Int]
06:51:46 <lambdabot>   * Exception: <interactive>:1:146-161: Irrefutable pattern failed for patter...
06:51:53 <dubhrosa> Saizan, thanks
06:52:05 <Saizan> > (do Just x <- return Nothing; return 4) :: [Int]
06:52:06 <lambdabot>   []
06:53:00 <dolio> etpace_: Note that CPSed foldr loses its nice laziness properties, because that particular CPS transformation is the one for the call-by-value lambda calculus.
06:53:15 <dolio> So it evaluates like it would in ML.
06:53:21 <etpace_> but foldl gains them?
06:53:25 <dolio> No.
06:53:52 <etpace_> ok
06:54:08 <dolio> foldl is also evaluated how it would be in ML.
06:54:14 <Saizan> well, that depends on what f does with the continuation though
06:54:16 <dolio> Roughly.
06:54:34 <Saizan> it's more like foldl in scheme, maybe :)
06:54:47 <dolio> Well, yes, that's true. You can actually short circuit in the CPSed foldl.
06:54:53 <dolio> But that's like using callCC.
06:55:37 <dolio> Or abort, I guess.
06:56:33 <dolio> Mucking around with the continuation in some way, certainly.
06:56:56 <Saizan> yeah
06:57:23 <dolio> You can do some of that in foldr, too, but you have to make it all the way to the end of the list before f is even called. :)
06:58:04 <dolio> So you can only short circuit out of the return trip.
07:00:21 <Saizan> the f (last xs) z call can discard all the others, etc..
07:00:34 <dolio> There's another CPS transformation for the call-by-name lambda calculus, but I don't know it nearly as well.
07:01:42 <dolio> In that case, the foldl/foldr analogues would have properties similar to the ones they have in Haskell regardless of the language they're written in.
07:15:51 <ccasin> I've got a cabal package that depends on a C library, which is installed in a non-standard location.
07:15:59 <ccasin> so I configure with --extra-lib-dirs to tell it where to look
07:16:07 <ccasin> and it builds fine, and can run from its source directory
07:16:16 <ccasin> but cabal install fails, complaining it can't find the library
07:16:17 <ccasin> any ideas?
07:19:32 <Lemmih> ccasin: cabal install --extra-lib-dirs=... ?
07:21:12 <ccasin> Lemmih: right - that doesn't work
07:21:24 <ccasin> well, it works in that it lets me cabal build
07:21:30 <ccasin> (which fails without it)
07:21:47 <ccasin> but cabal install recompiles some stuff and fails regardless
07:22:02 <dolio> Oh man, call-by-name CPS is even worse than I thought.
07:22:14 <Vanadium> > length [1..] > 3
07:22:17 <dolio> You actually have to transform datatypes for it to work right, I think.
07:22:19 <lambdabot>   mueval-core: Prelude.read: no parse
07:22:19 <lambdabot>  mueval: ExitFailure 1
07:22:49 <Lemmih> ccasin: 'cabal install' is (almost) the same as calling 'cabal configure && cabal build && cabal copy && cabal register'.
07:23:24 <Saizan> so if you pass the --extra-lib-dirs flag to install it should work
07:23:38 <Saizan> otherwise it's a bug
07:24:12 <ccasin> ah!
07:24:14 <ccasin> Thanks
07:24:26 <ccasin> sorry, I thought I should only have to provide it to configure
07:24:50 <ccasin> perhaps that's what you were trying to tell me, Lemmih - I am a little slow in the morning :)
07:25:45 <ccasin> oh, in fact
07:25:48 <ccasin> that's exactly what you said
07:26:24 <ccasin> thanks, both of you
07:26:36 <Saizan> np :)
07:33:47 <RayNbow> hmm, just wondering... when writing a single-author paper/report/thesis/etc., should one use "I" or "we" in the active voice?
07:34:31 <luite> If you've done something by yourself, why would you use "we"?
07:34:50 <ccasin> usually "we" for conference papers and stuff, I think
07:36:48 <RayNbow> ah, just found a few more opinions @ http://scienceblogs.com/principles/2009/04/academic_poll_person_and_voice.php
07:37:19 <ccasin> though googling suggests it's a topic of some debate
07:37:19 <ccasin> yeah
07:37:50 <RayNbow> ah, solution found:
07:37:52 <RayNbow> "so in this case there is no ideal solution for single authors other than to collaborate more :) "
07:37:53 <RayNbow> :p
07:38:02 <ccasin> :)
07:38:23 <ccasin> check the most recent proceedings/issue/whatever of the venue you're submitting to, I suppose
07:40:08 <ccasin> Looking at the abstracts of single-author papers in icfp 09, for example, I find 3 occurrences of "we" and none of "I"
07:40:47 <luite> RayNbow: I wonder why he thinks that first person singular is too arrogant sounding.
07:41:35 <RayNbow> luite: _ego_ism? :p
07:41:52 <ccasin> luite: I suppose because "we" is so common, "I" stands out
07:42:29 <RayNbow> the only place where "I" feels okay is in the preface/acknowledgements of a paper/thesis/etc
07:42:48 <RayNbow> (since that part is more personal)
07:44:24 <Vanadium> Given two sorted lists, is there a clever way to do the equivalent of a set-minus operation in linear time?
07:46:12 <RayNbow> http://twan.home.fmf.nl/blog/haskell/generic-merge.details <-- might be an interesting read, Vanadium
07:46:13 <trzkril> Vanadium: that's quite like merge as in mergesort
07:46:29 <Vanadium> thanks :o
07:46:39 <luite> RayNbow: hm, nah, 'I' is just the most logical and most correct way. If you've done something, why shouldn't you say so? The main reason that it does not feel right is that other people often don't use it, but should that be a reason to use a less correct and more verbose wording?
07:48:36 <RayNbow> luite: imo, it's more important -what- has been done than who did it
07:48:50 <RayNbow> it's just that the passive voice is a PITA to read
07:50:35 <luite> RayNbow: the more direct wording makes it at least as clear what has been done, just because it's less verbose
07:51:43 <RayNbow> @let mergeByR cmp fxy fx fy z = go    where go []     ys     = foldr fy z ys ; go xs     []     = foldr fx z xs ; go (x:xs) (y:ys) = case cmp x y of ; LT -> fx  x   (go xs (y:ys)) ; EQ -> fxy x y (go xs ys) ; GT -> fy    y (go (x:xs) ys)
07:51:44 <RayNbow> @let setMinus xs ys = mergeByR compare (\a b c -> c) (:) (:) [] xs ys
07:51:46 <lambdabot>  Defined.
07:51:47 <lambdabot>  Defined.
07:52:06 <RayNbow> > setMinux [1..10] [1,4,6,8]
07:52:08 <lambdabot>   Not in scope: `setMinux'
07:52:13 <RayNbow> > setMinus [1..10] [1,4,6,8] -- bah, typo :p
07:52:16 <lambdabot>   [2,3,5,7,9,10]
07:52:24 <RayNbow> > setMinus [1,4,6,8] [1..10]
07:52:26 <lambdabot>   [2,3,5,7,9,10]
07:52:31 <RayNbow> hmm
07:52:42 <RayNbow> not setMinus yet :p
07:52:49 <RayNbow> @undefine
07:54:31 <luite> RayNbow: it seems to me that using less direct forms (I -> we -> passive) is often because of (false?) modesty, but also 'evasion of responsibility'. It's easier to write 'it has been decided' than 'I have decided', because it feels that you could be held accountable for the decision
07:54:49 <RayNbow> @let mergeByR cmp fxy fx fy z = go    where go []     ys     = foldr fy z ys ; go xs     []     = foldr fx z xs ; go (x:xs) (y:ys) = case cmp x y of ; LT -> fx  x   (go xs (y:ys)) ; EQ -> fxy x y (go xs ys) ; GT -> fy    y (go (x:xs) ys)
07:54:49 <RayNbow> @let setMinus xs ys = mergeByR compare (\a b c -> c) (:) (\a c -> c) [] xs ys
07:54:50 <lambdabot>  Defined.
07:54:51 <lambdabot>  Defined.
07:55:23 <RayNbow> > (setMinus [1..10] [1,4,6,8]   ,  setMinus [1,4,6,8] [1..10])
07:55:25 <lambdabot>   ([2,3,5,7,9,10],[])
07:55:33 <RayNbow> ^ Vanadium
07:57:40 <RayNbow> luite: but what kind of responsibility does a single author bear?
07:59:46 <Vanadium> RayNbow: nice, thank you
08:00:52 <FunctorSalad_> what are the differences between c2hs and hsc2hs again?
08:01:10 <RayNbow> Vanadium: imo, you should thank twanvl for writing a nice blog post ;)
08:01:36 <Vanadium> Oh. Thank you, twanvl!
08:01:40 <twanvl> :)
08:01:41 <FunctorSalad_> (obviously they are different... I mean which do I use ;))
08:06:57 <dolio> Here's (I think) how you do call-by-name CPS folding, if anyone cares: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9116#a9116
08:12:49 <Saizan> dolio: i do!
08:13:14 <dolio> I guess I should try writing that in ocaml to verify.
08:17:34 <Saizan> dolio: no foldl'cbn for KList ?
08:17:49 <dolio> Yeah, I forgot that one, apparently.
08:18:00 <jethr0> is there any good material on applicative functors and similar concepts around (i.e. like a tutorial beyond lyah)?
08:19:09 <Saizan> jethr0: typeclassopedia?
08:19:45 <jethr0> also i have a general-structure question. let's say i have a game with dimensions and i don't want to hardcode them. therefore i use a (state) monad to carry them around and get them from the monad whenever needed.
08:20:46 <jethr0> but now every function I write tends to be of type "MyStateMonad ()", which enforces ordering on the statements and because i tend to need IO in some places (i.e. StateT MyState IO a), i now have IO everywhere
08:20:56 <jethr0> any suggestions how to improve this situation?
08:21:43 <Lemmih> Hoist out the IO?
08:22:06 <Vanadium> Why do my exceptions thrown in forkIO threads not fly all the way through to the main thread :'(
08:22:12 <Saizan> what kind of game?
08:22:38 <jethr0> "hoist"? i've thought about making my type "StateT MyState Identity a" and only in case I need to do printf-debugging to put it to IO again
08:22:40 <Saizan> you could have a datatype that represent the state of the game that you produce in pure code and then "render" it outside in IO
08:22:57 <jethr0> a bomberman clone. it's pretty far already (network, animations, input, game logic, ...)
08:23:12 <rovar> question, is there a way, when configuring a project with cabal, to automatically install the dependencies that it requires?
08:23:17 <jethr0> soon i'll reach milestone 2, at which point it should be more or less playable over network
08:23:43 <jethr0> Saizan: you mean like a writer monad for debug text?
08:23:49 <Saizan> rovar: no, only "cabal install" does that
08:24:07 <rovar> that is what I thought :(   thanks
08:24:25 <Saizan> jethr0: not for debug, for the main task
08:24:51 <jethr0> Saizan: good idea. my "problem" is also that most of my code does "modify (...)" and therefore tends not to return values. most of the game logic is inherently pure, but this fact gets lost due to the state monad used
08:25:23 <jethr0> Saizan: i don't actively need the io. only place i need it is display and that is a separated task.
08:26:04 <Saizan> but you don't just modify the state, eh?
08:26:19 <jethr0> just, in a few places i have print for error messages, etc. and therefore having a "StateT a IO b" is quite convenient
08:26:28 <jethr0> Saizan: huh?
08:26:56 <Saizan> i mean, if all you do is transform this MyState you could just have functions MyState -> MyState
08:27:03 <FunctorSalad_> hmm the "import C2HS" in this tutorial is a mistake, isn't it?
08:27:06 <FunctorSalad_> http://loupgaroublond.blogspot.com/2009/06/haskell-bindings-to-c-from-start-to.html
08:27:08 <Saizan> i guess you need to produce some other result
08:27:19 <FunctorSalad_> c2hs doesn't have any library part as I see it
08:27:37 <jethr0> yes, that's mainly what i do and i had MyState -> MyState, but then you have to unpack the quite large state, etc. A state monad seemed like the preferrable solution
08:27:38 <Saizan> FunctorSalad_: c2hs produces that module
08:27:52 <andyjgill> Does anyone know if we have a standard location for "newtype Mu a = In (a (Mu a))"?
08:28:52 <jethr0> like so many games it's basically like "loop st = do {st' <- handleInput st; let st'' = updateWorld st'; display st''; loop st''}"
08:28:54 <Saizan> andyjgill: there's Control.Functor.Fix in category-extras
08:29:00 <jethr0> only that it's done in state monad
08:29:02 * rovar concocts a python script to pipe in the result of cabal configure and invoke cabal install :)
08:29:02 <FunctorSalad_> Saizan: ok
08:29:06 * rovar is that lazy.
08:29:19 <andyjgill> Saizan: Ideal! Thanks. I'll look it up.
08:29:45 <jethr0> rovar: seems a little backwards. why can't you use cabal directly?
08:30:28 <Saizan> jethr0: if only updateWorld is in the State monad it doesn't seem so "impure" to me, you just use do-notation's ; instead of . for composition
08:30:52 <rovar> jethr0: cabal install, as I understand it, is kind of a separate beast than the rest of cabal. and cabal install is the only one that will recursively detect and fetch dependencies, 'cabal configure' doesn't do that
08:31:02 <jethr0> yes, but doesn't that enforce ordering?
08:31:09 <andyjgill> Saizan: Do you know what package thats in?
08:31:21 <Saizan> andyjgill: category-extras
08:31:35 <andyjgill> Yes, I should learn how it read....
08:31:40 <rovar> i think so, but then something has to turn around and call cabal install with the dependency list.
08:31:47 <jethr0> actually right now EVERYTHING is in the "StateT a IO b", in part out of laziness and because i didn't want to read out the state and run the next state iteration every time
08:32:39 <jethr0> rovar: ah yes, i've come across that issue. would be nice to address this at the source though instead of with an addon-script. but would be nice to have a script for that, anyway ;)
08:33:23 <Saizan> jethr0: State doesn't add ordering
08:33:30 <Saizan> of evaluation, i mean
08:33:59 <jethr0> Saizan: basically, i was wondering what the "reference structure" or recommended way of doing this in haskell would be? explicitely passing around a big "state" argument everywhere seems kinda annyoing
08:34:20 <jethr0> i thought all monads had an effect on ordering...
08:34:36 <Saizan> no, they order the side-effects in some abstract sense
08:35:05 <Saizan> but the evaluation can be as lazy as the internal structures permit
08:35:14 <jethr0> so, you're saying that state is just syntactic sugar for not passing an explicit argument? and that "func = do ..." is equivalent to "func st = ..."?
08:35:43 <Saizan> and since State s a = s -> (a,s) and the tuple is matched lazily you get the same laziness as composing functions of type s -> s
08:35:52 <Saizan> yes.
08:36:49 <Saizan> ?src State
08:36:50 <lambdabot> Source not found.
08:36:55 <jethr0> huh... and how about a writer monad. when i put things in there in real time and use the writer content on "runWriterT", will it come out in "real time"?
08:37:05 <jethr0> i think i've done this before, but it's been a while ;)
08:37:37 <Saizan> yes, the "log" can be consumed as soon as it is produced
08:37:46 <jethr0> so, maybe i could use a "WriterT (IO ()) State MyState" and push any IO actions (like "print") into the writer monad
08:37:49 <dolio> Saizan: OCaml version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9116#a9117
08:38:12 <Saizan> jethr0: WriterT w IO is different, the IO adds more ordering
08:38:19 <dolio> Oops, I forgot the definition of the lists.
08:38:23 <jethr0> Saizan: so, what's your heuristic for using State monad versus explicit state parameters everywhere?
08:38:45 <Saizan> jethr0: you'll be able to consume the log as soon the IO side effects are completed
08:38:50 <jethr0> no, i meant putting IO actions into the writer monad, not stacking WriterT on IO
08:38:53 <Vanadium> I am trying to do forkIO $ myThread `catch` throwTo anotherThreadId, but ghc complains with "Ambiguous type variable `e'". What is going on?
08:39:11 <Saizan> jethr0: ah, yeah, that'd work
08:39:33 <Saizan> jethr0: well, the heuristic is whatever looks nicer i think :)
08:39:41 * dolio disappears.
08:39:52 <jethr0> Vanadium: have you tried adding a type signature?
08:40:05 <Vanadium> jethr0: I do not want to, I want it to be polymorphic :(
08:40:17 <Saizan> you have to pick a type
08:40:31 <Saizan> you can never have unresolved polymorphism like that
08:40:31 <jethr0> it means ghc doesn't know what kind of exception it throwing
08:40:32 <Makoryu> Vanadium: Then add a polymorphic type signature
08:40:37 <jethr0> throwTo :: Exception e => ThreadId -> e -> IO ()
08:40:41 <jethr0> that's probably your e
08:41:06 <Saizan> Vanadium: but it's fine since you can use SomeException that it's at the top of the exception hierarchy
08:41:06 <Vanadium> I did try (throwTo anotherThreadId :: Exception e => e -> IO ()) but it did not seem to do anything!
08:41:25 <hackagebot> dyre 0.7.3 - Dynamic reconfiguration in Haskell (WillDonnelly)
08:41:29 <Saizan> if you use SomeException you'll catch all the exceptions
08:41:42 <Vanadium> I suppose that does it
08:41:49 <Vanadium> All right
08:41:51 <Vanadium> Thanks!
08:41:56 <Saizan> np
08:42:44 <jethr0> Saizan: still not sure what to think of the whole monad thingey. having most functions have type "State x ()" seems so unpure!!
08:42:48 <jethr0> hehe
08:43:31 <jethr0> but i guess it's just a variation on "MyState -> MyState"
08:44:18 <Saizan> i'm not sure why it feels much nicer than MyState -> MyState if most of the time you're using modify
08:44:30 <Saizan> do you have some come snippets to show?
08:44:48 <jethr0> it's 1000 loc, but i can find sth as an example
08:45:50 <jethr0> @paste
08:45:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:46:39 <jethr0> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9119#a9119
08:46:47 <Saizan> do-notation feels tidier at times, however, so i wouldn't feel bad using State for it
08:47:43 <jethr0> the thing with "MyState -> MyState" is that you have to use so much "f st = st''''' ... where st' = ..; st'' = ...; ..."
08:48:46 <jethr0> feels clunky and very error-prone
08:49:00 <Vanadium> What causes "thread blocked indefinitely" errors? :(
08:49:08 <Saizan> well, not if you mostly stick to (.)
08:49:13 <Vanadium> I am p. sure that someone would get around to writing something into the mvar at some point
08:49:21 <Saizan> however the State monad was invented precisely to solve that issue :)
08:49:24 <jethr0> waiting on a socket that was closed from the other end?
08:49:54 <Saizan> Vanadium: it usually happens if there's no other thread with a reference to that mvar
08:50:15 <jethr0> Saizan: yes, and with small functions that's easy. but with anything more complex i'd get expressions with at least 10-15 (.)s
08:50:25 <jethr0> probably a question of style and how big your functions are
08:51:12 <Vanadium> I am mostly annoyed because that error seems to circumvent execution of the bracket thing I installed :(
08:51:45 <Saizan> you've 10-15 newlines instead, you could put each function with its . on a line by itself too, however it's really a question of aestetics at this point
08:52:36 <jethr0> basically i'm just wondering whether this is less pure. but as you told me that state was quite lazy, i will probably keep it this way and this of "State MyState ()" more as "MyState -> MyState" ;)
08:53:40 <jethr0> s/this of/think of/
08:53:48 <Saizan> jethr0: newtype State s a = State { runState :: s -> (a,s)} so State MyState () is isomorphic to MyState -> ((),MyState), pretty close i'd say :)
08:54:40 <jethr0> and you were saying that "StateT a IO b" has a different semantics?
08:54:54 <Saizan> @unmtl StateT a IO b
08:54:54 <lambdabot> a -> IO (b, a)
08:55:14 <Saizan> you've the order of IO effects mixed in-between
08:55:58 <jethr0> so, when i'm not using any IO effects then it is similar to pure State in  terms of ordering/laziness?
08:56:24 <Saizan> so you can't access the state from before a certain IO effect until that's executed, even if it doesn't actually alter the state
08:56:45 <jethr0> huh?
08:57:48 <jethr0> > fmap (+1) (1,2)
08:57:50 <lambdabot>   (1,3)
08:57:57 <Saizan> "do put 1; liftIO $ print 2; fmap someFunction get;" <- here the last expression can't access the 1 before the 2 is printed
08:59:17 <Saizan> ..unless ghc becomes quite more clever than it is now, i guess
09:00:25 <jethr0> yes, that's understandable. so in terms of evaluation order "do {a <- func1 x; someIOAction; func2 a}" is different from "func2 (func1 x)"
09:01:42 <Saizan> right, not that the result or the state produced by func1 x are strictly evaluated in either case
09:02:12 <Saizan> s/,/, but /
09:03:04 <jethr0> k, i'll think about switching from "StateT a IO b" to "StateT a Writer b" for my debug/error/info messages
09:03:09 <jethr0> thx a lot
09:03:17 <Saizan> np
09:05:05 <c15c8ra1n> can anyone help me with DLR + mono? I'm having some trouble figuring out how to put the two together
09:05:23 <Vanadium> Hmm
09:05:32 <Vanadium> It seems unGetChan did not at all do what I thought it would :(
09:06:23 <jethr0> you think there's much of a difference (apart from the obvious) between "StateT a Writer String" and "StateT a Writer (IO ())"? in the first case i'd print the strings from the writer, whereas in the second i'd just execute the contained IO action.
09:06:59 <Vanadium> I had multiple threads blocking on readChan'ing on the same chan, then to stop all of them I wrote a single Nothing to the channel, and every thread was supposed to read it, unGetChan it back into the channel, and then stop looping
09:07:22 <Vanadium> That did not quite seem to work, but writeChan did. I am now confused.
09:07:26 <jethr0> and what happened?
09:07:47 <Vanadium> A single thread got the Nothing and seemed to block on unGetChan
09:07:59 <jethr0> when the channel was empty after reading the Nothing, i would think writeChan and unGetChan to have similar effects, no?
09:07:59 <Vanadium> Or at least no other thread got the Nothing.
09:08:27 <Vanadium> It should have been empty. And it worked perfectly with writeChan, I just figured if they were to have similar effects, unGetChan would have been more appropriate
09:08:46 <jethr0> i had some strange behavior with channels as well. sth about lazyness tripping up my logic
09:08:47 <Saizan> jethr0: i'm not actually sure, i guess IO's >> might be lazy enough, you'd have to make a Monoid instance for IO a though
09:09:33 <jethr0> Saizan: that was lightyears above my head ;)
09:10:11 <Saizan> jethr0: do you know about >>= and >>?
09:11:00 <jethr0> yup
09:11:49 <Saizan> ah ok, so if you use Writer (IO ()) a you need a Monoid (IO ()) instance because that's what the Writer monads use to compose the bits you "tell"
09:12:07 <Saizan> ?src Monoid
09:12:07 <lambdabot> class Monoid a where
09:12:08 <lambdabot>     mempty  :: a
09:12:08 <lambdabot>     mappend :: a -> a -> a
09:12:08 <lambdabot>     mconcat :: [a] -> a
09:12:40 <Saizan> so you've to implement mappend to properly compose two IO actions
09:12:52 <Saizan> and the appropriate function is (>>) there
09:13:11 <Saizan> mempty is supposed to be the identity for mappend, so you want "return ()"
09:14:45 <jethr0> ah, hadn't thought of that. how about "Writer (IO () -> IO ())" with "tell (>> print "hello")"?
09:15:58 <Gracenotes> monoid! I choose you!
09:16:16 <Saizan> jethr0: you need the Endo newtype for that
09:16:24 <Gracenotes> I think it only knows three attacks, though...
09:16:26 <jethr0> *argh*
09:16:47 <Saizan> jethr0: newtype Endo a = Endo (a -> a) and it composes the functions like you'd expect
09:16:50 <nlogax> Gracenotes: what does it evolve into?
09:17:09 <jethr0> functor! I choose you! "fmap kill world"
09:17:12 <Saizan> jethr0: so tell $ Endo (>> print "hello")
09:17:18 <jethr0> k
09:17:47 <Gracenotes> or (print "hello" >>), for ordering? depends..
09:17:55 <Phyx-> Monoids wants to learn mplus but monoids can't learn more than 4 attacks, should monoids forget an attack and learn mplus?
09:18:06 <Saizan> Vanadium: the problem is that a blocked readChan blocks unGetChan, since they use the same mvar as mutex
09:18:24 <Vanadium> Saizan: Oh, okay. That clears it up, thank you.
09:18:26 <Saizan> Gracenotes: i guess you're right
09:18:32 <Gracenotes> nlogax: ah, yes, MonadPlus.
09:18:46 <Gracenotes> as Phyx- said.
09:18:59 <Gracenotes> however, it evolves into Alternative if you give it an alt stone
09:19:19 * Phyx- heads off to bash.org again
09:19:32 <etpace_> hmm, how does callCC work? I understand what it does, but i don't really understand the implementation
09:19:45 <medfly> I don't see anything funny here.
09:20:06 <Saizan> etpace_: have you looked at it?
09:20:08 * Gracenotes is not sure if he does either
09:20:27 <etpace_> I'm trying to
09:20:41 * jethr0 is still confused by continuations. even after years of theoretical "exposure"...
09:20:44 <Phyx-> medfly: since when is anything on bash funny?
09:20:58 <medfly> some quotes are funny
09:21:13 <Phyx-> but the majority of them aren't
09:21:14 <Phyx-> lol
09:21:22 <Saizan> ?djinn type Cont r a = (a -> r) -> r
09:21:22 <lambdabot> Cannot parse command
09:21:28 <Saizan> ?djinn-add type Cont r a = (a -> r) -> r
09:21:35 <dcoutts> @yarr!
09:21:35 <lambdabot> Yarrr!
09:21:48 <etpace_> yeah wikiboot says djinn can magic the callCC def up
09:21:51 <etpace_> wikibook
09:22:30 <Saizan> ?djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
09:22:30 <lambdabot> f a b = a (\ c _ -> b c) b
09:22:36 <ski> dolio : s/fun l -> match l of /function/ :)
09:23:39 <Saizan> callCC f k = f (\a k' -> k a) k -- reads better maybe :)
09:23:51 <Saizan> the point is that k' is discarded
09:24:02 <etpace_> "CallCC takes a function, that takes a function that would have returned b but instead returns r. callCC then returns a function that would have returned a, but instead returns r?
09:25:10 <jethr0> etpace_: now that cleared it all up for me... ^_^
09:25:33 <Saizan> i got confused instead :)
09:25:39 <etpace_> shouldn't (\a l' -> k a) be type (a -> Cont r b)?
09:25:51 <Saizan> it is
09:26:17 <Saizan> remember that a -> Cont r b = a -> (b -> r) -> r
09:26:28 <Saizan> so (l' :: b -> r) there
09:26:28 <etpace_> Aha
09:26:51 <Saizan> and since (k :: a -> r) then (k a :: r)
09:28:34 <Heffalump> hi andy
09:29:59 <arsenm> hi, I'm having a problem where ghc isn't finding an installed module
09:30:31 <dschoepe_> arsenm: did you upgrade ghc recently? in that case you have to reinstall the module.
09:30:56 <arsenm> dschoepe_: No, but I've tried reinstalling the module several times
09:31:16 <dschoepe_> arsenm: check whether it's listed in the output of ghc-pkg.
09:31:36 <dschoepe_> ("ghc-pkg list" that ist)
09:31:46 <dschoepe_> s/that ist/that is/
09:32:00 <arsenm> dschoepe_: it is listed
09:32:14 <jethr0> and how does ghc express it's not finding the module?
09:32:51 <arsenm>     Could not find module `C2HS':
09:32:51 <arsenm>       Use -v to see a list of the files searched for.
09:34:53 <ski> @type \(x0,xk) f -> f (x0,(\x1 -> f (x1,xk)))
09:34:55 <lambdabot> forall t t1. (t, t -> t1) -> ((t, t -> t1) -> t1) -> t1
09:34:57 <ski> @type \fk f -> fk (\(x0,xk) -> f (x0,(\x1 -> f (x1,xk))))
09:34:57 <Saizan> i think there's a command from c2hs to generate that module
09:34:58 <lambdabot> forall t t1 t2. (((t, t -> t1) -> t1) -> t2) -> ((t, t -> t1) -> t1) -> t2
09:35:08 <ski> , [$ty| \fk -> MkContT2 $ \f -> fk `unContT2` \(x0,xk) -> f (x0,(\x1 -> f (x1,xk))) |]
09:35:10 <lunabot>  forall a b c d . ContT2 c b d ((a, a -> d c)) ->
09:35:10 <lunabot>                   ContT2 c b d ((a, a -> d c))
09:36:12 <ski> .. now how to coerce djinn into proving this ?
09:36:58 <arsenm> ghc -v -e "import C2HS" gives me   locations searched: C2HS.hs C2HS.lhs
09:37:47 <Saizan> arsenm: run "c2hs -l" in your source directory
09:38:45 <lpjhjdh> is there an example of using the alex monad wrapper somewhere?
09:39:40 <arsenm> Saizan: thanks, that worked
09:40:07 <jethr0> > (+) <$> ([1],2) <*> ([1],3)
09:40:08 <lambdabot>   ([1,1],5)
09:40:41 <jethr0> strange things are to be found in the typeclassopedia
09:41:08 <Makoryu> @instances ([a],b)
09:41:08 <lambdabot> Couldn't find class `([a],b)'. Try @instances-importing
09:41:09 <Saizan> jethr0: if you plan on using a list as monoid for writer use DList instead
09:41:11 <ski> etpace_ : in `callCC f k = f (\a _ -> k a) k', `k' is the current continuation of the whole call `callCC f'. this invokes `f' with `k' as the current continuation *and* passes something containing the current continuation `k' to `f' as argument. this argument `\a _ -> k a' *whenever*invoked*, will discard/ignore *its* current continuation (`_') and instead "return" the argument `a' to the earlier `k' continuation
09:41:12 <Makoryu> Whoops
09:41:24 <Makoryu> @instances Functor
09:41:25 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:41:47 <jethr0> Saizan: k, will do. why DList? how about Sequence?
09:41:52 <ski> etpace_ : .. thereby making it appear like `callCC f' returned (its `k' continuation invoked) with result `a'
09:42:33 <Saizan> jethr0: DList because appending is O(1) for it, and not Sequence because it's stricter
09:42:33 <ski> etpace_ : filling in the constructors and deconstructors, it becomes
09:42:43 <jethr0> k
09:43:46 <ski>   callCC f `runCont` k = f g `runCont` k
09:43:47 <ski>     where
09:43:53 <ski>     g `runCont` _ = k a
09:44:04 <ski> or, making that into actual haskell
09:44:08 <ski>   callCC f `runCont` k = f (\a -> Cont $ \_ -> k a) `runCont` k
09:44:12 <ski> er
09:44:25 <ski>   callCC f = Cont $ \k -> f (\a -> Cont $ \_ -> k a) `runCont` k
09:45:15 <etpace_> Aha, thanks
09:45:25 <ski> etpace_ : so `callCC' itself duplicates the current continuation, while the constructed argument to `f' discards *its* current continuation (and uses the previously constructed one)
09:46:16 <ski> etpace_ : in SML/NJ, these two operations are separated into
09:46:41 <jjohnsson> did anyone find a fix for the zlib problem for cabal on snow leopard? I had it working, but then I tried to upgrade stuff to be able to (eventually) use hmatrix, but then it broke. :(
09:46:41 <ski>   callCC :: ('a cont -> 'a) -> 'a
09:46:56 <ski>   throw  :: 'a cont -> 'a -> 'b
09:47:12 <ski> @type callCC
09:47:14 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:47:47 <ski> this `callCC' would be slightly more general if the type was `MonadCont m => ((forall b. a -> m b) -> m a) -> m a' instead
09:48:46 <ski> (or possibly even `MonadCont m => ((a -> m (forall b. b)) -> m a) -> m a' or equivalently `MonadCont m => ((a -> m Void) -> m a) -> m a')
09:50:08 <ski> (namely, with the former of these, you could apply the same captured continuation (function) in contexts with differing types .. i'm not sure atm when the latter would be better)
09:51:08 <kmc> ski, are Void and (forall b. b) not isomorphic?
09:51:19 <ski> sure they are
09:51:36 <ski> "the former" here were `MonadCont m => ((forall b. a -> m b) -> m a) -> m a'
09:51:45 <kmc> ah
09:52:01 <etpace_> thanks ski, I think I understand it now
09:52:03 <ski> (note the "or equivalently" :)
09:53:39 * ski seems to recall someone here wanting `Monad m => ... -> m (forall a. ..a..)' rather than `Monad m => ... -> (forall a. m (..a..))' for some practical purpose
09:53:55 <ski> (but i think in that example `..a..' was not plain `a')
09:54:09 <etpace_> if I have callCC $ \k -> do k "escape!"; let foo = longfunction, is it the laziness that allows the longfunction to never be executed?
09:55:58 <ski> yes, but as long as you wouldn't have used `foo' if the `k "escape"' call were to monadically return, you would get the same effect if you remove the call to `k'
09:57:01 <ski> i.e. `callCC $ \k -> do let {foo = longfunction}; ...' where `...' doesn't name `foo' still doesn't compute `longfunction' (obviously)
09:57:33 <gwern> huh. we now have a palindrome package
09:57:40 <etpace_> so, callCC doesnt allow you to "return" straight away, rather you return to the original continuation after f, discarding the 'other' continuation?
09:57:43 <gwern> doesn't seem very useful, but I guess it shows the breadth of hackage
09:58:49 <ski> but yes, the call to `k' discards the current continuation (hich consists of that `...' and everything "after" the current call, higher up in the `Cont' monad `(>>=)'- (or `do'-) callchain)
09:59:29 <etpace_> in a nonlazy language, is it possible for longfunction to still be called?
09:59:30 <ski> etpace_ : compare with `do Nothing; let {foo = longfunction}; ...' and `do Left err; let {foo = longfunction}; ...'
09:59:52 <etpace_> right
10:00:08 <FunctorSalad_> :( my FFI-using library compiles, but when I try to write an executable using it, linking fails because it can't find one of the C function symbols
10:00:11 <jethr0> :t maybe
10:00:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:00:22 <ski> etpace_ : in a strict language with continuation side-effects (such as e.g. Scheme or SML/NJ), the corresponding `longfunction' would not be computed
10:00:40 <FunctorSalad_> I did use "extra-libraries: ..." in the FFI-using library's .cabal
10:01:19 <jethr0> FunctorSalad_: are the include files and the linked library the same version? was the library actually linked against?
10:01:40 <etpace_> ok, thanks
10:03:28 <etpace_> the people who discover this stuff are impressive
10:03:44 <FunctorSalad_> jethr0: must be the same, I just installed the C library in question... not sure about the second question
10:04:26 <jethr0> when lifting a function into a monad (apart from liftM being the only "correct" answer), do you prefer "<$>", fmap or liftM?
10:04:58 <jethr0> have you tried adding -v to actually see the calls to ghc/gcc/...
10:05:06 <FunctorSalad_> jethr0: if I "nm" my libHSSYMPHONY-0.0.a, it says "U sym_open_environment", whre sym_open_environment is the missing symbol ghc complains about
10:05:20 <FunctorSalad_> I think this is bad but I don't really know what I'm talking about
10:05:28 <sjanssen> jethr0: I never use liftM.  Beyond that, I generally prefer fmap
10:05:42 <etpace_> so, you cant do callCC $ \k -> do {...; k "escape!} right? as it seems to need a >>= to 'return' to the original?
10:05:51 <FunctorSalad_> and libHSSYMPHONY is the FFI-using lib I made
10:06:13 <eoeas> NEWBIE: hi everybody, i compiled hello.hs with ghc 6.8.2 (ubuntu 8.04), why is my binary 359 kb although it only contains the line: main = putStrLn "Hello, world!"
10:06:27 <jethr0> FunctorSalad_: sounds bad, the symbol seems indeed to be missing. do you maybe need another library?
10:06:43 <sjanssen> eoeas: GHC includes a copy of its runtime in each binary, that's the overhead you're seeing
10:06:52 <sjanssen> eoeas: running 'strip' on the executable will help a little
10:06:52 <Saizan> FunctorSalad_: so it works in ghci but not with ghc --make ? weird, i generally get the opposite problem
10:07:25 <FunctorSalad_> jethr0: it does kinda find the C library though because I have an "extra-libraries:" in the .cabal, and if I change that library name to gibberish, cabal fails (so it is indeed used ;))
10:07:27 <eoeas> sjanssen: strip ??
10:07:32 <ski> - Cont.callcc (fn k => (Cont.throw k "escape !"; let val foo = (print "foo !"; 42) in Int.toString foo end));
10:07:35 <ski> val it = "escape !" : string
10:07:44 <ski> etpace_ : ^ that's SML/NJ
10:07:45 <FunctorSalad_> Saizan: didn't try ghci
10:08:22 <sjanssen> eoeas: yes, it's a command available on most Unixes, just "strip mybinary"
10:08:24 <FunctorSalad_> Saizan: the library compiles with cabal, but trying to write a Main fails at linking
10:08:33 <jethr0> did you actually wrap sym_open_environment in the FFI-using library?
10:08:52 <jethr0> sjanssen: what does strip take out?
10:08:56 <Saizan> FunctorSalad_: ah, i misread
10:09:16 <ski> jethr0 : `fmap' if i know my monad is in `Functor', `liftM' otherwise (i.e. e.g. for operations polymorphic over the monad)
10:09:37 <eoeas> sjanssen: okay, so it having a copy of ghc's runtime means it can run on another linux system that doesn't have ghc libraries ???
10:09:45 <FunctorSalad_> jethr0: "wrap" means have a "foreign import ccall" line? then yes
10:09:46 <sjanssen> eoeas: yes, exactly
10:10:04 <ski> etpace_ : there is no problem with `callCC $ \k -> do {...; k "escape!}'
10:10:26 <eoeas> sjanssen: is that what you call hard-linked in programming ?
10:10:40 <Saizan> static linked
10:10:51 <jethr0> weird, an is the foreign import exportet by the module? to be honest i'm a bit at a loss with that problem...
10:11:00 <sjanssen> jethr0: strip discards symbols from the object file.  This generally makes debugging the executable impossible, but it saves a bit of space
10:11:29 <eoeas> Saizan: so static is independant and dynamic requires local libraries, right?
10:11:35 <SamB> and debugging GHC-produced executables is practically impossible using GDB anyway ;-)
10:12:00 <sjanssen> eoeas: what Saizan said, "statically linked".  Currenly all Haskell libraries are statically linked in GHC, which causes slightly larger executables, but it also makes them more portable
10:12:45 <jethr0> if by portable you mean portable-across-platforms-of-the-same-ABI
10:13:22 <eoeas> I see, thanks very much sjanssen and Saizan :)
10:13:26 <FunctorSalad_> jethr0: yes, it is exported... here's the .chs FWIW (short) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9121
10:13:41 <SamB> it also means they won't suddenly stop working when you upgrade GHC ;-)
10:14:11 <FunctorSalad_> (that is the file that does work)
10:15:28 <ski> etpace_ : that `callCC $ \k -> do {...; k "escape!}' usually occurs to the left inside a ` >>= c'. every such `c' (out to the call to `runCont' (if no nqCPS is used)) will be part (in order) of the captured `k'
10:15:47 <sjanssen> jethr0: slightly less portable than that.  But, for example, moving binaries between modern Linuxes of the same arch typically works
10:16:47 <etpace_> aha
10:18:23 <jethr0> why slightly less? because of dynamic library dependencies of the ghc runtime?
10:19:11 <sjanssen> yeah, libc and kernel differences can matter
10:24:47 <ski>   callCC (\_ -> ma) >>= c  =  ma >>= c
10:25:00 <ski>   callCC (\k -> ma >>= k) >>= c  =  ma >>= c
10:25:01 <gwern> dons: http://donsbot.wordpress.com/2009/09/05/the-haskell-platform-status-report-haskell-symposium-2009/ scribd, seriously?
10:25:55 <sjanssen> gwern: what's scribd?
10:26:04 <gwern> sjanssen: evilness
10:26:18 <gwern> oh, you wanted details? flash pdf, flash txt, flash html...
10:26:35 <sjanssen> oh, that thing
10:26:45 <sjanssen> yeah, what was ever wrong with a link to PDF?
10:27:23 <gwern> a little old lady in peoria once lost an eye to a PDF popping up
10:27:29 <m4ik3ru> Howdy.
10:27:31 <SamB> yeah, I don't get that shit
10:28:47 <eoeas> Is it possible to program low-level in Haskell i.e. kernels, without embedding C or Asm ??
10:29:10 <m4ik3ru> I'm new to Haskell, as I'm sure will be become blantanly obvious quite soon.
10:29:16 <sjanssen> eoeas: there's an OS in Haskell, check out "house"
10:29:17 <SamB> most likely, there would be a need for a small amount of C and/or ASM
10:29:33 <m4ik3ru> First homework assignment, and no, I don't want you to do it for me, I just need to be pointed in the right direction...
10:29:34 <SamB> I mean, I don't think you can write a bootloader in Haskell ...
10:29:49 <m4ik3ru> First time programming in a functional language too.
10:29:56 <byorgey> m4ik3ru: welcome!
10:30:01 <sjanssen> SamB: really it depends on your compiler
10:30:05 <SamB> ... there's a few things CPUs do that need special instructions, etc.
10:30:09 <m4ik3ru> The prof wants me to implement a function firstN that returns the first n elements of a list.
10:30:10 * byorgey hands m4ik3ru a golden lambda.
10:30:19 <m4ik3ru> ...for which there is already a haskell function...
10:30:21 <sjanssen> SamB: if you add primops for the special instructions, I don't see why it isn't possible
10:30:29 <FunctorSalad_> jethr0: maybe you were right and I need another library
10:30:30 <dm`> firstN = take
10:30:34 <m4ik3ru> byorgey: Thanks, by the way :)
10:30:34 <SamB> sjanssen: that's more-or-less cheating
10:30:44 <SamB> sjanssen: those primops still need implementing somehow!
10:30:46 <FunctorSalad_> any hints how I can find the right library file?
10:30:54 <dm`> But I'm sure you are supposed to actually implement it, not just rename a function.
10:31:01 <m4ik3ru> I've tried that, the annotation says this: firstN :: Int -> [a] -> [a]
10:31:04 <m4ik3ru> Yeah.
10:31:15 <byorgey> m4ik3ru: that looks like the right type.
10:31:21 <m4ik3ru> I'm just having a hard time understanding this pure functional stuff.
10:31:22 <sjanssen> SamB: yes and no.  The truth is that you can't write anything that executes on the metal without writing some assembly
10:31:31 <gwern> oh christ and it's only 11 slides
10:31:35 <m4ik3ru> obviously I have to print *something* to screen, yes?
10:31:39 <byorgey> m4ik3ru: no.
10:31:45 <gwern> why is it even a pdf in the first place?
10:31:51 <ski>   callCC (\k -> mea >>= either k ame) >>= emb  =  callCC (\k -> mea >>= either (emb >=> k) (ame >=> emb))  -- ?
10:31:55 <SamB> sjanssen: I mean, creatin special primops just so you can say you didn't write ASM seems like cheating ;-)
10:31:56 <dm`> sjanssen: Depends on the hardware and bootloader, but you can come very close.
10:32:00 <byorgey> m4ik3ru: if the function was supposed to print something to the screen it would have to have IO in its type.
10:32:18 <dm`> sjanssen: On the DEC alpha, I think it was possible to start executing in C code in something like 3 instructions.
10:32:19 <byorgey> m4ik3ru: but you can experiment with pure functions (including printing their results to the screen) in an interactive environment like ghci
10:32:27 <sjanssen> SamB: (+) requires special primops just so you can say you didn't write ASM.  Is that cheating?
10:32:33 <m4ik3ru> Using that interpreter as we speak :)
10:32:51 <SamB> sjanssen: that's different -- those are general purpose primops!
10:32:54 <byorgey> m4ik3ru: right. =)  so you don't need to worry about anything like printing to the screen when implementing the function, ghci will handle that for you.
10:33:08 <Phyx-> @src (+)
10:33:09 <lambdabot> Source not found. I feel much better now.
10:33:13 <ski>   callCC (\k -> ma >>= body k)  =  ma >>= callCC body  -- i suppose
10:33:17 <m4ik3ru> I've looked at using : and foldr already...right track or wrong track?
10:33:19 <byorgey> m4ik3ru: so, what have you tried so far?  the general approach is to implement the function by cases.
10:33:21 <jethr0> > 4 + 3
10:33:22 <lambdabot>   7
10:33:29 <byorgey> m4ik3ru: foldr is probably overkill for now.
10:33:35 <hackagebot> event-list 0.0.10 - Event lists with relative or absolute time stamps (HenningThielemann)
10:33:36 <sjanssen> SamB: I think it depends on the interface exposed.  If prepareBootLoader is a primop that executes a whole bunch of ASM, I'd call that cheating.  On the other hand, 'pokeSpecialRegister X foo' seems like a reasonably general interface
10:33:38 <SamB> oh, and lets not forget the unusual calling conventions that interrupt/exception handlers often need to implement ...
10:33:39 <byorgey> m4ik3ru: but the answer will certainly involve (:) .
10:33:49 <jethr0> m4ik3ru: see, no printing necessary. ghci and lambdabot have a read-eval-print loop
10:33:50 <m4ik3ru> cases like, counting how many things i've alrady processed?
10:34:09 <m4ik3ru> like if i call firstN 5, count how many times I :?
10:34:14 <jethr0> m4ik3ru: do you know how to calculate the sum of a list?
10:34:14 <m4ik3ru> (does that even make any sense?)
10:34:16 <byorgey> m4ik3ru: no, I mean like cases on what arguments you are given.  for example, what if the first argument is 0 ?
10:34:22 <dschoepe> m4ik3ru: recursion is simpler: when giben firstN 0 return the empty list.
10:34:28 <dschoepe> s/giben/given/
10:34:39 <m4ik3ru> if the first argument is 0, firstN 0 = []
10:34:40 <byorgey> dschoepe: don't solve m4ik3ru's homework, please.
10:34:50 <byorgey> m4ik3ru: right! so that's the first line of the solution.
10:34:58 <m4ik3ru> Good!  I had that so far :)
10:34:59 <byorgey> m4ik3ru: well, except firstN takes another argument
10:35:11 <m4ik3ru> do i have to define that list first?
10:35:16 <dschoepe> byorgey: that's why I'm only giving him the abort condition. :)
10:35:17 <byorgey> no.
10:35:18 <SamB> sjanssen: but if those are all arch-specific, are they really any better than writing in C+ASM ?
10:35:21 <byorgey> dschoepe: ok =)
10:35:46 <jethr0> m4ik3ru: look at your type signature from before. what you wrote just now has type "firstN :: Int -> [a]"
10:35:47 <m4ik3ru> so firstN 5 [1..] is valis?
10:35:57 <sjanssen> SamB: whether it is better is another kettle of fish :)
10:35:57 <m4ik3ru> *valid
10:36:10 <ski>   callCC (\k -> ma >>= \a -> ..a..k..)  =  ma >>= \a -> callCC (\k -> ..a..k..)  -- corrected
10:36:11 <jethr0> yes, that would be a valid call with your above type signature
10:36:14 <byorgey> m4ik3ru: sure, that should return [1,2,3,4,5]
10:36:24 <roconnor> I think the prolog benchmark needs to be updated.
10:36:30 <m4ik3ru> let's try that...
10:36:40 <SamB> when I said "need", I meant "will probably want in order to avoid going insane" ;-)
10:36:41 <ski> roconnor : what does it do ?
10:36:44 <jethr0> try what?
10:36:51 <sjanssen> SamB: perhaps the best answer to eoeas question is "even OSs written in C embed some assembly, you'd need about the same amount of ASM in a Haskell compiler"
10:36:56 <roconnor> ski: I don't know but GHC's version runs in 0.00 seconds
10:37:03 <m4ik3ru> Nothing, actually, I just realized.
10:37:09 <Phyx->  /win 3
10:37:10 <sjanssen> SamB: oh, I don't see how a bunch of #ifdef in Haskell is more insane than the same in C
10:37:11 <Phyx-> whoops
10:37:21 <m4ik3ru> I have the next case now, I just don't know what to put on the other side of =
10:37:22 <ski> roconnor : what does the benchmark "solve" ?
10:37:42 <byorgey> m4ik3ru: wait, what is the first case?
10:37:44 <SamB> and, of course, most Haskell compilers have a certain amount of RTS code written in C anyway ...
10:37:49 <m4ik3ru> so i have firstN 0 = [] and firstN n [1..] = something.
10:37:58 <byorgey> m4ik3ru: that first case still isn't quite right.
10:38:08 <byorgey> m4ik3ru: since firstN takes two parameters, you have to list something for the second parameter.
10:38:11 <roconnor> ski: I don't know
10:38:12 * ski have no idea what is discussed .. only "prolog" runs a bell in the head :)
10:38:15 <m4ik3ru> firstN 0 [1..] = 0?
10:38:23 <Phyx-> I need a nice haskell paper to write a paper about and give a small 40mins talk about. Any suggestions?
10:38:26 <SamB> sjanssen: oh, but at least you wouldn't have to create a bunch of machine-specific primops, and most likely recompile the compiler each time you add one ...
10:38:28 <FunctorSalad_> sorry if I'm getting annoying but ;) which cabal settings or source pragmas detemine how the symbols are linked in the compiled libHSfoo.a file?
10:38:31 <jethr0> m4ik3ru: still not quite
10:38:31 <m4ik3ru> No, firstN 0 [1..] = []?
10:38:34 <roconnor> ski: I just think benchmark programs should take more that 0.00 seconds to run
10:38:40 <byorgey> m4ik3ru: no, firstN 0 x  is [] no matter what the second argument is, right?
10:38:42 <FunctorSalad_> the headers don't have anything to do with it, or do they?
10:38:44 <jethr0> maybe in the future you will apply it to a different list than [1..], no?
10:38:49 <ski> roconnor : that might be a good idea
10:38:49 <Phyx-> anything from the POPL, ICFP or PLDI is accepted
10:38:49 <byorgey> m4ik3ru: if you don't care about an argument you can put  _
10:38:58 <eoeas> sjanssen: you mentioned primops, is that a function that implements asm code ??
10:38:59 <SamB> GNUC just seems to be more ASM-embedding friendly than any dialect of Haskell ;-)
10:39:00 <m4ik3ru> ...ok
10:39:00 <byorgey> m4ik3ru: also, it's a bit noisy in here, shall we move to #haskell-overflow?
10:39:01 <dschoepe> m4ik3ru: that would assume that the given list is [1..], but you would want your function to work for any list.
10:39:05 <m4ik3ru> sure
10:39:29 <mattam> Phyx-: Take an Oleg paper, like the LogicT one.
10:39:40 <byorgey> Phyx-: how about "Applicative Programming with Effects"?
10:39:50 <byorgey> or the Fingertree paper
10:39:53 <byorgey> those are nice ones.
10:40:15 <mattam> Oh yeah the fingertree paper is great.
10:40:21 <sjanssen> eoeas: short for "primitive operation", basically something that can't be expressed in the source language
10:40:40 <Phyx-> byorgey: oh, i'll take a look thanks
10:40:46 <Phyx-> mattam: will also take a look at that
10:44:29 <eoeas> sjanssen: I c, i read that the helium compiler gives more user-friendly messages, however, doesn't support type classes yet. Do you think that me, as a beginner, can do without type classes at such an early learning stage ??
10:46:46 <Makoryu> eoeas: The user-friendliness of Helium is honestly overrated
10:47:19 <Phyx-> very nice suggestions byorgey and mattam i'll read both and see which one i'll choose. Thanks
10:47:41 <dcoutts> FunctorSalad_: I don't understand your question, could you try explaining again?
10:47:45 <eoeas> Makoryu: Is it ?! :-D
10:47:50 <Phyx-> Makoryu: it's user friendliness is in the error it generates
10:47:54 <Phyx-> and the tips it gives
10:48:03 <Phyx-> especially when compared to what ghc spits out at times
10:50:28 <Phyx-> eoeas: sure, when you're learning the basics you don't reallyneed any type classes, to learn the basics of pure functions, partial application, recursion etc
10:50:52 <byorgey> but type classes come in useful very quickly
10:50:55 <Makoryu> Phyx-: True, GHC's error messages are horrendous even when you're used to them :p
10:51:13 <byorgey> and type classes are not very difficult to understand.
10:51:17 <roconnor> eoeas: however even if you don't use type classes, GHC's error messages can still be cryptic because it knows about type classes.  Messages are even more cryptic because you don't know about type classes.
10:51:18 <Phyx-> eoeas: our first years always start with helium for the first excercise, they get a good set of assignments to do which don't really require typeclasses
10:51:46 <Phyx-> byorgey: true, but they aren't the first things one should learn imho
10:51:57 <Makoryu> When playing around with helium I found that it does sort of know about typeclasses, but it restricts their usage in weird ways
10:52:41 <FunctorSalad_> dcoutts: maybe my question didn't make much sense... essentially I'm wondering how to debug the linking process :) (a first question would be whether (the compilation of) my FFI-using library is to blame, or the executable using that library)
10:53:17 <Phyx-> Makoryu: one of the uses of Helium is, when used inside the UU networks it anonymously collects information about the type of mistakes/errors students make. in order for the course to address them. and also a way to track overall progress
10:53:49 <byorgey> Phyx-: agreed.
10:54:23 <eoeas> Phyx-: Are there any Haskell beginner tutorials that are compatible with Helium out there ??
10:54:59 <Phyx-> eoeas:tutorials, i don't know, but i do know os some assignments
10:55:46 <Phyx-> of*
10:55:51 <eoeas> Phyx-: That could do, any links at hand?
10:56:21 <Phyx-> oops, they're in dutch :|
10:56:43 <eoeas> hahaha
10:56:55 <eoeas> nevermind
10:57:12 <Phyx-> i generally only used helium myself for bout 3 days
10:57:16 <Phyx-> then i went to ghc :P
10:59:01 <byorgey> eoeas: my recommendation is, just use ghc and ask lots of questions in here =)
11:01:22 <Phyx-> eoeas: ah, i found an english version of the lecture notes, http://people.cs.uu.nl/jeroen/courses/fp-eng.pdf
11:02:01 <eoeas> byorgey: Yup, that makes sence
11:02:56 <eoeas> Phyx-: yey, thanks very much
11:04:43 <dcoutts> FunctorSalad_: I see, one useful check is to see if you can load your package in ghci
11:06:41 <jethr0> what's wrong with "import Prelude (); data List a = a : (List a) | []" ?
11:07:07 <roconnor> jethr0: [] isn't allowed as a name?
11:07:45 <roconnor> I'm not even sure about :
11:08:15 <FunctorSalad_> dcoutts: thanks, that narrowed it down. ghci also says "user specified .o/.so/.DLL could not be loaded (libOsi.o ..."
11:08:21 <jethr0> it complains about ":". can I use "::" or sth?
11:08:23 <FunctorSalad_> oddly cabal/ghc doesn't complain about -lOsi
11:08:59 <FunctorSalad_> I only have "/usr/local/lib/libOsi.a", does that matter?
11:09:13 <FunctorSalad_> (not .o or .so)
11:11:55 <Peaker> what's Helium?
11:12:30 <dqd> Helium is a dialect of Haskell that is used for teaching purposes.
11:12:53 <ray> : should be allowed
11:13:08 <gwern> helium is hard to build tho
11:13:21 <eoeas> Peaker: http://en.wikipedia.org/wiki/Helium_(Haskell)
11:13:24 <gwern> I once tried to cabalize it and gave up in disgust on learning it's written in like 3 languages
11:13:28 <Peaker> eoeas: thanks
11:13:28 <gwern> including java
11:15:59 <Valodim> you scared java out :P
11:16:36 <gwern> @quote eventually
11:16:36 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
11:16:36 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
11:16:36 <lambdabot> he was one of the pugs de
11:16:51 <gwern> @quote eventually
11:16:51 <lambdabot> DavidLeimbach says: Don't play with your monads... eventually you'll go bind.
11:16:58 <gwern> @quote eventually
11:16:58 <lambdabot> Elly says: a lazy cat will eventually be fine too
11:17:01 <Gracenotes> well how does it end
11:17:09 * gwern snickers especially at that last one
11:17:18 <gwern> Gracenotes: WE SHALL NEVER KNOW
11:17:57 <Gracenotes> ribbing, eh
11:18:33 <gwern> in a decade, people will be looking at our quotes file and they will have no idea why on earth that lazy cat will be fine
11:18:49 <gwern> heck, people probably stare in incomprehension at our current quotes file...
11:18:58 <kmc> yeah i don't get it
11:19:27 <gwern> kmc: google 'a cat is fine too'
11:19:40 <Gracenotes> a cat will be fine in a decade surely
11:19:46 <Valodim> gwern: that's gonna take more than a decade
11:19:57 <Taejo> To future Haskell Historians: look at the archives of http://encyclopediadramatica.com/A_Cat_Is_Fine_Too
11:19:57 <kmc> sigh
11:19:58 <gwern> Gracenotes: a lot of '99 memes are dead
11:20:09 <Valodim> right but not forgotten
11:20:18 <gwern> when was the last time you saw a dancing baby, subservient chicken, or yotta
11:20:20 <trzkril>                ("M-/", withFocused $ windows . W.sink),
11:20:35 <gwern> all your base is the only one of that era I can really remember
11:20:36 <Gracenotes> toxoplasmosis will ensure that cats will always be fine too
11:20:42 <trzkril> hmpf
11:20:48 * Taejo doesn't remember any of those except AYB
11:20:57 <gwern> see?
11:20:59 <trzkril> should bind another button to open urls
11:21:25 <Taejo> tho I'm not sure I even had internet access in 1999
11:21:31 <gwern> Taejo: although you may be assuming there that ed will be around another decade, not something I would
11:21:34 <Gracenotes> I recognize some of them. but internet people were less into metamemery than they are now
11:22:01 <Taejo> gwern: no, I assume the Internet Archive will be around
11:24:45 <eoeas> Taejo: LMAO!
11:43:51 <kmc> what are the best grad schools for doing interesting research in haskell?
11:45:06 <jethr0> microsoft reasearch ;)
11:45:39 <jethr0> i think cambridge, GB may have some affiliations to MS research
11:45:46 <jethr0> s/GB/UK/
11:46:53 <eoeas> Here's a joke: Two guys on a IRC channel are bragging about their genital sizes, the first one says: "Mine is thicker than the space bar on my keyboard!", unimpressed, the other one then replies: "that's nothing, if I layed mine on the keyboard, it would print all the characters from A to Z" ...
11:47:54 <mauke> eoeas: There are 16 kinds of people, those who understand hexadecimal and those who don't.
11:48:04 <xaep> eoeas: another bash.org fan7
11:48:05 <jethr0> hehe, highly keyboard-layout-specific though...
11:48:16 <djahandarie> I'm on bash
11:48:17 <jethr0> it's way funnier with 10
11:48:22 <jethr0> and binary
11:48:26 <eoeas> lol
11:48:31 <jethr0> since 10_2 = 2_10
11:48:32 <mc__> indeed
11:48:33 <mc__> it is  not funny at all with 16
11:49:04 <mauke> wow
11:49:30 <kmc> ugggh
11:49:36 <etpace_> *whoosh*
11:49:47 <mc__> every base is base 10
11:50:00 <mauke> etpace_: thank you
11:51:30 <eoeas> Anyone else with a non-offending joke? :)
11:51:58 <djahandarie> You could go read my programming rap
11:52:02 <djahandarie> It's somewhere in the top 100
11:52:17 <eoeas> Link ?
11:52:38 <djahandarie> http://bash.org/?870063
11:53:34 <mauke> There are four engineers traveling in a car -- a mechanical engineer, a chemical engineer, an electrical engineer, and a computer engineer. The car breaks down.
11:53:37 <mauke> "Sounds to me as if the pistons have seized. We'll have to strip down the engine before we can get the car working again", says the mechanical engineer.
11:53:40 <mauke> "Well", says the chemical engineer, "it sounded to me as if the fuel might be contaminated. I think we should clear out the fuel system."
11:53:43 <mauke> "I thought it might be an grounding problem", says the electrical engineer, "or maybe a faulty plug lead."
11:53:46 <mauke> They all turn to the computer scientist, who up to then had said nothing, and asked "Well, what do you think?"
11:53:49 <mauke> "I put on my robe and wizard hat. My other car is a cdr." The computer scientist pulls out a cudder from his pocket, and shoves it down the throats of the engineers. "Take that, motherfuckers!!!!"
11:55:12 <tew88> mauke: I was really hoping for better :(
11:55:57 <djahandarie> CDR is a reference to LISP?
11:56:50 <eoeas> djahandarie: Hahahahaaaa, very nice, me like!
11:57:07 <jethr0> djahandarie: yes
11:57:15 <djahandarie> eoeas, thanks. :P It was totally spur-of-the-moment too
11:57:19 <jethr0> (car:cdr) = xs
11:57:29 <gwern> that's one random joke
11:57:35 <djahandarie> jethr0, right, I was just making sure
11:57:51 <djahandarie> I don't like LISP anyways
11:57:52 <djahandarie> :P
11:57:54 <etpace_> haha what the hell mauke
11:57:56 <jethr0> the computer scientist isn't really solving the problem though. rather aggravating it
11:58:13 <jethr0> how can you not like lisp?
11:59:34 <djahandarie> jethr0, idunno. It doesn't have a good type system, can't be optimized as well as Haskell, and it requires large runtime environments.
11:59:42 <djahandarie> Not to mention the shitty syntax
11:59:57 <jethr0> well, it's 40 sth years old
12:00:03 <xaep> why large runtime?
12:00:09 <xaep> is scheme runtime large?
12:00:33 <jethr0> and building abstractions can be SOO powerful in lisp. not even to speak of the interactive environment...
12:00:40 <djahandarie> Well, it's due both to the size of the Lisp language and the difficulty of removing unused features during applicatino delivery
12:00:53 <jethr0> but yes, in some corners you can tell its age
12:00:57 <SubStack> > 2009 - 1958
12:00:58 <lambdabot>   51
12:01:07 <jethr0> ghc runtime is also not so small
12:01:21 <jethr0> SubStack: i forgot it was already 2009 *heh*
12:01:32 <deech> I'm getting more comfortable with Haskell, but I would love to know the workflow of more experienced Haskellers. Speaking of Lisp, there are some really nice screencasts out there develop a complete working program. This would be really nice for Haskell.
12:01:39 <xaep> djahandarie: hmm, you're talking about CL, right?
12:01:44 <djahandarie> Yeah, LISP can do some cool stuff like object oriented shit, syntactic abstraction, dynamic environment, the package system, dynamic typing and extensive libraries
12:01:47 <Cale> I don't like common lisp, but scheme is okay.
12:01:54 <djahandarie> But I don't like it
12:01:59 <djahandarie> Just gives me bad vibes
12:01:59 <xaep> djahandarie: CL is not the only LISP :)
12:02:08 <jethr0> deech i've thought about it. and even started recording my programming for project euler problems
12:02:11 <djahandarie> xaep, I know
12:02:15 <jethr0> never made it to public screencasts though ;(
12:02:44 <Berengal> I'm a bit confused by lispers
12:02:46 * tew88 would love some Haskell vids
12:02:49 <jethr0> common lisp is very large. scheme has the beauty of minimality, in some ways
12:03:20 <Berengal> The last few months, I've had several conversations with lispers who complain that you can't mix lists and values in haskell
12:03:29 <jethr0> the problem is the running audio commentary. that can be a lot of work, and without it live programming vids can get SOO boring
12:03:38 <Cale> Also, scheme doesn't have that separate namespaces for functions and other values nonsense.
12:03:38 <tew88> Stumbled upon any decent ones in your searching, deech?
12:03:44 <jethr0> maybe i'll revive my idea of haskell screencasts to showcase some development styles
12:03:57 <Berengal> You'd think the ones programming in a language where everything you do is define trees in terms of lists would know the difference
12:04:12 <jethr0> (i.e. data driven (data types first), type driven (type signatures first), ...)
12:04:21 <tew88> There's gotta be an audience for that, jethr0 :)
12:04:31 <deech> I've found that Common Lisp libraries are immature in the sense that they are often out of sync with their dependencies, making them very difficult to work with.
12:04:51 <jethr0> sure, but to do it well it requires quite a bit of work. and i'm not too keen to hear my voice on a screencast ;)
12:04:52 <deech> tew88: In Haskell, not a one.
12:05:05 <Cale> Berengal: I had to find and remove so many bugs in my lisp code which would have been prevented by forcing all the elements of a list to have been the same type.
12:05:25 <tew88> jethr0: Hire a poetic-sounding Englishman to dub it for you!
12:05:43 <jethr0> cool idea, how about you? are you poetic-sounding at all?
12:05:49 <Cale> Berengal: They can be so hard to track down too, because the place where the program goes wrong because the wrong type of thing is in the list can be far away from where the element gets into the list.
12:06:35 <Berengal> Cale, s/some words/some other words/ and you could be talking about most any other dynamically types language
12:06:35 <deech> tew88: Haskell is probably the hardest language to live code in.
12:06:43 <tew88> jethr0: Possibly. If you get around to doing it and you find it's a genuine issue for you - I'd be happy to assist with the vocals ;)
12:06:44 <jethr0> to be fair, some bugs can be hard to track in haskell too! unless you know Core
12:07:40 <jethr0> k, i may get back to you on that. maybe i'll put sth like that up. not like i am a haskell guru (and thus the style of programming may not be optimal) but if my level of expertise is high enough, it may be better than nothing *g*
12:07:51 <jethr0> and i may get good advice from my viewers...
12:08:10 <tew88> deech: I'm not sure I agree. If you can present the process rather than the actual coding, it shouldn't matter that it's live
12:08:27 <tew88> jethr0: Agreed. I'll be around.
12:08:58 <jethr0> who said anything about live coding. it's more about conveying the approach and the method than being "live" or not
12:09:07 <tew88> Ya
12:09:09 <jethr0> or a real-time recording for that matter
12:10:04 <deech> jethr0: Yeah, the process is really all I'm looking for. It doesn't have to be live!
12:10:04 <tew88> But I take the point that it's easier to demonstrate step-by-step scaling in an imperitive language
12:10:30 <jethr0> tew88: not sure i agree
12:10:36 <kmc> i don't agree at all
12:11:05 <kmc> shouldn't equational reasoning and composability be an asset here
12:11:49 <kmc> imo the first stage of writing any haskell program is writing the main types
12:11:53 <kmc> and that's not so incremental
12:13:04 <tew88> Well it isn't natural in the sense that the target audience of these videos would presumably be novices to FP concepts
12:13:47 <deech> kmc: I've really tried that but have found that as my understanding of the problem evolves, rewriting the types and changing all the function sifnatures is a major pain.
12:13:51 <jethr0> you think? i for one don't consider myself a novice and would still love to watch someone skilled program a non-trivial example
12:14:14 <jethr0> also, you could showcase different styles (top-down, bottom-up, dataflow, type-driven, ...)
12:14:46 <iago> what is the video?
12:15:11 <jethr0> for example, quite a few scheme/lisp weenies like programming bottom-up to create a kind of EDSL to solve their problem in
12:15:25 <jethr0> iago: i think we talking hypothetically
12:15:43 <iago> oh
12:15:50 <kmc> jethr0, that's how i program in haskell i think
12:16:09 <tew88> jethr0: There's certainly scope to cover a lot of ideas, sure
12:16:20 <EnglishGent> hello :)
12:16:34 <tew88> And there's your voice... ;)
12:16:48 <jethr0> as we're already talking about it, what would you like to see covered?
12:16:50 <deech> :)
12:16:55 <jethr0> hi EnglishGent
12:17:02 <EnglishGent> hi jethr0 :)
12:17:22 <kmc> deech, i agree that it's important to get the types right at first.  i think tweaking the functions once you have types correct is much easier
12:17:27 <kmc> types are a great aid to refactoring
12:17:36 <Phyx-> jethr0: everytime i read your nickname, i'm reminded of agent Gibbs in NCIS
12:17:42 <EnglishGent> can anyone tell me how I can persuade cabal to fetch source? I've got it working.. but I'd really like to see the source to some of the packages I'm using
12:17:43 <EnglishGent> :)
12:18:01 <jethr0> hehe
12:18:06 <tew88> Well there's a lot of introductory material on Haskell out there. So yeah, something perhaps to complement the middle to latter chapters of RWH. A focus on and comparison of development styles would benefit lots of people
12:18:09 <kmc> especially if you are obsessive about newtyping all primitive types and avoiding tuples/maybe/either in  favor of new algebraic types
12:18:40 <jethr0> cabal fetch <package-name>
12:18:46 <jethr0> it downloads to you default cabal folder
12:18:56 <jethr0> ~/.cabal/packages/ under linux
12:19:05 <EnglishGent> ah - ty jethr0 :)
12:19:16 <Berengal> EnglishGent, also, cabal unpack ignores dependencies
12:19:19 <jethr0> c:\Documents and Settings\user\Application Settings\Cabal\packages under windows (modulo typos)
12:19:24 * EnglishGent only got cabal working a few minutes ago
12:19:26 <EnglishGent> :)
12:19:52 <jethr0> if you do "cabal install" it also downloads the package BTW
12:19:57 <Berengal> cabal install does the same as fetch does, but also installs stuff. You can always find your source in ~/.cabal/packages
12:20:03 <deech> jethr0: An example where you take a non-trivial problem and start coding bottom-up, start noticing patterns and identify them as monoids, monads etc, and refactoring them.
12:20:48 <jethr0> huh, that's almost beyond my skill-set or current practices. probably would make sense to involve the #haskell masters at some point ;)
12:20:53 <jethr0> good idea though
12:20:56 <EnglishGent> I did a cabal install - it just didnt get the source
12:20:57 <EnglishGent> :)
12:21:16 <EnglishGent> as I'm still very much the Haskell newbie I'd like to see the source! :)
12:21:18 <Berengal> EnglishGent, what happened instead?
12:21:37 <EnglishGent> it fetched a load of .hi files
12:22:05 <EnglishGent> however... I can now do import Data.Digest.MD5 - so *something* must have worked
12:22:07 <EnglishGent> :)
12:22:44 <jethr0> EnglishGent: it most likely HAS fetched the source
12:23:13 <blackh> EnglishGent: The sources are in $HOME/.cabal/packages/hackage.haskell.org/
12:23:27 <jethr0> did you look in ./cabal/packages/hackage.haskell.org/<package name> or whatever you cabal directory is?
12:24:00 <FunctorSalad_> the order of -l flags matters, LOL
12:24:19 <deech> BTW is there a way to get the ":list ..." command in GHCI to print the source of an function coming from a module that was installed with cabal?
12:24:20 <jethr0> yes, at least under windows *argh*
12:24:22 <EnglishGent> yes - that's full of .hi files
12:24:27 <EnglishGent> but no .hs or .lhs
12:24:43 <jethr0> is there a tar.gz. file?
12:25:22 <EnglishGent> doesnt seem to be
12:25:31 <deech> EnglishGent: "~/.cabal/packages/hackage.haskell.org/<package name>/<package version>/" is where my sources are stored.
12:25:33 <Berengal> What package is this?
12:25:33 <jethr0> huh?
12:25:34 <blackh> EnglishGent: The .tar.gz files are definitely there
12:25:39 <etpace_> In the 'finger tree' paper, should I read something along the lines of: `xs reducer f z' as 'reducer f xs z'?
12:25:42 <EnglishGent> I've been using it for all opf about 10 minutes though - so errors are probably mine
12:26:15 <jethr0> EnglishGent: can you tell me the package name?
12:27:03 <EnglishGent> Crypto
12:27:35 <blackh> EnglishGent: On my system - /home/blackh/.cabal/packages/hackage.haskell.org/Crypto/4.2.0/Crypto-4.2.0.tar.gz
12:28:05 <EnglishGent> it's stuck stuff under ~/.cabal/lib.Crypto-4.2.0/ghc-6.8.2
12:28:29 <Berengal> EnglishGent, that's the installed package. Look under packages
12:28:51 <EnglishGent> ah! I see it
12:28:57 <EnglishGent> sorry :)
12:29:33 <EnglishGent> that contains the .tar.gz you mentioned jethr0 & blackh :)
12:29:34 <jethr0> well, at least now i have Crypto installed ;)
12:31:36 <kolmodin> Igloo: http://hackage.haskell.org/trac/ghc/wiki/Platforms -> OperationalError: database is locked
12:31:46 <EnglishGent> @hoogle Char -> Int
12:31:47 <lambdabot> Data.Char digitToInt :: Char -> Int
12:31:47 <lambdabot> Data.Char ord :: Char -> Int
12:31:47 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
12:33:00 <m4ik3ru> Don't know if I thanked jethr0, dschoepe, and byorgey earlier, but you guys are amazing :)
12:33:31 <m4ik3ru> :t concat
12:33:32 <lambdabot> forall a. [[a]] -> [a]
12:33:42 <jethr0> m4ik3ru: wanna continue?
12:33:50 <jethr0> you're very welcome, btw
12:33:59 <m4ik3ru> jethr0: yes please!
12:34:45 <m4ik3ru> back in #haskell-overflow or here?
12:34:49 <EnglishGent> hi m4ik3ru :)
12:34:52 <m4ik3ru> we stopped in the middle of filter
12:34:58 <m4ik3ru> Hi EnglishGent!
12:35:12 <jethr0> in #haskell-overflow again?
12:35:17 <m4ik3ru> sure
12:36:38 <Igloo> kolmodin: Just reload if you see that
12:36:40 <EnglishGent> out of interest - does anyone have any experience with using the Crypto package?
12:36:58 * EnglishGent simply wants to be able to calculate the SHA1 & MD5s of files
12:37:02 <EnglishGent> :)
12:37:10 <wdonnelly> I used it for a simple password manager
12:37:30 <EnglishGent> hi wdonnelly!
12:38:33 <EnglishGent> how do you persuade it to work on String instead of octets streams?
12:38:56 <kolmodin> Igloo: that did the trick! super! thanks
12:39:02 <kolmodin> Igloo: had a good trip home?
12:39:07 <kolmodin> Igloo: I just arrived a few hours ago
12:39:25 <wdonnelly> EnglishGent: give me a second, I still have to find the source code
12:39:31 <EnglishGent> okay - thanks wdonnelly
12:40:51 <wdonnelly> ah, now I remember
12:41:14 <wdonnelly> I used the 'Codec.Binary.UTF8.String' module to encode strings into octets
12:41:47 <EnglishGent> thanks :)
12:42:35 <wdonnelly> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9125
12:43:01 <wdonnelly> that function hashed a string with SHA256, but the signature for SHA1 is even simpler
12:43:21 <EnglishGent> thanks a lot! :)
12:43:26 <wdonnelly> so a 'SHA.hash . UTF.encode' should be all you require
12:43:35 <wdonnelly> and no problem :)
12:43:49 * EnglishGent is now trying to write a simple duplicate-file finder.. as part of his Haskell learning :)
12:44:03 <EnglishGent> hence the desire to calculate file hashes :)
12:44:13 <wdonnelly> sounds fun. good luck
12:45:10 <EnglishGent> thanks!
12:45:21 * EnglishGent will be happy to share the source if/when he succeeds :)
12:45:27 <kmc> wdonnelly, where does shift' come from
12:45:50 <wdonnelly> although if you're operating on files, it might be more efficient / better to use Data.ByteString.readFile directly
12:46:57 <EnglishGent> ah - the only way I know to read files at the moment is readFile
12:47:35 <kmc> EnglishGent, do you know the difference between String and ByteString?
12:47:49 <EnglishGent> I dont suppose you could recommend any docs on file handling in Haskell? I've figured out readFile, getFileStatus & the other stuff from System.Directory, System.Posix & System.FilePath
12:48:19 <EnglishGent> but I dont know about any more sophisticated file operations (e.g. checking file magic numbers, loading images as arrays, etc)
12:48:27 <kmc> EnglishGent, i would read the API documentation in System
12:48:47 <wdonnelly> System.Directory contains most of the interesting file-handling operations
12:49:27 * EnglishGent shall have a look :)
12:49:49 <Vanadium> I do not think there is anything for checking magic numbers and loading images in System.*
12:50:39 <wdonnelly> just to follow up on my previous comment about using ByteStrings, you'll want something akin to "SHA.hash . BS.unpack =<< BS.readFile"
12:50:41 <kmc> ah, if you've already read the System docs then i don't know
12:50:53 <kmc> look for packages on hackage, then
12:51:12 <wdonnelly> that way you avoid issues with treating binary files as unicode
12:57:14 <EnglishGent> that works for simple stuff like finding exact matches (treating binary files as unicode) - eventually I'd like to get clever & start doing things like finding similar-but-not-identical images & so on though
12:57:32 <EnglishGent> and that's going to require managing things at greater levels of abstraction
12:57:39 <EnglishGent> still - one thing at a time!
12:57:54 <EnglishGent> I'm going to focus on exact-match finding for now :)
12:58:16 <wdonnelly> EnglishGent: for fuzzy text matching, see the edit-distance package
12:58:23 <wdonnelly> @where edit-distance
12:58:23 <lambdabot> I know nothing about edit-distance.
12:58:27 <wdonnelly> :(
12:58:35 * wdonnelly thought he knew the command for that
12:58:51 <EnglishGent> thanks again wdonnelly :)
12:58:56 <yitz> @hoogle edit-distance
12:58:57 <lambdabot> package edit-distance
12:58:57 <lambdabot> package editline
12:58:57 <lambdabot> package fckeditor
12:59:15 <wdonnelly> I was trying to remember the command that gives a link to it on hackage
12:59:26 <yitz> @hackage edit-distance
12:59:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/edit-distance
12:59:31 <djahandarie> :P
12:59:35 <yitz> hmm
12:59:50 <EnglishGent> I figure the best way to learn a language is to do a real project in it... I have more ambitious plans longer term - but I have to start somewhere! :)
13:00:45 <wdonnelly> odd. the @hackage isn't listed at http://code.haskell.org/lambdabot/COMMANDS. I guess that'll teach me to trust documentation
13:00:49 <blackh> EnglishGent: I agree - I think that's a great way to learn a language.  Then you have to learn things - you can't pick your problem to suit what you already know.
13:00:57 <yitz> @let hackage = ("http://hackage.haskell.org/package/" ++)
13:00:59 <lambdabot>  Defined.
13:01:00 <djahandarie> Is there a @hayoo?
13:01:11 <yitz> > hackage "edit-distance"
13:01:11 <djahandarie> @hayoo map
13:01:11 <lambdabot> Unknown command, try @list
13:01:12 <lambdabot>   "http://hackage.haskell.org/package/edit-distance"
13:02:03 <yitz> @unlet hackage
13:02:03 <lambdabot>   Parse error
13:02:25 <yitz> @undef hackage
13:02:26 <jorick> @list
13:02:26 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:02:31 <EnglishGent> ah wdonnelly - I've just tried the code you pasted .. and it says "Not in scope: type constructor or class `Word256' & Not in scope: shift'
13:02:46 <yitz> @let hackage = text . ("http://hackage.haskell.org/package/" ++)
13:02:47 <lambdabot>  Defined.
13:02:54 <yitz> > hackage "edit-distance"
13:02:56 <lambdabot>   http://hackage.haskell.org/package/edit-distance
13:06:13 <wdonnelly> EnglishGent: try this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9127
13:06:49 <wdonnelly> the other paste was just a straight copy of the relevant function from an old project
13:18:31 <olsner> why does 'listen' have such a weird type (listen :: m a -> m (a, w))? wouldn't it be cleaner to have it as 'listen :: m w'?
13:19:58 <poe> olsner: what computation would it be listening to?
13:20:18 <iago> olsner, I expect that it is to don't run the computation twice
13:22:44 <olsner> if you do (foo >> listen) I would expect that to give what foo has said (in addition to what was said before foo)
13:23:13 <Berengal> foo >> listen doesn't typecheck
13:23:23 <olsner> but perhaps the point is for "listen foo" to have foo starting out with mempty
13:23:38 <Berengal> I think it is
13:23:44 <olsner> Berengal: with a different type for listen, I mean
13:24:26 <Berengal> It's sort of the dual of local
13:28:10 <olsner> this also (probably) means I can't extract the writer "state" from within my computation
13:31:36 <BMeph> olsner: ou mean, from your version of it, where it throws away the 'a' type? :)
13:31:45 <BMeph> Bah; *You
13:32:11 <olsner> BMeph: no, the last comment was about the currently existing version of listen
13:34:15 <BMeph> olsner: Then I don't understand. The 'currently existing version of listen' doesn't throw anything away, so why wouldn't you be able to 'extract the writer "state"'? :)
13:35:01 <olsner> BMeph: will (foo >> listen bar) also give back what foo said?
13:38:20 <tommd> Salut, Ca'va?
13:40:12 <poe> > runWriter $ do { tell "a"; tell "b"; listen (tell "c") }
13:40:14 <lambdabot>   (((),"c"),"abc")
13:41:11 <BMeph> Thanks, poe. :)
13:41:29 <EnglishGent> hi again (sorry had a rl distraction)
13:42:25 <poe> so it looks like one uses listen to span another "logged" computation without going through another runReader
13:44:09 <medfly> you should be speaking Japanese.
13:46:55 <monochrom> Haha, the Palindrome package completely obsoletes all sorts of "hi I'm a newbie I'm re-inventing palindrome algorithms" :)
13:47:16 <Vanadium> Oh, that is what it is for
13:47:34 <Berengal> monochrom, but what of the rites of passage?
13:47:58 <monochrom> Don't worry, there are still lots of monad tutorials and applicative blogs to write.
13:48:12 <Cale> The functions have dubious types though.
13:48:51 <Berengal> :O
13:48:56 <Berengal> Very dubious
13:49:04 <BMeph> I'll have to see if I can use it to re-do UD codes; maybe that can be the new palindrome. :)
13:51:11 <EnglishGent> someone should do a list of all the various kinds of types with an explanation of them actually... phantom types, wobbly types, existential types... dubious types :)
13:51:41 <EnglishGent> (seriously - the list of types of types is long & rather newbie intimidating I think)
13:55:51 <Berengal> Fixed types, variables types, constrained types, phantom types, existential types, datatypes, newtypes, synonym types, constructor types, classy types, high-ranking types, type types, type families, generalized algebraic datatypes...
13:56:45 <kmc> what's a synonym type
13:56:51 <Berengal> type synonym
13:57:17 <kmc> so a general haskell glossary would be good
13:57:21 <Berengal> I sacrificed correctness for consistency
13:57:33 <Berengal> (getting "type" at the end as much as possible)
13:57:39 <kmc> Berengal, just don't sacrifice completeness :)
13:59:10 <jethr0> correctness is totally overrated, anyway ;)
13:59:38 <jethr0> type oneType = anotherType
13:59:56 <gwern> kmc: the wiki is a haskell glossary!
14:00:15 <kmc> by searching, but not explicitly
14:00:26 <Berengal> We need a haskell bestiary
14:00:28 <jethr0> and a lot of the terms are explained in the wikipedia haskell book. though i don't know to what quality standards and recency
14:00:30 <Berengal> Or monster manual
14:00:40 <jethr0> nooooooooo
14:00:42 <jethr0> ;)
14:01:51 <kmc> JacquedeMolay, thou art avenged!
14:02:13 <kmc> sorry you probably get that a lot
14:03:08 <kmc> so i thought a phantom type was an argument to a tycon not appearing in any of its constructors
14:03:53 <kmc> the wiki is somewhat ambiguous between that, and a type with no constructors
14:04:51 <monochrom> It suffices to have the appropriate pages on the haskell wiki, e.g., there is already http://www.haskell.org/haskellwiki/Existential_type . So just have similar articles for other types.
14:05:01 <RyanT50002> is there a split version of Control.Concurrent.Chan?
14:05:08 <RyanT50002> one with a reading end and a writing end
14:05:13 <Berengal> kmc, it's both, sort of. They're usually the same
14:05:23 <RyanT50002> (or, is there a reason that would be a bad idea?)
14:05:23 <kmc> not at all
14:05:26 <Berengal> Well, not usually, but it's not uncommon
14:05:28 <kmc> but one is used with the other often
14:05:43 <monochrom> Just create two channels.
14:06:23 <RyanT50002> monochrom: no, i mean, i want a single channel
14:06:27 <RyanT50002> which i want to return
14:06:36 <Berengal> RyanT50002, I like to create two channels and instead of passing them around directly, pass around readTChan input/writeTChan output
14:06:40 <RyanT50002> but i don't want the caller to have access to the "write" functionality
14:06:46 <RyanT50002> hm
14:06:50 <monochrom> date OneSingleChannel = ReallyOneSingleChannel Chan Chan
14:07:29 <Berengal> If you only want one-way communication, passing around readTChan chan works just as well
14:08:03 <RyanT50002> Berengal: actually, that brings me to another question: is there a way to wait on multiple Chans at once aside from forking threads?
14:08:15 <Berengal> RyanT50002, orElse
14:08:24 <RyanT50002> Berengal: that's only if i'm using TChans, right?
14:08:28 <Berengal> readTChan chan1 `orElse` readTChan chan2
14:08:34 <RyanT50002> are they just universally preferred over normal Chans now?
14:08:37 <hackagebot> minimung 0.0 - Shows how to run grabber on Mac OS X (YakovZaytsev)
14:10:08 <Berengal> I've always prefered STM for it's theoretical superiority. Not that I've done anything with concurrency except play around
14:10:37 <RyanT50002> well, right now i'm getting messages out of GLUT and into Yampa, so theoretical purity isn't really on the table :P
14:12:58 <MrFahrenheit> according to the docs the GHCi debugger is enabled by default, but I get this error when I try to use it "Cannot find default module for breakpoint. Perhaps no modules are loaded for debugging?"
14:18:41 <jungehexe> jetr0: evening
14:19:53 <erisco> where can I go for collective knowledge about game development in haskell?
14:19:54 <jungehexe> jethr0: evening
14:20:02 <erisco> say I wanted to make pong, or something
14:20:04 <erisco> which I do :)
14:20:22 <dschoepe> erisco: the wiki on haskell.org might be a start.
14:20:51 <EnglishGent> hi erisco :)
14:21:29 <erisco> EnglishGent, hello
14:21:39 <erisco> I do not recognize you
14:22:03 <kmc> erisco, this is a good place for collective knowledge :)
14:22:20 <EnglishGent> I'm just being friendly erisco
14:22:36 <EnglishGent> and I second kmc - I'm a newbie & have found this channel very helpful :)
14:22:38 <dschoepe> erisco: functional reactive programming is term you might be interested in, if you want to write games in a more haskell-ish way.
14:23:09 <erisco> I want to write a game in haskell, especially after seeing something successful such as Frag
14:23:48 <erisco> however, despite looking into information for functional reactive programming, I could not find anything particularly helpful
14:23:55 <kmc> you can also use opengl directly from haskell
14:23:59 <jethr0> jungehexe: hi there
14:24:03 <tommd> @seen
14:24:12 <kmc> the binding is fairly imperative, but haskell is a fine language for imperative programming
14:24:34 <opqdonut> the best, according to some ;)
14:24:51 <RyanT50002> erisco: i've got a project going building a game in haskell right now; we're using Yampa for a lot of stuff
14:24:53 <kmc> iirc it doesn't support things like shader programs well, but i haven't used it in years
14:24:54 <dschoepe> erisco: did you read the tutorial for yampa? http://haskell.org/yampa/AFPLectureNotes.pdf
14:28:44 <erisco> dschoepe, I have seen that document. I scanned over it and determined that it was too much over my head
14:28:57 <erisco> since I haven't touched on any game creation with haskell yet
14:29:04 <MrFahrenheit> how do I enable the debugger in GHCi?
14:29:06 <erisco> but perhaps that is the problem and I should tackle something else first
14:29:18 <kmc> erisco, what have you written in haskell
14:29:31 <erisco> well, I have been mostly through the real world haskell book
14:29:40 <erisco> so, hrm, most notably a graham scan algo
14:29:51 <tommd> erisco: http://hackage.haskell.org/package/breakout
14:29:51 <tommd> erisco: The breakout game was a fairly simple design, iirc.
14:29:58 <tommd> It might be worth looking at.
14:30:13 <erisco> if game development in Haskell as a really high curve to get into, that's okay. I thought it might have been a fun and motivating project to get more familiar with
14:30:43 <hackagebot> idiii 0.0 - ID3v2 tag editing-suite (AlexeyAlekhin)
14:30:54 <Peaker> Baughn: you there?
14:32:24 <kmc> erisco, i'd say there's only a high learning curve if you want to do something like FRP
14:32:38 <erisco> I'd want to do it right
14:33:20 <dschoepe> erisco: well doing it the "normal" way via IO is also right. Just not as elegant in my opinion.
14:33:34 <kmc> imo it's also important to know that style well
14:34:33 <kmc> for example being comfortable defining higher-order imperative control flow features
14:34:38 <kmc> which isn't done in most imperative languages
14:35:34 <Baughn> Peaker: I art.
14:36:19 <Peaker> Baughn: what's going on with Reactive?
14:36:23 <Peaker> Baughn: or your alternative?
14:37:12 <Baughn> Peaker: Nothing much, on both counts
14:37:28 <Baughn> Busy with my thesis, which has nothing to do with FRP, and I haven't heard anything from conal
14:37:42 <Baughn> (I rather suspect he's even busier)
14:37:53 <Baughn> ..hm, I suppose I should at least upload the code I've got laying around on my disk.
14:38:17 <Peaker> Baughn: Conal busy == good sign!
14:38:25 <Peaker> Baughn: Expect brilliant posts on his blog soon :)
14:47:16 <FunctorSalad_> hehehe
14:57:05 <jethr0> i've done a little experimentation with yampa a few years ago (a small pong game).
14:57:32 <jethr0> i got it working finally, but the learning curve was ultimately painful. has that become any easier with reactive or any of the other framework lately?
14:59:26 <blackh> jethr0: reactive has some kind of issue to do with space leakage and it's meant to be a design issue.  I think it isn't being worked on actively at the moment, but don't quote me.
14:59:42 <blackh> I agree that Yampa's learning curve is painful.
14:59:49 <blackh> But it seems to work.
15:00:00 <tommd> Perhaps we should have a Yampa study group.
15:00:01 <blackh> I tried reactive, and sort of got things working, but still had a bit of trouble.
15:00:04 <Saizan> yampa is arrow based, right?
15:00:13 <blackh> Saizan: Yes
15:00:37 <jethr0> blackh: that's exactly my experience. "sort of working, but still some trouble"
15:01:19 <jethr0> i was actually really amazed with yampa and reactive programming, but i had wasted so much energy on stuff like integration and derivation of mouse movements, that i simply quit just when i had gotten the hang of it
15:01:21 <jethr0> too bad
15:02:12 <blackh> I think it takes a while to figure out how to use Yampa.  I ended up extending it a little, partly because I'm not processing every object every frame.
15:03:34 <Saizan> does it do any sort of caching of past values if the inputs didn't change?
15:04:55 <blackh> Not really.
15:05:18 <vyom> is there a haskell library that I can use to get masked input from commandline, for passwords etc?
15:07:57 <kmc> vyom, you can probably do it on UNIX with System.Posix.Terminal
15:08:39 <kmc> (by command line you mean a terminal, right)
15:08:48 <kmc> i don't know of a portable way
15:09:45 <Saizan> print ^h* after each characted?:)
15:09:58 <vyom> kmc:  yes I do mean a terminal.
15:10:20 <yitz> vyom: System.IO.hSetEcho
15:10:40 <yitz> @type System.IO.hSetEcho
15:10:42 <lambdabot> GHC.IOBase.Handle -> Bool -> IO ()
15:10:43 <Polarina> Is there an alternative to "intersperse a x | length x == 1 = head x" without the use of a guard?
15:11:00 <vyom> yitz: thanks, will try that out
15:11:14 <mauke> intersperse _ [x] = x
15:11:30 <Polarina> mauke: Thanks.
15:11:50 <yitz> Saizan: that's a du^h^h interesting idea.
15:12:37 <Vanadium> Should print ^h ^h imo
15:12:46 <Saizan> a
15:13:25 <yitz> @src intersperse
15:13:26 <lambdabot> intersperse _   []     = []
15:13:26 <lambdabot> intersperse _   [x]    = [x]
15:13:26 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
15:14:02 <Polarina> lambdabot: I figured that out already, thanks.
15:14:33 <yitz> @vixen I figured that out already, thanks.
15:14:33 <lambdabot> my pleasure
15:15:33 <medfly> I wonder what happens if my nick is src or something.
15:15:44 <Polarina> lambdabot: And your implementation of "intersperse" is broken.
15:16:00 <tavelram> :)
15:16:17 <yitz> mauke: lambdabot ought to use vixen to respond to msgs that start with "lambdabot:"
15:17:02 <yitz> Polarina: if you actually want her to respond, use "@vixen".
15:17:21 <Polarina> @vixen Your implementation of the function "intersperse" is broken.
15:17:21 <lambdabot> fun fun fun!
15:17:37 <jethr0> @vixen this is a serious issue!
15:17:37 <lambdabot> whatever
15:17:52 <jethr0> @vixen young lady, you better listen to what i have to say
15:17:52 <lambdabot> why do you have to?
15:17:53 <Saizan> broken?
15:18:00 <kmc> @vixen do you have a boyfriend?
15:18:01 <lambdabot> no, lookin to apply for the position?
15:18:15 <lispy> How is it broken?
15:18:30 <lispy> puts a sep at the end?
15:18:50 <lispy> I don't think that will happen because of the two base cases
15:19:18 <medfly> oh, I see.
15:19:50 * Saizan is tempted to prove that implementation correct in agda
15:20:39 * lispy waits for the counter example that demonstrates the breakage
15:22:04 * tavelram thinks Polarina didnt get the bot-fact and that (s)he actually had inconsistent types in the original question, ie a vs [a].
15:26:53 <lispy> :t intersperse
15:26:54 <lambdabot> forall a. a -> [a] -> [a]
15:27:15 <lispy> > intersperse 'a' "monkey"
15:27:16 <lambdabot>   "maoanakaeay"
15:27:19 <tavelram> .... -> a
15:27:20 <tavelram> 20090907 [00:11:44] <Polarina> Is there an alternative to "intersperse a x | length x == 1 = head x" without the use of a guard?
15:27:24 <tavelram> :t head
15:27:25 <lambdabot> forall a. [a] -> a
15:27:25 <ivanm> > intersperse a [b,c,d,e]
15:27:27 <lambdabot>   [b,a,c,a,d,a,e]
15:28:02 <ivanm> well, I would say that using intersperse there is stupid
15:28:15 <lispy> > foldr (+) [a] [b,c,d,e,f]
15:28:16 <lambdabot>   Ambiguous occurrence `f'
15:28:16 <lambdabot>  It could refer to either `L.f', defined at <local...
15:28:17 <ivanm> if length x == 1, doesn't that mean that intersperse a x does nothing?
15:28:24 <lispy> > foldr (+) [a] [b,c,d,e]
15:28:25 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
15:28:29 <ivanm> lol
15:28:30 <lispy> > foldr (+) [a] [b,c,d,e] :: Expr
15:28:31 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
15:28:44 <lispy> > foldr (+) a [b,c,d,e]
15:28:46 <lambdabot>   b + (c + (d + (e + a)))
15:28:58 <ivanm> lispy: I was wondering why you had [a] ...
15:29:06 <lispy> ivanm: yeah, in retrospect, I'm wondering too
15:29:10 <ivanm> heh
15:29:22 <ivanm> 20-20 hindsight vision is wonderful :p
15:29:24 <lispy> I had a dream about foldr recently
15:29:34 <lispy> I'm trying to recall what it was that in my dream I was typing here
15:29:39 <Peaker> did your stack overflow in the dream?
15:29:40 <lispy> I think it used (>>)
15:29:53 <lispy> > foldr (>>) a [b,c,d,e]
15:29:54 <lambdabot>   Couldn't match expected type `m b'
15:29:54 <Peaker> (if you know what I mean)
15:29:59 <Saizan> ?src sequence_
15:29:59 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:30:01 <lispy> Peaker: heeh, no
15:30:15 <lispy> Saizan: yeah, it was with sequence
15:30:20 <Peaker> does Expr have a monad instance?
15:30:26 <lispy> > foldr (>>) (return ()) [a,b,c,d]
15:30:27 <lambdabot>   Couldn't match expected type `m a'
15:30:30 <Cale> It couldn't possibly.
15:30:31 <jeffwheeler> I have a feeling somebody's written something like this before: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9139#a9139
15:30:38 <Peaker> yeah, wrong kind
15:30:40 <jeffwheeler> But I can't seem to find it, and mine's not very efficient.
15:30:44 <lispy> > foldr (>>) (return a) [b,c,d]
15:30:45 <lambdabot>   Couldn't match expected type `m a'
15:30:48 <lispy> ah well
15:31:02 <jeffwheeler> My function just finds duplicate items in a list . . .
15:31:07 <ivanm> lispy: I guess your dream was wrong then...
15:31:08 <Peaker> > sequence_ [return a, return b, return c] :: Maybe ()
15:31:10 <lambdabot>   Just ()
15:31:22 <Peaker> > sequence [return a, return b, return c] :: Maybe [Expr]
15:31:24 <lambdabot>   Just [a,b,c]
15:31:26 <lispy> What I wanted in my dream was to see foldr build the expression
15:32:03 <copumpkin> it can't build expressions like >>
15:32:08 <lispy> jeffwheeler: I don't tihnk I get what dupBy is doing
15:32:38 <lispy> jeffwheeler: dupBy _ (x:[]) = []
15:32:39 <Cale> jeffwheeler: looks like  map last . groupBy (not f)  or something?
15:32:54 <Cale> Er, yeah, that special case is strange...
15:33:01 <lispy> jeffwheeler: what are you doing there?  All singleton lists go te empty?
15:33:07 <Peaker> > ([a], ()) >> ([b], c)
15:33:08 <lambdabot>   No instance for (GHC.Base.Monad ((,) [SimpleReflect.Expr]))
15:33:08 <lambdabot>    arising from...
15:33:19 <Peaker> why isn't that instance in scope?
15:33:39 <jeffwheeler> lispy: yes, because singleton lists contain no duplicates
15:33:50 <jeffwheeler> lispy: I'm trying to include _just_ duplicates in my final list
15:34:10 <jeffwheeler> (although that could have been written better; I haven't used Haskell in about two weeks now)
15:34:18 <lispy> jeffwheeler: so, dup = dupBy (==) ?
15:34:22 <Peaker> @type Data.Map.filter
15:34:24 <lambdabot> forall a k. (Ord k) => (a -> Bool) -> M.Map k a -> M.Map k a
15:34:41 <jeffwheeler> lispy: exactly
15:34:52 <Peaker> Map.keys . Map.filter (>1) . histogram $ someList
15:35:14 <jeffwheeler> Peaker: is that for me?
15:35:21 <yitz> jeffwheeler: so if there is a sequence of 3 duplicates, you want 2 of them?
15:35:29 <Peaker> jeffwheeler: yeah, though histogram doesn't exist :)
15:35:35 <jethr0> uh, i love Map.filter! yummie
15:35:41 <jeffwheeler> yitz: I haven't really decided on that; I guess I'm fine with either behavior
15:35:55 <Cale> > concat . map (drop 1) . group $ "mississippi"
15:35:56 <Peaker> histogram :: (Ord k, Integral i) => [k] -> Map k i
15:35:57 <lambdabot>   "ssp"
15:36:10 <Cale> > concat . map (drop 1) . group $ "aaaabbbccdeee"
15:36:11 <lambdabot>   "aaabbcee"
15:36:16 <jeffwheeler> Cale: that'll work great; thanks
15:36:22 <Cale> > concat . map (take 1) . group $ "aaaabbbccdeee"
15:36:24 <lambdabot>   "abcde"
15:36:28 <yitz> concat . map = concatMap
15:36:31 <Cale> > concat . map (take 1 . drop 1) . group $ "aaaabbbccdeee"
15:36:32 <lambdabot>   "abce"
15:36:44 <Peaker> yitz: (concat.).map
15:37:00 <jeffwheeler> It just groups all the equal ones together, and then deletes the first letter, and combines back again.
15:37:00 <jeffwheeler> Clever.
15:37:01 <lispy> jeffwheeler: you probably want groupBy instead of group
15:37:09 <jeffwheeler> lispy: yeah
15:37:41 <yitz> jeffwheeler: so if you don't care, leaving out the "drop 1" part would make this look really simple.
15:38:31 <lispy> group has some weird semantics if your list is an unordered multiset (as contrasted with being an ordered multiset)
15:38:45 <lispy> > group [1,1,2,1,3]
15:38:47 <lambdabot>   [[1,1],[2],[1],[3]]
15:38:47 <yitz> actually, I like the take 1 . drop 1 version the best
15:39:01 <lispy> > group [1,1,1,2,3]
15:39:03 <lambdabot>   [[1,1,1],[2],[3]]
15:39:15 <lispy> I tend to expect the latter
15:39:23 <jeffwheeler> Fortunately, my incoming list should already be sorted.
15:39:31 <jeffwheeler> I hadn't even considered that in my original example
15:39:52 <Peaker> @pl (\x -> take x . drop x) 1
15:39:52 <lambdabot> take 1 . drop 1
15:39:55 <Peaker> @pl (\x -> take x . drop x)
15:39:55 <lambdabot> liftM2 (.) take drop
15:40:00 <yitz> > groupBy (<) [2,3,4,3,1,2,5]
15:40:01 <Peaker> liftM2 (.) take drop 1
15:40:02 <lambdabot>   [[2,3,4,3],[1,2,5]]
15:40:48 <yitz> that's something else weird about groupBy.
15:41:36 <Peaker> groupBy keeps comparing against the first of the group, not the last encountered from the group?
15:41:43 <yitz> right
15:42:40 <lispy> I think that's undefined behavior technically
15:42:54 <lispy> I want to say that the H98 report says something about the properties of the predicate
15:43:00 <Peaker> The Haskell report is overrated. ghc matters :-)
15:43:21 <yitz> lispy: that implementation is hard-wired into the report, in libraries chapter.
15:43:25 <yitz> the
15:44:25 <lispy> ?src groupBy
15:44:25 <lambdabot> groupBy _  []       =  []
15:44:25 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
15:44:25 <lambdabot>     where (ys,zs) = span (eq x) xs
15:44:52 <lispy> ?src span
15:44:53 <lambdabot> Source not found. :(
15:44:59 <lispy> :t span
15:45:01 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:45:03 <jethr0> on the wiki there is a backward-compatible "better" version
15:46:09 <lispy> > span (==1) [1,1,2,3,1,4]
15:46:10 <lambdabot>   ([1,1],[2,3,1,4])
15:46:14 <Peaker> can HXT be used for incremental processing of infinite XML streams?
15:46:15 <jethr0> http://www.haskell.org/haskellwiki/List_function_suggestions#Generalize_groupBy_and_friends
15:46:39 <jeffwheeler> @pl \(a, b, c) -> a
15:46:40 <lambdabot> (line 1, column 7):
15:46:40 <lambdabot> unexpected ","
15:46:40 <lambdabot> expecting letter or digit, operator or ")"
15:46:40 <lambdabot> ambiguous use of a non associative operator
15:48:55 <jethr0> wut?
15:52:47 * Berengal wonders if a typical haskell installation will ever consist of a compiler, the prelude and cabal
15:53:39 <Berengal> Perhaps even drop the prelude?
15:53:46 <jethr0> hehe, that would be way to easy
15:53:51 <mle> Berengal: cabal has a fair number of dependencies already.
15:54:05 <jethr0> ah, you mean no libs... why not some base libs included?
15:54:27 <Berengal> mle, the binary doesn't, does it?
15:55:13 <jeffwheeler> I'd like to not spend all day trying to libraries to work on Windows.
15:55:33 <Peaker> :t fromIntegral 'a'
15:55:33 <jeffwheeler> It's not Haskell's fault, but install libcurl is a huge pain in the ass. And then it gets worse with other libraries.
15:55:34 <lambdabot>     No instance for (Integral Char)
15:55:35 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:0-15
15:55:35 <lambdabot>     Possible fix: add an instance declaration for (Integral Char)
15:55:48 <Peaker> It would be nice if Char was integral so we didn't need ord/chr, no?
15:56:14 <mauke> 'a' + 'b'
15:56:38 <Peaker> @src Integral
15:56:38 <lambdabot> class  (Real a, Enum a) => Integral a  where
15:56:38 <lambdabot>     quot, rem, div, mod :: a -> a -> a
15:56:38 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
15:56:38 <lambdabot>     toInteger           :: a -> Integer
15:56:45 <Peaker> @src fromIntegral
15:56:45 <lambdabot> fromIntegral = fromInteger . toInteger
15:57:09 <Peaker> @src Enum
15:57:10 <lambdabot> class  Enum a   where
15:57:10 <lambdabot>     succ                     :: a -> a
15:57:10 <lambdabot>     pred                     :: a -> a
15:57:10 <lambdabot>     toEnum                   :: Int -> a
15:57:10 <lambdabot>     fromEnum                 :: a -> Int
15:57:12 <lambdabot> [3 @more lines]
15:57:21 <Peaker> > fromEnum 'a'
15:57:22 <lambdabot>   97
15:57:26 <Peaker> oh, alright
15:57:30 <shikanai> @pl factors_higherOrd n = filter ((0==) . mod n) [1..n]
15:57:30 <lambdabot> factors_higherOrd = ap (filter . ((0 ==) .) . mod) (enumFromTo 1)
15:57:38 <Peaker> Don't need chr/ord
16:00:15 <Peaker> is there a Quickcheck shortcut to check function equality?
16:00:23 <shikanai> @pl prime n = factors n == [1,n]
16:00:23 <lambdabot> prime = liftM2 (==) factors ((1 :) . return)
16:01:56 <shikanai> @pl primes' n = filter prime [2..n]
16:01:57 <lambdabot> primes' = filter prime . enumFromTo 2
16:02:03 <benmachine> if I were calculating factors, the first thing I'd do would be take the prime factors of something
16:02:12 <benmachine> just sayin'
16:03:02 <benmachine> (i.e. defining prime in terms of factors seems backwards to me)
16:03:40 <shikanai> that's homework for ya
16:03:55 <benmachine> hah, okay
16:04:06 <shikanai> :)
16:05:18 <Berengal> benmachine, I do both
16:05:31 <Berengal> I define primes in terms of factors, and factors in terms of primes
16:05:43 <GreatPatham> I have an application that I am thinking of implementing in Haskell.  When the application is started, it would begin by loading a very large amount of data into data structures in RAM (> 10GB).  Once these data structures have been created, they will not change.  I am concerned about garbage collection overhead.  Every now an then (I assume) Haskell will do a garbage collection even on those long-lived structures.  My worry is that m
16:05:43 <GreatPatham> cause the program to "hang" for a noticeable interval.  Multiple cores would be available, if that matters.  Can anyone clue me in on whether Haskell could work in this scenario?  Thanks for your help
16:06:04 <benmachine> GreatPatham: first message ended "My worry is that m"
16:06:18 <GreatPatham> Thanks, I'll post the continuation
16:06:30 <GreatPatham> My worry is that might cause the program to "hang" for a noticeable interval.  Multiple cores would be available, if that matters.  Can anyone clue me in on whether Haskell could work in this scenario?  Thanks for your help
16:06:39 <mle> GreatPatham: you can adjust the number of generations in the gc
16:07:11 <GreatPatham> Thus making it collections less and less likely for longer lived generations?
16:07:26 <mle> yes.  They can still happen, but much less often
16:07:26 <astrolabe> It won't garbage collect till it knows the data won't get used.
16:07:30 <GreatPatham> But, I assume that still means *some* gc on the longest lived?
16:07:53 <Berengal> I believe I read that with >4 generations, it'll almost never happen
16:08:00 <GreatPatham> Right, but it has to analyze to figure out if it needs the data still
16:08:14 <astrolabe> Ah
16:08:18 <GreatPatham> My fear is that on such a large quantity of data that could take a while
16:08:20 <mle> GreatPatham: Also, for constant data of vast size, perhaps other storage types might be appropriate, depending on what you're doing.  mmap()'d storage for example
16:08:48 <GreatPatham> I was thinking about ByteString
16:09:11 <sclv> if you access it through some sort of foreign pointer then it won't get collected, is the idea, i think.
16:09:21 <GreatPatham> That uses foreign pointers, I believe, and it wasn't clear to me how that affects GC
16:09:54 <uzytkownik> Hello. What's the meaning of (| ... |) in arrow notation?
16:10:22 <Berengal> uzytkownik, that's not arrow notation
16:10:29 <GreatPatham> That is actually what I am hoping, that the ByteString is not eligible for GC or that deciding if it is eligible is very low cost.
16:10:55 <uzytkownik> Berengal: What is the meaning anyway?
16:11:39 <uzytkownik> Berengal: And it is defined in chapter 7.10  under fcmd I belive
16:11:49 <uzytkownik> of GHC Manual
16:12:11 <sclv> GreatPatham: a normal bytestring is eligible for gc
16:12:27 <sclv> but if it is a single bytestring, then deciding it is eligible is obviously very simple.
16:12:45 <sclv> for a lazy bytestring, however, the gc will need to check all the chunks.
16:13:22 <sclv> the data contained behind a fpointer is however, not copied, but just left out there.
16:13:41 <sclv> for big static data, the bytestring-mmap package would probably be the easiest way.
16:14:40 <Berengal> uzytkownik, that's not haskell, that's grammar, and I've got no idea what it means
16:15:11 <uzytkownik> Berengal: In 7.10.4 it seems to be used
16:15:11 <GreatPatham> If all it has to do is verify that the ByteString is still needed---Without having to look *inside* the ByteString to see if any pieces of it are free to be gc'd then I don't think there is anything to worry about
16:15:27 <GreatPatham> And that seems plausible
16:15:44 <uzytkownik> Berengal: And in many examples in documentation as well (included arrows package)
16:16:04 <Peaker> GreatPatham: mmap'ing the file instead of copying it all into RAM might be a good idea anyway, no?
16:17:09 <Peaker> GreatPatham: why do you want to copy those 10GB anyway?
16:17:09 <Berengal> uzytkownik, seems you're right. In that case, I simply don't know what they mean
16:17:10 <GreatPatham> Yes, except that the data needs to be transformed into *usable* data forms (at least in part).  Still, you may be right.  It's definitely worth considering
16:17:27 <dm`> Does anyone here have experience using databases from Haskell?  Trying to figure out what is best, Takusen, HaskellDB, HDBC, etc.
16:18:20 <GreatPatham> The 10GB will basically be the backbone of an in-RAM specialized database.  Kept in RAM for the speedup, obviously...
16:21:03 <GreatPatham> I could, of course, load the data off disk lazily as it is needed, but the access pattern for that data would be essentially random, and that is ill-suited to disk operations
16:21:09 <mle> GreatPatham: using mmap as the backing store is nice because then the operating system can load/discard bits of it from physical memory based on your usage patterns and the amount of available physical ram.
16:22:30 <GreatPatham> mle: mmap does have some nice things going for it---It seems it would let me trade raw speed for a smaller memory footprint
16:23:41 <GreatPatham> Right now, my goals lean more toward speed.  I don't mind paying for the RAM
16:24:28 <GreatPatham> But, I really do need to consider mmap.  I might change my mind about things
16:24:42 <Peaker> GreatPatham: let the OS deal with caching
16:24:45 <blackdog> GreatPatham: I think if you have the RAM to spare, the OS will take advantage of it
16:25:03 <blackdog> you'll just get more graceful degradation in low memory environments
16:25:22 <GreatPatham> That's very true
16:25:51 <GreatPatham> Maybe I can combine the approaches
16:26:09 <sclv> dm`: all three are good for different things. depends on your needs and comfort level.
16:26:30 <GreatPatham> Let it load into RAM up to what is available and then let the OS handle swapping if needed.
16:26:30 <sclv> hdbc is the simplest and most general. for certain types of online processing, takusen can be much nicer and more efficient.
16:26:37 <sclv> some people feel more comfortable with its types too.
16:26:57 <sclv> if you're rolling your own data access layer on top, go with hdbc, or if you want to stay simple, go with hdbc or the basic sqlite binding.
16:27:03 <GreatPatham> I'll have to think about it.
16:27:53 <blackh> dm`: Consider Berkeley DB
16:27:53 <GreatPatham> But what I believe I am understanding is that this is an issue that can be successfully dealt with, without having to jump through too many hoops.  Thanks so much for all the input!
16:28:01 <sclv> if you want a very haskelly, well typed, well founded approach, and are willing to pay a bit more in learning upfront, then some folks really like haskelldb.
16:28:22 <Peaker> also, no need to pay for a huge copy at start.. just pay as you read
16:28:22 <Peaker> GreatPatham: why do you need to convert the data structures? Why not use them in their disk form, converting when you use them?
16:28:24 <sclv> (or yes, if you don't need something relational, there are lots of options)
16:28:26 <Peaker> (and discarding the conversion immediately after)
16:28:54 <mle> GreatPatham: if the ram is available, mmap will use it, so it really doesn't sacrifice speed terribly.
16:29:35 <GreatPatham> This database will have some special indexing not available in most database---So, I am leaning toward rolling my own.  And database is really too grandiose a word for what I am talking about.  In-RAM data is more like it
16:29:55 <blackh> GreatPatham: You could consider Berkeley DB
16:31:10 <mwolak> I'm trying to compile some openGL example code from a few places (ie: http://aedion.de/haskell/SmoothRaw.hs and the nehe translations on hackage), and I'm getting type errors where the compiler doesn't seem to want to realize that Size really is Graphics.Rendering.OpenGL.GL.CoordTrans.Size... any ideas?
16:32:28 <GreatPatham> I have some familiarity with it.  And it is pretty nice.  But I didn't mention that I am thinking commercial software.  And, last time I checked, the license for commercial from SleepyCat was more than I wanted to pay.  Maybe things are different now
16:33:08 <Polarina> What's a tail recursion?
16:33:17 <mle> not sure what they're quoting now, for which features.  typically it's been in the 6-figure usd range though.
16:34:06 <blackh> GreatPatham: The licence is BSD style, so you can use it commercially.
16:34:10 <blackh> (I do.)
16:34:48 <blackh> Berkeley DB saves you a lot of engineering and it performs like it's possessed.
16:34:50 <mle> Polarina: recursion where the final value of a function is dependent only on the results of a recursive call, without anything else in the way.  Ostensibly this allows constant stack space use, though things are more complex in lazy-eval situations.
16:35:08 <blackdog> Polarina: It's an optimisation to save stack space
16:35:16 <blackdog> uh, what mle said. :)
16:35:28 <mle> blackh: as long as you are opensource, yes.
16:35:41 <Polarina> mle: Could you rephrase that?
16:35:43 <GreatPatham> Thanks everyone---My daughter is yelling at me to take her to the library.  And that's a trend I want to encourage! ;^)
16:36:11 <blackh> mle: That is not so.
16:36:23 <mle> Polarina: I can try...  what's causing confusion?
16:36:29 <Polarina> mle: The wording.
16:36:34 <blackdog> Polarina: colloquially: when the last thing you do in a function is call yourself (or another function), you don't need all the stack variables that you used in the function.
16:37:01 <blackdog> therefore, it's a safe optimisation to write over them in the next function that you call, because they're out of scope and can't be referred to again
16:37:36 <blackdog> what it means in practice is that you can write recursive functions that operate over large data structures as efficiently as an iterative solution
16:37:42 <Polarina> Ah. So it is when you call yourself over and over and then something else that decides the outcome?
16:38:12 <blackdog> ... not following you
16:38:23 <Polarina> ?
16:38:27 <Lemmih> Random quote: If you want an education, go to the library. If you want to get laid, go to college. If you want neither, go to a technical university.
16:38:41 <mle> Polarina: if you call yourself and immediately return the result, you're tail-recursive.  If you call yourself but filter the result through something else, say + or : or something, then you are not tail recursive.
16:38:47 <blackdog> it doesn't actually change the meaning of a program, just the way it operates on a real computer
16:38:50 <dm`> I've used BerkeleyDB before, but occasionally experienced data corruption.   I consider it good for many things, but also easy to misuse.
16:38:57 <Polarina> mle: What do you mean?
16:39:19 <Polarina> mle: Oh, I got it.
16:39:42 <blackh> dm`: Data corruption happens can happen under certain conditions which are easy to avoid, but figuring that out is not so easy.
16:39:53 <mle> blackh: That may be, but term 3 for the primary license seems to require you make your source code available.  The complete source code for the app.  I could be very wrong about this; licensing is not something I understand well.
16:40:11 <Polarina> mle: Is this a tail recursion? http://codepad.org/AzTZgleZ
16:40:15 <dm`> I'm basically looking to build an application that will be very unlikely to lose data, and very easy for people to maintain.  Performance is a secondary concern.
16:40:34 <blackh> mle: Oh, I am just reading it and it seems that you are right.
16:40:41 <dm`> Using a separate database is a good idea, because even people who don't know haskell can figure out how to maintain, say, a Postgres database.
16:40:55 <dm`> So I'm wondering which of the three (Takusen, HaskellDB,
16:40:55 <mle> Polarina: no; you are passing the results of the recursion to (:), so it is not tail recursive.
16:40:56 <dibblego> Polarina, no, (:) is the last call
16:41:13 <dm`> HDBC) is most likely to be maintained in the future.  Would be a bummer if it stopped working with newer compilers/libraries.
16:41:17 <Polarina> I see.
16:41:37 <Polarina> So that function would clog up my memory on a long list?
16:41:45 <kmc> :t evaluate
16:41:46 <blackdog> tail recursion's always sort of a pain to explain in haskell, because even when you've got it in a form that's tail-recursive in a strict language, there's still the possibility of space leaks on the heap ;/
16:41:47 <lambdabot> Not in scope: `evaluate'
16:42:10 <dm`> it's: a -> IO a
16:42:29 <kmc> what's it do?
16:42:40 <kmc> \x -> x `seq` return x
16:42:43 <kmc> maybe?
16:42:56 <dm`> It throws an exception if the outer layer of the thing you are passes in throws an exception.
16:43:07 <dm`> So evaluate (1 `div` 0) should throw an exception.
16:43:10 <kmc> does it force its argument?
16:43:17 <kmc> "outer layer" meaning WHNF?
16:43:21 <dm`> But evaluate (1 `div` 0, "hello", "world") won't.
16:43:25 <mightybyte> @pl (\f g a -> (f a) >>= g)
16:43:25 <lambdabot> flip . ((>>=) .)
16:43:46 <dm`> I don't really understand what WHNF is, but I think so.
16:44:06 <mightybyte> @pl (\f g a -> g =<< (f a))
16:44:06 <lambdabot> flip ((.) . (=<<))
16:44:40 <mightybyte> @pl (\g f a -> (f a) >>= g)
16:44:40 <lambdabot> flip (flip . ((>>=) .))
16:44:41 <kmc> dm`, WHNF is the outer layer :) it means you have something other than an application as the outermost expression
16:44:54 <mightybyte> @pl (\g f a -> g =<< (f a))
16:44:54 <lambdabot> (.) . (=<<)
16:45:19 <kmc> in particular, WHNF of an algebraic type would be an evaluated constructor (whose fields may still be unevaluated thunks)
16:45:28 <kmc> so pattern matching involves eval to WHNF for this reason
16:45:38 <Polarina> Does anyone have an example of a tail recursion in Haskell? Newbie friendly, please.
16:45:45 <mightybyte> @pl (\f a g -> (f a) >>= g)
16:45:45 <lambdabot> ((>>=) .)
16:45:50 <mauke> f x = f x
16:45:53 <dm`> kmc: So (a, b) is not application of the (,) function?
16:45:58 <orbitz> are asynchronous exceptions used for communication or preempting the actions of a thread?
16:46:03 <kmc> dm`, (,) is a constructor
16:46:30 <dm`> kmc: I see, so the difference is between constructors and functions.  I thought constructors had to start with ":".  But '," is acceptable, too?
16:46:39 <Polarina> Oh, found one. Thanks.
16:46:46 <benmachine> dm`: (,) is a special case
16:47:03 <dm`> (,,) too, presumably?
16:47:06 <benmachine> it is in the syntax
16:47:20 <benmachine> yeah, all the tuples
16:48:12 <Beelsebob> "all" is a bit of a stretch of the imagination
16:48:17 <Beelsebob> but certainly more than you'll ever need
16:48:31 <kmc> :t (,,,,,,,,)
16:48:32 <lambdabot> forall a b c d e f g h i. a -> b -> c -> d -> e -> f -> g -> h -> i -> (a, b, c, d, e, f, g, h, i)
16:48:34 <Beelsebob> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
16:48:35 <kmc> :t (,,,,,,,,,,,,,,,,)
16:48:35 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
16:48:36 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109
16:48:36 <lambdabot> t110 t111 t112 t113 t114 t115 t116 t117 t118 t119 t120 t121 t122 t123 t124 t125 t126 t127 t128 t129 t130 t131 t132 t133 t134 t135 t136 t137 t138 t139 t140 t141 t142 t143 t144 t145 t146 t147 t148
16:48:36 <lambdabot> t149 t150 t151 t152 t153 t154 t155 t156 t157 t158 t159 t160 t161 t162 t163 t164 t165 t166 t167. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -
16:48:38 <lambdabot> > v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52
16:48:38 <kmc> oh no
16:48:41 <lambdabot> [9 @more lines]
16:48:43 <lambdabot> forall a b c d e f g h i j k l m n o p q. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
16:48:43 <Beelsebob> oh, didn't expect that to work
16:48:44 <Beelsebob> o.O
16:49:09 <mle> @botsnack
16:49:10 <lunabot>  :o
16:49:10 <lambdabot> :)
16:50:26 <mwolak> Couldn't match expected type `OpenGL-2.2.1.1:Graphics.Rendering.OpenGL.GL.CoordTrans.Size' against inferred type `Graphics.Rendering.OpenGL.GL.CoordTrans.Size' <-- Is there some way to fix this sort of thing?
16:50:28 <dm`> GHC.Tuple
16:51:36 <benmachine> mwolak: at a blind guess I'd say something needs recompiling
16:52:17 <orbitz> How do exceptions fit into the pure functional model? it seems impure in my beginner understandign
16:52:29 <mauke> :t catch
16:52:31 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
16:53:03 <mauke> orbitz: in some sense Maybe gives you exceptions
16:53:37 <mle> mwolak: do you have multiple copies of OpenGL at different versions in use by different modules?
16:53:37 <dm`> I've found out how to put "documentation: True" in my ~/.cabal/config file, but is there a way to make "cabal install package" include the "--hyperlink-source" argument to haddock, so I get sources as well as docs installed?
16:53:54 <mle> mwolak: check with ghc-pkg list and maybe hide one and rebuild?
16:59:07 <mwolak> mle: I don't think so, but I may have botched the openGL installation
16:59:07 <orbitz> mauke: i would thing 'Either' is closer to exceptions than Maybe
16:59:07 <mauke> true
16:59:07 <orbitz> but neither of those preempt what is happening until they hit a catch
16:59:07 <mauke> Maybe only has one "exception", Nothing
16:59:07 <mauke> orbitz: they do if you use monadic operations
16:59:07 <orbitz> tru dat
16:59:07 <mwolak> mle: Ah, found it, there's a system install and a user install of openGL... thanks
16:59:07 <mauke> do { x <- a; y <- b; return (x + y) }
16:59:07 <benmachine> the way to fit exceptions into pure code is to put an IO in there somewhere
16:59:07 <benmachine> and then everything is fine
16:59:07 <orbitz> mauke: so with a syncrhonous exceptions you can have other threads giving exceptions to a current thread right
16:59:07 <mauke> orbitz: I thought that was asynchronous exceptions
16:59:07 <kmc> Polarina, here's the classic example, maybe the one you found: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9142#a9142
16:59:07 <orbitz> mauke: oh, i hadd a space by accident
16:59:07 <mauke> ah
16:59:07 <mauke> yes
16:59:07 <orbitz> so basically
16:59:07 <orbitz> Threading in Haskell > Erlang
16:59:07 <kmc> err, fixed a typo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9142#a9143
16:59:07 <mle> benmachine: wouldn't Control.Exception be nicer?  you can throw from pure but catch in IO...
16:59:07 <benmachine> mle: that is not ruled out by my approach
16:59:07 <benmachine> depending on your definition of somewhere
16:59:07 <dm`> This paper helped my understand exceptions: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.8720
16:59:07 <mle> heh, okay.  I've not done much work with that yet.
16:59:45 <dm`> The point is that catching is non-deterministic, because there could be a whole set of exceptions associated with a particular value, and there is no well defined order for them.
16:59:53 <dm`> So that has to be in the IO monad.
17:00:52 * blackdog sings "Two unsafes in a line, i bet you think that's pretty special, dooooon't you boy...."
17:01:57 <dm`> But "unsafe" is meaningless.  After all, "inlinePerformIO" doesn't even contain the word "unsafe", but it's probably one of the most dangerous functions in all of haskell.
17:02:30 <blackdog> dm`: true enough. I'm still pretty sure I'm doing this the ugliest way possible
17:04:23 <Polarina> kmc: I don't think the sum_tail function is correct.
17:06:45 <Polarina> kmc: Would it also be tail recursive if I've used foldl?
17:07:12 <dibblego> foldl is itself tail recursive
17:07:17 <kmc> @src foldl
17:07:17 <lambdabot> foldl f z []     = z
17:07:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:07:17 <Polarina> :)
17:07:49 <kmc> Polarina, what's wrong with it?
17:08:02 <Polarina> kmc: Where are you passing the list to helper?
17:08:12 <kmc> Polarina, helper is partially applied
17:08:18 <kmc> sum_tail = helper 0
17:08:19 <Polarina> kmc: ?
17:08:21 <kmc> sum_tail xs = helper 0 xs
17:08:25 <kmc> these are equivalent
17:08:36 <Polarina> How so?
17:08:38 <kmc> Polarina, you know about currying?
17:08:45 <Polarina> kmc: What's currying?
17:08:51 <mauke> because f x = ... is syntactic sugar for f = \x -> ...
17:09:04 <Polarina> \x?
17:09:08 <kmc> Polarina, the type Int -> [Int] -> Int means Int -> ([Int] -> Int)
17:09:15 <mauke> Polarina: that's how you write functions
17:09:18 <Polarina> I don't get it...
17:09:19 <mle> Polarina: in haskell, if you give a function fewer arguments than it may accept, the result is another function that accepts those final arguments and applies them...
17:09:29 <kmc> a function that takes two arguments is a function that takes the first argument, and *returns* a function, that takes the next argument
17:09:30 <Polarina> ?
17:09:53 <kmc> so, "helper 0" is a function waiting for the second argument to helper
17:10:02 <kmc> and sum_tail is the same type as that waiting function
17:10:05 <Polarina> ?
17:10:08 <kmc> which we call a "partially applied" helper
17:10:13 <kmc> uh, what don't you understand
17:10:18 <Polarina> Everything.
17:10:19 <kmc> sorry, but '?' is not very helpful
17:10:29 <Peaker> Polarina: do you understand (a -> b -> c) notation?
17:10:37 <mle> so if you have say, foo a b c = a+b*c, foo is type Int -> Int -> Int -> Int, potentially.  foo 1 2 is type Int -> Int; meaning you could make a function bar = foo 1 2, and then use bar 3 later...
17:10:42 <Polarina> Peaker: Yes.
17:11:01 <Peaker> Polarina: Then you also understand what happens when you only give a value of type "a" to (a -> b -> c) ?
17:11:01 <Cale> > let add x y = x + y; increment = add 1 in increment 5
17:11:03 <lambdabot>   6
17:11:06 <Polarina> mle: I don't get it.
17:11:11 <kmc> Polarina, are you familiar with the idea that functions can take functions as arguments and/or return functions as a result?
17:11:18 <Polarina> Peaker: No.
17:11:27 <Polarina> kmc: Yes.
17:11:29 <Peaker> Polarina: well, what does (a -> b -> c) represent?
17:11:33 <kmc> (a -> b -> c) is (a -> (b -> c))
17:11:41 <mle> Polarina: in my example, are you comfortable with what \x -> foo 1 2 x would mean?
17:11:48 <Polarina> Peaker: takes in a and b as arguments and returns c.
17:11:50 <kmc> that's just how the "->" type-operator associates
17:11:53 <Polarina> mle: No.
17:11:55 <Cale> Polarina: If you have a function which takes 2 arguments, you can always treat it as a function with only one argument which gives another function as the result.
17:12:20 <mle> Polarina: think of it like this... the last args are always optional
17:12:25 <Cale> Polarina: All functions in Haskell really only have one argument, and those which seem to have more are really just giving other functions as the result.
17:12:26 <Polarina> Cale: And what does that other function do?
17:12:35 <mle> for each last arg you don't specify, you get a function that asks for that arg later.
17:12:38 <Cale> Polarina: Take the next argument and produce the result.
17:12:54 <Polarina> I see.
17:13:00 <mauke> > (+) 2 3
17:13:01 <lambdabot>   5
17:13:08 <Polarina> And what use is that?
17:13:08 <mauke> > let f = (+) 2 in  f 3
17:13:10 <lambdabot>   5
17:13:15 <mauke> simplicity
17:13:20 <Polarina> ...
17:13:20 <Petrosian> It might be worth also noting that `f 1 2' is really `(f 1) 2'
17:13:21 <kmc> Polarina, you already saw a use in my example
17:13:29 <kmc> which is how we got here
17:13:33 <Petrosian> That is, application is left associative
17:13:37 <mauke> > ((+) 2) 3
17:13:38 <Cale> Also, when working with higher-order functions, it's convenient to apply functions only to some of their arguments to get another function
17:13:38 <lambdabot>   5
17:13:44 <kmc> it's nice to define specializations of functions without passing and re-passing the same arguments
17:13:49 <Polarina> kmc: I don't see a use for it in your example.
17:13:53 <Cale> > map (map (*2)) [[1,2,3],[4,5,6]]
17:13:54 <lambdabot>   [[2,4,6],[8,10,12]]
17:13:58 <kmc> sum_tail = helper 0
17:14:07 <kmc> sum_tail is the special case of helper where the first arg is fixed to 0
17:14:15 <kmc> we don't need to say anything more, like how many additional args helper takes
17:14:18 <Cale> Polarina: See how that works well with map?
17:14:36 <Polarina> Cale: What is *2?
17:14:37 <kmc> > let my_sum = foldr (+) 0 in my_sum [1,2,3]
17:14:39 <lambdabot>   6
17:14:47 <Cale> Polarina: The function which multiplies its argument by 2
17:14:50 <kmc> Polarina, (*2) is \x -> x*2
17:15:01 <Peaker> Polarina: \x -
17:15:03 <Peaker> oops
17:15:03 <Polarina> What is this "\x" you keep using?
17:15:09 <mle> \ is lambda
17:15:10 <kmc> Polarina, a lambda expression
17:15:14 <Peaker> Polarina: \x -> x*2   means: a function that takes x as arg, and returns x*2
17:15:15 <kmc> introduces an anonymous function
17:15:17 <Polarina> What is a lambda?
17:15:17 <mle> \ args -> value
17:15:26 <Cale> For example...
17:15:26 <mle> lambda is an operator creating an anonymous function
17:15:33 <Cale> > (\x -> x^2) 5
17:15:35 <lambdabot>   25
17:15:35 <Polarina> mle: ?
17:15:49 <Cale> (\x -> x^2) is the function which given x, produces x^2
17:15:49 <kmc> Polarina, "f x = 3" is sugar for "f = \x -> 3"
17:15:59 <mle> so \x -> x*2 is like let foo x = x*2 ... and returning foo itself, the function, as a value.
17:16:08 <Polarina> kmc: I don't see how that works.
17:16:12 <kmc> :t let foo x = x*2 in foo
17:16:13 <lambdabot> forall a. (Num a) => a -> a
17:16:25 <kmc> Polarina, the expression "\x -> 3" evaluates to a function
17:16:34 <kmc> the behavior of that function is to take an argument and return 3
17:16:51 <Cale> > map (\x -> x + 2) [1,2,3,4,5]
17:16:52 <lambdabot>   [3,4,5,6,7]
17:17:26 <kmc> likewise Cale's "(\x -> x + 2)" is an expression which evaluates to a function, taking an argument, and returning that argument plus two
17:17:33 <kmc> we don't need to give a name to this function, so we don't
17:17:52 <Cale> > let plusTwo x = x + 2 in map plusTwo [1,2,3,4,5]
17:17:54 <lambdabot>   [3,4,5,6,7]
17:17:56 <kmc> and "(+2)" is just simpler syntax for the same
17:18:03 <kmc> making the "hole" implicit
17:18:04 <Polarina> I see.
17:18:17 <purplepenguins> @pl \x -> x + 2
17:18:17 <lambdabot> (2 +)
17:18:49 <kmc> > let plusTwo = \x -> x + 2 in map plusTwo [1,2,3,4,5]
17:18:50 <lambdabot>   [3,4,5,6,7]
17:18:58 <kmc> > map (\x -> x + 2) [1,2,3,4,5]
17:18:59 <lambdabot>   [3,4,5,6,7]
17:19:04 <kmc> > map (+ 2) [1,2,3,4,5]
17:19:05 <lambdabot>   [3,4,5,6,7]
17:19:15 <Peaker> > [3,4,5,6,7]
17:19:16 <lambdabot>   [3,4,5,6,7]
17:19:20 <Peaker> > [3..7]
17:19:21 <lambdabot>   [3,4,5,6,7]
17:19:26 <Polarina> > let plusTwo x = x + 2 in map plusTwo [1..5]
17:19:27 <lambdabot>   [3,4,5,6,7]
17:19:44 <Polarina> How does it know "x" is the first argument?
17:19:58 <Peaker> Polarina: its the first word after the function name
17:20:21 <Polarina> Peaker: No in "let plusTwo = \x -> x + 2 in map plusTwo [1,2,3,4,5]" I mean.
17:20:36 <Peaker> Polarina: plusTwo is a function of just 1 argument
17:20:41 <purplepenguins> @pl \x -> x
17:20:41 <lambdabot> id
17:20:53 <Polarina> Peaker: How does it know that?
17:21:02 <kmc> Polarina, you tell it what the args are, immediately after \
17:21:03 <purplepenguins> @pl \(x,y) -> (y,x)
17:21:04 <lambdabot> uncurry (flip (,))
17:21:13 <kmc> \args -> body
17:21:16 <mle> Polarina: everything betwee \ and -> is an argument
17:21:18 <Cale> > (\x y -> x^2 + y^2) 3 4
17:21:20 <lambdabot>   25
17:21:27 <Polarina> mle: Ah.
17:21:39 <Polarina> I still don't see how that works in kmc's example.
17:21:45 <Cale> > 3^2 + 4^2
17:21:46 <lambdabot>   25
17:21:53 <kmc> in sum_tail?
17:21:57 <Polarina> kmc: Yes.
17:22:12 <kmc> Polarina, do you understand the definition of "helper" first of all?
17:22:19 <Cale> What's the original question?
17:22:20 <Polarina> kmc: Yes.
17:22:29 <kmc> Polarina, what's the type of helper?
17:22:37 <Polarina> kmc: Int -> [Int] -> Int
17:22:42 <purplepenguins> @pl \(x,y,z,a,b,c) -> (a,b,c,y,z,x)
17:22:42 <lambdabot> (line 1, column 6):
17:22:42 <lambdabot> unexpected ","
17:22:42 <lambdabot> expecting letter or digit, operator or ")"
17:22:42 <lambdabot> ambiguous use of a non associative operator
17:22:46 <kmc> so what's the type of "helper 0"
17:22:55 <Polarina> kmc: I don't know.
17:23:19 <purplepenguins> hmm, i guess i fooled @pl
17:23:23 <kmc> Polarina, can you rewrite (Int -> [Int] -> Int) to make it clear which "->" is "outermost"
17:23:29 <kmc> using parentheses to group them
17:23:36 <Polarina> kmc: Eh?
17:23:49 <kmc> Polarina, a -> b means "function that takes a and returns b"
17:23:53 <Cale> Polarina: (a -> b -> c) means the same as (a -> (b -> c))
17:23:57 <Polarina> kmc: I know that.
17:24:04 <Polarina> Cale: ?
17:24:04 <Peaker> Polarina: (\x y -> x^2 + y^2)  really is (or becomes): (\x -> (\y -> x^2 + y^2))     so if you apply it to just one arg, x is assigned that value, and you get a (\y -> the_arg^2 + y^2).      So helper = (\x -> (\y -> ....))       so helper 0 is   (\y -> ....) where x's inside are replaced by 0
17:24:07 <kmc> so what does (Int -> [Int] -> Int) takes and return
17:24:12 <kmc> remember, only one answer for each
17:24:14 <Cale> Polarina: -> associates to the right
17:24:27 <purplepenguins> thanks to the niceties of partially applied functions and currying, (a -> (b -> c)) is the same as ((a -> b) -> c) is the same as (a -> b -> c)
17:24:27 <Polarina> Cale: I don't get it.
17:24:43 <Polarina> kmc: It takes Int and [Int] and gives Int.
17:24:48 <Cale> purplepenguins: no.
17:24:50 <Peaker> purplepenguins: its not the same as (a->b) -> c
17:24:54 <purplepenguins> it isn't?
17:24:56 <Cale> purplepenguins: (a -> b) -> c is very different
17:25:10 <purplepenguins> hmm, you are right that would be a different beast
17:25:17 <Peaker> purplepenguins: no, (a->b) -> c   is a function that *takes* a function as an argument, whereas a -> (b->c) is a function that returns a function as a result
17:25:22 <kmc> Polarina, no it takes only one argument
17:25:25 <kmc> by definition
17:25:31 <kmc> every function in haskell takes exactly one argument.
17:25:32 <Polarina> kmc: No, it takes two.
17:25:39 <Polarina> kmc: ?
17:25:42 <Cale> Polarina: When you write f x y z, it means ((f x) y) z
17:25:52 <kmc> Polarina, it's a function that returns a function
17:25:52 <Peaker> Polarina: A function takes just 1 argument, always.  Taking 2 args is "emulated" by taking 1, returning a function that will take the next one
17:25:59 <purplepenguins> it's associative only one way
17:26:04 <Polarina> Cale: Oh.
17:26:24 <kmc> Polarina, so what is the type of the single argument to helper
17:26:25 <Cale> Polarina: All functions take exactly one argument.
17:26:27 <kmc> and what is its return type
17:26:31 <Cale> Polarina: (really)
17:26:53 <Cale> Polarina: But the illusion that some take more is created by having some functions produce other functions as their result.
17:27:03 <Polarina> kmc: It takes Int and gives ([Int] -> Int).
17:27:09 <Cale> Polarina: right!
17:27:12 <kmc> yes
17:27:17 <kmc> so now, what's the type of "helper 0"
17:28:02 <Polarina> kmc: The type of "helper 0" is [Int] -> Int
17:28:10 <kmc> which is also the type we want for sum_tail
17:28:17 <kmc> so it's valid to use "helper 0" as the definition for sum_tail
17:28:23 <Polarina> I see.
17:28:42 <Polarina> But would it be equivalent to say "sum_tail xs = helper 0 xs"?
17:28:46 <kmc> yes
17:28:47 <Cale> Polarina: right
17:28:57 <Polarina> Ah. That explains everything. :D
17:29:29 <srush> where is the best place to put unit tests in a haskell package
17:30:01 <kmc> Polarina, we tend to prefer not giving the extra arguments like "xs" there
17:30:06 <srush> should I just throw them top level or is there a way to put it in the .cabal
17:30:13 <Polarina> kmc: Why not?
17:30:30 <Cale> Polarina: because it adds nothing.
17:30:39 <Polarina> Ok.
17:30:49 <kmc> it's more concise, easier to read, and allows you to specify the beginning of a function's argument list without caring about what goes next
17:30:51 <Cale> Polarina: It's like how you'd simplify an equation in mathematics if both sides were multiplied by 2 or something.
17:30:54 <mle> Polarina: if you're defining it, it doesn't make much difference, but consider the case of using it in map
17:31:16 <mle> Polarina: with the extra args, you have (\xs -> helper 0 xs) instead of just (helper 0)
17:32:37 <Polarina> I understand now.
17:32:43 <kmc> cool :)
17:32:47 <Polarina> Everything's a lot clearer to me now. :D
17:33:57 <blackdog> srush: there isn't a clear default yet.
17:34:14 <blackdog> srush: i package mine with TBC, but i'm a bit biased, i wrote some of it :)
17:34:56 <srush> yeah, there are a lot of frameworks
17:35:46 <blackdog> srush: the problem is that the cabal test hooks are a bit anaemic
17:36:18 <dcoutts_> the cabal test hook is almost completely useless
17:36:41 <srush> does TBC have any examples?
17:36:56 <srush> the docs on hackage are down
17:36:57 <blackdog> Yeah, there's a sample app in the distribution
17:37:38 <blackdog> cabal unpack it and have a look
17:38:00 <srush> ouch cabal 1.7
17:38:09 <srush> k, checking it out
17:38:20 <blackdog> srush: i should ask pete why we needed that
17:38:30 <blackdog> we might be able to back it out
17:39:32 <srush> ok, one more unit test question
17:39:42 <srush> is there a good way to do whitebox testing
17:39:56 <srush> so have tests within the module that test unexposed properties
17:40:10 <blackdog> hm, that's a good question
17:40:25 <blackdog> i think the standard way is to have a module that re-exports all the public stuff
17:40:36 <blackdog> and have your tests import the internal implementation module
17:40:48 <srush> oh interesting
17:41:06 <blackdog> when i have time i'll add an example to TBC just to check it works out of the box
17:41:47 <srush> any one know of a bigger project with good testing implemented?
17:42:07 <srush> I'd love to just poke around and see it done correctly
17:42:50 <blackdog> xmonad's pretty thoroughly tested
17:43:19 <blackdog> would be a good place to start.
17:43:51 <srush> great, thanks a lot blackdog
17:52:44 <blackdog> dcoutts: :) yeah, you're not wrong. not enough hours in the day, hey.
17:54:07 <drdr> anyone know if there is a really small haskell compiler/command line shell
17:54:24 <drdr> beacuse GHC is too big for my tastes
17:54:31 <kmc> drdr, what about Hugs
17:55:13 <drdr> havent seen taht one
17:55:14 <mle> drdr: http://haskell.org/haskellwiki/Implementations ?
17:55:24 <blackdog> drdr: jhc? depends how complete you need it to be
17:55:30 <Cale> drdr: There's nothing that really competes with GHC in terms of practicality though.
17:55:32 <blackdog> ghc is big for a reason...
17:55:43 <drdr> ide like it to have most of the funcunailty
17:56:08 <kmc> ghc is much bigger than a complete, correct H98 implementation need be
17:56:11 <kmc> because it aspires to much more
17:56:49 <drdr> ah
17:56:51 <purplepenguins> when will they release a new standard for haskell that includes some of those fancy extensions
17:57:01 <drdr> well i cant do a 100mb+ one
17:57:04 <dolio> If you're just interested in H98, you could use nhc98, perhaps. I've never used it, though.
17:57:14 <dolio> I assume it's smaller than GHC.
17:57:30 <kmc> yhc is the successor to nhc98 in'nit?
17:57:37 <blackdog> drdr: you don't have 100mb space? or it's just an aesthetic position on bloated software?
17:58:26 <dolio> Yeah, but I'm not sure how stable YHC is, since it's had a lot changed, and I don't remember if it's had a "stable" release at all.
17:59:06 <dolio> nhc98 is, like, complete. It hasn't changed in two years.
17:59:11 <Lemmih> YHC has been abandoned, iirc. That's as "stable" as you get.
17:59:18 <kmc> haha
17:59:32 <mle> if it breaks, you get to keep both pieces?
17:59:51 <Cale> 100mb is small enough these days that I probably wouldn't even notice if 100mb was shaved off the total size of my disk...
18:00:05 <dm``> As a relatively new haskell user, I must say the whole extensions thing is a bit weird, because it's hard to program without them (Control.Exception now requires it, for instance), but I don't have a good sense for which extensions are likely to be here in the long run, vs. which are not.
18:00:05 <kmc> Cale, run Windows and you can find out
18:00:07 <kmc> many times over
18:00:27 <mle> drdr: ghc produces reasonably small output... are you working with a self-hosting embedded environment or something strange?
18:00:29 <kmc> dm``, the ones that you can't program without, and are used throughout the standard libraries, will be here in the long run
18:00:32 <Cale> kmc: how?
18:00:40 <kmc> or they will be replaced better and the standard libraries updated
18:01:18 <blackh> dm`: The official answer to that question can be found in the docs to do with Haskell' (the new standard) but things are moving slowly in Haskell' land.
18:02:06 <thoughtpolice> well, certain extensions are pretty indispensible, and are guaranteed into the next standard, i.e. MPTCs and existential quantification
18:02:22 <kmc> remember, even hierarchical module names are an extension
18:02:29 <kmc> so in H98 you won't have Control.Exception to worry about ;)
18:03:14 <dm``> Also, I wonder about the safety of some extensions.  "cast" is supposedly safe, but if I manually define my own TypeOf method (instead of automatically deriving Typeable), can't I get the system to do some very unsafe things?
18:03:29 <kmc> yes
18:03:36 <dm``> @src cast
18:03:37 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:03:40 <copumpkin> thoughtpolice: you're alive!
18:03:49 <kmc> cast is implemented with unsafeCast, and uses typeOf to ensure safety
18:04:35 <Cale> dm``: You can.
18:04:35 <kmc> it'd be nice to have an option to forbid user-defined Typeable instances
18:04:59 <Cale> s/to have an option//
18:05:23 <kmc> Cale, fine, make it default, but I still want -XNoReallyIKnowWhatImDoing
18:05:24 <dm``> I guess I should look into Haskell' to see what is happening.  My dream would be that in the new language, it is 100% impossible to write unsafe code without actually using the characters "unsafe" in some identifier that can easily be searched for...
18:05:38 <dm``> My nightmare would be that it's no longer possible to ensure code is safe.
18:05:40 <Cale> kmc: Have you ever really needed to write your own instance of Typeable?
18:06:06 <kmc> no, but someone cleverer than I will think of a reason
18:06:19 <kmc> have you ever really needed a type with no constructors?
18:06:22 <dolio> There's only one reason to do that, and it's that whoever wrote some other library didn't write "deriving (Typeable)".
18:06:24 <kmc> ...well, we have now
18:06:32 <dm``> One annoying thing is that you can't derive Typeable unless everyithing in your type is also Typeable.
18:07:03 <kmc> dm``, because it needs to give types for ctors?
18:07:03 <dm``> It might be cool to create a wrapper around an untypeable type that is actually Typeable.  But since the typerep stuff is private anyway, I don't think you can do that.
18:07:10 <kmc> standalone deriving can help there thought
18:07:11 <kmc> though*
18:07:17 <dolio> Right.
18:07:41 <kmc> i wouldn't look at Typeable as the biggest culprit for safety problems
18:08:00 <dm``> Yes, but say I have a very simple example.  newtype Foo = Foo Integer.  And now I want to newtype Bar = Bar Foo, where even though Foo is not Typeable Bar is.
18:08:08 <blackdog> haskell's almost feeling like perl at the moment - i'm importing Control.Monad, Control.Applicative, blah blah blah into every file
18:08:13 <kmc> fact is that many essential libraries use unsafePerformIO and friends to provide an interface which they know is referentially transparent and typesafe
18:08:17 <blackdog> like use strict;use warnings;
18:08:32 <dolio> Why isn't Foo Typeable?
18:08:52 <dm``> Because I didn't define Foo as deriving Typeable.
18:08:55 <kmc> and while those library authors take on a burden of responsibility, it's important that we continue to let them do so
18:09:01 <kmc> dm``, then derive it now
18:09:06 <kmc> using ghc's standalone deriving feature
18:09:08 <dm``> Using StandaloneDeriving
18:09:17 <dm``> That's another security issue for me.
18:09:27 <dm``> I'm admittedly doing something a bit odd, namely information flow control in haskell.
18:10:00 <dm``> But I can't have untrusted code deriving instances for my types, or it can violate my security guarantees.
18:10:57 <kmc> dm``, fair enough, but the flexibility matters to other users. perhaps what we need is a way to export a typeclass without exporting its "dictionary constructor", thus making it closed
18:11:15 <kmc> which you can do with a first-class polymorphic record-of-methods
18:11:56 <dm``> Sure, anyway, I certainly don't want these kinds of things to be disabled.  I just would like to make their use glaringly obvious in the syntax of programs.
18:12:37 <kmc> dm``, well "deriving instance" is pretty glaringly obvious
18:12:55 <kmc> and it's an extension you can disable when your trusted-compilation wrapper calls ghc
18:12:56 <dm``> unsafePerformIO is exactly the kind of funciton I like, because I can grep your code and see that you aren't calling it, yet it can also be used safely by trusted libraries.
18:13:03 <kmc> though... are you verifying all of GHC's codebase?
18:13:15 <dm``> Certainly not.
18:13:52 <igotGTA> ;l
18:13:59 <dm``> I'm not going for suer-high-assurance software, but rather ease of extensibility.  For example, a web site where people can upload their own code to do qeuries on a database.  Got to make sure that code doesn't do anything unexpected.
18:14:05 <igotGTA> does anyone have few to explain something regarding lists
18:14:18 <kmc> dm``, look at the lambdabot codebase then
18:14:31 <kmc> igotGTA, sure
18:14:34 <dm``> Yup, I did.  That was very useful.
18:14:45 <dm``> Their wiki page lists attacks and such, too.
18:14:45 <srush> is there a good way to have a quickcheck property on all instance of a type class
18:14:55 <igotGTA> is there pm on here kmc or i can do it here
18:15:10 <kmc> dm``, i'm actually not familiar; what are the best tricks? i can think of the obvious like forbidding IO type and not importing unsafePerformIO
18:15:11 <srush> like, say I want to check that a bunch of instances are associative
18:15:11 <mauke> igotGTA: hint: just asking your question is a much better idea
18:15:25 <kmc> igotGTA, we tend to help people in-chan so others can chime in, and so lambdabot is available
18:15:29 <kmc> but pm is also fine if you prefer
18:15:33 <mauke> don't ask if anyone knows or wants or whatever, just ask your question
18:15:40 <igotGTA> ok cool
18:15:54 <igotGTA> i am just confused on how to return list in the function
18:16:00 <igotGTA> i am completely new to haskell
18:16:10 <mauke> what do you mean?
18:16:11 <kmc> igotGTA, you want an example of a function returning a list?
18:16:23 <kmc> > let threeOf x = [x, x, x] in threeOf 5
18:16:23 <Twey> > let f x = [x, x + 1, x + 2] in f 3
18:16:23 <igotGTA> yes please
18:16:25 <lambdabot>   [5,5,5]
18:16:25 <lambdabot>   [3,4,5]
18:16:30 <igotGTA> \but the simplest one possible...lol
18:16:32 <kmc> heh, law of threes
18:16:36 <dolio> What we really need is to standardize a jhc-like Type open GADT, so that everyone can implement safe dynamics. :)
18:16:36 <Twey> Hehe
18:16:42 <Twey> Simplest possible?  Hm
18:16:46 <mauke> > let f _ = [] in f ()
18:16:47 <lambdabot>   []
18:16:51 <Twey> Yes ☺
18:16:53 <kmc> dolio, does GHC support open GADTs?
18:16:56 <dm``> kmc: http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
18:17:02 <dolio> kmc: No.
18:17:05 <igotGTA> (++)                    :: [a] -> [a] -> [a] []     ++ ys            =  ys (x:xs) ++ ys            =  x : (xs++ys)
18:17:10 <dm``> kmc: I have a few I've found, too.
18:17:11 <kmc> dolio, is there an established proposal for it
18:17:51 <kmc> @paste
18:17:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:17:56 <kmc> igotGTA, use that
18:18:07 <kmc> dm``, thanks for the link
18:18:26 <igotGTA> http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=9144
18:18:29 <dolio> kmc: No. jhc doesn't really support open GADTs, either. But the way it implements type classes, it has a built-in Type GADT in its internal language that gets extended whenever new types are added. And that allows for a type-safe Dynamic, too.
18:18:53 <igotGTA> i am confused about last line ...if you can walk me trough it
18:19:05 <kmc> dm``, have you considered OS-level sandboxing as a compliment to your haskell protection
18:19:41 <dolio> So it's not something you could even do from scratch yourself in pure jhc-haskell, but it's expressible in the intermediate language.
18:19:47 <dm``> Actually, the haskell-level protection is a complement to my OS-level sandboxing.  Been hacking kernels for 10+ years, but using haskell for about 4 weeks.
18:20:15 <kmc> igotGTA, (x:xs) and ys are both patterns.  the former matches any list of at least one element: x is bound to the first element, and xs is bound to the list of the rest (possibly empty)
18:20:22 <kmc> ys just matches anything and binds it to ys
18:20:40 <kmc> since we're defining a case for an infix operator, the patterns go on either side of the operator we define
18:20:43 <kmc> and that's the left-hand
18:20:53 <kmc> does that make sense defore i continue to the right hand side?
18:21:10 <igotGTA> i thought x was head and xs was tail
18:21:12 <igotGTA> lol
18:21:52 <kmc> igotGTA, head and tail are the names of haskell functions that produce the respective parts
18:21:53 <kmc> :t head
18:21:54 <kmc> :t tail
18:21:54 <lambdabot> forall a. [a] -> a
18:21:55 <lambdabot> forall a. [a] -> [a]
18:21:58 <RyanT50002> is there code in hackage for memoization based on stablenames?
18:22:07 <igotGTA> ok kmc    thanks
18:22:14 <kmc> but, it's much preferable to pattern-match like this, than to match any list and call head or tail
18:22:30 <RyanT50002> e.g. based on "Stretching the storage manager" by simon, simon, and conal
18:22:37 <kmc> because head and tail can cause run-time errors when the list is empty, whereas the pattern smoothly integrates with other patterns to cover those cases
18:22:41 <igotGTA> ok ill try to make some function that reutnrs list and see how i do
18:22:49 <kmc> good luck :)
18:22:56 <igotGTA> thanks kmc
18:23:01 <kmc> no problem
18:23:06 <igotGTA> talk later
18:23:44 <srush> so I have I'd like to guarentee a bunch of instances are associative
18:23:50 <srush> and it
18:23:58 <srush> 's easy to write the quickcheck for that
18:24:12 <srush> but I'd like not to have to write it for every instance of a class
18:24:32 <srush> can I write it once, and then use it easily for other instances?
18:24:56 <srush> quickcheck seems to prefer monomorphic types
18:29:53 <Cale_> <Cale> igotGTA: Okay
18:29:55 <Cale_> <Cale> igotGTA: The first line is a type signature, it says that the function (++) takes a list of values of some type a, another list of values of some type a, and produces a list of values of that same type a
18:30:26 <Cale> Oh, now he's gone?
18:44:19 <RyanT50002> i'm trying to build a memotable using stablenames
18:44:41 <RyanT50002> but it seems that StableName doesn't implement Ord
18:44:55 <RyanT50002> and given only hashable and Eq, i can't create one
18:45:18 <RyanT50002> is there a hash table in hackage somewhere? (i couldn't find one)
18:45:25 <RyanT50002> alternatively, is there a better way to build memo tables?
18:46:14 <RyanT50002> oh, found Data.HashTable :-/
18:46:16 <RyanT50002> whoops
18:46:49 <Cale> RyanT50002: I ran into the same stupid issue.
18:46:50 <copumpkin> I don't recommend it :)
18:47:03 <Cale> RyanT50002: Don't use Data.HashTable.
18:47:07 <RyanT50002> ok
18:47:14 <Cale> RyanT50002: Use Data.Map or Data.IntMap
18:47:27 <RyanT50002> well, that would be awesome if i had an Ord instance :P
18:47:52 <Cale> What type of data are you memoising?
18:48:04 <RyanT50002> Cale: very opaque things
18:48:49 <Cale> That makes things tough.
18:48:58 <RyanT50002> basically, functions
18:49:18 <Cale> RyanT50002: So you're memoising a higher-order function?
18:49:23 <RyanT50002> yes
18:49:24 <Cale> (basically?)
18:49:25 <Cale> hmm
18:49:49 <RyanT50002> basically, i've got a datatype Value
18:50:04 <RyanT50002> which contains some functions, sometimes
18:50:15 <RyanT50002> and doesn't contain anything in Ord, ever
18:50:31 <RyanT50002> and i'm writing this function "evaluate"
18:50:45 <RyanT50002> evaluate :: Value a -> a
18:50:56 <RyanT50002> values can refer to other values, and i want to avoid recomputation
18:51:34 <RyanT50002> so basically i need evaluate to memoize itself
18:52:13 <RyanT50002> and then pass the memoized version into the contents of each Value as a kind of environment
18:52:22 <RyanT50002> so i need to be able to memoize on Values :P
18:55:34 <Cale> RyanT50002: I might start by attaching unique identifiers to the Value a values somehow...
18:55:43 <Cale> (ones which were in Ord)
18:56:30 <RyanT50002> isn't that what StableNames are *supposed* to do?
18:56:41 <RyanT50002> it strikes me as extremely strange that StableNames don't solve my problem
18:56:53 <RyanT50002> since, as far as i can tell, this is the exact problem they were intended to solve
18:56:59 <RyanT50002> are they just not maintained at all?
18:57:20 <lpsmith> RyanT50002:   You could use an assoc list as a proof-of-concept :-P
18:57:21 <RyanT50002> i mean, i guess i could slap an unsafePerformIO in every single Value
18:57:24 <RyanT50002> hahaha
18:57:32 <RyanT50002> lpsmith: that's a very good point :P
18:58:21 <RyanT50002> what's the performance of unsafePerformIO like, anyway?
18:58:44 <RyanT50002> am i going to ruin my performance if i use it a few hundred thousand times per second?
18:58:56 <Cale> RyanT50002: Yeah, they're supposed to solve that problem, but as you noticed, they don't work.
18:59:07 <kmc> RyanT50002, what about hashStableName :: StableName a -> Int
18:59:15 <RyanT50002> kmc: not guaranteed unique
18:59:16 <Cale> RyanT50002: Why unsafePerformIO?
18:59:24 <kmc> RyanT50002, so take the recompute hit then
18:59:32 <RyanT50002> Cale: well, how else am i going to put a unique ID inside every Value?
18:59:34 <kmc> er, hmm, that's no good
18:59:39 <dm``> Maybe use inlinePerformIO.
19:00:00 <Cale> RyanT50002: As you construct them.
19:00:23 <RyanT50002> Cale: eh, i don't want to have to build these things monadically
19:00:25 <Cale> RyanT50002: It might require some work to thread the next available ID along.
19:00:34 <RyanT50002> yeah, i'm trying to avoid that work
19:01:41 <jokerGTA> kmc you still there
19:01:46 <kmc> RyanT50002, maybe look at the guts of GHC's StableName# type
19:01:54 <kmc> jokerGTA, yes for a min or two
19:02:02 <jokerGTA> its me igotGTA
19:02:21 <jokerGTA> i want to make function that will take int and return list with that int added
19:02:35 <jokerGTA> i know there is build it function for that but i want to see how it works
19:02:54 <jokerGTA> this is my definition
19:02:54 <kmc> jokerGTA, added where
19:02:57 <jokerGTA> myList::Int -> [Int]
19:03:02 <jokerGTA> into the list
19:03:13 <jokerGTA> takes int as parametar and adds it to list
19:03:17 <jokerGTA> and returns that list
19:03:26 <kmc> adds it to what position?
19:03:37 <jokerGTA> front for example
19:03:42 <jokerGTA> doesnt really matter
19:03:45 <jokerGTA> but lets say front
19:03:48 <Vanadium> To what list
19:03:50 <jokerGTA> is my definiotion ok
19:03:54 <kmc> where's your code
19:04:02 <jokerGTA> myList::Int -> [Int]
19:04:09 <jokerGTA> myList l = l:[Int]
19:04:15 <kmc> that doesn't make sense
19:04:19 <Vanadium> l:[]
19:04:23 <kmc> what list are you adding onto
19:04:31 <jokerGTA> thats what i am confused with
19:04:34 <jokerGTA> where is that list
19:04:39 <jokerGTA> whats the reference to that list
19:04:54 <kmc> jokerGTA, if you want to add an element to a list, you'd need to take both as arguments
19:05:14 <kmc> > let myList x = x:[] in myList 3
19:05:15 <lambdabot>   [3]
19:05:18 <kmc> here we add it to the empty list
19:05:25 <Twey> mylist :: Int -> [Int] implies mylist x = [x=
19:05:28 <Twey> Er, = [x]
19:05:31 <kmc> > let myList x xs = x:xs in myList 3 [1,2,3,4,5]
19:05:32 <lambdabot>   [3,1,2,3,4,5]
19:05:47 <kmc> @djinn Int -> [Int]
19:05:48 <lambdabot> Error: Undefined type Int
19:05:50 <jokerGTA>  cant you do this
19:06:05 <kmc> Twey, only if you force a linear type
19:06:07 <jokerGTA> myList::Int->[Int]->[Int]
19:06:24 <jokerGTA> myList  a b = a : b
19:06:31 <kmc> yes, that works
19:06:42 <Twey> kmc: I said ‘implies’, not ‘requires’ — that's just what I thought of when I saw it :þ
19:06:52 <kmc> heh okay
19:06:52 <Twey> jokerGTA: That function already exists: it's called (:)
19:06:55 * kmc out
19:06:56 <jokerGTA> i know
19:07:11 <jokerGTA> just wanted to see how i can ruturn some data of type list
19:07:26 <mmorrow> RyanT50002: vacuum uses an IntMap as a "hashtable" for the StableNames ==> IntMap [(StableName,a)], where the keys are the Int's from hashStableName
19:07:55 <RyanT50002> mmorrow: i guess that would do it
19:08:01 <mmorrow> (the `a' in vacuum's case are HValue (== Any))
19:08:34 <mmorrow> that was an improvement over reallyUnsafePtrEquality# and linear search
19:08:47 <RyanT50002> haha yeah, i guess so
19:08:53 <RyanT50002> "reallyUnsafe" is an amazing prefix :P
19:08:59 <mmorrow> hehe
19:09:13 <RyanT50002> especially for something that already has a pound-sign
19:09:24 <Twey> Haha
19:11:56 <jokerGTA> Twey you still there
19:12:21 <Twey> I am
19:12:57 <jokerGTA> myList::Int->[Int]->[Int]
19:13:03 <roconnor> > reallyUnsafePerformUndefined undefined
19:13:05 <lambdabot>   Not in scope: `reallyUnsafePerformUndefined'
19:13:07 <jokerGTA> myList a b = a:b works
19:13:14 <jokerGTA> works for integers
19:13:26 <jokerGTA> but what i want to make same function that takes chars as well
19:13:30 <jokerGTA> can i do
19:13:45 <jokerGTA> myList a->[a]->[b]
19:14:17 <Twey> You can (with the ‘is of type’ operator), although the type of the function there is in fact a -> [a] -> [a]
19:14:20 <jokerGTA> myList  a b = a: b
19:14:38 <Petrosian__> @ty \a b -> a : b
19:14:39 <lambdabot> forall a. a -> [a] -> [a]
19:16:02 <jokerGTA> a->[a]-[b] is not good??
19:16:09 <jokerGTA> i though that [a] means any type
19:16:14 <jokerGTA> same for [b]
19:16:36 <Petrosian__> jokerGTA: However, `a' and `b' may be different types
19:16:47 <Petrosian__> Whereas a list requires that all its elements are the same type
19:17:03 <jokerGTA> well first function i made was just integers
19:17:19 <jokerGTA> myList ->Int->[Int]->[Int]
19:17:26 <jokerGTA> MyList a b = a :b
19:17:41 <jokerGTA> i just want to change it to be general and work on Int and Char
19:17:52 <Petrosian> Yes, and in that specific instance you're saying that the input list must have the same type as the output list
19:18:12 <Petrosian> The type a -> [a] -> [b] implies that the output list might contain elements of a different type to the input list
19:18:24 <jokerGTA> oh yes
19:18:29 <jokerGTA> i see what you mean...sorry
19:18:35 <jokerGTA> yeah that makes sense
19:19:11 <jokerGTA> myList::a -> [b] -> [b]
19:19:20 <jokerGTA> myList a  b  = a : b
19:19:45 <Petrosian> Once again, if you're consing an `a' onto a list, the list must be of type `[a]'
19:19:53 <Petrosian> Hence a -> [a] -> [a]
19:20:04 <jokerGTA> ok
19:20:12 <jokerGTA> yeah you right
19:20:32 <Petrosian> Since `a' and `b' are different types.
19:20:43 <jokerGTA> if ther different its not gonna work
19:20:43 <Petrosian> They may well end up being the same type, but they are not nessecarily the same type
19:20:45 <jokerGTA> they gottas be same
19:20:48 <Petrosian> Precisely.
19:20:53 <jokerGTA> yeah it works now
19:20:55 <jokerGTA> thanks
19:20:59 <Petrosian> > 1 : ['a', 'b', 'c']
19:21:00 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
19:21:01 <lambdabot>    arising from the literal `1...
19:21:05 <Petrosian> > 'x' : ['a', 'b', 'c']
19:21:06 <lambdabot>   "xabc"
19:21:17 <jokerGTA> thanks guys
19:23:26 <jokerGTA> myList a ['g','k']-> a not in the scope
19:23:41 <jokerGTA> not in a scope 'a'
19:23:55 <Petrosian> You probably want 'a'
19:23:57 <Petrosian> As in the character
19:24:01 <jokerGTA> ok
19:24:06 <Petrosian> Not the variable
19:24:14 <jokerGTA> yeah works
19:24:15 <jokerGTA> thanks again
19:24:17 <jokerGTA> and sorry
19:24:24 <Petrosian> No need to apologise!
19:24:34 <Petrosian> That's what this channel is for (primarily)
19:24:48 <jokerGTA> cool....thanks guys
19:29:28 <pacopil> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
19:43:13 <purplepenguins> @pl \(_,x)\(_,y) -> snd x == snd y
19:43:13 <lambdabot> (line 1, column 7):
19:43:14 <lambdabot> unexpected "\\"
19:43:14 <lambdabot> expecting operator, pattern or "->"
19:44:14 <dolio> @type ((==) `on` (snd . snd))
19:44:15 <lambdabot> forall a b a1. (Eq b) => (a1, (a, b)) -> (a1, (a, b)) -> Bool
19:44:39 <dolio> @type ((==) `on` snd . snd)
19:44:40 <lambdabot> forall a b a1. (Eq b) => (a1, (a, b)) -> (a1, (a, b)) -> Bool
19:49:44 <purplepenguins> huh
19:49:51 <purplepenguins> @type on
19:49:53 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:49:59 <roconnor> @free on
19:50:01 <lambdabot> (forall x. g . k x = p (f x) . f) => f . q = f1 . h => g . on k q y = on p f1 (h y) . h
19:50:43 <purplepenguins> @src on
19:50:44 <lambdabot> (*) `on` f = \x y -> f x * f y
19:50:47 <roconnor> I often wish free would eta expeand some of these equations.
19:51:32 <roconnor> @type on (***)
19:51:34 <lambdabot> forall (a :: * -> * -> *) b c a1. (Arrow a) => (a1 -> a b c) -> a1 -> a1 -> a (b, b) (c, c)
19:51:47 <purplepenguins> where is on anyway
19:51:47 <roconnor> @type on (&&&)
19:51:49 <lambdabot> forall (a :: * -> * -> *) b c a1. (Arrow a) => (a1 -> a b c) -> a1 -> a1 -> a b (c, c)
19:51:53 <roconnor> @index on
19:51:53 <lambdabot> bzzt
19:51:56 <roconnor> :/
19:51:56 <dolio> Data.Function
19:52:02 <purplepenguins> thanks
19:52:07 <roconnor> what does index do?
19:52:34 <dolio> @index foldr
19:52:34 <lambdabot> Data.List, Prelude
19:53:11 <roconnor> stupid out of date index
19:53:57 <purplepenguins> is it bad form to defined fst/snd/thd for triples?
19:55:48 <dolio> They've been proposed even. But no one's ever moved them into the libraries.
19:56:01 <dolio> They may have even existed in older versions of Haskell, I forget...
19:56:04 <ivant> I'm trying to build cabal-install, but it fails for some reason: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9145#a9145 . Can someone help me?
19:56:49 <ivant> @type (>>=)
19:56:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:35:00 <kniu> A function's normal form is unique.
20:35:22 <kniu> Does that mean that two functions that do the same thing always have the same normal form?
20:37:20 <ivant> kniu: likely depends on the definition of "do the same thing"
20:37:39 <kniu> Oh boy.
20:37:46 <dolio> I'm pretty sure the answer is "no".
20:37:58 <sjanssen> kniu: what sort of functions are we talking about?  Lambda calculus?
20:38:04 <kniu> sjanssen, yeah.
20:38:45 <ivant> kniu: I may be terribly wrong, but imagine two different functions, both return the same values, but one does not terminate in eager evaluator
20:39:13 <sjanssen> kniu: the implication of what you ask is that program equivalence is decidable in LC, and I don't think it is
20:39:25 <kniu> k.
20:41:56 <dolio> One way to divide up type theories is intensional vs. extensional.
20:42:14 <dolio> In intensional type theory, equality of functions is up to beta-eta-whatever equality.
20:42:34 <dolio> Which means that f = g if you can show that they have the same normal form, roughly.
20:42:58 <dolio> In extensional type theories, you also goet f = g if you can prove that f x = g x forall x.
20:43:53 <dolio> But that's something you have to add in addition to the usual intensional equality. You can't prove it in an intensional theory.
20:44:32 <dolio> And extensional equality is the sort of equality that captures "two things are equal if they do the same thing."
20:47:18 <dolio> I don't have any ready made examples of functions that are extensionally equal, but not intensionally equal, though.
20:48:05 <kmc> what about "\a b c -> (a + b) + c" and "\a b c -> a + (b + c)"
20:48:16 <kmc> they are extensionally equal, but only because addition happens to be associative
20:49:00 <dolio> You can likely prove that (a + b) + c and a + (b + c) are intensionally equal, though.
20:49:32 <kmc> universally quantified on all lambda terms a,b,c?
20:49:59 <dolio> Is + defined for all lambda terms?
20:50:12 <kmc> if you're using church numerals, yes
20:50:17 <ivant> @seen dcoutts
20:50:18 <lambdabot> dcoutts is in #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-in-depth, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 3h 13m 59s ago.
20:50:55 <kmc> in the pure untyped lambda calculus, there are no type errors
20:50:56 <dolio> I haven't tried that, off hand.
20:51:24 <dolio> Well, I'm definitely not talking about the untyped lambda calculus.
20:51:40 <kmc> fair enough
20:51:41 <dolio> Because type theories are typed.
20:52:04 <kmc> but people talk about intensional and extensional equality in untyped lambda calculus too
20:52:11 <kmc> how does having types change it particularly?
20:52:46 <dolio> I just don't know enough about the topic with regard to the untyped lambda calculus to comment.
20:53:47 <dolio> But I do know that you can prove that (\a b c -> (a + b) + c) = (\a b c -> a + (b + c)) in, say, Agda where a b and c are inductively defined naturals.
20:54:08 <dolio> Or, at least, I'm pretty sure you can.
20:54:22 <kmc> dolio, based on what definition of _=_?
20:54:29 <mattam> You can if you add functional extensionality :)
20:54:52 <dolio> kmc: data _==_ {a : Set} (x : a) : a -> Set where refl : x == x
20:55:22 <mattam> The propositional equality is just the reflection of the intensional one, hence it has the same limitation w.r.t. functions.
20:57:14 <dolio> I may be wrong. I'll try it now.
20:57:36 <kmc> mattam, adding extensionality would involve a datatype which takes proofs that functions are equal on all inputs?
20:58:08 <mattam> If it's limited so as not to contain eta-expansion either, you can't prove [f = λx, f x] without an axiom.
20:59:30 <mattam> Extensionality can be introduced as an axiom, or you can use a new equality like you say, that relates function that are extensionaly equal.
20:59:57 <kmc> you mean a new axiom for _==_?
21:00:03 <mattam> Yes.
21:01:44 <mattam> There's another solution to this problem, proposed by Conor McBride and Thorsten Altenkirch that integrates functional extensionality in the equality, but now the equality is built-in, and no longer a regular datatype.
21:02:54 <mattam> It's a delicate matter, as adding it can lead to undecidability of type-checking pretty quickly.
21:04:59 <mattam> As a simple example, λx, x and λx, x + 0 are not intensionaly equal if you define + by recursion on the first argument. But you'd like them to be considered equal nonetheless (even if their complexity differs slightly :).
21:05:29 <nainaide> I am confuse on State Monad in returnState a = State $ \s -> (a, s) ,  \s -> (a,s) return a tuple, but State needs to take two para "s" and "a"
21:05:56 <nainaide> thanks in advance
21:06:40 <nainaide> returnState :: a -> State s a
21:07:32 <kmc> data _=~=_ {a : Set} {b : Set} (f : a -> b) (g : a -> b) : Set where everywhere : (x -> (f x == g x)) -> (f =~= g)
21:07:46 <kmc> is that close to this idea of extensional equality?
21:07:48 * kmc is an agda noob
21:08:38 <kmc> :t returnState
21:08:39 <lambdabot> Not in scope: `returnState'
21:08:48 <mmorrow> nainaide: think about the definition of the type State
21:08:52 <mmorrow> @src State
21:08:52 <lambdabot> Source not found. Sorry.
21:09:01 <mattam> kmc: Yes.
21:09:03 <mmorrow> State s a = State (s -> (a,s))
21:09:11 <mmorrow> return :: a -> State s a
21:09:30 <mmorrow> @type \a -> State (\s -> (a,s))
21:09:32 <lambdabot> forall s a. a -> State s a
21:09:36 <nainaide> mmorrow, yes, I understand these two lines
21:10:09 <nainaide> but just dont know understand what State $ \s -> (a, s) means.
21:10:35 <mmorrow> it's a piece of data that happens to contain a function
21:10:41 <kmc> :t runState
21:10:43 <lambdabot> forall s a. State s a -> s -> (a, s)
21:10:43 <mmorrow> Just 42
21:10:51 <mmorrow> State (\s -> (9,s))
21:11:00 <nainaide> yes
21:11:06 <kmc> nainaide, the field in the State constructor has type s -> (a, s)
21:11:14 <kmc> State :: (s -> (a, s)) -> State s a
21:11:31 <nainaide> kmc, yes
21:11:39 <mmorrow> does that help?
21:11:59 <mmorrow> @type Just (\s -> (9,s))
21:12:01 <lambdabot> forall t t1. (Num t) => Maybe (t1 -> (t, t1))
21:12:06 <mmorrow> @type State (\s -> (9,s))
21:12:08 <lambdabot> forall s t. (Num t) => State s t
21:12:20 <nainaide>  State $ \s -> (a, s) , why there is a "$" required
21:12:22 <kmc> nainaide, are you getting confused between the type constructor State and the data constructor State?
21:12:30 <kmc> nainaide, that's State ( \s -> (a,s)
21:12:35 <kmc> err (\s -> (a,s))
21:12:42 <kmc> :t ($)
21:12:43 <lambdabot> forall a b. (a -> b) -> a -> b
21:12:44 <kmc> @src ($)
21:12:44 <lambdabot> f $ x = f x
21:13:03 <mmorrow> , negate $ 4
21:13:04 <lunabot>  -4
21:13:07 <mmorrow> , negate 4
21:13:08 <lunabot>  -4
21:13:33 <mmorrow> it just lets you alternatively not need parens
21:13:34 <nainaide> kmc, got it, but why not just  State (\s -> (a, s)) instead.
21:13:41 <kmc> nainaide, for style
21:13:45 <mmorrow> nainaide: that's the way i prefer writing it
21:13:45 <nainaide> understand! thanks.
21:13:54 <kmc> people like to write "f $ g $ h x" instead of "f (g (h x))"
21:13:55 <nainaide> mmorrow, for what
21:14:07 <kmc> it can be more readable, or not
21:14:24 <mmorrow> nainaide: i like    State (\s -> (a,s)) as opposed to State $ \s -> (a,s)
21:14:26 <Gracenotes> personally, State is easier to think of without the newtype wrapper, but they are equivalent
21:14:30 <nainaide> perhaps too math style in my mind.
21:15:09 <kmc> Gracenotes, doesn't it clash with the other ((->) r) monad if you don't wrap?
21:15:15 <nainaide> mmorrow, agree with you.
21:15:36 <Gracenotes> it does, for implementing, not thinking..
21:20:25 <RyanT50002> is there any way to get ghci to tell you the type of something deep inside a function?
21:20:35 <ivanm> RyanT50002: make it a seperate function :p
21:20:37 <RyanT50002> e.g.: something bound inside a do statement
21:20:47 <kmc> RyanT50002, set a breakpoint
21:20:50 <RyanT50002> ivanm: if i knew how to do that, i probably wouldn't need to know the type of it :P
21:20:54 <RyanT50002> kmc: ah, ok
21:20:54 <dolio> kmc: Well, having tinkered a while, you may be right. I can't figure out a way to use the fact that the bodies are intensionally equal to prove that the functions as a whole are.
21:21:20 <dolio> kmc: So I guess \i j k -> (i + j) + k may not be intensionally equal to \i j k -> i + (j + k).
21:24:00 <kmc> dolio, you were tinkering in agda?
21:24:03 <Makoryu> @src (<*>) (,)
21:24:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:24:04 <dolio> Yeah.
21:24:21 <kmc> yeah it sounds like a pain to prove
21:28:16 <dolio> kmc: Turns out it's trivial for Church numerals, though.
21:28:56 <kmc> okay
21:29:10 <dolio> Because they both normalize to "\i j k f x -> i f (j f (k f x))".
21:29:13 <RyanT50002> huh... so i think i broke the type system
21:29:27 <kmc> aha
21:29:28 <RyanT50002> or, maybe i just don't understand why what i did is legal
21:29:40 <copumpkin> RyanT50002: what?
21:29:49 <RyanT50002> i've got a function with type "forall b. Value xs b -> b"
21:29:57 <RyanT50002> and inside that function there's a Map Unique b
21:30:05 <kmc> dolio, okay, now what if we use commutivity instead of associativity? ;)
21:30:08 <RyanT50002> which is stored in an MVar
21:30:17 <copumpkin> RyanT50002: hmm?
21:30:33 <copumpkin> I don't know what Value xs b is :P
21:30:33 <RyanT50002> there's only one Map no matter how many times you run the function
21:30:40 <RyanT50002> copumpkin: doesn't matter
21:30:45 <RyanT50002> the point is
21:30:53 <RyanT50002> the type "b" changes when you run the function multiple times
21:31:11 <RyanT50002> but it happily lets me keep using the same Map
21:31:29 <RyanT50002> so i now have a Map with some values that are Strings and some values that are Integers
21:31:30 <copumpkin> you doing some unsafePerformIO for the global map?
21:31:34 <RyanT50002> yeah
21:31:47 <RyanT50002> it's not global, but it's created by unsafePerformIO
21:31:51 <copumpkin> unsafePerformIO $ newIORef Map.empty?
21:31:53 <copumpkin> oh
21:31:55 <RyanT50002> more or less, yeah
21:32:10 <copumpkin> yeah, you can write unsafeCoerce in a similar manner
21:32:15 <RyanT50002> i see
21:32:23 <RyanT50002> well, hm
21:32:27 <RyanT50002> this is exactly the behavior i wanted
21:32:32 <dolio> kmc: That might run into the same issue as with the inductive naturals. Plus, I'm not really sure how to prove commutativity for Church addition period. :)
21:32:41 <copumpkin>  as soon as you drop an unsafe* (maybe not with interleaveIO though) in there, you get odd behavior :P
21:32:44 <RyanT50002> but i expected ghc to reject it :P
21:32:50 <copumpkin> or the potential for odd behavior, at least
21:32:59 <RyanT50002> well, i didn't realize that unsafePerformIO could cause type errors
21:33:04 <RyanT50002> i thought it was limited to synchronization errors
21:33:17 <copumpkin> yeah, it allows you to get crazy polymoprhic stuff in ways you can't get otherwise
21:33:21 <copumpkin> like newIORef undefined
21:33:35 <copumpkin> gives you an IORef a where the a can be different things (and that's how you'd write unsafeCoerce)(
21:33:45 <mmorrow> RyanT50002: this is the polymorphic-ref problem
21:33:57 <RyanT50002> mmorrow: huh
21:34:09 <copumpkin> RyanT50002: you need to make sure your accessors to the map are enforcing good typing
21:34:12 <mmorrow> RyanT50002: you can write unsafeCoerce using a polymorphic IORef
21:34:17 <copumpkin> RyanT50002: or you'll be getting some unsafe coercsion too :P
21:34:20 <RyanT50002> yeah, my accessors enforce good typing
21:34:38 <RyanT50002> oddly enough, i was expecting to need to do coercions to get the code to compile :P
21:34:54 <RyanT50002> the behavior i'm getting is actually precisely what i wanted, it's just surprising :P
21:34:59 <Nereid_> so (following http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types )
21:35:16 <Nereid_> if I have: data ShowBox = forall a. Show a => SB a
21:35:25 <Nereid_> and
21:35:29 <mmorrow> RyanT50002: if you're making sure everything is ok yourself, there's no reason why it wouldn't work (but a misstep will most likely end in segfault, of course)
21:35:41 <Nereid_> data ShowBox' where SB' :: Show a => a -> ShowBox'
21:35:48 <Nereid_> how closely related are those?
21:35:48 <Nereid_> D:
21:35:50 <RyanT50002> mmorrow: yeah, i think it'll be alright
21:36:12 <Nereid_> they appear to let you do the same thing
21:36:52 <RyanT50002> basically, the each "Value b" has a Unique in it, which is used as the index into the Map, the corresponding value of which is always "b"
21:36:58 <m4ik3ru> what up.
21:37:07 <mmorrow> RyanT50002: if you need to unsafeCoerce things to a common type, the recommended type to use is GHC.Exts.Any (since that's type's guaranteed to be s.t.  (\a -> unsafeCoerce (unsafeCoerce (a::a) :: Any) :: a) == id)
21:37:27 <copumpkin> RyanT50002: if you wanted some safety you could also wrap a Data.Dynamic around it and check coercion is safe, but you'll probably be fine without it
21:37:34 <mmorrow> but since you're not directly unsafeCoerce'ing, i guess you probably don't need that
21:37:53 <mmorrow> yeah, e.g. Data.Dynamic uses Any
21:37:57 <RyanT50002> hm
21:38:05 <Nereid_> I guess what I'm kind of asking is
21:38:09 <RyanT50002> is unsafeCoerce optimized away?
21:38:13 <Nereid_> is there something that you can do with existential types that you can't with GADTs?
21:38:15 <copumpkin> not always
21:38:16 <kmc> Nereid_, i believe they are the same
21:38:24 <kmc> you can make existential GADTs
21:38:34 <RyanT50002> i'd rather be explicit about my coercion if i can do it without any runtime penalty
21:38:38 <copumpkin> RyanT50002: if you unsafeCoerce a function to a data and back to a function, it may still segfault
21:38:48 <RyanT50002> oh
21:38:50 <RyanT50002> that's bad
21:38:58 <mmorrow> RyanT50002: i'd imagine it is optimized away, as the def of the primop is equivalent to id
21:39:00 <copumpkin> but if you pass through an Any, it's suposedly safe
21:39:01 <Nereid_> kmc: yeah they look the same to me too
21:39:10 <mmorrow> RyanT50002: right, that's exactly the purpose of Any
21:39:11 <Heffalump> copumpkin: how does Data.Dynamic work then?
21:39:21 <RyanT50002> alright, so i'll make the map a Map Unique Any
21:39:28 <RyanT50002> just to be explicit about things
21:39:28 <Heffalump> oh, with an existential
21:39:30 <dolio> kmc: I suppose the associativity one with inductive naturals provides an answer to the original question. \i j k -> i + (j + k) is already in normal form, because you can't do any further evaluation until it's applied to arguments. And the other nesting is also in normal form. But the two forms aren't the same.
21:39:43 <copumpkin> here's the brief discussion on the topic: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Prim.html#v%3AunsafeCoerce%23
21:39:45 <kmc> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt  see 7.4.5
21:39:52 <mmorrow> Heffalump: although it could use an existential, it actually just uses Any
21:40:00 <copumpkin> in particular
21:40:00 <copumpkin> Other uses of unsafeCoerce# are undefined. In particular, you should not use unsafeCoerce# to cast a T to an algebraic data type D, unless T is also an algebraic data type. For example, do not cast Int->Int to Bool, even if you later cast that Bool back to Int->Int before applying it. The reasons have to do with GHC's internal representation details (for the congnoscenti, data values can be entered but function closures cannot). If 
21:40:16 <kmc> dolio, you can't reduce further because + is defined by structural recursion on the inductive nat type/
21:40:18 <kmc> ?*
21:40:18 <lambdabot> Maybe you meant: . ? @ v
21:40:27 <Nereid_> kmc: ahh thanks
21:40:38 <mmorrow> @src fromDynamic
21:40:38 <lambdabot> fromDynamic (Dynamic t v) = case unsafeCoerce v of
21:40:38 <lambdabot>     r | t == typeOf r -> Just r
21:40:38 <lambdabot>       | otherwise     -> Nothing
21:41:08 <mmorrow> @src toDyn
21:41:08 <lambdabot> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
21:41:13 <dolio> kmc: Commutativity with church numerals is similar. The normal form of \i j -> i + j is \i j f x -> i f (j f x), and that's all you can do. And that isn't the same as \i j f x -> j f (i f x).
21:41:53 <mmorrow> i guess maybe the Dyn implem pre-dates existentials
21:41:53 <copumpkin> wow, I'm surprised that lambdabot has @src for those two
21:42:01 <kmc> dolio, hmm, but you can pass functions for i and j (which aren't church numerals) which break even extensional equality
21:42:03 <kmc> can't you?
21:42:19 <dolio> Maybe.
21:42:26 <kmc> (in untyped lambda calculus, say)
21:42:48 <dolio> In a typed setting you can only pass things of type (r -> r) -> r -> r. I'm not sure if that gets you enough to prove commutativity or not.
21:43:25 <dolio> That is, if addition is actually commutative with those restrictions.
21:43:26 <Nereid_> hmm
21:43:34 <Nereid_> I think I'm starting to understand existentials.
21:43:37 <Nereid_> sort of.
21:43:37 <Nereid_> maybe
21:44:15 <dolio> Actually I was using 'forall r -> (r -> r) -> r -> r' which is even more restricted. If there's some known global r, it's probably easier to break.
21:44:38 <BlackM> For instance, if f is pred, it won't work when i or j is 0.
21:44:53 <kmc> dolio, {r : Set} -> (r -> r) -> r -> r ?
21:45:11 <kmc> Nereid_, are you using them to wrap typeclasses?
21:45:20 <Nereid_> I'm not really using them
21:45:23 <Nereid_> I'm just trying to  understand.
21:45:24 <Nereid_> :)
21:46:05 <dolio> As long as you can pick i = \_ _ -> x, and j = \_ _ -> y, where x /= y, then those two expressions are clearly not equal.
21:46:17 <dolio> But those aren't church numerals.
21:46:18 <copumpkin> Nereid_: an existential can be used to "hide" a type parameter from the compiler, for example
21:46:46 <kmc> Nereid_, i like the example from the ghc manual
21:46:52 <kmc> data Foo = forall a. MkFoo a (a -> Bool)
21:47:02 <Nereid_> mhm
21:47:11 <kmc> when you use them with typeclasses, there's sort of an extra magical thing which happens
21:47:23 <kmc> implementation-wise
21:48:36 <mmorrow> the magic being ghc adds a field to the datatype that contains a record of the functions for that typeclass
21:48:44 <mmorrow> .. for that type
21:49:13 <blackdog> any ideas for a quick haskell demo to impress some ruby types? I really don't want to do that tired old not-really-quicksort thing.
21:49:41 <blackdog> something that could fit on a slide, does something cool and useful in a short chunk of code...
21:49:49 <mmorrow> class A a where foo :: a -> String; data D = forall a. A a => D a ======> data D = forall a. D (DictA a) a
21:50:00 <kmc> blackdog, list of all fibonacci numbers
21:50:12 <mmorrow> DictA a = DictA {foo :: a -> String}
21:50:12 <Nereid_> ======> ?
21:50:22 <kmc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
21:50:22 <Nereid_> oh
21:50:22 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
21:50:24 <Nereid_> hehe
21:50:28 <mmorrow> (======>) := "transformed by ghc to be"
21:50:33 <mle> blackdog: well, what do they like to do?  Parsec stuff maybe?
21:50:34 <kmc> or list of all primes
21:50:34 <kmc> etc
21:50:55 <mle> kmc: the primes list is a fun one too
21:51:05 <copumpkin> blackdog: you could do something like let (a, b, c) = (b + 2, c * 5, 3) in (a, b, c)
21:52:53 <blackdog> mle: that could be kind of cool - a little embedded language or somethnig
21:53:25 <kmc> parsing is sort of ugly no matter what
21:53:32 <mmorrow> data Foo = forall a. (Eq a,Ord a,Read a,Show a) => Foo a =====> data Foo = Foo (EqD a) (OrdD a) (ReadD a) (ShowD a) a
21:53:33 <blackdog> i'm trying to avoid the standard accusations of writing cute little snippets to do things that no-one's ever going to need in a real app
21:54:08 <Nereid_> I second the Parsec stuff idea
21:54:13 <Nereid_> :<
21:54:15 <mmorrow> and    bar :: (Show a) => a -> (String,Int) =====>  bar :: ShowD a -> a -> (String, Int)
21:54:18 <BlackM> blackdog: Use "loeb". >;)
21:54:38 <blackdog> BlackM: loeb?
21:54:44 <blackdog> the country & western singer?
21:54:55 <copumpkin> blackdog: but you could start with what I wrote up there, and then show them how it's useful in a loeb-like snippet
21:55:48 <mmorrow> @type fix (\k a -> fmap ($ k a) a)
21:55:49 <lambdabot> forall b (f :: * -> *). (Functor f) => f (f b -> b) -> f b
21:56:04 <mle> blackdog: realworldhaskell makes a good example of working through several ways of doing a csv parser.  something like that, perhaps?
21:56:05 <mmorrow> @type let loeb a = fmap ($ loeb a) a in loeb
21:56:07 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
21:56:14 <BlackM> mmorrow: Nice! :)
21:56:21 <mmorrow> :)
21:56:37 <kmc> blackdog, an EDSL for XML output
21:56:54 <kmc> or JSON or whatever will appeal to rubyists
21:57:15 <kmc> proving statically that it adheres to a spec
21:57:48 <Nereid_> blackdog: loeb: http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
21:57:57 <Nereid_> and http://blog.sigfpe.com/2006/12/tying-knots-generically.html
22:01:10 * BMeph wonders how tough it'd be to encode the 1st order Stirlings using loeb...
22:02:37 <mmorrow> , let loeb=fix(\k a->fmap($ k a)a) in loeb [const 1,(\x->(x!!0)+(x!!2)),const 3]
22:02:38 <lunabot>  [1,4,3]
22:02:50 <mmorrow> , let loeb=fix(\k a->fmap($ k a)a) in loeb [length,(\x->(x!!0)+(x!!2)),const 3]
22:02:52 <lunabot>  [3,6,3]
22:03:25 <mmorrow> , let loeb=fix(\k a->fmap($ k a)a) in loeb [length,(!!1),const 3]
22:03:25 <lunabot>  Killed.
22:03:52 <kmc> > let loeb = fix (\k a -> fmap ($ k a) a) in loeb [succ . (!! 1), pred . (!! 0)]
22:03:53 <lambdabot>   [* Exception: Prelude.Enum.().succ: bad argument
22:04:01 <kmc> > let loeb = fix (\k a -> fmap ($ k a) a) in loeb [succ . (!! 1), pred . (!! 0)] :: [Int]
22:04:05 <lambdabot>   [* Exception: stack overflow
22:04:25 <kmc> BMeph, what are these Stirlings?
22:04:53 <BMeph> kmc: Stirling numbers.
22:05:02 <BMeph> @go Stirling numbers
22:05:03 <lambdabot> http://en.wikipedia.org/wiki/Stirling_number
22:05:03 <lambdabot> Title: Stirling number - Wikipedia, the free encyclopedia
22:05:30 <kmc> i see
22:07:49 <copumpkin> :t fix (ap sequence)
22:07:51 <lambdabot> forall a. [[a] -> a] -> [a]
22:08:47 <kmc> oh, a category theory question
22:09:12 <kmc> is this all true: the morphisms of the category Hask are function types, which are also objects in the category
22:09:34 <copumpkin> > let loeb = fix (ap sequence) in loeb ((+1) . (!! 1), const 2, (*3) . (!! 0)]
22:09:35 <lambdabot>   <no location info>: parse error on input `]'
22:09:44 <kmc> and it's not generally the case that the morphisms of a category are objects too?
22:09:44 <copumpkin> > let loeb = fix (ap sequence) in loeb [((+1) . (!! 1), const 2, (*3) . (!! 0)]
22:09:46 <lambdabot>   <no location info>: parse error on input `]'
22:09:57 <copumpkin> > let loeb = fix (ap sequence) in loeb [(+1) . (!! 1), const 2, (*3) . (!! 0)]
22:09:59 <lambdabot>   [3,2,9]
22:10:20 <copumpkin> are there other interesting uses of loeb in a different functor?
22:10:30 <BMeph> copumpkin: Much love to the loeb, eh? ;)
22:10:34 <copumpkin> (other than [] that is)
22:10:57 <copumpkin> BMeph: gotta love it!
22:11:20 <m4ik3ru> I'm trying to implement concat like this:
22:11:23 <Berengal> copumpkin, maps are fun
22:11:33 <m4ik3ru> concat' [] = []
22:11:43 <BMeph> copumpkin: Gotta 'loeb' it, even. ;p
22:11:47 <copumpkin> Berengal: hmm, interesting
22:11:52 <m4ik3ru> concat' (x:xs) = x:concat'(xs)
22:12:12 <copumpkin> Berengal: that's still more or less the same idea though, are there any unconventional loeb ideas?
22:12:15 <BMeph> m4ik3ru: Change the ':' to '++'. :)
22:12:20 <Berengal> copumpkin, unfortunately they're strict, so you can't have infinitely large ones
22:12:24 <m4ik3ru> And I get an error for the empty list saying cannot construct the infinite type a = [a[]
22:12:30 <kmc> m4ik3ru, as written that just walks through the list without doing anything
22:12:50 <m4ik3ru> dang it :)
22:12:56 <kmc> do you see why?
22:13:12 <mmorrow> , let loeb=fix(\k a->fmap($ k a)a); depth(Node _ [])=1;depth(Node _ xs)=1+sum(fmap depth xs) in loeb (Node depth [Node depth [], Node depth []])
22:13:13 <lunabot>  Node {rootLabel = 3, subForest = [Node {rootLabel = 3, subForest = []},No...
22:13:14 <m4ik3ru> : is for adding to a list, ++ concatenates a list to another
22:13:19 <m4ik3ru> ?
22:13:22 <mmorrow> , levels (let loeb=fix(\k a->fmap($ k a)a); depth(Node _ [])=1;depth(Node _ xs)=1+sum(fmap depth xs) in loeb (Node depth [Node depth [], Node depth []]))
22:13:23 <lunabot>  [[3],[3,3]]
22:13:58 <m4ik3ru> Is it just because I'm concating a list of lists?
22:14:04 <kmc> m4ik3ru, you can tell just by reading the equations you wrote
22:14:07 <mmorrow> , levels (let loeb=fix(\k a->fmap($ k a)a); depth(Node _ [])=1;depth(Node _ xs)=1+sum(fmap depth xs) in loeb (Node depth [Node ((subtract 1) . depth) [], Node depth []]))
22:14:08 <lunabot>  [[3],[2,3]]
22:14:11 <kmc> the second one just moves (:) outside the call
22:14:24 <Berengal> copumpkin, arrays are also fun... you can't really get away from the indexing and consting much
22:14:31 <kmc> without changing anything
22:14:53 <copumpkin> @pl fix (\k a -> fmap ($ k a) a)
22:14:53 <lambdabot> fix (fmap . flip id =<<)
22:14:57 <m4ik3ru> I didn't have a problem doing that with this: firstN n (x:xs) = x:firstN (n-1) (xs)
22:15:12 <copumpkin> :t fix (\k a -> fmap ($ k a) a)
22:15:14 <lambdabot> forall b (f :: * -> *). (Functor f) => f (f b -> b) -> f b
22:15:14 <m4ik3ru> nvm
22:15:18 <kmc> m4ik3ru, you're doing something additional there
22:15:25 <mmorrow> loeb just takes an X containing functions that operate on X's and produce Y's, and turns that into an (X Y)
22:15:26 <m4ik3ru> In that one I do it n-1 times
22:15:39 <m4ik3ru> you're right.
22:15:45 <copumpkin> (a -> a -> b -> b) -> a -> b in the function functor?
22:15:59 <copumpkin> :t fix (\k a -> fmap ($ k a) a) :: (a -> a -> b -> b) -> a -> b
22:16:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b -> b
22:16:00 <lambdabot>     In the expression:
22:16:00 <lambdabot>           fix (\ k a -> fmap ($ k a) a) :: (a -> a -> b -> b) -> a -> b
22:16:05 <copumpkin> hmm, I guess I messed it up
22:16:48 <mmorrow> @type fmap :: (a->b) -> ((x->a)->(x->b))
22:16:50 <lambdabot> forall a b x. (a -> b) -> (x -> a) -> x -> b
22:16:59 <m4ik3ru> thanks kmc :)
22:17:23 <kmc> :)
22:17:37 <copumpkin> :t fix (\k a -> (fmap :: (a->b) -> ((x->a)->(x->b)))  ($ k a) a)
22:17:39 <lambdabot> forall x b. (x -> (x -> b) -> b) -> x -> b
22:18:20 <BMeph> :t fix (\k a -> fmap ($ k a) a) :: (a -> (a -> b) -> b) -> a -> b
22:18:21 <lambdabot> forall a b. (a -> (a -> b) -> b) -> a -> b
22:18:34 <BMeph> copumpkin: Sweet! :)
22:19:46 <Berengal> Any arguments not resulting in bottom to that?
22:20:08 <copumpkin> seems like it'd just be a layered id
22:20:14 <mmorrow> without the polymorphism hiding the infinite type in loeb, you'd need something like
22:20:16 <mmorrow> data Loeb f a = Loeb (f (Loeb f a -> a))
22:20:28 <mmorrow> (Functor f)
22:20:42 <mmorrow> err, actually hmm
22:20:45 <Berengal> @type let loeb = fix (\k a -> fmap ($ k a) a) in loeb (flip ($))
22:20:46 <lambdabot> forall b b1. b -> b1
22:20:55 <mmorrow> @type fix (\k a -> fmap ($ k a) a)
22:20:57 <lambdabot> forall b (f :: * -> *). (Functor f) => f (f b -> b) -> f b
22:21:06 <mmorrow> yeah
22:21:17 <copumpkin> oh I see
22:21:29 <m4ik3ru> are union _ [] = _ and union [] _ = _ equivalent?
22:21:39 <copumpkin> m4ik3ru: not necessarily
22:21:50 <kmc> m4ik3ru, what does the underscore on the RHS represent?
22:22:00 <kmc> :t let f _ = _ in f
22:22:02 <lambdabot> Pattern syntax in expression context: _
22:22:20 <m4ik3ru> Whatever was passed as an argument on the LHS
22:22:32 <kmc> m4ik3ru, to get that you need an actual variable, not _, which is a wildcard
22:22:59 <m4ik3ru> so union (x:xs) [] = (x:xs) and union [] (x:xs) = (x:xs)
22:23:01 <kmc> @djinn (Functor a) => a (a x -> x) -> a x
22:23:02 <lambdabot> Error: Class not found: Functor
22:23:31 <kmc> @djinn ((x -> y) -> (f x -> f y)) -> a (a x -> x) -> a x
22:23:31 <lambdabot> -- f cannot be realized.
22:23:33 <mmorrow> err no, since the functions in the functor take as arg the /result/ type, thanks to fix
22:23:36 <kmc> lies!
22:23:56 <kmc> err
22:24:01 <kmc> @djinn ((x -> y) -> (a x -> a y)) -> a (a x -> x) -> a x
22:24:02 <lambdabot> -- f cannot be realized.
22:24:21 <BMeph> Yeah, ... = _ is a non-sequitur
22:24:22 <dolio> @djinn doesn't have fix.
22:24:22 <lambdabot> -- f cannot be realized.
22:24:31 <mmorrow> (that "err no, ..." was re: "without the polymorphism hiding the infinite type in loeb, you'd need something like")
22:24:52 <mmorrow> the polymorphism isn't hiding anything
22:25:35 <BMeph> truths!!
22:26:30 * mmorrow tries to remember how he got @djinn to loop the other day
22:26:38 <kmc> @djinn (f (a -> b) -> f a -> f b) -> (a -> f a) -> (a -> b) -> f a -> f b
22:26:39 <lambdabot> -- f cannot be realized.
22:27:10 <kmc> @djinn (f (a -> b) -> f a -> f b) -> (c -> f c) -> (d -> e) -> f d -> f
22:27:10 <lambdabot> Error: kind error: (KVar 0,KStar)
22:27:12 <kmc> @djinn (f (a -> b) -> f a -> f b) -> (c -> f c) -> (d -> e) -> f d -> f e
22:27:12 <lambdabot> -- f cannot be realized.
22:27:27 <dolio> Also, djinn doesn't instantiate type variables to other types.
22:27:38 <dolio> So you need to give it exactly the type it needs.
22:27:48 <kmc> :/
22:28:15 <dolio> If it needs '(f x -> x) -> f (f x) -> f x' then '(a -> b) -> f a -> f b' isn't good enough.
22:29:03 <mmorrow> woo, found (not the /exact/ same one as the other day, but the same idea (whatever tf that idea may be..))
22:29:10 <mmorrow> *found one (..
22:29:11 <mmorrow> @djinn J (J a (J b a)) a -> J b (J (J (J a b) a) b)
22:29:27 <lambdabot> No output from Djinn; installed?
22:29:32 <mmorrow> :)
22:29:34 <copumpkin> :O
22:29:52 <mmorrow> type J a b = (b -> a) -> b
22:29:53 <copumpkin> so djinn and pl can both be screwed with :o
22:30:26 <mmorrow> djinn looping though i think can be considered a bug
22:30:36 <mmorrow>  @pl on the other hand...
22:31:02 <BMeph> mmorrow: ...did you just break the djinn?
22:31:20 <mmorrow> BMeph: i think that means i looped it
22:31:50 <mmorrow> don't have it installed locally though to see..
22:32:08 <mmorrow> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
22:32:08 <lambdabot> ap (. join id) (. join id)
22:32:23 <mmorrow> @pl (\x -> x x) (\x -> x x)
22:32:27 <lambdabot> ap id id (ap id id)
22:32:27 <lambdabot> optimization suspended, use @pl-resume to continue.
22:32:51 <mmorrow> , ap(++)show"ap(++)show"
22:32:52 <lunabot>  "ap(++)show\"ap(++)show\""
22:32:54 <copumpkin> now you've done it
22:33:03 <copumpkin> mmorrow killed lambdabot!
22:33:20 <mmorrow> copumpkin: NEEDMOAR BOTDEATH
22:33:28 <copumpkin> lol
22:33:32 <mmorrow> heh
22:34:05 * BMeph looks around to see if NEEDMOAR shows up...
22:34:20 * mmorrow quickly registers the nick "botdeath"
22:34:31 * BMeph meant "shows *back up
22:34:37 <BMeph> "
22:37:01 <mmorrow> , let go e=(let x = (fromJust.fromDynamic.eval)e::String) in x : go x) in go (ap(++)show"ap(++)show")
22:37:02 <lunabot>  luna: parse error on input `)'
22:37:11 <mmorrow> , let go e=(let x = ((fromJust.fromDynamic.eval)e::String) in x : go x) in go (ap(++)show"ap(++)show")
22:37:15 <lunabot>  ["ap(++)show\"ap(++)show\"","ap(++)show\"ap(++)show\"","ap(++)show\"ap(++...
22:42:57 <kmc> hmm, so the morphisms in the haskell category are not function types but the functions themselves
22:42:59 <kmc> ... i think
22:47:55 <mmorrow> right
22:48:33 <BMeph> What's the difference between a function type, and a type function? :)
22:48:43 <copumpkin> lots :P
23:03:14 <dolio> What's the difference between chocolate milk and milk chocolate?
23:05:39 <BMeph> dolio: lots :p
23:07:40 <Berengal> dolio, milk/chocolate ratio
23:10:56 <mmorrow> i thought that milk chocolate was made of solidified chocolate milk, and chocolate milk was made of melted milk chocolate!?
23:15:20 <eoeas> Hi, I have the following syntax that works fine:
23:15:20 <eoeas> main = interact wordCount
23:15:20 <eoeas>     where wordCount input = show (length (lines input)) ++ "\n"
23:15:29 <eoeas> how do i add:
23:15:29 <eoeas>  (length (words input)) ++ "\n" (length (input)) ++ "\n"
23:15:31 <eoeas> ??
23:15:44 <kmc> :t length
23:15:59 * kmc pokes lambdabot with a stick
23:16:13 <kmc> eoeas, length returns an Int
23:17:03 <eoeas> kmc:  ??
23:17:12 <kmc> you have to render it as a string if you want to glue it onto other strings
23:17:13 <Twey> Remember to show
23:17:25 <kmc> that's what the function show that you're using does
23:17:59 <Twey> > let input = "Lorem ipsum dolor sit amet..." in show (length $ words input) ++ "\n" ++ show (length $ input) ++ "\n"
23:18:06 <kmc> also, in haskell parentheses are only for grouping; they're not special for function application.  so "(length (input))" would typically be written "(length input)"
23:18:11 <Twey> …
23:18:27 <kmc> lambdabot seems to be passed out in a ditch somewhere
23:18:28 <Twey> @bot
23:18:29 <lunabot>  :o
23:18:32 <Twey> Heh
23:18:34 <Twey> Seems so
23:18:42 <Twey> ] let input = "Lorem ipsum dolor sit amet..." in show (length $ words input) ++ "\n" ++ show (length input) ++ "\n"
23:18:43 <lunabot>  "5\n29\n"
23:25:35 <kmc> eoeas, does that help?
23:26:54 <eoeas> Didn't get it :-/ let me rephrase:
23:26:54 <eoeas> runghc wordcount < file.txt
23:26:54 <eoeas> wordcount content:
23:26:54 <eoeas> main = interact wordCount
23:26:54 <eoeas>     where wordCount input = show (length (lines input)) ++ "\n"
23:26:55 <eoeas> Wnat to expand it to count words and characters.
23:27:10 <kmc> you had the right idea before
23:27:37 <kmc> do you understand what the function "show" is doing there?
23:28:22 <eoeas> kmc: not really, experimenting with a tutorial example
23:28:44 <kmc> eoeas, in this context, it converts an Int to a String
23:29:00 <kmc> it's actually more general than that -- can convert a lot of different types to Strings
23:29:24 <Berengal> show :: (Show a) => a -> String
23:29:43 <Berengal> That means it works on everything that's an instance of the Show class
23:29:52 <|Steve|> @type interact
23:30:02 <|Steve|> lambdabot doesn't like me.
23:30:06 <kmc> anyway, Haskell is strongly typed; you can't just glue an int and a string together.  you have to tell the implementation that what you mean is, "render this int as a string of decimal digits"
23:30:11 <Berengal> lambdabot temporarily kicked the bucket
23:30:18 <kmc> she was out partying too hard
23:30:53 <eoeas> kmc: Can I put it this way:
23:30:53 <eoeas> show [int1, int2, int3]
23:30:53 <eoeas> ??
23:31:01 <kmc> eoeas, it may not do what you expect
23:31:05 <mmorrow> , show [0,1,2]
23:31:06 <lunabot>  "[0,1,2]"
23:31:13 <mmorrow> , concatMap show [0,1,2]
23:31:14 <kmc> eoeas, do you have access to an interactive haskell interpreter like GHCi or Hugs?
23:31:14 <lunabot>  "012"
23:31:20 <kmc> it's absolutely essential for learning the language quickly
23:31:22 <eoeas> GHCi
23:31:24 <Axman6> eoeas: do you know any other programming languages?
23:31:31 <kmc> eoeas, then you can try "show [1,2,3]"
23:31:32 <mmorrow> , intercalate " " (map show [0,1,2])
23:31:33 <lunabot>  "0 1 2"
23:31:36 <kmc> you get a textual representation of the list
23:31:38 <eoeas> Axman6: not really
23:31:39 <kmc> as above
23:31:51 <Axman6> ok
23:31:53 <kmc> eoeas, do you know what we're talking about with Int and String and such?
23:32:02 <eoeas> kmc: yup
23:32:13 <kmc> and why we need to be explicit about converting between them?
23:32:19 <kmc> (that's a feature in some languages and not others)
23:32:44 <kmc> (in perl and c++, you have lots of implicit conversions, often with disastrous results)
23:33:00 <|Steve|> I disagree with that statement whole-heartedly.
23:33:17 <kmc> |Steve|, "0 but true"
23:33:27 <kmc> I have nothing more to say. ;)
23:33:52 <|Steve|> Um, that's not valid in either of those languages.
23:34:06 <kmc> "0 but true" is a value used commonly in Perl
23:34:22 <kmc> it's just a string
23:34:41 <|Steve|> Oh, a string. I've never used that nor ever seen it used.
23:34:41 <kmc> it implicit-converts to 0 as an integer, and to true as a boolean
23:34:42 <eoeas> kmc: Kinda get your point, but how do I legally glue integer arguments that pass to show i.e. ++ or | or ,
23:34:42 <eoeas> ??
23:34:51 <kmc> eoeas, show each one individually
23:35:00 <kmc> that gets you strings, which you can use ++ to glue together
23:35:11 <Berengal> , show 1
23:35:12 <lunabot>  "1"
23:35:14 <kmc> eoeas, show is not the "print this value out" command
23:35:15 <Berengal> , show 2
23:35:17 <lunabot>  "2"
23:35:22 <Berengal> , (show 1) ++ (show 2)
23:35:23 <lunabot>  "12"
23:35:24 <kmc> it is the "convert to string" function
23:35:28 <kmc> the actual printing is done by interact
23:36:38 <kmc> ran into a subtle bug at work where a perl wrapper script died if you tried to pass "0" as a command-line arg to the wrapped script
23:36:56 <kmc> for similar reasons
23:38:54 <eoeas> Berengal: Yup, that helped:
23:38:54 <eoeas> (show (length (lines input))) ++ (show (length (words input))) ++ (show (length (input))) ++ "\n"
23:39:13 <Axman6> that won't quite work
23:39:21 <Axman6> since interact works on lines i believe
23:39:25 <eoeas> i know :P
23:39:28 <kmc> eoeas, if you like it better, you can write (f (g (h x))) as (f $ g $ h x)
23:39:41 <kmc> i find it easier to read when you're just applying lots of functions together
23:39:45 <|Steve|> Or f . g $ h x
23:39:56 <Quadrescence> (f . h . h) x
23:40:03 <Quadrescence> g
23:40:25 <kmc> here $ is not special syntax; it's just an infix operator like ++.  the meaning of this operator is that f $ x = f x
23:41:16 <eoeas> Problem is my output is: 714122, should be 7 14 122, do i just insert ++ " " ++
23:41:16 <kmc> . is the function composition operator; it works like this:
23:41:16 <eoeas> ??
23:41:22 <kmc> (f . g) x = f (g x)
23:41:30 <Quadrescence> kmc: Perhaps it is special syntax when the functions are fully saturated
23:41:41 <Quadrescence> in which case it could optimize to a function call.
23:41:46 <purplepenguins> @src inits
23:41:47 <Quadrescence> (sans currying)
23:42:04 <purplepenguins> is lambdabot broken
23:42:06 <kmc> eoeas, that would work
23:42:11 <kmc> also check out the function "unwords"
23:42:18 <mle> yes
23:42:30 <kmc> finally, note that if you're doing serious string processing in haskell, ++ is an inefficient way
23:42:33 <ray> very little in haskell is special syntax
23:42:33 <kmc> it's fine of course for learning
23:42:52 <ray> String isn't very efficient itself
23:43:02 <kmc> Quadrescence, i wouldn't call that special syntax regardless.  a compiler optimization should be transparent to the user
23:43:17 <kmc> there are optimizations on map and fold too
23:43:26 <eoeas> kmc: Thanks, testing in progress ...
23:43:28 <Quadrescence> Well, yeah, it would be transparent. But that doesn't preclude it from being special synrax.
23:43:34 <kmc> *shrug*
23:44:20 <kmc> is map special syntax, just because ghc knows to convert "map f $ map g x" into "map (f . g) x" ?
23:44:23 <ray> it's not special syntax
23:44:27 <ray> it's a line of code in the prelude
23:44:48 <dibblego> kmc, you are right, neither map or ($) are special syntax
23:45:25 <ray> i doubt the compiler generates extra code for f $ x as opposed to f x, but that's because it's smart
23:45:50 <kmc> it's cool that we have people learning haskell as a first language
23:46:05 <ray> yeah, it's probably a good first language
23:46:08 <kmc> yeah, ($) should always inline.  perhaps it is declared this way
23:46:13 <ray> i believe it is
23:46:21 <Quadrescence> kmc: Should it always inline?
23:46:33 <kmc> Quadrescence, if fully applied, i think there's no reason for it not to
23:46:42 <kmc> of course you can map ($ x) fs
23:46:42 <Quadrescence> Oh, so not always.
23:47:36 <|Steve|> (f$) would be a bit strange though.
23:47:37 <kmc> ray, i think a good first language depends a lot on what the person in question
23:47:42 <kmc>  wants to get out of programming
23:47:55 <Quadrescence> C is a good first language
23:48:02 <mle> ew, no.
23:48:06 <kmc> at my school they used scheme as an intro language, which worked great for the hardcore CS types, and terribly for mechanical engineers who just need to program to do things
23:48:28 <Axman6> Quadrescence: i disagree
23:48:31 <Quadrescence> mle: ew, yes. It teaches programmers to suck it up and learn how to solve problems.
23:48:38 <|Steve|> C is a good first language because there's nearly a 1-1 mapping with what the hardware is actually doing.
23:48:46 <Axman6> i think a first language should teach you ideas, without being too difficult
23:48:49 <dibblego> quite the contrary, it teaches people to solve non-problems that masquerade as problems
23:48:49 <mle> Quadrescence: I think C should be required material, but no, it isn't a good starting place.
23:48:51 <kmc> no, it teaches programmers to repeatedly re-solve problems that were solved 30 years ago
23:48:53 <ray> i think the mechanical engineers should learn scheme and the cs majors should go jump off a bridge :)
23:49:02 <arw_> C is a terrible first language because you focus on the hardware, not on whats important.
23:49:02 <kmc> ray, no good bridges around
23:49:04 <Quadrescence> kmc: New programmers aren't going to solve new problems.
23:49:06 <mle> |Steve|: ... not with any optimizing compiler written in the past 15 years.
23:49:14 <purplepenguins> is there an easy way to stop ghci from running an infinite loop
23:49:25 <ray> C is a pretty succinct description of a von neumann machine
23:49:31 <Axman6> Quadrescence: new programmers need to know how to solve old problems. these problems should not include C
23:49:33 <|Steve|> mle: Uh, reordering aside, it's pretty close.
23:49:51 <kmc> |Steve|, what do you mean by "hardware"? the ISA or the actual gates?
23:49:56 <kmc> because these days the ISA is just another virtual machine
23:49:58 <|Steve|> The ISA.
23:50:04 <ray> haskell is a language for writing succinct descriptions of interesting things in
23:50:05 <|Steve|> For x86, it is.
23:50:15 <dibblego> teaching Haskell/programming is pretty easy, unless they've been exposed to C (or a cousin of), in which case, it's extraordinarily difficult
23:50:20 <pikhq> |Steve|: ... No.
23:50:29 <mle> I guess it depends on whether you are emphasizing engineering or math.
23:50:37 <kmc> for most architectures, and for x86 to a huge degree
23:50:54 <|Steve|> Got another common architecture in mind?
23:51:00 <kmc> also, on RISC C is further from the machine
23:51:08 <|Steve|> No it isn't.
23:51:23 <pikhq> Have you ever programmed in assembly, |Steve|?
23:51:28 <kmc> when was the last time you had to account for shadowed instructions in a jump in C?
23:51:39 <|Steve|> pikhq: Not only that, but I've taught students to program in assembly.
23:51:52 <BMeph> C hasn't been near "close" to "what the hardware is actually doing" since 1983.
23:51:55 <kmc> C is pretty far from any real hardware anyone actually uses
23:52:11 <mle> kmc: heh, I guess vax is kinda dead now, eh?
23:52:12 <pikhq> |Steve|: It's hard to tell.
23:52:19 <kmc> it is heavily abstracted, in a way which maps efficiently to real hardware, and is still much lower level than other things
23:52:20 <ray> C is a generic von neumann machine
23:52:24 <|Steve|> As I already said, I meant ISA, not lower.
23:52:34 <kmc> |Steve|, but why is that any more important than any other VM
23:52:38 <pikhq> And the ISA is not "what the hardware is actually doing".
23:52:41 <|Steve|> It's not like tomosulo is exposed with C.
23:52:44 <kmc> why is it better to be close to the ISA than to the JVM or the STG machine?
23:52:52 <|Steve|> pikhq: But it's the closest a programmer can get.
23:52:58 <pikhq> ... And only x86 has much of a close mapping with C.
23:53:09 <kmc> ?
23:53:14 <|Steve|> The claim about risc is patently false, by the way.
23:53:20 <pikhq> (and that's principly because x86 was designed with hand-written assembly in mind)
23:53:35 <|Steve|> x = y + z becomes add rt,ra,rb on most risc.
23:54:00 <|Steve|> On x86, you've got to copy a register first.
23:54:05 <|Steve|> But that's all beside the point.
23:54:09 <pikhq> ... Yes, and assuming that y and z are Ints, the same is true of Haskell. That does not mean RISC has a nice mapping with Haskell.
23:54:18 <kmc> |Steve|, no, it becomes three loads, an add, and a store
23:54:30 <|Steve|> kmc: Only if their in memory.
23:54:34 <kmc> or do you mean that C variables map to registers? because i think there are a finite number of registers on even the fanciest RISC machine
23:54:36 <|Steve|> er, they're*
23:54:40 <kmc> and an infinite number of C variables
23:55:44 <ray> this is such a weird argument
23:55:59 <|Steve|> int foo( int x, int y ) { return x+y; } works out on the powerpc to be add r3,r3,r4; blr. Any idea what the similar thing will be for a Haskell program?
23:56:22 <pikhq> That is... Patently false.
23:56:39 * dibblego patents false
23:56:53 <ray> my head spins if i try to read it
23:57:04 <ray> and i don't mean boring lateral spinning
23:57:08 <ray> i'm turning upside down here
23:57:09 <pikhq> There's such a thing as a "stack" in common C implementations.
23:57:11 <kmc> pikhq, Microsoft beat you to it
23:57:22 <|Steve|> pikhq: I'm well-aware of it.
23:57:46 <pikhq> Which firmly does not exist in C itself.
23:58:00 <kmc> err, dibblego: Microsoft beat you to it
23:58:21 * BMeph patents False
23:58:25 <eoeas> ray: (07:46:06) ray: yeah, it's probably a good first language
23:58:25 <eoeas> Which one are you talking about?
23:58:30 <ray> haskell
23:58:31 * kmc runs Python, sets True = False
23:59:02 * blackdog runs Ruby, evades patents by having different types for true and false
23:59:27 <|Steve|> pikhq: That's true, it's implementation defined.
23:59:58 <kmc> |Steve|, no, it's not defined at all
23:59:58 <eoeas> ray: it seems very logical in a lot of ways, getting started was the problem, i seemed to be hitting a invisible wall
