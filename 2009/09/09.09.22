00:00:59 <mmorrow_> copumpkin, dons: here's the change to IntMap http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3878
00:01:14 <mmorrow_> (just verified that it works too)
00:01:50 <copumpkin> mmorrow: how did you make the change?
00:02:00 <mmorrow> copumpkin: directly to the .s unfirtunately
00:02:04 <copumpkin> ah
00:02:23 <copumpkin> any performance improvements?
00:02:27 <mmorrow> copied IntMap and IntSet into a local dir, unqualified their names, built each with
00:02:38 <copumpkin> :)
00:02:52 <mmorrow> i'll just paste it
00:03:57 <Orclev> @tell tehgeekmeister make sure to check out the second revision, I updated it after copumpkin made a untilM function for me
00:03:57 <lambdabot> Consider it noted.
00:05:11 <mmorrow> copumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3878#a3879
00:05:51 <Orclev> btw, how would one go about getting untilM put into one of the standard modules (say Control.Monad)?
00:06:19 <copumpkin> Orclev: probably send a proposal to the libraries mailing list
00:06:24 <mmorrow> it's cool that x86_64 has conditional mov instructions too
00:07:30 <dolio> So you compiled IntMap and IntSet in a local directory, and then modified the assembly by hand?
00:10:23 <mmorrow> here're those functions wrapped as ccalls with foreign imports http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3878#a3880
00:10:39 <mmorrow> dolio: yeah, i'm not sure there's another way to do it
00:10:45 <dolio> :)
00:11:08 <mmorrow> it's pretty painless though
00:11:18 <dolio> Yes, very user friendly.
00:11:32 <Orclev> mmorrow: yeah, I was amazed at how easy it is to call assembly from haskell and vice versa
00:12:19 <mmorrow> dolio: heh
00:12:30 <mmorrow> Orclev: yeah, the FFI rocks
00:16:02 <Baughn> Hm. That's just the C calling convention, though
00:16:07 <copumpkin> mmorrow: wouldn't wrapping them as ccalls negate some of your benefits?
00:16:22 <Baughn> It would. You should try wrapping them as foreign primops.
00:16:43 <copumpkin> you can't do that
00:16:49 <mmorrow> copumpkin: yeah, i just did the ccalls for playing with them
00:16:50 <Baughn> You can in 6.11.. I think
00:16:51 <copumpkin> not in the current ghc anyway
00:17:02 <copumpkin> Baughn: nope, you can do foreign import prim on cmm code
00:17:15 <Baughn> Not assembly?
00:17:16 <copumpkin> but cmm still needs to pass through a codegen that doesn't know about bsr
00:17:21 <copumpkin> nope
00:17:24 <dolio> Huh, interesting.
00:17:25 <Baughn> Pity.
00:17:40 <copumpkin> well, if you can figure out ghc's undocumented and rather volatile calling conventions, you can write assembly too
00:17:46 <copumpkin> (I'd assume)
00:18:40 <dolio> You should just hound Max Bolingbroke until he adds bsr to the codegen.
00:18:45 <Orclev> ok, I definitely need to get to bed... I read volatile calling conventions and got a mental picture of someone calling a function and having their computer burst into flames
00:18:50 <mmorrow> here's a foreign import prim cmm example http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7865#a7865
00:19:13 <Baughn> Orclev: That may not be too far off from the truth.
00:19:43 <copumpkin> dolio: I want him to finish GHC plugins first :P
00:19:59 <Baughn> mmorrow: ..so that's.... haskell assembly. Interesting.
00:20:31 <dolio> It's GHC's own non-standard version of C--.
00:21:17 <Zeiris> What's GHC assembly like when it comes to reverse engineering it?
00:21:20 <Orclev> lol, C--
00:21:29 <vegai> mm
00:21:34 <Baughn> Zeiris: Reverse engineering? Are you kidding?
00:21:51 <Baughn> Zeiris: There are whole companies dedicated to writing games in Haskell specifically so DRM will work better.
00:21:51 <vegai> I just split my project into 4 different modules. 3 of those have tests that depend on the one
00:22:16 <copumpkin> Zeiris: I haven't really looked at very deeply, but it's definitely going to break many reverse engineers' assumptions about what code looks like :)
00:22:25 <vegai> so the question: how do I run the tests of those three against the fourth's library without needing to install the library?
00:22:34 <Zeiris> Baughn: have they released any games yet?
00:22:46 <vegai> (they're all cabalized, of course)
00:22:53 <copumpkin> Zeiris: take a look at one reverser's reaction when he encountered chicken scheme, http://www.nnl-labs.com/cblog/index.php?/archives/2-Why-Did-CHICKEN-Cross-the...-oh-nevermind.html
00:23:26 <Baughn> Zeiris: I was, of course, joking.
00:23:55 <copumpkin> it will definitely stop scriptkiddies trying to reverse your programs from a tutorial on a "learn to be a cracker" site
00:23:55 <Zeiris> Yeah, I figured anything involving multiple game companies using Haskell was a joke :E
00:24:47 <copumpkin> mmorrow: have any benchmarks of your custom IntMaps then?
00:25:13 <copumpkin> it'd be interesting to see how much time is wasted in those 20 or so instructions
00:25:54 <mmorrow> copumpkin: not yet, but i definitely am going to
00:27:09 <Zeiris> copumpkin, that link is hilarious :)
00:27:55 <copumpkin> Zeiris: and all my reverser friends scoff at my love of functional languages, so you can be reasonably sure that not many of them have bothered to figure much out about it
00:28:06 <copumpkin> == more security through their ignornace, for now :P
00:28:14 <Orclev> lol, chicken, I love it
00:29:00 <Zeiris> Well, the sheer hilarity of 'where'd the retns go??' is worth it.
00:29:35 <dobblego> wtf is reverser?
00:30:25 <copumpkin> dobblego: reverse engineer?
00:30:37 <copumpkin> (my other life)
00:30:40 <Orclev> dobblego: shorthand for reverse engineer... could be worse, might eventually devolve into reve
00:31:09 <sereven> firefly reavers maybe?
00:32:23 <vegai> oh well, I'll just install them in order
00:32:31 <Orclev> sereven: nah, the program to chemically passify programmers was scrapped when it was discovered you can get the same result cheaper by supplying unlimited sode, coffee, and web comics
00:32:52 <sereven> :)
00:35:23 <Baughn> copumpkin: I am, right at this moment, imagining someone trying to reverse a haskell FRP program
00:35:28 <copumpkin> :)
00:35:58 <Orclev> reading about this guy trying to reverse engineer a continuation passing application makes me wonder what the dissassembly of haskell looks like... I suppose I could always build something down to the assembly level and take a peek
00:36:03 <copumpkin> I'm sure it would break many of IDA's assumptions about programs, let alone those of individual reversers trying to read the disassembly
00:36:23 <Baughn> Orclev: Having had a look.. it looks quite horrid
00:36:47 <Baughn> Orclev: It keeps calling into the same two or three functions to dethunk thunks :/
00:37:19 <dv-_> is reading and writing IORefs... fast?
00:37:36 <Baughn> Yes. Not that this should usually matter.
00:37:59 <Baughn> Yes, I am afraid it is... fast.
00:38:22 <copumpkin> not quite as fast as your average local variable
00:38:28 <copumpkin> since the contents won't live in a register
00:38:41 <Baughn> True. For best speed, stay out of IO.
00:39:17 <Baughn> Orclev: Still, haskell does have the same sense of "wtf is happening here?" that he noticed in chicken.
00:40:33 <Orclev> Baughn: well, never having spent much time reverse engineering any code at all, I'd probably be going "wtf is happening here" no matter what
00:40:43 <copumpkin> anyone know of a posix api for checking if a process is running (by name)? like what ps uses
00:41:01 <Baughn> copumpkin: ps *is* the posix api
00:41:08 <Baughn> Well, rather, pidof
00:41:15 <copumpkin> Baughn: programmatically
00:41:24 <Baughn> copumpkin: system(pidof)
00:41:28 <copumpkin> lol
00:41:30 <mornfall> copumpkin: POSIX probably doesn't define anything like a process name.
00:41:39 <mornfall> Or only very hazily.
00:41:46 <Baughn> It doesn't. pidof is the closest to anything portable that you'll find.
00:42:36 <copumpkin> a shell utility? no api whatsoever? :O
00:42:42 <bastl> hi. does anyone know how to parse a .cabal file to get a "Distribuition.PackageDescription" ?
00:42:53 <mornfall> copumpkin: There's even no POSIX API to list running processes. Bummer.
00:43:01 <copumpkin> meh :)
00:43:07 <mornfall> copumpkin: What ps, pidof etc do is usually hacking their way through /proc.
00:43:14 <copumpkin> not on mac os :)
00:43:25 <copumpkin> (given that there's no /proc)
00:43:44 <mornfall> Actually, the package on linux is called "procps" ... ; - )
00:43:48 <copumpkin> I guess I'll just run ps in popen or something
00:43:58 <mornfall> People tend to expect postscript processing powers from it. Wonder why.
00:44:30 <Baughn> Perhaps that is why ps has a latex output mode. >_>
00:45:07 <mornfall> Omg. :)
00:45:58 <Orclev> I'm trying to figure out a example where you'd actually want ps to output in latex and I'm failing utterly
00:46:43 <Baughn> Orclev: Keep in mind, this is from the same guys who built an email reader into hello, world.
00:47:56 <mornfall> Orclev: To include a snippet in your paper, of course.
00:48:35 <Orclev> mornfall: yes, then the instructor can see exactly how much time your spending playing nethack
00:49:15 <mornfall> You mean Wesnoth, don't you?
00:49:19 * mornfall is a kid.
00:49:56 <Baughn> You mean ADOM, right?
00:49:58 * Baughn is a snob.
00:50:04 <Orclev> ADOM?
00:50:14 <Baughn> Ancient Domains Of Mystery
00:50:24 <Orclev> ... never heard of it
00:50:26 <Baughn> ..I got too good at nethack. :P
00:51:06 <Orclev> I've never been good at nethack, I tend to get killed before I've made it more than a few levels down
00:51:54 <Baughn> You just need to be careful. And use your cat.
00:52:12 <mornfall> For food?
00:52:26 <Baughn> For fighting.
00:52:39 <Orclev> wtf? I just tried installing nethack on my gentoo box and I get a message saying it's blocked pending a resolution of a security issue... wtf kind of security issue could there be on nethack???
00:53:28 <Baughn> Orclev: It runs setgid games
00:53:37 <Baughn> Orclev: For the purpose of sharing bones
00:53:49 <Baughn> Orclev: ..you can overrid the block; there's no danger on a single-user system
00:54:38 <Orclev> Baughn: yeah I know I can force it, just couldn't think of any way that a single player game could possibly pose a security risk
00:54:41 <Baughn> (Or was it setuid root?)
00:54:51 <Orclev> Baughn: god, I hope not
00:55:51 <Baughn> Oh. The issue is that on gentoo, since users are /added to/ group games instead of making the game setgid, users can manipulate the bone files
00:56:17 <Baughn> Allowing arbitrary code execution in other users who run it
00:56:45 <Orclev> ah, so there's an exploit in the bone files
00:56:55 <Baughn> Kind of. Gentoo just breaks nethack's assumptions.
00:59:52 <Baughn> I.. what?
00:59:59 <Baughn> ...that makes a sick kind of sense.
01:00:10 <Orclev> doesn't it though
01:00:22 <Baughn> But doesn't that spell cost something like a thousand gold? :P
01:00:40 <Orclev> Baughn: probably, but you can't eat a thousand gold :P
01:00:53 <Baughn> It's a funny thing
01:01:18 <Baughn> ..I once haggled the "thousand gold' worth of diamond" down by 10%
01:01:24 <Baughn> ...my GM made me buy more.
01:01:46 <Orclev> Baughn: the GM always wins, one way or another
01:02:15 <Baughn> Orclev: Personally, I got the impression it was like those budgets, where if you don't spend it all it gets reduced
01:02:31 <Baughn> That always seemed counter-productive to me
01:03:24 <Orclev> Baughn: it's beurocracy, it's designed to be counter-productive... if it was productive it would be outsourced to a private company
01:04:08 <Baughn> Orclev: I should like to point out that last time I saw such a budget, it was in a private company
01:05:09 <Orclev> Baughn: typically you see it in government organizations, private companies that do such things tend not to last long... or they've reached the size where they can afford to blow wads of cash for no reason at all
01:07:01 <Orclev> anyway, I need to get to bed, it's waaaay past the time I should have gone to sleep
01:07:20 <copumpkin> Orclev: haskell is addictive, isn't it!
01:08:10 <Orclev> copumpkin: actually I haven't been doing any programming for the last hour or two
01:08:18 <copumpkin> still!
01:11:04 <Cale> Hehe, I installed Morrowind a while back under wine, and it had problems, so I just left it alone for a while, and wine got updated, and now it works pretty much perfectly. :)
01:13:01 <ivanm> Cale: and thus your Haskell output has decreased? :p
01:55:23 <ASA_> Hi, is anyone using GHC in a production environment and not having any problems with it?
01:56:21 <vegai> ASA_: I am!
01:57:25 <ASA_> vegai: which version are you using? I'm trying out 6.10.4 on windows and having problems.
02:05:39 <ksf> ...from 9 to 22 fps just by abandoning CHP and using plain STM
02:08:12 <eevar2> ASA_: "having problems" isn't very specific
02:11:21 <ksf> ...and the biggest culprit is: Map.lookup
02:11:26 <ASA_> Yes, I wasn't being specific. I don't like IRC, so will find another place to ask questions and fix the problems, but thought that this would be a good place to hit lots of users and ask generally if peopleare having problems
02:12:18 <Athas> ASA_: my impression is that GHC is generally pretty solid for production use.
02:12:26 <ksf> well, "having problems" isn't more specific anywhere else, too (didn't read the question, though)
02:12:49 <ksf> Ah. I constantly runt into problems with GHC. it always tells me my types are wrong.
02:14:20 <ksf> I'd say ghc is more stable than javac, and a bit less quirky than gcc.
02:14:23 <ASA_> Generally having problems like invalid references to c calls. Not  in the haskell I write.
02:14:45 <ksf> like, linker errors?
02:15:40 <ASA_> need to jump on other computer so I can cut/paste back in a minute.
02:15:48 <ksf> @hpaste
02:15:48 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:18:53 <ASA_> OK, I'm back.
02:18:59 <ksf> @hpaste
02:18:59 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:19:03 <ASA_> Just one example:-
02:19:10 <yaxu> ASA_: use the pastebin
02:19:38 <yaxu> ASA_: use the pastebin please, irc isn't good for pasting a lot of text
02:20:52 <halcyon10> hi, can anyone explain to me whats the idea behind fixST in Control.Monad.ST?
02:21:12 <ksf> the same as fixIO and mfix
02:21:16 <ksf> :t mfix
02:21:17 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
02:21:52 <ksf> the idea is to give the result of a computation as a parameter to the computation.
02:22:21 <ksf> ...that's just value recursion, though, no loop: the action is run only once.
02:22:36 <ksf> ...and has to be sufficiently lazy, of course.
02:22:54 <ASA_> OK, dropped an example in pastebin
02:22:58 <halcyon10> ok, so i can do recursive monadic actions with it?
02:23:03 <ksf> ASA_, link?
02:23:35 <ASA_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3881#a3881
02:24:10 <ksf> use ghc -make Main
02:24:15 <ksf> er --make
02:24:43 <mux> why would you want to call the main module Main2 instead of Main though?
02:24:48 <ASA_> what a dumbass I am
02:25:09 <ASA_> two files in same folder for testing
02:25:28 <mux> they can both have "module Main" in them though, can't they?
02:25:36 <ksf> they can
02:25:47 <mux> so there's no point in calling the main module Main2
02:25:50 <ksf> you can put Main modules in files named differently
02:26:19 <ksf> a usual technique is to call the main module foo.hs, and just compile it with ghc --make foo.hs
02:26:25 <ASA_> Sorry, thought module name and file name had to agree
02:26:28 <ksf> ...you get foo[.exe], then.
02:26:36 <ksf> in all other cases, yes.
02:26:38 <halcyon10> ksf: thanks for the mfix-hint, found a useful reference: http://leventerkok.googlepages.com/erkok-thesis.pdf
02:26:42 <mux> ASA_: that's only the case for "real" modules if you see what I mean
02:26:51 <ksf> ...but a main module is alway the root of the inheritance tree, so it don't matter.
02:27:12 <ASA_> OK, thanks for the clarification.
02:28:14 <lilac> @type \f -> fix (>>=f)
02:28:15 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b
02:28:48 <ksf> lilac, that has vastly different semantics.
02:28:58 <lilac> ksf: true :)
02:30:51 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO    is quite enlightening
02:37:53 <fasta> Probably old news, but Haskell.org is down.
02:39:23 <halcyon10> yeah, just noticed it :/
02:40:29 <fasta> The web is just a bad idea for community websites.
02:40:48 <Eelis> is there a mirror of the "haskell hierarchical libraries" documentation?
02:41:20 <fasta> Distributed hosting would make a lot more sense for a project like this.
02:41:48 <Eelis> ah, found what seems to be a mirror, though i don't know how up to date it is: http://sep07.mroot.net/documentation/libraries/
02:42:01 <dv-_> hm doing record { a = b } works fine, but record { a = b, c = d } throws a runtime error about nonexaustive pattern in record update
02:42:09 <dv-_> does that mean I can only update one field?
02:43:04 <poe> http://www.google.com/search?q=cache:_48FgwqL0yMJ:www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html&strip=1
02:43:46 <halcyon10> haskell.org is up again
02:46:15 <pozic> What is a simple library to draw lines on the screen? The most important property is that it has to be easy to use, license does not matter.
02:47:15 <eevar2> hopengl?
02:49:24 <dv-_> SDL is quite easy, but you'll have to make your own line drawing function
02:50:28 <pozic> I was thinking of something like this: Prelude Graphics.DrawingCombinators> draw( line (1,1) (300,200))
02:50:45 <pozic> But, if you try that, you get a segmentation fault.
02:50:59 <pozic> Long live bindings to C libraries...
02:51:16 <pozic> (Yes, I did initialize first. )
02:51:32 <dv-_> maybe it doesn't work in ghci?
02:52:04 <pozic> dv-_: then ghci needs to be fixed. A language without an interpreter is useless.
02:54:46 <yitz> @hoogle DrawingCombinators
02:54:46 <lambdabot> No results found
02:54:58 <yitz> @hoogle draw
02:54:58 <lambdabot> Data.Tree drawForest :: Forest String -> String
02:54:58 <lambdabot> Data.Tree drawTree :: Tree String -> String
02:55:08 <pozic> http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/0.3/doc/html/Graphics-DrawingCombinators.html
02:55:32 <yitz> pozic: what graphics backend is that based on?
02:55:51 <dv-_> opengl
02:57:05 <yitz> opengl doesn't work in ghci?
02:58:35 <dv-_> i remember having similar problems with the ruby interpreter
02:58:47 <pozic> yitz: don't know, don't care if it doesn't work. Best thing would be to nuke the package from orbit.
02:59:16 <yitz> pozic: that's one option. getting it fixed might be another.
03:00:25 <yitz> but if opengl has an intrinsic problem with interactive shells, you may need to nuke opengl from orbit.
03:01:27 <pozic> yitz: it's either ghci, or the binding to the library. Regarding the package. There are too many worthless packages on Hackage.
03:02:02 <pozic> Things have changed, so that there are also a few that have value.
03:02:40 <yitz> pozic: what's worthless to you may be useful to someone else. the difficulty is being able to evaluate that.
03:02:52 <yitz> pozic: there are a number of ideas floating around.
03:03:14 <yitz> the Haskell Platform is a major first step of course, but it's not a complete solution.
03:04:10 <pozic> yitz: if a function does not run, then it is worthless. A library doesn't have to do everything, but what it does, should not crash.
03:04:52 <doserj> pozic: a function that only doesn't work in ghci is not worthless
03:05:08 <pozic> I think every package should be stress tested to hackage. That is, automatically should all compatible functions be constructed into random programs and run. If it is possible to make it crash, it should not be on Hackage.
03:06:05 <pozic> I know that there are currently libraries, where the order in which you call stuff matters for whether or not it crashes, but safe libraries (that would be the Haskell thing to do) can be constructed where this is impossible.
03:12:26 <fasta> dcoutts: Have you seen this? gtk/Graphics/UI/Gtk/General/Drag.chs.pp:174:0:<newline>  parse error in doc string
03:12:52 <ivanm> fasta: I don't think dcoutts hacks on gtk2hs any more...
03:13:18 <fasta> ivanm: ok, thanks.
03:13:33 <ksf> yitz, there's also fgl, which has a dot interface
03:13:40 <ivanm> he's too busy with Cabal + IHG stuff
03:13:47 <yitz> dot?
03:13:48 <ksf> ...trees are graphs and graphics are cool, fwiw.
03:13:54 <ivanm> yitz: or there's my graphviz lib for FGL! :D
03:14:10 <ksf> ...that's what the graphviz executable is called.
03:14:15 <ivanm> FGL's dot interface is really bad
03:14:19 <yitz> ivanm++
03:14:23 <ivanm> \o/
03:14:30 <ivanm> yay! I haz karma! :D
03:14:49 <ivanm> ksf: dot is _one_ of the graphviz executables ;-)
03:15:27 <dv-_> how am I supposed to use this DrawingCombinators library anyway? I put draw(circle) just before SDL.flip screen, but it's not showing
03:18:29 <dv-_> ah nevermind there's an example.hs
03:20:58 <jungehexe> i am trying to create executable out of my program, which consists of a few modules. i run "ghc -o PongGame PongGame.hs "  but i get the problem by importing my other modules in PongGame
03:21:06 <jungehexe> failed to load interface for `Lusterel':       locations searched:         Lusterel.hi         Lusterel.hi-boot
03:21:29 <ivanm> jungehexe: ghc --make PongGame.hs
03:21:33 <jungehexe> how do i show ghci that ih has to compile other modules
03:21:34 <ivanm> that should do everything
03:22:13 <jungehexe> ivahm: thanks
03:22:56 <ivanm> no worries
03:24:57 <jungehexe> hmm
03:25:56 <pozic> When I run this example: http://public.beuth-hochschule.de/~panitz/hopengl/skript.html#tth_sEc1.1.1 , I don't get the same result as in the tutorial. In particular it appears that the background is not being set to nothing. How do I get e.g. a white background in this window?
03:27:48 <jungehexe> but i can't run the o.file
03:27:58 <jungehexe> how do i get smth like exe
03:27:59 <ivanm> jungehexe: it shouldn't be a .o file
03:28:05 <ivanm> jungehexe: that's what --make does
03:28:12 <ivanm> jungehexe: do you have a main function in PongGame.hs ?
03:28:48 <jungehexe> yes
03:28:54 <jungehexe> i do
03:29:29 <ivanm> is it "module Main where"?
03:29:54 <pozic> Ok, it was not flushed. Never mind.
03:29:58 <ivanm> heh
03:30:39 <ivanm> jungehexe: if so, delete all the .o and .hi files and try "ghc --make PongGame.hs" again
03:32:25 <fasta> gnomevfs-0.10.1: dependency glib-0.10.1 doesn't exist (use --force to override) <- how do I get this dependency?
03:32:46 <jungehexe> atatypes.hi   Datatypes.o  Defaults.hs~  Lusterel.hs   PongGame.hi   PongGame.o  Render.hs~  Test.hs~ Datatypes.hs   Defaults.hi  Defaults.o    Lusterel.hs~  PongGame.hs   Render.hi   Render.o Datatypes.hs~  Defaults.hs  Lusterel.hi   Lusterel.o    PongGame.hs~  Render.hs   Test.hs
03:32:48 <fasta> This is during the build of a release.
03:32:50 <ivanm> fasta: gtk2hs I think
03:32:59 <jungehexe> that's the list of files i get after all
03:33:03 <ivanm> jungehexe: rm *.{hi,o}
03:33:07 <fasta> ivanm: I am building the latest gtk2hs release.
03:33:13 <ivanm> fasta: ahhh...
03:33:22 <ivanm> fasta: then it must be the gnomevfs C lib
03:33:33 <ivanm> I mean glib, not gnomevfs
03:33:38 * ivanm is guessing here...
03:33:43 <jungehexe> i did it
03:33:44 <doserj> fasta: during installation?
03:34:04 <jungehexe> but after hte new compilation i get the same list of files
03:34:15 <ivanm> jungehexe: there is no executable there?
03:34:26 <jungehexe> no :(
03:34:34 <ivanm> jungehexe: can you paste your PongGame.hs file up somewhere please?
03:35:00 <fasta> doserj: I was not very specific. I consider installation to be that what happens when I run my installation script, which includes downloading, compiling and installing. Let me have a look.
03:35:22 <fasta> doserj: During make[2]: *** [install-data-hook]
03:35:34 <fasta> ivanm: I have the dev library installed.
03:35:44 <ivanm> fasta: *shrug* no idea then
03:36:22 <fasta> ivanm: yep, that's why I asked :)
03:36:43 <doserj> fasta: I think gtk2hs wants to install into the global pgk database by default. are there write permission errors?
03:36:57 <fasta> doserj: ./configure --prefix=$HOME
03:37:07 <doserj> fasta: that doesn't change it
03:37:15 <fasta> doserj: uh, huh?
03:37:33 <doserj> fasta: that changes where the library files are put, not in what package database it gets registered
03:37:34 <fasta> I am pretty sure it doesn't need root.
03:38:17 <jungehexe> http://paste-bin.de/4ab8a8f74f47f.html
03:38:38 <fasta> doserj: ok, I will try with root.
03:38:47 <fasta> doserj: you were right.
03:38:47 <jungehexe> but it wont compile without  the other parts
03:39:11 <fasta> Systems that need root, yagh!
03:40:09 <doserj> fasta: 'ghc-pkg register --global' needs root, obviously. there should a configure flag to tell gtk2hs to register --user, though.
03:40:19 <jungehexe> :ivanm http://paste-bin.de/4ab8a8f74f47f.html
03:40:27 <dcoutts> doserj: indeed there is
03:40:27 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
03:40:31 <ivanm> jungehexe: heh, hold your horses! ;-)
03:40:42 <ivanm> jungehexe: "module Main where" <-- use that
03:40:52 <jungehexe> just wasn't sure you saw it
03:42:06 <fasta> doserj: yes, yes, I know.
03:43:17 <jungehexe> than i need to make a module Main a sa√ºparate file
03:43:22 <jungehexe> separate
03:44:16 <ivanm> jungehexe: no, just put it in PongGame.hs ;-)
03:44:23 <jungehexe> i did
03:44:27 <jungehexe> it didn't compile
03:44:30 <ksf> ...and call the module Main
03:44:34 <ivanm> weird :s
03:44:43 <ivanm> ksf: you mean the filename? that isn't needed
03:44:44 <jungehexe>  file name does not match module name `Main'
03:45:00 <ksf> ghc --make?
03:45:04 <ivanm> oh, right, then you need optimisations
03:45:07 <jungehexe> yes
03:45:09 <ivanm> jungehexe: ghc -O2 --make
03:45:56 <ksf> ...the main module doesn't need matching module and file names, as it's at the root of the inheritance library and ghc already knows where to find the file
03:46:18 <jungehexe> kira@top-kaetzchen:~/DA/Work/pong_git$ ghc -O2 --make PongGame.hs  PongGame.hs:1:7: file name does not match module name `Main'
03:47:08 <ivanm> :o
03:47:17 <ivanm> weird.... I don't have this problem :s
03:47:52 <jungehexe> :(
03:48:37 <ivanm> this is what I sue to compile my apps: ghc -O2 -Wall -funbox-strict-fields --make <filename.hs>
03:48:45 <ivanm> where filename doesn't have to be Main.hs
03:50:15 <jungehexe> if i compile Maine
03:50:16 <ksf> ghc --make -O2 Demo
03:50:16 <ksf> ./Demo
03:50:16 <ksf> 0.000011s
03:50:21 <jungehexe> than i get executable
03:50:32 <jungehexe> but i's called Main
03:50:41 <jungehexe> and i wanted it to be called Pong game
03:50:55 <ivanm> jungehexe: which version of ghc do you have?
03:51:03 <ivanm> maybe it's a bug in an older version...
03:51:17 <ksf> % head -n 3 Demo.hs
03:51:17 <ksf> {-# LANGUAGE DeriveDataTypeable, MultiParamTypeClasses, BangPatterns, ScopedTypeVariables #-}
03:51:17 <ksf> module Main where
03:51:17 <ksf> module Main where
03:51:20 <jungehexe> ghc --version The Glorious Glasgow Haskell Compilation System, version 6.8.2
03:51:51 <ksf> erm that were supposed to be three lines
03:51:51 <ivanm> yeah, IIRC I had some bugs with 6.8.2
03:52:33 <ksf> 6.12 is coming out any week now, you should really be using 6.10.4 by now...
03:53:19 <jungehexe> well, i use standartd ubuntu repositories
03:53:30 <jungehexe> i have no idea why there cam no update
03:53:40 <jafet> ubuntu is in the dark ages as usual
03:53:43 * ivanm could answer, but it wouldn't be polite
03:53:43 <ivanm> ;-)
03:53:49 <ksf> because ubuntu is based on debian, and debian is outdated by default
03:54:07 <ivanm> heh, coincidentally I just got to the bit about ubuntu Haskell packages in the symposium videos ;-)
03:54:08 <jungehexe> a propos ksf
03:54:17 <ivanm> ksf: they're working on it, apparently
03:54:19 <jungehexe>  the % didn't go through
03:54:20 <Smokey`> "debian is outdated by default" <-- I've never heard anything so naive in my entire life.
03:54:28 <ivanm> and they say due to the feature freeze, it's 3 months out of date on release
03:54:35 <ksf> that's my shell prompt.
03:54:51 <ksf> standard zsh prompt.
03:55:09 <Smokey`> debian is a community based project, if no one from the haskell community bothers to keep the haskell packages up to date and in accordance with the debian QA process - then clearly their packages won't be up to date.
03:55:25 <ivanm> Smokey`: as with any community-based/driven distro
03:55:28 <jungehexe> Smokey, please don't start holywar
03:55:39 <Smokey`> ivanm: exactly.
03:55:53 <ivanm> Smokey`: though I think they were referring to debian stable as being outdated (I would say by design, not by default)
03:56:06 <jungehexe> anyway.
03:56:11 <Smokey`> ivanm: stable in itself tends to imply outdated :P
03:56:14 <jungehexe> i assume that with my compiler
03:56:19 <mmmdonuts> debian stable is for grown-ups. :P
03:56:34 <ivanm> Smokey`: but debian takes it too the extreme :p
03:56:42 <jungehexe> there'S no way to create executable called in some other way as main
03:56:46 <ksf> so then, why is gentoo's current stable 6.10.1 and testing 6.10.4?
03:56:50 <Smokey`> ivanm: no one's stopping you from using squeeze.
03:56:53 <ivanm> ksf: because kolmodin is lazy :p
03:56:54 <Smokey`> or sid, if you dare :P
03:57:05 <ivanm> Smokey`: but I don't use any debian :p
03:57:08 <ksf> (and why is it so much easier to install testing packages on gentoo?)
03:57:13 <ivanm> (well, I've got my mum using mint...)
03:57:26 <jungehexe> :(
03:57:34 <ivanm> ksf: we're working on having the platform in the tree, plus common apps like pandoc, gitit, etc.
03:57:37 <ksf> could it be because the gentoo community wants people to use testing packages, so they get -- gosh -- tested?
03:57:39 <ivanm> but everything else will be in the overlay
03:57:54 <ivanm> ksf: nah, it's because devs can't be bothered asking for stabilisation :p
03:58:19 <vegai> even though I'm not a big fan of Debian (obviously), their QA process is quite a lot above the others'
03:58:25 <Smokey`> gentoo has no strict QA process, once you get package repo rights, you can do anything and no one cares, no one will stop you, and no one will revert your changes.
03:58:27 <SamB_XP> ksf: easier than what ?
03:58:28 <ksf> what's a bit strange is that 6.10.1 certainly has more known bugs than 10.6.4
03:58:38 <ksf> e.g. debian.
03:58:49 <ksf> you have to move the whole distro to testing/unstable
03:58:57 <jungehexe> one more
03:59:02 <jungehexe> question
03:59:05 <SamB_XP> you mean ... there are other distros than testing/unstable ?
03:59:08 <ivanm> Smokey`: no, in gentoo it can only be marked stable by an arch team member after it has gone 30 days without bugs
03:59:19 <SamB_XP> I thought that was just a story to scare small children!
03:59:21 <jungehexe> i gave up getting a nice name for executable
03:59:27 <Smokey`> ivanm: then they've changed that recently (2 years ago, that was not the case.)
03:59:38 <jungehexe> but how can i compile it so that it gets a bit more memory
03:59:45 <jungehexe> it hangs on running
03:59:47 <ivanm> Smokey`: *shrug* I would have only started using Gentoo about 2 years ago ;-)
04:00:01 <jungehexe> and it doesn't happen if i stratthe leaded file
04:00:29 <jungehexe> and it doesn't happen if i start the loaded file from ghci
04:00:47 <SamB_XP> jungehexe: maybe you're using the wrong RTS?
04:00:59 <jungehexe> RTS?
04:01:02 <SamB_XP> what RTS does ghci use? is it different from the default one?
04:01:19 <ksf> runhaskell uses -threaded
04:01:23 <ksf> dunno about ghci
04:01:59 <jungehexe> what is a RTS after all
04:02:08 <ksf> run time system
04:02:16 <ksf> ...the equivalent of libc for haskell
04:02:23 <ksf> (a bit more involved)
04:02:38 <SamB_XP> it's the little bits of C and Cmm that a GHC-compiled program needs to run
04:02:46 <jungehexe> ok
04:02:58 <SamB_XP> including the garbage collector, the schedular, and the primitives
04:02:59 <ksf> garbage collector, scheduler, such things.
04:03:35 <jungehexe> ok, so is it possible to sy by compilation that a programm needs some more memory as usually
04:04:02 <ksf> usually it should take less.
04:04:08 <ksf> did you do a heap profile, yet?
04:04:38 <jungehexe> what is a heap profile
04:04:46 <jungehexe> ?
04:05:24 <ksf> a fancy diagram telling you what kind of type/ what closures take up how much memory, over time.
04:06:38 <jungehexe> says me nothing
04:07:21 <SamB_XP> ksf: did you say anything after you said basically what I had just said ?
04:07:44 <ksf> I said something about heap profiles
04:08:47 <jungehexe> yea, but it's theortical and i don't know what could i do to retrieve this info
04:09:24 <eevar2> jungehexe: you want to e.g. allocate more stack space to your program than normal? think you only can do that with a runtime flag, not during compilation
04:09:46 <jungehexe> :(
04:09:50 <ksf> looks like this: http://img14.imageshack.us/i/demo.pdf
04:10:11 <jungehexe> can't open the link
04:10:42 <ksf> compile with -prof -auto-all, and run with +RTS -h[c|y|d] (look at +RTS --help)
04:10:51 <jungehexe> eevar2, that's bad, i hope there is some way
04:10:59 <eevar2> jungehexe: or.. actually, you can
04:11:02 <ksf> ...then you get an .hp file, which you can convert to ps with hp2ps -c
04:11:20 <eevar2> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
04:11:23 <eevar2> see 4.14.7
04:11:43 <eevar2> for compiling in some default run-time options
04:11:53 <ksf> there,s a way, which involves plugging into the binary at c-level and messing with argv, iirc.
04:12:32 <ksf> jungehexe, append a / to the url
04:14:34 <eevar2> jungehexe: anyways. you don't want to specify run time options, even if I understood you as asking for that. read some more context now, and you should fix your algorithm, e.g. using a profiler like ksf suggests
04:17:03 <jungehexe> ok, i found out the way to rename executable :)
04:17:19 <jungehexe> but still didn't get the profiling
04:17:39 <jungehexe> ghc -o PongGame  --make Main.hs
04:17:47 <jungehexe> that renames a file
04:18:14 <ksf> jungehexe, http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
04:22:18 <ivanm> bugger, now I've just found proof that I'm over-using Sets...
04:22:25 <ivanm> since I have a case where I _do_ want duplicates :s
04:22:34 * ivanm bangs his head against a convenient surface
04:25:35 <jungehexe> ok, profiling doesn'T work any way, as somehow there are not profiling lib for soe in repo
04:31:01 <ksf> well, compile them.
04:32:37 <jungehexe> HOW
04:33:36 <Saizan> http://www.haskell.org/gtk2hs/download/ <- you can get the sources from here
04:34:23 <dv-_> When I try to draw sprites or fonts with Graphics.DrawingCombinators I just get white rectangles. any clues?
04:34:40 <dv-_> drawing primitives works fine
04:38:04 <halcyon10> is there a way to save the state of an ST action after i executed it via runST ? basically instead of runST :: (forall s. ST s a) -> a i want runST2 :: (forall s. ST s a) -> (ST s a, a)
04:41:00 <ksf> @hoogle a -> (ST s a, a)
04:41:00 <lambdabot> No results found
04:41:04 <ksf> hmmm.
04:41:10 <ksf> iirc it's a standard function
04:41:54 <ksf> nah, state had that.
04:42:22 <Saizan> halcyon10: what should it do?
04:42:29 <ksf> ...which is probably what you want to use, anyway.
04:43:57 <halcyon10> yeah, i also thought about state. basically i want to use the PRNG in the statistics package, which uses a ST monad to save the state of the random number generator: http://hackage.haskell.org/packages/archive/statistics/0.3.3/doc/html/Statistics-RandomVariate.html
04:45:01 <halcyon10> at the moment i'm using it like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9702#a9702
04:45:06 <ksf> ...well, use save.
04:45:22 <Saizan> yeah, use save and restore
04:45:42 <halcyon10> but this has the disadvantage that i can only generate new random numbers inside runST.
04:46:05 <halcyon10> oh, didn't know about save and restore, i'll look them up, thanks!
04:46:57 <ksf> do you just want the random gen or the statistics package?
04:46:58 <Saizan> they are in the page you linked
04:47:28 <halcyon10> i just need the Statistics.RandomVariate part of the library at the moment
04:48:17 <halcyon10> but i'm learning Monads and the ST-Monad along the way, so it's all kind of new to me atm
04:49:00 <ksf> sadly, don's version of mersenne-random is crippled, it uses the value-by value approach, while sfmt is meant to return large chunks of values
04:49:38 <halcyon10> what's sfmt?
04:50:01 <ksf> http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/
04:50:17 <ksf> the fastest and best-quality non-crypto prng there is
04:50:31 <halcyon10> ah, the SIMD version of Mersenne Twister, i see
04:51:51 <ksf> the maths and assembly are brilliant, code encapsulation+purity is abysmal.
04:52:17 <Jafet> MT is overrated
04:52:30 <halcyon10> after reading http://www.serpentine.com/blog/2009/09/19/a-new-pseudo-random-number-generator-for-haskell/ it looked to me as if the statistics-PRNG is the currently nicest solution
04:53:03 <ksf> ...it's only faster than sfmt because the bindings don't use sfmt correctly.
04:54:26 <Saizan> so it's the nicest solution unless you want to rebind sfmt differently, or maybe reimplement, i've read that the C lib is full of globals
04:54:27 <halcyon10> would it help if mersenne-random would encapsulate the mutable generator state in an ST-Monad like in the statistics-package?
04:54:43 <ksf> "full of" is a bit exaggerated.
04:54:55 <ksf> there's maybe two or three structs
04:55:16 <Saizan> heh, yeah, but a global is enough to prevent a nicer interface
04:55:18 <ksf> the important part is to generate arrays.
04:55:30 <ksf> it's not hard to hack the source /me means.
04:57:34 <SamB_XP> ksf: what about statics ?
04:58:12 <ksf> there is...
04:58:35 <ksf> a static array, a static double, a static int and an is_initialized flag
04:59:39 <SamB_XP> ksf: so, why haven't you bound it right yet ?
05:00:16 <ksf> because I was content with the single-double interface as switching to sfmt completely dissolved the prng bottleneck.
05:01:02 <ksf> ...and, frankly, I don't like hacking c unless I need to, anymore.
05:01:17 <halcyon10> in which module do save and restore live?
05:01:27 <ksf> the one you posted
05:02:02 <halcyon10> oh *doh* thanks...
05:02:31 <yakov> hey
05:04:44 <yakov> is it possible to add new clauses to an existing function with TH?
05:05:05 <ksf> not under the same name, but in general, yes.
05:05:14 <yakov> I don't want to write foo ..pattern.. = $(someTH) though..
05:05:57 <ksf> you can get the source of a whole function and then just add to the list of patterns
05:06:26 <ksf> ...so you have foo = $(someTH 'bar)
05:07:00 <ksf> erm no.
05:07:11 <ksf> $(someTH "foo" 'bar)
05:07:17 <ksf> ...you need to output a definition
05:07:33 <ksf> ...but a case would work too, of course.
05:08:44 <yakov> aha.. but the unavoidable pain is to have 2 names for same thing
05:09:53 <ksf> well, they're not the same.
05:10:27 <yakov> exactly, bar is foo with several additional patterns
05:10:42 <yakov> anyway how one could get functions clauses in TH?
05:10:58 <yakov> reify does not return this info :-(
05:11:40 <yakov> "exactly, bar is foo with several additional patterns"-- if i understand you correctly
05:13:24 <ksf> ...VarI should have a FunD inside it.
05:13:42 <ksf> foo is bar with added patterns
05:13:59 <yakov> argh.. sorry.
05:14:00 <yakov> sure!
05:14:06 <yakov> i've missed that.
05:14:15 <yakov> ksf, thanks you for the tip!
05:14:27 <ksf> the thing you can't get is instance declarations.
05:14:49 <ksf> which is a quite big oversight in the api
05:18:26 <lilac> yakov: you don't need TH for that! bar (YourPattern1) = yourValue1; bar (YourPattern2) = yourValue2; bar a = foo a
05:19:43 <yakov> lilac, well, i do need TH because I *generate* code to handle these patterns. you've missed the point. I don't want to write N chunks I want to do it once uniformily and instantiate.
05:20:40 <lilac> yakov: you mean that the 'YourPattern' and 'yourValue' are to be generated with TH?
05:20:48 <yakov> yup
05:21:01 <lilac> the technique still applies. generate the stuff you need to generate, then just call foo with the rest
05:21:44 <lilac> as you say, you need 'foo' and 'bar' to have different names :-/
05:21:50 <yakov> you see I don't want to write tedious fun pat1 = $(foo a1 a2..) fun pat2 ..
05:21:58 <lilac> what are you doing, if you don't mind me being nosy? :)
05:22:09 <yakov> i will have fun' with base cases written by hand
05:22:25 <yakov> and genRest to make fun from fun' and general cases written in TH ;-)
05:22:43 <yakov> lilac, i'm handling operators in Abstract Syntax :-)
05:23:51 <beutdeuce> Hry, is there anyway i can take a look at the logs (if there are any) for all conversations that happened yesterday on this channel?
05:24:15 <lilac> yakov: ah, that old chestnut. :)
05:24:29 <lilac> beutdeuce: see the topic :)
05:24:34 <lilac> beutdeuce: http://tunes.org/~nef/logs/haskell/
05:24:38 <beutdeuce> http://tunes.org/~nef/logs/haskell/
05:24:41 <beutdeuce> thnx
05:24:55 <beutdeuce> wait
05:24:58 <beutdeuce> those are 04-05
05:25:09 <beutdeuce> nvm
05:34:38 <beutdeuce> how would i be able to pass a string to a haskell program as an argument through standard in?
05:35:43 <halcyon10> getArgs
05:36:12 <beutdeuce> so
05:36:14 <ziman> beutdeuce, do you mean commandline argument or stdin?
05:36:22 <halcyon10> oh, sorry, thought you were referring to command line parameters, nevermind
05:36:34 <lilac> for stdin use getContents or one of its brethren
05:36:35 <beutdeuce> i was
05:36:38 <beutdeuce> o
05:36:39 <beutdeuce> ?
05:36:57 <beutdeuce> i mean like ru na haskell prog like ./test "hello.in"
05:37:02 <beutdeuce> and it would then read the file hello.in
05:37:46 <lilac> beutdeuce: that's a command-line argument, and not stdin :) use getArgs as halcyon10 said for that
05:38:07 <beutdeuce> but getArgs returns IO [String] right?
05:38:14 <halcyon10> beutdeuce: yes
05:38:25 <lilac> right. you need to make sure you got the right number of arguments, pull out the one you want and use something like readFile
05:38:31 <beutdeuce> so, how do i get the first parameter passed to it?
05:39:00 <lilac> for a quick hack you can use: "do [file] <- getArgs; contents <- readFile file; ..."
05:39:27 <lilac> but really you should do something better than using fail if you didn't get exactly one argument (or if the file can't be found or...)
05:41:15 <beutdeuce> thndx
05:53:56 <segv> is this a valid construct on Hugs?
05:53:59 <segv> http://pastebin.ca/1575185
05:54:55 <doserj> missing data
05:55:27 <segv> hehe
05:55:44 <segv> dort: thanks
05:55:56 <segv> *doserj
05:56:25 <dv-_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9703 could someone take a look at this?
05:56:53 * jkff has implemented "selective receive" with the magnificent first-class-patterns package and Control.Concurrent.Chan and is satisfied by the (not yet completely working) result.
06:08:48 <ksf>  jkff what for? you can implement map and fold on Chans...
06:09:06 <jkff> ksf: What do you mean?
06:09:20 <ksf> ...so you can also do filter.
06:09:54 <ksf> split should be easy, splice, too.
06:10:06 <jkff> ksf: Hmm. Is that really a substitute for selective receive?
06:10:25 <ksf> actually, I'm just wondering why I didn't yet implement half of reactive's api in stm.
06:11:45 <ksf> well, I guess that depends on what exactly you mean by it and whether you're dead-set on a particular abstraction
06:11:46 <jkff> Well.... Suppose I've got a process that expects 3 Apple's and 5 Orange's from a chan and then prints something. You mean I should do a getChanContents on the chan, get 2 lazy lists: one for Apple's, the other for Orange's, and take 3 from first and take 5 from second?
06:12:00 <jkff> (Another process is writing apples and oranges into the chan randomly)
06:12:24 <ksf> nope, spawn a thread that reads the chan and feeds it into two.
06:12:47 <jkff> Into two what?
06:12:54 <ksf> using stm, that should have near-zero overhead.
06:12:56 <ksf> chans
06:13:16 <jkff> That's not quite as syntactically comfortable as a pattern match
06:13:43 <ksf> but way more composable
06:13:54 <jkff> With first-class patterns things are composable, too
06:14:08 <jkff> (at least it seems so to me)
06:14:25 <ksf> split :: (a -> (b, c)) -> Chan a -> (Chan b, Chan c)
06:14:44 <ksf> map :: (a -> b) -> Chan a -> Chan b
06:14:49 <ksf> (well that's fmap)
06:15:18 <jkff> You mean, IO (Chan b) and IO (Chan b, Chan c)
06:15:42 <saml> > IO 2
06:15:42 <lambdabot>   Not in scope: data constructor `IO'
06:16:12 <ksf> yep.
06:17:33 <jkff> ksf: by the way, in which ways would you compose processes with a mailbox? I'm thinking of, for example, "adding a timeout clause", "parallel left-biased composition" (a message goes to whoever is the first to match it), what else?
06:19:49 <ksf> timeouts are filters (but I don't think I will need them), and composition...
06:20:05 <ksf> heck I just don't know what I'd use it for so I never thought about it.
06:20:58 <ksf> I'm doing plain many-to-one communication, mirroring if nescessary.
06:21:20 <ksf> (that is, pass an TMVar alongside with a request over a chan)
06:22:57 <jkff> Probably one should just take some srs erlang program and stare at it :)
06:24:05 <ksf> stm is truly a marvellous thing.
06:24:32 <ksf> I switched back to it after giving chp a try and found it to be excessively verbose and, most importantly, highly inefficient.
06:24:52 <jkff> What is chp?
06:24:58 <ksf> got to do some newtypes to distinguish between readable and writeable chans and vars, some time.
06:25:03 <ksf> @hackage chp
06:25:03 <lambdabot> http://hackage.haskell.org/package/chp
06:25:08 <jkff> Ah
06:25:17 <jkff> Ooh
06:25:18 <ksf> it's base on concurrent sequential processes, a process calculus
06:25:19 <jkff> Cool :)
06:25:42 <ksf> ...which you can use to do stuff like proving absense of deadlocks formally
06:27:35 * ksf never succeeded constructing a deadlock in stm, though, it always got killed instantly by the rts.
06:27:42 <ksf> lifelock should work, though.
06:41:35 <halcyon10> how can i restrict a parameterized type to members of a specific typeclass. for example i have: data Foo a = Foo a    and i want that a is a member of typeclass Num
06:43:18 <Botje> i think you can do that with GADT's, but i'm not sure about other ways
06:43:22 <Saizan> you don't, you just require a to be Num in the functions that use Foo
06:43:42 <Jafet> Simply parametrize it to be Num, instead of arbitrary type a
06:43:59 <Saizan> Jafet: what do you mean by that?
06:44:16 <halcyon10> Saizan: ok, i see, thx
06:44:22 <Botje> data Foo a where Foo :: Num a => a -> Foo a -- something like this?
06:44:37 <blackdog> wow, that was weird. dreamed about trying to fix a Cabal bug all night.
06:44:48 <Jafet> Wait, I'm probably thinking in ghc again
06:44:59 <blackdog> if only i'd lodged a bug while i was sleeping..
06:45:24 <Saizan> Botje: that works, but it's a bit different and not generally required
06:45:57 <Botje> I never really got the idea behind GADTs anyway. now's a good time to read, i guess :)
06:47:19 <Saizan> mh, the fundamental idea is about type refinements, though they are also the place where they put "nicer semantics that differ from h98" when they find them :)
06:49:08 <lpjhjdh> is there a pre-existing, efficient sorted-list-like structure?
06:49:35 <blackdog> lpjhjdh: what sort of operations do you want on it?
06:49:37 <halcyon10> Botje: thats what i wanted, but i think i'll stick with the constrained parametrized types in the functions that use Foo a then, like Saizan suggested, just didn't thought about that before
06:49:39 <Saizan> with or without duplicates?
06:49:53 <lpjhjdh> blackdog: lookup and insertion
06:50:06 <Saizan> lpjhjdh: Data.Set ?
06:50:50 <blackdog> lpjhjdh: lookup by position, or highest/lowest? binary search?
06:51:18 <Saizan> or Map a [a] or Map a Int
06:51:29 <blackdog> a straight sorted array is tricky because you can't get sharing easily
06:51:52 <lpjhjdh> blackdog: I actually need removal too
06:51:53 <blackdog> so you have to prove to haskell that you're only going to use it in a safe way, which means putting it in the ST monad
06:52:08 <blackdog> which is a pain
06:52:50 <lpjhjdh> blackdog: I need this to be really efficient, would destructive updates really speed it up?
06:53:07 <lpjhjdh> blackdog: I haven't really done anything that needed to be high performance so I'm pretty ignorant
06:53:07 <yakov> ksf, I've tried to reify (mkName "fun") to get clauses.. and it has failed. it returned Nothing as decs :-9
06:53:10 <yakov> :-(
06:53:18 <yakov> seems like reify cannot compute function clauses
06:53:35 <yakov> do anybody know if it's so?
06:54:54 <Saizan> you can't access function bodies with reify
06:55:07 <Saizan> ghc doesn't even store them for installed packages.
06:55:55 <blackdog> lpjhjdh: you haven't specified the operations you need yet, so it's hard to give useful advice
06:56:31 <blackdog> what do you mean by each of those operations? does lookup just tell you if an element is in the structure?
06:57:41 <blackdog> if so, a Set should be fine
06:57:55 <lpjhjdh> blackdog: oh, I'm an idiot, it looks like Data.Set will be perfect actually since removal is always max, thanks for the help
06:57:58 <yakov> Saizan, this is bad, because so i can't add clauses to functions at compile time which is quite strange
06:59:08 <Saizan> not so strange for me, but i guess we have different backgrounds :)
06:59:32 <HugoDaniel> hi
06:59:43 <HugoDaniel> return should be changed to "return $"
06:59:47 <HugoDaniel> in haskell' :)
07:00:59 <blackdog> lpjhjdh: np
07:03:12 <ivanm> HugoDaniel: why?
07:03:22 <ivanm> if you're just saying something like "return 2" ?
07:03:30 <HugoDaniel> its more practical :D
07:03:36 <ivanm> not really
07:03:43 <ivanm> and doesn't fit in with the rest of the syntax
07:03:46 <ivanm> in terms of arity, etc.
07:03:53 <ivanm> e.g. what arity would return have?
07:04:08 <ivanm> would something like "return zip3 as bs cs" still be valid?
07:04:15 <ivanm> if so, return would have an undefined arity
07:04:24 <ivanm> and how would you then define instances for it?
07:05:37 <yakov> Saizan, i've gave my brain few cycles more to decide and yup it's even meaningless to demand such feature when in functional language all function supposed to be total already :-)
07:06:45 <DuClare> Can I do ioctls from within Haskell somehow? :|
07:07:05 <mux> sure you can; that may require you writing FFI calls though :-P
07:07:16 <yakov> DuClare, check ML for the solution about writing argv FFIs..
07:07:30 <mux> I guess it would be wisest to ask you what kind of ioctl() you want to call and why first though
07:07:49 <mux> ideally you shouldn't have to do that
07:08:06 <DuClare> I'm trying to play around with /dev/dsp
07:08:40 <mux> well you'll need to write FFI calls indeed
07:11:37 <Saizan> ivanm: he was proposing to make return a keyword, i guess
07:12:38 <ksf> DuClare, we have sdl bindings, too, so if you don't requrie low-level access...
07:12:44 <yaxu> DuClare: you might be able to get something like sox to do the ioctls for you
07:12:57 <ksf> ...you get the additional benefit of automagically supporting other sound backends.
07:14:53 <ksf> no wait we have jack bindings.
07:14:59 <ksf> use jack, if you can.
07:15:42 <ksf> ...doesn't seem to compile, though. use openal if you can, then.
07:16:18 <fr0ggler> hopefully a simple question - if I have a function 'bar' that returns IO (Either String a), how would I then use that in an action? i'm trying foo <- bar ..params.. and I'm getting the expected/inferred type mismatch error
07:16:33 <nominolo> @seen kowey
07:16:33 <lambdabot> Unknown command, try @list
07:16:54 <mux> fr0ggler: the problem lies in what you do with the "foo" after that line
07:16:56 <ksf> fr0ggler, that's exactly how it's done
07:17:05 <HugoDaniel> where is the readability in this: map (flip (++) "\n" . show) lstd  ? :/
07:17:06 <mux> fr0ggler: typically you'd case it like so:
07:17:08 <mux> case foo of
07:17:12 <mux>   Left s -> ...
07:17:15 <mux>   Right x -> ..
07:17:17 <HugoDaniel> is there any simpler way to do it ?
07:17:19 <mux> or use the either function
07:17:21 <ksf> case Foo of Left ... -> ... ; Right -> ...
07:17:39 <mux> :t eithe'r
07:17:40 <lambdabot> Not in scope: `eithe'r'
07:17:41 <mux> :t either
07:17:41 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
07:17:42 <ksf> or say (Right foo) <- bar, if you're feeling adventurous
07:18:07 <Botje> HugoDaniel: i'd write map (++ "\n") lstd
07:18:12 <mux> ksf: why are you suggesting newbies to have partial pattern matches in their IO code? :-(
07:18:17 <fr0ggler> ksf, mux, thanks a lot - i'll try those out :) i'm not feeling adventurous - imperative->functional is hard :D
07:18:26 <Botje> err
07:18:29 <mux> fr0ggler: oh yes it is, don't worry, we know the pain :-)
07:18:44 <Botje> map (++ "\n") $ map show lstd
07:19:02 <Botje> HugoDaniel: or just unlines $ map show lstd if you want them joined together
07:19:24 <ksf> mux, yes. it's useful for a) rapid prototyping b) getting a standard MonadFail class as the new home of fail
07:19:28 <ksf> that'd be win.
07:19:28 <doserj> map (show >>> (++"\n")) lstd
07:19:40 <Botje> heh :]
07:19:43 <benmachine> HugoDaniel: flip (++) "\n" is the same as (++ "\n")
07:19:51 <benmachine> operator sections woo
07:19:55 <mux> ksf: at least explain him why it's not such a good idea in the common case..
07:19:56 <HugoDaniel> :)
07:20:20 <benmachine> wait
07:20:24 <benmachine> I wasn't scrolled down
07:20:25 <benmachine> whoops
07:20:26 <HugoDaniel> but i need to call show
07:20:27 <HugoDaniel> :)
07:20:32 <ksf> I think the pattern match errors are informative enough.
07:20:44 <benmachine> so ((++ "\n") . show) ?
07:21:02 <nominolo> any darcs experts here?
07:21:15 <HugoDaniel> benmachine: hence the flip ;)
07:21:44 * benmachine hardly ever uses flip
07:22:06 <benmachine> I think either operator sections or explicit lambdas are usually clearer
07:22:08 <HugoDaniel>  map ( (++ "\n") . show) lstd
07:22:14 <HugoDaniel> is not much more readable :/
07:22:22 <benmachine> 'tis
07:22:27 <mux> that's very readable
07:22:29 <benmachine> to me, anyway
07:22:30 <ksf> that's very readable.
07:22:38 <HugoDaniel> ok
07:22:39 <benmachine> it means, show and then add a newline on the end
07:22:49 <benmachine> to every thing in lstd
07:22:49 <HugoDaniel> ok
07:22:54 <HugoDaniel> i need to practice my readability
07:23:00 <mux> it means convert any element in the list to its string representation and add a newline at the end of each string thus produced
07:23:52 <ksf> you could also use map (flip (showsPrec 0) "\n") lstd
07:23:55 <dcoutts> blackdog: hah! Was it a nightmare? :-)
07:24:08 <ksf> ...which is moar faster.
07:25:04 <ksf> ...or just plain mapM print lstd
07:25:10 <blackdog> dcoutts: it kind of was, actually. i needed some feature (can't even remember what now) and there was just no way to do it.
07:25:30 <blackdog> dreaming about haskell all night long. i blame don.
07:27:23 <sohum> :t print
07:27:23 <lambdabot> forall a. (Show a) => a -> IO ()
07:29:59 * ksf thinks show and read should be deprecated, serialize and deserialize classes introduced, and finally show replaced by the IPPrint code
07:30:39 <blackdog> ksf: all just part of the whole String = [Char] mess...
07:30:54 <ksf> oh, yes.
07:30:56 <sohum> ksf, you mean, show and read should be renamed serialise and deserialise?
07:31:01 <ksf> yep.
07:31:17 <ksf> ...and show should do pretty-printing for human consumption.
07:31:25 <sohum> I'd settle for a standard Pretty typeclass
07:31:47 <DuClare> yaxu, Thanks, sox works great :)
07:31:55 <ksf> it should be one typeclass, actually.
07:32:03 <blackdog> ksf: so you'd have to recover the structure from the serialised string when you wanted to pretty-print?
07:32:18 <ksf> IPPrint does that.
07:32:24 <yaxu> DuClare: nice, what arguments are you giving it out of interest?
07:32:43 <jfoutz> pretty; read, show; binaryread, binaryshow
07:33:20 <jfoutz> a human-readable text serialization is very handy.
07:33:59 <blackdog> ksf: i hadn't seen ipprint, that's rather cool.
07:34:00 <ksf> can't we just replace String with Sequence Char?
07:34:05 <sohum> can't binread and binshow just be gzip . show and read . unzip?
07:34:13 <ksf> hell no
07:34:25 <ksf> binary is fast, as opposed to read/show
07:34:31 <sohum> ah
07:34:33 <sohum> fair enough
07:34:39 <blackdog> ksf: i guess you don't get much control about layout then, but if the heuristics are good enough...
07:34:58 <ksf> let's say they're readable.
07:35:04 <blackdog> if you're putting out something with a really complex structure i suppose you'd write special code anyway.
07:35:19 <sohum> @src Sequence
07:35:19 <lambdabot> Source not found. I feel much better now.
07:35:27 <sohum> *snerk*
07:35:33 <ksf> word-wrapping and indenting are the most important features.
07:36:01 <sohum> ksf: what's this Sequence thing?
07:36:13 <ksf> http://hackage.haskell.org/packages/archive/containers/0.2.0.0/doc/html/Data-Sequence.html
07:36:38 <ksf> we need generalized pattern matching.
07:36:41 <blackdog> it would be nicer to have a Stringy typeclass, i think
07:36:42 <jfoutz> actually... if there is a serialize/deserialize typeclass, it could be instanced binary, read/show, XML, and whatever else you might feel like.
07:36:51 * jfoutz comes around to ksf's way of thinking
07:36:53 <sohum> ksf: ah. that's pretty cool
07:37:04 <sohum> ksf: and yus. generalised pattern matching....
07:37:05 <ksf> but then, we _do_ have view patterns...
07:37:41 <fr0ggler> mux, ksf, sorry, just to clarify - i would do "foo <- bar params" and then "case foo of Left err -> err; Right x-> (not sure what goes here)"
07:38:14 <fr0ggler> or "case bar params of Left ... ; Right ... ;"
07:38:25 <benmachine> > either id (+1) $ Right 2
07:38:26 <lambdabot>   3
07:38:34 <Botje> that depends on the type of bar.
07:38:55 <Botje> if bar is pure can do case bar params of ..
07:39:00 <fr0ggler> Botje, the return of bar is IO (Either String a)
07:39:07 <Botje> then you need the first form.
07:39:12 <ksf> > let (viewR ->  _ :> 'a') = "woot" in (Data.Sequence.fromList "cda")
07:39:12 <lambdabot>   Illegal view pattern:  (viewR -> _ :> 'a')
07:39:12 <lambdabot>  Use -XViewPatterns to enable vi...
07:39:30 <sohum> ...view patterns?
07:39:54 <fr0ggler> Botje, ok, thanks. and in that case, what would be the action for Right?
07:40:03 <ksf> http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/syntax-extns.html    8.3.5
07:40:13 <Botje> fr0ggler: err, you use x in whatever fashion you deem appropriate :)
07:40:17 <ksf> you can also use them to replace fmap in monadic code
07:40:20 <benmachine> it'd presumably have to produce a String
07:40:25 <benmachine> to match the type of the Left branch
07:40:31 <Botje> i didn't follow the discussion so i don't know the history of your question
07:40:33 <ksf> toUpper -> foo <- bar
07:40:50 <benmachine> (because the case is a single expression and has to have a single type)
07:41:30 <Botje> fr0ggler: can you show code and/or explain what you're trying to do?
07:42:09 <Orclev> ok, I'm now officially spending too much time in here... first thing I did when I got up was to scroll back through my logs and read everything that happened since I went to bed
07:42:24 <ksf> bytestrings should be sequences, too.
07:42:33 <fr0ggler> Botje, I think that may be easier yeah :) 2 secs...
07:42:57 <Botje> Orclev: report to an asylum if you start seeing monads under your bed :)
07:43:00 <ksf> ...and sequence should be a class.
07:43:11 <fr0ggler> Botje, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3883#a3883
07:43:15 <Botje> Orclev: and I do the same for a number of other channels, don't worry :)
07:43:19 <Orclev> Botje: I'm safe for now, I don't fully understand monads yet
07:43:40 <fr0ggler> im basically trying to load and save an xml fragment using hexpat-pickle
07:44:11 <Botje> fr0ggler: oh. i think you have to do Right o -> putStrLn ( ... ++ ... )
07:44:18 <Botje> ++ has a lower precedence than $ i think.
07:45:05 <Botje> as an aside: i'd put the type annotation for ont in the case
07:45:12 <Botje> case ont :: OS.Ontology of ...
07:45:13 * ksf , as a lisp convert, doesn't know of such problems.
07:45:37 <Botje> but you're a /convert/! you've sworn off your parens! :)
07:45:42 <jfoutz> hehe
07:45:56 <Botje> fr0ggler: also, you could make a function for the when verbose thing.
07:46:08 <sohum> oh, well, you can't swear off lisp /entirely/
07:46:26 <DuClare> yaxu, sox -t raw -s 1 -r 8000 - -t oss -s 2 -r 44100
07:46:50 <sohum> there's always a part of your psyche that's trying to figure out what you'd need to write a metacircular evaluator in your current language
07:47:04 <benmachine> ++ is higher precedence than $
07:47:13 <benmachine> you can't get lower than $
07:47:23 <benmachine> the only thing I've met equal to $ is `on`
07:47:34 <DuClare> yaxu, It's the output format definition that counts
07:48:11 <DuClare> yaxu, My hardware seems to be unable to hand low samplerates properly, so I use sox to set up the device for 44100 Hz
07:48:15 <sleepynate> $ bill (ya ll)
07:48:37 <fr0ggler> Botje, hmm with your suggestions, I still get an expected/inferred mismatch between OS.Ontology and Either String a -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3886#a3886
07:48:56 <fr0ggler> i included the unpickleFromFile function too if that helps - apologies for the 100% action
07:49:02 <fr0ggler> noob action*
07:49:13 <yaxu> DuClare: yes I think it's increasingly common for soundchips to have fixed samplerates, annoyingly
07:49:32 <DuClare> I'm not sure it's fixed in this case (though it might be)
07:49:52 <DuClare> Higher samplerates seem to work.. though I'm not sure if they work as a higher samplerate *should*
07:50:00 <benmachine> the type annotation on ont doesn't make sense, unless OS.Ontology is a type synonym for Either
07:50:02 <ksf> why is sequence's reverse O(n)?
07:50:11 <ksf> If thought it'd be O(1)
07:50:15 <Saizan> fr0ggler: oh, you can't just put code like that in a file
07:50:26 <DuClare> yaxu, I think it's this cheap usb->optical spdif converter that causes problems.  Though it could be my DAC too.. :|
07:50:32 <Saizan> fr0ggler: you need main = do ...
07:50:36 <ksf> ...just replacing viewL with viewR, so to speak.
07:50:38 <Botje> fr0ggler: can you put the error in there as well?
07:50:55 <Botje> you can add a new revision to the existing paste.
07:51:00 <fr0ggler> Saizan, yeah i have all the necessary gubbins for that - i just thought I'd slim it down :)
07:51:06 <fr0ggler> Botje, sure 2 secs
07:51:08 <yaxu> DuClare: my laptop samplerate seems to be fixed, will have to invest in a proper soundcard one of these days
07:51:15 <Botje> but benmachine's comment makes sense. doh :)
07:51:33 <doserj> fr0ggler: you want case ont::Either String OS.Ontology, I guess (or just remove the type annotation)
07:51:34 <ksf> my stereo only accepts 44100 and 48000 pcm streams
07:51:46 <fr0ggler> Botje, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3886#a3887
07:51:48 <ksf> ...it's not the best, but it wasn't cheap, either.
07:52:06 <Botje> fr0ggler: yeah. it's telling you the type annotation is wrong.
07:52:10 <ksf> if you've got a lower samplerate, resampling won't hurt sound quality, either.
07:52:52 <ksf> ...more like "it won't rescue it"
07:53:18 <DuClare> Well, sox doesn't complain if I set the samplerate to 192000
07:53:29 <Orclev> benmachine: sorry for the late response, was looking at something on another screen... what about (==)? I ran into something trying to do a "return $ (==) []" where it complained about the precedence
07:53:33 <ksf> sox isn't implemented in hardware.
07:53:45 <Orclev> benmachine: if I recall "return . (==[])" worked fine however
07:54:01 <benmachine> Orclev: you can check fixities with :info (or :i) in ghci
07:54:02 <DuClare> ksf, Yeah, but it complains if I try something higher than that
07:54:03 <ksf> I rather have the engineers spend time on a proper dac than figuring out how to support rates like 1234325
07:54:09 <benmachine> it gave me infix 4 ==
07:54:54 <Saizan> Orclev: well, those are completely different expressions, it's not just a difference in parenthesizing
07:54:55 <benmachine> return $ (==) [] is the same as return ([] ==) which is not the same as return . ([] ==)
07:55:05 <DuClare> sox oss: Unable to set audio speed to 196000 (set to 192000)
07:55:38 <ksf> > logAtBase 2 196000
07:55:39 <lambdabot>   Not in scope: `logAtBase'
07:55:51 <benmachine> > logBase 2 196000
07:55:51 <lambdabot>   17.580494128777296
07:56:10 <ksf> that's a strange number.
07:56:31 <burp> > log 196000 / log 2
07:56:31 <lambdabot>   17.580494128777296
07:56:36 <ksf> > 196000 / 44100
07:56:38 <lambdabot>   4.444444444444445
07:56:38 <benmachine> it's strangely dull.
07:56:43 <ksf> > 196000 / 48000
07:56:43 <lambdabot>   4.083333333333333
07:56:55 <fr0ggler> doserj, Botje, ok I removed the type annotation, and am now getting a different error, which I presume is to do with the fact that im trying to use an undeclared function signature? -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3886#a3888
07:57:59 <Botje> without knowing the rest of your program, i'd say you have to define these instances.
07:58:14 <benmachine> or you're using that function with the wrong argument
07:58:18 <Orclev> every time I see 44100 I can't help but think of nyquest frequency
07:58:27 <benmachine> it'd be useful to know which line the thing is asking about
07:58:45 <ksf> btw, haxml can generate haskell adts from dtds
07:58:46 <benmachine> which is one of many reasons why pastebinning the entire code is useful
07:58:55 <benmachine> with a comment with the error in it
07:59:11 <ksf> ...you just have to call loadxml or something and you've got proper data.
08:00:14 <fr0ggler> benmachine, Botje, I guess the thing is, the rest of the code is trivial - just args processing... line 73 in that error is "ont <- unpickleFromFile (xpRoot xpickle) input"
08:00:56 <fr0ggler> this code wasn't written by me, and was written quite a long time ago, by which time the hexpat-pickle libs have undergone changes
08:05:46 <benmachine> fr0ggler: I'm looking at the hackage docs http://hackage.haskell.org/packages/archive/hexpat-pickle/0.3.1/doc/html/Text-XML-Expat-Pickle.html but not making a great deal of sense of it
08:06:04 <fr0ggler> you and me both benmachine :D
08:07:59 <benmachine> I'm guessing that the context of your use of xpickle is forcing it to a type that isn't an XmlPickler, so either your context is wrong or you need to make an instance of XmlPickler
08:08:11 <benmachine> but I have no idea which
08:08:22 <Orclev> does anyone know how the ghc profiler uses the cost center annotations? Does it run a pre-processor to allow the annotations to be accessed by the profiler at run time? Or is this a more general system that could be leveraged by other utilities?
08:09:22 <ksf> I guess there's no such thing as "the profiler", but the program just profiles itself.
08:09:38 <ksf> which'd mean injecting code at every SCC.
08:09:57 <Orclev> ksf: well, I assuming building it using -prof inserts some sort of profiling library
08:10:50 * ksf imagines it as a WriterT stacked upon the 'rts monad', but then, I've never, ever had a look at the rts source.
08:10:56 <ksf> use the source, luke.
08:11:24 <Orclev> hmm, I've never even looked at the source of ghc
08:11:55 <yakov> guys, is there a restriction about where to put splices which computes Decs? if I splice my $(deriveMyStuff) at the end of the source everything is OK, but if it's inserted in the middle then I get errors about "Not in scope: foo..bar" (foo is function) and foo and bar goes below my TH-function..
08:12:12 <ksf> maybe there's something in the ghc trac, there's quite much documentation about its internals, there.
08:12:28 <fr0ggler> benmachine, no worries - i think i'll contact the author of the lib to ask his advice - horses mouth and all that :) many many thanks for the help everyone
08:12:38 <Saizan> yakov: with TH the order of definitions matters
08:13:17 <ksf> TH, put succintly, isn't define-syntax.
08:14:51 <Orclev> ksf: jackpot, http://hackage.haskell.org/trac/ghc/wiki/Annotations
08:15:03 <Orclev> looks like it'll be in 6.12
08:17:52 <HugoDaniel> where is the readability in this: foldr (\x y -> y ++ ( (++ "\n") . show) x) "" lstd  ?
08:17:57 <HugoDaniel> can i write it in a simpler way ?
08:18:27 <ksf> @pl (\x y -> y ++ ( (++ "\n") . show) x)
08:18:27 <lambdabot> flip (++) . (++ "\n") . show
08:18:36 <Saizan> "unlines . reverse . map show $ lstd" ?
08:19:07 <Saizan> > foldr (\x y -> y ++ ( (++ "\n") . show) x) "" [1,2,3]
08:19:08 <lambdabot>   "3\n2\n1\n"
08:19:24 <Saizan> > unlines . reverse . map show [1,2,3]
08:19:25 <lambdabot>   Couldn't match expected type `a -> [a1]'
08:19:25 <lambdabot>         against inferred type `[GH...
08:19:28 <Saizan> > unlines . reverse . map show $ [1,2,3]
08:19:29 <lambdabot>   "3\n2\n1\n"
08:19:33 <Saizan> > unlines . reverse . map show $ []
08:19:34 <lambdabot>   ""
08:19:44 <Saizan> yeah, it seems those are equal
08:20:14 <HugoDaniel> hmm
08:20:14 <HugoDaniel> nice
08:20:15 <HugoDaniel> :D
08:20:20 <Saizan> don't try to do too much in a single foldr if you care about readability :)
08:20:34 <HugoDaniel> i do
08:20:48 <HugoDaniel> readability is my first concern, im just not good enough at haskell :/
08:20:53 <HugoDaniel> yet
08:20:53 <HugoDaniel> :)
08:21:17 <Orclev> if it starts getting complicated maybe move it into a function and just call the function from the fold
08:21:27 <HugoDaniel> i tend to find readability intrinsically connected with maintainability of a code...
08:21:40 <Saizan> it is
08:21:50 <HugoDaniel> it was one of the main reasons why i started to learn haskell
08:22:06 <HugoDaniel> its far more readable than the other languages i know of
08:22:20 <HugoDaniel> okey
08:22:27 <Saizan> and indeed composing small functions is the spirit of haskell
08:22:33 <HugoDaniel> ill use where to define functions
08:22:38 <Orclev> unfortunately maintainability/readability has a somewhat antagonistic relationship with performance
08:22:51 <HugoDaniel> yes :/
08:23:00 <HugoDaniel> but i delegate that part to the ghc developers:D
08:23:21 <Saizan> that's why we have list fusion, so that a composition like that should be transformed in a single foldr
08:23:42 <Orclev> Saizan: define list fusion, first time I've heard the term
08:23:57 <HugoDaniel> ive read that paper "from streams to nothing at all", it made me view haskell in a different way
08:24:08 <HugoDaniel> Orclev: read the paper
08:24:21 <Orclev> HugoDaniel: link? or should I just google it?
08:24:25 <HugoDaniel> ill paste a link
08:24:26 <HugoDaniel> w8
08:24:37 <ksf> "from list to streams to nothing at all"
08:24:41 <ksf> dons wrote it.
08:24:42 <HugoDaniel> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
08:24:54 <Saizan> though the system described in that paper is not used in ghc for Data.List (yet)
08:24:58 <Saizan> but the concept is the same
08:25:19 <HugoDaniel> ah
08:25:27 <Orclev> another paper for me to read... that's the biggest problem with hanging out in here... I think I'm up to something like 12 papers/sites/tutorials I need to go through now
08:25:34 <HugoDaniel> i also enjoyed the other one about bytestreams
08:25:57 <Saizan> you use ghc's RULES mechanism to specify source-level transformations that increase performance, by avoiding the construction of intermediate lists
08:26:02 <HugoDaniel> the comparison about foldr/build with the other methods was very good
08:26:21 <Saizan> e.g. rewrite "map f . map g" to  "map (f . g)"
08:26:42 <HugoDaniel> i hope to learn enough to help out in ghc development one day
08:27:02 <HugoDaniel> oh well, enough daydreaming, back to code
08:27:02 <HugoDaniel> thanks
08:27:03 <HugoDaniel> :)
08:27:13 <Saizan> it's also called deforestation, when done for arbitrary ADTs
08:27:32 <Orclev> hmm... I tend to start out with maps, and eventually most of them turn into folds
08:28:14 <Saizan> it works for most combinators from Data.List
08:48:00 <Orclev> great, now I can't wait for 6.12 to be released
08:49:07 <Berengal> Huh, it would seem polyparse doesn't actually have an Applicative instance...
08:49:41 <malcolmw> Berengal: no, it defines its own `apply` instead
08:49:55 <Berengal> malcolmw, yes, it's a bit weird...
08:50:06 <Berengal> Is there a reason why?
08:50:46 <malcolmw> Berengal: two reasons - I only discovered it was an Applicative after implementing it, and I prefer the name `apply`
08:51:18 <malcolmw> Berengal: so nothing deep.  I probably should change it to use the standard class
08:51:24 <Orclev> why not make it applicative now and just use apply as an alias for the applicative instance?
08:51:40 <Berengal> malcolmw, or at least just provide the applicative instance
08:51:50 <malcolmw> yeah
08:52:46 <Berengal> I've got a thing against infix functions (two uncomfortable dead-key chords to type :/), and prefix and applicatives don't mix...
08:57:13 <ksf> ` isn't a dead key
08:57:23 <ksf> ...unless you're french.
08:58:09 <sleepynate> goddamned french killing our tildes!
08:58:25 <Berengal> ksf, I'm norwegian, which I guess is close enough in keyboard layouts...
08:58:25 <Jafet> Or worse, your keyboard is french
08:59:47 <kw317> hmm.. I want to write a small compiler and I'm wondering how to approach parsing
08:59:55 <Jafet> Berengal, xmodmap?
08:59:58 <ksf> with parsec.
08:59:59 <danr> kw317: Parsec?
09:00:05 <kw317> should I start with some parser combinators library or use alex+happy?
09:00:20 <ksf> combinators.
09:00:33 <ksf> generators give you shift/reduce conflict headaches.
09:00:47 <kw317> true
09:00:48 <Berengal> Jafet, I had some cool layouts before, but then I forgot how to write them at the same time I became incredibly lazy. Rewriting them has been on my todo-list for over a year
09:01:09 <kw317> so when using combinators, how best approach the issue of tokenization?
09:01:22 <ksf> the only thing you have to keep in mind while writing a parsec parser is to insert enough trys
09:01:34 <HugoDaniel> can someone give me a fast way to read a file into a string, making all characters uppercase ?
09:01:58 <Berengal> HugoDaniel, map toUpper <$> readFile filePath
09:02:01 <ksf> fmap toUpper hGetContents "file.foo"
09:02:07 <ksf> or that.
09:02:12 <ksf> and I'm missing a $.
09:02:13 <HugoDaniel> is it fast ? :)
09:02:21 <Berengal> Returns immediately :P
09:02:31 <HugoDaniel> the file is 7Mb of text
09:02:47 <ksf> if you want fast, import Data.ByteString and use those methods.
09:02:51 <kw317> ksf: how best tokenize the input?
09:03:00 <ksf> ...but it'd be hardly be mesurable with those input sizes.
09:03:01 <HugoDaniel> ksf: its a UTF-8 file
09:03:04 <Jafet> kw317, you can implement a lexer separately or dispense with the idea entirely
09:03:09 <kw317> what I want to avoid is having "spaces" all over the place
09:03:13 <Berengal> HugoDaniel, Data.ByteString.UTF8
09:03:14 <jfoutz> > words "hello there and stuff"
09:03:15 <lambdabot>   ["hello","there","and","stuff"]
09:03:24 <jfoutz> that's an easy way.
09:03:27 <Berengal> > words "hello  there"
09:03:27 <lambdabot>   ["hello","there"]
09:03:31 <Berengal> nice
09:03:34 <ksf> There's data.text for unicode stuff. I think we even have an icu binding.
09:03:41 <kw317> hmm.. looks good
09:03:53 <Jafet> Sure, if your language spec exactly matches words
09:03:54 <ksf> kw317, just write two parsers, one going from chars to tokens, the other from tokens to your ast
09:03:57 <kw317> > words "hello \"foo\" there"
09:03:58 <lambdabot>   ["hello","\"foo\"","there"]
09:04:00 <Berengal> GHC 6.12 is supposed to have non-broken unicode, isn't it?
09:04:11 <kw317> > words "hello \"foo bar\" there"
09:04:12 <lambdabot>   ["hello","\"foo","bar\"","there"]
09:04:16 <kw317> nice
09:04:16 <benmachine> @type fmap fst . sortBy (comparing snd) . fmap (id &&& f) -- does this have a name somewhere?
09:04:18 <lambdabot>     Ambiguous type variable `b' in the constraints:
09:04:18 <lambdabot>       `SimpleReflect.FromExpr b'
09:04:18 <lambdabot>         arising from a use of `f' at <interactive>:1:49
09:04:19 <centrinia> > length $ words $ map chr [0..255]
09:04:20 <lambdabot>   4
09:04:25 <benmachine> grr
09:04:30 <benmachine> @type \f -> fmap fst . sortBy (comparing snd) . fmap (id &&& f) -- does this have a name somewhere?
09:04:30 <jfoutz> if you need to be more tricky, you can use parsec
09:04:31 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [a]
09:04:38 <centrinia> > [0..255] \\ (words $ map chr [0..255])
09:04:39 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
09:04:39 <lambdabot>    arising from the literal `...
09:04:49 <Berengal> benmachine, sortBy . comparing?
09:04:49 <centrinia> > [0..255] \\ (map ord $ words $ map chr [0..255])
09:04:50 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:04:50 <lambdabot>         against inferred type...
09:04:54 <Berengal> @type sortBy . comparing
09:04:55 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
09:04:56 <ksf> kw317, you also might want to start out with an ast. haskell data syntax isn't that unreadable.
09:05:22 <kw317> ksf: I've got that, sort of
09:05:27 <benmachine> Berengal: is slower, I think
09:05:31 <kw317> needs some refinement, but looks OK for now
09:05:41 <benmachine> because comparing will call your function on elements repeatedly
09:05:50 <kw317> I've got one nasty stm to parse
09:06:00 <kw317> which I'm having problems with
09:06:08 <Berengal> benmachine, that depends... and it's called a schwarzian transform
09:06:26 <kw317> case(expr){val0;exp0;val1;exp1;default}
09:07:04 <benmachine> Berengal: depends on?
09:07:11 <jfoutz> kw317: maybe check out Parsec. there is a built in java-like parser
09:07:18 <kw317> ((,) <$> expr <* char ';' <*> expr) `sepBy` char ';' <*> optional expr
09:07:35 <kw317> jfoutz: the language that I'm trying to parse is very java-unlike ;)
09:07:46 <Berengal> benmachine, phases of the moon, stuff like that... It's not something I've studied...
09:07:59 <kw317> this line above fails to parse the body.. probably missing a try somewhere
09:08:09 <benmachine> Berengal: oh you mean whether comparing will call the function repeatedly depends?
09:08:20 <benmachine> or whether the thing is slower I suppose
09:08:24 <Berengal> benmachine, no, wether it'll be faster or not
09:08:34 <sohum> :t comparing
09:08:35 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
09:09:00 <benmachine> k
09:09:28 <benmachine> but it's not hard to imagine that it could be if your comparing function was slow
09:10:10 <Berengal> Not the comparing function, the transformation
09:10:26 <benmachine> yeah I meant the function passed to comparing :P
09:10:29 <Berengal> You can't compare on 'a' anyway
09:15:15 * benmachine notes that map snd . sort . map (f &&& id) works just as well
09:15:55 <roconnor> ooh, Haskell has doctest
09:16:03 <Orclev> doctest?
09:16:10 <roconnor> @wiki DocTest
09:16:10 <lambdabot> http://www.haskell.org/haskellwiki/DocTest
09:16:18 <benmachine> oh, the latter requires that the original list is Ord though
09:17:29 <Orclev> roconnor: interesting but I'd like it even more if it could be run on haddock output
09:17:31 <Berengal> benmachine, it's not the same if f isn't injective either
09:18:39 <lilac> is Data.List.sort stable?
09:18:51 <roconnor> lilac: I think so
09:20:40 <aavogt> is it possible to add a feature like MonadWriter to an expression that already uses applicatives?
09:21:01 <RayNbow> > sortBy (comparing length) ["123","345","678","foo","bar"]
09:21:02 <lambdabot>   ["123","345","678","foo","bar"]
09:21:50 <lilac> "map (unEq . snd) . sort . map (f && Eq)" with "newtype Eq a = Eq { unEq :: a }; instance Ord Eq where compare _ _ = EQ" would probably work
09:22:39 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9710#a9710
09:22:47 * lilac reads up. why aren't we using sortOn = sortBy . (compare `on`)?
09:23:20 <RayNbow> :t GHC.Ext.sortWith
09:23:21 <lambdabot> Couldn't find qualified module.
09:23:21 <Berengal> lilac, reducing calls to f
09:23:22 <lilac> ah, the multiple-calls-of-f-per-element thing
09:23:25 <RayNbow> :t GHC.Exts.sortWith
09:23:26 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [a]
09:26:42 * benmachine tries to remember which one injective is
09:27:00 <benmachine> oh
09:27:30 <benmachine> hmm, it's pretty similar in that case
09:29:41 <Orclev> what's the command to check the installed version of a module?
09:30:50 * benmachine wonders if the reason haskell highlighting isn't used on a wikibook page he is reading is because of the awful colours it tends to choose
09:30:50 <twobitsprite> what is the significance of talking about _|_ instead of just saying it generates an error?
09:30:57 <masklinn> > 3.0/3
09:30:58 <lambdabot>   1.0
09:30:59 <doserj> Orclev: ghc-pkg list <pkgname>, or ghc-pkg describe <pkgname>
09:31:02 <masklinn> > 3/3
09:31:02 <lambdabot>   1.0
09:31:48 <masklinn> > (3::Int)/3
09:31:49 <doserj> twobitsprite: expressions with value _|_ do not have to generate an error
09:31:49 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
09:31:49 <lambdabot>    arising from a use o...
09:31:52 <ziman> twobitsprite, the program need not generate an error; it may as well just loop forever
09:32:54 <Orclev> doserj: actually ghc-pkg find-module <module> did what I want, but thanks for pointing me at ghc-pkg
09:34:17 <twobitsprite> ziman: "_|_" doesn't seem to be a valid haskell value
09:36:04 <ksf> it's not a value, just a member of every type.
09:36:14 <ksf> ...except those that don't have any other members
09:36:29 <ksf> (you can get those with -XEmptyDataDecls)
09:36:49 <ksf> wait.
09:37:33 <ksf> no, those still have bottom as member.
09:37:39 <monoidal> > let bot = bot in bot
09:37:43 <lambdabot>   mueval-core: Time limit exceeded
09:38:02 <twobitsprite> oh... bot = _|_?
09:38:05 <monoidal> yes
09:38:14 <ksf> > (\x -> x x) (\x -> x x)
09:38:15 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:38:20 <monoidal> > fix id
09:38:24 <lambdabot>   mueval-core: Time limit exceeded
09:38:27 <ksf> > fix error
09:38:28 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
09:38:33 <ray> > fix fix
09:38:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
09:38:48 <sm> @seen hackagebot
09:38:48 <lambdabot> Unknown command, try @list
09:39:03 <Saizan> preflex_: seen hackagebot
09:39:03 <preflex_>  hackagebot was last seen on #haskell 9 days, 2 hours, 6 minutes and 17 seconds ago, saying: OpenGLRaw 1.1.0.0 - A raw binding for the OpenGL graphics system (SvenPanne)
09:39:17 <sm> hmm. (thanks)
09:39:34 <Taejo> :t fix
09:39:35 <lambdabot> forall a. (a -> a) -> a
09:39:39 <crazy2k> Anyone know how to execute some script using hugs without entering command line mode?
09:39:45 <Taejo> :t fix . fix
09:39:46 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
09:40:00 <Saizan> crazy2k: runhugs
09:40:05 <Jafet> > fix $ (++) $ fix (0:)
09:40:06 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:40:23 <Jafet> > fix $ (:) $ fix (0:)
09:40:24 <lambdabot>   [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:40:25 <crazy2k> Saizan: Thanks :)
09:40:42 <ksf> > fix (:)
09:40:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a] -> [a]
09:40:52 <ksf> > fix (++)
09:40:53 <lambdabot>   Couldn't match expected type `[a]'
09:40:53 <lambdabot>         against inferred type `[a] -> [a]'
09:40:59 <ksf> > fix $ (++) ""
09:41:02 <Taejo> :t (:) $ fix (0:)
09:41:02 <lambdabot>   mueval-core: Time limit exceeded
09:41:03 <lambdabot> forall t. (Num t) => [[t]] -> [[t]]
09:42:23 <twobitsprite> hmm... "Not in scope: bot"
09:42:27 <twobitsprite> > botr
09:42:28 <lambdabot>   Not in scope: `botr'
09:42:28 <twobitsprite> > bot
09:42:29 <lambdabot>   Not in scope: `bot'
09:42:43 <monoidal> it's called undefined
09:42:56 <ksf> @src undefined
09:42:56 <lambdabot> undefined =  error "Prelude.undefined"
09:42:59 <monoidal> it raises an exception, but that isn't important
09:43:13 <monoidal> you can let bot = bot
09:43:20 <ksf> @scr error
09:43:20 <lambdabot> Maybe you meant: arr rc src
09:43:26 <ksf> @src error
09:43:27 <lambdabot> error s = throw (ErrorCall s)
09:43:36 <ksf> @src throw
09:43:36 <lambdabot> throw exception = raise# exception
09:43:43 <ksf> :t raise#
09:43:44 <lambdabot> Not in scope: `raise#'
09:43:47 <lilac> > let _|_ <- undefined = True in "Hello"
09:43:48 <lambdabot>   "Hello"
09:43:53 <ksf> :t GHC.Prim.raise#
09:43:54 <lambdabot> forall a b. a -> b
09:44:13 <absentia> where can I go to get my daily re-affirmation of why I should continue learning haskell...  ?
09:44:28 <Saizan> lambdabot: pattern guards?
09:44:35 <Saizan> ehm lilac ^^
09:44:35 <twobitsprite> absentia: any C++ blog? :P
09:44:35 <ksf> > GHC.Prim.raise# "choclate chip cookies"
09:44:36 <lambdabot>   Not in scope: `GHC.Prim.raise#'
09:44:40 <lilac> Saizan: right :)
09:44:55 <Saizan> absentia: planet.haskell.org ?
09:44:57 * absentia actually loves C++... 
09:45:03 <ksf> > throw "choclate chip cookies"
09:45:03 * absentia runs to planet haskell. thanks.
09:45:03 <lambdabot>   Not in scope: `throw'
09:45:04 <lilac> absentia: ##c++? :)
09:45:21 <ksf> > error "out of choclate chip cookies"
09:45:22 <lambdabot>   * Exception: out of choclate chip cookies
09:45:34 <benmachine> things that annoy me: forked threads don't run finally handlers when the main thread dies
09:45:34 <absentia>  lilac: did you check -- I am usually there... I actuallyleft ##C++ to join #haskell :-)
09:45:59 <ksf> don't let your threads die.
09:46:09 <ksf> you have to feed them regularly.
09:46:14 <ksf> otherwise, they starve.
09:46:31 <ksf> cute little buggers they are.
09:46:48 <Jafet> Tamagotchi threads
09:47:00 <lilac> remember to water them and don't let the read end of MVars they write to get GC'd :)
09:47:31 <ksf> lilac, the other way round?
09:47:58 <Saizan> both, i'd say
09:48:10 <lilac> you can get blocked indefinitely either way i think
09:48:46 <ksf> mhhh I'm writing to TMVars in a spark for performance sanity reasons, anyway...
09:49:34 <ksf> ...but I would _assume_ that the write just silently and non-blokingly fails.
09:51:25 <ksf> ...such stuff should be documented, by the way.
10:03:12 <ksf> :t isPrim
10:03:12 <lambdabot> Not in scope: `isPrim'
10:03:13 <ksf> :t isPrime
10:03:14 <lambdabot> Not in scope: `isPrime'
10:03:18 <ksf> bah.
10:03:22 <sm> hackagebot went silent on 9/13 due to a transient http failure. Sorry about that
10:04:59 <aavogt> so if I have a    Alternative f => f (Maybe a), it is not possible to invoke one effect if the result is Nothing, and a different result if it is Just?
10:05:33 <byorgey> aavogt: no. only Monad gives you the power to choose effects based on intermediate results.
10:07:02 <aavogt> wait, the alternative contraint lets me put those effects in the right side of the <|> case?
10:07:13 <aavogt> file:///usr/share/doc/ghc/libraries/action-permutations/Control-Applicative-Permutation.html#v%3Aatom
10:07:47 <aavogt> byorgey: I want a version of optAtom that does some logging when the fallback is chosen
10:08:01 <byorgey> aavogt: I can't access your filesystem ;)
10:08:11 <aavogt> too bad
10:08:34 <aavogt> byorgey: http://hackage.haskell.org/packages/archive/action-permutations/0.0.0.0/doc/html/Control-Applicative-Permutation.html
10:08:34 <byorgey> s'ok, I found it on hackage
10:08:42 <byorgey> thanks =)
10:10:22 <aavogt> byorgey: this is the Alternative I am using: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9711#a9711
10:10:24 <byorgey> aavogt: Alternative lets you choose to run or not run certain effects based on some notion of failure intrinsic to the Alternative instance
10:10:39 <byorgey> NOT based on the result of a successful action.
10:11:06 <aavogt> oh, that is actually enough then :)
10:11:22 <darrint> @pl \a b -> f a b / 2
10:11:22 <lambdabot> flip flip 2 . ((/) .) . f
10:11:32 <aavogt> assuming I can use the expanded version of maybeAtom
10:11:43 <byorgey> aavogt: yes, I think it actually should be, now that I look at the documentation
10:19:51 * coyo waves excitedly
10:20:46 <Keiya> coyo!
10:20:54 <coyo> keiya!
10:20:56 <byorgey> hi coyo!
10:20:56 * coyo glomps
10:20:59 <danr> hello, I'm trying to use STArrays but I get an error that it cannot be an MArray
10:21:03 <coyo> hey guise
10:21:12 <danr> if anyone could take a glance it would be great: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9712#a9712
10:21:22 <Keiya> > map (+1) [1..10]
10:21:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
10:21:25 * coyo is new
10:21:34 <Keiya> lambdabot's not only written in haskell, she can evaluate it :P
10:22:07 * coyo is exploring different languages - all he knows is the java from his hs ap comp sci class, and wants to learn something better
10:22:44 * coyo understands iteration and oop
10:23:08 <coyo> > helloWorld
10:23:09 <lambdabot>   Not in scope: `helloWorld'
10:23:09 <Keiya> But do you understand recursion and functional? :P
10:23:21 <Keiya> > "Hello, World!"
10:23:22 <lambdabot>   "Hello, World!"
10:23:26 <Keiya> :P
10:23:29 <danr> if i add :: ST s (STArray s Int a)
10:23:37 * coyo understands recursion
10:23:48 <danr> then it complains that a is bound by the type signature, and if i replace a with b it says that it indeed should be a
10:23:49 <byorgey> coyo: well, you're in a great place!
10:23:55 * coyo remembers a lot of his peers had trouble with it...
10:24:08 <byorgey> coyo: have you taken a look at any Haskell books/tutorials yet?
10:24:20 <coyo> not yet, i'm just exploring at this point
10:24:45 <coyo> i was considering common lisp... but.. it's not trivial to set up a working dev env
10:25:03 * coyo is afraid of emacs
10:25:16 <beutdeuce> coyo will die
10:25:23 * coyo is going to have nightmares about it
10:25:28 <Keiya> beutdeuce: Be nice :<
10:25:53 <Keiya> A lot of Haskell people /do/ use emacs, but you could code in notepad if you wanted to. (I do NOT recommend it :P)
10:25:54 * coyo huggles beautiful deuce
10:25:59 <beutdeuce> sorry, but really :P
10:26:03 <byorgey> coyo: hehe, emacs is great once you get it to like you.
10:26:14 * coyo offers a cookie to his emacs
10:26:37 <beutdeuce> emacs is one of the best written pieces of code to date
10:26:53 <Jafet> I hear emacs ships with an optional editor now
10:27:05 <beutdeuce> Jafet: funny...
10:27:10 <jfredett> beutdeuce: *chuckle* that's going on the quote board...
10:27:48 <coyo> well, i'll keep working on it, but does haskell work with, say... wait
10:27:57 <coyo> i dont know any open source ides!
10:28:04 <beutdeuce> coyo: emacs
10:28:07 <jfredett> anything that's made it to >20 versions that involves both lisp and C can -- methinks -- no longer be considered 'well-written' but rather 'undead'
10:28:09 <Keiya> coyo: Eh, ides are overrated
10:28:27 <coyo> i've heard of codeblocks and eclipse, but have no idea if they work with haskell
10:28:38 <Jafet> jfredett, yahoo store
10:28:40 * Keiya usually uses vim and a shell :J
10:28:43 <beutdeuce> coyo: they *work*, but they don't
10:28:51 <sohum> jfredett: I am interested in your ideas. why undead?
10:28:52 <coyo> keiya is leet :3
10:28:53 <Keiya> coyo: You can rig it to sorta work, but... yeah.
10:28:53 <jfredett> not to say that zombie-software is bad, simply that being alive ex post morte is probably not an optimal state of existence.
10:29:09 <byorgey> coyo: there is a project to add Haskell support to eclipse.  Not sure how complete it is/how easy it is to install.
10:29:17 <beutdeuce> leksah is too complex to configure, though i do enjoy its jit
10:29:20 <coyo> :<
10:29:23 <jfredett> sohum: because trying to understand the codebase is likely akin to having your brain eaten. :)
10:29:24 <Axman6> coyo: there's an eclipse-fp plugin for eclipse. it's not really ready for release though, since you need to compile it yourself, and that's non trivial
10:29:27 <sohum> or how sane you'd have to be to want to use eclipse for haskell
10:29:38 <Axman6> coyo: what OS are you on?
10:29:45 <coyo> i use ubuntu
10:29:49 <danr> I solved my problem, if anyone cares about how to (and how not to) make a polymorphic list to an STArray, have a look here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9712#a9714
10:29:57 <byorgey> coyo: you could try Leksah, which is a Haskell IDE written in Haskell.  but I might suggest just sticking with a simple text editor for now.
10:29:57 <coyo> i'm still a little new to linux
10:30:08 <coyo> okay
10:30:17 <coyo> well, i like my gedit
10:30:21 <jfredett> coyo: Ubuntu's a nice distro. good to learn on.
10:30:25 <byorgey> Haskell is so concise that it doesn't require IDE support as much as some languages do.
10:30:28 <sohum> jfredett: fwiu, the C bit is a tiny core. most of emacs is written in elisp, which, admittedly, has Issues, but it's not brain-eatingly-bad I wouldn't say
10:30:45 <lpjhjdh> is there a way to get an infinite list of inputs from the user that's lazily computed?
10:30:47 <Makoryu> Holy crap!
10:30:49 <Jafet> Good to learn how not to make a desktop
10:30:53 <byorgey> coyo: yes, gedit is fine.  I think it even does Haskell syntax highlighting, IIRC.
10:30:55 <jfredett> sohum: elisp makes me want to die. And I _like_ lisps...
10:31:03 <Keiya> Oh, that reminds me! Coyo, one thing that haskell is awesome about...
10:31:07 * coyo tries to keep up...
10:31:10 <Keiya> > [1..]
10:31:11 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:31:17 <coyo> O.O
10:31:20 <coyo> whoa
10:31:20 <Keiya> That list is infinite. And you can use it.
10:31:23 <jfredett> coyo: irc = multiplayer notepad, fear not, you'll get good at it.
10:31:37 * coyo likes gobby
10:31:39 <Keiya> It only evaluates each part as it uses it :J
10:31:47 <Jafet> lpjhjdh, "compute inputs" does not compute
10:32:07 <lpjhjdh> requests*
10:32:08 <Orclev> so, I've got an idea for doing versioning of libraries and I was wondering if someone would take a look at it and let me know why it's blindingly stupid, or if I'm lucky a decent idea
10:32:17 <coyo> > import this
10:32:17 <lambdabot>   <no location info>: parse error on input `import'
10:32:23 <Makoryu> coyo: Sup
10:32:30 <coyo> hey!
10:32:32 * coyo glomps
10:32:38 <Makoryu> coyo: You can't use import/module/etc. statements in the bot
10:32:39 <coyo> that's two tropers
10:32:43 <Orclev> a README and a couple examples: http://github.com/orclev/versioningidea
10:32:44 <byorgey> lpjhjdh: just a 'map read . words . getContents' or something ought to work, if I understand what you're asking
10:32:55 <Makoryu> coyo: Small world, eh?
10:32:56 <idnar> "import this" is a Python thing, anyhow
10:33:04 <coyo> yah
10:33:06 <coyo> really
10:33:10 <Makoryu> idnar: Ah, gotcha
10:33:18 <coyo> keiya is attempting to sell haskell to me
10:33:28 <Keiya> Python is nice for some jobs.
10:33:32 <lpjhjdh> byorgey: looks like it, thanks
10:33:33 <Makoryu> Keiya: I applaud your efforts and your contributions to society!
10:33:33 * jfredett finds all the freshman haskellers silly, but entertaining. September is a good time of year.
10:33:41 <Keiya> The same ones I used to hack out a bit of qbasic for, actually
10:33:57 <coyo> keiya: what is haskell's strong point?
10:34:02 <Axman6> everything
10:34:03 <jfredett> coyo: Types.
10:34:22 <Keiya> Strict types and lazy evaluation
10:34:24 <Axman6> > "hello" + 3 -- the fact this doesn't work is awesome
10:34:25 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
10:34:25 <lambdabot>    arising from the literal ...
10:34:38 <coyo> my initial, uninitiated impression with it is that it is academically pure, which may not be true
10:34:38 <Axman6> coyo: parallelism, concurrency
10:34:42 <coyo> ooh
10:34:43 <Orclev> Strong points: Awesomeness!... Weak Points: Learning how to use it properly
10:34:51 <coyo> parallelism??
10:34:52 <Makoryu> coyo: Haskell has what many people consider the best type system of any (general purpose) language. And it takes advantage of it immensely
10:34:54 <coyo> <3
10:34:56 <jfredett> coyo: if you have to narrow it down to one thing, the Type system in haskell, and the ease with which you create types for your data, make it a _very_ powerful language indeed.
10:35:10 <Makoryu> coyo: Yeah, you can do parallelism much more easily in a pure functional language
10:35:18 <coyo> why dont other languages adopt it's type system?
10:35:25 <coyo> *its
10:35:29 <Jafet> Why don't Brits speak German?
10:35:31 <Keiya> coyo: Because it's so ridiculously strict.
10:35:31 <jfredett> okay, off to the Math Club Meeting. Tally ho gentlepeople!
10:35:37 <coyo> oic
10:35:46 <Axman6> > let fib n | n < 2 = 1 | otherwise = a `par` b `pseq` a+b where a = fib (n-1); b = fib (n-2) in fib 100
10:35:46 <coyo> c ya, jfred
10:35:48 <jfredett> coyo: and because other people are unenlightened.
10:35:49 <lambdabot>   mueval-core: Time limit exceeded
10:35:53 <Axman6> > let fib n | n < 2 = 1 | otherwise = a `par` b `pseq` a+b where a = fib (n-1); b = fib (n-2) in fib 10
10:35:53 <lambdabot>   89
10:35:56 <Keiya> I wouldn't want to use it for quick, one-shot text processing hacks :P
10:35:58 <coyo> :3
10:36:01 <Axman6> coyo: parallel fibonacci
10:36:18 <Jafet> That's not very parallel
10:36:19 <Orclev> Keiya: actually using some of the regex modules it's not too bad at that either
10:36:20 * coyo shines under all of the attention <3
10:36:29 <Orclev> Keiya: in fact I used it for exactly that the other day
10:36:35 <Axman6> Jafet: on the contrary, it's overly parallel i'd say
10:36:36 <Makoryu> coyo: Most people think of Java and C++ when they think of static typing. Once people learn Haskell, they get *just* a bit more enthusiastic about the idea :p
10:36:43 <Keiya> Orclev: Oh, it's certainly usable. I'm just not comfortable with it. :J
10:36:47 <coyo> hmmm
10:36:48 <Jafet> The data dependencies are exactly linear.
10:36:55 <Jafet> That's kind of... not parallel
10:37:04 <Axman6> eh?
10:37:06 <coyo> static typing is a feature for clean, fast languages, right?
10:37:10 <Keiya> Java's typing looks like Visual Basic next to Haskell :P
10:37:27 <Keiya> "You mean it might be /null/!?" :P
10:37:32 <Orclev> coyo: yes and no, more accurately static typing is a feature for making runtime bugs compile time bugs
10:37:41 <coyo> ohh
10:37:46 <coyo> okay, i get that
10:38:00 <Jafet> Static typing is mainly the idea of giving types to names, rather than values.
10:38:02 <coyo> because the compiler now has enough information to make a determination
10:38:12 <Keiya> You'll note none of the snipits we've shown here have included type information, BTW... Haskell is amazingly good at guessing
10:38:13 <Jafet> As for what a type system is, that varies from language to language
10:38:28 <sohum> jfredett-away: gah, trying to find this quote - something along the lines of "any language that tries to implement static scoping gets it wrong on the first try, which may be why elisp has never tried."
10:38:40 * coyo is unable to follow the snippets passed to the bot at all
10:38:44 <Keiya> I like to be explicit most of the time anyway, to catch typos :P
10:38:46 <Orclev> heh
10:38:57 <Orclev> > show (8 :: Int)
10:38:58 <lambdabot>   "8"
10:39:03 <Orclev> > show (8 :: Double)
10:39:04 <lambdabot>   "8.0"
10:39:11 <coyo> o.o
10:39:15 <Makoryu> > [1..10]
10:39:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:39:22 <Axman6> :t [1..10]
10:39:23 <lambdabot> forall t. (Num t, Enum t) => [t]
10:39:27 <coyo> > show (7 :: String)
10:39:28 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
10:39:28 <lambdabot>    arising from the literal `...
10:39:32 <Orclev> > [1..10] :: [Double]
10:39:32 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
10:39:34 <Makoryu> > [2 + 2, (+) 2 2, (+ 2) 2]
10:39:35 <lambdabot>   [4,4,4]
10:39:39 <copumpkin> > show (7 :: Complex Double)
10:39:40 <lambdabot>   "7.0 :+ 0.0"
10:39:46 <Makoryu> > map (2 +) [2,2,2]
10:39:47 <lambdabot>   [4,4,4]
10:39:54 <Keiya> > foldr (+) 0 [1..10]
10:39:55 <lambdabot>   55
10:40:03 <sohum> coyo: there's two interesting bits of machinery going on there
10:40:06 <Makoryu> > sum [1..10] -- :p
10:40:07 <lambdabot>   55
10:40:08 <coyo> > show [23 * 5]
10:40:09 <lambdabot>   "[115]"
10:40:12 <Keiya> Incidentally, I've not used Haskell in /ages/, and I can still pull this stuff off :J
10:40:35 <monoidal> > [(x,y,z) | z <- [1..], x <- [1..z], y <- [x..z], x*x+y*y==z*z]
10:40:37 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(7,24,25),(15,20...
10:40:47 <sohum> coyo: firstly, when you write a numeric literal in ghci, there's an implicit fromIntegral (or is it fromInteger?) wrapped around it
10:40:50 <coyo> the code feels harsher, more mathematic
10:40:51 <sohum> :t fromInteger
10:40:52 <lambdabot> forall a. (Num a) => Integer -> a
10:40:56 <Orclev> coyo: one of the cooler things you can do in haskell is polymorphism on return types... then depending on how the function is used changes what it returns (and possibly expects)
10:40:59 <sohum> :t fromIntegral
10:41:00 <lambdabot> forall a b. (Integral a, Num b) => a -> b
10:41:07 <coyo> ohh
10:41:11 <Makoryu> > (show (23 * 5), show $ 23 * 5) -- coyo, note the ($) operator
10:41:12 <lambdabot>   ("115","115")
10:41:27 <Keiya> What's the current recommended starting point, BTW?
10:41:33 <Orclev> :t show
10:41:34 <lambdabot> forall a. (Show a) => a -> String
10:41:35 <sohum> coyo: and secondly, there's what Orclev just mentioned.
10:41:52 <Jafet> coyo: Haskell cases you to think carefully before writing code. As shown here, lambdabot removes that restriction.
10:41:59 <Athas> You can write seriously funky stuff with multi-parameter type classes defining methods that are polymorphic in their return type.
10:42:00 <Orclev> as you can see, show can take anything that's a member of the Show class, and convert it into a string
10:42:04 <coyo> > (show ["Mako"]) -- what does the dollar sign do?
10:42:05 <lambdabot>   "[\"Mako\"]"
10:42:12 <sohum> @src ($)
10:42:12 <lambdabot> f $ x = f x
10:42:14 <Orclev> coyo: $ is a hack for precedence
10:42:17 <monoidal> function application
10:42:20 <coyo> huh
10:42:27 <monoidal> > sin (cos (sin (1)))
10:42:28 <lambdabot>   0.6181340709529279
10:42:31 <monoidal> > sin $ cos $ sin 1
10:42:32 <lambdabot>   0.6181340709529279
10:42:34 <Athas> @src unsafePerformIO
10:42:34 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
10:42:37 <Makoryu> coyo: Basically, any time you see "f $ x," you can rewrite it as "f (x)"
10:42:41 <roconnor> > sin $ cos $ sin 1 :: CReal
10:42:42 <lambdabot>   0.6181340709529279221877384838523028913235
10:42:43 <Orclev> coyo: my personally theory is it was added just to make haskell look less like lisp
10:42:49 <Axman6> > sin . cos . sin $ 1
10:42:50 <lambdabot>   0.6181340709529279
10:42:55 <coyo> rofl
10:42:57 <Makoryu> Orclev: It does help with that, yes :p
10:43:15 <sohum> Orclev: I prefer to use . when possible for the nonbracketed look ;)
10:43:21 <Keiya> Yeah, otherwise it woulda just been Lisp with the function /outside/ the parens :P
10:43:28 <coyo> but haskell != lisp, amirite?
10:43:35 <Orclev> coyo: definitely
10:43:51 <Axman6> yes, Haskell > Lisp
10:43:53 <Axman6> >_>
10:44:00 <Axman6> god lisp is ugly
10:44:04 <sohum> I wouldn't go that far, Axman6
10:44:09 <sohum> pff, ugly
10:44:10 <Axman6> i would
10:44:18 <sohum> rewrite your aesthetic sensibilities!
10:44:18 <Keiya> Haskell's related to lisp about the same way, say, python's related to perl.
10:44:30 <coyo> huh
10:44:34 <coyo> opposites?
10:44:35 <Keiya> There's a /lot/ of concept-draw, but also a lot of tweaking, building-upon, etc
10:44:38 <sohum> at the moment, I'd say Haskell is incomparable to Lisp
10:44:43 <Keiya> Not at all :P
10:44:48 <Axman6> sohum: how so? o.O
10:44:52 <coyo> or rather, used for roughly the same things, but opposite philosphies?
10:45:03 <jmcarthur_work> niether  Haskell != Lisp  nor  Haskell > Lisp  type check, for me
10:45:06 <Raevel> it is very easy to compare things, more so the more different they are
10:45:12 <Jafet> What is lisp?
10:45:12 <Athas> Lisp is beautiful, but sadly not very statically safe.
10:45:13 <Makoryu> coyo: Haskell is regarded by many as the ultimate functional language. Lisp (well, presumably Common Lisp, since there are lots of dialects) is instead the ultimate macro language.
10:45:21 <Axman6> jmcarthur_work: you haven't defined your types correctly then :P
10:45:36 <sohum> Axman6: well, in the sense of it's hard to say one is "better" than the other, because of how different they are
10:45:37 <roconnor> Epigram 2 is the ultimate functional language :D
10:45:39 <coyo> i was brainwashed with java, so i
10:45:42 <Athas> Lisp is a local maximum... there's nowhere to go.  Haskell is still far away from its ultimate potential, yet already so great.
10:45:48 <coyo> kinda think in oop
10:46:01 <Jafet> jmcarthur, careful! Lisp is a type class
10:46:01 <Axman6> coyo: generics in Java come from Haskell btw
10:46:04 <Makoryu> roconnor: I can't even think about Epigram without my eyes instinctively bleeding to death and escaping out of my skull :|
10:46:13 <coyo> really?
10:46:14 <Orclev> coyo: the biggest downside to learning haskell is that you see A LOT of strange maths and theories mentioned, but don't let it scare you, most of it is optional
10:46:15 <coyo> i didnt know that
10:46:18 <Axman6> yep
10:46:25 <Makoryu> Axman6: I never heard that O_o
10:46:27 <Axman6> but haskell does them sooo much better
10:46:35 <Axman6> well, it's true
10:46:36 <jmcarthur_work> Jafet, okay, then i suppose the inference engine would make Lisp have type Liskell
10:46:36 <roconnor> Makoryu: ya, it's that good!
10:46:36 <Keiya> Except monads, you kinda need to at least sorta get a little of those if you wanna do anything useful :P
10:46:40 <Jafet> Orclev, most of it is mandatory and valuable
10:46:55 <coyo> i want to eventually learn higher math, but atm, sadly, i am at high school geometry level
10:46:57 <Orclev> Jafet: not to learn the basics of the language, only to do advanced things
10:46:57 <sohum> Athas: hm. I wouldn't say Lisp is in a local maxima, but definitely there's no real development going on in it nowadays.
10:47:00 <coyo> i have plans to change that
10:47:01 <Athas> You can understand monads perfectly well as a language thing without reading up on the math.
10:47:17 <Keiya> coyo: If you're at that level and willing to learn, you're fine :J
10:47:20 <sohum> coyo: it's ... well, don't think of it as math. just learn the concepts involved, and later you'll be surprised that it was math
10:47:21 <Makoryu> Keiya: Eh, monads aren't *that* important. They just build up on other typeclasses (Functor, Applicative, etc.)
10:47:29 * Axman6 wishes monads had a more friendly name
10:47:31 <coyo> :3
10:47:34 <orbitz> gonads
10:47:35 <coyo> i love math
10:47:39 <Athas> sohum: well OK, but any improvements to (Common) Lisp are either written in Lisp themselves, or require you to rip out core parts and do them differently.
10:47:40 <Axman6> orbitz: perfect
10:47:47 <roconnor> Axman6: I call them standard constructions
10:47:49 <orbitz> Programmable Gonads!
10:47:57 <sohum> Athas: well, that's kinda the point of the macro paradigm, no?
10:47:59 <jmcarthur_work> warm fuzzy things
10:48:02 <Orclev> o_O orbitz
10:48:06 <orbitz> i like that they are named monads, it lets me talk down to people when i cexplain them
10:48:13 <sohum> orbitz++
10:48:14 * coyo hilights on "fuzzy"
10:48:16 <Athas> sohum: sure.  And that's why I claim Lisp is in a local maxima.
10:48:25 <jmcarthur_work> coyo, O_o
10:48:38 <Keiya> They should be called Moonads. To be more cow-friendly
10:48:46 <Orclev> coyo: as you can tell, it gets rather lively in here at times
10:48:49 <Makoryu> > fmap (+5) <$> [Nothing, Nothing, Just 8, Just 12, Nothing, Just 3, Nothing]
10:48:50 <lambdabot>   [Nothing,Nothing,Just 13,Just 17,Nothing,Just 8,Nothing]
10:49:05 <coyo> orclev: i'm starting to get the feel for the culture
10:49:13 <Keiya> Makoryu: I have /no/ clue what that just did :P
10:49:23 <Makoryu> Keiya: I fmapped fmap >:)
10:49:26 <Keiya> Well, I understand what it did, but now how.
10:49:27 <Badger> @src (<$>)
10:49:27 <lambdabot> f <$> a = fmap f a
10:49:30 <Axman6> coyo: the haskell community is probably one of the best things about the language
10:49:39 <roconnor> > fmap fmap fmap [Nothing, Nothing, Just 8, Just 12, Nothing, Just 3, Nothing]
10:49:40 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a]'
10:49:40 <lambdabot>         against inferre...
10:49:44 <Orclev> coyo: oh this is nothing, wait till they get going on some theory or another and how it can be used for blah blah blah... you won't understand half of what's said but it's interesting to watch
10:49:46 <sohum> Athas: really? you'd say that, for instance, there's no way to improve the macro syntax/semantics, no better possible standard libraries, no other possible improvements?
10:49:47 <Makoryu> > fmap (+5) Nothing
10:49:47 <lambdabot>   Nothing
10:49:51 <roconnor> > fmap fmap fmap $ [Nothing, Nothing, Just 8, Just 12, Nothing, Just 3, Nothing]
10:49:52 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
10:49:52 <Keiya> Incidentally
10:49:57 <roconnor> hmm
10:49:57 <Makoryu> > fmap show [1,2,3]
10:49:58 <lambdabot>   ["1","2","3"]
10:50:02 <Keiya> Maybe has poisoned my ability to use english.
10:50:02 <coyo> orclev: fascinating!
10:50:05 <Badger> fmap $ fmap (+5) [Nothing, Nothing, Just 8, Just 12, Nothing, Just 3, Nothing]
10:50:06 <Makoryu> > map show [1,2,3]
10:50:07 <lambdabot>   ["1","2","3"]
10:50:13 <Keiya> When someone asks for 'just coffee'... >_>
10:50:14 * coyo adds #haskell to his autojoin
10:50:20 <roconnor> > fmap fmap fmap (+5) [Nothing, Nothing, Just 8, Just 12, Nothing, Just 3, Nothing]
10:50:20 <lambdabot>   [Nothing,Nothing,Just 13,Just 17,Nothing,Just 8,Nothing]
10:50:28 <Athas> sohum: yes, but those are not really radical improvements.  I'm talking about adding stuff like, say, static type safety.  You can't really do that well without ripping out existing parts of Lisp.
10:50:35 <Makoryu> roconnor: Oh yeah
10:50:40 <Athas> sohum: Haskell feels much more conductive to radical incremental improvements.
10:51:10 * Orclev ponders a radical incremental improvement.
10:51:19 <Makoryu> Athas: Actually, one of the common complaints in the Lisp community is that they don't have the *option* of proper type safety even with CL's type declarations
10:51:22 <Orclev> isn't that sort of an oxymoron?
10:51:25 <Keiya> I think we got 'im. :J
10:51:28 <Makoryu> But that's beside the point
10:51:35 <sohum> Athas: of course, this is with the understanding that a lot of what would be radical ripping-out-changes in other languages /is/ a change to the standard library in CL
10:51:40 <Berengal> Orclev, "radical" as in "awesome"?
10:51:41 <idnar> Keiya: do you return coffee?
10:51:56 <Athas> Lisp is so powerful that you can't really *say* anything about Lisp programs.  I think Haskell is less powerful than Lisp, but while it's possible to make Haskell stronger, it's not really feasible to grant Lisp more static guarantees.
10:52:01 <Orclev> Berengal: ah, that at least makes a bit more sense
10:52:04 <Woof> :t Keiya
10:52:05 <lambdabot> Not in scope: data constructor `Keiya'
10:52:14 <Woof> No idea, idnar
10:52:17 <Keiya> idnar: Yeah, but I still wonder why they were asking for a Maybe Drink :P
10:52:22 <idnar> Woof: heh
10:52:26 * coyo listens
10:52:29 <idnar> Keiya: haha
10:52:47 <sohum> Athas: fr'instance, Qi is written in CL, I believe, and it has static typing
10:53:02 <Keiya> Oooh, coyo, look at this:
10:53:02 <Keiya> http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
10:53:20 <Athas> sohum: that's not really a reasonable comparison, Qi hides much of CL.  Yale Haskell was written in CL too.
10:53:31 <Axman6> that's a terribly inefficient implementation of quicksort though
10:53:34 <Keiya> (Note that quicksort in haskell isn't used very often)
10:53:37 <Keiya> And yeah, it is.
10:53:44 <Athas> Can you even claim it to be quicksort?
10:53:50 <roconnor> note that it isn't really quicksort.
10:53:54 <Berengal> slowsort
10:53:57 <Keiya> Heh
10:53:59 <Keiya> Either way
10:54:00 <roconnor> it is a deforested treesort
10:54:06 <danr> i need to force evaluation of a list, how can I do that? rnf does not seem to be the trick
10:54:07 <Athas> That implementation doesn't have the asymptotic complexity which is supposed to be the point of qsort.
10:54:34 <Keiya> It's still kinda instructive as to the difference in approach.
10:54:35 <Orclev> coyo: haskell, like most functional languages is easiest to understand when working with something that uses a concrete algorithm... more traditional programs tend to get bogged down with some more advanced ideas like State monads
10:55:00 <roconnor> danr: I usually force the length of the list, but the proper thing to do is fold a seq over the list.
10:55:10 <sohum> Athas: but see, /that's the thing/. It is /possible/ to hide most of CL in CL, and so arbitrarily drawing a line and saying "anything more than this isn't /really/ an improvement to CL per se and so CL is a local maxima" when the very reason CL is different is that it allows for that amount of power is kinda ... missing the point?
10:55:23 * Axman6 quite likes his parallel implementation of quicksort in haskell, but it's probably not all that great (though faster than Data.List.sort on random data)
10:55:28 <danr> roconnor: i'll give that a try, thanks
10:56:26 * Keiya sighs
10:56:34 <Athas> sohum: no, because you can't really *know* that those parts aren't being accessed.  I wrote a bunch of code for a CL development environment, and one major problem was that the code being edited could really be expressing whatever.
10:56:39 <Keiya> My copy of RWH is miles and miles away >_>
10:56:51 <Athas> Analysing a Lisp program is really about loading it and then analysing the resulting image.
10:56:53 <Keiya> Stupid leaving things at home when I move into the dorms >_>
10:56:57 <sohum> Athas: what sense of "maxima" are you using?
10:57:02 <Orclev> Keiya: it's available online you know
10:57:09 <Keiya> Orclev: Yeah, but paper is nice
10:57:12 <sohum> Athas: because I don't see how that reduces the expressive power of the language at all
10:57:20 <sohum> Athas: and that's what I was assuming
10:57:22 <Keiya> I can have it open next to me :J
10:57:41 <Orclev> Keiya: true enough
10:57:54 <Athas> sohum: well, it's pretty obvious that I'm not using a formal definition here.  I'm saying that you can't really extend CL beyond its current abilities without first removing/obscuring something.
10:58:17 <Keiya> I also left behind my prefered java book. And yet somehow remember my book on 68k assembly!
10:58:26 <Orclev> so, I never got a response earlyer, did anyone take a look at my versioning idea? http://github.com/orclev/versioningidea
10:58:53 <Orclev> Keiya: I'm trying to figure out how you would simultaneously need Java and 68k assembly and utterly failing
10:58:59 <Makoryu> Keiya: There's a winner if I ever saw one :p
10:59:12 <Keiya> Orclev: Multiple projects. :P
10:59:20 <Athas> Is XHB still under maintenance/development?
10:59:27 <Keiya> Alternatively writing a 68k emulator, but that's not what I'm doing
10:59:34 <Athas> The xlib bindings are fairly awful, and XCB looks like the wave of the future.
10:59:40 <Orclev> Keiya: oooh, good example
11:00:05 <sohum> Athas: fair enough. I guess what I'm saying is that while that statement is technically true, it's really counter to the spirit of actual development in CL. that old saw about "rewriting the boundaries between your language and your program" etc.
11:00:14 <Keiya> Oh, also, Coyo?
11:00:15 <Keiya> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
11:00:25 <Keiya> So yeah, it's doable :P
11:00:58 <Keiya> (That's /not/ a beginner-level thing, but it's existing, so)
11:01:15 <Axman6> it's not too far from beginner level though
11:01:23 <Keiya> Yeah, it's not
11:01:23 <Axman6> sohum: why aren't you asleep man?
11:02:08 <sohum> Sometimes I wish haskell had a VM with on-the-fly reloading of code
11:02:14 <sohum> Axman6: why aren't you? :P
11:02:26 <Axman6> just got home from my girlfriends house
11:02:59 <Makoryu> sohum: Work on slimming down the GHC internals and maybe it could sorta >_>
11:03:01 <sohum> signficantly geekier reason: maths assignment which drifted into #haskell drawing me in ;)
11:03:25 <Axman6> heh
11:03:36 <sohum> Makoryu: is that the main reason why there's none atm?
11:03:43 <Axman6> yeah i'm quite glad i'm not doing any maths this semester
11:03:54 * coyo return and reads the massive scrolly
11:04:02 <Axman6> well, signal processing is all maths, but it's fu maths
11:04:13 <sohum> heh
11:04:14 <Keiya> +n?
11:04:20 <copumpkin> sohum: the main reason is that there are only four or five people who do most of the GHC work
11:04:33 <Makoryu> sohum: Well, hs-plugins can already compile code and re-execute the binary with the new code linked into it, which is close, but not the same thing. But even for that, GHC is a huge dependency
11:04:41 <coyo> keiya: what's +n?
11:04:45 <sohum> copumpkin: ...whoa. four or five /awesome/ people, I'd suppose
11:04:49 <Orclev> coyo: there tends to be a lot that goes on in here, but you can usually skim most of it
11:05:04 <Keiya> coyo: A change to the 'fu' which I think is supposed to be 'fun' iun the line13:03:47 < Axman6> well, signal processing is all maths, but it's fu maths
11:05:08 <Keiya> :P
11:05:16 <coyo> oh
11:05:23 <copumpkin> sohum: well, a lot of patches from individual contributors, but there aren't very many people who dedicate most of their time to it, and it's a massive project
11:05:28 <coyo> i thought i was a mode
11:05:29 <Axman6> Keiya: uh, yeah
11:05:33 <coyo> *it
11:05:39 <Orclev> s/fu/fun/... my Perl background is showing
11:05:44 <sohum> Makoryu: and there're libs to directly access ghc from haskell, yep.
11:05:46 <Keiya> It's either fu+n or fu+ck...
11:05:47 <Keiya> :P
11:06:02 <sohum> Orclev: you mean /regex/ background.
11:06:11 <Orclev> sohum: more or less the same difference
11:06:15 <benmachine> sed
11:06:25 <Axman6> sohum: you really need to watch some of Simon Peyton Jones' talks, they're amazing, and oh so awesome
11:06:30 <Orclev> regex is really the workhorse of perl
11:06:54 <sohum> Orclev: pfffffff. perl didn't invent regexes, just made them require non-regular grammars ;)
11:07:14 <Orclev> sohum: you have to admit though that some of the perl extensions to regex are rather nice
11:07:15 <coyo> o.o
11:07:28 <Keiya> Bah, perl! Sed for the win!
11:07:35 * Makoryu looks at all the perl discussion
11:07:38 <mux> like embedding conditional tests in regexps? :-P
11:07:38 <shapr> LAMBDASED!
11:07:38 * Makoryu clears throat
11:07:39 <Makoryu> Ahem.
11:07:42 <Makoryu> U MENA HASKAL
11:07:53 <mux> seriously, regexps are nothing but obfuscated parsing combinators
11:08:00 * coyo tilts his head, wide eyed
11:08:07 <Axman6> obfuscated? offt
11:08:11 <Axman6> pfft too!
11:08:11 <sohum> Orclev: well, it's a grudging admittance. because the price of losing /regularity/ in /regular expressions/ is kinda /really high/
11:08:14 <Orclev> Makoryu: shouldn't that be haskell?
11:08:21 <coyo> .wp Sed (programming language)
11:08:21 <Makoryu> Orclev: ...Yes >_>
11:08:29 <Orclev> sohum: fair enough
11:08:32 <coyo> ...
11:08:36 <Makoryu> Orclev: It should also be "you mean"
11:08:38 * coyo facepalms
11:08:51 <Keiya> coyo: This isn't #gender, there's no feepbot
11:08:52 <Keiya> :P
11:08:56 <coyo> is there wikipedia link fetching here?
11:09:12 * coyo sees an opportunity!
11:09:14 <sohum> Axman6: you wouldn't happen to have the talks downloaded, would you? ;)
11:09:15 <Orclev> lambdabot does something like that
11:09:17 <benmachine> @let wp = ("http://en.wikipedia.org/wiki/"++)
11:09:18 <lambdabot>  Defined.
11:09:28 <Keiya> http://en.wikipedia.org/wiki/Sed
11:09:30 <benmachine> > wp "Sed (programming language)"
11:09:31 <lambdabot>   "http://en.wikipedia.org/wiki/Sed (programming language)"
11:09:31 <Orclev> coyo: lambdabot does just about anything you could possible think of, and a few things you couldn't
11:09:35 <benmachine> almost.
11:09:41 <benmachine> @let wp = text . ("http://en.wikipedia.org/wiki/"++)
11:09:42 <lambdabot>  <local>:15:0:
11:09:42 <lambdabot>      Multiple declarations of `L.wp'
11:09:42 <lambdabot>      Declared at: <local>...
11:09:43 <Axman6> sohum: one or two maybe. i'll find links though
11:09:45 <benmachine> :(
11:10:01 <Keiya> It's actually, um, just sed, not sed (programming llanguage)
11:10:01 <benmachine> how do I delete @lets apart from with @undef?
11:10:14 <Makoryu> benmachine: That's the only way.
11:10:20 <coyo> benboxen: so it wont automatically overwrite the definition, like in lisp?
11:10:21 <benmachine> daaang
11:10:32 <Makoryu> benmachine: I guess someone could write a patch for that...
11:10:42 <Keiya> coyo: *shudder*
11:10:47 <Keiya> That would break haskell utterly
11:11:03 <Keiya> Referential transparency means you /can't/ redefine.
11:11:04 <sohum> coyo: well, normally you don't define things more than once in haskell. no vms or on-the-fly patching or anything similar. lambdabot is ... kinda a special case
11:11:07 <deech> Hi all, when I compile my .hs file using 'ghc --make' it automatically brings in all my imports, but when I  make a .cabal file for the project I have to specify all the imports manually. Is that correct?
11:11:13 <Makoryu> coyo: Haskell's declaration blocks (anything after let or where) are like letrecs rather than Lisp's lets
11:11:20 <dcoutts> deech: yes
11:11:41 <benmachine> Keiya: @let isn't really haskell though
11:11:57 <coyo> lisp is good for tinkering and patching, it seems
11:11:57 <Keiya> No, it's not, but
11:11:59 <Keiya> Anyway
11:12:13 <malcolmw> CUFP videos now uploaded --->  http://www.vimeo.com/album/128851
11:12:14 <Keiya> coyo: Yah, but there are haskell tools for doing such too :J
11:12:17 <dcoutts> deech: the reason is that cabal projects are for distribution and so it becomes important to be able to know in advance what the dependencies are. It allows automatic package management.
11:12:22 <dcoutts> malcolmw: yay :-)
11:12:26 <coyo> keiya: lemme see
11:12:29 <deech> Is there any way to autogenerate this file based on the imports?
11:12:45 <benmachine> the thing that most annoys me about lambdabot is the automatic spelling correction
11:12:48 * dcoutts has already updated a couple pages to point to the videos
11:12:53 <benmachine> for ages I thought there was an @info command but
11:13:08 <benmachine> @info do { x <- a; return x }
11:13:08 <lambdabot> a >>= \ x -> return x
11:13:08 <Makoryu> deech: This is a somewhat frequent feature request, but I haven't seen a patch for it yet
11:13:10 <deech> Or for that matter to know the name of the package each import belongs to?
11:13:16 <benmachine> it is actually just @undo
11:13:16 <Axman6> sohum: this one's good: http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/ and basically any of his videos on http://www.haskell.org/haskellwiki/Video_presentations
11:13:24 <dcoutts> deech: ghc tells you when you get it wrong
11:13:34 <Orclev> .... how is @info @undo?
11:13:44 <coyo> O.O
11:13:45 <sohum> coyo: oh, absolutely. ghci is neat, but there's nowhere near the level of exploratory programming possible in haskell. which is kinda what you'd expect from a static language, I suppose
11:13:52 <benmachine> Orclev: the keys are right next to each other
11:13:54 <sohum> Axman6: shiny, thanks
11:14:03 <dcoutts> deech: as Makoryu says, there's a feature request about it but implementing it is a bigger task than you might think at first.
11:14:10 * benmachine wonders how many times that is said on IRC while actually being true
11:14:23 * coyo likes the idea of exploratory metaprogramming promised by lisp
11:14:24 <dcoutts> deech: especially once you start thinking about preprocessors
11:14:36 <Athas> I find that the old-fasioned write-compile-debug cycle is surprisingly effective in Haskell.
11:14:55 <Orclev> benmachine: that's mind numbingly stupid... there should at least be some kind of check where if over 50% of the letters don't match it doesn't correct to it
11:15:01 <Athas> Mostly because I find that a preceding "think" phase is the dominating factor, and the "debug" component is very small.
11:15:01 * coyo will stick with that for now
11:15:06 <jmcarthur_work> we often lack the debug part of that cycle
11:15:08 <c_wraith> Haskell's cycle is more along the lines of write-compile-debug-run-debug
11:15:12 <benmachine> Orclev: how about if over 0% of the letters are wrong it doesn't correct it
11:15:24 <sohum> coyo: but yea, because Haskell is so /lean/, the standard compile cycle works fine for it
11:15:26 <deech> Ah, so the lesson is to start with the .cabal file.
11:15:27 <Axman6> Athas: agreed
11:15:35 <dcoutts> deech: right
11:15:42 <coyo> okay, i'm ready to begin
11:15:43 <Makoryu> @doh ap
11:15:43 <lambdabot> ap
11:15:53 <Orclev> I find that ghci foo.hs, :e, :r takes care of a lot
11:16:09 * coyo reads the links for hints on how to get started
11:16:09 <Makoryu> @waxon Yo dawg
11:16:09 <lambdabot> Solutions are not the answer.
11:16:10 <dcoutts> deech: byorgey is writing a new $ cabal init  feature, but it's not integrated yet. You can look at the user guide and existing examples.
11:16:11 <Axman6> coyo: do you have a tutorial to follow?
11:16:28 <sohum> Orclev: or, streamline that even more with haskell-mode and C-c C-l
11:16:31 <coyo> it appears i do not
11:16:34 <coyo> i could google
11:16:38 <Axman6> @where lyah
11:16:39 <lambdabot> www.learnyouahaskell.com
11:16:39 <Orclev> sohum: >_> emacs
11:16:40 <sohum> coyo: RWH is good
11:16:42 <Axman6> use that one
11:16:43 <byorgey> yep, I should be getting around to finishing that up soon
11:16:56 <Axman6> i highly recommend learn you a haskell before reading RWH
11:16:58 <Orclev> I liked learn you a haskell
11:17:04 <Makoryu> coyo: You'll probably want to start with LYAH, and move onto RWH when you're comfortable
11:17:06 * coyo lol'd at that site
11:17:08 <sohum> is lyah really that good?
11:17:11 <deech> dcoutts: will do thanks and lesson learned. Time to go my .cabal working!
11:17:12 <Axman6> yes
11:17:14 <sohum> it looked kinda janky
11:17:18 <Axman6> well, from what i've seen of it
11:17:22 <sohum> Orclev: ^_^ emacs
11:17:39 <Orclev> sohum: it's quirky for sure, but good, and the quirks help you remember a lot of it
11:17:51 <Keiya> /A/ haskell?
11:17:54 <coyo> it looks great
11:17:54 <Keiya> There's more than one?
11:18:00 * Axman6 thinks that RWH will need a second edition to make it a good beginners book
11:18:01 <Keiya> Then again...
11:18:04 * coyo noms the haskells
11:18:09 * Keiya glomps a coyo :P
11:18:18 * coyo is glomp
11:18:21 <coyo> d
11:18:24 <coyo> ...
11:18:24 <sohum> Orclev: no, I love quirky. _why was like one of my favourite people. but the type of quirky matters, and this looked... not so much with the charming.
11:18:51 <Keiya> _why is awesome. Like a butterfly filled with jelly.
11:18:52 <Athas> I dislike pointless quirkiness.  It's just... noise.
11:19:25 <Axman6> LYAH uses quirkiness quite effectively imo
11:19:41 <sohum> fair enough. I will reassess, then.
11:19:41 <Axman6> like, explaining lists as catapillars
11:20:16 <Axman6> O:oOoOoOoO <- catapillar list >_>
11:20:19 * Orclev Kirk voice: "CONS!!!!!"
11:20:57 <coyo> o.O
11:20:58 <jmcarthur_work> i liked _why because the quirkiness was almost like a kind of art. i think i would have liked it less if it seemed that the point was to attract certain kinds of beginners to the poignant guide, but it really seemed to be done for its own sake more than anything
11:21:03 <Orclev> > 1:2:3:4:[]
11:21:03 <lambdabot>   [1,2,3,4]
11:21:15 <Makoryu> Axman6: I seem to recall that exact metaphor being used in the Poignant Guide
11:21:24 <sohum> jmcarthur_work has the exact words I was trying to find
11:21:26 <coyo> "The channel #haskell on the freenode network is a great place to ask questions if you're feeling stuck. People there are extremely nice, patient and understanding to newbies. " <-- that's rare. you guise are awesome! <3
11:21:29 <Makoryu> Axman6: Except it also mentioned the caterpillar being stapled to the screen or something
11:21:29 <Axman6> yeah but screw ruby >_>
11:21:48 <sohum> Axman6: yeah but screw you ;)
11:21:58 <Orclev> :t (:)
11:21:59 <lambdabot> forall a. a -> [a] -> [a]
11:22:02 <Axman6> coyo: like i said, haskell's community is one of its best assets
11:22:06 <coyo> ruby is japanese, isnt it?
11:22:13 * coyo hugs axman
11:22:26 <jmcarthur_work> originated and popularized in japan at first
11:22:26 <Axman6> ruby is damn slow, that's pretty much all i care about it
11:22:30 <coyo> yanno, that name reminds me of the adorable alien from animorphs
11:22:32 <Orclev> coyo: the original creator was Japanese I think
11:22:34 <Makoryu> coyo: Yup, the author was sick of using Sepples and decided to throw Perl, Lisp, and Smalltalk into a blender
11:22:37 <nominolo> @losers
11:22:37 <lambdabot> Unknown command, try @list
11:22:41 <nominolo> @users
11:22:41 <lambdabot> Unknown command, try @list
11:22:48 <Axman6> coyo: man, i loved those books :)
11:22:52 <nominolo> wtf?
11:22:55 <Makoryu> Eventually the western world got a hold of it and made Rails, but yeah
11:22:57 <sohum> he took the best bits of all of them! except perl, because there /are/ no best bits of perl
11:23:11 <Makoryu> sohum: There's plenty of good stuff in Perl
11:23:13 <Orclev> sohum: :P
11:23:14 <Axman6> wtf? where'd @users go?
11:23:17 <sohum> so all the perl stuff is being deprecated
11:23:28 <sohum> Makoryu: sorry, *tongue in cheek*
11:23:42 <Axman6> anyway, sleep time. night all
11:23:44 <Makoryu> sohum: For example, "expr control_keyword stuff" instead of "control_keyword stuff { expr }"
11:24:06 <Makoryu> Little things like that
11:24:10 <coyo> nini axman
11:24:14 <sohum> Makoryu: that's from perl? huh.
11:24:18 <Orclev> yeah, I always like the literal-ness of "open foo or die"
11:24:33 <Saizan> nominolo: [de]serializing Plugin.Seen state has been broken for a long time, recently it got disabled until someone fixes it
11:24:44 <Makoryu> sohum: I haven't seen it in a whole lot of languages since then.... ¬Ø\O_o/¬Ø
11:25:14 <nominolo> Saizan: ah, hm.  too bad
11:25:24 <sohum> Makoryu: mm. I like it for one-line conditionals, qux += foo(bar) unless qaz
11:25:34 <Makoryu> sohum: Exactly
11:25:41 <copumpkin> by the way, if anyone felt the urge to evangelize haskell but was unable to because the haskell platform url was too long, haskell.org/platform now works too
11:25:55 <copumpkin> ;)
11:25:57 <Orclev> copumpkin: nice
11:26:06 <benmachine> I hate postfix conditionals
11:26:19 <benmachine> they are confusing to read
11:26:22 <Makoryu> copumpkin: Now if only we didn't have to wait till 2010 for a 6.12 platform ;)
11:26:49 <copumpkin> Makoryu: I have no control over that :) I just fired an email off to the haskell.org administrator to ask for the redirect :P
11:26:53 <Orclev> after reading about a couple of the changes in 6.12 I can't wait for it
11:27:10 <sohum> benmachine: they read more naturally in certain cases, I find. stack.pop unless stack.empty? and suchlike
11:27:45 <benmachine> sohum: I think naturality is overrated
11:27:47 <Makoryu> copumpkin: I know, it's a totally different issue :p
11:28:12 <Keiya> "If you say that a is 5, you can't say it's something else later because you just said it was 5. What are you, some kind of liar?" <- Bad analogy, especially once you start modeling reality. But anyway.
11:28:13 <benmachine> english-like programming languages seem to have forgotten the fact that english is an exceptionally complicated syntax
11:28:18 <Makoryu> copumpkin: And it's actually good that some testing and bugfuxing goes into 6.x before the platform includes it
11:28:23 <benmachine> and I really don't know why anyone would want to imitate it
11:28:43 <benmachine> (not that I don't like the language; I just don't tell computers what to do in it)
11:29:00 <Keiya> benmachine: Unless they're Apple, in which case it makes perfect sense.
11:29:08 <Keiya> Apple hates computers.
11:29:13 <Orclev> benmachine: because it's also an incredibly expressive and flexible syntax... with the caveat that you can easily make ambigous statements
11:29:37 <benmachine> Orclev: I don't really want flexible
11:29:39 <coyo> i find that i like languages with lots of coyo.getLink().getSomeAction("heck yus"); stuff going on for some reason
11:29:41 <benmachine> I want to know what to expect
11:29:48 <coyo> it must be my java exposure >.<;
11:30:05 <Orclev> coyo: it wears off quickly fortunately
11:30:11 <coyo> oh good
11:30:25 <sohum> benmachine: that's a criticism more rightfully leveled at perl, than ruby. postfix conditionals are /easier to understand/ in certain conditions, and it doesn't really harm the grammar to add them
11:30:27 <coyo> how would a similar statement be made in haskell?
11:30:54 <Makoryu> coyo: getSomeAction "heck yus" . getLink $ coyo, probably
11:31:00 <Orclev> coyo: that's not really a fair comparison, you're taking something designed around a OO paradigm
11:31:04 <benmachine> sohum: I think their presence is more to remember
11:31:06 <coyo> o.o interesting
11:31:13 <benmachine> but if we're talking about ruby, I haven't really used it enough to comment
11:31:14 <Orclev> coyo: there's many ways to do something similar
11:31:26 <Makoryu> coyo: But then, it depends on the types of the functions involved
11:31:37 <coyo> so i have to unlearn oop?
11:31:43 <Orclev> coyo: yes and no
11:32:00 <Orclev> coyo: you have to learn a new paradigm, if that requires you unlearning the old one first, the yes
11:32:01 <coyo> explain?
11:32:11 <coyo> hmm
11:32:23 <coyo> i can handle two paradigms, i think
11:32:34 <coyo> i'm young enough
11:32:35 * coyo is 21
11:32:42 <Orclev> coyo: you are probably like me when I first started, you tend to think in members, for loops, and collecting modification
11:32:42 <ksf> "Timings were done on a 500mhz Pentium with 128meg RAM, and it's actually the number of cursor blinks not seconds."
11:32:54 <ksf> the numbers are 0, 0, 11, 4, 65 and 100
11:32:58 <sohum> benmachine: fair enough
11:33:07 <jmcarthur_work> coyo, that would be written in haskell as (assuming point free style in which the final argument is left off): someAction "heck yus" . link
11:33:13 <copumpkin>  coyo: too old, sorry!
11:33:29 <sohum> coyo: quick, how would you sum the numbers in a list?
11:33:32 <Orclev> coyo: give it a little while and you'll begin to appreciate things like map and foldr (or foldl)
11:33:33 <bandu> NOOOOOOOOOO!
11:33:41 * bandu faints
11:33:47 <bandu> :P
11:34:07 <Orclev> > foldl (+) 0 [1..10]
11:34:08 <lambdabot>   55
11:34:21 <jmcarthur_work> > sum [1..10]
11:34:22 <Orclev> simple once you get used to it
11:34:22 <lambdabot>   55
11:34:27 <sohum> the question wasn't for you, Orclev ;)
11:34:28 <jmcarthur_work> ;)
11:34:34 <bandu> @summarize [23,5]
11:34:34 <lambdabot> Unknown command, try @list
11:34:48 <bandu> > [23,5]
11:34:49 <lambdabot>   [23,5]
11:35:06 <Orclev> sohum: yes I know, but it's obvious from the contect he's expected to say something about a for loop or some such
11:35:10 <Orclev> context
11:35:12 <bandu> > sum [23,5]
11:35:13 <lambdabot>   28
11:35:21 <sohum> Orclev: ;)
11:35:28 <sohum> @src sum
11:35:28 <lambdabot> sum = foldl (+) 0
11:35:30 <RayNbow> > sum [23,5] :: Expr
11:35:30 <lambdabot>   0 + 23 + 5
11:35:41 <byorgey> > foldl (*) 1 [23,5,19,6]
11:35:42 <lambdabot>   13110
11:35:47 <byorgey> > foldl max 0 [23,5,19,6]
11:35:47 <lambdabot>   23
11:35:49 <sohum> there's an Expr defined in lambdabot?
11:35:54 <Makoryu> > foldl (*) 1 [23,5,19,6] :: Expr
11:35:55 <lambdabot>   1 * 23 * 5 * 19 * 6
11:36:00 <byorgey> @where Expr
11:36:00 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
11:36:07 <RayNbow> > foldr f z [x,y,z]
11:36:08 <lambdabot>   f x (f y (f z z))
11:36:17 <jmcarthur_work> i wonder what the smallest ordered pair of integers such that those integers do not appear at the beginning of any of the sequences in the OEIS
11:36:20 <jmcarthur_work> is
11:36:51 <byorgey> jmcarthur_work: smallest according to what metric?
11:36:51 <monoidal> lexicographically?
11:37:09 <Orclev> :t foldl
11:37:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:37:26 <ksf> time to figure out?
11:37:28 <Makoryu> @oeis 3, 33333
11:37:28 <lambdabot>  Sequence not found.
11:37:41 <Makoryu> @oeis 5, 42
11:37:41 <lambdabot>  Coefficient triangle for certain polynomials N(2; n,x) (rising powers of x).
11:37:42 <lambdabot>  [1,2,1,5,6,2,14,28,20,5,42,120,135,70,14,132,495,770,616,252,42,429,2002,400...
11:37:44 <Makoryu> ffff
11:37:50 <lilac> @oeis 0 994
11:37:50 <lambdabot>  Sequence not found.
11:37:56 <lilac> yay
11:38:05 <bandu> @oeis 2 4 8
11:38:05 <lambdabot>  Powers of 2: a(n) = 2^n.
11:38:05 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:38:07 <monoidal> @oeis 0 42
11:38:08 <lambdabot>  Catalan triangle (with 0's). Inverse lower triangular matrix of A049310(n,m)...
11:38:09 <lambdabot>  [1,0,1,1,0,1,0,2,0,1,2,0,3,0,1,0,5,0,4,0,1,5,0,9,0,5,0,1,0,14,0,14,0,6,0,1,1...
11:38:09 <bandu> <3
11:38:20 <sohum> hah,, that expr's pretty cool
11:38:34 * Makoryu tries to remember the happy primes question from Doctor Who
11:38:49 <bandu> @oeis 2 3 5
11:38:50 <lambdabot>  The prime numbers.
11:38:50 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
11:38:54 <Gilly> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
11:38:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
11:38:58 <copumpkin> @oeis 2
11:39:00 <lambdabot>  The prime numbers.
11:39:00 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
11:39:01 <Keiya> > succ succ succ succ succ succ succ succ succ succ 0
11:39:02 <lambdabot>   No instance for (GHC.Enum.Enum
11:39:02 <lambdabot>                     (((((((((a -> a) -> a ->...
11:39:12 <Keiya> ...
11:39:12 <Makoryu> @oeis 313, 331, 367, 379
11:39:13 <lambdabot>  Odious primes: primes with odd number of 1's in binary expansion.
11:39:13 <lambdabot>  [2,7,11,13,19,31,37,41,47,59,61,67,73,79,97,103,107,109,127,131,137,151,157,...
11:39:14 <copumpkin> Keiya: function application is left-associative
11:39:19 <benmachine> > succ . succ . succ . succ $ 0
11:39:19 <lambdabot>   4
11:39:22 <Keiya> Oh.
11:39:23 <lilac> more formal statement: what's the sequence of numbers with the smallest absolute sum which doesn't match an OEIS sequence?
11:39:28 <Keiya> Right...
11:39:30 <Keiya> so
11:39:30 <pikhq> > succ . succ . succ . succ . succ . succ . succ . succ . succ . succ $ 0
11:39:31 <lambdabot>   10
11:39:36 <Keiya> Yeah
11:39:40 <Makoryu> :t compose
11:39:41 <lambdabot> Not in scope: `compose'
11:39:44 <benmachine> > foldr (.) id [succ, succ, succ, succ, succ] 0
11:39:44 <lambdabot>   5
11:39:57 <Makoryu> @let compose = foldr1 ($)
11:39:57 <lambdabot>  <local>:16:17:
11:39:57 <lambdabot>      Occurs check: cannot construct the infinite type: a = a ...
11:39:58 <sohum> > succ . succ . succ $ succ 0
11:39:59 <lambdabot>   4
11:40:01 <Makoryu> fff
11:40:09 <Makoryu> @let compose = foldr ($) id
11:40:10 <lambdabot>  Defined.
11:40:24 <benmachine> > compose [succ, succ] 0
11:40:24 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
11:40:24 <lambdabot>    arising from a use of `GHC.Enum...
11:40:39 <monoidal> @let compose = foldr (.) id
11:40:40 <lambdabot>  <local>:17:0:
11:40:40 <lambdabot>      Multiple declarations of `L.compose'
11:40:40 <lambdabot>      Declared at: <l...
11:40:41 <benmachine> :t compose
11:40:42 <sohum> > compose [succ, succ] $ 0
11:40:42 <lambdabot> forall a. [(a -> a) -> a -> a] -> a -> a
11:40:43 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
11:40:43 <lambdabot>    arising from a use of `GHC.Enum...
11:40:43 <Makoryu> :t compose [succ,succ]
11:40:44 <lambdabot> forall a. (Enum (a -> a)) => a -> a
11:40:50 <benmachine> @undef
11:41:01 <benmachine> @let compose = foldr (.) id
11:41:02 <lambdabot>  Defined.
11:41:24 <monoidal> or, flip $ foldr ($)
11:41:26 <sohum> > compose [succ, succ] $ 0
11:41:27 <benmachine> compose [succ, succ, (*3), succ] 1
11:41:27 <lambdabot>   2
11:41:36 <benmachine> > compose [succ, succ, (*3), succ] 1
11:41:37 <lambdabot>   8
11:41:52 <Makoryu> > compose . replicate 10 succ $ 0
11:41:53 <lambdabot>   Couldn't match expected type `a -> [a1 -> a1]'
11:41:53 <lambdabot>         against inferred typ...
11:42:00 <Orclev> bandu: btw, one of the other things that haskell does that's pretty cool is you can work with infinite lists (or structures in general)
11:42:01 <Makoryu> > compose (replicate 10 succ) $ 0
11:42:02 <lambdabot>   10
11:42:19 <bandu> oh i see
11:42:43 <Orclev> > take 10 [1..]
11:42:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:42:44 <bandu> but the only way you can do that is to hold the /definition/ of the list in memory, amirite?
11:43:15 <bandu> like, a pattern definition
11:43:18 <sohum> bandu: well, that's handled for free because haskell's lazily evaluated
11:43:37 <sohum> :t enumFrom
11:43:38 <lambdabot> forall a. (Enum a) => a -> [a]
11:43:49 <Orclev> take 10 $ map (+1) [1..]
11:43:53 <Orclev> > take 10 $ map (+1) [1..]
11:43:54 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
11:44:36 <sohum> more interestingly
11:44:44 <Orclev> bandu: you need the take 10 there of course otherwise lambdabot would hang trying to output forever
11:44:47 <Makoryu> bandu: Whenever you bind a value, you're actually binding a "thunk," or a piece of code that, when run, evaluates to that value.
11:45:11 <sohum> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
11:45:12 <lambdabot>  Defined.
11:45:19 <sohum> take 10 fibs
11:45:26 <sohum> > take 10 fibs
11:45:27 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
11:45:43 <Makoryu> bandu: In the case of an enumerated list like that, evaluating any "cell" of the list gives you two thunks: One for the value it holds, and one for the remainder of the list
11:46:16 <sohum> that /creates/ an infinite lazy list, that you can work with as normal.
11:46:23 <Makoryu> > length . take 9000 $ cycle [undefined]
11:46:24 <lambdabot>   9000
11:46:35 <Makoryu> > undefined
11:46:36 <lambdabot>   * Exception: Prelude.undefined
11:46:47 <Orclev> :t cycle
11:46:47 <lambdabot> forall a. [a] -> [a]
11:46:53 <Makoryu> > error "Whoops"
11:46:54 <lambdabot>   * Exception: Whoops
11:46:57 <Makoryu> > fix error
11:46:58 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
11:47:06 <nyingen> The other day I discovered 'iterate'
11:47:08 <sohum> @src fix
11:47:08 <lambdabot> fix f = let x = f x in x
11:47:19 <nyingen> You can implement L-systems very easily with 'iterate'
11:47:40 <monoidal> iterate error $ fix error
11:47:48 <monoidal> > iterate error $ fix error
11:47:48 <lambdabot>   ["* Exception: * Exception: * Exception: * Exception: * Exception: * Except...
11:47:49 <sohum> @pl \f -> let x = f x in x
11:47:49 <lambdabot> fix
11:48:00 <sohum> booo, lambdabot
11:48:03 <nyingen> what does @pl do?
11:48:09 <sohum> pointless
11:48:17 <sohum> @pl \x y -> x + y
11:48:17 <lambdabot> (+)
11:48:20 <nyingen> hmm
11:48:26 <sohum> @pl \x y -> f y x
11:48:32 <monoidal> attempts to eliminate all lambdas
11:48:36 <lambdabot> flip f
11:48:46 * lilac just got how "fix error" works
11:48:57 <nyingen> fix is interesting
11:48:59 <lilac> it always bugged me how it appears to produce a string
11:49:08 <lilac> whereas error should always result in an exception
11:49:08 <copumpkin> lilac: it fixes all your error
11:49:12 <copumpkin> (are you belong to fix)
11:49:13 <sohum> :t fix
11:49:14 <lambdabot> forall a. (a -> a) -> a
11:49:35 <lilac> but it's not producing a string, lamdabot just makes it look like one
11:49:51 <copumpkin> :t error
11:49:51 <lambdabot> forall a. [Char] -> a
11:50:14 <copumpkin> it is producing a string!
11:50:18 <sohum> :t fix error
11:50:18 <lambdabot> [Char]
11:50:26 <ksf> :t error
11:50:27 <lambdabot> forall a. [Char] -> a
11:50:29 <ksf> :t fix
11:50:30 <lambdabot> forall a. (a -> a) -> a
11:50:35 <Orclev> if I'm reading fix right isn't the same as f (f (f... for an ifinite amount of fs?
11:50:38 <ksf> ...should be obvious.
11:50:51 <sohum> > fix $ error "fixity!"
11:50:51 <lambdabot>   * Exception: fixity!
11:51:01 <sohum> oh, right, doy
11:51:13 <lilac> ksf: right, but "error a" gives an exception for all a
11:51:16 <lilac> plus...
11:51:19 <ksf> the show instance doesn't get further than noticing that's its the string char instance, though.
11:51:22 <lilac> > error (error "hello")
11:51:23 <lambdabot>   * Exception: hello
11:51:26 <ksf> ...as then, it hits bottom.
11:51:33 <nyingen> how is @pl implemented?
11:51:34 <lilac> ^ * Exception only appears once
11:52:07 <ksf> so first it produces " as all strings start with that, and then lazily fails towards infinity.
11:52:22 <ksf> > take 20 $ fix error
11:52:22 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
11:52:26 <ksf> > take 2 $ fix error
11:52:27 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
11:52:36 <sohum> it's not a list
11:52:46 <sohum> it's an actual exception
11:52:47 <lilac> ksf: no, it's more complex than that. trying to show the exception results in an exception, so mueval tries to show that, which results in an exception, os...
11:53:09 <ksf> makes sense.
11:53:20 <nyingen> (nevermind, I forgot I already have the source to lambdabot)
11:53:43 <Orclev> > take 5 $ fix (\x -> x + 1)
11:53:43 <lambdabot>   No instance for (GHC.Num.Num [a])
11:53:44 <lambdabot>    arising from the literal `1' at <inter...
11:53:50 <Baughn> kpreid: In what way is that not a latex quine?
11:54:10 <lilac> Baughn: traditionally quines which read their own source code off the disk don't count :)
11:54:21 <kpreid> just so
11:54:23 <Orclev> > take 5 $ fix (\x -> x + (1 :: Int))
11:54:24 <lambdabot>   Couldn't match expected type `[a]'
11:54:24 <lambdabot>         against inferred type `GHC.Types...
11:54:25 <monoidal> > error (error "A")
11:54:25 <lambdabot>   * Exception: A
11:54:58 <monoidal> error $ error "A"
11:55:30 <Orclev> :t fix
11:55:31 <lambdabot> forall a. (a -> a) -> a
11:55:32 <kpreid> lilac: would you happen to know of a way to formalize that constraint?
11:55:55 <Baughn> kpreid: The type of a quine does not include IO? :
11:56:01 <sohum> > fix (\f x -> if f x = 0 then 0 else 1) 0
11:56:02 <lambdabot>   <no location info>: parse error on input `='
11:56:07 <sohum> > fix (\f x -> if f x == 0 then 0 else 1) 0
11:56:08 <lambdabot>   * Exception: stack overflow
11:56:21 <lilac> kpreid: in languages with separate compilation, i guess you'd require the program to work without access to its source code
11:56:32 <Baughn> > let x = if x == 0 then 1 else 0 in x
11:56:35 <lambdabot>   mueval-core: Time limit exceeded
11:56:41 <monoidal> > error (error "A")
11:56:41 <lambdabot>   * Exception: A
11:56:44 <monoidal> > error $ error "A"
11:56:45 <lambdabot>   * Exception: * Exception: A
11:56:50 <monoidal> why there's a difference?
11:56:52 <sohum> > fix (\f x -> if x == 0 then 0 else f (x - 1)) 0
11:56:53 <lambdabot>   0
11:56:58 <sohum> > fix (\f x -> if x == 0 then 0 else f (x - 1)) 2
11:56:58 <lambdabot>   0
11:57:02 <kpreid> But consider a language which contains an expression which evaluates to the source code of the program.
11:57:14 <Baughn> monoidal: In the double error, the runtime encounters an exception while trying to print the outer exception. :P
11:57:18 <kpreid> That performs no IO, yet is not-really-a-quine.
11:57:41 <lilac> kpreid: is an empty python source file a quine?
11:57:50 <monoidal> Baughn: and in the first one? why this isn't lazy?
11:58:11 <Baughn> Oh. I see.
11:58:15 <monoidal> i always thought there's no difference between f x and f $ x
11:58:16 <sohum> > fix id
11:58:20 <lambdabot>   mueval-core: Time limit exceeded
11:58:20 <kpreid> lilac: *sigh*
11:58:30 <lilac> kpreid: what about a language with a 'quine' keyword which, if it appears anywhere in a source file, cuases the program to mean "print out my source code"?
11:58:32 <sohum> > fix (+1)
11:58:36 <lambdabot>   mueval-core: Time limit exceeded
11:58:41 <lilac> i think formalizing it is rather difficult :(
11:58:46 <kpreid> lilac: there is such a language, in fact: it's called "HQ9+"
11:59:04 <sohum> yea, fix is really not meant for one-arg fns
11:59:15 <monoidal> fix (1:)
11:59:25 <monoidal> > fix (1:)
11:59:25 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:59:35 <Baughn> monoidal: I'm not sure. It could be due to the strictness analyzer; $ is actually a function, so it's possible that, under those optimization settings, it can figure out that the use of error's parameter is strict in the paranthesized version but not the one that calls $
11:59:47 <Baughn> monoidal: Both behaviours are legal, anyhow
11:59:58 <sohum> :t fix (1:)
11:59:59 <lambdabot> forall t. (Num t) => [t]
12:00:00 <sohum> :t fix (1+)
12:00:01 <benmachine> lilac: both of those are boring quines.
12:00:01 <lambdabot> forall t. (Num t) => t
12:00:17 <lilac> kpreid: hah! i'd be nice if HQ9+ could be extended with similar esoterica until it was turing-complete :)
12:00:19 <monoidal> >  error (error (error "A"))
12:00:20 <lambdabot>   * Exception: A
12:00:25 <monoidal> >  error $ error $ error "A"
12:00:26 <lambdabot>   * Exception: * Exception: * Exception: A
12:00:41 <kpreid> > fix error
12:00:42 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:00:51 <Baughn> monoidal: The difference is obviously in evaluation order, at least
12:00:58 <monoidal> i agree
12:00:59 <Baughn> > error (error $ error "2")
12:01:00 <lambdabot>   * Exception: * Exception: 2
12:01:03 <lilac> monoidal: 'error' is strict, so GHC is free to evaluate the RHS and LHS in either order
12:01:04 <Orclev> ewww, side effects :P
12:01:24 <kpreid> In Haskell, if you fix an error, it's still broken.
12:01:35 <sohum> > fix $ mplus (Just 1)
12:01:36 <lambdabot>   Just 1
12:01:46 <Baughn> monoidal: In practice, GHC evaluates strict parameters before the function that uses them whenever possible. However, $ is non-strict, so unless it's inlined that can't happen.
12:01:52 <lilac> monoidal: i think the rule is 'you get one of the exceptions which the code could generate but it's undefined which one'
12:01:52 <sohum> > fix $ mplus Nothing
12:01:55 <lambdabot>   mueval-core: Time limit exceeded
12:01:57 <Baughn> monoidal: ..$ is, of course, usually inlined and optimized down to nothing at all
12:01:59 <sohum> right
12:02:05 <sohum> that makes sense
12:02:27 <monoidal> where I could read about strict functions?
12:02:42 <ksf> > fix undefined
12:02:43 <lambdabot>   * Exception: Prelude.undefined
12:02:51 <Baughn> monoidal: http://haskell.org/haskellwiki/Lazy_vs._non-strict
12:02:53 <sohum> :d undefined
12:02:54 <monoidal> is it just f !x ?
12:02:58 <sohum> :t undefined
12:02:59 <lambdabot> forall a. a
12:03:00 <halcyon10> > map (fix (\f k -> if (even k) then (k `div` 2) else (3*k - 1))) [0..10]
12:03:01 <lambdabot>   [0,2,1,8,2,14,3,20,4,26,5]
12:03:12 <ksf> @hoolgle whnf
12:03:13 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
12:03:17 <ksf> ...look there
12:03:19 <monoidal> thanks
12:03:30 <ksf> and...
12:03:31 <lilac> monoidal: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
12:03:33 <ksf> @hooge seq
12:03:33 <lambdabot> Prelude seq :: a -> b -> b
12:03:33 <lambdabot> Data.Sequence data Seq a
12:03:33 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
12:03:42 <ksf> ...which are closely related.
12:03:48 <sohum> halcyon10: you don't need fix there
12:03:58 <Baughn> monoidal: You might say that 'error x' is implicitly compiled at 'x `seq` error x', but it's really just standard eager evaluation
12:04:19 <Baughn> monoidal: ..also, that isn't always true, as you've seen
12:04:22 <sohum> > map (\f k -> if (even k) then (k `div` 2) else (3*k - 1)) [0..10]
12:04:23 <lambdabot>   [{-3->-10;-2->-1;-1->-4;0->0;1->2;2->1;3->8},{-3->-10;-2->-1;-1->-4;0->0;1-...
12:04:29 <sohum> > map (\k -> if (even k) then (k `div` 2) else (3*k - 1)) [0..10]
12:04:29 <lambdabot>   [0,2,1,8,2,14,3,20,4,26,5]
12:04:31 <lilac> that and "x `seq` error x" still doesn't necessarily produce the exception from x
12:04:40 <sohum> but, uh, whoa at that output
12:04:49 <ksf> > fix const "foo"
12:04:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
12:04:53 <ksf> > fix $ const "foo"
12:04:53 <lambdabot>   "foo"
12:04:55 <lilac> sohum: it's showing you the function :)
12:04:57 <Baughn> lilac: When 'x' is an error-producing thunk, it does. In practice, anyway.
12:05:04 <copumpkin> > (+1)
12:05:05 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
12:05:07 <halcyon10> sohum: i think i don't fix...
12:05:13 <Baughn> The standard is something else, but I was talking about GHC's implementation
12:05:17 <ksf> > lef f = fix $ const fix in f f
12:05:17 <lambdabot>   <no location info>: parse error on input `='
12:05:22 <halcyon10> sohum: i think i don't get fix
12:05:28 <monoidal> > error undefined
12:05:28 <lambdabot>   * Exception: * Exception: Prelude.undefined
12:05:30 <monoidal> > error $ undefined
12:05:31 <lambdabot>   * Exception: * Exception: Prelude.undefined
12:05:36 <lilac> Baughn: GHC's implementation is known to sometimes use the exception from the RHS of the seq
12:05:47 <sohum> halcyon10: technically what it does is returns the fixpoint of its argument
12:05:48 <lilac> Rarely, though, as i understand it
12:06:01 <Baughn> lilac: Really? Do you have references for that?
12:06:04 <Baughn> Sounds interesting
12:06:31 <lilac> i reproduced this last night (but i'm at work now so i don't have the code to hand)
12:06:49 <sohum> halcyon10: practically, recursive = fix (\f k -> <some defn including f>) is the same as recursive k = <same defn with s/f/recursive>
12:06:52 <halcyon10> sohum: how does it avoid to get stuck in an infinite loop?
12:07:03 <monoidal> lazy evaluation
12:07:06 <sohum> halcyon10: well, it doesn't always, right?
12:07:16 <halcyon10> ah, i see
12:07:24 <lilac> > tail (fix (1:)) `seq` error "fail"
12:07:25 <lambdabot>   * Exception: fail
12:07:28 <lilac> Baughn: ^^ there you go
12:07:30 <Baughn> lilac: How about with pseq?
12:07:38 <lilac> i think pseq is ok
12:07:44 <Baughn> > head $ tail (fix (1:))
12:07:45 <lambdabot>   1
12:07:57 <Baughn> lilac: Bad example, since the left-hand side dethunks without problems
12:07:58 <lilac> gah
12:08:08 <lilac> > last (fix (1:)) `seq` error "fail"
12:08:13 <lambdabot>   mueval: ExitFailure 1
12:08:14 * lilac searches harder
12:08:36 <Baughn> I know that there are cases where seq isn't obeyed, now that you mention it
12:09:05 <Baughn> ..for performance reasons. What was the reasoning, again...?
12:10:10 <sohum> > id
12:10:11 <lambdabot>   {()->()}
12:10:16 <sohum> hahahahha
12:10:17 <sohum> nice
12:10:27 <lilac> > id :: String -> String
12:10:28 <lambdabot>   ""->
12:10:28 <lambdabot>    ""
12:10:28 <lambdabot>  "a"->
12:10:28 <lambdabot>    "a"
12:10:28 <lambdabot>  "aa"->
12:10:30 <lambdabot> [6 @more lines]
12:10:46 <sohum> whoa
12:10:55 <sohum> something tells me that's not meant to be multiline
12:11:00 <Baughn> lilac: Wasn't it something like.. pseq forces the right-hand parameter to be lazy, even if the analyzer would like it to be strict, to ensure evaluation order?
12:11:13 * Baughn can't remember
12:11:13 <lilac> Baughn: something like that
12:11:15 <copumpkin> yeah
12:11:29 <lilac> Baughn: if the RHS is strict, it can get evaluated early
12:11:34 <Baughn> But if they're /both/ strict, what's stopping the compiler from just having the LHS parameter evaluated first anyway?
12:11:35 <sohum> > id :: Expr -> Expr
12:11:36 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
12:11:36 <lambdabot>    arising from...
12:11:44 <sohum> awwww
12:11:58 <sohum> > id :: (Int -> Int) -> (Int -> Int)
12:11:59 <lambdabot>   {-3->0;-2->-1;-1->-2;0->-3;1->-2;2->-1;3->0}->
12:11:59 <lambdabot>    {-3->0;-2->-1;-1->-2;0->-...
12:12:14 <sohum> impressive.
12:12:38 <lilac> Baughn: ok, i've got it. hpasting
12:13:10 <sohum> > show :: Int -> String
12:13:10 <lambdabot>   {-3->"-3";-2->"-2";-1->"-1";0->"0";1->"1";2->"2";3->"3"}
12:13:17 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9718#a9718
12:13:29 <halcyon10> is fix kind of related to the y combinator?
12:13:31 <Baughn> I suppose this is some quicktest magic?
12:13:43 <Baughn> *quickcheck
12:13:44 <lilac> Baughn: the strictness analyzer determines f is strict, so the exception happens in 'main' not in 'f'
12:14:14 <Baughn> Interesting
12:14:16 <halcyon10> > map (fix (\f k -> if k==0 then 1 else (f (k-1)))) [0..10]
12:14:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1]
12:14:21 <Baughn> ..I would've used [1..], though. :P
12:14:25 <sohum> halcyon10: the y combinator is the simplest definition of a function that calculates fix in the lambda calculus
12:14:49 <lilac> Baughn: people had been saying 'fix' here a lot and it just sprang to mind as a good exception :)
12:15:05 <Baughn> lilac: I suppose it'd work with error, too
12:15:08 <sohum> halcyon10: s/function that calculates fix/function that could be named fix/
12:15:19 <Baughn> Or unsafeDestroyWorld
12:15:36 <lilac> i wouldn't trust it with unsafeDestroyWorld
12:15:41 <halcyon10> sohum: ah, ok
12:15:43 <lilac> what if GHC specializes it for the argument
12:15:56 <Baughn> It's okay, you've told it not to inline
12:16:03 <sohum> > launchZeMissiles
12:16:03 <lambdabot>   Not in scope: `launchZeMissiles'
12:16:17 <Baughn> ..not not to specialize, granted
12:16:40 <Baughn> lilac: I'm pretty sure unsafeDestroyWorld wouldn't be executed at compile time. unsafePerformIO has special barriers against that.
12:16:50 <sohum> @def launchZeMissiles = putStrLn "missiles launched! Thank you for using Red Button Incorporated."
12:16:51 <lambdabot> Maybe you meant: bf do let
12:17:04 <sohum> @let launchZeMissiles = putStrLn "missiles launched! Thank you for using Red Button Incorporated."
12:17:05 <lambdabot>  Defined.
12:17:11 <sohum> :t launchZeMissiles
12:17:12 <lambdabot> IO ()
12:17:17 <sohum> hehehehehe
12:18:03 <Baughn> @let launchMyMissiles = unsafePerformIO $ destroyWorld
12:18:03 <lambdabot>  <local>:5:19: Not in scope: `unsafePerformIO'
12:18:03 <lambdabot>  
12:18:03 <lambdabot>  <local>:5:37: Not in scope:...
12:18:18 <jfoutz> this again.
12:18:19 <nyingen> @slap baughn
12:18:19 * lambdabot smashes a lamp on baughn's head
12:18:22 * jfoutz sighs
12:18:32 <jfoutz> destroyWorld is not unsafe!
12:18:43 <jfoutz> you just have to be sure you get all of it.
12:18:51 <sohum> hahahahahaha
12:20:00 <Orclev> does lambdabot have online docs for commands... something like a @help <command>?
12:20:18 <sinelaw> @slap his very own mirror image
12:20:19 * lambdabot orders her trained monkeys to punch his very own mirror image
12:20:24 <halcyon10> http://www.haskell.org/haskellwiki/Lambdabot
12:20:56 <sinelaw> in FRP, the +=> operator on events is really fmap, no?
12:21:36 <lilac> sinelaw: i have no idea how to google for that
12:22:08 <lilac> if it has the type of fmap and it follows the laws of fmap then it's fmap
12:22:08 <Makoryu> @hoogle (+=>)
12:22:08 <lambdabot> No results found
12:22:10 <Baughn> sinelaw: Typically, we use <$> for fmap..
12:22:19 <sohum> let y = \f -> (\x -> f (x x)) (\x -> f (x x)) in y (\f x -> if x == 0 then 1 else x * f (x - 1)) $ 10
12:23:06 <sohum> um
12:23:38 <sohum> oh, right
12:23:39 <sinelaw> lilac, http://www.conal.net/papers/icfp97/icfp97.ps
12:23:41 <sohum> > let y = \f -> (\x -> f (x x)) (\x -> f (x x)) in y (\f x -> if x == 0 then 1 else x * f (x - 1)) $ 10
12:23:42 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
12:23:55 <sohum> interesting
12:24:01 <sinelaw> page 4
12:24:06 <sinelaw> section 2.3
12:25:27 <Baughn> sinelaw: Well, no, fmap would be ==>
12:25:38 <sohum> > let y = \f -> f (y f) in y (\f x -> if x == 0 then 1 else x * f (x - 1)) $ 10
12:25:39 <lambdabot>   3628800
12:25:49 <Baughn> sinelaw: His later papers are clearer on the relation to existing type-classes. You should read them, I guess
12:25:59 <sohum> @where fix
12:25:59 <lambdabot> I know nothing about fix.
12:26:09 <sohum> @undef fix
12:26:27 <sohum> > fix
12:26:30 <lambdabot>   mueval-core: Time limit exceeded
12:26:58 <sohum> > fix :: (Int -> Int) -> (Int)
12:27:02 <lambdabot>   mueval-core: Time limit exceeded
12:27:06 <kowey> does gregory wright ever hang out here?
12:28:51 <sinelaw> @src fix
12:28:51 <lambdabot> fix f = let x = f x in x
12:29:09 <mux> the prettiest function definition in the prelude :)
12:29:27 <sinelaw> it's not in prelude, though
12:29:30 <mux> it's like the definition of a fixpoint operator
12:29:33 <mux> oh, my bad
12:29:47 <sinelaw> i still don't understand how it works (operationally)
12:30:13 <sinelaw> how does it "solve" that equation
12:31:13 <lilac> sinelaw: +=> is more like >>= than fmap. note that it's almost Event a -> (a -> Behaviour b) -> Event b
12:31:43 <sinelaw> i've forgotten what >>= is :)
12:31:47 <sinelaw> @type >>=
12:31:47 <lambdabot> parse error on input `>>='
12:31:50 <sinelaw> @type (>>=)
12:31:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:31:55 <sinelaw> ah
12:31:57 <tommd> monadic bind operation
12:32:06 <Makoryu> @undo do x <- foo; bar x
12:32:06 <lambdabot> foo >>= \ x -> bar x
12:32:07 <sohum> I don't like that definition of fix, tbh
12:32:14 <sohum> I like fix f = f (fix f) better
12:32:26 <lilac> sohum: that's not operatioanlly equivalent
12:32:49 <sohum> lilac: I know. but it's still a fixpoint
12:32:55 <sohum> combinator
12:32:57 <tommd> ... but it won't work
12:33:06 <lilac> it's not a 'good' one though ;-)
12:33:14 <ksf> >logBase 2 (maxBound :: Char)
12:33:15 <tommd> > let fix' f = f (fix' f)
12:33:16 <lambdabot>   not an expression: `let fix' f = f (fix' f)'
12:33:18 <sinelaw> but how does the other one DO work?
12:33:25 <tommd> > let fix' f = f (fix' f) in fix' error
12:33:25 <ksf> > logBase 2 (maxBound :: Char)
12:33:26 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:33:26 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Char)
12:33:26 <lambdabot>    arising from a use o...
12:33:34 <sinelaw> excuse my grammar :)
12:33:43 <ksf> > logBase 2 ((maxBound :: Char)::Float)
12:33:43 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
12:33:44 <lambdabot>         against inferred typ...
12:33:54 <ksf> > logBase 2 . fromIntegral $ (maxBound :: Char)
12:33:54 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
12:33:55 <lambdabot>    arising from a use of...
12:33:59 <lilac> sinelaw: it says, allocate memory for a value, call it 'x'. now, produce a thunk which applies f to x. finally, write that thunk to x, and return it
12:34:15 <ksf> > logBase 2 (maxbound :: Char)
12:34:16 <lambdabot>   Not in scope: `maxbound'
12:34:18 <sohum> lilac: "good" one?
12:34:20 <ksf> :t maxBound
12:34:21 <lambdabot> forall a. (Bounded a) => a
12:34:36 <lilac> sohum: where "good" means "uses constant space where possible" :)
12:34:38 <ksf> >  (maxBound :: Char)
12:34:39 <lambdabot>   '\1114111'
12:35:01 <ksf> > logBase 2 1114111
12:35:01 <lambdabot>   20.087461546321563
12:35:23 <lilac> sinelaw: the key is, producing the (f x) thunk uses only the 'box' containing x, and not x itself (which we've not defined yet)
12:35:29 <ksf> is that the whole unicode range?
12:35:32 <ksf> seems a bit small
12:35:35 <sinelaw> > fix (\f n -> if n<1 then 1 else n*(f (n-1)))
12:35:36 <lambdabot>   {-3->1;-2->1;-1->1;0->1;1->1;2->2;3->6}
12:36:12 <lilac> ksf: it'll do until we discover a lot more civilizations, or discover (or invent via scifi) lots of alien races :)
12:36:31 <idnar> @type fix (\f n -> if n<1 then 1 else n*(f (n-1)))
12:36:32 <lambdabot> forall a. (Num a, Ord a) => a -> a
12:36:36 <idnar> > (+1)
12:36:36 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
12:36:40 <idnar> ooh, I see
12:36:44 <ksf> do we have a tengwar range by now?
12:36:52 <sinelaw> idnar, factorial
12:37:05 <idnar> sinelaw: yeah, it's the Show instance on functions that threw me
12:37:13 <sinelaw> yeah, confusing
12:38:04 <lilac> ksf: it's still at the proposal stage apparently: http://std.dkuug.dk/JTC1/SC2/wg2/docs/n1641/n1641.htm
12:38:22 * sohum <3 unicode
12:40:12 <lilac> > let f b = False in f
12:40:13 <lambdabot>   {()->False}
12:40:23 <lilac> > let f b = not b in f
12:40:24 <lambdabot>   {True->False;False->True}
12:41:56 <lilac> > let f b = not . read . takeWhile (/=';') . drop 5 $ show f in f ()
12:41:58 <lambdabot>   * Exception: stack overflow
12:42:07 <lilac> yay for the halting problem
12:42:42 <jfoutz> it's not a problem. it halted :p
12:43:34 <sinelaw> > fix (\f x. (f x))
12:43:35 <lambdabot>   <no location info>: parse error on input `.'
12:43:38 <sinelaw> > fix (\f x -> (f x))
12:43:42 <lambdabot>   mueval-core: Time limit exceeded
12:44:04 <sinelaw> > fix (\f -> (fix f))
12:44:05 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
12:45:17 <lilac> > fix (\f -> const (fix f))
12:45:20 <lambdabot>   mueval-core: Time limit exceeded
12:45:50 <sohum> read "{()->False}" :: a -> Bool
12:45:54 <sohum> > read "{()->False}" :: a -> Bool
12:45:55 <lambdabot>   Could not deduce (GHC.Read.Read (a -> GHC.Bool.Bool))
12:45:55 <lambdabot>    from the context (...
12:46:15 <jfoutz> @type fix (\f -> const (fix f))
12:46:16 <lambdabot> forall a. a -> a
12:46:16 <benmachine> const . fix = id
12:46:26 <sinelaw> Baughn, if I understand correctly, an fmap equivalent would be something like +=> that returns Event_(alpha)? or is there another difference
12:46:34 <benmachine> > succ
12:46:34 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
12:46:42 <benmachine> heh
12:46:52 <sohum> > succ :: Int -> Int
12:46:52 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
12:47:02 <Baughn> sinelaw: The type of fmap is f a -> f b
12:47:14 <benmachine> > map (+1)
12:47:15 <lambdabot>   []->
12:47:15 <lambdabot>    []
12:47:15 <lambdabot>  [-2]->
12:47:16 <Baughn> sinelaw: ..well, rather, (a -> b) -> f a -> f b
12:47:17 <lambdabot>    [-1]
12:47:18 <sinelaw> @type fmap
12:47:19 <lambdabot>  [-2,-1]->
12:47:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:47:23 <lambdabot> [4 @more lines]
12:47:41 <benmachine> > fmap f
12:47:42 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
12:47:42 <lambdabot>                    GHC.Show...
12:47:45 <Baughn> sinelaw: This means that the /only/ information the function you pass is allowed to see is the "a", i.e. the event value - not the time
12:47:54 <Baughn> sinelaw: Further, it must work for any type b
12:47:59 <benmachine> > fmap f :: Maybe Expr -> Maybe Expr
12:48:00 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
12:48:00 <lambdabot>    arising from...
12:48:03 <benmachine> aw
12:48:16 <sohum> yea, it's not defined on Exprs
12:48:21 <davidL> benmachine: fix . const
12:48:32 <sohum> :t fix . const
12:48:35 <lambdabot> forall a. a -> a
12:48:49 <sinelaw> hmm. so i don't see why +=> is different from fmap (except for argument order)
12:48:53 <benmachine> davidL: oh, yeah
12:49:08 <Baughn> sinelaw: Well, the +=> function takes extra information, right? The type?
12:49:09 <sinelaw> the 'f' doesn't return an Event, it returns a value which is used to construct an Event
12:49:11 <Baughn> sinelaw: *time
12:49:42 <sinelaw> the time is part of the "content" of an event, however you call that in a Functor
12:49:57 <Baughn> You can't do that
12:50:35 <Baughn> fmap has to support /any/ return type; it is not allowed to place additional constraints such as "must be a (time,value) pair"
12:51:03 <Baughn> Well, though I suppose in principle you could constrain the Functor instance to something that would allow that..
12:51:04 <sinelaw> i see the difference now - f returns only the 'x' part, not the tuple (t,x)
12:51:14 <Baughn> Nevertheless, ==> is the closest match, not +=>
12:51:26 <sinelaw> but it takes both the time and x
12:51:31 <sinelaw> ok thanks
12:51:40 <sinelaw> right, ==> makes more sense to be an fmap
12:52:03 <Baughn> sinelaw: http://conal.net/papers/push-pull-frp/ <-- I suggest you read this instead; it's newer
12:52:11 <Baughn> (And covers the type-classes in detail)
12:52:27 <sinelaw> Baughn, but is it introductory enough?
12:52:45 <Baughn> Well.. there still are no functional implementations of FRP. :P
12:54:02 <sinelaw> yeah... i guess i'll try to read both papers, and probably others. i'm interested in FRP and managed to hijack my senior year's project to work on it
12:54:25 <sinelaw> problem is, noone in my univ. knows anything about it
12:54:33 <Baughn> sinelaw: I've got a half-finished FRP core around, if you want to take a look
12:54:34 <sohum> :t (,)
12:54:35 <lambdabot> forall a b. a -> b -> (a, b)
12:54:49 <sinelaw> Baughn, in Haskell I presume?
12:54:51 <Baughn> sinelaw: I *think* it'll work better than conal's. Problem is, it's woefully incomplete in general; the complex stuff is done, though
12:54:55 <Baughn> Of course
12:55:30 <sinelaw> of course i'm interested - what's missing? btw it being in Haskell means that performance / real-timeness is still an issue, no?
12:56:13 <Baughn> Depends on which issues you are referring to.
12:56:38 <Baughn> I think it'd be faster than concal's, on the principle that it isn"t forking a hundred threads for every operation, but it's still not what I'd describe as /fast/
12:57:33 <sinelaw> it's not just the issue of speed...I understand there's a problem with "consistency", or whatever you call that property of a real-time system
12:57:36 <Baughn> sinelaw: http://github.com/Baughn/Reactant
12:58:08 <Baughn> sinelaw: Timeliness, maybe? The idea that every event occurence should be fully defined and usable at the time that's attached to said event
12:58:14 <Baughn> *said occurence
12:58:38 <Baughn> sinelaw: I've taken great pains to make sure that is always the case.
12:58:58 <Baughn> sinelaw: http://github.com/Baughn/Reactant/blob/master/FRP/Reactant/Time.hs <-- This is the *interesting* stuff, anyway
12:59:01 <Baughn> That file
12:59:36 <Baughn> Using that, you should be able to get around the most annoying bit of implementing FRP - comparing time values. ;)
12:59:52 <sinelaw> how does that work with haskell's (or ghc's?) hard-to-predict memory management? i'm a little new on this so it's all from rumors :)
13:00:15 <Baughn> It doesn't depend on finalizers, if that's what you mean
13:00:20 <sinelaw> Baughn, thanks, i'll take a look at that :)
13:01:31 <Wooga> how can i implement random strings generator, where strings ara chars in specified range? i tried to use getStdRandom (randomR ('a', 'z')), but how do i place this in list? also, why getChar (getStdRandom (randomR ('a', 'z'))) rising an error?
13:01:46 <Wooga> s/ara/are/
13:02:10 <Baughn> sinelaw: Try not to be depressed by the extensive use of unsafePerformIO. I renamed it to something cuddly.
13:02:32 <sinelaw> Baughn, i don't know enough yet to even be bothered by it :)
13:03:05 <Baughn> sinelaw: Hm. Let's say, then: This implementation is tightly dependent on the exact GHC evaluation model. I would not expect it to work on other haskell implementations.
13:03:13 <hydo> Three more days until HacPDX! Squeee!
13:03:14 <tommd> > warmFuzzyRefTransparentFunctionConverter = unsafePerformIO
13:03:15 <lambdabot>   <no location info>: parse error on input `='
13:03:16 <Baughn> sinelaw: However, there is no actual way around this.
13:03:28 <tommd> hydo: yes!  It will be great
13:03:47 <Badger> @let warmFuzzyRefTransparentFunctionConverter = unsafePerformIO
13:03:48 <lambdabot>  <local>:1:43: Not in scope: `unsafePerformIO'
13:03:49 <sinelaw> ok, still doesn't bother me :) maybe i need to learn more about haskell itself before tackling FRP
13:03:53 <Badger> :'(
13:03:59 <Baughn> sinelaw: In particular, I'm using unsafePerformIO in its "run code when a thunk is evaluated" mode.
13:04:46 <tommd> Hydo: What are your planned project(s)?
13:04:49 <Baughn> Aand.. I just spotted an error. *groan*
13:07:21 <leimy_> I need to open a socket, bind it to a CAN interface, and then send raw data at it ;-)
13:07:39 <sinelaw> Baughn, makes sense that to implement FRP you need to somehow force some behavior into the haskell implementation
13:07:41 <leimy_> Not sure how to do that in Haskell... but I'd love to use Data.Binary and the associated network functions.
13:08:14 <leimy_> Alternatively I could put "raw" stuff through it via C and FFI, and do all the cooking in Haskell
13:08:22 <tommd> leimy_: I was just getting back to the question of a good network API.
13:08:29 <leimy_> heh
13:08:40 <tommd> leimy_: Let me know if you come up with a some fundamental thing that is currently missing that would really help.
13:08:41 <leimy_> In order to do what I need to do here, I need ioctl :-(
13:08:43 <Botje> "cooking in haskell" sounds like a great name for a paper.
13:08:51 <tommd> humm, there you have it.
13:08:56 * ksf thinks proper fast and speedy frp is going to need runtime support, anyway.
13:09:33 <Baughn> sinelaw: I've got my own plans for reactant, assuming I ever get around to it, but feel free to use the code. (Well, it /is/ GPL'd..)
13:09:53 <leimy_> so feel constrained to use the code :-)
13:10:11 <Baughn> Feel constrained not to misuse the code. ;)
13:10:32 <leimy_> you can use the code in any way you want except the disallowed ways that are enumerated by the GPL :-)
13:10:35 <sinelaw> Baughn, thanks :) I don't know if i'll actually *use* it, but i may try to understand parts of it. reading haskell is still a major effort for me
13:10:56 <Baughn> sinelaw: Again, Time.hs is the only part that's actually useful right now. Or complete.
13:11:56 <sinelaw> ok. tomorrow my son is getting an adenoidectomy...gotta go to sleep :\
13:13:10 <king3> Enter text here...hey
13:13:25 <xlq> I wrote a program that calculates something. It requires no input, it calculates the result and prints it. The program was completely functional (except for 'main'), so the compiler (ghc) could have evaluated the whole program at compile-time. Are there any plans to implement something like that in ghc?
13:13:27 <hackagebot> HaskellForMaths 0.1.8 - Combinatorics, group theory, commutative algebra, non-commutative algebra (DavidAmos)
13:13:47 <leimy_> Ugh... I specifically need AF_CAN
13:13:50 <leimy_> not part of Network.Socket :-)
13:14:43 <king3> hey guys im new to python used to program ib basic back on c64 and 128 :P but im needing some help with python i need it for my blender and gimp projects
13:15:02 <xlq> king3: what part of "haskell" and "python" looks the same?
13:15:04 <Makoryu> king3: EXPERT WRONGCHANNELING
13:15:13 <Makoryu> :D
13:15:26 <leimy_> king3: perhaps you want #python
13:15:28 <king3> lol dang how did i get in a haskell room oops sorry
13:15:43 <leimy_> because our badassity magnetized you
13:15:49 <leimy_> or something
13:16:25 <sinelaw> badasissity
13:16:31 <king3> well i would learn it the only reason im going with python is im runing ubuntu and basically the whole enviroment thrives off python
13:16:52 <Makoryu> king3: Hmmm. You know, you're right. There should be a distro that thrives on Haskell
13:17:06 <king3> i agree
13:17:11 <Makoryu> ITT: We take "Haskell platform" a bit literally
13:17:16 <aavogt> nixos, sort of?
13:17:40 <mmorrow> xlq: you can do exactly that with template-haskell
13:17:56 <king3> haskall is ool?
13:17:56 <leimy_> nixos is close
13:18:07 <leimy_> king3: nope :-)
13:18:53 <monadic_kid> is greencard any better than c2hs?
13:19:22 <aavogt> leimy_: yeah, except the syntax for derivations is c-style
13:19:29 <hackagebot> to-string-class 0.1.2 - Converting string-like types to Strings. (BasVanDijk)
13:19:33 <leimy_> aavogt: yep
13:19:40 <mmorrow> xlq: you use template-haskell to build haskell syntax with an abstract data type(s) at compile-time, so you can generate code, pre-evaluate things, include static data in your code, get info about types/names, etc
13:19:43 <leimy_> Well it looks like I'm stuck in FFI-land
13:20:18 <lpsmith> woah, there's a name I haven't heard in ages.... I thought greencard had been abandoned but then I see it's had a new release recently
13:20:37 <xlq> mmorrow: yeah, but presumably you'd have to use a different syntax
13:21:24 <aavogt> xlq: not with quasiquotes
13:21:39 <mmorrow> , foldr (\g f -> [|$g . $f|]) [|id|] (replicate 4 [|show|])
13:21:40 <lunabot>  InfixE (Just (VarE show)) (VarE .) (Just (InfixE (Just (VarE show)) (VarE...
13:21:47 <mmorrow> , ppDoc <$> foldr (\g f -> [|$g . $f|]) [|id|] (replicate 4 [|show|])
13:21:48 <lunabot>  show . (show . (show . (show . id)))
13:21:58 <mmorrow> , $(foldr (\g f -> [|$g . $f|]) [|id|] (replicate 4 [|show|])) (4::Int)
13:21:59 <tommd> Having just learned to use c2hs, I find it quite nice.  Just a couple limitations that no one besides me care about.
13:22:00 <lunabot>  "\"\\\"\\\\\\\"4\\\\\\\"\\\"\""
13:22:01 <leimy_> lpsmith: greencard generates FFI bindings?
13:22:08 <lpsmith> yep
13:22:31 <mmorrow> , $(tupE (fmap lift [0..15::Int]))
13:22:32 <lunabot>  luna: No instance for (GHC.Show.Show
13:22:46 <monadic_kid> well c2hs is okay but it has some issues that aren't well documentated, i've had a big learning curve because of those cavets but I've finally written some test bindings for d3d with the latest directx sdk but I'd like to know if greencard is more automated than c2hs
13:22:48 <mmorrow> um
13:22:48 <nyingen> what is this crazy moon language
13:22:54 <nyingen> oh, template haskell
13:23:21 <mmorrow> , tupE (fmap lift [0..15::Int])
13:23:22 <lunabot>  TupE [LitE (IntegerL 0),LitE (IntegerL 1),LitE (IntegerL 2),LitE (Integer...
13:23:33 <mmorrow> , pDoc <$> tupE (fmap lift [0..15::Int])
13:23:34 <lunabot>  luna: Not in scope: `pDoc'
13:23:37 <mmorrow> , ppDoc <$> tupE (fmap lift [0..15::Int])
13:23:39 <lunabot>  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
13:23:47 <lpsmith> monadic_kid:  honestly,  I've done some FFI, but not enough to really know that much :-)
13:23:48 <mmorrow> i dunno what type it's thinking that is
13:23:59 <mmorrow> oh
13:24:03 <lpsmith> maybe somebody else has an opinion though
13:24:13 <mmorrow> tuples > 14 or something don't have Show instances
13:24:20 <mmorrow> , ppDoc <$> tupE (fmap lift [0..2::Int])
13:24:21 <lunabot>  (0, 1, 2)
13:24:23 <mmorrow> , ppDoc <$> tupE (fmap lift [0..12::Int])
13:24:24 <lunabot>  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
13:24:31 <hackagebot> to-string-instances 0.2 - Instances for the ToString class. (BasVanDijk)
13:24:59 <monadic_kid> wanna get some directx 11 bindings going eventually
13:25:16 <benmachine> , :t tupE
13:25:17 <lunabot>  luna: Couldn't match expected type `([Language.Haskell.TH.Lib.ExpQ]
13:25:39 <aavogt> , [$ty| tupE |]
13:25:42 <lunabot>  [] ExpQ -> ExpQ
13:26:02 <mmorrow> xlq: so you can put code in [|...here...|] to quote it, you can put quoted code (you can also build AST pieces with the dataype itself as well) in $(...here...)
13:26:26 <mmorrow> it vaguely similar to bash, but bash lets you splice pretty much anywhere
13:26:36 <mmorrow> since it's only splicing strings into strings
13:26:47 <mmorrow> whereas TH is splicing code into code
13:26:49 <xlq> mmorrow: I see
13:27:24 <mmorrow> the most useful/powerful part is how you can splice $(...) inside [|...|]'s
13:27:59 <mmorrow> , $(let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go [|()|])
13:28:01 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
13:28:10 <mmorrow> , $(let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|()|])
13:28:11 <lunabot>  "\"\\\"\\\\\\\"()\\\\\\\"\\\"\""
13:28:18 <mmorrow> , ppDoc <$> let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|()|]
13:28:20 <lunabot>  show (show (show (show ())))
13:28:26 <mmorrow> , let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|()|]
13:28:27 <lunabot>  AppE (VarE show) (AppE (VarE show) (AppE (VarE show) (AppE (VarE show) (C...
13:28:53 <mmorrow> so you can view it at any of those three levels depending on what fits the situation
13:29:33 <mmorrow> also, you can keep quoting forever it you wanted too
13:29:40 <mmorrow> , lift (let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|()|])
13:29:41 <lunabot>  luna: No instance for (Language.Haskell.TH.Syntax.Lift
13:29:49 <mmorrow> , lift =<< (let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|()|])
13:29:50 <lunabot>  AppE (AppE (ConE AppE) (AppE (ConE VarE) (AppE (AppE (ConE Name) (AppE (V...
13:29:54 <mmorrow> , lift =<< lift =<< (let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|()|])
13:29:56 <lunabot>  AppE (AppE (ConE AppE) (AppE (AppE (ConE AppE) (AppE (ConE ConE) (AppE (A...
13:30:36 <mmorrow> but 90% of the time you're at those lowest 3 levels of quote-ness
13:30:50 <mmorrow> (and 99% of the time at those lowest 4)
13:32:33 <hackagebot> dstring 0.3.0.1 - Difference strings. (BasVanDijk)
13:37:25 <leimy_> Hmmm never tried greencard.
13:40:47 <Berengal> Writing a parser is easy when you've got a BNF, until you happen upon a random "prodFoo | /* start of line */" rule...
13:41:06 <Berengal> What the hell kind of format spec is that?
13:41:10 <Berengal> formal*
13:41:32 <saml> it's a comment
13:41:44 <saml> either it's prodFoo or matches /^/
13:41:47 <Berengal> Yes, but notice the "or" in front?
13:42:31 <Berengal> I can't match /^/, because at that point I've already passed it...
13:43:36 <hackagebot> repr 0.2 - Render numeric expressions to their textual representation. (BasVanDijk)
13:46:38 <byorgey> man, Bas has been on an uploading spree =)
13:50:09 <byorgey> are there any Hackage packages that provide a pure Haskell implementation of solution of linear systems?
13:50:25 <dancor> wait how is repr different from show
13:50:54 <lpsmith> byorgey:  what, like gaussian elimination?
13:50:58 <byorgey> I know about hmatrix, but it seems like a heavy dependency just to do some basic linear algebra
13:51:02 <byorgey> lpsmith: yes, exactly
13:51:09 <dolio> dancor: It's more like the reflection stuff in lambdabot.
13:51:16 <dolio> > a + 7 + 64
13:51:17 <lambdabot>   a + 7 + 64
13:51:31 <dancor> ooh
13:51:39 <dancor> > 1 + 2 + a
13:51:40 <lambdabot>   1 + 2 + a
13:51:49 <dancor> why doesn't it say 3 + a
13:51:54 <dancor> what's going on here anyway ;)
13:52:10 <dancor> > (1 + 2) + a
13:52:11 <lambdabot>   1 + 2 + a
13:52:11 <Twey> dancor: Because that's not as useful
13:52:18 <Twey> Exprs don't reduce
13:52:23 <dancor> ok
13:52:26 <Twey> (if they did, you wouldn't see all the arguments)
13:52:39 <byorgey> ah, hmm, there is Vec
13:52:40 <benmachine> isn't there a function for reducing them
13:52:47 <Twey> It's the SimpleReflect package
13:53:05 <benmachine> > reduce (1 + 2 + a)
13:53:06 <lambdabot>   3 + a
13:53:09 <benmachine> \o/
13:53:17 <Twey> It's basically just a list of symbols a‚Ä¶z and some clever functions for building expressions out of them and showing them
13:53:25 <Twey> Yeah ‚ò∫
13:55:36 <camio> > reduce (1 / 0)
13:55:37 <lambdabot>   Infinity
13:55:59 <camio> > reduce (1 / 0) * a
13:56:00 <lambdabot>   Infinity * a
13:56:09 <leimy_> > reduce (1 + a + 2 + 3 + b + 4 + 4 + 4 + 4 / z)
13:56:10 <lambdabot>   1 + a + 2 + 3 + b + 4 + 4 + 4 + 4 / z
13:56:10 <Twey> > reduce (a * a)
13:56:11 <lambdabot>   a * a
13:56:22 <Twey> Aw, it's not smart enough to produce a ^ 2.  ‚ò∫
13:56:26 <camio> :/
13:56:49 <Twey> I guess it reduces from the left, camio.
13:57:11 <benmachine> each reduce call only reduces once, according to the doc
13:57:16 <benmachine> > reduce a + 2 + 3
13:57:17 <lambdabot>   a + 2 + 3
13:57:18 <benmachine> er
13:57:22 <benmachine> > reduce (a + 2 + 3)
13:57:22 <lambdabot>   a + 2 + 3
13:57:27 <benmachine> ah
13:58:26 <pasc1> > reduction (4+3+a)
13:58:31 <lambdabot>   Not in scope: `reduction'
13:58:46 <Berengal> > iterate reduce (foldr (+) 0 [1..])
13:58:47 <lambdabot>   [1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + ...
13:58:56 <Berengal> Nice
13:59:20 <Berengal> Doesn't look like iterate was neccessary...
13:59:34 <Berengal> > reduce (foldr (+) 0 [1..])
13:59:36 <lambdabot>   * Exception: stack overflow
13:59:51 <Berengal> .. perhaps it was
13:59:54 <copumpkin> > reduce (foldr (+) 0 [1..10])
13:59:54 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + 10))))))))
14:00:04 <copumpkin> > (reduce . reduce) (foldr (+) 0 [1..10])
14:00:05 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + 19)))))))
14:00:24 <copumpkin> > iterate reduce $ foldr (+) 0 [1..5]
14:00:25 <lambdabot>   [1 + (2 + (3 + (4 + (5 + 0)))),1 + (2 + (3 + (4 + 5))),1 + (2 + (3 + 9)),1 ...
14:02:55 <benmachine> that is odd
14:03:31 <benmachine> oh wait
14:03:36 <camio> >iterate reduce $ foldl (+) 0 [1..5]
14:03:40 <benmachine> > expr $ foldr (+) 0 [1..]
14:03:41 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (...
14:03:43 <camio> > iterate reduce $ foldl (+) 0 [1..5]
14:03:43 <lambdabot>   [0 + 1 + 2 + 3 + 4 + 5,1 + 2 + 3 + 4 + 5,3 + 3 + 4 + 5,6 + 4 + 5,10 + 5,15,...
14:03:55 <benmachine> the first item in the iterate doesn't apply the function
14:06:15 <mrsolo> does ghc provide automatic parallelism?
14:06:45 <c_wraith> no.  You need to give it some hints.
14:07:51 <copumpkin> mrsolo: with DPH, you sort of get that
14:08:05 <mrsolo> DPH?
14:08:06 <copumpkin> but you need to write your code using a different prelude and different types, and it's still very experimental
14:08:09 <copumpkin> data parallel haskell
14:08:18 <mrsolo> so still need to do `par` and such
14:08:27 <copumpkin> nope
14:08:48 <copumpkin> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
14:09:05 <copumpkin> you get stuff like
14:09:05 <copumpkin> dotp_double :: [:Double:] -> [:Double:] -> Double
14:09:06 <copumpkin> dotp_double xs ys = sumP [:x * y | x <- xs | y <- ys:]
14:09:20 <copumpkin> where [::] is the type of a "parallel array"
14:09:34 <copumpkin> but that gets parallelized automatically
14:10:24 <mrsolo> experimental hmm
14:10:30 <copumpkin> it's not just for flat structures by the way
14:10:41 <mrsolo> i assume it will replace current prelude once it has stablized?
14:11:05 <copumpkin> mrsolo: depends on how well it ends up working, I guess :) but the basic primitive is an array, and not a list
14:11:11 <copumpkin> so you'll probably still have to ask for it
14:11:38 <Peaker> copumpkin, is it | between x and y there?  Cause parallel list comps do zip in that case
14:11:51 <copumpkin> yeah, that's what you want in the dot product
14:11:58 <mrsolo> hmm
14:12:03 <mrsolo> amd is going six cores next year
14:12:15 <mrsolo> parallel programming is sorta important now
14:12:20 <copumpkin> yep :)
14:12:23 <saml> > let f n | n < 0 = 0 | otherwise = n in f  (-1)
14:12:23 <Botje> screw that. gilette is going five blades :)
14:12:24 <lambdabot>   0
14:12:32 <saml> what's the name of such f ?
14:12:42 <Peaker> Botje, following the onion
14:12:43 <saml> abs or something?
14:12:48 <Botje> it's commonly called "clamp"
14:13:00 <Peaker> saml, (max 0)
14:13:04 <saml> Botje, thanks.. i thought it started with 'a'
14:13:10 <Peaker> @type clamp
14:13:11 <lambdabot> Not in scope: `clamp'
14:13:31 <Botje> Peaker: http://www.businessweek.com/the_thread/brandnewday/archives/2005/09/gillette_raise.html
14:13:42 <Botje> it's real! the onion has actually published a true article! :)
14:14:11 <copumpkin> many of their recent articles have been too close for comfort ;)
14:14:36 <Botje> :)
14:16:28 <tinLoaf> hi guys
14:16:41 <tinLoaf> i'm trying to completely understand the differences between monads and functors
14:16:55 <tinLoaf> am i right that i can make a monad out of every functor with this line:
14:16:59 <tinLoaf> fmap f x = x >>= (\a -> pure (f a))
14:17:11 <tinLoaf> err, a functor out of every monad
14:17:33 <tinLoaf> and of course "pure = return"
14:18:12 <camio> tinLoaf: In order for something to be a monad, it must also be a Functor.
14:18:20 <Peaker> tinLoaf, yeah
14:18:28 <Peaker> tinLoaf, That's an applicative functor tho
14:18:32 <Peaker> tinLoaf, (it has pure)
14:18:40 <tinLoaf> Peaker: yeah, sure
14:18:46 <Peaker> @pl fmap f x = x >>= (\a -> pure (f a))
14:18:46 <lambdabot> fmap = (=<<) . (pure .)
14:19:04 <Peaker> @pl (\a -> pure (f a))
14:19:04 <lambdabot> pure . f
14:19:14 <tinLoaf> uhm, ok, seems like you can fancy-up my syntax ;)
14:19:38 <Peaker> fmap f x = return . f =<< x
14:19:48 <Peaker> tinLoaf, that's readable imo :)
14:20:02 <Peaker> bind x into f-and-then-return
14:21:03 <tinLoaf> so say i have a monad which i can get the "contents of"
14:21:07 <tinLoaf> like Maybe
14:21:27 <tinLoaf> in that case i would also be able to transform that monad into a functor, right?
14:21:45 <Heffalump> any monad is a functor anyway
14:23:09 <tinLoaf> err, the other way round, sorry
14:23:31 <tinLoaf> >>= m f = fmap (\a -> getcontentofmonad (f a)) m
14:24:02 <tinLoaf> with "getcontentofmonad" being a function that somehow magically retrieves the "content" of that monad - pattern matching for Maybe e.g.
14:24:48 <DrSyzygy> tinLoaf: So what's the content of a list? :-)
14:25:13 <DrSyzygy> Or am I perceiving everything the wrong way around now?
14:25:15 <tinLoaf> DrSyzygy: i'm only talking about monads which have a possibilty to get their "contents"
14:25:22 <tinLoaf> like Maybe
14:25:32 <wdonnelly> tinLoaf: you can't get maybe's contents all the time
14:25:39 <tinLoaf> i.e. i need a functino getcontent :: M a -> a
14:25:42 <DrSyzygy> tinLoaf: What do you do with Nothing?
14:25:45 <wdonnelly> what happens when you call 'getContents' on "Nothing"?
14:25:52 <tinLoaf> that's true of course..
14:26:16 <xoclipse> does anyone know any solutions for getting cabal/zlib to work on snow leopard?
14:26:19 <DrSyzygy> tinLoaf: You are not all that often able to produce a counit for monads.
14:26:27 <xoclipse> i've updated my /usr/bin/ghc with the 32-bit flags...but still no go
14:26:49 <tinLoaf> DrSyzygy: "counit"?
14:27:15 <DrSyzygy> tinLoaf: The function 'return' is called a 'unit' sometimes. And the dual, the comonad function C a -> a, is thus called a counit.
14:27:34 <DrSyzygy> Hmmm. I wonder whether being simultaneously a monad and a comonad is an interesting property for a functor.
14:27:38 <tinLoaf> ah, ok, got that, my "getcontent" ;)
14:27:45 <DrSyzygy> Kinda like being a Hopf object of some sort...
14:27:56 <tinLoaf> so a "comonad" is a monad that has a counit?
14:28:01 <DrSyzygy> Nope.
14:28:17 <benmachine> it also has a something else
14:28:18 <DrSyzygy> A comonad is something that has a counit C a -> a, and a cobind C a -> C C a
14:28:30 <benmachine> that's cojoin isn't it?
14:28:30 <DrSyzygy> Obeying the "reverse"s of the monad laws.
14:28:33 <byorgey> and it doesn't have to be a monad.
14:28:42 * DrSyzygy can never remember which is which of bind and join.
14:28:52 <Peaker> tinLoaf, to form a monad from a functor, you just need "pure" and "join"
14:28:55 <tinLoaf> i think i should get the full concept behind monads before trying to cope with comonads ..
14:29:04 <DrSyzygy> Yes, yes you should.
14:29:08 <benmachine> join and (>>=) can be defined in terms of each other
14:29:11 <Peaker> tinLoaf, not (m a -> a) but (m (m a) -> m a)
14:29:14 * DrSyzygy still doesn't get comonads other than in the highest formality.
14:29:24 <byorgey> DrSyzygy: join 'joins' the two occurrences of M into one:  join :: M M a -> M a
14:29:26 <Peaker> tinLoaf, that way you can implement it for Nothing, too
14:29:32 <byorgey> that's how I remember which is which
14:29:47 <DrSyzygy> byorgey: Mmmmmhmmmm. Why can't people just use 'compose' and 'Kleisli arrow' like normal people do? ;-)
14:29:53 <byorgey> hehehe
14:30:08 <DrSyzygy> Or 'eta' and 'Kleisli arrow' for that matter...
14:30:27 <tinLoaf> Peaker: true, but in that case that function (m (m a) -> m a) needs to use a counit too?
14:30:45 <Peaker> tinLoaf, "counit"?
14:30:47 <benmachine> tinLoaf: no
14:30:52 <Peaker> oh
14:30:55 <DrSyzygy> tinLoaf: No, the m m a -> m a function is not a counit, it is the composition operation of the functor m.
14:30:56 <Peaker> tinLoaf, no need
14:31:12 <DrSyzygy> Peaker: I introduced counit to describe some C a -> a type of function.
14:31:21 <benmachine> join would be easy to implement if you had fmap and a counit
14:31:26 * DrSyzygy could introduce 'augmentation' to mean the same thing, just to algebrize even more.
14:31:34 <benmachine> but it's usually implemented without one
14:31:53 <benmachine> e.g. list join = concat
14:32:02 <Peaker> CT notation and more advanced (other) stuff just made me more confused when I tried to understand functors, monads and the relationship between them
14:32:06 <tinLoaf> so how does the m (m a) -> m a function get the a "out" of the inner monad ?
14:32:16 <DrSyzygy> It doesn't.
14:32:21 <DrSyzygy> It fuses the monad instances.
14:32:28 <DrSyzygy> Think of what it looks like for Maybe.
14:32:32 <benmachine> tinLoaf: how join is done differs from monad to monad
14:32:46 <DrSyzygy> Just (Just a) -> Just a. Just Nothing -> Nothing. Nothing -> Nothing.
14:32:51 <Peaker> tinLoaf, basically it creates a new "m" that has the "effects" of both of the m'a combined
14:32:54 <tinLoaf> benmachine: i'm thinking about a general way, to implement >== in terms of fmap
14:32:55 <Peaker> tinLoaf, (outer one first)
14:32:56 <Botje> tinLoaf: join x = x >>= id -- for example. Have fun staring at that one :)
14:32:59 <DrSyzygy> Or for lists: [[1,2],[3]] -> [1,2,3]
14:33:17 <DrSyzygy> :t x >>= id
14:33:18 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
14:33:18 <lambdabot>     In the first argument of `(>>=)', namely `x'
14:33:18 <lambdabot>     In the expression: x >>= id
14:33:27 <DrSyzygy> :t \x -> x >>= id
14:33:27 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
14:33:38 <benmachine> tinLoaf: I'm not familiar with >==
14:33:47 <tinLoaf> uhm, ok, so that combination function for two monad instances has to be written for every monad individually
14:33:53 <DrSyzygy> Yes!
14:33:58 <DrSyzygy> It is what makes it a monad.
14:33:59 <tinLoaf> benmachine: that's because i wanted to write >>= ;)
14:34:11 <DrSyzygy> And to mess things up for you even more, the same data structure can support several different joins.
14:34:17 <benmachine> join can be implemented in terms of >>= and >>= in terms of join
14:34:30 <benmachine> but you need to define one of them to make a monad instance
14:34:43 <DrSyzygy> Either is probably the best example of that. You can make it functorial and monadic in the first summand or in the second.
14:34:46 <Peaker> benmachine, (given Functor instance)
14:34:51 <Peaker> (and pure)
14:34:56 <benmachine> Peaker: true
14:35:04 <tinLoaf> that's clear.. why i started this whole in the first point was that i wanted to get the difference between functors and monads
14:36:04 <DrSyzygy> tinLoaf: Monads are functors where you can fuse two layers of functor application.
14:36:18 <DrSyzygy> tinLoaf: Thus they are functors with some special extra properties.
14:36:25 <tinLoaf> ok, this sounds quite undertandable
14:36:32 <tinLoaf> *understandable
14:36:38 <Peaker> tinLoaf, my intuition is:  Functors let you create copies of boxes with modifies contents, but no combining.  Applicative Functors let you sequence pre-determined boxes together (combining their values purely, too).  Monads let you sequence boxes together based on the contents of boxes previously in the sequence
14:36:46 <DrSyzygy> And the whole thing about m m a -> m a is about taking that (m m) and fusing the layers into just an m.
14:38:06 <tinLoaf> ok.. and all that "monads can capsule side effects" etc. is because the monads themselves can contain the side effects, and by combining them you can make these side effects "interact"?
14:39:09 <Peaker> tinLoaf, monads can describe a lot of things that accompany the value and that the value/result is allowed to depend on (or not depend on).  Side effects are one possible such thing.  Monads (and Applicatives) also do sequencing of such accompanied values, and side effects are usually sequenced together to form bigger side effects
14:40:01 <tinLoaf> hum, ok.. i think i got some more clearness on how these monads work
14:40:45 <tinLoaf> i think one of my mistakes was to see monads really just as mere containers, although they may contain lots of stuff (aside from their "content")
14:40:59 <DrSyzygy> "mere containers" - thats Functor land. :-P
14:41:17 <DrSyzygy> You build a new type from an old type, and you're able to act on it on the inside.
14:41:23 <Botje> tinLoaf: best advice is to just start using them and fighting against the types
14:41:25 <DrSyzygy> Quite literally the definition of a functor.
14:41:26 <Botje> insight will come :)
14:41:42 <Baughn> tinLoaf: Or read the typeclassopedia. That helps too.
14:41:48 <DrSyzygy> Botje: No! First, you pick up Awodey's book on category theory! Once you've grokked that, you can continue! ;-)
14:41:58 <tinLoaf> Botje: normally i more use the "read stuff, then use it"-approach.. but i think this is useless here :)
14:42:20 <Peaker> tinLoaf, Functors don't really let you do any operation on the "f" in (f a) so they are just "mere" containers.  Monads let you take multiple "m"s and fuse them into one, which affects the accompanying information, and not just the value
14:42:33 <DrSyzygy> tinLoaf: If you have decent amounts of patience, I'm developing lecture notes that should cover the theoretical side of all of this. It'll take a few months before it's all written though.
14:42:55 <Botje> DrSyzygy: heh. I'll have to do that sometime ;)
14:43:12 <Botje> with luck my uni will have a course on category theory in 2 years >:)
14:43:14 <Peaker> tinLoaf, there are also the parameterized monads
14:43:19 <tinLoaf> DrSyzygy: i hope to have got a clue about monads and stuff by then, but if you tell me where i'll find them in a few month, chances are that i'll have a look then ;)
14:43:23 <Peaker> tinLoaf, which may help a bit in making stuff a bit more clear
14:43:23 <DrSyzygy> Botje: Natch.
14:43:31 <DrSyzygy> tinLoaf: Poke me about it.
14:43:46 <DrSyzygy> tinLoaf: Or just search the Haskell wiki for 'MATH198'.
14:43:56 <tinLoaf> Peaker: parameterized monads are easier to understand?
14:43:59 <Peaker> tinLoaf, basically something like adding a pre/post type args to monads and only allow composition of monads when the types match
14:44:18 <tinLoaf> uhm, ok
14:44:49 <Peaker> tinLoaf, changing types to:  return :: m s s a      join :: m q r (m r s a) -> m q s a
14:44:54 <tinLoaf> Botje: category theory is not mandatory on most unis?
14:45:02 <tinLoaf> (when studying CS..)
14:45:03 <Peaker> tinLoaf, (>>=) :: m q r a -> (a -> m r s b) -> m q s b
14:45:09 <Baughn> fmap f (Foo a b) = Foo (a+1) (f b) -- Well, "fmap doesn't touch accompanying data" isn't /entirely/ true..
14:45:10 <copumpkin> tinLoaf: definitely not
14:45:23 <Botje> tinLoaf: i'd like it to be :)
14:45:30 <ziman> Baughn, but then fmap id /= id
14:45:30 <tinLoaf> copumpkin: so chances are i'll dodge that bullet ;)
14:45:33 <Peaker> tinLoaf, note how a monad has a value but also a "goes from q to r" type params, and you can only fuse monads that match.  Do you know the State monad?
14:45:49 <tinLoaf> nope, not yet
14:46:08 <Peaker> tinLoaf, that is a great monad for helping to understand how monads help with sequencing effects
14:46:08 <Baughn> ziman: Some people will take that as a challenge, adding a rewrite rule for id for that type
14:46:27 <ziman> how do you recognize id? ;)
14:46:36 <tinLoaf> Peaker: ok.. "a catalogue of standard monads" would be the next chapter of "all about monads" for me to read, i think its in there
14:46:51 <Baughn> ziman: Oh, that's easy. Enumerate all inputs, and check if they're equal to the outputs.
14:47:40 <Peaker> tinLoaf, did you follow the stuff about q r s in the monads above?
14:47:48 <tinLoaf> Peaker: i'm still trying to
14:48:15 <tinLoaf> you know what is a big "showstopper" when learning haskell (or functional programming)?
14:48:17 <Peaker> tinLoaf, ah, ok.   It might be a bit clearer if we use an infix name instead of "m"
14:48:20 <tinLoaf> all that one-letter-variables
14:48:21 <Peaker> tinLoaf, what?
14:48:34 <tinLoaf> i like my descriptive variable names from C ;)
14:48:39 <Peaker> tinLoaf, heh, yeah, some of those are bad/unjustified. But sometimes something is just so general there's no good name :)
14:49:06 <Makoryu> :t (>>=)
14:49:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:49:08 <tinLoaf> ok, so "m" is the monad. "r" and "q" are the parameters of that monad, right?
14:49:19 <tinLoaf> which set which monad may be combined with which
14:49:21 <ziman> Baughn, ah i see, i haven't considered that. ;)
14:49:22 <Peaker> tinLoaf, If you use (~>) infix instead of m, the above signature of (>>=) becomes:   (q ~> r) a -> (a -> (r ~> s) b) -> (q ~> s) b
14:49:32 <Peaker> tinLoaf, yeah
14:50:07 <Makoryu> ^ For tinLoaf, this can be rewritten as: Monad monad => monad contents1 -> (contents1 -> monad contents2) -> monad contents2
14:50:40 <tinLoaf> Makoryu: but this is not a declaration for "parameterized monads", is it?
14:51:10 <tinLoaf> that's a normal >>= :: m a -> (a -> m a) -> m b
14:51:13 <Makoryu> tinLoaf: No, it's not.
14:51:15 <Makoryu> Yeah.
14:51:29 <tinLoaf> yeah, i was pondering about the "parameterized monads" now ;)
14:51:58 <tinLoaf> Peaker: ah, but i think i got it now
14:52:14 <c_wraith> :t (>>)
14:52:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:52:19 <Peaker> tinLoaf, it controls which monadic values can be fused with each other
14:52:29 <tinLoaf> Peaker: so you can like use theses parameters as additional "states", how far these monads have already been fused
14:53:10 <tinLoaf> say you have three monads, with one of q->r, one with r->s, one with s->t
14:53:13 <Peaker> tinLoaf, sort of..  if you implement State monad's (>>=) and allow the compiler to infer the types, you get a more general type than of (>>=) which is a good hint
14:53:30 <tinLoaf> if you now get out a monad q->t you know that this was made by fusing all these three
14:53:34 <c_wraith> @src (>>)
14:53:35 <lambdabot> m >> k      = m >>= \_ -> k
14:53:52 <Peaker> tinLoaf, Yeah, if those are universally quantified
14:54:09 <Peaker> tinLoaf, (I mean, if q,r,s,t cannot be made up by someone elsewhere somehow)
14:54:16 <tinLoaf> yeah, of course
14:54:46 <tinLoaf> is the state monad such a parameterized monad?
14:55:17 <Peaker> tinLoaf, yeah, it has a parameterized monad instance.. I think all monads can have one
14:55:18 <tinLoaf> hum, doesn't look like it
14:55:24 <tinLoaf> ah, ok
14:55:24 <Peaker> (at worst, by adding phantom types)
14:56:09 <c_wraith> > [1, 2] >> [1, 2, 3] >>= return
14:56:10 <lambdabot>   [1,2,3,1,2,3]
14:58:08 <c_wraith> > [1, 2] >>= [1, 2, 3] >>= return . (,)
14:58:09 <lambdabot>   Couldn't match expected type `t -> [a]'
14:58:09 <lambdabot>         against inferred type `[a1]'
14:58:37 <c_wraith> oh, hah.
14:58:58 <copumpkin> > [1, 2] >> [1, 2, 3] >>= return . (,)
14:58:59 <lambdabot>   [{()->(1,())},{()->(2,())},{()->(3,())},{()->(1,())},{()->(2,())},{()->(3,(...
14:59:20 <c_wraith> that's...  not even close to what I was trying to do. :)
14:59:24 <copumpkin> :P
14:59:28 <copumpkin> :t [1, 2] >> [1, 2, 3] >>= return . (,)
14:59:29 <lambdabot> forall t b. (Num t) => [b -> (t, b)]
15:00:00 <Peaker> > liftA2 (,) [1,2] [1,2,3]
15:00:00 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
15:00:03 <Peaker> ?
15:00:12 <c_wraith> Sure, but that misses the point
15:00:23 <Peaker> The (>>) there already loses the 1,2
15:00:31 <Peaker> it only keeps the length of the list
15:00:38 <c_wraith> Oh,  that was a different experiment
15:01:45 <Peaker> > [1,2] >>= (\x -> [1,2,3] >>= return . ((,) x))
15:01:46 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
15:02:20 <c_wraith> yes, but once again missing the point.  The point was to figure out (by myself) how to do that point-free
15:02:39 <c_wraith> mostly as an exercise in thinking in the proper types
15:03:01 <DuClare> Haha
15:03:12 <DuClare> 010220  c_wraith> yes, but once again missing the point.  The point was to figure out (by myself) how to do that point-free
15:03:19 <DuClare> I got the point.
15:03:22 <c_wraith> yes.  bad puns. :)
15:03:28 <DuClare> :)
15:03:38 <DuClare> Good ones.
15:04:10 <Peaker> @pl xs >>= (\x -> ys >>= return . ((,) x))
15:04:11 <lambdabot> (`fmap` ys) . (,) =<< xs
15:05:06 <Makoryu> :t (<$> ys) . (,) =<< xs
15:05:07 <lambdabot> Not in scope: `ys'
15:05:07 <lambdabot> Not in scope: `xs'
15:05:13 <Makoryu> :t \ys xs (<$> ys) . (,) =<< xs
15:05:13 <lambdabot> Parse error in pattern
15:05:19 <Makoryu> :t \ys xs -> (<$> ys) . (,) =<< xs
15:05:20 <copumpkin> missin ur arro
15:05:20 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => f a -> f a1 -> f (a1, a)
15:05:29 <Makoryu> Yeah, hit return a little too soon
15:05:42 <Makoryu> :t \ys xs -> flip fmap ys . (,) =<< xs
15:05:43 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => f a -> f a1 -> f (a1, a)
15:07:01 <Peaker> :t \f xs ys -> flip fmap ys . f =<< xs
15:07:02 <lambdabot> forall a b (f :: * -> *) a1. (Functor f, Monad f) => (a1 -> a -> b) -> f a1 -> f a -> f b
15:07:13 <Peaker> :t liftM2
15:07:14 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:07:41 <c_wraith> > (,) <$> [1, 2] <*> [1, 2, 3]
15:07:42 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
15:08:19 <c_wraith> @src ap
15:08:19 <lambdabot> ap = liftM2 id
15:09:34 <Polarina> Is this function tail recursive?
15:09:44 <Polarina> http://codepad.org/LwmcVhhU
15:10:00 <Makoryu> Polarina: Yes.
15:10:18 <Polarina> :D
15:10:20 <Makoryu> Polarina: Mind you, it's not necessarily strict.
15:10:29 <Polarina> Makoryu: Strict?
15:10:36 <Makoryu> As opposed to lazy.
15:10:44 <Polarina> No, no. :)
15:12:45 <Makoryu> IIRC, stuff you can use in a tail-recursive function: case, let/where, if, seq
15:12:52 <byorgey> Polarina: the point is that in a lazy language like Haskell, tail-recursiveness is not the whole story about efficient recursion.
15:13:18 <byorgey> Polarina: that function will likely create a list with a single element containing the *unevaluated* expression  a1+a2+a3+a4+a5+a6+...
15:13:19 <Makoryu> Yeah. Evaluating that function will build a huge thunk of thunks of thunks
15:13:32 <Polarina> :(
15:13:34 <byorgey> the addition will only happen when the value is actually demanded.
15:14:10 <byorgey> Polarina: for efficiently adding lists it's advised to use  foldl'  from Data.List
15:14:15 <byorgey> > foldl' (+) 0 [1..10]
15:14:16 <Makoryu> Polarina: So, write the middle case as: let foo = x + y in foo `seq` sum_tail (foo : xs)
15:14:16 <lambdabot>   55
15:14:45 <Makoryu> Polarina: Or as: let (!foo) = x + y in sum_tail (foo : xs)
15:14:56 <byorgey> Polarina: if I were you I wouldn't worry too much about tail recursion; usually it doesn't matter in Haskell.
15:15:01 <Makoryu> You need an extension for the latter. -XBangPatterns, I believe.
15:15:06 <Polarina> Other than foldl' (for practicing reasons) how do I make that efficient?
15:15:17 <c_wraith> also, line 4 would be a lot clearer if it was: sum_tail [x] = x
15:15:24 <Makoryu> Polarina: By making it strict.
15:15:32 <Polarina> Makoryu: How?
15:15:47 <Makoryu> Polarina: ^ The rewrites I just mentioned.
15:15:58 <Polarina> Makoryu: Which one?
15:16:23 <Makoryu> Polarina: Either of them. Use seq or bang patters. It doesn't matter.
15:17:23 <Polarina> Makoryu: Why "let (!foo) = x + y in sum_tail (foo : xs)" and not "sum_tail ((x + y) : xs)"?
15:18:07 <Makoryu> Polarina: Because the way I wrote it, it will evaluate the thunk before passing it as an argument.
15:18:22 <Makoryu> "The thunk" here being the expression "x + y"
15:18:29 <Polarina> I don't get it.
15:19:13 <c_wraith> do you understand what Makoryu means by "lazy"?
15:19:24 <Polarina> c_wraith: Yes, evaluated when needed.
15:19:31 <Makoryu> Polarina: Okay, when you bind an expression in Haskell, the name points to a "thunk," which is a piece of code that, when called, will evaluate to the actual value.
15:19:35 <Polarina> c_wraith: And I don't see how a "let" will make it "needed".
15:19:42 <c_wraith> let doesn't.  the ! does
15:19:48 <Makoryu> Polarina: It's not the "let." It's the "seq" (or the "!")
15:20:08 <Polarina> The !?
15:20:26 <DuClare> The !!
15:20:40 <Polarina> What is the ! ?
15:20:53 <Makoryu> Polarina: There's an extension called -XBangPatterns that lets you write "!foo" for any variable that you want to automatically be evaluated before the function body is evaluated.
15:20:53 <DuClare> 011445  Makoryu> Polarina: Or as: let (!foo) = x + y in sum_tail (foo : xs)
15:21:17 <Polarina> Ah, not a part of the standard then?
15:21:26 <c_wraith> no.  but seq is part of the standard
15:21:31 <c_wraith> and was his first suggestion
15:21:37 <Makoryu> Yeah. The standard way is to do it within the function body, by writing "foo `seq` f foo"
15:21:59 <Polarina> f foo?
15:22:20 <Makoryu> Replace "f foo" with any arbitrary function body that uses foo. :p
15:22:41 <Polarina> Don't you need parenthesis?
15:22:42 <c_wraith> f1 bar = let foo = f2 bar in foo `seq` f1 foo
15:22:56 <Makoryu> Polarina: For seq?
15:23:04 <c_wraith> Parens aren't needed very often in haskell.
15:23:05 <Polarina> Makoryu: No, around "f foo"
15:23:13 <mmorrow> @src foldl'
15:23:13 <lambdabot> foldl' f a []     = a
15:23:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:23:32 <Makoryu> Polarina: You never need parentheses around function application. It has the highest precedence.
15:23:33 <mmorrow> @src $!
15:23:34 <lambdabot> f $! x = x `seq` f x
15:23:49 <c_wraith> @index $!
15:23:49 <lambdabot> Prelude
15:24:00 <Peaker> Makoryu, f (g x)
15:24:14 <Makoryu> Polarina: I mean, you need it if you want to use "f foo" as an argument to another function, but other than that, I can't think of any other instance.
15:24:20 <Makoryu> Yes, like that.
15:24:30 <c_wraith> f . g $ x
15:24:31 <Makoryu> Polarina: But you can also write that as "f $ g x"
15:24:37 <Polarina> What does $ do?
15:24:38 <Makoryu> Or that.
15:24:46 <Polarina> And .?
15:24:48 <c_wraith> $ does almost nothing.
15:24:50 <RayNbow> > f $ x
15:24:50 <mmorrow> (g . f)
15:24:51 <lambdabot>   Ambiguous type variable `b' in the constraints:
15:24:51 <lambdabot>    `GHC.Show.Show b'
15:24:51 <lambdabot>      a...
15:24:52 <Makoryu> Polarina: f $ x = f x
15:24:55 <RayNbow> > f $ x  ::  Expr
15:24:56 <lambdabot>   f x
15:25:13 <c_wraith> @src $
15:25:13 <lambdabot> f $ x = f x
15:25:15 <Makoryu> Polarina: The whole reason for ($) is to break up parenthesized expressions
15:25:27 <Polarina> I'll stick to parentheses.
15:25:34 <Peaker> Polarina, $ does func application, like (f x) does.  so (f $ x) = (f x). It has low precedence so is like having () around each side of it
15:25:57 <Peaker> Polarina, And . does func composition.  f . g   is a function that applies g and then f
15:26:05 <mmorrow> main = print . scanl (\count line -> count + length line) 0 . lines =<< getContents
15:26:08 <Polarina> Composition?
15:26:11 <Peaker> Polarina, f (g x) = f . g $ x
15:26:24 <Polarina> ...
15:26:24 <Makoryu> Polarina: (f . g) x = f (g x)
15:26:25 <Peaker> Polarina, Yeah, taking  (a -> b)   and   (b -> c)     and building (a -> c)
15:26:36 <c_wraith> The specific reason that parens aren't necessary in that case, though, is that function application always takes precedence over binary operators.
15:26:41 <Peaker> Polarina, (I flipped the args for clarity here)
15:26:44 <Polarina> Peaker: Ah.
15:26:59 <Polarina> Peaker: And how to use the .?
15:27:16 <RayNbow> > succ . (*3) . pred $ 11
15:27:17 <lambdabot>   31
15:27:17 <c_wraith> and using backticks around a function makes it a binary operator.
15:27:21 <mrsolo> i am trying out real world haskell example http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3890#a3890
15:27:31 <mmorrow> , ((*2) . (+2) . negate . length . show) [0..4]
15:27:32 <lunabot>  -18
15:27:32 <mrsolo> is there way to make that codes run faster?
15:27:50 <mrsolo> simple time benchmark shows that it runs about 1/2 as well as perl counterpart..
15:28:10 <Makoryu> mrsolo: There's a chapter in RWH dedicated to making things run faster.
15:28:33 <mmorrow> , ord 'A' - ord 'a'
15:28:34 <mrsolo> ah chapter 25
15:28:34 <lunabot>  -32
15:28:40 <mrsolo> i am in chapter 7 :-)
15:28:42 <Makoryu> mrsolo: http://book.realworldhaskell.org/read/profiling-and-optimization.html
15:28:54 <Makoryu> mrsolo: Keep reading. This is chapter 25 :p
15:29:00 <Makoryu> Yeah.
15:29:21 <c_wraith> That's about 90% unnecessary code
15:30:59 <c_wraith> All you really want to do is call hGetContents on the input file, map toUpper, and write it to the output file
15:32:28 <Peaker> Polarina, A function that adds 2 and then multiplies by 5:  (*5) . (+2)
15:34:08 <mrsolo> c_wraith: nice let me try that.. yea it is an example out of cha7 more for learning IO
15:34:20 <c_wraith> if you were ok with working with stdin and stdout, you could write the hwole program as "main = interact $ map toUpper"
15:34:29 <c_wraith> There are minor semantic differences
15:34:42 <c_wraith> Depending on how your system handles encodings
15:34:51 <c_wraith> and how hGetContents handles encodings
15:35:30 <mmorrow> mrsolo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9722#a9722
15:35:59 <mrsolo> mmorrow: why Lazy.Char8? faster?
15:36:10 <mmorrow> it'll stream
15:36:31 <mmorrow> if you want to read the entire file at once, just s/Lazy// (literally) to that file
15:36:52 <mmorrow> well, s|Lazy\.||  ;)
15:37:30 * mmorrow swears he doesn't do that kind of this often though ;)
15:37:39 <mmorrow> sed++++++
15:37:58 <c_wraith> @karma sed
15:37:58 <lambdabot> sed has a karma of 0
15:38:04 <c_wraith> sed++
15:38:06 <mmorrow> sed++
15:38:07 <c_wraith> @karma sed
15:38:07 <lambdabot> sed has a karma of 2
15:40:35 <benmachine> @karma sed++++
15:40:35 <lambdabot> sed++++ has a karma of 1
15:40:42 <c_wraith> haha
15:40:54 <aavogt> @hoogle liftM9
15:40:55 <lambdabot> No results found
15:41:02 <c_wraith> 9?
15:41:06 <c_wraith> that's impressive
15:41:18 <benmachine> can't you just use liftM and ap
15:41:23 <tommd> @hoogle liftM7
15:41:23 <lambdabot> No results found
15:41:30 <benmachine> :t liftM4
15:41:31 <lambdabot> forall a1 a2 a3 a4 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
15:42:03 <aavogt> benmachine: I'm already using ap: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9710
15:42:06 <tommd> humm, things usually stop at 7 when its tuples.  I guess the number gets lower the higher the theory.
15:42:09 <benmachine> :t \f a b c d e -> liftM4 f a b c d `ap` e
15:42:10 <lambdabot> forall a1 a2 a3 a4 a b (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> a -> b) -> m a1 -> m a2 -> m a3 -> m a4 -> m a -> m b
15:42:15 <aavogt> I want to add one more level
15:42:30 <ziman> > foldl ($) (\ a b c d -> a+b+c+d) [1,2,3,4]
15:42:31 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> b
15:43:13 <aavogt> where the withDef values are tagged (ex. with writer), so I can warn that xyz fields defaulted
15:44:26 <aavogt> it didn't work out to use an Applicative to store that data, since Perm has no alternative instance
15:44:46 <mrsolo> mmorrow: about 20% from original code but still slower than perl counterpart.  is haskell IO inheritently slower?
15:44:56 <mrsolo> 20% faster that is
15:45:15 <lpsmith> @karma c
15:45:15 <lambdabot> c has a karma of 1
15:48:19 <Makoryu> mrsolo: The list-based IO is kind of slow. ByteString-based IO is fast, however.
15:49:52 <Makoryu> mrsolo: I believe ByteStrings are covered by another RWH chapter
15:54:48 <aavogt> @hoogle ppDoc
15:54:48 <lambdabot> No results found
16:00:40 <Peaker> I wish Haskell evangelists stopped using "higher order functions" as a point in favor of Haskell.. pretty much everyone has that these days
16:01:24 <Peaker> when I read http://blog.typlab.com/2009/09/why-we-use-haskell/ saying Haskell functions are values and therefore we can do this and that, I think: "If he's excited about that, the rest of the features he's mentioning are probably not that exciting either"
16:01:35 <Peaker> (Given that I already know this and have this in my language)
16:01:41 <Peaker> (and its considered a triviality by now)
16:02:48 <gwern> Peaker: congratulations, you have been eaten by Blub
16:03:14 <p_l> blub?
16:03:34 <aavogt> bulb
16:04:08 <aavogt> coincidence?
16:05:22 <Peaker> gwern, ?
16:05:32 <aavogt> p_l: something apparently made up by Paul Graham
16:05:48 <Peaker> aavogt, what is it?
16:07:06 <aavogt> Peaker: it is a programming language missing certain features, and using it makes you think you don't need those (HOFs for instance)
16:07:22 <Makoryu> Peaker: It's an essay about how people become blind to any room for improvement in their favorite language
16:07:38 <copumpkin> really? I love haskell but there's a bajillion things I want to do to it
16:07:43 <copumpkin> and several gripes I have
16:07:45 <Makoryu> Peaker: http://www.paulgraham.com/avg.html
16:08:00 <wchogg> Or, equivalently, it's Paul Graham excusing the inability of language advocates to explain their position clearly by saying that the audience just "doesn't get it".
16:08:06 <Makoryu> copumpkin: Not everyone is a Blub programmer :p
16:08:12 <Peaker> Makoryu, aavogt: I agree with that effect -- my point was that you shouldn't try to sell people a language by saying it has this amazing feature that their language has always had
16:09:11 <aavogt> yeah, I'm not sure exactly what gwern means
16:09:24 <Makoryu> Peaker: Yeah, gwern's response to what you said was a misunderstanding of Blub, but I figured you ought to know what he meant anyway :p
16:10:29 <Peaker> I think to imperative programmers, local reasoning, laziness and separation of side effects are far more exciting than HOFs
16:11:09 <Makoryu> Yeah. The hard part is convincing them not to run away thinking all these things are bad
16:13:11 <aavogt> laziness means a loss of control, and it is easy to dismiss as something only used in trivial examples (since that is all we have space to explain with)
16:13:46 <newsham> http://www.crunchgear.com/2009/09/22/sgi-releases-first-new-product-since-bankruptcy-octane-iii/ <- 80 core em64t anyone?
16:14:54 <Peaker> aavogt, not loss of control, but loss of some operational transparency
16:15:00 <Peaker> (you can still control strictness)
16:16:11 <Peaker> I think there is a real trade-off between denotational transparency and operational transparency (and that it can be somewhat bridged by having a really good IDE that lets you add annotations/transformations to your program that preserve its denotational meaning but alter its operational one, allowing you to interact with the optimizer)
16:16:17 <Peaker> Most programmers already agree that a GC is a good idea (and it is an example of losing operational transparency for denotational simplicity/transparency)
16:18:22 <RayNbow> Peaker: unfortunately, there are still plenty of programmers that deny the reason of a GC's existence :p
16:18:29 <RayNbow> (you mean garbage collector, right?)
16:18:38 <Peaker> Yeah
16:18:53 <Peaker> well, some programmers value operational transparency over denotational one..
16:19:30 <Peaker> In some cases, its even justified, IMO:  Its better to have a system guaranteed not to leak and have clear performance charactaristics with some logical bugs, than one that is logically correct but slowly leaks until it will eventually die completely
16:20:01 <Peaker> As most logical bugs can be worked around, or fixed for periods of time, whereas complete death may mean downtime or such
16:21:34 <RayNbow> Peaker: the dreaded OutOfMemory error? :p
16:22:59 <Peaker> RayNbow, as an example, yeah
16:23:00 * RayNbow once had to do a lab course which involved killing a Tomcat server almost every time he modified his application
16:24:11 <Peaker> I think in order to have the best of both worlds, we need a Haskell IDE that exposes the actual evaluation that will take place, including all optimizations, and allow you to toy with the code until you are satisfied with how it runs, allowing simultaneously seeing the denotational and operational semantics
16:25:08 <Peaker> (GC will still be hidden, though you could probably somehow prove (in a DT language, perhaps, or using linear types) that a lot of stuff can be allocated on the stack, or at least place an upper bound on where its freed as to guarantee freeing
16:25:14 <Peaker> )
16:25:14 <RayNbow> btw, I would love a Haskell IDE with on the fly incremental compilation :p
16:25:21 <Rotaerk> i currently use gvim for haskell development... don't really care for it...
16:25:49 * RayNbow is a plain ol' Notepad user for simple 1-file Haskell apps :p
16:25:50 * RayNbow hides
16:26:06 <Rotaerk> notepad... ouch
16:26:31 <burp> wine Notepad.exe?
16:26:53 <Makoryu> Rotaerk: If you kick Vim in the face enough times and adjust your style to its indentation patterns, it's actually pretty nice for writing Haskell. Wish it would indent data declarations properly though.
16:26:54 <RayNbow> no, c:\Windows\notepad.exe ;)
16:26:58 <burp> hehe
16:27:22 <Rotaerk> I don't mind vim's indentation
16:28:19 <Peaker> RayNbow, on-the-fly incremental type-inference, compilation, and execution.. then a view mode for visualizing the optimizations/evaluation strategy :)
16:28:22 <benmachine> neither do I, because I turn it off >_>
16:28:31 <Rotaerk> I just don't care for its controls; mostly it just doesn't behave how I'd expect sometimes
16:29:02 * benmachine indents by pressing space a lot
16:29:05 <RayNbow> Peaker: that would be awesome :)
16:29:50 <Makoryu> benmachine: ‡≤†_‡≤†
16:30:51 <benmachine> Makoryu: those are boxes with 0CA0 written in them
16:31:47 <Peaker> I think vim's "on-a-character" that goes back when you exit insert mode on end-of-line is annoying..
16:31:50 <Rotaerk> you need a font with better unicode-coverage then
16:32:01 <Peaker> cursor should be *between* characters, damnit :-)
16:32:13 <benmachine> Rotaerk: probably
16:32:30 <jfoutz> Peaker, that's why it goes back. :)
16:32:45 <Peaker> jfoutz, It can be between the last character and the EOL
16:32:57 <Makoryu> Peaker: You can customize this behavior
16:32:58 <Peaker> jfoutz, EOL should also be a character, its easier to manipulate that way :)
16:33:06 <jfoutz> isn't it?
16:33:22 <benmachine> it is literally, but arguably vim doesn't treat it as such
16:33:32 <jfoutz> yes, it does, it's just hard to type.
16:33:33 <Peaker> jfoutz, In older vims I think it wasn't. In newer, it may behave somewhat like one, but cursor still can't be right before it (but after last actual char)
16:33:44 <jfoutz> <ctrl-V>[return]
16:33:57 <jfoutz> :%s/^v^m//
16:34:18 <jfoutz> oh! lame.
16:34:23 <jfoutz> sorry.
16:36:29 <Peaker> jfoutz, anyway, the cursor jumping around like that always confuses me
16:38:43 <jfoutz> yeah, i guess it is pretty odd. the whole command-mode idea was very alien to me.
16:42:07 <Makoryu> Peaker: :set virtualedit+=onemore
16:42:33 <Makoryu> Oh, never mind, that doesn't quite do it
16:44:05 <Peaker> Anyway, I also think vim isn't discoverable enough (at least not easily enough)  (Where's my C-h b?). Its extension language even more horrible than elisp
16:44:59 <Makoryu> Peaker: http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html
16:45:10 <Makoryu> Ideally, this would be included by default in vim
16:45:43 <Peaker> does vim have a "directory editor" like emacs?
16:45:49 <Makoryu> Yep
16:45:59 <Peaker> how do I activate it?
16:46:04 <Makoryu> Edit a directory
16:46:11 <jfoutz> :e /usr
16:46:11 <Makoryu> For example: :e ~/Documents
16:46:35 <Peaker> "." is a directory
16:46:37 <Peaker> (error)
16:46:52 <Makoryu> ... You don't have netrw installed, then, I guess
16:46:57 <Makoryu> I thought it was included....
16:47:03 <Makoryu> What version do you have?
16:47:08 <jfoutz> maybe you ran as vi?
16:47:48 <jfoutz> or, six as i like to call it.
16:49:24 <Peaker> VIM - Vi IMproved 7.2 (2008 Aug 9, compiled Mar 19 2009 15:24:43)
16:50:34 <jfoutz> hmm.
16:50:37 <jfoutz> well :help is worth checking out.
16:50:52 <jfoutz> but if emacs works for you, it might not be worth swiching.
16:51:35 <Peaker> I tried vim some, I prefer having elisp at hand, and I much prefer its cursor behavior... I love the directory editor too, cause it allows me to record macros of operations on files...
16:55:05 <Makoryu> Peaker: http://www.vim.org/scripts/script.php?script_id=1075 <- You can install it by hand, I guess
16:55:19 <Makoryu> But yeah, if Emacs is your thing, go for it
16:55:20 <jfoutz> yeah, macro recording, syntax aware navigation, and good regex replace tools are pretty much requirements for me.
16:55:56 <jfoutz> i think emacs and vim do all of those quite well, but they have very different attitudes about it.
16:56:10 <Peaker> brb
16:56:21 <periodic> They are both extensible to do just about anything, so the question is which philosophy you like best.
16:56:37 <jfoutz> mostly i don't like the way my wrists feel after using emacs for a few months.
16:56:42 <periodic> It's like OO vs Functional.  They could both theoretically do anything, but which do you like more. :D
16:56:49 <jfoutz> :)
16:56:51 <periodic> jfoutz: It's my pinkies that suffer.
16:57:11 <jfoutz> periodic: have you moved control? swap caps lock. helps immensely.
16:58:02 <periodic> jfoutz: yup.  There was a moment as an undergrad when all the systems in the computer lab were taken except for the Sun Solaris systems.  I sat down and when I realized they had control where caps usually is, I had an epiphany.
16:58:06 <periodic> Haven't looked back.
16:58:13 * jfoutz grins
16:58:37 <periodic> Alt is just so awkward though...
16:58:51 <periodic> And I like moving around with jkl;
16:59:01 <Makoryu> Not hjkl?
16:59:06 <periodic> er, right
16:59:08 <periodic> hjkl
16:59:14 <periodic> I don't think about it anymore. :P
16:59:38 * RayNbow still uses arrow keys in vim
16:59:44 <RayNbow> I use jk in Gmail though :p
17:00:02 <periodic> RayNbow: use vimperator!
17:00:31 <RayNbow> periodic: already am using it on my netbook's Arch installation :p
17:00:49 <RayNbow> too bad I was forced to switch to vimperator 2
17:00:50 <SamB_XP_> jkl is for people who are always looking to the future
17:00:53 <SamB_XP_> only going forwards
17:01:01 <RayNbow> vimperator 1.2 had faster tab completion
17:01:35 <hackagebot> graphics-drawingcombinators 0.41 - A functional interface to 2D drawing in OpenGL (LukePalmer)
17:02:32 <periodic> RayNbow: I noticed that when I switched to 2.1.  Glad it wasn't just me.
17:07:36 <hackagebot> graphics-drawingcombinators 0.42 - A functional interface to 2D drawing in OpenGL (LukePalmer)
17:09:56 <roconnor> ooooh
17:16:42 <mrsolo> style question:  which is commonly used? "foo.fee" or "foo . fee"
17:17:11 <Makoryu> mrsolo: The latter.
17:17:41 <Makoryu> mrsolo: Don't use the former. Even though technically allowed in many cases, it's also too similar to the qualified name notation
17:18:08 <Makoryu> For example: import qualified Foo as F; bar = Foo.baz
17:18:08 <mrsolo> ah good point thanks
17:18:12 <benmachine> > Just.id$3
17:18:13 <lambdabot>   Not in scope: `Just.id'
17:18:18 <benmachine> > Just . id $ 3
17:18:19 <lambdabot>   Just 3
17:18:42 * benmachine has got into the habit of doing [a .. b] now as well
17:19:16 <aavogt> > [1.0..3.4]
17:19:17 <lambdabot>   [1.0,2.0,3.0]
17:19:24 <roconnor> benmachine: why?
17:19:36 <benmachine> roconnor: because this annoyed me
17:19:41 <benmachine> > [False..True]
17:19:41 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
17:19:44 <roconnor> ah
17:22:01 <ddarius> module False where (.) x = [False .. x]
17:23:04 <Peaker> ddarius, ??
17:48:35 <Makoryu> :t map toLower
17:48:36 <lambdabot> [Char] -> [Char]
18:04:53 <benmachine> > mapM (+) [1,2,3,4] 5
18:04:54 <lambdabot>   [6,7,8,9]
18:05:25 * benmachine wonders vaguely whether this is interesting
18:06:31 <dobblego> benmachine, I use mapM on the ((->) t) monad often
18:12:15 <lispy|web> anyone here ever used weak refs in Haskell?  If so, what did you think?
18:13:21 <copumpkin> they're not what I'd like them to be
18:14:07 <Saizan__> how so?
18:14:31 <copumpkin> :o
18:14:39 <copumpkin> is someone misbehaving with lambdabot?
18:15:12 <Makoryu> copumpkin: Nah, Cale's trying to install a brainfuck interpreter
18:15:21 <copumpkin> ah
18:15:44 <Cale> Yeah, it was broken, so I'm fixing it. Needed to recompile, it was just looking in the current directory for it rather than the whole path.
18:16:25 <copumpkin> Saizan__: as for weak refs, I'd like them to be transparently recomputable weak refs with some sort of heuristic for forgettableness
18:16:44 <lispy|web> Cale: is that the bf interpreter I wrote for lambdabot or a different one?
18:17:06 <Cale> lispy|web: It's the one which comes with lambdabot
18:17:14 <lispy|web> I think I wrote that
18:17:25 <lispy|web> So if it's horrendous, you know who to yell at :)
18:18:42 <lispy|web> copumpkin: hmm....I'm not sure, but I don't know if I want mine to be transparently recomputable.  I'm going to read an SPJ paper about them now
18:18:52 <Cale> Nah, it was just a wibble in the lambdabot plugin. I changed "./bf" to "bf" and it's fine now :)
18:19:03 <lispy|web> ?bf ++++>+
18:19:03 <lambdabot>  Done.
18:19:06 <copumpkin> lispy|web: it's pretty simple really, you get to ask the weak ref if it's still alive, and get a Maybe out of that
18:19:24 <lispy|web> I see
18:19:35 <lispy|web> what is the type of the constructor function?
18:19:43 <lispy|web> and is there a way to tell GHC to clean up weak refs?
18:21:57 <byorgey> ?bf ++++.
18:21:57 <lambdabot>  Done.
18:22:33 <lispy|web> the full interpreter is fully featured AFAIK, but lambdabot's interface to it is a bit "stripped down"
18:22:37 <copumpkin> ?bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
18:22:37 <lambdabot>   Hello World!
18:22:50 <byorgey> nice =)
18:22:59 <byorgey> how does it handle the , instruction?
18:23:04 <byorgey> or doesn't it?
18:23:11 <SamB_XP> byorgey: my guess?
18:23:13 <SamB_XP> immediate EOF
18:23:21 <lispy|web> IIRC lambdabot filters out some instructions
18:23:24 <benmachine> @bf ,.
18:23:24 <lambdabot>  Done.
18:23:26 <SamB_XP> so, not very predictably
18:23:31 * benmachine shrugs
18:23:52 * Cale fixes the unlambda interpreter too
18:23:56 <copumpkin> :O
18:24:21 <lispy|web> also, there is a filter on what it can write to #haskell
18:24:24 <lispy|web> IIRC, only ASCII
18:25:56 <roconnor> ;( someone should hire QtPlaty
18:26:01 <copumpkin> aw
18:28:39 <Cale> lispy|web: btw, a better version of vim would be nice
18:28:57 <lispy|web> oh right, I saw your email but I couldn't take action at the time
18:29:42 <lispy|web> okay, try vim now
18:29:49 <SamB_XP> lispy|web: some pathetic reason like being away from home with no actual keyboard anywhere nearby?
18:30:09 <lispy|web> SamB_XP: pretty much
18:30:23 <SamB_XP> ... and you can't ssh from a phone?
18:30:37 <lispy|web> Cale: and unp is now installed
18:30:47 <Cale> lispy|web: thanks!
18:31:01 <Cale> awesome! syntax colouring :)
18:31:03 <lispy|web> SamB_XP: well, I was traveling in Japan where my phone doesn't work.  My internet was at a PC in the lobby of a hotel.
18:31:13 <SamB_XP> lispy|web: ah
18:31:20 <SamB_XP> so ... explain your lack of SSHing
18:31:27 <lispy|web> I do have SSH on my phone...
18:31:36 <lispy|web> SSH, RDP, and VNC actually
18:31:40 <SamB_XP> I don't even get internet on mine ;-P
18:31:47 <Cale> and mouse support :)
18:31:48 <SamB_XP> but why didn't you SSH from the hotel computer?
18:32:19 <lispy|web> SamB_XP: I didn't want to download anything to it just because it was a little bed and breakfast place.  It seemed like that might be rude.
18:32:23 <SamB_XP> lispy|web: what kind of screen does your phone have that RDP/VNC are actually useful?
18:32:28 <orbitz> is ther ea good wiki page on how to work with the number types in Haskell?
18:32:29 <SamB_XP> lispy|web: ah
18:32:35 <SamB_XP> bed and breakfast, yeah, maybe
18:32:48 <SamB_XP> on the other hand, you could have downloaded putty and deleted it when you were done ...
18:32:51 <orbitz> I'm getting beef about sum l / length l, I want the result to be a float
18:33:02 <lispy|web> fromIntegral
18:33:04 <SamB_XP> ... nevermind the registry entries it would leave behind ;-P
18:33:28 <lispy|web> :t \l -> fromIntegral (sum l) / genericLength l
18:33:29 <Saizan__> ?quote fromIntegral
18:33:30 <lambdabot> forall a b. (Integral a, Fractional b) => [a] -> b
18:33:30 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
18:33:36 * SamB_XP is used to the computers at school, where everything disappears when you reboot
18:33:52 <BMeph> Yay, orbitz! ;p
18:33:57 <orbitz> is fromIntegral the magic bullet for every situation
18:33:59 <orbitz> hey BMeph
18:34:12 <Saizan__> sometimes you need realToFloat
18:34:15 <lispy|web> orbitz: also see above that I used genericLength
18:34:15 <SamB_XP> orbitz: it doesn't convert a Double to an Integer
18:34:19 <lispy|web> :t genericLength
18:34:20 <lambdabot> forall b i. (Num i) => [b] -> i
18:35:02 <Saizan__> ?type \l -> sum l / genericLength l -- if you already have Fractionals in the list
18:35:03 <lambdabot> forall a. (Fractional a) => [a] -> a
18:35:11 <BMeph> orbitz: Just wanted to let you know: 'sum l / length l' is DOIN IT RONG!!!!!11!!1!!!1ichi111!
18:35:30 <lispy|web> BMeph: nice use of ichi
18:35:53 <orbitz> what is doin it right?
18:36:02 <BMeph> lispy|web: Considering your trip, I thought you'd like it. :)
18:36:09 <lispy|web> orbitz: I showed you :)
18:36:13 <lispy|web> :t \l -> fromIntegral (sum l) / genericLength l
18:36:15 <lambdabot> forall a b. (Integral a, Fractional b) => [a] -> b
18:36:20 <orbitz> oh ok, i though tmaybe BMeph had another idea in mind
18:36:28 <benmachine> :t sum
18:36:33 <lambdabot> forall a. (Num a) => [a] -> a
18:36:35 <BMeph> orbitz: ...yeah, what lispy|web said (again!)
18:36:44 <benmachine> you don't need to fromIntegral sum do you?
18:36:49 <orbitz> BMeph: odn't make me karate chop you, i will!
18:36:59 <orbitz> :t length
18:37:01 <lambdabot> forall a. [a] -> Int
18:37:07 <Saizan__> benmachine: depends on the type of the input list
18:37:21 <benmachine> Saizan__: oh, yeah I see
18:37:28 <orbitz> input list can be any numeric type, i want to make sure output is a Fractional
18:38:02 <Saizan__> if you use fromIntegral an sum l you force it to be Integral, if you don't you force it to be Fractional
18:38:18 <Saizan__> s/an/on/
18:38:36 <Saizan__> where it = the numeric type
18:38:36 <lispy|web> :t sum
18:38:37 <lambdabot> forall a. (Num a) => [a] -> a
18:38:40 <BMeph> :t realToFrac
18:38:42 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
18:38:52 <orbitz> is Fractional == float?
18:39:04 <orbitz> well i guess that i sorly phrased
18:39:09 <BMeph> @instances-importing Fractional
18:39:11 <lambdabot> Double, Float
18:39:11 <orbitz> Fractional is a typelcass right?
18:39:12 <Saizan__> ?instances Real
18:39:13 <lambdabot> Double, Float, Int, Integer
18:39:31 <Saizan__> oh, you could use realToFrac then
18:39:36 <BMeph> orbitz: Right. :)
18:40:29 <Saizan__> ?src Real
18:40:30 <lambdabot> class  (Num a, Ord a) => Real a  where
18:40:30 <lambdabot>     toRational      ::  a -> Rational
18:40:31 <orbitz> what is the emacs key combo to line up ='s?
18:40:40 * BMeph things 'realToFrac' would be a great name for a gossip show-within-a-show on "Caprica." ;)
18:40:46 <BMeph> *thi8nks
18:40:47 <byorgey> orbitz: M-x align-regexp
18:40:52 * BMeph sighs
18:40:56 <ray> C-power button C-unplug computer
18:41:07 <orbitz> hrm i thought Haskll mode had a shorter key combo
18:41:16 <byorgey> orbitz: oh, maybe it does, I don't know
18:41:35 <byorgey> I have C-x a r  bound to it myself
18:41:36 <lispy|web> doesn't emacs suggest the keybinding if it's bound?
18:41:53 <lispy|web> If not, get a more reason emacsen or check your .emacs :)
18:42:49 <byorgey> yes, it should =)
18:43:14 <orbitz> byorgey: i think this is different judging by the haskell mode wiki page
18:43:21 * benmachine doesn't line up =s anyway
18:43:35 <orbitz> i have a bunch of assignment sin a where clause and i want al lthe ='s to be in teh same oclumn
18:44:28 <BMeph> So, is there a generally accepted performance ratio, where two systems (PLs, or otherwise) can be called "competitive" with each other?
18:44:36 <lispy|web> orbitz: a nobel goal to be sure.  Sadly not what I've tried to use emacs for.  I don't typically find the emacs haskell-mode to be very, ahem, smart.  so I tend to do my vertical alignment manually in Haskell :(
18:45:01 <orbitz> ah
18:45:11 <orbitz> drats wish i could remember the ky combo, it was quite handy
18:45:26 <byorgey> orbitz: assignment sin, eh?  for your penance, you must write 100 times "I will not mutate state"
18:45:43 <BMeph> From the HWiki: "# C-c C-= inserts an = sign and lines up type signatures and other pattern matches nicely.
18:45:43 <BMeph> "
18:46:13 <orbitz> > cycle ["I will never mutate state"]
18:46:15 <lambdabot>   ["I will never mutate state","I will never mutate state","I will never muta...
18:46:18 <orbitz> what next byorgey ?
18:46:20 <orbitz> :)
18:46:21 <lispy|web> BMeph: I don't think you could define a ratio like that.  But, I often hear people say, "Well, I got it to within a factor of 2 of C which was good enough..."
18:46:48 <byorgey> orbitz: that's all. just don't do it again! ;)
18:46:52 <orbitz> haha
18:48:27 <lispy|web> BMeph: for one, when performance is king, you just need need need it and the goal is to reduce the ratio as much as possible.  Other times, the programmer productivity is often more important so you just take the first correct thing you get and deal with the performance later if it's an issue.
18:48:33 <byorgey> BMeph: 4.39 is widely recognized as the maximum performace ratio for competitiveness.
18:48:50 <oDric_oClumns> lispy|web: Hm, okay. That may explain (part of) the troll-fest on reddit yesterday. :)
18:50:34 <oDric_oClumns> byorgey: 4.39, eh? That's an interesting breakpoint... :)
18:51:01 <lispy|web> oDric_oClumns: just understand that 73.5% of all statistics are made up on the spot
18:51:08 <SamB_XP> byorgey: ratio between what and what ????
18:51:14 <lispy|web> or was it 89.4?
18:53:17 <Cale> hmm, I wonder what the heck is going on now...
18:53:50 <Cale> The unlambda plugin still isn't working, even though the unlambda program itself works, and lambdabot appears to be running it the same way it runs the bf interpreter...
18:53:54 <oDric_oClumns> I like this quote: "Actually nature is more object oriented than functional. When a molecule is changed, it actually changes. " Apparently, this guy has access to destructive-update chemicals - Philosopher's Stone, here we come! ;p
18:54:01 <Cale> @unlambda `r```````````.H.e.l.l.o. .w.o.r.l.di
18:54:02 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
18:54:48 <Cale> oh, maybe it should check whether the handle has closed itself before trying to close it
18:54:59 <Cale> unlambda knows when the input is over
18:56:43 <Orclev> @seen tehgeekmeister
18:56:44 <lambdabot> Unknown command, try @list
18:56:45 <byorgey> SamB_XP: you mean you don't know!? I'm surprised.
18:56:47 <Orclev> hmm
18:57:08 <SamB_XP> byorgey: between head and ass?
18:57:21 <SamB_XP> keyboard and chair, maybe ?
18:57:27 <lispy|web> But I don't even know where my I left my donkey
18:57:40 <SamB_XP> lol
18:57:45 <Orclev> PEBKAC?
18:57:57 <SamB_XP> that's okay, you just need the ratio between it and the head of the trail
18:57:57 <lispy|web> REBKAC -- ratio exists...
18:58:29 <lispy|web> :t \xs -> head xs / tail xs
18:58:30 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
18:58:30 <lambdabot>       Expected type: a
18:58:30 <lambdabot>       Inferred type: [a]
18:58:38 <lispy|web> SamB_XP: that's a type error
18:58:48 <lispy|web> oh you said, trail
18:59:03 <SamB_XP> hehehehehe
18:59:20 <jekor> Is there a way to get GHC to ignore lines that start with #? I have a literate Haskell file that uses them in a LaTeX verbatim environment, and GHC is complaining about lexical errors.
18:59:31 <oDric_oClumns> Eh, I thought he said "troll". ;p
18:59:32 <SamB_XP> :t ?donkey / head (tail ?xs)
18:59:33 <lambdabot> forall a. (?donkey::a, ?xs::[a], Fractional a) => a
19:00:00 <lispy|web> jekor: it's actually CPP that is complaining I believe
19:00:01 <Orclev> jekor: I think the literate haskell latex format has a way of doing a non-parsed verbatim
19:00:30 <jekor> Hmm...hadn't tried it with a multi-line verbatim. I'll give it a try. Thanks.
19:02:39 <Orclev> :t donkey
19:02:43 <lambdabot> Not in scope: `donkey'
19:02:51 <Orclev> hmm... wtf is donkey?
19:03:04 <lispy|web> > donky `asTypeOf` onion
19:03:07 <lambdabot>   Not in scope: `donky'Not in scope: `onion'
19:03:21 <aavogt> :t ?someImplicitVariableOrclev
19:03:22 <lambdabot> forall t. (?someImplicitVariableOrclev::t) => t
19:03:30 <Orclev> ah
19:03:49 <lispy|web> :t ?donkey `asTypeOf` ?onion
19:03:50 <lambdabot> forall a. (?onion::a, ?donkey::a) => a
19:04:10 <aavogt> :t asTypeOf `asTypeOf` asTypeOf
19:04:11 <lambdabot> forall a. a -> a -> a
19:04:15 <Orclev> pretty sure that's supposed to be ?ogre, not ?donkey
19:04:23 <lispy|web> oh, good catch
19:04:27 <SamB_XP> Orclev: lol
19:04:42 <SamB_XP> so, what's the function to peel off a layer ?
19:04:56 <lispy|web> :t tail
19:05:00 <lambdabot> forall a. [a] -> [a]
19:05:07 <Orclev> not sure but it does: error "cry"
19:05:30 <orbitz> hrm i'm tryign ot writ ea func to calc stdDev, it's type is : (Floating b, Integral b) => [b] -> b but when i try to call it iwth a [Double] I get, No instance for (Integral Double).  what am i missing?
19:05:37 <camio> I'm curious, does implicit variables have any uses? I haven't seen them in the wild as of yet.
19:05:49 <SamB_XP> camio: basically, just that
19:06:02 <aavogt> camio: be thankful of that
19:06:05 <SamB_XP> we haven't found any actual use for them besides calculating types
19:06:37 <Orclev> orbitz: Double isn't a integral?
19:06:43 <SamB_XP> I've tried them in the past, but in the end I came to the conclusion that it was saner to use Reader monads ...
19:07:12 <oDric_oClumns> SamB_XP: Why not Reader Comonads? ;)
19:07:25 <SamB_XP> oDric_oClumns: boov boov to you!
19:07:33 <orbitz> Orclev: and it's not a Floating?
19:07:59 <oDric_oClumns> SamB_XP: Aw, don't mind me, I'm a little mixed up... ;p
19:08:02 <c_wraith> That signature doesn't mean either Floating or Integral.  It means both.
19:08:04 <Orclev> orbitz: the way that's written implies both I believe, that is, it must be both a float and a integral
19:08:36 <SamB_XP> oDric_oClumns: btw, boov boov is a really really ancient reference to some conversation that used to be archived in the humour section of hawiki
19:08:37 <c_wraith> It's a pretty nonsense signature.  I don't know why there's an Integral constraint
19:08:45 <lispy|web> orbitz: Integral is a type class for ints and int-like things.
19:08:45 <lispy|web> orbitz: Probably the 'fromIntegral (sum l)" bit is doing the wrong thing.  Try removing that 'fromIntegral' as see if things improve
19:08:45 <lispy|web> :t (fromIntegral . sum, sum)
19:08:47 <aavogt> orbitz: are you dividing by (length someList)?
19:08:47 <camio> I remember when they came out I had a lot of trouble seeing where I would use them.
19:08:47 <aavogt> I don't think there are any types which satisfy Floating and Integral
19:08:48 <lambdabot> forall b a a1. (Integral a, Num b, Num a1) => ([a] -> b, [a1] -> a1)
19:08:48 <aavogt> you have to put fromIntegral in the right spots..
19:08:54 <orbitz> aavogt: genericLength
19:09:23 <Orclev> aavogt: pretty sure it's impossible to be both a float and an integral
19:09:25 <orbitz> I supposed my signature hsould be stdDev :: [Double] -> Double ?
19:09:36 <orbitz> or can i get it so it takes Integers too?
19:09:47 <c_wraith> Well, it'd be rare for the result to be an integer
19:10:34 <Orclev> orbitz: probably what you want is (Floating a) => [a] -> [a]
19:10:35 <orbitz> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3891#a3891
19:11:22 <c_wraith> I'd guess the signature should be more like Num a => [a] -> Double
19:11:59 <c_wraith> Feed it a list of Int if you like.  But the result is going to need to be a float value of some type, so it might as well be Double
19:12:22 <bos> your code is wrong.
19:12:27 <aavogt> (Num a,Floating b) => [a] -> b
19:12:34 <orbitz> how is it wrong bos?
19:12:34 <bos> look at the return type of genericLength.
19:12:59 <orbitz> bos: it returns an i, which is a Num
19:13:07 <c_wraith> :t genericLength
19:13:11 <lambdabot> forall b i. (Num i) => [b] -> i
19:13:44 <Orclev> I'm curious, why does it use [b] there rather than [a]?
19:13:48 <Orclev> arbitrary?
19:14:10 <aavogt> @src genericLength
19:14:10 <lambdabot> genericLength []    = 0
19:14:10 <lambdabot> genericLength (_:l) = 1 + genericLength l
19:14:44 <c_wraith> that *is* generic.  Written to be efficient with Natural!
19:15:44 <lispy|web> I'd assume it to be a foldr in the actual implementation
19:15:58 <c_wraith> > genericLength [1..] > (55::Natural)
19:16:00 <lambdabot>   True
19:16:19 <lispy|web> er wait, maybe I wouldn't
19:16:19 <aavogt> c_wraith: how can one go from Num a => a to Double, while keeping any fractional part that could exist in a?
19:16:28 <dolio> foldr would be the same.
19:16:41 <SamB_XP> Orclev: I guess there was an (a) but it fell out ?
19:16:48 <lispy|web> :t folder (const (+1)) 0
19:16:49 <lambdabot> Not in scope: `folder'
19:16:53 <lispy|web> :t foldr (const (+1)) 0
19:16:54 <lambdabot> forall a a1. (Num a) => [a1] -> a
19:16:55 <orbitz> i modified it to be http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3891#a3892
19:16:58 <byorgey> Orclev: the [b] is essentially arbitrary -- forall b. [b] is the same as forall a. [a].  but ghc tries to use names similar to the ones given in declared type signatures, if it can.
19:17:03 <c_wraith> :t realToFrac
19:17:05 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
19:17:07 <orbitz> and now it's not a fan of compiling
19:17:12 <c_wraith> @instances Fractional
19:17:13 <lambdabot> Double, Float
19:17:16 <byorgey> Orclev: which is probably why it uses [b] in this specific case.
19:17:25 <c_wraith> By calling realToFrac, aavogt
19:17:43 <c_wraith> @instances Real
19:17:44 <lambdabot> Double, Float, Int, Integer
19:18:17 <camio> @instance Monoid
19:18:17 <lambdabot> Maybe you meant: instances instances-importing
19:18:21 <c_wraith> You might lose some precision.  That's happens when calculating with computers.  *shrug*
19:18:24 <aavogt> c_wraith: surely it doesn't have to go through Rational?
19:18:33 <camio> @instance Data.Monoid
19:18:34 <lambdabot> Maybe you meant: instances instances-importing
19:18:45 <aavogt> @src realToFrac
19:18:45 <lambdabot> realToFrac = fromRational . toRational
19:18:50 <camio> @instances Data.Monoid
19:18:51 <lambdabot> Couldn't find class `Data.Monoid'. Try @instances-importing
19:18:58 <camio> @instances Monoid
19:18:59 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:19:01 <c_wraith> @instances Rational
19:19:02 <lambdabot> Couldn't find class `Rational'. Try @instances-importing
19:19:14 <aavogt> @type toRational
19:19:14 <lambdabot> forall a. (Real a) => a -> Rational
19:19:38 <c_wraith> Oh.  Rational is actually a concrete type
19:19:56 <lispy|web> :t 22/7
19:19:57 <lambdabot> forall t. (Fractional t) => t
19:20:02 <lispy|web> :t 22%7
19:20:04 <lambdabot> forall t. (Integral t) => Ratio t
19:20:26 <lispy|web> I don't think Rational is a type, I think Ratio is
19:20:45 <aavogt> > undefined ::Rational
19:20:46 <lambdabot>   * Exception: Prelude.undefined
19:20:50 <aavogt> > undefined ::Ratio
19:20:51 <lambdabot>   `GHC.Real.Ratio' is not applied to enough type arguments
19:20:51 <lambdabot>  Expected kind `?'...
19:20:56 <lispy|web> Hmm...yes but the type of toRational seems to say otherwise
19:20:58 <aavogt> > undefined ::Ratio Int
19:20:59 <c_wraith> the type of toRational pretty much requires that Rational be a concrete type
19:21:00 <lambdabot>   * Exception: Prelude.undefined
19:21:10 <orbitz> I think i have to be more specific than 'Num a' in with stdDev since i tis uing **?
19:21:28 <Cale> Man, this is so strange... the unlambda plugin even works from inside ghci, but in a compiled lambdabot, I get a resource vanished exception from hClose somewhere.
19:21:30 <c_wraith> No, orbitz.  You just need to convert it earlier.
19:21:40 * Cale cleans everything and rebuilds
19:21:49 <lispy|web> Cale: that bad, huh?
19:22:21 <lispy|web> I recall Duncan giving a talk where he basically said anytime you have to clean && rebuild, your build system is broken
19:22:22 <orbitz> c_wraith: how do i determine where?
19:22:39 <c_wraith> orbitz:  where it's necessary to do the calculations you need.
19:22:54 <Cale> Well, that didn't help, so Duncan is safe for now ;)
19:23:35 <orbitz> c_wraith: i'm afraid I'm a bit confused about how the numeric types are laid out in Haskell, can you be any more specific about how to debug this?
19:24:42 <c_wraith> let avg :: (Num a, Floating b) => [a] -> b ; avg as = sum as / genericLength as in avg [1..3]
19:24:52 <c_wraith> > let avg :: (Num a, Floating b) => [a] -> b ; avg as = sum as / genericLength as in avg [1..3]
19:24:56 <lambdabot>   Could not deduce (GHC.Real.Fractional a)
19:24:56 <lambdabot>    from the context (GHC.Num.Num a...
19:25:16 <c_wraith> :t (/)
19:25:18 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:25:31 <c_wraith> @src Num
19:25:32 <lambdabot> class  (Eq a, Show a) => Num a  where
19:25:32 <lambdabot>     (+), (-), (*)           :: a -> a -> a
19:25:32 <lambdabot>     negate, abs, signum     :: a -> a
19:25:32 <lambdabot>     fromInteger             :: Integer -> a
19:25:39 <lispy|web> ah ha, so perhaps my suggestion to use genericLength was not a good one here
19:25:55 <c_wraith> @src Rational
19:25:56 <lambdabot> type Rational = Ratio Integer
19:26:09 <c_wraith> @src Ratio
19:26:09 <lambdabot> data (Integral a) => Ratio a = !a :% !a
19:26:18 <aavogt> > let avg :: (Real a, Floating b) => [a] -> b; avg as = realToFrac (sum as) / genericLength as in avg [1..50]
19:26:19 <lambdabot>   25.5
19:26:48 <c_wraith> There's apparently no broad conversion function from Num to anything.
19:27:11 <lispy|web> Num is a ring, so their can't be
19:27:17 <ddarius> unsafeCoerce
19:27:23 <lispy|web> You can't just upgrade from a Ring to a Field, for example
19:27:24 <orbitz> ok, so would you suggest I work in Double's all the time since that is what my functions will be outputting? or can I do something more generic?
19:27:34 <c_wraith> ddarius, that sounds more like a crash than a conversion
19:27:57 <c_wraith> you can look at aavogt's example
19:28:04 <c_wraith> You can operate on Real, at least
19:28:04 <lispy|web> ?instances Fractional
19:28:05 <lambdabot> Double, Float
19:28:08 <orbitz> what is a Real?
19:28:15 <c_wraith> @src Real
19:28:16 <lambdabot> class  (Num a, Ord a) => Real a  where
19:28:16 <lambdabot>     toRational      ::  a -> Rational
19:28:17 <lispy|web> ?instances Real
19:28:18 <lambdabot> Double, Float, Int, Integer
19:28:26 <orbitz> ok
19:28:31 <lispy|web> orbitz: Real or Fractional is probably the way to go here
19:28:32 <Cale> You can upgrade from a ring to a field by taking the field of fractions ;)
19:28:33 <SamB_XP> orbitz: Haskell doesn't support Real, silly!
19:28:56 <SamB_XP> only constructive reals ;-P
19:29:03 <lispy|web> Cale:  I prefer the field of dreams :)
19:29:25 * Cale grumbles. This lambdabot bug is totally unreasonable.
19:29:46 <c_wraith> Man.  The numeric types in haskell really are a *complete* mess, aren't they?
19:29:52 <c_wraith> Err, the typeclasses, that is.
19:30:00 <lispy|web> Cale: could it be 1) an issue with the GHC on the linode (I had to build it myself to remove split-objs) 2) an issue with out of memory?
19:30:06 <Cale> c_wraith: They're not *so* bad.
19:30:20 <Cale> c_wraith: Num has a bit too much in it. Real has a silly name.
19:30:28 <lispy|web> c_wraith: they are pretty far away from mathematical standards but better than many PLs
19:30:40 <Cale> c_wraith: But apart from that, they are very practical.
19:31:17 <Cale> I don't think that the standard mathematical hierarchy makes much sense in the context of dealing with things like Floats
19:31:42 <camio> I personally like Scheme's idea of separating exact and inexact numbers.
19:31:59 <c_wraith> Most PLs just overload operators, and provide no attempt at a unifying types.  That's relatively sane, since at least you know what you're getting into.
19:32:42 <c_wraith> It's not clean, but it's very practical.
19:32:55 <Orclev> does someone have a few minutes to look over an idea I had and tell me if/why it's a stupid idea?
19:33:01 <copumpkin> NO!
19:33:13 <c_wraith> YES!  copumpkin does
19:33:16 <copumpkin> :O
19:33:29 * copumpkin is implementing silly matrix stuff in agda
19:33:34 <orbitz> sweet mama zeus i go tit to compiel at least!
19:33:51 <Cale> @unlambda `r```````````.H.e.l.l.o. .w.o.r.l.di
19:33:56 <lambdabot>   Hello world
19:34:00 <jekor> When I add a cabal dependency for lhs2tex, it compiles and installs it in ~/.cabal/bin and then it complains that it can't find it. ~/.cabal/bin is in my $PATH. What am I missing?
19:34:00 <Cale> hooray!
19:34:08 <Orclev> ... mama zeus... did someone screw with the greek god genders whil I wasn't looking
19:34:09 <orbitz> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3891#a3893
19:34:17 <orbitz> it's probably mroe verbose than it needs to be
19:34:19 <orbitz> but it appears to work
19:34:20 <orbitz> thanks!
19:34:21 <c_wraith> zeus is all-powerful.  he can be a mother if he likes
19:34:35 <jekor> Is there some way to diagnose the failure like with config.log for GNU autoconf?
19:34:44 <c_wraith> haha.  He's short of all powerful.  But being the single parent of Athena, you can call him a mother.
19:34:44 <orbitz> c_wraith: a sweet mother
19:34:52 <copumpkin> orbitz: have you seen bos' fast statistics library?
19:34:59 <Orclev> anyway, http://github.com/orclev/versioningidea
19:35:12 <lispy|web> Cale: what was the solution?
19:35:17 <orbitz> copumpkin: no. I'm in a statistics class right now and i'm just implementing the stuff on my own to learn them
19:35:24 <copumpkin> ah ok :)
19:36:06 <Cale> lispy|web: I think I might have been testing incorrectly for a while. I think the solution was when I added an exception handler to the hClose in Lambdabot.Process
19:36:08 <lispy|web> bos: oh that reminds me.  Did you consider or look at the probability distribution monad?
19:36:51 <Cale> (If the pipe is broken, we have nothing to worry about, it usually just means that the other process decided it had received enough input on its own.)
19:37:10 <c_wraith> let x = (3::Natural) in realToFrac x / 5
19:37:13 <bos> lispy|web: i'm aware of it, but haven't done anything with it.
19:37:17 <c_wraith> > let x = (3::Natural) in realToFrac x / 5
19:37:20 <lambdabot>   0.6
19:37:22 <Orclev> I've always hated statistics... it always seemed a hair short of complete BS most of the time... about the only use is defining margins of error and MTBF
19:37:25 <c_wraith> man, I'm failing at my leading >s today
19:37:44 <orbitz> Orclev: let's not forget gambling!
19:37:54 <lispy|web> bos: cool, it was made by a friend of mine while he was in grad school.  I've never used it myself, but when I saw your library I wondered if it had applicability.
19:38:47 <copumpkin> lispy|web: eric kidd?
19:38:56 <lispy|web> No, I'm thinking of a different library
19:38:58 <copumpkin> ah
19:39:01 <c_wraith> gambling really only needs probability, and then very basic statistics.  Mean, variance, and stddev get you most everywhere.
19:39:17 <ddarius> Read Jaynes.
19:39:22 <lispy|web> copumpkin: http://www.kolls.net/cv/
19:40:05 <lispy|web> bos: http://www.kolls.net/cv/mythesis.pdf
19:40:32 <lispy|web> I guess he made a DSL for describing probability disributions, particularly for people in the applied sciences
19:40:46 <Orclev> what's the lambdabot command for last seen?
19:40:48 <lispy|web> I always thought it might be cool to use it in non-scientific simulations like game-dev
19:40:52 <lispy|web> ?seen Orclev
19:40:52 <lambdabot> Unknown command, try @list
19:40:59 <lispy|web> ?list
19:40:59 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:41:18 <lispy|web> Orclev: I think maybe it's just broken
19:41:29 <lispy|web> it sohuld be '@seen' or '?seen'
19:41:33 <copumpkin> anyone know of a simple pure haskell matrix inverse function on list-of-lists
19:41:35 <copumpkin> ?
19:41:38 <Orclev> looks that way
19:42:12 <lispy|web> copumpkin: sure, transpose.  Oh but that only works on matricies with a special property, the name of which escapes me.
19:42:22 <ddarius> Orthogonal
19:42:25 <copumpkin> lol
19:42:33 <c_wraith> Identity
19:42:41 <c_wraith> wait
19:42:48 <blackh> Queen size?
19:42:49 <c_wraith> id can transpose identity matrices!
19:42:51 <copumpkin> identity is orthogonal
19:43:08 <c_wraith> in fact, id can transpose any symmetric matrix!
19:43:16 <copumpkin> but really :P
19:43:28 <Cale> @unlambda ```s``s``sii`ki`k.*``s``s`ks``s`k`s`ks``s``s`ks``s`k`s`k. ``s`k`sikk`k``s`ksk
19:43:28 <lambdabot>    * * ** *** ***** ******** ************* ********************* ************...
19:43:30 <lispy|web> ddarius: ah, see I was thinking it had to be Hermetian(sp?).  Really, just orthogonal is enough?
19:43:45 <ddarius> lispy|web: Hermitian applies to matrices of complex numbers.
19:43:58 <copumpkin> lispy|web: orthogonal is defined as transpose = inverse isn't it?
19:44:05 <ddarius> It's the "generalization" of orthogonality, but in that case you use the complex transpose.
19:44:09 <copumpkin> or maybe not by definition
19:44:23 <lispy|web> ddarius: aaah
19:44:34 <lispy|web> It's been years since I had a nice lin alg class
19:44:36 <lispy|web> I miss it
19:44:43 <Cale> self-adjoint
19:44:45 * ddarius has never had a linear algebra class.
19:45:26 <lispy|web> ddarius: ah, I found it to be a fun topic, but since I don't need it for anything I tend to forget it
19:45:37 <Cale> <Av,w> = <v,Aw> is the important bit :)
19:45:44 <CESSMASTER> you need linear algebra for everything what are you talking about
19:46:09 <ddarius> Hmm...  I find exactly the opposite.  I've often seen linear algebra presented in a very boring, mechanistic manor and I use it all the time.
19:46:12 * lispy|web uses the spectral theorem to make dinner
19:47:03 <ddarius> lispy|web: Learn the Geometric Algebra relationships for common Linear Algebra operations and it becomes much easier to remember or rederive.
19:47:40 <jperras> linear algebra is the fundamental building block of pretty much everything
19:47:40 <jperras> most of physics, large swaths of mathematics, a big chunk of computer science
19:48:04 <copumpkin> :o
19:48:21 <Orclev> I've probably used it before but I've never had a class on "linear algebra" so far as I know
19:50:22 <roconnor> GeometricAlgebra++
19:52:29 <lispy|web> I think I took a class in Geometric algebra once.  Is that the area which physiscists now rely on for coordinate systems and whatnot?
19:57:07 <jperras> lispy|web: it's used in a few fields
19:57:41 <jperras> relativity uses it quite heavily
19:57:44 <jperras> (general relativity)
19:58:13 <Orclev> Vectors for fun and profit!
19:59:05 <jperras> GR needs a lot of notational & mathematical tools to be comprehensible
19:59:06 <Orclev> copumpkin: did you ever look at that link I posted, or were you busy?
19:59:15 <copumpkin> NO!
19:59:24 <copumpkin> :)
19:59:34 <SamB_XP> copumpkin: neither ???
19:59:45 <Orclev> lol
20:02:03 <copumpkin> will check it in a bit :)
20:02:23 <Orclev> copumpkin: k, thanks
20:03:04 <ivanm> so, what caused lambdabot to crash this time, now that the troublesome @seen plugin is no longer working?
20:05:15 <lispy|web> ivanm: lambdabot just moved servers
20:05:22 <ivanm> ahhhh
20:05:35 <ivanm> so freeciv is no longer on lambdabot's server? :p
20:05:56 <lispy|web> hehe
20:06:19 <lispy|web> forensics that we've done doesn't indicate a compromise afterall
20:06:27 <lispy|web> We're still ditching that server for other reasons though
20:07:03 <copumpkin> @pl is still DOSable though
20:07:03 <lambdabot> is still DOSable though
20:07:07 <copumpkin> see!
20:07:31 <Orclev> lispy|web: server got hacked?
20:08:25 <lispy|web> Orclev: we thought maybe, but it looks like it may have been hardware
20:08:31 <lispy|web> or some other fluk
20:09:25 <ivanm> awww
20:09:31 <ivanm> the freeciv story was better :(
20:13:07 <ddarius> Rule number one of story telling: Don't let reality get in the way of a good story.
20:14:52 <ivanm> heh
20:18:36 <ray> so there i was, surrounded by killer suits
20:18:42 <lispy|web> The second rule of story club is ...
20:18:56 <dolio> Oh man, it's ddarius.
20:19:01 <oDric_oClumns> lispy|web: What the fluk?!? :)
20:19:23 <copumpkin> he's back!
20:19:44 <lispy|web> but not in #haskell-blah
20:19:56 <lispy|web> ddarius: were you deployed fore a while or something?
20:20:10 <ivanm> "deployed"? is ddarius in the military or something?
20:20:51 <shapr> ddarius: hiya! long time no see!
20:22:38 <ray> the first rule of ddarius club is that you don't talk about deployment
20:23:13 <ivanm> ray: heh
20:32:23 <Orclev> anyone happen to know if tehgeekmeister has been on today?
20:34:09 <aavogt> preflex_: seen: tehgeekmeister
20:34:15 <aavogt> preflex_: seen tehgeekmeister
20:34:15 <preflex_>  tehgeekmeister was last seen on #haskell 1 day, 3 hours, 39 minutes and 47 seconds ago, saying: thanks everyone for helping!
20:34:44 <Orclev> ah, didn't realise we had a second bot in here
20:35:14 <ivanm> anyone know why someone should/would use the new JoinList package rather than DList?
20:35:53 <copumpkin> ivanm: nope,
20:36:02 <copumpkin> ivanm: but then again I don't know why we have a dstring pacakge too :P
20:36:10 <ivanm> so no-one knows, or you don't know? :p
20:36:13 <ivanm> copumpkin: heh, true
20:36:21 <copumpkin> ivanm: if I don't know, nobody can know!
20:36:54 <lispy|web> We need a GenericString, or GString package too.
20:36:59 <copumpkin> Orclev: seems like an interesting idea, but sounds like a lot more work for the library maintainer
20:37:23 <dolio> Second?
20:37:42 <Orclev> copumpkin: yes but it's based on the idea that in a traditional approach your forcing the consumer of a library to keep up with something they have no control over, that is the versions of libraries
20:37:49 <copumpkin> Orclev: true
20:37:55 <copumpkin> Orclev: run it by dcoutts maybe?
20:38:02 <ivanm> lispy|web: then make GenericString use GenericList, which uses GenericSequence, which uses GenericStructure, which uses...
20:38:04 <ivanm> ;-)
20:38:11 <Orclev> copumpkin: who better to decide if a change breaks compatability than the person making the change?
20:38:20 <sjanssen> ivanm: check out the implementation, they're rather different animals
20:38:35 <ivanm> sjanssen: yeah, I had a quick look
20:38:57 <ivanm> but I was wondering if anyone had a known reason for picking one over the other
20:39:07 <copumpkin> I remember FMList seemd rather interesting
20:39:24 <ivanm> or even rather than Sequence (because Sequence isn't as nice to append lists to?)
20:39:50 <Orclev> copumpkin: it's more work upfront or the library creator, but in practice a lot would be handled by the tools, and most of the time if you're making a change that breaks something you should probably be aware of it and update as necessary
20:40:01 <Orclev> s/or/for/
20:40:21 <sjanssen> ivanm: JoinList seems to be much more simple, so it probably has better constant factors for simple operations
20:40:39 <Orclev> copumpkin: see anything obviously stupid in the idea?
20:40:44 <sjanssen> JoinList's append is O(1), Seq's is logarithmic
20:40:45 <copumpkin> Orclev: nope
20:41:11 <copumpkin> Orclev: maybe the types of functions can form an implicit version too?
20:42:27 <Orclev> copumpkin: yes and no, that's something a tool should be able to check of course, but it would still be up to the maintainer to insure the annotation is updated (and/or their editor might do it automaticaly when it detects a change in signature)
20:43:19 <Orclev> copumpkin: the goal is to be able to manage versions with nothing but the .compat files which would be autogenerated by utilities
20:43:43 <sjanssen> Orclev: what is a .compat file?
20:44:05 <dolio> You can construct situations where JoinList will have better behavior than DList.
20:44:05 <Orclev> sjanssen: part of an idea I had: http://github.com/orclev/versioningidea
20:44:28 <dolio> Although the opposite is also true.
20:44:45 <ddarius> Yuck $ Pure Nothing
20:44:55 <Orclev> need to update the README on that to state the rational I think
20:45:20 <lispy|web> rationale or rational?
20:45:42 <copumpkin> +
20:45:42 <copumpkin> e
20:46:11 <Orclev> rationale
20:46:21 <Orclev> I think
20:46:34 <copumpkin> certainly
20:46:37 <sjanssen> Orclev: that sounds like a really big headache
20:46:54 <sjanssen> Orclev: how many years of compatibility notes to I have to keep in my source code?
20:47:10 <ray> 7
20:47:22 <Orclev> sjanssen: should't need years, you start with the current version, and as you make changes you should note what breaks
20:47:48 <copumpkin> I think we should all just move to agda
20:47:57 <copumpkin> and specify our behavior completely in the types
20:48:16 <Orclev> sjanssen: for most functions there probably insn't such a thing as a partial compatability, so that's pretty straightforward
20:48:24 <ivanm> sjanssen: true
20:48:34 <Orclev> sjanssen: for haskell, in general if the type signature changes, it breaks compatability, otherwise it's probably fine
20:51:23 <Orclev> sjanssen: I present to you the opposite problem, I've got a program written for library foo v2.4.6, what versions is it compatible with? Do I need to go download every version that's been released and check against all of them?
20:52:12 <sjanssen> Orclev: good libraries will have a versioning policy, where major changes only happen in major releases
20:52:24 <lispy|web> Orclev: sounds like you fit in the autoconf camp
20:52:45 <dancor> do ppl approve of: having (sharedFunc :: Bool -> a -> [Either b c]; sharedFunc allowRightsToHappen a = ...; f = sharedFunc True; g = map fromLeft $ sharedFunc False)?
20:52:55 <sjanssen> lispy|web: what Orclev suggests isn't exactly autoconf either
20:53:35 <Orclev> lispy|web: the idea is to push the tracking of compatability down to where the changes are actually happening, that is in the libraries themselves
20:53:39 <dancor> i'm risking fromLeft fataling on some coding errors (and doing something that wouldn't work with dependent types..) in return for code reuse
20:55:06 <dancor> also you could (_maybe_) imagine that boxing and unboxing the Eithers in g could be some pref-hit
20:56:00 <lispy|web> Orclev: so it's unit based versioning instead of library based?
20:57:06 <Orclev> lispy|web: yes, more or less
20:57:42 <Orclev> lispy|web: little more involved than that, but you can think of it as kind of like that
20:58:17 <aavogt> is there a binding of a function like this: http://www.gnu.org/software/gsl/manual/html_node/Evaluation-of-Interpolating-Functions.html
20:58:19 <Orclev> lispy|web: it more or less takes normal dependency tracking and flips it 180
20:58:28 <aavogt> if it isn't in hmatrix
20:58:36 <aavogt> then I have to ffi to it myself?
20:59:40 <ddarius> dancor: You could potentially make it safer and still keep the implementation sharing.
21:00:40 <sjanssen> Orclev: I think the issue is that software systems are complex.  After several edits over time, I might not know that behavior has changed
21:01:19 <copumpkin> dependent types to the rescue!
21:01:27 <dancor> ddarius: you mean that will sometimes be possible and sometimes not?
21:03:00 <ddarius> dancor: Sometimes it will be worth the effort and sometimes not.  Also, oftentimes there are better ways.
21:03:11 <Orclev> sjanssen: well, that's part of the reason it tracks things at the function level as well as the module level, presumably you should know when making a change to a function would modify it's output or input in a way inconsistent with previous versions
21:03:25 <dancor> my case is combining the parsing logic for comma-delimited parameter lists of three forms:  (a, b, c)  (a, b, c,)  (a, , c)
21:04:02 <ddarius> dancor: For this particular example, you could do something like sharedFuncFalse :: a -> [Either b Void]; sharedFuncFalse = sharedFunc False
21:04:48 <sjanssen> Orclev: does a bug fix change compatibility?  Say 'f 0' goes from crashing to not crashing
21:05:12 <Orclev> sjanssen: no, it's changes of the input or output inconsistent with the intent of the function
21:05:29 <Orclev> sjanssen: or format, which would presumably be a type change
21:06:59 <dancor> my plan is to have allowTrailingComma and allowEmptyArgs Bools and return the most general type and then do dependent-type-no-nos in the three wrapper functions
21:08:00 <dancor> it sounds like you would recommend a different plan
21:08:09 * dancor thinks about life
21:08:23 <ddarius> My first reaction is to pass in functions to handle the situations.
21:08:33 <ddarius> But that's operating on too little information.
21:10:01 <copumpkin> > let fibs = fix ((0:) . scanl (+) 1) in scanl1 (+) fibs
21:10:02 <lambdabot>   [0,1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596,2583,4180,6764,10945,177...
21:10:13 <dancor> @oeis 1 2 4 7 12
21:10:14 <lambdabot>  Fibonacci numbers - 1.
21:10:14 <lambdabot>  [0,0,1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596,2583,4180,6764,10945,17...
21:10:25 <copumpkin> > let fibs = fix ((1:) . scanl (+) 1) in scanl1 (+) fibs
21:10:26 <lambdabot>   [1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596,2583,4180,6764,10945,17710...
21:11:17 <dancor> > let fibs = fix ((1:) . scanl (+) 2) in scanl1 (+) fibs
21:11:17 <lambdabot>   [1,3,6,11,19,32,53,87,142,231,375,608,985,1595,2582,4179,6763,10944,17709,2...
21:11:23 <dancor> @oeis 1 3 6 11 19
21:11:23 <lambdabot>  Fibonacci numbers - 2.
21:11:23 <lambdabot>  [0,1,3,6,11,19,32,53,87,142,231,375,608,985,1595,2582,4179,6763,10944,17709,...
21:11:27 <dancor> mm
21:12:22 <ivanm> is there a multiset data structure available?
21:12:32 <ivanm> I'm using Set, but I then realised I need duplicates :s
21:12:45 <dancor> http://hackage.haskell.org/package/multiset
21:13:06 <ddarius> a -> Int
21:13:14 <ivanm> thanks dancor
21:13:15 <copumpkin> lol
21:13:20 <ivanm> duh, didn't think to just look on hackage :s
21:13:33 <dancor> :t show :: a -> Int
21:13:34 <lambdabot>     Couldn't match expected type `Int' against inferred type `String'
21:13:34 <lambdabot>     In the expression: show :: a -> Int
21:13:42 <dancor> i mean read.  fail
21:14:06 <dancor> :t const (4 :: Int)
21:14:07 <lambdabot> forall b. b -> Int
21:14:45 <ivanm> dancor: any idea if MultiSet.difference removes all copies of duplicates?
21:15:02 <dons> http://twitter.com/aconbere/statuses/4306774886
21:15:06 <dons> "I need a haskell marketplace for peer review. Anyone up for reviewing a little app with me
21:15:10 <dons> looking for a couple of bugs?"
21:15:31 <ivanm> heh
21:15:38 <ivanm> code reading via twitter now?
21:18:45 <dancor> ivanm: i would expect it takes (max 0 (#inA - #inB))
21:19:03 <ivanm> *nod*
21:20:11 <dancor> > Data.MultiSet.fromList "lol"
21:20:11 <lambdabot>   Not in scope: `Data.MultiSet.fromList'
21:20:19 <dancor> > MultiSet.fromList "lol"
21:20:20 <lambdabot>   Not in scope: `MultiSet.fromList'
21:20:27 <dancor> > MS.fromList "lol"
21:20:28 <lambdabot>   Not in scope: `MS.fromList'
21:20:40 <dancor> @vixen Why have you forsakk?en me?
21:20:40 <lambdabot> who's to say?
21:20:42 <ivanm> looks like lambdabot doesn't have it
21:21:27 <sohum> > launchZeMissiles
21:21:27 <lambdabot>   Not in scope: `launchZeMissiles'
21:21:31 <sohum> awww
21:21:43 <dancor> > effectivemouthwash
21:21:43 <ivanm> sohum: fake french accents aren't needed...
21:21:44 <lambdabot>   Not in scope: `effectivemouthwash'
21:21:57 <sohum> :t launchMissiles
21:21:58 <lambdabot> Not in scope: `launchMissiles'
21:22:03 <sohum> :t launchTheMissiles
21:22:04 <lambdabot> Not in scope: `launchTheMissiles'
21:22:10 <ivanm> > launchMissiles
21:22:11 <lambdabot>   This doesn't look safe...
21:22:13 <ivanm> ;-)
21:22:19 <sohum> wait, what?
21:22:29 <dancor> how about a nice game of tic-tac-toe
21:22:41 <sohum> why does it fail when I ask for its type, then?
21:22:54 <dancor> oh wait that's hard to program in haskell without a nice multidimensional data structure ;)
21:23:53 <dancor> *Main> MS.fromList "helllo" `MS.difference` MS.fromList "lo"
21:23:53 <dancor> fromOccurList [('e',1),('h',1),('l',2)]
21:23:56 <Orclev> to those few of you that might be interested, I updated the README to provide a rationale, and some more details addressing some of the questions raised earlyer
21:24:16 <sohum> :t array ((1,3),(1,3)
21:24:16 <lambdabot> parse error (possibly incorrect indentation)
21:24:18 <sohum> :t array ((1,3),(1,3))
21:24:19 <lambdabot> forall t t1 e. (Num t, Num t1, Ix t, Ix t1) => [((t, t1), e)] -> Array (t, t1) e
21:24:52 <dancor> have fun writing the slicing logic
21:25:18 <sohum> slicing logic?
21:25:26 <dancor> win detection
21:25:35 <sohum> ah
21:26:03 <dancor> you basically want hmatrix without the numeric type constraint
21:26:04 <ivanm> sohum: because I just added it ;-)
21:26:11 <ivanm> @type launchMissiles
21:26:12 <lambdabot> Doc
21:26:16 <sohum> ivanm: pffffffff
21:26:18 <sohum> ;)
21:27:02 <ivanm> :t launchMissiles
21:27:02 <lambdabot> Doc
21:27:11 <sohum> @src Doc
21:27:11 <lambdabot> Source not found. Take a stress pill and think things over.
21:27:19 <ivanm> OK, thought :t wouldn't work since it was an internal lambdabot definition
21:27:26 <ivanm> @hoogle Doc
21:27:27 <lambdabot> Text.PrettyPrint.HughesPJ data Doc
21:27:27 <lambdabot> Language.Haskell.TH.PprLib type Doc = PprM Doc
21:27:27 <lambdabot> System.Directory getUserDocumentsDirectory :: IO FilePath
21:27:31 <ivanm> sohum: the first one
21:27:36 <sohum> huh
21:27:48 <ivanm> launchMissiles = text "This doesn't look safe..."
21:28:11 <sohum> make it a putStrLn, so the type will be IO () and look scary
21:28:51 <dancor> it's brilliant
21:29:17 <ivanm> danopia`: it only deletes each one once...
21:29:21 <ivanm> sohum: and then lambdabot couldn't use it
21:29:25 <ivanm> > putStrLn "hi"
21:29:26 <lambdabot>   <IO ()>
21:29:39 <sohum> ivanm: and that's fine!
21:29:41 <ivanm> whoops...
21:29:47 <ivanm> s/danopia`/dancor/
21:29:58 <ivanm> stupid tab completion not having DWIM support :@
21:30:04 <dancor> ivanm: no it deletes them however many times
21:30:10 <ivanm> :(
21:30:29 * Raynes shudders at the sight of IO
21:30:43 <dancor> *Main> MS.toList $ MS.fromList "aaaaab" `MS.difference` MS.fromList "aabbb"
21:30:43 <dancor> "aaa"
21:30:54 <shellsage> Is this correct for a function that returns an infinite list of ones?
21:30:55 <shellsage> ones :: [Integer]
21:30:55 <shellsage> ones = 1 : ones
21:30:56 <ivanm> > text $ "for Raynes: " ++ cycle "IO! "
21:31:01 <lambdabot>   mueval: ExitFailure 1
21:31:03 <ivanm> :(
21:31:06 <ivanm> > "for Raynes: " ++ cycle "IO! "
21:31:07 <lambdabot>   "for Raynes: IO! IO! IO! IO! IO! IO! IO! IO! IO! IO! IO! IO! IO! IO! IO! IO...
21:31:10 <dancor> > fix (1:)
21:31:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:31:15 <ivanm> (obviously text doesn't support infinite lists...)
21:31:15 <dancor> > cycle [1]
21:31:16 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:31:32 <dancor> > let ones = 1 : ones in ones
21:31:32 <shellsage> dancor, lets assume I had to write the recursive part myself
21:31:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:31:32 <bos> :t text
21:31:33 <lambdabot> String -> Doc
21:31:38 <bos> huh
21:31:53 <shellsage> I think my function's signature is incorrect
21:32:10 * dancor wonders which 10 ways to produce (1:) have the fewest characters
21:32:23 <dancor> to produce (fix (1:)), rather
21:32:27 <shellsage> because when I do something like zipWith (**) [2..] ones I get: No instance for (Floating Integer)
21:32:27 <shellsage>       arising from a use of `**' at <interactive>:1:8-11
21:32:29 <ivanm> bos: you've never seen pretty-print before? :o
21:32:37 <ivanm> your book had a re-implementation! :o
21:32:39 <ivanm> ;-)
21:32:41 <bos> ivanm: i'm surprised it's in scope
21:32:46 <ivanm> ahhhh
21:33:10 <sohum> dancor: probably [1..]
21:33:24 <dancor> that's different
21:33:27 <shellsage> am I just using zipWith incorrectly?
21:33:29 <ivanm> > [1..]
21:33:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:33:37 <sohum> oh, so it is.
21:33:40 <sohum> huh.
21:33:43 <ivanm> shellsage: [2.0 ..]
21:33:48 <sohum> > [1,1..]
21:33:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:34:06 <Raynes> ivanm: O.O!
21:34:22 <shellsage> ivanm, how do I force an arg to be a float in my method signature
21:34:28 * Raynes just falls over dead
21:34:46 <shellsage> I've read a few tutorials and I couldn't find them pointing out something this basic
21:34:49 <ivanm> shellsage: ummm.... you really shouldn't be using the enum instance of Double anyway
21:34:57 <ivanm> shellsage: you could do: map fromIntegral [2..]
21:35:03 <ivanm> which is "safer" than [2.0 ..]
21:35:06 <ivanm> > [2.0 ..]
21:35:07 <lambdabot>   [2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18...
21:35:10 <absentia> heheh
21:35:16 <ivanm> > map fromIntegral [2..]
21:35:16 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
21:35:22 <ivanm> > map fromIntegral [2..] :: [Double]
21:35:23 <lambdabot>   [2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18...
21:35:36 <shellsage> > fromIntegral 2.0
21:35:37 <lambdabot>   Ambiguous type variable `t' in the constraints:
21:35:37 <lambdabot>    `GHC.Real.Fractional t'
21:35:37 <lambdabot> ...
21:35:43 <shellsage> that's the issue
21:35:51 <shellsage> I can't just take Num or something
21:35:58 * ivanm wonders when they're going to have Raynes' funeral...
21:36:10 <ivanm> shellsage: 2.0 isn't Integral ;-)
21:36:16 <shellsage> ivanm, yes, I know
21:36:36 <shellsage> all I want here is a function to take a float or an int as an argument
21:36:44 <Raynes> shellsage: Sure you know. ;)
21:36:46 <shellsage> which I understood to be Num
21:36:53 <ivanm> > zipWith (**) [2..] (repeat 1)
21:36:53 <lambdabot>   [2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18...
21:36:54 <dancor> well you can definitely get 10 things of length 6/7 by adding spaces to "fix(1:)" and "[1,1..]"
21:37:06 <dancor> so i guess that's probably the answer
21:37:11 <ivanm> shellsage: you can't in general, unless it takes a Num as an argument
21:37:23 <ivanm> @type (**)
21:37:23 <lambdabot> forall a. (Floating a) => a -> a -> a
21:37:30 <ivanm> ^^ needs Floating, hence not Int
21:37:31 <shellsage> ivanm, it would appear that my ones function yields something other than (repeat 1)
21:37:32 <ivanm> @type (^)
21:37:33 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
21:37:39 <shellsage> *Main> zipWith (**) [2..] ones
21:37:40 <shellsage> <interactive>:1:8:
21:37:40 <shellsage>     No instance for (Floating Integer)
21:38:02 <ivanm> shellsage: it's defining ones to be [Integer]
21:38:14 <ivanm> shellsage: probably because you didn't give it a type, so it defaulted
21:38:15 <shellsage> what should I define ones to be, if not integer
21:38:22 <shellsage> I specified integer
21:38:28 <ivanm> @type (**)
21:38:28 <lambdabot> forall a. (Floating a) => a -> a -> a
21:38:33 <sohum> :t ones
21:38:34 <lambdabot> Not in scope: `ones'
21:38:49 <ivanm> shellsage: if you want (**) to work with ones, then it has to be an instance of Floating
21:38:57 <shellsage> ivanm, ok thank you.
21:38:58 <ivanm> @instances-importing Data.Complex Floating
21:38:59 <lambdabot> Complex a, Double, Float
21:39:13 <ivanm> ^^ i.e. one of these three
21:39:27 <ivanm> (though I doubt you want Complex, and Float is discouraged)
21:39:57 <sohum> > zipWith ((**) . fromIntegral) [2..] [1,1..]
21:39:57 <lambdabot>   [2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18...
21:40:23 <ivanm> shellsage: but why are you using ** anyway?
21:40:35 <ivanm> if you wnat an integral power, then ^ is better
21:40:49 <ivanm> (though I wonder why you're bothering if you're raising everything to the power of 1 anyway...)
21:41:13 <sohum> > zipWith (((**) &&& (^)) . fromIntegral) [2..] [1,1..]
21:41:13 <shellsage> ivanm, it was just an example of what I'm doing
21:41:14 <lambdabot>   Couldn't match expected type `b -> c'
21:41:14 <lambdabot>         against inferred type `(b1 ->...
21:41:20 <sohum> hrm.
21:41:43 <sohum> :t zipWith ((**) &&& (^))
21:41:43 <lambdabot>     Couldn't match expected type `b -> c'
21:41:43 <lambdabot>            against inferred type `(a -> a, b1 -> a)'
21:41:43 <lambdabot>     In the first argument of `zipWith', namely `((**) &&& (^))'
21:41:52 <sohum> :t zipWith
21:41:52 <ivanm> dancor: any idea how to make a MultiSet.difference-like function that deletes all instances? do something by hand using deleteAll whilst doing a mapAccum or something?
21:41:53 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
21:42:07 <sohum> :t (**) &&& (^)
21:42:07 <lambdabot> forall b b1. (Floating b, Integral b1) => b -> (b -> b, b1 -> b)
21:42:25 <sohum> ah, right
21:44:58 <sohum> > (zipWith ((**) . fromIntegral)) &&& (zipWith (^)) $ [2..] [1,1..]
21:44:59 <lambdabot>   Couldn't match expected type `t -> [a]'
21:44:59 <lambdabot>         against inferred type `[a1]'
21:45:03 <sohum> gr.
21:45:10 <sohum> :t(zipWith ((**) . fromIntegral)) &&& (zipWith (^))
21:45:16 <sohum> :t (zipWith ((**) . fromIntegral)) &&& (zipWith (^))
21:45:16 <lambdabot> forall b a b1. (Floating b, Integral a, Integral b1) => [a] -> ([b] -> [b], [b1] -> [a])
21:47:42 <sohum> :t (&&&)
21:47:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
21:49:07 <sohum> :t zipWith (^) [2..]
21:49:08 <lambdabot> forall a b. (Num a, Integral b, Enum a) => [b] -> [a]
21:49:39 <dancor> ivanm: i think the "right" way might be to convert to a (Map k Int)
21:50:02 <sohum> :t (zipWith ((**) . fromIntegral) [2..]) && (zipWith (^) [2..])
21:50:03 <lambdabot>     Couldn't match expected type `Bool'
21:50:03 <lambdabot>            against inferred type `[b] -> [b]'
21:50:03 <lambdabot>     In the first argument of `(&&)', namely
21:50:09 <ivanm> dancor: so use a Map k Int with Set k as the second "Set"?
21:50:10 <sohum> :t (zipWith ((**) . fromIntegral) [2..]) &&& (zipWith (^) [2..])
21:50:10 <lambdabot> forall b a. (Floating b, Integral b, Num a, Enum a) => [b] -> ([b], [a])
21:50:16 <dancor> ivanm: ya
21:50:31 <sohum> any way to factor the [2..] out of that?
21:50:40 <ivanm> well, multiset has toMap and fromMap...
21:50:55 <dancor> @pl \ x -> (zipWith ((**) . fromIntegral) x) &&& (zipWith (^) x)
21:50:55 <lambdabot> ap ((&&&) . zipWith ((**) . fromIntegral)) (zipWith (^))
21:51:02 * ivanm was about to do that
21:51:12 <sohum> ah, right
21:51:13 <dancor> pl it forward
21:51:16 <ivanm> but dancor saved me the effort ;-)
21:52:01 <sohum> although that looks weird...
21:52:05 * Orclev tries to figure out why his wireless connection is showing a 16% packet loss to the router
21:52:12 <sohum> :t ap
21:52:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:52:33 <dancor> once @pl produces ap, you usually decide not to pl it
21:52:37 <dancor> in my experience
21:52:46 <sohum> heh
21:52:56 <ivanm> heh
21:53:05 <ivanm> @remember dancor once @pl produces ap, you usually decide not to pl it
21:53:05 <lambdabot> It is stored.
21:53:14 <ivanm> just to make jfredett-away happy ;-)
21:53:34 <sohum> :t [(**) . fromIntegral, (^)]
21:53:35 <lambdabot> forall a. (Floating a, Integral a) => [a -> a -> a]
21:53:41 <dancor> @pl \ a (b, c) d -> ((a, b) (c, d))
21:53:41 <lambdabot> (`ap` snd) . (. fst) . flip flip (,) . (((.) . (.)) .) . (,)
21:53:43 <ivanm> dancor: still use a mapAccum-style technique to delete elements from the map you think?
21:55:00 <sohum> :t foldl1 (\x y -> x &&& zipWith y [2..]) [(**) . fromIntegral, (^)]
21:55:01 <lambdabot>     Couldn't match expected type `b -> c'
21:55:01 <lambdabot>            against inferred type `(b -> c, [c])'
21:55:01 <lambdabot>     Probable cause: `&&&' is applied to too many arguments
21:55:18 <sohum> :t foldl1 (\x y -> (&&&) x $ zipWith y [2..]) [(**) . fromIntegral, (^)]
21:55:19 <lambdabot>     Couldn't match expected type `b -> c'
21:55:19 <lambdabot>            against inferred type `(b -> c, [c])'
21:55:19 <lambdabot>     Probable cause: `$' is applied to too many arguments
21:55:28 <sohum> :t foldl1
21:55:29 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
21:56:18 <Orclev> what's (&&&) do?
21:56:50 <sohum> :t foldl1 (\x y -> (&&&) x $ zipWith y [2..])
21:56:51 <lambdabot>     Couldn't match expected type `b -> c'
21:56:51 <lambdabot>            against inferred type `(b -> c, [c])'
21:56:51 <lambdabot>     Probable cause: `$' is applied to too many arguments
21:57:18 <sohum> :t (\x y -> (&&&) x $ zipWith y [2..])
21:57:19 <lambdabot> forall c a b c1. (Num a, Enum a) => ([b] -> c) -> (a -> b -> c1) -> [b] -> (c, [c1])
21:58:00 <Orclev> :t (&&&)
21:58:01 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
21:58:17 <sohum> :t \f g -> f &&& g
21:58:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
21:58:30 <sohum> hm. I thought it'd simplify.
21:58:44 <ivanm> dancor: or for the second MultiSet, just create dummy values in a fake Map?
21:58:50 <ivanm> and then use Map.difference
21:58:57 <sohum> Orclev: basically, (f &&& g) x) = (f x, g x)
21:59:10 <sohum> s/x)/x
21:59:38 <Orclev> sohum: that's kind of interesting
21:59:47 <ivanm> sohum: methinks you're missing a / on the end
21:59:57 <sohum> ivanm: ppfffff
22:00:02 <ivanm> :D
22:00:06 <sohum> @pl \x -> zipWith x [2..]
22:00:06 <lambdabot> flip zipWith [2..]
22:00:23 <ivanm> sohum: what ethnic background is your name from?
22:00:36 <sohum> :t foldl1 (&&&) $ map (flip zipWith [2..]) [(**) . fromIntegral, (^)]
22:00:36 <lambdabot>     Occurs check: cannot construct the infinite type: c = (c, c)
22:00:36 <lambdabot>       Expected type: a b c
22:00:36 <lambdabot>       Inferred type: a b (c, c)
22:00:48 <dancor> *Main> let killElems ms elems = MS.fromOccurList . M.toList $ M.fromList (MS.toOccurList ms) `M.difference` M.fromList (zip elems $ repeat undefined)
22:00:50 <sohum> ivanm: indian. it's a hindi word.
22:00:52 <dancor> *Main> MS.toList $ MS.fromList "helllo" `killElems` "lo"
22:00:54 <dancor> "eh"
22:01:06 <dancor> ivanm: that was my first thought, not sure if it's a terrible hack
22:01:18 <sohum> :t map (flip zipWith [2..]) [(**) . fromIntegral, (^)]
22:01:19 <lambdabot> forall a. (Integral a, Floating a) => [[a] -> [a]]
22:01:22 <ivanm> sohum: *nod*
22:01:35 <ivanm> dancor: what's killElems?
22:01:51 <dancor> ivanm: defined in line above
22:01:58 <ivanm> heh, missed that
22:02:05 <sohum> ah, right, of course there can't be a &&& that works on lists
22:02:10 <sohum> stupid nongeneric tuples
22:04:08 <sohum> @pl \x -> x *** x
22:04:08 <lambdabot> join (***)
22:04:32 <sohum> :t join (***) (flip zipWith [2..]) [(**) . fromIntegral, (^)]
22:04:33 <lambdabot>     Couldn't match expected type `(a -> b -> c, a -> b -> c)'
22:04:33 <lambdabot>            against inferred type `[a1]'
22:04:33 <lambdabot>     In the third argument of `join', namely
22:04:38 <sohum> :t join (***) (flip zipWith [2..]) ((**) . fromIntegral, (^))
22:04:38 <lambdabot> forall a. (Integral a, Floating a) => ([a] -> [a], [a] -> [a])
22:05:12 * dancor forgets how to show the type of (&&&) specialized to the function-arrow
22:05:34 <sohum> :t (&&&) id
22:05:34 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
22:05:41 <sohum> is a quick and dirty hack
22:06:40 <sohum> @pl \x y -> zipwith x [2..] y
22:06:40 <lambdabot> flip zipwith [2..]
22:06:44 <sohum> oh, right
22:06:46 <sohum> doy
22:07:06 <sohum> @pl \x -> zipwith x [2..] [1..]
22:07:06 <lambdabot> flip (flip zipwith [2..]) [1..]
22:07:11 <Gracenotes> @type (&&&) `asTypeOf` (undefined :: a -> b -> c -> d)  -- do not try at home
22:07:11 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
22:07:17 <sohum> yay for doubleflips
22:07:30 <dancor> Gracenotes: ty
22:07:57 <Gracenotes> the clutter makes it pretty useless for didactic purposes. or any purposes. but at least it does try to unify the two
22:08:21 <sohum> :t join (***) (flip (flip zipWith [2..]) [1,1..]) ((**) . fromIntegral, (^))
22:08:22 <lambdabot> forall a. (Integral a, Floating a) => ([a], [a])
22:08:27 <sohum> > join (***) (flip (flip zipWith [2..]) [1,1..]) ((**) . fromIntegral, (^))
22:08:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:08:28 <lambdabot>    `GHC.Float.Floating a'
22:08:28 <lambdabot>  ...
22:08:33 <Gracenotes> in this case, (&&&) and a function with > three type constructors
22:08:38 <aavogt> @type fix asTypeOf
22:08:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
22:08:39 <lambdabot>     Probable cause: `asTypeOf' is applied to too few arguments
22:08:39 <lambdabot>     In the first argument of `fix', namely `asTypeOf'
22:08:54 <aavogt> @type fix . asTypeOf
22:08:54 <lambdabot> forall a. a -> a
22:08:56 <dancor> i thought there was a better way
22:09:51 <sohum> right, and now we get to the fundamental reason why I can't do that ;)
22:09:58 <sohum> @instances Integral
22:09:58 <lambdabot> Int, Integer
22:10:06 <sohum> @instances Floating
22:10:06 <lambdabot> Double, Float
22:10:59 <oDric_oClumns> sohum: Are you still working on your stddev? :)
22:11:14 <sohum> oDric_oClumns: stddev?
22:11:50 <oDric_oClumns> Sorry - stdDev? Or was that someone else? :)
22:12:08 <sohum> possibly someone else? it means nothing to me
22:12:22 <sohum> :t join
22:12:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:12:29 <sohum> oh, hahaha
22:12:33 <sohum> that's neat
22:12:38 <dancor> i've only ever worked on my kertosis
22:12:41 <sohum> : join (+)
22:12:46 <sohum> :t join (+)
22:12:47 <lambdabot> forall a. (Num a) => a -> a
22:12:53 <dancor> i'm still working on the spelling
22:12:57 <sohum> best definition of double ever.
22:13:40 <sohum> > join (*) 5
22:13:41 <lambdabot>   25
22:14:02 <Gracenotes> don't forget about..
22:14:07 <Gracenotes> > join (join (*)) 2
22:14:08 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a)
22:14:18 <Gracenotes> or something like it, except working
22:14:27 <sohum> :t join (join (*))
22:14:28 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
22:14:28 <lambdabot>     Probable cause: `*' is applied to too few arguments
22:14:28 <lambdabot>     In the first argument of `join', namely `(*)'
22:14:35 <sohum> :t join (join (*2))
22:14:36 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a -> a1
22:14:36 <lambdabot>     Probable cause: `*' is applied to too many arguments
22:14:36 <lambdabot>     In the first argument of `join', namely `(* 2)'
22:14:43 <sohum> :t join . join
22:14:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
22:15:00 <Gracenotes> oh yes, now I remember
22:15:05 <Gracenotes> > join (.) (join (*)) 2
22:15:05 <lambdabot>   16
22:15:19 <sohum> hahaha
22:15:21 <Gracenotes> > join (.) (join (.) (join (*))) 2
22:15:22 <lambdabot>   65536
22:17:19 <Gracenotes> I believe you could do this automatically by folding with an accumulator of type (a -> a) -> a -> a
22:23:05 <oDric_oClumns> :tfoin (.)
22:23:07 <copumpkin> :t join (.) join
22:23:08 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
22:23:08 <lambdabot>       Expected type: m (m a) -> m a
22:23:08 <lambdabot>       Inferred type: m (m a) -> m (m a)
22:23:14 <oDric_oClumns> :t join (.)
22:23:15 <lambdabot> forall b. (b -> b) -> b -> b
22:23:39 <copumpkin> ah
22:24:11 <oDric_oClumns> :t ($id)
22:24:12 <lambdabot> forall b a. ((a -> a) -> b) -> b
22:25:38 <oDric_oClumns> :t join (,)
22:25:39 <lambdabot> forall a. a -> (a, a)
22:27:38 <Gracenotes> > foldr1 (.) (replicate 2 $ join (.)) (join (*)) 2
22:27:38 <lambdabot>   65536
22:28:16 <Gracenotes> can be replaced with foldr with id as 2nd argument
22:29:02 <Gracenotes> I'm having trouble finding out what this function is, actually... it grows like (2^2), 2^(2^2), 2^(2^(2^2)), etc.
22:29:45 <Gracenotes> > iterate (2^) 1
22:29:45 <lambdabot>   [1,2,4,16,65536,20035299304068464649790723515602557504478254755697514192650...
22:31:05 <Gracenotes> something particular to the pattern of growth is that the join (.) doubles the computation. so it's not quite the double exponentiation operator; it is 2-specific somehow
22:33:30 <oDric_oClumns> > foldr1 (.) (replicate 2 $ join (.)) (join (*)) 3
22:33:31 <lambdabot>   43046721
22:48:14 <sohum> :t \x y -> foldl1 (.) (accum y) x where accum x | x <= 1 = [id] | x == 2 = [(join (*))] | x > 2 = replicate (x-2) (join (.)) ++ accum 2
22:48:15 <lambdabot> parse error on input `where'
22:53:12 <sohum> :t \x y -> let accum x | x <= 1 = [id] | x == 2 = [(join (*))] | x > 2 = replicate (x-2) (join (.)) ++ accum 2 in foldl1 (.) (accum y) x
22:53:12 <lambdabot> forall b. (Num (b -> b)) => (b -> b) -> Int -> b -> b
22:53:37 <sohum> ...doing something wrong
23:15:39 <dblhelix> good morning #haskell!
23:16:47 <mayahustle> Hey everyone! I'm a graduate student whose recently been given a term project for a distributed systems class.  The implementation language is of course up to us, and I was thinking about using Haskell.  I'm not new to the language, but I've never fooled around with the Concurrency/Networking aspect of the language.  Has anyone here ever built a distributed system with haskell? if so, how hard/easy was haskell to use to build it?
23:17:25 <dons> i was involved in a project that ran simulations across a cluster
23:17:37 <dons> using concurrent haskell on the nodes, and the regular networking layer
23:17:56 <mayahustle> btw.. the assignment is to "build a simplified version of a distributed file system which supports parallel i/o ops, with emphasis on scalability and fault-tolerance"
23:17:59 <dons> the benefit of haskell is that it is fast and safe on each node, and there's moderate support for inter-node communication
23:18:00 <mayahustle> how'd it go?
23:18:09 <dons> oh, fine. there's a few papers on it
23:18:20 <dons> i think for 'fast-and-safe' haskell might be a good bet.
23:18:44 <dons> if you can get some kind of distributed transactional memory semantics...
23:18:47 <dons> that'd be a good research results
23:19:03 <mayahustle> I've never fooled around with STM before
23:19:10 <mayahustle> but that's what I was thinking
23:19:14 <dons> and there's a very rich environment for shared-memory concurrency and parallelism
23:19:19 <dons> the distributed part is less developed
23:19:38 <mayahustle> the only other language I was considering using was python
23:19:40 <dons> Glasgow Distributed Haskell is a huge , long term project though
23:19:48 <dons> oh, well, there performance + safety will kill you.
23:19:54 <mayahustle> exactly
23:19:56 <dons> no one implements file systems, of any kind, in python
23:20:04 <mayahustle> and the project is definitely emphasizing speed
23:20:19 <mayahustle> how far along is GDH?
23:20:25 * ivanm wonders how erlang would cope for such a distributed file system
23:20:29 <dons> its a research project.
23:20:37 <mayahustle> hrmm
23:20:42 <dons> and you can bootstrap from galois' open source haskell filesystem, http://www.haskell.org/halfs/
23:21:11 <mayahustle> does anyone know of any distributed file systems implemented in a functional language in general?
23:21:19 <dons> hmm. nope.
23:21:19 <ivanm> dons: where "research project" means "it will never be finished, and usability is not yet something we're considering"? :p
23:21:31 <dons> well, i've never used, nor met anyone in here who has.
23:21:49 <dons> but it would be a good reference for the design of abstractions
23:22:09 <dons> mayahustle: sounds like a cool project.
23:22:15 <ivanm> mayahustle: well, this is the distributed file systems known to wikipedia: http://en.wikipedia.org/wiki/List_of_file_systems#Distributed_file_systems
23:22:27 <ivanm> you could see which langs they've been implemented in
23:22:54 <mayahustle> my prof is looking for something similar to googlefs, panasasfs, or pNFS
23:23:12 <mayahustle> the project is of course simplified.. we only have 10 weeks to do it
23:23:23 <JoePeck> mayahustle: I know a few students who have worked with Hadoop (its Java) for a 10 week based course
23:23:43 <dons> the hayoo guys seem to have done a fair bit on distribution.
23:23:51 <dons> in haskell..
23:24:00 <mayahustle> hayoo?
23:24:07 <dons> http://hackage.haskell.org/package/Holumbus-Storage
23:24:14 <dons> "This package contains a library for building distributed storage systems.
23:24:28 <mayahustle> joepeck:.. I've been trying to avoid java
23:24:42 <mayahustle> I'm sort of sick of it.. having been raised as an undergrad on it
23:24:54 <mayahustle> unless your suggesting interfacing haskell to hadoop
23:25:18 <mayahustle> thanks for the link dons
23:25:19 <JoePeck> mayahustle: fair enough, just mentioning some familiarity with the list
23:26:01 <mayahustle> yeah, thanks, also, I have a feeling the rest of the class will be using java.. I would like to do something more interesting
23:26:11 <JoePeck> thats a good attitude =)
23:27:18 <dons> mayahustle: it'd be interesting to see if you can use haskell to ramp up the fault tolerance angle
23:27:22 <mayahustle> I also think we will get some kind of bonus for speed/throughput.. I'm hoping to beat out the java programs
23:27:33 <dons> or, emphasise multicore concurrency on each node.
23:27:37 <mayahustle> no jvm = faster program (hopefully)
23:28:21 <Pseudonym> In case anyone is curious about the forward error correction problem I had yesterday, I found a quaternary code with 105 codewords which corrects single-symbol errors and detects double-symbol errors.
23:28:21 <dons> lots of forkIO haskell threads
23:28:21 <Pseudonym> That's with messages of 6 symbols.
23:28:21 <mayahustle> right
23:28:42 <vegai> dons: http://www.willmcgugan.com/blog/tech/2008/9/21/announcing-fs-010-a-python-file-system/ :P
23:28:52 <dons> hey
23:28:54 <mayahustle> I don't know about emphasizing multicore... I would like the design to be able to run on the cheap hardware
23:29:02 <mayahustle> sort of like panasas
23:29:11 <mayahustle> then again multi-core isn't exactly expensive
23:29:38 <dons> i think that would be an interesting research angle
23:30:18 <mayahustle> lol.. 10 weeks isn't exactly a lot of time for a great research angle.. the best I can hope for is a fast prototype
23:31:13 <mayahustle> I may be able to use it for my thesis.. (i'm studying digital forensics). maybe this experience could lead to distributed forensics tools in haskell
23:31:17 <mayahustle> that would be interesting
23:32:12 <dons> hummm
23:32:15 <dons> very interesting
23:32:37 <mayahustle> most forensics tools, at least the ones i've encountered are written in either C or python
23:32:56 <dons> btw, i work at galois.com, we're a fault tolerance/ high assurance research company that uses a lot of haskell, if you're interested once your thesis is done :-)
23:33:32 <vegai> dons: do you guys employ non-graduates?
23:34:25 <mayahustle> python 2.5 or 2.6 has pretty good IO speeds.. but python 3.0 is terrible. I'm trying to find a language that can ease the development of forensics tools with higher order language constructs
23:34:32 <mayahustle> dons:... i very well may be
23:34:34 <dons> minimum requirement is a comp. sci degree or equivalent
23:34:38 <ivanm> what's so bad about 3's IO?
23:34:48 <vegai> right
23:35:24 <mayahustle> Word on the street (meaning, I haven't really tested it) is that the new IO package is way slower than 2.5, 2.6.
23:36:00 <mayahustle> at least that's the opinion I've encountered from the people I know that like to code in python
23:36:42 <Gracenotes> worst comes to worst, people will write their own cpython IO libraries
23:36:46 <mayahustle> dons: I'm bookmarking galois.com... I may be sending a resume once I finish up.. thanks for the info
23:37:01 <mayahustle> lol or keep using 2.6
23:38:26 <mayahustle> anyways, thank you guys for the info regarding the dfs, I'm sure I'll be back once I start making progress. Good night/good morning..
23:39:11 <dons> good stuff.
