00:00:03 <arw_> > quot 3 (-2)
00:00:04 <lambdabot>   -1
00:01:27 <stanv> strange :(((
00:08:50 <olsner> hmm, I'm trying to use a type-level list to generate instances of a type-class based on the description in the type-level list
00:09:25 <FunctorSalad> what's the current tool of choice for writing FFI bindings less painfully?
00:10:28 <FunctorSalad> e.g. this would be nice to have a binding to, I suppose http://www.gnu.org/software/glpk/
00:10:39 <blackdog> FCGFGGGC
00:10:39 <blackdog> FCGFGGGC
00:10:52 <blackdog> argh. sorry. terminal screwup.
00:11:08 <blackdog> FunctorSalad: i think FFI pain is invariant
00:11:23 <blackdog> c2hs isn't so bad, although the docs are threadbare
00:12:09 <FunctorSalad> hmm
00:12:19 <BMeph> > mod (-2) 3
00:12:21 <lambdabot>   1
00:12:31 <BMeph> > rem (-2) 3
00:12:32 <lambdabot>   -2
00:13:42 <copumpkin> FunctorSalad: that would be a lot nicer if we had a boolean typeclass :P
00:17:45 <SubStack> a maybe read would be nice
00:17:49 <SubStack> I recall wanting this before
00:18:07 <Cale> SubStack: yeah... there's reads though which gives you a list, which is almost as good
00:18:16 <Cale> (sometimes more appropriate)
00:18:17 <copumpkin> :t listToMaybe . reads
00:18:17 <SubStack> almost, yeah
00:18:18 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
00:18:24 <FunctorSalad> SubStack: http://hackage.haskell.org/packages/archive/safe/0.2/doc/html/Safe.html#v:readMay
00:18:31 <FunctorSalad> @help where
00:18:32 <lambdabot> where <key>. Return element associated with key
00:18:52 <FunctorSalad> @help remember
00:18:52 <SubStack> I want the instance for String to be the id like happstack's ReadString
00:18:52 <lambdabot> quote <nick>
00:18:53 <lambdabot> remember <nick> <quote>
00:18:53 <lambdabot> Quote somebody, a random person, or save a memorable quote
00:19:07 <SubStack> so I'll need to whip up my own class anyways
00:19:26 <SubStack> neat though
00:19:46 <SubStack> makes this bit easier
00:19:52 <SubStack> FunctorSalad++
00:21:29 <mmorrow> FunctorSalad: re: FFI bindings. jabbing an eye-glass screwdriver under each toenail before you start is helpful to get yoar pain receptorz prepped for what's to come.
00:21:46 <FunctorSalad> mmorrow: I see
00:22:08 <mmorrow> FunctorSalad: it's not that bad actually, just tedious.
00:23:21 <mmorrow> FunctorSalad: but it could definitely be automated by someone that spends the time to write a package that uses language-c to extract the relevant bits automatically, and then either TH or haskell-src-exts to build the haskell code to import/etc them
00:23:30 <mmorrow> then prettyprint to a bunch of haskell modules
00:23:48 <mmorrow> but no one has done so yet
00:23:53 <FunctorSalad> there's hsffig
00:24:05 <FunctorSalad> didn't really use it yet though
00:24:24 <mmorrow> FunctorSalad: i tried that a bit, couldn't seem to get it to do anything
00:25:21 <mmorrow> but i got the code i was trying to use some backward-assed way, and had iirc do stuff to it to even get it to build (so i'm sure i was Doing It Wrong)
00:26:03 <mmorrow> FunctorSalad: i don't think hsffig is done yet
00:26:37 <mmorrow> FunctorSalad: the omfg-this-is-awesome tool i'm picturing would work like:
00:27:30 <mmorrow> $ ls stuff/*.h | hsffi-gen
00:27:39 <mmorrow> then "$ ls" would show
00:27:52 <mmorrow> This.hs That.hs Asdf.hs
00:27:58 <mmorrow> given this.h that.h asdf.h
00:28:05 <FunctorSalad> that would be ideal indeed ;)
00:28:16 <ksf> c2hs is quite promising, but also quite limited.
00:28:38 <clanehin> people talk about it hypothetically, but there's never been an actual implementation of pointer-equality in Haskell, right?
00:28:59 <FunctorSalad> clanehin: stable names
00:29:18 <clanehin> I mean with arbitrary thunks, not FFI stuff.
00:29:20 <ksf> what I'd like to see is a) function templates, for all those functions that have common types and semantics, b) stubs to or compilation of c macros c) customized codegens
00:29:22 <mmorrow> clanehin: there's a ghc primitive to do it, but of course the ptr depends on how evaluated something is, and the ptrs change across GC's (which occur many times per second)
00:29:23 <FunctorSalad> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
00:29:48 <mmorrow> yeah, StableName is the way to go
00:30:21 <clanehin> FunctorSalad, mmorrow, thanks that's what I needed.
00:30:34 <olsner> @pl \f -> g (f x)
00:30:34 <lambdabot> g . ($ x)
00:31:04 <ksf> ...in the end, you don't want completely-automatic ffi, as you will want to haskellise the bindings, anyway.
00:31:42 <ksf> otoh, xcb/xhb show the way to go.
00:32:13 <mmorrow> ksf: right. the tool i'm picturing just does the grunt work of generating all the
00:32:23 <ksf> ...which are both generated from the same descriptions, both implementing the whole x protocol, themselves.
00:32:26 * FunctorSalad remembers when we were talking about putting CReal under Foreign.C.Real with the justification of having thought that that hierarchy contains any names starting with C, lol
00:32:38 <copumpkin> :)
00:32:43 <copumpkin> it should be called Real imo
00:32:58 <ksf> Real is taken for the typeclass.
00:32:58 <mmorrow> foreign import ccall unsafe "ten_of_four_thousand" ten_of_four_thousand :: Ptr (Ptr (Ptr CLong)) -> Ptr CChar -> CInt -> CLong -> Ptr CUInt
00:33:04 <mmorrow> x 10000
00:33:07 <ksf> ...which confuses the hell out of me.
00:33:16 <ksf> "Dividable" would be a good name.
00:33:16 <copumpkin> ksf: yeah, I think that's silly
00:33:43 <ksf> class names should be descriptions, not things.
00:33:58 <mmorrow> and would generate "data PROT = PROT_WRITE | PROT_READ | PROT_EXEC" etc for all enumcs
00:34:00 <mmorrow> *enums
00:34:07 <doserj> Real should be named OrderedRing
00:34:36 <mmorrow> + would gen     tHIS_IS_A_DEFINE = 0x38783    for all "#define THIS_IS_A_DEFINE 0x38783"
00:34:38 <mmorrow> etc
00:35:11 <mmorrow> the tricky part is what to do about non-constant macros
00:35:33 * ksf opposes any numeric library that dares to mention "Ring" or other things of that ilk THAT DO NOT COME WITH THE PRINCIPIA MATHEMATICA IN PLAIN ENGLISH IN THE HADDOCKS
00:36:06 <Dr_K> plain english?
00:36:13 <FunctorSalad> but things defined in the principia mathematica are fine or what?
00:36:27 <copumpkin> oh crap
00:36:34 <copumpkin> ksf would not like the library I'm working on now
00:36:43 <ksf> mmorrow, I bet c2hs could already do that with its current codeset.
00:37:24 <ksf> it knows how to parse headers and I guess also how to process macros
00:37:29 <mmorrow> ksf: i'd probably just use language-c and haskell-src-exts (or TH, but just for convenience in building the haskell, not to splice) directly
00:37:41 <ksf> ...it should be possible to map over it and just dump everything.
00:38:55 <ksf> oh, one additional thing: dynamic loading support.
00:39:07 <hackagebot> language-dot 0.0.1 - A library for the analysis and creation of Graphviz DOT files (BrianLewis)
00:39:11 <mmorrow> System.Posix.DynamicLinker ?
00:39:23 <mmorrow> well, you also need something like libffi/equiv
00:39:27 <copumpkin> *Algebra> withSemiring plusTimesInteger (E 5 + E 6 * E 7 + one)
00:39:27 <copumpkin> 48
00:39:31 <ksf> ...you're back to hand-coding nearly everything, as c2hs can't generate dynamic ffi imports.
00:39:34 <mmorrow> to dynamically build the glue code
00:40:01 <copumpkin> :P
00:40:18 <copumpkin> there is so much voodoo in this code
00:40:20 <ksf> lemme look at my code
00:40:21 <copumpkin> it's ridiculous
00:41:26 <BMeph> Ah, yes, thugs: the ilk of human kindness... ;p
00:41:38 <ksf> type TCInt_CharP = CInt -> IO CString
00:41:38 <ksf> foreign import ccall safe "dynamic"
00:41:38 <ksf>     mkCInt_CharP :: FunPtr TCInt_CharP -> TCInt_CharP
00:41:38 <ksf> fCInt_CharP :: FunPtr TCInt_CharP -> Integer -> IO String
00:41:38 <ksf> fCInt_CharP f x = (mkCInt_CharP f) (fromIntegral x) >>= peekCAString
00:41:51 <ksf> ...for every bleeding C type I want to import.
00:42:12 * BMeph sacrifices a chicken for live analysis of copumpkin's code
00:42:13 <FunctorSalad> copumpkin: withSemiring? what does that do?
00:42:16 <mmorrow> ksf: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2029
00:42:26 <mmorrow> ksf: easy partay with libffi
00:42:31 <copumpkin> FunctorSalad: it specifies which semiring I want to use for the expression :P
00:42:49 <copumpkin> FunctorSalad: with so much voodoo it's not even funny
00:43:04 <FunctorSalad> copumpkin: is this oleg's local-instances stuff? (which I didn't really get)
00:43:47 <copumpkin> FunctorSalad: I'm using http://hackage.haskell.org/package/reflection behind the scenes, and layering much voodoo of my own on top of it
00:44:11 <copumpkin> I have what feels like subtyping on the algebraic structures
00:44:19 <mmorrow> ksf: (that's using the libffi haskell bindings from hackage)
00:44:28 <copumpkin> so if you're a group you're automatically a monoid and a semigroup and so on
00:44:28 <FunctorSalad> copumpkin: yeay, that package was what I was thinking of
00:44:29 <ksf> hmmm.
00:44:35 <FunctorSalad> so I agree, it's vodoo to me ;)
00:44:43 <mmorrow> copumpkin: nice
00:45:04 <ksf> Someone remind me never to use something from base before looking at hackage
00:45:05 <copumpkin> mmorrow: yeah, I'm liking the way this is going, although needing to put the E on everything is a little annoying
00:46:18 <mmorrow> copumpkin: could you make the type that E is from an instance of Num?
00:46:26 <mmorrow> so "5" ==> "E 5"
00:46:36 <copumpkin> mmorrow: yeah, definitely, but I'd feel dirty using Num in this code :P
00:46:43 <copumpkin> so I've avoided it so far
00:46:51 <mmorrow> copumpkin: heh, just implement fromInteger..
00:46:56 <copumpkin> and I'd still need to do the E for non-numeric types
00:47:01 <mmorrow> and don't even import the rest
00:47:02 <mmorrow> aww
00:47:03 <copumpkin> mmorrow: I tried and it wasn't working, so I put it off until later
00:47:13 <copumpkin> when in doubt, procrastinate
00:47:15 <copumpkin> is my motto
00:48:17 <a-s> hi
00:48:24 <a-s> waw, how many users!
00:48:28 <a-s> never seen so much
00:48:42 <a-s> lazy evaluation :)
00:49:12 <copumpkin> mmorrow: also, unfortunately I have just about every ghc extension turned on for this :P
00:49:22 <mmorrow> heh
00:50:22 <copumpkin> including undecidable and incoherent instances
00:50:29 <copumpkin> I could probably trim some out if I wasn't so lazy
00:51:23 <ketil> blackdog, I think many people have a fuzzy idea of what a type is.  Including me.
00:51:42 <copumpkin> I have a type-level ordered list as a set with unioning, subset extraction (including on the value level) and things like that
00:51:54 * ketil apologizes for replying to a conversation that's an age and a half old.  Damn.
00:53:08 <ksf> "when in doubt, procrastinate" only works with a big enough problem space and a shallow enough descision tree. unfortunally, bottom-up design is depth-first.
00:53:24 <ksf> but backtracking helps, yes.
00:53:50 <blackdog> ketil: surely a Boolean is reasonably clearcut, though
00:54:04 <blackdog> (ignoring bottom etc)
00:54:31 <ksf> ...product and sum types are the point where it gets interesting.
00:54:55 <ksf> ...and their curry-howard correspondences.
00:55:30 <ketil> blackdog, well, I think most people have a working intuition about what they think they mean when they talk about types.  But can they formally define it?  I have a hard time accepting e.g. lisp programmers that considers division by zero a type error.
00:56:02 <FunctorSalad> it could be if you have a "nonzero real" type
00:56:29 <FunctorSalad> but IIRC even in the coq reals package they have real division non-dependently typed to avoid the mess
00:56:52 <ketil> FunctorSalad, sure - but you get all kinds of ad-hoq types this way, and I have a problem seeing what kind of error is *not* a type error.
00:57:39 <FunctorSalad> and a lemma like: Rinv_r: forall r : R, r <> 0%R -> (r * / r)%R = 1%R
00:57:48 <lars9> hi, can haskell's lightweight threads be running on different CPU cores?
00:58:13 <FunctorSalad> ketil: yeah, that's the idea in system likes coq, the type system is a full-blown logic
00:58:14 * ketil is talking about so-called "dynamic typing" here, not dependent static types or similar theroy, fashionable though it may be.
00:58:22 <ksf> ...you get around the mess by defining multiplication in terms of data Recp = Recp (Succ Nat)
00:58:22 <FunctorSalad> ah
00:58:41 <ksf> lars9, yep.
00:58:43 <FunctorSalad> is it really fashionable? I keep hearing that but it doesn't seem very widely used yet :D
00:59:11 <lars9> ksf: so, threads generated by forkIO can run on different CPUs?
00:59:17 <ksf> ...the rts spaws as many threads as you have cpus (by default with -threaded), and schedules all your threads accross all cores.
00:59:19 <ketil> Popularity is a true sign of something about to go out of style.
00:59:24 <ksf> ...even one thread can run on different cores.
01:00:00 <lars9> ksf: but how can haskell do that if haskell's threads are not native threads?
01:00:19 <ksf> s/thread/process/
01:00:38 <FunctorSalad> ketil: do you think it's fashionable as in "won't actually work"?
01:00:44 <ksf> the rts spawns N processes (or pthread, whatever) and schedules the haskell threads there.
01:00:55 <FunctorSalad> I like to think it could work :)
01:00:57 <lars9> ksf: i see, thanks:)
01:01:10 <ksf> ...which aren't preemptive, btw.
01:01:33 <copumpkin> ?
01:01:51 <copumpkin> they aren't?
01:02:53 <ksf> it's fashionable as in "ghc's typechecker is moving more and more towards the edge of non-termination"
01:03:52 <ketil> FunctorSalad, no opinion, really - I've never tried.  Lots of smart people seem to be working on it, so either they think it will work, or at least, they manage to convince their funding agencies that they think so.
01:04:05 <ksf> somehow, type families already crossed that border.
01:04:25 <stanv> please help: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8913#a8913
01:04:44 <ketil> compukin: I think the RTS switches threads on allocations, so a non-allocation thread might hog the native thread.
01:05:08 <ksf> the problem is that you either need programmpers to prove termination, which may not terminate, or attempt to prove yourself, which may not terminate.
01:05:27 <ksf> copumpkin, they're cooperative.
01:05:50 <copumpkin> :o
01:06:28 <ksf> they yield voluntary, even if the compiler inserts a lot of yields itself.
01:06:48 <Saizan> GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).
01:06:51 <mmorrow> lars9: the way you'd do forkIO in C would be by giving each "thread" it's own stack, writing your own scheduler, and to context switch you'd restore the (subset that you need of) regs of the thread to-switch-to, and jmp
01:06:55 <ksf> ...which also means that ffi calls won't be preempted.
01:07:13 <ksf> that's not preemptive.
01:07:37 <ksf> preemptive is shooting a car's tires to make it stop.
01:07:44 <mmorrow> the way that ghc can do pre-emption is because it's generating the haskell to begin with
01:07:59 <ksf> ...the rts just waits until the car stops, and then decides whether it may go on or not.
01:08:04 <mmorrow> so it checks if it needs to return to the scheduler at certain points
01:08:24 <mmorrow> with C, you'd need to explicitly  yield(), since the C compiler wouldn't be in on this
01:08:24 <copumpkin> ksf: well yeah, it can't stop foreign calls, but that doesn't mean it's not pre-emptive
01:08:27 <arw_> thats not preemption, thats cooperative multitasking with compiler support.
01:08:36 <mmorrow> arw_: right
01:08:40 <arw_> preemption is getting interrupts which cannot be masked.
01:08:52 <ksf> it's just not preemptive if the scheduler has no way to stop a thread before it yields.
01:09:00 <ksf> ...that's cooperative.
01:09:29 <Saizan> from the haskell source code POV it's preemption, there's no explicit wait to prevent your thread from being stopped
01:09:30 <mmorrow> arw_: the rts uses a timer interrupt, and upon getting it arranges that the current forkIO thread yield at the next possible safe-to-yield point
01:09:52 <lars9> mmorrow: the problem is native threads are scheduled by OS, and threads in the same process can run on different cores. but if all haskell threads run inside a single native thread, it can not utilize multi-cores
01:09:52 <mmorrow> yeah, from haskell you can't tell the difference (as long as you're allocating)
01:10:16 <copumpkin> lars9: except if you ask the rts to distribute your work across multiple threads...
01:10:22 <mmorrow> lars9: the rts may migrate forkIO threads between the OS threads it itself is running in
01:11:07 <copumpkin> I have a type-level question
01:11:23 <copumpkin> say I have a type-level list of types
01:11:42 <copumpkin> I want to guarantee they're all of kind * -> * and that they're all applied to the same value
01:11:48 <copumpkin> I mean all applied to the same type
01:11:53 <copumpkin> is there a way to do that?
01:11:59 <lars9> mmorrow: in a simple sample, if i use forkIO to generate a thread, then i have two threads A and B, can they be scheduled to two cores?
01:12:18 <arw_> possibly, yes.
01:12:18 <copumpkin> yeah
01:12:22 <ksf> if you complie with -threaded, yes.
01:12:29 <mmorrow> lars9: yes, and they may also switch between cores each time slice they run
01:13:03 <ksf> ...or they may all run on one core, which might make sense.
01:13:09 <mmorrow> lars9: but whether or not that happens depends on the rts scheduler
01:13:13 <ksf> see e.g. the thread ring shootout program.
01:13:31 <mmorrow> lars9: you can also explicitly pin a forkIO thread to a specific core
01:13:35 <Saizan> copumpkin: so you want them to appear applied in the type?
01:13:54 <mmorrow> @type GHC.Conc.forkOnIO
01:13:55 <lambdabot> Int -> IO () -> IO GHC.Conc.ThreadId
01:14:08 <mmorrow> the Int is the core number
01:14:09 <ksf> copumpkin, write fold on the type level and compare them...
01:14:11 <copumpkin> Saizan: yeah, say I have Type1 Int :> Type2 Int :> Type3 Int :> Nil, that's good, but Type1 Int :> Type2 Bool :> Nil is bad
01:14:15 <lars9> ksf, mmorrow: is haskell using a N to M mapping to map haskell threads to native threads?
01:14:22 <copumpkin> ksf: hm, I was thinking of that
01:14:23 <blackdog> ketil: hm. yeah, you can't even r eally call that a dynamic type error, can you....
01:14:24 <Saizan> copumpkin: a class should do
01:14:47 <copumpkin> Saizan: yeah, but that doesn't force them to be the same type does it?
01:15:00 <mmorrow> lars9: you can set the number of hardware threads the rts'll use with ./foo +RTS -N2 -RTS
01:15:04 <copumpkin> it'll just complain if they aren't
01:15:13 <EnglishGent> hi all :)
01:15:18 <copumpkin> hi EnglishGent
01:15:23 <EnglishGent> hi copumpkin :)
01:15:28 <Saizan> copumpkin: class Check arg list; instance Check arg Nil; instance Check arg tail => Check arg (f arg :> tail);
01:15:33 <ksf> ...type families come with type equality constraints.
01:15:47 <lars9> i see:)
01:15:56 <copumpkin> Saizan: yeah, I was going to do that, but let's take another example
01:15:58 <mmorrow> lars9: but yeah, usually the ideal number of hardware threads is the number of cores (or i've heard people say #cores+1)
01:15:59 <ksf> copumpkin, while you're at it, write map and unfoldr, and, most importantly, stream fusion.
01:16:01 <Saizan> copumpkin: and probably a list -> arg, fundep
01:16:19 <copumpkin> ksf :P
01:16:19 <lars9> mmorrow: i see:)
01:16:27 <ketil> blackdog, division by zero?  Well, if types are sets of values, division requires a dividend(?) from the set of non-zero numbers.  But it's all very ad-hoc, and thus rather useless.
01:16:36 <Saizan> copumpkin: -in-depth?
01:16:53 <blackdog> ketil: yeah, exactly.
01:17:01 <ksf> you don't even need rules to match for deforestation...
01:17:17 <dmwit> braindead formats... =(
01:19:37 <ksf> there can be no division by zero if you define multiplication in terms of reciprocals that only take numbers > 0
01:25:48 <ketil> Reading http://en.wikipedia.org/wiki/Type_system, the section on Dynamic typing seems to imply types as tagging of values, and thus zero division is not a type error.  If I understand it correctly.
01:27:02 <ukl> hello. I'm a little disturbed my ghci's prompt. How can I determine the type of <$> or <*> or anything similar from Control.Applicative? All I end up with (when using ":t <*>") is "parse error on input".
01:27:19 <mux> ukl: put parens around the operator, ie :t (<$>)
01:27:27 <ukl> oh, sure. thanks
01:28:33 <Saizan> mmorrow: got my tiny hstidy patch? (for the derive-gadt repo, actually)
01:28:45 <mux> ketil: not sure what you mean here
01:28:51 <ukl> another thing; how can I get ghci's prompt to obey keys like <home>, <end>, <del>? I end up with "7~", I must have messed up some configuration; just don't know where to start looking
01:29:35 <ukl> (using urxvt as terminal)
01:30:05 <mux> ukl: what version of GHC are you using? versions < 6.10.3 use libreadline or libeditline to handle prompt input and history, and sometimes those weren't detected and thus not linked
01:30:19 <Igloo> Anyone at ICFP here?
01:30:19 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
01:30:22 <mux> newer GHC versions use haskeline, a pure Haskell implementation, and so it typically works much better
01:30:29 <ukl> mux: 6.10.4
01:30:48 <mux> ukl: then your problem is most likely on your side; ie misconfigured terminal
01:31:01 <mux> ukl: if this is a UNIX-like, check that $TERM is set to the correct thing
01:31:02 <ketil> mux: some (dynamic typing) people seem to consider div by zero a type error.  I think that's wrong, but I'm a bit uncertain how "dynamic type" is defined.
01:31:09 <ukl> mux: I'm using the ghc from debian's sid repositories -- well, I don't doubt it's my side ;)
01:31:22 <Saizan> ukl: http://trac.haskell.org/haskeline/wiki/UserPrefs
01:31:33 <ukl> Saizan: thanks, I'll have a look
01:31:55 <mux> ketil: that would mean type would depend on values, which is what you get with dependent typing, which is an active research topic - it doesn't work that way in dynamic languages as far as I know
01:32:28 <Saizan> on this side of the fence we consider "dynamic typing" an entirely different field
01:32:34 <mux> ketil: typically, the definitions I've read say that dynamic type system allows the same variable to be of different type during the execution of the program
01:32:38 <ketil> mux: it's a question of definition.
01:32:48 <Saizan> types are only those which are static :)
01:32:51 <mux> ketil: yes, but that one doesn't sound sane to me
01:32:55 <ketil> Saizan, yes, the "type" in "dynamic type" and "static type" are different things.
01:34:10 <mux> there are many terms characterising type systems that are very vague and have no well defined meaning (weak/strong, safe/unsafe); however dynamic/static is the most well defined one
01:34:20 <ketil> mux: Sure - but a value should have a single type in each "typing", no?
01:34:36 <Saizan> ketil: i'd agree with you that dynamic typing is motly about tags, and so division by zero is not catched by them
01:34:41 <mux> ketil: I don't understand you here, what's a "typing"
01:35:19 <mux> at some point in time, a value has only a single type, sure - and it cannot ever have multiple types, if that's what you're asking
01:35:23 <Saizan> ketil: there are type systems for which a value has no most specific type
01:35:39 <mapreduce> mux: Does that definition of dynamic typing mean that Erlang is statically typed?
01:35:41 <Saizan> and so it has effectively multiple types
01:35:50 <mapreduce> because you cannot update a variable.
01:35:55 <ketil> mux: Sorry - in ref to "same variable can have different types".  A variable can hold different values, but any value has a single type.  No?
01:35:58 <mux> Saizan: didn't know about that
01:36:36 <mux> mapreduce: I don't know Erlang well enough to comment but AFAIK it's dynamically typed
01:36:40 <mapreduce> ketil: A value in an untyped language has a tag (they usually call this 'type', but if we're talking about static and dynamic in the same conversation, 'tag' is a better term)
01:36:53 <mux> ketil: a variable holds only one value at a specified point in time
01:36:55 <mapreduce> mux: It is.  I was pointing out a whole in a) your definition, or b) my interpretation of it
01:37:01 <mapreduce> s/whole/hole/
01:37:13 <mux> mapreduce: please substantiate :-)
01:37:39 <mapreduce> mux: If dynamic typing is where a variable can hold multiple types over time, then Erlang isn't dynamically typed.
01:37:40 <ketil> mapreduce, yes, and I should probably say "object" instead of "value", since that's what variables hold.  That is, an object might change its type.  I suppose.
01:37:40 <mux> the definition I've been giving is (to some degree of correctness depending on my memory) the one in TAPL
01:37:44 <ketil> How simple Haskell is!
01:37:48 <ketil> :-)
01:38:19 <mux> mapreduce: also, I find it actually even more intuitive to reason about compile-time checks vs runtime checks
01:38:20 <mapreduce> I don't have TAPL to hand atm. to look for that.
01:39:04 <mapreduce> mux: That's better, though one can imagine systems where compile-time and runtime are more interleaved, so that that doesn't help.
01:39:09 <mapreduce> E.g., Typed Scheme.
01:39:10 <Saizan> ketil: i'd say that without a formal definition of the "tag system" for the language in question it's a matter of opinion if some error belong to it or not
01:39:10 <mmorrow> Saizan: ooh, no. /me checks
01:39:39 <ketil> dynamic typing: a static type system with only a single type, which is a discriminated union of "dynamic types".
01:39:51 <mapreduce> ketil: In most languages claiming to have object support, an object cannot change which class it is of.
01:40:37 <ketil> mapreduce, I think this is possible in dynamic languages.  But perhaps I'm wrong about this.
01:40:37 <mapreduce> ketil: Nice.  Where's that from?
01:40:44 <mux> mapreduce: yes, it ain't a binary distinction
01:41:05 <ketil> mapreduce, from long-lost memories of Usenet discussions, mostly.
01:41:09 <mapreduce> ketil: It is theoretically possible, but I can't name a language in which it is definitely possible.
01:41:19 <mapreduce> Smalltalk, perhaps?
01:41:20 <mux> ketil: that is another definition I also quite like
01:41:54 <mmorrow> Saizan: hmm, what email did you send it to?
01:41:54 <Saizan> that last definition looks to much operational though :)
01:42:19 <ketil> mapreduce, duck-typing seems to fit the bill.  You change the "type" by changing the set of methods.
01:42:38 <Saizan> mmorrow: mmh, the one here http://hackage.haskell.org/package/hstidy
01:42:40 <ketil> mapreduce, I.e. the type of an object is defined by the messages it accepts/methods it supports.
01:42:45 <mapreduce> ketil: Ah, ok.  That's an even more informal idea of 'type'.
01:42:47 <mux> duck typing is like dynamic structural subtyping
01:43:01 <quicksilver> mapreduce: it's certainly possible in perl, which is one of the natural examples of a dynamic language claiming to have object support
01:43:06 <mmorrow> Saizan: ah gah, i've gotta update that. ok, checking that one.
01:43:07 <quicksilver> mapreduce: it's also possible in javascript
01:43:33 <mapreduce> There's not even any tag to check.  Duck typing is basically a predicate.  obj.doYouSupportTheseMethods('walk, 'quack)
01:43:52 <mapreduce> quicksilver: JavaScript doesn't have anything called classes, as I recall.
01:43:55 <ketil> So is it typing at all?
01:44:08 <mapreduce> ketil: No, like all dynamic typing, it is not typing. :)
01:44:15 <Saizan> mmorrow: that's why i don't like the definition that defines dynamic typing as a tag system
01:44:20 <Saizan> err, mapreduce ^^^
01:44:52 <ketil> Duck typing also means that a value belongs to a vast number of ad-hoc "types".
01:45:01 <mapreduce> Saizan: I see.  Perhaps it's better defined as "not having syntactic checks for types".
01:45:15 <quicksilver> mapreduce: it has prototypes which are the related structure.
01:45:17 <mapreduce> Yeah, 3 is an Int, and a Not(2) and a Not(1)..
01:45:20 <quicksilver> mapreduce: and you can change them.
01:45:24 <mmorrow> Saizan: ah nice, i've got it.
01:45:34 <mapreduce> quicksilver: Right.
01:46:11 <mapreduce> I had JavaScript in mind when I wrote the statement, which is why I was careful to write class instead of type.
01:46:25 <fasta> quicksilver: has there been any activity on the Haskell Emacs mode bug I reported?
01:46:57 <quicksilver> I can't remember what it was, fasta
01:47:26 <fasta> quicksilver: I sent you a reproducible case by email.
01:47:42 <fasta> quicksilver: you forwarded it to Kuribas.
01:47:47 <mux> I'll be even more radical and state that duck typing is structural subtyping implemented wrongly :-)
01:48:14 <mapreduce> mux: Is it actually structural subtyping rather than structural typing?
01:48:20 <mapreduce> I'm not sure where the sub comes from.
01:48:30 <mux> subtyping, since it defines a subtyping relation
01:48:56 <mux> allowing you to substitute one type by its subtype or by its supertype depending on the case
01:49:11 <Saizan> mux: why wrongly?:)
01:49:20 <fasta> It is really annoying when you press delete and get Illegal token: value (I think this is another issue).
01:49:26 <mux> Saizan: because it's dynamic ;-)
01:49:51 <etpace_> hmm, whats the best way to have interact with 'state'? as it seems interact calls the same function over and over?
01:51:27 <Saizan> etpace_: interact calls the function only once, giving it the full input
01:51:52 <fasta> Saizan: lazily, no?
01:51:58 <Saizan> fasta: yes
01:52:28 <etpace_> aha
01:52:39 <mmorrow> Saizan: nice, that's handy.
01:54:15 <mmorrow> Saizan: i wonder what it would take to add comments to haskell-src-exts, and also to have the option of recording *all* formatting of the input, and being able to prettyprint that (or a modified) AST *exactly* as it appeared in the input (but for the new parts default to whatever formatting or something)
01:54:19 <Saizan> mmorrow: now i'd need a pretty printer that suits my taste :)
01:54:41 <Saizan> mmorrow: the last version has some support for comments, apparently
01:54:43 <mmorrow> Saizan: yeah totally. i have my own hacked version of haskell-src-exts's Pretty module
01:55:29 <mmorrow> Saizan: i think i may have broken some parts of the prettyprinting with the no-layout option with my changes, but meh
01:55:45 <mmorrow> Saizan: oh nice
01:55:53 <fasta> mmorrow: I don't think _that_ much. It is just that in academic circles people never no that, because it gives no extra peer points :P
01:56:21 <mmorrow> fasta: heh
01:57:18 <Saizan> mmorrow: do you have that hacked Pretty module somewhere public?
01:57:31 <mmorrow> Saizan: no, but i was just making a diff actually... ;)
01:57:56 <etpace_> How does lazy IO work with interact then? It never seems to be fed the new state, so would get/put work for a 'board' game?
01:58:51 <fasta> etpace_: unsafeInterleaveIO
01:59:08 <etpace_> What's that?
01:59:14 <mmorrow> Saizan: it's against haskell-src-exts-1.0.0 though, i haven't had a chance to make fix all the little breaking changes that 1.1.0 surely has made (wrt the patch) yet
01:59:18 <fasta> etpace_: lazy IO in general is considered to be a hack.
01:59:33 <fasta> etpace_: for interact it has been proved informally at least that the use is safe.
02:00:02 <Saizan> etpace_: are you using the State monad?
02:00:04 <fasta> etpace_: unsafeInterleaveIO is basically delay, if you know Scheme.
02:00:19 <mmorrow> Saizan: updating my changes from 0.4.8 to 1.0.0 was slightly painful (whatever this random visual-diff prog i installed with yum is called was a lifesaver for that)
02:00:34 <fasta> etpace_: so, DELAY, in upper case, Lisp 1337 speak.
02:00:41 <mmorrow> "MELD diff viewer" it's called
02:01:02 <fasta> mmorrow: kdiff3 is also quite nice.
02:01:09 <etpace_> I havn't written the the interactiohnn part at all yet Saizan, so It would be wise to use state I think
02:01:16 <etpace_> :t unsafeInterleaveIO
02:01:18 <lambdabot> Not in scope: `unsafeInterleaveIO'
02:01:43 <fasta> etpace_: using unsafeInterleaveIO is sort of "advanced", but it is not that complicated.
02:01:48 <etpace_> I don't know any scheme, so what does it do/how would I use it?
02:02:53 <Saizan> etpace_: if you want to use the State monad and interact you'd have to call runState from inside the function you pass to interact, so the state threading will work as expected
02:04:09 <Saizan> etpace_: you should play a little with it to gain some intuition
02:04:55 <Saizan> etpace_: "unsafeInterleaveIO action" delays the execution side-effects of action until their results are needed
02:05:17 <Saizan> "of the side-effects"
02:05:38 <fasta> etpace_: yes, for what you want to do, you can do what Saizan says. If you want to understand unsafeInterLeaveIO, you should just read the chapter on force and delay in SICP and then try to understand the connection. I had to figure out the connection myself, so it's already easier for you.
02:06:29 <etpace_> ok
02:06:53 * Saizan understood unsafeInterleaveIO without knowing any scheme
02:09:19 <mmorrow> Saizan: here's a diff against a fresh haskell-src-exts-1.0.0 i just grabbed from hackage http://moonpatio.com/repos/haskell-src-exts-1.0.0_morrow-pretty.diff
02:09:37 <ManateeLazyCat> @seen dons
02:09:37 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
02:11:58 <mmorrow> Saizan: it's fairly messy and has a bunch of little special cases/micro-tweaks that i made incrementally, so fwiw..
02:12:42 <mmorrow> hmm, looking at that diff it's not nearly as bad as i thought
02:12:54 <ManateeLazyCat> dons: How do you consider keep Gtk widget state in dynamic application? Now, if i just can keep necessary information through reboot, after reboot rebuild all widget, if just few widgets will okay, but if application have 100 ~ 200 different widget, and have split current window with many different sub-window. Example 200 widget, and split 4 sub-window, so i need rebuild 400 widget after reboot, and this rebuild process will cost too
02:12:54 <ManateeLazyCat> much time. How do you think?
02:13:46 <ManateeLazyCat> rebuild 800 widgets after reboot.
02:14:01 <ManateeLazyCat> 200 x 4
02:15:17 <Saizan> mmorrow: mh, how do i apply the diff? (i'm too used to darcs patches :\)
02:15:57 <Botje> patch -p1 < patchfile
02:16:02 <Botje> if you're in the haskell-src-exts directory
02:16:41 <Saizan> ah, ok, i shouldn't have been scared by the prompt
02:18:40 <iabal> Someone knows how I could improve this code (to make it clearer and shorter) http://www.moonpatio.org/fastcgi/hpaste.fcgi/view?id=3479 ?
02:20:48 <mmorrow> Saizan: patch -p1 src/Language/Haskell/Exts/Pretty.hs < haskell-src-exts-1.0.0_morrow-pretty.diff
02:22:04 <mmorrow> ah, too late :)
02:23:24 <mmorrow> Saizan: i couldn't figure out how to have:
02:23:28 <mmorrow> foo = do
02:23:30 * ManateeLazyCat Looks just me at research how to write dynamic Gtk application..... 
02:23:30 <mmorrow>   ...
02:24:07 <mmorrow> err, i can't remember exactly what the problem was, but iirc weird interactions were happening
02:24:55 <mmorrow> Saizan: oh! ok so there's one bug actually i've noticed. lemme try to come up with a minimal case
02:25:29 <mmorrow> Saizan: echo -ne 'data A = A deriving(Show)' | hstidy
02:25:37 <mmorrow> Saizan: the "deriving" isn't indented
02:26:01 <mmorrow> but it only happens if there's one con
02:26:08 <mmorrow> e.g. echo -ne 'data A = A | B deriving(Show)' | hstidy
02:26:11 <mmorrow> is fine
02:26:13 <mmorrow> :/
02:27:49 * ManateeLazyCat Consider rebuild widgets concurrence, then will save much time.... :)
02:28:12 <doserj> iabal: my suggestion (untested): http://www.moonpatio.org/fastcgi/hpaste.fcgi/view?id=3479#a3480
02:28:27 <mmorrow> but if there's only one con, but it's a record-style con, then it's also ok
02:28:32 <Saizan> iabal: mine http://www.moonpatio.org/fastcgi/hpaste.fcgi/view?id=3479#a3481
02:30:48 <mmorrow> foldl' would be better for that too
02:31:26 <iabal> thanks doserj Saizan !
02:31:45 <mmorrow> iabal: s/foldr/foldl'/ would be faster and use less memory
02:31:58 <Saizan> yeah
02:32:06 <ManateeLazyCat> iabal: You can use hlint for code suggestions.
02:32:08 <mmorrow> but i guess in this particular case, the Sets may not be large enough to notice
02:32:14 <ManateeLazyCat> @hackage hlint
02:32:14 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlint
02:32:18 <mmorrow> (but still i'd personally use foldl')
02:32:32 <iabal> mmorrow: in that case is not valid
02:32:38 <iabal> [TyLabel x s, t]
02:32:41 <iabal> means x is bound in t
02:32:45 <mmorrow> iabal: ?
02:33:09 <mmorrow> iabal: (did you mean mmorrow?)
02:33:12 <iabal> I think (if I'm not missed) that I must use foldr
02:33:17 <mmorrow> oh
02:33:19 <mmorrow> ok, /me looks
02:33:43 <iabal> (TyLabel x s:ts)
02:33:51 <iabal> x is removed from ts free vars
02:34:03 <iabal> since x is bound in all ts
02:34:23 <mmorrow> iabal: well you can always reverse the incoming list first
02:34:35 <mmorrow> iabal: foldl' would be a lot better for the Set union
02:35:27 <iabal> uhmm, yep, foldl' ... . reverse
02:35:53 <iabal> thanks mmorrow
02:36:17 <Saizan> it's not really the size of the sets, but the length of ss that matters
02:36:37 <iabal> well, length ss will be small
02:36:41 <mmorrow> Saizan: true
02:36:51 <iabal> I don't know nobody who uses 1000-tuples
02:36:56 <Saizan> with foldr you'll consume O(length ss) stack
02:37:06 <iabal> 2 or 3 in most cases
02:37:39 <fasta> iabal: so, everyone is using 1000-tuples? ;)
02:37:57 <iabal> s/nobody/anybody ?
02:38:04 <mmorrow> , $(tupE (fmap lift [0..999::Int]))
02:38:04 <dmwit> No, nobody uses 1000-tuples, but he doesn't know the guy.
02:38:05 <lunabot>  luna: A 1000-tuple is too large for GHC
02:38:10 <mmorrow> :)
02:38:34 <Saizan> mmorrow: i guess that's because they have a foldr there!
02:38:38 <fasta> mmorrow: heh, you can dream the abstract syntax?
02:38:41 <mmorrow> Saizan: haha
02:38:52 <ManateeLazyCat> A 1000-tuple is too large for GHC ???
02:39:09 <fasta> It only goes to 15 or so?
02:39:11 <mmorrow> fasta: if by dream you mean build manually, then oh yesh
02:39:16 <dmwit> 63
02:39:17 <mmorrow> , $(tupE (fmap lift [0..63::Int]))
02:39:18 <lunabot>  luna: A 64-tuple is too large for GHC
02:39:21 <mmorrow> , $(tupE (fmap lift [0..62::Int]))
02:39:22 <lunabot>  luna: A 63-tuple is too large for GHC
02:39:24 <mmorrow> , $(tupE (fmap lift [0..61::Int]))
02:39:25 <lunabot>  luna: No instance for (GHC.Show.Show
02:39:40 <mmorrow> fasta: i think it's Show that only goes to 15
02:39:40 <dmwit> Huh, I could have sworn GHC could do 63-tuples.
02:39:41 <fasta> mmorrow: no, I mean that you know all the constructors by heart.
02:40:01 <mmorrow> fasta: heh, burned into my mind at this point :)
02:40:10 <fasta> mmorrow: WHY?
02:40:42 <dmwit> Aw, I thought that was lunabot being clever, but that's the actual verbatim error that GHC gives for 63-tuples. =P
02:41:19 <mmorrow> fasta: if you have to write any functions that transform TH ast to another haskell AST you get to know them pretty fast
02:42:20 <fasta> mmorrow: but don't your compile time skyrocket with TH?
02:42:27 <fasta> times*
02:42:40 <mmorrow> fasta: i always prettyprint the generated code, then include it statically in my code
02:43:04 <EnglishGent> sorry - another question... does ghc come with the source for the standard prelude, etc - or do I have to get all that seperately?
02:43:16 * EnglishGent would really like to look at how some of the built in stuff is implemented :)
02:43:32 <mmorrow> fasta: e.g. the commented ghci session at the top of http://moonpatio.com/repos/hsfft/GenFFT.hs
02:43:32 <fasta> EnglishGent: you just download the source distribution.
02:43:41 <mmorrow> fasta: to get http://moonpatio.com/repos/hsfft/fft_upto_128.hs
02:43:41 <EnglishGent> ty fasta
02:44:22 <luite> EnglishGent: you can also use the online documentation: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
02:44:28 <mmorrow> (the second ghci> line is extraneous)
02:44:39 <fasta> mmorrow: I think I already saw that one. Pretty nice.
02:45:25 <mmorrow> fasta: yeah, i definitely want to work on generating FFTs some more when i get a chance
02:45:39 <EnglishGent> ah! ty luite :)
02:45:45 <fasta> mmorrow: how does it compare to the Ocaml one?
02:45:58 <fasta> mmorrow: or rather the OCaml program creating the C program?
02:46:15 <mmorrow> fasta: i'm not sure actually, although i want to look at the internals of that one too
02:47:00 <fasta> mmorrow: I think you would hit #1 on Reddit if you publish a blog post on that, if you are an attention whore, that is ;)
02:47:13 <mmorrow> fasta: i read over the paper describing the implem of fftw a while back, seems interesting
02:47:21 <mmorrow> fasta: heh
02:47:26 <fasta> mmorrow: the best thing would be if you publish it either way, even if the Haskell is slower.
02:47:52 <fasta> (which it probably is, because the OCaml program is rather smart)
02:48:17 <fasta> So, it's essentially comparing apples and oranges... maybe not such a good idea then.
02:48:27 <mmorrow> fasta: yeah, it's doing a bunch (but not so much that you couldn't do the same with enough effort)
02:49:02 <fasta> If you would make it do the same thing, but then generating Haskell, instead of C and then compare, that would be really interesting.
02:49:02 <mmorrow> fasta: at the level of techniques though, i think it's fairly language indep
02:49:26 <dons> make sure you're doing the same thing , or don't claim a comparison
02:49:33 <mmorrow> fasta: it'd be extra cool if you could plug some sort of modular backed in to gen your language-of-choice
02:49:59 <fasta> mmorrow: people have been talking for years about modular compilers, but almost nobody actually does it.
02:50:21 <fasta> (except for the Lisp people, but they don't present it like that)
02:52:15 <mmorrow> fasta: might as well just generate vectorized SSE asm..
02:52:48 <mmorrow> or FPGA whatevers.. that would be really interesting
02:53:19 <fasta> mmorrow: yes, but one of the ideas of functional programming was that you didn't have to do that and would get these optimizations automatically. Of course, such a SSC might just not exist.
02:55:41 <mmorrow> fasta: i think that's true to the extent that you don't know a-priori more about what the code's doing than would be feasible for the compiler to automatically extract/figure out
02:56:57 <fasta> mmorrow: yes, practically, maybe having complicated compilers is not a good idea.
02:57:04 <mmorrow> and the case of FFTs is a pretty focused thing you're doing, so i think it'd be hard for a compiler that has to handle anything expressible in the language to beat a compiler that only knows how to compile FFTs and do it well
02:58:15 <stanv> please help: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8913#a8913
02:59:20 <fasta> stanv: the compiler already gives the answer.
02:59:34 <fasta> stanv: removing the type signature will probably fix it too.
03:00:29 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8917#a8917 I'm getting an identation error, any ideas?
03:00:29 <EnglishGent> okay....
03:00:31 <stanv> fasta: wich of two ?
03:00:43 * EnglishGent is confused again .. I thought I was beginning to figure this out
03:01:14 <EnglishGent> hpaste.org/fastcgi/hpaste.fcgi/view?id=8916#a8916
03:01:15 <Saizan> etpace_: you've to repeat do after then and else
03:01:43 <EnglishGent> why am I getting a type error? I thought source_files would be of type [FilePath]
03:01:46 <etpace_> aha
03:02:32 <Saizan> map (\x -> "/home/martin/test_a/" ++ x) source_files :: [String] so you can't use it in the do-block like that
03:03:01 <Saizan> if you're using the IO monad then in "x <- foo" foo must be of type IO Something
03:03:15 <Saizan> and then x will be of type Something
03:03:30 <EnglishGent> but getDirectoryContents is
03:03:36 <EnglishGent> @hoogle getDirectoryContents
03:03:37 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
03:03:40 <Saizan> yeah
03:03:48 <Saizan> but the error is not about getDirectoryContents
03:03:52 <Saizan> it's about "     source_files <- (map (\x -> "/home/martin/test_a/" ++ x) source_files) ;
03:04:12 <etpace_> I need to clean up the function I think
03:04:52 <EnglishGent> oh I see! I need to return that dont I? i.e. source_files <- return (map (\x -> "home/martin/test_a" ++ x) source_files)) ;
03:05:30 * EnglishGent thought it was whining about source_files variable on the right!
03:05:36 <EnglishGent> ty! :)
03:06:08 <doserj> what is that line supposed to do anyways?
03:06:11 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8916#a8918 <- both work
03:06:34 <stanv> how to stop instance definition ?
03:06:53 <Saizan> stanv: what do you mean?
03:07:03 <stanv> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8913#a8913
03:08:25 <Saizan> etpace_: also the "if" after let b' = .. should be aligned with let, or be wrapped in parentheses and indented more to be an argument to moveTo, depending on what you want to do
03:08:57 <doserj> stanv: did you try what the error message suggests?
03:09:07 <fasta> EnglishGent: you can just do f <- bar; let a = 3; return 1
03:09:15 <fasta> EnglishGent: you don't need the {} pairs.
03:09:37 <fasta> EnglishGent: using a<-return bar is a bad thing.
03:10:16 <stanv> doserj: no
03:11:26 <EvilTerran> fasta, well, it can be useful when "a" is a refutable pattern
03:11:40 <Saizan> or when you want to shadow a variable
03:12:56 <fasta> For 99% of the cases what I said is the right thing to do. Otherwise we could just stop talking, since there is no universal rule to programming.
03:15:03 <Saizan> it didn't took lots of time to add a few exceptions :)
03:17:07 <Saizan> stanv: do you understand why you get that type error?
03:18:53 <Saizan> stanv: from its type signature compare' promises to be able to work for any type that it's an instance of Ord, so you can't use methods from Visable on those values because their types might not be members of that class
03:19:41 <Saizan> stanv: if you remove the type signature on compare' ghci will be able to infer the correct one for you
03:21:45 <stanv> Saizan: I'm stupid..... I thought thar 'size' method is standard
03:21:49 <stanv> that*
03:21:59 <stanv> in class Ord
03:22:20 <stanv> but Ord doesn't have 'size' method
03:22:47 <fasta> stanv: that is exactly the problem.
03:23:29 <fasta> stanv: you say it works for all types which are in the Ord class, but in fact the compiler proves to you that it doesn't, by providing a counter example.
03:24:48 <stanv> :)) the problem is in my absent-mindedness :))
03:25:54 <stanv> music volume to high :(
03:32:19 <yitz> EnglishGent: let full_paths = map ("home/martin/test_a" ++) source_files
03:33:00 <ManateeLazyCat> @hoogle "Maybe a -> (a -> b) -> Maybe b"
03:33:00 <lambdabot> Parse error:
03:33:00 <lambdabot>   --count=20 ""Maybe a -> (a -> b) -> Maybe b""
03:33:00 <lambdabot>              ^
03:33:08 <ManateeLazyCat> @hoogle Maybe a -> (a -> b) -> Maybe b
03:33:09 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
03:33:09 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
03:33:09 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
03:33:46 <yitz> flip fmap?
03:34:05 <yitz> @type flip fmap
03:34:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
03:34:28 <yitz> @type <$>
03:34:30 <lambdabot> parse error on input `<$>'
03:34:31 <Peaker> does hoogle know to suggest fmap because Maybe is an instance of Functor or would it suggest it anyway?
03:34:35 <yitz> @type (<$>)
03:34:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:35:00 <yitz> @hoogle Peaker a -> (a -> b) -> Peaker b
03:35:01 <lambdabot> Warning: Unknown type Peaker
03:35:01 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
03:35:01 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
03:35:08 <yitz> Peaker: are you a functor?
03:35:31 <Peaker> :-)
03:37:47 <stanv> hmmm.. strange that i can't define my own method `>' in my own class: Ambiguous occurrence `>' It could refer to either `Ex12.>', defined at 12.hs:145:12 or `Prelude.>', imported from Prelude
03:38:38 <doserj> classes don't provide a separate namespace
03:38:42 <Cale> stanv: You can, it just becomes ambiguous which one you mean at that point. You'll have to import the Prelude hiding (>) or else use the qualified name.
03:39:52 <Cale> But a better idea is probably not to define names which conflict with the Prelude unless you have a really good reason.
03:40:22 <brian6> possible to generate haddock comments in th?
03:40:57 <Cale> brian6: I would be quite surprised...
03:42:07 <Cale> brian6: You should be able to write haddock comments in source files which use TH and have them show up, but the generated code doesn't exist in a form which haddock will parse, TH works at the level of abstract syntax.
03:42:14 * Saizan wants a Semigroup a => Monoid (Maybe a) instance
03:42:33 <ManateeLazyCat> @hoogle Monad m => Maybe a -> (a -> m (Maybe b)) -> m (Maybe b)
03:42:34 <lambdabot> No results found
03:43:03 <Saizan> ManateeLazyCat: it looks like you want MaybeT
03:43:08 <Saizan> @hackage MaybeT
03:43:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT
03:46:13 * ksf wants a syntactic extension to painlessly create a bottom value of any type.
03:48:05 <ksf> and I found a ghci bug.
03:48:18 <ManateeLazyCat> @let maybeTest a f = case a of Just aa -> f aa; Nothing -> return Nothing
03:48:19 <lambdabot>  Defined.
03:48:24 <ManateeLazyCat> @type maybeTest
03:48:25 <lambdabot> forall t (m :: * -> *) a. (Monad m) => Maybe t -> (t -> m (Maybe a)) -> m (Maybe a)
03:48:32 <ksf> ...it loads a TypeFamilies pragma just fine, but then chokes on ~ syntax, demanding the pragma.
03:59:29 <ksf> @faq can haskell give me IO on the type level?
03:59:30 <lambdabot> The answer is: Yes! Haskell can do that.
04:07:20 <FunctorSalad> ksf: painlesser than (undefined::Foo)?
04:07:30 <FunctorSalad> (how would that be possible?)
04:07:40 <FunctorSalad> unless it can be inferred of course
04:07:55 <yitz> @djinn (t -> f (g a)) -> g t -> f (g a)
04:07:56 <lambdabot> -- f cannot be realized.
04:08:24 <yitz> @hoogle (t -> f (g a)) -> g t -> f (g a)
04:08:24 <lambdabot> No results found
04:09:42 <yitz> ManateeLazyCat: maybeTest = maybe (return Nothing) f
04:19:48 <Axman6> @djinn (t -> Either (Maybe a)) -> Maybe t -> Either (Maybe a)
04:19:49 <lambdabot> Error: kind error: (KVar 3,KStar)
04:20:13 <Axman6> @djinn (t -> Either () (Maybe a)) -> Maybe t -> Either () (Maybe a)
04:20:14 <lambdabot> f a b =
04:20:14 <lambdabot>     case b of
04:20:14 <lambdabot>     Nothing -> Left ()
04:20:14 <lambdabot>     Just c -> a c
04:37:08 <stanv> each C++ class can have his own operators. but in haskell all namespace is one for all :(
04:37:38 <Saizan_> right
04:37:54 <Saizan_> you use modules to deal with namespaces
04:38:17 <Saizan_> also, OO classes and type classes are quite different things
04:40:03 <Twey> C++ ‘classes’ have suffered feature-creep.
04:40:13 <Twey> They are still classes, but they're also namespaces.
04:40:41 <Twey> Haskell doesn't do that.  Modules, and modules alone, have the task of namespacing.
04:40:57 <Jafet> They work well enough for C++.
04:41:09 <pr> still they suck
04:41:15 <Jafet> Just like C++.
04:41:18 <pr> right
04:41:35 <Jafet> Are haskell types structurally compatible, like in ML?
04:42:28 <Twey> Jafet: Not automatically
04:52:20 <Lemmih> Is the code for hoopl available somewhere?
04:59:07 <maxote> @go STM machine
04:59:09 <lambdabot> http://www.springerlink.com/index/NW11R40536468666.pdf
04:59:09 <lambdabot> Title: SpringerLink Home - Main
04:59:39 <maxote> is it a shop? remove springer from it!
04:59:48 <maxote> @go STM machine -springer
04:59:50 <lambdabot> http://www.springerlink.com/index/NW11R40536468666.pdf
04:59:50 <lambdabot> Title: SpringerLink Home - Main
05:00:46 <Peaker> how does jhc compare to ghc in comprehensive support of Haskell+extensions, and in optimizations?
05:02:11 <Axman6> seems to optimise quite well, but i don't think it supports many (any?) extensions
05:05:26 <quicksilver> Peaker: I don't think jhc is at the point yet where it is fair to compare
05:05:44 <quicksilver> it supports very few extensions,
05:06:06 <quicksilver> ...its optimiser is very clever and does some things well but I don't believe it is anything like as 'broad' as GHCs
05:06:30 <flux> so you can actually build a software of decent size in jhc these days and expect it to do it with bounded memory?
05:06:43 <flux> also, it has gc in addition to region inference?
05:06:59 <quicksilver> I believe the answers to that is "no;no"
05:07:27 <Saizan_> i think it uses the bohem gc
05:09:27 <Lemmih> flux: GHC vs. JHC vs. LHC vs. UHC: http://darcs.haskell.org/~lemmih/nobench/x86_64/results.html
05:10:09 <Lemmih> flux: It's not a fair benchmark, though.
05:10:23 <Lemmih> (if those even exist)
05:12:04 <Saizan_> i wonder why so many segfaults
05:12:14 <Peaker> Bohm GC :-(
05:12:16 <Lemmih> Saizan_: Stack overflows.
05:14:45 <Saizan_> ah
05:15:22 <Lemmih> The alternative haskell compilers are a sorry bunch.
05:16:19 <Lemmih> ketil: Do you run blog.malde.org?
05:16:31 <ketil> Lemmih, maybe.  Who wants to know? :-)
05:16:34 <ketil> Okay, yes.
05:17:24 <Lemmih> ketil: I'd like to take a stab at parsing integers. Is your repo publicly available?
05:18:43 <ketil> Lemmih, great!  Yes, everything's available (of course).
05:19:32 <etpace_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8920#a8920 another parsing error, but adding a do on line 10 complains that the last line of a do has to return, any ideas?
05:20:05 <ketil> Do you want the full (but embarassingly crummy) file parser or the small, rather synthetic benchmark with unreasonable constraints? :-)
05:20:23 <doserj> etpace_: the else should align with the then
05:21:21 <Lemmih> etpace_: And your first 'if' is also misaligned.
05:21:48 <doserj> as is the second, and the second then-else branches...
05:22:16 <etpace_> so much for this auto=align .vim
05:25:42 * ketil drums his fingers.
05:25:57 <Saizan_> ketil: i'll take the small benchmark
05:28:17 <ketil> Okay: I put some stuff at http://malde.org/~ketil/biohaskell/qualparsetest/
05:28:38 <ketil> test.hs contains some different versions, input.qual is the input file to use.
05:29:53 <ketil> Note that the breaking into lines is an artifact of old code, but to be useful to my ends, you need to sort out the lines starting with '>'.
05:31:05 <Saizan_> ah
05:39:06 <benmachine> it's never occured to me to bind infix operators in a pattern-match before
05:39:14 * benmachine just wrote foldr (**) b (a:as) = a ** foldr (**) b as
05:39:58 <idnar> @src on
05:39:58 <lambdabot> (*) `on` f = \x y -> f x * f y
05:42:35 <Peaker> @pl (*) `on` f = \x y -> f x * f y
05:42:35 <lambdabot> (line 1, column 12):
05:42:36 <lambdabot> unexpected "="
05:42:36 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
05:42:50 <Peaker> @pl star `on` f = \x y -> f x `star` f y
05:42:50 <lambdabot> (line 1, column 13):
05:42:50 <lambdabot> unexpected "="
05:42:50 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
05:43:02 <Peaker> @pl on star f = \x y -> f x `star` f y
05:43:02 <lambdabot> on = join . ((flip . ((.) .)) .) . (.)
05:43:08 <Makoryu> @hoogle (:+)
05:43:08 <lambdabot> Warning: Unknown type :+
05:43:08 <lambdabot> Prelude undefined :: a
05:43:08 <lambdabot> Data.Array.Base arrEleBottom :: a
05:43:25 <Peaker> @type on
05:43:27 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:43:33 <Axman6> > 1 :+ 2
05:43:34 <lambdabot>   1.0 :+ 2.0
05:44:33 <quicksilver> > sqrt ( -1 :+ 0 )
05:44:34 <lambdabot>   Precedence parsing error
05:44:34 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
05:44:40 <quicksilver> > sqrt ( (-1) :+ 0 )
05:44:41 <lambdabot>   0.0 :+ 1.0
05:46:09 <Makoryu> That unary (-) is always gonna bother me
05:46:15 <Peaker> @type (:+)
05:46:16 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
05:46:26 <Peaker> > (-1) ** 0.5 :: Complex Double
05:46:28 <lambdabot>   6.123233995736766e-17 :+ (-1.0)
05:46:40 <Peaker> floating point :-(
05:47:21 <Makoryu> All right: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8922#a8922
05:47:39 <Makoryu> I'm gonna try my hand at writing a J interpreter
05:48:03 <quicksilver> Peaker: well, you need exp and log to work.
05:48:29 <quicksilver> > (-1) ** 0.5 :: Complex CReal
05:48:30 <lambdabot>   0.0 :+ 1.0
05:48:31 <Peaker> quicksilver: Symbolic is too slow, numeric is so ugly. Computers suck at math
05:48:38 <quicksilver> right.
05:49:18 <quicksilver> > exp ( 0 :+ pi ) :: Complex CReal
05:49:19 <lambdabot>   (-1.0) :+ 0.0
05:50:12 <Makoryu> @src CReal
05:50:12 <lambdabot> Source not found. My mind is going. I can feel it.
05:50:43 <quicksilver> Makoryu: @src is for (a very limited selection of) basic types + functions
05:50:50 <quicksilver> Makoryu: CReal is defined by the numbers package on hackage
05:50:58 <Makoryu> quicksilver: Ah, gotcha
05:51:01 <quicksilver> it's arbitrary precision arithmetic
05:54:37 <benmachine> nothing to do with CInt et al then?
05:54:43 <quicksilver> no
05:54:49 <quicksilver> arguably a poor choice of name
05:54:59 <quicksilver> "CInt" - "The int type from C"
05:55:04 <quicksilver> "CReal" - "computable real number"
05:55:21 <benmachine> oh, computable
06:00:48 <Makoryu> > 0 < infinity
06:00:49 <lambdabot>   True
06:01:28 <etpace_> > max 0 (-infinity)
06:01:30 <lambdabot>   * Exception: Natural: (-)
06:01:36 <etpace_> :t infinirt
06:01:38 <lambdabot> Not in scope: `infinirt'
06:01:42 <etpace_> :t infinity
06:01:43 <lambdabot> Natural
06:03:02 <Makoryu> etpace_: infinity = S infinity -- Definition from Data.Number.Natural
06:03:41 <Berengal> infinity = fix S
06:04:45 <etpace_> Is there an identity element for max/min?
06:05:01 <doserj> minBound/maxBound
06:05:30 <benmachine> if you're not Bounded then no
06:05:57 <Berengal> Is Natural Bounded?
06:06:11 <benmachine> > (minBound, maxBound) :: (Natural, Natural)
06:06:13 <lambdabot>   No instance for (GHC.Enum.Bounded Data.Number.Natural.Natural)
06:06:13 <lambdabot>    arising f...
06:06:13 <etpace_> > foldl (\acc x -> min acc x ) maxBound [2,5,9,2,1,4,0]
06:06:14 <lambdabot>   Add a type signature
06:06:18 <benmachine> apparently not.
06:06:27 <Berengal> minBound is easily 0, but it has no maxBound
06:06:31 <etpace_> > foldl (\acc x -> min acc x ) maxBound [2,5,9,2,1,4,0] :: Int
06:06:33 <lambdabot>   0
06:06:36 <benmachine> it has infinity
06:06:46 <Berengal> infinity isn't a bound...
06:06:53 <benmachine> suppose not
06:07:02 <Berengal> But it's still an identity for min
06:11:05 <mux> @check \(x::Int) -> min minBound x == minBound
06:11:06 <lambdabot>   Parse error in pattern at "->" (column 11)
06:11:22 <mux> @check \x -> min minBound (x::Int) == minBound
06:11:24 <lambdabot>   "OK, passed 500 tests."
06:11:51 <benmachine> @check \x -> min (minBound + 1) (x :: Int) == minBound + 1
06:11:53 <lambdabot>   "OK, passed 500 tests."
06:12:09 <benmachine> 500 isn't going to quite cut it, I suspect
06:12:36 <benmachine> (although imo if I could test 3 Ints I'd test 0, minBound, and maxBound)
06:16:21 <Berengal> I've got a bunch of coordinates I need to match up against another bunch of coordinates disregarding scale or rotation, and one of the bunches are quite probably lacking a few coordinates as well. Anyone done something like this before?
06:25:44 <hackagebot> property-list 0.0.0.3 - XML property list parser (JamesCook)
06:26:22 <jfoutz> that sounds really hard. all the fun of np-complete, plus the added bonus of worrying about rounding errors when rounding and scaling.
06:27:00 <jfoutz> er, rotating and scaling
06:27:44 <hackagebot> property-list 0.0.0.1.1 - XML property list parser (JamesCook)
06:37:31 <Lanjiao> p = \x -> (if x' == Nothing then Nothing else Just (x', x') where x'=x)
06:37:45 <Lanjiao> test.hs:17:60: parse error on input `where'
06:37:56 <Lanjiao> how can I fix this problem? thanks!
06:38:55 <ski>   p = \x -> let x' = x in if x' == Nothing then Nothing else Just (x',x')
06:39:03 <ski>   p x = if x' == Nothing then Nothing else Just (x',x')
06:39:05 <ski>     where
06:39:06 <ski>     x' = x
06:39:38 <ski>   p x = fmap (\_ -> (x',x')) x'
06:39:40 <ski>     where
06:39:42 <ski>     x' = x
06:40:10 <ski> Lanjiao : any of those work for you ?
06:41:57 <FunctorSalad> jfoutz: this is np-complete? (disregarding that we haven't really defined the prob ;))
06:42:03 <ski> Lanjiao_ : see end of <http://tunes.org/~nef/logs/haskell/09.09.01>
06:42:18 <Lanjiao_> ski: thanks, i'll check
06:42:32 <benmachine> p x = x' >> (x', x') where x' = x
06:42:35 <benmachine> maybe
06:43:04 <ski> you'd need s/(x',x')/return (x',x')/
06:43:12 <benmachine> oh yeah
06:43:13 <jfoutz> FunctorSalad: if elements are missing, it sure seems like you have to try every combination. initialy i was thinking of pca on both datasets, then rotating... but that fails with missing data
06:43:34 <benmachine> p x = x' >> return (x', x') where x' = x
06:43:44 * ski presumes that the actual definiendum in  x' = x  is more complicated
06:43:45 <Lanjiao> ski: so, the where clause can't be used in lambda expr like \x-> ...........?
06:44:21 <ski> `where' attaches to equations (and `case' branches), not to expressions
06:44:49 <Lanjiao> and how about let-in?
06:44:55 <ski> so if you need to do some local definitions on an expression, use `let ... in ...'
06:45:24 <Lanjiao> ski: thanks, will have a try
06:45:29 <CalJohn> Lanjiao: i don't think you can really use anything in a lambda in haskell, not guards, at least
06:45:51 <FunctorSalad> jfoutz: but not every combination is possible (e.g. in 2d mapping one triangle will fix the rotation)
06:45:53 <CalJohn> i think the logic is that if the function is non-trivial it should be given a name
06:45:59 <FunctorSalad> jfoutz: I agree it seems hard though
06:46:31 <jfoutz> FunctorSalad: i guess n is bounded by the number of dimensions
06:46:41 <FunctorSalad> at least if the input size is the dimension... then you have 2^n coordinatewise flips already
06:47:05 <Berengal> Well, it'll be 2d
06:48:53 <Berengal> My initial idea was to somehow normalize the coordinates and hash the resulting structure according to some ancient arcane hashing algorithm handed down by the gods, but that's very suceptible to small deviations
06:49:31 <Jafet> Deviation will be punished severely
06:49:37 <Berengal> It will
06:49:49 <FunctorSalad> couldn't you parameterize the transformation and put it into a general-purpose nonlinear optimizer?
06:49:56 <FunctorSalad> not that many params in 2d
06:49:59 <Botje> Berengal: you could rotate a beam from the center of mass and note the angles between points?
06:50:26 <Jafet> A good first step might be to rewrite all your points into polar form
06:50:35 <Berengal> Botje, where's the center when you might have points missing?
06:50:45 <Jafet> Then you can separate the processes of rotation and scaling.
06:50:49 <Berengal> Thought that is a good idea
06:51:20 <Jafet> (True, you'd have to find the center. Perhaps find the convex hull and its centroid.)
06:51:46 <Berengal> Oh, and the coordinates have weights as well, where the more weight something has the more likely it is to not be missing
06:51:48 <Jafet> Or several convex hulls, to compensate for missing points.
06:52:31 <RayNbow> hmm... Intel seems to be working on x86 cpus for cellphones... does this mean we can easily run GHC in the near future on our phones? :p
06:52:46 <jfoutz> hmm. sort by weight? match heaviest to heaviest?
06:52:55 <jfoutz> that seems much easier
06:52:58 <Botje> x86 is terribly wasteful
06:53:09 <FunctorSalad> RayNbow: "can't talk now, I need to compile gtk2hs!"
06:53:20 <FunctorSalad> o_O
06:53:26 <luite> RayNbow: I believe it already runs on the iphone, which has an ARM cpu
06:53:26 <RayNbow> Botje: well yeah, it might not be very battery friendly
06:53:29 <Berengal> jfoutz, as with everything else, the weights may not match up exactly...
06:53:31 <Jafet> Short monadic service
06:53:33 <Botje> 8 registers is simply not enough :)
06:53:36 <RayNbow> luis: I don't have an iPhone :p
06:53:49 <Berengal> Perhaps I should define the problem a bit better...
06:53:52 <RayNbow> luite *
06:53:52 <jfoutz> Berengal: yeah, but it's only one dimension of error. seems much easier
06:54:17 <luite> RayNbow: your htc something phone also has an arm, so you just have to port it to windows mobile :p
06:54:40 <jfoutz> unless the weights are really inaccurate vs positions
06:54:43 <Jafet> You can view your set of points as vertices of a planar graph.
06:54:46 <Berengal> Given a picture of the night sky, find the piece of sky it's a picture of
06:54:50 <Jafet> Then you can match edges.
06:55:09 <Jafet> (And you can even match locally against known constellations.)
06:56:47 <Berengal> RayNbow, http://en.wikipedia.org/wiki/N900
06:57:49 <RayNbow> Berengal: I've seen a video of it recently
06:58:22 <luite> RayNbow: and? you think it's too slow? :)
06:58:34 <Berengal> Given that my current cell is a pos, I've been drooling a bit over that one...
06:58:36 <RayNbow> not impressed by the qwerty kb
06:58:54 <RayNbow> http://www.engadget.com/2009/08/27/nokia-n900-running-maemo-5-officially-500-in-october/
06:58:59 <RayNbow> only 3 rows :p
06:59:13 <luite> is that really a problem?
06:59:41 <RayNbow> luite: my old HTC Wizard has 4 rows and my current HTC Touch Pro 2 has 5 rows
06:59:59 <RayNbow> and they're comfortable keyboards
07:00:32 <luite> the location of the space bar may take some getting used to but other than that, it looks ok to me
07:00:43 <luite> but I haven't actually used it, obviously
07:01:33 <Berengal> Finnish-english is so hillarious to listen to...
07:02:27 <RayNbow> http://www.blogcdn.com/www.engadget.com/media/2009/02/htc-touch-pro2-hands-on-1.jpg <-- luite
07:02:35 <RayNbow> dedicated number row = awesome
07:03:16 <RayNbow> anyway, a 3 rows keyboard may suffice if you don't type a lot
07:03:36 <Berengal> I was very unimpressed by windows mobile, back when I had a htc myself
07:04:53 * RayNbow can live with some of the shortcomings of WM
07:06:39 <Berengal> What I miss the most about it was x-com...
07:06:54 <RayNbow> x-com?
07:06:57 <Berengal> The game
07:07:04 <jfoutz> hahahaa. awesome.
07:07:10 <jfoutz> that was a fantastic game.
07:07:35 <Berengal> Indeed it was. Spent many long hours on the bus with that one.
07:08:34 <Botje> they made an x-com port to windows mobile?
07:10:23 <Berengal> What I don't miss is how the phone crapped out on me and died. It's successor, my current phone, is a cheapo monochrome-display one, which only features are: can make and receive calls, send and receive texts, store contacts, has a flashlights and an alarm function
07:10:42 <Jafet> In other words, a mobile phone
07:10:47 <Berengal> Indeed
07:10:49 * Twey chuckles.
07:11:04 <Berengal> Oh, and it's got a kick-ass battery lifetime, and survives being run over by cars
07:11:05 <Twey> Plus flashing lights and alarms
07:11:54 * RayNbow mainly uses his WM phone to receive calls and browse the web
07:12:17 <Berengal> I've never been this happy with a mobile phone since I got my first one, which did pretty much the same (except the flashlight)
07:12:20 <RayNbow> (I don't make an awful lot of calls)
07:13:23 <Berengal> Though if someone ports ghc to maemo, the N900 is a definitive buy
07:13:48 * Twey is still waiting for OpenMoko.
07:15:03 <fasta> Twey: until GHC works on OpenMoko you mean?
07:17:03 <Twey> Haha
07:17:07 <Twey> That too :þ
07:17:33 <fasta> Twey: so, then what were you waiting for?
07:21:05 <dino-> Twey: You can have mine. Kind of a disappointment even before it got bricked by running out of battery power.
07:24:08 <Lemmih> Twey: Didn't they cancel the project?
07:34:28 <lispy> Lemmih: how is LHC going?  I see that JHC just had a release
07:34:32 <lispy> still no GC
07:35:02 <Lemmih> lispy: LHC is improving rapidly.
07:35:22 <lispy> Which areas?
07:35:46 <lispy> also: let me know when darcs compiles; that would be kinda cool
07:36:00 <lispy> (we use like 1,000,000 extensions thoughH)
07:36:33 <Lemmih> lispy: Correctness and performance mostly. Accurate GC and exceptions are still far in the future.
07:37:34 <Lemmih> lispy: You can follow the progress here: http://darcs.haskell.org/~lemmih/nobench/x86_64/results.html
07:38:37 <benmachine> > [False..True]
07:38:38 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
07:38:45 <benmachine> ^ what's going on here
07:38:50 <benmachine> oh hmm
07:39:01 <benmachine> > [False .. True]
07:39:02 <lambdabot>   [False,True]
07:39:05 <benmachine> how awkward
07:39:10 <Lemmih> benmachine: Yeah /-:
07:39:41 <Botje> heh. cute.
07:39:50 <lispy> Lemmih: cool.  Much more correctness than jhc, but slower too?
07:39:56 <Botje> is there a module called False, then?
07:40:01 <benmachine> no
07:40:06 <Saizan_> no, but there could be
07:40:20 <lispy> import False
07:40:31 <lispy> or, import False hiding (True)
07:40:45 <Botje> >:)
07:40:57 <benmachine> so what happens if I do
07:41:02 <benmachine> import Just
07:41:21 <benmachine> instance Functor Maybe where fmap f (Just x) = Just.f$x
07:41:25 <Lemmih> lispy: I do very few optimizations. My main focus has been on setting up a correct framework for translating Haskell to GRIN and GRIN to C.
07:41:49 <benmachine> probably something horrible.
07:41:51 * FunctorSalad likes the twist on circular acronyms in "The Luxurious LHC Haskell Optimization System"
07:42:15 <Lemmih> lispy: LHC still beats JHC more often than not.
07:42:25 <lispy> Lemmih: cool :)
07:42:46 <lispy> Lemmih: and having a slow correct program is better than a fast one that doesn't compile or gives the wrong results
07:43:10 <lispy> So those examples where JHC doesn't even compile are much worse than being just behind i
07:43:13 <lispy> it*
07:43:18 <Lemmih> lispy: My thoughts exactly.
07:45:03 <Lemmih> I plan on soon making a dent in the "real" category.
07:47:04 <lispy> Lemmih: are some of the programs in the real category incorrect?  I see some compiler errors on ghc
07:50:54 <Lemmih> lispy: I told GHC to ignore the haskell98 package. I want as few package dependencies as possible.
07:52:08 <lispy> ah
07:52:40 * lispy is excited about starting at Galois in October!
07:53:27 * Lemmih is envious about Jason starting at Galois in October!
07:54:03 <Axman6> ok, Grand Central Dispatch is officially awesome. makes writing concurrent code in C almost as easy as in Haskell
07:55:06 * Saizan_ too
07:58:01 <luite> Axman6: do you have some examples?
07:58:38 <gogonkt> c
07:58:56 <lispy> Axman6: is GCD something that Apple made?
07:59:04 <Axman6> you can start with http://arstechnica.com/apple/reviews/2009/08/mac-os-x-10-6.ars/12 and i've just written a (massively) parallel program that performs beautilly
07:59:10 <Axman6> beautifully*
07:59:12 <Axman6> yeah
07:59:48 <Axman6> it's amazing how little work is needed to now have work performed concurrently
08:00:17 <Makoryu> And very much a good thing.
08:00:26 <Makoryu> :t on (==)
08:00:28 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
08:01:31 <HugoDaniel> hi
08:02:40 <lispy> Axman6: what is it about GCD that makes it so much easier than other abstractions?
08:04:34 <Axman6> lispy: http://pastie.textmate.org/601722 shows my program, which performs 2^32 functions, concurrently. i didn't have to set up threads or decide how many i would need, and there is no boilerplate. just an import, and some new syntax (^(size_t i){...} is an anonymous function)
08:04:46 <luite> does it use some preprocessor tricks, or is this ^-thing standard objective C syntax?
08:04:46 <Makoryu> lispy: GCD is a thread pool managed by the OS. To help write programs that use it, Apple also added lambda expressions and some other stuff to its C dialects
08:04:46 <jorick> hmm, i just did "zf create controller player" and then i went to /player ... it gives me a 404 and the playercontroller file isn't loaded ...
08:04:54 <jorick> whoops wrong channel sorry
08:04:56 <lispy> Do any of you guys know how the vista/windows7 security model changes affect building binaries?  It seems like vista/windows7 does something different with things like cabal.exe and darcs.exe than xp
08:05:11 <Makoryu> luite: It's a C extension
08:05:19 <Makoryu> luite: You can use GCD in regular C programs
08:05:35 <luite> Makoryu: also supported by a regular gcc?
08:05:37 <Makoryu> The extension is supported by both GCC and clang
08:06:31 <Makoryu> Hell, GHC could probably use this for its threaded runtime
08:06:34 <lispy> Axman6, Makoryu: cool thanks for the summary
08:07:00 <Axman6> luite: the ^ syntax is an extension Apple have introduced to C, and will likely propose its addition to C at some point
08:07:55 <Axman6> luite: basically, these blocks are lambdas, with the same scope as where they were created (so they can work on variables external to the block
08:08:11 <Peaker> Axman6: GCD seems pretty standard - except for its mangling into the OS
08:08:37 <Axman6> it's doind pretty standard stuff, in a very elegant way
08:09:28 <mux> I really don't see those extensions getting into the C standard anytime in the future
08:09:46 <Peaker> oh I just read that page assuming it was a summary. Seems they extended the language too?
08:09:49 <luite> Axman6: ah. are there some limitations, for example, can you return a pointer to a lambda?
08:10:21 <Axman6> i'm not sure
08:10:49 <luite> access to the same variables in scope seems tricky too, if the lambda is called multiple times from different threads
08:10:54 <Axman6> i think they're a lot like function pointers, but with a different scope.. but don't quote me, i'm no expert on C or blocks ;)
08:12:01 <Peaker> I think if you add lambdas to C you get a lot of troubles -- many nice abstractions are extremely difficult to execute in a GC-less environment
08:12:41 <Axman6> they're not really lambdas
08:12:55 <Jafet> GC is only really required for functional programming, like closures and continuations
08:13:05 <Makoryu> luite: IIRC, you can't return a lambda outside the function that creates it
08:13:11 <Jafet> Unnamed procedures work just fine in a stack environment.
08:13:17 <Axman6> best to go read the Ars article, it should explain it better
08:15:04 <Axman6> OpenCL is pretty cool too, but probably a little harder to use
08:17:18 <lispy> Axman6: we have a Haskell lib for OpenCL though
08:17:42 <Axman6> yeah. it doesn't look all that easy to use atm (waiting for the higher level version)
08:17:45 <lispy> Actually, I found OpenCL amusing, because back in like Nov or December I sent a joke email to the darcs list saying we would rewrite darcs to run on the GPU
08:18:03 <lispy> and now we could...
08:18:07 <Axman6> indeed :)
08:18:11 <Axman6> and the Cell >_>
08:18:50 <lispy> The darcs feature set could include "GPU based calculations" and "Fully 3d vcs.  Putting the d back in dvcs."
08:19:44 <Axman6> they're using OpenCL in Core Image now, supposed to give a 25% performance boost.
08:20:33 <Axman6> (Core Image is apple's live image manipulation framework, allowing you to dynamically, and non-destructively manipulate images in real time. even works with live video)
08:20:41 <edwardk> lispy: the problem there is the lack of any coherent write order in the patch semantics =P
08:22:13 <edwardk> i do think that opencl has some nice opportunities for doing some 'fusion' like operations though, when you know you are generating a vector element by element using reads from lots of inputs
08:32:20 * lispy needs to work more on documenting what repository operations darcs does
08:32:46 <lispy> I think it's probably possible to abstract it away into a transactional api
08:32:58 <lispy> and hopefully simply the internals
08:33:21 <lispy> I'm guessing there is a TransactT monad transformer hiding in there for filesystem transactions
08:35:22 <Peaker> Jafet: "Unnamed procedures work just fine in a stack environment"?  What if you want to return them or store them in variables?
08:36:22 <Jafet> Procedures aren't first class in C. Badum tish.
08:36:52 <lilac> it needs to be possible to pass them around or they're utterly useless, no?
08:37:10 <Jafet> Not really. Consider qsort.
08:37:28 <lilac> Jafet: exactly, you /pass a function/ (or pointer thereto) to it
08:37:40 <Jafet> You pass a function pointer, not a function.
08:37:47 <Jafet> You cannot pass functions in C.
08:38:02 <Axman6> they're more useful in a context like GCD, where you want to do some 'work' concurrently. you can box that work up, and send it off to be executed
08:38:06 <Jafet> (If you haven't figured out by now, C is retarded and archaic.)
08:38:13 <Saizan_> Peaker: the problem is capturing the lexical scope in a closure, without that you don't need gc
08:38:14 <lilac> don't you see how this completely undermines your "work just fine" comment?
08:38:28 <Jafet> They work for the intended purpose.
08:38:33 <Peaker> Jafet: I thought we were talking about adding "Anonymous procedures" to a GC-less environment, not C (which doesn't have anonymous procedures)
08:38:33 <Taejo> Jafet: but in a non-optimising Haskell implementation, functions are passed by pointer too
08:38:48 <Jafet> Peaker, oh, we are?
08:39:13 <Peaker> Jafet: That's what I thought you meant by "Unnamed procedures work just fine"
08:39:32 <Peaker> Saizan_: Yeah, if you can just float them to top-level functions, they're not very problematic but also add very little interesting expressiveness
08:39:35 <Jafet> Wait, wait. What exactly is an anonymous procedure?
08:40:05 <Saizan_> Peaker: *nod*
08:40:27 <Peaker> Jafet: I guess I was thinking closures
08:41:58 <lilac> i thought we were talking about something akin to GCC's trampoline lambdas or C++0x's lambdas
08:42:13 <lilac> (that is, closures which can crash if you use them after their creator returns)
08:42:49 <Jafet> C++0x lambdas are closure-hackable
08:43:14 <Jafet> Thanks to the black magic of classes
08:43:15 <lilac> C++0x lambdas don't close. they either break when their closees go out of scope, or take a copy
08:43:49 <Jafet> Like all other useful and productivity enhancing high level concepts, you have to hack closures into C++ yourself.
08:43:51 <Makoryu> C++0x should've taken the D approach of GCing the closures
08:43:55 <lilac> this is a pity, since there are nice implementation techniques which would have allowed them to clsoe
08:44:08 <lilac> Makoryu: allocating the stack frame on the heap?
08:44:16 <Jafet> They couldn't even agree on type classes syntax, lilac. Try not to expect too much.
08:44:17 <Makoryu> lilac: Presumably.
08:44:18 <lilac> that's certainly how i'd have spec'd it
08:44:34 <lilac> Jafet: the /syntax/ was not the problem.
08:45:09 <Jafet> Oh, I thought it was the main part
08:45:16 <lilac> they couldn't agree whether they wanted type classes or something more like the ad-hoc mechanism of c++'s unconstrained templates
08:45:16 <etpace_> Can I do something like data (Ord a) => Tree a | ..?
08:45:46 <lilac> as always, they tried to pick a wrong and broken compromise. unlike normal, they spotted their error before shipping a standard :)
08:46:10 <pozic> Is there a doesFileExist function somewhere?
08:46:44 <pozic> Never mind, there is. I didn't know hoogle was case SEnsiTIVE.
08:46:46 <etpace_> data (Ord a) => Tree a = .. even
08:46:58 <Makoryu> C++0x is just profoundly embarrassing. They should give up on it and go work on OCaml
08:47:17 <lilac> C++0x should hopefully be less embarrassing than C++99 :)
08:47:52 <lilac> c++98, sorry :)
08:48:00 <saml> C++ programs are embarrassingly fast
08:48:08 <Jafet> C99 was (and still is) embarassing.
08:48:22 <saml> embarassment is good
08:48:30 <Jafet> C++0x should be all-round less stupid than C++. They still have trigraphs, though.
08:48:45 <Jafet> saml, protip: they aren't
08:48:53 <lilac> iirc they wanted to remove trigraphs, but there were some objections
08:49:12 <Makoryu> From IBM, yes
08:49:24 <Jafet> Burn their mainframes
08:49:31 <medfly> BURN THEIR MAINFRAMES!
08:50:12 <lilac> not just from IBM: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2910.pdf
08:50:18 <saml> let's make Haskell++ by adding bunch of stuff and embarrass ourselves!
08:50:50 <lilac> saml: proposal: each member of the channel gets to add one language feature. there is no discussion on making them work together nicely. then we ship.
08:51:45 <saml> ghc is already like that. /me hides
08:52:37 <fasta> saml: you don't have to hide for common knowledge.
08:53:45 <Makoryu> Incidentally, how many serious languages are still out there that haven't added OOP features?
08:54:01 <Axman6> haskell?
08:54:11 <Axman6> C?
08:54:11 <lispy> My language feature will be optional parameters!
08:54:22 <lispy> (oh wait, we already have those...)
08:54:24 <Makoryu> Haskell and C, obviously.... Erlang..... Anything else?
08:54:35 <lispy> Can I propose n+k patterns then?  Oh?  wait...n/m
08:54:51 <Makoryu> lispy: Optional parameters? Where?
08:54:57 <Jafet> OOP is rubbish
08:55:07 <Makoryu> (If you mean Maybe t........ I'll eat my hat)
08:55:10 <ray> all of them
08:55:10 <ray> that's how i define a serious language
08:55:31 <lispy> Makoryu: no one likes them, but GHC has support for them
08:55:41 <lispy> Makoryu: I think you put a ? infront of the type
08:55:49 <Makoryu> lispy: Hrrrrmmmm
08:56:19 <Jafet> If you can write clos/mop in lisp, surely you can do something comparable in haskell
08:56:39 <mapreduce> > let x . y = y x in "hello".length
08:56:40 <lambdabot>   5
08:56:42 <Jafet> (And *not* give it a silly brand name like "OOP")
08:56:51 <lilac> lispy: i think you mean implicit parameters rather than optional parameters?
08:56:52 <Makoryu> Jafet: CLOS is basically just records + multiple dispatch, which we can already do
08:56:59 <mapreduce> What's OOP?
08:57:04 <lispy> lilac: oh right
08:57:13 <lispy> Makoryu: sorry, I had the wrong name
08:57:19 <Jafet> Makoryu, wait, so do you think haskell "has OOP features"?
08:57:31 <lispy> http://cvs.haskell.org/Hugs/pages/users_guide/implicit-parameters.html
08:57:42 <lispy> Jafet: it does
08:57:42 <Makoryu> Jafet: It has all the good parts of OOP without trying to appeal to Java programmers
08:57:51 <Jafet> Oh, ok
08:57:54 <Makoryu> Jafet: The "appealing to Java programmers" part is what bothers me
08:57:56 <mapreduce> Makoryu: Then what is OOP to you?
08:58:14 <taruti> reimplementing clos in Haskell is nontrivial
08:58:23 <lispy> Jafet: but don't take my word for it: http://homepages.cwi.nl/~ralf/OOHaskell/
08:59:15 <ray> haskell would be object oriented if "data" were renamed to "class" and all functions from a type were required to be inside its data-er, class declaration
08:59:42 <Makoryu> mapreduce: Nailed-on dog legs?
08:59:44 <lilac> i'd say OOP is 1) type encapsulation and its other face abstraction, 2) compositionality of types, and 3) type-dependent function lookup. haskell has all of these :)
09:00:01 <lispy> lilac: what about subtypes?
09:00:29 <lilac> lispy: i'm not convinced they're part of OOP per se.
09:00:31 <lispy> haskell doesn't have subtypes but they can be implemented, see OOHaskell or using type class heirarchies
09:00:38 <lispy> lilac: polymorphism!!!
09:00:40 <quicksilver> lilac: implementation inheritances and subtyping-polymorphism are the ugly stepchildren.
09:01:04 <quicksilver> lilac: subtyping-polymorphism as an approach to generic programming for example.
09:01:09 <mapreduce> lilac: Type encapsulation?  Does that mean private fields in types?
09:01:45 <Makoryu> mapreduce: Seriously, though. I'm not adamantly anti-OOP (I still like what Ruby does with it). However, I really hate how often language designers seem to say "Let's bring relevancy back to our language by adding the Java type system to it!"
09:02:02 <mapreduce> Makoryu: What languages do that?
09:02:11 <lilac> quicksilver: i'm unconvinced that subtype polymorphism is essential or even important
09:02:36 <Makoryu> mapreduce: Ada, Fortran, Pascal, COBOL... Even J! (Or so I've heard)
09:02:38 <lilac> quicksilver: implements-the-same-interface-as seems to be enough without mentioning concrete types
09:02:55 <mapreduce> Makoryu: All those have been updated to be Java-like?
09:03:06 <Makoryu> mapreduce: More or less.
09:03:08 <lilac> mapreduce: encapsulation meaning that code 'outside' the class /can't/ access its fields
09:03:19 <mapreduce> lilac: How does Haskell provide that?
09:03:25 <quicksilver> lilac: nothing is essential.
09:03:33 <lilac> mapreduce: by non-exported data constructors
09:03:37 <Axman6> Makoryu: i don't like Ada's object orientation :(
09:03:41 <quicksilver> lilac: we can write great applications in haskell or even in BASIC.
09:03:43 <mapreduce> lilac: Ah, I see.
09:03:56 <Makoryu> Axman6: Exactly!
09:03:56 <quicksilver> lilac: however subtype-polymorphism is pretty essential to "what peoplpe think OOP means"
09:03:57 <Axman6> unless you could protected objects as OOP objects (i don't)
09:04:05 <lilac> quicksilver: sorry, missing context. "essential for a language to be classified by me as OOP"
09:04:14 <Axman6> Ada's protected objects are lovely
09:04:20 <quicksilver> lilac: OK. I'm arguing about "classified by other people"
09:04:28 <mapreduce> You could emulate subtyping by having implicit conversions between types.
09:04:33 <quicksilver> lilac: (whether or not they are misguided in that view in lilac's opinion ;)
09:04:37 <lilac> quicksilver: right, i think i'm probably in a minority ;-)
09:04:38 <Axman6> possible to emulate them in Haskell, but they'd need some more plumbing than Ada
09:04:42 <Baughn> Can you recommend a format to losslessly store sequential RGBA images? Before I go mad and use MNG or something?
09:05:04 <fasta> Baughn: that depends on a lot of factors.
09:12:20 <Baughn> fasta: Needs to have a cross-platform implementation in C or C++, 8 bit/channel rgba, lossless compression, etc.
09:12:20 <fasta> Baughn: and I assume it should be faaaasssstt?
09:12:20 <Baughn> fasta: Nah. Doesn't matter.
09:12:20 <vegai> mapreduce: ever seen "Progress 4GL"?
09:12:20 <bd_> Baughn: PNGs in a ZIP
09:12:20 <mapreduce> vegai: No.
09:12:20 <vegai> ah, s/mapreduce/Makoryu/
09:12:20 <Makoryu> vegai: Don't think so
09:12:20 <fasta> Baughn: in Haskell I would just use zlib + the numbers separated by spaces.
09:12:20 <lilac> quicksilver: as a thought experiment, if you took Java and removed implementation inheritance, so that only interfaces could be inherited. would that still be an OOPL?
09:12:20 <Baughn> bd_: ..I was rather afraid you'd say that. No common formats that take advantage of inter-frame redundancy?
09:12:20 <fasta> Baughn: trivial to implement. When it needs to be faster, switch formats.
09:12:20 <vegai> Makoryu: it's a legacy business language that recently added an OO layer that looks just like Java
09:12:20 <Baughn> fasta: Speed isn't an issue. Compression ratio is.
09:12:20 <vegai> and I've heard several people say that's a positive thing
09:12:20 <fasta> Baughn: compression ratio depends on a compressor. You can write special purpose compressors.
09:12:20 <fasta> vegai: is it legacy?
09:12:20 <vegai> fasta: ?
09:12:20 <Baughn> fasta: I'd rather not. New requirement: Compressor must already exist.
09:12:20 <fasta> vegai: I know some people that use it actively and there are also new releases and all that.
09:12:20 <Baughn> fasta: I suppose I should be using an actual video format. :/
09:12:20 <vegai> I might've meant "shit" when I say "legacy"
09:12:20 <Makoryu> vegai: I might believe them if older versions of the language had such an impoverished type system that they couldn't get anything done in it
09:12:20 <fasta> Baughn: video formats are not lossless.
09:12:20 <bd_> fasta: Some are
09:12:20 <quicksilver> lilac: I dunno. It would be a language I'd be fairly happy with, as Javas go. I found implementation inheritance more often a source of bugs than features.
09:12:21 <Baughn> fasta: Some are. YULS, MSU...
09:12:21 <quicksilver> lilac: of course, without some substitute form of code composition some things get a bit clumsy.
09:12:21 <quicksilver> combinators to combine behaviours is what you want.
09:12:21 <fasta> Ok, I should have said "most video formats".
09:12:21 <Baughn> fasta: FFV1, Lagarith, SheerVideo...
09:12:21 <lilac> Baughn: try 'cat'. it's a wonderful compression algorithm... zero-overhead, extremely fast and ubiquitous
09:12:21 <Baughn> lilac: Sadly, not ubiquitous. This needs to work on windows as well. :P
09:12:21 <Makoryu> lilac: And it's 100% lossless!
09:12:21 <bd_> they get terrible ratios, but there are lossless video codecs
09:12:21 <bd_> for example, huffyuv. And I think H.264 has a lossless mode too
09:12:21 <Baughn> lilac: Also, I believe there are theorems preventing a zero-overhead algorithm from doing any actual /compression/
09:12:21 <lilac> Baughn: windows has a similar decompressor built in :)
09:12:21 <bd_> Baughn: so, H.264 with qp=0 should be lossless, would that work for you?
09:12:25 <Baughn> bd_: I'd probably use one of the codecs actually created for losslessness, but yeah, I guess
09:12:54 * Baughn wonders if he's going overboard for this. It's only to store twenty or so frames... well, never mind. Linking to lagarith sounds like fun.
09:13:25 <bd_> also freenode appears to be having issues, I keep getting a burst of messages every 30s or so :|
09:13:37 <bd__> right then.
09:13:44 <Baughn> bd__: Not freenode, just that server
09:13:54 <bd_> Baughn: so, as I was saying, H.264 with qp=0 should be lossless, would that work for you?
09:14:03 <Baughn> bd_: I'd probably use one of the codecs actually created for losslessness, but yeah, I guess
09:15:11 <Baughn> bd_: ..I'm /definitely/ going overboard here. I don't think my audience is up to creating video tilesets. I'll just use a zipfile.
09:15:22 <bd_> at least, x264 with qp=0 anyway
09:15:22 <bd_> http://forum.doom9.org/showthread.php?t=95962 <-- according to this
09:17:22 <bd_> Baughn: probably easiest that way :)
09:17:22 <bd_> and I guess the RGBA->YV420 colorspace conversion is lossy too (losing the entire alpha channel even)
09:18:20 <Baughn> Eheh. Yes, I can't lose that.
09:19:10 <Baughn> It's a pity that I won't get inter-frame compression, but.. eh, I'll worry about that once I see a tileset larger than 10kB.
09:19:50 <lispy> alpha values are just an illusion anyway
09:20:00 <lispy> "You've already lost them..."
09:20:45 <Baughn> lispy: Not when rendering multiple tiles to the same area, they're not
09:22:26 <lispy> Baughn: I'm just teasing :)
09:22:44 <harlekin> Is lisp fun to learn if you already know Haskell? (Hope it's not too of topic.)
09:22:53 <Twey> Yep
09:23:05 <Twey> Different way of doing things.
09:23:08 <Baughn> Well.. you keep reaching for haskell tools it's missing. :P
09:23:15 <Twey> Hehe
09:23:20 <Baughn> But it's still worth learning, yes. For SLIME, if nothing else.
09:23:21 <harlekin> Twey, cool. Hoped it would be so.
09:23:25 <Twey> You do if you're not good at code-switching :þ
09:23:26 <lispy> harlekin: It's a cool language.  But, I'm so enamored with good static types, laziness, and pattern matching that I don't want to go back
09:23:39 * lispy never understood why people like SLIME
09:24:11 <harlekin> What's a good lisp book that preferably doesn't assume an reader only knowing imperative programming languages?
09:24:33 <lispy> It always broke my lisp compilers and also when you go to do sometimes of input it changes the expectation of pressing enter (or not) which drove me nuts
09:24:34 <Twey> PCL doesn't assume much
09:24:47 <Twey> http://gigamonkeys.com/book/
09:25:12 <lispy> harlekin: also, I like Paul Graham's OnLisp which is free now too.  If you have debian you can even get it from apt
09:25:13 <ray> lisp is ugly
09:25:13 <ray> learn scheme to slightly lessen that
09:26:09 <harlekin> Twey, lispy, thank you both. I'll read a few chapters in order to decide if I'll buy one of them.
09:26:27 <lispy> harlekin: SICP might be a good read.
09:26:37 <Twey> Yeah, On Lisp is good, but not an introduction IIRC
09:26:40 <lispy> harlekin: and they have video lectures
09:27:36 <ray> sicp doesn't assume you know any languages
09:28:00 <ray> learning scheme is more of a side-effect of SICP
09:28:08 <harlekin> I just don't want to go over that "What is a functional programming language" again.
09:29:18 <harlekin> ray, that book sounds interesting. But it's pretty expensive. \:
09:29:26 <etpace_> sicp is free
09:30:05 <lispy> I get the feeling harlekin wants a hardcopy
09:30:14 <harlekin> Yeah. Preferably.
09:30:37 <Twey> Borrow it from your local library?
09:36:03 <cgizmo> hi
09:36:23 <cgizmo> i have a question regarding memory leaks
09:36:24 <jfoutz> anybody have a link to two mutually recursive data's that are instances of Monad?
09:36:53 <Saizan_> @wiki Stack overflow
09:36:53 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
09:36:59 <lispy> cgizmo: just ask away, if someone knows how to help they will
09:37:03 <cgizmo> basically, i'm opening a connection to a PostgreSQL database using HDBC
09:37:16 <cgizmo> this is done in the main, in the IO Monad
09:37:42 <cgizmo> the, i'm passing the variable bond to this connection over to the State Monad
09:37:59 <lispy> cgizmo: (on a side note, this will help a lot in general with space leaks: http://book.realworldhaskell.org/read/profiling-and-optimization.html)
09:38:23 <cgizmo> when i'm done, I close only the varialbe that was opened in the main, but NOT the one that still resides in the State Monad
09:38:46 <cgizmo> is there any probleme at all regarding memory leaks when doing this ?
09:38:59 <lispy> cgizmo: what do you mean by variable?
09:39:14 <lispy> cgizmo: did you create a top level value with unsafePerformIO and no-inline?
09:39:27 <lispy> cgizmo: or do you just mean you pass a value around?
09:39:27 <quicksilver> I think cgizmo just means a database handle.
09:39:31 <yav> jfoutz: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=8930#a8930 these two can be made into monads
09:39:31 <quicksilver> there is "only one" handle, cgizmo
09:39:37 <cgizmo> by variable I mean : connection <- connectPostgreSql "etc"
09:39:43 <quicksilver> the fact you only close it in one place doesn't make it leak
09:39:50 <quicksilver> there is only one connection - if you close it, it's closed.
09:39:59 <cgizmo> quicksilver: yes, I mean database handle... sorry for the mixup in the vocabulary
09:40:05 <quicksilver> the other copy of the value is just, now, a handle to a closed connection
09:40:06 <quicksilver> which is fine
09:40:19 <quicksilver> (it would be a runtime error to use it, I expect)
09:40:32 <cgizmo> alright, thanks a lot
09:40:57 <lispy> cgizmo: one question.  Would it be more appropriate for the IO monad to close it?  If so, you might consider something like bracket
09:41:02 <cgizmo> so the handle I have in the State monad isn't a copy of the handle I created in the main ?
09:41:09 <lispy> :t Control.Monad.bracket
09:41:10 <lambdabot> Not in scope: `Control.Monad.bracket'
09:41:16 <lispy> ?hoogle bracket
09:41:17 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
09:41:17 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
09:41:17 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
09:41:27 <cgizmo> lispy: the main does close it
09:41:31 <lispy> ah
09:41:37 <cgizmo> what are brackets used for ?
09:41:40 <lispy> hoogle gets those types wrong
09:41:47 <lispy> :t Control.Exception.bracket
09:41:48 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:42:06 <quicksilver> cgizmo: it's the same value
09:42:09 <lispy> cgizmo: bracket takes a function to obtain a resource, a function to release a resource, and a function to use the resource
09:42:12 <quicksilver> cgizmo: it's only a "copy of" in a very weak sense
09:42:39 <quicksilver> cgizmo: "let x = 3 in f x" <-- is that function passed "the real 3" or "a copy of 3" ? does it matter? can you tell?
09:42:43 <opqdonut> @. pl undo \m x -> do f <- m; f x
09:42:44 <lambdabot> (. flip id) . (>>=)
09:42:44 <lispy> cgizmo: and it makes sure that the release happens
09:42:52 <quicksilver> cgizmo: the thing about immutable values is you can't tell when something is a copy
09:42:53 <jfoutz> yav: thanks, i think my initial guess for datatypes was not good.
09:42:55 <quicksilver> they're all the same anyway.
09:43:00 <cgizmo> quicksilver: thanks for the explaination, it helps a lot
09:43:25 <cgizmo> lispy: hum, brackets are nice, i'll try using them in my program
09:44:10 <quicksilver> lispy is right, of course. brackets are great
09:44:16 <yav> jfoutz: i missed the beginning of the conversation :-)  i can post the Monad instances too if you'd like?
09:44:19 <quicksilver> I was answerign a different part of your question that's all ;)
09:44:42 <cgizmo> alright, well thanks to both of you
09:46:11 <lispy> cgizmo: cheers.  also, your database library might provide a withConnection (or similar name) that is like bracket but specialized to your task
09:47:29 <jfoutz> yav: I didn't explain, sorry. The instances would be really helpful.
09:49:32 <cgizmo> lispy: you're right, HDBC provides a "withWConn" function
09:50:03 <Makoryu> Axman6: OpenCL supports vector operations in C? Now I'm *really* excited...
09:50:37 <Axman6> :)
09:51:11 <lispy> Makoryu: yeah, take that *Fortran* ;)
09:51:35 <lispy> 30 years after the creation of C, boohya
09:52:23 <Twey> Haha
09:52:44 <jfoutz> yav: i think there's some trick to avoiding the infinite type, but i can't seem to figure it out.
09:53:10 <Twey> Urgh, what is it with people and C-likes
09:53:26 <lispy> jfoutz: avoiding infinite types relies on recursive data types.  I can't code it from memory, but I've seen the solution on Haskell-Cafe a few times
09:53:31 <Twey> It's like they've completely closed off their minds to the possibility that a language that *isn't C* can possibly be efficient
09:54:23 <lispy> I blame AT&T for inventing unix
09:54:32 <lispy> it ran on small machines
09:54:41 <lispy> and C was the implementation language, ergo C is fast
09:54:42 <Rotaerk> Twey, what? they can be???
09:54:52 <jfoutz> lispy: thanks... i'll point google at haskell-cafe
09:55:01 <Rotaerk> hmm..
09:55:26 <EvilTerran> Rotaerk, ghc-compiled haskell can outperform gcc-compiled C, in some circumstances
09:55:36 <Rotaerk> yea I've heard
09:55:41 <Rotaerk> and it's more scalable
09:56:01 <lispy> and in Haskell as soon as someone makes a new algorithm with better complexity, you can switch to it :)
09:56:07 <glguy> EvilTerran: "in some circumstances" is a great qualifier
09:56:09 <Twey> It's sad/amusing to see people attempt to shoe-horn C into the concurrent-applications sector
09:56:11 <Rotaerk> some people like to have low level control over the hardware to feel like they've got control over the performance
09:56:58 <Rotaerk> when it's really just reinventing the square wheel
09:57:10 <Twey> Yeah
09:57:15 <Twey> But it's so prevalent :-\
09:57:21 <Baughn> Don't underestimate the square wheel!
09:57:54 <glguy> They must do it because they are dumb
09:57:56 <glguy> that's probably it
09:59:13 <EvilTerran> glguy, yeah, i use it to mean "not that i can remember any of the specifics"
09:59:27 <lispy> my sacrasm detector just detected a huge spike
10:00:12 <lispy> I feel like I don't like coding in low level C because it takes too much brain power to write correct code at that level.
10:00:41 <yav> jfoutz: hmm, i am not sure that i gave you a good example, making ListM into a monad does not seem to quite work. let me think of another one.
10:00:41 <Twey> If you design it correctly, the brain-power requirement isn't that huge
10:00:43 <monochrom> You detected a huge spike because I was about to write something sarcastic.
10:00:48 <Twey> The RSI-factor is, though.
10:01:27 <monochrom> By a self-selection process, programmers are very likely to be control freaks.
10:01:45 * glguy tries to take that sarcastically...
10:02:00 * benmachine selects monochrom 
10:02:04 <Raevel> i'll decide that for myself thank you very much
10:02:28 <Twey> monochrom: So write your own compiler.
10:03:00 <Saizan_> but they are also likely to be "lazy" as in "automate tasks"
10:03:47 <jfoutz> yav: thanks. it's tougher than i realized.
10:04:26 <yav> jfoutz: tougher then i realized too :)
10:05:48 <monochrom> glguy: I suppressed my sarcastic remark, and it was unrelated.
10:10:30 <Synth-c> :r
10:10:59 <jfoutz> [1 of 1] Compiling Main
10:11:02 <benmachine> :wq
10:11:13 <monochrom> $
10:11:25 <LeoD> ^
10:11:49 <monochrom>   No Show instance for ...
10:12:40 <benmachine> oh hey a merton.ox.ac.uk
10:12:46 <benmachine> I have a friend who goes to merton
10:12:52 <benmachine> although he is probably not there at the moment
10:24:00 <hackagebot> serialport 0.1.0.2 - Cross platform serial port library. (JorisPutcuyps)
10:33:04 <hackagebot> language-dot 0.0.2 - A library for the analysis and creation of Graphviz DOT files (BrianLewis)
10:36:05 <hackagebot> language-dot 0.0.3 - A library for the analysis and creation of Graphviz DOT files (BrianLewis)
10:36:19 <Twey> Heh
10:36:21 <Twey> That was fast
10:38:01 <aavogt> .. at the current rate, we'll have 480 releases of langage-dot by tomorrow
10:41:09 <c_wraith> Can I still be annoyed that the decimal system is big-endian today?
10:42:15 <ray> yes
10:42:20 <inimino> c_wraith: it's not, it's written right-to-left
10:42:46 <c_wraith> inimino: endian-ness is only about the order you store it in anyway
10:43:00 <ray> with the most significant figure first, inimino
10:43:34 <ray> you can look at it your way but that seems a bit specious to me
10:43:46 <c_wraith> Hmm.  It just occurred to me that decimal representations of things like pi are more annoying little-endian.
10:43:55 <c_wraith> Ok, now I'm confused what I want to be annoyed it.
10:43:59 <inimino> ray: the least significant figure first
10:43:59 * c_wraith sulks
10:44:01 <inimino> ray: that's actually the historical fact
10:44:20 <ray> well, if you go back to the original arabic
10:44:23 * c_wraith solves the problem by writing pi as 1 in base-pi
10:44:43 <ray> 10
10:44:51 <c_wraith> err, yes
10:44:54 <c_wraith> >_>
10:45:08 <c_wraith> or maybe 01
10:45:09 <c_wraith> :)
10:50:55 * erikc wants a language-c++
10:51:53 <c_wraith> @instances Integral
10:51:53 <lambdabot> Int, Integer
10:56:27 <edwardk> erikc: i'm talking to someone to see if i can get an in house proprietary edsl/quasiquoter for it released, but its got a big company using it that doesn't like to make stuff public =/
10:58:41 <erikc> a edsl/quasiquoter for pattern matching c++?
10:59:39 * c_wraith just did an inventory and found 9 pens on his desk.  Slight overkill
11:01:04 <kmc> edwardk, an edsl in Haskell?
11:02:13 <lispy> c_wraith: I could use some more pens
11:03:16 <c_wraith> I just returnd 5 of them
11:03:22 <c_wraith> ...  *returned
11:03:33 <path[l]> this may not be the right place to ask, but does anyone know how I can uninstall ghc on mac os if it WASNT installed via ports? I wanna install the latest version via mac ports
11:03:57 <path[l]> theres no make uninstall
11:04:24 <c_wraith> ...  look at the make install targets, and manually delete everything it creates? :(
11:04:30 <doublethink_work> path[l]: there's an uninstaller script included
11:04:38 <c_wraith> oh, hey.  that's way better. :)
11:04:45 <path[l]> really? hmm let me see if I can find it
11:04:50 <doublethink_work> path[l]: i'm not on my macbook right now, but look in /Library/GHC.Framework I believe
11:04:56 <path[l]> aha thanks
11:05:04 <doublethink_work> look around and you should come across a script that's just 'Uninstaller'
11:06:16 <path[l]> ah thanks found it
11:06:30 <path[l]> god I need to relearn the unix tool set. I still cant use find lol
11:06:51 <path[l]> ok done thanks :)
11:06:55 <kmc> unix: where every command has its own DSL
11:07:03 <kmc> not sure if that's a bug or a feature
11:07:04 <path[l]> so now I should port install ghc and port install cabal right?
11:07:21 <path[l]> afterthat if I understand right, everything is done through cabal
11:08:00 <c_wraith> if macports has haskell-platform, use it
11:08:06 <path[l]> oh ok
11:08:33 <c_wraith> It's a packaging of known-to-be compatible versions of lots of common packages from hackage, including cabal
11:08:34 <path[l]> nope, I dont see it
11:08:58 <path[l]> oh its not sorted
11:09:04 <monochrom> Every user interface is a DSL.
11:09:52 <path[l]> there's a dmg file on the net for it
11:11:00 <inimino> monochrom: for some very weak definition of L
11:11:03 <FunctorSalad> monochrom: careful, or "DSL" will be the next "exponential" :O
11:11:19 <inimino> if you call pointing and grunting a language...
11:11:22 <monochrom> Perhaps it is a bug that every user interface is a DSL. The solution should be to eliminate users.
11:11:24 <c_wraith> n^2 grows so fast, it's like exponential!
11:11:44 <path[l]> doublethink_work: since you're a mac user. What do you recommend? port install ghc? or the haskell-platform dmg
11:12:00 * sm likes the HP dmg
11:12:12 <c_wraith> well, haskell-platform doesn't include GHC, I thought
11:12:18 <ray> i prefer doing MP damage
11:12:23 * sm likes the GHC dmg + HP dmg
11:12:24 <path[l]> huh really? it doesnt?
11:12:27 <erikc> monochrom: i make that argument all the time in favor of not building GUI tools
11:12:40 * Rotaerk mana burns ray.
11:12:52 <path[l]> hey copumpkin any luck with speeding that thing up?
11:12:53 <erikc> in most cases, user interfaces are the most expensive and least expressive DSLs you can make
11:12:58 <kmc> is there a way to turn on typeclass deriving more globally than for a single type?
11:13:08 <kmc> say "Everything in this module gets Eq, Ord, and Show if possible"
11:13:10 <path[l]> he MacOS X installer provides GHC 6.10.4 and the full tool and library suite: <--- looks like GHC is included
11:13:11 <c_wraith> path[l]: it's a set of libraries and utilities for managing them.
11:13:14 <Makoryu> c_wraith: Why on earth would it not include GHC?
11:13:19 <c_wraith> Oh, it does now?
11:13:29 <c_wraith> I know it didn't include GHC last I installed it
11:13:35 <c_wraith> But that was several versions ago
11:13:38 <c_wraith> and not on OS X
11:13:40 <path[l]> hope it lets me uninstall later when I need to upgrade
11:13:57 <FunctorSalad> Rotaerk: you can only mana burn yourself :o
11:14:02 <kmc> in particular though the interfaces of UNIX commands tend to resemble "real" programming languages
11:14:13 <kmc> and they're all different :/
11:14:13 <c_wraith> FunctorSalad: as of the M10 rule changes, mana burn no longer exists
11:14:20 <Rotaerk> FunctorSalad, depends on the game :P
11:14:28 <FunctorSalad> c_wraith: I'm getting old...
11:14:38 <path[l]> heh it doesnt include the one package I wanted. hslin
11:14:39 <path[l]> t
11:14:48 <c_wraith> well, it includes cabal
11:14:52 <path[l]> heh any of you guys play mtg online? (not mtgo)
11:14:59 <path[l]> yeah I know :)
11:15:02 <FunctorSalad> used to a long time ago
11:15:07 <FunctorSalad> (but yes this is OT)
11:15:13 <kmc> @dice d20
11:15:13 <lambdabot> unexpected "d": expecting number
11:15:21 <kmc> eff you lambdabot
11:15:22 <c_wraith> @dice 3d6
11:15:22 <lambdabot> 3d6 => 13
11:15:24 <path[l]> the new octgn is really nice looking
11:15:43 <path[l]> anyway thanks guys
11:17:14 <kmc> can i import a module qualified and then re-export the qualified namespace as is?
11:17:32 <edwardk> kmc: yeah
11:17:40 <lilac> oh no, someone used @dice and i saw the output!
11:17:48 <edwardk> kmc: (was afk)
11:18:02 <edwardk> kmc: the yeah was re the edsl in haskell comment
11:18:04 * lilac feels like his possible futures have been wrapped up and rammed into a quantum mechanical monad
11:18:29 <edwardk> kmc: regarding exporting namespaces no, you can only export in your current lexical scope, nothing nested or anything weird like that
11:18:30 <lispy> lilac: and then fired into the LHC?
11:18:36 <erikc> edwardk: for parsing/matching c++?
11:18:37 <c_wraith> lilac, don't worry.  I'm sure lambdabot is deterministic when rolling dice, so QM doesn't come into play
11:18:45 <edwardk> erikc: yeah
11:18:47 <lilac> c_wraith: oh, phew!
11:18:48 <Baughn> lilac: Don't worry, they'll decohere immanently.
11:18:57 <edwardk> erikc: i wouldn't get your hopes up, i don't think he'll be able to release it
11:18:59 <edwardk> lots of red tape
11:19:34 <lilac> Baughn: i belong to the Everett school of quantum mechanics.
11:19:36 <Rotaerk> I fired at your mom with my LHC
11:19:39 <erikc> edwardk: yup, no doubt
11:19:47 <Baughn> lilac: Yes..?
11:20:07 <lilac> Baughn: so decoherence doesn't allay my concerns. your decoherence is my many worlds.
11:20:41 <kmc> edwardk, where do you work that's cool enough to generate C++ from Haskell?
11:20:42 <Baughn> lilac: That's the decoherence I was referring to. Many-worlds is kind of obvious, isn't it?
11:21:35 * Rotaerk fights the decoherence.
11:21:44 <edwardk> kmc: its not my company, but i was requested not to name the company in question, when I was told about the project.
11:21:49 <joyful> Fight the decoherence - chill!
11:21:51 <FunctorSalad> kmc: interesting point... I wonder how many C++ jobs would allow that
11:21:55 <kmc> okay, no worries
11:22:08 <Rotaerk> ew
11:22:18 <Rotaerk> generating C++ from haskell? bad idea
11:22:19 <edwardk> kmc: said red tape again ;)
11:22:37 <FunctorSalad> Rotaerk: I haven't tried it, admittedly
11:22:43 <copumpkin> edwardk: I started writing an epic algebra library using your reflection stuff
11:22:45 <copumpkin> edwardk: I even have pseudo-subtyping for the algebraic structures
11:22:46 <FunctorSalad> just sounds possible in principle
11:22:49 <edwardk> rotaerk: dan friedman always says 'generate any language you have to, but work in scheme'. I think the same idea applies to Haskell =P
11:22:59 <edwardk> copumpkin: rock!
11:23:04 <copumpkin> :)
11:23:06 <edwardk> copumpkin: how well is it working out?
11:23:18 <Rotaerk> if you're going to be generating C++, then you're probably doing it because the company's code is in C++... and code you write for a company needs to be manageable
11:23:19 <copumpkin> pretty well, except I feel a little dirty since I have just about every ghc extension enabled
11:23:29 <Rotaerk> generated code isn't usually all that human-usable
11:23:42 <Rotaerk> especially if it's C++ crap
11:23:43 <kmc> Rotaerk, maybe your generated code links to existing code
11:23:49 <copumpkin> edwardk: but I can say withMonoid aGroup (monoid expression) for example, like your code
11:23:50 <kmc> but should never be edited by hand, just re-generated
11:23:54 <edwardk> Rotaerk: i agree, actually, just playing devil's advocate ;)
11:23:57 <copumpkin> edwardk: in a type-safe way
11:24:00 <kmc> it's a horrible pain to link anything other than C or C++ to C++
11:24:04 <edwardk> copumpkin: spiffy =)
11:24:07 <Rotaerk> kmc, that would mean you maintain it in haskell, not C++
11:24:10 <Cale> The difference between Many Worlds and Copenhagen is a garbage collector ;)
11:24:12 <kmc> agreed
11:24:15 <Rotaerk> which isn't an option if the company wants only to depend on C++
11:24:17 <edwardk> cale: lol
11:24:19 <FunctorSalad> Rotaerk: sure if it must be maintainable by C++ers then generated code wouldn't work. But maybe in some situations C++ is mandated for other reasons
11:24:26 <Rotaerk> introducing a language to a company isn't free
11:24:28 <monochrom> @remember Cale The difference between Many Worlds and Copenhagen is a garbage collector ;)
11:24:28 <lambdabot> I will remember.
11:24:36 <Rotaerk> because in the future they have to hire people who understand haskell
11:24:36 <copumpkin> @flush
11:24:36 <lambdabot> Not enough privileges
11:24:42 <edwardk> cale: though the notion of reachability is a bit ill posed
11:24:45 * copumpkin resists the temptation to acquire enough privileges
11:24:56 <kmc> yes, but supposing that barrier is overcome you still may want to generate c++ for other reasons
11:24:59 <Baughn> Cale: I think you're referring to Mangled Worlds, not Copenhagen. :P
11:25:02 <Rotaerk> I love the word "acquire"
11:25:06 <Baughn> Mangled worlds = many worlds + garbage collector.
11:25:07 <Rotaerk> it's so... ambiguous regarding the means
11:25:20 <Cale> edwardk: true
11:25:39 <copumpkin> Rotaerk: :D
11:25:44 <kmc> e.g. one person understands Haskell and implements the DSL, many people use it, and many people write the c++ runtime for it
11:25:48 <edwardk> so maybe the garbage collector is there, but useless because reachability is always satisfied? =)
11:26:39 <edwardk> kmc: take a look at sclv's jmacro if you are interested in a nice way to build an EDSL embedding of some generated language. he does javascript really nicely
11:26:54 <edwardk> with hygienic macros!
11:27:25 * copumpkin hates hygiene
11:27:36 * edwardk remembers not to sit next to copumpkin.
11:27:41 <copumpkin> :D
11:27:49 <monochrom> I think he hates it but he still does it.
11:28:00 <Baughn> Cale, lilac: http://hanson.gmu.edu/mangledworlds.html <-- I'd love to see your reactions to this. :3
11:28:04 <edwardk> then er.. thats a bit of a wash ;)
11:28:09 <monochrom> "I have to brush teeth twice a day but I hate it!"
11:28:30 <monochrom> "I hate my job but I still have to do it!"
11:29:15 <edwardk> copumpkin: what have you against hygiene? or do you mean the bondage and discipline hygiene like syntax-rules? but the fuzzy handcuffs hygiene like syntax-case is ok?
11:29:42 <copumpkin> oh I was just being a dirty basement nerd
11:29:50 <edwardk> ah
11:29:58 <copumpkin> nothing against macro hygiene :)
11:29:59 * edwardk remembers not to sit next to copumpkin.
11:30:19 <monochrom> Just don't go into basements.
11:30:21 <copumpkin> oh no, now people think I'm dirty
11:30:27 * Rotaerk fetches the power washer.
11:30:32 * Botje wants a hygiene macro
11:31:00 <Rotaerk> if you're the copumpkin, who's the pumpkin
11:31:02 <copigpen> I'm sure there is a 'great pumpkin charlie brown' joke in here somewhere.
11:32:02 <Rotaerk> or maybe you're a fake-parallel pumpkin
11:33:30 <copumpkin> :o
11:34:57 <path[l]> wtf worlds colliding
11:35:05 <HugoDaniel> hi
11:35:05 <path[l]> mangled worlds is being discussed here too
11:35:17 <HugoDaniel> can anyone help me out with this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8933#a8933  ? :/
11:35:30 <roconnor> that mangled world abstract seemed quite intersting
11:35:41 <path[l]> went above my head
11:36:05 <edwardk> hrmm. i wonder what kind of neat GPGPU comonads there are. current gpgpu architectures generally let each site read anything but only write to the current texture location, that see everything/generate something small pattern looks comonadic. now if only it could hold stuff other than a single texel.
11:36:54 * copumpkin tries and fails to fit a yo dawg joke to what edwardk just said
11:37:24 <edwardk> heh
11:38:48 <Baughn> path[l]: I can only hope that the mangled worlds don't allow for consciousness. ^^;
11:38:52 <Rotaerk> I can't understand the mangled worlds thing
11:39:04 <kmc> oh no
11:39:10 <Rotaerk> don't know squat about quantum physics
11:39:23 <path[l]> heh
11:39:53 <path[l]> like a lot of people I have my own little private interpretation of quantum physics that Ill never discuss with a real scientist for fear of being laughed at
11:40:26 <path[l]> the only link it has with mangled worlds is thats a name that would describe my view too
11:40:40 <Apocalisp> edwardk: I like your words. Keep saying them.
11:40:52 <Cale> I'm not sure what to think about this mangled worlds thing, but the way I see many worlds/Copenhagen it is that the many worlds interpretation is somewhat more thorough in that it tries to interpret all the information which is available mathematically, while the Copenhagen interpretation discards the terms of the sum that don't correspond to the world we seem to find ourselves entangled with.
11:41:02 <path[l]> but when I read mangled worlds all excited, that someone else maybe endorsed a view I had come up with by myself ... I realised I couldnt understand mangled worlds
11:41:06 <path[l]> so it didnt matter
11:41:11 <path[l]> I wont even know if Im right
11:41:12 <path[l]> lol
11:42:03 <Cale> It's always okay to discard those terms once we've seen the outcome, since observables are all linear, and will split over the sum anyway.
11:42:17 <Baughn> Cale: That's about right. Copenhagen, apart from being disproven (yeah..), requires an additional physical mechanism to discard those extra terms
11:42:41 <Baughn> Cale: As nature provides exactly zero evidence that they are in fact discarded, occam's razor demands that we don't postulate that they are
11:42:45 <aavogt> Cale: is there some reason lambdabot doesn't make tinyurls whenever people paste urls?
11:43:06 <aavogt> as in, should I disable it if I'm running my own lambdabot?
11:43:15 <Baughn> Cale: Mangled worlds, meanwhile, attempts to explain the arbitrary Born rule (physical law) via a hypothetical emergent effect, which thereby reduces complexity further
11:43:30 <Cale> Baughn: Well, I think it's meaningless to ask if nature *really* discards them. They're mathematical things, part of a system we constructed for modelling the universe.
11:43:36 <Baughn> aavogt: Some people find it annoying.
11:43:48 <Baughn> aavogt: And the url has already /been/ pasted, so what is the tinyurl /for/?
11:44:28 <Cale> aavogt: Well, two reasons: one is that the url plugin is buggy and causes crashes. The second is that people tended to complain about it.
11:44:31 <edwardk> Apocalisp: well, it looks comonadic, its just a question of what shape the underlying type system/category takes. it might not have many types and doesn't look like it has full exponentials.
11:44:43 <Baughn> Cale: Even if you don't consider objective reality to be interesting, it provides predictions for what you'd see during a quantum suicide.
11:44:55 <dino-> URL shortening services make me nervous anyway.
11:45:20 <Baughn> Cale: (Assuming certain theories of self.. that are pretty arbitrary in themselves, but seem hardwired into our minds. Doesn't mean they're correct. Heh.)
11:45:26 <edwardk> dino-: i'll admit i get annoyed when i explicitly paste an _unshortened_ url into twitter and it clips it for me.
11:46:17 <HugoDaniel> i wish i could understand types better :/
11:46:24 <dino-> edwardk: But the real magic starts when the shortening service inevitably goes away, leaving a slum of dead URLs behind.
11:46:36 <edwardk> dino-: yeah
11:46:55 <dino-> Watching this drama unfold with Twitter is like a train wreck you can't tear your eyes away from.
11:47:33 <Cale> Every URL eventually dies.
11:47:37 * Baughn doesn't use twitter, and this is one reason why. What's so great about a tiny string length limit?
11:48:00 <glguy> Well, URL shortening services disappearing eventual and twitter messages having a lifetime of 0 minutes go pretty well together
11:48:12 <Cale> I agree. I absolutely can't stand message length limits everywhere else.
11:48:18 <edwardk> Baughn: i use it every once in a while for messages more permanent than an irc message, but less significant than a blog post.
11:48:41 <dino-> glguy: Exacty that has been mystifying me. Why does anyone care about transient short URLs with a twit when they are themselves so short-lived.
11:49:06 <Baughn> edwardk: If you feel that a blog post is too heavy-weight, maybe that's a problem with the stylesheet, not blogs. Twitter /is/ basically a blog..
11:49:10 <edwardk> the twitter message length limit does seem implicit to its ability to send text messages to anyone using crufty old technology ;) which helps foster adoption
11:49:13 <copumpkin> anyone here at ICFP?
11:49:31 <copumpkin> I was wondering what was going with the contest results
11:49:33 <copumpkin> *going on
11:49:42 <edwardk> oh yeah, i forgot about the contest.
11:49:44 <Asztal> Except text messages can be chained together
11:49:45 <Cale> I personally can't stand message length limits.
11:49:49 <Asztal> So I don't see why it's 140
11:50:03 <holmak> I think the original idea was to be compatible with SMS
11:50:05 <Vanadium> Not all phones properly support that
11:50:07 <edwardk> Asztal: which results in something almost unreadable on most craptacular phones
11:50:13 <Vanadium> and it still ends up being more expensive than a single message
11:50:22 <Vanadium> aaaand twitter messages chan be chained together just as much :V
11:50:51 <holmak> So, if I want to use some regular expressions, which variant of Text.Regex.??? should I be using?
11:51:11 <holmak> There seem to be about 15 implementations of regexes
11:51:13 <Baughn> holmak: Depends on what style of regular expressions you want to use
11:51:14 <Cale> I thought that when Google bought YouTube, it would *have* to get a decent comment system...
11:51:26 <holmak> Nothing more exotic that word boundaries
11:51:31 <Baughn> holmak: There are posix regexes, bash regexes, perl regexes, etc. etc. etc.
11:51:47 <Twey> holmak: By default, I'd go with .Posix
11:52:00 <Baughn> holmak: If all you need are word boundaries, how about Prelude.words?
11:52:04 <Twey> If you need fancy stuff, you might want the slower but more powerful PCRE
11:52:11 <edwardk> cale: now now, you can't hold the IQ of the average mouth-breathing youtube poster against them. they can't help themselves. they are drawn to the shiny animated lights.
11:52:28 <holmak> Oh, I need actual regexes, but I know \b isn't standard everywhere
11:52:32 <Twey> edwardk: I always thought it was the soft porn.
11:52:49 <holmak> I'll try .Posix, thanks
11:52:55 <Twey> Oh, and the pictures of people jumping off tall things.
11:53:59 <Cale> edwardk: The real reason the average IQ is so low is that anyone smart has realised by now that the commenting system there is hopelessly broken. It will randomly reject the comments you try to post for reasons which don't seem to apply, assuming that you can squish what you're trying to say into a small enough number of characters...
11:54:09 <edwardk> well, it did nicely kill off the "stupid clip show" tv format
11:54:40 <Cale> and then even supposing that your comment does get posted, it'll just get lost among the random number of 'pages' of comments, which are really just different random selections of the comments people have made.
11:54:53 <monochrom> Yeah, we comment on YouTube clips on IRC.
11:55:11 <Twey> Cale: Heh, yes.
11:55:35 <Twey> It used to reject all Lojban comments, believing them to be spam URLs (‽)
11:55:53 <monochrom> "real men write comments on IRC"...
11:55:57 <Twey> Heh
11:55:59 <edwardk> twey: heh
11:56:11 <Cale> I know that Google has competent programmers... I suspect that they look at the YouTube code and just decide to work on something else. It has the signs of being a complete and utter mess.
11:57:14 <monochrom> "The ICFP contest judges announce that Lojban is the language of choice of discriminating spammers"
11:57:24 <Twey> Hahahaha
11:57:29 <Cale> There are other stupid things about YouTube too, like that many of the links are not really links to where you want to go, but links back to the page you're on that have javascript events attached to them to implement linking, which means that if you accidentally double click them, you go nowhere.
11:57:53 <Cale> (or if you try to open them in a new tab)
11:57:59 <erikc> goog is never going to make their money back on youtube
11:59:34 <Baughn> They would probably be better off reimplementing it. With the tools they've already got, it shouldn't be /that/ much work
11:59:52 <dino-> @paste
11:59:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:59:59 <Twey> They could probably just reïmplement it as an extension to Google Video…
12:00:32 <dino-> Oh, I forgot we were originally going to go away then too.
12:00:48 <dino-> sorry, I'm a dipshit typing in the wrong channel
12:01:44 <HugoDaniel> i need help with typeable data types: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8935#a8935 how do i use a "generic" function ?
12:01:56 <nathanic2> Twey: did you manually type that diaeresis or do you have a filter for that?
12:02:45 <Twey> Er, no, I just typed it
12:03:15 <nathanic2> Are you french or just fancy? ;-)
12:04:19 <leimy> I'm trying to decide if it's crazy to embed a StateT IO inside a ReaderT :-)
12:04:32 <leimy> but, I have state I need to update once.
12:05:07 <HugoDaniel> leimy: its quite usual
12:05:22 <leimy> HugoDaniel: I mean, local isn't going to cut it :-)
12:06:03 <monochrom> You can even go RWST _ _ _ IO
12:06:06 <leimy> So is that a ReaderT StateT IO ?
12:06:23 <leimy> er ReaderT StateT IO a
12:06:38 <Peaker> leimy: ReaderT (StateT IO) a
12:06:38 <leimy> And does that mean IO has to be lifted 2x?
12:06:52 <Peaker> leimy: you can use the MonadIO instance of ReaderT/StateT (and use liftIO)
12:06:55 <leimy> Peaker:  yeah I wasn't being very explicit.
12:07:00 <kmc> liftIO works all the way up because it's a typeclass member
12:07:03 <monochrom> One liftIO suffices.
12:07:06 <leimy> Peaker: Ah right!
12:07:08 <Peaker> leimy: yeah and I also forgot the ReaderT r argument
12:07:15 <leimy> I totally forgot about that
12:07:18 <Peaker> leimy: but I like newtype'ing the monad transformer and naming all the lifters
12:07:22 <leimy> yep
12:07:25 <HugoDaniel> talking about typeclasses, what about my code ? :/
12:07:36 <leimy> Peaker: you name the "lifters"?
12:07:38 * kmc <3 monad transformer + newtype + GHC newtype deriving
12:07:44 <HugoDaniel> can anyone help me out with it plz ?
12:08:43 <Apocalisp> edwardk: It does seem comonadic. Cellular automata immediately come to mind.
12:09:18 <Peaker> leimy: yeah, something like:  newtype MyMonadT m a = MyMonadT { unMyMonadT :: ReaderT SomeR (StateT SomeS m) a } ; liftReader = MyMonadT ; liftState = MyMonadT . lift ; instance MonadTrans MyMonadT where lift = MyMonadT . lift . lift
12:09:37 <Peaker> kmc: if you auto-derive MonadTrans, lift goes through the entire stack, or just the most outer layer?
12:09:47 <Peaker> kmc: is my last instance there redundant?
12:10:10 <kmc> hmm my newtype is a monad not a monad xformer
12:10:20 <kmc> and i autoderive (Monad, MonadPlus, MS.MonadState State, ME.MonadError Error)
12:10:29 <copumpkin> @botsmack
12:10:29 <lunabot>  :o
12:10:29 <lambdabot> :)
12:10:32 <kmc> (MS and ME are qual imports of C.M.State and C.M.Error resp)
12:10:40 <Peaker> kmc: With class aliases, we could auto-derive these groups without enumerating them each time
12:10:56 <kmc> yeah, that'd be nice
12:11:09 <edwardk> Apocalisp: well, there is a nice comonad for dealing with cellular automata rules
12:11:22 <edwardk> Apocalisp: so that isn't surprising ;)
12:11:42 <holmak> How do I specify MULTILINE mode for a regex match?
12:17:57 <fffej> i'm having trouble understanding multi-dimensional arrays in Haskell - the following gives me a result, but by my understanding the array is out of bounds.  (array ((0,0),(1,1)) [ ((i,j),i*2+j) | i <- [0..1], j <- [0..1]])  gives 2 - can someone explain wny?
12:18:55 <Alpounet> do somebody here already use grapefruit ?
12:19:04 <dino-> holmak: I'm trying to find the docs, but I forget the API offhand.
12:19:07 <ryant50003> what would be a good way of visualizing Arrows?
12:19:11 <dino-> I wish the regex-compat API docs were still around.
12:19:30 <dino-> I seem to have trouble finding the page where matchRegex is documented
12:19:31 <holmak> I think its ok -- since im going to process the file line-by-line, I don't need it actually
12:19:43 <holmak> The regex docs are much harder to read than the rest
12:19:49 <dino-> holmak: yup
12:20:16 <lispy> dino-: are you looking for the haddocks?
12:20:27 <ryant50003> i don't expect something to automatically build one out of haskell code, but it would be nice if there were something that could build such diagrams easily
12:20:29 <leimy> hmmm how does one "run" a ReaderT a (StateT b IO)
12:20:45 <lispy> dino-: this link? http://www.haskell.org/ghc/docs/latest/html/libraries/
12:21:31 <dino-> lispy: the problem is that you can't get the docs for the module that contains matchRegex and mkRegex from there, or I'm doing it wrong.
12:21:44 <dino-> I prefer to not use the =~ things at all
12:22:02 <holmak> I would too, but Real World Haskell does, and that's my best reference right now.
12:22:09 <lispy> ?hoogle matchRegex
12:22:09 <lambdabot> No results found
12:22:14 <lispy> ?hoogle mkRegex
12:22:14 <lambdabot> No results found
12:22:26 <holmak> I'm looking at http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-RegexLike.html now
12:22:30 <HugoDaniel> can someone help me with typeable data types ?
12:22:35 <Saizan_> HugoDaniel: you need to write the missing instance, or unwrap/rewrap the RObject constructor inside the lambda
12:23:09 <HugoDaniel> ive been trying to write the missing instance, but i keep getting a strange error
12:23:12 <dino-> this may be good enough for now: http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html
12:23:28 <lispy> dino-: I found that at the same time :)
12:23:40 <noteventime> fffej: What do you mean gives 2?
12:23:51 <dino-> Ok, holmak, there's an alternate mkRegex in the API called mkRegexWithOpts
12:23:55 <fffej> noteventtime: I mean evaluates too 2
12:24:15 <fffej> noteventtime: (literally typing it in at the REPL)
12:24:38 <noteventime> fffej: I get "array ((0,0),(1,1)) [((0,0),0),((0,1),1),((1,0),2),((1,1),3)]"
12:24:39 <dino-> I think something can be done with that for multi-line-ness
12:24:54 <Saizan_> HugoDaniel: which is?
12:25:04 <fffej> noteventiime:  oops, missed off ! (0,2) at the end!  sorry
12:25:18 <noteventime> :)
12:25:21 <HugoDaniel> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8936#a8936
12:26:00 <holmak> dino-: That looks good, thanks!
12:26:19 <noteventime> @src (=~)
12:26:19 <lambdabot> Source not found. There are some things that I just don't know.
12:27:46 <Saizan_> HugoDaniel: you're forgetting the 'o' there
12:29:14 <leimy> ah nm I got it figured out
12:29:28 <Saizan_> HugoDaniel: this should typecheck http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8936#a8937
12:30:01 <HugoDaniel> ah
12:30:06 <HugoDaniel> hmm
12:30:13 <HugoDaniel> how do i manage without instancing the type class ?
12:30:31 <HugoDaniel> you said something about wrapping in a lambda
12:31:01 <HugoDaniel> i tryed that before
12:31:04 <HugoDaniel> but ghci complains
12:31:21 <HugoDaniel> about not being able to call getObjectId on a non-Haskell 98 data type :/
12:32:31 <HugoDaniel> ah i see
12:32:32 <HugoDaniel> ok
12:32:33 <HugoDaniel> thanks :D
12:32:56 <HugoDaniel> the methods of the typeable data are going to be called, cool
12:45:44 <hackagebot> ieee 0.5 - Approximate comparisons for IEEE floating point numbers (PatrickPerry)
13:00:09 <kmc> @pl \a b -> f $ g a b
13:00:10 <lambdabot> (f .) . g
13:39:54 <orbitz> i'm trying to install from sources (tar.bz2 downloaded) and configure is complaining it cna't find GHC, as far as i know I did not skip a step.  this is the latest version on GHC website, and compilong on linux, any ideas?
13:41:02 <Alpounet> orbitz, what're you trying to install from sources ?
13:41:24 <orbitz> whoops, sorry.  ghc
13:41:46 <benmachine> ghc is compiled with ghc I think
13:41:58 <Twey> Mostly.
13:42:00 <copumpkin> plusInteger = Magma (AssociativeC :> CommutativeC :> UnitalC 0 :> InvertibleC negate :> Nil) (P.+)
13:42:02 <copumpkin> mmm
13:42:05 <copumpkin> :P
13:42:10 <orbitz> Indeed, I am under the impression the source distribution is bootstrapped though
13:42:11 <Twey> There's some terrifying Perl involved, as I remember it.
13:42:20 <olsner> copumpkin: what's wrong with plus = (+)?
13:42:24 <Alpounet> orbitz, don't think so.
13:42:34 <Alpounet> the better for you is maybe to install haskell platform
13:42:37 <Alpounet> @where platform
13:42:37 <lambdabot> http://hackage.haskell.org/platform/
13:42:38 <copumpkin> olsner: I'm defining an algebraic structure there, not a function
13:44:46 <daz> what does the makescript say it requires to run? does your linux distribution use a package manager? You may need some dependencies to compile it.
13:44:56 <opqdonut> copumpkin: is that something you're playing around with or actual code?
13:45:03 <copumpkin> opqdonut: it's actual code
13:45:08 <copumpkin> opqdonut: not necessarily in its final form yet though
13:45:13 <copumpkin> but it's typesafe algebraic structures
13:45:26 <copumpkin> where you just define your properties and then can use them as you please
13:45:45 <opqdonut> sounds nice, is it light enough to be useable?
13:45:46 <copumpkin> so that one above could be used for any function that requires (Group a) => or (Monoid a) => or Semigroup a, etc.
13:45:51 <opqdonut> i mean syntactically and semantically
13:46:11 <copumpkin> opqdonut: it's pretty light so far, but I'm still building it, so I'm not sure how unpleasant it'll end up being for the library user
13:46:26 <copumpkin> for now it's just withGroup nameOfGroup (value)
13:46:46 <opqdonut> :)
13:46:47 <copumpkin> or withSemigruop or whatever
13:46:51 <opqdonut> lispy
13:47:33 <copumpkin> I'm rather proud of the substructures thing in it though
13:47:51 <copumpkin> (that is, that structures aren't defined in terms of "This is a group"
13:47:59 <copumpkin> but rather, this has x properties (on the type level)
13:48:11 <copumpkin> and then you can use it with anything that requires those properties
13:48:15 <copumpkin> even if it doesn't require all of them
13:49:12 <copumpkin> you could also have "smart constructors" of structures that use something like quickcheck to make sure your properties are true
13:49:21 <copumpkin> or appear to be true, at least
13:55:06 <lispy> opqdonut: hi?
13:56:28 <opqdonut> lispy: :d
13:56:40 <lispy> what's up?
13:56:56 <opqdonut> lispy: sorry for the hilight, i just commented on copumpkin's api
13:57:19 <opqdonut> but nothing much is up, listening to techno and killing time on irc
13:58:12 <lispy> ah
13:58:22 <lispy> Sorry, I just assumed :)
13:58:36 * lispy is wishing gmail would load
13:58:54 <opqdonut> same here actually
13:59:02 <opqdonut> been acting up all day long
13:59:14 <opqdonut> and you know what, even google search is flaking
13:59:19 <lispy> There is a good chance they tried to upgrade something on the server side then :)
13:59:28 <opqdonut> i had to actually resort to an other search machine
13:59:37 <lispy> Quick, switch to bing/livemail ;)
13:59:37 <opqdonut> last time was in the nineties or something :D
13:59:44 <orbitz> Alpounet: i think my libc is too old
14:01:30 <Alpounet> orbitz, to install platform ?
14:01:41 <orbitz> Alpounet: yes
14:01:55 <Alpounet> which distro are you using ?
14:02:04 <mauke>  CTCP VERSION reply from orbitz: mIRC v6.16 Khaled Mardam-Bey Linux Beta
14:02:06 <mauke> GOOD JOB
14:02:11 <Alpounet> hmm...
14:02:14 <opqdonut> :D
14:02:57 <orbitz> Alpounet: linux
14:03:07 <orbitz> Alpounet: i get
14:03:13 <orbitz> checking for path to top of build tree... pwd: timer_create: Invalid argument
14:03:16 <orbitz> on the configure
14:03:18 <Alpounet> which linux distribution ?
14:03:20 <orbitz> which appears to be a sign of a libc too old
14:03:34 <orbitz> redhat
14:03:51 <Alpounet> use if possible your package manager to install platform, its depencies should be complete enough to fix such problems.
14:05:27 <path[l]> I used cabal to install hlint. How do I run it now?
14:05:43 <mauke> where did you install it?
14:05:55 <path[l]> I dunno where cabal puts it =p
14:05:57 <Peaker> path[l]: put ~/.cabal/bin in your $PATH - that's the default/usual install path for cabal exec's
14:06:02 <lispy> path[l]: there is a good chance that cabl put it into ~/.cabal/bin
14:06:23 <benmachine> I changed cabal to install in system directory
14:06:27 <benmachine> I can't actually remember why now
14:06:31 <benmachine> I probably had a good reason
14:06:39 <path[l]> ah thanks
14:07:19 <Alpounet> orbitz, instructions for fedora : http://fedoraproject.org/wiki/Haskell_SIG#Haskell_Platform_support
14:36:10 * copumpkin wonders if the icfp contest final ranking has been announced somewhere and someone just forgot to update the page
14:38:40 <Cale> copumpkin: has the actual conference happened already?
14:38:59 <copumpkin> Cale: I thought it was happening now
14:39:42 <Cale> Normally they announce the results during the conference, so I don't know
14:44:01 <HugoDaniel> can someone point me out where i can read about typeable data types, and their uses in type classes ?
14:45:10 <Lemmih> HugoDaniel: Want to know anything specific?
14:46:47 <HugoDaniel> i want to understand them so that i can know what i am doing
14:47:48 <Lemmih> HugoDaniel: You could try playing around with Data.Typeable in ghci.
14:48:59 <jpcooper> is there an opposite of hGetContents for putting lazy strings onto a handle, or is that only possible with lazy bytestrings?
14:49:04 <HugoDaniel> i used to think i understood them, but know i dont
14:49:22 <copumpkin> jpcooper: how would that work?
14:49:35 <copumpkin> not sure how writing lazily would work
14:49:38 <Lemmih> jpcooper: Well, hPutStr does that.
14:49:41 <copumpkin> the filesystem would need to be able to request data
14:49:53 <jpcooper> oh okay
14:50:44 <jpcooper> it'd be nice if I could have a lazy string and the contents of it could be written to a handle as things come in
14:51:04 <jpcooper> I suppose I could to this with channels and getChanContents?
14:51:22 <copumpkin> that should already happen I think
14:51:23 <Lemmih> Normal IO does exactly that.
14:52:15 <Saizan> hPutStr does write your String as soon as it is produced, modulo buffering
14:52:30 <jpcooper> yes but I'd like it to be written as the string is produced
14:52:41 <mauke> what do you mean by "but"?
14:52:45 <jpcooper> never mind, it's not so important
14:52:51 <copumpkin> jpcooper: no, that's what will happen...
14:53:13 <Lemmih> jpcooper: That /is/ what hPutStr does.
14:53:15 <jpcooper> IO INFINITELIST >>= hPutStrLn handle
14:53:24 <mauke> yes?
14:53:28 <copumpkin> that works
14:53:38 <copumpkin> just put it in its own thread or you won't be able to do anything else
14:53:39 <Saizan> well, it depends
14:53:43 <jpcooper> doesn't the whole list have to be computed first?
14:54:05 <mauke> return (repeat 'w') >>= putStrLn
14:54:06 <Saizan> all the side effects relative to producing the list has to computed first
14:54:15 <Saizan> *to be
14:54:33 <Saizan> but not the list itself
14:55:00 * copumpkin just filled a 192 MB file with mauke's line
14:55:27 <Saizan> if you want the side-effects to be delayed you want to use unsafeInterleaveIO inside your IO INFINITELIST action
14:55:39 <mauke> putStr (cycle "y\n")  -- yes
14:56:13 <copumpkin> forever (putStrLn "y") has the same behavior doesn't it?
14:56:30 <Phyx-> :t forever
14:56:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:56:34 <Phyx-> the heck
14:56:38 <copumpkin> :P
14:56:38 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8943#a8943
14:56:39 <Phyx-> it even exists
14:56:51 <copumpkin> Phyx-: it's useless on many Monad instances
14:56:57 <copumpkin> there should be a MonadForever class
14:56:59 <copumpkin> :P
14:57:01 <HugoDaniel> im having this error, is it because im not using initialize in my code yet, and so ghci cannot infer its type ?
14:57:06 <Phyx-> copumpkin: oh, now i remember, i think i used it with threads
14:57:16 <copumpkin> Phyx-: it's most useful with IO
14:57:25 <jpcooper> so say I have:     fmap (map multiplyCharBy2) (hGetContents handle) >>= hPutStr handle2, will it start outputting to handle2 as soon as input comes in on handle?
14:57:27 <copumpkin> with lists it's useless as far as I can see
14:57:40 <Saizan> jpcooper: yes
14:57:47 <Phyx-> copumpkin: heheeh, yeah, for that there's cycle already and repeat
14:57:50 <jpcooper> okay thanks a lot
14:58:10 <jpcooper> if only I knew this before
14:58:36 <copumpkin> you could've experimented!
14:58:36 <copumpkin> :D
14:58:44 <copumpkin> experimentation is where all the fun is :)
14:58:51 <jpcooper> I did and thought that I had found a counter-example
14:58:51 <Phyx-> exactly
14:58:52 <Phyx-> :)
14:58:55 <Saizan> HugoDaniel: no, you forgot to rewrap the result with the RObject constructor
14:59:01 <Phyx-> and having ghc give you cryptic errors!
14:59:03 <Phyx-> always fun
14:59:09 * copumpkin 's algebraic abomination is a result of such experiments
14:59:25 <copumpkin> Saizan: did you see my latest algebraic abomination? worse even than my last failgebra attempt!
14:59:47 <Saizan> copumpkin: i didnt!
14:59:52 <HugoDaniel> Saizan: "i forgot" :D
14:59:58 <copumpkin> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8941 :P
15:00:10 <HugoDaniel> the problem is that in my head it makes sense like it is right now
15:00:29 <copumpkin> Saizan: I still haven't added the smart constructors though
15:00:42 <copumpkin> got sidetracked into adding more stuff elsehwere
15:01:12 <aavogt> > forever []
15:01:13 <lambdabot>   []
15:01:21 <copumpkin> > forever [1]
15:01:23 <lambdabot>   * Exception: stack overflow
15:01:37 <copumpkin> > forever (fix (1:))
15:01:39 <lambdabot>   * Exception: stack overflow
15:01:44 <aavogt> > (Nothing `forever`)
15:01:46 <lambdabot>   Nothing
15:02:04 <copumpkin> > (Just "do it" `forever`)
15:02:09 <lambdabot>   mueval-core: Prelude.read: no parse
15:02:09 <lambdabot>  mueval: ExitFailure 1
15:02:21 <Saizan> HugoDaniel: RObject a and the contained (o a) are not the same type.
15:02:31 <Philonous1> I have a datatype Foo a = a `Foo` a and I want to define for any Functor m an instance Functor (Lambda a. Foo (m a) (m a)) with fmap f (Foo a b ) = Foo (fmap f a ) (fmap f b). I know how to implement it, but how do I write the instance header?
15:02:46 <etpace_> > let foo x = x + 1 in 5 `foo`
15:02:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:02:48 <copumpkin> Lambda a. :o
15:02:53 * aavogt wonders where the infix notation for single-argument functions went with ghc 6.10
15:03:02 <copumpkin> aavogt: it's still there
15:03:08 <copumpkin> there's an extension for it iirc
15:03:09 <Saizan> HugoDaniel: so, "initialize x" which has type R (Maybe (o a)) can't be of type R (Maybe (RObject a))
15:03:28 <benmachine> is forever actually useful for anything unrelated to IO?
15:03:41 <Philonous1> copumpkin: This is supposed to be a type level lambda, which unfortunately doesn't exist in Haskell :-(
15:03:48 <copumpkin> Philonous1: aw
15:03:50 <mauke> Λ
15:03:56 <HugoDaniel> i see
15:03:59 <|randomwords|> copumpkin: I think I just got tha algebraic equivalent of diabetes reading your Algebra module
15:04:10 <copumpkin> |randomwords|: who did?
15:04:13 <Saizan> copumpkin: does Subset work?
15:04:17 <copumpkin> Saizan: yep
15:04:19 <benmachine> I suppose forever is a bit like fix
15:04:23 <copumpkin> Saizan: all the code is usable :P
15:04:25 <|randomwords|> I did?
15:04:37 <Phyx-> @src forever
15:04:38 <lambdabot> Source not found.
15:04:39 <copumpkin> |randomwords|: oh, I misread that as "he just got the algebraic equivalent" sorry
15:04:42 <Phyx-> :t fix
15:04:43 <lambdabot> forall a. (a -> a) -> a
15:04:44 <copumpkin> |randomwords|: sorry to hear that!
15:04:50 <benmachine> forever a = a >> forever a
15:05:01 <Phyx-> benmachine: can't forever be defined in terms of fix?
15:05:02 <copumpkin> Saizan: needs much cleaning up to not be quite as ridiculously misbehaved
15:05:09 <benmachine> probably
15:05:10 <copumpkin> Saizan: but I'm enjoying where it's heading
15:05:14 <benmachine> @src fix
15:05:14 <lambdabot> fix f = let x = f x in x
15:05:17 <pr> @type fix
15:05:18 <Saizan> copumpkin: what if (x `Compare` y) /~ GT ?
15:05:19 <lambdabot> forall a. (a -> a) -> a
15:05:20 <pr> @type forever
15:05:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:05:26 <HugoDaniel> Saizan: but it really mixes my head when i say "instance RObjectClass RObject ..." :/
15:05:31 <aavogt> @type fix (>> ?f)
15:05:33 <HugoDaniel> i guess i just dont know what im doing
15:05:33 <lambdabot> forall (m :: * -> *) b. (?f::m b, Monad m) => m b
15:05:54 <aavogt> > fix (>> [])
15:05:58 <Saizan> HugoDaniel: have you read something about existential types?
15:06:00 <lambdabot>   mueval-core: Prelude.read: no parse
15:06:00 <lambdabot>  mueval: ExitFailure 1
15:06:05 <HugoDaniel> Saizan: no
15:06:21 <aavogt> > fix ([] >>)
15:06:21 <Saizan> HugoDaniel: you should, since RObject is one
15:06:22 <kmc> what's this mueval business
15:06:22 <lambdabot>   []
15:06:40 <aavogt> kmc: lambdabot evaluation has a time limit
15:06:42 <Phyx-> ?f is an implicit argument right?
15:06:42 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber flush foldoc forget fortune fptools free freshname ft . ? @ bf v
15:06:50 <aavogt> Phyx-: yes
15:06:57 * copumpkin has to go
15:07:01 <benmachine> @?
15:07:08 * copumpkin will write more obscene algebra later
15:07:10 <benmachine> @help ?
15:07:10 <lambdabot> ? [args].
15:07:11 <lambdabot> ? executes plugin invocations in its arguments, parentheses can be used.
15:07:11 <lambdabot>  The commands are right associative.
15:07:11 <lambdabot>  For example:    ? ?pl ?undo code
15:07:11 <lambdabot>  is the same as: ? (?pl (?undo code))
15:07:22 <benmachine> oh I suppose that makes sense
15:07:25 <Phyx-> ?pl \x->x
15:07:25 <lambdabot> id
15:07:47 <Phyx-> so, is @ then left associative?
15:07:54 <HugoDaniel> Saizan: robject is to be defined for all types that implement the given type classes
15:08:13 <aavogt> @bf
15:08:14 <lambdabot>  Done.
15:08:23 <copumpkin> ciao :)
15:08:30 <Saizan> bye
15:08:42 <mun> if i want to prove that if t <= 1 then t <= 2, which axioms of the natural numbers should be used? i've rewritten it to become if t <= suc(0), then t <= suc(suc(0))
15:09:02 <Phyx-> bye copumpkin
15:09:06 <Phyx-> oops, already left
15:09:09 <mun> oops
15:09:10 <Saizan> HugoDaniel: yeah, it contains an unknown type which is a member of that typeclass
15:09:11 <mun> wrong chan
17:35:56 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
17:35:56 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
17:35:56 --- names: list (clog o-regalia elliotstern amz bens walrus chpln resistor jorizma kpreid kfish bel5f5 Rotaerk waern_ XGas dolio nick-m _-jn smorg mreggen dschoepe_ fbru02 rgr horms igorgue tromp snhmib whoppix erg0t psal defun_ `w1zard jml altmattr keseldude surgeon trie kunkila McManiaC Peaker Geheimdienst Trafalgards saccade randomwords ath davatk Nereid_ ericP dort Petrosian merus Phyx- Popper SubStack r0bby SamB_XP dancor Alucard_Not_Orca Guest70389)
17:35:56 --- names: list (kolmodin sclv_ wormwood thingwath zsol jimfear skorpan O_4 blueflute bgs100 Stinger Lycurgus vav Raynes aconbere klon lstor Lemonator Saizan nooga pheaver dodo_the_last ketil sbahra woggle ChthonLaptop trez zakwilson_ laynor_ pikhq jedediah_ kynky jajamana1 dcolish aanand dibblego themroc--- jmelesky jcd1 omichael gbacon Pthing watermind slash_ tessier trofi Kambus` vinicius niksnut c_wraith monochrom jamesbritt ray bd_ SyntaxNinja necrobious)
17:35:56 --- names: list (andrewz loupgaroublond noteventime jfredett byorgey gogonkt rdd triplez roconnor hzap PsiOmega carlocci pr CESSMASTER JackJoke_ der_eq koninkje_away drbean groberts qz_ eevar_ Schmidt s76__ JaffaCake1 Nshag djahandarie Khisanth drhodes hiratara FilipeMaia dumael intrados_ voker57 shepheb_ StoneToad Mr_Awesome_ dogmaT Philonous1 sgwizdak otto_s_ xinming daz juhp BMeph poucet polux fnordus M| benmachine pinp jan_ Raevel burp sjanssen DarthArachides)
17:35:56 --- names: list (Dunearhp Xichekolas jix_ Tomas mmorrow Pewpewarrows alexsuraci Baconizer Ryan52 arjanoosting Adamant elias` eno dfeuer danopia` Draconx rntz brad_larsen Makoryu sshc_ defun mahogny preflex lanaer mapreduce levitation[A] jvogel icee det apples` cognominal_ blackdog proq Twey joed araujo wjt amgarching fredcy oubiwann Axman6 Berengal desp authentic gnuvince reqamst te LeCamarade|Away ville DoubleDose42 Jaak Mitar nathanic2 gnufied_ sebbe1991)
17:35:56 --- names: list (yoonkn fxr Modius_ aarong caligula__ ski Valodim dilinger vili Poeir Cale gwern jbauman DEVOKUN mauke Vanadium lambdabot SimonRC guerby clanehin Optimo syntaxglitch sohum jaj Hong_MinHee karld p_l kmc Counter-Strike flori LeoD alexbobp mun Cthulhon nego Eelis dr4wd3 arw_ QtPlaty[HireMe] AnMaster vegai DrSyzygy lunabot thetallguy kadoban mikm jmillikin shapr astrocub greap Colours integral cmeme nlogax eelco_ Milo- zong_sharo mikezackles)
17:35:56 --- names: list (CalJohn Igloo g0ju nasloc__ jeffersonheard Ytinasni leadnose thirsteh taruti impl glasser` quarks jlouis alip Stephan212 sebas_ dreixel luis aluink glith joga wuncidunci hackagebot m-i-l-a-n Nereid __marius__ TimMc anders^^ bran mikem` saiam mornfall dmwit LionMadeOfLions wdonnelly ponzao___ mm_freak ehamberg lefant cjay DekuNut karihre_ ertai joyful Jedai kw317 qm13 quicksilver Heffalump harlekin tltstc mokus nominolo|uni ksandstr _janne)
17:35:56 --- names: list (inimino kar-1 electrog1ek pragma_ laz0r wolverian Gertm dqd purplepenguins galdor Nanar luite shachaf Elly xci erk periodic ennen dionoea klugez mux sunnavy hellige davidL Annie|Home Laney nablaa lilac epmf Ferdirand Baughn mjrosenb deavid Badger felipe_ deiga canvon idnar mmmulani edwinb erg Boney equanimity BrianHV Twigaathy nimred djinni` gdsx daed_ mrd regulate ahf webframp marmolak lispy gOcOOl MarcWeber tkr Gabbie AndyP loop jahgru)
17:35:56 --- names: list (chr1s t Shurique Gilly agemo jfoutz pettter dsfox PHO__ mattam nwf netcat liyang sbok etpace_ tuukkah eivind mle thomastc Taggnostr thetallguy1 magicman|sleep raimo_ ibid ToRA dons dixie jlaire miasma tarbo_ Bleadof yottis StarFire opqdonut blackh Paks brx MyCatVerbs ingy jvoorhis ArneB Vq jrockway fadec_ neurocyte absentia _rey kalven SeaPrior maxote orbitz mlh_ suiside dino- majoh earthy jdavis matthew-_ Jiten Blub\0 _Jordan_ daf michie1)
17:35:56 --- names: list (allbery_b osfameron Hunner desu elliottt mercury^ wagle_home yahooooo Liskni_si malouin And[y] kaol nornagon Warrigal gereedy Megant jims TML Aisling koeien otulp Pistahh dufflebunk stanv mike-burns solrize thoughtpolice jonafan Botje defn frederik ido Lemmih tmoertel_work_ pcc1 qebab mfp J11 poe sully ricky26 flux koala_man xian Sisu Nafai Zao andrewsw smg aavogt hiredman cods OnionKnight tomlok noj Deewiant Philippa_ mdmkolbe olsner kosmikus)
17:35:56 --- names: list (@ChanServ PeakerWork pastorn jajamana aempirei matsuura m_g skaar jnwhiteh ziman anji maskd endojelly nothingmuch _br_ profmakx)
17:36:17 <Twey> Hmm.  Is that a valid reason?
17:36:39 <sjanssen> surgeon: you want mapM
17:36:39 <defun_> Makoryu: well yes. They are functions, in a manner of speaking.
17:36:39 <defun_> conecptually
17:36:39 <defun_> or containers
17:37:08 <Twey> I mean, obviously types aren't first-class if Java classes aren't (Data.Dynamic et al) but the mere fact that they're in different namespaces doesn't seem to lead to that conclusion.
17:37:33 <Twey> CL has functions in a separate namespace, yet I don't think anyone would argue that it doesn't have first-class functions.
17:37:53 <monochrom> Perl keeps scalars, lists, maps in three different namespaces.
17:38:24 <defun_> perl drives me nuts.
17:38:52 <monochrom> You can even say that scalar variables have to be wrapped under $, list variables under @, map variables under #, just to pull unimportant syntax into the story.
17:39:21 <defun_> it takes all of unixes deficiencies and packages them in kludge.
17:39:44 <defun_> truly abysmal language, imho.
17:39:44 <defun_> *unix's
17:39:58 <monochrom> And so I don't care about clumsy ridiculous syntax. I only care about "what can you do with X".
17:40:33 <Twey> monochrom: Functions too, no?
17:40:42 <Twey> A fourth namespace?
17:41:08 <aavogt> haskell has lots of namespaces
17:41:18 <Twey> Really?
17:41:19 <kmc> perl also has globs and filehandles
17:41:25 * kmc feels terrible for knowing that
17:41:26 <monochrom> I don't know how first-class Perl functions are. But surely lists are first-class despite namespace and despite @
17:41:27 <Twey> Value, type, kind
17:41:31 <Twey> Pattern?
17:41:37 <Axman6> defun_: i decided i never wanted to use perl when i found out it cannot be statically parsed. i thought that was just hilarious
17:41:57 <Twey> Hahaha
17:42:06 <kmc> defun_: Agda has first-class modules
17:42:07 <defun_> lol
17:42:12 <kmc> and ML's module system is famous
17:42:21 <pr> being able to parse perl = being able to solve the halting problem
17:42:21 <kmc> and both of these are sort of like Haskell
17:42:21 <pr> hehe
17:42:28 <defun_> kmc: thanks.
17:42:35 <Twey> Thing about first-class modules is that they seem like they'd be quite clumsy in a pure language
17:42:48 <kmc> Twey, why?
17:42:59 <Twey> Well, you'd essentially have to treat them like a map, no?
17:43:03 <Draconx> Axman6, well, C++ has the same problem.
17:43:22 <kmc> you can get quite close to first-class modules with parametric record types
17:43:30 <kmc> Draconx, no
17:43:30 <gOcOOl> is this IF statement valid in Haskell? 'if 1 then "hi" else 123'
17:43:30 <gOcOOl> I'm not sure why evaluating it in ghci is giving me an error
17:43:38 <Twey> gOcOOl: No
17:43:44 <Twey> An expression can only have one type
17:43:54 <kmc> gOcOOl, what would its type be?
17:43:56 <monochrom> Split personality between string and number
17:43:59 <kmc> not string or int
17:43:59 <Axman6> gOcOOl: is 1 a boolean value?
17:44:04 <Axman6> @src Bool
17:44:04 <lambdabot> data Bool = False | True deriving (Eq, Ord)
17:44:06 <Twey> if is an expression; therefore, it must return only one type no matter what the predicate value is
17:44:19 <kmc> Draconx, you don't need to execute a C++ program in order to parse it
17:44:20 <monochrom> This has Perl written all over it.
17:44:22 <Twey> And, yeah, I just spotted that, too :)
17:44:31 <kmc> :t if True then "hi" else 123
17:44:33 <lambdabot>     No instance for (Num [Char])
17:44:33 <lambdabot>       arising from the literal `123' at <interactive>:1:23-25
17:44:33 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
17:44:33 <Draconx> kmc, you might need to simulate a turing machine.
17:44:36 <kmc> :t if True then 123 else 456
17:44:37 <lambdabot> forall t. (Num t) => t
17:44:41 <kmc> Draconx, not to parse it
17:44:52 <gOcOOl> ahhhh ok, that's exactly what I was trying to get at. this makes sense now
17:44:54 <Draconx> kmc, one second, let me find it.
17:44:57 <kmc> unless there's an additional terrible secret of C++ that i'm not aware of
17:45:00 <kmc> which is totally possible
17:45:01 <Draconx> kmc, templates.
17:45:11 <kmc> Draconx, but parsing templates is not
17:45:14 <kmc> only instantiating them
17:45:21 <monochrom> Some people include typechecking as part of parsing.
17:45:29 <Draconx> kmc, right, and instantiating a template can cause something to be a declaration or not a declaration.
17:45:32 <kmc> in fact the parsing of templates is notoriously stupid
17:45:39 <kmc> Draconx, but that is resolved by failing terribly
17:45:47 <kmc> rather than by performing arbitrary computation
17:46:15 <kmc> you have to write "typename" before your declaration even if it's f'cking obvious to all parties involved that the thing is a type
17:46:39 <kmc> monochrom, :/
17:47:00 <monochrom> I don't think it's all that surprising.
17:47:43 <kmc> defun_, i think it was decided that many of the things ML's modules were used for would be subsumed by typeclasses in Haskell
17:48:24 <kmc> and with fundeps and associated types and existentials and such, that's even more true now
17:48:25 <defun_> kmc: thanks for the info.
17:48:39 <kmc> but probably there would still be an argument for first-class modules in haskell as well
17:49:13 <monochrom> I want to have block-scoped typeclass instances.
17:50:00 <dolio> Miranda, the language Haskell is descended from, has neither type classes nor ML-like modules.
17:50:06 <dolio> (As far as I can tell, at least.)
17:50:15 <kmc> actually, Scala gets rid of typeclasses entirely in favor of value inference on implicit arguments
17:50:27 <kmc> which means among other things that you get to use all your scoping machinery for free
17:50:50 <dolio> Type classes were originally introduced for reasons that aren't obviously related to what ML modules are good for.
17:51:51 <defun_> kmc: possibly. what i'm more interested in is how can someone overlay a macro-system (pre-processor) on top of the language. So that the preprocessor can be called from the language itself, to tell the compiler what to do. That might be fun. But i'd imagine it gets messy. and yes, i studied common lisp over the weekend (not that i'm an expert).
17:52:04 <kmc> defun_, have you seen Template Haskell?
17:52:35 <defun_> kmc: no.
17:52:35 <defun_> kmc: i forgot about that.
17:52:50 <defun_> kmc: i'll have to check that out.
17:52:55 <kmc> it sounds like what you describe
17:52:56 <defun_> kmc: can it implement do notation from scratch?
17:53:09 <kmc> and they have clever ways to keep the messiness manageable
17:53:15 <CalJohn> i don't know TH very well, but i think it is a bit different from cl's macros
17:53:17 <dolio> Template Haskell doesn't let you define new syntax.
17:53:20 <kmc> defun_, i don't think you can extend the grammar of haskell
17:53:21 <surgeon> sjanssen: thanks
17:53:26 <kmc> the quasiquoting feature in GHC can
17:53:37 <kmc> but that might be a bit heavy-weight to add one syntactic extension to haskell
17:54:13 <dolio> There's a macro system (or something like that) for OCaml that lets you define new syntax, though.
17:54:14 <defun_> kmc: i know. and like i said, such grammar transformations can get messy.
17:54:18 <dolio> You might want to look at that.
17:54:22 <kmc> camlp4
17:54:28 <kmc> it's very fancy
17:54:29 <defun_> kmc: s-exprs make macros easier, imho.
17:54:33 <kmc> yes
17:54:45 <CalJohn> (cl's macroes are a compile time substitution of sexps, which is possible because cl's has no sugar at all)
17:55:16 <defun_> kmc: i take it that camlp4 is the ocaml macros you mentioned?
17:55:17 <kmc> but languages that use s-exprs are unreadable and unusable
17:55:22 * kmc ducks
17:55:31 <kmc> defun_, that dolio mentioned, i think
17:55:45 <CalJohn> i hear people in ml communities say that a lot, but i never, ever found that
17:55:46 <defun_> kmc: they are a pain, and the macros only help to a degree.
17:55:46 <dolio> Yes.
17:56:05 <defun_> yes, sorry, i meant dolio.
17:56:13 <CalJohn> operator precedence, while small, is a much bigger deal
17:56:14 <dolio> I don't actually know much of anything about camlp4, beyond that it exists.
17:56:32 <Makoryu> Twey: ^ Having stuff in separate namespaces is less significant than being unable to put a reference to stuff from one namespace into another namespace
17:56:46 <defun_> CalJohn, what are you refering to? s-exprs?
17:56:59 <CalJohn> yes
17:57:02 <monochrom> I routinely drink espresso without sugar.
17:57:20 <SubStack> same
17:57:21 <Makoryu> Twey: For example, CL gives you funcall and function-quoting (#'), and Perl gives you references
17:57:26 <Makoryu> (Which are scalars)
17:57:36 <kmc> it's odd to say that sexps are better than other things because they *lack* the feature of infix
17:57:42 <kmc> if you don't like that feature, don't use it
17:57:55 <defun_> kmc: i /love/ infix.
17:58:06 <SamB> kmc: basically the nice thing about sexps is that they are structured
17:58:12 <Berengal> kmc, it enables you to put funky symbols in regular names though
17:58:13 <kmc> i `love` infix
17:58:19 <defun_> kmc: I would commit suicide if . and $ dissapeared.
17:58:27 <SamB> lacking infix was just one thing that made that a lot simpler to do
17:58:31 <defun_> lol
17:58:53 <Makoryu> Twey: But in Haskell you can't wrap a type to pass it to a function (without extensive hackery) and you can't put a normal value into a type signature
17:59:16 <CalJohn> i am mixed on infix
17:59:20 <CalJohn> i use it a lot, obviously
17:59:24 <pikhq> sexp is nice primarily because it is very, very easy to handle programatically.
17:59:31 <monochrom> There are still programming languages that force you to use infix, e.g., C. No such thing as (+) or op +
17:59:34 <kmc> but are you in on mixfix ??
17:59:44 <kmc> monochrom, C++ :D
17:59:59 <arw_> as a physicist i'm inclined to say, infix is really nice, but only with enough freedom.
18:00:02 <kmc> operator+(2, 3)
18:00:07 <Makoryu> monochrom: Don't forget J, where *everything* is infix
18:00:10 <CalJohn> haha, i suppose i mean I am mixed on mixfix also
18:00:11 <arw_> e.g. its really nice in haskell, but its stupid in c++
18:00:24 <kmc> arw_, i agree, it's ridiculous to let users override "built in" operators but not define new ones
18:00:53 <kmc> take a loot at Boost.Spirit... it's like Parsec but the syntax is constrained to built-in C++ operators
18:00:54 <monochrom> The distinction between "function" and "operator" is bunk.
18:00:57 <CalJohn> compose is certainly very ugly in the various lisps
18:01:12 <Berengal> And then there's java who left out overriding operators just because it was confusing in c++...
18:01:13 <Axman6> does anyone else things that C++ looks like a dead fish? (C++<)
18:01:18 <Twey> Makoryu: Right
18:01:20 <Axman6> think even
18:01:26 <Makoryu> Axman6: D:
18:01:37 <Axman6> you know i'm right
18:01:40 <Berengal> Axman6++
18:01:46 <monochrom> Stylistic difference, yes, but surely not to be point of one being user-definable and the other dictated.
18:01:52 <dancor> when ad hominem meets ascii art
18:01:55 <Berengal> @remember Axman6 does anyone else things that C++ looks like a dead fish? (C++<)
18:01:55 <lambdabot> Good to know.
18:02:02 <Axman6> Berengal: elongated dead Axman fish
18:02:06 <copumpkin> Berengal: fail
18:02:11 <kmc> what about C++1x
18:02:16 <Axman6> @forget Axman6 does anyone else things that C++ looks like a dead fish? (C++<)
18:02:16 <lambdabot> Done.
18:02:17 <defun_> hey, how set my status as away on irc.
18:02:25 <defun_> is it \away
18:02:26 <copumpkin> defun_: please don't
18:02:26 <Axman6> @remember Axman6 does anyone else think that C++ looks like a dead fish? (C++<)
18:02:26 <lambdabot> Done.
18:02:28 <arw_> kmc: nuclear power plant fish :)
18:02:38 <copumpkin> defun_: most clients do it obnoxiously, just leave :P
18:02:45 <Axman6> @quote C++
18:02:45 <lambdabot> dons says: I don't mind autoconf, except for the fact that it's stupid and ugly
18:02:51 <Axman6> @quote C++
18:02:52 <lambdabot> monochrom says: 16 is the ripe age for writing your own compiler, you know.
18:02:55 <copumpkin> @karma c
18:02:55 <lambdabot> c has a karma of 1
18:02:59 <copumpkin> @karma C
18:02:59 <lambdabot> C has a karma of 1
18:03:04 <kmc> @quote Visual Basic
18:03:04 <lambdabot> No quotes for this person. Maybe you made a typo?
18:03:07 <Axman6> @karma C++
18:03:07 <lambdabot> C++ has a karma of -2
18:03:11 <Axman6> XD
18:03:22 <copumpkin> C+++
18:03:27 <copumpkin> @karma C+
18:03:27 <lambdabot> C+ has a karma of 3
18:03:27 <dancor> defun_: i can't tell if you are kidding.  it's /away, irc commands start with /
18:04:00 <defun_> that's what i meant. as you can see i code in haskell too much.
18:04:22 <kmc> :t \away -> (/away)
18:04:23 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:04:37 <Axman6> heh
18:04:43 <psal> \away -> IO ()
18:06:06 <monochrom> \ means you write LaTeX too much.
18:06:42 <arw_> Why do you say that\,?
18:07:10 <porges> I have a quick question on writing nicer code: converting a list of [(a,b,c)] into Map a (Map b (Set c))
18:07:16 <porges> at the moment I have;
18:07:24 <porges> Map.map (Map.map Set.fromList) . Map.map (Map.fromListWith(++)) . Map.fromListWith(++) . map (\(a,b,c) -> (a,[(b,[c])]))
18:07:45 <porges> is there a nicer way to do this? :P
18:07:52 <kmc> :t Map.map
18:07:53 <lambdabot> Couldn't find qualified module.
18:08:01 <aavogt> :t M.map
18:08:02 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
18:08:38 <copumpkin> porges: what's it doing?
18:08:49 <mmmulani> how do you pattern match with a parameter's value?
18:08:51 <copumpkin> :t Map.map (Map.map Set.fromList) . Map.map (Map.fromListWith(++)) . Map.fromListWith(++) . map (\(a,b,c) -> (a,[(b,[c])]))
18:08:52 <lambdabot> Couldn't find qualified module.
18:09:09 <kmc> mmmulani, what do you mean
18:09:15 <copumpkin> :t M.map (M.map S.fromList) . M.map (M.fromListWith(++)) . M.fromListWith(++) . map (\(a,b,c) -> (a,[(b,[c])]))
18:09:16 <lambdabot> forall a k k1. (Ord a, Ord k, Ord k1) => [(k1, k, a)] -> M.Map k1 (M.Map k (S.Set a))
18:09:24 <copumpkin> ah
18:09:46 <aavogt> > \x -> case x of 42 -> True; _ -> False $ 42
18:09:47 <lambdabot>   Couldn't match expected type `a -> b'
18:09:48 <mmmulani> kmc: suppose I have a function which defines another function in its "where" clause
18:09:56 <aavogt> > (\x -> case x of 42 -> True; _ -> False) 42
18:09:57 <lambdabot>   True
18:09:59 <copumpkin> porges: I was doing something similar recently, let me think
18:10:26 <mmmulani> kmc: how would I pattern match for a function in the where clause, with a value from the main function
18:10:54 <kmc> mmmulani, arguments to the outer function are free variables of the inner function, if that's what you're asking
18:10:58 <monochrom> I wonder why it is not Map (a,b) (Set c)
18:10:59 <kmc> you can use them e.g. in a "case" expression
18:11:02 <mmmulani> hmmm
18:11:22 <aavogt> mmmulani: or use pattern guards
18:11:48 <Berengal> I like the fact that you can use pattern guards on variables, not just functions...
18:12:28 <aavogt> > (\x | x == 42 -> True) 42
18:12:29 <lambdabot>   <no location info>: parse error on input `|'
18:12:45 <Berengal> > let {foo | bar > 10 = 5 | otherwise = 15; bar = 9;} in foo
18:12:46 <lambdabot>   15
18:13:13 <aavogt> too bad lambdas can't take real patterns
18:13:25 <aavogt> and we're stuck using the ugly  \x -> case x of ...
18:13:51 <aavogt> or is there a better way?
18:14:27 <mmmulani> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8948#a8948
18:14:36 <chessguy> > let f 2 = 2; f x = x + 1 in f 4
18:14:37 <lambdabot>   5
18:14:40 <monochrom> Someone tried to propose a better way on the haskell-cafe mailing list. It didn't fly. IMO it was not a better way.
18:14:44 <chessguy> aavogt, is that what you mean?
18:14:49 <mmmulani> I'm trying to make it so that f 10 produces [10,9..0]
18:14:51 <monochrom> Then no one tried again.
18:14:52 <DEVOKUN> is there an easier way of specifying all the required packages when compiling via ghc other than having to pass the -package option for each package?
18:15:15 <sshc_> Hi, I've downloaded and built the source of wxHaskell.  Now, what do I to "define" the module "Graphics.UI.WX" with ghc?
18:15:24 <aavogt> DEVOKUN: use cabal
18:15:42 <DEVOKUN> ok thanks
18:15:56 <sshc_> aavogt: how does ghc know where to find wx if I installed it using cabal?
18:15:59 <aavogt> or the --make flag to ghc if its just a couple files
18:16:16 <aavogt> sshc_: it should
18:16:28 <sshc_> aavogt: is a default path on to search?
18:16:40 <chessguy> mmmulani, try this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8948#a8949
18:16:40 <sshc_> aavogt: is there a default path on which to search?
18:17:10 <c_wraith> sshc_: It registers the package with ghc-pkg
18:17:12 <Makoryu> aavogt: The sanest proposal I saw was "case of foo..."
18:17:18 <DEVOKUN> --make is exactly what i needed, thankyou
18:17:31 <mmmulani> chessguy: thanks, that's what I started doing :P
18:17:35 <sshc_> c_wraith: oh.  Where does GHC keep track of all registered packages?
18:17:50 <chessguy> > let f num = g [] 0 where g acc n | n == num = acc | otherwise = g (n:acc) (n+1) in f 10
18:17:51 <lambdabot>   [9,8,7,6,5,4,3,2,1,0]
18:18:08 <monochrom> Berengal: I like that too. It's most convenient and sensible with: f x | gx>0 = blah | gx<0 = haha  where gx = g x. Elegant and efficient.
18:18:26 <chessguy> mmmulani, ^^
18:19:21 <Axman6> DEVOKUN: always compile with --make, because it makes life easier
18:19:22 <aavogt> sshc_: ghc-pkg list should name at least one package.conf
18:19:43 <monochrom> ghc --make war
18:20:02 <aavogt> target `war' is not a module name or a source file
18:20:21 <monochrom> ghc --make me a sandwich
18:20:21 <DEVOKUN> yes I've just discovered it right now, I was specifying each package individually and I've also just discovered I can exclude the output name with --make which is so much easier
18:20:25 <Axman6> ghc --make love ¬war
18:21:15 <Berengal> Not using --make is madness
18:21:26 <Axman6> indeed
18:21:27 <monochrom> use --make or cabal
18:21:48 <Berengal> cabal is also fine, but not when you module is called foo.hs
18:22:05 <aavogt> is anyone familiar with Distribution.Simple.GHC.getInstalledPackages?
18:23:08 <aavogt> getInstalledPackages verbose GlobalPackageDB (addKnownProgram (simpleProgram "Cabal") emptyProgramConfiguration)
18:23:41 <aavogt> fails with an irrefutable pattern match failure
18:30:43 <aavogt> @seen dcoutts
18:30:44 <lambdabot> Last time I saw dcoutts was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #bfpg, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc,
18:30:44 <lambdabot> #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-iphone, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #
18:30:44 <lambdabot> haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #interplanetarylazers, #jhc, #jtiger, #kata, #learnanycomputerlanguage, #macosx, #macosxdev, #
18:30:44 <lambdabot> novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #uscs2009, #xmonad and #yi 6d 16h 35m 10s ago, and .
18:30:44 <aavogt> @bot
18:30:44 <lunabot>  :o
18:30:45 <lambdabot> :)
18:34:08 <necrobious> in IO, when calling Data.Binary.decode on a ByteString, that does not contain valid type data, decode is calling fail. What is the best way to recover from Data.Binary's decode failure? I've tried using Control.Exception.catch, but my exception function never seems to execute using,  ErrorCall, IOException, and IOError.
18:34:51 <Axman6> try SomeException
18:35:00 <Axman6> should match any exception
18:35:02 <Axman6> i think
18:37:18 <defun_> how do i contribute to ghc (code wise). And more importantly, are there any kinds of contributions that may be beyond the scope of the project? (i.e. an extension for fist class modules?)
18:37:39 <Twey> defun_: #ghc
18:37:46 <defun_> ah thanks.
18:42:59 <orbitz> is supercompilation part of GHC or just a theortical addon?
18:43:22 <copumpkin> pejo's working on adding it in right now
18:43:37 <orbitz> ETA?
18:43:43 <copumpkin> who knows
18:43:52 <copumpkin> you could try asking him
18:44:06 <orbitz> hrm
18:44:15 <orbitz> i'm intrigued by your ideas and wish to subscribe to your newsletter
18:44:56 <dolio> ndm was doing a supercompiler with YHC core, but that's stalled until someone decides to pay him to do it. :)
18:45:47 <necrobious> Axman6: thanks for the suggestion. Unfortunately SomeException does not appear to work either, however it looks like what is happening (after switching to SomeException) is that the the socket handle I'm working with is closed. that should not be! At least i know my problem is else where... thanks again :)
18:46:13 <Axman6> :)
18:46:28 <copumpkin> dammit, I can't use @ for type functions
18:47:37 <chessguy> @seen conal
18:47:37 <lambdabot> I saw conal leaving #haskell, #ghc, #haskell-in-depth, #haskell-iphone and #haskell-blah 7d 5h 25m 44s ago, and .
18:52:08 <defun_> Am I the only one who thinks that implementing Erlang-like distributability and message passing in haskell is a good idea? If so, then why do devs think its a bad idea?
18:52:36 <defun_> *or why do devs think it's low priority?
18:53:29 <Twey> http://hackage.haskell.org/package/erlang ?
18:53:39 <orbitz> is FRP kind of a generic functional event loop idea?
18:54:44 <Twey> orbitz: Er… well, same purpose
18:54:54 <Twey> It's quite different to an actual event loop, though
18:55:08 <orbitz> any good resources that a newbie can read?
18:55:32 <Twey> defun_: AIUI, Haskell folks are mostly of the opinion that that much implicitness is a bad thing
18:55:59 <defun_> Twey: implicitness?
18:56:07 <defun_> what is being implied?
18:56:36 <Twey> orbitz: http://www.haskell.org/yampa/ maybe?
18:56:40 <chessguy> @type let r f g a (Node x s) = f x (r' f g a s); r' f g a [] = a; r' f g a (s:ss) = g (r f g a s) (r' f g a ss) in r
18:56:41 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t2 -> t1 -> t1) -> t1 -> Tree t -> t2
18:56:59 <chessguy> @type let r f g a (Node x s) = f x (r' f g a s); r' f g a [] = a; r' f g a (s:ss) = g (r f g a s) (r' f g a ss) in r'
18:57:01 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t2 -> t1 -> t1) -> t1 -> Forest t -> t1
18:57:04 <Twey> defun_: The message queue, for a start, as well as the (potential) remoteness of a node
18:57:14 <kmc> @hoogle [a] -> (Int, a) -> [a]
18:57:14 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
18:57:14 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
18:57:14 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
18:57:18 <copumpkin> I like how my type-level stuff is going :D
18:57:24 <kmc> @hoogle [a] -> Int -> a -> [a]
18:57:24 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
18:57:24 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
18:57:24 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
18:57:27 <copumpkin> I have all sorts of awesome type-level combinators
18:57:53 <kmc> @src Array
18:57:53 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:57:55 <Twey> orbitz: Also http://www.haskell.org/haskellwiki/Reactive
18:58:04 <orbitz> Twey: thanks
18:58:18 <defun_> I see. What about a kind of local concurrency, so that haskell can support individual "processes".
18:58:34 <defun_> This would also lend itself to hot code swapping, I think.
18:58:51 <defun_> Which can be useful in situations where the system must not be taken off line
18:59:05 <Twey> defun_: We already have that
18:59:11 <defun_> ?
18:59:16 <defun_> howcome I never heard of it?
18:59:17 <Twey> See Control.Concurrent(.STM)
18:59:35 <Twey> It's the default mode for forkIO threads
18:59:56 <defun_> Is there documentation for it somewhere (hackage?)
19:00:10 <aavogt> @docs Control.Concurrent
19:00:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
19:00:21 <defun_> @docs Data.List
19:00:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
19:00:30 <defun_> that's handy :) thanks.
19:00:32 <Axman6> defun_: haskell's concurrency support is beautiful
19:00:33 <jfoutz> what's the thing that replaced HConf? that does real hot code swapping.
19:00:37 <Twey> There's even a tutorial of sorts on Wikibooks
19:00:48 <orbitz> Twey: by "already have that" do you mean local concurrency, or the hto code swapping
19:00:55 <defun_> Most things in haskell are beautiful.
19:01:07 <Twey> orbitz: The concurrency
19:01:08 <defun_> I think he means local
19:01:17 <defun_> which reminds me.
19:01:27 <Twey> I don't know of the code-swapping, although jfoutz seems to be saying that it exists
19:01:31 <defun_> wouldn't the devs agree that hot code swapping owuld be nice to have.
19:01:33 <Twey> xmonad has a nice method for it
19:01:42 <jfoutz> and yi
19:01:46 <Twey> Yeah
19:01:58 <orbitz> i thought yi recompiled itself everytime?
19:02:05 <jfoutz> it used to be HConf, but they just got something new...
19:02:10 <aavogt> those apps don't really hot-swap running code...
19:02:10 <Twey> It does, on the fly
19:02:16 <jfoutz> well... sorta yeah, but as you are running. :)
19:02:22 <aavogt> jfoutz: dyre
19:02:24 <aavogt> ?
19:02:35 <jfoutz> i bet that's it.
19:02:46 <Twey> Oh cool.
19:03:00 <defun_> doesn't xmonad recompile itself?
19:03:04 <jfoutz> yeah, that's it.
19:03:17 <Twey> defun_: Yes.
19:03:26 <aavogt> defun_: it gets ghc to recompile itself
19:03:31 <defun_> how is that hot code swapping?
19:03:46 <aavogt> the application state is serialized
19:03:52 <defun_> that's recompilation, i think. unless i got hot code swapping wrong in my head.
19:04:17 <Twey> What do you think ‘hot code swapping’ is?
19:04:21 <jfoutz> defun_: that's fair.
19:04:35 <Twey> It's always going to involve recompilation in a compiled language.
19:04:41 <orbitz> does it serialize the state then restart?
19:04:42 <defun_> Twey: I see.
19:04:56 <Twey> Unless you mean writing binary data directly, but that's not very human-friendly.
19:05:13 <defun_> Twey: then what's the difference between dynamic loading and hot code swapping?
19:05:15 <Twey> And probably illegal nowadays, what with write-protected data sections and stuff.
19:05:24 <Twey> Er, execute sections
19:05:40 <orbitz> in Erlang, you laod the new module, and the next call to a function in that module switches to the new code base
19:05:42 <Twey> defun_: One's even vaguer than the other?  ;)
19:05:57 <defun_> I see. ok.
19:06:10 <copumpkin> I think I inadvertently reinvented datatypes à la carte
19:06:23 <Twey> orbitz: That's horrifically impure
19:06:39 <orbitz> Twey: indeed, but I think it is what defun_ thinks of as hot swapping
19:06:39 <Twey> It essentially breaks referential transparency
19:06:44 <Twey> Ah
19:06:47 <defun_> So in summary, hot code swapping a fancy name for recompilation.
19:06:58 <copumpkin> without stopping the program
19:07:00 * jfoutz ponders
19:07:23 <Twey> defun_: I think of it as any way to modify the program ‘on the fly’, without noticeably shutting everything down.
19:07:35 <orbitz> so how does xmonad do it?
19:07:52 <defun_> copumpkin: but you /are/ shutting down everything? (just trying to clarify for myself)
19:08:01 <copumpkin> nope?
19:08:13 <kmc> in haskell we have lots of ways to manipulate functions as data without actually recompiling anything
19:08:14 <kmc> thoug
19:08:16 <Twey> Serialising the state and passing it to the new code so it picks up where the old one left off transparently (which is what xmonad does) is one way of doing it
19:08:19 <kmc> though it is nice additionally
19:08:30 <Twey> defun_: Depends.
19:08:33 <orbitz> Twey: how does the 'passing' happen?
19:08:45 <defun_> Twey: great
19:08:48 <Twey> defun_: The process shuts down, but the state is preserved, so it's not exactly ‘shutting down everything’.
19:08:50 <kmc> on the command line
19:09:01 <Twey> Yeah, I think it's just serialised and piped through
19:09:07 <Axman6> > let ilog a = if a > 0 then 1+ilog (a `div` 2) else 0 in ilog 8
19:09:08 <lambdabot>   4
19:09:10 <defun_> so, it's like passing a baton during a race?
19:09:11 <Axman6> > let ilog a = if a > 0 then 1+ilog (a `div` 2) else 0 in ilog 9
19:09:12 <lambdabot>   4
19:09:17 <Twey> defun_: Yeah.  That's a good analogy.
19:09:19 <Axman6> > let ilog a = if a > 0 then 1+ilog (a `div` 2) else 0 in ilog 2^32
19:09:20 <lambdabot>   4294967296
19:09:28 <Axman6> hmm
19:09:29 <orbitz> so for exampl,e any sockets that were open, would those get lost?
19:09:31 <defun_> oh, that seems quite intutive.
19:09:39 <defun_> *intuitive
19:09:41 <Axman6> > let ilog a = if a > 1 then 1+ilog (a `div` 2) else 0 in ilog 2^32
19:09:42 <Twey> orbitz: I imagine they wouldn't.
19:09:43 <lambdabot>   1
19:09:58 <orbitz> i think this is how irssi does /upgrade's then
19:10:00 <Twey> I mean, conceptually at least, they needn't be.
19:10:13 <Twey> I don't know if the existing code actually handles that sort of thing
19:10:23 <orbitz> serialize the state, then execute and all yoru fd's are still open and all that i think
19:10:58 <jfoutz> i don't think it kills the underlying runtime. only one section, that's contained in a monad.
19:11:01 <Axman6> > let ilog a = if a > 1 then 1+ilog (a `div` 2) else 0 in ilog (2^32)
19:11:02 <lambdabot>   32
19:11:09 <Axman6> > let ilog a = if a > 1 then 1+ilog (a `div` 2) else 0 in ilog (2^32+17384982)
19:11:10 <lambdabot>   32
19:11:10 <Twey> Anyway, I'm going to sleep.  'night.
19:12:26 <copumpkin> it'd be nice if I could have polymorphic output for type functions
19:12:29 <porges> I wish we still had monad comprehensions
19:19:56 <roconnor> Question: should modules reexport the types that occur in the functions that are exported?
19:21:14 <copumpkin> any way to coax out a polymorphic return value from a type function?
19:26:16 <chessguy> ok, i'm clearly doing something obvioiusly wrong here, and i'm too brain-dead to see it
19:26:19 <chessguy> any help? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8951#a8951
19:28:33 <roconnor> that seems wrong in many respects
19:28:42 <heatsink> chessguy: I don't know why you're getting 2, but the (fold f root) looks wrong.  Each node's value should only contribute to the fold once, right?
19:29:12 <chessguy> hm, yeah
19:29:17 <chessguy> maybe i'm over-simplifying
19:29:21 <roconnor> I think not sure that he got 1 + 1, ie the value of the root node added to itself once for every child
19:29:52 <roconnor> chessguy: throw away that code, it is all wrong.
19:30:05 <roconnor> one sec
19:30:27 <chessguy> haha, i'm not surprised
19:30:35 <roconnor> chessguy: instead implement a Foldable instance
19:30:43 <chessguy> i should have just gone to bed an hour ago :)
19:31:13 <chessguy> i'd like to do this without typeclasses
19:31:45 <chessguy> because then i'm going to 'translate' it up an absraction
19:32:11 <heatsink> chessguy: if you want to map something over the subtrees, the result of mapping over a subtree should be an (a -> a) that takes a partial result and adds the subtree's contribution to it.
19:32:41 <BMeph> chessguy: I'd like to get $10M without working for it, but I'm no closer to being declared "Too Big to Fail" by the US Gov. than ever... ;p
19:32:52 <roconnor> you effectively need to use a state transformer and traverse the structure.
19:32:55 <copumpkin> dammit, I want me some polymorphic (-output) type functions dammit :P
19:33:29 <roconnor> copumpkin: can't you wrap up a polymorphic value as a GADT type and output that?
19:33:38 <chessguy> BMeph, don't worry, once i get this library written, i'll solve chess and get rich, and then bail you out
19:33:57 <copumpkin> roconnor: I guess, but that's so indirect :(
19:34:02 * copumpkin hrrmpfs
19:34:58 <roconnor> chessguy: implement Foldable, and then expend the definitions of foldr until you expand away all the Foldable class stuff.
19:35:19 <chessguy> roconnor, i looked at the Foldable instance at http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Tree.html#Forest
19:35:23 <roconnor> chessguy: this is how we write haskell code, via program transformations.
19:36:12 <roconnor> great!
19:36:15 <roconnor> now foldr f z t = appEndo (foldMap (Endo . f) t) z
19:36:32 <roconnor> so substitute that definition of foldMap, and expand.
19:36:45 <chessguy> uh....what?
19:36:51 <heatsink> foldMap!  Hey, that's clever.
19:37:06 * heatsink just figured out what the type meant.
19:37:11 <roconnor> foldMap f (Node x ts) = f x `mappend` foldMap (foldMap f) ts
19:37:18 <roconnor> foldr f z t = appEndo (foldMap (Endo . f) t) z
19:37:19 <dolio> copumpkin: What do you mean?
19:37:20 <roconnor> so
19:37:39 <copumpkin> dolio: type instance F A = a
19:37:43 <defun_> has anyone here used UHC (utrecht haskell compiler)? What's it about? Another toy implementation? or something more?
19:37:43 <copumpkin> or forall a. a
19:37:44 <copumpkin> or something
19:37:50 * BMeph is amazed at roconnor's "strip-ts" artistry... ;p
19:37:52 <roconnor> foldr f z t = appEndo ((\f (Node x ts) -> f x `mappend` foldMap (foldMap f) ts) (Endo . f) t) z
19:38:01 <dolio> That doesn't work?
19:38:08 <dolio> With RankNTypes and such?
19:38:22 <copumpkin> dolio: nope :(
19:38:34 <copumpkin> I have just about every extension in the world switched on
19:38:38 <copumpkin> including RankNTypes
19:38:49 <roconnor> hmm
19:39:02 <roconnor> I see the issue
19:39:12 <roconnor> reasoning about recursive functions is a little bit tricky :D
19:39:39 <roconnor> ah wait
19:39:49 <chessguy> roconnor, this isn't that big a deal, don't hurt yourself over it...
19:39:59 <roconnor> foldMap is defined in terms of foldr as well
19:40:05 <roconnor> foldMap f = foldr (mappend . f) mempty
19:40:16 <chessguy> right, they're defined in terms of each other
19:40:29 <chessguy> minimum complete instance is one or the other
19:40:40 <roconnor> foldr f z t = appEndo ((\f (Node x ts) -> f x `mappend` foldMap (foldr (mappend . f) mempty f) ts) (Endo . f) t) z
19:40:52 <roconnor> now we have made foldr recursive in itself
19:40:59 <roconnor> I think that other foldMap is the list instance.
19:41:16 <roconnor> or maybe I have it the other way round
19:41:19 <dolio> copumpkin: Huh, I'm not sure why that'd be disallowed.
19:41:29 <roconnor> anyhow, you can ... um ... do it this way.
19:41:48 <copumpkin> dolio: it seems a reasonable thing to want (I can see why polymorphic parameters could be a problem), but it doesn't work :/
19:42:16 <roconnor> @src mappend Endo
19:42:16 <lambdabot> Source not found. My mind is going. I can feel it.
19:42:21 <chessguy> roconnor, ok, um...thanks :)
19:42:39 <dolio> Well, (forall a. a) is supposed to be a first-class type with RankNTypes on, so I'd have expected it to just work.
19:43:06 <roconnor> foldr f z t = appEndo ((\f (Node x ts) -> f x `mappend` foldMap (foldMap f) ts) (Endo . f) t) z
19:43:08 <copumpkin> Algebra.hs:188:0:
19:43:08 <copumpkin>     Illegal polymorphic or qualified type: forall a. a
19:43:08 <copumpkin>     In the type synonym instance declaration for `Arg'
19:43:12 <dolio> And it doesn't seem like the sort of thing that would lead to unsoundness.
19:43:19 <copumpkin> exactly
19:43:20 <dolio> Yeah, i tried it out myself.
19:43:27 <roconnor> foldr f z t = appEndo ((\(Node x ts) -> (Endo .f) x `mappend` foldMap (foldMap (Endo. f)) ts) t) z
19:43:30 <copumpkin> maybe HEAD changed that
19:43:41 <copumpkin> I know type families are under pretty active development
19:43:57 <dolio> Yeah, it might be a fluke.
19:44:13 <copumpkin> pity ChilliX isn't around
19:44:26 <copumpkin> anyone have a compiled copy of HEAD lying around? :D
19:44:56 <copumpkin> oh I think I do actually :)
19:45:01 * BMeph is not giving HEAD to anybody! >:(
19:45:09 <roconnor> foldr f z (Node x ts) = appEndo ((Endo .f) x `mappend` foldMap (foldMap (Endo. f)) ts) z
19:45:12 <dolio> Well, even if it isn't any different in HEAD, that could just mean they didn't notice it.
19:45:27 <copumpkin> yeah
19:45:42 <heatsink> Does foldl have the expected bounded stack size when it's defined as a foldr with the dual of Endo?
19:46:02 <heatsink> Oh wait, it's not foldl'.  Nm.
19:46:06 <roconnor> foldr f z (Node x ts) = ((appEndo (Endo .f) x) . (appEndo foldMap (foldMap (Endo. f)) ts))) z
19:46:25 <roconnor> foldr f z (Node x ts) = (f x) . (appEndo foldMap (foldMap (Endo. f)) ts))) z
19:48:33 <roconnor> foldr f z (Node x ts) = (f x) . (appEndo (foldMap (foldMap (Endo. f)) ts))) z
19:48:42 <kmc> the lack of abstraction over record field names is bugging me
19:48:46 <kmc> is there a good solution for that
19:49:18 <dolio> You can get on the lens bandwagon.
19:49:22 <copumpkin> you can write a typeclass for every duplicated field name :P
19:49:47 <dolio> But it doesn't have any compiler automation, obviously.
19:50:02 <kmc> do you have a link to the lens stuff
19:50:12 <roconnor> foldr f z (Node x ts) = (f x) . (appEndo (foldMap (foldr (mappend . Endo . f) mempty) ts))) z
19:50:33 <defun_> when ghc creates/forks/whatever threads, are they operating system threads?
19:50:40 <kmc> hmm, functional references looks nice
19:50:44 <orbitz> AFAIK, yes
19:50:54 <orbitz> kmc: functional references?
19:51:01 <kmc> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
19:51:05 <dolio> kmc: No, you could google for them. They're also known as "functional references."
19:51:11 <kmc> oh okay then
19:51:47 <dolio> The idea is that a field name corresponds to 'whole -> (part, part -> whole)' or something isomorphic.
19:52:18 <dolio> Which form a category, so you can compose them together to get pointers to parts of parts of whole and so on.
19:53:07 <dolio> And then you write a function like "get :: Lens whole part -> whole -> part" and "put :: Lens whole part -> whole -> part -> whole".
19:53:11 * copumpkin could give in and give hs Nil a type parameter
19:53:16 <copumpkin> but that feels dirty
19:53:21 <heatsink> There are some library definitions in the data-accessor module you might find useful for record access.
19:54:21 <roconnor> foldr f z (Node x ts) = (f x) . (appEndo (foldr (mappend . (foldr (mappend . Endo . f) mempty)) mempty  ts))) z
19:54:49 <roconnor> foldr f z (Node x ts) = (f x) . (foldr ((.) . (foldr ((.) .  f) id)) id ts)) z
19:54:57 <BMeph> @go Boomerang resourceful
19:54:58 <lambdabot> http://www.cis.upenn.edu/~bcpierce/papers/boomerang-tr.pdf
19:54:58 <lambdabot> Title: Boomerang: Resourceful Lenses for String Data
19:55:06 <roconnor> @unpl ((f x) . (foldr ((.) . (foldr ((.) .  f) id)) id ts))) z
19:55:06 <lambdabot> Unbalanced parentheses
19:55:15 <roconnor> crap
19:55:20 <BMeph> kmc: ^^ (a link to lens stuff) ;)
19:55:25 <kmc> thanks
19:55:37 <dolio> Yeah, boomerang is a whole language based on the idea.
19:55:52 <kmc> @pl \x -> (a x >>= b)
19:55:52 <lambdabot> (b =<<) . a
19:55:53 <dolio> By everyone's favorite type system guru.
19:55:59 <roconnor> @unpl ((f x) . (foldr ((.) . (foldr ((.) .  f) id)) id ts)) z
19:55:59 <lambdabot> (f x (foldr (\ o b c -> foldr (\ r e g -> f r (e g)) (\ h -> h) o (b c)) (\ i -> i) ts z))
19:56:11 <copumpkin> :t \x -> (a x >>= b)
19:56:13 <lambdabot>     Couldn't match expected type `t -> m a'
19:56:13 <lambdabot>            against inferred type `Expr'
19:56:13 <lambdabot>     In the first argument of `(>>=)', namely `a x'
19:56:16 <roconnor> @. pl unpl ((f x) . (foldr ((.) . (foldr ((.) .  f) id)) id ts)) z
19:56:16 <lambdabot> f x (foldr ((.) . foldr ((.) . f) id) id ts z)
19:56:32 <copumpkin> :t \a b x -> (a x >>= b)
19:56:33 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
19:56:45 <copumpkin> kmc: >=>
19:56:55 <kmc> :t >=>
19:56:56 <lambdabot> parse error on input `>=>'
19:56:57 <BMeph> dolio: Surely, Wadler is everyone's favorite TS guru. Pierce is everyone's TS scholar. ;)
19:56:59 <kmc> :t (>=>)
19:57:00 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:57:03 <copumpkin> :t (\a b x -> (a x >>= b)) `asTypeOf` (>=>)
19:57:04 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => (a1 -> m a) -> (a -> m b) -> a1 -> m b
19:57:06 <dolio> :)
19:57:06 <roconnor> chessguy: and (foldr f z (Node x ts) = (f x) . (foldr ((.) . (foldr ((.) .  f) id)) id ts)) z) might even work :D
19:57:21 <dolio> BMeph: I was expecting someone to throw Oleg at me.
19:57:26 <roconnor> @pl ((.) . f)
19:57:26 <lambdabot> (.) . f
19:57:29 <chessguy> um...ew?
19:57:30 <roconnor> @unpl ((.) . f)
19:57:31 <lambdabot> (\ g b c -> f g (b c))
19:57:39 <copumpkin> chessguy: ?
19:57:49 <chessguy> copumpkin, not you
19:57:54 <copumpkin> :)
19:59:13 <BMeph> dolio: TS wizard, maybe? After all, he tests out Haskell stuff by thinking up implementations in Scheme...scary stuff, Man! ;)
19:59:16 <copumpkin> @seen ChilliX
19:59:16 <lambdabot> Last time I saw ChilliX was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #bfpg, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc,
19:59:16 <lambdabot> #haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-iphone, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #
19:59:16 <lambdabot> haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #interplanetarylazers, #jhc, #jtiger, #kata, #learnanycomputerlanguage, #macosx, #macosxdev, #
19:59:16 <lambdabot> novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #uscs2009, #xmonad and #yi 6d 18h 3m 43s ago, and .
19:59:24 <copumpkin> ugh
19:59:28 <copumpkin> preflex: seen ChilliX
19:59:28 <preflex>  ChilliX was last seen on #ghc 5 days, 22 hours, 6 minutes and 3 seconds ago, saying: gotta head of now - bbl
20:00:00 <Axman6> jesus... ChilliX is just a little addicted to IRC...
20:00:11 <Axman6> @seen lambdabot
20:00:11 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
20:00:11 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-iphone, #haskell-in-depth, #haskell-freebsd, #
20:00:11 <lambdabot> interplanetarylazers, #learnanycomputerlanguage, #uscs2009, #macosx, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #bfpg, #
20:00:11 <lambdabot> novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
20:00:32 <BMeph> Axman6: Well, that, or he's just an l-bot Stalker. :)
20:00:39 <Axman6> heh
20:00:49 <roconnor> Occurs check: cannot construct the infinite type: b = a -> b
20:00:51 <roconnor> :(
20:01:00 * roconnor fails at being Dijkstra
20:01:10 <copumpkin> Axman6: that's lambdabot saying lambdabot left those channels, not ChilliX
20:01:36 <Adamant> I gotta know
20:01:44 <Adamant> interplanetarylazers?
20:01:45 <Axman6> oh, i see, didn't read the beginning :)
20:02:31 <Adamant> guys bouncing stuff off the moon mirror the astronauts left, or "Alan Parsons Project"-level Dr. Evil designed death rays?
20:02:32 <chessguy> Topic for #interplanetarylazers is: melons
20:02:35 <chessguy> naturally
20:02:39 <Adamant> lol
20:03:08 * BMeph votes for the pinky-nibbling "Hmm"-ster
20:03:44 <roconnor> @type \f -> (.) . f
20:03:45 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
20:04:00 <copumpkin> @type (.) . (.)
20:04:01 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:05:22 <chessguy> 'night ya'all. time for bed
20:07:50 <roconnor> ah, giving it a type worked
20:07:52 <roconnor> strange
20:07:55 <roconnor> crap!
20:08:00 <roconnor> I just had it too
20:08:16 <copumpkin> ?
20:09:02 <roconnor> Main> fold (+) 0 (Node 1 [Node 2 [], Node 3 []])
20:09:03 <roconnor> 6
20:09:05 <roconnor> @paste
20:09:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:10:45 <roconnor> @tell chessguy, it works once you give it a type and don't conflict with the prelude name for foldr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8954#a8954
20:10:45 <lambdabot> Consider it noted.
20:11:24 <roconnor> I wonder if there is a nicer way to write fold ((.) .  f) id
20:12:06 <roconnor> and/or a way to write this that doesn't use polymorphic recursion.
20:13:13 <roconnor> @unpl ((.) . f)
20:13:14 <lambdabot> (\ g b c -> f g (b c))
20:13:45 <roconnor> = (\g b -> f g . b)
20:14:00 <roconnor> = (\g -> (f g .))
20:15:21 <orbitz> Simon Marlow's paper on High performance webserver is pretty fascinating
20:15:45 <copumpkin> orbitz: still debating between haskell and ocaml?
20:15:53 <copumpkin> *deciding
20:16:21 <orbitz> copumpkin: I think i want to implement a concurrent http client to laod test our application at work in haskell as a case-study
20:16:30 <copumpkin> :)
20:16:47 <arw_> orbitz: link or title?
20:16:58 <orbitz> http://www.haskell.org/~simonmar/papers/web-server.ps.gz
20:17:02 <arw_> thx.
20:17:14 <orbitz> copumpkin: written any thing like that in haskell?
20:17:29 <copumpkin> not me, I don't do much web stuff :)
20:18:27 <orbitz> any multiplexing stuff?
20:19:03 <copumpkin> not yet
20:20:49 <orbitz> copumpkin: looks like i might be abel to multiple with STM
20:20:53 <orbitz> http://sequence.complete.org/node/257
20:21:09 <ray> ocaml, because haskell has terrible hash table performance
20:21:22 <copumpkin> lol
20:21:31 <copumpkin> ZOMG
20:21:45 <copumpkin> how do you do, like, anything in haskell, without hashtables?
20:21:59 <orbitz> I am having issues gettign GHC to compile on work machines, and ocaml compiels fine so that is one reason to stick with ocaml for right now
20:22:08 <ray> you write a wrapper to call another program, duh
20:22:46 <orbitz> hah, is htis a common haskell complaint? no hashtables == AHHHHH?
20:22:56 <SamB_XP> ray: heh
20:23:08 <Nafai> orbitz: if you are Jon Harrop, yes
20:23:21 <SamB_XP> orbitz: I dunno ... not too often in here!
20:23:33 <ray> oh, i thought this was #haskell-blah
20:23:40 <ray> since people were talking about haskell
20:25:03 <pushkar> ne1 here know ms access & VB??
20:25:22 <SamB_XP> what was that paper again?
20:25:29 <SamB_XP> about how VB is the new Haskell or whatever?
20:25:58 <copumpkin> orbitz: yeah, there's a resident troll in the functional communities who loves to pick on haskell's hashtables :P
20:25:58 <heatsink> There's a ##vb.net
20:26:38 <dibblego> orbitz, you have been harroped
20:28:17 <orbitz> ohh good ol jan
20:28:18 <orbitz> jon
20:28:24 <orbitz> F# 4 life
20:30:15 <dancor> i thought he and simonmar were bffs
20:31:02 <dancor> i bet they have constructive convos about hash tables in haskell.  not on irc
20:31:58 <orbitz> time for bed, thanks for the help
20:32:38 * mmorrow throws (foldl' IntMap.union mempty) at hashtables
20:33:15 <SamB_XP> dancor: bffs?
20:33:22 <orbitz> best friencd forever
20:33:32 <SamB_XP> best friend forevers?
20:33:34 <orbitz> SamB_XP: like you an dme are bffs
20:34:05 <SamB_XP> I think I tried to read it as "best friends for <something-that-starts-with-S>"
20:34:18 <SamB_XP> but couldn't figure out what the last word should be ;-)
20:34:23 <dancor> !
20:35:08 <SamB_XP> maybe this is why we capitalize acronyms like GUNDAM
20:35:39 <heatsink> That's an acronym?
20:35:48 <SamB_XP> heatsink: in the Seed storyline, yes
20:36:07 <SamB_XP> look on the bootscreen of a gundam in Seed and you'll see what it stands for there
20:37:01 <heatsink> huh. kay.
20:37:11 <mmorrow> SamB_XP: crack is bad
20:37:20 <SamB_XP> mmorrow: why do you say that?
20:37:27 <mmorrow> SamB_XP: just kidding!
20:37:43 <SamB_XP> are you equating Gundam Seed with crap?
20:37:49 <mmorrow> SamB_XP: i meant to imply that you must be on crack.
20:38:00 <mmorrow> :)
20:38:09 <SamB_XP> I never really got into Season 2 for some reason ...
20:38:26 <SamB_XP> possibly the subbers just weren't very good starting out the season?
20:43:23 <log0ut> Er, what is the syntax for multiple pattern matches in a lambda?
20:43:29 <defun_> when xmonad reloads/recompiles itself, it is done by the runtime? meaning the runtime swaps two binaries while perserving/passing state between them?
20:44:13 <copumpkin> log0ut: there isn't one
20:44:23 <monochrom> \x -> case x of ...
20:44:48 <log0ut> Ahh.  Thanks.
20:45:10 <aavogt> defun_: the new version is called with the serialized state of the old version
20:45:39 <aavogt> I'm not sure what you mean by involving the runtime... (the ghc RTS?)
20:45:55 <defun_> yes I know that, but is this done by the ghc runtime (the calling), or is it done by the operating system, some script?
20:46:16 <jorgegzz> quit
20:46:58 <defun_> better, yet is there some documentation on this recompilation of xmonad?
20:48:59 <aavogt> defun_: there's not very much source code you have to look at
20:49:33 <defun_> aavogt: what do you mean?
20:50:23 <copumpkin> xmonad is comparatively tiny
20:50:54 <defun_> ah. all the better. I truly want to understand this recompilation trick.
20:50:55 <wdonnelly> it's actually rather hard to find the recompile-specific code in xmonad
20:51:03 <defun_> oh.
20:51:20 <defun_> don't worry I'll find it later then. :)
20:51:30 <wdonnelly> it's in there, but there's not as much clean separation as one might hope
20:51:34 <aavogt> wdonnelly: probably because there isn't much of it ;)
20:52:44 <aavogt> wdonnelly: you wrote dyre?
20:53:22 <wdonnelly> yes
21:01:28 <wdonnelly> it seems I was possibly too quick to judge xmonad last time I examined the source
21:03:10 <sjanssen> wdonnelly: XMonad.Core.recompile and XMonad.Main.main IIRC
21:03:19 <pjb3> So if I define a function like this in ghci
21:03:21 <pjb3> let forever = forever
21:03:23 <pjb3> and then call it
21:03:25 <pjb3> with just
21:03:27 <pjb3> forever
21:03:32 <wdonnelly> also XMonad.Operations.restart
21:03:34 <pjb3> ghci just sits there
21:03:48 <wdonnelly> and I *still* can't find where the state gets restored at
21:03:52 <pjb3> which makes sense because I think I've defined a function that calls itself recursively forever
21:04:04 <pjb3> so why doesn't ghci use any CPU?
21:04:06 <sjanssen> wdonnelly: state is restored in XMonad.Main.main
21:04:22 <sjanssen> wdonnelly: you're right, it isn't factored out
21:04:34 <wdonnelly> that explains it. my eyes just slipped over all the X-related stuff and missed the state loading
21:05:11 <monochrom> The impossible has happend. ghci has solved the halting problem.
21:06:32 <sjanssen> defun_: if you want a high-level description of xmonad's dynamic recompilation:
21:07:02 <sjanssen> xmonad calls the GHC executable via the operating system's exec() function on xmonad.hs
21:07:23 <sjanssen> well, fork then exec -- the xmonad process isn't replaced at this point
21:07:47 <sjanssen> xmonad then execs the binary produced by GHC (which, in Unix, replaces the existing process)
21:08:08 <sjanssen> state is preserved by passing an command line argument in the exec call
21:08:40 <defun_> thanks.
21:08:46 <monochrom> reincarnation! second life!
21:10:03 <wdonnelly> one important thing to note if you want your restarting code to work on windows or OSX
21:10:21 <wdonnelly> is that neither of them will let you do a straightforward executeFile
21:10:42 <sjanssen> wdonnelly: this should all work on OS X AFAIK
21:10:53 <wdonnelly> windows has no analogue, AFAIK, and for some reason OSX just doesn't like it when executeFile is called without forking
21:12:03 <sjanssen> that might be the GHC RTS's limitation?  I think we have xmonad users on OS X using this
21:12:19 <mmorrow> wdonnelly: what about using the execve syscall directly?
21:12:22 <mmorrow> (in osx)
21:12:49 <mmorrow> wdonnelly: as in, is this a bug in the haskell wrapper on osx?
21:13:12 <wdonnelly> it doesn't work. not sure why. see yi bug report #286
21:13:16 <wdonnelly> (http://code.google.com/p/yi-editor/issues/detail?id=286)
21:13:42 <wdonnelly> I don't know about using the syscall directly, but I can't imagine what the Haskell wrapper could do to break that
21:13:56 <wdonnelly> so I would assume the issue would be at a lower level
21:14:13 <wdonnelly> I have no OSX system to test, so it's not an issue I can personally explore
21:14:29 <arw_> not quite sure, i have written c code on osx that uses execve without problems.
21:14:48 <mmorrow> i wonder that the haskell code's doing
21:14:53 <arw_> with some small deviations, osx behave like any unix there.
21:15:03 <mmorrow> (or the C code's doing, if the haskell's just a wrapper)
21:15:44 <mmorrow> preflex: zdec _executablezmpathzm0zi0_SystemziEnvironmentziExecutableziMacOSX_CFData_closure_tbl
21:15:45 <preflex>  _executable-path-0.0_System.Environment.Executable.MacOSX_CFData_closure_tbl
21:15:52 <sjanssen> executeFile (dir ++ "/xmonad-"++arch++"-"++os) False args Nothing -- is how xmonad calls it and we've had no bug reports
21:16:06 <mmorrow> what is System.Environment.Executable.MaxOSX ?
21:16:33 <sjanssen> what is executable-path?
21:16:36 <mmorrow> ah, looks like
21:16:41 <mmorrow> yeah, what is that
21:16:45 <wdonnelly> it gives the path to the current executable
21:16:50 <wdonnelly> that isn't the issue though
21:17:01 <wdonnelly> because the old HConf library had workaround code for the issue too
21:17:08 <wdonnelly> and it didn't use executable-path
21:17:08 <mmorrow> is System.Environment.Executable.MaxOSX from that package?
21:17:22 <sjanssen> mmorrow: probably
21:17:45 <sjanssen> mmorrow: yeah, it seems so
21:18:44 <wdonnelly> looking at the source to the unix-2.3.2.0 package
21:18:54 <wdonnelly> it doesn't seem to do anything fancy on OS X
21:19:33 <dancor> is (const res <$> parseSomething) theoretically slower than (parseSomething >> return res)
21:20:05 <mmorrow> foreign import ccall unsafe "execve" :: ...  -- might be a simple solution
21:20:39 <wdonnelly> but that's exactly what appears in the System.Posix.Process source code
21:20:59 <mmorrow> who's generating this error msg?
21:21:04 <mmorrow> "executeFile: failed (Operation not
21:21:04 <mmorrow> supported)"
21:21:06 <wdonnelly> lines 309 and 310, to be precise
21:21:12 <dancor> i ask because i've seen parsing-related things use (Maybe (a -> a)) instead of (a -> a), the optimization being that specially treating Nothing as id is faster than Just id
21:21:15 <sjanssen> "executeFile: failed (Operation not
21:21:15 <sjanssen> supported)
21:21:23 <sjanssen> that's pretty clearly a Haskell error
21:21:37 <wdonnelly> really?
21:21:53 <roconnor> foldr (\a b- > f a . b) id [] z = z
21:22:16 <sjanssen> wdonnelly: the OS wouldn't use the name 'executeFile'
21:22:19 <wdonnelly> I would assume it to come from the calls to 'throwErrnoPathIfMinus1_ calls in the 'executeFile' wrapper function in the Process module
21:22:31 <wdonnelly> where it says "throwErrnoPathIfMinus1_ "executeFile" path (c_execvp s arr)
21:22:42 <wdonnelly> so yes, the name comes from Haskell
21:22:48 <wdonnelly> but the error comes from OS X, I believe
21:22:56 <roconnor> foldr (\a b- > f a . b) id (c:d) z = (f c . (foldr (\a b -> f a . b) id) d) z
21:22:59 <SamB_XP> I guess it depends what you mean by "come from" ;-)
21:23:05 <mmorrow> looks like that's getting triggered by throwErrnoPathIfMinus1_ i think
21:23:34 <mmorrow> so i i take it exec<whichever it's using> is failing with errno=-1 ?
21:23:49 <SamB_XP> mmorrow: exevp, it would seem!
21:23:58 <roconnor> what are the foldr laws?
21:24:25 <sjanssen> wdonnelly: what sort of args were you passing to executeFile?
21:24:32 <mmorrow> SamB_XP: it using one of execvp/execv/execve depending on the function args
21:24:36 <mmorrow> *it's
21:24:40 <SamB_XP> mmorrow: ah
21:24:56 <monochrom> The foldr laws are, roughly: foldr is natural, foldr is catamorphism.
21:25:13 <mmorrow> http://darcs.haskell.org/libraries/unix/System/Posix/Process.hsc
21:25:22 <roconnor> @free foldr
21:25:23 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
21:25:30 <SamB_XP> monochrom: could you explain them?
21:25:46 <monochrom> I forgot enough details.
21:25:58 <SamB_XP> ITYM "too many"
21:26:11 <mmorrow> wdonnelly: ah, just saw your previous mention of throwErrnoPathIfMinus1_ ..
21:26:23 <monochrom> I am sleepy.
21:26:35 <wdonnelly> mmorrow: the function it eventually calls is 'execv'
21:26:59 <mmorrow> arw_: do all three of
21:27:00 <wdonnelly> because the environment is 'Nothing' and search is set to 'False'
21:27:02 <mmorrow> wdonnelly: ah, ok
21:27:11 <kmc> @free candy
21:27:12 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `candy'\n\n"
21:27:22 <mmorrow> arw_: does execv work on osx? (i'd assume so..)
21:27:41 <SamB_XP> kmc: you have to say what kind of candy you want
21:27:48 <kmc> @free delicious candy
21:27:48 <lambdabot> Extra stuff at end of line
21:27:58 <SamB_XP> that is, you need to give the type of candy
21:28:21 <monochrom> @help free
21:28:21 <lambdabot> free <ident>. Generate theorems for free
21:28:30 <monochrom> @free foldr
21:28:31 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
21:28:37 <aavogt> @free candy :: a -> b
21:28:37 <lambdabot> g . candy = candy . f
21:28:47 <mmorrow> maybe osx has some particular additional requirement for the args of execv that're non-standard or something
21:29:23 <SamB_XP> what path is he passing?
21:29:28 <roconnor> (forall x y. g (h x y) = k (f x) (g y)) => forall z. g (foldr h y z) = (foldr k (g y) (map f z))
21:29:29 <wdonnelly> mmorrow: not according to their man pages (http://developer.apple.com/mac/library/documentation/Darwin/Reference/ManPages/man3/exec.3.html)
21:29:40 <SamB_XP> and what args?
21:30:49 <glguy> Does anyone know enough Agda 2 to know how to do 1.4 on http://wiki.portal.chalmers.se/agda/agda.php?n=Main.TypesSummerSchool2007?action=view
21:31:23 <wdonnelly> the call to executeFile is "executeFile binaryPath False args Nothing", where 'binaryPath' is the absolute path to the binary, and '
21:31:25 <SamB_XP> glguy: not this late!
21:31:26 <roconnor> @pl \x y z -> (f x) (y z)
21:31:27 <lambdabot> (.) . f
21:31:41 <wdonnelly> and 'args' is the list of command-line arguments
21:31:58 <arw_> mmorrow: there are several variants of exec(v|e)
21:32:05 <dolio> glguy: Case analysis on x.
21:32:43 <glguy> dolio: I did the easy part, I think assoc zero y z = refl
21:32:46 <glguy> assoc (suc x) y z = {!!}
21:32:58 <dolio> glguy: You might need to prove a lemma that x == y -> suc x == suc y.
21:33:50 <arw_> mmorrow: they are just wrappers around the syscall which take different arguments, like in the case of execv the command line as an array of strings (v) and no environment (no e)
21:34:25 <dolio> Since that shed should be demanding something of type "suc (x + (y + z)) == suc ((x + y) + z)" if I'm not mistaken.
21:35:19 <copumpkin> dammit, I'm going to have to write my type-level union function on the value level too
21:35:20 <copumpkin> boo
21:35:29 <arw_> mmorrow: the -p variants additionally search the PATH environment variable like a shell would do. but thats the only sematic difference between those variants.
21:35:46 <glguy> dolio: you aren't mistaken :)
21:36:20 <copumpkin> glguy: yay agda
21:36:24 <SamB_XP> copumpkin: use a better language ;-P
21:36:25 <roconnor> SamB_XP, morrow: nice the free theorem for foldr implies foldr ((.) . f) y z = foldr (.) y (map f z)
21:36:32 <copumpkin> SamB_XP: yeah :(
21:36:41 <copumpkin> SamB_XP: I want to use agda but I enjoy it
21:36:44 <copumpkin> (haskell)
21:36:53 <dolio> Clearly you shold be using she.
21:37:10 <arw_> mmorrow: and yes, execv does work on osx.
21:37:21 <mmorrow> arw_, wdonnelly: ugh, and Foreign.C.Error maps multiple errno values to "UnsupportedOperation" (which appears to be what's happening here, given the error msg throwErr.. is printing)
21:37:30 <arw_> mmorrow: if you give me some minutes i'll boot the mac and check.
21:37:32 <SamB_XP> I think people would kind of have noticed if execv didn't work on OS X ;-P
21:37:46 <copumpkin> dolio: but I am!
21:37:54 <copumpkin> dolio: she still can't cross the type-value barrier though :(
21:38:06 <mmorrow> http://darcs.haskell.org/libraries/base/Foreign/C/Error.hs
21:38:24 <dolio> It doesn't let you write value-level functions and translate them to the type level?
21:38:45 <copumpkin> dolio: yeah, but I need things simultaneously on both levels
21:39:50 <dolio> Yes, but no?
21:40:15 <copumpkin> yes that it lets me write value-level functions and translate them to type level
21:40:22 <copumpkin> but no that it doesn't let me use both simultaneously
21:40:36 <copumpkin> as far as I've been able to see, at least
21:40:40 <arw_> mmorrow: hm, but it uses the systems strerror on errno somewhere. which should give the correct error message
21:40:49 <copumpkin> maybe I need to think more about it
21:41:06 <dolio> Do you need the type-level version in the type of the value-level version or something?
21:41:30 <copumpkin> nope
21:41:33 <dolio> Not that I'd see why that'd be a problem for it, necessarily.
21:42:28 <copumpkin> hmm, maybe you're right
21:42:59 <copumpkin> I'll play with applying she to that problem later :)
21:43:40 <arw_> mmorrow: line 501 ff. the error string is obtained correctly, but the handling of errType seems strange as you said.
21:44:42 <mmorrow> arw_: maybe the default printer for IOError (here "(IOError maybeHdl errType loc str (Just errno') maybeName)") doesn't print the part of the IOError that contains the string gotten from strerror
21:47:49 <roconnor> the free theorem also implies   ($ a) (foldr (.) id z) = foldr ($) (id $ a) (map id z)
21:48:01 <roconnor> aka (foldr (.) id z) a = foldr ($) a z
21:48:07 <roconnor> man, free theorems are great!
21:48:36 <arw_> mmorrow: you are right.
21:48:52 <arw_> mmorrow: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html#IOException
21:49:07 <mmorrow> argh
21:49:07 <roconnor> Thus foldr ((.) . f) id z a = foldr ($) a (map f z)
21:50:24 <mmorrow> i wonder what the actual errno val is that executeFile is triggering on osx with the particular args that yi gives
21:50:31 <roconnor> @free fold :: (a -> b -> b) -> b -> Node a -> b
21:50:31 <lambdabot> (forall x. g . h x = k (f x) . g) => g . fold h y = fold k (g y) . $map_Node f
21:51:02 <arw_> mmorrow: gdb it and break on the exec call.
21:51:11 <roconnor> @free foldr
21:51:12 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
21:51:20 <roconnor> same free theorem
21:51:25 <roconnor> I guess that was obvious
21:51:52 <SamB_XP> @free foldl
21:51:53 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
21:52:14 <copumpkin> > gcd 1 5
21:52:15 <lambdabot>   1
21:53:03 <SamB_XP> @free foldr1
21:53:04 <lambdabot> (forall x. f . g x = h (f x) . f) => f . foldr1 g = foldr1 h . $map f
21:53:41 <SamB_XP> @free foldl1
21:53:42 <lambdabot> (forall x. f . g x = h (f x) . f) => f . foldl1 g = foldl1 h . $map f
21:53:54 <SamB_XP> oh, same type I guess
21:54:27 <arw_> mmorrow: sorry, i've read the wrong function, the string in IOException/IOError is used.
21:55:21 <ozten> howdy, I'm not having any luck finding a way to run Happstack as a CGI instead of a stand-alone server. I have found happstack-fastcgi on hackage / blog posts.
21:56:33 <ozten> Should I try and port the fast-cgi code over, or can anyone point me in the right direction?
21:57:24 <roconnor> I'm pleased to know that "foldr (.) id z a = foldr ($) a z"  I thought I needed to transform a foldr into a foldl somewhere here.
21:57:44 <roconnor> > foldr (.) id [a,b,c] z
21:57:45 <lambdabot>   Couldn't match expected type `a -> a'
21:57:49 <roconnor> > foldr (.) id [a,b,c] d
21:57:50 <lambdabot>   Couldn't match expected type `a -> a'
21:57:57 <roconnor> > foldr (.) id [f,g] h
21:57:58 <lambdabot>   Add a type signature
21:58:01 <roconnor> > foldr (.) id [f,g] h x
21:58:02 <lambdabot>   Overlapping instances for GHC.Show.Show (SimpleReflect.Expr -> a)
21:58:03 <lambdabot>    arisin...
21:58:09 <roconnor> > foldr (.) id [f,g] x
21:58:11 <lambdabot>   f (g x)
21:58:20 <roconnor> > foldr ($) x [f,g]
21:58:21 <lambdabot>   f (g x)
21:58:29 <roconnor> > foldl (flip ($)) x [f,g]
21:58:30 <lambdabot>   g (f x)
21:58:39 <roconnor> > foldl (flip (.)) id [f,g] x
21:58:40 <lambdabot>   g (f x)
21:59:58 <ozten> It looks like I need to create an adapter for Network.CGI into a ServerPartT, but as a newbie focusing on learning Happstack, it might be over my head
