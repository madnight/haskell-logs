00:00:05 <ski> np
00:00:14 <blackdog> Lycurgus: "Commonwealth English" is not quite the same thing as the English spoken by Commonwealth nations. It's just a shorthand for English that's closer to the original English than the USian reformulation.
00:00:41 <Lycurgus> you get the last word on this
00:03:41 <Unregistered> http://bit.ly/Tp2F1 Is this good?need advice from pros
00:04:10 <Zeiris> Do the Haskell C bindings have support for C to Haskell callbacks?
00:04:22 <blackdog> Zeiris: yes.
00:04:30 <ski> (mayhaps someone should ban the spammer ..)
00:05:04 <blackdog> ski: yeah, it's mildly obnoxious
00:06:14 <blackdog> Zeiris: there are some restrictions on callbacks - when you import a C function into a Haskell program, you can either import it as "safe" or "unsafe" - using "unsafe" means you promise that you won't call back into Haskell.
00:06:39 <blackdog> Zeiris: http://www.haskell.org/ghc/docs/4.08/set/sec-primitive.html
00:07:23 * ski wonders why that was called "unsafe" rather than "will_not_callback" or something
00:07:54 <blackdog> ski: nonreentrant, maybe
00:08:29 * ski nods
00:08:32 <blackdog> but yeah, from the perspective of a programmer it's almost reversed. you have to mark all your simple, safe functions like sin as unsafe...
00:09:09 <ski> (and "unsafe" doesn't tell you what the possible problem is)
00:10:03 <blackdog> suppose it makes sense from the perspective of the compiler
00:11:44 <ivanm> ski: he won't be here long enough probably
00:12:50 <ski> well, s/he rejoined once ..
00:13:04 <blackdog> spambots have gender now?
00:13:28 <ski> Mercury has `may_call_mercury'/`will_not_call_mercury' , `promise_pure'/`promise_semipure' and `thread_safe'/`not_thread_safe'/`maybe_thread_safe'
00:13:37 <ski> blackdog : why not ? :)
00:14:01 <blackdog> @vixen: a/s/l?
00:14:12 <ski> @botsmack
00:14:13 <lunabot>  :o
00:14:29 <blackdog> ... comprehensive proof will have to wait for another day
00:15:28 <DarkUnicorn> ski: what is "semipure"?
00:18:34 <ski> DarkUnicorn : semipure calls can be commuted with other pure and semipure calls, but not with impure calls; the typical example is something that reads state (but doesn't modify state)
00:19:16 <DarkUnicorn> ski: ah okay. thanks for the explaination!
00:20:17 <ski> (see <http://www.cs.mu.oz.au/research/mercury/information/doc-release/mercury_ref/Impurity.html> for more info on that)
00:21:33 <vegai> does anyone have a rather recent ghc-sparc snapshot?
00:21:36 <vegai> binary
00:22:41 <vegai> solaris-sparc, that is
00:32:10 <kbp> /leave/exit
00:35:21 <ivanm> does (opdolio) == dolio (assuming that (a -> b) is an instance of Eq)?
00:35:31 <ivanm> ;-)
00:36:20 <dolio> It's my dual category.
00:44:34 <EnglishGent> hello :)
00:44:44 <EnglishGent> hi solidsnack
00:45:12 <glenn01> hello
00:45:21 <glenn01> can u help me with my codes?
00:45:34 <solidsnack> EnglishGent: Hello.
00:45:46 <EnglishGent> can someone tell me how to convert a deviceID into an Integer? I want to enter Inode & device id's for various files into a database - and toSql fails when you try to provide them
00:45:49 <solidsnack> glenn01: send me teh codez
00:46:18 <EnglishGent> actually!
00:46:24 <EnglishGent> @hoogle DeviceID
00:46:42 <ski> (maybe `fromIntegral' ??)
00:46:49 <EnglishGent> oh - okay.. that seemed worth a go :|
00:46:58 <EnglishGent> ty ski :)
00:47:33 <glenn01> pls help me..
00:47:36 <glenn01> huhuhhu
00:47:46 * ski has no idea whether `DeviceID' is in `Integral'
00:48:16 <ski> glenn01 : if you don't tell the problem, how can anyone help ?
00:48:23 <glenn01> anyone?
00:48:53 <EnglishGent> doesnt seem to work ski :|
00:49:02 <glenn01> my problem is about binary tree arithmetic expression.. i need to traverse it
00:49:33 <glenn01> how to traverse the arithmetic expression, i hav the code and i think it is not enough
00:49:43 <anders^^> glenn01: post the code hpaste.org
00:50:49 <glenn01> anyone can help?
00:50:53 <glenn01> pls.
00:50:55 <glenn01> pls
00:50:55 <glenn01> pls
00:51:12 <EnglishGent> glenn01 - you need to either paste the code if you have some, or explain the question in more detail
00:51:24 <EnglishGent> people here are very friendly, and we will help if we can
00:51:27 <glenn01> ok
00:51:35 <EnglishGent> but we cant answer questions that arent clear!
00:52:18 <glenn01> BTNode.java
00:52:20 <glenn01> class BTNode {
00:52:28 <glenn01> class BTNode {
00:52:56 <EnglishGent> no glenn01 - you need to post it at hpaste.org & then post the link it gives you here
00:52:57 <ski> glenn01 : i think you possibly want to join ##java, instead
00:53:08 <EnglishGent> I made that mistake once when I was a newbie
00:53:21 <glenn01> i was a newbiehir
00:53:23 <glenn01> huhuhu
00:54:52 <EnglishGent> oh ick! DeviceID is not a member of Integer - but it is a member of Show - so you can do read (show (deviceID file_status)) :: Integer
00:54:59 <EnglishGent> that works - kinda ugly though
00:55:44 * ski wonders why that works
00:56:29 <pikhq> ski: I presume that DeviceID's show instance outputs a decimal number.
00:56:29 <EnglishGent> becuase deviceIDs are in fact integers - I mean it makes sense to wrap them in something so you cant do nonsensical things like add them together
00:56:50 <EnglishGent> but the show reperesentation returns the underlying number
00:57:36 <ski> then one should be able to use literals of type `DeviceID', no ?
00:57:54 <EnglishGent> not sure what you mean ski
00:57:56 <ski> .. oh, this was in the other direction, though
00:58:06 <EnglishGent> yes - other way :)
00:58:36 <EnglishGent> I'm writing some code to calculate the sha1 hash for every file - and dump it into a database along with the inode & device id
00:58:45 <EnglishGent> (duplicate file detection in Haskell) :)
00:58:53 <ski> (i meant that one should be able to use `496 :: DeviceID', and thus `fromInteger :: Integer -> DeviceID' .. at which point i realize that was the wrong direction :)
00:59:10 <glenn01> i pasted already my codes .. anyone could help
00:59:15 <glenn01> huhuhuhu
00:59:16 <glenn01> pls..
00:59:40 <ski> glenn01 : you haven't provided a link to the paste
00:59:50 <EnglishGent> id=9914
00:59:53 <EnglishGent> but it's in Java
01:00:00 <glenn01> oh sorry
01:00:14 <EnglishGent> glenn01 - this channel is about Haskell - which is different programming language
01:00:18 <glenn01> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9914
01:00:19 <ski> glenn01 : so ask in ##java and give them that paste link ?
01:00:32 <EnglishGent> (though In practice I imagine most people here know java as well)
01:00:35 <EnglishGent> yes - I'd ask there
01:01:28 <glenn01> anyone knows java?
01:01:43 <anders^^> glenn01: check in #java they know it
01:05:02 <Fragsworth> Man Haskell is a bitch to learn.
01:05:04 <EnglishGent> glenn01 - I know it, but I'm going to have to go soon
01:05:14 <EnglishGent> if you catch me later I might be able to help
01:05:25 <EnglishGent> but i'd ask in #java - you'll probably get an answer quicker
01:05:52 <Fragsworth> Are there any languages that you guys think are on par with Haskell as far as language quality is concerned?
01:06:54 <lambdabot> 19/f/California
01:06:55 <lambdabot> :)
01:07:14 <Botje> language /quality/ ?
01:07:17 <Botje> how do you define such a beast?
01:08:22 <glenn01> thank you so much EnglishGent
01:08:40 <lambdabot> System.Posix.Types type DeviceID = CDev
01:08:53 <ski> blackdog : ^
01:18:22 <Fragsworth> It's a pretty subjective question I'm asking
01:18:37 <Fragsworth> Basically, given that you know Haskell, are there any other languages you think are as good or better?
01:22:30 <dibblego> Fragsworth, few languages are as practical as Haskell
01:36:39 <hackagebot> usb-id-database 0.3.0.1 - A database of USB identifiers (RoelVanDijk)
01:43:17 <ivanm> dibblego: how are you defining "practical"?
01:43:35 <dibblego> solving general programming problems
01:44:02 <ivanm> so the typing system, pureness removing IO problems, etc.?
01:46:30 <dibblego> yes
01:46:38 <dibblego> pure, lazy, statically-typed -> practical
01:48:44 <en0th> foldr (++) ["h","e","l","l","o"]
01:49:13 <en0th> fail. Mmm... foldr (++) "!" ["h","e","l","l","o"]
01:49:24 <ivanm> dibblego: so the only other practical language to you is Clean?
01:49:50 <ivanm> > foldr (:) [] ['h', 'e', 'l', 'l', 'o'] -- ;-)
01:49:55 <dibblego> ivanm, practical is a continuum, Clean only works on Windows last I checked, which makes it less practical than Java
01:50:04 <ivanm> lambdabot: wakey-wakey!
01:50:06 <lambdabot>   mueval-core: Time limit exceeded
01:50:37 <en0th> ^^
01:50:40 <ivanm> dibblego: there's a cut-down version for *nix (less I/O and no "dynamics" according to wikipedia)
01:50:40 <ivanm> :o
01:50:46 <ivanm> @type foldr (:) [] ['h', 'e', 'l', 'l', 'o'] -- ;-)
01:50:52 <ivanm> @type foldr (:) [] ['h', 'e', 'l', 'l', 'o']
01:50:56 <ivanm> @type foldr (:) []
01:50:56 <ski> , foldr (:) [] ['h', 'e', 'l', 'l', 'o'] -- ;-(
01:50:58 <lunabot>  luna: parse error (possibly incorrect indentation)
01:51:02 <ski> , foldr (:) [] ['h', 'e', 'l', 'l', 'o']
01:51:03 <lunabot>  "hello"
01:51:08 <lambdabot> Plugin `type' failed with: thread killed
01:51:17 <ivanm> bugger, I thought lambdabot, etc. accepted comments...
01:51:18 <lambdabot> thread killed
01:51:19 <en0th> disastorz!
01:51:21 <ski> , [$ty| foldr (:) [] |]
01:51:22 <lambdabot> thread killed
01:51:24 <lunabot>  forall a . [] a -> [] a
01:51:37 <ski> ivanm : lambdabot does, but apparently lunabot doesn't
01:51:55 <ivanm> *nod*
01:52:01 <ivanm> but lunabot seems to work whereas lambdabot doesn't ;-)
01:52:32 <Itkovian> Any word on updates for Snow Leopard?
01:52:48 <ivanm> Itkovian: yes: they want you to do them
01:52:49 <ivanm> ;-)
01:52:56 <Veinor> lol
01:53:02 <Itkovian> :-)
01:54:55 <en0th> in real world code, is it common to define new type classes?
01:55:01 <dibblego> yes
01:55:38 <ivanm> all the time
01:55:52 <ivanm> en0th: mainly to avoid having to think up new function names (in my code, anyway) :p
01:56:35 <en0th> mm.. i'm polluted by java interfaces.
01:57:07 <ivanm> though I did use a type class to avoid having to work out what the appropriate function name for a given type was in some auto-generated code...
01:58:26 <en0th> so if you write a data type for a Tree, wich typeclasses would you add it to
01:59:23 <ski> i would not add a type class until i need at least two types as an instance of it
02:00:37 <en0th> ok! this doubt is because i thought: you can insert items to a tree, and you can do it also with other types
02:01:34 <en0th> so maybe i should make a type class with insert function..
02:01:38 <sohum> heh. wouldn't that be something like Constructable? i.e., including every ADT in haskell? ;)
02:02:01 <sohum> less snarkily, that feels like a slight mismatch in what you use typeclasses for
02:02:04 <sohum> to m
02:02:05 <sohum> ee
02:02:20 <en0th> yes whatever-able like in java interfaces.. that's why i say i'm polluted by java
02:02:21 <Gracenotes> a typeclass can serve a purpose like an interface in Java, but generally in Haskell you create unnecessary abstractions by overuse
02:03:02 <Gracenotes> like, if someone is going to write a function, they are probably going to use a specific data structure, rather than a generic collection
02:03:16 <maltem> I'm looking for a generic (Monad)Fail class, something like class Fail m where { type Failure m; mfail :: Failure m -> m a } -- but looks like nothing along these lines is packaged?
02:03:20 <sohum> because typeclasses are for abstraction at a different level
02:03:59 <sohum> what Gracenotes said
02:03:59 <dolio> @type throwError
02:04:14 <maltem> dolio: MonadError needs an implementation of catchError
02:04:20 <maltem> which I don't want to provide
02:04:24 <lambdabot> thread killed
02:04:36 <en0th> ok, i'll remember this :)
02:04:44 <sohum> like, look at the typeclass Foldable
02:05:05 <sohum> that's stuff that you can fold on
02:05:23 <sohum> folding being something a person does /to/ a set of data, not /on/. if that makes sense.
02:05:23 <dolio> maltem: Unfortunately, there's no generic failure class like that.
02:05:40 <maltem> ok then I'll just make it up
02:05:41 <sohum> maltem: I've used MonadPlus's mzero for that purpose before
02:05:44 <dolio> maltem: Only failure with some sort of catching still exists.
02:06:05 <maltem> sohum, then I have the same problem as with MonadError, that I don't implement the whole instance
02:06:23 <en0th> interesting, sohum.
02:06:58 <sohum> maltem: mplus is just meant to properly take care of the mzero case, really
02:07:10 <sohum> well, scratch that
02:07:17 <sohum> that's not what it's "meant" to
02:07:27 <maltem> you mean, you use it to propagate failure?
02:07:27 <sohum> but an implementation that just does that is fine, I'd say
02:07:32 <sohum> yea
02:07:43 <ski>   mzero `mplus` ma = ma
02:07:50 <maltem> well that's what >>= should do, I think
02:07:58 <maltem> and what ski said
02:08:52 <sohum> that is what >>= should do, but then you don't have an explicit notation for failure
02:09:14 * ski idly wonders what "that" refers to ..
02:09:18 <sohum> hm. I see your point
02:09:30 <maltem> ski: propagate failure
02:09:53 <sohum> >>='s handling of any failure cases is implicit rather than explicit
02:10:23 <ski> what is the difference between implicit and explicit, here ?
02:10:29 * maltem is wondering if I should add a (Monad m) context to my type class
02:11:14 <ski> maltem : not necessarily .. it might be useful for applicative functors (or even plain functors), maybe
02:12:00 <ski> (also, call the `/me'-police)
02:12:31 * maltem forgot where the phone is
02:12:47 <ski> maltem : maybe you have some laws relating `mfail' to monadic operations in mind ?
02:13:06 <sohum> oh, doy. this is where I point out that I know just enough to be dangerous. >>= is for chaining computation. mplus is for combining results.
02:13:07 <ski> in that case it could make sense to add the `Monad m' precondition
02:14:24 <maltem> I don't think there are any laws that I could have in mind, so I should probably drop it. On the other hand, I have another class here where the (Monad m) context just serves to greatly reduce my type signatures ;)
02:15:58 <ski> possibly you want `mfail failure >>= _ = mfail failure' ?
02:15:59 <maltem> I think I don't even want to guarantee propagation of failure, because that isn't natural for my primary use case, MonadPrompt
02:16:11 <maltem> yea see, there's the problem ;)
02:16:21 <sohum> can't you use a type synonym for the simplifying thing?
02:16:31 <ski> maltem> @src MonadPrompt
02:16:35 <maltem> sohum, not for the contexts
02:16:41 <sohum> ah, true
02:16:53 <sohum> wait, I'm fairly sure there was a trick for that
02:17:03 <maltem> sohum, there is a trick with UndecidableInstances
02:17:09 <maltem> but I found it even less elegant
02:17:44 <maltem> or rather, it didn't save me as much typing :)
02:18:32 <sohum> do you have a large set of constraints, or is it just Monad m?
02:19:34 <sohum> why /can't/ you put a type constraint in a type synonym?
02:19:56 <maltem> sohum, (Monad m, Monad n), and additionally I'd have to resort to using ~ due to a GHC bug in FlexibleContexts
02:20:16 <ski> iirc, ghc allows that, but doesn't provide any class constraint synonyms
02:21:47 <sohum> hm. yea, I'm out of ideas, then
02:23:05 <hackagebot> json-b 0.0.0 - JSON parser that uses byte strings. (JasonDusek)
02:23:39 <maltem> sohum, no problem, the class in question makes "practical" sense only for specific monads anyways
02:24:26 <EnglishGent> @hoogle toInteger
02:24:36 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
02:25:25 * ski prompts maltem again about the monad
02:25:52 <maltem> @where MonadPrompt
02:25:56 <lambdabot> I know nothing about monadprompt.
02:26:03 <maltem> @hackage MonadPrompt
02:26:06 <lambdabot> http://hackage.haskell.org/package/MonadPrompt
02:28:42 <maltem> well the class is a little strange:
02:29:01 * EnglishGent waves to ski :)
02:29:21 <maltem> -- | Like MonadPrompt, but with the dependent arrow in the other direction.
02:29:29 <maltem> -- Usage: runPromptM embed ...
02:29:34 <maltem> class Monad m => Embed p m | p -> m where
02:29:39 <maltem>     embed :: p a -> m a
02:30:35 <ski> (for some reason, i was thinking about condition systems)
02:31:14 <lysgaard> I have a problem: I wont to send an udp package to an node containing a function to execute, then have the node execute the function and return the result. What i want to achieve would be as little difference as possible in runninng a function localy and remotely.
02:31:37 * ski waves from EnglishGent
02:31:45 <maltem> google condition system ---> Understanding Your Dog's Body Condition
02:32:18 <ski> Condition Handling in the Lisp Language Family by Kent M. Pitman (2001) <http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html>
02:33:05 <ski> "like" exception systems, except you don't neccesarily abort (you can continue in some cases), iiuc
02:33:30 <lysgaard> Eg. f = x*2; locally: f 2;  remotely: send "10.0.0.2:123" $ f 2    where send is a function that handles the magic
02:33:42 <maltem> ski, too much for me to digest now, but at least it shares with the MonadPrompt the use of continuations
02:34:45 <ski> you signal a condition that you don't know how to handle locally. a handler up the dynamic extent might decide to abort, or to do some fix, or to delegate to next handler. the top-level might enter a debugger allowing one to inspect local variables at the signal point
02:34:48 <maltem> lysgaard, isn't that what distributed computing frameworks, which haven't really been ported to haskell afaik, do?
02:35:09 <lysgaard> maltem: That's exactly what i want to achieve
02:35:28 <maltem> ah heh
02:35:31 <lysgaard> maltem: Any reason why there's no distrib frameworks yet
02:35:36 <ski> Alice ML has something like that
02:36:00 <ski> (<http://www.ps.uni-sb.de/alice/manual/tour.html#distribution>)
02:36:05 <maltem> lysgaard, to little number-crunching Haskell programmers I suppose
02:36:34 <lysgaard> maltem: Heh, i thought that was all haskell was about :P
02:36:48 <maltem> ski, now talking "delegate to the next handler", that's very similar to what I'm doing
02:37:18 <maltem> ski, at least, if I had a chain of Embed instances
02:37:35 <ski> maltem : well, at least the "separate issue from how to handle it" sounded similar to `MonadPrompt' (iiu it correctly)
02:37:47 <Fragsworth> In "putChar :: Char -> IO ()", what is suggested by "IO ()"?
02:38:06 <maltem> right
02:38:27 <lysgaard> ski: This Alice is not meant for haskell, am I right?
02:38:28 <ski> Fragsworth : that `putChar' gives you an action that when executed will perform some I/O and return `()' (an uninteresting value)
02:38:34 <ziman> Fragsworth, putChar takes a Char and returns an IO action returning () ("nothing") that, when executed, prints that char
02:38:38 <ski> lysgaard : no, it is Alice ML :)
02:38:55 <ski> lysgaard : that link was for comparision, mostly
02:38:56 <maltem> Fragsworth, (putChar 'x') is an IO action that, when performed, will do some IO (namely, output 'x'), but return nothing interesting (namely, ())
02:39:08 <lysgaard> ski: Ah, thanks =)
02:39:28 <maltem> :o I'm slow
02:39:58 <Fragsworth> So if I wanted putChar to do some IO AND return a value, should I do "putChar :: Char -> IO (Char)"?
02:40:01 <en0th> lysgaard, if it's an experiment, you could pass strings over network
02:40:23 <maltem> Fragsworth, yes that's right, except that you'd want to name the function differently
02:40:33 <ski> Fragsworth : `putChar' only monadically returns `()', if you want to return something else, you have to make another action
02:40:40 <ski>   foo :: Char -> IO Char
02:40:47 <ski>   foo c = do
02:40:51 <ski>     putChar c
02:40:56 <ski>     return '!'
02:40:57 <ski> e.g.
02:41:02 <lysgaard> Well, maybe i can explain my problem better. Lets say i send a task to a node. I can't wait for it to complete, my code has to continue. BUT, when the node returns an answer, i need the code to continue in the same place as it left. Some kinda callback/event something
02:41:07 <Fragsworth> Ok, thanks
02:42:49 <maltem> sendTastkToNode >> waitForAnswer >>= workOnThat -- the interesting thing is waitForAnswer :)
02:43:09 <maltem> but I'm clueless really
02:43:18 <Peaker> @type (>>return '!') . putChar
02:43:27 <Fragsworth> So IO types are what connect haskell to the outside world?
02:43:31 <Fragsworth> Everything else is internal?
02:43:40 <ski> you could say that, yes
02:43:50 <zenzike> I'm having troubles with importing the right version of parsec into ghci; I want to be using 3.0.1, but the type signatures of some of the functions look wrong, which makes me think a previous version is being used. Is there any way of knowing which one is being imported?
02:44:47 <maltem> zenzike, use -hide-package/-expose-package
02:45:06 <maltem> zenzike, also, note that parsec-3 uses Text.Parsec for the main interface
02:45:18 <maltem> (I tripped on that catch shortly)
02:45:46 <maltem> s/shortly/recently
02:46:00 <zenzike> maltem: yeah i'm looking at the symbol function in Text.Parsec.Token
02:46:23 <lysgaard> maltem: Yeah, your analysis is right, but it's that pesky waitForAnswer. Haskell is so strict in nature, i really don't know how this would work..
02:46:41 <Peaker> @bot
02:46:42 <lunabot>  :o
02:46:44 <zenzike> maltem: it should have signature symbol :: String -> ...., but I've got something like symbol :: GenTokenParser ... -> String -> ...
02:46:47 <Peaker> ,type (>>return '!') . putChar
02:46:48 <lunabot>  luna: parse error on input `type'
02:46:53 <Peaker> ,t (>>return '!') . putChar
02:46:54 <lunabot>  luna: Couldn't match expected type `(m a -> m GHC.Types.Char) -> b -> c'
02:47:32 <Peaker> ,t return '!' << putChar 'x'
02:47:33 <lunabot>  luna: Not in scope: `<<'
02:47:35 <lysgaard> maltem: What's shure is that i can't start a thread for each task I send, would flood the cpu
02:47:37 <ivanm> I'm updating my SourceGraph app, and I'm trying to work out what kind of shapes to use for different entities in Haskell code (class function, instance of class function, constructor, record function, normal function)
02:47:45 <Peaker> ,t putChar 'x' >> return '!'
02:47:46 <lunabot>  luna: Couldn't match expected type `(GHC.Types.Char -> GHC.IOBase.IO ())
02:47:48 <ivanm> any suggestions? the possible shapes are at http://www.graphviz.org/doc/info/shapes.html
02:48:12 <ski> , [$ty| (>> return '!') . putChar |]
02:48:15 <lunabot>  Char -> IO Char
02:48:17 <Peaker> ah
02:48:22 <ski> , help
02:48:23 <maltem> zenzike, why it *is* GenTokenParser ... -> String -> ...
02:48:25 <lunabot>  type of an expression:      , [$ty| \x -> x |]
02:48:25 <lunabot>  get info for a type/class:  , src ''Monad
02:48:25 <lunabot>  get info for a var/con:     , src 'fix
02:48:28 <Peaker> lunabot has messy syntax
02:48:45 <en0th> ivanm, the link seems to be broken
02:48:48 <maltem> zenzike, note that it's a record selector when reading the docs
02:48:56 <ivanm> en0th: :o working here...
02:48:58 <zenzike> maltem: doesn't look like that in the code does it?
02:49:04 <ivanm> http://www.graphviz.org/doc/info/shapes.html <-- works here
02:49:19 <zenzike> maltem: ah, that makes sense
02:50:19 <ski> (ivanm : "box" for all of them ?)
02:50:21 <lysgaard> maltem: In OO languages the send -> doOtherStuff
02:50:44 <maltem> lysgaard, ok, then this sounds like a typical problem of concurrent programming :) keep in mind though that ghc threads are green, and ghc will only use as much OS threads as instructed by -N
02:50:59 <ivanm> ski: I'm wanting to differentiate between them by shape
02:51:03 <maltem> s/ghc will/the RTS will/
02:52:01 <maltem> lysgaard, that is, it's not disastrous to fork 50 threads
02:52:20 <lysgaard> maltem: Yeah, if it helps, what I'm trying to make is an DHT And the remote tasks that has to be done are lookup of nodes in the DHT
02:52:39 <maltem> @go DHT
02:53:03 <ski> @slap lambdabot
02:53:06 <maltem> Distributed Hash Table, as it turns out. lambdabot: fail!
02:53:11 <lysgaard> maltem: Well, I'd rather not solve it that way, if it's possible to make the cedo cleaner
02:54:08 <lysgaard> maltem: I know, there's _no_ research on dhts in haskell =/ I really don't understand why, It's a so interesting subject
02:55:21 <maltem> lysgaard, maybe the community just waits for YOU to do the research ;)
02:55:47 <lysgaard> maltem: I'd LOVE to! =)
02:56:15 <lysgaard> maltem: But i need some help from you guys, because of my rookines in haskell
02:58:12 <hackagebot> json-b 0.0.1 - JSON parser that uses byte strings. (JasonDusek)
02:58:17 <medfly> DO IT LYSGAARD!
02:58:17 <medfly> I don't really know what dhts is, I'm just acting as the community in maltem's world.
02:58:47 <lysgaard> medfly: Hihi
02:59:37 <lysgaard> A dht is a content adressible network. Imagine todays P2P, to find something messages are flooded from node to node untill you by chance hit something
03:00:17 <hackagebot> json-b 0.0.2 - JSON parser that uses byte strings. (JasonDusek)
03:00:21 <lysgaard> In a dht there's mathematical proof that if the thing you are searching for is on the network, it will be reached in a fixed number of hops, and it will _always_ be reached
03:00:26 <pozic> lysgaard: why would it be research to do something in Haskell?
03:00:52 <lysgaard> pozic: It's not research
03:00:59 <pozic> lysgaard: and how big is this number, which is of course the interesting thing?
03:01:17 <pozic> Then why did you say " I know, there's _no_ research on dhts in haskell =/ I really don't understand why, It's a so interesting subject"
03:01:54 <lysgaard> pozic: It's the log(m) where m is the number of nodes
03:03:01 <lysgaard> pozic: Maybe i worded myself wrong, I'm sorry. I'm just a high scool student afterall, for _me_ this is research, in the sense of that i'm learning something new as im doing it.
03:03:40 <lysgaard> s/scool/school/
03:05:42 <EnglishGent> anyone know how you determine the device ID for the filesystem some file is on -- from the Unix shell? (I know it's not strictly a Haskell question.. but I need to do it whilst debugging some Haskell code) :)
03:06:25 <ivanm> where can I find the options for ~/.cabal/config ?
03:06:59 <dcoutts> ivanm: you mean what fields can be used, or the allowed values for the fields?
03:07:06 <ivanm> what fields
03:07:10 <maltem> EnglishGent, not sure about scripting, but mount and df list the current mount points
03:07:50 <dcoutts> ivanm: ok, so you've probably got an old config file created by an old version of the program.
03:07:56 <ivanm> yup
03:07:56 <maltem> EnglishGent, and df FILE will limit output to the appropriate device
03:08:13 <ivanm> still works, I just want to tell it to build docs, etc. by default
03:08:14 <dcoutts> ivanm: back it up, delete, let it be recreated and merge back any saved options
03:08:31 <pozic> lysgaard: if you are a high school student and get dhts to work in Haskell, you can skip university.
03:08:32 <ivanm> what kind of cabal commands will create it? anything?
03:08:35 <dcoutts> ivanm: the new one is more-or-less self-documenting
03:08:38 <Beelsebob> EnglishGent: if it's OS X, then diskutil list is rather easier to process than the output of mount
03:08:45 <dcoutts> ivanm: pretty much, eg list foobar
03:09:25 <ivanm> thanks dcoutts
03:09:39 <ivanm> what does "library-vanilla" mean?
03:09:40 <SamB_XP> dcoutts: what? someone rewrote foobar in haskell???
03:10:21 <dcoutts> ivanm: it means not profiling
03:10:27 <dcoutts> ivanm: what would you call it?
03:10:29 <Zao> I wish that there was a VC++ backend for GHC.
03:10:37 <ivanm> ahhhh
03:10:37 <Zao> It would make making foobar2000 components much easier.
03:10:42 <ivanm> dcoutts: profile :: Bool ?
03:10:52 <dcoutts> ivanm: no, that's not the same
03:10:55 <ivanm> dcoutts: esp since you have library-profiling as well...
03:11:00 <dcoutts> ivanm: exactly!
03:11:03 <dcoutts> they're independent
03:11:07 <lysgaard> maltem: Btw. I think I've found my savior when it comes to the waitforanswer problem Control.Engine
03:11:11 <ivanm> oh, profiled and non-profiled versions?
03:11:16 <dcoutts> ivanm: right
03:11:20 <xenoblitz> Hi anyone from Leksah inside here? :)
03:11:28 <ivanm> dcoutts: and do username and password replace the hackage-* fields?
03:11:48 <dcoutts> ivanm: it accepts the new and old names
03:11:52 <EnglishGent> ty maltem, Beelsebob :)
03:11:56 <ivanm> *nod*
03:12:00 <ivanm> still quoted strings?
03:12:14 <dcoutts> ivanm: I don't think it matters anymore
03:12:38 <ivanm> heh, you've put in enough DWIM into cabal-install? :p
03:13:05 <ivanm> what's the difference between build-log and build-summary? (log is verbose?)
03:25:27 * ivanm wished Data.Set used elem rather than member, or at least had it as an alias
03:25:47 <ivanm> I understand why they used member, but for switching from lists, etc. it'd be nice to use elem
03:28:46 <EnglishGent> @hoogle splitExtension
03:29:32 <maltem> lysgaard, care to summarize in a sentence?
03:30:11 <ivanm> does anyone else find that in emacs with haskell mode, the string "forestgreen" is highlighted automatically? :s
03:30:17 <ivanm> EnglishGent: lambdabot seems to be sulking
03:30:23 <ivanm> preflex: seen lambdabot
03:30:23 <preflex>  lambdabot was last seen on #haskell 1 hour, 4 minutes and 17 seconds ago, saying: http://hackage.haskell.org/package/MonadPrompt
03:31:02 <ivanm> strange, now it isn't highlighted :s
03:36:17 <byorgey> was it highlighted in... forest green?
03:37:50 <xenoblitz> can someone help me install gtk2hs 0.10.1 with ghc 6.10.4?
03:38:04 <dcoutts> xenoblitz: what OS?
03:38:13 <xenoblitz> windows xp
03:39:21 <xenoblitz> dcoutts: I am actually making use of the latest Haskell Platform
03:39:28 <xenoblitz> dcoutts: if it matters that is
03:40:15 <SamB_XP> xenoblitz: oh, and if it doesn't matter, you aren't? ;-P
03:40:39 <xenoblitz> SamB_XP: no i still am! :-P
03:41:05 <maltem> um - what does it mean when documentation talks about "A 4-byte magic number '\377tOc'"?
03:41:14 <maltem> since when does 377 fit into a byte?
03:41:19 <Zao> maltem: Octal.
03:41:26 <maltem> ahh
03:41:29 <maltem> thanks
03:41:35 <Veinor> but why is that octal? :/
03:41:50 <Zao> Because \nnn is octal.
03:41:50 <maltem> (in ghci it's decimal)
03:41:53 <Zao> In most sane languages.
03:41:55 <Zao> (C)
03:42:09 <maltem> in C yeah
03:45:34 <xenoblitz> dcoutts: I will uninstall the one installed via windows installer and try to edit the cabal file and install it manually... do you think that would work?
03:46:07 <dcoutts> xenoblitz: the last official installer only works with 6.10.3. I made a minimal one (without glade etc) that works with 6.10.4
03:46:39 <EnglishGent> @hoogle [a] -> [a] -> Bool
03:46:41 <dcoutts> xenoblitz: I'm not sure what you mean about editing etc
03:47:04 <ivanm> xenoblitz: gtk2hs doesn't use cabal
03:47:08 <xenoblitz> dcoutts: nevermind I am still not much used to cabal installing etc etc... erm may I ask where I can download the minimal one which works with 6.10.4?
03:47:11 <ivanm> so editing the cabal file won't help you ;-)
03:47:16 <EnglishGent> is lambdabot dead? :|
03:47:26 <xenoblitz> ivanm: Oh :/
03:47:43 <ivanm> EnglishGent: looks like it
03:47:43 <dcoutts> xenoblitz: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.exe
03:48:02 <xenoblitz> dcoutts: thanks :D
03:48:03 <dcoutts> xenoblitz: if you need more than the minimal stuff you can build it from source, but it's not a trivial exercise
03:48:57 <xenoblitz> dcoutts: hmmm i mostly need Graphics.UI.Gtk and Graphics.Rendering.Cairo
03:53:17 <xenoblitz> dcoutts: thanks it seems to work for what I need
03:53:31 <dcoutts> great
03:55:40 <EnglishGent> hmm .. why doesnt tail [] yield an empty list? [] is of type [x] for all x
03:55:46 <ivanm> dcoutts: glade is just the tool for building GUIs with gtk, right?
03:55:51 <ivanm> (as in designing)
03:55:56 <EnglishGent> I can see why you cant define head [] -- is this just for symmetry?
03:56:02 <EnglishGent> or is there a deeper reason?
03:56:09 <dcoutts> ivanm: yes, and libglade for loading the xml files
03:56:13 <poe> EnglishGent: because [] is the empty list, it has no tail
03:56:16 <Beelsebob> EnglishGent: yes, because [] doesn't have a tail
03:56:36 <Beelsebob> (:) has two arguments – it's head, and it's tail
03:56:37 <pozic> EnglishGent: you cannot define it polymorphically with a sensical value.
03:56:38 <Beelsebob> [] is not (:)
03:56:44 <poe> EnglishGent: the head and the tail of a list are the first and second arguments of (:)
03:56:59 <en0th> [] is sugar Nil
03:57:12 <pozic> EnglishGent: head_int [] = 0 could be done,  but not head [] = 0.
03:57:38 <pozic> EnglishGent: oh, misread, sorry.
03:57:41 <Beelsebob> pozic: but that would be insane
03:57:54 <Beelsebob> how would you tell the difference between [0] and []?
03:57:56 <pozic> Beelsebob: tell that to the Coq people.
03:58:10 <maltem> EnglishGent, you can write "drop 1" to get the behaviour you described
03:58:11 <Beelsebob> pozic: well yeh, but they have the type system to check whether the list is empty or not
03:58:16 <pozic> Beelsebob: actually, that's not really true.
03:58:24 <EnglishGent> ah ty!
03:58:25 <pozic> Beelsebob: in their stdlibs they do it correctly.
03:58:29 * ski doesn't see that `tail [] = []' would be that useful
03:58:42 <pozic> EnglishGent: I have a total_tail function in my library.
03:58:47 <Jafet> ski, tail recursion!
03:58:51 <pozic> EnglishGent: so, it's arbitrary.
03:58:58 <ski> Jafet : sorry ?
03:59:11 * Beelsebob would much rather have partial, than wrong
03:59:17 <Jafet> That was supposed to be punny.
03:59:27 <ski> oh
03:59:31 <Beelsebob> Jafet: I giggled
03:59:32 <Beelsebob> :P
04:00:00 <EnglishGent> I dont know - it's defined that way in common lisp ski (cdr '()) -> ()
04:00:07 <EnglishGent> and it is useful in many contexts
04:00:36 <Jafet> It's not in scheme, and we all know who's superior
04:00:42 * byorgey would much rather have  tail :: [a] -> Maybe [a]
04:00:57 <Beelsebob> byorgey: that would certainly be very nice, yes
04:01:08 <EnglishGent> scheme doesnt allow it though
04:01:18 <doserj> EnglishGent: there is always 'drop 1'
04:01:21 * ski . o O ( `as :: [a] |- Maybe (tail as :: [a])' )
04:01:27 <Jafet> Oh lawd, the Maybe virus
04:01:42 <Beelsebob> Jafet: what's wrong with Maybe?
04:02:10 <vegai> Beelsebob: Nothing?
04:02:16 <Beelsebob> vegai: >.<
04:02:17 <byorgey> hehe
04:02:18 <Beelsebob> bad!
04:02:30 <EnglishGent> by that line of reasoning shouldnt we also have head :: [a] -> Maybe a
04:02:31 <EnglishGent> ?
04:02:35 <byorgey> indeed.
04:02:38 <Beelsebob> EnglishGent: yes, absolutely
04:02:39 <Peaker> I would love to see all explicitly partial functions go into a Maybe
04:03:10 <Beelsebob> or Either, if we actually care about the error
04:03:11 <Peaker> or at least, if they don't, maybe they can get some conventional prefix/suffix for their partiality
04:03:14 <Beelsebob> Either String rather
04:03:15 <ski> Peaker : even `fromJust' ?
04:03:27 <Peaker> Beelsebob, well, when there's just one possible error...
04:03:29 <Beelsebob> ski: I'd like that one to just bugger off
04:03:48 <Peaker> @type fromMaybe . error
04:03:56 <byorgey> or just call it 'unsafeFromJust'
04:04:02 <Beelsebob> that would work, yes
04:04:06 <ski> , [$ty| fromMaybe . error |]
04:04:09 <lunabot>  forall b . [] Char -> Maybe b -> b
04:04:27 <Peaker> That would force people to explain why they're sure its not a Nothing :)
04:04:49 <kbp> what does "!!" mean in if (reverse bitString) !! i == '0' then F else T ? I cant google because "!!" are special characters
04:05:08 <byorgey> kbp: that's list indexing
04:05:09 <ski>   (!!) :: [a] -> Int -> a
04:05:15 <byorgey> > [1..10] !! 3
04:05:23 <byorgey> , [1..10] !! 3
04:05:24 <ski> , [1..10] !! 3
04:05:24 <lunabot>  4
04:05:25 <lunabot>  4
04:05:56 <en0th> About Maybe.. I have "instance (Eq m) => Eq (Maybe m) where . . ." But i can build a Just t with t not deriving Eq, right?
04:05:58 <kbp> I've got it, thank you byorgey and sk
04:06:02 <kbp> *ski
04:06:09 <kbp> (tab doesnt work)
04:06:16 <ski> en0th : sure
04:06:18 <byorgey> kbp: also, you may not be able to Google... but you can Hoogle!
04:06:24 <byorgey> kbp: haskell.org/hoogle
04:06:47 <kbp> byorgey: haha nice, didn't even  know it exists
04:07:02 <kbp> byorgey: thanks :)
04:07:02 <en0th> so, is it correct to say that a parametric type can only partially belong to a type class?
04:07:07 <byorgey> kbp: sure =)
04:07:41 <byorgey> en0th: I don't understand what you mean.  can you give an example?
04:08:22 <ski> , maybe (error "8128") ($ (pi / 4)) (lookup "sin" [("cos",cos),("sin",sin)]) ** 2
04:08:24 <lunabot>  0.4999999999999999
04:08:38 <EnglishGent> hmm... I'd be inclinced to have head :: [a] -> Maybe [a]
04:08:48 <EnglishGent> and tail x defined as drop 1 x
04:08:55 <EnglishGent> maybe it's my common lisp background showing
04:09:01 <byorgey> en0th: re: your previous question, you can construct a 'Just t' with t having some type not deriving Eq, sure.
04:09:09 <ski> en0th : iirc, we have `instance Eq (IORef a)' without further constraints on `a'
04:09:09 <byorgey> en0th: you just wouldn't be able to compare it for equality.
04:09:18 <EnglishGent> but cl does it that way for a reason - otherwise the empty list becomes an annoying corner case in many algorithms
04:09:53 <ski> en0th : but strictly, `Maybe Int' is one type, `Maybe Bool' another (related) one, `Maybe a' is one type for each value of `a'
04:09:55 <Peaker> EnglishGent, drop 1  is easy enough to use though?
04:10:22 <EnglishGent> I agree Peaker - it's a lovely solution
04:10:36 <ski> EnglishGent : do you have an example ?
04:10:39 <EnglishGent> I guess it depends on what one thinks the semantics of 'tail' are :)
04:10:42 <en0th> now i see the point. "Maybe" doesnt belong to a type class
04:10:52 <ski> sure it does
04:10:56 <ski>   instance Functor Maybe
04:10:59 <Peaker> en0th, Maybe belongs to several type-classes
04:11:03 <en0th> omg !
04:11:05 <EnglishGent> er.. not immediately to hand ski - but I bet I can come up with plenty if I go looking - it's something I've seen over & over again
04:11:15 <Peaker> en0th, Type class instances can be simple types, or type constructors, too
04:11:40 * EnglishGent remembers having long discussions on the differences between Scheme & Common Lisp before - and this difference certainly came up
04:12:06 <Peaker> I hate CL :(
04:12:17 <ski> en0th : `Functor' (and also `Monad') is what were known in the ancient days as "constructor classes"
04:12:42 <EnglishGent> although it's not CLish (becuase Strings arent Lists in CL) - I think it would be easy to come up with cases involving strings
04:12:43 <en0th> it's more clear now
04:13:05 <EnglishGent> in fact - a concrete example - splitExtension in Haskell - yields an empty string as the 2nd parameter if the file doesnt have an extension
04:13:17 <EnglishGent> if it *does* it has the extension beginning with the '.'
04:13:47 <pozic> CL is too big, has funcall, but at least has SLIME.
04:13:49 * ski then dislikes that choice :)
04:14:02 <EnglishGent> now 'tail (snd (splitExtension file))' breaks -- though 'drop 1 (snd (splitExtension file))' does what you want
04:14:21 <EnglishGent> which choice ski? :)
04:14:29 <pozic> Scheme is also too big in some sense. How many people know the exact interactions with exceptions and continuations?
04:14:35 <ski> returning something prefixed with `.'
04:14:43 <EnglishGent> Haskell is at least as big as Scheme
04:15:00 <EnglishGent> the problem is the corner case (again) - a file who's name ends in '.'
04:15:18 <ski> (pozic : not to mention the interaction between dynamic environment with threads and composable continuation)
04:15:20 <EnglishGent> which is pathalogical of course & shouldnt happen (and therefore will)
04:15:21 <EnglishGent> :)
04:15:39 <pozic> ski: yes, that's what I wanted to say, but this was simpler :)
04:16:05 <pozic> In Haskell I don't know anything of which I don't know what it is supposed to do, except unsafePerformIO.
04:16:25 <EvilTerran> callCC?
04:16:34 <pozic> EvilTerran: callCC is not hard.
04:16:52 <EvilTerran> oh wait, we're back to talking about haskell, not lisps still. nvm.
04:22:18 <maltem> @hoogle m a -> m b -> m (a,b)
04:23:35 <ski> liftM2 (,)
04:23:38 <ski> liftA2 (,)
04:24:09 <maltem> ah right thx
04:30:26 <Baughn> pozic: unsafePerformIO creates a thunk that, when forced, executes some IO code. Simple.
04:30:57 <Baughn> ..well, except that's specific to lazy evaluation, which is not actually guaranteed
04:32:46 <Beelsebob> maltem: <^(,)^> can be useful too, to keep things infix
04:38:47 <Peaker> Does anyone know of any examples of Language.C.Analysis?
04:39:17 <Peaker> Beelsebob, its a bit appauling to many, though :)
04:40:12 <Alpounet> That's why it's interesting
04:40:20 * Beelsebob suggests letting them be appauled
04:40:24 <Beelsebob> it's much much cleaner to me
04:40:53 <Peaker> maybe if you could:  `liftA2 (,)`  :-)
04:41:00 <Peaker> blah `liftA2 (,)` bleh
04:41:16 <Beelsebob> how is that in any way better?
04:41:33 <ski> blah `liftA2 `($)` (,)` bleh
04:41:54 <Peaker> Beelsebob, it reuses backticks and liftA2 that people already know
04:42:16 <Peaker> Beelsebob, <^(,)^> is also harder to type than `liftA2 (,)`, probably, and looks funny too :)
04:42:20 <Beelsebob> why are people any more likely to know one function (liftA2) than another pair (<^) and (^>)?
04:42:36 <Peaker> Beelsebob, oh, you suggest wholly replacing liftA2?
04:43:11 <Beelsebob> no, I'm suggesting that if people are perfectly capable of learning what liftA2 means, they're perfectly capable of learning what a pair of infix operators that even look like "lifting" are
04:44:13 <Peaker> Beelsebob, well, I prefer methods that require less learning
04:44:19 <Peaker> and less remembering
04:44:48 * Beelsebob prefers methods that make the intention clear
04:45:08 <Beelsebob> (x <^(,)^> y) says very clearly "apply (,) to x and y, but lifted"
04:45:58 <Peaker> Beelsebob, well, `liftA2 (,)` says the same thing but seems to require less additional learning
04:46:09 <Beelsebob> but looks much less clear
04:46:36 <Beelsebob> the point here is to keep leaving it looking like an infix operator... otherwise we would have just used it prefix
04:51:56 <byorgey> (x <^(,)^> y) says very clearly "happy elephant"
04:52:42 <en0th> @type fmap
04:52:51 <en0th> , @type fmap
04:52:52 <lunabot>  luna: parse error on input `@'
04:53:00 <ski> , [$ty| fmap |]
04:53:03 <lunabot>  forall f b a . Functor f => (a -> b) -> f a -> f b
04:53:07 <fbru02> I agree with Peaker on this one
04:53:09 <en0th> ty!
04:53:10 <Beelsebob> byorgey: rofl
04:54:44 * ski . o O ( [> ([<x>],[<y>]) <] )
04:57:01 <Alpounet> ski, can't figure out which animal it is
04:57:42 <ski> no animal at all
04:59:22 <ski> written in Scheme-like notation, it'd be
04:59:35 <ski>   `(pair ,x ,y)
05:04:34 <en0th> omg i made my Tree instance of Functor. now i rock.
05:04:45 <dibblego> haha
05:04:47 <dibblego> fmap it!
05:05:04 <Alpounet> write a TreeT monad transformer, and you'll be done
05:05:08 <en0th> it could be risky.
05:05:33 <en0th> Alpounet, i'll write your sentence in my blackboard for future!
05:05:58 <dibblego> instance Monad Tree where ...
05:06:56 <en0th> ( .. there's no Monad Tree in this tutorial hehe
05:07:04 <Alpounet> en0th, actually, looking at the typeclassopedia and wondering whether your tree fits each of the shown classes may be interesting :-p
05:07:59 <ski> en0th : what is your tree type ?
05:08:02 <en0th> where can i find it?
05:08:11 <Alpounet> @where typeclassopedia
05:08:17 <Alpounet> damn, I miss you lambdabot
05:08:31 <en0th> data Tree a = End | Node a (Tree a) (Tree a)
05:08:32 <Alpounet> http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
05:08:43 <Alpounet> it's byorgey's article.
05:09:17 <en0th> i'm reading it :)
05:09:24 <ski> can you define `join :: Tree (Tree a) -> Tree a' naturally ?
05:10:50 * ski wonder's whether his CPS-tree is monadic
05:11:00 <en0th> join two trees? it seems that one information is missing..
05:11:23 <ski> join a tree of trees, not two trees
05:11:37 <ski> like
05:11:58 <ski>   concat [[],[0],[1,2],[3,4,5],[6,7,8,9]] = [0,1,2,3,4,5,6,7,8,9]
05:12:31 <en0th> it seems i need to fold in some way
05:12:49 <ski> (or maybe not exactly "like" that .. but it should be associative, and have a two-sided unit)
05:14:05 <Alpounet> once done with your binary tree
05:14:30 <Alpounet> you'll be able to go on with : data NaryTree a = End | Node a [NaryTree a]
05:15:14 <ski> or
05:15:15 <ski> , src ''Tree
05:15:16 * lilac ponders whether that Tree type has the Monad nature
05:15:18 <ski> i presume ?
05:15:18 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
05:15:48 <en0th> will be possible to build a NaryTree with given maximum n-arity?
05:17:01 <Jafet> Not in the type system
05:17:12 <maltem> en0th, for general n? well there may be a way abusing the type system... but it will be dreadful
05:17:50 <dolio> Abuse?
05:17:53 <en0th> ok, that's because in evil OOP, you often enforce constraint in constuctors
05:17:57 <Jafet> You can do it in C++ to get an idea of "dreadful"
05:18:34 <lilac> in c++ it's rather elegant isn't it? "template <int MaxArity> ..."
05:18:48 <Jafet> lilac, that's, erm, the interface.
05:19:01 <Alpounet> en0th, you would have to provide "smart constructors"
05:19:02 <dibblego> @type (<^)
05:19:08 <Peaker> C++ types can be parameterized on ints, not just types.  But not on non-int values, right?
05:19:18 <Peaker> Or perhaps only builtins?
05:19:32 <lilac> Peaker: only on builtins (including pointers)
05:19:37 <Jafet> Yes, but that brings us to ##c++, which we should pragmatically avoid
05:19:39 <Beelsebob> dibblego: Functor f => f a -> (a -> b) -> f b
05:19:49 <dibblego> Beelsebob, ta
05:19:56 <Beelsebob> dibblego: it's in infix applicative
05:20:03 <en0th> so, make my module export only the constructor interface, Alpounet?
05:20:04 <Beelsebob> (or just defined as flip fmap)
05:20:28 <Peaker> so, no-one knows how to use Language.C.Analyze?
05:20:43 <kbp> http://codepad.org/Dq6eX5Rv <-------- this function is to simplify boolean expression, but it doesn't understand "x" on line 6!? any idea?
05:20:54 <Peaker> I want to create a C parser that properly indexes C projects
05:20:54 <Alpounet> en0th, make your module hide the data constructors like End and Node, but expose smart constructors which would be functions of that module.
05:21:10 <Alpounet> guys, do you know of a little sample of Haskell code which covers most of the Haskell syntax ? It is for testing a syntax highlighting script. Thanks !
05:21:23 <lilac> kbp: right, there's no 'x' in scope there. == does not pattern match.
05:21:40 <maltem> en0th, ah you just meant providing an abstract data type for that purpose. that is of course possible
05:22:16 <lilac> kbp: you would probably have better luck if you write your simplify rules as: simplify (And x F) = F
05:22:20 <kbp> lilac: so that means I can't use | for each case, instead I have to write simplify (Or x T) = T and so on?
05:22:35 <lilac> kbp: right.
05:23:15 <kbp> lilac: thank you :) actually i tried to be lazy, but can't be now :D
05:23:22 <lilac> kbp: there's a GHC extension called PatternGuards which would allow you to write | And x F <- exp = ..., but you can't then say "| And x F <- exp || And F x <- exp" so you'd need to write the rules out separately anyway
05:23:57 <en0th> maltem, yes, let's say i need a square matrix in  my functions. How would i force a programmer to supply only a square one?
05:24:17 <Peaker> lilac, that seems like inlining
05:24:31 <lilac> kbp: also your recursive calls in the And x y and Or x y case are incorrectly parenthesized
05:24:49 <lilac> kbp: instead of (And simplify(x) simplify(y)), write And (simplify x) (simplify y)
05:25:14 <kbp> lilac: oh I see :)
05:25:19 <Alpounet> en0th, just as with the nary trees
05:25:31 <ski> kbp : you could write `simplify exp = case exp of Not F -> T; Not T -> F; And x T -> x; ...'
05:25:34 <Alpounet> keep the developer from creating values directly with the value constructor.
05:26:06 <Alpounet> OR, make two differents ADTs for non-square matrix & square matrixe
05:26:09 <Alpounet> matrix*
05:26:33 <en0th> ok
05:26:57 <kbp> ski: nice :) let me hoogle the case statement :)  not sure how to use it though
05:26:59 <en0th> thanks everybody. this channel has been more useful than any book, so far.
05:27:12 <ski> kbp : typically you could indent like
05:27:18 <ski>   simplify exp = case exp of
05:27:21 <ski>     Not F -> T
05:27:22 <ski>     ...
05:27:23 <Alpounet> en0th, the best is to have both, actually, IMO :-)
05:28:12 <en0th> :)
05:28:14 <ski> (kbp : and instead of ending with `otherwise', use `_')
05:28:51 <kbp> ski: thank you :) yea I'm trying the "case exp of" now
05:29:05 <ski> kbp : btw, are you sure you don't want to comtinue simplifying `x' in the `And x T' case ?
05:29:36 <lilac> kbp: partial examples: http://codepad.org/00vdJrsL
05:29:46 <kbp> ski: well spot :D didn't think about that case :)
05:29:58 <ski> also, the `x == y' and `x /= y' checks might be better to do on the simplified versions of `x' and `y'
05:30:21 <pozic> Baughn: but no standard says what you says.
05:30:29 <ski> (it should be `/=', not `!=', in haskell)
05:31:11 * lilac ponders how to write this nicely
05:31:41 <lilac> simplify (And (simplify -> x) (simplify -> y)) | F <- x = F | F <- y = y | otherwise = And x y
05:31:43 <kbp> *new to haskell :)*
05:33:50 <lilac> i can't think of a clean, terse way of writing this 'simplify' correctly in haskell'98 ;-)
05:34:12 <tim_> hey all - i was wondering if you wouldn't mind giving a haskell beginner a bit of help?
05:34:35 <ski> ask away
05:34:39 <tim_> i'm working my was through SICP trying to implement some of the exercises in haskell instead of scheme
05:34:56 <tim_> and one of them is a program to approximate tehe square root of a number
05:34:57 <Baughn> pozic: No documentation, either
05:35:02 <tim_> this is what i've got so far:
05:35:04 <tim_> http://gist.github.com/195396
05:35:17 <Baughn> pozic: unsafePerformIO is a funny function that way
05:35:23 <kbp> lilac: how to convert  | (Xor x y) && (x==y) = F to the line of "case of" ?
05:35:33 <tim_> but i get a "unification would give infinite type" error on this line:  guess otherwise sqrtIter ((guess + x / guess) / 2.0) guess x
05:35:43 <ski> tim_ : replace `x/2' with `(x/2)'
05:35:52 <lilac> kbp: "Xor x y | x == y ->"
05:35:57 <tim_> aah thanks
05:36:16 <kbp> lilac: I see :) thanks
05:36:18 <tim_> hmm - still not happy
05:36:38 <ski> tim_ : replace `otherwise' with `| otherwise ='
05:36:45 <tim_> aha
05:37:05 <tim_> oh cool
05:37:12 <tim_> thanks, yep just a syntax thing
05:38:24 <ski> if you define `sqrtIter' locally, you can avoid passing around `x' to it
05:38:49 <ski> the ` == True' is needless
05:38:54 <ski> , True == Tre
05:38:55 <lunabot>  luna: Not in scope: data constructor `Tre'
05:38:56 <ski> , True == True
05:38:57 <lunabot>  True
05:39:10 <ski> , (2 + 3 == 5) == True
05:39:11 <lunabot>  True
05:39:31 <tim_> aah thanks yep,good point
05:39:45 <ski> finally the brackets in `(x / guess)' is not needed
05:39:57 <tim_> aah yep again, operator precedence
05:40:05 <ski> (and you can replace `2.0' with `2', if you prefer)
05:40:09 <tim_> do you have an example of local function definitions?
05:40:27 <tim_> is it as simple as let foo = \ x -> something-or-other
05:40:43 <tim_> \\ rather than /
05:40:51 <ski> `let' works as well, i was thinking of `where'
05:40:57 <tim_> aah yes
05:41:09 * ski tries to come up with a simple enough example
05:41:19 <tim_> i think i've come across 'where' before
05:41:20 <tim_> will google
05:41:21 <tim_> !
05:41:26 <tim_> thanks for your help
05:41:26 <ski> basically like
05:41:38 <Peaker> I think "Occurs check" are the hardest type errors to debug
05:41:39 <ski>   foo x y = bar x
05:41:41 <ski>     where
05:41:50 <ski>     bar 0 = 0
05:41:57 <tim_> aah yes
05:42:02 <ski>     bar n = n*y + bar (n-1)
05:42:23 <ski> here `bar' grabs `y' "out of the air"
05:43:40 <Beelsebob> http://dizzythinks.net/2009/09/funny-because-its-true.html
05:44:19 <wferi> Hi! cabal install text says: Building text-0.4... and bails out as:
05:44:20 <wferi> Data/Text/Encoding/Error.hs:87:9:
05:44:20 <wferi>     Type constructor `Exception' used as a class
05:44:20 <wferi>     In the instance declaration for `Exception UnicodeException'
05:44:43 <wferi> I guess it's an outdated dependency in text's cabal file.
05:44:54 <wferi> Which other package should I install beforehand?
05:46:03 <tim_> hmm - can i use a 'where' clause with guards?
05:46:03 <tim_> as in
05:46:06 <dcoutts> wferi: you'll need to modify the package's .cabal file, or workaround it using --preference='base >= 4'
05:46:11 <wferi> Or is text-0.4 incompatible with GHC-6.8 (khm)
05:46:25 <tim_> http://gist.github.com/195396
05:46:27 <dcoutts> wferi: oh, yes, it needs base 4.
05:46:30 <tim_> (updated)
05:46:33 <wferi> Too bad...
05:47:14 <dcoutts> tim_: where clauses do not have guards, functions defined in where clauses are just ordinary function definitions and as such can have guards.
05:47:30 <tim_> ok cool
05:47:30 <ski> tim_ : you can do that, but you don't really need to nest them there
05:47:36 <tim_> aaah i see
05:47:42 <tim_> i'm getting a syntax error
05:47:45 <ski> also, you need to indent the `|' more than the equation they are attaching to
05:47:48 <wferi> dcoutts: thanks anyway. I can live without it, but was I wrong the expect cabal handle this situation gracefully?
05:47:50 <tim_> presumably whtesace related
05:47:53 <tim_> aah yes
05:47:54 <ski> (that's the syntax error)
05:48:03 <ski>   sqrt' x = ...
05:48:04 <ski>     where
05:48:06 <wferi> s/the/to/
05:48:11 <ski>     sqrtIter ...
05:48:15 <ski>     | ...
05:48:15 <dcoutts> wferi: it should handle it gracefully, however the deps in the text.cabal file are wrong, so cabal cannot do the right thing.
05:48:18 <ski> er
05:48:19 <ski>       | ...
05:48:29 <ski>     goodEnough ...
05:48:30 <gio12345> ski: pm :)
05:48:37 <wferi> ok, thanks
05:49:52 <dcoutts> wferi: looking at the text.cabal it looks like it is supposed to work with 6.8, but clearly it was not tested.
05:49:58 <lilac> kbp: here's how i might do it (note that i've used two language extensions: ViewPatterns and PatternGuards): http://codepad.org/yEq7jEh5
05:50:16 <dcoutts> wferi: report it to bos
05:50:17 <wferi> It may have fallen victim of the exception changes, as it looks.
05:50:27 <wferi> what is bos?
05:50:33 <dcoutts> who
05:50:41 <dcoutts> @seen bos
05:50:47 <benmachine> preflex: seen box
05:50:47 <preflex>  Sorry, I haven't seen box
05:50:49 <wferi> got it.
05:50:49 <benmachine> er
05:50:50 <dcoutts> doh, no lambdabot
05:50:50 <benmachine> preflex: seen bos
05:50:51 <preflex>  bos was last seen on #haskell 9 hours, 13 minutes and 50 seconds ago, saying: fnord123: they're not.
05:51:01 <benmachine> dcoutts: lambdabot isn't seeing these days anyway
05:51:11 <dcoutts> oh, that's a shame
05:51:22 <benmachine> there was some bug in the plugin
05:51:25 <benmachine> so it got disabled
05:51:31 <kbp> lilac: codepad gives error on line 2
05:51:40 <dcoutts> oh that old one, still not fixed
05:51:44 <Alpounet> preflex: seen edwardk
05:51:45 <preflex>  edwardk was last seen on #haskell 3 days, 11 hours, 10 minutes and 18 seconds ago, saying: ddarius: i've been getting a lot of mileage out of iteratee-based monoidal tokenization and then doing the rest of parsing once i've bracketed out short segments of tokens involving balanced parens or known layout.
05:51:53 <wferi> Should I mail him?
05:52:04 <dcoutts> benmachine: it's a bit sad, we identified the source of the bug about a year ago
05:56:05 <lilac> kbp: right, codepad doesn't have the relevant extensions turned on :) also i didn't define the isConst function
05:56:51 <Peaker> data Blah = Blah !!Int String -- what is a double-! ?
05:57:32 <dibblego> super strict?
05:57:42 <dolio> Haddock oddity.
05:57:44 <ski> double-plus unstrict
05:58:18 <kbp> lilac: I just copied and pasted to my code and it gives same error: doesnt know what -> is :(
05:58:52 <ski> "note that i've used two language extensions: ViewPatterns and PatternGuards"
05:58:53 <Peaker> heh
05:59:44 <ski> try adding `{-# LANGUAGE ViewPatterns,PatternGuards #-}' to the top of the module file
06:00:26 <Peaker> damn if Language.C had show instances... :(
06:00:33 <Peaker> (it would be so much easier to work with)
06:04:55 <Alpounet> co-strictness
06:05:16 <en0th> in The Typeclassopedia, i read: " ( (,) e ) represents a container wich holds an annotation of type e". Whaat?
06:06:27 <en0th> isn't (,) a tuple?
06:07:12 <doserj> en0th: yes
06:07:44 * sw17ch notes that Judy's bindings use an MVar around the foreign ptr, rejoices
06:07:52 <int-e> (,) is a binary type constructor.
06:07:55 <Alpounet> you annotate the second part of the tuple with something of type e
06:08:06 <Alpounet> (seen from a value point of view)
06:08:24 <int-e> ("annotation", "value")
06:08:52 <en0th> so, if i fmap a tuple what happens?
06:09:00 <ski> , fmap (+1) (2,3)
06:09:01 <lunabot>  (2,4)
06:09:08 <int-e> the annotation is preserved
06:09:59 <en0th> , fmap (+1) ("W",3)
06:10:00 <lunabot>  ("W",4)
06:10:53 <en0th> thanks. now i should read fmap implementation for tuple.
06:10:56 <lilac> , (fmap.fmap.fmap) (*3) ("Annotation 1", ("Annotation 2", ("Annotation 3", 14)))
06:10:58 <lunabot>  ("Annotation 1",("Annotation 2",("Annotation 3",42)))
06:11:32 <en0th> this is impressive.
06:11:37 <lilac> , src (fmap :: (a -> b) -> (c,a) -> (c,b))
06:11:38 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
06:11:42 <lilac> hmm
06:11:51 <lilac> , src '(fmap :: (a -> b) -> (c,a) -> (c,b))
06:11:52 <lunabot>  luna: parse error on input `fmap'
06:13:03 <en0th> it's like " instance Functor (t,) where .. " i guess
06:13:53 <lilac> en0th: sadly (t,) is not valid syntax. you have to write ((,) t) instead
06:14:18 <en0th> ok
06:15:10 <Alpounet> as with (->)
06:15:41 <lilac> a recent GHC extension allows (a,) in value expressions but i don't know whether it's allowed in type expressions
06:16:11 <lilac> ,src 'src
06:16:14 <lunabot>  src :: Name -> Doc
06:16:51 <lilac> (where 'recent' is i think GHC 6.11/6.12)
06:17:04 <ivanm> lilac: yup
06:17:58 <ivanm> WE CAN HAZ LAMBDABOT BAK? KTHNX BYE
06:18:31 <burp> instance Functor ((,) a) where fmap f (a,b) = (a,f b)
06:18:58 <lysgaard> maltem: It's a threadpool worker framework. It says it was made for experimenting with DHT, strange, because there's no sign of dhts in haskell exept one blog post.
06:19:10 <Alpounet> ivanm, he's trapd in ze Bug mownad :(
06:19:22 <ivanm> Alpounet: s/he's/she's/
06:20:05 <Alpounet> oh, never looked, sorry :-)
06:21:27 * en0th is entering the 'lifted' world..
06:27:09 <en0th> what should I import to get access to Pointed type class?
06:27:28 <Peaker> @index Pointed
06:28:42 <maltem> en0th, it's not in any standard package, I don't think
06:29:04 <maltem> ,hoogle Pointed
06:29:05 <lunabot>  luna: Not in scope: `hoogle'
06:29:09 <en0th> here it says it's in the category-extras library
06:29:35 <maltem> well then
06:29:49 <maltem> yes it's listed there in hayoo
06:35:12 <Alpounet> is anyone aware of some haskell snippet useful and complete for testing syntax highlighting stuffs ?
06:39:02 <xenoblitz> dcoutts or anyone who programs with gtk2hs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9917#a9917 any idea what is wrong here?
06:40:14 <dcoutts> xenoblitz: you're connecting to the expose event but for some reason you're expecting a move event
06:40:54 <dcoutts> xenoblitz: you're using the old untyped interface, the new typed interface prevents you from making such mistakes.
06:40:57 <xenoblitz> I was hoping to capture the mouse's xy on the canvas and print "test" as it moves
06:41:09 <dcoutts> xenoblitz: don't import the Graphics.UI.Gtk.Gdk.Events, use the new api
06:41:23 <xenoblitz> dcoutts: sorry am making use of the tutorial online :/
06:41:32 <dcoutts> xenoblitz: then why are you connecting to onExpose if what you want is a move even?
06:41:35 <dcoutts> event
06:41:49 <xenoblitz> dcoutts: following yet more online help
06:41:55 <xenoblitz> ok so which is best I use?
06:42:35 <dcoutts> xenoblitz: if you want mouse move events then use the onXXX for that kind of event, see the docs.
06:43:51 <xenoblitz> dcoutts: ok which are the modules I should avoid?
06:44:07 <dcoutts> xenoblitz: the default set you get is fine
06:44:24 <Taejo> hayoo++
06:44:42 <dcoutts> xenoblitz: it's ok to use the old Graphics.UI.Gtk.Gdk.Events if you really want to, but there's a new version that you get by default and that's a bit safer
06:44:47 <xenoblitz> dcoutts: ok I guess hoogle still finds the old ones... I'll search via the api directly ;)
06:47:02 <dcoutts> xenoblitz: see the docs for motionNotifyEvent
06:51:46 <Peaker> What Maybe Functor instance could violation composition law without violating fmap id law?
06:51:54 <Peaker> violate, that is
06:52:33 <lola1990> voila le 1er site de tchat rencontre gratuit sexe +18 ... au monde sur  ( www.casafilm.tk  )
06:52:39 <lilac> Peaker: fmap f Nothing = Nothing; fmap f (Just x) = Just (unsafeCoerce x)
06:52:50 <lola1990> voila le 1er site de tchat rencontre gratuit sexe +18 ... au monde sur  ( www.casafilm.tk  )
06:52:52 <ski> no evil, please !
06:53:09 <lilac> of those three lines i'm surprised it was mine you objected to! :)
06:53:10 <Botje> grr.
06:53:19 <en0th> (i'm reading it too, Peaker :) )
06:53:29 <ski> lilac : actually i was objecting to all of them :)
06:53:47 <lilac> unsafeCoerce: as unwelcome as spam in #haskell :)
06:54:15 <lola1990> voila le 1er site de tchat rencontre gratuit sexe +18 ... au monde sur  ( www.sexe.su.ma  )
06:54:38 <lilac> @where ops
06:54:41 <lilac> @where lambdabot
06:54:49 <Peaker> lilac, cool, thanks :)
06:55:00 <Botje> sigh.
06:58:58 <linopolus> Wie mach ich in der Bash per echo n newline? in der zsh funktioniert das wunderbar mit \n aber wie in bash?
06:59:49 <Lycurgus> versuchen sie vieleicht "man bash"?
07:00:10 <Axman6> german?
07:00:15 <ski> ja
07:00:31 <doserj> echo -e "\n"
07:00:34 <Makoryu> > 4 * 10 ** 27 :: Integer
07:00:36 * Axman6 belives that #haskell(.|-)de might be more appropriate
07:00:50 <ski> or maybe #bash
07:00:55 <Makoryu> Whoops
07:01:36 <Lycurgus> dot
07:02:23 <doserj> Makoryu: No instance for (Floating Integer). Possible fix: use (^) instead of (**).
07:02:50 <Makoryu> doserj: Yeah, realized that after trying it in my local prompt :p
07:03:05 <Axman6> doserj: are JaffaCake and SPJ your parents or what? :P
07:03:21 <maltem> doserj, heh, that's how "possible fix" should really read
07:03:34 <Makoryu> The illustrious Peyton `Simon` Jones....
07:11:15 <ivanm> :o I found a case where hlint didn't turn catMaybes . map to mapMaybe! :o
07:24:19 <Taejo> when was Applicative discovered?
07:25:30 <ski> wasn't it Conor McBride who talked about them (calling them "idioms") ?
07:25:42 <Beelsebob> Taejo: the paper is 08
07:25:43 <Beelsebob> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
07:25:47 <ski> (maybe someone else did it concurrently, i don't recall)
07:25:57 <Taejo> Beelsebob: thanks
07:26:35 <Taejo> I guess it's not surprising that so many Monads still lack Applicative instances, then
07:29:52 <ivanm> dcoutts: you still around?
07:30:03 <dcoutts> ivanm: mm
07:30:17 <ivanm> dcoutts: where's the documentation on the Paths_ module located? google is failing me :o
07:30:49 <dcoutts> ivanm: if there is any it'll be in the cabal user guide
07:34:15 <ivanm> This seems to be the only mention of it: http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html :(
07:35:14 <dcoutts> ivanm: what else do you want?
07:35:30 <ivanm> what else I can get from there, e.g. the program name, etc.
07:35:42 <dcoutts> ivanm: you can take a look :-)
07:35:51 <dcoutts> ivanm: you can get the program version, you're assumed to know the name
07:36:08 <ivanm> gah, looked in the wrong sub-directory of dist :s
07:36:42 <ivanm> yeah, it would just be nice not to have to hard-code it
07:36:51 <ivanm> (even though I've had to hard-code it for the Paths_ module :s)
07:37:40 <dcoutts> ivanm: heh heh
07:37:53 <dcoutts> ivanm: though technically that's the package name, not the program name
07:38:11 <ivanm> true
07:38:20 <dcoutts> ivanm: which is all you'd get, how would we provide all the names of all the programs?
07:38:45 <dcoutts> we'd need a separate generated module per component
07:39:50 <ivanm> true
07:45:17 <saml> > hello world
07:45:54 <doserj> Not in scope: `hello'
07:46:18 <saml> > 1
07:46:30 <doserj> 1
07:46:40 <saml> > fix . fix $ id 2
07:46:56 <EvilTerran> , [$typ| fix . fix |]
07:46:58 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
07:47:01 <EvilTerran> , [$ty| fix . fix |]
07:47:04 <lunabot>  forall a . ((a -> a) -> a -> a) -> a
07:49:19 <pozic> Baughn: it's "documented" in the FFI, but it basically promises nothing.
07:49:49 <ivanm> is there a nicer way of writing this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9919#a9919
07:50:39 <Botje> a foldM of some sort?
07:51:00 <pozic> ivanm: foldM
07:51:14 <ivanm> duh
07:51:22 <ivanm> thanks Botje and pozic
07:51:36 <hackagebot> hpage 0.2.0 - A scrapbook for Haskell developers (FernandoBenavides)
07:52:16 <lilac> saml: No instance for Num ((a -> a) -> (a -> a))
07:52:41 <saml> collaborative human bot posers
07:55:13 <ivanm> dammit, I think foldM folds the wrong way :s
07:55:27 <ivanm> that is, I want a foldr and foldM seems to be a foldl :s
07:55:34 <lilac> you mean your (>>) isn't associative? :)
07:55:39 <ivanm> heh
07:56:01 <ivanm> ahhhh, Data.Foldable has a foldrM
07:56:35 <pragma_> GIBBERISH
07:58:44 <ivanm> actually... now I'm confused... which type of fold do I want? :s
07:58:53 <lilac> ivanm: what are you trying to do? :)
07:59:13 <ivanm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9919#a9919
07:59:38 <Philonous> @hoogle cIntConv
07:59:46 <ski> exercise : find a(n interesting) use for `fix . fix'
08:00:00 <Philonous> @bot
08:00:01 <lunabot>  :o
08:00:09 <Philonous> ,hoogle cIntConv
08:00:12 <lunabot>  luna: Not in scope: `hoogle'
08:02:02 <lilac> , (fix.fix) (\f xs -> 1:zipWith (+) xs (f xs))
08:02:03 <lunabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
08:02:17 <ivanm> lilac: any pointers?
08:02:21 <ivanm> is it a foldM? :s
08:02:30 <lilac> , (fix.fix) (\f xs -> 1:zipWith (+) xs (f (tail xs)))
08:02:30 <doserj> , fix.fix $ ((1:).)
08:02:31 <lunabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:02:31 <lunabot>  [1,2,5,16,65,326,1957,13700,109601,986410,9864101,108505112,1302061345,16...
08:02:32 * ivanm always gets mixed up between left and right folds :s
08:02:35 <EvilTerran> ivanm, it looks to me like you should be able to use a vanilla foldM for that
08:02:47 <ivanm> thanks EvilTerran
08:03:05 <EvilTerran> ivanm, assuming MS.union has the usual properties of a union operation, anyway
08:03:24 <EvilTerran> , [$ty|foldM|]
08:03:27 <lunabot>  forall m b a . Monad m => (a -> b -> m a) -> a -> [] b -> m a
08:03:46 <ivanm> yeah, it's MultiSet.union
08:03:59 <ivanm> I'm more worried getting the order right, that's all
08:04:16 <lilac> @@ @oeis @run (fix.fix) (\f xs -> 1:zipWith (+) xs (f (tail xs)))
08:04:29 <lilac> A000522    Total number of arrangements of a set with n elements: a(n) = Sum_{k=0..n} n!/k!
08:04:36 <EvilTerran> the order of effects would be left-to-right along the list in the case of a standard foldM
08:05:44 <ski>   getExp (Do ss) = foldr (\s go_ss' -> do (d,c) <- getStmt s; cs <- go_ss'; return $ c `MS.union` defElsewhere cs d) (return MS.empty) ss  -- ivanm ?
08:07:18 <EvilTerran> ski, would that be the same as: foldM (\s cs -> do (d,c) <- getStmt s; return $ c `MS.union` defElsewhere cs d) MS.empty
08:07:19 <EvilTerran> ?
08:07:19 <ivanm> EvilTerran: so does the function get applied to the first element and the foldM of the rest of the list? or the first element with the base case?
08:07:35 <EvilTerran> ivanm, first element and base case, like a foldl
08:07:47 <EvilTerran> then result from that and second element
08:07:47 <ivanm> yeah, that's not what I want ;-)
08:07:48 <EvilTerran> etc
08:08:04 <ivanm> right, so I do want foldrM
08:10:28 <ski> EvilTerran : s/s cs/cs s/
08:11:01 <ski> (i don't know what `defElsewhere' does)
08:15:53 <Baughn> pozic: Turns out that the actual implementation of unsafePerformIO is a very useful thing to know about, however. Heads will fly if they change it.
08:25:23 <en0th> i'm struggling with this: why does " pure head " have a type different from " pure . head " ?
08:25:42 <Botje> pure . head = \x -> pure (head x)
08:26:35 <en0th> so, what is " pure head " supposed to do ?
08:26:50 <Botje> pure head has type f ([a] -> a)
08:26:57 <Botje> pure . head has type [a] -> f a
08:27:01 <lilac> "pure head" takes the 'head' function and puts it in an Applicative box
08:27:05 <Botje> (if i remember the type of pure correctly)
08:27:12 <Botje> :t pure
08:27:22 <lilac> pure :: Applicative f => a -> f a
08:28:02 <Botje> @lilacsnack
08:28:03 <en0th> oh now i see. So, that's why fmap g x = pure g <*> x
08:28:06 <lilac> :)
08:30:02 <en0th> anyway, this <*> thing (typing included) is very difficult.
08:30:46 <hackagebot> GenI 0.20 - A natural language generator (specifically, an FB-LTAG surface realiser) (EricKow)
08:31:45 <doserj> en0th: don't worry about <*>. Try to understand liftA2 first. then liftA3, and so on.
08:33:09 <en0th> are they defined in Applicative type class ?
08:33:25 <jmcarthur_work> they are in Control.Applicative
08:33:30 <jmcarthur_work> not in the type class though
08:33:34 <lilac> liftA2 f x y = f <$> x <*> y; liftA3 f x y z = f <$> x <*> y <*> z
08:33:59 <lilac> liftA2 :: Applicative f => (a -> b -> c) -> (f a -> f b -> f c)
08:34:06 <lilac> liftA3 :: Applicative f => (a -> b -> c -> d) -> (f a -> f b -> f c -> f d)
08:34:08 <jmcarthur_work> arguably, liftA2 should be in the type class and you should have the choice between defining (<*>) or liftA2
08:34:36 <en0th> omg. doserj, you told me to not worry about <*> !
08:34:49 <doserj> en0th: the liftA<n> functions are what Applicative is really about. <*> is just a means to implement all of them
08:34:51 <Philonous> en0th: You can think of (<*>) as zipWith ($) generalised for Apllicatives.
08:34:53 <jmcarthur_work> although i think that (<*>) is usually easier to define
08:35:29 <en0th> now it's more clear. Something like map and fmap i guess.
08:35:31 <doserj> en0th: so don't worry about how the liftA<n> functions are implemented, try to understand what they do.
08:36:14 <lilac> en0th: fmap is liftA1
08:36:35 <lilac> liftA1 :: Applicative f => (a -> b) -> (f a -> f b)
08:36:43 <en0th> oh. Is liftA2 something like fmap . fmap ?
08:36:57 <lilac> no. there's a critical difference between liftA<n> for n > 1 and liftA1
08:37:17 <lilac> liftA2 upwards produce a function which take two or more values 'in' the functor
08:37:32 <int-e> pure is liftA0 :)
08:37:36 <lilac> and they need to produce a single value 'in' the functor, so they need some way of combining the 'shape' of the functor
08:37:48 <doserj> int-e: indeed!
08:38:01 <int-e> (which is also not expressible with a Functor)
08:39:13 <en0th> this sounds like everything haskell is about.
08:40:28 <lilac> there is some depth here. working in a functor, or applicative, or monad, is basically mapping yourself to another 'category' with a richer semantics, while preserving basic laws of haskell functions etc.
08:44:15 <RayNbow> @hoogle csv
08:44:25 <RayNbow> hmm
08:44:27 <RayNbow> @botsmack
08:44:28 <lunabot>  :o
08:44:34 <RayNbow> oh, no lambdabot
08:55:44 <Berengal> I love static types
08:56:04 <FunctorSalad> STATIC CAT
08:56:15 <Berengal> IS CHECKED AT COMPILE TIME
08:56:37 <FunctorSalad> :)
08:57:11 <Cale> > 1
08:57:17 <Cale> hum
08:57:35 <Berengal> > :3
08:57:45 <int-e> , 42
08:57:46 <lunabot>  42
08:57:55 * int-e cheers
08:58:01 <sw17ch> i do not love c2hs and pointers 2 pointers
08:58:04 <Berengal> > text "\o/"
08:58:15 <lambdabot>   <no location info>:
08:58:27 <Berengal> > text "\\o/"
08:58:37 <lambdabot>   \o/
08:58:41 <Berengal> \o/
08:58:49 <Cale> actually...
08:59:14 <Cale> @quit
08:59:25 <jmcarthur_work> O_O
08:59:31 <Berengal> :(
08:59:34 <jmcarthur_work> NOOOOOOOOOOOO!
09:00:18 <FunctorSalad> @restart
09:00:21 <FunctorSalad> ;)
09:00:28 <Cale> I'm restarting it, hang on.
09:00:42 <Berengal> > text "\\o/"
09:00:45 <Rotaerk> bleh, I hate Real World Haskell
09:00:48 <lambdabot>   \o/
09:00:49 <Rotaerk> time to find something else to read
09:00:50 <Berengal> \o/
09:00:54 <Cale> Hmm, I got an error message about State/fact
09:01:02 <Cale> @where lyah
09:01:08 <lambdabot> www.learnyouahaskell.com
09:01:13 <Cale> well, it works anyway
09:01:15 <lilac> @seen lambdabot
09:01:17 <Rotaerk> learn you a haskell doesn't cover much
09:01:20 <FunctorSalad> Rotaerk: curious, why?
09:01:22 <lambdabot> Unknown command, try @list
09:01:28 <FunctorSalad> (me hasn't read it)
09:01:28 <Rotaerk> FunctorSalad, too much noise
09:01:31 <kakeman> learn you a haskell is nice
09:01:31 <lilac> @@ @vixen Welcome back!
09:01:31 <Cale> Rotaerk: Oh, that wasn't a real suggestion.
09:01:34 <Berengal> Rotaerk, I personally think the lord of the rings is pretty hood
09:01:36 <Rotaerk> I don't care to learn about how bar codes are encoded
09:01:36 <lambdabot>  what type of car do you drive?
09:01:41 <Cale> Rotaerk: I was testing the @where plugin :)
09:02:06 <Rotaerk> hmm brb
09:02:29 <en0th> what language has been used to implement haskell?
09:02:35 <Berengal> en0th, haskell
09:02:39 <int-e> several ;)
09:02:45 <FunctorSalad> Rotaerk: oh, yeah, like I said I haven't read it, but I don't like it either if the example noise is harder to understand than the thing itself ;)
09:02:51 <Berengal> (And C--, C, Perl... probably some assembly)
09:03:18 <pozic> Baughn: that will be a fun day. :D
09:03:55 <pozic> en0th: I heard there are about 50 intermediate languages ;)
09:04:02 <Cale> en0th: But yeah, the main Haskell compiler, GHC, is written primarily in Haskell.
09:04:03 <en0th> mm :(
09:04:38 <FunctorSalad> Rotaerk: sounds like you might want to read one of the mathsy introductions then?
09:04:48 <pozic> It's written in Simon Haskell, which is so complicated he is afraid to touch some components himself.
09:05:04 <int-e> hugs is mostly C. Is there any haskell compiler in one of the *ML languages?
09:05:08 <doublethink_work> some of the RTS is crazy (and awesome)
09:05:09 <Cale> pozic: heh, did he say something like that?
09:05:21 <en0th> i'd like to implement a small functional language for my thesis
09:05:44 <opqdonut> have you read "the implementation of functional programming languages"
09:05:47 <doublethink_work> and nothing can get into the RTS or be changed unless it passes the 'marlow barrier' as spj said, i.e. there can be no performance loss :)
09:05:56 <pozic> Cale: yes, he says that in one of the bug reports.
09:06:05 <pozic> Cale: but I made up this quote.
09:06:18 <en0th> i'm reading that.., opqdonut
09:06:20 <int-e> doublethink_work: unless it fixes a bug, clearly.
09:06:24 <opqdonut> en0th: oh, good :)
09:06:28 <doublethink_work> int-e: yes :)
09:06:44 <doublethink_work> should have quantified that with 'feature'
09:06:49 <int-e> :)
09:06:51 <en0th> i'd like to get more informations about implementing FP with imperative programming
09:07:16 <en0th> things that you don't learn at univ. (at least, mine doesnt teach it)
09:08:09 <pozic> en0th: FP, non-FP, it's all the same.
09:08:24 <int-e> does http://www.ioccc.org/1998/fanf.c qualify?
09:08:35 <Cale> en0th: That seems more painful than enlightening, at least for the frontend.
09:08:48 <opqdonut> iirc none of the algorithms in ifpl are exclusively functional
09:11:00 <pozic> Functional programming only restricts what you can do. The ST monad fixes this.
09:11:03 <en0th> i mean, i find myself very angry when i write for example a class in java, totally ignoring what happens under the hood
09:11:22 <Baughn> pozic: I should do a write-up on the implementation details, for the documentation. I've spent enough time figuring it out.
09:11:37 <pozic> en0th: programming is about abstractions. At some point you need to assume some things, otherwise there is no progress.
09:11:38 <Baughn> pozic: The way it reacts to exceptions is a wonder to behold
09:11:53 <pozic> Baughn: ah, yes. There is a way to catch undefined.
09:12:01 <pozic> Baughn: I used that evil hack once.
09:12:16 <Cale> The nice thing about hoods is that many equivalent things could be underneath them, and as long as it works the same, you don't have to care.
09:12:31 <Baughn> pozic: That was _not_ what I was referring to. Would you like to hear the [link=EldritchAbomination]details?[/link]
09:12:37 <naren> What is wrong with this function? pruneReflex = filter (\(a,(b,_)) -> a /= b)
09:12:47 <pozic> Baughn: of course.
09:12:50 <Cale> I usually prefer explanations which are idealistic lies ;)
09:13:03 <Baughn> @type filter (\(a,(b,_)) -> a /= b)
09:13:06 <lambdabot> forall t t1. (Eq t) => [(t, (t, t1))] -> [(t, (t, t1))]
09:13:18 <Cale> naren: Nothing outwardly wrong with that.
09:13:20 <Baughn> naren: Nothing? Looks fine to me.
09:13:28 <naren> it complains about monomorphism
09:13:33 <naren> don't know what that is
09:13:42 <pozic> naren: pruneReflex x = <what you had> x
09:13:59 <pozic> naren: or, enable a flag. man ghc / mono
09:14:12 <naren> how strange....why is that?
09:14:24 <pozic> naren: google has seen millions of newbies already.
09:14:29 <Cale> naren: ah, {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file will also turn it off
09:15:06 <naren> thanks
09:15:07 <Baughn> pozic: First, GHC implements evaluation via a (C) stack, /which is separate from the haskell one/ (I think). If forcing one thunk requires forcing another before the first can be finalized, then you get multiple stack frames; nest too deeply, and stack overflow hits.
09:15:15 <Cale> naren: It's a stupid typing restriction rule in Haskell 98: if you write a pattern binding without an explicit type signature, it's not allowed to be typeclass polymorphic
09:15:46 <en0th> Baughn, this is the kind of information i'm looking for!
09:15:56 <Cale> Baughn: It's the only Haskell stack I know. :)
09:15:56 <Baughn> pozic: When one thunk happens to be an unsafePerformIO-produced thunk, it inserts a special marker in the stack, then starts executing the IO code in deeper stack frames
09:16:16 <naren> Cale: gotcha.
09:16:55 <Baughn> pozic: If the code completes correctly, that's fine. If the code produces an error, or throws an exception, then the exception is stored in the unsafePerformIO thunk itself before being thrown past the unsafePerformIO stack frame, and future attempts to evaluate it immediately throw that exception.
09:17:06 <Makoryu> Baughn: Talking about eldritch abominations? In *my* #haskell?
09:17:15 <Makoryu> It's more likely than you think.
09:17:18 <Cale> naren: The rationale for this is that pattern bindings look like they define constants, so you'd expect them to be evaluated at most once, but typeclass polymorphism secretly turns them into functions of the typeclass dictionary.
09:17:54 <Cale> naren: I guess some people were afraid that people would be surprised by their programs' performance. I don't think it's something which belongs in the standard.
09:18:05 <Baughn> pozic: When the thread running it catches an /asynchronous/ exception, then it gets interesting. An async exception (regardless of origin; feel free to throwTo myThreadId) causes the runtime to copy the stack wholesale, from the top down to the unsafePerformIO marker, into a heap value allocated for the purpose.
09:18:41 <Baughn> pozic: If the thunk in question is then later re-entered in another thread (or the same one), it'll resume the execution from where it stalled.
09:18:52 <naren> Cale: That is pretty cool
09:19:40 <en0th> Baughn: where can I read details about that??
09:19:43 <Baughn> Cale: A question. Normally, multiple evaluation of thunks is only probabilistically prevented, which is fine with pure functions - IIRC there's a race condition in the evaluator
09:19:47 <Baughn> en0th: Here.
09:19:56 <Baughn> Cale: ..is this also the case for unsafePerformIO thunks?
09:20:00 <int-e> Baughn: right, in the parallel RTS
09:20:15 <pozic> Baughn: an article about that would be quite interesting to read.
09:20:22 <int-e> Baughn: and there's code in unsafePerformIO that prevents this. unsafeDupablePerformIO doesn't have that code.
09:20:28 <Baughn> int-e: Gotcha
09:20:38 <Baughn> So that's what it's for. How expensive is the code in question?
09:20:47 <int-e> it's taking a lock
09:20:57 <Baughn> Just the usual, then.
09:22:11 <Cale> en0th: If you want to understand how Haskell code is compiled into imperative low-level code, one place to start would be the STG machine paper... let me get you a link
09:22:45 <en0th> wonderful, thanks!
09:23:01 <Cale> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
09:23:14 <Cale> I believe that's it. My connection is being flaky.
09:23:47 <en0th> got it ^^
09:23:51 <Cale> Should be something like "Implementing lazy functional languages on stock hardware"
09:24:02 <Baughn> en0th: Pretty sure that doesn't explain unsafePerformIO, but it's a great help in general
09:24:23 <Baughn> It's very hard to imagine programming in haskell (or any language, really) /without/ understanding how it's compiled, at least in theory
09:24:57 <Cale> Baughn: I think it's really mostly irrelevant, myself.
09:25:10 <Cale> I just imagine everything in terms of graph reduction.
09:25:34 <Baughn> Cale: It's kind of important to avoiding stack overflows, though
09:25:54 <Cale> Baughn: Stack overflows occur when the outermost redex is too deep.
09:26:05 <Baughn> Although I suppose you could see that with the graph reduction view too, but.. that's because that's what the compiled code /does/, basically
09:26:10 <Cale> You don't really need to care about the fact that there's a real stack.
09:26:15 <en0th> do you think that it would be feasible to extract a subset of a language like haskell?
09:26:25 <lilac> en0th: what sort of subset?
09:26:26 <Baughn> en0th: Sure. Haskell'98 would be such a subset. :P
09:27:02 <en0th> i mean even smaller, for educational purpose, obviously
09:27:13 <Baughn> Doable
09:27:21 <Baughn> You could rip out type-classes, for example
09:27:28 <Makoryu> en0th: A lot of the "complexity" that makes Haskell daunting is just libraries, rather than something built into the language.
09:27:29 <burp> ow
09:27:45 <burp> rip out the heart of haskell? ;)
09:27:46 <Baughn> Makoryu: The other half is the type system
09:28:17 <Makoryu> Baughn: Yeah but the type system could be presented in a much friendlier way. Non-otherworldly GHC error messages would help ;)
09:28:19 <Baughn> That humongous, delicious, ghastly, convenient type system
09:28:43 <int-e> The syntax sugar is quite bad, too, for beginners (I still remember being mightily confused by what @ does).
09:28:49 <Baughn> Makoryu: To be fair, it does pretty well if you don't turn on any extensions
09:28:52 <lilac> en0th: you might be interested in Helium
09:28:54 <en0th> i'm wondering about chopping some syntax sugar, indeed.
09:28:56 <Baughn> Makoryu: (Assuming you already understand the language)
09:29:08 <Baughn> Makoryu: However, a no-type-classes subset could do a lot better for error messages
09:29:13 <FunctorSalad> en0th: ghc already does this doesn't it? ;)
09:29:34 <FunctorSalad> btw, is core purely functional?
09:29:37 <Baughn> Makoryu: ..ugh. I wouldn't want to use it, though. I think base haskell is already clean enough to be good for learning.
09:29:38 <Cale> en0th: The core Haskell language used in GHC comes close.
09:29:54 <Makoryu> Baughn: ...And then you'd have to go the ML way of implementing different versions of operators for different math types (eg. +, +., +: ...)
09:30:12 <en0th> i smell it's gonna be hard for me.
09:30:26 <lilac> FunctorSalad: i don't think so, no... ST has to expand to /something/ in core :)
09:30:51 <FunctorSalad> lilac: I wondered because it does seem to thread around a RealWorld
09:31:11 <Cale> en0th: Basically, the things which you'll want to keep are: algebraic datatypes, let, case, and the basic lambda calculus stuff.
09:31:13 <lilac> FunctorSalad: this is why I picked ST rather than IO as my example ;-)
09:31:23 <Baughn> Makoryu: Not if you only have one numeric type, Decimal
09:31:29 <Cale> en0th: Maybe some primitive types as well.
09:31:34 <namor> Is hackage.haskell.org down or is it just my computer?
09:31:34 <Makoryu> Baughn: Hmmm.
09:31:35 <Cale> en0th: But that's not essential.
09:31:54 <lilac> Cale: i personally would ditch let (keep where), ditch case (keep pattern matching in function arguments), ditch if (keep guards) ... ;-)
09:32:15 <Saizan_> namor: works here
09:32:31 <en0th> how much overhead do type classes bring?
09:32:36 <Makoryu> lilac: Yeah, if/then/else is redundant
09:32:38 <en0th> for implementation..
09:32:50 <namor> Saizan_, ok, thanks. Router reboot..
09:32:56 <Makoryu> en0th: For implementation, not that much. For learning..... eheh.
09:32:57 <Cale> lilac: let and case have the advantage that they are expression forms
09:33:43 <fnord123> curious. i thought the haskell platform was to be a rolling releaste but
09:33:48 <Makoryu> lilac: Function patterns and "where" blocks are syntactic sugar for Core's case/let
09:34:06 <en0th> isn't "if" a normal function?
09:34:15 <Cale> en0th: No, but it could be.
09:34:20 <Makoryu> en0th: You could write "if" as a function
09:34:27 <lilac> Makoryu: sure. but if we're ditching one or the other, my personal preferences would be as i stated
09:34:33 <Vanadium> But then you need more parentheses :(
09:34:34 <fnord123> rolling release, but http://trac.haskell.org/haskell-platform/wiki/AddingPackages suggests it's going on releases
09:34:39 <Cale> en0th: It's syntax sugar so that the 'then' and 'else' work
09:34:48 <Makoryu> lilac: Yeah, I rarely find myself using let
09:35:13 <mightybyte> Makoryu: Same here, except in do notation.
09:35:20 <Cale> if foo then bar else quux ~~> case foo of True -> bar; False -> quux
09:35:22 <en0th> ok
09:35:34 <lilac> Cale: i don't find 'let' and 'case' useful in practice. they seem like ugly 'brute force' mechanisms to do what you can do more naturally in other ways. this is partly /because/ they're expression forms.
09:35:44 <Makoryu> Cale: Or... case () of () | foo -> bar; otherwise -> quux
09:35:45 <Makoryu> ;)
09:35:46 <Cale> lilac: interesting
09:35:48 <Vanadium> I still wish case could be used in a point-free way :(
09:36:00 <lilac> let and case both seem too focussed on how i'm doing something rather than what i'm doing
09:36:10 <Cale> lilac: I don't see it that way.
09:36:14 <Makoryu> Oh whoops, I forgot a |
09:36:16 <en0th> i don't like " <- " in case
09:36:52 <Makoryu> en0th: Well, (<-) is a GHC extension...
09:37:01 <Cale> en0th: <- ?
09:37:25 <lilac> Cale: my other argument against them is that code which uses them doesn't lay out beautifully
09:37:35 * Cale was unaware that <- had any role to play in the syntax of case.
09:37:44 <Cale> lilac: it doesn't?
09:37:44 <Peaker> Vanadium, that's why we have folds for each ADT :)
09:37:47 <lilac> (which is incidentally also a reason i dislike if/then/else)
09:37:52 <Cale> lilac:
09:37:54 <Cale> if foo
09:37:57 <Cale>    then bar
09:37:59 <Cale>    else quux
09:38:06 <int-e> " -> "
09:38:09 <lilac> Cale: right, look at that weird indentation
09:38:16 <Baughn> ..looks nice enough to me
09:38:19 <Cale> lilac: That's the standard indentation.
09:38:29 <lilac> exactly, and it's not beautiful
09:38:30 <Philippa_> lilac: "more naturally" is a matter of taste :-) Certainly if you prefer the equational form, you're better off with where and local pattern-match functions
09:38:31 <Makoryu> lilac: I do use case a lot, because it's often easier to read than function patterns
09:38:41 <int-e> (and there's a Haskell' proposal that allows you to line up 'then' and 'else' with the 'if' even in do blocks)
09:38:52 <Cale> lilac: 'then' and 'else' are part of the 'if', so they are indented more than it, and they are siblings, so they are indented the same amount
09:38:53 <Baughn> lilac: http://github.com/Baughn/Reactant/blob/master/FRP/Reactant/Time.hshttp://github.com/Baughn/Reactant/blob/master/FRP/Reactant/Time.hs <- How would you avoid the case in the wait function here? (Line 185)
09:39:02 <Philippa_> but if I'm writing constraint-generating code I end up using case-within-do a lot, for example
09:39:15 <lilac> Cale: logically, yes. but that's independent of beauty i think :)
09:39:17 <Makoryu> Baughn: Whoops, repo offline
09:39:33 <int-e> http://github.com/Baughn/Reactant/blob/master/FRP/Reactant/Time.hs
09:39:37 <int-e> he double-pasted
09:39:44 <Philippa_> lilac: let and case are /very/ nice if you're trying to write fairly intentionally low-level code - it's all a matter of what kind of reasoning you want to prioritise
09:39:46 <Baughn> ..whoops
09:39:48 <Makoryu> int-e: Oh, d'oh
09:40:16 <lilac> Philippa_: yeah. they /are/ nice for that. but as a corollary, code which uses them feels (to me) low level.
09:40:56 <Baughn> en0th: http://github.com/Baughn/Reactant/blob/master/FRP/Reactant/Time.hs <-- If you want an example of advanced use of unsafePerformIO, here's one for your enjoyment.
09:41:00 <Makoryu> Baughn: Really, any case expression can be rewritten as a local function
09:41:00 <lilac> Baughn: Page does not exist!
09:41:04 <Cale> lilac: how would you prefer to lay out an if expression?
09:41:16 <lilac> Cale: i don't use if expressions.
09:41:20 <Baughn> lilac: I double-pasted. See one of the last two links
09:41:21 <Cale> lilac: only guards?
09:41:21 <lilac> (well, almost never)
09:41:27 <Baughn> Makoryu: Well, I suppose..
09:41:28 <lilac> Baughn: that doesn't work either ;-)
09:41:44 <Baughn> lilac: I assure you, http://github.com/Baughn/Reactant/blob/master/FRP/Reactant/Time.hs loads fine
09:41:45 <lilac> Cale: right
09:41:57 <Cale> lilac: Do you introduce new definitions artificially in order to make use of guards?
09:42:10 <en0th> thanks, Baughn. Bookmarked
09:42:13 <lilac> Baughn: it loads fine to a page which says "Page does not exist!"
09:42:58 <lilac> Cale: occasionally. but usually i find a nicer way of writing the code which gives somewhere natural to put the guard or removes the need for it
09:43:45 <lilac> Baughn: perhaps i need to be logged into github for that link to work?
09:44:00 <Baughn> lilac: That should not be required
09:44:06 <Baughn> lilac: Try force-reloading/
09:44:08 <Baughn> ?
09:44:30 <lilac> Baughn: well, even github.com/Baughn doesn't exist apparently
09:44:52 <lilac> hah, nor does http://github.com/ :)
09:45:22 <Philippa> *nod*. Sometimes you're writing code that's meant to be low-level with regard to some set of semantics, though
09:45:25 <Philippa> and sometimes the pattern-match is the right emphasis
09:45:31 <Philippa> (I'm probably missing 3 minutes' chat, btw)
09:46:02 <Baughn> lilac: A pity. The entire wait function is an eyesore, really; I'd have appreciated hints.
09:46:07 <Baughn> Oh, I know..
09:46:10 <lilac> Baughn: well, hpaste?
09:46:18 <Baughn> yeah
09:46:28 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9922#a9922
09:46:51 <pao> hi all
09:46:57 <lilac> Baughn: you lost me at line 34 ;-)
09:48:02 <pao> I need a space efficient readonly association-list, the main operation would be sequential access... what would be the best candidate?
09:48:43 <Baughn> lilac: unsafePerformIO is /too long/. :P
09:48:52 <opqdonut> pao: [(a,b)] or Array Int (a,b)
09:48:58 <Baughn> lilac: (Also, doing that is a great way to tell people there's SRS BSNS ahead)
09:49:09 <pao> opqdonut: thank
09:49:10 <wdonnelly> it's only used once every 40 lines! that's practically never :P
09:49:15 <opqdonut> maybe UArray (unboxed) if you want to be really space efficient
09:50:16 <pao> @hoogle UArray
09:50:17 <lambdabot> Data.Array.Unboxed data UArray i e
09:50:17 <lambdabot> Data.Array.IO castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
09:50:17 <lambdabot> Data.Array.IO.Internals castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
09:50:34 <Makoryu> Hay guise wanna make an HTML-based widget toolkit rendered by Webkit?
09:50:46 <Makoryu> FOR USE IN DESKTOP APPS?
09:50:47 <Makoryu> :D
09:51:06 <Baughn> Hmm.. No.
09:51:30 <lilac> Baughn: i think the first step in removing that case is changing the return type from IO (Either a a) to IO (Bool, a)
09:52:28 <Baughn> lilac: Definitely. I've seen horror, and its name is Either.
09:52:43 <opqdonut> :D
09:53:03 <lilac> Baughn: it was the two uses, one of which was 'either id id' and the other was 'either id something' which tipped me off :)
09:53:25 <int-e> Baughn: does the flipping serve any purpose? you could just pass (\r -> act it1 r it2) to 'call'.
09:53:41 <int-e> oh.
09:53:54 <int-e> you want to know which one completed, I guess.
09:54:03 <Baughn> Indeed
09:54:21 <Baughn> int-e: The wait function also does way too much..
09:54:32 <int-e> so return a FirstComplete | SecondComplete | BothComplete
09:54:42 <lilac> Baughn: the (True,False) and (False,True) case have unexploited symmetry too
09:54:55 <int-e> instead of the bool and the either.
09:55:37 <int-e> "return" meaning calling 'act'
09:55:51 * int-e wonders
09:56:20 <int-e> Ok, I misunderstood what it does.
09:56:56 <int-e> but why does act get one bit of information and the caller a different one?
09:57:21 <int-e> if you gave act all the information, it could decide what to do with it when it returns to the caller.
09:57:32 <pao> opqdonut: what about uvector for my use case?
09:57:43 <FunctorSalad> lilac: but ST is impure in Haskell too?
09:58:04 <FunctorSalad> (impure on the inside, but pure on the outside :))
09:58:05 <Baughn> int-e: At the time I was writing it, I didn't see that connection
09:58:18 <Baughn> They needed slightly different information, and it wasn't obvious that one could feed the other
10:00:59 <nomeata> dons or anyone else knowledgable about the X11 bindings: It seems that fetchName returns None for windows with unicode characters
10:01:31 <nomeata> I traced it to alloca $ \p -> xFetchName dpy 0x02a0001c p  >> peek p returning a zero pointer
10:02:16 <nomeata> So is this a problem with the fetchName C call, or is something wrong with the X11 bindings here?
10:05:14 <nomeata> ah, known problem: http://www.haskell.org/pipermail/xmonad/2007-July/001363.html
10:07:03 <lilac> FunctorSalad: ST is semantically pure in haskell; a pure implementation is conceivable apart from the likely need to unsafeCoerce at strategic places ;-)
10:08:04 <FunctorSalad> lilac: that's what I meant "on the outside"... but the point is that this is not an instance of core making internally pure code impure
10:09:39 <lilac> FunctorSalad: no, but it /is/ an instance of core not being pure itself
10:09:57 <lilac> that is, there are primops in core which can be called directly which are not pure
10:10:17 <lilac> (at least, as far as I understand how it works...)
10:11:57 <Cale> lilac: I actually wonder if there isn't a clever way to use all the GADT and other fancy type machinery now to avoid unsafeCoerce in a pure implementation of ST.
10:13:17 <Cale> Probably if we could do it, then Oleg would just come along and show us how it could have been done in Haskell 98 ;)
10:13:37 <lilac> it's easy to do if you're happy to restrict STRefs to Typeable types
10:13:38 <ddarius> Cale: I'm pretty sure it cannot be done with the same interface.
10:13:40 <EvilTerran> Cale, i was just thinking the same thing
10:14:24 <Cale> ddarius: Yeah, it's at least not obvious how to do it.
10:14:43 <ddarius> Cale: I think it is provably impossible.
10:14:44 <Cale> ddarius: But there's so much fancy machinery now that it's hard to tell what is and isn't possible to do.
10:14:58 <EvilTerran> i've previously considered used an indexed state monad with hlist state
10:15:28 <Cale> (I'm talking about GHC with all the extensions turned on)
10:15:34 <EvilTerran> but you could construct an ST action that uses an infinite number of types of references (with polymorphic recursion, say)
10:15:50 <Cale> (I'm pretty sure it's provably impossible in Haskell 98 too)
10:15:58 <lilac> EvilTerran: it can't use an infinite number of types at runtime :)
10:16:23 <Cale> lilac: But it can use an arbitrarily large number of types based on user input.
10:16:49 <lilac> that doesn't preclude a solution which uses resources linear in the number of actual types used
10:16:51 <EvilTerran> lilac, ok then, "can use any prefix of a certain infinite sequence of types" :P
10:16:57 <opdolio> If you can write a safe Dynamic, you can write a safe ST, more or less.
10:17:07 <lilac> well, you /can/ write a safe Dynamic
10:17:11 <opdolio> Although not with the same performance characteristics.
10:17:12 <ddarius> I'm saying I believe the types of the operations make it impossible unless some extension completely brutalizes properties like parametricity.
10:17:31 * lilac has an implementation idea
10:18:03 <EvilTerran> lilac, the problem was that i intended to use an HList where each cell was, say, a Map Int Foo, and there was an HList cell for each type of reference used in the ST action
10:18:22 <EvilTerran> lilac, it'd've involved some very scary types-as-data activity, probably with overlapping and undecidable instances]
10:18:34 <fergie> Is there any sort of workaround for the dynamic library "can't load .so/.DLL" error?
10:18:39 <opdolio> You can write a safe closed Dynamic in GHC. But not an open one.
10:18:41 <lilac> EvilTerran: i'm thinking of something similar
10:18:45 <fergie> Can't get gitit to work with plugins
10:18:58 <Cale> fergie: That sounds like you have a broken installation of some package maybe?
10:19:00 <opdolio> Of course, implementing ST that way adds Typeable a as a constraint to everything, too.
10:19:34 <lilac> opdolio: right, it's easy to do if you're happy to restrict STRefs to Typeable types
10:19:38 <fergie> Don't think so. Everything seems to work fine unless I tell gitit to load a plugin
10:20:11 <Cale> fergie: ah, is that the complete error message?
10:20:28 <fergie> Cale: how would I find out which package is broken?
10:20:57 <fergie> Cale: complete message is "gitit: <command line>: can't load .so/.DLL for: pcre (/usr/lib64/libpcre.so: invalid ELF header)"
10:21:08 <Cale> oh, that's more informative :)
10:21:27 <mmorrow> awesome, the version of Lava for generating vhdl for fpgas recently got uploaded to hackage http://hackage.haskell.org/package/york-lava
10:21:39 <Cale> It's saying that it doesn't like your 64-bit version of the perl compatible regex library.
10:21:59 <fergie> Cale: sorry
10:22:10 <fergie> Cale: so how do I fix that?
10:22:48 <Peaker> etags doesn't seem to support Haskell :(  What does?
10:22:49 <fergie> Cale: reinstall perl regex?
10:23:04 <Cale> You might just try reinstalling libpcre to start with. 'invalid ELF header' is a strange message to get there, though I have almost no experience with 64 bit architectures.
10:23:25 <Cale> That sounds as if the .so file is just broken to me.
10:23:52 <Cale> Before that, it would be interesting to see the output of:  file /usr/lib64/libpcre.so
10:24:37 <fergie> Cale: /usr/lib64/libpcre.so: ASCII C program text
10:25:08 <Cale> fergie: yes, that's *really* broken then.
10:25:30 <fergie> Cale: I'll try a reinstall
10:25:36 <Cale> fergie: You might cat it and have a look. It's supposed to be a binary file.
10:26:14 <absentia>  /win shirnk 3
10:26:48 <Vanadium> Cale: Maybe it is a GNU ld script
10:27:23 <FunctorSalad> @src cast
10:27:23 <lambdabot> Source not found.
10:27:35 <FunctorSalad> I think it uses unsafeCoerce too, just guarded by the typerep stuff
10:28:03 <fergie> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9923
10:28:15 <fergie> Cale: is the contents of the file
10:28:29 <Vanadium> Oh, gentoo
10:28:58 <fergie> Vanadium: I was young, stupid and had a lot of time
10:29:28 <Cale> fergie: okay, I've never seen anything like that, but I'll bet this bit of hackery is to blame for your problem.
10:29:49 <Vanadium> fergie: Same here
10:30:07 <fergie> Cale: Thanks. I'll try reinstalling perl regex or whatever its called
10:30:53 <Vanadium> I do not suppose you could somehow point whatever it is directly towards the file in /lib?
10:30:56 <sereven> fergie: might try #gentoo-haskell, they are ld scripts and yes, seems to confuse cabal periodically
10:31:18 <fergie> sereven: thanks. I'll have a look there
10:31:39 <fergie> Vanadium: it does seem to tell me where it should be going
10:38:09 <hackagebot> epoll 0.2.1 - epoll bindings (ToralfWittner)
10:55:03 <JME> hi there
10:55:46 <Cale> hello!
10:55:53 <tommd> @seen Cale
10:55:54 <lambdabot> Unknown command, try @list
10:56:04 <Cale> I am here
10:56:04 <tommd> Humm, who fixes lambdabot?
10:56:07 <Cale> me
10:56:11 <Cale> Well...
10:56:11 <tommd> I know, it was a test and a poke at you.
10:56:12 <tommd> ok.
10:56:18 <Cale> I keep it running.
10:56:30 <tommd> Lambdabot needs some lambdalobe.
10:56:32 <Cale> I don't really think of myself as a proper maintainer of the codebase.
10:56:33 <tommd> lambdalove.
10:56:42 <tommd> no one does.
10:57:12 <mmorrow> wasn't @seen removed since preflex does it better?
10:57:14 <dons> sw17ch: btw, imo you should never engage harrop in conversation. he trolls, and only lives off energy and input from others.
10:57:23 <mmorrow> preflex: mmorrow
10:57:27 <mmorrow> preflex: seen mmorrow
10:57:27 <preflex>  mmorrow was last seen on #haskell 4 seconds ago, saying: preflex: mmorrow
10:57:31 <dons> it fires him up to have people lambast his claims
10:57:32 <sw17ch> dons: is that who i replied to?
10:57:36 <dons> jdh, yes.
10:57:46 <sw17ch> dons: on reddit?
10:57:48 <tommd> Was it?  Its not a full solution as preflex isn't in every channel that lambdabot is in... or is it?
10:57:49 <dons> right.
10:57:57 <mmorrow> tommd: beats me
10:58:01 <sw17ch> dons: oh crap. i should have seen that.
10:58:13 <dons> he's difficult to deal with, since he will repeat garbage (like "O(N^2) hashtables") whether you call him on it or not.
10:58:18 <sw17ch> dons: usually i don't, but i've been looking for some sort of flying-frog crap
10:58:22 <dons> but if you don't feed him, he stays quiet
10:58:23 <mmorrow> tommd: you should fix it! ;)
10:58:24 <sw17ch> and jdh is now added to my filter
10:58:49 <sw17ch> dons: thanks for pointing this out, i hadn't even noticed he replied until now
10:59:43 <nomeata> Is there a difference with regard to locale handling in ghci and ghc?
10:59:49 <aavogt> @instances-importing Data.Map
10:59:49 <lambdabot> Couldn't find class `Data.Map'. Try @instances-importing
10:59:50 <Cale> dons: The more annoying thing is that even if you try to ignore jdh, he creates material which other people use to troll too.
10:59:54 <aavogt> @instances-importing M.Map
10:59:55 <lambdabot> Couldn't find class `M.Map'. Try @instances-importing
10:59:58 <dons> he's a strange unconstructive individual. he seems to produce noise, and nothing of value or substance. i've never encountered anyone as difficult and pointless to engage with as he is.
11:00:00 <nomeata> It seems my compiled code behaves as if LANG=C was in effect
11:00:04 <Cale> dons: Or just parrot unknowingly.
11:00:04 <aavogt> @instances-importing Data.Map.Map
11:00:05 <lambdabot> Couldn't find class `Data.Map.Map'. Try @instances-importing
11:00:23 * aavogt is looking for an Arbitrary instance of Map
11:00:25 <dons> Cale: right. i'm very careful just to build things, demonstrate them, and move on. never reference his material or links. never engage.
11:00:43 <lament> Fear of commitment.
11:01:06 <Rotaerk> <- has that
11:01:14 <sw17ch> Who does he have a bone to pick with, any way? Did some one make him fly off the deepend a long time ago?
11:01:18 <dons> lispm has a  good article on his technique of asserting bizarre claims as fact, to drive up trolling
11:02:09 <dons> sw17ch: it just seems to be how he operates. he  has no collaborators or partners, no one works on his projects, and he thrives on having enemies (he's got a personal feud with pretty much everyone of note in the FP world)
11:02:42 <dons> and if you counter his claims directly, he just goes ballistic
11:03:13 <dons> i really see him as a sad, lonely person, who has some serious social problems.
11:03:30 <sw17ch> who published his books? i've seen he's written a few...
11:03:41 <sw17ch> i could go look it up i suppose...
11:03:52 <dons> mostly self published. he's attacked wiley, who published his last one, for not advertising it, and stealing his money
11:04:18 <dons> but he doesn't see how being so self-destructive destroys his business model as a credible technical writer in FP.
11:04:39 <dons> so many layers of nonsensical strategy, it bogglesme.
11:04:43 <sw17ch> holy lord, 125GBP for a book?
11:04:53 <dons> oh, yeah, and that.
11:05:00 <dons> he's attacked o'reilly for undercharging.
11:05:21 <sw17ch> i can barely justify coughing up 40USD for a book...
11:05:37 * sw17ch does a quick pricecheck on RWH and prepares to backtrack
11:05:55 <sw17ch> dons: realworldhaskell.org appears to be down...
11:06:00 <dons> and that's all with less-than-zero credibility technically.
11:06:10 <dons> oh, prob. serpentine.com too then.
11:06:15 <dons> bos
11:06:36 <sw17ch> so, Don Syme at least proofread the Expensive# book
11:06:59 <dons> MS paid for one of them. They seem to have backed off dealing with him now though.
11:08:01 <sw17ch> well, ok
11:10:55 <blackstar> last night discussing in IRC, someone mentioned that Haskell doesn't provide support for Unicode, and its Hashtables are extremely slow, as such it is not very suitable for many real world applications. Could you help me understand how much truth is in that statement?
11:11:09 <Alpounet> dons, however, reading a Leroy VS Harrop battle on the Caml mailing list can be fun sometimes
11:11:33 <Rotaerk> jenkins?
11:12:17 <dons> blackstar: umm? haskell supports unicode out of the box, and there are high performance hashtables right here: http://hackage.haskell.org/package/judy-0.2.2
11:12:31 <periodic> Troll wars are amusing, but ultimately unfulfilling.
11:12:37 <dons> blackstar: so yep, that's entirely FUD. thanks.
11:13:01 <dons> unlike most FP languages, we have industrial support contracts, and an industrial users consortium, http://haskell.org/haskellwiki/Haskell_in_industry
11:13:14 <blackstar> dons: that actually makes me happy. I was worried, that those were true to some degrees.
11:13:57 <dons> its kind of ridiculously false, and takes 30s to google up evidence of why. this is computer science. rumours are stupid, benchmarks and code are facts.
11:14:00 <Vanadium> The standard IO functions are p. bad at unicode, aren't they?
11:14:16 <dons> GHC 6.12 ships with unicode-enables Handles
11:14:18 <Zao> New or old IO library?
11:14:19 <dons> locale-aware.
11:14:22 <Zao> 6.12 is awesome.
11:14:24 <Vanadium> oh, neat
11:14:31 <dons> there are packages on hackage for many years now for utf8 IO and more.
11:14:35 <Phyx-> 6.12 fixes my bug (hopefully)
11:14:35 <Phyx-> lol
11:15:00 <dons> how can we make this clearer?
11:15:23 <dons> blackstar: where was this conversation?
11:15:52 <monochrom> The only way to make this clearer is to teach the scientific method in K-12.
11:16:04 <Makoryu> Ah
11:16:09 <dons> adam peake wrote a good post on the lack of rigour and science in technical debate.
11:16:13 <Phyx-> what's K-12? middleschool?
11:16:14 <Makoryu> dons: That was in #proggit.
11:16:16 <dons> the internet noise fest.
11:16:36 <monochrom> K-12 means from kindergarten to US grade 12.
11:16:44 <Phyx-> ah ok
11:16:54 <blackstar> dons: at this point in time, I'm trying to decide between Haskell, Scala or Clojure. Next year I will open a startup that will do intelligence gathering / data mining on large dataset collected from the internet. I have that voice in my head that says "haskell, haskelll" but I'd like to justify it with something more solid that a "feeling". If me and my cofounders have to invest a year learning a language, we'd like to invest on the ri
11:16:54 <blackstar> one. We strongly believe in functional programming, and we strongly believe that the language choice makes a difference.
11:17:12 <Makoryu> blackstar: Did you stick around for slava's long rants about the rigors of unicode support in Factor?
11:17:13 <dons> blackstar: maybe have a look at Curt Sampson's experience report?
11:17:14 <babusrini> When you sum a list of Ints, if the value exceeds what can be stored in a Int, isn't an Integer used to store the results?
11:17:17 <Alpounet> btw, why won't we have a 6.11 ?
11:17:21 <dons> blackstar: or other reports from CUFP?
11:17:23 <gwern> blackstar: I understand that it's easier to go from haskell->scala than vice versa, so that's something to consider
11:17:42 <dons> blackstar: http://www.google.com/url?sa=t&source=web&ct=res&cd=4&url=http%3A%2F%2Fwww.starling-software.com%2Fmisc%2Ficfp-2009-cjs.pdf&ei=vv3ASsXxBIPWtgOy8Mwp&usg=AFQjCNEGX_47hxcy8TWbx1UkiL9QhgaZEg&sig2=c549JGU97N1w2SsKkkX3Gw
11:17:44 <dolio> Alpounet: Odd minors are development branches.
11:17:47 <dons> grr
11:18:03 <dons> blackstar: don't guess based on rumorus, read experience reports, construct prototypes.
11:18:08 <dolio> Alpounet: Like the Linux kernel.
11:18:15 <dons> here's an experience report on haskell for real time trading on the korean market, www.starling-software.com/misc/icfp-2009-cjs.pdf
11:18:17 <gwern> (suppose that's in part because haskell is more of a single-paradigm language, while scala has always seemed kind of a frankenstein fusion of java and haskell/scheme to me)
11:18:34 <absentia> yay!
11:18:36 <dons> blackstar: http://cufp.galois.com/ has reports in general from commerical users about various FP langs.
11:18:37 <blackstar> dons: thanks for the link, that's the approach I'd like to take
11:18:44 <absentia> it's not htat haskell comparison form like 1990 or 93.. :-)
11:18:46 <Makoryu> gwern: "Frankenstein" is exactly the word for it :p
11:19:05 <Alpounet> dolio, okay, thanks
11:19:10 <dons> blackstar: for a wide range of industrial experience in haskell, see the talks and abstracts here, http://haskell.org/haskellwiki/Haskell_in_industry
11:19:20 <gwern> Makoryu: my tip jar is thatta way! -->
11:19:26 <dons> many companies using haskell have written about its use, linked on that site.
11:19:56 * sw17ch is trying really hard to use Haskell @ work...
11:20:01 <lilac> dons: does this 'judy' package haf the same problem that arrays currently have (that is, the whole array being rescanned in the GC after an update)?
11:20:02 <sw17ch> it's a really hard sell
11:20:07 <lilac> *have
11:20:08 <camio> dons: Speaking of that, I've been wondering how I can contribute my Anygma experience [a recently passed haskell company] to the haskell community.
11:20:18 <dons> lilac: nope. see the detailed benchmarks.
11:20:21 <blackstar> dons: I will read the reports. Is there any limit or negative aspect to Haskell that I should be aware about?
11:20:23 <gwern> camio: is -cafe broken or something?
11:20:28 <gwern> just email or post an essay on the wiki
11:20:33 <gwern> it's not like we charge
11:20:34 <dons> camio: code, experience report at cufp?
11:21:03 <dons> blackstar: its a big complex language. it isn't suited for everything, but it seems to work in a wide range of scenarios.
11:21:13 <camio> Well, it was a failed company and I think the reasons for its failure are interesting (not haskell, but its application).
11:21:23 <mmorrow> lilac: an array only needs to be scanned ever if it's an array of pointers
11:21:29 <dons> compared to scala or clojure, it is extremely mature, and has wider commercial use, and open source libraries
11:21:30 <blackstar> dons: Datamining in Haskell... how does that sound?
11:21:34 <camio> gwern: Yes -cafe is broken. That's why I'm asking of course.
11:21:44 <dons> not sure... multicore might help?
11:22:07 <gwern> (I always feel so impatient when I see people like camio dithering; I think that's my wikipedia background, my instinct is to slap them with a {{sofixit}}, but of course no one here is familiar with that)
11:22:07 <absentia> sounds a little like :  Damned to Hell ...  if you're not laying attention
11:22:11 <lilac> mmorrow: true, but an array used for a general purpose hash table invariably contains pointers...
11:22:35 <dons> lilac: did you see the benchmarking?
11:22:41 <dons> i tried to compare it accurately against HashTable
11:22:42 <mmorrow> lilac: it looks like dons has a class (class ToWord a where toWord :: a -> Word; fromWord :: Word -> a)
11:23:03 <Makoryu> blackstar: If your programmers are only familiar with imperative languages, they'll have to learn to think in terms of functional programming. That's probably the biggest caveat.
11:23:04 <dons> lilac: http://donsbot.wordpress.com/2009/09/26/very-fast-scalable-mutable-maps-and-hashes-for-haskell/
11:23:05 <mmorrow> s/ToWord/the actual name/
11:23:31 <mightybyte> blackstar: laziness can present some obstacles that might not be expected, but there are usually ways around that.
11:23:34 <gwern> > (1 :: Float) + 1
11:23:35 <lambdabot>   2.0
11:23:38 <lilac> dons: no, for some reason my RSS reader marked that planet haskell entry as 'read' ;-/
11:23:41 <dons> ah
11:24:01 <Twey> dons: Elaborate on ‘isn't suited for everthing’?
11:24:21 <camio> gwern: It sounds like you've had a bad experience in the past, but you're really misreading(mis classing "people like", etc.) me.
11:24:39 <camio> I was thinking about doing an ebook or something like that.
11:24:45 <dons> Twey: its impure.
11:24:49 <blackstar> Makoryu: I think we have the basics down. We are now reading and enjoying Purely Functional Data Structures (the book).
11:24:51 <mmorrow> lilac: (and since the array lives in C, it can't contain haskell pointers anyway)
11:24:56 <dons> meaning it isn't as general purpose as a purely functional structure
11:25:16 <dons> gwern: yeah, take your issues elsewhere ...
11:25:21 <Twey> Sorry, are we talking about Haskell here?
11:25:22 <Makoryu> blackstar: All right, then the biggest hurdle is behind you :p
11:25:22 <camio> It seems like all the experience reports are very technical in nature, where the interesting part of the Anygma experience was more of a management style issue.
11:25:31 <hackagebot> arbtt 0.1.4 - Automatic Rule-Based Time Tracker (JoachimBreitner)
11:25:33 <babusrini> When you sum a list of Ints, if the value exceeds what can be stored in a Int, isn't an Integer used to store the results? So, how come I am getting a negative number (overflow) as the result? I have specify [Integer] -> Integer as the type to get the correct result.
11:25:36 <lilac> dons: how is the array GC problem avoided? could the same technique be used to fix the issue for Array (and hence HashTable)?
11:25:44 <dons> Twey: oh, sorry, i thought you were referring to the judy array post.
11:25:55 <gwern> camio: no, I mean, why were you even asking in the first place? how long could it possibly be? you have blogs, you have -cafe, you have hawiki, you have The Monad.Reader, you have CUFP. I'm really at a loss to explain how you could wonder how to contribute a report or essay
11:25:56 <Twey> No no.  Haskell in general.
11:25:59 <dons> lilac: it doesn't allocate a boxed array on the Haskell heap
11:25:59 <jmcarthur_work> oh did anygma go down?
11:26:02 <dons> it allocates on the C heap.
11:26:06 <Alpounet> blackstar, there are some datamining libraries out there on hackage
11:26:11 <Makoryu> > sum [0xffffff, 0xffffff]
11:26:12 <gwern> jmcarthur_work: so it seems!
11:26:12 <lambdabot>   33554430
11:26:12 <dons> lilac: and yes, that can be used to avoid having the GC scan a boxed array
11:26:16 <jmcarthur_work> :(
11:26:22 <Makoryu> > sum [0xf0ffffff, 0xffffff]
11:26:23 <lambdabot>   4060086270
11:26:24 <dons> lilac: also, you can just increase the heap size for a similar result
11:26:29 <Makoryu> Oh right, 64-bit
11:26:46 <Makoryu> > maxBound :: Int
11:26:47 <lambdabot>   9223372036854775807
11:27:09 <Makoryu> > maxBound :: Integer
11:27:10 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
11:27:10 <lambdabot>    arising...
11:27:14 <dolio> > showHex (maxBound :: Int) ""
11:27:14 <jmcarthur_work> camio, if it was management type stuff i think a blog post might be most appropriate
11:27:15 <lambdabot>   "7fffffffffffffff"
11:27:31 <camio> gwern: I know of several ways, none of which I find satisfying. I'm looking for the "best" way.
11:27:34 <gwern> camio: now, if you had said something like 'I have this beautiful latex-generated PDF about the Anygma experience, you think it should go to CUFP or TMR?' then I'd understand
11:27:35 <jmcarthur_work> camio, and you could link to it in -cafe, here, reddit, etc. if you wish
11:27:36 <mauke> babusrini: no, calculations with Ints always return an Int
11:27:40 <dons> its frustrating. you can build something great. benchmark it, publish it, and still people say 'you can't do that'
11:27:47 <Makoryu> babusrini: Anyway, try mapping toInteger before you sum
11:27:48 <blackstar> technical question
11:27:54 <monochrom> (how do I contribute to fixing -cafe?)
11:27:57 <jmcarthur_work> dons, ?
11:27:59 <gwern> mauke: really? :) 1/0 <-- look like ints to me
11:28:02 <Makoryu> babusrini: 'Cause Integer will never overflow
11:28:11 <mauke> gwern: can't be Ints
11:28:15 <blackstar> Haskell has arbitrary precision math right?
11:28:19 <mauke> / is for fractionals
11:28:19 <Twey> gwern: That's what *you* think…
11:28:22 <Makoryu> blackstar: Yep. The Integer type
11:28:24 <Twey> :t (/)
11:28:25 <lambdabot> forall a. (Fractional a) => a -> a -> a
11:28:32 <jmcarthur_work> Makoryu, Integer can overflow. it just takes a lot of work and memory
11:28:35 <gwern> bah!
11:28:46 <Twey> :þ
11:29:00 <Makoryu> blackstar: The primitives of the Integer type are an interface to GMP (which will be replaced by an equivalent library in 6.12, IIRC, for license reasons)
11:29:01 <Twey> :t div 1 0
11:29:03 <lambdabot> forall t. (Integral t) => t
11:29:10 <Twey> > div 1 0
11:29:11 <mightybyte> dons: Hah, jdh30 has -1571 comment karma on reddit.
11:29:12 <lambdabot>   * Exception: divide by zero
11:29:12 <babusrini> Makoryu, But print $ foldl' (+) 0 [3,5..4000000] returns 3999999999999
11:29:13 <gwern> jmcarthur_work: wait, how does that work? I thought Integer was supposed to crash your box or make the OOM kill your program before it'd do stuff like overflow
11:29:17 <blackstar> ok, then why do I get a stack overflow? sum $ [1,3..10000000] I tried the same code in Scala and Clojure and obtained the result, with no overflow.
11:29:21 <copumpkin> Makoryu: won't be replaced
11:29:31 <jmcarthur_work> gwern, "lots of memory" ;)
11:29:50 <copumpkin> Makoryu: the default will still be gmp, but there's a bsd-licensed pure haskell alternative if you need it (but it's slower, of course)
11:29:54 * gwern still doesn't get it
11:30:00 <Saizan_> jmcarthur_work: so it doesn't really overflow, it rather crashes your program
11:30:19 <dons> blackstar: compile it. :)
11:30:25 <Makoryu> blackstar: That's a strictness issue, rather than an arithmetic issue.
11:30:28 <jmcarthur_work> i just mean the algorithm used by Integer right now doesn't theoretically prevent overflow. that is, it would actually overflow if we had enough memory to hold the gigantic numbers necessary
11:30:29 <blackstar> gwern: I think we are experiencing the same problem
11:30:47 <jmcarthur_work> it's just that we do not have the memory for that to happen
11:30:50 <blackstar> dons: so it's an interpreter issue?
11:30:54 <Makoryu> blackstar: If you try that code in the REPL, it doesn't pass through the strictness analyzer
11:31:02 <dons> blackstar: the 'sum' function is funny. its a foldl -- so it relies on strictness analysis to convert into a tail recursive loop. that's a wart, but not harmful in practice (you don't use ghci for production math)
11:31:02 <dons> blackstar: right.
11:31:02 <Makoryu> blackstar: But if you compile it, it does.
11:31:03 <gwern> jmcarthur_work: oh. that's interesting. is there an explanation of that anywhere?
11:31:04 <sw17ch> dons: i think we emphasize purity rather than the ability of Haskell to make impurity safe
11:31:09 <dons> blackstar: try ghc -O2
11:31:13 <Saizan_> jmcarthur_work: really? there's a hard limit in gmp to the expandability of the integers?
11:31:15 <jmcarthur_work> gwern, i only "know" this from hearsay
11:31:16 <sw17ch> err, more than we should
11:31:24 <mmorrow> dons: what is this in response to? "its frustrating. you can build something great. benchmark it, publish it, and still people say 'you can't do that'"
11:31:32 <blackstar> dons: oh let me try, let's see if it's faster than Scala
11:31:40 <gwern> jmcarthur_work: well, don't feel bad. I only "know" of China from hearsay
11:31:42 <jmcarthur_work> so maybe i should have been qualifying everything with "i heard that ..."
11:31:56 <dons> blackstar: i wrote a library for very fast loops like this. stream-fusion
11:32:01 <jmcarthur_work> heh
11:32:06 <dons> should be == C for the same kind of code.
11:32:28 <dons> blackstar: cabal install this, http://hackage.haskell.org/package/stream-fusion
11:32:53 <dons> your sum [1...] will turn into a register-only loop, and i'd be surprised if that didn't beat scala's pants.
11:33:04 <monochrom> I wish I could convince dons to ignore unscientific frustrating people.
11:33:21 <blackstar> dons: how do I use it?
11:33:23 <dons> we tend to beat scala on the shootout anyway, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
11:33:23 <dons> monochrom: well, i don't engage with them at all.
11:33:40 <dons> cabal install stream-fusion, then instead of Data.List, use Data.List.STream
11:33:44 <dons> i'll give you an example.
11:33:53 <blackstar> dons: thanks
11:33:55 <Saizan_> babusrini: however, you should never see overflow if you're using Integer, but at the same time the compiler doesn't promote an Int to Integer automatically when it's going to overflow
11:33:56 <mmorrow> dons: sum [1..] turns into a register-only loop with the current ghc optims?
11:34:10 <mmorrow> dons: (talking about your stream fusion lib)
11:34:19 <dons> via streams.
11:34:23 <jmcarthur_work> you also have to make sure you are using nice combinators and stuff, not using explicit recursion and stuff
11:34:37 <mmorrow> dons: (i'm currently hacking with optims along these lines, but in a different direction)
11:34:38 <jmcarthur_work> but the former is better style than the latter anyway :)
11:36:05 <blackstar> dons: the plain version, Haskell is only slightly faster than Scala (0.65 vs 0.7s)
11:36:14 <dolio> sum [m..n] should fuse under foldr/build, too.
11:36:17 <dons> blackstar: http://www.galois.com/~dons/A.hs
11:36:28 <dons> blackstar: right. the fused version is what, ... 20x faster?
11:36:40 <dons> i get 0.6s for the list one, and 0.02 for the uvector one.
11:36:48 <mmorrow> dolio: it's a      foldl' (+) 0 (enumFromTo m n)      though
11:36:51 <dons> cabal install uvector
11:37:15 <dons> blackstar: make sense?
11:37:20 <dolio> enumFromTo has rewrite rules for Integer, I think.
11:37:37 <dons> that's one advantage over Scala -- aggressively optimizing compiler
11:37:43 <dcoutts> dolio: sum [m..n] does not fuse under foldr/build because sum is not a foldr
11:37:46 <mmorrow> dolio: cheating!
11:37:59 <mmorrow> :)
11:38:00 <blackstar> dons: fast, but I get the wrong result (a negative number)
11:38:03 <dolio> Oh right, duh.
11:38:08 <dons> oh, Int vs Integer?
11:38:16 <dons> you need more bits :)
11:38:24 <blackstar> dons: let me try
11:38:33 <copumpkin> Word64!
11:38:42 <copumpkin> except I remember seeing a ticket about the specific-sized values not being as optimized
11:38:50 <copumpkin> maybe they don't have as many rewrite rules or something?
11:39:05 <dons> import Data.Word
11:39:05 <dons> main = print (sumU (enumFromToU 3 (10000000 :: Word64)))
11:39:13 <dons> on a 32 bit machine, I suppose.
11:39:28 <dons> blackstar: it just illustrates a point: you have access to some pretty smart optimizations :)
11:40:37 <blackstar> dons: yes
11:40:53 <Alpounet> by the way, I'll try to introduce some little haskell apps in nuclear fusion -- not critical ones, don't worry :-p
11:41:01 <blackstar> dons: how do I modify to add odds number only (the version you graciously posted me adds all numbers in the range)
11:41:02 <dons> hehe.
11:41:14 <Berengal> Are there plans/rumors about plans of stack traces in GHC, or am I imagining things?
11:41:27 <jmcarthur_work> i don't suppose that foldl defined in terms of foldr gives you any advantages as far as fusion is concerned?
11:41:29 <dons> i should add enumFromToThen. but let's see...
11:41:53 <Berengal> Right now I'm debugging a parser, and it'd be nice to see just which path it takes
11:41:56 <Twey> Alpounet: I can't think of a much better language in which to do the critical ones
11:41:59 <Twey> Maybe Coq :þ
11:42:09 <lilac> how expensive is a StablePtr?
11:42:35 <Alpounet> Twey, they won't let me introduce Haskell for critical apps, but I'll introduce it actually to generate part of them, maybe
11:42:49 <Raynes> Shame.
11:42:51 <Alpounet> (I'm a trainee, my decision "power" is weak, there :-p)
11:42:56 <jmcarthur_work> what do they use for critical apps?
11:43:10 <dons> blackstar: main = print . sumU . filterU (\x -> x `rem` 2 == 1) $ (enumFromToU 1 (10000000 :: Word64))
11:43:19 <Alpounet> C++
11:43:23 <dons> $ time ./A
11:43:23 <dons> 25000000000000
11:43:23 <dons> ./A  0.10s user 0.00s system 101% cpu 0.099 total
11:43:26 <copumpkin> Berengal: yeah, there's even a paper on it, and I think it will be in 6.12
11:43:28 <jmcarthur_work> :(
11:43:32 <Makoryu> Alpounet: Seriously? :|
11:43:38 <dons> blackstar: but it'll be faster if I had enumFromToThen for you.
11:43:46 <Berengal> copumpkin, references?
11:43:50 <copumpkin> Alpounet: remind me to stay away from your nuclear reactor :P
11:43:59 <blackstar> dons: slower than Scala with filter
11:44:05 <copumpkin> Berengal: http://hackage.haskell.org/trac/ghc/wiki/ExplicitCallStack
11:44:18 <dons> oh, we do have it.
11:44:20 <Alpounet> yes, but not crap C++. Good one.
11:44:25 <Berengal> copumpkin, thanks
11:44:34 <copumpkin> Berengal: might not be in 6.12, not sure :)
11:44:47 <dons> blackstar: what was it without the filter?
11:44:54 * dons is intrigued at what Word64 on 32 bits is like.
11:45:10 <blackstar> dons: my processor is 64 bit
11:45:13 <Berengal> copumpkin, the parser is already quite ammenable to implementing frames yourself, but it feels a bit tedious...
11:45:24 <Berengal> Still... can't wait for 6.12
11:45:26 <Makoryu> blackstar: By the way, what OS are you on?
11:45:29 <copumpkin> yeah
11:45:40 <blackstar> dons: without filter, I got about 0.5ish seconds.
11:45:45 <dons> blackstar: but you have a 32 bit ghc?
11:45:49 <blackstar> Makoryu:  Mac
11:45:54 <dons> $ time ./A
11:45:54 <dons> 25000000000000
11:45:54 <dons> ./A  0.02s user 0.00s system 84% cpu 0.024 total
11:45:56 <blackstar> dons: oh right
11:46:09 <absentia> what killed anygma?
11:46:12 <Makoryu> blackstar: Ahh. My biggest complaint about GHC right now is that the Mac support is lagging behind
11:46:17 <blackstar> dons: what kind of hardware do you have? Cray?
11:46:17 <dons> blackstar: that sounds funny. that's nearly 20x slower than mine.
11:46:17 <dons> and more like what I was getting for lists.
11:46:26 <dons> $ time ./A
11:46:26 <dons> 25000000000000
11:46:26 <dons> ./A  0.02s user 0.00s system 84% cpu 0.024 total
11:46:27 <Alpounet> Makoryu, but I'm not aware of any library for playing with FPGA hardwares, for example, in Haskell -- it would be painful to write, considering the little amount of time we have.
11:46:30 <dons> blackstar: no, just a 64 bit core 2 duo.
11:46:35 <dons> are we running the same code?
11:46:39 <Makoryu> blackstar: If you deploy on Linux, it'll absolutely scream
11:46:41 <blackstar> dons: we are
11:46:42 <Makoryu> dons: He's on OS X
11:46:54 <dons> http://www.galois.com/~dons/A.hs ?
11:46:56 <Makoryu> dons: No 64 bit support, and some other issues
11:46:57 <blackstar> dons: Is GHC on Mac that slow?
11:47:02 <absentia> opencl links to haskell ?
11:47:08 <dons> well, you must be running in 32 bit mode
11:47:12 <dons> with Word64's being emulated?
11:47:18 * absentia holds down 4 and 8 during bootup to get a 48 bit kernel.
11:47:21 <Makoryu> dons: He's on a Mac. There's no 64 bit support.
11:47:27 <monochrom> Hahaha
11:47:27 <dons> right
11:47:31 <Makoryu> dons: There's not yet any 64 bit support in GHC on OS X.
11:47:35 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3055 is the ticket I was thinking about
11:47:43 <blackstar> dons: that new code gives me the wrong result
11:48:00 <dons> right, it should (32 bit ints)
11:48:06 <dons> but does it run in ~20ms or so?
11:48:11 <blackstar> dons: yes
11:48:12 <lilac> absentia: unlucky, today you get an 84-bit kernel
11:48:22 <dons> ok. good. so yes, the issue then is Word64 being emulated on your 32 bit ghc
11:48:28 <copumpkin> blackstar: 32-bit code has almost no registers to work with for tight loops
11:49:24 <blackstar> dons: I see. Will GHC be 64bit on OS X anytime soon?
11:49:29 <mmorrow> this speaks for itself (on how crucial figuring out the static control flow that's hiding in the high level code) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4219#a4219
11:50:12 <dons> yeah, next week or two.
11:50:13 <Makoryu> blackstar: A patch is on the way
11:50:13 * absentia uses ghc on osx
11:50:13 <dons> blackstar: feel free to play around with the uvector library (its used for some fast statistics and other things)
11:50:13 <blackstar> Makoryu: nice
11:50:13 <mmorrow> unfortunately, we're not there yet, but we could be!
11:50:13 <Makoryu> absentia: Me too :(
11:50:13 <dons> there's nothing like it in other languages, really.
11:50:30 <copumpkin> mmorrow: wow
11:50:31 <mmorrow> 153186 collections and 26seconds    vs.     0 collections and 2.6 seconds !
11:50:35 <blackstar> dons: what does it do in practice?
11:50:36 <copumpkin> mmorrow: have you tried that on stream-fusion?
11:50:53 <blackstar> dons: I mean, how does it achieve such speed?
11:51:02 <mmorrow> copumpkin: i will right now (happen to have the stream fusion List module right here)
11:51:24 <copumpkin> cool
11:52:03 <burp> doesn't the default haskell list implementation use stream fusion already?
11:52:09 <Augur_> Is Reactive the most up to date library for FRP?
11:52:10 <Makoryu> blackstar: It relies heavily on the purely functional Haskell semantics
11:52:14 <copumpkin> burp: sadly not
11:52:17 <Makoryu> burp: Not for all Prelude functions, no
11:52:18 <blackstar> Makoryu: ok
11:52:31 <copumpkin> burp: it doesn't use it at all, it uses something else called foldr/build fusion
11:52:40 <copumpkin> burp: which doesn't work on nearly as many operations
11:52:51 <blackstar> So is there a -Wall option that warns me when my program may give the wrong result due to the usage of integer instead of word64?
11:54:11 <copumpkin> why would integer give you a wrong result?
11:54:19 <mmorrow> burp: there're some optimizations that need to be done (to pursue this idea in general) that can't be done by only using inlining+beta-reduction+rewrite-rules
11:54:36 <Makoryu> copumpkin: It doesn't. 32-bit Ints were giving a wrong result.
11:55:33 <Makoryu> blackstar: There are two integer types in the Prelude (the standard library): The native one (Int) and the arbitrary precision one (Integer)
11:55:58 <burp> ok
11:56:21 <bob0> and (Word|Int)(8|16|32|64)
11:56:26 <blackstar> Makoryu: so I can used Integer instead of int?
11:56:31 <dolio> Heh, that reminds me, someone on c.l.haskell was arguing that functions using Integer are partial, because you can run out of memory, but the same functions using Int aren't (since they just wrap).
11:56:35 <Makoryu> blackstar: A warning like that would unfortunately run into the halting problem, but you can always play it safe by using Integer
11:56:37 <Makoryu> blackstar: Yep
11:56:44 <Makoryu> blackstar: Dunno how fast it'll be though.
11:57:08 <bob0> blackstar: Integer is only bould to your system memory.
11:57:47 <monochrom> Functions using Int are partial because you may burn out the chips.
11:58:15 <dolio> monochrom: Yeah. Or you might be 4/8 bytes away from memory exhaustion, and it might have to allocate.
11:58:27 <monochrom> I mean, people's opinions are awful.
11:59:09 <monochrom> Opinions should be banned. Only allow the scientific method. Publish or perish. Back up or shut up.
11:59:24 <blackstar> Is Integer, Word64 under the hood?
11:59:27 <monochrom> Call it Scientific Fundamentalistm.
11:59:37 <lament> because the probability of being published does not rely on anyone's opinions at all.
11:59:39 <mightybyte> blackstar: No, Integer is arbitrary precision.
11:59:48 <Makoryu> blackstar: No. Integer is the GMP library under the hood.
11:59:51 <mightybyte> blackstar: Word64 is a fixed 64 bits.
11:59:52 <{newbie}> Hi is there any road map for the ghc 6.12.1?
11:59:57 <blackstar> mightybyte: so slower, but safer.
12:00:03 <mightybyte> blackstar: Correct.
12:00:03 <Kagami`> monochrom: so why such functions such as `length' using Int?
12:00:10 <gwern> Kagami`: history
12:00:20 <gwern> also, how often do you run into lists which actually need Integer?
12:00:21 <Makoryu> Kagami`: That's... a good question. I actually almost asked that earlier.
12:00:23 <gweiqi> what is the special name for a choice-like function like "maybe" ?
12:00:29 <monochrom> I did not design length and I don't know why.
12:00:52 <mauke> catamorphism?
12:00:56 <gweiqi> yes, thanks
12:00:57 <Makoryu> Kagami`: I guess the idea is that you won't see a whole lot of lists that would take up more RAM than you actually have on your system
12:01:02 <blackstar> just finished watching a video with Simon Peyton Jones. How bloody awesome is he? Wow.
12:01:17 <gwern> I mean, if you're actually creating and consuming lists with lengths/indices up to Int's maxbound, you obviously have the chops to go hoogle for genericLength
12:01:24 <gwern> or you're just doing it wrong
12:01:59 <mightybyte> blackstar: Int is matched to your native word size.  The types in Data.Int and Data.Word are a suite of fixed-size types.
12:02:43 <Makoryu> > genericLength [0 .. 0xfffffffffffffffffffff]
12:02:44 <lambdabot>   * Exception: stack overflow
12:02:52 <Makoryu> :(
12:03:03 <dolio> genericLength is a foldr.
12:04:17 <nomeata> Hi. Is it expected that a C library that reads the current locale’s charset behaves differently in ghci and ghc? Do I have to initialize the locale in my haskell program somehow?
12:05:45 <mauke> possibly; man setlocale
12:05:46 <mije> is there a keyboard shortcut to eval expressions in debug, in leksah ?
12:06:07 <Makoryu> , (.length (range 0xffffffffffffffffffffffff))
12:06:09 <lunabot>  luna: Couldn't match expected type `a -> b'
12:06:13 <Makoryu> Whoops
12:06:24 <mauke> http://hackage.haskell.org/packages/archive/setlocale/0.0.3/doc/html/System-Locale-SetLocale.html
12:08:22 <mmorrow> copumpkin: hmm, i'm not sure what's going on. something is asploding and that prog with the Stream module (from dcoutts' repo) consumes all my memory, but if i put the definition for enumFromTo *in* the module with main it turns into a reg-only loop
12:08:36 <nomeata> mauke: ok, so I should call "setLocale LC_ALL (Just "")" at program start?
12:08:36 <copumpkin> mmorrow: weird
12:08:47 <copumpkin> mmorrow: maybe the same loop on uvector will work better?
12:08:58 <nomeata> I’m surprised that this is not default behaviour, and if it is not, that setLocal is not part of any standard library.
12:09:07 <dcoutts> mmorrow: sounds interesting
12:09:08 <mauke> nomeata: yes, if that's the problem
12:09:57 <mmorrow> copumpkin, dcoutts: this is the Stream module i'm using http://haskell.org/~duncan/list/
12:10:15 <mmorrow> (i uncommented the enumFromTo in Stream)
12:10:31 <mmorrow> and tried
12:10:32 <copumpkin> mmorrow: I thought there was a more recent one than that
12:10:33 <mmorrow> main = print (foldl' (+) 0 (enumFromTo (0::Int) 1000000000))
12:10:49 <nomeata> hmm, known problem: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-March/014493.html
12:10:49 <mmorrow> copumpkin: oh, i'm not sure. on hackage?
12:10:55 <copumpkin> yeah, just stream-fusion
12:11:05 <mmorrow> copumpkin: nice, /me gets
12:11:11 <copumpkin> also, http://www.cse.unsw.edu.au/~dons/streams.html
12:11:19 <gwern> > 2008 - 1965
12:11:20 <lambdabot>   43
12:12:17 <Rotaerk> > 1 + 2
12:12:18 <lambdabot>   3
12:12:19 <Rotaerk> WRONG
12:12:32 <nomeata> mauke: thx, it indeed fixes the problem.
12:12:50 <gwern> > 84 - 52
12:12:51 <lambdabot>   32
12:12:56 <gwern> > 52 / (84 - 52)
12:12:57 <lambdabot>   1.625
12:13:16 <mmorrow> copumpkin: ah, the difference between the foldl' in the one i've got and the one in dons' repo is a commented out !
12:13:23 * mmorrow tries with the bang
12:13:38 <mmorrow> err, actually the difference in two !'s
12:13:40 <copumpkin> needs moar bang for the buck
12:13:47 <hackagebot> arbtt 0.1.5 - Automatic Rule-Based Time Tracker (JoachimBreitner)
12:14:22 <mmorrow> err, actually there're other differences too
12:14:35 * mmorrow just gets that whole repo
12:16:46 <mightybyte> Is this type of "polymorphism" possible in Haskell?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9929#a9929
12:18:24 <allbery_b> there are ways to do that, but usually wanting that is a mistake
12:18:25 <Saizan_> with gadts you can do something similar
12:19:03 <mightybyte> allbery_b: How would I correct the mistake?
12:19:26 <Saizan_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9929#a9930
12:20:08 <dcoutts> mmorrow: I've updated that old repo
12:20:10 <allbery_b> the first step is to ask what you're really trying to do, at a high level
12:20:21 <dcoutts> mmorrow: but it's probably best to use the released hackage package
12:21:29 <mightybyte> allbery_b: Well, I have a data type like that that has three differently-parameterized instances of a type.
12:22:16 <mmorrow> dcoutts: ok, cool
12:22:19 <mightybyte> allbery_b: I was wanting to avoid duplicating code that manipulates these things
12:23:56 <mightybyte> allbery_b: I'm also receiving some input telling me which of the three to operate on.
12:25:35 <mightybyte> allbery_b: It seems a reasonable application of the pattern you see there.
12:26:10 <allbery_b> I'm not quite seeing it (this isn't necessarily your fault, for various reasons I'm having a bad brain day)
12:27:26 <mightybyte> The input selecting which element of Foo comes in as a string and I just use a derived Read instance to get a FooType
12:28:06 <mightybyte> Then I would pass the FooType to getFunc to get the correct function of Foo to Set a
12:28:23 <lilac> i'm writing a disassembler for a variable-width bytecode. what would be a nice interface for it? can i do better than ByteString -> [(StreamPos, Opcode)] where type StreamPos = Int?
12:30:26 <Augur_> Is the Reactive library complete enough to build actual systems with, or is it still a proof of concept?
12:31:38 <Peaker> Augur_, the latter, unfortunately
12:31:40 <Peaker> afaik, anyway
12:31:48 <Augur_> Nooooo :((((
12:32:02 <allbery_b> mightybyte: I'm thinking you want a typeclass but I'm backfiring on the details for what you want to do, sorry
12:32:59 <hackagebot> json-b 0.0.3 - JSON parser that uses byte strings. (JasonDusek)
12:33:11 <jorick> if i have two matrices (lists of lists), how do i multiply them by one another? wasn't there a fmap function to do that?
12:33:29 <copumpkin> jorick: not really, but it's not too painful
12:34:12 <copumpkin> unless you want it to be efficient :P
12:34:45 <Heffalump> the obvious implementation is fairly efficient, isn't it?
12:34:45 <Augur_> Are there any FRP libraries that work reliably?
12:35:03 <jorick> no it doesn't need to be efficient, i need it once to calculate something for a project i'm working on
12:35:07 <copumpkin> Heffalump: the short one I'm thinking of isn't particularly efficient, but if you have a better one I wouldn't mind seeing it
12:35:09 <mmorrow> Heffalump: some people can get pretty hardcore with making matrix mult efficient
12:35:21 <copumpkin> x * y = transpose (map (λ col → map (λ row → row ∙ col) x) (transpose y))
12:35:35 <copumpkin> where \cdot is dot product
12:35:55 <Heffalump> I hadn't really worked it out fully, but something directly recursive
12:36:01 <burp> use lapack ;)
12:36:07 <jorick> thanks!
12:36:15 <copumpkin> I used that for my agda implementation of matrices
12:36:28 <copumpkin> it's pretty obvious
12:36:35 <burp> http://hackage.haskell.org/packages/archive/hmatrix/0.5.2.2/doc/html/Numeric-LinearAlgebra-LAPACK.html#v%3AmultiplyR
12:36:42 <copumpkin> there's just hmatrix
12:36:45 <copumpkin> oh that is hmatrix
12:41:41 <lilac> > flip (map . flip (map . (sum .) . zipWith (*)) . transpose) [[1,0],[1,1]] [[1,2,3],[4,5,6]]
12:41:42 <lambdabot>   [[1,2,3],[5,7,9]]
12:42:13 <lilac> jorick: matrixMult = flip (map . flip (map . (sum .) . zipWith (*)) . transpose)
12:42:27 <copumpkin> is that more efficient than the one I wrote?
12:42:30 <Peaker> > flip (map . (sum .) . flip (map . zipWith (*)) . transpose) [[1,0],[1,1]] [[1,2,3],[4,5,6]]
12:42:30 <copumpkin> I only see one transpose
12:42:31 <Heffalump> http://pastebin.com/m44be331c was what I was thinking of
12:42:31 <lambdabot>   No instance for (GHC.Num.Num [a])
12:42:31 <lambdabot>    arising from a use of `Data.List.sum' ...
12:42:41 <Heffalump> it may well be no better than explicit transpose
12:42:49 <jorick> awesome, thanks
12:54:38 <jorick> there's no arccos in haskell?
12:54:47 <Botje> @hoogle cos
12:54:48 <lambdabot> Prelude cos :: Floating a => a -> a
12:54:48 <lambdabot> Prelude cosh :: Floating a => a -> a
12:54:48 <lambdabot> Prelude acos :: Floating a => a -> a
12:54:58 <jorick> :o) thanks
12:54:58 <Botje> jorick: acos looks like the correct one
12:55:06 <copumpkin> > acos 1
12:55:07 <lambdabot>   0.0
12:55:21 <mightybyte> That's what I call screaming fast customer service.
12:55:47 <Veinor> it's all 0.0
12:55:54 <Veinor> cause it's in shock that you'd need to compute the acos of 1 :P
12:56:11 <mightybyte> "#haskell: We can search the web faster than you" :P
12:56:48 <ari> Hi, what's the language extension name to enable parallel list comprehensions?
12:57:10 <Botje> ParallelListComp
12:57:16 <Botje> (man ghc lists all possible extensions)
12:57:21 <ari> Botje: ty
12:57:49 <copumpkin> man ghc is so awesome vs. man, ghc is so awesome
12:58:08 <lilac> ghc --supported-languages lists all the known extensions in a more compact and greppable fashion
13:12:13 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9931#a9931 <-- anyone got any thoughts on how i could improve this code?
13:12:40 * sw17ch started working on bindings for libgcrypt
13:12:52 <sw17ch> HsOpenSSL really frustrates me :\
13:13:43 <kosmic> http://www.haskell.org/haskellwiki/Blow_your_mind#Monad_magic
13:13:52 <kosmic> what exactly is that?
13:15:19 <lilac> kosmic: nice. i love the idiom "unfoldr (\b -> fmap (const (f b)) (listToMaybe b))
13:15:22 <copumpkin> kosmic: what?
13:15:34 <kosmic> well,i tried running a few of those
13:15:36 <kosmic> didnt know
13:15:38 <kosmic> work*
13:16:02 <lilac> > unfoldr (\b -> fmap (const . (second $ drop 1) . break (==' ') $ b) . listToMaybe $ b) "Hello world"
13:16:03 <copumpkin> >   fix ((1:) . (>>= \x -> [x+1, 1/(x+1)])) :: [Rational]
13:16:03 <lambdabot>   ["Hello","world"]
13:16:04 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
13:16:10 <copumpkin> that's pretty neat
13:16:22 <kosmic> what is it?
13:16:32 <copumpkin> all the positive rationals
13:16:59 <kosmic> see, i don't know what that is
13:17:11 <copumpkin> all positive fractions?
13:17:28 <kosmic> if you say so ;)
13:17:32 <copumpkin> 1/1, 2/1, 1/2, 3/1, 1/3, 3/2, etc.
13:17:40 <jmcarthur_work> rational numbers numbers expressible as fractions where the numerators and denominators are integers
13:17:50 <jmcarthur_work> *rational numbers are numbers
13:18:02 <kosmic> okay
13:18:19 <copumpkin> that doesn't have the epic kleisli composition in it
13:18:37 <kosmic> heh. you guys sound like mathematicians ;)
13:18:38 <copumpkin> > ((+) <=< (+)) 5 6
13:18:40 <lambdabot>   17
13:19:51 <kosmic> i guess i need a tutorial that teaches me what all those symbols in haskell do/mean
13:20:01 <burp> what symbols?
13:20:03 <jmcarthur_work> kosmic, we do tend to learn some math because it turns out to help a lot when describing abstractions
13:20:18 <burp> there are just functions :)
13:20:22 <kosmic> functions ;)
13:20:26 <copumpkin> :t (<=<)
13:20:27 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:20:35 <kosmic> hehe
13:20:37 <copumpkin> :t (.)
13:20:38 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:20:39 <jmcarthur_work> <=< is basically monadic composition
13:21:08 <jmcarthur_work> and =<< is basically like monadic application
13:21:20 <jmcarthur_work> where (.) and ($) are their nonmonadic counterparts
13:22:47 <lilac> :t (<=<) :: (b -> c -> d) -> (a -> c -> b) -> (a -> c -> d)
13:22:47 <lambdabot> forall b c d a. (b -> c -> d) -> (a -> c -> b) -> a -> c -> d
13:23:37 <copumpkin> zomg
13:23:40 <copumpkin> my secret is revealed!
13:23:41 <burp> has it just changed?
13:23:52 <copumpkin> has what just changed?
13:24:00 <burp> never mind
13:24:06 <copumpkin> m turned into (c ->)
13:24:32 <ski> @type (<=<)
13:24:33 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:25:07 <ski> copumpkin : is there a way to get the "levels" there in order ?
13:25:20 <copumpkin> levels?
13:25:26 <ski> (in Stern-Brocot)
13:25:33 * copumpkin blinks
13:25:44 <copumpkin> oh
13:25:56 <yakov> hello
13:25:58 <ski> > fix ((1:) . (>>= \x -> [x+1, 1/(x+1)])) :: [Rational]
13:26:00 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
13:26:07 <copumpkin> ski: not sure, I just found that snippet on that haskellwiki page
13:26:10 <lilac> > case listToMaybe [1,2,3] of Just {} -> True; Nothing {} -> False
13:26:11 <lambdabot>   True
13:26:16 <yakov> guys, I've came across epigram source http://www.e-pig.org/darcsweb?r=Pig09;a=headblob;f=/src/Prop.lhs    it uses import .. where syntax. what is it? :-)
13:26:16 <lilac> huh
13:26:22 <yakov> I could not find it in docs
13:26:37 <copumpkin> ski: I'd imagine so, if you expressed it in terms of one of those fancy categorical recursion schemes and switched functors :P
13:26:44 <yakov> e.g. import -> CanConstructors where
13:26:45 <ski> this gives a breadth-first traversal of a binary tree, generated from `1',`\x -> x+1',`\x -> 1/(x+1)'
13:26:48 * copumpkin spews out more bullsh*t
13:26:57 <lilac> yakov: i think it's a she thing
13:27:17 <Heffalump> epigram is already being rewritten with she?
13:27:19 <Heffalump> scary
13:27:34 <copumpkin> yep
13:27:57 <lilac> yakov: http://personal.cis.strath.ac.uk/~conor/pub/she/
13:27:58 <jmcarthur_work> she was made specifically to attack some abstractions int he epigram 2 source, iirc
13:27:58 <copumpkin> it's a pity he stopped updating the epilogue again
13:28:07 <jmcarthur_work> *in the
13:28:49 <ski> @where she
13:28:50 <lambdabot> I know nothing about she.
13:28:54 <yakov> thx
13:28:57 <copumpkin> @where SHE
13:28:58 <lambdabot> I know nothing about she.
13:28:58 <ski> @where+ she http://personal.cis.strath.ac.uk/~conor/pub/she/
13:28:58 <lambdabot> Good to know.
13:29:11 <copumpkin> @whereis she
13:29:12 <yakov> i've found what -pgmF means in GHC docs
13:29:12 <lambdabot> Maybe you meant: where where+
13:29:13 <copumpkin> aw
13:29:19 <copumpkin> yakov: it's a preprocessor
13:30:45 <opqdonut> heh, "divers functionality"
13:30:53 <opqdonut> i wonder what the divers do
13:31:07 <copumpkin> they diversify, obviously
13:34:11 <yakov> heh, i never though about haskell programing from such an angle :-) very fruitful way to write your own very special preporcessor ;-)
13:37:13 <Lycurgus> ah come on, stony silence in response to "preporcessor", that's not fair
13:38:24 <lysgaard> @seen tomMD
13:38:24 <lambdabot> Unknown command, try @list
13:38:29 <lysgaard> @list
13:38:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:39:13 <lysgaard> What is the command for looking up the last time a user was seen in the channel?
13:39:23 <aavogt> preflex: seen lysgaard
13:39:23 <preflex>  lysgaard was last seen on #haskell 10 seconds ago, saying: What is the command for looking up the last time a user was seen in the channel?
13:39:42 <aavogt> @seen is disabled
13:39:42 <lambdabot> Unknown command, try @list
13:40:04 <lysgaard> aavogt: So I have to "ask" preflex?
13:40:11 <lysgaard> preflex: seen tomMD
13:40:11 <preflex>  tomMD was last seen on #haskell 2 hours, 42 minutes and 22 seconds ago, saying: Was it?  Its not a full solution as preflex isn't in every channel that lambdabot is in... or is it?
13:40:36 <tommd1> lysgaard: Looking for me?
13:40:43 <yitz> preflex: seen preflex
13:40:43 <preflex>  what
13:41:07 <TomMD> lysgaard: Thats better!
13:41:21 <TomMD> preflex: seen TomMD
13:41:21 <preflex>  TomMD was last seen on #haskell 14 seconds ago, saying: lysgaard: Thats better!
13:41:42 <lysgaard> TomMD: Yeah! I was actually looking for you =)
13:42:04 <lysgaard> TomMD: You have some experience with DHTs in haskell don't you?
13:42:20 <TomMD> lysgaard: Yes, some.
13:42:24 <lysgaard> TomMD: I've been searching all over the internet and you seem to be the only one
13:42:27 * sw17ch listens to DHT conversation
13:42:37 <TomMD> I probably am - one of the reasons I started that library.
13:42:47 <yitz> dht?
13:43:03 <mauke> danger hardcore team
13:43:16 <TomMD> But I'm a moron and didn't decide on all the aspects of the protocol I wanted early enough, so I've wasted lots of time going from a Pastry join protocol to a Chord one and back.
13:43:17 <mauke> digital home theater
13:43:24 <TomMD> yitz: Distributed Hash Table
13:43:32 <lysgaard> TomMD: Well, bear with me, I'm a 19 years old, so I'm not that prominent in haskell etc, but I've learnt some.
13:43:56 <yitz> ah, nice. yeah mauke, i guess that's danger hardcore. :)
13:44:15 <lysgaard> TomMD: I've read the papers on Pastry and Chord, and implemented some sort of kademlia, who's a sort of pastry if I'm not tottaly mistaken?
13:45:19 <lysgaard> TomMD: But since I've just been doing haskell for under six months, I've run intoo a problem I can't solve efficiently.
13:45:34 <TomMD> lysgaard: I'm not familiar with Kademlia, I'll have to look at it.
13:46:08 <lysgaard> TomMD: It's the DHT used by bittorrent
13:46:12 <TomMD> ok
13:46:36 <TomMD> lysgaard: What type of issues?  Usually you can distill such issues to a general case and ask anyone in #haskell.
13:47:34 <lysgaard> TomMD: Well, anyways. I've been wondering. You know the Chord protocoll. Let's take the findSuccessor call. If the id you're looking for is between yours and your successor, the function should return the your successor. Right?
13:48:10 <TomMD> For leafset/finger table routing? Yep.
13:48:27 <lysgaard> TomMD: Yeah, the issue is _wery_ general, but I've never met anyone that could explain to me what to do, but you ougta know ;) You've made a working DHT
13:49:51 <lysgaard> TomMD: But let's say the id you're looking for is now betwenn your id and your successors. Then you send a RPC to the closesPrecedingNode ordering it to find it's successor of the id you're looking for.
13:50:12 <TomMD> lysgaard: 1) My class is starting so I'm going to have to go 2) I'd be glad to help, so do e-mail, or IRC @tell me something so I'll remember to get back to you 3) I don't yet understand your issue.
13:50:43 <lysgaard> TomMD: Ah, guess you're on the other side of the world then, I'll mail you ;)
13:50:52 <TomMD> ok :-)
13:57:22 <fergie> How do I make a module installed so that I can do "include Something.ModuleName" rather than "include ModuleName.hs"?
13:59:16 <mauke> there is no include
14:00:02 <fergie> mauke: sorry. I meant "import"
14:00:08 <_zenon_> :)
14:00:12 <jmcarthur_work> Ferdirand, put it in a directory called Something
14:00:17 <mauke> import ModuleName.hs looks like a syntax error
14:00:21 <jmcarthur_work> *fergie
14:01:21 <fergie> jmcarthur_work: where should this directory be?
14:01:25 <olsner> fergie: module Foo.Bar.Baz would be looked for in Foo/Bar/Baz.hs when you compile
14:01:59 <fergie> olsner: thanks, I'll see if that works
14:07:40 <fergie> olsner: I'm still struggling a bit. Is Foo/Bar/Baz.hs relative to the file that imports Foo.Bar.Baz?
14:08:15 <jmcarthur_work> fergie, relative to the root of the projevy
14:08:17 <jmcarthur_work> *project
14:09:29 <fergie> jmcarthur_work: what do you think is the root of the project for a gitit plugin? The directory where the plugin is or the directory where gitit is being run?
14:09:42 <jmcarthur_work> i am not familiar with gitit
14:10:59 <fergie> jmcarthur_work: I'll try both and see how I go. Thanks for your help
14:10:59 <absentia> dos ghc 6.10.3 onthe mac not have readline support?
14:11:10 <absentia> it's quite difficult to work on this without ^P and ^N .. and have to use the arrows.
14:11:19 <absentia> (arrows feel so third grade)
14:11:37 <absentia> is there an option to enable readline?
14:11:47 <mauke> no, because the ghc developers hate you
14:11:55 * absentia is sad.
14:12:28 <lilac> rlfe?
14:13:11 <absentia> seriosuly, is there anyway to enable that?
14:13:30 <lilac> rlfe?
14:13:32 <dons> bos: http://twitter.com/timbray/statuses/4451806621
14:13:36 <absentia> is there something I can put in my .ghcrc ?
14:13:40 <gwern> fergie: plugins are loaded by the executable, so I would assume that plugins run in the same process and so have the same relative location as it
14:13:48 <gwern> although I've never tried this...
14:14:04 <gwern> fergie: are you trying to write a plugin which loads files in the filestore?
14:14:07 <bos> dons: tee hee!
14:14:08 <lambdabot> bos: You have 4 new messages. '/msg lambdabot @messages' to read them.
14:14:26 <dons> bos: the tweeples have spoken!
14:15:17 * absentia is now angry.
14:15:23 <augur> :|
14:15:40 <augur> all people stealin mah name! :|
14:15:48 <absentia> I will try running ghci through an emacs shell
14:15:49 <augur> YOU!
14:16:05 <fergie> gwern: Think I've got it working now. As you say the path is relative to the executable
14:16:18 <mauke> augur: that sounds like you didn't register augur_
14:16:22 <absentia> works great.
14:16:24 <absentia> yay emacs
14:16:29 <gwern> augur: well, picking a common verb/noun like that doesn't augur well for people-not-stealing-it
14:16:36 <gwern> fergie: what plugin are you writing?
14:16:47 <augur> i didnt register any of augur_+, mauke. this is true.;
14:17:00 <fergie> gwern: not doing filestore stuff. Have some maths functions that I've got written in modules because I use then all the time
14:17:00 <Augur_> Neener!
14:17:25 <fergie> gwern: trying to use formlets plugin so that I can have a page in  my wiki that will calculate some stuff
14:17:31 <augur> gwern: actually noone stole it until this FRAUD showed up a few days ago :|||
14:17:40 <gwern> fergie: oh, so you were asking about imports; hm. it'd probably be easiest to just create & install a 'gitit-extras' package and then you wouldn't have to care about relative paths
14:17:42 <augur> plus, its not all that common. :P
14:18:00 <gwern> fergie: I've been meaning to create a gitit-extras/gitit-contrib anyway once I wrote 1 or 2 more plugins
14:18:28 <absentia> bah.. but ghci freaks at chars at the end of the infpu
14:18:29 <absentia> fuck
14:18:30 <sw17ch> -fno-warn-unused-binds should hide unused variables, right?
14:18:33 * absentia goes back to google and prays.
14:18:34 <fergie> gwen: mine is probably a bit too specialised to be useful. What else have you got?
14:18:50 <sw17ch> ah, warnings for unused variables
14:18:52 <fergie> gwern: mine is probably a bit too specialised to be useful. What else have you got?
14:19:06 <gwern> fergie: well, I've been meaning to write a transclusion module, and also a plugin which colors links by the size of the destination article
14:19:12 <gwern> in addition to the ones I already wrote
14:19:41 <fergie> gwern: what is transclusion?
14:19:46 <absentia> it seems like readline might be support
14:19:51 <absentia> but it never says how to enable it
14:19:52 <absentia> or how to check it
14:19:56 <absentia> or what the command line option might be
14:20:03 <gwern> fergie: it's where you substitute another article into a primary article
14:20:11 <mauke> I don't think it's supported
14:20:34 <mauke> I'm running an unofficially patched ghc-6.10.2 just to get readline
14:20:44 <gwern> fergie: this would be useful for gitit-as-ablog, for example. you write a regular article, then you edit the main page and transclude the new article, say, the first 100 characters
14:20:51 <absentia> edit line
14:20:59 <gwern> fergie: then anyone subscribed to the RSS feed for the main page gets notice of a new article
14:21:24 <absentia> I wonder how to enable it
14:21:55 <fergie> gwern: that sounds very cool. I'd definitely give that a try
14:22:02 <gwern> fergie: the link-coloring idea is just my pet peeve - I never know how 'important' or well-fleshed out a wikilink is. it'd be nice to see whether a link is to a big important article or a 1 line stub
14:23:20 <fergie> gwern: I was thinking the link coloring thing would be useful for seeing which pages you hadn't written yet. Are you thinking 1 color=stub page, another color=good page or do you want more a continuous change of tone?
14:23:33 <gwern> fergie: well, iirc, unwritten pages are just red
14:23:53 <absentia> is there any way to make editline behave like readline? or change the bindings to emacs?  specifically, ^p is previous and ^n is next?
14:23:58 <gwern> fergie: my plan was to figure out what HTML tags do coloring and see what range they allowed. probably no more than 10 gradations
14:24:04 <gwern> but I got stuck on working with filestore
14:24:18 <mauke> absentia: 6.10.3 doesn't use editline
14:24:47 <absentia> mauke: oh?  I can't find out what it uses... :-<  seems like nothing...
14:24:48 <fergie> gwern: Do you have a project page or anything? I'd like to see how your idea develop
14:24:58 <gwern> fergie: nah, it's just some half-written code
14:25:08 <mauke> absentia: haskeline
14:25:08 <gwern> maybe I'll try to write transclusion tonight. it shouldn't be *too* hard
14:25:12 <bos> hmm, i can't use criterion on a mac due to lack of gtk and cairo
14:25:20 <bos> dcoutts: ^^^ :-(
14:25:43 <fergie> gwern: post it to reddit or something if you ever get done. I really like the transclusion idea
14:25:46 <absentia> can I bind ^p to previous_line ?
14:25:55 <mpwd> bos:  fink?
14:26:01 <gwern> fergie: I'll post ti gitit ML of course; transclusion is just an obvious WP idea
14:26:07 <bos> mpwd: yeuch
14:26:38 <mpwd> bos: I'm pretty sure you can get gtk and cairo threw fink...
14:26:53 <bos> mpwd: i don'
14:26:54 <fergie> gwern: guess I should join that mailing list then
14:26:58 <gwern> yep
14:27:11 <bos> mpwd: i don't have the stomach for that quantity of yak shaving
14:28:04 <lilac> @hoogle (a -> Bool) -> [a] -> [[a]]
14:28:04 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
14:28:04 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
14:28:04 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
14:28:04 <absentia> echo "bind: ctrl-p up" >> $HOME/.haskeline
14:28:09 <absentia> finally.. sanity!
14:28:56 <fergie> gwern: thanks for your help tonight (and jmcarthur_work and olsner too)
14:29:03 <fergie> :quit
14:29:28 <jtra> hi
14:29:53 <lilac> is there a generalization of something like lines / words to an arbitrary predicate?
14:30:06 <Botje> lilac: if there is, it's in Data.List.Split
14:30:10 <jtra> I have tried to use Codec.Image.DevIL library but it does not work for me
14:30:30 <gwern> lilac: what Botje said. split was assembled specifically for that question
14:31:05 <lilac> @type \p -> unfoldr (fmap (const . takeWhile (not . p)) . listToMaybe)
14:31:06 <lambdabot>     Couldn't match expected type `(a, [[a1]])'
14:31:06 <lambdabot>            against inferred type `b -> [a1]'
14:31:06 <lambdabot>       Expected type: Maybe (a, [[a1]])
14:31:06 <jtra> here is same code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4220#a4220 - it should put a colored square onto image, but the result looks like http://dastych.sh.cvut.cz/~jtra/haskell/test.jpg instead
14:31:59 * mauke uses his crystal ball without looking at the code ...
14:32:13 <mauke> I see: swapped x and y coordinates
14:32:32 <gwern> 'that will be 95$, thank you'
14:32:53 <yitz> ok, now let's try the competition
14:33:03 <yitz> @vixen what is wrong with jtra's code?
14:33:11 <lambdabot> let's don't talk about that
14:33:23 <yitz> there you have it folks
14:33:28 <monochrom> Hehehe
14:34:16 <lilac> > (\p -> unfoldr (\xs -> fmap (const . first (head xs:) $ break p (drop 1 xs)) $ listToMaybe xs)) isSpace "Hello there world"
14:34:17 <lambdabot>   ["Hello"," there"," world"]
14:34:31 <jtra> mauke: I don't think it is a problem with swapped coordinates, they x and y are just names and both are used with same range so swapping them would not change much except for color gradient
14:35:02 <gwern> yitz: worth every penny you paid for it!
14:35:09 <jtra> input image and output image is here: http://dastych.sh.cvut.cz/~jtra/haskell/
14:36:16 <jtra> it looks more like some issue with the library, perhaps some problem with line padding that haskell side of the library ignores
14:38:11 <jtra> my ghc is 6.10.4, the library is libdevil1c2    1.7.8-5, I'm on debian
14:38:17 <lilac> i /think/ that's split (keepDelimsL $ whenElt p) :-/
14:41:44 <Zeiris> Wait a sec - which FRP library is 'better', Reactive or Yampa?
14:43:22 <Beelsebob> Zeiris: yes
14:43:29 <jmcarthur_work> they are different
14:43:33 <Beelsebob> (depends on your definition of better)
14:43:40 <Beelsebob> Reactive has a much nicer and cleaner interface
14:43:44 <Beelsebob> Yampa actually work
14:43:46 <Beelsebob> works*
14:44:00 <jmcarthur_work> i think reactive is semantically cleaner, yampa has an actual working implementation
14:44:15 <Zeiris> Well, I'm looking for something I can actually build a network client with. So I guess 'actually work' is good :)
14:44:19 <Beelsebob> although reactive isn't totally semantically clean
14:44:19 <jmcarthur_work> well, reactive too, but yampa works better
14:44:23 <jmcarthur_work> no it's not
14:44:29 <Beelsebob> but conal is working hard on that
14:44:32 <jmcarthur_work> *cough*Event*cough*
14:44:36 * Beelsebob nods
14:44:53 <Beelsebob> also, Reactive's obvious monad instance being near enough impossible to implement without having a time machine
14:44:57 <jmcarthur_work> the main issue is the monad instance
14:45:08 <jmcarthur_work> Event doesn't even have a valid monad, afaik
14:45:12 <skorpan> yeah the monad instance
14:45:14 * Beelsebob was proud to invent a time machine and implement that... but it did leak memory all over the place
14:45:16 <skorpan> i hear dat yo
14:45:33 <Beelsebob> jmcarthur: no, there is a valid one... it just doesn't agree with the useful applicative instance
14:45:46 <jmcarthur_work> Beelsebob, what is its semantics?
14:45:57 * Beelsebob tries to remember
14:46:49 <jmcarthur_work> i suppose it could be that there are even multiple ones, but i'm not sure they are useful
14:46:59 <Beelsebob> you probably need to poke conal with that one... I do remember him saying that there is a valid one
14:47:00 <pao> where is the instance Monad (r->) defined?
14:47:07 <Beelsebob> I even remember him telling me what it is
14:47:12 <Beelsebob> but I don't remember what it is
14:47:58 <Beelsebob> jmcarthur: yep
14:48:00 <Baughn> Beelsebob: Wait, how did you do it exactly?
14:48:20 <Baughn> Beelsebob: What /is/ the "obvious" join instance for Event?
14:48:25 <jmcarthur_work> Beelsebob, wait, what is the useful Applicative? surely not the current one. conal always says it is not useful
14:48:27 <mauke> pao: Control.Monad.Instances, Control.Monad.Reader
14:48:45 <pao> mauke: thanks... found it ...
14:48:50 <Beelsebob> Baughn: no no, I implemented monad for Behavior, not Event
14:48:57 <jmcarthur_work> ah, that's different\
14:49:09 <Beelsebob> yeh, but equally problematic
14:49:15 <Baughn> Beelsebob: Oh. That'd be.. hm.
14:49:39 * jmcarthur_work has written a few reactive implementations, and Behavior was rarely the problematic one
14:49:58 <Beelsebob> jmcarthur: you've had a Monad for behavior implementation at all?
14:50:06 <Baughn> Beelsebob: I suppose using max to join the inner behaviour's times with the outer?
14:50:08 <jmcarthur_work> yeah
14:50:27 <jmcarthur_work> its semantics are just the same as a stream, but continuous
14:50:57 <Baughn> Beelsebob: ..how would that work. I suppose.. if multiple switches end up on the same moment, remove all but the last? ...this seems hard to use.
14:50:57 <Beelsebob> yeh, but to implement that you need to be able to arbitrarily sample a behavior
14:51:12 <jmcarthur_work> it's not arbitrary
14:51:18 <jmcarthur_work> it's only ever at the current time
14:51:44 <Beelsebob> yep, but how do you tell the compiler that
14:52:01 <Beelsebob> (this is why my implementation leaked, the compiler couldn't see that it only ever sampled at the current time)
14:52:07 <absentia> hello world in c:  12K Bytes... hello world in haskell:  310KBytes
14:52:15 <Baughn> The implementation should be approximately the same as for Reactive, except with added merging of simultaneous switches
14:52:24 <burp> hello world in brainfuck: 400 bytes
14:52:37 <Baughn> absentia: Hello, world in assembly, 40 bytes
14:52:50 <mauke> hello world in ploki: 12 bytes
14:53:01 <absentia> er not the source code.. the executable.
14:53:02 <Botje> hello world in HQ9+: 1 byte.
14:53:03 <absentia> :-)
14:53:12 <absentia> botje: hehehe, ya nice language.
14:53:22 <Beelsebob> absentia: what's the issue with that?
14:53:22 <sw17ch> can i convince ghc to build a file with options that other files are not built with?
14:53:24 <Baughn> absentia: ..currently the RTS is always statically linked, which expands executables a little. GHC 6.12 adds dynamic linking, so just wait a few weeks and the problem'll go away.
14:53:26 <jmcarthur_work> Beelsebob, i simply never ran into the problem. i don't really implement things the way conal does in Reactive, though
14:53:27 <monochrom> hello world in Hola!, a language designed for hello world: 0 bytes.
14:53:30 <Beelsebob> absentia: all haskell binaries carry around the runtime
14:53:32 <burp> we're not talking about source size
14:53:33 <sw17ch> i tried setting the OPTIONS pragma, but it seems to like ignoring that
14:53:36 <Beelsebob> jmcarthur: *nod*
14:53:40 <absentia> baugh: thank you...
14:53:48 <absentia> beel: didn't knw that.
14:53:57 <monochrom> Oh, we're talking about machine code? OK!
14:53:58 <Beelsebob> jmcarthur: at some point I want to implement Reactive with a runtime, that schedules events/behaviors to run at specific times
14:54:14 <absentia> later.
14:54:14 <monochrom> hello world in HolaPlus!, a suite of language and hardware designed for hello world: 0 bytes.
14:54:17 <Beelsebob> absentia: why do you care how big the executable is, anyway?
14:54:20 <jmcarthur_work> Beelsebob, if you have a queue of behavior chunks where the tail is added to in IO and the head read from in pure code, it can be garbage collected from the head as you traverse it
14:54:40 <jmcarthur_work> Beelsebob, that is the basic approach i've been taking
14:55:00 <tromp> brainfuck in lambda calculus: 117 bytes
14:55:10 <Baughn> jmcarthur_work: How have you been dealing with comparing time values?
14:55:21 <Beelsebob> jmcarthur: yes, except for that you need to be careful to keep all behaviors/events ticking along, if one gets delayed (from never being output) then it can end up keeping hold of the entire history of all your other behaviors/events
14:55:23 <Baughn> jmcarthur_work: E.g. for the monoid instance for reactive
14:55:47 <jmcarthur_work> Baughn, duration is stored along with the chunks
14:55:55 <monochrom> "hello world in GHC-compiled haskell: 1MB. coolness: priceless" ?  :)
14:55:56 <jmcarthur_work> so time is rather simple
14:56:10 <jmcarthur_work> Beelsebob, this isn't a "stepping" system
14:56:13 <Baughn> jmcarthur_work: Even when you don't know the time in advance?
14:56:18 <monochrom> Oh I know a better one!
14:56:24 <sw17ch> never mind, i'm just hiding the wrong thign apparently :\
14:56:28 <Baughn> monochrom: No, 247kB, we already covered that
14:56:41 <jmcarthur_work> Baughn, i don't need the time in advance. if i don't know the time yet, i don't have a chunk yet
14:56:44 <monochrom> Yeah I made up the figure.
14:57:19 <Baughn> jmcarthur_work: Well, that's true - there are of course lots of synchronization issues with that, but it's true
14:57:56 <aavogt> why does HXT encourage the use of IO arrows?
14:58:16 <jmcarthur_work> Baughn, the main point of synchronization is the top level IO driver. you have to populate the queues and then sample the behavior with the same duration you just added to the queues, but that's easy because you already have that number
14:58:25 <Baughn> jmcarthur_work: http://github.com/Baughn/Reactant/blob/master/FRP/Reactant/Time.hs <-- I'm mostly curious whether there's a simpler way to do it than what I've been doing here. You don't need to look at all of it, but how does the code size compare?
14:58:37 <monochrom> "sum [1..100000000] with ghc -O2: 0.02 seconds. nofib with ghc -O2: 10 seconds. haskell coolness: timeless."
14:59:11 <Baughn> jmcarthur_work: Or, maybe..
14:59:51 <Baughn> jmcarthur_work: newTime :: IO (Time, IO ()) -- where calling the function sets the value of the first value returned, but you can compare Time values at any point before that
15:00:03 <Baughn> jmcarthur_work: Is that the same basic interface you've got?
15:00:36 <jmcarthur_work> Baughn, i think our architectures are very different, as these questions are not making much sense to me
15:00:53 <Baughn> jmcarthur_work: Possible. Can I look yours up on hackage?
15:01:03 <jmcarthur_work> it's not there
15:01:16 <Polarina> Is there some better way to do what I am doing here? http://codepad.org/ImMFHPNG
15:01:17 <jmcarthur_work> i'm still experimenting
15:01:26 <jmcarthur_work> (it's not 100% yet()
15:01:29 <jmcarthur_work> -(
15:01:51 <jmcarthur_work> i inevitably will find some sort of a leak, because i always do, but i think it will at least not be in the same place as seems to be most common
15:01:59 * Baughn fights not to instance Show a => Show (MVar a)
15:02:01 <jmcarthur_work> i'm also toying with the semantics a fair bit
15:02:27 <olsner> show . unsafePerformIO . readMVar?
15:02:32 <Baughn> ..yeah.
15:02:34 <jmcarthur_work> yuck
15:03:07 <Baughn> It would be convenient - it's basically what I'm doing in the Show instance for Time, and then I could derive it - but there's no way to avoid exporting the instance. ;/
15:03:12 <aavogt> Polarina: I believe there was a thread on the haskell-cafe mailing list covering different, and short approaches to roman numerals
15:03:44 <Polarina> aavogt: Do you have a link?
15:04:03 <monochrom> show . unsafePerformIO . readMVar screws up your synchronization.
15:04:31 <jmcarthur_work> Baughn, i'm basing my semantics on some of conal's input trimming ideas
15:04:35 <Baughn> monochrom: Not in this case. They're really just IVars.
15:05:22 <jmcarthur_work> well, my implementation i mean. the semantics are based on the corresponding comonadic ideas
15:06:45 <aavogt> Polarina: http://www.haskell.org/pipermail/haskell-cafe/2009-June/062508.html hmm, but that is for going the other way
15:06:51 <jmcarthur_work> Baughn, you could newtype wrap MVar and not export the newtype
15:06:52 <Baughn> monochrom: ..which solves the problem right there. I should newtype it, and make a proper IVar of it.
15:07:08 <jmcarthur_work> okay fine then
15:07:10 <jmcarthur_work> :P
15:08:19 * Baughn kind of thinks IVars should be implemented at the RTS level. They're more or less co-thunks.
15:09:30 <Baughn> (Also, only a /single/ lock should be required; as it is, I end up needing two MVars)
15:09:47 <Baughn> ..hm, not really
15:10:38 <olsner> what's an IVar?
15:10:46 <jmcarthur_work> write once read many
15:10:47 <skorpan> a swedish name
15:11:05 <olsner> skorpan: haha, true
15:11:18 <Baughn> Basically just a value, but such that reading the value blocks until it's set by an IO action
15:12:15 <olsner> hmm, so for instance, it could be used for event signals in some FRP system?
15:12:31 <Baughn> Yep, although that's not quite enough on its own
15:12:52 <Baughn> Add a way to block until one /of multiple/ IVars has been defined, and you're halfway there
15:13:10 * Baughn hugs unsafePerformIO. Such a convenient atrocity.
15:15:11 <olsner> e.g. something like unamb?
15:15:30 <jmcarthur_work> unamb is another approach to the same problem
15:15:38 <Baughn> Not really. The interface would be something like "readFirst :: IVar a -> IVar b -> Either a b"
15:15:50 <Baughn> That avoids the semantic fragility of unamb
15:15:52 <olsner> there was an unamb in conal's latest FRP paper (which I recently read), is there something wrong about it? or do you not want to use unamb?
15:16:01 <Baughn> I don't want to use unamb. ;)
15:16:36 <Baughn> It may be semantically correct, but it's extremely fragile, bug-prone (I should know, I fixed some of them) and, worse, forks a ridiculous number of threads to do its work
15:17:00 <Baughn> unamb is also more general than what I actually needed for Time.hs. The implementation I came up with instead isn't perfect, but it's a lot cheaper.
15:17:14 <jmcarthur_work> yeah, when i first read about it i was like "how is this a good idea?"
15:17:26 <yitz> Polarina: http://www.haskell.org/haskellwiki/Roman_numerals
15:17:46 <yitz> Polarina: what you did looks fine to me
15:17:48 <hackagebot> hssqlppp 0.0.7 - Sql parser and type checker (JakeWheat)
15:17:49 <jmcarthur_work> not that it's a bad idea semantically
15:17:50 <Baughn> jmcarthur_work: Oh, it's unequivocally a good idea. It may not be practical, but it's a great /idea/.
15:17:54 <jmcarthur_work> just as Baughn said... bug prone
15:18:05 <jmcarthur_work> Baughn, :)
15:18:57 <Polarina> yitz: :)
15:19:55 <olsner> I dig think the fork-based unamb implementation was meant to just be some kind of bubblesort of unambs :)
15:19:57 <yitz> Polarina: http://hackage.haskell.org/package/roman-numerals
15:20:14 <olsner> and that it was assumed that FRP would eventually prove useful and that one of those RTS geniuses would plop out an awesome-unamb and put it in ghc
15:20:24 <Baughn> olsner: You may be right
15:20:24 <jmcarthur_work> right
15:20:34 <Baughn> Thing is, since I figured out how to do without unamb.. :P
15:20:47 <jmcarthur_work> conal has said that he suspects we lack something in the RTS
15:21:40 <jmcarthur_work> Baughn, i'm not sure i would call your heavy use of unsafePerformIO such a hot thing either, based on what i've read you say about it :P
15:22:08 <Baughn> jmcarthur_work: I've learned how it works. I'm confident I'm safer in using it than 95% of #haskell.
15:22:19 <jmcarthur_work> heh
15:22:34 <Baughn> This does not imply that I'd suggest /others/ should use it. :P
15:22:51 <olsner> Baughn: re doing without unamb, isn't readFirst the exact same basic operation as unamb - just in a different package? or were you refering to something else?
15:22:52 <Baughn> It's a backdoor, and I'm using it essentially to extend the runtime. Not a lot of people need to try that.
15:23:00 <jmcarthur_work> Baughn, okay, so looking at your code, you follow the same basic design as reactive, but you put all the "ugly" stuff in your time abstraction?
15:23:18 <Baughn> olsner: The difference is, readFirst can be implemented cheaply; unamb can't. Or at least, we haven't figured out how yet.
15:23:39 <olsner> the difference being that readFirst works on IVars and unamb works on thunks?
15:23:59 <Baughn> olsner: In my case, I'm sticking IO actions (namely, incrementing a QSem, which wakes the readFirst thread) inside the IVar, to be executed when it gains a value
15:24:02 <Baughn> Yes
15:24:10 <Baughn> ..hm...
15:24:21 <Baughn> Actually, I suppose you could do exactly that with thunks, too
15:24:29 <Baughn> I mean, a thunk basically /is/ an IVar
15:24:57 <jmcarthur_work> i'm trying to do a synchronization-free implementation. we'll see how that goes
15:26:06 <jmcarthur_work> it's basically glorified interact
15:26:12 <Baughn> olsner: Oh yeah. The other, really important difference is that readFirst does not pretend to be pure. It's amb, not unamb
15:26:45 <Baughn> Though I suppose that makes little difference to the mechanics. :P
15:26:47 <olsner> so "readFirst :: IVar a -> IVar b -> Either a b" should really have an IO around that?
15:26:56 <Baughn> Yes. It does, rather.
15:26:56 <jmcarthur_work> Baughn, ah, so you really have that as an IVar primitive then, not just as a Future primitive?
15:27:20 <Baughn> jmcarthur_work: Well.. at the moment, I've got it as a Time primitive, but I could (and will) factor it out to a separate IVar
15:27:29 <olsner> hmm, how pure is unamb though?
15:27:31 <jmcarthur_work> ah
15:27:41 <Baughn> unamb is pure if the IVar values are structurally identical
15:27:49 <Baughn> (Or if one stays bottom forever)
15:27:53 <jmcarthur_work> olsner, the preconditions of unamb require that both arguments be the same if not _|_
15:28:01 <jmcarthur_work> olsner, so it's pure, semantically
15:28:14 <Baughn> It's pure, so long as you're vewwy vewwy caweful
15:28:24 <olsner> hmm, so it can return either of two equal values, kind of?
15:28:32 <jmcarthur_work> olsner, that's it
15:28:35 <Baughn> One of my issues with reactive is that it uses unamb a lot, where amb and unsafePerformIO would be safer
15:29:07 <olsner> haha, "unsafePerformIO would be safer"
15:29:31 <Saizan_> really?
15:29:33 <jmcarthur_work> olsner, unamb can be useful for non-reactive stuff too
15:29:50 <Baughn> Saizan_: unamb = unsafePerformIO . amb
15:29:55 <Baughn> More or less
15:30:10 <copumpkin> "One of my issues with reactive is that it uses unamb a lot, where amb and unsafePerformIO would be safer"
15:30:12 <jmcarthur_work> olsner, for example, you can run both arguments to an or operation in parallel and return early if the first to finish is True
15:30:14 <Saizan_> Baughn: yeah, so why amb + unsafePerformIO would be safer?
15:30:15 <copumpkin> "Saizan_: unamb = unsafePerformIO . amb"
15:30:16 <Baughn> ..actually, exactly, but amb would be nicer if it told us /which/ of the two values evaluated first
15:30:42 <copumpkin> Either a a
15:31:01 <Baughn> Saizan_: That way you can gain a reduced amount of dangerous code
15:31:19 <jmcarthur_work> Left a `amb` Right b
15:31:27 <Baughn> Saizan_: Conal's code uses unamb all over. Mine uses unsafePerformIO only in one, two-hundred-line file, which exports an interface that can't be misused. They do basically the same thing.
15:31:31 <Baughn> jmcarthur_work: ..well, I suppose
15:32:07 <jmcarthur_work> still not sure how that makes anything less dangerous, though
15:32:21 <Saizan_> Baughn: so the point is that you build bigger IO blocks to unsafePerform?
15:32:52 <Baughn> Saizan_: That, and that I build blocks that have safe interfaces
15:33:01 <jmcarthur_work> the Either a a version, i mean. i get that a safer interface helps, of course
15:33:38 <Baughn> Saizan_: Mostly, it's just that I have /fewer/ unsafePerformIO calls than conal has unamb calls. unamb is a lot more convenient, which is a pity when it's so dangerous.
15:34:50 <coco> is there a good book that explains the theoretical underpinnings of ghc?
15:34:57 <mrsolo> .. Not in scope: `Test.QuickCheck.verboseCheck'...
15:35:04 <jmcarthur_work> coco, theoretical?
15:35:05 <mrsolo> look like my haskell platform install is screwedup?
15:35:11 <copumpkin> the STG and so on?
15:35:19 <gwern> > 1+1--comment
15:35:21 <lambdabot>   2
15:35:22 <coco> STG?
15:35:25 <gwern> > 1+1 --comment
15:35:25 <jmcarthur_work> coco, spineless tagless G machine
15:35:26 <lambdabot>   2
15:35:33 <gwern> huh. I didn't expect those to work
15:35:36 <jmcarthur_work> makes for a good google
15:35:40 <coco> huh, never heard of that
15:35:50 <lilac> how common is RecursiveDo?
15:35:56 <jmcarthur_work> @where STG
15:35:57 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
15:35:57 <gwern> > 1 + {--} 2
15:35:59 <lambdabot>   3
15:36:30 <coco> thanks, but I was looking for a book
15:36:35 <olsner> lilac: monadfix is a weird beast, I suspect few people understand how to use it :P
15:36:38 <copumpkin> coco: then no
15:36:40 <jmcarthur_work> i don't know of any books
15:38:59 <aavogt> @where ifl
15:39:00 <lambdabot> I know nothing about ifl.
15:39:01 <lilac> olsner: hmm. thanks. i can't see a nicer solution, though...
15:40:46 <aavogt> coco: this one, or another spj book written a bit later covers that stuff:  http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
15:41:04 <jmcarthur_work> lilac, as long as you don't reuse identifiers you shouldn't have any problems with mdo
15:41:07 <gwern> > [-100.. -110]
15:41:09 <lambdabot>   []
15:41:33 <olsner> but if you don't reuse identifiers, is there any point in using mdo at all?
15:41:56 <jmcarthur_work> olsner, the point is that the idents on the lhs and rhs are the same thing
15:42:03 <jmcarthur_work> if your intent is for them to be different then you are going to break things
15:42:30 <olsner> you mean, like mdo x <- x?
15:42:40 <jmcarthur_work> well, as a degenerate example
15:42:40 <lilac> well that'd be a type error but...
15:44:05 <lilac> i'm actually doing something like: mdo bs <- mapM (doAllSortsOfCrazyStuffWith bs) as
15:44:32 <copumpkin> why is mdo called mdo?
15:46:11 <copumpkin> why not rdo?
15:46:18 * jmcarthur_work shurgs
15:46:23 <jmcarthur_work> shrugs, even
15:48:02 <mrsolo> is HUnit commonly used? or there is something else?
15:49:16 <Saizan_> what's the problem with RecursiveDo? if you know how "let" works you shouldn't have big problems with it
15:49:36 <Saizan_> recursion is always recursion
15:49:50 <bos> copumpkin: mdo stands for µdo
15:50:11 <copumpkin> :o
15:50:20 <copumpkin> I guess a paper uses that notation?
15:50:40 <bos> in a footnote.
15:50:53 <gwern> quick question: anyone know how to make 'if [[ `hostname` == "craft" ]]; then firefox "$@"; else true; fi' work in sh and not just bash?
15:51:33 <lilac> gwern: 'if [ "x`hostname`" == "xcraft" ]; then ...' maybe
15:51:43 <gwern> that's hideous
15:51:46 <jmcarthur_work> ??
15:51:47 <gwern> what's with the xes?
15:51:51 <Draconx> also note that $@ is not portable, either.
15:52:08 <lilac> some shells go wrong if you give them empty strings, and remove the argument altogether. test doesn't like that.
15:52:14 <bos> gwern: just drop the double square brackets down to single
15:52:18 <Draconx> hostname probably doesn't return the empty string, though.
15:52:21 <gwern> bos: I already tried that
15:52:26 <Draconx> plus, you use = with [, not ==.
15:52:33 <bos> gwern: the nonsense with the use of x hasn't been necessary in decades.
15:52:49 <gwern> Draconx: oh. damn my eyes for being a haskeller then!
15:53:03 <gwern> ah, looks like == was the problem
15:53:20 <gwern> 'if [ `hostname` = "craft" ]; then firefox "$@"; else true; fi' works with sh
15:53:29 <Draconx> $@ will be problematic on many shells.
15:53:41 <gwern> Draconx: well, it doesn't really matter to me. I don't expect to ever actually call this script with args
15:53:56 * gwern shrugs. it's for my desktop startup sequence
15:54:04 <gwern> habit, I suppose, makes me write it
15:57:58 <olsner> hmm, then why do you need it to work with plain sh? can't you just make it run with bash?
16:15:35 <mle> Maybe I'm having language-barrier issues, but the Ro/haskell page looks like wikispam, seeing as it's in (mostly) English and contains animated gif files.
16:19:27 <copumpkin> mle: Ro/haskell?
16:19:39 <Kagami``> http://www.haskell.org/haskellwiki/Ro/haskell
16:19:45 <mle> yes that.
16:19:46 <Kagami``> mandriva ads :3
16:20:18 <copumpkin> it definitely looks like there's legit stuff on there
16:20:20 <jmcarthur_work> O_o
16:20:22 <copumpkin> but not sure if it all is
16:20:25 <mmorrow> lol
16:20:37 <mle> yeah, I'm confused because all the updates are by the same guy.
16:20:50 <mmorrow> "(en) Here, in Romania, students had running Haskell on Mandriva Linux." (accompanied by an animated gif mandriva add)
16:20:53 <mmorrow> classic
16:21:01 <copumpkin> lol
16:21:27 <mle> maybe he has a bad password or reaaaally likes mandriva or something.
16:21:41 <jmcarthur_work> barely better http://www.haskell.org/haskellwiki/Ro/Haskell
16:24:26 <mle> recommend replacing with a #REDIRECT maybe
16:24:44 <kpreid> looks like enthusiasm to me
16:25:25 <mle> #REDIRECT is more effective than a page with Four links and flashing gif files.
16:26:27 <naren> Hello. I have a mapreduce program in C++, but I want to try writing this in Haskell using one of the available distributed frameworks. Can anyone recommend which one I should use to write a mapreduce like program? Note, I have never done any parallel programming in haskell.
16:27:24 <Alpounet> @hackage mapreduce
16:27:24 <lambdabot> http://hackage.haskell.org/package/mapreduce
16:27:36 <Alpounet> damn
16:27:46 <Alpounet> http://hackage.haskell.org/package/Holumbus-MapReduce
16:28:13 <Alpounet> or http://hackage.haskell.org/package/monoids (contains a general map/reduce framework)
16:28:34 <gwern> mle: maybe he doesn't know how to make redirects
16:28:42 <naren> are these maintained well?
16:28:57 <gwern> Alpounet: @hackage doesn't check to see whether the package actually exists
16:28:59 <gwern> sry
16:29:10 <Alpounet> yeah
16:29:14 <Alpounet> just figured it out
16:29:31 <mle> gwern: well, it doesn't look malicious.
16:29:38 <Alpounet> naren, don't know, just read their description, look at the last update date, etc
16:30:08 <burp> hm, embed Writer in StateT or State in WriterT? pro/contra?
16:30:17 <naren> Alpounet: rightho, thanks
16:30:43 <tommd> And send food to the maintainers, so they have more time and energy to program.
16:31:30 <burp> hm, or I use RWS rightaway, I could use reader too
16:31:37 <Alpounet> tommd, heh
16:32:11 <Alpounet> gwern, it'd be feasible though
16:32:26 <gwern> sure, lots of lb improvements are feasible
16:32:41 <aavogt> @vixen but aren't you perfect already?
16:32:42 <lambdabot> good question
16:33:09 <Alpounet> gwern, yeah, as always, time and developers missing ? :-)
16:33:14 <gwern> yeah
16:33:43 <c_wraith> > 1
16:33:44 <lambdabot>   1
16:33:52 <c_wraith> that's an improvement over last night. :)
16:35:25 <Alpounet> gwern, I'll try to give lambdabot a whirl asap, to see if I can do something correct for handy features
16:35:29 <gwern> great
16:35:33 <Alpounet> now, gotta go, good night
16:35:40 <gwern> @let 1 = 2
16:35:42 <lambdabot>  Defined.
16:35:43 <gwern> > 1
16:35:44 <lambdabot>   1
16:35:47 <gwern> dammit
16:36:56 <periodic> anwb.wsdfansdfkljsdfasdfa
16:36:59 <periodic> oops.
16:40:26 <mrsolo> hmm realword haskell goes out of date fast......
16:40:43 <Igloo> Oh?
16:41:23 <mrsolo> there is a change in Exception in 6.0.10..boom
16:41:55 <mrsolo> and it is using quickcheck 1.2  man the book was just release few months back
16:42:03 <copumpkin> not sure I'd say the book is out of date because one api changed
16:42:09 <Kagami``> mrsolo: try Contro.OldException
16:42:09 <copumpkin> and many people use quickcheck 1.2
16:42:32 <mrsolo> right
16:43:25 <mrsolo> there are solutions of course but those stumble blocks are huge when trying to learn haskell (to me anyway)
16:43:36 <copumpkin> huge o.O
16:47:37 <dons> import Control.OldException
16:48:10 <McManiaC> is there a way to "cancel" a foldr?
16:48:50 <copumpkin> you could do a scanr and only take as much of it as you want
16:49:12 <ivanm> mrsolo: I don't know of anyone that uses quickcheck-2 :s
16:50:18 <gwern> offhand, does anyone know if there's a magic string one can append to a url to make the browser go to the bottom of the page?
16:50:22 <gwern> ivanm: yi uses it
16:50:34 <ivanm> :o
16:50:38 * ivanm faints
16:50:43 <gwern> my stars!
16:50:48 <gwern> gor blimey
16:51:56 <mrsolo> ivanm: what's wrong with it?
16:52:08 <McManiaC> gwern: not that i know of
16:52:15 <ivanm> mrsolo: it's different from QC-1
16:52:21 <ivanm> _that's_ what's wrong with it :p
16:52:22 <gwern> McManiaC: all the hits I see are for doing it on the server, with js or html
16:52:28 <mrsolo> ivanm: apparently lots of stuff doesn't work
16:52:31 <mrsolo> what did i know
16:52:35 <McManiaC> yeh
16:52:58 <McManiaC> i dont think html has any kind of thing like that, even if it had it would probably not be supported by many browsers ^^
16:53:03 <mrsolo> i have to actually to learn what ghc-pkg on the fly to hide it
16:53:06 <kpreid> gwern: you want to do this to somebody else's web page?
16:53:15 <mrsolo> since cabal happily installed the latest version
16:53:19 <gwern> kpreid: yeah, for like a bookmark
16:55:24 <seanmcl> Hi.  I'm rather new to Haskell.  I have a program that logs stuff using the Writer monad.  Unfortunately, when an Exception is raised, the nice log I've been building is lost, since it's hidden in this monad that the exception jumps out of.  I could make every function that could possibly raise an Exception live in the writer monad, whereby I could grab the log and pass it along with the exception, but I hate to pollute my nice pure
16:55:24 <seanmcl> functions types.  Is there a better way to get ahold of the writer log?  Or should I abandon the writer in favor of Debug.trace?
16:55:30 <kpreid> thought about using a javascript: bookmark but I don't think that can control the *next* page
16:55:52 <gwern> mm. well, it wasn't very important. just would've made my life a tiny bit easier
16:55:55 <dons> seanmcl: you could catch the exception?
16:55:55 <McManiaC> does anyone know any performant way to strip trailing white spaces from every line of a long string?
16:56:08 <seanmcl> yes, I catch the exception in IO
16:56:10 <dons> seanmcl: what's throwing the exception?
16:56:10 <kpreid> gwern: of course if there's some id on the page you can use it
16:56:12 <kpreid> e.g. http://www.haskell.org/#footer
16:56:18 <dons> McManiaC: bytestring. dropWhile ?
16:56:26 <gwern> hm. I didn't see anything in the ToC but maybe it's hidden
16:56:45 <McManiaC> how do you dropWhile from the end of a string? ^^
16:56:47 <kpreid> on haskell.org? it's part of the outer markup, not any page section
16:56:52 <dons> seanmcl: what's throwing the exception though? somehow you have to squash the exception throwing, or use WriterT IO
16:57:00 <seanmcl> The writer gets run in a package, prove :: Formula -> Bool.  Then the front end calls prove, and handles exceptions.  Prove calls runWriterT.
16:57:05 <gwern> kpreid: wp
16:57:06 <dons> catch the exception in the tranfromer.
16:57:24 <gwern> nope. either it's not there or my custom css/js have removed the footer
16:57:32 <kpreid> wikipedia has an #footer too
16:58:03 <seanmcl> dons: How do you catch an exception in a transformer?  I thought you could only catch it in IO.
16:58:15 <dons> you're in WriterT State IO a ?
16:58:29 <dons> writercatch = liftIO catch ?
16:58:39 <dons> IO is your base monad?
16:58:55 <seanmcl> Mmm. No.  Maybe that's the problem.  I totally avoid IO.
16:59:00 <seanmcl> except in the front end.
16:59:06 <dons> oh, so you're in a pure monad
16:59:10 <dons> where's the exception coming from, then?
16:59:10 <seanmcl> Right
16:59:29 <seanmcl> Exception is coming from pure code
16:59:45 <dons> you can unsafePerformIO $ catch
16:59:49 <dons> to catch in pure code.
16:59:49 <seanmcl> There's a bug.  This shouldn't be happening, so it's not the average case.
16:59:54 <dons> ok.
17:00:14 <dons> it would be better to rule out the imprecise exceptions coming out of the pure code. your program will be more robust.
17:00:16 <FunctorSalad> how unsafe is that?
17:00:21 <dons> but you can in catch exceptions in pure code if you want
17:00:32 <dons> FunctorSalad: its not 'unsafe' afaik.
17:00:51 <dons> and it might be a good workaround if you have no control over the code throwing the error
17:00:57 <dons> i've had to do that maybe 2 times in 10 years
17:00:59 <seanmcl> Rule out the exceptions by using Maybe or something like that?
17:01:02 <FunctorSalad> *nod*
17:01:09 <dons> seanmcl: exactly
17:01:17 <dons> convert any exception into Maybe a
17:01:20 <dons> then handle it purely
17:01:25 <dons> that's why it is safe, btw,
17:01:38 <dons> since you're not breaking referential transparency
17:01:48 <seanmcl> If you were writing a program that could raise exceptions and log interesting tidbits, how would you organize the monads?
17:01:59 <seanmcl> so you coudl get the log if an exception was raised
17:02:00 <dons> WriterT IO a is a good way to write loggers
17:02:08 <dons> or us ing the Logging framework on hackage
17:02:20 <seanmcl> ok, thanks!  I'll check that out.
17:02:23 <dons> if its pure code, i'd map exceptions into Maybes
17:02:31 <dons> hslogger, iirc. very popular.
17:03:04 <FunctorSalad> maybe you could even prove that exception-catching pure code can always be transformed to pure code?
17:03:26 <dons> you can certainly satisfy the usual rule for unsafePerformIO -- "can i write a pure function that does the same thign"
17:03:32 <dons> and yes, you can, since you could return Maybe
17:04:21 <FunctorSalad> ok, I'll keep it in mind for the next time I use some partial library function :)
17:07:55 <Vanadium> welp
17:07:58 <Vanadium> Just did a bunch of exercises in scala
17:08:08 <Vanadium> Lets me appreciate haskell so much more~
17:09:07 <ivanm> Vanadium: Scala is project secretly designed to convert Java programmers to Haskell programmers :p
17:09:20 <mrsolo> hmm it seems like quickcheck 2 run much faster
17:10:22 <kroo> heh, cool, I really like the idea of statically typed units ( http://code.google.com/p/dimensional/ )
17:10:36 <kroo> looks a little inflexible though
17:10:54 <aavogt> Vanadium: I got the same impression of Scala
17:11:27 <dibblego> that's what I use Scala for anyway :)
17:11:44 <ivanm> see? :p
17:12:02 <dibblego> Vanadium, what exercises?
17:12:56 <aavogt> kroo: what do you mean by inflexible?  A bigger problem with that library is that the error messages from mismatched dimensions can be pretty unpleasant
17:13:30 <f4hy> I am considering using haskell for a numerical analysis class becuase I think it will be more fun, but I am still sort of new to haskell, so not sure if it will be biting off more than I can choose. What do you all recommend?
17:13:39 <dons> we can make QC faster with the new fast randoms libraries, btw.
17:13:51 <dons> f4hy: sounds good to me. install GHC from the Haskell Platform
17:13:55 <kroo> aavogt: the numeric type implementation only allows for fairly small, integer exponents, etc
17:14:06 <Vanadium> dibblego: A bunch of homework questions a friend of mine was working on. Basic list manipulation, implementing delete, nub, splitAt, etc
17:14:07 <aavogt> but if you know what types you are expecting, and can write those signatures in, then any errors will be a bit more precise
17:14:13 <ivanm> dons: well, were he installs it from depends on what distro, etc. he's using...
17:14:51 <mz> heyyyyy
17:14:57 <aavogt> kroo: it does CGS, which apparenly has some fractional exponents for electromagnetic things IIRC
17:15:31 <mz> how many ppl on here
17:15:32 <f4hy> dons: I already ahve GHC, is there more in the Haskell Platform?
17:15:44 <f4hy> I guess, what exactly is the haskell platform
17:16:11 <Vanadium> (Frankly the entire assignment struck me as "we wanted to teach haskell but they would not let us")
17:16:20 <ivanm> f4hy: GHC + libraries, to provide "batteries included" environment for haskell
17:16:26 <ivanm> @where HaskellPlatform
17:16:26 <lambdabot> I know nothing about haskellplatform.
17:16:30 <ivanm> @google "haskell platform"
17:16:32 <lambdabot> http://hackage.haskell.org/platform/
17:16:32 <lambdabot> Title: Haskell Platform Download (Beta)
17:16:45 <ivanm>  @google > @where :s
17:16:54 <f4hy> Ahh, well I can just install the libraries as I need them right?
17:17:07 <ivanm> f4hy: yes, cabal-install can help you with that
17:17:10 <kroo> aavogt: afaict it looks like its missing the EM units
17:17:12 <ivanm> @where cabalinstall
17:17:12 <lambdabot> I know nothing about cabalinstall.
17:17:15 <ivanm> @where cabal-install
17:17:16 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
17:17:28 <f4hy> Ya, I have used that in the past.
17:18:40 <kroo> aavogt: http://code.google.com/p/dimensional/wiki/ChuckBlake20070611
17:18:55 <Zao> Has there been any non-vapor work on Haskell integration in NetBeans?
17:19:02 <f4hy> Anyway, I am doing numerical analysis/optimization, and all the algorythms in the books are iterative, but I was wondering if there are good resorces (libaries / documation) on how to do number crunching with haskell.
17:20:00 <tweety> heyyyy ppl
17:20:05 <ivanm> hmatrix provides matrix stuff
17:20:35 <ivanm> Zao: don't recall hearing anything about it
17:22:36 <Zao> Ooh, binary installer of Leksah for Windows.
17:22:53 <aavogt> kroo: From CGS.lhs: I'm ignorantly assuming that when working with the CGS (or MKS) system you will only (meaningfully?) encounter half-exponents and only of the length and mass dimensions. Of course, in other systems other rational exponents may be encountered.
17:23:11 <arnihermann> could anyone (familiar with scala?) suggest sensible data model in haskell equiv. to http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9953#a9953 ?
17:23:26 <kroo> ahah, gocha
17:23:50 <arnihermann> I'm feel I'm using too many data types (one for each statement, thing, ...)
17:24:18 <arnihermann> in haskell
17:24:51 <aavogt> but I have not used that part of dimensional
17:25:26 <dibblego> arnihermann, data Thing = Location String | Robot String | Crane String
17:25:46 <arnihermann> dibblego: right, I got that so far
17:25:57 <arnihermann> dibblego: I'm struggling with the statements and the actions
17:26:09 <dibblego> arnihermann, deriving (Eq, Show) to get the equivalent of toString and equals for the case classes
17:26:33 <BMeph> Ugh, pity me - I've decided to convert someone's number-crunching program to Haskell...from FORTRAN. :|
17:26:36 <arnihermann> dibblego: data Statement = ... | At Robot Location | ...
17:26:46 <arnihermann> dibblego: I cannot do this if Thing is a data type
17:26:56 <arnihermann> dibblego: since Robot and Location are constructors
17:27:03 <arnihermann> dibblego: right?
17:27:06 <dibblego> arnihermann, Statement can be written in the same manner and data Action = Action { pre :: [Statement], min :: [Statement], add :: [Statement] }
17:27:39 <f4hy> BMeph: Pretty much what I am doing
17:27:41 <ivanm> BMeph: well, I've done the reverse...
17:27:41 <dibblego> data Move = Move Action Robot Location Location
17:28:16 <f4hy> BMeph: In my field everything is still in FORTRAN, and I am considering doing things in haskell, but I feel like it might be a bad idea
17:29:29 <BMeph> ivanm: That's kind of goofy-sounding, but it doesn't sound nearly as daunting. Then again, I haven't programmed "serious" FORTRAN in over twenty years. :)
17:29:36 <ivanm> heh
17:29:51 <ivanm> which version of Fortran are you using?
17:30:03 <ivanm> (note that they got over the capitalisation a while back AFAICT...)
17:30:09 <f4hy> f90 is actually not bad. If you are still in f77 :-(
17:30:35 <ivanm> yeah, I used F90/95/2003
17:31:10 <ivanm> (I needed run-time allocation in a record-style data structure... F90 added both features, but it wasn't until 2003 that they realised some people might want to use them _together_ :o)
17:31:13 <BMeph> f4hy: I hear that - this routine I'm working on has so many "go to"s, I'm seriously debating making the (first) re-write CP style. :\
17:31:23 <ivanm> (and intel's compiler was the only one that seemed to accept it...)
17:31:29 <ivanm> BMeph: CP?
17:31:46 <BMeph> ivanm: Continuation-Passing
17:31:58 <ivanm> ahhh
17:31:59 <holmak> The reinvention of unstructured programming
17:32:04 <burp> f4hy: physics? :P
17:32:08 <holmak> Truly, there is no new idea in programming :p
17:32:31 <f4hy> I actually wrote a script a while back to take a f77 program and convert it to f90 with a bunch of hacked regular expressions
17:32:37 <f4hy> burp: ya
17:32:41 <burp> haha knew it
17:32:43 <arnihermann> dibblego: right, thanks, I'll try that
17:32:53 <hackagebot> cereal 0.1 - A binary serialization library (TrevorElliott)
17:32:58 <burp> physicists seem to love fortran ;)
17:33:16 <f4hy> burp: Computational physics, its all FORTRAN. But this new project, i really want to use haskell, but worried I wont know how to convert some of these algos
17:33:17 <ivanm> nowadays they also love Mathematica by the looks of things :s
17:33:18 <BMeph> f4hy: Yeah, mine's F77. It got a small refactoring in '99, but only to exploit how part of the algorithm works, not anything major.
17:37:52 <arnihermann> dibblego: would it make sens to have a typeclass for actions (pre, min, add) which each action datatype would be an instance of? meaning, the pre/min/add is static to each action, I don't want to create that everytime I create a move action with different robot/location
17:38:38 <dibblego> arnihermann, I don't think so, but I'm not clear on what you mean
17:39:13 <arnihermann> dibblego: data Move = Move Action Robot Location Location, the Action for Move is always the same, while Robot and Location differentiate
17:39:39 <dibblego> arnihermann, in that case don't have it appear as a constructor argument
17:40:43 <arnihermann> dibblego: right, makes sens, there are probably many correct ways of doing this... then I just need to associate it with the Move type
17:45:01 <lispy|web> dons: ping
17:45:39 <copumpkin> lithpy
17:47:04 <kroo> heh, show $ (1 ~ gee)  (12 *~ second) <-- thats pretty cool, I have to say.
17:48:23 <gwern> > 5014 / 356
17:48:25 <lambdabot>   14.084269662921349
17:59:48 <arnihermann> dibblego: should http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9962#a9962 work based on what you told me earlier?
18:00:24 <arnihermann> dibblego: I'm getting "Not in scope: type constructor or class `Location'" on that code
18:03:13 <arnihermann> or anyone that can take a quick look at that code?
18:03:46 <Polarina> arnihermann: Is Location defined?
18:03:51 <heatsink> arnihermann, 'Location' is a data constructor, not a type constructor.
18:04:02 <arnihermann> ah, right
18:04:41 <arnihermann> what I thought, so I'd have to make a data Location = ..., data Robot = ..., etc
18:05:20 <Polarina> data Location = Location crap String | omg String | rest Location deriving (You)
18:05:34 <Polarina> Like that.
18:06:21 <heatsink> You have very similar definitions for both Object and Statement.  It might be simpler to merge them into one type.
18:07:35 <arnihermann> heatsink: right, simpler
18:08:20 <heatsink> data ObjectType = Location | Robot | Crane | Pile | Container; data Object = Object ObjectType String; data Statement = Associated Object String | Occupied String
18:09:18 <arnihermann> heatsink: yeah but that wouldn't constrain the type of object
18:09:21 <arnihermann> to the type of statement
18:09:28 <arnihermann> which is exactly what I need
18:09:49 <arnihermann> h
18:09:50 <arnihermann> sorry
18:09:52 <arnihermann> I misread
18:10:07 <arnihermann> interesting
18:11:38 <arnihermann> heatsink: but if I wanted to only allow building Occupied with a Location object
18:11:44 <arnihermann> instead of a string ?
18:13:26 <heatsink> data Location = Location String
18:13:34 <copumpkin> newtype
18:13:59 <heatsink> Then make functions that convert between Object and Location.  The Object -> Location cast may fail.
18:15:23 <heatsink> This way, you have a data type Location that acts like a subtype of Object.
18:15:24 <arnihermann> right but that's basically using pattern matching to find errors instead of the type system?
18:16:32 <heatsink> yes.  This works well when most of your code keeps Location and Object separate, so you only have a few places where dynamic errors can occur.
18:16:55 <arnihermann> yes, true
18:18:01 <arnihermann> thanks all, you've given me stuff to think about :)
18:44:00 <Axman6> http://www.infoq.com/interviews/armstrong-peyton-jones-erlang-haskell anyone watched this yet? quite a nice interview with SPJ and Joe Armstrong
18:50:40 <lispy|web> Is there a way to do the same thing as LD_PRELOAD on osx?
18:50:56 <Axman6> DYLD_PRELOAD possibly?
18:51:35 <blackdog> how do you let cabal know to use a specific version of GHC when you may have many installed?
18:51:42 <lispy|web> Axman6: thanks, I'lly try that
18:52:02 <Axman6> lispy|web: tried it, no dice
18:52:17 <Axman6> man dyld
18:53:27 <lispy|web> Axman6: do you think DYLD_INSERT_LIBRARIES does what I want?  The description doesn't tell me much
18:53:51 <Axman6> it may do... test and see :)
18:53:51 <lispy|web> I want to inject a library so I can intercept calls to mmap
18:53:55 <Axman6> what're you trying to do?
18:54:42 <lispy|web> Well, it seems that GHC's heap profile doesn't keep track of mmap'd things and maybe also pinned memory
18:54:43 <copumpkin> lispy|web: mmap may be hard, but that is what you use to inject libraries
18:55:02 <lispy|web> copumpkin: okay, well I have some example code that Igloo wrote for linux.  Trying to make it work on the mac
18:55:13 <copumpkin> http://books.google.com/books?id=K8vUkpOXhN4C&pg=PA73&lpg=PA73&dq=DYLD+INTERPOSE&source=bl&ots=OJmjQ__r0C&sig=sBUkEzCX2XClhiHoIwBcyjRwAlk&hl=en&ei=8WjBSu-nOdCJtgf63aD6BA&sa=X&oi=book_result&ct=result&resnum=1#v=onepage&q=DYLD%20INTERPOSE&f=false
18:56:07 <lispy|web> copumpkin: thanks!
18:59:20 <Axman6> crap, i just broke my GHC
18:59:55 <tommd> Axman6: Don't worry, extra copies are free.
19:00:05 <Axman6> not on snow leopard
19:00:34 <tommd> Non-trivial time investment, huh?
19:01:11 <Axman6> well, it's just broken on SL afaict
19:02:22 <aavogt> is there any guide to the usage of arrow transformers?
19:03:01 <blackdog> got a bit of a cabal problem - i'm trying to specify a different version of ghc, but it's going straight to the one in my PATH instead
19:03:04 <blackdog> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4222#a4222
19:03:07 <blackdog> any ideas?
19:03:08 <aavogt> I want to be able to use Control.Arrow.Transformer.Writer with the Control.Arrow.ListArrow from HXT
19:03:26 <aavogt> but I'm not sure how to lift the ArrowXml instances through the writer
19:06:24 <mitchellh> I'm using HXT to parse an HTML document, and xpath to get down to just the elements I'm interested in. This was simple and made sense to me. However, I'm not sure how to extract values of the elements from the XmlTree structure. Anyone have anything to point me in the right direction, please?
19:07:26 <aavogt> mitchellh: (xshow getChildren) produces a String, and then run your arrow
19:08:05 <aavogt> the wiki http://www.haskell.org/haskellwiki/HXT tells you how to use writeDocument for writing files etc.
19:08:47 <mitchellh> aavogt: Thanks, I've been reading that page actually, and I see how to select elements, they just didn't have an example to extract them out of the structure.
19:09:16 <lispy|web> blackdog: GHC=someghc
19:09:25 <lispy|web> blackdog: does putting that at the start of the command line help?
19:09:59 <lispy|web> no man page for cabal
19:10:33 <lispy|web> blackdog: and --with-PROG=PATH    give the path to PROG, try --with-ghc=ghc-6.10.3
19:10:36 <lispy|web> or whatever
19:10:36 <blackdog> lispy|web: sadly no
19:10:50 <blackdog> i'll try that
19:10:53 <lispy|web> sorry, I can't read
19:11:11 <lispy|web> You already tried that :)
19:11:21 <aavogt> I'm pretty sure that the tutorial covers outputting the processed xml
19:11:21 <blackdog> oh, i thought you meant without the absolute path
19:11:22 <lispy|web> according to your post on hpaste
19:11:31 <blackdog> doesn't help anyway :)
19:11:31 <aavogt> but it isn't emphasized at all
19:11:34 <copumpkin> preflex: seen edwardk
19:11:35 <preflex>  edwardk was last seen on #haskell 4 days, 30 minutes and 8 seconds ago, saying: ddarius: i've been getting a lot of mileage out of iteratee-based monoidal tokenization and then doing the rest of parsing once i've bracketed out short segments of tokens involving balanced parens or known layout.
19:11:46 <copumpkin> zomg a ChilliX
19:13:00 <tommd> blackdog: Not claiming this is ideal, but I actually have aliases in my .bashrc "ghc683" and "ghc6103" to change the "ghc" and "ghc-pkg" softlinks in my PATH.
19:13:03 <lispy|web> blackdog: you may be in the territory, 'submit a bug report'
19:13:16 <tommd> It works ok and avoids lots of little issues dealing with cabal and other corners.
19:13:35 <lispy|web> tommd: sounds like gnu stow (or is it stash) would work
19:13:43 <blackdog> tommd: heh. yeah, i guess that'd work. just annoying, i'm building new versions of ghc every day...
19:14:01 <lispy|web> not that I ever understoond stow
19:14:06 <cpfr> hey is there any reason appendFile would keep appending more than once?
19:20:59 <Saizan>  
19:21:10 <Saizan> blackdog: --with-ghc or just -w worked?
19:21:29 <fbru02> hey guys stupid question , what is a spark ?
19:21:44 <copumpkin> a wannabe thread
19:21:55 <dons> fbru02: http://stackoverflow.com/questions/958449/what-is-a-spark-in-haskell/959001#959001
19:22:07 <blackdog> Saizan: no, it didn't
19:22:09 <fbru02> dons: thanks
19:22:21 <blackdog> aliasing ghc's allowed me to get do the next error, at least.
19:22:41 <blackdog> something about failing to parse the output of ghc-pkg dump
19:22:42 <dons> they're computations that you might like to have evaluated speculatively. if the runtime has spare time, it will schedule a thread to run your sparks. otherwise it will run them normally once they're needed.
19:23:03 <dons> so you can fill up spare time in your haskell program waiting on results by having some sparks around to be run.
19:23:17 <dons> not many languages support that.
19:23:34 <dons> one cool thing: you can turn any expression in haskell into a spark
19:23:40 <dons> just by adding a `par`
19:23:57 <Saizan> blackdog: ah, i don't think cabal-install is up to date to use it with 6.12, if that's your case
19:24:03 * dons wishes the whole programming world knew this
19:24:26 <fbru02> dons: cool, it is included in RWH right? ... i have to re-read the last chapters ....
19:24:33 <blackdog> dons: you want to teach the world to parallelise in perfect harmony?
19:24:42 <Saizan> dons: only a million haskell threads?
19:24:43 <blackdog> Saizan: ah, that'd be it. i'll grab 1.7
19:24:45 <dons> fbru02: that's right.
19:25:11 <dons> i think sparks, and how easy they are to use (i.e. always it is safe to add sparks) are killer features that are massively underused.
19:25:29 <cschneid> how do I go about modeling a problem in haskell? I'd like to replicate the craps blog post example that made the rounds.  Should I be thinking of a problem domain in terms of data, or functions, or.... eh?
19:25:46 <dons> build an interpreter for the problem.
19:25:46 <Saizan> blackdog: your installation of GHC should come with the newer Cabal, but you'd have to recompile cabal-install against it, and i don't think it'll build because of API changes, but i haven't tried
19:26:00 <dons> i.e. a AST for the commands, an environment to operate on, and a set of primtives to execute and reduce your AST
19:26:11 <dons> that's roughly how i build models of anything -- as interpreters
19:26:13 <dons> see xmonad.
19:26:19 <cschneid> dons: I understand all the words you're saying, but it's a bit high level :)
19:26:33 <dons> " go about modeling a problem in haskell?" -- your question is a bit high level :)
19:26:44 <cschneid> dons: you start with the language you're trying to build, and write code you'd expect to run. Then make it run?
19:26:50 <dons> try writing an interpreter for the game of craps
19:27:08 <blackdog> Saizan: oh, i see. ok, i can live without the cabal stuff for the moment i guess. will be easier when it's standard:)
19:27:08 <dons> it has operations, a stream of them, a state, semantics for what happens on each turn.
19:27:28 <dons> so in haskell, i would say modelling of any problem is done by working out the semantics , and writing an interpreter for the semantics.
19:27:49 <dons> at a high level, yes, everything is a language design problem
19:28:17 <dons> you'd end up with a DSL for writing craps games, along with a model that executes the game.
19:28:26 <blackdog> cschneid: it's got interesting parallels with BDD in rspec - you write the code you'd like to be able to write using Your Perfect Library (if it existed)
19:28:42 <ddarius> dons: You would hate this: http://lambda-the-ultimate.org/node/3575
19:29:19 <cschneid> blackdog: right. So the functions are the starting point, and the data model evolves from there to support the functions?
19:29:35 <dons> ddaris, why?
19:29:38 <cschneid> basically I know all the individual pieces of haskell in an academic sense, but I'm trying to tie them all together into something non-trivial
19:29:55 <blackdog> cschneid: urk. um, not quite. The distinction between functions and data in Haskell is not strong.
19:30:01 * dons -> makes winter soup, has a quiet beer, and ponders library design. bbl.
19:30:03 <Axman6> RRRAAAAAAAAAWWWWWWWRRRRRRRRRR
19:30:11 <Axman6> frigging ghc/cabal/everything!
19:30:31 <cschneid> thank you dons
19:30:34 <ddarius> dons: A comment from that page that is fairly accurate: "Totally Functional Programming (TFP) seems to fundamentally be about avoiding 'interpretation'"
19:30:51 <dons> aha
19:31:19 <fbru02> dons : havent thought about that way but , it seems that good code that  i write, code that isn't piled up in the main do block , you can say it is a dsl
19:31:30 <blackdog> Axman6: chill, it can't be that bad. What's the problem?
19:31:40 <Axman6> well, i can't use ghc
19:32:17 <absentia> xn/win shrink 4
19:33:03 <Axman6> updated libiconv, which seemed to downgrade it, making most of the things i have installed with macports break, so installed the binary version, and now cabal-install gives me "error: CPU you selected does not support x86-64 instruction set" with everything i try and install with cabal-install
19:33:12 <cpfr> so why would appendFile keep getting executed
19:35:00 <copumpkin> cpfr: have you pasted the code?
19:35:23 <blackdog> Axman6: eep. You are giving me further reasons to delay installing SL
19:35:36 <copumpkin> just build ghc head
19:35:41 <copumpkin> :P
19:36:25 <Axman6> that's what i'm frigging trying to
19:36:37 <Axman6> but it seems to require cabal-install
19:36:43 <Axman6> which crashes now
19:36:50 <cpfr> copumpkin, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9969#a9969
19:36:52 <Axman6> so i need to reinstall cabal-install
19:37:09 <Axman6> but i can't, becuase it's trying to use the wrong architecture
19:37:27 <copumpkin> is your ghc script still passing the extra parameters to the real ghc?
19:37:50 <Axman6> should be
19:39:15 <Axman6> how do you pass arguments to ghc with cabal-install?
19:39:27 <copumpkin> it's just calling the usual ghc script as far as I know
19:39:34 <copumpkin> so if that's correct, you shouldn't get that error
19:39:50 <copumpkin> does ghc work on its own?
19:40:16 <Axman6> "cannot do signed 4 byte relocation
19:40:34 <copumpkin> less `which ghc` :P
19:40:34 <jargonjustin> Is there a way to assert that a certain function calls error in quickCheck?
19:40:35 <blackdog> Axman6: i think blackh had a patch for that problem
19:40:42 <Axman6> it works if i add -opta -m32 -optl -m32
19:40:57 <copumpkin> yeah, so add that to your which ghc
19:41:33 <blackdog> http://hackage.haskell.org/trac/ghc/ticket/3550
19:42:18 <blackdog> oh, no, my mistake. that was "non-relocatable expression"
19:44:07 <Axman6> ok, well i edited my `which ghc` script, and things seem to be okish
19:45:37 <Axman6> fark!
19:45:39 <copumpkin> :o
19:45:43 <copumpkin> spoke too soon?
19:45:53 <Axman6> cabal-install still can't compile things like zlib
19:45:59 <Axman6> i'll try by hand
19:46:10 <Axman6> not that it will change anything, it'll still be using cabal
19:47:15 <Axman6> i keep getting:
19:47:16 <Axman6> /var/folders/-J/-JQP03F72RazIk+BYoiSW++++Tg/-Tmp-/21518.c:1:0: error: CPU you selected does not support x86-64 instruction set
19:48:14 <Saizan> use -v to see what's going on
19:48:34 <Axman6> i havem it doesn't show anything at all useful
19:48:37 <c_wraith> Axman, is this on osx?
19:48:37 <Axman6> even -v3
19:48:39 <Axman6> yes
19:48:43 <c_wraith> 10.6?
19:48:46 <Axman6> yes
19:48:46 <forgot> hey does anyone know a haskell library for moving the mouse, keyboard, etc, like java.awt.Robot, or Autoit?
19:48:48 <c_wraith> Someone else was reporting that.
19:48:52 <Saizan> at which stage does it die?
19:48:56 <c_wraith> I don't think anyone solved it then, either
19:49:05 <c_wraith> sounds like a ghc bug
19:49:06 <Saizan> maybe you need to add flags for the gcc invocation
19:49:08 <Axman6> Configuring zlib-0.5.2.0...
19:49:08 <Axman6> Flags chosen: bytestring-in-base=False
19:49:08 <Axman6> Dependency base <2.0 || >=2.2 && <5: using base-4.1.0.0
19:49:08 <Axman6> Dependency bytestring >=0.9: using bytestring-0.9.1.4
19:49:10 <Axman6> /var/folders/-J/-JQP03F72RazIk+BYoiSW++++Tg/-Tmp-/21541.c:1:0: error: CPU you selected does not support x86-64 instruction set
19:49:26 <Axman6> Saizan: i've tried, doesn't do anything
19:50:03 <Saizan> weird, it should show the program invocations
19:50:04 <orbitz> would it have been a good idea to make a Sequence typeclass or somethign that would unify List, String, ByteString, anythin glese that act slike a sequence?
19:50:27 <Axman6> ah, -v3 shows more: ("/usr/bin/ghc",["-c","/var/folders/-J/-JQP03F72RazIk+BYoiSW++++Tg/-Tmp-/21580.c","-o","/var/folders/-J/-JQP03F72RazIk+BYoiSW++++Tg/-Tmp-/21580.o"])
19:51:31 <Axman6> doesn't seem to be taking any notice of --gcc-option
19:52:14 <c_wraith> any chance it left the .o file behind so you could inspect it?
19:52:23 <c_wraith> Err, sorry.  it bombed trying to create the .o
19:52:24 <c_wraith> misread
19:52:45 <Axman6> yeah, no file left
19:54:54 <Axman6> FFFFFFFFFUUUUUUUUU >_<
19:55:37 <Axman6> ok, time to try the haskell platform
19:56:18 <cpfr> copumpkin, any idea?
19:57:13 <Axman6> orbitz: well, lists and strings are the same thing
19:57:15 <Saizan> it's not like the haskell platform does things differently..
19:57:25 <absentia> orbitz !@#$!@#$!@#$!@#$
19:57:31 <orbitz> Axman6: right, but ByteStrings aren't
19:57:36 * absentia checks to see if orbitz is still ignoring him.
19:57:38 <Axman6> are there darcs binaries?
19:59:05 <forgot> hey does anyone know a haskell library for moving the mouse, keyboard, etc, like java.awt.Robot, or Autoit?
19:59:29 <Axman6> doesn't sound like a very haskelly thing to do
20:00:00 <c_wraith> maybe the gtk library has that?
20:01:06 <absentia> what, like something useful ?
20:02:14 <Axman6> sounds like a VB thing ;)
20:07:00 <forgot> not a haskelly thing?
20:08:41 <Axman6> i doubt there are many, if any, libs to do it anyway
20:09:00 <Makoryu> What's this lib doing here?
20:09:52 <Saizan> i guess you'd want to move the mouse pointer, rather than the mouse :)
20:09:52 <pumpkin> it's rather platform-specific
20:10:00 <pumpkin> I'm not even sure how you'd do it in mac os
20:10:04 <Saizan> maybe you can generate X events?
20:10:10 <Axman6> i doubt you could pumpkin
20:10:14 <pumpkin> I remember making silly little programs in vc++ back in the day to troll my classmates
20:10:46 <Axman6> my friend used to make awesome guildwars bots in VB doing that sort of thing
20:11:20 <c_wraith> java does it cross-platform
20:11:23 <c_wraith> *shrug*
20:11:25 <gwern> you can move the mouse sort of with some module in xmonadcontrib
20:11:50 <c_wraith> Are you sure the gtk library can't do it?
20:12:00 <Trinithis> Anyone know a haskell library that can output some standard image format? (bmp, jpg, gif, tiff, png, ppm)
20:12:27 <Axman6> Trinithis: there are quite a few i believe
20:12:34 <Axman6> just check hackage
20:12:51 <Trinithis> ah ok
20:13:00 <pumpkin> aha, you can do it in mac os
20:14:14 <Gracenotes> hm. what's an adjective for "should be wary of because of poor design"?
20:14:28 <ivanm> Gracenotes: RUN AWAY!!!!
20:14:30 <ivanm> ;-)
20:14:42 <ivanm> FUBARed?
20:14:50 <cpfr> has System.Process given other people grief?
20:14:54 <Saizan> c_wraith: cross-platoform, or only affecting awt apps?
20:14:55 <Gracenotes> a word like "suspicious", but less about ulterior motive and more to do with general shakiness
20:15:06 <Gracenotes> I mean, to use in an essay -.-
20:15:20 <jmillikin> Is there a way to specify in a .cabal file "any version >= n of this dependency is OK"? I'm currently using "parsec >= 3.0.0", but I still receive an error when building: <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9973>
20:15:44 <ivanm> Gracenotes: oh, so FUBARed is out? :s
20:15:45 <jmillikin> I don't understand why it's using a higher version number than required if it causes a conflict.
20:15:55 <c_wraith> Saizan: On every platform that implements it.  It's part of the AWT class hierarchy, but it doesn't require you use an AWT GUI.
20:15:57 <Gracenotes> :x
20:16:21 <c_wraith> Saizan:  It's part of the 1.5 spec, I think.  Meaning that if the platform supports 1.5, it has it.
20:17:11 <Saizan> jmillikin: because "runghc Setup configure" doesn't have a sophisticated dependency solver, only a check, you can use "cabal install" for the smart solver
20:17:24 <jmcarthur> i suppose i could just benchmark this myself, but figure i could ask first. is there any overhead in something like this?: map MyNewtypeWrapper
20:17:32 <jargonjustin> I'd like to use QuickCheck to model check my program against a C implementation, is there any safe way to define 'instance Testable a => Testable (IO a)' without unsafePerformIO?
20:17:45 <jmcarthur> i imagine there must be, generally, since it might evaluate the spine of a list or something?
20:17:49 <pumpkin> jargonjustin: in quickcheck 2 there is I believe
20:18:01 <jargonjustin> pumpkin: quickcheck 2?
20:18:06 <Axman6> jmcarthur: what sort of overhead are you worried about?
20:18:28 <pumpkin> jmcarthur: there is
20:18:37 <jmcarthur> Axman6: by "overhead" i just mean "time spent traversing the list even though this doesn't change anything"
20:18:42 <jmillikin> Saizan: The error occurs in the Hackage auto-builder, so I don't have much control over which commands it executes.
20:19:01 <Saizan> jmcarthur: yes, that's like map id, which is not optimized away unless fused with other list operations
20:19:08 <pumpkin> lol
20:19:16 <pumpkin> @where ops
20:19:16 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
20:19:17 <Axman6> huh, i was wondering what was up there...
20:19:29 <bos> huh?
20:19:31 <pumpkin>  /mode +i maybe?
20:19:33 <Axman6> freenode under attack?
20:19:35 --- mode: ChanServ set +o Saizan
20:19:37 <beaublack>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:37 <co_cari_^ce_cute>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:37 <Cynthia19>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:38 <v_q>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:38 <co_pengen_ML_ma_>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:38 <zie>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:38 <Co2co_bt_nunggu_>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:38 <di-jual-anion-50>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:38 <^Male28[bth-cwe->  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:38 <cow_alone>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <cwo_imud>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <dCo0L>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <Co-cr_cw_bayaran>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <DoctorX29>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <co-papua-gede-pa>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <man_romantic>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <tolll>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <DropB0t>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <ickha>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <Cwo_caRi_tmen>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <co_do>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <myla_23>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <coco111>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <Cupank>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <latino0712>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <Guest65898>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <Drimette>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <co_kul_caripacar>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:39 <suricate>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:40 <EEATMEE>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:40 <^C0-KerjaJKT>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:40 <jual_jackdaniel>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:40 <Om^pgn_dielus>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:40 <LeD|oC>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:40 <siNgLeLady79>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:41 <co_chnz_21>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:41 <Zu|fi>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:41 <^co_biasa_aja>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:41 <PrAyInG^EyEs>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:41 <gay_siang2>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:42 <Aalmendra_Gimene>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:42 <co_criTmn>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:42 <Axman6> fuck
20:19:43 --- mode: Saizan set +i
20:19:44 <jmcarthur> wow
20:19:44 <pumpkin> someone's joinflooding us
20:19:44 <ivanm> wtf?
20:19:47 <c0___>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:19:47 --- mode: ChanServ set +o dibblego
20:19:51 <jmcarthur> :(
20:19:53 <Axman6> @where ops
20:19:54 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
20:19:57 <pumpkin> don't say I didn't warn :)
20:20:04 --- mode: Saizan set +l 500
20:20:06 <allbery_b> several ops already here
20:20:08 <ivanm> pumpkin: you did this, didn't you...
20:20:10 --- mode: ChanServ set +o bos
20:20:16 <pumpkin> ivanm: lol
20:20:20 <dons> ?
20:20:20 <dons> hmm
20:20:20 <dons> there we go
20:20:20 <dons> let freenode deal with it?
20:20:22 <Saizan> no one should be able to join now
20:20:23 --- mode: ChanServ set +oo dons dons
20:20:24 <pumpkin> phew
20:20:30 <R11coo_at_Serato>  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
20:20:33 <allbery_b> looks like freenode is dealing, yes
20:20:34 --- kick: ^co_biasa_aja was kicked by bos (bos)
20:20:36 <Axman6> dons: some  +i would be very useful
20:20:41 --- mode: Saizan set +b *!*n=ijase@24.42.187.*
20:20:42 --- kick: R11coo_at_Serato was kicked by Saizan (Saizan)
20:20:45 <pumpkin> dons: yeah, I normally set +i until the network figures it out
20:20:55 --- mode: ChanServ set +o allbery_b
20:20:55 --- kick: Om^pgn_dielus was kicked by dibblego (dibblego)
20:20:57 <Saizan> +i is setted
20:21:06 --- mode: dons set +i
20:21:08 --- kick: Zu|fi was kicked by bos (bos)
20:21:10 <Axman6> huh
20:21:11 <ivanm> Saizan: they all seemed to have different IPs...
20:21:20 <pumpkin> ivanm: it's a botnet, I guess
20:21:21 --- kick: co_kul_caripacar was kicked by bos (bos)
20:21:23 <ivanm> well, _someone_ doesn't like Haskell...
20:21:27 <jmcarthur> proxies or botnet
20:21:29 --- kick: co_pengen_ML_ma_ was kicked by allbery_b (allbery_b)
20:21:51 <pumpkin> ivanm: they were flooding other channels too I think
20:21:53 <ivanm> oh, wait, I thought Saizan was banning, but he was just kicking
20:22:00 <pumpkin> ivanm: probably just did a /list and picked the highest ones
20:22:00 --- kick: di-jual-anion-50 was kicked by bos (bos)
20:22:02 <allbery_b> too many to ban, I think
20:22:02 <Saizan> ivanm: yeah, i just used /kickban instead of /kick out of habit there
20:22:06 <ivanm> pumpkin: yeah
20:22:09 --- kick: beaublack was kicked by bos (bos)
20:22:16 --- kick: co_cari_^ce_cute was kicked by bos (bos)
20:22:16 <Axman6> #freenode must've been hit too, can't join without being sent to #overflow
20:22:22 --- kick: Cynthia19 was kicked by bos (bos)
20:22:25 --- mode: allbery_b set -o allbery_b
20:22:28 <ivanm> so, how many ops have their kicking boots on?
20:22:35 <pumpkin> Axman6: probably cause of all the legit users thinking to go report the flod :)
20:22:36 <dons> +i is set, btw.
20:22:41 <Axman6> yeah
20:22:44 <pumpkin> and +l
20:22:45 <ivanm> dons: which means?
20:22:46 <allbery_b> 4 currently
20:22:46 --- mode: dibblego set -o dibblego
20:22:48 <allbery_b> 3
20:22:50 <pumpkin> ivanm: invite-only
20:22:51 <ivanm> heh
20:22:53 <dons> "No client can join this channel unless they are listed in the invite exemption list"
20:22:54 <ivanm> pumpkin: ahhh
20:22:54 * allbery_b already backed out
20:22:56 --- kick: co_criTmn was kicked by bos (bos)
20:23:02 <ivanm> dons: so where's this magical list?
20:23:04 --- mode: Saizan set -l
20:23:10 --- kick: suricate was kicked by bos (bos)
20:23:14 <ivanm> Saizan: that was the +l?
20:23:17 --- mode: Saizan set -o Saizan
20:23:25 <dons> there is no list. that's the magic!
20:23:27 --- kick: zie was kicked by bos (bos)
20:23:35 <Saizan> ivanm: a limit on the users, i didn't know about +i :)
20:23:48 <bos> that's a pretty big attack.
20:23:53 <bos> what's +i?
20:23:57 <pumpkin> invite-only
20:24:08 <Axman6> but, obviously it doesn't work
20:24:19 <pumpkin> you need to /invite nick #channel to let them in, and you must be an op to do so
20:24:22 <dons> i just set it
20:24:26 <dons> no one else is joining
20:24:30 <ivanm> dons: so if my net kicks out or something, I can't get back on? :o
20:24:39 <allbery_b> temporarily
20:24:40 <dons> right
20:24:46 <dons> you can ask for an invite
20:24:51 <ivanm> *nod*
20:24:53 --- kick: independent was kicked by bos (bos)
20:24:57 <dons> hmm. we don't have join throttling.
20:25:00 <dons> we can add that.
20:25:00 <ivanm> so there _is_ an escape clause...
20:25:10 <allbery_b> it might be smart to have some uber-ops on the exemption list in case we get hit by a netsplit while +i
20:25:33 <dons> +J is join throttling. "This mode takes one parameter of the form "x,y", where x and y are positive integers. These two
20:25:33 <dons> integers control the rate at which users may join the channel. The limit is roughly y users every x*y
20:25:33 <dons> seconds, but the algorithm allows for bursts."
20:25:33 <dons> shall we turn that on anyway?
20:25:48 <dons> what's a good rate?
20:25:49 <pumpkin> sounds reasonable
20:25:53 <Makoryu> Whoa, *automatic* join throttling?
20:25:59 <Makoryu> I've only ever seen it done with a bot
20:26:04 --- kick: gogonkt was kicked by bos (bos)
20:26:06 <dons> yay freenode :)
20:26:17 <pumpkin> it just means it sets +l every so often, right?
20:26:18 <Saizan> allbery_b: maybe ops can invite themselves via chanserv?
20:26:21 <jmcarthur> that's kind of cool
20:26:53 <bos> ok, i think that's all the bots kicked.
20:27:02 <pumpkin> yay
20:27:17 <jmcarthur> that was inconvenient
20:27:24 <dons> shall I undo the join ban?
20:27:36 <jmcarthur> probably
20:27:45 <jmcarthur> i think freenode handled the majority of those
20:27:45 --- mode: dons set -i
20:28:12 <pumpkin> *drum roll*
20:28:18 <dons> if someone wants to work out  the average join rate, based on http://t0x.in/ircfreenode.html#cm07  . we could turn on auto join flood handling.
20:28:28 <dons> ...
20:28:40 <jmcarthur> err
20:28:49 <Axman6> sounds like a job for... HASKELL! <supre hero music/>
20:28:52 <Axman6> super too
20:29:07 <jmcarthur> i think these need some bans
20:29:18 <jmillikin> Guess I'll re-ask my question, since it got buried in all the noise.
20:29:19 <Axman6> jmcarthur: won't do anything
20:29:20 <jmillikin> Saizan: The error occurs in the Hackage auto-builder, so I don't have much control over which commands it executes.
20:29:29 <ivanm> jmillikin: so _you_ caused it! :o
20:29:32 <ivanm> my apologies, pumpkin :p
20:29:38 <pumpkin> :)
20:29:48 <pumpkin> damn, that bot attack flipped my arrows
20:30:01 <allbery_b> "independent" was not one of the spewers, according to my scrollback
20:30:07 <jmcarthur> oh okay
20:30:10 <Saizan> jmillikin: then you're screwed :)
20:30:25 <jmillikin> Oh dear. Does that mean it'll always fail to build on hackage?
20:30:27 <jmcarthur> must have been a mistake to kick independent then
20:30:37 <copumpkin>  /sajoin :P
20:30:47 <allbery_b> a little overcautious.  understandable under the circumstances
20:30:53 <hackagebot> gitit 0.6.4 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
20:30:54 <allbery_b> I'd guess freenode got the real ones
20:31:04 <bos> jeepers, pandoc is awesome.
20:31:16 <Saizan> jmillikin: it'll work when they'll upload a new version of network, i think
20:31:18 <bos> i'll never have to write wordpress posts using its shitty web UI again!
20:31:25 <Axman6> bos: yeah :)
20:31:36 <Axman6> i couldn't get its language highlighting to work :\
20:32:12 <Saizan> jmillikin: however the idea is to switch to the new hackage-server as soon as that's done that would solve this by having build reports from users and uploadable docs for each package
20:32:25 <Saizan> jmillikin: it needs volunteers to complete the coding though
20:32:39 <copumpkin> there's a beta running on sparky iirc
20:32:44 <Axman6> you know what would be awesome? if there were a charting library like Chart, that didn't require gtk2hs
20:32:52 * copumpkin stares at Axman6
20:33:13 <jmcarthur> or if gtk2hs was properly cabalized and on hackage
20:33:22 <Axman6> and worked on OS X
20:33:22 <Makoryu> Axman6: Hmm, it's almost as if you don't exclusively use Linux!
20:33:23 <copumpkin> and didn't require gtk...
20:33:47 <Axman6> copumpkin: it requites cairo, which is part of gtk2hs
20:33:50 <Axman6> r*
20:34:03 <copumpkin> Axman6: I meant, it would be awesome if gtk2hs were properly cabalized, and didn't require gtk :P
20:34:17 <Axman6> heh
20:34:23 <Saizan> the truth is that haskell is how microsoft is trying to kill apple's market
20:34:28 <Makoryu> copumpkin: Just reimplement gtk2hs on top of GLUT
20:34:32 <copumpkin> :O
20:35:07 <Makoryu> (Since GLUT seems to work everywhere, and is even part of the Haskell platform...)
20:35:08 <Saizan> by making developers switch to linux, of course
20:36:22 <Makoryu> Saizan: Fridge logic prompts me to remind you that Apple is a hardware company ;)
20:37:03 <Vanadium> gtk2hs is discouraging~
20:37:05 <Makoryu> ....And that a lot of new Mac users over the past year or two have been in it for the iPhone development.
20:37:09 <Makoryu> Yes.
20:37:11 <Makoryu> Yes it is.
20:37:17 <ivanm> Makoryu: "fridge logic"?
20:37:34 <Vanadium> Saying this as a total gtk(mm) fan~
20:38:14 <Makoryu> ivanm: ....It is very cold... in space. Inside a fridge.
20:38:22 <Makoryu> Which is also in space.
20:38:47 <allbery_b> I thought the main problem with cabalizing gtk2hs was the custom c2hs; I'm unclear on whether the customization can be merged
20:40:58 <bos> does the xhtml library allow me to traverse a html document, or just to generate one
20:40:58 <bos> ?
20:41:08 <Saizan> generate
20:41:17 <dons> generate only. its a ppr combinator set
20:41:20 --- mode: ChanServ set -o dons
20:41:24 <bos> bummer.
20:41:29 --- mode: bos set -o bos
20:41:51 <bos> i was hoping i might be able to get at the body of a chunk of html generated by pandoc without having to reparse the bloody thing.
20:41:54 <monochrom> both hxt and haxml can generate and parse.
20:42:05 * ivanm wonders why xchat didn't show bos as being a chanop but did for dons...
20:42:08 <A1kmm> hmm, does ghc with functional dependencies consider an instance undecidable even if it is decidable through functional dependencies?
20:42:39 <A1kmm> e.g. I have class ArithmeticExpr a e | e -> a
20:42:50 <A1kmm> instance (Floating a, ArithmeticExpr a e) => Num e
20:43:06 <bos> monochrom: but to use haxml, i'd have to figure out how to use it :-(
20:43:28 <bos> it's a wee bit lacking in documentation.
20:43:36 * bos wants xpath
20:43:43 <A1kmm> and ghc gives an error saying I need to enable the undecidable instances extension... but a is decidable using the functional dependency on ArithmeticExpr
20:44:01 <copumpkin> A1kmm: ghc isn't very smart about decidability
20:44:29 <copumpkin> it just says "yo, you called one type function from another, I'm going to say you're undecidable" (or similar oversimplifications)
20:45:22 <allbery_b> yeh, "this exceeds my easy threshold, turn on wizard mode"
20:45:49 <bos> haxml exceeeds my easy threshold :-(
20:46:05 <A1kmm> copumpkin: hmm, I'm not sure if it will do the right thing if I enable the undecidable instances extension though.
20:46:08 <allbery_b> (at which point it becomes a lot smarter but may start contemplating its navel without warning)
20:46:16 <copumpkin> anyone have a one-liner gauss-jordan elimination on list-of-list matrices? :P
20:46:28 <pikhq> A1kmm: It may in fact be undecidable if it does the right thing. ;)
20:47:57 <bos> it makes me sad to reach for python and lxml for html mangling
20:48:37 * jmcarthur tries to think of a good way to @remember what allbery_b just said without it getting too out of context
20:49:10 <allbery_b> sometimes the potential out of context interpretation is the best part :)
20:52:19 <jmcarthur> @remember allbery_b [on UndecidableInstances] "this exceeds my easy threshold, turn on wizard mode" (at which point it becomes a lot smarter but may start contemplating its navel without warning)
20:52:19 <lambdabot> It is forever etched in my memory.
20:56:22 <Axman6> oh man, today is going to be a really long day or compikling and recompiling >_<
20:56:27 <Axman6> compiling too
20:57:45 <Axman6> bos: was there any reason you chose to use Chart for criterion?
20:58:07 <bos> Axman6: it was there?
20:58:13 <Axman6> fair enough
20:58:23 <bos> it's pretty nice, generates nice output, and is nice to use.
20:58:35 <bos> why, are there alternatives?
20:58:37 <Axman6> except it requires gtk2hs
20:59:03 <Axman6> there's a graphviz one, probably a gnuplot one (i haven't looked at either)
20:59:12 <dons> gnuplot bindings are fine.
20:59:19 <dons> much as you'd expect gnuplot bindings
21:00:12 <bos> graphviz is useless for this purpose.
21:00:24 <ivanm> what are you trying to do?
21:00:34 <Axman6> bos: and gtk2hs is totally broken on OS X (which despite what many people seem to think, is actually quite a popular platform for haskell development)
21:00:34 <bos> ivanm: it's the criterion charting stuff
21:00:35 <tommd> did, criterion
21:00:38 <ivanm> ahhh
21:00:43 <ivanm> bos: and Chart isn't good enough?
21:00:52 <bos> ivanm: no, Axman6 was asking
21:00:55 <ivanm> ahhh
21:00:56 * ivanm doesn't like the gnuplot bindings on hackage
21:01:02 <bos> Axman6: i wish i could do something about that.
21:01:09 <Axman6> i do too
21:01:21 <ivanm> I was thinking of writing new ones, but in the end I couldn't be bothered since I wasn't likely to need them any time soon
21:01:26 <Axman6> since trying to fix things has left me with a totally broken haskell world on my computer
21:01:58 * ivanm just wishes graphviz wouldn't keep drawing the call graphs he's making so _wide_
21:03:06 <Draconx> graphviz has several tools that implement a variety of layout algorithms.
21:04:40 <ivanm> Draconx: I know
21:04:52 <ivanm> I'm using dot because of clusters, etc.
21:04:56 <Draconx> even 'neato' is too wide?
21:05:06 <ivanm> neato draws the wrong kind of graphs
21:05:25 <Draconx> ah.
21:05:45 <ivanm> yup, neato ignores clusters
21:17:06 <samuelhopkins> can anyone help me install GHC on OS X?
21:17:39 <jmcarthur> > let cycle = fix . mappend in cycle map (*2) [1..3]
21:17:39 <lambdabot>   [2,4,6,2,4,6,2,4,6,2,4,6,2,4,6,2,4,6,2,4,6,2,4,6,2,4,6,2,4,6,2,4,6,2,4,6,2,...
21:17:44 <samuelhopkins> on the packages i always get a grayed out install where i should be able to click to install
21:17:50 <jmcarthur> totally useful definition for cycle
21:19:27 <jmcarthur> maybe useful for pointfree code or for some monoids that i can't think of right now
21:20:03 <copumpkin> :t let cycle = fix . mappend in cycle
21:20:05 <lambdabot> forall a. (Monoid a) => a -> a
21:20:42 <copumpkin> > let cycle = fix . mappend in cycle (Dual [1..3])
21:20:46 <lambdabot>   mueval-core: Time limit exceeded
21:20:54 <jfoutz> what's the best way to do utf8 decoding?
21:21:01 <jmcarthur> :t let cycle = fix . mappend in cycle map
21:21:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:22:07 <jmcarthur> aw that Dual experiment kind of disappoints me
21:22:50 <jmillikin> jfoutz: utf8-string seems to be the best-supported option.
21:23:01 <jfoutz> hmm. ok, thanks.
21:23:15 <copumpkin> Data.Text might do what you need
21:23:17 <jmcarthur> @instances Monoid
21:23:17 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:23:33 <jmcarthur> ooh endo
21:23:43 <copumpkin> infinite composition?
21:23:54 <copumpkin> that doesn't look good
21:24:09 <jmcarthur> heh
21:24:17 <copumpkin> > let cycle = fix . mappend in cycle ()
21:24:18 <lambdabot>   ()
21:24:23 <jmcarthur> shouldn't it basically be fix?
21:24:26 <samuelhopkins> does anyone know why it won't let me install? i have xcode installed
21:24:38 <copumpkin> > let cycle = fix . mappend in cycle (Any [False, True])
21:24:39 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
21:24:39 <lambdabot>         against inferred type ...
21:24:55 <copumpkin> > let cycle = fix . mappend in cycle (Any True)
21:24:56 <lambdabot>   Any {getAny = True}
21:25:06 <copumpkin> > let cycle = fix . mappend in cycle (Any False) -- won't terminate?
21:25:10 <lambdabot>   mueval-core: Time limit exceeded
21:25:21 <jmcarthur> the parens are unnecessary :)
21:25:35 <copumpkin> > let cycle = fix . mappend in cycle Any True
21:25:37 <lambdabot>   Any {getAny = True}
21:25:41 <copumpkin> funkeh :)
21:26:03 <Makoryu> samuelhopkins: What OS version and CPU arch are you on? And what installer are you using?
21:26:15 <copumpkin> > let cycle = fix . mappend in cycle Sum 1 > (3 :: Natural)
21:26:16 <lambdabot>   Couldn't match expected type `Data.Monoid.Sum a'
21:26:17 <lambdabot>         against inferred t...
21:26:24 <copumpkin> > let cycle = fix . mappend in cycle Sum 1 > Sum (3 :: Natural)
21:26:25 <lambdabot>   True
21:26:44 <samuelhopkins> OS X 10.5.8, Intel
21:26:55 <jmcarthur> > let cycle = fix . mappend in cycle Endo (1:) `appEndo` []
21:26:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:26:59 <jmcarthur> ha!
21:27:15 <samuelhopkins> ghc-6.10.4-i386.pkg
21:27:28 <Makoryu> samuelhopkins: Can you tell me where you downloaded this from?
21:27:35 <samuelhopkins> haskell.org
21:27:55 <samuelhopkins> http://haskell.org/ghc/download_ghc_6_10_4.html
21:28:56 <Makoryu> samuelhopkins: Okay, now as for Xcode
21:29:20 <samuelhopkins> i had to download iphonesdk to get that
21:29:21 <samuelhopkins> bleh
21:30:09 <Makoryu> Hmm, so you ought to have a recent enough version, if you got it with the iPhone SDK
21:30:28 <Makoryu> ....Free hard drive space? ¯\O_o/¯
21:30:32 <samuelhopkins> it's not that the install fails, it's like it won't let me click install at all
21:31:01 <samuelhopkins> i have 100+ gigs available
21:31:32 <Makoryu> samuelhopkins: Wait a second, did you install the BSD subsystem? (I can't think of a reason why you wouldn't have, but I gotta ask)
21:32:04 <samuelhopkins> what does that mean?
21:32:21 <samuelhopkins> i probably did not then
21:32:28 <Makoryu> UNIX software that most Mac apps don't need
21:32:41 <Makoryu> GHC does need it though
21:34:26 <samuelhopkins> how do i get it?
21:34:46 <Makoryu> samuelhopkins: It's included with either the OS X or the Xcode installers. I don't remember which.
21:35:31 <samuelhopkins> ahhh thanks
21:35:46 <thoughtpolice> ? I just upgraded to snow leopard and there was no reason to install any 'bsd subsystem' that I can remember
21:36:03 <thoughtpolice> I just installed xcode from the install DVD and anything GHC needs is there
21:36:04 <ivanm> gah, I'm getting a fromJust error from somewhere
21:36:26 <ivanm> but when I try to track it down by replacing it with "fromMaybe (error "foo")", it still complains about fromJust! :@
21:36:50 <ivanm> could this be from a library I'm using?
21:36:54 <Makoryu> samuelhopkins: But honestly, if it's not that, I have no idea what the problem is. Let's hope it says something on the console...
21:37:02 <copumpkin> thoughtpolice: you're alive!!!
21:37:17 <ChilliX> Axman6: What's your problem on SL?
21:37:28 <Axman6> god, what isn't my problem with SL :P
21:37:33 <thoughtpolice> copumpkin: yes, and about to be doing homework :P
21:37:53 <ChilliX> hehehe
21:37:57 <bos> dons: still around?
21:37:59 <ChilliX> I mean with ghc and SL
21:38:10 <copumpkin> thoughtpolice: :O
21:38:13 <Makoryu> ChilliX: Sup. I've got a problem: I get segfaults!
21:38:17 <ChilliX> (SL does actually work quite nicely for me, except for ghc)
21:38:30 <Axman6> ChilliX: yeah same here
21:38:33 <ChilliX> Makoryu: on Snow Leopard?
21:38:36 <Axman6> ghc and macports
21:38:36 <Makoryu> I ran the "parallel hello world" the other day and it segfaulted. I'm freakin' out, man
21:38:37 <Makoryu> Yeah
21:38:49 <thoughtpolice> ChilliX: yes, it's quite nice. GHC is the only real issue :)
21:39:14 <thoughtpolice> and I just haven't had enough time lately to try and get any sort of port working, although there was conformation of 6.8.3 getting to work on SL, which is good
21:39:23 <ChilliX> Axman6: did you use a pre-build ghc or build yourself
21:39:31 <ChilliX> Makoryu: and you,which ghc?
21:39:31 <Makoryu> Axman6: I'm not at all surprised that Macports ate its own face off and beat itself to death with its own skull. It's all around just a horrible piece of software
21:39:32 <thoughtpolice> ChilliX: btw, I think that OpenCL would be really cool to use with your accelerate package :)
21:39:45 <Makoryu> ChilliX: Binary distribution of Haskell platform
21:39:47 <thoughtpolice> ChilliX: and having it in SL by default is really awesome :)
21:39:50 <Axman6> thoughtpolice: me too
21:39:52 <ChilliX> thoughtpolice: oh, I think so, too :)
21:40:33 <Axman6> ChilliX: if your work ended up with a really nice way to get past all the OpenCL boilerplate, that would be totally awesome
21:40:58 <jargonjustin> Is there special syntax to take a record and return a copy with certain fields updated?
21:41:22 <ChilliX> Makoryu: did you file a bug report?
21:41:45 <Makoryu> jargonjustin: foo { bar = baz } -- bar is updated, foo's other fields are copied
21:43:15 <jargonjustin> Makoryu, Thank you.
21:43:15 <Axman6> just have something like contexts <- getContexts [GPU,CPU]; kernel <- compileKernel contexts src; runKernel kernel [inputs...]
21:43:15 <Makoryu> ChilliX: Nope. I just sort of despaired and trolled people out of frustration
21:43:15 <ChilliX> Axman6: yep, I hope that we'll get there, but for the moment it'll first be CUDA (we already have code for that; OpenCL needs to be written from scratch)
21:43:15 <copumpkin> we needz magick CUDA -> OpenCL translat0r
21:43:15 <Makoryu> ChilliX: And it worked out pretty well, too. The trolling I did that night had a tally of something like 200 replies by the next morning
21:43:15 <Axman6> ChilliX: hopefully OpenCL shouldn't be too hard, since it's supposefd to be quite close to CUDA
21:43:15 <Axman6> rage!
21:43:15 <ChilliX> Makoryu: please do report a bug, I am trying to stay on top of what's working on SL and what not; trac tickets make that easier
21:43:15 <Axman6> how are you supposed to build ghc?
21:43:52 <Axman6> wait, missing a step
21:43:52 <Axman6> heh
21:44:04 <ChilliX> Axman6: yeah, I'd hope OpenCL to be similar enough to CUDA that it is not too much work
21:44:21 <ChilliX> Axman6: you are building ghc on SL?
21:44:27 <Makoryu> ChilliX: But the same program worked fine for Axman6, so I figured it must somehow be my install, anyway
21:44:28 <Axman6> trying to
21:44:33 <ChilliX> Axman6: that should work fine, only ghci won't work properly
21:44:35 <copumpkin> it'd be nice if there were a package for mac os that didn't need tweaking on SL
21:44:43 <Axman6> ChilliX: oh really? how come?
21:44:58 <ChilliX> Makoryu: maybe differebnt versions (that you and Axman6 used?)
21:45:05 <Axman6> i had 6.10.3
21:45:29 <Axman6> ok, well now. can't build ghc-HEAD either >_<
21:45:38 <Axman6> utils/ghc-cabal/ghc-cabal.hs:13:7:
21:45:38 <Axman6>     Could not find module `Distribution.Simple.Program.HcPkg':
21:45:38 <Axman6>       Use -v to see a list of the files searched for.
21:45:55 <Makoryu> Oh, yeah, I'm on 6.10.4
21:46:13 <ChilliX> I built ghc head on SL with 6.10.4 two times today already
21:46:28 <ChilliX> so, not quite sure what's wrong on your end
21:46:53 <ChilliX> did you "make distclean" ?
21:48:10 <Axman6> just tried, no dice >_<
21:48:15 <jargonjustin> If I'm wrapping a C library, is there a good way to embed sizeof(my_complicated_struct) at compile time?
21:48:33 <bd_> you could put it in a global const size_t field
21:48:52 <jargonjustin> bd_: I didn't write the library, if I don't have to ship any C code I'd be happier.
21:49:07 <bd_> ah, not sure if FFI lets you embed C code inline like that
21:49:43 <Axman6> ChilliX: can i check with you and see if i'm doing things right?
21:49:46 <jargonjustin> bd_: yeah, I assumed not, but wanted to check just in case. Haskell continues to surprise in (mostly) pleasant ways ;-)
21:50:07 <bd_> I seem to have a vauge memory that there's a way, but don't quote me on that :)
21:50:48 <Axman6> i've downloaded the source snapshot, unpacked it, run darcs get inside it, then darcs-all get (the first one probably isn't needed, but oh well), then ran ./configure --prefix="$HOME/usr", then make, and it dies with the error above
21:51:28 <ChilliX> Axman6: you should run "sh boot" before configure
21:51:36 <ivanm> @hoogle Exception -> String
21:51:36 <lambdabot> Control.OldException assertions :: Exception -> Maybe String
21:51:36 <lambdabot> Control.OldException errorCalls :: Exception -> Maybe String
21:51:36 <lambdabot> Control.OldException userErrors :: Exception -> Maybe String
21:51:38 <ChilliX> (in case any of the configure scripts schanged)
21:51:39 <Axman6> right, i did that, sorry
21:52:05 <ChilliX> What the newest patch wehn you do "darcs changes"?
21:52:08 <ivanm> is there an Exception -> String function for extensible exceptions?
21:52:29 <Axman6> Sat Sep 26 20:36:10 EST 2009  Ben.Lippmeier@anu.edu.au * Remove long rotted configure support for Windows DLLs
21:52:37 <Saizan> ivanm: what should it do?
21:53:05 <ivanm> Saizan: just wanted to know if there was a way of telling what the error message was
21:53:27 <ivanm> s/message was/was about/
21:53:37 <ChilliX> Axman6: ok, just in case, get rid of that one patch (the one from ben you just mentioned) — with "darcs unpull"
21:53:41 <ChilliX> then we have the same tree
21:53:45 <Saizan> ivanm: you could just use show
21:53:57 <ivanm> duh ;-)
21:53:59 <ivanm> thanks Saizan
21:54:35 <Axman6> ChilliX: how do say i only want to unpull that one patch?
21:54:46 <Axman6> i's asking me about the rest of the patches
21:55:25 <ChilliX> say "y" for the first one
21:55:28 <ChilliX> then "d" for done
21:55:30 <Axman6> yep
21:55:31 <Axman6> ah ok
21:55:47 <Axman6> Tue Sep 29 11:27:17 EST 2009  Ian Lynagh <igloo@earth.li> * Fix making Windows bindist and installer
21:55:52 <Axman6> is the latest patch
21:56:03 <Axman6> then what?
21:56:29 <ChilliX> hmm, then you got a different order than I did... :/
21:57:38 <Axman6> ok, the name of the snapshot i downloaded is: ghc-HEAD-2009-06-25-ghc-corelibs-testsuite.tar.gz. i unpacked that, then ran ./darcs-all
21:57:52 <ChilliX> btw, when you did ./darcs-all get, did it actually donwload anything
21:58:06 <Axman6> yeah, something like 400 patches
21:58:09 <ChilliX> or just go through the list of packages and say they are already available?
21:58:28 <ChilliX> did you really do ./darcs-all get or rather ./darcs-all pull?
21:58:38 <Axman6> get i think
21:58:59 <Axman6> i'll start again and try (i hoppened to open the gz file twice, so i've got two copies :)
21:59:16 <Axman6> bah, ok i aleady used that one
21:59:33 * Axman6 rm -rf's and starts again
21:59:54 <ChilliX> ok, I'll get all the latest patches, too
21:59:57 <ChilliX> and try on my box
22:00:02 <Axman6> cheers
22:01:23 <ChilliX> Axman6: do "./darcs-all get" and then "./darcs-all pull" (the former gets repos that are needed and not yet available, whereas the latter pulls all the latest patches into the already existing repos)
22:01:45 <Axman6> ok, will do when the gz file has finished being extracted
22:02:21 <Axman6> ChilliX: if only there was going to be more free time at SAPLING, we could totally get ghc fixed on SL :P
22:03:37 <Axman6> also, you should come to the pub with blackdog and I afterwards
22:05:28 <ivanm> gah! I've hit a but in upstream graphviz bug that hasn't been touched since 2007! :@
22:05:35 <copumpkin> :o
22:05:45 <copumpkin> pure haskell graph drawing now
22:06:30 <Axman6> yeah, we need a nice graphing library :(
22:06:30 <ivanm> copumpkin: you write it and I'll use it if it's any good ;-)
22:06:43 <ivanm> http://www.graphviz.org/bugs/b1258.html
22:07:02 <ChilliX> Axman6: beer after sounds like a good plan
22:07:09 <Axman6> excellent :)
22:08:23 <Axman6> maybe we can get benl to come along too (and possibly Clem, though having a beer with my lecturer seems a little odd)
22:09:56 <Axman6> ChilliX: i'm doing a ./darcs-all pull at the moment by the way. looks like it may well have been my problem
22:10:05 <ivanm> Axman6: as long as you don't buy him a beer, it's OK (ethically, etc.)
22:10:13 <Axman6> heh, true
22:10:24 <Axman6> i don't have the cash to be buying beers for people anyway :P
22:10:39 <Axman6> not again...
22:10:56 <ivanm> anyone here read Coders at Work?
22:12:07 <copumpkin> might be a good idea to kick the people who joined at the same time as the k-lined people
22:12:11 <copumpkin> maybe not though
22:12:23 <copumpkin> like kardel
22:12:45 <copumpkin> I'd guess kardel will spam if he isn't k-lined before
22:13:21 <hackagebot> dbus-core 0.3 - Low-level DBus protocol implementation (JohnMillikin)
22:13:37 <jmillikin> gods I hope it builds this time
22:13:49 <ivanm> heh
22:13:56 <ChilliX> Axman6: mine is still pulling, too
22:14:17 * Axman6 hits a a few dozen times
22:14:29 <arquebus> ivanm- have you checked out software engineering radio? a lot of people in that book are interviewed there
22:14:33 <ChilliX> Axman6: the trick is to pass the "-a" option
22:14:48 <Axman6> ah, handy :)
22:14:49 <ivanm> arquebus: nope
22:14:53 <arquebus> www.se-radio.net
22:15:00 <ChilliX> (sorry, should have mentioned that earlier)
22:15:17 <ivanm> gah, what does this even mean? "dot: mincross.c:998: install_in_rank: Assertion `(g)->u.rank[r].n <= (g)->u.rank[r].an' failed."
22:15:34 <Axman6> s'all good :)
22:15:50 <Axman6> == Required repo libraries/integer-simple is missing! Skipping
22:15:52 <Axman6> :O
22:16:03 <jfoutz> copumpkin: Data.Text looks better. the Codec.Binary.UTF8 one dosn't do null correctly.
22:16:34 <jmillikin> Is Data.Text planned to replace String or something? I've never heard about it until today, but it looks very useful.
22:16:57 <Gracenotes> ivanm: an error in the part when it tries to minimize the number of edge crossings. I'm supposing it checks to make sure that the rows set up in the ranking phase are valid?
22:17:30 <ivanm> *sigh* bloody stupid graphviz
22:17:47 <Gracenotes> when it makes a partial order of the graph
22:18:14 <jfoutz> oh. hmm. nevermind, it looks like java is just sort of dumb about encoding.
22:18:32 <Gracenotes> is your graph particularly complicated?
22:18:39 <ivanm> maybe I can't have as many clusters everywhere...
22:18:52 <ChilliX> Axman6:  did you do the "./darcs-all get" before the pull?
22:18:58 <Axman6> yep
22:19:08 <copumpkin> the get should be fetching that lib for you
22:19:08 <ChilliX> Axman6: that should have gotten the integer-simple!
22:19:24 <ChilliX> when pull is finished
22:19:29 <ChilliX> run get again
22:19:33 <Axman6> i'm doing another darcs-all get now
22:19:54 <Axman6> (it didn't do anything before, but now it's doing quite a bit)
22:20:23 <Gracenotes> the assert error happens in a function whose description is "install a node at the current right end of its rank"
22:20:35 <ChilliX> ok
22:21:05 * copumpkin guesses tiwie is another bot
22:21:09 <copumpkin> along with kardel :P
22:21:23 <ChilliX> Axman6: when its done, do: sh boot; ./configure
22:21:38 <Axman6> yep
22:24:38 <ChilliX> Axman6: is it building now?
22:24:44 <Axman6> configuring
22:24:51 <ChilliX> (mine is compiling the stage1 compiler)
22:25:19 <Axman6> ok, looking good, got past where it died before
22:25:25 <Gracenotes> ivanm: okay. so n is "number of nodes in this rank", and an is "globally allocated number of nodes". So there are more allocated nodes than actual nodes, which I suppose is a problem
22:25:26 <ChilliX> :)
22:25:40 <ivanm> Gracenotes: :s
22:25:57 <Gracenotes> no idea when the values get changed to be what they are
22:25:57 <ChilliX> I do like how expose in SL includes minimised windows as smaller images
22:26:10 <Gracenotes> hm, have you fixed it now?
22:26:25 <hackagebot> sized-types 0.1 - Sized types in Haskell. (AndyGill)
22:26:26 <Axman6> ChilliX: it's nice, unless you have porn minimised to the dock :P
22:26:37 <ChilliX> lol
22:26:39 <copumpkin> @hackage sized-types
22:26:40 <lambdabot> http://hackage.haskell.org/package/sized-types
22:26:40 * Axman6 this hasne't happened to me, but it's the first thing i thought when i saw it
22:27:04 <copumpkin> that looks nice
22:27:17 <Gracenotes> porn is a very important factor in the adaption of new technologies, both a positive one and a negative one
22:27:31 <Gracenotes> or adoption
22:27:38 <Veinor> haskell porn?
22:27:44 <copumpkin> type porn
22:27:45 <ChilliX> naked lambdas!
22:27:50 <Gracenotes> er. or I suppose it could be a neutral one.
22:28:09 <Veinor> oh yeah baby, unsafePerformIO
22:28:09 <Gracenotes> more like end user technologies :)
22:28:30 <ChilliX> Veinor: didn't you know that you should practice safe sex?!?
22:28:41 <copumpkin> lol
22:28:43 <Veinor> I'm barebacking it!
22:29:11 <Axman6> oh yeah baby, you're so naughty, unsafely perform that IO!
22:31:04 <Draconx> unsafeCopulate
22:31:12 <Axman6> "oh so you're a SexT eh? hawt"
22:32:13 <tommd> @vixen an innocent lady like you shouldn't be in a dirty room like this.
22:32:13 <lambdabot> i'd say i like
22:32:19 <Axman6> what on earth is the point of type T = T T? o.O
22:32:32 <tommd> Axman6: Peano number?
22:32:39 <tommd> Or is that the only constructor?
22:32:46 <copumpkin> it isn't allowed
22:32:46 <Axman6> the only one
22:32:46 <Gracenotes> ..that can only represent infinite
22:32:48 <copumpkin> unless it's newtype
22:32:51 <copumpkin> or data
22:33:00 <Axman6> hmm
22:33:03 <copumpkin> if it's newtype
22:33:05 <Axman6> i'm confused now
22:33:09 <Gracenotes> data T = T !T -- uh-oh
22:33:10 <copumpkin> then it's effectively EmptyDataDecls
22:33:11 <Axman6> http://hackage.haskell.org/packages/archive/gnuplot/0.3.3/doc/html/Graphics-Gnuplot-Graph-ThreeDimensional.html#t%3AT
22:33:27 <Axman6> ChilliX: oh no, it died :O
22:33:33 <Axman6> fark!
22:33:37 <Axman6>      error: CPU you selected does not support x86-64 instruction set
22:33:40 <Axman6> frigging cabal!
22:33:46 <copumpkin> Axman6: huh? that type doesn't look like what you said?
22:33:59 <Axman6> copumpkin: http://hackage.haskell.org/packages/archive/gnuplot/0.3.3/doc/html/Graphics-Gnuplot-Plot-ThreeDimensional.html
22:34:00 <Gracenotes> fix T `seq` () -> ()
22:34:09 <ChilliX> Axman6: on which command?
22:34:17 <Axman6> Configuring Cabal-1.7.4...
22:34:24 <copumpkin> Axman6: type T = Plot.T Graph.T
22:34:29 <copumpkin> Axman6: the beauty of HT's naming
22:34:30 <Axman6> ah...
22:34:35 <Axman6> >_<
22:34:50 <copumpkin> all types are T, all classes are C
22:34:55 <copumpkin> it's a thing of beauty
22:35:07 <Axman6> >_________<
22:35:12 <copumpkin> indeed
22:35:22 <Saizan> i hope he's not going to name all the modules M
22:35:22 <Axman6> ChilliX: you're on SL right?
22:35:33 <copumpkin> M.M.M.M.C
22:35:38 <copumpkin> yay roman numerals
22:37:22 <Gracenotes> so that restricts a module to one type each
22:37:28 <copumpkin> yep
22:40:17 <ChilliX> Axman6: yeah, sure, SL
22:40:34 <Axman6> and you're not getting this stupid architecture thing?
22:40:37 <ChilliX> (actually compiling in parallel on L and SL — two different boxes)
22:40:40 <ChilliX> nope
22:40:46 <Axman6> >_<
22:40:48 <ChilliX> it's in the stage2 build now
22:41:02 <Axman6> i have o idea what state i'm in
22:41:06 <Axman6> stage*
22:41:08 <ChilliX> Axman6: what's teh command that fails
22:41:21 <ChilliX> what was teh command before th error msg
22:41:34 <Axman6> just says Configuring Cabal-1.7.4...
22:41:34 <Axman6> /var/folders/-J/-JQP03F72RazIk+BYoiSW++++Tg/-Tmp-/80532.c:1:0: error: CPU you selected does not support x86-64 instruction set
22:41:37 <Axman6> make[1]: *** [libraries/Cabal/dist-boot/package-data.mk] Error 1
22:41:45 <ChilliX> you did modify the /usr/bin/ghc of your bootstrap compiler, didn't you?
22:43:19 <Axman6> ChilliX: yeah, i added -optc -m32 -optl -m32
22:43:19 <ChilliX> ah
22:43:19 <ChilliX> you need -opta-m32 too
22:43:20 <Axman6> but it does it without that
22:43:39 <Axman6> i have that (s/optc/opta)
22:43:50 <Axman6> exec /Library/Frameworks/GHC.framework/Versions/610/usr/lib/ghc-6.10.4/ghc -B/Library/Frameworks/GHC.framework/Versions/610/usr/lib/ghc-6.10.4/. -dynload wrapped ${1+"$@"} -opta-m32 -optl-m32
22:43:55 <Axman6> look right?
22:44:02 <ChilliX> both
22:44:05 <ChilliX> you need both of these
22:44:13 <Axman6> what do you mean?
22:44:18 <ChilliX> -optc-m32 -opta-m32 -optl-m32
22:44:24 <Axman6> ah
22:44:30 <Axman6> ah ha!
22:44:37 * Axman6 hugs ChilliX 
22:44:50 <Axman6> if this all works out, i'm buying you a beer in sydney :)
22:44:52 <ChilliX> Well wait whether it works with that!
22:45:09 <ChilliX> Axman6: didn't you say, you can't afford buying people beers ;)
22:45:27 <Axman6> yeah, but i can go without food for a week or something :P
22:45:39 <Axman6> nah i've got enough, just not to buy _people_ beers :P
22:45:39 <ChilliX> hehehe
22:45:46 <ChilliX> btw, my build just completred
22:45:50 <Axman6> haskell > food anyway
22:46:08 <ChilliX> living on lambdas
22:46:19 * Axman6 ups the ante and starts make -j3
22:46:25 <f4hy> I am having trouble thinking of how to do vector math with haskell. Computing a gradient for example. Would you have to have a different function for each different dimension size?
22:47:02 <copumpkin> f4hy: not necessarily
22:47:10 <copumpkin> f4hy: you can have type-sized vectors
22:47:35 <copumpkin> but if the sizes weren't known at compile time, you'd need some existentials
22:47:42 * Raynes huggles copumpkin.
22:47:47 <Raynes> <3
22:47:49 <copumpkin> Raynes: learn agda!
22:47:56 <copumpkin> Raynes: you were saying that languages felt dull :)
22:47:58 <Raynes> Say what? O.O
22:47:58 <f4hy> existentials?
22:48:02 <Raynes> Oh.
22:48:14 <copumpkin> f4hy: type-hiding types!
22:48:24 <Raynes> I'm learning Ruby, and everything is like: wut.
22:48:33 <monochrom> Languages are dull. Try logics instead.
22:48:33 <copumpkin> data Pandora'sBox = forall a. Box a
22:48:51 <ChilliX> copumpkin: lol
22:49:15 <copumpkin> it contains everything! and it's safe! cause if you look inside you see nothing!
22:49:19 <f4hy> ok type-hiding types that sounds far scarier than I want to deal with. What do you mean by known at compile time exactly.
22:49:22 <Axman6> ChilliX: got a favourite beer?
22:49:28 <Makoryu> Raynes: I hear Ruby makes a lot more sense if you drop a near-fatal quantity of acid and then live as a homeless person for four or five years
22:49:40 <copumpkin> f4hy: basically that the size of the vector doesn't depend on runtime values
22:49:48 <BMeph> ChilliX: Say Toohey's Old... ;)
22:49:54 <Raynes> Makoryu: I would try that but...
22:49:54 <Axman6> f4hy: if you preresent your vectors as lists, life may be easier for you
22:50:07 <copumpkin> but it isn't typesafe!
22:50:09 <copumpkin> :(
22:50:13 <ChilliX> Axman6: I'm German, I'm hard to please when it gets to beer ;)
22:50:19 <f4hy> copumpkin: Ok could the functions in a given module not know anyhting about size, but then a separate file which uses that module determine the sizes?
22:50:25 <Axman6> heh, fair enough :P
22:50:34 <copumpkin> f4hy: sure thing
22:50:45 <copumpkin> f4hy: well, they could accept size as a "Variable"
22:50:46 <f4hy> So a general purpose gradient function, but the size would be set by whatever was using it somewhere else?
22:50:49 <Makoryu> Raynes: You could also just try to learn Perl, fail, go back to Java, and then the next time you try to learn Perl, just read about Ruby instead, and unicorns will explode out of your forehead. Also, narwhals
22:50:50 <copumpkin> but it'd be a type variable
22:51:01 <copumpkin> f4hy: here, I have an example using SHE ;)
22:51:06 <Makoryu> Raynes: That's how I did it. Except for the unicorn part.
22:51:06 <Axman6> ChilliX: if you're ever in canberra, i have a favourite pub which brews their own beers. some of them are very nice (quite a few german beers too i think)
22:51:06 <Raynes> Holy shit.
22:51:39 <ChilliX> Axman6: microbrewerys are a good thing
22:51:50 <copumpkin> f4hy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8890#a8890 uses a nice preprocessor to make type-level stuff more pleasant, but it might still be a little hard for you to work with unless you're used to lots of type-level stuff
22:51:54 <Axman6> this one has won many many awards
22:52:10 <f4hy> copumpkin: it may be over my head, but i will check it out. thanks!
22:52:12 <Axman6> they ahve a really nice one at the moment with smoked hops. it's really nice
22:52:35 <Axman6> and their velcet cream stout is amazing. not sure i like it, but it tastes like chocolate. fascinating to drink
22:52:38 <copumpkin> f4hy: keep in mind that it needs SHE (type @where she if you're curious), but that it's nothing that can't be done in vanilla (ghc) haskell
22:52:45 <ChilliX> Axman6: sounds good, what is the place called?
22:52:52 <Axman6> the Wig and Pen
22:53:26 <Nereid_> So why aren't concurrent things like STM done in parallel?
22:53:34 <Nereid_> well, forkIO, it seems
22:53:44 <copumpkin> they are if you ask the RTS to be parallel
22:53:45 <f4hy> copumpkin: what is SHE?
22:53:49 <Axman6> Nereid_: eh?
22:54:03 <Nereid_> copumpkin: using -threaded and giving the RTS -N2 didn't seem to have any effect
22:54:19 <dmead> hey channel
22:54:24 <copumpkin> f4hy: a recent preprocessor for haskell that expands its syntax a little bit and makes certain interesting operations easier to work with (including the type-level stuff that you'd need for vectors)
22:54:26 <Axman6> o/ dmead
22:54:34 <dmead> can you do cartesian product in O(logn)?
22:54:34 <copumpkin> @where she
22:54:35 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
22:54:41 <dmead> \o_
22:54:51 <Nereid_> dmead: define "do"
22:55:00 <Saizan> Nereid_: you might not be strict enough so the values are not evaluated in the thread you're thinking they will
22:55:01 <copumpkin> dmead: what's n? I can do anything in O(1) lazily ;)
22:55:15 <Saizan> Nereid_: or you might have too much synchronization
22:55:15 <Nereid_> Saizan: hmm.
22:55:20 <dmead> does the liftm2 function in the modal module run in nlogn time
22:55:20 <Nereid_> no, definitely not the latter.
22:55:29 <dmead> *monad module
22:55:33 <copumpkin> dmead: no
22:55:44 <copumpkin> dmead: you're also thinking of lists in particular, I assume?
22:55:52 <dmead> a friend of mine has an assignment to do cartesian product in nlogn time
22:55:57 <dmead> and i don't believe him that it can be done
22:56:05 <c_wraith> there are n^2 results
22:56:05 <monochrom> What is cartesian product?
22:56:08 <copumpkin> it'd be n * m
22:56:14 <dmead> yea n*m
22:56:15 <f4hy> Hmmm. Maybe my haskell skills are not strong enough to attempt to do vector calculus.
22:56:17 <copumpkin> monochrom: liftA2 (,)
22:56:19 <copumpkin> :P
22:56:29 <dmead> you mean liftm2
22:56:30 <monochrom> No, I want to hear it from the horse's mouth.
22:56:35 <dmead> ?
22:56:46 <copumpkin> dmead: they behave identically for lists
22:56:49 <dibblego> @type liftA2 -- applicative style
22:56:50 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
22:56:50 <dmead> ah
22:56:57 <dmead> ?src liftA2
22:56:58 <lambdabot> liftA2 f a b = f <$> a <*> b
22:57:05 <dmead> ah
22:57:08 <Makoryu> copumpkin: Is there any type for which they *don't* behave identically?
22:57:18 <c_wraith> You can't run an algorithm in less time than the size of the output.
22:57:23 <copumpkin> Makoryu: ZipLists, where the liftM2 will give you a type error :P
22:57:42 <Makoryu> copumpkin: ......yeah.
22:57:43 <Saizan> c_wraith: change how you represent the output then!
22:58:17 <Makoryu> > join (liftA2 (*)) [1,2,3]
22:58:18 <lambdabot>   [1,2,3,2,4,6,3,6,9]
22:58:41 <copumpkin> dmead: are you sure you didn't misunderstand him or he didn't misunderstand his prof?
22:59:01 <monochrom> exactly why I asked what is the real meaning.
22:59:04 <dmead> copumpkin, probably, cause that seems impossible to me
22:59:16 <dmead> yea someone doesn't get someone
22:59:43 <Makoryu> > liftA2 (*) `join` [2,3,5,7]
22:59:44 <lambdabot>   [4,6,10,14,6,9,15,21,10,15,25,35,14,21,35,49]
22:59:52 <monochrom> But apparently people are more interested in tossing out opinions than following the scientific method.
23:00:09 <monochrom> Exactly why dons is often frustrated.
23:00:18 <monochrom> And me too.
23:00:33 <Nereid_> dmead: or do you mean something else by cartesian product?
23:00:55 <Nereid_> something other than
23:01:02 <copumpkin> monochrom: sheesh :P
23:01:09 <Nereid_> > [(x,y) | x <- [1..3], y <- ['a'..'c']]
23:01:10 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
23:01:37 <Axman6> > liftM1 (,) [1,2,3] [a,b,c]
23:01:39 <lambdabot>   Not in scope: `liftM1'
23:01:40 <copumpkin> maybe it'd be wise for an op to be on the lookout? there are several very suspicious joins every so often
23:01:43 <Axman6> > liftM2 (,) [1,2,3] [a,b,c]
23:01:44 <lambdabot>   [(1,a),(1,b),(1,c),(2,a),(2,b),(2,c),(3,a),(3,b),(3,c)]
23:01:52 <Axman6> urgh, not again...
23:02:10 <Nereid_> > liftA2 (,) [1..3] "abc"
23:02:12 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
23:02:15 <Nereid_> indeed
23:02:44 <Axman6> copumpkin: yeah, i'm in #freenode, and a lot of the same nicks are joining there too
23:03:11 <c_wraith> well, then, they'll be k-lined soon.
23:03:20 <dmead> banhammer'd
23:03:40 <dmead> yea my friend says theres no repeats
23:03:41 <Axman6> so according to the nicks the spammers are in, these are the top 20 channels on freenode: #ubuntu #gentoo #debian #archlinux #django #haskell #perl #git #mysql #piratenpartei #fedora #freenode #vim #bash #android #jquery #math #postgresql #RubyOnRails #centos-unregistered
23:03:55 <dmead> but i figure you have to factor in the time it takes for lookups
23:04:21 <c_wraith> no repeats of what?
23:04:43 <monochrom> (what is there to lookup?)
23:04:49 <c_wraith> The problem is sounding even less defined now
23:05:26 <copumpkin> :t deriv
23:05:27 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
23:05:46 <dmead> to get a cartesian product
23:05:47 <copumpkin> does anyone remember how to use that stuff?
23:05:51 <dmead> ie
23:06:05 <dmead> > liftM2 (+) [1,2,3] [4,5,6]
23:06:06 <lambdabot>   [5,6,7,6,7,8,7,8,9]
23:06:12 <dmead> do that, in nlogn time
23:06:56 <c_wraith> removing the repeats in the results isn't going to make that n log n
23:07:02 <c_wraith> There might not be repeats.
23:07:36 <c_wraith> There has to be some tighter constraint on the problem space if n log n is possible.
23:07:52 <Axman6> i have a feeling it's not possible. like someone said earlier, you can't have n*m results in less than n*m time
23:07:54 <dmead> yea i think he's misunderstanding it
23:07:55 <Berengal> Or 'n' is something other than what it usually is
23:08:41 <monochrom> liftM2 (,) [1.. n-bit number] [1.. m-bit number]  takes exponential time.  <duck>
23:09:01 <bos> hey kids, read all about my new criterion library here: http://bit.ly/rUuAa
23:09:31 <copumpkin> yay
23:09:44 <monochrom> fib is benchmark-worthy? :)
23:09:46 <ivanm> bos: why did you bother using a URL shortener?
23:09:49 <copumpkin> bos: you forgot to close a parenthesis
23:09:54 <ivanm> monochrom: of cousre, fib is _the_ benchmark!
23:10:01 <copumpkin> "Compared to other benchmarking frameworks (for any programming language,"
23:10:02 <bos> copumpkin: i did?
23:10:17 <copumpkin> that one is unclosed as far as I can see
23:10:23 <copumpkin> :)
23:10:24 <ivanm> yup
23:10:39 <monochrom> (cabal is not trivial to install. or maybe I'm just outdated.)
23:10:40 <ivanm> and here bos was, checking all his code in the article...
23:10:54 <ivanm> monochrom: you're outdated (at least on linux, etc.)
23:11:06 <c_wraith> > liftA2 (+) [1,2,3] [10,20,30]
23:11:08 <lambdabot>   [11,21,31,12,22,32,13,23,33]
23:11:09 <monochrom> Good to hear. I'm happy.
23:11:28 <monochrom> English checking is undecidable.
23:11:59 <c_wraith> cabal is a lot easier to install on linux than it was when I started using it.  Hugely vastly improved.
23:12:21 <ivanm> paludis -i cabal-install :p
23:12:23 <Axman6> "Criterion itself is trivially easy to install." why do you mock us bos :(
23:12:38 <bos> Axman6: patches welcome. seriously.
23:12:49 <Axman6> if i had time, i would consider it
23:12:55 <bos> Axman6: it should be easy to get it working on a mac, although you'll only be able to output CSV files.
23:13:27 <Axman6> CSV would be ok. there's packages for processing csv, and packages for graphing
23:13:33 <ivanm> bos: any particular reason for not capitalising the X/Y labels?
23:13:53 <bos> ivanm: jesus christ, do you ever have anything not nit-picky to say?
23:14:03 <ivanm> when I'm asleep? :p
23:14:14 <Axman6> heh
23:14:28 <ski> > (deriv (\x -> x^2) `graph`) `map` [-3..3]  -- copumpkin
23:14:29 <lambdabot>   [(-3,-6),(-2,-4),(-1,-2),(0,0),(1,2),(2,4),(3,6)]
23:14:34 <Axman6> bos: btw, it looks like a lovely package, so well done to you :)
23:14:39 <ray> "have anything not not-picky to say", not "not have anything nit-picky to say", ray nitpicked
23:14:51 <blackdog> Axman6: Tim Docker wrote the charts lib bos is using - he's pretty approachable. sure he'd take mac patches too.
23:14:55 <monochrom> I am against capitalizing the labels.
23:15:07 <bos> Axman6: thanks
23:15:23 <Axman6> blackdog: well, i'd really like to see gtk2hs fixed
23:15:58 <blackdog> Axman6: it has worked on mac, right? at some point in the dusty sepia past?
23:16:06 <Axman6> yeah
23:16:12 <Axman6> i've even used it a little
23:16:25 <Axman6> but now it refuses to find the right libraries
23:16:47 <copumpkin> ski: nice :)
23:17:05 <copumpkin> > deriv (^2) x
23:17:06 <lambdabot>   1 * x + x * 1
23:17:16 <copumpkin> beautiful ;)
23:17:50 <Axman6> needs some simplification
23:17:54 <monochrom> powerful!
23:18:12 <Axman6> > deriv (^5) x
23:18:13 <lambdabot>   ((1 * x + x * 1) * (x * x) + x * x * (1 * x + x * 1)) * x + x * x * (x * x)...
23:18:21 <m0nkfish> x_x
23:18:23 <Axman6> :t deriv (^5) x
23:18:24 <lambdabot> Expr
23:18:30 <Makoryu> :t deriv
23:18:30 <blackdog> Axman6: hm. wonder if it's anything to do with the general mac dylib problem
23:18:30 <copumpkin> f4hy: check that out :)
23:18:32 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
23:18:48 <Axman6> :t reduce (deriv (^5) x)
23:18:49 <lambdabot> Expr
23:18:54 <Axman6> > reduce (deriv (^5) x)
23:18:55 <lambdabot>   ((1 * x + x * 1) * (x * x) + x * x * (1 * x + x * 1)) * x + x * x * (x * x)...
23:19:13 <Axman6> > drop 5 $ iterate reduce (deriv (^5) x)
23:19:14 <lambdabot>   [((1 * x + x * 1) * (x * x) + x * x * (1 * x + x * 1)) * x + x * x * (x * x...
23:19:20 <Axman6> > drop 10 $ iterate reduce (deriv (^5) x)
23:19:21 <lambdabot>   [((1 * x + x * 1) * (x * x) + x * x * (1 * x + x * 1)) * x + x * x * (x * x...
23:19:24 <Axman6> lamw
23:19:25 <Axman6> e
23:19:46 <copumpkin> > reduce (deriv (^2) x)
23:19:48 <lambdabot>   1 * x + x * 1
23:19:57 <ski> > reduce (1 + 1)
23:19:58 <lambdabot>   2
23:20:01 <copumpkin> zomg!
23:20:11 <copumpkin> :t reduce
23:20:12 <lambdabot> Expr -> Expr
23:20:29 <ski> > reduce (1 * x + 1 * x)
23:20:29 <Axman6> > reduce (x*1)
23:20:30 <lambdabot>   1 * x + 1 * x
23:20:30 <lambdabot>   x * 1
23:20:36 <ski> heh
23:20:38 <Axman6> :(
23:21:05 <copumpkin> > reduce (x + x)
23:21:06 <lambdabot>   x + x
23:21:08 <Saizan> ?type reduce
23:21:08 <ski> obviously it doesn't believe `1' is the global multiplicative unit
23:21:09 <lambdabot> Expr -> Expr
23:21:10 <copumpkin> there we go
23:21:26 <Makoryu> , reduce (1 * x + x * 1)
23:21:29 <lunabot>  1 * x + x * 1
23:21:49 <copumpkin> @index reduce
23:21:50 <lambdabot> bzzt
23:21:54 <Axman6> > drop 10 $ iterate reduce (deriv (^5) 5)
23:21:56 <Saizan> it doesn't seem to reduce much!
23:21:56 <lambdabot>   [(250 + 250) * 5 + 5 * 5 * (5 * 5) * 1,500 * 5 + 5 * 5 * (5 * 5) * 1,2500 +...
23:22:04 <Axman6> > drop 13 $ iterate reduce (deriv (^5) 5)
23:22:05 <lambdabot>   [2500 + 25 * (5 * 5) * 1,2500 + 25 * 25 * 1,2500 + 625 * 1,2500 + 625,3125,...
23:22:15 <Axman6> > drop 15 $ iterate reduce (deriv (^5) 5)
23:22:16 <lambdabot>   [2500 + 625 * 1,2500 + 625,3125,3125,3125,3125,3125,3125,3125,3125,3125,312...
23:23:00 <c_wraith> @src reduce
23:23:01 <lambdabot> reduce _ 0 = undefined
23:23:01 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
23:23:01 <lambdabot>     where d = gcd x y
23:23:02 <Gracenotes> reduce isn't how the common Num types do it :)
23:23:26 <Gracenotes> er. that one's for ratios, hm
23:23:29 <c_wraith> yeah
23:23:31 <c_wraith> not quite right
23:23:45 <Gracenotes> Int, Integer, etc. use result sharing
23:23:45 <monochrom> Seems to be implemented by a 1st-year student doing homework.
23:24:12 <ski> > map ($ x) (iterate deriv (^3))  -- type error
23:24:13 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
23:24:14 <lambdabot>         against inferred ...
23:24:22 <FunctorSalad> @typ reduce
23:24:23 <lambdabot> Expr -> Expr
23:24:52 <Axman6> > 2 ^ 5 :: Expr
23:24:53 <lambdabot>   2 * 2 * (2 * 2) * 2
23:25:40 <ivanm> bos: with criterion, how much "theoretical" knowledge do/did you have about benchmarking, etc. or is this all from doing benchmarks over the years, etc.?
23:25:57 <ivanm> (i.e. did you read up on benchmarking papers, etc. or just figure it out yourself)
23:26:25 <Gracenotes> for (2^4): let a = 2 * 2; b = 2 * 2; c = a * b; in  c
23:26:58 <bos> ivanm: Both.
23:26:58 <Gracenotes> ...at least, says Debug.Traced
23:27:21 <bos> ivanm: I've done a fair bit of work in high performance computing.
23:27:25 <ivanm> *nod*
23:27:30 <bos> and compiler hacking, and the like.
23:27:42 <ski> @type iterate (let foo :: (forall a. Num a => a -> a) -> (forall b. Num b => b -> b); foo f = deriv f in foo)
23:27:44 <lambdabot>     Couldn't match expected type `forall a. (Num a) => a -> a'
23:27:44 <lambdabot>            against inferred type `b -> b'
23:27:44 <lambdabot>     In the expression: foo
23:27:53 <bos> also, there are refs to brent boyer's work (which is pretty much the best around) at the end of my blog posting.
23:29:41 <bos> some guy wrote a phd on java performance analysis, too, but it's much less statistically sophisticated.
23:29:43 <ivanm> *nod*
23:29:58 <bos> bootstrapping is fucking cool.
23:30:01 <ivanm> Java performance analysis? you can actually get performance from Java? :p
23:30:29 <monochrom> No. The joke is: you can get a PhD from that. :)
23:30:34 <Axman6> java can be pretty damn fast
23:30:42 <Makoryu> ivanm: HUR HUR JAVA IS SLOW AND ALL GERMANS DRIVE YUGOS ETC. ETC.
23:30:56 <ivanm> Makoryu: I've been in yugos
23:31:13 <monochrom> I thought all Germans drove Benz.
23:31:17 <ivanm> half of Serbia drives a Yugo, the other half has a brand new car
23:31:20 <ivanm> ;-)
23:32:43 <Axman6> bos: with the "bench "fib 10" $ \n -> fib (10+n-n)" bit of the example, what sorts of numbers get passed into n?
23:33:04 <bos> Axman6: ah, that's the subject of another posting i'll have to write.
23:33:11 <Axman6> ok :)
23:33:16 <medfly> the joke is that someone is reading PhD theses on  Java performance analysis
23:33:17 <medfly> no?
23:33:23 <bos> Axman6: the purpose of that number is to keep the expression from getting thunked.
23:33:23 <monochrom> Haha
23:33:34 <Axman6> fair enough
23:33:55 <bos> Axman6: otherwise you tend to find that your code takes a few hundred nanoseconds to execute, after the first measurement.
23:33:58 <ivanm> bos: what does the title of your blog actually mean?
23:34:08 <Axman6> ah, i see :)
23:34:10 <bos> ivanm: it's irish for "clever witty title"
23:34:14 <Axman6> heh
23:34:23 <ivanm> heh
23:34:24 <monochrom> ....
23:36:49 <Axman6> bos: "We print an estimate in advance for how long the measurements will take, so that if you're benchmarking something expensive, you can go for coffee or whatever. " i was just wondering about that :)
23:37:49 <bos> oh yeah, so the reason i went on this mad statistical performance and measurement rampage for a month was to see if my new text search code was better than the old.
23:38:06 <bos> it's 10x to 20x faster, according to criterion. i am happy.
23:38:06 <ivanm> and is it?
23:38:18 <Axman6> excellent :)
23:39:04 * Axman6 would still like to know which one of his haskell DCT IV implementations is fastest
23:39:30 <ivanm> bos: but it's interesting that you even took into account CPU usage by other apps, which is something I for one normally don't bother thinking about...
23:40:21 <bos> ivanm: if something is worth doing, it's worth doing to a point where nobody else will ever bother trying it again :-)
23:40:29 <ivanm> heh
23:40:46 <ivanm> so are you still doing work on criterion or is it now good enough?
23:41:33 * copumpkin had an idea in his benchmarking library that he was hoping criterion would implement too, but doesn't seem to have yet
23:41:33 <ivanm> oh, just came to the bit where you say there's more to do ;-)
23:42:08 <copumpkin> maybe I'll submit a patch with it someday
23:42:31 <PetRat> How do make a monad into a nested loop?   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9983#a9983
23:42:46 <Alpounet> Hi
23:43:08 <Axman6> PetRat: it's not clear what you're trying to actually do
23:43:13 <Axman6> or, maybe it is
23:43:21 <Axman6> read the comments Axman!
23:43:26 <monochrom> I just read the comments.
23:43:35 <bos> copumpkin: what's the idea?
23:43:41 <monochrom> zipWith f [0..100] [0..100]  is one
23:44:04 <monochrom> [f x y | x <- [0..100], y <- [0..100] ] is another.
23:44:07 <ivanm> copumpkin: hopefully your idea is more fleshed out than "fill it with moar awesome"...
23:44:08 <ivanm> ;-)
23:44:19 <monochrom> Oh yuck I forgot you want IO.
23:44:23 <PetRat> monochrom: does it matter than f is a monad with side-effects?
23:44:41 <monochrom> sequence_ (what I said)
23:45:00 <Axman6> PetRat: if you do sequence_ [f x y | x <- [1..100], y <- [1..100]] it woll work
23:45:23 <PetRat> Axman6: thanks
23:45:29 <copumpkin> bos: I was using a quickcheck-like approach that basically allowed you to type bench fib (used a bunch of arbitrary-like typeclasses for this) and it would automatically sample the domain of the function and build you a table of its performance for different inputs (only graphable for low dimensions, obviously). It had timeouts and probed the timing space a bit to avoid taking too long and to only try inputs that didn't take very lo
23:46:14 <copumpkin> I have the code lying around somewhere, it was to help compare integer-simple with -gmp, but I never finished it and then you started yours so I stopped :)
23:46:15 <ski_> cut off at "didn't take very lo"
23:46:24 <copumpkin> "ng"
23:46:25 <copumpkin> :)
23:46:35 --- mode: ChanServ set +o dibblego
23:46:52 <monochrom> Not very long but just 2 or 3 bytes too long. :)
23:46:55 <ivanm> dibblego: I think all the spammers have gone now...
23:47:08 <dibblego> ivanm, I don't
23:47:12 <Axman6> me either
23:47:13 <ivanm> heh
23:47:15 <bos> copumpkin: oh yes, that's very much on my mind.
23:47:19 <ivanm> s/now/for now/
23:47:38 <ski> (was there any spammers ?)
23:47:54 <monochrom> (yes, they spewed a lot of @@@@@'s)
23:48:14 <Axman6> they're attacking the top 20 channels
23:48:20 <Axman6> we should be somewhat flattered :P
23:48:38 <ski> (oh, a litle bit more than 3 hours ago)
23:48:45 <jorick> how do i turn a list [a,b,c,d,e] into [a + b, b + c, c + d, d + e]?
23:48:55 * ski notices a `K-line'
23:48:57 <copumpkin> bos: awesome :) I envisioned typing bench fib and have it spit out an exponentialish graph in reasonable time, with some good statistical grounding, and maybe curve fitting to estimate the complexity of your functions in terms of their various inputs. But the yak shaving required proved to be excessive, so I'm glad you did it :)
23:49:06 <ski> @quote aztec
23:49:06 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
23:49:35 <ski> > (zipWith (+) `ap` tail) [a,b,c,d,e]
23:49:36 <lambdabot>   [a + b,b + c,c + d,d + e]
23:49:36 <bos> copumpkin: well, there's a chunk of refactoring needed to make all that happen :-)
23:49:45 <jorick> ski thanks!
23:49:46 <Axman6> zomg, GHC finished building!
23:49:52 <bos> copumpkin: but at least all the basic machinery is in place
23:50:10 <copumpkin> bos: well, I'm still glad for your statistics library, which would greatly reduce the yak shaving needed to revive my project if I ever stop being ADD about my programming
23:50:13 <copumpkin> :)
23:50:28 <ski> jorick : also `zipWith (+) list (tail list)' where `list = [a,b,c,d,e]'
23:50:50 <bos> ha. i did all this BECAUSE i didn't stick to the details of one thing :-)
23:51:12 <bos> and now i have two new libraries and a faster text library out of my month of nuttiness.
23:51:43 * Axman6 thinks that criterion could become yet another killer app for haskell
23:52:08 <lispy|web> bos: did you incorporate any features from maybench?
23:52:18 <bos> lispy|web: no
23:52:28 <copumpkin> Axman6: I agree
23:52:42 <monochrom> main = defaultMain [ ("ghc", buildghc) ]
23:52:49 <copumpkin> Axman6: it's the first time I've seen such a rigorous and easy approach to benchmarking
23:52:58 <Axman6> same here
23:53:22 --- kick: C0_0nl was kicked by dibblego (dibblego)
23:53:26 <blackdog> it's an interesting indicator - if you see a million libs all putatively designed to do the same thing, it's almost certain that none of them are very good...
23:53:35 <ivanm> Axman6: I don't think it will until it's available for other langs as well (and by that, I don't mean they steal the idea and re-write it)
23:53:38 <copumpkin> ivanm: but yeah, needs moar awesome ;)
23:53:39 --- kick: cO26jkt was kicked by dibblego (dibblego)
23:53:49 --- kick: newtoblr was kicked by dibblego (dibblego)
23:53:57 --- kick: co^gudel was kicked by dibblego (dibblego)
23:54:02 <lispy|web> wth is up with freenode tonight?
23:54:04 --- kick: Co_Bikers_____ was kicked by dibblego (dibblego)
23:54:05 <copumpkin> everything needs moar awesome
23:54:10 --- kick: co_pngn_kehangat was kicked by dibblego (dibblego)
23:54:19 <lispy|web> A lot of "co" named nicks
23:54:23 --- kick: cow_ajh was kicked by dibblego (dibblego)
23:54:30 <ivanm> dibblego: are you just finding weird-looking nicks in here or something?
23:54:32 * copumpkin hides from dibblego's banhammer of doom
23:54:48 <blackdog> copumpkin: be you spam or ham?
23:54:48 <Axman6> dibblego: don't go kicking conal by accident :O
23:54:49 <copumpkin> ivanm: if you /whois them and look at the channels they're in, it's all the same list and they're all top-20s
23:54:55 <ivanm> ahhh
23:55:03 <Veinor> 02:54:48 [freenode] -!-  channels : #ubuntu #debian #Archlinux #django #perl #git #mysql #piratenpartei #fedora #freenode #vim #bash #android #jquery #math  #postgresql #rubyonrails #centos-unregistered
23:55:11 <Veinor> he obviously just has a very diverse set of interests :)
23:55:12 <ivanm> Axman6: but he can feel free to kick copumpkin though :p
23:55:17 --- mode: dibblego set -o dibblego
23:55:17 <copumpkin> :'(
23:55:23 --- mode: ChanServ set +o bos
23:55:29 <Veinor> crouching dibblego, hidden op
23:55:32 --- kick: cwo_Pgn_Ktmuan was kicked by bos (bos)
23:55:39 <monochrom> hehe
23:55:50 <Axman6> fark >_<
23:55:55 --- kick: dooof was kicked by bos (bos)
23:55:55 <lispy|web> Practicing your kick fu?
23:56:03 --- kick: octal was kicked by bos (bos)
23:56:04 <ivanm> @remember Veinor [about dibblego kicking a whole bunch of spammers] crouching dibblego, hidden op
23:56:04 <lambdabot> I will never forget.
23:56:11 <Veinor> :D
23:56:21 <ray> more like i will forget in about 30 seconds
23:56:22 <lispy|web> ?quote Veinor
23:56:23 <lambdabot> Veinor says: [about dibblego kicking a whole bunch of spammers] crouching dibblego, hidden op
23:56:30 <lispy|web> ?quote Veinor
23:56:30 <lambdabot> Veinor says: [about dibblego kicking a whole bunch of spammers] crouching dibblego, hidden op
23:56:33 <Veinor> I didn't think it was that funny :P
23:56:39 <lispy|web> ?quote
23:56:39 <lambdabot> JelloBiafra: says: The conveniences you demanded are now mandatory.
23:56:41 <ivanm> Veinor: jfredett wanted more quotes
23:56:46 <ivanm> so I'm giving them to him :p
23:56:46 <lispy|web> ?quote
23:56:47 <lambdabot> concat says: $ forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
23:56:49 <Veinor> :P
23:56:50 <dibblego> I think octal was an error
23:57:00 <Axman6> rage >_<
23:57:02 <lispy|web> > forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
23:57:03 <lambdabot>   ["((","(5","(,","(9","()","2(","25","2,","29","2)",",(",",5",",,",",9",",)"...
23:57:10 <Axman6> $ cabal install criterion
23:57:10 <Axman6> cabal: failed to parse output of 'ghc-pkg dump'
23:57:17 <Axman6> god damn it
23:57:22 <ivanm> Axman6: heh
23:57:27 <Veinor> yeah, octal might be legit
23:57:29 <lispy|web> > concat $ forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
23:57:30 <lambdabot>   "(((5(,(9()2(252,292),(,5,,,9,)3(353,393))()5),)9))"
23:57:30 <Veinor> > forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
23:57:31 <lambdabot>   ["((","(5","(,","(9","()","2(","25","2,","29","2)",",(",",5",",,",",9",",)"...
23:57:41 <Veinor> why is that possibly useful
23:57:41 <lispy|web> I get it now, you're supposed to run concat on it
23:57:51 <Axman6> > forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
23:57:51 <Alpounet> bos: I'm definitely not the first to tell you that, but criterion is really awesome
23:57:52 <lambdabot>   ["((","(5","(,","(9","()","2(","25","2,","29","2)",",(",",5",",,",",9",",)"...
23:57:59 <Axman6> i remember that
23:58:03 <octal> ... and I was kicked because of what?
23:58:04 --- kick: cwo_crz36 was kicked by bos (bos)
23:58:10 <bos> octal: a mistake, sorry.
23:58:22 <Veinor> it's odd how the spambots aren't actually saying anything
23:58:32 <Axman6> they have been
23:58:35 <bos> Veinor: they sit around for a few hours then attack.
23:58:39 <Veinor> Ah.
23:58:40 <copumpkin> Veinor: I'd assume they're sitting in some private channel waiting for someone to send them a command
23:58:41 <Axman6> freenode is catching them before they do though
23:59:02 <Veinor> Oh man, that reminds me
23:59:27 <Veinor> Huh.
23:59:38 <Axman6> dcoutts: are you around?
23:59:45 <Alpounet> Veinor: these are the most dangerous ones. They watch people in #haskell, see their weakness, and then hurt there.
23:59:56 <Veinor> I tested a couple old sploits in an empty channel to see if I'd get /killed
