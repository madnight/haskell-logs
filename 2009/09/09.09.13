00:01:48 <Tony[`]> hm. Mutability seems to be the focus of the argument when building/replicating memcached, not as much when utilizing it
00:04:25 <Tony[`]> but fair enough :)
00:05:34 <BMeph> Tony[`]: I think part of the point here is that (at least from an FP perspective), there's a completely different use case motivation for it.
00:07:02 <Tony[`]> Can you explain? I've always thought memoization looked about the same in both settings, mutable and immutable focused
00:08:44 <opqdonut> memoization in an imperative setting mostly involves updating some structure
00:09:01 <opqdonut> memoization in a purely functional setting mostly involves defining a lazy data structure
00:10:54 <Tony[`]> okay, then when utilizing something like memcached how would they look much different?
00:12:02 <Tony[`]> It still just seems like some indirection on read/write either way
00:12:28 <Tony[`]> touching the cache when necessary/appropriate
00:16:56 <Cale> Tony[`]: hmm... I suppose the difference is that looking at the immutable case from an operational perspective, you're initialising an array/map/whatever with expressions that identify what is to be memoised, and these simply wait to be evaluated (which will update them as evaluating any expression does)
00:16:56 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
00:18:08 <Cale> Tony[`]: Whereas in the mutable case, you might start out with an array which is either entirely uninitialised or simply contains markers that say the value hasn't been computed yet, rather than a representation of what is intended to go in that place.
00:18:18 <kyagrd> oh what is this lambdabot message feature hmm...
00:18:30 <ivanm> @help tell
00:18:30 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
00:18:34 <ivanm> kyagrd: ^^
00:19:10 <Cale> Tony[`]: I'm not sure if that's what you're after though... does that help?
00:19:21 <kyagrd> Wow, didn't know that lambdabot was a message box
00:19:41 <kyagrd> (message box alert, more precisely)
00:20:08 <Zeiris> That's awesome.
00:20:17 <opqdonut> Tony[`]: i have no idea how using memcached looks in one's code
00:20:47 <opqdonut> ah okay, it has to be used explicitly
00:27:32 <Cale> In the case of a mutable memoisation scheme, you explicitly update the cache with the new value whenever the function is computed. With an immutable memoisation scheme, you define a datastructure which implicitly consists of all the values on which you want the function memoised right off the bat (usually a rather large or even infinite datastructure), and let the operational semantics of evaluation handle the rest.
00:31:40 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html -- this library takes a slightly different route, and abstracts things a little further, making use of the fact that parameters to a function are evaluated at most once to build up schemes for memoising things.
00:31:43 <lambdabot> Title: Data.MemoCombinators, http://tinyurl.com/p9xv4z
00:32:25 <Cale> type Memo a = forall r. (a -> r) -> (a -> r)
00:32:38 <Cale> bool :: Memo Bool
00:32:38 <Cale> bool f = cond (f True) (f False)
00:32:38 <Cale>     where
00:32:38 <Cale>     cond t f True  = t
00:32:38 <Cale>     cond t f False = f
00:32:48 <absentia> hi cale
00:32:51 <Cale> Hello
00:34:11 <Cale> From this primitive memoiser for functions on boolean values, it builds up memoisers for more complicated datatypes, usually by some representation of that type in terms of bits.
00:52:59 <Gilly> > (-1) ** (0 :+ 1)
00:53:00 <lambdabot>   23.140692632779267 :+ 0.0
00:53:24 <Gilly> why does haskell use exp pi and not exp -pi?
00:54:01 <ivanm> for what?
00:54:10 <Gilly> for (-1) ** i
00:54:36 <ivanm> Gilly: are you sure it's meant to be exp -pi?
00:54:49 <Gilly> well i don't know if it should be defined at all
00:55:00 <ivanm> > exp pi
00:55:01 <lambdabot>   23.140692632779267
00:55:14 <Gilly> (-1) = e^(-pi*i) = e^(pi*i), thus (-1)^i could be e^(-pi) or e^(pi)
00:55:45 <ivanm> you sure about that?
00:55:57 <ivanm> why does e^(-pi*i) == e^(pi*i) ?
00:55:58 <Gilly> > exp (pi * (0 :+ 1))
00:55:59 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
00:56:05 <Gilly> > exp (-pi * (0 :+ 1))
00:56:05 * ivanm isn't sure off the top of his head if that's right or not...
00:56:06 <lambdabot>   (-1.0) :+ (-1.2246467991473532e-16)
00:56:23 <ivanm> I haven't done complex stuff in a while...
00:56:31 <Gilly> well, e^(xi) = cos x + i sin x
00:56:45 <ivanm> oh, yeah
00:56:51 <Gilly> cos -pi = cos pi = -1, sin pi = sin (-pi) = 0
00:56:56 <ivanm> duh
00:57:08 <ivanm> exp (-pi)
00:57:12 <ivanm> > exp (-pi)
00:57:13 <lambdabot>   4.321391826377226e-2
00:58:15 <ivanm> Gilly: I'm thinking different roots...
00:58:27 <ivanm> and the fact that the e^pi option is chosen as default is arbitrary
00:58:33 <ivanm> I could be talking garbage here though :p
01:00:13 <Gilly> hmm, i guess the only way to know would be to look at the source code :)
01:00:25 <ivanm> yup
01:02:51 <Gilly> > polar (-1)
01:02:51 <lambdabot>   (1.0,-3.141592653589793)
01:03:07 <Gilly> > exp (snd it * (0 :+ 1) * (0 :+ 1))
01:03:07 <lambdabot>   Not in scope: `it'
01:03:20 <Gilly> > exp (snd (polar (-1)) * (0 :+ 1) * (0 :+ 1))
01:03:21 <lambdabot>   No instance for (GHC.Float.RealFloat (Data.Complex.Complex t))
01:03:21 <lambdabot>    arising f...
01:03:30 <Gilly> > exp ((snd (polar (-1)) :+ 0) * (0 :+ 1) * (0 :+ 1))
01:03:31 <lambdabot>   23.140692632779267 :+ (-0.0)
01:05:46 <absentia> orbitz, eh?
01:08:12 <Gilly> even more weird:
01:08:16 <Gilly> > let x = (-1) :+ 0; y = 0 :+ 1 in x ** y
01:08:17 <lambdabot>   4.321391826377226e-2 :+ 0.0
01:08:28 <Gilly> > (-1) ** (0 :+ 1)
01:08:28 <lambdabot>   23.140692632779267 :+ 0.0
01:08:44 <Gilly> i guess it uses different types in the two situations
01:09:15 <Gilly> and the precision of the other makes it to use -pi for the first and pi for the other
01:10:13 <Gilly> ah, actually it's weather i use (-1) :+ 0 or (-1)
01:56:22 <dmwit> > (-1) :: Complex Double
01:56:23 <lambdabot>   (-1.0) :+ (-0.0)
01:57:21 <ski> > - (1 :: Complex Double)  -- really this
01:57:22 <lambdabot>   (-1.0) :+ (-0.0)
01:57:54 <kyagrd> > negate (1.0 :+ 0)
01:57:54 <lambdabot>   (-1.0) :+ (-0.0)
01:58:22 <kyagrd> > negate (-0.0 :+ 1.0)
01:58:23 <lambdabot>   Precedence parsing error
01:58:23 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
01:58:28 <dmwit> quite
01:58:28 <kyagrd> > negate ((-0.0) :+ 1.0)
01:58:28 <dmwit> I guess they both translate to the same thing.
01:58:29 <lambdabot>   0.0 :+ (-1.0)
01:58:34 <dmwit> i.e. (negate 1) :: Complex Double === negate (1 :: Complex Double)
01:58:43 <ski> they should
01:58:45 <kyagrd> what is -0.0 hmm
01:58:53 <kyagrd> > negate ((-0.0) :+ 0.0)
01:58:53 <lambdabot>   0.0 :+ (-0.0)
01:59:00 <dmwit> kyagrd: Welcome to the world of IEEE floats.
01:59:05 <kyagrd> > negate (0.0 :+ (-0.0))
01:59:05 <lambdabot>   (-0.0) :+ 0.0
01:59:20 <dmwit> > -1 :: Complex Real
01:59:20 <kyagrd> Ah IEEE floats
01:59:20 <lambdabot>   Class `GHC.Real.Real' used as a type
01:59:23 <dmwit> err
01:59:25 <dmwit> > -1 :: Complex CReal
01:59:25 <lambdabot>   (-1.0) :+ 0.0
02:00:31 <ski> > 0.0 == -0.0
02:00:32 <lambdabot>   True
02:01:08 <dmwit> > let x = -1 in ((x :+ 0) ** (0 :+ 1), (x :+ -0) ** (0 :+ 1)) :: (Complex Double, Complex Double)
02:01:08 <lambdabot>   Precedence parsing error
02:01:08 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and pr...
02:01:17 <dmwit> > let x = -1 in ((x :+ 0) ** (0 :+ 1), (x :+ (-0)) ** (0 :+ 1)) :: (Complex Double, Complex Double)
02:01:18 <lambdabot>   (4.321391826377226e-2 :+ 0.0,23.140692632779267 :+ 0.0)
02:01:31 <dmwit> That I do not understand.
02:01:39 <dmwit> > 23.14 / pi
02:01:39 <lambdabot>   7.365690766292917
02:01:43 <dmwit> > 23.14 / e
02:01:44 <lambdabot>   23.14 / e
02:01:53 <dmwit> ...
02:01:53 <dmwit> oh
02:01:56 <dmwit> > 23.14 / exp 1
02:01:57 <lambdabot>   8.512730268707177
02:02:06 <kyagrd> @type 23.13 / 2
02:02:07 <lambdabot> forall t. (Fractional t) => t
02:02:13 <dmwit> > ln 23.14
02:02:14 <lambdabot>   Not in scope: `ln'
02:02:21 <kyagrd> @type 23.13
02:02:21 <dmwit> > log 23.14
02:02:22 <lambdabot> forall t. (Fractional t) => t
02:02:22 <lambdabot>   3.1415627217655304
02:02:28 <dmwit> aha
02:02:34 <dmwit> But I still don't understand. =P
02:02:39 <kyagrd> @type e
02:02:40 <lambdabot> Expr
02:02:55 <kyagrd> > e
02:02:56 <lambdabot>   e
02:03:06 <ski> > exp 1
02:03:06 <lambdabot>   2.718281828459045
02:03:11 <kyagrd> someone defiend e or is this some library value?
02:03:16 <dmwit> kyagrd: library
02:03:18 <dmwit> > f
02:03:19 <lambdabot>   Add a type signature
02:03:20 <dmwit> > x
02:03:21 <lambdabot>   x
02:03:24 <kyagrd> @hoogle e
02:03:25 <lambdabot> Data.Graph.Inductive.Example e :: Gr Char ()
02:03:25 <lambdabot> Data.Graph.Inductive.Example e' :: IO (SGr Char ())
02:03:25 <lambdabot> Data.Fixed data E12
02:03:28 <dmwit> > foldr f [x, y, z]
02:03:28 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
02:03:28 <lambdabot>    arising fr...
02:03:34 <dmwit> > foldr f a [x, y, z]
02:03:35 <lambdabot>   f x (f y (f z a))
02:03:41 <ivanm> well, someone probably defined e = exp 1 here
02:03:50 <dmwit> I don't think so, no.
02:03:53 <dmwit> e :: Expr, see?
02:04:00 <kyagrd> @undefine
02:04:04 <kyagrd> e
02:04:05 <kyagrd> >e
02:04:07 <kyagrd> > e
02:04:08 <lambdabot>   e
02:04:11 <kyagrd> whell
02:04:12 <dmwit> ?where simplereflect
02:04:12 <ivanm> oh, I thought this was from before doing all the exp stuff :s
02:04:12 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
02:04:14 <ivanm> sorry :s
02:04:21 <dmwit> kyagrd: See that page for more information.
02:04:39 <dmwit> > sum [x, y, z]
02:04:40 <lambdabot>   0 + x + y + z
02:04:53 <kyagrd> ahhh
02:04:59 <kyagrd> Lifting the alphabet
02:05:22 <dmwit> :t fun
02:05:23 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
02:05:44 <kyagrd> > a
02:05:44 <dmwit> :t expr
02:05:45 <lambdabot>   a
02:05:45 <lambdabot> Expr -> Expr
02:05:57 <dmwit> > expr (fun "Are we having fun yet?")
02:05:58 <lambdabot>   Are we having fun yet?
02:06:01 <kyagrd> > a+b+c+d+e
02:06:02 <lambdabot>   a + b + c + d + e
02:06:09 <FunctorSalad_> @hoogle Expr -> a
02:06:09 <lambdabot> Warning: Unknown type Expr
02:06:09 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
02:06:09 <lambdabot> Prelude id :: a -> a
02:06:23 <kyagrd> > sum [a,b,c,d,e]
02:06:23 <lambdabot>   0 + a + b + c + d + e
02:06:30 <kyagrd> holy cow
02:06:31 <dmwit> FunctorSalad_: Note the FromExpr a => constraint...
02:06:53 <FunctorSalad_> dmwit: I was looking for an "eval" function ;)
02:06:54 <kyagrd> quite fun
02:08:48 * dmwit writes instance Num a => FromExpr ([(String, a)] -> a) where ...
02:08:49 <dmwit> ;-)
02:09:07 <dmwit> actually,
02:09:10 <dmwit> add a Maybe in there
02:11:56 <FunctorSalad_> @instances-importing SimpleReflect SimpleReflect.FromExpr
02:11:57 <lambdabot> Couldn't find class `SimpleReflect.FromExpr'. Try @instances-importing
02:12:07 <FunctorSalad_> oh no
02:12:34 <dmwit> I very much doubt SimpleReflect is in ?instance's database.
02:13:42 <FunctorSalad_> shouldn't it have a single LONG database for all the plugins?
02:13:50 <FunctorSalad_>  @src is a bit sparse too
02:13:56 <FunctorSalad_> yes I know, "write it" ;)
02:14:03 <ivanm> isn't @src done by hand?
02:14:24 <FunctorSalad_> it could use hayoo, maybe
02:14:43 <FunctorSalad_> (since sources are linked on hackage)
02:15:35 <ivanm> hmmm...
02:16:02 <ivanm> heh
02:16:06 <ivanm> whoops, wrong window :s
02:18:39 <__void__> what is the best resource for learning haskell, real world haskell book?
02:19:07 <ivanm> not really
02:19:11 <ivanm> not for a beginner
02:19:27 <ivanm> if you want a book, there's craft of functional programming and Haskell, school of expression
02:19:28 <dschoepe> __void__: learn you a haskell is a good start.
02:19:35 <ivanm> oh, and Graham's Programming Haskell
02:19:42 <ivanm> there's the wikibook, and YAHT
02:19:52 <ivanm> and that LYAH thingy that dschoepe is referring to :s
02:20:09 <__void__> i've looked trough many of them, was looking for the definitive resource :)
02:20:10 <dschoepe> and, depending on your taste, you might like "A gentle introduction to Haskell"
02:20:31 <__void__> my main goal is to understand an collaborate with xmonad xD
02:20:33 <Berengal> http://arcanux.org/lambdacats/gentle-intro.jpg
02:20:43 <ivanm> dschoepe: I thought it wasn't that gentle...
02:21:05 <dschoepe> ivanm: well, but it
02:21:11 <dschoepe> 's precise and to the point
02:21:28 <dschoepe> that's why I added "depending on your taste" :)
02:21:50 <poe> __void__ a friend of mine is having a good time with the haskell wikibook as his first resource
02:22:02 <ivanm> heh
02:22:12 <Berengal> I used the wikibook as my first resource as well, then quickly branched out to other tutorials once I got the basics down
02:22:23 <Berengal> Seemed to work
02:22:36 <ivanm> I liked craft
02:23:21 <ski> (Me Too [tm])
02:24:12 <__void__> and can you point me to a good program implemented in haskell besides xmonad and darcs?
02:24:59 <__void__> (that's used in real life :) )
02:25:10 <Beelsebob1> __void__: pugs
02:25:23 <Beelsebob1> yi
02:25:23 <ivanm> __void__: GHC
02:25:24 <ivanm> ;-)
02:25:25 <Beelsebob1> leksah
02:25:28 <ivanm> hlint
02:25:30 <dschoepe> yi
02:25:40 <__void__> non-haskelll centric  xD
02:25:43 <Taejo> fractal (well, I use it in real life)
02:25:47 <ivanm> heh
02:25:54 <Taejo> but I did write it, so YMMV
02:25:55 <ivanm> __void__: well, pugs isn't haskell-centric
02:25:59 <ivanm> it's perl-centric ;-)
02:26:01 <Beelsebob1> in fact, fuck it, just look at http://hackage.haskell.org/packages/archive/pkg-list.html __void__
02:26:01 <lambdabot> Title: HackageDB: packages by category
02:26:55 <__void__> Beelsebob1: i was looking trough it , but i wanna know some "popular" ones, or mainstream
02:27:00 <ivanm> anyone here played around with ndm's cmdargs yet?
02:27:11 <__void__> i know that haskell provides bindings to near anything
02:27:14 <ivanm> __void__: well, we gave them to you!
02:27:23 <ivanm> though IIRC, dons blog has some rankings of haskell apps...
02:28:12 <Beelsebob1> __void__: well, the popular mainstream ones are xmonad, darcs, ghc, pugs, hugs
02:28:27 <mauke> hugs is C, isn't it?
02:28:31 <ivanm> yup
02:28:36 <ivanm> Beelsebob1: s/hugs//
02:28:37 <ivanm> ;-)
02:29:07 <Beelsebob1> oh, is it?
02:29:17 <__void__> hugs is another haskell compiler
02:29:23 <mauke> interpreter
02:29:24 <ivanm> no, it's an interpreter
02:29:26 <__void__> sorry
02:29:28 <dmwit> __void__: Well, there's been some games posted to Hackage recently.
02:29:32 <ivanm> so you should be! ;-)
02:29:44 <dmwit> Tetris, Pong, maybe a few other simple ones like that?
02:29:56 <ivanm> dmwit: but are they "mainstream"?
02:30:07 <Beelsebob> who cares?
02:30:07 <dmwit> *shrug*
02:30:09 <__void__> nobody mentioned holumbus, i've seen it before, when doing an scraping framework in python
02:30:11 <ivanm> after all, how many businesses would use them :p
02:30:20 <__void__> i wonder what does galois use
02:30:23 <Beelsebob> __void__: what's holumbus?
02:30:40 <Taejo> are any other haskellers competing in this year's Google Codejam
02:30:49 <__void__> the framework that powers hayoo
02:31:00 <Beelsebob> powers it in what way?
02:31:05 <Beelsebob> what functionality does it provide?
02:31:10 <Saizan_> argh, cmdargs uses a global mutable variable that's written to by pure code just to get nice syntax?
02:31:18 <__void__> http://holumbus.fh-wedel.de/trac
02:31:20 <lambdabot> Title: Holumbus – Trac
02:31:21 <Beelsebob> also, you did ask for programs, not frameworks
02:31:34 <__void__> is hilarios that they use trac for hosting the project
02:31:39 <Berengal> pandoc
02:31:40 <ivanm> Saizan_: it's a global mutable variable? :o
02:31:46 <ivanm> Berengal: ooh, forgot about that one...
02:31:46 <Beelsebob> __void__: what's hilarious about that?
02:31:55 <__void__> Beelsebob: sorry, i meant some 'haskell-in-real-life'
02:32:00 <ivanm> though I wish pandoc's library interface was nicer :s
02:32:24 <Berengal> TH makes order important :S
02:32:31 <__void__> that trac is something like .. subpar ... and in python ... does haskell do not have anything like it , a bugtracker with an integrated wiki
02:32:32 <Saizan_> ivanm: http://hackage.haskell.org/packages/archive/cmdargs/0.1/doc/html/src/System-Console-CmdArgs-UI.html#info
02:32:32 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/oxed7t
02:32:34 * Berengal just lots a little bit faith
02:32:51 <ivanm> Saizan_: :(
02:32:58 <ivanm> Berengal: in ndm?
02:33:04 <gwern> __void__: well, we have a very nice wiki in haskell, gitit
02:33:11 <dschoepe> __void__: afaik, bluespec uses Haskell for their synthesis/IC-design software.
02:33:18 <gwern> __void__: why not hack on it and add bugtracker? it'd also be distributed...
02:33:44 <gwern> you could steal the file format from one of the existing distributed bugtrackers, I suppose
02:33:56 <Berengal> ivanm, in TH.
02:34:09 <__void__> i'm trying to find if haskell is a good language for everyday use
02:34:25 <gwern> gitit also supports plugins, which lets you structure pages nicely: eg. emailing subscribing could be done as a plugin looking for special text fragments
02:34:26 <ivanm> well, I lost a little faith in ndm when Saizan_ pointed out the use of a global variable...
02:34:33 <__void__> i see it in more scientific / specific approaches, like dsls
02:34:48 <gwern> what's scientific or specific about gitti?
02:34:57 <__void__> nono, haskell in general
02:35:05 <__void__> (galois work for ex)
02:35:24 * gwern thinks everyone should just go and use gitit already
02:35:30 <ivanm> gwern: for what?
02:35:33 <ivanm> why would I use it?
02:35:36 <mauke> well, there are two haskell programs I use every day
02:35:39 <ivanm> I don't run a website, or a wiki
02:35:43 <gwern> ivanm: writing up your essays and notes and stuff
02:35:48 <gwern> everyone has things to write
02:36:10 <ivanm> I don't write up notes
02:36:18 <ivanm> my essays I write directly in LaTeX
02:36:56 * Twey too
02:37:03 * Twey uses org-mode for the notes.
02:37:31 <ivanm> I tried once to use pandoc/muse to write slides and notes for a talk...
02:37:46 <ivanm> in the end I just wrote beamer stuff directly from scratch
02:38:19 <Berengal> I once tried to write slides for a talk. In the end I just memorized it and used a whiteboard
02:38:26 <ivanm> heh
02:38:33 <ivanm> I kinda had to write slides
02:38:53 <kyagrd> I've seen people using pandoc to translate markdown to other forms
02:39:14 <gwern> well, that is one of the signature features of gitit
02:39:26 * ivanm would like to see pretty-printing interface to pandoc's library
02:39:28 <kyagrd> gwern: sure, but he was not using wiki
02:39:29 <gwern> don't like markdown/rst? then export the page source in like 9 different formats
02:39:33 <Berengal> gitit accepts just about any markup...
02:39:44 <kyagrd> gwern: processing existing markdown files
02:39:49 <gwern> kyagrd: where do you think gitit gets that ability?
02:40:00 <ivanm> kyagrd: pandoc does that
02:40:04 <kyagrd> pandoc library yes :)
02:40:14 <ivanm> pandoc is an app as well
02:40:19 <ivanm> not that great as a library IMHO
02:40:25 <Taejo> either pandoc or markdown doesn't realise that in English, quotes are not necessarily balanced, which is what stopped my attempted move from LaTeX to Markdown for non-scientific writing
02:40:28 <kyagrd> Yeah I've seen one using as an app
02:40:34 <ivanm> (unless it's drastically improved in the last year... haven't looked at it for a while)
02:40:53 <ivanm> Taejo: as in double quotes?
02:41:02 <ivanm> when do you not balance double quotes?
02:41:09 <gwern> Taejo: can't you disable the fancy quotes?
02:41:14 <kyagrd> British English double quotes are balanced but not American English
02:41:15 <mauke> 5'3"
02:41:21 <ivanm> ahhhh
02:41:25 <ivanm> silly imperial units
02:41:26 <ivanm> ;-)
02:41:29 <kyagrd> Amercian english screwed up
02:41:37 <Taejo> I mean real quotes, not double-prime marks
02:41:40 <kyagrd> How can they and a sentense in double quote?
02:41:46 <ivanm> tbh, that's also the case for thinks like latitude and longtitude
02:41:56 <gwern> iirc those fancy quotes are enabled with --smart, so presumably there's some way to disable it
02:41:57 <kyagrd> s/and/end/
02:42:11 <mauke> "This is a quoted paragraph.
02:42:16 <mauke> "It continues here.
02:42:18 <Taejo> if you quote multiple paragraphs, each paragraph gets an opening quote, but only the last gets a closing quote
02:42:19 <kyagrd> s/sentence/scentence/
02:42:37 <ivanm> oh, _that's_ what you mean
02:42:38 <Taejo> kyagrd: lol
02:42:57 <gwern> mauke: why is there a leading quote on each paragraph?
02:43:01 <kyagrd> oh now sentence was right :(
02:43:11 <kyagrd> s/now/no :( ah i'm sleepy
02:43:14 <Taejo> gwern: that's how English is punctuated
02:43:19 <Taejo> it doesn't have to make sense
02:43:21 <mauke> gwern: because English is weird
02:43:23 <ivanm> heh
02:43:34 <ivanm> mauke: aren't most languages weird in one way or another?
02:43:38 <gwern> I don't think I've ever done that, and no one's ever called me on it...
02:43:57 <ivanm> no-one sets out to make a spoken language that follows strict grammatical, syntactical, etc. rules
02:44:06 <blackdog> Taejo: I've never even seen that construction... is that standard?
02:44:11 <ivanm> (well, I suppose there's lojban, etc. ... but how many people speak that?)
02:44:13 <ivanm> blackdog: yes
02:44:14 <Taejo> using straight quotes is not a solution: it seems the solution is to use Latex
02:44:24 <gwern> ivanm: what, you mean basically any conlang?
02:44:53 <dmwit> Language is hard.
02:44:54 <ivanm> gwern: I should have prepended that with "and has it become very popular" or something ;-)
02:45:08 <Taejo> blackdog: it's the *only* common way (s/common/correct/ if that floats your boat) of quoting multiple paragraphs
02:45:17 <dmwit> not true
02:45:20 <ivanm> s/common/correct/
02:45:22 <gwern> ivanm: but no conlang has ever become very popular; the exceptions like modern hebrew arguably aren't conlangs
02:45:26 <dmwit> Blockquoting uses no quotation marks, and is correct.
02:45:35 <Taejo> dmwit: fair enough
02:45:36 <ivanm> and for multi-paragraph speech in novels, etc.
02:45:46 <ivanm> dmwit: true
02:46:21 <Taejo> "In most cases, quotations that span multiple paragraphs should be set as block quotations, and thus do not require quotation marks. Quotation marks are used for multiple-paragraph quotations in some cases, especially in narratives. The convention in English is to give opening quotation marks to the first and each subsequent paragraph, using closing quotation marks only for the final paragraph of the quotation. The Spanish
02:46:21 <Taejo> convention, though similar, uses closing quotation marks at the beginning of all subsequent paragraphs beyond the first."
02:46:37 <Taejo> so says Wikipedia
02:46:51 <gwern> closing quotation marks at the beginning?
02:46:54 * gwern 's head asplodes
02:47:00 <dmwit> Yeah, that's weird.
02:47:25 <Taejo> gwern: I think you're misreading
02:47:35 <ivanm> in some cyrillic languages, they use << and >> to denote quotes, etc.
02:47:42 <gwern> I hope I am because that makes no sense
02:47:56 <Saizan_> Taejo: hw was referring to the spanish part
02:47:57 <Taejo> it means there's only a closing quote at the *end* of the final paragraph
02:47:57 <gwern> ivanm: not just cyrillic; I see those thingies all the time in french/german stuff
02:47:59 <dmwit> I also think it's weird that they use both "subsequent" and "beyond the first" in that sentence.
02:48:00 <ivanm> gwern: in Spanish, they close every paragraph except the first
02:48:12 <Taejo> oh, didn't read the Spanish part
02:48:20 <mauke> that's not what it says
02:48:45 <Taejo> -blah, anyone?
02:48:52 <gwern> 'If you love Haskell and Linux then today is your day – today we reconcile the two and allow you to write Linux Kernel modules in Haskell. By making GHC and the Linux build system meet in the middle we can have modules that are type safe and garbage collected. Using the copy of GHC modified for the House operating system as a base, it turns out to be relatively simple to make the modifications necessary to generate object files for the Kernel ...
02:49:00 <gwern> ... environment. Additionally, a new calling convention (regparm3) was added to make it easier to import (and export) functions from the Kernel.'
02:49:01 <ivanm> Taejo: as soon as anyone says anything off-topic ;-)
02:49:02 <gwern> http://tommd.wordpress.com/2009/09/13/kernel-modules-in-haskell/
02:49:03 <lambdabot> Title: Kernel Modules in Haskell « Beware the Jabberwolk
02:49:16 <ivanm> gwern: I note that he never actually wrote any kernel code that I could see in there...
02:49:21 <ivanm> just telling you how to do it :s
02:49:35 <gwern> 'Continuing the example started by hello.c, ‘hsHello.hs’ is online [3].'
02:49:58 <__void__> i liked more the language topic :)
02:50:00 <ski> (ivanm : itym s/off/on/)
02:50:09 <__void__> i'm a native spanish speaker, i can help with that
02:50:46 <dmwit> __void__: So, does the Wikipedia page mean this?
02:50:47 <ivanm> heh
02:50:54 <dmwit> <<Paragraph 1.
02:50:58 <dmwit> >><<Paragraph 2.
02:50:58 <ivanm> ski: heh, yeah
02:51:02 <dmwit> >><<Paragraph 3.>>
02:51:03 <dmwit> ?
02:51:12 <ivanm> dmwit: no, I mean <<Hello>>, Bob said.
02:51:16 <ivanm> <<How are you today?>>
02:51:31 <dmwit> ivanm: I'm specifically referring to, "The Spanish convention, though similar, uses closing quotation marks at the beginning of all subsequent paragraphs beyond the first."
02:51:44 <ivanm> ahhh, no I think they mean
02:51:48 <gwern> hm. I wonder what the complexity of these quoting conventions are
02:51:49 <ivanm> "paragraph 1
02:51:51 <ivanm> "paragraph 2"
02:51:53 <ivanm> "paragraph 3"
02:51:54 <ivanm> etc.
02:51:59 <__void__> lemme grab a book and check
02:52:02 <mauke> ivanm: that's not at the beginning
02:52:03 <ivanm> gwern: O(asplode), I think
02:52:14 <ivanm> ahhh
02:52:27 <ivanm> mauke: is that the upside-down quotations you see at the bottom sometimes maybe then?
02:52:35 <mauke> I like `àwesome quoteś´
02:53:02 <gwern> I know my favored convention of 'opening quote at start of first paragraph, close quote at the end of the last paragraph' is O(depth) in number of quotes, but these other conventions sound more
02:53:05 <dmwit> ivanm: The orthography of opening and closing quotes is orthogonal to the placement of opening and closing quotes.
02:53:18 <lilac> ivanm: english: "<<foo bar\n<<baz quux\n<<meep meep>>" spanish: "<<foo bar\n>>baz quux\n>>meep meep>>", i think
02:53:21 <dmwit> Yeah, big words!
02:53:33 <ivanm> heh
02:53:43 <dmwit> lilac: ...oh
02:53:49 <dmwit> That would make more sense, I guess.
02:53:55 <lilac> ivanm: so in spanish, >> at the start of a para is a "quote continuation"
02:54:04 <mauke> „German quotes”?
02:54:09 <lilac> that makes it actually less ambiguous than the english convention afaics
02:54:24 <ivanm> mauke: that's what I was thinking of
02:54:45 * Taejo is sad that „Afrikaans quotes” have been supplanted by ``Afrikaans quotes''
02:55:16 <dmwit> The top five Google hits for "spanish multi paragraph quotation" have identical text to Wikipedia. =(
02:55:23 * Taejo blames the long-time absence of a South African keyboard layout
02:55:28 <ivanm> dmwit: of course they do!
02:55:29 <Saizan_> omg, typography is the work of the devil!
02:56:31 <dmwit> most of the next ten do, too =(
02:57:05 <ivanm> dmwit: direct clones?
02:57:08 <ivanm> or just liberal quoting?
02:57:17 <lilac> "linux kernel modules in haskell: now your gigabyte space leaks are in kernel mode!"
02:57:25 <dmwit> ivanm: direct clones
02:57:29 <__void__> damn , i couldn't find multipara quotes in geb
02:57:37 <gwern> dmwit: well, that's Free content for ya
02:57:43 <gwern> google doesn't penalize them heavily enough imo
02:57:44 <ivanm> lilac: lol
02:57:54 <ivanm> @remember lilac linux kernel modules in haskell: now your gigabyte space leaks are in kernel mode!
02:57:54 <lambdabot> I will never forget.
02:58:10 <Taejo> ivanm: Wikipedia's internal linking does great things for its PageRank; unfortunately, the same holds for Wikipedia mirrors
02:58:24 <__void__> but i'm preety sure i've seen " para1, para2,"
02:59:28 <gwern>  #haskell: because none of us are as offtopic as all of us
02:59:51 <Taejo> @remember gwern #haskell: because none of us are as offtopic as all of us
02:59:51 <lambdabot> I will remember.
03:00:06 <__void__> in spanish we use opening quotation marks and opening exclamation marks also
03:02:21 <__void__> haskell is preety good for working in nlp no?
03:03:04 <gwern> good at parsing means good at nlp
03:03:41 <__void__> gwern: for some task you have to process large amonunt of data, like when pos taggin comparing to a corpora
03:04:03 <__void__> but i think fp is the most appropiate model to program for language structures
03:04:14 <__void__> 'cause of the recursion in language
03:04:47 <ski> LP is not bad, either
03:05:17 <ski> (btw, most imperative languages has recursion, too, no ?)
03:05:38 <gwern> ski: don't support it well
03:05:42 <Berengal> Most imperative languages has loops
03:06:33 * Berengal always thought recursion was the cleaner alternative
03:06:33 * ski would think pattern-matching is also an important factor when manipulating language structures
03:07:10 <Taejo> ski: if you go for the statistical stuff, arrays and matrices are pretty important
03:07:50 * ski hasn't really done much of nlp :)
03:14:01 <hackagebot> arbtt 0.1 - Automatic Rule-Based Time Tracker (JoachimBreitner)
03:22:55 <ivanm> is there an inverse function to intersperse?
03:23:36 <nomeata> ivanm: concat?
03:23:43 <nomeata> ivanm: or more like split?
03:23:58 <nomeata> (eh, yeah, concat would not be it :-))
03:24:15 <nomeata> http://hackage.haskell.org/package/split might contain the variant you are looking for
03:24:15 <lambdabot> Title: HackageDB: split-0.1.1
03:24:30 <ivanm> yeah, a split
03:34:40 <mmorrow> ivanm: some information is lost during `intersperse' though (in the situation where the [a] already contains at least one if the elem you're interspersing)
03:34:52 <mmorrow> *one of ...
03:35:10 <ivanm> mmorrow: I know I don't have that ;-)
03:35:22 <ivanm> I'm trying to split up a Module path into it's sub-components
03:35:36 <mmorrow> ah, yeah that one :)
03:36:06 <ivanm> and I've decided to be lazy and have that done later (i.e. store the full qualified module name, and have functions pull it apart, rather than splitting it and have functions put it back together again)
03:36:28 <mmorrow> that's one of those annoying things that repeatedly come up, but every time you seem to have to write it from scratch..
03:36:47 <ivanm> yeah
03:37:01 * mmorrow is trying to remember where one instance of that is
03:37:15 <ivanm> byorgey's split package seems to have it; it just seems to be a (relatively minor) expensive import for one function I could re-write from scratch :s
03:39:25 <mmorrow> ivanm: yeah, i find i only really use this one split function:
03:39:31 <mmorrow> split _ [] = []; split p xs = let (ys,zs) = break p xs in ys : split p (drop 1 zs)
03:40:13 <mmorrow> err, i was thinking of the module name split, in addition to having to then put it into a:
03:40:14 <ivanm> someone helped me once do something similar: breakAll p = groupBy (const (not . p))
03:40:18 <mmorrow> ([String],String)
03:40:25 <mmorrow> which is the annoying part
03:40:32 <ivanm> mmorrow: yeah, that's something I was looking at as well
03:40:36 <mmorrow> (since you have to split on last)
03:41:12 <ivanm> I was thinking of writing a tailLast function to do a single pass for tail and last (because for some reason I don't like doing tail and last...)
03:41:13 <hackagebot> arbtt 0.1.1 - Automatic Rule-Based Time Tracker (JoachimBreitner)
03:41:27 <mmorrow> what i usually settle on is to (fmap reverse . uncons . split (=='.') . reverse)
03:41:48 <mmorrow> where uncons (x:xs) = (x,xs)
03:42:24 <ivanm> I guess Joachim found a bug pretty quickly...
03:42:35 <mmorrow> heh
03:42:40 <ivanm> mmorrow: you reverse it twice?
03:42:41 <ivanm> :o
03:42:46 <ivanm> isn't that, you know, _bad_? :p
03:42:51 <mmorrow> err, oops
03:43:05 <mmorrow> (fmap reverse . uncons . reverse . split (=='.'))
03:43:26 <mmorrow> yeah, to get at the last val, rather than use init+last
03:43:35 <mmorrow> but i guess it's the same actually.. hmm
03:43:48 <mmorrow> ideally you want unsnoc
03:43:54 <mmorrow> (great name btw :)
03:44:03 <ivanm> heh
03:44:21 <mmorrow> i know i have that in some module somewhere..
03:44:26 * mmorrow tries to remember
03:45:02 <mmorrow> it's little functions like this that're prelude-worthy definitely
03:45:06 <mmorrow> e.g. swap
03:45:24 <ivanm> swap (a,b) = (b,a) ?
03:45:30 <mmorrow> also, Prelude needs a "zip-with-leftover" function
03:45:48 <mmorrow> ivanm: yeah, but it's annoying to keep having to rewrite it
03:46:53 <ivanm> agreed
03:46:54 <mmorrow> zipAnd :: (a -> b -> c) -> [a] -> [b] -> ([c],[Either [a] [b])
03:47:30 * ivanm doesn't think he's ever needed that one...
03:47:39 <raimo_> is there some simple way to generate all string permutations in haskell?
03:48:11 <loop> @type permutations
03:48:12 <lambdabot> forall a. [a] -> [[a]]
03:48:15 <mmorrow> if you need the remainder of one of the lists, i've found it's impossible with any of the pre-packaged functions (i.e., you wave to write a manual explicitely recursive variant of zip)
03:48:26 <mmorrow> s/wave/have/
03:51:11 <mmorrow> (impossible without >1 traversals)
03:52:16 <mmorrow> (and impossible for real if one of the lists is infinite)
03:52:23 <mmorrow> @src zipWith
03:52:23 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
03:52:23 <lambdabot> zipWith _ _      _      = []
03:53:56 <Raevel> compiling the haskell platform on ubuntu failed for me, but then by magic it worked on the next attempt
03:54:08 <mmorrow> @let zipAnd _ [] bs = [Right(Right bs)]; zipAnd _ as [] = [Right(Left as)]; zipAnd f (a:as) (b:bs) = Left (f a b) : zipAnd f as bs
03:54:08 <lambdabot>  Defined.
03:54:48 <nomeata> ivanm: not me, but Nicolas Pouillard, who tried to build it on MacOS and does not like case sensitivity name clashes
03:59:47 <mmorrow> are there any other "standard" names for an inverted tree? i've heard them called {inverted,sink,?} trees before.
04:00:36 <mmorrow> oh, also "inward-directed" trees
04:00:48 <lilac> > let swap a b = map (\x -> if x == a then b else if x == b then a else x); splitOn x = map (swap x ' ') . words . swap x ' '  in  splitOn '.' "Hello.World.Module foo bar"
04:00:48 <lambdabot>   ["Hello","World","Module foo bar"]
04:00:49 <mauke> where every node knows its parent?
04:00:49 <Twey> What is an inverted tree?
04:00:56 <c_wraith> inverted meaning parent pointers as opposed to child pointers?
04:00:58 * mmorrow is trying to decide on his choice of name for this module he needs to write
04:01:15 <lilac> mmorrow: in haskell we call them lists ;-)
04:01:22 <mmorrow> mauke: right, thinking of a tree as a dag, it's the opposite graph
04:01:36 <mmorrow> lilac: :o
04:01:43 <mauke> yeah, those are called linked lists
04:01:58 <mmorrow> i don't think i'm making this completely clear
04:02:10 <mmorrow> would you call a Tree a linked list?
04:02:13 <c_wraith> If being used in the union/find algorithm, I'll sometimes call them union/find trees
04:02:18 <mauke> mmorrow: no
04:02:23 <mmorrow> mauke: hmm.
04:02:25 <lilac> mmorrow: no, because each node points to multiple children, not just one
04:02:26 <ski> > zipAnd undefined [] []
04:02:28 <lambdabot>   [Right (Right [])]
04:02:36 <lilac> mmorrow: but the other way up, each node points to a single parent, or is the root
04:02:49 <mauke> Node x parent | Root
04:03:16 <Saizan> so the whole tree will be like lists that share the tail at some point
04:03:37 <mmorrow> here's an image of what i'm talking about (although the article this image is from isn't necessarily the application) http://upload.wikimedia.org/wikipedia/commons/e/e5/Spaghettistack.svg
04:03:37 <Saizan> unless you add explicit ids for node identity
04:03:38 <lambdabot> http://tinyurl.com/qchnfq
04:03:53 <c_wraith> I never did figure out a permutation algorithm for lists that time efficient, memory efficient, and lexicographically ordered.
04:03:58 <mauke> mmorrow: those are three linked lists
04:04:01 <mmorrow> Saizan: right, linked lists with a shared tail
04:04:06 <lilac> mmorrow: rotate right 90 degrees, and imagine the tails being shared
04:04:09 <mmorrow> but by that same token then
04:04:17 <mmorrow> data Tree a = Node a [Tree a]
04:04:24 <mmorrow> are linked lists with a common prefix
04:04:29 <mauke> no such thing
04:04:33 <mmorrow> why not?
04:04:56 <mauke> because if the prefix is the same, everything else must be the same too
04:05:01 <mmorrow> it's just the reverse-graph of an inverted-tree
04:05:04 <mauke> so they're really the same list
04:06:45 <lilac> mmorrow: "data UpsideDownTree a = Node a (UpsideDownTree a) | Root" is isomorphic to "data List a = Cons a (List a) | Null"
04:06:49 <lilac> does that help?
04:08:29 <mmorrow> data ITree = ([NodeId], [(NodeId.[NodeId])])
04:08:48 <mmorrow> you have as entry-point the entire list of leaves
04:09:13 <mmorrow> since you only have links going root-ward
04:09:38 <mmorrow> just like you have a single entry-point to a regular tree, going leaves-ward
04:10:34 <mmorrow> data Tree = (NodeId, [(Node,[NodeId])])
04:12:19 <mmorrow> (also, you can't represent an Inverted Tree with haskell ADTs directly (without a level of indirection), since you'd need explicit sharing)
04:13:09 <mmorrow> (or duplication)
04:14:28 * mmorrow goes with inverted-tree
04:15:13 <mauke> call it eert
04:18:25 <mmorrow> hehe
04:23:06 <mmorrow> somewhat related, this is my new wallpaper (for a haskell module Scope.hs, it's the dominator trees, one rooted at each label, of the control flow in Scope.s)  http://moonpatio.com/images/Scope_s_DOM.png
04:23:34 <mmorrow> unfortunately the shapes aren't very interesting because ghc uses a bunch of indirect jumps
04:23:48 <mmorrow> but there's a crapload of them :)
04:26:00 * mmorrow stares
04:26:56 <mmorrow> i want to do one for a big C file too, and see how different they look
04:27:08 <mmorrow> the C one'll probably have some cool shapes
04:33:21 <maurer_> When using GHC profiling, should I expect the time percentages in the top level to add up?
04:33:58 <maurer_> Err, nvm, found the issue
04:34:57 <maltem> With regard to GHC profiling, I'd really appreciate an explanation of all the statistics for the profilistically impaired
04:41:13 <kakeman> i have to compile one .hs file to binary. how?
04:41:21 <maurer_> ghc foo.hs
04:41:30 <kakeman> nice
04:41:33 <kakeman> :)
04:41:50 <mauke> if you get linker errors, the first thing to try is ghc --make foo.hs
04:41:51 <maurer_> Random curiosity, does ghc have an option to build with a static gmp, etc. if available?
04:42:08 <mauke> IIRC there was something like -optl-static
04:43:37 <maurer_> mauke: Thanks for the idea. GHC gets bitchy about pthreads, but maybe I can find a solution
04:43:41 <Axman6> kakeman: ghc --make foo.hs is what you need 99% of the time
04:43:42 <InkBottle> Hi, I'm looking for links to functional style programing implementations of operations on finite state automaton (usual operations, mean determinization, minimization, regex to nfa...); either algorithms or real library code.
04:44:13 <mauke> well, ghc -Wall -O2 --make foo.hs, while we're at it
04:45:57 <Peaker> InkBottle: I think the regex-dfa package might have that, but not sure
04:45:59 <maltem> InkBottle, there are some regex-something libs on hackage. Not sure if they are fancy enough for your needs
04:46:25 <Axman6> InkBottle: it's really quite easy to implement a FSA in haskell.
04:49:03 <maltem> It's nice how you can implement a circular automaton as an infinite tree in haskell. It basically looks like just another monad. Graph-theoretic algorithms mostly fail on such a representation, of course :)
04:51:25 <maurer_> In case anyone else was wondering, it's -optl-static -optl-pthread that you need to get it to work.
04:55:48 <InkBottle> thank you, really
05:02:12 <__JN> hello, i need som help. I have a function i.e. F, and a list, let's call it L. Now, F (head L) >>= (\r -> return (name r)) works fine, but how to do something like mapM (F >>= (\r -> return (name r)) ) L ?. The result I want is a list of names.
05:03:37 <Axman6> map F L?
05:04:07 <maltem> __JN, as long as you just use `return', there's not much need to use monadic operators at all. Or do you have something different in your real code?
05:04:48 <__JN> ret <- (mapM (listStoreGetValue model  ) lps) >>= (\r -> return ( name r ) )
05:04:52 <Axman6> yeah, if you could paste your actual code, that would help a lot
05:05:10 <__JN> L=lps
05:05:12 <maltem> oh, I guess  F :: a -> m a   or something
05:05:16 <__JN> if the code is any help...
05:05:22 <Axman6> :t sequence
05:05:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:05:33 <Axman6> :t mapM
05:05:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:06:40 <maltem> __JN, I don't get it right now, but maybe you can simplify this by first mapping F over your list, and then map  name  over the result?
05:07:48 <__JN> ret' <- listStoreGetValue model (head lps) >>= (\r -> return ( name r )), is no problem, but to get not just head lps, but all values into ret... I'm stuck
05:08:32 <maurer_> Is there a way to detect if you're about to enter a black hole thunk?
05:08:59 <maltem> __JN, you know, when you pull Haskell code apart into such fragments, nobody understands it anymore ;-)
05:10:37 <__JN> ok, sorry, how can I show want I mean?
05:11:06 <maltem> @hpaste
05:11:06 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:11:39 <maltem> Alternatively, questions like "is there a function of the following type" tend to work relatively good
05:13:16 <Axman6> maltem: s/haskell/
05:14:10 <Saizan> __JN: "mapM (\x -> F x >>= (\r -> return (name r))) L" perhaps?
05:14:22 <Saizan> which can be simplified further
05:14:38 <__JN> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3585#a3585 shows the whole function
05:15:50 <Saizan> __JN: you can't just attach the ">>= (\r -> return ( name r ) )" there because the result of "(mapM (listStoreGetValue model) lps)" is a list
05:15:52 <Axman6> @pl foo >>= (\r -> return (name r)
05:15:52 <lambdabot> (line 1, column 31):
05:15:52 <lambdabot> unexpected end of input
05:15:52 <lambdabot> expecting variable, "(", operator or ")"
05:15:57 <Axman6> @pl foo >>= (\r -> return (name r))
05:15:57 <lambdabot> name `fmap` foo
05:16:07 <Axman6> __JN: ^^^^
05:16:27 <Saizan> you need to do: "(mapM (listStoreGetValue model) lps) >>= (\r -> return ( map name r ) )"
05:16:36 <Axman6> so, i think you want mapM (\x -> name `fmap` F x)
05:16:48 <Saizan> yeah, in the end you want that
05:17:39 <__JN> many thanks! your suggestion did the trick Saizan!
05:17:52 <__JN> thank you all for your help!
05:18:14 <Saizan> (mapM (listStoreGetValue model) lps) >>= (\r -> return ( map name r ) ) = map name `fmap` mapM (listStoreGetValue model) lps = mapM (\x -> name `fmap` listStoreGetValue model x) lps
05:29:31 <Peaker> @hlint
05:29:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:32:59 <jpcooper> hello
05:33:22 <jpcooper> will indentation of if-statements in haskell-mode be sorted out? Or has it already been?
05:36:22 <ivanm> define "sorted out"
05:36:31 <ivanm> and is this inside a do-block or not?
05:37:54 <jpcooper> ivanm, made to work
05:37:58 <jpcooper> what do you think that it could mean otherwise?
05:38:10 <ivanm> well, it works here...
05:38:12 <Vanadium> What is haskell mode
05:38:15 <ivanm> what makes you think it doesn't work?
05:38:25 <ivanm> jpcooper: oh, is this for emacs or vim?
05:38:37 <jpcooper> its not working for me makes me think that it doesn't work. What else could make me think that it doesn't work?
05:38:39 <ivanm> Vanadium: a syntax/indentation/etc. mode for haskell in either emacs or vim
05:38:42 <jpcooper> I don't understand why these questions have to be asked
05:38:45 <Vanadium> ah
05:38:48 <ivanm> (vim's is normally called haskellmode without the hyphen)
05:38:58 <ivanm> jpcooper: how doesn't it work?
05:39:13 <jpcooper> as said, the indentation of if-statements doesn't work as it should
05:39:20 <Vanadium> Urgh.
05:39:24 <ivanm> in do blocks, or normally?
05:39:30 <ivanm> and how aren't they indented properly?
05:39:46 <ivanm> in do-blocks, then yes, I know there's a bug in emacs haskell mode
05:39:56 <ivanm> in that the indent cycle doesn't work properly
05:39:59 <jpcooper> the "then" and "else" parts are indented to the same column as the "if" part, rather than being indented further forwards
05:40:02 <ivanm> but the first auto-indent does indeed work
05:40:09 <ivanm> jpcooper: in a do block?
05:40:37 <jpcooper> anywhere
05:40:52 <ivanm> ummm... normally, the then and else are meant to be aligned with the if
05:41:41 <jpcooper> and not in do-statements?
05:42:03 <dschoepe> jpcooper: adding "(setq haskell-indent-thenelse 3)" to my .emacs fixed that for me.
05:42:03 <jpcooper> I don't understand why it hasn't been sorted out for do-statements
05:42:04 <ivanm> no
05:42:18 <jpcooper> this bug has existed for about three years now
05:42:18 <ivanm> jpcooper: because the parser is bad? *shrug*
05:42:21 <jpcooper> probably longer
05:42:38 <ivanm> jpcooper: if you think it's that bad, then I'm sure patches are accepted! ;-)
05:42:49 <ivanm> dschoepe: never heard of that variable before...
05:42:56 <ivanm> is that for all if-then-else statements?
05:43:16 <jpcooper> I don't know enough of emacs to do. I would have hoped that the gravity of this bug would merit either the maintainer or someone able, to fix it
05:43:38 <dschoepe> ivanm: I think so. it's possible that this variable is only present in haskell-mode-cvs though
05:43:46 <ivanm> jpcooper: also, the auto-indent in a do-block does it properly; it's just the indent cycle (which "intelligently" tries to work out where the next line should go without knowing it's in an if-statement) that doesn't work
05:43:58 <ivanm> jpcooper: there's also kuribas' mode, which quicksilver swears by
05:43:59 <jpcooper> right
05:44:01 <ivanm> @where kuribas-mode
05:44:01 <lambdabot> I know nothing about kuribas-mode.
05:44:04 <ivanm> @where kuribas
05:44:04 <lambdabot> I know nothing about kuribas.
05:44:07 <Cale> Huh? the 'then' and 'else' should always be indented more than the 'if'
05:44:08 <ivanm> @go kuribas haskell emacs
05:44:08 <lambdabot> Maybe you meant: google googleit do
05:44:14 <ivanm> Cale: should they? :o
05:44:19 <ivanm> I only ever do that in a do-block
05:44:19 <Cale> Because they're part of the if expression.
05:44:31 <ivanm> in "normal" code, I have them all aligned...
05:44:37 <Axman6> Cale: has the URL announcing in \bot been fixed yet?
05:44:43 <ivanm> *shrug* so that's a stylistic thing rather than a syntactic one by the looks of things...
05:44:47 <Cale> Axman6: fixed how?
05:44:51 <ivanm> dschoepe: *nod*
05:44:52 <Cale> Axman6: Do you mean turned off?
05:44:54 <ivanm> @users
05:44:54 <lambdabot> Maximum users seen in #haskell: 658, currently: 572 (86.9%), active: 14 (2.4%)
05:44:56 <Axman6> well, turned off
05:45:03 <Cale> No, I haven't touched anything.
05:45:05 <ivanm> Cale: so the @seen plugin got re-enabled, did it?
05:45:05 <mun_> i got a slightly irrelevant question and it's about FOL theorem provers: since FOL is semi-decidable, how come FOL provers like Vampire work well? do they try to make a way around somehow?
05:45:05 <dschoepe> ivanm: that never worked for me. I always had to indent them more than the if.
05:45:13 <ivanm> dschoepe: hmmm....
05:45:15 * ivanm checks
05:45:16 <Cale> I'm running a stock lambdabot
05:45:24 <Cale> on a different server
05:45:35 <Cale> while lispy figures out what happened to the other one
05:45:38 <ivanm> nope, works here without extra indents
05:45:40 <Axman6> ah, ok
05:45:41 <ivanm> Cale: *nod*
05:45:51 <ivanm> "stock" lambdabot rather than "fixed" lambdabot? ;-)
05:45:58 <Cale> I always indent if like:
05:46:00 <Cale> if foo
05:46:00 <Axman6> well, she's been banned from #macosx until she stops announcing URLs
05:46:01 <dschoepe> ivanm: okay, I also checked, it works. perhaps a recent change?
05:46:02 <Cale>    then bar
05:46:05 <Cale>    else quux
05:46:14 <ivanm> dschoepe: I've always had it work for me...
05:46:16 <Cale> Aligning the 'then' and 'else' with the condition.
05:46:20 <jpcooper> Cale, do you know how I can enable auto-indent?
05:46:27 <ivanm> then again, I generally try to avoid if statements
05:46:28 <Cale> jpcooper: auto-indent?
05:46:41 <ivanm> jpcooper: hit enter, hit tab... that's what I'm calling "auto-indent" ;-)
05:46:47 <jpcooper> yes, apparently auto-indent indents if-statements properly
05:46:55 <Cale> if-expressions
05:47:02 <dschoepe> ivanm: very strange. I could swear ghc complained about that a while ago.
05:47:03 <jpcooper> ivanm, well it doesn't for me
05:47:12 <jpcooper> I've tried both the normal version and the CVS version of haskell-mode
05:47:44 <ivanm> jpcooper: http://article.gmane.org/gmane.comp.lang.haskell.cafe/62495
05:47:46 <lambdabot> Title: Gmane -- Mail To News And Back Again
05:47:48 <ivanm> covers your problem ;-)
05:48:09 <jpcooper> thanks
05:48:25 <ivanm> @where+ kuribas-mode http://kuribas.hcoop.net/haskell-indentation.el
05:48:25 <lambdabot> I will remember.
05:49:48 <ivanm> I personally didn't like it (the parser is a bit too strict for my taste; if I wanted to write another function whilst I was halfway through another, it would refuse to indent the other function properly) but you might like it
05:50:00 <jpcooper> oh
05:50:14 <maurer_> Here's a question--as I recurse, I need to keep track of the path I took (for cycle detection), so I need to feed through a data structure that keeps track of where I've been so far
05:50:45 <maurer_> The problem is that if I use lists, this is O(n) membership checking, so it ends up being O(cycle length^2) in bad cases
05:50:56 <maurer_> If I use a real data structure, it keeps getting copied, which is also an O(n) operation
05:50:58 <maurer_> Ideas?
05:51:03 <ivanm> State?
05:51:03 <maltem> mun_, I'd just suspect it to not always be successful (only in special, but common, cases, or something), but I don't know anything about this
05:51:28 <maurer_> ivanm: I could do it that way, but I was hoping there was a clean way to do this.
05:51:49 <ivanm> maurer_: use Sequence?
05:51:53 <ivanm> or DList?
05:52:01 <maurer_> Looking those up
05:52:57 <mun_> maltem, i see. but how come some provers can prove FOL theorems that other provers can't?
05:53:17 <ehamberg> in RWH, in the Programming with Monads chapter, there are some examples of naïve lookup code doing "case foo of Just (bar@(_:_)) -> bar". isn't the "@(_:_)" completely superfluous? or will that make sure it only continues if the value in the Just is a list?
05:53:30 <maurer_> ivanm: Those don't solve the problem.
05:53:32 <ehamberg> (simplified example)
05:53:35 <mauke> ehamberg: a non-empty list
05:53:42 <ivanm> ehamberg: yes
05:53:50 <ehamberg> right. ok. :)
05:53:50 <ivanm> otherwise, bar will also match []
05:53:51 <maurer_> ivanm: They avoid allocation, but have the same problem I have with a regular list--O(n) membership detection
05:54:11 <Cale> maurer_: copied?
05:54:18 <Cale> maurer_: Use a Set.
05:54:37 <ivanm> Cale: I think he's worrying about pass-by-value becoming expensive...
05:54:37 <Cale> maurer_: I don't understand what you mean by "keeps getting copied"
05:54:46 <ivanm> (in terms of memory)
05:54:59 <ivanm> since lists have pointers for shared memory, etc. purposes
05:55:04 <Axman6> ChilliX: are you around man?
05:55:10 <maurer_> ivanm: Yeah, basically
05:55:11 <ivanm> (if you only prepend, that is)
05:55:28 <ivanm> maurer_: unless you're talking about a _huge_ case, I wouldn't worry about it
05:55:35 <Cale> maurer_: Inserting an element into a Set is O(log n) time, and determining if an element is in it is the same.
05:55:36 <ivanm> intelligent stuff normally happens so you don't have to ;-)
05:55:47 <maurer_> Cale: That time complexity is fine
05:55:53 <Cale> maurer_: (and O(log n) space)
05:56:00 <maurer_> Wait what?
05:56:09 <maurer_> How does it store the set in O(log n) space
05:56:21 <ivanm> maurer_: Set is tree-based; so it only alters log n of the nodes in the tree
05:56:22 <Cale> It shares all subtrees which are the same
05:56:27 <ivanm> so the "diff" is small
05:56:36 <ivanm> maurer_: is order important?
05:56:39 <maurer_> Ah, Set has intelligent Diff?
05:56:40 <Cale> You only have to make a new path from the element up to the root
05:56:43 <maurer_> No, order is not important.
05:56:48 <ivanm> maurer_: then go with Set
05:56:49 <Cale> It's automatic.
05:56:58 <ivanm> log n everything just about ;-)
05:57:09 <Cale> When you build a datastructure by referring to parts of another, the structure isn't copied.
05:57:16 <Cale> It's shared between the two.
05:57:32 <ivanm> pass-by-value _looks_ like it's copying everything
05:57:34 <maurer_> Cale: Yes, that makes sense, but without delving into implementation, I don't know what "insert" does with that.
05:57:37 <ivanm> but in reality, it uses pointers
05:57:49 <ivanm> maurer_: which is why I was telling you not to worry about it ;-)
05:57:52 <maltem> mun_, maybe they pursue different strategies? Of course, when you run one prover after the other, you would then have a prover that is a little better
05:57:53 <maurer_> :P
05:58:19 <ivanm> admittedly, it is theoretically worse in a pure lang like Haskell than an impure one since you wouldn't have to do _any_ copying...
05:58:26 <ivanm> but it's not all that bad really
06:00:02 <maurer_> ivanm: Basically this is a problem I ran into in a silly coding competition a while ago (I think I tried Array and lists) which annoyed me because the C guys just made a giant array and flipped bits. Trying to make it work now.
06:00:16 <ivanm> heh
06:00:51 <mun_> maltem, right. so the undecidable problems can be decidable only depending on the strategies?
06:01:10 <ivanm> wtf? undecidable == decidable if you do it properly? :o
06:01:28 <Cale> maurer_: Well, suppose that it examines the root of the tree and decides that the element to insert is to be inserted into the right subtree. Then the result of the insert y (Branch x l r) will be Branch x l r', where r' is the new right subtree, which, being simplistic about things, is just insert y r.
06:01:55 <maltem> mun_, the problem of finding a proof of *any* FO theorem just isn't decidable
06:01:55 <Cale> (The actual Set implementation is a little fancier and does some balancing, and keeps track of some size information to help with that)
06:02:11 <ivanm> it's full of coolness
06:02:15 <ivanm> and that's all you have to know ;-)
06:02:17 <maurer_> Cale: Yes, I see how it should be about O(log n) new space per operation, which should be fine.
06:02:22 <Cale> But the thing to notice is that x and l are just references to parts of the original tree.
06:02:47 <maurer_> Yes, this makes sense, just like how with only Consing to lists, things remain cheap
06:03:05 <ivanm> only because under the hood it's pass-by-reference
06:03:13 <maurer_> Sure.
06:03:19 <maurer_> Well, no, not quite...
06:03:23 <ivanm> kinda ;-)
06:03:36 <maltem> mun_, with a given strategy, you solve a different, possibly decidable problem: finding proofs for any theorem of a *certains subset* of FO
06:04:21 <mun_> maltem, i see.
06:04:26 <Cale> maurer_: yeah, similar
06:04:39 <Cale> maurer_: Just as lists share tails, trees can share subtrees
06:05:14 <mun_> maltem, i've read that FOL is semi-decidable if the problem uses predicates of arity >2, do you know why?
06:05:17 <maltem> Btw it drove me a little crazy to learn that there are complete calculi for FO, but still FO is undecidable :)
06:05:17 <maurer_> Yes, this makes sense, I guess I just (incorrectly) assumed that I'd have the same problem with Sets that I had with arrays
06:05:38 <mun_> maltem, i can't seem to find anything explaining why.
06:05:49 <maltem> mun_, sry I don't even know what semi-decidable means
06:06:00 <|Steve|> mun_: I'd find that hard to believe since any 0-, 1-, or 2-ary predicates could be turned into a ternary predicate.
06:06:12 <ivanm> maltem: you can semi-decide it? :p
06:06:30 <mun_> maltem, well undecidable if you may. FOL is semi-decidable because you can always prove valid theorems, but not invalid ones.
06:06:47 <maltem> ivanm: oh that makes it perfectly clear :-
06:06:53 <ivanm> heh
06:06:58 <|Steve|> mun_: Define semi-decidable.
06:07:10 <mun_> |Steve|, taken from wiki on FOL: "Unlike propositional logic, first-order logic is undecidable (although semidecidable), provided that the language has at least one predicate of arity at least 2 (other than equality). "
06:07:34 <|Steve|> Do you mean Turing-recognizable (recursively enumerable)?
06:07:43 <maltem> mun_, wait, I don't believe this. If I can prove any valid theorem, then I can prove (not q), where q is a non-theorem.
06:07:51 <mun_> |Steve|, how do you turn, say, unary predicates to ternary ones?
06:07:59 <maltem> wait, that wasn't quite right by me
06:08:18 <mun_> maltem, |Steve| http://en.wikipedia.org/wiki/First-order_logic#Completeness_and_undecidability
06:08:19 <lambdabot> Title: First-order logic - Wikipedia, the free encyclopedia, http://tinyurl.com/nveyr
06:08:25 <mun_> |Steve|, i agree with you -- it confuses me.
06:08:26 <maltem> rather: where q is false
06:09:12 <|Steve|> mun_: Let P(x) be a unary predicate, then let P'(x,y,z) = {(x,y,z) | P(x)}.
06:09:13 <mun_> "if a sentence A logically implies a sentence B then this can be discovered (for example, by searching for a proof until one is found, using some effective, sound, complete proof system). However, if A does not logically imply B, this does not mean that A logically implies the negation of B. There is no effective procedure that, given formulas A and B, always correctly decides whether A logically implies B."
06:09:45 <|Steve|> So you just mean recognizable (recursively enumerable).
06:10:16 <mun_> |Steve|, i guess so, but i don't know what you mean by recursively enumerable.
06:10:57 <|Steve|> http://en.wikipedia.org/wiki/Semidecidable
06:11:00 <maltem> Damn. this was the actual point of my logics course last year, and I didn't even really grasp it
06:11:46 <|Steve|> mun_: probably easiest to think about in terms of Turing machines, but if you're unfamiliar with those, then 6am is not the time for me to explain it.
06:12:20 <maltem> mun_, what does "can be discovered" mean? That it is found in finite time?
06:12:30 <|Steve|> Yes.
06:13:06 <mun_> |Steve|, i see what it's saying. so if a formula is not in a FOL theory, you won't necessarily get a negative answer.
06:13:55 <|Steve|> yes
06:13:59 <maltem> Ah. So does this mean that complete theories are decidable?
06:14:23 <mun_> but what makes predicate logic and FOL different in this respect? how come you can verify whether a formula is missing from a predicate logic theory and not from a FOL?
06:14:56 <maltem> mun_, you mean propositional logic?
06:15:14 <mun_> maltem, yeah, sorry.
06:15:28 <|Steve|> It's the quantifier that makes them difference.
06:15:31 <|Steve|> er, different
06:15:39 <|Steve|> Spelling is hard late at night.
06:15:45 <mun_> :)
06:17:11 <maurer_> If I have a function http://pastebin.com/m51c2acf0 and I run it in two different threads (for example via parMap) and one thread evaluates someval, and the other goes to resolve it, will the memoization go across the thread barrier, or not?
06:17:12 <maltem> Intuitively, interpretations of propositional logic are always enumerable, even finite for a finite number of propositions. Whereas in FO, models of arbitrary cardinality abound.
06:17:24 <maurer_> I suppose I could try to test this, but it seems like writing the test would be hard.
06:17:25 <mun_> this is getting a bit confusing: Godel's completeness theorem says that they were sound and complete deductive systems for FOL, then how come FOL is semi-decidable?
06:17:47 <Axman6> maurer_: haskell doesn't do memoisation
06:18:08 <maurer_> Axman6: It kind of does in cases like this...
06:18:18 <maltem> mun_, when you got a succint explanation, don't forget to tell me. Unfortunately I'm leaving now
06:18:41 <Axman6> maurer_: to some degree, yeah
06:18:58 <maurer_> http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/src/Data-MemoCombinators.html
06:18:58 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/plq4bw
06:19:06 <maurer_> Think along the lines of the bool function there.
06:19:19 <maurer_> I'm wondering whether tricks like this work across thread boundaries
06:19:23 <jonh> ok this is awesome http://tommd.wordpress.com/2009/09/13/kernel-modules-in-haskell/
06:19:23 <lambdabot> Title: Kernel Modules in Haskell « Beware the Jabberwolk
06:19:30 <tommd> Thanks :-)
06:19:40 <jonh> np :)
06:19:41 <Berengal> maurer_, if two threads have pointers to the same thunk, only one of them will evaluate it. The other thread will use the evaluated value
06:20:36 <mun_> i guess the problem is the it's semi-decidable because of formulas being not in the theory, so in that case the deductive system can still be sound and complete.
06:20:36 <Berengal> So the question is "will the function re-evaluate someval on each invocation?"
06:20:37 <maurer_> Berengal: Cool, thanks.
06:20:44 <maurer_> Berengal: Yes.
06:20:56 <maurer_> Berengal: Specifically, will the thread that hasn't evaluated it yet, evaluate it.
06:21:12 <maurer_> (I already use this tactic in single-threaded cases and it works well)
06:21:38 <mmorrow> maurer_: there's only like a one or two instruction window where it's possible for two threads to both evaluate the same thunk
06:21:38 <Berengal> Threads have nothing to do with it. If it works for one thread, it works for more
06:22:04 <Berengal> But note that a thread may block waiting for another thread to evaluate a value it needs
06:22:32 <Berengal> In that case, however, it'll wait and the OS thread running it will start running another thread. At least I think it does
06:22:42 <maurer_> OK, cool. I know very little of the threading model in haskell beyond "use parMap on big jobs, then add -Ncores"
06:23:17 <maurer_> But it sounds like it works the way one would want it to.
06:23:36 <Berengal> Indeed it does.
06:23:44 <mmorrow> maurer_: this is good http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/multicore-ghc.pdf
06:23:45 <lambdabot> Title: Runtime Support for Multicore Haskell, http://tinyurl.com/rebvkg
06:23:46 <sohum> is there a Recursable typeclass?
06:23:50 <sohum> like, class Recursable r e where recurse :: (r -> r) -> e -> e
06:23:54 <sohum> and stuff like data Tree a = Leaf a | Node (Tree a) (Tree a); instance Recursable Tree Tree where recurse r (Node n1 n2) = Node (r n1) (r n2); recurse _ x = x
06:24:12 <mmorrow> Functor?
06:25:11 <Axman6> it's close, but not wuite
06:25:12 <Axman6> q*
06:25:14 <mmorrow> instance Functor Tree where fmap f (Leaf a) = Leaf (f a); fmap f (Node l r) = Node (fmap f l) (fmap f r)
06:25:48 <mmorrow> what would some instances of your Recurse look like?
06:26:41 <sohum> mmorrow: basically, it define a way of recursing down data structures
06:27:02 <Berengal> Functor does that
06:27:05 <mmorrow> instance Functor Tree where recurse f t@(Leaf _) = f t; fmap f (Node l r) = Node (f l) (f r)
06:27:07 <mmorrow> or
06:27:18 <mmorrow> instance Functor Tree where recurse f t@(Leaf _) = f t; fmap f (Node l r) = f (Node (f l) (f r))
06:27:20 <mmorrow> or .. ?
06:27:33 <sohum> mmorrow: yea, I see that now. the differences between what I did and Functor are close to trivial
06:27:37 <sohum> mmorrow: cool!
06:27:57 <mmorrow> sohum: :) (although there could be some other pattern that you're looking for maybe)
06:28:30 <mmorrow> e.g. you can't have fmap :: (Tree a -> Tree b) -> (Tree a -> Tree b)
06:28:37 <FunctorSalad_> there is gmapT for only mapping the immediate kids
06:29:13 <mmorrow> yeah, and there're multiple traversal strategies, etc
06:30:04 <mmorrow> bottom-up, top-down, top-down-then-bottom-up, bottom-up-then-top-down, etc
06:30:31 <sohum> mmorrow: are these strategies different functions on Functor?
06:31:04 <mmorrow> Functor doesn't propogate any information along the structure, it just maps the elements the structure holds
06:31:36 <mmorrow> like, the difference between `map' and `scan{l,r}'
06:31:49 <mmorrow> or mapAccum{L,R}
06:31:53 <sohum> mmorrow: right
06:32:07 <Phyx-> hmmm is it possible to create an instance of say... Storable from an abstract type?
06:32:17 <Berengal> The contract for fmap is that the structure should be identical before and after, which means any function which doesn't look at the elements should return the same result
06:32:20 <mmorrow> Phyx-: sure
06:32:39 <Cale> Phyx-: yes, if the information available from the interface is enough to completely determine the value.
06:32:40 <mmorrow> Phyx-: as long as you can pull out the info you need from it, then build one from the info you store
06:33:42 <Phyx-> ah right. ofcourse.  Lemme go see if i have enough information. thanks
06:33:51 * Phyx- had pattern matching on the brain
06:34:09 <sohum> Berengal: ..wait, what? so I shouldn't, say, replace a Leaf with a Node of two Leafs when using fmap?
06:34:59 <|Steve|> That wouldn't seem to be what fmap would do.
06:35:22 <Cale> sohum: note that fmap id = id
06:35:34 <Cale> sohum: is a law that fmap is supposed to satisfy
06:35:58 <sohum> Cale: aaaah, right, I get it
06:36:28 <sohum> sorry, brainbarf
06:37:03 <mmorrow> , [$bf|.+[.+]|] ""
06:37:06 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
06:37:40 <nightchill> hi
06:37:43 <mauke> , [$bf|++++++++++[.]|] ""
06:37:44 <lunabot>  "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n...
06:38:11 <mmorrow> wtf is '\v'
06:38:12 <mmorrow> ?
06:38:21 <ivanm> mmorrow: vertical tab IIRC
06:38:25 <mmorrow> ahh, right
06:38:28 <nightchill> i'm trying a tutorial on http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot, and basically i get stuck at first example... i get the error Not in scope: data constructor `Portnumber'
06:38:29 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
06:38:33 <nightchill> any ideas what i'm missing?
06:38:40 <mauke> you'll be pleased to know that perl doesn't support \v :-)
06:38:40 <ivanm> (though I've never understood what a vertical tab was meant to be...)
06:39:04 <|Steve|> The same thing a horizontal tab means.
06:39:04 <mauke> nightchill: it's PortNumber
06:39:06 <Lemmih>  nightchill Haskell is case sensitive.
06:39:22 <nightchill> oh i see
06:39:24 <nightchill> thanks
06:39:34 <|Steve|> But, you know, vertically.
06:39:36 <ivanm> |Steve|: how does a vertical tab work?  does it imply a newline as well?
06:39:43 <ivanm> make that line taller?
06:39:51 <__JN> Is there any standard function like elem, but instead of returning true/false, that returns the index of the first occurrence of a specific value in a list?
06:40:06 <nomeata> @hoolge index
06:40:06 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
06:40:06 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
06:40:06 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
06:40:18 <|Steve|> ivanm: It implies moving vertically down to the next vertical tab stop, whatever distance that is away.
06:40:22 <mauke> @hoogle a -> [a] -> Int
06:40:22 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
06:40:22 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
06:40:22 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
06:40:38 <__JN> aha, thank you!
06:40:51 <ivanm> |Steve|: yes, but if I put that into a document, it doesn't seem to do anything...
06:41:54 <|Steve|> ivanm: Whether your editor does anything with it or not is another matter. It was invented in the days of mechanical tab stops.
06:42:01 <nightchill> well i don't get the output
06:42:07 <nightchill>    "NOTICE AUTH :*** Looking up your hostname...\r\nNOTICE AUTH :***
06:42:07 <nightchill>    Checking ident\r\nNOTICE AUTH :*** Found your hostname\r\n ...
06:42:12 <nightchill> just blank line...
06:43:41 <|Steve|> @hoogle (m a -> Maybe (m a)) -> m a -> Maybe (m a)
06:43:42 <lambdabot> Data.Generics.Aliases ext1M :: (Monad m, Data d, Typeable1 t) => (e -> m e) -> (t f -> m (t f)) -> d -> m d
06:43:42 <ivanm> |Steve|: ahhh
06:44:02 <ivanm> so it would implicitly do a newline and let you keep on going from the next column on or something?
06:44:37 <|Steve|> That's what a newline would do without a carriage return (think typewriter here).
06:44:58 <|Steve|> The vertical tab would advance the page to the next stop, presumably without returning the carriage.
06:45:08 <|Steve|> It's not like I've ever used a device that supported vertical tabs!
06:45:19 <ivanm> well, how was I supposed to know that? :p
06:45:23 <aavogt> @type id :: (m a -> Maybe (m a)) -> m a -> Maybe (m a)
06:45:24 <lambdabot> forall (m :: * -> *) a. (m a -> Maybe (m a)) -> m a -> Maybe (m a)
06:48:03 <|Steve|> I was thinking more like you could modify the tree. The first argument returns Nothing to remove the node or returns Just (...) to return a subtree.
06:50:03 <ChilliX> Axman6: hey - what's up?
06:50:26 <Axman6> i was wondering if SAPLING required any registration/money?
06:50:43 <ChilliX> there is no registration fee
06:50:59 <Axman6> i talked it over with my girlfriend today, and she said she'd be happy to come up (and pay for most of the trip too... damn employed people)
06:51:04 <ChilliX> the origanisation institution (Uni of Sydney) covers for the rooms and tea/coffee break
06:51:18 <ChilliX> *organising
06:51:24 <Axman6> so, just rock up at the door on the day?
06:51:31 <ChilliX> (nice of your g/f :)
06:51:42 <Axman6> yes, she's wonderful :)
06:51:58 <ChilliX> they may call for a registration just to get an idea of the numbers of people attending
06:52:27 <Axman6> ok. should i sign up for the mailing list then?
06:52:31 <ChilliX> although, I think, we didn't do that in tghe past
06:52:54 <ivanm> what's SAPLING?
06:52:57 <ChilliX> signing up for the ml is surely a good idea, just to make sure you get any additional late info about th event
06:53:10 <Axman6> ok, done and done
06:53:16 <Axman6> ChilliX: you know of Clem's going?
06:53:17 <danr> @pl \f x y z -> f y z x
06:53:17 <lambdabot> flip . (flip .)
06:53:25 <ChilliX> http://plrg.science.mq.edu.au/projects/show/sapling
06:53:29 <lambdabot> Title: SAPLING - Overview - Macquarie University Programming Languages Research Group
06:53:41 <ivanm> gah, wikipedia failed me :@
06:53:55 <danr> @pl \x y z -> y z x
06:53:55 <lambdabot> flip flip
06:53:59 <ivanm> ahhh, thought it was a conference of some kind...
06:54:11 <Axman6> it is
06:54:12 <ChilliX> Axman6: re clem, his PhD student (ben) is coming and he usually comes, too
06:54:31 <ChilliX> ivanm: it is, just a bad page title
06:54:31 <Axman6> yeah, i noticed Ben was coming. he'll be lecturing me in a few weeks
06:54:43 <ivanm> ChilliX: heh
06:54:59 <ChilliX> Axman6: ic, he mentioned that he is going to run a class soon when we talked at icfp
06:55:08 <ivanm> Axman6: "There is no
06:55:09 <ivanm> registration fee to attend this meeting. Participants will be responsible for their own lunch costs."
06:55:11 <ivanm> ;-)
06:55:34 <hackagebot> GLUT 2.2.2.0 - A binding for the OpenGL Utility Toolkit (SvenPanne)
06:57:22 <ivanm> hmm... the talk by Barry Jay and Thomas Given-Wilson sounds mildly interesting...
06:58:21 * Axman6 thinks ChilliX's talk sounds fascinating
06:58:48 <ivanm> oh, combinatory logic rather than combinatorics :(
06:59:08 <ivanm> since I don't know ChilliX's real name, I can't tell how interesting his talk sounds ;-)
06:59:15 <Axman6> the first one ;)
06:59:29 <ivanm> ChilliX == Chakravarty?
06:59:55 <ivanm> yeah, accelerated arrays sounds cool...
07:00:03 <ivanm> but I'm more of an FP user than an FP theoretician ;-)
07:00:49 <ChilliX> Axman6: it's about our new EDSL for processing regular, multi-dimensional arrays that can be off-loaded to GPUs etc
07:01:24 <ChilliX> ivanm: this is very practical stuff (although it uses quite some type-level magic under the hood)
07:01:45 <Axman6> ChilliX: can't wait for an OpenCL backend for it all, since then it will be portable
07:02:09 <ChilliX> at least accelerate.cabal has this entry
07:02:10 <ChilliX> Extensions:             FlexibleContexts, FlexibleInstances,
07:02:11 <ChilliX>                         ExistentialQuantification, GADTs, TypeFamilies,
07:02:11 <ChilliX>                         ScopedTypeVariables, DeriveDataTypeable,
07:02:11 <ChilliX>                         BangPatterns, PatternGuards, TypeOperators, RankNTypes
07:02:11 <ChilliX> (
07:02:32 <Axman6> heh
07:02:33 <ivanm> heh, yeah, you seem to use a few extensions there... ;-)
07:02:46 <ChilliX> There should be a LANGUAGE TortureTheTypeChecker instead of having to enumerate all the extensions
07:03:04 <Axman6> sounds like a good regression test for GHC
07:03:16 <ivanm> ChilliX: -fglasgowexts ? :p
07:08:53 <kakeman> what is :: ?
07:09:18 <ivanm> it reads as "has type"
07:09:20 <basti_> "a::B" means "a is of type B"
07:09:39 <dcoutts_> it separates the hard working values from the slakker types
07:09:45 <ivanm> dcoutts_: :o
07:09:56 <ivanm> you can't spell slacker! :p
07:10:07 <FunctorSalad_> http://strictlypositive.org/winging-jpgs/
07:10:09 <lambdabot> Title: Winging It
07:10:25 <kakeman> ok. example: main :: IO () ?
07:10:34 <ivanm> kakeman: main is of type IO ()
07:11:24 <kakeman> aa
07:12:03 <kakeman> string in, string out?
07:12:50 <ivanm> no String
07:13:15 <ivanm> this means String in and String out: String -> String
07:16:57 <nainaide> Did any  one try mod_haskell ?
07:17:13 <skorpan> no, but i'm seriously considering it
07:18:04 <teddy_> hi is there something i need to include in my code to use the round function? I have a function using round that works in ghci but wont compile in ghc
07:18:16 <Axman6> @index round
07:18:17 <lambdabot> Prelude
07:18:19 <Axman6> nope
07:18:31 <teddy_> hmm
07:18:49 <teddy_> guessbetween :: Int -> Int -> Int
07:18:49 <teddy_> guessbetween min max = round(min + max / 2)
07:18:59 <ivanm> teddy_: are you building your app properly?
07:19:17 <teddy_> but i guess i wasnt defining my type in ghci
07:19:22 <teddy_> and i was in the code
07:19:57 <teddy_> yep thats it
07:20:42 <hackagebot> GLURaw 1.1.0.0 - A raw binding for the OpenGL graphics system (SvenPanne)
07:20:56 <teddy_> im new to haskell... guess i should have checked the type of round :)
07:21:26 <BleSS> I've seen that has been built many cool DBMS in erlang as couchdb. scalaris, dynomite, ... does hashell would not be a great language too for it?
07:26:43 <aavogt> > round (0 10 / 2) -- teddy_
07:26:44 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
07:26:44 <lambdabot>    arising from the literal `0' at <...
07:26:51 <aavogt> > round (0 + 10 / 2)
07:26:52 <lambdabot>   5
07:27:07 <aavogt> > round (5 + 10 / 2)
07:27:08 <lambdabot>   10
07:27:24 <aavogt> > round ((5 + 10) / 2)
07:27:24 <lambdabot>   8
07:28:03 <teddy_> cool you can do haskel code here? :D
07:28:07 <teddy_> haskell*
07:28:21 <aavogt> yep
07:28:29 <FunctorSalad_> @bot
07:28:29 <lambdabot> :)
07:28:29 <lunabot>  :o
07:29:35 <teddy_> well see my problem was round gos to an Integral and my function wanted an Int
07:30:02 <sohum> :t fromIntegral . round
07:30:03 <lambdabot> forall b a. (Num b, RealFrac a) => a -> b
07:30:46 <pacopil> online boxing game http://www.kobox.org/kobox-fande-Nourine.html
07:30:47 <lambdabot> Title: ..:: Boxeador Nourine ::.. || "Kobox" ||
07:32:11 <mmorrow> nainaide, skorpan: mod_haskell??
07:32:46 <hackagebot> OpenGLRaw 1.1.0.0 - A raw binding for the OpenGL graphics system (SvenPanne)
07:34:02 <danr> @bot
07:34:02 <lambdabot> :)
07:34:02 <lunabot>  :o
07:34:02 <aavogt> @google mod_haskell
07:34:04 <lambdabot> http://www.st.ewi.tudelft.nl/~dolstra/mod_haskell/
07:34:04 <lambdabot> Title: mod_haskell
07:34:11 <nainaide> mmorrow, I just think about how to do method GET and POST under apache. And found someone talking about mod_haskell
07:34:40 <nainaide> but I can not find it from my gentoo overlay.
07:34:42 <mmorrow> just found http://www.st.ewi.tudelft.nl/~dolstra/mod_haskell/
07:34:43 <lambdabot> Title: mod_haskell
07:34:54 <mmorrow> looks like the last "News" item is from 2002..
07:35:07 <mmorrow> although i'm sure it could be resurrected
07:35:45 <mmorrow> also, this came up
07:35:54 <nainaide> yeah! not update for a long time.
07:35:55 <mmorrow> gah! long google links
07:36:18 <mmorrow> darcs.haskell.org/~lemmih/modhaskell/mod_haskell.c
07:36:30 <nainaide> Btw, do you have any idea about GET in apache?
07:36:31 <mmorrow> http://darcs.haskell.org/~lemmih/modhaskell/
07:36:31 <lambdabot> Title: Index of /~lemmih/modhaskell
07:36:39 <mmorrow> nainaide: ?
07:36:54 <mmorrow> do you mean you the application getting the raw GET request?
07:36:59 <mmorrow> (not sure)
07:37:09 <nainaide> mmorrow,  yes
07:37:47 <mmorrow> maybe look into using happs, since then you are the webserver
07:37:58 <mmorrow> (happs(tack) or whatnot)
07:38:57 <nainaide> Someone want to put datas through method GET to my server
07:39:15 <mmorrow> oh, you can just use (fast)cgi for that..
07:39:36 <nainaide> yes, happs can do that.
07:40:41 <nainaide> mmorrow, yeah, that is another way. If mod_haskell lives should be better
07:42:16 <mmorrow> nainaide: i've done quite a few fastcgi apps with apache, it's pretty nice. it doesn't look like mod_haskell is an option unless you want to hack the bitrot out of it
07:42:42 <nainaide> mmorrow, great! thanks for your advice!!!
07:43:36 <nainaide> this save me much time
07:49:23 <sohum> oh, wait a second
07:49:31 <sohum> I can't make a concrete type a functor
07:49:53 <sohum> yea, ok, and I can see why
08:26:53 <BleSS> I've seen that has been built many cool DBMS in erlang as couchdb. scalaris, dynomite, ... does hashell would not be a great language too for it?
08:27:52 <jfoutz> i see how most of data.list can be implemented as a catamorphism, but what about zip?
08:29:54 <jfoutz> is there an algebraic construct that takes many arguments?
08:30:56 <Saizan> you can do zip as a fold too
08:31:42 <jfoutz> i guess you can make one list the seed
08:32:16 <Saizan> it won't be very efficient, iirc
08:32:37 <Saizan> however there's the code on oleg's site
08:33:31 <alexmac> is this a good place for a haskell noob to get some help? I've been using quickCheck for a while and everything is going ok, but now that I want my quickcheck generators to maintain some state I'm coming unstuck trying to get them to play nicely with the state monad, I have a simple example of what I'm trying to do here: http://pastebin.com/d3c07c53e any help would be much appreciated!
08:34:09 <jfoutz> Saizan: i've gone through the bananas lenses paper, it seems like there should be generalizations fomr many arguments, zip was just the most obvious example. not sure if there's some other paper or book that's a good follow up.
08:34:50 <aavogt> > let zf = \x y -> snd $ foldr (\y z -> case z of (x:xs,acc) -> (xs,(x,y):acc); ([],acc) -> ([],acc)) (x,[]) y in zf "helloO" "12345678"
08:34:50 <lambdabot>   [('O','3'),('o','4'),('l','5'),('l','6'),('e','7'),('h','8')]
08:35:20 <aavogt> wow, something
08:35:25 <aavogt> is reversed there
08:37:20 <ski> Saizan : why not efficient ?
08:37:25 <jfoutz> building the acc effectivly turns it into foldl.
08:37:56 <aavogt> > let zf = \x y -> snd $ foldl (\z y -> case z of (x:xs,acc) -> (xs,(x,y):acc); ([],acc) -> ([],acc)) (x,[]) y in zf "helloO" "12345678"
08:37:56 <lambdabot>   [('O','6'),('o','5'),('l','4'),('l','3'),('e','2'),('h','1')]
08:39:43 <ski> jfoutz : how about `zipWith3' at <http://www.mdstud.chalmers.se/~md9slj/code/FoldrZip.hs> ?
08:40:01 <ski> that's a left-to-right traversal that is incremental
08:41:06 <Orclev> so, I"m trying to do a basic animation, and I figured I'd do it with SDL, but now that I've actually looked through the SDL binding I discover SDL has no methods to actually draw anything but pixmaps
08:41:34 <Orclev> in theory I could use OpenGL to do the actual drawing, but from what I can tell the OpenGL bindings aren't available from haskell
08:41:59 <jfoutz> ski: thanks, that looks really interesting.
08:42:17 <ski> it can be thought of as two coroutines that each walk down their list one step, pass the "baton" to the next coroutine, one of them also emitting cons cells as output
08:42:39 <Orclev> anyone know a simple library for doing 2d animation in haskell?
08:42:45 <ski> instead of using `[]' and `(:)' there, i could easily be using `build' instead
08:43:45 <ski> (that way the core of it basically has type `(a -> b -> c) -> List a -> List b -> List c', where `type List a = forall o. (a -> o -> o) -> o -> o')
08:44:00 <ski> @type GHC.Base.build
08:44:00 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
08:44:18 <ski> (so `build :: List a -> [a]', using that type synonym)
08:45:16 <Makoryu> Orclev: Are you prepared to make your program dependent on GTK?
08:45:32 <jfoutz> ski: that is a really slick traversal.
08:45:41 <Orclev> Makoryu: that's fine, what I'm looking for is mostly ease of doing 2d animation
08:45:44 * ski bows
08:46:02 <Saizan> ski: that's very nice
08:46:08 <Orclev> Makoryu: it really sucks that SDL can't do simple drawing, otherwise it would be perfect
08:46:21 <nomeata> Orclev: I tend to do such stuff with cairo
08:46:46 <nomeata> Orclev: http://www.joachim-breitner.de/blog/archives/292-FrakView-An-Haskell-Renderer-for-Iterated-Function-Systems.html for example
08:46:50 <lambdabot> Title: FrakView: An Haskell Renderer for Iterated Function Systems - nomeata’s mind s ..., http://tinyurl.com/6dtoww
08:46:51 <Orclev> nomeata: I looked at cairo but I couldn't find any documentation/tutorials that seemed to help...
08:46:58 <pastah> @hoogle [Word8] -> Word32
08:46:58 <lambdabot> Data.List genericLength :: Num i => [b] -> i
08:46:58 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
08:46:58 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:46:59 <Orclev> nomeata: thanks, I'll check that out
08:47:05 <Makoryu> Orclev: Hmmm http://www.haskell.org/gtk2hs/archives/category/cairo/
08:47:06 <lambdabot> Title: Gtk2Hs » cairo
08:47:06 <Makoryu> Oh
08:47:33 <pastah> how do i do that convertion? ([Word8] -> Word32)
08:47:57 <Orclev> Makoryu: actually I looked at that already, but I wasn't sure how hard it would be to do animation using that
08:48:03 <ski> (aside, i would like to define `A' and `B' as `newtype's local to the `zipWith3' definition, to avoid repeating parameters, like `zipwith3 ... = ... where ...; newtype A = MkA {unA ::      B -> [c]}; newtype B = MkB {unB :: a -> A -> [c]}')
08:48:17 <Makoryu> Orclev: ¯\(°_o)/¯
08:48:28 <jfoutz> i took a few runs at (a -> b -> c) -> c -> f a -> g b -> h c, but got very bogged down on the accumulators. i think that make/unmake trick might be enough for me to get it.
08:48:43 <Makoryu> Orclev: I've never done this in Haskell because most of the libraries assume you have GTK working....
08:48:50 <ski> jfoutz,Saizan : i hope you see how to use this trick/idea in other cases ?
08:49:38 * jfoutz is absorbing slowly
08:49:53 <ski> jfoutz : elaborate on what you meant by `(a -> b -> c) -> c -> f a -> g b -> h c' ?
08:50:22 <pastah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9329#a9329
08:50:31 <pastah> could someone please look at that?
08:50:44 <pastah> it is in dire need of not loking ugly
08:50:53 <jfoutz> yeah, say zipwith taking a tree and a list, returning a maybe
08:50:56 <mpacula> hey everyone
08:51:06 <mpacula> are there any good plotting packages for haskell?
08:51:24 <pastah> @google haskell plot
08:51:25 <lambdabot> No Result Found.
08:51:25 <Orclev> Makoryu,nomeata: another one I looked at was chalkboard as that seemed pretty close to what I wanted, but unfortuntaly the viewer for it won't compile
08:51:29 <pastah> haha
08:51:35 <mpacula> i found Graphics.Plot from hmatrix, but it's simplistic at best
08:51:53 <jfoutz> ski: i think monoid and traversable are enough... haven't quite got it yet.
08:51:57 <ski> @type fromIntegral -- pastah
08:51:58 <lambdabot> forall a b. (Integral a, Num b) => a -> b
08:52:39 <pastah> ski: cool
08:52:41 <pastah> thanks
08:53:03 <ski> jfoutz : why a `Maybe _' ?
08:53:43 <jfoutz> sorry, not the best example, i guess it would be zipWith :: (Monoid g, Traversable f, Traversable h) => (a->b->c) -> c -> f a -> g b -> h c
08:53:46 <ski> pastah : what if the list is empty ?
08:54:02 <ski> pastah : should it return `0' ?
08:54:28 <ski> jfoutz : why does it take a `c' argument ?
08:54:34 <pastah> ski: error handling is for sissies
08:54:58 <ski> pastah : but maybe there's a sensible result to give for empty list ?
08:55:50 <ski> maybe what you're trying to do is convert a sequence of `Word8', representing "digits" of base 2^8, into a `Word32' ?
08:55:57 <Saizan> ski: so that's how zipWith is written to exploit foldr/build fusion?
08:56:28 <ski> Saizan : i assume so. i haven't tried looking at core for that
08:56:58 <jfoutz> ski: the thing i need should fully traverse both traversables. for regular old zip, that's clearly not necessary.
08:57:04 * ski invented that himself some time ago .. then didn't think much more on it
08:57:11 <pastah> ski: for this use the empty list will never be an argument
08:57:43 <ski> what is the intended semantics ?
08:58:58 <jfoutz> was that at me?
08:59:21 <Orclev> Makoryu: btw, that link you posted earlier, the example in it doesn't compile
08:59:28 <Makoryu> Orclev: Damn
09:00:20 <Orclev> Makoryu: yeah, complains about an ambiguous liftIO usage, and a type and data constructor that are out of scope
09:00:47 <ski> jfoutz : no, for pastah
09:00:56 <jfoutz> ok :)
09:01:52 <ski> > (`showHex` "") $ foldr (\d n -> d + 256*n) 0 (map (fromIntegral :: Word8 -> Word32) [128,64,32])
09:01:53 <lambdabot>   "204080"
09:02:03 <ski> pastah : ^ is that satisfactory ?
09:02:08 <pastah> ski: oh, nice :)
09:02:13 <pastah> that's pretty awesome
09:02:13 <ski> actually
09:02:40 <ski> > (`showHex` "") (foldr (\d n -> fromIntegral d + 256*n) 0 ([128,64,32] :: [Word8]) :: Word32)
09:02:41 <lambdabot>   "204080"
09:02:50 <ski> i.e.
09:03:01 <ski>   converter = foldr (\d n -> fromIntegral d + 256*n) 0
09:03:15 <gwern> c.h.o down?
09:03:19 <ski> also, note that
09:03:25 <ski> > (`showHex` "") (foldr (\d n -> fromIntegral d + 256*n) 0 ([] :: [Word8]) :: Word32)
09:03:25 <idnar> @pl (\d n -> fromIntegral d + 256*n)-
09:03:25 <lambdabot>   "0"
09:03:26 <lambdabot> (line 1, column 34):
09:03:26 <lambdabot> unexpected end of input
09:03:26 <lambdabot> expecting white space or simple term
09:03:27 <idnar> @pl (\d n -> fromIntegral d + 256*n)
09:03:27 <lambdabot> (. (256 *)) . (+) . fromIntegral
09:03:31 <idnar> eek
09:03:33 <ski> to my satisfaction :)
09:03:41 <idnar> that's almost nice, but not quite
09:04:05 <zzaz> hey i need help: what does it mean by "how many fridays are divisible by 3 or 5" : http://www.cstutoringcenter.com/problems/problems.php?id=74
09:04:06 <lambdabot> Title: The 20th Century - Problem 74, C++ programming challenge, Java programming chall ...
09:04:55 <aavogt> gwern: c.h.o is up by ssh, but http doesn't seem to work
09:05:09 <ski> jfoutz : you mean you want something that traverses two structures in parallel in some traversal order, combining the elements and reconstructing the structure of one of the inputs ?
09:05:13 <gwern> hm. that's usually the case yeah
09:06:01 <ski> jfoutz : or, hm .. the return container type can be different as well .. what does that mean ?
09:06:19 <byorgey> zzaz: that's really unclear.  Maybe it means that the date is divisible by 3 or 5 (e.g. the 15th of the month, but not the 17th) ?
09:07:07 <zzaz> maybe.. i'll try that
09:07:23 <ski> .. or the index of the say in the year, or since epoch, or ..
09:07:33 <jfoutz> ski: i have a simple problem, but i also just read the bananas lenses barbed wire paper, and so i'm generalizing in a lot of ways. just golfing i guess.
09:08:00 <ski> ok, what is the simple problem, and how are you trying to generalize ?
09:09:45 <Kagami`> Hi. Where I can find example of thread-safe usage libcurl bindings for Haskell? This code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9330#a9330 segfaults every minute when I run multiple threads...
09:10:12 <jfoutz> ski: i have two lists of strings. pad each string in the first list so the second list won't lose formatting, print everything, even if one list is shorter than the other.
09:10:54 <jfoutz> er, each string is catted to it's peer, like zipWith (++)
09:10:56 <ski> making each string in the first list the same length ?
09:11:24 <alinp> hi
09:11:28 <jsoffer> Hello, I'm translating the Haskell Cheat Sheet (http://blog.codeslower.com/2008/10/The-Haskell-Cheatsheet) to Spanish. The repository is at http://github.com/jsoffer/cheatsheet (currently around 10% translated). Comments and corrections please.
09:11:31 <alinp> why is not possible to do something like this:
09:11:32 <Lemmih> Kagami`: Shouldn't 'withCurlDo' only be called once?
09:11:40 <jfoutz> ["a","bcdef"] -> ["b"] -> ["a    b","bcdef"]
09:11:57 <alinp> let t :: (Num a, Num b) => a -> b -> a; t a b = a + b
09:11:57 <alinp> ?
09:12:09 <ski> because
09:12:12 <byorgey> alinp: because (+) expects its arguments to be the same type
09:12:12 <ski> @type (+)
09:12:13 <lambdabot> forall a. (Num a) => a -> a -> a
09:12:31 <alinp> byorgey: well, the arguments are the same type
09:12:32 <alinp> Num
09:12:34 <Kagami`> Lemmih: hmm, only in Main module? thanks, I'll try it
09:12:37 <byorgey> alinp: no, Num is a type class
09:12:38 <ski> `Num' is not a type
09:12:51 <ski> `a' and `b' there are type( variable)s
09:12:56 <alinp> hmmm
09:13:08 <byorgey> alinp: Int, Integer, Double, Rational are all different types which are instances of the Num type class
09:13:08 <ski> `Num a' says that `a' is a type supporting numeric operations in some way
09:13:21 <alinp> oh
09:13:23 <alinp> ok
09:13:26 <alinp> thanks
09:13:48 <Orclev> nomeata: hey, that pausingForM_, if I'm reading that right, it runs an action over a list if inputs till it reaches a certain number of interations or it runs out of elements... and if it reaches the specified number of iterations it pauses for... some unspecified amount of time
09:14:32 <zzaz> byorgey: yup it meant the date is divisible by 3 or 5
09:15:02 <nomeata> Orclev: well, it does not pause, but it returns control back to the application (e.g. to handle user interaction) and which can re-start it again.
09:15:42 <Orclev> nomeata: ok, so it functions a bit like setting a timer interupt before starting a loop
09:16:35 <nomeata> Orclev: similar, yes.
09:24:01 <Orclev> hmm, is there a haskell glade builder?
09:27:30 <aavogt> Orclev: you can use the regular glade designer program
09:30:51 <Orclev> nomeata: which package is eventButton in?
09:32:36 * benmachine wishes he could declare infix operators with a higher precedence than function application
09:33:10 <benmachine> actually is that what I want I'm not sure
09:33:10 <nomeata> Orclev: Graphics.UI.Gtk.Gdk.Events. It used to be exported with Graphics.UI.Gtk, I think.
09:33:14 <benmachine> probably not
09:33:35 <Orclev> nomeata: ok, so odds are this thing will start compiling if I import that... going to go try it now
09:33:38 <benmachine> I tried to define fmt %% arg = printf fmt arg but it didn't work with more than one argument
09:34:00 <nomeata> Orclev: I’ll be away in a moment, but I hope the rest of #haskell can help you :-)
09:34:03 <Kagami`> Lemmih: no, the same. I tested it on this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9331#a9331
09:34:13 <amitprakash> umm in hugs.ghc how do i define data x= string [(int,int)]
09:34:27 <copumpkin> o.O
09:34:30 <copumpkin> hugs.ghc?
09:34:34 <amitprakash> hugs/ghc*
09:34:41 <copumpkin> you can't do it in ghci
09:34:42 <byorgey> benmachine: it should work, but you would need parentheses
09:34:51 <copumpkin> not sure about hugs but nobody uses it
09:34:52 <byorgey> like  (fmt %% arg1) arg2 arg3 ...
09:35:06 <benmachine> byorgey: yeah I suppose so, but that'd be a bit ugly
09:35:06 <amitprakash> copumpkin, cant i define it in a file and load it using ghc?
09:35:13 <benmachine> think I'll just stick to normal printf
09:35:13 <copumpkin> amitprakash: yep
09:35:16 <byorgey> benmachine: so, right, if an infix operator could have higher precedence than application, I think that would do what you want
09:35:21 <Orclev> ok, everything but TMstring is working now... which package is TMstring a member of?... I tried using hoogle but that got me no results
09:35:44 <amitprakash> copumpkin, umm i've forgotten how though :) could you please tell me what i should be writing instead
09:35:53 <jmcarthur> @where she
09:35:54 <lambdabot> I know nothing about she.
09:36:14 <jmcarthur> she is a horrible name for google
09:36:18 <Axman6> @quote Axman6
09:36:18 <lambdabot> Axman6 says: -ddump-occur-anal <- another terrible name...
09:36:43 <Axman6> hmm, so this \bot has the old quotes. excellent
09:36:52 <byorgey> jmcarthur: http://personal.cis.strath.ac.uk/~conor/pub/she/
09:36:53 <Orclev> hmm... google FTW... TMstring is part of TreeViw.ListStore
09:36:53 <lambdabot> Title: The Strathclyde Haskell Enhancement
09:37:19 <jmcarthur> byorgey: thanks
09:37:36 <conal> @where+ she http://personal.cis.strath.ac.uk/~conor/pub/she/
09:37:36 <lambdabot> Good to know.
09:37:40 <jmcarthur> byorgey: i found that if i add some of the features of she to the google search like idiom brackets i can find it
09:44:36 <Kagami`> Can someone test this code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9331#a9331 Maybe it segfaults because of wrong usage MVars?
09:46:27 <bos> @where+ she http://personal.cis.strath.ac.uk/~conor/pub/she/
09:46:27 <lambdabot> Nice!
09:48:00 <ski> (bos : conal already told her ..)
09:48:54 <bos> ah
09:49:44 <byorgey> need someone such as gwern to do a @flush
09:50:32 <benmachine> Kagami`: doesn't segfault for me
09:54:00 <Kagami`> benmachine: hmm. i have crash per minute in average.
09:54:49 <benmachine> Kagami`: I wouldn't call myself an expert but I don't see anything in your code that could cause a segfault
09:55:12 <benmachine> so the most likely candidate for blame is
09:55:15 <benmachine> at a guessm your libcurl
09:56:42 <benmachine> Kagami`: how are you running it, just in case it makes a difference?
09:56:50 <PeakerWork> Kagami`: can you repaste?
09:57:05 <benmachine> compiled/runhaskell/ghci, if compiled then with what options
09:57:09 <Kagami`> PeakerWork: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9331#a9331
09:57:18 <Kagami`> benmachine: runghc file.hs
09:57:42 <jmcarthur> so i have a set of functions that i'm not sure what to name... foo :: (b -> c) -> (a -> b) -> (a -> c) ; bar :: ((a -> c) -> (d -> e)) -> (a -> b -> c) -> (d -> b -> e) ; baz :: ((a -> b -> d) -> (e -> f -> g)) -> (a -> b -> c -> d) -> (e -> f -> c -> g)
09:57:43 <Kagami`> (ghc 6.10.4-1)
09:57:44 <benmachine> ah there we go
09:57:53 <benmachine> *** glibc detected *** /usr/lib/ghc-6.10.4/ghc: free(): invalid pointer: 0xb7eff1b0 ***
09:57:55 <jmcarthur> foo is obviously the same as (.)
09:58:26 <jmcarthur> but generally, each of them applies one function to another, ignoring one of the arguments of the argument function.... in a sense
09:58:46 <jmcarthur> i think the type for bar makes it the most clear
09:58:58 <jmcarthur> and baz makes sense once you get it
09:59:07 <benmachine> Kagami`: sounds like a problem either in libcurl or the curl binding
09:59:14 <benmachine> but
09:59:18 <benmachine> it might be something else entirely
09:59:24 <jmcarthur> right now i just have ignore1, ignore2, ignore3, etc., but those don't seem very descriptive
09:59:27 * benmachine tries not to sound too authoritative
10:01:14 <jmcarthur> gah i have horrible timing. i have to go :(
10:06:55 <PeakerWork> Kagami`: it doesn't segfault here
10:07:07 <benmachine> PeakerWork: I had to leave it running for a while
10:07:10 <benmachine> and then it did
10:07:20 <benmachine> seemingly at random
10:07:59 <PeakerWork> benmachine: can you get a gdb backtrace on the segfault?
10:08:36 <Kagami`> it crashes rarely, then it runned via `ghc --make file.hs && ./file'
10:08:44 <benmachine> PeakerWork: for me it wasn't a segfualt actually
10:09:44 <Kagami`> PeakerWork: this is strace output: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9332#a9332
10:09:54 <benmachine> PeakerWork: this is what I got http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9333#a9333
10:10:51 <PeakerWork> Kagami`: doesn't seem very useful
10:11:29 <wmealing> can someone tell me why i see the putStrln output all at once ( http://pastebin.com/m749d6624 )
10:11:34 <benmachine> kind of odd that it got SIGCHLD but had no children to wait for
10:11:37 <PeakerWork> which libcurl do you have installed? I have the GNU TLS one
10:11:54 <wmealing> i assumed that the io monad made the statements sequenced ?
10:12:07 <benmachine> wmealing: terminal buffering
10:12:31 <wmealing> benmachine:  oh thats fail.. how do I work around it ?
10:12:35 <benmachine> wmealing: usually your terminal will store output until a newline, then output it all at once
10:12:38 <benmachine> there are two ways
10:12:42 <PeakerWork> still doesn't crash here
10:13:21 <Kagami`> PeakerWork: try run via `runghc file.hs'
10:13:25 <benmachine> you can either disable terminal buffering with hSetBuffering stdout NoBuffering (relevant definitions in System.IO) or you can hFlush stdout after each print
10:13:49 <benmachine> the former will result in slightly slower code I guess but probably not sufficient that you'd notice
10:14:19 * wmealing nods
10:15:06 <Kagami`> PeakerWork: I have libcurl 7.9.6
10:15:34 <benmachine> 7.19.6 here
10:15:51 <nominolo> @hoogle (a -> m a) -> (Maybe a -> m (Maybe a))
10:15:51 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:15:52 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
10:15:52 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
10:16:59 <PeakerWork> 7.18.2 here
10:17:11 <PeakerWork> ii  libcurl3-gnutls   7.18.2-8ubuntu4.1 Multi-protocol file transfer library (GnuTLS)
10:18:01 <benmachine> where'd you get that from?
10:19:26 <PeakerWork> benmachine: apt-get
10:19:52 <benmachine> oh
10:19:56 <amitprakash> copumpkin, umm i've forgotten how though :) could you please tell me what i should be writing instead
10:20:22 <Berengal> Ugh... missing instances are painful
10:20:35 <benmachine> my package is just called curl
10:20:52 <Berengal> I'm playing around with macid and ixsets, and UTCTime seems to lack Data instances...
10:21:02 <wmealing> benmachine: thankyou, that works a treat.
10:21:18 <Berengal> And I can't define it either, because DiffTime is hidden :/
10:21:19 <benmachine> :)
10:21:48 <PeakerWork> Kagami`: doesn't happen here
10:21:54 <PeakerWork> Kagami`: with runghc too
10:22:24 <PeakerWork> nominolo: what do you need that for?
10:22:37 <Kagami`> PeakerWork: and haskell bindings is 1.3.5 version?
10:22:49 <benmachine> :t liftM
10:22:50 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:22:54 <PeakerWork> Kagami`: yes
10:23:09 <Kagami`> PeakerWork: ok, i will try another version of libcurl, thanx
10:23:35 <benmachine> :t liftM :: (a -> m a) -> (Maybe a -> m (Maybe a))
10:23:36 <lambdabot>     Couldn't match expected type `m' against inferred type `Maybe'
10:23:36 <lambdabot>       `m' is a rigid type variable bound by
10:23:36 <lambdabot>           an expression type signature at <interactive>:1:15
10:23:39 <nominolo> PeakerWork: I'm serialising a Trie where serialising a value returns a value.  A Trie value is only optionally present, hence the Maybe
10:23:43 <benmachine> oh drat
10:23:56 <PeakerWork> @type \f m -> sequenceA (fmap f m)
10:23:56 <lambdabot> Not in scope: `sequenceA'
10:24:05 <PeakerWork> @hoogle sequenceA
10:24:05 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:24:06 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
10:24:09 <benmachine> oh that gets me Maybe (m a)
10:24:15 <PeakerWork> @type \f m -> Data.Traversable.sequenceA (fmap f m)
10:24:15 <lambdabot> forall a (f :: * -> *) a1 (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f a1) -> t a -> f (t a1)
10:24:27 <PeakerWork> nominolo: this should work?
10:25:28 <Kagami`> Berengal: http://happstack.com/docs/0.2/happstack/0.2/Happstack-State-ClockTime.html ?
10:25:29 <lambdabot> Title: Happstack.State.ClockTime, http://tinyurl.com/mpn3vb
10:25:32 <benmachine> :t traverse
10:25:33 <lambdabot> Not in scope: `traverse'
10:25:38 <_Ray_> Hey, small question. I'm reading a tutorial, and one of the things it mentions is how floats are "funky", and gives this example: [0.1, 0.3 .. 1]  gives [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]. Why is it that the last number in the resulting sequence is larger than the limiting number in the expression (1)?
10:25:41 <benmachine> :t Data.Traversable.traverse
10:25:42 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:25:54 <nominolo> PeakerWork: yeah, I'm not sure what exactly I need yet.  I'll find out soon
10:26:09 <Baughn> > [1,3..10]
10:26:10 <lambdabot>   [1,3,5,7,9]
10:26:13 <byorgey> _Ray_: because of the way the Enum instance for Doubles is implemented.
10:26:15 <Berengal> Kagami`, that's System.Time, not Data.Time, but at least it's something useful. Thanks
10:26:17 <PeakerWork> @type \f m -> Data.Traversable.sequenceA (liftM f m) :: Monad m => (a -> m a) -> (Maybe a -> m (Maybe a))
10:26:18 <lambdabot>     Inferred type is less polymorphic than expected
10:26:18 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
10:26:18 <lambdabot>         m :: Maybe a -> a1 (bound at <interactive>:1:3)
10:26:19 <Baughn> > [0.1,0.3..1]
10:26:20 <bastl> hi all
10:26:20 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
10:26:31 <byorgey> _Ray_: the specification says that it should keep going as long as it is within 1/2 of the step size of the upper limit.
10:26:43 <lispy> I wish someone would take gitit and build a bug tracker (something with really nice searching and cool features) on top of it.
10:26:44 <benmachine> the lesson is that the Enum instance for Double is weird
10:26:45 <ski> @djinn ((x0 -> x1) -> (y0 -> y1)) -> (((a0 -> x0) -> (a1 -> x1)) -> ((a0 -> y0) -> (a1 -> y1)))
10:26:45 <lambdabot> -- f cannot be realized.
10:26:46 <_Ray_> Ah
10:26:57 <benmachine> byorgey: any idea why?
10:27:00 <_Ray_> Thanks :)
10:27:03 <lispy> (I don't want a wiki to trac bugs, but I can see the distributed nature of gitit being really nice for a BTS)
10:27:25 <PeakerWork> nominolo: I suppose in the Nothing case, you want a (return Nothing) there
10:27:44 <bastl> where will extra source files appear that i specified in my cabal file, after the package is installed?
10:27:45 <byorgey> benmachine: yes, because otherwise you can get weird behavior where because of rounding, you do something like [0.0, 0.1 .. 1.0] and have it stop at 0.9 (because adding 0.1 to 0.0 ten times gives you something SLIGHTLY larger than 1.0, say)
10:27:56 <bastl> I have extra configuration in a file, i want to load at runtime.
10:27:59 <byorgey> but really you should just NEVER EVER use the Enum instance of Double.
10:28:10 <benmachine> mm
10:28:19 <benmachine> sounds reasonable to me
10:28:26 <PeakerWork> @hoogle Maybe (m a) -> m (Maybe a)
10:28:26 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:28:27 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:28:27 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
10:28:29 <benmachine> the latter, I mean
10:29:03 <PeakerWork> > sequenceA Nothing :: Maybe [a]
10:29:04 <lambdabot>   Not in scope: `sequenceA'
10:29:09 <PeakerWork> > Data.Traversable.sequenceA Nothing :: Maybe [a]
10:29:09 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a]'
10:29:14 <PeakerWork> > Data.Traversable.sequenceA Nothing :: [Maybe a]
10:29:15 <lambdabot>   [Nothing]
10:29:22 <PeakerWork> > Data.Traversable.sequenceA [] :: Maybe [a]
10:29:23 <nominolo> PeakerWork: ah, turns out I can't reuse the existing Binary instance for Maybe anyway
10:29:23 <lambdabot>   Just []
10:29:43 <PeakerWork> nominolo: why not?
10:29:53 <nominolo> Because it can't return a value
10:30:13 <PeakerWork> nominolo: the binary instance?
10:30:21 <nominolo> put :: a -> Put
10:30:26 <nominolo> where Put is PutM ()
10:31:19 <nominolo> anyway, I have a way to work around that
10:34:33 <PeakerWork> PutM is silly, IMO
10:35:06 <PeakerWork> nominolo: so you can't use the binary instance in general, not just Maybe's?
10:35:14 <nominolo> yeah
10:35:20 <nominolo> I need a State monad
10:35:37 <nominolo> I'm building a dictionary as a side effect of serialising values
10:42:14 <Saizan> nominolo: serializing existentials?
10:42:28 <nominolo> no.  Maps
10:42:39 <nominolo> or rather lots of Strings
10:42:46 <nominolo> but many of them are the same
10:42:57 <Saizan> ah, i see
10:43:16 <Axman6> nominolo: you might like to take a look at my TernaryTrees package. it's got a rather efficient Binary instance for TernaryMaps
10:43:18 <Saizan> i thought there was something like that on hackage already
10:43:43 <nominolo> Axman6: well, my special stuff works on the keys.  Does your package support this?
10:43:58 <Axman6> what sort of special stuff?
10:44:08 <ski> conal : SYN
10:44:13 <nominolo> Axman6: well, my *keys* are strings
10:44:18 <nominolo> er, sorry
10:44:21 <nominolo> *values*
10:44:32 <Axman6> ah, not so much :)
10:44:34 <nominolo> I use Tries already, so that's efficient
10:46:40 <dsouza> I was reading about Functors ... and then I spot an instance declaration as follows: instance Functor ((->) r) where fmap = (.)
10:46:58 <dsouza> quite shocking .. I didn't know (->) was a value constructor (is it the right term?)
10:47:04 <dsouza> but then:
10:47:07 <dsouza> @kind (->)
10:47:08 <lambdabot> ?? -> ? -> *
10:47:11 <Saizan> it's a type constructor
10:47:15 <dsouza> what does the ?? and ? means?
10:47:23 <nominolo> dsouza: yeah, that's something GHC specific
10:47:34 <byorgey> dsouza: it's a type constructor, usually written infix, like   a -> b
10:47:41 <nominolo> It tells GHC something about which parts can be boxed
10:47:48 <byorgey> so ((->) r) a  === r -> a
10:48:08 <byorgey> dsouza: you can/should just think of ?? and ?  as both being *
10:48:35 <bastl> are the "data2tree" and "tree2data" from the SYB Papers available in some library ?
10:49:27 <dsouza> ok, thx. I
10:49:32 <Saizan> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes <- more details here, if you want :)
10:49:33 <lambdabot> Title: IntermediateTypes - GHC - Trac
10:49:42 <dreixel> bastl: maybe it's here somewhere? http://www.cs.vu.nl/boilerplate/
10:49:44 <lambdabot> Title: Scrap your boilerplate ... in Haskell
10:50:26 <bastl> i have the code, i just ask myself, if i should import some existing module instead ...
10:50:31 <dsouza> ok, I'll read them as * for now. but is this ghc specific?
10:50:39 <ski> yes
10:50:57 <dreixel> it's not on Data.Data or Data.Generics, for sure.
10:51:25 <ski> @type GT :: Ordering
10:51:26 <lambdabot> Ordering
10:51:27 <ski> @kind Int :: *
10:51:28 <lambdabot> parse error on input `::'
10:51:31 <ski> :/
10:51:46 <bastl> ok, so ill copy and paste ...
10:53:10 <aavogt> why isn't GenParser an instances of MonadPlus or Alternative?
10:56:26 <benmachine> :t lookup
10:56:27 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:56:31 <benmachine> :t Map.lookup
10:56:32 <lambdabot> Couldn't find qualified module.
10:56:35 <benmachine> aw
10:56:56 <Axman6> :t M.lookup
10:56:57 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
10:57:00 <benmachine> ah
10:57:20 <nominolo> ah, crap.
10:57:21 <benmachine> :t \f k -> M.lookup k . M.map f
10:57:22 <lambdabot> forall k a a1. (Ord k) => (a1 -> a) -> k -> M.Map k a1 -> Maybe a
10:57:24 <byorgey> aavogt: good question.
10:57:30 <nominolo> I really need GHC's Binary stuff
10:57:47 <benmachine> ^ are Maps lazy enough for that to be efficient?
10:57:52 <nominolo> Normal Binary can't even do peek and poke
10:58:04 <Gandalf> Hello to all...
10:58:04 <benmachine> wai
10:58:09 <benmachine> wait, that doesn't make sense
10:58:15 * benmachine needs to map over keys
10:58:17 <benmachine> hi Gandalf
10:58:24 <aavogt> byorgey: any idea how to write 'empty'?
10:58:27 <benmachine> oh, that'll be mapKeys
10:58:46 <Gandalf> I want to ask a question about access + vba + sql server 2000
10:58:53 <benmachine> :t \f k -> M.lookup k . M.mapKeys f -- will this do the map lazily?
10:58:54 <lambdabot> forall k a k1. (Ord k) => (k1 -> k) -> k -> M.Map k1 a -> Maybe a
10:59:01 <benmachine> Gandalf: where does haskell come in?
10:59:07 <Axman6> Gandalf: this is a channel about Haskell
10:59:15 <dsouza> Gandalf: /join #m$
10:59:32 <Gandalf> :) oups guys i am sorry
10:59:46 <Axman6> Gandalf: how did you end up here btw?
11:00:24 <byorgey> aavogt: well, 'empty' should be the parser that fails while consuming no input
11:00:38 <byorgey> aavogt: I don't remember off the top of my head how to write that
11:01:16 <aavogt> byorgey: perhaps fail?
11:02:41 <Berengal> Things are starting to make more sense now. This is good.
11:03:55 <ski> aavogt : `pzero' ?
11:04:07 <Baughn> PeakerWork: I've been thinking about FRP..
11:04:46 <Baughn> PeakerWork: It still seems inefficient to me. However, it now seems to me that the reason for this is that it simplifies and thus encourages some extremely high-level constructions that are very inconvenient to use otherwise - observers, etc.
11:04:51 <aavogt> ski: thanks!
11:05:12 <Baughn> PeakerWork: ..I'm not sure if this is a good thing or not
11:05:54 <PeakerWork> Baughn: I am pretty sure its a good idea. I think it should always be optimizable down to the low-level code we have today.  Observer pattern can be inlined when the callbacks are known statically, and from there, you have a normal non-FRP program
11:06:04 * ski wonder's whether `(<|>)' is associative
11:06:07 <PeakerWork> but of course what I say is in theory :)
11:06:34 <Baughn> PeakerWork: Yeah. Getting this working /at all/ is hard; optimizing it to that degree is probably worth a PhD.
11:06:44 <PeakerWork> ski: Ideally, the answer would be the [in]existence of mappend=(<|>)  (As mempty is probably easy)
11:08:27 <ski> PeakerWork : sorry ?
11:09:03 <PeakerWork> ski: the existence of mappend suggests its associative. The lack of it suggests it isn't. But that's only assuming everyone creates all possible instances :)
11:10:02 <ski> the lack of it suggests either it isn't associative, or noone thought of to add a `MonadPlus' instance
11:14:01 <monochrom> Funny, dons's blog is called donsbot and Control.Monad.Writer? :)
11:15:31 <Tony[`]> all hail dons
11:17:57 <mapreduce> @googleit foobarbaz
11:17:57 <lambdabot> http://letmegooglethatforyou.com/?q=foobarbaz
11:18:11 <mapreduce> This seems a poor feature to be in lambdabot.
11:19:44 <Gracenotes> hm, what's it called when you have two paths meet up again in a DAG? that would be a cycle, if it were an undirected graph?
11:20:10 <ski> maybe "sharing" ?
11:20:14 <Gracenotes> maybe.. an undirected cycle? >_< seems a bit wordy/vague though
11:20:34 <byorgey> a "confluence"?
11:20:38 <Gracenotes> ski: yeah... like "shared node". that seems nice
11:20:43 <ski> a "commutative diagram" ?
11:21:34 <Gracenotes> byorgey: ooh :o
11:24:18 <Gracenotes> it might be huge, but there might be some value in making a dictionary showing all possibly paths from one node to another
11:24:47 <Gracenotes> although in the graph I'm working with, the maximum length of any path is 5 nodes, so it's not so bad
11:24:54 <Gracenotes> *possible
11:32:36 <monochrom> Oh I see now, examining thunks during runtime is made possible by unpackClosure#. Neato.
11:33:43 <monochrom> Haha some of the visualizations are like chemistry molecule visualizations. :)
11:34:39 <Gracenotes> hm, is there some combinator for doing both structural recursion and keeping track of an accumulator while descending and ascending in the traversal? it is sort of mind-stretching.. but it seems to work :)
11:34:52 <Gracenotes> for trees/graphs in particular, I'm thinking of
11:35:38 <Gracenotes> sort of like depth-first search, actually. Just with an accumulator, like for example a node list for detecting cycles.
11:35:47 * monochrom goes ask a chemist to synthesize C7O7, a ring of 7 C's, each C attaching one O. This will look like the "cycle [1..7]" visualization in dons's talk.
11:36:22 <copumpkin> Gracenotes: a histomoprhism?
11:36:36 <copumpkin> Gracenotes: or a structuralrecursionwithaccumulomorphism maybe
11:36:48 <Gracenotes> good call
11:36:52 <monochrom> (Is that a German morphism?)
11:37:32 <Gracenotes> I'm not even sure this sort of morphism is particularly amenable to any category other than functions :P
11:37:57 <monochrom> Does foldl count as a structuralrecursionwithaccumulomorphism for lists?
11:38:30 <jmillikin> Is there any alternative URL to pull the XMonad sources from? code.haskell.org appears to be unavailable.
11:38:39 <Gracenotes> well, for the accumulator part certainly
11:41:02 <monochrom> I take that as "no".
11:41:28 <dcoutts> @seen Lemmih
11:41:28 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 2h 29m 56s ago.
11:42:15 <Gracenotes> monochrom: who nos
11:42:54 <EnglishGent> @hoogle Word160
11:42:54 <lambdabot> No results found
11:43:05 <Lemmih> dcoutts: Oi.
11:43:10 <dcoutts> hia Lemmih
11:43:40 <Lemmih> dcoutts: What's up?
11:44:21 <dcoutts> Lemmih: ok to chat privately?
11:45:00 * Gracenotes holds a glass against the door
11:45:11 <dcoutts> heh
11:45:26 <copumpkin> :o
11:45:33 <mmorrow> Gracenotes: use an (Int)Set to keep track of seen nodes
11:45:44 <copumpkin>  /j #sekrit_dcoutts_and_lemmih_private_chatroom
11:45:45 <mmorrow> lists are linear search!
11:45:47 <copumpkin> onoes
11:46:04 <Gracenotes> mmorrow: actually, what I'm trying to do is list all possible paths from one node to another node
11:46:22 <FunctorSalad_> * #sekrit_dcoutts_and_lemmih_private_chatroom :Nick/channel is temporarily unavailable
11:46:28 <Gracenotes> so the data structure that's being passed around is an IntMap (IntMap [Int]). enables much sharing
11:46:28 <mmorrow> Gracenotes: ooh. hmm
11:46:30 <FunctorSalad_> conspiracy!
11:46:55 <Gracenotes> actually, that should be [[Int]] perhaps
11:47:13 <mmorrow> Gracenotes: i was looking to try to do that at one point, but never got around to it, since what i was doing followed some other tangent
11:47:35 <mmorrow> Gracenotes: so the two nodes are given ahead of time, right?
11:47:47 <Gracenotes> the main point really is to find where paths meet up again, if at all, to try to help where ranks can be shifted in positioning subgraphs
11:48:57 <Gracenotes> yeah, huge graph of 2000 kanji, displaying subgraphs of maybe 5-30 at a time. sort of doing it on and off, many different directions :)
11:49:16 <Gracenotes> the actual code-writing, that is
11:50:13 <mmorrow> Gracenotes: err, be back in one sec
11:50:31 <Gracenotes> I think I'll need a mapAccum thing... *wave*
11:51:20 <EnglishGent> @hoogle hex
11:51:20 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
11:51:20 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
11:51:20 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
11:51:31 <copumpkin> Gracenotes: :O
11:51:55 <EnglishGent> hmm... I dont suppose there's a function to 'show' an Integer as a hex string available somewhere?
11:52:00 <mmorrow> Gracenotes: ok, why are you trying to do this in particular?
11:52:10 <mmorrow> Gracenotes: as a sub-step for another algo?
11:52:55 <Gracenotes> no, not really, just writing an algorithm to see where more than one path exists between two nodes (e.g. something that *could* be transitively reduced, but in this case shouldn't be)
11:53:22 <mmorrow> Gracenotes: ah ok, so you're looking to do transitive reduction?
11:53:45 <mmorrow> Gracenotes: there aren't very many good descriptions of that
11:54:29 <Gracenotes> well, no transitive reduction. It's almost like.. finding connected components, but in a structural way
11:55:00 <PetRat> I want to write a function that pattern-matches on various constructors of an algebraic data type, but I would prefer not to introduce a dependence on the number or ordering of fields.. I only care about one field.
11:55:03 <Gracenotes> anyway, it's fun :P  I'll see if it gets somewhere, for positioning heuristics
11:55:13 <copumpkin> PetRat: use records
11:55:22 <copumpkin> Gracenotes: start a blog about it!
11:55:29 <PetRat> copumpkin: is there a record-form of pattern matching?
11:55:36 <copumpkin> PetRat: yep
11:55:47 <EnglishGent> hi copumpkin :)
11:55:54 <copumpkin> f Record { field = x } = x
11:55:59 <copumpkin> EnglishGent: hi!
11:56:15 <PetRat> copumpkin: great!
11:57:51 <mmorrow> Gracenotes: right, connected components is a pre-step for transitive reduction
11:57:59 <mmorrow> (assuming the possibility of cycles)
11:58:08 <mmorrow> then for each SCC, you compute a minimal one
11:58:50 <Gracenotes> yeah. in the other project, it is. in the kanji project, it's not, but there is a similar concept of sink components and source components. nodes meeting up again makes this murky, e.g. it's not just a directed tree
11:58:55 <mmorrow> by first doing a dfs, classifying edges into 4 categories, and computing a dfsnumbering and another numbering, then you start removing edges
11:59:18 <Gracenotes> I mean, there is the possibility of cycles in the other project
11:59:34 <mmorrow> Gracenotes: totally, nearest common ancestor and dominators also come up in transitive reduction
12:00:15 <mmorrow> i've read that paper through once, i'd like to try to implem it the next go-through
12:01:56 <TommyOnMac> i hope this fever is transitive :-P
12:13:32 <arsenm> is there a good way to find if bindings to c are leaking?
12:14:17 <defun> is there a haskell calculus library?
12:14:43 <kmc> defun, what do you want it to do?
12:14:52 <defun> limits derivatives
12:14:58 <kmc> numerical?
12:15:01 <defun> yes
12:15:06 <PeakerWork> arsenm: its a longshot, but maybe valgrind can help
12:15:33 <PeakerWork> arsenm: maybe you could compile the bindings/library with some trickery to trace allocation/releases to see if/where there's a leak
12:16:33 <kmc> defun, i can't find one :/
12:16:37 <kmc> look through the packages on hackage
12:16:43 <defun> sure.
12:16:44 <defun> thanks
12:16:47 <kmc> there is a library for rungekutta integration
12:16:57 <defun> hmm
12:17:00 <defun> sounds like a start
12:17:03 <defun> :)
12:17:08 <Phyx-> kfc?
12:17:10 <Phyx-> oh, kmc
12:17:28 <PeakerWork> arsenm: what is it possibly leaking specifically?
12:17:35 <arsenm> PeakerWork: I've tried valgrind but I have almost no idea where to start with non-c
12:17:46 <arsenm> PeakerWork: I'm working on some bindings, and valgrind says I have a small leak
12:18:29 <PeakerWork> arsenm: ah. do you know if its in the lib or in the bindings?
12:18:34 <PeakerWork> arsenm: is it leaking malloc calls?
12:20:34 <arsenm> PeakerWork: at this point I'm still checking that I understand what I'm doing with bindings, and don't want to end up finding I've done everything fundamentally wrong later with lots of leaks, and it's almost certainly my bindings
12:24:27 <Gracenotes> hm. what's the best way for merging a list of key/values into an IntMap? making a temporary IntMap from them and unioning together? or something with foldl' insert?
12:25:10 <PeakerWork> arsenm: well, laziness is notorious for causing certain kinds of leaks
12:25:16 <PeakerWork> arsenm: maybe you can paste some code?
12:31:00 <Gracenotes> > map (0:) [[1,2],[]]
12:31:01 <lambdabot>   [[0,1,2],[0]]
12:34:09 <tibbe> @seen bos
12:34:10 <lambdabot> I saw bos leaving #ghc and #haskell 1h 36m 15s ago, and .
12:34:25 <tibbe> @msg bos Fredrik Lundh sits next to me at work. :)
12:34:25 <lambdabot> Not enough privileges
12:34:39 <tibbe> @tell bos Fredrik Lundh sits next to me at work. :)
12:34:40 <lambdabot> Consider it noted.
12:35:04 <arsenm> PeakerWork: if you really want to see what I'm doing I can put it somewhere in a couple of minutes
12:35:23 <PeakerWork> arsenm: I'm not sure I'll have time to, but maybe someone will
12:35:28 <PeakerWork> arsenm: if its a laziness issue, for example
12:44:16 <poe> (sorry, anybody can access springerlink.com for a couple articles? broken uni's proxy here.)
12:46:35 <amitprakash> whats wrong with type Figure = [ String [ ( Int, Int)]]
12:47:26 <mauke> it doesn't make sense
12:47:30 <Berengal> amitprakash, String isn't a type constructor. You probably want a tuple
12:47:30 <mauke> String takes no arguments
12:48:10 <amitprakash> Berengal, ah wait.. what i want is a data type which has a string then a list of int, int
12:48:23 <amitprakash> Berengal, right.. touple i guess
12:48:24 <mauke> (String, [(Int, Int)])
12:48:26 <Berengal> [(String, [(Int, Int)])]
12:48:55 <b0ef> I've studied haskell in like 2 hours and even I spotted that one;)
12:49:03 <b0ef> hehe
12:59:10 <arsenm> PeakerWork: http://jayne.hortont.com/git/cgit.cgi/clutterhs/
12:59:10 <lambdabot> Title: clutterhs - Clutter Haskell bindings
13:03:21 <Parkotron> I'm very new to Haskell. Any comments on the layout and indentation of this code? http://pastebin.ca/1564557 It seems a bit awkward to me, but I'm not necessarily sure what good Haskell looks like. :)
13:03:38 <copumpkin> I wouldn't indent the where that far
13:04:01 <Parkotron> copumpkin: What would you do? 4 spaces?
13:04:02 <copumpkin> I might also use a guard instead of those ifs
13:04:10 <copumpkin> Parkotron: probably 2 spaces
13:04:58 <Parkotron> copumpkin: I can see how to replace the first if with a guard, but not the other two.
13:06:17 <aavogt> ski: turns out, there is a MonadPlus instance in Text.ParserCombinators.Parsec.Prim, but I needed to write in the alternative instance: x <|> y = Parsec.try x Parsec.<|> y
13:06:18 <kmc> Parkotron, there's a very simple declarative way to write isPalindrome
13:06:30 <aavogt> for the permutation parsing to work properly
13:06:44 <copumpkin> :t ap (==) reverse
13:06:45 <lambdabot> forall a. (Eq a) => [a] -> Bool
13:06:48 <kmc> i think your version there will walk to the end of the list over and over
13:07:15 <copumpkin> > (==) <*> reverse $ "abcba"
13:07:16 <lambdabot>   True
13:07:18 <copumpkin> > (==) <*> reverse $ "abcb"
13:07:18 <lambdabot>   False
13:07:49 <kmc> for a beginner i'd suggest just: isPalindrome xs = xs == (reverse xs)
13:09:17 <kmc> it's also faster -- will walk to the end of the list only once, then unravel that while comparing pointwise against xs
13:09:21 <PeakerWork> that has some unnecessary comparisons, if you care
13:09:26 <copumpkin> yeah
13:09:42 <kmc> which does?
13:09:43 <PeakerWork> (both do)
13:10:03 <PeakerWork> you don't need to compare first to last and then last to first
13:10:19 <kmc> that's true
13:10:33 <copumpkin> if it's not a palindrome it's not inefficient
13:11:24 <PeakerWork> but its not easy to get rid of it without adding more iterations of the list. (reverse + length) at the same time could work, maybe, with conal's more beautiful folds, then with length available it is easy
13:11:24 <kmc> Parkotron, also i probably wouldn't use a 'where' on euler4 at all
13:11:36 <kmc> since the bulk of the function is in the where, just make that a top-level declaration
13:11:57 <Parkotron> kmc: The predicate "p" is passed in. That's why it's nested.
13:12:22 <kmc> i'd just pass that around
13:12:32 <Parkotron> Seemed cleaner than having helper pass p to itself.
13:12:37 <kmc> but it's a matter of style, i've used the other way as well
13:13:01 <kmc> the best case is when your main function is just a partially-applied helper
13:13:04 <kmc> but that doesn't seem to be the case here
13:13:57 <kmc> Parkotron, for using guards further in, you might use a case statement
13:14:31 <Parkotron> kmc: Is that really better than an if. (Honest question.)
13:14:44 <kmc> it depends
13:16:01 <aavogt> has anybody written a readsToParsec :: Read b => CharParser st b
13:16:17 <aavogt> I have something that works, but it messes up the positions
13:16:45 <kmc> (if k > biggest && p k then k else biggest)  ==>  (if p k then max k biggest else biggest)
13:16:46 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9334#a9334
13:16:49 <kmc> i think that's clearer
13:17:36 <Parkotron> kmc: I had debated that one, myself. Flipped back and forth.
13:17:39 <kmc> also, if the goal here is to find the largest of something
13:17:43 <kmc> why not just make a list and sort it?
13:17:54 <kmc> or actually
13:17:56 <kmc> :t maximum
13:17:56 <lambdabot> forall a. (Ord a) => [a] -> a
13:18:47 <PeakerWork> maximum . filter p  ?
13:18:54 <aavogt> basically, when I have that setSourceColumn set, it overshoots the number of lines and columns by about 3
13:19:23 <aavogt> otherwise the source position isn't advanced
13:24:34 <kmc> Parkotron, most of the early project euler problems can be solved in one, reasonably readable line
13:26:52 <Berengal> kmc, doesn't really say much, since a line of haskell can be anything between 1 and 50 lines of blub (depending on which blub and which context)
13:27:20 <kmc> blub?
13:28:06 <Berengal> http://www.paulgraham.com/avg.html
13:28:07 <lambdabot> Title: Beating the Averages
13:28:31 <kmc> i don't see why comparing to other languages is relevant
13:28:33 <McManiaC> how do you overload a instance for a data?
13:29:02 <kmc> my point is that if you're doing PE in haskell for the purpose of learning concise, idiomatic haskell, you should have that as a target
13:29:10 <kmc> (i'm not assuming that is Parkotron's purpose however)
13:29:32 <aavogt> McManiaC: you mean declaring an instance for the class Data, or something else?
13:30:49 <Berengal> kmc, my point was that most small things can be done in one reasonably readable line in haskell
13:31:03 <kmc> Berengal, that was my point too :)
13:31:11 <badsheepy> the lexical permutations one i did today
13:31:20 <badsheepy> i spent a day doing the iterative solution, it was hideous
13:31:27 <badsheepy> two days trying to work out evil nonsense
13:31:34 <McManiaC> aavogt: jup
13:31:35 <badsheepy> and then it was a 2 line solution i googled :(
13:32:12 <Parkotron> kmc: I didn't want to brute force it, though. I certainly couldn't have come up an intelligent solution in a single line. Emphasis on "I".
13:32:31 <kmc> Parkotron, what's your definition of brute force here
13:33:00 <Parkotron> Try all three digit numbers and take the biggest palindromic product.
13:33:21 <kmc> and what are you doing?
13:33:29 <saml> ?
13:34:11 <kmc> not you
13:34:11 <aavogt> McManiaC: usually you get ghc to derive Data, but I still don't understand what you're trying to do...
13:34:22 <McManiaC> aavogt: just playing around ^^
13:34:27 <McManiaC> at least atm
13:34:28 <McManiaC> ;P
13:34:38 <kmc> you'd declare an instance of Data the same way as any other typeclass instance
13:34:50 <Parkotron> kmc Starting with the largest numbers and working downward, moving on when no bigger solutions are possible.
13:34:55 <aavogt> > Data.Traversable.sequenceA (1,Just 1)
13:34:55 <lambdabot>   No instance for (Data.Traversable.Traversable ((,) t))
13:34:56 <lambdabot>    arising from a us...
13:35:12 <kmc> okay
13:39:02 <copumpkin> > strength (1,Just 1)
13:39:02 <lambdabot>   Just (1,1)
13:40:12 <kmc> :t strength
13:40:12 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => (a1, f a) -> f (a1, a)
13:40:51 <pao> > strength (1, Nothing)
13:40:52 <lambdabot>   Nothing
13:41:53 <aavogt> copumpkin: yeah, that's it
13:42:20 * aavogt remembers asking about it before
13:43:00 <copumpkin> :t let bistrength = uncurry (liftA2 (,)) in bistrength
13:43:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (f a, f b) -> f (a, b)
13:45:00 <aavogt> :t unbistrength = fmap fst &&& fmap snd
13:45:00 <lambdabot> parse error on input `='
13:45:14 <aavogt> :t let unbistrength = fmap fst &&& fmap snd in unbistrength
13:45:15 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a, b) -> (f a, f b)
13:45:36 <aavogt> or is that biweakness?
13:49:06 <dolio> Wouldn't weakness be costrength?
13:49:53 <olsner> hmm, cobistrength? bicostrength?
13:50:18 <dolio> costrength :: f (Either a b) -> Either a (f b)
13:50:27 <copumpkin> I just made up the bistrength name
13:50:41 <dolio> bicostrength is tough, I think.
13:51:06 <dschoepe> Is it possible to compile an executable only when a flag is set in cabal?
13:54:04 <int-e> dschoepe: yes.  if !flag(name) [next line, indented] Buildable: False
13:54:13 <dschoepe> int-e: thanks
13:58:50 <trofi> 'foreign import ccall "&" cur_term :: Ptr (Ptr TERMINAL)' what is "&" ?
14:00:58 <trofi> it's a global C visible symbol of this type or something?
14:02:10 <mauke> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-170004.1.1
14:02:12 <lambdabot> Title: 4 Specification of External Entities, http://tinyurl.com/2pdya4
14:05:06 <trofi> not sure i got what is written there :[
14:06:39 <BMeph> trofi: "If a Haskell program needs to access a C variable bar of integer type, ==> foreign import ccall "&" bar :: Ptr CInt <==
14:06:40 <BMeph> must be used to obtain a pointer referring to the variable. "
14:06:44 <M_o_C> Do you know what the & operator  does in C(++) besides bitwise AND?
14:07:35 <Gracenotes> uh. this is not a C++ channel -_- but it does do boolean and (not short-circuited), and whatever else you overload it to do in C++
14:07:38 <Lycurgus> gets a ref IIRC
14:07:48 <Lycurgus> but what Gracenotes said
14:07:48 <Gracenotes> oh, right, that too
14:07:49 <trofi> gets an address
14:07:54 <M_o_C> No, I was asking trofi to see where his problem is ;)
14:07:58 <mauke> & doesn't do boolean and
14:08:11 <M_o_C> Sorry, I should have prefixed it.
14:08:15 <trofi> i don't get who allocates memory for that "reference"
14:08:24 <trofi> and how stable is it
14:08:26 <mauke> trofi: the linker
14:08:36 <mauke> since you're getting the address of a symbol
14:10:37 <trofi> and without "&" some other module should provide already allocated and available symbol, right?
14:11:16 <mauke> trofi: without & you're getting a function
14:14:06 <BMeph> trofi: "The first alternative either imports a static function 'cid' or, if '&' precedes the identifier, a static address."
14:14:11 <trofi> then "&" is never a 'ccall'
14:14:31 <nominolo> Hm, interesting.  My package DB consists of 136 packages, totalling 2143 modules, which together export 43101 distinct items, with 32020 distinct names
14:14:46 <nominolo> That's quite a lot of name-overloading
14:15:46 <int-e> nominolo: how much of that is base-3 vs. base-4?
14:16:03 <nominolo> int-e: ah, good point.  didn't count
14:16:08 <nominolo> probably a lot
14:16:58 <trofi> BMeph: Can i get static address to a C function with "&" and how to call that function then?
14:18:17 <mauke> well, you'd have a Ptr (a -> b) for some a, b
14:18:29 <mauke> so dereference, then call
14:18:53 <trofi> FunPtr?
14:19:20 <mauke> hmm
14:19:42 <int-e> even with FunPtr, won't you have to use a foreign import "wrapper" to turn it into a haskell function?
14:19:52 <mauke> right, should be FunPtr
14:20:27 <mauke> argh
14:20:57 <int-e> ah no. stupid me.
14:21:57 <trofi> seem to start getting it
14:23:51 <int-e> foreign import ccall "dynamic"  is what you need
14:24:46 <int-e> see http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-160004.1.3
14:24:47 <lambdabot> Title: 4 Specification of External Entities, http://tinyurl.com/2pdya4
14:25:16 <trofi> oh, i don't need it. i'm just trying to figure out what way terminfo manages to break on ppc64
14:26:58 <sinelaw> @undef
14:27:07 <sinelaw> @let bottom = bottom
14:27:08 <lambdabot>  Defined.
14:27:10 <sinelaw> > bottom
14:27:15 <lambdabot>   mueval-core: Prelude.read: no parse
14:27:15 <lambdabot>  mueval: ExitFailure 1
14:27:19 <sinelaw> why no parse?
14:27:41 <PeakerWork> sinelaw: just a bug in the way mueval reports errors to lambdabot
14:27:43 <trofi> > bottom -- yes, why?
14:27:48 <lambdabot>   mueval-core: Prelude.read: no parse
14:27:49 <lambdabot>  mueval: ExitFailure 1
14:27:58 <PeakerWork> I think its basically timing out, and the timeout error is mis-parsed
14:28:00 <Taejo> :t unfoldr
14:28:01 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:28:18 <PeakerWork> > let f (x,y) = 1 in f undefined
14:28:19 <lambdabot>   * Exception: Prelude.undefined
14:28:24 <PeakerWork> > let f ~(x,y) = 1 in f undefined
14:28:25 <lambdabot>   1
14:28:40 <trofi> ok, thanks mauke, int-e and BMeph! time to sleep a little
14:29:13 <dmwit> \bot doesn't know how to parse an exception, I guess.
14:36:46 <Taejo> why is randomR uncurried?
14:37:02 <dmwit> :t bounds
14:37:03 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
14:37:07 <dmwit> ;-)
14:37:19 <Taejo> :)
14:37:27 <FunctorSalad_> apparently to make it clear it's an interval
14:37:39 <Taejo> or just to compose with bounds?
14:40:47 <Taejo> :t fromMaybe
14:40:48 <lambdabot> forall a. a -> Maybe a -> a
14:43:17 <Baughn> Has ghc 6.10 started doing something that breaks ptrace?
14:44:16 <Baughn> $ strace -p `pidof xmobar`
14:44:19 <Baughn> attach: ptrace(PTRACE_ATTACH, ...): Operation not permitted
14:44:39 <defun> what does it mean when a numerical operation in haskell returns 'NaN'
14:45:11 <mauke> > 0/0
14:45:12 <lambdabot>   NaN
14:45:27 <defun> ah... infinity?
14:45:30 <mauke> > 1/0
14:45:31 <lambdabot>   Infinity
14:45:37 <defun> sweet!
14:45:41 <defun> thanks
14:46:11 <profmakx> dividing by zero always hurts me :/
14:49:05 <skorpan> subtracting is much better
14:49:21 <kmc> defun, NaN is "Not a Number", and not +infinity or -infinity either
14:49:25 * dolio subtracts by zero all the time.
14:50:53 * Badger subtracts 0 from dolio 
14:52:38 <dolio> @pl subtract 0
14:52:38 <lambdabot> subtract 0
14:52:49 <dolio> @pl \x -> x - 0
14:52:49 <lambdabot> subtract 0
14:53:07 <dolio> I guess @pl doesn't believe that's the identity function.
14:53:51 <skorpan> does lambdabot know that (-) is Prelude.-?
14:54:02 <PeakerWork> @index (-)
14:54:02 <lambdabot> Prelude
14:54:05 <dolio> Well, it assumes all sorts of other things.
14:54:15 <dolio> @pl \x y -> y + x
14:54:15 <lambdabot> (+)
14:54:20 <dolio> Like addition is commutative.
14:54:26 <copumpkin> is that kind of information hardcoded in it?
14:54:41 <copumpkin> or does it have a config file with "knowledge"?
14:54:52 <skorpan> no one knows
14:54:56 <dolio> I imagine it's hard coded.
14:54:59 <skorpan> it's like djinn, dark magic
14:55:08 <sinelaw1> @djinn
14:55:08 <lambdabot> Cannot parse command
14:55:19 <skorpan> @djinn (a -> b) -> a
14:55:19 <lambdabot> -- f cannot be realized.
14:55:20 <sinelaw1> i call that disobedience
14:55:23 <skorpan> snap
14:55:32 <skorpan> @djinn (a -> b) -> a -> b
14:55:32 <lambdabot> f a = a
14:56:50 <defun> what do the letter NaN stand for?
14:56:59 <kmc> Not a Number
14:57:05 <mauke>  <kmc> defun, NaN is "Not a Number"
14:57:11 <defun> that's what I thought. thanks
15:13:32 <sinelaw> what does |- mean? (reading a paper about epigram)
15:14:13 <Rotaerk> doesn't it mean "therefore" or something
15:14:33 <conal> "is derivable from"
15:14:55 <Taejo> sinelaw: "S |- F" means that we can prove statement F using the assumptions in the set S
15:14:56 <skorpan> p ^ q |- p
15:15:04 <conal> yah
15:15:08 <skorpan> what's the other thing, |=?
15:15:10 <conal> yeah
15:15:11 <skorpan> soundness?
15:15:53 <PeakerWork> conal: hey! how's the GPU compiler project going?
15:16:00 <skorpan> i miss doing that type of stuff
15:16:14 <Taejo> skorpan: AFAICT, the difference between |- and |= depends on context
15:16:27 <skorpan> Taejo: how so?
15:16:51 <conal> PeakerWork: hi there!  it's in good shape.  though stalled while i was away and now while i'm learning mac/iphone programming.
15:16:59 <dolio> |= is like what you use when you need something like |-, but |- is already taken. :)
15:17:06 <Taejo> when I studied logic one meant "derivable from" and the other meant "implies", until we proved that the two things were equivalent
15:17:16 <Saizan> yeah
15:17:22 <skorpan> Taejo: |= and -> isn't the same thing, are they?
15:17:31 <PeakerWork> conal: cool!  Are you going to publish some of that goodness anytime? :)
15:17:40 <skorpan> aren't the same thing*
15:17:44 <conal> PeakerWork: yeah i will.
15:17:44 <Saizan> you can see |= as the denotational semantics of |- usually
15:18:41 <sinelaw> ouch, still can't understand what this means. notations, notations. can someone explain the typing rules on page 2 of this: http://www.e-pig.org/downloads/epigram-notes.pdf
15:18:42 <Taejo> skorpan: no, -> is a symbol in a formal language; |= is a metalanguage "verb"
15:18:42 <sinelaw> ?
15:18:43 <lambdabot> Title: Epigram: Practical Programming with Dependent Types
15:18:49 <Saizan> skorpan: -> is usually a connective of the logic, while |= is a metatheoretic notion
15:19:00 <dolio> Oh yeah. If you're doing propositional logic you might have Propositions |- theorem, whereas Model |= theorem.
15:19:17 <dolio> Sorry, predicate logic.
15:19:45 <PeakerWork> is conor mcbride ever here?
15:20:19 <conal> PeakerWork: i don't think so.
15:20:25 <dolio> Where there are potentially a lot of models for a particular set of assumptions.
15:20:27 <conal> PeakerWork: he's pigworker on twitter
15:20:35 <PeakerWork> conal: cool, thanks
15:20:40 <conal> :)
15:21:19 <jordandanford> Hi, I have a question - is there a way to overload the "^" function?
15:21:38 <skorpan> @index (^)
15:21:38 <lambdabot> Prelude
15:21:49 <aavogt> yes
15:22:12 <aavogt> > let x ^ y = x / y in 12 ^ 2
15:22:12 <lambdabot>   6.0
15:22:25 <copumpkin> nope
15:22:41 <copumpkin> except indirectly by overloading *
15:22:45 <jordandanford> sorry, I wasn't specific enough
15:22:50 <Saizan> sinelaw: e.g. the one on the left means: if (assuming x is of type S, t is of type T) then ( \x -> t is of type forall x:S, T )
15:23:21 <aavogt> @type (^)
15:23:22 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:23:37 <jordandanford> I'm making my own Fraction datatype, and I've overloaded (+), (-), etc, by making Fraction part of the Num typeclass
15:24:01 <copumpkin> (^) just uses your (*)
15:24:04 <mauke> what's wrong with the xisting fractions?
15:24:07 <copumpkin> @src (^)
15:24:07 <lambdabot> x ^ 0            =  1
15:24:08 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
15:24:08 <lambdabot>   where f _ 0 y = y
15:24:08 <lambdabot>         f x n y = g x n
15:24:08 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
15:24:08 <mauke> *existing
15:24:09 <lambdabot>                       | otherwise = f x (n-1) (x*y)
15:24:12 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
15:24:16 <copumpkin> whoops, sorry, that's rather large
15:24:22 <jordandanford> but it says it conflicts with the (^) already in Prelufe
15:24:25 <jordandanford> *Prelude
15:24:35 <mauke> what's wrong with the existing (^)?
15:24:35 <copumpkin> jordandanford: you get that for free, you can't override it
15:24:44 <copumpkin> unless you want to hide it
15:25:22 <jordandanford> GHCi says "Ambiguous occurrence `^'"
15:26:13 <Saizan> jordandanford: if you want to use your (^) then you have to import Prelude hiding ((^))
15:26:28 <jordandanford> oh, nevermind
15:26:45 <jordandanford> I'm a bit dumb - I didn't realize I already got it if I defined (*)
15:26:49 <mauke> so, what's wrong with Rational?
15:28:33 <jordandanford> well, thank you for your help
15:30:09 <CalJohn> @hoogle ByteString -> a
15:30:09 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:30:09 <lambdabot> Prelude id :: a -> a
15:30:09 <lambdabot> Data.Function id :: a -> a
15:31:11 <copumpkin> CalJohn: that'd be an odd function to have
15:31:12 <CalJohn> is there a read :: ByteString -> a ?
15:31:28 <copumpkin> read :: (Read a) => ByteString -> a maybe :)
15:31:33 <copumpkin> but I don't think so
15:31:46 <copumpkin> it would necessarily just convert the bytestring to a string and read that
15:32:33 <CalJohn> can bytestrings not be read?
15:33:04 <copumpkin> the problem is that the Read typeclass assumes you're going to be feeding it a string
15:33:25 <copumpkin> so, they can be read, but you don't get any benefit over just reading them from a regular string
15:33:46 <PeakerWork> well, a ByteString has to be decoded into text before it can be parsed as text
15:34:43 <Gracenotes> @index text
15:34:43 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.Html, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
15:37:17 <Taejo> is there a dead-simple twitter library for haskell? something where I can run `tweet username password "This is my tweet"` and nothing more
15:37:27 <CalJohn> copumpkin: ok, i was just trying to use bytestrings because i thought it would be sensible to use them everywhere
15:53:04 <FunctorSalad_> mmorrow: should someone unbitrot hstidy or is it somehow redundant now?
15:53:37 <mmorrow> FunctorSalad_: i've got an updated version, but i've just been too lazy to update the hackage package
15:53:56 <mmorrow> FunctorSalad_: http://moonpatio.com/repos/derive-gadt/tools/hstidy.hs  is the current
15:54:05 <FunctorSalad_> thanks
15:54:20 <mmorrow> FunctorSalad_: making a note to update that too :)
15:55:56 <Boney> N
15:56:55 <mmorrow> icaragua?
15:57:28 <gwern> what did hstidy do? sounds like hlint
15:58:04 <FunctorSalad_> gwern: indent stuff properly
15:58:14 <gwern> astounding
16:09:39 <kmc> :t head []
16:09:39 <lambdabot> forall a. a
16:09:45 <torrenter> does anyone know of a good PDF torrent of Real World Haskell (I have the .chm)
16:10:44 <kmc> torrenter, it's free in html form
16:10:49 <kmc> and you could convert either that or the chm to pdf
16:10:49 <Gracenotes> hrm, is it wrong the treat the inconsistent behavior of NaN as a feature in sorting algorithms? -_-
16:10:55 <torrenter> i know but i want to print it
16:11:02 <kmc> Gracenotes, floats have a partial order :/
16:11:07 <kmc> what's inconsistent though
16:11:11 <torrenter> and the PDF version i found has "5 comments" everywhere
16:11:39 <Gracenotes> > let nan = 0/0 in sort [nan, 3, nan, 5, nan, 1, nan]
16:11:40 <lambdabot>   [NaN,1.0,NaN,3.0,5.0,NaN,NaN]
16:11:59 <Gracenotes> for the most part it leaves the elements alone. which is a good thing in my case :)
16:12:33 <tehgeekmeister> boo, just came back to code i haven't touched for months and it appears i left it broken.  =/
16:12:40 <torrenter> i find the "5 comments" in blue at the end of each paragraph _very_ distracting
16:12:52 <Gracenotes> > let nan = 0/0 in sortBy (comparing snd) $ zip [0..] [nan, 3, nan, 5, nan, 1, nan]
16:12:53 <lambdabot>   [(6,NaN),(5,1.0),(4,NaN),(1,3.0),(3,5.0),(2,NaN),(0,NaN)]
16:13:10 <kmc> torrenter, you could edit that out easily
16:13:15 <Gracenotes> hm. well, not entirely leaving them alone, but keeps them distributed
16:13:16 <kmc> probably just by tweaking the stylesheet
16:13:50 <kmc> sortBy is stable right?
16:13:57 <tehgeekmeister> torrenter: it's available in a clean pdf on emule, don't know about torrents, tho.
16:14:10 <torrenter> ok i'll go find it
16:14:22 <kmc> you do know the people who wrote that book are in this channel right
16:14:33 <torrenter> so i'm anonymous =]
16:14:48 <kmc> okay i'll come to your house wearing a ski mask and steal your car :)
16:15:08 <kmc> (I don't care all that much; IP is mostly bullshit.  but it's a little rude)
16:15:37 <MyCatVerbs> kmc: sortBy and sort are mergesorts, so yes.
16:15:41 <torrenter> true but i just want to print this book, not rob a bank
16:16:01 <MyCatVerbs> RWH? Is on the friggin' interwebs anyways.
16:16:05 <MyCatVerbs> @where rwh
16:16:05 <lambdabot> is http://www.realworldhaskell.org/blog/
16:16:07 <tehgeekmeister> given that it's available in html for free, it's kinda odd to expect people won't take that as a sort of implicit permission for other formats, albeit this holds absolutely no weight legally.
16:16:15 <kmc> you can learn haskell first and use that to rob the bank
16:16:27 <kmc> @src sortBy
16:16:27 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:16:34 <MyCatVerbs> kmc: so that's what the missiles are for.
16:16:36 <kmc> @src insertBy
16:16:37 <lambdabot> insertBy _   x [] = [x]
16:16:37 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
16:16:37 <lambdabot>                                  GT -> y : insertBy cmp x ys'
16:16:37 <lambdabot>                                  _  -> x : ys
16:16:53 <tehgeekmeister> how do i insert unsafe print statements into code again, for debugging purposes?
16:16:54 <kmc> so sort and friends should only look at >, not ==
16:16:56 <Gracenotes> that's not the sort from Data.List.
16:16:57 <torrenter> tehgeekmeister: you have the link to the clean pdf by any chance?
16:16:59 <kmc> and thus should work fine for a partial order
16:17:05 <tehgeekmeister> torrenter: no, i don't
16:17:13 <kmc> i.e., they will satisfy stability with respect to that order
16:17:18 <Gracenotes> Data.List uses a different, faster, but more complicated algorithm
16:17:29 <Parkotron> Can someone recommend a good Data.Map tutorial/example?
16:17:33 <aavogt> @index trace
16:17:33 <lambdabot> Debug.Trace
16:17:34 <kmc> tehgeekmeister, Debug.Trace iirc
16:17:40 <kmc> ha beat you lambdabot
16:17:41 <tehgeekmeister> kmc: thanks
16:18:17 <Gracenotes> kmc: the one in Data.List does use the same sort of comparison, though :)
16:18:52 <kmc> Parkotron, there are examples in the Data.Map documentation
16:19:04 <kmc> are you trying to do something in particular?
16:19:11 <tehgeekmeister> it seems the version of my code i've come back to after months is the one that is merely a constant space infinite loop
16:19:15 <Gracenotes> kmc: the issue is that, if you have a = NaN and b = NaN, both cmp a b and cmp b a will yield GT
16:19:29 <kmc> Gracenotes, really? that seems wrong
16:19:30 <gwern> that's floating point for you!
16:19:37 <kmc> > let a = (0/0) in compare a a
16:19:37 <lambdabot>   GT
16:19:41 <kmc> well i'll be buggered
16:19:43 * gwern notes that all of floating point seems wrong to me
16:19:46 <Gracenotes> kmc: there's no other option, based on how compare is defined
16:20:02 <kmc> wouldn't EQ be better in this context?
16:20:09 <Parkotron> kmc: No, just trying to get an impression of how the module works.
16:20:14 <Gracenotes> NaN != NaN, that is defined in the spec
16:20:17 <copumpkin> if that were true, it wouldn't break the equivalence relation
16:20:17 <gwern> thougth NaN != NaN
16:20:22 <kmc> sure but so is NaN !> NaN
16:20:41 <Parkotron> kmc: I had only seen one or two line examples in the docs, but your right, there are some longer examples in there too.
16:20:46 <Gracenotes> the problem is that NaN != NaN, but there is no ordering between then, so:
16:21:02 <Gracenotes> > let nan = 0/0 in (nan < nan, nan > nan)
16:21:03 <lambdabot>   (False,False)
16:21:27 <Gracenotes> 'compare' checks for (<). So seeing it is false, assumes GT
16:21:46 <kmc> the real problem seems to be that compare can't represent partial orders
16:22:02 <BMeph> Gracenotes: Well, and after confirming the /= case, too. :)
16:22:10 <Gracenotes> ja
16:22:20 <dolio> Even partial orders have reflexivity.
16:22:33 <dolio> Even preorders.
16:22:51 <BMeph> The "real" problem is that compare was never made for partial orders, but some people insist on using them anyway... ;p
16:23:00 <Gracenotes> but this is actually useful for me, since I sort of want NaNs well distributed in sort, which seems to happen more often than not here >_> that is, I don't care about their positions, I'd just rather not have them all bunch up on one end
16:23:37 <Gracenotes> perverse as it is
16:23:48 <mmorrow> BMeph: that seems rather a "complex" problem to me
16:23:50 <copumpkin> Floats should never be compared, only computed with
16:24:01 <FunctorSalad_> they Haskell a lot at Utrecht don't they? :)
16:24:19 <FunctorSalad_> half the type-level things on hackage link there
16:24:39 <Gracenotes> copumpkin: that's nice, but this is for a heuristic...
16:24:44 <copumpkin> :P
16:24:58 <Gracenotes> I am computing a heuristic order
16:25:00 <copumpkin> use CReal kthx
16:25:12 <davidL> can (++) be written tail recursively?
16:25:18 <Gracenotes> pssh, I'll use Float! super extra speed!
16:25:25 <copumpkin> davidL: what do you mean by tail recursion
16:25:25 <copumpkin> ?
16:25:29 <dolio> Use slow code kthx!
16:25:32 <dolio> :)
16:25:34 <kmc> davidL, yes
16:25:42 <copumpkin> listen to dolio kthx!
16:25:48 <davidL> kmc: how?
16:25:57 <aavogt> @src (++)
16:25:57 <lambdabot> []     ++ ys = ys
16:25:57 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:25:57 <lambdabot> -- OR
16:25:57 <lambdabot> xs ++ ys = foldr (:) ys xs
16:25:58 <copumpkin> @src (++)
16:25:58 <lambdabot> []     ++ ys = ys
16:25:59 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:26:01 <lambdabot> -- OR
16:26:02 <copumpkin> damn
16:26:03 <lambdabot> xs ++ ys = foldr (:) ys xs
16:26:03 <Gracenotes> note, modern architectures tend to be optimized for doublin and so on
16:26:15 <kmc> davidL, with an accumulator argument i imagine
16:26:41 <FunctorSalad_> isn't efficient (++) what FMList is for? I could be wrong
16:26:47 <davidL> so can you write it in terms of foldl?
16:27:05 <copumpkin> davidL: why would you want to?
16:27:12 <copumpkin> the foldr definition is very natural
16:27:19 <mmorrow> davidL: you wouldn't want to really, i think it'd be worse than foldr no matter how you did it
16:27:35 <Gracenotes> is someone threatening you with a gun unless you write (++) with foldl? it's okay, you can tell us
16:27:46 <copumpkin> gun + bj = awesome
16:27:58 <mmorrow> :o
16:28:02 <FunctorSalad_> :o
16:28:07 <mmorrow> @bot
16:28:07 <lambdabot> :)
16:28:07 <lunabot>  :o
16:28:07 <dolio> copumpkin: Are you watching Swordfish?
16:28:07 <tehgeekmeister> copumpkin: lawl, swordfish
16:28:09 <davidL> Gracenotes: sort of, someone is claiming it can be done tail recursively
16:28:11 <gwern> FMList? 'Fuck My List'? :)
16:28:13 <copumpkin> :)
16:28:19 <copumpkin> nah, but was reminded of it
16:28:26 <copumpkin> DLists can also do fast append
16:28:37 <davidL> Gracenotes: and by someone, I mean this homework assignment :P
16:28:40 * dolio hopes someday to be as good a hacker as Hugh Jackman. Or Ryan Phillipe.
16:28:48 <FunctorSalad_> copumpkin: "foldMap lists" FWIW
16:28:49 <gwern> 'so I appended all 100 entries to my list - then I discovered I needed to index in the *reverse* order. FML, man. FMList.'
16:28:56 <tehgeekmeister> http://www.cse.unsw.edu.au/~liamoc/obf.html <== this is scary
16:28:57 <lambdabot> Title: awesome.hs
16:29:03 <copumpkin> davidL: what do they mean by tail recursion in haskell?
16:29:12 <copumpkin> lol
16:29:14 <davidL> copumpkin: it's ocaml :(
16:29:19 <copumpkin> davidL: oh ok
16:29:19 <tehgeekmeister> supposedly it's fibs
16:29:20 <Gracenotes> I supose you could do a weird function-composing thing, like the way to write foldl in terms of foldr, but the other way around
16:29:29 <FunctorSalad_> tehgeekmeister: well IMHO lack of indentation is cheating (for obfuscation)
16:29:36 <Gracenotes> does OCaml have easy function composition?
16:29:44 <tehgeekmeister> FunctorSalad_: i didn't write it, but you're right
16:29:46 <copumpkin> tehgeekmeister: have you seen the reverse state monad version of fibs?
16:29:47 <FunctorSalad_> tehgeekmeister: I piped it through hstidy and it seems like it isn't even beta-reduced
16:30:00 <tehgeekmeister> copumpkin: no
16:30:07 <tehgeekmeister> FunctorSalad_: beta reduced?
16:30:08 <Gracenotes> I mean, you have (a:), (b:), (c:), etc., and you compose them in the proper order. uh. if that's possible.
16:30:12 <copumpkin> tehgeekmeister: http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
16:30:13 <lambdabot> Title: Mindfuck: The Reverse State Monad « Luke Palmer, http://tinyurl.com/m3py3l
16:30:16 <mmorrow> FunctorSalad_: hehe, a perfect hstidy application!
16:30:27 <copumpkin> tehgeekmeister: there, clean code, but still a mindfuck :)
16:30:46 <tehgeekmeister> reverse state monad...  guh.
16:30:52 <tehgeekmeister> why does the world need such a thing?
16:30:54 <FunctorSalad_> tehgeekmeister: I think it contains expression of the form "(\x -> blah) y"
16:30:56 <davidL> kmc: how would an accumulator be useful for (++)?
16:31:03 <FunctorSalad_> tehgeekmeister: (which can be statically simplified)
16:31:07 <kmc> i probably spoke too soon
16:31:15 <kmc> but i think by accumulating function composition like Gracenotes suggested
16:31:30 <mmorrow> @pl main = print (( (\f->(\x->f((u x)x))(R(\x->f((u x)x))))  ((\o->(\q->(\r->(\t->(\b->((\f->(\s->(\i->(\g->(\n->i (f n) o (i (s n) o (t (g (b n)) (g (b (b n))))))))))  (\x->q x (b o)) (\x->q x o) (\c->(\t->(\e->if c then t else e))))) (\x->r x o))))) 1 (==) (-) (+) )) 10)
16:31:41 <FunctorSalad_> haha
16:31:43 <mmorrow> i wonder if its going to asplode
16:31:49 * copumpkin can hear it churning
16:31:57 <mmorrow> @bot
16:31:57 <lunabot>  :o
16:32:02 <mmorrow> ruhroh
16:32:06 <kmc> get down
16:32:43 <tehgeekmeister> poor lambdabot.
16:32:52 <mmorrow> lambdabot needs rlimits on plugins!
16:32:54 <Gracenotes> davidL: would it be unethical if I showed you my solution?
16:33:05 <mmorrow> , [$pl| main = print (( (\f->(\x->f((u x)x))(R(\x->f((u x)x))))  ((\o->(\q->(\r->(\t->(\b->((\f->(\s->(\i->(\g->(\n->i (f n) o (i (s n) o (t (g (b n)) (g (b (b n))))))))))  (\x->q x (b o)) (\x->q x o) (\c->(\t->(\e->if c then t else e))))) (\x->r x o))))) 1 (==) (-) (+) )) 10) |]
16:33:11 <lunabot>  Killed.
16:33:15 <FunctorSalad_> who knows what the complexity of @pl is
16:33:20 <FunctorSalad_> maybe it uses bogosort or something
16:33:22 <defun> is anyone here a physicist?
16:33:30 <copumpkin> defun: I enjoy physiques
16:33:31 <Gwern-away> mmorrow: problem is, rlimits break on many people's machines
16:33:34 <Gwern-away> I had to turn them off
16:33:53 <mmorrow> Gwern-away: and runaway plugins brake the botz!
16:33:57 <davidL> Gracenotes: well the homework is actually asking us to write a different function tail recursively...but without the aid of any library functions, so I assume I can't use ocaml's equivalent of (++)
16:34:24 <defun> copumpkin: could it be said that (acceleration * time) is equivalent to the change in velocity?
16:34:36 <Gracenotes> well, it probably means in one sweep, not multiple ones (using auxiliary functions)
16:34:37 <copumpkin> defun: what are the units? :)
16:34:47 <Gracenotes> but if you feel it's necessary, the basic idea is..
16:34:50 <mmorrow> Gwern-away: seriously though, i think the solution is to use a C function for the process forking, and put the rlimit setting in the switch case of the child
16:34:50 <Gracenotes> , let a ++ b = foldl (\acc x -> acc . (x:)) id a b in [1,2]++[3,4]
16:34:52 <lunabot>  [1,2,3,4]
16:35:22 <defun> doesn't say... I assume they are standard metric (i.e m/s, m/s^2, etc)
16:35:22 <davidL> Gracenotes: yeah :(
16:35:25 <mmorrow> gwern: which is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3530#a3531
16:35:37 <mmorrow> gwern: that should completely solve the problem i believe
16:35:49 <mmorrow> gwern: it just needs a haskell module wrapper
16:36:11 <defun> This deals with constant acceleration, btw.
16:36:16 <lambdabot> Plugin `pl' failed with: thread killed
16:36:28 <Gracenotes> I would @pl \acc x -> acc . (x:), but... eh... looks like both lambdabot and I are too lazy for it
16:36:38 <mmorrow> gwern: iirc the haskell rlimits lib had a bug(s), but i think they got fixed?
16:36:42 <Gracenotes> or maybe not
16:36:45 <Gracenotes> @pl \acc x -> acc . (x:)
16:36:45 <lambdabot> (. (:)) . (.)
16:36:47 <BMeph> davidL: a dt = dv; so, yes. :)
16:36:51 <copumpkin> defun: I mean, reason about your question in terms of the units
16:36:55 <kmc> haha
16:36:57 <Gwern-away> mmorrow: they did?
16:37:01 <Gwern-away> first I heard
16:37:13 <davidL> BMeph: I think you mean defun :)
16:37:15 <BMeph> Er, *defun, I mean. :S
16:37:32 <BMeph> defun: a dt = dv; so, yes. :)
16:37:39 <mmorrow> Gwern-away: i recall stracing and them doing something weird, mauke may remember. anyhow, they work now (this was 6.8 i think)
16:37:41 <defun> copumpkin,BMeph: thanks.
16:37:47 <Gracenotes> mrowl
16:38:04 <Nereid_> why is darcs so slow :(
16:38:07 <mmorrow> Gwern-away: i don't see how they couldn't work (unless the haskell wrapper was botching it)
16:38:27 <davidL> Gracenotes: thanks, that's what I expected, maybe I am misinterpreting the "use no library functions" aspect of the question
16:38:31 <Gwern-away> Nereid_: because you touch yourself at night
16:38:34 <Gwern-away> mmorrow: well, they were crashing when invoked
16:38:36 <Gwern-away> or something, I dunno this was like a year or 2 ago!
16:38:37 <mmorrow> lunabot uses them
16:38:41 <Nereid_> and that was uncalled for
16:38:45 <Gwern-away> LOTS OF THINGS HAVE HAPPENED SINCE I CANNOT REMEMBER EVERYTHING
16:38:55 <burp> @src null
16:38:55 <lambdabot> null []     = True
16:38:55 <lambdabot> null (_:_)  = False
16:38:55 <mmorrow> @djinn
16:38:55 <lambdabot> Cannot parse command
16:39:05 <Gracenotes> Gwern-away: but you'rve remembered all those things, right?
16:39:29 <Nereid_> @djinn a -> b
16:39:29 <lambdabot> -- f cannot be realized.
16:39:30 <Gwern-away> Gracenotes: I remember I do not remember them!
16:39:37 <mmorrow> @djinn-add type J b a = (a -> b) -> a
16:39:39 <tehgeekmeister> i'm aware this is horribly vague, so feel free to help me phrase it better if you can.  i'm trying to figure out why my code isn't lazy enough, by which i mean, while i write a sequence of separate functions which are composed or applied to each other, each of which is written to act on a whole list/set/whatever, i expect the processing to be done on each, all the way thru the chain of separate functions.  but this isn't
16:39:39 <tehgeekmeister> happening, and i want to start to figure out WHY it isn't happening.  how do i go about that?  is there some useful blog post or whatnot to get me started into understanding laziness better in this respect?
16:39:43 <mmorrow> @djinn-env
16:39:43 <lambdabot> data () = ()
16:39:43 <lambdabot> data Either a b = Left a | Right b
16:39:43 <lambdabot> data Maybe a = Nothing | Just a
16:39:43 <lambdabot> data Bool = False | True
16:39:43 <lambdabot> data Void
16:39:45 <lambdabot> type Not x = x -> Void
16:39:47 <lambdabot> type J b a = (a -> b) -> a
16:39:49 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
16:39:51 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:39:55 <mmorrow> hrm, wonder why that doesn't work in /msg
16:40:07 <Gwern-away> Gracenotes: there are knowns knowns; the things we know we know; and then there are the known unknowns, the things we know we do not know. but there are also the unknown unknowns, the things we don't know we don't know
16:40:08 <mmorrow> n/m it does now
16:40:14 <Nereid_> @djinn J b a
16:40:14 <lambdabot> Cannot parse command
16:40:14 <lambdabot> -- f cannot be realized.
16:40:35 <aavogt> Gwern-away: you forgot the unknown knowns
16:40:43 <aavogt> ;)
16:40:58 <Gwern-away> aavogt: rumsfeld didn't talk about those, so my parody couldn't include them
16:41:03 <mmorrow> @djinn J (J b (J a b)) (J (J (J b (J a b)))) -> J a ((J (J (J b (J a b)))) b)
16:41:04 <lambdabot> Cannot parse command
16:41:04 <lambdabot> Error: kind error: (KVar 11,KStar)
16:41:11 <Gwern-away> although they make up the last of the permutations, yes
16:41:49 <BMeph> tehgeekmeister: Are you sure you mean "isn't lazy enough"? It sounds more as if you're expecting it to be strict. :)
16:42:04 <Nereid_> @djinn J a b -> J b a
16:42:04 <lambdabot> Cannot parse command
16:42:04 <lambdabot> -- f cannot be realized.
16:42:06 <Nereid_> whee
16:43:11 <mmorrow> @djinn J (J b (J a b)) a -> J a (J (J (J (J b a) a) (J b a)) (J (J b a) a))
16:43:19 <Gracenotes> Gwern-away: are you quoting TV tropes now
16:43:26 <lambdabot> No output from Djinn; installed?
16:43:35 <mmorrow> runaway-djinn-instances++
16:43:38 <tehgeekmeister> BMeph: oops, i didn't include one vital bit: i'm printing the entire output, so it's strict in that respect.
16:43:53 <mmorrow> @. pl djinn J (J b (J a b)) a -> J a (J (J (J (J b a) a) (J b a)) (J (J b a) a))
16:43:55 <tehgeekmeister> BMeph: but i want it to be lazy as in processing each item all the way thru one at a time, rather than in batch at each step
16:44:00 <mmorrow> rlimits ftw!
16:44:08 <lambdabot> (line 1, column 21):
16:44:08 <lambdabot> unexpected ";"
16:44:08 <lambdabot> expecting variable, "(", operator or end of input
16:44:21 <Gwern-away> Gracenotes: you know me, I am far too erudite to quote tropes
16:44:39 <Gwern-away> I quote the originals
16:44:54 <Gracenotes> Gwern-away: you may scoff, but the quote has been adapted for the use of explaining the trope "Didn't See That Coming" http://tvtropes.org/pmwiki/pmwiki.php/Main/Ptitle7xno8ayw
16:44:55 <lambdabot> Title: Didn't See That Coming - Television Tropes & Idioms
16:45:24 <Gracenotes> and, aavogt, it does note that "unknown knowns" is a bit of an oddball
16:45:28 * mmorrow wonders what % cpu those two djinns are using..
16:45:39 * Gwern-away scoffs at those tropers
16:46:18 <BMeph> tehgeekmeister: But you're asking for the whole thing, so why should it do the whole thing, one bit at a time? :)
16:46:44 <tehgeekmeister> BMeph: i have to wait to see output that way!
16:48:05 <BMeph> tehgeekmeister: ...so, have you tried take'ing selected numbers of your list, and printing those? :)
16:48:20 <Gwern-away> Gracenotes: I do like how tropes agrees with me that the ending of hellsing was stupid, tho
16:48:58 <tehgeekmeister> BMeph: unfortunately i don't have anything so simple as a list, but rather an algorithm that runs in the state monad running inside yet another algorithm running in the state monad
16:49:00 <tehgeekmeister> =/
16:49:15 <tehgeekmeister> and it can take 10-15 minutes to run, easily
16:49:20 <Gracenotes> the anime? yeah, I even complained about that to you
16:49:35 <Gwern-away> Gracenotes: no no the manga
16:49:46 <Gracenotes> I thought the anime was pretty good otherwise though, even the weird post-modernist episode. ooh... manga. yeah, don't know too much about that.
16:50:50 <mmorrow> ummmm. that awesome.hs seems to loop my ghc-6.10.1 with -O2
16:51:08 <mmorrow> but it loads fine in ghci
16:51:14 <tehgeekmeister> weird
16:51:55 <mmorrow> it loops with any level of optim, with ghc --make
16:52:21 <mmorrow> a month old HEAD also loops..
16:53:53 <mmorrow> is it looping for anyone else?
16:54:19 <tehgeekmeister> haven't even tried running it, and i've got 6.8 something, anyway
16:54:36 <tehgeekmeister> wait, apparently i upgraded without knowing it
16:54:44 <tehgeekmeister> don't know how that happened
17:06:43 <Gwern-away> tehgeekmeister: perhaps you sleep-hack
17:07:02 <tehgeekmeister> Gwern-away: that, or the fact that i've not used haskell in months
17:07:12 <tehgeekmeister> i probably just forgot that i was using that version when i stopped
17:07:35 <tehgeekmeister> i really should stop straying from haskell; i love it so.  and getting used to it again is such a waste of time.
17:07:51 <kmc> especially because it moves so fast
17:08:04 <tehgeekmeister> well, i'm never at all up to date with the latest
17:08:09 <tehgeekmeister> so that's not such an issue
17:08:25 <tehgeekmeister> it's more that if you stop thinking functionally for a few months, you have to relearn a lot of it
17:09:02 <kmc> tehgeekmeister, i think FP is pervasive enough that you end up using the ideas in any language
17:09:23 <tehgeekmeister> you CAN, doesn't mean you necessarily do
17:09:29 <kmc> i did a python project which was very OO and also very functional, which made me realize that the supposed opposition of these concepts is bullshit
17:09:34 <tehgeekmeister> and beyond that, when i've left haskell for months, i've often left programming as a whole for months
17:09:40 <kmc> fair enough
17:09:47 <kmc> can't say the same because it's the only thing i'm really good at :)
17:10:16 <tehgeekmeister> i'm not good enough to get a job with it, nor do i have any credentials, otherwise i'd be glad to do it all the time
17:10:34 <kmc> if you are really good you don't need credentials
17:10:36 <kmc> more so than most fields
17:11:11 <tehgeekmeister> unfortunately, i'm not that good
17:11:17 <tehgeekmeister> mostly as a result of not having enough practice
17:11:28 <tehgeekmeister> it's a nice catch-22
17:12:07 <dolio> If you talk to dibblego, he'll tell you that he got to functional programming by doing OO programming, and realizing that things got better the less implicit state/mutation he used.
17:12:26 <dolio> So it's not unsurprising that you can describe something as both OO and functional.
17:13:21 <dolio> Some folks back in the day were trying to implement the actor model (which many people will probably tell you is idealized OO), and came up with Scheme.
17:23:19 <kmc> dolio, yes, immutable objects are great
17:23:40 <kmc> i know it's controversial to suggest that C++ is not a total pile of shit, but it does support immutability fairly well
17:23:58 * mauke const_casts kmc 
17:24:20 <kmc> oh snap
17:24:24 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9348#a9348
17:24:35 <dolio> C++ has several nice/interesting features in its pile of shit.
17:24:36 <Veinor> Why isn't this working? I have a Hid3.hs in the same directory with a getTitle function.
17:24:53 <coreyoconnor> True!
17:25:08 <kmc> Veinor, what error?
17:25:28 <Veinor> I'm running ghc hid3test.hs and getting
17:25:32 <Veinor> (.data+0x54): undefined reference to `Hid3_getTitle_closure'
17:25:42 <Veinor> along with the other attendant errors
17:25:53 <mauke> I'd try ghc --make first
17:26:28 <Veinor> That worked.
17:28:01 <coreyoconnor> That said, I'm done with C++. I suspect Haskell + extensions will cover all my development requirements in the near future.
17:28:04 <Veinor> That reminds me I need to get back to work on my haskell ID3 library.
17:28:13 <Veinor> Right now it succeeds quickly, but fails slowly.
17:28:35 <Veinor> Cause it looks throughout the entire file for the MP3 tag, cause I can't figure out how the length bit of the ID3 header works. :/
17:29:11 <kmc> coreyoconnor, at work i use C++ in a role haskell is still very much unsuited for -- and i'd love to see it move into that role as well
17:29:27 <coreyoconnor> What role is that?
17:30:04 <coreyoconnor> My experience at work, where I used to code only in C++ that the application of Haskell + extensions was limited by library support. Not some inherit feature of the language.
17:30:16 <kmc> low latency network protocol conversion
17:30:31 <coreyoconnor> err. Not by some inherit feature of the languae
17:31:19 <coreyoconnor> What aspect of haskell prevents use in this domain? Latency caused by memory allocation / garbage collection?
17:32:20 <kmc> that's the biggest one
17:33:05 <coreyoconnor> To me memory allocation is always more costly in haskell compared to some C/C++ code I've written. Allocating on the stack is cheap. I want to be able to tune my code to only use stack allocation.
17:33:12 <coreyoconnor> ah ok. Yea.
17:33:15 <Peaker> memory allocation is O(1) and very cheap, afaik. Only GC itself may cause some latency
17:33:18 <kmc> i don't know how long GC typically takes
17:33:29 <kmc> was trying a bit to find stats on that for real-world workloads
17:33:37 <coreyoconnor> The problem with low latency stuff is that big O notation is not sufficient
17:33:40 <Peaker> coreyoconnor: I think heap allocation in generational GC is as cheap as stack allocation - its the freeing that's more expensive
17:33:51 <kmc> coreyoconnor, indeed, it's a totally different measure
17:33:57 <coreyoconnor> those little constants
17:34:02 <Peaker> coreyoconnor: well, its basically moving a pointer and returning it, like a stack allocation
17:34:12 <Peaker> coreyoconnor: so there's no monster hiding behind that O(1)
17:34:24 <coreyoconnor> Except for the freeing
17:34:39 <Peaker> coreyoconnor: yeah, that's why I said its the GC part, not the allocation part, that's adding latency
17:35:06 <coreyoconnor> I'm not convinced allocation in the heap is always as cheap as stack allocation
17:35:07 <Peaker> though ghc is quite successful at eliminating a lot of allocations altogether
17:35:20 <Peaker> coreyoconnor: do you mean including or excluding freeing?
17:35:26 <kmc> i think it'd be much more feasible to write that kind of code in Strict Haskell
17:35:28 <coreyoconnor> excluding the freeing
17:35:34 <Peaker> coreyoconnor: why not?
17:35:42 <kmc> and i don't see laziness as a core part of why haskell is cool and useful tbh
17:35:55 <coreyoconnor> GHC is very good, but it's still something of a black art figuring out how to eliminate allocations
17:36:06 <Peaker> kmc: Did you read "Why Functional Programming Matters"?
17:36:25 <coreyoconnor> and for the life of me I still run into code that appears to allocate a thunk for a let binding unnecessarially
17:36:41 <coreyoconnor> Peaker: I can't argue against you cause I don't know enough about how memory allocators work :-)
17:36:43 <kmc> Peaker, some of it
17:36:46 <coreyoconnor> Well, not modern ones hehe
17:37:06 <coreyoconnor> I remember how the ones I was taught in Operating Systems 101 (or equiv) worked
17:37:06 <Peaker> kmc: Laziness allows for more modularity, which is the key to software success :)
17:37:15 <coreyoconnor> Oh how I love laziness
17:37:32 <Peaker> kmc: they use some nice examples such as separating the generation of a game tree from its pruning
17:37:50 <kmc> sure but i'd still rather program in strict haskell than most languages
17:38:06 <kmc> (especially since any language with higher-order functions can be made lazy-by-choice)
17:38:09 <coreyoconnor> I love being able to bind an expensive computation to a name. Providing that to an equation in a type class. Then knowing the instance will only incur the computation cost if it needs the value from the binding.
17:38:37 <Peaker> kmc: well, I personally think performance should be a secondary concern. When its primary, you do have strictness annotations
17:38:48 <kmc> i agree in the general case
17:39:24 <kmc> i was talking about why i can't use haskell for a particular performance-critical role, and how it might change to accommodate that as well
17:39:35 <mmorrow> coreyoconnor: "main = print (length [0..100000000])" allocates 8 GB in the heap over its lifetime
17:40:10 <kmc> specifically, laziness -> lots of allocation of thunks -> GC required
17:40:10 <mmorrow> (lifetime being 4.03 seconds with -O2 on my machine)
17:40:24 <coreyoconnor> Do you mean it allocates 8 gb at once?
17:40:27 <mmorrow> 2 GB/second!
17:40:30 <coreyoconnor> haha
17:40:31 <coreyoconnor> yea
17:40:37 <coreyoconnor> I hate that stuff. Memory churn hurts
17:40:47 <mmorrow> the gc ran 15318 times
17:40:54 <mmorrow> for generation 0
17:40:57 <coreyoconnor> hahaha owww
17:40:57 <mmorrow> and once for generation 1
17:41:02 <kmc> mmorrow, how much time spent in GC?
17:41:09 <mmorrow> 0.10 seconds
17:41:20 <tehgeekmeister> that is fast gc!
17:41:36 <kmc> that's true
17:41:41 * mmorrow did  ghc -O2 --make o.hs && ./o +RTS -sstderr -RTS
17:41:54 <kmc> a 7 us GC hit *might* be tolerable for what we do, if it's infrequent
17:41:54 <coreyoconnor> When optimizing Vty I spent a while just reducing memory churn. Gained quite a lot of performance in the end.
17:42:11 <coreyoconnor> course then I rewrote the entire backend and had to ditch all those optimizations... ah well!
17:42:39 <mmorrow> (and "1 MB total memory in use (0 MB lost due to fragmentation)")
17:42:40 <tehgeekmeister> i think the .1 seconds is a low price to pay for not having to deal with all the low end details, myself.
17:43:03 <mmorrow> if you want C it's just a single "foreign import ccall unsafe ..." away
17:43:03 <sauf> hi, I need to improve my style
17:43:04 <kmc> tehgeekmeister, it really depends on what you're doing
17:43:08 <sauf> do you know an elegant way to obtain [[1,1,1],[2,2],[3]] from [[1],[1,2],[1,2,3]] (using head, I guess) ?
17:43:12 <copumpkin> unsafe?
17:43:21 <kmc> unsafe => can't call back into haskell
17:43:22 <kmc> i think?
17:43:24 <copumpkin> I find the ffi safety markings rather unintuitive and maybe backward
17:43:36 <copumpkin> I think it's the opposite
17:43:38 <tehgeekmeister> kmc: if that's .1 seconds inside your most critical inner loop, perhaps it's not, but in general, it's not a big deal.
17:43:42 <kmc> sauf, i don't get what you want to do
17:43:47 <mmorrow> copumpkin: safe makes the rts assume that the function'll re-enter the rts
17:43:52 <coreyoconnor> You can call back into Haskell.
17:44:00 <coreyoconnor> If the FFI import is marked "unsafe" then you can't
17:44:05 <mmorrow> so it has to lock stuff and stuff
17:44:07 <copumpkin> mmorrow: ah okay, I still think it's rather unintuitive
17:44:30 <kmc> > transpose [[1],[1,2],[1,2,3]]
17:44:31 <sauf> i want to use head, init and that sort of things
17:44:31 <lambdabot>   [[1,1,1],[2,2],[3]]
17:44:45 <mmorrow> yeah, it's annoying that the default is "safe" if you omit the safety annotation
17:44:46 <kmc> sauf, head and init are partial functions and therefore evil
17:44:53 <sauf> i'm confused ,thanks !
17:44:59 <kmc> especially head can usually be replaced with a pattern match
17:45:10 <kmc> mmorrow, isn't haskell safe by default?
17:45:34 <mmorrow> kmc: but in this context, safe is a different safe than unsafeCobra
17:45:49 <copumpkin> unsafeCobra :o
17:45:49 <kmc> but conceptually it's still an unchecked precondition
17:46:15 <kmc> tehgeekmeister, there are applications that are more latency sensitive than throughput sensitive, where a GC pause will be ruinous even if it's occasional and not associated with some inner loop
17:46:17 <mmorrow> @type Foreign.unsafePerformIO
17:46:18 <lambdabot> forall a. IO a -> a
17:46:42 <copumpkin> I still think it would be amusing to make IO and ST instances of Copointed
17:46:44 <mmorrow> kmc: yeah, i hear you. i still think it's annoying though ;)
17:46:53 <tehgeekmeister> kmc: that makes sense, but i've never personally had to code for one of those, so i've never thot of that.
17:47:01 <kmc> wtf is a Copointed
17:47:10 <copumpkin> @hoogle copointed
17:47:10 <lambdabot> No results found
17:47:16 <copumpkin> @hackage category-extras
17:47:17 <lambdabot> http://hackage.haskell.org/package/category-extras
17:47:39 <aavogt> ?hoogle coreturn
17:47:39 <lambdabot> No results found
17:47:41 <copumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Pointed.html
17:47:41 <lambdabot> Title: Control.Functor.Pointed, http://tinyurl.com/olr3tf
17:47:57 <copumpkin> kmc: Pointed is the missing typeclass between Functor and Applicative
17:48:03 <ray> copoint :; f a -> a
17:48:05 <copumpkin> kmc: Copointed is pure backwards
17:48:09 <kmc> i see
17:48:28 <ray> in theory, instance Copointed IO where copoint = unsafePerformIO
17:48:32 <ray> but who would be crazy enough to write that
17:48:34 <kmc> hehe
17:48:52 <copumpkin> ray: me!!!
17:49:30 <ray> what's next, instance Comonad IO where cojoin = return?
17:49:40 <kmc> are there pointed/copointed laws?
17:49:55 <copumpkin> ray: not sure that would work
17:50:19 <dolio> fmap f (point x) = point (f x)
17:50:49 <dolio> copoint (fmap f fx) = f (copoint f x)
17:50:54 <ray> IO a -> IO (IO a)
17:51:01 <dolio> copoint fx even.
17:51:42 <ray> :t return getLine
17:51:43 <lambdabot> forall (m :: * -> *). (Monad m) => m (IO String)
17:51:50 <dolio> (co)point is supposed to be natural.
17:52:05 <dolio> point : I => F, copoint : F => I
17:52:10 <kmc> dolio, is there a simple explanation of what natural transformations are in haskelly terms?
17:52:30 <copumpkin> homomorphism homomorphisms!
17:52:47 <dolio> kmc: It's supposed to commute with map.
17:52:48 <Veinor> sup dawg, we put a homomorphism in yo homomorphism
17:52:48 <BMeph> homomorphic homomorphisms. :)
17:53:18 <copumpkin> dolio was not amused by the yo dawg :(
17:53:30 <kmc> haha
17:54:15 <BMeph> ...so you can string diagram while you string diagram? ;p
17:54:25 <dolio> Did that last line get through? Natural f g = forall x. f x -> g x?
17:54:27 <kmc> where map = fmap, the thing that takes Hask morphisms to your functor's morphisms?
17:54:46 <Peaker> @type (>>= return . return)
17:54:47 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m a -> m (m1 a)
17:55:24 <ray> to your category's morphisms even
17:55:32 * copumpkin wrote an awesome natural transformation once
17:55:36 <kmc> err right
17:55:49 <kmc> the functor is the fmap + the map on objects, which is just a tycon in haskell
17:55:51 <kmc> right?
17:56:01 <Woof> Cale?
17:56:04 <ray> yeah
17:56:15 <kmc> can we talk about functors which aren't tycons, using type synonym families?
17:56:41 <tommd> Are there any Haskellers hacking on a beagleboard or BB derivative?  Yes, I am aware of the iphone effort (which seems to have gone silent for the past month)!
17:56:49 <Cale> Woof: hello
17:57:05 <Woof> Hello, Cale!
17:57:09 <Cale> Hello!
17:57:20 <Woof> Cale, lambdabot no longer comes to #learnanycomputerlanguage  :
17:57:23 * Meow glares at Woof
17:57:23 <Woof> : (*
17:57:43 <Woof> And, incidentally, nor to #functionaljava
17:57:45 <Cale> Woof: Ah, I lost the join list. I'll add it.
17:57:50 <tommd> @slap lambdabot
17:57:50 * lambdabot clobbers lambdabot with an untyped language
17:57:54 <Cale> lambdabot: @join #learnanycomputerlanguage
17:57:59 <Woof> Aha. Danke schön, Cale
17:58:13 <ray> ring homomorphisms map ring elements all the time and they don't even think twice about it
17:58:58 <Peaker> btw: About the GC timings above (measured to about 2.5% runtime): don't compare them to 0, allocations/freeing on the stack also cost some.  Though what worries me most is not the percentage of time GC takes, but the fact it amortizes that percentage into small pauses
17:59:19 <kmc> Peaker, but there is much less allocation total in a strict language
17:59:30 <kmc> (or with extensive strictness annotations, i'll bet)
18:00:11 <kmc> tommd, what OS for the beagleboard?
18:00:40 <kmc> http://hackage.haskell.org/trac/ghc/wiki/ArmLinuxGhc
18:00:42 <lambdabot> Title: ArmLinuxGhc - GHC - Trac
18:03:13 <Parkotron> If I want to take a list and produce a Map from it where the keys are list elements and the values are the number of times they occur, is there a better way than this: http://pastebin.ca/1564833
18:04:55 <Meow> > M.fromListWith (+) . zip (repeat 1) $ [1..5] ++ [2..5]
18:04:56 <lambdabot>   fromList [(1,29)]
18:04:59 <Meow> whoops
18:05:05 <Meow> > M.fromListWith (+) . flip zip (repeat 1) $ [1..5] ++ [2..5]
18:05:06 <lambdabot>   fromList [(1,1),(2,2),(3,2),(4,2),(5,2)]
18:05:26 <kmc> @src foldr
18:05:26 <lambdabot> foldr f z []     = z
18:05:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:05:28 <jfredett> So, I'm working with some Template haskell, and I'm trying to use it to generate some datatypes for HWN stuff. Now, I wrote the generation code and it works okay, except when I try to splice it, I get the following error:
18:05:28 <lambdabot> jfredett: You have 1 new message. '/msg lambdabot @messages' to read it.
18:05:28 <Meow> Parkotron: basically what you wrote, but this is a little simpler
18:05:38 <tommd> kmc: In the end I'd like to make something custom - but linux for now.
18:05:58 * Parkotron goes to read up on flip and repeat.
18:05:59 <jfredett> "GHC Stage Restriction: `headers' is used as a top-level splice, and must be imported, not defined locally"
18:06:13 <copumpkin> > flip (-) 5 6 -- Parkotron
18:06:14 <lambdabot>   1
18:06:15 <tommd> kmc: That page is frightfully out of date.
18:06:16 <jfredett> however, I'm not sure exactly what I'm supposed to do.
18:06:22 <copumpkin> > repeat 1 -- Parkotron
18:06:23 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:06:34 <tommd> kmc: I'd hope to get a registered ARM build supported in HEAD.
18:06:46 <jfredett> I've tried putting it in numerous places, the original source file, an alternate file, everywhere.
18:06:47 <kmc> Parkotron, what you've written is a left-fold
18:06:51 <jfredett> anyone with some insight? :)
18:07:03 <ray> > getZipList $ pure 1
18:07:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:08:17 <Woof> Oh yeah, ray, here's an interesting question for you: Don't tell me the answer though - Is it possible that a group G is isomorphic to a subgroup H' of a group G', AND the group G' is isomorphic to a subgroup H of G, BUT G is not isomorphic to G'?
18:08:39 <byorgey> jfredett: you just have to define the splice in a different module than the one in which you use it.
18:09:16 <jfredett> byorgey: right, I kindof understood that, but -- oh wait. I think I know what the problem is. hang on.
18:09:29 <jfredett> byorgey: actually- why is that? :/
18:09:30 <Guest88318> 85.14.80.241 no pass no login
18:11:57 <jfredett> aah, I understand now- I was defining a Separate string to use to list the enumerations, and I can't do that either.
18:12:02 <ray> woof: :)
18:12:04 <jfredett> only literals allowed.
18:13:56 <jfredett> hmm, another TH question, is there any way to read these things from a file? Eg, have some file named "headers.hwn" and then parse it and use it as the argument to the splice?
18:14:25 <philvarner> Anyone have suggestions/examples of when to use $ instead of ( )?
18:14:35 <kmc> philvarner, you mean in function applications?
18:14:37 <BMeph> Woof: Why would you thing that's interesting? :)
18:14:54 <philvarner> kmc, yes
18:14:55 <kmc> i tend to prefer "f $ g $ h x" to "f (g (h x))"
18:15:15 <kmc> it's more readable, and emphasizes that there's a linear pipeline of functions
18:15:30 <jfredett> philvarner: when I have a chain of functions I'm applying, I like to use the f . g . h $ arg syntax, rather than f(g(h(arg))) or f $ g $ h arg.
18:15:40 <Veinor> Does anybody in here have experience with doing ID3 tag stuff?
18:15:40 <kmc> strictly speaking the alternatives are "$" and " "
18:15:45 <jfredett> it's nice to mentally separate the arguments from the function chain.
18:15:46 <Guest88318> 85.14.80.241 no pass no login can u digg it?
18:15:50 <kmc> parens don't do anything special for application, like they do in scheme
18:17:15 <philvarner> i'm thinking more for readability
18:17:51 <BMeph> philvarner: For readability, I'd prefer " " over either of the others. ;)
18:17:57 <SamB> kmc: well, you have to admit there are times when you must use at least one or the other
18:18:05 <philvarner> jfredett, is it important to distinguish between functions and args?
18:18:28 <ivanm> jfredett: no problems ;-)
18:18:40 <SamB> jfredett: I like to do that because I disapprove of the present fixity of $ and $! ;-P
18:19:17 <jfredett> philvarner: well, I like to know what I'm passing as arguments, and what is part of the function chain.
18:19:19 <SamB> and then theres the subexpression argument ...
18:19:35 <Woof> BMeph: : þ
18:19:58 <jfredett> I mean, it's nice to keep things separate when you're doing something like: (+1) . (*2) . (/3) $ 4
18:20:05 <jfredett> which, if my internal GHCI is working properly
18:20:15 <jfredett> > (+1) . (*2) . (/3) $ 4
18:20:16 <lambdabot>   3.6666666666666665
18:20:18 <jfredett> should be good haskell.
18:20:22 <Veinor> how do I do fast file IO in Haskell?
18:20:27 <jfredett> oh yah...
18:20:38 <kmc> Veinor, Data.ByteString
18:21:06 <SamB> ... and now, the unsafeInterleaveIO flamefest!
18:21:15 <SamB> </ringmaster>
18:21:21 <kmc> it's like sausages?
18:21:49 <SamB> kmc: you can't eat just one ?
18:21:59 <monochrom> oktoberflamefest!
18:22:09 <kmc> monochrom, thank you, you reminded me that i have beer
18:22:33 <Veinor> kmc: The point is that right now i have a problem where I need to quickly determine whether a certain string is present in a 3MB file
18:22:57 <kmc> Veinor, did you try the naive solution first?
18:22:57 <SamB> Veinor: grep ;-P ?
18:23:00 <monochrom> do { b <- unsafeInterleaveIO beer; grill sausage `withDrink` b }
18:23:38 <jfredett> Veinor: cat file | grep "yada" :)
18:23:49 <Veinor> yeah, but this is a Haskell library
18:23:57 <Veinor> I don't want to have to call out to the system for that :P
18:23:57 <ivanm> monochrom: so you're having a BBQ?
18:24:09 <monochrom> No. I'm just saying.
18:24:31 <ivanm> heh
18:24:32 <SamB> Veinor: well, that's why I used a P
18:24:50 <Veinor> Yes, yes I know :P
18:24:55 <Veinor> Anyway
18:25:05 <Veinor> Will using Data.ByteString make this actually, y'know, fail fast?
18:25:26 <SamB> Veinor: failing isn't what you can do fast, for this problem
18:25:36 <Parkotron> kmc: So is this the correct folded form "foldl (\m x -> M.insertWith (+) x 1 m) M.empty xs"?
18:25:36 <Veinor> SamB: Well will it fail faster than 2 seconds?
18:25:48 <SamB> oh, probably ;-)
18:25:51 <Parkotron> kmc: Thanks for your help today, by the way.
18:26:29 <kmc> Parkotron, i think so.  does it typecheck? ;)
18:26:54 <Parkotron> kmc: It works. :)
18:26:57 <kmc> cool
18:27:46 <Veinor> @hoogle Data.Bytestring
18:27:46 <lambdabot> module Data.ByteString
18:27:46 <lambdabot> Data.ByteString data ByteString
18:27:46 <lambdabot> Data.ByteString.Char8 data ByteString
18:29:41 <Parkotron> kmc: Of course, it's kind of all beside the point. I was writing a program to calculate the LCM of a list of numbers. I did it up very fancy with prime factorisation, combined maps of prime factor counts, etc. But I just now stumbled upon the docs for "lcm".
18:29:43 <Parkotron> Sigh.
18:29:53 <Parkotron> Oh well, I still learned something.
18:30:01 <kmc> :)
18:30:30 <aavogt> @src lcm
18:30:30 <lambdabot> lcm _ 0     =  0
18:30:30 <lambdabot> lcm 0 _     =  0
18:30:30 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
18:30:49 <aavogt> @src gcd
18:30:50 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
18:30:50 <lambdabot> gcd x y = gcd' (abs x) (abs y)
18:30:50 <lambdabot>    where gcd' a 0  =  a
18:30:50 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
18:32:54 <Parkotron> aavogt: Of course after finding "lcm" I looked up its implementation. It's way more efficient than mine, but mine is the way I learned in grade school, so it must be better. ;)
18:33:56 <nainaide> A question about CGI,  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9351#a9351 , thanks for any help.
18:34:07 <philvarner> In the Prelude doc, map ($ 0) xs is given as an example for HO use of $ -- xs is a list of functions in this case, right?
18:35:34 <kmc> yeah
18:35:42 <kmc> :t \xs -> map ($ 0) xs
18:35:43 <lambdabot> forall a b. (Num a) => [a -> b] -> [b]
18:36:38 <dolio> :t flip (<*>) . pure
18:36:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => a -> f (a -> b) -> f b
18:36:56 <blackh1> nainaide: I don't quite understand your question.
18:38:24 <philvarner> is the good example of the usefulness of that?
18:39:46 <nainaide> blackh1, thanks for your response. I think in general Html, there should be a html in advance, then the client can input, then cgi can get it.
18:40:01 <jmcarthur> :t (<**>) . pure
18:40:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => a -> f (a -> b) -> f b
18:40:23 <nainaide> but if just a line do  mn <- getInput "name" , should nothing happened
18:41:20 <blackh1> nainaide: I still don't quite get you. Can you re-phrase the question again?
18:42:27 <Veinor> http://pastebin.com/m6f6f94b1
18:42:30 <Veinor> What does this error mean?
18:43:17 <nainaide> blackh1,  I mean the inputForm "should" show before the getInput. but It seems in cgiMain do block, it doesn't
18:44:01 <nainaide> so how can do mn <- getInput "name" work?
18:44:05 <blackh1> Veinor: mp3 is type [a], but the indexOf function wanted a [Char]
18:44:25 <tehgeekmeister> oh!  i just realized why my code isn't as lazy as i wanted.  i'm using a strict data type.
18:44:29 <Veinor> So then how come it can't let a be Char ?
18:45:21 <blackh1> Veinor: You need to put 'Char' type in the signature for getTag... or use a more general implementation of indexOf
18:45:28 <tehgeekmeister> sequences are strict, correct?
18:45:35 <Veinor> All IndexOf requires is that its types are Eq
18:45:39 <Veinor> Which Chars are
18:45:49 <Veinor> indexOf :: (Eq a) => [a] -> [a] -> Maybe Int
18:46:25 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9352#a9352
18:46:36 <Veinor> Ignore the comment on --getTag :P
18:47:01 <blackh1> Veinor: Oh!  Hmmm....
18:47:26 <Veinor> Yeah.
18:47:52 <nainaide> In do block, if I say:  do mn <- getInput "name"  , does it mean haskell will getInput immediately or jusr bind mn to "name", and will do it if required?
18:48:32 <blackh1> nainaide: It doesn't mean it will do the actual work immediately.
18:48:34 <kmc> the latter
18:48:47 <kmc> it means that it will occur in the proper order with respect to the other stuff in that do block
18:48:59 <monochrom> Depends on which monad. Which monad is it?
18:49:27 <nainaide> blackh1, great, now I understand the cgi code. "do"  just means order, doesn 'tit?
18:49:33 <blackh1> Veinor: Your second paste doesn't give an error!
18:49:52 <kmc> nainaide, "do" is syntactic sugar for the use of monad operators like (>>=) and return
18:50:02 <kmc> and those are basically for ordering
18:50:19 <blackh1> nainaide: "do" doesn't necessarily imply order, but in the IO monad it generally does.
18:50:27 <Veinor> blackh1: really?
18:50:39 <Veinor> Oh.
18:50:43 <Philippa> really, consider the identity monad
18:50:50 <Veinor> Uncomment the --getTag :: typedef
18:50:51 <nainaide> I see, thanks blackh1  and kmc.
18:50:56 <monochrom> Control.Monad.State.Lazy is out of order.
18:50:58 <Philippa> where do is essentially let minus recursion
18:51:34 <blackh1> Veinor: Now I'm getting the error. Let me see.
18:52:48 <blackh1> Veinor: Your use of 'section' ties tag and mp3 to the same type.
18:53:12 <Veinor> Ah.
18:53:52 <Veinor> Ahhhhh. Now I see.
18:54:25 <Veinor> I need some way to get it to treat tag as a ByteString then.
18:54:53 <Veinor> hm.
18:55:06 <blackh1> No - Actually of course it's the use of indexOf that does it.
18:55:27 <Veinor> Yeah. Now I'm realizing that, duh.
18:56:02 <blackh1> Veinor: Maybe you want to do some stuff to allow indexOf to take different types.
18:56:16 <Veinor> I might just rewrite it to use Data.Bytestring throughout.
18:56:54 <tehgeekmeister> i've got a function which is generating a Sequence from beginning to end; is it possible to make it act as if i were generating a list, beginning to end, with respect to laziness.  in other words, operating an element at a type, from beginning to end, instead of waiting for the whole sequence to be generated.
18:57:00 <blackh1> If you want to keep it polymorphic, you could do it with a typeclass, but that may or may not be a good idea.
18:57:21 <Veinor> Eh.
18:58:22 <blackh1> Veinor: A typeclass could be used if you wanted tag and mp3 to be able to be different types.
18:58:45 <Veinor> Yeah, but the problem is that right now tag is a String and mp3 will be a ByteString.
18:58:47 <gaze___> okay let's say you were writing a fancy build system that had to build a dependency tree... how would you structure it such that... say you have obj A, obj B, and obj C, and B and C depend on A... the program sees B depends on A, builds A, builds B, sees C depends on B, but what would be the cleanest way to update that A has been built?
18:59:20 <blackh1> tehgeekmeister: I think Seq is a kind of tree (but don't quote me), that means all modifications must modify the root node... which means it's strict.
18:59:38 <tehgeekmeister> blackh1: yeah, it's implemented as a tree
19:00:07 <Veinor> Cause this is an ID3 library, so it kind of needs Data.ByteString for performance.
19:00:17 <blackh1> tehgeekmeister: Actually it doesn't necessarily mean the root node will get modified, but it probably does.
19:00:46 <blackh1> Veinor: You need to decide whether you want to use concrete types, or whether you want it to be polymorphic.
19:01:06 <tehgeekmeister> i remember i switched to seq instead of list because list was consuming ridiculous amounts of memory, but i can't imagine why it was
19:02:15 <blackh1> tehgeekmeister: Maybe list is what you want.
19:02:32 <Veinor> blackh1: I think I'm going to be using concrete types.
19:03:32 <blackh1> Veinor: Straightforward code is good!
19:04:02 <Veinor> Now I just have to figure out how to turn a String into a ByteString
19:04:09 <Veinor> @hoogle String -> ByteString
19:04:10 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
19:04:10 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
19:04:10 <lambdabot> Prelude read :: Read a => String -> a
19:06:02 <blackh1> Veinor: One way is to import c2w from Data.ByteString.Internal and use Data.ByteString.pack . map c2w
19:06:14 <BMeph> Yeah, Seq uses fingertrees internally, so is strict.
19:06:27 <tehgeekmeister> blackh1: i think list is what i want, but i'll need to figure out what the problem i had with it before was.
19:06:42 <blackh1> Veinor: My favourite way is to use the 'text' package and Text datatype instead of String, and use encodeUtf8 from the Data.Text.Encoding package
19:07:13 <Veinor> But I'm giving it string literals :P
19:07:25 <blackh1> Veinor: Then use {-# LANGUAGE OverloadedStrings #-}
19:07:55 <Veinor> Which does?
19:08:25 <tehgeekmeister> blackh1: oh, i think it was that i was appending to the end of the list, that's expensive, right?  whereas prepending is not?
19:08:26 <blackh1> Veinor: That extension makes it so you can type string literals and get the Text data type instead of String.
19:08:38 <blackh1> You can also use Data.ByteString.Char8, which might be more like what you want to do.
19:08:54 <Veinor> Ah.
19:09:05 <Veinor> Hm.
19:09:31 <blackh1> tehgeekmeister: Yes, that's right - it is also strict.  If you want it to be lazy, you need to write your function in the right way.
19:09:34 <Veinor> Gah, okay
19:10:27 <tehgeekmeister> blackh1: what exactly is this right way?
19:11:10 <blackh1> Veinor: That is, you can use Data.ByteString.Char8 in combination with OverloadedString.  You can also write your own IsString instance - see Data.String in the standard libraries.
19:12:36 <Veinor> Hm.
19:12:39 <Veinor> Now I'm getting *new* errors.
19:12:39 <blackh1> tehgeekmeister: The return value from your function has to have a head part, and then a concatenation of some sort - usually either ++ or : - and then a tail part, which is lazy.
19:12:40 <Zeiris> How can I convert IO [Int] to IO [Word]?
19:12:41 <BMeph> tehgeekmeister: If you want to append swiftly, use the DList hack - i.e., use compositions of appends, and eval when you need it. :)
19:13:07 <ivanm> Zeiris: liftM (map fromIntegral)
19:13:09 <blackh1> Zeiris: Using (fromIntegral `fmap`)
19:13:10 <ivanm> I think...
19:13:20 <ivanm> @type liftM (map fromIntegral)
19:13:21 <lambdabot> forall a b (m :: * -> *). (Integral a, Num b, Monad m) => m [a] -> m [b]
19:13:28 <BMeph> fmap . fmap :)
19:13:28 <ivanm> yup, that should do it
19:13:32 <blackh1> Zeriris: ivanm is right
19:13:33 <ivanm> BMeph: bleh
19:13:34 <aavogt> Zeiris: what should happen to say, -1
19:13:35 <tehgeekmeister> blackh1: i remember what my problem was, now.  the function is in the state monad, and i couldn't do that sort of laziness without using unsafeinterleaveio, iirc
19:13:40 <ivanm> blackh1: of course I am! :p
19:14:15 <Zeiris> aavogt: guaranteed not to exist by the fact that I'm generating in a range of 0 to N... Although I'd love to generate Words directly, instead of all this hoop-hopping.
19:14:17 <blackh1> tehgeekmeister: You should be able to do laziness in the state monad... I just have to think how to do it.
19:14:25 <Veinor> blackh1: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9355#a9355
19:14:33 <blackh1> Zeiris: ivanm is *always* right. :)
19:14:38 <BMeph> tehgeekmeister: if you're using uIIO, then it's not State. Maybe it's an STRef? :)
19:14:43 <ivanm> (well, not always...)
19:15:08 <aavogt> > [1..10::Word]
19:15:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:15:20 <tehgeekmeister> BMeph: no, it's state.  the type signature is makeNextBestReader :: MonadState ReaderState m => m (), and it compiles
19:15:26 <tehgeekmeister> BMeph: so it must be in the state monad.
19:15:30 <BMeph> Zeiris: What's stopping you from using Words directly? :)
19:15:41 <tehgeekmeister> oh, wait
19:15:44 <tehgeekmeister> m ()
19:15:45 <tehgeekmeister> that's a problem
19:15:57 <blackh1> Veinor: If you want to use Prelude.filter and Prelude.foldl, you'll need to use B.unpack and B.pack to convert it to a list
19:16:09 <Zeiris> BMeph, I suck and don't want to figure out how to implement a Word class for Random... Or something.
19:16:12 <Veinor> Oh yeah.
19:16:52 <Veinor> By the way, is there any way for me to tell it to ignore the Prelude functions if they conflict unless I specifically specify Prelude?
19:17:13 <blackh1> Veinor: import Prelude hiding (filter, foldl)
19:17:15 <Veinor> Ah.
19:18:54 <BMeph> Zeiris: Uh, well whatever oral fixations you have, are yours to deal with. :)
19:19:36 <BMeph> Well, I'll be... Word Isn't listed as a Random member! That's...disappointing. :\
19:19:43 <Veinor> Haha, findSubstring is deprecated.
19:19:45 <Veinor> Oh dear.
19:19:54 <c_wraith> :t isInfixOf
19:19:55 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
19:20:24 <Zeiris> Bmeph: Neither is Word8, Word16, etc. So I figure there's some easy way to add/convert it that I'm missing.
19:20:39 <Veinor> ... and it's still slow.
19:20:44 <Veinor> But not as slow as before, haha
19:21:19 <blackh1> tehgeekmeister: If you use the state monad, the problem is that you can't modify your state using 'modify' without doing something to the head of the list.  That forces it to be strict.
19:21:31 <Veinor> blackh1: That code succeeds fast, but if I try to get a non-existent tag, it fails after half a second. :/
19:21:42 <Veinor> is there any wya I can make it fail faster?
19:21:54 <tehgeekmeister> blackh1: i have to explicitly modify it, then?
19:22:15 <blackh1> tehgeekmeister: I believe the state monad just can't do it. The writer monad should do it, though.
19:22:16 <aavogt> Veinor: is grep faster?
19:22:20 <Veinor> Yes.
19:22:33 <tehgeekmeister> blackh1: writer?  writer can emulate state?
19:22:34 <Veinor> grep returns in essentially no time.
19:23:01 <aavogt> perhaps findSubstring is using an inefficient algorithm
19:23:08 <aavogt> like isInfixOf
19:23:10 <Veinor> Maybe.
19:23:29 <Veinor> So what's an efficient algorithm?
19:23:32 <blackh1> tehgeekmeister: Writer uses a Monoid typeclass to do the concatenation, and it does it lazil.y
19:23:33 <aavogt> have you profiled?
19:23:50 <Veinor> nope
19:24:12 <Veinor> don't even know how >_>
19:24:36 <Veinor> I could always tell it to only search the first 50KB if it came down to it
19:25:37 <BMeph> Veinor: bos was just playing around with string searching for his benchmarking stuff. Maybe he has something far enough along that you can use.
19:26:11 <BMeph> Veinor: Or, you could look at the algorithm and work it up yourself. :)
19:26:14 <Veinor> :P
19:26:20 <Veinor> I don't know enough about algos to do it.
19:26:25 <roconnor> map f (x : map f -> xs) = f x : xs
19:26:26 <blackh1> Veinor: You should be able to achieve very good speed using ByteString
19:26:28 <tehgeekmeister> blackh1: you're right, that does seem about right.  i hate that i'm going to have to rewrite all my code, tho.  =/
19:26:39 <Veinor> blackh1: Uh, I'm using ByteSTring and findSubstring :/
19:26:50 <tehgeekmeister> and i don't need the extra value.
19:26:51 <Nafai> I'm excited that bos1337 wrote the statistics library; but I remember so little of college stats that I don't know how to do anything useful :(
19:27:53 <tehgeekmeister> blackh1: what if i use the lazy state monad?
19:28:09 <ivanm> Nafai: try to take over the world with it? :p
19:28:14 <blackh1> tehgeekmeister: Well, it doesn't help - think about how 'modify' works...
19:28:27 <tehgeekmeister> blackh1: i can avoid modify, if i need to
19:28:38 <tehgeekmeister> blackh1: can't i just replace the state explicitly using put?
19:28:45 <blackh1> tehgeekmeister: Well, get / put is equivalent to modify
19:28:57 <tehgeekmeister> blackh1: oh, right, because you're not modifying, you're replacing
19:29:35 <tehgeekmeister> mm, actually not sure if that's really the problem, but yeah.
19:29:39 <blackh1> tehgeekmeister: The problem is that doing it that way means that you're starting at the head of the list each time.
19:30:19 <blackh1> ...whereas using the writer monad resolves to <something> `mappend` <something> `mappend` <something> ...
19:30:27 <Nafai> ivanm: Heh.  Got to re-learn stats.
19:30:47 <tehgeekmeister> oh but i NEED the state
19:30:48 <tehgeekmeister> frak
19:31:05 <tehgeekmeister> can i embed writer in state?  or would that have the same problem?
19:32:03 <tehgeekmeister> i think this calls for a stack overflow question
19:32:38 <Veinor> blackh1: you have any idea how to help me get more speed out of this thing?
19:32:51 <blackh1> tehgeekmeister: You can use the state separately - stack two monads on top of each other.
19:33:15 <blackh1> Veinor: Yes, I should be able to help.  I did some shootout benchmarks in this area.
19:33:27 <tehgeekmeister> i need the state for deciding what element comes next, but i don't need to store the results in state
19:33:31 <tehgeekmeister> i can put them into the writer
19:33:38 <Zeiris> Bmeph: Neither is Word8, Word16, etc. So I figure there's some easy way to add/convert it that I'm missing.
19:33:58 <blackh1> tehgeekmeister: It takes a little while to get your head around Haskell's laziness, but once you do, it makes sense.
19:34:21 <tehgeekmeister> blackh1: i get it when there's not monads involved.  needless to say, that's not very often.  =P
19:34:43 <roconnor> tehgeekmeister: note that it is often better to write to a DList with writer than a list.
19:35:13 <tehgeekmeister> roconnor: of course, that makes sense
19:35:15 <tehgeekmeister> thanks
19:35:24 <tommd> Does anyone know of an endianness CPP definition by GCC?  I'd like to do #if BIG_ENDIAN in some code and runtime checks would get costly.
19:35:28 <Veinor> blackh1: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9356#a9356 is the code; calling getTitle on a typical MP3 is really slow, especially if the tag isn't actually present
19:35:50 <roconnor> really, there ought to be a runWriterLeft and runWriterRight that takes care of that nonsense for you.
19:37:10 <tehgeekmeister> blackh1: so i would have the list in the writer be the value of the state computation, and get it out using evalstate?
19:38:18 <tehgeekmeister> guh, this code needs some serious improvements.  53 minutes running, and at this point i'm not sure it's not just an infinite loop
19:38:27 <tehgeekmeister> takes around 10 minutes in the python code i'm trying to port from
19:38:43 <blackh1> Veinor: I think the reason is that 'take 50000 mp3' is not lazy. It loads the whole file into RAM. What you want is a lazy bytestring.
19:39:12 <Veinor> blackh1: Well, that's just a performance hack to speed up failure
19:39:55 <blackh1> Veinor: How are you getting your mp3 into RAM?
19:40:20 <Veinor> Data.ByteString.readFile "blah.mp3"
19:40:21 <gaze___> anyone here that wouldn't mind helping me figure out some details on how to implement make in haskell?
19:40:48 <blackh1> tehgeekmeister: I would stack a state monad on top of a writer monad, and use the writer for your output.  Try it out on a simple example just to make sure it behaves lazily.
19:40:58 <BMeph> Zeiris: Were you talking about 'fromIntegral'? :)
19:41:08 <Veinor> although profiling says that readFile isn't the slow bit.
19:41:21 <ivanm> gaze___: I would first query why we need yet another make-like program
19:41:23 <blackh1> Veinor: OK - so you're sure the slow part start after the readFile has finished? (Fortunately BS.readFile works completely strictly.)
19:41:41 <Veinor> Yeah, the slow part starts after readFile is done.
19:41:49 <tehgeekmeister> blackh1: brilliant idea, trying it out on something simple.
19:42:05 <BMeph> roconnor: Won't 'Dual' do that Left vs. Right thing you want? :)
19:42:28 <roconnor> BMeph: nope
19:42:30 <tommd> GAHHH - not enough time,k going mad!!  HaskellDHTKernelmodulesnetworkingcryptohackageserver!!
19:42:33 <blackh1> Veinor: So it must be findSubstring that's being slow.
19:42:36 <gaze___> ivanm: For the fun of it, and I don't particularly like the way gmake handles header scanning (it lets GCC do it in a hacky manner), and the way it handles  multiple directories
19:42:52 <Veinor> although, I think readFile might be part of it.
19:43:09 <roconnor> BMeph: well, you probably can use dual to implement one in terms of the other, but you still need to define at least one.
19:43:11 <Veinor> given that nulling out getTag still takes 28 seconds.
19:43:13 <tehgeekmeister> blackh1: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9357#a9357
19:43:18 <gaze___> recursive make is bad, nonrecursive make is hacky. It just seems like a cool challenge too.
19:43:48 <tehgeekmeister> blackh1: the function in question is makeNextBestReader, the rest you should be able to fairly safely ignore
19:43:57 <tehgeekmeister> if it helps to see the actual code
19:43:59 <gaze___> jam I like the principle but not the implementation and it isn't mantained, scons is slow, blah blah blah
19:44:59 <Veinor> Anyway.
19:45:03 <Veinor> Er, not 28 seconds
19:45:04 <Veinor> 28 ms
19:45:38 <blackh1> Veinor: Can you give me the actual figures on how slow is slow?
19:46:19 <Veinor> on a file that has no title tag, it takes .941 ms, .900 of which is spent in user
19:46:23 <blackh1> tehgeekmeister: What list do you want to output lazily?
19:46:35 <Veinor> This is a 8M file, by the way.
19:47:03 <tehgeekmeister> blackh1: the items i'm appending in makeNextBestReader
19:47:10 <Veinor> Which isn't terribly unreasonable for MP3 files.
19:47:42 <Veinor> If it's present, it takes .057s.
19:48:11 <Veinor> Or so.
19:48:21 <Veinor> Most of that is spent in sys, not user.
19:49:01 <Veinor> The point is that it takes upwards of a second to fail, and acceptably little time to succeed.
19:49:06 <blackh1> tehgeekmeister: Well, if appendItems wrote to a writer monad that sat underneath your state monad, it should work lazily in theory.
19:49:26 <tehgeekmeister> blackh1: okay, i'll give that a try tomorrow
19:49:29 <tehgeekmeister> thanks for your help
19:49:34 <tehgeekmeister> i think it's time to get off to bed
19:49:59 <blackh1> tehgeekmeister: Good night!
19:50:27 <blackh1> Veinor: It should be able to go faster.  It could be that it wasn't written for extreme speed.
19:50:41 <blackh1> Veinor: I am just looking at the code.
19:51:03 <Veinor> blackh1: Yeah; the bottleneck appears to be in findSubstring. So what would be a way to do it in reasonably fast time?
19:52:02 <blackh1> Veinor: I'll take a quick look at how it works, then I'll tell you a fast way.
19:52:06 <Veinor> Cool.
19:52:33 <Veinor> If all else fails, i can just look at the first 100KB and hope that whoever tagged the MP3 didn't put the album art before the ID3 tag :P
19:53:14 <Veinor> Er, 1KB even.
19:54:29 <blackh1> Veinor: Well, it's using this thing called unsafeTail which should be fast but could easily not be optimized as well as we would like.  OK - here is how to write it super-duper fast:
19:54:36 * Veinor takes notes
19:55:33 <blackh1> Veinor: let (fp, offset, len) = Data.ByteString.Internal.toForeignPtr
19:55:51 <blackh1> withForeignPtr fp $ \p0 -> do
19:56:00 <blackh1> let p = p0 + offset
19:56:34 <blackh1> foldM_ [0..(len-1)] ( ... )
19:57:02 <Veinor> could you just put this in a haskell pastebin so I don't run into formatting errors or whatever? :P
19:57:07 <blackh1> So you need to use Data.ByteString.Internal.memcmp to compare the memory location.....
19:57:15 <blackh1> OK - I'll just write the whole thing now.
19:57:22 <Veinor> Would you please? <3
19:59:53 * BMeph gets the feeling that a lot of the problems in this code come from trying to "program Pythom in Haskell"...
20:03:05 * wdonnelly is currently causing problems by trying to program Haskell in python
20:03:13 <wdonnelly> trust me, the other way around is much more fun
20:03:24 * Veinor is trying to program python in haskell in python.
20:05:11 <Zeiris> How can I get pie (circle,total) = circle/total*4 to have a type of pie :: Fractional a => (Int,Int) -> a
20:06:22 <kmc> :t pie (circle,total) = circle/total*4
20:06:24 <lambdabot> parse error on input `='
20:06:30 <kmc> :t let pie (circle,total) = circle/total*4 in pie
20:06:30 <lambdabot> forall t. (Fractional t) => (t, t) -> t
20:06:46 <kmc> :t let pie (circle,total) = (fromIntegral circle)/(fromIntegral total)*4 in pie
20:06:47 <lambdabot> forall t t1 b. (Integral t1, Fractional b, Integral t) => (t, t1) -> b
20:12:34 <Veinor> blackh1: If it's too much of a problem, you don't have to bother with it
20:13:06 <blackh1> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3598#a3598
20:13:21 <blackh1> Veinor: Nothing is too much of a problem for you! Try that. See if it's any faster.
20:13:33 <gaze___> anyone mind helping me with this dependency tree structuring issue?
20:13:49 <blackh1> Use unsafePerformIO if you want to use it in pure code.
20:14:48 <blackh1> Veinor: You might also find you can speed it up by checking the first character before calling memcmp, which would eliminate the Haskell/C overhead in the common case.
20:16:00 <blackh1> e.g. c1 <- peek n ; c2 <- peek (h `plusPtr` offset) ; matched <- if c1 == c2 then BI.memcmp else return (-1)
20:16:22 <Veinor> I do not understand this code. :D
20:16:23 <blackh1> When Haskell code calls C, there's a whole lot of mucking about with pushing registers onto the stack.
20:16:50 <blackh1> Veinor: This code is accessing memory directly.
20:16:58 <Veinor> And it won't compile.
20:16:59 <blackh1> Veinor: It's basically C code written in Haskell.
20:17:00 <Veinor> hm
20:17:19 <Veinor> I think I might need to install Foreign
20:17:27 <Veinor> ... or not.
20:17:29 <blackh1> Foreign is in the standard library
20:17:34 <blackh1> So you don't need to install it.
20:17:45 <Veinor> It's not compiling.
20:17:51 <blackh1> The code I pasted works for me on ghc 6.10.3
20:18:05 <Veinor> (.data+0x164): undefined reference to `bytestringzm0zi9zi0zi1_DataziByteString_pack_closure'
20:18:17 <blackh1> Did you pass --make to ghc?
20:18:29 <Veinor> ... Now I feel silly.
20:19:26 <Veinor> Hm.
20:20:19 <Veinor> Let's see if it's faster.
20:20:52 <blackh1> Veinor: If it isn't, I'll try the optimization I mentioned above
20:21:40 <Veinor> Cool.
20:21:54 <Veinor> Now I just have to figure out how to get it to work with a ByteString read from a file , haha
20:22:56 <Pygma> How smart is Haskell about optimising stuff like recursive stuff?
20:23:06 <Veinor> Wow, that's really slow
20:23:11 <Pygma> Like I have "fib x = (if x < 2 then x else fib (x-1) + fib (x-2))"
20:23:25 <blackh1> Veinor: How long did that take?
20:23:35 <Veinor> A second to fail.
20:23:40 <Pygma> I would hope that if I call fib 42 then fib 43 it would be pretty instantaneous
20:23:52 <Pygma> But that doesn't seem to happen
20:24:15 <Pygma> Seems to work it all out again, despite already having worked out everything
20:24:23 <blackh1> Veinor: That's roughly the same. I'll try the optimization.
20:24:30 <blackh1> Pygma: That's the way it's meant to work.
20:24:32 <FunctorSalad_> AFAIK it doesn't memoize your version of fib at all
20:25:03 <Veinor> yeah, but it's more than a second, the other one was less than.
20:25:09 <Veinor> It's slower than the pure-haskell implementation.
20:26:33 <Veinor> Hm.
20:27:38 <Veinor> The slowness might just be due to loading the modules.
20:27:41 <Veinor> Nah.
20:31:05 <blackh1> Veinor: Try that. http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=3598#a3599
20:31:16 <blackh1> I've added unsafePerformIO so now it has a pure interface.
20:32:16 <Veinor> Nope, still slow.
20:32:18 <Veinor> :/
20:32:43 <mmorrow> , (let go !m !n = m : go n (m+n) in go 0 1) !! 100000
20:32:45 <lunabot>  2597406934722172416615503402127591541488048538651769658472477070395253454...
20:32:54 <Veinor> Now I think I know why there's no pure Haskell ID3 library, lol
20:33:50 <blackh1> Veinor: I tried and I failed!
20:33:54 <Veinor> It's fine.
20:35:01 <mmorrow> Pygma: that fib computes it bottom-up, rather than duplicating work by repeatedly following top-down paths like f(n-1)+f(n-2)
20:38:57 <mmorrow> , (length . show) (let go 0 !m _ = m; go l !m !n = go (l-1) n (m+n) in go 200000 0 1)
20:39:00 <lunabot>  41798
20:39:08 <mmorrow> gmp is fast
20:39:28 <mmorrow> , (length . show) (10000^1000)
20:39:29 <lunabot>  4001
20:40:42 <mmorrow> , (length . show) (10000000000^100000)
20:40:44 <lunabot>  1000001
20:40:52 <Parkotron> How do I generate a list of pairs (x, y) where x < y and x + y == 10?
20:41:19 <ksandstr> use a list comprehension.
20:41:29 <mmorrow> , [(x,y) | x <- [0..], y <- [0..], x < y, x + y == 10]
20:41:35 <lunabot>  Killed.
20:41:39 <dolio> No, not that way.
20:41:42 <gaze___> hahahah
20:41:43 <c_wraith> heh.  that's a terrible way to do that
20:41:47 <mmorrow> err, i guess you'll need to diagonal
20:42:03 <ksandstr> , [(x, y) | x <- [0..10], y <- [0..(x-1)], x < y, x + y == 10]
20:42:03 <dolio> , [(x,10-x) | x <- [0..5]]
20:42:04 <lunabot>  []
20:42:04 <lunabot>  [(0,10),(1,9),(2,8),(3,7),(4,6),(5,5)]
20:42:11 <mmorrow> wee
20:42:17 <ksandstr> possibally not :D
20:42:35 <Parkotron> Thanks folks. Time for me to do more reading.
20:43:17 <dolio> , [(x,10-x) | x <- [5,4..]]
20:43:18 <lunabot>  [(5,5),(4,6),(3,7),(2,8),(1,9),(0,10),(-1,11),(-2,12),(-3,13),(-4,14),(-5...
20:43:57 <Parkotron> dolio: What about triplets where x+y+z == 20?
20:44:26 <dolio> x <= y <= z or what?
20:44:36 <ksandstr> that felt suspiciously like trying to optimize bubblesort
20:44:38 <Parkotron> dolio: x < y < z
20:44:46 <gaze___> haha... you're limiting this to positive integers, right?
20:44:51 <gaze___> oh
20:45:02 <dolio> Anyhow, you pick x, then pick y starting from x+1, and then use z = 20 - x - y.
20:45:54 <dolio> And x obviously never has to go above 20/3, because then x + y + z will be greater than 20, since they're greater than x.
20:45:54 <Parkotron> dolio: I know that. I want to know what it looks like in Haskell! ;)
20:45:55 <dolio> And so on.
20:46:01 <dolio> Oh.
20:46:38 <Parkotron> dolio: I'm just kidding with you. I need to read up on Haskell list comprehensions.
20:46:45 <dolio> , [(x, y, 20-z) | x <- [0..6] , y <- [x+1..10]]
20:46:47 <lunabot>  [(0,1,20 - z),(0,2,20 - z),(0,3,20 - z),(0,4,20 - z),(0,5,20 - z),(0,6,20...
20:46:57 <dolio> , [(x, y, 20-x-y) | x <- [0..6] , y <- [x+1..10]]
20:46:58 <lunabot>  [(0,1,19),(0,2,18),(0,3,17),(0,4,16),(0,5,15),(0,6,14),(0,7,13),(0,8,12),...
20:47:32 <dolio> That might be wrong.
20:47:40 <Guest49002> is code.haskell.org having trouble?
20:48:01 <dolio> , [(x, y, 20-x-y) | x <- [0..6] , y <- [x+1..(20 - x)`div`2]]
20:48:02 <lunabot>  [(0,1,19),(0,2,18),(0,3,17),(0,4,16),(0,5,15),(0,6,14),(0,7,13),(0,8,12),...
20:48:02 <ivanm> Guest49002: yes
20:48:10 <ivanm> http://downforeveryoneorjustme.com/code.haskell.org
20:48:11 <mmorrow> , let xs = diagonal (fmap (\n -> [n..]) [0..]); ys = tail xs in nub (interleave (zip xs ys) (zip ys xs))
20:48:14 <lunabot>  [(0,1),(1,0),(1,1),(1,2),(2,1),(2,2),(2,3),(3,2),(3,3),(3,4),(4,3),(4,4),...
20:48:16 <lambdabot> Title: It's not just you!
20:48:24 <dolio> , length [(x, y, 20-x-y) | x <- [0..6] , y <- [x+1..(20 - x)`div`2]]
20:48:25 <lunabot>  37
20:48:33 <dolio> , length [(x, y, 20-x-y) | x <- [0..6] , y <- [x+1..10]]
20:48:34 <lunabot>  49
20:49:46 <mmorrow> , , let d x y = sqrt (fromIntegral(x^2 * y^2):: Double) in fmap d (let xs = diagonal (fmap (\n -> [n..]) [0..]); ys = tail xs in nub (interleave (zip xs ys) (zip ys xs)))
20:49:47 <lunabot>  luna: parse error on input `let'
20:49:51 <mmorrow> , let d x y = sqrt (fromIntegral(x^2 * y^2):: Double) in fmap d (let xs = diagonal (fmap (\n -> [n..]) [0..]); ys = tail xs in nub (interleave (zip xs ys) (zip ys xs)))
20:49:52 <lunabot>  luna: No instance for (GHC.Show.Show ((a, a) -> GHC.Types.Double))
20:49:57 <Guest49002> ivanm: any idea of when it will be back to normal?
20:50:02 <ivanm> nope
20:50:09 <mmorrow> , let d x y = sqrt (fromIntegral(x^2 * y^2):: Double) in fmap (uncurry d) (let xs = diagonal (fmap (\n -> [n..]) [0..]); ys = tail xs in nub (interleave (zip xs ys) (zip ys xs)))
20:50:13 <lunabot>  [0.0,0.0,1.0,2.0,2.0,4.0,6.0,6.0,9.0,12.0,12.0,16.0,20.0,20.0,25.0,30.0,3...
20:50:20 <Guest49002> darn, well, thanks
20:50:41 <mmorrow> err
20:50:48 <mmorrow> , let d x y = sqrt (fromIntegral(x^2 + y^2):: Double) in fmap (uncurry d) (let xs = diagonal (fmap (\n -> [n..]) [0..]); ys = tail xs in nub (interleave (zip xs ys) (zip ys xs)))
20:50:49 <lunabot>  [1.0,1.0,1.4142135623730951,2.23606797749979,2.23606797749979,2.828427124...
20:51:28 <gaze___> okay well, does anyone feel like helping with the dependency tree business? all I've gotten was that we don't need another build system which I don't argue with but I'm interested in the problem itself...
20:52:42 <mmorrow> gaze___: you probably'll need toposort, which you get for free with scc's, and i think both'll be useful
20:53:09 <gaze___> what is scc?
20:53:19 <mmorrow> strongly-connected components
20:55:58 <Veinor> blackh1: I might just shell out to id3v2, haha
20:56:03 <gaze___> hmm... what would be a valid case of a dependency graph that was cyclic?
20:56:52 <gaze___> I mean... I'd hope that you wouldn't have an executable that depends on a source file that depends on the executable or something like that
21:02:00 <cloudhead> how would I convert an Int to an Integer? can't figure it out : |
21:02:23 <roconnor> fromIntegral
21:02:53 <roconnor> or toInteger
21:03:06 <cloudhead> ah right, so it converts it to a Num which is compatible with Integer?
21:03:23 <Cale> yeah
21:03:26 <roconnor> @type fromIntegral
21:03:27 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:03:31 <Parkotron> , let n = 20 in [ (x,y,n-x-y) | x <- [1..(div n 3)], y <-[(x+1)..(div (n-x-1) 2)] ]
21:03:32 <lunabot>  [(1,2,17),(1,3,16),(1,4,15),(1,5,14),(1,6,13),(1,7,12),(1,8,11),(1,9,10),...
21:03:34 <roconnor> @type toIntegral
21:03:35 <lambdabot> Not in scope: `toIntegral'
21:03:38 <roconnor> @type toInteger
21:03:39 <lambdabot> forall a. (Integral a) => a -> Integer
21:03:42 <Orclev> can someone download the source from this (http://user.cs.tu-berlin.de/~magr/pub/Transformers.en.html) tutorial and let me know if you can get it to compile... when I try to load it into ghci I get 4 errors about mismatched type signatures
21:03:43 <lambdabot> Title: Monad Transformers Step by Step
21:03:44 <roconnor> @src toInteger
21:03:44 <lambdabot> Source not found.
21:03:45 <Cale> It converts any type of Integral into any type of Num
21:03:54 <m4ik3ru> Howdy.
21:04:06 <ivanm> Cale: does it convert to Integer first or something?
21:04:13 <ivanm> I seem to recall reading that somewhere once...
21:04:18 <m4ik3ru> I want to apologize to anyone who was in here when I asked my previous question, a few days ago.
21:04:20 <Cale> ivanm: yeah, it converts via Integer
21:04:24 <roconnor> @src fromIntegral
21:04:24 <lambdabot> fromIntegral = fromInteger . toInteger
21:04:43 <Cale> m4ik3ru: what was that?
21:04:45 <m4ik3ru> I hadn't Googled exhaustively enough and found my answer rather quickly.
21:04:57 <Cale> m4ik3ru: That's okay. Asking is often faster than googling.
21:05:01 <cloudhead> thanks roconner, for some reason I didn't find toInteger, but it is indeed there : )
21:05:01 <m4ik3ru> I was looking for help understanding the implementation of powerset.
21:05:10 <narbeh> can somebody please help me with my programming pleaseeeee?
21:05:11 <m4ik3ru> Cale: I know, right? :)
21:05:15 <roconnor> powerset over what?
21:05:16 <Cale> m4ik3ru: There are lots of people who hang around here looking for beginners to help.
21:05:17 <Orclev> half the battle is usually knowing what to google for in the first place
21:05:32 <m4ik3ru> I know, jethr0 and other have been hugely helpful
21:05:38 <Cale> > filterM (const [True, False]) [1,2,3,4]
21:05:39 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
21:05:46 <roconnor> oh that powerset
21:05:57 <m4ik3ru> Cale: I had to implement it myself without using built in function :)
21:06:01 <m4ik3ru> well, besides map
21:06:25 <m4ik3ru> I think I might loose a point or two for that :)
21:06:41 <narbeh> can somebody please help me with my prgramming please?
21:06:47 <Cale> Of course you could implement map yourself too :)
21:07:00 <m4ik3ru> Actually he had covered map in class, so it might be cool.
21:07:05 <Cale> narbeh: Nobody can help when they don't know what your question is.
21:07:05 <roconnor> narbeh: ok
21:07:07 <m4ik3ru> ishavedchewbacca: Hi Matt.
21:07:21 <ishavedchewbacca> Hi Mike
21:07:41 <m4ik3ru> > take 20 [1..]
21:07:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
21:08:03 <m4ik3ru> :t take
21:08:03 <lambdabot> forall a. Int -> [a] -> [a]
21:08:22 <Orclev> so, anyone have any luck with ( http://user.cs.tu-berlin.de/~magr/pub/Transformers.lhs )
21:08:25 <m4ik3ru> :t take
21:08:26 <lambdabot> forall a. Int -> [a] -> [a]
21:08:48 <Orclev> trying to figure out if my libraries are fubar, or if the tutorial is out of date
21:09:54 <Orclev> hmm... now that I look at the errors it looks like they all are related to the lookup function... was there some major change in that recently?
21:10:12 <m4ik3ru> > define firstN :: Int -> [a] -> [a]
21:10:13 <lambdabot>   Not in scope: `define'Not in scope: `firstN'
21:10:32 <m4ik3ru> > firstN :: Int -> [a] -> [a]
21:10:33 <lambdabot>   Not in scope: `firstN'
21:18:45 <m4ik3ru> sup
21:19:47 <ivanm> for some reason when using ghci with the emacs haskell-mode, when I try and paste in text to create a String variable, it complains "lexical error in string/character literal at character '\EOT'" ... any ideas why?
21:19:54 <ivanm> (ghci in an xterm doesn't complain)
21:20:47 <SamB_XP_> maybe emacs sets some environment variable that messes things up ???
21:20:52 <SamB_XP_> or maybe it uses the wrong encoding ?
21:21:02 <BMeph> Orclev: Yes, 'round about the 6.10 change, lookup was changed to explicitly use Maybe, since the former constraints weren't seen to add anything of use.
21:21:13 <ivanm> SamB_XP_: hmmm, could be
21:23:19 <eoeas> Hi everyone, my app "test.hs" which should read "text_file.txt" compiles file, however, at runtime, I get "test: Prelude.read: no parse", any idea what this could mean ??
21:23:31 <eoeas> ... compiles fine
21:23:33 <Orclev> BMeph: hmm, well in the tutorial he mentions that lookup returns a Maybe value and he's using fromJust... but it doesn't look like he continues to use fromJust after he starts adding in some monads (and monad transformers later on)...
21:23:57 <SamB_XP_> Orclev: I guess he didn't updated that parted of the tutorialed ?
21:24:16 <blackh1> eoeas: It means that 'read' is expecting something - probably a number - and it can't parse it.
21:25:37 <eoeas> blackh: could it also be expecting 'Char' but gets 'String' ??
21:26:04 <Orclev> SamB_XP_: yeah, looks that way, I edited one of the error lines to change it from Map.lookup ... to return $ fromJust $ Map.lookup ... and it fixed the error... guess I just need to fix the other 3 occurences
21:26:10 <blackh> blackh: Yes - it could be.  'read' is the function that's failing, because it doesn't like its input.
21:26:38 <eoeas> Cheers blackh
21:28:02 <Orclev> and success, it compiles cleanly now
21:28:16 <jmcarthur> woah, i didn't know you could set the fixity on `foo` notation
21:28:29 <Orclev> wonder if it would be worth the time to e-mail the author about the chnage
21:28:49 <SamB_XP_> Orclev: well, it depends on how hard it is to find his email address ;-)
21:29:08 <cloudhead> is it bad style to have a type declaration on the same line as a 'where' ?
21:29:44 <SamB_XP_> cloudhead: it depends on whether that makes your code stick into the margins or not, basically ;-)
21:30:17 <cloudhead> I'm wondering cause the syntax highlighter in my texteditor specifies that type declarations can't have anything before them
21:30:22 <cloudhead> hehe
21:30:51 <SamB_XP_> get a better text editor ?
21:31:09 <jmcarthur> haskell-mode in emacs is quite excellent :)
21:31:33 <cloudhead> well, I was about to change the regex, but I wanted to know if the author ommitted it on purpose
21:31:35 <cloudhead> http://www.friendpaste.com/4iWatdMiPEYkQ6r8nxcVcf
21:31:41 <cloudhead> this is what I'm doing
21:32:15 <cloudhead> if it's fine, I'll go fix up the syntax file : )
21:33:11 <Veinor> Blah. I noticed that a lot of the things that're keep me from doing interesting stuff in Haskell is a lack of good libraries.
21:33:50 <SamB_XP_> Veinor: go forth and write some!
21:33:57 <Veinor> :P
21:34:27 <cloudhead> Veinor: like what? (just curious)
21:34:50 <Veinor> Well, ID3
21:34:58 <Veinor> and libnotify
21:35:09 <Orclev> I thought there was a ID3 library
21:35:15 <Veinor> Really? Where?
21:35:16 <cloudhead> ah : )
21:35:37 <Makoryu> cloudhead: What text editor are you using, I wonder?
21:35:39 <Orclev> give me a second to go see if I can find one... although I could have sworn I had seen one at some point
21:35:44 <cloudhead> Makoryu: TextMate
21:35:49 <Makoryu> cloudhead: Whoops >_>
21:36:00 <Makoryu> cloudhead: Don't trust anything it says.
21:36:03 <cloudhead> haha
21:36:20 <cloudhead> I know, I've been messing around with the syntax file quite a bit already
21:36:20 <Veinor> ah, taglib
21:36:34 <cloudhead> does the maintainer happen to be around?
21:36:48 <cloudhead> (if he's even still interested in maintaining it)
21:36:52 <Makoryu> cloudhead: The maintainer for that bundle is me :p
21:36:58 <cloudhead> aha!
21:37:08 <cloudhead> nice meeting you : )
21:37:22 <Makoryu> Send me your patches! I'll see if I can track down my SVN password...
21:37:27 <Veinor> Ooh, taglib actually works :D
21:37:31 <Veinor> for some reason it didn't for me
21:37:47 <Veinor> before
21:37:49 <cloudhead> Do you maintain the github repo?
21:37:50 <Veinor> but now I can use this, yay
21:38:12 <Makoryu> cloudhead: Last I checked, that was a mirror. The real repo is on svn.textmate.org
21:38:32 <cloudhead> ah yea it probably is
21:38:41 <Makoryu> Haven't checked in some time, though...
21:39:13 <cloudhead> well, so far the problems I found were with comments
21:39:16 <Makoryu> It's been months and months since anyone last commented on the bundle's behavior, and I never got around to the rewrite I wanted to to
21:39:21 <cloudhead> and that 'where' thing
21:39:22 <Makoryu> Yeah, the comments are a crap shoot
21:39:32 <cloudhead> ah I see
21:40:13 <cloudhead> Makoryu: do you code in TextMate?
21:40:20 <cloudhead> or are you on linux or something?
21:41:34 <Makoryu> cloudhead: I switched to MacVim ages ago because the TM devs are dragging their feet on proper indentation support
21:41:41 <Orclev> I recently downloaded yi, and the design of it reminds me a lot of xmonad, but I'm not yet sufficiently motivated to move away from vim
21:42:14 <cloudhead> Makoryu: ah : D — you got me interested, what is proper indentation support?
21:43:05 <cloudhead> to be fair the TM dev(s)? are dragging their feet on everything : )
21:43:07 <Orclev> my guess would be soft tabs and smart auto-indent, but I'm just guessing here
21:43:22 <cloudhead> TM has soft tabs
21:43:26 <ivanm> soft tabs? :o
21:43:53 <cloudhead> there is auto-indent, but I guess it could be improved
21:44:01 <Orclev> ivanm: yeah, for inserting spaces instead of a tab character when you use the tab key
21:44:14 <ivanm> since when was that referred to as a soft tab?
21:44:25 <Orclev> what I've always heard it referred to as
21:44:26 <Makoryu> cloudhead: Variable indentation, etc.
21:44:44 <Orclev> ivanm: what do you normally see it called?
21:44:56 <Makoryu> ivanm: That's been text editor terminology for as long as I can remember
21:45:03 <cloudhead> same ; )
21:45:17 <ivanm> hmmmm, I must have gotten them confused with electric tabs...
21:45:31 <ivanm> (setq indent-tabs-mode nil) ; all I need ;-)
21:45:43 <Orclev> now electric tabs is a new one on me... what's that mean?
21:46:37 <ivanm> Orclev: auto-insertion I think
21:46:39 <ivanm> (of text)
21:47:09 <blackh> ivanm is often right!
21:47:22 <ivanm> heh
21:47:36 <Makoryu> Anyway
21:47:52 <Makoryu> Orclev: The actual problem I have with TM's auto-indent is that it's not turing-complete
21:47:58 <ivanm> Orclev: http://www.emacswiki.org/emacs/Electricity
21:48:15 <Orclev> ewww, emacs :P
21:48:32 <ivanm> you didn't guess with that setq tab I had above? ;-)
21:49:01 <ivanm> s/tab/command/
21:49:04 <Orclev> emacs, the OS with the built in editor
21:49:18 <ivanm> *sigh*
21:49:27 <ivanm> exit's that way: =====>
21:49:27 <Orclev> sorry, couldn't resist
21:49:40 * ivanm is looking forward to EZBL though
21:50:07 <Orclev> EZBL?
21:50:35 <ivanm> have you heard of UZBL?
21:50:38 <impl> http://www.haxney.org/2009/08/its-alive.html
21:50:42 <impl> FEAR
21:50:45 <Orclev> ivanm: nope
21:51:15 <ivanm> impl: yeah, that
21:51:21 <ivanm> w3m sucks at reading haddock docs :@
21:51:29 <Orclev> LOL!
21:51:32 <Orclev> that's awesome
21:52:45 <Orclev> seriously, I'm waiting for someone to release emacs OS, it can't possibly be that far from happening at this point
21:54:11 <ivanm> ummm.... last I heard, Hurd was nowhere near release :p
21:54:40 <SamB_XP_> they were probably closer to release a decaade ago
21:55:11 <SamB_XP_> but I don't think Orclev is talking about the hurd
21:55:15 <Draconx> ivanm, I think it's more accurate to say "haddock sucks at producing good html documents so that browsers such as w3m can display them nicely."
21:55:24 <ivanm> Draconx: maybe...
21:55:34 <babusrini> Is it possible to have a one-liner "forM (listDirectory "../..") (\a -> return $ length a)". This doesn't work as listDirectory returns IO [String]. Can String be lifted without doing 'c <- listDirectory "../.." first', like do {c <- listDirectory "../.."; forM c (\a -> return $ length a)}
21:55:51 <Draconx> ivanm, in particular, it doesn't use list markup for lists.
21:55:58 <ivanm> (e.g. the +/- on instances...)
21:56:11 <ivanm> babusrini: liftM
21:56:14 <ivanm> @type liftM
21:58:01 <Orclev> you know, one of the things that always made perl modules on CPAN a breeze to use was the tendency to provide a fairly comprehensive tutorial of standard usage in the general description of a module... from what I've seen the norm of haskell is a generic high level blurb and then one or two lines per function
21:58:17 <Orclev> if that
21:58:23 <babusrini> I have used liftM. But how would I use it here? What would be the first arg of liftM ((a1 -> r)) in this case?
21:58:28 <blackdog> Orclev: yeah. a cookbook approach is often helpful
21:58:55 <blackdog> if you're careful, you can make your tests be a decent cookbook
21:59:05 <blackdog> especially if you sequester the nasty corner cases away in another file
21:59:32 <blackdog> been trying to do that with Hubris, aided by the fact that it's not terribly feature-complete yet...
22:02:08 <Orclev> blackdog: would that be helpful to someone browsing the haddock generated documentation on hackage?
22:04:11 <blackdog> Orclev: suppose not.
22:04:39 <blackdog> but API reference docs and cookbooks are very different sorts of documentation
22:04:49 <blackdog> the first has to be complete, the second has to be readable and intuitive.
22:05:11 <Orclev> blackdog: true, although it doesn't hurt any to include a little of the later in the former
22:05:22 <hydo> Does anyone know what the particular dance is required to get HStringTemplateHelpers to install on windows?  It depends on FileManip which is decidedly winders-unfriendly.
22:05:23 <blackdog> it's nice if you can do it, but it's often difficult
22:05:42 <blackdog> quite often, newbie tutorials are almost lies to children
22:06:06 <blackdog> once you get the gist of something you can find out the tech details in the api
22:06:15 <hydo> Google is being rather tight-lipped with the answers too which is weird - I assume you have to install hsth to get the happstack tutorial to work.
22:08:28 <Orclev> blackdog: well, I'm not saying you should put a proper tutorial in the API docs, but often times I'll look up a package on hackage, check out the API docs, and have absolutely no clue how to go about using that package... even a "hey stupid, you probably want to look at this function first" would be helpful
22:15:00 <hydo> ugh... yakshave for x hours or refactor away from hstringtemplate.
22:17:48 <blackdog> Orclev: one of the things i rather like about github is that they put the README up on the very first page
22:18:03 <blackdog> so you can put up a small example inline
22:20:41 <hydo> oooo... press looks pretty cool.
22:25:32 <m4ik3ru> :t find
22:25:52 <ivanm> blackdog: and that's good because it forces upstream to create README pages? :p
22:25:57 <ivanm> @bot
22:25:57 <lunabot>  :o
22:26:02 <ivanm> lambdabot seems to be dead...
22:26:07 <m4ik3ru> ...is lambdabot dead?
22:26:09 <m4ik3ru> Aww...
22:26:12 <mauke> preflex: seen lambdabot
22:26:12 <preflex>  lambdabot was last seen on #haskell 1 hour, 15 minutes and 39 seconds ago, saying:   Not in scope: `firstN'
22:26:12 <m4ik3ru> Lunabot?
22:26:22 <ivanm> operates differently
22:26:26 <m4ik3ru> ah.
22:26:31 <ivanm> anyone here a lambdabot admin?
22:26:37 <ivanm> preflex: seen Gwern-away
22:26:38 <preflex>  Gwern-away was last seen on #haskell 5 hours, 19 minutes and 54 seconds ago, saying: tehgeekmeister: perhaps you sleep-hack
22:26:41 <ivanm> preflex: seen Gwern
22:26:42 <preflex>  Gwern was last seen on #haskell 5 hours, 57 minutes and 52 seconds ago, saying: 'so I appended all 100 entries to my list - then I discovered I needed to index in the *reverse* order. FML, man. FMList.'
22:27:00 <sbahra> heh
22:27:08 <sbahra> preflex, seen ddarius
22:27:09 <preflex>  ddarius was last seen on #haskell 108 days, 4 hours, 4 minutes and 19 seconds ago, saying: parsec2 is faster and what most libraries expect.
22:27:10 <m4ik3ru> nice :)
22:27:12 <sbahra> preflex, seen wli
22:27:12 <preflex>  wli was last seen on #haskell-blah 66 days, 7 hours, 2 minutes and 53 seconds ago, saying: He's in the bathroom right now having another of those hushed convos about dumping me.
22:27:35 <m4ik3ru> so, apparently "find" isn't in Prelude.
22:27:40 <m4ik3ru> Neither is isJust.
22:27:48 <mauke> @index find
22:27:52 <mauke> :-(
22:28:21 <Orclev> well, from what I've seen there's basically two "classes" of docs in the haskell world... there's the API docs on hackage which for the most part, assume you already know how to use the package and just need a quick refresher, and then there's sometimes tutorials/basic usage docs scattered about on the various wikis and personal websites (and occasionaly hosted on the website for that package)
22:29:02 <m4ik3ru> ishavedchewbacca: Hi Matt.
22:29:51 <Orclev> it would be nice if there was a simpler way to find the tutorials/usage docs from hackage, and/or if the docs on hackage were a bit less terse and newbie-friendly
22:30:00 <m4ik3ru> ishavedchewbacca: in what package are find, isJust and nub?
22:30:15 <mauke> Data.List and Data.Maybe
22:30:18 <m4ik3ru> Orclev: I've only read Learn You A Haskell For Great Good :)
22:30:35 <m4ik3ru> what's the import syntax?
22:30:43 <Orclev> m4ik3ru: that was one of the first ones I read as well, really liked it
22:30:49 <mauke> import Data.List
22:31:04 <m4ik3ru> ishavedchewbacca: I am altering your code... Pray I do not alter it further...
22:31:32 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/altered-pool.jpg
22:31:47 <blackdog> ivanm: yeah, kinda :)
22:32:43 <m4ik3ru> mauke: They are apparently in one or both of those packages, because I got a syntax error instead of a scope error :)
22:33:04 <mauke> um, yay?
22:33:15 <m4ik3ru> mauke: steps in the right direction.
22:33:22 <m4ik3ru> mauke: so thank you :)
22:34:26 <kmc> lol,internet
22:36:51 <m4ik3ru> > let {powerset = powerset (xs) ++ map (x:) powerset (xs)} in powerset [1,2,3]
22:38:01 <Veinor> , let {powerset = powerset (xs) ++ map (x:) powerset (xs)} in powerset [1,2,3]
22:38:02 <lunabot>  luna: Not in scope: `xs'
22:38:22 <kmc> why does LYAHFGG have that weird name anyway
22:40:18 <m4ik3ru> kmc: For Great Justice Make Your Time
22:40:20 <Orclev> kmc: no idea, but the style is the same as a poor translation from japanese (E.G. all your base)... also, for great good, or for great justice is often how a common catch phrase in japanese is translated...
22:40:44 <kmc> okay
22:40:48 <m4ik3ru> lol Orclev and m4ik3ru nerdy meme knowledge
22:42:06 <Orclev> hah, you can't have spent as much time browsing icanhascheezburger.com as I have and not absorbed a few memes
22:42:54 <m4ik3ru> Orclev: hah, you can't have spent as much time browsing icanhascheezburger.com (read: 4chan) as I have and not absorbed a few (read: every) memes
22:43:36 <kmc> if that's the only thing you absorbed from 4chan consider yourself lucky
22:43:45 * Orclev agrees with kmc
22:44:09 <kmc> personally i have an irrational loathing for every internet meme that became popular after some particular arbitrary point in time
22:44:09 <m4ik3ru> kmc: I'm trying to maintain some semblance of purity in y'all's eyes...
22:44:20 <kmc> we are all about purity here
22:44:25 <kmc> purity of essence
22:44:26 <m4ik3ru> HAH!
22:44:30 <m4ik3ru> lol haskell pun
22:44:33 <kmc> yup
22:44:42 <m4ik3ru> i love you guys
22:44:45 <m4ik3ru> and i love puns
22:46:04 <Orclev> ok, I need to get to bed, it's nearly 2 am and I'm got to be walking out the door at 8 am... man tomorrow is going to suck
22:46:14 <m4ik3ru> Orclev: same
22:46:18 <m4ik3ru> night all
22:46:29 <kmc> night
23:01:05 <Makoryu> > utf8encode '™'
23:01:25 <Makoryu> :/
23:01:42 <mauke> U+2122 (e2 84 a2): TRADE MARK SIGN [™]
23:02:19 <Makoryu> Ah, I didn't think to check a table
23:02:22 <Makoryu> Thanks
23:03:28 <ivanm> WAKE UP LAMBDABOT!
23:16:05 <donri> i read that composition is defined as "f . g = \x -> f (g x)", could it not simply be "f $ g"? *probably missing something fundamental*
23:16:52 <Lemmih> donri: See how 'f g x' is different from 'f (g x)'?
23:17:17 <donri> "(f g) x" right?
23:17:41 <mauke> f $ g is just f g
23:17:42 <Lemmih> donri: '(f g) x' /is/ 'f g x'.
23:17:53 <donri> but "f $ g x" is "f (g x)", right?
23:18:02 <donri> oh, i thought currying would figure it out.
23:18:12 <donri> Lemmih: yes, that was my point
23:48:39 <holmak> Is there anything like SciPy or matlab's plotting for Haskell?
