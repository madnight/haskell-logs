00:00:07 <jargonjustin> lpsmith: too some extent, I'm misusing "strict" when I really mean "fast"
00:00:15 <lpsmith> taking something and writing it in CPS makes you define an evaluation order, either lazy or strict
00:00:52 <jargonjustin> Although, I'd need to not break the current strictness semantics of the module (something I'm not sure how to verify)
00:01:20 <lpsmith> the CPS State monad can treat the state lazily,  but it does produce the result strictly
00:01:44 <lpsmith> However you can recover lazy results via mapCont
00:03:30 <lpsmith> you might be interested in the adaptive state monad
00:04:00 <lpsmith> that treats both it's result and the state strictly
00:04:24 <lpsmith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4458
00:04:47 <jargonjustin> lpsmith, that looks absolutely wonderful
00:05:35 <lpsmith> there is a lot of miscellaneous bookkeeping with lazy evaluation
00:05:44 <lpsmith> but it can be fast when used appropriately
00:05:56 <lpsmith> much faster than strict evaluation, evel
00:06:30 <lpsmith> strict evaluation has less bookkeeping overhead,  but it can do arbitrarily more work
00:07:08 <lpsmith> or it might demand that a whole bunch of work be done at once,  before anything useful is returned
00:07:13 <jargonjustin> lpsmith: I'm using this in the context of parsing a lazy ByteString where the parsed semantics are a list of "packet" objects. I'd like the list of packets to be lazily evaluated (so it parses packets on demand) but the packet themselves to be strict
00:07:32 <lpsmith> lazy evaluation can return bits incrementally,  using more of a "pay as you go" type strategy
00:07:58 <jargonjustin> So I guess I need a lazy result in general, or an entirely strict parser and I drive the state through at the top level
00:08:12 <jargonjustin> Hmm
00:08:14 <lpsmith> sure,  sounds like it's probably a good approach
00:08:24 <lpsmith> check out mapcont
00:08:48 <jargonjustin> I will, I don't understand how it changes the strictness of the continuation though.
00:08:53 <lpsmith> If you drop the higher-ranked type in the adaptive state monad,  you can get lazy results :)
00:09:04 <jargonjustin> It takes a continuation, and results a continuation that will apply the fuction to the final result, right?
00:09:18 <lpsmith> basically
00:10:44 <jargonjustin> Hmm, the "data UState s :: * -> *" is a GADT for a data type of kind * -> *?
00:10:58 <lpsmith> no,  that's an associated type
00:10:58 <jargonjustin> (in the adaptive state monad declaration of AdaptState)
00:11:14 <lpsmith> (I haven't played with them much, it's one of the newer goodies available in GHC :-)
00:11:49 <jargonjustin> Ah, it's a type families thing... I think I played with something like this in scala...
00:13:34 <lpsmith> if you want to see bits and pieces of mapCont,   my paper in the latest Monad Reader shows a number of examples
00:15:50 <lpsmith> specifically,  check out foldrByLevel'' in listing 30 on page 55,  and compare that to listing 22 on page 50
00:15:57 <jargonjustin> lpsmith: I'll take a look, thanks!
00:16:15 <Fragsworth> Is it possible to run a .hs file without compiling it? Or, equally good, is there a single command that does both compile + run?
00:16:32 <jargonjustin> Fragsworth: try `runhaskell`
00:16:33 <Baughn> Fragsworth: runghc
00:16:40 <Fragsworth> thanks
00:16:56 <Fragsworth> perfect :D
00:17:24 <lpsmith> The trick is that foldrByLevel can traverse an infinite tree,  such as the Stern-Brocot Tree,  when run with the lazy state monad
00:17:39 <Baughn> Fragsworth: You can also stick a #!/usr/bin/env runhaskell on the top of a .hs file
00:17:45 <lpsmith> but doesn't return anything useful when run with the CpSt Monad
00:17:56 <Fragsworth> Baughn: thanks
00:18:14 <Baughn> Fragsworth: Hm. Actually, I think it needs to be .lhs
00:18:33 <lpsmith> however,  foldrByLevel'' uses mapCont,  so it circumvents that issue.  (But can't be run with the lazy state monad,  because it uses mapCont.)
00:18:37 <Fragsworth> Baughn: that seems to work fine
00:21:45 <malcolmw> jargonjustin: seen http://www-users.cs.york.ac.uk/~malcolm/partialparse.html ?
00:22:16 <mrsolo> is there a difference between runhaskell and runghc?
00:22:33 <mrsolo> oh nm just symlink
00:22:50 <Baughn> mrsolo: runhaskell may not be referring to ghc
00:23:16 <Baughn> It's basically a first-come, first-serve sort of thing. Could be you get hugs, or cookies.
00:23:34 <jargonjustin> malcomw: Not specifically, I was looking at attoparsec which provides continuation based incremental parsers over bytestrings. This is similar?
00:23:53 <stanv_> [Int] - is type. [3::Int] - constructor for type [Int]. How is it possible to use same keyword for type and constructor ?
00:25:17 <BMeph> stanv_: Because lists are Special.
00:25:30 <mrsolo> baughn: right better to do runghc then
00:25:53 <stanv_> BMeph: build in type ?
00:26:02 <Baughn> mrsolo: Assuming ghc is what you need, yes. Which, admittedly, is usually the case.
00:26:10 * Baughn has long since given up on writing /portable/ haskell
00:26:40 <malcolmw> jargonjustin: the polyparse library (which goes with that paper) is not continuation based, nor does it (currently) work directly over bytestrings
00:26:56 <Baughn> stanv_: Type names and values are in different namespaces; constructors are a kind of value
00:27:02 <SubStack> I can't stand the hugs repl anyways
00:27:06 <Baughn> (A magical kind)
00:27:18 <SubStack> and could never get yhc to work
00:27:42 <jargonjustin> malcomw: Ah, thanks. I'm trying to find a simple way to bolt graceful failures (basically something handleable outside of IO) for Data.Binary.Get, which currently calls error :-/
00:27:51 <jargonjustin> s/for/onto/
00:27:58 <stanv_> Baughn: :((
00:28:36 <malcolmw> jargonjustin: I've been considering developing a binary parser in polyparse for some time now
00:28:47 <Baughn> stanv_: The point is, the parser can tell whether it's a type name or a constructor based on the context, so you can reuse type names for constructor names. Therefore "data Foo = Foo" works.
00:30:19 <jargonjustin> malcolmw: I think there's niches for separate parsers. Not many binary formats need a great deal of generality in their primities. Mine's complicated by needing to handle partially corrupted input, so I need some sort of backtracking.
00:30:30 <lpsmith> jargonjustin:  The existing "get" monad is the lazy variant,  not the strict
00:30:33 <lpsmith> (I think)
00:31:02 <lpsmith> You can simply replace that with a *much* faster monad that's a drop in replacement
00:31:16 <lpsmith> and add the new graceful error handling feature too :-)
00:31:35 <jargonjustin> lpsmith: Mmm, really? The comments indicate that it lifts the monad definition from Control.Monad.State.Strict
00:31:36 <malcolmw> jargonjustin: in polyparse, backtracking is the default, and you mark definitely-non-backtrackable paths with 'commit'
00:31:52 <lpsmith> (I mean, I'm confident that's the lazy variant,  but maybe I'm missing something)
00:31:54 <lpsmith> Hmm
00:32:04 <jargonjustin> malcolmw: right, I'm saying that most of the time I don't need the backtracking, it's really only at the top-level non-terminal
00:32:08 <lpsmith> http://hackage.haskell.org/packages/archive/binary/0.4.3.1/doc/html/src/Data-Binary-Get.html
00:32:17 <lpsmith> ^^ is that what you are looking at?
00:32:36 <jargonjustin> lpsmith: yes... not 100% sure on the version but that's it
00:32:50 <stanv_> Baughn: thanks :)
00:33:05 <jargonjustin> lpsmith: http://hackage.haskell.org/packages/archive/binary/latest/doc/html/src/Data-Binary-Get.html#Get
00:33:25 <lpsmith> heh,  I could rewrite that quite easily myself,  but I'll let you hash it out if you want to learn something :-)
00:33:54 <lpsmith> ahh, there we go
00:34:17 <jargonjustin> lpsmith: well, a pointer in the right direction for a fast monadic state representation would be greatly appreciated
00:34:47 <lpsmith> Yeah,  if you want a low-impact approach,  use the newtype I gave you above
00:34:48 <jargonjustin> My intuitions about the performance of Haskell code are often rather wrong
00:34:56 <lpsmith> mine too :-)
00:35:06 <lpsmith> You slowly get better at it though
00:35:27 <jargonjustin> lpsmith: The continuation newtype?
00:35:32 <lpsmith> aye
00:36:19 <jargonjustin> lpsmith: Alright, I'll start with that. The module comes with nicely setup tests and benchmarks so this shouldn't be all too difficult
00:36:32 <lpsmith> newtype Get a = Get { unGet :: forall r. (a -> S -> Either E r) -> S -> Either E r)
00:37:37 <lpsmith> that would be a drop-in equivalence,  but the forall-ed type implies that you can't implement mapCont,  which means that the result will not be returned lazily
00:37:49 <lpsmith> Which the current version doesn't
00:38:02 <lpsmith> Although the older version does return it's result lazily
00:38:12 <lpsmith> alternatively
00:38:34 <lpsmith> newtype Get r a = Get { unGet :: (a -> S -> Either E r) -> S -> Either E r }
00:38:39 <jargonjustin> lpsmith: I'm not going to worry horribly about breaking the strictness then. If it's strict, I can work around it by optionally returning state and using that to make the top level lazy
00:39:59 <jargonjustin> lpsmith: the forall means the result types of the continuation and the overall function don't need to match?
00:40:19 <lpsmith> no, they need to match
00:40:22 <Tobsan> @pl \(i,e) -> e /= 0
00:40:22 <lambdabot> (0 /=) . snd
00:40:27 <lpsmith> but you cant access them :-)
00:40:44 <lpsmith> Due to parametericity
00:41:05 <lpsmith> For example,  a function  that has type [a] -> [a]
00:41:16 <lpsmith> can reorder elements,  possibly remove some or duplicate them
00:41:31 <lpsmith> but it can't construct new elements of type a
00:41:45 <lpsmith> or go inside and modify any
00:42:02 <jargonjustin> Ah, but forall a. [a] -> [a] can't because the types in the list could actually be different?
00:42:11 <lpsmith> nope
00:42:21 <lpsmith> the elements in the list must still all have the same time
00:42:23 <lpsmith> type
00:42:56 <jargonjustin> Hmm, maybe I'm confusing this with type-class constraints on list elements some how
00:43:00 <lpsmith> (With existential types,  then you could have heterogenous lists.  but not with polymorphic)
00:43:04 <lpsmith> well
00:43:22 <lpsmith> If you add a type class constraint, that gives you a window into the values
00:43:43 <lpsmith> e.g.  :: forall a.  (Num a) => [a] -> [a]
00:44:05 <lpsmith> you could then add elements to construct new values of type a
00:44:24 <jargonjustin> Right, that I understand
00:44:31 <lpsmith> but you are restricted to using *only*  members of the Num class
00:47:54 <lpsmith> hmm
00:48:00 <lpsmith> actually
00:48:17 <lpsmith> newtype Get a = Get { unGet :: (a -> S -> Either E R) -> S -> Either E R }
00:48:24 <lpsmith> that would allow mapCont as well
00:48:35 <jargonjustin> For a fixed result type though
00:48:41 <lpsmith> and not change the kind of Get
00:48:43 <lpsmith> of course :-)
00:58:42 <Fragsworth> what's the most prominent language reference for Haskell on the web?
00:59:29 <Fragsworth> I mean is there an "official" reference
00:59:45 <lpsmith> the H98 report,  and the GHC User's guide
00:59:51 <lpsmith> and papers
01:00:08 <lpsmith> (especially when it comes to documenting various language extensions)
01:31:28 <hackagebot> wxdirect 0.11.1.4 - helper tool for building wxHaskell (KidoTakahiro)
01:34:30 <hackagebot> hs-ffmpeg 0.2.3 - Bindings to FFMPEG library (VasylPasternak)
01:42:28 <pozic> I want to have x = unsafePerformIO(readFile "blah") return a different result in ghci when I change the blah file. Is that possible?
01:42:50 <pozic> It only needs to return a different result after a :r.
01:43:22 <pozic> One might even argue that this is a bug, since loading and reloading is not equivalent in semantics.
01:43:32 <hackagebot> ffmpeg-tutorials 0.2.1 - Tutorials on ffmpeg usage to play video/audio (VasylPasternak)
01:47:40 <jargonjustin> pozic: What's wrong with: x <- readFile "blah" ?
01:47:47 <mmorrow> pozic: x() = unsafePerformIO(readFile "blah")  ......      x()::String
01:49:43 <c_wraith> :t rnf
01:49:44 <lambdabot> forall a. (NFData a) => a -> Done
01:58:45 <GogloomUser> ?
02:04:43 <mfwitten> You guys need to make a browser with haskell so that we don't get all of these memory leaks.
02:04:51 <mfwitten> (firefox)
02:05:17 <Dema_> mfwitten, there will be space leaks... :)
02:05:22 <HugoDaniel> hi
02:05:33 <Botje> mfwitten: there's uzbl bindings iirc :P
02:05:37 <HugoDaniel> this is not entirely related to haskell, but i would like to share the link w/ you guys: http://www.joelonsoftware.com/items/2009/09/23.html
02:05:42 <HugoDaniel> (and girls)
02:06:02 <mfwitten> Dema_: :-/
02:07:15 <mfwitten> Botje: That might be interesting. However, I don't like the fully distributed (unixy) nature of uzbl; that seems overly inefficient.
02:07:46 <Botje> what's wrong with unixy ? :P
02:11:41 <dqd> HugoDaniel: Yeah, Coders at Work looks promising.
02:15:37 <mfwitten> Botje: Well, nothing, for the most part. However, it's a waste of time to have to reinterpret the DOM multiple times between different processes; it's bad enough that we have to interpret a human readable DOM (HTML, javascript, etc.) already (servers should serve VM instructions that are already in some low-level machine form, but alas, the web is crap). My problem is that basically you can set up "a uzbl browser" with your own ...
02:15:39 <fr0ggler> hay all - i have a map of Maybes. is there a way to print these out nicely?
02:15:43 <mfwitten> ... customizations and unixy pipes/sockets and then there won't be much need to change things in the long term, so the runtime overhead of such indirection becomes unnecessary overhead.
02:15:47 <mfwitten> (netsplit)
02:16:36 <Dema_> Is there any heap inspector in ghc?.. I need to find out who keeps references to list elements preventing GC to collect it?
02:20:31 <Dema_> I've read RWH but my code is not that simple as f=sum/lenght :) So I'm stuck a little :)
02:22:00 <int-e> I'd start looking at http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#retainer-prof but I have never actually used it.
02:27:36 <Dema_> int-e, Thanks!
02:35:48 <squidsoup> hola - I'm trying to learn me a haskell, and ghci doesn't want to parse this: removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
02:35:50 <squidsoup> any thoughts?
02:36:00 <dobblego> squidsoup, precede it with 'let'
02:36:00 <squidsoup> <interactive>:1:22: parse error on input `='
02:36:05 <squidsoup> ah thank you
02:36:39 <lpsmith> squidsoup:  even better,  put that in a file and load it into GHCi
02:36:50 <lpsmith> You'll find that in general, that's a better means of interaction
02:37:08 <squidsoup> ooh, it has tab completion for defined functions, nifty!
02:37:34 <squidsoup> I think I'm going to enjoy learnin' me some haskell .. giving my shriveled imperative brain a good workout :D
02:39:37 <squidsoup> kudos to the chap that wrote this tutorial.. most entertaining thing I've read since why's poignant guide, may he rest in peace
02:41:21 <Tobsan> squidsoup: which one, learn you a haskell?
02:41:40 <squidsoup> yep
02:45:35 <squidsoup> hmm, the haskell textmate bundle seems a bit.. underdeveloped
02:50:06 <squidsoup> IRC client for Emacs lol
02:51:44 <Jafet> Laughing at emacs is not allowed
02:51:58 <squidsoup> oh yes, it's written is LISP isn't it.. I should know better :)
02:52:00 <ivanm> @slap squidsoup
02:52:00 * lambdabot decomposes squidsoup into several parts using the Banach-Tarski theorem and reassembles them to get two copies of squidsoup!
02:52:18 <ivanm> squidsoup: it's written in elisp; there's no longer a language called LISP
02:52:21 <Jafet> Stupid slap
02:52:30 <ivanm> yeah, we don't want _two_ of him!
02:52:32 <Jafet> We'll have countably infinite squidsoups next
02:52:57 <squidsoup> well, you'll never go hungry.. assuming you enjoy cephalopodic snacks
02:53:22 <Jafet> The axiom of choice, solving world hunger
02:53:27 <ivanm> heh
02:53:51 * ivanm thinks Feynman wouldn't have liked/approved of that theorem...
02:54:36 <Jafet> Name it after him and he'll shut up
02:55:48 <ivanm> heh, I doubt it
02:56:09 <squidsoup> just out of interest, are there any web frameworks being developed in a functional language? I understand that python and ruby both have functional features, but I mean something more along the lines of scala or haskell
02:56:23 <Jafet> Try erlang
02:56:32 <ivanm> there's a story of him trying to refute a topology theorem by stating that it isn't possible to cut up an orange into pieces such that it would be larger than the sun, because you can't make any pieces smaller than an atom
02:56:43 <dobblego> squidsoup, yes I wrote one in Scala
02:56:44 <ivanm> squidsoup: scala has some
02:56:49 <ivanm> heh, was about to mention you dobblego
02:56:51 <squidsoup> wow, neat
02:57:04 <ivanm> squidsoup: of course, there's always happstack, hack, etc. in haskell as well
02:57:11 <ivanm> see hackage for a list of them
02:58:24 <squidsoup> dobblego: what is your project called?
02:58:32 <dobblego> Scalaz
02:59:18 <ivanm> dobblego: though that's not just a web framework, is it?
02:59:32 <squidsoup> looks like a big library
02:59:33 <dobblego> it's everything ever
02:59:36 <ivanm> I thought scalaz was a batteries-included library for scala with a functional orientation
02:59:43 <squidsoup> did you write scalaz.http or the whole thing dobble?
02:59:47 <ivanm> dobblego: in that case, that means you're not going to add any new features? :p
02:59:48 <dobblego> most of it
02:59:57 <ivanm> since it has everything ever? :p
03:00:09 <dobblego> there are some plans for web programming, now with the new changes to Scala type system
03:00:35 <ivanm> dobblego: what new changes?
03:00:46 <squidsoup> I read that the twitter guys have adopted scala
03:00:48 <dobblego> HList can now be written for example, which is very useful for web form field validation
03:01:22 <ivanm> squidsoup: they did a while back IIRC
03:01:54 <ivanm> what are HLists?
03:02:06 <mux> heterogeneous lists
03:02:09 <dobblego> heterogeneous list
03:02:21 <ivanm> which means? :p
03:02:25 <dobblego> we have it in Java if you'd like to look :)
03:02:30 * ivanm notes that gwern has put hardly any documentation in there...
03:02:42 <dobblego> list with elements of varying type
03:02:45 <ivanm> ahhh
03:02:49 <ivanm> so lisp-style lists?
03:03:00 <dobblego> statically checked
03:03:48 <ivanm> that must be an ugly type sig...
03:04:04 <dobblego> yes, type inference is required (sure you don't want to see the Java?)
03:04:16 <ivanm> pretty sure ;-)
03:04:26 <ivanm> dobblego: seeing as how much you hate Java in general ;-)
03:04:45 <dobblego> I don't love/hate languages; I just observe them for what they are
03:04:53 <squidsoup> are you seeing a lot of java devs migrating to scala?
03:04:55 <squidsoup> and jruby?
03:05:21 <dobblego> yes, to Scala; I've counselled a few people who tended toward JRuby -- I expect many get through though
03:05:55 <squidsoup> I'm rather fond of ruby myself, but I'm just a web developer :)
03:06:12 <dobblego> many of my colleagues used to be as well until I was let loose on them
03:08:55 <ivanm> heh
03:10:55 <ivanm> dobblego: the great FP evangelism plague-bringer!
03:11:16 <dobblego> they asked and I told them they were doomed to fail, they failed, then they asked why
03:11:24 <ivanm> @remember dobblego many of my colleagues used to be [fond of ruby] as well until I was let loose on them
03:11:24 <lambdabot> Nice!
03:11:30 <dobblego> I'd have happily sat in my corner and watched it :)
03:11:47 <squidsoup> one thing I don't understand is that javascript is supposedly a functional language, but javascript variables are mutable - isn't that a requirement in functional programming, that there are no side effects?
03:12:02 <dobblego> squidsoup, that depends what you call a functional language
03:12:23 <dobblego> squidsoup, often a distinction is made by referring to *pure* functional languages (Haskell, ...)
03:12:36 <ivanm> Excel is apparently a functional language...
03:12:37 <squidsoup> ah I see
03:12:42 <squidsoup> Microsoft Excel?
03:12:47 <ivanm> (though would it be better to call it FRP?)
03:12:52 <ivanm> squidsoup: yeah, and spreadsheets in general
03:12:56 <squidsoup> O.o
03:13:04 <dobblego> let a1 = 7; let b2 = a1 + 8
03:15:21 <dolio> If mutable variables preclude a language being "functional", then a lot of languages people apply the term to aren't.
03:16:12 <ivanm> you could argue that no language is functional then, since they all have the ability to mutate variables in IO
03:16:20 <ivanm> (well, those that can actually have running programs...)
03:18:19 <dolio> There's Charity, I guess. I never used it, but I think I heard in passing that they never bothered to implement IO for it. :)
03:19:46 <dolio> Which isn't surprising given the area it's in, I guess. I never use I/O in Agda, either.
03:21:23 <paolino> How to resolve starvation in STM ?
03:22:31 <ivanm> paolino: by making sure you have enough food
03:22:32 <ivanm> ;-)
03:22:35 <dolio> Don't write long transactions?
03:22:37 <paolino> I cannot avoid it when I implement serialization
03:22:48 <ivanm> dolio: so how do you actually do anything in Agda?
03:23:07 <paolino> ivanm :)
03:23:45 <dolio> ivanm: I mainly play with either formalizing math, or proving stuff about algorithms.
03:23:46 <paolino> dolio : serialization in inherently long
03:24:03 <hackagebot> graphviz 2999.5.1.1 - GraphViz bindings for Haskell. (IvanMiljenovic)
03:24:31 <dolio> That just requires writing functions that type check.
03:25:19 <ivanm> dolio: so you don't actually run anything?
03:25:24 <dolio> Also, you can have Agda evaluate terms to normal form and display them. That's similar to ghci.
03:25:40 <dolio> I mean, it uses IO under the hood, obviously, but none of my code does.
03:25:55 <flux> ivanm, can't you just get a copy of the data and then serialize that, outside transaction?
03:26:17 <ivanm> flux: hmmm?
03:26:25 <ivanm> dolio: so no _explicit_ IO?
03:26:47 <dolio> ivanm: Well, I mean the Agda runtime uses IO to interact with emacs and stuff.
03:27:08 <paolino> flux: I need to copy what is inside every TVar/Tchan at the same time
03:27:24 <flux> ivanm, I'm just talking in the principle level, I've done vary little Haskell, not to mention STM :)
03:27:45 <ivanm> flux: I've done very little STM ;-)
03:27:55 <ivanm> let alone serialisation, etc. ;-)
03:28:06 <dolio> So it's not my stuff that's doing IO, it's a program that does IO telling me results about my pure functions.
03:28:14 <paolino> flux: it was my question :)
03:29:12 <flux> oh :)
03:30:15 <ivanm> dolio: cheater ;-)
03:30:41 <dolio> :)
03:30:57 <PetRat> @unmtl StateT Int []
03:30:58 <lambdabot> err: `StateT Int []' is not applied to enough arguments, giving `/\A. Int -> [(A, Int)]'
03:31:04 <PetRat> @unmtl StateT Int [] a
03:31:04 <lambdabot> Int -> [(a, Int)]
03:31:25 <dolio> Well, I'm not sure if you wrote "fibs = fix $ (0:) . scanl (+) 1" in a file and compiled it, you'd say it's doing IO.
03:31:29 <PetRat> @unmtl StateT [a] [] a
03:31:29 <lambdabot> [a] -> [(a, [a])]
03:32:44 <PetRat> Would it make any sense to have a ListT monad transformer: one that puts a list monad around an inner monad?
03:36:21 <doserj> @unmtl ListT m a
03:36:22 <lambdabot> m [a]
03:46:07 <Crusty84> Hi everybody, I was reading on some pointer usage in wxHaskell. And I do not understand some code completely. The function:
03:46:11 <Crusty84> withObjectRef :: String -> Object a -> (Ptr a -> IO b) -> IO b
03:46:11 <Crusty84> withObjectRef msg obj f
03:46:11 <Crusty84>  = withObjectPtr obj $ \p ->
03:46:11 <Crusty84> 	withValidPtr msg p f
03:46:28 <Crusty84> with Objecttr having the type : withObjectPtr :: Object a -> (Ptr a -> IO b) -> IO b
03:46:37 <Crusty84> what does the $ \p do in the withObjectRef?
03:46:58 <Botje> that's the Ptr a you get
03:47:13 <Botje> $ is just a way of avoiding parens
03:47:31 <Botje> it's equivalent to withObjectPtr obj ( \p -> withValidPtr msg p f)
03:48:03 <Botje> so inside that lambda, the p is of type Ptr a
03:48:27 <Crusty84> Not of (Ptr a -> IO b)?
03:48:55 <Crusty84> How do you know it is the type Ptr a?
03:50:43 <Crusty84> The type of p  should be (ptr a -> IO b)? Because p is the argument left given... right?
03:51:45 <doserj> Crusty84: (\p -> withValidPtr msg p f) is the second argument given to withObjectPtr, so ( \p -> withValidPtr msg p f) has type (Ptr a -> IO b)
03:52:06 <stanv_> is it possible to write constrains for `data' types ?
03:52:08 <doserj> Crusty84: that means, p has type Ptr a
03:52:47 <lilac> Crusty84: withObjectPtr :: Object a -> (Ptr a -> IO b) -> IO b. so "withObjectPtr obj" is a function expecting an argument of type Ptr a -> IO b.
03:53:20 <lilac> Crusty84: (\p -> foo p) is a way of defining an unnamed function which takes an argument p and returns foo p.
03:53:34 <lilac> in this case, that function will need to be of type Ptr a -> IO b, and indeed it is
03:53:47 <brianB> hello
03:54:17 <bastl> is the pastebin on moonpatio.com down for longer?
03:54:20 <lilac> (because p is of type Ptr a, and foo p is of type IO b)
03:54:35 <Crusty84> ahh ok lilac. I understand now I think :)
03:55:01 <Crusty84> I always have to get used to the use of the \
03:55:24 <stanv_> :(
03:56:08 <bastl> i have a ugly local function to compare a string with a monadic value. Can i make this look nicer? its unreadable, IMHO.
03:56:09 <bastl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9771#a9771
03:56:15 <brianB> I seem to have a problem with Haskell's type sytem; I defined a class which (among others) has a findFilter function, which needs to be defined to take an instance of Eq and a instance of the class, and returns a bool - true if the Eq instance matches a member of the class instance:
03:56:16 <brianB> class (HTML c, LaTeX c) => Card c where
03:56:16 <brianB>   findFilter :: (Eq a) => a -> c -> Bool
03:56:44 <opqdonut> bastl: how about "liftM (==s) $ widgetGetName w"
03:56:47 <stanv_> is it possible to ask in clases that types must have certain constructors ?
03:57:50 <brianB> now, when I try to make an instance of the class, defining, eg. "  findFilter x = (==) x . lid " or " findFilter x = isInfixOf x . name, I'm getting an error about not being able to match expected a against inferred Int, saying a is a rigid type variable bound by findFilter...
03:57:51 <opqdonut> stanv_: no, not really
03:58:01 <bastl> opqdonut: better, but still. slices are also not the easiest thing in haskell (i have problems to understand something like that *quickly*)
03:58:04 <opqdonut> stanv_: but you can add functions to the class with certain type sigs
03:58:08 <brianB> does anybody know how to fix and avoid this error?
03:58:12 <opqdonut> stanv_: which are "meant" to wrap the constructors
03:58:42 <stanv_> opqdonut: wrap. hm...
03:59:16 <opqdonut> stanv_: i mean, like "class Foo a where cons :: Int -> Bool -> a; Instance Foo (Int,Bool) where cons = (,);"
03:59:25 <opqdonut> if you see what i mean
03:59:36 <opqdonut> that's effectively like requiring a constructor
04:00:02 <doserj> brianB: your class declaration says that findFilter works for all types a (as long as they are Eq). But in your instance declaration, it only works for a particular a (depending on c)
04:01:02 <stanv_> opqdonut: class Foo a where Cons :: Int -> Bool -> a;" - incorrect, right ?
04:01:19 <opqdonut> stanv_: yes
04:01:22 <doserj> brianB: you can try using MPTCs and FDs for that: class (HTML c, LaTeX c, Eq a) => Card c a | c -> a where ...
04:02:01 <brianB> how do I avoid this? the idea is that the class includes some functions to find and edit data in a list, all with functions that needn't be defined on instantiation... the only thing the user needs to define is a simple function, which in effect defined what the "key" of a list of instances is
04:04:30 <stanv_> opqdonut: so it is impossible write polimorphic functions for. foo :: Either a b -> Int ? like: foo (Some class that require Either cons a) => a -> Int, right ?
04:06:28 <opqdonut> stanv_: yeah, basically
04:10:09 <brianB> where can I read more about mptc and fd's ?
04:11:53 <bastl> here are two alternatives of the same (monadic) code: which one is more readable?
04:11:54 <bastl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9772#a9772
04:13:18 <FunctorSalad> brianB: should an Instance for "carb Foo" require findFilter to be polymorphiv over all a with (Eq a)?
04:13:38 <FunctorSalad> (which is what your original declaration says)
04:14:47 <FunctorSalad> brianB: I don't see anything wrong with your instance declaration though...
04:15:00 <FunctorSalad> (disable the monomorphism restriction?)
04:15:40 <brianB> hmm it should work with one instance of Eq, and which one that is should be known on instantiation - for example, one instance of Card might use a numeric ID, and the function should work on Int (nothing else for this instance).. another instance might use names and thus work with Strings..
04:16:04 <FunctorSalad> or wait, are "lid" and "name" polymorphic?
04:16:27 <FunctorSalad> brianB: ah, then you want doserj'g multi-param typeclass indeed
04:16:31 <brianB> it sounded trivial to me - define a class polymorphic, and then specify the instances for one type
04:16:32 <FunctorSalad> *doserj's
04:17:04 <brianB> no... lid and name are record syntax
04:17:07 <FunctorSalad> brianB: since the "a" is not a parameter of the class, it is assumed to be universally qualified
04:17:41 <FunctorSalad> (as in "an instance must work for every a with (Eq a)")
04:18:21 <doserj> brianB: another way is to use associated types: class (HTML c, LaTeX c) => Card c where type Key c ; instance Card Foo where type Key Foo = Int ; ...
04:18:27 <bastl> no opinions about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9772#a9772 !?
04:19:09 <doserj> bastl: how about the version using =<<?
04:19:27 <int-e> bastl: I like the first one better, and would consider using =<<, too.
04:19:50 <Crusty84> Mmm... I'm still wondering about something regarding the anonymous use of functions.. I rewrote the previous code to something without dollar signs and I think I still miss some arguments??
04:19:54 <Crusty84> withObjectRef "choiceAppend" _obj $ \cobj__obj ->
04:19:54 <Crusty84>     withStringPtr item $ \cobj_item ->
04:19:54 <Crusty84>     wxChoice_Append cobj__obj  cobj_item
04:19:58 <Crusty84> foreign import ccall "wxChoice_Append" wxChoice_Append :: Ptr (TChoice a) -> Ptr (TWxString b) -> IO ()
04:20:00 <Crusty84> to
04:20:04 <Crusty84> withObjectRef "choiceAppend" _obj ( \cobj__obj -> withStringPtr item ( \cobj_item -> wxChoice_Append (cobj__obj) (cobj_item)  ) )
04:20:04 <Crusty84> foreign import ccall "wxChoice_Append" wxChoice_Append :: Ptr (TChoice a) -> Ptr (TWxString b) -> IO ()
04:20:35 <Crusty84> To my opinion i still have to arguments for the \cobj__obj and \cobj__item...?
04:21:13 <bastl> ok, thanks
04:21:14 * kowey hopes Crusty84 is in the middle of patching wxHaskell :-)
04:21:56 <Crusty84> I'm working on wxHaskell for making a `spinn-off' of wxHaskell which uses the Adobe Flash player instead of wxWidgets :)
04:22:02 <kowey> ever so close to "cabal install wx" just works happy-time
04:22:48 <kowey> hmm, think you might be interested in the common library so that people can just program one way and plug wxHaskell/gtk2hs/your work in at will?
04:23:02 <kowey> I don't know how feasible that is; I do know there is some DNA flowing back and forth
04:23:23 <kowey> (oh and throw qtHaskell in along the way)
04:23:36 <int-e> Crusty84: I don't understand the question. The two pieces of code look equivalent to me.
04:24:34 <Crusty84> They are int-e. But when I read the function it still requires some arguments that need to be given to fill in the \cob_1 and \cobj_2 lambda's so the speak. Or is my reasoning wrong?
04:24:37 <ivanm> Crusty84: that sounds evil...
04:24:52 <ivanm> why would you want to use flash player widgets?
04:24:59 <int-e> Crusty84: the with* functions do that.
04:25:00 <ivanm> or are you working on a Haskell -> Flash converter?
04:25:51 <Crusty84> I'll answer you question later ivanm
04:25:55 <int-e> > let withInt f = f 42 in withInt succ -- something like this, but more useful.
04:25:56 <lambdabot>   43
04:26:06 <Crusty84> but first, int-e. There is no let binding in the function :)
04:26:24 <ivanm> Crusty84: OK
04:26:26 <int-e> > let withInt f = f 42 in withInt (\x -> x + 1) -- or perhaps like this.
04:26:27 <lambdabot>   43
04:27:06 * ivanm is more interested in a kind of "I can't believe people are that stupid" kinda way in which you can't tear your eyes away than in being interested in actually writing flash code
04:27:09 <ivanm> no offence Crusty84
04:27:48 <int-e> Crusty84: but the functions are defined somewhere, and they take a function as an argument, filling the 'hole' that you seem to perceive.
04:28:06 <Crusty84> I don't completly understand what you are meaning ivanm...
04:28:17 <Crusty84> I think the hole lies in the foreign import ccall then int-e
04:28:51 <int-e> Crusty84: oh? But you call that with two arguments. Maybe I still don't understand the question.
04:28:51 <ivanm> OK, how about like watching a car fall off a cliff...
04:29:07 <SamB_XP> ivanm: youtube!
04:29:16 <int-e> Crusty84: (the arguments are cobj__obj and cobj_item)
04:29:35 <ivanm> SamB_XP: heh, or stupid people on youtube
04:29:42 <ivanm> though I usually avoid those
04:29:55 <SamB_XP> actually, I meant that there are probably such films on youtube
04:30:07 <SamB_XP> you know, of cars falling off cliffs
04:31:21 <Crusty84> int-e: The arguments the the FFI function are indead cobj__obj and conj_item. But they are declared as lamda's in the example, so they have to be bound somehow. Such as in the example: isInAny2 needle haystack = any (\s -> needle `isInfixOf` s) haystack. Where haystack is \s in this case
04:31:27 <int-e> Crusty84: withObjectRef "choiceAppend" _obj f  creates a pointer value, calls f with that pointer value as its argument, and makes sure that the pointer is still valid when f returns, and not garbage collected in the meantime. (that's why it's done with a wrapper like this). In your case, f is (\cobj__obj -> ...), so cobj__obj becomes the pointer created by withObjectRef.
04:32:03 <Crusty84> Ahh ok. Now i understand int-e :)
04:32:15 <int-e> and in that sense it's equivalent to the withInt example above - x becomes the int created by withInt (namely, 42).
04:32:28 <Crusty84> The toughts were somewhat fuzzy in my mind. You made them much clearer now :)
04:32:32 <brianB> doserj: thanks! the associated types fixed my problem easily and elegantly... strange thing I never heard of them before, but then again i'm still very much a beginner i'm afraid
04:33:17 <Crusty84> Ok, now back to you ivanm. You were wondering why i use Flash widgets instead of the wxWidgets?
04:33:18 <brianB> MPTCs and FDs sound interesting too, once this is finished I might look into that subject as well
04:33:34 <Crusty84> and If  i was using a Haskell -> Flash converter or not
04:33:57 <Crusty84> That was right ivan-m?
04:34:34 <SamB_XP> Crusty84: are you using YHC, perhaps ?
04:35:13 <Crusty84> SamB_XP No i'm using GHC
04:35:22 <hackagebot> RefSerialize 0.2.4 - Write to and read from Strings maintaining internal memory references (AlbertoCorona)
04:35:38 <SamB_XP> I didn't know GHC had an ECMAscript backend!
04:35:45 <Crusty84> No it hasn't
04:36:02 <SamB_XP> so how does it work, then ?
04:36:40 <Crusty84> The library communicates with the Flash player, just in the same way as wxHaskell communicates with wxWidgets. However, I don't use the FFI, but network sockets for communication
04:37:21 <Crusty84> In the Flash player, we have a Flash application, that receives and executes the commands and sends reponses back to the adjusted wxHaskell library
04:37:23 <hackagebot> Workflow 0.5.5 - library for transparent execution of interruptible computations (AlbertoCorona)
04:37:54 <Crusty84> So intstead of calling functions in wxWidgets. I call functions in the Flash Player
04:38:56 <Crusty84> The basic idea is very simple, the implementation however has some drawbacks
04:40:13 <ivanm> Crusty84: yup
04:40:33 <ivanm> does that actually work though? :o
04:40:47 <ivanm> so you're trying to use flash as a front end for your app, and haskell for your backend?
04:40:58 <Crusty84> Your correct ivanm
04:41:00 <Crusty84> And it does work
04:41:09 <Crusty84> I've implemented a very small subset of features of wxHaskell
04:41:10 <ivanm> heh, that makes reasonable sense then
04:41:15 <SamB_XP> ivanm: why wouldn't it work?
04:41:29 <ivanm> SamB_XP: I thought he wanted a Haskell -> Flash converter/compiler
04:41:39 <ivanm> (though why use flash for your front end?)
04:41:43 <Crusty84> However, as I said there are still some drawbacks
04:42:00 <SamB_XP> maybe he wants to run the UI on a client computer?
04:42:11 <Crusty84> The flash player is installed on > 95% procent of all internet capabale machines and wxWidgets or any software as such is not
04:42:25 <ivanm> true
04:42:29 <SamB_XP> Crusty84: well, that didn't stop bittorrent from using it back in the day!
04:42:41 <ivanm> (though I personally find that a bad thing...)
04:42:52 <Crusty84> what do you find a bad thinig?
04:43:05 <ivanm> that flash is so prevalent
04:43:18 <SamB_XP> you prefer silverfish?
04:43:22 <ivanm> hell no
04:43:26 <SamB_XP> is that the name ?
04:43:31 <ivanm> yeah
04:43:32 <Crusty84> silverlight ;)
04:43:37 <SamB_XP> oh, right, silverlight
04:43:39 <ivanm> whatever it is :p
04:43:43 <Crusty84> You also got JavaFX as an alternative
04:43:53 <Crusty84> Java, MS all try to imitate Flash nowadays
04:44:10 <ivanm> yay for embedded video in HTML5!
04:44:16 <SamB_XP> I was (a) not remembering the second word of the name and (b) mocking MS by using a name much feared by book-readers
04:44:25 <ivanm> (if only it works better than the mplayer plugin in firefox...)
04:44:34 <ivanm> SamB_XP: how is silverfish mocked?
04:44:46 <ivanm> s/ed/ing/
04:44:51 <SamB_XP> @all-dict silverfish
04:44:53 <lambdabot> *** "Silverfish" gcide "The Collaborative International Dictionary of English v.0.48"
04:44:53 <lambdabot> Silverfish \Sil"ver*fish`\, n.
04:44:53 <lambdabot>    1. (Zool.)
04:44:53 <lambdabot>       (a) The tarpum.
04:44:53 <lambdabot>       (b) A white variety of the goldfish.
04:44:55 <lambdabot> [36 @more lines]
04:44:57 <SamB_XP> @more
04:44:57 <lambdabot>           [1913 Webster]
04:44:59 <lambdabot>  
04:45:01 <lambdabot>    2. one of a variety of insects of the order {Thysanura},
04:45:03 <lambdabot>       especially {Lepisma saccharina}, which may infest houses,
04:45:05 <lambdabot>       and eats starched clothing and sized papers. See
04:45:07 <lambdabot> [31 @more lines]
04:45:07 <SamB_XP> @more
04:45:08 <ivanm> oh, the old default password thingy?
04:45:09 <lambdabot>       {Lepisma.}
04:45:11 <lambdabot>       [PJC]
04:45:13 <lambdabot>  
04:45:15 <lambdabot> *** "silverfish" gcide "The Collaborative International Dictionary of English v.0.48"
04:45:17 <lambdabot> Lepisma \Le*pis"ma\ (l[-e]*p[i^]z"m[.a]), n. [NL., fr. Gr.
04:45:19 <lambdabot> [26 @more lines]
04:45:19 <SamB_XP> ivanm: huh?
04:45:32 <ivanm> wait, I'm thinking of swordfish
04:45:41 <Crusty84> hahaha
04:45:44 <SamB_XP> I just picked a really scary word that sounded a bit like the word I meant
04:46:05 <SamB_XP> anyway, def #2 there is the one I meant
04:46:12 <ivanm> SamB_XP: heh, because of this? http://en.wikipedia.org/wiki/Silver_Fish :p
04:46:43 <Crusty84> Ok. But I think we are wondering of of the subject. What do you think of using the Flash player as a front-end? Would you use it instead of wxWidgets as the front-end
04:46:45 <SamB_XP> ivanm: not particularly based on the wikipedia page ...
04:46:56 <SamB_XP> Crusty84: not really
04:47:05 <SamB_XP> not unless I was hoping to somehow use it remotely
04:47:25 <SamB_XP> or to compile my code to actionscript somehow
04:47:43 <Crusty84> Or distributing your application to people who don't have wxWidgets installed
04:47:49 <SamB_XP> heck no
04:47:57 <ivanm> Crusty84: if it's a windows app, you can embed wxwidgets (or whatever toolkit you wanted) into the installer, can't you?
04:47:59 <SamB_XP> I'd just bundle the DLL for Windows users
04:48:15 <stanv_> Show that any function of type `a->b' can be transformed into functions of type `a->Either b c' `a->Either c b'.
04:48:16 <SamB_XP> and for other users, I'd let their package managers take care of it
04:48:19 <Crusty84> But not all people can install applications on their pc's
04:48:28 <ivanm> no idea for OS X, but *nix users would either have it or be able to install it easily
04:48:31 <Crusty84> administratitors and such
04:48:46 <xenoblitz> Does it make sense to place a type synonym into a type class? And if so which extension should I enable?
04:49:05 <ivanm> xenoblitz: type families methinks
04:49:12 <SamB_XP> wxwidgets is not an application, and if they can get your program somewhere they can run it, they can surely get the wxWidgets DLL beside it ;-P
04:49:17 <xenoblitz> ivanm: thanks :)
04:49:18 <ivanm> it might make sense, depending on your usage
04:49:43 <ivanm> e.g. instead of multiparam typeclasses or fundeps
04:50:45 <Crusty84> WxWidgets on mobile phones ;)?
04:51:22 <xenoblitz> ivanm: basically I need it to restrict an attribute of a type to a certain family of types
04:52:43 <earthy> on OS X the nice thing to do is to bundle the .so files for wxwidgets inside the .app bundle
04:53:04 <ivanm> xenoblitz: could work, haven't really used it that much to be able to tell you
04:53:20 <SamB_XP> Crusty84: oh, you want to run on mobiles too?
04:53:30 <SamB_XP> Crusty84: I dunno if wxwidgets has ports for them...
04:53:42 <Crusty84> Well sure, we want to target as much platforms as possible. And the Flash player allows that
04:53:51 <ivanm> as much as I hate to admit it, if it's for mobiles then JVM might be a platform to target
04:53:51 <xenoblitz> ivanm: thanks all the same I'll give it a shot
04:54:04 <SamB_XP> well, wxFlash you should make, perhaps?
04:54:19 <ivanm> or else make pure web page based apps
04:54:36 <ivanm> (as in normla web pages, not flash)
04:54:49 <Crusty84> well of course there are a lot of alternatives. I've chosen this as an alternative
04:55:08 <ivanm> Crusty84: though are you sure that wxwidgets is a good basis for a flash widget lib?
04:55:09 <Crusty84> Mostly just to see if you can use the Flash player as a GUI front-end for Haskell application
04:55:17 <ivanm> I've never used it, so I wouldn't know...
04:55:52 <Crusty84> wxHaskell is in my opinion of the the larger and commonly used libraries for creating GUI's for haskell applications
04:56:15 <Crusty84> so why don't take advantage of all the bugfixing and development they have done, and profit from that
04:56:17 <ivanm> I would have thought gtk2hs would be more used nowadays :o
04:57:10 <SamB_XP> yeah, wxHaskell seems almost bitrotted...
04:57:20 <ivanm> I think more unmaintained
04:57:38 <Crusty84> No that's not true. They have recently releases version 0.11.3 I believe
04:57:38 <ivanm> I don't recall any releases from when I started using haskell a few years ago until recently...
04:57:57 <SamB_XP> remind me what that word means?
04:58:07 <ivanm> SamB_XP: which word?
04:58:14 <SamB_XP> "release"
04:58:44 <ivanm> hmmm, maybe not, there were releases all last year
04:58:49 <Crusty84>  January 2009
04:58:49 <Crusty84>     wxHaskell 0.11.0 is released.
04:59:08 <ivanm> SamB_XP: you decide that you want testers^w users to have a crack at the new stuff in your code
04:59:21 <ivanm> so you hgive it an arbitrary number and upload it somewhere (in haskell's case, usually hackage nowadays)
04:59:24 <ivanm> ;-)
04:59:49 <Crusty84> In that case you can call everything in hackage unreleased
05:00:02 <Crusty84> What does released mean in your case then?
05:01:08 <ivanm> Crusty84: huh, how is everything on haskell unreleased by my definition? :s
05:02:26 <Crusty84> Well you say, just give it a number, and upload it to hackage, and people can test away
05:02:38 <ivanm> semi-sarcastically, yes
05:02:40 <ivanm> ;-)
05:02:42 <SamB_XP> Crusty84: he never said that they actually *would* test it
05:02:56 <Crusty84> ahh sarcams, missed that part ;)
05:02:59 <SamB_XP> just that you would desire them to do so
05:05:43 <ivanm> hey, I keep getting bug reports from users of my graphviz library!
05:06:10 <ivanm> (but when I ask for what people would prefer out of several design options, no-one answers... :s)
05:18:01 <sinelaw> PeakerWork, i'm starting to think about graphui using FRP
05:18:52 <PeakerWork> sinelaw: cool, what FRP implementation though?  I see the primary problem of FRP as no working implementations of continuous time FRP's
05:19:25 <sinelaw> PeakerWork, that is the question
05:20:09 <sinelaw> what are the current problems with Reactive?
05:26:29 <PeakerWork> sinelaw: I am not sure. I think Baughn knows that well
05:26:36 <xenoblitz> ivanm: Type Families didn't work out :( to give you a hint of what I am doing:
05:26:37 <xenoblitz> type Links a = LinkFam a => [(a,a)]
05:26:52 <ivanm> xenoblitz: I have no idea ;-)
05:27:02 <PeakerWork> sinelaw: I think it used to have a lot of "unamb" problems. I think that now only the "threads that don't allocate" problem remains, and I think its a rare one that doesn't cause problems in practice (but I am not sure)
05:27:18 <xenoblitz> ivanm: thanks anyways
05:27:32 <ivanm> xenoblitz: np
05:27:38 <ivanm> is there any way of temporarily using a State monad to act as a Read (i.e. I want to be able to pass it to a sub-function that should only be reading the state values, not altering them)?
05:28:12 <ivanm> I don't really _have_ to do this, since I'm the only one who's going to be using this... but still, it might be an interesting thing to do for proof/assurance purposes
05:30:43 <xenoblitz> is there any way to restrict the type required as input by a type synonym to a type class only?
05:30:45 <sinelaw> PeakerWork, for Graphui what i want is to have a DSL that describes the graph with annotations describing how it is presented
05:31:28 <sinelaw> and then have Reactive control the UI
05:32:14 <ivanm> xenoblitz: not by using a type synonym AFAIK
05:32:23 <ivanm> you might be able to do it with a forall though...
05:33:46 <xenoblitz> ivanm: hmmm I guess that makes sense, thanks again, I'll give it a shot
05:36:32 <nainaide> help: I just want use the simplest way to unserstand how to useState Monad, I have a string "abcdefg" , each time  take one char from head, and update the string state. Infact I dont know how to starhttp://hpaste.org/fastcgi/hpaste.fcgi/view?id=9775#a9775, thanks.t
05:37:01 <nainaide> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9775#a9775
05:38:02 <nainaide> Thanks in advance!
05:38:50 <ivanm> nainaide: for starters, you can probably forget the deriving Show
05:38:58 <ivanm> oh, wait, ignore that
05:39:10 <ivanm> (I thought it was a newtype on State for some reason :s )
05:39:12 <nainaide> ivanm, thanks
05:39:15 <ivanm> @src State
05:39:15 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:39:17 <ivanm> gah
05:39:36 <ivanm> IIRC, newtype State s a = State { runState :: s -> (a, s) }
05:39:50 <ivanm> nainaide: obligatory question: is this homework/assignment/whatever?
05:41:06 <pastorn> ivanm: that's correct :)
05:41:14 <nainaide> ivanm, no. I read many examples of state monad, but there are not clear enough, so ,I think this is the simple way for any starter from simple example
05:41:15 <ivanm> hmmmmm.....
05:41:23 <ivanm> right-o then
05:41:33 <ivanm> (note: I've only recently started using State myself :p )
05:41:45 <ivanm> nainaide: OK, the way I see State is as a way of chaining together functions
05:42:02 <ivanm> so that eventually you have one big function of type s -> (s, a) with
05:42:19 <ivanm> which you pass in the parameter for with runState
05:42:41 <nainaide> ivanm, Could you please try to solve my question ?
05:42:45 <pastorn> nainaide: if you can andurstand this: http://paste.lisp.org/display/87620
05:42:51 <pastorn> then you're on your way
05:43:00 <pastorn> (the top one, the bottom one is from a compiler)
05:43:01 <ivanm> nainaide: I prefer the Socratic (?) approach
05:43:03 <ivanm> ;-)
05:44:24 <nainaide> pastorn, thanks, will try
05:44:48 <nainaide> ivanm, thanks way. Ok, let start Socraticly
05:45:13 <ivanm> so, the State monad is a way of chaining together functions
05:45:18 <nainaide> yes
05:45:34 <nainaide> and now I have a string "abcdefg"
05:45:43 <ivanm> no, don't think of it that way
05:45:49 <bastl> How can I make a debian / ubuntu package from a cabal package? I saw "haskell-devscripts" in my synaptic ...
05:45:50 <nainaide> ok, go ahead
05:46:52 <ivanm> each "sub-function" takes in our current state, and returns a new state and something based off that state
05:47:05 <ivanm> what are you wanting your sub-function to do?
05:47:44 <boegel> hiya all
05:47:53 <nainaide> remove the first char of a string
05:47:57 <boegel> what's the status on using Haskell Platform on Snow Leopard (OS X)
05:48:00 * ivanm aimlessly waves his hand in the general direction of boegel 
05:48:03 <boegel> does it work out of the box yet?
05:48:21 <ivanm> nainaide: so, what happens to your state? and what extra value is returned?
05:48:45 <ivanm> boegel: appears so: http://hackage.haskell.org/platform/
05:49:21 <nainaide> ivanm,  the state changed, one char was removed, and the lengh -1
05:49:27 <ivanm> right
05:49:37 <ivanm> so you want to remove the first char; that's what happens to your state
05:49:46 <ivanm> what about a return value? does anything get returned?
05:50:03 <nainaide> a length :: Int
05:50:14 <ivanm> nainaide: OK, so you want the length returned as well?
05:50:21 <nainaide> yeah
05:50:34 <ivanm> I personally would say that's a different function we can do to our state; but first of all let's combine them
05:51:03 <nainaide> ivanm, ok
05:51:25 <ivanm> so, without worrying about the State monad at all, can you write a function that 1) takes in a String, 2) removes the first letter of that String, 3) returns the length of the updated String and the updated String?
05:51:46 <nainaide> ivanm, Yes
05:52:00 <boegel> ivanm:  where does it say it works on 1.06, aka Snow Leopard (/= Leopard, 10.5)
05:52:02 <ivanm> well, write it ;-)
05:52:02 <fr0ggler> hey all - how can I output the contents of a list of Maybes?
05:52:07 <gwern> 'A bit more than a year ago, on a flight from
05:52:07 <gwern> Frankfurt to San Francisco I wrote two interpreters for a trivial
05:52:07 <gwern> subset of Haskell or ML (PCF actually), just big enough for Power,
05:52:07 <gwern> Fibonacci and other classic functions. The following code is a
05:52:07 <gwern> fragment of meta-Haskell. It defines the object language and two
05:52:09 <gwern>  interpreters: one is the typed meta-circular interpreter, and the
05:52:10 <boegel> s/1.06/10.6/g
05:52:11 <gwern> other is a non-too-pretty printer.
05:52:13 <ivanm> boegel: ahh, didn't realise there was a difference
05:52:21 <ivanm> fr0ggler: catMaybe
05:52:21 <boegel> ivanm:  blasphemy!
05:52:26 <ivanm> or catMaybes, don't recall
05:52:29 <gwern> oh good grief. everytime I see an email from Oleg, I have to steel myself
05:52:44 <ivanm> @hoogle [Maybe a] -> [a]
05:52:45 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
05:52:45 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
05:52:45 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
05:52:48 <gwern> but in a way, the existence of Oleg is a little reassuring. it reminds me of that passage from _Cryptonomicon_
05:52:55 <ivanm> nainaide: so what is the function?
05:53:02 <ivanm> gwern: heh, which one?
05:53:09 <gwern> ivanm: today's
05:53:10 <ivanm> (it's been a few years since I read cryptonimicon...)
05:53:19 <ivanm> gwern: no, which passage from cryptonomicon
05:54:21 <gwern> ivanm: oh, it's the one which goes 'every guy secretly thinks that if the right events happened, if drug dealers murdered his family, he could go to China and train and become the baddest-ass in the world...But now that Hiro has met Raven, he no longer thinks that. He knows that Raven is the baddest-ass around'
05:54:35 <ivanm> gwern: that's Snow Crash I think
05:54:39 <ivanm> not Cryptonomicon
05:54:48 <ivanm> hang on, no, you're right
05:55:04 <ivanm> I'm getting Raven mixed up with yet another book, that was my confusion :s
05:55:24 <gwern> oh wait, it is snow crash. I just found the passage
05:55:30 <ivanm> heh, so I _was_ right
05:55:38 <nainaide> ivanm, something like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9776#a9776
05:55:42 * ivanm should stop doubting himself
05:55:59 <gwern> Until a man is twenty-five, he still thinks, every so often, that under the right circumstances he could be the baddest motherfucker in the world. If I moved to a martial-arts monastery in China and studied real hard for ten years. if my family was wiped out by Colombian drug dealers and I swore myself to revenge. If I got a fatal disease, had one year to live, devoted it to wiping out street crime. If I just dropped out and devoted my ...
05:56:05 <ivanm> nainaide: two things wrong: one, the order is wrong; two, it's length, not Length :p
05:56:06 <gwern> ... life to being bad.
05:56:08 <gwern> Hiro used to feel that way, too, but then he ran into Raven. In a way, this is liberating. He no longer has to worry about trying to be the baddest motherfucker in the world. The position is taken. The crowning touch, the one thing that really puts true world-class badmotherfuckerdom totally out of reach, of course, is the hydrogen bomb. If it wasn't for the hydrogen bomb, a man could still aspire. Maybe find Raven's Achilles' heel. ...
05:56:15 <gwern> ... Sneak up, get a drop, slip a mickey, pull a fast one. But Raven's nuclear umbrella kind of puts the world title out of reach.
05:56:17 <nainaide> ivanm, just foud it
05:56:18 <gwern> Which is okay. Sometimes it's all right just to be a little bad. To know your limitations. Make do with what you've got.
05:56:29 <ivanm> but slightly more efficiently: tailString s = let s' = tail s in (length s, s)
05:56:30 <fr0ggler> ivanm, ok - so i do 'in case catMaybes mChildren of [] -> Left $ "blah"' and I'm getting to the Left, even though mChildren is length 1, and I don't really understand why
05:56:36 <ivanm> whoops, that should be (length s', s')
05:56:40 <fr0ggler> (i omitted the Right)
05:57:08 <ivanm> is Snow Crash the one with the freaky meme plot line on a boat?
05:57:22 <nainaide> ivanm, modified
05:58:10 <gwern> ivanm: yes
05:58:19 <ivanm> fr0ggler: you sure it's non-empty?
05:58:22 <ivanm> nainaide: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9776#a9780
05:58:23 <gwern> ivanm: _Big U_ was freakier though
05:58:30 <ivanm> slightly better version IMHO
05:58:37 <ivanm> since you only do the tail once
05:58:39 <fr0ggler> well pretty sure, but i guess it must be empty
05:58:43 <ivanm> gwern: big U?
05:58:46 <gwern> yes
05:58:56 <ivanm> fr0ggler: you could always use trace to check..
05:59:03 <ivanm> gwern: who/what is big U?
05:59:10 * ivanm hasn't read snow crash in a while either
05:59:16 <gwern> a novel by Stephenson, as I thought context made clear
05:59:18 <nainaide> ivanm, yes
05:59:50 <ivanm> gwern: never heard of it
05:59:56 <gwern> most haven't
05:59:58 <fr0ggler> ivanm, hm i did try to use trace, but I couldn't get the syntax (im a Haskell newb)
06:00:06 <ivanm> snow crash and cryptonomicon are the only ones of his I've read IIRC
06:00:25 <ivanm> fr0ggler: I usually use this to help out: tracer a = trace (show a) a
06:00:26 <dschoepe> Anathem is also great, imo.
06:00:33 <gwern> ivanm: but a major plot point centers around Jaynes _The Origin of Consciousness in the Breakdown of the Bicameral Mind_, which is something you should read as well
06:00:43 <ivanm> nainaide: OK, so we have a function of type s -> (a, s), which is what State wants
06:01:30 <ivanm> we can now do wrap it in State: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9776#a9781
06:01:47 <nainaide> ivanm, just dont know
06:01:54 <ivanm> to do this, we call: runState nextStringS "abcdefg"
06:01:56 <nainaide> ivanm,  yes
06:02:07 <ivanm> s/do/run/
06:02:21 <nainaide> just call runState nextStringS "abcdefg" ?
06:02:59 <fr0ggler> ivanm, so this is part of the function im trying to debug: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=3997#a3997
06:03:08 <fr0ggler> where can I stick in that trace?
06:03:17 <ivanm> nainaide: yes
06:03:27 <ivanm> and that should return (6, "bcdefg")
06:03:31 <nainaide> ivanm,  let try! :)
06:04:25 <fr0ggler> do i need to write a new do expression in that Left to carry out both the trace and the error output?
06:05:20 <ivanm> fr0ggler: gimme a minute to finish something off for nainaide, OK?
06:05:27 <fr0ggler> ivanm, sure of course :)
06:05:28 * ivanm can only type one thing at a time :p
06:05:29 <nainaide> ivanm, sure
06:05:38 <nainaide> :)
06:06:40 <ivanm> nainaide: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9776#a9782
06:06:42 <nainaide> ivanm, I got an error  on  Couldn't match expected type `State s a'
06:06:46 <ivanm> :o
06:06:50 <ivanm> nainaide: where?
06:07:19 <nainaide> ivanm, my problem , your code is great!
06:08:02 <nainaide> ivanm, thanks, I think I need some time to understand your code.
06:08:34 <ivanm> nainaide: wait, the last bit has an error
06:09:06 <nainaide> I think this is the best code to understand state monad comparing those StdGen things.
06:09:13 <ivanm> OK, that last one should be ">>", not ">>="
06:09:21 <ivanm> fr0ggler: OK, I'll look at yours now ;-)
06:09:41 <nainaide> ivanm,  I see. THANK YOU!
06:09:42 <fr0ggler> ivanm, that'd be awesome thanks :)
06:09:59 <ivanm> fr0ggler: OK, I'd have "case catMaybes $ tracer mChildren of ..."
06:10:10 <ivanm> that way, you can check that there really is a Just value in there
06:10:20 <ivanm> nainaide: no problem!
06:10:26 <nainaide> :)
06:10:37 <ivanm> this goes towards people like mmorrow helping me out with State the other day
06:10:43 <fr0ggler> ivanm, hmm ok - with that I see: Couldn't match expected type `Char' against inferred type `Maybe (Either String a, Either String b)'
06:10:53 <pastorn> nainaide: did you check that stack monad?
06:10:55 <nainaide> :w
06:10:57 <ivanm> @hoogle trace
06:10:57 <lambdabot> Debug.Trace trace :: String -> a -> a
06:10:57 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
06:10:57 <lambdabot> module Debug.Trace
06:11:07 <ivanm> @type \ s -> trace (show s) s
06:11:08 <lambdabot> Not in scope: `trace'
06:11:15 <ivanm> @type \ s -> Debug.Trace.trace (show s) s
06:11:16 <lambdabot> forall a. (Show a) => a -> a
06:11:26 <pastorn> it's basically the state monad, just a little different
06:11:29 <ivanm> fr0ggler: did you define that tracer function I mentioned before?
06:11:33 <fr0ggler> yup :)
06:11:38 <ivanm> pastorn: how is it different?
06:11:47 <ivanm> fr0ggler: :s that's weird
06:12:04 <ivanm> can you paste up a bit more of the code above and below that bit, as well as the error message?
06:12:12 <fr0ggler> sure
06:12:23 <pastorn> well, pop/get can be done several times in a row, yielding different results
06:12:56 <ivanm> nainaide: so do you see how you can chain the State functions up rather than defining them together like we did with the first version?
06:14:07 <nainaide> ivanm,  still a question in nextStringS' :: State String (), how can  "get" works
06:14:30 <ivanm> @tell mmorrow either I'm not using it correctly, or the Add highlight button on your hpastetwo doesn't work correctly and causes an error :s
06:14:30 <lambdabot> Consider it noted.
06:14:44 <ivanm> nainaide: get is a magic function that returns the state
06:15:12 <ivanm> the next step in learning State monads is to write return and (>>=) yourself
06:15:17 <ivanm> the one after that is to learn get and put
06:15:24 <fr0ggler> ivanm, http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=3997#a3998 - the code is basically just hexpat-pickle
06:15:28 <nainaide> ivanm, yes, a error :   Couldn't match expected type `() -> State String Int' in lengthStringS
06:15:32 <ivanm> nainaide: so, given the type signature of a -> State s a, how would you define return?
06:15:43 <ivanm> nainaide: yeah, as I said: it should be >>, not >>=
06:15:49 <fr0ggler> i'm trying to work out why it's saying it can't find a particular element when im unpickling some xml, when i know for sure the element exists
06:15:55 <ivanm> fr0ggler: the error?
06:15:55 <nainaide> ivanm,  got it
06:16:00 <fr0ggler> ah sorry
06:16:01 <fr0ggler> 2 secs
06:16:11 <ivanm> heh, no probs
06:16:27 <fr0ggler> http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=3997#a3999
06:16:57 <halcyon10> @pl addPairs (a,b) (c,d) = (a+c,b+d)
06:16:57 <lambdabot> addPairs = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
06:16:58 <ivanm> fr0ggler: ahhhh
06:17:24 <ivanm> you need a Show instance for whatever v and k are
06:17:32 <fr0ggler> apologies if this is really simple stuff - i'm debugging some stuff that wasn't written by me as part of this project you see and im finding the imperative->function transition a little tricky ;)
06:17:34 <nainaide> ivanm, return should be return (s , a)?
06:17:46 <ivanm> nainaide: don't forget, it has to be a _function_
06:17:53 <mmorrow> ivanm: are you entering the line number and clicking "Add highlight"?
06:17:53 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
06:18:01 <ivanm> mmorrow: ahhh, that's how it works
06:18:04 <ivanm> nvm then ;-)
06:18:13 <ivanm> I thought it highlighted the given text :s
06:18:14 <mmorrow> :)
06:18:39 <ivanm> nainaide: need to match the type of the inner function: newtype State s a = State { runState :: s -> (s, a) }
06:19:03 <ivanm> nainaide: so, do we actually do anything to the state value?
06:19:20 <nainaide> no
06:19:32 <fr0ggler> ivanm ah awesome ok i added those Show instances for each of the contexts that are affected - lets see what happens :)
06:19:34 <nainaide> byproduct
06:19:49 <ivanm> so, return a = State ( \ s -> ????? )
06:19:57 <ivanm> what are the question marks going to be?
06:20:09 <ivanm> remembering the type we need for the end result has to be (a,s)
06:20:33 <ivanm> mmorrow: though I'm passing on the knowledge you taught me about State, oh wise guru! :p
06:20:41 <nainaide> ivanm, confuse, sorry
06:20:50 <mmorrow> ivanm: :)
06:21:02 <nainaide> ivanm,  return a = State ( \ s -> (s, a) )
06:21:11 <ivanm> nainaide: flip the tuple around
06:21:31 <nainaide> ivanm,  return a = State ( \ s -> (a,s) ) ?
06:21:34 <ivanm> yup
06:21:43 <zezoz2005> http://www.vi2tu.net/uploads/test_14.htm
06:21:49 <ivanm> remember, newtype State s a = State { runState :: s -> (a,s) }
06:21:59 <fr0ggler> ivanm, heh this isn't fun - i'm going to have to change loads of contexts throughout the XmlPickler instance i have
06:22:00 <ivanm> so we have to return the "value" first, _then_ the state
06:22:00 <fr0ggler> :(
06:22:06 <ivanm> fr0ggler: :(
06:22:12 <ivanm> fr0ggler: OK, you could simplify:
06:22:22 <nainaide> ivanm, yes
06:22:37 <ivanm> traceThis s = trace (show $ map (fmap (const ()) s) s
06:22:53 <ivanm> that will print something like [ Nothing, Just () }
06:22:56 <ivanm> s/}/]/
06:23:03 <ivanm> nainaide: right, so we have return down pat
06:23:11 <ivanm> now, how would you define (>>=) ?
06:23:15 <ivanm> @type (>>=_
06:23:16 <lambdabot> parse error (possibly incorrect indentation)
06:23:16 <ivanm> @type (>>=)
06:23:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:23:25 <ivanm> nainaide: in this case, m = State s
06:23:48 <ivanm> so we want something of type: State s a -> (a -> State s b) -> State s b
06:24:18 <nainaide> ivanm, yes, infact I need some time to understand, thanks. :)
06:24:26 <ivanm> nainaide: hint: in this case, we need to use runState a couple of times
06:24:32 <ivanm> nainaide: OK, don't worry about it ;-)
06:24:47 <nainaide> ivanm, thank you !!!
06:24:52 <fr0ggler> sorry ivanm: Couldn't match expected type `a1 -> a' against inferred type `[Maybe (Either String a2, Either String b)]'
06:24:56 <ivanm> for now, just accept that get will return the current state; put will replace the current state and modify will, well, modify the current state ;-)
06:25:02 <ivanm> fr0ggler: gah
06:25:10 <ivanm> fr0ggler: what type is the list?
06:25:19 <ivanm> Maybe (Either a b) or something?
06:25:26 <ivanm> @src Either fmap
06:25:26 <lambdabot> fmap _ (Left x) = Left x
06:25:26 <lambdabot> fmap f (Right y) = Right (f y)
06:25:28 <fr0ggler> yeah i think so :)
06:25:55 <ivanm> try: map (fmap (fmap (const ())))
06:26:10 <ivanm> it appears that the Left values are of type String already
06:26:22 <lilac> or in conal's style: (fmap.fmap.fmap) const ()
06:26:22 <ivanm> actually... that shouldn't matter :s
06:26:32 <ivanm> the point of the function was to replace the Eithers :s
06:27:37 <ivanm> fr0ggler: so you had: "traceThis s = trace (show $ map (fmap (const ())) s) s" and "case catMaybes $ traceThis mChildren" ?
06:27:47 <fr0ggler> yup exactly
06:27:56 <ivanm> lilac: yeah,  I normally wouldn't use quite so many brackets
06:28:31 <ivanm> > show $ map (fmap (const ())) [Nothing, Just const]
06:28:32 <lambdabot>   "[Nothing,Just ()]"
06:28:54 <ivanm> fr0ggler: it typechecks without the trace thingy?
06:29:05 <ivanm> remove it, and check the type of the traceThis function
06:29:31 <ivanm> and the sub bit
06:29:50 <ivanm> trace this should be [Maybe a] -> [Maybe a], and the mapping bit should be [Maybe a] -> [Maybe ()]
06:30:23 <fr0ggler> ivanm, pardon my ignorance - how do I check the type within a source file (only stuff i've read is typechecking in the ghci)
06:30:33 <ivanm> fr0ggler: that's what I meant ;-)
06:30:40 <ivanm> load it into ghci, and do :t foo
06:30:46 <fr0ggler> (i literally took my first look at haskell last friday)
06:30:49 <ivanm> without specifying a type signature in the source file
06:30:50 <ivanm> :o
06:30:53 <fr0ggler> ah ok
06:30:57 <ivanm> and you're trying to do evil XML stuff already? :o
06:31:03 <fr0ggler> yeah :|
06:31:06 <fr0ggler> it aint fun
06:32:39 <fr0ggler> ivanm, type of traceThis: traceThis :: (Show ([a1] -> [()])) => (a1 -> a) -> a1 -> a
06:33:01 <ivanm> :o
06:33:08 <ivanm> what's the source of traceThis?
06:33:13 <ivanm> because that ain't right...
06:33:28 <fr0ggler> traceThis s = trace (show $ map (fmap (const ()) s)) s
06:33:36 <ivanm> @type \s -> Debug.Trace.trace (show $ map (fmap (const ())) s) s
06:33:37 <lambdabot> forall a (f :: * -> *). (Show (f ()), Functor f) => [f a] -> [f a]
06:33:53 <fr0ggler> ah bracket woes
06:33:55 <fr0ggler> 2 secs
06:33:59 <ivanm> yup, about to say that ;-)
06:34:04 <fr0ggler> :)
06:34:47 <fr0ggler> ah better :) traceThis :: (Show (f ()), Functor f) => [f a] -> [f a]
06:35:02 <ivanm> yup
06:35:11 <ivanm> and waddaya know, Maybe is a Functor ;-)
06:35:18 <ivanm> fr0ggler: so, does it work now?
06:35:27 <fr0ggler> building again
06:35:48 <ivanm> fr0ggler: why don't you just try loading the file into ghci and hacking that way?
06:35:54 <ivanm> so you can test each sub-function, etc.
06:35:56 <sinelaw> can someone try to explain why FRP is better than approaches like Signal and Lustre?
06:36:12 <ivanm> (and write smaller functions... your xpElem one seems abnormally big for a Haskell function)
06:36:32 <ivanm> sinelaw: since I'm not that familiar with FRP and I have nfi what Signal and Lustre, I can't ;-)
06:36:51 <fr0ggler> ivanm, well this xml parsing stuff is quite elaborate, and I'm more used to java-like "build, test, repeat" i guess :)
06:37:01 <ivanm> heh
06:37:31 <ivanm> most people here (AFAIK, anyway) generally do a more "interactive" style building: write, load in interpreter, test, repeat
06:37:43 <ivanm> where write is per-function thing
06:37:50 <ivanm> with lots of little re-usable functions
06:37:50 <fr0ggler> ivanm, yeah that does make sense
06:38:46 <sinelaw> also, does anybody know how stable/useable AFRP is?
06:38:50 <ivanm> @time
06:38:51 <lambdabot> Local time for ivanm is Thu Sep 24 23:38:51
06:39:08 <ivanm> fr0ggler: it's time for me to experience a state of unconciousness... any other questions before I collapse? :p
06:39:39 <fr0ggler> ivanm, heh yeah with your trace function, the contents of that list is indeed [Nothing]
06:39:41 <fr0ggler> :)
06:39:54 <sinelaw> i mean YAMPA
06:39:57 <fr0ggler> so I guess I need to dig deeper and understand why - thanks so much for your help though - it's much appreciated!
06:40:04 <ivanm> no worries! ;-)
06:40:08 * ivanm -> land of nod
06:41:26 <saml> > repeat "lo"
06:41:27 <lambdabot>   ["lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo"...
06:41:46 <byorgey> > cycle "lo"
06:41:46 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
06:42:35 * saml fails
06:42:57 <lilac> > zipWith ($) (cycle [(!0),(!1)]) "lo"
06:42:58 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
06:42:58 <lambdabot>         against inferred t...
06:43:04 <lilac> > zipWith ($) (cycle [(!!0),(!!1)]) "lo"
06:43:05 <lambdabot>   Couldn't match expected type `[a]'
06:43:05 <lambdabot>         against inferred type `GHC.Types...
06:43:13 <lilac> huh. :(
06:43:40 <lilac> > zipWith ($) (cycle [(!!0),(!!1)]) (repeat "lo")
06:43:41 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
07:01:10 <int-e> > let bicycle = cycle . cycle in bicycle "lo"
07:01:11 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
07:02:48 <ksf> zomg! there's ghc 6.13
07:02:56 <ksf> but then, where's 6.12?
07:03:21 <int-e> it fell through a crack in space-time
07:03:35 <int-e> hmm "slipped" sounds nicer.
07:04:06 <ksf> me can't decide whether to download the lastest 6.13 or the latest 6.11, assuming that that's the code that's going to be 6.12
07:04:16 <int-e> ksf: more seriously, I expect there's a 6.12 branch now.
07:04:45 <ksf> oh, you're right.
07:04:49 <ksf> it's in the stable archive.
07:05:09 <int-e> (and indeed there is, http://darcs.haskell.org/ghc-6.12/ )
07:10:48 <masak> > reverse show $ product [1..4]
07:10:49 <lambdabot>   Couldn't match expected type `[a]'
07:10:49 <lambdabot>         against inferred type `a1 -> GHC...
07:10:58 <masak> what does the 'a1 -> GHC...' part mean?
07:11:44 <Saizan_> that you used a function where it expected a list
07:11:47 <int-e> GHC.Base.String?
07:12:03 <Saizan_> as the argument of reverse
07:12:25 <Saizan_> > reverse . show $ product [1..4]
07:12:25 <int-e> ghci says: Couldn't match expected type `[a]' against inferred type `a1 -> String'
07:12:26 <lambdabot>   "42"
07:13:26 <masak> ah. that makes more sense. thank you.
07:13:38 <int-e> > reverse show -- same error?
07:13:39 <lambdabot>   Couldn't match expected type `[a]'
07:13:39 <lambdabot>         against inferred type `a1 -> GHC...
07:13:41 <int-e> ok.
07:14:10 <shachaf> > reverse . show . product . enumFromTo 1 $ 4
07:14:10 <lambdabot>   "42"
07:17:11 <int-e> > reverse . show . product . enumFromTo 1 . ($ 4) . ($ id) . ap const const . const id . Just . (\for -> show) $ ()
07:17:12 <lambdabot>   "42"
07:17:46 <alexsura1i> > "42"
07:17:47 <lambdabot>   "42"
07:17:55 <alexsura1i> magic!
07:18:06 <int-e> alexsura1i wins.
07:22:00 <masak> > reverse $ show $ product [1..4]
07:22:01 <lambdabot>   "42"
07:22:19 <masak> is there any reason to prefer 'reverse . show' to 'reverse $ show' ?
07:22:43 <doserj> . makes less line noise than $
07:22:44 <lilac> > (""++) . map (toEnum . (54-) . snd) . filter fst . zipWith ($) (cycle $ map (,) [False ..]) . enumFromTo 1 $ 4
07:22:44 <lambdabot>   "42"
07:23:13 <Botje> masak: i you use . you can easily take out parts of the pipeline and make them into functions of their own
07:23:33 <masak> Botje: I thought it might be something like that. thanks.
07:23:35 <lilac> if you use (.) you can easily take out the LHS of the pipeline
07:23:43 <lilac> if you use ($) you can easily take out the RHS of the pipeline
07:24:24 <masak> ah. cool.
07:24:27 <lilac> f . g $ x -> let h = f . g in h $ x; f $ g $ x -> let gx = g $ x in f $ gx
07:25:01 <lilac> it's often more useful to think and work in terms of functions than in terms of values, so the former transformation is often more useful
07:25:31 <masak> that makes sense.
07:25:41 <burp> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++.--.
07:25:42 <lambdabot>   42
07:26:08 <burp> don't complain :p
07:27:56 * edwardk_ waves hello.
07:28:11 <jmcarthur_work> lambdabot has a brainfuck interpreter?!
07:29:35 <lilac> @bf ++[>+++[>+++[>+++<-]<-]<-]>>++[>--.<-]
07:29:35 <lambdabot>   42
07:29:46 <burp> @bf ++++++++++[>+++++<-]>++.--.
07:29:46 <lambdabot>   42
07:30:45 <int-e> > comparing length "+++++++[>+++++++<-]>+++" "++++++++++[>+++++<-]>++"
07:30:46 <lambdabot>   EQ
07:34:56 <lilac> @bf ++[>+++++[>+++++<-]<-]>>++.--.
07:34:56 <lambdabot>   42
07:35:46 <burp> @bf +++++++[>+++++++<-]>+++.--.
07:35:46 <lambdabot>   42
07:35:53 <burp> hm, I guess thats optimal?
07:35:57 <burp> 7*7
07:36:27 <int-e> 7*7+3 and 5*10+2 are the same length.
07:37:45 <burp> thats true ;)
07:39:00 <MyCatVerbs> 7*7+3 and 5*10+2? I thought you were trying to get to 42, not 52?
07:39:04 <trzkril> ,ord '2'
07:39:07 <lunabot>  50
07:39:08 <tromp> so is 6*9-2
07:39:35 <eyeris> I'm doing something wrong while trying to use regexes. Could someone tell me how my use differs from the example code in the RegexContext docs (in the paste)? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9784#a9784
07:39:35 <MyCatVerbs> Or are you printing the ASCII values of the characters "42"?
07:39:55 <int-e> @bf >+>++>++>+[>[<+++>-]<<]>.--.
07:39:55 <lambdabot>   42
07:40:12 <burp> MyCatVerbs: yes
07:40:23 <int-e> (no, not better.)
07:41:13 <tromp> so is 4*13
07:42:39 <benmachine> what would 5*5*2+2 look like?
07:42:48 * benmachine is not well-versed in bf
07:42:48 <boegel> benmachine: 52? :)
07:43:01 <int-e> +++++[>+++++<-]>[>++<-]>++
07:43:01 <boegel> @bf 5*5*2+2
07:43:01 <lambdabot>  Done.
07:43:06 <boegel> lol
07:43:22 <boegel> @bf
07:43:22 <lambdabot>  Done.
07:43:25 <boegel> @bf +++++[>+++++<-]>[>++<-]>++
07:43:25 <lambdabot>  Done.
07:43:35 <int-e> @bf +++++[>+++++<-]>[>++<-]>++.--.
07:43:35 <lambdabot>   42
07:43:42 <boegel> right
07:43:50 <boegel> 'cause '.--.' is print
07:43:55 <boegel> right?
07:43:58 <benmachine> . is print
07:44:01 <MyCatVerbs> . is print.
07:44:03 * boegel is learning Brainfuck really fast
07:44:08 <benmachine> .--. is print then decrement twice then print again
07:44:19 <benmachine> note that . is putChar . ord
07:44:23 <MyCatVerbs> .--. prints the currently-pointed-at-cell, then the same again minus two.
07:44:49 <benmachine> so you get the ascii character with that value rather than a number
07:44:52 <int-e> benmachine: s/ord/chr/ ?
07:44:53 <MyCatVerbs> Yep.
07:44:57 <benmachine> int-e: yeah
07:45:05 <benmachine> whoops.
07:46:34 <bastl> is someone here experienced with gtk2hs and glade?
07:46:47 <alexsura1i> @bf ++++.--.
07:46:47 <lambdabot>  Done.
07:47:00 <burp> no printable ascii character
07:47:08 <alexsura1i> ah
07:47:25 <benmachine> @bf ++++++++++.
07:47:25 <lambdabot>  Done.
07:47:49 <Makoryu> > chr 32
07:47:50 <lambdabot>   ' '
07:47:55 <alexsura1i> ++++++++++++++++++++++++++++++++++++++++++++++++.
07:47:57 <alexsura1i> woops
07:48:02 <alexsura1i> @bf ++++++++++++++++++++++++++++++++++++++++++++++++.
07:48:02 <lambdabot>   0
07:48:05 <Makoryu> > map chr [32 .. 100]
07:48:06 <alexsura1i> gotcha
07:48:06 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcd"
07:48:28 <bastl> how do i add custom (or predefined) signals in glade? how should they be named in in haskell-source ?
07:48:39 <dcoutts> bastl: you don't do it in glade
07:48:41 <bastl> e.g. "onMyBtnPressed"
07:48:47 <dcoutts> bastl: you do signals in the code
07:49:10 <dcoutts> bastl: see the demos in the the source tarball
07:49:23 <bastl> i do std stuff in my code, but i believe it could be done in glade?
07:49:31 <bastl> (cancel to hide a dialog)
07:49:47 <dcoutts> bastl: no, that doesn't work well in typed languages.
07:49:49 <bastl> adding signals from code works as expected.
07:49:54 <bastl> ah, i see
07:50:14 <dcoutts> bastl: it really only works in C anyway
07:50:25 <dcoutts> because C lets you look up functions by their linker name
07:50:27 <bastl> i used it once in mono iirc
07:50:28 <dcoutts> it's a bit evil
07:50:40 <dcoutts> oh, they're doing something funky then
07:50:42 <bastl> c#
07:50:54 <dcoutts> and probably doing some introspection and dynamic casting
07:50:58 <dcoutts> all rather evil
07:53:03 <eyeris> dcoutts: introspection and dynamic casting are not evil
07:53:19 <eyeris> They are just not in good taste, when you don't have to use them
07:53:23 <eyeris> Some problems require them
07:53:23 <dcoutts> ok, they can be used for evil :-)
07:53:52 <eyeris> Right
07:54:07 <dcoutts> eyeris: I'd like to think there are no problems that require them, it just looks that way sometimes
07:54:48 <eyeris> Well the UI problem at hand is an example of one that has looked that way for a very, very long time then.
07:55:50 <bastl> dcoutts: i feel my code contains too much handmade boilerplate code. Are we using it right?
07:55:51 <bastl> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4015#a4015
07:56:08 <darren^> hi
07:56:22 <darren^> what's a good compiler to use for haskell
07:56:28 <eyeris> ghc is the std
07:56:34 <darren^> thanks
07:56:37 <eyeris> the de facto std
07:56:41 <coldflame23> hugs
07:56:43 <coldflame23> :(
07:56:48 <bastl> perhaps i'm over-optimizing the program ...
07:57:17 <dcoutts> bastl: doesn't look too bad, you could shorten a bit with some helper functions
07:58:01 <bastl> ok, that's clear. but these "helpers" are not there already? (e.g. a general "Action type" )
07:58:03 <McManiaC> hmmmm
07:58:33 <dcoutts> bastl: what would action be other than IO () ?
07:58:46 <bastl> true.
07:59:05 <dcoutts> bastl: I mean for example you could probably shorten the code for connecting up the menus to actions
07:59:13 <McManiaC> show (read "foo" :: ByteString)
07:59:23 <dcoutts> to just a list of pairs of menu name and action
07:59:36 <McManiaC> why do i get a "Prelude.read: no parse" error here? ByteString should be showable?
07:59:38 <bastl> yeah, thats what i was thinking about.
07:59:44 <McManiaC> show/read-able
07:59:44 <dcoutts> bastl: and that might shorten the list of widgets you have to remember and carry about
08:00:10 <dcoutts> bastl: you've got the tools to do that already, no special glade magic is required.
08:00:46 <bastl> ok. so more refactoring to do :-)
08:01:27 <Saizan> > B.pack "foo"
08:01:28 <lambdabot>   Not in scope: `B.pack'
08:02:22 <benmachine> McManiaC: try show (read "foo" :: String) and think about why that fails
08:03:26 <eyeris> What is the type of the exception thrown by List.head []?
08:04:53 <eyeris> I am trying to satisy the type checker: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9785#a9785
08:05:48 <McManiaC> benmachine: huh? whats wrong with that?
08:05:50 <Beelsebob> eyeris: lets see the code
08:05:57 <eyeris> Beelsebob: I just added it to the paste
08:05:59 <Beelsebob> oh, you gave it
08:06:20 <eyeris> I'm pretty sure that it's complaining about the \_ in the second paramter to catch
08:06:26 <Beelsebob> indeed
08:06:28 <Beelsebob> it is
08:06:40 <eyeris> I probably just need to import the module that defines the exception
08:06:48 <Saizan> McManiaC: the "s are part of the representation
08:06:50 <Axman6> can anyone see why these two pieces of code woud give slightly different answers? they should be exactly equivalent from what i can tell
08:06:52 <eyeris> but I don't know how to figure out which type and thus which module
08:06:54 <Beelsebob> no, you need to give the _ a type eyeris
08:06:58 <Beelsebob> the question is ... which type
08:07:06 <eyeris> Right
08:07:06 <benmachine> McManiaC: yeah, you need something like read "\"foo\""
08:07:08 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9787#a9787
08:07:11 <Axman6> btw...
08:07:32 <McManiaC> hmmm
08:07:47 <Saizan> if you just want to convert a String to a ByteString there's Data.ByteString.Char8.pack
08:07:47 <McManiaC> is there a way to convert ByteString to String without those ""s?
08:07:52 <Saizan> but it assumes latin1
08:08:00 <Axman6> McManiaC: unpack?
08:08:12 <benmachine> :t pack
08:08:13 <lambdabot> Not in scope: `pack'
08:08:20 <benmachine> erm
08:08:22 <Axman6> :t L.unpack
08:08:23 <lambdabot> Not in scope: `L.unpack'
08:08:23 <lilac> > read (show "foo" :: String) :: ByteString
08:08:24 <lambdabot>   Not in scope: type constructor or class `ByteString'
08:08:27 <Axman6> :t BS.unpack
08:08:28 <lambdabot> BSC.ByteString -> [Word8]
08:08:33 <benmachine> ah
08:08:42 <lilac> > read (show "foo") :: BS.ByteString
08:08:43 <lambdabot>   "foo"
08:08:54 <lilac> <insert evil laugh here>
08:09:22 <Axman6> is there any reason why a value passed as a parameter should give a different result to the same value being defined in a where clause?
08:09:26 <McManiaC> oh great
08:09:27 <McManiaC> :)
08:10:49 <ziman> unsafePerformIO? :)
08:11:16 <Axman6> nope
08:13:09 <eyeris> Beelsebob: I was able to satisfy the type checker by splitting that lambda out into a named function and specifying the type as Control.Exception.SomeException -> IO ()
08:14:49 <Saizan> eyeris: you could have just done (\(SomeException _) -> ..)
08:15:01 <Makoryu> Axman6: Sure, if stuff is shadowing other stuff and you didn't notice.
08:15:10 <Makoryu> Axman6: Post the context?
08:15:23 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9787#a9787 are the two versions
08:16:02 <eyeris> Saizan: Thanks. I tried (\_::SomeException -> ...) but got an error :)
08:16:43 <Saizan> eyeris: that also works, with ScopedTypeVariables
08:17:28 <Axman6> Makoryu: the reason i want to know is that numerically the results i'm getting are very slightly different, but they're a hell of a lot faster in the second version
08:17:53 <Keiya_> I'm sitting in a precalc class where we're going over the basics of functions. I'm bored. :P
08:18:19 <Makoryu> Axman6: Oh boy, FP arithmetic
08:18:22 <eyeris> Though exceptions just don't seem to make much sense in haskell, because there's only one catch function, so you have to use pattern matching to handle different exception types differently, but then the exception handler can be far removed from the error site
08:18:26 <Axman6> Makoryu: yeah :\
08:18:29 <eyeris> erm, the catch site
08:19:13 <Makoryu> Axman6: Most FP operations are not actually commutative. Particularly when working with very small values, you're likely to see a lot of error creep
08:19:32 <Makoryu> Axman6: Basically, order of operations is extremely sensitive
08:20:06 <Axman6> yeah
08:20:23 <Makoryu> Can't quite see where this is going wrong, though....
08:21:35 <Keiya_> "You can compose functions! where f(t) is the radius of a spherical baloon as a function of time, and g(r) is the volume of a sphere as a function of the radius, what does g . f represent?
08:21:39 <Axman6> yeah, i'm wondering if it would have anything to do with the fact that possibly arguments are treated/compiled differently
08:21:39 * Keiya_ headdesks
08:22:26 <Makoryu> Axman6: Different optimizations are applied, yes
08:22:43 <Makoryu> Axman6: But I don't know which, offhand
08:22:45 <eyeris> Keiya_: The volume of the sphere as a function of time?
08:23:05 <Keiya_> eyeris: Yes. I knew that /before finishing the question/ >_>
08:23:09 <Keiya_> soooo bored >_> thank god for not paying attention in class
08:25:34 <Makoryu> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9787#a9788
08:25:59 <Axman6> good querstion, i'll test
08:26:12 <McManiaC> is there any way to drop (root) user privileges in a running programm? so you can run it as root and then switch to user xy?
08:26:36 <Athas> setuid(2)
08:26:51 <Athas> Uh.  I dunno if there is a Haskell wrapper.
08:27:16 <jmcarthur_work> FFI is your friend :)
08:27:19 <Makoryu> There seems to be: http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-User.html
08:27:50 <Axman6> Makoryu: gives the same asnwers as the other versions, but it's a lot slower strangely
08:28:03 <Makoryu> Axman6: Oh, that's... not good....
08:28:11 <Axman6> not at all
08:28:19 <Makoryu> Wait, they *all* give the same answer?
08:29:15 <Axman6> no, i mean i have a few different versions of the same algorithm, using lists, arrays, and now UVector, and the uvector one gives wrong results when using the second one i listed
08:31:16 <Makoryu> Axman6: Come to think of it, it might be a bug in UVector. There've been a number of those...
08:31:26 <Axman6> yeah
08:31:30 <srush> is there a template haskell library to generate an all maybe type?
08:31:40 <srush> so take Hello Int Int
08:31:53 <srush> and make a HelloMaybe (Maybe Int) (Maybe Int)
08:39:52 <jmcarthur_work> srush, dunno, but maybe your Hello type should be polymorphic instead
08:40:01 <jmcarthur_work> data Hello a = Hello a a
08:40:31 <jmcarthur_work> then you can have Hello Int or Hello (Maybe Int)
08:40:46 <Berengal> Aren't all type constructors polymorphic?
08:41:16 <jmcarthur_work> only if they are actually type constructors
08:41:24 <jmcarthur_work> my impression was that that isn't the case
08:41:27 <Makoryu> Berengal: Type constructors, yes. But what if it's: data Hello = Hello Int Int
08:41:29 <jmcarthur_work> that Hello is just a type
08:42:00 <Berengal> Hello Int Int is a type, but there must be a type constructor Hello :: * -> * -> * for it to exist
08:42:29 <srush> huh
08:42:39 <jmcarthur_work> Berengal, i thought srush was talking about the rhs of the type definition
08:42:48 <jmcarthur_work> but perhaps that was a bad assumption
08:42:51 <srush> so I should do Hello (m Int) (m Int)
08:43:13 <Berengal> jmcarthur_work, he said "type", which I took to mean type, not value...
08:43:21 <srush> and type Id a = a
08:43:26 <jmcarthur_work> Berengal, i took it to be a terminology mistake
08:43:38 <jmcarthur_work> but again, maybe i was assuming too much
08:43:47 <jmcarthur_work> srush, that would be one way
08:43:56 <jmcarthur_work> or you could just have Hello a a
08:43:59 <Berengal> jmcarthur_work, we may never know, or we could ask him
08:44:10 <Berengal> srush, what does the type declaration look like?
08:44:28 <srush> my initial one was data Hello = Hello Int Int
08:44:39 <Berengal> jmcarthur_work, you were right it seems
08:44:45 <jmcarthur_work> Berengal, my mind reading is better than yours ;)
08:44:54 <srush> but now I guess it looks like data Hello m = Hello (m Int) (m Int)
08:45:10 <jmcarthur_work> srush, why that instead of data Hello a = Hello a a?
08:45:15 <McManiaC> uuuh, how can i use sth like "case" with regular guards?
08:45:20 <Berengal> srush, Hello a = Hello a a, or Hello a b = Hello a b, or Hello m = Hello (m Int) (m Int) all work, but work differently
08:45:23 <jmcarthur_work> do you *really* want to require a functor?
08:45:44 <doserj> srush: type Id a = a won't work unfortunately
08:45:46 <srush> I only care about two cases
08:45:51 <srush> one where the types are fixed
08:45:57 <srush> and one where they are all maybe'd
08:46:12 <srush> so Hello Maybe
08:46:19 <srush> and Hello Id
08:46:39 <srush> but as doserj points out Id doesn't work
08:46:45 <Berengal> srush, you could also use GADTs and multiple constructors...
08:46:51 <jmcarthur_work> srush, you can do newtype Id a = Id a, though
08:46:53 <Berengal> depends on your useage
08:47:08 <srush> newtype Id is ok, but kind of lame
08:47:11 <jmcarthur_work> srush, but i still recommend a more polymorphic approach. generality is nothing to be afraid of :)
08:47:26 <srush> jmcarthur_work: I think I disagree
08:47:42 <srush> my type will have tons of parameters
08:47:49 <jmcarthur_work> it does depend on what you are doing, but usually i go with the most general approach and then only make it monomorphic if i decide later that i shouldn't have made it general
08:47:57 <duaneb> yo, could someone take a look at this?
08:47:57 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9789#a9789
08:47:58 <jmcarthur_work> it's just easier to change code when it is more general
08:48:18 <duaneb> It complains that ``Pattern matche(s) are overlapped''
08:48:25 <srush> maybe I misunderstand
08:48:28 <duaneb> err, match(es)
08:48:46 <jmcarthur_work> duaneb, clDeviceTypeCPU is not a constructor
08:48:47 <Axman6> duaneb: complains about which code specifically?
08:48:52 <jmcarthur_work> duaneb, it will match everything
08:49:12 <Axman6> ah, yeah you'll need a guarde
08:49:14 <Axman6> -e
08:49:37 <duaneb>  :(
08:49:37 <duaneb> Axman6: it says in the comments
08:49:40 <srush> if I have constructor (Hello a b c d e)
08:50:22 <srush> then I need to right type NormHello = Hello a b c d e
08:50:23 <Axman6> duaneb: what you've done isexactly the same as saying: case foo of x -> blah; y -> blah;. here x and y will match anything
08:50:31 <jmcarthur_work> duaneb, clDeviceTypeCPU -> ... always succeeds and binds clDeviceTypeCPU to the value of dev
08:51:04 <jmcarthur_work> srush, i don't know what you are getting at, but that won't work
08:51:10 <Axman6> like doing case foo of Just x -> blah, will bind the x to the value in the Just
08:51:40 <srush> data Hello a b c d = Hello a b c d
08:51:54 <srush> type NormHello = Hello a b c d
08:52:07 <jmcarthur_work> NormHello is not defined properly
08:52:28 <srush> sorry, I just being lazy
08:52:29 <jmcarthur_work> a b c and d are free on the rhs
08:52:41 <srush> type NormHello = Hello type1 type2 type3 type4
08:52:46 <jmcarthur_work> no
08:52:48 <int-e> srush: use A B C D ?
08:53:02 <int-e> srush: that way nobody will mistake them for type variables
08:53:03 <eyeris> This regex module, while I'm sure it is capable, is a freaking nightmare.
08:53:03 <jmcarthur_work> oh i see
08:53:11 <srush> type NormHello = Hello A B C D
08:53:14 <jmcarthur_work> yeah i thought those were supposed to be type cariables
08:53:16 <jmcarthur_work> *variables
08:53:27 <srush> type MaybeHello = Hello (Maybe A) (Maybe B) (Maybe C) (Maybe D)
08:53:33 <srush> and I'm back where I started
08:53:46 <eyeris> Regex libraries need to export a simple function that takes two strings and matches one against the other as a regex
08:54:01 <jmcarthur_work> oh i see
08:54:14 <sioraiocht> anyone here at IFL?
08:54:27 <srush> but the functor idea seems reasonable
08:54:35 <jmcarthur_work> srush, okay i agree with your decision that Hello a b c d is probably not so great
08:54:47 <doserj> eyeris: but what do you want as result? all matches, the first match, the positions of the matches, a Boolean, etc?
08:55:11 <srush> ok, cool, thanks for the help
08:55:24 <srush> I'll work on my precision
08:55:26 <int-e> srush: maybe you can define  type FHello f = Hello (f A) (f B) (f C) (f D)
08:55:41 <int-e> (not sure what a good name for that would be)
08:55:59 <jmcarthur_work> srush, i'd do either data Hello f = Hello (f A) (f B) (f C) (f D) or data Hello f a b c d = Hello (f a) (f b) (f c) (f d)
08:56:01 <eyeris> doserj Bool now. I completely understand why the type classes are used.
08:56:20 <eyeris> doserj: It needs to export a function  String -> String -> Bool
08:56:25 <jmcarthur_work> srush, or int-e's suggestion
08:56:30 <eyeris> doserj: Call it simpleMatch or something
08:56:51 <doserj> eyeris: and a couple of other functions, for the other use-cases.
08:56:56 <eyeris> doserj: Right.
08:56:59 <srush> and then use newtype Id a = Id a
08:57:15 <srush> and make it a functor
08:57:30 <eyeris> doserj: as it is now, the API is unusable for someone who doesn't want to look through the source code.
08:57:36 <copumpkin> EMBRACE THE POWER OF THE FUNCTOR!
08:57:42 <duaneb_> Ok, how about this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9790#a9790
08:57:54 <duaneb_> Sometimes doing the simplest of things is way too hard in haskell >.<
08:58:17 <benmachine> srush: or import Control.Monad.Identity and use that
08:58:28 <eyeris> doserj: I can't even figure out how to write the function I describe because the type checker can't infer it
08:58:37 <copumpkin> duaneb_: hard is a function of the person writing the language as well as the language :P
08:59:14 <duaneb_> copumpkin: Perhaps. I feel as if it should be easier to do a basic switch statement/case expression/whatever
08:59:21 <duaneb_> there are too many corner cases in haskell :/
08:59:34 <copumpkin> duaneb_: you didn't even write a base case expression in that code..
08:59:38 <copumpkin> basic
08:59:39 <srush> benmachine: thanks
08:59:47 <benmachine> duaneb_: http://haskell.org/haskellwiki/Case
08:59:49 <duaneb_> copumpkin: what do you mean?
09:00:03 <copumpkin> duaneb_: you wrote guards for something a case or simple pattern match could do more cleanly
09:00:13 <Axman6> copumpkin: you might be interested in the stuff i'm working on atm, making heavy use of UVector :)
09:00:17 <copumpkin> Axman6: ooh
09:00:20 <duaneb_> copumpkin: I used a case before and people yelled at me :P
09:00:21 <Saizan> and it doesn't parse
09:01:30 <Axman6> copumpkin: annoyingly i can't get the code to be any faster than the unboxed array version (which is possibly what UVector is based on?)
09:01:38 * Axman6 checks source
09:01:53 <benmachine> duaneb_: yeah the yelling people were right
09:02:37 <benmachine> but have a look at the page I linked for ways to do what you want in more obvious ways
09:03:21 <duaneb_> :/
09:03:30 <duaneb_> now my program doesn't even run correctly
09:03:53 <copumpkin> duaneb_: if you gave us a bigger chunk of it we could give better suggestions
09:03:53 <duaneb_> I feel as if using haskell to use an api designed for c was a bad decision :(
09:04:14 <Saizan> in pattern matches you can only use contructors, not arbitrary values
09:04:58 <copumpkin> I assumed he had constructors hidden away somewhere in that DeviceType
09:04:59 <benmachine> if you want to match arbitrary values then you want a Map or something similar
09:05:02 <duaneb_> that's not true
09:05:14 <duaneb_> case x of {1->bleh; etc}
09:05:27 <benmachine> literals are magic
09:05:41 <duaneb_> the things I was using are constants!
09:06:00 <benmachine> yes but not literals :P
09:06:06 <copumpkin> you can think of data Int = 1 | 2 | 3 | 4 ...
09:06:14 <benmachine> yeah
09:06:19 <duaneb_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9792#a9792
09:06:22 <doserj> eyeris: something like \ r s -> matchTest (makeRegex r::Regex) s ?
09:06:22 <duaneb_> ok, that the version that compiles
09:06:23 <benmachine> so 1 is sort of a constructor for the Int type
09:06:25 <duaneb_> but fails badly
09:06:33 <duaneb_> it runs for about 5 seconds and then crashes
09:06:43 <eyeris> doserj: that doesn't work
09:07:36 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9790#a9793 <- i'd write it like this, btw
09:07:39 <tromp> > data Int = -9223372036854775808 | ... | 9223372036854775807
09:07:39 <lambdabot>   <no location info>: parse error on input `data'
09:07:57 <tromp> on a 64 bit os
09:08:07 <copumpkin> tromp: yeah, yeah; )
09:08:11 <eyeris> Or, maybe it does
09:08:14 <doserj> eyeris: let f r s -> matchTest (makeRegex r::Regex) s)::String -> String -> Bool works for me (with import Text.Regex.Posix)
09:08:14 <eyeris> I tried that earlier
09:08:29 <eyeris> and it gave me an error about the ::Regex not matching the inferred type
09:08:45 <eyeris> maybe I had placed the ::Regex in the wrong place
09:08:47 <rindolf> Hi all.
09:08:53 <copumpkin> is this using opencl?
09:09:03 <eyeris> Thanks
09:09:12 <duaneb_> copumpkin: yea
09:09:14 <rindolf> I was once shown a short Haskell program for the equivalent of these - http://paste.debian.net/47425/  and http://paste.debian.net/47424
09:09:28 <Axman6> i need to play with the haskell OpenCL bindings. i'm already using OpenCL through the FFI
09:09:29 <rindolf> I split by words and then count the number of occurences of each word.
09:09:41 <rindolf> Can anyone reproduce it?
09:09:43 <duaneb_> Axman6: could you show me some sample code?
09:09:49 <duaneb_> mine is dying write now
09:09:57 <Axman6> duaneb_: of what?
09:10:15 <duaneb_> I think there's an issue with the way I'm fetching device ids
09:10:15 <doserj> eyeris: even f :: Strint -> String -> Bool; f = (=~) should just work
09:10:24 <duaneb_> Axman6: OpenCL via haskell
09:10:38 <duaneb_> or are you not using OpenCLRaw
09:10:49 <Axman6> > map (id *** length) . group . sort . words $ "hello hello test hello blah foo blah"
09:10:50 <lambdabot>   Couldn't match expected type `(b, [a])'
09:10:50 <lambdabot>         against inferred type `[GHC...
09:11:00 <Axman6> :t (***)
09:11:00 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:11:11 <doserj> > "bl*" =~ "blubb" :: Bool -- eyeris
09:11:12 <lambdabot>   False
09:11:13 <Axman6> > map (id &&& length) . group . sort . words $ "hello hello test hello blah foo blah"
09:11:13 <lambdabot>   [(["blah","blah"],2),(["foo"],1),(["hello","hello","hello"],3),(["test"],1)]
09:11:22 <Axman6> > map (head &&& length) . group . sort . words $ "hello hello test hello blah foo blah"
09:11:22 <lambdabot>   [("blah",2),("foo",1),("hello",3),("test",1)]
09:11:34 <Axman6> rindolf: does that do what you're after?
09:11:41 <benmachine> > map (head &&& length) . group . sort . words $ []
09:11:41 <lambdabot>   []
09:11:55 <benmachine> oh that does make sense
09:11:57 <Axman6> duaneb_: i'm writing the functions in C, and using the FFI to interface with them
09:12:09 <doserj> > "blubb" =~ "bl*" :: Bool -- eyeris
09:12:09 <lambdabot>   True
09:12:16 <duaneb_> ah
09:12:19 <duaneb_> ok
09:12:21 <Axman6> benmachine: it scares me a little how quickly i came up with that
09:12:21 <duaneb_> I might do that
09:12:33 <benmachine> Axman6: :P
09:12:44 <rindolf> Axman6: maybe with some IO stuff.
09:12:52 <Axman6> #haskell has broken me. i'm using all sorts of shit that used to scare me :(
09:13:06 <eyeris> yeah, I see doserj
09:13:19 <Axman6> rindolf: i don't read ((((lisp)))), so i couldn't check myself :P
09:13:25 <eyeris> Maybe I will be the one to publish a package with super simple newbie functions :)
09:14:32 <rindolf> Axman6: I need to read this from a file and write it as a list of "$occurences\t$words\n" to another file.
09:15:02 <Axman6> rindolf: well, that code i wrote does most of the heavy lifting
09:15:55 <rindolf> Axman6: ah.
09:16:43 <Justin_> Hello.  Can I ask a simple question of someone?  I'm trying to find a particular list function that I'm sure should exist...
09:16:52 <copumpkin> Justin_: @hoogle! or us
09:16:54 <copumpkin> but ask it :)
09:16:57 <lilac> @type do [infile,outfile] <- System.Environment.getArgs; text <- readFile infile; writeFile outfile . unlines . map (\xs -> head xs ++ "\t" ++ show (length xs)) . group . sort . words $ text
09:16:58 <lambdabot> IO ()
09:17:07 <lilac> rindolf: ^^ completely untested, but that might do what you want
09:17:20 <copumpkin> oh no, an irrefutable pattern!
09:17:23 <rindolf> lilac: thanks.
09:17:56 <lilac> copumpkin: proper error checking seems overkill for a one-liner :)
09:18:07 <Axman6> lilac: looks pretty right to me
09:18:18 <benmachine> it's not irrefutable anyway
09:18:21 <Justin_> copumpkin: Thanks!  I need something to get from say [0.2,0.2,0.2,0.2,0.2] to [0.2,0.4,0.6,0.8,1.0], just summing with intermediate values.
09:18:22 <benmachine> is it?
09:18:41 <copumpkin> Justin_: you could try scanl (+) 0
09:18:43 <lilac> benmachine: no, that's the problem :)
09:18:51 <Axman6> > scanl (+) 0 [0.2,0.4,0.6,0.8,1.0]
09:18:52 <lambdabot>   [0.0,0.2,0.6000000000000001,1.2000000000000002,2.0,3.0]
09:18:59 <copumpkin> > scanl (+) 0 [0.2,0.2,0.2,0.2,0.2]
09:19:00 <lambdabot>   [0.0,0.2,0.4,0.6000000000000001,0.8,1.0]
09:19:02 <Axman6> > scanl (+) 0 [0.2,0.2,0.2,0.2,0.2] -- even
09:19:03 <lambdabot>   [0.0,0.2,0.4,0.6000000000000001,0.8,1.0]
09:19:06 <c_wraith> yay fp error!
09:19:19 <rindolf> lilac: ghc gives me analyze-log.hs:4:0: parse error (possibly incorrect indentation)
09:19:34 <Justin_> copumpkin: That's the one!  Perfect.  I knew it'd be simple.  Thanks for your help.
09:19:40 <copumpkin> :)
09:19:46 <Axman6> rindolf: well it will need proper formatting
09:19:49 <copumpkin> it's more efficient than map sum . tails
09:19:59 <rindolf> Axman6: I tried to add one.
09:20:27 <Makoryu> > map fromRational . scanl (+) 0 . replicate 5 $ 1 % 5
09:20:28 <lambdabot>   [0.0,0.2,0.4,0.6,0.8,1.0]
09:22:40 <lilac> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9795#a9795
09:22:46 <lilac> rindolf ^^ ghc accepts that for me
09:22:56 <rindolf> lilac: http://paste.debian.net/47427/
09:23:32 <lilac> rindolf: you'll need to add 'main = ' to the do if you want to compile it
09:23:46 <rindolf> lilac: ah.
09:24:03 <lilac> and you'll need to import System.Environment (for getArgs) and Data.List (for group and sort)
09:24:33 <lilac> it's slightly strange that sort isn't in the Prelude but unlines is
09:26:01 <Justin_> copumpkin: Sorry, one more q: What if it's a list of pairs, where I want to sum snd but not the fst? So [(a,0.2),(b,0.2),(c,0.2),(d,0.2),(e,0.2)] to [(a,0.2),(b,0.4),(c,0.6),(d,0.8),(e,1.0)] ?
09:27:49 <tommd> rindolf: Working on your log analyzer?
09:28:17 <rindolf> tommd: not really.
09:28:33 <rindolf> tommd: it's just something I wrote a long time ago in several languages.
09:28:34 <tommd> Ah, well, figured I'd say hello
09:28:49 <copumpkin> :t uncurry zip . (second (scanl (+) 0)) . unzip
09:28:49 <lambdabot> forall a a1. (Num a) => [(a1, a)] -> [(a1, a)]
09:29:01 <doserj> > scanl1 (\(a,n) (b,m) -> (b,n+m)) [(a,0.2),(b,0.2),(c,0.2),(d,0.2),(e,0.2)]
09:29:01 <lambdabot>   [(a,0.2),(b,0.4),(c,0.6000000000000001),(d,0.8),(e,1.0)]
09:29:02 <lilac> > tail $ scanl (\(_,c) (x,d) -> (x,c+d)) (undefined,0) [(a,0.2),(b,0.2),(c,0.2),(d,0.2),(e,0.2)]
09:29:02 <copumpkin> Justin_: that's one way of doing it, but not the prettiest
09:29:03 <lambdabot>   [(a,0.2),(b,0.4),(c,0.6000000000000001),(d,0.8),(e,1.0)]
09:29:07 <Makoryu> I wrote a book about aliens. Can I cite this as proof that aliens exist?
09:29:20 <lilac> heh, yeah, scanl1. good idea :)
09:29:20 <copumpkin> > uncurry zip . (second (scanl (+) 0)) . unzip $ [(a,0.2),(b,0.2),(c,0.2),(d,0.2),(e,0.2)]
09:29:21 <lambdabot>   [(a,0.0),(b,0.2),(c,0.4),(d,0.6000000000000001),(e,0.8)]
09:30:12 <rindolf> tommd: hi.
09:30:37 <rindolf> tommd: now it consumes 38.4% of RAM - but it didn't segfault yet.
09:30:55 <tommd> Sounds like you need some strictness annotations
09:31:09 <sdhs> i have this code:
09:31:12 <sdhs> > sum zipWith (*) [0.01,0.02..0.05] [0.9,0.8,0.7,0.6,0.5]
09:31:12 <lambdabot>   Couldn't match expected type `[a]'
09:31:12 <lambdabot>         against inferred type `(a1 -> b ...
09:31:22 <sdhs> er...
09:31:46 <copumpkin> sdhs: dot product!
09:31:46 <tommd> > sum $ zipWith (*) [0.01,0.02..0.05] [0.9,0.8,0.7,0.6,0.5]
09:31:47 <copumpkin> zomg
09:31:47 <lambdabot>   9.499999999999999e-2
09:31:54 <sdhs> aha
09:31:55 <sdhs> well anyway
09:32:02 <sdhs> can somebody make that into assembly for me
09:32:04 <sdhs> i have no idea how to do that
09:32:05 <copumpkin> :O
09:32:08 <Makoryu> sdhs: Wut
09:32:12 <copumpkin> that's what ghc's for
09:32:15 <lilac> sdhs: GHC knows how to do that
09:32:19 * sdhs doens't have ghc
09:32:20 <tommd> sdhs: sdhs: SimonM and SPJ can do exactly that for you using GHC
09:32:21 <sdhs> can't install it
09:32:25 <copumpkin> sdhs: why not?
09:32:30 <tommd> sdhs: I'd fix that first.
09:32:37 <sdhs> not my computer
09:32:43 <sdhs> no permissions
09:32:52 <danr> it'd be quite cumbersome if you have to compile every haskell program you write by hand to assembly
09:32:57 <tommd> You can get a copy of GHC running without root on Linux.
09:32:58 <copumpkin> sdhs: what are you planning to do with the assembly?
09:33:10 <sdhs> convert it into assembly for a DSP
09:33:19 <lilac> sdhs: it compiles into the following assembly: "." (for a vector processor i just made up)
09:33:24 <Justin_> copumpkin: Hmmm, thanks.  It starts at 0, but that should be okay.  Thanks again.
09:33:31 <copumpkin> Justin_: yeah, you can kill that by using scanl1
09:33:37 <copumpkin> just make sure your list isn't empty :)
09:33:53 <lilac> > scanl1 f x []
09:33:54 <lambdabot>   Couldn't match expected type `[a]'
09:33:54 <lambdabot>         against inferred type `SimpleRef...
09:33:57 <sdhs> can anyone do that for me
09:34:06 <Makoryu> :t scanl1
09:34:06 <sdhs> i'll give you one of those chocolate coins
09:34:06 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
09:34:34 <lilac> > scanl1 undefined []
09:34:35 <lambdabot>   []
09:34:42 <lilac> empty lists are no problem :)
09:35:04 <copumpkin> oh yea
09:35:05 <copumpkin> h
09:35:44 <lilac> presumably scanl f x xs = scanl1 f (x:xs)
09:35:49 <lilac> @src scanl
09:35:49 <lambdabot> scanl f q ls = q : case ls of
09:35:49 <lambdabot>     []   -> []
09:35:49 <lambdabot>     x:xs -> scanl f (f q x) xs
09:37:23 <tommd> sdhs: This is a bad idea, I suggest you save some time and not go this route.
09:37:30 <tommd> sdhs: but here is your asm http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9796#a9796
09:37:34 <tommd> i386
09:37:45 <Justin_> That looks great.  Thanks again.
09:37:48 <sdhs> good christ
09:37:52 <sdhs> how is that so complicated
09:38:04 <tommd> Feel free to figure out the answer and get back to us.
09:38:50 <lilac> sdhs: why're you complaining? it's got variable names and comments and everything!
09:38:58 * sdhs frowns
09:39:04 <lilac> assuming lines starting with # are comments
09:39:44 <danr> at least it is not bytecode
09:40:11 <sdhs> shouldn't that whole program be like
09:40:14 <copumpkin> you could write simpler asm for dot product
09:40:15 <sdhs> maybe 20 lines long
09:40:33 <copumpkin> but remember
09:40:40 <copumpkin> you're not using arrays for the vectors
09:40:48 <copumpkin> and definitely not unboxed arrays
09:40:53 <copumpkin> so you're traversing the linked list
09:41:03 <doserj> > scanl1 (uncurry (***) . (flip const *** (+))) [(a,0.2),(b,0.2),(c,0.2),(d,0.2),(e,0.2)]
09:41:04 <lambdabot>   [(a,0.2),(b,0.4),(c,0.6000000000000001),(d,0.8),(e,1.0)]
09:42:19 <tommd> sdhs: New version with -O2 and the Haskell code is "dotproduct list = sum . (zipWith (*) list)
09:42:19 <tommd> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9796#a9797
09:44:15 <sdhs> this is what i have: http://pastebin.ca/1578062
09:44:19 <sdhs> it does not quite work
09:45:20 <Makoryu> @pl \xs -> sum . zipWith (+) xs
09:45:21 <lambdabot> (sum .) . zipWith (+)
09:48:03 <sdhs>  i feel like i'm in "the cat in the hat" every time i come in here
09:48:39 <sdhs> i ask questions in my own language and get answers in this weird dactylic tetrameter
09:48:48 <sdhs> and there are always all these weird symbols
09:49:00 <tommd> sdhs: Such as?
09:49:19 <sdhs> @ and $ and / and \ and ^ and #### and god knows what else
09:49:19 <Makoryu> sdhs: It could be a lot worse. You could be learning J.
09:51:27 <tommd> sdhs: @ and $ are normal haskell operators - they aren't complex and if you want to know Haskell (I assume you do) then you should learn them.  "/" is division, just like in every other language I know, so I'm not clear on your issue there.  "\" (backslash) is to escape characters... just like other languages too.  I've never seen "####", and assume it is a custom symbol in a not-so-common library.
09:51:46 <sdhs> i wasn't really speaking literally
09:52:14 <tommd> sdhs: Ah, well - I guess its too early for me to catch false examples ;-)  Never mind.
09:52:15 <doserj> @ isn't a operator
09:52:15 <Makoryu> sdhs: 1: }. ] * i.@#  <- A function for deriving polynomials in J
09:52:26 <tommd> doserj: Right, not an operator, but a symbol.
09:54:01 <sdhs> that's like saying "you should be glad you live in the sewer, at least you don't live in an incinerator"
09:54:09 <sdhs> it could always be worse
09:54:46 <sdhs> and then somebody will say, "well, at least the sewer can handle pressure up to 40 atm!"
09:55:05 <sdhs> do you really want to be living down there during an event where that's necessary
09:56:13 <jmelesky> sdhs: there's definitely a culture of terseness around Haskell. i think it'
09:56:38 <jmelesky> i think it's still more transparent than the golfing that happens in the perl community (and i worked with perl for a decade)
09:57:57 <sdhs> it's all a religious matter
09:58:37 <Makoryu> sdhs: The @stuff, at least, is almost always bot commands
09:58:43 <Makoryu> @vixen Isn't that right?
09:58:44 <lambdabot> correct
09:59:26 <Makoryu> sdhs: And a lot of times, someone will try to use @pl to make their code more readable, only to have it backfire and do it by hand ;)
09:59:34 <jmelesky> sdhs: i'd argue it's an aesthetic matter, not religious, but no doubt others disagree
09:59:35 <ray> @vixen how about those liberals?
09:59:35 <lambdabot> how? it depends...
09:59:59 <danr> was perl golf some kind of parallell to pointfree syntax in haskell?
10:00:28 <sinelaw> @pl fix fix
10:00:28 <lambdabot> fix fix
10:00:33 <jmelesky> danr: slightly different aims, though both with the result of terseness
10:00:58 <Makoryu> danr: Perl has implicit variables ($_ and @_), which are very much in the same spirit as point-free style
10:01:04 <danr> terseness as in Visa detaljer
10:01:06 <danr> a neatly short and concise expressive style
10:01:41 <danr> oh rightoo Makoryu
10:01:42 <Makoryu> danr: Any time you write "if (s/foo/bar/) { split; join; chomp; snafu; }" you're using Perl's own point-free style
10:02:03 <danr> since it is split $_; join @_ and so on?
10:02:09 <Makoryu> Yep
10:02:19 <danr> ah... that is indeed quite pointless
10:04:36 <c_wraith> :t fix fix
10:04:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
10:04:37 <lambdabot>     Probable cause: `fix' is applied to too many arguments
10:04:37 <lambdabot>     In the first argument of `fix', namely `fix'
10:05:02 <c_wraith> :t fix . fix
10:05:03 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
10:06:04 <tommd> > fix . fix $ error  -- How does this translate to English? "Fix.  Fixing currency is erroneous"
10:06:05 <lambdabot>   Couldn't match expected type `a -> a'
10:06:05 <lambdabot>         against inferred type `[GHC.T...
10:06:22 <tommd> > (fix . fix) error
10:06:23 <lambdabot>   Couldn't match expected type `a -> a'
10:06:23 <lambdabot>         against inferred type `[GHC.T...
10:06:26 <tommd> humm
10:06:45 <Makoryu> :t fix . fix . fix
10:06:46 <lambdabot> forall a. (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> a
10:06:58 <Makoryu> :t fix fmap
10:06:59 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
10:06:59 <lambdabot>       Expected type: a
10:06:59 <lambdabot>       Inferred type: f a
10:17:08 <tinLoaf> hum.. i want to write a function with a polymorphic return type.. say for example a function "foo" that returns either 5 or True. How do i do that?
10:17:16 <tinLoaf> i guess the signature is something like "foo :: a"
10:17:31 <tinLoaf> but now how do i decide in the function's "body" what to return?
10:17:59 <lilac> tinLoaf: you need a typeclass in order to have a function which can return different values depending on which type it's used at
10:18:14 <lilac> it sounds like a strange thing to want to do, but...
10:18:35 <lilac> class Foo a where foo :: a; instance Foo Int where foo = 5; instance Foo Bool where foo = True
10:18:43 <jmcarthur_work> tinLoaf, foo :: Either Int Bool
10:18:46 <jmcarthur_work> :)
10:19:07 <jmcarthur_work> oh polymorphic
10:19:12 <jmcarthur_work> type class, yeah
10:19:20 <tinLoaf> uhm, ok, thanks
10:26:55 <danr> > inits "abc"
10:26:56 <lambdabot>   ["","a","ab","abc"]
10:27:04 <danr> > tails "abc"
10:27:05 <lambdabot>   ["abc","bc","c",""]
10:51:11 <mrsolo> haskell wiki says this about list comprehension
10:51:15 <mrsolo> ..Since lists are an instance of monads, you can get list comprehension in terms of the do notation. Because of this, several Haskell programmers consider the list comprehension unnecessary now..
10:51:25 <mrsolo> is that the general view?
10:51:32 <Botje> pretty much.
10:51:41 <danr> several, maybe, but that does by no means say all
10:51:46 <Botje> advanced haskell hackers want to enable monad comprehensions instead of list comprehensions
10:51:46 <mrsolo> or list comprehension is still heavily used
10:51:48 <tromp> several != most
10:52:01 <Botje> but they're too convenient to simply leave out
10:52:20 <mrsolo> hlint still hint this type of syntax [ x | y ] to replace if then else
10:52:42 <danr> i'm an assistant teacher in an introductory course in haskell programming, and we rely some on list comprehensions. it would not be appropriate to say that it works because lists are instances of monad and monadplus.
10:52:55 <Berengal> I seldom use list comprehension, but I don't think of them as useless. I used to use them all the time, but for some reason I never seem to need them now
10:52:55 <danr> mrsolo: yes that is quite charming :)
10:54:00 <ksf> if it weren't for atomically, I could get rid of IO.
10:56:59 <danr> so what's more efficient: least = head . sort or least = minimum?
10:57:28 <danr> seems to be quite the same?
10:58:10 <ksf> should be the same, sort happens to be lazy.
10:58:49 <Twey> @src minimum
10:58:49 <lambdabot> minimum [] = undefined
10:58:49 <lambdabot> minimum xs = foldl1 min xs
10:58:51 <ksf> but then, you might want to use a priority fingertree or something of that ilk, that supports your queries in less than average O(n/2)
10:59:58 <ksf> ...that is, you could get the minimum in O(1) and have O(log n) insert.
11:00:00 <danr> priority fingertree... sounds intresting
11:00:25 <ksf> http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-PriorityQueue-FingerTree.html
11:00:32 <danr> well, if I have O(log n) insert, I will get O(nlogn) if i have n elements... right?
11:01:00 <ksf> nope it's log n
11:01:28 <ksf> ...you just have to test against log n other keys to find a place for an element.
11:01:33 <danr> i can't possibly insert n items in O(log n) ?
11:01:41 <ksf> ah no of course not.
11:01:45 <danr> nope.
11:02:09 <ksf> well... fromList is O(n)
11:02:20 <copumpkin> fromAscList
11:02:44 <ksf> http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/src/Data-PriorityQueue-FingerTree.html#fromList
11:02:54 <ksf> nothing like that, it's just folding an insert into the list.
11:03:27 <copumpkin> :O
11:03:27 <ksf> looks like stuff cancels itself out, those big-O arguments in the fingertree paper always made me dizzy.
11:03:45 <pchiusano> is there a name for applicative functors augmented with a "plus" operator
11:03:52 <pchiusano> like monad plus
11:04:14 <edwardk> pchuisano: Alternative
11:04:17 <edwardk> empty and <|>
11:04:40 <pchiusano> ah
11:04:56 <edwardk> alas, there is no FunctorPlus ;)
11:05:04 <jmcarthur_work> :(
11:05:05 <pchiusano> edwardk: has anyone built a parser combinator library based on that?
11:05:08 <edwardk> which would be useful for the prod-type monad
11:05:15 <jmcarthur_work> pchiusano, many are based on that :)
11:05:19 <edwardk> pchuisano: uu-parsinglib's P_f parser is only Alternative.
11:05:20 * ksf wants monadic case patterns, btw.
11:05:37 <jmcarthur_work> parsec instantiates Alternative
11:05:38 <pchiusano> I would imagine you could generate very efficient code or interpret the parser more efficiently
11:05:45 <edwardk> I have a library that is 'mostly done' that is Applicative-only (can only handle 'Context-Free Attribute Grammars' basically.
11:05:47 <jmcarthur_work> ah you mean specialized
11:05:48 <ksf> ...I already use ifM c a p = if p then c else a , but that won't work for cases as patterns aren't first class.
11:06:15 <edwardk> but yeah in general any monadic parser is also alternative, so you can get used to the style by using parsec or what have you
11:06:30 <pchiusano> jmcarthur_work: yes, any MonadPlus is an alternative, but it is too general
11:06:57 <edwardk> limiting yourself to applicatives lets you do some neat things, like in my case parallel parsing, etc.
11:06:59 <danr> an mcase and mif would be sweet. i know these are implemented in some extra sugar layer somewhere
11:07:04 <pchiusano> edwardk: parsimony?
11:07:24 <edwardk> pchuisano: that was what i was originally going to call it before someone snuck another one onto hackage under that name ;)
11:07:33 <pchiusano> ouch
11:07:34 <ray> just call it monoidal-parsing
11:07:35 <pchiusano> :)
11:07:42 <edwardk> ray: probably a good call
11:07:51 <ksf> proper multi-case patterns for lambdas are another topic.
11:08:09 * ksf can't believe haskell, a language that claims to be functional, is crippling lambdas.
11:08:35 <edwardk> ksf: just read \x -> case x of ... as a multiline lambda ;)
11:08:54 <ksf> I'm trying to get rid of all those backslashes.
11:08:57 <pchiusano> besides what edwardk is working on... can anyone point me to a paper that implements parsers using ONLY Alternative, and from which you can generate efficient code for the parser, or interpret it more efficiently
11:09:36 <ksf> you see, isEOF >>= mIf (act1) (act2) is way more readable than do b <- isEOF; if b then act1 else act2
11:09:41 <edwardk> ksf: write a short quasiquoter that just matches case bodies? [$fun| Foo x -> ...; bar -> ... |]
11:09:54 <ksf> ...the same goes for >>= \b -> if b
11:09:56 <edwardk> and have it generate the anonymous case?
11:10:14 <Makoryu> :t let f 0 = 1; f n | n > 0 = n * f (n - 1) | n < 0 = 1 in f
11:10:15 <lambdabot> forall t. (Ord t, Num t) => t -> t
11:10:24 * Makoryu coughs in ksf's direction
11:10:47 <edwardk> ksf: should be pretty easy to generate using haskell-src-exts or what have you
11:10:51 <dons> ksf: how can you cripple a lambda?
11:10:57 <dons> its either \x.e or its not
11:11:05 <ksf> dons, by not supporting multiple patterns.
11:11:16 <edwardk> dons: he wants multiple patterns, etc.
11:11:19 <dons> oh, does any language with built in lambda support that?
11:11:26 <Makoryu> dons: Clojure supports pattern matching in lambdas... Though I can't think of *any* other language that does that.
11:11:37 <ksf> ...anyway, I don't want lambdas. I want to write caseM (action) of ...
11:11:39 <dons> there's been quite a few proposals for this, but it always falls down
11:11:39 <Makoryu> Maybe OCaml
11:11:42 <darinm> ocaml does
11:11:46 <edwardk> Makoryu: lots of ML dialects
11:11:50 <dons> in that : once you need multiple patterns, you should use a real function
11:12:02 <dons> the benefit of anonymous multi-line lambdas is a bit suspect
11:12:11 <ksf> or, rather, action >>= caseM (pat1 -> act1) ...
11:12:12 <dons> that's essentially the argument, power/weight tradeoff
11:12:21 <pchiusano> i don't get what the fuss is about... since you can always have a case expression as the body of the lambda
11:12:28 <dons> right
11:12:32 <dons> \x -> case x of ...
11:12:32 <Makoryu> Yeah, it's not too hard to use let f .. in f
11:12:37 <Makoryu> Or that
11:12:37 <ksf> verbosity.
11:12:40 <ksf> clutter.
11:12:41 <edwardk> i did like the random 'case of' suggestion that was floated in haskell' somewhere.
11:12:44 <ksf> vs. consciseness.
11:12:46 <jmcarthur_work> i find it hard enough to convince myself to use lambdas as it is. i think i would be thoroughly grossed out if i had to use a multicase lambda
11:12:48 <dons> look up the haskell' discussion on this
11:13:02 <Makoryu> ksf: Brevity vital? Use J.
11:13:03 <dons> since the full design was pretty much done, and all arguments made.
11:13:25 <dons> power/weight for new syntax is a big concern these days
11:13:29 <dons> we already have too much syntax
11:13:33 <dons> so by all means: use TH
11:13:51 <edwardk> foo x = case x of ... can then become foo = case of ... which is the same general model as ksf's proposal, but it isn't a big enough deal to warrant actually bolting ANOTHER corner case on the grammar
11:14:21 <Saizan> ..if we had first class patterns instead
11:14:25 <edwardk> syntactic sugar causes cancer of the semicolon.
11:15:06 <edwardk> at least in large enough amounts
11:15:15 <ray> speaking of that
11:15:19 <ray> how about the poor . character
11:15:27 <edwardk> its a bit overworked.
11:15:28 * ksf likes edwardk's suggestion.
11:15:40 <ksf> ... \-> case of ?
11:15:48 <ray> no, just case of
11:16:12 <edwardk> ksf: it was mentioned in haskell' suggestions somewhere
11:16:18 <ksf> what about "caseof"?
11:16:29 <edwardk> ksf: in practice the best i think you'll be able to do is a TH quasiquoter.
11:16:31 <ksf> no need to corner case, that's a new keyword.
11:16:35 <edwardk> ksf: adds a keyword
11:16:47 <edwardk> ksf: which now creates parsing problems, etc.
11:17:22 <ksf> we should switch to sexpr syntax and define the now usual syntax in terms of it.
11:17:35 <edwardk> ksf: i wish you luck in your crusade ;)
11:17:47 * ksf doesn't think it makes sense to burden compilers with parsing.
11:17:53 <ray> enjoy liskell
11:18:12 <edwardk> ksf: i don't think it makes sense to burden programmers with parsing. There are more of them than there are compilers.
11:18:26 <ksf> heck you don't _have_ to use sexpr syntax, and you're not even supposed to.
11:18:46 <ksf> I'm just of the oppinion that syntax should be a library, not a language feature.
11:19:03 <edwardk> ksf: it may hearten you to hear that the intermediate language used in my toy compiler is a slightly mutated scheme. ;)
11:19:33 <edwardk> ksf: alas it is not present anywhere near the surface syntax though i've been trying to figure out a clean way to bolt in syntax-rules
11:20:13 <edwardk> layout + fixity + syntax rules + very dynamic scoping models don't mix very well.
11:20:14 <ray> well, that's sensible
11:20:23 <ray> writing in sexprs is what's not sensible
11:21:06 <ksf> it doesnt' make sense to make a distinction between cases and patterns in functions in the ast, either.
11:21:11 <edwardk> i personally subscribe to the 'why is $ not syntax!' philosophy. i want to eliminate parens, not add more ;)
11:21:33 <ksf> languages shouldn't provide sugar, just the possibility to add it.
11:22:04 <edwardk> i'm a pragmatist, language-based sugar can often be 'sweeter' than library sugar.
11:22:08 <ksf> I am _not_ advocating changing the syntax used to write programs.
11:22:28 <ksf> ...just open up the desugaring to allow people to mess with it as they please.
11:22:28 <ray> i want to eliminate syntax, not add more
11:22:42 <ksf> well, that's what sexprs do.
11:22:45 <Saizan> i think very customizable syntax is a problem for reading other people's code
11:23:07 <ksf> not more problematic than reading code written in a library you don't know.
11:23:11 <edwardk> Saizan: sure, but i will also concede that syntax-rules can greatly improve highly domain-specific code and reduce boilerplate.
11:23:40 <ksf> if syntax is sugar, then library-specific syntax is fairy dust.
11:23:51 <Saizan> ksf: no, it's more problematic, i can at least tell which are functions and which aren't right now!
11:25:07 <ksf> you can distinguish foo = 1 and foo = id just by looking at "foo"?
11:25:50 <Saizan> function/value as opposed to keyword, for example i know where alpha-equivalence holds and where it doesn't
11:27:43 <ksf> if True then c else _ = c; if False then _ else a = a
11:27:46 <edwardk> Saizan: if you only have hygienic macros then that is the limit of your concerns though, since you only have to worry about names introduced in your code, not from the macro.
11:28:08 <ksf> there's nothing inherently special to keywords.
11:28:15 <edwardk> Saizan: and you can extend the editor to load the syntax-rules so it knows what is a keyword
11:28:48 <Makoryu> Highlighting extensions? In MY editor?
11:28:55 <Makoryu> It's more likely than you think.
11:29:25 <ksf> at some point, we're going to force yi on everyone, anyway, in the same way that plt forces drscheme on you.
11:30:39 <jfoutz> they won't let you download mzscheme anymore?
11:30:56 <Makoryu> That reminds me
11:31:08 <Makoryu> How do you change syntax modes in yi?
11:31:26 <edwardk> ksf: (define-syntax do (syntax-rules (<- let) ((do (x <- s) ss ...) (>>= s (lambda (x) (do ss ...)))) (other stuff) -- in there the <- is special in code that uses the macro.
11:32:06 <eyeris> The prelude conflicts with so many common functions (e.g. Prelude.head vs Data.List.head). Is there a way to hide everything in Prelude?
11:32:34 <edwardk> so to be fair, saizan does have a point, with macros, you need to care a lot about what names you can bring into scope, etc. otoh, it is just for the lexical scope of the syntax-rule that they matter.
11:32:34 <ksf> import qualified Prelude
11:32:49 <Makoryu> eyeris: import Prelude hiding (foo)
11:32:54 <ksf> ...then do import Prelude(foo,bar) for the things you want to have accessible.
11:32:57 <tommd> eyeris: Its normal to import things like Bytestring qualified, but you can explicitly import Prelude and hide or reveal only certain parts.
11:33:00 <Makoryu> eyeris: Or import qualified Prelude as Foo
11:33:09 <edwardk> Prelude.head and Data.List.head shouldn't conflict, things like ByteString etc on the other hand will
11:33:14 <tommd> import Prelude ()
11:33:20 <Makoryu> TML: Or that <_<
11:33:50 <ksf> edwardk, there's no principle problem with making syntax parametrizable. load-syntax foo ("fmap" "map")
11:34:07 <ray> that's not syntax though
11:34:18 <ray> just a different Prelude
11:34:39 <ksf> ...well, abstract it sufficiently to be syntax.
11:35:07 <ray> yeah
11:35:15 <ksf> the point is that you can alpha-convert what a define-syntax matches on without messing with anything else.
11:35:43 <ksf> (doing alpha-conversion and type coercions while importing modules would be cool, too, btw)
11:36:10 <edwardk> i think my answer for now is to just make the editor smart enough to know about macros and to syntax highlight explicit syntax differently ;)
11:37:04 <ksf> even better, as the syntax isn't defined in some obscure happy-file compiled into the compiler, the editor actually has a better chance of getting stuff right.
11:37:28 <lilac> the fact that my brain can parse haskell code locally (without reading the whole file and all of its imports) is something i consider extremely valuable, and is the number 1 reason i don't like lisps...
11:38:21 <ksf> that won't change, as noone else wants to read that much, too.
11:38:33 <lilac> i find that haskell syntax is in that sweet spot where it's expressive enough that it doesn't get in the way, without being so general that i can't tell what's going on
11:39:25 <lilac> ksf: it /could/ change. these things have a way of creeping...
11:39:53 <ksf> ok, I'm going to switch into another gear now.
11:40:16 <ksf> having the syntax defined in the compiler instead as a library is a _blatant_layering_violation_
11:40:43 <lilac> absolutely not. there must be /an/ interface to the compiler, in the form of some language.
11:41:20 <ksf> ...which shouldn't have insane redundancies as patterns in both cases and function definitions.
11:41:27 <lilac> why?
11:41:28 <ksf> ...it should be the semantic minimum.
11:41:30 <copumpkin> just write in core then
11:41:34 <ksf> 'cos that's sugar.
11:41:38 <lilac> so?
11:41:51 <copumpkin> "should"
11:42:11 <lilac> why should it be the semantic minimum?
11:42:25 * copumpkin just writes everything in lambda calculus
11:42:43 <ksf> well, have a look at the TH ast, it's a pain to work with as you can do the same stuff in way too many ways.
11:42:53 <copumpkin> too much sugar in numbers, and types, etc.
11:43:05 <lilac> i'm very happy that, when applicatives got introduced, they used <*> rather than introducing some new sugar which would have to be learned and taught
11:43:48 <ksf> haskell's syntax is very fine, _unless_ you happen to hit that wall of pre-defined non-first class stuff
11:44:07 <jfoutz> do the same stuff too many ways? that seems... wrong.
11:44:12 <copumpkin> agda mixfix for all!
11:44:14 <Makoryu> I wish we could use ; and , in operator names :(
11:44:21 <lilac> do you have a concrete example? as i said earlier, i've always found haskell to be expressive enough
11:44:44 <ksf> ifM c a p = if p then c else a
11:44:45 <jfoutz> it's good enough for BASIC, right?
11:44:48 <ksf> do that for cases.
11:45:19 <ksf> bools are first class: no problems. patterns are: there's the wall.
11:45:26 <ksf> er aren't.
11:45:27 <jfoutz> no, if is the sugar.
11:45:47 <lilac> personally i'd be in favour of dropping 'if' and possibly 'let'
11:47:08 <ksf> we also have a long history of having to hack up do-notation to allow for alternative bind definitions, hacking up list comprehensions so they work with streams, mdo, arrow syntax...
11:47:35 <ksf> the reason is always a library one, but it induces changes to the compiler.
11:47:42 <lilac> i think it's a great thing that such changes are difficult and time-consuming, because it means that they're not added as a whim
11:47:47 <ksf> and that's a blatant layering violation.
11:48:00 <lilac> most of the time, people find other ways of doing what they want to do with no great loss of expressivity
11:48:16 <lilac> if it were easy to change the syntax, i strongly suspect it'd happen a lot more in cases where it's not needed.
11:49:15 <lilac> folklore says that code is read at least 10x more often than it's written. custom syntax makes the writer's job easier and in my experience makes the reader's job harder. that seems unlike a win.
11:49:33 <ksf> it can make it harder, if you abuse it.
11:49:56 <lilac> peoples' definitions of what constitutes a nice clever idiom and what constitutes abuse differ wildly
11:50:01 <ksf> but it's kinda besides the point to argue against a feature because it may be used in an obfuscation contest.
11:50:10 <eyeris> When I try to set a breakpoint in ghci, I get an error that the expected type Bool does not match the inferred type ByteString -> Maybe VDef. Can I only break on boolean functions?
11:50:23 <lilac> i understand that the author of the bourne shell didn't think that its source code was an abuse of C macros
11:51:28 <ksf> C macros are the worst example of a syntax defitition language there is...
11:51:56 <lilac> peoples' ideas of what is 'readable' differ. it's helpful if there's only a certain amount of leeway.
11:52:34 <lilac> ksf: anyway, i've got to head off :) if you want to present an argument, privmsg me and i'll read it when i return
11:53:33 <ksf> well, we just have different expectations about what would happen and what stuff would be used for and in what way.
11:53:49 * ksf takes the libertarian standpoint.
11:55:19 <jfoutz> oh. well, go for it.
11:57:14 <ksf> /home/ksf/ghc/lib/ghc-6.12.0.20090923/ghc-stage2: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory
11:57:50 <copumpkin> #ghc
11:59:44 <bos> dons: have you updated the #haskell irc traffic stats recently?
12:00:03 <bos> i notice that the number of nicks in here has grown by 20% since the last time i looked, just a few months ago.
12:00:15 <dons> oh, should rerun that code
12:00:22 <dons> not sure if its still running on my unsw machine.
12:01:07 * copumpkin hopes he isn't the biggest chatterbox anymore
12:01:18 <bos> we're now the 7th biggest channel on freenode by current nick count
12:03:21 <eyeris> What is wrong with: rosterNumber = if rosterText == "" 0 else (read rosterText)?
12:03:30 <eyeris> ghci gives a parse error on else
12:03:46 <eyeris> doh, then
12:03:47 <pchiusano> msg edwardk hey are you avail to talk Monday
12:03:50 <copumpkin> if x then y else z
12:14:41 <ziman> pchiusano, i think it's @msg
12:15:29 <pchiusano> ziman: no, I was going for private irc message
12:17:14 <pchiusano> forgot the slash
12:25:07 <ziman> i see :)
12:26:25 <sayyestolife> <3
12:26:39 <sayyestolife> because everything is less than 3
12:27:26 <paxcoder> :-)
12:29:27 <halcyon10> hi, is there something like a monadic if?
12:29:46 <Makoryu> halcyon10: What do you mean exactly?
12:30:04 <sm> has someone written a general parser of date strings, that would recognise eg most common date formats found in feed item publish dates ?
12:30:19 <halcyon10> something that either runs action1 or action2 depending on a boolean value
12:30:33 <bos> sm: there was a huge perl module that did that back around 1993, but i've not seen anything similar since.
12:30:53 <sm> thanks bos
12:31:13 <Makoryu> halcyon10: So, for example.... if foo then return True else return False
12:31:19 * sm wonders why ever didn't rss designers specify a date format
12:31:53 <Makoryu> halcyon10: Or... if foo then putStrLn "Yeah" else putStrLn "Nah"
12:32:12 <halcyon10> Makoryu: ok, i see, i thought too complicated ;)
12:33:03 <Makoryu> halcyon10: You do have to be careful not to line up the then/else lines with the "if" line
12:33:40 <halcyon10> Makoryu: i usually indent them, but why would it be bad?
12:33:43 <Makoryu> halcyon10: That's the only real caveat to using if/then/else in a "do" block
12:34:34 <Makoryu> halcyon10: Because indentation is how the compiler knows where to break apart a block into lines
12:34:45 <paxcoder> sm: they didn't? noobs.
12:35:33 <halcyon10> Makoryu: yeah, but is it worse in a do-block than elsewhere?
12:36:27 <Makoryu> halcyon10: A do-block is the only place that's likely to happen with if/then/else in particular
12:36:53 <Makoryu> halcyon10: I really wish I had good examples on hand to show how this works....
12:37:20 <hackagebot> hsemail-ns 1.3.1 - Internet Message Parsers (JoeFredette)
12:37:36 <halcyon10> Makoryu: i see, now i know, so i won't make that mistake :)
12:38:15 <Makoryu> halcyon10: But generally speaking, lines in a layout block (anything after "let," "where," "do," or "case .. of") have implicit semicolons wherever they line up to the left margin
12:38:35 <Makoryu> And the semicolons are the "real" syntax for separating declarations
12:39:03 <Makoryu> > let { f 0 = True; f n = False } in f 5
12:39:04 <lambdabot>   False
12:40:03 <halcyon10> Makoryu: thx for explaining
12:40:30 <Makoryu> halcyon10: No sweat. Remind me later to write up an explanation that I can post somewhere :p
12:40:43 <Makoryu> (The existing ones never satisfied me)
12:43:29 <Makoryu> halcyon10: For now, just refer to RWH: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.offside
12:44:07 <halcyon10> Makoryu: i already have that, it's right on my desk and i'm referring to it all the time :)
12:44:13 <Makoryu> halcyon10: Awesome
12:44:20 <Makoryu> Then you'll be all set :p
12:45:30 <Lycurgus> http://hackage.haskell.org/package/Workflow is rife with typos. Is one supposed to be big and allow as how the author is not a native speaker of English?
12:46:07 <halcyon10> ghci gives me a compile error in the way i'm using if in a monadic context, what am i doing wrong here? : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9806#a9806
12:46:08 <Lycurgus> (i.e. overriding the normal repulsion one has for such a lack of attention to detail)
12:46:24 <hackagebot> diagrams 0.2.1 - An EDSL for creating simple diagrams (BrentYorgey)
12:46:45 <benmachine> Lycurgus: maybe offer your services as a copyeditor? :)
12:47:14 <Lycurgus> I may do better than that and actually use the package if it seems warranted.
12:47:25 <devilsnight> hello room
12:47:38 <Lycurgus> yello devilsnight
12:47:40 <devilsnight> i am kinda new here and really would need a few services
12:48:18 <Makoryu> halcyon10: Ah, that's a different issue
12:48:19 <Lycurgus> well with 632 users I imagine someone will "service" you
12:48:38 <Makoryu> halcyon10: Start a new do-block after the first else
12:48:57 <halcyon10> Makoryu: ok, i'll try that
12:49:37 <Makoryu> halcyon10: A do-block is an expression like any other. Keep this in mind while writing code
12:49:53 <benmachine> woo, the ghc bug I reported got fixed
12:51:07 <benmachine> the diff is 1 character I think
12:51:52 <halcyon10> Makoryu: cool, now it works! thx!
12:51:59 * Makoryu salutes
12:52:41 <lightstep> i'm reading TaPL, and the existential types has an exercise to implement universal types when you only have existential types. does anyone have a hint on how to do that?
12:53:30 <halcyon10> Makoryu: i'm going offline now, thanks for your help again, see ya
12:55:50 <Lycurgus> TaPL: Theoretical Analysis of Programming Languages?
12:56:07 <Gracenotes> Types and Programming Languages, no?
12:56:12 <Lycurgus> ah
12:56:21 <Lycurgus> (makes more sense here)
12:56:23 <lightstep> yes, types and programming languages
12:56:49 <danr> that book is on my desktop :O
12:56:58 <danr> my physical one, even
12:57:12 <lightstep> it's the last exercise in the chapter, and the solutions says that Pierce didn't ever see it written out, and that it should be a global transformation
12:57:12 <Gracenotes> I would have it, were the cost less
12:57:31 <devilsnight> please where can i get advices on hacking please room
12:58:12 <lightstep> devilsnight, what kind of hacking?
12:58:12 <jkr> Hi
12:58:43 <jkr> Is there a module that parses get/post parameters from a Hack Env?
12:59:30 <devilsnight> i am looking for a paypal hacker in the house or a cc hacker please
12:59:46 <tomh-> Zomg
12:59:49 <jkr> lol
13:00:22 <byorgey_> lightstep: maybe it would help to think about it in English.  If you can only use the phrases "all" and the phrase "it is not the case that", how would you express the idea that something with property X exists?
13:00:46 <byorgey_> er, I don't think I said that very well.  but maybe it will help anyway. =)
13:00:56 <jkr> Ah, found it. It's all in hack-contrib
13:00:58 <byorgey> oh, I said it backwards anyway.
13:01:14 <byorgey> well, the same trick works both ways =)
13:01:31 <benmachine> it is my personal opinion that some people should accept that the battle to keep the original meaning of hack has been lost
13:01:37 <devilsnight> lightstep
13:01:40 <devilsnight> thanx
13:01:54 <devilsnight> credit cards
13:01:58 <devilsnight> and paypal
13:01:59 <lightstep> byorgey, in logic "for all x, y happens" is the same as "there doesn't exist an x such that y doesn't happen", and vice versa
13:02:06 <byorgey> lightstep: exactly.
13:02:24 <byorgey> devilsnight: I think you are in the wrong channel.
13:02:27 <wdonnelly> devilsnight: try #freenode
13:02:34 <devilsnight> ok
13:02:41 <lightstep> devilsnight, i don't know of any haskell library for hacking paypal or credit cards in development
13:02:42 <devilsnight> wdonnelly
13:02:49 <devilsnight> thanx
13:03:00 <devilsnight> but what do you think you can tutor me in hacking
13:03:14 <devilsnight> wdonnelly and lightstep
13:03:15 <byorgey> @where lyah
13:03:15 <lambdabot> www.learnyouahaskell.com
13:03:18 <Rotaerk> "here's how you can steal people's identities!"
13:03:26 <byorgey> devilsnight: ^^^ that ought to get you started down the path of hacking
13:03:29 <jkr> We call it "hasking" :)
13:03:58 <devilsnight> thanx man
13:03:59 <devilsnight> too nyc
13:04:12 <lightstep> byorgey, so, "exists x. <expr>" translates to "NOT (forall x. (NOT <expr>))" which translates to "forall ZZ. (forall x. (<expr> -> ZZ)) -> ZZ"
13:05:04 <lightstep> but i have no idea how to go the other way around, since the encoding for NOT which i know requires universal quantification
13:05:31 <byorgey> lightstep: oh, I see, I was confused about what you were asking for.  I didn't realize this was a four-star exercise =)
13:07:34 <lightstep> yeah :)
13:07:35 <samphippen> if we know an array contains 13 items, can anyone give me one line of haskell to return it's median?
13:08:02 <Gracenotes> is it sorted?
13:08:10 <mahogny> samphippen, slow version: sort, use !! to pick out middle
13:08:13 <lightstep> samphippen, sort (elems arr) !! 7
13:08:38 <Gracenotes> it is possible to do it in O(n) time with a quicksort-like algorithm.
13:08:41 <samphippen> lightstep, is elems significant?
13:09:01 <jfoutz> @type elems
13:09:02 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
13:09:05 <jfoutz> ;)
13:09:13 <Rotaerk> hai, can any1 tutor me on how to rob a jewelry store??
13:09:25 <Rotaerk> *cough*
13:09:45 <Beelsebob> Rotaerk: you need unsafePerformIO for that
13:09:52 <jfoutz> Rotaerk: have you seen reservoir dogs? not quite that.
13:10:04 <sinelaw> Rotaerk, You mean probably how to transform a AST that uses arrows into one that doesnt?
13:10:08 <Gracenotes> samphippen: see http://ocw.mit.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/LectureNotes/lec6.pdf for an efficient algorithm. I don't think it's a one liner in any language, though
13:10:18 <Rotaerk> hmm nope never saw it
13:10:25 <Gracenotes> and it might only be worth it for bigger n
13:10:39 <lightstep> samphippen, "sort" works on lists, "elems" convert an array to a list
13:10:50 <Gracenotes> really big. 13 is probably overkill for it
13:11:15 <Gracenotes> I think it also requires mutability
13:11:51 <samphippen> sort arr !! 7 seems to work
13:12:05 <devilsnight> wdonnelly please i tried #freenode but no one there is willing to assist
13:12:41 <wdonnelly> :(
13:12:51 * wdonnelly was hoping an admin would be there to k-line him
13:13:10 <Lycurgus> devilsnight, did you come here cause you heard the l33t hax0rs were here?
13:13:13 <Gracenotes> samphippen: hm.. is it an array? the default data structure, like [1, 2, 3], is a singly linked list
13:13:34 <samphippen> I think it might be a list
13:13:46 <samphippen> sort arr !! 6 = instant work and much shorter than python
13:14:10 <lightstep> sorted(arr)[6]
13:14:14 <lightstep> in python
13:14:51 <tommd1> Does Data.ByteString.copy always result in a 4 byte aligned bytestring?  Anyone here know?
13:15:04 <jfoutz> well, that's not really fair, right. you'll need ot import Data.List
13:15:15 <mmorrow> tommd1: doubtful
13:15:27 <Heffalump> should there be some kicking going on?
13:15:44 <Gracenotes> the 'average' median, though, would be something like: (/2) . liftM2 (+) (head) (tail . head) . drop 6 (sort list)
13:16:02 <Rotaerk> Heffalump, someone wants us to teach him how to hack credit cards and paypal, does that count?
13:16:03 <Gracenotes> er, replace last . with $
13:16:28 <Heffalump> Rotaerk: well, I was wondering if he was providing entertainment value, since there wasn't any shouting for an op.
13:16:43 --- mode: ChanServ set +o Heffalump
13:16:44 <Rotaerk> I found it amusing/sad
13:16:51 <Heffalump> doh
13:16:56 --- mode: Heffalump set -o Heffalump
13:19:47 <Rotaerk> I suppose it's possible that guy was actually a cop trying to weed people out
13:20:44 <lightstep> cop from what country?
13:20:52 <coco`> in (a `par` b), is a fully evaluated, or only to head-normal form?
13:20:57 <Rotaerk> true
13:23:13 <kw317> coco`: hnf
13:23:49 <kw317> oh, with par
13:23:53 <kw317> that depends
13:23:58 <kw317> it might not get evaluated at all
13:25:30 <coco`> yes, yes, it might not
13:25:38 <coco`> but what is the maximum?
13:25:59 <TomMD> @seen dcoutts
13:25:59 <lambdabot> Unknown command, try @list
13:26:20 <kw317> coco`: maximum? what do you mean?
13:26:22 <TomMD> preflex_: seen dcoutts
13:26:22 <preflex_>  dcoutts was last seen on #ghc 1 hour, 11 minutes and 42 seconds ago, saying: it's like deb or rpm, it just compiles the .deb/.rpm from source on your box rather than the distro build server
13:26:54 <kw317> coco`: everything is only ever evaluated to hnf unless you need more
13:27:07 <kw317> so a will be evaluated to hnf if the computation starts
13:27:16 <coco`> ok, thanks
13:27:22 <coco`> that's what I was wondering about
13:27:23 <kw317> and then if it's used in b then it will be evaluated further
13:27:32 <TomMD> @tell dcoutts If you could pull down community.haskell.org/~tommd/pureMD5 and give that a test then let me know if it properly fixes your alignment issues I'd appreciate it.  Sorry such a simple fix took so long.
13:27:32 <lambdabot> Consider it noted.
13:28:21 <coco`> in (a `pseq` b), are a and b ran in parallel and b will be thrown away if a is undefined?
13:28:35 <kw317> they are not run in parallel
13:28:45 <kw317> pseq is like seq but strict only in the first arg
13:29:16 <coco`> what do you mean by strict?
13:29:35 <kw317> if a is undefined then the result of the expression is undefined
13:29:39 <coco`> surely (a `pseq' undefined) is undefined
13:30:01 <kw317> ues, but undefined `pseq` b is also undefined
13:31:08 <coco`> ...and so is undefined `seq` b, no?
13:31:26 <kw317> yes
13:31:43 <coco`> :)
13:31:47 <coco`> so what's the difference?
13:31:50 <kw317> the difference between seq and pseq is as follows
13:31:58 <kw317> if you have function (+)
13:32:03 <kw317> it's strict in both arguments
13:32:14 <kw317> i.e. function body is evaluated after its arguments, both left and right
13:32:33 <coco`> ok, I guess that's "operational" strictness
13:32:41 <kw317> therefore the compiler can evaluate x and y in x+y in any order
13:32:44 <kw317> same with seq
13:33:04 <kw317> in x `seq` y, either x or y may be evaluated first
13:33:10 <kw317> since they are pure, it does not matter
13:33:18 <coco`> I see
13:33:19 <coco`> and pseq?
13:33:21 <kw317> so for some optimiznation the compiler may change the order
13:33:38 <kw317> and in pseq, since the second argument is lazy, this optimization cannot take place
13:33:47 <kw317> and this is precisely what you want with parallel computations
13:34:51 <coco`> so pseq a b evaluates a to hnf, before starting to look at b?
13:35:00 <kw317> yes
13:35:56 <coco`> so 'par' is necessary to introduce parallelism
13:36:07 <kw317> yes
13:36:14 <coco`> what's pseq useful for?
13:36:18 <Gracenotes> seq is not guaranteed to do it, but it always does it for me :)
13:37:13 <kw317> coco`: simple example: parallelize x+y, where x and y are some time-consuming operations
13:37:24 <dons> coco`: pseq says 'do it in the current thread'
13:37:36 <dons> par says 'maybe do it in another thread if you have the time'
13:38:13 <coco`> might `pseq` be useful in non-parallel programs?
13:38:19 <defun> What does 'HOF' mean in this sentance: "Using HOFs is more elegant, but makes it harder to reason about space usage, also explicit recursion does not make the code hard to read - just explicit about what it is doing."
13:38:33 <coco`> defun: higher order function
13:38:33 <Gracenotes> higher order function
13:38:40 <defun> ah, ok.
13:38:41 <defun> thanks
13:38:47 <kw317> coco`: in non-parallel setting better is seq
13:38:57 <dons> pseq is fine in a non-parallel setting
13:38:57 <Heffalump> how do HOFs complicate space usage? Because of variable capture in closures?
13:38:57 <Rotaerk> my HOF's higher than your HOF
13:38:58 <Gracenotes> meaning, I think, foldl/foldr/map/filter/zipWith/etc.
13:39:15 <coco`> I meant, when maybe our intuition about optimal evaluation oreder is better than ghc...
13:39:27 <dons> defun: i don't think they complicate space usage.... any more than loops with loop bodies do
13:39:36 <dons> i've never heard that before.
13:39:42 <defun> dons: I agree.
13:39:44 <TomMD> dons: From what I see, the FFI addendum says mallocBytes must be reasonably aligned - this isn't specified for things like mallocForeignPtrBytes - but is strongly implied to me.  Is it safe for me to assume such a function (and consequently ByteString.Internal.createUnsafe and ByteString.copy) will be aligned?
13:39:56 <lightstep> @google "explicit recursion does not make the code hard to read"
13:39:57 <lambdabot> No Result Found.
13:40:06 <kw317> coco`: yes, it is, you have for example strict application $!
13:40:09 <defun> I'm just reading a wiki page that's discussing some things related to haskell.
13:40:13 <dons> TomMD: I'm not sure if it is safe to assume, without checking the code.
13:40:23 <dons> defun: feel free to edit it, [citation needed]
13:40:23 <kw317> coco`: which under the hood uses seq
13:40:27 <Gracenotes> perhaps because the accumulator in folds is not so explicit, you wonder where it is
13:40:44 <TomMD> The spec should be clear on that and then we could add a test.
13:40:46 <dons> esp. given HOFs are common to almost all languages now, my guess: someone talking about haskell without any experience .
13:40:48 <kw317> coco`: and this stuff is very useful at times
13:40:49 <dons> TomMD: indeed
13:41:19 <defun> Someone apparently thinks HOFs are bad, but I think such a statement is almost like an "X considered harmful" flame.
13:42:28 <coco`> here is my attempt at a list constructor that is both parallel and strict:
13:42:35 <coco`> x !!: y = (x `par` (y `pseq` (x `pseq` (x : y))))
13:42:53 <dons> the pseq on x is suspicious
13:43:01 <coco`> it's to make it strict in x
13:43:04 <defun> i.e. "do notation considered harmful", "syntactic sugar considered harmful", "list notation considered harmful". Over-generalizations, imho.
13:43:05 <dons> indeed
13:43:13 <coco`> could be `seq` probably
13:43:17 <dons> defun: umm.. [citation needed]
13:43:21 <Gracenotes> list notation wha
13:43:30 <dons> defun: this is written by a lisp programmer, perchance? :)
13:43:37 <dons> types considered harmful
13:43:39 <dons> what else.
13:43:42 <defun> dons: my thoughts exactly.
13:43:43 <dons> laziness.
13:43:47 <dons> purity
13:43:54 <dons> referential transparency considered harmful
13:43:57 <defun> the list goes on and on.
13:44:09 <kw317> life considered harmful
13:44:09 <dons> helpful communities considered unhelpful
13:44:13 <kw317> ends with death ;-)
13:44:14 <defun> editing now...
13:47:35 <defun> Is RWH going to be updated when Haskell' is released?
13:48:43 <TomMD> defun: I wouldn't worry about Haskell prime being released any time soon... and its not like RWH uses Haskell 98 as it is.
13:49:37 <defun> dons: Clarification: above it looks like I'm agreeing that 'types are considered harmful'. I'm merely suspecting that that a lisper is bashing haskell because it's not lisp.
13:50:01 <defun> TomMD: true. I thought H' was scheduled for 2010?
13:50:07 <kw317> that's what one of my supervisors would say
13:50:11 <kw317> (re types)
13:51:11 <TomMD> Is there a schedule?  I missed that, but good news that it will actually be finished in some manner.
13:51:12 * kw317 decides it's high time for dinner
13:53:13 <defun> On GHC trac they mentioned a 2010 release, iirc.
13:53:35 <Gracenotes> hm
13:54:36 <Heffalump> TomMD: the plan is for yearly releases, with H' as the ongoing process that generates them.
13:55:24 <Vanadium> yearlyReleases = iterate H' haskell
13:57:28 <Lycurgus> h' seems to evidence a confusion between standards and implementations
13:57:48 <Lycurgus> confusion, equivocation, whatever
14:02:19 <Lycurgus> (i.e. practical implementation meant for general use as opposed to say operational specifications)
14:03:46 <defun> Probably going to get a biased response, but what RCS would fellow haskellers recommend for my latest and greatest project? And why?
14:04:23 * cygnus prefers darcs
14:04:56 * Vanadium uses git because all his friends do
14:05:57 <defun> We need something like github for darcs.
14:06:08 <cygnus> Yeah. There's patch-tag, but it's not very mature yet. :-/
14:06:16 <defun> bummer.
14:06:27 <sm> darcs, natch, because it's easy
14:06:53 * cygnus likes the darcs workflow.  Especially the hunk cherry-picking UI.
14:07:06 <defun> sm: natch?
14:07:10 <sm> naturally
14:07:13 <defun> ah
14:07:23 <defun> I should have guessed...
14:07:41 <aavogt> cygnus: can you split up hunks with darcs before recording?
14:07:48 <tinLoaf> hey guys. does the "no match in record selector"-exception mean that i did call a "getter" on something of the wrong type?
14:07:50 <sm> also, because as a haskeller you'll have more fun hacking on your rcs tool, should you need to
14:08:18 <Alpounet> http://www.reddit.com/r/haskell/comments/9nsp8/3d_text_rendering_in_haskell_with_ftgl/ <<< I finally got my 3D Text Rendering working :-)
14:08:26 <cygnus> aavogt: not sure what you mean; hunks are units by definition, they can't be split unless you modify the source to create two hunks instead of one.
14:08:35 <cygnus> in other words, no. :)
14:08:50 <sm> I think a feature just got added which sounds like that
14:08:59 <sm> #darcs will know
14:09:16 <sm> (aavogt )
14:09:18 <aavogt> cygnus: what I mean is, lets say you add two functions that occur right next to eachother, but they should belong to different patches
14:09:22 * cygnus is using 2.2.0
14:09:44 <cygnus> aavogt: that's probably going to be considered one hunk.  I usually just manually remove one, record, reinstate, record.
14:10:07 <cygnus> aavogt: it's annoying for sure, but it doesn't come up *that* often in my experience.
14:11:12 <cygnus> aavogt: I find that one way to avoid that in general is to simply record more often, but that takes discipline and it's sometimes unavoidable.
14:14:09 <coco`> has someone already made a strict list library?
14:14:41 <TomMD> coco: You mean an array?  Or a linked list that forces evaluation of each element?
14:14:53 <skorpan> > take 4 $ seqList [1..]
14:14:54 <lambdabot>   Couldn't match expected type `Control.Parallel.Strategies.Strategy
14:14:54 <lambdabot>         ...
14:14:54 <coco`> a linked list
14:14:57 <skorpan> hm.
14:15:26 <skorpan> obviously i have no idea how that stuff works.
14:15:30 <coco`> oh, what's Control.Parallel.Strategies about?
14:15:40 <TomMD> Evaluation stratagies.
14:15:41 <skorpan> :t Strategy
14:15:41 <lambdabot> Not in scope: data constructor `Strategy'
14:15:47 <TomMD> strategies
14:15:52 <skorpan> type Strategy a = a -> Done
14:16:04 <mpiechotka> How to select children in HXT? I mean only children - not ancestors?
14:16:53 <coco`> are strategies a way of forcing in-depth evaluation, instead of just HNF? in that case, isn't it more efficient to put strictness into the datatype definitions?
14:17:31 <TomMD> coco`: yes
14:18:37 <coco`> strategies remind me of deepSeq
14:19:27 <Heffalump> deepSeq is called rnf in the strategies library
14:20:41 <coco`> rnf's haddock says it reduces its argument to (head) normal form
14:20:53 <coco`> is that misleading?
14:21:09 <TomMD> coco`: You aren't confusing whnf with hnf, are you?
14:21:16 <coco`> oh
14:21:19 <coco`> I might
14:21:22 <coco`> what's the difference?
14:21:56 <TomMD> In an informal nutshell - one is deepSeq while the other will only determine the wrapping constructor.
14:22:42 <coco`> the latter one is whnf I guess
14:22:48 <coco`> yes, so I have been confusing them
14:22:50 <coco`> :)
14:30:30 <McManiaC> ghc: panic! (the 'impossible' happened)
14:30:31 <McManiaC> yay
14:30:31 <McManiaC> ^^
14:31:01 <Botje> GHC makes the impossible merely infrequent :)
14:32:05 <aavogt> @quote exploded
14:32:05 <lambdabot> ghc says: My brain just exploded.
14:33:26 <bastl> @hoogle IORef
14:33:26 <lambdabot> module Data.IORef
14:33:26 <lambdabot> Data.IORef data IORef a
14:33:26 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
14:36:25 <bastl> is there any way to make something like a global variable that i can access from many IO() actions?
14:36:54 <bastl> I have a data-wrapper for a GTK-GUI which i carry around all the time, which is ugly
14:37:05 <Botje> can you use a readerT?
14:37:21 <bastl> whats that?
14:37:25 <Botje> otherwise you can use "unsafePerformIO $ newIORef"
14:37:49 <MyCatVerbs> bastl: There's the unsafePerformIO (newIORef x) hack, but it's preferrable to carry the state around with a Reader or ReaderT.
14:38:03 <jmcarthur_work> or State or StateT, if necessary
14:38:17 <bastl> readerT sounds good.
14:38:34 <bastl> are there examples howto use it ?
14:38:46 <MyCatVerbs> ReaderT if you never alter the state, or StateT if you do.
14:39:03 <benmachine> could you put an IORef in a ReaderT?
14:39:09 <benmachine> and then modify it
14:39:40 <bastl> hmm. as i said, the value is a GTK-Gui. so i think it will change state ...
14:40:34 <aavogt> benmachine: the ioref itself is immutable
14:40:42 <coco`> how does the following associate:   a `seq` b : c
14:40:47 <coco`> how can I find out?
14:40:51 <benmachine> aavogt: but it points to mutable data?
14:41:01 <bastl> thanks
14:41:03 <aavogt> yeah, the result of (readIORef someref) is allowed to change
14:42:41 <christo_m> how would one go abotu defining a datatype for representing the abstract syntax trees of propositional formulae?
14:43:27 <lpsmith> benmachine:  you wouldn't be able to change the reference,  but you could change what the reference points to.   Readers are a handy way of dealing with IORefs :-)
14:43:37 <skorpan> data P = Unit | Or P P | And P P | ...
14:43:38 <Botje> christo_m: think about trees :)
14:43:50 <christo_m> Botje: it's been a while :(
14:43:54 <aavogt> you can have an ioref contain another ioref..
14:52:07 <benmachine> okay so I have (x:xs) * r@(y:ys) = x * y : (map (*x) ys + (xs * r))
14:52:29 <benmachine> any recommendations wrt removing explicit recursion/generally improving that
14:53:18 <lightstep> benmachine, what does the + do?
14:53:34 <coco`> is there a way to have any kind of symbol character be a prefix constructor
14:53:47 <coco`> I'm making strict list and would like to have a symbol similar to [] for nil
14:53:55 <aavogt> > (+) 1 2
14:53:56 <lambdabot>   3
14:54:01 <coco`> constructor!
14:54:04 <sjanssen> coco`: Haskell doesn't support prefix constructors by default
14:54:11 <benmachine> lightstep: a bit like zipWith (+) only xs + [] = xs
14:54:13 <coco`> and by language extension?
14:54:29 <sjanssen> nope
14:54:33 <coco`> :(
14:54:55 <benmachine> (the full definition is xs + [] = xs; [] + ys = ys; (x:xs) + (y:ys) = (x + y):(xs + ys)
14:55:02 <coco`> and what are the legal infix symbols composed of?
14:55:17 <lightstep> isn't this the same as zipWith?
14:55:25 <lightstep> > zipWith (+) [1,2,3] []
14:55:26 <lambdabot>   []
14:55:30 <sjanssen> @where report
14:55:30 <lambdabot> http://www.haskell.org/onlinereport/
14:55:31 <lightstep> > zipWith (+) [] [1,2,3]
14:55:32 <lambdabot>   []
14:55:39 <skorpan> > zipWith (+) [1..] [2..]
14:55:39 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
14:55:40 <coco`> thx
14:55:49 <skorpan> prime numbers, all of them!
14:55:56 <skorpan> okay, not all of them
14:56:13 <c_wraith> 25 is prime today.  just for you
14:56:15 <benmachine> > [1..]
14:56:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:56:16 <jfoutz> i'm pretty sure it has all of them but 2.
14:56:21 <benmachine> all primes are in there somewhere
14:56:21 <jfoutz> and some extra stuff.
14:57:02 <Rotaerk> >[1..2..]
14:57:05 <Rotaerk> > [1..2..]
14:57:06 <lambdabot>   <no location info>: parse error on input `..'
14:57:07 <hackagebot> hsemail-ns 1.3.2 - Internet Message Parsers (JoeFredette)
14:57:15 <skorpan> Rotaerk: what are you trying to do?
14:57:42 <Philonous> > [1..]++[2..]
14:57:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:57:56 <Rotaerk> I was thinking... [1,3,5,...
14:58:00 <aavogt> coco`: maybe there are some unicode brackets that look like [], which ghc thinks are symbols. Then you could write  (:[])  as your constructor (note, that doesn't work as written)
14:58:03 <Philonous> > [1,3..]
14:58:04 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
14:58:07 <Rotaerk> ah
15:11:26 <lightstep> benmachine, look at http://www.haskell.org/pipermail/haskell-cafe/2008-November/050328.html . this convolution is similar to what you are trying to do
15:11:58 <TomMD> Hummm... hardware driver in Haskell CHECK, libraries CHECK, Linux kernel CHECK, symbols defined CHECK, computer freezes CHECK.  Damn!
15:12:37 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9801#a9811 <-- in the bigger of the pastes, could someone please tell me why i get a kind error, i just can't see it
15:13:11 * benmachine giggles at a function called convolute
15:14:45 <pastorn> it's a GADT irrer i can't get grips of :/
15:14:59 <coco> can ghc be told to spit out absolute paths for the source files in its error messages? my emacs gets confused...
15:15:15 <lightstep> pastorn, Mx is a class of types with kind *->*, but Mx3 has kind *->*->*
15:15:57 <skorpan> Rotaerk: what are you trying to do?
15:16:01 <skorpan> oops, mispress
15:16:23 <dons> TomMD: haha
15:16:42 <pastorn> lightstep: you see any solution?
15:16:54 <pastorn> class (mx vt) where doesn't work
15:17:09 <Botje> you need to fix the instance definition
15:17:19 <Botje> instance Mx (Mx3 foo bar) where ..
15:17:32 <Botje> uh
15:17:36 <skorpan> remove one?
15:17:36 <Botje> or possibly Mx3 foo
15:17:38 <Botje> it's rather late :)
15:19:01 <pastorn> instance Mx (Mx3 Vector3) where <-- doesn't work either :/
15:20:15 <lightstep> pastorn, why does Mx3 even have the first parameter?
15:20:37 <pastorn> lightstep: Mx is a class for square matrices
15:20:52 <pastorn> so i can do mx `matMul` vec
15:20:57 <pastorn> typesafe
15:21:03 <dons> bos: http://twitter.com/timbray/status/4349115087 notice something unusual
15:21:20 <bos> dons: yeah, funny
15:23:18 <lightstep> can you imagine some Mx3 with vecType /= Vector3 ?
15:23:31 <pastorn> no
15:23:44 <pastorn> well, i could
15:24:03 <pastorn> actually the Mx class should be renamed to SqMx
15:24:05 <lightstep> it's not even a real parameter, just a phantom parameter
15:24:11 <pastorn> yes, i know
15:24:29 * pastorn thought he was being all h4xx0r and stuff
15:25:58 * lightstep is not h4xx0r enough to mix phantom types and type classes
15:26:46 * skorpan sticks to python
15:27:02 <pastorn> skorpan: fail@u?
15:27:37 <skorpan> excuse me, i think you were the one who failed? :)
15:28:01 <benmachine> no it was me sorry
15:28:37 <pastorn> the truth is in the eye of the beholder...
15:50:12 <dcoutts> TomMD: thanks!
15:53:13 <TomMD> dcoutts: sure thing.
15:53:36 <dcoutts> TomMD: what approach did you take in the end?
15:54:00 <TomMD> dcoutts: Its just a simple check to see if the bytestring is aligned and I use Data.ByteString.copy if it isn't aligned.
15:54:32 <TomMD> from what I can tell this should return an aligned bytestring but that isn't required explicitly by the FFI - just implied.  I made a Haskell' suggestion to fix that.
15:54:33 <dcoutts> TomMD: at the input stage, or on each 64byte block ?
15:55:03 <TomMD> dcoutts: On the 'make blocks' function, so it's still happening every 64 bytes.
15:55:40 <dcoutts> TomMD: hmm, if only the construction of the trailing blocks could be fixed then you could do it at the bigger granularity.
15:56:06 <TomMD> dcoutts: Yeah, its just an issue with poor organization of the current code.  I should rework it a fair amount more but have enough going right now.
15:56:09 <dcoutts> the thing where it actually introduces misaligned blocks, when there were none in the input
15:57:00 <dcoutts> TomMD: really? It looked to me like there was one place that constructed the trailing blocks
15:57:06 <TomMD> Let me know if its ok for you - I'll send it to hackage if you give a thumbs up.  Its at least better than the current version.
15:57:10 <dcoutts> sure
15:57:57 <TomMD> dcoutts: When the input is aligned, sure we only would need to fix the Finalize.  For the uses when the input isn't aligned I need the main body to check and fix it anyway.
15:58:26 <coco> can a datatype with strict constructors be automatically derived from a non-strict one? say, strict lists from lazy lists?
15:58:45 <dcoutts> TomMD: ah but for the latter it's a simple lazy pass over the input
16:07:02 <dons> coco: "automatically" in what sense?
16:07:18 <dons> you can do a manual induction on the type structure, replacing lazy nodes with strict ones.
16:07:45 <coco> dons: template haskell? or even better putting a prime afer the type ;)
16:08:25 <coco> I'm doing this manual induction right now copying list code from the prelude and replacing the constructors with strict ones...
16:08:46 <dons> oh, i see, you want to derive Strict, yielding a new type with strict semantics?
16:08:58 <dons> hey, why not use the strict list package?
16:09:11 <dons> there's even a specializing list package.
16:09:19 <coco> !!
16:09:20 <dons> which is more useful
16:09:28 <dons> adaptive-containers is what you need
16:09:32 <coco> ok, I don't know what 'Strict' is
16:09:39 <coco> but I have been looking for a strict list package
16:09:39 <dons> http://hackage.haskell.org/packages/archive/adaptive-containers/0.3/doc/html/Data-Adaptive-List.html
16:09:55 <dons> element-strict, self-optimizing types
16:10:20 <coco> wow!
16:10:30 <coco> thanks, that looks very useful
16:10:37 <coco> how is this possible?
16:11:00 <dons> through the power of SCIENCE
16:11:08 <coco> haha
16:11:27 <dons> srsly, no, the package explains how, http://hackage.haskell.org/package/adaptive-containers
16:11:40 <coco> are adaptive lists strict?
16:11:48 <coco> oh, element-strict
16:11:50 <dons> in the elements.
16:11:58 <coco> but I also want them self-strict...
16:12:03 <dons> spine strict?
16:12:15 <coco> that sounds like the right word
16:12:16 <dons> so no infinite structures, no lists-as-control structures?
16:12:21 <coco> cons should be strict in both arguments
16:12:24 <coco> yes
16:12:25 <dons> they degenerate into arrays then.
16:12:32 <dons> see, e.g. uvector.
16:12:39 <coco> indeed, but I do lots of recursion over them
16:12:47 <dons> http://hackage.haskell.org/package/uvector
16:12:58 <dons> Fast unboxed arrays with a flexible list interface,
16:13:11 <dons> spine and element strict
16:13:18 <dons> so e.g. cons copies.
16:13:22 <coco> oh
16:13:26 <coco> hmmm
16:13:34 <coco> so I can do pattern matching?
16:13:50 <dons> only via view patterns
16:14:00 <dons> f (cons xs -> x:xs) = ...
16:14:02 <coco> is that efficient?
16:14:10 <coco> or is a whole new array generated
16:14:11 <coco> ?
16:14:33 <dons> no, it can be as efficient. but you should not use spine-strict structures in the same way as lazy ones
16:14:39 <dons> as they have quite different characterisitcs
16:14:53 <dons> cons is, relatively, bad
16:15:03 <coco> the algorithm I happen to use happens to be recursive
16:15:07 <dons> what's your use case?
16:15:13 <dons> why spine-strictness?
16:15:17 <coco> huge polynomials
16:15:24 <dons> huge lists of them?
16:15:36 <dons> why not use element-strict lazy lists? or unboxed arrays?
16:15:37 <coco> trees
16:15:52 * dons is skeptical that spine-strictness by default helps here.
16:16:34 <coco> I've been using this in some places: x !: y = x `seq` y `seq` x : y
16:16:39 <coco> and it helped quite a bit
16:16:47 <coco> more than x !: y = x `seq` x : y
16:17:00 <coco> memory usage is an issue
16:17:49 <dons> so that makes it element strict
16:17:57 <dons> are the elements trees?
16:18:41 <coco> yes
16:18:50 <dons> right, so that makes sense.
16:18:58 <dons> you have big unevaluated trees otherwise.
16:19:06 <dons> also, this might be a nice place to do some speculative parallelism
16:19:22 <dons> x `par` y `pseq` x : y : z
16:19:41 <coco> yes, I wanted to do that, but then realized that I should deal with the strictness first
16:20:02 <dons> its a good problem to have.
16:21:58 <coco> I'm curious about how uvectors are able to provide a list interface
16:22:29 <coco> (btw, thanks, you saved me some work)
16:23:31 <dons> ah, via the magic of SCIENCE
16:23:35 <ivanm> heh
16:23:39 <dons> i mean, COMPILERS
16:23:49 <MyCatVerbs> COMPILER SCIENCE.
16:23:58 <ivanm> @remember dons ah, via the magic of SCIENCE
16:23:58 <lambdabot> I will never forget.
16:23:58 <MyCatVerbs> You're even allowed to lowercase it.
16:28:09 <coco> are the elements of uvectors unboxed?
16:30:01 <coco> yes, they are
16:33:28 <coco> dons: uvector's haddock says its consU has complexity O(n)
16:35:04 <dons> coco: right, it is an entirely unpacked structure, with all data stored in consecutive memory slots
16:35:14 <dons> it is not just a spine-strict list.
16:35:20 <dons> it is spine strict and flattened.
16:35:40 <coco> ok, so efficient recursion would result in index-fiddeling
16:36:23 <dons> no, you'd use the higher order functions (map/fold/etc.)
16:36:32 <dons> or rely on fusion.
16:36:44 <coco> what's fusion?
16:39:49 <ivanm> what dons' is referring to is a type of fusion that isn't listed here: http://en.wikipedia.org/wiki/Fusion :p
16:40:10 * jfredett_ pounds his head against the wall...
16:40:20 <ivanm> coco: list/array fusion, which combines functions together and applies them more efficiently (i.e. dumb code becomes more efficient) ... I think :s
16:40:23 <jfredett_> It should not be _this_ hard to parse email...
16:40:28 <ivanm> jfredett_: what, still not enough quotes? :o
16:40:29 <ivanm> ;-)
16:40:46 <ivanm> jfredett_: oh, you trying to write an email library?
16:40:48 <jfredett_> ivanm: no, it's looking better, I've got a good 7-9 to pick from
16:41:06 <jfredett_> ivanm: well, I thought I'd try scraping gmane archives, that's not even worth it... :P
16:41:21 <jfredett_> ivanm: then I said, "Screw it, I'll just download, parse, and sort the emails themselves"
16:41:41 <jfredett_> it's just such a pain, because the RFC makes the format too complicated.
16:41:45 <ivanm> heh
16:41:55 <coco> ivanm: does that work in practice... can I just convert arrays to lists and hope the compiler optimizes it away?
16:42:06 <jfredett_> mostly because email grew "organically" (read, it got made up by satan in the beginning of time).
16:42:12 <ivanm> one of those "whoops, so many incompatible versions already available and in use... I know, let's just combine them all!" specifications?
16:42:30 <ivanm> coco: it's more that multiple operations on the lists are fused together
16:42:43 <ivanm> (and possibly operations on the arrays, but I'm not that sure about that)
16:42:46 <ivanm> @google list fusion
16:42:46 <lambdabot> http://www.listfusion.net/
16:42:47 <lambdabot> Title: ListFusion
16:42:51 <ivanm> heh, doubt that's it
16:42:54 <ivanm> @google list fusion haskell
16:42:55 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
16:42:55 <lambdabot> Title: 7.14.Rewrite rules
16:43:04 <ivanm> coco: ^^ have a look there
16:43:10 <coco> ok, thx
16:43:10 <jfredett> @google google
16:43:10 <lambdabot> http://www.google.com/
16:43:10 <lambdabot> Title: Google
16:43:37 <jfredett> or you could go there... then you'd have more options. :P
16:43:56 <Endo> Hi there
16:44:02 <jfredett> Endo: Hiya..
16:44:08 <ivanm> jfredett: heh
16:44:22 <Endo> :>
16:45:08 <Endo> Ehm... I guess I'll just shoot the question
16:45:18 <jfredett> Endo: go for it, we don't bite
16:45:20 <jfredett> much.
16:45:27 <ivanm> jfredett: heh, stole my line
16:45:30 <ivanm> (the "much")
16:45:34 <jfredett> :)
16:45:35 <Endo> :P
16:45:43 <ivanm> Endo: just hurry up and ask the question!
16:45:50 <Endo> pf
16:46:04 <ivanm> hmmmmm.... tasty Endos... nom nom nom... :p
16:46:33 <redline6561> My turn, are monads *really* warm and fuzzy or do people just say that?
16:47:15 <ivanm> redline6561: they're not as bad (to use, at least) as people think they are
16:47:25 <jfredett> redline6561: if this were -blah I'd have a joke. but instead I will just say, "Yes"
16:47:35 <Endo> Prelude> :m +Text.Regex.Posix \\
16:47:36 <Endo> <interactive>:1:0: parse error on input `=~' \\ Prelude Text.Regex.Posix> "bar" =~ "(foo|bar)" \\ <interactive>:1:6: Not in scope: `=~'
16:47:57 <ivanm> IIRC, the "warm and fuzzy" came from SPJ who said that they should have called them "fuzzy monsters" or something so as not to scare people that much
16:48:00 <redline6561> ivanm: That's what I hear. My humor == FAIL.
16:48:02 <Endo> not a fast typer am I
16:48:09 <ivanm> jfredett: awwww.... please joke away? pretty please?
16:48:12 <redline6561> jfredett: Thanks.
16:48:21 <jfredett> ivanm: it's dirty, hence -blah restriction
16:48:29 <ivanm> ahhhh
16:48:30 <jfredett> we keep it pg in here, iirc.
16:48:34 <ivanm> yeah
16:48:44 <jfredett> Endo: okay- somethings not in scope, gotcha.
16:48:57 <Endo> great
16:48:57 <ivanm> @hoogle (=~)
16:48:57 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
16:48:57 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
16:49:16 <ivanm> @type Text.Regex.Posix.(=~)
16:49:17 <lambdabot>     Not in scope: data constructor `Text.Regex.Posix'
16:49:21 <ivanm> @type Text.Regex.Posix.=~
16:49:22 <lambdabot> parse error on input `Text.Regex.Posix.=~'
16:49:25 <ivanm> @type (Text.Regex.Posix.=~)
16:49:26 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
16:49:41 <ivanm> right, so it should work with just a Text.Regex.Posix import
16:49:48 <jfredett> Endo: are you sure Text.Regex.Posix is imported/installed on your setup?
16:49:59 <Endo> Allright, the thing is I have nbo clue about what is exactly out of scope and how to bring it in
16:50:05 <ivanm> jfredett: it seemed to have imported it OK
16:50:15 <Endo> I'm pretty sure it's there
16:50:17 <jfredett> it should change your PS1 line from Prelude> to Text.Regex.Posix>
16:50:18 <ivanm> > "bar" =~ "(foo|bar")
16:50:19 <lambdabot>   <no location info>: parse error on input `)'
16:50:21 <ivanm> > "bar" =~ "(foo|bar)"
16:50:22 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
16:50:22 <lambdabot>                    ...
16:50:26 <ivanm> jfredett: it did... ;-)
16:50:36 <jfredett> ivanm: I mean on _his_ system
16:50:42 <ivanm> jfredett: well, it changed it to "Prelude Text.Regex.Posix>"
16:50:45 <jfredett> the issue is that the (=~) operator
16:50:48 <jfredett> isn't imported.
16:50:49 <ivanm> jfredett: look at his paste...
16:50:55 <jfredett> oh, theres a past?
16:50:58 <jfredett> paste*
16:51:03 <ivanm> jfredett: what he pasted here
16:51:05 <ivanm> with the error
16:51:17 <Endo> yep
16:51:26 <Endo> <interactive>:1:0: parse error on input `=~' \\ Prelude Text.Regex.Posix> "bar" =~ "(foo|bar)" \\ <interactive>:1:6: Not in scope: `=~'
16:51:31 <ivanm> Endo: just run this to check: :type (=~)
16:51:34 <Endo> just not in scope
16:51:34 <jfredett> ahh, okay
16:51:42 <ivanm> maybe a versioning problem?
16:51:45 <jfredett> hmm
16:52:01 <jfredett> probably. Endo, did you "cabal install" the regex stuff, or what?
16:52:10 <Endo> Not in scope. :(
16:52:15 <Endo> nono
16:52:20 <Endo> uhm...
16:52:31 <ivanm> ghc-pkg list regex-base
16:52:33 <FunctorSalad_> @hoogle (=~)
16:52:34 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
16:52:34 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
16:52:40 <Endo> I'm actually running GHCi standalone for windows :S
16:52:42 <FunctorSalad_> did you import that .Wrap?
16:52:52 <jfredett> Endo: well _theres_ your problem. :P
16:52:54 <ivanm> FunctorSalad_: it seems to be re-exported by Text.Regex.Posix
16:53:01 <jfredett> in all seriousness
16:53:16 <jfredett> if you do (I hope this is right, I haven't used windose in a while.)
16:53:20 <Endo> really? let's see
16:53:21 <jfredett> run cmd.exe
16:53:43 <jfredett> then there should be some variant of ghc-pkg.exe or something
16:54:09 <ivanm> jfredett: IIRC, the one time I installed GHC on windows there was a link in the start menu to auto-run ghci via cmd.exe
16:54:39 <Endo> Prelude Text.Regex.Posix> :m +Wrap \\ Could not find module `Wrap': \\
16:54:39 <Endo>   it is not a module in the current program, or in any known package.
16:54:50 <jfredett> ivanm: right, but he should still be able to run ghc-pkg et al from cmd.exe, to see whatversion he has
16:54:51 <Endo> oops sorry
16:55:01 <ivanm> jfredett: true
16:55:04 <jfredett> should be Text.whatevergoeshere.Wrap
16:55:26 <Endo> I meant :m +Text.Regex.Posix.Wrap
16:55:57 <Endo> I realized that and it is still not found
16:55:59 <Endo> :(
16:56:15 <Endo> Windoze approach: reinstall.
16:56:22 <jfredett> Endo: let me ask you a metaquestion, why do you need regexes? Why not parsec (just curious, I haven't got much more to offer unfortunately).
16:56:49 <jfredett> Endo: Windoze approach: disregard windows, acquire linux.
16:56:53 <jfredett> ftfy
16:57:36 <Endo> I'm trying to express the format of a more complicated grammar for Parsec (no trouble there). And regex are just to keep it understandable
16:58:05 <ivanm> Endo: can you get ghc-pkg to work in cmd.exe
16:58:57 <jfredett> Endo: So, you're using regexes _and_ parsec for the grammar, or is the regex business for something corelated
16:59:09 <ivanm> when I try what you have, I get "No instance for (RegexContext Regex [Char] target)" ...
16:59:24 <Fragsworth> I don't quite understand the "->" notation in type definitions
16:59:37 <ivanm> Fragsworth: in what way?
16:59:52 <Fragsworth> add x y :: Integer -> Integer -> Integer
16:59:55 <ivanm> "a -> b" means "given a value of type a, I will return a value of type b"
16:59:56 <Fragsworth> what does this mean?
17:00:05 <Endo> jfredett: I know I should use linux|BSD to work, but I want it to run on windoze first --just to get some non-geeks using my bots :/
17:00:13 <ivanm> Fragsworth: OK, if there's multiple ->, then wrap brackets around later ones
17:00:21 <benmachine> ivanm: using any kind of regex ever usually needs a typesig I think
17:00:30 <maltem> Fragsworth, given an integer, it will, given an integer, return an integer
17:00:31 <ivanm> benmachine: yeah, worked that out
17:00:42 <ivanm> benmachine: but my point is that I didn't have Endo's problem
17:00:44 <benmachine> oh
17:00:46 <FunctorSalad_> use regex-pcre-light or whatsitcalled if you think the typeclasses are a bit of an overkill
17:00:47 <benmachine> yeah
17:00:51 <ivanm> i.e. Integer -> Integer -> Integer is equivalent to Integer -> (Integer -> INteger)
17:00:53 <Fragsworth> maltem: Holy crap I think I get it.
17:01:03 <jfredett> Fragsworth: think of it as a roadsign, if you start at point "a", then the function will take you to point "b"
17:01:03 <ivanm> s/N/n/
17:01:17 <ivanm> it's type sig analogy time! :p
17:01:40 <jfredett> so a function from a to b is just a path from a value of type a to a value of type b, for some types a and b.
17:01:44 <Fragsworth> Is the last type always the return type?
17:01:48 <jfredett> yep
17:01:55 <ivanm> if you provide all the args, yup
17:02:03 <jfredett> in fact, the last _n_ types can be the return type
17:02:11 <Fragsworth> Ahh, ok.
17:02:11 <Endo> jfredett: yes I'm using both, the main idea is to have a function lift a whole "complicated" grammar from the first line in it's file (this string being the simpler grammar for the one actually in the file).
17:02:12 <FunctorSalad_> Fragsworth: the idea is that "Int -> Int -> Int" is essentially the same as "(Int,Int) -> Int"
17:02:16 <jfredett> since function are a type.
17:02:33 <FunctorSalad_> (try writing converters between these two :))
17:05:07 <jfredett> Endo: so basically, it's a parser parser?
17:05:13 <Endo> yeah!
17:05:16 <Endo> :D
17:05:22 <ivanm> that sounds.... scary :s
17:05:33 <jfredett> Cool, why not use parsec for both parts? :)
17:05:40 <Endo> Parser Parser GramF is the actual type (I think)
17:05:42 <Endo> :P
17:06:00 <Fragsworth> Everything in Haskell, at first glance, ends up being the tip of a massive iceberg. And if I hold my breath long enough I might be able to see the bottom...
17:06:33 <jfredett> You'll have to forgive me, I've written half a dozen parsers over the last few days, so I've fully drunk the `string "kool" *> string "aid"`
17:06:42 <Endo> jfredett: I guess that's the other choice. Getting the code to look "common sense" would be a great exercise :P
17:07:06 <jfredett> are you using applicative or monadic style?
17:07:40 <Philippa> Fragsworth: heh. The thing about it is, the icebergs were there in other languages - they were just hidden away as "but I don't do that stuff!" even when you did
17:07:56 * Philippa is starting to like interleaving monadic and applicative style
17:08:05 <Philippa> (if it's Parsec, there's no good reason not to)
17:08:06 <maltem> There's the other end of Haskell fun, at least if you're like me and always go like, there must be a way to this even more elegantly... hack hack hack... wait, didn't I want this code to do something useful?
17:08:21 <Endo> jfredett: this is my first parser and my first two weeks on haskell since I studied it in college
17:08:36 <Endo> so I'm not sure what's the difference there
17:08:41 <jfredett> Philippa: I agree. My .hwn parser is all applicative, but I find that generating monadic code is somewhat easier from TH.
17:09:03 <jfredett> Endo: on a very basic level, applicative parsers don't really specify variables, monadic ones do.
17:09:28 <Endo> uhm
17:09:39 <Philippa> jfredett: eh, I don't buy that
17:09:47 <jfredett> if you poke at my HWN2 repo on patchtag, you can see a (if I do say so myself) lovely applicative parser.
17:10:01 <jfredett> Philippa: My sample size for that statement is 1, so I'm not sure I do either.
17:10:20 <jfredett> but I am finding that parsec + template haskell goes together like rednecks and nascar.
17:10:30 <Endo> jfredett: are Parsec parsers monadic?
17:10:33 <Philippa> Endo: if you're using Parsec, write monadic style for now
17:10:36 <Philippa> they are
17:10:55 <Endo> then I'm using monadic style
17:10:57 <Endo> :D
17:10:58 <jfredett> Endo: they're both monadic (think "do" notation) and applicative (with a little work).
17:11:25 <Endo> so what's the difference then? Sugar?
17:11:41 <jfredett> but yes, start with monadic style. It just seemed like your project was indicative of someone who's done alot of parsec. :)
17:11:49 <jfredett> Endo: and a little semantic difference.
17:12:22 <jfredett> Applicative parsers work by "applying" one parser to another, it's more declarative in alot of ways.
17:12:24 <Philippa> Endo: if something's an Applicative but not a Monad, you can't do things akin to context-sensitive parsing
17:12:34 <Endo> oohh I haven't done a "lot", just some "complicated" stuff (not so much with a good book and a Guido Macchi around)
17:12:50 <Philippa> all Monads are or can be applicatives, and the applicative combinators have a different flavour to the monadic ones
17:13:13 <Philippa> jfredett: it'd be possible to have an 'applicative do', btw
17:13:29 <jfredett> Philippa: really? Interesting.
17:13:37 <ivanm> Philippa: would it? I thought Monads = Applicative + (>>=), and that (>>=) is needed for do-notation
17:13:48 <Endo> Philippa: then I actually need monads. Trying to parse natural everyday informal conversational spanish.
17:13:53 <jfredett> I suppose it makes sense, I'm always "feeding values up the chain"
17:14:28 <jfredett> it would be weird though, wouldn't it. the monad laws would (obviously. :) ) be somewhat different.
17:14:52 <Philippa> do a <- f; g; b <- h; return $ Foo a b => (\a b -> Foo a b) <$> f <*> g *> h
17:15:20 <jfredett> Endo: ... thats an ambitious project for two-weeks experience, good on you!.
17:15:28 <Philippa> ivanm: it'd just be a first-order language instead of a higher-order one, if that makes sense. Transform's above, assuming simple variable patterns only
17:15:40 <Philippa> Endo: cool!
17:15:45 <ivanm> nope, doesn't make sense ;-)
17:15:57 <Philippa> Fragsworth: this is why the icebergs are worth hacking at :-)
17:16:02 <jfredett> ivanm: :P
17:16:16 <jfredett> Damn the icebergs, full speed ahead!
17:16:25 <ivanm> *crunch*
17:16:35 <ivanm> jfredett: did you remember to pack enough lifeboats? ;-)
17:16:43 <Endo> gotta go. I'll tell more about the project when it's done. Thanks a lot for the help!
17:16:55 <Philippa> ivanm: anyway, does the desugaring rule above figure? Is that do-like enough for you? (you'd probably replace do with another token, same difference though)
17:16:56 <jfredett> ivanm: Lifeboats? Who needs 'em!
17:17:29 <ivanm> Philippa: it kinda makes sense, but does all do-notation stuff translate?
17:17:40 <ivanm> jfredett: the Titanic did...
17:17:59 <Philippa> ivanm: no, it doesn't. This wouldn't work: do f <- g; f;
17:18:12 <ivanm> yeah, that's what I figured
17:18:30 <Philippa> it's "do for applicatives" in that it gives you the closest, most natural equivalent
17:19:06 <ivanm> right
17:19:15 <ivanm> but you're more limited in what you can do
17:19:41 <Philippa> depends: is being able to do half-decent static analysis a limit? :-)
17:21:02 <Philippa> hey edwardk
17:21:06 <edwardk> heya
17:22:39 <McManiaC> is there a way to pattern match on the IO monad?
17:23:16 <ivanm> McManiaC: no
17:23:48 <ivanm> for one, IO's constructors aren't exported
17:24:28 <McManiaC> so there is no way to write a MonadIO instance?
17:24:46 <SamB_XP_> McManiaC: not like that, no ;-P
17:24:50 <McManiaC> ok
17:24:51 <McManiaC> ^^
17:24:53 <McManiaC> damn
17:27:06 <bd_> @src IO
17:27:06 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:27:26 <bd_> (note: GHC implementation detail; here be dragons)
17:27:31 <bd_> @src RealWorld
17:27:31 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:28:25 <Philippa> McManiaC: you write them in terms of other MonadIO instances
17:28:26 <burp> I thought it was Universe
17:28:38 <burp> and not RealWorld
17:28:39 <Philippa> burp: Many Worlds, no?
17:29:05 <Philippa> "universe" has other potentially-relevant meanings
17:42:46 <ddarius> hey edwardk
17:44:47 <ddarius> So, I probably should have reread the Concurrent Haskell paper because, apparently, if two people independently try to solve concurrent selection, they'll arrive at very similar solutions.
17:45:31 <jmcarthur> ddarius: concurrent selection?
17:45:40 <jmcarthur> choice?
17:46:52 <ddarius> Yes.
17:47:18 <ddarius> The select operation of newsqueak or cml.
17:48:43 <jmcarthur> anything like the CHP (<->) operator?
17:48:57 <jmcarthur> i'm not very familiar with those languages
17:53:26 <ddarius> select operates on channels in newsqueak and "events" in CML, rather than processes.
17:54:11 <ddarius> (more accurately, newsqueak's select operates on sends/receives on channels, which is similar to CML's events)
17:54:34 <Fragsworth> In Lambda abstraction, is the "->" related to what it means in type definitions?
17:54:52 <ddarius> Fragsworth: Nope.
17:54:59 <jmcarthur> barely
17:55:06 <Fragsworth> Ok great, just clarifying
17:55:24 <ddarius> Fragsworth: The usual notation for lambda abstractions uses a . instead of a ->, e.g. \x.x for \x -> x
17:55:56 <ddarius> In that context, -> doesn't mean anything on its own, and is just syntax to separate the argument list from the boy.
17:56:01 <ddarius> s/boy/body
17:56:09 <jmcarthur> (\a -> b) :: a -> b  means  a :: a  and  b :: b. that is probably as close as you can get
17:56:28 <jmcarthur> that breaks when you have multiple arguments
17:56:32 <Cale> So, it is sort of related :)
17:57:11 <Cale> If you split up the lambdas with multiple arguments, it becomes related again
17:57:15 <jmcarthur> yes
17:57:30 <jmcarthur> if you call the multiple arguments "syntax sugar" i guess it's fine
17:57:53 <Cale> (though strangely enough, in the presence of seq, we can tell the difference between lambdas with multiple arguments and nested lambdas...)
17:58:00 <jmcarthur> O_o
17:58:09 <ddarius> jmcarthur: There's a cml library on hackage if you want to look into it.
17:58:16 <jmcarthur> s/seq/unsafeSeq/ :(
17:58:43 <ddarius> Indeed, seq breaks uncurry . curry = id, curry . uncurry = id
18:00:04 <SamB_XP_> Cale: that's standard ?
18:00:23 <SamB_XP_> not some GHC bug ?
18:00:45 <Cale> SamB_XP_: I don't think it's a bug, but I think the standard is a bit unclear about it.
18:00:58 <Cale> Well...
18:01:28 <SamB_XP_> Cale: yeah, I'm pretty sure it was not realized by the committee
18:04:17 <Cale> It's conceivable from the way that the standard is written that lambdas without patterns in their parameters get translated into nested lambdas, I think.
18:04:17 <christophergreen> Hi! I was attempting to use Cabal to update QuickCheck, which cabal info indicates the most reason version is 2.1. However, when attempting to use cabal install QuickCheck, it says that the package is already installed (1.2). Forcing a reinstall still results in 1.2 being built.
18:04:45 <dcoutts> christophergreen: the default version is 1.2, the latest is 2.x
18:04:50 <Cale> But lambdas with patterns are explicitly translated into ones without that have a case which pattern matches on one big tuple
18:05:01 <dcoutts> christophergreen: it just doesn't tell you that very clearly
18:05:11 * ksf reads -> as "implies", in both types and lambdas
18:05:13 <dcoutts> christophergreen: use cabal install 'quickcheck >= 2'
18:05:17 <christophergreen> dcoutts: ah! thank you. I take it there is some flag for cabal that lets me...
18:05:22 <christophergreen> dcoutts: yep, thanks! :)
18:05:29 <ksf> ...or I at least try to, in the presence of currying.
18:05:58 <ksf> ...same goes for cases.
18:06:07 <ksf> ...and view patterns, for that matter.
18:07:26 <SamB_XP_> ksf: well, it's more the curry-howard isomorphism than currying
18:08:51 * ksf means that one tends to forget that Int -> Int -> Int means Int -> (Int -> Int), and read it as one function taking two arguments instead of two functions taking one each.
18:08:56 <Cale> By using patterns, you can make it really clear:
18:09:03 <Cale> > seq ((\(x:xs) y -> x + y) undefined) 0
18:09:04 <lambdabot>   0
18:09:08 <Cale> > seq ((\(x:xs) -> \y -> x + y) undefined) 0
18:09:09 <lambdabot>   * Exception: Prelude.undefined
18:10:02 <ksf> well yes a pattern has to be matched wholly, you can't just match on x:xs first and then on y without changing fall-through semantics.
18:10:02 <Cale> I believe there was an example without needing to use patterns, but I can't recall it.
18:10:27 <Cale> ksf: You could. It's just the translation in the Report doesn't say that.
18:10:47 <nswill> Is there an analogous formal design paradigm for functional programing that parallels state/activity diagrams?
18:10:51 <cwg> On a mac, what directories does the haskell platform install into?
18:11:40 <ksf> er lambda calculus is isomorphic to a turing machine, so, yes.
18:11:41 <Cale> The report could have specified that (\p1 p2 .. pn -> expr) translates to (\x1 -> case x1 of p1 -> (\x2 -> case x2 of p2 -> ... (\xn -> case xn of pn -> expr) ... ))
18:11:57 <ksf> but, frankly, you don't want to investigate that iso.
18:12:16 <Cale> Rather than to \x1 -> \x2 -> ... \xn -> case (x1,x2,...,xn) of (p1,p2,...,pn) -> expr
18:13:16 <Cale> and then there would be no difference between the two, though it would lean toward the strict end of things.
18:13:33 <ksf> nswill, but then, you might be looking for stuff like the State monad or a wrapper with multiple, mutually recursive workers, which can be easily seen as being state passing and state switching.
18:14:11 <dancor> @hoogle (a, b) -> (a -> m c) -> m (c, b)
18:14:11 <lambdabot> No results found
18:14:35 <dancor> @crowdsource (a, b) -> (a -> m c) -> m (c, b)
18:14:35 <lambdabot> Unknown command, try @list
18:15:03 <ksf> @djinn (a, b) -> (a -> m c) -> m (c, b)
18:15:03 <lambdabot> -- f cannot be realized.
18:15:27 <ksf> @djinn Monad m => (a, b) -> (a -> m c) -> m (c, b)
18:15:27 <lambdabot> -- f cannot be realized.
18:15:33 <ivanm> @vixen does @djinn know about monads?
18:15:33 <lambdabot> first you tell me.
18:15:37 <nswill> I should qualify my question in more accurately, I often use state diagrams to reason about imperative algorithms in a visual way; when I say "analogous" I mean some kind of flow chart formalism that allows you to reason about how a functional algorithm would work in a visual way. Not sure if that makes more sense.
18:16:00 <dancor> @pl hm (a, b) f = f a >>= \ c -> return (c, b)
18:16:01 <lambdabot> hm = uncurry ((. ((return .) . flip (,))) . flip . ((>>=) .) . flip id)
18:16:04 <Cale> nswill: Graph transformation of expressions.
18:16:10 <ksf> you can draw flowcharts in the same way.
18:16:20 <Cale> nswill: http://cale.yi.org/index.php/Fold_Diagrams has some examples
18:16:20 <edwardk> ddarius lives!
18:16:45 <dancor> :t (first f <$>)
18:16:46 <lambdabot> forall b c d (f :: * -> *). (Show b, SimpleReflect.FromExpr c, Functor f) => f (b, d) -> f (c, d)
18:18:05 <Cale> nswill: Of course, if you ignore matters of performance, functional algorithms don't follow anything like a flow-chart. The whole point of referential transparency is that you can reduce subexpressions in any order which terminates and you'll get the same result.
18:18:36 <ksf> ...you can draw data dependencies and descisions, though.
18:18:50 <Cale> nswill: If you're talking about the order in which reduction occurs specifically in lazy evaluation, then what you do is always reduce the outermost function application which can succeed in pattern matching.
18:19:51 <Cale> That is, replace the function with its body, and substitute in the parameters. If you're using a graph, which is a little more accurate, you draw arcs for the parameters, which means that when the parameters get evaluated, the evaluation happens to all the "copies" at the same time.
18:21:17 <ksf> ...or you can inverse the flow, starting your program at multiple points (the leaves of the dependency graph), and draw a standard flowchart until you hit the root of the graph.
18:21:22 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
18:21:47 <Cale> This is the sort of thing which is going on when functional programs are evaluated.
18:21:53 <ddarius> edwardk: Incidentally, I recently, finally, pushed out a bug-fix update of parsec3, that, among other things, makes return non-strict.  You are one of the few users I'm aware of.
18:21:58 <Cale> (I wish I had more animations :)
18:21:59 <nswill> Looking at a state chart I have in front of me here I suppose in a functional context this would translate most accurately into a data dependency graph
18:22:13 <Cale> nswill: Yeah, that sort of thing works.
18:22:29 * ksf is using parsec, too, but never noticed return being non-strict.
18:23:19 <ksf> ...most likely because getting any part of the parse forces the whole parse, anyway, as there's no no-error mode like with polypars.
18:23:20 <Cale> nswill: You can imagine that something demands some output from the data dependency graph, and the demand flows backward toward the inputs.
18:23:27 <nswill> Since the state chart just describes the steps to construct a series of lists and guarantee their contents are consistent across the interface presented to other subsystems
18:23:38 <ddarius> ksf: return is strict in all versions of parsec available except 3.0.1.  This violates the monad laws.
18:23:53 <Cale> nswill: Let's take a look at how something simple like map (*10) actually operates on a given list.
18:24:12 <Cale> @src map
18:24:12 <lambdabot> map _ []     = []
18:24:12 <lambdabot> map f (x:xs) = f x : map f xs
18:24:26 <Cale> map (*10) (1:(2:(3:[])))
18:24:43 <Cale> -> (*10) 1 : map (*10) (2:(3:[]))
18:24:48 <ksf> > map (*10) [1..4] :: Expr
18:24:49 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:24:49 <lambdabot>         against inferred ...
18:24:57 <ksf> > map (*10) [1..4] :: [Expr]
18:24:58 <lambdabot>   [1 * 10,2 * 10,3 * 10,4 * 10]
18:24:58 <Cale> At this point, evaluation is "finished"
18:25:21 <Cale> Because we have a data constructor (:) applied to some arguments.
18:25:52 <Cale> Suppose we're printing the resulting list though, so we're going to need to know what the first element is before the rest of them
18:26:00 <Cale> So we'd proceed to evaluate that now
18:26:13 <Cale> -> 10 : map (*10) (2:(3:[]))
18:27:07 <ksf> ...but we could be calling length on the result instead.
18:27:19 <Cale> Yeah, in which case we'd have taken a different path
18:27:23 <ksf> in which case we aren't interested in the contents of the list, but only its spine.
18:27:32 <Cale> We'd neglect to ever evaluate the (*10) 1
18:27:54 <Cale> Actually, I think that's a nicer example, let's do that completely :)
18:27:58 <Cale> @src length
18:27:58 <lambdabot> Source not found.
18:28:03 <ksf> > map (*10) [1..4] :: [Expr]
18:28:04 <lambdabot>   [1 * 10,2 * 10,3 * 10,4 * 10]
18:28:04 <Cale> well...
18:28:08 <Cale> length [] = 0
18:28:09 <ksf> that's the one.
18:28:12 <Cale> length (x:xs) = 1 + length xs
18:28:16 <Cale> We'll use that one
18:28:31 <Cale> (even though the real length function is a little more efficient)
18:28:40 <SamB> > length
18:28:41 <lambdabot>   {[]->0;[()]->1;[(),()]->2;[(),(),()]->3}
18:28:51 <SamB> there, that's your length for you ;-P
18:28:51 <Cale> length (map (*10) (1:(2:(3:[]))))
18:29:04 <edwardk> ddarius: nice
18:29:12 <Cale> length can't evaluate right now, because the expression it's applied to doesn't match any of the patterns
18:29:22 <edwardk> ddarius: yeah. you did see that they forked it into some lib called 'parsimony' right?
18:29:24 <Cale> So we have to evaluate the map first
18:29:42 <Cale> -> length ((*10) 1 : map (*10) (2:(3:[])))
18:29:46 <edwardk> they here i think was Iavor and Daan
18:29:54 <Cale> and now the length can pattern match
18:30:05 <Cale> x = (*10) 1, and xs = map (*10) (2:(3:[]))
18:30:13 <Cale> So this reduces to
18:30:22 <edwardk> ddarius: i'm not yet sure what their lib offers over parsec 3 though.
18:30:29 <Cale> 1 + length (map (*10) (2:(3:[])))
18:31:05 <Cale> and + can't reduce immediately, because integers are not lazy datastructures, so it needs to know both its arguments to evaluate
18:31:13 <lpsmith> > (+)
18:31:14 <lambdabot>   -3->
18:31:14 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
18:31:14 <lambdabot>  -2->
18:31:14 <lambdabot>    {-3->-5;-2->...
18:31:32 <ksf> > sin
18:31:33 <lambdabot>   -0.375->
18:31:33 <lambdabot>    -0.36627252908604757
18:31:33 <lambdabot>  -0.75->
18:31:33 <lambdabot>    -0.6816387600233341
18:31:33 <lambdabot>  -1.5->
18:31:35 <lambdabot>   ...
18:31:48 <ksf> @users
18:31:48 <lambdabot> Unknown command, try @list
18:31:48 <Cale> and length (the next outermost thing) can't reduce immediately, because map (*10) (2:(3:[])) is not [] or (x:xs)
18:31:51 <ksf> hmmm.
18:32:04 <Cale> But the map can again evaluate
18:32:06 * ksf is wondering about development priorities...
18:32:21 <Cale> nswill: Does this make sense?
18:32:26 <Cale> So we go:
18:32:36 <lpsmith> > map
18:32:37 <lambdabot>   {{()->()}->{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}}
18:32:49 <Cale> -> 1 + length ((*10) 2 : map (*10) (3:[]))
18:33:04 <Cale> -> 1 + (1 + length (map (*10) (3:[])))
18:33:12 <ksf> > return
18:33:12 <lambdabot>   No instance for (GHC.Show.Show (m a))
18:33:12 <lambdabot>    arising from a use of `M3099208974...
18:33:17 <SamB_XP_> > id
18:33:18 <lambdabot>   {()->()}
18:33:20 <Cale> -> 1 + (1 + length ((*10) 3 : map (*10) []))
18:33:35 <SamB_XP_> > compare compare
18:33:35 <lambdabot>   No instance for (GHC.Classes.Ord (a -> a -> GHC.Ordering.Ordering))
18:33:35 <lambdabot>    aris...
18:33:42 <ksf> > foldr
18:33:43 <lambdabot>   {{()->{()->()}}->{()->{[]->();[()]->();[(),()]->();[(),(),()]->()}}}
18:33:44 <SamB_XP_> > comparing map
18:33:44 <lambdabot>   No instance for (GHC.Classes.Ord ([a] -> [b]))
18:33:44 <lambdabot>    arising from a use of `Da...
18:33:45 <Cale> -> 1 + (1 + (1 + (length (map (*10) []))))
18:33:57 <Cale> -> 1 + (1 + (1 + (length [])))
18:34:05 <Cale> -> 1 + (1 + (1 + 0))
18:34:41 <nswill> Yes that makes sense
18:35:08 <Cale> This is obviously using more space than necessary. The expressions take space linear in the length of the list, while a more clever implementation of length would do the addition as it went down the list, running in log space.
18:35:16 <ddarius> edwardk: Parsimony seems to be a "fork" of Parsec 2 of which there are several.
18:35:50 <nswill> I've been trying to find a simple activity diagram that isn't completely stateful to use as an example
18:36:04 <ksf> let length xs = go 0 xs where go n (x:xs) = go (n+1) xs; go n [] = n
18:36:11 <edwardk> ddarius: mostly annoyed because i had to go rewrite a library to rename it when they snatched the name =) that'll get me to release earlier on hackage i guess ;)
18:36:17 <Cale> A particularly mind-bending one is figuring out how:
18:36:36 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
18:36:36 <nswill> But most of the time when I use an activity diagram it's to represent a cascade of computations resulting from some event which then returns flow control back to the central null state
18:36:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:36:41 <Cale> ^^ how that evaluates
18:36:55 <ddarius> edwardk: Have you released that library yet?
18:37:25 * ddarius wrote an attribute grammar rep_min in C# the other day.
18:37:37 <Cale> nswill: But *most* of the time when we program functionally, we don't ask "what does this do?" we ask "what value is this?"
18:37:57 <Cale> nswill: Which is a question that doesn't require discussion of control flow.
18:38:06 <edwardk> ddarius: not yet. i found a hack that ran faster and solved the grammars i was interested in
18:38:13 <nswill> Right
18:38:23 <ksf> actually, we don't ask "what value is this", but "what's the bleeding arity of the function, at this point in the syntax"
18:38:26 <edwardk> ddarius: so i put down the context-free attribute grammar stuff for a while, to use the locally context sensitive iteratee stuff
18:38:33 <Cale> ksf: hehehe
18:39:00 <edwardk> ddarius: did you get a chance to see my slides?
18:39:09 <Cale> ksf: The answer is always 1
18:39:14 <ddarius> edwardk: Yes.
18:39:19 <nswill> It just gets a bit confusing on how to make the models when you have to deal with events, like a gui program or a server model
18:39:24 <copumpkin> ddarius: the odd thing about the fork is that it's by the original author, isn't it?
18:40:36 <ddarius> copumpkin: Daan is the original author, but I'm not sure if he is listed there as actually being a part of it rather than just as credit.  He's listed as an author for Parsec 3.
18:40:44 <copumpkin> ah, ok
18:40:53 <ksf> it's a function from RealWorld a to RealWorld b
18:41:11 <ksf> where a is your input, b is your output, and RealWorld is what you promise your haskell program to exist.
18:41:26 <edwardk> ddarius: i've been getting a lot of mileage out of iteratee-based monoidal tokenization and then doing the rest of parsing once i've bracketed out short segments of tokens involving balanced parens or known layout.
18:42:45 <ksf> ...how you make your models will depend on what api your events, gui or server has.
18:44:07 <ksf> if it's a monadic one, stuff gets quite imperative. if you're dealing with frp, the functional approach applies. if you're mostly dealing with chaned up threads, some process calculus will help. if you're dealing with iteratees, you're going to be vastly confused for prolonged periods of time
18:44:41 * ddarius restates his exercise of implementing a binary tree creation routine driven by GUI events: a button to branch the tree and to stub a leaf and display the tree when it is complete.
18:45:04 <ddarius> E.g. Branch, Branch, Leaf, Leaf, Leaf should produce B (B L L) L
18:46:09 <ksf> that should be Leaf, Leaf, Leaf, Branch, Branch.
18:46:27 <ksf> if you have to sequentialise stuff, use RPN, for sanity's sake.
18:47:03 <Beelsebob> that's only sane if you're german
18:47:17 <ksf> nah it's polish.
18:47:19 <Beelsebob> english puts the verbs in the middle
18:47:23 <nswill> That sounds like a good exercise to try
18:47:43 <ksf> but /me always wondered about people complaining about the x87 "messing with registers".
18:47:47 <nswill> Trying to unlearn the imperative way of thinking is kind of difficult
18:48:09 <ksf> it's a perfect coding model if you do what you usually do in fpu code: lots and lots of nested expressions.
18:48:30 <ddarius> The Polish way is, I believe, a bit more difficult for an event-based interface than the reverse Polish way.
18:49:12 <SamB_XP> so ... has everyone seen http://www.frc.ri.cmu.edu/~hpm/project.archive/general.articles/1991/TempComp.html ?
18:50:09 <ksf> it's not true that german always puts the verb at the end, btw.
18:50:24 <SamB_XP> yeah, ITYM forth
18:50:54 <ksf> it's just splitting up verb combinations to surround the thing the combination logically parethesises.
18:51:20 <ksf> ... "to the theng the conbination logically parentises surrounds"
18:51:48 <SamB_XP> ksf: could you diagram that sentance ?
18:52:04 <ddarius> Requiring a push-down automata instead of a finite one.
18:52:22 <ksf> to_surround ( the thing ) -> to (the thing) surround
18:52:28 <SamB_XP> ddarius: well, you just have to keep the depth limited
18:52:44 <SamB_XP> humans do actually have a finite nesting depth limit
18:52:51 <ddarius> SamB_XP: Very limited.
18:53:12 <ksf> it centrainly trains attention span.
18:53:33 <ksf> ...which might be the reason germans can cope with epic kantean sentence length.
18:53:38 <SamB_XP> ksf: I meant one of those funky treeish things
18:54:04 <SamB_XP> ksf: well, bracketing things is something that english doesn't do enough of
18:54:24 <SamB_XP> you know how we're always having to put parens in things we say just to disambiguate the grouping ?
18:54:34 <ksf> it's nice to have pushed context over a whole paragraph, arriving at the (only) full stop and feel it all slide into context.
18:54:53 <SamB_XP> hehehe
18:54:56 <ksf> like, commata, in english?
18:55:10 <ksf> heck that's even ambiguous.
18:55:20 <SamB_XP> I don't pay attention to how many sentances are in my paragraphs, usually
18:55:23 <ddarius> ksf: Constant bewilderment followed by epiphany.
18:55:35 <SamB_XP> I just break them off where it seems best to do so ;-)
18:55:45 <nyingen> a man a woman a child a bird i heard saw knows loves
18:55:52 <nyingen> :)
18:55:55 <ksf> well, let's say it's not as sequential as 10 spo sentences.
18:57:02 <SamB_XP> I've tossed that "paragraph structure" out the window for the most part
18:57:24 <SamB_XP> I might pay a bit of attention to it in the introduction and conclusion of a paper ...
18:58:30 <SamB_XP> ... mostly because the structure there is usually supposed to reflect that of the entire paper
18:58:47 <SamB_XP> (or is it the other way 'round?)
19:00:02 <dancor> @let firstM f (a, b) = flip (,) b <$> f a
19:00:03 <lambdabot>  Defined.
19:00:24 <ksf> "But if, on the other hand, I think only a number in general, whether it be five or a hundred, this thought is rather the representation of a method whereby a multiplicity, for instance a thousand, may be represented in an image in conformity with a certain concept, than the image itself."
19:00:52 <SamB_XP> ksf: what the heck is that supposed to mean?
19:00:52 <dancor> i feel like i can use the monad arrow instance
19:01:04 <SamB_XP> :t firstM
19:01:04 <lambdabot> forall t (f :: * -> *) a b. (Functor f) => (t -> f a) -> (t, b) -> f (a, b)
19:01:06 <ksf> dunno, I'm missing the context.
19:01:33 <SamB_XP> > firstM
19:01:33 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
19:01:33 <lambdabot>                    GHC.Show...
19:01:37 <ksf> he's talking about "The Schematism of the Pure Concepts of Understanding", there.
19:01:54 <SamB_XP> oh, that sounds fairly nonsensical
19:01:54 <dancor> philosophy has a way of muddling together examples and non-examples
19:02:01 <SamB_XP> "pure concepts" indeed!
19:02:16 <SamB_XP> as if there was such a thing as a pure concept
19:02:32 <SamB_XP> what's the pumping lemma ?
19:02:51 <dancor> srsly?  http://en.wikipedia.org/wiki/Pumping_lemma
19:02:56 <Zeiris> :source Int
19:03:09 <SamB_XP> someone just asked in #zsnes
19:03:22 <SamB_XP> it sounded like the type of thing #haskell would know ;-)
19:03:33 <dancor> the pumping lemma owns
19:04:12 <ksf> "(But if (on the other hand)) (I think only a number in general (whether it be five or a hundred)) (this thought is rather the representation of a method (whereby a multiplicity (for instance a thousand) may be represented (in an image in conformity with a certain concept)) than the image itself."
19:04:42 <ksf> so, it bogs down to "this thought is rather the representation of a method than the image itself.
19:05:00 <ksf> ...but reading that alone doesn't give you enough context to grok the context.
19:05:31 <dancor> is 5 in my mind the representation of a method
19:05:33 <dancor> i wonder
19:06:00 <ksf> in fact, the sentence, or rather the way it's written and thus the order it induces thoughts, is itself the example.
19:06:10 <ksf> such things are easily lost in translation, though.
19:06:21 <dancor> i still don't know what image means there
19:06:40 <dancor> mind's eye image?
19:07:13 <ksf> the concept you have of five is not the image of a five, but the image of a method that can yield a number.
19:08:01 <ksf> as in "there's no numbers without arithmetic". cf. peano and such.
19:08:43 <dancor> well i agree that 5 is "really" succ 4 but i don't think it's that way in my mind
19:08:54 <dancor> which is far more of a mess than that
19:10:02 <dancor> :t first
19:10:02 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
19:10:06 <ksf> well, to my perception my concept of "5" is a filter that can scan multiple distinguished things parallelly, yielding true or false
19:10:28 <dancor> :t first (:[])
19:10:29 <lambdabot> forall b d. (b, d) -> ([b], d)
19:10:44 <ksf> which is actually more close to what he said that what I said before.
19:12:01 <dancor> A a b === a -> m b   is an arrow right
19:12:37 <ddarius> Yes.
19:12:42 <ddarius> Kleisli m a b
19:14:02 <FunctorSalad_> "Kleislify" has google hits :)
19:14:19 <dancor> so first there is (b -> m c) -> (b, d) -> m (c, d)
19:15:12 <dancor> > first putStr ("lol", "test")
19:15:13 <lambdabot>   (<IO ()>,"test")
19:16:08 <ddarius> > runKleisli $ first (Kleisli putStr) ("A", "B")
19:16:09 <dancor> hm i don't get why that's not of type IO ((), String)
19:16:09 <lambdabot>   Couldn't match expected type `([GHC.Types.Char], [GHC.Types.Char])
19:16:09 <lambdabot>         ...
19:16:26 <ddarius> dancor: You are using a different first instance.
19:16:39 <ddarius> Namely the (->) one.
19:17:00 <dancor> oh is there weird overlapping
19:17:06 <ddarius> No.
19:17:15 <ddarius> Kleisli is a newtyp.
19:17:27 <dancor> right, but there is ideological weird overlapping
19:17:36 <dancor> i'd be willing to drop "weird"
19:17:48 <jfredett> @remember ksf (But if (on the other hand)) (I think only a number in general (whether it be five or a hundred)) (this thought is rather the representation of a method (whereby a multiplicity (for instance a  thousand) may be represented (in an image in conformity with a certain concept)) than the image itself."
19:17:48 <lambdabot> I will remember.
19:17:55 <jfredett> that was a mindbender... :)
19:18:08 <FunctorSalad_> dancor: (->) = Kleisli Identity, up to iso
19:18:24 <ddarius> I wouldn't say so.  While usually implicit, you just need to say what category you are working in.
19:18:40 <Saizan> > runKleisli $ first (Kleisli putStr) ("A", "B")
19:18:41 <lambdabot>   Couldn't match expected type `([GHC.Types.Char], [GHC.Types.Char])
19:18:41 <lambdabot>         ...
19:18:55 <camio> Anyone know the status of C--?
19:18:55 <Saizan> > runKleisli (first (Kleisli putStr)) ("A", "B")
19:18:56 <lambdabot>   <IO ((),[Char])>
19:19:21 <ksf> oh, kant's original text is even nicer.
19:19:40 <ksf> whoever made that translation chopped up sentences throughly.
19:19:43 <atp> hey, are ghc-pkg and cabal related and if so how?
19:19:44 <hackagebot> NetSNMP 0.1.1 - Bindings for net-snmp's C API for clients (JohnDorsey)
19:20:08 <FunctorSalad_> atp: cabal install registers things with ghc-pkg
19:20:24 <Saizan> and uses ghc-pkg to see which packages are installed
19:20:37 <atp> FunctorSalad_: does it generate the description file for ghc-pkg from the cabal file, or are they the same thing?
19:20:38 <Saizan> when you use ghc as the compiler, of course
19:20:57 <ksf> it's not like he'd be using usual german sentence length or trying to be pretentious and/or obscure, he's doing his best to be 100% precise.
19:21:11 <dcoutts> atp: right, cabal generates the info that ghc-pkg expects.
19:21:17 <Saizan> atp: it generates it from the .cabal file and the decisions taken in the configure step
19:21:18 <dancor> @let firstM = runKleisli . first . Kleisli
19:21:18 <lambdabot>  <local>:8:0:
19:21:18 <lambdabot>      Equations for `firstM' have different numbers of arguments...
19:21:29 <dancor> @unset firstM
19:21:29 <lambdabot> Unknown command, try @list
19:21:39 <atp> i guess my question specifically is, if i downloaded the source to a package and want to install it, can i use cabal?  or is cabal only for pulling stuff from hackage and then building it a la apt-get?
19:21:44 <dcoutts> atp: .cabal files are not the same thing as the info "ghc-pkg register" expects and "ghc-pkg describe" produces
19:21:54 <dcoutts> atp: does both
19:22:00 <atp> hm
19:22:03 <FunctorSalad_> in lambdabot land, a single equation can have different number of arguments from itself?
19:22:21 <dancor> @undefine firstM
19:22:26 <Saizan> atp: if you run "cabal install" in a directory with a .cabal file it'll install that package
19:22:29 <dancor> @suicide
19:22:29 <lambdabot> Unknown command, try @list
19:22:33 <FunctorSalad_> @unlet firstM
19:22:33 <lambdabot>   Parse error: SemiColon
19:22:35 <atp> Saizan: aha!
19:22:39 <FunctorSalad_> lol
19:22:47 <atp> Saizan: let me try that then, maybe that's all i need to do
19:22:50 <Saizan> ..and the rest of the files that package expects
19:23:07 <dancor> @let firstM = runKleisli . first . Kleisli
19:23:08 <lambdabot>  Defined.
19:23:14 * dancor cries
19:23:28 <dcoutts> atp: and if the package you want to modify is from hackage, then just use $ cabal unpack foo
19:24:00 <ksf> there's unpack?
19:24:03 <FunctorSalad_> atp: if you do "cabal install" in a directory where there is a .cabal file, that file will be used
19:24:12 <ksf> I've always used fetch and tar xvzf
19:24:20 <ksf> you've just saved me hours!
19:24:23 <atp> dcoutts: i actually did do that... i'm new to cabal, sorry for the silly questions... i wanted to hack on a package before installing it, and i had some problems
19:24:40 <atp> dcoutts: (with cabal and ghc-pkg, not the hacking :p)
19:24:54 <dcoutts> atp: right, it's a nice workflow: cabal unpack foo; cd foo-x.y/; hack hack; cabal install
19:25:09 <atp> dcoutts: nice
19:25:21 <dcoutts> thanks to Saizan for adding "cabal unpack"
19:25:34 <atp> dcoutts: and if my distro registers binary packages when i install them, and install my hacked packages with --user, everything just works, it seems
19:25:50 <dcoutts> atp: right, user packages mask global ones
19:25:51 <ddarius> My cabal doesn't have unpack.
19:25:56 <dcoutts> ddarius: upgrade!
19:26:02 <dcoutts> cabal install cabal-install
19:26:04 <dcoutts> :-)
19:26:07 <ddarius> I probably should.  I wanted it a bit ago.
19:26:37 <atp> dcoutts: see, that was my problem... i installed a package as a binary, and then wanted to change it, so i unpacked it, and i actually used the --reinstall option... then when i deleted the global version, stuff was wack
19:26:46 <atp> my own durn fault for not reading the fm
19:26:51 <atp> as usual
19:28:22 <atp> alright, thanks for the help guys, off to eat dinner
19:33:24 <ivanm> dcoutts: is there a new cabal-install?
19:34:12 <ivanm> nope, hackage doesn't seem to have it...
19:34:35 <ivanm> oh, it's already in 0.6.2
19:40:58 <dancor> does ghci support incremental compilation
19:42:26 <Makoryu> dancor: Sort of. Every binding you type into it (with "let foo = bah...") is compiled to memory.
19:43:02 <ddarius> dancor: Define what you mean by "incremental compilation"
19:43:41 <Makoryu> dancor: If you want to compile a module, you have to compile it all at once (with :load/:reload)
19:44:45 <Saizan> ghci compiles to bytecode though, which is not what ghc does, and can be orders of magnitude slower
19:44:48 <Makoryu> ddarius: Common Lisp allows you to paste any function/macro/package definition into a REPL and have it compiled one definition at a time
19:45:11 <Saizan> though it'll load the ghc generated code for installed libraries or precompiled modules
19:45:15 <ddarius> Makoryu: I did not ask what you mean by "incremental compilation."
19:45:56 <bcw> AFAIK, ghci isn't a compiler, it's an interpreter. ghc is the compiler, but i don't know if it supports that feature
19:46:04 <Makoryu> ddarius: I'll stop speculating.
19:46:30 <Makoryu> bcw: You can always implement it for your own program using hs-plugins
19:47:53 <bcw> Makoryu, ok.  just pointing out that asking whether ghci compiles in any sort of way is kinda meaningless.  bytecode is just an intermediate code, which some interpreters have always had.
19:51:19 <bcw> except that traditional interpreters didn't use their icode as part of their language definition, like bytecode is
19:58:53 <bcw> the old interpreter designers said, "nevermind the compiler behind the curtain ... that's an implementation detail."  i guess "explicit is better than implicit" after all :)
20:00:23 <bcw> so anyway, ghci does something *like* compiling, i concede
20:01:51 <copumpkin> compilation is just transformation of one code to another!
20:02:07 <copumpkin> that preserves your semantics, you hope
20:03:15 <lispy|web> What is the complexity of Prelude.union?
20:03:27 <lispy|web> ?src union
20:03:27 <lambdabot> union = unionBy (==)
20:03:39 <lispy|web> ?src unionBy
20:03:39 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
20:03:41 <copumpkin> I'd assume it's n^2
20:03:47 <copumpkin> since it doesn't require Ord
20:03:58 <Makoryu> :t unionBy
20:03:58 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
20:04:06 <lispy|web> copumpkin: more like O(n*m)?
20:04:12 <copumpkin> yeah
20:04:25 <lispy|web> and if I have two sorted lists?
20:04:32 <lispy|web> Is there an existing union that is fast?
20:04:39 <copumpkin> Data.OrdList
20:04:42 <copumpkin> @hackage data-ordlist
20:04:42 <lambdabot> http://hackage.haskell.org/package/data-ordlist
20:04:43 <ivanm> shouldn't it also remove duplicates from xs?
20:05:02 <ivanm> lispy|web: Data.Set.union is faster! :p
20:05:16 <lispy|web> ivanm: yeah.  I have lists for some reason
20:05:23 <ivanm> >_>
20:05:27 <lispy|web> This isn't code I wrote, just code I want to optimize
20:05:41 * ivanm has become over-obsessed with sets for his latest hacking effort
20:05:50 <Makoryu> :t nubBy
20:05:51 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
20:05:57 <Makoryu> :t nub
20:05:58 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:06:05 <lispy|web> sets are cool
20:06:15 <Makoryu> > nub . words $ "yeah yeah etc. whatever"
20:06:15 <lambdabot>   ["yeah","etc.","whatever"]
20:07:21 <lispy|web> I'll try throwing in this OrdList.union and see what happens
20:07:36 <copumpkin> there's also xunion
20:08:13 <lispy|web> xunion?
20:08:21 <Makoryu> :t xunion
20:08:22 <lambdabot> Not in scope: `xunion'
20:09:26 <lispy|web> ugh, the cabal file doesn't enable optimazitons
20:09:37 <lispy|web> How can I force my local cabal to build it with -O2?
20:12:59 <lispy|web> cabal fetch; lots of manual steps; done
20:13:58 <ddarius> cabal install --ghc-options=-O2
20:14:38 <lispy|web> ah
20:14:41 <Gracenotes> hm. when does Karmic Koala come out again?
20:14:41 <lispy|web> handy :)
20:14:54 <lispy|web> Gracenotes: is that a TV show?
20:15:02 <tommd> October if that's the next one.
20:15:19 <Gracenotes> yes, it is the next one. what date, though :x
20:15:34 <Gracenotes> lispy|web: ubuntu major release
20:15:43 <tommd> I think he was joking.
20:15:58 <Saizan> -O2 also works with cabal install, iirc
20:16:02 <tommd> But if he wasn't I'll give him heck for it at the hackathon.
20:16:04 <Gracenotes> wikipedia says 29 October 2009
20:16:05 <lispy|web> Gracenotes: ah.  They always have such silly names
20:16:18 <Gracenotes> why, that's almost november
20:16:33 * lispy|web has always been more fond of stable/testing/unstable
20:16:45 <tommd> They will have to call it 9.11, not 9.10 - that would probably break some scripts.
20:17:03 <tommd> lispy: Ubuntu simplified that system by eliminating the stable and testing branches.
20:17:25 <Gracenotes> lispy|web: a la arch?
20:17:48 <lispy|web> Gracenotes: debian FTW
20:18:00 * lispy|web has yet to try arch
20:18:07 <wdonnelly> Gracenotes: not exactly like arch. arch made everything into 'testing', ubuntu just went with 'stable'
20:18:08 <tommd> I really liked Arch - I miss my arch.
20:18:10 <Gracenotes> oh, yeah, nevermind, that wouldn't apply to arch
20:18:44 * lispy|web grumbles about trying to optimize stuff
20:19:04 <lispy|web> I don't think switching to Data.OrdList.union is going to make much difference here :(
20:23:07 <lispy|web> speaking of efficency, I should probably be hacking on chrome instead of waiting for the mac and linux support...
20:23:19 * lispy|web glares at FF for taking up so much ram and CPU
20:23:56 <Gracenotes> my test on asymptotic stuffs/master theorem is tomorrow :o
20:24:26 <Gracenotes> based on CLSR's intro, chapters 2-4
20:25:06 <lispy|web> um...my test case time doubled
20:25:40 * lispy|web runs it again, hoping that the disk cache in the OS just needed to heat up
20:25:40 <ddarius> I didn't prefer Chrome on Windows, and I think most of my troubles with Firefox are due to the Flash plugin.
20:26:06 <ddarius> lispy|web: Why not just write your own sorted list merge?
20:26:13 <lispy|web> ddarius: plugins are a huge source of problems in FF.  Flash is quite troublesome, but so are all the FF plugins.
20:26:37 <lispy|web> ddarius: well, if there is one out there, then hopefully it is nice and why not just use it?  But...it seems to make matters worse some how
20:27:09 <lispy|web> The nicest thing about FF is adblock plus, IMO
20:27:14 * bos is sad because scion doesn't work
20:29:23 <lpsmith> wait,  I'll admit I'm not a cabal guru.   But my ~/.cabal/config  has a line  -- optimization: True,   I thought that meant it compiles everything -O by default.
20:29:35 <bos> lpsmith: "--" is a comment
20:29:45 <lpsmith> right
20:29:58 <bos> but you are correct, cabal is using -O by default
20:30:15 <lispy|web> ah, I didn't realize that
20:30:15 <lpsmith> but when cabal writes out a default file,  doesn't it put the defaults in comments?
20:30:17 <lispy|web> good to know
20:30:28 <bos> lpsmith: right
20:30:31 <lpsmith> ah, ok
20:31:21 <lpsmith> I mean, as a practical matter, there isn't much you want to compile without at least the strictness analyzer running.
20:31:34 <lispy|web> I wonder if the definiton of Ord for elements of my list is much slower than the implementation of Eq
20:31:59 <lispy|web> That could explain the slow down
20:32:01 <Saizan> lpsmith: the default is -O, not -O2
20:32:26 <lpsmith> Saizan:  -O includes strictness analysis :-)
20:33:05 <lpsmith> lispy|web:  That's a good question, that I'll admit I haven't bothered to find the answer to.
20:33:38 <Saizan> lpsmith: yup, i was connecting it to lispy's question about -O2 earlier
20:33:55 <lpsmith> But my intuition is that at least for some things,  like Int,  there should be little difference between (==) and compare
20:34:30 <lispy|web> newtype AnchoredPath = AnchoredPath [Name] deriving (Eq, Show, Ord)
20:35:41 <Saizan> where Name?
20:36:36 <lispy|web> newtype Name = Name BS.ByteString  deriving (Eq, Show, Ord)
20:36:47 <lispy|web> not sure why Name exists
20:37:25 <lispy|web> ByteString -> Name doesn't seem to do anything special
20:38:26 <lpsmith> lispy|web:  if you are concerned that you might confuse a random bytestring with a "Name",  then a newtype can help you prevent that
20:38:44 <lpsmith> It can be stylistically pleasing,  or not.   I've seen it go both ways
20:38:52 <lispy|web> lpsmith: aye, and I can see that when a Name is, for example, a sanitized ByteString
20:39:28 <lispy|web> it may very well be doing something here.  I just hope the rewrite rules fire after the newtype is 'removed'
20:40:16 <FunctorSalad_> well do they?
20:40:29 <lispy|web> no idea :)
20:40:32 <FunctorSalad_> -ddump-simpl-stats shows it IIRC
20:40:34 <lpsmith> lispy|web:  use ghc-core :-)
20:42:12 <lispy|web> Trying some other stuff at the moment, but yeah I may dig into that
20:43:21 <lispy|web> there is a listA = sort [ ... ]; listB = sort [ ... ]; foo = reverse (listA `union` listB);  I'm sort of curious what happens to the run time if I remove the sorts and reverse
20:44:51 <ezyang> Hallo Haskellers!
20:46:08 <lispy|web> ezyang: hi
20:46:08 <jfredett> ezyang: hiya!
20:46:15 <lispy|web> 'ello jfredett
20:46:26 <jfredett> lispy|web: hi lispy.
20:58:32 * bos determines that the Monoid instance for Data.Map is kind of useless
21:01:01 <shepheb> show of hands: who pronounces EDSL as "eee dee ess ell", and who as "edsel"?
21:01:25 <FunctorSalad_> I mentally pronounce it in german
21:01:29 <monochrom> eee dee ess ell
21:02:01 <ray> it's just a token to me
21:02:13 <dm`> eee dee ess ell
21:02:24 <jmcarthur> eee dee ess ell
21:02:26 <monochrom> (Does anyone pronounce RTFM as rutfem or something?)
21:02:43 <jmcarthur> are tee eff emm
21:05:53 <shepheb> hmm, I seem to be in a minority. now I feel weird for mentally saying "edsel".
21:08:01 <FunctorSalad_> I do pronounce "ROFL" "roffle" IRL
21:08:03 <khora> I want to write a function that takes in input any other expression (function, value, whatever...) and prints the execution time as well as returning the result of the  computation. Similarly to the time function in Clojure. I implemented it in Scala, and now I would like to compare it to the equivalent in Haskell.
21:12:32 <dm`> And I would like to make my Haskell code run really, really fast, so I don't even have to worry about printing execution times.  Unfortunately I'm about 20x slower than C now.  Array modifications are killing me.
21:13:01 <jmcarthur> ew array modifications
21:13:42 <bos> array modifications == sometimes, doing it wrong
21:14:14 <dm`> Well, I'd love suggestions on avoiding it.
21:14:21 <jmcarthur> what are you doing?
21:14:25 <bos> bit hard in a vacuum.
21:15:06 <dm`> I'm implementing the RC4 stream cipher, and putting it into lazy bytestrings.  It's super convenient for testing out network transports, because you can hPut the lazy string in one end, and just compare to the string on the other end to make sure the data you get out is what you put in.
21:15:34 <dm`> Constant space is great.  But running time is very bad.
21:16:31 <jmcarthur> unfortunately i am unfamiliar with rc4 :\
21:16:40 <dm`> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9822#a9822
21:16:44 <dm`> very simple algorithm.
21:17:14 <dm`> check out a4byte.  4 lines of code, returns a pseudo-random byte.  But permutes to elements in a 256-element byte array.
21:17:25 <dm`> s/to/two
21:17:25 <bos> it has a very similar pattern to some code i wrote recently.
21:17:55 <dm`> And, did you find a way to make your code fast?
21:18:06 <bos> i did, but it's not convenient.
21:18:34 <dm`> If only there were some way of creating a lazy bytestring inside a monad (like the ST monad).
21:18:49 <bos> you can do so via use of unsafeInterleaveST.
21:19:00 <bos> it's just tricky.
21:19:16 <dm`> @hoogle Monad m => (a -> m (Maybe (Word8, a))) -> a -> m ByteString
21:19:17 <lambdabot> No results found
21:19:39 <bos> right, it's an unfold.
21:20:10 <dm`> a monadic unfold, basically.  Data.ByteString.Internal has versions in the IO monad.
21:20:59 <bos> which is essentially what you need, if you want to clobber a mutable array in-place.
21:21:14 <dm`> But then I need unsafePerformIO, right?
21:21:24 <bos> and you can't write a suitable function over any monad, only IO or ST.
21:21:37 <bos> you could do it via the ST monad.
21:21:56 <dm`> Though if I do it via the ST monad, do I even need to so anything unsafe?
21:22:17 <bos> unsafeInterleaveST, so you can generate new chunks on demand instead of spewing them all at once.
21:22:40 <dm`> Why is unsafeInterleaveST unsafe?
21:23:30 <bos> good question. maybe it's named that way for consistency.
21:23:38 <dm`> And wouldn't the Control.Monad.ST.Lazy already give me laziness?
21:23:54 <bd_> dm`: because it results in IO effects occuring at unpredictable points. This can result, among other things, in deadlocks in pure code (consider pure code, forced from a STM transaction, forces an unsafeInterleavedIO thunk that in turn tries to do STM)
21:24:12 <bos> bd_: he's asking about unsafeInterleaveST
21:24:15 <c_wraith> ST can be executed as IO, though.
21:24:16 <bd_> oh, ST
21:24:19 <dolio> unsafeInterleaveST allows you to produce non-deterministic pure functions.
21:24:25 <bd_> indeed
21:24:42 <bd_> actually, using RealWorld I think you can produce unsafeInterleaveIO from unsafeInterleaveST
21:25:02 <bos> yes, the underlying representation is the same.
21:25:19 <dm`> Okay, but without stToIO, what's the least safe thing I can do with unsafeInterleaveST?
21:25:43 <dolio> Violate referential transparency.
21:26:03 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8540
21:26:32 <dm`> So I could imagine producing two strings such that the first one read is always "a", and the second one read is "b", but since I can't go back and read them the other way, why does it matter?
21:26:54 <dm`> wrote that before reading your example, hold on.
21:27:00 <bd_> dm`: Look again - just evaluating a2 causes b2 to change. Spooky action at a distance :)
21:27:14 <bd_> it's 'unsafe' because it violates one of the fundamental rules of Haskell
21:27:31 <bd_> one of the rules that the optimizer implicitly assumes to be true, at that
21:27:48 <dolio> Because "runST bad" has a pure type, and so should always produce the same results.
21:28:20 <dm`> how does the other one change?  I'm assuming that unsafeInterleaveST is like unsafeInterleaveIO, not inlinePerformIO.  Is it more like inlinePerformIO where it could perform an action multiple times?
21:28:32 <ddarius> dm`: The issues are similar to the ones for unsafeInterleaveIO, but worse because due to runST, we can't sweep pretend that the non-determinism comes from outside.
21:29:49 <dm`> Oh, I see.  Issue is not that it changes after returning from runST, but rather that two identical invocations of runST (an ostensibly pure function) return values that look different.
21:29:52 <Heffalump> not just that, but why would you use it? There's no lazy file reading.
21:30:02 <dolio> Referential transparency says that I should be able to rewrite that code to say "let p = runST bad ; (a1, b1) = p ; (a2, b2) = p in ..." and get the same results.
21:30:07 <dm`> Thanks for that example, BTW.
21:30:11 <dolio> But you don't.
21:31:35 <dm`> So what I want should be safe.  I want a function like "makeRandomByteString seed" where you get back a 100MB pseudo-random ByteString.Lazy generated deterministically from the seed.
21:31:36 <ddarius> runST . unsafeInterleaveST === unsafePerformIO . unsafeInterleaveIO . stToIO
21:32:04 <dm`> The real answer here is for me to use Iteratee.
21:32:09 <khora> What would be the equivalent Haskell function of this Scala time function: http://pastie.org/629979?
21:34:18 <dm`> So here's a simpler question.  Is it possible to return both an array and some other values from runSTArray?
21:35:13 <Gracenotes> it is possible with runST, for sure
21:35:37 <dm`> But with runST, you don't get the magic copy avoidance for arrays, do you?
21:35:56 <dm`> Or just call freeze manually?
21:36:22 <dm`> I guess I just need to play with this stuff a bit.  I'm guessing it can give me some pretty sizeable speedups.
21:36:32 <Gracenotes> I rewrote this page specifically for this issue :)  --> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
21:36:40 <Heffalump> I think runSTArray just does an unsafeFreeze under the covers
21:36:51 <khora> I guess my question is, how do I benchmark a snippet of Haskell code?
21:37:00 <roconnor> @type runSTArray
21:37:00 <lambdabot> Not in scope: `runSTArray'
21:37:08 <Gracenotes> to quote, uh, myself.. "If you want to use the same memory locations before and after freezing or thawing but can allow some access restrictions", then see unsafeFreeze and ilk
21:37:32 <dm`> khora: getClockTime
21:37:38 <dm`> khora: http://hackage.haskell.org/packages/archive/old-time/1.0.0.2/doc/html/System-Time.html
21:37:47 <dm`> khora: Use seq to force evaluation
21:37:54 <jmcarthur> rnf
21:38:31 <jmcarthur> @hoogle evaluate
21:38:31 <lambdabot> Control.Exception evaluate :: a -> IO a
21:38:31 <lambdabot> Control.OldException evaluate :: a -> IO a
21:38:31 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
21:38:39 <khora> dm`: I'm too new to Haskell to understand that. :( Is there a pre-made function I can use like time (something)
21:38:39 <Gracenotes> Heffalump: and I'm guessing it doesn't have to worry about access restrictions because, by the time you have the array, the ST will be out of scope
21:38:59 <bos> i wonder why Data.Traversable has forM but not forM_
21:39:01 <Gracenotes> I think Cale wrote a package just for timing things
21:39:04 <Heffalump> Gracenotes: right
21:39:38 * Heffalump is looking forward to bos's framework for timing things
21:39:40 <jmcarthur> bos: Data.Foldable has it
21:39:56 <Gracenotes> mm, http://hackage.haskell.org/packages/archive/timeit/1.0.0.0/doc/html/System-TimeIt.html
21:40:19 <Gracenotes> it's an IO action, though... but rnf blah `seq` return (), would work
21:40:27 <Cale> That's not my package, but I did put code on the wiki for doing that, so maybe someone packaged it for me.
21:40:30 <bos> jmcarthur: ah
21:40:42 <Gracenotes> ah, I see
21:41:18 <Cale> er, hmm... doesn't seem to be my code
21:41:32 <Gracenotes> hm. I do recall you saying code .like. it on IRC
21:42:00 <Gracenotes> still, it is a good simple package for timing things, does the time for you
21:42:16 <Gracenotes> prints out the results
21:43:01 <Gracenotes> oh, maybe it was augustss..
21:43:41 <lpsmith> Heffalump:  I agree :-)
21:44:28 <dm`> Gracenotes: still reading your wiki page, it's very helpful, thanks.
21:45:41 <Gracenotes> well.. I basically only added and augmented examples >_> mainly because STArray is a rather weird API to get into
21:46:37 * lispy|web has never really learned how to place cost centres
21:46:57 <Gracenotes> code that uses it tends be structured in similar ways.
21:47:32 <dm`> Maybe DiffArray will solve my problem.  I should benchmark that.
21:47:36 <Gracenotes> an example function type: killMonster :: STRoom s -> Coord -> ST s (STRoom s)
21:48:45 <Gracenotes> with: data STRoom s = STRoom (STGrid s) [Actor] Actor, type STGrid s = STArray s Coord Square, type Coord = (Int, Int). the s is everywhere.. that's the point of it, I suppose :x
21:49:01 <Gracenotes> hm, I haven't heard too good things about the performance of DiffArray, iirc
21:50:41 <Gracenotes> the benchmarks don't lie, though -_-
21:50:58 <khora> I can't install cabal on Mac OS 10.6
21:51:43 <dm`> Hmm... Still waiting for DiffArray benchmark to complete... I'm going to guess this is not the solution.
21:52:00 <khora> I get errors like: 32-bit absolute addressing is not supported for x86-64
21:52:38 <dm`> Yeah, about 50 seconds for DiffUarray, and 2 seconds for UArray.
21:54:00 <Zeiris> Gracenotes, so how does that killMonster function work? It takes a pure STRoom value, and returns a state modification of that value?
21:54:07 <Zeiris> What do the little 's' es mean :E
21:54:55 <dm`> The s's are to prevent you from using STRefs allocated in one invocation of runST in a different invocation of runST.
21:55:36 <dm`> They are a placeholder fake type, to make all of your types incompatible each time you execute an ST computation.
21:56:15 <Gracenotes> Zeiris: in IO-speak, it would be: IORoom -> Coord -> IO (IORoom)
21:56:57 <Gracenotes> since people use ST for the mutability that IO affords, while keeping things referentially transparent, and avoiding the ugly IO type
21:57:21 <Gracenotes> so the final type is ST s x, because it is in the ST monad, like it would be IO x in the IO monad
21:57:24 <Zeiris> Referential transparency = can be replaced by the value, right? But if the state is complicated enough, can that still be done?
21:57:39 <Zeiris> Is a STRoom that was built up over several hours of gameplay, be any different from a scanf or fread?
21:58:05 <BMeph> To ask the question is to answer it. ;)
21:58:06 <dm`> The difference is no side effects.
21:58:11 <ezyang> Zeiris: well, you're not replacing it with a value when you're in the state monad...
21:58:14 <Gracenotes> the reason why it is (STRoom s) is because 's' is used in STArray s Coord Square, and the polymorphic s has to come from somewhere
21:58:57 <Gracenotes> once you accept that s just needs to be everywhere, and it behaves like IO in the types made for it (STVar, STArray, etc.), it's fine
21:59:45 <danr> hmm... is it possible to do something like type ST' = forall s. ST s
22:00:25 <Gracenotes> hm. in terms of mutable operations with ST, referential transparency would probably be closer to: if you come in with a state, you'll come out with the same state every time
22:00:48 <Zeiris> Aaaah, thank you gracenotes :)
22:01:28 <Gracenotes> for that particular input state. I had a 'normal' representation with a plain immutable Array, and a part where it was converted to an STArray, then back to an Array again
22:01:43 <Gracenotes> for performance reasons
22:02:18 <Gracenotes> so if you called the ST-using function with the array one time, it would yield the same output as calling it any other time (assuming the other parameters were equal, like what key was pressed)
22:02:36 <Gracenotes> well, again, calling it any other time with that particular array
22:03:48 <Gracenotes> as it turned out even this was sluggish when scaled a lot, so I just changed it to IOArray and didn't bother with immutability in the end >_>
22:04:39 <Gracenotes> by a lot I mean more monsters than any sane room would have. even more than an insane room.
22:05:35 <Gracenotes> but at that point I hadn't introduced more complicated, AI-ish monsters
22:08:53 <dm`> What's the difference between ! and !! as a strictness qualifier?
22:09:01 <dm`> E.g., data ByteString
22:09:01 <dm`> = Empty
22:09:01 <dm`> | Chunk !!ByteString ByteString
22:09:01 <dm`>  
22:10:30 <Cale> I was unaware that's even valid syntax
22:10:46 <Makoryu> Same here
22:11:06 <dm`> Hmm.. Maybe some weird haddock thing.  The actual source says:
22:11:14 <dm`> data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString ByteString
22:12:45 <Cale> Maybe it's trying to represent the {-# UNPACK #-} in a strange way.
22:13:29 <Cale> That would actually probably be a more sensible notation than the pragma.
22:13:55 <FunctorSalad_> :)
22:13:58 <Cale> But the pragma has the advantage of being ignored when it's unsupported.
22:14:20 <FunctorSalad_> what happens if you do the pragma without the bang?
22:14:33 <Makoryu> So, I can write {-# PIZZA CheeseAndPepperoni #-} and the compiler will skip right over it?
22:14:51 <dolio> Try it.
22:15:09 <dm`> > {-# PIZZA CheeseAndPepperoni #-} 99
22:15:10 <lambdabot>   99
22:15:34 <Gracenotes> PIZZA not found
22:15:40 <ivanm> lol
22:16:38 <Makoryu> Here it only prints "Unrecognized pragma" :(
22:18:09 <Gracenotes> doesn't say anything here
22:19:02 <bos> man, Text.Printf makes code fugly.
22:19:05 <Gracenotes> unless, of course, you do {-# LANGUAGE CheeseAndPepperoni #-}: t.hs:1:13: unsupported extension: CheeseAndPepperoni
22:23:13 <lispy|web> wow okay.  So my version of sortedUnion is significantly faster than using Data.OrdList.union
22:23:22 <ivanm> lispy|web: how do you do it?
22:23:36 <lispy|web> ivanm: well I'm not sure why it's so much faster
22:24:08 <lispy|web> 1) I don't pass a dictionary, I have a concrete monotype (no type variables), 2) I put the exceptional cases (empty lists) at the end
22:24:23 <lispy|web> Once I verify this one more time I'll try move the pattern matches around and see if that makes a difference
22:24:38 <ddarius> You also have better inlining and such presumably.
22:24:46 <mornfall> lispy|web: Hmm. If it's for zipTrees, rewriting it to use recursion and union on 'items' keyset would be probably better.
22:25:05 <mornfall> lispy|web: Recursion on the Tree, instead of relying on "list" to convert it into a flat structure.
22:25:15 <lispy|web> mornfall: this is for zipTrees.  I think with this version, that I can send you, it is back on par with non-hs darcs
22:25:29 <lpsmith> lispy|web:   use the unionBy variant
22:25:43 <mornfall> Great. I'll be offline for a few hours, but I'll read the patch as soon as I am back online.
22:25:44 <lpsmith> lispy|web:  I don't have any SPECIALIZE pragmas on Union
22:25:57 <lispy|web> lpsmith: did you write OrdList?
22:25:59 <mornfall> Well, about 6 or so. :) See you! (and thanks)
22:26:04 <lpsmith> yep :)
22:26:07 <lispy|web> mornfall: np :)
22:26:10 <lispy|web> lpsmith: ah
22:26:42 <lpsmith> I doubt changing the order of patterns around will make any difference,  but if it does,  I'm most interested in hearing about it :-)
22:26:52 <lispy|web> lpsmith: but, I'd just be doing unionBy (==)
22:27:00 <lispy|web> or is it compare
22:27:03 <lpsmith> compare
22:27:06 <lispy|web> I guess unionBy (compare)
22:27:21 <lispy|web> I'll try moving the pattern matches around
22:27:30 <lpsmith> right,  but that's not a dictionary lookup
22:27:40 <Makoryu> :t (const .)
22:27:41 <lambdabot> forall b b1 a. (a -> b) -> a -> b1 -> b
22:27:56 <lpsmith> and if unionBy gets inlined, then the higher order function will go away
22:28:00 <lispy|web> lpsmith: also, given the nature of your library, -O2 may be approriate in the .cabal file
22:28:24 <lpsmith> I've manually applied the static argument transform to the entire library, for better or worse
22:28:42 <lpsmith> Yes,  maybe,  like I said,  I'm definitely interested if you find some ways to make it better :-)
22:29:02 <Makoryu> :t ((const .) .)
22:29:03 <lambdabot> forall b b1 a a1. (a1 -> a -> b) -> a1 -> a -> b1 -> b
22:29:52 <lispy|web> lpsmith: one small way, is to use @ and not rebuild the lists in the 2 cases where that is possible
22:30:13 <bos> waaah: http://www.serpentine.com/blog/2009/09/25/riddle-me-this/
22:30:19 <lispy|web> lpsmith: moving the pattern matches around did not change the performance
22:31:05 <mmorrow> lpsmith: what's the gain of using [] instead of (Map a Int{-count-}) or something, since you've already got an (Ord a) constraint? (those are pretty loops though)
22:31:06 <lispy|web> lpsmith: so perhaps it's just the simple act of removing the dictionary overhead
22:31:08 <ivanm> bos: why panda?
22:31:15 <ivanm> I get the sad irish bit...
22:31:37 <mmorrow> and just do M.unionWith (+) etc
22:31:40 <ivanm> @hoogle hPrintf
22:31:41 <lambdabot> Text.Printf hPrintf :: HPrintfType r => Handle -> String -> r
22:31:41 <lambdabot> Text.Printf class HPrintfType t
22:31:58 <lpsmith> lispy|web:  GHC already does that, so using the @ symbol won't help  :-)
22:32:00 <mmorrow> sup ddarius
22:32:06 <bos> ivanm: because http://www.thedailygreen.com/cm/thedailygreen/images/emo-panda.jpg
22:32:07 <lispy|web> lpsmith: oh really?
22:32:09 <ivanm> @hoogle printf
22:32:09 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
22:32:09 <lambdabot> module Text.Printf
22:32:09 <lambdabot> Text.Printf class PrintfArg a
22:32:20 <ivanm> bos: heh
22:32:28 <lpsmith> Yeah,  compile with optimization and that won't be an issue.
22:32:31 <ivanm> bos: and you associate with that panda, do you?
22:33:00 <ddarius> mmorrow: Heya
22:33:08 <lpsmith> I'll have to take a look at the possibilities of -O2,  although it usually doesn't make a huge difference
22:33:31 <ivanm> @remember bos [On the type signature of hPrintf] This makes me a sad Irish panda.
22:33:31 <lambdabot> It is stored.
22:33:43 <ddarius> bos: Basically, as currently written, to make a vararg printf-like function, you have to completely recreate the Printf type classes trickery.
22:33:50 <bos> ddarius: i know.
22:34:08 <lpsmith> mmorrow:  not necessarily any performance gain,  I haven't explored that tradeoff carefully
22:34:09 <bos> ddarius: c'est un grand bummer.
22:34:45 <ddarius> I remember thinking about this months ago.  I think it can be partially resolved by simply making more things public and/or maybe slightly extending the class.
22:35:11 <lpsmith> mmorrow:  When I want sets,  I typically use Data.Set or Data.Map.   I see Data.OrdList as something that's handy when you have lists lying around that happen to be sorted,  not as a set replacement :-)
22:35:33 <mmorrow> ddarius: easy party http://moonpatio.com/repos/PrintfGen.hs
22:35:51 <bos> what i really want is a bit of quasiquoted or TH magic to give the function a comprehensible type.
22:36:03 <lpsmith> mmorrow:   Data.OrdList grew out of a number theory library I first wrote years and years ago
22:36:36 <lpsmith> mmorrow:  Often I'd be producing lists of numbers,  not explicitly sets
22:36:42 <lispy|web> mornfall: sent :)
22:36:59 <lpsmith> mmorrow:  oh,  and Data.OrdList deals with infinite lists,  Data.Set does not :-)
22:37:16 <mmorrow> lpsmith: true
22:37:51 <ddarius> It's relatively trivial to make a TH "macro" that will produce monomorphic printf functions.  Of course you would then lose the ability to specify the format string at run-time.
22:38:41 <lispy|web> lpsmith: considering I'd be using Data.OrdList for 1 function that I can write in just a few lines it may be easiest to just use the function I wrote
22:38:49 <bos> small price to pay. that'd be a vanishingly rare case.
22:38:53 <ddarius> Of course any printf-like functions in that case would themselves have to be macros.
22:38:58 <bos> now if only i knew word one about TH.
22:39:15 <mmorrow> ddarius: being that the the haskell printf can crash, i don't consider it a solution either
22:39:34 <ddarius> bos: A simple printf was an example in the earliest TH papers (and probably all subsequent ones as well)
22:39:44 <bos> ddarius: heh
22:39:59 <ddarius> mmorrow: If you mean can pattern match error at run-time, there's no way to avoid that in general.
22:40:15 <mmorrow> , length $ replicateM 3 ["C","I","L","D","P"]
22:40:15 <ddarius> (Even dependent types can't avoid it.)
22:40:16 <lunabot>  125
22:40:35 <ddarius> Actually, yes they can for that.
22:40:35 <lpsmith> lispy|web:  sure,  but eventually I got tired of hunting down or re-writing those functions repeatedly.   I put it on cabal mostly for my own benefit :-P
22:40:48 <ddarius> It's a scanf equivalent that would be impossible to do.
22:41:00 <FunctorSalad_> the TH printf is available on hackage, btw (printf-TH)
22:41:12 <FunctorSalad_> maybe you could start from that
22:41:18 <mmorrow> ddarius: right
22:41:29 <lpsmith> But import Data.OrdList is pretty darn easy
22:41:56 <mmorrow> , length $ (\n xs -> foldr (\xs xss -> [a:as | a <- xs, as <- xss]) [[]] (replicate n xs) 3 ["C","I","L","D","P"]
22:41:57 <bos> the printf-TH package contains no documentation at all.
22:41:57 <lunabot>  luna: parse error (possibly incorrect indentation)
22:42:07 <mmorrow> , length $ (\n xs -> foldr (\xs xss -> [a:as | a <- xs, as <- xss]) [[]] (replicate n xs)) 3 ["C","I","L","D","P"]
22:42:08 <lunabot>  125
22:42:11 <mmorrow> oh
22:42:15 <lispy|web> lpsmith: yeah, I did try that earlier, it was just that it gave no performance boost because of the specilaziation issues I was unawares of
22:42:18 <lpsmith> And you'll (probably) get identical performance by GHC.Exts.inline unionBy compare   on a monomorphic type,  as what you produced.
22:42:22 <lispy|web> lpsmith: now I'm lazy to go back
22:42:23 <ddarius> printf :: pi s. calcType s
22:42:33 <lpsmith> I should add some specializations
22:42:35 <lpsmith> honestly
22:42:42 <mmorrow> anyway, it's amusing generating like 800,000 printf wrapper and watch gcc spin
22:43:36 <lispy|web> and now I can focus elsewhere for a while
22:43:44 <mmorrow> hmm, that might be the 750,000 feathers that break ghc's back though
22:43:52 <dm`> :t block (thaw (undefined :: UArray Int Int))
22:43:53 <lambdabot> Not in scope: `block'
22:43:53 <lambdabot> Not in scope: `thaw'
22:43:53 <lambdabot>     Not in scope: type constructor or class `UArray'
22:43:53 * mmorrow tries
22:44:22 <ddarius> I don't think GHC has particular trouble with large files, just large functions/values (not, post inlining).
22:44:31 <ddarius> s/not/note
22:46:36 <lispy|web> and linking
22:46:44 <lispy|web> split-objs is really terrible in some ways
22:47:16 <ddarius> GHC doesn't do the linking.  That's ld's problem.
22:47:43 <mmorrow> ddarius: this spits out an .hs module on stdout with the foreign import decls, and an instance of a Printf class that it defines for each one, but true it probably wouldn't have a problem
22:47:58 <mmorrow> , length $ (\n xs -> foldr (\xs xss -> [a:as | a <- xs, as <- xss]) [[]] (replicate n xs)) 8 ["C","I","L","D","P"]
22:48:00 <lunabot>  390625
22:48:05 <mmorrow> trying that amount now
22:48:34 <mmorrow> it'd been generating just the initial file for about a minute.. may have to bail
22:49:21 <mmorrow>  7778 m         20   0 2141m 2.1g 2492 R 99.9 54.7   2:48.48 PrintfGen
22:49:23 <mmorrow> :o
22:50:07 <mmorrow> sometimes that TH compiles to/executes as bytecode is painfull
22:50:32 <mmorrow> , length $ (\n xs -> foldr (\xs xss -> [a:as | a <- xs, as <- xss]) [[]] (replicate n xs)) 6 ["C","I","L","D","P"]
22:50:33 <lunabot>  15625
22:51:50 <lpsmith> mmorrow:  oh by the way,  I've recently stumbled across the fact the static argument transform was added,  with little fanfare, to GHC 6.10
22:52:06 <lpsmith> You have to turn it on with a flag though,  it's not used by default
22:52:46 * ddarius will probably move his crazy channel/UI code to use the CML library on hackage.
22:53:00 <mmorrow> gah! the bytecode blows the stack on exhaustive upto 6-arg printf's
22:53:13 <lispy|web> now System.FilePath.normalise is too slow
22:53:43 <lpsmith> mmorrow:  what do you mean that TH compiles sometimes to bytecode?
22:54:05 <mmorrow> lpsmith: i've been reading into loop optims (in general in addition to functional-lang specific), and suddenly find FORTRAN pretty (sometimes)
22:54:27 <lpsmith> haha
22:54:50 <ddarius> mmorrow: Have you read Olin Shiver's work (and his student's)?  Also the Hoopl paper?
22:54:56 <mmorrow> lpsmith: any splices that need to be run at compile time get compiled to bytecode, then run, since they eval to the actual code
22:54:56 <lispy|web> I think we need System.FilePath.ByteString :)
22:55:53 <lpsmith> I played around with TH a fair bit on Monday,  for the first time really,  and noticed (at least my own inept macros) often compiled to different code
22:56:10 <lpsmith> Than if I had written the exact same function by hand
22:56:14 <mmorrow> ddarius: i've checked out ghc's cmm stuff/Hoopl framework, re: Shivers hmm i just saw that name earlier but can't recall where
22:56:31 <ddarius> mmorrow: Control Flow Analysis, CFA0
22:56:41 <ddarius> Superbeta reduction
22:57:43 <mmorrow> ddarius: ah right. i saw it reference from another paper i was reading, and marked it as a to-look-at (but haven't yet). the paper that refs it being
22:57:58 <nswill> So I've been continuing to work out a method that works for me for reasoning in functional programming and I've found that if I think of a stream of data or events as a list with the list comprehension semantics (present:future) .... building my algorithm seems to be a lot easier, feels like writing a sql query for a ... stream. Would this be a suboptimal way of reasoning functional programs operating on some kind of sparse stream of events/data?
22:58:04 <mmorrow> ddarius: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.6773
22:58:14 <mmorrow> ddarius: which is really good
22:58:50 <lpsmith> oh oh oh,  now I understand what you mean by the TH bytecode remark :-)
22:59:07 <ddarius> Yes, many traditional loop optimizations are simple transforms of functional code.
22:59:23 <mmorrow> (and i got to that one from the Appel paper "ssa is functional programming" bib)
22:59:47 <lpsmith> I thought you meant that sometime bytecode was used to compile the expanded result.  What you actually meant is that the macros are bytecode-executed.
22:59:57 <khora> When I run cabal update on Mac OS 10.6 I get the following error: cabal: user error (Codec.Compression.Zlib: incompatible version) I installed zlib as universal through macports. How can I fix this?
23:00:13 <FunctorSalad_> "... and you post angry emails to haskell mailing lists saying something like "Goddamn it! What I need are third-order existential abstract generalized monadoids, and I cannot believe that Haskell doesn't support this natively!""
23:00:38 <lpsmith> mmorrow:  can't you put the heavy-lifting macros in a seperate module, and then compile that?
23:00:42 <mmorrow> ddarius: the idea though is to merge groups of functions together, transform to SSA, do all the loop-optims/etc that are known, then transform back. (at least, this is what i'm taking from it)
23:01:11 <ddarius> mmorrow: See Matthew Might's dissertation here: http://matt.might.net/#papers
23:01:27 <dm`> Can someone tell me what the correct monomorphic type is for this function?
23:01:27 <dm`> foo :: UArray Int Int -> IOUArray Int Int
23:01:27 <dm`> foo = thaw
23:01:40 <mmorrow> ddarius: i think the idea that functional programs don't have any explicit loops is wrong
23:02:04 <ddarius> mmorrow: You might be somewhat interested in looking into Static Single Information and its relation to FP.
23:02:26 <mmorrow> ddarius: heh, i've got that one too, but haven't read it yet
23:02:45 <ddarius> mmorrow: Some do, and I don't agree with you on that, I'm not sure I disagree with you that strongly.
23:03:07 <mmorrow> ddarius: right, i mean in particular lazy functional ones
23:03:12 <ddarius> mmorrow: I'm not overly enamored on SSI, but it does make more analyses trivial.
23:04:09 <khora> anyone?
23:04:11 <lpsmith> >   thaw :: UArray Int Int -> IO (IOUArray Int Int)
23:04:11 <lambdabot>   Not in scope: type constructor or class `UArray'Not in scope: type construc...
23:04:18 <lpsmith> argh
23:04:37 <dm`> Duh, thanks lpsmith.
23:05:24 <ddarius> mmorrow: Loops tend to need mutable state.  Formulations that don't tend to either be translated to recursion equations, gaining you nothing, and/or be easily capturable in HOFs upon which high-level algebraic rules can capture common optimizations.
23:06:08 <mmorrow> lpsmith: right, you can compile the module first
23:06:29 <mmorrow> lpsmith: and actually in this case i'm mistaken and there's no bytecode involved
23:07:08 <koala_man> what's HOF?
23:07:19 <ddarius> @vera HOF
23:07:21 <lambdabot> No match for "HOF".
23:07:25 <ddarius> @foldoc HOF
23:07:26 <lambdabot> No match for "HOF".
23:07:30 <lpsmith> Higher Order Function
23:07:39 <koala_man> ah
23:08:20 <lpsmith> Python 1.5 claimed to have HOFs,  but didn't actually properly support them until sometime later
23:10:02 <lpsmith> mmorrow:  regarding fortran,  it's amazing how properly understanding a quality implementation can make a language seem so much prettier :-)
23:10:27 <lpsmith> Haskell is a very pretty language on one level,   but implementationally,   not so much
23:10:39 <lpsmith> Methinks Scheme is prettier
23:11:14 <lpsmith> Once you factor what's available in state-of-the-art implementations
23:11:18 <mmorrow> ddarius: you map in an inside-out way the actuals of functions (which you then inline) to the phi(..,here,..), and (here <- phi(..)) correspond to the formal params
23:11:19 <medfly> pretty?
23:12:11 <mmorrow> so what you really gain is info about the flow of values around closed paths and into join points
23:13:00 <etate> how do I get stuff out of the IO monad and into pure land?
23:13:22 <mmorrow> lpsmith: heh
23:13:33 <mmorrow> lpsmith: true
23:13:37 <etate> as in from IO [String] to just [String]
23:14:05 <Tobsan> @src foldr1
23:14:05 <lambdabot> foldr1 _ [x]    = x
23:14:05 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
23:14:05 <lambdabot> foldr1 _ []     = undefined
23:14:34 <kmc> etate, you can't
23:14:50 <kmc> you can apply that [String] to either a pure function or another IO action, and get the result again in the IO monad
23:15:04 <etate> kmc: you can't ever get it out of the IO monad?
23:15:14 <kmc> the most beginner-friendly way to do either is with the "do" notation
23:15:25 <etate> kmc: yeah thats what i want to get out of
23:15:52 <lpsmith> etate:   a better question is,  what do you want do do with the [String] once it's "out" of IO land?
23:16:04 <kmc> etate, there are seriously terrible ways to do it.  unless you're doing something very specific and advanced, it's not advised.
23:16:32 <kmc> the general idea is: write the computational core of your program as pure functions; write the user-facing shell in IO code, make pure calls from IO but don't try to "extract" values
23:16:34 <etate> kmc: by terrible what do you mean?
23:16:41 <kmc> semantically ill-defined
23:17:21 <etate> kmc: i see, but then anytime you use IO, everything you do is tagged with "this is and IO operation"
23:17:27 <kmc> yes
23:17:37 <kmc> it has to be, because pure values are referentially transparent
23:17:56 <kmc> one (f 3) is always the same as another (f 3) and has no side effects
23:18:11 <etate> kmc: but what if you don't care about IO and just want the value contained within, which is a list of String
23:18:14 <kmc> that's true even if f returns an IO type -- it's just that "the same" there means "performs the same side-effect, later"
23:18:23 <lpsmith> etate:  for example,   do you want to find the length of each string?
23:18:26 <kmc> etate, then you want to feed that [String] into another pure function
23:18:30 <kmc> but your result will still be in IO
23:18:44 <etate> kmc: but why does the result have to be in IO? that is what is confusing me :)
23:19:01 <kmc> etate, because the result can depend on the outside world
23:19:13 <etate> lpsmith: i can use pure functions in the do notation, its just not as nice as being in pure land
23:19:15 <FunctorSalad_> put differently, you can "temporarily" extract the value if you put it back into IO at the end. That's what (>>=) does.
23:19:17 <ddarius> IO String doesn't necessarily have a String "inside it" anymore than [String] necessarily does.
23:19:24 <ivanm> Does anyone know what haskell-src-exts means by "a recursive binding group for arrows"?
23:19:39 <ivanm> ddarius: when won't it? when it throws an error?
23:19:50 <ddarius> ivanm: Yes.
23:19:55 <ivanm> *nod*
23:20:00 <lpsmith> etate:   right,  it's not quite as bad as you think though
23:21:02 <etate> lpsmith: i'm just surprised, my intuition wanted to make me believe that there was a way out of IO :)
23:21:26 <lpsmith> etate:  there are ways "out of" most other monads, but not IO
23:21:56 <kmc> etate, once a value depends on the outside world, nothing derived from it can not-depend on the outside world
23:22:35 <lpsmith> But say you want to find the length of some IO [String]s
23:22:49 <etate> kmc: hmm, but once you have a set of strings from a file, why should that depend on IO anymore... I can understand that the read operation should depend on IO ...
23:23:18 <lpsmith> then you could write ioLengths m = do { xs <- m;  return (map length xs) }
23:23:33 <lpsmith> and ioLengths :: IO [String] -> IO [Int]
23:23:39 <dobblego> s/map //
23:23:48 <dobblego> oh wait, sorry
23:24:02 <lpsmith> dobblego:  np :-)
23:24:07 <ddarius> (Total) functions M a -> a for a monad M are extremely rare.
23:24:18 <FunctorSalad_> etate: if you have an value of type "IO [String]", you don't have a set of strings, you have a way to get a set of strings from the real world
23:24:34 <lpsmith> ddarius:  true enough
23:24:34 <kmc> yes, it's best to think of IO values as "plans" for getting data
23:24:37 <kmc> rather than the data themselves
23:25:02 <kmc> a plan that involves some IO and some pure computation is still a plan requiring IO
23:25:12 <lpsmith> etate:  but this simple example is probably not what you actually what you want to do
23:25:45 <etate> lpsmith: well no i just wanted to take some words and count them up pretty much, but its useful to know all of this stuff :)
23:26:04 <lpsmith> etate:  Instead of staying inside the IO monad to do everything,   do most of what you want in pure-haskell-land instead and come back only when you must
23:26:27 <lpsmith> etate:  not a bad exercise to start with :)
23:26:41 <kmc> etate, a good rule is: write the core of your program as a pure function you can run from ghci
23:26:47 <kmc> once that's done, write the IO shell
23:27:26 <kmc> the result within that shell is in the IO monad -- that's fine, because you probably want to print it out
23:27:40 <FunctorSalad_> ddarius: hmm, is there anything you can deduce from existence of such a function in general?
23:27:45 <etate> kmc, lpsmith: awesome, i will give that a try, thanks a lot for your help. :) now i must go to work. :D
23:27:51 <kmc> (as a side note, if you're using IO *only* for the mutable variables and not for input/output, consider ST instead)
23:28:04 <FunctorSalad_> (like some property of "extract . return" or "return . extract|)
23:28:12 <ddarius> FunctorSalad_: You immediately know that M is not a MonadPlus (or more specifically a MonadZero)
23:28:52 <FunctorSalad_> ah good point, set a = Void
23:29:12 <lpsmith> ddarius:   out of curiousity,  how did you learn category theory?   I've tried,  and I get little bits and pieces of it here and there,  but I've mostly failed at understanding it.  :-)
23:30:57 <ddarius> lpsmith: I read lots (for the most part).  I read many other mathematical things and CS things not directly related to CT as well.
23:32:42 <lpsmith> Well, I'll admit that the product/coproduct definitions "clicked" for me recently in a way that hasn't happened before,  so maybe it's time to try again.
23:33:24 <ddarius> lpsmith: I would recommend to just attack and retreat repeatedly (and during the "retreat" periods learn about other things such as topology and abstract algebra.)
23:33:29 <lpsmith> Before that,  it was much like my initial experiences with continuations, I could do them but it took an immense amount of thought.
23:33:55 <lpsmith> Heh, I'm pretty good with abstract,  I suck at topology
23:34:15 <lpsmith> I need to work on the topological proof of the infinitude of primes, though :-)
23:34:16 <ddarius> lpsmith: I read "Toposes, Triples, and Theories" several times.  The first time was almost complete incomprehension.  The middle times was some comprehension but not really seeing a use for the stuff.  And the last times, was because I actually needed/wanted the results in it.
23:34:47 <ddarius> lpsmith: Yeah, I'm more an algebra person than a geometry/topology person.
23:34:56 <lpsmith> Oh,  Charles Wells is a great guy,  I've talked with him on a handful of occasions.  I found TTT pretty dense though
23:35:36 <ddarius> lpsmith: The ELLSSI lecture notes are a pretty good introduction.  It was too late for me, but Awodey's book on CT seems pretty good.
23:36:34 <ddarius> I highly recommend reading "Basic Concepts of Enriched Category Theory" by Kelly but ignore the "enriched" aspect of it.  There are topics covered there in depth that are rarely covered elsewhere such as Kan extensions.
23:38:41 <ddarius> lpsmith: I'd say it took either one or two years (one of those, not between those) for the categorical way of thinking to completely click with me.  That's not constantly spending time on it.
23:38:56 <lpsmith> of course
23:39:20 <ddarius> Of course there are still plenty of things that I couldn't just read and immediately understand.
23:39:44 <lpsmith> FP clicked for me immediately,  although it took about two years before I managed to unlearn and relearn all that I needed before I became a fluent functional programmer
23:40:32 <lpsmith> Category theory, I've been struggling to understand for a long time.   Although sometimes I get frustrated and give up for a spell
23:41:25 <lispy|web> hmm... .prof files are not affected by the options you pass to the RTS
23:41:46 <lispy|web> I used -hmFoo and the .prof file still covers all modules.  This is really unfortunate
23:41:58 <lispy|web> Is there a work around?
23:45:23 <khora> Guys, I tried everything, but I still get cabal: user error (Codec.Compression.Zlib: incompatible version) when I try to run cabal update. Do you have any suggestions?
23:46:54 <ivanm> khora: does "ghc-pkg list" say anything?
23:46:58 <ivanm> I mean "ghc-pkg check"
23:47:09 <Fragsworth> What is the purpose of type defining?
23:47:19 <ivanm> Fragsworth: you mean adding explicit type signatures?
23:47:21 <khora> ivanm: no otput
23:47:33 <ivanm> khora: OK, what does "ghc-pkg list zlib" say?
23:47:36 <Fragsworth> ivanm: I think so. I'm reading a tutorial, and they're defining them with the "::" operator
23:48:01 <ivanm> Fragsworth: right... whilst in general GHC/ghci can infer them, there are two reasons for adding them explicitly:
23:48:11 <khora> ivanm: zlib-0.5.2.0
23:48:17 <ivanm> 1) sometimes they can't be inferred properly (too vague, etc.) or you need to state explicit types
23:48:26 <ivanm> 2) the more important reason: documentation
23:48:36 <kmc> machine-checkable documentation@
23:48:37 <kmc> !
23:48:38 <ivanm> that way, people reading your code can see what types it needs
23:48:46 <Fragsworth> ivanm: Ahh. Ok great, thanks for clarifying that.
23:48:54 <ivanm> also, haddock will only add documentation for functions with explicit type signatures
23:48:58 <ddarius> lpsmith: If you want, I can email you a draft of an article I wrote.  It contains a lot of handy results, but the emphasis is mostly on proving them, the style of proof, and the tools used.
23:49:09 <ivanm> because unless you run GHC on the code or something first, there's no way of telling what the type signature is
23:49:20 <ivanm> khora: OK, how did you install cabal-install?
23:49:21 <lpsmith> ddarius:  sure :-)
23:49:43 <khora> ivanm: ./bootsrap.sh
23:49:43 <ivanm> @seen dcoutts
23:49:44 <lambdabot> Unknown command, try @list
23:49:48 <ivanm> gah
23:49:50 <ivanm> preflex_: seen dcoutts
23:49:50 <preflex_>  dcoutts was last seen on #haskell 4 hours, 23 minutes and 46 seconds ago, saying: :-)
23:49:54 <ivanm> preflex_: seen dcoutts_
23:49:54 <preflex_>  dcoutts_ was last seen on #haskell 11 days, 16 hours, 40 minutes and 15 seconds ago, saying: it separates the hard working values from the slakker types
23:50:32 <ddarius> lpsmith: I assume the email you use for Haskell-Cafe is good.
23:50:33 <ivanm> khora: did you upgrade the version of zlib at all since installing cabal-install?
23:51:08 <ddarius> lpsmith: Also, PS or PDF?
23:51:15 <khora> ivanm: yes, I had macports installed. But I removed it since.
23:51:36 <ivanm> khora: ummmm.... that sounds bad...
23:51:45 <lpsmith> I haven't been on Haskell-Cafe for years,  mostly because of the volume of email is large and finding an IMAP solution with adequate server-side filtering is a pain
23:51:52 <ivanm> though realistically, it shouldn't matter since GHC binaries are still statically linked...
23:52:00 <khora> ivanm: should I uninstall everything?
23:52:10 <Makoryu> ivanm: FOR NOW!
23:52:35 <Makoryu> khora: Don't even bother with macports. Go directly to the Haskell Platform.
23:52:52 <lpsmith> Oh, and as PDF, although it doesn't make me too much difference
23:53:28 <ivanm> khora: try running bootstrap.sh again maybe... *shrug*
23:53:43 <ivanm> lpsmith: why not get digests?
23:53:57 <ivanm> and what do you want with server-side filtering?
23:54:29 <khora> ivanm: tried, didn't work
23:54:56 <lpsmith> ivanm:  I find digests obnoxious,  and I want to move messages from Haskell-Cafe into a seperate IMAP folder based on the proper header
23:55:10 <ivanm> lpsmith: gmail can do that
23:55:16 <lpsmith> ivanm:  no it can't
23:55:21 <ivanm> yes it can...
23:55:24 <ivanm> that's how I'm doing it
23:55:46 <lpsmith> based on the mailing-list header, or whatever?
23:55:56 <ivanm> Matches: list:"haskell-cafe.haskell.org"
23:56:01 <ivanm> ^^ what I use
23:56:03 <lpsmith> hmm
23:56:10 <ivanm> lpsmith: it came out a few months ago
23:56:19 <lpsmith> ahh
23:56:26 <ivanm> most cases, when you open an email it has an option up the top to filter out messages from that list
23:56:27 <lpsmith> that might be why I thought about doing it
23:56:28 <khora> god... there is haskell platform
23:56:35 <khora> I didn't know :(
23:56:42 <ivanm> khora: it's relatively new
23:56:49 <lpsmith> Err, that's why I thought it wasn't possible
23:56:53 <ivanm> lpsmith: heh
23:57:21 <ivanm> lpsmith: the other alternative if you really want is to subscribe to -cafe without getting any emails, and then use a newsreader to get the actual "articles'
23:57:24 <ivanm> s/'/"/
23:57:55 <lpsmith> I sent complaints about server-side filtering into the black hole of the suggestion box a few times,  I know that much
23:58:02 <ivanm> heh
23:58:22 <ivanm> but even still, they've had manual filtering (matching the address, etc.) for a lot longer...
