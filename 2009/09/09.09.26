00:00:47 <ivanm> noooo!!! come back hackagebot!!!
00:00:57 <ivanm> how else will we know when a new package appears on hackage? :p
00:01:20 <dm`> back by request I guess
00:04:10 <ivanm> \o/
00:05:58 <dm`> How can I get an overlapping instances error and a no instances error message at the same time, on the same instance declaration?
00:06:56 <Axman6> magic
00:07:00 <copumpkin> i think ur doin it rong
00:07:02 <Axman6> dark, nasty magic
00:07:14 <dm`> I think the compiler is being unfair to me.
00:07:31 <dm`> If there's no way to satisfy my instance constraint, then how can that instance overlap with another?
00:18:10 <ummmmd> building ghc6.10.4 on openbsd fails at haskeline. suggestions?
00:18:52 <ivanm> weird...
00:18:56 <ivanm> what's the exact error?
00:19:44 <ummmmd> Configuring ghc-bin-6.10.4...
00:19:44 <ummmmd> cabal-bin: At least the following dependencies are missing:
00:19:47 <ummmmd> haskeline -any
00:21:46 <abbe> ummmmd: http://www.haskell.org/pipermail/freebsd-haskell/2009-July/000093.html : we generated a bootstrap tarball for freebsd, messages from archives might help.
00:22:02 <ivanm> I thought GHC came with haskeline...
00:22:43 <ummmmd> idk
00:25:36 <ummmmd> ivanm: thanks for the lead
00:26:40 <ivanm> ummmm, abbe gave you the link, not me...
00:27:26 <ummmmd> oops. thanks abbe!!
00:28:19 <abbe> ummmmd: check out the Makefile of ghc683.shar
00:29:26 <abbe> ummmmd: the makefile is only tested with amd64 architecture, someone has already built for i386, so i've not modified i386 sections.
00:30:51 <ummmmd> ok. i'm on amd64
00:52:13 <sohum> :t takeWhile
00:52:13 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:56:01 <sohum> :t fractional
00:56:01 <lambdabot> Not in scope: `fractional'
00:56:07 <sohum> @instances Fractional
00:56:08 <lambdabot> Double, Float
00:57:25 <sohum> hm. what's the unbounded fractional type?
00:58:12 <en0th> rational?
00:59:16 <ivanm> that's the closest you can get
00:59:23 <ivanm> without using FewDigits or something
01:00:33 <sohum> what's FewDigits?
01:00:49 <ivanm> it was roconnor's implementation of calculable reals
01:00:57 <ivanm> IIRC, it's called CNum or something on hackage
01:01:35 <ivanm> @hoogle CReal
01:01:35 <lambdabot> No results found
01:01:37 <ivanm> @hoogle CNum
01:01:37 <lambdabot> No results found
01:02:03 <ivanm> @hackage numbers
01:02:03 <lambdabot> http://hackage.haskell.org/package/numbers
01:02:06 <ivanm> ^^ tha's the one
01:02:11 <ski> > pi :: CReal
01:02:11 <lambdabot>   3.1415926535897932384626433832795028841972
01:02:14 <sohum> cool
01:02:17 <sohum> thanks
01:02:29 <ivanm> I take it back, it's lennart's
01:02:30 <ski> > sin pi :: CReal
01:02:31 <lambdabot>   0.0
01:02:37 * ivanm thought it used roconnor's implementation
01:02:55 <ivanm> or not, it's based on David Lester's code ;-)
01:04:01 <lorph> @hackage
01:04:01 <lambdabot> http://hackage.haskell.org
01:07:58 <en0th> list comprehension is syntactic sugar, but the syntax doesn't seem so consistent..
01:09:06 <ivanm> in what way?
01:09:36 <en0th> [x+1 | x <- [1..10]]
01:10:04 <en0th> the pipe and back arrow.. why ?
01:10:10 <dancor> it's from math
01:10:14 <dancor> like everything in haskell
01:10:26 <ivanm> en0th: it looks like set notation
01:10:29 <en0th> yes, but pipe is already in guards!
01:10:34 <ivanm> s/notation/comprehension notation/
01:10:38 <ivanm> en0th: so?
01:10:54 <ivanm> en0th: -> is used for type sigs and for case statements
01:11:02 <ivanm> where is used for sub-definitions and for case statements
01:11:08 <dancor> it's also in ||
01:11:13 <ivanm> = is used for function definitions and for guards
01:11:23 <dancor> @let a |||||||||| b = 4
01:11:24 <lambdabot>  Defined.
01:11:33 <ivanm> <- is used in comprehensions and do-notation
01:11:44 <ivanm> > undefined |||||||||| undefined
01:11:45 <lambdabot>   4
01:11:51 <ivanm> yay for laziness!
01:12:04 <ivanm> en0th: ( and ) are used for grouping, tuples and unit
01:12:10 <ivanm> oh, and to turn infix into prefix
01:12:12 <en0th> that's a lot to remember
01:12:16 <ivanm> not really
01:12:19 <dancor> don't forget .
01:12:27 <en0th> hehe also the dot yes
01:12:27 <ivanm> we only allow one type of strings (OK, two... explicit lists of chars)
01:12:34 <ivanm> dancor: what else is it used for?
01:12:40 * ivanm can only think of (.) atm
01:12:48 <dancor> qualifying
01:12:51 <paolino> forall a .
01:12:54 <dancor> Set.Set
01:12:59 <dancor> :t Set.Set
01:13:00 <lambdabot> Couldn't find qualified module.
01:13:01 <ivanm> ahhh
01:13:03 <dancor> :t Data.Set.Set
01:13:03 <lambdabot> Not in scope: data constructor `Data.Set.Set'
01:13:05 <ivanm> dancor: that's an extension :p
01:13:08 <dancor> :t Prelude..
01:13:09 <lambdabot> parse error on input `Prelude..'
01:13:14 <ivanm> s/dancor/paolino/
01:13:22 <ivanm> :t Prelude.(.)
01:13:23 <lambdabot> Not in scope: data constructor `Prelude'
01:13:27 <ivanm> grrr....
01:13:53 <dancor> :t Data.Function.(.)
01:13:53 <ivanm> en0th: the problem is, there aren't enough keys on the keyboard to let every single little thing have it's own independent notation
01:13:54 <lambdabot> Couldn't find qualified module.
01:14:08 <ivanm> I demand that all letters automatically indicate Strings!
01:14:11 <Jafet> @hoogle Set
01:14:11 <lambdabot> module Data.Set
01:14:11 <lambdabot> Data.Set data Set a
01:14:11 <lambdabot> Network.Browser setAllowBasicAuth :: Bool -> BrowserAction t ()
01:14:13 <en0th> yes, that's right
01:14:16 <Jafet> Lols
01:14:17 <ivanm> we thus need other symbols for variables, etc.!
01:14:46 <en0th> but for a functional novice like me it's a big obstacle
01:14:49 <Jafet> Your father's APL keyboard. For a more enlightened age.
01:15:25 <en0th> i wrote (\x -> x+1) [1..10] at first glance
01:15:27 <paolino> long life to Typeable , typeclasses and their effects on existentials !
01:15:34 <en0th> omg
01:15:46 <en0th> map (\x -> x+1) [1..10]
01:16:19 <Jafet> > map (+1) [1..10]
01:16:20 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
01:16:33 <en0th> is list comprehension preferred to this?
01:16:45 <paolino> (I forgot fundeps, actually :) )
01:21:15 <ummmmd> got past haskeline. thanks ivanm / abbe.
01:22:16 <ummmmd> new error... haddock: out of memory (requested 1048576 bytes)
01:23:34 <paolino> en0th: I think list comprehension is mostly used when there is more then a simple map
01:24:05 <en0th> so they haven't the same expression power?
01:24:23 <paolino> sure they have
01:25:12 <en0th> so, i think i'll have to get used to both.. :(
01:25:23 <paolino> list comp are translated in do notation in the list monad and in the end in \f -> concat . map f
01:26:11 <en0th> (omg list monad)
01:27:04 <paolino> > [x*y | x <- [2..5], y <- [1..x]]
01:27:05 <lambdabot>   [2,4,3,6,9,4,8,12,16,5,10,15,20,25]
01:27:50 <ski> > let f c x | Just y <- lookup c [('a',3),('b',7)], x < y = y | otherwise = 23 in zipWith f "aabb" [2,3,4,5]
01:27:51 <lambdabot>   [3,23,7,7]
01:28:21 <ski> (^ `<-' in a guard)
01:29:40 <ivanm> ski: is that an extension?
01:29:49 <ivanm> (to have the Just y <- ... in a guard)
01:30:10 <ski> PatternGuards, iirc
01:30:33 <ivanm> duh, I think I was just asking about that the other day...
01:30:48 <ivanm> one thing I can say for haskell-src-exts... using it makes you more aware of the different extensions :s
01:31:01 <paolino> en0th: I use the [] Monad instance more often than list comprehension, but ymmv
01:31:47 <en0th> how would you write that example with [] Monad??
01:32:23 <ski> > do x <- [2..5], y <- [1..x]; return (x*y)
01:32:24 <lambdabot>   <no location info>:
01:32:24 <lambdabot>      The last statement in a 'do' construct must be an ...
01:32:31 <ski> > do x <- [2..5]; y <- [1..x]; return (x*y)  -- er
01:32:31 <lambdabot>   [2,4,3,6,9,4,8,12,16,5,10,15,20,25]
01:32:45 <FunctorSalad> without curly braces?
01:32:47 <paolino> > [2..5] >>= \x -> [1..x] >>= return . (*x)
01:32:47 <lambdabot>   [2,4,3,6,9,4,8,12,16,5,10,15,20,25]
01:32:58 <ski> FunctorSalad : that was without
01:33:18 <FunctorSalad> I thought you either had to use layout or curly braces :)
01:33:20 <en0th> mmm..
01:33:41 <ski> FunctorSalad : you can use `;' without `{',`}'
01:34:27 <ski> (and iirc, in a block, you can use indentation in some places, and `;' in other places)
01:34:31 <en0th> 'this is no fun'
01:34:50 <ski> (what isn't ?)
01:34:58 <paolino> it is fun-ctional  :P
01:35:06 <en0th> ;(
01:35:44 <en0th> monad things in general i guess
01:36:48 <en0th> monad binds .. blabla .. yes, whatever. I studied physics and math, but i still don't get it yet
01:37:03 <paolino> it takes some time to get used to it all, someone understands it before using it , but others like me, just become confident before understanding it
01:37:57 <FunctorSalad> en0th: maybe you could look at math examples of monads then
01:38:18 <ski> like the powerset-monad
01:38:42 <en0th> mm i should try!
01:38:43 <FunctorSalad> or free stuff (free groups, vector spaces, ..)
01:39:11 <ski>   `return x' is the singleton subset `{x}'
01:39:48 <ski>   `s >>= f' is the subset `{y | x <- s , y <- f x}'
01:40:12 <ski> (where that `<-' is the "elementhood" relation)
01:46:56 <en0th> they often explain monads with Maybe
01:47:49 <en0th> what i don't understand is why Maybe has to be a monad, shouldn't it be a simple type?
01:48:04 <Beelsebob> it is a simple type
01:48:06 <FunctorSalad> @kind Maybe
01:48:07 <lambdabot> * -> *
01:48:14 <FunctorSalad> it's a type constructor
01:48:29 <Beelsebob> I'm not sure he was using the same definition of simple type as you
01:48:36 <paolino> @src Maybe
01:48:36 <lambdabot> data Maybe a = Nothing | Just a
01:48:54 <pheaver> so I'm playing around with homebrew (experimental Mac OS X package manager) and its default CFLAGS are "-O3 -march=nocona -mfpmath=sse -mmmx -msse4.1 -w -pipe -fomit-frame-pointer -mmacosx-version-min=10.5".   anyone know if those are safe for compiling GHC?
01:48:58 <en0th> it's like data Color = Red or Blue
01:49:09 <paolino> no
01:49:29 <paolino> Color has no parameters
01:49:31 <Beelsebob> en0th: no, Maybe can store an extra value
01:49:33 <Beelsebob> it's values are not Red
01:49:35 <Beelsebob> or Blue
01:49:40 <Beelsebob> it's values are Nothing (similar to Red)
01:49:50 <Beelsebob> or Just someOtherValue
01:49:52 <en0th> oh it's polymorphic
01:49:53 <Beelsebob> including Just 1
01:49:55 <Beelsebob> Just 10
01:49:57 <Beelsebob> Just "a"
01:50:00 <Beelsebob> Just (Just 5)
01:50:02 <Beelsebob> etc
01:50:21 <Beelsebob> a Maybe value is a value that "maybe" exists
01:50:37 <carotene> Hi, anybody tried GHC 6.10.4 on Solaris 10 Sparc with GCC 4.4.1?
01:50:51 <pheaver> should i ask my CFLAGS question in #ghc?
01:51:07 <Beelsebob> carotene: I have it running on OpenSolaris, but boy was it a pain to get there
01:51:28 <paolino> en0th: Maybe is a tag type, you put it around another one
01:51:42 <carotene> Beelsebob: I got it working, too, after modifying the TailCalls.h header...
01:51:55 <Beelsebob> en0th: all Functors, Applicatives and Monads store another value somehow
01:51:59 <paolino> en0th: that is why it can be a monad
01:52:01 <carotene> Beelsebob: I'm not sure if this is the right way, though.
01:52:15 <Beelsebob> carotene: I certainly didn't have to do that
01:52:33 <paolino> @src Monad
01:52:33 <lambdabot> class  Monad m  where
01:52:33 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
01:52:33 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
01:52:33 <lambdabot>     return      :: a -> m a
01:52:33 <lambdabot>     fail        :: String -> m a
01:53:00 <paolino> see that m "stores" a
01:53:03 <carotene> Beelsebob: Did you use GCC 4.4.1?
01:53:03 <en0th> omg monad is a class, now that's what i didn't get
01:53:21 <Beelsebob> carotene: sec
01:53:37 <Beelsebob> en0th: Monad's also not the first one you should look at
01:53:43 <Beelsebob> it's the top of the chain
01:53:48 <Beelsebob> look at Functor first
01:53:54 <en0th> ok
01:53:59 <carotene> Beelsebob: It seems at least this version of GCC compiles tail calls to an illegal instruction "ta 5", which is a software interrupt on SPARC, as far as I know...
01:54:13 <Beelsebob> oh, interesting
01:54:31 <Beelsebob> carotene: ah yeh, my gcc is rather older than yours
01:54:34 <carotene> Beelsebob: Not all the tail calls, just some of them.
01:54:51 <Beelsebob> en0th: (blowing my own trumpet) http://noordering.wordpress.com/
01:55:01 <Beelsebob> oops, didn't pull teh article out
01:55:04 <carotene> Beelsebob: I tried GCC 3.4.x and it had no this problem.
01:55:19 <Beelsebob> en0th: this... http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
01:55:31 <Beelsebob> carotene: yeh, 3.4.3 was what worked for me
01:56:59 <en0th> Beelsebob: this could really make my day
01:57:04 <carotene> Beelsebob: I used the 6.10.4 binary downloaded from the official site. With GCC 3.4.3, although I can configure&make install, ghc complains about unaligned symbol reference when linking.
01:57:32 <Beelsebob> carotene: there's a binary available for Sol?
01:57:33 <Beelsebob> o.O
01:57:36 <Beelsebob> wasn't when I did it
01:57:40 <Beelsebob> I had to grab 6.6
01:57:45 <carotene> Beelsebob: I guess the builder of the binary used GCC 4.2 or something like that.
01:57:46 <Beelsebob> then compile 6.10 for myself
01:58:06 <carotene> Beelsebob: Yes, here http://www.haskell.org/ghc/download_ghc_6_10_4.html :-)
01:58:20 <Beelsebob> random, must be more recent than me installing it
01:58:48 <en0th> i'm planning to implement a (subset) of a language like haskell for a thesys.. i must master it before
01:59:31 <ski> (en0th : nitpick .. `Maybe' is parametric, not polymorphic)
01:59:38 <carotene> Beelsebob: This binary works fine after the header modification.
01:59:56 <Beelsebob> :)
02:00:13 <Beelsebob> oh well, when I need a newer ghc on my OpenSol box I'll try it
02:00:38 <carotene> Beelsebob: It's good to know some people still care about GHC on SPARC+Solaris...:-(
02:00:59 <Beelsebob> carotene: I don't think it'll be moving any time soon...
02:01:00 <en0th> parametric, right. I'm hating OOP more and more
02:01:11 <Beelsebob> think of the number of unis with staff servers running on that combo
02:01:24 <Beelsebob> and the number of unis with staff wanting to run their haskell code
02:02:46 <carotene> Beelsebob: Well, yes. It's said that SPARC servers are popular in financial industry. Haskell should be appealing to them.
02:03:26 <Beelsebob> carotene: having talked recently with people using functional programming in the financial industry, they don't see a lazy language as being suitable for them at all
02:03:32 <Beelsebob> too unpredictable space/time behavior
02:04:17 <p_l> carotene: SPARCs are quite popular for heavy iron, methink
02:05:24 <p_l> Beelsebob: maybe it depends on exact job (and how good programmers they get)
02:06:03 <Beelsebob> p_l: true
02:07:49 <carotene> p_l: Maybe it's hard to get relly good Haskell programmers...it seems to me the really "good" ones are mostly researchers who don't need an industry job.
02:07:57 <lpsmith> I'm reading the first scrap your boilerplate paper:  http://www.cs.vu.nl/boilerplate/tldi03.pdf
02:08:32 <Jafet> Lazy languages can have strict performance characteristics
02:08:49 <Jafet> But hs98 doesn't really specify those, I expect
02:08:55 <lpsmith> I'm not understanding the definition of gmapQ  in the instance Term a => Term [a]  on page 4
02:09:06 <p_l> carotene: there's also question of the hi-speed side of financial software - Haskell would do just fine in the non-realtime area
02:09:52 <lpsmith> Jafet:  Concurrent Clean had a much more defined runtime semantics
02:10:08 <lpsmith> err, has.   If you want to mess around with Clean,  it's no longer Concurrent.
02:11:26 <vegai> carotene: where I work, perhaps 50% of the servers are sparcs
02:11:29 <carotene> p_l: Sometimes I wonder if it's possible to make something like a monad transformer which when work on other monads can transparently compute the computational complexity of the underlying monad actions.
02:11:33 <Jafet> I think lazy evaluation is the only real way for large systems to work
02:11:54 <carotene> vegai: Actually, in my job 99% servers are SPARC...
02:11:54 <vegai> carotene: and (unless oracle now decides to screw things up), the amount of sparcs shouldn't be going down
02:11:57 <Jafet> carotene, that is nondecidable in general
02:12:54 <Jafet> Monads can't have well-defined complexity either, consider IO
02:13:02 <carotene> vegai: I hope Oracle can really add more investment to SPARC, like they recently announced.
02:13:26 <carotene> Jafet: Yes, but if we restrict the actions we can accept to a subset...
02:14:03 <p_l> vegai: I somehow suspect Oracle will screw things up, though
02:14:18 <carotene> Jafet: I mean the big-O complexity, assuming one IO () action is just O(1).
02:14:40 <Jafet> That probably won't be a useful subset, since it is infeasible or impossible to automatically deduce the complexity of many interesting constructs
02:16:33 <carotene> Jafet: If we don't allow structures like for/while loops...only map/fold.
02:24:43 <jrockway> anyone using PArrows?
02:24:55 <jrockway> i am wondering if there's a good way to match all characters except for 1 (or a few)
02:25:10 <jrockway> currently i have something like "foldl1 (<+>) $ char <$> (filter f $ chr <$> [0..255])"
02:31:06 <maltem> Argh
02:31:13 <maltem> I was going to simplify my type signatures
02:31:21 <maltem> and what did I end up with?
02:31:26 <maltem> UndecidableInstances :(
02:31:29 <en0th> lol
02:31:31 <ivanm> yay!
02:31:32 <ivanm> ;-)
02:32:20 <maltem> That's what I have always abhored thoroughly!
02:32:36 <maltem> But it looks so much nicer now :)
02:33:18 <en0th> could a thing like this.. eventually.. work?
02:33:20 <en0th> nfmap 0 = fmap
02:33:21 <en0th> nfmap n = (fmap.) (nfmap (n-1))
02:33:57 <dolio> en0th: http://code.haskell.org/~dolio/agda-share/html/Nest.html
02:34:45 <maltem> :t let nfmap 0 = fmap; fnmap n = fmap . nfmap (n-1) in nfmap
02:34:45 <lambdabot> forall t a b (f :: * -> *). (Functor f, Num t) => t -> (a -> b) -> f a -> f b
02:35:19 <dolio> I suspect he missed a dot.
02:35:50 <maltem> uh, why (a -> b) rather than (a -> a)?
02:36:06 <dolio> Anyhow, if g : a -> f a, and x : a, then nest 0 g x : a, nest 1 g x : f a, nest 2 g x : f (f a), etc.
02:36:33 <maltem> :t let nfmap 0 = fmap; fnmap n = (fmap .) . nfmap (n-1) in nfmap
02:36:34 <lambdabot> forall t a b (f :: * -> *). (Functor f, Num t) => t -> (a -> b) -> f a -> f b
02:40:29 <maltem> :t \n f x -> iterate (fmap f) x !! n
02:40:30 <lambdabot> forall b (f :: * -> *). (Functor f) => Int -> (b -> b) -> f b -> f b
02:42:59 <dolio> maltem: You have a typo.
02:43:12 <dolio> maltem: The second case is called fnmap.
02:43:34 <dolio> And he didn't miss a dot, as it turns out.
02:50:52 <maltem> :t let nfmap 0 = fmap; nfmap n = fmap . nfmap (n-1) in nfmap
02:50:53 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
02:50:53 <lambdabot>       Expected type: (a -> b) -> f a -> f b
02:50:53 <lambdabot>       Inferred type: (a -> b) -> f (f a) -> f (f b)
02:51:00 <maltem> aha :)
02:51:22 <maltem> I was quite wondering
02:55:05 <ivanm> hmmm.... what secret mind rays has ndm built into hlint? I find that it offers less "suggestions" nowadays than when I started... >_>
03:14:14 <Phyx-> hello, anyone know a TH code that can take for instance data Foo =  Bar | Bar2 Int and give me "foo_bar, foo_bar2" as a result?
03:25:17 <Phyx-> hmm this must be an off-hour... or everyone's on a smoking break
03:25:29 * ivanm has never touched TH, and is scared to do so
03:26:54 <maltem> So am I ;)
03:27:34 <Phyx-> ivanm: lol
03:27:50 <Phyx-> i just don't wanna type that out for the 138 constructors this datatype has
03:27:51 <Phyx-> :|
03:28:05 <Phyx-> :t datatypeOf
03:28:06 <lambdabot> Not in scope: `datatypeOf'
03:28:09 <Phyx-> :t dataTypeOf
03:28:10 <lambdabot> forall a. (Data a) => a -> DataType
03:28:20 <Phyx-> :t dataTypeOf Lexer.Token
03:28:20 <lambdabot> Couldn't find qualified module.
03:28:28 <Phyx-> :t dataTypeOf Token
03:28:29 <lambdabot> Not in scope: data constructor `Token'
03:28:41 <Phyx-> hrm.. apparently... GHC is hidden
03:28:41 <mauke> > dataTypeOf ()
03:28:42 <lambdabot>   DataType {tycon = "Prelude.()", datarep = AlgRep [()]}
03:28:47 <ski> > fix dataTypeOf
03:28:48 <lambdabot>   DataType {tycon = "Data.Generics.Basics.DataType", datarep = NoRep}
03:28:52 <Phyx-> :t dataTypeOf GHC.Token
03:28:52 <lambdabot> Couldn't find qualified module.
03:29:16 <ski> > id `join` dataTypeOf
03:29:17 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a)
03:29:31 <ski> > dataTypeOf dataTypeOf
03:29:31 <lambdabot>   Ambiguous type variable `a' in the constraint:
03:29:32 <lambdabot>    `Data.Data.Data a'
03:29:32 <lambdabot>      a...
03:29:56 <Phyx-> :t dataTypeOf Expr
03:29:57 <lambdabot> Not in scope: data constructor `Expr'
03:30:01 <mauke> > dataTypeOf (\x@() -> dataTypeOf x)
03:30:02 <lambdabot>   DataType {tycon = "Prelude.(->)", datarep = NoRep}
03:30:03 <Phyx-> oh
03:30:05 <Phyx-> ofcourse
03:30:08 <ski> > dataTypeOf (dataTypeOf :: () -> DataType)
03:30:09 <lambdabot>   DataType {tycon = "Prelude.(->)", datarep = NoRep}
03:30:13 <Phyx-> :t dataTypeOf (undefined :: Lexer.Token)
03:30:14 <lambdabot> Couldn't find qualified module.
03:30:24 <Phyx-> :t dataTypeOf (undefined :: GHC.Token)
03:30:24 <lambdabot> Couldn't find qualified module.
03:30:29 <Phyx-> *sigh*
03:30:34 <Phyx-> :t dataTypeOf (undefined :: Token)
03:30:34 <lambdabot> Not in scope: type constructor or class `Token'
03:30:37 <Phyx-> *shrug*
03:30:43 <mauke> why don't you do it in ghci?
03:31:23 <Phyx-> good question
03:32:34 <Phyx-> hmmm that won't work either. no instance for Data Token
03:35:06 <Phyx-> someone gave me a TH code here once, which i forgot
03:35:06 <Phyx-> :|
03:36:51 <kw317> Phyx-: there are logs of this channel somewhere
03:36:52 <smorg> anyone here heard of bpython? Its pretty sweet. Do we have anything like that for ghci? (syntax highlighting, tab completeion)
03:37:06 <ivanm> no idea what bpython is
03:37:14 <Phyx-> kw317: yeah, but all the searchable ones, give 404
03:37:23 <Phyx-> or rather, the sites that expose a search box
03:38:12 <smorg> ivanm: Its basically the python interactive shell with highlighting and completion etc. Screenies: http://www.bpython-interpreter.org/screenshots/
03:38:26 <ivanm> ahhh
03:38:31 <jrockway> ghci has tab completion
03:38:39 <ivanm> jrockway: dammit, you beat me to it!
03:38:54 <kw317> the syntax highlighting is quite nice
03:38:54 <ivanm> also, you can use hscolour to give it highliting; not sure how stable it is though
03:39:03 <kw317> smorg: maybe you should write one ;-)
03:39:05 <ivanm> IIRC, I had problems with it when I tried it a while back
03:39:15 <jrockway> how much syntax highlighting do you need for one-liners?
03:39:16 <ivanm> also, I think WinHaskell has highlighting
03:39:22 * Phyx- just types this out
03:39:39 <jrockway> (emacs + ghci is what you should use for anything longer than one line)
03:39:42 <fxr`> smorg: isn't it an interface? we have haskell-mode for emacs
03:39:43 <ivanm> jrockway: I want each letter to be a random psychedelic colour!
03:40:00 <ivanm> jrockway: if only ghci in emacs supported long pieces of text... :(
03:40:14 <smorg> kw317: I might :) this has something like vim omni completion too with a popup of completion terms
03:40:17 <mauke> 30r02a3>n10d>0o?9m68 2>c58o;3l?>o?0r31s?1?2< 6:w3<h12a;=t2? 53a07 ;=g8;r53e4>a95t;0 3?i<>d>7e13ag
03:40:25 <ivanm> mauke: :o
03:40:28 <jrockway> open a file, "C-c C-l", now it's in ghci
03:40:36 <ivanm> that's the ANSI escape codes now in there, isn't it?
03:40:40 <mauke> nope
03:40:42 <smorg> haskell is much more condusive to one-liners than python
03:41:01 <ivanm> jrockway: when I'm testing/using code I've written to deal with long strings, it's annoying to have to put them into the haskell source as variables and then re-load
03:41:18 <ivanm> when I'd prefer to just copy them from wherever and paste them into the *haskell* buffer
03:41:30 <jrockway> and that doesn't work?
03:41:57 <ivanm> not for input > 255 characters
03:43:07 <jrockway> works for me
03:43:27 <ivanm> :o
03:43:33 <ivanm> which haskell-mode/emacs do you have?
03:44:16 <skorpan> works here as well and i can't see why it shouldn't
03:44:36 <skorpan> GNU Emacs 23.1.50.3 (i686-pc-linux-gnu, GTK+ Version 2.16.5) of 2009-08-23
03:44:39 <ivanm> I'm talking about text of at least 600 characters...
03:44:45 <skorpan> i pasted ~800 chars
03:44:47 <jrockway> i tried 999 as the test
03:44:52 <ivanm> skorpan: in one line?
03:44:57 <skorpan> ivanm: yes
03:45:03 <jrockway> length " <C-u 999 X> " ==> 999
03:45:05 <ivanm> hmmmm.... yet I found bugs about it :s
03:45:23 <skorpan> jrockway: that would be 1001
03:45:24 <ivanm> <interactive>:1:254:
03:45:24 <ivanm>     lexical error in string/character literal at character '\EOT'
03:45:25 <skorpan> :)
03:45:26 <ivanm> ^^ what I get
03:45:31 <smorg> It would be REALLY cool to have some kind of interactive multiline function-making environment. Think like a spreadsheet, as soon as you have a valid function, recompute the output and display it in real time
03:45:42 <skorpan> ivanm: maybe it depends on where you copy the text from.. i copied it from an rcirc buffer.
03:45:42 <ivanm> when I tried what jrockway did (with the 2 extra spaces as well)
03:45:57 <jrockway> the spaces were for readability
03:45:59 <jrockway> but that works too
03:45:59 <ivanm> skorpan: I copied it from another buffer
03:46:06 <jrockway> i run my ghci as "cat | ghci"
03:46:09 <mauke> maybe your text actually contains \EOT
03:46:10 <ivanm> which arch?
03:46:12 <jrockway> this is because editline sucks
03:46:15 <ivanm> ahhh, I don't
03:46:17 <DRMacIver> stupid question. I'm looking into binary IO in Haskell and I'm seeing a lot of signatures like hPutBuf :: Handle -> Ptr a -> Int -> IO (). The a type parameter doesn't make a lot of sense to me - there are no constraints on it, so I can't see how it can possibly have binary data read from this pointer.
03:46:18 <ivanm> mauke: nope
03:46:27 <skorpan> i'm running ghci as ghci...
03:46:35 <mauke> DRMacIver: why not?
03:46:46 <ivanm> I have in custom-set variables '(haskell-program-name "ghci -idist/build/autogen")
03:46:49 <mauke> it's like a void * in C
03:46:52 <DRMacIver> mauke: Well given an arbitrary type there's no obvious way to interpret it as binary data to be written.
03:46:54 <skorpan> hey, i get the problem as well.
03:47:04 <mauke> DRMacIver: yes, there is. you just read bytes from the pointer
03:47:08 <DRMacIver> mauke: well yes, but I tend to hold Haskell to a slightly higher standard of type safety than C... :)
03:47:11 <ivanm> skorpan: so you lied when you said it didn't work! :@
03:47:13 <DRMacIver> APparently this was a mistake
03:47:28 <mauke> DRMacIver: ByteStrings are probably a better idea
03:47:35 <mauke> this is a pretty low-level interface
03:47:48 <ivanm> trying to use 999-character long variables also doesn't work
03:48:04 <jrockway> the Ptr type handles ensuring that there is a sane binary representation
03:48:11 <ivanm> IIRC, this is a problem with using comint mode that it buffers the stuff to send to the other app
03:48:15 <jrockway> "The type a will often be an instance of class Foreign.Storable.Storable which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C struct."
03:48:16 <ivanm> and ghci doesn't like that :s
03:48:31 <jrockway> ghci does not know about emacs' buffering
03:48:31 <ivanm> jrockway: you literally use "cat | ghci" ?
03:48:33 <jrockway> why would it?
03:48:42 <jrockway> ivanm: no, it is inside a shell script
03:48:52 <jrockway> "exec cat | ghci"
03:48:53 <ivanm> I'm not saying it's ghci's fault, just that that's what appears to happen
03:49:04 <jrockway> a "type" wrapper for shell scripts :)
03:49:07 <ivanm> jrockway: which version of GHC do you use?
03:49:12 <jrockway> 6.10.something
03:49:19 <jrockway> .4
03:49:27 <ivanm> jrockway: in that case, there's no more editline
03:49:28 <DRMacIver> mauke: ByteString probably doesn't do what I want here, as I want mutable access to the underlying file data.
03:49:30 <ivanm> so you shouldn't need that hack
03:49:35 <jrockway> no
03:49:42 <jrockway> it's 6.8 that used readline
03:49:42 <mrsolo> ... Perhaps these are why pointfree style is sometimes (often?) referred to as pointless style.
03:49:44 <mrsolo>  ..
03:49:44 <mrsolo> :-)
03:49:49 <mauke> DRMacIver: like mmap?
03:49:49 <jrockway> readline worked fine
03:49:52 <jrockway> it's the new one that's broken
03:49:55 <ivanm> jrockway: 6.10.4 uses haskeline, not editline
03:50:06 <jrockway> it's still broken
03:50:11 <mrsolo> some of those pointfree expression is really hard to read
03:50:17 <DRMacIver> mauke: Could use mmap, but couldn't find an mmap implementation for Haskell that exposed the file mutably.
03:50:21 * mauke uses 6.10.2 with readline
03:50:22 <jrockway> i have done a lot of terminal control stuff with haskell, and there are no libraries to do it right
03:50:35 <mauke> DRMacIver: then what do you mean?
03:50:36 <jrockway> so perhaps haskelline implemented a sane binding to the terminal
03:50:40 <jrockway> but i am not holding my breat
03:50:41 <jrockway> h
03:50:44 <skorpan> ivanm: does the bug crash your emacs as well? :P
03:50:53 <DRMacIver> mauke: I mean what I said. I want to mutate the file's contents. :)
03:51:02 <mauke> DRMacIver: so use read and write
03:51:22 <mauke> why does this require direct modification?
03:51:40 <skorpan> speed perhaps
03:52:47 <DRMacIver> Because most of my previous experience with Haskell has been quite high level and I'm writing a port of sdbm to Haskell in order to get a sense of what it's like for low level binary IO.
03:53:08 <DRMacIver> So I need pretty precise control over what goes where.
03:53:28 <jrockway> that does not require mmap
03:53:32 <DRMacIver> I didn't say it idid
03:53:38 <mauke> it doesn't require mutable strings either
03:53:44 <jrockway> it is orthogonal
03:53:52 <DRMacIver> Nor was I proposing it required mutable strings.
03:53:54 <jrockway> you can create arbitrary binary structures in pure haskell
03:54:38 <Phyx-> @hoogle Data a=> a -> Constr
03:54:38 <lambdabot> Data.Data toConstr :: Data a => a -> Constr
03:54:38 <lambdabot> Prelude id :: a -> a
03:54:38 <lambdabot> Data.Function id :: a -> a
03:55:31 <mauke> DRMacIver: then what's the problem?
03:55:39 <DRMacIver> The problem is that I'm getting a lecture I don't need. :)
03:55:49 <mauke> I don't understand your problem description
03:56:11 <jrockway> you were the one complaining about the Ptr type :)
03:56:18 <jrockway> "i thought haskell..."
03:56:23 <jrockway> that is a great way to get a lecture :)
03:56:36 <DRMacIver> jrockway: Yes, but the lecture I've got is almost completely orthogonal to that complaint. :)
03:57:00 * mauke listens to Deep Forest - Computer Machine
03:57:07 <jrockway> then the conversation went in the direction of "how do i use mmap" "why do you need mmap" "for this reason" "you don't need mmap for that reason"
03:57:10 <jrockway> and here we are now
03:57:31 <jrockway> awaiting your next question ;)
03:58:06 <jrockway> anyway, what is the problem with this module: http://hackage.haskell.org/packages/archive/bytestring-mmap/0.2.0/doc/html/System-IO-Posix-MMap-Lazy.html
03:58:11 <DRMacIver> jrockway: I never asked how to use mmap. mauke suggested I use mmap.
03:58:16 <jrockway> i see
03:58:31 <DRMacIver> jrockway: The problem with that module is that it's not only not designed for but actively dangerous when combined with mutating the underlying file.
03:58:34 <mauke> mmap is the only way I know to directly modify a file's contents
03:58:55 <jrockway> in what way?
03:59:19 <Phyx-> @pl map (map toLower.show)
03:59:19 <lambdabot> map (map toLower . show)
03:59:29 <DRMacIver> jrockway: it presents a purportedly immutable view of the file contents. If you modify the underlying file, your alleged immutable data changes underneath you
03:59:43 <jrockway> it does not purport to be immutable
03:59:49 <jrockway> "This operation is unsafe: if the file is written to by any other process on the system, the ByteString contents will change in Haskell. "
03:59:56 <DRMacIver> jrockway: It does in the type system. :)
04:00:35 <mauke> yeah, this is basically readFile, only more evil
04:00:48 <mauke> because data you've already looked at can change as well
04:00:54 <jrockway> that is how mmap works
04:01:00 <jrockway> if you don't want stuff to change, make your own copy
04:01:02 <mauke> that is not how haskell strings work
04:01:04 <DRMacIver> Argh.
04:01:09 <mauke> you can't copy strings in haskell
04:01:23 <jrockway> but you can read a file into a string
04:01:28 <jrockway> and then write it out when you are done
04:01:35 <jrockway> that is how you avoid changes by outside processes
04:01:39 <mauke> yes
04:01:43 <jrockway> yup, it's more expensive
04:01:56 <Phyx-> hrm.. well.. that wasn't so hard... and no TH used, lol. only some SYB
04:02:25 <DRMacIver> Look, I know you guys are trying to be helpful, but it's really not working. Evidently I'm insufficiently explaining what I'm trying to do here.
04:02:45 <jrockway> you want something that is impossible
04:02:58 <jrockway> you want to mutate files directly on disk with a haskell type signature that indicates that
04:03:43 <jrockway> if you move all the bytestring operations into IO, you could have that
04:04:47 <DRMacIver> Um. No. What I want should work fine with the file handle operations in System.IO. I just came here because I was confused about one of the type signatures.
04:05:04 <DRMacIver> (or at least it should)
04:05:07 <mauke> the file handle operations in System.IO don't give you direct access to the file's contents
04:07:42 <DRMacIver> I can read, write and seek. That's enough to work with. :)
04:07:52 <mauke> <DRMacIver> mauke: ByteString probably doesn't do what I want here, as I want mutable access to the underlying file data.
04:07:58 <mauke> then what does that mean?
04:08:34 <trofi> :t mmap
04:08:35 <lambdabot> Not in scope: `mmap'
04:09:44 <DRMacIver> Can we drop this conversation? It isn't being even slightly useful and I'm getting annoyed (a fact which I acknowledge is probably in large part due to my explaining myself badly, but that doesn't change it).
04:10:05 <jrockway> let's laugh about an amusing error message in my current program
04:10:12 <jrockway> '*** Exception: user error (No binding for Symbol "3")'
04:10:29 <jrockway> 2 + 2 works, but 2 + 3 doesn't :)
04:10:35 <jrockway> that is how you know you are awesome
04:10:38 <mauke> wait, it thinks 3 is a variable?
04:10:53 <mauke> how did you do that?
04:11:10 <jrockway> ah, it is my own "programming language"
04:11:19 <ski> obviously you need to bind all numerals to their respective numeric values in a top-level environment
04:11:22 <mauke> huhu, that was obvious
04:11:24 <jrockway> i started writing a parser to test out PArrows, and decided to implement an evaluator also
04:11:33 <jrockway> ski: indeed
04:11:50 <Baughn> jrockway: But you forgot to implement literals?
04:11:51 <jrockway> that is what i did with 2 :)
04:11:52 <ski> then you can have fun with `let 2 = 3 in ...'
04:12:01 <mauke> ah, ok
04:12:04 <jrockway> yeah, you can rebind numbers in dynamic scopes
04:12:16 <ski> not lexical, then ?
04:12:16 <mauke> what a "great" idea!
04:12:24 <jrockway> no
04:12:24 * Baughn would like to see an IOArray-ish version of mmap
04:12:40 <jrockway> i would do it if it were a real lanugage
04:12:45 <Baughn> ..mutable bytestrings sound like a great idea
04:12:50 <ski> > let !2 = 3 in ()
04:12:51 <lambdabot>   * Exception: <interactive>:1:145-150: Non-exhaustive patterns in pattern bi...
04:13:10 <mauke> fool! any C programmer knows !2 is 0, not 3
04:13:32 <Baughn> > let !2 = 0 in ()
04:13:32 <lambdabot>   * Exception: <interactive>:1:145-150: Non-exhaustive patterns in pattern bi...
04:13:37 <ski> but this was `=', not `==' ;)
04:13:39 <Baughn> Nope ^_^
04:13:46 <mauke> ãƒ¾
04:13:58 <Baughn> Is that.. a tiny spaceship?
04:14:05 <mauke> no, a frownie
04:14:16 <Baughn> Really?
04:14:17 <hackagebot> hsgtd 0.2 - Console-based gettings-things-done application (MichaelLesniak)
04:14:18 <mauke> ãƒ„
04:14:59 <ski> (it's an `a' with a tillde, followed by an inverted `C', followed by a "three quarters" symbol)
04:15:10 <mauke> enable utf-8 support
04:15:28 <mauke> and upgrade your irssi while you're at it :-)
04:15:44 <Baughn> mauke: Tsu?
04:15:45 <Botje> displays as a smiley here :)
04:16:03 <ski> (*grumble* .. at least you're not suggesting i'm to restart my screen session)
04:16:15 <ivanm> skorpan: nope, doesn't crash it
04:16:16 <Baughn> mauke: ..katakana look /really/ bad in an 8x12 font
04:16:22 <ivanm> jrockway: I have no problems with haskeline in 6.10.4
04:16:41 <jrockway> press M-p to see the previous item in the history
04:16:43 <jrockway> doesn't work :)
04:16:45 <mauke> ski: I thought this could all be set from inside screen/irssi
04:16:52 <ivanm> jrockway: I only use it in emacs ;-)
04:16:59 <jrockway> yeah
04:17:07 <ski> mauke : mayhaps .. i don't really know
04:18:16 <jrockway> yeah, it is fixed
04:18:24 <jrockway> no need for "cat" anyway
04:18:29 <jrockway> functionally identical otherwise
04:18:47 <jrockway> ah wait, now it breaks with the \EOT nonsense
04:18:53 <jrockway> i will keep my workaround around
04:18:55 <Baughn> ski: irssi and screen work weirdly together. For some reason starting irssi switches off utf-8 mode - unless you start/resume screen with -U.
04:19:11 <Baughn> ski: I've tried any number of other fixes, but -U /works/.
04:19:19 <Baughn> (The others, by and large, don't)
04:19:36 <ski> (but that is only an issue when you *start* irssi, then ?)
04:19:46 <Baughn> No...
04:19:50 <DRMacIver> Baughn: Really? I've never seen that. I'm using screen + irssi here and I get unicode characters displaying fine.
04:20:27 <DRMacIver> (I don't have a hard time believing that it happens. I'm just surprised that I've not seen it if it does :) )
04:20:34 <Baughn> ski: There are all sorts of settings you need to make cooperate. First, whether or not the terminal connected to screen uses utf-8 - that's what -U is for
04:20:51 <ivanm> jrockway: can you check if removing cat does cause \EOT nonsense?
04:20:59 <Baughn> ski: Second, whether the screen vty should understand utf-8 - that's configurable, but -U sets the default to "yes"
04:21:02 <jrockway> yes, i did, and it does
04:21:08 <jrockway> plain ghci = nonsense
04:21:13 <jrockway> cat | ghci = working
04:21:23 <ivanm> OK, so I know at least that I can go back to using that hack if I have to
04:21:25 <Baughn> ski: Third, whether the LANG environment variable (or LC_..something) is set to utf-8; screen will do that if you pass -U, but it may be getting reset elsewhere
04:21:28 <ivanm> thanks jrockway
04:22:05 <Baughn> ski: Fourth, whether irssi is configured to utf-8 or not. It defaults to whatever LANG says, but can be manually switched - and after you save your configuration once, LANG becomes.. incoherent. Better make them match.
04:22:30 <Baughn> ski: ..I'd be so very happy if utf-8 had been invented forty years ago. ;_;
04:23:07 <ski> (you mean `LANG' is saved explicitly in the configuration regardless of whether it was manually switched inside irssi ?)
04:23:31 <Baughn> No, I mean LANG is used to set the utf-8 switch inside irssi, but once it's set it's saved in .irssi/config and overrides LANG
04:23:39 <Baughn> Except that, it seems, sometimes it doesn't
04:24:02 <ivanm> if I'm using type families in a class and I want to specify that the type of the type family has to be Ord, do I put that in the class definition?
04:24:03 <Baughn> Irssi is also capable of translating non-utf8 channels to utf-8, or vice versa..
04:24:28 <ski> (well, that amounts to what i meant :)
04:24:55 <mauke> hmm, I might disappear later. I'm upgrading tmux to 1.0
04:37:36 <maltem> ivanm, if you mean the type that is mentioned in the class head, yes
04:38:13 <ivanm> maltem: I want to put a constraint on one of the type family types
04:38:24 <maltem> if you mean the type that follows type ..., then not sure
04:38:33 <ivanm> e.g. class Foo a where type Bar a; I want (Bar a) to be Ord
04:39:11 <maltem> hmm no idea
04:40:13 <ski> (the "obvious" way would be to add `instance Ord (Bar a)' inside the `where' .. no idea whether that is implemented, though)
04:40:34 <maltem> oh, actually it seems to work like ivanm anticipated
04:40:57 <ivanm> you mean having to put them in the class (...) => constraints?
04:41:02 <maltem> at least, class Ord (Bar a) => Foo a where type Bar a -- does not error out
04:41:13 <ivanm> that also seems to require flexible contexts :s
04:41:27 <maltem> yes, but those are nice ;)
04:41:41 <maltem> but will that actually do the right thing?
04:41:43 <ivanm> are they? why?
04:41:59 <ivanm> maltem: I've seen that used in code before by Cale, etc., so I think that's the right way of doing it
04:42:09 <ivanm> I just thought it would have looked nicer in the type family setting
04:42:35 <maltem> well flexible contexts don't do anything scary, afaics
04:43:59 <maltem> still
04:44:07 <maltem> this doesn't look so good:
04:44:28 <maltem> test :: Bar a -> Bar a -> Ordering; test x y = compare x y
04:44:40 <maltem>  Could not deduce (Ord (Bar a)) from the context ()
04:45:05 <maltem> ah sry
04:45:13 <maltem> test :: Foo a => Bar a -> Bar a -> Ordering
04:45:16 <maltem> then it will work
04:45:38 <maltem> funny
04:47:48 <etpace> I've got import Data.Map as M, but there is still an ambiguity when I use the function map between prelude and M, is there a way so that it defaults to prelude?
04:48:08 <mauke> import qualified Data.Map as M
04:49:18 <ivanm> mauke: so have you disappeared yet? :p
04:49:26 <mauke> no, kernel problems
04:49:54 <mauke> turns out I accidentally uninstalled my current kernel sources or something
04:49:58 <ivanm> :o
04:54:27 <mauke> success. continuing install ...
04:57:12 <etpace> @pl \x -> fromList (zip [0..] (map (Just . ord) x))
04:57:12 <lambdabot> fromList . zip [0..] . map (Just . ord)
05:01:37 <ivanm> can anyone help me with this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9860#a9860
05:01:46 * ivanm doesn't see why it has that type error...
05:04:37 <etpace> @unpl \x -> uncurry Either $ length &&& (fromList âˆ˜ zip ([0..] :: [Int]) . map (Just . ord)) $ x
05:04:37 <lambdabot>  Illegal character ''\136''
05:04:37 <lambdabot>  at "ˆ˜" (column 46)
05:04:41 <lilac> ivanm: well, the type error is on line 58 of a 39 line piece of code ;-)
05:04:56 <ivanm> lilac: not helping... ;-)
05:05:00 <etpace> @unpl \x -> uncurry Either $ length &&& (fromList . zip ([0..] :: [Int]) . map (Just . ord)) $ x
05:05:01 <lambdabot> \ x -> uncurry Either (length &&& \ g -> fromList (zip ([0 ..] :: [Int]) (map (\ m -> (Just) (ord m)) g))) x
05:05:07 <etpace> @pl \x -> uncurry Either $ length &&& (fromList . zip ([0..] :: [Int]) . map (Just . ord)) $ x
05:05:08 <lambdabot> uncurry Either . (length &&& fromList . zip ([0..] :: [Int]) . map (Just . ord))
05:05:10 <lilac> i assume it means line 28
05:05:14 <etpace> is there a way to remove the :: [Int]?
05:06:04 <ivanm> lilac: yeah
05:06:05 <ski> @type uncurry Either
05:06:06 <lambdabot> Not in scope: data constructor `Either'
05:06:12 <ivanm> didn't think about the line numbers wrt the error
05:06:30 <etpace> I mean, [0..] seems to default to [Integer]
05:07:02 <ivanm> etpace: create a custom defaulting declaration
05:07:04 <etpace> or not, my mistake :P
05:08:15 <ivanm> lilac: am I likely to need FlexibleContexts or something in the second file?
05:08:35 <ivanm> nope, that doesn't help... >_>
05:08:58 <lilac> ivanm: the problem is clusterID
05:09:12 <ivanm> I don't see why it's a problem though...
05:09:38 <lilac> clusterID is not usable, because its type is Cluster cl -> Maybe GraphID, with Cluster cl a type family (not a data family)
05:09:39 <ivanm> since doesn't the type sig of graphvizClusters' make it obvious which instance it's using?
05:10:15 <lilac> suppose we have an instance of ClusterLabel where type Cluster [Int] = Int and we have another where type Cluster (Maybe Int) = Int
05:10:25 <lilac> what function do we use for clusterID (42 :: Int)?
05:10:55 <ivanm> ahhh
05:10:59 <ivanm> dammit!
05:12:14 <ivanm> I can't change the typeSig of what clusterID should be, so it looks like I've got to go back to requiring users to put it in or else have another class which specifies the clusterID function :s
05:12:33 <lilac> or use 'data Cluster cl' rather than 'type Cluster cl'
05:13:46 <ivanm> nah, I want to work with Ints, etc.
05:13:50 <etpace> @hoogle State
05:13:50 <lambdabot> module Control.Monad.State
05:13:50 <lambdabot> Test.HUnit.Base data State
05:13:50 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
05:15:50 <lilac> ivanm: can you turn it around, so that you define instances for the Cluster types and have an associated type for the cluster label?
05:16:34 <ivanm> lilac: I now have class ClusterType c where clusterID ...; class (CLusterType (CLust cl)) => ClusterLabel cl where ...
05:16:41 <fxr`> what is a mealy style state machine like?
05:17:29 <lilac> ivanm: that looks like it could work
05:17:38 <ivanm> it does! \o/
05:17:44 <ivanm> it's a bit uglier though :(
05:19:53 <lilac> fxr: it's like: a -> State s b
05:20:19 <lilac> more like (a, a -> State s b) i guess
05:20:27 <lilac> s/a/s/
05:20:37 <fxr> a transducer?
05:21:49 <fxr> oh a fst
05:21:50 <fxr> ok
05:23:43 <fxr> @hoogle mealy
05:23:43 <lambdabot> No results found
05:49:05 <fbru02> @src !!
05:49:05 <lambdabot> xs     !! n | n < 0 = undefined
05:49:05 <lambdabot> []     !! _         = undefined
05:49:05 <lambdabot> (x:_)  !! 0         = x
05:49:05 <lambdabot> (_:xs) !! n         = xs !! (n-1)
05:58:26 <en0th> - this might be a really stupid question - does every function belong to a class?
05:58:52 <Botje> no
05:58:54 <Botje> :t head
05:58:55 <lambdabot> forall a. [a] -> a
05:59:05 <Botje> head's not in any typeclass.
05:59:21 <mauke> most functions aren't part of a class
05:59:49 <en0th> cause there's no need to i guess
05:59:50 <ivanm> does it make sense to specify unknown licenses in .cabal files and hope that they're picked up properly as OtherLicense?
05:59:58 <ivanm> or just use one of the defined ones?
06:01:35 <fxr> mauke: what about Hask class?
06:01:48 <mauke> fxr: a fairy tale, nothing more
06:04:19 <fxr> mauke: so looking at calculator's perspective Num is a fairy tale also
06:08:36 <mlesniak> Is there a function (that I've overlooked if it exists) that rounds a Double to a specific number of decimal places?
06:16:12 <burp> hm is there a way to use (,) infix without brackets?
06:16:27 <burp> > (,) 1 2
06:16:28 <lambdabot>   (1,2)
06:16:31 <burp> > 1 , 2
06:16:32 <lambdabot>   <no location info>: parse error on input `,'
06:16:38 <mauke> no
06:16:40 <burp> ok
06:16:49 <mauke> I've defined (~>) = (,) in my xmonad.hs for this
06:17:28 <McManiaC> if i do sth like "x >= length foo" on a *very* long string, will it read just the first x chars to get a boolean value or will haskell read the entire string?
06:18:14 <koala_man> McManiaC: it will read the entire string
06:19:05 <mauke> you want something like: not . null . drop (x - 1) $ foo
06:19:15 <McManiaC> ok
06:23:01 <burp> > let (~>) = (,); infix 0 ~>; in "x":["y"] ~> "a":["b"]
06:23:02 <lambdabot>   (["x","y"],["a","b"])
06:25:35 <Phyx-> Hi I was wondering if someone here could help me with some FFI, i'm getting some unresolve references error during compilation http://phyx.pastebin.com/d6063e798
06:26:40 <mauke> have you tried --make?
06:27:00 <Phyx-> I though --make and -shared produced an internal error. maybe that's fixed now
06:27:04 <mauke> oh
06:27:04 <Phyx-> lemme try
06:33:03 <Phyx-> mauke nope, didn't completely help the problem. I think I need to include the object files containing the library functions i use aswell.. If those are around
06:40:27 <Phyx-> hmm ghc uses gcc to compile does it now, how do i pass options down to the gcc?
06:41:00 <mauke> ISTR something like -optc and -optl
06:41:24 <Jafet> Erm, it doesn't?
06:41:24 <Phyx-> cool, thanks, let me give those a try
06:41:44 <Jafet> Unless you ask it to
06:42:08 <Jafet> Oh, you're building ghc. Nevermind
06:42:44 <Saizan> gcc is normally used only for linking
06:43:59 <Phyx-> Jafet i'm building a shared library using ghc, but i'm getting unresolved references errors. And i assume these come becauce ghc doesn't add the compiled references of used packages automatically
06:52:05 <Phyx-> hmm how annoying... adding the .o files by hand fixes the old errors, and adds new ones because those libraries were build using other libraries.. I must be doing something wrong here.. this must be automated
06:52:37 <Saizan> Phyx-: are those from C or haskell libs?
06:52:48 <Saizan> for haskell there should be --make
06:53:05 <ivanm> how do I stop the Paths_ module from appearing in the haddock docs if I use it to get the version?
06:53:30 <Phyx-> Saizan when i use --make and -shared together it doesn't parse the command anymore
06:53:35 <SamB_XP> ivanm: you could read the other haddock docs ?
06:53:48 <ivanm> SamB_XP: you mean the docs for haddock?
06:53:52 <SamB_XP> ivanm: or, wait, no that's generated ...
06:54:00 <ivanm> heh
06:54:20 <ivanm> nvm, worked it out
06:54:22 <SamB_XP> you would need to get a haddock directive inserted into the Paths_ module
06:54:25 <ivanm> had to list it in Other-modules
06:54:37 <ivanm> then it stopped appearing in the haddock index
06:54:38 <SamB_XP> ... or that ;-)
06:55:22 * SamB_XP wonders what the heck a treefish is...
06:55:26 <Phyx-> Saizan "ghc --make -shared -o GHC.dll GHCDllFFI.o GHCDllFFI_stub.o dllMain.o GHCDllFFI.def -static" doesn't work for instance
06:55:48 <SamB_XP> Phyx-: you should pass it your .hs files
06:56:58 <Phyx-> SamB_XP then i get
06:57:00 <Phyx-> $ ghc --make -shared -o GHC.dll GHCDllFFI.hs dllMain.o GHCDllFFI.def -static
06:57:12 <Phyx-> ghc.exe: panic! (the 'impossible' happened)
06:57:23 <SamB_XP> okay, that sounds like a bug
06:57:33 <Phyx->   (GHC version 6.10.4 for i386-unknown-mingw32):
06:58:44 <SamB_XP> you should probably report it and include your sources ?
06:59:01 <Phyx-> well, if i remember correctly, It has already been reported
06:59:07 <SamB_XP> oh
06:59:08 <Phyx-> just not marked to be fixed any time soon
06:59:19 <Phyx-> which is why i defaulted to adding the files by hand
06:59:23 <SamB_XP> well, chime in on it ;-P
06:59:32 <en0th> why -shared?
06:59:53 <SamB_XP> en0th: presumably because he wants to make a plugin of some kind
07:00:07 <SamB_XP> or possibly a C-callable library
07:00:50 <en0th> ok
07:01:03 <Phyx-> i'm building a windows dll
07:01:13 <Phyx-> via FFI, so yeah, a c-callable libary
07:02:27 * Phyx- takes a look at the bug status
07:04:40 <ivanm> QtPlaty[HireMe]: still no employer, eh?
07:05:58 <QtPlaty[HireMe]> No :(  Dropped a few jobs apps off last week and will repeat this week.
07:08:32 <Phyx-> SamB_XP it's set to be fixed in 6.12, when ever that comes out http://hackage.haskell.org/trac/ghc/ticket/3114
07:08:56 <SamB_XP> Phyx-: but, that's impossible!
07:09:03 <SamB_XP> it can only be fixed in 6.11!
07:09:09 <Phyx-> lol
07:09:19 <olsner> @ty ?diff <<< (?cut *** ?grep)
07:09:19 <lambdabot> forall (cat :: * -> * -> *) c b c1 b' c'. (?diff::cat (c1, c') c, ?cut::cat b c1, ?grep::cat b' c', Arrow cat) => cat (b, b') c
07:09:40 <olsner> arrows > pipes :D
07:09:52 <Phyx-> 25e66.12.1 (scheduled for September-November 2009)
07:09:58 <SamB_XP> Phyx-: were there any workarounds given ?
07:09:59 <Phyx-> hmm so.. now i get to idle for 2 months
07:10:00 <Phyx-> heheh
07:10:33 <SamB_XP> or you could, you know, see if it actually works in the latest 6.11
07:10:50 <Phyx-> SamB_XP well, no. But I could write a small app to aggregate the files that i would need to include and then just add them all and ommit --make
07:12:58 <Phyx-> SamB_XP though building ghc on windows isn't trivial no?
07:13:34 <SamB_XP> hmm ... I wouldn't think it was *that* hard, though I guess you do need cygwin ...
07:15:40 <Phyx-> ok, i'll give it a try
07:35:10 <coco> what does -O2 do that -O doesn't?
07:35:50 <SamB_XP> coco: more aggressive optimization ;-P
07:35:56 <SamB_XP> seriously, you could check the manual
07:36:01 <coco> I tried
07:36:16 <coco> it says -O2 applies "every non-dangerous optimisation"
07:36:21 <coco> without specifying them
07:36:26 <SamB_XP> but if you asked that about -O3 and -O2 a few years back, I could have said "not optimize"
07:36:30 <SamB_XP> coco: ... oookay ...
07:36:37 <SamB_XP> that's pretty vague
07:36:41 <SamB_XP> bug report it!
07:36:49 <burp> or read ghc source
07:37:08 <SamB_XP> perhaps both
07:43:34 <merijn> I'm reading through Yet Another Haskell Tutorial and was wondering if someone could explain some stuff to me. One of the exercise/solutions I found in it is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4212#a4215 I was wondering, why the fifth type "e" for Tuple (or is it a typo/mistake?) and why do the results for fromTuple need to be nested in a double "Either" type?
07:43:54 <Jafet> There is a list of errata somewhere
07:44:55 <coco> is there a pragma for call pattern specialization?
07:46:45 <SamB_XP> coco: call pattern specialization ?
07:46:50 <SamB_XP> I don't think so
07:48:39 <merijn> Oh, wait I think I get why it's a nested "Either" there. It's because the single a and the 3 tuples are all different types, so it needs a double either to have 4 choices of type to be able to return all 4 different types and still be correctly typed...
07:49:21 <Petrosian> merijn: The `e' just looks like a typo to me
07:49:35 <Petrosian> Tho' I haven't read that section of that tutorial
07:49:57 <SamB_XP> see, this is why you need to typecheck, not only your t-shirts, but also your tutorials
07:50:27 <Peaker> Why does Data.Judy use a type-class for hashing and not a hash func?  It also doesn't specify the hash instance for basic stuff like Char or string
07:50:42 <merijn> Petrosian: That's what I thought, am I correct about why fromTuple needs double Either's, though?
07:50:54 <Peaker> Why would people have an errata rather than just fixing it? (Perhaps changelog)
07:51:06 <SamB_XP> Peaker: well, I assume the idea is that it should work for many types ...
07:51:19 <SamB_XP> ... but no idea why they don't at least implement instances for H98 types!
07:51:38 <merijn> Peaker: I assume because there's a PDF being mirrored by people who won't all be updating it to a fixed version?
07:51:45 <SamB_XP> or did you mean you should be able to supply their own ?
07:52:26 <Petrosian> merijn: Your explanation sounds about right
07:52:28 <Peaker> merijn, mirroring stuff that gets updates is not expensive, nor is hosting a pdf
07:52:33 <SamB_XP> an erratalog would work great if you thought to put version numbers at the top
07:52:48 <Peaker> SamB_XP, nah, instances are global, so I'd rather have a hash func
07:52:56 <SamB_XP> Peaker: well, getting all the mirrors to update can be a hassle
07:53:09 <SamB_XP> especially ones with names involving "citeseer"
07:53:24 <Peaker> SamB_XP, even if that means writing your own lookup for different types, or your own hash class
07:53:41 <Peaker> a pdf doesnt really need many mirrors
07:53:46 <SamB_XP> Peaker: I suppose it would be valuable as a lower-level interface
07:53:51 <merijn> Peaker: I didn't say it was a GOOD reason
07:53:55 <SamB_XP> Peaker: doesn't mean you won't get them anyway!
08:08:57 <gwern> @quote porn
08:08:57 <lambdabot> jrmole says: any program that could read minds would just evolve into a porn downloader
08:09:52 <SamB_XP> jrmole was assuming the program would aim to please
08:10:05 <SamB_XP> ... in the most naive way possible
08:10:47 <thaldyron> is there a function/package for writing files atomically? (I could do it myself with tempfiles but, just like Haskell, I'm lazy...)
08:11:26 <merijn> thaldyron: Depends on your definition of atomically
08:11:46 <merijn> As for true atomicity you'd need filesystem support
08:12:28 <SamB_XP> for instance, you might want to stear away from ext4 for the moment ?
08:12:51 <SamB_XP> last I remember knowing, ext4 was not so good at that
08:13:06 <merijn> It's all about ZFS now :p
08:14:05 <thaldyron> merijn: hmm, I need to prevent a thread reading an incomplete file that is concurrently being written to.
08:14:21 <thaldyron> merijn: suppose I could use MVars
08:14:29 <SamB_XP> thaldyron: locks might help
08:14:38 <SamB_XP> I mean, on the files
08:14:47 <merijn> thaldyron: Well, in that case your screwed unless you use locks and/or a true atomic filesystem (any FS that supports Copy-On-Write should do)
08:15:29 <merijn> Mutable global state (read: filesystem) combined with concurrency sucks
08:15:54 <Jafet> sql to the rescue!
08:15:59 <thaldyron> SamB_XP, merijn: ok, thanks. Back to using locks then
08:16:38 <thaldyron> Jafet: I prefer happstack-state ;-)
08:16:59 <merijn> Hell, one of the main reason I find Haskell intriguing is that the lack of mutable state stops me from doing stupid stuff while threading :p
08:18:35 <Jafet> Soon you'll be wondering why other languages allow you to do it
08:23:20 <wdonnelly> thaldyron: the cautious-file package provides a simple mechanism to write files with the whole "create temp then move" safety thing
08:23:42 <wdonnelly> it's not quite atomic, but it's pretty close, and should avoid you ever seeing incomplete files
08:24:56 <thaldyron> wdonnelly: thanks, I'll have a look at it!
08:48:08 <coco> if haskell did whole-program transformatin could typeclass dictionaries always be eliminated?
08:48:39 <Phyx-> hmm is there any reason why hsc2hs insists on dropping caps and "_" from names...
08:50:44 <Saizan> coco: you'll still need something like those for existentials with a typeclass context
08:57:42 <hackagebot> binary-strict 0.4.5 - Binary deserialisation using strict ByteStrings (DominicSteinitz)
08:58:39 <tommd> Anyone waiting to get into the building for HacPDX?
08:58:42 <fooo> Where are all the videos that Malcolm Wallace uploaded?
09:00:20 <arjanb> fooo: http://www.vimeo.com/user2191865/videos
09:11:21 <nainaide> Help! please,  parse error on input `<-'    http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9863#a9863
09:13:16 <nainaide> Thsnks
09:13:47 <wdonnelly> you can only use the '<-' inside a 'do' block
09:14:53 <nainaide> wdonnelly,  infact I dont know how to insert a do block within a normal pure funtions.
09:15:33 <wdonnelly> as far as IO is concerned, you can't
09:15:41 <wdonnelly> you'd have to rewrite your function a bit
09:15:48 <wdonnelly> just a second and i'll have an example
09:16:22 <nainaide> wdonnelly,  wonderful,
09:17:13 <tommd> "tommd"
09:17:19 <tommd> > "tommd"
09:17:19 <lambdabot>   "tommd"
09:17:47 <tommd> > "tommd"
09:17:48 <lambdabot>   "tommd"
09:17:59 <wdonnelly> there should be a revision on that paste now, showing how i would rewrite it
09:18:26 <wdonnelly> the important thing to note is that because you're using the IO action 'openURL'
09:18:39 <nainaide> wdonnelly, yes
09:18:43 <wdonnelly> the return type of your function also has to become 'IO (foo)'
09:18:49 <Phyx-> nainaide that's not entirely true... you could do something that's generally frowned upon, which is use unsafePerformIO
09:18:55 <nainaide> wdonnelly, great!
09:19:05 <jfredett> okay, so I just sent out HWN, someone tell me if you get it, I think it should have worked, but I don't know.
09:19:22 <Phyx-> let  tags' = unsafePerformIO ( liftM parseTags $openURL x )
09:19:32 <Phyx-> but rewriting would be better yes
09:19:48 <nainaide> Phyx-, :) great!
09:20:15 <wdonnelly> Phyx-: i figure that understanding how to write a monadic function needs to be a prerequisite to using unsafePerformIO
09:20:20 <jfredett> anyone get HWN yet?
09:20:32 <Phyx-> wdonnelly which is why i said it's frowned upon :P
09:20:33 <wdonnelly> learning about it sooner just entices people to break all kinds of rules along the way
09:20:44 <fooo> Is there a way to download movies from vimeo on Linux?
09:20:48 <nainaide> wdonnelly, thank you!
09:21:18 <wdonnelly> nainaide: you're welcome. feel free to ask if you have any other issues
09:22:36 <nainaide> Phyx-, infact I just learn unsafePerformIO, :)
09:23:43 <srush> let's say I have a bunch of strings, represented as ints/atoms with a lookup table
09:23:49 <Phyx-> nainaide, but it shouldn't be used for what you're trying to do in this case. I said it because you should know it exists, but for your problem the path wdonnelly showed is better
09:23:56 <srush> is there a good way to implement instance Show for them?
09:24:02 <tommd> oooh, two copies of HWN - I'm special
09:24:12 <srush> is there a monadic show or something, that lets me do a -> m String
09:24:18 <copumpkin> srush: nope
09:24:29 <nainaide> Phyx-, I see, thank you.
09:24:30 <copumpkin> srush: for that kind of thing you probably want to use a memoizing function
09:24:33 <srush> how would you recommend doing that
09:24:37 <copumpkin> rather than looking them up yourself in a global table
09:25:30 <jfredett> shite, it did work the first time.
09:25:32 <jfredett> well.
09:25:38 <jfredett> lol, at least it got out.
09:25:45 <srush> I like the atom approach because I want to have ordering
09:26:13 <jfredett> byorgey: if you could punch it up on sequence, that'd be lovely. I'll send John another email sometime this week.
09:26:29 <jfredett> HAH! I fixed the line ending stuff.
09:26:32 <jfredett> at least on Nabble
09:27:17 <mmmdonuts_> jfredett: Worked the second time too.  And the third!
09:27:45 <sereven> jfredett: yep, looks good again here too in client where was previously ugly. thanks!
09:27:48 <copumpkin> srush: then you're going to need some unsafePerformIO I guess
09:28:05 <copumpkin> srush: just out of curiosity, why do you need atomic strings in the first place?
09:28:30 <srush> I have a bunch of maps on a limited set of strings
09:28:32 <jfredett> mmmdonuts_: yeh, sendmail can be touchy...
09:28:35 <srush> and I'm running out of memory
09:28:44 <jfredett> fixed in pipermail too.
09:28:52 <copumpkin> srush: might want to use a more memory efficient string structure than a list of chars?
09:28:53 <jfredett> okay, to it must have been mail.app's fault
09:29:20 <srush> yeah, I'm using bytestring
09:29:29 <srush> but ints seem so good
09:29:37 <srush> and then I can use patricia trees
09:29:47 <jfredett> although, I send the wrong issue # in the subject line... I'm awesome. If it aint line endings, it's my inability to count...
09:32:33 <jfredett> okay, enough of this, I'm going back to the cave to hibernate, later folks.
09:36:18 <dons> tommd: is anyone in need of a spare laptop? i can bring a backup.
09:38:01 <tommd> dons: not that I know of
09:38:03 <srush> so copumpkin your advice is to keep the lookup as a global and use unsafePerfomIO?
09:38:34 <srush> would it be bad to make the type (Int, LookupTable) for each of them?
09:39:25 <dons> tommd: ok.
09:39:51 <FunctorSalad_> @hackage stringtable-atom
09:39:51 <lambdabot> http://hackage.haskell.org/package/stringtable-atom
09:41:44 <nainaide_> wdonnelly,  I got a little error on that code, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9863#a9865
09:42:07 <srush> I looked at that package
09:42:23 <srush> but it just uses unsafePerformIO also
09:42:49 <wdonnelly> nainaide_: ah, i missed that bit of the function
09:43:58 <wdonnelly> i'd just move out the call to 'retrieve', see the most recent revision
09:44:53 <dons> bos: ETA on the benchmarking code? even alpha would be ok. need it for a hackathon project :)
09:45:04 <nainaide_> wdonnelly, I saw the most recent revision,  and dont understand " rest" mean
09:45:35 <nainaide_> wdonnelly,  I undertood. thanks
09:46:13 <srush> ok, I guess I'll try that, thanks, FunctorSalad_
09:46:45 <bos> dons: for you, http://darcs.serpentine.com/criterion
09:46:45 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
09:46:46 <nainaide_> wdonnelly,  great code! I learned much, thank you
09:46:51 <dons> wonderful!
09:47:06 <bos> dons: look in the examples dir to see how to use it.
09:47:37 <dons> bos: cheers! this will help my judy haxoring
09:47:51 <dons> ok. looks easy enough
09:48:25 <bos> dons: if you're building pure code, be careful that let-floating doesn't end up causing you to benchmark an empty loop.
09:48:35 <bos> empty loops are impressively fast, but not especially useful :-)
09:48:39 <dons> right.
09:48:43 <ahnfelt> I'm playing around with the SDL bindings
09:48:54 <ahnfelt> I get the strangest error though
09:48:58 <ahnfelt> http://paste.debian.net/47568/
09:49:06 <bos> dons: run the built program with -t win -k win to get graphs of performance
09:49:25 <ahnfelt> Even though the types seem to fit, gchi (and ghc) complains
09:49:36 <bos> dons: and patches welcome :-)
09:49:42 <dons> There is no available version of statistics that satisfies >=0.3.4 ?
09:49:51 <bos> oh crumbs. let me fix that.
09:51:20 <bos> dons: ok, statistics 0.3.4 on hackage now
09:51:48 <dons> roxors
09:51:56 <hackagebot> statistics 0.3.4 - A library of statistical types, data, and functions (BryanOSullivan)
09:52:00 <dons> heh
09:54:07 <dons> ok. we're in business.
09:54:54 <dons> still think it should have been 'criterium' :)
09:55:29 <bos> :-)
09:55:40 <bos> so you have Fib up and running?
09:56:11 <dons> pretty graphs
09:56:20 <dons> yep. works fine. charts are displaying
09:56:33 <bos> i need to use the chart API more cleverly, but it was a quick way to get started.
09:57:36 <dons> the challenge may be in helping users interpret the data
09:57:52 <bos> dons: yeah, i'm not done with that yet.
09:58:42 <ahnfelt> Lemmih: Maybe you can help me out (with this: http://paste.debian.net/47568/ )
09:58:50 <bos> dons: if you've any thoughts on that front, do share. i'll have to write up some decent docs, for sure.
10:00:20 <seanmcl> I'm trying to install readline via cabal.  My system has an ancient readline library in /usr/lib.  Thus, the haskell version fails to build.  I installed a new one in a /opt/local/lib, and tried cabal install readline --extra-lib-dirs=/opt/local/lib, but the configure phase of the build still found the old one.  Is there a way to put the new path in front of the old one?
10:02:31 <SamB> hmm, is reblogged a word ?
10:07:14 <dons> tommd: would it be wise to grab some cookies et al to bring for snacks, or is there any catering?
10:07:41 <tommd> dons: No catering.  About a dozen donuts that will go fast and a box of cookies are here now.  Oh, and lots of coffe.
10:07:44 <tommd> coffee
10:08:05 <dons> ok. i'll grab some treats from the shop. leaving now, on my way over.
10:08:05 <tommd> Feel free to bring more in!
10:08:18 <tommd> great - msg me when you get to the door.
10:08:23 <dons> will do.
10:08:30 * dons -> scaddadles
10:10:49 <Jeb> hello
10:12:40 <Jeb> I'm just starting to learn haskell and running into a little trouble
10:15:31 <Jeb> hello
10:15:37 <Saizan> hi
10:15:49 <Saizan> feel free to ask your question
10:16:24 <seanmcl> solved: for future reference:  cabal -v install --configure-option=--with-readline-libraries=/opt/local/lib readline
10:16:34 <Jeb> I'm trying to define a function, and I keep getting "not in scope" (I'm extremely new)
10:16:56 <srush> is it bad to have data types with thousands of constructors
10:17:09 <Saizan> @paste
10:17:09 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:17:33 <bos> srush: sort of
10:17:34 <Saizan> Jeb: you could paste your code there, so we can see what is the problem
10:17:46 <srush> like data EnglishWords = A | At | ...
10:18:03 <bos> srush: yes, that would take a long time to compile and be extremely unwieldy
10:18:16 <Jeb> its only one line:        square :: Int -> Int
10:18:57 <Saizan> that only gives the type signature for the function
10:19:07 <Saizan> you've to give it a proper definition too
10:19:21 <Jeb> how can I give it a proper definition if it won't even take the signature?
10:19:37 <Saizan> are you doing this at the ghci prompt?
10:19:51 <Saizan> it's better to put your definitions in a file
10:20:07 <Jeb> ya, at the prompt
10:20:13 <Saizan> at the prompt you can do "let square :: Int -> Int; square x = x * x"
10:20:25 <Jeb> okay, I'll try the file and get back to you
10:20:26 <Jeb> brb
10:20:29 <Jeb> thanks for your help
10:20:39 <Saizan> however most of the time you don't need to specify signatures at all
10:21:08 <Saizan> you still need to use let to define functions at the prompt, though
10:21:24 <srush> but dozens is probably ok
10:21:37 <srush> data POS = NN | VB | JJ | ...
10:21:53 <copumpkin> NLP?
10:22:49 <srush> yeah
10:24:33 <bos> @pl \a -> any (a`isPrefixOf`) b
10:24:33 <lambdabot> flip any b . isPrefixOf
10:25:14 <bos> @pl shouldRun b = null args || any (flip any b . isPrefixOf) args
10:25:14 <lambdabot> shouldRun = (null args ||) . flip any args . (. isPrefixOf) . flip any
10:25:17 <bos> eeek.
10:27:56 <lilac> null args || or (liftM2 isPrefixOf b args) ?
10:29:05 <lilac> (null args ||) . or . liftM2 isPrefixOf args
10:29:10 <lilac> i /think/ :)
10:29:35 <lilac> @type (null ?args ||) . or . liftM2 isPrefixOf ?args
10:29:36 <lambdabot> forall a. (?args::[[a]], Eq a) => [[a]] -> Bool
10:30:02 <lilac> @type or . (null ?args:) . liftM2 isPrefixOf ?args
10:30:03 <lambdabot> forall a. (?args::[[a]], Eq a) => [[a]] -> Bool
10:32:04 <fooo> bos refers to a talk dons gave in his presentation. Can someone give me the URL to that talk?
10:33:12 <sunrayser> is there any way to get the function itself from a string containing the name of the function? I think I need some reflection thing like String -> (a->a) and found the Data.Reflection library but it doesn't seem very documented
10:34:32 <copumpkin> it won't get you that
10:35:02 <copumpkin> you could make a simple Data.Map String (a -> a)
10:35:07 <copumpkin> and fill it in yourself
10:35:31 <sunrayser> ok and what if the type signatures are different?
10:35:40 <ray> a -> b
10:35:50 <copumpkin> then you have to do uglier things
10:35:52 <ray> template haskell maybe
10:35:56 <fooo> No
10:35:56 <lilac> sunrayser: you presumably know what the type of the function you want to call is.
10:36:03 <sunrayser> I actually have a string list containing all the functions' name
10:36:05 <fooo> Template Haskell cannot refer to the defining module.
10:36:24 <sunrayser> I used the haskell-src-exts library for that
10:36:43 <sunrayser> now I have to pass these functions as a parameter to another function
10:36:44 <lilac> sunrayser: you can use TH (from another module as fooo points out) to build at compile time a map from the strings to the functions, i suppose
10:37:01 <lilac> but the functions need to all have the same type, or you won't be able to /call/ them :)
10:37:07 <fooo> But TH is a nightmare in its own way.
10:37:14 <lilac> agreed :)
10:37:25 <fooo> Haskell and meta-programming are no friends.
10:37:40 <sapsi> Hello, I have quick question, how would I do the following (python code) in haskell for x in range(1,10): print x
10:37:59 <fooo> mapM_ print [1..10]
10:38:02 <lilac> sunrayser: what problem is it you're trying to solve?
10:38:12 <sapsi> much thanks
10:38:39 <sunrayser> lilac: well so start at the beginning
10:38:41 <ray> why not just a list of functions
10:39:34 <sunrayser> lilac: the current solution is to write this into a file: import COmpiler\ntest func "func"
10:39:42 <sunrayser> lilac: and load that into ghci...
10:39:55 <fooo> In QuickCheck there is also a lot of redundancy.
10:40:20 <sunrayser> lilac: but that only works if I call the whole thing from the root of the compiler folder structure
10:40:28 <ray> or if you really need the names for something, an association list or a Map from names to functions
10:40:53 <sunrayser> umm the src-exts thing gives me only strings
10:40:54 <lilac> sunrayser: what is this the solution for? what functionality are you trying to create?
10:41:17 <sunrayser> lilac: we're actually writing a compiler
10:41:46 <sunrayser> lilac: we need to parse the high level source, get all the function names and generate them into the target code
10:42:03 <fooo> So, referring to what bos said in his talk: saying people FP is great, doesn't help. Fixing the software does. So, get a proper documented TH working, get Leksah or a sane IDE working with everything the Java programmer expects, get writing high-assurance Haskell trivial, fix all open bugs in GHC and you will see the millions of users flowing in.
10:42:34 <fooo> It has nothing to do with marketing, but all with qualitity and quality is where it is lacking.
10:42:47 <sunrayser> lilac: but I'm actually wondering why the compiler actually needs the function itself
10:43:04 <bos> fooo: no, it's both.
10:43:08 <ray> compilers are more like string transforms
10:43:20 <ray> the state of haskell on windows is just embarassing
10:43:28 <ray> i put up with it because i love haskell
10:43:30 <lilac> sunrayser: i still don't quite follow. are you writing a haskell compiler, in haskell, that has access to the source code of the stuff it's compiling at its compile time?
10:44:01 <fooo> bos: one follows from the other. Saying to people "Haskell is really great", but leaving out the buts is just lying, imho.
10:44:12 <ray> sunrayser: a compiler is just a really complicated String -> String
10:44:17 <sunrayser> lilac: umm the source language is a high-level haskell-based stuff, the compiler is in haskell, and the generated code is in C
10:44:29 <fooo> (I am not saying that you do so. ) I only saw this one talk of you.
10:44:47 <ray> so you need to be taking apart your strings according to some kind of grammar
10:45:17 <mmmdonuts_> "you will see the millions of users flowing in" - eek, how do we stop that?
10:45:20 <sunrayser> ray: I got a nice parse output from parseFile, but that gives strings as names
10:45:35 <Alpounet> @hoogle modm
10:45:35 <lambdabot> No results found
10:45:39 <fooo> mmmdonuts_: what kind of silly response is that?
10:45:44 <bos> i don't think fixing all the open bugs in ghc would make one whit of difference to the number of extant haskell users.
10:45:47 <ray> yeah, those are basically your symbol names
10:46:05 <mmmdonuts_> fooo: It's not a silly response.  Why do you want "millions of users"?
10:46:07 <dm`> bos:  Fixing the libraries might.
10:46:18 <bos> dm`: probably, yes.
10:46:20 <fooo> mmmdonuts_: because of economies of scale.
10:46:24 <monochrom> There are not even millions of programmers.
10:46:54 <ray> the state of haskell on windows is embarassing, and the general "lol, windows" reaction to said state is even more embarassing :)
10:47:13 <sunrayser> ray: so I need to call the test_compiler stuff for all functions, and it needs the functino itself as a parameter (no idea why)
10:47:15 <dm`> As a relatively new haskell user, I'm very interested, but admitedly a bit freaked out by the libraries.  They just don't seem geared towards the kind of systems programming I need to do.
10:47:33 <fooo> dm`: what kind of things do you need to do?
10:48:04 <ray> maybe it wants to test the function against the generated code? i don't know
10:48:12 <bos> ray: i haven't had any significant problems on windows. if windows people find stuff wrong, they do need to pitch in and help. this is mostly volunteer-driven stuff.
10:48:50 <mmmdonuts_> fooo: so you want the average Haskell programmer to be like the average, say, PHP or VB.Net programmer, is that correct?
10:48:50 <ray> the platform is actually better on windows than uniax but that's where it stops
10:49:07 <ray> because then hackage is like "where's my sh" or "depends on unix"
10:49:09 <Jeb> @paste
10:49:10 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:49:16 <dm`> So for example, there's no support for cautious file IO.  This is absolutely critical to do in many kinds of servers.  Sure, it was easy to add an FFI wrapper to call fsync.  But it felt weird that what I was doing was considered so unusual that there was no support for itin the base library.  (Found some cautious-file thing on hackage, but for some reason it didn't work for me, and implementing my own hSync was easiest.)
10:49:25 <sunrayser> lilac: actually the compiler should access the to-be-compiled source code structure at the compier's runtime
10:49:33 <fooo> mmmdonuts_: what makes you think Haskell programmers are somehow better?
10:49:39 <ray> someone needs to go through hackage and fix dubious unix dependencies like that
10:49:43 <mmmdonuts_> fooo: Experience with both.
10:49:49 <fooo> mmmdonuts_: they are just more likely to have degrees.
10:49:56 <ray> sunrayser: the AST
10:50:04 <Saizan> dm`: you could packate it up so next time there'll be something working on hackage :)
10:50:20 <sunrayser> ray: probably
10:50:20 <fooo> mmmdonuts_: it just depends on the amount of formal training they received.
10:50:24 <mmmdonuts_> fooo: they are more likely to be better programmers, which is what's important.
10:50:24 <Jeb> can someone explain why this doesn't work as I would expect it to: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4216#a4216
10:50:28 <sjanssen> dm`: fsync might be in the unix package
10:50:31 <dm`> I do intend to start contributing packages when I'm a bit more familiar with cabal.
10:50:35 <mmmdonuts_> fooo: no, formal training is an indicator, not a requirement.
10:50:40 <sunrayser> ray: but it's in the "wrong" format
10:50:41 <Saizan> ray: that someone should be a windows user
10:50:58 <ray> saizan: alas, my hard drive failed earlier this week, so i'm not even a computer user
10:51:03 <fooo> mmmdonuts_: sure, but 1% of large number is better than 50% of a small number.
10:51:15 <mmmdonuts_> fooo: we disagree on that.
10:51:26 <lilac> if I type (length &&& head) [1..] into ghci then wait until it uses all my memory, my system stops responding and i'm left with little choice other than to reboot. is that a GHC bug or an OS bug?
10:51:39 <fooo> mmmdonuts_: you are afraid of the mailing lists being filled with n00bs?
10:51:56 <dm`> sjanssen:  It's not, though.  My point is not that it's hard to add, just that this gives a feeling that I'm entering uncharted territory whenever I do what I consider fairly basic server stuff.  This doesn't turn me off, but I would imagine it would turn off other people.
10:52:06 <fooo> I think that has already happened, in some sense.
10:52:24 <mmmdonuts_> fooo: no, of the entire language being compromised in future by the requirements of people who don't understand it.
10:52:25 <Saizan> lilac: you'd like a limited heap by default?
10:52:26 <fooo> The volume is too high for me to read everything.
10:52:26 <ray> lilac: if you're on an os i don't like it's an os bug, otherwise it's a ghc bug
10:52:35 <ray> (but probably not a bug)
10:52:45 <fooo> mmmdonuts_: the language has already been compromised a lot.
10:52:51 <sjanssen> lilac: just turn off swap
10:52:58 <fooo> mmmdonuts_: in fact, I would say that Haskell has a lot of mistakes.
10:53:10 <fooo> One of them is that meta-programming is not practical.
10:53:36 <dm`> Other issues I've had:  No way easy way to get the process ID of a process you spawn with createProcess (no biggie, just use System.Process.Internals, but again, something so basic that it seemed weird to use internal interfaces).
10:53:36 <bos> fooo: i think you might be misapprehending the importance of metaprorgamming.
10:53:40 <mmmdonuts_> fooo: that's not a reason to make it worse.
10:53:50 <ray> metaprogramming is overrated (mostly by lispers) but you have an important point
10:53:51 <Vq> fooo: i wouldn't call that a mistake
10:54:06 <bos> dm`: really? oh, that's funny.
10:54:13 <dm`> Or can't connect a bount socket.  Means people haven't done much network programming with haskell.
10:54:21 <fooo> bos: it makes me do repetetive work, because doing the repetition is faster than working around TH issues.
10:54:32 <sjanssen> dm`: System.Process is more for simple stuff that needs to be portable.  I use System.Posix for anything serious
10:54:33 <lilac> Saizan, sjanssen: if i write a program in c++ which does "while(true) new char[1000000];" it churns away for a while then is killed by the kernel
10:54:51 <fooo> bos: A selling point supposedly is that you can abstract over the semi-colon.
10:55:04 <fooo> So, why not be able to abstract over everything?
10:55:25 <lilac> why does the same not happen to ghci?
10:55:27 <sjanssen> lilac: your C++ program isn't touching that memory.  The Haskell code is, not to mention GC
10:55:43 <bos> fooo: you have to choose your boundaries somewhere. the number of people who work on the compiler is small, and they work on what's important to them.
10:55:53 <dm`> sjanssen: Yes, but docs warn heavily against the use of forkProcess.
10:56:04 <bos> fooo: i'm with you on the confusing nature of TH.
10:56:20 <lilac> sjanssen: hmm, fair point. but when my machine dies it's not swapping.
10:56:28 <dm`> sjanssen:  Plus there's no easy way to set the F_SETFD (close-on-exec) bit on file descriptors, so createProcess seems like the only way to close all open file descriptors you don't want passed in.
10:56:30 <lilac> sjanssen: it swaps for a while, then a deathly silence falls over it
10:56:42 <sjanssen> dm`: as long as you follow up with an exec() of some sort, you're fine.  That's as much as you can do with createProcess, anyway
10:56:45 <bos> dm`: you're doing very unix-specific stuff there.
10:58:01 <fooo> Liskell was very promising. I wouldn't mind using Liskell for meta-programming and Haskell for the rest, with some easy way to convert Haskell code to Liskell code.
10:58:21 <dm`> bos:  It's just stuff you really need to do when implementing servers (except for connecting bound sockets, which everyone needs to do).  Yes it happens to differ across OSes, but the fact is you can't necessarily abstract all functionality across OSes.  If Haskell tries to do that, it will be fighting two battles at once (adoption of Haskell, and unifying server programming APIs).
10:58:33 <fooo> If you don't need meta-programming, which the vast majority of programmers think they don't need, then Haskell is very nice.
10:58:43 <bos> dm`: sure. i know a little bit about server programming.
10:58:52 * dons @ HacPDX
10:58:52 <dons> dm`: people have done years and years of network programming in haskell. we have millions of dollars on this stuff.
10:58:52 <dons> dm`: so i want to see the bug report.
10:58:52 <dons> why was it promising?
10:59:34 <dm`> dons:  There's a bug report that's been open for 8 months, on a one-line change that would fix the socket issue.
10:59:42 <monochrom> The scientific method is so nice.
10:59:42 <copumpkin> how many people are at hacpdx?
10:59:43 <fooo> dons: because it simplified meta-programming Haskell to the point where it was useful.
11:00:09 <sjanssen> dm`: link?  I'm curious about the sort of stuff that is causing you trouble
11:00:48 <dm`> Sure, let me dig it up.  Incidentally, I don't mean to knock haskell, because often this stuff is easy to work around.  It's just stuff that I think could easily scare users off.
11:01:17 <dm`> http://trac.haskell.org/network/ticket/3
11:03:54 <sjanssen> dm`: presumably you're the last poster?  The best way to make this happen is to record a darcs patch and send it to libraries@haskell.org.  In your email, mention why the fix is important and whether it breaks any existing code
11:04:18 <copumpkin> it'd be funny if it did break existing code
11:04:27 <copumpkin> they'd need to be explicitly catching the error
11:04:51 <dm`> sjanssen:  yes, I'm the last poster.  My email to libraries@haskell.org bounces.  I think it's a closed list.  Can I subscribe so as to be able to post?
11:05:05 <copumpkin> dm`: yeah, usual subscription method
11:05:31 <copumpkin> http://www.haskell.org/mailman/listinfo/libraries
11:05:33 <sjanssen> copumpkin: but saying "This patch doesn't break compatibility in any way" helps the maintainer see that the patch should be applied
11:05:39 <copumpkin> yeah
11:06:05 <copumpkin> or a proof ad absurdum that the patch cannot break any code, because if it did, the code must be doing absurd things :P
11:06:48 <Saizan> network has a specific maintainer now though
11:08:16 <dm`> Well, the thing is I can't say for sure that the patch doesn't break compatibility in any way, because I don't really understand the logic of the original check.  Someone must have had a reason for preventing code from calling connect again, but I can't understand what that would be.  (After all, the OS already checks for this, so why duplicate the check?  It's an error condition, so you definitely don't need to optimize it.)
11:08:22 <bos> dm`: what's the patch?
11:08:38 <bos> dm`: i 'spect that someone confused bound with connected, nothing more.
11:08:43 <dm`> It's in the link I posted.
11:10:32 <sjanssen> dons: idea for the Distributions list on Hackage: mark distros that have the latest version of a package with a star or some such
11:10:45 <fooo> I do not understand this backwards compatibility concern. Just write a tool to convert a program using the old way to the new way.
11:10:59 <dons> sjanssen: mmm!
11:13:36 <dons> ?seen tibbe
11:13:36 <lambdabot> Unknown command, try @list
11:14:26 <sjanssen> wut?
11:14:31 <sjanssen> preflex: seen tibbe
11:14:31 <preflex>  tibbe was last seen on #haskell 3 days, 9 hours, 6 minutes and 57 seconds ago, saying: ksf: have you had time to look at profiling output?
11:14:45 <bos> dm`: ok, your bug is fixed.
11:15:57 <enolan> What's the status of git on c.h.o? SHA's cabal file lists git://code.haskell.org/SHA.git but I get connection refused.
11:16:13 <bos> dm`: i want to take a quick run through the bug list and see if anything else can be done in a quick drive-by.
11:16:46 <mrsolo> is pointfree style commonly used?
11:17:14 <sjanssen> mrsolo: pointfree is used on simple code fairly frequently
11:17:21 <mrsolo> it is pretty hard to read from time to time
11:17:34 <dm`> bos:  Thanks!
11:31:20 <mjrosenb> mrsolo: it takes some getting used to
11:32:21 <mjrosenb> mrsolo: for things that are just long chains of compositions, it is generally much clearer than having a lambda + ton of parens
11:32:59 <mrsolo> cut down readbility from time to time
11:33:28 <mrsolo> ((.)  . (.)) for example is a bit much
11:34:14 <Gracenotes> there are some situations where I've considered using it, I think...
11:34:57 <Gracenotes> except I think I'd phrase it (liftM.liftM) instead. perhaps not much better >_>
11:35:26 <sereven> or result . result
11:36:17 <dons> bos: titles on the graph would be good, as would x and y axis :)
11:36:59 <bos> dons: i don't know why those aren't showing up.
11:37:32 <dons> http://www.galois.com/~dons/images/1M.png
11:38:16 <bos> dons: y axis is time, x axis is sample number.
11:38:36 * bos `ap` fixing the plotting code.
11:38:48 <dm`> :t ((.)  . (.))
11:38:48 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:39:18 <dm`> That would be kind of useful under a friendlier name.  Too bad .. is taken.
11:39:32 <jmcarthur> dons: i notice that a lot of your code uses the INLINE pragma. any tips on when using INLINE is a better idea than not? i imagine smaller functions are better than larger, but beyond that i'm not sure.
11:39:35 <dons> http://www.galois.com/~dons/images/1M-curve.png ?
11:39:47 <bos> jmcarthur: you use INLINE when it helps performance.
11:39:50 <dons> jmcarthur: when you have some specialization in mind.
11:39:52 <SamB> jmcarthur: sometimes he overdoes things like that
11:39:54 <ski> dm` : `(.:)' has been suggested
11:39:54 <bos> jmcarthur: which you measure very carefully.
11:40:02 <dons> right.
11:40:12 <bos> dons: y axis is probability density function, x axis is time.
11:40:13 <SamB> for instance, in hmp3, he had # everywhere
11:40:15 <jmcarthur> bos: that's what i would do, but it looks like dons often does it very zealously
11:40:22 <SamB> for no evident reason
11:40:31 <bos> dons: so the peak tells you that most of your times are around 1.59e-8
11:40:32 <dons> i am zealous
11:40:43 <SamB> I mean, I believe I asked him and he couldn't think of a reason ;-)
11:40:55 <bos> SamB: we've gotten older and wiser since
11:40:59 <dons> oh, so that seems a bit short....
11:41:02 <dons> 0.0000000159s
11:41:13 <bos> dons: what are you measuring?
11:41:21 <dons> supposed to be inserting 1M ints into a judy hash
11:41:33 <dons> should be about 200ms
11:41:34 <SamB> bos: yeah, just warning jmcarthur that just because dons has done it doesn't make it a good idea ;-)
11:41:44 <bos> ah. have you compiled with -fno-full-laziness?
11:41:51 * dons tries
11:41:54 <bos> SamB: dons doesn't do it any more.
11:41:58 <dons> the actions are in IO though.
11:42:05 <bos> they are? oh hmm.
11:42:16 <SamB> bos: yeah, but I don't know what code jmcarthur is looking at
11:42:18 <bos> dons: got a piece of code handy that i can haz poke at?
11:42:33 <dons> let's see...
11:43:17 <jmcarthur> well, this time i happened to be looking at judy, but it's probably not the best example of tons of INLINE
11:43:17 <dons> http://www.galois.com/~dons/Bench.hs
11:43:25 <dons> bos: cabal install judy ; ghc -O2 --make Bench.hs
11:43:37 <jmcarthur> lots of small functions have it, but they seem so small that it would almost be common sense
11:43:43 <dons> (assuming you have the C Judy installed)
11:43:53 <jmcarthur> then again, if it's common sense, shouldn't the compiler figure it out?
11:44:19 <SamB> jmcarthur: hmm, you'd think the compiler would figure that out on it's own if their so small!
11:44:24 <SamB> oh, you said that
11:44:29 * SamB was a bit behind
11:44:29 <jmcarthur> :)
11:44:32 <mjrosenb> :t return return
11:44:33 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (a -> m a)
11:45:49 <ski>   eval Eval = eval
11:46:28 <SamB> jmcarthur: I've been feeling like this today: http://naesten.blogspot.com/2009/09/cant-haskell.html
11:46:43 <jmcarthur> heh
11:46:49 <bos> dons: looking into it.
11:47:04 <bos> dons: i think i see what's wrong.
11:47:28 <sinelaw> Peaker, hey
11:47:30 <dons> all ears
11:47:55 <bos> dons: if you're benchmarking an IO action, just use the IO action. no Int param required.
11:48:15 <dons> ah
11:48:34 <dons> i see it type checks :)
11:48:49 <dons> oh, this looks more sensible
11:48:58 <bos> dons: ok. 0.19 seconds to insert 1M elements.
11:49:27 <dons> yes, excellent.
11:49:30 <bos> dons: if you have any ideas on how to prevent people from shooting themselves in the foot that way, i'm all ears :-)
11:49:40 <dons> mean: 152.9545 ms, lb 152.3597 ms, ub 154.0533 ms, ci 0.950
11:50:00 <bos> whoa, crap. trying to insert 10M elements is DOSing my laptop.
11:50:01 <dons> different functions for IO vs pure benchmarking?
11:50:16 <bos> dons: that wouldn't obviously help.
11:50:29 <bos> because Int -> IO a is still "pure", just useless.
11:51:00 <dons> what's the const argument used for in the fib example?
11:51:13 <bos> the Int?
11:51:18 <SamB> bos: it might help often
11:51:32 <dons> yeah
11:51:37 <bos> dons: to prevent the expression from being thunked.
11:51:47 <dons> ah, so you run it 100 times?
11:51:51 <dons> that's what '100 samples' are?
11:51:55 <bos> yes.
11:51:58 <dons> sweet
11:51:59 <SamB> it would help people figure out what to do if they are looking at the docs and trying to see how to benchmark their thing
11:52:11 <tommd> @join ##hacpdx
11:52:11 <lambdabot> Not enough privileges
11:52:17 <tommd> @slap lambdabot
11:52:17 * lambdabot pulls lambdabot through the Evil Mangler
11:52:37 <dons> the 10M benchmark allocates about 1G
11:52:40 <dons> 1.3G
11:52:42 <dons> 1.4
11:52:48 <dons> ok. 2g
11:52:51 <bos> dons: jeezus pleezus. that's ridonkulous.
11:53:03 <Rotaerk> lol
11:53:05 <dons> we may be slow in freeing those 100 arrays
11:53:16 <bos> i have 3G on my laptop, and it plotzed when i tried running that.
11:53:28 <dons> 3.1g
11:53:48 <SamB> yeah, GHC doesn't know how much non-haskell-heap is being used ...
11:54:00 <dons> might be memory leak in the binding
11:54:12 <pasc1> we
11:54:15 <bos> seems plausible.
11:57:10 <tommd> ping: byorgey, gwern
11:57:15 <bos> so i guess we already have a little win case for the library. woo!
12:03:35 <dons> yeah.
12:03:39 <dons> well, i had to reboot my machine
12:03:41 <dons> but yeah.
12:03:45 <bos> snrf.
12:03:59 * dons tests to see if the finalizers are running
12:04:05 <bos> just think of all the nice clean memory you have now. a high colonic for your allocator!
12:04:26 <dons> i feel so clean now
12:04:32 <dons> rejuvenated.
12:04:42 <bos> so.
12:04:48 <bos> here's something i could do which would be fugly.
12:05:13 <bos> i could look at the TypeRep of a benchmarked pure function to see if its return type is IO, and barf if so.
12:05:27 <bos> i could possibly do that statically with enough ugly type hacking, too.
12:05:54 <bos> but i'd prefer not to have 4-line type signatures for n00bs. or for myself.
12:06:06 <Saizan> sigh, no love for Uncurry
12:06:07 <monochrom> Haha 4-line type sigs.
12:06:11 <dons> ah ....
12:06:18 <dons> bos: you know why the finalizer's not getting called?
12:06:23 <bos> nope.
12:06:29 <dons> because the GC doesn't realize there's a 100M array sitting on the C side of the heap
12:06:33 <dons> it looks to the GC like 1 ptr
12:06:38 <dons> so no heap pressure.
12:06:46 <bos> oh, ouch.
12:06:54 * dons thinks
12:07:07 <bos> i guess we've known at the back of our heads that we needed that for a while.
12:07:10 <dons> need a cost accounting for ForeignPtr
12:07:16 <bos> i bet that mmap-bytestring suffers from the same problem.
12:07:17 <dons> where you set the real cost
12:07:22 <jmcarthur> eek
12:07:24 <dons> yep. all foreign allocated ForeignPtr stuff
12:07:33 <dons> just shows up bad when there's no other heap pressure.
12:07:49 <dons> a performGC in the inner loop here should help.
12:07:55 <dons> maybe in bos' inner loop
12:08:05 <bos> dons: run with -g
12:08:35 <dons> +RTS -g ?
12:08:49 <bos> dons: no ./Judy -g
12:08:52 <dons> oh. awesome.
12:08:55 <dons> yes. working.
12:08:57 <bos> dons: or ./Judy --help
12:08:59 <dons> its freeing each time
12:09:00 <mauke>  * dons thinks  <- http://mauke.ath.cx/stuff/img/lol,internet/random/1175478432732.jpg
12:09:25 <dons> damn. its like bos thought of this already
12:10:11 * dons enjoys constant space
12:10:20 <bos> steady state 183M on my laptop now.
12:10:30 <rgr> whats the link/relationship between command ghci and hugs? When i start haskell in emacs hugs comes up and it has different error reporting form the examples in the haskell tutorial I am following which are in ghci.
12:10:40 <dons> alternating between 120 and 163m for me with the 10M test
12:10:56 <ziman> i'm running dijkstra algorithm for 20 vertices in graph in parallel "map (dijkstra graph) vertices `using` parList rnf" but the runtime drops from 33s (unthreaded) to 27s (-N2) only. The graph is ~5k vertices. Is it normal that the perf gain is so small (given that the jobs are independent)?
12:11:03 <dons> the finalizer is definitely getting run (i can see   it)
12:11:05 <mauke> rgr: they're both interactive haskell interpreters
12:12:21 <bos> dons: so about 1.8 seconds to insert 10M elements.
12:12:35 <rgr> well, yes I know they are. But what are the differences and why would I use one over the other?
12:12:39 <dons> bos: that's good
12:12:47 <bos> dons: compared to .18 for 1M.
12:13:12 * bos is really happy that the library makes all of this so simple.
12:13:16 <dons> they say these judy things scale properly.
12:13:21 <dons> yes, this is sooo much easier
12:13:27 <mauke> rgr: hugs is easier to install; it's just a C program
12:13:40 <bos> dons: if you want a quicker estimate, reduce the number of samples with -s
12:13:47 <monochrom> hugs is small. ghci is powerful.
12:13:50 <dons> is there a way to save graphs showing the scaling as .png or some such?
12:13:55 <dons> for inclusion in docs...
12:13:55 <bos> dons: almost.
12:14:08 <mauke> rgr: ghci comes with ghc, supports more extensions, and I like its diagnostics better
12:14:12 <bos> dons: -t csv works for now, and i'll add png, pdf, and svg support today hopefully.
12:14:51 <rgr> mauke: both are installed so thats not a reason to use one over the other. Any emacs users here, what can you recommend for running ghci as the interpreter from a haskell buffer. It seems quite murky out there in google land.
12:14:52 <bos> dons: scaling is another thing entirely.
12:15:01 <bos> which i also want to tackl.
12:15:30 <Saizan> rgr: M-x customize Haskell
12:15:35 <dons> ok. how do you want to write out svg? via cairo?
12:15:40 <dons> (there's code for that in vacuum-cairo)
12:15:47 <bos> dons: yeah, the chart library supports it.
12:15:48 <dons> actually, no. there's code to read in .svg and show it
12:15:51 <dons> ok.
12:16:08 <bos> but i want to make the charts more comprehensible first.
12:16:16 <bos> the current quick hack is not totally cromulent.
12:16:33 <dons> is there a way to set -g in the source?
12:16:35 <dons> defaultMain
12:16:39 <dons> defaultMain  { gc = True } ?
12:16:57 <bos> dons: oh, nice suggestion. hang on.
12:17:35 <dons>     , cfgPerformGC    :: Last Bool ?
12:18:02 <bos> right.
12:18:39 <sinelaw> Does/Can Haskell somehow enforce or verify the rules of operators on type classes (e.g. Monoid)?
12:18:51 <sinelaw> i meant on instances thereof
12:19:21 <Saizan> no
12:19:22 <sinelaw> and guessing the answer is _no_, which means that the implementer of instances must make sure his instance is really "ok"
12:19:23 <ziman> i don't think this is possible in general
12:20:00 <Saizan> sinelaw: exactly
12:20:07 <dons> bos: doing a super quick criterion demo at hacpdx in 5 mins :)
12:20:53 <sinelaw> Saizan, i guess it's not so bad because it forces you to think about your instance
12:20:56 <dons> print '.' on each iteration for slow benchmarks would be good
12:21:41 <bos> dons: ok, code with settable config is in darcs now. see examples/Judy.hs for usage.
12:21:48 * bos loves hackathons.
12:21:52 <dons> sweet.
12:22:07 <FunctorSalad_> sinelaw: it is bad, but to fix it you'd need a full-blown theorem prover ;)
12:22:16 <FunctorSalad_> sinelaw: you can do it in coq or agda
12:22:21 <bos> refactoring clean haskell code is like falling in love every time.
12:22:59 <sinelaw> FunctorSalad_, you'll also need to solve the halting problem?
12:23:38 <monochrom> Programmers solve the halting problem everyday.
12:24:10 <FunctorSalad_> sinelaw: yes, semantic equivalence of haskell programs is undecidable in general
12:24:31 <sinelaw> monochrom, but not computers
12:24:32 <FunctorSalad_> but you could prove the law for special cases in a prover
12:24:44 <FunctorSalad_> (namely, for your instance)
12:24:49 <Berengal> monochrom, no, we figure out if some given program halts or not, which isn't the halting problem
12:24:52 <Saizan> it'd be easy in general to prove e.g. associativity
12:24:56 <monochrom> coq and agda still require programmers to solve the halting problem.
12:25:16 <FunctorSalad_> Saizan: instance Monoid (Int -> Int) where ...? -- :)
12:25:28 <FunctorSalad_> err, Integer
12:25:54 <sinelaw> + and 0?
12:25:54 <sinelaw> * and 1?
12:25:57 <bos> dons: let me know what people say about the criterion demo
12:25:58 <Saizan> heh, s/in general/in many interesting cases, but not all/
12:26:14 <sinelaw> yeah.
12:26:45 <Saizan> for concrete numbers you shouldn't have a problem with an inductive view
12:26:46 <sinelaw> It's not so bad that it forces you to think about it, though, maybe you'll see that the instance actually fits a more general class
12:26:48 <Berengal> I have this nagging hunch that almost all interesting programs can be expressed in a non-turing-complete language with decideable semantics
12:26:59 <sinelaw> Berengal, me too
12:27:38 <Sgeo> Is it bad or good style to usually use import qualified?
12:27:41 <Saizan> well i wasn't considering the case where the prover finds the associativy proof for you, just that it checks the one you give to it
12:27:46 <FunctorSalad_> Berengal: intuitively I think the complexity would blow up even in very restricted languages
12:27:53 <FunctorSalad_> (complexity for deciding equivalence)
12:28:04 <Saizan> so the thinking would be necessary anyway.
12:28:42 <FunctorSalad_> Berengal: consider deciding equivalence of (\b1 b2 b3 ... -> (b1 || b2) && ...) and False
12:28:53 <FunctorSalad_> that's the SAT problem, and it's NP-complete
12:29:03 <FunctorSalad_> (in the number of boolean variables)
12:29:25 <monochrom> OK, programmer writes his program and "just knows" this program is correct, satisfies all the required properties, everything. The only choice he makes is: (A) for the sake of other people, write down the proof and make it checkable; (B) be snobbery and "I just know, it's obvious, any smart person sees it"
12:29:26 <sinelaw> FunctorSalad_, but how big expressions are you going to build?
12:29:53 <FunctorSalad_> maybe I was being to vague there, the second "..." only involves logical connectives
12:30:22 <sinelaw> FunctorSalad_, even an NP-complete problem that's not very big, is eventually solved
12:31:53 <FunctorSalad_> sinelaw: but wouldn't you get similar issues for less artificial examples?
12:31:58 <Saizan> sinelaw: an expression can become very big if you include all the definitions of the functions you use
12:33:27 <sinelaw> it's all guesswork for me anyway because i have no idea how a restricted useful language will look like anyway
12:33:32 <SamB_XP> Berengal: why is that a hunch ?
12:33:36 <SamB_XP> tried Coq yet ?
12:33:52 <SamB_XP> my thinking is that you either haven't, or know not what it is
12:34:36 <Berengal> SamB_XP, I know what it is, but I haven't tried it myself. Mainly though, it's because I haven't defined "interesting" formally yet
12:34:42 <FunctorSalad_> SamB_XP: I'm not sure whether you are saying that coq corrobates or refutes the hunch
12:35:39 <SamB> FunctorSalad_: corroborates
12:35:41 <pao> @pl \x -> map ($x) [id, (+1)]
12:35:41 <lambdabot> flip map [id, (1 +)] . flip id
12:35:45 <monochrom> Suppose you stick to booleans, integers, linear arithmetic, and the usual control flow. Then termination of your programs is decidable. See for example Byron Cook's "Terminator".
12:35:54 <mauke> pao: sequence [id, (+1)]
12:35:59 <SamB> the non-turing-complete part, at least ;-P
12:36:34 <pao> > sequence [id, (+1)] 2
12:36:35 <lambdabot>   [2,3]
12:36:44 <monochrom> (IOW the answer to the question of decidable subset is to be found in the verification field rather than the language field.)
12:36:46 <pao> mauke: thanks :-)
12:36:47 <FunctorSalad_> monochrom: ? not if "the usual control flow" includes general recursion
12:36:53 <pao> mauke: can it be done with Monoid?
12:37:17 <mauke> pao: what do you mean?
12:37:25 <bos> wow, the chart library is really daunting.
12:37:33 <FunctorSalad_> SamB: hmm the restriction used by Fixpoint is a real restriction sometimes
12:37:45 <FunctorSalad_> SamB: and general measures can be non-trivial
12:37:50 <pao> mauke: the solution you proposed uses (r->) as Monad instance... right?
12:37:57 <mauke> ah, yes
12:38:22 <SamB> FunctorSalad_: yes, but you *can* reason about lots of interesting programs ...
12:38:31 <pao> mauke: I was wondering if there is some other pointless version based on Monoid instance...
12:39:18 <Saizan> ?type appEndo . mconcat . map Endo $ [id,(+1)]
12:39:18 <sticazzi> Hello! I've just started learning haskell this morning.. with the whole lazyness in place.. is it more efficient to reverse a list result from a foldl, or simply use foldl?
12:39:19 <lambdabot> forall a. (Num a) => a -> a
12:39:40 <SamB> argh
12:39:44 <sticazzi> in other words... do I still need to care about tail recursion?
12:39:46 <SamB> stupid ICFP contest memes
12:40:18 <Saizan> @wiki Stack overflow
12:40:18 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
12:40:18 <SamB> sticazzi: foldr is usually preferred
12:40:22 <monochrom> Don't care about tail recursion. Care about something else.
12:40:36 <Saizan> that wiki page explains what to care about, somewhat
12:41:28 <BMeph> @type flip id
12:41:29 <lambdabot> forall b c. b -> (b -> c) -> c
12:41:59 <pao> > [id, (+1)] <*> pure 2
12:41:59 <lambdabot>   [2,3]
12:42:06 <monochrom> But you will be thrilled that "print (map f [0..])" is O(1) memory.
12:42:55 <SamB> monochrom: well, unless the compiler floats out a CAF and ...
12:43:16 <pao> @pl <*> [id, (+1)]  . pure
12:43:16 <lambdabot> (line 1, column 1):
12:43:16 <lambdabot> unexpected "<"
12:43:16 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:43:21 <sinelaw> CAF?
12:43:32 <pao> @pl (<*>) [id, (+1)] . pure
12:43:33 <lambdabot> ([id, (1 +)] <*>) . pure
12:43:48 <SamB> @vera CAF
12:43:49 <lambdabot> No match for "CAF".
12:43:53 <SamB> I thought not ;-)
12:44:01 <SamB> Constant Applicative Form
12:44:02 <Badger> @help vera
12:44:02 <lambdabot> I perform dictionary lookups via the following 13 commands:
12:44:02 <lambdabot> all-dicts ... Query all databases on dict.org
12:44:02 <lambdabot> devils ...... The Devil's Dictionary
12:44:02 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
12:44:02 <lambdabot> elements .... Elements database
12:44:04 <lambdabot> [9 @more lines]
12:44:45 <monochrom> Unless Easton's 1897 Bible Dictionary already has CAF.
12:44:46 <FunctorSalad_> why is it O(1)? fusion?
12:44:48 <pao> mauke: ok... I'm sold with your solution... thanks :-)
12:44:59 <SamB> @vera vera
12:45:00 <lambdabot> *** "vera" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
12:45:00 <lambdabot> VERA
12:45:00 <lambdabot>      Just playing around, huh?
12:45:00 <lambdabot>  
12:45:01 <sinelaw> in 1897 that was already obselete i guess
12:45:02 <FunctorSalad_> or does ghc figure it out on its own
12:45:04 <monochrom> O(1) even without fusion.
12:45:12 <FunctorSalad_> hmm
12:45:28 <monochrom> Think about garbage collection instead.
12:45:36 <sinelaw> obsolete even :)
12:45:53 <SamB> sinelaw: why do you think that ?
12:47:02 <sinelaw> SamB, I've fed my comment into emacs' ELIZA and guess what it replied...
12:47:06 <sinelaw> "Why do you say in 1987 it was already obsolete?"
12:47:48 <monochrom> There is a bisimulation between the two. :)
12:48:08 <sinelaw> @vera bisimulation
12:48:08 <lambdabot> No match for "bisimulation".
12:48:19 <SamB> sinelaw: vera is for acronyms
12:48:26 <SamB> @all-dict bisimulation
12:48:26 <lambdabot> No match for "bisimulation".
12:48:31 <SamB> @all-dict simulation
12:48:32 <lambdabot> *** "Simulation" gcide "The Collaborative International Dictionary of English v.0.48"
12:48:32 <lambdabot> Simulation \Sim`u*la"tion\, n. [F. simulation, L. simulatio.]
12:48:32 <lambdabot>    The act of simulating, or assuming an appearance which is
12:48:32 <lambdabot>    feigned, or not true; -- distinguished from dissimulation,
12:48:32 <lambdabot>    which disguises or conceals what is true.
12:48:34 <lambdabot> [73 @more lines]
12:48:47 <sinelaw> well. i've learnt "dissumulation" :)
12:48:59 <sinelaw> oops, dissimulation
12:48:59 <ksf> bisimulation is a proof technique iirc, involving isos.
12:49:36 <ksf> but there's actually approx 400 people in this channel knowing more about that kind of stuff than me.
12:49:46 <SamB> ksf: why 400 ?
12:49:48 <monochrom> For example to prove two infinite-list-generators to be the "same" i.e. generates the same infinite list, you use bisimulation.
12:50:10 <ksf> it's just a guesstimate.
12:50:16 <sinelaw> SamB: is it because of your plans that you ask why 400?
12:50:21 <SamB> monochrom: how would you formulate the relation?
12:50:22 <ksf> I figure the other 200 know nothing about it, just like me.
12:50:25 <dons> bos: demo done. looks great.
12:50:25 <monochrom> (Quick, someone enter "but there's actually approx 400 people in this channel knowing more about that kind of stuff than me" into ELIZA!)
12:50:48 <monochrom> Haha sinelaw :)
12:50:50 <dons> questions about: can we use it to measure scaling. what does the y axis in the clumping graph mean? (proportion of tests?)
12:50:54 <bos> dons: cool!
12:50:58 <SamB> Is it because there's actually approx 400 people in this channel
12:50:58 <SamB> knowing more about that kind of stuff than you that you came to me?
12:51:04 <bos> dons: can't use it to measure scaling ... yet
12:51:13 <monochrom> hahaha
12:51:14 <SamB> that's technically from M-x doctor
12:51:16 <bos> dons: y axis in the KDE chart?
12:51:18 <sinelaw> if ELIZA was alive, he'd be dead by now
12:51:19 * BMeph uses "Sergeant Schultz" as a life coach!
12:51:36 <monochrom> I thought ELIZA was a she.
12:51:37 <dons> http://www.galois.com/~dons/images/1M-curve.png
12:51:52 <SamB> monochrom: you would think that, wouldn't you?
12:51:55 <SamB> from the name and all
12:52:00 <sinelaw> i thought it was like the prophet (a he)
12:52:07 <ziman> dons, that's a neat graph; what plot it?
12:52:11 <ziman> (plotted?)
12:52:12 <SamB> the prophet is spelled with a J
12:52:18 <bos> dons: y axis is the probability density function
12:52:24 <dons> ah.. ok.
12:52:29 <sinelaw> ah.. ok.
12:52:30 <BMeph> ...or an "SH". :)
12:52:38 <SamB> though you wouldn't believe how often the names are mixed up
12:52:42 <SamB> BMeph: oh, well, him too
12:53:13 <SamB> but he's not quite as cool
12:53:13 <sinelaw> Ezekiel is the best. Now I'll go back to http://conal.net/papers/type-class-morphisms/
12:59:22 <sinelaw> that's a really cool paper, so far.
13:07:40 * SamB wonders how to debug font-lock rules ...
13:08:15 <monochrom> Just delete all of them. Have no font-lock-whatever.
13:18:42 <gnut> I'm getting timer_create issues when building ghc-6.10.4 using ghc-6.10.1 and I can't seem to resolve it using the answers found on the web
13:19:35 <gjl> I assume qthaskell isn't actively being developed as there hasn't been a release since over a year. Would I be better off using gtk?
13:20:08 <mahogny> I have heard a lot more from the gtk team. but then, I'm not an active H user anymore
13:20:59 <mahogny> with qt going lgpl it should maybe receive a higher priority though
13:23:03 <|randomwords|> Sometimes I think the world be a better place with one canonical gui library
13:23:51 <mahogny> only sometimes?
13:25:17 <|randomwords|> lack of competition probably has drawbacks
13:25:48 <|randomwords|> but the number of man-hours freed up..
13:25:48 <SamB> well, as long as it's not qt4
13:26:26 <mahogny> some. I think the problem with eg QT is that it is very highlevel for C++ users. would be better for everyone if there was a low-level GUI library which everyone could use, but with of several language-specific wrappers on top
13:26:45 <mahogny> and the lower part could be OS-specific even
13:26:47 <SamB> mahogny: my issue with it is the size of it
13:26:56 <SamB> mahogny: huh???
13:27:01 <SamB> OS specific ?
13:27:04 <mahogny> oh. lol. I compiled QT and it ate like 2 gb :C
13:27:10 <SamB> wouldn't that ruin the whole point?
13:27:12 <monochrom> If there is a canonical gui library, the man-hours freed up will go into a rivalling gui library.
13:27:19 <SamB> mahogny: I'm talking about the space to install it!
13:27:25 <SamB> that's a lot less but still too huge
13:27:31 <mahogny> SamB, yes. if you decide that you anyway will put a wrapper on top it's ok. then you can make it really small and lean, like a driver
13:27:35 <|randomwords|> monochrom: I'm proposing we outlaw gui competetion - have one sanctioned library
13:27:56 <monochrom> But in reality, we already have a canonical gui library, and it's called Windows.
13:27:58 <mahogny> |randomwords|, I have my hopes that some guy in open source will mandate one
13:28:03 <SamB> monochrom: no, no
13:28:08 <SamB> windows is not a GUI library
13:28:51 <|randomwords|> or we could all just use CLI and be happy
13:29:19 <SamB> there's a chance that there is a GUI library somewhere on the Windows 7 disk
13:29:31 <monochrom> Then what gui library do windows programmers use?
13:29:48 <mahogny> win32
13:29:57 <SamB> that's not a real GUI library
13:30:02 <Alpounet> all the windows-only GUI libraries Microsoft has written just... sucks.
13:30:05 <Alpounet> suck*
13:30:09 <mahogny> closest thing they have
13:30:10 <monochrom> Then win32 is the canonical gui library.
13:30:33 <|randomwords|> monochrom: Perhaps canonical was the wrong word. Try mandated
13:30:35 <SamB> it seems more like a syscall interface to me :-(
13:30:35 <monochrom> The emphasis is on "canonical". I don't really care how we bend the meaning of "gui".
13:30:47 <mahogny> I hate when people use a wysiwyg GUI-editor. always end up crap. or if they hard-code positions and sizes in pixels >:E
13:30:48 <Alpounet> Win32, MFC, Winforms, WPF, ...
13:30:49 <|randomwords|> or enforced
13:31:14 <mahogny> Alpounet, doesn't all that end up in win32 no?
13:31:26 <|randomwords|> mahogny: Perhaps one could realise your earlier idea by writing an even higher-lvl gui library which compiles down to all the others
13:31:40 <mahogny> that's what we have now. gtk and qt sort of does that
13:31:46 <SamB> mahogny: well, win32 does nothing to encourage an approach that does not involve hardcoding
13:32:00 <mahogny> problem is, the other GUI libraries are already very high-level. double work and hard to tweak different platforms together
13:32:30 <mahogny> SamB, totally noticed from some porting attempts -_-
13:32:40 <Alpounet> mahogny, it might, but anyway the way it is thought just sucks, most of time...
13:32:47 <SamB> I noticed from using WindowBlinds
13:32:52 <|randomwords|> it's hard to envisage a solution which doesn't require killing a lot of people
13:33:01 <mahogny> |randomwords|, killing? I'm on
13:33:06 <SamB> |randomwords|: couldn't we just waterboard them ?
13:33:13 <SamB> (or would killing be more humane?)
13:33:14 <monochrom> I like killing a lot of people. :)
13:33:18 <mahogny> it's war against terrorism!
13:33:21 <mahogny> win32 is terrorism
13:33:59 <mahogny> gates is funding research against cancer. but what then about win32?
13:34:06 <monochrom> All human social problems are solved by exterminating all humans.
13:34:21 <|randomwords|> underpopulation?
13:34:40 <monochrom> underpopulation is not a problem.
13:34:45 <|randomwords|> it would be
13:34:54 <Sgeo> Wait, the whole Either thing is asymmetrical?
13:35:04 <mahogny> underpopulation means that every birth counts more. hence you'd be making progress
13:35:07 <monochrom> Alternatively, I prefer it when no one is around to complain about underpopulation!
13:35:16 * Sgeo is looking at http://learnyouahaskell.com/making-our-own-types-and-typeclasses , right at "# instance Functor (Either a) where  "
13:35:18 <ski> @djinn Either a b -> Either b a
13:35:18 <lambdabot> f a =
13:35:18 <lambdabot>     case a of
13:35:18 <lambdabot>     Left b -> Right b
13:35:18 <lambdabot>     Right c -> Left c
13:35:25 <ray> i think we should just kill all the programmers
13:35:36 <mahogny> start with the c++ programmers
13:35:39 <ray> that'd get rid of enough social problems with less effort
13:35:47 <ski> Sgeo : currying is assymetrical
13:36:39 <Lycurgus> no start with the <X> programmers, where <X> is any single lang
13:37:02 <mahogny> there is an implicit "forAll" there :o
13:40:04 <Lycurgus> nah, there's plenty that style themselves, software engineers, plain ole programmmers, etc. anything but <X> programmer
13:40:29 <|randomwords|> Does anyone know what the currect ETA for 6.12 is. Some old articles stated this Sept. but that doesn't look too likely now
13:41:29 <|randomwords|> Lycurgus: If you have programmed in <X>, are you not an "<X> programmer"?
13:42:04 <SamB_XP> copumpkin: um, >50% of the channel just left
13:42:04 <mauke> I dunno, I've programmed in more than 20 languages
13:42:05 <SamB_XP> well, okay, we just left
13:42:30 <Lycurgus> just a big ass netsplit
13:42:41 <Lycurgus> wasn't just this channel
13:42:47 <SamB_XP> Lycurgus: I know that ;-P
13:43:09 <monochrom> Look on the bright side, the channel has just doubled!
13:43:17 <copumpkin> SamB_XP: yep
13:43:21 <copumpkin> SamB_XP: they don't like me :(
13:43:28 <SamB_XP> copumpkin: sure they do
13:43:33 <SamB_XP> they just left for a drink
13:43:33 <copumpkin> IRC sucks *****
13:43:37 <SamB_XP> ... all at the same time ...
13:43:51 <|randomwords|> hey - they were thirsty
13:44:01 <monochrom> for your blood
13:44:30 <copumpkin> Lycurgus: it's not about channels, it's about nodes in the network
13:44:49 <Lycurgus> |randomwords|, No, definitely not. Just a programmer that can program in <X>.
13:45:28 <Lycurgus> copumpkin, yes I know. But different channels use different nodes.
13:45:40 <SamB_XP> Lycurgus: huh ?
13:45:43 <|randomwords|> I can't help but feel you're unfairly murdering a lot of people due to thorny semantics..
13:46:00 <SamB_XP> Lycurgus: who are you killing off ???
13:46:42 <|randomwords|> <X> programmers
13:46:51 <Lycurgus> i think unrelated topics got crossed, at least in my ...
13:46:57 <Lycurgus> oh
13:47:08 <SamB_XP> Lycurgus: in my talking also
13:47:10 <monochrom> kill :: (forall X. <X> programmers) -> IO ()
13:47:22 <SamB_XP> what's the <> operator do ?
13:47:46 <monochrom> C++ <X> syntax!
13:47:48 <ski> kill programmers who program every language ?
13:47:57 <Lycurgus> well, actually I'd prefer to free them from the limitation to <X>, allow them to use <X> with a broader view, etc.
13:48:28 <SamB_XP> Lycurgus: oh, you meant the chronic monolingual programmers, then ?
13:48:34 <Lycurgus> them
13:50:34 <Lycurgus> and the whatever that loves them (markets, ignorant public, bosses, whatever)
13:50:50 <SamB_XP> but newbies -- they're safe, right?
13:50:55 <SamB_XP> I mean, you have to start somewhere, don't you ?
13:51:03 <copumpkin> nope
13:51:05 <copumpkin> I've always been amazing
13:51:11 <copumpkin> (ly annoying)
13:51:14 <SamB_XP> RIGHT
13:51:33 <Lycurgus> absolutely, don't hurt the younglings, everybody knows that
13:51:51 <|randomwords|> I mean - wasn't everyone's "hello world" a polygot quine?
13:52:04 <|randomwords|> Mine sure was
13:52:12 <SamB_XP> the first one?
13:52:17 <SamB_XP> well, maybe
13:52:28 <monochrom> Not mine. What is a polygot quine?
13:52:32 <SamB_XP> if I did it in BASIC at the REL
13:52:40 <SamB_XP> well, not a quine
13:52:45 <SamB_XP> just the polyglot part
13:53:09 <SamB_XP> monochrom: a program that prints its own source, when run in several different languages
13:53:23 <monochrom> I still can't do that now.
13:53:30 <|randomwords|> SamB_XP: Sometimes they are cyclic
13:53:37 <copumpkin> have you seen mauke's ridiculous polyglot
13:54:01 <SamB_XP> have you seen that cool cyclic quine from IOCCC?
13:54:10 <copumpkin> the manga one?
13:54:12 <SamB_XP> the one that does the cool shapes?
13:54:15 <copumpkin> with four manga characters?
13:54:22 <SamB_XP> is that what it was ?
13:55:04 <copumpkin> http://www.ioccc.org/2000/dhyang.c
13:55:34 <SamB_XP> copumpkin: that's the one
13:55:50 <SamB_XP> of course, that first form isn't part of the cycle
13:56:04 <|randomwords|> If only they used their powers for good...
13:56:23 <SamB_XP> oh, and http://www.dilbert.com/strips/comic/1996-08-19/ is funny ... looking ...
13:57:44 <SamB_XP> copumpkin: I still don't remember if I ever managed to read that program ;-)
13:58:15 <byorgey> jfredett: posted.
13:58:19 <byorgey> tommd: pong?
13:59:55 <mmmulani> can I compile a haskell program to C?
14:00:11 <copumpkin> yes, but you don't want to
14:00:27 <SamB_XP> well, not if it uses the full FFI you can't
14:00:30 <mmmulani> hmm how would I cross compile to a different platform then?
14:00:47 <SamB_XP> mmmdonuts: with great difficulty :-(
14:00:51 <SamB_XP> er.
14:00:54 <SamB_XP> mmmulani:
14:00:55 <mmmulani> dammit
14:00:55 <copumpkin> mmmulani: it writes platform-dependent c for you ;)
14:01:00 <mmmulani> ahaha oh god
14:01:09 <mmmulani> I will try compiling ghc on the server then :P
14:01:24 <SamB_XP> mmmulani: you'll need GHC already compiled to do that
14:01:41 <SamB_XP> mmmulani: though, that isn't to say compiling is necessarily pointless
14:02:24 <bos> dons: new rendering code in criterion darcs
14:02:27 <byorgey> mmmulani: what platform are you trying to target?
14:02:42 <mmmulani> debian x86_64
14:02:58 <copumpkin> bos: yay
14:03:42 <fergie> How do I modify the Formlets example from the wiki so that the form fields have labels?
14:03:45 <tommd> byorgey: Never mind, you send Greg the wiki password already - thanks!
14:04:23 <dons> bos: ok. trying it out.
14:04:52 <SamB_XP> mmmulani: ah, yeah, you may well want to compile up your own rather than use the packages
14:05:06 <byorgey> tommd: ah, ok =)
14:06:46 <bos> dons: PNG output support now in
14:06:47 <dons> bos: much more explanatory!
14:07:04 <bos> so pull again and run with "-t png"
14:07:06 <dons> what's the range for 'estimate of probability density'
14:07:15 <bos> [0,1]
14:08:38 <dons> so when it is 0 .. 8.0e-2
14:09:08 <bos> dons: you can basically disregard the numbers on the y axis. it's purely a visual aid.
14:09:15 <dons> ah ok.
14:09:17 <dons> good to know
14:09:20 <|randomwords|> bos: Which library did you use to output PNG?
14:09:26 <bos> |randomwords|: chart
14:09:30 <fergie> I've modified the wiki Formlets example so that it does what I want when "submit" is pressed. It would just look a lot better if I could lable the input fields
14:10:12 <dons> bos: ok. this looks good. i'll try to do thorough benchmarking of my lib as is now, and put up the results.
14:10:46 <dons> "variance is unaffected by outliers" is good?
14:10:54 <bos> yes!
14:11:01 <dons> excellent.
14:11:10 <Baughn> dons: (0,1), for real-life anythings - that lets you avoid infinities
14:11:14 <byorgey> |randomwords|: and it looks like Chart, in turn, uses cairo
14:11:32 <|randomwords|> byorgey: Yes - I came to that conclusion
14:12:24 <|randomwords|> currently to spit out PNG files I believe you need to use GD or SDL. It would be nice to have bindings to libpng or a haskell implementation of the PNG algorithm
14:12:39 <fergie> sounds like serious business is going on here. I'll try the Google again
14:13:06 <BMeph> Heh-heh, when hanging out in #math, I was shocked at how rude the folks are...then I understood why everyone always talks about how polite it is in #haskell... :)
14:13:32 <byorgey> |randomwords|: yeah, that would be nice
14:13:34 <_zenon_> BMeph: really?
14:13:44 <burp> really =)
14:13:47 <Philonous> BMeph: We should establish our own #math channel. Maybe we brand it #haskell-math.
14:13:54 <|randomwords|> BMeph: I would burn the #math bridge as soon as possible
14:13:58 <Baughn> Some channels are worse than others.. #math isn't actually that bad
14:14:07 <|randomwords|> Baughn: Depends what you want out of it
14:14:49 <|randomwords|> if you are genuinely stuck on a reasonably difficult problem that you can define well - then I imagine it can be helpful
14:15:15 <dons> bos: "  -t TYPE  --plot-timing=TYPE  plot timings" doesn't say what  the TYPE is
14:15:28 <burp> instance ToDBVal String where toDBVal str = DBString str <- why do I need TypeSynonymInstances for this?
14:15:36 <dons> String == [Char]
14:15:36 <Baughn> |randomwords|: You mean, they're not very happy with high-school type questions?
14:15:48 <burp> oh, ok
14:15:52 <mmmulani> #math gets a lot of "can someone do my homework" style questions
14:15:59 <dons> bos: also,
14:16:00 <dons> "$ ./Bench --help
14:16:01 <dons> hi mom!Usage: Bench [OPTIONS]"
14:16:05 <|randomwords|> Baughn: I don't know what the current state of affairs is. I know that _I_ wasn't happy with them
14:16:08 <dons> "hi mom!" might be a feature.
14:16:09 <Cale> |randomwords|: It depends on who is around :)
14:16:11 <bos> dons: yeah. png or pdf or svg
14:16:19 <|randomwords|> (read _|_ as emphasized I, not bottom)
14:16:36 <|randomwords|> Cale: Hmm?
14:16:50 <dons> oh, svg. roxors.
14:16:54 <SamB_XP> dons: but, the missing \n sure ain't!
14:17:09 <dons> svg makes me happy
14:17:11 <bos> dons: the svg and pdf output are currently 800x600 points, which makes no real sense.
14:17:15 <_zenon_> dons: You forgot about M$ existing out there.
14:17:18 <Cale> |randomwords|: It used to have more people who were willing to help beginners than it does now, it seems. I try to go and help out from time to time.
14:17:22 <Cale> (#math)
14:17:24 <bos> dons: if you have a better idea for point sizes, please let me know.
14:17:43 <dons> copy gnuplot's geometry flag?
14:17:46 <bos> 800 points == 11 inches
14:17:50 <dons> mmm
14:18:00 <dons> svg i don't care so much, i'll just rescale.
14:18:05 <dons> make it fit on a4?
14:18:10 <|randomwords|> Cale: Yeah. On the whole people do help out (I used to). But more often than not the asker will be berated about not specifying his question precisely, even though the meaning is obvious.
14:18:11 <bos> yeah, but i'd prefer it to make some amount of sense :-)
14:18:41 <|randomwords|> Also if you go there in search of higher-level mathematical discourse... well - it's rare
14:19:53 <dons> plotTimes SVG: not yet implemented
14:19:54 <dons> plotKDE SVG: not yet implemented
14:19:56 <dons> I SEE!
14:20:45 <bos> dons: clearly you aren't pulling frequently enough :-)
14:21:13 <dons> bos: might be interesting to scale the timing graph in percents.
14:21:19 <dons> let me show you what i mean
14:21:40 <dons> http://www.galois.com/~dons/images/insert-1M-timings.png
14:21:45 <dons> timing shows misleadingly large spike
14:21:48 <dons> when it is only 10ms
14:22:29 <dons> i wonder if that is GC.
14:22:37 <dons> nice tight density cluster, http://www.galois.com/~dons/images/insert-1M-densities.png
14:23:53 <bos> dons: yeah, there's a balance between zero-basing the graph and showing the discrepancies most clearly
14:24:15 <dons> indeed. i like the density functions
14:24:26 <bos> they're far more useful.
14:24:40 <dons> and plugging in some random gens here, in my test
14:24:49 <dons> so i can show the performance isn't affected by the values
14:25:17 <dons> this looks good for benchmarking networking code
14:25:20 <dons> ping times...
14:26:09 <bos> you could even use it to benchmark C code.
14:26:40 <dons> yeah. yay FFI
14:26:49 <|randomwords|> is there someone on the wiki where one could suggest potential projects?
14:26:49 <dons> most excellent.
14:26:55 <dons> |randomwords|: the proposals reddit
14:27:07 <dons> http://www.reddit.com/r/haskell_proposals
14:27:23 <|randomwords|> thanks
14:27:32 * mmorrow sees bos has released the goods
14:27:42 <bos> mmorrow: not released really.
14:27:48 <bos> unless you've a strong stomach.
14:27:48 <dons> beta testing
14:27:56 <dons> actually, its very impressive.
14:27:56 <mmorrow> bos: always!
14:28:13 * BMeph imagines that reddit section gets a lot of traffic from folks wanting to "make an honest woman" out of lambdabot...
14:28:21 * dons does some benchmarking. 
14:28:38 * BMeph does some benchwarming...
14:28:54 <SamB_XP> BMeph: what the heck ?
14:29:04 <SamB_XP> some kind of necromancy?
14:30:20 <BMeph> SamB_XP: Moe like "Oh, @vixen, you complete me, would you marry me?"-stuff. :)
14:30:40 <SamB_XP> how is she non-honest now ?
14:31:03 <dons> bos: thoughts on how to do comparisons?
14:31:14 <dons> keep the cvs and run it through gnuplot?
14:31:29 <dons> i want to overlay hashtable, intmap and judy, on the same test, as measured by criterion
14:32:08 <bos> dons: i'd like the app to support comparisons natively.
14:32:29 <bos> dons: just haven't thought through the UI yet.
14:32:53 <bos> dons: but something like '--compare=hashtable 10,intmap 10,judy 10'
14:33:04 <bos> dons: would seem nice to me
14:33:39 * Alpounet proud of having explained monads to a Java develope
14:33:41 <Alpounet> +r
14:33:45 <Vanadium> gtk2hs is confusing. In C I can bind gdk events like button-press-events on a GtkStatusIcon, but in gtk2hs, those belong to the WidgetClass and StatusIcon is not a widget :(
14:34:27 <SamB_XP> Vanadium: it isn't ?
14:34:36 <Vanadium> No
14:34:47 <SamB_XP> what's it's ancestry ?
14:35:26 <Vanadium> In C, GObject. In gtk2hs, I am just seeing class TreeSortableClass o => StatusIconClass o
14:35:30 <FunctorSalad_> SamB_XP: necromancy isn't the word for animating inanimate things, I forgot the proper word
14:35:59 <SamB_XP> you mean dead things aren't inanimate
14:36:00 <SamB_XP> ?
14:36:05 <hackagebot> checkers 0.2.3 - Check properties on standard classes and data structures. (ConalElliott)
14:36:21 <_zenon_> FunctorSalad_: Antropomorphization?
14:37:00 <_zenon_> FunctorSalad_: Goes generally for animals I guess
14:37:03 <FunctorSalad_> _zenon_: that's on the conceptual level, I mean on the concrete level, as in casting a spell to make a sculpture or something alife ;)
14:37:09 <FunctorSalad_> or a lambdabot
14:37:23 <FunctorSalad_> SamB_XP: they are, but not conversely
14:37:36 <monochrom> Invent a new word. Empower the sculpture!
14:37:38 <dons> bos: or the ability to graph two runs on the same scale
14:37:41 <Baughn> FunctorSalad_: Making a golem?
14:37:46 <FunctorSalad_> Baughn: yeah like that
14:37:50 <bos> dons: right
14:37:53 <dons> bos: but cvs and gnuplot probably best for now?
14:38:00 <mauke> .oO( type variable golemization )
14:38:03 <bos> dons: for now, yes
14:38:13 <FunctorSalad_> but do golems have emotions? you'd want a living lambdabot to have emotions
14:38:17 <_zenon_> FunctorSalad_: Animate?
14:38:20 <bos> dons: but be wary.
14:38:24 <Baughn> FunctorSalad_: So, since haskell values are immutable, and therefore inanimate.. does that make IO a subclass of Golem?
14:38:25 <FunctorSalad_> ok I guess this is #-blah o_O
14:38:35 <monochrom> I don't want lambdabot to go rage.
14:38:43 <bos> dons: the points that you'll get out of the kernel density estimator on the y axis will be different every time.
14:38:46 <dons> bos: what are you using for the timings?
14:38:51 <dons> cputime?
14:38:53 <bos> dons: so it won't be trivial to glue things together.
14:38:56 <dons> ah
14:38:59 <bos> dons: wallclock time.
14:39:09 <dons> ok. what's the resolution on that?
14:39:16 <bos> it tells you when it runs.
14:39:16 <dons> i see 1ms increments, appox?
14:39:22 <dons> ah
14:39:29 <bos> look at the first few lines of output.
14:39:32 <dons> estimating clock resolution...
14:39:32 <dons> mean is 12.83817 us (40001 iterations)
14:39:45 <dons> estimating cost of a clock call...
14:39:45 <dons> mean is 1.239019 us (79 iterations)
14:40:24 <bos> right.
14:41:40 <mauke> http://www.flickr.com/photos/30686429@N07/3953574039/in/set-72157622330082619/
14:42:28 <_zenon_> HAHA :)
14:43:07 <dons> criterion is going to change my life.
14:43:59 <Baughn> Come, now. The axiom of choice is obviously false. :3
14:45:56 <monochrom> Haha "free variables"
14:45:59 <|randomwords|> AC <=> WO (the well ordering of dead babies?). There's a joke in there somewhere, I guses..
14:47:21 <jperras> those are awesome signs
14:47:40 <SamB_XP> what is this about dead babies ?
14:47:58 <_zenon_> Yeah, some funny sh*t right there
14:48:40 <|randomwords|> look at the picture
14:48:45 <jperras> there's an "End Duality" sign that made me laugh more than it should have
14:48:52 <|randomwords|> its a pro-(axiom)-choice joke
14:49:29 <jperras> http://www.flickr.com/photos/30686429@N07/3954355212/in/set-72157622330082619/
14:49:31 <Makoryu> dons: Criterion?
14:51:07 <Saizan> _support_ vector machines :D
14:51:23 <Alpounet> heh nice pics
14:58:33 <JoePeck> hmm, I'm in GHCI, how can I load two modules up at the same time with :? commands, I cant seem to get it working
14:58:59 <Alpounet> :l mod1.hs mod2.hs shoud be okay IIRC.
14:59:50 <dons> :m +
14:59:53 <JoePeck> it compiles both
15:00:03 <JoePeck> but I can't access anything from the first to compile
15:00:20 <Jeb> can someone explain why this doesn't work?      [1 .. floor sqrt 9]
15:00:31 <mauke> yeah, floor only takes one argument
15:00:38 <monochrom> floor (sqrt 9)
15:01:09 <Jeb> sorry, I think I over simplified
15:01:16 <Jeb> one minute
15:01:58 <Jeb> @paste
15:01:58 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:02:55 <Jeb> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4217#a4217
15:04:00 <Saizan> floor (sqrt (fromIntegral n))
15:04:15 <Saizan> otherwise n has to be a Fractional
15:04:21 <Saizan> ?type sqrt
15:04:21 <monochrom> @quote fromIntegral
15:04:21 <lambdabot> forall a. (Floating a) => a -> a
15:04:21 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
15:04:24 <victimofgcd> Â¥ÇÅ½»¾¯ËÄ´óÈý£¬
15:04:24 <victimofgcd> ×£ÄãÈ«¼ÒËÀ¹â¹â¡£
15:04:24 <victimofgcd> ¶þÂÖÒ»ÔÂÎ´ÄêÉó£¬
15:04:24 <victimofgcd> Ê®ÌìÉÏÇ§±»Äã¿Ð¡£
15:04:25 <victimofgcd> ÐÄÏñÑÆ°Í³Ô»ÆÁ«£¬
15:04:27 <victimofgcd> ¸¯ÂÒ¸ÒÅ­²»¸ÒÑÔ¡£
15:04:28 --- mode: ChanServ set +o Saizan
15:04:29 <victimofgcd> Ò»µ³×¨Õþ²»ºÏÀí£¬
15:04:31 <victimofgcd> ¹²µ³ºÏ·¨µÄÍÁ·Ë¡£
15:04:33 <victimofgcd> Ãñ·ßÎÞ´¦ºÏÀíËß£¬
15:04:34 --- mode: Saizan set +b *!*=victimof@218.75.17.*
15:04:34 --- kick: victimofgcd was kicked by Saizan (Saizan)
15:05:04 <Saizan> and if that was the first alien trying to get help with haskell, i'm sorry
15:05:09 <monochrom> Nice poem. Rhymes with Â£Â¬. :)
15:05:15 --- mode: Saizan set -o Saizan
15:05:16 <Jeb> why do i need fromIntegral?
15:05:29 <monochrom> Because n is integer but sqrt wants double.
15:05:33 <Alpounet> ?type sqrt
15:05:34 <lambdabot> forall a. (Floating a) => a -> a
15:05:34 <jperras> if aliens were to learn one of our programming languages, it'd probably be haskell.
15:05:46 <Alpounet> Jeb, because of the constraint on a for sqrt
15:05:51 <Saizan> because you've to convert the Integer n to e.g. a Double befoe you can call sqrt on it
15:06:01 <Jeb> why does    sqrt 9          then? (sorry I'm very new)
15:06:09 <monochrom> Because 9 is overloaded.
15:06:09 <Saizan> 9 is polymorphic
15:06:14 <Saizan> ?type 9
15:06:14 <Jeb> alright, thanks
15:06:14 <Berengal> @type 9
15:06:14 <lambdabot> forall t. (Num t) => t
15:06:15 <lambdabot> forall t. (Num t) => t
15:06:21 <_zenon_> jperras: I think it would be assembly
15:06:32 <mauke> he did the same thing in #perl
15:06:43 <monochrom> If aliens were to teach us programming, it would probably be Haskell.
15:06:47 <Jeb> lol
15:06:54 <Berengal> monochrom, no, lisp
15:06:58 <burp> you suspect the aliens to be intelligent?
15:07:00 <Berengal> (Made with alien technology)
15:07:07 <burp> Berengal: haha right
15:07:32 <monochrom> aliens wouldn't teach us alien technology. state secret.
15:07:58 <dm`> no, haskell.
15:08:07 <monochrom> And with that, BMeph is abducted by aliens for studies.
15:08:10 <_zenon_> if aliens would teach us programming, it would be something organic.
15:08:25 <dm`> lisp is just syntactically weird.  haskell is more deeply different.
15:08:31 <Alpounet> Monads were probably invented by aliens, then taught to Wadler.
15:08:35 <_zenon_> Heh
15:08:49 <Berengal> Alpounet, or perhaps Wadler is an alien himself?
15:08:52 <dm`> Yeah, I mean who is Moggi?  Is that a humanoid name?
15:08:54 <monochrom> Monads were probably invented by aliens to be taught to Wadler.
15:08:58 <Alpounet> Not impossible.
15:11:07 <monochrom> E. Moggi is alien's name for a bacterium we call E. Coli
15:11:12 <merijn> Isn't Haskell more likely to be taught by zombie Church then aliens?
15:12:32 <dm`> No, it has to be aliens.
15:12:42 <dm`> Here's how sure I am...
15:13:28 <monochrom> fromIntegral is a long name.
15:13:41 <dm`> I have to make up a programming assignment for students to implement a network protocol (in C).  I'm going to give them an implementation in Haskell to interact with.  Ordinarily I'd be worried about them copying my implementaiton into their solution.  But I'm sure their human brains will not be able to comprehend the Haskell.
15:14:08 <FunctorSalad_> monochrom: "i2n" would be better? :)
15:14:14 <merijn> Well, are zombies human?
15:14:24 <dm`> zombies are ex-human, as I understand it.
15:14:36 <wdonnelly> "I have to make up a programming assignment for students to
15:14:36 <wdonnelly>              implement a network protocol (in C).  I'm going to give them an
15:14:36 <wdonnelly>              implementation in Haskell to interact with.  Ordinarily I'd be
15:14:36 <wdonnelly>              worried about them copying my implementaiton into their solution.
15:14:36 <wdonnelly>              But I'm sure their human brains will not be able to comprehend the
15:14:39 <Berengal> dm`, or they might turn in the c-dump of the haskell code :P
15:14:40 <wdonnelly> ugh
15:14:43 <wdonnelly> stupid PuTTY
15:14:44 <monochrom> You aren't even obliged to release the source code of your implementation (until after their deadline).
15:15:08 * wdonnelly didn't expect right-clicking to do that, i will be quiet now
15:15:33 <dm`> But I don't like giving only binaries, what if students want to run on some other machine.  (Or what if they want to learn haskell?)
15:16:33 <Berengal> transcribing haskell into C is not really straightforward either. Might be just as easy to just do the assignment
15:16:45 <monochrom> Assuming widespread availability of internet, you can just run your side on a school server, and let them connect from wherever they are.
15:17:29 <sm>  /me thinks copying a haskell implementation is a good lesson for budding c programmers
15:17:46 <monochrom> If some of them like to learn Haskell, they can see your implementation after the deadline.
15:18:11 <merijn> monochrom: Students don't do work after deadlines, of course
15:18:28 <monochrom> If your protocol has non-determinism, but your implementation doesn't, it is a bad idea to let them code to your implementation.
15:18:46 <dm`> I'm not going to give them the random seeds that we'll run with the grader.
15:19:06 <dm`> I just implemented RC4, and am using it as a source of randomness.
15:19:23 <FunctorSalad_> Berengal: -fvia-c? ;)
15:19:30 <dm`> It's kind of cool that I can make a random, 1MB Lazy ByteString, and just write it to a socket with hPut.
15:20:00 <mle> Is there something like sequence that works on functors of monads instead of lists of monads?
15:20:12 <Berengal> mle, Traversable
15:20:38 <mle> ahhh
15:20:38 <FunctorSalad_> mle: sequenceA
15:20:41 <mle> thanks.
15:20:53 <FunctorSalad_> (in Traversable, yes)
15:21:08 <FunctorSalad_> @hoogle sequenceA
15:21:08 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
15:21:08 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
15:22:09 <Berengal> sequenceA works on applicatives, sequence works on monads. Both are in Traversable, but Prelude has a list-version of sequnce...
15:22:51 <FunctorSalad_> @hoogle sequenceM
15:22:51 <lambdabot> No results found
15:22:55 <copumpkin> :t Data.Traversable.mapM
15:22:56 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:28:09 <mlesniak> Could someone take a look at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4218#a4218 -- a question about type classes
15:29:10 <Sgeo> Why is it, exactly, that foldr works on infinite lists but foldl doesn't?
15:29:16 <mauke> data WrapObject = forall a. (Object a) => O a
15:29:36 <mauke> data World = World { objects :: [WrapObject] }
15:29:52 <mlesniak> mauke, Hmmm, thanks, will meditate over this :)
15:29:54 <Raevel> wierd, my 3 year old macbook beat my 1yo workstation at compiling darcs+dependencies
15:29:57 <skorpan> Sgeo: because foldr can start producing results immediately while foldl can't (i think)
15:30:12 <dons> bos: the width of the bars in svg mode is too great.
15:30:15 <Alpounet> @src foldl
15:30:15 <lambdabot> foldl f z []     = z
15:30:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:30:20 <bos> dons: hm
15:30:20 <Alpounet> @src foldr
15:30:21 <lambdabot> foldr f z []     = z
15:30:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:30:21 <Philonous> > foldl1 f [a,b,c,d,e] -- Sgeo
15:30:22 <lambdabot>   f (f (f (f a b) c) d) e
15:30:24 <Philonous> > foldr1 f [a,b,c,d,e] -- Sgeo
15:30:25 <lambdabot>   f a (f b (f c (f d e)))
15:30:26 <mauke> instance Object WrapObject where tick (O a) w = tick a w; draw (O a) = draw a
15:30:38 <dm`> Argh!!  I just upgraded to ghc-6.10.4 on my system (gentoo), and they got rid of the source links in all the haddock documentation!
15:30:49 <mauke> w = World [O Box, O Box, O Box2]
15:30:50 <dm`> My computer is now useless.
15:30:57 <bos> dons: i just pushed some changes that let you specify plot sizes.
15:31:06 <bos> dons: so -t svg:800x200 for example
15:31:12 <dons> http://www.galois.com/~dons/images/insert-1k-timings-432x324.svg
15:31:14 <mlesniak> mauke, Hmmm, is there no easier way? Seems a bit complicated, thought this way kind of a usual case for classes?
15:31:25 <mauke> mlesniak: not really
15:31:38 <Sgeo> Ah, that makes sense, Philonous. Thanks
15:31:44 <mlesniak> mauke, Ok, thanks again!
15:31:57 <bos> dons: oh, that's funny.
15:32:46 <dons> i get smoother graphs when i increase the heap size on the bench program
15:33:47 <bos> dons: i get the same problem with PDF files
15:34:38 <Alpounet> where's criterion ?
15:35:39 <dons> $ ./Bench -g -k png -t png +RTS -H100M -A50M
15:35:40 <dons> Error: unknown plot typeRun "Bench --help" for usage information
15:35:43 <dons> png stopped working?
15:35:50 <bos> hmm.
15:36:14 <dejones> dons: just saw your Judy package, looks very cool.  Thanks!  :)
15:36:41 <dons> still has lots we can do, but its a stab at it
15:36:41 <bos> dons: oops, fix pushed.
15:36:55 <dons> ack.
15:37:03 <sjanssen> dons: how is judy different from HsJudy?
15:37:29 <dons> i'm writing it
15:37:38 <dons> so keeping an eye on the design, and the optimization story
15:37:48 <dons> HsJudy does some odd things, that i think kill performance.
15:38:10 <dons> same underneath though
15:40:37 * bos wonders whether Criterion is an okay module name, or maybe Benchmark.Criterion
15:41:00 <dons> its good enough it can have its own namespace :)
15:41:01 <Sgeo> It's kind of fun that a cat program can be written in one line of code (sorry, I'm re-exploring Haskell after a very long time of not having touched it)
15:41:59 <sjanssen> bos: it's not Haskell unless it has at least two useless hierarchy components at the top
15:42:12 <sjanssen> or one, in special cases
15:42:17 <BMeph> Control.Data.Judy? ;p
15:42:18 <bos> sjanssen: Bicycle.Twelve.Criterion?
15:42:37 <sjanssen> bos: Test.Benchmark.Criterion?
15:42:44 <bos> there we go.
15:43:11 <Philonous> Do packages on hackage ever expire?
15:43:39 <sjanssen> Philonous: no, each tarball receives a large portion of preservatives
15:44:26 <Gowilla> I think the whole system will start creaking at the seams in a few years, if it isn't already
15:45:40 <Makoryu> I wish (-) was better behaved.
15:47:51 <lilac> Sgeo: one line? two tokens :) and one of those is 'id'
15:48:22 <mauke> perl -pe0
15:48:25 <mauke> zero lines
15:48:29 <Makoryu> Quick, someone make a language where (pre|in|post)fixity is determined by whether the tokens are separated by whitespace
15:48:55 <Sgeo> Erm, I guess I'm not sure what a token is, because I'd imaging that "main = interact id" is 4 tokens
15:49:05 <ddarius> Makoryu: See Fortress
15:49:09 <Sgeo> Unless there's easier?
15:49:16 <lilac> Sgeo: well, ok, if you include the main = ;-)
15:49:50 <ddarius> cat
15:50:44 <lilac> it's zero lines in sed too, and that doesn't even require any specialcommand-line  arguments
15:53:12 <Alpounet> but it's harder to write, say, a WM, with Perl and Sed
15:56:57 <merijn> Alpounet: Wuss :p
15:58:21 <Alpounet> heh :-)
16:06:27 <Jeb> is it possible to use map with a function that returns a list?
16:06:33 <benmachine> yes
16:06:37 <benmachine> you get a list of lists
16:06:54 <benmachine> :t map (\x -> [x, x])
16:06:54 <lambdabot> forall a. [a] -> [[a]]
16:06:59 <benmachine> or!
16:07:05 <benmachine> you can use concatMap
16:07:09 <benmachine> a.k.a. =<<
16:07:13 <mmorrow> , map (\n -> replicate n n) [0..4]
16:07:16 <lunabot>  [[],[1],[2,2],[3,3,3],[4,4,4,4]]
16:07:18 <mmorrow> , concatMap (\n -> replicate n n) [0..4]
16:07:19 <lunabot>  [1,2,2,3,3,3,4,4,4,4]
16:07:39 <Jeb> I think that's what I wanted, thank you
16:07:54 <mmorrow> , join replicate =<< [0..4]
16:07:56 <lunabot>  [1,2,2,3,3,3,4,4,4,4]
16:09:44 <Jeb> worked, thanks for your help
16:14:33 <hackagebot> rss2irc 0.4 - Watch an RSS/Atom feed and write it to an IRC channel (SimonMichael)
16:16:36 <sm> um, ignore the massive typo in the hackage description
16:18:15 <skorpan> sm: which one is that?
16:18:35 <sm> I list the current options, then the options from the previous version
16:18:56 <skorpan> oh, hehe
16:19:14 * sm grumbles, messing up my simple version numbers
16:19:31 <skorpan> i wish hackage wasn't so static... wasn't there some discussion about changing this on haskell-cafe?
16:19:31 <byorgey> hehe, it happens to the best of us =)
16:24:54 <SubStack> is it trivial to lump "deriving (Data, Typeable, Read, Show)" into deriving from a single class which is a synthesis of these?
16:24:58 <SubStack> or even possible
16:25:23 <SubStack> preferably without resorting to template haskell
16:25:24 <dm`> Maybe with the StandaloneDeriving extension, but probably not.
16:25:51 <SubStack> reading
16:32:27 <SubStack> it seems somewhat contradictory that scrapping boilerplate requires adding more boilerplate
16:33:02 <SubStack> although I'm optimistic that there is a terrible hack to be found
16:33:11 <skorpan> if you're scrapping ~15 characters of boilerplate to begin with, i suggest you don't use syb
16:35:08 <SubStack> just trying to simplify the external interface
16:42:46 <kw317> hmm.. I'm trying to write a simple parser using Parsimony and I'm having trouble with parsing case statement of the form: case(target){expr1;value1;expr2;value2;default}
16:42:59 <kw317> my fist attempt was something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9875#a9875
16:43:28 <kw317> but it fails :(
16:47:09 <dm`> I'm so sad they took away my sources.
16:47:23 <dm`> Why is it not the default always to install haddock documentation with links to the sources?
16:53:48 <EvilTerran> kw317, i find it's worth lexing in a seperate step
16:54:48 <kw317> EvilTerran: yeah, but what I'm trying to do now is to get the grammar right, then I'm going to re-write it from scratch if I won't get bored with this ;-)
16:55:01 <kw317> EvilTerran: what's the best way to lex when using parser combinators?
16:55:11 <kw317> EvilTerran: any idea how to fix this parser?
16:56:59 <kw317> :r
16:57:06 <kw317> ups, not this window ;-)
17:03:13 <thedward> So, if I upgrade to Parsec 3.x am I just doomed to type annotations for all my parser functions?
17:07:33 <xle> Hey guys, is there a good yaml config file reader library for haskell?
17:09:54 <burp> http://hackage.haskell.org/packages/archive/pkg-list.html
17:10:01 <burp> plenty
17:10:02 <Berengal> xle, nope, but I'm writing one right now
17:10:18 <dons> bos: around?
17:10:23 <dons> how do I benchmark an IntMap?
17:10:47 <xle> I saw yaml-0.3 there, but not sure if that's what I'm looking for. I don't have any haskell experience yet, but I've been reading quite a bit and being able to read yaml files would be a huge plus if I decide to use haskell in a project.
17:11:16 <Berengal> xle, yaml-0.3 looked pretty good to begin with, until I realized it used unsafePerformIO and started throwing IOExceptions on failure
17:11:23 <Twey> xle: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/YamlReference
17:11:25 <dons> bos http://www.galois.com/~dons/tmp/Bench.hs
17:11:40 <Berengal> xle, if you know for certain your files are valid, it seems to work though
17:11:49 <dons> under a normal main, that should take about 7s a run. criterion thinks its taking 3.846337 us
17:12:17 <Berengal> Twey, that one's basically useless. Completely useless, in fact, unless you modify the source to export the actual type the parser returns...
17:12:30 <povman> I feel like doing some work on Reactive; is anyone actually working on it? Is it clinically broken?
17:13:18 <xle> Berengal: I see. I guess I can live with having to provide valid YAML. I think a robust YAML library would be a huge plus for the community though.
17:14:27 <Berengal> xle, I'm currently plowing my way through the YAML 1.2 specs, transcribing the BNF to haskell and mapping return values to the productions. If everything goes to plan, I'll have a parser ready in one to two weeks
17:15:05 <Berengal> A pretty-printer and other processing functions will probably follow soon after that
17:15:28 <xle> Berengal: Sounds good... How about this guy: http://hackage.haskell.org/package/HsSyck
17:15:34 <BMeph> Is there a package for distributed Haskell programming?
17:15:53 <Berengal> xle, I didn't even try that as everything's in IO, but I've seen a couple of other libraries that depend on it
17:16:08 * Berengal is a bit OCD about IO
17:17:13 <xle> It also returns a YamlNode with too much info for most purposes
17:17:21 <Twey> Why on Earth is parseYaml :: String -> IO YamlNode?
17:17:43 <bos> dons: hmmm
17:17:52 <Berengal> Twey, exactly. When I saw that, I produced a swear word, then pressed "back" on my browser
17:17:58 <Twey> Haha, aye.
17:18:12 <bos> dons: what's going wrong?
17:18:14 <Berengal> It's probably in IO because it's a FFI binding
17:18:27 <Twey> But it doesn't need to be
17:18:30 <Berengal> Same with yaml, but it unsafePerformIOs it's way out of it...
17:18:31 <xle> Ah that's right, it uses C syck
17:18:32 * Berengal grumbles
17:18:36 <Twey> FFI strips that IO automatically
17:18:44 <Twey> Well, that's okay
17:18:58 <Twey> So long as it's a pure function, that's the point of unsafePerformIO
17:19:02 <Berengal> It's not okay if I get async exceptions in my pure values instead of pretty Nothings
17:19:23 <Twey> Ah, yeah.  â˜º
17:19:27 <Berengal> Which is what happens in yaml...
17:19:40 <xle> Yeah that would be bad :)
17:20:07 <dons> bos: not measuring any time. (not sure if I need some 'force' function, this stuff is prob. not your fault)
17:20:21 <dons> just wondering if you can see an obvious reason why IntMap wouldn't be being evaluated properly.
17:20:36 <Berengal> Anyway, I should soon be able to parse JSON with my YAML library, unless I've screwed something up badly
17:21:04 <xle> Berengal: Good luck with that.. I'll be watching the hackage db for yaml parsers
17:21:06 <Twey> xle: So why YAML?
17:21:07 <bos> dons: let me replicate and see
17:22:38 <Berengal> Twey, human readable and easy to process, is my guess. Those were my reasons at least
17:22:40 <xle> Twey: It's been gaining a lot of traction in ruby/python communities.. and I've used in many previous applications so my team is used to its syntax
17:23:15 <xle> Berengal: Exactly, I like how simple/good looking yaml config files are. But I have not tried every option out there, so I didn't want to sound ignorant
17:23:29 <xle> Twey: Any alternatives to yaml that play nicely in the haskell world?
17:23:37 <Twey> I think my config-file-format-of-the-month is Lua.
17:23:44 <Berengal> xle, well, XML is also pretty decent, and has great haskell support, but it's OH MY GOD SO UGLY
17:24:09 <Berengal> It's human-readable only in the sense that worms are human food
17:24:14 <Twey> It's flexible enough that you can make the syntax readable like a config file, and it's also Turing-complete, in case your project grows to need the power.
17:24:25 <xle> Berengal: Ah XML for me as a huge no-no. It would be my reason to go with python instead of haskell in a computational project.
17:24:31 <xle> is*
17:24:52 * Botje really doesn't get the knee-jerk response to XML
17:25:14 * SubStack thinks xml is fine so long as he doesn't need to use it
17:25:14 <Botje> no, it's not pretty, but it gets the job done and has support for static typing through Xschema / DTD
17:25:15 <Berengal> xle, another alternative is haskell itself... I've been writing lots of xhtml in haskell lately, and not only is haskell a pretty decent templating language, but it looks better as well
17:25:29 <xle> Botje: Elegance is important when you are creating computational tools for non-IT non-programming people. YAML has been very easy to explain to a team of management consultants in my case.
17:26:13 <Botje> management consultants should be touching code or anything related to it!
17:26:17 <Botje> *should not
17:26:24 <SubStack> agree
17:26:25 <burp> http://ix.io/kf/hs <- can someone tell me how to solve this "Ambiguous type variable `b' in the constraint"?
17:26:25 <xle> you would be surprised
17:26:31 <Twey> Botje: SGML was carefully designed for publishing, and it's good at that.  It was never meant to be used for config files, and XML even removes the features that incidentally are good for such purposes.
17:26:32 <ezyang> burp: looking
17:26:54 <Twey> The effect is that you end up with more metadata than actual data, much of it redundant.
17:27:08 <bos> dons: it seems to be working for me
17:27:37 <xle> So what is the prominent way to implement configuration files for an application in the community?
17:27:44 <dons> bos: hmm. what's it measuring insert time as?
17:27:46 <dons> using my code?
17:27:48 <ezyang> burp: That's a very odd typeclass you have
17:28:05 <xle> Say I want to write a program that uses a large input file and performs some operations leading to a result, but those operations would be modified by a config file
17:28:06 <burp> ezyang: hm, I guess you're right :|
17:28:07 <bos> dons: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9876#a9876
17:28:28 <bos> dons: 140 ms to insert 100,000 items into a map
17:28:33 <Berengal> xle, several applications actually use haskell itself. It provides a high-level library and lets you implement your own main function...
17:28:39 <ezyang> Anyway, the actual answer to your question: look at the type for 'print'
17:28:40 <dm`> xle:  Just make some simple syntax that doesn't involve typing a lot of < > characters
17:28:51 <dons> bos: ok that sounds right
17:28:54 <dons> thanks.
17:28:59 <Twey> Yeah, I think Haskell is the most prominent config language about.
17:28:59 <ezyang> it's Show a => a -> IO ()
17:29:15 <ezyang> so Haskell doesn't know what typeclass to use
17:29:19 <Berengal> Haskell does require a bit of haskell and programming knowledge to use though...
17:29:38 * ezyang thinks of XMonad config 
17:29:39 <xle> dm, berengal: not sure if I am following you guys. I would ideally want to be able to have a directory with alternative config files, one of which I would choose every time I run the program
17:29:45 <bos> dons: i don't know what's wrong with your code. let me check it, instead of mine.
17:30:07 <ezyang> burp: You should try to make functions on your typeclass defined for everything
17:30:43 <ezyang> burp: In this case, I recommend axing the typeclass and having a fromDBVal with lots of matches
17:30:51 <dm`> Yeah, I'm saying roll your own config syntax, and make it simple.
17:30:58 <bos> dons: your benchmark successfully drove my machine into swap, so it seems ok.
17:31:09 <ezyang> burp: toDBVal might still work as a typeclass
17:31:17 <dons> bos: sweet.
17:31:19 <burp> hm, ok
17:31:23 <dons> ok. i wonder why it wasn't doing that here...
17:31:24 <xle> dm: an then implement a parser that would understand that syntax?
17:31:25 <Berengal> xle, JSON okay?
17:31:38 * dons darcs pulls
17:31:39 <Berengal> Implementing parsers in haskell is a cakewalk
17:31:42 <bos> dons: ah, wait.
17:31:53 <bos> dons: it was just the first run that did that.
17:31:56 <burp> ezyang: but then I need a fromDBVal for every possible target type
17:31:59 <dm`> I'm a C++ programmer, and for all my config files, I use a similar thing where each line of the config file is either a comment, blank, or a directive with one or more arguments.  \ at the end of the line for continuation lines.  " and "\ for quoting things.  That's it.
17:32:00 <dons> oh, it should allocate a lot, but its clearly reusing the result.
17:32:02 <ezyang> burp: Nope
17:32:03 <xle> Berengal: Actually, JSON would be more than enough for my needs now that I think about it. I need to be able to communicate strings, numerical values, arrays and dictionaries. that's about it
17:32:12 <dm`> But with haskell, I might be tempted to use the haskell lexer or something.
17:32:15 <Berengal> xle, there you go then :)
17:32:44 <burp> fromDBVal (DBString str) = str; fromDBVal (DBInt int) = int.. what would the type signature of fromDBVal be?
17:32:46 <ezyang> burp: fromDBVal keeps the same type signature
17:33:01 <ezyang> This is the beauty of algebraic data types
17:33:05 <ezyang> cheap and quick polymorphism
17:33:07 <xle> dm, yeah i've already seen quite a few parsing examples in various tutorials. interesting how easy it is to parse things like that with haskell
17:33:24 <xle> berengal, good point. i will check out some json libraries in that case
17:33:37 <xle> interesting discussion guys, thanks for the ideas.
17:34:43 <bos> dons: oh, i see what's up.
17:35:41 <Saizan> burp: to fix that ambiguous type variable error you should pick a type for the result of fromDBVal, making the whole thing useless i guess
17:35:42 <bos> dons: ghc's doing worker/wrapper transformation on the code.
17:36:20 <dons> ahh
17:36:27 * ezyang wants algebraic datatypes in Python >:-( 
17:36:53 <bos> dons: that's easily fixed.
17:36:56 <Saizan> burp: you could write a fromDBVal' :: (forall a. Show a => a -> b) -> DBVal -> b though
17:37:09 <burp> hm, yes
17:37:11 <bos> dons: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9877#a9877
17:37:19 <Saizan> burp: then "fromDBVal' print" would work
17:37:34 <Saizan> or you could use an explicit existential type
17:38:01 <burp> well in that case I can't do that
17:38:28 <bos> dons: see how i used the parameter passed in by the benchmarking code to ensure that the body doesn't get let-floated out?
17:38:53 <Saizan> burp: that being?
17:39:13 <burp> mapM (print . fromDBVal) vals <- how could I specifiy a type for the fromDBVal result?
17:39:21 <bos> dons: that reliably tells me that it takes 40ms to insert 100,000 elements into an IntMap
17:39:29 <Jeb> suppose, I have a list, and I want to multiply the first element by 12, the second by 12^2, the third by 12^3....
17:39:46 <burp> I will use/try your fromDBVal' solution
17:39:55 <Saizan> burp: "mapM (print . (fromDBVal :: DBVal -> Int)) vals" for example
17:40:00 <Jeb> what method would you use to do such a thing?
17:40:17 <ezyang> burp: You don't really care about the type
17:40:34 <ezyang> burp: You just care that it has the Show typeclass
17:40:47 <bos> Jeb: zipWith (\a b -> b * (12^a)) [1..]
17:40:48 <Saizan> > zipWith (*) [1..] (iterate (*12) 12)
17:40:49 <lambdabot>   [12,288,5184,82944,1244160,17915904,250822656,3439853568,46438023168,619173...
17:41:03 <bos> > zipWith (\a b -> b * (12^a)) [1..] [23,77,81,42]
17:41:04 <lambdabot>   [276,11088,139968,870912]
17:41:23 <burp> Saizan: this wouldn't work with [DBInt 1, DBDouble 1], right?
17:41:25 <copumpkin> Jeb: zipWith (*) (iterate (12*) 12))
17:41:27 <copumpkin> Jeb: it's simpler than that really
17:41:29 <burp> just with DBInts
17:41:31 <copumpkin> Saizan: zomg copione
17:41:33 <copumpkin> that's less efficient though
17:41:40 <ezyang> burp: Correct.
17:41:52 <Saizan> burp: right
17:42:10 <Jeb> thanks
17:42:21 <Saizan> burp: that's why i said it'd make the thing fairly useless
17:42:26 <burp> ok
17:42:31 <bos> @pl \m k -> insert k 'a' m
17:42:31 <lambdabot> flip (flip insert 'a')
17:43:30 <A1kmm> Hi, does anyone know the proper way to construct a Record suitable for project when building queries with HaskellDB?
17:44:02 * Baughn wonders what the value of the busy beaver function is for graham's number
17:44:03 <A1kmm> The tutorials seem to be out of date... I have an Expr Int, but I don't know how to make a Record from that.
17:44:41 <copumpkin> Baughn: rather large
17:44:50 <ezyang> Baughn: So big we don't know how big it is
17:45:58 <hackagebot> judy 0.2 - Fast, scalable, mutable dynamic arrays, maps and hashes (DonaldStewart)
17:47:25 <A1kmm> BTW I have: :t liftM (\tab -> tab ! feedTypeId) (table feedTypes)
17:47:32 <A1kmm>   :: Query (Expr Int)
17:47:45 <dons> what i was doing today: http://donsbot.wordpress.com/2009/09/26/very-fast-scalable-mutable-maps-and-hashes-for-haskell/
17:47:55 <A1kmm> :t (feedTypeId .=.)
17:47:56 <lambdabot> Not in scope: `feedTypeId'
17:47:56 <lambdabot> Not in scope: `.=.'
17:47:57 <A1kmm> (feedTypeId .=.) :: Int -> RecNil -> RecCons FeedTypeId Int RecNil
17:48:34 <A1kmm> So I can't use .=. to put everything together because feedTypeId .=. wants an Int, but I have an Expr Int
17:49:25 <bos> dons: nice pictures!
17:49:31 <burp> gnu R plots I guess
17:49:55 <Berengal> dons, :O HashMap?
17:50:11 <Baughn> (iterate (Î£) g_64) !! g_64
17:50:18 * copumpkin looks forward to mmorrow's hand-modified IntMap code being benchmarked by bos' new framework
17:50:53 <dons> bos: so my request is for the ability to overlay density functions
17:51:07 <bos> dons: yeah
17:51:11 <dons> then we can just automate the entire 'which lib should i use for performance requirement X' story
17:51:41 * dons was happy to get 100M elements into a judy array without stress or fus.
17:51:47 <dons> fuss. 8G would get us 1B elements i think
17:52:15 <bos> dons: i want to be able to pass in some parameters to benchmarked code via the command line, too
17:52:21 <Axman6> yeah, what i want to use the library for would be comparing various implementations of certain algorithms
17:53:58 * Axman6 has three algirithms written in haskell that are all around 1.6x the C version
17:54:00 <copumpkin> @tell mmorrow bos' new benchmarking framework could help you test your new hand-optimized IntMap!
17:54:00 <lambdabot> Consider it noted.
17:54:18 <jmcarthur> dang, criterion looks cool
17:54:25 <Axman6> my pain problem is however that it's a very parallelisable problem, but it refuses to run in parallel
17:55:03 <Axman6> s/pain/main
17:55:40 <bos> huh?
17:56:22 <olsner> Axman6: you mean with parallel benchmarks disturbing each other?
17:56:42 <Axman6> i mean the parallel versions only ever use one core
17:57:48 <Axman6> from what i can tell, i should get an almost linear speedup, and my parallel C version manages to speed up just fine
17:57:57 * jmcarthur foresees dons' blog becoming a harrop target soon
17:58:03 <Axman6> heh
17:58:05 <Alpounet> jmcarthur, lol
17:58:07 <Sgeo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9878#a9878 Why is this acting line-by-line and not character-by-character?
17:58:18 <Sgeo> I could have sworn I wrote a char-by-char version a long time ago
17:58:24 <mauke> without looking: buffering
17:58:24 <Sgeo> Don't have easy access to that code though
17:58:28 <mauke> oh
17:58:45 <mauke> terminal settings then
17:59:18 <mauke> if it works in ghci (but you can't quit it), it's definitely terminal settings
17:59:19 <Sgeo> ...Is there a way to make cmd.exe play nice?
17:59:26 <Sgeo> I'm on Windows
17:59:35 <Sgeo> Last time I wrote something similar, I was on Linux
17:59:36 <mauke> oh, no idea then
17:59:47 <SubStack> Data.Generics has an everywhereM function! This is highly relevant to my interests.
18:00:03 <mauke> .oO( pervert )
18:01:08 <SubStack> it's looking like my crazy persistence experiment is actually possible to write
18:01:08 <FunctorSalad_> hmm?
18:01:36 <Saizan> Sgeo: maybe you need NoBuffering on stdout too?
18:01:52 <Sgeo> ......wow, I'm an idiot today
18:02:08 <Sgeo> wait
18:02:10 <Sgeo> n/m?
18:02:31 <dons> jmcarthur: well, he's crazy, but i doubt it, unless he has something snarky or stupid to say
18:02:46 <Sgeo> stdout doesn't help
18:03:01 <Sgeo> Scary that I mistakenly confused stdin with stdout when you said that, though :/
18:03:07 <Axman6> dons: so he'll be posting about it very soon we can assume ;)
18:03:40 <SamB_XP_> dons: what do you doubt ?
18:03:45 <dons> actually, probably not. he doesn't really follow things in real time. slow to respond, not involved in events at the time they happen.
18:03:53 <dons> he's been quiet for a while
18:04:01 <SamB_XP_> who's been quiet ?
18:04:16 <mauke> harrop
18:04:20 <Alpounet> dons, he's writing a book. Or he just achieved, dunno.
18:05:28 <Alpounet> (F#)
18:06:14 <copumpkin>  I'm sure he'll point out that under certain conditions, the judy arrays are 2% slower than the F# equivalent, and therefore haskell sucks
18:06:55 <Axman6> dons: i have a feeling he only ever replies to these sorts of things when someone says to him 'this language is better than ocaml (?), and this proves why'
18:11:46 <Jeb> if I had a list of 3 values [1,10,100] and I want to times the first by 12^3, second by 12^2, and last by 12^1 how would I go about that?
18:11:59 <Jeb> I tried using iterate with div, to reverse the example you gave earlier
18:12:24 <Alpounet> @type zipWith
18:12:25 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:12:26 <Alpounet> ?
18:12:48 <Saizan> Jeb: what happens if the list gets longer, or is it fixed?
18:13:02 <mauke> > (\[x,y,z] -> [x*12^3, y*12^2, z*12^1]) [1,10,100]
18:13:03 <lambdabot>   [1728,1440,1200]
18:13:06 <Jeb> I was going to use length to determine that
18:13:12 <copumpkin> lol
18:14:02 <Saizan> you could just use the same function as before and do a double reverse
18:14:06 <Alpounet> @pl \[x,y,z] -> [x*12^3, y*12^2, z*12^1]
18:14:06 <lambdabot> (line 1, column 2):
18:14:06 <lambdabot> unexpected "["
18:14:06 <lambdabot> expecting pattern
18:14:11 <Alpounet> heh
18:14:44 <Jeb> saizan, how would that help?
18:14:45 <mauke> ok, bright colors on white background == bad idea
18:15:09 <Saizan> > zipWith (*) (iterate (12^3) (div 12)) [1,10,100]
18:15:09 <lambdabot>   No instance for (GHC.Num.Num ((t -> t) -> t -> t))
18:15:09 <lambdabot>    arising from the lite...
18:15:10 <Alpounet> Jeb, it'd help to know if the function that'd solve your problem has to take in account a fixed size for the list, or a variable size
18:15:16 <FunctorSalad_> mauke: and gray is a bright colour too!!!
18:15:23 <FunctorSalad_> sorry, pet peeve ;)
18:15:25 <Saizan> > zipWith (*) (iterate (div 12) (12^3)) [1,10,100]
18:15:26 <lambdabot>   [1728,0,* Exception: divide by zero
18:15:32 <Jeb> variable size, it'll depend on the length of the list
18:15:34 <mauke> FunctorSalad_: yes, gray is bright black
18:15:38 <Saizan> > zipWith (*) (iterate (`div` 12) (12^3)) [1,10,100]
18:15:39 <lambdabot>   [1728,1440,1200]
18:15:45 <Saizan> that works btw
18:15:50 <FunctorSalad_> (I'm thinking of gray-on-white text)
18:16:04 <Saizan> you want 12 to be the divisor, so the second argument
18:16:33 <Jeb> I kept getting division by zero errors
18:16:35 <Jeb> one min
18:17:11 <Saizan> > reverse . zipWith (*) (iterate (*12) 12) . reverse $ [1,10,100]
18:17:11 <lambdabot>   [1728,1440,1200]
18:17:17 <Saizan> same result :)
18:17:22 <BMeph> > reverse . zipWith (*) (iterate (* 12) 12) . reverse $ [1,10,100,1000,8192]
18:17:23 <lambdabot>   [248832,207360,172800,144000,98304]
18:17:58 * Saizan wonders if that fuses nicely
18:18:38 <Jeb> thanks for your help saizan, one last thing, what does `` do?
18:18:40 <Jeb> around div
18:19:00 <Saizan> it makes it infix
18:19:11 <Saizan> > 13 `div` 12
18:19:12 <lambdabot>   1
18:19:32 <mauke> two spaces?
18:19:34 <Saizan> so it's parsed like an operator
18:19:40 <A1kmm> I'd like to write a function like "showAndIgnoreException = (flip E.catch) (\e -> putStrLn $ show e)" with Control.Exception but this doesn't work because the type of e is ambiguous.
18:19:44 <Jeb> ah, alright, thank you
18:19:49 <A1kmm> Are there any language extensions that would let me do this?
18:19:57 <Jeb> looks like I have a lot more reading/understanding to do yet...
18:20:12 <FunctorSalad_> Saizan: 4 RuleFired
18:20:12 <FunctorSalad_>     1 foldr/nil
18:20:12 <FunctorSalad_>     1 foldr2/left
18:20:12 <FunctorSalad_>     1 iterate
18:20:12 <FunctorSalad_>     1 zipWith
18:20:29 <Saizan> A1kmm: you can just use the top of the exception hierarchy, i.e. SomeException
18:20:51 <Saizan> (flip E.catch) (\e -> putStrLn $ show (e :: SomeException))
18:21:02 <mauke> handle = flip catch
18:21:15 <A1kmm> Saizan: ah... I didn't know that was possible, thanks.
18:21:23 <mauke> E.handle (\e -> print (e :: SomeException))
18:22:00 <Saizan> FunctorSalad_: so no rule for the reverses it seems
18:22:30 <FunctorSalad_> Saizan: I can't yet decipher core :(
18:22:58 <A1kmm> Saizan: Thanks, I ended up with showAndIgnoreException = E.handle (\e -> putStrLn $ show (e :: E.SomeException))
18:23:00 <FunctorSalad_> maybe it should use less random variable names
18:23:47 <mauke> why not print? :-(
18:24:17 <Sgeo> Is Haskell used in the business world? How many/few Haskell jobs are there?
18:24:23 <A1kmm> mauke: Ah, didn't actually know about print... thanks.
18:25:15 <koninkje_away> Sgeo: http://industry.haskell.org/
18:25:22 <Saizan> dons today claimed they have millions of dollars in network haskell code where he works :)
18:26:39 <malouin> If I have some messy data typed value (MyData a s d f ...), and I want to make another value that differs from it by one field, (MyData z s d f ...), is there a nice syntactic way to do that?
18:26:56 <mauke> yeah, make it a record
18:27:25 <malouin> I thought it was a record.
18:27:30 <sbahra> data C = C { a :: firstValue, b :: secondValue }
18:28:03 <malouin> yes, I have MyData defined somewhere else, it has many fields.  Now I have a value of type MyData and I want to make another value that only differs by one field.
18:28:10 <sbahra> f o = a o :: C -> firstValue
18:28:28 <Axman6> data MyData a b c d = MyData { a :: a, b :: b, c :: c, d :: d}; foo = MyData 1 'a' 3 "hello"; bah = foo {a = [Nothing]}
18:29:00 <malouin> Axman6: great!
18:29:15 <sbahra> :(
18:31:26 <largos> is there an easy way to find out if ghci is using libreadline or libeditline? (simpler than strace?)
18:32:10 <largos> I haven't had ^p or ^n working for prev/next line navigation in ages, and it's finally bugging me enough to try and fix it...
18:33:16 <mauke> well, you could ldd the ghc executable
18:33:21 <mauke> the trick is finding it
18:34:19 <FunctorSalad_> trick? "which ghci"
18:34:54 <mauke> % file `which ghci`
18:34:55 <mauke> symbolic link to `ghci-6.10.2'
18:35:12 <mauke> % file `which ghci-6.10.2`
18:35:13 <mauke> POSIX shell script text executable
18:35:51 <largos> mauke: hm.. it's apparently not a dynamic executable
18:36:09 <mauke> it's a shell script
18:36:21 <largos> oh, of course
18:38:13 <largos> well, that wasn't so hard to find, but ldd doesn't show anything that looks like a line input library
18:39:01 <mauke> then it's probably using haskeline
18:39:36 <largos> ah..
18:42:16 <A1kmm> hmm, does Control.Concurrent.threadDelay have an upper limit of a 1 second delay or something?
18:42:39 <mauke> no
18:42:50 <mauke> more like 22 minutes
18:43:33 <A1kmm> Well, I'm telling it to delay for 20000000 microseconds between each iteration of my main loop, and it goes through the main loop 20 times in 20s.
18:44:02 <A1kmm> (the main loop for that concurrent process)
18:44:04 <mauke> > (2^32 - 1) `div` 1000000 `div` 60
18:44:05 <lambdabot>   71
18:44:07 <A1kmm> This is when compiled with -threaded
18:44:18 <mauke> > (2^31 - 1) `div` 1000000 `div` 60
18:44:18 <lambdabot>   35
18:45:03 <mauke> can you turn this into a short testcase?
18:47:25 <A1kmm> mauke: Actually, I found the problem... it turned out I had more than one concurrent process going to another bug in my program, sorry about that.
18:47:51 <Jeb> > 3+3
18:47:52 <lambdabot>   6
18:49:54 <SubStack> (+1) `mkT` 5
18:49:58 <SubStack> er
18:50:01 <SubStack> > (+1) `mkT` 5
18:50:02 <lambdabot>   6
18:50:10 <SubStack> neat, lambdabot has generics
18:50:58 <largos> what is mkT?
18:51:27 <SubStack> > (+1) `mkT` "moo"
18:51:27 <lambdabot>   "moo"
18:51:29 <SubStack> generics magic
18:52:00 <largos> huh
18:54:15 <copumpkin> :t mkT
18:54:16 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
18:54:43 <copumpkin> > ('a':) `mkT` "moo"
18:54:44 <lambdabot>   "amoo"
18:54:51 <FunctorSalad_> > mkT (*2) ("foo",(9,"bar"))
18:54:52 <lambdabot>   ("foo",(9,"bar"))
18:55:06 <FunctorSalad_> > everywhere (mkT (*2)) ("foo",(9,"bar"))
18:55:07 <lambdabot>   ("foo",(18,"bar"))
18:55:11 <FunctorSalad_> \o/
18:55:15 <copumpkin> neat
18:55:24 <largos> whoa
18:55:26 <copumpkin> > everywhere (mkT (*2)) ("foo",(9,"bar"),2)
18:55:27 <lambdabot>   ("foo",(18,"bar"),4)
18:55:31 <copumpkin> fancy :)
18:55:55 <SubStack> hopefully not useful too often
18:56:03 <FunctorSalad_> > everywhere (mkT (*2) `extT` (++"cat")) ("foo",(9,"bar"))
18:56:03 <lambdabot>   ("foocatcatcatcat",(18,"barcatcatcatcat"))
18:56:05 <SubStack> but now and then, super useful
18:56:11 <FunctorSalad_> wtf
18:56:17 <jmcarthur> lol
18:56:23 <copumpkin> lol
18:56:57 <FunctorSalad_> I forgot that it descends into chars, but still?
18:57:04 <copumpkin> > everywhere (mkT (*2) `extT` (++"tactical long")) ("cat", (9, "dog"))
18:57:05 <lambdabot>   ("cattactical longtactical longtactical longtactical long",(18,"dogtactical...
18:57:14 <FunctorSalad_> =)
18:58:16 <largos> :t extT
18:58:17 <lambdabot> forall a b. (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
18:59:19 <FunctorSalad_> extT adds handling for another type to a generic query
18:59:26 <FunctorSalad_> s/query/transformation/
18:59:37 <FunctorSalad_> (the Q stuff is for queries)
19:00:00 <copumpkin> fancy shit
19:00:11 <ray> drongnotcatcatcatcat
19:00:16 <FunctorSalad_> lol
19:01:37 * copumpkin intends to beat an explanation of that out of ray if he ever meets him
19:02:07 <FunctorSalad_> > everything (mkQ 1 (+) `extQ` length) (((),"foo"),((),"bar"))
19:02:08 <lambdabot>   Couldn't match expected type `b -> b'
19:02:08 <lambdabot>         against inferred type `GHC.Ty...
19:02:14 <FunctorSalad_> @type mkQ
19:02:15 <lambdabot> forall r b a. (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
19:02:21 <largos> I'm having a hell of a time googling for that.   does anyone have a link to the source / docs for those generic functions?
19:02:29 <FunctorSalad_> @hackage syb
19:02:29 <lambdabot> http://hackage.haskell.org/package/syb
19:02:32 <FunctorSalad_> @largos
19:02:37 <largos> thanks!
19:02:58 <FunctorSalad_> @type everything
19:02:58 <lambdabot> forall r a. (Data a) => (r -> r -> r) -> GenericQ r -> a -> r
19:03:11 <FunctorSalad_> > everything (+) (mkQ 1 length) (((),"foo"),((),"bar"))
19:03:12 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:03:12 <lambdabot>    `Data.Typeable.Typeable a...
19:03:41 <BMeph> @hoogle something
19:03:41 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
19:03:49 <BMeph> Heh-heh. :)
19:03:49 <FunctorSalad_> hmm
19:04:03 <copumpkin> something = id!
19:04:04 <copumpkin> zomg
19:04:18 <FunctorSalad_> was that coincidence BMeph?
19:04:34 <ray> copumpkin: http://drong.notacat.org/
19:04:36 <FunctorSalad_> > everything (+) (mkQ (1::Int) length) (((),"foo"),((),"bar"))
19:04:37 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:04:37 <lambdabot>    `Data.Typeable.Typeable a...
19:04:46 <copumpkin> ray: I've seen that :P
19:04:50 <copumpkin> ray: can't say it helped
19:04:54 <FunctorSalad_> anyone spot the error?
19:05:07 <FunctorSalad_> @type everything (+) (mkQ (1::Int) length)
19:05:08 <lambdabot>     Ambiguous type variable `a' in the constraint:
19:05:08 <lambdabot>       `Typeable a' arising from a use of `mkQ' at <interactive>:1:16-34
19:05:08 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
19:05:34 <FunctorSalad_> @type everything (+) (mkQ 1 (length::String -> Int))
19:05:35 <lambdabot> forall a. (Data a) => a -> Int
19:05:41 <FunctorSalad_> ah, the length was too polymorphic
19:06:20 <copumpkin> drong is clearly a cartesian closed category
19:06:25 <FunctorSalad_> so this will add the length for every String node in the ADT, and 1 for every other node
19:06:52 <FunctorSalad_> > everything (+) (mkQ 1 (length::String -> Int)) ("foo","barr")
19:06:53 <lambdabot>   24
19:07:05 <FunctorSalad_> hmm.
19:08:00 <FunctorSalad_> > everything (+) (mkQ 1 (length::String -> Int)) []
19:08:01 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:08:01 <lambdabot>    `Data.Data.Data a'
19:08:01 <lambdabot>      a...
19:12:15 <amuck> Does ghc 6.10.4 on Solaris support the threaded runtime?
19:12:50 <dons> Saizan: that's right
19:16:06 <FunctorSalad_> (aha! it recurses into the Strings and uses the "String" case for every tail)
19:17:45 <mmorrow> , everywhere (mkT (*2)) ((1,(2,3)),((4,5),6))
19:17:45 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:17:46 <lunabot>  ((2,(4,6)),((8,10),12))
19:18:35 <mmorrow> copumpkin: totally, that's the first thing i want to try with it (IntMap optim benchmark)
19:18:44 <copumpkin> :)
19:19:28 <FunctorSalad_> with drong?
19:20:07 <mmorrow> preflex: seen ddarius
19:20:07 <preflex>  ddarius was last seen on #haskell 3 hours, 30 minutes and 17 seconds ago, saying: cat
19:20:18 <copumpkin> oh, he was talking about drong
19:20:39 <mmorrow> ddarius: did you ever get that @tell with the epic cfg for rfft?
19:21:11 <mmorrow> copumpkin: http://moonpatio.com/images/rfft.png :o
19:21:27 <copumpkin> wut dat
19:21:38 <copumpkin> vacuum on program structure? :o
19:21:49 <dons> mmorrow: you working on IntMap?
19:21:54 <mmorrow> copumpkin: the flowgraph for this rfft function http://moonpatio.com/repos/MISC/fft-misc/rsplitfft.c
19:22:12 <Zeiris> recursive fast fourier transform?
19:22:36 <copumpkin> real
19:22:53 <mmorrow> dons: i wanted to see what impact this mod (unfortunately had to make it at the asm-level) would have on IntMap perf http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3878
19:25:23 <dons> cool.
19:25:32 <dons> i think there's a lot to be gained via structure specialization too
19:26:05 <mmorrow> dons: totally
19:26:53 <copumpkin> mmorrow: that rfft code is really ugly :P
19:27:05 <mmorrow> copumpkin: haha
19:27:37 <mmorrow> copumpkin: but the flowgraph is really pretty
19:27:41 <copumpkin> yep
19:28:34 <mmorrow> the parallelizable loops between .L19 and .L18 are neat too
19:29:12 <mmorrow> (and this was the gcc asm output, a leeter compiler could probably do various interesting loop transforms)
19:29:55 <ddarius> mmorrow: Yes, but I have no idea why.
19:30:46 <mmorrow> ddarius: as an example of what haskell code is missing by not having explicit asm-level loops
19:31:57 <dons> benchmarks ? ...
19:32:47 <Fragsworth> Is there a haskell package index? Something you can install remote packages with in the command line?
19:33:06 <dobblego> Fragsworth, cabal
19:33:08 <sjanssen> Fragsworth: yes, hackage.haskell.org.  Check out cabal-install
19:33:29 <Fragsworth> excellent
19:33:29 <Fragsworth> thanks
19:34:53 <dons> its part of the haskell platform.
19:34:59 <dons> so if you install that, you will have it already
19:35:30 <dons> http://haskell.org/platform
19:37:05 <blackdog> dons: did you bootleg bos's benchmark lib? :)
19:37:26 <blackdog> home taping kills music, you know.
19:38:03 <dons> nah, he put a repo up
19:38:11 <blackdog> url?
19:38:24 <dons> chttp://darcs.serpentine.com/criterion
19:38:30 <blackdog> i want to throw away my horrible benchmarks for perfecthash
19:38:32 <blackdog> beaut.
19:38:34 <dons> mwhahaha http://twitter.com/wmacgyver/statuses/4406352175
19:38:53 <copumpkin> yay twitter
19:39:08 * dons watches the memes infect
19:40:53 <copumpkin> slava on the offensive!
19:41:22 <ray> don't forget the #drongisnotacat hashtag
19:41:48 <copumpkin> not sure my followers care that drong is not a cat
19:41:58 <dons> slava's our brother in arms.
19:41:59 <copumpkin> but maybe I should try and see
19:42:03 <SamB_XP_> http://naesten.blogspot.com/2009/09/cant-haskell.html
19:42:12 <SamB_XP_> I made you a meme, but I accidentally it
19:43:06 <olsner> you WHAT the meme!?
19:43:14 <SamB_XP_> I did!
19:43:52 <copumpkin> how is meme formed?
19:43:56 <copumpkin> how is meme formed
19:44:09 <copumpkin> how accidentally it
19:44:21 <Zeiris> Lambdacats :3
19:44:45 <SamB_XP_> well, I could send you over to precocious.com and suggest you ask Dr. Oven ...
19:45:31 <hackagebot> dbus-core 0.1 - DBus protocol (JohnMillikin)
19:45:53 <SamB_XP_> oh noes!!!!!
19:46:19 <sshc> how do I add 24 to a Char?
19:46:34 <Berengal> sshc, how does that make sense?
19:46:47 <sshc> Berengal: the 24th character after a char
19:46:53 <dibblego> same way you find the melting point of the number 7
19:47:04 <Fragsworth> it makes sense in ASCII
19:47:12 <sshc> yes
19:47:33 <sshc> you would use the '+' operator in C
19:47:41 <sshc> for example, 'a' + 24
19:47:43 <wdonnelly> > chr . (+24) . ord $ 'c'
19:47:44 <lambdabot>   '{'
19:47:58 <Berengal> sshc, depends on the ordering of the chars... assuming ascii, chr . (+24) . ord, or foldl' (.) id (replicate 24 succ)
19:48:20 <olsner> sshc: well, you would use the + operator and a couple of implicit casts between characters and integers
19:48:33 <ray> i'll foldl' (.) id (replicate 24 YOU)
19:48:52 * Berengal isn't actually sure if that last one works
19:49:03 <Berengal> > foldl' (.) id (replicate 24 succ) 'a'
19:49:04 <lambdabot>   'y'
19:49:09 <Sgeo> Anyone have any experience with J?
19:49:12 <ray> of course it works
19:49:14 <ray> this is haskell
19:49:47 <Makoryu> Sgeo: Uuuggghhhh.
19:50:02 <Makoryu> Sgeo: This bears repeating... Uuuuggghhhhh.
19:50:10 <Sgeo> lol
19:50:17 <Makoryu> Sgeo: I'm still trying to figure out how they parse the damn thing
19:50:36 <Makoryu> It doesn't conform to any school of grammar design I've ever heard of
19:51:30 <Sgeo> I tried learning it, then stopped when I had more stuff to do. Thinking about it in terms of Haskell, its only advantage (verbs that apply to single values Just Work with lists) is not a significant one, and being explicit, like in Haskell, is saner
19:51:56 <Makoryu> Sgeo: That's not the only thing it does.
19:52:22 <Makoryu> Sgeo: It also has goofy stuff like implicit liftA2
19:52:47 * bos is writing documentation for ciriterion tonight
19:52:52 <Makoryu> For example, translating to Haskell, "sum / length" would mean "\xs -> sum xs / length xs"
19:52:57 <bos> dammit, can't spell my own library's name
19:53:05 <Makoryu> (With appropriate type conversions inserted)
19:53:30 <copumpkin> as soon as multiple versions of criterion are released, we can call them criteria!
19:53:38 <Makoryu> Sgeo: There are also a couple weirder ones that I don't understand
19:54:27 <Sgeo> Also, what is the deal with boxes? They're important for selecting from an array, and are also used for display?
19:54:51 <SamB_XP_> Sgeo: hmm ?
19:54:53 <Makoryu> Sgeo: Ah, they're like tuples in that each "slot" in a box can have a different type
19:55:05 <ray> that cool package on hackage has operators so you can do something like sum <[{/}]> length
19:55:10 <ray> for liftA2 (/) sum length
19:55:27 <Sgeo> But why are boxes conflated with display?
19:55:29 <SamB_XP_> Makoryu, Sgeo: what are you discussing ?
19:55:33 <Makoryu> Sgeo: Whereas a proper array must have uniform type
19:55:35 <Makoryu> SamB_XP_: J
19:55:44 <Makoryu> SamB_XP_: The APL derivative
19:55:46 <Sgeo> SamB_XP_, http://www.jsoftware.com/
19:55:48 <SamB_XP_> ah, yeah
19:55:50 <SamB_XP_> seen it
19:55:58 <SamB_XP_> didn't see where you mentioned it
19:55:58 <Makoryu> Sgeo: I don't know what you mean
19:56:24 <Sgeo> Meh, never mind. It just seems ugly to me
19:56:32 <aconbere> Anyone know how to do something like a "splitWhile"
19:57:01 <SamB_XP_> ... it could be much worse, J could use charcters not on your keyboard or in your fonts ;-P
19:57:14 <aconbere> I can see Edison has a splitWhile, I'm just not sure if that's something I should be using just to get at splitWhile :P
19:57:36 <Makoryu> aconbere: You mean like \f xs -> (dropWhile f xs, takeWhile f xs)?
19:57:44 <SamB_XP_> @hoogle splitWhile
19:57:44 <lambdabot> No results found
19:57:46 <SamB_XP_> @hoogle split
19:57:47 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
19:57:47 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
19:57:47 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
19:58:01 <jmcarthur> :t let for = flip liftM in \f -> join . for f . for
19:58:02 <lambdabot> forall (m :: * -> *) a1 r. (Monad m) => m (a1 -> r) -> m a1 -> m r
19:58:22 <Makoryu> @hoogle (a -> Bool) -> [a] -> ([a], [a])
19:58:22 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
19:58:22 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
19:58:22 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
19:58:22 <Sgeo> ...What are kinds doing in a type?
19:58:27 <jmcarthur> my cute definition for ap  ^_^
19:58:39 <aconbere> Makoryu: that's reasonable really
19:59:08 <olsner> seems it should be possible to construct an instance to implement (/) on functions as liftA2 (/) f g
19:59:28 <jmcarthur> olsner: yes :)
19:59:36 <Makoryu> olsner: It is, though it's not pretty.
19:59:50 <jmcarthur> olsner: the only problem is that you have to leave some things undefined to get the Num instance
19:59:56 * Sgeo doesn't understand liftA2
19:59:57 <Bruners> hi, anyone here that might have a nano syntax highlight for haskell ?
20:00:32 <jmcarthur> Sgeo: liftA2 is like fmap, but taking more than one argument for the function
20:00:53 <jmcarthur> > liftA2 (*) (Just 5) (Just 3)
20:00:53 <lambdabot>   Just 15
20:00:59 <SamB_XP_> :t liftA2
20:01:00 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
20:01:06 <SamB_XP_> :t liftA
20:01:07 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
20:01:11 <olsner> I would like to experiment with making all function applications implicitly lift, with appropriate instances for the type of "raw" functions
20:01:42 <Makoryu> olsner: Good luck with that. I'm not sure you can do it in Haskell's type system
20:01:50 <olsner> suspect it would leave a lot of insufficiently constrained types of expressions though
20:02:16 <Makoryu> olsner: I mean, you couldn't do it implicitly without first setting up miles and miles of type hackery
20:02:26 <Makoryu> And also annotating every function you wanted to use it with
20:02:31 <SamB_XP_> Makoryu: I think you need more than that
20:02:46 <SamB_XP_> I think you would need to redefine " "
20:03:04 <olsner> yes, basically I think you'd have to split up actual function application (on the "raw" function type) and syntactic function application (which would take any function-like thing)
20:04:02 <Makoryu> olsner: Wanna write a J interpreter? :p
20:04:05 <jmcarthur> olsner: step one: what would be the type of (.)?
20:04:17 <Fragsworth> .hiub vub;;''
20:04:20 <jmcarthur> have fun :)
20:04:25 <olsner> e.g. desugar expressions into (apply f x), then instance Function (a #-> b) where apply f x = f #$ x
20:04:58 <olsner> hmm, or perhaps I mean: instance (->) (#->)
20:07:35 <wdonnelly> the bigger issue, to my mind, is the 'Show' constraint on the 'Num' typeclass (why is it there?)
20:07:52 <Makoryu> wdonnelly: Apparently, nobody remembers
20:08:02 <copumpkin> wdonnelly: lack of foresight
20:08:04 * snetz slaps lambdabot around a bit with a large trout
20:08:33 <Makoryu> wdonnelly: Though, mauke's implementation of the wacky Num instance just looked like: show _ = error "whoops"
20:08:57 <SamB_XP_> Makoryu: but show isn't part of Num!
20:09:01 <wdonnelly> for that matter, why is there an 'Eq' constraint on it?
20:09:15 <wdonnelly> none of the functions seem to need one
20:09:16 <jmcarthur> for pattern matching on numeric literals, i think
20:09:32 <FunctorSalad_> n+k lolpatterns
20:09:33 <Makoryu> SamB_XP_: I mean, the Show instance *supporting* his wacky Num instance. I implicitly lifted over a typeclass dependency ;)
20:09:52 <copumpkin> wdonnelly: same answer as above, I think :)
20:10:09 <copumpkin> wdonnelly: I don't think anyone really likes the Num typeclass (or some of the related ones)
20:10:17 <SamB_XP_> Makoryu: hey, I've had to implement "2" like that ;-)
20:10:27 <jmcarthur> i'm not famous for hating it, but i should be
20:10:31 <jmcarthur> ;)
20:10:31 <Axman6> could someone paste a lambda symbol for me? i'm failing at finding it in my character viewer (the lambda it finds has a line through the head bar >_<)
20:10:37 <jmcarthur> because i hate it A LOT
20:10:45 <copumpkin> Axman6: Î»
20:10:51 <Axman6> thanks copumpkin
20:10:52 <jmcarthur> \
20:10:55 <copumpkin> :)
20:11:03 <SamB_XP_> Axman6: it's called lamda, I think
20:11:16 * copumpkin happened to be working in agda-mode when you asked that :D
20:11:21 <Sgeo> You mean \ isn't a lambda character? *gasp*
20:11:24 <FunctorSalad_> M-x ucs-insert SMALL GREEK LETTER LAMBDA
20:11:27 <Sgeo> Haskell LIED to me!
20:11:35 <FunctorSalad_> comfy isn't it?
20:11:36 <copumpkin> \lambda
20:11:49 <SamB_XP_> FunctorSalad_: you must have cheated
20:11:49 <jmcarthur> Sgeo: the \x -> notation isn't lambda calculus notation, either
20:11:55 * Sgeo was joking
20:12:09 <Sgeo> Î». x
20:12:26 <SamB_XP_> copumpkin: you ... er, seem to have forgotten to switch input methods
20:12:31 <copumpkin> :)
20:12:38 <FunctorSalad_> to protect emacs, I think it's pretty cool how * works with tab-completion
20:12:54 <FunctorSalad_> SamB_XP_: yeah, GREEK and SMALL should be transposed
20:13:16 <SamB_XP_> FunctorSalad_: I meant, the LAMBDA part -- how the heck did that work ?
20:14:00 <FunctorSalad_> SamB_XP_: what? why wouldn't it
20:14:06 <wdonnelly> hmm, with the exception of those typeclass constraints, making functions into num and fractional instances actually works surprisingly well
20:14:09 <wdonnelly> haskell++
20:14:17 <SamB_XP_> FunctorSalad_: 'cause the unicoders are crazy!
20:14:32 <Sgeo> wdonnelly, I was just thinking of doing exactly that (haskell++) to see what the reaction would be
20:14:49 <olsner> @karma haskell
20:14:50 <lambdabot> haskell has a karma of 50
20:15:03 <wdonnelly> that's...surprisingly low, considering
20:15:23 <Sgeo> Who'd do an obvious update operation on something that's suppose to have no mutable variables?
20:15:26 <Gracenotes> lambdabot's karma system is weird. you have to explicitly call it
20:15:42 <Gracenotes> the syntax isn't so memorable either..
20:15:43 <olsner> every line in #haskell should be an implicit karma-up for haskell
20:15:44 <Gracenotes> preflex: karma haskell
20:15:44 <preflex>  haskell: 9
20:15:54 <Gracenotes> :x that's not so super either
20:16:05 <Sgeo> C++--
20:16:13 <Sgeo> What does that do, if anything?
20:16:41 <olsner> Gracenotes: haskell++ should increase the karma for haskell? that's not very hard to remember?
20:16:43 <Gracenotes> I think it parses it greedily
20:17:02 <jmcarthur> @karma C++
20:17:03 <lambdabot> C++ has a karma of -4
20:17:03 <olsner> @karma haskell
20:17:03 <lambdabot> haskell has a karma of 51
20:17:08 <jmcarthur> @karma C
20:17:08 <lambdabot> C has a karma of 1
20:17:10 <Gracenotes> olsner: lambdabot doesn't do it though
20:17:11 <jmcarthur> C++--
20:17:13 <jmcarthur> @karma C
20:17:13 <lambdabot> C has a karma of 1
20:17:17 <jmcarthur> @karma C++
20:17:17 <lambdabot> C++ has a karma of -5
20:17:21 <Badger> c--
20:17:23 <olsner> Gracenotes: it did just now?
20:17:37 <jmcarthur> @karma C--
20:17:37 <lambdabot> C-- has a karma of 4
20:17:46 <Badger> heh
20:17:50 <Badger> c----
20:17:53 <Gracenotes> ...this must be recent
20:18:03 * Sgeo was just looking at C--
20:18:22 <olsner> hmm, I'm pretty sure that one is an ancient feature
20:18:33 <SamB_XP_> @karma C
20:18:33 <lambdabot> C has a karma of 1
20:18:40 <Gracenotes> preflex: karma c
20:18:40 <preflex>  c: 39754
20:18:43 <SamB_XP_> oh, I guess C's karma can't go down
20:18:59 <SamB_XP_> does preflex use Int16 for karma, or just let C's karma go up?
20:19:07 <SamB_XP_> hmm, how *did* C's karma get to be 1?
20:19:31 <jmcarthur> C++
20:19:31 <Sgeo> SamB_XP_, someone said C++ by itself, maybe as an answer to a question?
20:19:33 <jmcarthur> @karma C
20:19:33 <lambdabot> C has a karma of 1
20:19:39 <Sgeo> ..?
20:19:43 <SamB_XP_> C++
20:19:44 <SamB_XP_> @karma
20:19:44 <lambdabot> You have a karma of 0
20:19:46 <SamB_XP_> @karma C
20:19:47 <lambdabot> C has a karma of 1
20:19:51 <SamB_XP_> it doesn't do anything
20:19:55 <Sgeo> SamB_XP_++
20:20:00 <Sgeo> @karma SamB_XP_
20:20:00 <lambdabot> SamB_XP_ has a karma of 1
20:20:03 <olsner> hmm, I think there's a minimum length
20:20:05 <Gracenotes> said so :x
20:20:15 <Gracenotes> zomgz caveat :????
20:20:42 <Makoryu> c ++
20:20:45 <Makoryu> @karma c
20:20:45 <lambdabot> c has a karma of 1
20:20:52 <malouin> :t join
20:20:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:20:58 <Makoryu> @help karma
20:20:58 <lambdabot> karma <polynick>. Return a person's karma value
20:21:24 <olsner> I don't really see why anyone bothered adding a minimum length for that - what's the problem with karming single-char names anyway?
20:21:39 <jmcarthur> karming
20:21:40 <olsner> @karma- c
20:21:40 <lambdabot> c's karma lowered to 0.
20:21:55 <Sgeo> @karma- J
20:21:55 <lambdabot> J's karma lowered to -1.
20:22:11 <jmcarthur> @karma+ J
20:22:11 <lambdabot> J's karma raised to 0.
20:22:21 <Sgeo> jmcarthur, you like J?
20:22:31 <jmcarthur> eh, it's not bad
20:22:36 <jmcarthur> i was just taking @karma+
20:22:38 <jmcarthur> *testing
20:22:45 <Gracenotes> badNicks    = ["", "C", "c"] -- Special cases.  Ignore the null nick.  C must also be ignored because C++ and C-- are languages.
20:22:47 <Gracenotes> badPrefixes = ["$", "@", "%"] -- More special cases, to ignore Perl code.
20:22:48 <Makoryu> It's not so much wrong or evil as just vastly alien
20:23:09 <Makoryu> J, I mean
20:23:21 <Makoryu> Though the interpreter could be a bit nicer.
20:23:33 <jmcarthur> J is the regular expression of point free programming
20:23:36 <Makoryu> Like, it could give error messages that are more helpful than "GAG ME WITH A SPOON"
20:24:49 <olsner> Makoryu: reminds me of the classic prolog error message: "No."
20:25:09 <Gracenotes> olsner: so it does have special cases. the basic operation is to 'words' everything, and count it if it ends in -- or ++ and not a bad nick. And it has been in the source code for a while :o
20:25:19 <jmcarthur> that's not an error message, is it?
20:25:21 <Sgeo> olsner, how is that an error? Isn't that a result?
20:25:46 <olsner> well, not if you were expecting a positive result
20:26:01 <jmcarthur> i'd say it is no more an error message than an empty list would be in haskell
20:26:09 <Makoryu> olsner: Every Prolog interpreter I've seen will explain any syntax errors you've made :p
20:26:31 <Makoryu> Also, I always had more trouble with infinitely deep searches than with false results
20:26:50 <jmcarthur> > [x+y | x <- [1..], y <- []] -- ERROR!?
20:26:54 <lambdabot>   mueval-core: Time limit exceeded
20:27:03 <olsner> indeed :P
20:27:04 <jmcarthur> *sigh*
20:27:16 <jmcarthur> > [x+y | x <- [], y <- [1..]] -- ERROR!?
20:27:16 <lambdabot>   []
20:28:07 <jmcarthur> apparently i have more trouble with infinitely deep searches, too
20:28:18 <Gracenotes> ?- mostAwesomeChannel(freenode, X)
20:28:18 <lambdabot> Maybe you meant: . ? @ v
20:28:22 <FunctorSalad_> @hoogle runOmega
20:28:22 <lambdabot> No results found
20:28:23 <Gracenotes> X = haskell ;
20:28:25 <Gracenotes> No.
20:28:25 <FunctorSalad_> :P
20:28:35 <FunctorSalad_> Omega monad will search fairly
20:28:58 <Gracenotes> lunabot has it
20:30:11 <Gracenotes> , runOmega $ liftM2 (,) [1..] [1..]
20:30:12 <lunabot>  luna: Couldn't match expected type `Control.Monad.Omega.Omega a1'
20:30:17 <Gracenotes> D:
20:30:54 <Gracenotes> , runOmega $ liftM2 (,) (each [1..]) (each [1..])
20:30:55 <lunabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),...
20:31:14 <Gracenotes> hm... *watches more lectures*
20:31:39 <nyingen> what is lunabot?
20:36:25 <Makoryu> nyingen: Lambdabot's bizarro evil twin from a mirror universe down the street from the sound stage where they used to make "Sliders."
20:37:34 <SubStack> good old American scifi... made in Canada
20:37:36 <bos> @seen dons
20:37:36 <lambdabot> Unknown command, try @list
20:37:39 <bos> wtf.
20:37:48 <nyingen> sliders, eh?
20:38:09 <BMeph> I prefer K to J. :)
20:38:21 <SubStack> the episodes with snow on the ground are especially silly since it's supposed to be set in san fran
20:38:58 <Makoryu> SubStack: There was some hand-wavey thing about how the portal generator had a blast radius or something
20:39:15 <SubStack> awesome
20:39:44 <Makoryu> So they could wind up 400 miles north of SF, or (much more likely, since they eventually started filming in LA) 400 miles south
20:40:13 <Makoryu> I guess nobody ever asked why they wouldn't go 400 miles west and be forced to tread water for 36 hours
20:40:21 <copumpkin> bos: @seen was removed from lambdabot for being useless, but preflex: seen works
20:40:33 <bos> copumpkin: ok, thanks
20:40:41 <SamB_XP_> Makoryu: I guess the thingy was nice like that
20:40:57 <SubStack> obviously it only works parallel to lines of longitude
20:41:02 <SamB_XP_> Makoryu: and tried to avoid dropping them anywhere where they'd necessarily drown
20:41:10 <SubStack> on account of the inductive properties of the Earth's core
20:41:20 <SamB_XP_> SubStack: that makes no sense, on account of the way the earth is always spinning ...
20:41:41 <SamB_XP_> ... but at least it wouldn't dump them in the wrong part of earth's orbit ;-)
20:41:46 <Makoryu> SubStack: I'd sooner say it's because they reversed the polarity of the neutron flow :p
20:42:20 <SubStack> or maybe the shift could only occur normal to the initial sliding vector
20:42:20 * Sgeo is going to try implementing some of his C++ homework in Haskell
20:42:35 <medfly> I think you should just settle on realising that shows aren't meant to be totally realistic and have flaws like that
20:43:24 <SamB_XP_> oh, that reminds me of the bestest time travel book ever
20:43:30 <SamB_XP_> To Say Nothing of the Dog
20:44:03 <Makoryu> medfly: The MST3K mantra ;)
20:44:26 <Makoryu> medfly: Of course, Sliders had completely different flaws, such as the horrendous writing
20:44:33 <SamB_XP_> http://www.amazon.com/Say-Nothing-Dog-Connie-Willis/dp/0553575384
20:44:56 <Makoryu> "Talk about... What do you call it? Slipping? Swinging?.... Talk about sliding into the wrong place at the wrong time."
20:45:02 <SamB_XP_> this is the only fun time travel story I know that actually makes sense!
20:45:08 <SamB_XP_> I mean, it's believable!
20:45:21 <SamB_XP_> how crazy is that?
20:46:29 * SamB_XP_ only saw the sneek peaks for sliders, mostly ... he was pretty young when that was on ...
20:46:31 <SubStack> it is adequately crazy
20:46:39 <FunctorSalad_> the universe is 4-dimensional and immutable, problem solved (yes barring new theories or whatever)
20:46:59 <SamB_XP_> FunctorSalad_: that doesn't make To Say Nothing of the Dog impossible in any way ;-)
20:47:28 <FunctorSalad_> SamB_XP_: does it have this self-causing book like in the wikipedia example?
20:47:57 <FunctorSalad_> (or something like that :))
20:48:04 <SamB_XP_> FunctorSalad_: maybe!
20:48:09 <SamB_XP_> I'm not going to spoil the story
20:48:17 <SamB_XP_> and don't dare read the wikipedia page on it!
20:48:23 <SamB_XP_> read the *book*
20:48:24 <FunctorSalad_> D:
20:50:37 <jmcarthur> HireMe? not playing it subtle, i see
20:50:46 <jmcarthur> ;)
20:52:32 <copumpkin> you only just noticed?
20:53:25 <jmcarthur> i don't pay attention to nicks very often, especially if it's somebody that doesn't normally talk much
21:01:42 <bos> it makes me so sad that we don't have an agreed-upon first class label system.
21:02:00 <bos> instead, we have 2 or 3 that only a handful of people use, and they're all incompatible.
21:02:25 <ivanm> bos: couldn't you have planned what code to use for samples before you gave your statistical benchmarking talk at the HIW? :p
21:02:31 * ivanm is watching it now
21:02:40 <bos> ivanm: huh?
21:03:13 <ivanm> you kept getting your function names, type sigs, etc. mixed up when entering them into the ghci prompt
21:03:25 <bos> ivanm: i got that code working for the first time 45 minutes before demoing it.
21:03:43 <bos> i was making it up as i went.
21:03:47 <ivanm> ahhhh
21:03:53 <bos> so, no, i could not have planned it any more than i did.
21:04:00 <bos> think of it as livecoding.
21:04:09 <ivanm> is that your statistics package, or the as-yet-unreleased benchmarking package?
21:04:10 <ivanm> heh
21:04:12 <bos> both.
21:04:17 <ivanm> *nod*
21:04:23 <ivanm> what are you using for the graphs? gnuplot?
21:04:30 <bos> the benchmarking code uses the stats code for the heavy lifting.
21:04:37 <bos> not gnuplot, native haskell code.
21:04:52 <ivanm> oh? you wrote your own plotting code?
21:04:56 <ivanm> or is that the charts library?
21:05:19 <bos> it's tim's Chart library, yes.
21:05:39 <ivanm> from the video, it looked more like gnuplot, that's all
21:06:22 <ivanm> I take it dons was testing criterion for you with his judy benchmarks?
21:06:30 <bos> yes.
21:29:05 <jekor> I'm going through Monad Transformers Step by Step and it claims that Map.lookup "is defined to work within any monad by simply calling the monad's fail function". I see it defined in terms of Maybe, and I'm guessing that fail is looked down on now.
21:29:27 <jekor> Is that right? And if so, is there a way to lift it into another monad (Identity in this case) nicely?
21:30:28 <BMeph> jekor: 'fail' has always been looked down on. It was decided recently, though, to change the API for lookup, since it's generally always used in a way compatible to Maybe.
21:30:38 <bd_> jekor: a good MonadPlus should map fail to mzero. Anything else, either match the result of Lookup against a Maybe, or assume it'll never fail
21:30:50 <ivanm> BMeph: that was the only change between containers-0.1 and 0.2, wasn't it?
21:31:10 <jekor> Thanks.
21:32:36 <BMeph> ivanm: I have no idea. I just stumbled on the discussion on -cafe one day. :)
21:32:44 <jekor> So, just to be sure on this. The non-monadic version was fromJust $ Map.lookup n env. Is the simplest monadic version return $ fromJust $ Map.lookup n env or is there some magic I don't know of?
21:32:53 <ivanm> BMeph: heh
21:33:10 <ivanm> jekor: ummm, no
21:33:21 <ivanm> fromJust would throw an error rather than fail
21:33:43 <ivanm> try this if you want a generic monadic one: maybe (fail "foo") return $ Map.lookup n env
21:33:55 <ivanm> @type maybe (fail "foo") return $ Map.lookup n env
21:33:56 <lambdabot> Couldn't find qualified module.
21:34:01 <ivanm> @type maybe (fail "foo") return $ Data.Map.lookup n env
21:34:02 <lambdabot> Not in scope: `env'
21:34:06 <jekor> Ah, OK. There would be no way to trap the error otherwise with the fromJust then?
21:34:08 <ivanm> @type \n env -> maybe (fail "foo") return $ Data.Map.lookup n env
21:34:09 <lambdabot> forall (m :: * -> *) a k. (Monad m, Ord k) => k -> M.Map k a -> m a
21:34:13 <ivanm> jekor: you can in IO
21:34:16 <ivanm> that's it
21:34:34 <jekor> OK, that really helps. Thanks.
21:34:58 <ivanm> no problems ;-)
21:42:01 <BMeph> jekor: You might consider leaving it in Maybe, and just check for Nothing, instead of forcing the issue with 'fromJust', and trapping what error might show up. :)
21:42:56 <jekor> Good call. I think I'd do that normally, but I'll continue with the error method as this tutorial seems to make use of it.
21:43:51 <copumpkin> or just write toFailOrNotToFailThatIsTheQuestion : (Monad m) => Maybe a -> m a; toFailOrNotToFailThatIsTheQuestion = maybe (fail "dayum") return
21:46:30 <ivanm> copumpkin: heh
21:50:02 <Gracenotes> i has found u a wittle fixpoint: 'Nothing'
21:51:45 <monochrom> toHaltOrNotToHaltThatIsTheDecisionProblem
21:52:22 <monochrom> Wouldn't it be nice if Turing opened his paper with that sentence. :)
21:52:30 <ivanm> what sentence?
21:52:39 <ivanm> there's no sentence there...
21:52:47 <monochrom> "to halt or not to halt, that is the decision problem" :)
21:52:50 <ivanm> just a long camelCased phrase
21:53:05 <copumpkin> there is something isomorphic to a sentence there
21:53:05 <Gracenotes> you might right a decidable unCamel function yourself to decipher it!
21:53:05 <ivanm> s/t/T/, s/^/./
21:53:09 <Gracenotes> *write
21:53:17 <ivanm> copumpkin: punctuation makes it non-isomorphic
21:53:27 <copumpkin> and maybe acronyms
21:53:34 <Gracenotes> isomorphic modulo punctuation!
21:53:36 <ivanm> no acronyms in there
21:53:41 <copumpkin> just sayin'
21:53:44 <ivanm> Gracenotes: heh
21:53:52 <Gracenotes> "up to", as real category theorists say. allegedly.
21:54:05 <monochrom> ivnam is just being strongly typed.
21:54:47 <monochrom> "Reader Int Bool is not Int -> Bool!"
21:55:39 <BMeph> Some things are "just like" others, as long as "just like" is not exactly "just like" itself. Your Modulo May Vary. ;)
22:00:00 <ivanm> monochrom: heh
22:00:20 <ivanm> BMeph: is that the standard comparison disclaimer?
22:01:45 <BMeph> ivanm: It is for me. :)
22:11:21 <rgr> Any emacs users here : did you need to do anything special to have haskell-mode indent properly? In my setup each successive line is one tab spacing further to the right.
22:11:50 <largos> rgr: if you keep hitting tab, does it cycle through other options?
22:12:18 <largos> I think I generally hit tab twice to get to the same indent as the previous line
22:12:27 <rgr> yes
22:12:45 <rgr> but trying "hilite all" and then indent really screws up the buffer
22:13:03 <largos> ah... haven't tried that
22:14:22 <rgr> but hitting tab twice seems to work. yuck.
22:30:01 <Zeiris> Are there some existing libraries for making asynchronous processes that change state on events?
22:30:54 <largos> hrm...  I wonder if I need generic haskell.
22:31:02 <lispy|web> largos: hi
22:31:17 <hackagebot> dbus-core 0.2 - Low-level DBus protocol implementation (JohnMillikin)
22:31:29 <largos> I want to create a tree where each node has a (potentially) different type, and a transform that maps to and from the parent type...
22:31:35 <largos> lispy|web: hey, how's it going?
22:31:58 <lispy|web> largos: not bad.  I had to miss hacPDX today, but I should be there tomorrow
22:32:08 <largos> ah, sucks to missing it :(
22:32:23 <largos> where's it at?
22:32:32 <lispy|web> PSU
22:32:42 <largos> ah, cool
22:32:49 <lispy|web> what do you need generic haskell for?
22:32:59 <largos> lispy|web: version spaces...
22:33:31 <largos> lispy|web: I'm playing with different type deffinitions for a haskell implementation again
22:34:00 <largos> and I'm running into problems... sec. I'll hpaste some
22:34:22 <lispy|web> ?users
22:34:22 <lambdabot> Unknown command, try @list
22:34:29 <lispy|web> oh silly lambdabot
22:34:37 <lispy|web> ?vixen where have all your commands gone?
22:34:38 <lambdabot> whoa whoa whoa, one question at a time!
22:34:47 <largos> is lambdabot running on your linode?
22:34:53 <lispy|web> aye
22:35:04 <lispy|web> I think Cale needs some things off olive still
22:35:30 <lispy|web> I'm installing lambdabot locally though so I can use GOA
22:35:57 <lispy|web> http://chrisdone.com/blog/html/2008-08-01-ghci-on-acid.html
22:36:07 <largos> GOA?
22:36:14 <FunctorSalad_> ghci on acid
22:36:58 <largos> ah
22:37:08 <lispy|web> it integrates lambdabot features with ghci
22:37:17 <lispy|web> so you can call hoogle from ghci, for example
22:38:48 <largos> oh, awesome
22:38:52 <largos> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9884#a9884
22:39:14 <largos> hm... hpaste keeps removing whitespace from my posts
22:39:49 <largos> it's probably an opera thing....
22:40:05 <lispy|web> :t ***
22:40:05 <lambdabot> parse error on input `***'
22:40:11 <lispy|web> :t (***)
22:40:11 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:40:45 <FunctorSalad_> largos: you can take the type sig of your "join" and use that as a GADT constructor
22:41:13 <lispy|web> well, also his join looks like an arrow, (***) matches to me
22:41:42 <lispy|web> But, FunctorSalad_'s suggestion is probably more to the point
22:41:53 <lispy|web> largos: have you used GADTs at all?
22:42:22 <FunctorSalad_> largos: annotated the hpaste how it would look with a GADT
22:42:27 <largos> lispy|web: probably not -- I'm not sure... G___ algebraic data types?
22:42:36 <lispy|web> generalized
22:42:45 <Axman6> @src (***)
22:42:46 <lambdabot> f *** g = first f >>> second g
22:42:51 <Axman6> :t (>>>)
22:42:52 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
22:43:07 <FunctorSalad_> lispy|web: yes it looks like *** but who knows whether the type supports a composition ;)
22:43:09 <Axman6> @instances-importing Control.Category.Category
22:43:09 <lambdabot> (->), Kleisli m
22:43:42 <lispy|web> FunctorSalad_: good point.  I need to learn me some cat. theory for great good
22:43:50 <largos> me too...
22:44:07 <largos> so, can I patern match on that GADT Join?
22:44:08 * Axman6 plans too one day, but wouldn't do it without a course on it
22:44:59 <FunctorSalad_> largos: yes, each branch of the pattern match has extra knowledge what "i" and "o" must look like in that branch
22:45:24 <lispy|web> is there a comment character for use in ~/.ghci  ?  Perhaps -- ?
22:45:42 <Axman6> SamB_XP_: Re: lam(b)da symbol, you were right. how annoying >_<
22:45:58 <Axman6> lispy|web: works fine
22:46:07 <lispy|web> Axman6: cool
22:46:25 <largos> ok... I need to learn more about GADTs...
22:46:54 <Axman6> @src Maybe
22:46:54 <lambdabot> data Maybe a = Nothing | Just a
22:46:58 <Axman6> there's one
22:47:00 <lispy|web> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9886#a9886
22:47:15 <FunctorSalad_> largos: a hint: the "i" and "o" before the "where" don't have any meaning except for indicating the number of type params
22:47:16 <lispy|web> largos: they're pretty simple, but my thesis has an appendix with a quick intro :)
22:47:23 <lispy|web> </shameless-self-plug>
22:47:29 <largos> hehe
22:48:05 <lispy|web> I doubt you can find a copy at the moment though...
22:48:15 <largos> yeah... iirc, dagit.o was on olive
22:48:51 <Axman6> lispy|web: more people should self plug their thesis', else no one would read them :P
22:48:58 <lispy|web> largos: http://ir.library.oregonstate.edu/jspui/handle/1957/11180
22:49:11 <largos> whoa, the library has it up already? ;)
22:49:25 <lispy|web> largos: yeah, they've had it up since the day *I* uploaded it ;)
22:49:39 <largos> bah.
22:49:40 <lispy|web> largos: <g> makes me wonder why *they* don't have yours?
22:49:57 <largos> yeah yeah yeah
22:50:04 <lispy|web> I may not have written the submission system, but at least I used it :)
22:50:06 <largos> the grad school *said* they would upload it for me
22:50:11 <largos> haha
22:50:19 <largos> yeah, I'm never living that down <sigh>
22:50:35 <largos> fwiw, I really doubt you used the same system I wrote :)
22:53:14 <lispy|web> sweet, goa is active
22:53:28 <lispy|web> how do I get source to work?
22:54:06 <RTFMMao> Hell all, n00b question
22:54:39 <Axman6> hell all?
22:54:48 <LegendaryPenguin> watch ur language
22:54:59 <monochrom> I think it's typo for hello.
22:54:59 <lispy|web> largos: the bottom line with GADTs is that you replace the normal data constructor syntax with function syntax.  So, data Foo = F Int String, would become data Foo where F :: Int -> String -> Foo
22:55:05 <LegendaryPenguin> lol
22:55:22 <largos> lispy|web: yeah, this looks like it does exactly what I need...
22:55:46 <largos> I do have a suspicion that version spaces are closely related to Arrows though
22:55:58 <RTFMMao> Is there a concise syntax in haskell to make a copy of an object graph, one or more substitutions made?
22:56:08 <copumpkin> no
22:56:09 <lispy|web> largos: and for the subset of gadts that corresponds to adts it has exactly the same meaning.  In my example, if you use the classic defintion and type :t F, in ghci it would give you F :: Int -> String -> Foo
22:56:28 <RTFMMao> like, if I wanted to make a copy of foo, where foo.bar.baz = 2 instead of 1 as it currently is
22:56:31 <RTFMMao> is there a short way to write this?
22:56:46 <copumpkin> there's something called semantic editors
22:56:59 <copumpkin> and various related concepts like Data.Accessor
22:57:46 <lispy|web> largos: other ways of using GADTs allow you refine the type(s) that a type variable can take on in the various data constructors FunctorSalad_'s example does exactly this
22:58:14 <Axman6> RTFMMao: you can use records to do that
22:58:25 <Axman6> RTFMMao: data MyData a b c d = MyData { a :: a, b :: b, c :: c, d :: d}; foo = MyData 1 'a' 3 "hello"; bah = foo {a = [Nothing]}
22:58:31 <copumpkin> they don't allow easy nested record update though
22:58:45 <Axman6> ah, well, don't nest them then >_>
22:59:18 <psykotic> that's a big pain in the ass
22:59:41 <psykotic> even a little syntax sugar would be a blessing
22:59:48 <Axman6> yeah
22:59:59 <Axman6> no one's been able to figure out a nice syntax for it
23:00:07 <copumpkin> I hear Data.Accessor is quite nice, although not a syntax
23:00:10 <RTFMMao> Yeah I'm talkin about nesting
23:00:10 <Axman6> . is used more than enough already
23:00:25 <RTFMMao> That's the problem I'm having, I want to go, say, 6 fields deep or something
23:00:26 <psykotic> if we had a first-class theory of record labels
23:00:34 <psykotic> then it would be no problem
23:00:43 <psykotic> cf daan what's-his-face
23:01:01 <Axman6> RTFMMao: ... that's... probably indicative of some bad design
23:01:08 <Axman6> RTFMMao: care to give some examples?
23:01:45 <FunctorSalad_> RTFMMao: if you want to modify all occurences of a certain type in your tree, you can use syb
23:02:45 <Axman6> rawg, my ghc wasn't compiled with dph :(
23:03:36 <lispy|web> Axman6: it's really easy to build GHC these days
23:03:42 <psykotic> syb is so insanely overcomplex
23:03:44 <lispy|web> Axman6: compared to the hassle it used to be
23:03:47 <Axman6> lispy|web: yeah
23:03:59 <Axman6> maybe i will... is the 6.12 RC out yet?
23:04:04 <FunctorSalad_> @type gfoldl
23:04:05 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
23:04:05 <RTFMMao> Axman6:  I'm implementing an event-driven simulation, and using nested records for storing state
23:04:09 <lispy|web> Axman6: no idea :)
23:04:14 <FunctorSalad_> (for psykotic ;))
23:04:18 <Axman6> heh, ok
23:04:20 <RTFMMao> FunctorSalad_: alas, no, that's not what I'm doing.
23:04:21 <ivanm> lispy|web: I've never had a problem building GHC...
23:04:35 <lispy|web> ivanm: cool.  I have
23:04:36 <ivanm> {emerge,pmerge,paludis -i} dev-lang/ghc :p
23:04:41 <ivanm> works like a charm! :D
23:05:15 <ivanm> (OK, fine, I have to bootstrap it first since I've been building the x86 binaries lately, and then upload it, create manifests, etc. ... but still)
23:06:57 <lispy|web> does the student who made hp2any ever hang out in here?
23:07:01 <lispy|web> ?seen tibbe
23:07:01 <lambdabot> Unknown command, try @list
23:07:08 <lispy|web> ,seen tibbe
23:07:09 <lunabot>  luna: Not in scope: `seen'
23:07:28 <ivanm> lispy|web: what's hp2any?
23:07:32 <ivanm> preflex: seen tibbe
23:07:32 <preflex>  tibbe was last seen on #haskell 3 days, 20 hours, 59 minutes and 58 seconds ago, saying: ksf: have you had time to look at profiling output?
23:07:38 <Axman6> preflex: seen tibbe
23:07:38 <preflex>  tibbe was last seen on #haskell 3 days, 21 hours and 4 seconds ago, saying: ksf: have you had time to look at profiling output?
23:07:46 <ivanm> Axman6: hah, beat you! :p
23:08:21 <Axman6> yeah but my answer was shorted, and therefore more beautiful
23:08:22 <lispy|web> thanks
23:09:18 <ivanm> heh
23:20:07 <largos> @source (><)
23:20:07 <lambdabot> (><) not available
23:21:04 <largos> is anyone familiar with that function?
23:21:28 <dolio> It's from Data.Sequence, no?
23:21:40 <largos> Data.Graph.Inductive.Query.Monad is the one I found
23:21:51 <largos> I don't understand the source
23:21:53 <largos> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/Data-Graph-Inductive-Query-Monad.html#%3E%3C
23:22:35 <dolio> Oh.
23:22:46 <dolio> f >< g applies f to the left element of a pair, and g to the right element.
23:22:54 <Axman6> hmm, anyone know how to turn a PArray (from data paralle haskell) into a list>
23:22:56 <Axman6> ?*
23:22:56 <lambdabot> Maybe you meant: . ? @ v
23:24:19 <largos> dolio: ok, yeah... that is what I need. thanks! (now if I can get it to show up locally...)
23:32:38 <Fragsworth> I am new to Haskell, and I'm looking at how everything is lazily evaluated. Can lazy evaluation sometimes make it difficult to find the source of an error?
23:33:06 <largos> @source filter
23:33:06 <lambdabot> filter not available
23:33:39 <lispy|web> You don't want source
23:33:43 <lispy|web> ?src filter
23:33:44 <lambdabot> filter _ []     = []
23:33:44 <lambdabot> filter p (x:xs)
23:33:44 <lambdabot>     | p x       = x : filter p xs
23:33:44 <lambdabot>     | otherwise = filter p xs
23:34:00 <lispy|web> but more likely you want something else?
23:34:00 <Axman6> Fragsworth: it's possible. but i wouldn't say so
23:34:15 <largos> ah, thanks
23:34:27 <lispy|web> ?hoogle (i1 -> o1) -> (i2 -> o2) -> (i1, i2) -> (o1, o2)
23:34:27 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
23:34:54 <lispy|web> I think you meant (***) though
23:35:18 <lispy|web> > ((+1) *** (*2)) (1, 3)
23:35:19 <lambdabot>   (2,6)
23:35:28 <lispy|web> ?hoogle (***)
23:35:28 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
23:35:48 <largos> I'm not using Arrows (yet, anyway)
23:35:58 <lispy|web> That's fine because (->) is an arrow
23:36:02 <lispy|web> ?instances-importing Arrow
23:36:03 <lambdabot> (->), Kleisli m
23:36:08 <largos> huh
23:36:17 <copumpkin> largos: you can ignore the arrowness of it
23:36:24 <lispy|web> so in the type of (***) replace a with (->)
23:36:27 <copumpkin> :t (***) :: (i1 -> o1) -> (i2 -> o2) -> (i1, i2) -> (o1, o2)
23:36:28 <lambdabot> forall i1 o1 i2 o2. (i1 -> o1) -> (i2 -> o2) -> (i1, i2) -> (o1, o2)
23:36:46 <lispy|web> It's a shame hoogle doesn't look that far ahead
23:37:29 <Axman6> copumpkin: gross variable names
23:37:36 <copumpkin> I just copied lispy's ones
23:37:38 <copumpkin> :P
23:37:41 <largos> hehe
23:37:46 <largos> and lispy copied mine <sob>
23:37:47 * lispy|web blames largos :)
23:37:56 <Axman6> largos: gross
23:38:10 <largos> I have two inputs, two outputs
23:38:15 <lispy|web> largos: so does importing Control.Arrow ( (***) ) work for you?
23:38:59 <largos> sounds like it..
23:39:16 <lispy|web> You're using .cabal file, right?
23:39:32 <largos> lispy|web: not yet, I've just been hacking in an emacs buffer and :l'ing
23:39:42 <orbitz> when peopel talk about mutable arrays and mutable judy arrays in Haskell, it's still a safe mutability right? pretty close to 'pure' and 'side efect free'?
23:39:45 <largos> I didn't really expect to make much progress tonight ;)
23:40:02 <copumpkin> orbitz: I think the judy arrays are in IO
23:40:11 <copumpkin> it's safe
23:40:16 <copumpkin> but not pure
23:40:17 <lispy|web> the judy arrays could be made to be in ST though
23:40:25 <lispy|web> dons said that is planned on his blog
23:40:30 <copumpkin> ah, cool
23:40:57 <lispy|web> "Thereâ€™s no reason for it to be in IO. Iâ€™m using the IO as a base layer, but the plan is to add a freeze(), and an ST mode."  <-- from his blog
23:40:59 <periodic> Yeah, the IO-ness of the Judy arrays looked a bit annoying.
23:41:11 <periodic> I'd like to see lookups be pure though.
23:41:22 <orbitz> what is ST mode?
23:41:25 <copumpkin> well if he's putting it in ST with a freeze, there will be pure lookups :)
23:41:36 <copumpkin> orbitz: ST is a restricted IO that you can break out of
23:41:36 <periodic> True.
23:41:47 <orbitz> does it stand for anything?
23:41:50 <periodic> I was thinking short term, though I doubt I'll use them any time soon either. :D
23:41:51 <lispy|web> orbitz: ST is like IO but it just allows things like memory updates instead of all the various things IO allows
23:41:51 <Axman6> orbitz: ST monad
23:41:54 <copumpkin> orbitz: state thread, I believe
23:41:56 <Axman6> State Transformer
23:42:13 <Axman6> or, maybe State Thread
23:42:21 * copumpkin shrugs :)
23:42:49 <lispy|web> given the rank2 type, maybe it's Silly Typed?
23:42:51 <Axman6> orbitz: it's IO without all that actual IO, so mutable variables and arrays, but it's totally pure to the rest of the program
23:43:18 <orbitz> so once you exit ST everything is frozen?
23:43:29 <Axman6> yeah, sort of
23:43:30 <lispy|web> orbitz: so, it's type safe mutability, but other side-effects are not allowed
23:43:37 <Axman6> :t runSt
23:43:37 <lambdabot> Not in scope: `runSt'
23:43:39 <Axman6> :t runST
23:43:40 <lambdabot> forall a. (forall s. ST s a) -> a
23:43:57 <Axman6> @src ST
23:43:57 <lambdabot> newtype ST s a = ST (STRep s a)
23:44:00 <Axman6> bah
23:44:08 <lispy|web> ?src STRep
23:44:08 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
23:44:10 <Axman6> i've forgotten how to use ST -_-
23:44:20 <orbitz> i must say, RWH covers EVERYTHING
23:44:43 <orbitz> and so far everythign i'v elooked up seem sto be in sufficient detail to use it, and understand it well enough to look up
23:44:50 <Axman6> yeah i need to read more of my RWH
23:45:04 <ivanm> Axman6: you haven't finished it yet? :o
23:45:05 <orbitz> printing on the copy i have i sa bit shoddy unforunatley
23:45:16 <Axman6> i got bored
23:45:21 <ivanm> heh
23:45:23 <ivanm> slacker
23:45:30 <Axman6> i figure it's best to just read the chapters you're interested in
23:46:20 <lispy|web> Axman6: yeah, that's the way I've been reading it.  I just open it when there is something I want to read up on specifically, such as the section preformance tuning
23:46:31 <Axman6> yeah
23:46:40 <Axman6> i need to actually read that section
23:46:49 <Axman6> though, i'm not doing too badly without it :)
23:49:46 <largos> what is the syntax for multiple type constraints?
23:49:58 <ivanm> (Show a, Eq a) => ...
23:50:05 <largos> I'm drawing blanks...
23:50:07 <largos> thanks!
23:50:23 <ivanm> how do you draw a blank? isn't it be default _blank_, and thus nothing to actually draw? :p
23:50:30 <largos> hehe
23:50:32 <ivanm> s/be/by/
23:53:03 <Veinor> what function f satisfies f "foo" ["bar", "baz", "quuz"] = "barfoobazfooquuz"
23:53:34 <Veinor> basically, I want to join a bunch of strings with a separator
23:53:40 <hackagebot> tkhs 0.1.0.5 - Simple Presentation Utility (YusakuHashimoto)
23:53:40 <lispy|web> ?pl zipWith (***)
23:53:40 <lambdabot> zipWith (***)
23:53:45 <lispy|web> :t zipWith (***)
23:53:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => [a b c] -> [a b' c'] -> [a (b, b') (c, c')]
23:54:32 <Gracenotes> Veinor: intercalate?
23:54:39 <Gracenotes> from Data.List
23:54:54 <Veinor> there we go.
23:55:20 <Gracenotes> (no such inverse splitting function, exists.. there is a separate package for that :/)
23:56:23 <ivanm> the problem with the split package is that it's a PITA to have to install/use an extra package just for one function :s
23:57:50 <hackagebot> criterion 0.1 - Benchmarking, Performance, Testing (BryanOSullivan)
23:58:11 <Veinor> awesome, fizzbuzz is 380K of compiled source
23:58:23 <ivanm> bos: \o/
23:58:30 <Gracenotes> yeah. I almost wish it'd be possible to identify just one form of split to put in base, and leave the generic highly customizable splits in the split package
23:58:33 <ivanm> bos++
23:58:52 <Veinor> @hoogle a -> a
23:58:52 <lambdabot> Prelude id :: a -> a
23:58:52 <lambdabot> Data.Function id :: a -> a
23:58:52 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
23:59:11 <Gracenotes> the former part doesn't seem so likely, the bickering wouldn't end..
23:59:29 <Veinor> @pl putStr $ intercalate " " ( map fizzbuzz x)
23:59:29 <lambdabot> putStr (intercalate " " (map fizzbuzz x))
23:59:30 <ivanm> bos: so now you can go back to the actual code you were working on that you wanted the profiling package for? :p
23:59:46 <Veinor> @unpl putStr $ intercalate " " ( map fizzbuzz x)
23:59:46 <lambdabot> (putStr (intercalate " " (map fizzbuzz x)))
23:59:47 <bos> ivanm: more or less
23:59:54 <hackagebot> omnicodec 0.3 - data encoding and decoding command line utilities (MagnusTherning)
