00:02:08 <Zeiris> Ug. I'm having trouble thinking about any kind of top-level design in Haskell. I don't think I fully 'get' monads even thought I thought I did - what's a good, Haskellic OS project I can look at for an example?
00:04:35 <sereven> Zeiris: xmonad is an oft given example, but there are others in other domains. http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/01#xmonad_part1_model http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
00:04:49 <Zeiris> Awesome. Thank youu :)
00:05:10 <Zeiris> I like this language, I just wish there was a 'haskell for dummies' book out there.
00:05:25 <sereven> @where lyah
00:05:25 <lambdabot> www.learnyouahaskell.com
00:05:27 <Zeiris> (No offense to Real World Haskell, great beginner book too.)
00:06:14 <Zeiris> Well, lyah may be a leetle too simple. Or maybe the problem I'd like to tackle is too tough for a beginner :\
00:06:51 <sereven> Zeiris: yeah, there's a bit of a gap between those two, but you asked for haskell for dummies. :-)
00:09:06 <ivanm> Zeiris: I don't think RWH can be categorised as a beginner book...
00:12:21 <sereven> Zeiris: if you haven't seen them Typeclassopedia and All about Monads are good for that sort of macro view. "Design Patterns"
00:13:54 <Zeiris> Dumb question: can a function that doesn't use monads, call a function that makes a monad, does stuff with it, then gets a non-monadic value out of it?
00:14:30 <Beelsebob> ofc
00:14:39 <Beelsebob> but be aware, some monads don't have a function to get a non-monadic value back out
00:14:45 <Beelsebob> or at least not a safe one
00:15:15 <blackh> Zeiris: Generally yes - but not the IO monad.
00:15:27 <Zeiris> Stupid IO monad. They just threw it in there to confuse me, didn't they.
00:15:36 <dobblego> or [] or Maybe or ...
00:15:58 <Beelsebob> Zeiris: well, the point of the IO monad is to not let people get values out of it
00:16:10 <Beelsebob> if it did let people get values out, it wouldn't be referentially transparent
00:16:21 <ivanm> Zeiris: yes, they did
00:16:22 <c_wraith> You don't need to get values out of the IO monad, though.  You can just work inside it.
00:16:24 <ivanm> just for you
00:18:08 <c_wraith> Also, I'm beginning to take the viewpoint that all "values" in haskell are actually 0-arg functions.  I started to think that way to make sense of monadic values.  But I see no reason to not expand that viewpoint to all values.
00:18:55 <Beelsebob> c_wraith: they're not all 0-arg
00:19:02 <Beelsebob> id for example is a value, and is 1-arg
00:19:40 <c_wraith> fine.  all expressions that cannot be applied
00:20:02 <c_wraith> Are still functions.  They just take 0 args, so applying them is incoherent
00:20:04 <blackh> Bang! My head just exploded again. That keeps happening.
00:20:34 <Beelsebob> c_wraith: it's nice to think like that sometimes, but Haskell does like to contradict you sometimes
00:20:48 <Beelsebob> e.g. functions aren't first class – they can't be pattern matched against
00:21:55 <Beelsebob> (actually, thinking about that, that's kinda surprising, seeing as pattern matching doesn't require Eq, instead working on the structure... so couldn't pattern matching on functions work on the structure too... i.e. the source being the same)
00:23:18 <dm`> @hoogle ProcessHandle -> ProcessID
00:23:18 <lambdabot> Warning: Unknown type ProcessHandle
00:23:18 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:23:18 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
00:23:19 <c_wraith> :t ask
00:23:19 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
00:23:39 <c_wraith> :t asks
00:23:40 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
00:26:50 <dm`> Is there any way to find out the process ID of a process you've created with createProcess?  The docs seems to suggest forkProcess is a bad idea (and I can't figure out how to call dup2 to rearrange file descriptors), but there seems to be no way to do anything useful with a ProcessHandle.
00:27:09 <c_wraith> But it's the only way I can have a coherent model of the Reader, State, and IO monads.  a function like asks, for instance.  The value of a returned by it depends on the contents of the reader monad.  when I tried to think of it as operating in a context, it felt like the context was an argument that was part of the return value.  When I adjusted my viewpoint to think of the return value as a 0-arg gunction, it made a lot more sen
00:27:09 <c_wraith> se to me.
00:27:34 <c_wraith> *function
00:27:44 <c_wraith> I'm bad at typing in the dark.  and proofreading.
00:29:20 <c_wraith> @src MonadReader
00:29:20 <lambdabot> Source not found. My pet ferret can type better than you!
00:34:50 <hackagebot> simplenote 1.0 - Haskell interface for the simplenote API. (MariusEriksen)
00:42:28 <copumpkin> can we say that there's a functor mapping the category of linear transformations (whose morphisms are composition where possible) to (and from) the category of matrices (with morphisms as multiplication where possible)
00:43:17 <copumpkin> or is it an overcomplicated way of saying they're isomorphic?
00:56:13 <copumpkin> wow, this channel is quiet!
00:56:32 * Beelsebob is busy thinking about why we don't have pattern matching on functions
00:56:40 <Beelsebob> it would actually be bloody useful
00:56:43 <copumpkin> how could we?
00:57:04 <Beelsebob> f (if c then t else e) = if not c then t else e -- like this
00:57:08 <Beelsebob> (for example)
00:57:36 <copumpkin> not sure I get that
00:57:39 <copumpkin> what's the type of it?
00:57:46 <copumpkin> is there a lambda there?
00:57:57 <Beelsebob> oh, woops, missed the lambda
00:58:27 <Beelsebob> f (\t e -> if c then t else e) t' e' = if not c then t' else e' -- this is what I meant to write
00:58:48 <sohum> hm. the best you could get is like pattern matching on thunks
00:58:50 <copumpkin> f :: ?
00:59:10 <Beelsebob> f :: (a -> a -> a) -> a -> a -> a copumpkin
00:59:23 <copumpkin> Beelsebob: where does the c come from?
00:59:35 <sohum> and then you'd have to have a desugarer in the pattern-matching subsystem
00:59:38 <Beelsebob> copumpkin: it's matched against the condition in any lambda that's possed to it
00:59:38 <lpsmith> hmm,  is hackage and Cabal going to support the AGPL?
01:00:02 <sohum> and pattern matching as of now forces evaluation, so dunno how that'd interact
01:00:20 <copumpkin> Beelsebob: how do you know the lambda that's passed to you even contains such a condition?
01:00:25 <Beelsebob> sohum: that makes sense – it needs to force evaluation enough to check that it indeed has a functional value that looks right
01:01:13 <Beelsebob> copumpkin: you store a representation of the lambda in some form that gives you the right level (as yet undetermined) of structural equality
01:01:28 <Beelsebob> that's what I'm trying to figure out atm, what's the "right level" to write in some semantics
01:01:42 <copumpkin> hm :)
01:06:48 <sohum> well, clearly haskell stores them in some sense, right?
01:06:52 <sohum> that's what thunks are
01:07:04 <copumpkin> as binary code
01:07:34 <Beelsebob> yeh, you would (probably) need a rather higher level representation too
01:07:52 <Beelsebob> unless you could do something *very* clever at the optimised binary level
01:08:14 <dolio> And you thought seq was bad!
01:08:26 <Beelsebob> what's "bad" about this dolio?
01:08:44 <Beelsebob> it's inspecting the structure of a value, just like all other pattern matching does
01:09:11 <dolio> seq breaks eta, this breaks all semblance of extensionality of functions.
01:09:40 <Beelsebob> how so?
01:09:48 <dolio> Since now I can tell the difference between (\t f -> if True then t else f) and (\t f -> t)
01:10:00 <solrize> should an IntMap Int with about 6 million keys use anything like 2gb of memory?
01:10:05 <Beelsebob> how does that break extensibility?
01:10:29 <Beelsebob> that's like saying that Set is broken, because you can tell the difference between a left leaning tree and a right leaning tree as the internal representation
01:10:30 <dolio> Extensionality says that f = g iff forall x. f x = g x
01:10:46 <Beelsebob> dolio: yes, so?
01:10:52 <Beelsebob> pattern matching isn't about equality
01:11:00 <dolio> They're nice properties to have.
01:11:10 <Beelsebob> can you give an example where it's not true?
01:11:53 <dolio> I don't really understand that question. Those two functions are no longer able to be substituted for one another.
01:12:08 <dolio> Because they're now different functions, despite doing the same thing.
01:12:13 <Beelsebob> sure they are, if you what you want to do is compare equality of functions
01:12:18 <Beelsebob> no they're not
01:12:25 <Beelsebob> the undefinable Eq on functions is still the same
01:12:55 <Beelsebob> what you're saying is equivalent to a left-leaning tree containing 'a' is a different set to a right-leaning tree containing 'a'
01:13:01 <Beelsebob> because pattern matching can tell the difference
01:13:05 <dolio> (\t f -> if c then t else f) == (\t' f' -> if c' then t' else f') = c == c'
01:13:07 <Beelsebob> even though the Eq instance can't
01:13:25 <Beelsebob> dolio: this has nothing to do with (==) at all
01:13:37 <Beelsebob> no one is comparing things for equality
01:14:42 <dolio> I must not understand what you're proposing, then.
01:14:51 <Beelsebob> something that compares structure
01:14:56 <Beelsebob> just like all other pattern matching does
01:15:17 <Beelsebob> (which is not the same as something that tells us if the two values the structures represent are equal)
01:16:25 <dolio> Am I not allowed to write that function? If I am, then if True then _ else _ and const are not the same function, because I cannot always substitute one for the other and get the same results.
01:16:49 <dolio> The language allows me to tell them apart.
01:17:46 <Beelsebob> just like (Branch (Branch (Leaf 'a') (Leaf 'b')) (Leaf 'c')) and (Branch (Leaf 'a') (Branch (Leaf 'b') (Leaf 'c'))) can't be substituted for each other if you pattern match on them
01:17:56 <dolio> That's right.
01:17:59 <Beelsebob> yet a Set library might define the two to represent the same value
01:18:06 <dolio> Yes.
01:18:33 <Beelsebob> so what I'm saying is that being able to tell the difference between them is entirely natural in this language
01:18:37 <Beelsebob> it works on *all* other values
01:18:47 <Beelsebob> we have two kinds of equality
01:18:51 <Beelsebob> the one defined in Eq
01:18:54 <Beelsebob> and structural equality
01:19:21 <dolio> Okay. But that breaks several theoretically 'nice' properties that people may care about.
01:19:28 <Beelsebob> does it?
01:19:33 <Beelsebob> like what?
01:19:39 <doserj> Beelsebob: it breaks equational reasoning
01:19:40 <dolio> Like eta, extensionality, maybe beta.
01:20:10 <Beelsebob> dolio: can you give an example of one being broken
01:20:15 <dolio> The reason people hate on seq is that it breaks some of these same things.
01:21:17 <Beelsebob> so far, all the examples you've given seem to be equally broken by representing a set as a tree
01:21:18 <dolio> For seq, it breaks eta, which says that \x -> f x = f.
01:21:44 <dolio> But that is not true, because (\x -> undefined x) `seq` () = (), and undefined `seq` () = undefined.
01:22:13 <Beelsebob> okay, and for what x is it broken here?
01:22:17 <doserj> Beelsebob: if you can pattern match on the tree structure, than that tree doesn't represent a set anymore
01:22:25 <Beelsebob> doserj: indeed
01:22:28 <Beelsebob> that's kinda my point
01:22:56 <doserj> Beelsebob: that's why you don't export the Tree constructors
01:23:14 <Beelsebob> right, so similarly, we might want a way of constraining whether a function can be matched on or not
01:23:23 <Beelsebob> a "do we want people to know how this is implemented" flag
01:24:18 <doserj> Beelsebob: a function that you can pattern match against, would not be a function, but rather sth. like algorithm, code, etc, which is on another abstraction level
01:24:27 <Beelsebob> indeed
01:24:34 <Beelsebob> which is an interesting structure to work with
01:25:00 <Beelsebob> I've often wanted to modify a function that's been passed to me – and usually the only way to do so is to wrap something around it
01:25:09 <Beelsebob> it would be interesting to be able to poke inside it and play with the values
01:25:10 <doserj> Sure, but it is totally different from the haskell type constructor (->)
01:25:30 <Beelsebob> possibly
01:26:08 <Beelsebob> that would make sense, an a ~> b being an "algorithm" while a -> b was a function
01:26:14 <Beelsebob> functions can be reasoned about nicely
01:26:20 <Beelsebob> while algorithms can be taken apart and put back together
01:29:38 <doserj> Beelsebob: and you couldn't have a function of type (a->b) -> (a~>b), of course :) (only vice-versa)
01:29:48 <Beelsebob> yep
01:30:07 * Beelsebob ponders, could you have an algorithm (a -> b) ~> (a ~> b)
01:30:32 <Beelsebob> I suspect you can
01:30:45 <Beelsebob> that the breakage of reasoning gets wrapped up there
01:30:50 <Beelsebob> and infects all values from then on
01:31:12 <doserj> well, if you have (a ~> b) -> (a->b), and (a -> b) ~> (a ~> b), then you would also have (a->b) -> (a~>b)
01:31:24 <Beelsebob> oh, so you do
01:31:32 <Beelsebob> so it's not as all pervasive as I thought
01:32:48 <dolio> You can, to some degree do this in Haskell, by writing your own language and a 'compiler' that compiles into Haskell functions.
01:32:55 * Beelsebob nods
01:32:58 <dolio> You just don't automatically get everything mirrored.
01:33:57 <dolio> You can actually do wackier things in dependently typed languages. There's an example in one of the epigram papers that lets you call a 'view' or something where you match on something that looks like '\x -> e'.
01:34:26 <dolio> Although that doesn't get you back the actual term that was used to define the function, but you can compute something that looks like that for the specific sort of function it was called on.
01:35:29 <MyCatVerbs> @check \a b -> ((a::Float)+b) == (b+a)
01:35:30 <lambdabot>   "OK, passed 500 tests."
01:37:07 <ksf> what should I do if IntMap is too slow and I'm too lazy to roll a dynamic hashtable on my own?
01:37:19 <ksf> (I'm looking for as fast as possible lookups)
01:38:14 <Baughn> Use an Array?
01:38:40 * Baughn wonders if the Array GC mess has been fixed for 6.12
01:38:43 <Beelsebob> ksf: IIRC, someone tested hash tables for that, and discovered that they were slower than just using the tree like it does atm
01:38:52 <ksf> > length ([chr 0..maxBound] :: Char)
01:38:53 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
01:38:53 <lambdabot>         against inferred type...
01:38:58 <ksf> > length ([chr 0..maxBound] :: [Char])
01:38:59 <lambdabot>   1114112
01:39:29 <Baughn> > ord (maxBound ::  Char)
01:39:30 <lambdabot>   1114111
01:40:00 <ksf> well I'm not caring much about insert performance, so I _can_ do fancy things like perfect hashing on collisions and stuff.
01:40:26 <ksf> heck I can even pre-compute a separate perfect hash function for commonly used alphabetic ranges.
01:40:46 <Botje> well, a perfect hash would be O(1) :)
01:40:49 <ksf> say extended latin greek japanese
01:41:23 <ksf> (I can't really claim it, but I expect that chinese has less performance problems as you get less glyphs on the screen on average)
01:43:26 <ksf> I guess that's the key, anyway. the unicode range is used highly selectively, but inside those collections, still chunked.
01:52:10 <tibbe> ksf: what's your use case?
01:52:25 <ksf> a glyph cache
01:52:40 <tibbe> ksf: hmm
01:52:55 <tibbe> ksf: and the problem is that lookup is too slow?
01:53:18 <ksf> let's say it's way slower that I'd like it to be.
01:53:36 <tibbe> ksf: hmm, OK. I'm not sure why it would be slow :/
01:53:46 <tibbe> ksf: IntMaps are usually pretty fast
01:54:01 <ksf> they're darn fast, at least compared to plain maps
01:54:08 <Baughn> ksf: How many lookups per second are we talking here?
01:54:34 <ksf> it's not per-second performance but per-draw performance that's important.
01:54:51 <ksf> and there's a lookup for every bleeding glyph displayed.
01:55:01 <ksf> have a look at your chat client for an average measure.
01:55:07 <tibbe> ksf: so presumably you're looking up the glyphs for all characters in a long string?
01:55:17 <ksf> yep
01:55:31 <Baughn> ksf: That should not be a problem. A few thousand lookups?
01:55:40 <tibbe> ksf: can't the glyph be cached with the character instead of being repeatedly looked up?
01:56:35 <copumpkin> ksf: I don't see why an IntMap would be slower than a hashtable on something like a code point
01:56:43 <ksf> surely, but I'd loose my nice string-only interface.
01:57:04 <tibbe> ksf: I believe something like the feather weight pattern is used in OOP languages to deal with cases like this. Every visual character is shared and refers to only one glyph.
01:57:20 <tibbe> copumpkin: me neither
01:57:34 <tibbe> ksf: it might just be that a string of characters isn't the best representation in this case
01:57:54 <tibbe> ksf: you might go through a lot of work to great a hash map and notice that's it's not faster
01:58:05 <copumpkin> the thing is, your hash function will probably examine all the bits of your character, possibly multiple times, before you even look into the table itself
01:58:42 <copumpkin> an intmap will probably examine fewer than all bits in your codepoint, and at the worst will look at all of them
01:59:52 <Peaker> copumpkin, current hardware makes looking at "all the bits in a character" not more expensive than looking at some, perhaps even cheaper
01:59:53 <ksf> actually, you're perfectly right, and I should have known it all along. computing stuff inside draw() is bad.
01:59:58 <ksf> ...even if computing is lookup.
02:00:36 <copumpkin> Peaker: true, but the basic idea is you're not going to get any cheaper with a hashtable, if your keys are ints anyway
02:00:56 <ksf> copumpkin, I was worried about that, too.
02:01:23 <ksf> so it's factoring out everything more complex than an array lookup or list traversal out of draw.
02:01:25 <Peaker> ksf, are you writing a word processor?
02:01:38 <ksf> dunno.
02:02:00 <Peaker> ksf, what are you writing?
02:03:01 <Peaker> Is IntMap really faster than a hash table for lookups? I suppose for functional updates (making a new IntMap), sure, but my guess is that in-place changes and lookups are faster in a hash table, at least if its allowed to waste some space for less hash collisions
02:03:13 <ksf> something that knows how to search /usr/share/fonts for otf and ttf's, uses freetype to read them and currently blits a test string of every font to the screen. In other directories, there are some other bits and pieces.
02:03:37 <copumpkin> Peaker: why would lookup be faster? fewer memory accesses I guess?
02:04:02 <ksf> well it's not that there's a millon of glyphs stored in there.
02:04:14 <tibbe> an IntMap specialized for a particular value type could be a bit faster if it could save one indirection
02:04:18 <copumpkin> in principle I could see a bit-trie (with a wide branching factor maybe) being basically equivalent to a hashtable on "bittish" data
02:04:35 <Baughn> ksf: A quick test shows 1.5 million lookups in a 30,000-element intmap per second.. in ghci
02:04:48 <Baughn> ksf: Are you /sure/ the map is your bottleneck?
02:05:26 <ksf> well, I _did_ get towards 220 fps by replacing the test string with "FooBar". ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] still lags noticably, at about 10 fps.
02:05:26 <copumpkin> only around 100k code points are defined in unicode, and most fonts don't contain glyphs for most of them
02:05:43 <Peaker> copumpkin, I'd guess fewer operations overall.. computing a hash, indexing, comparing
02:06:02 <Baughn> ksf: Which is entirely different. Can you try replacing the intmap lookup with a const glyph?
02:06:11 <Peaker> copumpkin, startnig to extract bits and traversing a tree based on that already sounds more expensive
02:06:15 <tibbe> > length ( ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'])
02:06:16 <lambdabot>   62
02:06:26 <tibbe> ksf: 62 lookups vs 6?
02:06:41 <Baughn> There's just no way this is the intmap..
02:06:47 <ksf> copumpkin, that's why I'm storing separate char -> glyph index (freetype gives me those), glyph ix -> bitmap and (glyph ix, glyph ix) -> kerning caches.
02:06:53 <copumpkin> PeakerWork: what about a wide-branching one? each trie node eats up 4 bits or something? for a 32-bit word that means 8 bitmasks and you're there
02:07:03 <ksf> it's the enummap and gmap (enum,enum)
02:07:17 <copumpkin> (along with the associated memory reads)
02:07:34 <tibbe> ksf: have you had time to look at profiling output?
02:07:38 <ksf> from a quick scan of the code I assume intmap uses as wide a prefix as it can.
02:07:56 <ksf> I've even had time to insert a swash of SCC's.
02:08:19 <Peaker> copumpkin, I don't know, maybe it is faster, but still, if your hash and comparison is really cheap, and array indexing is pretty cheap, then its still 8 lookups vs 1 + comparison, it seems
02:08:48 <copumpkin> Peaker: well, your hash function is still doing some work, a few xors and shifts and such
02:09:13 <Peaker> IntMap also requires you to intify it (assuming your keys aren't necessarily Ints)
02:09:35 <Peaker> I wonder if an in-place hash table performance was compared to IntMap, or just copy-to-update hash table
02:09:57 <copumpkin> dunno :)
02:10:09 <copumpkin> time for bed, anyway
02:11:26 <ksf> profile:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9729#a9729
02:14:17 * ksf thinks he should get smart about whitespace, too. chunking into words is needed for justification, anyway.
02:15:21 <ksf> although I don't expect there to be many occurences of "Donaudampfschifffahrtsgesellschaftskapitaensmuetzenhalterpolierertuch" on one screen.
02:16:28 <paolino> hi, I have a question on this code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9730#a9730
02:17:01 <paolino> How can I serialize ex and ex2 ?
02:17:28 <ksf> (Donau steamshippingcompany's captain's hat stand polisher's tissue)
02:18:19 <paolino> they have different state type, so I cannot put it in the SM data
02:18:26 <ksf> haskell can't serialize functions.
02:19:00 <ksf> ...but you can serialize an (G)ADT that represents those computations.
02:19:33 <paolino> right, I want to put that Int/Char in the SM definition
02:19:49 <ksf> ...you could use the Enum typeclass.
02:20:32 <ksf> (chr and ord are the same as toEnum/fromEnum, specialized to Char)
02:20:32 <DarkUnicorn> ksf: shouldn't it be "...poliertuch"?
02:20:40 <ksf> well, no.
02:20:52 <ksf> it's the polisher's tissue, not a polishing tissue.
02:21:01 <DarkUnicorn> oh ok
02:21:34 <paolino> ksf , the example was too simple then, say the 2 states have no common class
02:21:38 <DarkUnicorn> didn't know that they have an own job for that :)
02:22:25 <ksf> having the possessive case as part of the grammar to concatenate nouns is one of the reasons that you can do such tapeworm words.
02:23:11 <ksf> a common job recommondation among kids is "toilettentieftaucher mit arschbeleuchtung"
02:23:14 <paolino> ksf if I define SM s p = SM (s -> p -> (SM s p,s))  everything is fine but I need both SM Int String and SM Char String which I don't want
02:23:31 <ksf> as teenagers, we settled on "colakistenentgrater"
02:25:28 <paolino> I feel I need an existential, but I cannot guess how to use it
02:26:52 <ksf> ...and I guess those pio -> +1 and meno -> -1 mappings aren't all that you're going to have?
02:27:29 <paolino> ksf , my real code is here http://github.com/paolino/smsc, you can get a better view  of those functions in TestCore.hs
02:28:18 <ksf> that's... that's not english.
02:28:23 <Peaker> I don't think an existential is ever actually needed, but that's just a hunch based on experience with particular cases.. it seems like whatever is later done to the existential could be done before-hand, avoiding the need to store an existential anywhere
02:29:20 <ksf> ghc won't understand that, it's native language is oxford english.
02:30:14 <ksf> you want to serialize those beasts? you're going to need a full-blown evaluator for that.
02:30:40 <paolino> ksf, well I need to serialize only their state
02:31:01 <paolino> but from the Core
02:31:21 <paolino> now I just don't see it from there
02:31:33 <ksf> you already have read and show instances for GState...
02:32:11 <paolino> right, but the SM data is not seeing those
02:32:33 <paolino> SM Command Answers
02:35:04 <paolino> in Core I have a list of [SM p q] but I cannot serialize those , which makes the service not stoppable
02:35:33 <ksf> well an SM isn't serializable.
02:35:36 <paolino> I cannot recreate it after, if not feeding all the events from the beginning
02:35:37 <ksf> ...only its state.
02:36:01 <ksf> so if you have a way to extract state, you can serialize it.
02:36:31 <paolino> ksf I suppose with a class from the state I can get the method back
02:36:57 <ksf> (if it happens to have the right instances. It's considered bad practice to annotate data types with it, just write a function that only accepts properly-constrained state types)
02:38:49 <paolino> I'm not understanding, sorry
02:40:48 * ksf thinks your current code is overkill... that is, there's much to much library and not enough code using it.
02:41:26 * ksf always finds it hard to design libraries proper before there's an app that's using the functionality.
02:42:14 <ksf> (the library just tends to unveil itself as an abstraction over much-used idioms in the app's code)
02:43:07 <paolino> mh the real Command/Answers set is bigger in my application so is the number of possible SM
02:43:51 <paolino> but you are right, I cannot resist these things
02:44:19 <ksf> ...automata-driven programming is a cool technique, but its' not haskell.
02:44:48 <dolio> Beelsebob: http://code.haskell.org/~dolio/agda-share/html/FunView.html <-- something like this, but I can't find the Epigram (or whatever it was) paper where I originally saw the idea.
02:45:36 <ksf> even in game programming, where automata occur completely naturally, I never bothered to abstract them away.
02:46:45 <dolio> Beelsebob: The idea is that when you have a function from a finite domain, you can "match" against the function like, taking Booleans for instance, g matches to (\b -> if b then t else f), giving you t = g True and f = g False.
02:47:02 <kowey> is it reasonable to want cabal sdist to figure out which modules of my executable to include without me having to specify it in other-modules?
02:47:48 <dolio> Which probably isn't very useful, but it looks cool.
02:48:50 <ksf> doesn't it do that?
02:52:34 <Beelsebob> damn it, now I want to learn agda simply because that code looks so damn beautiful
02:52:56 <dolio> Yeah, unicode + mixfix can look pretty sexy.
02:53:07 <Beelsebob> also, I'm not sure if that's the same as what I was looking for
02:53:17 <Beelsebob> that seems to be doing function equality, when it's possible
02:53:24 <Beelsebob> rather than doing structural matching
02:53:33 <dolio> It's not really. You're not extracting any information from the function.
02:53:58 <dolio> It's just that matching on "vlam v" gives you information about the function, which lets you display it as a lambda expression.
02:54:42 <dolio> When a pattern becomes ".foo" it means that all the stuff in foo is determined elsewhere.
02:55:49 <dolio> The original source I got it from may have had a more interesting application, though.
02:56:01 <dolio> But I can't find it.
03:01:20 <SamB_XP> > not
03:01:21 <lambdabot>   {True->False;False->True}
03:01:33 <ksf> someone tell me a different word for "in", as that's taken up by the language.
03:01:57 <SamB_XP> ksf: you could use "for"
03:02:12 <SamB_XP> what are you doing, though ?
03:02:14 <ksf> no like in "input channel" "input variable"
03:02:22 <SamB_XP> ksf: oh
03:02:26 <ksf> ...as opposed to a binding that's you'd call "out"
03:02:32 <SamB_XP> inp
03:04:29 * SamB_XP at first thought ksf was trying to make up a syntax for "let" in a language where "in" was already taken
03:08:30 <lilac> ksf: endo? :)
03:08:56 <lilac> iN?
03:10:55 * ksf reconsidered what's haskell all about and settled on "i" and "o"
03:12:18 <SamB_XP> ksf: sometimes I do things like "fin" and "fout"
03:12:30 <SamB_XP> but possibly that's when I'm writing python
03:13:28 <SamB_XP> where in means \in
03:21:44 <lilac> ksf: just go pointfree :)
03:22:16 <SamB_XP> lilac: ... right!
03:23:24 <hackagebot> digest 0.0.0.7 - Various cryptographic hashes for bytestrings; CRC32 and Adler32 for now. (EugeneKirpichov)
03:23:56 <lpsmith> heh,  crc32 isn't a cryptographic hash
03:24:53 <lilac> i'm parsing a binary format with Data.Binary.Get. this format has 'interned' strings in it, which are backreferences to earlier strings, but i don't want to expose them in the interface.
03:25:15 <lilac> what's the best way of doing that?
03:26:18 <lilac> if i separate the uninterning from the parsing (which seems cleanest) then i need some kind of intermediary format. i've considered using a GADT with a type parameter which controls whether the extra constructors exist, but that seems ugly
03:26:50 <lpsmith> lilac:  that sounds mighty complicated
03:27:01 <lilac> yeah, it's nasty
03:27:09 <lpsmith> why not just refer back to the existing string?
03:27:09 <lilac> the trouble is, the type is recursive
03:27:20 <lilac> lpsmith: how do you mean?
03:28:08 <lilac> i think i'm going to give up on separating the uninterning from the parsing and use StateT [String] Get O rather than just Get O, but that makes me slightly sad
03:28:21 <lpsmith> well,  I assume your parser is producing a ADT of some kind
03:28:40 <lilac> well, the string references are integer indices from the start
03:29:09 <lpsmith> So unless the consumer of the parse tree needs to explicitly deal with sharing
03:30:46 <lpsmith> I'd copy the ADT that you produced for the interned string
03:30:46 <int-e> lilac: well instead of a GADT you could parameterize the type on the kind of strings it may contain - then parse to Foo (Either Reference String) and resolve references mapping that to Foo String.
03:30:46 <lpsmith> This could be a copy,  or you could share it, possibly
03:30:48 <lilac> int-e: that sounds reasonable, but i think it still suffers from the problem that that detail leaks through to the interface
03:31:11 <lilac> (i want consumers of my type to be able to pattern-match on it, but i don't want them to know about the interning)
03:31:21 <lpsmith> ok
03:31:55 <lpsmith> well,  let's say you are parsing a serial representation of a binary tree... and the backreference refers to another binary tree
03:33:00 <lpsmith> so you want the binary tree referred to directly in your final result,  right?
03:33:24 <lilac> sure. ideally i'd like it shared, but that's not too important.
03:33:32 <lpsmith> There is a couple ways of doing this;  circular programming could do the trick and preserve sharing :)
03:34:17 <lilac> i'm looking for a way of doing it which lets me separate the parsing step from the resolving backreferences step
03:34:59 <lilac> ah, i think i see what you're saying
03:36:06 <lpsmith> another idea is to associate a part of the ADT in an IntMap
03:36:09 <int-e> parseFoo :: (Reference -> String) -> Get Foo?
03:36:13 <lilac> if i have: parse :: [String] -> Get Obj (and I'm careful) then I can write extractStrings :: Obj -> [String], and then say: let strings = extractStrings obj; obj = runGet (parse strings) byteString in obj
03:36:41 <lpsmith> Whenever the parser produces an ADT,  store it in the IntMap,  when it finds a backreference, look it up
03:37:10 <lilac> lpsmith: ok, but that seems to imply merging the unintern step and the parse step
03:37:25 <lilac> perhaps that's the best answer, though
03:37:30 <lpsmith> maybe.
03:37:37 <lilac> i do quite like the tying-the-knot approach
03:37:38 <lpsmith> You could work on disentangling the two aspects later
03:37:55 <lilac> erk, there's something important i forgot :(
03:38:10 <lpsmith> but it might be appreciably more efficient to have it in "one" step,  whether they be disentangled or not
03:38:23 <lilac> there are three types of string in the binary format: direct strings, interned strings and string refs. string refs refer to previous interned strings. i want the final data type to only have direct strings.
03:38:41 <lilac> so the tying-the-knot method doesn't quite work because it still needs an intermediate format containing interned strings
03:40:09 <lilac> i think i'll either give up on using the type system to guarantee i've uninterned the result, or merge the two steps and use StateT (IntMap String) Get Obj or similar
03:41:00 <int-e> lilac: to make things worse, the indices of the interned strings seem to be tied to the parsing order. So if you separate these steps, you'll have to keep the traversal and parsing in sync.
03:41:22 <lilac> int-e: that's true, and it seems like a good argument to combine them.
03:41:55 <kw-> hi. is there a decent way to have mutable, shared state?
03:42:05 <SamB_XP> lilac: what's the diff between interned strings and direct strings ?
03:42:27 <SamB_XP> direct strings can't be backreferenced ?
03:42:36 <lilac> SamB_XP: right.
03:42:37 <int-e> kw-: IORef? MVar? Or STM? It depends on how you want to mutate it, and what kind of atomicity requirements you have.
03:42:49 <SamB_XP> lilac: so, just put only the interned strings in the Map
03:43:00 <SamB_XP> doesn't seem like much of a problem ...
03:43:03 <lilac> SamB_XP: that presupposes there is a Map ;-)
03:43:21 <SamB_XP> lilac: well, you could use a Sequence if you prefer ;-P
03:43:29 <SamB_XP> in fact, I guess I'd advise it ...
03:43:48 <lilac> SamB_XP: having a map means making the parse step know about the uninterning
03:44:00 <lilac> which is what i originally wanted to avoid, but int-e has convinced me that i should merge them
03:44:30 <kw-> int-e: well, i'm pretty much a noob, no idea what fits. i spawn threads which are supposed to "report back" when required (ie whenever the user wants). :?
03:45:55 <lilac> kw-: if what you want is to have a collection of threads doing impure IO stuff, and sending messages to a central thread, then a Chan might be a good fit.
03:46:12 <int-e> (here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html )
03:46:28 <lilac> int-e, lpsmith, SamB_XP: thanks, i think my head is clear on this now :)
03:47:45 <kw-> much obliged
03:49:05 <lilac> i think i'm going for: parse' :: Array Int String -> Get (Obj, [String]); parse :: Get Obj
03:49:15 <lilac> with parse building an array from the list and tying the knot
03:49:23 <SamB_XP> lilac: oh, the parse step certainly has to know about the interning -- it's just that one way it actually does it, and the other way it doesn't but your types get cluttered with fairly meaningless constructors
03:49:36 <int-e> lilac: arrays can't be grown nicely
03:49:47 <lilac> int-e: no, but i don't need to build the array until i'm done parsing
03:50:15 <SamB_XP> where are you getting this array again ?
03:50:23 <int-e> lilac: nm, I didn't look at the result type closely enough.
03:50:30 <int-e> SamB_XP: knot tying
03:50:40 <lilac> SamB_XP: the array is built from a list of interned strings produced by the parsing step
03:50:45 <SamB_XP> oh
03:50:48 <SamB_XP> you mean mfix ?
03:50:56 <int-e> no, just fix
03:51:02 <SamB_XP> whatever
03:51:05 <int-e> runGet produces a pure value.
03:51:09 <lilac> parse woudl actually be ByteString -> Obj
03:51:21 <altmattr> anyone here involved with YCR2JS?
03:51:25 <SamB_XP> lilac: incidentally, what are you parsing ?
03:51:30 <SamB_XP> altmattr: what's that?
03:51:37 <lilac> SamB_XP: python's 'marshal' format
03:51:41 <SamB_XP> a YHC core to JavaScript converter ?
03:51:44 <altmattr> haskell to javascript
03:51:48 <altmattr> via yhc
03:51:56 <altmattr> sorry, via yhc core
03:52:05 <SamB_XP> lilac: oh ... is that the one they use for .pyc files ?
03:52:10 <lilac> SamB_XP: that's right, yeah.
03:52:31 <SamB_XP> what else is it used for, that you actually have a use for parsing it ?
03:52:31 <lilac> SamB_XP: ultimately i'm trying to make a python static type inference engine and compiler ;)
03:52:34 <SamB_XP> oh
03:52:38 <SamB_XP> heh
03:52:55 <SamB_XP> are you going to write a new decompyler ?
03:53:02 <SamB_XP> as well
03:53:10 <lilac> i already have a disassembler working
03:53:46 <lilac> i'm not planning on writing a decompyle (that project is no longer dead)
03:54:03 <SamB_XP> lilac: oh, cool!
03:54:20 <lilac> it's been renamed now though (can't remember what to)
03:54:26 <SamB_XP> I was just going to say about how there used to be a program called decompyle, but it seemed to have died ...
03:54:30 <SamB_XP> what ?
03:54:38 <SamB_XP> why'd they do a fool thing like that?
03:54:53 <lilac> http://code.google.com/p/unpyc/
03:55:03 <ksf> never trust a chiropractor with bent back
03:55:04 <lilac> it's a fork
03:55:11 <SamB_XP> ah
03:55:31 <SamB_XP> how does it qualify as a fork if the original project went dormant?
03:55:40 <lilac> decompyle worked by pattern matching, and got broken by python2.5's bytecode peephole optimizer
03:55:51 <SamB_XP> ah
03:55:56 <lilac> i think they're going to be doing some fairly drastic surgery to it to get it working :)
03:56:17 <ksf> it's a fork if you don't get maintainership passed on to you oficially by the original maintainer.
03:56:26 <kw-> hm, chan doesn't seem to be right for my purpose. i basically want a list where every entry contains information about a thread.
03:56:44 <SamB_XP> huh, you'd think peephole wouldn't be that hard to counter ... then again, I guess I haven't done it myself
03:56:54 <lilac> kw-: hmm. maybe a map from some kind of thread identifier to an MVar?
03:57:02 <SamB_XP> heck, I haven't even written a Turbo Pascal decompiler like I probably ought to ...
03:57:06 <lilac> or an IORef if an MVar doesnt' quite fit
03:57:36 <SamB_XP> what about weak references ?
03:57:44 <ksf> kw-, [ThreadId] ?
03:57:53 <SamB_XP> you'd think GHC could give you a list of threads ...
03:59:17 <ksf> if you want to shut down your threads, a thing like chp's poison would be sensible.
03:59:41 <ksf> ...in fact, it's the only sensible thing to do, throwing exceptions to threads is dirty.
03:59:51 <ksf> (and gives you nasty messages on stderr)
04:00:02 <lilac> SamB_XP: so the plan is 1) read .pyc files [done but ugly], 2) disassemble [done for every python version ever ;-)], 3) convert to SSA [partial] 4) analyze types and optimize 5) emit LLVM
04:01:05 <SamB> lilac: so, you really think that's going to outperform a good JIT?
04:01:12 <SamB> I mean, even psyco?
04:01:24 <kw-> ksf: sorry, i don't understand. i want the the main thread to see the thread's progress (curl's ProgressFunction).
04:02:26 <lilac> SamB: a specializing JIT is hard to beat. this is as much a "to see if I can" project as something to beat psyco / unladen swallow / pypy / whatever.
04:02:55 <ksf> oh, you want a MVar.
04:03:20 <ksf> ... let the callback put the value into it, and read it in a different thread.
04:03:42 <lilac> SamB: that said, my goal is pretty similar to that of Shed Skin, and that beats psyco by quite a large margin on some code
04:03:45 <kw-> i will look it up. thanks lilac and ksf.
04:04:29 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
04:04:29 <SamB> lilac: huh
04:04:38 <SamB> school now ...
04:04:58 <lilac> lunch now ... :)
04:05:19 <int-e> An IORef should do for that purpose, actually. (writeIORef just updates a pointer after all)
04:05:24 <ksf> ah, and you want to do tryTakeMVar mv >> putMVar mv v to put your stuff, as you don't want to block on writing
04:05:33 <ksf> (in case the display thread can't keep up)
04:06:29 <ksf> int-e, you can't block on an ioref, so you'd have to specify a sampling interval instead of just waiting for a new value.
04:08:14 <int-e> ksf: mm. ok, the way I'd implement this I'd probably have such a sampling interval (no point in updating the display more than 20 times or so a second even if the worker is making progress very quickly.)
04:09:46 <ksf> see, the way I'd do that is fork off another thread that limits that rate.
04:11:10 <ksf> I'm going to release a STM library some time, as soon as I've got a more serious collection of idioms.
04:11:19 <paolino> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9730#a9732, if anyone can help I'd appreciate a lot, thanks
04:13:37 <ksf> why do you want to constrain the type to Counter?
04:13:56 <ksf> you can do that, but you'd need typeable/dynamic
04:14:24 <ksf> usually, just referring to the typeclass methods should be enough.
04:15:10 <paolino> I added :: Counter after I got the error
04:15:48 <paolino> Couldn't match expected type `Counter' against inferred type `x'
04:15:48 <paolino>       `x' is a rigid type variable bound by
04:15:48 <paolino>           the constructor `B'
04:17:03 <ksf> ...you can't extract the concrete type of an existential without using typeable, to do run-time dynamic typing.
04:17:27 <ksf> after all, you could pass _any_ type that implements GetSM into it
04:17:55 <ksf> (even if there's only one GetSM instance, classes are open: another file could do another instance)
04:19:04 <paolino> so, I must nail down the modification, in the class ?
04:20:01 <ksf> either that, or use Data.Dynamic
04:20:36 <paolino> mh, never opened that can, till now
04:20:41 <ksf> ...or find another way to wire up your functions/types, that doesnt' use existentials.
04:21:43 <paolino> which would stop me to have SM not parametrized on its state type, I suppose
04:22:02 <ksf> :t runState
04:22:03 <lambdabot> forall s a. State s a -> s -> (a, s)
04:22:12 <ksf> ...see, it's parametrized over s
04:22:47 <paolino> as it is now SM is not
04:23:22 <ksf> ...I just wanted to nudge you into the direction of accepting that it makes sense to parametrize over the state type.
04:23:42 <hackagebot> curry-base 0.2.3 - Functions for manipulating Curry programs (HolgerSiegel)
04:23:51 <ksf> you can hide it later on, when you say type MyConcreteAutomaton = State MyConCreteType
04:24:14 <paolino> ksf then I cannot collect the SM as they have different state types
04:24:39 <ksf> well, you can use existentials there. on the outer, not inner level.
04:24:42 <hackagebot> curry-frontend 0.2.3 - Compile the functional logic language Curry to several intermediate formats (HolgerSiegel)
04:25:08 <paolino> and , worse I cannot make the SM create SMs with different state types
04:25:23 <paolino> in the real case
04:26:05 <paolino> data SM p = SM (p -> (SM p, [SM p]))
04:27:32 <paolino> well, I must think a lot actually, I'm a noob
04:27:57 <ksf> just try different approaches, to get a feel for it.
04:28:22 <ksf> It's way easier to reason about existing code.
04:28:43 <hackagebot> curry-base 0.2.2 - Functions for manipulating Curry programs (HolgerSiegel)
04:29:33 <ivanm> why did hackagebot announce the older version of curry-base _after_ the newer version? :s
04:31:11 <doserj> ivanm: because it was uploaded later...
04:31:49 <ivanm> well, why would someone upload an older version after a newer version...
04:32:16 <ivanm> (and yes, hackage agrees with you regarding upload times)
04:50:36 <ksf> is there a way to reset the profile from within the program?
04:51:48 <hackagebot> hmpfr 0.3 - Haskell binding to MPFR library (AlesBizjak)
04:52:53 <ksf> I'm up to 50fps drawing a whole screenfull of glyphs
04:54:50 <ksf> that lib should be called hmpfgrrargh
05:14:22 <vegai> hmm, System.Locale is in the old-locale library
05:14:40 <vegai> where's the non-old locale?
05:15:12 <ivanm> there isn't one AFAIK
05:15:27 <ivanm> old- means its deprecated, but a lot of people still use it
05:15:53 <vegai> huh
05:15:57 <Baughn> What are you supposed to use instead?
05:16:01 <vegai> why deprecate something that doesn't have a replacement?
05:16:20 * Baughn deprecates thunks
05:16:57 <Cale> Perhaps they intend to replace it soon? I'm not sure why, really.
05:17:08 * ksf thinks one of those shiny, fancy new IO systems is going to be the replacement
05:17:23 <Baughn> There's some locale work in 6.12, but iirc that just means defaulting to the correct encoding
05:17:28 <ksf> ...as unicode and locale support are somewhat intertwined.
05:17:42 <vegai> ah.
05:18:06 <Baughn> You'd still want to pick up things like default language, etc.
05:20:30 <ksf> .oO( unsafeInterleaveSTM )
05:22:03 <ksf> that reminds me... I wanted to buy a wine. Didn't have one for months, and kept on dreaming about it for the last three nights.
05:22:35 <Baughn> http://www.gertens.com/sites/default/files/images/Climbing%20vine.jpg <-- Like this?
05:23:04 <ksf> some nice australian cabernet sauvignon or such
05:23:13 <Baughn> I don't know that plant
05:23:25 <lilac> wine's open-source, so there's really no need to buy it :)
05:24:03 <ksf> more like this: http://upload.wikimedia.org/wikipedia/en/2/26/Yellowtaillogo.png
05:24:39 <lilac> what do you consider "nice"?
05:25:14 <lilac> (are we talking a £7 bottle or a £70 bottle?)
05:25:15 <ksf> ...having a good price without being cheap.
05:25:28 <ksf> we're talking about a 6 Euro bottle here.
05:25:49 <lilac> makes sense. the first few pounds here are tax :)
05:26:07 <lilac> how did unsafeInterleaveSTM remind you of this?
05:26:19 <ksf> just the general dreamy mood.
05:27:05 <lilac> unsafePerformDanceRoutine
05:27:18 <ksf> expensive wines are just too sacre to really _drink_ them.
05:27:29 <ivanm> ksf: are you from down under, or buying our plonk overseas?
05:27:34 <lilac> depends who's paying :)
05:27:39 <ksf> overseas.
05:27:40 <ivanm> heh
05:27:41 <int-e> unsafeDrinkBeerAfterWine
05:27:57 <lilac> unsafeCrossStreams
05:28:16 <ksf> It's not that germany wouldn't have good wines, but they're either bland or too expensive.
05:29:04 <lilac> do you listen to different music when coding in haskell from when coding in other languages?
05:29:23 <ksf> nope
05:30:24 <ivanm> because you don't program in any other language? :p
05:30:34 <ksf> I started out by standing in the wine department, thinking "let's go for sunny countries that aren't too widely known for their wines, so you don't pay for the nationality" and got hooked up on australian ones.
05:30:53 <ivanm> ksf: I thought Australia _was_ moderately well known for wines...
05:31:03 <eevar2> ivanm: indeed
05:31:10 <ivanm> http://en.wikipedia.org/wiki/Australian_wine
05:31:15 <ksf> well, you could say that I'm listening to less music than before, but I can't really connect that to haskell.
05:31:18 <ivanm> we're the 4th largest plonk exporters in the world!
05:31:58 <Baughn> http://hollygeegoeswest.typepad.com/photos/uncategorized/2008/04/24/matress_vine_042208.jpg <-- In australia, even the vines are out to kill you. Seriously, that looks terrible.
05:32:19 <ksf> still, around here if you say wine think "france", because of heritage, "greece", because of an awful pop song, or "germany", because of that recent mosel vacation.
05:32:42 <ivanm> ksf: what's a "mosel vacation"?
05:32:57 <ksf> http://en.wikipedia.org/wiki/Mosel_(wine_region)
05:33:00 <ivanm> Baughn: heh, that's nothing like a real vineyard
05:33:28 <lilac> ksf: interesting. here i think it's "france" because of heritage, "australia" because of the jacob's creek advertising, then possibly italy
05:34:06 <ksf> I've never seen wine ads in germany.
05:34:14 <ciscbrain> don't any of you guys like wine from chile/argentina?
05:34:39 <mux> I prefer wine from france
05:34:50 <ivanm> ciscbrain: I don't drink any wine at all, so no ;-)
05:34:53 <fr0ggler> hi all - am I able to put a try catch in a Right action?
05:34:54 <lilac> i'm not sure i've had any argentinian wine, but i've enjoyed chilean wine
05:34:55 <mux> and that has absolutely nothing to do with me being french, of course.
05:34:59 * eevar2 has a bottle from one of those contries at home. can't remember which, tho ;)
05:35:14 <ksf> I once tried a chilenean and drained it into the sink. That made me a bit less curious about what other wines they have.
05:35:37 * mux has a great bottle of red wine at home, ~50 EUR in .fr, but it'd probably cost at least four times that price if bought elsewhere :-)
05:35:43 <lilac> fr0ggler: if you mean, in an Either action, then yes, you can use the catchError from MonadError
05:35:55 <lilac> @type catchError
05:35:56 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
05:36:13 <lilac> @type catchError :: Either e a -> (e -> Either e a) -> Either e a
05:36:13 <lambdabot>     Could not deduce (Error e) from the context ()
05:36:13 <lambdabot>       arising from a use of `catchError' at <interactive>:1:0-9
05:36:13 <lambdabot>     Possible fix:
05:36:18 <lilac> :(
05:36:23 <fr0ggler> :)
05:36:27 <lilac> @type catchError :: Error e => Either e a -> (e -> Either e a) -> Either e a
05:36:28 <lambdabot> forall e a. (Error e) => Either e a -> (e -> Either e a) -> Either e a
05:36:55 <lilac> @djinn catchError :: Either e a -> (e -> Either e a) -> Either e a
05:36:55 <lambdabot> Cannot parse command
05:37:21 <lilac> @djinn Either e a -> (e -> Either e a) -> Either e a
05:37:22 <lambdabot> f a b =
05:37:22 <lambdabot>     case a of
05:37:22 <lambdabot>     Left c -> b c
05:37:22 <lambdabot>     Right d -> Right d
05:37:36 <lilac> ^^ is that what you want?
05:37:39 <ksf> also, germany doesn't grow a lot of red wine
05:37:41 <eevar2> chile/argentina use the same grapes as the french wines, but have less regulations regarding 'natural' production, e.g. irrigation, additives or whatever, so should in theory be able to make better/more consistent wine, and cheaper
05:38:23 * eevar2 was too lazy to change channels during some wine documentary from southern america ;)
05:38:47 <fr0ggler> lilac, er i *think* so. i'm still stuck on this problem i was having before (yeah a couple of days I've spent on this) ;)
05:38:47 <ksf> "additives" doesn't sound like increasing quality to me.
05:39:02 <ivanm> eevar2: heh
05:39:05 <lilac> fr0ggler: if you paste what you've got so far i'll have a look
05:39:07 <ksf> it's more like desperately trying to rescue messed-up crops.
05:40:38 <ksf> (heck many beer imports can't be marketed as beer around here as they contain other stuff than water, grains, hops and yeast)
05:41:56 <fr0ggler> lilac, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3894#a3894
05:42:48 <fr0ggler> im pretty sure unpickleTree is throwing an UnpickleException, but im only getting a "exception :: Control.Exception.Extensible.SomeException"
05:43:05 <fr0ggler> and I don't know enough to get at the message of that exception
05:43:36 <ksf> you can try compiling with profiling and using that exception that gives you the cost centre stack on an exception
05:43:47 <ksf> s/exception/flag
05:44:45 <jacobian> Is there a safe !!
05:45:19 <ksf> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging   -xc
05:45:25 <Saizan> you could catch it
05:46:26 <ivanm> sounds like a disease...
05:47:01 <mux> @hoogle [a] -> Int -> Maybe a
05:47:01 <lambdabot> Prelude (!!) :: [a] -> Int -> a
05:47:01 <lambdabot> Data.List (!!) :: [a] -> Int -> a
05:47:01 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
05:47:09 <mux> hmmm.
05:47:25 <mux> @hoogle MonadPlus m => [a] -> Int -> m a
05:47:25 <lambdabot> Prelude (!!) :: [a] -> Int -> a
05:47:25 <lambdabot> Data.List (!!) :: [a] -> Int -> a
05:47:25 <lambdabot> Prelude drop :: Int -> [a] -> [a]
05:47:31 <mux> well that sucks
05:47:42 <Saizan> i think there's one in the safe package
05:47:45 <Saizan> ?hackage safe
05:47:45 <lambdabot> http://hackage.haskell.org/package/safe
05:47:54 <lilac> fr0ggler: some thoughts here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3894#a3895
05:48:30 <lilac> fr0ggler: you want to use unpickleTree' since that returns Left e in case of an error rather than throwing an exception
05:48:58 * Saizan wonders why he can no longer paste from firefox
05:51:03 <lilac> @type \n -> msum . map return . take n
05:51:04 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => Int -> [a] -> m a
05:51:15 <lilac> mux: ^^ that?
05:51:38 <lilac> oh, i see :)
05:51:47 <mux> yeah I can write that too :-) I was looking for an existing function for jacobian
05:51:56 <fr0ggler> lilac, wow thanks for those - that helps a lot :) yeah i was trying that yesterday, but I was having more trouble so I thought i'd start again and try to get at the exact exception message
05:51:58 <lilac> mux: it's also not what you wanted :)
05:52:50 <mux> oh yeah, we'd need listToMaybe . drop (n - 1)
05:52:55 <mux> err
05:53:01 <ksf> argh I hate it when programs change behaviour when compiled with -threaded
05:53:01 <lilac> > (\n -> msum . map return . drop n) 4 "Hello" :: Maybe Char
05:53:02 <lambdabot>   Just 'o'
05:53:04 <mux> listToMaybe . take 1 . drop (n - 1)
05:53:18 <lilac> > (\n -> msum . map return . drop n) 4 "Hello" :: [Char]
05:53:19 <lambdabot>   "o"
05:53:29 <lilac> dropM?
05:54:04 <mux> > let foo n = listToMaybe . take 1 . drop (n - 1) in [1..5] `foo` 3
05:54:05 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:54:05 <lambdabot>         against inferred type ...
05:54:16 <lilac> @hoogle MonadPlus m => [a] -> m a
05:54:16 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
05:54:16 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
05:54:16 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
05:55:05 <ksf> _ESPECIALLY_ if it changes depending on a print statement.
05:56:50 <ksf> so, why does this   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9734#a9734    work if I uncomment the print?
05:57:03 <ksf> (or, rather, why doesnt' it work without print?)
05:59:12 <ksf> ...erm no it still doesn't reliably work, must've been a coincedence.
06:01:16 <ksf> also, I've got to clean all .hi and .o before it works when recompiling without -threaded
06:02:19 <lilac> ksf: you can use -fforce-recomp to avoid that
06:02:41 <Saizan> weird anyhow, i thought the only difference was linking an rts or the other
06:02:56 <ksf> the bug in itself is weild.
06:05:03 <lilac> "You need to link your program using the -threaded switch. (NOTE: previously it was necessary to compile all code, including libraries, with the -smp switch, this is no longer the case. The -smp flag is now a synonym for -threaded)."
06:05:21 <lilac> (from the wiki) certainly sounds like -threaded should only affect linking
06:05:47 <burp> > floor (0/0)
06:05:48 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
06:05:49 <burp> funny
06:06:08 <ksf> that's -infinity
06:06:17 <ksf> > 0/0
06:06:17 <lambdabot>   NaN
06:06:20 <burp> hehe
06:06:21 <burp> its a known bug http://hackage.haskell.org/trac/ghc/ticket/3070 ;)
06:06:25 <ksf> > 1/0
06:06:26 <lambdabot>   Infinity
06:06:30 <ksf> > (-1)/0
06:06:30 <lambdabot>   -Infinity
06:06:37 <ksf> well, close enough guess.
06:07:21 <burp> well it's still bounded, though Integer
06:07:52 <Axman6> > length . show . floor $ (0/0)
06:07:53 <lambdabot>   310
06:08:12 <lilac> > significand (0/0)
06:08:12 <lambdabot>   -0.75
06:11:21 * ksf just notices that TMVars are implemented in terms of TVars
06:11:41 <ksf> I thought they were magical special beasts
06:24:38 <ManateeLazyCat> > "/test/Download" =~ "^~*" :: Bool
06:24:39 <lambdabot>   True
06:24:59 <fr0ggler> lilac, thanks for the help - i've managed to get the error out now :)
06:25:01 <ManateeLazyCat> What?
06:25:22 <ManateeLazyCat> > "~/test" =~ "^~*" :: Bool
06:25:23 <lambdabot>   True
06:25:38 <ManateeLazyCat> > "" =~ "^~*" :: Bool
06:25:39 <lambdabot>   True
06:26:50 <ManateeLazyCat> > "/test/Download" =~ "^~.*" :: Bool
06:26:50 <lambdabot>   False
06:26:59 <fr0ggler> lilac, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3894#a3898, if you were interested - let me know if there's anything that's goofy :)
06:27:06 <ManateeLazyCat> > "~/test" =~ "^~.*" :: Bool
06:27:07 <lambdabot>   True
06:28:00 * ManateeLazyCat Looks "^~.*" is right one, i bet TDFA package change recently, "^~*" works with old version.
06:28:53 <Axman6> > "/test/Download" =~ "^~.*" :: String
06:28:53 <lambdabot>   ""
06:28:58 <Axman6> > "/test/Download" =~ "^~*" :: String
06:28:58 <lambdabot>   ""
06:29:06 <Axman6> > "/test/Download" =~ "^.*" :: String
06:29:07 <lambdabot>   "/test/Download"
06:29:46 <saml> @type (=~)
06:29:47 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
06:29:58 <saml> > 1 =~ 1
06:29:59 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexMaker
06:29:59 <lambdabot>                     T...
06:30:49 <ManateeLazyCat> > 1 =~ 1 :: Bool
06:30:50 <lambdabot>   No instances for (Text.Regex.Base.RegexLike.RegexMaker
06:30:50 <lambdabot>                     ...
06:31:05 <saml> > f=~f
06:31:06 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexMaker
06:31:06 <lambdabot>                     T...
06:31:10 <ManateeLazyCat> > "1" =~ "1" :: Bool
06:31:11 <lambdabot>   True
06:31:14 <saml> > f=~f :: Expr
06:31:15 <lambdabot>   No instances for (Text.Regex.Base.RegexLike.RegexContext
06:31:15 <lambdabot>                   ...
06:31:29 <ManateeLazyCat> saml: Change to String to compare
06:31:38 <saml> > "f"=~"f" :: Expr
06:31:39 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
06:31:39 <lambdabot>                    ...
06:32:02 <ManateeLazyCat> > "f" =~ "f" :: Bool
06:32:03 <lambdabot>   True
06:32:11 <saml> > "\x -> x"=~"\y -> y" :: Bool
06:32:11 <lambdabot>   <no location info>:
06:32:11 <lambdabot>      lexical error in string/character literal at chara...
06:32:21 <saml> > "\\x -> x"=~"\\y -> y" :: Bool
06:32:22 <lambdabot>   False
06:33:19 <ManateeLazyCat> > "hello, haskeller" =~ "hello" :: (String,String,String)
06:33:20 <lambdabot>   ("","hello",", haskeller")
06:33:30 <ManateeLazyCat> > "hello, haskeller" =~ "hello" :: (String,String,String, [String])
06:33:30 <lambdabot>   ("","hello",", haskeller",[])
06:33:50 <ManateeLazyCat> > "hello, haskeller" =~ "hello" :: (MatchOffset,MatchLength)
06:33:51 <lambdabot>   (0,5)
06:34:25 <ManateeLazyCat> > "hello, haskeller" =~ "hello" :: [String]
06:34:25 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
06:34:25 <lambdabot>                    ...
06:34:27 <ksf> > "3" *&$%^"^%$@ "x" :: Bool
06:34:28 <lambdabot>   <no location info>:
06:34:28 <lambdabot>      lexical error in string/character literal at end o...
06:34:35 <ksf> oh.
06:34:38 <ksf> > "3" *&$%^^%$@ "x" :: Bool
06:34:38 <lambdabot>   Not in scope: `*&$%^^%$@'
06:34:49 <saml> that looks like a face
06:34:56 <saml> maybe i'm hikikomori
06:34:59 <ManateeLazyCat> > "hello, haskeller" =~~ "hello" :: Maybe String
06:35:00 <lambdabot>   Just "hello"
06:35:15 <ManateeLazyCat> > "hello, haskeller" =~~ "hello" :: [String]
06:35:16 <lambdabot>   ["hello"]
06:35:24 <ManateeLazyCat> > "hello, haskeller" =~~ "hello" :: IO Int
06:35:25 <lambdabot>   <IO Int>
06:35:29 <saml> > "1" =~~~~~~~~~~~~~~~~~~~~~~~~ "1" :: Bool
06:35:30 <lambdabot>   Not in scope: `=~~~~~~~~~~~~~~~~~~~~~~~~'
06:35:47 <ManateeLazyCat> saml: Not =~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~, :)
06:35:58 <ManateeLazyCat> :t (=~~)
06:35:59 <lambdabot> forall source1 source (m :: * -> *) target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
06:36:03 <ManateeLazyCat> :t (=~~~)
06:36:04 <lambdabot> Not in scope: `=~~~'
06:36:15 <saml> that looks like a sperm
06:36:21 <ManateeLazyCat> saml: Just (=~) and (=~~)
06:36:30 <saml> baby sperms!
06:36:48 <Axman6> o~~ O~~ o-~
06:36:53 <Axman6> ~o
06:36:53 <ksf> saml, http://myanimelist.net/anime/1210/Welcome_to_the_NHK
06:37:05 <Axman6> ^^ one that didn't make it
06:37:07 <ManateeLazyCat> saml: nausea
06:37:44 <ManateeLazyCat> saml: Bye. :)
06:43:37 * ksf wonders how efficient it is to have all worker threads that map something listlike to something listlike produce the list incrementally.
06:44:00 <ksf> it certainly looks nicer to see the list build up on the screen than to wait for the whole chunk
06:56:38 <sw17ch> Is there a good method for pretty-printing the default show instances?
06:58:11 <saml> instance Show (YourType a) where show = yourTypePrettyPrint   but i think you need to implement yourTypePrettyPrint
06:58:34 <saml> yourTypePrettyPrint (Foo a) = string a
06:58:47 <sw17ch> hrm... i'm hoping to avoid implementing it myself
06:59:04 * sw17ch considers writing a parser for the default instances...
07:02:33 <ksf> @hackage ipprint
07:02:33 <lambdabot> http://hackage.haskell.org/package/ipprint
07:02:34 <ksf> use that
07:03:08 <ksf> it can word-wrap and indent everything with a show instance
07:03:52 <ksf> ...it's not fast, but reasonably pretty (for a fully automated tool)
07:07:14 <ksf> > pprint ["foo", "quuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuux", "bar"
07:07:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:07:18 <ksf> > pprint ["foo", "quuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuux", "bar"]
07:07:18 <lambdabot>   Not in scope: `pprint'
07:07:38 <ksf> @ask Cale can we have IPPrint in lambdabot?
07:07:38 <lambdabot> Consider it noted.
07:07:45 <burp> pprint is -> IO()
07:08:10 <burp> hm ok there is pshow
07:08:13 <ksf> > pshow ["foo", "quuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuux", "bar"]
07:08:14 <lambdabot>   Not in scope: `pshow'
07:08:46 <saml> > string
07:08:47 <lambdabot>   Not in scope: `string'
07:08:56 <ksf> she could even hpaste bigger outputs
07:09:24 <saml> > Text.PrettyPrint
07:09:24 <lambdabot>   Not in scope: data constructor `Text.PrettyPrint'
07:09:34 <saml> > Text.PrettyPrint.int 2
07:09:35 <lambdabot>   Not in scope: `Text.PrettyPrint.int'
07:14:10 <saml> , pshow 1
07:14:12 <lunabot>  luna: Not in scope: `pshow'
07:14:18 <saml> , pprint 1
07:14:19 <lunabot>  luna: Not in scope: `pprint'
07:14:26 <saml> , Text.PrettyPrint.int 2
07:14:27 <lunabot>  luna: Not in scope: `Text.PrettyPrint.int'
07:15:34 <McManiaC> hey, are there any good introductions on how to use the ForeignFunctionInterface (Foreign.C etc) in haskell? especially how to handle structs etc
07:15:47 <McManiaC> http://www.haskell.org/haskellwiki/FFI_Introduction i know this one but it doesnt really help me a lot
07:15:50 <ksf> McManiaC, have a look at c2hs
07:16:10 <ksf> it does much, much of the grunt work, and makes the rest of the grunt work way easier.
07:16:43 <ksf> also, note that there are new ForeignPtr functions somewhere in Control.Concurrent
07:17:14 * ksf doesn't know what drugs you have to take to put them into Control.Concurrent, though.
07:18:16 <ksf> there's also libffi, you can do everything at run-time using that.
07:18:45 <amf> hi! which package/data structure would best fit the following requirements (kind of a sorted queue): get last, delete last, insert front (only lesser elem than all present will be inserted), get front, delete front, searchfront e (find first elem >= e) ? Any ideas ?
07:19:02 <ksf> Data.Sequence
07:19:33 <McManiaC> ksf: ok ill take a look
07:19:50 <ksf> ...not sure about searchfront, though. you might need to roll your own fingertree-based sequence to get logarithmic time, as sequence doesnt' carry an ord constraint.
07:20:10 <mux> or Set ?
07:20:34 <ksf> set doesn't distinguish between min and max
07:20:53 <mux> uh? Set has findMin and findMax
07:21:12 <yottis> wasn't there some fingertree library and some bundled instances of it?
07:21:27 <mux> and wit hthe split operation you can easily remove the max/min element too
07:21:45 <ksf> http://hackage.haskell.org/package/fingertree
07:22:15 <amf> thanks, will look into all those structures, any other ideas?
07:22:24 <McManiaC> huh
07:22:41 <McManiaC> ksf: c2hs wont install with cabal :o
07:22:57 <dcoutts> McManiaC: won't it? works for me
07:23:04 <ksf> you have to install happy and alex, first, iirc
07:23:16 <ksf> cabal doesn't track dependencies on executables
07:23:21 <McManiaC> ok
07:23:58 <McManiaC> is there a reason why not?
07:24:13 <ksf> noone has implemented it yet.
07:24:32 <amf> mux: set is not ordered, is it? my 'queue' needs to be ordered.
07:24:53 <ksf> ...and the pain isn't too high, as most things cabal tracks are libraries
07:24:59 <mux> amf: it is, by virtue of its implementation
07:25:17 <mux> amf: which is why findMin and finxMax are O(log n)
07:25:42 <dcoutts> McManiaC: if you can find me a spare week in my schedule I'll implement it :-)
07:25:43 <mux> note the Ord constraint on functions returning a Set
07:25:49 <ksf> ..it's based on finitemap.
07:26:03 <mux> no, it's implemented with a balanced binary tree
07:26:36 <ksf> the haddock says it's implemented with finiteMap, and that's a...dunno.
07:26:56 <ksf> anyway, if you want O(1) insert/delete at both ends, you want a fingertree-based structure.
07:27:24 <mux> I don't see where haddock says that.. it says "The implementation of Set is based on size balanced binary trees (or trees of bounded balance)"
07:27:29 <amf> so no insert/delete at both ends  on  Set ?
07:27:42 <ksf> whoops shame on google.
07:27:47 <mux> amf: since your list is to be sorted, you have insert/delete at both ends, in a sense
07:27:50 <ksf> I'm looking at the 5.04.3 docs
07:28:30 <mux> well I'm looking at the docs of the latest version on hackage
07:28:45 * mux thinks Set is underrated
07:29:15 <ksf> maybe all you want is http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-PriorityQueue-FingerTree.html  ?
07:29:27 <sw17ch> ksf: thanks. that's what i want :)
07:29:32 <amf> mux: i see, i'd have to insert (time, value) into set. but searchfront is required to search by value
07:30:09 <mux> amf: if you map some type of elements to another type of elements, you clearly don't want Set anyways
07:30:13 <amf> ksf: will check d.pq.ft ..
07:30:44 <ksf> there don't seem to be functions to mess with the max values, but I don't think it'd be hard to add them based on the min functions.
07:33:40 <amf> i was hoping for a dynamic/extendable array/vector based dequeue with a binary search
07:34:49 <ksf> fingertrees are perfect deques
07:35:11 <ksf> ...and allow for binary search, if you annotate them properly.
07:35:41 <ksf> they're not based on arrays, though, but that'd be unusual in a pure language, anyway.
07:36:34 <ksf> (although you could consider those 1 to 4 element buckets arrays)
07:37:22 * ksf recommends having a look at the paper.
07:37:39 <sw17ch> hmmm... does IPPrint not work with record syntax?
07:37:41 <sw17ch> :(
07:37:50 <ksf> it should.
07:37:56 <sw17ch> hmm... i must be doing it wrong
07:38:02 <sw17ch> it works, but output is not what i'd expect
07:38:08 <sw17ch> (all still on one line)
07:38:09 <ksf> maybe the constructors need to be visible or something.
07:38:25 <amf> thanks, for all suggestions
07:38:29 <sw17ch> http://hackage.haskell.org/packages/archive/ipprint/0.3/doc/html/src/IPPrint.html#pprint
07:38:29 <ksf> it only breaks if nescessary
07:39:12 <ksf> make one element of your record really long and you'll see.
07:39:42 <sw17ch> what if i have lots of elements, but none are really long :\
07:39:58 <ksf> then breaking would be a waste of space...
07:40:14 <sw17ch> i was hoping to get the line wraps automagically
07:40:15 <sw17ch> oh well
07:40:23 <sw17ch> (because my data type wraps like 8 lines)
07:40:30 <sw17ch> (with all the nesting and whatnot)
07:41:04 <sw17ch> oh, there it is
07:41:04 <sw17ch> lol
07:41:07 <ksf> maybe you can tell the haskell-src prettyprinter ipprint is based on to do that.
07:41:09 <sw17ch> forgot to rebuild
07:41:12 <sw17ch> :(
07:41:20 * sw17ch facedesks
07:41:54 <ksf> yep, no magic there.
07:42:05 <ksf> show the structure, parse it as a haskell module, then use the pretty printer.
07:42:35 <sw17ch> yep, makes sense
07:44:40 * lilac honestly thinks that fingertrees are the most impressive data structure he's ever seen
07:45:06 <ksf> they could come with a generalisation to more fingers
07:45:10 <eyeris> I am trying to install the haskell platform, but it fails at "sudo make install". Could someone take a look at this and tell me what I am doing wrong? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9740#a9740
07:45:28 <lilac> ksf: would that change any of their performance characteristics?
07:46:27 <ksf> possibly. at least if you want to have fingers to the say smallest and largest elements in addition to the last-inserted and first-inserted as well as most sweet and most bitter ones.
07:47:09 <lilac> ksf: hmm, i think i see what you mean. you could possibly access other 'important' elements in constant time rather than logarithmic time
07:47:20 <ksf> exactly
07:47:25 <lilac> at the expense of a higher constant for all update operations :-/
07:47:44 <lilac> you can build that structure out of a fingertree easily enough, by wrapping all the operations with ones which update the 'extra fingers'
07:47:53 <Botje> eyeris: can you do "sudo runhaskell packages/Setup.hs install" ?
07:48:01 <Botje> errr
07:48:10 <Botje> packages/mtl-1.1.0.2/Setup.hs
07:48:11 <Botje> even
07:48:16 <lilac> that'd make the operations O(f log n) where f is the finger count, though
07:48:23 <ksf> you can. but you can also set a root-command somewhere in your ~/.cabal/config
07:48:36 <ksf> it will build as user then, and install as root.
07:48:43 <eyeris> Botje: It says: Setup.hs: Run the 'configure' command first.
07:49:04 <arw_> eyeris: did you install the extralibs for ghc before building the platform?
07:49:10 <ksf> install runs configure first. did you use build?
07:49:24 <arw_> eyeris: if so, leave out the extralibs from ghc.
07:49:39 <Saizan> ksf: he's not using cabal-install he's using the haskell platform build system
07:50:03 <eyeris> arw_: I have no idea what extralibs is. It wasn't in the installation instructions.
07:50:29 <arw_> eyeris: it isn't, its only a problem if you build ghc by yourself.
07:50:31 <ksf> setup.hs isn't interested in ~/.cabal/config?
07:51:14 <eyeris> arw_: I didn't. I installed it from the binary packages at haskell.org.
07:51:14 <dcoutts> ksf: correct
07:51:27 <McManiaC> dcoutts: oh ok hehe
07:52:15 <McManiaC> i still fail to see how you can use structs with that c2hs
07:52:29 <ksf> McManiaC, get and set hooks
07:52:35 <dcoutts> Setup.hs is like a ./configure script, it does not have any global config file, it just takes inputs directly. Your package manager has a config file, and so does cabal-install.
07:52:38 <ksf> it's not fully automatic.
07:52:41 <McManiaC> and use pointers for the struct?
07:52:47 <ksf> yep.
07:53:21 <ksf> ...you have to have a pointer for everything you want to handle with haskell, anyway.
07:53:49 <McManiaC> hmm and how would you import a function like "MyStruct foo() { /* return somestruct; */ }" ?
07:54:21 <McManiaC> or would you *have* to convert this into sth like MyStruct * foo()...?
07:54:37 <ksf> (and most C structs contain things that you don't want to expose, anyway. like the pitch of a 2-dimensional *char, which you most likely want to memcpy/turn into an array)
07:55:05 <McManiaC> hmmm
07:55:09 <ksf> McManiaC, if you have such a function, the author didn't know a bit about C.
07:55:10 <McManiaC> i'm really not good at C :S
07:55:20 <ksf> ...one doesn't return pointers to local variables.
07:55:36 <saml> unless it's mallocced
07:55:40 <ksf> if you want to return a struct, take a pointer to an empty one as argument, and then write to it.
07:55:45 <saml> or you have to pass the pointer
07:55:59 <McManiaC> ok
07:56:26 <eyeris> I tracked down why mtl isn't being configured. It is skipped because it is already installed. So it knows to skip the configure and the build steps but not the install step. Retarded.
07:56:32 <McManiaC> and i create an empty struct with that {#pointer ..#} construct?
07:56:33 <ksf> passing by reference is usually preferred, as you leave it up to the caller whether he wants a malloced piece or something on his stack.
07:56:47 <ksf> McManiaC, alloca
07:56:56 <ksf> ...or mallocBytes.
07:57:06 <ksf> you can get the size of a struct with a sizeof hook.
07:57:14 <McManiaC> i mean inside my .hs file
07:58:05 <Saizan_> eyeris: file a ticket
07:58:25 <McManiaC> ksf: do you have any example on how to use this?
07:58:27 <eyeris> Saizan_: I would, but the bug tracker seems to be down.
07:58:33 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9741#a9741
07:59:05 <ksf> uh.
07:59:22 <ksf> while that's a struct, I'm actually treating it as a CLong array, which it is, too.
07:59:39 <ksf> but the principle stays the same.
08:00:44 <McManiaC> could i see the related c-file too?
08:01:11 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9741#a9743   that's extracting some useful information
08:02:18 <ksf> the extra work usually pays off fast as the marshalled stuff works as expected in the rest of the code
08:02:52 <ksf> (and is referentially transparent, which wouldn't be the case if I didn't memcpy that data there)
08:02:57 <Orclev> the FFI is both really easy, and a real pain... most simple variables work fine, but working with structs and doing some of the fancier things can get a little nasty
08:03:59 <ksf> since we got the new newForeignPtr functions there's nothing that destroys grace, though.
08:04:50 <McManiaC> hmmm
08:05:28 <Orclev> dcoutts: hey, if you have a few minutes I showed this to copumpkin and he thought I might want to run it past you and get your feedback: http://github.com/orclev/versioningidea
08:07:13 <dcoutts> Orclev: have you read the http://haskell.org/haskellwiki/Package_versioning_policy ?
08:08:07 <Orclev> dcoutts: not yet, the idea is actually one I've had for a long time, even before I started learning haskell, I just wrote it up as a haskell implementation
08:08:35 <dcoutts> Orclev: from a brief first reading it looks similar to the PVP
08:09:08 <khufu> is tehre such a thing as a nice interactive shell with hilighting?
08:09:18 <dcoutts> Orclev: namely to shift the responsibility to the lib author (rather than author of a client of the lib) to explain how the API changes in compatible and incompatible ways
08:09:39 <Orclev> dcoutts: it's similar in purpose to the ideas behind the major, minor, etc, but designed to take a bit of the guesswork out of things
08:10:01 <dcoutts> Orclev: the PVP gives a precise meaning to the major, minor etc
08:10:14 <ksf> khufu, you can pipe ghci's output through hscolour...
08:10:22 <dcoutts> in terms of API changes, compatible and incompatible
08:10:48 <saml> maybe leksah has repl
08:10:54 <ksf> nope
08:10:54 <Orclev> dcoutts: yes, but often times a particular package that only uses a subset of a libraries capabilities can get away with using many versions even through major number changes
08:10:55 <khufu> ksf, uh, how?
08:11:17 <dcoutts> Orclev: that's quite true
08:11:45 <dcoutts> Orclev: and a version number gives too much of a conservative approximation in that case
08:11:59 <ksf> khufu, http://haskell.org/haskellwiki/GHCi_in_colour
08:12:05 <mmorrow> khufu: [m@monire ~]$ ghci | HsColour -tty
08:12:09 <b52> hey fellas
08:12:14 <saml> hey b52
08:12:20 <mmorrow> khufu: but that doesn't play nice with e.g. backspace :(
08:12:39 <b52> im actually reading http://learnyouahaskell.com/ and im asking my self if there are some nice exercies i could try to do while im reading it?
08:12:39 <Orclev> dcoutts: as a nice side effect this system also makes the library author more aware of possible compatability breaking changes
08:12:49 <mmorrow> khufu: so it's not really a solution
08:14:00 <ksf> ...doesnt' seem to work, anymore.
08:14:56 <Orclev> dcoutts: part of the reason I got thinking about this again was an issue with frag where a new release of the OpenGL bindings has broken it, but the cabal file is out of date because it doesn't have an upper bound on the OpenGL version yet
08:16:01 <ksf> input isn't coloured on my machine, at all.
08:16:09 <ksf> I guess haskellline or something broke the hack.
08:16:45 <mmorrow> i tried at one point to add an IORef to the ghc module which inserts the implicit `print' wrapper (at the AST level) around the code you type at the ghci prompt, which is then conpiled to bytecode, where this IORef held the Name (a ghc type) of the function to use in place of "print", but since ghci links in a whole new copy of everything, modifying that IORef wasn't modifying the one ghci was using, just the newly linked in copy
08:16:47 <msteele_> b52, I solve Project Euler problems for practice.  http://projecteuler.net
08:16:49 <mmorrow> so that was a fail
08:17:09 <saml> b52, http://www.haskell.org/haskellwiki/99_Haskell_exercises
08:18:11 <dcoutts> Orclev: right, the other part of our idea with the PVP is that it becomes possible to state what the upper bound should be.
08:18:35 <Laney> does cabal have an IRC channel?
08:18:42 <mmorrow> it should
08:18:46 <mmorrow> (but doesn't)
08:18:49 <dcoutts> Laney: we mostly use the ghc channel
08:18:56 <Laney> alright
08:18:59 * Laney sprints over there
08:19:23 <mmorrow> dcoutts: i think a #cabal would encourage cabal hacking
08:19:43 <mmorrow> cabal-proper, as opposed to cabal-wrt-ghc
08:19:57 <dcoutts> mmorrow: mm, maybe
08:20:10 <Orclev> mmorrow: does anyone who isn't using ghc use cabal?
08:20:39 <mmorrow> Orclev: i just mean the cabal infrastructure/features/whatnot itself
08:20:46 <Orclev> mmorrow: ah, ok
08:23:01 <Orclev> dcoutts: another drive behind this is that it's independent of any versioning system, that is cabal can utilize the info, but so could a third party... it would also mean that dependency info could be left out of the cabal file and be dynamically generated from the compiled binary
08:23:40 <Orclev> dcoutts: it's even available at run time should such info be useful in some way
08:25:39 <linduxed> hey guys
08:25:58 <Orclev> dcoutts: anyway, aside from a great deal of overlap with the intention of the versioning conventions for packages, do you see any other problems with the idea?
08:26:34 <linduxed> i was wondering if i someone could explain or point me to a guide where this is explained:
08:26:34 <linduxed> tmp1 = map (map (\x -> ((head x), (length x))) . group . sort) (transpose strs)
08:26:40 <orbitz> what do people mean when they say say non-von Neumann programming model?
08:26:47 <linduxed> what are the dots close to group?
08:26:55 <orbitz> linduxed: function composition
08:26:56 <linduxed> what do they do, how do they work
08:27:02 <Orclev> :t (.)
08:27:02 <linduxed> orbitz: ok
08:27:02 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:27:14 <orbitz> (f . g) x = f (g x)
08:27:26 <Orclev> linduxed: they take two functions, and combine them into one function... more or less
08:27:54 <linduxed> Orclev: hmmm, will check my tutorial for function composition...
08:28:50 <dcoutts> Orclev: I guess the main issue is how does all this annotation info get generated
08:29:32 <dons> CUFP videos are  now up, http://www.reddit.com/r/programming/comments/9ncbg/commercial_users_of_functional_programming/
08:29:44 <Orclev> dcoutts: did you look at the example module and program on there?
08:29:49 <dons> including dcoutts on why we should invest in shared open source infrastructure
08:29:51 <Makoryu> linduxed: Also, (\foo -> bar) is a lambda expression, which evaluates to an anonymous function that takes the argument "foo" and does "bar"
08:30:06 <dcoutts> dons: :-)
08:30:22 <dcoutts> dons: btw, I've also linked that from the IHG status page
08:30:31 <Twey> (\foo -> bar) ≡ const bar
08:30:33 <dcoutts> (and a W-T blog post)
08:30:49 <mmorrow> dons, dcoutts: ooh, nice
08:30:51 <linduxed> Makoryu: i think i can handle lamba expressions, kinda
08:30:54 <linduxed> Makoryu: but thx
08:31:00 * RayNbow wonders if Microsoft's new Courier (prototype?) device will run GHC...
08:31:04 <Twey> Haha
08:31:14 <Twey> ‘Lambda expressions: can *you* handle them‽’
08:31:26 <Orclev> dcoutts: it's based on the new annotation system that's supposed to be in 6.12... in practice a lot of it could be handled by utilities much like the -auto-all ghc flag handles inserting cost center annotations
08:31:31 <mmorrow> i'm digging malcolmw's vimeo page as well
08:31:53 <dons> dcoutts: excellent
08:31:59 <dons> dcoutts: worth sending to the members too
08:32:23 <dcoutts> dons: I sent it to Amgen already, the others saw the talk live :-)
08:32:42 <dons> great
08:33:10 <fr0ggler> I'm trying to parse some xml using hexpat, and i'm coming into trouble with namespaces. I'm trying to retrieve a certain element from the XML, and upon showing the hexpat-parsed XML, i can see the element looks like:
08:33:11 <fr0ggler> {eName = NName {nnNamespace = Just "http://www.w3.org/2002/07/owl#", nnLocalPart = "Ontology"}
08:33:43 <Makoryu> linduxed: Just making sure :p
08:34:10 <mmorrow> heh, "The Big Board"
08:34:21 <mmorrow> "but he'll see the big board!!"
08:34:26 <fr0ggler> however, when I try and grab this element, i get:
08:34:27 <fr0ggler> can't find <NName {nnNamespace = Just "http://www.w3.org/2002/07/owl#", nnLocalPart = "Ontology"}>
08:34:38 <linduxed> Makoryu: hey, im too worthless for not making sure, so keep em coming
08:34:39 <fr0ggler> now i'm not that sharp, but those two elements look the same to me :)
08:40:43 <Orclev> dcoutts: in theory the bare minimum to use the system would be to provide a version number for your modules, and then the compatability info if not given could just default to Partial X.0.0, Full X.Y.0 which would be consistent with the packaging conventions
08:41:18 <ksf> linduxed,
08:41:20 <ksf> > let f = (toUpper.) in f intToDigit 3
08:41:21 <lambdabot>   '3'
08:41:23 <ksf> explain.
08:41:24 <mmorrow> dons: http://downforeveryoneorjustme.com/http://code.haskell.org
08:42:29 <linduxed> ksf: wow, that's heavy...
08:42:33 <linduxed> ksf: hmmm
08:42:34 <ksf> even better,
08:42:38 <ksf> > let f = (toUpper.) in f intToDigit 15
08:42:38 <lambdabot>   'F'
08:42:39 <saml> > intToDigit 3
08:42:40 <lambdabot>   '3'
08:42:55 <saml> > intToDigit 15
08:42:55 <lambdabot>   'f'
08:43:10 <saml> > '안'
08:43:11 <lambdabot>   '\50504'
08:43:20 <saml> > intToDigit 50504
08:43:20 <lambdabot>   * Exception: Char.intToDigit: not a digit 50504
08:43:29 <saml> > intToDigit 14
08:43:30 <lambdabot>   'e'
08:43:36 <ksf> it's only defined up to hex
08:43:36 <saml> > intToDigit 10
08:43:37 <lambdabot>   'a'
08:44:04 <saml> @hoogle intToDigit
08:44:04 <lambdabot> Data.Char intToDigit :: Int -> Char
08:44:10 <ksf> there's a base-80 or something proposal for ipv6, though.
08:44:24 <Orclev> base-80?
08:44:32 <saml> Convert an Int in the range 0..15 to the corresponding single digit Char. This function fails on other inputs, and generates lower-case hexadecimal digits.
08:45:15 <ksf> :t (toUpper .)
08:45:16 <lambdabot> forall a. (a -> Char) -> a -> Char
08:45:23 <saml> > map intToDigit [0..15]
08:45:24 <lambdabot>   "0123456789abcdef"
08:45:36 <Orclev> for most instances I've found it simpler to use printf because then you don't need to worry about figuring out any leading 0s and such
08:45:38 <saml> that's base 16
08:45:57 <saml> it should be naked intToHexDigit
08:46:01 <saml> wait.. isn't Digit related to 10?
08:46:17 <ksf> pad x n ys = replicate (n - length ys) x ++ ys
08:46:19 <Orclev> that's the origin, but not the meaning
08:46:37 <ksf> "digit" means "finger"
08:46:42 <Twey> It's not even the origin
08:46:43 <Orclev> ksf: that too
08:46:44 <Twey> Right
08:46:45 <saml> no, index means finger
08:46:56 <Twey> saml: ‽
08:46:59 <ksf> greek or latin?
08:47:04 <Twey> Latin
08:47:06 <Orclev> :t ord
08:47:06 <Twey> ‘Digitus’
08:47:06 <lambdabot> Char -> Int
08:47:12 <saml> oh i'm wrong
08:47:14 <Orclev> > ord 'a'
08:47:14 <Makoryu> Phalanx is Greek for finger (plural phalanges)
08:47:15 <lambdabot>   97
08:47:15 <Twey> (‘DIGITVS’)
08:47:36 <burp> > intToDigit 8253
08:47:36 <lambdabot>   * Exception: Char.intToDigit: not a digit 8253
08:47:49 <ksf> ...but "digit" has nothing to do with "decimal"
08:48:08 <saml> > let i (I# i) | otherwise = 1
08:48:08 <lambdabot>   not an expression: `let i (I# i) | otherwise = 1'
08:48:15 <saml> > let i (I# i) | otherwise = 1 in i 2
08:48:15 <lambdabot>   Not in scope: data constructor `I#'
08:48:49 <ksf> and it wouldn't make much sense, anyway. you can represent 2^10  different numbers with your fingers.
08:49:09 <ksf> if you've got some more control, even up to 4^10
08:51:05 <Orclev> > ord 0
08:51:05 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:51:05 <lambdabot>    arising from the literal `0...
08:51:14 <Orclev> > ord '0'
08:51:15 <lambdabot>   48
08:51:19 <ksf> > chr 0
08:51:19 <lambdabot>   '\NUL'
08:51:23 <Orclev> > ord '9'
08:51:23 <lambdabot>   57
08:51:32 <Orclev> hmm
08:51:42 <Orclev> well, there goes that idea
08:51:49 <ksf> @check (\c -> ord c == fromEnum c)
08:51:50 <lambdabot>   "OK, passed 500 tests."
09:01:20 <mmaruseacph2> why 500 tests?
09:01:37 <mmaruseacph2> Ascii has 128 or 256 and unicode many more
09:01:57 <aavogt> @check \x -> x < 300
09:01:57 <lambdabot>   "OK, passed 500 tests."
09:02:18 <Saizan_> @check () == ()
09:02:18 <lambdabot>   "OK, passed 500 tests."
09:02:20 <Orclev> I think it just picks 500 values at random
09:02:31 <aavogt> small values too
09:02:50 <mmorrow> dolio: ping
09:02:56 <Orclev> I think it's looking for errors, not the return value
09:03:10 <Makoryu> ASCII has 128
09:03:11 <Orclev> hmm, well, maybe not
09:03:13 <int-e> > filter (\a -> ord a /= fromEnum a) [chr 0..]
09:03:15 <lambdabot>   ""
09:03:22 <Makoryu> > [chr 0 .. chr 127]
09:03:22 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
09:03:58 <Orclev> @check 1 == 0
09:03:59 <lambdabot>   "Falsifiable, after 0 tests:\n"
09:04:04 <Orclev> lol
09:04:06 <burp> > (<**>) (Just 2) $ (-) <$> (Just 1)
09:04:06 <mmorrow> , [$bf|.+[.+]|] []
09:04:07 <lambdabot>   Just (-1)
09:04:08 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
09:04:39 * mmorrow loves pulling out his one-trick-pony brainfuck skillz whenever he can
09:05:01 <Orclev> I looked a branfuck once... once
09:05:12 <Orclev> brainfuck even
09:05:38 <Orclev> they named that one right... it's nearly as bad as RPG
09:05:44 <Badger> @bf >+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]
09:05:44 <lambdabot>   Hello
09:05:44 <Badger> >++++++++[<++++>-] <.>+++++++++++[<++++++++>-]<-.--------.+++
09:05:50 <int-e> does it have an unlambda quasiquoter, too?
09:06:08 <dons> i encourage everyone to sit back and enjoy the mellow tones of bos, http://www.vimeo.com/6703480
09:06:17 <dons> then take action and change the world with your codes
09:06:51 <mmorrow> int-e: no, but if you have one i'll add it
09:07:10 <burp> @bf +++
09:07:10 <lambdabot>  Done.
09:07:19 <mmorrow> , [$bf|>+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]|] ""
09:07:21 <lunabot>  "Hello"
09:07:26 <mmorrow> , [$bf2|>+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]|] ""
09:07:28 <lunabot>  ("Hello",(0,Mem (fromList [(0,0),(1,0)])))
09:07:32 <burp> @bf +++.
09:07:32 <lambdabot>  Done.
09:08:11 <mmorrow> , fmap [$bf|+.|] ['a'..'e']
09:08:13 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Char]'
09:08:18 <saml> , print "> 1"
09:08:20 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
09:08:22 <mmorrow> , fmap ([$bf|+.|] . (:[])) ['a'..'e']
09:08:24 <lunabot>  ["\SOH","\SOH","\SOH","\SOH","\SOH"]
09:08:26 <mmorrow> grr
09:08:29 <saml> , putStrLn "> 1"
09:08:30 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
09:08:33 <burp> how would you print 5 in brinfuck?
09:08:41 <mmorrow> , fmap ([$bf|,+.|] . (:[])) ['a'..'e']
09:08:43 <lunabot>  ["b","c","d","e","f"]
09:09:02 <int-e> @bf +++++[>+++++++++++<-]>+++.
09:09:02 <lambdabot>   :
09:09:17 <Orclev> that video of bos is buffering really slow
09:10:01 <ksf> Orclev, not here.
09:10:39 <int-e> , [$bf|[+.>]|] "abcde"
09:10:40 <lunabot>  ""
09:10:50 <int-e> oh.
09:11:02 <int-e> , [$bf|,[+.,]|] "abcde"
09:11:04 <lunabot>  "bcdef*** Exception: bf blocked on input"
09:11:18 <int-e> , [$bf|,+[.,+]|] "abcde"
09:11:20 <lunabot>  "bcdef*** Exception: bf blocked on input"
09:11:22 <int-e> :(
09:11:30 <mmorrow> it loops until it sees a 0
09:11:30 <Orclev> hmm... I bet they use a geocaching service... the only downside to using opendns is it breaks geocaching
09:11:41 <mmorrow> , [$bf|,+[.,+]|] "abcde\0"
09:11:43 <lunabot>  "bcdef\SOH*** Exception: bf blocked on input"
09:11:45 <int-e> should return -1 on eof
09:11:47 <mmorrow> grr
09:11:54 <int-e> wrong version :)
09:12:11 <int-e> , [$bf|,[+.,]|] "abcde\0"
09:12:12 <lunabot>  "bcdef"
09:12:13 <mmorrow> , [$bf|,[+.,]|] "abcde\0"
09:12:15 <lunabot>  "bcdef"
09:12:15 <mmorrow> heh
09:16:06 <burp> @bf +.
09:16:06 <lambdabot>  Done.
09:16:12 <burp> shouldn't this print something like 1?
09:16:17 <mmorrow> yeah
09:16:28 <mmorrow> , [$bf|+.|] ""
09:16:29 <int-e> ^A really
09:16:30 <lunabot>  "\SOH"
09:16:39 <mmorrow> , ord ([$bf|+.|] "")
09:16:40 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
09:16:45 <mmorrow> , fmap ord ([$bf|+.|] "")
09:16:47 <lunabot>  [1]
09:16:49 <int-e> @bf +++++++[>+++++++<-]>.
09:16:49 <lambdabot>   1
09:16:59 <int-e> @bf +++++++[>+++++++<-]>+.
09:16:59 <lambdabot>   2
09:17:07 <burp> ah you need the ascii 1
09:17:07 <int-e> and so on.
09:17:16 <mmorrow> , '\1'
09:17:18 <lunabot>  '\SOH'
09:17:20 <burp> yup :>
09:17:28 <mmorrow> , macBound :: Char
09:17:30 <lunabot>  luna: Not in scope: `macBound'
09:17:31 <mmorrow> , maxBound :: Char
09:17:32 <lunabot>  '\1114111'
09:18:09 <mmorrow> , chr (1114111+1)
09:18:10 <lunabot>  luna: Prelude.chr: bad argument
09:18:27 <int-e> @bf -
09:18:27 <lambdabot>  Done.
09:18:41 <int-e> , [$bf|-|] ""
09:18:43 <lunabot>  ""
09:18:46 <trzkril> @bf -.
09:18:46 <lambdabot>  Done.
09:18:48 <int-e> , [$bf|-.|] ""
09:18:50 <lunabot>  luna: Prelude.chr: bad argument
09:19:23 <burp> @bf ++++++++++ ++++++++++ ++++++++++ ++++++++++ +++++++++ .
09:19:24 <lambdabot>   1
09:20:05 <mmorrow> , [$bf2|-|] ""
09:20:07 <lunabot>  ("",(0,Mem (fromList [(0,-1)])))
09:20:24 <mmorrow> , [$bf2|->->->->-->->+|] ""
09:20:26 <lunabot>  ("",(6,Mem (fromList [(0,-1),(1,-1),(2,-1),(3,-1),(4,-2),(5,-1),(6,1)])))
09:21:35 <byorgey> heh, nice =)
09:21:54 <mmorrow> (http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.5/doc/html/src/Language-Haskell-Meta-QQ-BF.html)
09:22:04 <Berengal> Am I right in thinking you need at least one token lookbehind to match /^/ ?
09:22:24 <int-e> , [$bf2|+[+>>[>]+<[-<]<]>++]
09:22:25 <lunabot>  luna: lexical error in string/character literal at end of input
09:22:31 <int-e> , [$bf2|+[+>>[>]+<[-<]<]>++|]
09:22:32 <lunabot>  luna: No instance for (GHC.Show.Show
09:22:37 <int-e> , [$bf2|+[+>>[>]+<[-<]<]>++|] ""
09:22:37 <mmorrow> (String -> String)
09:22:43 <lunabot>  Killed.
09:23:03 <burp> , [$bf | , ] "hello"
09:23:04 <lunabot>  luna: parse error on input `,'
09:23:21 <mmorrow> ooh, i almost forgot. here's rwbarton's brainfuck compiler that outputs an (x86) ELF .o file:
09:23:21 <burp> , [$bf | ,  |] "hello"
09:23:22 <lunabot>  luna: parse error on input `,'
09:23:35 <mmorrow> http://moonpatio.com/repos/brain/
09:23:47 <int-e> , [$bf2|+++++[>+++++++<-]>[->>[>]+<[-<]<]>++|] ""
09:23:49 <lunabot>  ("",(2,Mem (fromList [(0,0),(1,0),(2,2),(3,1),(4,1),(5,0),(6,0),(7,0),(8,...
09:23:55 <burp> , [$bf|,|] "hello"
09:23:57 <lunabot>  ""
09:24:07 <burp> hm, I expected it to print "h" or something
09:24:10 <mmorrow> , [$bf2|,.|] "hello"
09:24:12 <lunabot>  ("h",(0,Mem (fromList [(0,104)])))
09:24:14 <burp> ah yes sure
09:24:26 <burp> it's quite easy :>
09:24:58 <mmorrow> , [$bf2|<[>,.]|] "hello"
09:24:59 <lunabot>  ("",(-1,Mem (fromList [])))
09:25:17 <mmorrow> , [$bf2|>[>,.]|] "hello\0"
09:25:18 <lunabot>  ("",(1,Mem (fromList [])))
09:25:22 <mmorrow> err
09:25:41 <burp> hm, shouldn't that print the whole string?
09:25:41 <mmorrow> oh
09:25:52 <mmorrow> , [$bf2|+[>,.]|] "hello\0"
09:25:53 <lunabot>  ("hello\NUL",(6,Mem (fromList [(0,1),(1,104),(2,101),(3,108),(4,108),(5,1...
09:26:01 <tinLoaf> is something wrong with this haskell code: http://pastebin.com/m4d690a44 ?
09:26:12 <tinLoaf> I'm getting a "Data constructor Maybe not in scope"
09:26:30 <burp> , [$bf2|,[.,]|] "hello\0"
09:26:30 <tinLoaf> i even imported Data.Maybe, although i think that the maybe constructor should be in prelude
09:26:31 <lunabot>  ("hello",(0,Mem (fromList [(0,0)])))
09:26:39 <aavogt> tinLoaf: use Just
09:26:43 <byorgey> tinLoaf: Maybe is not a data constructor, it is a type.
09:26:45 <tinLoaf> errrr
09:26:46 <aavogt> Maybe is th type
09:26:50 <byorgey> you probably mean (Just (k,v))
09:26:56 <tinLoaf> sometime i want to bang my head against a wall ;)
09:26:57 <tinLoaf> thanks
09:27:01 <burp> , [$bf2|[.,]|] "hello\0"
09:27:02 <lunabot>  ("",(0,Mem (fromList [])))
09:27:06 <byorgey> tinLoaf: hehe =)
09:27:26 <byorgey> tinLoaf: I've made that mistake before.
09:27:26 <burp> , [$bf2|,[.,+++++++++++++]|] "hello\0"
09:27:28 <lunabot>  ("*** Exception: bf blocked on input",(-1,Mem (fromList [])))
09:27:43 <burp> hm, something like rot13 should be easily done
09:27:53 <int-e> , [$bf|,[[->>[>]+<[-<]<]++++++++[>++++++[>++++++++<-]>.[-]<<-[>+<-]>].,]|] "01\0"
09:27:55 <lunabot>  "00001100\NUL10001100\NUL"
09:29:17 <holmak> @djinn (a -> b -> c) -> (a -> b) -> a -> b
09:29:17 <lambdabot> f _ a b = a b
09:29:57 <holmak> bad lambdabot, lazy
09:35:18 <doserj> holmak: what did you expect?
09:35:45 <mmorrow> iirc the actual djinn prog'll print out a bunch of possibilities
09:35:54 <dons> dcoutts_: doaitse on the list needs cabal help
09:37:28 <holmak> doserj: thats actually the type signature of the S combinator
09:37:34 <doserj> holmak: it is not
09:37:38 <holmak> i was hoping djinn would spit it out
09:37:41 <holmak> no?
09:37:48 <doserj> typo at the end
09:37:49 <holmak> well, its what ghci claims
09:38:15 <mmorrow> , [$ski|[f::Expr->Expr->Expr][g][x::Expr]|]
09:38:19 <lunabot>  f g x
09:38:21 <doserj> @djinn (a -> b -> c) -> (a -> b) -> a -> c
09:38:21 <lambdabot> f a b c = a c (b c)
09:38:23 <mmorrow> grr
09:38:25 <mmorrow> , [$ski|S[f::Expr->Expr->Expr][g][x::Expr]|]
09:38:27 <holmak> aha
09:38:28 <lunabot>  f x (g x)
09:38:34 <holmak> thats my bad
09:38:39 <holmak> @djinn (a -> b -> c) -> (a -> b) -> a -> c
09:38:39 <lambdabot> f a b c = a c (b c)
09:38:43 <holmak> nice
09:38:53 <doserj> @type ap
09:38:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:39:07 <doserj> for m = (->) c, of course
09:39:50 <holmak> I was reading up on Applicative, which is the reason for my sudden interest in combinators
09:40:08 <doserj> @type (<*>)
09:40:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:41:02 <doserj> @. pl djinn (a -> b -> c) -> (a -> b) -> a -> c
09:41:02 <lambdabot> f = ap
09:41:50 <saml> > (+1) `ap` 2
09:41:51 <lambdabot>   No instance for (GHC.Num.Num ((a -> b) -> a))
09:41:51 <lambdabot>    arising from the literal `...
09:42:33 <saml> > ap (-) (+1) 1
09:42:34 <lambdabot>   -1
09:43:19 <saml> > (\x -> ap (-) (+1) x) :: Expr
09:43:19 <lambdabot>   The lambda expression `\ x -> Control.Monad.ap
09:43:19 <lambdabot>                             ...
09:43:39 <roconnor> > ap (-) (+1) x
09:43:39 <lambdabot>   x - (x + 1)
09:43:43 <Makoryu> > (-) `ap` (+1) $ 1
09:43:44 <lambdabot>   -1
09:44:02 <roconnor> > deriv (sin . cos) x
09:44:03 <lambdabot>   1 * negate (sin x) * cos (cos x)
09:44:34 <saml> > deriv 1
09:44:35 <lambdabot>   No instance for (GHC.Num.Num
09:44:35 <lambdabot>                     (Data.Number.Dif.Dif a -> ...
09:44:38 <saml> > deriv x
09:44:39 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
09:44:39 <lambdabot>                        ...
09:44:51 <roconnor> saml: take derivative of a function
09:44:56 <doserj> > deriv (const x)
09:44:57 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif b'
09:44:57 <lambdabot>         against inferr...
09:45:06 <roconnor> and evaluate it somewhere
09:45:26 <burp> > deriv (const x) y
09:45:27 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif b'
09:45:27 <lambdabot>         against inferr...
09:45:27 <saml> > deriv (\x -> x)
09:45:28 <lambdabot>   {-3->1;-2->1;-1->1;0->1;1->1;2->1;3->1}
09:46:06 <roconnor> @type deriv (const x)
09:46:07 <lambdabot>     Couldn't match expected type `Dif b' against inferred type `Expr'
09:46:07 <lambdabot>     In the first argument of `deriv', namely `(const x)'
09:46:07 <lambdabot>     In the expression: deriv (const x)
09:46:19 <doserj> > deriv (const 1) x
09:46:19 <roconnor> @type (const x)
09:46:20 <lambdabot> forall b. b -> Expr
09:46:20 <lambdabot>   0
09:46:46 <roconnor> oh, I guess you can't have expression variables in the function you want to take the derivative of
09:47:05 <doserj> > deriv id x
09:47:06 <lambdabot>   1
09:47:25 <doserj> fair enough
09:47:46 <int-e> burp: writing a short rot13 is actually a bit of a challenge - conditionals aren't easy.
09:51:54 <copumpkin> > deriv (\x -> 2 * x)
09:51:55 <lambdabot>   {-3->2;-2->2;-1->2;0->2;1->2;2->2;3->2}
09:53:08 <LeoD> nice
09:53:29 <LeoD> > deriv (*2) 100000
09:53:30 <lambdabot>   2
09:53:43 <LeoD> > deriv (\x -> x*x) 10
09:53:44 <lambdabot>   20
09:53:55 <LeoD> > deriv (\x -> sqrt x) 10
09:53:56 <lambdabot>   0.15811388300841897
09:55:22 <hydo> I'm not sure it's healthy to be this excited about HacPDX.
09:55:32 <burp> int-e: after thinking about it I figured out it's not that easy :|
09:55:51 <burp> naive I thought about +[,+++++++++++++.]
09:55:56 <burp> but that will loop forever :>
09:57:17 <lilac> burp: we playing brainfuck?
09:57:33 <burp> nah, we're back at haskell
09:57:51 <aug_triad> Hi, I have a simple question, though I couldn't find a solution... If the type constructor says type PMap a = PlayerName -> Player a, and PlayerName have type String, how should I use the PMap datatype in a function? By now I have only seen a type without the arrow. E.g. I would thought that I could use it like: perform ("bimlebamle" defPlayer) ... ..., when perform :: PMap -> ... -> .... Sure it should be easy :)
09:58:01 * ksf thinks he urgently needs to go shopping, or there won't be any wine this evening.
10:00:20 <c_wraith> aug_triad:  that's a type alias, not a constructor of any sort
10:02:14 <aug_triad> c_wraith: Ok, it's not a constructor, but how do I use it in a function?
10:03:53 <c_wraith> x :: PMap a -> PlayerName -> Player a ; x m name = m name
10:04:09 <c_wraith> Is the extremely trivial example.
10:04:12 <lilac> aug_triad: if you have 'type PlayerName = String' and 'type PMap a = PlayerName -> Player a' then a value of type PMap a is a function from String to a. so call it, passing in a string
10:05:18 <lilac> aug_triad: for instance, f :: PMap Int -> PlayerName -> PlayerName -> Int; f pmap a b = pmap a + pmap b
10:05:31 <dcoutts> dons: which mailing list was doaitse asking for help on?
10:05:39 <lilac> urg
10:05:43 <c_wraith> lilac, that doesn't work.
10:05:52 <c_wraith> You get a Player Int out of those
10:06:06 <lilac> c_wraith: yeah, in retrospect my 'urg' comment could have said that more explicitly ;-)
10:06:10 <c_wraith> :)
10:06:36 <lilac> c_wraith: 'urg' was more 'to fix this i need an Applicative instance for Player...'
10:07:05 <lilac> '... this example is not helpful any more'
10:08:55 <sm> hlint rocks!
10:09:11 <sm> neil mitchell++
10:09:24 <c_wraith> @karma neil mitchell
10:09:24 <lambdabot> neil has a karma of 0
10:09:41 <c_wraith> aww.  you can't give karma to someone with a space in their name
10:09:47 <shapr> @karma ndm
10:09:47 <lambdabot> ndm has a karma of 0
10:09:50 <shapr> weird
10:09:51 <sm> I can't remember his nick
10:09:57 <shapr> @karma+ ndm
10:09:58 <lambdabot> ndm's karma raised to 1.
10:10:01 <shapr> @karma dons
10:10:01 <lambdabot> dons has a karma of 10
10:10:04 <shapr> @karma shapr
10:10:04 <lambdabot> You have a karma of 3
10:10:06 <shapr> bah
10:10:19 <saml> @karma+ saml
10:10:19 <lambdabot> You can't change your own karma, silly.
10:10:27 <dons> dcoutts: -cafe I think
10:10:39 <sm> ndm++
10:10:44 <c_wraith> Well, that just encourages nick abuse
10:11:18 * sm notes the ++ works but doesn't report the change
10:11:20 <tinLoaf> can i somehow use a type variable from a function's signature in the function itself?
10:11:42 <tinLoaf> e.g. in http://pastebin.com/m4730f83a , it seems not to know k
10:11:57 <c_wraith> If the function's signature has a type variable in it, you can't do anything with that type.
10:12:02 <tinLoaf> i'm getting "Could not deduce (Bounded k1) from the context ()"
10:12:03 <c_wraith> (in the function)
10:12:05 <opqdonut> tinLoaf: scoped type variables
10:12:11 <lilac> @karma mitchell
10:12:11 <lambdabot> mitchell has a karma of 1
10:12:17 <opqdonut> tinLoaf: is a language extension that allows precisely that
10:12:28 <tinLoaf> opqdonut: thanks for the hint
10:12:44 <c_wraith> Oh.  I see the use.  Yeah, that's a handy one.
10:12:50 <opqdonut> tinLoaf: but that ::k is not needed as it can be inferred
10:13:15 <tinLoaf> opqdonut: just a "minBound" would be enough?
10:13:21 <sm> why does hlint want to change f $ g $ h $ i j to f (g $ h $ i j) ?
10:13:24 <opqdonut> tinLoaf: of course
10:13:43 <tinLoaf> opqdonut: just because k is the only bounded type in the Heap constructor?
10:13:43 <sm> bah, ndm -
10:14:03 <byorgey> sm: yeah, that's strange.  personally I'd change it to  f . g . h $ i j
10:14:06 <Saizan> maybe it'll go to f . g $ h $ i j from there?
10:14:11 <aug_triad> Thank you
10:14:19 <tinLoaf> great.. works in fact. so ghc just "guesses" that i want the maxbound of k, because there is nothing else that is bounded?
10:14:22 <c_wraith> get it working, aug_triad?
10:14:25 <Saizan> i'd use "f . g . h . i $ j"
10:14:38 <byorgey> Saizan: er, right =)
10:14:41 <opqdonut> tinLoaf: no, because you _gave_ k as the return type of the function
10:14:56 <opqdonut> in the type signature
10:15:00 <tinLoaf> uhm, ok, that makes sense
10:18:00 <sm> perhaps I'm confused.. what it actually said was change "(length $ Map.keys $ accountmap $ cacheLedger [] rawledger7) `is`
10:18:01 <sm>   15" to "length (Map.keys $ accountmap $ cacheLedger [] rawledger7) `is` 15"
10:22:27 <aug_triad> c_wraith: Yes, I have simply made a function returning the appropriate type, now I have a problem with the other two arguments, hehe. But I'll find out, thank you.
10:26:58 <dcoutts> dons: ta, replied
10:42:28 * sw17ch wonders about the status of 6.12 and being able to cross compile...
10:45:23 <tinLoaf> hum.. it seems like haskell knows some "@" operator that introduces some fancy syntax.. could someone point me to a term to google for to get to know something about that @?
10:45:43 <tinLoaf> "haskell @ operator" doesn't get me too useful results..
10:46:06 <int-e> as-pattern works better
10:46:07 <Botje> it's used in pattern matches
10:46:14 <arw_> http://haskell.org/hoogle/?hoogle=%28%40%29
10:46:29 <Saizan> > let xxs@(x:xs) = [1,2,3] in (xxs,x,xs)
10:46:29 <lambdabot>   ([1,2,3],1,[2,3])
10:46:33 <arw_> perhaps not what you meant..
10:46:39 <Botje> foo list@(x:xs) = if x == 1 then list else xs
10:46:42 <sw17ch> > (\ x@(a,b) -> [show x, show a, show b]) (1,2)
10:46:43 <lambdabot>   ["(1,2)","1","2"]
10:46:47 <Saizan> you use it to give an alias that matches the whole pattern
10:47:02 <shapr> Can it match subsets as well?
10:47:13 <Saizan> subpatterns?
10:47:23 <sw17ch> > (\ x@(y(a,b),c) -> [show x, show y, show a, show b]) ((1,2),c)
10:47:24 <lambdabot>   <no location info>: Parse error in pattern
10:47:24 <tinLoaf> oh, ok
10:47:28 <sw17ch> > (\ x@(y@(a,b),c) -> [show x, show y, show a, show b]) ((1,2),c)
10:47:29 <lambdabot>   ["((1,2),c)","(1,2)","1","2"]
10:47:30 <int-e> @google haskell "as-patterns"
10:47:32 <lambdabot> http://www.zvon.org/other/haskell/Outputsyntax/As-patterns_reference.html
10:47:32 <lambdabot> Title: Haskell : As-patterns
10:47:34 <shapr> sw17ch: right
10:47:35 <tinLoaf> that's useful of course
10:47:39 <sw17ch> > (\ x@(y@(a,b),c) -> [show x, show y, show a, show b]) ((1,2),3)
10:47:40 <lambdabot>   ["((1,2),3)","(1,2)","1","2"]
10:47:45 <shapr> sw17ch: Exactly that.
10:47:49 <sw17ch> :)
10:48:06 <tinLoaf> thanks :)
10:48:38 * sw17ch pokes around one more time on the status of 6.12 and hopefully being able to make cross compilers
10:54:33 <Philippa> grr, sucky coverage happens
10:54:42 <xmonader> is there an implementation for "expand" in any of the Regex modules ?
10:54:47 <Philippa> oops, wrong chan, sorry guys
11:09:39 <stanv_> hello
11:10:00 <byorgey> hi stanv_
11:10:17 <stanv_> I have to hard exercise :(
11:10:24 <stanv_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9745#a9745
11:12:40 <byorgey> stanv_: what have you tried so far?
11:20:14 <jfoutz> @type (\ x@(y@(a,b),c) -> [show x, show y, show a, show b])
11:20:15 <lambdabot> forall t t1 t2. (Show t1, Show t2, Show t) => ((t1, t2), t) -> [String]
11:20:24 <jfoutz> ah, show.
11:26:11 <shapr> jimfear: Do you do Arduino dev with Haskell?
11:28:13 * sw17ch <3 his Arduino stuff
11:29:22 <shapr> sw17ch: Do you hang out on #arduino also?
11:29:51 <sw17ch> no, not yet :(
11:30:03 <sw17ch> i *think* i had some of the first Atom posts on arduino though
11:30:24 <jimfear> shapr: I'm a haskell newbie and I'm waiting until I have more time to get an Arduino.
11:30:25 <sw17ch> speaking of which, i've been meaning to put more up... i have the real time stuff working with timers and whatnot...
11:30:29 <jimfear> But maybe one day :)
11:30:45 <sw17ch> the light blinks EXACTLY one time per second now XD
11:30:48 <Berengal> My parsing knowledge and googling skills fail to tell me if lookbehind is neccessary to match /^/
11:30:51 <shapr> jimfear: There's a Haskell lib that does some sort of Arduino dev.
11:31:12 <Berengal> Anyone know if this is true?
11:31:24 <sw17ch> shapr, which lib?
11:31:29 <shapr> The Atom lib, yeah?
11:31:32 <shapr> @hackage Atom
11:31:32 <lambdabot> http://hackage.haskell.org/package/Atom
11:31:37 <sw17ch> oh yes :)
11:31:41 <shapr> Did you write it?
11:31:50 <sw17ch> it's not explicitly for Arduino... and actually, the timers don't work the greatest
11:31:52 <sw17ch> no
11:31:56 <sw17ch> Tom Hawkins from Eaton Trucking did
11:31:59 <sw17ch> but i've contributed a bit
11:32:20 <sw17ch> they built it to control hydraulic systems on garbage trucks
11:32:26 <sw17ch> i made it blink a light <.<
11:32:37 <shapr> heh
11:33:39 <sw17ch> it works much better on architectures with wider words
11:33:52 <sw17ch> it runs into problems with the timers on 8 bit since the timers are 64 bits wide o_O
11:34:16 <sw17ch> and doing a mod with a 64 bit timer on an 8bit processor generates something like 2K of code3
11:34:24 <sw17ch> unless you're doing mod 0, mod 1, or mod 2
11:34:29 <sw17ch> mod 3 explodes
11:35:04 <mjrosenb> mod0 sounds like it is fun
11:35:38 <mjrosenb> also, sounds like someone needs to optimize!
11:36:12 <sw17ch> when the code is built to run on 32 bit procs, and you move it to an 8bit proc, funny things happen
11:37:12 <Baughn> What is a "mod 0", exactly?
11:37:15 <Baughn> > 3 `mod` 0
11:37:16 <lambdabot>   * Exception: divide by zero
11:37:28 <shapr> Is the Arduino MEGA easier?
11:39:54 <sw17ch> mod 0 is an error, my mistake
11:47:00 <Alpounet> http://manning.com/petricek/ - like if there wasn't anything else than F# to write real world functional code...
11:54:09 <nomeata> Hi. Are the hackage download logs available somewhere? I’m really curious if anyone, and how many, has downloaded arbtt :-)
11:56:30 <ksf> are the icfp talks available somewhere online?
11:56:47 <ksf> acm upped the papers, but I didn't find any videos
11:56:48 <Saizan> nomeata: dons routinely publishes stats, so i'd guess so
11:56:54 <ksf> (a week or two ago, tbh)
11:57:14 <nomeata> Saizan: not routinely enough for an impatient person
11:57:16 <nomeata> :-)
11:58:30 <ksf> nomeata, the easiest way to get them might be to figure out what dons uses, cabal fetch hackage, hack it to generate them on a daily basis, and then bug everyone responsible for haskell.org to include it.
11:59:05 <Saizan> i think you've to ask Ross for the logs
11:59:26 <dcoutts> nomeata: the new server will maintain individual package download stats
11:59:29 <nomeata> ksf: :-) nice idea. I actually have experience bugging these people (you might have noticed the distribution version display on hackage)
11:59:36 <nomeata> ok, fair enough
11:59:38 <dcoutts> and it'll get finished quicker if you help :-)
12:00:04 <dcoutts> nomeata: yes, you still need to add that feature into the new server
12:00:06 <dcoutts> :-)
12:03:12 <byorgey> nomeata: arbtt is running on the laptop on which I am typing at this very moment! =)
12:03:17 <byorgey> so that's at least one download
12:03:58 <nomeata> byorgey: cool :-). Did you give configuring it a try yet? Is the „language“ suitable?
12:04:23 <Badger> I want a „ key.
12:04:35 <byorgey> nomeata: I must confess that I haven't yet.  I read your blog post, thought it was a cool and useful idea, so downloaded it and started it running.
12:05:00 <byorgey> the fact that I could start using it and configure the stats later when I had time was one of the big selling points =)
12:05:21 <nomeata> Badger: cat ~/.Xmodmap |grep doublelowquotemark
12:05:23 <mmorrow> nomeata: yeah, i read your blog about that too and dl'ed it, but i haven't got around to trying it yet
12:05:25 <nomeata> Badger: keycode  52 = y Y doublelowquotemark singlelowquotemark doublelowquotemark singlelowquotemark
12:05:31 <mmorrow> nomeata: it's on my list though
12:05:33 <saml> ["a", "a", "b", "a"]  ==> [("a", 3), ("b", 1)]  is there a name for this? counting number of identical elements
12:06:00 <saml> and how woudl you implement?
12:06:00 <mmorrow> nomeata: i like the idea
12:06:03 <nomeata> mmorrow: you might want to make it start collect data (takes no configuration), so that you have data when you get around to play with it
12:06:14 <mmorrow> nomeata: oh nice
12:06:15 <nomeata> byorgey: :-) fair enough
12:06:58 <byorgey> nomeata: when I get around to configuring it (it's on my list of things to do), I'll let you know
12:08:15 <nomeata> saml: I’d use something like: foldr (\e -> Data.Map.insertWith (+) e 1) Data.Map.empty
12:08:27 <nomeata> byorgey: thanks, I’m curious :-9
12:08:58 <saml> > foldr (\e -> Data.Map.insertWith (+) e 1) Data.Map.empty ["a", "a"]
12:08:59 <lambdabot>   Not in scope: `Data.Map.insertWith'Not in scope: `Data.Map.empty'
12:09:02 <ksf> gosh! germans. th. _TH_. /not/ s.
12:09:57 <ksf> it's not actually that hard. in fact, in 5th class, our english teacher spend a whole two lessons grinding that into our toungues+brains.
12:10:09 <ksf> do it yourself, for fuck's sake.
12:11:57 <RayNbow> hmm, according to a stats bot that's on several networks in several channels... lambdabot is the most talkative client :p
12:12:04 <byorgey> ksf: ... #haskell-blah, please?
12:12:45 * ksf is entitled to say such things here. he's slightly drunk and will be even more, soon.
12:12:56 <sw17ch> was i mistaken thinking GHC had plans to be a cross compiler at some point?
12:13:19 <Badger> @slap ksf
12:13:19 <lambdabot> stop telling me what to do
12:13:25 <Badger> heh
12:13:39 <ksf> I'm not trolling, though. just loosening up your tight-buttoned collars
12:13:47 <ksf> see, even lambdabot agrees with me.
12:13:53 <ksf> she's a good girl
12:13:55 <RayNbow> @botsmack
12:13:55 <lambdabot> :)
12:13:55 <lunabot>  :o
12:14:00 * ksf pets lambdabot
12:14:08 <RayNbow> she loves a good beating? :p
12:14:23 <ksf> @botsnack
12:14:23 <lambdabot> :)
12:14:24 <lunabot>  :o
12:14:31 <Tobsan> sup skorpan
12:14:45 <skorpan> Tobsan: asp.net :(
12:14:46 * ksf thinks both should distinguish them both commands.
12:14:58 <Tobsan> skorpan: :P
12:15:29 <skorpan> Tobsan: just when you thought your image of microsoft couldn't get any worse, you learned asp.net.
12:16:26 <Tobsan> I doubt it is really that bad
12:18:01 <skorpan> Tobsan: to put it short, i have a for-loop in my HTML looping through a list. if i want to access an attribute in that list, the standard asp.net way of doing it is to make a function ~7-8 lines long with four lines of XML comments for the function.
12:18:12 <skorpan> an attribute of an item in that list*
12:18:19 * ksf once heard someone at work talk about his impressions of the win2k code, specifically that one that leaked and that parses .ini files.
12:19:01 <ksf> ...whole of locks, killing locks, re-trying after failing to kill those locks, trying to get an r/w-lock because a r lock won't work due to some other obscure bug...
12:19:22 <ksf> ...at the end of it, I wasn't surprised that abdomination is called windoze.
12:20:19 <skorpan> you can really tell that asp.net was made long before things such as jquery existed.
12:20:53 <Tobsan> skorpan: eww
12:22:00 * ksf just loves the way wine makes you fuzzy.
12:22:28 <mjrosenb> oh, ksf is not talking about the on-emulator windows environment
12:22:45 <Badger> no,it appears not
12:22:53 <skorpan> hah, i would never have understood unless you told me
12:23:51 * ksf would not even imagine reading any leaked m$ code himself, for fear of picking up bad practice.
12:24:26 <ksf> or, rather, drown in endless pity.
12:24:33 <tnm> the old ReactOS was like wine just with a worse hangover
12:25:13 <ksf> i've been going on about wine for some hours today.
12:25:20 <ksf> we even had a nice conversation about it
12:25:30 <ksf> (before you pointy-haired suits arrived, that is)
12:25:45 <ksf> wine's the best way to run eve online, btw.
12:25:57 <ksf> it's also plays best with a bit of wine.
12:26:35 * ksf wishes mplayer's mute wouldn't mute the whole sound card
12:27:19 <skorpan> ksf: indeed
12:27:34 <skorpan> i hate it when you mute in mplayer then quit and the sound comes on for a split second before it actually quitz
12:27:36 <skorpan> quits*
12:28:10 * ksf also thinks an open-source haskell group, in addition to the industrial haskell group would be a good idea.
12:28:28 <Heffalump> to collect money?
12:28:32 <ksf> them being in semi-competition and semi-cooperation
12:28:51 <ksf> more to coordinate stuff
12:28:55 <Heffalump> not quite sure I see the point of competition...
12:28:59 <ksf> and to plan for world dominance.
12:29:23 <ksf> if there's no competition, imagine competition. otherwise, you loose.
12:29:44 <Heffalump> we talked about collecting individual contributions/merchandising to fund infrastructure development
12:30:23 <ksf> see, with tvtime, we always planned for world dominance. it figures that we got it.
12:30:30 <ksf> (even though there's been no update for >1 year now. it's just perfect like it is)
12:32:36 * ksf thinks haskell's new motto should be "strive for world dominance, no matter what procrastination"
12:33:24 <ksf> we should e.g. stop calling those standards '98 and such, 0.0.1.2 is much a better version.
12:40:09 <nyingen> @quote
12:40:09 <lambdabot> mwc says: I can only believe that Java is a conspiracy perpetrated by keyboard manufacturers
12:40:39 <nyingen> mwc has obviously never programmed in perl :)
12:42:03 <Orclev> wonder what other goodies are in quote
12:42:07 <Orclev> @quote
12:42:07 <lambdabot> your_mom says: Will you stop telling dumb jokes about me
12:42:16 <nyingen> hardy har har
12:42:20 <nyingen> @quote
12:42:20 <lambdabot> SimonRC says: if performance was that important, people would be using perl, python, or the JVM
12:42:44 <Orclev> think that was supposed to be wouldn't
12:43:01 <nyingen> also, I tried out the @vixen command on my own copy of lambdabot the other day
12:43:03 <nyingen> O_o
12:43:21 <RayNbow> hmm, just got this in a query window:
12:43:21 <Orclev> no clue what @vixen does
12:43:21 <RayNbow> <RayNbow> @quote
12:43:21 <RayNbow> <lambdabot> Plugin `quote' failed with: getRandItem: empty list
12:43:22 <Makoryu> The actual command is @nixon, no?
12:43:46 <byorgey> Makoryu: heh, no =)
12:44:05 <Badger> @vixen do you have any idea?
12:44:05 <lambdabot> yes i do
12:44:23 <Badger> @vixen awesome. care to enlighten us?
12:44:24 <lambdabot> i'm glad your happy
12:44:32 <Badger> apparently not.
12:44:39 <Orclev> ah, it's a eliza... or something like one
12:44:42 <byorgey> @vixen say hi to Makoryu
12:44:42 <lambdabot> hiya
12:45:37 <sinelaw> @vixen @vixen
12:45:37 <lambdabot> we all have a little vixen in us
12:45:37 <sinelaw> @vixen _|_
12:45:37 <lambdabot> i'm a huge baseball fan
12:45:42 * ksf 's bottom is much sexier than lambdabots
12:46:10 <Orclev> hehe... wonder what this does (reminded me of something from the mailing list)
12:46:10 <Orclev> @vixen (.) (.)
12:46:10 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here behind my computer talking to you!
12:46:50 <nyingen> Orclev: ouch...you got shut down
12:46:53 <Orclev> lol, I really don't mind getting shut down by a bot
12:47:10 <Orclev> plus I wanted to see what it would make out of the "boob" operator
12:48:02 <Badger> @quote (.)
12:48:02 <lambdabot> glguy says: dons: one meteor could wipe out the Haskell IRC bot community!
12:48:25 <Badger> @remember (.) I am the boob operator!
12:48:25 <lambdabot> Okay.
12:49:18 <Orclev> actually I think it's two of them that's considered the boob operator
12:49:27 <Orclev> :t (.) (.)
12:49:28 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
12:49:46 <camio> looks more like eyes to me
12:49:53 * Orclev shrugs.
12:50:01 <_schulte_> is it possible to use the let ... in ... construct to define a temporary function for use in multiple statements?
12:50:06 <qiemem> Is this an appropriate place to ask a cabal related question?
12:50:24 <benmachine> @nixon
12:50:24 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
12:50:24 <camio> qiemem: no, this is ascii art only channel
12:50:30 <_schulte_> I've tried to with the following but I'm getting syntax errors http://gist.github.com/192232
12:50:34 <benmachine> smooth
12:50:46 <camio> qiemem: just kidding. Go ahead and ask.
12:50:49 <qiemem> heh
12:51:54 <byorgey> _schulte_: no, you can't.  let ... in ... can only be used with expressions, not declarations.
12:52:12 <byorgey> _schulte_: just define the function you need as a top-level function and don't export it.
12:52:28 <byorgey> that's also good practice because it makes it easier to test.
12:52:40 <qiemem> so, I'm trying to install grapefruit. I have installed gtk2hs through standard configure-make-sudo make install. I keep getting: "There is no available version of gtk that satisfies >=0.9.13 && <0.11" however. So how do I get cabal to recognize that I have gtk?
12:52:53 <_schulte_> byorgey: thanks, I guess I'll do that, although it somehow doesn't seem as clean
12:53:44 <qiemem> oh, I mean, when I do "cabal install grapefruit-ui-gtk" I get that error message
12:54:44 <Heffalump> qiemem: what does ghc-pkg list say?
12:54:48 <Alpounet> qiemem, actually, cabal is telling you about the haskell binding of gtk, whose version must satisfy the given constraints.
12:55:10 <Alpounet> (don't get why there are such ones, btw)
12:55:21 <qiemem> Heffalump: ghc-pkg?
12:55:31 <Heffalump> Alpounet: would you expect every package to do its own GTK bindings?
12:55:37 <Heffalump> qiemem: yes, it's a tool that comes with ghc
12:55:41 <Heffalump> tells you what you have installed
12:56:02 <Alpounet> no, but why precisely >=0.913 && <0.11, and not 0.12, e.g
12:56:03 <Heffalump> but if you just mean that you have the C GTK, then you need the Haskell bindings too. Google for gtk2hs. Unfortunately they have to be installed by hand.
12:56:07 <tnm> @nixon
12:56:07 <lambdabot> I reject the cynical view that politics is a dirty business.
12:56:24 <qiemem> So I did install gtk2hs
12:57:02 <qiemem> hmm... ghc-pkg list|grep gtk comes up blank
12:58:06 <Heffalump> qiemem: ok, then something is wrong with your gtk2hs install
12:58:32 <qiemem> I specified no options during ./configure. Should I have explicitly pointed to ghc or something?
12:59:00 <Heffalump> I'd only expect that to be needed if you have multiple GHCs installed
13:00:50 <aug_triad> Hi, I have a question about the @-operator. What does it mean? It occurs in the following function: perform pmap c@Context{cTime = t, cPlayer = pl, cDur = dt, cKey = k }m = ...
13:02:20 <tommd> aug_triad: It just binds the name to the data structure.  so "c" is a variable of the type "Context" is a constructor for.
13:02:36 <tommd> And the internal elements of"c" are spelled out inside the brackets.
13:02:41 <nyingen> aug_triad: You use that when you want a name for the whole data structure as well as its pieces
13:02:45 <wjt> @let misc str@(x:xs) = if x == 'j' then Just str else Nothing
13:02:45 <lambdabot>  Defined.
13:02:51 <wjt> > misc "jelly"
13:02:52 <lambdabot>   Just "jelly"
13:02:58 <wjt> > misc "cheese"
13:02:59 <lambdabot>   Nothing
13:03:30 <aug_triad> Thank you!
13:18:19 <Alpounet> @pl \x y -> repeat x . repeat y
13:18:19 <lambdabot> (. repeat) . (.) . repeat
13:18:49 <Alpounet> @pl \x -> repeat x . repeat 5
13:18:49 <lambdabot> (. repeat 5) . repeat
13:19:47 <absentia> @pl marsboobs :: (.) -> (.) -> (.)
13:19:47 <lambdabot> (line 1, column 18):
13:19:47 <lambdabot> unexpected ">" or "-"
13:19:47 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
13:26:20 <Alpounet> what would you use to represent a N*N board (for a board game...) ?
13:27:00 <camio> [[Item]]?
13:27:01 <Gracenotes> an Array with (Int, Int) indexing is probably nice
13:27:49 <Gracenotes> mutable or immutable, depending on your needs...
13:27:51 <camio> Ah yes, an array would likely be nicer.
13:29:48 <Gracenotes> 'needs' mostly meaning performance. I did a tetris game, 20x8, that wasn't noticeably slow with an immutable array
13:30:20 <Alpounet> Gracenotes, what did you use for the immutable part ?
13:30:30 <Alpounet> simply MutableArray ?
13:30:56 <Gracenotes> the nice part about using (Int, Int) is that it is stored in a contingent block of memory (or at least, as GHC would believe). Math is used to translate (Int, Int) to simple indexing, but you don't have to deal with that
13:31:33 <Alpounet> Ok. Arrays look nice indeed.
13:31:33 <Gracenotes> data Board = Board (Array (Int, Int) Bool), Bool being whether it had a block or not
13:32:31 <Gracenotes> most operations were just moving a block or set of blocks along, and that can be done in one go with (//). for stretches that require very complex operations, but are still atomic, temporary STArray-ization can work, I guess
13:32:36 <Alpounet> Gracenotes, did you then use State Board ?
13:32:50 <Alpounet> ok
13:33:12 <Gracenotes> I used GTK, the design of which basically requires you to keep IOVars for state. the state, as it were, was just a Board and the currently falling Block
13:33:39 <Alpounet> ok
13:36:02 <Gracenotes> actually, the Block was kept separate from the Board, so falling didn't require changing the Array. Maybe it would have been slower if that were the case. Anyway, at the end of the "fall", it actually just becomes part of the board, merging into it. worked for the simple design I had in mind at least
13:40:12 <Alpounet> Ok fine.
13:40:32 <Alpounet> I think an IOVar will actually be okay too for me.
13:40:54 <Gracenotes> depending on how much data sharing is possible, there may be better structures... or even just mutable arrays themselves... but, uh, good luck :) I am off for a bike ride
13:40:55 <Alpounet> Is your tetris hosted somewhere ? Looking at your code should be very interesting for me.
13:46:56 <Gracenotes> Alpounet: I'm leaving now, but here is, uh, a stable version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9748  sorry if it is dense in places though
13:49:03 <tromp> that's a lot more readable than http://www.cwi.nl/~tromp/tetris.html
13:49:44 <Gracenotes> -_-
13:49:58 <Badger> ^_^
13:54:55 <_schulte_> does haskell have a function analagous to mapcdr? or a version of foldr which runs over sucessive tails?
13:55:52 <Berengal> Transcribing a BNF to haskell while keeping the parser return values sane is hard work...
13:56:00 <copumpkin> _schulte_: scan maybe?
13:56:13 <copumpkin> _schulte_: or map f . tails ?
13:56:36 <_schulte_> copumpkin: thanks, trying out both of those...
13:58:32 <_schulte_> copumpkin: i think map|foldr . tails should do the trick, thanks
13:58:40 <Alpounet> Gracenotes, thanks.
13:58:47 <copumpkin> :t foldr.  tails
13:58:48 <lambdabot>     Couldn't match expected type `a -> b -> b'
13:58:48 <lambdabot>            against inferred type `[[a1]]'
13:58:48 <lambdabot>     In the second argument of `(.)', namely `tails'
13:59:01 <copumpkin> :t \f -> foldr1 f .  tails
13:59:02 <lambdabot> forall a. ([a] -> [a] -> [a]) -> [a] -> [a]
13:59:23 <Makoryu> @pl \f -> foldr1 f . tails
13:59:23 <lambdabot> (. tails) . foldr1
13:59:33 <Makoryu> @pl \f -> foldr f . tails
13:59:33 <lambdabot> (. tails) . foldr
13:59:37 <Makoryu> Huh
14:01:05 <_schulte_> Makoryu: thanks I *think* I understand what's taking place in that cmoposition
14:01:41 <Makoryu> @unpl (. f) . g
14:01:42 <lambdabot> (\ d i -> g d (f i))
14:02:11 <Makoryu> Wait, wait
14:02:16 <Makoryu> :t foldr
14:02:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:02:32 <Makoryu> @pl \f z -> foldr f z . tails
14:02:32 <lambdabot> flip flip tails . ((.) .) . foldr
14:02:43 <Makoryu> D:
14:05:36 <aug_triad> Hi, i still can't get the type right... I have the type signature: performance :: (String -> Player a) -> Context a -> Music (Pitch, [NoteAttribute]), which I implement with: performance = perform (defP "andreashjortgaard") n_context vol1. The signature for defP is defP :: String -> Player (Pitch, [NoteAttribute]). Why do I get the error Couldn't match expected type `PMap a'; against inferred type `Player (Pitch, [NoteAttribute])'? The inferred type s
14:05:36 <aug_triad> be String -> Player (Pitch, [NoteAttribute]), right??
14:08:09 <c_wraith> Tough to get enough context in chat.  Can you post it on hpaste, along with the error message?
14:08:13 <c_wraith> @where hpaste
14:08:13 <lambdabot> http://hpaste.org/
14:08:31 <aug_triad> Yes, of cause
14:09:26 <camio> Anyone know of a program that can notify you when an interesting conversation comes up on #haskell?
14:10:44 <lpsmith> how is any program going to know whether or not a conversation is interesting?
14:10:44 <c_wraith> well, first you create strong AI
14:10:44 <lpsmith> hahaha
14:11:20 <camio> keywords perhaps? Maybe when certain people start talking... There's lots of ways, no?
14:11:43 <lpsmith> That might make sense,  but I don't particularly know of one
14:12:01 <jmelesky> camio: sounds like you should write one and publish it
14:12:17 <c_wraith> most IRC programs will notify you on a set of keywords
14:12:20 <lpsmith> I'm not an irc guru by any means though
14:12:26 <c_wraith> Choosing an appropriate set is hard, though
14:12:29 <aug_triad> It's on hpaste now
14:12:39 <jmelesky> make it general enough for any channel, and you can get non-haskellers to start using a new haskell app
14:13:00 <camio> Or maybe there ought to be an addition to the bot. @interestingConversationStarting.
14:14:42 <c_wraith> aug_triad: I think you just want to pass defP as the second arg to perform, not (defP "test")
14:17:38 <uid_b> I've been searching around the docs, but haven't had any luck: is there a way to create a gap between windows?
14:18:42 <uid_b> doh, wrong chan
14:22:14 <aug_triad> c_wraith: but the first argument should be a function that takes a string and return a Player a. The second argument is Context a, right?
14:24:22 <c_wraith> aug_triad: defP is a function that takes a string and returns a Player a (for one specific value of a).  If you apply it to a string, it no longer has that type
14:25:14 <aug_triad> Yes, I can see that, but how should I do it otherwise?
14:26:40 <c_wraith> I'm not completely sure what you're asking.
14:28:32 <aug_triad> performance = perform (X) n_context vol1, what should I write instead of X ... I have made a function String --> Player a, the only thing I can think of, is to put it instead of X
14:29:37 <nfm1> hi
14:29:51 <c_wraith> performance = perform defP n_context vol1
14:30:01 <c_wraith> You can just refer to the function by name
14:30:08 <c_wraith> You don't need to apply it to any arguments
14:33:27 <aug_triad> Ok, thanks. I can't see why the function should have the correct type doing that, though... But the error has disappeared, and a new one is facing me.
14:36:38 <aug_triad> How is defP's argument being used? DefP should be called with a string somehow?
14:38:39 <c_wraith> yes.  In theory, the perform function will call defP with a string it gets from somewhere.
14:39:16 <aug_triad> Spooky
14:40:12 <c_wraith> Are you familiar with functional programming, in general?  Functions like map, for instance?
14:40:26 <aug_triad> Yes, I have done some in SML
14:40:54 <c_wraith> Well, it's the same idea.  You're passing a function to another function.
14:44:25 <aug_triad> After doing it, I get this error:
14:44:26 <aug_triad> Couldn't match expected type `(String -> Player a) -> Context a -> Music (Pitch, [NoteAttribute])'
14:44:26 <aug_triad>            against inferred type `Performance'
14:44:26 <aug_triad>     In the expression: perform defP n_context vol1
14:44:26 <aug_triad>     In the definition of `performance':
14:44:27 <aug_triad>         performance = perform defP n_context vol1
14:45:33 <aug_triad> The signature for perform is perform :: PMap a -> Context a -> Music a -> Performance. I can't see how the last arrow come into the game?
14:46:26 <tingi_> does anyone know if  X mod (p1*p2) is ? p1 and p2 are primes. Can it be written as a product of individual mods like  x mod p1 *  xmodp2
14:46:39 <tingi_> something like that
14:46:51 <c_wraith> aug_triad: Well, you applied 3 arguments to perform.  That means 3 of the arrows were traversed.
14:47:35 <c_wraith> aug_triad:  The compiler is right.  Your type signature is wrong.  The type of performance is just Performance
14:47:40 <trzkril> tingi_: you know the chinese remainder theorem?
14:48:08 <tingi_> trzkril, yes
14:49:18 <aug_triad> Ah, yes, I see.
14:50:59 <trzkril> tingi_: well, that can be used to reduce multiplication mod p1*p2 to multiplication mod p1 and p2
14:52:17 <PetRat> Trying to understand Doug Auclair's article on  MonadPlus and the use of StateT on a list monad. My question is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9751#a9751
14:52:36 <aconbere> I'm trying to figure out how people usually organize their test environments for a package. I can see that xmonad puts their Properties.hs file in ./tests/, and includes the file via cabal extra-source-files. But I'm not entirely sure how they run quickCheck and how that Properties file gets access to the XMonad namespace from that directory.
14:53:20 <aug_triad> c_wraith: now it all works, thank you!
14:53:34 <c_wraith> aug_triad: you're welcome
14:55:25 <PetRat> Trying to understand Doug Auclair's article on  MonadPlus and the use of StateT on a list monad. My question is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9751#a9751
14:55:57 <tingi_> trzkril, can you tell me how for 15 mod 10 ? i don't get it
14:57:38 <trzkril> tingi_: well, 5 is not in the multiplicative group mod 10 since gcd(10,5) ≠ 1
15:03:48 <aconbere> is the idea that you would cabal install the package first, then run the tests?
15:04:11 <aconbere> or can I load modules from directories below my current running directory (not something XMonad is doing, but maybe nicer way of doing it?)
15:05:11 <Gracenotes> I am back. woot.
15:05:44 <mrsolo> what's most commonly use? text.regex.posix or text.regex.pcre?
15:06:32 <yitz> mrsolo: Text.Parsec
15:06:51 <Gracenotes> that makes 130 minutes of bike riding today \o/
15:10:16 <lpsmith> PetRat:  use lift
15:14:09 <lpsmith> @type lift
15:14:10 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
15:19:27 <flazz> if i have a data Vec = Vec x y z, is the constructor read as "Vec of x y z"?
15:19:34 <flazz> if i were to talk to another human
15:25:05 <sjanssen> flazz: that's an interesting question
15:25:17 <sjanssen> though I can't say I've ever read Haskell to another person
15:25:34 <flazz> or to myself alod :)
15:25:38 <flazz> aloud*
15:25:56 <Asztal> I don't read it to myself like that
15:26:15 <flazz> Asztal: how do you?
15:26:24 <yitz> flazz: I guess you might read it the same way you would read the name of any other function.
15:26:24 <Asztal> just "Vec x y z"
15:26:30 <Asztal> but I do prevocalize $ in a strange way
15:26:39 <Gracenotes> the product type of x, y and z :o
15:27:17 <sjanssen> flazz: I might say "constructor Vec taking x, y, z"
15:27:49 <flazz> how about the type "IO String"?
15:28:10 <lilac> flazz: i say "IO String" for that :)
15:28:24 <flazz> Asztal: how do you prevocalize  f $ e?
15:28:51 <flazz> i dont per se, but i hink of it as a reverse pipe
15:30:15 <sjanssen> a Haskell version of cdecl might be kind of handy
15:32:24 <Cale> I usually read $ as "applied to"
15:32:24 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
15:33:17 <Cale> ksf: What is IPPrint?
15:33:34 <ksf> @hackage ipprint
15:33:34 <lambdabot> http://hackage.haskell.org/package/ipprint
15:34:00 <ksf> shows some value, parses it with haskell-src and then uses the haskell-src pretty printer to print it.
15:34:14 <ksf> another idea was to have lambadbot hpaste longer outputs
15:34:48 <Cale> I could import the module, but I don't think it would be very useful...
15:35:08 <ksf> ...as lambdabot output isn't multi-lined, yes.
15:35:31 <Cale> also because you can't do I/O
15:35:32 <ksf> could be useful in connection with a thing like @more or so, though.
15:35:38 <ksf> there's pshow, too.
15:35:51 <Cale> yeah, but that'll give you a string with escapes in it :)
15:36:29 <ksf> > show "foo"
15:36:30 <lambdabot>   "\"foo\""
15:36:34 <ksf> that does, too.
15:36:55 <Cale> Yes, but it sort of defeats the purpose of pretty printing it
15:37:45 <flazz> Cale: i like applied to, its very lambda-calculus-esque
15:37:53 <ksf> you know, back when I was sober it seemed like a good idea, but after a bottle of wine, there's some serious arguments against it.
15:38:12 <hackagebot> haskeline 0.6.2.1 - A command-line interface for user input, written in Haskell. (JudahJacobson)
15:38:44 <eyeris> Is there a standard haskell function that, given n and m, would return the lowest multiple of m that is greater than or equal to n?
15:39:54 <Cale> I'm pretty sure there isn't. There's lcm.
15:40:29 <eyeris> Okay
15:42:04 <aconbere> how do people feel about test-framework?
15:42:43 * aconbere is wading through testing best practices but can't find much in the way of concensus
15:43:06 <ksf> conscensus is what you accept it to be.
15:43:10 <sm> aconbere: like it!
15:43:16 <ksf> trust your own judgment, and find it quickly.
15:43:54 <sm> current most featureful test runner
15:44:11 <ksf> who, after all, would trust all those 600+ nutcases in #haskell?
15:44:31 <Peaker> Why did #haskell stop growing? :(
15:44:50 <olsner> ksf: most of those 600+ nutcases, I'd say :)
15:44:58 <Badger> :o
15:45:05 <Badger> it has lost about 50 people
15:45:06 <ksf> we've attracted all nutcases in the world there are, so we've plateaued the growth.
15:45:31 <Makoryu> Peaker: A few theories: .NET is implementing a lot of the stuff that made Haskell attractive, meaning Haskell isn't quite as unique as it once was.
15:45:33 <aconbere> sm: do you include cabal test integration with your projects?
15:45:44 <sm> I have with one, yes
15:46:08 <aconbere> sm: I have a bunch of simple QuickCheck tests that work, and I can't quite figure out the right way to architect running them.
15:46:11 <Peaker> Makoryu, Purity, laziness, strong type system?  F# has a tiny bit of the latter maybe?
15:46:14 <sm> http://joyful.com/repos/hledger/Setup.hs
15:46:24 <Peaker> Makoryu, I dont see how .NET has the attractive Haskell things
15:46:29 <sm> um, that may not be the *right* way, but it's a way
15:46:34 <aconbere> sm: part of that is where to put the test files so they have access to the Module namespace being tested
15:46:37 <aconbere> et.c
15:46:39 <aconbere> hehe
15:46:50 <Makoryu> Peaker: See, people want all the benefits of purity without actually having purity... Ditto laziness and strong typing.
15:46:54 <mrsolo> i double haskell will ever be as popular as .net languages
15:46:58 <sm> I think there's a doc describing this
15:47:09 <aconbere> sm: I've been looking all over!
15:47:14 <aconbere> I would be super excited to see a doc :)
15:47:54 <Peaker> mrsolo, I double your double
15:48:12 <sm> I think I followed http://koweycode.blogspot.com/2009/07/some-ideas-for-practical-quickcheck.html
15:48:22 <Makoryu> Peaker: For example, people who understand monads without necessarily liking Haskell will say "NICE! Now how can we do that in F#?"
15:48:28 <aconbere> sm: cool I'm reading that as well
15:48:43 <Peaker> Makoryu, Well, some concepts will translate well but some won't
15:48:43 <aconbere> sm: then perhaps I'm on the same page as some of the rest of the community :)
15:48:57 <Makoryu> Peaker: Obviously.
15:49:13 <mrsolo> but people use whatever to pay the bills
15:49:21 <mrsolo> haskell is a nice hobby for me so far
15:49:44 <sm> yes, I guess Cabal 1.8 will make it easier (http://hackage.haskell.org/trac/hackage/ticket/215)
15:52:39 <Peaker> Does the shared lib support in ghc mean we're going to see smaller executables in Linux now?
15:52:41 <sm> how do I get the system's hostname ?
15:52:45 <Peaker> Hello World is a few megabytes, iirc
15:52:50 <Peaker> @hoogle hostname
15:52:50 <lambdabot> Network type HostName = String
15:52:50 <lambdabot> Network.BSD type HostName = String
15:52:50 <lambdabot> Network.Socket type HostName = String
15:54:11 <lilac> why is it that contexts and deriving clauses require parentheses if multiple items are specified, but fixity declarations and LANGUAGE pragmas don't?
15:54:18 <aavogt> Peaker: apparently it will not be a default in 6.12, since there are versioning issues
15:55:02 <scasware> beginner question: What type of binary executable does GHC generates?
15:55:46 <scasware> I mean, is it platform specific? If I compile with GHC on a Mac Unix, Can I run it in, say, BSD?
15:55:49 <aavogt> scasware: I get: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.18, stripped
15:56:43 <aavogt> scasware: most likely that will fail
15:56:44 <scasware> aavogt: please remind me what command can I use to get that info
15:56:44 <jmcarthur> scasware: it's a native binary, not portable byte code
15:56:50 <aavogt> scasware: file
15:56:58 <scasware> jmcarthur: I see, thanks.
15:56:59 <lilac> I get: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, not stripped
15:57:06 * sm resorts to readProcess "hostname" [] ""
15:57:53 <aavogt> hmm, but the binaries are mostly statically linked (other than gmp), so maybe it will work
15:58:14 <aavogt> for example, I can compile haskell apps in wine, and run those binaries in windows
15:59:06 <scasware> Is there anything such as 'haskell runtime libraries' that must be present in the target OS?
15:59:19 <ksf> ELF 64-bit LSB executable, x86-64, version 1 (SYSV), for GNU/Linux 2.6.9, dynamically linked (uses shared libs), not stripped
15:59:51 <ksf> huh. I've got 2.6.28
16:00:10 <Peaker> For a better hoogle, I think it might be useful for types to indicate whether their type params are "positive" or "negative". Usually when you search for a type you care about the positivity more than the exact structure I think. Any ideas if that is reasonable/possible to deduce automatically?
16:00:37 <lilac> sm: the hostname command itself just calls 'gethostname'
16:00:45 <lilac> sm: you could probably FFI that pretty easily
16:00:46 <aavogt> Peaker: can you explain positive and negative more?
16:01:10 <ksf> hello => ./hello (interpreter => /lib64/ld-linux-x86-64.so.2)
16:01:10 <ksf>     libm.so.6 => /lib/libm.so.6
16:01:10 <ksf>     libgmp.so.3 => /usr/lib/libgmp.so.3
16:01:10 <ksf>     libdl.so.2 => /lib/libdl.so.2
16:01:10 <ksf>     librt.so.1 => /lib/librt.so.1
16:01:11 <ksf>         libpthread.so.0 => /lib/libpthread.so.0
16:01:13 <ksf>     libc.so.6 => /lib/libc.so.6
16:01:30 <Peaker> aavogt, I see negative as "consumed" and positive as "produced".  So  in [] a  the a is positive.   in (a -> b)  the a is negative and the b is positive
16:01:42 <ksf> should be all pretty standard.
16:01:54 <ksf> libgmp and libm isn't minimal, though.
16:01:59 <aavogt> @hoogle [a] -> b
16:02:00 <lambdabot> Prelude head :: [a] -> a
16:02:00 <lambdabot> Prelude last :: [a] -> a
16:02:00 <lambdabot> Data.List head :: [a] -> a
16:02:02 <lilac> sm: here's how 'hostname' does it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9756#a9756
16:02:15 <ksf> (also, it's debatable whether a non-threaded rts should link to pthread)
16:02:23 <aavogt> @hoogle (a -> b -> c) -> (a -> b) -> a -> b
16:02:24 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:02:24 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
16:02:24 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
16:02:39 <lilac> aavogt: const id
16:03:09 <lilac> @hoogle (a -> b -> c) -> (a -> b) -> a -> c
16:03:09 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:03:09 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
16:03:09 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
16:03:16 <Saizan> Peaker: there's a formal definition for positive and negative, being on the left of a -> gives you a *(-1)
16:03:24 <ksf> aavogt, ghc on windoze uses mingw
16:03:30 <Peaker> Saizan, Everything else is positive?
16:03:38 <lilac> @type ap :: (a -> b -> c) -> (a -> b) -> a -> c
16:03:39 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
16:03:40 <Peaker> Saizan, (IO a) -- the a is positive here
16:03:48 <Peaker> Saizan, Maybe there are non-function types that are really negative?
16:03:49 <ksf> ...so, i guess, yes, compiling with wine should work, as long as you don't involved windoze-foo.
16:03:58 <ksf> I'm not at all an expert on windoze, though.
16:04:06 <ksf> In fact, I refuse to use it, at all.
16:04:16 <Peaker> Saizan, I guess if everything but left-of-(->) is positive, then hoogle may already have all that in it
16:05:14 <scasware> ksf: I'm not planning on getting even near a Windows system, yet. =)
16:05:23 <Saizan> Peaker: that's the definition generally used, not sure how closely it matches your intuitive idea
16:05:42 <Saizan> in (a -> r) -> r, 'a' is positive too
16:05:49 <Peaker> Yeah
16:05:53 <ksf> well, it was aavogt that asked
16:05:57 <Saizan> and r is used both positively and negatively
16:06:01 <Peaker> I think maybe there start to be problems when a type param appears in both negative and positive positions
16:09:29 <aavogt> Saizan, Peaker, thanks for the explanation
16:10:07 <sm_> lilac: thanks, but wouldn't that hurt portability ?
16:10:56 <aavogt> ksf: hmm, I used gtk2hs, which is indirectly involved with windows-foo, but it did work out.
16:10:57 <Saizan> clearly if you have a defined ADT you should expand it when counting this
16:15:49 <Peaker> Saizan, Just wondered because it seemed like when I searched hayoo for HostName I wasn't sure if it only gave results where HostName was positive
16:16:07 <Peaker> Saizan, @hoogle HostName  might imply you want a positive HostName, not to hand a HostName to someone
16:17:04 <aavogt> @hoogle HostName -> a
16:17:04 <lambdabot> Prelude error :: [Char] -> a
16:17:04 <lambdabot> Debug.Trace trace :: String -> a -> a
16:17:04 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
16:17:51 <lilac> @hoogle Functor f => f (a -> b) -> a -> f b
16:17:51 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
16:17:51 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
16:17:51 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
16:18:14 <lilac> is there a normal symbolic name for that operator?
16:18:52 <lilac> i've been using >$< for it
16:18:55 <aavogt> @type fmap id
16:18:56 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
16:19:02 <aavogt> @type fmap . id
16:19:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:19:50 <lilac> @pl \a b -> fmap ($b) a
16:19:50 <lambdabot> flip (fmap . flip id)
16:20:15 <Makoryu> @pl fmap ($b) a
16:20:15 <lambdabot> fmap ($ b) a
16:20:26 <aavogt> :t fmap . flip id
16:20:27 <lambdabot> forall (f :: * -> *) a c. (Functor f) => a -> f (a -> c) -> f c
16:23:49 <lilac> maybe 'f <$> ($x)' is ok
16:25:22 <Saizan> Peaker: never investigated much how @hoogle searches, i'm not even sure if it parses the types properly
16:25:33 <brad_larsen> is there any equivalent of let-expressions for type families?
16:25:54 <Peaker> Saizan, I thought it probably does given that it knows how to search similar structures and all
16:25:58 <lilac> brad_larsen: there's type synonyms
16:27:17 <brad_larsen> When using associated types, I end up writing things like (VarT (ExprT t a)) a bunch
16:27:38 <brad_larsen> it would be nice if I could make a synonym for that large thing
16:28:06 <brad_larsen> ...but I think i just figured it out
16:28:35 <lilac> brad_larsen: you can make a 'type VE t a = VarT (ExprT t a)'
16:29:08 <lilac> brad_larsen: or you can say (ve ~ VarT (ExprT t a)) => ve -> ve -> ve
16:29:51 <brad_larsen> lilac: that's true, the type equality constraint could work
16:31:06 <brad_larsen> lilac: yeah, just using a simple type synonym works, mostly, for what I want
16:31:34 <lilac> type equality is probably about as close to a let as you can get in the type level i think
16:31:56 <brad_larsen> I wish I could define a type synonym, lexically, in a class definition
16:31:58 <lilac> type synonyms don't let you close over types in the same way
16:32:03 <brad_larsen> (that might be an incoherent desire)
16:32:30 <lilac> well, you can, using synonyms in the class head, i think
16:32:46 <brad_larsen> type synonyms, families, etc. seem to have global scope
16:32:57 <lilac> 'class (ve ~ VarT (ExprT t a)) => Foo t a where f :: ve -> a'
16:33:07 <brad_larsen> hmmm
16:33:17 <lilac> no idea if GHC will accept that :)
16:33:36 <lilac> probably fails some kind of coverage condition
16:34:24 <copumpkin> it won't
16:34:27 <copumpkin> not fundamentally though
16:37:19 <Keiya> Hmm... you know, lazyness makes some things really weird. I can easily envision a function that would take the state of, say, a game of Life as input, and have the next step as output. But displaying that is harder... :/
16:37:29 <lilac> hmm. ve doesn't scope over the class body but t and a do :(
16:38:03 <ivanm> Keiya: State -> (Output, State)
16:38:10 <lilac> and you can't even put a 'forall' in to fix it, not even with ScopedTypeVariables
16:38:57 <Keiya> ivanm: That's one thing I thought of, but... eh...
16:39:03 <brad_larsen> lilac: yeah, I'd like to be able to define a ``lexically scoped'' type synonym, so that I can tidy up some function signatures within a class definition
16:39:04 <ivanm> @src State
16:39:04 <lambdabot> Source not found. Maybe you made a typo?
16:39:08 <ivanm> @src ST
16:39:08 <lambdabot> newtype ST s a = ST (STRep s a)
16:39:15 <ivanm> that's not the one I was after...
16:39:44 <ivanm> Keiya: well, the State monad basically uses a wrapped version of that
16:39:44 <Keiya> The problem is really the mismatch. At the 'outer layers', you have to work imperatively because that's how the rest of the system works.
16:39:44 <lilac> brad_larsen: i think the nice syntactic space for that is occupied by associated types, sadly.
16:40:06 <lilac> brad_larsen: (class Foo t a where type VE = VarT (ExprT t a); ...)
16:40:10 <Keiya> I guess the trick would be to have a non-haskell 'driver' that forces the haskell program to actually /go/ :P
16:40:20 <ivanm> Keiya: not at all
16:40:26 <lilac> Keiya: not non-haskell. but in IO
16:40:33 <ivanm> didn't you know? Haskell is the world's finest imperative language!
16:40:57 <lilac> Keiya: you're right to observe that without external influence, lazy code by itself will never 'go' :)
16:41:10 <Keiya> From what I've been able to tell, IO is just an implementation of that concept :P
16:41:15 <ivanm> lilac: and will never play 'go'? ;-)
16:41:26 <brad_larsen> lilac: i tried that.  ghc complains:  ____Type declaration in a class must be a kind signature or synonym default
16:41:33 <brad_larsen> lilac: so, no go
16:41:55 <lilac> brad_larsen: right, that's defining an associated type synonym, which is not what you want
16:42:05 <lilac> or at least it would be if it were legal :)
16:42:35 <brad_larsen> (I'm playing around with DSLs, of the ``finally tagless'' variety)
16:43:06 <brad_larsen> lilac: I end up with a class for statements, with a couple associated types
16:43:20 <brad_larsen> lilac: class Statement stmt where type ExprT stmt; type VarT stmt; ...
16:43:46 <brad_larsen> lilac: I end up writing a bunch of VarT stmt (ExprT stmt a) sort of stuff in the signatures of the class functions
16:44:01 <ClaudiusMaximus> anyone have some pure haskell code for singular value decomposition? i only need to decompose 2x2 real matrices, so any external linear algebra libraries are likely to be massive overkill....
16:44:07 <brad_larsen> lilac: using a normal type synonym outside of the class definition, the best I can come up with is...
16:44:19 <brad_larsen> lilac: type SVar stmt a = VarT stmt (ExprT stmt a)
16:44:52 <brad_larsen> lilac: which allows me to simplify the class function signatures, but it still requires `stmt' as a type parameter
16:45:24 <brad_larsen> lilac: if I could have a scoped type synonym, I wouldn't need the `stmt' type parameter
16:45:45 <brad_larsen> oh well, for now, I'll settle with the type synonym.
16:47:13 <lilac> you can use the type equality trick if you're using the type synonym multiple times in the same type, at least
16:47:29 <brad_larsen> yeah
16:47:30 <Cale> @dice 99999999999999999999999999999999999999999999999999d0
16:47:30 <lambdabot> 999999999999999999999999999... => -26965397022934738615939577861835371004269...
16:48:29 <brad_larsen> anyone experienced with ``finally tagless'' DSLs?
16:48:55 <pastorn> brad_larsen: what does that mean? "finally tagless"?
16:49:08 <brad_larsen> referring to a recent paper.  hang on
16:49:31 <ivanm> pastorn: they finally managed to get rid of the tags... duh... :p
16:49:41 <brad_larsen> http://okmij.org/ftp/Computation/tagless-typed.html
16:49:42 <lilac> @hoogle MonadState m s => (s -> (s, a)) -> m a
16:49:42 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
16:49:43 <lambdabot> System.Random getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
16:49:46 <pastorn> ivanm: why of course...
16:50:18 <brad_larsen> ``Finally Tagless, Partially Evaluated:  Tagless Staged Interpreters for Simpler Typed Languages'' by Carette, Kiselyov, and Shan
16:50:49 <Peaker> sometimes hoogle is awesome, sometimes its a little dumb ;)
16:50:50 <brad_larsen> used also in ``Unembedding Domain-Specific Languages'' by Atkey, Lindley, and yallop
16:50:56 <ivanm> Peaker: I'd say it's more a 50-50 (OK, maybe 60-40)
16:51:24 <brad_larsen> i have a question regarding that technique
16:52:15 <brad_larsen> ...but unfortunately, have to leave now
16:56:12 <juhp> dcoutts__: can I ask you about cabal haddock - well http://hackage.haskell.org/trac/ghc/ticket/3532
16:56:24 <juhp> any ideas?
16:56:25 <ivanm> preflex_: seen dcoutts_
16:56:25 <preflex_>  dcoutts_ was last seen on #haskell 10 days, 9 hours, 46 minutes and 47 seconds ago, saying: it separates the hard working values from the slakker types
16:56:28 <ivanm> preflex_: seen dcoutts__
16:56:28 <preflex_>  dcoutts__ was last seen on #ghc 55 days, 20 hours, 34 minutes and 24 seconds ago, saying: dons: do you get how this ever worked:
16:56:36 <ivanm> juhp: looks like you don't have much luck ;-)
16:56:38 <ivanm> preflex_: seen dcoutts
16:56:38 <preflex_>  dcoutts was last seen on #haskell 4 hours, 56 minutes and 31 seconds ago, saying: :-)
16:56:54 <juhp> ivanm: maybe I'll cc him :)  thanks
16:56:57 <ivanm> juhp: I think it's about midnight for dcoutts_ ...
16:57:03 <juhp> yeah
16:57:08 <benmachine> it's about midnight for me
16:57:32 <benmachine> just sayin'
16:57:55 <benmachine> @time dcoutts_
16:57:56 <lambdabot> Local time for dcoutts_ is Thu Sep 24 00:57:55
16:58:24 <ivanm> oh, is there daylight saving in the UK?
16:58:42 <benmachine> similar idea
16:58:47 <benmachine> it's called british summertime
16:58:56 <Raevel> i read "local time for dceoutts" as "it's time for donuts"
16:58:57 <Raevel> :-((
16:58:58 <juhp> ivanm: yeah
16:59:01 <benmachine> and I invariably forget when it starts and ends
17:11:43 <aconbere> hmmmm
17:13:04 <aconbere> I have a Setup.hs file associated with my .cabal file. But running Setup configure doesn't find the same packages as cabal install (dependencies fail)
17:14:40 <Saizan> aconbere: you need --user, i think
17:15:03 <Saizan> cabal-install uses --user by default, while for Setup.hs the default is --global
17:16:01 <aconbere> ah
17:16:01 <aconbere> k
17:25:47 <lispy> Saizan: yes, I've always found that terribly confusing.  If you start installing things with one you have to keep using it or else things mysteriously break
17:27:06 <Saizan> lispy: actually Setup.hs is deprecated as an user interface
17:27:19 <lispy> good
17:27:34 <fbru02> i have a newby question, why should i care about restricting my types using GADT or whatever when i can fully anotate and have quickcheck check my types to see if they are indeed what I wanted ?
17:28:30 <dons> static versus testing guarantees
17:28:38 <dons> also, your GADT may lead to faster code
17:28:57 <dons> do you want an a priori proof of correctness, or experimental evidence?
17:30:06 <fbru02> dons : thank you for the answer , i mean , i guess proof of correctness is nice , but sometimes it might be easier in non critical systems to experiment a little bit and annotate to lead the compiler as required ?
17:30:10 <lispy> In other words, you would rather have the compiler test it or would you rather take the time to test it?
17:30:30 <dons> fbru02: sometimes testing is easier
17:30:35 <dons> esp. if you don't have the design yet
17:30:44 <dons> the type system tends to "bake in" the design, making it harder to change
17:31:58 <Saizan> it can also help you make sure you propagate the changes in design in all the right places
17:32:43 <fbru02> so i guess as always there is a compromise not a single answer, but as a User of Haskell should i care about this issues or lead it them to GHC mantainers to  dictate what is good for me ?
17:33:01 <dons> hmm?
17:33:22 <ivanm> so Haskell is now an "advanced" purely functional programming language?
17:33:27 <ivanm> when did that advanced get in there?
17:33:42 <dons> it always was?
17:33:55 <dons> its not your grandad's functional language
17:33:59 <ivanm> heh
17:34:07 <fbru02> i mean right now they are extensions to the language
17:34:10 <ivanm> I've never seen the word "advanced" in there for descriptions of Haskell
17:34:22 <Axman6> dons: what'd you think of that stuff on OpenCL i wrote btw?
17:34:25 <pastorn> dons: was that you i saw in that video on the talk about what books that should be written?
17:34:39 <ivanm> pastorn: that was bos doing the talk
17:34:51 <pastorn> cool
17:34:52 <dons> Axman6: good stuff. though wish there were graphs of the speedups
17:34:55 <dons> and slowdowns
17:34:56 <ivanm> dons did get up at one point to mention something from the audience
17:34:58 * Axman6 is watching that at the moment
17:34:58 <fnord123> Am watching Bryan's talk from CUFP. Thanks for putting it online (whomever put it online). Is this the link being shared for the rest of the videos: http://www.vimeo.com/6696959 ? If so, would it be worth adding it to the topic? :)
17:35:02 <dons> fbru02: oh you mean, GADTs
17:35:06 <fbru02> yes
17:35:09 <pastorn> ivanm: yeah, that was what i meant...
17:35:29 <Axman6> dons: yeah, that would be nice... if you've got any ideas on how to do such things i'd be willing to try them :)
17:35:59 <ivanm> this looks cool; pity it's in Python though :( http://gimbo.org.uk/blog/2009/09/23/generating-an-index-of-haskell-haddock-docs-automatically/
17:36:31 <sfuentes> fnord123: +1
17:36:31 * dons hacks on judy hashes a bit
17:37:10 <ivanm> dons: is that what wikipedia calls judy arrays?
17:37:35 <Axman6> dons: any chance you'd be able to say write some post on benchmarking code, with graphs and all?
17:37:44 <ivanm> "Judy consumes more CPU time than all other data structures, but aims to make up for this usage with less waiting on memory." :o
17:37:49 <dons> Axman6: talk to bos
17:37:54 <dons> he's got the uber benchmarking suite
17:38:04 <ivanm> dons: has he released it yet?
17:38:08 <Axman6> ah, excellent. i'll check that out
17:38:17 <pastorn> bos: i would buy this book if it existed "Haskling your way to high performance games"
17:39:03 <ivanm> pastorn: is "Haskling" a new verb which means "use Haskell to"? :p
17:39:19 <pastorn> ivanm: i'm swedish, we make new verbs all the time :)
17:39:34 <Saizan> ivanm: the darcs cabal-install has an option to keep an index of the installed haddock docs with the same format as this http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:39:55 <ivanm> Saizan: well, I don't use cabal-install :(
17:39:56 <pastorn> you just put an 'a' at the end of a noun, and your "doing" that noun, sort of
17:40:04 <ivanm> (well, I use it for testing packages I'm hacking on, but that's about it)
17:40:28 <ivanm> pastorn: heh... I've seen jokes for Ukrainian like that: "to run: runuvaty; to swim: swimuvaty", etc.
17:40:53 <pastorn> ivanm: brush (n) = borste; brush (v) = borsta
17:41:03 <ivanm> heh
17:41:48 <Saizan> ivanm: i guess we could expose a command to force the generation of the index
17:42:02 <ivanm> *nod*
17:42:38 <pastorn> i don't know if i'm doing it wrong, but in other languages (C etc.) it seem like six hours in, people are like, look at my cool pixelshader effects i'm using in my rudementary game environment
17:42:48 <lispy> dons: oh, speaking of benchmarking.  I haven't been able to get hp2any to work, nor have I found who to contact
17:42:56 <dons> lispy: hmm. tibbe
17:43:04 <pastorn> and i'm like, "how do i design this datatype to contain the vars i need i my state in a good way"?
17:43:04 <dons> he is the mentor for gergai, the student
17:43:31 <Axman6> dons: one day, you must write the haskell users phone book of which people to contact for which problems ;)
17:43:34 <lispy> dons: it gives a weird error message about failure to connect to the RTS and recommends making sure you're using the threaded RTS (which we definitely are) and I can profile regularly
17:44:05 <lispy> Axman6: heh, are you saying we're 1 bus away from being a disconnected community?
17:44:22 <Axman6> no, just saying it would save a lot of time :P
17:44:56 <pastorn> i bet augustsson would produce a 1:1 embedding of glsl if he just sneezed at it
17:45:45 <dons> lispy: do you need ghc head i wonder?
17:45:56 <lispy> dons: oh, maybe.  I have 6.10.4
17:46:29 <lispy> I got it from the Platform
17:46:48 <lispy> hmm...if you work on the Haskell Platform does that make you a platformer?
17:47:25 <lispy> dons: I had trouble digging up info about hp2any that looked authorative and recent
17:49:26 <dons> lispy: tibbe will be a good resource
17:50:01 <lispy> how would I do something like this (It doesn't type check and BC is ByteString.Char8): (BC.pack $ show $ BC.ord c)
17:50:13 <lispy> I want to print the numeric value of C
17:50:15 <lispy> er c
17:50:22 <lispy> and by print I mean, convert to a bytestring
17:50:39 <lispy> "a" -> "97"
17:50:40 <tommd> Have you heard?  Evidently bashing $LANGUAGE_1 in irc #LANGUAGE_2 is considered informative these days.
17:51:31 <dons> shouldn't really do that. :)
17:51:34 <Axman6> tommd: care to expand those?
17:51:46 <dons> lispy: hmm. bytestring-show package?
17:51:52 <dons> will be faster than pack.
17:52:20 <lispy> dons: well, darcs can't allow spaces in path names without changing the patch format.  At some point someone decidide to escape whitespace by character value.  I'm trying to optimize it without changing the patch format :(
17:52:21 <tommd> Axman6: http://lwn.net/Articles/353578/    guys in #perl in an unknown decade were commenting negatively on Haskell - this was referred to as an informative conversation.
17:52:39 <Axman6> dons: just watched bos' video on this benchmarking library, and it looks excellent
17:52:54 <Axman6> heh
17:53:28 <dons> tommd: lwn rots the brain
17:53:39 <Axman6> "Haskell and ghc are still fine to play with and highly enlightening, but I'd never use them in anything "industrial strength", that I want to depend on."
17:54:30 <tommd> dons: Its a shame - it really used to be a decent source of discussion.
17:54:34 * lispy grumbles about the irony of that statement from someone who uses dynamicly typed languages
17:54:57 <dons> hearsay and rumour. clearly we are a threat.
17:55:06 <dons> finally!
17:55:19 <Axman6> hoorah!
17:55:35 <Axman6> RALLY THE TROOPS! We've got them scared!
17:55:36 <Axman6> >_>
17:55:52 * Axman6 loads his >>= cannon
17:56:31 <dons> tommd: besides the ridiculous segfault claims, the memory hog is also funny,  essentially identical to perl and its decades of C optimizatoins, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=perl&box=1
17:56:40 <dons> but with 347x the performance
17:56:48 <lispy> dons: unless I misunderstand bytestring-show it doesn't really do what I want.  In particular, I need the bytestring equivalent of rd
17:56:50 <lispy> ord
17:56:52 <lispy> :t ord
17:56:55 <lambdabot> Char -> Int
17:57:37 <Axman6> dons: but haven't you heard? the shootout is silly and down't show anything of use
17:58:04 <Axman6> doesn't*
17:58:28 * Axman6 thinks this isn't totally false, when it comes to basically writing C in haskell.
17:58:36 <lispy> actually, maybe I'm just silly here
17:59:10 <dons> i don't see many people say its silly. its been hammered on too much to be silly
17:59:15 * dons doesn't feel like a victim.
18:00:02 <Axman6> i personally think the shootout has quite a bit of merit
18:00:11 <Axman6> but others do not
18:00:24 <jmelesky> the shootout is silly, though it's useful too
18:00:44 <lispy> I want a VCS shootout
18:00:47 <Axman6> (i got some quite unpleasant responses when i complained about the thread-ring speed of Ada in #Ada)
18:00:50 <lispy> anyone want to get started on that :)
18:00:55 <jmelesky> but all too frequently it reflects time spent by submitters rather than properties of the languages
18:01:02 <lispy> We could either hackout out from the existing shootout source code or use happs.
18:03:34 <lispy> :t chr
18:03:35 <lambdabot> Int -> Char
18:03:40 <jmelesky> how about a kernel shootout?
18:04:08 <fnord123> 6.12's feature list looks beast. Any ideas when it will be released?
18:04:36 <pastorn> jmelesky: house v. linux. v. freebsd v. win7?
18:04:52 <pastorn> i'd love to see how house does at that
18:05:09 <Makoryu> pastorn: ...vs. Haiku vs. Hurd vs. ....
18:05:16 <jmelesky> pastorn: v. netbsd v. openbsd v. BeOS v. Haiku v. WinXP v. ...
18:05:33 <jmelesky> oh, forgot darwin
18:05:38 <Makoryu> Oh yeah, and Darwin
18:06:18 <pastorn> jmelesky, Makoryu: only took dominant kernels
18:06:18 <Makoryu> Hahaha
18:06:18 <dons> fnord123: about 2 weeks
18:06:18 <Makoryu> pastorn: Right, avoiding niche OSes
18:06:18 <pastorn> yes
18:06:18 <pastorn> dominant - TO ME
18:06:20 <Makoryu> pastorn: So why'd you include Win7? ;)
18:06:22 * pastorn is at the center of the world - and he ain't leavin it!
18:06:23 <jmelesky> a shootout is a place for the niche to shine!
18:06:43 <Axman6> heh, watching http://vimeo.com/6680185: "what do you do when you're not don Stewart to make programs run fast?"
18:07:02 <pastorn> Axman6: hehe, great title
18:07:15 <Axman6> pastorn: that's just a quote from it
18:07:27 <pastorn> oh, cool
18:07:55 <Axman6> dons: i'd love to see more stuff from you on writing fast programs in haskell. also where did those posts on writing haskell faster than C go from your blog?
18:08:44 <jmelesky> Axman6: you should write the Haskell tuning book. Don's already got a book
18:08:58 <Axman6> i would, if i were any good at it :)
18:09:13 <fnord123> dons, great! We'll have to rebuild our cabal packages for the new ghc version, right? Every time I updated ghc in the past  it got confused by what's in my ~/.ghc/.*6.x.y/ vs. what's in ~/.cabal
18:09:23 <jmelesky> you'll be good at it by the time you've finished the book. :)
18:09:32 <Axman6> ha. true :)
18:09:36 <Axman6> maybe one day :)
18:10:04 <Axman6> i'm only a second year at uni, so i'm well off that point at the moment
18:11:05 <fnord123> I'll probably end up nuking cabal and ghc directories from orbit if I run into trouble. :-/
18:11:49 <Saizan> fnord123: there shouldn't be any confusion, but you do need to reinstall them for the new compiler
18:15:01 <Makoryu> fnord123: It's the only way to be sure.
18:17:12 <pastorn> Axman6: where are you studying?
18:21:22 <O_4> Hmm, can't I use "BS.empty" as a pattern in a function definition?
18:23:47 <SamB_XP_> @keal
18:23:48 <lambdabot> antiparsimony were 100% correct...
18:23:58 <SamB_XP> @keal
18:23:59 <lambdabot> i want to invent white dye
18:24:01 <SamB_XP> @keal
18:24:01 <lambdabot> oh btw my fpu is blown due to a hardcased failsafe i have 3 year warranty right. and then they call fads
18:24:44 <SamB_XP> @keal
18:24:44 <lambdabot> intuitive != imperative
18:24:56 <SamB_XP> there seems to be a keal sighting in #nsrt ...
18:24:59 <Makoryu> O_4: Nope, you can only use constructors and literals
18:25:07 <lispy> O_4: no, but you can do, foo b | BS.null b = ...
18:25:45 <O_4> Hmm, I guess that makes sense, but it's a bit inconvenient :-p
18:26:15 <lispy> O_4: you can try it with overloaded strings but I don't think it will work any better
18:26:30 <O_4> lispy: thanks for the suggestion, I'll see if I can rewrite this using guards
18:26:46 <Peaker> who's he?
18:27:04 <lispy> Peaker: a crazy troll from years past
18:27:13 <lispy> Peaker: immortalized via @keal
18:27:15 <lispy> @keal
18:27:15 <lambdabot> its because the timeline diverges and past events themselves unhappen
18:27:16 <Peaker> O_4, upper-case things (or operators that start with :) are data constructors, you can only pattern match on those (and on numbers)
18:27:29 <Peaker> heh
18:28:45 <pastorn> i'm looking at the source of GHC.Conc
18:28:52 <pastorn> atomically (STM m) = IO (\s -> (atomically# m) s ) <-- what is this?
18:29:05 <pastorn> seems like an infinite type to me...
18:29:20 <Peaker> pastorn, atomically# is distinct from atomically
18:29:45 <pastorn> hmm, i thought that # was some memory-thingamojigg
18:29:51 <Peaker> pastorn, atomically basically applies atomically# on the m in the STM it gets, passing along the s. It could be nicer with SEC composition, IMO
18:30:20 <pastorn> Peaker: SEC?
18:31:02 <Peaker> @where SEC
18:31:02 <lambdabot> I know nothing about sec.
18:31:08 <pastorn> @hoogle atomically#
18:31:09 <lambdabot> No results found
18:31:12 <pastorn> exactly
18:31:15 <Peaker> @go Semantic Editor Combinators
18:31:15 <lambdabot> Maybe you meant: google googleit do
18:31:16 <SamB_XP> huh, keal says @keal is epic, and that he was probably drunk when he said those things ;-P
18:31:17 <pastorn> doesn't exist :(
18:31:22 <Peaker> @google Semantic Editor Combinators
18:31:23 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
18:31:23 <lambdabot> Title: Conal Elliott » Semantic editor combinators
18:31:38 <Peaker> @where+ SEC http://conal.net/blog/posts/semantic-editor-combinators/
18:31:39 <lambdabot> I will remember.
18:31:41 <Peaker> @where SEC
18:31:41 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
18:32:53 <tommd> @where FAA
18:32:53 <lambdabot> I know nothing about faa.
18:32:54 <tommd> @where SEC
18:32:55 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
18:32:58 <tommd> @where DOD
18:32:58 <lambdabot> I know nothing about dod.
18:33:16 <tommd> we can cover more of these tla's if we just try a little harder.
18:34:35 <Peaker> know what? no need for SECs even
18:34:46 <Peaker> @pl atomically (STM m) = IO (\s -> (atomically# m) s )
18:34:47 <lambdabot> (line 1, column 20):
18:34:47 <lambdabot> unexpected "="
18:34:47 <lambdabot> expecting variable, "(", operator or end of input
18:34:53 <Peaker> @pl atomically (STM m) = IO (\s -> (atomically' m) s )
18:34:53 <lambdabot> (line 1, column 20):
18:34:53 <lambdabot> unexpected "="
18:34:53 <lambdabot> expecting variable, "(", operator or end of input
18:35:10 <Peaker> @pl atomically m = IO (\s -> (atomically' (unSTM m)) s )
18:35:11 <lambdabot> atomically = IO . atomically' . unSTM
18:35:18 <Peaker> that's nicer :)
18:35:44 <pastorn> wat?
18:35:50 <pastorn> nevermind i asked...
18:36:03 <pastorn> *forget*
18:36:18 * pastorn reads about SEC, seems easier, all of the sudden
18:36:25 <Makoryu> So, then, atomically (STM m) = IO . atomically# m ...?
18:36:37 <te> So I just compiled ghc from source and installed it to /usr/local, i tried using the bootstrap script in cabal-install, but it failed, im on ubuntu jaunty x64
18:36:40 <te> any ideas?
18:36:44 <Peaker> pastorn, one of conal's pearls
18:36:58 <te>  /usr/bin/ld: cannot find -lgmp
18:37:04 <pastorn> te: install binary?
18:37:26 <pastorn> that was the advice i got when i asked about installing from cabal...
18:37:41 <pastorn> te: or are you trying out bleeding edge stuff?
18:38:01 <Peaker> te, install libgmp
18:38:07 <Peaker> Makoryu, No:  atomically (STM m) = IO . atomically# $ m
18:38:19 <Makoryu> Peaker: Whoops >_>
18:39:03 <te> pastorn: this is a fairly stable release i believe
18:39:16 <pastorn> i installed 6.10.4 from the binary
18:39:20 <pastorn> works like a charm
18:39:29 <pastorn> why would you want to compile it?
18:39:52 <Peaker> Makoryu, but why do the pattern matching explicitly? use unSTM :)
18:40:16 <Peaker> Brian O'Sullivan's talk was nice
18:40:50 <te> cabal-install 0.6.2, ghc 6.10.4
18:41:10 <te> pastorn: in the past i needed to to compile a lot of the xmonad goodies
18:41:26 <te> so that's just kind of my normal path i take when setting up my system now
18:41:39 <aconbere> so what I ended up doing was writing my tests in module inside my app MyApp.Test.Buffer in the MyApp.Test module there's a main function defined which runs a test suite through test-framework. And I have a little bash script that compiles and removes a test executable from that Module.
18:41:50 <aconbere> I'm not sure if that feels "haskelly"
18:41:59 <Peaker> convert your bash script to Haskell ;)
18:42:04 <aconbere> but I like it better than hacking things into Setup.hs and cabal files :P
18:42:22 <aconbere> Peaker: sounds good to me :P
18:42:26 <Peaker> I have no idea how to do proper testing in Haskell
18:42:32 <Peaker> (in terms of scripting around it)
18:42:53 <aconbere> Peaker: I'm not sure i know either, after an afternoon of reading about it
18:43:09 <SamB> @8ball does using Haskell make the shell script better?
18:43:09 <lambdabot> Unknown command, try @list
18:43:12 <SamB> aww
18:43:21 <aconbere> supposedly better support is coming to cabal, until then... it seems a rather weakly supported
18:52:06 <Saizan_> better support is coming to cabal only if you code it!
18:52:50 <te> ^^
18:53:47 <FunctorSalad> one way is to just make an extra testing cabal project...
18:54:04 <FunctorSalad> but I missed the beginning of this discussion
18:55:06 <aavogt> hi, there's nobody in #happs at the moment, but could somebody help me trouble a space leak in this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9760#a9761
18:55:13 <aavogt> by trouble, I mean solve
19:06:20 <duaneb> anyone here use Snow Leopard?
19:06:31 <duaneb> I'm trying to get GHC to play nice with it
19:06:45 <duaneb> but LD is trying to use the architecture x86_64
19:07:29 <SamB> duaneb: so is gcc, isn't it ?
19:08:11 <ivanm> unless duaneb has installed an x86 version of GHC instead of x86_64 (or vice versa)
19:08:14 <duaneb> SamB: no, it's actually not
19:08:16 <duaneb> I don't think
19:08:31 <duaneb> ivanm: ther is no x86_64 version of ghc for OS X
19:08:51 <ivanm> *shrug*
19:09:05 <SamB> duaneb: last I heard, the GCC defaulted to 64-bit compiles there ..
19:09:12 <ivanm> I've only ever used OSX on the uni machines when tutoring
19:09:19 <duaneb> Oh, never mind
19:09:20 <SamB> ask copumpkin for details, I think
19:09:32 <duaneb> I was using `-optl-3` instead of `-optl-32`
19:09:35 <duaneb> which would work
19:09:41 <duaneb> SamB: yea, but I turned that off
19:09:47 <SamB> duaneb: ah
19:10:04 <SamB> duaneb: might have said that when you said "it's actually not" ;-P
19:10:12 <duaneb> probably
19:10:14 <SamB> then I would have maybe believed you ;-P
19:10:31 <duaneb> I'm glad the ghc is flexible enough to compile for a different architecture with only a few flags
19:10:44 <duaneb> This is weird
19:10:46 <SamB> it isn't
19:10:49 <duaneb> I'm using Haskell to convert C code to Python
19:11:03 <SamB> that sounds awfully odd
19:11:08 <SamB> why are you doing it?
19:11:16 <SamB> the Python will be the worst python you ever saw, won't it ?
19:11:21 <duaneb> I hate doing this sort of stuff by hand
19:11:30 <duaneb> SamB: well, ctypes declarations
19:11:35 <SamB> ah
19:11:48 <SamB> just prototypes, then?
19:18:42 <aconbere> FunctorSalad: I've just been musing about how to structure tests in haskell projects
19:19:09 <aconbere> FunctorSalad: I went with a Test module under my main module, and having ghc build me a test executable from that
19:24:57 <FunctorSalad> aconbere: ghc --make Test -main-is Test?
19:25:06 <aconbere> basically
19:25:07 <aavogt> is there a way to get cabal install to rebuild everything with profiling?
19:25:27 <FunctorSalad> you could also make an extra section in the cabal file to have cabal build it
19:25:27 <aconbere> ghc --make Hed.Test --main-is Hed.Test -o hed-test
19:27:53 <aconbere> FunctorSalad: in a second Executable section?
19:28:18 <FunctorSalad> aconbere: yes
19:31:27 <Augur_> Does GHCI not come with Control.Monad.Writer by default?
19:32:29 <FunctorSalad> you need to import it (:m +Control.Monad.Writer)
19:33:52 <FunctorSalad> (you could also put that into ~/.ghci)
19:34:28 <tommd> Evidently GHCi HEAD repl can understand "import Control.Monad.Writer"
19:35:13 <shachaf> tommd: But it's not a "real" import (you can't import qualified or anything like that).
19:35:27 <tommd> Really?  Aww, that's a shame.
19:35:33 <Augur_> Trying to :m +Control.Monad.Writer tells me it could not find module, ditto for importing it. I suspect something's wrong with my installation.
19:36:27 <shachaf> Augur_: You probably need mtl.
19:36:35 <augur> O_O
19:36:47 <augur> who is this augur_ >|
19:36:56 <augur> you liar!
19:36:58 <augur> you chear!
19:37:00 <augur> cheat..
19:37:04 <augur> you ruiner of spelling!
19:37:12 <FunctorSalad> :o
19:37:18 <Augur_> I had this name first :o
19:37:22 <augur> really?
19:37:24 <augur> cause uh
19:37:28 <Augur_> You're probably just a computer I forgot to log off. Shoo, shoo!
19:37:30 <augur> i have this one registered.
19:38:02 <Augur_> This only further proves that you're a computer run amok. I'll deal with you when I get home.
19:38:22 <augur> lies
19:38:42 <aavogt> @nixon
19:38:42 <lambdabot> The press is the enemy.
19:38:42 <augur> :o
19:38:44 <nyingen> only one way to resolve this: calculate THAC0 and single combat via @dice command.
19:38:45 <FunctorSalad> but... he didn't even spell it differently
19:38:53 <augur> Augur:, are you sexy like a fox?
19:38:58 <gwern> > (26 * 30) / 60
19:38:58 <augur> Augur_
19:38:58 <lambdabot>   13.0
19:39:00 <augur> *
19:39:14 <Augur_> augur: I'm scared of talking off-topic in #haskell, is what I am :E
19:39:27 <augur> cause if you are, we should totally make out and confuse the hell out of everyone
19:39:40 <gwern> > (39 * 20 + 5 * 30 + 120 + 50 * 30) / 60
19:39:41 <lambdabot>   42.5
19:42:09 <FunctorSalad> "The augur was a priest and official in the classical world, especially ancient Rome and Etruria. His main role was to interpret the will of the ..."
19:42:12 * augur eats a FunctorSalad
19:42:54 <gwern> '“What are your fees?” inquired Guyal cautiously.
19:42:54 <gwern> “I respond to 3 questions,” stated the augur. “For twenty terces I phrase the answer in clear and actionable language; for 10 I use the language of cant, which occasionally admits of ambiguity; for five, I speak a parable which you must interpret as you will; and for one terce, I babble in an unknown tongue.”'
19:42:54 <duaneb> anyone used the haskell OpenCL extension yet?
19:43:47 <tommd> augur: No quoting arrested development here - only real development is on topic.
19:43:47 <tommd> ;-)
19:43:47 <augur> tommd what? D:
19:44:15 <tommd> Oh - I thought your makeout comments was inspired by Hollywood - I guess I'm mistaken.  Should have known, it wasn't that similar.
19:44:27 <tommd> s/comments/comment
19:44:32 <augur> tommd: :|
19:44:37 <augur> you're weird
19:44:45 <augur> conal!
19:45:00 <augur> i tried to watch your talk on FRP
19:45:04 <augur> i didnt get it at all
19:45:06 <augur> but
19:45:09 <augur> i saw you.
19:45:11 <augur> which was cool.
19:45:12 <gwern> is conal broke & working for The Man yet?
19:45:20 <FunctorSalad> :o
19:46:05 * gwern thinks I could've phrased that more diplomatically
19:46:16 <sohum> @oefc 4, 16, 37, 58
19:46:16 <lambdabot>  Take sum of squares of digits of previous term.
19:46:16 <lambdabot>  [2,4,16,37,58,89,145,42,20,4,16,37,58,89,145,42,20,4,16,37,58,89,145,42,20,4...
19:46:29 <aavogt> I have this heap profiling: http://omploader.org/vMmV1Nw/Main.png
19:46:31 <ivanm> gwern: how?
19:47:07 <augur> efc is the name of the cafe owned by the character that i take my name from
19:47:08 <augur> :o
19:47:17 <gwern> ivanm: I could've said something like, 'I recall conal mentioning that his savings were running out and he was considering either a startup or finding a nice tech job; given I haven't heard about any of the former, I wonder whether he's seekign the latter now?'
19:48:36 <ivanm> hmmmm.... true
19:48:40 <medfly> heh, the #haskell gang is conversing.
19:48:50 <FunctorSalad> :o
19:49:00 <gwern> > 0.99 * 0.99
19:49:01 <lambdabot>   0.9801
19:49:21 <ClaudiusMaximus> sample output video of my current haskell project >> http://www.archive.org/details/ClaudiusMaximus_-_Fl4m6e_r1333
19:49:40 <sohum> what, what's the oefc plugin link into?
19:50:08 <ivanm> medfly: what else do you propose we do here?
19:50:22 <ivanm> act emo like and just idle here, not talking? :p
19:50:33 <ivanm> ps-auxw: so which processes are running?
19:50:36 <ivanm> ;-)
19:51:00 <oDric_oClumns> sohum: That's oeis. :)
19:51:17 <sohum> so why's it named oefc?
19:51:26 <sohum> or is that the autocorrection again?
19:51:27 <ps-auxw> Too many to list here. ;)
19:51:27 <gwern> edit distance
19:51:32 <ivanm> sohum: probably
19:51:44 <jfoutz> online encyclopedia of integer sequences.
19:51:45 <jfoutz> http://www.research.att.com/~njas/sequences/
19:52:06 <oDric_oClumns> sohum: It isn't. Lambdabot uses a two-letter edit distance rule to "give you the command you Really wanted"(TM). ;)
19:52:08 <FunctorSalad>  /exec ps auxw
19:52:12 <FunctorSalad> (...)
19:52:24 <ivanm> FunctorSalad: don't be evil! ;-)
19:52:40 * p_l counted 120 processes
19:52:41 <ivanm> oDric_oClumns: which is annoying with the new @do plugin
19:52:54 <sohum> oDric_oClumns: right, fair enough
19:52:55 <ivanm> since it means we can't use @go anymore for @google :(
19:53:01 <FunctorSalad> ivanm: I'm not google or something :o
19:53:12 <ivanm> FunctorSalad: heh
19:53:18 <jfoutz> @nxn
19:53:18 <lambdabot> Maybe you meant: nixon run wn
19:53:26 <FunctorSalad> (only google is non-evil.)
19:53:31 * ivanm wonders what @run does)
19:53:35 <oDric_oClumns> ivamn: Hmm, I thought it was bombing out because there's a 'googleit' command now, too? :)
19:53:36 <jfoutz> @run
19:53:36 <lambdabot>   not an expression: `'
19:53:43 <ivanm> FunctorSalad: yes, they're just sometimes naughty ;-)
19:53:47 <ivanm> @run 2+3
19:53:47 <jfoutz> @run 1+2
19:53:47 <lambdabot>   5
19:53:48 <lambdabot>   3
19:53:51 <ivanm>  @run = > ?
19:53:53 <aavogt> @help google
19:53:53 <jfoutz> heh.
19:53:53 <lambdabot> google <expr>. Search google and show url of first hit
19:54:04 <jfoutz> @help run
19:54:04 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
19:54:13 <sohum> @help >
19:54:13 <oDric_oClumns> ivanm: Yes.
19:54:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:58:46 <Gracenotes> @. run run text . intercalate "+" . map show $ [1..5]
19:58:48 <lambdabot>   15
19:58:58 <ivanm> :o
19:59:08 <ivanm> Gracenotes: how long did it take you to think that up?
19:59:48 <Gracenotes> hm, I don't remember. it might fail for larger expressions, though.. even in plugin composition, lambdabot likes cutting off text
20:01:08 <aavogt> @. google run (fix $ \x -> 1:1:zipWith (+) x (tail x))
20:01:09 <lambdabot> No Result Found.
20:01:17 <aavogt> @run (fix $ \x -> 1:1:zipWith (+) x (tail x))
20:01:17 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:01:36 <copumpkin> scanl's prettier
20:02:03 <aavogt> @. vixen vixen you're prettier
20:02:03 <lambdabot> i do tend to talk in circles at times
20:02:15 <ivanm> lol
20:02:20 <ivanm> that's highly appropriate
20:02:22 <Gracenotes> +1 for perfectly appropriate
20:02:52 <Gracenotes> hm, I do tend to like fix
20:03:44 <Gracenotes> particularly when it's fix ((0:) . (1:) . (zipWith (+) <*> tail))
20:04:22 <jfoutz> @. oeis run (fix ((0:) . (1:) . (zipWith (+) <*> tail)))
20:04:23 <lambdabot>  Sequence not found.
20:04:37 <copumpkin> @@ @oeis @run fix ((1:) . scanl (+) 1)
20:04:38 <lambdabot>  Sequence not found.
20:04:45 <copumpkin> > fix ((1:) . scanl (+) 1)
20:04:45 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:04:52 <FunctorSalad> maybe drop the bracket
20:05:02 <aavogt> is hpaste down for anyone else?
20:05:02 <Gracenotes> or intercalate " "
20:05:07 <copumpkin> aavogt: nope
20:05:19 <jfoutz> @. oeis run intercalate " " $ map show (fix ((0:) . (1:) . (zipWith (+) <*> tail)))
20:05:20 <lambdabot>  Numbers n such that the period length P(n) of the Fibonacci sequence mod n i...
20:05:20 <lambdabot>  [1,5,6,10,12,20,24,25,30,50,60,100,120,125,150,250,300,500,600,625,750,1250,...
20:05:28 <copumpkin> lol
20:05:40 <copumpkin> > fix ((0:) . (1:) . (zipWith (+) <*> tail))
20:05:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:08:25 <FunctorSalad> @. google slap copumpkin
20:08:26 <lambdabot> No Result Found.
20:08:34 <FunctorSalad> ;)
20:08:59 <aavogt> copumpkin: well, now it works
20:09:19 <copumpkin> :o
20:09:25 <ivanm> @. vixen slap copumpkin
20:09:26 <lambdabot> I will NOT be ignored...
20:09:29 <ivanm> heh
20:09:46 * ivanm wished there was a way to show intermediary results for @.
20:10:06 <aavogt> we need @ap ?
20:10:43 <ray> @. slap vixen
20:10:44 <jfoutz> @. google text run 1
20:10:47 <lambdabot> Come on, let's all slap yeah, why not?
20:10:47 <lambdabot> Plugin `compose' failed with: Unknown command: "text"
20:10:52 <pastorn> how do i check which version of a library i am using?
20:10:56 <jfoutz> @text stuff
20:10:56 <lambdabot> Maybe you meant: let tell thx
20:10:59 <jfoutz> hmm.
20:11:11 <ivanm> pastorn: ghc-pkg list <foo> ?
20:11:11 <ray> @. slap yow
20:11:11 * lambdabot secretly deletes Couldn't find fortune file
20:11:11 <lambdabot> 's source code
20:11:17 <pastorn> /home/alexander/.ghc/i386-linux-6.10.4/package.conf:
20:11:19 <pastorn>     OpenGL-2.2.2.0, OpenGL-2.2.3.0, OpenGL-2.4.0.1
20:11:58 <Saizan_> it defaults to the latest
20:12:25 <FunctorSalad> maybe pastorn is using cabal though
20:12:32 <Saizan_> there's probably a verbosity level that shows which gets linked in too
20:12:39 <pastorn> FunctorSalad: yes i am
20:13:12 <Saizan_> in that case -v shows the decisions at the configure step, iirc
20:13:16 <FunctorSalad> pastorn: I might be wrong but I think then it chooses whatever gives a consistent choice
20:14:41 <pastorn> -v seems to give me... stuff...
20:14:43 <pastorn> hang on..
20:15:45 <aavogt> is there a nice way to interpret the .prof that ghc gets you?
20:16:58 <pastorn> hiding package OpenGL-2.2.3.0 to avoid conflict with later version OpenGL-2.4.0.1
20:17:00 <pastorn> hiding package OpenGL-2.2.2.0 to avoid conflict with later version OpenGL-2.2.3.0
20:17:14 <pastorn> so i'm guessing 2.3.0.1 then... :)
20:18:34 <oDric_oClumns> 2.4.0.1 it seems. Unless there's another one of those "hide the package" (bow-chicka-wow-wow!) lines out there. :)
20:18:47 <pastorn> hehe
20:20:03 <pastorn> hehe, "unsafePreservingMatrix :: IO a -> IO a"
20:22:21 <SamB> pastorn: well *that* type is certainly very enlightening!
20:22:59 <pastorn> SamB: i feel naughty coding with opengl, everything is IO and has state
20:23:05 * Axman6 doesn't think that IO actions should be called unsafe. their type implies that
20:23:14 * pastorn is making himself some nice little IORefs...
20:23:21 <SamB_XP> Axman6: do you know what that one does?
20:23:28 <SamB_XP> ... neither do I
20:23:34 <SamB_XP> but maybe it's unsafer than you know
20:23:41 <Axman6> pastorn: i think the trick is to make as little of your code use IO as possible
20:23:50 <pastorn> Axman6: fuck that
20:24:07 * pastorn has adopted a naughty c programmer bad boy style
20:24:17 <Axman6> SamB_XP: unsafePreservingMatrix m = launchMissiles >> return (transpose m)?
20:24:27 <FunctorSalad> Axman6: I think that one is unsafe in some way other than being IO
20:24:29 <pastorn> evrything in one big 1000+ lines file, and lots and lots of io
20:24:33 <FunctorSalad> there is also "preservingMatrix"
20:24:40 <SamB_XP> Axman6: uh, no
20:24:47 <SamB_XP> that has the wrong type, duh
20:25:05 <Axman6> it's a polymorphic transpose. transposes the bytes
20:25:15 <Axman6> obviously :P
20:25:17 <SamB_XP> there are no bytes
20:25:21 <SamB_XP> this isn't C!
20:25:32 <Axman6> there are in my transpose ;)
20:25:33 <pastorn> SamB_XP, Axman6, FunctorSalad: in gl you have a stack of matrices you multiply with your vertices in order to transform them, preserving means that you get a copy of it on the stack
20:25:43 <FunctorSalad> "A more efficient, but potentially dangerous version of preservingMatrix: The given action is not allowed to throw an exception or change the current matrix mode permanently."
20:25:54 <pastorn> unsafePreserving will die HARD upon any exceptions
20:26:17 <SamB_XP> that does sound pretty unsafe!
20:26:23 <SamB_XP> even for IO
20:26:37 * pastorn thinks this is cool :)
20:26:39 <Axman6> SamB_XP: my transpose takes the block(s) of memory that the argument occupies, and transposes them
20:27:07 <FunctorSalad> I like how it doesn't even describe what happens if it does throw an exception - as if it was too horrible to speak of
20:27:08 <SamB_XP> Axman6: the hourse was dead three hours ago
20:27:21 <Axman6> huh?
20:27:36 <SamB_XP> I'm slightly exhagerating
20:27:49 <Axman6> man, you're no fun. i'm not playing with you anymore
20:27:57 <SamB_XP> lol
20:28:15 * Axman6 goes to play cricket with the cool kids
20:28:17 <oDric_oClumns> unsafePreservingMatrix m = launchMissiles >> fmap transpose m? :)
20:28:17 <pastorn> Axman6: i asked, but you never answered; where do you study?
20:28:28 <pastorn> oDric_oClumns: that seems more like it
20:28:29 <Axman6> ANU
20:28:34 <pastorn> wut?
20:28:42 <Axman6> google it
20:28:45 <Axman6> @google ANU
20:28:46 <lambdabot> http://www.anu.edu.au/
20:28:46 <lambdabot> Title: Home - The Australian National University
20:28:48 <SamB_XP> he doesn't like you either
20:28:54 <SamB_XP> Axman6: it doesn't seem to have worekd
20:28:58 <SamB_XP> @vera ANU
20:29:00 <lambdabot> No match for "ANU".
20:29:05 <Axman6> it worked perfectly...
20:29:06 <SamB_XP> that didn't worked either
20:29:07 <ivanm> @help vera
20:29:07 <lambdabot> I perform dictionary lookups via the following 13 commands:
20:29:07 <lambdabot> all-dicts ... Query all databases on dict.org
20:29:07 <lambdabot> devils ...... The Devil's Dictionary
20:29:07 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
20:29:07 <lambdabot> elements .... Elements database
20:29:09 <lambdabot> [9 @more lines]
20:29:10 <ivanm> ahhh
20:29:16 <ivanm> ANU == Australian National University
20:29:23 <ivanm> best uni down under
20:29:30 <Axman6> one of the best in the world too
20:29:43 <SamB_XP> oh, I saw the part about him dissing your expression but not the question ;-P
20:30:02 <FunctorSalad> why was yesterday so silent here, but wednesday is chaos day?
20:30:15 <ivanm> FunctorSalad: wasn't _that_ silent
20:30:39 <seanstickle> humpskell day
20:30:39 <ivanm> also, you weren't asking stupid questions yesterday :p
20:30:39 <pastorn> hmmm... if i globally declare a datatype that has loads of IORefs in it, could i use that as a state without having to pass it around?
20:30:39 <FunctorSalad> ivanm: ok, wasn't online very long
20:30:39 * oDric_oClumns thinks Axman6 believes it's Thursday...
20:30:45 <pastorn> *declare an instance of a datatype*
20:30:47 <SamB_XP> pastorn: that's considered highly evil
20:31:00 <pastorn> SamB_XP: as i said, fuck language conventions
20:31:00 <SamB_XP> hence, GHC does it
20:31:05 <Axman6> oDric_oClumns: it _IS_ thursday
20:31:05 <pastorn> haha
20:31:10 <Axman6> Thu Sep 24 13:31:10 EST 2009
20:31:24 * ivanm agrees
20:31:46 <seanstickle> Aw, I thought we were all using Swatch beats-time now
20:31:46 <FunctorSalad> pastorn: you still have to use unsafePerformIO to initialise an instance globally
20:31:46 <SamB_XP> pastorn: it seriously can get annoying, though
20:31:47 <FunctorSalad> pastorn: there's a page on haskellwiki presenting the argument, but I forgot the name
20:31:50 <pastorn> FunctorSalad: i can live with that
20:31:57 <SamB_XP> pastorn: Disinform or whatever it's called does it, and it's a pain
20:32:41 <ivanm> seanstickle: nah, that's company-specific
20:32:41 <Axman6> pastorn: technically it's a misuse of unsafePerformIO
20:32:41 <pastorn> SamB_XP: what is that?
20:32:41 <aavogt> @goo est
20:32:41 <lambdabot> Maybe you meant: google googleit do ghc todo yow
20:32:41 <pastorn> Axman6: see above
20:32:43 <ivanm> heh
20:32:45 <ivanm> @help googleit
20:32:45 <lambdabot> letmegooglethatforyou.
20:32:47 <pastorn> you language nazis
20:32:48 <Axman6> see what specifically?
20:32:55 <ivanm> @google haskell
20:32:57 <lambdabot> http://www.haskell.org/
20:32:57 <lambdabot> Title: Haskell - HaskellWiki
20:32:58 <ivanm> @googleit haskell
20:32:58 <lambdabot> http://letmegooglethatforyou.com/?q=haskell
20:33:01 <ivanm> heh
20:33:07 <Axman6> should tinyURL that
20:33:08 <pastorn> if i wasn't supposed to do unsafePerformIO, then why was it provided?
20:33:16 <aavogt> @googleit lmgtfy
20:33:17 <lambdabot> http://letmegooglethatforyou.com/?q=lmgtfy
20:33:17 <Axman6> so you can use the FFI
20:33:33 <pastorn> Axman6: NOWAI
20:33:38 <ivanm> aavogt: heh
20:33:55 <pastorn> well, they should've hidden it deep inside the FFI modules then
20:33:59 <FunctorSalad> pastorn: for cases where you know that what you are doing is referentially transparent
20:34:00 <wdonnelly> if we'd get that ACIO stuff already, I would gladly relinquish the top-level unsafePerformIO hack
20:34:04 <pastorn> not in System.IO.Unsafe, too easy to find
20:34:11 <FunctorSalad> wdonnelly: ahhh that was the name
20:34:34 <pastorn> actually, i DO know when i'm allowed to use unsafePerformIO
20:34:51 <roconnor> @bot
20:34:51 <lambdabot> :)
20:34:51 <lunabot>  :o
20:34:54 <pastorn> but as i said, i'm adopting this bad boy attitude, so i don't really care
20:34:58 <Axman6> well maybe you could quit acting lick such a noob then :)
20:35:02 <Saizan_> rather then ACIO i'd like a more advanced module system
20:35:06 <Saizan_> *than
20:35:28 <Axman6> also, i fucking hate databases
20:35:32 <Axman6> fuck this course >_<
20:35:33 <Saizan_> it'd solve the problem in a more general fashion
20:35:40 <Axman6> i have absolutely no interest in them
20:35:48 <ivanm> Axman6: agreed
20:35:48 <Gracenotes> the order of top-level effects would be problematic in any solution, no?
20:35:54 <ivanm> which lang are you doing it in?
20:35:59 <pastorn> Axman6: they will pay for your food?
20:36:02 <Axman6> Postgres...
20:36:11 <ivanm> just SQL?
20:36:14 <Axman6> yes
20:36:16 <ivanm> no front-ends or anything?
20:36:18 <Axman6> well, we code some JDBC
20:36:21 <FunctorSalad> Gracenotes: doesn't matter for newIORef, does it?
20:36:31 <ivanm> Axman6: *shudder* what I was afraid of
20:36:31 <FunctorSalad> but it would matter if the newIORef gets inlined
20:36:32 <Axman6> s/code/cover... but code works too
20:36:38 <ivanm> you mean even ANU has the Java infection?
20:36:41 <Rotaerk> hmm sometimes I find myself wondering if a function should just take a GameState value, or just the individual pieces of the GameState that it actually uses
20:37:05 <Axman6> ivanm: they teach it, because it's useful in industry, but they also teach you a lot of other languages
20:37:09 <pastorn> Rotaerk: you in the State monad?
20:37:09 <Gracenotes> FunctorSalad: oh, I'm more thinking about run-once top-level variables that are effectful
20:37:11 <SamB_XP> Axman6: what, no ScalQL?
20:37:13 <ivanm> Axman6: oh, good-o
20:37:13 <Axman6> like, Haskell, C, Asm, Ada etc
20:37:19 <Axman6> Prolog
20:37:20 <ivanm> UQ usually just does Java
20:37:20 <Gracenotes> not thinking about mutability particularly. :/
20:37:29 <ivanm> (with a bit of Python now in first year, replacing scheme)
20:37:31 * Axman6 <3 Ada now
20:37:43 <wdonnelly> Gracenotes: the lack of ordering is the 'AC' part of 'ACIO', as I understand it
20:37:48 <SamB_XP> Axman6: needs better functors, I think...
20:37:51 <Rotaerk> pastorn, well, I try to keep my functions out of the state monad when possible, and then call them from within the state monad
20:38:05 <ivanm> Axman6: heresy!
20:38:07 <FunctorSalad> "associative commutative"?
20:38:15 <wdonnelly> "Affine Central", IIRC
20:38:20 <Axman6> if you've ever done concurrency in Ada, you'll know what i'm on about
20:38:21 <FunctorSalad> ah :)
20:38:24 <pastorn> Rotaerk: seems like a good choice for some of the functions, but for most you should be in the state monad
20:38:28 <Rotaerk> pastorn, so it doesn't take a "State GameState ()", it just takes a "GameState"
20:38:31 <Axman6> it has fantastic concurrecny primitives
20:38:36 <FunctorSalad> "affine" in some linear types sense?
20:38:47 <SamB_XP> wdonnelly: what is the IO part ?
20:39:04 <pastorn> Rotaerk: if you're inside the state monad stuff is easier
20:39:15 <ivanm> Axman6: well, going by the wikipedia examples, it's rather an ugly language syntactically
20:39:17 <aavogt> @googleit lmgtfy&l=1
20:39:17 <lambdabot> http://letmegooglethatforyou.com/?q=lmgtfy&l=1
20:39:18 <wdonnelly> FunctorSalad: probably. I don't know enough about all that theory to say for certain. there's a page about it on haskellwiki
20:39:20 <ivanm> better than Java, but still...
20:39:24 <SamB_XP> Axman6: huh, the VHDL variant has pretty run-of-the-mill concurrency ...
20:39:29 <pastorn> remember, the state monad simplifies things, you want to be there
20:39:45 <Rotaerk> hmm k
20:40:02 <Rotaerk> hmm actually, one thing I've been wondering about... I have a Game type which is "StateT GameState IO"
20:40:12 <wdonnelly> SamB_XP: what's the IO mean in the IO monad? it's not all input and output even there
20:40:13 <Axman6> ivanm: indeed, but you get over than when you realise how nice it is to write concurrent programs in
20:40:24 <pastorn> i'm also making a little game, and for a few functions i'm not in the state monad, but i keep the typ signature to :: a -> b -> c -> GameState -> GameState
20:40:32 <Rotaerk> is it easy enough to use types that are just in "State GameState", from within a Game
20:40:38 <pastorn> <3 <3 <3 modify without lambdas <3 <3 <3
20:40:48 <SamB_XP> wdonnelly: I was wondering if it by any chance meant something almost entirely different from input and output ;-P
20:41:17 <pastorn> Rotaerk: you mean functions?
20:41:19 <wdonnelly> SamB_XP: ah, I assumed you were just being snarky
20:41:27 <ivanm> Axman6: what concurrency model does it use?
20:41:30 <SamB_XP> more like punchy
20:42:54 <Rotaerk> hmm
20:43:07 <pastorn> Rotaerk: lift :: (State GameState a) -> Game a
20:43:34 <pastorn> so stay out of IO if you can, writing just State-functions
20:43:38 <Axman6> ivanm: tasks, with rendezvous, protected objects (mutually exclusive operations, including guarded entries which won't be executed until the guard is true)... there's other stuff too
20:43:38 <pastorn> and lifting them
20:43:56 <oDric_oClumns> Axman6: You should throw some K/Q into the mix, and really mess with some heads! >:)
20:44:00 <hackagebot> dtrace 0.1 - Haskell interface to the DTrace system tracing utility (AaronTomb)
20:44:19 <Axman6> ontilt: K/Q?
20:44:32 <Axman6> uh BMeph* ;)
20:44:44 <pastorn> but be stay iside the state monad if you're not doing nasty stuff, like lot's n lot's of boring list operations and what not (and hide that stuff in a different module)
20:45:46 <pastorn> Rotaerk: can you divulge the project?
20:45:54 <pastorn> *projects details*
20:46:11 <Rotaerk> the delusion is that it's going to be a tactical RPG
20:46:30 <Rotaerk> the reality is that it's a simple console app with some menus
20:46:39 <Rotaerk> that don't do much yet
20:46:42 <pastorn> Rotaerk: VTY?
20:47:23 <pastorn> or are you a hardcore ansi guy?
20:48:08 <Rotaerk> oh I use windows, and I've just run it from inside GHCi
20:48:09 <Rotaerk> which uses cmd
20:48:13 <pastorn> yeah
20:48:25 <pastorn> i don't know if vty works on windows
20:48:38 <pastorn> you should try out unix, with real consoles
20:48:43 <pastorn> much nicer
20:49:01 <pastorn> you know, ubuntu comes with an "install from within windows"-thingy
20:49:10 <Rotaerk> I've tried linux before; overall i just prefer the windows OS (or am just used to it)
20:49:35 <pastorn> Rotaerk: i don't like it that much, too much clicking
20:49:38 <Rotaerk> in any case changing to a different type of console won't really solve anything
20:49:54 <pastorn> well, vty seems to be pretty sweed
20:50:00 <pastorn> *sweet*
20:50:08 <BMeph> Axman6:  http://en.wikipedia.org/wiki/K_(programming_language)
20:50:12 <pastorn> for doing stuff like what you want
20:50:29 <Rotaerk> like what?
20:51:23 <pastorn> Rotaerk: http://hackage.haskell.org/packages/archive/vty/4.0.0.1/doc/html/Graphics-Vty-Picture.html
20:51:40 <pastorn> so you said you would have a menu and then i'm guessing an action screen
20:51:57 <Rotaerk> oh, well the console app is really just makeshift and temporary
20:52:07 <pastorn> so you just use (<->) or (<|>) to compose them
20:52:07 <Rotaerk> it's going to be used for building up the basic rules for my game
20:52:15 <Rotaerk> but then will eventually use OGL
20:52:52 <pastorn> Rotaerk: i'm sitting writing the ogl tutorials now
20:52:52 <pastorn> i have rotating cubes!! this is awesome!
20:52:55 <Rotaerk> :P
20:53:07 <pastorn> did i mention they have colour?
20:53:14 <pastorn> they all do, DIFFERENT colours
20:53:17 <pastorn> totally rad
20:53:31 <Rotaerk> amazing !
20:53:31 <nvoorhies> sweet
20:54:49 <FunctorSalad> shiny too??
20:54:56 <roconnor> OGL ?= OpenGL
20:54:57 <pastorn> not yet, getting there
20:54:59 <pastorn> yes
20:55:03 <FunctorSalad> !
20:55:05 <pastorn> pixx coming
20:55:08 <roconnor> ooh, the name is getting shorter
20:55:20 <FunctorSalad> letter loss
20:55:50 <nvoorhies> it ends up being GL eventually after you get sick of saying it over and over
20:56:02 <pastorn> http://web.student.chalmers.se/~goranssa/rotating_colours.png
20:56:04 <medfly> and then you just stop talking about it
20:56:31 <pastorn> Rotaerk: check that sweetness
20:56:40 <SamB_XP> nvoorhies: also if you don't want to have to distinguish MesaGL from OpenGL ;-P
20:56:43 <Rotaerk> I'd prefer DX so I don't have to load a bunch of extensions for everything
20:56:59 <Rotaerk> too bad haskell doesn't have a library for it
20:56:59 <nvoorhies> Is mesagl significantly different nowadays?
20:57:09 <SamB_XP> Rotaerk: I fail to see how that improves anything
20:57:10 <Rotaerk> pastorn, purty
20:57:15 <SamB_XP> nvoorhies: name, mostly
20:57:33 <SamB_XP> I think that's the way it's always been
20:57:47 <pastorn> dispPt (x,y,z) = unsafePreservingMatrix $ do
20:57:48 <pastorn>                             color $ Color3 ((x+1)/2)    ((y+1)/2)   ((z+1)/2)
20:57:50 <pastorn>                             translate $ Vector3 x y z
20:57:52 <pastorn>                             cube (0.1::GLfloat) pMode
20:58:20 <pastorn> then i just apply my rotation matrix on all those actions, sorta
20:58:43 <SamB_XP> I guess that's safe, as long as 2 /= 0
20:58:53 <Rotaerk> lol
20:58:56 <pastorn> hehe
20:59:05 <nvoorhies> quickcheck could help assure that 2/=0
20:59:08 <pastorn> SamB_XP: PERFORMANCE!!!!!!!!!!!!!!11111111111
20:59:22 <SamB_XP> @check 2/=0
20:59:23 <lambdabot>   "OK, passed 500 tests."
20:59:25 <SamB_XP> @scheck 2/=0
20:59:26 <lambdabot>   "OK, passed 500 tests."
20:59:30 <SamB_XP> @qcheck 2/=0
20:59:31 <lambdabot>   "OK, passed 500 tests."
20:59:31 <pastorn> scheck?
20:59:41 <ivanm> @help scheck
20:59:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:59:43 <SamB_XP> I dunno if it's actually doing what I want, think of it ...
20:59:45 <SamB_XP> @help check
20:59:46 <lambdabot> check <expr>
20:59:46 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
20:59:47 <ivanm> @slap @help
20:59:48 * lambdabot is overcome by a sudden desire to hurt @help
20:59:57 <SamB_XP> @smallcheck 2/=0
20:59:57 <lambdabot> Unknown command, try @list
21:00:03 <SamB_XP> @small 2/=0
21:00:03 <lambdabot> Maybe you meant: smack spell
21:00:06 <SamB_XP> @help check
21:00:06 <lambdabot> check <expr>
21:00:06 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
21:00:12 <SamB_XP> @help checkmodule
21:00:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:00:16 <SamB_XP> @list check
21:00:16 <lambdabot> check provides: check
21:00:32 <SamB_XP> Cale: what happened to smallcheck ?
21:00:38 <SamB_XP> and/or what plugin is it in?
21:00:57 <copumpkin> > (+1)
21:00:57 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
21:01:01 <copumpkin> it's still loaded
21:01:18 <pastorn> copumpkin: wtf?!?!
21:01:22 <SamB_XP> copumpkin: I meant the plugin to actually invoke it's checking thing
21:01:31 <pastorn> > fromJust
21:01:32 <lambdabot>   * Exception: Maybe.fromJust: Nothing
21:01:41 <copumpkin> > fromMaybe
21:01:41 <roconnor> :D
21:01:41 <lambdabot>   {()->{Nothing->();Just ()->()}}
21:01:53 <jfoutz> > maybe
21:01:53 <lambdabot>   {()->{{()->()}->{Nothing->();Just ()->()}}}
21:01:57 <roconnor> :O
21:02:05 <SamB_XP> > negate
21:02:06 <lambdabot>   {-3->3;-2->2;-1->1;0->0;1->-1;2->-2;3->-3}
21:02:11 <roconnor> > (+)
21:02:11 <pastorn> shit, when did she become so smart?
21:02:12 <lambdabot>   -3->
21:02:12 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
21:02:12 <lambdabot>  -2->
21:02:12 <lambdabot>    {-3->-5;-2->...
21:02:30 <SamB_XP> @hoogle Ordering -> Ordering
21:02:30 <lambdabot> Prelude pred :: Enum a => a -> a
21:02:30 <lambdabot> Prelude succ :: Enum a => a -> a
21:02:30 <lambdabot> Prelude id :: a -> a
21:02:34 <SamB_XP> aww
21:02:41 <roconnor> > id
21:02:41 <pastorn> > compare
21:02:41 <lambdabot>   {()->()}
21:02:42 <lambdabot>   {()->{()->EQ}}
21:02:58 <SamB_XP> > compare :: Int -> Ordering
21:02:59 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
21:02:59 <lambdabot>         against inferr...
21:03:11 <SamB_XP> > compare :: Int -> GHC.Ordering.Ordering
21:03:11 <lambdabot>   Not in scope: type constructor or class `GHC.Ordering.Ordering'
21:03:23 <Saizan_> > compare :: Int -> Int -> Ordering
21:03:24 <lambdabot>   -3->
21:03:24 <lambdabot>    {-3->EQ;-2->LT;-1->LT;0->LT;1->LT;2->LT;3->LT}
21:03:24 <lambdabot>  -2->
21:03:24 <lambdabot>    {-3->GT;-2-...
21:03:32 <SamB_XP> oh, right
21:03:36 <SamB_XP> hehehe
21:04:07 <SamB_XP> > compare :: Ordering->Ordering->Ordering
21:04:08 <lambdabot>   No instance for (Test.SmallCheck.Serial GHC.Ordering.Ordering)
21:04:08 <lambdabot>    arising f...
21:04:11 <SamB_XP> aww
21:04:17 <SamB_XP> > compare :: Bool->Ordering
21:04:18 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
21:04:18 <lambdabot>         against inferr...
21:04:25 <SamB_XP> > compare :: Bool->Bool->Ordering
21:04:25 <lambdabot>   {True->{True->EQ;False->GT};False->{True->LT;False->EQ}}
21:04:49 <copumpkin> > compare :: Ordering -> Ordering -> Ordering
21:04:50 <lambdabot>   No instance for (Test.SmallCheck.Serial GHC.Ordering.Ordering)
21:04:50 <lambdabot>    arising f...
21:05:00 <copumpkin> @slap smallcheck
21:05:00 * lambdabot would never hurt smallcheck!
21:06:57 <pastorn> what happends if i have this? data State = S { angle :: IORef GLFloat }
21:07:39 <Saizan_> hell freezes
21:07:47 <pastorn> a <- newIORef 1
21:07:56 <pastorn> s <- newIORef (S a)
21:08:13 <SamB_XP> pastorn: you end up with too many IORefs ?
21:08:47 <pastorn> and later, when i need to send an ioref to my angle to some function, and modify it, will later readings of my State have the updated value?
21:09:25 <Saizan_> if they readIORef s again they will
21:09:40 <pastorn> Saizan_: cool, thanks :)
21:09:52 <FunctorSalad> btw, Reader monad is enough for passing around the IORefs
21:09:55 <Saizan_> well
21:10:03 <FunctorSalad> unless you actually want to make new Refs for some weird reason
21:10:16 <pastorn> FunctorSalad: true, ReaderT, here i come :D
21:10:20 <Saizan_> depending on the semantics of "modify it" maybe you don't even need to readIORef s again
21:10:38 <Saizan_> if they just writeIORef to a
21:11:25 <FunctorSalad> any values read from the IORef before the write should not be affected
21:12:04 <FunctorSalad> probably misunderstanding you
21:12:14 <pastorn> FunctorSalad: it would be quite silly if they were...
21:12:28 <SamB_XP> rather impossible, too ;-P
21:12:39 <pastorn> SamB_XP: never say that...
21:12:44 <FunctorSalad> hehehe
21:13:17 <lispy> So, I had a heap profile where most of the heap was being consumed by String
21:13:27 <lispy> I refactored the module to use Data.ByteString.Char8
21:13:40 <lispy> I then profiled
21:13:47 <Saizan_> and it's String again?
21:14:01 <lispy> The memory usage was about the same, but the productivity went up about 20%
21:14:04 * FunctorSalad was ambushed by references captured in my closure being mutated (in an evil impure language)
21:14:18 <lispy> I then disabled the profiler and compared them.  The String version is better in almost every measure
21:14:26 <FunctorSalad> (not what they point to, the references themselves! o_O)
21:14:26 <SamB_XP> lispy: strange
21:15:08 <lispy> Saizan_: no, the heap graph shows a lot of improvement
21:15:27 <lispy> Saizan_: String disappears and the ByteString that replaces it uses much less heap
21:15:40 <Saizan_> and you had a lot of gc?
21:15:47 <lispy> But, oddly enough the GC statistics and top show it using more memory overall once the profiler is turned off
21:16:17 <FunctorSalad> hmm list fusion? (random guess)
21:16:20 <lispy> Saizan_: Well, it's about 85% productive without my changes, but yeah it takes about 1GB of virtual memory and 460megs of physical RAM (before my changes to bytestring)
21:16:20 <FunctorSalad> (for the String)
21:16:35 <lispy> lots of GC going on
21:17:35 <lispy> I wonder if I need to make the ByteString version stricter or lazier
21:17:58 <FunctorSalad> maybe try Text? I haven't really used it though
21:18:10 <lispy> dons mentioned Text, what is it exactly?
21:18:12 <FunctorSalad> (of course that wouldn't solve the mystery :))
21:19:07 <Saizan_> Text is a strict-bytestring-backed unicode-aware string datatype, which uses stream fusion
21:19:11 <lispy> I think the function I see as a culprit, I should turn it into id and see what changes
21:19:27 <lispy> Saizan_: ah, then yeah darcs should probably be using it
21:20:09 <Saizan_> i think it uses utf-16 as internal repr, but it might be utf8
21:21:35 <Saizan_> there aren't measurement about the performance vs. bytestring
21:22:26 <lispy> Darcs has a bunch of annoying code because we have to deal carefully with encoding/decoding to/from UTF-8
21:22:48 <lispy> So farming that all out to a nice API and library sounds like a win.  We can improve the performance of the library separately
21:23:20 <Saizan_> maybe bytestring-backed is not technically correct, as it defines its own datatype
21:23:44 <Keiya> Mnah, darcs. I have a bit of a distaste for dvcses in general. Not because of workflow issues or anything, but just because there are too damn many of them and I wind up having to install all of them at one point or another :P
21:24:30 <Keiya> anyway, sleepytime
21:24:37 <lispy> Yeah, I think darcs stands a good chacne of being a rossetta stone in that regard.  The patch calculus is pretty powerful
21:25:47 <Keiya> The rosetta stone would be illegal today because of the DMCA. >_< Anyway, ninght :P
21:26:35 <Xichekolas> anyone got time for a totally newbie question?
21:26:55 <pastorn> Xichekolas: sure
21:27:00 <Xichekolas> how the heck do I get a random number between zero and 1?
21:27:04 <pastorn> hehe
21:27:12 <pastorn> Xichekolas: import System.Random
21:27:35 <Xichekolas> done!
21:27:37 <pastorn> remember, random is filthy stuff, you need to go out into the real world to get you random number generators
21:27:42 <pastorn> (StdGen)
21:27:49 <pastorn> @type newStdGen
21:27:49 <lambdabot> IO StdGen
21:27:58 <pastorn> there you see, it's contaminated
21:28:10 <pastorn> @type random
21:28:11 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
21:28:18 <pastorn> @type randomS
21:28:18 <lambdabot> Not in scope: `randomS'
21:28:24 <pastorn> @type randomR
21:28:24 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
21:28:41 <FunctorSalad> shouldn't this use MonadRandom?
21:28:42 <Xichekolas> yeah, I think my lack of understanding comes down to my piss poor understanding of monads... but I get why it's stateful
21:28:42 <pastorn> there we go, there you have a (a,a) as input, that's your interval
21:28:55 <pastorn> FunctorSalad: newbie question, stay out of this
21:29:00 <Xichekolas> haha
21:29:02 * FunctorSalad hides
21:29:07 <FunctorSalad> :)
21:29:24 <pastorn> Xichekolas: ok, so look at the type signature for randomS
21:29:40 <pastorn> first you feed it two things of what you want to get back
21:29:52 <pastorn> then you feed it a random generator (or "seed")
21:29:57 <Xichekolas> yep
21:30:04 <Xichekolas> and you get back a number and new generator
21:30:04 <pastorn> then when done, you have your random numeber AND a new seed
21:30:09 <pastorn> yup
21:30:25 <pastorn> see, you didn't need to know monads for this :)
21:30:41 <pastorn> well
21:30:46 <Xichekolas> but when I try:
21:30:59 <Xichekolas> randomR (0.0, 1.0) getStdGen
21:31:17 * FunctorSalad thinks random variables are actually a nice example for explaining monads
21:31:23 <Xichekolas> I get some lovely error "cannot infer instance"
21:31:51 <FunctorSalad> try "0.0 :: Double"
21:31:55 <Saizan_> do g <- newStdGen; return $ randomR (0.0,1) g
21:32:00 <pastorn> randomFloat = do { g <- newStdGen; let (rv,_) = randomR (0,1::Float) g; return rv }
21:32:31 <Saizan_> or just "randomRIO (0.0,1)"
21:32:38 <Saizan_> which is the same.
21:32:50 <lispy> :t 0.0
21:32:51 <lambdabot> forall t. (Fractional t) => t
21:33:25 <lispy> ?src randomRIO
21:33:25 <lambdabot> Source not found.
21:33:41 <pastorn> Xichekolas: the parser in haskell is annoying, it tries to keep your value as generic as possible, so when it gets to "randomR" it knows that your values are of Floating a, but not WHICH Floating a, so it dosn't know how it should pick its random number, and fails, leaving you feeling stupid and inadequate
21:34:00 <FunctorSalad> :(
21:34:10 <Saizan_> pastorn: that's not the problem here
21:34:10 <Xichekolas> pastorn: you're right about the stupid and inadequate ;)
21:34:16 <pastorn> hehe
21:34:36 <Saizan_> the problem is that "randomR (0.0, 1.0) getStdGen" tries to use an (IO StdGen) as generator
21:34:42 <Saizan_> when you want to use StdGen
21:35:07 <Saizan_> since there's not RandomGen instance for IO StdGen
21:35:13 <pastorn> Xichekolas: yeah, i told you, once you generate a new StdGet with "newStdGen", it's contaminated
21:35:25 <pastorn> and everything you build from it will be contaminated as well
21:35:40 <pastorn> IO-contamination, biohazard, do not get too close
21:36:09 * Saizan_ waits for the spacesuit methaphor
21:36:18 <pastorn> nah
21:36:26 <pastorn> i don't know that one
21:36:27 <Xichekolas> pastorn: but I could, say, start my program, get a generator, then pass it into a pure function and use it, as long as I repassed the new generator each time right?
21:36:42 <pastorn> yes
21:37:02 <FunctorSalad> yes, the pseudorandom generator itself is pure, you just use IO to get the seed
21:37:09 <pastorn> Xichekolas: exercise: make a function that generates an endless stream of floats between 0 and 1
21:37:26 <Xichekolas> pastorn: still working on a single float
21:37:56 <pastorn> Xichekolas: how much have you used the IO monad?
21:38:21 <Xichekolas> well I started with haskell about a week ago if that tells you
21:38:25 <Xichekolas> basically not at all
21:38:32 <lispy> ?quote unsafePerformSex
21:38:32 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
21:38:49 <Saizan_> Xichekolas: tried this code? "do { g <- newStdGen; let (rv,_) = randomR (0,1::Float) g; return rv }"
21:39:04 <Xichekolas> I've been through Graham Hutton's book and that is it
21:39:08 <Saizan_> ?type do { g <- newStdGen; let (rv,_) = randomR (0,1::Float) g; return rv }
21:39:09 <lambdabot> parse error on input `}'
21:39:13 <jargonjustin> I'm working on a parser for a binary file format that needs to handle the case where part of the file is corrupt. The Data.Binary.Get module has most of what I need, but calls error when a parser fails! I'd really like to have the monad handle the failures gracefully, so I could have something like "tryLookAhead :: Get a -> Get (Maybe a)". Is there a simple way to accomplish this?
21:39:15 <Saizan_> ?type do g <- newStdGen; let (rv,_) = randomR (0,1::Float) g; return rv
21:39:16 <lambdabot> parse error (possibly incorrect indentation)
21:39:25 <Saizan_> ?type do g <- newStdGen; let {(rv,_) = randomR (0,1::Float) g}; return rv
21:39:26 <lambdabot> IO Float
21:39:30 <Saizan_> yay.
21:39:47 <lispy> jargonjustin: Control.Exception.catch IIRC
21:39:49 <lispy> ?hoogle catch
21:39:49 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
21:39:49 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
21:39:49 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
21:39:55 <jargonjustin> lispy: It's in IO
21:40:03 <lispy> jargonjustin: the one in Prelude is no good
21:40:07 <Saizan_> jargonjustin: or use attoparsec which has proper support for errors
21:40:11 <Gracenotes> liftming some fsting or somelike
21:40:48 <jargonjustin> lispy: what do you mean about the one in Prelude?
21:40:50 <pastorn> Xichekolas: as you no doubt have heard, IO is for doing stuff OUTSIDE of the language
21:40:55 <jargonjustin> Saizan_: thanks, taking a look
21:41:05 <FunctorSalad> jargonjustin: http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Get.html#v%3AlookAhead ?
21:41:06 <lispy> jargonjustin: the catch that is defined by the Prelude can't catch much.
21:41:09 <pastorn> ("the language" == pure and nice world where no evil can be)
21:41:27 <pastorn> Xichekolas: and random is as nasty as it gets
21:41:28 <jargonjustin> FunctorSalad: The last sentence is the problem.
21:41:41 <cygnus> jargonjustin: Control.Exception.catch is more general.
21:41:47 <pastorn> Xichekolas: but generatining the actual random values is not
21:41:52 <jargonjustin> cygnus: can I use it outside of IO?
21:42:05 <Saizan_> no.
21:42:22 <pastorn> Xichekolas: so the only nasty stuff is getting the random seed, you with me?
21:42:45 <FunctorSalad> jargonjustin: you could lookahead at the data as some type that will succeed (Word32 or something), but admittedly that's a bit of a workaround
21:42:48 <lispy> jargonjustin: So maybe Control.Exception.catch won't work so well here
21:43:07 <FunctorSalad> (and check whether that Word is corrupted, if possible in your situation)
21:43:20 <lispy> jargonjustin: I have to admit, I didn't try Data.Binary yet
21:43:29 <jargonjustin> FunctorSalad: Yeah, having the error handling hidden in the monad would be big win
21:43:37 <FunctorSalad> (apparently that's what uncheckedLookahead does)
21:44:42 <FunctorSalad> jargonjustin: agreed
21:45:07 <ivanm> how do guarded case expressions look?
21:45:31 <ivanm> case foo of bar -> | g1 = blah; | otherwise = blahO; etc. ?
21:45:33 <Saizan_> case .. of pat | expr -> ..; ..
21:45:43 <lispy> ivanm: close, but use -> instead of /
21:45:44 <lispy> er =
21:45:53 <ivanm> ahhhhh
21:46:00 <lispy> ivanm: and your semi-colon isn't always needed
21:46:03 <ivanm> guards _before_ the patterns
21:46:09 <ivanm> lispy: I was using it as a line-ender ;-)
21:46:13 <Saizan_> no, after the patterns
21:46:17 <Saizan_> but before the ->
21:46:19 <ivanm> oh, right
21:46:23 <ivanm> mis-read what you wrote
21:46:36 <lispy> it's actually just like normal guards
21:46:39 <FunctorSalad> jargonjustin: so I think I agree with Saizan that you need another lib, apparently it's not possible with binary
21:46:49 <lispy> But not as common
21:46:49 <lispy> I used them recently is the only reason I know anything about them :)
21:46:56 <FunctorSalad> (the instances would have to be rewritten to support pure error handling?)
21:47:13 <ivanm> lispy: heh
21:47:24 <ivanm> OK, haskell-src-exts description of them doesn't make sense...
21:47:39 <Saizan_> (nah, they'd just start giving proper errors back)
21:47:50 <ivanm> it says that in a case expression, you have a list of Alt values, where "data Alt = Alt SrcLoc Pat GuardedAlts Binds"
21:47:52 <lispy> MonadError is your friend :)
21:48:13 <Saizan_> ivanm: you can have multiple guards for each pattern
21:48:15 <ivanm> I understood that as meaning that you had your pattern, possibly some guards and then -> Binds
21:48:31 <FunctorSalad> lispy: in the Get situation you mean?
21:48:45 <ivanm> but then it has "data GuardedAlts = UnGuardedAlt Exp | GuardedAlts [GuardedAlt]", so what does "Unguarded foo" mean?
21:48:46 <lispy> FunctorSalad: in life, but yeah seems reasonable there too
21:49:12 <lispy> Okay, so most people would probably rather just use Either or Maybe, but MonadError lets the caller choose
21:49:45 <FunctorSalad> isn't (Either String) the "generic" MonadError already?
21:49:52 <FunctorSalad> it can't do anything but throw strings
21:50:06 <lispy> that's my memory
21:50:13 <Saizan_> if you can return the initial algebra for something, you should
21:50:16 <lispy> that's usually what you want, right?
21:50:42 <Saizan_> FunctorSalad: you can make nicer things instances of Error
21:51:05 <FunctorSalad> Saizan_: I was thinking (Either String) is that initial algebra
21:51:25 <FunctorSalad> (or actually, Either (Maybe String))
21:51:27 <Saizan_> FunctorSalad: depends on the kinds of errors you're generating
21:51:36 <FunctorSalad> (if you want to differentiate noMsg)
21:53:49 <FunctorSalad> (using "algebra" usely, apparently the algebras are error-type-parameterised monads here :))
21:53:53 <FunctorSalad> *losely
21:53:58 <FunctorSalad> *loosely
21:54:03 <FunctorSalad> ...
21:54:49 <FunctorSalad> and the morphisms are monad morphisms preserving the MonadError structure? ;)
21:55:11 <Saizan_> ivanm: the Binds part is for where
21:55:23 <ivanm> Saizan_: yeah, just worked it out myself
21:55:32 <ivanm> but thanks anyway
21:55:55 * ivanm guesses this means that haskell-src-exts implicitly adds bindings groups for anywhere a where statement woudl be legal
21:56:17 <Saizan_> FunctorSalad: i'm fixing the error-type instead of parametrizing it :)
21:57:03 <Saizan_> explicitly, i'd say
22:01:55 <shameface> hello
22:02:20 <shameface> anyone here doing any web-dev?
22:03:08 <ivanm> shameface: using which platform?
22:03:17 * ivanm doesn't, but might be able to give pointers
22:03:30 <ivanm> there's happstack, and a few others I can't recall...
22:03:36 <shameface> Im trying to get the happstack-helpers installed
22:03:47 <shameface> having some problems with hscolour, though
22:03:50 <ivanm> shameface: did you try #happs?
22:03:53 <vegai> "hack" looks most promising for web dev, imho
22:03:59 <shameface> hmm
22:03:59 <ivanm> @hackage hack
22:04:00 <lambdabot> http://hackage.haskell.org/package/hack
22:04:03 <ivanm> haven't heard of that one
22:04:11 <vegai> heard of rack?
22:04:22 <ivanm> *shudder* year-based versioning :s
22:04:24 <ivanm> vegai: nope
22:04:30 <ivanm> I usually try to avoid web dev ;-)
22:04:43 <ivanm> (in fact, I usually try to avoid any development that requires more UI than cmd-line args :p )
22:04:45 <vegai> good idea :P
22:04:56 <shameface> haha, noted
22:04:59 <vegai> unfortunately, people want that junk
22:05:13 <ivanm> vegai: I'll use 'em, just don't want to code 'em ;-)
22:05:20 <shameface> well, it seems to be the norm at the moment
22:07:38 <ivanm> there's an extension that allows "f <- b" usage in pattern guards, isn't there?
22:09:33 <Makoryu`> ivanm: Yep
22:09:56 <ivanm> right, so I do have to take them into account...
22:11:14 <lispy> pattern guards
22:11:25 <lispy> ivanm: you can find those described in the GHC manual
22:11:34 <ivanm> duh, forgot :s
22:11:46 <ivanm> lispy: I just wanted to check that there _was_ an extension, not actually use it ;-)
22:11:53 * ivanm hates using haskell-src-exts
22:16:26 <ivanm> @remember dons [on whether a library is wanted] *yes* put it on Hackage!
22:16:26 <lambdabot> It is stored.
22:16:32 <ivanm> dons: the package whore :p
22:18:06 <Gracenotes> no double meaning here
22:18:25 <ivanm> who said anything about a double meaning?
22:18:52 <Gracenotes> no one
22:22:51 <Makoryu`> @unpl \a b -> when . a $ b
22:22:51 <lambdabot> \ a b -> when (a b)
22:23:35 <Gracenotes> success
22:23:46 <lispy> I almost the whole success!
22:24:07 <lispy> I saw a t-shirt yesterday that read, "I organ donation."
22:24:23 <Makoryu`> I see what they did there
22:31:09 <ivanm> Makoryu`: do you? because I don't...
22:33:34 <lispy> > delete '3' (delete '<' "I <3 organ donation.")
22:33:35 <lambdabot>   "I  organ donation."
22:34:04 * FunctorSalad still doesn't
22:34:56 <stanv_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9745#a9745
22:35:55 <lispy> stanv_: that looks like a homework assignment designed by someone who doesn't understand typeful programming
22:36:58 <lispy> Like reusing 0 as a representative
22:37:46 <Saizan_> well, not that you never use fromMaybe
22:37:56 <lispy> stanv_: I'd recommend defining (!!) so it has type (!!) :: [a] -> Int -> Maybe a
22:38:02 <ivanm> lispy: esp. if they have Maybe
22:38:27 <lispy> stanv_: the read should be pretty easy I would guess
22:38:50 <stanv_> after (!!) definition ?
22:38:57 <lispy> stanv_: yeah
22:39:09 <lispy> stanv_: so how would you define (!!) to return Maybe a?
22:39:19 <stanv_> lispy: it easy
22:39:33 <lispy> stanv_: do you see the rest of the solution then?
22:39:51 <stanv_> I don't know, where is allowe to define helpfull functions.
22:40:08 <stanv_> lispy: with (!!) - yes
22:40:36 <lispy> I don't really see where to use mapMaybe
22:40:47 <lispy> Perhaps you're supposed to use that to defin (!!)
22:41:26 <stanv_> ok. I'll try
22:42:09 <shachaf> stanv_: Note: mapMaybe is usually the function :: (a -> Maybe b) -> [a] -> [b]
22:42:38 <shachaf> What you defined is generally called fmap. :-)
22:43:22 <stanv_> shachaf: :) But author of the book, give self-defined fucntion mapMaybe, I don'y know for what reason
22:43:33 <shachaf> Ah.
22:43:42 <ivanm> "RecStmt [Stmt]	a recursive binding group for arrows" is this referring to Arrows?
22:44:02 <duaneb> sup haskell
22:44:12 <ivanm> no, sup is written in Ruby IIRC
22:44:13 <ivanm> ;-)
22:44:31 <duaneb> So, this function has a return type of ForeignPtr ()
22:44:45 <duaneb> how can I ``cast'' whatever that points to into my type?
22:45:08 <ivanm> @hoogle ForeignPtr
22:45:09 <lambdabot> module Foreign.ForeignPtr
22:45:09 <lambdabot> Foreign.ForeignPtr data ForeignPtr a
22:45:09 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
22:45:10 <duaneb> which is, in this case, a CULong
22:45:40 <duaneb> yep, that's the one
22:45:41 <BMeph> duaneb: UR DOIN IT RONG!!! >:|
22:45:46 <duaneb> :P
22:45:54 <duaneb> I am, essentially, writing c in haskell
22:45:59 <duaneb> and it ain't no fun
22:46:04 <duaneb> meaning, tons of fun
22:46:23 <Saizan_> ?hoogle cast
22:46:23 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
22:46:23 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
22:46:23 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
22:46:30 <BMeph> duaneb: That ^^ is intentional. And extensional, but for different reasons. ;p
22:46:39 <duaneb> ok
22:46:49 <duaneb> well, it doesn't change the fact that I have to deal with a ForeignPtr () :P
22:47:02 <Saizan_> duaneb: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html#v%3AcastForeignPtr
22:47:25 <duaneb> excellent :)
23:08:46 <dolio> Heh. Oleg was bored on a flight one day, so he wrote two (mini) haskell interpreters.
23:12:41 <jargonjustin> Under GHC 6.10.4 with -XOverloadedStrings, doing a "foo" :: ByteString gives no instance (IsString ByteString), am I missing something? http://www.haskell.org/ghc/docs/6.10.2/html/libraries/bytestring/Data-ByteString.html#t%3AByteString
23:12:55 <duaneb> err
23:12:59 <duaneb> this sounds rather strange
23:13:11 <duaneb> But given IO t
23:13:54 <duaneb> how can I use a function f :: a -> IO b?
23:14:01 <duaneb> sorry, f :: t -> IO b
23:14:19 <dolio> @type (>>=)
23:14:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:14:43 <duaneb> oh.
23:14:45 <duaneb> I feel stupid now
23:17:11 <dolio> Hey, I completely forget about monads all the time. :)
23:17:42 <duaneb> I felt as if (>>=) took a function instead of a monad
23:17:47 <duaneb> or something
23:17:52 <duaneb> my mind thinks strangely
23:18:02 <Cale> Well, it takes an action and a function :)
23:18:14 <Cale> Perhaps you were thinking of...
23:18:19 <Cale> :t (>=>)
23:18:19 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
23:23:01 <duaneb> > (return "4" ::IO String) >>= (liftM (\s -> ("It's a " ++ s))) >>= putStrLn
23:23:02 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
23:23:02 <lambdabot>         against inferred ty...
23:23:13 <duaneb> why does that not work?
23:23:23 <duaneb> I can't figure out what s :: Char instead of s :: [Char]
23:23:56 <tommd> String = [Char]
23:24:03 <duaneb> well, yes
23:24:27 <duaneb> > (return "4" ::IO [Char]) >>= (liftM (\s -> ("It's a " ++ s))) >>= putStrLn
23:24:28 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
23:24:28 <lambdabot>         against inferred ty...
23:24:38 <duaneb> but s should be a list, no?
23:25:20 <tommd> (return "4" ::IO [Char]) >>= return . (\s -> ("It's a " ++ s)) >>= putStrLn
23:25:24 <tommd> > (return "4" ::IO [Char]) >>= return . (\s -> ("It's a " ++ s)) >>= putStrLn
23:25:25 <lambdabot>   <IO ()>
23:25:48 <BMeph> :t liftM (\s -> ("It's a " ++ s))
23:25:49 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char] -> m [Char]
23:25:52 <duaneb> d'oh
23:29:33 <duaneb> what's the case equivalent of `default'?
23:30:16 <BMeph> duaneb: 'True'
23:30:29 <duaneb> yea, but doesn't that overlap?
23:30:36 <duaneb> wait, isn't True a bool?
23:30:59 <BMeph> duaneb: Except, Haskell cases don't have fall-through. Pity, that. :)
23:33:09 <ClaudiusMaximus> > case False of { True -> "true" ; _ -> "default or something" }
23:33:10 <lambdabot>   "default or something"
23:34:55 <duaneb> also, what on earth is a ForeignPtr? I'm trying to convert a ForeignPtr monad to an IO monad
23:35:09 <duaneb> ah, nm
23:35:34 <BMeph> Technically, it's "_ | True", alternately "_ | otherwise". :)
23:38:55 <BMeph> > case (2+3) of { 1 -> "One." ; _ | True -> "Not One." }
23:38:55 <lambdabot>   "Not One."
23:40:09 <lpsmith> @def otherwise
23:40:09 <lambdabot> Maybe you meant: bf do let
23:40:43 <lpsmith> @src otherwise
23:40:43 <lambdabot> otherwise = True
23:41:01 <lpsmith> otherwise && False
23:41:03 <lpsmith> > otherwise && False
23:41:04 <lambdabot>   False
23:41:58 <BMeph> @type lift
23:41:59 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
23:47:18 <BMeph> @type liftIO
23:47:19 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
23:47:32 <BMeph> @instances-importing MonadIO
23:47:32 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
23:48:22 <jargonjustin> Will GHC represent a type (# a, b #) in the same way as data T a b = T !a !b?
23:49:33 <lpsmith> not quite
23:50:29 <lpsmith> (# a, b #) isn't a fully general first-class value,  you can't pass it to a function, for example
23:51:24 <lpsmith> but T !a !b will often become (# a, b #) through the worker-wrapper transform, when compiled with appropriate flags
23:52:03 <jargonjustin> lpsmith: Hmm, I'm trying build an efficient, failable strict state monad. Something like newtype T a = T { unT :: S -> Either E (# a, S #) }
23:52:18 <jargonjustin> Which won't work because the unboxed tuple can't be placed into Either
23:52:32 <lpsmith> Well, my answer to that would be to use the continuation passing state monad :)
23:53:17 <jargonjustin> lpsmith: Well, more specifically, I'm trying to modify the Data.Binary.Get module (which currently copies the strict state monad) to fail gracefully instead of calling error
23:53:29 <lpsmith> newtype T r a = T { unT :: (a -> S -> Either E r) -> S -> Either E R)
23:54:13 <danr> lambdabot: are you a bot?
23:54:35 <lpsmith> > product [1..1000]
23:54:36 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
23:54:44 <lpsmith> :-)
23:56:08 <jargonjustin> lpsmith, the type you gave will call the first argument on success, or return a failure result, right?
23:56:19 <jargonjustin> lpsmith, s/call/should call/
23:56:20 <lpsmith> yep
23:56:48 <lpsmith> you call the first argument when you want to "return" something
23:57:25 <jargonjustin> lpsmith: How would I ensure that the resulting Monad is strict? Judicious use of seq?
23:59:28 <lpsmith> it already is
23:59:34 <lpsmith> well
23:59:44 <jargonjustin> lpsmith: Ah, the cps is similar to how seq can be described as well, right?
23:59:47 <lpsmith> depends on the precise form of strictness do you want
